/-
Copyright (c) 2024 Enrico Z. Borba. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Enrico Z. Borba
-/

import Mathlib.Probability.Density
import Mathlib.Probability.Notation
import Mathlib.MeasureTheory.Constructions.Prod.Integral
import Mathlib.Analysis.SpecialFunctions.Integrals
import Mathlib.Probability.Distributions.Uniform

/-!

# Freek ‚Ññ 99: Buffon's Needle

This file proves Theorem 99 from the [100 Theorems List](https://www.cs.ru.nl/~freek/100/), also
known as Buffon's Needle, which gives the probability of a needle of length `l > 0` crossing any
one of infinite vertical lines spaced out `d > 0` apart.

The two cases are proven in `buffon_short` and `buffon_long`.

## Overview of the Proof

We define a random variable `B : Œ© ‚Üí ‚Ñù √ó ‚Ñù` with a uniform distribution on `[-d/2, d/2] √ó [0, œÄ]`.
This represents the needle's x-position and angle with respect to a vertical line. By symmetry, we
need to consider only a single vertical line positioned at `x = 0`. A needle therefore crosses the
vertical line if its projection onto the x-axis contains `0`.

We define a random variable `N : Œ© ‚Üí ‚Ñù` that is `1` if the needle crosses a vertical line, and `0`
otherwise. This is defined as `fun œâ => Set.indicator (needleProjX l (B œâ).1 (B œâ).2) 1 0`.
f
As in many references, the problem is split into two cases, `l ‚â§ d` (`buffon_short`), and `d ‚â§ l`
(`buffon_long`). For both cases, we show that
```lean
‚Ñô[N] = (d * œÄ) ‚Åª¬π *
    ‚à´ Œ∏ in 0..œÄ,
      ‚à´ x in Set.Icc (-d / 2) (d / 2) ‚à© Set.Icc (-Œ∏.sin * l / 2) (Œ∏.sin * l / 2), 1
```
In the short case `l ‚â§ d`, we show that `[-l * Œ∏.sin/2, l * Œ∏.sin/2] ‚äÜ [-d/2, d/2]`
(`short_needle_inter_eq`), and therefore the inner integral simplifies to
```lean
‚à´ x in (-Œ∏.sin * l / 2)..(Œ∏.sin * l / 2), 1 = Œ∏.sin * l
```
Which then concludes in the short case being `‚Ñô[N] = (2 * l) / (d * œÄ)`.

In the long case, `l ‚â§ d` (`buffon_long`), we show the outer integral simplifies to
```lean
‚à´ Œ∏ in 0..œÄ, min d (Œ∏.sin * l)
```
which can be expanded to
```lean
2 * (
  ‚à´ Œ∏ in 0..(d / l).arcsin, min d (Œ∏.sin * l) +
  ‚à´ Œ∏ in (d / l).arcsin..(œÄ / 2), min d (Œ∏.sin * l)
)
```
We then show the two integrals equal their respective values `l - ‚àö(l^2 - d^2)` and
`(œÄ / 2 - (d / l).arcsin) * d`. Then with some algebra we conclude
```lean
‚Ñô[N] = (2 * l) / (d * œÄ) - 2 / (d * œÄ) * (‚àö(l^2 - d^2) + d * (d / l).arcsin) + 1
```

## References

* https://en.wikipedia.org/wiki/Buffon%27s_needle_problem
* https://www.math.leidenuniv.nl/~hfinkeln/seminarium/stelling_van_Buffon.pdf
* https://www.isa-afp.org/entries/Buffons_Needle.html

-/

open MeasureTheory (MeasureSpace IsProbabilityMeasure Measure pdf.IsUniform)
open ProbabilityTheory Real

namespace BuffonsNeedle

variable
  /- Probability theory variables. -/
  {Œ© : Type*} [MeasureSpace Œ©] [IsProbabilityMeasure (‚Ñô : Measure Œ©)]

  /- Buffon's needle variables. -/

  /-
    - `d > 0` is the distance between parallel lines.
    - `l > 0` is the length of the needle.
  -/
  (d l : ‚Ñù)
  (hd : 0 < d)
  (hl : 0 < l)

  /- `B = (X, Œò)` is the joint random variable for the x-position and angle of the needle. -/
  (B : Œ© ‚Üí ‚Ñù √ó ‚Ñù)
  (hB‚Çò : Measurable B)

  /- `B` is uniformly distributed on `[-d/2, d/2] √ó [0, œÄ]`. -/
  (hB : pdf.IsUniform B ((Set.Icc (-d / 2) (d / 2)) √óÀ¢ (Set.Icc 0 œÄ)) ‚Ñô)

/--
  Projection of a needle onto the x-axis. The needle's center is at x-coordinate `x`, of length
  `l` and angle `Œ∏`. Note, `Œ∏` is measured relative to the y-axis, that is, a vertical needle has
  `Œ∏ = 0`.
-/
def needleProjX (x Œ∏ : ‚Ñù) : Set ‚Ñù := Set.Icc (x - Œ∏.sin * l / 2) (x + Œ∏.sin * l / 2)

/--
  The indicator function of whether a needle at position `‚ü®x, Œ∏‚ü© : ‚Ñù √ó ‚Ñù` crosses the line `x = 0`.

  In order to faithfully model the problem, we compose `needleCrossesIndicator` with a random
  variable `B : Œ© ‚Üí ‚Ñù √ó ‚Ñù` with uniform distribution on `[-d/2, d/2] √ó [0, œÄ]`. Then, by symmetry,
  the probability that the needle crosses `x = 0`, is the same as the probability of a needle
  crossing any of the infinitely spaced vertical lines distance `d` apart.
-/
noncomputable def needleCrossesIndicator (p : ‚Ñù √ó ‚Ñù) : ‚Ñù :=
  Set.indicator (needleProjX l p.1 p.2) 1 0

/--
  A random variable representing whether the needle crosses a line.

  The line is at `x = 0`, and therefore a needle crosses the line if its projection onto the x-axis
  contains `0`. This random variable is `1` if the needle crosses the line, and `0` otherwise.
-/
noncomputable def N : Œ© ‚Üí ‚Ñù := needleCrossesIndicator l ‚àò B

/--
  The possible x-positions and angle relative to the y-axis of a needle.
-/
abbrev needleSpace: Set (‚Ñù √ó ‚Ñù) := Set.Icc (-d / 2) (d / 2) √óÀ¢ Set.Icc 0 œÄ

lemma volume_needleSpace : ‚Ñô (needleSpace d) = ENNReal.ofReal (d * œÄ) := by
  simp_rw [MeasureTheory.Measure.volume_eq_prod, MeasureTheory.Measure.prod_prod, Real.volume_Icc,
    ENNReal.ofReal_mul hd.le]
  ring_nf

lemma measurable_needleCrossesIndicator : Measurable (needleCrossesIndicator l) := by
  unfold needleCrossesIndicator
  refine Measurable.indicator measurable_const (IsClosed.measurableSet (IsClosed.inter ?l ?r))
  all_goals simp only [tsub_le_iff_right, zero_add, ‚Üê neg_le_iff_add_nonneg']
  case' l => refine' isClosed_le continuous_fst _
  case' r => refine' isClosed_le (Continuous.neg continuous_fst) _
  all_goals
    refine' Continuous.mul (Continuous.mul _ continuous_const) continuous_const
    simp_rw [‚Üê Function.comp_apply (f := Real.sin) (g := Prod.snd),
      Continuous.comp Real.continuous_sin continuous_snd]

lemma stronglyMeasurable_needleCrossesIndicator :
    MeasureTheory.StronglyMeasurable (needleCrossesIndicator l) := by
  refine stronglyMeasurable_iff_measurable_separable.mpr
    ‚ü®measurable_needleCrossesIndicator l, {0, 1}, ?separable‚ü©
  have range_finite : Set.Finite ({0, 1} : Set ‚Ñù) := by
    simp only [Set.mem_singleton_iff, Set.finite_singleton, Set.Finite.insert]
  refine ‚ü®range_finite.countable, ?subset_closure‚ü©
  rw [IsClosed.closure_eq range_finite.isClosed, Set.subset_def, Set.range]
  intro x ‚ü®p, hxp‚ü©
  by_cases hp : 0 ‚àà needleProjX l p.1 p.2
  ¬∑ simp_rw [needleCrossesIndicator, Set.indicator_of_mem hp, Pi.one_apply] at hxp
    apply Or.inr hxp.symm
  ¬∑ simp_rw [needleCrossesIndicator, Set.indicator_of_not_mem hp] at hxp
    apply Or.inl hxp.symm

lemma integrable_needleCrossesIndicator :
    MeasureTheory.Integrable (needleCrossesIndicator l)
      (Measure.prod
        (Measure.restrict ‚Ñô (Set.Icc (-d / 2) (d / 2)))
        (Measure.restrict ‚Ñô (Set.Icc 0 œÄ))) := by
  have needleCrossesIndicator_nonneg p : 0 ‚â§ needleCrossesIndicator l p := by
    apply Set.indicator_apply_nonneg
    simp only [Pi.one_apply, zero_le_one, implies_true]
  have needleCrossesIndicator_le_one p : needleCrossesIndicator l p ‚â§ 1 := by
    unfold needleCrossesIndicator
    by_cases hp : 0 ‚àà needleProjX l p.1 p.2
    ¬∑ simp_rw [Set.indicator_of_mem hp, Pi.one_apply, le_refl]
    ¬∑ simp_rw [Set.indicator_of_not_mem hp, zero_le_one]
  refine' And.intro
    (stronglyMeasurable_needleCrossesIndicator l).aestronglyMeasurable
    ((MeasureTheory.hasFiniteIntegral_iff_norm (needleCrossesIndicator l)).mpr _)
  refine lt_of_le_of_lt (MeasureTheory.lintegral_mono (g := 1) ?le_const) ?lt_top
  case le_const =>
    intro p
    simp only [Real.norm_eq_abs, abs_of_nonneg (needleCrossesIndicator_nonneg _),
      ENNReal.ofReal_le_one, Pi.one_apply]
    exact needleCrossesIndicator_le_one p
  case lt_top =>
    simp_rw [Pi.one_apply, MeasureTheory.lintegral_const, one_mul, Measure.prod_restrict,
      Measure.restrict_apply MeasurableSet.univ, Set.univ_inter, Measure.prod_prod, Real.volume_Icc,
      neg_div, sub_neg_eq_add, add_halves, sub_zero, ‚Üê ENNReal.ofReal_mul hd.le,
      ENNReal.ofReal_lt_top]

/--
  This is a common step in both the short and the long case to simplify the expectation of the
  needle crossing a line to a double integral.
  ```lean
  ‚à´ (Œ∏ : ‚Ñù) in Set.Icc 0 œÄ,
    ‚à´ (x : ‚Ñù) in Set.Icc (-d / 2) (d / 2) ‚à© Set.Icc (-Œ∏.sin * l / 2) (Œ∏.sin * l / 2), 1
  ```
  The domain of the inner integral is simpler in the short case, where the intersection is
  equal to `Set.Icc (-Œ∏.sin * l / 2) (Œ∏.sin * l / 2)` by `short_needle_inter_eq`.
-/
lemma buffon_integral :
    ùîº[N l B] = (d * œÄ) ‚Åª¬π *
      ‚à´ (Œ∏ : ‚Ñù) in Set.Icc 0 œÄ,
      ‚à´ (x : ‚Ñù) in Set.Icc (-d / 2) (d / 2) ‚à© Set.Icc (-Œ∏.sin * l / 2) (Œ∏.sin * l / 2), 1 := by
  simp_rw [N, Function.comp_apply]
  rw [
    ‚Üê MeasureTheory.integral_map hB‚Çò.aemeasurable
      (stronglyMeasurable_needleCrossesIndicator l).aestronglyMeasurable,
    hB, ProbabilityTheory.cond, MeasureTheory.integral_smul_measure, volume_needleSpace d hd,
    ‚Üê ENNReal.ofReal_inv_of_pos (mul_pos hd Real.pi_pos),
    ENNReal.toReal_ofReal (inv_nonneg.mpr (mul_nonneg hd.le Real.pi_pos.le)), smul_eq_mul,
  ]
  refine' mul_eq_mul_left_iff.mpr (Or.inl _)
  have : MeasureTheory.IntegrableOn (needleCrossesIndicator l)
      (Set.Icc (-d / 2) (d / 2) √óÀ¢ Set.Icc 0 œÄ) := by
    simp_rw [MeasureTheory.IntegrableOn, Measure.volume_eq_prod, ‚Üê Measure.prod_restrict,
      integrable_needleCrossesIndicator d l hd]
  rw [Measure.volume_eq_prod, MeasureTheory.setIntegral_prod _ this,
    MeasureTheory.integral_integral_swap ?integrable]
  case integrable => simp_rw [Function.uncurry_def, Prod.mk.eta,
    integrable_needleCrossesIndicator d l hd]
  simp only [needleCrossesIndicator, needleProjX, Set.mem_Icc]
  have indicator_eq (x Œ∏ : ‚Ñù) :
      Set.indicator (Set.Icc (x - Œ∏.sin * l / 2) (x + Œ∏.sin * l / 2)) 1 0 =
      Set.indicator (Set.Icc (-Œ∏.sin * l / 2) (Œ∏.sin * l / 2)) (1 : ‚Ñù ‚Üí ‚Ñù) x := by
    simp_rw [Set.indicator, Pi.one_apply, Set.mem_Icc, tsub_le_iff_right, zero_add, neg_mul]
    have :
        x ‚â§ Real.sin Œ∏ * l / 2 ‚àß 0 ‚â§ x + Real.sin Œ∏ * l / 2 ‚Üî
        -(Real.sin Œ∏ * l) / 2 ‚â§ x ‚àß x ‚â§ Real.sin Œ∏ * l / 2 := by
      rw [neg_div, and_comm, ‚Üê tsub_le_iff_right, zero_sub]
    by_cases h : x ‚â§ Real.sin Œ∏ * l / 2 ‚àß 0 ‚â§ x + Real.sin Œ∏ * l / 2
    ¬∑ rw [if_pos h, if_pos (this.mp h)]
    ¬∑ rw [if_neg h, if_neg (this.not.mp h)]
  simp_rw [indicator_eq, MeasureTheory.setIntegral_indicator measurableSet_Icc, Pi.one_apply]

/--
  From `buffon_integral`, in both the short and the long case, we have
  ```lean
  ùîº[N l B] = (d * œÄ)‚Åª¬π *
    ‚à´ (Œ∏ : ‚Ñù) in Set.Icc 0 œÄ,
      ‚à´ (x : ‚Ñù) in Set.Icc (-d / 2) (d / 2) ‚à© Set.Icc (-Œ∏.sin * l / 2) (Œ∏.sin * l / 2), 1
  ```
  With this lemma, in the short case, the inner integral's domain simplifies to
  `Set.Icc (-Œ∏.sin * l / 2) (Œ∏.sin * l / 2)`.
-/
lemma short_needle_inter_eq (h : l ‚â§ d) (Œ∏ : ‚Ñù) :
    Set.Icc (-d / 2) (d / 2) ‚à© Set.Icc (-Œ∏.sin * l / 2) (Œ∏.sin * l / 2) =
    Set.Icc (-Œ∏.sin * l / 2) (Œ∏.sin * l / 2) := by
  rw [Set.Icc_inter_Icc, inf_eq_min, sup_eq_max, max_div_div_right zero_le_two,
    min_div_div_right zero_le_two, neg_mul, max_neg_neg, mul_comm,
    min_eq_right (mul_le_of_le_of_le_one_of_nonneg h Œ∏.sin_le_one hl.le)]

/--
  Buffon's Needle, the short case (`l ‚â§ d`). The probability of the needle crossing a line
  equals `(2 * l) / (d * œÄ)`.
-/
theorem buffon_short (h : l ‚â§ d) : ‚Ñô[N l B] = (2 * l) * (d * œÄ)‚Åª¬π := by
  simp_rw [buffon_integral d l hd B hB‚Çò hB, short_needle_inter_eq d l hl h _,
    MeasureTheory.setIntegral_const, Real.volume_Icc, smul_eq_mul, mul_one, mul_comm (d * œÄ)‚Åª¬π _,
    mul_eq_mul_right_iff]
  apply Or.inl
  ring_nf
  have : ‚àÄ·µê Œ∏, Œ∏ ‚àà Set.Icc 0 œÄ ‚Üí ENNReal.toReal (ENNReal.ofReal (Œ∏.sin * l)) = Œ∏.sin * l := by
    have (Œ∏ : ‚Ñù) (hŒ∏ : Œ∏ ‚àà Set.Icc 0 œÄ) : 0 ‚â§ Œ∏.sin * l :=
      mul_nonneg (Real.sin_nonneg_of_mem_Icc hŒ∏) hl.le
    simp_rw [ENNReal.toReal_ofReal_eq_iff, MeasureTheory.ae_of_all _ this]
  simp_rw [MeasureTheory.setIntegral_congr_ae measurableSet_Icc this,
    ‚Üê smul_eq_mul, integral_smul_const, smul_eq_mul, mul_comm, mul_eq_mul_left_iff,
    MeasureTheory.integral_Icc_eq_integral_Ioc, ‚Üê intervalIntegral.integral_of_le Real.pi_pos.le,
    integral_sin, Real.cos_zero, Real.cos_pi, sub_neg_eq_add, one_add_one_eq_two, true_or]

/--
  The integrand in the long case is `min d (Œ∏.sin * l)` and its integrability is necessary for
  the integral lemmas below.
-/
lemma intervalIntegrable_min_const_sin_mul (a b : ‚Ñù) :
    IntervalIntegrable (fun (Œ∏ : ‚Ñù) => min d (Œ∏.sin * l)) ‚Ñô a b := by
  apply Continuous.intervalIntegrable
  exact Continuous.min continuous_const (Continuous.mul Real.continuous_sin continuous_const)

/--
  This equality is useful since `Œ∏.sin` is increasing in `0..œÄ / 2` (but not in `0..œÄ`).
  Then, `‚à´ Œ∏ in (0)..œÄ / 2, min d (Œ∏.sin * l)` can be split into two adjacent integrals, at the
  point where `d = Œ∏.sin * l`, which is `Œ∏ = (d / l).arcsin`.
-/
lemma integral_min_eq_two_mul :
    ‚à´ Œ∏ in (0)..œÄ, min d (Œ∏.sin * l) = 2 * ‚à´ Œ∏ in (0)..œÄ / 2, min d (Œ∏.sin * l) := by
  rw [‚Üê intervalIntegral.integral_add_adjacent_intervals (b := œÄ / 2) (c := œÄ)]
  conv => lhs; arg 2; arg 1; intro Œ∏; rw [‚Üê neg_neg Œ∏, Real.sin_neg]
  simp_rw [intervalIntegral.integral_comp_neg fun Œ∏ => min d (-Œ∏.sin * l), ‚Üê Real.sin_add_pi,
    intervalIntegral.integral_comp_add_right (fun Œ∏ => min d (Œ∏.sin * l)), add_left_neg,
    (by ring : -(œÄ / 2) + œÄ = œÄ / 2), two_mul]
  all_goals exact intervalIntegrable_min_const_sin_mul d l _ _

/--
  The first of two adjacent integrals in the long case. In the range `(0)..(d / l).arcsin`, we
  have that `Œ∏.sin * l ‚â§ d`, and thus the integral is `‚à´ Œ∏ in (0)..(d / l).arcsin, Œ∏.sin * l`.
-/
lemma integral_zero_to_arcsin_min :
    ‚à´ Œ∏ in (0)..(d / l).arcsin, min d (Œ∏.sin * l) = (1 - ‚àö(1 - (d / l) ^ 2)) * l := by
  have : Set.EqOn (fun Œ∏ => min d (Œ∏.sin * l)) (Real.sin ¬∑ * l) (Set.uIcc 0 (d / l).arcsin) := by
    intro Œ∏ ‚ü®hŒ∏‚ÇÅ, hŒ∏‚ÇÇ‚ü©
    have : 0 ‚â§ (d / l).arcsin := Real.arcsin_nonneg.mpr (div_nonneg hd.le hl.le)
    simp only [sup_eq_max, inf_eq_min, min_eq_left this, max_eq_right this] at hŒ∏‚ÇÅ hŒ∏‚ÇÇ
    have hŒ∏_mem : Œ∏ ‚àà Set.Ioc (-(œÄ / 2)) (œÄ / 2) := by
      exact ‚ü®lt_of_lt_of_le (neg_lt_zero.mpr (div_pos Real.pi_pos two_pos)) hŒ∏‚ÇÅ,
        le_trans hŒ∏‚ÇÇ (d / l).arcsin_mem_Icc.right‚ü©
    simp_rw [min_eq_right ((le_div_iff hl).mp ((Real.le_arcsin_iff_sin_le' hŒ∏_mem).mp hŒ∏‚ÇÇ))]
  rw [intervalIntegral.integral_congr this, intervalIntegral.integral_mul_const, integral_sin,
    Real.cos_zero, Real.cos_arcsin]

/--
  The second of two adjacent integrals in the long case. In the range `(d / l).arcsin..(œÄ / 2)`, we
  have that `d ‚â§ Œ∏.sin * l`, and thus the integral is `‚à´ Œ∏ in (d / l).arcsin..(œÄ / 2), d`.
-/
lemma integral_arcsin_to_pi_div_two_min (h : d ‚â§ l) :
    ‚à´ Œ∏ in (d / l).arcsin..(œÄ / 2), min d (Œ∏.sin * l) = (œÄ / 2 - (d / l).arcsin) * d := by
  have : Set.EqOn (fun Œ∏ => min d (Œ∏.sin * l)) (fun _ => d) (Set.uIcc (d / l).arcsin (œÄ / 2)) := by
    intro Œ∏ ‚ü®hŒ∏‚ÇÅ, hŒ∏‚ÇÇ‚ü©
    wlog hŒ∏_ne_pi_div_two : Œ∏ ‚â† œÄ / 2
    ¬∑ simp only [ne_eq, not_not] at hŒ∏_ne_pi_div_two
      simp only [hŒ∏_ne_pi_div_two, Real.sin_pi_div_two, one_mul, min_eq_left h]
    simp only [sup_eq_max, inf_eq_min, min_eq_left (d / l).arcsin_le_pi_div_two,
      max_eq_right (d / l).arcsin_le_pi_div_two] at hŒ∏‚ÇÅ hŒ∏‚ÇÇ
    have hŒ∏_mem : Œ∏ ‚àà Set.Ico (-(œÄ / 2)) (œÄ / 2) := by
      exact ‚ü®le_trans (Real.arcsin_mem_Icc (d / l)).left hŒ∏‚ÇÅ, lt_of_le_of_ne hŒ∏‚ÇÇ hŒ∏_ne_pi_div_two‚ü©
    simp_rw [min_eq_left ((div_le_iff hl).mp ((Real.arcsin_le_iff_le_sin' hŒ∏_mem).mp hŒ∏‚ÇÅ))]
  rw [intervalIntegral.integral_congr this, intervalIntegral.integral_const, smul_eq_mul]

/--
  Buffon's Needle, the long case (`d ‚â§ l`).
-/
theorem buffon_long (h : d ‚â§ l) :
    ‚Ñô[N l B] = (2 * l) / (d * œÄ) - 2 / (d * œÄ) * (‚àö(l^2 - d^2) + d * (d / l).arcsin) + 1 := by
  simp only [
    buffon_integral d l hd B hB‚Çò hB, MeasureTheory.integral_const, smul_eq_mul, mul_one,
    MeasurableSet.univ, Measure.restrict_apply, Set.univ_inter, Set.Icc_inter_Icc, Real.volume_Icc,
    sup_eq_max, inf_eq_min, min_div_div_right zero_le_two d, max_div_div_right zero_le_two (-d),
    div_sub_div_same, neg_mul, max_neg_neg, sub_neg_eq_add, ‚Üê mul_two,
    mul_div_cancel_right‚ÇÄ (min d (Real.sin _ * l)) two_ne_zero
  ]
  have : ‚àÄ·µê Œ∏, Œ∏ ‚àà Set.Icc 0 œÄ ‚Üí
      ENNReal.toReal (ENNReal.ofReal (min d (Œ∏.sin * l))) = min d (Œ∏.sin * l) := by
    have (Œ∏ : ‚Ñù) (hŒ∏ : Œ∏ ‚àà Set.Icc 0 œÄ) : 0 ‚â§ min d (Œ∏.sin * l) := by
      by_cases h : d ‚â§ Œ∏.sin * l
      ¬∑ rw [min_eq_left h]; exact hd.le
      ¬∑ rw [min_eq_right (not_le.mp h).le]; exact mul_nonneg (Real.sin_nonneg_of_mem_Icc hŒ∏) hl.le
    simp_rw [ENNReal.toReal_ofReal_eq_iff, MeasureTheory.ae_of_all _ this]
  rw [MeasureTheory.setIntegral_congr_ae measurableSet_Icc this,
    MeasureTheory.integral_Icc_eq_integral_Ioc,
    ‚Üê intervalIntegral.integral_of_le Real.pi_pos.le, integral_min_eq_two_mul,
    ‚Üê intervalIntegral.integral_add_adjacent_intervals
      (intervalIntegrable_min_const_sin_mul d l _ _) (intervalIntegrable_min_const_sin_mul d l _ _),
    integral_zero_to_arcsin_min d l hd hl, integral_arcsin_to_pi_div_two_min d l hl h]
  field_simp
  ring_nf

end BuffonsNeedle
