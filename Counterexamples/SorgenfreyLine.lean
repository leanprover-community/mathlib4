/-
Copyright (c) 2022 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov

! This file was ported from Lean 3 source module sorgenfrey_line
! leanprover-community/mathlib commit 328375597f2c0dd00522d9c2e5a33b6a6128feeb
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Topology.Instances.Irrational
import Mathbin.Topology.Algebra.Order.Archimedean
import Mathbin.Topology.Paracompact
import Mathbin.Topology.MetricSpace.Metrizable
import Mathbin.Topology.MetricSpace.EmetricParacompact
import Mathbin.Data.Set.Intervals.Monotone

/-!
# Sorgenfrey line

In this file we define `sorgenfrey_line` (notation: `‚Ñù‚Çó`) to be the Sorgenfrey line. It is the real
line with the topology space structure generated by half-open intervals `set.Ico a b`.

We prove that this line is a completely normal Hausdorff space but its product with itself is not a
normal space. In particular, this implies that the topology on `‚Ñù‚Çó` is neither metrizable, nor
second countable.

## Notations

- `‚Ñù‚Çó`: Sorgenfrey line.

## TODO

Prove that the Sorgenfrey line is a paracompact space.

-/


open Set Filter TopologicalSpace

open scoped Topology Filter

namespace Counterexample

noncomputable section

/-- The Sorgenfrey line. It is the real line with the topology space structure generated by
half-open intervals `set.Ico a b`. -/
def SorgenfreyLine : Type :=
  ‚Ñù
deriving ConditionallyCompleteLinearOrder, LinearOrderedField, Archimedean
#align counterexample.sorgenfrey_line Counterexample.SorgenfreyLine

-- mathport name: sorgenfrey_line
scoped[SorgenfreyLine] notation "‚Ñù‚Çó" => SorgenfreyLine

namespace SorgenfreyLine

/-- Ring homomorphism between the Sorgenfrey line and the standard real line. -/
def toReal : ‚Ñù‚Çó ‚âÉ+* ‚Ñù :=
  RingEquiv.refl ‚Ñù
#align counterexample.sorgenfrey_line.to_real Counterexample.SorgenfreyLine.toReal

instance : TopologicalSpace ‚Ñù‚Çó :=
  TopologicalSpace.generateFrom {s : Set ‚Ñù‚Çó | ‚àÉ a b : ‚Ñù‚Çó, Ico a b = s}

theorem isOpen_Ico (a b : ‚Ñù‚Çó) : IsOpen (Ico a b) :=
  TopologicalSpace.GenerateOpen.basic _ ‚ü®a, b, rfl‚ü©
#align counterexample.sorgenfrey_line.is_open_Ico Counterexample.SorgenfreyLine.isOpen_Ico

theorem isOpen_Ici (a : ‚Ñù‚Çó) : IsOpen (Ici a) :=
  iUnion_Ico_right a ‚ñ∏ isOpen_iUnion (isOpen_Ico a)
#align counterexample.sorgenfrey_line.is_open_Ici Counterexample.SorgenfreyLine.isOpen_Ici

theorem nhds_basis_Ico (a : ‚Ñù‚Çó) : (ùìù a).HasBasis (fun b => a < b) fun b => Ico a b :=
  by
  rw [TopologicalSpace.nhds_generateFrom]
  haveI : Nonempty { x // x ‚â§ a } := Set.nonempty_Iic_subtype
  have : (‚®Ö x : { i // i ‚â§ a }, ùìü (Ici ‚Üëx)) = ùìü (Ici a) :=
    by
    refine' (IsLeast.isGLB _).iInf_eq
    exact ‚ü®‚ü®‚ü®a, le_rfl‚ü©, rfl‚ü©, forall_range_iff.2 fun b => principal_mono.2 <| Ici_subset_Ici.2 b.2‚ü©
  simp only [mem_set_of_eq, iInf_and, iInf_exists, @iInf_comm _ (_ ‚àà _), @iInf_comm _ (Set ‚Ñù‚Çó),
    iInf_iInf_eq_right]
  simp_rw [@iInf_comm _ ‚Ñù‚Çó (_ ‚â§ _), iInf_subtype', ‚Üê Ici_inter_Iio, ‚Üê inf_principal, ‚Üê inf_iInf, ‚Üê
    iInf_inf, this, iInf_subtype]
  suffices : (‚®Ö x ‚àà Ioi a, ùìü (Iio x)).HasBasis ((¬∑ < ¬∑) a) Iio; exact this.principal_inf _
  refine' has_basis_binfi_principal _ nonempty_Ioi
  exact directedOn_iff_directed.2 (directed_of_inf fun x y hxy => Iio_subset_Iio hxy)
#align counterexample.sorgenfrey_line.nhds_basis_Ico Counterexample.SorgenfreyLine.nhds_basis_Ico

theorem nhds_basis_Ico_rat (a : ‚Ñù‚Çó) :
    (ùìù a).HasCountableBasis (fun r : ‚Ñö => a < r) fun r => Ico a r :=
  by
  refine'
    ‚ü®(nhds_basis_Ico a).to_hasBasis (fun b hb => _) fun r hr => ‚ü®_, hr, subset.rfl‚ü©,
      Set.to_countable _‚ü©
  rcases exists_rat_btwn hb with ‚ü®r, har, hrb‚ü©
  exact ‚ü®r, har, Ico_subset_Ico_right hrb.le‚ü©
#align counterexample.sorgenfrey_line.nhds_basis_Ico_rat Counterexample.SorgenfreyLine.nhds_basis_Ico_rat

theorem nhds_basis_Ico_inv_pNat (a : ‚Ñù‚Çó) :
    (ùìù a).HasBasis (fun n : ‚Ñï+ => True) fun n => Ico a (a + n‚Åª¬π) :=
  by
  refine'
    (nhds_basis_Ico a).to_hasBasis (fun b hb => _) fun n hn =>
      ‚ü®_, lt_add_of_pos_right _ (inv_pos.2 <| Nat.cast_pos.2 n.Pos), subset.rfl‚ü©
  rcases exists_nat_one_div_lt (sub_pos.2 hb) with ‚ü®k, hk‚ü©
  rw [one_div] at hk 
  rw [‚Üê Nat.cast_add_one] at hk 
  exact ‚ü®k.succ_pnat, trivial, Ico_subset_Ico_right (le_sub_iff_add_le'.1 hk.le)‚ü©
#align counterexample.sorgenfrey_line.nhds_basis_Ico_inv_pnat Counterexample.SorgenfreyLine.nhds_basis_Ico_inv_pNat

theorem nhds_countable_basis_Ico_inv_pNat (a : ‚Ñù‚Çó) :
    (ùìù a).HasCountableBasis (fun n : ‚Ñï+ => True) fun n => Ico a (a + n‚Åª¬π) :=
  ‚ü®nhds_basis_Ico_inv_pNat a, Set.to_countable _‚ü©
#align counterexample.sorgenfrey_line.nhds_countable_basis_Ico_inv_pnat Counterexample.SorgenfreyLine.nhds_countable_basis_Ico_inv_pNat

theorem nhds_antitone_basis_Ico_inv_pNat (a : ‚Ñù‚Çó) :
    (ùìù a).HasAntitoneBasis fun n : ‚Ñï+ => Ico a (a + n‚Åª¬π) :=
  ‚ü®nhds_basis_Ico_inv_pNat a,
    monotone_const.Ico <|
      Antitone.const_add
        (fun k l hkl => inv_le_inv_of_le (Nat.cast_pos.2 k.Pos) (Nat.mono_cast hkl)) _‚ü©
#align counterexample.sorgenfrey_line.nhds_antitone_basis_Ico_inv_pnat Counterexample.SorgenfreyLine.nhds_antitone_basis_Ico_inv_pNat

theorem isOpen_iff {s : Set ‚Ñù‚Çó} : IsOpen s ‚Üî ‚àÄ x ‚àà s, ‚àÉ y > x, Ico x y ‚äÜ s :=
  isOpen_iff_mem_nhds.trans <| forall‚ÇÇ_congr fun x hx => (nhds_basis_Ico x).mem_iff
#align counterexample.sorgenfrey_line.is_open_iff Counterexample.SorgenfreyLine.isOpen_iff

/- ./././Mathport/Syntax/Translate/Basic.lean:638:2: warning: expanding binder collection (x ¬´expr ‚àâ ¬ª s) -/
theorem isClosed_iff {s : Set ‚Ñù‚Çó} : IsClosed s ‚Üî ‚àÄ (x) (_ : x ‚àâ s), ‚àÉ y > x, Disjoint (Ico x y) s :=
  by simp only [‚Üê isOpen_compl_iff, is_open_iff, mem_compl_iff, subset_compl_iff_disjoint_right]
#align counterexample.sorgenfrey_line.is_closed_iff Counterexample.SorgenfreyLine.isClosed_iff

theorem exists_Ico_disjoint_closed {a : ‚Ñù‚Çó} {s : Set ‚Ñù‚Çó} (hs : IsClosed s) (ha : a ‚àâ s) :
    ‚àÉ b > a, Disjoint (Ico a b) s :=
  isClosed_iff.1 hs a ha
#align counterexample.sorgenfrey_line.exists_Ico_disjoint_closed Counterexample.SorgenfreyLine.exists_Ico_disjoint_closed

@[simp]
theorem map_toReal_nhds (a : ‚Ñù‚Çó) : map toReal (ùìù a) = ùìù[‚â•] toReal a :=
  by
  refine' ((nhds_basis_Ico a).map _).eq_of_same_basis _
  simpa only [to_real.image_eq_preimage] using nhdsWithin_Ici_basis_Ico (to_real a)
#align counterexample.sorgenfrey_line.map_to_real_nhds Counterexample.SorgenfreyLine.map_toReal_nhds

theorem nhds_eq_map (a : ‚Ñù‚Çó) : ùìù a = map toReal.symm (ùìù[‚â•] a.toReal) := by
  simp_rw [‚Üê map_to_real_nhds, map_map, (¬∑ ‚àò ¬∑), to_real.symm_apply_apply, map_id']
#align counterexample.sorgenfrey_line.nhds_eq_map Counterexample.SorgenfreyLine.nhds_eq_map

theorem nhds_eq_comap (a : ‚Ñù‚Çó) : ùìù a = comap toReal (ùìù[‚â•] a.toReal) := by
  rw [‚Üê map_to_real_nhds, comap_map to_real.injective]
#align counterexample.sorgenfrey_line.nhds_eq_comap Counterexample.SorgenfreyLine.nhds_eq_comap

@[continuity]
theorem continuous_toReal : Continuous toReal :=
  continuous_iff_continuousAt.2 fun x => by rw [ContinuousAt, tendsto, map_to_real_nhds];
    exact inf_le_left
#align counterexample.sorgenfrey_line.continuous_to_real Counterexample.SorgenfreyLine.continuous_toReal

instance : OrderClosedTopology ‚Ñù‚Çó :=
  ‚ü®isClosed_le_prod.Preimage (continuous_toReal.Prod_map continuous_toReal)‚ü©

instance : ContinuousAdd ‚Ñù‚Çó :=
  by
  refine' ‚ü®continuous_iff_continuousAt.2 _‚ü©
  rintro ‚ü®x, y‚ü©
  simp only [ContinuousAt, nhds_prod_eq, nhds_eq_map, nhds_eq_comap (x + y), prod_map_map_eq,
    tendsto_comap_iff, tendsto_map'_iff, (¬∑ ‚àò ¬∑), ‚Üê nhdsWithin_prod_eq]
  exact (continuous_add.tendsto _).inf (maps_to.tendsto fun x hx => add_le_add hx.1 hx.2)

theorem isClopen_Ici (a : ‚Ñù‚Çó) : IsClopen (Ici a) :=
  ‚ü®isOpen_Ici a, isClosed_Ici‚ü©
#align counterexample.sorgenfrey_line.is_clopen_Ici Counterexample.SorgenfreyLine.isClopen_Ici

theorem isClopen_Iio (a : ‚Ñù‚Çó) : IsClopen (Iio a) := by
  simpa only [compl_Ici] using (is_clopen_Ici a).compl
#align counterexample.sorgenfrey_line.is_clopen_Iio Counterexample.SorgenfreyLine.isClopen_Iio

theorem isClopen_Ico (a b : ‚Ñù‚Çó) : IsClopen (Ico a b) :=
  (isClopen_Ici a).inter (isClopen_Iio b)
#align counterexample.sorgenfrey_line.is_clopen_Ico Counterexample.SorgenfreyLine.isClopen_Ico

instance : TotallyDisconnectedSpace ‚Ñù‚Çó :=
  ‚ü®fun s hs' hs x hx y hy =>
    le_antisymm (hs.subset_clopen (isClopen_Ici x) ‚ü®x, hx, le_rfl‚ü© hy)
      (hs.subset_clopen (isClopen_Ici y) ‚ü®y, hy, le_rfl‚ü© hx)‚ü©

instance : FirstCountableTopology ‚Ñù‚Çó :=
  ‚ü®fun x => (nhds_basis_Ico_rat x).IsCountablyGenerated‚ü©

/-- Sorgenfrey line is a completely normal Hausdorff topological space. -/
instance : T5Space ‚Ñù‚Çó :=
  by
  /- Let `s` and `t` be disjoint closed sets. For each `x ‚àà s` we choose `X x` such that
    `set.Ico x (X x)` is disjoint with `t`. Similarly, for each `y ‚àà t` we choose `Y y` such that
    `set.Ico y (Y y)` is disjoint with `s`. Then `‚ãÉ x ‚àà s, Ico x (X x)` and `‚ãÉ y ‚àà t, Ico y (Y y)` are
    disjoint open sets that include `s` and `t`. -/
  refine' ‚ü®fun s t hd‚ÇÅ hd‚ÇÇ => _‚ü©
  choose! X hX hXd using fun x (hx : x ‚àà s) =>
    exists_Ico_disjoint_closed isClosed_closure (disjoint_left.1 hd‚ÇÇ hx)
  choose! Y hY hYd using fun y (hy : y ‚àà t) =>
    exists_Ico_disjoint_closed isClosed_closure (disjoint_right.1 hd‚ÇÅ hy)
  refine'
    disjoint_of_disjoint_of_mem _
      (bUnion_mem_nhdsSet fun x hx => (is_open_Ico x (X x)).mem_nhds <| left_mem_Ico.2 (hX x hx))
      (bUnion_mem_nhdsSet fun y hy => (is_open_Ico y (Y y)).mem_nhds <| left_mem_Ico.2 (hY y hy))
  simp only [disjoint_Union_left, disjoint_Union_right, Ico_disjoint_Ico]
  intro y hy x hx
  cases' le_total x y with hle hle
  ¬∑
    calc
      min (X x) (Y y) ‚â§ X x := min_le_left _ _
      _ ‚â§ y := (not_lt.1 fun hyx => (hXd x hx).le_bot ‚ü®‚ü®hle, hyx‚ü©, subset_closure hy‚ü©)
      _ ‚â§ max x y := le_max_right _ _
  ¬∑
    calc
      min (X x) (Y y) ‚â§ Y y := min_le_right _ _
      _ ‚â§ x := (not_lt.1 fun hxy => (hYd y hy).le_bot ‚ü®‚ü®hle, hxy‚ü©, subset_closure hx‚ü©)
      _ ‚â§ max x y := le_max_left _ _

theorem denseRange_coe_rat : DenseRange (coe : ‚Ñö ‚Üí ‚Ñù‚Çó) :=
  by
  refine' dense_iff_inter_open.2 _
  rintro U Uo ‚ü®x, hx‚ü©
  rcases is_open_iff.1 Uo _ hx with ‚ü®y, hxy, hU‚ü©
  rcases exists_rat_btwn hxy with ‚ü®z, hxz, hzy‚ü©
  exact ‚ü®z, hU ‚ü®hxz.le, hzy‚ü©, mem_range_self _‚ü©
#align counterexample.sorgenfrey_line.dense_range_coe_rat Counterexample.SorgenfreyLine.denseRange_coe_rat

instance : SeparableSpace ‚Ñù‚Çó :=
  ‚ü®‚ü®_, countable_range _, denseRange_coe_rat‚ü©‚ü©

theorem isClosed_antidiagonal (c : ‚Ñù‚Çó) : IsClosed {x : ‚Ñù‚Çó √ó ‚Ñù‚Çó | x.1 + x.2 = c} :=
  isClosed_singleton.Preimage continuous_add
#align counterexample.sorgenfrey_line.is_closed_antidiagonal Counterexample.SorgenfreyLine.isClosed_antidiagonal

theorem isClopen_Ici_prod (x : ‚Ñù‚Çó √ó ‚Ñù‚Çó) : IsClopen (Ici x) :=
  (Ici_prod_eq x).symm ‚ñ∏ (isClopen_Ici _).Prod (isClopen_Ici _)
#align counterexample.sorgenfrey_line.is_clopen_Ici_prod Counterexample.SorgenfreyLine.isClopen_Ici_prod

/-- Any subset of an antidiagonal `{(x, y) : ‚Ñù‚Çó √ó ‚Ñù‚Çó| x + y = c}` is a closed set. -/
theorem isClosed_of_subset_antidiagonal {s : Set (‚Ñù‚Çó √ó ‚Ñù‚Çó)} {c : ‚Ñù‚Çó}
    (hs : ‚àÄ x : ‚Ñù‚Çó √ó ‚Ñù‚Çó, x ‚àà s ‚Üí x.1 + x.2 = c) : IsClosed s :=
  by
  rw [‚Üê closure_subset_iff_isClosed]
  rintro ‚ü®x, y‚ü© H
  obtain rfl : x + y = c := by
    change (x, y) ‚àà {p : ‚Ñù‚Çó √ó ‚Ñù‚Çó | p.1 + p.2 = c}
    exact closure_minimal (hs : s ‚äÜ {x | x.1 + x.2 = c}) (is_closed_antidiagonal c) H
  rcases mem_closure_iff.1 H (Ici (x, y)) (is_clopen_Ici_prod _).1 le_rfl with
    ‚ü®‚ü®x', y'‚ü©, ‚ü®hx : x ‚â§ x', hy : y ‚â§ y'‚ü©, H‚ü©
  convert H
  ¬∑ refine' hx.antisymm _
    rwa [‚Üê add_le_add_iff_right, hs _ H, add_le_add_iff_left]
  ¬∑ refine' hy.antisymm _
    rwa [‚Üê add_le_add_iff_left, hs _ H, add_le_add_iff_right]
#align counterexample.sorgenfrey_line.is_closed_of_subset_antidiagonal Counterexample.SorgenfreyLine.isClosed_of_subset_antidiagonal

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem nhds_prod_antitone_basis_inv_pNat (x y : ‚Ñù‚Çó) :
    (ùìù (x, y)).HasAntitoneBasis fun n : ‚Ñï+ => Ico x (x + n‚Åª¬π) √óÀ¢ Ico y (y + n‚Åª¬π) :=
  by
  rw [nhds_prod_eq]
  exact (nhds_antitone_basis_Ico_inv_pnat x).Prod (nhds_antitone_basis_Ico_inv_pnat y)
#align counterexample.sorgenfrey_line.nhds_prod_antitone_basis_inv_pnat Counterexample.SorgenfreyLine.nhds_prod_antitone_basis_inv_pNat

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/-- The product of the Sorgenfrey line and itself is not a normal topological space. -/
theorem not_normalSpace_prod : ¬¨NormalSpace (‚Ñù‚Çó √ó ‚Ñù‚Çó) :=
  by
  have h‚ÇÄ : ‚àÄ {n : ‚Ñï+}, (0 : ‚Ñù) < n‚Åª¬π := fun n => inv_pos.2 (Nat.cast_pos.2 n.Pos)
  have h‚ÇÄ' : ‚àÄ {n : ‚Ñï+} {x : ‚Ñù}, x < x + n‚Åª¬π := fun n x => lt_add_of_pos_right _ h‚ÇÄ
  intro
  /- Let `S` be the set of points `(x, y)` on the line `x + y = 0` such that `x` is rational.
    Let `T` be the set of points `(x, y)` on the line `x + y = 0` such that `x` is irrational.
    These sets are closed, see `sorgenfrey_line.is_closed_of_subset_antidiagonal`, and disjoint. -/
  set S := {x : ‚Ñù‚Çó √ó ‚Ñù‚Çó | x.1 + x.2 = 0 ‚àß ‚àÉ r : ‚Ñö, ‚Üër = x.1}
  set T := {x : ‚Ñù‚Çó √ó ‚Ñù‚Çó | x.1 + x.2 = 0 ‚àß Irrational x.1.toReal}
  have hSc : IsClosed S := is_closed_of_subset_antidiagonal fun x hx => hx.1
  have hTc : IsClosed T := is_closed_of_subset_antidiagonal fun x hx => hx.1
  have hd : Disjoint S T := by
    rw [disjoint_iff_inf_le]
    rintro ‚ü®x, y‚ü© ‚ü®‚ü®-, r, rfl : _ = x‚ü©, -, hr‚ü©
    exact r.not_irrational hr
  -- Consider disjoint open sets `U ‚äá S` and `V ‚äá T`.
  rcases normal_separation hSc hTc hd with ‚ü®U, V, Uo, Vo, SU, TV, UV‚ü©
  /- For each point `(x, -x) ‚àà T`, choose a neighborhood
    `Ico x (x + k‚Åª¬π) √óÀ¢ Ico (-x) (-x + k‚Åª¬π) ‚äÜ V`. -/
  have : ‚àÄ x : ‚Ñù‚Çó, Irrational x.toReal ‚Üí ‚àÉ k : ‚Ñï+, Ico x (x + k‚Åª¬π) √óÀ¢ Ico (-x) (-x + k‚Åª¬π) ‚äÜ V :=
    by
    intro x hx
    have hV : V ‚àà ùìù (x, -x) := Vo.mem_nhds (@TV (x, -x) ‚ü®add_neg_self x, hx‚ü©)
    exact (nhds_prod_antitone_basis_inv_pnat _ _).mem_iff.1 hV
  choose! k hkV
  /- Since the set of irrational numbers is a dense GŒ¥ set in the usual topology of `‚Ñù`, there
    exists `N > 0` such that the set `C N = {x : ‚Ñù | irrational x ‚àß k x = N}` is dense in a nonempty
    interval. In other words, the closure of this set has a nonempty interior. -/
  set C : ‚Ñï+ ‚Üí Set ‚Ñù := fun n => closure {x | Irrational x ‚àß k (to_real.symm x) = n}
  have H : {x : ‚Ñù | Irrational x} ‚äÜ ‚ãÉ n, C n := fun x hx =>
    mem_Union.2 ‚ü®_, subset_closure ‚ü®hx, rfl‚ü©‚ü©
  have Hd : Dense (‚ãÉ n, interior (C n)) :=
    is_GŒ¥_irrational.dense_Union_interior_of_closed dense_irrational (fun _ => isClosed_closure) H
  obtain ‚ü®N, hN‚ü© : ‚àÉ n : ‚Ñï+, (interior <| C n).Nonempty; exact nonempty_Union.mp Hd.nonempty
  /- Choose a rational number `r` in the interior of the closure of `C N`, then choose `n ‚â• N > 0`
    such that `Ico r (r + n‚Åª¬π) √ó Ico (-r) (-r + n‚Åª¬π) ‚äÜ U`. -/
  rcases rat.dense_range_cast.exists_mem_open isOpen_interior hN with ‚ü®r, hr‚ü©
  have hrU : ((r, -r) : ‚Ñù‚Çó √ó ‚Ñù‚Çó) ‚àà U := @SU (r, -r) ‚ü®add_neg_self _, r, rfl‚ü©
  obtain ‚ü®n, hnN, hn‚ü© :
    ‚àÉ (n : _) (hnN : N ‚â§ n), Ico (r : ‚Ñù‚Çó) (r + n‚Åª¬π) √óÀ¢ Ico (-r : ‚Ñù‚Çó) (-r + n‚Åª¬π) ‚äÜ U
  exact ((nhds_prod_antitone_basis_inv_pnat _ _).hasBasis_ge N).mem_iff.1 (Uo.mem_nhds hrU)
  /- Finally, choose `x ‚àà Ioo (r : ‚Ñù) (r + n‚Åª¬π) ‚à© C N`. Then `(x, -r)` belongs both to `U` and `V`,
    so they are not disjoint. This contradiction completes the proof. -/
  obtain ‚ü®x, hxn, hx_irr, rfl‚ü© :
    ‚àÉ x : ‚Ñù, x ‚àà Ioo (r : ‚Ñù) (r + n‚Åª¬π) ‚àß Irrational x ‚àß k (to_real.symm x) = N :=
    by
    have : (r : ‚Ñù) ‚àà closure (Ioo (r : ‚Ñù) (r + n‚Åª¬π)) := by rw [closure_Ioo h‚ÇÄ'.ne, left_mem_Icc];
      exact h‚ÇÄ'.le
    rcases mem_closure_iff_nhds.1 this _ (mem_interior_iff_mem_nhds.1 hr) with ‚ü®x', hx', hx'Œµ‚ü©
    exact mem_closure_iff.1 hx' _ isOpen_Ioo hx'Œµ
  refine' UV.le_bot (_ : (to_real.symm x, -‚Üër) ‚àà _)
  refine' ‚ü®hn ‚ü®_, _‚ü©, hkV (to_real.symm x) hx_irr ‚ü®_, _‚ü©‚ü©
  ¬∑ exact Ioo_subset_Ico_self hxn
  ¬∑ exact left_mem_Ico.2 h‚ÇÄ'
  ¬∑ exact left_mem_Ico.2 h‚ÇÄ'
  ¬∑ refine' (nhds_antitone_basis_Ico_inv_pnat (-x)).2 hnN ‚ü®neg_le_neg hxn.1.le, _‚ü©
    simp only [add_neg_lt_iff_le_add', lt_neg_add_iff_add_lt]
    exact hxn.2
#align counterexample.sorgenfrey_line.not_normal_space_prod Counterexample.SorgenfreyLine.not_normalSpace_prod

/-- Topology on the Sorgenfrey line is not metrizable. -/
theorem not_metrizableSpace : ¬¨MetrizableSpace ‚Ñù‚Çó :=
  by
  intro
  letI := metrizable_space_metric ‚Ñù‚Çó
  exact not_normal_space_prod inferInstance
#align counterexample.sorgenfrey_line.not_metrizable_space Counterexample.SorgenfreyLine.not_metrizableSpace

/-- Topology on the Sorgenfrey line is not second countable. -/
theorem not_secondCountableTopology : ¬¨SecondCountableTopology ‚Ñù‚Çó := by intro;
  exact not_metrizable_space (metrizable_space_of_t3_second_countable _)
#align counterexample.sorgenfrey_line.not_second_countable_topology Counterexample.SorgenfreyLine.not_secondCountableTopology

end SorgenfreyLine

end Counterexample

