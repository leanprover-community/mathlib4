/-
Copyright (c) 2022 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov
-/
import Mathlib.Order.Interval.Set.Monotone
import Mathlib.Topology.Instances.Irrational
import Mathlib.Topology.Algebra.Order.Archimedean
import Mathlib.Topology.Compactness.Paracompact
import Mathlib.Topology.Metrizable.Urysohn
import Mathlib.Topology.EMetricSpace.Paracompact
import Mathlib.Topology.Separation.NotNormal
import Mathlib.Topology.Baire.Lemmas
import Mathlib.Topology.Baire.LocallyCompactRegular

/-!
# Sorgenfrey line

In this file we define `SorgenfreyLine` (notation: `‚Ñù‚Çó`) to be the Sorgenfrey line. It is the real
line with the topology space structure generated by half-open intervals `Set.Ico a b`.

We prove that this line is a completely normal Hausdorff space but its product with itself is not a
normal space. In particular, this implies that the topology on `‚Ñù‚Çó` is neither metrizable, nor
second countable.

## Notation

- `‚Ñù‚Çó`: Sorgenfrey line.

## TODO

Prove that the Sorgenfrey line is a paracompact space.

-/


open Set Filter TopologicalSpace

open scoped Topology Filter Cardinal

namespace Counterexample

noncomputable section

/-- The Sorgenfrey line (denoted as `‚Ñù‚Çó` within the `SorgenfreyLine` namespace).
It is the real line with the topology space structure generated by
half-open intervals `Set.Ico a b`. -/
def SorgenfreyLine : Type := ‚Ñù
deriving ConditionallyCompleteLinearOrder, Field, IsStrictOrderedRing, Archimedean

@[inherit_doc]
scoped[SorgenfreyLine] notation "‚Ñù‚Çó" => Counterexample.SorgenfreyLine
open scoped SorgenfreyLine

namespace SorgenfreyLine

/-- Ring homomorphism between the Sorgenfrey line and the standard real line. -/
def toReal : ‚Ñù‚Çó ‚âÉ+* ‚Ñù :=
  RingEquiv.refl ‚Ñù

instance : TopologicalSpace ‚Ñù‚Çó :=
  TopologicalSpace.generateFrom {s : Set ‚Ñù‚Çó | ‚àÉ a b : ‚Ñù‚Çó, Ico a b = s}

theorem isOpen_Ico (a b : ‚Ñù‚Çó) : IsOpen (Ico a b) :=
  TopologicalSpace.GenerateOpen.basic _ ‚ü®a, b, rfl‚ü©

theorem isOpen_Ici (a : ‚Ñù‚Çó) : IsOpen (Ici a) :=
  iUnion_Ico_right a ‚ñ∏ isOpen_iUnion (isOpen_Ico a)

theorem nhds_basis_Ico (a : ‚Ñù‚Çó) : (ùìù a).HasBasis (a < ¬∑) (Ico a ¬∑) := by
  rw [TopologicalSpace.nhds_generateFrom]
  haveI : Nonempty { x // x ‚â§ a } := Set.nonempty_Iic_subtype
  have : (‚®Ö x : { i // i ‚â§ a }, ùìü (Ici ‚Üëx)) = ùìü (Ici a) := by
    refine (IsLeast.isGLB ?_).iInf_eq
    exact ‚ü®‚ü®‚ü®a, le_rfl‚ü©, rfl‚ü©, forall_mem_range.2 fun b => principal_mono.2 <| Ici_subset_Ici.2 b.2‚ü©
  simp only [mem_setOf_eq, iInf_and, iInf_exists, @iInf_comm _ (_ ‚àà _), @iInf_comm _ (Set ‚Ñù‚Çó),
    iInf_iInf_eq_right, mem_Ico]
  simp_rw [@iInf_comm _ ‚Ñù‚Çó (_ ‚â§ _), iInf_subtype', ‚Üê Ici_inter_Iio, ‚Üê inf_principal,
    ‚Üê inf_iInf, ‚Üê iInf_inf, this, iInf_subtype]
  suffices (‚®Ö x ‚àà Ioi a, ùìü (Iio x)).HasBasis (a < ¬∑) Iio from this.principal_inf _
  refine hasBasis_biInf_principal ?_ nonempty_Ioi
  exact directedOn_iff_directed.2 <| Monotone.directed_ge fun x y hxy ‚Ü¶ Iio_subset_Iio hxy

theorem nhds_basis_Ico_rat (a : ‚Ñù‚Çó) :
    (ùìù a).HasCountableBasis (fun r : ‚Ñö => a < r) fun r => Ico a r := by
  refine ‚ü®(nhds_basis_Ico a).to_hasBasis (fun b hb => ?_) fun r hr => ‚ü®_, hr, Subset.rfl‚ü©,
    Set.to_countable _‚ü©
  rcases exists_rat_btwn hb with ‚ü®r, har, hrb‚ü©
  exact ‚ü®r, har, Ico_subset_Ico_right hrb.le‚ü©

theorem nhds_basis_Ico_inv_pnat (a : ‚Ñù‚Çó) :
    (ùìù a).HasBasis (fun _ : ‚Ñï+ => True) fun n => Ico a (a + (n : ‚Ñù‚Çó)‚Åª¬π) := by
  refine (nhds_basis_Ico a).to_hasBasis (fun b hb => ?_) fun n hn =>
    ‚ü®_, lt_add_of_pos_right _ (inv_pos.2 <| Nat.cast_pos.2 n.pos), Subset.rfl‚ü©
  rcases exists_nat_one_div_lt (sub_pos.2 hb) with ‚ü®k, hk‚ü©
  rw [one_div] at hk
  rw [‚Üê Nat.cast_add_one] at hk
  exact ‚ü®k.succPNat, trivial, Ico_subset_Ico_right (le_sub_iff_add_le'.1 hk.le)‚ü©

theorem nhds_countable_basis_Ico_inv_pnat (a : ‚Ñù‚Çó) :
    (ùìù a).HasCountableBasis (fun _ : ‚Ñï+ => True) fun n => Ico a (a + (n : ‚Ñù‚Çó)‚Åª¬π) :=
  ‚ü®nhds_basis_Ico_inv_pnat a, Set.to_countable _‚ü©

theorem nhds_antitone_basis_Ico_inv_pnat (a : ‚Ñù‚Çó) :
    (ùìù a).HasAntitoneBasis fun n : ‚Ñï+ => Ico a (a + (n : ‚Ñù‚Çó)‚Åª¬π) :=
  ‚ü®nhds_basis_Ico_inv_pnat a, monotone_const.Ico <| Antitone.const_add
    (fun k _l hkl => inv_anti‚ÇÄ (Nat.cast_pos.2 k.2)
      (Nat.mono_cast <| Subtype.coe_le_coe.2 hkl)) _‚ü©

theorem isOpen_iff {s : Set ‚Ñù‚Çó} : IsOpen s ‚Üî ‚àÄ x ‚àà s, ‚àÉ y > x, Ico x y ‚äÜ s :=
  isOpen_iff_mem_nhds.trans <| forall‚ÇÇ_congr fun x _ => (nhds_basis_Ico x).mem_iff

theorem isClosed_iff {s : Set ‚Ñù‚Çó} : IsClosed s ‚Üî ‚àÄ x, x ‚àâ s ‚Üí ‚àÉ y > x, Disjoint (Ico x y) s := by
  simp only [‚Üê isOpen_compl_iff, isOpen_iff, mem_compl_iff, subset_compl_iff_disjoint_right]

theorem exists_Ico_disjoint_closed {a : ‚Ñù‚Çó} {s : Set ‚Ñù‚Çó} (hs : IsClosed s) (ha : a ‚àâ s) :
    ‚àÉ b > a, Disjoint (Ico a b) s :=
  isClosed_iff.1 hs a ha

@[simp]
theorem map_toReal_nhds (a : ‚Ñù‚Çó) : map toReal (ùìù a) = ùìù[‚â•] toReal a := by
  refine ((nhds_basis_Ico a).map _).eq_of_same_basis ?_
  simpa only [toReal.image_eq_preimage] using nhdsGE_basis_Ico (toReal a)

theorem nhds_eq_map (a : ‚Ñù‚Çó) : ùìù a = map toReal.symm (ùìù[‚â•] (toReal a)) := by
  simp_rw [‚Üê map_toReal_nhds, map_map, Function.comp_def, toReal.symm_apply_apply, map_id']

theorem nhds_eq_comap (a : ‚Ñù‚Çó) : ùìù a = comap toReal (ùìù[‚â•] (toReal a)) := by
  rw [‚Üê map_toReal_nhds, comap_map toReal.injective]

@[continuity]
theorem continuous_toReal : Continuous toReal :=
  continuous_iff_continuousAt.2 fun x => by
    rw [ContinuousAt, Tendsto, map_toReal_nhds]
    exact inf_le_left

instance : OrderClosedTopology ‚Ñù‚Çó :=
  ‚ü®isClosed_le_prod.preimage (continuous_toReal.prodMap continuous_toReal)‚ü©

instance : ContinuousAdd ‚Ñù‚Çó := by
  refine ‚ü®continuous_iff_continuousAt.2 ?_‚ü©
  rintro ‚ü®x, y‚ü©
  rw [ContinuousAt, nhds_prod_eq, nhds_eq_comap (x + y), tendsto_comap_iff,
    nhds_eq_map, nhds_eq_map, prod_map_map_eq, ‚Üê nhdsWithin_prod_eq, Ici_prod_Ici]
  exact (continuous_add.tendsto _).inf (MapsTo.tendsto fun x hx => add_le_add hx.1 hx.2)

theorem isClopen_Ici (a : ‚Ñù‚Çó) : IsClopen (Ici a) :=
  ‚ü®isClosed_Ici, isOpen_Ici a‚ü©

theorem isClopen_Iio (a : ‚Ñù‚Çó) : IsClopen (Iio a) := by
  simpa only [compl_Ici] using (isClopen_Ici a).compl

theorem isClopen_Ico (a b : ‚Ñù‚Çó) : IsClopen (Ico a b) :=
  (isClopen_Ici a).inter (isClopen_Iio b)

instance : TotallyDisconnectedSpace ‚Ñù‚Çó :=
  ‚ü®fun _ _ hs x hx y hy =>
    le_antisymm (hs.subset_isClopen (isClopen_Ici x) ‚ü®x, hx, left_mem_Ici‚ü© hy)
      (hs.subset_isClopen (isClopen_Ici y) ‚ü®y, hy, left_mem_Ici‚ü© hx)‚ü©

instance : FirstCountableTopology ‚Ñù‚Çó :=
  ‚ü®fun x => (nhds_basis_Ico_rat x).isCountablyGenerated‚ü©

/-- Sorgenfrey line is a completely normal topological space.
    (Hausdorff follows as TotallyDisconnectedSpace ‚Üí T‚ÇÅ) -/
instance : CompletelyNormalSpace ‚Ñù‚Çó := by
  /-
  Let `s` and `t` be disjoint closed sets.
  For each `x ‚àà s` we choose `X x` such that `Set.Ico x (X x)` is disjoint with `t`.
  Similarly, for each `y ‚àà t` we choose `Y y` such that `Set.Ico y (Y y)` is disjoint with `s`.
  Then `‚ãÉ x ‚àà s, Ico x (X x)` and `‚ãÉ y ‚àà t, Ico y (Y y)` are
  disjoint open sets that include `s` and `t`.
  -/
  refine ‚ü®fun s t hd‚ÇÅ hd‚ÇÇ => ?_‚ü©
  choose! X hX hXd using fun x (hx : x ‚àà s) =>
    exists_Ico_disjoint_closed isClosed_closure (disjoint_left.1 hd‚ÇÇ hx)
  choose! Y hY hYd using fun y (hy : y ‚àà t) =>
    exists_Ico_disjoint_closed isClosed_closure (disjoint_right.1 hd‚ÇÅ hy)
  refine disjoint_of_disjoint_of_mem ?_
    (bUnion_mem_nhdsSet fun x hx => (isOpen_Ico x (X x)).mem_nhds <| left_mem_Ico.2 (hX x hx))
    (bUnion_mem_nhdsSet fun y hy => (isOpen_Ico y (Y y)).mem_nhds <| left_mem_Ico.2 (hY y hy))
  simp only [disjoint_iUnion_left, disjoint_iUnion_right, Ico_disjoint_Ico]
  intro y hy x hx
  rcases le_total x y with hle | hle
  ¬∑ calc
      min (X x) (Y y) ‚â§ X x := min_le_left _ _
      _ ‚â§ y := (not_lt.1 fun hyx => (hXd x hx).le_bot ‚ü®‚ü®hle, hyx‚ü©, subset_closure hy‚ü©)
      _ ‚â§ max x y := le_max_right _ _
  ¬∑ calc
      min (X x) (Y y) ‚â§ Y y := min_le_right _ _
      _ ‚â§ x := (not_lt.1 fun hxy => (hYd y hy).le_bot ‚ü®‚ü®hle, hxy‚ü©, subset_closure hx‚ü©)
      _ ‚â§ max x y := le_max_left _ _

theorem denseRange_ratCast : DenseRange ((‚Üë) : ‚Ñö ‚Üí ‚Ñù‚Çó) := by
  refine dense_iff_inter_open.2 ?_
  rintro U Uo ‚ü®x, hx‚ü©
  rcases isOpen_iff.1 Uo _ hx with ‚ü®y, hxy, hU‚ü©
  rcases exists_rat_btwn hxy with ‚ü®z, hxz, hzy‚ü©
  exact ‚ü®z, hU ‚ü®hxz.le, hzy‚ü©, mem_range_self _‚ü©

instance : SeparableSpace ‚Ñù‚Çó :=
  ‚ü®‚ü®_, countable_range _, denseRange_ratCast‚ü©‚ü©

theorem isClosed_antidiagonal (c : ‚Ñù‚Çó) : IsClosed {x : ‚Ñù‚Çó √ó ‚Ñù‚Çó | x.1 + x.2 = c} :=
  isClosed_singleton.preimage continuous_add

theorem isClopen_Ici_prod (x : ‚Ñù‚Çó √ó ‚Ñù‚Çó) : IsClopen (Ici x) :=
  (Ici_prod_eq x).symm ‚ñ∏ (isClopen_Ici _).prod (isClopen_Ici _)

theorem cardinal_antidiagonal (c : ‚Ñù‚Çó) : #{x : ‚Ñù‚Çó √ó ‚Ñù‚Çó | x.1 + x.2 = c} = ùî† := by
  rw [‚Üê Cardinal.mk_real]
  exact Equiv.cardinal_eq ‚ü®fun x ‚Ü¶ toReal x.1.1,
    fun x ‚Ü¶ ‚ü®(toReal.symm x, c - toReal.symm x), by simp‚ü©,
    fun ‚ü®x, hx‚ü© ‚Ü¶ by ext <;> simp [‚Üê hx.out], fun x ‚Ü¶ rfl‚ü©

/-- Any subset of an antidiagonal `{(x, y) : ‚Ñù‚Çó √ó ‚Ñù‚Çó| x + y = c}` is a closed set. -/
theorem isClosed_of_subset_antidiagonal {s : Set (‚Ñù‚Çó √ó ‚Ñù‚Çó)} {c : ‚Ñù‚Çó} (hs : ‚àÄ x ‚àà s, x.1 + x.2 = c) :
    IsClosed s := by
  rw [‚Üê closure_subset_iff_isClosed]
  rintro ‚ü®x, y‚ü© H
  obtain rfl : x + y = c := by
    change (x, y) ‚àà {p : ‚Ñù‚Çó √ó ‚Ñù‚Çó | p.1 + p.2 = c}
    exact closure_minimal (hs : s ‚äÜ {x | x.1 + x.2 = c}) (isClosed_antidiagonal c) H
  rcases mem_closure_iff.1 H (Ici (x, y)) (isClopen_Ici_prod _).2 left_mem_Ici with
    ‚ü®‚ü®x', y'‚ü©, ‚ü®hx : x ‚â§ x', hy : y ‚â§ y'‚ü©, H‚ü©
  convert H
  ¬∑ refine hx.antisymm ?_
    rwa [‚Üê add_le_add_iff_right, hs _ H, add_le_add_iff_left]
  ¬∑ refine hy.antisymm ?_
    rwa [‚Üê add_le_add_iff_left, hs _ H, add_le_add_iff_right]

open Subtype in
instance (c : ‚Ñù‚Çó) : DiscreteTopology {x : ‚Ñù‚Çó √ó ‚Ñù‚Çó | x.1 + x.2 = c} :=
  discreteTopology_iff_forall_isClosed.2 fun C ‚Ü¶ isClosed_induced_iff.2
    ‚ü®val '' C, isClosed_of_subset_antidiagonal <| coe_image_subset _ C,
      preimage_image_eq _ val_injective‚ü©

/-- The Sorgenfrey plane `‚Ñù‚Çó √ó ‚Ñù‚Çó` is not a normal space. -/
theorem not_normalSpace_prod : ¬¨NormalSpace (‚Ñù‚Çó √ó ‚Ñù‚Çó) :=
  (isClosed_antidiagonal 0).not_normal_of_continuum_le_mk (cardinal_antidiagonal _).ge

/-- An antidiagonal is a separable set but is not a separable space. -/
theorem isSeparable_antidiagonal (c : ‚Ñù‚Çó) : IsSeparable {x : ‚Ñù‚Çó √ó ‚Ñù‚Çó | x.1 + x.2 = c} :=
  .of_separableSpace _

/-- An antidiagonal is a separable set but is not a separable space. -/
theorem not_separableSpace_antidiagonal (c : ‚Ñù‚Çó) :
    ¬¨SeparableSpace {x : ‚Ñù‚Çó √ó ‚Ñù‚Çó | x.1 + x.2 = c} := by
  rw [separableSpace_iff_countable, ‚Üê Cardinal.mk_le_aleph0_iff, cardinal_antidiagonal, not_le]
  exact Cardinal.aleph0_lt_continuum

theorem nhds_prod_antitone_basis_inv_pnat (x y : ‚Ñù‚Çó) :
    (ùìù (x, y)).HasAntitoneBasis fun n : ‚Ñï+ => Ico x (x + (n : ‚Ñù‚Çó)‚Åª¬π) √óÀ¢ Ico y (y + (n : ‚Ñù‚Çó)‚Åª¬π) := by
  rw [nhds_prod_eq]
  exact (nhds_antitone_basis_Ico_inv_pnat x).prod (nhds_antitone_basis_Ico_inv_pnat y)

/-- The sets of rational and irrational points of the antidiagonal `{(x, y) | x + y = 0}` cannot be
separated by open neighborhoods. This implies that `‚Ñù‚Çó √ó ‚Ñù‚Çó` is not a normal space. -/
theorem not_separatedNhds_rat_irrational_antidiag :
    ¬¨SeparatedNhds {x : ‚Ñù‚Çó √ó ‚Ñù‚Çó | x.1 + x.2 = 0 ‚àß ‚àÉ r : ‚Ñö, ‚Üër = x.1}
    {x : ‚Ñù‚Çó √ó ‚Ñù‚Çó | x.1 + x.2 = 0 ‚àß Irrational (toReal x.1)} := by
  have h‚ÇÄ : ‚àÄ {n : ‚Ñï+}, 0 < (n : ‚Ñù)‚Åª¬π := inv_pos.2 (Nat.cast_pos.2 (PNat.pos _))
  have h‚ÇÄ' : ‚àÄ {n : ‚Ñï+} {x : ‚Ñù}, x < x + (n : ‚Ñù)‚Åª¬π := lt_add_of_pos_right _ h‚ÇÄ
  /- Let `S` be the set of points `(x, y)` on the line `x + y = 0` such that `x` is rational.
    Let `T` be the set of points `(x, y)` on the line `x + y = 0` such that `x` is irrational.
    These sets are closed, see `SorgenfreyLine.isClosed_of_subset_antidiagonal`, and disjoint. -/
  set S := {x : ‚Ñù‚Çó √ó ‚Ñù‚Çó | x.1 + x.2 = 0 ‚àß ‚àÉ r : ‚Ñö, ‚Üër = x.1}
  set T := {x : ‚Ñù‚Çó √ó ‚Ñù‚Çó | x.1 + x.2 = 0 ‚àß Irrational (toReal x.1)}
  -- Consider disjoint open sets `U ‚äá S` and `V ‚äá T`.
  rintro ‚ü®U, V, Uo, Vo, SU, TV, UV‚ü©
  /- For each point `(x, -x) ‚àà T`, choose a neighborhood
    `Ico x (x + k‚Åª¬π) √óÀ¢ Ico (-x) (-x + k‚Åª¬π) ‚äÜ V`. -/
  have : ‚àÄ x : ‚Ñù‚Çó, Irrational (toReal x) ‚Üí
      ‚àÉ k : ‚Ñï+, Ico x (x + (k : ‚Ñù‚Çó)‚Åª¬π) √óÀ¢ Ico (-x) (-x + (k : ‚Ñù‚Çó)‚Åª¬π) ‚äÜ V := fun x hx ‚Ü¶ by
    have hV : V ‚àà ùìù (x, -x) := Vo.mem_nhds (@TV (x, -x) ‚ü®add_neg_cancel x, hx‚ü©)
    exact (nhds_prod_antitone_basis_inv_pnat _ _).mem_iff.1 hV
  choose! k hkV using this
  /- Since the set of irrational numbers is a dense GŒ¥ set in the usual topology of `‚Ñù`, there
    exists `N > 0` such that the set `C N = {x : ‚Ñù | Irrational x ‚àß k x = N}` is dense in a nonempty
    interval. In other words, the closure of this set has a nonempty interior. -/
  set C : ‚Ñï+ ‚Üí Set ‚Ñù := fun n => closure {x | Irrational x ‚àß k (toReal.symm x) = n}
  have H : {x : ‚Ñù | Irrational x} ‚äÜ ‚ãÉ n, C n := fun x hx =>
    mem_iUnion.2 ‚ü®_, subset_closure ‚ü®hx, rfl‚ü©‚ü©
  have Hd : Dense (‚ãÉ n, interior (C n)) :=
    IsGŒ¥.setOf_irrational.dense_iUnion_interior_of_closed dense_irrational
      (fun _ => isClosed_closure) H
  obtain ‚ü®N, hN‚ü© : ‚àÉ n : ‚Ñï+, (interior <| C n).Nonempty := nonempty_iUnion.mp Hd.nonempty
  /- Choose a rational number `r` in the interior of the closure of `C N`, then choose `n ‚â• N > 0`
    such that `Ico r (r + n‚Åª¬π) √ó Ico (-r) (-r + n‚Åª¬π) ‚äÜ U`. -/
  rcases Rat.denseRange_cast.exists_mem_open isOpen_interior hN with ‚ü®r, hr‚ü©
  have hrU : ((r, -r) : ‚Ñù‚Çó √ó ‚Ñù‚Çó) ‚àà U := @SU (r, -r) ‚ü®add_neg_cancel _, r, rfl‚ü©
  obtain ‚ü®n, hnN, hn‚ü© :
      ‚àÉ n, N ‚â§ n ‚àß Ico (r : ‚Ñù‚Çó) (r + (n : ‚Ñù‚Çó)‚Åª¬π) √óÀ¢ Ico (-r : ‚Ñù‚Çó) (-r + (n : ‚Ñù‚Çó)‚Åª¬π) ‚äÜ U :=
    ((nhds_prod_antitone_basis_inv_pnat _ _).hasBasis_ge N).mem_iff.1 (Uo.mem_nhds hrU)
  /- Finally, choose `x ‚àà Ioo (r : ‚Ñù) (r + n‚Åª¬π) ‚à© C N`. Then `(x, -r)` belongs both to `U` and `V`,
    so they are not disjoint. This contradiction completes the proof. -/
  obtain ‚ü®x, hxn, hx_irr, rfl‚ü© :
      ‚àÉ x : ‚Ñù, x ‚àà Ioo (r : ‚Ñù) (r + (n : ‚Ñù)‚Åª¬π) ‚àß Irrational x ‚àß k (toReal.symm x) = N := by
    have : (r : ‚Ñù) ‚àà closure (Ioo (r : ‚Ñù) (r + (n : ‚Ñù)‚Åª¬π)) := by
      rw [closure_Ioo h‚ÇÄ'.ne, left_mem_Icc]
      exact h‚ÇÄ'.le
    rcases mem_closure_iff_nhds.1 this _ (mem_interior_iff_mem_nhds.1 hr) with ‚ü®x', hx', hx'Œµ‚ü©
    exact mem_closure_iff.1 hx' _ isOpen_Ioo hx'Œµ
  refine UV.le_bot (?_ : (toReal.symm x, -(r : ‚Ñù‚Çó)) ‚àà _)
  refine ‚ü®hn ‚ü®?_, ?_‚ü©, hkV (toReal.symm x) hx_irr ‚ü®?_, ?_‚ü©‚ü©
  ¬∑ exact Ioo_subset_Ico_self hxn
  ¬∑ exact left_mem_Ico.2 h‚ÇÄ'
  ¬∑ exact left_mem_Ico.2 h‚ÇÄ'
  ¬∑ refine (nhds_antitone_basis_Ico_inv_pnat (-x)).2 hnN ‚ü®neg_le_neg hxn.1.le, ?_‚ü©
    simp only [add_neg_lt_iff_le_add', lt_neg_add_iff_add_lt]
    exact hxn.2

/-- Topology on the Sorgenfrey line is not metrizable. -/
theorem not_metrizableSpace : ¬¨MetrizableSpace ‚Ñù‚Çó := by
  intro
  letI := metrizableSpaceMetric ‚Ñù‚Çó
  exact not_normalSpace_prod inferInstance

/-- Topology on the Sorgenfrey line is not second countable. -/
theorem not_secondCountableTopology : ¬¨SecondCountableTopology ‚Ñù‚Çó :=
  fun _ ‚Ü¶ not_metrizableSpace (metrizableSpace_of_t3_secondCountable _)

end SorgenfreyLine

end

end Counterexample
