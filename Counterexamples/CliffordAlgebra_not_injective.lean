/-
Copyright (c) 2021 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser
-/
import Mathlib.Algebra.CharP.Pi
import Mathlib.Algebra.CharP.Quotient
import Mathlib.Algebra.CharP.Two
import Mathlib.Data.MvPolynomial.CommRing
import Mathlib.Data.ZMod.Basic
import Mathlib.LinearAlgebra.CliffordAlgebra.Basic
import Mathlib.LinearAlgebra.Finsupp
import Mathlib.RingTheory.MvPolynomial.Basic
import Mathlib.RingTheory.MvPolynomial.Ideal

/-! # `algebraMap R (CliffordAlgebra Q)` is not always injective.

A formalization of [Darij Grinberg's answer](https://mathoverflow.net/questions/60596/clifford-pbw-theorem-for-quadratic-form/87958#87958)
to a "Clifford PBW theorem for quadratic form" post on MathOverflow, that provides a counterexample
to `Function.Injective (algebraMap R (CliffordAlgebra Q))`.

The outline is that we define:

* $k$ (`Q60596.K`) as the commutative ring $ùîΩ‚ÇÇ[Œ±, Œ≤, Œ≥] / (Œ±¬≤, Œ≤¬≤, Œ≥¬≤)$
* $L$ (`Q60596.L`) as the $k$-module $‚ü®x,y,z‚ü© / ‚ü®Œ±x + Œ≤y + Œ≥z‚ü©$
* $Q$ (`Q60596.Q`) as the quadratic form sending $Q(\overline{ax + by = cz}) = a¬≤ + b¬≤ + c¬≤$

and discover that $Œ±Œ≤Œ≥ ‚â† 0$ as an element of $K$, but $Œ±Œ≤Œ≥ = 0$ as an element of $ùíûl(Q)$.

Some Zulip discussion at https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/.F0.9D.94.BD.E2.82.82.5B.CE.B1.2C.20.CE.B2.2C.20.CE.B3.5D.20.2F.20.28.CE.B1.C2.B2.2C.20.CE.B2.C2.B2.2C.20.CE.B3.C2.B2.29/near/222716333.
-/

noncomputable section

open scoped BigOperators

namespace Q60596

open MvPolynomial

/-- The monomial ideal generated by terms of the form $x_ix_i$. -/
def kIdeal : Ideal (MvPolynomial (Fin 3) (ZMod 2)) :=
  Ideal.span (Set.range fun i => (X i * X i : MvPolynomial (Fin 3) (ZMod 2)))

theorem mem_kIdeal_iff (x : MvPolynomial (Fin 3) (ZMod 2)) :
    x ‚àà kIdeal ‚Üî ‚àÄ m : Fin 3 ‚Üí‚ÇÄ ‚Ñï, m ‚àà x.support ‚Üí ‚àÉ i, 2 ‚â§ m i := by
  have :
      kIdeal = Ideal.span ((monomial ¬∑ (1 : ZMod 2)) '' Set.range (Finsupp.single ¬∑ 2)) := by
    simp_rw [kIdeal, X, monomial_mul, one_mul, ‚Üê Finsupp.single_add, ‚Üê Set.range_comp,
      Function.comp]
  rw [this, mem_ideal_span_monomial_image]
  simp

theorem X0_X1_X2_not_mem_kIdeal : (X 0 * X 1 * X 2 : MvPolynomial (Fin 3) (ZMod 2)) ‚àâ kIdeal := by
  intro h
  simp_rw [mem_kIdeal_iff, support_mul_X, support_X, Finset.map_singleton, addRightEmbedding_apply,
    Finset.mem_singleton, forall_eq, ‚Üê Fin.sum_univ_three fun i => Finsupp.single i 1,
    ‚Üê Finsupp.equivFunOnFinite_symm_eq_sum] at h
  contradiction

theorem mul_self_mem_kIdeal_of_X0_X1_X2_mul_mem {x : MvPolynomial (Fin 3) (ZMod 2)}
    (h : X 0 * X 1 * X 2 * x ‚àà kIdeal) : x * x ‚àà kIdeal := by
  rw [mem_kIdeal_iff] at h
  have : x ‚àà Ideal.span ((X : Fin 3 ‚Üí MvPolynomial _ (ZMod 2)) '' Set.univ) := by
    rw [mem_ideal_span_X_image]
    intro m hm
    simp_rw [mul_assoc, support_X_mul, Finset.map_map, Finset.mem_map,
      Function.Embedding.trans_apply, addLeftEmbedding_apply, forall_exists_index,
      and_imp, forall_apply_eq_imp_iff‚ÇÇ, ‚Üê add_assoc, ‚Üê
      Fin.sum_univ_three fun i => Finsupp.single i 1, ‚Üê Finsupp.equivFunOnFinite_symm_eq_sum,
      Finsupp.add_apply, Finsupp.equivFunOnFinite_symm_apply_toFun] at h
    refine (h _ hm).imp fun i hi => ‚ü®Set.mem_univ _, ?_‚ü©
    rintro hmi
    rw [hmi] at hi
    norm_num at hi
  rw [as_sum x, CharTwo.sum_mul_self]
  refine sum_mem fun m hm => ?_
  rw [mem_kIdeal_iff, monomial_mul]
  intro m' hm'
  obtain rfl := Finset.mem_singleton.1 (support_monomial_subset hm')
  rw [mem_ideal_span_X_image] at this
  obtain ‚ü®i, _, hi‚ü© := this m hm
  simp_rw [‚Üê one_add_one_eq_two]
  refine ‚ü®i, Nat.add_le_add ?_ ?_‚ü© <;> rwa [Nat.one_le_iff_ne_zero]

/-- `ùîΩ‚ÇÇ[Œ±, Œ≤, Œ≥] / (Œ±¬≤, Œ≤¬≤, Œ≥¬≤)` -/
def K : Type _ := _ ‚ß∏ kIdeal

instance : CommRing K := Ideal.Quotient.commRing _

theorem comap_C_kIdeal : kIdeal.comap (C : ZMod 2 ‚Üí+* MvPolynomial (Fin 3) (ZMod 2)) = ‚ä• := by
  refine bot_unique ?_
  refine (Ideal.comap_le_map_of_inverse _ _ _ (constantCoeff_C _)).trans ?_
  rw [kIdeal, Ideal.map_span]
  refine (Ideal.span_le).2 ?_
  rintro x ‚ü®_, ‚ü®i, rfl‚ü©, rfl‚ü©
  rw [RingHom.map_mul, constantCoeff_X, mul_zero, Submodule.bot_coe,
    Set.mem_singleton_iff]

/-- `k` has characteristic 2. -/
instance K.charP : CharP K 2 := by
  dsimp only [K]
  rw [CharP.quotient_iff_le_ker_natCast]
  have : Nat.castRingHom (MvPolynomial (Fin 3) (ZMod 2)) = C.comp (Nat.castRingHom _) := by
    ext1 r; rfl
  rw [this, ‚Üê Ideal.comap_comap, ‚Üê RingHom.comap_ker, comap_C_kIdeal]
  exact Ideal.comap_mono bot_le

/-- The generators of `K`. -/
def K.gen (i : Fin 3) : K := Ideal.Quotient.mk _ (MvPolynomial.X i)

local notation "Œ±" => K.gen 0
local notation "Œ≤" => K.gen 1
local notation "Œ≥" => K.gen 2

/-- The elements above square to zero -/
@[simp]
theorem X_sq (i : Fin 3) : K.gen i * K.gen i = (0 : K) := by
  change Ideal.Quotient.mk _ _ = _
  rw [Ideal.Quotient.eq_zero_iff_mem]
  exact Ideal.subset_span ‚ü®i, rfl‚ü©

/-- If an element multiplied by `Œ±Œ≤Œ≥` is zero then it squares to zero. -/
theorem sq_zero_of_Œ±Œ≤Œ≥_mul {x : K} : Œ± * Œ≤ * Œ≥ * x = 0 ‚Üí x * x = 0 := by
  induction x using Quotient.inductionOn'
  change Ideal.Quotient.mk _ _ = 0 ‚Üí Ideal.Quotient.mk _ _ = 0
  rw [Ideal.Quotient.eq_zero_iff_mem, Ideal.Quotient.eq_zero_iff_mem]
  exact mul_self_mem_kIdeal_of_X0_X1_X2_mul_mem

/-- Though `Œ±Œ≤Œ≥` is not itself zero-/
theorem Œ±Œ≤Œ≥_ne_zero : Œ± * Œ≤ * Œ≥ ‚â† 0 := fun h =>
  X0_X1_X2_not_mem_kIdeal <| Ideal.Quotient.eq_zero_iff_mem.1 h

/-- The 1-form on $K^3$, the kernel of which we will take a quotient by.

Our source uses $Œ±x - Œ≤y - Œ≥z$, though since this is characteristic two we just use $Œ±x + Œ≤y + Œ≥z$.
 -/
@[simps!]
def lFunc : (Fin 3 ‚Üí K) ‚Üí‚Çó[K] K :=
  letI proj : Fin 3 ‚Üí (Fin 3 ‚Üí K) ‚Üí‚Çó[K] K := LinearMap.proj
  Œ± ‚Ä¢ proj 0 + Œ≤ ‚Ä¢ proj 1 + Œ≥ ‚Ä¢ proj 2

/-- The quotient of `K^3` by the specified relation. -/
abbrev L : Type _ := _ ‚ß∏ LinearMap.ker lFunc

/-- The quadratic form corresponding to squaring a single coefficient. -/
def sq {Œπ R : Type*} [CommRing R] (i : Œπ) : QuadraticForm R (Œπ ‚Üí R) :=
  QuadraticForm.sq.comp <| LinearMap.proj i

theorem sq_map_add_char_two {Œπ R : Type*} [CommRing R] [CharP R 2] (i : Œπ) (a b : Œπ ‚Üí R) :
    sq i (a + b) = sq i a + sq i b :=
  CharTwo.add_mul_self _ _

theorem sq_map_sub_char_two {Œπ R : Type*} [CommRing R] [CharP R 2] (i : Œπ) (a b : Œπ ‚Üí R) :
    sq i (a - b) = sq i a - sq i b := by
  haveI : Nonempty Œπ := ‚ü®i‚ü©
  rw [CharTwo.sub_eq_add, CharTwo.sub_eq_add, sq_map_add_char_two]

open scoped BigOperators

/-- The quadratic form (metric) is just euclidean -/
def Q' : QuadraticForm K (Fin 3 ‚Üí K) :=
  ‚àë i, sq i

theorem Q'_add (x y : Fin 3 ‚Üí K) : Q' (x + y) = Q' x + Q' y := by
  simp only [Q', QuadraticForm.sum_apply, sq_map_add_char_two, Finset.sum_add_distrib]

theorem Q'_sub (x y : Fin 3 ‚Üí K) : Q' (x - y) = Q' x - Q' y := by
  simp only [Q', QuadraticForm.sum_apply, sq_map_sub_char_two, Finset.sum_sub_distrib]

theorem Q'_apply (a : Fin 3 ‚Üí K) : Q' a = a 0 * a 0 + a 1 * a 1 + a 2 * a 2 :=
  calc
    Q' a = a 0 * a 0 + (a 1 * a 1 + (a 2 * a 2 + 0)) := rfl
    _ = _ := by ring

theorem Q'_apply_single (i : Fin 3) (x : K) : Q' (Pi.single i x) = x * x :=
  calc
    Q' (Pi.single i x) = ‚àë j : Fin 3, (Pi.single i x * Pi.single i x : Fin 3 ‚Üí K) j := by
      simp [Q', sq]
    _ = _ := by simp_rw [‚Üê Pi.single_mul, Finset.sum_pi_single', Finset.mem_univ, if_pos]

theorem Q'_zero_under_ideal (v : Fin 3 ‚Üí K) (hv : v ‚àà LinearMap.ker lFunc) : Q' v = 0 := by
  rw [LinearMap.mem_ker, lFunc_apply] at hv
  have h0 : Œ± * Œ≤ * Œ≥ * v 0 = 0 := by
    have := congr_arg (Œ≤ * Œ≥ * ¬∑) hv
    simp only [mul_zero, mul_add, ‚Üê mul_assoc] at this
    rw [mul_comm (Œ≤ * Œ≥) Œ±, ‚Üê mul_assoc, mul_right_comm Œ≤ Œ≥ Œ≤, mul_assoc Œ≤ Œ≥ Œ≥, X_sq, X_sq] at this
    simpa only [mul_zero, zero_mul, add_zero, zero_add] using this
  have h1 : Œ± * Œ≤ * Œ≥ * v 1 = 0 := by
    have := congr_arg (Œ± * Œ≥ * ¬∑) hv
    simp only [mul_zero, mul_add, ‚Üê mul_assoc] at this
    rw [mul_right_comm Œ± Œ≥ Œ±, mul_assoc Œ± Œ≥ Œ≥, mul_right_comm Œ± Œ≥ Œ≤, X_sq, X_sq] at this
    simpa only [mul_zero, zero_mul, add_zero, zero_add] using this
  have h2 : Œ± * Œ≤ * Œ≥ * v 2 = 0 := by
    have := congr_arg (Œ± * Œ≤ * ¬∑) hv
    simp only [mul_zero, mul_add, ‚Üê mul_assoc] at this
    rw [mul_right_comm Œ± Œ≤ Œ±, mul_assoc Œ± Œ≤ Œ≤, X_sq, X_sq] at this
    simpa only [mul_zero, zero_mul, add_zero, zero_add] using this
  rw [Q'_apply, sq_zero_of_Œ±Œ≤Œ≥_mul h0, sq_zero_of_Œ±Œ≤Œ≥_mul h1, sq_zero_of_Œ±Œ≤Œ≥_mul h2, add_zero,
    add_zero]

/-- `Q'`, lifted to operate on the quotient space `L`. -/
@[simps!]
def Q : QuadraticForm K L :=
  QuadraticForm.ofPolar
    (fun x =>
      Quotient.liftOn' x Q' fun a b h => by
        rw [Submodule.quotientRel_r_def] at h
        suffices Q' (a - b) = 0 by rwa [Q'_sub, sub_eq_zero] at this
        apply Q'_zero_under_ideal (a - b) h)
    (fun a x => by
      induction x using Quotient.inductionOn
      exact Q'.toFun_smul a _)
    (by rintro ‚ü®x‚ü© ‚ü®x'‚ü© ‚ü®y‚ü©; exact Q'.polar_add_left x x' y)
    (by rintro c ‚ü®x‚ü© ‚ü®y‚ü©; exact Q'.polar_smul_left c x y)

open CliffordAlgebra

/-- Basis vectors in the Clifford algebra -/
def gen (i : Fin 3) : CliffordAlgebra Q := Œπ Q <| Submodule.Quotient.mk (Pi.single i 1)

local notation "x'" => gen 0
local notation "y'" => gen 1
local notation "z'" => gen 2

/-- The basis vectors square to one -/
@[simp]
theorem gen_mul_gen (i) : gen i * gen i = 1 := by
  dsimp only [gen]
  simp_rw [CliffordAlgebra.Œπ_sq_scalar, Q_apply, ‚Üê Submodule.Quotient.mk''_eq_mk,
    Quotient.liftOn'_mk'', Q'_apply_single, mul_one, map_one]

/-- By virtue of the quotient, terms of this form are zero -/
theorem quot_obv : Œ± ‚Ä¢ x' - Œ≤ ‚Ä¢ y' - Œ≥ ‚Ä¢ z' = 0 := by
  dsimp only [gen]
  simp_rw [‚Üê LinearMap.map_smul, ‚Üê LinearMap.map_sub, ‚Üê Submodule.Quotient.mk_smul _ (_ : K),
    ‚Üê Submodule.Quotient.mk_sub]
  convert LinearMap.map_zero _ using 2
  rw [Submodule.Quotient.mk_eq_zero]
  simp (config := {decide := true}) [sub_zero, Ideal.span, Pi.single_apply]

/-- The core of the proof - scaling `1` by `Œ± * Œ≤ * Œ≥` gives zero -/
theorem Œ±Œ≤Œ≥_smul_eq_zero : (Œ± * Œ≤ * Œ≥) ‚Ä¢ (1 : CliffordAlgebra Q) = 0 := by
  suffices Œ± ‚Ä¢ 1 - Œ≤ ‚Ä¢ (y' * x') - Œ≥ ‚Ä¢ (z' * x') = 0 by
    have := congr_arg (fun x => (Œ≤ * Œ≥) ‚Ä¢ x) this
    dsimp only at this
    simp_rw [smul_sub, smul_smul] at this
    rwa [mul_assoc Œ≤ Œ≥ Œ≥, mul_right_comm Œ≤ Œ≥ Œ≤, mul_right_comm Œ≤ Œ≥ Œ±, mul_comm Œ≤ Œ±, X_sq, X_sq,
      zero_mul, mul_zero, zero_smul, zero_smul, sub_zero, sub_zero, smul_zero] at this
  have : (Œ± ‚Ä¢ x' - Œ≤ ‚Ä¢ y' - Œ≥ ‚Ä¢ z') * x' = Œ± ‚Ä¢ 1 - Œ≤ ‚Ä¢ (y' * x') - Œ≥ ‚Ä¢ (z' * x') := by
    simp_rw [sub_mul, smul_mul_assoc, gen_mul_gen]
  rw [‚Üê this]
  rw [quot_obv, zero_mul]

theorem algebraMap_Œ±Œ≤Œ≥_eq_zero : algebraMap K (CliffordAlgebra Q) (Œ± * Œ≤ * Œ≥) = 0 := by
  rw [Algebra.algebraMap_eq_smul_one, Œ±Œ≤Œ≥_smul_eq_zero]

/-- Our final result: for the quadratic form `Q60596.Q`, the algebra map to the Clifford algebra
is not injective, as it sends the non-zero `Œ± * Œ≤ * Œ≥` to zero. -/
theorem algebraMap_not_injective : ¬¨Function.Injective (algebraMap K <| CliffordAlgebra Q) :=
  fun h => Œ±Œ≤Œ≥_ne_zero <| h <| by rw [algebraMap_Œ±Œ≤Œ≥_eq_zero, RingHom.map_zero]

end Q60596

open Q60596 in
/-- The general statement: not every Clifford algebra over a module has an injective algebra map. -/
theorem CliffordAlgebra.not_forall_algebraMap_injective.{v} :
    -- TODO: make `R` universe polymorphic
    ¬¨‚àÄ (R : Type) (M : Type v) [CommRing R] [AddCommGroup M] [Module R M] (Q : QuadraticForm R M),
      Function.Injective (algebraMap R <| CliffordAlgebra Q) :=
  fun h => algebraMap_not_injective fun x y hxy => by
    let uU := ULift.moduleEquiv (R := K) (M := L)
    let uQ := Q.comp uU.toLinearMap
    let f : Q ‚Üíq·µ¢ uQ := { uU.symm with map_app' := fun _ => rfl }
    refine h K (ULift L) (Q.comp uU.toLinearMap) ?_
    let uC := CliffordAlgebra.map f
    have := uC.congr_arg hxy
    rwa [AlgHom.commutes, AlgHom.commutes] at this
