/-
Copyright (c) 2024 Filippo A. E. Nuccio. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Filippo A. E. Nuccio
-/

import Mathlib.Analysis.SpecificLimits.Basic
import Mathlib.Order.Interval.Set.Basic
import Mathlib.Topology.MetricSpace.Pseudo.Defs
import Mathlib.Topology.MetricSpace.Cauchy
import Mathlib.Topology.UniformSpace.Cauchy

/-!
# Discrete uniformities and discrete topology
Exactly as different metrics can induce equivalent topologies on a space, it is possible that
different uniform structures (a notion that generalises that of a metric structure) induce the same
topology on a space. In this file we are concerned in particular with the *discrete topology*,
formalised using the class `DiscreteTopology`, and the *discrete uniformity*, that is the bottom
element of the lattice of uniformities on a type (see `bot_uniformity`).

The theorem `discreteTopology_of_discrete_uniformity` shows that the topology induced by the
discrete uniformity is the discrete one, but it is well-known that the converse might not hold in
general, along the lines of the above discussion. We explicitly produce a metric and a uniform
structure on a space (on `‚Ñï`, actually) that are not discrete, yet induce the discrete topology.

To check that a certain uniformity is not discrete, recall that once a type `Œ±` is endowed with a
uniformity, it is possible to speak about `Cauchy` filters on `a` and it is quite easy to see that
if the uniformity on `a` is the discrete one, a filter is Cauchy if and only if it coincides with
the principal filter `ùìü {x}` (see `Filter.principal`) for some `x : Œ±`. This is the
declaration `UniformSpace.DiscreteUnif.eq_const_of_cauchy` in Mathlib.

A special case of this result is the intuitive observation that a sequence `a : ‚Ñï ‚Üí ‚Ñï` can be a
Cauchy sequence if and only if it is eventually constant: when claiming this equivalence, one is
implicitly endowing `‚Ñï` with the metric inherited from `‚Ñù`, that induces the discrete uniformity
on `‚Ñï`. Hence, the intuition suggesting that a Cauchy sequence, whose
terms are "closer and closer to each other", valued in `‚Ñï` must be eventually constant for
*topological* reasons, namely the fact that `‚Ñï` is a discrete topological space, is *wrong* in the
sense that the reason is intrinsically "metric". In particular, if a non-constant sequence (like
the identity `id : ‚Ñï ‚Üí ‚Ñï` is Cauchy, then the uniformity is certainly *not discrete*.

## The counterexamples

We produce two counterexamples: in the first section `Metric` we construct a metric and in the
second section `SetPointUniformity` we construct a uniformity, explicitly as a filter on `‚Ñï √ó ‚Ñï`.
They basically coincide, and the difference of the examples lies in their flavours.

### The metric

We begin  by defining a metric on `‚Ñï` (see `dist_def`) that
1. Induces the discrete topology, as proven in `TopIsDiscrete`;
2. Is not the discrete metric, in particular because the identity is a Cauchy sequence, as proven
in `idIsCauchy`

The definition is simply `dist m n = |2 ^ (- n : ‚Ñ§) - 2 ^ (- m : ‚Ñ§)|`, and I am grateful to
Anatole Dedecker for his suggestion.

### The point-set-theoretic uniformity
A uniformity on `‚Ñï` is a filter on `‚Ñï √ó ‚Ñï` satisfying some properties: we define a sequence of
subsets `fundamentalEntourage n : (Set ‚Ñï √ó ‚Ñï)` (indexed by `n : ‚Ñï`) and we observe it satisfies the
condition needed to be a basis of a filter: moreover, the filter generated by this basis satisfies
the condition for being a uniformity, and this is the uniformity we put on `‚Ñï`.

For each `n`, the set `fundamentalEntourage n : Set (‚Ñï √ó ‚Ñï)` consists of the `n+1` points
`{(0,0),(1,1)...(n,n)}` on the diagonal; together with the half plane `{(x,y) | n ‚â§ x ‚àß n ‚â§ y}`

That this collection can be used as a filter basis is proven in the definition `counterBasis` and
that the filter `counterBasis.filterBasis` is a uniformity is proven in the definition
`counterCoreUniformity`.

This induces the discrete topology, as proven in `TopIsDiscrete` and the `atTop` filter is Cauchy
(see `atTopIsCauchy`): that this specializes to the statement that the identity sequence
`id : ‚Ñï ‚Üí ‚Ñï` is Cauchy is proven in `idIsCauchy`.

## Implementation details
Since most of the statements evolve around membership of explicit natural numbers (framed by some
inequality) to explicit subsets, many proofs are easily closed by `aesop` or `omega` or `linarith`.

### References
* [N. Bourbaki, *General Topology*, Chapter II][bourbaki1966]
-/

open Set Function Filter Metric

/- We remove the "usual" instances of (discrete) topological space and of (discrete) uniform space
from `‚Ñï`. -/
attribute [-instance] instTopologicalSpaceNat instUniformSpaceNat

section Metric


noncomputable local instance : PseudoMetricSpace ‚Ñï where
  dist := fun n m ‚Ü¶ |2 ^ (- n : ‚Ñ§) - 2 ^ (- m : ‚Ñ§)|
  dist_self := by simp only [zpow_neg, zpow_natCast, sub_self, abs_zero, implies_true]
  dist_comm := fun _ _ ‚Ü¶ abs_sub_comm ..
  dist_triangle := fun _ _ _ ‚Ü¶ abs_sub_le ..

@[simp]
lemma dist_def {n m : ‚Ñï} : dist n m = |2 ^ (-n : ‚Ñ§) - 2 ^ (-m : ‚Ñ§)| := rfl

lemma Int.eq_of_pow_sub_le {d : ‚Ñï} {m n : ‚Ñ§} (hd1 : 1 < d)
    (h : |(d : ‚Ñù) ^ (-m) - d ^ (-n)| < d ^ (-n - 1)) : m = n := by
  have hd0 : 0 < d := one_pos.trans hd1
  replace h : |(1 : ‚Ñù) - d ^ (n - m)| < (d : ‚Ñù)‚Åª¬π := by
    rw [‚Üê mul_lt_mul_iff_of_pos_left (a := (d : ‚Ñù) ^ (-n)) (zpow_pos _ _),
      ‚Üê abs_of_nonneg (a := (d : ‚Ñù) ^ (-n)) (le_of_lt <| zpow_pos _ _), ‚Üê abs_mul, mul_sub, mul_one,
      ‚Üê zpow_add‚ÇÄ <| Nat.cast_ne_zero.mpr (ne_of_gt hd0), sub_eq_add_neg (b := m),
      neg_add_cancel_left, ‚Üê abs_neg, neg_sub,
      abs_of_nonneg (a := (d : ‚Ñù) ^ (-n)) (le_of_lt <| zpow_pos _ _), ‚Üê zpow_neg_one,
      ‚Üê zpow_add‚ÇÄ <| Nat.cast_ne_zero.mpr (ne_of_gt hd0), ‚Üê sub_eq_add_neg]
    ¬∑ exact h
    all_goals exact Nat.cast_pos'.mpr hd0
  by_cases H : (m : ‚Ñ§) ‚â§ n
  ¬∑ obtain ‚ü®a, ha‚ü© := Int.eq_ofNat_of_zero_le (sub_nonneg.mpr H)
    rw [ha, ‚Üê mul_lt_mul_iff_of_pos_left (a := (d : ‚Ñù)) <| Nat.cast_pos'.mpr hd0,
      mul_inv_cancel‚ÇÄ <| Nat.cast_ne_zero.mpr (ne_of_gt hd0),
      ‚Üê abs_of_nonneg (a := (d : ‚Ñù)) <| Nat.cast_nonneg' d, ‚Üê abs_mul,
      show |(d : ‚Ñù) * (1 - |(d : ‚Ñù)| ^ (a : ‚Ñ§))| = |(d : ‚Ñ§) * (1 - |(d : ‚Ñ§)| ^ a)| by norm_cast,
      ‚Üê Int.cast_one (R := ‚Ñù), Int.cast_lt, Int.abs_lt_one_iff, Int.mul_eq_zero,
      sub_eq_zero, eq_comm (a := 1), pow_eq_one_iff_cases] at h
    simp only [Nat.cast_eq_zero, ne_of_gt hd0, Nat.abs_cast, Nat.cast_eq_one, ne_of_gt hd1,
      Int.reduceNeg, reduceCtorEq, false_and, or_self, or_false, false_or] at h
    rwa [h, Nat.cast_zero, sub_eq_zero, eq_comm] at ha
  ¬∑ have h1 : (d : ‚Ñù) ^ (n - m) ‚â§ 1 - (d : ‚Ñù)‚Åª¬π := calc
      (d : ‚Ñù) ^ (n - m) ‚â§ (d : ‚Ñù)‚Åª¬π := by
        rw [‚Üê zpow_neg_one]
        apply zpow_right_mono‚ÇÄ <| Nat.one_le_cast.mpr hd0
        linarith
      _ ‚â§ 1 - (d : ‚Ñù)‚Åª¬π := by
        rw [inv_eq_one_div, one_sub_div <| Nat.cast_ne_zero.mpr (ne_of_gt hd0),
          div_le_div_iff_of_pos_right <| Nat.cast_pos'.mpr hd0, le_sub_iff_add_le]
        norm_cast
    linarith [sub_lt_of_abs_sub_lt_right (a := (1 : ‚Ñù)) (b := d ^ (n - m)) (c := d‚Åª¬π) h]

lemma ball_eq_singleton {n : ‚Ñï} : Metric.ball n ((2 : ‚Ñù) ^ (-n - 1 : ‚Ñ§)) = {n} := by
  ext m
  constructor
  ¬∑ zify [zpow_natCast, mem_ball, dist_def, mem_singleton_iff]
    apply Int.eq_of_pow_sub_le one_lt_two
  ¬∑ intro H
    rw [H, mem_ball, dist_self]
    apply zpow_pos two_pos


theorem TopIsDiscrete : DiscreteTopology ‚Ñï := by
  apply discreteTopology_iff_isOpen_singleton.mpr
  intro
  simpa only [‚Üê ball_eq_singleton] using isOpen_ball

lemma idIsCauchy : CauchySeq (id : ‚Ñï ‚Üí ‚Ñï) := by
  rw [Metric.cauchySeq_iff]
  refine fun Œµ ‚Ü¶ Metric.cauchySeq_iff.mp
    (@cauchySeq_of_le_geometric_two ‚Ñù _ 1 (fun n ‚Ü¶ 2 ^(-n : ‚Ñ§)) fun n ‚Ü¶ le_of_eq ?_) Œµ
  simp only [Nat.cast_add, Nat.cast_one, neg_add_rev, Int.reduceNeg, one_div]
  rw [Real.dist_eq, zpow_add' <| Or.intro_left _ two_ne_zero]
  calc
    |2 ^ (- n : ‚Ñ§) - 2 ^ (-1 : ‚Ñ§) * 2 ^ (- n : ‚Ñ§)|
    _ = |(1 - (2 : ‚Ñù)‚Åª¬π) * 2 ^ (- n : ‚Ñ§)| := by rw [‚Üê one_sub_mul, zpow_neg_one]
    _ = |2‚Åª¬π * 2 ^ (-(n : ‚Ñ§))| := by congr; rw [inv_eq_one_div 2, sub_half 1]
    _ = 2‚Åª¬π / 2 ^ n := by rw [zpow_neg, abs_mul, abs_inv, abs_inv, inv_eq_one_div,
        Nat.abs_ofNat, one_div, zpow_natCast, abs_pow, ‚Üê div_eq_mul_inv, Nat.abs_ofNat]

end Metric

section SetPointUniformity

/- As the `instance PseudoMetricSpace ‚Ñï` declared in the previous section was local, `‚Ñï` has no
topology at this point. We are going to define a non-discrete uniform structure (just using the
filter-based definition), that will endow it with a topology that we will eventually show to be
discrete. -/

/-- The fundamental entourages (index by `n : ‚Ñï`) used to construct a basis of the uniformity: for
each `n`, the set `fundamentalEntourage n : Set (‚Ñï √ó ‚Ñï)` consists of the `n+1` points
`{(0,0),(1,1)...(n,n)}` on the diagonal; together with the half plane `{(x,y) | n ‚â§ x ‚àß n ‚â§ y}`. -/
def fundamentalEntourage (n : ‚Ñï) : Set (‚Ñï √ó ‚Ñï) :=
  (‚ãÉ i : Icc 0 n, {((i : ‚Ñï), (i : ‚Ñï))}) ‚à™ Set.Ici (n , n)

@[simp]
lemma fundamentalEntourage_ext (t : ‚Ñï) (T : Set (‚Ñï √ó ‚Ñï)) : fundamentalEntourage t = T ‚Üî
    T = (‚ãÉ i : Icc 0 t, {((i : ‚Ñï), (i : ‚Ñï))}) ‚à™ Set.Ici (t , t) := by
  simpa only [fundamentalEntourage] using eq_comm

lemma mem_range_fundamentalEntourage (S : Set (‚Ñï √ó ‚Ñï)) :
    S ‚àà (range fundamentalEntourage) ‚Üî ‚àÉ n, fundamentalEntourage n = S := by
  simp only [Set.mem_range, Eq.symm]

lemma mem_fundamentalEntourage (n : ‚Ñï) (P : ‚Ñï √ó ‚Ñï) : P ‚àà fundamentalEntourage n ‚Üî
    (n ‚â§ P.1 ‚àß n ‚â§ P.2) ‚à® (P.1 = P.2) := by
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ simp only [fundamentalEntourage, iUnion_singleton_eq_range, mem_union, mem_range,
      Subtype.exists, mem_Icc, zero_le, true_and, exists_prop', nonempty_prop, mem_Ici] at h
    rcases h with h | h
    ¬∑ apply Or.inr
      rw [((h.choose_spec).2).symm]
    ¬∑ exact Or.inl h
  ¬∑ simp only [iUnion_singleton_eq_range, mem_union, mem_range, Subtype.exists, mem_Icc, zero_le,
      true_and, exists_prop', nonempty_prop, mem_Ici, fundamentalEntourage]
    rcases h with h | h
    ¬∑ exact Or.inr h
    ¬∑ cases le_total n P.1 with
      | inl h_le => exact Or.inr ‚ü®h_le, h ‚ñ∏ h_le‚ü©
      | inr h_le => exact Or.inl ‚ü®P.1, ‚ü®h_le, congrArg _ h‚ü©‚ü©

/-- The collection `fundamentalEntourage` satisfies the axioms to be a basis for a filter on
`‚Ñï √ó ‚Ñï` and gives rise to a term in the relevant type. -/
def counterBasis : FilterBasis (‚Ñï √ó ‚Ñï) where
  sets := range fundamentalEntourage
  nonempty := range_nonempty _
  inter_sets := by
    intro S T hS hT
    obtain ‚ü®s, hs‚ü© := hS
    obtain ‚ü®t, ht‚ü© := hT
    simp only [mem_range, subset_inter_iff, exists_exists_eq_and, fundamentalEntourage]
    use max t s
    refine ‚ü®fun ‚ü®P1, P2‚ü© hP ‚Ü¶ ?_, fun ‚ü®P1, P2‚ü© hP ‚Ü¶ ?_‚ü© <;> rcases hP with h | h
    ¬∑ simp only [iUnion_singleton_eq_range, mem_range, Prod.mk.injEq, Subtype.exists,
        exists_and_left, exists_eq_left] at h
      simpa only [‚Üê hs, mem_fundamentalEntourage] using Or.inr h.2
    ¬∑ simpa only [‚Üê hs, mem_fundamentalEntourage] using Or.inl
        ‚ü®le_trans (by omega) h.1, le_trans (by omega) h.2‚ü©
    ¬∑ simp only [iUnion_singleton_eq_range, mem_range, Prod.mk.injEq, Subtype.exists,
        exists_and_left, exists_eq_left] at h
      simpa only [‚Üê ht, mem_fundamentalEntourage] using Or.inr h.2
    ¬∑ simp only [mem_Ici, Prod.mk_le_mk] at h
      simpa only [‚Üê ht, mem_fundamentalEntourage] using Or.inl ‚ü®le_trans
         (by omega) h.1, le_trans (by omega) h.2‚ü©

@[simp]
lemma mem_counterBasis_iff (S : Set (‚Ñï √ó ‚Ñï)) :
    S ‚àà counterBasis ‚Üî S ‚àà range fundamentalEntourage := by
  dsimp [counterBasis]
  rfl

/-- The "crude" uniform structure, without topology, simply as a the filter generated by `Basis`
and satisfying the axioms for being a uniformity. We later extract the topology `counterTopology`
generated by it and bundle `counterCoreUniformity` and `counterTopology` in a uniform structure
on `‚Ñï`, proving in passing that `counterTopology = ‚ä•`. -/
def counterCoreUniformity : UniformSpace.Core ‚Ñï := by
  apply UniformSpace.Core.mkOfBasis counterBasis <;>
  intro S hS
  ¬∑ obtain ‚ü®n, hn‚ü© := hS
    simp only [fundamentalEntourage_ext, iUnion_singleton_eq_range] at hn
    simp only [hn, mem_union, mem_range, Prod.mk.injEq, and_self, Subtype.exists, mem_Icc, zero_le,
      true_and, exists_prop', nonempty_prop, exists_eq_right, mem_Ici, Prod.mk_le_mk]
    omega
  ¬∑ refine ‚ü®S, hS, ?_‚ü©
    obtain ‚ü®n, hn‚ü© := hS
    simp only [fundamentalEntourage_ext, iUnion_singleton_eq_range] at hn
    simp only [hn, preimage_union, union_subset_iff]
    constructor
    ¬∑ apply subset_union_of_subset_left (subset_of_eq _)
      aesop
    ¬∑ apply subset_union_of_subset_right (subset_of_eq _)
      aesop
  ¬∑ refine ‚ü®S, hS, ?_‚ü©
    obtain ‚ü®n, hn‚ü© := hS
    simp only [fundamentalEntourage_ext, iUnion_singleton_eq_range] at hn
    simp only [hn]
    rintro ‚ü®P1, P2‚ü© ‚ü®m, h1, h2‚ü©
    simp only [mem_union, mem_range, Prod.mk.injEq, Subtype.exists, mem_Icc, zero_le, true_and,
      exists_and_left, exists_prop', nonempty_prop, exists_eq_left, mem_Ici, Prod.mk_le_mk] at h1 h2
    aesop

/-- The topology on `‚Ñï` induced by the "crude" uniformity -/
instance counterTopology : TopologicalSpace ‚Ñï := counterCoreUniformity.toTopologicalSpace

/-- The uniform structure on `‚Ñï` bundling together the "crude" uniformity and the topology -/
instance counterUniformity : UniformSpace ‚Ñï := UniformSpace.ofCore counterCoreUniformity

lemma HasBasis_counterUniformity :
    (uniformity ‚Ñï).HasBasis (fun _ ‚Ü¶ True) fundamentalEntourage := by
  change counterCoreUniformity.uniformity.HasBasis (fun _ ‚Ü¶ True) fundamentalEntourage
  simp only [Filter.hasBasis_iff, true_and]
  intro T
  refine ‚ü®fun ‚ü®s, ‚ü®‚ü®r, hr‚ü©, hs‚ü©‚ü© ‚Ü¶ ‚ü®r, subset_of_eq_of_subset hr hs‚ü© , fun ‚ü®n, hn‚ü© ‚Ü¶ ?_‚ü©
  exact (@FilterBasis.mem_filter_iff _ counterBasis T).mpr ‚ü®fundamentalEntourage n, by simp, hn‚ü©

/-- A proof that the topology on `‚Ñï` induced by the "crude" uniformity `counterCoreUniformity`
(or by `counterUniformity` tout-court, since they are `defeq`) is discrete -/
theorem TopIsDiscrete' : DiscreteTopology ‚Ñï := by
  rw [discreteTopology_iff_nhds]
  intro n
  rw [nhds_eq_comap_uniformity']
  apply Filter.ext
  intro S
  simp only [Filter.mem_comap, Filter.mem_pure]
  have := @Filter.HasBasis.mem_uniformity_iff _ _ _ _ _ HasBasis_counterUniformity
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ simp_rw [this] at h
    obtain ‚ü®T, ‚ü®‚ü®i, ‚ü®-, h1‚ü©‚ü©, h2‚ü©‚ü© := h
    apply h2 (h1 _ _ _)
    rw [mem_fundamentalEntourage]
    aesop
  ¬∑ refine ‚ü®fundamentalEntourage (n + 1), ?_, ?_‚ü©
    ¬∑ change fundamentalEntourage (n + 1) ‚àà counterCoreUniformity.uniformity
      exact @Filter.HasBasis.mem_of_mem (‚Ñï √ó ‚Ñï) ‚Ñï counterCoreUniformity.uniformity (fun _ ‚Ü¶ True)
        fundamentalEntourage (n + 1) HasBasis_counterUniformity trivial
    ¬∑ simp only [preimage_subset_iff, mem_fundamentalEntourage, add_le_iff_nonpos_right,
        nonpos_iff_eq_zero, one_ne_zero, and_false, false_or]
      exact fun _ a ‚Ü¶ mem_of_eq_of_mem a h

/- With respect to the above uniformity, the `atTop` filter is Cauchy; in particular, it is not of
the form `ùìü {x}` for any `x`, although the topology is discrete. This implies in passing that this
uniformity is not discrete. -/
lemma atTopIsCauchy : Cauchy (atTop : Filter ‚Ñï) := by
  rw [HasBasis_counterUniformity.cauchy_iff]
  refine ‚ü®atTop_neBot, fun i _ ‚Ü¶ ?_‚ü©
  simp_rw [mem_fundamentalEntourage, mem_atTop_sets, ge_iff_le]
  exact ‚ü®Ici i, ‚ü®‚ü®i, fun _ hb ‚Ü¶ hb‚ü©, fun _ hx _ hy ‚Ü¶ Or.inl ‚ü®hx, hy‚ü©‚ü©‚ü©

/-- We find the same result about the identity map found in `idIsCauchy`, without using any metric
structure. -/
lemma idIsCauchy' : CauchySeq (id : ‚Ñï ‚Üí _) := ‚ü®map_neBot, cauchy_iff_le.mp atTopIsCauchy‚ü©

end SetPointUniformity
