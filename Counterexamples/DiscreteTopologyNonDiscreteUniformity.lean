/-
Copyright (c) 2024 Filippo A. E. Nuccio. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Filippo A. E. Nuccio
-/

import Mathlib.Analysis.SpecificLimits.Basic
import Mathlib.Order.Interval.Set.Basic
import Mathlib.Topology.MetricSpace.Pseudo.Defs
import Mathlib.Topology.MetricSpace.Cauchy
import Mathlib.Topology.UniformSpace.Cauchy

/-!
# Discrete uniformities and discrete topology
Exactly as different metrics can induce equivalent topologies on a space, it is possible that
different uniform structures (a notion that generalises that of a metric structure) induce the same
topology on a space. In this file we are concerned in particular with the *discrete topology*,
formalised using the class `DiscreteTopology`, and the *discrete uniformity*, that is the bottom
element of the lattice of uniformities on a type (see `bot_uniformity`).

The theorem `discreteTopology_of_discrete_uniformity` shows that the topology induced by the
discrete uniformity is the discrete one, but it is well-known that the converse might not hold in
general, along the lines of the above discussion.

Once a type `Œ±` is endowed with a uniformity, it is possible to speak about `Cauchy` filters on `a`
and it is quite easy to see that if the uniformity on `a` is the discrete one, a filter is Cauchy if
and only if it the principal filter `ùìü {x}` (see `Filter.principal`) and for some `x : Œ±`. This is
the declaration `UniformSpace.DiscreteUnif.eq_const_of_cauchy` in Mathlib.

A special case of this result is the intuitive observation that a sequence `a : ‚Ñï ‚Üí ‚Ñï` can be a
Cauchy sequence if and only if it is eventually constant: when claiming this equivalence, one is
implicitely endowing `‚Ñï` with the metric inherited from `‚Ñù`, that induces the discrete uniformity
on `‚Ñï`: on the other hand, the geometric intuition might suggest that a Cauchy sequence, whose
terms are "closer and closer to each other", valued in `‚Ñï` must be eventually constant for
*topological* reasons, namely the fact that `‚Ñï` is a discrete topological space.

## The question and the counterexample
It is natural to wonder whether the assumption of `UniformSpace.DiscreteUnif.eq_const_of_cauchy`
that the uniformity is discrete can be relaxed to assume that the *topology* is discrete. In other
terms, is it true that every Cauchy sequence in a uniform space whose topology is discrete is
eventually constant? In the language of filters: is it true that every Cauchy filter `‚Ñ±` in a
uniform space `Œ±` whose induced topology `UniformSpace.toTopologicalSpace` is discrete, is of the
form `‚Ñ± = ùìü {x}` for some `x : Œ±`?

The goal of this file is to show that the answer is "no", by providing a counterexample. We
construct a uniform structure on `‚Ñï`, showing that it induces the discrete topology on `‚Ñï` but
such that the filter `Filter.atTop` (that can be of the form `ùìü {x}` only when `x` is a top
element, which is not the case if `Œ± = ‚Ñï`) is Cauchy. In particular, the identity sequence
`fun x ‚Ü¶ x : ‚Ñï ‚Üí ‚Ñï` is a Cauchy sequence valued in the discrete topological space `‚Ñï`.

## The construction of the uniformity
A uniformity on `‚Ñï` is a filter on `‚Ñï √ó ‚Ñï` satisfying some properties: we define a sequence of
subsets `fundamentalEntourage n : (Set ‚Ñï √ó ‚Ñï)` (indexed by `n : ‚Ñï`) and we observe it satisfies the
condition needed to be a basis of a filter: moreover, the filter generated by this basis satisfies
the condition for being a uniformity, and this is the uniformity we put on `‚Ñï`.

For each `n`, the set `fundamentalEntourage n : Set (‚Ñï √ó ‚Ñï)` consists of the `n+1` points
`{(0,0),(1,1)...(n,n)}` on the diagonal; together with the half plane `{(x,y) | n ‚â§ x  ‚àß n ‚â§ y}`

That this collection can be used as a filter basis is proven in the definition `counterBasis` and
that the filter `counterBasis.filterBasis` is a uniformity is proven in the definition
`counterCoreUniformity`.

This induces the discrete topology, as proven in `TopIsDiscrete` and the `atTop` filter is Cauchy
(see `atTopIsCauchy`): that this specializes to the statement that the identity sequence
`id : ‚Ñï ‚Üí ‚Ñï` is Cauchy is proven in `idIsCauchy`.

## Implementation details
Since most of the statements evolve around membership of explicit natural numbers (framed by some
inequality) to explicit subsets, many proofs are easily closed by `aesop` or `omega`.

### References
* [N. Bourbaki, *General Topology*, Chapter II][bourbaki1966]
-/

open Set Function Filter Metric

/- We remove the "usual" instances of (discrete) topological space and of (discrete) uniform space
from `‚Ñï`-/
attribute [-instance] instTopologicalSpaceNat instUniformSpaceNat

section Metric

-- noncomputable
-- abbrev f : ‚Ñï ‚Üí ‚Ñù := fun n ‚Ü¶ 2 ^(- n : ‚Ñ§)

-- lemma inj_f : Injective f := sorry

-- abbrev S : Set ‚Ñù := range f

-- noncomputable local instance : MetricSpace S := by
--   use MetricSpace.induced
--   -- have := MetricSpace.induced f inj_f

noncomputable local instance : PseudoMetricSpace ‚Ñï where
  dist := fun n m ‚Ü¶ |2 ^ (- n : ‚Ñ§) - 2 ^ (- m : ‚Ñ§)|
  dist_self := by simp only [zpow_neg, zpow_natCast, sub_self, abs_zero, implies_true]
  dist_comm := fun _ _ ‚Ü¶ abs_sub_comm ..
  dist_triangle := fun _ _ _ ‚Ü¶ abs_sub_le ..

@[simp]
lemma dist_def {n m : ‚Ñï} : dist n m = |2 ^ (-n : ‚Ñ§) - 2 ^ (-m : ‚Ñ§)| := rfl

lemma ball_eq_singleton {n : ‚Ñï} : Metric.ball n ((2 : ‚Ñù) ^ (-n : ‚Ñ§)) = {n} := by
  ext m
  constructor
  ¬∑ simp only [zpow_natCast, mem_ball, dist_def, mem_singleton_iff]
    intro H
    have : |(2 : ‚Ñù) ^ (-m : ‚Ñ§) - 2 ^ (-n : ‚Ñ§)| = |2 ^ (-n : ‚Ñ§)* (2 ^ (n - m : ‚Ñ§) -1)| := sorry

      --rw [not_le, ‚Üê Int.ofNat_lt, ‚Üê neg_lt_neg_iff] at hmn
      -- specialize this _ H

  --   ¬∑ sorry
  -- ¬∑ intro H
  --   simp only [/- zpow_neg,  -/zpow_natCast, mem_ball, dist_def]
  --   simp at H
  --   rw [H]
  --   simp only [zpow_neg, zpow_natCast, sub_self, abs_zero, inv_pos, Nat.ofNat_pos, pow_pos]


theorem TopIsDiscrete : DiscreteTopology ‚Ñï := by

  rw [‚Üê singletons_open_iff_discrete]
  intro n
  set œÜ : ‚Ñï ‚Üí ‚Ñù := fun x ‚Ü¶ dist x n with hœÜ
  simp only [dist, zpow_natCast] at hœÜ
  have c_œÜ : Continuous œÜ := sorry
  rw [continuous_def] at c_œÜ
  specialize c_œÜ (Ioo ((2 : ‚Ñù) ^ (-n - 1 : ‚Ñ§)) ((2 : ‚Ñù) ^ (-n : ‚Ñ§))) isOpen_Ioo
  convert c_œÜ
  ext m
  simp only [mem_singleton_iff, hœÜ, zpow_natCast, mem_preimage/- , mem_Ioo -/]
  constructor
  ¬∑ intro hmn
    rw [hmn]
    simp only [zpow_neg, zpow_natCast, sub_self, abs_zero, inv_pos, Nat.ofNat_pos, pow_pos,
      and_true]
  ¬∑ intro H
    simp at H


    -- rintro ‚ü®HL, HR‚ü©
    -- simp at HL HR


  --   -- simp only [zpow_natCast]--, sub_self, abs_zero]
  --   constructor
  --   ¬∑ sorry
  --   ¬∑ sorry



  have con : Continuous (fun x ‚Ü¶ (x, n) : ‚Ñï ‚Üí ‚Ñï √ó ‚Ñï) := by
    simp_all only [continuous_prod_mk]
    apply And.intro
    ¬∑ apply continuous_id'
    ¬∑ apply continuous_const
  have := (@continuous_dist ‚Ñï _)
  -- have cc := (@continuous_prod_mk ‚Ñï ‚Ñï ‚Ñï _ _ _ id n).mpr
  -- simp only [id_eq, Pi.natCast_def, Nat.cast_id, /- continuous_prod_mk, -/ continuous_const, continuous_id, and_true]
  --   at cc
  -- simp? at cc
  have  fd := Continuous.comp (hf := con) (hg := this)

  -- have f := @continuous_fst ‚Ñï ‚Ñï _ _
  rw [continuous_def] at fd
  specialize fd (Ioo (-n -1 : ‚Ñ§) (-n + 1: ‚Ñ§)) isOpen_Ioo
  convert fd
  -- simp only [dist_def, zpow_neg, zpow_natCast, Int.cast_sub, Int.cast_neg, Int.cast_natCast,
  --   Int.cast_one, Int.cast_add]
  ext m
  simp only [mem_singleton_iff, dist_def, zpow_neg, zpow_natCast, Int.cast_sub, Int.cast_neg,
    Int.cast_natCast, Int.cast_one, Int.cast_add, mem_preimage, comp_apply, mem_Ioo,
    lt_neg_add_iff_add_lt]

  constructor
  ¬∑ intro hmn
    rw [hmn]
    simp only [sub_self/- , abs_zero, sub_neg, add_zero, Nat.cast_lt_one -/]
  --   sorry
  -- ¬∑ intro H
  --   simp at H


  -- simp at this
  -- have ff : {(n, n)} = (fun p ‚Ü¶ dist p.1 p.2) ‚Åª¬π' (Ioo (-(n : ‚Ñ§) - 1) ((-n : ‚Ñ§) + 1)) := sorry
  -- simp at ff
  rw [isOpen_prod_iff] at this
  simp at this
  -- omega at this
  -- have ff : {(n, n)} = ((fun p ‚Ü¶ dist p.1 p.2) ‚Åª¬π' Ioo (-‚Üën - 1) (-‚Üën + 1))





lemma idIsCauchy : CauchySeq (id : ‚Ñï ‚Üí ‚Ñï) := by
  rw [Metric.cauchySeq_iff]
  refine fun Œµ ‚Ü¶ Metric.cauchySeq_iff.mp
    (@cauchySeq_of_le_geometric_two ‚Ñù _ 1 (fun n ‚Ü¶ 2 ^(-n : ‚Ñ§)) fun n ‚Ü¶ ?_) Œµ
  simp only [zpow_natCast, Nat.cast_add, Nat.cast_one, neg_add_rev, Int.reduceNeg, one_div]
  rw [Real.dist_eq, zpow_add' <| Or.intro_left _ two_ne_zero]
  calc |2 ^ (- n : ‚Ñ§) - 2 ^ (-1 : ‚Ñ§) * 2 ^ (- n : ‚Ñ§)| =
        |(1 - (2 : ‚Ñù)‚Åª¬π) * 2 ^ (- n : ‚Ñ§)| := by rw [‚Üê one_sub_mul, zpow_neg_one]
      _ = |2‚Åª¬π * 2 ^ (-(n : ‚Ñ§))| := by congr; rw [inv_eq_one_div 2, sub_half 1]
      _ = 2‚Åª¬π / 2 ^ n := by rw [zpow_neg, abs_mul, abs_inv, abs_inv, inv_eq_one_div,
          Nat.abs_ofNat, one_div, zpow_natCast, abs_pow, ‚Üê div_eq_mul_inv, Nat.abs_ofNat]
  rfl

end Metric

section SetPointUniformity

/- As the `instance PseudoMetricSpace ‚Ñï` declared in the previous section was local, `‚Ñï` has no
topology at this point. We are going to define a non-discrete uniform structure (just using the
filter-based definition), that will endow it with a topology that we will eventually show to be
discrete. -/

/-- The fundamental entourages (index by `n : ‚Ñï`) used to construct a basis of the uniformity: for
each `n`, the set `fundamentalEntourage n : Set (‚Ñï √ó ‚Ñï)` consists of the `n+1` points
`{(0,0),(1,1)...(n,n)}` on the diagonal; together with the half plane `{(x,y) | n ‚â§ x  ‚àß n ‚â§ y}`-/
def fundamentalEntourage (n : ‚Ñï) : Set (‚Ñï √ó ‚Ñï) :=
  (‚ãÉ i : Icc 0 n, {((i : ‚Ñï), (i : ‚Ñï))}) ‚à™ Set.Ici (n , n)

@[simp]
lemma fundamentalEntourage_ext (t : ‚Ñï) (T : Set (‚Ñï √ó ‚Ñï)) : fundamentalEntourage t = T ‚Üî
    T = (‚ãÉ i : Icc 0 t, {((i : ‚Ñï), (i : ‚Ñï))}) ‚à™ Set.Ici (t , t) := by
  simpa only [fundamentalEntourage] using eq_comm

lemma mem_range_fundamentalEntourage (S : Set (‚Ñï √ó ‚Ñï)) :
    S ‚àà (range fundamentalEntourage) ‚Üî ‚àÉ n, fundamentalEntourage n = S := by
  simp only [Set.mem_range, Eq.symm]

lemma mem_fundamentalEntourage (n : ‚Ñï) (P : ‚Ñï √ó ‚Ñï) : P ‚àà fundamentalEntourage n ‚Üî
    (n ‚â§ P.1 ‚àß n ‚â§ P.2) ‚à® (P.1 = P.2) := by
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ simp only [fundamentalEntourage, iUnion_singleton_eq_range, mem_union, mem_range,
      Subtype.exists, mem_Icc, zero_le, true_and, exists_prop', nonempty_prop, mem_Ici] at h
    rcases h with h | h
    ¬∑ apply Or.inr
      rw [((h.choose_spec).2).symm]
    ¬∑ exact Or.inl h
  ¬∑ simp only [iUnion_singleton_eq_range, mem_union, mem_range, Subtype.exists, mem_Icc, zero_le,
      true_and, exists_prop', nonempty_prop, mem_Ici, fundamentalEntourage]
    rcases h with h | h
    ¬∑ exact Or.inr h
    ¬∑ by_cases h_le : n ‚â§ P.1
      ¬∑ exact Or.inr ‚ü®h_le, h ‚ñ∏ h_le‚ü©
      ¬∑ refine Or.inl ‚ü®P.1, ‚ü®le_of_lt <| not_le.mp h_le, congrArg _ h‚ü©‚ü©

/-- The collection `fundamentalEntourage` satisfies the axioms to be a basis for a filter on
 `‚Ñï √ó ‚Ñï` and gives rise to a term in the relevant type.-/
def counterBasis : FilterBasis (‚Ñï √ó ‚Ñï) where
  sets := range fundamentalEntourage
  nonempty := range_nonempty _
  inter_sets := by
    intro S T hS hT
    obtain ‚ü®s, hs‚ü© := hS
    obtain ‚ü®t, ht‚ü© := hT
    simp only [mem_range, subset_inter_iff, exists_exists_eq_and, fundamentalEntourage]
    use max t s
    refine ‚ü®fun ‚ü®P1, P2‚ü© hP ‚Ü¶ ?_, fun ‚ü®P1, P2‚ü© hP ‚Ü¶ ?_‚ü© <;>
    cases' hP with h h <;>
    simp only [iUnion_singleton_eq_range, mem_range, Prod.mk.injEq, Subtype.exists, mem_Icc,
      zero_le, le_max_iff, true_and, exists_and_left, exists_prop', nonempty_prop,
      exists_eq_left] at h
    ¬∑ simpa only [‚Üê hs, mem_fundamentalEntourage] using Or.inr h.2
    ¬∑ simpa only [‚Üê hs, mem_fundamentalEntourage] using Or.inl
        ‚ü®le_trans (by omega) h.1, le_trans (by omega) h.2‚ü©
    ¬∑ simpa only [‚Üê ht, mem_fundamentalEntourage] using Or.inr h.2
    ¬∑ simp only [mem_Ici, Prod.mk_le_mk] at h
      simpa only [‚Üê ht, mem_fundamentalEntourage] using Or.inl ‚ü®le_trans
         (by omega) h.1, le_trans (by omega) h.2‚ü©

@[simp]
lemma mem_counterBasis_iff (S : Set (‚Ñï √ó ‚Ñï)) :
    S ‚àà counterBasis ‚Üî S ‚àà range fundamentalEntourage := by
  dsimp [counterBasis]
  rfl

/-- The "crude" uniform structure, without topology, simply as a the filter generated by `Basis`
and satisfying the axioms for being a uniformity. We later extract the topology `counterTopology`
generated by it and bundle `counterCoreUniformity` and `counterTopology` in a uniform strucutre
on `‚Ñï`, proving in passing that `counterTopology = ‚ä•`-/
def counterCoreUniformity : UniformSpace.Core ‚Ñï := by
  apply UniformSpace.Core.mkOfBasis counterBasis <;>
  intro S hS
  ¬∑ obtain ‚ü®n, hn‚ü© := hS
    simp only [fundamentalEntourage_ext, iUnion_singleton_eq_range] at hn
    simp only [hn, mem_union, mem_range, Prod.mk.injEq, and_self, Subtype.exists, mem_Icc, zero_le,
      true_and, exists_prop', nonempty_prop, exists_eq_right, mem_Ici, Prod.mk_le_mk]
    omega
  ¬∑ refine ‚ü®S, hS, ?_‚ü©
    obtain ‚ü®n, hn‚ü© := hS
    simp only [fundamentalEntourage_ext, iUnion_singleton_eq_range] at hn
    simp only [hn, preimage_union, union_subset_iff]
    constructor
    ¬∑ apply subset_union_of_subset_left (subset_of_eq _)
      aesop
    ¬∑ apply subset_union_of_subset_right (subset_of_eq _)
      aesop
  ¬∑ refine ‚ü®S, hS, ?_‚ü©
    obtain ‚ü®n, hn‚ü© := hS
    simp only [fundamentalEntourage_ext, iUnion_singleton_eq_range] at hn
    simp only [hn, mem_union, mem_range, Prod.mk.injEq, Subtype.exists, mem_Icc, zero_le, true_and,
      exists_and_left, exists_prop', nonempty_prop, exists_eq_left, mem_Ici, Prod.mk_le_mk]
    rintro ‚ü®P1, P2‚ü© ‚ü®m, h1, h2‚ü©
    simp only [mem_union, mem_range, Prod.mk.injEq, Subtype.exists, mem_Icc, zero_le, true_and,
      exists_and_left, exists_prop', nonempty_prop, exists_eq_left, mem_Ici, Prod.mk_le_mk] at h1 h2
    aesop

/--The topology on `‚Ñï` induced by the "crude" uniformity-/
instance counterTopology: TopologicalSpace ‚Ñï := counterCoreUniformity.toTopologicalSpace

/-- The uniform structure on `‚Ñï` bundling together the "crude" uniformity and the topology-/
instance counterUniformity: UniformSpace ‚Ñï := UniformSpace.ofCore counterCoreUniformity

lemma HasBasis_counterUniformity :
    (uniformity ‚Ñï).HasBasis (fun _ ‚Ü¶ True) fundamentalEntourage := by
  show counterCoreUniformity.uniformity.HasBasis (fun _ ‚Ü¶ True) fundamentalEntourage
  simp only [Filter.hasBasis_iff, exists_and_left, true_and]
  intro T
  refine ‚ü®fun ‚ü®s, ‚ü®‚ü®r, hr‚ü©, hs‚ü©‚ü© ‚Ü¶ ‚ü®r, subset_of_eq_of_subset hr hs‚ü© , fun ‚ü®n, hn‚ü© ‚Ü¶ ?_‚ü©
  exact (@FilterBasis.mem_filter_iff _ counterBasis T).mpr ‚ü®fundamentalEntourage n, by simp, hn‚ü©

/-- A proof that the topology on `‚Ñï` induced by the "crude" uniformity `counterCoreUniformity`
(or by `counterUniformity` tout-court, since they are `defeq`) is discrete.-/
theorem TopIsDiscrete' : DiscreteTopology ‚Ñï := by
  rw [discreteTopology_iff_nhds]
  intro n
  rw [nhds_eq_comap_uniformity']
  apply Filter.ext
  intro S
  simp only [Filter.mem_comap, Filter.mem_pure]
  have := @Filter.HasBasis.mem_uniformity_iff _ _ _ _ _ HasBasis_counterUniformity
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ simp_rw [this] at h
    obtain ‚ü®T, ‚ü®‚ü®i, ‚ü®-, h1‚ü©‚ü©, h2‚ü©‚ü© := h
    apply h2 (h1 _ _ _)
    rw [mem_fundamentalEntourage]
    aesop
  ¬∑ refine ‚ü®fundamentalEntourage (n + 1), ?_, ?_‚ü©
    ¬∑ show fundamentalEntourage (n + 1) ‚àà counterCoreUniformity.uniformity
      exact @Filter.HasBasis.mem_of_mem (‚Ñï √ó ‚Ñï) ‚Ñï counterCoreUniformity.uniformity (fun _ ‚Ü¶ True)
        fundamentalEntourage (n + 1) HasBasis_counterUniformity trivial
    ¬∑ simp only [preimage_subset_iff, mem_fundamentalEntourage, add_le_iff_nonpos_right,
        nonpos_iff_eq_zero, one_ne_zero, and_false, false_or]
      exact fun _ a ‚Ü¶ mem_of_eq_of_mem a h

/- With respect to the above uniformity, the `atTop` filter is Cauchy; in particular, it is not of
the form `ùìü {x}` for any `x`, although the topology is discrete. This implies in passing that this
uniformity is not discrete-/
lemma atTopIsCauchy : Cauchy (atTop : Filter ‚Ñï) := by
  rw [HasBasis_counterUniformity.cauchy_iff]
  refine ‚ü®atTop_neBot, fun i _ ‚Ü¶ ?_‚ü©
  simp_rw [mem_fundamentalEntourage, mem_atTop_sets, ge_iff_le]
  exact ‚ü®Ici i, ‚ü®‚ü®i, fun _ hb ‚Ü¶ hb‚ü©, fun _ hx _ hy ‚Ü¶ Or.inl ‚ü®hx, hy‚ü©‚ü©‚ü©

/-- We find the same result about the identity map found in `idIsCauchy`, without using any metric
structure. -/
lemma idIsCauchy' : CauchySeq (id : ‚Ñï ‚Üí _) := ‚ü®map_neBot, cauchy_iff_le.mp atTopIsCauchy‚ü©

end SetPointUniformity
