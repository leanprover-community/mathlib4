diff --git a/Mathlib.lean b/Mathlib.lean
index 0b2dbf0646..f1cf85c71b 100644
--- a/Mathlib.lean
+++ b/Mathlib.lean
@@ -2131,6 +2131,7 @@ import Mathlib.CategoryTheory.Closed.FunctorCategory.Groupoid
 import Mathlib.CategoryTheory.Closed.FunctorToTypes
 import Mathlib.CategoryTheory.Closed.Ideal
 import Mathlib.CategoryTheory.Closed.Monoidal
+import Mathlib.CategoryTheory.Closed.PowerObjects
 import Mathlib.CategoryTheory.Closed.Types
 import Mathlib.CategoryTheory.Closed.Zero
 import Mathlib.CategoryTheory.CodiscreteCategory
@@ -2786,6 +2787,7 @@ import Mathlib.CategoryTheory.Sums.Associator
 import Mathlib.CategoryTheory.Sums.Basic
 import Mathlib.CategoryTheory.Sums.Products
 import Mathlib.CategoryTheory.Thin
+import Mathlib.CategoryTheory.Topos.Basic
 import Mathlib.CategoryTheory.Topos.Classifier
 import Mathlib.CategoryTheory.Triangulated.Adjunction
 import Mathlib.CategoryTheory.Triangulated.Basic
diff --git a/Mathlib/CategoryTheory/Closed/PowerObjects.lean b/Mathlib/CategoryTheory/Closed/PowerObjects.lean
new file mode 100644
index 0000000000..9b221cc485
--- /dev/null
+++ b/Mathlib/CategoryTheory/Closed/PowerObjects.lean
@@ -0,0 +1,178 @@
+/-
+Copyright (c) 2025 Klaus Gy. All rights reserved.
+Released under Apache 2.0 license as described in the file LICENSE.
+Authors: Klaus Gy
+-/
+import Mathlib.CategoryTheory.Limits.Shapes.Pullback.Equalizer
+import Mathlib.CategoryTheory.Topos.Classifier
+/-!
+# Elementary Topos (in Elementary Form)
+
+This ongoing work formalizes the elementary definition of a topos and the direct consequences.
+
+## References
+
+* [S. MacLane and I. Moerdijk, *Sheaves in Geometry and Logic*][MM92]
+-/
+
+universe u v
+
+open CategoryTheory
+open Category Functor Limits Opposite Prod
+
+variable {â„° : Type u} [Category.{v} â„°]
+
+namespace LeftRepresentable
+
+variable {F : â„°áµ’áµ– Ã— â„°áµ’áµ– â¥¤ Type (max u v)}
+
+variable {B PB : â„°} (hPB : ((curryObj F).obj (op B)).RepresentableBy PB)
+  {C PC : â„°} (hPC : ((curryObj F).obj (op C)).RepresentableBy PC)
+
+/-- The morphism induced by a morphism between the base objects. -/
+def map (h : B âŸ¶ C) : PC âŸ¶ PB :=
+  hPB.homEquiv.symm (F.map (h.op Ã—â‚˜ ğŸ™ (op PC)) (hPC.homEquiv (ğŸ™ PC)))
+
+lemma map_universal (h : B âŸ¶ C) :
+  F.map (ğŸ™ (op B) Ã—â‚˜ (map hPB hPC h).op) (hPB.homEquiv (ğŸ™ PB))
+    = F.map (h.op Ã—â‚˜ ğŸ™ (op PC)) (hPC.homEquiv (ğŸ™ PC)) := by
+  calc
+    _ = ((curryObj F).obj (op B)).map (map hPB hPC h).op (hPB.homEquiv (ğŸ™ PB)) := by rfl
+    _ = F.map (h.op Ã—â‚˜ ğŸ™ (op PC)) (hPC.homEquiv (ğŸ™ PC)) := by
+      rw [â† hPB.homEquiv_eq, map, hPB.homEquiv.apply_symm_apply]
+
+variable {D PD : â„°} (hPD : ((curryObj F).obj (op D)).RepresentableBy PD)
+
+lemma compose (h : B âŸ¶ C) (h' : C âŸ¶ D) :
+    map hPB hPD (h â‰« h') = map hPC hPD h' â‰« map hPB hPC h := by
+  let Ph := map hPB hPC h
+  let Ph' := map hPC hPD h'
+  apply hPB.homEquiv.injective
+  calc
+    _ = F.map ((h'.op Ã—â‚˜ ğŸ™ _) â‰« (h.op Ã—â‚˜ ğŸ™ _)) (hPD.homEquiv (ğŸ™ PD)) := by unfold map; simp
+    _ = F.map ((ğŸ™ _ Ã—â‚˜ Ph'.op) â‰« (h.op Ã—â‚˜ ğŸ™ _)) (hPC.homEquiv (ğŸ™ PC)) := by
+      rw[FunctorToTypes.map_comp_apply, â† map_universal, â† FunctorToTypes.map_comp_apply]
+    _ = F.map ((h.op Ã—â‚˜ ğŸ™ _) â‰« (ğŸ™ _ Ã—â‚˜ Ph'.op)) (hPC.homEquiv (ğŸ™ PC)) := by simp
+    _ = F.map ((ğŸ™ _ Ã—â‚˜ Ph.op) â‰« (ğŸ™ _ Ã—â‚˜ Ph'.op)) (hPB.homEquiv (ğŸ™ PB)) := by
+      rw[FunctorToTypes.map_comp_apply, â† map_universal, â† FunctorToTypes.map_comp_apply]
+    _ = (F.curryObj.obj _).map (Ph' â‰« Ph).op (hPB.homEquiv (ğŸ™ PB)) := by
+      simp [curryObj, â† FunctorToTypes.map_comp_apply]
+    _ = hPB.homEquiv (Ph' â‰« Ph) := by rw[â† hPB.homEquiv_eq]
+
+/-- Let `F : â„°áµ’áµ– Ã— â„°áµ’áµ– â¥¤ Type`. If for each `B` we choose
+an object `P B` representing the functor `A â†¦ F (B, A)`,
+then these choices assemble into a covariant functor `â„°áµ’áµ– â¥¤ â„°`. -/
+def functor (P : â„° â†’ â„°) (hP : âˆ€ B : â„°, ((curryObj F).obj (op B)).RepresentableBy (P B)) :
+    â„°áµ’áµ– â¥¤ â„° :=
+  { obj (B : â„°áµ’áµ–) := P (unop B),
+    map {B C : â„°áµ’áµ–} (h : B âŸ¶ C) := map (hP (unop C)) (hP (unop B)) h.unop,
+    map_id (_) := by
+      change (hP _).homEquiv.symm (F.map (ğŸ™ _) ((hP _).homEquiv (ğŸ™ _))) = ğŸ™ _
+      rw[FunctorToTypes.map_id_apply]; simp
+    map_comp {B C D : â„°áµ’áµ–} (h : B âŸ¶ C) (h' : C âŸ¶ D) :=
+      compose (hP (unop D)) (hP (unop C)) (hP (unop B)) h'.unop h.unop }
+
+end LeftRepresentable
+
+open CartesianMonoidalCategory MonoidalCategory
+
+variable [CartesianMonoidalCategory â„°]
+
+private abbrev cmdiag (X : â„°) : X âŸ¶ X âŠ— X := lift (ğŸ™ X) (ğŸ™ X)
+
+private lemma pullback_of_diag {B X : â„°} (b : X âŸ¶ B) :
+    IsPullback b (lift b (ğŸ™ X)) (cmdiag B) (B â— b) :=
+  let eq : lift b (ğŸ™ X) â‰« fst B X = lift b (ğŸ™ X) â‰« snd B X â‰« b := by simp
+  let lim : IsLimit (Fork.ofÎ¹ (lift b (ğŸ™ X)) eq) :=
+    Fork.IsLimit.mk _
+      (fun s => s.Î¹ â‰« (snd B X))
+      (fun s => by simp[â† s.condition])
+      (fun s m eq => by simp[â† eq])
+  let pb : IsPullback _ (_ â‰« fst B X) (lift (fst B X) (snd B X â‰« b)) (cmdiag B) :=
+    isPullback_equalizer_binaryFan_fork _ (fst B X) (snd B X â‰« b) _ lim
+  IsPullback.flip
+    (by simpa using pb)
+
+private lemma eq_of_lift_through_diag {X Y : â„°} {f f' g : X âŸ¶ Y}
+    (h : lift f f' = g â‰« cmdiag Y) : f = f' := by
+  calc
+    _ = (lift f f') â‰« (fst Y Y) := by simp
+    _ = (lift f f') â‰« (snd Y Y) := by simp[h]
+    _ = f' := by simp
+
+variable [HasPullbacks â„°]
+
+/-- The subobject functor for products. -/
+noncomputable def subobjProd : â„°áµ’áµ– Ã— â„°áµ’áµ– â¥¤ Type (max u v) where
+  obj P := Subobject (unop P.1 âŠ— unop P.2)
+  map f := (Subobject.pullback (f.1.unop âŠ—â‚˜ f.2.unop)).obj
+  map_id A := by ext1 x; simp [Subobject.pullback_id]
+  map_comp f f' := by ext1 x; simp [Subobject.pullback_comp]
+
+/-- `P` is a power object of `B` if it represents the functor `A â†¦ Subobject (B âŠ— A)`. -/
+def IsPowerObjectOf (B P : â„°) :=
+  (subobjProd.curryObj.obj (op B)).RepresentableBy P
+
+namespace PowerObject
+
+variable {B PB : â„°} (hPB : IsPowerObjectOf B PB)
+
+section functoriality
+
+variable {C PC : â„°} (hPC : IsPowerObjectOf C PC)
+  {D PD : â„°} (hPD : IsPowerObjectOf D PD)
+
+/-- Functoriality on the left variable of the bifunctor `(B, A) â†¦ Subobject (B âŠ— A)`:
+a map `h : B âŸ¶ C` induces `PC âŸ¶ PB` via left-representability. -/
+noncomputable def map (h : B âŸ¶ C) : PC âŸ¶ PB := LeftRepresentable.map hPB hPC h
+
+lemma compose (h : B âŸ¶ C) (h' : C âŸ¶ D) :
+    map hPB hPD (h â‰« h') = map hPC hPD h' â‰« map hPB hPC h :=
+  LeftRepresentable.compose hPB hPC hPD h h'
+
+/-- Given a choice of representing objects `P B` for the functors `A â†¦ Subobject (B âŠ— A)`,
+then these choices assemble into a covariant functor `â„°áµ’áµ– â¥¤ â„°`. -/
+noncomputable def functor (P : â„° â†’ â„°) (hP : âˆ€ B : â„°, IsPowerObjectOf B (P B)) : â„°áµ’áµ– â¥¤ â„° :=
+  LeftRepresentable.functor P hP
+
+end functoriality
+
+/-- The singleton morphism from `B` to `PB`. -/
+def singleton : B âŸ¶ PB :=
+  hPB.homEquiv.invFun (Subobject.mk (cmdiag B))
+
+/-- The classifying subobject on `B âŠ— PB` associated to the chosen representation. -/
+def epsilon : Subobject (B âŠ— PB) := hPB.homEquiv (ğŸ™ PB)
+
+private lemma pullback_diag_eq_singleton {X} (f : X âŸ¶ B) :
+      (Subobject.pullback (B â— f)).obj (Subobject.mk (cmdiag B)) =
+    hPB.homEquiv (f â‰« singleton hPB) := by
+  calc
+    _ = (subobjProd.curryObj.obj (op B)).map f.op (hPB.homEquiv (singleton hPB)) := by
+      simp[subobjProd, curryObj, singleton]
+    _ = hPB.homEquiv (f â‰« singleton hPB) := Eq.symm (hPB.homEquiv_comp f (singleton hPB))
+
+noncomputable instance singleton_is_mono : Mono (singleton hPB) :=
+  âŸ¨ fun {X} (b b' : X âŸ¶ B) eq â†¦
+    let B_sub := Subobject.mk (cmdiag B)
+    let P := (Subobject.pullback (B â— b)).obj B_sub
+    let P' := (Subobject.pullback (B â— b')).obj B_sub
+    let PeqP' : P = P' := by
+      unfold P P'
+      rw[pullback_diag_eq_singleton hPB b, eq, â† pullback_diag_eq_singleton hPB b']
+    let Î¹ : X â‰… Subobject.underlying.obj P :=
+      IsPullback.isoIsPullback_congr
+        (Subobject.underlyingIso (cmdiag B)).symm (Iso.refl (B âŠ— X))
+        (Subobject.underlyingIso_hom_comp_eq_mk (cmdiag B)) (by simp)
+        (pullback_of_diag b) (Subobject.isPullback (B â— b) B_sub)
+    let eqâ‚ : (lift b (ğŸ™ X)) = Î¹.hom â‰« P.arrow := by unfold P Î¹; simp
+    let eqâ‚‚ := Eq.symm (Subobject.arrow_congr P P' PeqP')
+    let eqâ‚ƒ := Eq.symm (Subobject.isPullback (B â— b') B_sub).w
+    let eqâ‚„ := Eq.symm (Subobject.underlyingIso_hom_comp_eq_mk (cmdiag B))
+    have : (lift b b') = _ â‰« cmdiag B := by
+      calc
+        _ = (lift b (ğŸ™ X)) â‰« B â— b' := by simp
+        _ = _ â‰« cmdiag B := by rw[eqâ‚, assoc, eqâ‚‚, assoc, eqâ‚ƒ, assoc, eqâ‚„, â† assoc, â† assoc]
+    eq_of_lift_through_diag this âŸ©
+
+end PowerObject
diff --git a/Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean b/Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean
index 93f5b673a0..5ef650d62b 100644
--- a/Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean
+++ b/Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean
@@ -30,7 +30,7 @@ braiding and associating isomorphisms, and the product comparison morphism.
 
 universe v vâ‚ u uâ‚ uâ‚‚
 
-open CategoryTheory
+open CategoryTheory Category
 
 namespace CategoryTheory.Limits
 
@@ -386,7 +386,7 @@ theorem BinaryFan.isLimit_iff_isIso_fst {X Y : C} (h : IsTerminal Y) (c : Binary
     obtain âŸ¨l, hl, -âŸ© := BinaryFan.IsLimit.lift' H (ğŸ™ X) (h.from X)
     exact
       âŸ¨âŸ¨l,
-          BinaryFan.IsLimit.hom_ext H (by simpa [hl, -Category.comp_id] using Category.comp_id _)
+          BinaryFan.IsLimit.hom_ext H (by simpa [hl, -comp_id] using comp_id _)
             (h.hom_ext _ _),
           hlâŸ©âŸ©
   Â· intro
@@ -433,9 +433,9 @@ theorem BinaryCofan.isColimit_iff_isIso_inl {X Y : C} (h : IsInitial Y) (c : Bin
   Â· rintro âŸ¨HâŸ©
     obtain âŸ¨l, hl, -âŸ© := BinaryCofan.IsColimit.desc' H (ğŸ™ X) (h.to X)
     refine âŸ¨âŸ¨l, hl, BinaryCofan.IsColimit.hom_ext H (?_) (h.hom_ext _ _)âŸ©âŸ©
-    rw [Category.comp_id]
+    rw [comp_id]
     have e : (inl c â‰« l) â‰« inl c = ğŸ™ X â‰« inl c := congrArg (Â·â‰«inl c) hl
-    rwa [Category.assoc,Category.id_comp] at e
+    rwa [assoc,id_comp] at e
   Â· intro
     exact
       âŸ¨BinaryCofan.IsColimit.mk _ (fun f _ => inv c.inl â‰« f)
@@ -519,8 +519,8 @@ noncomputable def coprodIsCoprod (X Y : C) [HasBinaryCoproduct X Y] :
     IsColimit (BinaryCofan.mk (coprod.inl : X âŸ¶ X â¨¿ Y) coprod.inr) :=
   (colimit.isColimit _).ofIsoColimit (Cocones.ext (Iso.refl _) (fun âŸ¨uâŸ© => by
     cases u
-    Â· dsimp; simp only [Category.comp_id]
-    Â· dsimp; simp only [Category.comp_id]
+    Â· dsimp; simp only [comp_id]
+    Â· dsimp; simp only [comp_id]
   ))
 
 @[ext 1100]
@@ -622,7 +622,7 @@ theorem prod.comp_lift {V W X Y : C} [HasBinaryProduct X Y] (f : V âŸ¶ W) (g : W
     f â‰« prod.lift g h = prod.lift (f â‰« g) (f â‰« h) := by ext <;> simp
 
 theorem prod.comp_diag {X Y : C} [HasBinaryProduct Y Y] (f : X âŸ¶ Y) :
-    f â‰« diag Y = prod.lift f f := by simp
+    f â‰« diag Y = lift f f := by simp
 
 @[reassoc (attr := simp)]
 theorem prod.map_fst {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : W âŸ¶ Y)
@@ -642,6 +642,10 @@ theorem prod.map_id_id {X Y : C} [HasBinaryProduct X Y] : prod.map (ğŸ™ X) (
 theorem prod.lift_fst_snd {X Y : C} [HasBinaryProduct X Y] :
     prod.lift prod.fst prod.snd = ğŸ™ (X â¨¯ Y) := by ext <;> simp
 
+@[simp]
+lemma prod.lift_comp_fst_snd {X Y Z : C} [HasBinaryProduct Y Z] (f : X âŸ¶ Y â¨¯ Z) :
+    prod.lift (f â‰« prod.fst) (f â‰« prod.snd) = f := by ext <;> simp
+
 @[reassoc (attr := simp)]
 theorem prod.lift_map {V W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : V âŸ¶ W)
     (g : V âŸ¶ X) (h : W âŸ¶ Y) (k : X âŸ¶ Z) :
@@ -744,6 +748,10 @@ theorem coprod.map_id_id {X Y : C} [HasBinaryCoproduct X Y] : coprod.map (ğŸ™ X
 theorem coprod.desc_inl_inr {X Y : C} [HasBinaryCoproduct X Y] :
     coprod.desc coprod.inl coprod.inr = ğŸ™ (X â¨¿ Y) := by ext <;> simp
 
+@[simp]
+lemma coprod.desc_comp_inl_inr {X Y Z : C} [HasBinaryCoproduct X Y] (f : X â¨¿ Y âŸ¶ Z) :
+    coprod.desc (coprod.inl â‰« f) (coprod.inr â‰« f) = f := by ext <;> simp
+
 -- The simp linter says simp can prove the reassoc version of this lemma.
 @[reassoc, simp]
 theorem coprod.map_desc {S T U V W : C} [HasBinaryCoproduct U W] [HasBinaryCoproduct T V]
@@ -913,7 +921,7 @@ theorem prod.leftUnitor_hom_naturality [HasBinaryProducts C] (f : X âŸ¶ Y) :
 @[reassoc]
 theorem prod.leftUnitor_inv_naturality [HasBinaryProducts C] (f : X âŸ¶ Y) :
     (prod.leftUnitor X).inv â‰« prod.map (ğŸ™ _) f = f â‰« (prod.leftUnitor Y).inv := by
-  rw [Iso.inv_comp_eq, â† Category.assoc, Iso.eq_comp_inv, prod.leftUnitor_hom_naturality]
+  rw [Iso.inv_comp_eq, â† assoc, Iso.eq_comp_inv, prod.leftUnitor_hom_naturality]
 
 @[reassoc]
 theorem prod.rightUnitor_hom_naturality [HasBinaryProducts C] (f : X âŸ¶ Y) :
@@ -923,7 +931,7 @@ theorem prod.rightUnitor_hom_naturality [HasBinaryProducts C] (f : X âŸ¶ Y) :
 @[reassoc]
 theorem prod_rightUnitor_inv_naturality [HasBinaryProducts C] (f : X âŸ¶ Y) :
     (prod.rightUnitor X).inv â‰« prod.map f (ğŸ™ _) = f â‰« (prod.rightUnitor Y).inv := by
-  rw [Iso.inv_comp_eq, â† Category.assoc, Iso.eq_comp_inv, prod.rightUnitor_hom_naturality]
+  rw [Iso.inv_comp_eq, â† assoc, Iso.eq_comp_inv, prod.rightUnitor_hom_naturality]
 
 theorem prod.triangle [HasBinaryProducts C] (X Y : C) :
     (prod.associator X (âŠ¤_ C) Y).hom â‰« prod.map (ğŸ™ X) (prod.leftUnitor Y).hom =
@@ -1097,7 +1105,7 @@ theorem prodComparison_inv_natural (f : A âŸ¶ A') (g : B âŸ¶ B') [IsIso (prodCom
     [IsIso (prodComparison F A' B')] :
     inv (prodComparison F A B) â‰« F.map (prod.map f g) =
       prod.map (F.map f) (F.map g) â‰« inv (prodComparison F A' B') := by
-  rw [IsIso.eq_comp_inv, Category.assoc, IsIso.inv_comp_eq, prodComparison_natural]
+  rw [IsIso.eq_comp_inv, assoc, IsIso.inv_comp_eq, prodComparison_natural]
 
 /-- The natural isomorphism `F(A â¨¯ -) â‰… FA â¨¯ F-`, provided each `prodComparison F A B` is an
 isomorphism (as `B` changes).
@@ -1174,7 +1182,7 @@ theorem coprodComparison_inv_natural (f : A âŸ¶ A') (g : B âŸ¶ B') [IsIso (copro
     [IsIso (coprodComparison F A' B')] :
     inv (coprodComparison F A B) â‰« coprod.map (F.map f) (F.map g) =
       F.map (coprod.map f g) â‰« inv (coprodComparison F A' B') := by
-  rw [IsIso.eq_comp_inv, Category.assoc, IsIso.inv_comp_eq, coprodComparison_natural]
+  rw [IsIso.eq_comp_inv, assoc, IsIso.inv_comp_eq, coprodComparison_natural]
 
 /-- The natural isomorphism `FA â¨¿ F- â‰… F(A â¨¿ -)`, provided each `coprodComparison F A B` is an
 isomorphism (as `B` changes).
@@ -1209,7 +1217,7 @@ noncomputable def Over.coprod [HasBinaryCoproducts C] {A : C} : Over A â¥¤ Over
   obj f := Over.coprodObj f
   map k :=
     { app := fun g => Over.homMk (coprod.map k.left (ğŸ™ _)) (by
-        dsimp; rw [coprod.map_desc, Category.id_comp, Over.w k])
+        dsimp; rw [coprod.map_desc, id_comp, Over.w k])
       naturality := fun f g k => by
         ext
         simp }
diff --git a/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean b/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean
index 17d7fe8b12..d0b738730c 100644
--- a/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean
+++ b/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean
@@ -4,6 +4,7 @@ Released under Apache 2.0 license as described in the file LICENSE.
 Authors: Kim Morrison, Markus Himmel
 -/
 import Mathlib.CategoryTheory.EpiMono
+import Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts
 import Mathlib.CategoryTheory.Limits.HasLimits
 
 /-!
@@ -172,7 +173,7 @@ theorem walkingParallelPairOpEquiv_counitIso_one :
   rfl
 
 variable {C : Type u} [Category.{v} C]
-variable {X Y : C}
+variable {X Y Z : C}
 
 /-- `parallelPair f g` is the diagram in `C` consisting of the two morphisms `f` and `g` with
 common domain and codomain. -/
@@ -355,6 +356,23 @@ theorem Cofork.coequalizer_ext (s : Cofork f g) {W : C} {k l : s.pt âŸ¶ W}
   | zero => by simp only [s.app_zero_eq_comp_Ï€_left, Category.assoc, h]
   | one => h
 
+@[simp]
+theorem Fork.ofÎ¹_eq_self (w : Fork f g) : Fork.ofÎ¹ w.Î¹ w.condition = w :=
+  let ext (w w' : Fork f g) (hp : w.pt = w'.pt) (hÏ€ : w.Ï€ = hp â–¸ w'.Ï€) : w = w' := by
+    cases w; cases hp; cases hÏ€; rfl
+  have (X : WalkingParallelPair) : (Fork.ofÎ¹ w.Î¹ w.condition).Ï€.app X = w.Ï€.app X := by
+    cases X <;> simp
+  ext _ w (by rfl) (NatTrans.ext (funext this))
+
+@[simp]
+theorem Cofork.ofÏ€_eq_self (w : Cofork f g) : Cofork.ofÏ€ w.Ï€ w.condition = w :=
+  let ext (w w' : Cofork f g) (hp : w.pt = w'.pt) (hÎ¹ : w.Î¹ = hp â–¸ w'.Î¹) : w = w' := by
+    cases w; cases hp; cases hÎ¹; rfl
+  have (X : WalkingParallelPair) :
+    (Cofork.ofÏ€ w.Ï€ w.condition).Î¹.app X = w.Î¹.app X := by
+    cases X <;> simp
+  ext _ w (by rfl) (NatTrans.ext (funext this))
+
 theorem Fork.IsLimit.hom_ext {s : Fork f g} (hs : IsLimit s) {W : C} {k l : W âŸ¶ s.pt}
     (h : k â‰« Fork.Î¹ s = l â‰« Fork.Î¹ s) : k = l :=
   hs.hom_ext <| Fork.equalizer_ext _ h
@@ -698,6 +716,22 @@ def Cofork.isColimitOfIsos {X' Y' : C} (c : Cofork f g) (hc : IsColimit c)
     (commâ‚ƒ : eâ‚.inv â‰« c.Ï€ â‰« e.hom = c'.Ï€ := by cat_disch) : IsColimit c' :=
   (Cofork.isColimitEquivOfIsos c c' eâ‚€ eâ‚ e) hc
 
+lemma eq_of_lift_eq_diag (p : BinaryFan Z Z) (hp : IsLimit p)
+      {e : X âŸ¶ Y} {f g : Y âŸ¶ Z} {h : X âŸ¶ Z}
+      (eq : e â‰« hp.lift (BinaryFan.mk f g) = h â‰« (hp.lift (BinaryFan.mk (ğŸ™ Z) (ğŸ™ Z)))) :
+    e â‰« f = e â‰« g :=
+  by calc
+    e â‰« f = h     := by simpa using congr($eq â‰« p.fst)
+    _     = e â‰« g := by simpa using congr($eq.symm â‰« p.snd)
+
+lemma eq_of_desc_eq_codiag (p : BinaryCofan X X) (hp : IsColimit p)
+      {e : Y âŸ¶ Z} {f g : X âŸ¶ Y} {h : X âŸ¶ Z}
+      (eq : (hp.desc (BinaryCofan.mk f g)) â‰« e = (hp.desc (BinaryCofan.mk (ğŸ™ X) (ğŸ™ X))) â‰« h) :
+    f â‰« e = g â‰« e :=
+  by calc
+    f â‰« e = h     := by simpa using congr(p.inl â‰« $eq)
+    _     = g â‰« e := by simpa using congr(p.inr â‰« $eq.symm)
+
 variable (f g)
 
 section
@@ -741,6 +775,15 @@ noncomputable def equalizerIsEqualizer : IsLimit (Fork.ofÎ¹ (equalizer.Î¹ f g)
     (equalizer.condition f g)) :=
   IsLimit.ofIsoLimit (limit.isLimit _) (Fork.ext (Iso.refl _) (by simp))
 
+/-- The equalizer built from `equalizer.fork f g` is limiting. -/
+noncomputable def equalizerIsEqualizer' : IsLimit (equalizer.fork f g) :=
+  IsLimit.ofIsoLimit (limit.isLimit _) (Fork.ext (Iso.refl _) (by simp))
+
+@[simp]
+theorem equalizer.fork_ofÎ¹ :
+    Fork.ofÎ¹ (equalizer.Î¹ f g) (equalizer.condition f g) = equalizer.fork f g :=
+  Fork.ofÎ¹_eq_self (equalizer.fork f g)
+
 variable {f g}
 
 /-- A morphism `k : W âŸ¶ X` satisfying `k â‰« f = k â‰« g` factors through the equalizer of `f` and `g`
@@ -890,6 +933,15 @@ noncomputable def coequalizerIsCoequalizer :
     IsColimit (Cofork.ofÏ€ (coequalizer.Ï€ f g) (coequalizer.condition f g)) :=
   IsColimit.ofIsoColimit (colimit.isColimit _) (Cofork.ext (Iso.refl _) (by simp))
 
+/-- The cofork built from `coequalizer.Ï€ f g` is colimiting. -/
+noncomputable def coequalizerIsCoequalizer' : IsColimit (coequalizer.cofork f g) :=
+  IsColimit.ofIsoColimit (colimit.isColimit _) (Cofork.ext (Iso.refl _) (by simp))
+
+@[simp]
+theorem coequalizer.cofork_ofÏ€ :
+    Cofork.ofÏ€ (coequalizer.Ï€ f g) (coequalizer.condition f g) = coequalizer.cofork f g :=
+  Cofork.ofÏ€_eq_self (coequalizer.cofork f g)
+
 variable {f g}
 
 /-- Any morphism `k : Y âŸ¶ W` satisfying `f â‰« k = g â‰« k` factors through the coequalizer of `f`
@@ -1226,6 +1278,19 @@ noncomputable def splitEpiOfIdempotentCoequalizer {X : C} {f : X âŸ¶ X} (hf : f
     [HasCoequalizer (ğŸ™ X) f] : SplitEpi (coequalizer.Ï€ (ğŸ™ X) f) :=
   splitEpiOfIdempotentOfIsColimitCofork _ hf (colimit.isColimit _)
 
+variable [HasBinaryProducts C]
+
+local notation "pâŸ¨" f ", " g "âŸ©" => Limits.prod.lift f g
+
+/-- For `f : X âŸ¶ Y`, the pairing `pâŸ¨ğŸ™ X, fâŸ© : X âŸ¶ X â¨¯ Y` is the equalizer
+of the pair `(prod.fst â‰« f, prod.snd)`. -/
+noncomputable def graph_as_equalizer {X Y : C} (f : X âŸ¶ Y) :
+    IsLimit (Fork.ofÎ¹ pâŸ¨ğŸ™ X, fâŸ© ((by simp) : pâŸ¨ğŸ™ X, fâŸ© â‰« prod.fst â‰« f = pâŸ¨ğŸ™ X, fâŸ© â‰« prod.snd)) :=
+  Fork.IsLimit.mk _
+    (fun s => s.Î¹ â‰« prod.fst)
+    (fun s => ((by simp[prod.comp_lift, s.condition])))
+    (fun s m eq => by simp[â† eq])
+
 end CategoryTheory.Limits
 
 end
diff --git a/Mathlib/CategoryTheory/Limits/Shapes/Pullback/CommSq.lean b/Mathlib/CategoryTheory/Limits/Shapes/Pullback/CommSq.lean
index f95b2be8ce..b38676e3ca 100644
--- a/Mathlib/CategoryTheory/Limits/Shapes/Pullback/CommSq.lean
+++ b/Mathlib/CategoryTheory/Limits/Shapes/Pullback/CommSq.lean
@@ -373,6 +373,46 @@ lemma of_iso (h : IsPullback fst snd f g)
               rw [â† reassoc_of% commfst, eâ‚‚.hom_inv_id, Category.comp_id]
             Â· change snd = eâ‚.hom â‰« snd' â‰« eâ‚ƒ.inv
               rw [â† reassoc_of% commsnd, eâ‚ƒ.hom_inv_id, Category.comp_id]))âŸ©
+
+def isoIsPullback_congr
+      {P' X' Y' : C}
+      (iX : X â‰… X') (iY : Y â‰… Y')
+      {fst' : P' âŸ¶ X'} {snd' : P' âŸ¶ Y'}
+      {f' : X' âŸ¶ Z} {g' : Y' âŸ¶ Z}
+      (hf : iX.inv â‰« f = f') (hg : iY.inv â‰« g = g')
+      (pb : IsPullback fst snd f g)
+      (pb' : IsPullback fst' snd' f' g') :
+    P â‰… P' :=
+  have h_trans : IsPullback (fst â‰« iX.hom) (snd â‰« iY.hom) (iX.inv â‰« f) (iY.inv â‰« g) :=
+    IsPullback.of_iso pb
+      (Iso.refl P) (iX) (iY) (Iso.refl Z)
+      (by simp) (by simp) (by simp) (by simp)
+  IsPullback.isoIsPullback X' Y' h_trans (by simpa [hf, hg] using pb')
+
+@[reassoc (attr := simp)]
+lemma isoIsPullback_congr_hom_fst
+      {X' Y' P' : C}
+      (iX : X â‰… X') (iY : Y â‰… Y')
+      {fst' : P' âŸ¶ X'} {snd' : P' âŸ¶ Y'}
+      {f' : X' âŸ¶ Z} {g' : Y' âŸ¶ Z}
+      (hf : iX.inv â‰« f = f') (hg : iY.inv â‰« g = g')
+      (pb : IsPullback fst snd f g)
+      (pb' : IsPullback fst' snd' f' g') :
+    (isoIsPullback_congr iX iY hf hg pb pb').hom â‰« fst' = fst â‰« iX.hom := by
+  unfold isoIsPullback_congr; simp
+
+@[reassoc (attr := simp)]
+lemma isoIsPullback_congr_hom_snd
+      {X' Y' P' : C}
+      (iX : X â‰… X') (iY : Y â‰… Y')
+      {fst' : P' âŸ¶ X'} {snd' : P' âŸ¶ Y'}
+      {f' : X' âŸ¶ Z} {g' : Y' âŸ¶ Z}
+      (hf : iX.inv â‰« f = f') (hg : iY.inv â‰« g = g')
+      (pb : IsPullback fst snd f g)
+      (pb' : IsPullback fst' snd' f' g') :
+    (isoIsPullback_congr iX iY hf hg pb pb').hom â‰« snd' = snd â‰« iY.hom := by
+  unfold isoIsPullback_congr; simp
+
 section
 
 variable {P X Y : C} {fst : P âŸ¶ X} {snd : P âŸ¶ X} {f : X âŸ¶ Y} [Mono f]
diff --git a/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Equalizer.lean b/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Equalizer.lean
index acd890c5e8..8da00a78f9 100644
--- a/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Equalizer.lean
+++ b/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Equalizer.lean
@@ -4,6 +4,8 @@ Released under Apache 2.0 license as described in the file LICENSE.
 Authors: Andrew Yang
 -/
 import Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq
+import Mathlib.CategoryTheory.Monoidal.Cartesian.Basic
+
 
 /-!
 # Equalizers as pullbacks of products
@@ -14,35 +16,53 @@ Also see `CategoryTheory.Limits.Constructions.Equalizers` for very similar resul
 
 universe v u
 
+open CategoryTheory.Category CategoryTheory.CartesianMonoidalCategory
+
 namespace CategoryTheory.Limits
 
-variable {C : Type u} [Category.{v} C] {X Y : C} (f g : X âŸ¶ Y)
-
-/-- The equalizer of `f g : X âŸ¶ Y` is the pullback of the diagonal map `Y âŸ¶ Y Ã— Y`
-along the map `(f, g) : X âŸ¶ Y Ã— Y`. -/
-lemma isPullback_equalizer_prod [HasEqualizer f g] [HasBinaryProduct Y Y] :
-    IsPullback (equalizer.Î¹ f g) (equalizer.Î¹ f g â‰« f) (prod.lift f g) (prod.lift (ğŸ™ _) (ğŸ™ _)) := by
-  refine âŸ¨âŸ¨by ext <;> simp [equalizer.condition f g]âŸ©, âŸ¨PullbackCone.IsLimit.mk _ ?_ ?_ ?_ ?_âŸ©âŸ©
-  Â· refine fun s â†¦ equalizer.lift s.fst ?_
-    have Hâ‚ : s.fst â‰« f = s.snd := by simpa using congr($s.condition â‰« prod.fst)
-    have Hâ‚‚ : s.fst â‰« g = s.snd := by simpa using congr($s.condition â‰« prod.snd)
-    exact Hâ‚.trans Hâ‚‚.symm
-  Â· exact fun s â†¦ by simp
-  Â· exact fun s â†¦ by simpa using congr($s.condition â‰« prod.fst)
-  Â· exact fun s m hm _ â†¦ by ext; simp [*]
+variable {C : Type u} [Category.{v} C] {X Y Z : C}
+
+/-- If `e` is an equalizer of `f g : X âŸ¶ Y`, then `e` is also the pullback of the diagonal map
+`Y âŸ¶ Y â¨¯ Y` along `âŸ¨f, gâŸ© : X âŸ¶ Y â¨¯ Y`. Fully explicit version with binary fans and forks -/
+lemma isPullback_equalizer_binaryFan_fork {p : BinaryFan Y Y} (hp : IsLimit p)
+      (f g : X âŸ¶ Y) (e : Fork f g) (he : IsLimit e) :
+    IsPullback e.Î¹ (e.Î¹ â‰« f)
+      (hp.lift (BinaryFan.mk f g)) (hp.lift (BinaryFan.mk (ğŸ™ Y) (ğŸ™ Y))) := by
+  refine
+    âŸ¨ âŸ¨ BinaryFan.IsLimit.hom_ext hp (by simp) (by simp[e.condition]) âŸ©,
+      âŸ¨ PullbackCone.IsLimit.mk _ ?_ ?_ ?_ ?_ âŸ© âŸ©
+  Â· exact fun s â†¦ he.lift (Fork.ofÎ¹ s.fst (eq_of_lift_eq_diag p hp (s.condition)))
+  Â· exact fun s â†¦ Fork.IsLimit.lift_Î¹ he
+  Â· exact fun s â†¦ by simpa using congr($s.condition â‰« p.fst)
+  Â· exact fun _ _ hm _ â†¦ Fork.IsLimit.hom_ext he (Eq.symm (Fork.IsLimit.lift_Î¹ he) â–¸ hm)
+
+/-- The equalizer of `f g : X âŸ¶ Y` is the pullback of the diagonal map `Y âŸ¶ Y â¨¯ Y`
+  along the map `âŸ¨f, gâŸ© : X âŸ¶ Y â¨¯ Y`. Version with implicit products and equalizers. -/
+lemma isPullback_equalizer_prod (f g : X âŸ¶ Y) [HasEqualizer f g] [HasBinaryProduct Y Y] :
+      IsPullback (equalizer.Î¹ f g) (equalizer.Î¹ f g â‰« f) (prod.lift f g) (diag Y) :=
+    isPullback_equalizer_binaryFan_fork _
+      f g (equalizer.fork f g) (equalizerIsEqualizer' f g)
+
+/-- If `e` is an coequalizer of `f g : X âŸ¶ Y`, then `e` is also the pushout of the codiagonal map
+`X + X âŸ¶ X` along `âŸ¨f, gâŸ© : X + X âŸ¶ Y`. Fully explicit version with binary cofans and coforks. -/
+lemma isPushout_coequalizer_binaryCofan_coFork {p : BinaryCofan X X} (hp : IsColimit p)
+  (f g : X âŸ¶ Y) (e : Cofork f g) (h : IsColimit e) :
+    IsPushout (hp.desc (BinaryCofan.mk f g)) (hp.desc (BinaryCofan.mk (ğŸ™ X) (ğŸ™ X)))
+      e.Ï€ (f â‰« e.Ï€) := by
+  refine
+    âŸ¨ âŸ¨ BinaryCofan.IsColimit.hom_ext hp (by simp) (by simp[e.condition]) âŸ©,
+      âŸ¨ PushoutCocone.IsColimit.mk _ ?_ ?_ ?_ ?_ âŸ© âŸ©
+  Â· exact fun s â†¦ h.desc (Cofork.ofÏ€ s.inl (eq_of_desc_eq_codiag p hp (s.condition)))
+  Â· exact fun s â†¦ Cofork.IsColimit.Ï€_desc h
+  Â· exact fun s â†¦ by simpa using congr(p.inl â‰« $s.condition)
+  Â· exact fun _ _ hm _ â†¦ Cofork.IsColimit.hom_ext h (Eq.symm (Cofork.IsColimit.Ï€_desc h) â–¸ hm)
 
 /-- The coequalizer of `f g : X âŸ¶ Y` is the pushout of the diagonal map `X â¨¿ X âŸ¶ X`
-along the map `(f, g) : X â¨¿ X âŸ¶ Y`. -/
-lemma isPushout_coequalizer_coprod [HasCoequalizer f g] [HasBinaryCoproduct X X] :
-    IsPushout (coprod.desc f g) (coprod.desc (ğŸ™ _) (ğŸ™ _))
-      (coequalizer.Ï€ f g) (f â‰« coequalizer.Ï€ f g) := by
-  refine âŸ¨âŸ¨by ext <;> simp [coequalizer.condition f g]âŸ©, âŸ¨PushoutCocone.IsColimit.mk _ ?_ ?_ ?_ ?_âŸ©âŸ©
-  Â· refine fun s â†¦ coequalizer.desc s.inl ?_
-    have Hâ‚ : f â‰« s.inl = s.inr := by simpa using congr(coprod.inl â‰« $s.condition)
-    have Hâ‚‚ : g â‰« s.inl = s.inr := by simpa using congr(coprod.inr â‰« $s.condition)
-    exact Hâ‚.trans Hâ‚‚.symm
-  Â· exact fun s â†¦ by simp
-  Â· exact fun s â†¦ by simpa using congr(coprod.inl â‰« $s.condition)
-  Â· exact fun s m hm _ â†¦ by ext; simp [*]
+along the map `(f, g) : X â¨¿ X âŸ¶ Y`. Version with implicit coproducts and coequalizers -/
+lemma isPushout_coequalizer_coprod (f g : X âŸ¶ Y) [HasCoequalizer f g] [HasBinaryCoproduct X X] :
+    IsPushout (coprod.desc f g) (codiag X)
+      (coequalizer.Ï€ f g) (f â‰« coequalizer.Ï€ f g) :=
+  isPushout_coequalizer_binaryCofan_coFork _
+    f g (coequalizer.cofork f g) (coequalizerIsCoequalizer' f g)
 
 end CategoryTheory.Limits
diff --git a/Mathlib/CategoryTheory/Monoidal/Cartesian/Basic.lean b/Mathlib/CategoryTheory/Monoidal/Cartesian/Basic.lean
index 8b58ba85b2..8d7a53af72 100644
--- a/Mathlib/CategoryTheory/Monoidal/Cartesian/Basic.lean
+++ b/Mathlib/CategoryTheory/Monoidal/Cartesian/Basic.lean
@@ -223,6 +223,10 @@ Construct a morphism to the product given its two components.
 def lift {T X Y : C} (f : T âŸ¶ X) (g : T âŸ¶ Y) : T âŸ¶ X âŠ— Y :=
   (BinaryFan.IsLimit.lift' (tensorProductIsBinaryProduct X Y) f g).1
 
+@[simp]
+lemma lift_eq {T X Y : C} (f : T âŸ¶ X) (g : T âŸ¶ Y) :
+  (tensorProductIsBinaryProduct X Y).lift (BinaryFan.mk f g) = lift f g := rfl
+
 @[reassoc (attr := simp)]
 lemma lift_fst {T X Y : C} (f : T âŸ¶ X) (g : T âŸ¶ Y) : lift f g â‰« fst _ _ = f :=
   (BinaryFan.IsLimit.lift' (tensorProductIsBinaryProduct X Y) f g).2.1
@@ -276,6 +280,14 @@ lemma whiskerRight_fst {X Y : C} (f : X âŸ¶ Y) (Z : C) : f â–· Z â‰« fst _ _ = f
 lemma whiskerRight_snd {X Y : C} (f : X âŸ¶ Y) (Z : C) : f â–· Z â‰« snd _ _ = snd _ _ := by
   simp [snd_def, â† comp_whiskerRight_assoc]
 
+@[simp]
+lemma whiskerLeft_eq_lift {X Y Z : C} (f : Y âŸ¶ Z) :
+    (lift (fst X Y) (snd X Y â‰« f)) = X â— f := by aesop_cat
+
+@[simp]
+lemma whiskerRight_eq_lift {X Y Z : C} (f : X âŸ¶ Z) :
+    (lift (fst X Y â‰« f) (snd X Y)) = f â–· Y := by aesop_cat
+
 @[reassoc (attr := simp)]
 lemma tensorHom_fst {Xâ‚ Xâ‚‚ Yâ‚ Yâ‚‚ : C} (f : Xâ‚ âŸ¶ Xâ‚‚) (g : Yâ‚ âŸ¶ Yâ‚‚) :
     (f âŠ—â‚˜ g) â‰« fst _ _ = fst _ _ â‰« f := by simp [tensorHom_def]
diff --git a/Mathlib/CategoryTheory/Subobject/Basic.lean b/Mathlib/CategoryTheory/Subobject/Basic.lean
index bc9abec6e2..f925ff8bf8 100644
--- a/Mathlib/CategoryTheory/Subobject/Basic.lean
+++ b/Mathlib/CategoryTheory/Subobject/Basic.lean
@@ -186,9 +186,13 @@ noncomputable def arrow {X : C} (Y : Subobject X) : (Y : C) âŸ¶ X :=
 instance arrow_mono {X : C} (Y : Subobject X) : Mono Y.arrow :=
   (representative.obj Y).property
 
+def isoFromEq {A : C} {X Y : Subobject A} (h : X = Y) :=
+  eqToIso (congr_arg (fun X : Subobject A => (X : C)) h)
+
 @[simp]
 theorem arrow_congr {A : C} (X Y : Subobject A) (h : X = Y) :
-    eqToHom (congr_arg (fun X : Subobject A => (X : C)) h) â‰« Y.arrow = X.arrow := by
+    (isoFromEq h).hom â‰« Y.arrow = X.arrow := by
+  unfold isoFromEq
   induction h
   simp
 
diff --git a/Mathlib/CategoryTheory/Topos/Classifier.lean b/Mathlib/CategoryTheory/Topos/Classifier.lean
index fceb5b45d7..dd7abbc0c6 100644
--- a/Mathlib/CategoryTheory/Topos/Classifier.lean
+++ b/Mathlib/CategoryTheory/Topos/Classifier.lean
@@ -72,9 +72,7 @@ variable (C : Type u) [Category.{v} C]
 ```
 An equivalent formulation replaces `Î©â‚€` with the terminal object.
 -/
-structure Classifier where
-  /-- The domain of the truth morphism -/
-  Î©â‚€ : C
+structure Classifier (Î©â‚€ : C) where
   /-- The codomain of the truth morphism -/
   Î© : C
   /-- The truth morphism of the subobject classifier -/
@@ -108,8 +106,7 @@ def mkOfTerminalÎ©â‚€
     (isPullback : âˆ€ {U X : C} (m : U âŸ¶ X) [Mono m],
       IsPullback m (t.from U) (Ï‡ m) truth)
     (uniq : âˆ€ {U X : C} (m : U âŸ¶ X) [Mono m] (Ï‡' : X âŸ¶ Î©)
-      (_ : IsPullback m (t.from U) Ï‡' truth), Ï‡' = Ï‡ m) : Classifier C where
-  Î©â‚€ := Î©â‚€
+      (_ : IsPullback m (t.from U) Ï‡' truth), Ï‡' = Ï‡ m) : Classifier C Î©â‚€ where
   Î© := Î©
   truth := truth
   mono_truth := t.mono_from _
@@ -118,7 +115,12 @@ def mkOfTerminalÎ©â‚€
   isPullback m _ := isPullback m
   uniq m _ Ï‡â‚€' Ï‡' hÏ‡' := uniq m Ï‡' ((t.hom_ext Ï‡â‚€' (t.from _)) â–¸ hÏ‡')
 
-instance {c : Classifier C} : âˆ€ Y : C, Unique (Y âŸ¶ c.Î©â‚€) := fun Y =>
+variable {Î©â‚€ : C}
+
+/-- Given `c : Classifier C`, `c.Î©â‚€` is a terminal object.
+Prefer `c.Ï‡â‚€` over `c.isTerminalÎ©â‚€.from`. -/
+def isTerminalÎ©â‚€ {c : Classifier C Î©â‚€} : IsTerminal Î©â‚€ :=
+  have : âˆ€ Y : C, Unique (Y âŸ¶ Î©â‚€) := fun Y â†¦
   { default := c.Ï‡â‚€ Y,
     uniq f :=
       have : f â‰« c.truth = c.Ï‡â‚€ Y â‰« c.truth :=
@@ -126,40 +128,36 @@ instance {c : Classifier C} : âˆ€ Y : C, Unique (Y âŸ¶ c.Î©â‚€) := fun Y =>
           _ = c.Ï‡ (ğŸ™ Y) := c.uniq (ğŸ™ Y) (of_horiz_isIso_mono { })
           _ = c.Ï‡â‚€ Y â‰« c.truth := by simp [â† (c.isPullback (ğŸ™ Y)).w]
       Mono.right_cancellation _ _ this }
-
-/-- Given `c : Classifier C`, `c.Î©â‚€` is a terminal object.
-Prefer `c.Ï‡â‚€` over `c.isTerminalÎ©â‚€.from`. -/
-def isTerminalÎ©â‚€ {c : Classifier C} : IsTerminal c.Î©â‚€ := IsTerminal.ofUnique c.Î©â‚€
+  IsTerminal.ofUnique Î©â‚€
 
 @[simp]
-lemma isTerminalFrom_eq_Ï‡â‚€ (c : Classifier C) : c.isTerminalÎ©â‚€.from = c.Ï‡â‚€ := rfl
+lemma isTerminalFrom_eq_Ï‡â‚€ (c : Classifier C Î©â‚€) : c.isTerminalÎ©â‚€.from = c.Ï‡â‚€ := rfl
 
 end Classifier
 
 /-- A category `C` has a subobject classifier if there is at least one subobject classifier. -/
 class HasClassifier (C : Type u) [Category.{v} C] : Prop where
   /-- There is some classifier. -/
-  exists_classifier : Nonempty (Classifier C)
+  exists_classifier : Nonempty (Î£ Î©â‚€, Classifier C Î©â‚€)
 
 namespace HasClassifier
 
 variable (C) [HasClassifier C]
 
 noncomputable section
-
 /-- Notation for the `Î©â‚€` in an arbitrary choice of a subobject classifier -/
-abbrev Î©â‚€ : C := HasClassifier.exists_classifier.some.Î©â‚€
+abbrev Î©â‚€ : C := HasClassifier.exists_classifier.some.1
+private abbrev cÎ©â‚€ : Classifier C (Î©â‚€ C) := HasClassifier.exists_classifier.some.2
 /-- Notation for the `Î©` in an arbitrary choice of a subobject classifier -/
-abbrev Î© : C := HasClassifier.exists_classifier.some.Î©
+abbrev Î© : C := (cÎ©â‚€ C).Î©
 
 /-- Notation for the "truth arrow" in an arbitrary choice of a subobject classifier -/
-abbrev truth : Î©â‚€ C âŸ¶ Î© C := HasClassifier.exists_classifier.some.truth
+abbrev truth : Î©â‚€ C âŸ¶ Î© C := (cÎ©â‚€ C).truth
 
 variable {C} {U X : C} (m : U âŸ¶ X) [Mono m]
 
 /-- returns the characteristic morphism of the subobject `(m : U âŸ¶ X) [Mono m]` -/
-def Ï‡ : X âŸ¶ Î© C :=
-  HasClassifier.exists_classifier.some.Ï‡ m
+def Ï‡ : X âŸ¶ Î© C := (cÎ©â‚€ C).Ï‡ m
 
 /-- The diagram
 ```
@@ -172,7 +170,7 @@ def Ï‡ : X âŸ¶ Î© C :=
 ```
 is a pullback square.
 -/
-lemma isPullback_Ï‡ : IsPullback m (Classifier.Ï‡â‚€ _ U) (Ï‡ m) (truth C) :=
+lemma isPullback_Ï‡ : IsPullback m (Classifier.Ï‡â‚€ (cÎ©â‚€ C) U) (Ï‡ m) (truth C) :=
   Classifier.isPullback _ m
 
 /-- The diagram
@@ -187,16 +185,16 @@ lemma isPullback_Ï‡ : IsPullback m (Classifier.Ï‡â‚€ _ U) (Ï‡ m) (truth C) :=
 commutes.
 -/
 @[reassoc]
-lemma comm : m â‰« Ï‡ m = Classifier.Ï‡â‚€ _ U â‰« truth C := (isPullback_Ï‡ m).w
+lemma comm : m â‰« Ï‡ m = (cÎ©â‚€ C).Ï‡â‚€ U â‰« truth C := (isPullback_Ï‡ m).w
 
 /-- `Ï‡ m` is the only map for which the associated square
 is a pullback square.
 -/
-lemma unique (Ï‡' : X âŸ¶ Î© C) (hÏ‡' : IsPullback m (Classifier.Ï‡â‚€ _ U) Ï‡' (truth C)) : Ï‡' = Ï‡ m :=
-  Classifier.uniq _ m hÏ‡'
+lemma unique (Ï‡' : X âŸ¶ Î© C) (hÏ‡' : IsPullback m ((cÎ©â‚€ C).Ï‡â‚€ U) Ï‡' (truth C)) :
+  Ï‡' = Ï‡ m := (cÎ©â‚€ C).uniq m hÏ‡'
 
 instance truthIsSplitMono : IsSplitMono (truth C) :=
-  Classifier.isTerminalÎ©â‚€.isSplitMono_from _
+  (cÎ©â‚€ C).isTerminalÎ©â‚€.isSplitMono_from _
 
 /-- `truth C` is a regular monomorphism (because it is split). -/
 noncomputable instance truthIsRegularMono : RegularMono (truth C) :=
@@ -251,7 +249,7 @@ open Subobject
 
 section RepresentableBy
 
-variable {C : Type u} [Category.{v} C] [HasPullbacks C] (ğ’ : Classifier C)
+variable {C : Type u} [Category.{v} C] [HasPullbacks C] {Î©â‚€ : C} (ğ’ : Classifier C Î©â‚€)
 
 /-- The subobject of `ğ’.Î©` corresponding to the `truth` morphism. -/
 abbrev truth_as_subobject : Subobject ğ’.Î© :=
@@ -404,8 +402,7 @@ noncomputable def isoÎ©â‚€ : (h.Î©â‚€ : C) â‰… âŠ¤_ C :=
 
 /-- Any representation `Î©` of `Subobject.presheaf C` gives a subobject classifier with truth values
 object `Î©`. -/
-noncomputable def classifier : Classifier C where
-  Î©â‚€ := âŠ¤_ C
+noncomputable def classifier : Classifier C (âŠ¤_ C) where
   Î© := Î©
   truth := h.isoÎ©â‚€.inv â‰« h.Î©â‚€.arrow
   mono_truth := terminalIsTerminal.mono_from _
@@ -430,12 +427,12 @@ variable [HasTerminal C]
 theorem isRepresentable_hasClassifier_iff [HasPullbacks C] :
     HasClassifier C â†” (Subobject.presheaf C).IsRepresentable := by
   constructor <;> intro h
-  Â· obtain âŸ¨âŸ¨ğ’âŸ©âŸ© := h
+  Â· obtain âŸ¨âŸ¨Î©â‚€, ğ’âŸ©âŸ© := h
     apply RepresentableBy.isRepresentable
     exact ğ’.representableBy
   Â· obtain âŸ¨Î©, âŸ¨hâŸ©âŸ© := h
     constructor; constructor
-    exact Classifier.SubobjectRepresentableBy.classifier h
+    exact âŸ¨âŠ¤_ C, Classifier.SubobjectRepresentableBy.classifier hâŸ©
 
 end Representability
 end CategoryTheory
