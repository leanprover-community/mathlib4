diff --git a/Mathlib.lean b/Mathlib.lean
index 0b2dbf0646..f1cf85c71b 100644
--- a/Mathlib.lean
+++ b/Mathlib.lean
@@ -2131,6 +2131,7 @@ import Mathlib.CategoryTheory.Closed.FunctorCategory.Groupoid
 import Mathlib.CategoryTheory.Closed.FunctorToTypes
 import Mathlib.CategoryTheory.Closed.Ideal
 import Mathlib.CategoryTheory.Closed.Monoidal
+import Mathlib.CategoryTheory.Closed.PowerObjects
 import Mathlib.CategoryTheory.Closed.Types
 import Mathlib.CategoryTheory.Closed.Zero
 import Mathlib.CategoryTheory.CodiscreteCategory
@@ -2786,6 +2787,7 @@ import Mathlib.CategoryTheory.Sums.Associator
 import Mathlib.CategoryTheory.Sums.Basic
 import Mathlib.CategoryTheory.Sums.Products
 import Mathlib.CategoryTheory.Thin
+import Mathlib.CategoryTheory.Topos.Basic
 import Mathlib.CategoryTheory.Topos.Classifier
 import Mathlib.CategoryTheory.Triangulated.Adjunction
 import Mathlib.CategoryTheory.Triangulated.Basic
diff --git a/Mathlib/CategoryTheory/Closed/PowerObjects.lean b/Mathlib/CategoryTheory/Closed/PowerObjects.lean
new file mode 100644
index 0000000000..9b221cc485
--- /dev/null
+++ b/Mathlib/CategoryTheory/Closed/PowerObjects.lean
@@ -0,0 +1,178 @@
+/-
+Copyright (c) 2025 Klaus Gy. All rights reserved.
+Released under Apache 2.0 license as described in the file LICENSE.
+Authors: Klaus Gy
+-/
+import Mathlib.CategoryTheory.Limits.Shapes.Pullback.Equalizer
+import Mathlib.CategoryTheory.Topos.Classifier
+/-!
+# Elementary Topos (in Elementary Form)
+
+This ongoing work formalizes the elementary definition of a topos and the direct consequences.
+
+## References
+
+* [S. MacLane and I. Moerdijk, *Sheaves in Geometry and Logic*][MM92]
+-/
+
+universe u v
+
+open CategoryTheory
+open Category Functor Limits Opposite Prod
+
+variable {‚Ñ∞ : Type u} [Category.{v} ‚Ñ∞]
+
+namespace LeftRepresentable
+
+variable {F : ‚Ñ∞·µí·µñ √ó ‚Ñ∞·µí·µñ ‚•§ Type (max u v)}
+
+variable {B PB : ‚Ñ∞} (hPB : ((curryObj F).obj (op B)).RepresentableBy PB)
+  {C PC : ‚Ñ∞} (hPC : ((curryObj F).obj (op C)).RepresentableBy PC)
+
+/-- The morphism induced by a morphism between the base objects. -/
+def map (h : B ‚ü∂ C) : PC ‚ü∂ PB :=
+  hPB.homEquiv.symm (F.map (h.op √ó‚Çò ùüô (op PC)) (hPC.homEquiv (ùüô PC)))
+
+lemma map_universal (h : B ‚ü∂ C) :
+  F.map (ùüô (op B) √ó‚Çò (map hPB hPC h).op) (hPB.homEquiv (ùüô PB))
+    = F.map (h.op √ó‚Çò ùüô (op PC)) (hPC.homEquiv (ùüô PC)) := by
+  calc
+    _ = ((curryObj F).obj (op B)).map (map hPB hPC h).op (hPB.homEquiv (ùüô PB)) := by rfl
+    _ = F.map (h.op √ó‚Çò ùüô (op PC)) (hPC.homEquiv (ùüô PC)) := by
+      rw [‚Üê hPB.homEquiv_eq, map, hPB.homEquiv.apply_symm_apply]
+
+variable {D PD : ‚Ñ∞} (hPD : ((curryObj F).obj (op D)).RepresentableBy PD)
+
+lemma compose (h : B ‚ü∂ C) (h' : C ‚ü∂ D) :
+    map hPB hPD (h ‚â´ h') = map hPC hPD h' ‚â´ map hPB hPC h := by
+  let Ph := map hPB hPC h
+  let Ph' := map hPC hPD h'
+  apply hPB.homEquiv.injective
+  calc
+    _ = F.map ((h'.op √ó‚Çò ùüô _) ‚â´ (h.op √ó‚Çò ùüô _)) (hPD.homEquiv (ùüô PD)) := by unfold map; simp
+    _ = F.map ((ùüô _ √ó‚Çò Ph'.op) ‚â´ (h.op √ó‚Çò ùüô _)) (hPC.homEquiv (ùüô PC)) := by
+      rw[FunctorToTypes.map_comp_apply, ‚Üê map_universal, ‚Üê FunctorToTypes.map_comp_apply]
+    _ = F.map ((h.op √ó‚Çò ùüô _) ‚â´ (ùüô _ √ó‚Çò Ph'.op)) (hPC.homEquiv (ùüô PC)) := by simp
+    _ = F.map ((ùüô _ √ó‚Çò Ph.op) ‚â´ (ùüô _ √ó‚Çò Ph'.op)) (hPB.homEquiv (ùüô PB)) := by
+      rw[FunctorToTypes.map_comp_apply, ‚Üê map_universal, ‚Üê FunctorToTypes.map_comp_apply]
+    _ = (F.curryObj.obj _).map (Ph' ‚â´ Ph).op (hPB.homEquiv (ùüô PB)) := by
+      simp [curryObj, ‚Üê FunctorToTypes.map_comp_apply]
+    _ = hPB.homEquiv (Ph' ‚â´ Ph) := by rw[‚Üê hPB.homEquiv_eq]
+
+/-- Let `F : ‚Ñ∞·µí·µñ √ó ‚Ñ∞·µí·µñ ‚•§ Type`. If for each `B` we choose
+an object `P B` representing the functor `A ‚Ü¶ F (B, A)`,
+then these choices assemble into a covariant functor `‚Ñ∞·µí·µñ ‚•§ ‚Ñ∞`. -/
+def functor (P : ‚Ñ∞ ‚Üí ‚Ñ∞) (hP : ‚àÄ B : ‚Ñ∞, ((curryObj F).obj (op B)).RepresentableBy (P B)) :
+    ‚Ñ∞·µí·µñ ‚•§ ‚Ñ∞ :=
+  { obj (B : ‚Ñ∞·µí·µñ) := P (unop B),
+    map {B C : ‚Ñ∞·µí·µñ} (h : B ‚ü∂ C) := map (hP (unop C)) (hP (unop B)) h.unop,
+    map_id (_) := by
+      change (hP _).homEquiv.symm (F.map (ùüô _) ((hP _).homEquiv (ùüô _))) = ùüô _
+      rw[FunctorToTypes.map_id_apply]; simp
+    map_comp {B C D : ‚Ñ∞·µí·µñ} (h : B ‚ü∂ C) (h' : C ‚ü∂ D) :=
+      compose (hP (unop D)) (hP (unop C)) (hP (unop B)) h'.unop h.unop }
+
+end LeftRepresentable
+
+open CartesianMonoidalCategory MonoidalCategory
+
+variable [CartesianMonoidalCategory ‚Ñ∞]
+
+private abbrev cmdiag (X : ‚Ñ∞) : X ‚ü∂ X ‚äó X := lift (ùüô X) (ùüô X)
+
+private lemma pullback_of_diag {B X : ‚Ñ∞} (b : X ‚ü∂ B) :
+    IsPullback b (lift b (ùüô X)) (cmdiag B) (B ‚óÅ b) :=
+  let eq : lift b (ùüô X) ‚â´ fst B X = lift b (ùüô X) ‚â´ snd B X ‚â´ b := by simp
+  let lim : IsLimit (Fork.ofŒπ (lift b (ùüô X)) eq) :=
+    Fork.IsLimit.mk _
+      (fun s => s.Œπ ‚â´ (snd B X))
+      (fun s => by simp[‚Üê s.condition])
+      (fun s m eq => by simp[‚Üê eq])
+  let pb : IsPullback _ (_ ‚â´ fst B X) (lift (fst B X) (snd B X ‚â´ b)) (cmdiag B) :=
+    isPullback_equalizer_binaryFan_fork _ (fst B X) (snd B X ‚â´ b) _ lim
+  IsPullback.flip
+    (by simpa using pb)
+
+private lemma eq_of_lift_through_diag {X Y : ‚Ñ∞} {f f' g : X ‚ü∂ Y}
+    (h : lift f f' = g ‚â´ cmdiag Y) : f = f' := by
+  calc
+    _ = (lift f f') ‚â´ (fst Y Y) := by simp
+    _ = (lift f f') ‚â´ (snd Y Y) := by simp[h]
+    _ = f' := by simp
+
+variable [HasPullbacks ‚Ñ∞]
+
+/-- The subobject functor for products. -/
+noncomputable def subobjProd : ‚Ñ∞·µí·µñ √ó ‚Ñ∞·µí·µñ ‚•§ Type (max u v) where
+  obj P := Subobject (unop P.1 ‚äó unop P.2)
+  map f := (Subobject.pullback (f.1.unop ‚äó‚Çò f.2.unop)).obj
+  map_id A := by ext1 x; simp [Subobject.pullback_id]
+  map_comp f f' := by ext1 x; simp [Subobject.pullback_comp]
+
+/-- `P` is a power object of `B` if it represents the functor `A ‚Ü¶ Subobject (B ‚äó A)`. -/
+def IsPowerObjectOf (B P : ‚Ñ∞) :=
+  (subobjProd.curryObj.obj (op B)).RepresentableBy P
+
+namespace PowerObject
+
+variable {B PB : ‚Ñ∞} (hPB : IsPowerObjectOf B PB)
+
+section functoriality
+
+variable {C PC : ‚Ñ∞} (hPC : IsPowerObjectOf C PC)
+  {D PD : ‚Ñ∞} (hPD : IsPowerObjectOf D PD)
+
+/-- Functoriality on the left variable of the bifunctor `(B, A) ‚Ü¶ Subobject (B ‚äó A)`:
+a map `h : B ‚ü∂ C` induces `PC ‚ü∂ PB` via left-representability. -/
+noncomputable def map (h : B ‚ü∂ C) : PC ‚ü∂ PB := LeftRepresentable.map hPB hPC h
+
+lemma compose (h : B ‚ü∂ C) (h' : C ‚ü∂ D) :
+    map hPB hPD (h ‚â´ h') = map hPC hPD h' ‚â´ map hPB hPC h :=
+  LeftRepresentable.compose hPB hPC hPD h h'
+
+/-- Given a choice of representing objects `P B` for the functors `A ‚Ü¶ Subobject (B ‚äó A)`,
+then these choices assemble into a covariant functor `‚Ñ∞·µí·µñ ‚•§ ‚Ñ∞`. -/
+noncomputable def functor (P : ‚Ñ∞ ‚Üí ‚Ñ∞) (hP : ‚àÄ B : ‚Ñ∞, IsPowerObjectOf B (P B)) : ‚Ñ∞·µí·µñ ‚•§ ‚Ñ∞ :=
+  LeftRepresentable.functor P hP
+
+end functoriality
+
+/-- The singleton morphism from `B` to `PB`. -/
+def singleton : B ‚ü∂ PB :=
+  hPB.homEquiv.invFun (Subobject.mk (cmdiag B))
+
+/-- The classifying subobject on `B ‚äó PB` associated to the chosen representation. -/
+def epsilon : Subobject (B ‚äó PB) := hPB.homEquiv (ùüô PB)
+
+private lemma pullback_diag_eq_singleton {X} (f : X ‚ü∂ B) :
+      (Subobject.pullback (B ‚óÅ f)).obj (Subobject.mk (cmdiag B)) =
+    hPB.homEquiv (f ‚â´ singleton hPB) := by
+  calc
+    _ = (subobjProd.curryObj.obj (op B)).map f.op (hPB.homEquiv (singleton hPB)) := by
+      simp[subobjProd, curryObj, singleton]
+    _ = hPB.homEquiv (f ‚â´ singleton hPB) := Eq.symm (hPB.homEquiv_comp f (singleton hPB))
+
+noncomputable instance singleton_is_mono : Mono (singleton hPB) :=
+  ‚ü® fun {X} (b b' : X ‚ü∂ B) eq ‚Ü¶
+    let B_sub := Subobject.mk (cmdiag B)
+    let P := (Subobject.pullback (B ‚óÅ b)).obj B_sub
+    let P' := (Subobject.pullback (B ‚óÅ b')).obj B_sub
+    let PeqP' : P = P' := by
+      unfold P P'
+      rw[pullback_diag_eq_singleton hPB b, eq, ‚Üê pullback_diag_eq_singleton hPB b']
+    let Œπ : X ‚âÖ Subobject.underlying.obj P :=
+      IsPullback.isoIsPullback_congr
+        (Subobject.underlyingIso (cmdiag B)).symm (Iso.refl (B ‚äó X))
+        (Subobject.underlyingIso_hom_comp_eq_mk (cmdiag B)) (by simp)
+        (pullback_of_diag b) (Subobject.isPullback (B ‚óÅ b) B_sub)
+    let eq‚ÇÅ : (lift b (ùüô X)) = Œπ.hom ‚â´ P.arrow := by unfold P Œπ; simp
+    let eq‚ÇÇ := Eq.symm (Subobject.arrow_congr P P' PeqP')
+    let eq‚ÇÉ := Eq.symm (Subobject.isPullback (B ‚óÅ b') B_sub).w
+    let eq‚ÇÑ := Eq.symm (Subobject.underlyingIso_hom_comp_eq_mk (cmdiag B))
+    have : (lift b b') = _ ‚â´ cmdiag B := by
+      calc
+        _ = (lift b (ùüô X)) ‚â´ B ‚óÅ b' := by simp
+        _ = _ ‚â´ cmdiag B := by rw[eq‚ÇÅ, assoc, eq‚ÇÇ, assoc, eq‚ÇÉ, assoc, eq‚ÇÑ, ‚Üê assoc, ‚Üê assoc]
+    eq_of_lift_through_diag this ‚ü©
+
+end PowerObject
diff --git a/Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean b/Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean
index 93f5b673a0..5ef650d62b 100644
--- a/Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean
+++ b/Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean
@@ -30,7 +30,7 @@ braiding and associating isomorphisms, and the product comparison morphism.
 
 universe v v‚ÇÅ u u‚ÇÅ u‚ÇÇ
 
-open CategoryTheory
+open CategoryTheory Category
 
 namespace CategoryTheory.Limits
 
@@ -386,7 +386,7 @@ theorem BinaryFan.isLimit_iff_isIso_fst {X Y : C} (h : IsTerminal Y) (c : Binary
     obtain ‚ü®l, hl, -‚ü© := BinaryFan.IsLimit.lift' H (ùüô X) (h.from X)
     exact
       ‚ü®‚ü®l,
-          BinaryFan.IsLimit.hom_ext H (by simpa [hl, -Category.comp_id] using Category.comp_id _)
+          BinaryFan.IsLimit.hom_ext H (by simpa [hl, -comp_id] using comp_id _)
             (h.hom_ext _ _),
           hl‚ü©‚ü©
   ¬∑ intro
@@ -433,9 +433,9 @@ theorem BinaryCofan.isColimit_iff_isIso_inl {X Y : C} (h : IsInitial Y) (c : Bin
   ¬∑ rintro ‚ü®H‚ü©
     obtain ‚ü®l, hl, -‚ü© := BinaryCofan.IsColimit.desc' H (ùüô X) (h.to X)
     refine ‚ü®‚ü®l, hl, BinaryCofan.IsColimit.hom_ext H (?_) (h.hom_ext _ _)‚ü©‚ü©
-    rw [Category.comp_id]
+    rw [comp_id]
     have e : (inl c ‚â´ l) ‚â´ inl c = ùüô X ‚â´ inl c := congrArg (¬∑‚â´inl c) hl
-    rwa [Category.assoc,Category.id_comp] at e
+    rwa [assoc,id_comp] at e
   ¬∑ intro
     exact
       ‚ü®BinaryCofan.IsColimit.mk _ (fun f _ => inv c.inl ‚â´ f)
@@ -519,8 +519,8 @@ noncomputable def coprodIsCoprod (X Y : C) [HasBinaryCoproduct X Y] :
     IsColimit (BinaryCofan.mk (coprod.inl : X ‚ü∂ X ‚®ø Y) coprod.inr) :=
   (colimit.isColimit _).ofIsoColimit (Cocones.ext (Iso.refl _) (fun ‚ü®u‚ü© => by
     cases u
-    ¬∑ dsimp; simp only [Category.comp_id]
-    ¬∑ dsimp; simp only [Category.comp_id]
+    ¬∑ dsimp; simp only [comp_id]
+    ¬∑ dsimp; simp only [comp_id]
   ))
 
 @[ext 1100]
@@ -622,7 +622,7 @@ theorem prod.comp_lift {V W X Y : C} [HasBinaryProduct X Y] (f : V ‚ü∂ W) (g : W
     f ‚â´ prod.lift g h = prod.lift (f ‚â´ g) (f ‚â´ h) := by ext <;> simp
 
 theorem prod.comp_diag {X Y : C} [HasBinaryProduct Y Y] (f : X ‚ü∂ Y) :
-    f ‚â´ diag Y = prod.lift f f := by simp
+    f ‚â´ diag Y = lift f f := by simp
 
 @[reassoc (attr := simp)]
 theorem prod.map_fst {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : W ‚ü∂ Y)
@@ -642,6 +642,10 @@ theorem prod.map_id_id {X Y : C} [HasBinaryProduct X Y] : prod.map (ùüô X) (
 theorem prod.lift_fst_snd {X Y : C} [HasBinaryProduct X Y] :
     prod.lift prod.fst prod.snd = ùüô (X ‚®Ø Y) := by ext <;> simp
 
+@[simp]
+lemma prod.lift_comp_fst_snd {X Y Z : C} [HasBinaryProduct Y Z] (f : X ‚ü∂ Y ‚®Ø Z) :
+    prod.lift (f ‚â´ prod.fst) (f ‚â´ prod.snd) = f := by ext <;> simp
+
 @[reassoc (attr := simp)]
 theorem prod.lift_map {V W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : V ‚ü∂ W)
     (g : V ‚ü∂ X) (h : W ‚ü∂ Y) (k : X ‚ü∂ Z) :
@@ -744,6 +748,10 @@ theorem coprod.map_id_id {X Y : C} [HasBinaryCoproduct X Y] : coprod.map (ùüô X
 theorem coprod.desc_inl_inr {X Y : C} [HasBinaryCoproduct X Y] :
     coprod.desc coprod.inl coprod.inr = ùüô (X ‚®ø Y) := by ext <;> simp
 
+@[simp]
+lemma coprod.desc_comp_inl_inr {X Y Z : C} [HasBinaryCoproduct X Y] (f : X ‚®ø Y ‚ü∂ Z) :
+    coprod.desc (coprod.inl ‚â´ f) (coprod.inr ‚â´ f) = f := by ext <;> simp
+
 -- The simp linter says simp can prove the reassoc version of this lemma.
 @[reassoc, simp]
 theorem coprod.map_desc {S T U V W : C} [HasBinaryCoproduct U W] [HasBinaryCoproduct T V]
@@ -913,7 +921,7 @@ theorem prod.leftUnitor_hom_naturality [HasBinaryProducts C] (f : X ‚ü∂ Y) :
 @[reassoc]
 theorem prod.leftUnitor_inv_naturality [HasBinaryProducts C] (f : X ‚ü∂ Y) :
     (prod.leftUnitor X).inv ‚â´ prod.map (ùüô _) f = f ‚â´ (prod.leftUnitor Y).inv := by
-  rw [Iso.inv_comp_eq, ‚Üê Category.assoc, Iso.eq_comp_inv, prod.leftUnitor_hom_naturality]
+  rw [Iso.inv_comp_eq, ‚Üê assoc, Iso.eq_comp_inv, prod.leftUnitor_hom_naturality]
 
 @[reassoc]
 theorem prod.rightUnitor_hom_naturality [HasBinaryProducts C] (f : X ‚ü∂ Y) :
@@ -923,7 +931,7 @@ theorem prod.rightUnitor_hom_naturality [HasBinaryProducts C] (f : X ‚ü∂ Y) :
 @[reassoc]
 theorem prod_rightUnitor_inv_naturality [HasBinaryProducts C] (f : X ‚ü∂ Y) :
     (prod.rightUnitor X).inv ‚â´ prod.map f (ùüô _) = f ‚â´ (prod.rightUnitor Y).inv := by
-  rw [Iso.inv_comp_eq, ‚Üê Category.assoc, Iso.eq_comp_inv, prod.rightUnitor_hom_naturality]
+  rw [Iso.inv_comp_eq, ‚Üê assoc, Iso.eq_comp_inv, prod.rightUnitor_hom_naturality]
 
 theorem prod.triangle [HasBinaryProducts C] (X Y : C) :
     (prod.associator X (‚ä§_ C) Y).hom ‚â´ prod.map (ùüô X) (prod.leftUnitor Y).hom =
@@ -1097,7 +1105,7 @@ theorem prodComparison_inv_natural (f : A ‚ü∂ A') (g : B ‚ü∂ B') [IsIso (prodCom
     [IsIso (prodComparison F A' B')] :
     inv (prodComparison F A B) ‚â´ F.map (prod.map f g) =
       prod.map (F.map f) (F.map g) ‚â´ inv (prodComparison F A' B') := by
-  rw [IsIso.eq_comp_inv, Category.assoc, IsIso.inv_comp_eq, prodComparison_natural]
+  rw [IsIso.eq_comp_inv, assoc, IsIso.inv_comp_eq, prodComparison_natural]
 
 /-- The natural isomorphism `F(A ‚®Ø -) ‚âÖ FA ‚®Ø F-`, provided each `prodComparison F A B` is an
 isomorphism (as `B` changes).
@@ -1174,7 +1182,7 @@ theorem coprodComparison_inv_natural (f : A ‚ü∂ A') (g : B ‚ü∂ B') [IsIso (copro
     [IsIso (coprodComparison F A' B')] :
     inv (coprodComparison F A B) ‚â´ coprod.map (F.map f) (F.map g) =
       F.map (coprod.map f g) ‚â´ inv (coprodComparison F A' B') := by
-  rw [IsIso.eq_comp_inv, Category.assoc, IsIso.inv_comp_eq, coprodComparison_natural]
+  rw [IsIso.eq_comp_inv, assoc, IsIso.inv_comp_eq, coprodComparison_natural]
 
 /-- The natural isomorphism `FA ‚®ø F- ‚âÖ F(A ‚®ø -)`, provided each `coprodComparison F A B` is an
 isomorphism (as `B` changes).
@@ -1209,7 +1217,7 @@ noncomputable def Over.coprod [HasBinaryCoproducts C] {A : C} : Over A ‚•§ Over
   obj f := Over.coprodObj f
   map k :=
     { app := fun g => Over.homMk (coprod.map k.left (ùüô _)) (by
-        dsimp; rw [coprod.map_desc, Category.id_comp, Over.w k])
+        dsimp; rw [coprod.map_desc, id_comp, Over.w k])
       naturality := fun f g k => by
         ext
         simp }
diff --git a/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean b/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean
index 17d7fe8b12..d0b738730c 100644
--- a/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean
+++ b/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean
@@ -4,6 +4,7 @@ Released under Apache 2.0 license as described in the file LICENSE.
 Authors: Kim Morrison, Markus Himmel
 -/
 import Mathlib.CategoryTheory.EpiMono
+import Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts
 import Mathlib.CategoryTheory.Limits.HasLimits
 
 /-!
@@ -172,7 +173,7 @@ theorem walkingParallelPairOpEquiv_counitIso_one :
   rfl
 
 variable {C : Type u} [Category.{v} C]
-variable {X Y : C}
+variable {X Y Z : C}
 
 /-- `parallelPair f g` is the diagram in `C` consisting of the two morphisms `f` and `g` with
 common domain and codomain. -/
@@ -355,6 +356,23 @@ theorem Cofork.coequalizer_ext (s : Cofork f g) {W : C} {k l : s.pt ‚ü∂ W}
   | zero => by simp only [s.app_zero_eq_comp_œÄ_left, Category.assoc, h]
   | one => h
 
+@[simp]
+theorem Fork.ofŒπ_eq_self (w : Fork f g) : Fork.ofŒπ w.Œπ w.condition = w :=
+  let ext (w w' : Fork f g) (hp : w.pt = w'.pt) (hœÄ : w.œÄ = hp ‚ñ∏ w'.œÄ) : w = w' := by
+    cases w; cases hp; cases hœÄ; rfl
+  have (X : WalkingParallelPair) : (Fork.ofŒπ w.Œπ w.condition).œÄ.app X = w.œÄ.app X := by
+    cases X <;> simp
+  ext _ w (by rfl) (NatTrans.ext (funext this))
+
+@[simp]
+theorem Cofork.ofœÄ_eq_self (w : Cofork f g) : Cofork.ofœÄ w.œÄ w.condition = w :=
+  let ext (w w' : Cofork f g) (hp : w.pt = w'.pt) (hŒπ : w.Œπ = hp ‚ñ∏ w'.Œπ) : w = w' := by
+    cases w; cases hp; cases hŒπ; rfl
+  have (X : WalkingParallelPair) :
+    (Cofork.ofœÄ w.œÄ w.condition).Œπ.app X = w.Œπ.app X := by
+    cases X <;> simp
+  ext _ w (by rfl) (NatTrans.ext (funext this))
+
 theorem Fork.IsLimit.hom_ext {s : Fork f g} (hs : IsLimit s) {W : C} {k l : W ‚ü∂ s.pt}
     (h : k ‚â´ Fork.Œπ s = l ‚â´ Fork.Œπ s) : k = l :=
   hs.hom_ext <| Fork.equalizer_ext _ h
@@ -698,6 +716,22 @@ def Cofork.isColimitOfIsos {X' Y' : C} (c : Cofork f g) (hc : IsColimit c)
     (comm‚ÇÉ : e‚ÇÅ.inv ‚â´ c.œÄ ‚â´ e.hom = c'.œÄ := by cat_disch) : IsColimit c' :=
   (Cofork.isColimitEquivOfIsos c c' e‚ÇÄ e‚ÇÅ e) hc
 
+lemma eq_of_lift_eq_diag (p : BinaryFan Z Z) (hp : IsLimit p)
+      {e : X ‚ü∂ Y} {f g : Y ‚ü∂ Z} {h : X ‚ü∂ Z}
+      (eq : e ‚â´ hp.lift (BinaryFan.mk f g) = h ‚â´ (hp.lift (BinaryFan.mk (ùüô Z) (ùüô Z)))) :
+    e ‚â´ f = e ‚â´ g :=
+  by calc
+    e ‚â´ f = h     := by simpa using congr($eq ‚â´ p.fst)
+    _     = e ‚â´ g := by simpa using congr($eq.symm ‚â´ p.snd)
+
+lemma eq_of_desc_eq_codiag (p : BinaryCofan X X) (hp : IsColimit p)
+      {e : Y ‚ü∂ Z} {f g : X ‚ü∂ Y} {h : X ‚ü∂ Z}
+      (eq : (hp.desc (BinaryCofan.mk f g)) ‚â´ e = (hp.desc (BinaryCofan.mk (ùüô X) (ùüô X))) ‚â´ h) :
+    f ‚â´ e = g ‚â´ e :=
+  by calc
+    f ‚â´ e = h     := by simpa using congr(p.inl ‚â´ $eq)
+    _     = g ‚â´ e := by simpa using congr(p.inr ‚â´ $eq.symm)
+
 variable (f g)
 
 section
@@ -741,6 +775,15 @@ noncomputable def equalizerIsEqualizer : IsLimit (Fork.ofŒπ (equalizer.Œπ f g)
     (equalizer.condition f g)) :=
   IsLimit.ofIsoLimit (limit.isLimit _) (Fork.ext (Iso.refl _) (by simp))
 
+/-- The equalizer built from `equalizer.fork f g` is limiting. -/
+noncomputable def equalizerIsEqualizer' : IsLimit (equalizer.fork f g) :=
+  IsLimit.ofIsoLimit (limit.isLimit _) (Fork.ext (Iso.refl _) (by simp))
+
+@[simp]
+theorem equalizer.fork_ofŒπ :
+    Fork.ofŒπ (equalizer.Œπ f g) (equalizer.condition f g) = equalizer.fork f g :=
+  Fork.ofŒπ_eq_self (equalizer.fork f g)
+
 variable {f g}
 
 /-- A morphism `k : W ‚ü∂ X` satisfying `k ‚â´ f = k ‚â´ g` factors through the equalizer of `f` and `g`
@@ -890,6 +933,15 @@ noncomputable def coequalizerIsCoequalizer :
     IsColimit (Cofork.ofœÄ (coequalizer.œÄ f g) (coequalizer.condition f g)) :=
   IsColimit.ofIsoColimit (colimit.isColimit _) (Cofork.ext (Iso.refl _) (by simp))
 
+/-- The cofork built from `coequalizer.œÄ f g` is colimiting. -/
+noncomputable def coequalizerIsCoequalizer' : IsColimit (coequalizer.cofork f g) :=
+  IsColimit.ofIsoColimit (colimit.isColimit _) (Cofork.ext (Iso.refl _) (by simp))
+
+@[simp]
+theorem coequalizer.cofork_ofœÄ :
+    Cofork.ofœÄ (coequalizer.œÄ f g) (coequalizer.condition f g) = coequalizer.cofork f g :=
+  Cofork.ofœÄ_eq_self (coequalizer.cofork f g)
+
 variable {f g}
 
 /-- Any morphism `k : Y ‚ü∂ W` satisfying `f ‚â´ k = g ‚â´ k` factors through the coequalizer of `f`
@@ -1226,6 +1278,19 @@ noncomputable def splitEpiOfIdempotentCoequalizer {X : C} {f : X ‚ü∂ X} (hf : f
     [HasCoequalizer (ùüô X) f] : SplitEpi (coequalizer.œÄ (ùüô X) f) :=
   splitEpiOfIdempotentOfIsColimitCofork _ hf (colimit.isColimit _)
 
+variable [HasBinaryProducts C]
+
+local notation "p‚ü®" f ", " g "‚ü©" => Limits.prod.lift f g
+
+/-- For `f : X ‚ü∂ Y`, the pairing `p‚ü®ùüô X, f‚ü© : X ‚ü∂ X ‚®Ø Y` is the equalizer
+of the pair `(prod.fst ‚â´ f, prod.snd)`. -/
+noncomputable def graph_as_equalizer {X Y : C} (f : X ‚ü∂ Y) :
+    IsLimit (Fork.ofŒπ p‚ü®ùüô X, f‚ü© ((by simp) : p‚ü®ùüô X, f‚ü© ‚â´ prod.fst ‚â´ f = p‚ü®ùüô X, f‚ü© ‚â´ prod.snd)) :=
+  Fork.IsLimit.mk _
+    (fun s => s.Œπ ‚â´ prod.fst)
+    (fun s => ((by simp[prod.comp_lift, s.condition])))
+    (fun s m eq => by simp[‚Üê eq])
+
 end CategoryTheory.Limits
 
 end
diff --git a/Mathlib/CategoryTheory/Limits/Shapes/Pullback/CommSq.lean b/Mathlib/CategoryTheory/Limits/Shapes/Pullback/CommSq.lean
index f95b2be8ce..b38676e3ca 100644
--- a/Mathlib/CategoryTheory/Limits/Shapes/Pullback/CommSq.lean
+++ b/Mathlib/CategoryTheory/Limits/Shapes/Pullback/CommSq.lean
@@ -373,6 +373,46 @@ lemma of_iso (h : IsPullback fst snd f g)
               rw [‚Üê reassoc_of% commfst, e‚ÇÇ.hom_inv_id, Category.comp_id]
             ¬∑ change snd = e‚ÇÅ.hom ‚â´ snd' ‚â´ e‚ÇÉ.inv
               rw [‚Üê reassoc_of% commsnd, e‚ÇÉ.hom_inv_id, Category.comp_id]))‚ü©
+
+def isoIsPullback_congr
+      {P' X' Y' : C}
+      (iX : X ‚âÖ X') (iY : Y ‚âÖ Y')
+      {fst' : P' ‚ü∂ X'} {snd' : P' ‚ü∂ Y'}
+      {f' : X' ‚ü∂ Z} {g' : Y' ‚ü∂ Z}
+      (hf : iX.inv ‚â´ f = f') (hg : iY.inv ‚â´ g = g')
+      (pb : IsPullback fst snd f g)
+      (pb' : IsPullback fst' snd' f' g') :
+    P ‚âÖ P' :=
+  have h_trans : IsPullback (fst ‚â´ iX.hom) (snd ‚â´ iY.hom) (iX.inv ‚â´ f) (iY.inv ‚â´ g) :=
+    IsPullback.of_iso pb
+      (Iso.refl P) (iX) (iY) (Iso.refl Z)
+      (by simp) (by simp) (by simp) (by simp)
+  IsPullback.isoIsPullback X' Y' h_trans (by simpa [hf, hg] using pb')
+
+@[reassoc (attr := simp)]
+lemma isoIsPullback_congr_hom_fst
+      {X' Y' P' : C}
+      (iX : X ‚âÖ X') (iY : Y ‚âÖ Y')
+      {fst' : P' ‚ü∂ X'} {snd' : P' ‚ü∂ Y'}
+      {f' : X' ‚ü∂ Z} {g' : Y' ‚ü∂ Z}
+      (hf : iX.inv ‚â´ f = f') (hg : iY.inv ‚â´ g = g')
+      (pb : IsPullback fst snd f g)
+      (pb' : IsPullback fst' snd' f' g') :
+    (isoIsPullback_congr iX iY hf hg pb pb').hom ‚â´ fst' = fst ‚â´ iX.hom := by
+  unfold isoIsPullback_congr; simp
+
+@[reassoc (attr := simp)]
+lemma isoIsPullback_congr_hom_snd
+      {X' Y' P' : C}
+      (iX : X ‚âÖ X') (iY : Y ‚âÖ Y')
+      {fst' : P' ‚ü∂ X'} {snd' : P' ‚ü∂ Y'}
+      {f' : X' ‚ü∂ Z} {g' : Y' ‚ü∂ Z}
+      (hf : iX.inv ‚â´ f = f') (hg : iY.inv ‚â´ g = g')
+      (pb : IsPullback fst snd f g)
+      (pb' : IsPullback fst' snd' f' g') :
+    (isoIsPullback_congr iX iY hf hg pb pb').hom ‚â´ snd' = snd ‚â´ iY.hom := by
+  unfold isoIsPullback_congr; simp
+
 section
 
 variable {P X Y : C} {fst : P ‚ü∂ X} {snd : P ‚ü∂ X} {f : X ‚ü∂ Y} [Mono f]
diff --git a/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Equalizer.lean b/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Equalizer.lean
index acd890c5e8..8da00a78f9 100644
--- a/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Equalizer.lean
+++ b/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Equalizer.lean
@@ -4,6 +4,8 @@ Released under Apache 2.0 license as described in the file LICENSE.
 Authors: Andrew Yang
 -/
 import Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq
+import Mathlib.CategoryTheory.Monoidal.Cartesian.Basic
+
 
 /-!
 # Equalizers as pullbacks of products
@@ -14,35 +16,53 @@ Also see `CategoryTheory.Limits.Constructions.Equalizers` for very similar resul
 
 universe v u
 
+open CategoryTheory.Category CategoryTheory.CartesianMonoidalCategory
+
 namespace CategoryTheory.Limits
 
-variable {C : Type u} [Category.{v} C] {X Y : C} (f g : X ‚ü∂ Y)
-
-/-- The equalizer of `f g : X ‚ü∂ Y` is the pullback of the diagonal map `Y ‚ü∂ Y √ó Y`
-along the map `(f, g) : X ‚ü∂ Y √ó Y`. -/
-lemma isPullback_equalizer_prod [HasEqualizer f g] [HasBinaryProduct Y Y] :
-    IsPullback (equalizer.Œπ f g) (equalizer.Œπ f g ‚â´ f) (prod.lift f g) (prod.lift (ùüô _) (ùüô _)) := by
-  refine ‚ü®‚ü®by ext <;> simp [equalizer.condition f g]‚ü©, ‚ü®PullbackCone.IsLimit.mk _ ?_ ?_ ?_ ?_‚ü©‚ü©
-  ¬∑ refine fun s ‚Ü¶ equalizer.lift s.fst ?_
-    have H‚ÇÅ : s.fst ‚â´ f = s.snd := by simpa using congr($s.condition ‚â´ prod.fst)
-    have H‚ÇÇ : s.fst ‚â´ g = s.snd := by simpa using congr($s.condition ‚â´ prod.snd)
-    exact H‚ÇÅ.trans H‚ÇÇ.symm
-  ¬∑ exact fun s ‚Ü¶ by simp
-  ¬∑ exact fun s ‚Ü¶ by simpa using congr($s.condition ‚â´ prod.fst)
-  ¬∑ exact fun s m hm _ ‚Ü¶ by ext; simp [*]
+variable {C : Type u} [Category.{v} C] {X Y Z : C}
+
+/-- If `e` is an equalizer of `f g : X ‚ü∂ Y`, then `e` is also the pullback of the diagonal map
+`Y ‚ü∂ Y ‚®Ø Y` along `‚ü®f, g‚ü© : X ‚ü∂ Y ‚®Ø Y`. Fully explicit version with binary fans and forks -/
+lemma isPullback_equalizer_binaryFan_fork {p : BinaryFan Y Y} (hp : IsLimit p)
+      (f g : X ‚ü∂ Y) (e : Fork f g) (he : IsLimit e) :
+    IsPullback e.Œπ (e.Œπ ‚â´ f)
+      (hp.lift (BinaryFan.mk f g)) (hp.lift (BinaryFan.mk (ùüô Y) (ùüô Y))) := by
+  refine
+    ‚ü® ‚ü® BinaryFan.IsLimit.hom_ext hp (by simp) (by simp[e.condition]) ‚ü©,
+      ‚ü® PullbackCone.IsLimit.mk _ ?_ ?_ ?_ ?_ ‚ü© ‚ü©
+  ¬∑ exact fun s ‚Ü¶ he.lift (Fork.ofŒπ s.fst (eq_of_lift_eq_diag p hp (s.condition)))
+  ¬∑ exact fun s ‚Ü¶ Fork.IsLimit.lift_Œπ he
+  ¬∑ exact fun s ‚Ü¶ by simpa using congr($s.condition ‚â´ p.fst)
+  ¬∑ exact fun _ _ hm _ ‚Ü¶ Fork.IsLimit.hom_ext he (Eq.symm (Fork.IsLimit.lift_Œπ he) ‚ñ∏ hm)
+
+/-- The equalizer of `f g : X ‚ü∂ Y` is the pullback of the diagonal map `Y ‚ü∂ Y ‚®Ø Y`
+  along the map `‚ü®f, g‚ü© : X ‚ü∂ Y ‚®Ø Y`. Version with implicit products and equalizers. -/
+lemma isPullback_equalizer_prod (f g : X ‚ü∂ Y) [HasEqualizer f g] [HasBinaryProduct Y Y] :
+      IsPullback (equalizer.Œπ f g) (equalizer.Œπ f g ‚â´ f) (prod.lift f g) (diag Y) :=
+    isPullback_equalizer_binaryFan_fork _
+      f g (equalizer.fork f g) (equalizerIsEqualizer' f g)
+
+/-- If `e` is an coequalizer of `f g : X ‚ü∂ Y`, then `e` is also the pushout of the codiagonal map
+`X + X ‚ü∂ X` along `‚ü®f, g‚ü© : X + X ‚ü∂ Y`. Fully explicit version with binary cofans and coforks. -/
+lemma isPushout_coequalizer_binaryCofan_coFork {p : BinaryCofan X X} (hp : IsColimit p)
+  (f g : X ‚ü∂ Y) (e : Cofork f g) (h : IsColimit e) :
+    IsPushout (hp.desc (BinaryCofan.mk f g)) (hp.desc (BinaryCofan.mk (ùüô X) (ùüô X)))
+      e.œÄ (f ‚â´ e.œÄ) := by
+  refine
+    ‚ü® ‚ü® BinaryCofan.IsColimit.hom_ext hp (by simp) (by simp[e.condition]) ‚ü©,
+      ‚ü® PushoutCocone.IsColimit.mk _ ?_ ?_ ?_ ?_ ‚ü© ‚ü©
+  ¬∑ exact fun s ‚Ü¶ h.desc (Cofork.ofœÄ s.inl (eq_of_desc_eq_codiag p hp (s.condition)))
+  ¬∑ exact fun s ‚Ü¶ Cofork.IsColimit.œÄ_desc h
+  ¬∑ exact fun s ‚Ü¶ by simpa using congr(p.inl ‚â´ $s.condition)
+  ¬∑ exact fun _ _ hm _ ‚Ü¶ Cofork.IsColimit.hom_ext h (Eq.symm (Cofork.IsColimit.œÄ_desc h) ‚ñ∏ hm)
 
 /-- The coequalizer of `f g : X ‚ü∂ Y` is the pushout of the diagonal map `X ‚®ø X ‚ü∂ X`
-along the map `(f, g) : X ‚®ø X ‚ü∂ Y`. -/
-lemma isPushout_coequalizer_coprod [HasCoequalizer f g] [HasBinaryCoproduct X X] :
-    IsPushout (coprod.desc f g) (coprod.desc (ùüô _) (ùüô _))
-      (coequalizer.œÄ f g) (f ‚â´ coequalizer.œÄ f g) := by
-  refine ‚ü®‚ü®by ext <;> simp [coequalizer.condition f g]‚ü©, ‚ü®PushoutCocone.IsColimit.mk _ ?_ ?_ ?_ ?_‚ü©‚ü©
-  ¬∑ refine fun s ‚Ü¶ coequalizer.desc s.inl ?_
-    have H‚ÇÅ : f ‚â´ s.inl = s.inr := by simpa using congr(coprod.inl ‚â´ $s.condition)
-    have H‚ÇÇ : g ‚â´ s.inl = s.inr := by simpa using congr(coprod.inr ‚â´ $s.condition)
-    exact H‚ÇÅ.trans H‚ÇÇ.symm
-  ¬∑ exact fun s ‚Ü¶ by simp
-  ¬∑ exact fun s ‚Ü¶ by simpa using congr(coprod.inl ‚â´ $s.condition)
-  ¬∑ exact fun s m hm _ ‚Ü¶ by ext; simp [*]
+along the map `(f, g) : X ‚®ø X ‚ü∂ Y`. Version with implicit coproducts and coequalizers -/
+lemma isPushout_coequalizer_coprod (f g : X ‚ü∂ Y) [HasCoequalizer f g] [HasBinaryCoproduct X X] :
+    IsPushout (coprod.desc f g) (codiag X)
+      (coequalizer.œÄ f g) (f ‚â´ coequalizer.œÄ f g) :=
+  isPushout_coequalizer_binaryCofan_coFork _
+    f g (coequalizer.cofork f g) (coequalizerIsCoequalizer' f g)
 
 end CategoryTheory.Limits
diff --git a/Mathlib/CategoryTheory/Monoidal/Cartesian/Basic.lean b/Mathlib/CategoryTheory/Monoidal/Cartesian/Basic.lean
index 8b58ba85b2..8d7a53af72 100644
--- a/Mathlib/CategoryTheory/Monoidal/Cartesian/Basic.lean
+++ b/Mathlib/CategoryTheory/Monoidal/Cartesian/Basic.lean
@@ -223,6 +223,10 @@ Construct a morphism to the product given its two components.
 def lift {T X Y : C} (f : T ‚ü∂ X) (g : T ‚ü∂ Y) : T ‚ü∂ X ‚äó Y :=
   (BinaryFan.IsLimit.lift' (tensorProductIsBinaryProduct X Y) f g).1
 
+@[simp]
+lemma lift_eq {T X Y : C} (f : T ‚ü∂ X) (g : T ‚ü∂ Y) :
+  (tensorProductIsBinaryProduct X Y).lift (BinaryFan.mk f g) = lift f g := rfl
+
 @[reassoc (attr := simp)]
 lemma lift_fst {T X Y : C} (f : T ‚ü∂ X) (g : T ‚ü∂ Y) : lift f g ‚â´ fst _ _ = f :=
   (BinaryFan.IsLimit.lift' (tensorProductIsBinaryProduct X Y) f g).2.1
@@ -276,6 +280,14 @@ lemma whiskerRight_fst {X Y : C} (f : X ‚ü∂ Y) (Z : C) : f ‚ñ∑ Z ‚â´ fst _ _ = f
 lemma whiskerRight_snd {X Y : C} (f : X ‚ü∂ Y) (Z : C) : f ‚ñ∑ Z ‚â´ snd _ _ = snd _ _ := by
   simp [snd_def, ‚Üê comp_whiskerRight_assoc]
 
+@[simp]
+lemma whiskerLeft_eq_lift {X Y Z : C} (f : Y ‚ü∂ Z) :
+    (lift (fst X Y) (snd X Y ‚â´ f)) = X ‚óÅ f := by aesop_cat
+
+@[simp]
+lemma whiskerRight_eq_lift {X Y Z : C} (f : X ‚ü∂ Z) :
+    (lift (fst X Y ‚â´ f) (snd X Y)) = f ‚ñ∑ Y := by aesop_cat
+
 @[reassoc (attr := simp)]
 lemma tensorHom_fst {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) (g : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) :
     (f ‚äó‚Çò g) ‚â´ fst _ _ = fst _ _ ‚â´ f := by simp [tensorHom_def]
diff --git a/Mathlib/CategoryTheory/Subobject/Basic.lean b/Mathlib/CategoryTheory/Subobject/Basic.lean
index bc9abec6e2..f925ff8bf8 100644
--- a/Mathlib/CategoryTheory/Subobject/Basic.lean
+++ b/Mathlib/CategoryTheory/Subobject/Basic.lean
@@ -186,9 +186,13 @@ noncomputable def arrow {X : C} (Y : Subobject X) : (Y : C) ‚ü∂ X :=
 instance arrow_mono {X : C} (Y : Subobject X) : Mono Y.arrow :=
   (representative.obj Y).property
 
+def isoFromEq {A : C} {X Y : Subobject A} (h : X = Y) :=
+  eqToIso (congr_arg (fun X : Subobject A => (X : C)) h)
+
 @[simp]
 theorem arrow_congr {A : C} (X Y : Subobject A) (h : X = Y) :
-    eqToHom (congr_arg (fun X : Subobject A => (X : C)) h) ‚â´ Y.arrow = X.arrow := by
+    (isoFromEq h).hom ‚â´ Y.arrow = X.arrow := by
+  unfold isoFromEq
   induction h
   simp
 
diff --git a/Mathlib/CategoryTheory/Topos/Classifier.lean b/Mathlib/CategoryTheory/Topos/Classifier.lean
index fceb5b45d7..dd7abbc0c6 100644
--- a/Mathlib/CategoryTheory/Topos/Classifier.lean
+++ b/Mathlib/CategoryTheory/Topos/Classifier.lean
@@ -72,9 +72,7 @@ variable (C : Type u) [Category.{v} C]
 ```
 An equivalent formulation replaces `Œ©‚ÇÄ` with the terminal object.
 -/
-structure Classifier where
-  /-- The domain of the truth morphism -/
-  Œ©‚ÇÄ : C
+structure Classifier (Œ©‚ÇÄ : C) where
   /-- The codomain of the truth morphism -/
   Œ© : C
   /-- The truth morphism of the subobject classifier -/
@@ -108,8 +106,7 @@ def mkOfTerminalŒ©‚ÇÄ
     (isPullback : ‚àÄ {U X : C} (m : U ‚ü∂ X) [Mono m],
       IsPullback m (t.from U) (œá m) truth)
     (uniq : ‚àÄ {U X : C} (m : U ‚ü∂ X) [Mono m] (œá' : X ‚ü∂ Œ©)
-      (_ : IsPullback m (t.from U) œá' truth), œá' = œá m) : Classifier C where
-  Œ©‚ÇÄ := Œ©‚ÇÄ
+      (_ : IsPullback m (t.from U) œá' truth), œá' = œá m) : Classifier C Œ©‚ÇÄ where
   Œ© := Œ©
   truth := truth
   mono_truth := t.mono_from _
@@ -118,7 +115,12 @@ def mkOfTerminalŒ©‚ÇÄ
   isPullback m _ := isPullback m
   uniq m _ œá‚ÇÄ' œá' hœá' := uniq m œá' ((t.hom_ext œá‚ÇÄ' (t.from _)) ‚ñ∏ hœá')
 
-instance {c : Classifier C} : ‚àÄ Y : C, Unique (Y ‚ü∂ c.Œ©‚ÇÄ) := fun Y =>
+variable {Œ©‚ÇÄ : C}
+
+/-- Given `c : Classifier C`, `c.Œ©‚ÇÄ` is a terminal object.
+Prefer `c.œá‚ÇÄ` over `c.isTerminalŒ©‚ÇÄ.from`. -/
+def isTerminalŒ©‚ÇÄ {c : Classifier C Œ©‚ÇÄ} : IsTerminal Œ©‚ÇÄ :=
+  have : ‚àÄ Y : C, Unique (Y ‚ü∂ Œ©‚ÇÄ) := fun Y ‚Ü¶
   { default := c.œá‚ÇÄ Y,
     uniq f :=
       have : f ‚â´ c.truth = c.œá‚ÇÄ Y ‚â´ c.truth :=
@@ -126,40 +128,36 @@ instance {c : Classifier C} : ‚àÄ Y : C, Unique (Y ‚ü∂ c.Œ©‚ÇÄ) := fun Y =>
           _ = c.œá (ùüô Y) := c.uniq (ùüô Y) (of_horiz_isIso_mono { })
           _ = c.œá‚ÇÄ Y ‚â´ c.truth := by simp [‚Üê (c.isPullback (ùüô Y)).w]
       Mono.right_cancellation _ _ this }
-
-/-- Given `c : Classifier C`, `c.Œ©‚ÇÄ` is a terminal object.
-Prefer `c.œá‚ÇÄ` over `c.isTerminalŒ©‚ÇÄ.from`. -/
-def isTerminalŒ©‚ÇÄ {c : Classifier C} : IsTerminal c.Œ©‚ÇÄ := IsTerminal.ofUnique c.Œ©‚ÇÄ
+  IsTerminal.ofUnique Œ©‚ÇÄ
 
 @[simp]
-lemma isTerminalFrom_eq_œá‚ÇÄ (c : Classifier C) : c.isTerminalŒ©‚ÇÄ.from = c.œá‚ÇÄ := rfl
+lemma isTerminalFrom_eq_œá‚ÇÄ (c : Classifier C Œ©‚ÇÄ) : c.isTerminalŒ©‚ÇÄ.from = c.œá‚ÇÄ := rfl
 
 end Classifier
 
 /-- A category `C` has a subobject classifier if there is at least one subobject classifier. -/
 class HasClassifier (C : Type u) [Category.{v} C] : Prop where
   /-- There is some classifier. -/
-  exists_classifier : Nonempty (Classifier C)
+  exists_classifier : Nonempty (Œ£ Œ©‚ÇÄ, Classifier C Œ©‚ÇÄ)
 
 namespace HasClassifier
 
 variable (C) [HasClassifier C]
 
 noncomputable section
-
 /-- Notation for the `Œ©‚ÇÄ` in an arbitrary choice of a subobject classifier -/
-abbrev Œ©‚ÇÄ : C := HasClassifier.exists_classifier.some.Œ©‚ÇÄ
+abbrev Œ©‚ÇÄ : C := HasClassifier.exists_classifier.some.1
+private abbrev cŒ©‚ÇÄ : Classifier C (Œ©‚ÇÄ C) := HasClassifier.exists_classifier.some.2
 /-- Notation for the `Œ©` in an arbitrary choice of a subobject classifier -/
-abbrev Œ© : C := HasClassifier.exists_classifier.some.Œ©
+abbrev Œ© : C := (cŒ©‚ÇÄ C).Œ©
 
 /-- Notation for the "truth arrow" in an arbitrary choice of a subobject classifier -/
-abbrev truth : Œ©‚ÇÄ C ‚ü∂ Œ© C := HasClassifier.exists_classifier.some.truth
+abbrev truth : Œ©‚ÇÄ C ‚ü∂ Œ© C := (cŒ©‚ÇÄ C).truth
 
 variable {C} {U X : C} (m : U ‚ü∂ X) [Mono m]
 
 /-- returns the characteristic morphism of the subobject `(m : U ‚ü∂ X) [Mono m]` -/
-def œá : X ‚ü∂ Œ© C :=
-  HasClassifier.exists_classifier.some.œá m
+def œá : X ‚ü∂ Œ© C := (cŒ©‚ÇÄ C).œá m
 
 /-- The diagram
 ```
@@ -172,7 +170,7 @@ def œá : X ‚ü∂ Œ© C :=
 ```
 is a pullback square.
 -/
-lemma isPullback_œá : IsPullback m (Classifier.œá‚ÇÄ _ U) (œá m) (truth C) :=
+lemma isPullback_œá : IsPullback m (Classifier.œá‚ÇÄ (cŒ©‚ÇÄ C) U) (œá m) (truth C) :=
   Classifier.isPullback _ m
 
 /-- The diagram
@@ -187,16 +185,16 @@ lemma isPullback_œá : IsPullback m (Classifier.œá‚ÇÄ _ U) (œá m) (truth C) :=
 commutes.
 -/
 @[reassoc]
-lemma comm : m ‚â´ œá m = Classifier.œá‚ÇÄ _ U ‚â´ truth C := (isPullback_œá m).w
+lemma comm : m ‚â´ œá m = (cŒ©‚ÇÄ C).œá‚ÇÄ U ‚â´ truth C := (isPullback_œá m).w
 
 /-- `œá m` is the only map for which the associated square
 is a pullback square.
 -/
-lemma unique (œá' : X ‚ü∂ Œ© C) (hœá' : IsPullback m (Classifier.œá‚ÇÄ _ U) œá' (truth C)) : œá' = œá m :=
-  Classifier.uniq _ m hœá'
+lemma unique (œá' : X ‚ü∂ Œ© C) (hœá' : IsPullback m ((cŒ©‚ÇÄ C).œá‚ÇÄ U) œá' (truth C)) :
+  œá' = œá m := (cŒ©‚ÇÄ C).uniq m hœá'
 
 instance truthIsSplitMono : IsSplitMono (truth C) :=
-  Classifier.isTerminalŒ©‚ÇÄ.isSplitMono_from _
+  (cŒ©‚ÇÄ C).isTerminalŒ©‚ÇÄ.isSplitMono_from _
 
 /-- `truth C` is a regular monomorphism (because it is split). -/
 noncomputable instance truthIsRegularMono : RegularMono (truth C) :=
@@ -251,7 +249,7 @@ open Subobject
 
 section RepresentableBy
 
-variable {C : Type u} [Category.{v} C] [HasPullbacks C] (ùíû : Classifier C)
+variable {C : Type u} [Category.{v} C] [HasPullbacks C] {Œ©‚ÇÄ : C} (ùíû : Classifier C Œ©‚ÇÄ)
 
 /-- The subobject of `ùíû.Œ©` corresponding to the `truth` morphism. -/
 abbrev truth_as_subobject : Subobject ùíû.Œ© :=
@@ -404,8 +402,7 @@ noncomputable def isoŒ©‚ÇÄ : (h.Œ©‚ÇÄ : C) ‚âÖ ‚ä§_ C :=
 
 /-- Any representation `Œ©` of `Subobject.presheaf C` gives a subobject classifier with truth values
 object `Œ©`. -/
-noncomputable def classifier : Classifier C where
-  Œ©‚ÇÄ := ‚ä§_ C
+noncomputable def classifier : Classifier C (‚ä§_ C) where
   Œ© := Œ©
   truth := h.isoŒ©‚ÇÄ.inv ‚â´ h.Œ©‚ÇÄ.arrow
   mono_truth := terminalIsTerminal.mono_from _
@@ -430,12 +427,12 @@ variable [HasTerminal C]
 theorem isRepresentable_hasClassifier_iff [HasPullbacks C] :
     HasClassifier C ‚Üî (Subobject.presheaf C).IsRepresentable := by
   constructor <;> intro h
-  ¬∑ obtain ‚ü®‚ü®ùíû‚ü©‚ü© := h
+  ¬∑ obtain ‚ü®‚ü®Œ©‚ÇÄ, ùíû‚ü©‚ü© := h
     apply RepresentableBy.isRepresentable
     exact ùíû.representableBy
   ¬∑ obtain ‚ü®Œ©, ‚ü®h‚ü©‚ü© := h
     constructor; constructor
-    exact Classifier.SubobjectRepresentableBy.classifier h
+    exact ‚ü®‚ä§_ C, Classifier.SubobjectRepresentableBy.classifier h‚ü©
 
 end Representability
 end CategoryTheory
