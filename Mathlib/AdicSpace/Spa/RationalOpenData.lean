import Mathlib.AdicSpace.Spv
import Mathlib.Order.CompletePartialOrder
import Mathlib.GroupTheory.MonoidLocalization.Away
import Mathlib.RingTheory.OreLocalization.Ring

universe u

open Topology TopologicalSpace

section

namespace Submodule

open scoped Pointwise

section SmulInt

variable {R : Type*} [CommRing R] (s : Set R) (I : Ideal R)

lemma smul_eq_smul_span_int :
  ((s • I : Ideal R) : Set R) = (((s • (span ℤ (I : Set R)) : Submodule ℤ R)) : Set R) := by
  conv_lhs => rw [← span_eq I]
  rw [set_smul_span, set_smul_span, smul_eq_mul]
  ext x
  simp only [SetLike.mem_coe]
  constructor
  · intro hx
    induction hx using span_induction with
    | mem x h => apply mem_span_of_mem; assumption
    | zero => simp
    | add x y hx hy _ _ => apply Submodule.add_mem; all_goals assumption
    | smul a x hx hsi =>
        induction hsi using span_induction with
        | mem x h =>
          rw [Set.mem_mul] at h
          obtain ⟨x, hx, i, hi, rfl⟩ := h
          rw [← mul_smul_comm]
          apply mem_span_of_mem
          apply Set.mul_mem_mul (by assumption)
          simp only [smul_eq_mul, SetLike.mem_coe]
          apply Ideal.mul_mem_left
          simpa
        | zero => simp
        | add x y hx hy h₁ h₂ =>
          rw [smul_add]
          apply add_mem
          · apply h₁
            apply span_subset_span ℤ R
            simpa
          · apply h₂
            apply span_subset_span ℤ R
            simpa
        | smul a x hx hax =>
          rw [smul_eq_mul, mul_smul_comm]
          apply smul_mem
          apply hax
          apply span_subset_span ℤ R
          simpa
  · intro hx
    induction hx using span_induction with
    | mem x h => apply mem_span_of_mem; assumption
    | zero => simp
    | add x y hx hy _ _ => apply Submodule.add_mem; all_goals assumption
    | smul a x hx _ =>
      simp only [Ideal.submodule_span_eq, zsmul_eq_mul]
      apply Ideal.mul_mem_left
      simpa

end SmulInt

variable {R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] (a : R) (p : Submodule R M)

lemma smul_toAddSubgroup : a • p.toAddSubgroup =
    (a • p).toAddSubgroup := by
  ext
  simp

end Submodule

namespace spa

structure rationalOpenData (A : HuberPair) where
  s : A
  T : Finset A
  isOpen : IsOpen ((Ideal.span (T : Set A)) : Set A)

def rationalOpenData.openSet {A : HuberPair} (r : rationalOpenData A) : Set (spa A) :=
  {v | (∀ t ∈ r.T, (v t ≤ v r.s)) ∧ (v r.s ≠ 0)}

instance (A : HuberPair) : Preorder (rationalOpenData A) where
  le r s := r.openSet ⊆ s.openSet
  le_refl _ := by tauto_set
  le_trans := by tauto_set
  lt_iff_le_not_ge := by tauto_set

def rationalBasis (A : HuberPair) : Set (Set (spa A)) :=
  {U | ∃ r : rationalOpenData A, U = r.openSet}

instance (A : HuberPair) : TopologicalSpace (spa A) :=
  TopologicalSpace.generateFrom (spa.rationalBasis A)

lemma rationalOpenData.openSet_isOpen {A : HuberPair} (r : rationalOpenData A) :
    IsOpen r.openSet := by
  apply isOpen_generateFrom_of_mem
  simp [rationalBasis]

end spa

end

def HuberRing.Away {R : Type u} [CommRing R] [TopologicalSpace R] [IsTopologicalRing R]
    (_T : Set R) (s : R) : Type u := Localization.Away s

namespace HuberRing.Away

variable {R : Type u} [CommRing R] [TopologicalSpace R] [IsTopologicalRing R]

instance (T : Set R) (s : R) : CommRing (HuberRing.Away T s) := by
  dsimp [HuberRing.Away]
  infer_instance

instance (T : Set R) (s : R) : Module R (HuberRing.Away T s) := by
  dsimp [HuberRing.Away]
  infer_instance

instance (T : Set R) (s : R) : Algebra R (HuberRing.Away T s) := by
  dsimp [HuberRing.Away]
  infer_instance

variable (T : Set R) (s : R)

end HuberRing.Away

namespace spa

variable {A : HuberPair.{u}} (r : rationalOpenData A)

def rationalOpenData.Localization := HuberRing.Away r.T r.s

def rationalOpenData.invSelf : r.Localization := Localization.Away.invSelf r.s

instance : CommRing r.Localization := by
  dsimp [rationalOpenData.Localization]
  infer_instance

instance : Algebra A r.Localization := by
  dsimp [rationalOpenData.Localization]
  infer_instance

def ringSubgroupsBasisFamily : OpenAddSubgroup A → AddSubgroup r.Localization :=
  fun U ↦ (Submodule.span (Subring.closure
    ((fun x ↦ r.invSelf * x) '' (algebraMap A r.Localization '' (r.T : Set A))))
    (algebraMap A r.Localization '' U)).toAddSubgroup

open scoped Pointwise

open Submodule

open scoped Classical in
/-- A technical auxiliary lemma: for every finite set L contained in the ideal generated by T,
there exists a finite set K such that L is contained in the subgroup generated by the set T * K.
(Recall that T * K is the set of products of elements in T and in K). -/
lemma K.aux (L : Finset A) (h : (L : Set A) ⊆ Ideal.span (r.T : Set A)) :
    ∃ (K : Finset A), (L : Set A) ⊆ (Submodule.span ℤ ((r.T : Set A) * (K : Set A))) := by
  delta Ideal.span at h

  rw [← Set.image_id (r.T : Set A), Finsupp.span_image_eq_map_linearCombination] at h
  dsimp [Submodule.map] at h
  rw [Finset.subset_set_image_iff] at h
  obtain ⟨s, hs, rfl⟩ := h
  use s.biUnion (fun f ↦ f.frange)
  intro l hl
  obtain ⟨f, hf, rfl⟩ := Finset.mem_image.mp hl
  rw [Finsupp.linearCombination_apply_of_mem_supported _ (s := f.support)]
  · apply sum_mem
    intro t ht
    simp only [Finset.coe_biUnion, Finset.mem_coe, id_eq, smul_eq_mul]
    rw [mul_comm]
    apply mem_span_of_mem
    rw [Set.mem_mul]
    refine ⟨f t, ?_, t, ?_, rfl⟩
    · rw [Set.mem_iUnion]
      use f
      rw [Set.mem_iUnion]
      use hf
      simp only [Finset.mem_coe]
      rw [Finsupp.mem_frange]
      exact ⟨by simpa using ht, t, rfl⟩
    · replace hf := hs hf
      simp only [SetLike.mem_coe] at hf
      rw [Finsupp.mem_supported] at hf
      apply hf
      exact ht
  · rw [Finsupp.mem_supported]

/-- The coercion from A to A⟮T/s⟯. -/
instance : Coe A r.Localization := ⟨fun a ↦ (algebraMap A r.Localization : A → r.Localization) a⟩

/-- For every open subgroup `U` of `A` and every `a : A`,
there exists an open subgroup `V` of `A`,
such that `a • (span D V)` is contained in the `D`-span of `U`. -/
lemma left_mul_subset (U : OpenAddSubgroup A) (a : A) :
    ∃ V : OpenAddSubgroup A, (algebraMap A r.Localization a) • (ringSubgroupsBasisFamily r V) ≤
      (ringSubgroupsBasisFamily r U) := by
  let φ : A →+ A := {
    toFun x := a * x
    map_zero' := by grind
    map_add' := by grind
  }
  have : Continuous φ := by simp [φ]; fun_prop
  let W : OpenAddSubgroup A := U.comap φ this
  have : (W : Set A) ∈ nhds (0 : A) := by
    simpa [W, φ] using this.continuousAt.preimage_mem_nhds (by simpa using U.mem_nhds_zero)
  obtain ⟨V, hV⟩ := NonarchimedeanRing.is_nonarchimedean (R := A) W this
  use V
  dsimp [ringSubgroupsBasisFamily]
  intro x hx
  rw [AddSubgroup.mem_smul_pointwise_iff_exists] at hx
  obtain ⟨y, hy, rfl⟩ := hx
  simp only [mem_toAddSubgroup, smul_eq_mul] at hy ⊢
  replace hV : algebraMap A r.Localization '' V ≤ algebraMap A r.Localization '' W := by
    apply Set.image_mono
    assumption
  let R :=
    (Subring.closure ((fun x ↦ r.invSelf * x) '' (algebraMap A r.Localization '' (r.T : Set A))))
  replace hV : span R (algebraMap A r.Localization '' V) ≤
      span R (algebraMap A r.Localization '' W) := by
    apply span_mono
    assumption
  let φ' : r.Localization →ₗ[R] r.Localization := {
    toFun x := a * x
    map_add' := by grind
    map_smul' := by simp }
  have : span R (algebraMap A r.Localization '' W) ≤
      (span R (algebraMap A r.Localization '' U)).comap φ' := by
    intro x hx
    simp only [OpenAddSubgroup.coe_comap, AddMonoidHom.coe_mk, ZeroHom.coe_mk, mem_comap,
      LinearMap.coe_mk, AddHom.coe_mk, W, φ, φ'] at hx ⊢
    induction hx using span_induction with
    | mem x h =>
      apply mem_span_of_mem
      simp only [Set.mem_image, Set.mem_preimage, SetLike.mem_coe] at h ⊢
      obtain ⟨y, hy, rfl⟩ := h
      refine ⟨a * y, hy, ?_⟩
      simp
    | zero => simp
    | add x y hx hy _ _ =>
      rw [mul_add]
      apply add_mem
      all_goals assumption
    | smul a x hx _ =>
      simp only [Algebra.mul_smul_comm]
      apply smul_mem
      assumption
  simpa using hV.trans this hy

open scoped Classical in
/-- If T ⊆ A generates an open ideal, and U is an open subgroup of A,
then T • U generates an open subgroup.
(This lemma is the main part of case n = 1 of [Wedhorn, Lem 6.20].) -/
lemma mul_T_open (U : OpenAddSubgroup A) :
    IsOpen (((r.T : Set A) • Submodule.span ℤ (U : Set A) : Submodule ℤ A) : Set A) := by
  -- Choose an ideal of definition I ⊆ span T
  have h₁ := Ideal.zero_mem (Ideal.span (r.T : Set A))
  obtain ⟨A₀, _, _, _, ⟨_, emb, I, fg, top⟩, hI⟩ :=
    HuberRing.exists_pod_subset A.carrier _
      (r.isOpen.mem_nhds <| Ideal.zero_mem <| Ideal.span (r.T : Set A))
  dsimp only at hI
  -- Choose a generating set L ⊆ I
  obtain ⟨L, hL⟩ := fg
  rw [← hL] at hI
  -- Observe L ⊆ span T
  have Lsub : (L.image (algebraMap A₀ A) : Set A) ⊆ Ideal.span (r.T : Set A) := by
    rw [Finset.coe_image]
    refine subset_trans ?_ hI
    apply Set.image_mono
    exact Ideal.subset_span
  obtain ⟨K, hK⟩ := K.aux _ _ Lsub
  -- Choose V such that K * V ⊆ U
  -- let nonarch := HuberRing.nonarchimedean,
  let V := K.inf (fun k : A ↦ (NonarchimedeanRing.left_mul_subset U k).choose)
  obtain ⟨H₁, H₂⟩ := isAdic_iff.mp top
  have hV : K * (V : Set A) ⊆ U := by
    rintro _ ⟨k, hk, v, hv, rfl⟩
    apply (NonarchimedeanRing.left_mul_subset U k).choose_spec
    refine ⟨v, ?_, rfl⟩
    apply (Finset.inf_le hk : V ≤ _)
    exact hv
  replace hV : span ℤ _ ≤ span ℤ _ := span_mono hV
  rw [← span_mul_span] at hV
  obtain ⟨m, hm⟩ := H₂ _ ((emb.continuous.isOpen_preimage _ V.isOpen).mem_nhds (by simp))
  rw [← Set.image_subset_iff] at hm
  let O : OpenAddSubgroup A := {
    toAddSubgroup := (I ^ (m + 1) : Ideal A₀).toAddSubgroup.map (algebraMap A₀ A)
    isOpen' := by
      exact emb.isOpenMap _ (H₁ (m + 1)) }
  let O' : AddSubgroup A := ((r.T : Set A) • span ℤ U).toAddSubgroup
  change IsOpen (O' : Set A)
  apply AddSubgroup.isOpen_of_openAddSubgroup (U := O)
  -- What remains is the following calculation: I^(m+1) ⊆ T • span U.
  -- Unfortunately it seems to be hard to express in calc mode
  -- First observe: I^(m+1) = L • I^m as A₀-ideal, but also as ℤ-submodule
  simp only [O', O]
  have : toAddSubgroup (I ^ (m + 1)) =
      ((L : Set A₀) • AddSubgroup.toIntSubmodule (toAddSubgroup (I ^ m))).toAddSubgroup := by
    suffices (toAddSubgroup (I ^ (m + 1)) : Set A₀) =
        (((L : Set A₀) • AddSubgroup.toIntSubmodule
          (toAddSubgroup (I ^ m))).toAddSubgroup : Set A₀) by
      ext x
      rw [Set.ext_iff] at this
      exact this x
    rw [pow_succ, mul_comm, ← smul_eq_mul]
    simp only [smul_eq_mul, toIntSubmodule_toAddSubgroup]
    rw [← span_coe_eq_restrictScalars]
    dsimp only [coe_toAddSubgroup]
    rw [← smul_eq_smul_span_int]
    simp only [SetLike.coe_set_eq]
    have : I ^ m = span A₀ (I ^ m) := by simp
    nth_rw 2 [this]
    rw [Submodule.set_smul_span, smul_eq_mul, ← span_mul_span]
    change _ = Ideal.span (L : Set A₀) * _
    rw [hL]
    simp
  rw [this]
  trans ((r.T : Set A) • ((span ℤ (K : Set A)) * span ℤ (V : Set A))).toAddSubgroup
  · rw [span_mul_span, Submodule.set_smul_span]
    simp only [smul_eq_mul]
    rw [← mul_assoc, ← span_mul_span]
    trans (span ℤ ((r.T : Set A) * (K : Set A)) *
      span ℤ ((algebraMap A₀ A) '' (I ^ m : Ideal A₀))).toAddSubgroup
    · rw [mul_comm, span_mul_span, ← smul_eq_mul, ← Submodule.set_smul_span]
      trans ((algebraMap A₀ A '' (I ^ m : Ideal A₀) : Set A) •
        span ℤ ((L.image (algebraMap A₀ A) : Set A))).toAddSubgroup
      · rw [Submodule.set_smul_span, smul_eq_mul, ← span_mul_span, mul_comm]
        simp
        let φ : A₀ →ₐ[ℤ] A := {
          toFun := algebraMap A₀ A
          map_one' := by simp
          map_mul' := by simp
          map_zero' := by simp
          map_add' := by simp
          commutes' := by simp }
        change _ ≤ (span ℤ (φ.toLinearMap '' (L : Set A₀)) *
          span ℤ (φ.toLinearMap '' _)).toAddSubgroup
        rw [span_image, span_image, ← Submodule.map_mul, span_mul_span,
          ← smul_eq_mul, ← Submodule.set_smul_span]
        simp [φ]
        rfl
      · gcongr 2
        exact span_le.mpr hK
    · gcongr
  · gcongr

lemma addsubgroup_smul_le_smul {V W : AddSubgroup r.Localization} (h : V ≤ W) (a : r.Localization) :
    a • V ≤ a • W := by
  intro x hx
  rw [AddSubgroup.mem_smul_pointwise_iff_exists] at hx
  obtain ⟨y, hy, rfl⟩ := hx
  rw [AddSubgroup.mem_smul_pointwise_iff_exists]
  refine ⟨y, ?_, rfl⟩
  apply h
  simpa

lemma submodule_le_submodule {R M : Type*} [Ring R] [AddCommGroup M] [Module R M]
    {p₁ p₂ : Submodule R M} : p₁.toAddSubgroup ≤ p₂.toAddSubgroup ↔ p₁ ≤ p₂ := by
  rfl

/-
Our next goal is the lemma mul_left,
which says that for every element a of A⟮T/s⟯ and
every open subgroup U of A, there exists an open subgroup V of A, such that a • Dspan V ≤ Dspan U.

We prove this statement using two helper lemmas.
The first proves the case where a = s⁻¹. The second considers arbitrary powers of s⁻¹.
-/

/-- Helper lemma. A special case of mul_left, where the element a is s⁻¹. -/
lemma mul_left.aux₁ (U : OpenAddSubgroup A) : ∃ (V : OpenAddSubgroup A),
      r.invSelf • (ringSubgroupsBasisFamily r V) ≤ ringSubgroupsBasisFamily r U := by
  refine ⟨⟨((r.T : Set A) • Submodule.span ℤ (U : Set A) : Submodule ℤ A).toAddSubgroup,
    mul_T_open r U⟩, ?_⟩
  simp only [ringSubgroupsBasisFamily]
  have : ((r.T : Set A) • (Submodule.span ℤ (U : Set A) : Submodule ℤ A) : Submodule ℤ A) =
      Submodule.span ℤ (r.T : Set A) * (Submodule.span ℤ (U : Set A) : Submodule ℤ A) := by
    rw [Submodule.set_smul_span, Submodule.span_mul_span]
    congr
  let R :=
    (Subring.closure ((fun x ↦ r.invSelf * x) '' (algebraMap A r.Localization '' (r.T : Set A))))
  change r.invSelf • (Submodule.span R
    (algebraMap A r.Localization '' (((r.T : Set A) • (Submodule.span ℤ (U : Set A) :
      Submodule ℤ A) : Submodule ℤ A)))).toAddSubgroup ≤ _
  rw [this, Submodule.span_mul_span]
  let φ : A →ₗ[ℤ] r.Localization := {
    toFun := algebraMap A r.Localization
    map_add' := by simp
    map_smul' := by simp }
  have : (algebraMap A r.Localization '' (Submodule.span ℤ ((r.T : Set A) * (U : Set A)))) =
      (Submodule.map φ (Submodule.span ℤ ((r.T : Set A) * (U : Set A)))) := by
    rfl
  rw [this, Submodule.map_span, Submodule.span_span_of_tower]
  have : r.invSelf • (Submodule.span R (φ '' ((r.T : Set A) * (U : Set A)))).toAddSubgroup =
      (r.invSelf • (Submodule.span R (φ '' ((r.T : Set A) * (U : Set A))))).toAddSubgroup := rfl
  rw [this, submodule_le_submodule, Submodule.smul_def, Submodule.span_le]
  intro x hx
  rw [Set.mem_smul_set] at hx
  obtain ⟨x, hx, rfl⟩ := hx
  simp only [SetLike.mem_coe] at hx ⊢
  induction' hx using Submodule.span_induction with y mem y z hy hz hy' hz' r' y hy hy'
  · obtain ⟨y, hy, rfl⟩ := mem
    rw [Set.mem_mul] at hy
    obtain ⟨t, ht, u, hu, rfl⟩ := hy
    simp only [LinearMap.coe_mk, AddHom.coe_mk, map_mul, smul_eq_mul, φ]
    rw [← mul_assoc, ← smul_eq_mul]
    convert Submodule.smul_mem (R := R) _ ⟨r.invSelf * algebraMap A r.Localization t, ?_⟩ _ using 1
    · apply Subring.mem_closure_of_mem
      use t
      simp only [Set.mem_image, Finset.mem_coe, and_true]
      use t
      simpa
    · apply Submodule.mem_span_of_mem
      use u
  · simp
  · rw [smul_add]
    apply Submodule.add_mem
    all_goals assumption
  · simp only [smul_eq_mul, Algebra.mul_smul_comm]
    apply Submodule.smul_mem
    simpa

def rationalOpenData.invPower (s' : Submonoid.powers r.s) : r.Localization :=
  Localization.mk 1 s'

lemma rationalOpenData.invPower_succ (k : ℕ) :
    r.invPower ⟨r.s ^ (k + 1), k + 1, rfl⟩ = r.invPower ⟨r.s ^ k, k, rfl⟩ * r.invSelf := by
  simp only [invPower, invSelf, Localization.Away.invSelf]
  rw [Localization.mk_mul]
  congr
  all_goals grind

/-- Helper lemma. A special case of mul_left, where the element a is the inverse of a power of s. -/
lemma mul_left.aux₂ (s' : Submonoid.powers r.s) (U : OpenAddSubgroup A) :
    ∃ (V : OpenAddSubgroup A),
      r.invPower s' • (ringSubgroupsBasisFamily r V) ≤ ringSubgroupsBasisFamily r U := by
  obtain ⟨_, ⟨n, rfl⟩⟩ := s'
  induction' n with k hk
  · use U
    simp [rationalOpenData.invPower]
  · obtain ⟨W, hW⟩ := hk
    obtain ⟨V, hV⟩ := mul_left.aux₁ r W
    refine ⟨V, le_trans ?_ hW⟩
    dsimp
    rw [r.invPower_succ, mul_smul]
    exact addsubgroup_smul_le_smul r hV _

/-- For every element a of A⟮T/s⟯ and every open subgroup U of A,
there exists an open subgroup V of A, such that a • Dspan V ≤ Dspan U. -/
lemma mul_left (a : r.Localization)
    (U : OpenAddSubgroup A) : ∃ (V : OpenAddSubgroup A), a • (ringSubgroupsBasisFamily r V) ≤
      ringSubgroupsBasisFamily r U := by
  induction' a using Localization.induction_on with a
  obtain ⟨a', s'⟩ := a
  obtain ⟨W, hW⟩ := mul_left.aux₂ r s' U
  obtain ⟨V, hV⟩ := left_mul_subset r W a'
  use V
  refine le_trans ?_ hW
  simp only [rationalOpenData.invPower]
  rw [← one_mul a']
  nth_rw 1 [← mul_one s']
  rw [← Localization.mk_mul, mul_smul]
  exact addsubgroup_smul_le_smul r hV _

def ringSubgroupsBasis : RingSubgroupsBasis (ringSubgroupsBasisFamily r) :=
  RingSubgroupsBasis.of_comm (ringSubgroupsBasisFamily r)
    (fun U V ↦ ⟨U ⊓ V, by
      simp only [ringSubgroupsBasisFamily]
      intro x hx
      constructor
      · apply Submodule.span_mono _ hx
        apply Set.image_mono
        simp
      · apply Submodule.span_mono _ hx
        apply Set.image_mono
        simp⟩)
    (fun U ↦ by
      obtain ⟨V, hV⟩ := NonarchimedeanRing.mul_subset U
      use V
      dsimp only [ringSubgroupsBasisFamily]
      let R := (Subring.closure
        ((fun x ↦ r.invSelf * x) '' (algebraMap A r.Localization '' (r.T : Set A))))
      let S := ((algebraMap A r.Localization : _ → _) '' (V : Set A))
      let T := ((algebraMap A r.Localization : _ → _) '' (U : Set A))
      have : Submodule.span R S * Submodule.span R S ≤ Submodule.span R T := by
        rw [Submodule.span_mul_span]
        apply Submodule.span_mono
        convert Set.image_mono hV
        simp [S, Set.image_mul]
      refine subset_trans ?_ this
      simp [S, R, Submodule.mul_eq_span_mul_set])
    fun x U ↦ by
      obtain ⟨V, hV⟩ := mul_left r x U
      refine ⟨V, fun y _ ↦ ?_⟩
      apply hV
      rw [AddSubgroup.mem_smul_pointwise_iff_exists]
      exact ⟨y, by simpa⟩

instance : TopologicalSpace r.Localization :=
  (spa.ringSubgroupsBasis r).topology

instance : IsTopologicalRing r.Localization := inferInstance

instance : UniformSpace r.Localization :=
  IsTopologicalAddGroup.toUniformSpace r.Localization

instance : IsUniformAddGroup r.Localization :=
  isUniformAddGroup_of_addCommGroup

instance : UniformContinuousConstSMul A r.Localization where
  uniformContinuous_const_smul c := by
    let f : r.Localization →+ r.Localization := {
      toFun x := c • x
      map_zero' := by simp
      map_add' := by simp }
    change UniformContinuous f
    apply uniformContinuous_addMonoidHom_of_continuous
    simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, f, Algebra.smul_def]
    continuity

noncomputable
instance : CommRing (UniformSpace.Completion r.Localization) :=
  UniformSpace.Completion.commRing _

noncomputable
instance : Algebra A (UniformSpace.Completion r.Localization) :=
  UniformSpace.Completion.algebra _ _

instance : IsTopologicalRing (UniformSpace.Completion r.Localization) :=
  inferInstance

end spa
