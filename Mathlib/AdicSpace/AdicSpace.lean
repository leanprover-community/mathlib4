import Mathlib
import Mathlib.AdicSpace.Spa

universe u

open Topology CategoryTheory TopologicalSpace

section TopologicalSpace

namespace Submodule

open scoped Pointwise

section SmulInt

variable {R : Type*} [CommRing R] (s : Set R) (I : Ideal R)

lemma smul_eq_smul_span_int :
  ((s ‚Ä¢ I : Ideal R) : Set R) = (((s ‚Ä¢ (span ‚Ñ§ (I : Set R)) : Submodule ‚Ñ§ R)) : Set R) := by
  conv_lhs => rw [‚Üê span_eq I]
  rw [set_smul_span, set_smul_span, smul_eq_mul]
  ext x
  simp only [SetLike.mem_coe]
  constructor
  ¬∑ intro hx
    induction hx using span_induction with
    | mem x h => apply mem_span_of_mem; assumption
    | zero => simp
    | add x y hx hy _ _ => apply Submodule.add_mem; all_goals assumption
    | smul a x hx hsi =>
        induction hsi using span_induction with
        | mem x h =>
          rw [Set.mem_mul] at h
          obtain ‚ü®x, hx, i, hi, rfl‚ü© := h
          rw [‚Üê mul_smul_comm]
          apply mem_span_of_mem
          apply Set.mul_mem_mul (by assumption)
          simp only [smul_eq_mul, SetLike.mem_coe]
          apply Ideal.mul_mem_left
          simpa
        | zero => simp
        | add x y hx hy h‚ÇÅ h‚ÇÇ =>
          rw [smul_add]
          apply add_mem
          ¬∑ apply h‚ÇÅ
            apply span_subset_span ‚Ñ§ R
            simpa
          ¬∑ apply h‚ÇÇ
            apply span_subset_span ‚Ñ§ R
            simpa
        | smul a x hx hax =>
          rw [smul_eq_mul, mul_smul_comm]
          apply smul_mem
          apply hax
          apply span_subset_span ‚Ñ§ R
          simpa
  ¬∑ intro hx
    induction hx using span_induction with
    | mem x h => apply mem_span_of_mem; assumption
    | zero => simp
    | add x y hx hy _ _ => apply Submodule.add_mem; all_goals assumption
    | smul a x hx _ =>
      simp only [Ideal.submodule_span_eq, zsmul_eq_mul]
      apply Ideal.mul_mem_left
      simpa

end SmulInt

variable {R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] (a : R) (p : Submodule R M)

lemma smul_toAddSubgroup : a ‚Ä¢ p.toAddSubgroup =
    (a ‚Ä¢ p).toAddSubgroup := by
  ext
  simp

end Submodule

namespace spa

structure rationalOpenData (A : HuberPair) where
  s : A
  T : Finset A
  isOpen : IsOpen ((Ideal.span (T : Set A)) : Set A)

def rationalOpenData.openSet {A : HuberPair} (r : rationalOpenData A) : Set (spa A) :=
  {v | (‚àÄ t ‚àà r.T, (v t ‚â§ v r.s)) ‚àß (v r.s ‚â† 0)}

instance (A : HuberPair) : Preorder (rationalOpenData A) where
  le r s := r.openSet ‚äÜ s.openSet
  le_refl _ := by tauto_set
  le_trans := by tauto_set
  lt_iff_le_not_ge := by tauto_set

def rationalBasis (A : HuberPair) : Set (Set (spa A)) :=
  {U | ‚àÉ r : rationalOpenData A, U = r.openSet}

instance (A : HuberPair) : TopologicalSpace (spa A) :=
  TopologicalSpace.generateFrom (spa.rationalBasis A)

lemma rationalOpenData.openSet_isOpen {A : HuberPair} (r : rationalOpenData A) :
    IsOpen r.openSet := by
  apply isOpen_generateFrom_of_mem
  simp [rationalBasis]

end spa

end TopologicalSpace

section Presheaf

namespace spa

end spa

def HuberRing.Away {R : Type u} [CommRing R] [TopologicalSpace R] [IsTopologicalRing R]
    (_T : Set R) (s : R) : Type u := Localization.Away s

namespace HuberRing.Away

variable {R : Type u} [CommRing R] [TopologicalSpace R] [IsTopologicalRing R]

instance (T : Set R) (s : R) : CommRing (HuberRing.Away T s) := by
  dsimp [HuberRing.Away]
  infer_instance

instance (T : Set R) (s : R) : Module R (HuberRing.Away T s) := by
  dsimp [HuberRing.Away]
  infer_instance

instance (T : Set R) (s : R) : Algebra R (HuberRing.Away T s) := by
  dsimp [HuberRing.Away]
  infer_instance

variable (T : Set R) (s : R)

end HuberRing.Away

namespace spa

variable {A : HuberPair.{u}} (r : rationalOpenData A)

def rationalOpenData.Localization := HuberRing.Away r.T r.s

def rationalOpenData.invSelf : r.Localization := Localization.Away.invSelf r.s

instance : CommRing r.Localization := by
  dsimp [rationalOpenData.Localization]
  infer_instance

instance : Algebra A r.Localization := by
  dsimp [rationalOpenData.Localization]
  infer_instance

def ringSubgroupsBasisFamily : OpenAddSubgroup A ‚Üí AddSubgroup r.Localization :=
  fun U ‚Ü¶ (Submodule.span (Subring.closure
    ((fun x ‚Ü¶ r.invSelf * x) '' (algebraMap A r.Localization '' (r.T : Set A))))
    (algebraMap A r.Localization '' U)).toAddSubgroup

open scoped Pointwise

open Submodule

open scoped Classical in
/-- A technical auxiliary lemma: for every finite set L contained in the ideal generated by T,
there exists a finite set K such that L is contained in the subgroup generated by the set T * K.
(Recall that T * K is the set of products of elements in T and in K). -/
lemma K.aux (L : Finset A) (h : (L : Set A) ‚äÜ Ideal.span (r.T : Set A)) :
    ‚àÉ (K : Finset A), (L : Set A) ‚äÜ (Submodule.span ‚Ñ§ ((r.T : Set A) * (K : Set A))) := by
  delta Ideal.span at h

  rw [‚Üê Set.image_id (r.T : Set A), Finsupp.span_image_eq_map_linearCombination] at h
  dsimp [Submodule.map] at h
  rw [Finset.subset_set_image_iff] at h
  obtain ‚ü®s, hs, rfl‚ü© := h
  use s.biUnion (fun f ‚Ü¶ f.frange)
  intro l hl
  obtain ‚ü®f, hf, rfl‚ü© := Finset.mem_image.mp hl
  rw [Finsupp.linearCombination_apply_of_mem_supported _ (s := f.support)]
  ¬∑ apply sum_mem
    intro t ht
    simp only [Finset.coe_biUnion, Finset.mem_coe, id_eq, smul_eq_mul]
    rw [mul_comm]
    apply mem_span_of_mem
    rw [Set.mem_mul]
    refine ‚ü®f t, ?_, t, ?_, rfl‚ü©
    ¬∑ rw [Set.mem_iUnion]
      use f
      rw [Set.mem_iUnion]
      use hf
      simp only [Finset.mem_coe]
      rw [Finsupp.mem_frange]
      exact ‚ü®by simpa using ht, t, rfl‚ü©
    ¬∑ replace hf := hs hf
      simp only [SetLike.mem_coe] at hf
      rw [Finsupp.mem_supported] at hf
      apply hf
      exact ht
  ¬∑ rw [Finsupp.mem_supported]

/-- The coercion from A to A‚üÆT/s‚üØ. -/
instance : Coe A r.Localization := ‚ü®fun a ‚Ü¶ (algebraMap A r.Localization : A ‚Üí r.Localization) a‚ü©

/-- For every open subgroup `U` of `A` and every `a : A`,
there exists an open subgroup `V` of `A`,
such that `a ‚Ä¢ (span D V)` is contained in the `D`-span of `U`. -/
lemma left_mul_subset (U : OpenAddSubgroup A) (a : A) :
    ‚àÉ V : OpenAddSubgroup A, (algebraMap A r.Localization a) ‚Ä¢ (ringSubgroupsBasisFamily r V) ‚â§
      (ringSubgroupsBasisFamily r U) := by
  let œÜ : A ‚Üí+ A := {
    toFun x := a * x
    map_zero' := by grind
    map_add' := by grind
  }
  have : Continuous œÜ := by simp [œÜ]; fun_prop
  let W : OpenAddSubgroup A := U.comap œÜ this
  have : (W : Set A) ‚àà nhds (0 : A) := by
    simpa [W, œÜ] using this.continuousAt.preimage_mem_nhds (by simpa using U.mem_nhds_zero)
  obtain ‚ü®V, hV‚ü© := NonarchimedeanRing.is_nonarchimedean (R := A) W this
  use V
  dsimp [ringSubgroupsBasisFamily]
  intro x hx
  rw [AddSubgroup.mem_smul_pointwise_iff_exists] at hx
  obtain ‚ü®y, hy, rfl‚ü© := hx
  simp only [mem_toAddSubgroup, smul_eq_mul] at hy ‚ä¢
  replace hV : algebraMap A r.Localization '' V ‚â§ algebraMap A r.Localization '' W := by
    apply Set.image_mono
    assumption
  let R :=
    (Subring.closure ((fun x ‚Ü¶ r.invSelf * x) '' (algebraMap A r.Localization '' (r.T : Set A))))
  replace hV : span R (algebraMap A r.Localization '' V) ‚â§
      span R (algebraMap A r.Localization '' W) := by
    apply span_mono
    assumption
  let œÜ' : r.Localization ‚Üí‚Çó[R] r.Localization := {
    toFun x := a * x
    map_add' := by grind
    map_smul' := by simp }
  have : span R (algebraMap A r.Localization '' W) ‚â§
      (span R (algebraMap A r.Localization '' U)).comap œÜ' := by
    intro x hx
    simp only [OpenAddSubgroup.coe_comap, AddMonoidHom.coe_mk, ZeroHom.coe_mk, mem_comap,
      LinearMap.coe_mk, AddHom.coe_mk, W, œÜ, œÜ'] at hx ‚ä¢
    induction hx using span_induction with
    | mem x h =>
      apply mem_span_of_mem
      simp only [Set.mem_image, Set.mem_preimage, SetLike.mem_coe] at h ‚ä¢
      obtain ‚ü®y, hy, rfl‚ü© := h
      refine ‚ü®a * y, hy, ?_‚ü©
      simp
    | zero => simp
    | add x y hx hy _ _ =>
      rw [mul_add]
      apply add_mem
      all_goals assumption
    | smul a x hx _ =>
      simp only [Algebra.mul_smul_comm]
      apply smul_mem
      assumption
  simpa using hV.trans this hy

open scoped Classical in
/-- If T ‚äÜ A generates an open ideal, and U is an open subgroup of A,
then T ‚Ä¢ U generates an open subgroup.
(This lemma is the main part of case n = 1 of [Wedhorn, Lem 6.20].) -/
lemma mul_T_open (U : OpenAddSubgroup A) :
    IsOpen (((r.T : Set A) ‚Ä¢ Submodule.span ‚Ñ§ (U : Set A) : Submodule ‚Ñ§ A) : Set A) := by
  -- Choose an ideal of definition I ‚äÜ span T
  have h‚ÇÅ := Ideal.zero_mem (Ideal.span (r.T : Set A))
  obtain ‚ü®A‚ÇÄ, _, _, _, ‚ü®_, emb, I, fg, top‚ü©, hI‚ü© :=
    HuberRing.exists_pod_subset A.carrier _
      (r.isOpen.mem_nhds <| Ideal.zero_mem <| Ideal.span (r.T : Set A))
  dsimp only at hI
  -- Choose a generating set L ‚äÜ I
  obtain ‚ü®L, hL‚ü© := fg
  rw [‚Üê hL] at hI
  -- Observe L ‚äÜ span T
  have Lsub : (L.image (algebraMap A‚ÇÄ A) : Set A) ‚äÜ Ideal.span (r.T : Set A) := by
    rw [Finset.coe_image]
    refine subset_trans ?_ hI
    apply Set.image_mono
    exact Ideal.subset_span
  obtain ‚ü®K, hK‚ü© := K.aux _ _ Lsub
  -- Choose V such that K * V ‚äÜ U
  -- let nonarch := HuberRing.nonarchimedean,
  let V := K.inf (fun k : A ‚Ü¶ (NonarchimedeanRing.left_mul_subset U k).choose)
  obtain ‚ü®H‚ÇÅ, H‚ÇÇ‚ü© := isAdic_iff.mp top
  have hV : K * (V : Set A) ‚äÜ U := by
    rintro _ ‚ü®k, hk, v, hv, rfl‚ü©
    apply (NonarchimedeanRing.left_mul_subset U k).choose_spec
    refine ‚ü®v, ?_, rfl‚ü©
    apply (Finset.inf_le hk : V ‚â§ _)
    exact hv
  replace hV : span ‚Ñ§ _ ‚â§ span ‚Ñ§ _ := span_mono hV
  rw [‚Üê span_mul_span] at hV
  obtain ‚ü®m, hm‚ü© := H‚ÇÇ _ ((emb.continuous.isOpen_preimage _ V.isOpen).mem_nhds (by simp))
  rw [‚Üê Set.image_subset_iff] at hm
  let O : OpenAddSubgroup A := {
    toAddSubgroup := (I ^ (m + 1) : Ideal A‚ÇÄ).toAddSubgroup.map (algebraMap A‚ÇÄ A)
    isOpen' := by
      exact emb.isOpenMap _ (H‚ÇÅ (m + 1)) }
  let O' : AddSubgroup A := ((r.T : Set A) ‚Ä¢ span ‚Ñ§ U).toAddSubgroup
  change IsOpen (O' : Set A)
  apply AddSubgroup.isOpen_of_openAddSubgroup (U := O)
  -- What remains is the following calculation: I^(m+1) ‚äÜ T ‚Ä¢ span U.
  -- Unfortunately it seems to be hard to express in calc mode
  -- First observe: I^(m+1) = L ‚Ä¢ I^m as A‚ÇÄ-ideal, but also as ‚Ñ§-submodule
  simp only [O', O]
  have : toAddSubgroup (I ^ (m + 1)) =
      ((L : Set A‚ÇÄ) ‚Ä¢ AddSubgroup.toIntSubmodule (toAddSubgroup (I ^ m))).toAddSubgroup := by
    suffices (toAddSubgroup (I ^ (m + 1)) : Set A‚ÇÄ) =
        (((L : Set A‚ÇÄ) ‚Ä¢ AddSubgroup.toIntSubmodule
          (toAddSubgroup (I ^ m))).toAddSubgroup : Set A‚ÇÄ) by
      ext x
      rw [Set.ext_iff] at this
      exact this x
    rw [pow_succ, mul_comm, ‚Üê smul_eq_mul]
    simp only [smul_eq_mul, toIntSubmodule_toAddSubgroup]
    rw [‚Üê span_coe_eq_restrictScalars]
    dsimp only [coe_toAddSubgroup]
    rw [‚Üê smul_eq_smul_span_int]
    simp only [SetLike.coe_set_eq]
    have : I ^ m = span A‚ÇÄ (I ^ m) := by simp
    nth_rw 2 [this]
    rw [Submodule.set_smul_span, smul_eq_mul, ‚Üê span_mul_span]
    change _ = Ideal.span (L : Set A‚ÇÄ) * _
    rw [hL]
    simp
  rw [this]
  trans ((r.T : Set A) ‚Ä¢ ((span ‚Ñ§ (K : Set A)) * span ‚Ñ§ (V : Set A))).toAddSubgroup
  ¬∑ rw [span_mul_span, Submodule.set_smul_span]
    simp only [smul_eq_mul]
    rw [‚Üê mul_assoc, ‚Üê span_mul_span]
    trans (span ‚Ñ§ ((r.T : Set A) * (K : Set A)) *
      span ‚Ñ§ ((algebraMap A‚ÇÄ A) '' (I ^ m : Ideal A‚ÇÄ))).toAddSubgroup
    ¬∑ rw [mul_comm, span_mul_span, ‚Üê smul_eq_mul, ‚Üê Submodule.set_smul_span]
      trans ((algebraMap A‚ÇÄ A '' (I ^ m : Ideal A‚ÇÄ) : Set A) ‚Ä¢
        span ‚Ñ§ ((L.image (algebraMap A‚ÇÄ A) : Set A))).toAddSubgroup
      ¬∑ rw [Submodule.set_smul_span, smul_eq_mul, ‚Üê span_mul_span, mul_comm]
        simp
        let œÜ : A‚ÇÄ ‚Üí‚Çê[‚Ñ§] A := {
          toFun := algebraMap A‚ÇÄ A
          map_one' := by simp
          map_mul' := by simp
          map_zero' := by simp
          map_add' := by simp
          commutes' := by simp }
        change _ ‚â§ (span ‚Ñ§ (œÜ.toLinearMap '' (L : Set A‚ÇÄ)) *
          span ‚Ñ§ (œÜ.toLinearMap '' _)).toAddSubgroup
        rw [span_image, span_image, ‚Üê Submodule.map_mul, span_mul_span,
          ‚Üê smul_eq_mul, ‚Üê Submodule.set_smul_span]
        simp [œÜ]
        rfl
      ¬∑ gcongr 2
        exact span_le.mpr hK
    ¬∑ gcongr
  ¬∑ gcongr

lemma addsubgroup_smul_le_smul {V W : AddSubgroup r.Localization} (h : V ‚â§ W) (a : r.Localization) :
    a ‚Ä¢ V ‚â§ a ‚Ä¢ W := by
  intro x hx
  rw [AddSubgroup.mem_smul_pointwise_iff_exists] at hx
  obtain ‚ü®y, hy, rfl‚ü© := hx
  rw [AddSubgroup.mem_smul_pointwise_iff_exists]
  refine ‚ü®y, ?_, rfl‚ü©
  apply h
  simpa

lemma submodule_le_submodule {R M : Type*} [Ring R] [AddCommGroup M] [Module R M]
    {p‚ÇÅ p‚ÇÇ : Submodule R M} : p‚ÇÅ.toAddSubgroup ‚â§ p‚ÇÇ.toAddSubgroup ‚Üî p‚ÇÅ ‚â§ p‚ÇÇ := by
  rfl

/-
Our next goal is the lemma mul_left,
which says that for every element a of A‚üÆT/s‚üØ and
every open subgroup U of A, there exists an open subgroup V of A, such that a ‚Ä¢ Dspan V ‚â§ Dspan U.

We prove this statement using two helper lemmas.
The first proves the case where a = s‚Åª¬π. The second considers arbitrary powers of s‚Åª¬π.
-/

/-- Helper lemma. A special case of mul_left, where the element a is s‚Åª¬π. -/
lemma mul_left.aux‚ÇÅ (U : OpenAddSubgroup A) : ‚àÉ (V : OpenAddSubgroup A),
      r.invSelf ‚Ä¢ (ringSubgroupsBasisFamily r V) ‚â§ ringSubgroupsBasisFamily r U := by
  refine ‚ü®‚ü®((r.T : Set A) ‚Ä¢ Submodule.span ‚Ñ§ (U : Set A) : Submodule ‚Ñ§ A).toAddSubgroup,
    mul_T_open r U‚ü©, ?_‚ü©
  simp only [ringSubgroupsBasisFamily]
  have : ((r.T : Set A) ‚Ä¢ (Submodule.span ‚Ñ§ (U : Set A) : Submodule ‚Ñ§ A) : Submodule ‚Ñ§ A) =
      Submodule.span ‚Ñ§ (r.T : Set A) * (Submodule.span ‚Ñ§ (U : Set A) : Submodule ‚Ñ§ A) := by
    rw [Submodule.set_smul_span, Submodule.span_mul_span]
    congr
  let R :=
    (Subring.closure ((fun x ‚Ü¶ r.invSelf * x) '' (algebraMap A r.Localization '' (r.T : Set A))))
  change r.invSelf ‚Ä¢ (Submodule.span R
    (algebraMap A r.Localization '' (((r.T : Set A) ‚Ä¢ (Submodule.span ‚Ñ§ (U : Set A) :
      Submodule ‚Ñ§ A) : Submodule ‚Ñ§ A)))).toAddSubgroup ‚â§ _
  rw [this, Submodule.span_mul_span]
  let œÜ : A ‚Üí‚Çó[‚Ñ§] r.Localization := {
    toFun := algebraMap A r.Localization
    map_add' := by simp
    map_smul' := by simp }
  have : (algebraMap A r.Localization '' (Submodule.span ‚Ñ§ ((r.T : Set A) * (U : Set A)))) =
      (Submodule.map œÜ (Submodule.span ‚Ñ§ ((r.T : Set A) * (U : Set A)))) := by
    rfl
  rw [this, Submodule.map_span, Submodule.span_span_of_tower]
  have : r.invSelf ‚Ä¢ (Submodule.span R (œÜ '' ((r.T : Set A) * (U : Set A)))).toAddSubgroup =
      (r.invSelf ‚Ä¢ (Submodule.span R (œÜ '' ((r.T : Set A) * (U : Set A))))).toAddSubgroup := rfl
  rw [this, submodule_le_submodule, Submodule.smul_def, Submodule.span_le]
  intro x hx
  rw [Set.mem_smul_set] at hx
  obtain ‚ü®x, hx, rfl‚ü© := hx
  simp only [SetLike.mem_coe] at hx ‚ä¢
  induction' hx using Submodule.span_induction with y mem y z hy hz hy' hz' r' y hy hy'
  ¬∑ obtain ‚ü®y, hy, rfl‚ü© := mem
    rw [Set.mem_mul] at hy
    obtain ‚ü®t, ht, u, hu, rfl‚ü© := hy
    simp only [LinearMap.coe_mk, AddHom.coe_mk, map_mul, smul_eq_mul, œÜ]
    rw [‚Üê mul_assoc, ‚Üê smul_eq_mul]
    convert Submodule.smul_mem (R := R) _ ‚ü®r.invSelf * algebraMap A r.Localization t, ?_‚ü© _ using 1
    ¬∑ apply Subring.mem_closure_of_mem
      use t
      simp only [Set.mem_image, Finset.mem_coe, and_true]
      use t
      simpa
    ¬∑ apply Submodule.mem_span_of_mem
      use u
  ¬∑ simp
  ¬∑ rw [smul_add]
    apply Submodule.add_mem
    all_goals assumption
  ¬∑ simp only [smul_eq_mul, Algebra.mul_smul_comm]
    apply Submodule.smul_mem
    simpa

def rationalOpenData.invPower (s' : Submonoid.powers r.s) : r.Localization :=
  Localization.mk 1 s'

lemma rationalOpenData.invPower_succ (k : ‚Ñï) :
    r.invPower ‚ü®r.s ^ (k + 1), k + 1, rfl‚ü© = r.invPower ‚ü®r.s ^ k, k, rfl‚ü© * r.invSelf := by
  simp only [invPower, invSelf, Localization.Away.invSelf]
  rw [Localization.mk_mul]
  congr
  all_goals grind

/-- Helper lemma. A special case of mul_left, where the element a is the inverse of a power of s. -/
lemma mul_left.aux‚ÇÇ (s' : Submonoid.powers r.s) (U : OpenAddSubgroup A) :
    ‚àÉ (V : OpenAddSubgroup A),
      r.invPower s' ‚Ä¢ (ringSubgroupsBasisFamily r V) ‚â§ ringSubgroupsBasisFamily r U := by
  obtain ‚ü®_, ‚ü®n, rfl‚ü©‚ü© := s'
  induction' n with k hk
  ¬∑ use U
    simp [rationalOpenData.invPower]
  ¬∑ obtain ‚ü®W, hW‚ü© := hk
    obtain ‚ü®V, hV‚ü© := mul_left.aux‚ÇÅ r W
    refine ‚ü®V, le_trans ?_ hW‚ü©
    dsimp
    rw [r.invPower_succ, mul_smul]
    exact addsubgroup_smul_le_smul r hV _

/-- For every element a of A‚üÆT/s‚üØ and every open subgroup U of A,
there exists an open subgroup V of A, such that a ‚Ä¢ Dspan V ‚â§ Dspan U. -/
lemma mul_left (a : r.Localization)
    (U : OpenAddSubgroup A) : ‚àÉ (V : OpenAddSubgroup A), a ‚Ä¢ (ringSubgroupsBasisFamily r V) ‚â§
      ringSubgroupsBasisFamily r U := by
  induction' a using Localization.induction_on with a
  obtain ‚ü®a', s'‚ü© := a
  obtain ‚ü®W, hW‚ü© := mul_left.aux‚ÇÇ r s' U
  obtain ‚ü®V, hV‚ü© := left_mul_subset r W a'
  use V
  refine le_trans ?_ hW
  simp only [rationalOpenData.invPower]
  rw [‚Üê one_mul a']
  nth_rw 1 [‚Üê mul_one s']
  rw [‚Üê Localization.mk_mul, mul_smul]
  exact addsubgroup_smul_le_smul r hV _

def ringSubgroupsBasis : RingSubgroupsBasis (ringSubgroupsBasisFamily r) :=
  RingSubgroupsBasis.of_comm (ringSubgroupsBasisFamily r)
    (fun U V ‚Ü¶ ‚ü®U ‚äì V, by
      simp only [ringSubgroupsBasisFamily]
      intro x hx
      constructor
      ¬∑ apply Submodule.span_mono _ hx
        apply Set.image_mono
        simp
      ¬∑ apply Submodule.span_mono _ hx
        apply Set.image_mono
        simp‚ü©)
    (fun U ‚Ü¶ by
      obtain ‚ü®V, hV‚ü© := NonarchimedeanRing.mul_subset U
      use V
      dsimp only [ringSubgroupsBasisFamily]
      let R := (Subring.closure
        ((fun x ‚Ü¶ r.invSelf * x) '' (algebraMap A r.Localization '' (r.T : Set A))))
      let S := ((algebraMap A r.Localization : _ ‚Üí _) '' (V : Set A))
      let T := ((algebraMap A r.Localization : _ ‚Üí _) '' (U : Set A))
      have : Submodule.span R S * Submodule.span R S ‚â§ Submodule.span R T := by
        rw [Submodule.span_mul_span]
        apply Submodule.span_mono
        convert Set.image_mono hV
        simp [S, Set.image_mul]
      refine subset_trans ?_ this
      simp [S, R, Submodule.mul_eq_span_mul_set])
    fun x U ‚Ü¶ by
      obtain ‚ü®V, hV‚ü© := mul_left r x U
      refine ‚ü®V, fun y _ ‚Ü¶ ?_‚ü©
      apply hV
      rw [AddSubgroup.mem_smul_pointwise_iff_exists]
      exact ‚ü®y, by simpa‚ü©

instance : TopologicalSpace r.Localization :=
  (spa.ringSubgroupsBasis r).topology

instance : IsTopologicalRing r.Localization := inferInstance

instance : UniformSpace r.Localization :=
  IsTopologicalAddGroup.toUniformSpace r.Localization

instance : IsUniformAddGroup r.Localization :=
  isUniformAddGroup_of_addCommGroup

instance : UniformContinuousConstSMul A r.Localization where
  uniformContinuous_const_smul c := by
    let f : r.Localization ‚Üí+ r.Localization := {
      toFun x := c ‚Ä¢ x
      map_zero' := by simp
      map_add' := by simp }
    change UniformContinuous f
    apply uniformContinuous_addMonoidHom_of_continuous
    simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, f, Algebra.smul_def]
    continuity

noncomputable
instance : CommRing (UniformSpace.Completion r.Localization) :=
  UniformSpace.Completion.commRing _

noncomputable
instance : Algebra A (UniformSpace.Completion r.Localization) :=
  UniformSpace.Completion.algebra _ _

instance : IsTopologicalRing (UniformSpace.Completion r.Localization) :=
  inferInstance

open UniformSpace

-- Wedhorn Proposition 8.2(1)
noncomputable def rationalOpenData.uniqueOfLE
    {A : HuberPair} (r s : rationalOpenData A) (h : r ‚â§ s) :
    Unique (Completion s.Localization ‚ÜíA[A] Completion r.Localization) :=
  sorry

attribute [-instance] UniformSpace.Completion.ring

noncomputable def rationalOpenData.topAlgHomOfLE
    {A : HuberPair} (r s : rationalOpenData A) (h : r ‚â§ s) :
    Completion s.Localization ‚ÜíA[A] Completion r.Localization :=
  letI := uniqueOfLE r s h
  default

lemma rationalOpenData.topAlgHom_eq {A : HuberPair} (r s : rationalOpenData A) (h : r ‚â§ s)
    (f : Completion s.Localization ‚ÜíA[A] Completion r.Localization) :
    rationalOpenData.topAlgHomOfLE r s h = f := by
  letI := uniqueOfLE r s h
  exact Subsingleton.elim _ _

end spa

open UniformSpace

noncomputable def spa.presheafOnRationalOpenDataAlg (A : HuberPair) :
    (rationalOpenData A)·µí·µñ ‚•§  TopAlgCat A where
  obj r := TopAlgCat.of A (Completion r.unop.Localization)
  map h := TopAlgCat.ofHom A (rationalOpenData.topAlgHomOfLE _ _ h.unop.1.1)
  map_id _ := by
    apply ConcreteCategory.ext
    apply rationalOpenData.topAlgHom_eq
  map_comp _ _ := by
    apply ConcreteCategory.ext
    apply rationalOpenData.topAlgHom_eq


-- attribute [-instance] UniformSpace.Completion.ring

-- def rationalOpenData.algHomOfLE {A : HuberPair} (r s : rationalOpenData A) (h : r ‚â§ s) :
--     s.Localization ‚Üí‚Çê[A] r.Localization :=
--   sorry

-- @[simp]
-- lemma rationalOpenData.algHomOfLE_refl {A : HuberPair}
--     (r : rationalOpenData A) :
--     algHomOfLE r r (le_refl r) = AlgHom.id _ _ := by
--   sorry

-- @[simp]
-- lemma rationalOpenData.algHomOfLE_trans {A : HuberPair}
--     {r s t : rationalOpenData A} (hrs : r ‚â§ s) (hst : s ‚â§ t) :
--     (algHomOfLE r s hrs).comp (algHomOfLE s t hst) = algHomOfLE r t (fun _ a ‚Ü¶ hst (hrs a)) := by
--   sorry

-- lemma rationalOpenData.algHomOfLE_continuous {A : HuberPair} (r s : rationalOpenData A)
--     (h : r ‚â§ s) : Continuous (algHomOfLE r s h) :=
--   sorry

-- noncomputable def rationalOpenData.topAlgHomOfLE
--     {A : HuberPair} (r s : rationalOpenData A) (h : r ‚â§ s) :
--     Completion s.Localization ‚ÜíA[A] Completion r.Localization where
--   toRingHom := Completion.mapRingHom (algHomOfLE r s h).toRingHom (algHomOfLE_continuous r s h)
--   commutes' x := by
--     simp only [AlgHom.toRingHom_eq_coe, RingHom.toMonoidHom_eq_coe, OneHom.toFun_eq_coe,
--       MonoidHom.toOneHom_coe, MonoidHom.coe_coe, Completion.mapRingHom_apply]
--     rw [Completion.algebraMap_def, Completion.algebraMap_def]
--     sorry
--   cont := Completion.continuous_map

-- end spa

-- open UniformSpace

-- noncomputable def spa.presheafOnRationalOpenDataAlg (A : HuberPair) :
--     (rationalOpenData A)·µí·µñ ‚•§  TopAlgCat A where
--   obj r := TopAlgCat.of A (Completion r.unop.Localization)
--   map h := TopAlgCat.ofHom A (rationalOpenData.topAlgHomOfLE _ _ h.unop.1.1)
--   map_id _ := by
--     ext
--     change Completion.map _ _ = _
--     simp
--   map_comp _ _ := by
--     ext
--     change Completion.map _ _ = (Completion.map _ ‚àò Completion.map _) _
--     rw [Completion.map_comp]
--     ¬∑ change _ = Completion.map ((rationalOpenData.algHomOfLE _ _ _).comp
--         (rationalOpenData.algHomOfLE _ _ _)) _
--       simp [-AlgHom.coe_comp]
--     ¬∑ apply uniformContinuous_addMonoidHom_of_continuous
--       exact rationalOpenData.algHomOfLE_continuous _ _ _
--     ¬∑ apply uniformContinuous_addMonoidHom_of_continuous
--       exact rationalOpenData.algHomOfLE_continuous _ _ _

noncomputable def spa.presheafOnRationalOpenData (A : HuberPair) :
    (rationalOpenData A)·µí·µñ ‚•§  TopCommRingCat :=
  presheafOnRationalOpenDataAlg A ‚ãô forget‚ÇÇ _ _

def spa.rationalOpenDataToOpens (A : HuberPair) : rationalOpenData A ‚•§ Opens (spa A) where
  obj r := ‚ü®r.openSet, r.openSet_isOpen‚ü©
  map h := h

open TopCat

noncomputable def spa.presheaf (A : HuberPair.{u}) : Presheaf TopCommRingCat.{u} (of (spa A)) :=
  (rationalOpenDataToOpens A).op.pointwiseRightKanExtension (spa.presheafOnRationalOpenData A)

end Presheaf

open TopCat

section Valuation

def TopCat.Presheaf.forgetToRing {X : TopCat.{u}} (‚Ñ± : X.Presheaf TopCommRingCat) :
    X.Presheaf CommRingCat :=
  ‚Ñ± ‚ãô forget‚ÇÇ TopCommRingCat CommRingCat

def spa.stalk_valuation (A : HuberPair) (x : of (spa A)) :
    Spv (((spa.presheaf A).forgetToRing).stalk x) :=
  sorry

end Valuation

open AlgebraicGeometry Opposite

structure PreValuedRingedSpace extends PresheafedSpace TopCommRingCat where
  valuation : ‚àÄ x : carrier, Spv (presheaf.forgetToRing.stalk x)

def PreValuedRingedSpace.forgetToRing (X : PreValuedRingedSpace.{u}) :
    PresheafedSpace CommRingCat.{u} :=
  (forget‚ÇÇ TopCommRingCat CommRingCat).mapPresheaf.obj X.toPresheafedSpace

instance PreValuedRingedSpace.coeCarrier :
    CoeOut PreValuedRingedSpace TopCat where coe X :=
  X.carrier

instance PreValuedRingedSpace.coeSort : CoeSort PreValuedRingedSpace Type* where
  coe X := X.1

def PreValuedRingedSpace.toTopCat (X : PreValuedRingedSpace.{u}) : TopCat.{u} :=
  of X

instance : Category.{u} PreValuedRingedSpace.{u} :=
  InducedCategory.category PreValuedRingedSpace.toPresheafedSpace

attribute [local instance] TopCommRingCat.uniformSpace

instance (X : TopCat) (P : TopCat.Presheaf TopCommRingCat X) (U : Opens X) :
    TopologicalSpace (P.forgetToRing.obj (op U)) :=
  inferInstanceAs (TopologicalSpace (P.obj (op U)))

structure PreLVCRS extends PresheafedSpace TopCommRingCat where
  complete (U : Opens carrier) : CompleteSpace (presheaf.obj (op U))
  isLocalRing (x : carrier) : presheaf.forgetToRing.stalk x
  valuation (x : carrier) : Spv (presheaf.forgetToRing.stalk x)
  valuation_continuous (U : Opens carrier) (x : carrier) (hx : x ‚àà U) :
    ((valuation x).comap (presheaf.forgetToRing.germ U x hx).hom').IsContinuous
  supp_maximal (x : carrier) : Ideal.IsMaximal (valuation x).out.supp

instance PreLVCRS.coeCarrier :
    CoeOut PreLVCRS TopCat where coe X :=
  X.carrier

instance PreLVCRS.coeSort : CoeSort PreLVCRS Type* where
  coe X := X.1

structure LVCRS extends SheafedSpace TopCommRingCat where
  complete (U : Opens carrier) : CompleteSpace (presheaf.obj (op U))
  isLocalRing (x : carrier) : presheaf.forgetToRing.stalk x
  valuation (x : carrier) : Spv (presheaf.forgetToRing.stalk x)
  valuation_continuous (U : Opens carrier) (x : carrier) (hx : x ‚àà U) :
    ((valuation x).comap (presheaf.forgetToRing.germ U x hx).hom').IsContinuous
  supp_maximal (x : carrier) : Ideal.IsMaximal (valuation x).out.supp

def LVCRS.toPreLVCRS (X : LVCRS.{u}) : PreLVCRS.{u} where
  toPresheafedSpace := X.toPresheafedSpace
  valuation := X.valuation
  supp_maximal := X.supp_maximal
  complete := X.complete
  valuation_continuous := X.valuation_continuous
  isLocalRing := X.isLocalRing

instance LVCRS.coeCarrier :
    CoeOut LVCRS TopCat where coe X :=
  X.carrier

instance LVCRS.coeSort : CoeSort LVCRS Type* where
  coe X := X.1

def LVCRS.toPreValuedRingedSpace (X : LVCRS.{u}) : PreValuedRingedSpace.{u} where
  toPresheafedSpace := X.toPresheafedSpace
  valuation := X.valuation

noncomputable def PreValuedRingedSpace.restrictStalkMap {U : TopCat.{u}}
    (X : PreValuedRingedSpace.{u}) {f : U ‚ü∂ X.toTopCat} (h : IsOpenEmbedding f) (x : U) :
    X.toPresheafedSpace.presheaf.forgetToRing.stalk (f x) ‚ü∂
    (X.toPresheafedSpace.restrict h).presheaf.forgetToRing.stalk x :=
  (PresheafedSpace.Hom.stalkMap (PresheafedSpace.ofRestrict X.forgetToRing h) x)

noncomputable def PreValuedRingedSpace.restrictStalkMapInv {U : TopCat.{u}}
    (X : PreValuedRingedSpace.{u}) {f : U ‚ü∂ X.toTopCat} (h : IsOpenEmbedding f) (x : U) :
    (X.toPresheafedSpace.restrict h).presheaf.forgetToRing.stalk x ‚ü∂
      X.toPresheafedSpace.presheaf.forgetToRing.stalk (f x) :=
  inv (PresheafedSpace.Hom.stalkMap (PresheafedSpace.ofRestrict X.forgetToRing h) x)

def PreValuedRingedSpace.restrict {U : TopCat.{u}} (X : PreValuedRingedSpace.{u})
    {f : U ‚ü∂ X.toTopCat} (h : IsOpenEmbedding f) : PreValuedRingedSpace where
  toPresheafedSpace := X.toPresheafedSpace.restrict h
  valuation x := by
    refine ValuativeRel.ofValuation ((X.valuation (f x)).valuation.comap ?_)
    exact ConcreteCategory.hom (X.restrictStalkMapInv h x)

def PreLVCRS.restrict {U : TopCat.{u}} (X : PreLVCRS.{u})
    {f : U ‚ü∂ (X : TopCat)} (h : IsOpenEmbedding f) : PreLVCRS where
  toPresheafedSpace := X.toPresheafedSpace.restrict h
  complete := sorry
  isLocalRing := sorry
  valuation := sorry
  valuation_continuous := sorry
  supp_maximal := sorry
  -- valuation x := by
  --   refine ValuativeRel.ofValuation ((X.valuation (f x)).valuation.comap ?_)
  --   exact ConcreteCategory.hom (X.restrictStalkMapInv h x)

noncomputable def Spa (A : HuberPair.{u}) : PreLVCRS.{u} where
  carrier := of (spa A)
  presheaf := spa.presheaf A
  complete := sorry
  isLocalRing := sorry
  valuation := spa.stalk_valuation A
  valuation_continuous := sorry
  supp_maximal := sorry

open TopologicalSpace

noncomputable def PreLVCRS.Hom.stalkMap {X Y : PreLVCRS.{u}}
    (f : X.toPresheafedSpace ‚ü∂ Y.toPresheafedSpace) (x : X) :=
  PresheafedSpace.Hom.stalkMap
    ((Functor.mapPresheaf (forget‚ÇÇ TopCommRingCat.{u} CommRingCat.{u})).map f) x

structure PreLVCRS.Hom (X Y : PreLVCRS.{u}) where
  hom : X.toPresheafedSpace ‚ü∂ Y.toPresheafedSpace
  -- isLocal (x : X) : IsLocalHom (PreLVCRS.Hom.stalkMap hom x).hom'
  -- follows from `valuedCondition`
  valuativeCondition (x : X) : (X.valuation x).comap (PreLVCRS.Hom.stalkMap hom x).hom' =
    (Y.valuation (hom.base x))

@[simps]
def PreLVCRS.Hom.id (X : PreLVCRS.{u}) : PreLVCRS.Hom X X where
  hom := ùüô _
  valuativeCondition x := by
    dsimp [stalkMap]
    erw [AlgebraicGeometry.PresheafedSpace.stalkMap.id]
    rfl

@[simps]
def PreLVCRS.Hom.comp {X Y Z : PreLVCRS.{u}} (f : PreLVCRS.Hom X Y) (g : PreLVCRS.Hom Y Z) :
    PreLVCRS.Hom X Z where
  hom := f.hom ‚â´ g.hom
  valuativeCondition x := by
    sorry

-- def PreLVCRS.Hom.c {X Y : PreLVCRS.{u}} (f : PreLVCRS.Hom X Y) :

instance : Category.{u} PreLVCRS.{u} where
  Hom := PreLVCRS.Hom
  id := PreLVCRS.Hom.id
  comp := PreLVCRS.Hom.comp
  id_comp := sorry
  comp_id := sorry
  assoc := sorry

def LVCRS.IsAdicSpace (X : LVCRS.{u}) : Prop :=
  ‚àÄ x : X, ‚àÉ (U : OpenNhds x) (A : HuberPair.{u}),
    (Nonempty (Spa.{u} A ‚âÖ (X.toPreLVCRS.restrict U.isOpenEmbedding)))

structure AdicSpace extends LVCRS where
  isAdic : toLVCRS.IsAdicSpace

namespace AdicSpace

@[ext]
structure Hom (X Y : AdicSpace.{u}) extends
    PreLVCRS.Hom X.toPreLVCRS Y.toPreLVCRS where

def Hom.comp {X Y Z : AdicSpace.{u}} (f : X.Hom Y) (g : Y.Hom Z) : X.Hom Z where
  __ := PreLVCRS.Hom.comp f.1 g.1

def Hom.id (X : AdicSpace.{u}) : X.Hom X where
  __ := PreLVCRS.Hom.id X.toPreLVCRS

instance : Category.{u} AdicSpace.{u} where
  Hom := AdicSpace.Hom
  id := Hom.id
  comp := Hom.comp

def forgetToPreLVCRS : AdicSpace.{u} ‚•§ PreLVCRS.{u} where
  obj X := X.toPreLVCRS
  map {X Y} f := f.1

def PreLVCRS.forgetToPresheafedSpace : PreLVCRS.{u} ‚•§ PresheafedSpace TopCommRingCat.{u} where
  obj X := X.toPresheafedSpace
  map f := f.hom

def forgetToPresheafedSpace : AdicSpace.{u} ‚•§ PresheafedSpace TopCommRingCat.{u} :=
  forgetToPreLVCRS ‚ãô PreLVCRS.forgetToPresheafedSpace

abbrev PreLVCRS.IsOpenImmersion : MorphismProperty PreLVCRS := fun _ _ f ‚Ü¶
  PresheafedSpace.IsOpenImmersion (PreLVCRS.forgetToPresheafedSpace.map f)

abbrev IsOpenImmersion : MorphismProperty AdicSpace := fun _ _ f ‚Ü¶
  PreLVCRS.IsOpenImmersion (forgetToPreLVCRS.map f)

def Hom.base {X Y : AdicSpace.{u}} (f : X ‚ü∂ Y) : X.1.carrier ‚ü∂ Y.1.carrier :=
  f.1.1.1

instance : CoeSort AdicSpace.{u} (Type u) where
  coe X := X.1.1

abbrev Opens (X : AdicSpace.{u}) := TopologicalSpace.Opens X.1

scoped[AdicSpace] notation3 "Œì(" X ", " U ")" =>
  (PresheafedSpace.presheaf (PreLVCRS.toPresheafedSpace
    (LVCRS.toPreLVCRS (AdicSpace.toLVCRS X)))).obj
    (op (Œ± := AdicSpace.Opens _) U)

variable {X Y : AdicSpace.{u}}

def Opens.adicSpace (U : X.Opens) : AdicSpace.{u} :=
  sorry

instance : CoeOut X.Opens AdicSpace.{u} where
  coe U := U.adicSpace

def Opens.Œπ (U : X.Opens) : (U : AdicSpace.{u}) ‚ü∂ X :=
  sorry

def Opens.preimage (f : X ‚ü∂ Y) (U : Y.Opens) : X.Opens :=
  U.comap f.hom.base.1

def Hom.restrict (f : X ‚ü∂ Y) (U : Y.Opens) : (U.preimage f : AdicSpace.{u}) ‚ü∂ U :=
  sorry

@[reassoc (attr := simp)]
lemma Hom.restrict_Œπ (f : X ‚ü∂ Y) (U : Y.Opens) :
    f.restrict U ‚â´ U.Œπ = (U.preimage f).Œπ ‚â´ f :=
  sorry

end AdicSpace

open CategoryTheory.Functor

namespace CategoryTheory.Functor

variable {C : Type*} [Category C]
variable {D : Type*} [Category D]

def mapSheaf (F : C ‚•§ D)
    [‚àÄ X : SheafedSpace C, (Opens.grothendieckTopology X).HasSheafCompose F] :
    SheafedSpace C ‚•§ SheafedSpace D where
  obj X :=
    { carrier := X.carrier
      presheaf := X.presheaf ‚ãô F
      IsSheaf := GrothendieckTopology.HasSheafCompose.isSheaf _ X.IsSheaf }
  map f :=
    { base := f.base
      c := whiskerRight f.c F }
  map_id X := by
    ext U
    ¬∑ rfl
    ¬∑ simp
  map_comp f g := by
    ext U
    ¬∑ rfl
    ¬∑ simp

variable (F : C ‚•§ D) [‚àÄ X : SheafedSpace C, (Opens.grothendieckTopology X).HasSheafCompose F]

@[simp]
lemma mapSheaf_obj_X (X : SheafedSpace C) :
    (F.mapSheaf.obj X : TopCat) = (X : TopCat) :=
  rfl

@[simp]
lemma mapSheaf_obj_presheaf (X : SheafedSpace C) :
    (F.mapSheaf.obj X).presheaf = X.presheaf ‚ãô F :=
  rfl

@[simp]
lemma mapSheaf_map_f {X Y : SheafedSpace C} (f : X ‚ü∂ Y) :
    (F.mapSheaf.map f).base = f.base :=
  rfl

@[simp]
lemma mapSheaf_map_c {X Y : SheafedSpace C} (f : X ‚ü∂ Y) :
    (F.mapSheaf.map f).c = whiskerRight f.c F :=
  rfl

end Functor

end CategoryTheory
