/-
Copyright (c) 2022 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison
-/
import Std.Util.TermUnsafe
import Mathlib.Tactic.Repeat

/-!
# The `apply_rules` tactic

The `apply_rules` tactic calls `apply` (with a specified set of lemmas) and `assumption`
repeatedly, until no more applications are possible.
-/


namespace Mathlib.Tactic
open Lean Meta Elab Tactic Term Parser.Tactic

/--
`applyFirst l`, for `l : List (TacticM Expr)`,
tries to apply one of the lemmas generated by the tactics in `l` to the first goal, and
fail if none succeeds.

Implementation note:
We pass a list of `TacticM Expr` rather than just `Expr`,
because when `(← getMainGoal).apply e` succeeds, it can modify `e` via unification,
blocking subsequent applications which would succeed but unify differently.
This implementation ensures that the expressions are freshly generated for each
invocation of `apply`.
-/
def applyFirst (cfg : ApplyConfig) (L : List (TacticM Expr)) : TacticM Unit := withMainContext do
  let g ← getMainGoal
  setGoals $ ← L.firstM (fun t => do g.apply (← t) cfg)

/--
Implementation of the `apply_rules` tactic.
-/
def applyRules (bound : Nat) (cfg : ApplyConfig) (lemmas : List (TacticM Expr)) : TacticM Unit :=
  repeatAllSubgoals bound (do (evalTactic $ ← `(tactic|assumption)) <|> do _ ← applyFirst cfg lemmas)

-- FIXME: Is there a nicer way to obtain `assumption` as a `TacticM Unit`,
-- rather than ``(evalTactic $ ← `(tactic|assumption))``?

/--
`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively
applying the list of lemmas `[l₁, l₂, ...]` or by calling `assumption`.
If `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.

You may include attributes amongst the lemmas:
`apply_rules` will include all lemmas marked with these attributes.

You can bound the iteration depth using the syntax `apply_rules lemmas n`.
The default bound is 50.

You can pass a further configuration `cfg : ApplyConfig` via the syntax `apply_rules cfg lemmas n`.

Unlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies
a lemma from the list until it gets stuck.

TODO: add support for attributes
TODO: copy the other tests/examples from Lean 3
-/
elab (name := applyRulesElab)
  "apply_rules" cfg:(config)? " [" lemmas:term,* "]" n:(ppSpace num)? : tactic =>
do
  let cfg ← cfg.mapM (unsafe evalTerm ApplyConfig (mkConst ``ApplyConfig) ·)
  let lemmas := lemmas.getElems.toList.map (elabTermForApply ·.raw)
  applyRules (n.map (·.getNat) |>.getD 50) (cfg.getD {}) lemmas
