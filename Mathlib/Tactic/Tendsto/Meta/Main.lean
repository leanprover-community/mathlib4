/-
Copyright (c) 2025 Vasilii Nesterov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Vasilii Nesterov
-/
import Mathlib.Tactic.Tendsto.Multiseries
import Mathlib.Tactic.Tendsto.Lemmas
import Mathlib.Tactic.Tendsto.Meta.Trimming
import Mathlib.Tactic.Tendsto.Meta.LeadingTerm

/-!
# TODO
-/

open Filter Topology Asymptotics TendstoTactic Stream'.Seq ElimDestruct

open Lean Elab Meta Tactic Qq

namespace TendstoTactic

theorem basis_wo : WellFormedBasis [fun (x : ‚Ñù) ‚Ü¶ x] := by
  simp [WellFormedBasis]
  exact fun _ a ‚Ü¶ a

lemma proveLastExpZero_aux {x y : ‚Ñù} {z : Option ‚Ñù} (hx : z = .some x) (hy : z = .some y)
    (hy0 : y = 0) : x = 0 := by
  aesop

partial def proveLastExpZero (li : Q(List ‚Ñù)) : TacticM <| Option <|
    Q(‚àÄ a, List.getLast? $li = .some a ‚Üí a = 0) := do
  let .some last ‚Üê getLast li | return .none
  let .zero h_zero := ‚Üê compareReal last | return .none
  let h_eq : Q(List.getLast? $li = .some $last) ‚Üê mkFreshExprMVar q(List.getLast? $li = .some $last)
  let res ‚Üê evalTacticAt (‚Üê `(tactic| rfl)) h_eq.mvarId!
  if !res.isEmpty then
    panic! "proveLastExpZero: unexpected result of rfl"
  return .some q(fun _ ha ‚Ü¶ proveLastExpZero_aux ha $h_eq $h_zero)

partial def getBasisExtension (basis basis' : Q(Basis)) : MetaM (Q(BasisExtension $basis)) := do
  match basis, basis' with
  | ~q(List.nil), ~q(List.nil) => return q(BasisExtension.nil)
  | ~q(List.cons $basis_hd $basis_tl), ~q(List.nil) => panic! "getBasisExtension: short basis"
  | ~q(List.nil), ~q(List.cons $basis_hd' $basis_tl') =>
    let ex ‚Üê getBasisExtension q([]) basis_tl'
    return q(BasisExtension.insert $basis_hd' $ex)
  | ~q(List.cons $basis_hd $basis_tl), ~q(List.cons $basis_hd' $basis_tl') =>
    if basis_hd == basis_hd' then
      -- they must be just equal. Maybe need to use isDefEq with reducible transparency?
      let ex ‚Üê getBasisExtension basis_tl basis_tl'
      return q(BasisExtension.keep $basis_hd $ex)
    else
      let ex ‚Üê getBasisExtension basis basis_tl'
      return q(BasisExtension.insert $basis_hd' $ex)

structure BasisState where
  basis : Q(Basis)
  logBasis : Q(LogBasis $basis)
  h_basis : Q(WellFormedBasis $basis)
  n_id : Q(Fin (List.length $basis))

abbrev BasisM := StateT BasisState TacticM

example (n m : ‚Ñï) (h : n < m) : n < m + 1 := by exact Nat.lt_add_right 1 h
#check Fin.prop

partial def createMSImp (body : Expr) : BasisM MS := do
  if body.isBVar then
    if body.bvarIdx! != 0 then
      throwError "Unexpected bvarIdx in createMS: expected 0"
    return MS.monomial (‚Üê get).basis (‚Üê get).logBasis (‚Üê get).n_id (‚Üê get).h_basis
  match body.getAppFnArgs with
  | (``Neg.neg, #[_, _, arg]) => return MS.neg (‚Üê createMSImp arg)
  | (``HAdd.hAdd, #[_, _, _, _, arg1, arg2]) =>
    let ms1 ‚Üê createMSImp arg1
    let ms2 ‚Üê createMSImp arg2
    if ms1.basis != ms2.basis then
      let ex ‚Üê getBasisExtension ms1.basis ms2.basis
      let ms1' ‚Üê ms1.updateBasis ex ms2.logBasis ms2.h_basis
      return MS.add ms1' ms2 ‚ü®‚ü©
    else
      return MS.add ms1 ms2 ‚ü®‚ü©
  | (``HSub.hSub, #[_, _, _, _, arg1, arg2]) =>
    let ms1 ‚Üê createMSImp arg1
    let ms2 ‚Üê createMSImp arg2
    if ms1.basis != ms2.basis then
      let ex ‚Üê getBasisExtension ms1.basis ms2.basis
      let ms1' ‚Üê ms1.updateBasis ex ms2.logBasis ms2.h_basis
      return MS.sub ms1' ms2 ‚ü®‚ü©
    else
      return MS.sub ms1 ms2 ‚ü®‚ü©
  | (``HMul.hMul, #[_, _, _, _, arg1, arg2]) =>
    let ms1 ‚Üê createMSImp arg1
    let ms2 ‚Üê createMSImp arg2
    if ms1.basis != ms2.basis then
      let ex ‚Üê getBasisExtension ms1.basis ms2.basis
      let ms1' ‚Üê ms1.updateBasis ex ms2.logBasis ms2.h_basis
      return MS.mul ms1' ms2 ‚ü®‚ü©
    else
      return MS.mul ms1 ms2 ‚ü®‚ü©
  | (``Inv.inv, #[_, _, arg]) =>
    let ‚ü®ms, h_trimmed‚ü© ‚Üê trimMS (‚Üê createMSImp arg)
    return MS.inv ms h_trimmed
  | (``HDiv.hDiv, #[_, _, _, _, arg1, arg2]) =>
    let ms1 ‚Üê createMSImp arg1
    let ‚ü®ms2, h_trimmed‚ü© ‚Üê trimMS (‚Üê createMSImp arg2)
    if ms1.basis != ms2.basis then
      let ex ‚Üê getBasisExtension ms1.basis ms2.basis
      let ms1' ‚Üê ms1.updateBasis ex ms2.logBasis ms2.h_basis
      return MS.div ms1' ms2 h_trimmed ‚ü®‚ü©
    else
      return MS.div ms1 ms2 h_trimmed ‚ü®‚ü©
  | (``HPow.hPow, #[_, t, _, _, arg, exp]) =>
    let ‚ü®ms, h_trimmed‚ü© ‚Üê trimMS (‚Üê createMSImp arg)
    if t == q(‚Ñï) then
      return MS.npow ms exp h_trimmed
    else if t == q(‚Ñ§) then
      return MS.zpow ms exp h_trimmed
    else if t == q(‚Ñù) then
      let .some h_pos ‚Üê getLeadingTermCoefPos ms.val
        | throwError f!"Cannot prove that argument of rpow is eventually positive: {‚Üê ppExpr arg}"
      return MS.rpow ms exp h_trimmed h_pos
    else
      throwError f!"Unexpected type in pow: {‚Üê ppExpr t}. Only ‚Ñï, ‚Ñ§ and ‚Ñù are supported."
  | (``Real.log, #[arg]) =>
    -- dbg_trace "log"
    let ‚ü®ms, h_trimmed‚ü© ‚Üê trimMS (‚Üê createMSImp arg)
    let ‚ü®leading, h_leading_eq‚ü© ‚Üê getLeadingTermWithProof ms.val
    let ~q(‚ü®$coef, $exps‚ü©) := leading | panic! "Unexpected leading in computeTendsto"
    let .some h_pos ‚Üê getLeadingTermCoefPos ms.val
      | throwError f!"Cannot prove that argument of log is eventually positive: {‚Üê ppExpr arg}"
    match ‚Üê proveLastExpZero exps with
    | .some h_last => return MS.log ms h_trimmed h_pos h_last
    | .none =>
      let kek ‚Üê ms.insertLastLog
      -- dbg_trace (‚Üê ppExpr kek.basis)
      let ‚ü®ms, h_trimmed‚ü© ‚Üê trimMS kek
      let ‚ü®leading, h_leading_eq‚ü© ‚Üê getLeadingTermWithProof ms.val
      let ~q(‚ü®$coef, $exps‚ü©) := leading | panic! "Unexpected leading in computeTendsto"
      -- TODO: prove h_pos' from h_pos
      let .some h_pos ‚Üê getLeadingTermCoefPos ms.val
        | panic! s!"Cannot prove that argument of log is eventually positive: {‚Üê ppExpr arg}"
      let .some h_last ‚Üê proveLastExpZero exps | panic! "Unexpected last exp in log"
      -- dbg_trace "basis after update {‚Üê ppExpr ms.basis}"
      -- dbg_trace "h_basis after update {‚Üê ppExpr (‚Üê inferType ms.h_basis)}"
      -- haveI : List.length $((‚Üê get).basis) =Q List.length $ms.basis := ‚ü®‚ü©
      let new_n_id ‚Üê mkAppM ``Fin.castSucc #[(‚Üê get).n_id]
      StateT.set {
        basis := ms.basis
        logBasis := ms.logBasis
        h_basis := ms.h_basis
        n_id := new_n_id
          --q(Fin.castSucc $((‚Üê get).n_id))
      }
      return MS.log ms h_trimmed h_pos h_last
  | _ =>
    if body.hasLooseBVars then
      throwError f!"Unsupported body in createMS: {body}"
    else
      return MS.const (‚Üê get).basis (‚Üê get).logBasis body (‚Üê get).h_basis

def createMS (body : Expr) : TacticM MS := do
  return (‚Üê (createMSImp body).run {
    basis := q([fun (x : ‚Ñù) ‚Ü¶ x])
    logBasis := q(LogBasis.single _)
    h_basis := q(basis_wo)
    n_id := q(‚ü®0, by simp‚ü©)
  }).fst

def computeTendsto (f : Q(‚Ñù ‚Üí ‚Ñù)) :
    TacticM ((limit : Q(Filter ‚Ñù)) √ó Q(Tendsto $f atTop $limit)) := do
  match f with
  | .lam _ _ b _ =>
    let ms ‚Üê createMS b
    -- dbg_trace f!"ms created: {‚Üê ppExpr ms.val}"
    let ‚ü®ms_trimmed, h_trimmed‚ü© ‚Üê trimPartialMS ms
    -- dbg_trace "trimmed"
    let hf_eq ‚Üê mkFreshExprMVarQ q($ms.f = $f)
    hf_eq.mvarId!.applyRfl

    let ~q(List.cons $basis_hd $basis_tl) := ms_trimmed.basis
      | throwError "Unexpected basis in computeTendsto"
    -- I don't know how to avoid Expr here.
    let h_tendsto : Expr ‚Üê match ms_trimmed.val with
    | ~q(PreMS.nil) =>
      pure (q(PreMS.nil_tendsto_zero $ms_trimmed.h_approx) : Expr)
    | ~q(PreMS.cons $hd $tl) =>
      let ‚ü®leading, h_leading_eq‚ü© ‚Üê getLeadingTermWithProof ms_trimmed.val
      let ~q(‚ü®$coef, $exps‚ü©) := leading | panic! "Unexpected leading in computeTendsto"
      let h_tendsto ‚Üê match ‚Üê getFirstIs exps with
      | .pos h_exps =>
        match ‚Üê compareReal coef with
        | .neg h_coef =>
          pure (q(PreMS.tendsto_bot_of_FirstIsPos $ms_trimmed.h_wo $ms_trimmed.h_approx
            $h_trimmed.get! $ms_trimmed.h_basis $h_leading_eq $h_exps $h_coef) : Expr)
        | .pos h_coef =>
          pure (q(PreMS.tendsto_top_of_FirstIsPos $ms_trimmed.h_wo $ms_trimmed.h_approx
            $h_trimmed.get! $ms_trimmed.h_basis $h_leading_eq $h_exps $h_coef) : Expr)
        | .zero _ => panic! "Unexpected zero coef with FirstIsPos"
      | .neg h_exps =>
        pure (q(PreMS.tendsto_zero_of_FirstIsNeg $ms_trimmed.h_wo $ms_trimmed.h_approx
          $h_leading_eq $h_exps) : Expr)
      | .zero h_exps =>
        pure (q(PreMS.tendsto_const_of_AllZero $ms_trimmed.h_wo $ms_trimmed.h_approx
          $h_trimmed.get! $ms_trimmed.h_basis $h_leading_eq $h_exps) : Expr)
    | _ => panic! "Unexpected result of trimMS"

    let ‚ü®0, t, h_tendsto‚ü© ‚Üê inferTypeQ h_tendsto
      | panic! "Unexpected h_tendsto's universe level"
    let ~q(@Tendsto ‚Ñù ‚Ñù $g atTop $limit) := t | panic! "Unexpected h_tendsto's type"
    haveI' : $g =Q $ms.f := ‚ü®‚ü©
    -- let res := h_tendsto -- also works, decide later
    let res := q(Eq.subst (motive := fun x ‚Ü¶ Tendsto x atTop $limit) $hf_eq $h_tendsto)
    return ‚ü®limit, res‚ü©
  | _ => throwError "Function should be lambda"

def convertFilter (f : Q(‚Ñù ‚Üí ‚Ñù)) (limit : Q(Filter ‚Ñù)) : MetaM (Option Name √ó List (Q(‚Ñù ‚Üí ‚Ñù))) := do
  match limit with
  | ~q(atTop) => return (.none, [f])
  | ~q(atBot) => return (.some ``tendsto_bot_of_tendsto_top, [q(fun x ‚Ü¶ $f (-x))])
  | ~q(ùìù[>] $c) => return (.some ``tendsto_nhds_right_of_tendsto_top, [q(fun x ‚Ü¶ $f ($c + x‚Åª¬π))])
  | ~q(ùìù[<] $c) => return (.some ``tendsto_nhds_left_of_tendsto_top, [q(fun x ‚Ü¶ $f ($c - x‚Åª¬π))])
  | ~q(ùìù[‚â†] $c) => return (.some ``tendsto_nhds_punctured_of_tendsto_top,
    [q(fun x ‚Ü¶ $f ($c - x‚Åª¬π)), q(fun x ‚Ü¶ $f ($c + x‚Åª¬π))])
  | _ => throwError f!"Unexpected source filter: {‚Üê ppExpr limit}"

elab "compute_asymptotics" : tactic =>
  Lean.Elab.Tactic.withMainContext do
    let target : Q(Prop) ‚Üê getMainTarget
    let ~q(@Filter.Tendsto ‚Ñù ‚Ñù $f $filter $targetLimit) := target
      | throwError "The goal must me in the form Tendsto (fun x ‚Ü¶ ...) ... ..."
    let (convertLemma?, convertedFs) ‚Üê convertFilter f filter
    let proofs : List (Expr) ‚Üê convertedFs.mapM fun f => do
      let ‚ü®1, fType, f‚ü© ‚Üê inferTypeQ f
        | throwError "Unexpected universe level of function in compute_asymptotics"
      let ~q(‚Ñù ‚Üí ‚Ñù) := fType | throwError "Only real functions are supported"
      let ‚ü®limit, h_tendsto‚ü© ‚Üê computeTendsto f
      if !(‚Üê isDefEq limit targetLimit) then
        match targetLimit, limit with
        | ~q(ùìù $a), ~q(ùìù $b) =>
          let h_eq : Q($b = $a) ‚Üê mkFreshExprMVarQ q($b = $a)
          let extraGoals ‚Üê evalTacticAt (‚Üê `(tactic| try norm_num)) h_eq.mvarId!
          appendGoals extraGoals
          pure q(Eq.subst
            (motive := fun x ‚Ü¶ Filter.Tendsto $f atTop (ùìù x)) $h_eq $h_tendsto)
        | _ =>
          throwError m!"The tactic proved that the function tends to {‚Üê ppExpr limit},
            not {‚Üê ppExpr targetLimit}."
      else
        pure h_tendsto
    let pf ‚Üê match convertLemma? with
    | .none => pure proofs[0]!
    | .some convertLemma => mkAppM convertLemma (f :: proofs).toArray

    (‚Üê getMainGoal).assign pf

end TendstoTactic
