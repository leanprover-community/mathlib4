/-
Copyright (c) 2025 Vasilii Nesterov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Vasilii Nesterov
-/
import Mathlib.Tactic.Tendsto.Multiseries
import Qq

/-!
# TODO
-/

namespace TendstoTactic.PreMS

open scoped Topology

-- I don't want to define them earlier because I was enjoying Stream'.Seq API available for `nil`
-- and `cons` when proving thing in `Multiseries` folder. On the meta level I need them to work only
-- with multiseries without heavy parsing.

def nil {basis_hd} {basis_tl} : PreMS (basis_hd :: basis_tl) := .nil

def cons {basis_hd} {basis_tl} (hd : (‚Ñù √ó PreMS basis_tl)) (tl : PreMS (basis_hd :: basis_tl)) :
    PreMS (basis_hd :: basis_tl) := .cons hd tl

open Stream'.Seq

theorem nil_of_destruct {basis_hd : ‚Ñù ‚Üí ‚Ñù} {basis_tl : Basis} {ms : PreMS (basis_hd :: basis_tl)}
    (h_destruct : destruct ms = .none) :
    ms = PreMS.nil :=
  Stream'.Seq.destruct_eq_none h_destruct

theorem cons_of_destruct {basis_hd : ‚Ñù ‚Üí ‚Ñù} {basis_tl : Basis} {ms : PreMS (basis_hd :: basis_tl)}
    {hd : ‚Ñù √ó PreMS basis_tl} {tl : PreMS (basis_hd :: basis_tl)}
    (h_destruct : destruct ms = .some (hd, tl)) :
    ms = PreMS.cons hd tl :=
  Stream'.Seq.destruct_eq_cons h_destruct

open Filter in
lemma nil_tendsto_zero {basis_hd : ‚Ñù ‚Üí ‚Ñù} {basis_tl : Basis} {f : ‚Ñù ‚Üí ‚Ñù}
    (h : PreMS.Approximates (@PreMS.nil basis_hd basis_tl) f) : Tendsto f atTop (ùìù 0) := by
  apply PreMS.Approximates_nil at h
  exact h.tendsto

end PreMS

open Lean Elab Meta Qq

partial def computeLength (b : Q(Basis)) : MetaM Nat := do
  match b with
  | ~q(List.nil) => return 0
  | ~q(List.cons $basis_hd $basis_tl) => return 1 + (‚Üê computeLength basis_tl)
  | _ => panic! s!"computeLength: unexpected basis: {‚Üê ppExpr b}"

def replicate {Œ± : Q(Type)} (n : Nat) (x : Q($Œ±)) : MetaM Q(List $Œ±) := do
  match n with
  | 0 => return q(List.nil)
  | n + 1 =>
    let tl ‚Üê replicate n x
    return q(List.cons $x $tl)

partial def reduceAppend {Œ± : Q(Type)} (left right : Q(List $Œ±)) : MetaM Q(List $Œ±) := do
  match left with
  | ~q(List.nil), _ => return right
  | ~q(List.cons $left_hd $left_tl) =>
    let tl ‚Üê reduceAppend left_tl right
    return q(List.cons $left_hd $tl)
  | _ => panic! s!"Unexpected left in reduceAppend: {‚Üê ppExpr left}"

mutual

  partial def reduceBasisExtension {basis : Q(Basis)} (ex : Q(BasisExtension $basis)) :
      MetaM Q(Basis) := do
    match basis, ex with
    | ~q(List.nil), ~q(BasisExtension.nil) => return q(List.nil)
    | ~q(List.cons $basis_hd $basis_tl), ~q(BasisExtension.keep _ $ex_tl) =>
      let tl ‚Üê reduceBasisExtension ex_tl
      return q(List.cons $basis_hd $tl)
    | _, ~q(BasisExtension.insert $f $ex_tl) =>
      let tl ‚Üê reduceBasisExtension ex_tl
      return q(List.cons $f $tl)
    | _ => panic! s!"Unexpected ex in reduceBasisExtension: {‚Üê ppExpr ex}"

  partial def reduceBasis (basis : Q(Basis)) : MetaM Q(Basis) := do
    match basis with
    | ~q(List.nil) => return q(List.nil)
    | ~q(List.cons $hd $tl) =>
      let tl' ‚Üê reduceBasis tl
      return q(List.cons $hd $tl')
    | ~q(@BasisExtension.getBasis $basis' $ex) =>
      let basis'' ‚Üê reduceBasis basis'
      haveI : $basis =Q $basis' := ‚ü®‚ü©
      return ‚Üê @reduceBasisExtension basis'' ex
    | ~q($left ++ $right) =>
      let left' ‚Üê reduceBasis left
      let right' ‚Üê reduceBasis right
      return ‚Üê reduceAppend (Œ± := q(‚Ñù ‚Üí ‚Ñù)) left' right'

end

-- partial def reduceLogBasis {basis : Q(Basis)} (logBasis : Q(LogBasis $basis)) :
--     MetaM Q(LogBasis $basis) := do
--   let ~q(List.cons $basis_hd $basis_tl) := basis | return logBasis
--   match logBasis with

end TendstoTactic
