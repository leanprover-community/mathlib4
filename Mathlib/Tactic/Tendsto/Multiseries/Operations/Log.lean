/-
Copyright (c) 2025 Vasilii Nesterov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Vasilii Nesterov
-/
import Mathlib.Analysis.SpecialFunctions.Complex.Analytic
import Mathlib.Tactic.Tendsto.Multiseries.Operations.Inv
import Mathlib.Tactic.Tendsto.Multiseries.LogBasis

/-!
# Logarithm of Multiseries

-/

open Filter Asymptotics Topology

namespace TendstoTactic

namespace PreMS

open LazySeries Stream' Seq

-- log (1 + x) = x - x^2/2 + x^3/3 - ...

noncomputable def logSeries : LazySeries :=
  ofFn fun n ‚Ü¶ -(-1 : ‚Ñù)^n / n

theorem Real.log_hasFPowerSeriesAt : HasFPowerSeriesAt (fun t ‚Ü¶ Real.log (1 + t))
    (.ofScalars ‚Ñù (fun n ‚Ü¶ -(-1 : ‚Ñù)^n / n)) 0 := by
  suffices HasFPowerSeriesAt Real.log (.ofScalars ‚Ñù (fun n ‚Ü¶ -(-1 : ‚Ñù)^n / n)) 1 by
    rw [show (0 : ‚Ñù) = 1 + (-1) by simp]
    conv => arg 1; ext t; rw [show 1 + t = t - (-1) by ring]
    exact HasFPowerSeriesAt.comp_sub this _
  suffices ((FormalMultilinearSeries.ofScalars ‚Ñù (fun n ‚Ü¶ -(-1 : ‚Ñù)^n / n)) =
      FormalMultilinearSeries.ofScalars ‚Ñù
        (fun n ‚Ü¶ iteratedDeriv n Real.log 1 / (n.factorial : ‚Ñù))) by
    convert AnalyticAt.hasFPowerSeriesAt _ using 1 <;> try infer_instance
    exact analyticAt_log (by simp)
  ext n v
  simp
  left
  clear v
  cases' n with n
  ¬∑ simp
  rw [Nat.factorial_succ, pow_succ]
  field_simp
  move_mul [((n : ‚Ñù) + 1)]
  simp
  left
  suffices iteratedDeriv (n + 1) Real.log =
      fun (x : ‚Ñù) ‚Ü¶ (-1 : ‚Ñù) ^ n * n.factorial * x ^ (-(n : ‚Ñ§) - 1) by
    rw [this]
    simp
  induction n with
  | zero =>
    simp
  | succ n ih =>
    simp
    rw [iteratedDeriv_succ, ih]
    ext x
    simp [Nat.factorial_succ, pow_succ]
    ring_nf

theorem logSeries_toFormalMultilinearSeries_eq :
    logSeries.toFormalMultilinearSeries = .ofScalars ‚Ñù (fun n ‚Ü¶ -(-1 : ‚Ñù)^n / n) := by
  simp [toFormalMultilinearSeries]
  suffices logSeries.coeff = (fun (n : ‚Ñï) ‚Ü¶ -(-1 : ‚Ñù)^n / n) by
    rw [this]
  ext n
  simp [LazySeries.coeff, logSeries]

theorem logSeries_analytic : logSeries.analytic := by
  apply analytic_of_HasFPowerSeriesAt
  convert Real.log_hasFPowerSeriesAt
  rw [logSeries_toFormalMultilinearSeries_eq]

theorem logSeries_toFun : logSeries.toFun =·∂†[ùìù 0] (fun t ‚Ü¶ Real.log (1 + t)) := by
  apply toFun_of_HasFPowerSeriesAt
  convert Real.log_hasFPowerSeriesAt
  rw [logSeries_toFormalMultilinearSeries_eq]

-- log (C b^e + F) = log C + e log b + log(1 + C^-1 b^-e F)
-- here we assume that the last exponent is 0
noncomputable def log {basis : Basis}
    (logBasis : LogBasis basis)
    (ms : PreMS basis) :
    PreMS basis :=
  match basis with
  | [] => Real.log ms
  | List.cons _ basis_tl =>
    match destruct ms with
    | none => .nil
    | some ((exp, coef), tl) =>
      match basis_tl with
      | [] => PreMS.add (PreMS.const _ (Real.log coef)) <|
          logSeries.apply (PreMS.mulConst tl coef‚Åª¬π) -- here exp = 0 by assumption
      | List.cons _ _ =>
        let logC := log logBasis.tail coef
        match logBasis with
        | .cons _ _ _ _ log_hd =>
          PreMS.add ((.cons (0, logC.add <| log_hd.mulConst exp) .nil)) <|
            logSeries.apply (mulMonomial tl coef.inv (-exp))

theorem log_WellOrdered {basis : Basis}
    {logBasis : LogBasis basis}
    {ms : PreMS basis}
    (h_logBasis : logBasis.WellFormed)
    (h_last : ‚àÄ x, ms.leadingTerm.exps.getLast? = .some x ‚Üí x = 0)
    (h_wo : ms.WellOrdered)
    :
    (ms.log logBasis).WellOrdered := by
  cases' basis with basis_hd basis_tl
  ¬∑ apply WellOrdered.const
  cases basis_tl with
  | nil =>
    cases' ms with exp coef tl
    ¬∑ simpa [log]
    have h_exp : exp = 0 := by
      simpa [leadingTerm] using h_last
    obtain ‚ü®h_coef_wo, h_comp, h_tl_wo‚ü© := WellOrdered_cons h_wo
    simp [log]
    apply add_WellOrdered const_WellOrdered
    apply apply_WellOrdered
    ¬∑ apply mulConst_WellOrdered h_tl_wo
    ¬∑ simp
      generalize tl.leadingExp = x at h_comp
      cases x
      ¬∑ exact WithBot.bot_lt_coe 0
      ¬∑ simp at h_comp
        norm_cast
        linarith
  | cons basis_tl_hd basis_tl_tl =>
    cases' ms with exp coef tl
    ¬∑ simpa [log]
    obtain ‚ü®h_coef_wo, h_comp, h_tl_wo‚ü© := WellOrdered_cons h_wo
    cases' logBasis with _ _ _ _ logBasis_tl log_hd h_wo h_approx
    unfold log
    simp
    apply add_WellOrdered
    ¬∑ apply WellOrdered.cons
      ¬∑ apply add_WellOrdered
        ¬∑ apply log_WellOrdered (LogBasis.tail_WellFormed h_logBasis) _ h_coef_wo
          intro x h
          specialize h_last x
          unfold leadingTerm at h_last
          simpa [List.getLast?_cons, h] using h_last
        ¬∑ apply mulConst_WellOrdered
          exact h_logBasis.left
      ¬∑ simp [leadingExp]
        exact WithBot.bot_lt_coe 0
      ¬∑ exact WellOrdered.nil
    ¬∑ apply apply_WellOrdered
      ¬∑ apply mulMonomial_WellOrdered h_tl_wo
        exact inv_WellOrdered h_coef_wo
      ¬∑ -- copypaste from above
        simp
        generalize tl.leadingExp = x at h_comp
        cases x
        ¬∑ exact WithBot.bot_lt_coe 0
        ¬∑ simp at h_comp
          norm_cast
          linarith

theorem log_Approximates {basis : Basis} {f : ‚Ñù ‚Üí ‚Ñù}
    {logBasis : LogBasis basis}
    {ms : PreMS basis}
    (h_basis : WellFormedBasis basis)
    (h_logBasis : logBasis.WellFormed)
    (h_wo : ms.WellOrdered)
    (h_approx : ms.Approximates f)
    (h_trimmed : ms.Trimmed)
    (h_pos : 0 < ms.leadingTerm.coef)
    (h_last : ‚àÄ x, ms.leadingTerm.exps.getLast? = .some x ‚Üí x = 0)
    :
    (ms.log logBasis).Approximates (Real.log ‚àò f) := by
  cases' basis with basis_hd basis_tl
  ¬∑ simp [Approximates] at h_approx
    apply Approximates_of_EventuallyEq (f := Real.log ‚àò (fun _ ‚Ü¶ ms))
    ¬∑ apply EventuallyEq.fun_comp h_approx.symm
    change (log logBasis ms).Approximates (fun x ‚Ü¶ Real.log ms)
    simp [log, Approximates]
  cases basis_tl with
  | nil =>
    cases' ms with exp coef tl
    ¬∑ simp [log]
      apply Approximates_nil at h_approx
      apply Approximates.nil
      trans Real.log ‚àò (fun _ ‚Ü¶ 0)
      ¬∑ apply Filter.EventuallyEq.fun_comp h_approx
      apply EventuallyEq.of_eq
      ext
      simp
    ¬∑ simp [log]
      have h_exp : exp = 0 := by
        simpa [leadingTerm] using h_last
      subst h_exp
      obtain ‚ü®fC, h_coef, h_maj, h_tl‚ü© := Approximates_cons h_approx
      obtain ‚ü®h_coef_wo, h_comp, h_tl_wo‚ü© := WellOrdered_cons h_wo
      simp [Approximates] at h_coef
      -- f = basis_hd t ^ exp * coef + (f t - basis_hd t ^ exp * coef)
      --   = basis_hd t ^ exp * coef * (1 + basis_hd t ^ (-exp) * coef‚Åª¬π *
      --                                       (f t - basis_hd t ^ exp * coef))
      -- log f = log coef + exp * log basis_hd + log (1 + basis_hd t ^ (-exp) * coef‚Åª¬π *
      --                                       (f t - basis_hd t ^ exp * coef))
      -- here exp = 0, so
      -- log f = log coef + log (1 + coef‚Åª¬π * (f t - coef))
      have h_tendsto_zero : Tendsto (fun t ‚Ü¶ f t - coef) atTop (ùìù 0) := by
        apply neg_leadingExp_tendsto_zero h_comp
        apply Approximates_of_EventuallyEq _ h_tl
        apply Eventually.mono h_coef
        intro x hx
        simpa using hx
      apply Approximates_of_EventuallyEq
          (f := fun t ‚Ü¶ Real.log coef + Real.log (1 + (f t - coef) * coef‚Åª¬π))
      ¬∑ simp [leadingTerm] at h_pos
        rw [NormedAddCommGroup.tendsto_nhds_zero] at h_tendsto_zero
        specialize h_tendsto_zero (coef * 2‚Åª¬π) (by positivity)
        calc
          _ =·∂†[atTop] (fun t ‚Ü¶ Real.log (coef * (1 + (f t - coef) * coef‚Åª¬π))) := by
            apply Eventually.mono h_tendsto_zero
            intro x hx
            simp
            rw [Real.log_mul h_pos.ne']
            intro h
            field_simp at h
            simp [h, abs_of_pos h_pos] at hx
            apply one_lt_of_lt_mul_left‚ÇÄ at hx
            ¬∑ norm_num at hx
            ¬∑ exact h_pos.le
          _ = _ := by
            ext x
            simp
            congr
            field_simp
      apply add_Approximates
      ¬∑ exact const_Approximates h_basis
      apply Approximates_of_EventuallyEq (f := logSeries.toFun ‚àò fun t ‚Ü¶ (f t - coef) * coef‚Åª¬π)
      ¬∑ have := Filter.EventuallyEq.comp_tendsto logSeries_toFun
          (by simpa using h_tendsto_zero.mul_const coef‚Åª¬π)
        apply Eventually.mono this
        simp
      apply apply_Approximates logSeries_analytic h_basis
      ¬∑ exact mulConst_WellOrdered h_tl_wo
      ¬∑ simp
        generalize tl.leadingExp = x at h_comp
        cases x
        ¬∑ exact WithBot.bot_lt_coe 0
        ¬∑ simp at h_comp
          norm_cast
      apply mulConst_Approximates'
      apply Approximates_of_EventuallyEq _ h_tl
      simp
      apply Eventually.mono h_coef
      intro x hx
      simpa using hx
  | cons basis_tl_hd basis_tl_tl =>
    cases' ms with exp coef tl
    ¬∑ simp [log]
      apply Approximates_nil at h_approx
      apply Approximates.nil
      trans Real.log ‚àò (fun _ ‚Ü¶ 0)
      ¬∑ apply Filter.EventuallyEq.fun_comp h_approx
      apply EventuallyEq.of_eq
      ext
      simp
    obtain ‚ü®h_coef_wo, h_comp, h_tl_wo‚ü© := WellOrdered_cons h_wo
    obtain ‚ü®h_coef_trimmed, h_coef_ne_zero‚ü© := Trimmed_cons h_trimmed
    obtain ‚ü®fC, h_coef, h_maj, h_tl‚ü© := Approximates_cons h_approx
    cases' logBasis with _ _ _ _ logBasis_tl log_hd h_wo h_log_approx
    unfold log
    simp
    have h_f_pos : ‚àÄ·∂† t in atTop, 0 < f t :=
      eventually_pos_of_coef_pos h_pos h_wo h_approx h_trimmed h_basis
    have h_fC_pos : ‚àÄ·∂† t in atTop, 0 < fC t := by
      unfold leadingTerm at h_pos
      simp at h_pos
      apply eventually_pos_of_coef_pos h_pos h_coef_wo h_coef h_coef_trimmed h_basis.tail
    have h_basis_hd_pos : ‚àÄ·∂† t in atTop, 0 < basis_hd t := basis_head_eventually_pos h_basis
    apply Approximates_of_EventuallyEq
        (f := fun t ‚Ü¶ (Real.log (fC t) + Real.log (basis_hd t) * exp) +
          Real.log (1 + basis_hd t ^ (-exp) * (fC t)‚Åª¬π * (f t - (basis_hd t) ^ exp * fC t)))
    ¬∑ apply Eventually.mono (h_f_pos.and (h_fC_pos.and (h_basis_hd_pos)))
      intro x ‚ü®h_f, h_fC, h_basis_hd‚ü©
      simp
      rw [mul_comm, ‚Üê Real.log_rpow, ‚Üê Real.log_mul, ‚Üê Real.log_mul]
      rotate_left
      ¬∑ positivity
      ¬∑ rw [mul_sub]
        ring_nf
        move_mul [‚Üê basis_hd x ^ exp]
        rw [‚Üê Real.rpow_add h_basis_hd]
        simp
        rw [mul_inv_cancel‚ÇÄ h_fC.ne']
        simp
        constructorm* _ ‚àß _ <;> positivity
      ¬∑ positivity
      ¬∑ positivity
      ¬∑ assumption
      congr
      rw [mul_add]
      move_mul [‚Üê (fC x)‚Åª¬π]
      simp [inv_mul_cancel‚ÇÄ h_fC.ne', ‚Üê Real.rpow_add h_basis_hd]
      ring
    apply add_Approximates
    ¬∑ apply Approximates.cons (fC := fun t ‚Ü¶ Real.log (fC t) + Real.log (basis_hd t) * exp)
      ¬∑ apply add_Approximates
        ¬∑ apply log_Approximates h_basis.tail (LogBasis.tail_WellFormed h_logBasis) h_coef_wo
            h_coef h_coef_trimmed
          ¬∑ rwa [leadingTerm_cons_coef] at h_pos
          intro x h
          specialize h_last x
          unfold leadingTerm at h_last
          simp at h_last
          simpa [List.getLast?_cons, h] using h_last
        ¬∑ apply mulConst_Approximates'
          simp [LogBasis.WellFormed] at h_logBasis
          exact h_logBasis.right.left
      ¬∑ rw [show (0 : ‚Ñù) = 0 ‚äî 0 by simp]
        apply add_majorated
        ¬∑ have := PreMS.Approximates_coef_majorated_head h_coef h_basis
          unfold leadingTerm at h_pos h_last
          simp at h_pos h_last
          replace h_last : ‚àÄ (x : ‚Ñù), coef.leadingTerm.exps.getLast? = some x ‚Üí x = 0 := by
            intro x h
            apply h_last
            rw [‚Üê h]
            rw [List.getLast?_eq_getLast _ (leadingTerm_ne_nil),
              List.getLast?_eq_getLast _ (by simp)]
            simp
            rw [List.getLast_cons]
          have := log_Approximates (ms := coef) (f := fC) h_basis.tail
            (LogBasis.tail_WellFormed h_logBasis) h_coef_wo h_coef h_coef_trimmed h_pos
            h_last
          exact PreMS.Approximates_coef_majorated_head this h_basis
        ¬∑ apply mul_const_majorated
          simp [majorated]
          intro exp' h_exp'
          change (Real.log ‚àò basis_hd) =o[atTop] ((fun t ‚Ü¶ t ^ exp') ‚àò basis_hd)
          apply Asymptotics.IsLittleO.comp_tendsto (l := atTop)
          swap
          ¬∑ apply h_basis.right
            simp
          exact isLittleO_log_rpow_atTop h_exp'
      ¬∑ apply Approximates.nil
        simp
        rfl
    ¬∑ have h_tendsto_zero : Tendsto (fun t ‚Ü¶ (fC t)‚Åª¬π * basis_hd t ^ (-exp) *
          (f t - basis_hd t ^ exp * fC t)) atTop (ùìù 0) := by
        apply Tendsto.congr' (f‚ÇÅ := fun t ‚Ü¶ fC‚Åª¬π t * basis_hd t ^ (-exp) * f t - 1)
        ¬∑ apply Eventually.mono (h_fC_pos.and h_basis_hd_pos)
          intro t ‚ü®h_fC, h_basis_hd‚ü©
          simp [mul_sub]
          ring_nf
          simp [mul_inv_cancel‚ÇÄ h_fC.ne', ‚Üê Real.rpow_add h_basis_hd]
        rw [show (0 : ‚Ñù) = 1 - 1 by simp]
        apply Tendsto.sub_const
        apply Tendsto.congr' (f‚ÇÅ := f / (fun k ‚Ü¶ fC k * basis_hd k ^ (exp)))
        ¬∑ simp only [EventuallyEq]
          apply h_basis_hd_pos.mono
          intro t h_basis_hd_pos
          simp [Real.rpow_neg h_basis_hd_pos.le]
          ring
        rw [‚Üê isEquivalent_iff_tendsto_one]
        conv => rhs; ext t; rw [mul_comm]
        apply IsEquivalent_coef h_coef h_coef_wo h_coef_trimmed h_coef_ne_zero h_tl h_comp h_basis
        apply (h_fC_pos.and h_basis_hd_pos).mono
        intro t ‚ü®h_fC_pos, h_basis_hd_pos‚ü©
        simp
        constructor
        ¬∑ exact h_fC_pos.ne'
        ¬∑ rw [Real.rpow_eq_zero_iff_of_nonneg]
          ¬∑ push_neg
            intro h
            simp [h] at h_basis_hd_pos
          ¬∑ exact h_basis_hd_pos.le
      apply Approximates_of_EventuallyEq
        (f := logSeries.toFun ‚àò fun t ‚Ü¶ (fC t)‚Åª¬π * basis_hd t ^ (-exp) *
          (f t - basis_hd t ^ exp * fC t))
      ¬∑ have := Filter.EventuallyEq.comp_tendsto logSeries_toFun h_tendsto_zero
        apply Eventually.mono this
        intro t ht
        simp at ht
        simp [ht]
        congr 3
        ring
      apply apply_Approximates logSeries_analytic h_basis
      ¬∑ apply mulMonomial_WellOrdered h_tl_wo
        exact inv_WellOrdered h_coef_wo
      ¬∑ simp
        generalize tl.leadingExp = x at h_comp
        cases x
        ¬∑ exact WithBot.bot_lt_coe 0
        ¬∑ simp at h_comp
          norm_cast
          linarith
      apply mulMonomial_Approximates h_basis h_tl
      exact inv_Approximates h_basis.tail h_coef_wo h_coef h_coef_trimmed

end PreMS

end TendstoTactic
