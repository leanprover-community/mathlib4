/-
Copyright (c) 2024 Yuma Mizuno. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yuma Mizuno
-/
import Lean.Meta.AppBuilder
import Mathlib.Tactic.CategoryTheory.Coherence.Datatypes

/-!
# Normalization of 2-morphisms in bicategories

This file provides a function that normalizes 2-morphisms in bicategories. The function also
used to normalize morphisms in monoidal categories. This is used in the string diagram widget given
in `Mathlib/Tactic/StringDiagram.lean`, as well as `monoidal` and `bicategory` tactics.

We say that the 2-morphism `Œ∑` in a bicategory is in normal form if
1. `Œ∑` is of the form `Œ±‚ÇÄ ‚â´ Œ∑‚ÇÄ ‚â´ Œ±‚ÇÅ ‚â´ Œ∑‚ÇÅ ‚â´ ... Œ±‚Çò ‚â´ Œ∑‚Çò ‚â´ Œ±‚Çò‚Çä‚ÇÅ` where each `Œ±·µ¢` is a
  structural 2-morphism (consisting of associators and unitors),
2. each `Œ∑·µ¢` is a non-structural 2-morphism of the form `f‚ÇÅ ‚óÅ ... ‚óÅ f‚Çô ‚óÅ Œ∏`, and
3. `Œ∏` is of the form `Œπ‚ÇÅ ‚ó´ ... ‚ó´ Œπ‚Çó`, and
4. each `Œπ·µ¢` is of the form `Œ∫ ‚ñ∑ g‚ÇÅ ‚ñ∑ ... ‚ñ∑ g‚Çñ`.

Note that the horizontal composition `‚ó´` is not currently defined for bicategories. In the monoidal
category setting, the horizontal composition is defined as the `tensorHom`, denoted by `‚äó`.

Note that the structural morphisms `Œ±·µ¢` are not necessarily normalized, as the main purpose
is to get a list of the non-structural morphisms out.

Currently, the primary application of the normalization tactic in mind is drawing string diagrams,
which are graphical representations of morphisms in monoidal categories, in the infoview. When
drawing string diagrams, we often ignore associators and unitors (i.e., drawing morphisms in
strict monoidal categories). On the other hand, in Lean, it is considered difficult to formalize
the concept of strict monoidal categories due to the feature of dependent type theory. The
normalization tactic can remove associators and unitors from the expression, extracting the
necessary data for drawing string diagrams.

The string diagrams widget is to use Penrose (https://github.com/penrose) via ProofWidget.
However, it should be noted that the normalization procedure in this file does not rely on specific
settings, allowing for broader application. Future plans include the following. At least I (Yuma)
would like to work on these in the future, but it might not be immediate. If anyone is interested,
I would be happy to discuss.

- Currently, the string diagrams widget only do drawing. It would be better they also generate
  proofs. That is, by manipulating the string diagrams displayed in the infoview with a mouse to
  generate proofs. In https://github.com/leanprover-community/mathlib4/pull/10581,
  the string diagram widget only uses the morphisms generated by the
  normalization tactic and does not use proof terms ensuring that the original morphism and the
  normalized morphism are equal. Proof terms will be necessary for proof generation.

- There is also the possibility of using homotopy.io (https://github.com/homotopy-io), a graphical
  proof assistant for category theory, from Lean. At this point, I have very few ideas regarding
  this approach.

## Main definitions
- `Tactic.BicategoryLike.eval`: Given a Lean expression `e` that represents a morphism in a monoidal
category, this function returns a pair of `‚ü®e', pf‚ü©` where `e'` is the normalized expression of `e`
and `pf` is a proof that `e = e'`.

-/

open Lean Meta

namespace Mathlib.Tactic.BicategoryLike

section

/-- Expressions of the form `Œ∑ ‚ñ∑ f‚ÇÅ ‚ñ∑ ... ‚ñ∑ f‚Çô`. -/
inductive WhiskerRight : Type
  /-- Construct the expression for an atomic 2-morphism. -/
  | of (Œ∑ : Atom) : WhiskerRight
  /-- Construct the expression for `Œ∑ ‚ñ∑ f`. -/
  | whisker (e : Mor‚ÇÇ) (Œ∑ : WhiskerRight) (f : Atom‚ÇÅ) : WhiskerRight
  deriving Inhabited

/-- The underlying `Mor‚ÇÇ` term of a `WhiskerRight` term. -/
def WhiskerRight.e : WhiskerRight ‚Üí Mor‚ÇÇ
  | .of Œ∑ => .of Œ∑
  | .whisker e .. => e

/-- Expressions of the form `Œ∑‚ÇÅ ‚äó ... ‚äó Œ∑‚Çô`. -/
inductive HorizontalComp : Type
  | of (Œ∑ : WhiskerRight) : HorizontalComp
  | cons (e : Mor‚ÇÇ) (Œ∑ : WhiskerRight) (Œ∑s : HorizontalComp) :
    HorizontalComp
  deriving Inhabited

/-- The underlying `Mor‚ÇÇ` term of a `HorizontalComp` term. -/
def HorizontalComp.e : HorizontalComp ‚Üí Mor‚ÇÇ
  | .of Œ∑ => Œ∑.e
  | .cons e .. => e

/-- Expressions of the form `f‚ÇÅ ‚óÅ ... ‚óÅ f‚Çô ‚óÅ Œ∑`. -/
inductive WhiskerLeft : Type
  /-- Construct the expression for a right-whiskered 2-morphism. -/
  | of (Œ∑ : HorizontalComp) : WhiskerLeft
  /-- Construct the expression for `f ‚óÅ Œ∑`. -/
  | whisker (e : Mor‚ÇÇ) (f : Atom‚ÇÅ) (Œ∑ : WhiskerLeft) : WhiskerLeft
  deriving Inhabited

/-- The underlying `Mor‚ÇÇ` term of a `WhiskerLeft` term. -/
def WhiskerLeft.e : WhiskerLeft ‚Üí Mor‚ÇÇ
  | .of Œ∑ => Œ∑.e
  | .whisker e .. => e

/-- Whether a given 2-isomorphism is structural or not. -/
def Mor‚ÇÇIso.isStructural (Œ± : Mor‚ÇÇIso) : Bool :=
  match Œ± with
  | .structuralAtom _ => true
  | .comp _ _ _ _ Œ∑ Œ∏ => Œ∑.isStructural && Œ∏.isStructural
  | .whiskerLeft _ _ _ _ Œ∑ => Œ∑.isStructural
  | .whiskerRight _ _ _ Œ∑ _ => Œ∑.isStructural
  | .horizontalComp _ _ _ _ _ Œ∑ Œ∏ => Œ∑.isStructural && Œ∏.isStructural
  | .inv _ _ _ Œ∑ => Œ∑.isStructural
  | .coherenceComp _ _ _ _ _ _ Œ∑ Œ∏ => Œ∑.isStructural && Œ∏.isStructural
  | .of _ => false

/-- Expressions for structural isomorphisms. We do not impose the condition `isStructural` since
it is not needed to write the tactic. -/
abbrev Structural := Mor‚ÇÇIso

/-- Normalized expressions for 2-morphisms. -/
inductive NormalExpr : Type
  /-- Construct the expression for a structural 2-morphism. -/
  | nil (e : Mor‚ÇÇ) (Œ± : Structural) : NormalExpr
  /-- Construct the normalized expression of a 2-morphism `Œ± ‚â´ Œ∑ ‚â´ Œ∑s` recursively. -/
  | cons (e : Mor‚ÇÇ) (Œ± : Structural) (Œ∑ : WhiskerLeft) (Œ∑s : NormalExpr) : NormalExpr
  deriving Inhabited

/-- The underlying `Mor‚ÇÇ` term of a `NormalExpr` term. -/
def NormalExpr.e : NormalExpr ‚Üí Mor‚ÇÇ
  | .nil e .. => e
  | .cons e .. => e

/-- A monad equipped with the ability to construct `WhiskerRight` terms. -/
class MonadWhiskerRight (m : Type ‚Üí Type) where
  /-- The expression for the right whiskering `Œ∑ ‚ñ∑ f`. -/
  whiskerRightM (Œ∑ : WhiskerRight) (f : Atom‚ÇÅ) : m WhiskerRight

/-- A monad equipped with the ability to construct `HorizontalComp` terms. -/
class MonadHorizontalComp (m : Type ‚Üí Type) extends MonadWhiskerRight m where
  /-- The expression for the horizontal composition `Œ∑ ‚ó´ Œ∑s`. -/
  hConsM (Œ∑ : WhiskerRight) (Œ∑s : HorizontalComp) : m HorizontalComp

/-- A monad equipped with the ability to construct `WhiskerLeft` terms. -/
class MonadWhiskerLeft (m : Type ‚Üí Type) extends MonadHorizontalComp m where
  /-- The expression for the left whiskering `f ‚ñ∑ Œ∑`. -/
  whiskerLeftM (f : Atom‚ÇÅ) (Œ∑ : WhiskerLeft) : m WhiskerLeft

/-- A monad equipped with the ability to construct `NormalExpr` terms. -/
class MonadNormalExpr (m : Type ‚Üí Type) extends MonadWhiskerLeft m where
  /-- The expression for the structural 2-morphism `Œ±`. -/
  nilM (Œ± : Structural) : m NormalExpr
  /-- The expression for the normalized 2-morphism `Œ± ‚â´ Œ∑ ‚â´ Œ∑s`. -/
  consM (headStructural : Structural) (Œ∑ : WhiskerLeft) (Œ∑s : NormalExpr) : m NormalExpr

variable {m : Type ‚Üí Type} [Monad m]

open MonadMor‚ÇÅ

/-- The domain of a 2-morphism. -/
def WhiskerRight.srcM [MonadMor‚ÇÅ m] : WhiskerRight ‚Üí m Mor‚ÇÅ
  | WhiskerRight.of Œ∑ => return Œ∑.src
  | WhiskerRight.whisker _ Œ∑ f => do comp‚ÇÅM (‚Üê Œ∑.srcM) (.of f)

/-- The codomain of a 2-morphism. -/
def WhiskerRight.tgtM [MonadMor‚ÇÅ m] : WhiskerRight ‚Üí m Mor‚ÇÅ
  | WhiskerRight.of Œ∑ => return Œ∑.tgt
  | WhiskerRight.whisker _ Œ∑ f => do comp‚ÇÅM (‚Üê Œ∑.tgtM) (.of f)

/-- The domain of a 2-morphism. -/
def HorizontalComp.srcM [MonadMor‚ÇÅ m] : HorizontalComp ‚Üí m Mor‚ÇÅ
  | HorizontalComp.of Œ∑ => Œ∑.srcM
  | HorizontalComp.cons _ Œ∑ Œ∑s => do comp‚ÇÅM (‚Üê Œ∑.srcM) (‚Üê Œ∑s.srcM)

/-- The codomain of a 2-morphism. -/
def HorizontalComp.tgtM [MonadMor‚ÇÅ m] : HorizontalComp ‚Üí m Mor‚ÇÅ
  | HorizontalComp.of Œ∑ => Œ∑.tgtM
  | HorizontalComp.cons _ Œ∑ Œ∑s => do comp‚ÇÅM (‚Üê Œ∑.tgtM) (‚Üê Œ∑s.tgtM)

/-- The domain of a 2-morphism. -/
def WhiskerLeft.srcM [MonadMor‚ÇÅ m] : WhiskerLeft ‚Üí m Mor‚ÇÅ
  | WhiskerLeft.of Œ∑ => Œ∑.srcM
  | WhiskerLeft.whisker _ f Œ∑ => do comp‚ÇÅM (.of f) (‚Üê Œ∑.srcM)

/-- The codomain of a 2-morphism. -/
def WhiskerLeft.tgtM [MonadMor‚ÇÅ m] : WhiskerLeft ‚Üí m Mor‚ÇÅ
  | WhiskerLeft.of Œ∑ => Œ∑.tgtM
  | WhiskerLeft.whisker _ f Œ∑ => do comp‚ÇÅM (.of f) (‚Üê Œ∑.tgtM)

/-- The domain of a 2-morphism. -/
def NormalExpr.srcM [MonadMor‚ÇÅ m] : NormalExpr ‚Üí m Mor‚ÇÅ
  | NormalExpr.nil _ Œ∑ => Œ∑.srcM
  | NormalExpr.cons _ Œ± _ _ => Œ±.srcM

/-- The codomain of a 2-morphism. -/
def NormalExpr.tgtM [MonadMor‚ÇÅ m] : NormalExpr ‚Üí m Mor‚ÇÅ
  | NormalExpr.nil _ Œ∑ => Œ∑.tgtM
  | NormalExpr.cons _ _ _ Œ∑s => Œ∑s.tgtM

namespace NormalExpr

variable [MonadMor‚ÇÇIso m] [MonadNormalExpr m]

/-- The identity 2-morphism as a term of `normalExpr`. -/
def idM (f : Mor‚ÇÅ) : m NormalExpr := do
  MonadNormalExpr.nilM <| .structuralAtom <| ‚Üê MonadMor‚ÇÇIso.id‚ÇÇM f

/-- The associator as a term of `normalExpr`. -/
def associatorM (f g h : Mor‚ÇÅ) : m NormalExpr := do
  MonadNormalExpr.nilM <| .structuralAtom <| ‚Üê MonadMor‚ÇÇIso.associatorM f g h

/-- The inverse of the associator as a term of `normalExpr`. -/
def associatorInvM (f g h : Mor‚ÇÅ) : m NormalExpr := do
  MonadNormalExpr.nilM <| ‚Üê MonadMor‚ÇÇIso.symmM <|
    .structuralAtom <| ‚Üê MonadMor‚ÇÇIso.associatorM f g h

/-- The left unitor as a term of `normalExpr`. -/
def leftUnitorM (f : Mor‚ÇÅ) : m NormalExpr := do
  MonadNormalExpr.nilM <| .structuralAtom <| ‚Üê MonadMor‚ÇÇIso.leftUnitorM f

/-- The inverse of the left unitor as a term of `normalExpr`. -/
def leftUnitorInvM (f : Mor‚ÇÅ) : m NormalExpr := do
  MonadNormalExpr.nilM <| ‚Üê MonadMor‚ÇÇIso.symmM <| .structuralAtom <| ‚Üê MonadMor‚ÇÇIso.leftUnitorM f

/-- The right unitor as a term of `normalExpr`. -/
def rightUnitorM (f : Mor‚ÇÅ) : m NormalExpr := do
  MonadNormalExpr.nilM <| .structuralAtom <| ‚Üê MonadMor‚ÇÇIso.rightUnitorM f

/-- The inverse of the right unitor as a term of `normalExpr`. -/
def rightUnitorInvM (f : Mor‚ÇÅ) : m NormalExpr := do
  MonadNormalExpr.nilM <| ‚Üê MonadMor‚ÇÇIso.symmM <| .structuralAtom <| ‚Üê MonadMor‚ÇÇIso.rightUnitorM f

/-- Construct a `NormalExpr` expression from a `WhiskerLeft` expression. -/
def ofM [MonadMor‚ÇÅ m] (Œ∑ : WhiskerLeft) : m NormalExpr := do
  MonadNormalExpr.consM ((.structuralAtom <| ‚Üê MonadMor‚ÇÇIso.id‚ÇÇM (‚Üê Œ∑.srcM))) Œ∑
    (‚Üê MonadNormalExpr.nilM ((.structuralAtom <| ‚Üê MonadMor‚ÇÇIso.id‚ÇÇM (‚Üê Œ∑.tgtM))))

/-- Construct a `NormalExpr` expression from a Lean expression for an atomic 2-morphism. -/
def ofAtomM [MonadMor‚ÇÅ m] (Œ∑ : Atom) : m NormalExpr :=
  NormalExpr.ofM <| .of <| .of <| .of Œ∑

end NormalExpr

/-- Convert a `NormalExpr` expression into a list of `WhiskerLeft` expressions. -/
def NormalExpr.toList : NormalExpr ‚Üí List WhiskerLeft
  | NormalExpr.nil _ _ => []
  | NormalExpr.cons _ _ Œ∑ Œ∑s => Œ∑ :: NormalExpr.toList Œ∑s

end

section

/-- The result of evaluating an expression into normal form. -/
structure Eval.Result where
  /-- The normalized expression of the 2-morphism. -/
  expr : NormalExpr
  /-- The proof that the normalized expression is equal to the original expression. -/
  proof : Expr
  deriving Inhabited

variable {m : Type ‚Üí Type}

/-- Evaluate the expression `Œ± ‚â´ Œ≤`. -/
class MkEvalComp (m : Type ‚Üí Type) where
  /-- Evaluate `Œ± ‚â´ Œ≤` -/
  mkEvalCompNilNil (Œ± Œ≤ : Structural) : m Expr
  /-- Evaluate `Œ± ‚â´ (Œ≤ ‚â´ Œ∑ ‚â´ Œ∑s)` -/
  mkEvalCompNilCons (Œ± Œ≤ : Structural) (Œ∑ : WhiskerLeft) (Œ∑s : NormalExpr) : m Expr
  /-- Evaluate `(Œ± ‚â´ Œ∑ ‚â´ Œ∑s) ‚â´ Œ∏` -/
  mkEvalCompCons (Œ± : Structural) (Œ∑ : WhiskerLeft) (Œ∑s Œ∏ Œπ : NormalExpr) (e_Œ∑ : Expr) : m Expr

/-- Evaluate the expression `f ‚óÅ Œ∑`. -/
class MkEvalWhiskerLeft (m : Type ‚Üí Type) where
  /-- Evaluate `f ‚óÅ Œ±` -/
  mkEvalWhiskerLeftNil (f : Mor‚ÇÅ) (Œ± : Structural) : m Expr
  /-- Evaluate `f ‚óÅ (Œ± ‚â´ Œ∑ ‚â´ Œ∑s)`. -/
  mkEvalWhiskerLeftOfCons (f : Atom‚ÇÅ) (Œ± : Structural) (Œ∑ : WhiskerLeft) (Œ∑s Œ∏ : NormalExpr)
    (e_Œ∏ : Expr) : m Expr
  /-- Evaluate `(f ‚â´ g) ‚óÅ Œ∑` -/
  mkEvalWhiskerLeftComp (f g : Mor‚ÇÅ) (Œ∑ Œ∑‚ÇÅ Œ∑‚ÇÇ Œ∑‚ÇÉ Œ∑‚ÇÑ : NormalExpr)
    (e_Œ∑‚ÇÅ e_Œ∑‚ÇÇ e_Œ∑‚ÇÉ e_Œ∑‚ÇÑ : Expr) : m Expr
  /-- Evaluate `ùüô _ ‚óÅ Œ∑` -/
  mkEvalWhiskerLeftId (Œ∑ Œ∑‚ÇÅ Œ∑‚ÇÇ : NormalExpr) (e_Œ∑‚ÇÅ e_Œ∑‚ÇÇ : Expr) : m Expr

/-- Evaluate the expression `Œ∑ ‚ñ∑ f`. -/
class MkEvalWhiskerRight (m : Type ‚Üí Type) where
  /-- Evaluate `Œ∑ ‚ñ∑ f` -/
  mkEvalWhiskerRightAuxOf (Œ∑ : WhiskerRight) (f : Atom‚ÇÅ) : m Expr
  /-- Evaluate `(Œ∑ ‚ó´ Œ∑s) ‚ñ∑ f` -/
  mkEvalWhiskerRightAuxCons (f : Atom‚ÇÅ) (Œ∑ : WhiskerRight) (Œ∑s : HorizontalComp)
    (Œ∑s' Œ∑‚ÇÅ Œ∑‚ÇÇ Œ∑‚ÇÉ : NormalExpr) (e_Œ∑s' e_Œ∑‚ÇÅ e_Œ∑‚ÇÇ e_Œ∑‚ÇÉ : Expr) : m Expr
  /-- Evaluate `Œ± ‚ñ∑ f` -/
  mkEvalWhiskerRightNil (Œ± : Structural) (f : Mor‚ÇÅ) : m Expr
  /-- Evaluate ` (Œ± ‚â´ Œ∑ ‚â´ Œ∑s) ‚ñ∑ j` -/
  mkEvalWhiskerRightConsOfOf (f : Atom‚ÇÅ) (Œ± : Structural) (Œ∑ : HorizontalComp)
    (Œ∑s Œ∑s‚ÇÅ Œ∑‚ÇÅ Œ∑‚ÇÇ Œ∑‚ÇÉ : NormalExpr)
    (e_Œ∑s‚ÇÅ e_Œ∑‚ÇÅ e_Œ∑‚ÇÇ e_Œ∑‚ÇÉ : Expr) : m Expr
  /-- Evaluate `(Œ± ‚â´ (f ‚óÅ Œ∑) ‚â´ Œ∑s) ‚ñ∑ g` -/
  mkEvalWhiskerRightConsWhisker (f : Atom‚ÇÅ) (g : Mor‚ÇÅ) (Œ± : Structural) (Œ∑ : WhiskerLeft)
    (Œ∑s Œ∑‚ÇÅ Œ∑‚ÇÇ Œ∑s‚ÇÅ Œ∑s‚ÇÇ Œ∑‚ÇÉ Œ∑‚ÇÑ Œ∑‚ÇÖ : NormalExpr) (e_Œ∑‚ÇÅ e_Œ∑‚ÇÇ e_Œ∑s‚ÇÅ e_Œ∑s‚ÇÇ e_Œ∑‚ÇÉ e_Œ∑‚ÇÑ e_Œ∑‚ÇÖ : Expr) : m Expr
  /-- Evaluate `Œ∑ ‚ñ∑ (g ‚äó h)` -/
  mkEvalWhiskerRightComp (g h : Mor‚ÇÅ)
    (Œ∑ Œ∑‚ÇÅ Œ∑‚ÇÇ Œ∑‚ÇÉ Œ∑‚ÇÑ : NormalExpr) (e_Œ∑‚ÇÅ e_Œ∑‚ÇÇ e_Œ∑‚ÇÉ e_Œ∑‚ÇÑ : Expr) : m Expr
  /-- Evaluate `Œ∑ ‚ñ∑ ùüô _` -/
  mkEvalWhiskerRightId (Œ∑ Œ∑‚ÇÅ Œ∑‚ÇÇ : NormalExpr) (e_Œ∑‚ÇÅ e_Œ∑‚ÇÇ : Expr) : m Expr

/-- Evaluate the expression `Œ∑ ‚ó´ Œ∏`. -/
class MkEvalHorizontalComp (m : Type ‚Üí Type) where
  /-- Evaluate `Œ∑ ‚ó´ Œ∏` -/
  mkEvalHorizontalCompAuxOf (Œ∑ : WhiskerRight) (Œ∏ : HorizontalComp) : m Expr
  /-- Evaluate `(Œ∑ ‚ó´ Œ∑s) ‚ó´ Œ∏` -/
  mkEvalHorizontalCompAuxCons (Œ∑ : WhiskerRight) (Œ∑s Œ∏ : HorizontalComp)
    (Œ∑Œ∏ Œ∑‚ÇÅ Œ∑Œ∏‚ÇÅ Œ∑Œ∏‚ÇÇ : NormalExpr) (e_Œ∑Œ∏ e_Œ∑‚ÇÅ e_Œ∑Œ∏‚ÇÅ e_Œ∑Œ∏‚ÇÇ : Expr) : m Expr
  /-- Evaluate `(f ‚óÅ Œ∑) ‚ó´ Œ∏` -/
  mkEvalHorizontalCompAux'Whisker (f : Atom‚ÇÅ) (Œ∑ Œ∏ : WhiskerLeft)
    (Œ∑Œ∏ Œ∑Œ∏‚ÇÅ Œ∑Œ∏‚ÇÇ Œ∑Œ∏‚ÇÉ : NormalExpr) (e_Œ∑Œ∏ e_Œ∑Œ∏‚ÇÅ e_Œ∑Œ∏‚ÇÇ e_Œ∑Œ∏‚ÇÉ : Expr) : m Expr
  /-- Evaluate `Œ∑ ‚ó´ (f ‚óÅ Œ∏)` -/
  mkEvalHorizontalCompAux'OfWhisker (f : Atom‚ÇÅ) (Œ∑ : HorizontalComp) (Œ∏ : WhiskerLeft)
    (Œ∑‚ÇÅ Œ∑Œ∏ Œ∑Œ∏‚ÇÅ Œ∑Œ∏‚ÇÇ : NormalExpr) (e_Œ∑Œ∏ e_Œ∑‚ÇÅ e_Œ∑Œ∏‚ÇÅ e_Œ∑Œ∏‚ÇÇ : Expr) : m Expr
  /-- Evaluate `Œ± ‚ó´ Œ≤` -/
  mkEvalHorizontalCompNilNil (Œ± Œ≤ : Structural) : m Expr
  /-- Evaluate `Œ± ‚ó´ (Œ≤ ‚â´ Œ∑ ‚â´ Œ∑s)` -/
  mkEvalHorizontalCompNilCons (Œ± Œ≤ : Structural) (Œ∑ : WhiskerLeft)
    (Œ∑s Œ∑‚ÇÅ Œ∑s‚ÇÅ Œ∑‚ÇÇ Œ∑‚ÇÉ : NormalExpr) (e_Œ∑‚ÇÅ e_Œ∑s‚ÇÅ e_Œ∑‚ÇÇ e_Œ∑‚ÇÉ : Expr) : m Expr
  /-- Evaluate `(Œ± ‚â´ Œ∑ ‚â´ Œ∑s) ‚ó´ Œ≤` -/
  mkEvalHorizontalCompConsNil (Œ± Œ≤ : Structural) (Œ∑ : WhiskerLeft) (Œ∑s : NormalExpr)
    (Œ∑‚ÇÅ Œ∑s‚ÇÅ Œ∑‚ÇÇ Œ∑‚ÇÉ : NormalExpr) (e_Œ∑‚ÇÅ e_Œ∑s‚ÇÅ e_Œ∑‚ÇÇ e_Œ∑‚ÇÉ : Expr) : m Expr
  /-- Evaluate `(Œ± ‚â´ Œ∑ ‚â´ Œ∑s) ‚ó´ (Œ≤ ‚â´ Œ∏ ‚â´ Œ∏s)` -/
  mkEvalHorizontalCompConsCons (Œ± Œ≤ : Structural) (Œ∑ Œ∏ : WhiskerLeft)
    (Œ∑s Œ∏s Œ∑Œ∏ Œ∑Œ∏s Œ∑Œ∏‚ÇÅ Œ∑Œ∏‚ÇÇ : NormalExpr) (e_Œ∑Œ∏ e_Œ∑Œ∏s e_Œ∑Œ∏‚ÇÅ e_Œ∑Œ∏‚ÇÇ : Expr) : m Expr

/-- Evaluate the expression of a 2-morphism into a normalized form. -/
class MkEval (m : Type ‚Üí Type) extends
    MkEvalComp m, MkEvalWhiskerLeft m, MkEvalWhiskerRight m, MkEvalHorizontalComp m where
  /-- Evaluate the expression `Œ∑ ‚â´ Œ∏` into a normalized form. -/
  mkEvalComp (Œ∑ Œ∏ : Mor‚ÇÇ) (Œ∑' Œ∏' Œ∑Œ∏ : NormalExpr) (e_Œ∑ e_Œ∏ e_Œ∑Œ∏ : Expr) : m Expr
  /-- Evaluate the expression `f ‚óÅ Œ∑` into a normalized form. -/
  mkEvalWhiskerLeft (f : Mor‚ÇÅ) (Œ∑ : Mor‚ÇÇ) (Œ∑' Œ∏ : NormalExpr) (e_Œ∑ e_Œ∏ : Expr) : m Expr
  /-- Evaluate the expression `Œ∑ ‚ñ∑ f` into a normalized form. -/
  mkEvalWhiskerRight (Œ∑ : Mor‚ÇÇ) (h : Mor‚ÇÅ) (Œ∑' Œ∏ : NormalExpr) (e_Œ∑ e_Œ∏ : Expr) : m Expr
  /-- Evaluate the expression `Œ∑ ‚ó´ Œ∏` into a normalized form. -/
  mkEvalHorizontalComp (Œ∑ Œ∏ : Mor‚ÇÇ) (Œ∑' Œ∏' Œπ : NormalExpr) (e_Œ∑ e_Œ∏ e_Œπ : Expr) : m Expr
  /-- Evaluate the atomic 2-morphism `Œ∑` into a normalized form. -/
  mkEvalOf (Œ∑ : Atom) : m Expr
  /-- Evaluate the expression `Œ∑ ‚äó‚â´ Œ∏ := Œ∑ ‚â´ Œ± ‚â´ Œ∏` into a normalized form. -/
  mkEvalMonoidalComp (Œ∑ Œ∏ : Mor‚ÇÇ) (Œ± : Structural) (Œ∑' Œ∏' Œ±Œ∏ Œ∑Œ±Œ∏ : NormalExpr)
    (e_Œ∑ e_Œ∏ e_Œ±Œ∏ e_Œ∑Œ±Œ∏ : Expr) : m Expr

variable {œÅ : Type}
variable [MonadMor‚ÇÇIso (CoherenceM œÅ)] [MonadNormalExpr (CoherenceM œÅ)] [MkEval (CoherenceM œÅ)]

open MkEvalComp MonadMor‚ÇÇIso MonadNormalExpr

/-- Evaluate the expression `Œ± ‚â´ Œ∑` into a normalized form. -/
def evalCompNil (Œ± : Structural) : NormalExpr ‚Üí CoherenceM œÅ Eval.Result
  | .nil _ Œ≤ => do return ‚ü®‚Üê nilM (‚Üê comp‚ÇÇM Œ± Œ≤), ‚Üê mkEvalCompNilNil Œ± Œ≤‚ü©
  | .cons _ Œ≤ Œ∑ Œ∑s => do return ‚ü®‚Üê consM (‚Üê comp‚ÇÇM Œ± Œ≤) Œ∑ Œ∑s, ‚Üê mkEvalCompNilCons Œ± Œ≤ Œ∑ Œ∑s‚ü©

/-- Evaluate the expression `Œ∑ ‚â´ Œ∏` into a normalized form. -/
def evalComp : NormalExpr ‚Üí NormalExpr ‚Üí CoherenceM œÅ Eval.Result
  | .nil _ Œ±, Œ∑ => do evalCompNil Œ± Œ∑
  | .cons _ Œ± Œ∑ Œ∑s, Œ∏ => do
    let ‚ü®Œπ, e_Œπ‚ü© ‚Üê evalComp Œ∑s Œ∏
    return ‚ü®‚Üê consM Œ± Œ∑ Œπ, ‚Üê mkEvalCompCons Œ± Œ∑ Œ∑s Œ∏ Œπ e_Œπ‚ü©

open MkEvalWhiskerLeft

variable [MonadMor‚ÇÅ (CoherenceM œÅ)] [MonadMor‚ÇÇIso (CoherenceM œÅ)]

/-- Evaluate the expression `f ‚óÅ Œ∑` into a normalized form. -/
def evalWhiskerLeft : Mor‚ÇÅ ‚Üí NormalExpr ‚Üí CoherenceM œÅ Eval.Result
  | f, .nil _ Œ± => do
    return ‚ü®‚Üê nilM (‚Üê whiskerLeftM f Œ±), ‚Üê mkEvalWhiskerLeftNil f Œ±‚ü©
  | .of f, .cons _ Œ± Œ∑ Œ∑s => do
    let Œ∑' ‚Üê MonadWhiskerLeft.whiskerLeftM f Œ∑
    let ‚ü®Œ∏, e_Œ∏‚ü© ‚Üê evalWhiskerLeft (.of f) Œ∑s
    let Œ∑'' ‚Üê consM (‚Üê whiskerLeftM (.of f) Œ±) Œ∑' Œ∏
    return ‚ü®Œ∑'', ‚Üê mkEvalWhiskerLeftOfCons f Œ± Œ∑ Œ∑s Œ∏ e_Œ∏‚ü©
  | .comp _ f g, Œ∑ => do
    let ‚ü®Œ∏, e_Œ∏‚ü© ‚Üê evalWhiskerLeft g Œ∑
    let ‚ü®Œπ, e_Œπ‚ü© ‚Üê evalWhiskerLeft f Œ∏
    let h ‚Üê Œ∑.srcM
    let h' ‚Üê Œ∑.tgtM
    let ‚ü®Œπ', e_Œπ'‚ü© ‚Üê evalComp Œπ (‚Üê NormalExpr.associatorInvM f g h')
    let ‚ü®Œπ'', e_Œπ''‚ü© ‚Üê evalComp (‚Üê NormalExpr.associatorM f g h) Œπ'
    return ‚ü®Œπ'', ‚Üê mkEvalWhiskerLeftComp f g Œ∑ Œ∏ Œπ Œπ' Œπ'' e_Œ∏ e_Œπ e_Œπ' e_Œπ''‚ü©
  | .id _ _, Œ∑ => do
    let f ‚Üê Œ∑.srcM
    let g ‚Üê Œ∑.tgtM
    let ‚ü®Œ∑', e_Œ∑'‚ü© ‚Üê evalComp Œ∑ (‚Üê NormalExpr.leftUnitorInvM g)
    let ‚ü®Œ∑'', e_Œ∑''‚ü© ‚Üê evalComp (‚Üê NormalExpr.leftUnitorM f) Œ∑'
    return ‚ü®Œ∑'', ‚Üê mkEvalWhiskerLeftId Œ∑ Œ∑' Œ∑'' e_Œ∑' e_Œ∑''‚ü©

open MkEvalWhiskerRight MkEvalHorizontalComp

mutual

/-- Evaluate the expression `Œ∑ ‚ñ∑ f` into a normalized form. -/
partial def evalWhiskerRightAux : HorizontalComp ‚Üí Atom‚ÇÅ ‚Üí CoherenceM œÅ Eval.Result
  | .of Œ∑, f => do
    let Œ∑' ‚Üê NormalExpr.ofM <| .of <| .of <| ‚Üê MonadWhiskerRight.whiskerRightM Œ∑ f
    return ‚ü®Œ∑', ‚Üê mkEvalWhiskerRightAuxOf Œ∑ f‚ü©
  | .cons _ Œ∑ Œ∑s, f => do
    let ‚ü®Œ∑s', e_Œ∑s'‚ü© ‚Üê evalWhiskerRightAux Œ∑s f
    let ‚ü®Œ∑‚ÇÅ, e_Œ∑‚ÇÅ‚ü© ‚Üê evalHorizontalComp (‚Üê NormalExpr.ofM <| .of <| .of Œ∑) Œ∑s'
    let ‚ü®Œ∑‚ÇÇ, e_Œ∑‚ÇÇ‚ü© ‚Üê evalComp Œ∑‚ÇÅ (‚Üê NormalExpr.associatorInvM (‚Üê Œ∑.tgtM) (‚Üê Œ∑s.tgtM) (.of f))
    let ‚ü®Œ∑‚ÇÉ, e_Œ∑‚ÇÉ‚ü© ‚Üê evalComp (‚Üê NormalExpr.associatorM (‚Üê Œ∑.srcM) (‚Üê Œ∑s.srcM) (.of f)) Œ∑‚ÇÇ
    return ‚ü®Œ∑‚ÇÉ, ‚Üê mkEvalWhiskerRightAuxCons f Œ∑ Œ∑s Œ∑s' Œ∑‚ÇÅ Œ∑‚ÇÇ Œ∑‚ÇÉ e_Œ∑s' e_Œ∑‚ÇÅ e_Œ∑‚ÇÇ e_Œ∑‚ÇÉ‚ü©

/-- Evaluate the expression `Œ∑ ‚ñ∑ f` into a normalized form. -/
partial def evalWhiskerRight : NormalExpr ‚Üí Mor‚ÇÅ ‚Üí CoherenceM œÅ Eval.Result
  | .nil _ Œ±, h => do
    return ‚ü®‚Üê nilM (‚Üê whiskerRightM Œ± h), ‚Üê mkEvalWhiskerRightNil Œ± h‚ü©
  | .cons _ Œ± (.of Œ∑) Œ∑s, .of f => do
    let ‚ü®Œ∑s‚ÇÅ, e_Œ∑s‚ÇÅ‚ü© ‚Üê evalWhiskerRight Œ∑s (.of f)
    let ‚ü®Œ∑‚ÇÅ, e_Œ∑‚ÇÅ‚ü© ‚Üê evalWhiskerRightAux Œ∑ f
    let ‚ü®Œ∑‚ÇÇ, e_Œ∑‚ÇÇ‚ü© ‚Üê evalComp Œ∑‚ÇÅ Œ∑s‚ÇÅ
    let ‚ü®Œ∑‚ÇÉ, e_Œ∑‚ÇÉ‚ü© ‚Üê evalCompNil (‚Üê whiskerRightM Œ± (.of f)) Œ∑‚ÇÇ
    return ‚ü®Œ∑‚ÇÉ, ‚Üê mkEvalWhiskerRightConsOfOf f Œ± Œ∑ Œ∑s Œ∑s‚ÇÅ Œ∑‚ÇÅ Œ∑‚ÇÇ Œ∑‚ÇÉ e_Œ∑s‚ÇÅ e_Œ∑‚ÇÅ e_Œ∑‚ÇÇ e_Œ∑‚ÇÉ‚ü©
  | .cons _ Œ± (.whisker _ f Œ∑) Œ∑s, h => do
    let g ‚Üê Œ∑.srcM
    let g' ‚Üê Œ∑.tgtM
    let ‚ü®Œ∑‚ÇÅ, e_Œ∑‚ÇÅ‚ü© ‚Üê evalWhiskerRight (‚Üê consM (‚Üê id‚ÇÇM' g) Œ∑ (‚Üê NormalExpr.idM g')) h
    let ‚ü®Œ∑‚ÇÇ, e_Œ∑‚ÇÇ‚ü© ‚Üê evalWhiskerLeft (.of f) Œ∑‚ÇÅ
    let ‚ü®Œ∑s‚ÇÅ, e_Œ∑s‚ÇÅ‚ü© ‚Üê evalWhiskerRight Œ∑s h
    let Œ±' ‚Üê whiskerRightM Œ± h
    let ‚ü®Œ∑s‚ÇÇ, e_Œ∑s‚ÇÇ‚ü© ‚Üê evalComp (‚Üê NormalExpr.associatorInvM (.of f) g' h) Œ∑s‚ÇÅ
    let ‚ü®Œ∑‚ÇÉ, e_Œ∑‚ÇÉ‚ü© ‚Üê evalComp Œ∑‚ÇÇ Œ∑s‚ÇÇ
    let ‚ü®Œ∑‚ÇÑ, e_Œ∑‚ÇÑ‚ü© ‚Üê evalComp (‚Üê NormalExpr.associatorM (.of f) g h) Œ∑‚ÇÉ
    let ‚ü®Œ∑‚ÇÖ, e_Œ∑‚ÇÖ‚ü© ‚Üê evalComp (‚Üê nilM Œ±') Œ∑‚ÇÑ
    return ‚ü®Œ∑‚ÇÖ, ‚Üê mkEvalWhiskerRightConsWhisker f h Œ± Œ∑ Œ∑s Œ∑‚ÇÅ Œ∑‚ÇÇ Œ∑s‚ÇÅ Œ∑s‚ÇÇ Œ∑‚ÇÉ Œ∑‚ÇÑ Œ∑‚ÇÖ
      e_Œ∑‚ÇÅ e_Œ∑‚ÇÇ e_Œ∑s‚ÇÅ e_Œ∑s‚ÇÇ e_Œ∑‚ÇÉ e_Œ∑‚ÇÑ e_Œ∑‚ÇÖ‚ü©
  | Œ∑, .comp _ g h => do
    let ‚ü®Œ∑‚ÇÅ, e_Œ∑‚ÇÅ‚ü© ‚Üê evalWhiskerRight Œ∑ g
    let ‚ü®Œ∑‚ÇÇ, e_Œ∑‚ÇÇ‚ü© ‚Üê evalWhiskerRight Œ∑‚ÇÅ h
    let f ‚Üê Œ∑.srcM
    let f' ‚Üê Œ∑.tgtM
    let ‚ü®Œ∑‚ÇÉ, e_Œ∑‚ÇÉ‚ü© ‚Üê evalComp Œ∑‚ÇÇ (‚Üê NormalExpr.associatorM f' g h)
    let ‚ü®Œ∑‚ÇÑ, e_Œ∑‚ÇÑ‚ü© ‚Üê evalComp (‚Üê NormalExpr.associatorInvM f g h) Œ∑‚ÇÉ
    return ‚ü®Œ∑‚ÇÑ, ‚Üê mkEvalWhiskerRightComp g h Œ∑ Œ∑‚ÇÅ Œ∑‚ÇÇ Œ∑‚ÇÉ Œ∑‚ÇÑ e_Œ∑‚ÇÅ e_Œ∑‚ÇÇ e_Œ∑‚ÇÉ e_Œ∑‚ÇÑ‚ü©
  | Œ∑, .id _ _ => do
    let f ‚Üê Œ∑.srcM
    let g ‚Üê Œ∑.tgtM
    let ‚ü®Œ∑‚ÇÅ, e_Œ∑‚ÇÅ‚ü© ‚Üê evalComp Œ∑ (‚Üê NormalExpr.rightUnitorInvM g)
    let ‚ü®Œ∑‚ÇÇ, e_Œ∑‚ÇÇ‚ü© ‚Üê evalComp (‚Üê NormalExpr.rightUnitorM f) Œ∑‚ÇÅ
    return ‚ü®Œ∑‚ÇÇ, ‚Üê mkEvalWhiskerRightId Œ∑ Œ∑‚ÇÅ Œ∑‚ÇÇ e_Œ∑‚ÇÅ e_Œ∑‚ÇÇ‚ü©

/-- Evaluate the expression `Œ∑ ‚äó Œ∏` into a normalized form. -/
partial def evalHorizontalCompAux : HorizontalComp ‚Üí HorizontalComp ‚Üí CoherenceM œÅ Eval.Result
  | .of Œ∑, Œ∏ => do
    return ‚ü®‚Üê NormalExpr.ofM <| .of <| ‚Üê MonadHorizontalComp.hConsM Œ∑ Œ∏,
      ‚Üê mkEvalHorizontalCompAuxOf Œ∑ Œ∏‚ü©
  | .cons _ Œ∑ Œ∑s, Œ∏ => do
    let Œ± ‚Üê NormalExpr.associatorM (‚Üê Œ∑.srcM) (‚Üê Œ∑s.srcM) (‚Üê Œ∏.srcM)
    let Œ±' ‚Üê NormalExpr.associatorInvM (‚Üê Œ∑.tgtM) (‚Üê Œ∑s.tgtM) (‚Üê Œ∏.tgtM)
    let ‚ü®Œ∑Œ∏, e_Œ∑Œ∏‚ü© ‚Üê evalHorizontalCompAux Œ∑s Œ∏
    let ‚ü®Œ∑‚ÇÅ, e_Œ∑‚ÇÅ‚ü© ‚Üê evalHorizontalComp (‚Üê NormalExpr.ofM <| .of <| .of Œ∑) Œ∑Œ∏
    let ‚ü®Œ∑Œ∏‚ÇÅ, e_Œ∑Œ∏‚ÇÅ‚ü© ‚Üê evalComp Œ∑‚ÇÅ Œ±'
    let ‚ü®Œ∑Œ∏‚ÇÇ, e_Œ∑Œ∏‚ÇÇ‚ü© ‚Üê evalComp Œ± Œ∑Œ∏‚ÇÅ
    return ‚ü®Œ∑Œ∏‚ÇÇ, ‚Üê mkEvalHorizontalCompAuxCons Œ∑ Œ∑s Œ∏ Œ∑Œ∏ Œ∑‚ÇÅ Œ∑Œ∏‚ÇÅ Œ∑Œ∏‚ÇÇ e_Œ∑Œ∏ e_Œ∑‚ÇÅ e_Œ∑Œ∏‚ÇÅ e_Œ∑Œ∏‚ÇÇ‚ü©

/-- Evaluate the expression `Œ∑ ‚äó Œ∏` into a normalized form. -/
partial def evalHorizontalCompAux' : WhiskerLeft ‚Üí WhiskerLeft ‚Üí CoherenceM œÅ Eval.Result
  | .of Œ∑, .of Œ∏ => evalHorizontalCompAux Œ∑ Œ∏
  | .whisker _ f Œ∑, Œ∏ => do
    let ‚ü®Œ∑Œ∏, e_Œ∑Œ∏‚ü© ‚Üê evalHorizontalCompAux' Œ∑ Œ∏
    let ‚ü®Œ∑Œ∏‚ÇÅ, e_Œ∑Œ∏‚ÇÅ‚ü© ‚Üê evalWhiskerLeft (.of f) Œ∑Œ∏
    let ‚ü®Œ∑Œ∏‚ÇÇ, e_Œ∑Œ∏‚ÇÇ‚ü© ‚Üê evalComp Œ∑Œ∏‚ÇÅ (‚Üê NormalExpr.associatorInvM (.of f) (‚Üê Œ∑.tgtM) (‚Üê Œ∏.tgtM))
    let ‚ü®Œ∑Œ∏‚ÇÉ, e_Œ∑Œ∏‚ÇÉ‚ü© ‚Üê evalComp (‚Üê NormalExpr.associatorM (.of f) (‚Üê Œ∑.srcM) (‚Üê Œ∏.srcM)) Œ∑Œ∏‚ÇÇ
    return ‚ü®Œ∑Œ∏‚ÇÉ, ‚Üê mkEvalHorizontalCompAux'Whisker f Œ∑ Œ∏ Œ∑Œ∏ Œ∑Œ∏‚ÇÅ Œ∑Œ∏‚ÇÇ Œ∑Œ∏‚ÇÉ e_Œ∑Œ∏ e_Œ∑Œ∏‚ÇÅ e_Œ∑Œ∏‚ÇÇ e_Œ∑Œ∏‚ÇÉ‚ü©
  | .of Œ∑, .whisker _ f Œ∏ => do
    let ‚ü®Œ∑‚ÇÅ, e_Œ∑‚ÇÅ‚ü© ‚Üê evalWhiskerRightAux Œ∑ f
    let ‚ü®Œ∑Œ∏, e_Œ∑Œ∏‚ü© ‚Üê evalHorizontalComp Œ∑‚ÇÅ (‚Üê NormalExpr.ofM Œ∏)
    let ‚ü®Œ∑Œ∏‚ÇÅ, e_Œ∑Œ∏‚ÇÅ‚ü© ‚Üê evalComp Œ∑Œ∏ (‚Üê NormalExpr.associatorM (‚Üê Œ∑.tgtM) (.of f) (‚Üê Œ∏.tgtM))
    let ‚ü®Œ∑Œ∏‚ÇÇ, e_Œ∑Œ∏‚ÇÇ‚ü© ‚Üê evalComp (‚Üê NormalExpr.associatorInvM (‚Üê Œ∑.srcM) (.of f) (‚Üê Œ∏.srcM)) Œ∑Œ∏‚ÇÅ
    return ‚ü®Œ∑Œ∏‚ÇÇ, ‚Üê mkEvalHorizontalCompAux'OfWhisker f Œ∑ Œ∏ Œ∑Œ∏ Œ∑‚ÇÅ Œ∑Œ∏‚ÇÅ Œ∑Œ∏‚ÇÇ e_Œ∑‚ÇÅ e_Œ∑Œ∏ e_Œ∑Œ∏‚ÇÅ e_Œ∑Œ∏‚ÇÇ‚ü©

/-- Evaluate the expression `Œ∑ ‚äó Œ∏` into a normalized form. -/
partial def evalHorizontalComp : NormalExpr ‚Üí NormalExpr ‚Üí CoherenceM œÅ Eval.Result
  | .nil _ Œ±, .nil _ Œ≤ => do
    return ‚ü®‚Üê nilM <| ‚Üê horizontalCompM Œ± Œ≤, ‚Üê mkEvalHorizontalCompNilNil Œ± Œ≤‚ü©
  | .nil _ Œ±, .cons _ Œ≤ Œ∑ Œ∑s => do
    let ‚ü®Œ∑‚ÇÅ, e_Œ∑‚ÇÅ‚ü© ‚Üê evalWhiskerLeft (‚Üê Œ±.tgtM) (‚Üê NormalExpr.ofM Œ∑)
    let ‚ü®Œ∑s‚ÇÅ, e_Œ∑s‚ÇÅ‚ü© ‚Üê evalWhiskerLeft (‚Üê Œ±.tgtM) Œ∑s
    let ‚ü®Œ∑‚ÇÇ, e_Œ∑‚ÇÇ‚ü© ‚Üê evalComp Œ∑‚ÇÅ Œ∑s‚ÇÅ
    let ‚ü®Œ∑‚ÇÉ, e_Œ∑‚ÇÉ‚ü© ‚Üê evalCompNil (‚Üê horizontalCompM Œ± Œ≤) Œ∑‚ÇÇ
    return ‚ü®Œ∑‚ÇÉ, ‚Üê mkEvalHorizontalCompNilCons Œ± Œ≤ Œ∑ Œ∑s Œ∑‚ÇÅ Œ∑s‚ÇÅ Œ∑‚ÇÇ Œ∑‚ÇÉ e_Œ∑‚ÇÅ e_Œ∑s‚ÇÅ e_Œ∑‚ÇÇ e_Œ∑‚ÇÉ‚ü©
  | .cons _ Œ± Œ∑ Œ∑s, .nil _ Œ≤ => do
    let ‚ü®Œ∑‚ÇÅ, e_Œ∑‚ÇÅ‚ü© ‚Üê evalWhiskerRight (‚Üê NormalExpr.ofM Œ∑) (‚Üê Œ≤.tgtM)
    let ‚ü®Œ∑s‚ÇÅ, e_Œ∑s‚ÇÅ‚ü© ‚Üê evalWhiskerRight Œ∑s (‚Üê Œ≤.tgtM)
    let ‚ü®Œ∑‚ÇÇ, e_Œ∑‚ÇÇ‚ü© ‚Üê evalComp Œ∑‚ÇÅ Œ∑s‚ÇÅ
    let ‚ü®Œ∑‚ÇÉ, e_Œ∑‚ÇÉ‚ü© ‚Üê evalCompNil (‚Üê horizontalCompM Œ± Œ≤) Œ∑‚ÇÇ
    return ‚ü®Œ∑‚ÇÉ, ‚Üê mkEvalHorizontalCompConsNil Œ± Œ≤ Œ∑ Œ∑s Œ∑‚ÇÅ Œ∑s‚ÇÅ Œ∑‚ÇÇ Œ∑‚ÇÉ e_Œ∑‚ÇÅ e_Œ∑s‚ÇÅ e_Œ∑‚ÇÇ e_Œ∑‚ÇÉ‚ü©
  | .cons _ Œ± Œ∑ Œ∑s, .cons _ Œ≤ Œ∏ Œ∏s => do
    let ‚ü®Œ∑Œ∏, e_Œ∑Œ∏‚ü© ‚Üê evalHorizontalCompAux' Œ∑ Œ∏
    let ‚ü®Œ∑Œ∏s, e_Œ∑Œ∏s‚ü© ‚Üê evalHorizontalComp Œ∑s Œ∏s
    let ‚ü®Œ∑Œ∏‚ÇÅ, e_Œ∑Œ∏‚ÇÅ‚ü© ‚Üê evalComp Œ∑Œ∏ Œ∑Œ∏s
    let ‚ü®Œ∑Œ∏‚ÇÇ, e_Œ∑Œ∏‚ÇÇ‚ü© ‚Üê evalCompNil (‚Üê horizontalCompM Œ± Œ≤) Œ∑Œ∏‚ÇÅ
    return ‚ü®Œ∑Œ∏‚ÇÇ,
      ‚Üê mkEvalHorizontalCompConsCons Œ± Œ≤ Œ∑ Œ∏ Œ∑s Œ∏s Œ∑Œ∏ Œ∑Œ∏s Œ∑Œ∏‚ÇÅ Œ∑Œ∏‚ÇÇ e_Œ∑Œ∏ e_Œ∑Œ∏s e_Œ∑Œ∏‚ÇÅ e_Œ∑Œ∏‚ÇÇ‚ü©

end

open MkEval

variable {œÅ : Type}
    [MonadMor‚ÇÅ (CoherenceM œÅ)]
    [MonadMor‚ÇÇIso (CoherenceM œÅ)]
    [MonadNormalExpr (CoherenceM œÅ)] [MkEval (CoherenceM œÅ)]
    [MonadMor‚ÇÇ (CoherenceM œÅ)]

/-- Trace the proof of the normalization. -/
def traceProof (nm : Name) (result : Expr) : CoherenceM œÅ Unit := do
  withTraceNode nm (fun _ => return m!"{checkEmoji} {‚Üê inferType result}") do
    if ‚Üê isTracingEnabledFor nm then addTrace nm m!"proof: {result}"

-- TODO: It takes a while to compile. Find out why.
/-- Evaluate the expression of a 2-morphism into a normalized form. -/
def eval (nm : Name) (e : Mor‚ÇÇ) : CoherenceM œÅ Eval.Result := do
  withTraceNode nm (fun _ => return m!"eval: {e.e}") do
    match e with
    | .isoHom _ _ Œ± => withTraceNode nm (fun _ => return m!"Iso.hom") do match Œ± with
      | .structuralAtom Œ± => return ‚ü®‚Üê nilM <| .structuralAtom Œ±, ‚Üê mkEqRefl e.e‚ü©
      | .of Œ∑ =>
        let Œ∑ ‚Üê MonadMor‚ÇÇ.atomHomM Œ∑
        let result ‚Üê mkEvalOf Œ∑
        traceProof nm result
        return ‚ü®‚Üê NormalExpr.ofAtomM Œ∑, result‚ü©
      | _ => throwError "not implemented. try dsimp first."
    | .isoInv _ _ Œ± => withTraceNode nm (fun _ => return m!"Iso.inv") do match Œ± with
      | .structuralAtom Œ± => return ‚ü®‚Üê nilM <| (‚Üê symmM (.structuralAtom Œ±)), ‚Üê mkEqRefl e.e‚ü©
      | .of Œ∑ =>
        let Œ∑ ‚Üê MonadMor‚ÇÇ.atomInvM Œ∑
        let result ‚Üê mkEvalOf Œ∑
        traceProof nm result
        return ‚ü®‚Üê NormalExpr.ofAtomM Œ∑, result‚ü©
      | _ => throwError "not implemented. try dsimp first."
    | .id _ _ f =>
      let Œ± ‚Üê MonadMor‚ÇÇIso.id‚ÇÇM f
      return  ‚ü®‚Üê nilM <| .structuralAtom Œ±, ‚Üê mkEqRefl e.e‚ü©
    | .comp _ _ _ _ _ Œ∑ Œ∏ => withTraceNode nm (fun _ => return m!"comp") do
      let ‚ü®Œ∑', e_Œ∑‚ü© ‚Üê eval nm Œ∑
      let ‚ü®Œ∏', e_Œ∏‚ü© ‚Üê eval nm Œ∏
      let ‚ü®Œ∑Œ∏, pf‚ü© ‚Üê evalComp Œ∑' Œ∏'
      let result ‚Üê mkEvalComp Œ∑ Œ∏ Œ∑' Œ∏' Œ∑Œ∏ e_Œ∑ e_Œ∏ pf
      traceProof nm result
      return ‚ü®Œ∑Œ∏, result‚ü©
    | .whiskerLeft _ _ f _ _ Œ∑ => withTraceNode nm (fun _ => return m!"whiskerLeft") do
      let ‚ü®Œ∑', e_Œ∑‚ü© ‚Üê eval nm Œ∑
      let ‚ü®Œ∏, e_Œ∏‚ü© ‚Üê evalWhiskerLeft f Œ∑'
      let result ‚Üê mkEvalWhiskerLeft f Œ∑ Œ∑' Œ∏ e_Œ∑ e_Œ∏
      traceProof nm result
      return ‚ü®Œ∏, result‚ü©
    | .whiskerRight _ _ _ _ Œ∑ h =>
      withTraceNode nm (fun _ => return m!"whiskerRight") do
        let ‚ü®Œ∑', e_Œ∑‚ü© ‚Üê eval nm Œ∑
        let ‚ü®Œ∏, e_Œ∏‚ü© ‚Üê evalWhiskerRight Œ∑' h
        let result ‚Üê mkEvalWhiskerRight Œ∑ h Œ∑' Œ∏ e_Œ∑ e_Œ∏
        traceProof nm result
        return ‚ü®Œ∏, result‚ü©
    | .coherenceComp _ _ _ _ _ _ Œ±‚ÇÄ Œ∑ Œ∏ =>
      withTraceNode nm (fun _ => return m!"monoidalComp") do
        let ‚ü®Œ∑', e_Œ∑‚ü© ‚Üê eval nm Œ∑
        let Œ±‚ÇÄ := .structuralAtom <| .coherenceHom Œ±‚ÇÄ
        let Œ± ‚Üê nilM Œ±‚ÇÄ
        let ‚ü®Œ∏', e_Œ∏‚ü© ‚Üê eval nm Œ∏
        let ‚ü®Œ±Œ∏, e_Œ±Œ∏‚ü© ‚Üê evalComp Œ± Œ∏'
        let ‚ü®Œ∑Œ±Œ∏, e_Œ∑Œ±Œ∏‚ü© ‚Üê evalComp Œ∑' Œ±Œ∏
        let result ‚Üê mkEvalMonoidalComp Œ∑ Œ∏ Œ±‚ÇÄ Œ∑' Œ∏' Œ±Œ∏ Œ∑Œ±Œ∏ e_Œ∑ e_Œ∏ e_Œ±Œ∏ e_Œ∑Œ±Œ∏
        traceProof nm result
        return ‚ü®Œ∑Œ±Œ∏, result‚ü©
    | .horizontalComp _ _ _ _ _ _ Œ∑ Œ∏ =>
      withTraceNode nm (fun _ => return m!"horizontalComp") do
        let ‚ü®Œ∑', e_Œ∑‚ü© ‚Üê eval nm Œ∑
        let ‚ü®Œ∏', e_Œ∏‚ü© ‚Üê eval nm Œ∏
        let ‚ü®Œ∑Œ∏, e_Œ∑Œ∏‚ü© ‚Üê evalHorizontalComp Œ∑' Œ∏'
        let result ‚Üê mkEvalHorizontalComp Œ∑ Œ∏ Œ∑' Œ∏' Œ∑Œ∏ e_Œ∑ e_Œ∏ e_Œ∑Œ∏
        traceProof nm result
        return ‚ü®Œ∑Œ∏, result‚ü©
    | .of Œ∑  =>
      let result ‚Üê mkEvalOf Œ∑
      traceProof nm result
      return ‚ü®‚Üê NormalExpr.ofAtomM Œ∑, result‚ü©

end

end Mathlib.Tactic.BicategoryLike
