/-
Copyright (c) 2024 Yuma Mizuno. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yuma Mizuno
-/
import Mathlib.Tactic.CategoryTheory.Coherence.PureCoherence
import Mathlib.Tactic.CategoryTheory.BicategoricalComp

/-!
# Normalization of morphisms in monoidal categories
This file provides a tactic that normalizes morphisms in monoidal categories. This is used in the
string diagram widget given in `Mathlib.Tactic.StringDiagram`.
We say that the morphism `Œ∑` in a monoidal category is in normal form if
1. `Œ∑` is of the form `Œ±‚ÇÄ ‚â´ Œ∑‚ÇÄ ‚â´ Œ±‚ÇÅ ‚â´ Œ∑‚ÇÅ ‚â´ ... Œ±‚Çò ‚â´ Œ∑‚Çò ‚â´ Œ±‚Çò‚Çä‚ÇÅ` where each `Œ±·µ¢` is a
  structural 2-morphism (consisting of associators and unitors),
2. each `Œ∑·µ¢` is a non-structural 2-morphism of the form `f‚ÇÅ ‚óÅ ... ‚óÅ f‚Çò ‚óÅ Œ∏`, and
3. `Œ∏` is of the form `Œπ ‚ñ∑ g‚ÇÅ ‚ñ∑ ... ‚ñ∑ g‚Çó`

Note that the structural morphisms `Œ±·µ¢` are not necessarily normalized, as the main purpose
is to get a list of the non-structural morphisms out.

Currently, the primary application of the normalization tactic in mind is drawing string diagrams,
which are graphical representations of morphisms in monoidal categories, in the infoview. When
drawing string diagrams, we often ignore associators and unitors (i.e., drawing morphisms in
strict monoidal categories). On the other hand, in Lean, it is considered difficult to formalize
the concept of strict monoidal categories due to the feature of dependent type theory. The
normalization tactic can remove associators and unitors from the expression, extracting the
necessary data for drawing string diagrams.

The current plan on drawing string diagrams (#10581) is to use
Penrose (https://github.com/penrose) via ProofWidget. However, it should be noted that the
normalization procedure in this file does not rely on specific settings, allowing for broader
application.

Future plans include the following. At least I (Yuma) would like to work on these in the future,
but it might not be immediate. If anyone is interested, I would be happy to discuss.

- Currently (#10581), the string diagrams only do drawing. It would be better they also generate
  proofs. That is, by manipulating the string diagrams displayed in the infoview with a mouse to
  generate proofs. In #10581, the string diagram widget only uses the morphisms generated by the
  normalization tactic and does not use proof terms ensuring that the original morphism and the
  normalized morphism are equal. Proof terms will be necessary for proof generation.

- There is also the possibility of using homotopy.io (https://github.com/homotopy-io), a graphical
  proof assistant for category theory, from Lean. At this point, I have very few ideas regarding
  this approach.

- The normalization tactic allows for an alternative implementation of the coherent tactic.

## Main definitions
- `Tactic.Monoidal.eval`: Given a Lean expression `e` that represents a morphism in a monoidal
category, this function returns a pair of `‚ü®e', pf‚ü©` where `e'` is the normalized expression of `e`
and `pf` is a proof that `e = e'`.

-/

open Lean Meta Elab Qq
open CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory

namespace Mathlib.Tactic

namespace Bicategory

/-- The domain of a morphism. -/
def srcExpr (Œ∑ : Expr) : MetaM Expr := do
  match (‚Üê whnfR (‚Üê inferType Œ∑)).getAppFnArgs with
  | (``Quiver.Hom, #[_, _, f, _]) => return f
  | _ => throwError m!"{Œ∑} is not a morphism"

def srcExpr? (Œ∑ : Expr) : MetaM (Option Expr) := do
  try return some (‚Üê srcExpr Œ∑)
  catch _ => return none

/-- The codomain of a morphism. -/
def tgtExpr (Œ∑ : Expr) : MetaM Expr := do
  match (‚Üê whnfR (‚Üê inferType Œ∑)).getAppFnArgs with
  | (``Quiver.Hom, #[_, _, _, g]) => return g
  | _ => throwError m!"{Œ∑} is not a morphism"

def tgtExpr? (Œ∑ : Expr) : MetaM (Option Expr) := do
  try return some (‚Üê tgtExpr Œ∑)
  catch _ => return none

/-- The domain of an isomorphism. -/
def srcExprOfIso (Œ∑ : Expr) : MetaM Expr := do
  match (‚Üê whnfR (‚Üê inferType Œ∑)).getAppFnArgs with
  | (``Iso, #[_, _, f, _]) => return f
  | _ => throwError m!"{Œ∑} is not a morphism"

/-- The codomain of an isomorphism. -/
def tgtExprOfIso (Œ∑ : Expr) : MetaM Expr := do
  match (‚Üê whnfR (‚Üê inferType Œ∑)).getAppFnArgs with
  | (``Iso, #[_, _, _, g]) => return g
  | _ => throwError m!"{Œ∑} is not a morphism"

initialize registerTraceClass `bicategory

/-- The context for evaluating expressions. -/
structure Context where
  level‚ÇÇ : Level
  level‚ÇÅ : Level
  level‚ÇÄ : Level
  /-- The expression for the underlying category. -/
  B : Q(Type level‚ÇÄ)
  instBicategory : Q(Bicategory.{level‚ÇÇ, level‚ÇÅ} $B)

/-- Populate a `context` object for evaluating `e`. -/
def mkContext? (e : Expr) : MetaM (Option Context) := do
  let e ‚Üê instantiateMVars e
  let type ‚Üê instantiateMVars <| ‚Üê inferType e
  match (‚Üê whnfR (‚Üê inferType e)).getAppFnArgs with
  | (``Quiver.Hom, #[_, _, f, _]) =>
    let fType ‚Üê instantiateMVars <| ‚Üê inferType f
    match (‚Üê whnfR fType).getAppFnArgs with
    | (``Quiver.Hom, #[_, _, a, _]) =>
      let B ‚Üê inferType a
      let .succ level‚ÇÄ ‚Üê getLevel B | return none
      let .succ level‚ÇÅ ‚Üê getLevel fType | return none
      let .succ level‚ÇÇ ‚Üê getLevel type | return none
      let .some instBicategory ‚Üê synthInstance?
        (mkAppN (.const ``Bicategory [level‚ÇÇ, level‚ÇÅ, level‚ÇÄ]) #[B]) | return none
      return some ‚ü®level‚ÇÇ, level‚ÇÅ, level‚ÇÄ, B, instBicategory‚ü©
    | _ => return none
  | _ => return none

instance : BicategoryLike.Context Bicategory.Context where
  mkContext? := Bicategory.mkContext?

/-- The monad for the normalization of 2-morphisms. -/
abbrev BicategoryM := CoherenceM Context

instance : MonadMor‚ÇÅ BicategoryM where
  id‚ÇÅM a := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    have a_e : Q($ctx.B) := a.e
    return .id q(ùüô $a_e) a
  comp‚ÇÅM f g := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    have a : Q($ctx.B) := f.src.e
    have b : Q($ctx.B) := f.tgt.e
    have c : Q($ctx.B) := g.tgt.e
    have f_e : Q($a ‚ü∂ $b) := f.e
    have g_e : Q($b ‚ü∂ $c) := g.e
    return .comp q($f_e ‚â´ $g_e) f g

section

open Bicategory

universe w v u
variable {B : Type u} [Bicategory.{w, v} B] {a b c d e : B}

theorem structuralIso_inv {f g : a ‚ü∂ b} (Œ∑ : f ‚âÖ g) :
    Œ∑.symm.hom = Œ∑.inv := by
  simp only [Iso.symm_hom]

theorem structuralIsoOfExpr_comp {f g h : a ‚ü∂ b}
    (Œ∑ : f ‚ü∂ g) (Œ∑' : f ‚âÖ g) (ih_Œ∑ : Œ∑'.hom = Œ∑)
    (Œ∏ : g ‚ü∂ h) (Œ∏' : g ‚âÖ h) (ih_Œ∏ : Œ∏'.hom = Œ∏) :
    (Œ∑' ‚â™‚â´ Œ∏').hom  = Œ∑ ‚â´ Œ∏ := by
  simp [ih_Œ∑, ih_Œ∏]

theorem structuralIsoOfExpr_whiskerLeft (f : a ‚ü∂ b) {g h : b ‚ü∂ c}
    (Œ∑ : g ‚ü∂ h) (Œ∑' : g ‚âÖ h) (ih_Œ∑ : Œ∑'.hom = Œ∑)  :
    (whiskerLeftIso f Œ∑').hom = f ‚óÅ Œ∑ := by
  simp [ih_Œ∑]

theorem structuralIsoOfExpr_whiskerRight {f g : a ‚ü∂ b} (h : b ‚ü∂ c)
    (Œ∑ : f ‚ü∂ g) (Œ∑' : f ‚âÖ g) (ih_Œ∑ : Œ∑'.hom = Œ∑)  :
    (whiskerRightIso Œ∑' h).hom = Œ∑ ‚ñ∑ h := by
  simp [ih_Œ∑]

theorem StructuralOfExpr_bicategoricalComp {f g h i : a ‚ü∂ b} [BicategoricalCoherence g h]
    (Œ∑ : f ‚ü∂ g) (Œ∑' : f ‚âÖ g) (ih_Œ∑ : Œ∑'.hom = Œ∑) (Œ∏ : h ‚ü∂ i) (Œ∏' : h ‚âÖ i) (ih_Œ∏ : Œ∏'.hom = Œ∏) :
    (bicategoricalIsoComp Œ∑' Œ∏').hom = Œ∑ ‚äó‚â´ Œ∏ := by
  simp [ih_Œ∑, ih_Œ∏, bicategoricalIsoComp, bicategoricalComp]

end

open Bicategory
open MonadMor‚ÇÅ

instance : MonadStructuralAtom BicategoryM where
  associatorM f g h := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    have a : Q($ctx.B) := f.src.e
    have b : Q($ctx.B) := f.tgt.e
    have c : Q($ctx.B) := g.tgt.e
    have d : Q($ctx.B) := h.tgt.e
    have f_e : Q($a ‚ü∂ $b) := f.e
    have g_e : Q($b ‚ü∂ $c) := g.e
    have h_e : Q($c ‚ü∂ $d) := h.e
    return .associator q(Œ±_ $f_e $g_e $h_e) f g h
  leftUnitorM f := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    have a : Q($ctx.B) := f.src.e
    have b : Q($ctx.B) := f.tgt.e
    have f_e : Q($a ‚ü∂ $b) := f.e
    return .leftUnitor q(Œª_ $f_e) f
  rightUnitorM f := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    have a : Q($ctx.B) := f.src.e
    have b : Q($ctx.B) := f.tgt.e
    have f_e : Q($a ‚ü∂ $b) := f.e
    return .rightUnitor q(œÅ_ $f_e) f
  id‚ÇÇM f := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    have a : Q($ctx.B) := f.src.e
    have b : Q($ctx.B) := f.tgt.e
    have f_e : Q($a ‚ü∂ $b) := f.e
    return .id q(Iso.refl $f_e) f
  coherenceHomM f g inst := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    have a : Q($ctx.B) := f.src.e
    have b : Q($ctx.B) := f.tgt.e
    have f_e : Q($a ‚ü∂ $b) := f.e
    have g_e : Q($a ‚ü∂ $b) := g.e
    have inst : Q(BicategoricalCoherence $f_e $g_e) := inst
    match (‚Üê whnfI inst).getAppFnArgs with
    | (``BicategoricalCoherence.mk, #[_, _, _, _, _, _, Œ±]) =>
      let e : Q($f_e ‚âÖ $g_e) := q(BicategoricalCoherence.iso)
      return ‚ü®e, f, g, inst, Œ±‚ü©
    | _ => throwError m!"failed to unfold {inst}"

instance : MonadMor‚ÇÇIso BicategoryM where
  comp‚ÇÇM Œ∑ Œ∏ := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    let f ‚Üê Œ∑.srcM
    let g ‚Üê Œ∑.tgtM
    let h ‚Üê Œ∏.tgtM
    have a : Q($ctx.B) := f.src.e
    have b : Q($ctx.B) := f.tgt.e
    have f_e : Q($a ‚ü∂ $b) := f.e
    have g_e : Q($a ‚ü∂ $b) := g.e
    have h_e : Q($a ‚ü∂ $b) := h.e
    have Œ∑_e : Q($f_e ‚âÖ $g_e) := Œ∑.e
    have Œ∏_e : Q($g_e ‚âÖ $h_e) := Œ∏.e
    return .comp q($Œ∑_e ‚â™‚â´ $Œ∏_e) f g h Œ∑ Œ∏
  whiskerLeftM f Œ∑ := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    let g ‚Üê Œ∑.srcM
    let h ‚Üê Œ∑.tgtM
    have a : Q($ctx.B) := f.src.e
    have b : Q($ctx.B) := f.tgt.e
    have c : Q($ctx.B) := g.tgt.e
    have f_e : Q($a ‚ü∂ $b) := f.e
    have g_e : Q($b ‚ü∂ $c) := g.e
    have h_e : Q($b ‚ü∂ $c) := h.e
    have Œ∑_e : Q($g_e ‚âÖ $h_e) := Œ∑.e
    return .whiskerLeft q(whiskerLeftIso $f_e $Œ∑_e) f g h Œ∑
  whiskerRightM Œ∑ h := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    let f ‚Üê Œ∑.srcM
    let g ‚Üê Œ∑.tgtM
    have a : Q($ctx.B) := f.src.e
    have b : Q($ctx.B) := f.tgt.e
    have c : Q($ctx.B) := h.tgt.e
    have f_e : Q($a ‚ü∂ $b) := f.e
    have g_e : Q($a ‚ü∂ $b) := g.e
    have h_e : Q($b ‚ü∂ $c) := h.e
    have Œ∑_e : Q($f_e ‚âÖ $g_e) := Œ∑.e
    return .whiskerRight q(whiskerRightIso $Œ∑_e $h_e) f g Œ∑ h
  horizontalCompM _ _ := throwError "horizontal composition is not implemented"
  symmM Œ∑ := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    let f ‚Üê Œ∑.srcM
    let g ‚Üê Œ∑.tgtM
    have a : Q($ctx.B) := f.src.e
    have b : Q($ctx.B) := f.tgt.e
    have f_e : Q($a ‚ü∂ $b) := f.e
    have g_e : Q($a ‚ü∂ $b) := g.e
    have Œ∑_e : Q($f_e ‚âÖ $g_e) := Œ∑.e
    return .inv q(Iso.symm $Œ∑_e) f g Œ∑
  coherenceCompM Œ± Œ∑ Œ∏ := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    let f ‚Üê Œ∑.srcM
    let g ‚Üê Œ∑.tgtM
    let h ‚Üê Œ∏.srcM
    let i ‚Üê Œ∏.tgtM
    have a : Q($ctx.B) := f.src.e
    have b : Q($ctx.B) := f.tgt.e
    have f_e : Q($a ‚ü∂ $b) := f.e
    have g_e : Q($a ‚ü∂ $b) := g.e
    have h_e : Q($a ‚ü∂ $b) := h.e
    have i_e : Q($a ‚ü∂ $b) := i.e
    have _inst : Q(BicategoricalCoherence $g_e $h_e) := Œ±.inst
    have Œ∑_e : Q($f_e ‚âÖ $g_e) := Œ∑.e
    have Œ∏_e : Q($h_e ‚âÖ $i_e) := Œ∏.e
    return .coherenceComp q($Œ∑_e ‚â™‚äó‚â´ $Œ∏_e) f g h i Œ± Œ∑ Œ∏

instance : MonadMor‚ÇÇ BicategoryM where
  homM Œ∑ := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    let f ‚Üê Œ∑.srcM
    let g ‚Üê Œ∑.tgtM
    have a : Q($ctx.B) := f.src.e
    have b : Q($ctx.B) := f.tgt.e
    have f_e : Q($a ‚ü∂ $b) := f.e
    have g_e : Q($a ‚ü∂ $b) := g.e
    have Œ∑_e : Q($f_e ‚âÖ $g_e) := Œ∑.e
    let e : Q($f_e ‚ü∂ $g_e) := q(Iso.hom $Œ∑_e)
    have eq : Q(Iso.hom $Œ∑_e = $e) := q(rfl)
    return .isoHom q(Iso.hom $Œ∑_e) ‚ü®Œ∑, eq‚ü© Œ∑
  atomHomM Œ∑ := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    let f := Œ∑.src
    let g := Œ∑.tgt
    have a : Q($ctx.B) := f.src.e
    have b : Q($ctx.B) := f.tgt.e
    have f_e : Q($a ‚ü∂ $b) := f.e
    have g_e : Q($a ‚ü∂ $b) := g.e
    have Œ∑_e : Q($f_e ‚âÖ $g_e) := Œ∑.e
    return .mk q(Iso.hom $Œ∑_e) f g
  invM Œ∑ := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    let f ‚Üê Œ∑.srcM
    let g ‚Üê Œ∑.tgtM
    have a : Q($ctx.B) := f.src.e
    have b : Q($ctx.B) := f.tgt.e
    have f_e : Q($a ‚ü∂ $b) := f.e
    have g_e : Q($a ‚ü∂ $b) := g.e
    have Œ∑_e : Q($f_e ‚âÖ $g_e) := Œ∑.e
    let e : Q($g_e ‚ü∂ $f_e) := q(Iso.inv $Œ∑_e)
    let Œ∑_inv ‚Üê Mor‚ÇÇIso.symmM Œ∑
    let eq : Q(Iso.inv $Œ∑_e = $e) := q(Iso.symm_hom $Œ∑_e)
    return .isoInv e ‚ü®Œ∑_inv, eq‚ü© Œ∑
  atomInvM Œ∑ := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    let f := Œ∑.src
    let g := Œ∑.tgt
    have a : Q($ctx.B) := f.src.e
    have b : Q($ctx.B) := f.tgt.e
    have f_e : Q($a ‚ü∂ $b) := f.e
    have g_e : Q($a ‚ü∂ $b) := g.e
    have Œ∑_e : Q($f_e ‚âÖ $g_e) := Œ∑.e
    return .mk q(Iso.inv $Œ∑_e) g f
  id‚ÇÇM f := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    have a : Q($ctx.B) := f.src.e
    have b : Q($ctx.B) := f.tgt.e
    have f_e : Q($a ‚ü∂ $b) := f.e
    let e : Q($f_e ‚ü∂ $f_e) := q(ùüô $f_e)
    let eq : Q(ùüô $f_e = $e) := q(Iso.refl_hom $f_e)
    return .id e ‚ü®.structuralAtom <| ‚Üê StructuralAtom.id‚ÇÇM f, eq‚ü© f
  comp‚ÇÇM Œ∑ Œ∏ := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    let f ‚Üê Œ∑.srcM
    let g ‚Üê Œ∑.tgtM
    let h ‚Üê Œ∏.tgtM
    have a : Q($ctx.B) := f.src.e
    have b : Q($ctx.B) := f.tgt.e
    have f_e : Q($a ‚ü∂ $b) := f.e
    have g_e : Q($a ‚ü∂ $b) := g.e
    have h_e : Q($a ‚ü∂ $b) := h.e
    have Œ∑_e : Q($f_e ‚ü∂ $g_e) := Œ∑.e
    have Œ∏_e : Q($g_e ‚ü∂ $h_e) := Œ∏.e
    let iso_lift? ‚Üê (match (Œ∑.isoLift?, Œ∏.isoLift?) with
      | (some Œ∑_iso, some Œ∏_iso) =>
        have Œ∑_iso_e : Q($f_e ‚âÖ $g_e) := Œ∑_iso.iso.e
        have Œ∏_iso_e : Q($g_e ‚âÖ $h_e) := Œ∏_iso.iso.e
        have Œ∑_iso_eq : Q(Iso.hom $Œ∑_iso_e = $Œ∑_e) := Œ∑_iso.eq
        have Œ∏_iso_eq : Q(Iso.hom $Œ∏_iso_e = $Œ∏_e) := Œ∏_iso.eq
        let eq := q(structuralIsoOfExpr_comp _ _ $Œ∑_iso_eq _ _ $Œ∏_iso_eq)
        return .some ‚ü®‚Üê Mor‚ÇÇIso.comp‚ÇÇM Œ∑_iso.iso Œ∏_iso.iso, eq‚ü©
      | _ => return none)
    let e : Q($f_e ‚ü∂ $h_e) := q($Œ∑_e ‚â´ $Œ∏_e)
    return .comp e iso_lift? f g h Œ∑ Œ∏
  whiskerLeftM f Œ∑ := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    let g ‚Üê Œ∑.srcM
    let h ‚Üê Œ∑.tgtM
    have a : Q($ctx.B) := f.src.e
    have b : Q($ctx.B) := f.tgt.e
    have c : Q($ctx.B) := g.tgt.e
    have f_e : Q($a ‚ü∂ $b) := f.e
    have g_e : Q($b ‚ü∂ $c) := g.e
    have h_e : Q($b ‚ü∂ $c) := h.e
    have Œ∑_e : Q($g_e ‚ü∂ $h_e) := Œ∑.e
    let iso_lift? ‚Üê (match Œ∑.isoLift? with
      | some Œ∑_iso => do
        have Œ∑_iso_e : Q($g_e ‚âÖ $h_e) := Œ∑_iso.iso.e
        have Œ∑_iso_eq : Q(Iso.hom $Œ∑_iso_e = $Œ∑_e) := Œ∑_iso.eq
        let eq := q(structuralIsoOfExpr_whiskerLeft $f_e _ _ $Œ∑_iso_eq)
        return .some ‚ü®‚Üê Mor‚ÇÇIso.whiskerLeftM f Œ∑_iso.iso, eq‚ü©
      | _ => return none)
    let e : Q($f_e ‚â´ $g_e ‚ü∂ $f_e ‚â´ $h_e) := q($f_e ‚óÅ $Œ∑_e)
    return .whiskerLeft e iso_lift? f g h Œ∑
  whiskerRightM Œ∑ h := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    let f ‚Üê Œ∑.srcM
    let g ‚Üê Œ∑.tgtM
    have a : Q($ctx.B) := f.src.e
    have b : Q($ctx.B) := h.src.e
    have c : Q($ctx.B) := h.tgt.e
    have f_e : Q($a ‚ü∂ $b) := f.e
    have g_e : Q($a ‚ü∂ $b) := g.e
    have h_e : Q($b ‚ü∂ $c) := h.e
    have Œ∑_e : Q($f_e ‚ü∂ $g_e) := Œ∑.e
    let iso_lift? ‚Üê (match Œ∑.isoLift? with
      | some Œ∑_iso => do
        have Œ∑_iso_e : Q($f_e ‚âÖ $g_e) := Œ∑_iso.iso.e
        have Œ∑_iso_eq : Q(Iso.hom $Œ∑_iso_e = $Œ∑_e) := Œ∑_iso.eq
        let eq := q(structuralIsoOfExpr_whiskerRight $h_e _ _ $Œ∑_iso_eq)
        return .some ‚ü®‚Üê Mor‚ÇÇIso.whiskerRightM Œ∑_iso.iso h, eq‚ü©
      | _ => return none)
    let e : Q($f_e ‚â´ $h_e ‚ü∂ $g_e ‚â´ $h_e) := q($Œ∑_e ‚ñ∑ $h_e)
    return .whiskerRight e iso_lift? f g Œ∑ h
  horizontalCompM _ _ := throwError "horizontal composition is not implemented"
  coherenceCompM Œ± Œ∑ Œ∏ := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    let f ‚Üê Œ∑.srcM
    let g ‚Üê Œ∑.tgtM
    let h ‚Üê Œ∏.srcM
    let i ‚Üê Œ∏.tgtM
    have a : Q($ctx.B) := f.src.e
    have b : Q($ctx.B) := f.tgt.e
    have f_e : Q($a ‚ü∂ $b) := f.e
    have g_e : Q($a ‚ü∂ $b) := g.e
    have h_e : Q($a ‚ü∂ $b) := h.e
    have i_e : Q($a ‚ü∂ $b) := i.e
    have _inst : Q(BicategoricalCoherence $g_e $h_e) := Œ±.inst
    have Œ∑_e : Q($f_e ‚ü∂ $g_e) := Œ∑.e
    have Œ∏_e : Q($h_e ‚ü∂ $i_e) := Œ∏.e
    let iso_lift? ‚Üê (match (Œ∑.isoLift?, Œ∏.isoLift?) with
      | (some Œ∑_iso, some Œ∏_iso) => do
        have Œ∑_iso_e : Q($f_e ‚âÖ $g_e) := Œ∑_iso.iso.e
        have Œ∏_iso_e : Q($h_e ‚âÖ $i_e) := Œ∏_iso.iso.e
        have Œ∑_iso_eq : Q(Iso.hom $Œ∑_iso_e = $Œ∑_e) := Œ∑_iso.eq
        have Œ∏_iso_eq : Q(Iso.hom $Œ∏_iso_e = $Œ∏_e) := Œ∏_iso.eq
        let eq := q(StructuralOfExpr_bicategoricalComp _ _ $Œ∑_iso_eq _ _ $Œ∏_iso_eq)
        return .some ‚ü®‚Üê MonadMor‚ÇÇIso.coherenceCompM Œ± Œ∑_iso.iso Œ∏_iso.iso, eq‚ü©
      | _ => return none)
    let e : Q($f_e ‚ü∂ $i_e) := q($Œ∑_e ‚äó‚â´ $Œ∏_e)
    return .coherenceComp e iso_lift? f g h i Œ± Œ∑ Œ∏

section

open Bicategory

universe w v u

variable {B : Type u} [Bicategory.{w, v} B] {a b c d e : B}

local infixr:81 " ‚óÅ " => Bicategory.whiskerLeftIso
local infixl:81 " ‚ñ∑ " => Bicategory.whiskerRightIso

abbrev normalizeIsoComp {p : a ‚ü∂ b} {f : b ‚ü∂ c} {g : c ‚ü∂ d} {pf : a ‚ü∂ c} {pfg : a ‚ü∂ d}
    (Œ∑_f : p ‚â´ f ‚âÖ pf) (Œ∑_g : pf ‚â´ g ‚âÖ pfg) :=
  (Œ±_ _ _ _).symm ‚â™‚â´ whiskerRightIso Œ∑_f g ‚â™‚â´ Œ∑_g

theorem naturality_associator
    {p : a ‚ü∂ b} {f : b ‚ü∂ c} {g : c ‚ü∂ d} {h : d ‚ü∂ e} {pf : a ‚ü∂ c} {pfg : a ‚ü∂ d} {pfgh : a ‚ü∂ e}
    (Œ∑_f : p ‚â´ f ‚âÖ pf) (Œ∑_g : pf ‚â´ g ‚âÖ pfg) (Œ∑_h : pfg ‚â´ h ‚âÖ pfgh) :
    p ‚óÅ (Œ±_ f g h) ‚â™‚â´ (normalizeIsoComp Œ∑_f (normalizeIsoComp Œ∑_g Œ∑_h)) =
    (normalizeIsoComp (normalizeIsoComp Œ∑_f Œ∑_g) Œ∑_h) :=
  Iso.ext (by simp)

theorem naturality_leftUnitor {p : a ‚ü∂ b} {f : b ‚ü∂ c} {pf : a ‚ü∂ c} (Œ∑_f : p ‚â´ f ‚âÖ pf) :
    p ‚óÅ (Œª_ f) ‚â™‚â´ Œ∑_f = normalizeIsoComp (œÅ_ p) Œ∑_f :=
  Iso.ext (by simp)

theorem naturality_rightUnitor {p : a ‚ü∂ b} {f : b ‚ü∂ c} {pf : a ‚ü∂ c} (Œ∑_f : p ‚â´ f ‚âÖ pf) :
    p ‚óÅ (œÅ_ f) ‚â™‚â´ Œ∑_f = normalizeIsoComp Œ∑_f (œÅ_ pf) :=
  Iso.ext (by simp)

theorem naturality_id {p : a ‚ü∂ b} {f : b ‚ü∂ c} {pf : a ‚ü∂ c} (Œ∑_f : p ‚â´ f ‚âÖ pf) :
    p ‚óÅ Iso.refl f ‚â™‚â´ Œ∑_f = Œ∑_f :=
  Iso.ext (by simp)

theorem naturality_comp {p : a ‚ü∂ b} {f g h : b ‚ü∂ c} {pf : a ‚ü∂ c} {Œ∑ : f ‚âÖ g} {Œ∏ : g ‚âÖ h}
    (Œ∑_f : p ‚â´ f ‚âÖ pf) (Œ∑_g : p ‚â´ g ‚âÖ pf) (Œ∑_h : p ‚â´ h ‚âÖ pf)
    (ih_Œ∑ : p ‚óÅ Œ∑ ‚â™‚â´ Œ∑_g = Œ∑_f) (ih_Œ∏ : p ‚óÅ Œ∏ ‚â™‚â´ Œ∑_h = Œ∑_g) :
    p ‚óÅ (Œ∑ ‚â™‚â´ Œ∏) ‚â™‚â´ Œ∑_h = Œ∑_f := by
  rw [‚Üê ih_Œ∑, ‚Üê ih_Œ∏]
  apply Iso.ext (by simp)

theorem naturality_whiskerLeft {p : a ‚ü∂ b} {f : b ‚ü∂ c} {g h : c ‚ü∂ d} {pf : a ‚ü∂ c} {pfg : a ‚ü∂ d}
    {Œ∑ : g ‚âÖ h} (Œ∑_f : p ‚â´ f ‚âÖ pf) (Œ∑_fg : pf ‚â´ g ‚âÖ pfg) (Œ∑_fh : pf ‚â´ h ‚âÖ pfg)
    (ih_Œ∑ : pf ‚óÅ Œ∑ ‚â™‚â´ Œ∑_fh = Œ∑_fg) :
    p ‚óÅ (f ‚óÅ Œ∑) ‚â™‚â´ normalizeIsoComp Œ∑_f Œ∑_fh = normalizeIsoComp Œ∑_f Œ∑_fg := by
  rw [‚Üê ih_Œ∑]
  apply Iso.ext (by simp [‚Üê whisker_exchange_assoc])

theorem naturality_whiskerRight {p : a ‚ü∂ b} {f g : b ‚ü∂ c} {h : c ‚ü∂ d} {pf : a ‚ü∂ c} {pfh : a ‚ü∂ d}
    {Œ∑ : f ‚âÖ g} (Œ∑_f : p ‚â´ f ‚âÖ pf) (Œ∑_g : p ‚â´ g ‚âÖ pf) (Œ∑_fh : pf ‚â´ h ‚âÖ pfh)
    (ih_Œ∑ : p ‚óÅ Œ∑ ‚â™‚â´ Œ∑_g = Œ∑_f) :
    p ‚óÅ (Œ∑ ‚ñ∑ h) ‚â™‚â´ normalizeIsoComp Œ∑_g Œ∑_fh = normalizeIsoComp Œ∑_f Œ∑_fh := by
  rw [‚Üê ih_Œ∑]
  apply Iso.ext (by simp)

theorem naturality_inv {p : a ‚ü∂ b} {f g : b ‚ü∂ c} {pf : a ‚ü∂ c}
    {Œ∑ : f ‚âÖ g} (Œ∑_f : p ‚â´ f ‚âÖ pf) (Œ∑_g : p ‚â´ g ‚âÖ pf) (ih : p ‚óÅ Œ∑ ‚â™‚â´ Œ∑_g = Œ∑_f) :
    p ‚óÅ Œ∑.symm ‚â™‚â´ Œ∑_f = Œ∑_g := by
  rw [‚Üê ih]
  apply Iso.ext (by simp)

open Qq

set_option autoImplicit false

instance : MonadNormalizeNaturality BicategoryM where
  mkNaturalityAssociator p pf pfg pfgh f g h Œ∑_f Œ∑_g Œ∑_h := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    have a : Q($ctx.B) := p.src.e
    have b : Q($ctx.B) := p.tgt.e
    have c : Q($ctx.B) := f.tgt.e
    have d : Q($ctx.B) := g.tgt.e
    have e : Q($ctx.B) := h.tgt.e
    have p : Q($a ‚ü∂ $b) := p.e.e
    have f : Q($b ‚ü∂ $c) := f.e
    have g : Q($c ‚ü∂ $d) := g.e
    have h : Q($d ‚ü∂ $e) := h.e
    have pf : Q($a ‚ü∂ $c) := pf.e.e
    have pfg : Q($a ‚ü∂ $d) := pfg.e.e
    have pfgh : Q($a ‚ü∂ $e) := pfgh.e.e
    have Œ∑_f : Q($p ‚â´ $f ‚âÖ $pf) := Œ∑_f.e
    have Œ∑_g : Q($pf ‚â´ $g ‚âÖ $pfg) := Œ∑_g.e
    have Œ∑_h : Q($pfg ‚â´ $h ‚âÖ $pfgh) := Œ∑_h.e
    return q(naturality_associator $Œ∑_f $Œ∑_g $Œ∑_h)
  mkNaturalityLeftUnitor p pf f Œ∑_f := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    have a : Q($ctx.B) := p.src.e
    have b : Q($ctx.B) := p.tgt.e
    have c : Q($ctx.B) := f.tgt.e
    have p : Q($a ‚ü∂ $b) := p.e.e
    have f : Q($b ‚ü∂ $c) := f.e
    have pf : Q($a ‚ü∂ $c) := pf.e.e
    have Œ∑_f : Q($p ‚â´ $f ‚âÖ $pf) := Œ∑_f.e
    return q(naturality_leftUnitor $Œ∑_f)
  mkNaturalityRightUnitor p pf f Œ∑_f := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    have a : Q($ctx.B) := p.src.e
    have b : Q($ctx.B) := p.tgt.e
    have c : Q($ctx.B) := f.tgt.e
    have p : Q($a ‚ü∂ $b) := p.e.e
    have f : Q($b ‚ü∂ $c) := f.e
    have pf : Q($a ‚ü∂ $c) := pf.e.e
    have Œ∑_f : Q($p ‚â´ $f ‚âÖ $pf) := Œ∑_f.e
    return q(naturality_rightUnitor $Œ∑_f)
  mkNaturalityId p pf f Œ∑_f := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    have a : Q($ctx.B) := p.src.e
    have b : Q($ctx.B) := p.tgt.e
    have c : Q($ctx.B) := f.tgt.e
    have p : Q($a ‚ü∂ $b) := p.e.e
    have f : Q($b ‚ü∂ $c) := f.e
    have pf : Q($a ‚ü∂ $c) := pf.e.e
    have Œ∑_f : Q($p ‚â´ $f ‚âÖ $pf) := Œ∑_f.e
    return q(naturality_id $Œ∑_f)
  mkNaturalityComp p pf f g h Œ∑ Œ∏ Œ∑_f Œ∑_g Œ∑_h ih_Œ∑ ih_Œ∏ := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    have a : Q($ctx.B) := p.src.e
    have b : Q($ctx.B) := p.tgt.e
    have c : Q($ctx.B) := f.tgt.e
    have p : Q($a ‚ü∂ $b) := p.e.e
    have f : Q($b ‚ü∂ $c) := f.e
    have g : Q($b ‚ü∂ $c) := g.e
    have h : Q($b ‚ü∂ $c) := h.e
    have pf : Q($a ‚ü∂ $c) := pf.e.e
    have Œ∑ : Q($f ‚âÖ $g) := Œ∑.e
    have Œ∏ : Q($g ‚âÖ $h) := Œ∏.e
    have Œ∑_f : Q($p ‚â´ $f ‚âÖ $pf) := Œ∑_f.e
    have Œ∑_g : Q($p ‚â´ $g ‚âÖ $pf) := Œ∑_g.e
    have Œ∑_h : Q($p ‚â´ $h ‚âÖ $pf) := Œ∑_h.e
    have ih_Œ∑ : Q($p ‚óÅ $Œ∑ ‚â™‚â´ $Œ∑_g = $Œ∑_f) := ih_Œ∑
    have ih_Œ∏ : Q($p ‚óÅ $Œ∏ ‚â™‚â´ $Œ∑_h = $Œ∑_g) := ih_Œ∏
    return q(naturality_comp $Œ∑_f $Œ∑_g $Œ∑_h $ih_Œ∑ $ih_Œ∏)
  mkNaturalityWhiskerLeft p pf pfg f g h Œ∑ Œ∑_f Œ∑_fg Œ∑_fh ih_Œ∑ := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    have a : Q($ctx.B) := p.src.e
    have b : Q($ctx.B) := p.tgt.e
    have c : Q($ctx.B) := f.tgt.e
    have d : Q($ctx.B) := g.tgt.e
    have p : Q($a ‚ü∂ $b) := p.e.e
    have f : Q($b ‚ü∂ $c) := f.e
    have g : Q($c ‚ü∂ $d) := g.e
    have h : Q($c ‚ü∂ $d) := h.e
    have pf : Q($a ‚ü∂ $c) := pf.e.e
    have pfg : Q($a ‚ü∂ $d) := pfg.e.e
    have Œ∑ : Q($g ‚âÖ $h) := Œ∑.e
    have Œ∑_f : Q($p ‚â´ $f ‚âÖ $pf) := Œ∑_f.e
    have Œ∑_fg : Q($pf ‚â´ $g ‚âÖ $pfg) := Œ∑_fg.e
    have Œ∑_fh : Q($pf ‚â´ $h ‚âÖ $pfg) := Œ∑_fh.e
    have ih_Œ∑ : Q($pf ‚óÅ $Œ∑ ‚â™‚â´ $Œ∑_fh = $Œ∑_fg) := ih_Œ∑
    return q(naturality_whiskerLeft $Œ∑_f $Œ∑_fg $Œ∑_fh $ih_Œ∑)
  mkNaturalityWhiskerRight p pf pfh f g h Œ∑ Œ∑_f Œ∑_g Œ∑_fh ih_Œ∑ := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    have a : Q($ctx.B) := p.src.e
    have b : Q($ctx.B) := p.tgt.e
    have c : Q($ctx.B) := f.tgt.e
    have d : Q($ctx.B) := h.tgt.e
    have p : Q($a ‚ü∂ $b) := p.e.e
    have f : Q($b ‚ü∂ $c) := f.e
    have g : Q($b ‚ü∂ $c) := g.e
    have h : Q($c ‚ü∂ $d) := h.e
    have pf : Q($a ‚ü∂ $c) := pf.e.e
    have pfh : Q($a ‚ü∂ $d) := pfh.e.e
    have Œ∑ : Q($f ‚âÖ $g) := Œ∑.e
    have Œ∑_f : Q($p ‚â´ $f ‚âÖ $pf) := Œ∑_f.e
    have Œ∑_g : Q($p ‚â´ $g ‚âÖ $pf) := Œ∑_g.e
    have Œ∑_fh : Q($pf ‚â´ $h ‚âÖ $pfh) := Œ∑_fh.e
    have ih_Œ∑ : Q($p ‚óÅ $Œ∑ ‚â™‚â´ $Œ∑_g = $Œ∑_f) := ih_Œ∑
    return q(naturality_whiskerRight $Œ∑_f $Œ∑_g $Œ∑_fh $ih_Œ∑)
  mkNaturalityHorizontalComp _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ := do
    throwError "horizontal composition is not implemented"
  mkNaturalityInv p pf f g Œ∑ Œ∑_f Œ∑_g ih := do
    let ctx ‚Üê read
    let _bicat := ctx.instBicategory
    have a : Q($ctx.B) := p.src.e
    have b : Q($ctx.B) := p.tgt.e
    have c : Q($ctx.B) := f.tgt.e
    have p : Q($a ‚ü∂ $b) := p.e.e
    have f : Q($b ‚ü∂ $c) := f.e
    have g : Q($b ‚ü∂ $c) := g.e
    have pf : Q($a ‚ü∂ $c) := pf.e.e
    have Œ∑ : Q($f ‚âÖ $g) := Œ∑.e
    have Œ∑_f : Q($p ‚â´ $f ‚âÖ $pf) := Œ∑_f.e
    have Œ∑_g : Q($p ‚â´ $g ‚âÖ $pf) := Œ∑_g.e
    have ih : Q($p ‚óÅ $Œ∑ ‚â™‚â´ $Œ∑_g = $Œ∑_f) := ih
    return q(naturality_inv $Œ∑_f $Œ∑_g $ih)

theorem of_normalize_eq {f g f' : a ‚ü∂ b} {Œ∑ Œ∏ : f ‚âÖ g} (Œ∑_f : ùüô a ‚â´ f ‚âÖ f') (Œ∑_g : ùüô a ‚â´ g ‚âÖ f')
    (h_Œ∑ : ùüô a ‚óÅ Œ∑ ‚â™‚â´ Œ∑_g = Œ∑_f)
    (h_Œ∏ : ùüô a ‚óÅ Œ∏ ‚â™‚â´ Œ∑_g = Œ∑_f) : Œ∑ = Œ∏ := by
  apply Iso.ext
  calc
    Œ∑.hom = (Œª_ f).inv ‚â´ Œ∑_f.hom ‚â´ Œ∑_g.inv ‚â´ (Œª_ g).hom := by
      simp [‚Üê reassoc_of% (congrArg Iso.hom h_Œ∑)]
    _ = Œ∏.hom := by
      simp [‚Üê reassoc_of% (congrArg Iso.hom h_Œ∏)]

end

def Atom‚ÇÅ.mkM (e : Expr) : MetaM Atom‚ÇÅ := do
  let src ‚Üê srcExpr? e
  let tgt ‚Üê tgtExpr? e
  return ‚ü®e, ‚ü®src‚ü©, ‚ü®tgt‚ü©‚ü©

def isId‚ÇÅ? (e : Expr) : BicategoryM (Option Obj) := do
  let ctx ‚Üê read
  let _bicat := ctx.instBicategory
  let a : Q($ctx.B) ‚Üê mkFreshExprMVar ctx.B
  if ‚Üê withDefault <| isDefEq e q(ùüô $a) then
    return .some ‚ü®‚Üê instantiateMVars a‚ü©
  else
    return none

def isComp‚ÇÅ? (e : Expr) : BicategoryM (Option (Mor‚ÇÅ √ó Mor‚ÇÅ)) := do
  let ctx ‚Üê read
  let _bicat := ctx.instBicategory
  let a ‚Üê mkFreshExprMVarQ ctx.B
  let b ‚Üê mkFreshExprMVarQ ctx.B
  let c ‚Üê mkFreshExprMVarQ ctx.B
  let f ‚Üê mkFreshExprMVarQ q($a ‚ü∂ $b)
  let g ‚Üê mkFreshExprMVarQ q($b ‚ü∂ $c)
  if ‚Üê withDefault <| isDefEq e q($f ‚â´ $g) then
    let a ‚Üê instantiateMVars a
    let b ‚Üê instantiateMVars b
    let c ‚Üê instantiateMVars c
    let f ‚Üê instantiateMVars f
    let g ‚Üê instantiateMVars g
    return .some ((.of ‚ü®f, ‚ü®.some a‚ü©, ‚ü®.some b‚ü©‚ü©), .of ‚ü®g, ‚ü®.some b‚ü©, ‚ü®.some c‚ü©‚ü©)
  else
    return none

/-- Construct a `Mor‚ÇÅ` expression from a Lean expression. -/
partial def mor‚ÇÅOfExpr (e : Expr) : BicategoryM Mor‚ÇÅ := do
  if let some f := (‚Üê get).cache.find? e then
    return f
  let f ‚Üê
    if let some a ‚Üê isId‚ÇÅ? e then
      MonadMor‚ÇÅ.id‚ÇÅM a
    else if let some (f, g) ‚Üê isComp‚ÇÅ? e then
      MonadMor‚ÇÅ.comp‚ÇÅM (‚Üê mor‚ÇÅOfExpr f.e) (‚Üê mor‚ÇÅOfExpr g.e)
    else
      return Mor‚ÇÅ.of (‚Üê Atom‚ÇÅ.mkM e)
  modify fun s => { s with cache := s.cache.insert e f }
  return f

instance : MkMor‚ÇÅ BicategoryM where
  ofExpr := mor‚ÇÅOfExpr

partial def Mor‚ÇÇIsoOfExpr (e : Expr) : BicategoryM Mor‚ÇÇIso := do
  match (‚Üê whnfR e).getAppFnArgs with
  | (``Bicategory.associator, #[_, _, _, _, _, _, f, g, h]) =>
    Mor‚ÇÇIso.associatorM' (‚Üê MkMor‚ÇÅ.ofExpr f) (‚Üê MkMor‚ÇÅ.ofExpr g) (‚Üê MkMor‚ÇÅ.ofExpr h)
  | (``Bicategory.leftUnitor, #[_, _, _, _, f]) =>
    Mor‚ÇÇIso.leftUnitorM' (‚Üê MkMor‚ÇÅ.ofExpr f)
  | (``Bicategory.rightUnitor, #[_, _, _, _, f]) =>
    Mor‚ÇÇIso.rightUnitorM' (‚Üê MkMor‚ÇÅ.ofExpr f)
  | (``Iso.refl, #[_, _, f]) =>
    Mor‚ÇÇIso.id‚ÇÇM' (‚Üê MkMor‚ÇÅ.ofExpr f)
  | (``Iso.symm, #[_, _, _, _, Œ∑]) =>
    Mor‚ÇÇIso.symmM (‚Üê Mor‚ÇÇIsoOfExpr Œ∑)
  | (``Iso.trans, #[_, _, _, _, _, Œ∑, Œ∏]) =>
    Mor‚ÇÇIso.comp‚ÇÇM (‚Üê Mor‚ÇÇIsoOfExpr Œ∑) (‚Üê Mor‚ÇÇIsoOfExpr Œ∏)
  | (``Bicategory.whiskerLeftIso, #[_, _, _, _, _, f, _, _, Œ∑]) =>
    Mor‚ÇÇIso.whiskerLeftM (‚Üê MkMor‚ÇÅ.ofExpr f) (‚Üê Mor‚ÇÇIsoOfExpr Œ∑)
  | (``Bicategory.whiskerRightIso, #[_, _, _, _, _, _, _, Œ∑, h]) =>
    Mor‚ÇÇIso.whiskerRightM (‚Üê Mor‚ÇÇIsoOfExpr Œ∑) (‚Üê MkMor‚ÇÅ.ofExpr h)
  | (``bicategoricalIsoComp, #[_, _, _, _, _, g, h, _, inst, Œ∑, Œ∏]) =>
    let Œ± ‚Üê MonadStructuralAtom.coherenceHomM (‚Üê MkMor‚ÇÅ.ofExpr g) (‚Üê MkMor‚ÇÅ.ofExpr h) inst
    Mor‚ÇÇIso.coherenceCompM Œ± (‚Üê Mor‚ÇÇIsoOfExpr Œ∑) (‚Üê Mor‚ÇÇIsoOfExpr Œ∏)
  | (``BicategoricalCoherence.iso, #[_, _, _, _, f, g, inst]) =>
    Mor‚ÇÇIso.coherenceHomM' (‚Üê MkMor‚ÇÅ.ofExpr f) (‚Üê MkMor‚ÇÅ.ofExpr g) inst
  | _ =>
    return .of ‚ü®e, ‚Üê MkMor‚ÇÅ.ofExpr (‚Üê srcExprOfIso e), ‚Üê MkMor‚ÇÅ.ofExpr (‚Üê tgtExprOfIso e)‚ü©

open MonadMor‚ÇÇ in
partial def Mor‚ÇÇOfExpr (e : Expr) : BicategoryM Mor‚ÇÇ := do
  match ‚Üê whnfR e with
  -- whnfR version of `Iso.hom Œ∑`
  | .proj ``Iso 0 Œ∑ => homM (‚Üê Mor‚ÇÇIsoOfExpr Œ∑)
  -- whnfR version of `Iso.inv Œ∑`
  | .proj ``Iso 1 Œ∑ => invM (‚Üê Mor‚ÇÇIsoOfExpr Œ∑)
  | .app .. => match (‚Üê whnfR e).getAppFnArgs with
    | (``CategoryStruct.id, #[_, _, f]) => id‚ÇÇM (‚Üê MkMor‚ÇÅ.ofExpr f)
    | (``CategoryStruct.comp, #[_, _, _, _, _, Œ∑, Œ∏]) =>
      comp‚ÇÇM (‚Üê Mor‚ÇÇOfExpr Œ∑) (‚Üê Mor‚ÇÇOfExpr Œ∏)
    | (``Bicategory.whiskerLeft, #[_, _, _, _, _, f, _, _, Œ∑]) =>
      whiskerLeftM (‚Üê MkMor‚ÇÅ.ofExpr f) (‚Üê Mor‚ÇÇOfExpr Œ∑)
    | (``Bicategory.whiskerRight, #[_, _, _, _, _, _, _, Œ∑, h]) =>
      whiskerRightM (‚Üê Mor‚ÇÇOfExpr Œ∑) (‚Üê MkMor‚ÇÅ.ofExpr h)
    | (``bicategoricalComp, #[_, _, _, _, _, g, h, _, inst, Œ∑, Œ∏]) =>
      let Œ± ‚Üê MonadStructuralAtom.coherenceHomM (‚Üê MkMor‚ÇÅ.ofExpr g) (‚Üê MkMor‚ÇÅ.ofExpr h) inst
      coherenceCompM Œ± (‚Üê Mor‚ÇÇOfExpr Œ∑) (‚Üê Mor‚ÇÇOfExpr Œ∏)
    | _ => return .of ‚ü®e, ‚Üê MkMor‚ÇÅ.ofExpr (‚Üê srcExpr e), ‚Üê MkMor‚ÇÅ.ofExpr (‚Üê tgtExpr e)‚ü©
  | _ =>
    return .of ‚ü®e, ‚Üê MkMor‚ÇÅ.ofExpr (‚Üê srcExpr e), ‚Üê MkMor‚ÇÅ.ofExpr (‚Üê tgtExpr e)‚ü©

instance : BicategoryLike.MkMor‚ÇÇ BicategoryM where
  ofExpr := Mor‚ÇÇOfExpr

instance : MonadCoherehnceHom BicategoryM where
  unfoldM Œ± := Mor‚ÇÇIsoOfExpr Œ±.unfold

universe w v u
variable {B : Type u} [Bicategory.{w, v} B] {a b : B}

open Bicategory

theorem mk_eq_of_normalized_eq {f g f' : a ‚ü∂ b} (Œ∑ Œ∏ : f ‚ü∂ g) (Œ∑' Œ∏' : f ‚âÖ g)
    (Œ∑_f : ùüô a ‚â´ f ‚âÖ f') (Œ∑_g : ùüô a ‚â´ g ‚âÖ f')
    (HŒ∑ : Œ∑'.hom = Œ∑) (HŒ∏ : Œ∏'.hom = Œ∏)
    (HŒ∑' : whiskerLeftIso (ùüô a) Œ∑' ‚â™‚â´ Œ∑_g = Œ∑_f)
    (HŒ∏' : whiskerLeftIso (ùüô a) Œ∏' ‚â™‚â´ Œ∑_g = Œ∑_f) : Œ∑ = Œ∏ :=
  calc
    Œ∑ = Œ∑'.hom := HŒ∑.symm
    _ = (Œª_ f).inv ‚â´ Œ∑_f.hom ‚â´ Œ∑_g.inv ‚â´ (Œª_ g).hom := by
      simp [‚Üê reassoc_of% (congrArg Iso.hom HŒ∑')]
    _ = Œ∏'.hom := by
      simp [‚Üê reassoc_of% (congrArg Iso.hom HŒ∏')]
    _ = Œ∏ := HŒ∏

open Elab.Tactic

def pureCoherence (mvarId : MVarId) : MetaM (List MVarId) :=
  BicategoryLike.pureCoherence `bicategory
    Bicategory.Context (mkAppM ``mk_eq_of_normalized_eq) mvarId

elab "bicategory_coherence" : tactic => withMainContext do
  replaceMainGoal <| ‚Üê Bicategory.pureCoherence <| ‚Üê getMainGoal

end Mathlib.Tactic.Bicategory
