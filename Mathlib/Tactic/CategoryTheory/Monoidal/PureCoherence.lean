/-
Copyright (c) 2024 Yuma Mizuno. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yuma Mizuno
-/
-- import Mathlib.CategoryTheory.Monoidal.Category
import Mathlib.Tactic.CategoryTheory.Coherence.PureCoherence


import Mathlib.Tactic.CategoryTheory.MonoidalComp
-- import Mathlib.Tactic.CategoryTheory.BicategoryLike

/-!
# Normalization of morphisms in monoidal categories
This file provides a tactic that normalizes morphisms in monoidal categories. This is used in the
string diagram widget given in `Mathlib.Tactic.StringDiagram`.
We say that the morphism `Î·` in a monoidal category is in normal form if
1. `Î·` is of the form `Î±â‚€ â‰« Î·â‚€ â‰« Î±â‚ â‰« Î·â‚ â‰« ... Î±â‚˜ â‰« Î·â‚˜ â‰« Î±â‚˜â‚Šâ‚` where each `Î±áµ¢` is a
  structural 2-morphism (consisting of associators and unitors),
2. each `Î·áµ¢` is a non-structural 2-morphism of the form `fâ‚ â— ... â— fâ‚˜ â— Î¸`, and
3. `Î¸` is of the form `Î¹ â–· gâ‚ â–· ... â–· gâ‚—`

Note that the structural morphisms `Î±áµ¢` are not necessarily normalized, as the main purpose
is to get a list of the non-structural morphisms out.

Currently, the primary application of the normalization tactic in mind is drawing string diagrams,
which are graphical representations of morphisms in monoidal categories, in the infoview. When
drawing string diagrams, we often ignore associators and unitors (i.e., drawing morphisms in
strict monoidal categories). On the other hand, in Lean, it is considered difficult to formalize
the concept of strict monoidal categories due to the feature of dependent type theory. The
normalization tactic can remove associators and unitors from the expression, extracting the
necessary data for drawing string diagrams.

The current plan on drawing string diagrams (#10581) is to use
Penrose (https://github.com/penrose) via ProofWidget. However, it should be noted that the
normalization procedure in this file does not rely on specific settings, allowing for broader
application.

Future plans include the following. At least I (Yuma) would like to work on these in the future,
but it might not be immediate. If anyone is interested, I would be happy to discuss.

- Currently (#10581), the string diagrams only do drawing. It would be better they also generate
  proofs. That is, by manipulating the string diagrams displayed in the infoview with a mouse to
  generate proofs. In #10581, the string diagram widget only uses the morphisms generated by the
  normalization tactic and does not use proof terms ensuring that the original morphism and the
  normalized morphism are equal. Proof terms will be necessary for proof generation.

- There is also the possibility of using homotopy.io (https://github.com/homotopy-io), a graphical
  proof assistant for category theory, from Lean. At this point, I have very few ideas regarding
  this approach.

- The normalization tactic allows for an alternative implementation of the coherent tactic.

## Main definitions
- `Tactic.Monoidal.eval`: Given a Lean expression `e` that represents a morphism in a monoidal
category, this function returns a pair of `âŸ¨e', pfâŸ©` where `e'` is the normalized expression of `e`
and `pf` is a proof that `e = e'`.

-/

open Lean Meta Elab
open CategoryTheory Mathlib.Tactic.BicategoryLike
-- MkClass

namespace Mathlib.Tactic

namespace Monoidal

/-- The domain of a morphism. -/
def srcExpr (Î· : Expr) : MetaM Expr := do
  match (â† whnfR (â† inferType Î·)).getAppFnArgs with
  | (``Quiver.Hom, #[_, _, f, _]) => return f
  | _ => throwError m!"{Î·} is not a morphism"

def srcExpr? (Î· : Expr) : MetaM (Option Expr) := do
  try return some (â† srcExpr Î·)
  catch _ => return none

/-- The codomain of a morphism. -/
def tgtExpr (Î· : Expr) : MetaM Expr := do
  match (â† whnfR (â† inferType Î·)).getAppFnArgs with
  | (``Quiver.Hom, #[_, _, _, g]) => return g
  | _ => throwError m!"{Î·} is not a morphism"

def tgtExpr? (Î· : Expr) : MetaM (Option Expr) := do
  try return some (â† tgtExpr Î·)
  catch _ => return none

/-- The domain of an isomorphism. -/
def srcExprOfIso (Î· : Expr) : MetaM Expr := do
  match (â† whnfR (â† inferType Î·)).getAppFnArgs with
  | (``Iso, #[_, _, f, _]) => return f
  | _ => throwError m!"{Î·} is not a morphism"

/-- The codomain of an isomorphism. -/
def tgtExprOfIso (Î· : Expr) : MetaM Expr := do
  match (â† whnfR (â† inferType Î·)).getAppFnArgs with
  | (``Iso, #[_, _, _, g]) => return g
  | _ => throwError m!"{Î·} is not a morphism"

initialize registerTraceClass `monoidal

/-- The context for evaluating expressions. -/
structure Context where
  /-- The expression for the underlying category. -/
  C : Expr
  instCat : Expr
  instMonoidal : Option Expr
  levelâ‚ : Level
  levelâ‚‚ : Level

/-- Populate a `context` object for evaluating `e`. -/
def mkContext (e : Expr) : MetaM Context := do
  let e â† instantiateMVars e
  let e â† (match (â† whnfR e).eq? with
    | some (_, lhs, _) => return lhs
    | none => return e)
  let type â† instantiateMVars <| â† inferType e
  match (â† whnfR type).getAppFnArgs with
  | (``Quiver.Hom, #[_, _, f, _]) =>
    let C â† instantiateMVars <| â† inferType f
    let .succ levelâ‚ â† getLevel C |
      throwError m!"faled to get the universe level of {C}"
    let .succ levelâ‚‚ â† getLevel type |
      throwError m!"failed to get the universe level of {type}"
    let instCat â† synthInstance (mkAppN (.const ``Category [levelâ‚‚, levelâ‚]) #[C])
    let instMonoidal â† synthInstance?
      (mkAppN (.const ``MonoidalCategory [levelâ‚‚, levelâ‚]) #[C, instCat])
    return âŸ¨C, instCat, instMonoidal, levelâ‚, levelâ‚‚âŸ©
  | _ => throwError m!"{e} is not a morphism"

instance : BicategoryLike.Context Monoidal.Context where
  mkContext := Monoidal.mkContext

/-- The monad for the normalization of 2-morphisms. -/
abbrev MonoidalM := CoherenceM Context

def getLevels : MonoidalM (List Level) := do
  let ctx â† read
  return [ctx.levelâ‚‚, ctx.levelâ‚]

def mkCategoryStructInst : MonoidalM Expr := do
  let ctx â† read
  return mkAppN (.const ``Category.toCategoryStruct (â† getLevels)) #[ctx.C, ctx.instCat]

def mkMonoidalCategoryInst : MonoidalM Expr := do
  let ctx â† read
  match ctx.instMonoidal with
  | some inst => return inst
  | none =>
    trace[monoidal] "synthesizing monoidal category instance"
    throwError m!"failed to find monoidal category instance on {ctx.C}"

def mkMonoidalCategoryStructInst : MonoidalM Expr := do
  let ctx â† read
  return mkAppN (.const ``MonoidalCategory.toMonoidalCategoryStruct (â† getLevels))
    #[ctx.C, ctx.instCat, â† mkMonoidalCategoryInst]

def mkMonoidalCoherenceHom (f g inst : Expr) : MonoidalM Expr := do
  let ctx â† read
  return mkAppN (.const ``MonoidalCoherence.hom (â† getLevels))
    #[ctx.C, ctx.instCat, f, g, inst]

def mkMonoidalCoherenceIso (f g inst : Expr) : MonoidalM Expr := do
  let ctx â† read
  return mkAppN (.const ``MonoidalCoherence.iso (â† getLevels))
    #[ctx.C, ctx.instCat, f, g, inst]

def mkIsoHom (Î· : Expr) : MonoidalM Expr := do
    let ctx â† read
    let f â† srcExprOfIso Î·
    let g â† tgtExprOfIso Î·
    return mkAppN (.const ``Iso.hom (â† getLevels))
      #[ctx.C, ctx.instCat, f, g, Î·]

def mkIdâ‚ : MonoidalM Expr := do
    let ctx â† read
    return mkAppN (.const ``MonoidalCategoryStruct.tensorUnit (â† getLevels))
      #[ctx.C, ctx.instCat, â† mkMonoidalCategoryStructInst]

def mkCompâ‚ (f g : Expr) : MonoidalM Expr := do
    let ctx â† read
    return mkAppN (.const ``MonoidalCategoryStruct.tensorObj (â† getLevels))
      #[ctx.C, ctx.instCat, â† mkMonoidalCategoryStructInst, f, g]

instance : MonadMorâ‚ MonoidalM where
  idâ‚M a := return .id (â† mkIdâ‚) a
  compâ‚M f g := return .comp (â† mkCompâ‚ f.e g.e) f g

section

open MonoidalCategory

universe v u
variable {C : Type u} [Category.{v} C] [MonoidalCategory C]

theorem structuralIso_inv {f g : C} (Î· : f â‰… g) :
    Î·.symm.hom = Î·.inv := by
  simp only [Iso.symm_hom]

theorem structuralIsoOfExpr_comp {f g h : C}
    (Î· : f âŸ¶ g) (Î·' : f â‰… g) (ih_Î· : Î·'.hom = Î·)
    (Î¸ : g âŸ¶ h) (Î¸' : g â‰… h) (ih_Î¸ : Î¸'.hom = Î¸) :
    (Î·' â‰ªâ‰« Î¸').hom  = Î· â‰« Î¸ := by
  simp [ih_Î·, ih_Î¸]

theorem structuralIsoOfExpr_whiskerLeft {f g h : C}
    (Î· : g âŸ¶ h) (Î·' : g â‰… h) (ih_Î· : Î·'.hom = Î·)  :
    (whiskerLeftIso f Î·').hom = f â— Î· := by
  simp [ih_Î·]

theorem structuralIsoOfExpr_whiskerRight {f g h : C}
    (Î· : f âŸ¶ g) (Î·' : f â‰… g) (ih_Î· : Î·'.hom = Î·)  :
    (whiskerRightIso Î·' h).hom = Î· â–· h := by
  simp [ih_Î·]

theorem structuralIsoOfExpr_horizontalComp {fâ‚ gâ‚ fâ‚‚ gâ‚‚ : C}
    (Î· : fâ‚ âŸ¶ gâ‚) (Î·' : fâ‚ â‰… gâ‚) (ih_Î· : Î·'.hom = Î·)
    (Î¸ : fâ‚‚ âŸ¶ gâ‚‚) (Î¸' : fâ‚‚ â‰… gâ‚‚) (ih_Î¸ : Î¸'.hom = Î¸) :
    (Î·' âŠ— Î¸').hom = Î· âŠ— Î¸ := by
  simp [ih_Î·, ih_Î¸]

theorem StructuralIsoOfExpr_monoidalComp {f g h i : C} [MonoidalCoherence g h]
    (Î· : f âŸ¶ g) (Î·' : f â‰… g) (ih_Î· : Î·'.hom = Î·) (Î¸ : h âŸ¶ i) (Î¸' : h â‰… i) (ih_Î¸ : Î¸'.hom = Î¸) :
    -- (Î± : g â‰… h) (ih_Î± : Î±.hom = (âŠ—ğŸ™ : g âŸ¶ h)) :
    (monoidalIsoComp Î·' Î¸').hom = Î· âŠ—â‰« Î¸ := by
  simp [ih_Î·, ih_Î¸, monoidalIsoComp, monoidalComp]

end

open MonadMorâ‚

instance : MonadStructuralIsoAtom MonoidalM where
  associatorM f g h := do
    let ctx â† read
    let e := mkAppN (.const ``MonoidalCategoryStruct.associator (â† getLevels))
      #[ctx.C, ctx.instCat, â† mkMonoidalCategoryStructInst, f.e, g.e, h.e]
    return .associator e f g h
  leftUnitorM f := do
    let ctx â† read
    let e := mkAppN (.const ``MonoidalCategoryStruct.leftUnitor (â† getLevels))
      #[ctx.C, ctx.instCat, â† mkMonoidalCategoryStructInst, f.e]
    return .leftUnitor e f
  rightUnitorM f := do
    let ctx â† read
    let e := mkAppN (.const ``MonoidalCategoryStruct.rightUnitor (â† getLevels))
      #[ctx.C, ctx.instCat, â† mkMonoidalCategoryStructInst, f.e]
    return .rightUnitor e f
  idâ‚‚M f := do
    let ctx â† read
    let e := mkAppN (.const ``Iso.refl (â† getLevels)) #[ctx.C, ctx.instCat, f.e]
    return .id e f
  coherenceHomM f g inst := do
    let ctx â† read
    match (â† whnfI inst).getAppFnArgs with
    | (``MonoidalCoherence.mk, #[_, _, _, _, Î±]) =>
      let e := mkAppN (.const ``MonoidalCoherence.iso (â† getLevels))
        #[ctx.C, ctx.instCat, f.e, g.e, inst]
      return âŸ¨e, f, g, inst, Î±âŸ©
    | _ => throwError m!"failed to unfold {inst}"

instance : MonadMorâ‚‚Iso MonoidalM where
  compâ‚‚M Î· Î¸ := do
    let ctx â† read
    let f â† Î·.srcM
    let g â† Î·.tgtM
    let h â† Î¸.tgtM
    let e := mkAppN (.const ``Iso.trans (â† getLevels))
      #[ctx.C, ctx.instCat, f.e, g.e, h.e, Î·.e, Î¸.e]
    return .comp e f g h Î· Î¸
  whiskerLeftM f Î· := do
    let ctx â† read
    let g â† Î·.srcM
    let h â† Î·.tgtM
    let e := mkAppN (.const ``MonoidalCategory.whiskerLeftIso (â† getLevels))
      #[ctx.C, ctx.instCat, â† mkMonoidalCategoryInst, f.e, g.e, h.e, Î·.e]
    return .whiskerLeft e f g h Î·
  whiskerRightM Î· h := do
    let ctx â† read
    let f â† Î·.srcM
    let g â† Î·.tgtM
    let e := mkAppN (.const ``MonoidalCategory.whiskerRightIso (â† getLevels))
      #[ctx.C, ctx.instCat, â† mkMonoidalCategoryInst, f.e, g.e, Î·.e, h.e]
    return .whiskerRight e f g Î· h
  horizontalCompM Î· Î¸ := do
    let ctx â† read
    let fâ‚ â† Î·.srcM
    let gâ‚ â† Î·.tgtM
    let fâ‚‚ â† Î¸.srcM
    let gâ‚‚ â† Î¸.tgtM
    let e := mkAppN (.const ``tensorIso (â† getLevels))
      #[ctx.C, fâ‚.e, gâ‚.e, fâ‚‚.e, gâ‚‚.e, ctx.instCat, â† mkMonoidalCategoryInst, Î·.e, Î¸.e]
    return .horizontalComp e fâ‚ gâ‚ fâ‚‚ gâ‚‚ Î· Î¸
  symmM Î· := do
    let ctx â† read
    let f â† Î·.srcM
    let g â† Î·.tgtM
    let e := mkAppN (.const ``Iso.symm (â† getLevels)) #[ctx.C, ctx.instCat, f.e, g.e, Î·.e]
    return .inv e f g Î·
  coherenceCompM Î± Î· Î¸ := do
    let ctx â† read
    let f â† Î·.srcM
    let g â† Î·.tgtM
    let h â† Î¸.srcM
    let i â† Î¸.tgtM
    let e := mkAppN (.const ``monoidalIsoComp (â† getLevels))
      #[ctx.C, ctx.instCat, f.e, g.e, h.e, i.e, Î±.inst, Î·.e, Î¸.e]
    return .coherenceComp e f g h i Î± Î· Î¸

instance : MonadMorâ‚‚ MonoidalM where
  homM Î· := do
    let ctx â† read
    let f â† Î·.srcM
    let g â† Î·.tgtM
    let e := mkAppN (.const ``Iso.hom (â† getLevels))
      #[ctx.C, ctx.instCat, f.e, g.e, Î·.e]
    return .isoHom e âŸ¨Î·, â† mkEqRefl eâŸ© Î·
  homAtomM Î· := do
    let ctx â† read
    let f := Î·.src
    let g := Î·.tgt
    let e := mkAppN (.const ``Iso.hom (â† getLevels))
      #[ctx.C, ctx.instCat, f.e, g.e, Î·.e]
    return .mk e f g
  invM Î· := do
    let ctx â† read
    let f â† Î·.srcM
    let g â† Î·.tgtM
    let e := mkAppN (.const ``Iso.inv (â† getLevels)) #[ctx.C, ctx.instCat, f.e, g.e, Î·.e]
    let Î·Inv â† Morâ‚‚Iso.symmM Î·
    let eq := mkAppN (.const ``Iso.symm_hom (â† getLevels)) #[ctx.C, ctx.instCat, f.e, g.e, Î·.e]
    return .isoInv e âŸ¨Î·Inv, eqâŸ© Î·
  invAtomM Î· := do
    let ctx â† read
    let f := Î·.src
    let g := Î·.tgt
    let e := mkAppN (.const ``Iso.inv (â† getLevels)) #[ctx.C, ctx.instCat, f.e, g.e, Î·.e]
    return .mk e g f
  idâ‚‚M f := do
    let ctx â† read
    let e := mkAppN (.const ``CategoryStruct.id (â† getLevels)) #[ctx.C, â† mkCategoryStructInst, f.e]
    let eq := mkAppN (.const ``Iso.refl_hom (â† getLevels)) #[ctx.C, ctx.instCat, f.e]
    return .id e âŸ¨(.structuralAtom <| â† StructuralIsoAtom.idâ‚‚M f), eqâŸ© f
  compâ‚‚M Î· Î¸ := do
    let ctx â† read
    let f â† Î·.srcM
    let g â† Î·.tgtM
    let h â† Î¸.tgtM
    let isoLift? â† (match (Î·.isoLift?, Î¸.isoLift?) with
      | (some Î·Iso, some Î¸Iso) => do
        let eq := mkAppN (.const ``structuralIsoOfExpr_comp (â† getLevels))
          #[ctx.C, ctx.instCat, f.e, g.e, h.e, Î·.e, Î·Iso.iso.e, Î·Iso.eq, Î¸.e, Î¸Iso.iso.e, Î¸Iso.eq]
        return .some âŸ¨â† MonadMorâ‚‚Iso.compâ‚‚M Î·Iso.iso Î¸Iso.iso, eqâŸ©
      | _ => return none)
    let e := mkAppN (.const ``CategoryStruct.comp (â† getLevels))
      #[ctx.C, â† mkCategoryStructInst, f.e, g.e, h.e, Î·.e, Î¸.e]
    return .comp e isoLift? f g h Î· Î¸
  whiskerLeftM f Î· := do
    let ctx â† read
    let g â† Î·.srcM
    let h â† Î·.tgtM
    let isoLift? â† (match Î·.isoLift? with
      | some Î·Iso => do
        let eq := mkAppN (.const ``structuralIsoOfExpr_whiskerLeft (â† getLevels))
          #[ctx.C, ctx.instCat, f.e, g.e, h.e, Î·.e, Î·Iso.iso.e, Î·Iso.eq]
        return .some âŸ¨â† MonadMorâ‚‚Iso.whiskerLeftM f Î·Iso.iso, eqâŸ©
      | _ => return none)
    let e := mkAppN (.const ``MonoidalCategoryStruct.whiskerLeft (â† getLevels))
      #[ctx.C, ctx.instCat, â† mkMonoidalCategoryStructInst, f.e, g.e, h.e, Î·.e]
    return .whiskerLeft e isoLift? f g h Î·
  whiskerRightM Î· h := do
    let ctx â† read
    let f â† Î·.srcM
    let g â† Î·.tgtM
    let isoLift? â† (match Î·.isoLift? with
      | some Î·Iso => do
        let eq := mkAppN (.const ``structuralIsoOfExpr_whiskerRight (â† getLevels))
          #[ctx.C, ctx.instCat, â† mkMonoidalCategoryInst, f.e, g.e, h.e, Î·.e, Î·Iso.iso.e, Î·Iso.eq]
        return .some âŸ¨â† MonadMorâ‚‚Iso.whiskerRightM Î·Iso.iso h, eqâŸ©
      | _ => return none)
    let e := mkAppN (.const ``MonoidalCategoryStruct.whiskerRight (â† getLevels))
      #[ctx.C, ctx.instCat, â† mkMonoidalCategoryStructInst, f.e, g.e, Î·.e, h.e]
    return .whiskerRight e isoLift? f g Î· h
  horizontalCompM Î· Î¸ := do
    let ctx â† read
    let fâ‚ â† Î·.srcM
    let gâ‚ â† Î·.tgtM
    let fâ‚‚ â† Î¸.srcM
    let gâ‚‚ â† Î¸.tgtM
    let isoLift? â† (match (Î·.isoLift?, Î¸.isoLift?) with
      | (some Î·Iso, some Î¸Iso) => do
        let eq := mkAppN (.const ``structuralIsoOfExpr_horizontalComp (â† getLevels))
          #[ctx.C, ctx.instCat, â† mkMonoidalCategoryInst, fâ‚.e, gâ‚.e, fâ‚‚.e, gâ‚‚.e,
            Î·.e, Î·Iso.iso.e, Î·Iso.eq, Î¸.e, Î¸Iso.iso.e, Î¸Iso.eq]
        return .some âŸ¨â† MonadMorâ‚‚Iso.horizontalCompM Î·Iso.iso Î¸Iso.iso, eqâŸ©
      | _ => return none)
    let e := mkAppN (.const ``MonoidalCategoryStruct.tensorHom (â† getLevels))
      #[ctx.C, ctx.instCat, â† mkMonoidalCategoryStructInst, fâ‚.e, gâ‚.e, fâ‚‚.e, gâ‚‚.e, Î·.e, Î¸.e]
    return .horizontalComp e isoLift? fâ‚ gâ‚ fâ‚‚ gâ‚‚ Î· Î¸
  coherenceCompM Î± Î· Î¸ := do
    let ctx â† read
    let f â† Î·.srcM
    let g â† Î·.tgtM
    let h â† Î¸.srcM
    let i â† Î¸.tgtM
    let isoLift? â† (match (Î·.isoLift?, Î¸.isoLift?) with
      | (some Î·Iso, some Î¸Iso) => do
        let eq := mkAppN (.const ``StructuralIsoOfExpr_monoidalComp (â† getLevels))
          #[ctx.C, ctx.instCat, f.e, g.e, h.e, i.e, Î±.inst,
            Î·.e, Î·Iso.iso.e, Î·Iso.eq, Î¸.e, Î¸Iso.iso.e, Î¸Iso.eq]
        return .some âŸ¨â† MonadMorâ‚‚Iso.coherenceCompM Î± Î·Iso.iso Î¸Iso.iso, eqâŸ©
      | _ => return none)

    let e := mkAppN (.const ``monoidalComp (â† getLevels))
      #[ctx.C, ctx.instCat, f.e, g.e, h.e, i.e, Î±.inst, Î·.e, Î¸.e]
    return .coherenceComp e isoLift? f g h i Î± Î· Î¸

section

open MonoidalCategory

universe v u

variable {C : Type u} [Category.{v} C] [MonoidalCategory C]

local infixr:81 " â— " => MonoidalCategory.whiskerLeftIso
local infixl:81 " â–· " => MonoidalCategory.whiskerRightIso

abbrev normalizeIsoComp {p f g pf pfg : C} (Î·_f : p âŠ— f â‰… pf) (Î·_g : pf âŠ— g â‰… pfg) :=
  (Î±_ _ _ _).symm â‰ªâ‰« whiskerRightIso Î·_f g â‰ªâ‰« Î·_g

theorem naturality_associator {p f g h pf pfg pfgh : C}
    (Î·_f : (p âŠ— f) â‰… pf) (Î·_g : (pf âŠ— g) â‰… pfg) (Î·_h : pfg âŠ— h â‰… pfgh) :
    p â— (Î±_ f g h) â‰ªâ‰« normalizeIsoComp Î·_f (normalizeIsoComp Î·_g Î·_h) =
    normalizeIsoComp (normalizeIsoComp Î·_f Î·_g) Î·_h :=
  Iso.ext (by simp)

theorem naturality_leftUnitor {p f pf : C} (Î·_f : p âŠ— f â‰… pf) :
    p â— (Î»_ f) â‰ªâ‰« Î·_f = normalizeIsoComp (Ï_ p) Î·_f :=
  Iso.ext (by simp)

theorem naturality_rightUnitor {p f pf : C} (Î·_f : p âŠ— f â‰… pf) :
    p â— (Ï_ f) â‰ªâ‰« Î·_f = normalizeIsoComp Î·_f (Ï_ pf) :=
  Iso.ext (by simp)

theorem naturality_id {p f pf : C} (Î·_f : p âŠ— f â‰… pf) :
    p â— Iso.refl f â‰ªâ‰« Î·_f = Î·_f := by
  simp

theorem naturality_comp {p f g h pf : C} {Î· : f â‰… g} {Î¸ : g â‰… h}
    (Î·_f : (p âŠ— f) â‰… pf) (Î·_g : (p âŠ— g) â‰… pf) (Î·_h : p âŠ— h â‰… pf)
    (ih_Î· : p â— Î· â‰ªâ‰« Î·_g = Î·_f) (ih_Î¸ : p â— Î¸ â‰ªâ‰« Î·_h = Î·_g) :
    p â— (Î· â‰ªâ‰« Î¸) â‰ªâ‰« Î·_h = Î·_f := by
  simp_all

theorem naturality_whiskerLeft {p f g h pf pfg : C} {Î· : g â‰… h}
    (Î·_f : (p âŠ— f) â‰… pf) (Î·_fg : (pf âŠ— g) â‰… pfg) (Î·_fh : (pf âŠ— h) â‰… pfg)
    (ih_Î· : pf â— Î· â‰ªâ‰« Î·_fh = Î·_fg) :
    p â— (f â— Î·) â‰ªâ‰« normalizeIsoComp Î·_f Î·_fh = normalizeIsoComp Î·_f Î·_fg := by
  rw [â† ih_Î·]
  apply Iso.ext
  simp [â† whisker_exchange_assoc]

theorem naturality_whiskerRight {p f g h pf pfh : C} {Î· : f â‰… g}
    (Î·_f : (p âŠ— f) â‰… pf) (Î·_g : (p âŠ— g) â‰… pf) (Î·_fh : (pf âŠ— h) â‰… pfh)
    (ih_Î· : p â— Î· â‰ªâ‰« Î·_g = Î·_f) :
    p â— (Î· â–· h) â‰ªâ‰« normalizeIsoComp Î·_g Î·_fh = normalizeIsoComp Î·_f Î·_fh := by
  rw [â† ih_Î·]
  apply Iso.ext
  simp

theorem naturality_tensorHom {p fâ‚ gâ‚ fâ‚‚ gâ‚‚ pfâ‚ pfâ‚fâ‚‚ : C} {Î· : fâ‚ â‰… gâ‚} {Î¸ : fâ‚‚ â‰… gâ‚‚}
    (Î·_fâ‚ : p âŠ— fâ‚ â‰… pfâ‚) (Î·_gâ‚ : p âŠ— gâ‚ â‰… pfâ‚) (Î·_fâ‚‚ : pfâ‚ âŠ— fâ‚‚ â‰… pfâ‚fâ‚‚) (Î·_gâ‚‚ : pfâ‚ âŠ— gâ‚‚ â‰… pfâ‚fâ‚‚)
    (ih_Î· : p â— Î· â‰ªâ‰« Î·_gâ‚ = Î·_fâ‚)
    (ih_Î¸ : pfâ‚ â— Î¸ â‰ªâ‰« Î·_gâ‚‚ = Î·_fâ‚‚) :
    p â— (Î· âŠ— Î¸) â‰ªâ‰« normalizeIsoComp Î·_gâ‚ Î·_gâ‚‚ = normalizeIsoComp Î·_fâ‚ Î·_fâ‚‚ := by
  rw [tensorIso_def]
  apply naturality_comp
  Â· apply naturality_whiskerRight _ _ _ ih_Î·
  Â· apply naturality_whiskerLeft _ _ _ ih_Î¸

theorem naturality_inv {p f g pf : C} {Î· : f â‰… g}
    (Î·_f : p âŠ— f â‰… pf) (Î·_g : p âŠ— g â‰… pf) (ih : p â— Î· â‰ªâ‰« Î·_g = Î·_f) :
    p â— Î·.symm â‰ªâ‰« Î·_f = Î·_g := by
  rw [â† ih]
  apply Iso.ext
  simp

instance : MonadNormalizeNaturality MonoidalM where
  mkNaturalityAssociator p pf pfg pfgh f g h Î·_f Î·_g Î·_h := do
    let ctx â† read
    return mkAppN (.const ``naturality_associator (â† getLevels))
      #[ctx.C, ctx.instCat, â† mkMonoidalCategoryInst, p.e.e, f.e, g.e, h.e,
        pf.e.e, pfg.e.e, pfgh.e.e,
        Î·_f.e, Î·_g.e, Î·_h.e]
  mkNaturalityLeftUnitor p pf f Î·_f := do
    let ctx â† read
    return mkAppN (.const ``naturality_leftUnitor (â† getLevels))
      #[ctx.C, ctx.instCat, â† mkMonoidalCategoryInst, p.e.e, f.e, pf.e.e, Î·_f.e]
  mkNaturalityRightUnitor p pf f Î·_f := do
    let ctx â† read
    return mkAppN (.const ``naturality_rightUnitor (â† getLevels))
      #[ctx.C, ctx.instCat, â† mkMonoidalCategoryInst, p.e.e, f.e, pf.e.e, Î·_f.e]
  mkNaturalityId p pf f Î·_f := do
    let ctx â† read
    return mkAppN (.const ``naturality_id (â† getLevels))
      #[ctx.C, ctx.instCat, â† mkMonoidalCategoryInst, p.e.e, f.e, pf.e.e, Î·_f.e]
  mkNaturalityComp p pf f g h Î· Î¸ Î·_f Î·_g Î·_h ih_Î· ih_Î¸ := do
    let ctx â† read
    return mkAppN (.const ``naturality_comp (â† getLevels))
      #[ctx.C, ctx.instCat, â† mkMonoidalCategoryInst, p.e.e, f.e, g.e, h.e, pf.e.e, Î·.e, Î¸.e,
        Î·_f.e, Î·_g.e, Î·_h.e, ih_Î·, ih_Î¸]
  mkNaturalityWhiskerLeft p pf pfg f g h Î· Î·_f Î·_fg Î·_fh ih_Î· := do
    let ctx â† read
    return mkAppN (.const ``naturality_whiskerLeft (â† getLevels))
      #[ctx.C, ctx.instCat, â† mkMonoidalCategoryInst, p.e.e, f.e, g.e, h.e,
        pf.e.e, pfg.e.e, Î·.e, Î·_f.e, Î·_fg.e, Î·_fh.e, ih_Î·]
  mkNaturalityWhiskerRight p pf pfh f g h Î· Î·_f Î·_g Î·_fh ih_Î· := do
    let ctx â† read
    return mkAppN (.const ``naturality_whiskerRight (â† getLevels))
      #[ctx.C, ctx.instCat, â† mkMonoidalCategoryInst, p.e.e, f.e, g.e, h.e,
        pf.e.e, pfh.e.e, Î·.e, Î·_f.e, Î·_g.e, Î·_fh.e, ih_Î·]
  mkNaturalityHorizontalComp p pfâ‚ pfâ‚fâ‚‚ fâ‚ gâ‚ fâ‚‚ gâ‚‚ Î· Î¸ Î·_fâ‚ Î·_gâ‚ Î·_fâ‚‚ Î·_gâ‚‚ ih_Î· ih_Î¸ := do
    let ctx â† read
    return mkAppN (.const ``naturality_tensorHom (â† getLevels))
      #[ctx.C, ctx.instCat, â† mkMonoidalCategoryInst, p.e.e, fâ‚.e, gâ‚.e, fâ‚‚.e, gâ‚‚.e,
        pfâ‚.e.e, pfâ‚fâ‚‚.e.e, Î·.e, Î¸.e, Î·_fâ‚.e, Î·_gâ‚.e, Î·_fâ‚‚.e, Î·_gâ‚‚.e, ih_Î·, ih_Î¸]
  mkNaturalityInv p pf f g Î· Î·_f Î·_g ih := do
    let ctx â† read
    return mkAppN (.const ``naturality_inv (â† getLevels))
      #[ctx.C, ctx.instCat, â† mkMonoidalCategoryInst, p.e.e,
        f.e, g.e, pf.e.e, Î·.e, Î·_f.e, Î·_g.e, ih]

theorem of_normalize_eq {f g f' : C} {Î· Î¸ : f â‰… g} (Î·_f : ğŸ™_ C âŠ— f â‰… f') (Î·_g : ğŸ™_ C âŠ— g â‰… f')
    (h_Î· : ğŸ™_ C â— Î· â‰ªâ‰« Î·_g = Î·_f)
    (h_Î¸ : ğŸ™_ C â— Î¸ â‰ªâ‰« Î·_g = Î·_f) : Î· = Î¸ := by
  apply Iso.ext
  calc
    Î·.hom = (Î»_ f).inv â‰« Î·_f.hom â‰« Î·_g.inv â‰« (Î»_ g).hom := by
      simp [â† reassoc_of% (congrArg Iso.hom h_Î·)]
    _ = Î¸.hom := by
      simp [â† reassoc_of% (congrArg Iso.hom h_Î¸)]

end

def Atomâ‚.mkM (e : Expr) : MetaM Atomâ‚ := do
  let src â† srcExpr? e
  let tgt â† tgtExpr? e
  return âŸ¨e, âŸ¨srcâŸ©, âŸ¨tgtâŸ©âŸ©

def isIdâ‚? (e : Expr) : MonoidalM (Option Obj) := do
  let ctx â† read
  match ctx.instMonoidal with
  | none => return none
  | some _ => do
    let unit := mkAppN (.const ``MonoidalCategoryStruct.tensorUnit (â† getLevels))
      #[ctx.C, ctx.instCat, â† mkMonoidalCategoryStructInst]
    if â† withDefault <| isDefEq e unit then
      return .some âŸ¨noneâŸ©
    else
      return none

def isCompâ‚? (e : Expr) : MonoidalM (Option (Morâ‚ Ã— Morâ‚)) := do
  let ctx â† read
  let f â† mkFreshExprMVar ctx.C
  let g â† mkFreshExprMVar ctx.C
  match ctx.instMonoidal with
    | none => return none
    | some _ => do
      let fg := mkAppN (.const ``MonoidalCategoryStruct.tensorObj (â† getLevels))
          #[ctx.C, ctx.instCat, â† mkMonoidalCategoryStructInst, f, g]
      if â† withDefault <| isDefEq e fg then
        let f â† instantiateMVars f
        let g â† instantiateMVars g
        return .some ((.of âŸ¨f, âŸ¨noneâŸ©, âŸ¨noneâŸ©âŸ© : Morâ‚), (.of âŸ¨g, âŸ¨noneâŸ©, âŸ¨noneâŸ©âŸ© : Morâ‚))
      else
        return none

/-- Construct a `Morâ‚` expression from a Lean expression. -/
partial def morâ‚OfExpr (e : Expr) : MonoidalM Morâ‚ := do
  if let some a â† isIdâ‚? e then
    MonadMorâ‚.idâ‚M a
  else if let some (f, g) â† isCompâ‚? e then
    MonadMorâ‚.compâ‚M (â† morâ‚OfExpr f.e) (â† morâ‚OfExpr g.e)
  else
    return Morâ‚.of (â† Atomâ‚.mkM e)

instance : MkMorâ‚ MonoidalM where
  ofExpr := morâ‚OfExpr

partial def Morâ‚‚IsoOfExpr (e : Expr) : MonoidalM Morâ‚‚Iso := do
  match (â† whnfR e).getAppFnArgs with
  | (``MonoidalCategoryStruct.associator, #[_, _, _, f, g, h]) =>
    Morâ‚‚Iso.associatorM' (â† MkMorâ‚.ofExpr f) (â† MkMorâ‚.ofExpr g) (â† MkMorâ‚.ofExpr h)
  | (``MonoidalCategoryStruct.leftUnitor, #[_, _, _, f]) =>
    Morâ‚‚Iso.leftUnitorM' (â† MkMorâ‚.ofExpr f)
  | (``MonoidalCategoryStruct.rightUnitor, #[_, _, _, f]) =>
    Morâ‚‚Iso.rightUnitorM' (â† MkMorâ‚.ofExpr f)
  | (``Iso.refl, #[_, _, f]) =>
    Morâ‚‚Iso.idâ‚‚M' (â† MkMorâ‚.ofExpr f)
  | (``Iso.symm, #[_, _, _, _, Î·]) =>
    Morâ‚‚Iso.symmM (â† Morâ‚‚IsoOfExpr Î·)
  | (``Iso.trans, #[_, _, _, _, _, Î·, Î¸]) =>
    Morâ‚‚Iso.compâ‚‚M (â† Morâ‚‚IsoOfExpr Î·) (â† Morâ‚‚IsoOfExpr Î¸)
  | (``MonoidalCategory.whiskerLeftIso, #[_, _, _, f, _, _, Î·]) =>
    Morâ‚‚Iso.whiskerLeftM (â† MkMorâ‚.ofExpr f) (â† Morâ‚‚IsoOfExpr Î·)
  | (``MonoidalCategory.whiskerRightIso, #[_, _, _, _, _, Î·, h]) =>
    Morâ‚‚Iso.whiskerRightM (â† Morâ‚‚IsoOfExpr Î·) (â† MkMorâ‚.ofExpr h)
  | (``tensorIso, #[_, _, _, _, _, _, _, Î·, Î¸]) =>
    Morâ‚‚Iso.horizontalCompM (â† Morâ‚‚IsoOfExpr Î·) (â† Morâ‚‚IsoOfExpr Î¸)
  | (``monoidalIsoComp, #[_, _, _, g, h, _, inst, Î·, Î¸]) =>
    let Î± â† Morâ‚‚IsoOfExpr <| â† mkMonoidalCoherenceIso g h inst
    match Î± with
    | .structuralAtom (.coherenceHom Î±) =>
      Morâ‚‚Iso.coherenceCompM Î± (â† Morâ‚‚IsoOfExpr Î·) (â† Morâ‚‚IsoOfExpr Î¸)
    | _ => unreachable!
  | (``MonoidalCoherence.iso, #[_, _, f, g, inst]) =>
    Morâ‚‚Iso.coherenceHomM' (â† MkMorâ‚.ofExpr f) (â† MkMorâ‚.ofExpr g) inst
  | _ =>
    return .of âŸ¨e, â† MkMorâ‚.ofExpr (â† srcExprOfIso e), â† MkMorâ‚.ofExpr (â† tgtExprOfIso e)âŸ©

open MonadMorâ‚‚ in
partial def Morâ‚‚OfExpr (e : Expr) : MonoidalM Morâ‚‚ := do
  match â† whnfR e with
  -- whnfR version of `Iso.hom Î·`
  | .proj ``Iso 0 Î· => homM (â† Morâ‚‚IsoOfExpr Î·)
  -- whnfR version of `Iso.inv Î·`
  | .proj ``Iso 1 Î· => invM (â† Morâ‚‚IsoOfExpr Î·)
  | .app .. => match (â† whnfR e).getAppFnArgs with
    | (``CategoryStruct.id, #[_, _, f]) => idâ‚‚M (â† MkMorâ‚.ofExpr f)
    | (``CategoryStruct.comp, #[_, _, _, _, _, Î·, Î¸]) =>
      compâ‚‚M (â† Morâ‚‚OfExpr Î·) (â† Morâ‚‚OfExpr Î¸)
    | (``MonoidalCategoryStruct.whiskerLeft, #[_, _, _, f, _, _, Î·]) =>
      whiskerLeftM (â† MkMorâ‚.ofExpr f) (â† Morâ‚‚OfExpr Î·)
    | (``MonoidalCategoryStruct.whiskerRight, #[_, _, _, _, _, Î·, h]) =>
      whiskerRightM (â† Morâ‚‚OfExpr Î·) (â† MkMorâ‚.ofExpr h)
    | (``MonoidalCategoryStruct.tensorHom, #[_, _, _, _, _, _, _, Î·, Î¸]) =>
      horizontalCompM (â† Morâ‚‚OfExpr Î·) (â† Morâ‚‚OfExpr Î¸)
    | (``monoidalComp, #[_, _, _, g, h, _, inst, Î·, Î¸]) =>
      coherenceCompM (â† MonadStructuralIsoAtom.coherenceHomM
        (â† MkMorâ‚.ofExpr g) (â† MkMorâ‚.ofExpr h) inst) (â† Morâ‚‚OfExpr Î·) (â† Morâ‚‚OfExpr Î¸)
    | _ => return .of âŸ¨e, â† MkMorâ‚.ofExpr (â† srcExpr e), â† MkMorâ‚.ofExpr (â† tgtExpr e)âŸ©
  | _ =>
    return .of âŸ¨e, â† MkMorâ‚.ofExpr (â† srcExpr e), â† MkMorâ‚.ofExpr (â† tgtExpr e)âŸ©

instance : BicategoryLike.MkMorâ‚‚ MonoidalM where
  ofExpr := Morâ‚‚OfExpr

instance : MonadCoherehnceHom MonoidalM where
  unfoldM Î± := Morâ‚‚IsoOfExpr Î±.unfold

universe v u
variable {C : Type u} [Category.{v} C] [MonoidalCategory C]

open MonoidalCategory

theorem mk_eq_of_normalized_eq {f g f' : C} (Î· Î¸ : f âŸ¶ g) (Î·' Î¸' : f â‰… g)
    (Î·_f : ğŸ™_ C âŠ— f â‰… f') (Î·_g : ğŸ™_ C âŠ— g â‰… f')
    (HÎ· : Î·'.hom = Î·) (HÎ¸ : Î¸'.hom = Î¸)
    (HÎ·' : whiskerLeftIso (ğŸ™_ C) Î·' â‰ªâ‰« Î·_g = Î·_f)
    (HÎ¸' : whiskerLeftIso (ğŸ™_ C) Î¸' â‰ªâ‰« Î·_g = Î·_f) : Î· = Î¸ :=
  calc
    Î· = Î·'.hom := HÎ·.symm
    _ = (Î»_ f).inv â‰« Î·_f.hom â‰« Î·_g.inv â‰« (Î»_ g).hom := by
      simp [â† reassoc_of% (congrArg Iso.hom HÎ·')]
    _ = Î¸'.hom := by
      simp [â† reassoc_of% (congrArg Iso.hom HÎ¸')]
    _ = Î¸ := HÎ¸

open Elab.Tactic

def pureCoherence (mvarId : MVarId) : MetaM (List MVarId) :=
  BicategoryLike.pureCoherence `monoidal Monoidal.Context (mkAppM ``mk_eq_of_normalized_eq) mvarId

elab "monoidal_coherence" : tactic => withMainContext do
  replaceMainGoal <| â† Monoidal.pureCoherence <| â† getMainGoal

end Mathlib.Tactic.Monoidal
