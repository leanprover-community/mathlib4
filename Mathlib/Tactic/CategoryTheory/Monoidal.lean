/-
Copyright (c) 2024 Yuma Mizuno. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yuma Mizuno
-/
import Mathlib.Tactic.CategoryTheory.MonoidalComp

/-!
# Normalization of morphisms in monoidal categories
This file provides a tactic that normalizes morphisms in monoidal categories. This is used in the
string diagram widget given in `Mathlib.Tactic.StringDiagram`.
We say that the morphism `Œ∑` in a monoidal category is in normal form if
1. `Œ∑` is of the form `Œ±‚ÇÄ ‚â´ Œ∑‚ÇÄ ‚â´ Œ±‚ÇÅ ‚â´ Œ∑‚ÇÅ ‚â´ ... Œ±‚Çò ‚â´ Œ∑‚Çò ‚â´ Œ±‚Çò‚Çä‚ÇÅ` where each `Œ±·µ¢` is a
  structural 2-morphism (consisting of associators and unitors),
2. each `Œ∑·µ¢` is a non-structural 2-morphism of the form `f‚ÇÅ ‚óÅ ... ‚óÅ f‚Çò ‚óÅ Œ∏`, and
3. `Œ∏` is of the form `Œπ ‚ñ∑ g‚ÇÅ ‚ñ∑ ... ‚ñ∑ g‚Çó`

Note that the structural morphisms `Œ±·µ¢` are not necessarily normalized, as the main purpose
is to get a list of the non-structural morphisms out.

Currently, the primary application of the normalization tactic in mind is drawing string diagrams,
which are graphical representations of morphisms in monoidal categories, in the infoview. When
drawing string diagrams, we often ignore associators and unitors (i.e., drawing morphisms in
strict monoidal categories). On the other hand, in Lean, it is considered difficult to formalize
the concept of strict monoidal categories due to the feature of dependent type theory. The
normalization tactic can remove associators and unitors from the expression, extracting the
necessary data for drawing string diagrams.

The current plan on drawing string diagrams (#10581) is to use
Penrose (https://github.com/penrose) via ProofWidget. However, it should be noted that the
normalization procedure in this file does not rely on specific settings, allowing for broader
application.

Future plans include the following. At least I (Yuma) would like to work on these in the future,
but it might not be immediate. If anyone is interested, I would be happy to discuss.

- Currently (#10581), the string diagrams only do drawing. It would be better they also generate
  proofs. That is, by manipulating the string diagrams displayed in the infoview with a mouse to
  generate proofs. In #10581, the string diagram widget only uses the morphisms generated by the
  normalization tactic and does not use proof terms ensuring that the original morphism and the
  normalized morphism are equal. Proof terms will be necessary for proof generation.

- There is also the possibility of using homotopy.io (https://github.com/homotopy-io), a graphical
  proof assistant for category theory, from Lean. At this point, I have very few ideas regarding
  this approach.

- The normalization tactic allows for an alternative implementation of the coherent tactic.

## Main definitions
- `Tactic.Monoidal.eval`: Given a Lean expression `e` that represents a morphism in a monoidal
category, this function returns a pair of `‚ü®e', pf‚ü©` where `e'` is the normalized expression of `e`
and `pf` is a proof that `e = e'`.

-/

open Lean Meta Elab
open CategoryTheory

namespace Mathlib.Tactic.Monoidal

initialize registerTraceClass `monoidal

/-- The context for evaluating expressions. -/
structure Context where
  /-- The expression for the underlying category. -/
  C : Expr
  instCat : Expr
  instMonoidal : Expr
  level‚ÇÅ : Level
  level‚ÇÇ : Level

/-- Populate a `context` object for evaluating `e`. -/
def mkContext? (e : Expr) : MetaM (Option Context) := do
  match (‚Üê whnfR (‚Üê inferType e)).getAppFnArgs with
  | (``Quiver.Hom, #[_, _, f, _]) =>
    let C ‚Üê inferType f
    let .succ level‚ÇÅ ‚Üê getLevel C | return none
    let .succ level‚ÇÇ ‚Üê getLevel (‚Üê inferType e) | return none
    let .some instCat ‚Üê synthInstance?
      (mkAppN (.const ``Category [level‚ÇÇ, level‚ÇÅ]) #[C]) | return none
    let .some instMonoidal ‚Üê synthInstance?
      (mkAppN (.const ``MonoidalCategory [level‚ÇÇ, level‚ÇÅ]) #[C, instCat]) | return none
    return some
      { C := C, instCat := instCat, instMonoidal := instMonoidal,
        level‚ÇÅ := level‚ÇÅ, level‚ÇÇ := level‚ÇÇ }
  | _ => return none

/-- The monad for the normalization of 2-morphisms. -/
abbrev MonoidalM := ReaderT Context MetaM

/-- Run a computation in the `M` monad. -/
abbrev MonoidalM.run {Œ± : Type} (c : Context) (m : MonoidalM Œ±) : MetaM Œ± :=
  ReaderT.run m c

def getLevels : MonoidalM (List Level) := do
  let ctx ‚Üê read
  return [ctx.level‚ÇÇ, ctx.level‚ÇÅ]

/-- The domain of a morphism. -/
def srcExpr (Œ∑ : Expr) : MetaM Expr := do
  match (‚Üê inferType Œ∑).getAppFnArgs with
  | (``Quiver.Hom, #[_, _, f, _]) => return f
  | _ => match (‚Üê whnfR (‚Üê inferType Œ∑)).getAppFnArgs with
    | (``Quiver.Hom, #[_, _, f, _]) => return f
    | _ => throwError m!"{Œ∑} is not a morphism"

/-- The codomain of a morphism. -/
def tgtExpr (Œ∑ : Expr) : MetaM Expr := do
  match (‚Üê inferType Œ∑).getAppFnArgs with
  | (``Quiver.Hom, #[_, _, _, g]) => return g
  | _ => match (‚Üê whnfR (‚Üê inferType Œ∑)).getAppFnArgs with
    | (``Quiver.Hom, #[_, _, _, g]) => return g
    | _ => throwError m!"{Œ∑} is not a morphism"

/-- The domain of a morphism. -/
def srcExprOfIso (Œ∑ : Expr) : MetaM Expr := do
  match (‚Üê inferType Œ∑).getAppFnArgs with
  | (``Iso, #[_, _, f, _]) => return f
  | _ => match (‚Üê whnfR (‚Üê inferType Œ∑)).getAppFnArgs with
    | (``Iso, #[_, _, f, _]) => return f
    | _ => throwError m!"{Œ∑} is not a morphism"

/-- The codomain of a morphism. -/
def tgtExprOfIso (Œ∑ : Expr) : MetaM Expr := do
  match (‚Üê inferType Œ∑).getAppFnArgs with
  | (``Iso, #[_, _, _, g]) => return g
  | _ => match (‚Üê whnfR (‚Üê inferType Œ∑)).getAppFnArgs with
    | (``Iso, #[_, _, _, g]) => return g
    | _ => throwError m!"{Œ∑} is not a morphism"

def mkCategoryStructInst : MonoidalM Expr := do
  let ctx ‚Üê read
  return mkAppN (.const ``Category.toCategoryStruct (‚Üê getLevels)) #[ctx.C, ctx.instCat]

def mkQuiverInst : MonoidalM Expr := do
  let ctx ‚Üê read
  return mkAppN (.const ``CategoryStruct.toQuiver (‚Üê getLevels)) #[ctx.C, ‚Üê mkCategoryStructInst]

def mkMonoidalCategoryStructInst : MonoidalM Expr := do
  let ctx ‚Üê read
  return mkAppN (.const ``MonoidalCategory.toMonoidalCategoryStruct (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal]

def mkTensorObj (f g : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  return mkAppN (.const ``MonoidalCategoryStruct.tensorObj (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ‚Üê mkMonoidalCategoryStructInst, f, g]

def mkTensorUnit : MonoidalM Expr := do
  let ctx ‚Üê read
  return mkAppN (.const ``MonoidalCategoryStruct.tensorUnit (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ‚Üê mkMonoidalCategoryStructInst]

def mkComp (Œ∑ Œ∏ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExpr Œ∑
  let g ‚Üê tgtExpr Œ∑
  let h ‚Üê tgtExpr Œ∏
  return mkAppN (.const ``CategoryStruct.comp [ctx.level‚ÇÇ, ctx.level‚ÇÅ])
    #[ctx.C, ‚Üê mkCategoryStructInst, f, g, h, Œ∑, Œ∏]

def mkId (f : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  return mkAppN (.const ``CategoryStruct.id [ctx.level‚ÇÇ, ctx.level‚ÇÅ])
    #[ctx.C, ‚Üê mkCategoryStructInst, f]

def mkIsoHom (Œ∑ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExprOfIso Œ∑
  let g ‚Üê tgtExprOfIso Œ∑
  return mkAppN (.const ``Iso.hom [ctx.level‚ÇÇ, ctx.level‚ÇÅ])
    #[ctx.C, ctx.instCat, f, g, Œ∑]

def mkIsoInv (Œ∑ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExprOfIso Œ∑
  let g ‚Üê tgtExprOfIso Œ∑
  return mkAppN (.const ``Iso.inv [ctx.level‚ÇÇ, ctx.level‚ÇÅ])
    #[ctx.C, ctx.instCat, f, g, Œ∑]

def mkWhiskerLeft (f Œ∑ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let g ‚Üê srcExpr Œ∑
  let h ‚Üê tgtExpr Œ∑
  return mkAppN (.const ``MonoidalCategoryStruct.whiskerLeft (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ‚Üê mkMonoidalCategoryStructInst, f, g, h, Œ∑]

def mkWhiskerRight (Œ∑ h : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExpr Œ∑
  let g ‚Üê tgtExpr Œ∑
  return mkAppN (.const ``MonoidalCategoryStruct.whiskerRight (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ‚Üê mkMonoidalCategoryStructInst, f, g, Œ∑, h]

def mkTensorHom (Œ∑ Œ∏ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExpr Œ∑
  let g ‚Üê tgtExpr Œ∑
  let h ‚Üê srcExpr Œ∏
  let i ‚Üê tgtExpr Œ∏
  return mkAppN (.const ``MonoidalCategoryStruct.tensorHom (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ‚Üê mkMonoidalCategoryStructInst, f, g, h, i, Œ∑, Œ∏]

def mkAssociator (f g h : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  return mkAppN (.const ``MonoidalCategoryStruct.associator (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ‚Üê mkMonoidalCategoryStructInst, f, g, h]

def mkLeftUnitor (f : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  return mkAppN (.const ``MonoidalCategoryStruct.leftUnitor (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ‚Üê mkMonoidalCategoryStructInst, f]

def mkRightUnitor (f : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  return mkAppN (.const ``MonoidalCategoryStruct.rightUnitor (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ‚Üê mkMonoidalCategoryStructInst, f]

def mkMonoidalCoherenceHom (f g inst : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  return mkAppN (.const ``MonoidalCoherence.hom (‚Üê getLevels))
    #[ctx.C, ctx.instCat, f, g, inst]

/-- Expressions for atomic 1-morphisms. -/
structure Atom‚ÇÅ : Type where
  /-- Extract a Lean expression from an `Atom‚ÇÅ` expression. -/
  e : Expr

/-- Expressions for 1-morphisms. -/
inductive Mor‚ÇÅ : Type
  /-- `id` is the expression for `ùüô_ C`. -/
  | id : Mor‚ÇÅ
  /-- `comp X Y` is the expression for `X ‚äó Y` -/
  | comp : Mor‚ÇÅ ‚Üí Mor‚ÇÅ ‚Üí Mor‚ÇÅ
  /-- Construct the expression for an atomic 1-morphism. -/
  | of : Atom‚ÇÅ ‚Üí Mor‚ÇÅ
  deriving Inhabited

/-- Converts a 1-morphism into a list of its components. -/
def Mor‚ÇÅ.toList : Mor‚ÇÅ ‚Üí List Atom‚ÇÅ
  | .id => []
  | .comp f g => f.toList ++ g.toList
  | .of f => [f]

/-- Returns `ùüô_ C` if the expression `e` is of the form `ùüô_ C`. -/
def isTensorUnit? (e : Expr) : MonoidalM (Option Expr) := do
  let unit ‚Üê mkTensorUnit
  if ‚Üê withDefault <| isDefEq e unit then
    return ‚Üê instantiateMVars unit
  else
    return none

/-- Returns `(f, g)` if the expression `e` is of the form `f ‚äó g`. -/
def isTensorObj? (e : Expr) : MonoidalM (Option (Expr √ó Expr)) := do
  let ctx ‚Üê read
  let f ‚Üê mkFreshExprMVar ctx.C
  let g ‚Üê mkFreshExprMVar ctx.C
  let fg ‚Üê mkTensorObj f g
  if ‚Üê withDefault <| isDefEq e fg then
    return (‚Üê instantiateMVars f, ‚Üê instantiateMVars g)
  else
    return none

/-- Construct a `Mor‚ÇÅ` expression from a Lean expression. -/
partial def toMor‚ÇÅ (e : Expr) : MonoidalM Mor‚ÇÅ := do
  if let some _ ‚Üê isTensorUnit? e then
    return Mor‚ÇÅ.id
  else if let some (f, g) ‚Üê isTensorObj? e then
    return (‚Üê toMor‚ÇÅ f).comp (‚Üê toMor‚ÇÅ g)
  else
    return Mor‚ÇÅ.of ‚ü®e‚ü©

/-- Expressions for atomic structural 2-morphisms. -/
inductive StructuralAtom : Type
  /-- The expression for the associator `(Œ±_ f g h).hom`. -/
  | associator (f g h : Mor‚ÇÅ) : StructuralAtom
  /-- The expression for the inverse of the associator `(Œ±_ f g h).inv`. -/
  | associatorInv (f g h : Mor‚ÇÅ) : StructuralAtom
  /-- The expression for the left unitor `(Œª_ f).hom`. -/
  | leftUnitor (f : Mor‚ÇÅ) : StructuralAtom
  /-- The expression for the inverse of the left unitor `(Œª_ f).inv`. -/
  | leftUnitorInv (f : Mor‚ÇÅ) : StructuralAtom
  /-- The expression for the right unitor `(œÅ_ f).hom`. -/
  | rightUnitor (f : Mor‚ÇÅ) : StructuralAtom
  /-- The expression for the inverse of the right unitor `(œÅ_ f).inv`. -/
  | rightUnitorInv (f : Mor‚ÇÅ) : StructuralAtom
  /-- Expressions for `Œ±` in the monoidal composition `Œ∑ ‚äó‚â´ Œ∏ := Œ∑ ‚â´ Œ± ‚â´ Œ∏`. -/
  | monoidalCoherence (f g : Mor‚ÇÅ) (e : Expr) : StructuralAtom
  deriving Inhabited

/-- Construct a `StructuralAtom` expression from a Lean expression. -/
def structuralAtom? (e : Expr) : MonoidalM (Option StructuralAtom) := do
  match (‚Üê whnfR e) with
  -- whnfR version of `| (``Iso.hom, #[_, _, _, _, Œ∑]) =>`
  | .proj ``Iso 0 Œ∑ =>
    match (‚Üê whnfR Œ∑).getAppFnArgs with
    | (``MonoidalCategoryStruct.associator, #[_, _, _, f, g, h]) =>
      return some <| .associator (‚Üê toMor‚ÇÅ f) (‚Üê toMor‚ÇÅ g) (‚Üê toMor‚ÇÅ h)
    | (``MonoidalCategoryStruct.leftUnitor, #[_, _, _, f]) =>
      return some <| .leftUnitor (‚Üê toMor‚ÇÅ f)
    | (``MonoidalCategoryStruct.rightUnitor, #[_, _, _, f]) =>
      return some <| .rightUnitor (‚Üê toMor‚ÇÅ f)
    | _ => return none
  -- whnfR version of `| (``Iso.inv, #[_, _, _, _, Œ∑]) =>`
  | .proj ``Iso 1 Œ∑ =>
    match (‚Üê whnfR Œ∑).getAppFnArgs with
    | (``MonoidalCategoryStruct.associator, #[_, _, _, f, g, h]) =>
      return some <| .associatorInv (‚Üê toMor‚ÇÅ f) (‚Üê toMor‚ÇÅ g) (‚Üê toMor‚ÇÅ h)
    | (``MonoidalCategoryStruct.leftUnitor, #[_, _, _, f]) =>
      return some <| .leftUnitorInv (‚Üê toMor‚ÇÅ f)
    | (``MonoidalCategoryStruct.rightUnitor, #[_, _, _, f]) =>
      return some <| .rightUnitorInv (‚Üê toMor‚ÇÅ f)
    | _ => return none
  | _ =>
    match (‚Üê whnfR e).getAppFnArgs with
    | (``MonoidalCoherence.hom, #[_, _, f, g, inst]) =>
      return some <| .monoidalCoherence (‚Üê toMor‚ÇÅ f) (‚Üê toMor‚ÇÅ g) inst
    | _ => return none

/-- Expressions for atomic non-structural 2-morphisms. -/
structure Atom where
  /-- Extract a Lean expression from an `Atom` expression. -/
  e : Expr
  deriving Inhabited

/-- Expressions of the form `Œ∑ ‚ñ∑ f‚ÇÅ ‚ñ∑ ... ‚ñ∑ f‚Çô`. -/
inductive WhiskerRightExpr : Type
  /-- Construct the expression for an atomic 2-morphism. -/
  | of (Œ∑ : Atom) : WhiskerRightExpr
  /-- Construct the expression for `Œ∑ ‚ñ∑ f`. -/
  | whisker (Œ∑ : WhiskerRightExpr) (f : Atom‚ÇÅ) : WhiskerRightExpr
  deriving Inhabited

/-- Expressions of the form `Œ∑‚ÇÅ ‚äó ... ‚äó Œ∑‚Çô`. -/
inductive TensorHomExpr : Type
  | of (Œ∑ : WhiskerRightExpr) : TensorHomExpr
  | cons (head : WhiskerRightExpr) (tail : TensorHomExpr) : TensorHomExpr
  deriving Inhabited

/-- Expressions of the form `f‚ÇÅ ‚óÅ ... ‚óÅ f‚Çô ‚óÅ Œ∑`. -/
inductive WhiskerLeftExpr : Type
  /-- Construct the expression for a right-whiskered 2-morphism. -/
  | of (Œ∑ : TensorHomExpr) : WhiskerLeftExpr
  /-- Construct the expression for `f ‚óÅ Œ∑`. -/
  | whisker (f : Atom‚ÇÅ) (Œ∑ : WhiskerLeftExpr) : WhiskerLeftExpr
  deriving Inhabited

/-- Expressions for structural 2-morphisms. -/
inductive Structural : Type
  /-- Expressions for atomic structural 2-morphisms. -/
  | atom (Œ∑ : StructuralAtom) : Structural
  /-- Expressions for the identity `ùüô f`. -/
  | id (f : Mor‚ÇÅ) : Structural
  /-- Expressions for the composition `Œ∑ ‚â´ Œ∏`. -/
  | comp (Œ± Œ≤ : Structural) : Structural
  /-- Expressions for the left whiskering `f ‚óÅ Œ∑`. -/
  | whiskerLeft (f : Mor‚ÇÅ) (Œ∑ : Structural) : Structural
  /-- Expressions for the right whiskering `Œ∑ ‚ñ∑ f`. -/
  | whiskerRight (Œ∑ : Structural) (f : Mor‚ÇÅ) : Structural
  /-- Expressions for the tensor `Œ± ‚äó Œ≤`. -/
  | tensorHom (Œ± Œ≤ : Structural) : Structural
  deriving Inhabited

/-- Normalized expressions for 2-morphisms. -/
inductive NormalExpr : Type
  /-- Construct the expression for a structural 2-morphism. -/
  | nil (Œ± : Structural) : NormalExpr
  /-- Construct the normalized expression of 2-morphisms recursively. -/
  | cons (head_structural : Structural) (head : WhiskerLeftExpr) (tail : NormalExpr) : NormalExpr
  deriving Inhabited

/-- The domain of a morphism. -/
def src (Œ∑ : Expr) : MonoidalM Mor‚ÇÅ := do
  match (‚Üê whnfR (‚Üê inferType Œ∑)).getAppFnArgs with
  | (``Quiver.Hom, #[_, _, f, _]) => toMor‚ÇÅ f
  | _ => throwError "{Œ∑} is not a morphism"

/-- The codomain of a morphism. -/
def tgt (Œ∑ : Expr) : MonoidalM Mor‚ÇÅ := do
  match (‚Üê whnfR (‚Üê inferType Œ∑)).getAppFnArgs with
  | (``Quiver.Hom, #[_, _, _, g]) => toMor‚ÇÅ g
  | _ => throwError "{Œ∑} is not a morphism"

/-- The domain of a 2-morphism. -/
def Atom.src (Œ∑ : Atom) : MonoidalM Mor‚ÇÅ := do Monoidal.src Œ∑.e

/-- The codomain of a 2-morphism. -/
def Atom.tgt (Œ∑ : Atom) : MonoidalM Mor‚ÇÅ := do Monoidal.tgt Œ∑.e

/-- The domain of a 2-morphism. -/
def WhiskerRightExpr.src : WhiskerRightExpr ‚Üí MonoidalM Mor‚ÇÅ
  | WhiskerRightExpr.of Œ∑ => Œ∑.src
  | WhiskerRightExpr.whisker Œ∑ f => return (‚Üê WhiskerRightExpr.src Œ∑).comp (Mor‚ÇÅ.of f)

/-- The codomain of a 2-morphism. -/
def WhiskerRightExpr.tgt : WhiskerRightExpr ‚Üí MonoidalM Mor‚ÇÅ
  | WhiskerRightExpr.of Œ∑ => Œ∑.tgt
  | WhiskerRightExpr.whisker Œ∑ f => return (‚Üê WhiskerRightExpr.tgt Œ∑).comp (Mor‚ÇÅ.of f)

/-- The domain of a 2-morphism. -/
def TensorHomExpr.src : TensorHomExpr ‚Üí MonoidalM Mor‚ÇÅ
  | TensorHomExpr.of Œ∑ => Œ∑.src
  | TensorHomExpr.cons Œ∑ Œ∑s => return (‚Üê Œ∑.src).comp (‚Üê Œ∑s.src)

/-- The codomain of a 2-morphism. -/
def TensorHomExpr.tgt : TensorHomExpr ‚Üí MonoidalM Mor‚ÇÅ
  | TensorHomExpr.of Œ∑ => Œ∑.tgt
  | TensorHomExpr.cons Œ∑ Œ∑s => return (‚Üê Œ∑.tgt).comp (‚Üê Œ∑s.tgt)

/-- The domain of a 2-morphism. -/
def WhiskerLeftExpr.src : WhiskerLeftExpr ‚Üí MonoidalM Mor‚ÇÅ
  | WhiskerLeftExpr.of Œ∑ => TensorHomExpr.src Œ∑
  | WhiskerLeftExpr.whisker f Œ∑ => return (Mor‚ÇÅ.of f).comp (‚Üê WhiskerLeftExpr.src Œ∑)

/-- The codomain of a 2-morphism. -/
def WhiskerLeftExpr.tgt : WhiskerLeftExpr ‚Üí MonoidalM Mor‚ÇÅ
  | WhiskerLeftExpr.of Œ∑ => TensorHomExpr.tgt Œ∑
  | WhiskerLeftExpr.whisker f Œ∑ => return (Mor‚ÇÅ.of f).comp (‚Üê WhiskerLeftExpr.tgt Œ∑)

/-- The domain of a 2-morphism. -/
def StructuralAtom.src : StructuralAtom ‚Üí Mor‚ÇÅ
  | .associator f g h => (f.comp g).comp h
  | .associatorInv f g h => f.comp (g.comp h)
  | .leftUnitor f => Mor‚ÇÅ.id.comp f
  | .leftUnitorInv f => f
  | .rightUnitor f => f.comp Mor‚ÇÅ.id
  | .rightUnitorInv f => f
  | .monoidalCoherence f _ _ => f

/-- The codomain of a 2-morphism. -/
def StructuralAtom.tgt : StructuralAtom ‚Üí Mor‚ÇÅ
  | .associator f g h => f.comp (g.comp h)
  | .associatorInv f g h => (f.comp g).comp h
  | .leftUnitor f => f
  | .leftUnitorInv f => Mor‚ÇÅ.id.comp f
  | .rightUnitor f => f
  | .rightUnitorInv f => f.comp Mor‚ÇÅ.id
  | .monoidalCoherence _ g _ => g

/-- The domain of a 2-morphism. -/
def Structural.src : Structural ‚Üí Mor‚ÇÅ
  | .atom Œ∑ => Œ∑.src
  | .id f => f
  | .comp Œ± _ => Œ±.src
  | .whiskerLeft f Œ∑ => f.comp Œ∑.src
  | .whiskerRight Œ∑ f => Œ∑.src.comp f
  | .tensorHom Œ± Œ≤ => Œ±.src.comp Œ≤.src

/-- The codomain of a 2-morphism. -/
def Structural.tgt : Structural ‚Üí Mor‚ÇÅ
  | .atom Œ∑ => Œ∑.tgt
  | .id f => f
  | .comp _ Œ≤ => Œ≤.tgt
  | .whiskerLeft f Œ∑ => f.comp Œ∑.tgt
  | .whiskerRight Œ∑ f => Œ∑.tgt.comp f
  | .tensorHom Œ± Œ≤ => Œ±.tgt.comp Œ≤.tgt

/-- The domain of a 2-morphism. -/
def NormalExpr.src : NormalExpr ‚Üí Mor‚ÇÅ
  | NormalExpr.nil Œ∑ => Œ∑.src
  | NormalExpr.cons Œ± _ _ => Œ±.src

/-- The codomain of a 2-morphism. -/
def NormalExpr.tgt : NormalExpr ‚Üí Mor‚ÇÅ
  | NormalExpr.nil Œ∑ => Œ∑.tgt
  | NormalExpr.cons _ _ Œ∑s => Œ∑s.tgt

/-- The associator as a term of `normalExpr`. -/
def NormalExpr.associator (f g h : Mor‚ÇÅ) : NormalExpr :=
  .nil <| .atom <| .associator f g h

/-- The inverse of the associator as a term of `normalExpr`. -/
def NormalExpr.associatorInv (f g h : Mor‚ÇÅ) : NormalExpr :=
  .nil <| .atom <| .associatorInv f g h

/-- The left unitor as a term of `normalExpr`. -/
def NormalExpr.leftUnitor (f : Mor‚ÇÅ) : NormalExpr :=
  .nil <| .atom <| .leftUnitor f

/-- The inverse of the left unitor as a term of `normalExpr`. -/
def NormalExpr.leftUnitorInv (f : Mor‚ÇÅ) : NormalExpr :=
  .nil <| .atom <| .leftUnitorInv f

/-- The right unitor as a term of `normalExpr`. -/
def NormalExpr.rightUnitor (f : Mor‚ÇÅ) : NormalExpr :=
  .nil <| .atom <| .rightUnitor f

/-- The inverse of the right unitor as a term of `normalExpr`. -/
def NormalExpr.rightUnitorInv (f : Mor‚ÇÅ) : NormalExpr :=
  .nil <| .atom <| .rightUnitorInv f

/-- Construct a `NormalExpr` expression from a `WhiskerLeftExpr` expression. -/
def NormalExpr.of (Œ∑ : WhiskerLeftExpr) : MonoidalM NormalExpr := do
  return .cons (.id (‚Üê Œ∑.src)) Œ∑ (.nil (.id (‚Üê Œ∑.tgt)))

/-- Construct a `NormalExpr` expression from a Lean expression for an atomic 2-morphism. -/
def NormalExpr.ofExpr (Œ∑ : Expr) : MonoidalM NormalExpr :=
  NormalExpr.of <| .of <| .of <| .of ‚ü®Œ∑‚ü©

/-- If `e` is an expression of the form `Œ∑ ‚äó‚â´ Œ∏ := Œ∑ ‚â´ Œ± ‚â´ Œ∏` in the monoidal category `C`,
return the expression for `Œ±` .-/
def structuralOfMonoidalComp (e : Expr) : MonoidalM Structural := do
  let ctx ‚Üê read
  let f ‚Üê mkFreshExprMVar ctx.C
  let g ‚Üê mkFreshExprMVar ctx.C
  let h ‚Üê mkFreshExprMVar ctx.C
  let i ‚Üê mkFreshExprMVar ctx.C
  let Œ∑ ‚Üê mkFreshExprMVar (mkAppN (.const ``Quiver.Hom [ctx.level‚ÇÇ.succ, ctx.level‚ÇÅ])
    #[ctx.C, ‚Üê mkQuiverInst, f, g])
  let Œ±‚ÇÄ ‚Üê mkFreshExprMVar (mkAppN (.const ``Quiver.Hom [ctx.level‚ÇÇ.succ, ctx.level‚ÇÅ])
    #[ctx.C, ‚Üê mkQuiverInst, g, h])
  let Œ∏ ‚Üê mkFreshExprMVar (mkAppN (.const ``Quiver.Hom [ctx.level‚ÇÇ.succ, ctx.level‚ÇÅ])
    #[ctx.C, ‚Üê mkQuiverInst, h, i])
  let Œ±Œ∏ := mkAppN (.const ``CategoryStruct.comp (‚Üê getLevels))
    #[ctx.C, ‚Üê mkCategoryStructInst, g, h, i, Œ±‚ÇÄ, Œ∏]
  let Œ∑Œ±Œ∏ := mkAppN (.const ``CategoryStruct.comp (‚Üê getLevels))
    #[ctx.C, ‚Üê mkCategoryStructInst, f, g, i, Œ∑, Œ±Œ∏]
  _ ‚Üê isDefEq e Œ∑Œ±Œ∏
  match ‚Üê structuralAtom? (‚Üê instantiateMVars Œ±‚ÇÄ) with
  | some Œ± => return .atom Œ±
  | none => throwError "not a structural 2-morphism"

section

open scoped MonoidalCategory

universe v u

variable {C : Type u} [Category.{v} C]

variable {f f' g g' h h' i i' j : C}

@[nolint synTaut]
theorem evalComp_nil_nil {f g h : C} (Œ± : f ‚ü∂ g) (Œ≤ : g ‚ü∂ h) :
    Œ± ‚â´ Œ≤ = Œ± ‚â´ Œ≤ := by
  simp

def mkEvalCompNilNil (Œ± Œ≤ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExpr Œ±
  let g ‚Üê tgtExpr Œ±
  let h ‚Üê tgtExpr Œ≤
  return mkAppN (.const ``evalComp_nil_nil (‚Üê getLevels))
    #[ctx.C, ctx.instCat, f, g, h, Œ±, Œ≤]

theorem evalComp_nil_cons {f g h i j : C} (Œ± : f ‚ü∂ g) (Œ≤ : g ‚ü∂ h) (Œ∑ : h ‚ü∂ i) (Œ∑s : i ‚ü∂ j) :
    Œ± ‚â´ (Œ≤ ‚â´ Œ∑ ‚â´ Œ∑s) = (Œ± ‚â´ Œ≤) ‚â´ Œ∑ ‚â´ Œ∑s := by
  simp

def mkEvalCompNilCons (Œ± Œ≤ Œ∑ Œ∑s : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExpr Œ±
  let g ‚Üê tgtExpr Œ±
  let h ‚Üê tgtExpr Œ≤
  let i ‚Üê tgtExpr Œ∑
  let j ‚Üê tgtExpr Œ∑s
  return mkAppN (.const ``evalComp_nil_cons (‚Üê getLevels))
    #[ctx.C, ctx.instCat, f, g, h, i, j, Œ±, Œ≤, Œ∑, Œ∑s]

theorem evalComp_cons {f g h i j : C} (Œ± : f ‚ü∂ g) (Œ∑ : g ‚ü∂ h) {Œ∑s : h ‚ü∂ i} {Œ∏ : i ‚ü∂ j} {Œπ : h ‚ü∂ j}
    (pf_Œπ : Œ∑s ‚â´ Œ∏ = Œπ)  :
    (Œ± ‚â´ Œ∑ ‚â´ Œ∑s) ‚â´ Œ∏ = Œ± ‚â´ Œ∑ ‚â´ Œπ := by
  simp [pf_Œπ]

def mkEvalCompCons (Œ± Œ∑ Œ∑s Œ∏ Œπ pf_Œπ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExpr Œ±
  let g ‚Üê tgtExpr Œ±
  let h ‚Üê tgtExpr Œ∑
  let i ‚Üê tgtExpr Œ∑s
  let j ‚Üê tgtExpr Œ∏
  return mkAppN (.const ``evalComp_cons (‚Üê getLevels))
    #[ctx.C, ctx.instCat, f, g, h, i, j, Œ±, Œ∑, Œ∑s, Œ∏, Œπ, pf_Œπ]

theorem eval_comp
    {Œ∑ Œ∑' : f ‚ü∂ g} {Œ∏ Œ∏' : g ‚ü∂ h} {Œπ : f ‚ü∂ h}
    (pf_Œ∑ : Œ∑ = Œ∑') (pf_Œ∏ : Œ∏ = Œ∏') (pf_Œ∑Œ∏ : Œ∑' ‚â´ Œ∏' = Œπ) :
    Œ∑ ‚â´ Œ∏ = Œπ := by
  simp [pf_Œ∑, pf_Œ∏, pf_Œ∑Œ∏]

def mkEvalComp (Œ∑ Œ∑' Œ∏ Œ∏' Œπ pf_Œ∑ pf_Œ∏ pf_Œ∑Œ∏ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExpr Œ∑
  let g ‚Üê tgtExpr Œ∑
  let h ‚Üê tgtExpr Œ∏
  return mkAppN (.const ``eval_comp (‚Üê getLevels))
    #[ctx.C, ctx.instCat, f, g, h, Œ∑, Œ∑', Œ∏, Œ∏', Œπ, pf_Œ∑, pf_Œ∏, pf_Œ∑Œ∏]

theorem eval_of (Œ∑ : f ‚ü∂ g) :
    Œ∑ = ùüô _ ‚â´ Œ∑ ‚â´ ùüô _ := by
  simp

def mkEvalOf (Œ∑ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExpr Œ∑
  let g ‚Üê tgtExpr Œ∑
  return mkAppN (.const ``eval_of (‚Üê getLevels))
    #[ctx.C, ctx.instCat, f, g, Œ∑]

theorem eval_monoidalComp
    {Œ∑ Œ∑' : f ‚ü∂ g} {Œ± : g ‚ü∂ h} {Œ∏ Œ∏' : h ‚ü∂ i} {Œ±Œ∏ : g ‚ü∂ i} {Œ∑Œ±Œ∏ : f ‚ü∂ i}
    (pf_Œ∑ : Œ∑ = Œ∑') (pf_Œ∏ : Œ∏ = Œ∏') (pf_Œ±Œ∏ : Œ± ‚â´ Œ∏' = Œ±Œ∏) (pf_Œ∑Œ±Œ∏ : Œ∑' ‚â´ Œ±Œ∏ = Œ∑Œ±Œ∏) :
    Œ∑ ‚â´ Œ± ‚â´ Œ∏ = Œ∑Œ±Œ∏ := by
  simp [pf_Œ∑, pf_Œ∏, pf_Œ±Œ∏, pf_Œ∑Œ±Œ∏]

def mkEvalMonoidalComp (Œ∑ Œ∑' Œ± Œ∏ Œ∏' Œ±Œ∏ Œ∑Œ±Œ∏ pf_Œ∑ pf_Œ∏ pf_Œ±Œ∏ pf_Œ∑Œ±Œ∏ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExpr Œ∑
  let g ‚Üê tgtExpr Œ∑
  let h ‚Üê tgtExpr Œ±
  let i ‚Üê tgtExpr Œ∏
  return mkAppN (.const ``eval_monoidalComp (‚Üê getLevels))
    #[ctx.C, ctx.instCat, f, g, h, i, Œ∑, Œ∑', Œ±, Œ∏, Œ∏', Œ±Œ∏, Œ∑Œ±Œ∏, pf_Œ∑, pf_Œ∏, pf_Œ±Œ∏, pf_Œ∑Œ±Œ∏]

variable [MonoidalCategory C]

@[nolint synTaut]
theorem evalWhiskerLeft_nil (f : C) {g h : C} (Œ± : g ‚ü∂ h) :
    f ‚óÅ Œ± = f ‚óÅ Œ± := by
  simp

def mkEvalWhiskerLeftNil (f Œ± : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let g ‚Üê srcExpr Œ±
  let h ‚Üê tgtExpr Œ±
  return mkAppN (.const ``evalWhiskerLeft_nil (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, f, g, h, Œ±]

theorem evalWhiskerLeft_of_cons {f g h i j : C}
    (Œ± : g ‚ü∂ h) (Œ∑ : h ‚ü∂ i) {Œ∑s : i ‚ü∂ j} {Œ∏ : f ‚äó i ‚ü∂ f ‚äó j} (pf_Œ∏ : f ‚óÅ Œ∑s = Œ∏) :
    f ‚óÅ (Œ± ‚â´ Œ∑ ‚â´ Œ∑s) = f ‚óÅ Œ± ‚â´ f ‚óÅ Œ∑ ‚â´ Œ∏ := by
  simp [pf_Œ∏]

def mkEvalWhiskerLeft_of_cons (f Œ± Œ∑ Œ∑s Œ∏ pf_Œ∏ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let g ‚Üê srcExpr Œ±
  let h ‚Üê tgtExpr Œ±
  let i ‚Üê tgtExpr Œ∑
  let j ‚Üê tgtExpr Œ∑s
  return mkAppN (.const ``evalWhiskerLeft_of_cons (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, f, g, h, i, j, Œ±, Œ∑, Œ∑s, Œ∏, pf_Œ∏]

theorem evalWhiskerLeft_comp {f g h i : C}
    {Œ∑ : h ‚ü∂ i} {Œ∏ : g ‚äó h ‚ü∂ g ‚äó i} {Œπ : f ‚äó g ‚äó h ‚ü∂ f ‚äó g ‚äó i}
    {Œπ' : f ‚äó g ‚äó h ‚ü∂ (f ‚äó g) ‚äó i} {Œπ'' : (f ‚äó g) ‚äó h ‚ü∂ (f ‚äó g) ‚äó i}
    (pf_Œ∏ : g ‚óÅ Œ∑ = Œ∏) (pf_Œπ : f ‚óÅ Œ∏ = Œπ)
    (pf_Œπ' : Œπ ‚â´ (Œ±_ _ _ _).inv = Œπ') (pf_Œπ'' : (Œ±_ _ _ _).hom ‚â´ Œπ' = Œπ'') :
    (f ‚äó g) ‚óÅ Œ∑ = Œπ'' := by
  simp [pf_Œ∏, pf_Œπ, pf_Œπ', pf_Œπ'']

def mkEvalWhiskerLeft_comp (f g Œ∑ Œ∏ Œπ Œπ' Œπ'' pf_Œ∏ pf_Œπ pf_Œπ' pf_Œπ'' : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let h ‚Üê srcExpr Œ∑
  let i ‚Üê tgtExpr Œ∑
  return mkAppN (.const ``evalWhiskerLeft_comp (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, f, g, h, i, Œ∑, Œ∏, Œπ, Œπ', Œπ'', pf_Œ∏, pf_Œπ, pf_Œπ', pf_Œπ'']

theorem evalWhiskerLeft_id {f g : C} {Œ∑ : f ‚ü∂ g}
    {Œ∑' : f ‚ü∂ ùüô_ C ‚äó g} {Œ∑'' : ùüô_ C ‚äó f ‚ü∂ ùüô_ C ‚äó g}
    (pf_Œ∑' : Œ∑ ‚â´ (Œª_ _).inv = Œ∑') (pf_Œ∑'' : (Œª_ _).hom ‚â´ Œ∑' = Œ∑'') :
    ùüô_ C ‚óÅ Œ∑ = Œ∑'' := by
  simp [pf_Œ∑', pf_Œ∑'']

def mkEvalWhiskerLeftId (Œ∑ Œ∑' Œ∑'' pf_Œ∑' pf_Œ∑'' : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExpr Œ∑
  let g ‚Üê tgtExpr Œ∑
  return mkAppN (.const ``evalWhiskerLeft_id (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, f, g, Œ∑, Œ∑', Œ∑'', pf_Œ∑', pf_Œ∑'']

theorem eval_whiskerLeft {f g h : C}
    {Œ∑ Œ∑' : g ‚ü∂ h} {Œ∏ : f ‚äó g ‚ü∂ f ‚äó h}
    (pf_Œ∑ : Œ∑ = Œ∑') (pf_Œ∏ : f ‚óÅ Œ∑' = Œ∏) :
    f ‚óÅ Œ∑ = Œ∏ := by
  simp [pf_Œ∑, pf_Œ∏]

def mkEvalWhiskerLeft (f Œ∑ Œ∑' Œ∏ pf_Œ∑ pf_Œ∏ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let g ‚Üê srcExpr Œ∑
  let h ‚Üê tgtExpr Œ∑
  return mkAppN (.const ``eval_whiskerLeft (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, f, g, h, Œ∑, Œ∑', Œ∏, pf_Œ∑, pf_Œ∏]

theorem eval_whiskerRight {f g h : C}
    {Œ∑ Œ∑' : f ‚ü∂ g} {Œ∏ : f ‚äó h ‚ü∂ g ‚äó h}
    (pf_Œ∑ : Œ∑ = Œ∑') (pf_Œ∏ : Œ∑' ‚ñ∑ h = Œ∏) :
    Œ∑ ‚ñ∑ h = Œ∏ := by
  simp [pf_Œ∑, pf_Œ∏]

def mkEvalWhiskerRight (h Œ∑ Œ∑' Œ∏ pf_Œ∑ pf_Œ∏ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExpr Œ∑
  let g ‚Üê tgtExpr Œ∑
  return mkAppN (.const ``eval_whiskerRight (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, f, g, h, Œ∑, Œ∑', Œ∏, pf_Œ∑, pf_Œ∏]

theorem eval_tensorHom {f g h i : C}
    {Œ∑ Œ∑' : f ‚ü∂ g} {Œ∏ Œ∏' : h ‚ü∂ i} {Œπ : f ‚äó h ‚ü∂ g ‚äó i}
    (pf_Œ∑ : Œ∑ = Œ∑') (pf_Œ∏ : Œ∏ = Œ∏') (pf_Œπ : Œ∑' ‚äó Œ∏' = Œπ) :
    Œ∑ ‚äó Œ∏ = Œπ := by
  simp [pf_Œ∑, pf_Œ∏, pf_Œπ]

def mkEvalTensorHom (Œ∑ Œ∑' Œ∏ Œ∏' Œπ pf_Œ∑ pf_Œ∏ pf_Œπ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExpr Œ∑
  let g ‚Üê tgtExpr Œ∑
  let h ‚Üê srcExpr Œ∏
  let i ‚Üê tgtExpr Œ∏
  return mkAppN (.const ``eval_tensorHom (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, f, g, h, i, Œ∑, Œ∑', Œ∏, Œ∏', Œπ, pf_Œ∑, pf_Œ∏, pf_Œπ]

@[nolint synTaut]
theorem evalWhiskerRight_nil {f g : C} (Œ± : f ‚ü∂ g) (h : C) :
    Œ± ‚ñ∑ h = Œ± ‚ñ∑ h := by
  simp

def mkEvalWhiskerRightNil (Œ± h : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExpr Œ±
  let g ‚Üê tgtExpr Œ±
  return mkAppN (.const ``evalWhiskerRight_nil (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, f, g, Œ±, h]

theorem evalWhiskerRight_cons_of_of {f g h i j : C}
    {Œ± : f ‚ü∂ g} {Œ∑ : g ‚ü∂ h} {Œ∑s : h ‚ü∂ i} {Œ∑s‚ÇÅ : h ‚äó j ‚ü∂ i ‚äó j}
    {Œ∑‚ÇÅ : g ‚äó j ‚ü∂ h ‚äó j} {Œ∑‚ÇÇ : g ‚äó j ‚ü∂ i ‚äó j} {Œ∑‚ÇÉ : f ‚äó j ‚ü∂ i ‚äó j}
    (pf_Œ∑s‚ÇÅ : Œ∑s ‚ñ∑ j = Œ∑s‚ÇÅ) (pf_Œ∑‚ÇÅ : Œ∑ ‚ñ∑ j = Œ∑‚ÇÅ)
    (pf_Œ∑‚ÇÇ : Œ∑‚ÇÅ ‚â´ Œ∑s‚ÇÅ = Œ∑‚ÇÇ) (pf_Œ∑‚ÇÉ : Œ± ‚ñ∑ j ‚â´ Œ∑‚ÇÇ = Œ∑‚ÇÉ) :
    (Œ± ‚â´ Œ∑ ‚â´ Œ∑s) ‚ñ∑ j = Œ∑‚ÇÉ := by
  simp_all

def mkEvalWhiskerRightConsOfOf (j Œ± Œ∑ Œ∑s Œ∑s‚ÇÅ Œ∑‚ÇÅ Œ∑‚ÇÇ Œ∑‚ÇÉ pf_Œ∑s‚ÇÅ pf_Œ∑‚ÇÅ pf_Œ∑‚ÇÇ pf_Œ∑‚ÇÉ : Expr) :
    MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExpr Œ±
  let g ‚Üê tgtExpr Œ±
  let h ‚Üê tgtExpr Œ∑
  let i ‚Üê tgtExpr Œ∑s
  return mkAppN (.const ``evalWhiskerRight_cons_of_of (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal,
      f, g, h, i, j, Œ±, Œ∑, Œ∑s, Œ∑s‚ÇÅ, Œ∑‚ÇÅ, Œ∑‚ÇÇ, Œ∑‚ÇÉ, pf_Œ∑s‚ÇÅ, pf_Œ∑‚ÇÅ, pf_Œ∑‚ÇÇ, pf_Œ∑‚ÇÉ]

theorem evalWhiskerRight_cons_whisker {f g h i j k : C}
    {Œ± : g ‚ü∂ f ‚äó h} {Œ∑ : h ‚ü∂ i} {Œ∑s : f ‚äó i ‚ü∂ j}
    {Œ∑‚ÇÅ : h ‚äó k ‚ü∂ i ‚äó k} {Œ∑‚ÇÇ : f ‚äó (h ‚äó k) ‚ü∂ f ‚äó (i ‚äó k)} {Œ∑s‚ÇÅ : (f ‚äó i) ‚äó k ‚ü∂ j ‚äó k}
    {Œ∑s‚ÇÇ : f ‚äó (i ‚äó k) ‚ü∂ j ‚äó k} {Œ∑‚ÇÉ : f ‚äó (h ‚äó k) ‚ü∂ j ‚äó k} {Œ∑‚ÇÑ : (f ‚äó h) ‚äó k ‚ü∂ j ‚äó k}
    {Œ∑‚ÇÖ : g ‚äó k ‚ü∂ j ‚äó k}
    (pf_Œ∑‚ÇÅ : (ùüô _ ‚â´ Œ∑ ‚â´ ùüô _ ) ‚ñ∑ k = Œ∑‚ÇÅ) (pf_Œ∑‚ÇÇ : f ‚óÅ Œ∑‚ÇÅ = Œ∑‚ÇÇ)
    (pf_Œ∑s‚ÇÅ : Œ∑s ‚ñ∑ k = Œ∑s‚ÇÅ) (pf_Œ∑s‚ÇÇ : (Œ±_ _ _ _).inv ‚â´ Œ∑s‚ÇÅ = Œ∑s‚ÇÇ)
    (pf_Œ∑‚ÇÉ : Œ∑‚ÇÇ ‚â´ Œ∑s‚ÇÇ = Œ∑‚ÇÉ) (pf_Œ∑‚ÇÑ : (Œ±_ _ _ _).hom ‚â´ Œ∑‚ÇÉ = Œ∑‚ÇÑ) (pf_Œ∑‚ÇÖ : Œ± ‚ñ∑ k ‚â´ Œ∑‚ÇÑ = Œ∑‚ÇÖ) :
    (Œ± ‚â´ (f ‚óÅ Œ∑) ‚â´ Œ∑s) ‚ñ∑ k = Œ∑‚ÇÖ := by
  simp at pf_Œ∑‚ÇÅ
  simp [pf_Œ∑‚ÇÅ, pf_Œ∑‚ÇÇ, pf_Œ∑s‚ÇÅ, pf_Œ∑s‚ÇÇ, pf_Œ∑‚ÇÉ, pf_Œ∑‚ÇÑ, pf_Œ∑‚ÇÖ]

def mkEvalWhiskerRightConsWhisker
    (f k Œ± Œ∑ Œ∑s Œ∑‚ÇÅ Œ∑‚ÇÇ Œ∑s‚ÇÅ Œ∑s‚ÇÇ Œ∑‚ÇÉ Œ∑‚ÇÑ Œ∑‚ÇÖ
    pf_Œ∑‚ÇÅ pf_Œ∑‚ÇÇ pf_Œ∑s‚ÇÅ pf_Œ∑s‚ÇÇ pf_Œ∑‚ÇÉ pf_Œ∑‚ÇÑ pf_Œ∑‚ÇÖ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let g ‚Üê srcExpr Œ±
  let h ‚Üê srcExpr Œ∑
  let i ‚Üê tgtExpr Œ∑
  let j ‚Üê tgtExpr Œ∑s
  return mkAppN (.const ``evalWhiskerRight_cons_whisker (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal,
      f, g, h, i, j, k, Œ±, Œ∑, Œ∑s, Œ∑‚ÇÅ, Œ∑‚ÇÇ, Œ∑s‚ÇÅ, Œ∑s‚ÇÇ, Œ∑‚ÇÉ, Œ∑‚ÇÑ, Œ∑‚ÇÖ,
      pf_Œ∑‚ÇÅ, pf_Œ∑‚ÇÇ, pf_Œ∑s‚ÇÅ, pf_Œ∑s‚ÇÇ, pf_Œ∑‚ÇÉ, pf_Œ∑‚ÇÑ, pf_Œ∑‚ÇÖ]

theorem evalWhiskerRight_comp {f f' g h : C}
    {Œ∑ : f ‚ü∂ f'} {Œ∑‚ÇÅ : f ‚äó g ‚ü∂ f' ‚äó g} {Œ∑‚ÇÇ : (f ‚äó g) ‚äó h ‚ü∂ (f' ‚äó g) ‚äó h}
    {Œ∑‚ÇÉ : (f ‚äó g) ‚äó h ‚ü∂ f' ‚äó (g ‚äó h)} {Œ∑‚ÇÑ : f ‚äó (g ‚äó h) ‚ü∂ f' ‚äó (g ‚äó h)}
    (pf_Œ∑‚ÇÅ : Œ∑ ‚ñ∑ g = Œ∑‚ÇÅ) (pf_Œ∑‚ÇÇ : Œ∑‚ÇÅ ‚ñ∑ h = Œ∑‚ÇÇ)
    (pf_Œ∑‚ÇÉ : Œ∑‚ÇÇ ‚â´ (Œ±_ _ _ _).hom = Œ∑‚ÇÉ) (pf_Œ∑‚ÇÑ : (Œ±_ _ _ _).inv ‚â´ Œ∑‚ÇÉ = Œ∑‚ÇÑ) :
    Œ∑ ‚ñ∑ (g ‚äó h) = Œ∑‚ÇÑ := by
  simp [pf_Œ∑‚ÇÅ, pf_Œ∑‚ÇÇ, pf_Œ∑‚ÇÉ, pf_Œ∑‚ÇÑ]

def mkEvalWhiskerRightComp (g h Œ∑ Œ∑‚ÇÅ Œ∑‚ÇÇ Œ∑‚ÇÉ Œ∑‚ÇÑ pf_Œ∑‚ÇÅ pf_Œ∑‚ÇÇ pf_Œ∑‚ÇÉ pf_Œ∑‚ÇÑ : Expr) :
    MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExpr Œ∑
  let f' ‚Üê tgtExpr Œ∑
  return mkAppN (.const ``evalWhiskerRight_comp (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal,
      f, f', g, h, Œ∑, Œ∑‚ÇÅ, Œ∑‚ÇÇ, Œ∑‚ÇÉ, Œ∑‚ÇÑ, pf_Œ∑‚ÇÅ, pf_Œ∑‚ÇÇ, pf_Œ∑‚ÇÉ, pf_Œ∑‚ÇÑ]

theorem evalWhiskerRight_id {f g : C}
    {Œ∑ : f ‚ü∂ g} {Œ∑‚ÇÅ : f ‚ü∂ g ‚äó ùüô_ C} {Œ∑‚ÇÇ : f ‚äó ùüô_ C ‚ü∂ g ‚äó ùüô_ C}
    (pf_Œ∑‚ÇÅ : Œ∑ ‚â´ (œÅ_ _).inv = Œ∑‚ÇÅ) (pf_Œ∑‚ÇÇ : (œÅ_ _).hom ‚â´ Œ∑‚ÇÅ = Œ∑‚ÇÇ) :
    Œ∑ ‚ñ∑ ùüô_ C = Œ∑‚ÇÇ := by
  simp [pf_Œ∑‚ÇÅ, pf_Œ∑‚ÇÇ]

def mkEvalWhiskerRightId (Œ∑ Œ∑‚ÇÅ Œ∑‚ÇÇ pf_Œ∑‚ÇÅ pf_Œ∑‚ÇÇ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExpr Œ∑
  let g ‚Üê tgtExpr Œ∑
  return mkAppN (.const ``evalWhiskerRight_id (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, f, g, Œ∑, Œ∑‚ÇÅ, Œ∑‚ÇÇ, pf_Œ∑‚ÇÅ, pf_Œ∑‚ÇÇ]

theorem evalWhiskerRightExprAux_of {g h : C} (Œ∑ : g ‚ü∂ h) (f : C) :
    Œ∑ ‚ñ∑ f = ùüô _ ‚â´ Œ∑ ‚ñ∑ f ‚â´ ùüô _ := by
  simp

def mkEvalWhiskerRightExprAuxOf (Œ∑ f : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let g ‚Üê srcExpr Œ∑
  let h ‚Üê tgtExpr Œ∑
  return mkAppN (.const ``evalWhiskerRightExprAux_of (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, g, h, Œ∑, f]

theorem evalWhiskerRightExprAux_cons {f g h i j : C} {Œ∑ : g ‚ü∂ h} {Œ∑s : i ‚ü∂ j}
    {Œ∑s' : i ‚äó f ‚ü∂ j ‚äó f} {Œ∑‚ÇÅ : g ‚äó (i ‚äó f) ‚ü∂ h ‚äó (j ‚äó f)}
    {Œ∑‚ÇÇ : g ‚äó (i ‚äó f) ‚ü∂ (h ‚äó j) ‚äó f} {Œ∑‚ÇÉ : (g ‚äó i) ‚äó f ‚ü∂ (h ‚äó j) ‚äó f}
    (pf_Œ∑s' : Œ∑s ‚ñ∑ f = Œ∑s') (pf_Œ∑‚ÇÅ : (ùüô _ ‚â´ Œ∑ ‚â´ ùüô _) ‚äó Œ∑s' = Œ∑‚ÇÅ)
    (pf_Œ∑‚ÇÇ : Œ∑‚ÇÅ ‚â´ (Œ±_ _ _ _).inv = Œ∑‚ÇÇ) (pf_Œ∑‚ÇÉ : (Œ±_ _ _ _).hom ‚â´ Œ∑‚ÇÇ = Œ∑‚ÇÉ) :
    (Œ∑ ‚äó Œ∑s) ‚ñ∑ f = Œ∑‚ÇÉ := by
  simp [‚Üê pf_Œ∑s', ‚Üê pf_Œ∑‚ÇÅ, ‚Üê pf_Œ∑‚ÇÇ, ‚Üê pf_Œ∑‚ÇÉ, MonoidalCategory.tensorHom_def]

def mkEvalWhiskerRightExprAuxCons (f Œ∑ Œ∑s Œ∑s' Œ∑‚ÇÅ Œ∑‚ÇÇ Œ∑‚ÇÉ pf_Œ∑s' pf_Œ∑‚ÇÅ pf_Œ∑‚ÇÇ pf_Œ∑‚ÇÉ : Expr) :
    MonoidalM Expr := do
  let ctx ‚Üê read
  let g ‚Üê srcExpr Œ∑
  let h ‚Üê tgtExpr Œ∑
  let i ‚Üê srcExpr Œ∑s
  let j ‚Üê tgtExpr Œ∑s
  return mkAppN (.const ``evalWhiskerRightExprAux_cons (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal,
      f, g, h, i, j, Œ∑, Œ∑s, Œ∑s', Œ∑‚ÇÅ, Œ∑‚ÇÇ, Œ∑‚ÇÉ, pf_Œ∑s', pf_Œ∑‚ÇÅ, pf_Œ∑‚ÇÇ, pf_Œ∑‚ÇÉ]

theorem evalWhiskerRightExpr_cons_of {f f' g h i : C} {Œ± : f' ‚ü∂ g} {Œ∑ : g ‚ü∂ h} {Œ∑s : h ‚ü∂ i}
    {Œ∑s‚ÇÅ : h ‚äó f ‚ü∂ i ‚äó f} {Œ∑‚ÇÅ : g ‚äó f ‚ü∂ h ‚äó f} {Œ∑‚ÇÇ : g ‚äó f ‚ü∂ i ‚äó f}
    {Œ∑‚ÇÉ : f' ‚äó f ‚ü∂ i ‚äó f}
    (pf_Œ∑s‚ÇÅ : Œ∑s ‚ñ∑ f = Œ∑s‚ÇÅ) (pf_Œ∑‚ÇÅ : Œ∑ ‚ñ∑ f = Œ∑‚ÇÅ)
    (pf_Œ∑‚ÇÇ : Œ∑‚ÇÅ ‚â´ Œ∑s‚ÇÅ = Œ∑‚ÇÇ) (pf_Œ∑‚ÇÉ : Œ± ‚ñ∑ f ‚â´ Œ∑‚ÇÇ = Œ∑‚ÇÉ) :
    (Œ± ‚â´ Œ∑ ‚â´ Œ∑s) ‚ñ∑ f = Œ∑‚ÇÉ := by
  simp [pf_Œ∑s‚ÇÅ, pf_Œ∑‚ÇÅ, pf_Œ∑‚ÇÇ, pf_Œ∑‚ÇÉ]

def mkEvalWhiskerRightExprConsOf (f Œ± Œ∑ Œ∑s Œ∑s‚ÇÅ Œ∑‚ÇÅ Œ∑‚ÇÇ Œ∑‚ÇÉ
    pf_Œ∑s‚ÇÅ pf_Œ∑‚ÇÅ pf_Œ∑‚ÇÇ pf_Œ∑‚ÇÉ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f' ‚Üê srcExpr Œ±
  let g ‚Üê srcExpr Œ∑
  let h ‚Üê tgtExpr Œ∑
  let i ‚Üê tgtExpr Œ∑s
  return mkAppN (.const ``evalWhiskerRightExpr_cons_of (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal,
      f, f', g, h, i, Œ±, Œ∑, Œ∑s, Œ∑s‚ÇÅ, Œ∑‚ÇÅ, Œ∑‚ÇÇ, Œ∑‚ÇÉ, pf_Œ∑s‚ÇÅ, pf_Œ∑‚ÇÅ, pf_Œ∑‚ÇÇ, pf_Œ∑‚ÇÉ]

theorem evalTensorHomAux_of {f g h i : C} (Œ∑ : f ‚ü∂ g) (Œ∏ : h ‚ü∂ i) :
    Œ∑ ‚äó Œ∏ = ùüô _ ‚â´ (Œ∑ ‚äó Œ∏) ‚â´ ùüô _ := by
  simp

def mkEvalTensorHomAuxOf (Œ∑ Œ∏ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExpr Œ∑
  let g ‚Üê tgtExpr Œ∑
  let h ‚Üê srcExpr Œ∏
  let i ‚Üê tgtExpr Œ∏
  return mkAppN (.const ``evalTensorHomAux_of (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, f, g, h, i, Œ∑, Œ∏]

theorem evalTensorHomAux_cons {f f' g g' h i : C} {Œ∑ : f ‚ü∂ g} {Œ∑s : f' ‚ü∂ g'} {Œ∏ : h ‚ü∂ i}
    {Œ∑Œ∏ : f' ‚äó h ‚ü∂ g' ‚äó i} {Œ∑‚ÇÅ : f ‚äó (f' ‚äó h) ‚ü∂ g ‚äó (g' ‚äó i)}
    {Œ∑Œ∏‚ÇÅ : f ‚äó (f' ‚äó h) ‚ü∂ (g ‚äó g') ‚äó i} {Œ∑Œ∏‚ÇÇ : (f ‚äó f') ‚äó h ‚ü∂ (g ‚äó g') ‚äó i}
    (pf_Œ∑Œ∏ : Œ∑s ‚äó Œ∏ = Œ∑Œ∏) (pf_Œ∑‚ÇÅ : (ùüô _ ‚â´ Œ∑ ‚â´ ùüô _) ‚äó Œ∑Œ∏ = Œ∑‚ÇÅ)
    (pf_Œ∑Œ∏‚ÇÅ : Œ∑‚ÇÅ ‚â´ (Œ±_ _ _ _).inv = Œ∑Œ∏‚ÇÅ) (pf_Œ∑Œ∏‚ÇÇ : (Œ±_ _ _ _).hom ‚â´ Œ∑Œ∏‚ÇÅ = Œ∑Œ∏‚ÇÇ) :
    (Œ∑ ‚äó Œ∑s) ‚äó Œ∏ = Œ∑Œ∏‚ÇÇ := by
  simp_all

def mkEvalTensorHomAuxCons (Œ∑ Œ∑s Œ∏ Œ∑Œ∏ Œ∑‚ÇÅ Œ∑Œ∏‚ÇÅ Œ∑Œ∏‚ÇÇ pf_Œ∑Œ∏ pf_Œ∑‚ÇÅ pf_Œ∑Œ∏‚ÇÅ pf_Œ∑Œ∏‚ÇÇ : Expr) :
    MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExpr Œ∑
  let g ‚Üê tgtExpr Œ∑
  let f' ‚Üê srcExpr Œ∑s
  let g' ‚Üê tgtExpr Œ∑s
  let h ‚Üê srcExpr Œ∏
  let i ‚Üê tgtExpr Œ∏
  return mkAppN (.const ``evalTensorHomAux_cons (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal,
      f, f', g, g', h, i, Œ∑, Œ∑s, Œ∏, Œ∑Œ∏, Œ∑‚ÇÅ, Œ∑Œ∏‚ÇÅ, Œ∑Œ∏‚ÇÇ, pf_Œ∑Œ∏, pf_Œ∑‚ÇÅ, pf_Œ∑Œ∏‚ÇÅ, pf_Œ∑Œ∏‚ÇÇ]

theorem evalTensorHomAux'_whisker {f f' g g' h : C} {Œ∑ : g ‚ü∂ h} {Œ∏ : f' ‚ü∂ g'}
    {Œ∑Œ∏ : g ‚äó f' ‚ü∂ h ‚äó g'} {Œ∑‚ÇÅ : f ‚äó (g ‚äó f') ‚ü∂ f ‚äó (h ‚äó g')}
    {Œ∑‚ÇÇ :  f ‚äó (g ‚äó f') ‚ü∂ (f ‚äó h) ‚äó g'} {Œ∑‚ÇÉ : (f ‚äó g) ‚äó f' ‚ü∂ (f ‚äó h) ‚äó g'}
    (pf_Œ∑Œ∏ : Œ∑ ‚äó Œ∏ = Œ∑Œ∏) (pf_Œ∑‚ÇÅ : f ‚óÅ Œ∑Œ∏ = Œ∑‚ÇÅ)
    (pf_Œ∑‚ÇÇ : Œ∑‚ÇÅ ‚â´ (Œ±_ _ _ _).inv = Œ∑‚ÇÇ) (pf_Œ∑‚ÇÉ : (Œ±_ _ _ _).hom ‚â´ Œ∑‚ÇÇ = Œ∑‚ÇÉ) :
    (f ‚óÅ Œ∑) ‚äó Œ∏ = Œ∑‚ÇÉ := by
  simp only [‚Üê pf_Œ∑Œ∏, ‚Üê pf_Œ∑‚ÇÅ, ‚Üê pf_Œ∑‚ÇÇ, ‚Üê pf_Œ∑‚ÇÉ]
  simp [MonoidalCategory.tensorHom_def]

def mkEvalTensorHomAux'_whisker (f Œ∑ Œ∏ Œ∑Œ∏ Œ∑‚ÇÅ Œ∑‚ÇÇ Œ∑‚ÇÉ pf_Œ∑Œ∏ pf_Œ∑‚ÇÅ pf_Œ∑‚ÇÇ pf_Œ∑‚ÇÉ : Expr) :
    MonoidalM Expr := do
  let ctx ‚Üê read
  let g ‚Üê srcExpr Œ∑
  let h ‚Üê tgtExpr Œ∑
  let f' ‚Üê srcExpr Œ∏
  let g' ‚Üê tgtExpr Œ∏
  return mkAppN (.const ``evalTensorHomAux'_whisker (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal,
      f, f', g, g', h, Œ∑, Œ∏, Œ∑Œ∏, Œ∑‚ÇÅ, Œ∑‚ÇÇ, Œ∑‚ÇÉ, pf_Œ∑Œ∏, pf_Œ∑‚ÇÅ, pf_Œ∑‚ÇÇ, pf_Œ∑‚ÇÉ]

theorem evalTensorHomAux'_of_whisker {f f' g g' h : C} {Œ∑ : g ‚ü∂ h} {Œ∏ : f' ‚ü∂ g'}
    {Œ∑‚ÇÅ : g ‚äó f ‚ü∂ h ‚äó f} {Œ∑Œ∏ : (g ‚äó f) ‚äó f' ‚ü∂ (h ‚äó f) ‚äó g'}
    {Œ∑Œ∏‚ÇÅ : (g ‚äó f) ‚äó f' ‚ü∂ h ‚äó (f ‚äó g')}
    {Œ∑Œ∏‚ÇÇ : g ‚äó (f ‚äó f') ‚ü∂ h ‚äó (f ‚äó g')}
    (pf_Œ∑‚ÇÅ : Œ∑ ‚ñ∑ f = Œ∑‚ÇÅ) (pf_Œ∑Œ∏ : Œ∑‚ÇÅ ‚äó (ùüô _ ‚â´ Œ∏ ‚â´ ùüô _) = Œ∑Œ∏)
    (pf_Œ∑Œ∏‚ÇÅ : Œ∑Œ∏ ‚â´ (Œ±_ _ _ _).hom = Œ∑Œ∏‚ÇÅ) (pf_Œ∑Œ∏‚ÇÇ : (Œ±_ _ _ _).inv ‚â´ Œ∑Œ∏‚ÇÅ = Œ∑Œ∏‚ÇÇ) :
    Œ∑ ‚äó (f ‚óÅ Œ∏) = Œ∑Œ∏‚ÇÇ := by
  simp only [‚Üê pf_Œ∑‚ÇÅ, ‚Üê pf_Œ∑Œ∏, ‚Üê pf_Œ∑Œ∏‚ÇÅ, ‚Üê pf_Œ∑Œ∏‚ÇÇ]
  simp [MonoidalCategory.tensorHom_def]

def mkEvalTensorHomAux'OfWhisker (f Œ∑ Œ∏ Œ∑‚ÇÅ Œ∑Œ∏ Œ∑Œ∏‚ÇÅ Œ∑Œ∏‚ÇÇ pf_Œ∑‚ÇÅ pf_Œ∑Œ∏ pf_Œ∑Œ∏‚ÇÅ pf_Œ∑Œ∏‚ÇÇ : Expr) :
    MonoidalM Expr := do
  let ctx ‚Üê read
  let g ‚Üê srcExpr Œ∑
  let h ‚Üê tgtExpr Œ∑
  let f' ‚Üê srcExpr Œ∏
  let g' ‚Üê tgtExpr Œ∏
  return mkAppN (.const ``evalTensorHomAux'_of_whisker (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal,
      f, f', g, g', h, Œ∑, Œ∏, Œ∑‚ÇÅ, Œ∑Œ∏, Œ∑Œ∏‚ÇÅ, Œ∑Œ∏‚ÇÇ, pf_Œ∑‚ÇÅ, pf_Œ∑Œ∏, pf_Œ∑Œ∏‚ÇÅ, pf_Œ∑Œ∏‚ÇÇ]

@[nolint synTaut]
theorem evalTensorHomExpr_nil_nil {f g h i : C} (Œ± : f ‚ü∂ g) (Œ≤ : h ‚ü∂ i) :
    Œ± ‚äó Œ≤ = Œ± ‚äó Œ≤ := by
  simp

def mkEvalTensorHomExprNilNil (Œ± Œ≤ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExpr Œ±
  let g ‚Üê tgtExpr Œ±
  let h ‚Üê srcExpr Œ≤
  let i ‚Üê tgtExpr Œ≤
  return mkAppN (.const ``evalTensorHomExpr_nil_nil (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, f, g, h, i, Œ±, Œ≤]

theorem evalTensorHomExpr_nil_cons {f f' g g' h i : C}
    {Œ± : f ‚ü∂ g} {Œ≤ : f' ‚ü∂ g'} {Œ∑ : g' ‚ü∂ h} {Œ∑s : h ‚ü∂ i}
    {Œ∑‚ÇÅ : g ‚äó g' ‚ü∂ g ‚äó h} {Œ∑s‚ÇÅ : g ‚äó h ‚ü∂ g ‚äó i}
    {Œ∑‚ÇÇ : g ‚äó g' ‚ü∂ g ‚äó i} {Œ∑‚ÇÉ : f ‚äó f' ‚ü∂ g ‚äó i}
    (pf_Œ∑‚ÇÅ : g ‚óÅ (ùüô _ ‚â´ Œ∑ ‚â´ ùüô _) = Œ∑‚ÇÅ)
    (pf_Œ∑s‚ÇÅ : g ‚óÅ Œ∑s = Œ∑s‚ÇÅ) (pf_Œ∑‚ÇÇ : Œ∑‚ÇÅ ‚â´ Œ∑s‚ÇÅ = Œ∑‚ÇÇ)
    (pf_Œ∑‚ÇÉ : (Œ± ‚äó Œ≤) ‚â´ Œ∑‚ÇÇ = Œ∑‚ÇÉ) :
    Œ± ‚äó (Œ≤ ‚â´ Œ∑ ‚â´ Œ∑s) = Œ∑‚ÇÉ := by
  simp_all [MonoidalCategory.tensorHom_def]

def mkEvalTensorHomExpr_nil_cons (Œ± Œ≤ Œ∑ Œ∑s Œ∑‚ÇÅ Œ∑s‚ÇÅ Œ∑‚ÇÇ Œ∑‚ÇÉ
    pf_Œ∑‚ÇÅ pf_Œ∑s‚ÇÅ pf_Œ∑‚ÇÇ pf_Œ∑‚ÇÉ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExpr Œ±
  let g ‚Üê tgtExpr Œ±
  let f' ‚Üê srcExpr Œ≤
  let g' ‚Üê tgtExpr Œ≤
  let h ‚Üê srcExpr Œ∑s
  let i ‚Üê tgtExpr Œ∑s
  return mkAppN (.const ``evalTensorHomExpr_nil_cons (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal,
      f, f', g, g', h, i, Œ±, Œ≤, Œ∑, Œ∑s, Œ∑‚ÇÅ, Œ∑s‚ÇÅ, Œ∑‚ÇÇ, Œ∑‚ÇÉ, pf_Œ∑‚ÇÅ, pf_Œ∑s‚ÇÅ, pf_Œ∑‚ÇÇ, pf_Œ∑‚ÇÉ]

theorem evalTensorHomExpr_cons_nil {f f' g g' h i : C}
    {Œ± : f ‚ü∂ g} {Œ∑ : g ‚ü∂ h} {Œ∑s : h ‚ü∂ i} {Œ≤ : f' ‚ü∂ g'}
    {Œ∑‚ÇÅ : g ‚äó g' ‚ü∂ h ‚äó g'} {Œ∑s‚ÇÅ : h ‚äó g' ‚ü∂ i ‚äó g'} {Œ∑‚ÇÇ : g ‚äó g' ‚ü∂ i ‚äó g'} {Œ∑‚ÇÉ : f ‚äó f' ‚ü∂ i ‚äó g'}
    (pf_Œ∑‚ÇÅ : (ùüô _ ‚â´ Œ∑ ‚â´ ùüô _) ‚ñ∑ g' = Œ∑‚ÇÅ) (pf_Œ∑s‚ÇÅ : Œ∑s ‚ñ∑ g' = Œ∑s‚ÇÅ)
    (pf_Œ∑‚ÇÇ : Œ∑‚ÇÅ ‚â´ Œ∑s‚ÇÅ = Œ∑‚ÇÇ) (pf_Œ∑‚ÇÉ : (Œ± ‚äó Œ≤) ‚â´ Œ∑‚ÇÇ = Œ∑‚ÇÉ) :
    (Œ± ‚â´ Œ∑ ‚â´ Œ∑s) ‚äó Œ≤ = Œ∑‚ÇÉ := by
  simp_all [MonoidalCategory.tensorHom_def']

def mkEvalTensorHomExprConsNil (Œ± Œ∑ Œ∑s Œ≤ Œ∑‚ÇÅ Œ∑s‚ÇÅ Œ∑‚ÇÇ Œ∑‚ÇÉ
    pf_Œ∑‚ÇÅ pf_Œ∑s‚ÇÅ pf_Œ∑‚ÇÇ pf_Œ∑‚ÇÉ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExpr Œ±
  let g ‚Üê tgtExpr Œ±
  let h ‚Üê tgtExpr Œ∑
  let i ‚Üê tgtExpr Œ∑s
  let f' ‚Üê srcExpr Œ≤
  let g' ‚Üê tgtExpr Œ≤
  return mkAppN (.const ``evalTensorHomExpr_cons_nil (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal,
      f, f', g, g', h, i, Œ±, Œ∑, Œ∑s, Œ≤, Œ∑‚ÇÅ, Œ∑s‚ÇÅ, Œ∑‚ÇÇ, Œ∑‚ÇÉ, pf_Œ∑‚ÇÅ, pf_Œ∑s‚ÇÅ, pf_Œ∑‚ÇÇ, pf_Œ∑‚ÇÉ]

theorem evalTensorHomExpr_cons_cons {f f' g g' h h' i i' : C}
    {Œ± : f ‚ü∂ g} {Œ∑ : g ‚ü∂ h} {Œ∑s : h ‚ü∂ i}
    {Œ≤ : f' ‚ü∂ g'} {Œ∏ : g' ‚ü∂ h'} {Œ∏s : h' ‚ü∂ i'}
    {Œ∑Œ∏ : g ‚äó g' ‚ü∂ h ‚äó h'} {Œ∑Œ∏s : h ‚äó h' ‚ü∂ i ‚äó i'}
    {Œ∑Œ∏‚ÇÅ : g ‚äó g' ‚ü∂ i ‚äó i'} {Œ∑Œ∏‚ÇÇ : f ‚äó f' ‚ü∂ i ‚äó i'}
    (pf_Œ∑Œ∏ : Œ∑ ‚äó Œ∏ = Œ∑Œ∏) (pf_Œ∑Œ∏s : Œ∑s ‚äó Œ∏s = Œ∑Œ∏s)
    (pf_Œ∑Œ∏‚ÇÅ : Œ∑Œ∏ ‚â´ Œ∑Œ∏s = Œ∑Œ∏‚ÇÅ) (pf_Œ∑Œ∏‚ÇÇ : (Œ± ‚äó Œ≤) ‚â´ Œ∑Œ∏‚ÇÅ = Œ∑Œ∏‚ÇÇ) :
    (Œ± ‚â´ Œ∑ ‚â´ Œ∑s) ‚äó (Œ≤ ‚â´ Œ∏ ‚â´ Œ∏s) = Œ∑Œ∏‚ÇÇ := by
  simp [‚Üê pf_Œ∑Œ∏ , ‚Üê pf_Œ∑Œ∏s , ‚Üê pf_Œ∑Œ∏‚ÇÅ, ‚Üê pf_Œ∑Œ∏‚ÇÇ]

def mkEvalTensorHomExprConsCons (Œ± Œ∑ Œ∑s Œ≤ Œ∏ Œ∏s Œ∑Œ∏ Œ∑Œ∏s Œ∑Œ∏‚ÇÅ Œ∑Œ∏‚ÇÇ
    pf_Œ∑Œ∏ pf_Œ∑Œ∏s pf_Œ∑Œ∏‚ÇÅ pf_Œ∑Œ∏‚ÇÇ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExpr Œ±
  let g ‚Üê tgtExpr Œ±
  let h ‚Üê tgtExpr Œ∑
  let i ‚Üê tgtExpr Œ∑s
  let f' ‚Üê srcExpr Œ≤
  let g' ‚Üê tgtExpr Œ≤
  let h' ‚Üê tgtExpr Œ∏
  let i' ‚Üê tgtExpr Œ∏s
  return mkAppN (.const ``evalTensorHomExpr_cons_cons (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal,
      f, f', g, g', h, h', i, i', Œ±, Œ∑, Œ∑s, Œ≤, Œ∏, Œ∏s, Œ∑Œ∏, Œ∑Œ∏s, Œ∑Œ∏‚ÇÅ, Œ∑Œ∏‚ÇÇ,
      pf_Œ∑Œ∏, pf_Œ∑Œ∏s, pf_Œ∑Œ∏‚ÇÅ, pf_Œ∑Œ∏‚ÇÇ]

end

/-- Extract a Lean expression from a `Mor‚ÇÅ` expression. -/
def Mor‚ÇÅ.e : Mor‚ÇÅ ‚Üí MonoidalM Expr
  | .id => do mkTensorUnit
  | .comp f g => do mkTensorObj (‚Üê Mor‚ÇÅ.e f) (‚Üê Mor‚ÇÅ.e g)
  | .of f => return f.e

/-- Extract a Lean expression from a `StructuralAtom` expression. -/
def StructuralAtom.e : StructuralAtom ‚Üí MonoidalM Expr
  | .associator f g h => do mkIsoHom (‚Üê mkAssociator (‚Üê f.e) (‚Üê g.e) (‚Üê h.e))
  | .associatorInv f g h => do mkIsoInv (‚Üê mkAssociator (‚Üê f.e) (‚Üê g.e) (‚Üê h.e))
  | .leftUnitor f => do mkIsoHom (‚Üê mkLeftUnitor (‚Üê f.e))
  | .leftUnitorInv f => do mkIsoInv (‚Üê mkLeftUnitor (‚Üê f.e))
  | .rightUnitor f => do mkIsoHom (‚Üê mkRightUnitor (‚Üê f.e))
  | .rightUnitorInv f => do mkIsoInv (‚Üê mkRightUnitor (‚Üê f.e))
  | .monoidalCoherence f g e => do mkMonoidalCoherenceHom (‚Üê f.e) (‚Üê g.e) e

/-- Extract a Lean expression from a `Structural` expression. -/
partial def Structural.e : Structural ‚Üí MonoidalM Expr
  | .atom Œ∑ => Œ∑.e
  | .id f => do mkId (‚Üê f.e)
  | .comp Œ± Œ≤ => do mkComp (‚Üê Œ±.e) (‚Üê Œ≤.e)
  | .whiskerLeft f Œ∑ => do mkWhiskerLeft (‚Üê f.e) (‚Üê Œ∑.e)
  | .whiskerRight Œ∑ f => do mkWhiskerRight (‚Üê Œ∑.e) (‚Üê f.e)
  | .tensorHom Œ± Œ≤ => do mkTensorHom (‚Üê Œ±.e) (‚Üê Œ≤.e)

/-- Extract a Lean expression from a `WhiskerRightExpr` expression. -/
def WhiskerRightExpr.e : WhiskerRightExpr ‚Üí MonoidalM Expr
  | WhiskerRightExpr.of Œ∑ => return Œ∑.e
  | WhiskerRightExpr.whisker Œ∑ f => do mkWhiskerRight (‚Üê Œ∑.e) f.e

/-- Extract a Lean expression from a `TensorHomExpr` expression. -/
def TensorHomExpr.e : TensorHomExpr ‚Üí MonoidalM Expr
  | TensorHomExpr.of Œ∑ => Œ∑.e
  | TensorHomExpr.cons Œ∑ Œ∑s => do mkTensorHom (‚Üê Œ∑.e) (‚Üê Œ∑s.e)

/-- Extract a Lean expression from a `WhiskerLeftExpr` expression. -/
def WhiskerLeftExpr.e : WhiskerLeftExpr ‚Üí MonoidalM Expr
  | WhiskerLeftExpr.of Œ∑ => Œ∑.e
  | WhiskerLeftExpr.whisker f Œ∑ => do mkWhiskerLeft f.e (‚Üê Œ∑.e)

/-- Extract a Lean expression from a `NormalExpr` expression. -/
def NormalExpr.e : NormalExpr ‚Üí MonoidalM Expr
  | NormalExpr.nil Œ± => Œ±.e
  | NormalExpr.cons Œ± Œ∑ Œ∏ => do mkComp (‚Üê Œ±.e) (‚Üê mkComp (‚Üê Œ∑.e) (‚Üê Œ∏.e))

/-- The result of evaluating an expression into normal form. -/
structure Result where
  /-- The normalized expression of the 2-morphism. -/
  expr : NormalExpr
  /-- The proof that the normalized expression is equal to the original expression. -/
  proof : Expr

/-- Construct a `NormalExpr` expression from another `NormalExpr` expression by adding a structural
2-morphism at the head. -/
def evalCompNil (Œ± : Structural) : NormalExpr ‚Üí MonoidalM Result
  | .nil Œ≤ => do
    let Œ±Œ≤ := .nil (Œ±.comp Œ≤)
    return ‚ü®Œ±Œ≤, ‚Üê mkEvalCompNilNil (‚Üê Œ±.e) (‚Üê Œ≤.e)‚ü©
  | .cons Œ≤ Œ∑ Œ∑s => do
    let Œ±Œ≤ := .cons (Œ±.comp Œ≤) Œ∑ Œ∑s
    return ‚ü®Œ±Œ≤, ‚Üê mkEvalCompNilCons (‚Üê Œ±.e) (‚Üê Œ≤.e) (‚Üê Œ∑.e) (‚Üê Œ∑s.e)‚ü©

mutual

/-- Evaluate the expression `Œ∑ ‚â´ Œ∏` into a normalized form. -/
partial def evalComp : NormalExpr ‚Üí NormalExpr ‚Üí MonoidalM Result
  | .nil Œ±, Œ∑ => do evalCompNil Œ± Œ∑
  | .cons Œ± Œ∑ Œ∑s, Œ∏ => do
    let ‚ü®Œπ, pf_Œπ‚ü© ‚Üê evalComp Œ∑s Œ∏
    let Œπ' := .cons Œ± Œ∑ Œπ
    return ‚ü®Œπ', ‚Üê mkEvalCompCons (‚Üê Œ±.e) (‚Üê Œ∑.e) (‚Üê Œ∑s.e) (‚Üê Œ∏.e) (‚Üê Œπ.e) pf_Œπ‚ü©

/-- Evaluate the expression `f ‚óÅ Œ∑` into a normalized form. -/
partial def evalWhiskerLeftExpr : Mor‚ÇÅ ‚Üí NormalExpr ‚Üí MonoidalM Result
  | f, .nil Œ± => do
    return ‚ü®.nil (.whiskerLeft f Œ±), ‚Üê mkEvalWhiskerLeftNil (‚Üê f.e) (‚Üê Œ±.e)‚ü©
  | .of f, .cons Œ± Œ∑ Œ∑s => do
    let Œ∑' := WhiskerLeftExpr.whisker f Œ∑
    let ‚ü®Œ∏, pf_Œ∏‚ü© ‚Üê evalWhiskerLeftExpr (.of f) Œ∑s
    let Œ∑'' := .cons (.whiskerLeft (.of f) Œ±) Œ∑' Œ∏
    return ‚ü®Œ∑'', ‚Üê mkEvalWhiskerLeft_of_cons f.e (‚Üê Œ±.e) (‚Üê Œ∑.e) (‚Üê Œ∑s.e) (‚Üê Œ∏.e) pf_Œ∏‚ü©
  | .comp f g, Œ∑ => do
    let ‚ü®Œ∏, pf_Œ∏‚ü© ‚Üê evalWhiskerLeftExpr g Œ∑
    let ‚ü®Œπ, pf_Œπ‚ü© ‚Üê evalWhiskerLeftExpr f Œ∏
    let h := Œ∑.src
    let h' := Œ∑.tgt
    let ‚ü®Œπ', pf_Œπ'‚ü© ‚Üê evalComp Œπ (NormalExpr.associatorInv f g h')
    let ‚ü®Œπ'', pf_Œπ''‚ü© ‚Üê evalComp (NormalExpr.associator f g h) Œπ'
    return ‚ü®Œπ'', ‚Üê mkEvalWhiskerLeft_comp (‚Üê f.e) (‚Üê g.e) (‚Üê Œ∑.e) (‚Üê Œ∏.e) (‚Üê Œπ.e)
      (‚Üê Œπ'.e) (‚Üê Œπ''.e) pf_Œ∏ pf_Œπ pf_Œπ' pf_Œπ''‚ü©
  | .id, Œ∑ => do
    let f := Œ∑.src
    let g := Œ∑.tgt
    let ‚ü®Œ∑', pf_Œ∑'‚ü© ‚Üê evalComp Œ∑ (NormalExpr.leftUnitorInv g)
    let ‚ü®Œ∑'', pf_Œ∑''‚ü© ‚Üê evalComp (NormalExpr.leftUnitor f) Œ∑'
    return ‚ü®Œ∑'', ‚Üê mkEvalWhiskerLeftId (‚Üê Œ∑.e) (‚Üê Œ∑'.e) (‚Üê Œ∑''.e) pf_Œ∑' pf_Œ∑''‚ü©

/-- Evaluate the expression `Œ∑ ‚ñ∑ f` into a normalized form. -/
partial def evalWhiskerRightExprAux : TensorHomExpr ‚Üí Atom‚ÇÅ ‚Üí MonoidalM Result
  | .of Œ∑, f => do
    let Œ∑' ‚Üê NormalExpr.of <| .of <| .of <| .whisker Œ∑ f
    return ‚ü®Œ∑', ‚Üê mkEvalWhiskerRightExprAuxOf (‚Üê Œ∑.e) f.e‚ü©
  | .cons Œ∑ Œ∑s, f => do
    let ‚ü®Œ∑s', pf_Œ∑s'‚ü© ‚Üê evalWhiskerRightExprAux Œ∑s f
    let ‚ü®Œ∑‚ÇÅ, pf_Œ∑‚ÇÅ‚ü© ‚Üê evalTensorHomExpr (‚Üê NormalExpr.of <| .of <| .of Œ∑) Œ∑s'
    let ‚ü®Œ∑‚ÇÇ, pf_Œ∑‚ÇÇ‚ü© ‚Üê evalComp Œ∑‚ÇÅ (.associatorInv (‚Üê Œ∑.tgt) (‚Üê Œ∑s.tgt) (.of f))
    let ‚ü®Œ∑‚ÇÉ, pf_Œ∑‚ÇÉ‚ü© ‚Üê evalComp (.associator (‚Üê Œ∑.src) (‚Üê Œ∑s.src) (.of f)) Œ∑‚ÇÇ
    return ‚ü®Œ∑‚ÇÉ, ‚Üê mkEvalWhiskerRightExprAuxCons f.e (‚Üê Œ∑.e) (‚Üê Œ∑s.e) (‚Üê Œ∑s'.e)
      (‚Üê Œ∑‚ÇÅ.e) (‚Üê Œ∑‚ÇÇ.e) (‚Üê Œ∑‚ÇÉ.e) pf_Œ∑s' pf_Œ∑‚ÇÅ pf_Œ∑‚ÇÇ pf_Œ∑‚ÇÉ‚ü©

/-- Evaluate the expression `Œ∑ ‚ñ∑ f` into a normalized form. -/
partial def evalWhiskerRightExpr : NormalExpr ‚Üí Mor‚ÇÅ ‚Üí MonoidalM Result
  | .nil Œ±, h => do
    return ‚ü®.nil (.whiskerRight Œ± h), ‚Üê mkEvalWhiskerRightNil (‚Üê Œ±.e) (‚Üê h.e)‚ü©
  | .cons Œ± (.of Œ∑) Œ∑s, .of f => do
    let ‚ü®Œ∑s‚ÇÅ, pf_Œ∑s‚ÇÅ‚ü© ‚Üê evalWhiskerRightExpr Œ∑s (.of f)
    let ‚ü®Œ∑‚ÇÅ, pf_Œ∑‚ÇÅ‚ü© ‚Üê evalWhiskerRightExprAux Œ∑ f
    let ‚ü®Œ∑‚ÇÇ, pf_Œ∑‚ÇÇ‚ü© ‚Üê evalComp Œ∑‚ÇÅ Œ∑s‚ÇÅ
    let ‚ü®Œ∑‚ÇÉ, pf_Œ∑‚ÇÉ‚ü© ‚Üê evalCompNil (.whiskerRight Œ± (.of f)) Œ∑‚ÇÇ
    return ‚ü®Œ∑‚ÇÉ, ‚Üê mkEvalWhiskerRightConsOfOf f.e (‚Üê Œ±.e) (‚Üê Œ∑.e) (‚Üê Œ∑s.e)
      (‚Üê Œ∑s‚ÇÅ.e) (‚Üê Œ∑‚ÇÅ.e) (‚Üê Œ∑‚ÇÇ.e) (‚Üê Œ∑‚ÇÉ.e) pf_Œ∑s‚ÇÅ pf_Œ∑‚ÇÅ pf_Œ∑‚ÇÇ pf_Œ∑‚ÇÉ‚ü©
  | .cons Œ± (.whisker f Œ∑) Œ∑s, h => do
    let g ‚Üê Œ∑.src
    let g' ‚Üê Œ∑.tgt
    let ‚ü®Œ∑‚ÇÅ, pf_Œ∑‚ÇÅ‚ü© ‚Üê evalWhiskerRightExpr (.cons (.id g) Œ∑ (.nil (.id g'))) h
    let ‚ü®Œ∑‚ÇÇ, pf_Œ∑‚ÇÇ‚ü© ‚Üê evalWhiskerLeftExpr (.of f) Œ∑‚ÇÅ
    let ‚ü®Œ∑s‚ÇÅ, pf_Œ∑s‚ÇÅ‚ü© ‚Üê evalWhiskerRightExpr Œ∑s h
    let Œ±' := .whiskerRight Œ± h
    let ‚ü®Œ∑s‚ÇÇ, pf_Œ∑s‚ÇÇ‚ü© ‚Üê evalComp (.associatorInv (.of f) g' h) Œ∑s‚ÇÅ
    let ‚ü®Œ∑‚ÇÉ, pf_Œ∑‚ÇÉ‚ü© ‚Üê evalComp Œ∑‚ÇÇ Œ∑s‚ÇÇ
    let ‚ü®Œ∑‚ÇÑ, pf_Œ∑‚ÇÑ‚ü© ‚Üê evalComp (.associator (.of f) g h) Œ∑‚ÇÉ
    let ‚ü®Œ∑‚ÇÖ, pf_Œ∑‚ÇÖ‚ü© ‚Üê evalComp (.nil Œ±') Œ∑‚ÇÑ
    return ‚ü®Œ∑‚ÇÖ, ‚Üê mkEvalWhiskerRightConsWhisker f.e (‚Üê h.e) (‚Üê Œ±.e) (‚Üê Œ∑.e) (‚Üê Œ∑s.e)
      (‚Üê Œ∑‚ÇÅ.e) (‚Üê Œ∑‚ÇÇ.e) (‚Üê Œ∑s‚ÇÅ.e) (‚Üê Œ∑s‚ÇÇ.e) (‚Üê Œ∑‚ÇÉ.e) (‚Üê Œ∑‚ÇÑ.e) (‚Üê Œ∑‚ÇÖ.e)
      pf_Œ∑‚ÇÅ pf_Œ∑‚ÇÇ pf_Œ∑s‚ÇÅ pf_Œ∑s‚ÇÇ pf_Œ∑‚ÇÉ pf_Œ∑‚ÇÑ pf_Œ∑‚ÇÖ‚ü©
  | Œ∑, .comp g h => do
    let ‚ü®Œ∑‚ÇÅ, pf_Œ∑‚ÇÅ‚ü© ‚Üê evalWhiskerRightExpr Œ∑ g
    let ‚ü®Œ∑‚ÇÇ, pf_Œ∑‚ÇÇ‚ü© ‚Üê evalWhiskerRightExpr Œ∑‚ÇÅ h
    let f := Œ∑.src
    let f' := Œ∑.tgt
    let ‚ü®Œ∑‚ÇÉ, pf_Œ∑‚ÇÉ‚ü© ‚Üê evalComp Œ∑‚ÇÇ (.associator f' g h)
    let ‚ü®Œ∑‚ÇÑ, pf_Œ∑‚ÇÑ‚ü© ‚Üê evalComp (.associatorInv f g h) Œ∑‚ÇÉ
    return ‚ü®Œ∑‚ÇÑ, ‚Üê mkEvalWhiskerRightComp (‚Üê g.e) (‚Üê h.e) (‚Üê Œ∑.e) (‚Üê Œ∑‚ÇÅ.e) (‚Üê Œ∑‚ÇÇ.e)
      (‚Üê Œ∑‚ÇÉ.e) (‚Üê Œ∑‚ÇÑ.e) pf_Œ∑‚ÇÅ pf_Œ∑‚ÇÇ pf_Œ∑‚ÇÉ pf_Œ∑‚ÇÑ‚ü©
  | Œ∑, .id => do
    let f := Œ∑.src
    let g := Œ∑.tgt
    let ‚ü®Œ∑‚ÇÅ, pf_Œ∑‚ÇÅ‚ü© ‚Üê evalComp Œ∑ (.rightUnitorInv g)
    let ‚ü®Œ∑‚ÇÇ, pf_Œ∑‚ÇÇ‚ü© ‚Üê evalComp (.rightUnitor f) Œ∑‚ÇÅ
    return ‚ü®Œ∑‚ÇÇ, ‚Üê mkEvalWhiskerRightId (‚Üê Œ∑.e) (‚Üê Œ∑‚ÇÅ.e) (‚Üê Œ∑‚ÇÇ.e) pf_Œ∑‚ÇÅ pf_Œ∑‚ÇÇ‚ü©

/-- Evaluate the expression `Œ∑ ‚äó Œ∏` into a normalized form. -/
partial def evalTensorHomAux : TensorHomExpr ‚Üí TensorHomExpr ‚Üí MonoidalM Result
  | .of Œ∑, Œ∏ => do
    return ‚ü®‚Üê NormalExpr.of <| .of <| .cons Œ∑ Œ∏, ‚Üê mkEvalTensorHomAuxOf (‚Üê Œ∑.e) (‚Üê Œ∏.e)‚ü©
  | .cons Œ∑ Œ∑s, Œ∏ => do
    let Œ± := NormalExpr.associator (‚Üê Œ∑.src) (‚Üê Œ∑s.src) (‚Üê Œ∏.src)
    let Œ±' := NormalExpr.associatorInv (‚Üê Œ∑.tgt) (‚Üê Œ∑s.tgt) (‚Üê Œ∏.tgt)
    let ‚ü®Œ∑Œ∏, pf_Œ∑Œ∏‚ü© ‚Üê evalTensorHomAux Œ∑s Œ∏
    let ‚ü®Œ∑‚ÇÅ, pf_Œ∑‚ÇÅ‚ü© ‚Üê evalTensorHomExpr (‚Üê NormalExpr.of <| .of <| .of Œ∑) Œ∑Œ∏
    let ‚ü®Œ∑Œ∏‚ÇÅ, pf_Œ∑Œ∏‚ÇÅ‚ü© ‚Üê evalComp Œ∑‚ÇÅ Œ±'
    let ‚ü®Œ∑Œ∏‚ÇÇ, pf_Œ∑Œ∏‚ÇÇ‚ü© ‚Üê evalComp Œ± Œ∑Œ∏‚ÇÅ
    return ‚ü®Œ∑Œ∏‚ÇÇ, ‚Üê mkEvalTensorHomAuxCons (‚Üê Œ∑.e) (‚Üê Œ∑s.e) (‚Üê Œ∏.e) (‚Üê Œ∑Œ∏.e)
      (‚Üê Œ∑‚ÇÅ.e) (‚Üê Œ∑Œ∏‚ÇÅ.e) (‚Üê Œ∑Œ∏‚ÇÇ.e) pf_Œ∑Œ∏ pf_Œ∑‚ÇÅ pf_Œ∑Œ∏‚ÇÅ pf_Œ∑Œ∏‚ÇÇ‚ü©

/-- Evaluate the expression `Œ∑ ‚äó Œ∏` into a normalized form. -/
partial def evalTensorHomAux' : WhiskerLeftExpr ‚Üí WhiskerLeftExpr ‚Üí MonoidalM Result
  | .of Œ∑, .of Œ∏ => evalTensorHomAux Œ∑ Œ∏
  | .whisker f Œ∑, Œ∏ => do
    let ‚ü®Œ∑Œ∏, pf_Œ∑Œ∏‚ü© ‚Üê evalTensorHomAux' Œ∑ Œ∏
    let ‚ü®Œ∑Œ∏‚ÇÅ, pf_Œ∑Œ∏‚ÇÅ‚ü© ‚Üê evalWhiskerLeftExpr (.of f) Œ∑Œ∏
    let ‚ü®Œ∑Œ∏‚ÇÇ, pf_Œ∑Œ∏‚ÇÇ‚ü© ‚Üê evalComp Œ∑Œ∏‚ÇÅ (.associatorInv (.of f) (‚Üê Œ∑.tgt) (‚Üê Œ∏.tgt))
    let ‚ü®Œ∑Œ∏‚ÇÉ, pf_Œ∑Œ∏‚ÇÉ‚ü© ‚Üê evalComp (.associator (.of f) (‚Üê Œ∑.src) (‚Üê Œ∏.src)) Œ∑Œ∏‚ÇÇ
    return ‚ü®Œ∑Œ∏‚ÇÉ, ‚Üê mkEvalTensorHomAux'_whisker f.e (‚Üê Œ∑.e) (‚Üê Œ∏.e) (‚Üê Œ∑Œ∏.e)
      (‚Üê Œ∑Œ∏‚ÇÅ.e) (‚Üê Œ∑Œ∏‚ÇÇ.e) (‚Üê Œ∑Œ∏‚ÇÉ.e) pf_Œ∑Œ∏ pf_Œ∑Œ∏‚ÇÅ pf_Œ∑Œ∏‚ÇÇ pf_Œ∑Œ∏‚ÇÉ‚ü©
  | .of Œ∑, .whisker f Œ∏ => do
    let ‚ü®Œ∑‚ÇÅ, pf_Œ∑‚ÇÅ‚ü© ‚Üê evalWhiskerRightExprAux Œ∑ f
    let ‚ü®Œ∑Œ∏, pf_Œ∑Œ∏‚ü© ‚Üê evalTensorHomExpr Œ∑‚ÇÅ (‚Üê NormalExpr.of Œ∏)
    let ‚ü®Œ∑Œ∏‚ÇÅ, pf_Œ∑Œ∏‚ÇÅ‚ü© ‚Üê evalComp Œ∑Œ∏ (.associator (‚Üê Œ∑.tgt) (.of f) (‚Üê Œ∏.tgt))
    let ‚ü®Œ∑Œ∏‚ÇÇ, pf_Œ∑Œ∏‚ÇÇ‚ü© ‚Üê evalComp (.associatorInv (‚Üê Œ∑.src) (.of f) (‚Üê Œ∏.src)) Œ∑Œ∏‚ÇÅ
    return ‚ü®Œ∑Œ∏‚ÇÇ, ‚Üê mkEvalTensorHomAux'OfWhisker f.e (‚Üê Œ∑.e) (‚Üê Œ∏.e) (‚Üê Œ∑Œ∏.e)
      (‚Üê Œ∑‚ÇÅ.e) (‚Üê Œ∑Œ∏‚ÇÅ.e) (‚Üê Œ∑Œ∏‚ÇÇ.e) pf_Œ∑‚ÇÅ pf_Œ∑Œ∏ pf_Œ∑Œ∏‚ÇÅ pf_Œ∑Œ∏‚ÇÇ‚ü©

/-- Evaluate the expression `Œ∑ ‚äó Œ∏` into a normalized form. -/
partial def evalTensorHomExpr : NormalExpr ‚Üí NormalExpr ‚Üí MonoidalM Result
  | .nil Œ±, .nil Œ≤ => do
    return ‚ü®.nil <| .tensorHom Œ± Œ≤, ‚Üê mkEvalTensorHomExprNilNil (‚Üê Œ±.e) (‚Üê Œ≤.e)‚ü©
  | .nil Œ±, .cons Œ≤ Œ∑ Œ∑s => do
    let ‚ü®Œ∑‚ÇÅ, pf_Œ∑‚ÇÅ‚ü© ‚Üê evalWhiskerLeftExpr Œ±.tgt (‚Üê NormalExpr.of Œ∑)
    let ‚ü®Œ∑s‚ÇÅ, pf_Œ∑s‚ÇÅ‚ü© ‚Üê evalWhiskerLeftExpr Œ±.tgt Œ∑s
    let ‚ü®Œ∑‚ÇÇ, pf_Œ∑‚ÇÇ‚ü© ‚Üê evalComp Œ∑‚ÇÅ Œ∑s‚ÇÅ
    let ‚ü®Œ∑‚ÇÉ, pf_Œ∑‚ÇÉ‚ü© ‚Üê evalCompNil (Œ±.tensorHom Œ≤) Œ∑‚ÇÇ
    return ‚ü®Œ∑‚ÇÉ, ‚Üê mkEvalTensorHomExpr_nil_cons (‚Üê Œ±.e) (‚Üê Œ≤.e) (‚Üê Œ∑.e) (‚Üê Œ∑s.e)
      (‚Üê Œ∑‚ÇÅ.e) (‚Üê Œ∑s‚ÇÅ.e) (‚Üê Œ∑‚ÇÇ.e) (‚Üê Œ∑‚ÇÉ.e) pf_Œ∑‚ÇÅ pf_Œ∑s‚ÇÅ pf_Œ∑‚ÇÇ pf_Œ∑‚ÇÉ‚ü©
  | .cons Œ± Œ∑ Œ∑s, .nil Œ≤ => do
    let ‚ü®Œ∑‚ÇÅ, pf_Œ∑‚ÇÅ‚ü© ‚Üê evalWhiskerRightExpr (‚Üê NormalExpr.of Œ∑) Œ≤.tgt
    let ‚ü®Œ∑s‚ÇÅ, pf_Œ∑s‚ÇÅ‚ü© ‚Üê evalWhiskerRightExpr Œ∑s Œ≤.tgt
    let ‚ü®Œ∑‚ÇÇ, pf_Œ∑‚ÇÇ‚ü© ‚Üê evalComp Œ∑‚ÇÅ Œ∑s‚ÇÅ
    let ‚ü®Œ∑‚ÇÉ, pf_Œ∑‚ÇÉ‚ü© ‚Üê evalCompNil (Œ±.tensorHom Œ≤) Œ∑‚ÇÇ
    return ‚ü®Œ∑‚ÇÉ, ‚Üê mkEvalTensorHomExprConsNil (‚Üê Œ±.e) (‚Üê Œ∑.e) (‚Üê Œ∑s.e) (‚Üê Œ≤.e)
      (‚Üê Œ∑‚ÇÅ.e) (‚Üê Œ∑s‚ÇÅ.e) (‚Üê Œ∑‚ÇÇ.e) (‚Üê Œ∑‚ÇÉ.e) pf_Œ∑‚ÇÅ pf_Œ∑s‚ÇÅ pf_Œ∑‚ÇÇ pf_Œ∑‚ÇÉ‚ü©
  | .cons Œ± Œ∑ Œ∑s, .cons Œ≤ Œ∏ Œ∏s => do
    let ‚ü®Œ∑Œ∏, pf_Œ∑Œ∏‚ü© ‚Üê evalTensorHomAux' Œ∑ Œ∏
    let ‚ü®Œ∑Œ∏s, pf_Œ∑Œ∏s‚ü© ‚Üê evalTensorHomExpr Œ∑s Œ∏s
    let ‚ü®Œ∑Œ∏‚ÇÅ, pf_Œ∑Œ∏‚ÇÅ‚ü© ‚Üê evalComp Œ∑Œ∏ Œ∑Œ∏s
    let ‚ü®Œ∑Œ∏‚ÇÇ, pf_Œ∑Œ∏‚ÇÇ‚ü© ‚Üê evalCompNil (Œ±.tensorHom Œ≤) Œ∑Œ∏‚ÇÅ
    return ‚ü®Œ∑Œ∏‚ÇÇ, ‚Üê mkEvalTensorHomExprConsCons (‚Üê Œ±.e) (‚Üê Œ∑.e) (‚Üê Œ∑s.e) (‚Üê Œ≤.e) (‚Üê Œ∏.e) (‚Üê Œ∏s.e)
      (‚Üê Œ∑Œ∏.e) (‚Üê Œ∑Œ∏s.e) (‚Üê Œ∑Œ∏‚ÇÅ.e) (‚Üê Œ∑Œ∏‚ÇÇ.e) pf_Œ∑Œ∏ pf_Œ∑Œ∏s pf_Œ∑Œ∏‚ÇÅ pf_Œ∑Œ∏‚ÇÇ‚ü©

end

/-- Evaluate the expression of a 2-morphism into a normalized form. -/
partial def eval (e : Expr) : MonoidalM Result := do
  let e ‚Üê instantiateMVars e
  withTraceNode `monoidal (fun _ => return m!"eval: {e}") do
    if let .some Œ± ‚Üê structuralAtom? e then
      return ‚ü®.nil <| .atom Œ±, ‚Üê mkEqRefl (‚Üê Œ±.e)‚ü©
    else
      match (‚Üê whnfR e).getAppFnArgs with
      | (``CategoryStruct.id, #[_, _, f]) =>
        return ‚ü®.nil (.id (‚Üê toMor‚ÇÅ f)), ‚Üê mkEqRefl (‚Üê mkId f)‚ü©
      | (``CategoryStruct.comp, #[_, _, _, _, _, Œ∑, Œ∏]) =>
        withTraceNode `monoidal (fun _ => return m!"comp") do
        let ‚ü®Œ∑', pf_Œ∑‚ü© ‚Üê eval Œ∑
        let ‚ü®Œ∏', pf_Œ∏‚ü© ‚Üê eval Œ∏
        let ‚ü®Œ∑Œ∏, pf‚ü© ‚Üê evalComp Œ∑' Œ∏'
        let result ‚Üê mkEvalComp Œ∑ (‚Üê Œ∑'.e) Œ∏ (‚Üê Œ∏'.e) (‚Üê Œ∑Œ∏.e) pf_Œ∑ pf_Œ∏ pf
        trace[monoidal] m!"{checkEmoji} {‚Üê inferType result}"
        return ‚ü®Œ∑Œ∏, result‚ü©
      | (``MonoidalCategoryStruct.whiskerLeft, #[_, _, _, f, _, _, Œ∑]) =>
        withTraceNode `monoidal (fun _ => return m!"whiskerLeft") do
          let ‚ü®Œ∑', pf_Œ∑‚ü© ‚Üê eval Œ∑
          let ‚ü®Œ∏, pf_Œ∏‚ü© ‚Üê evalWhiskerLeftExpr (‚Üê toMor‚ÇÅ f) Œ∑'
          let result ‚Üê mkEvalWhiskerLeft f Œ∑ (‚Üê Œ∑'.e) (‚Üê Œ∏.e) pf_Œ∑ pf_Œ∏
          trace[monoidal] m!"{checkEmoji} {‚Üê inferType result}"
          return ‚ü®Œ∏, result‚ü©
      | (``MonoidalCategoryStruct.whiskerRight, #[_, _, _, _, _, Œ∑, h]) =>
        withTraceNode `monoidal (fun _ => return m!"whiskerRight") do
          let ‚ü®Œ∑', pf_Œ∑‚ü© ‚Üê eval Œ∑
          let ‚ü®Œ∏, pf_Œ∏‚ü© ‚Üê evalWhiskerRightExpr Œ∑' (‚Üê toMor‚ÇÅ h)
          let result ‚Üê mkEvalWhiskerRight h Œ∑ (‚Üê Œ∑'.e) (‚Üê Œ∏.e) pf_Œ∑ pf_Œ∏
          trace[monoidal] m!"{checkEmoji} {‚Üê inferType result}"
          return ‚ü®Œ∏, result‚ü©
      | (``monoidalComp, #[_, _, _, _, _, _, _, Œ∑, Œ∏]) =>
        withTraceNode `monoidal (fun _ => return m!"monoidalComp") do
          let ‚ü®Œ∑', pf_Œ∑‚ü© ‚Üê eval Œ∑
          let Œ±‚ÇÄ ‚Üê structuralOfMonoidalComp e
          let Œ± := NormalExpr.nil Œ±‚ÇÄ
          let ‚ü®Œ∏', pf_Œ∏‚ü© ‚Üê eval Œ∏
          let ‚ü®Œ±Œ∏, pf_Œ∏Œ±‚ü© ‚Üê evalComp Œ± Œ∏'
          let ‚ü®Œ∑Œ±Œ∏, pf_Œ∑Œ±Œ∏‚ü© ‚Üê evalComp Œ∑' Œ±Œ∏
          let result ‚Üê mkEvalMonoidalComp Œ∑ (‚Üê Œ∑'.e) (‚Üê Œ±‚ÇÄ.e) Œ∏ (‚Üê Œ∏'.e) (‚Üê Œ±Œ∏.e) (‚Üê Œ∑Œ±Œ∏.e)
            pf_Œ∑ pf_Œ∏ pf_Œ∏Œ± pf_Œ∑Œ±Œ∏
          trace[monoidal] m!"{checkEmoji} {‚Üê inferType result}"
          return ‚ü®Œ∑Œ±Œ∏, result‚ü©
      | (``MonoidalCategoryStruct.tensorHom, #[_, _, _, _, _, _, _, Œ∑, Œ∏]) =>
        withTraceNode `monoidal (fun _ => return m!"tensorHom") do
          let ‚ü®Œ∑', pf_Œ∑‚ü© ‚Üê eval Œ∑
          let ‚ü®Œ∏', pf_Œ∏‚ü© ‚Üê eval Œ∏
          let ‚ü®Œ∑Œ∏, pf‚ü© ‚Üê evalTensorHomExpr Œ∑' Œ∏'
          let result ‚Üê mkEvalTensorHom Œ∑ (‚Üê Œ∑'.e) Œ∏ (‚Üê Œ∏'.e) (‚Üê Œ∑Œ∏.e) pf_Œ∑ pf_Œ∏ pf
          trace[monoidal] m!"{checkEmoji} {‚Üê inferType result}"
          return ‚ü®Œ∑Œ∏, result‚ü©
      | _ =>
        let result ‚Üê mkEvalOf e
        trace[monoidal] m!"{checkEmoji} {‚Üê inferType result}"
        return ‚ü®‚Üê NormalExpr.ofExpr e, result‚ü©

/-- Convert a `NormalExpr` expression into a list of `WhiskerLeftExpr` expressions. -/
def NormalExpr.toList : NormalExpr ‚Üí List WhiskerLeftExpr
  | NormalExpr.nil _ => []
  | NormalExpr.cons _ Œ∑ Œ∑s => Œ∑ :: NormalExpr.toList Œ∑s

/-- `normalize% Œ∑` is the normalization of the 2-morphism `Œ∑`.
1. The normalized 2-morphism is of the form `Œ±‚ÇÄ ‚â´ Œ∑‚ÇÄ ‚â´ Œ±‚ÇÅ ‚â´ Œ∑‚ÇÅ ‚â´ ... Œ±‚Çò ‚â´ Œ∑‚Çò ‚â´ Œ±‚Çò‚Çä‚ÇÅ` where
  each `Œ±·µ¢` is a structural 2-morphism (consisting of associators and unitors),
2. each `Œ∑·µ¢` is a non-structural 2-morphism of the form `f‚ÇÅ ‚óÅ ... ‚óÅ f‚Çò ‚óÅ Œ∏`, and
3. `Œ∏` is of the form `Œπ ‚ñ∑ g‚ÇÅ ‚ñ∑ ... ‚ñ∑ g‚Çó`
-/
elab "normalize% " t:term:51 : term => do
  let e ‚Üê Lean.Elab.Term.elabTerm t none
  let some ctx ‚Üê mkContext? e
    | throwError m!"{e} is not a morphism"
  MonoidalM.run ctx do (‚Üê eval e).expr.e

theorem mk_eq {Œ± : Type _} (a b a' b' : Œ±) (ha : a = a') (hb : b = b') (h : a' = b') : a = b := by
  simp [h, ha, hb]

open Lean Elab Meta Tactic in
/-- Transform an equality between 2-morphisms into the equality between their normalizations. -/
def mkEqOfNormalizedEq (e : Expr) : MetaM Expr := do
  withTraceNode `monoidal (fun _ => return m!"normalizing {e}") do
    let some (_, e‚ÇÅ, e‚ÇÇ) := (‚Üê whnfR <| ‚Üê instantiateMVars <| e).eq?
      | throwError "monoidal_nf requires an equality goal"
    let some ctx ‚Üê mkContext? e‚ÇÅ
      | throwError "the lhs and rhs must be morphisms"
    MonoidalM.run ctx do
      let ‚ü®e‚ÇÅ', p‚ÇÅ‚ü© ‚Üê eval e‚ÇÅ
      let ‚ü®e‚ÇÇ', p‚ÇÇ‚ü© ‚Üê eval e‚ÇÇ
      mkAppM ``mk_eq #[e‚ÇÅ, e‚ÇÇ, ‚Üê e‚ÇÅ'.e, ‚Üê e‚ÇÇ'.e, p‚ÇÅ, p‚ÇÇ]

open Lean Elab Tactic in
/-- Normalize the both sides of an equality. -/
elab "monoidal_nf" : tactic => withMainContext do
  let t ‚Üê getMainTarget
  let mvarIds ‚Üê (‚Üê getMainGoal).apply (‚Üê mkEqOfNormalizedEq t)
  replaceMainGoal mvarIds

end Mathlib.Tactic.Monoidal
