/-
Copyright (c) 2018 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Avigad, Simon Hudon
-/
import Mathlib.Control.Functor.Multivariate
import Mathlib.Data.PFunctor.Multivariate.Basic
import Mathlib.Data.PFunctor.Multivariate.M
import Mathlib.Data.QPF.Multivariate.Basic

#align_import data.qpf.multivariate.constructions.cofix from "leanprover-community/mathlib"@"f694c7dead66f5d4c80f446c796a5aad14707f0e"

/-!
# The final co-algebra of a multivariate qpf is again a qpf.

For a `(n+1)`-ary QPF `F (Œ±‚ÇÄ,..,Œ±‚Çô)`, we take the least fixed point of `F` with
regards to its last argument `Œ±‚Çô`. The result is an `n`-ary functor: `Fix F (Œ±‚ÇÄ,..,Œ±‚Çô‚Çã‚ÇÅ)`.
Making `Fix F` into a functor allows us to take the fixed point, compose with other functors
and take a fixed point again.

## Main definitions

 * `Cofix.mk`     - constructor
 * `Cofix.dest`   - destructor
 * `Cofix.corec`  - corecursor: useful for formulating infinite, productive computations
 * `Cofix.bisim`  - bisimulation: proof technique to show the equality of possibly infinite values
                    of `Cofix F Œ±`

## Implementation notes

For `F` a QPF, we define `Cofix F Œ±` in terms of the M-type of the polynomial functor `P` of `F`.
We define the relation `Mcongr` and take its quotient as the definition of `Cofix F Œ±`.

`Mcongr` is taken as the weakest bisimulation on M-type. See
[avigad-carneiro-hudon2019] for more details.

## Reference

 * Jeremy Avigad, Mario M. Carneiro and Simon Hudon.
   [*Data Types as Quotients of Polynomial Functors*][avigad-carneiro-hudon2019]
-/


universe u

open MvFunctor

namespace MvQPF

open TypeVec MvPFunctor

open MvFunctor (LiftP LiftR)

variable {n : ‚Ñï} {F : TypeVec.{u} (n + 1) ‚Üí Type u} [mvf : MvFunctor F] [q : MvQPF F]

/-- `corecF` is used as a basis for defining the corecursor of `Cofix F Œ±`. `corecF`
uses corecursion to construct the M-type generated by `q.P` and uses function on `F`
as a corecursive step -/
def corecF {Œ± : TypeVec n} {Œ≤ : Type _} (g : Œ≤ ‚Üí F (Œ±.append1 Œ≤)) : Œ≤ ‚Üí q.P.M Œ± :=
  M.corec _ fun x => repr (g x)
set_option linter.uppercaseLean3 false in
#align mvqpf.corecF MvQPF.corecF

theorem corecF_eq {Œ± : TypeVec n} {Œ≤ : Type _} (g : Œ≤ ‚Üí F (Œ±.append1 Œ≤)) (x : Œ≤) :
    M.dest q.P (corecF g x) = appendFun id (corecF g) <$$> repr (g x) := by
  rw [corecF, M.dest_corec]
  -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align mvqpf.corecF_eq MvQPF.corecF_eq

/-- Characterization of desirable equivalence relations on M-types -/
def IsPrecongr {Œ± : TypeVec n} (r : q.P.M Œ± ‚Üí q.P.M Œ± ‚Üí Prop) : Prop :=
  ‚àÄ ‚¶Éx y‚¶Ñ,
    r x y ‚Üí
      abs (appendFun id (Quot.mk r) <$$> M.dest q.P x) =
        abs (appendFun id (Quot.mk r) <$$> M.dest q.P y)
#align mvqpf.is_precongr MvQPF.IsPrecongr

/-- Equivalence relation on M-types representing a value of type `Cofix F` -/
def Mcongr {Œ± : TypeVec n} (x y : q.P.M Œ±) : Prop :=
  ‚àÉ r, IsPrecongr r ‚àß r x y
set_option linter.uppercaseLean3 false in
#align mvqpf.Mcongr MvQPF.Mcongr

/-- Greatest fixed point of functor F. The result is a functor with one fewer parameters
than the input. For `F a b c` a ternary functor, fix F is a binary functor such that

```lean
Cofix F a b = F a b (Cofix F a b)
```
-/
def Cofix (F : TypeVec (n + 1) ‚Üí Type u) [MvFunctor F] [q : MvQPF F] (Œ± : TypeVec n) :=
  Quot (@Mcongr _ F _ q Œ±)
#align mvqpf.cofix MvQPF.Cofix

instance {Œ± : TypeVec n} [Inhabited q.P.A] [‚àÄ i : Fin2 n, Inhabited (Œ± i)] :
    Inhabited (Cofix F Œ±) :=
  ‚ü®Quot.mk _ default‚ü©

/-- maps every element of the W type to a canonical representative -/
def mRepr {Œ± : TypeVec n} : q.P.M Œ± ‚Üí q.P.M Œ± :=
  corecF (abs ‚àò M.dest q.P)
set_option linter.uppercaseLean3 false in
#align mvqpf.Mrepr MvQPF.mRepr

/-- the map function for the functor `Cofix F` -/
def Cofix.map {Œ± Œ≤ : TypeVec n} (g : Œ± ‚üπ Œ≤) : Cofix F Œ± ‚Üí Cofix F Œ≤ :=
  Quot.lift (fun x : q.P.M Œ± => Quot.mk Mcongr (g <$$> x))
    (by
      rintro aa‚ÇÅ aa‚ÇÇ ‚ü®r, pr, ra‚ÇÅa‚ÇÇ‚ü©; apply Quot.sound
      -- ‚ä¢ (fun x => Quot.mk Mcongr (g <$$> x)) aa‚ÇÅ = (fun x => Quot.mk Mcongr (g <$$>  ‚Ä¶
                                     -- ‚ä¢ Mcongr (g <$$> aa‚ÇÅ) (g <$$> aa‚ÇÇ)
      let r' b‚ÇÅ b‚ÇÇ := ‚àÉ a‚ÇÅ a‚ÇÇ : q.P.M Œ±, r a‚ÇÅ a‚ÇÇ ‚àß b‚ÇÅ = g <$$> a‚ÇÅ ‚àß b‚ÇÇ = g <$$> a‚ÇÇ
      -- ‚ä¢ Mcongr (g <$$> aa‚ÇÅ) (g <$$> aa‚ÇÇ)
      use r'; constructor
      -- ‚ä¢ IsPrecongr r' ‚àß r' (g <$$> aa‚ÇÅ) (g <$$> aa‚ÇÇ)
              -- ‚ä¢ IsPrecongr r'
      ¬∑ show IsPrecongr r'
        -- ‚ä¢ IsPrecongr r'
        rintro b‚ÇÅ b‚ÇÇ ‚ü®a‚ÇÅ, a‚ÇÇ, ra‚ÇÅa‚ÇÇ, b‚ÇÅeq, b‚ÇÇeq‚ü©
        -- ‚ä¢ abs ((TypeVec.id ::: Quot.mk r') <$$> M.dest (P F) b‚ÇÅ) = abs ((TypeVec.id :: ‚Ä¶
        let u : Quot r ‚Üí Quot r' :=
          Quot.lift (fun x : q.P.M Œ± => Quot.mk r' (g <$$> x))
            (by
              intro a‚ÇÅ a‚ÇÇ ra‚ÇÅa‚ÇÇ
              apply Quot.sound
              exact ‚ü®a‚ÇÅ, a‚ÇÇ, ra‚ÇÅa‚ÇÇ, rfl, rfl‚ü©)
        have hu : (Quot.mk r' ‚àò fun x : q.P.M Œ± => g <$$> x) = u ‚àò Quot.mk r := by
          ext x
          rfl
        rw [b‚ÇÅeq, b‚ÇÇeq, M.dest_map, M.dest_map, ‚Üê q.P.comp_map, ‚Üê q.P.comp_map]
        -- ‚ä¢ abs (((TypeVec.id ::: Quot.mk r') ‚äö (g ::: fun x => g <$$> x)) <$$> M.dest ( ‚Ä¶
        rw [‚Üê appendFun_comp, id_comp, hu, ‚Üê comp_id g, appendFun_comp]
        -- ‚ä¢ abs (((g ::: u) ‚äö (TypeVec.id ::: Quot.mk r)) <$$> M.dest (P F) a‚ÇÅ) = abs (( ‚Ä¶
        rw [q.P.comp_map, q.P.comp_map, abs_map, pr ra‚ÇÅa‚ÇÇ, ‚Üê abs_map]
        -- üéâ no goals
      show r' (g <$$> aa‚ÇÅ) (g <$$> aa‚ÇÇ); exact ‚ü®aa‚ÇÅ, aa‚ÇÇ, ra‚ÇÅa‚ÇÇ, rfl, rfl‚ü©)
      -- ‚ä¢ r' (g <$$> aa‚ÇÅ) (g <$$> aa‚ÇÇ)
                                         -- üéâ no goals
#align mvqpf.cofix.map MvQPF.Cofix.map

instance Cofix.mvfunctor : MvFunctor (Cofix F) where map := @Cofix.map _ _ _ _
#align mvqpf.cofix.mvfunctor MvQPF.Cofix.mvfunctor

/-- Corecursor for `Cofix F` -/
def Cofix.corec {Œ± : TypeVec n} {Œ≤ : Type u} (g : Œ≤ ‚Üí F (Œ±.append1 Œ≤)) : Œ≤ ‚Üí Cofix F Œ± := fun x =>
  Quot.mk _ (corecF g x)
#align mvqpf.cofix.corec MvQPF.Cofix.corec

/-- Destructor for `Cofix F` -/
def Cofix.dest {Œ± : TypeVec n} : Cofix F Œ± ‚Üí F (Œ±.append1 (Cofix F Œ±)) :=
  Quot.lift (fun x => appendFun id (Quot.mk Mcongr) <$$> abs (M.dest q.P x))
    (by
      rintro x y ‚ü®r, pr, rxy‚ü©
      -- ‚ä¢ (fun x => (TypeVec.id ::: Quot.mk Mcongr) <$$> abs (M.dest (P F) x)) x = (fu ‚Ä¶
      dsimp
      -- ‚ä¢ (TypeVec.id ::: Quot.mk Mcongr) <$$> abs (M.dest (P F) x) = (TypeVec.id :::  ‚Ä¶
      have : ‚àÄ x y, r x y ‚Üí Mcongr x y := by
        intro x y h
        exact ‚ü®r, pr, h‚ü©
      rw [‚Üê Quot.factor_mk_eq _ _ this]
      -- ‚ä¢ (TypeVec.id ::: Quot.factor (fun x y => r x y) (fun x y => Mcongr x y) this  ‚Ä¶
      conv =>
        lhs
        rw [appendFun_comp_id, comp_map, ‚Üê abs_map, pr rxy, abs_map, ‚Üê comp_map,
          ‚Üê appendFun_comp_id])
#align mvqpf.cofix.dest MvQPF.Cofix.dest

/-- Abstraction function for `cofix F Œ±` -/
def Cofix.abs {Œ±} : q.P.M Œ± ‚Üí Cofix F Œ± :=
  Quot.mk _
#align mvqpf.cofix.abs MvQPF.Cofix.abs

/-- Representation function for `Cofix F Œ±` -/
def Cofix.repr {Œ±} : Cofix F Œ± ‚Üí q.P.M Œ± :=
  M.corec _ <| q.repr ‚àò Cofix.dest
#align mvqpf.cofix.repr MvQPF.Cofix.repr

/-- Corecursor for `Cofix F` -/
def Cofix.corec'‚ÇÅ {Œ± : TypeVec n} {Œ≤ : Type u} (g : ‚àÄ {X}, (Œ≤ ‚Üí X) ‚Üí F (Œ±.append1 X)) (x : Œ≤) :
    Cofix F Œ± :=
  Cofix.corec (fun _ => g id) x
#align mvqpf.cofix.corec'‚ÇÅ MvQPF.Cofix.corec'‚ÇÅ

/-- More flexible corecursor for `Cofix F`. Allows the return of a fully formed
value instead of making a recursive call -/
def Cofix.corec' {Œ± : TypeVec n} {Œ≤ : Type u} (g : Œ≤ ‚Üí F (Œ±.append1 (Sum (Cofix F Œ±) Œ≤))) (x : Œ≤) :
    Cofix F Œ± :=
  let f : (Œ± ::: Cofix F Œ±) ‚üπ (Œ± ::: Sum (Cofix F Œ±) Œ≤) := id ::: Sum.inl
  Cofix.corec (Sum.elim (MvFunctor.map f ‚àò Cofix.dest) g) (Sum.inr x : Sum (Cofix F Œ±) Œ≤)
#align mvqpf.cofix.corec' MvQPF.Cofix.corec'

/-- Corecursor for `Cofix F`. The shape allows recursive calls to
look like recursive calls. -/
def Cofix.corec‚ÇÅ {Œ± : TypeVec n} {Œ≤ : Type u}
    (g : ‚àÄ {X}, (Cofix F Œ± ‚Üí X) ‚Üí (Œ≤ ‚Üí X) ‚Üí Œ≤ ‚Üí F (Œ± ::: X)) (x : Œ≤) : Cofix F Œ± :=
  Cofix.corec' (fun x => g Sum.inl Sum.inr x) x
#align mvqpf.cofix.corec‚ÇÅ MvQPF.Cofix.corec‚ÇÅ

theorem Cofix.dest_corec {Œ± : TypeVec n} {Œ≤ : Type u} (g : Œ≤ ‚Üí F (Œ±.append1 Œ≤)) (x : Œ≤) :
    Cofix.dest (Cofix.corec g x) = appendFun id (Cofix.corec g) <$$> g x := by
  conv =>
    lhs
    rw [Cofix.dest, Cofix.corec];
  dsimp
  -- ‚ä¢ (TypeVec.id ::: Quot.mk Mcongr) <$$> MvQPF.abs (M.dest (P F) (corecF g x)) = ‚Ä¶
  rw [corecF_eq, abs_map, abs_repr, ‚Üê comp_map, ‚Üê appendFun_comp]; rfl
  -- ‚ä¢ (TypeVec.id ‚äö TypeVec.id ::: Quot.mk Mcongr ‚àò corecF g) <$$> g x = (TypeVec. ‚Ä¶
                                                                   -- üéâ no goals
#align mvqpf.cofix.dest_corec MvQPF.Cofix.dest_corec

/-- constructor for `Cofix F` -/
def Cofix.mk {Œ± : TypeVec n} : F (Œ±.append1 <| Cofix F Œ±) ‚Üí Cofix F Œ± :=
  Cofix.corec fun x => (appendFun id fun i : Cofix F Œ± => Cofix.dest.{u} i) <$$> x
#align mvqpf.cofix.mk MvQPF.Cofix.mk

/-!
## Bisimulation principles for `Cofix F`

The following theorems are bisimulation principles. The general idea
is to use a bisimulation relation to prove the equality between
specific values of type `Cofix F Œ±`.

A bisimulation relation `R` for values `x y : Cofix F Œ±`:

 * holds for `x y`: `R x y`
 * for any values `x y` that satisfy `R`, their root has the same shape
   and their children can be paired in such a way that they satisfy `R`.

-/


private theorem Cofix.bisim_aux {Œ± : TypeVec n} (r : Cofix F Œ± ‚Üí Cofix F Œ± ‚Üí Prop) (h' : ‚àÄ x, r x x)
    (h : ‚àÄ x y, r x y ‚Üí
      appendFun id (Quot.mk r) <$$> Cofix.dest x = appendFun id (Quot.mk r) <$$> Cofix.dest y) :
    ‚àÄ x y, r x y ‚Üí x = y := by
  intro x
  -- ‚ä¢ ‚àÄ (y : Cofix F Œ±), r x y ‚Üí x = y
  rcases x; clear x; rename M (P F) Œ± => x;
  -- ‚ä¢ ‚àÄ (y : Cofix F Œ±), r (Quot.mk Mcongr a‚úù) y ‚Üí Quot.mk Mcongr a‚úù = y
            -- ‚ä¢ ‚àÄ (y : Cofix F Œ±), r (Quot.mk Mcongr a‚úù) y ‚Üí Quot.mk Mcongr a‚úù = y
                     -- ‚ä¢ ‚àÄ (y : Cofix F Œ±), r (Quot.mk Mcongr x) y ‚Üí Quot.mk Mcongr x = y
  intro y
  -- ‚ä¢ r (Quot.mk Mcongr x) y ‚Üí Quot.mk Mcongr x = y
  rcases y; clear y; rename M (P F) Œ± => y;
  -- ‚ä¢ r (Quot.mk Mcongr x) (Quot.mk Mcongr a‚úù) ‚Üí Quot.mk Mcongr x = Quot.mk Mcongr ‚Ä¶
            -- ‚ä¢ r (Quot.mk Mcongr x) (Quot.mk Mcongr a‚úù) ‚Üí Quot.mk Mcongr x = Quot.mk Mcongr ‚Ä¶
                     -- ‚ä¢ r (Quot.mk Mcongr x) (Quot.mk Mcongr y) ‚Üí Quot.mk Mcongr x = Quot.mk Mcongr y
  intro rxy
  -- ‚ä¢ Quot.mk Mcongr x = Quot.mk Mcongr y
  apply Quot.sound
  -- ‚ä¢ Mcongr x y
  let r' := fun x y => r (Quot.mk _ x) (Quot.mk _ y)
  -- ‚ä¢ Mcongr x y
  have hr' : r' = fun x y => r (Quot.mk _ x) (Quot.mk _ y) := by rfl
  -- ‚ä¢ Mcongr x y
  have : IsPrecongr r' := by
    intro a b r'ab
    have h‚ÇÄ :
      appendFun id (Quot.mk r ‚àò Quot.mk Mcongr) <$$> MvQPF.abs (M.dest q.P a) =
        appendFun id (Quot.mk r ‚àò Quot.mk Mcongr) <$$> MvQPF.abs (M.dest q.P b) :=
      by rw [appendFun_comp_id, comp_map, comp_map]; exact h _ _ r'ab
    have h‚ÇÅ : ‚àÄ u v : q.P.M Œ±, Mcongr u v ‚Üí Quot.mk r' u = Quot.mk r' v := by
      intro u v cuv
      apply Quot.sound
      dsimp [hr']
      rw [Quot.sound cuv]
      apply h'
    let f : Quot r ‚Üí Quot r' :=
      Quot.lift (Quot.lift (Quot.mk r') h‚ÇÅ)
        (by
          intro c
          apply Quot.inductionOn
            (motive := fun c =>
              ‚àÄb, r c b ‚Üí Quot.lift (Quot.mk r') h‚ÇÅ c = Quot.lift (Quot.mk r') h‚ÇÅ b) c
          clear c
          intro c d
          apply Quot.inductionOn
            (motive := fun d => r (Quot.mk Mcongr c) d ‚Üí
              Quot.lift (Quot.mk r') h‚ÇÅ (Quot.mk Mcongr c) = Quot.lift (Quot.mk r') h‚ÇÅ d) d
          clear d
          intro d rcd; apply Quot.sound; apply rcd)
    have : f ‚àò Quot.mk r ‚àò Quot.mk Mcongr = Quot.mk r' := rfl
    rw [‚Üê this, appendFun_comp_id, q.P.comp_map, q.P.comp_map, abs_map, abs_map, abs_map, abs_map,
      h‚ÇÄ]
  refine' ‚ü®r', this, rxy‚ü©
  -- üéâ no goals

/-- Bisimulation principle using `map` and `Quot.mk` to match and relate children of two trees. -/
theorem Cofix.bisim_rel {Œ± : TypeVec n} (r : Cofix F Œ± ‚Üí Cofix F Œ± ‚Üí Prop)
    (h : ‚àÄ x y, r x y ‚Üí
      appendFun id (Quot.mk r) <$$> Cofix.dest x = appendFun id (Quot.mk r) <$$> Cofix.dest y) :
    ‚àÄ x y, r x y ‚Üí x = y := by
  let r' (x y) := x = y ‚à® r x y
  -- ‚ä¢ ‚àÄ (x y : Cofix F Œ±), r x y ‚Üí x = y
  intro x y rxy
  -- ‚ä¢ x = y
  apply Cofix.bisim_aux r'
  ¬∑ intro x
    -- ‚ä¢ r' x x
    left
    -- ‚ä¢ x = x
    rfl
    -- üéâ no goals
  ¬∑ intro x y r'xy
    -- ‚ä¢ (TypeVec.id ::: Quot.mk r') <$$> dest x = (TypeVec.id ::: Quot.mk r') <$$> d ‚Ä¶
    cases r'xy
    -- ‚ä¢ (TypeVec.id ::: Quot.mk r') <$$> dest x = (TypeVec.id ::: Quot.mk r') <$$> d ‚Ä¶
    case inl h =>
      rw [h]
    case inr r'xy =>
      have : ‚àÄ x y, r x y ‚Üí r' x y := fun x y h => Or.inr h
      rw [‚Üê Quot.factor_mk_eq _ _ this]
      dsimp
      rw [appendFun_comp_id]
      rw [@comp_map _ _ _ q _ _ _ (appendFun id (Quot.mk r)),
        @comp_map _ _ _ q _ _ _ (appendFun id (Quot.mk r))]
      rw [h _ _ r'xy]
  right; exact rxy
  -- ‚ä¢ r x y
         -- üéâ no goals
#align mvqpf.cofix.bisim_rel MvQPF.Cofix.bisim_rel

/-- Bisimulation principle using `LiftR` to match and relate children of two trees. -/
theorem Cofix.bisim {Œ± : TypeVec n} (r : Cofix F Œ± ‚Üí Cofix F Œ± ‚Üí Prop)
    (h : ‚àÄ x y, r x y ‚Üí LiftR (RelLast Œ± r (i:=_)) (Cofix.dest x) (Cofix.dest y)) :
    ‚àÄ x y, r x y ‚Üí x = y := by
  apply Cofix.bisim_rel
  -- ‚ä¢ ‚àÄ (x y : Cofix F Œ±), r x y ‚Üí (TypeVec.id ::: Quot.mk fun x y => r x y) <$$>  ‚Ä¶
  intro x y rxy
  -- ‚ä¢ (TypeVec.id ::: Quot.mk fun x y => r x y) <$$> dest x = (TypeVec.id ::: Quot ‚Ä¶
  rcases (liftR_iff (fun a b => RelLast Œ± r a b) (dest x) (dest y)).mp (h x y rxy)
    with ‚ü®a, f‚ÇÄ, f‚ÇÅ, dxeq, dyeq, h'‚ü©
  rw [dxeq, dyeq, ‚Üê abs_map, ‚Üê abs_map, MvPFunctor.map_eq, MvPFunctor.map_eq]
  -- ‚ä¢ MvQPF.abs { fst := a, snd := (TypeVec.id ::: Quot.mk fun x y => r x y) ‚äö f‚ÇÄ  ‚Ä¶
  rw [‚Üê split_dropFun_lastFun f‚ÇÄ, ‚Üê split_dropFun_lastFun f‚ÇÅ]
  -- ‚ä¢ MvQPF.abs { fst := a, snd := (TypeVec.id ::: Quot.mk fun x y => r x y) ‚äö spl ‚Ä¶
  rw [appendFun_comp_splitFun, appendFun_comp_splitFun]
  -- ‚ä¢ MvQPF.abs { fst := a, snd := splitFun (TypeVec.id ‚äö dropFun f‚ÇÄ) ((Quot.mk fu ‚Ä¶
  rw [id_comp, id_comp]
  -- ‚ä¢ MvQPF.abs { fst := a, snd := splitFun (dropFun f‚ÇÄ) ((Quot.mk fun x y => r x  ‚Ä¶
  congr 2 with (i j); cases' i with _ i <;> dsimp
  -- ‚ä¢ splitFun (dropFun f‚ÇÄ) ((Quot.mk fun x y => r x y) ‚àò lastFun f‚ÇÄ) i j = splitF ‚Ä¶
                      -- ‚ä¢ splitFun (dropFun f‚ÇÄ) ((Quot.mk fun x y => r x y) ‚àò lastFun f‚ÇÄ) Fin2.fz j =  ‚Ä¶
                                            -- ‚ä¢ splitFun (dropFun f‚ÇÄ) ((Quot.mk fun x y => r x y) ‚àò lastFun f‚ÇÄ) Fin2.fz j =  ‚Ä¶
                                            -- ‚ä¢ splitFun (dropFun f‚ÇÄ) ((Quot.mk fun x y => r x y) ‚àò lastFun f‚ÇÄ) (Fin2.fs a‚úù) ‚Ä¶
  ¬∑ apply Quot.sound
    -- ‚ä¢ r (lastFun f‚ÇÄ j) (lastFun f‚ÇÅ j)
    apply h' _ j
    -- üéâ no goals
  ¬∑ change f‚ÇÄ _ j = f‚ÇÅ _ j
    -- ‚ä¢ f‚ÇÄ (Fin2.fs a‚úù) j = f‚ÇÅ (Fin2.fs a‚úù) j
    apply h' _ j
    -- üéâ no goals
#align mvqpf.cofix.bisim MvQPF.Cofix.bisim

open MvFunctor

/-- Bisimulation principle using `LiftR'` to match and relate children of two trees. -/
theorem Cofix.bisim‚ÇÇ {Œ± : TypeVec n} (r : Cofix F Œ± ‚Üí Cofix F Œ± ‚Üí Prop)
    (h : ‚àÄ x y, r x y ‚Üí LiftR' (RelLast' Œ± r) (Cofix.dest x) (Cofix.dest y)) :
    ‚àÄ x y, r x y ‚Üí x = y :=
  Cofix.bisim r <| by intros; rw [‚Üê LiftR_RelLast_iff]; apply h; assumption
                      -- ‚ä¢ LiftR (fun {i} => RelLast Œ± r) (dest x‚úù) (dest y‚úù)
                              -- ‚ä¢ LiftR' (RelLast' Œ± r) (dest x‚úù) (dest y‚úù)
                                                        -- ‚ä¢ r x‚úù y‚úù
                                                                 -- üéâ no goals
#align mvqpf.cofix.bisim‚ÇÇ MvQPF.Cofix.bisim‚ÇÇ

/-- Bisimulation principle the values `‚ü®a,f‚ü©` of the polynomial functor representing
`Cofix F Œ±` as well as an invariant `Q : Œ≤ ‚Üí Prop` and a state `Œ≤` generating the
left-hand side and right-hand side of the equality through functions `u v : Œ≤ ‚Üí Cofix F Œ±` -/
theorem Cofix.bisim' {Œ± : TypeVec n} {Œ≤ : Type*} (Q : Œ≤ ‚Üí Prop) (u v : Œ≤ ‚Üí Cofix F Œ±)
    (h : ‚àÄ x, Q x ‚Üí ‚àÉ a f' f‚ÇÄ f‚ÇÅ,
      Cofix.dest (u x) = q.abs ‚ü®a, q.P.appendContents f' f‚ÇÄ‚ü© ‚àß
        Cofix.dest (v x) = q.abs ‚ü®a, q.P.appendContents f' f‚ÇÅ‚ü© ‚àß
          ‚àÄ i, ‚àÉ x', Q x' ‚àß f‚ÇÄ i = u x' ‚àß f‚ÇÅ i = v x') :
    ‚àÄ x, Q x ‚Üí u x = v x := fun x Qx =>
  let R := fun w z : Cofix F Œ± => ‚àÉ x', Q x' ‚àß w = u x' ‚àß z = v x'
  Cofix.bisim R
    (fun x y ‚ü®x', Qx', xeq, yeq‚ü© => by
      rcases h x' Qx' with ‚ü®a, f', f‚ÇÄ, f‚ÇÅ, ux'eq, vx'eq, h'‚ü©
      -- ‚ä¢ LiftR (fun {i} => RelLast Œ± R) (dest x) (dest y)
      rw [liftR_iff]
      -- ‚ä¢ ‚àÉ a f‚ÇÄ f‚ÇÅ, dest x = MvQPF.abs { fst := a, snd := f‚ÇÄ } ‚àß dest y = MvQPF.abs { ‚Ä¶
      refine'
        ‚ü®a, q.P.appendContents f' f‚ÇÄ, q.P.appendContents f' f‚ÇÅ, xeq.symm ‚ñ∏ ux'eq,
          yeq.symm ‚ñ∏ vx'eq, _‚ü©
      intro i; cases i
      -- ‚ä¢ ‚àÄ (j : B (P F) a i), RelLast Œ± R (appendContents (P F) f' f‚ÇÄ i j) (appendCon ‚Ä¶
               -- ‚ä¢ ‚àÄ (j : B (P F) a Fin2.fz), RelLast Œ± R (appendContents (P F) f' f‚ÇÄ Fin2.fz j ‚Ä¶
      ¬∑ apply h'
        -- üéâ no goals
      ¬∑ intro j
        -- ‚ä¢ RelLast Œ± R (appendContents (P F) f' f‚ÇÄ (Fin2.fs a‚úù) j) (appendContents (P F ‚Ä¶
        apply Eq.refl)
        -- üéâ no goals
    _ _ ‚ü®x, Qx, rfl, rfl‚ü©
#align mvqpf.cofix.bisim' MvQPF.Cofix.bisim'

theorem Cofix.mk_dest {Œ± : TypeVec n} (x : Cofix F Œ±) : Cofix.mk (Cofix.dest x) = x := by
  apply Cofix.bisim_rel (fun x y : Cofix F Œ± => x = Cofix.mk (Cofix.dest y)) _ _ _ rfl;
  -- ‚ä¢ ‚àÄ (x y : Cofix F Œ±), (fun x y => x = mk (dest y)) x y ‚Üí (TypeVec.id ::: Quot ‚Ä¶
  dsimp
  -- ‚ä¢ ‚àÄ (x y : Cofix F Œ±), x = mk (dest y) ‚Üí (TypeVec.id ::: Quot.mk fun x y => x  ‚Ä¶
  intro x y h
  -- ‚ä¢ (TypeVec.id ::: Quot.mk fun x y => x = mk (dest y)) <$$> dest x = (TypeVec.i ‚Ä¶
  rw [h]
  -- ‚ä¢ (TypeVec.id ::: Quot.mk fun x y => x = mk (dest y)) <$$> dest (mk (dest y))  ‚Ä¶
  conv =>
    lhs
    congr
    rfl
    rw [Cofix.mk]
    rw [Cofix.dest_corec]
  rw [‚Üê comp_map, ‚Üê appendFun_comp, id_comp]
  -- ‚ä¢ (TypeVec.id ::: (Quot.mk fun x y => x = mk (dest y)) ‚àò corec fun x => (TypeV ‚Ä¶
  rw [‚Üê comp_map, ‚Üê appendFun_comp, id_comp, ‚Üê Cofix.mk]
  -- ‚ä¢ (TypeVec.id ::: ((Quot.mk fun x y => x = mk (dest y)) ‚àò mk) ‚àò fun i => dest  ‚Ä¶
  congr
  -- ‚ä¢ (TypeVec.id ::: ((Quot.mk fun x y => x = mk (dest y)) ‚àò mk) ‚àò fun i => dest  ‚Ä¶
  apply congrArg
  -- ‚ä¢ (((Quot.mk fun x y => x = mk (dest y)) ‚àò mk) ‚àò fun i => dest i) = Quot.mk fu ‚Ä¶
  funext x
  -- ‚ä¢ (((Quot.mk fun x y => x = mk (dest y)) ‚àò mk) ‚àò fun i => dest i) x = Quot.mk  ‚Ä¶
  apply Quot.sound;
  -- ‚ä¢ mk ((fun i => dest i) x) = mk (dest x)
  rfl
  -- üéâ no goals
#align mvqpf.cofix.mk_dest MvQPF.Cofix.mk_dest

theorem Cofix.dest_mk {Œ± : TypeVec n} (x : F (Œ±.append1 <| Cofix F Œ±)) :
    Cofix.dest (Cofix.mk x) = x := by
  have : Cofix.mk ‚àò Cofix.dest = @_root_.id (Cofix F Œ±) := funext Cofix.mk_dest
  -- ‚ä¢ dest (mk x) = x
  rw [Cofix.mk, Cofix.dest_corec, ‚Üê comp_map, ‚Üê Cofix.mk, ‚Üê appendFun_comp, this, id_comp,
    appendFun_id_id, MvFunctor.id_map]
#align mvqpf.cofix.dest_mk MvQPF.Cofix.dest_mk

theorem Cofix.ext {Œ± : TypeVec n} (x y : Cofix F Œ±) (h : x.dest = y.dest) : x = y := by
  rw [‚Üê Cofix.mk_dest x, h, Cofix.mk_dest]
  -- üéâ no goals
#align mvqpf.cofix.ext MvQPF.Cofix.ext

theorem Cofix.ext_mk {Œ± : TypeVec n} (x y : F (Œ± ::: Cofix F Œ±)) (h : Cofix.mk x = Cofix.mk y) :
    x = y := by rw [‚Üê Cofix.dest_mk x, h, Cofix.dest_mk]
                -- üéâ no goals
#align mvqpf.cofix.ext_mk MvQPF.Cofix.ext_mk

/-!
`liftR_map`, `liftR_map_last` and `liftR_map_last'` are useful for reasoning about
the induction step in bisimulation proofs.
-/


section LiftRMap

theorem liftR_map {Œ± Œ≤ : TypeVec n} {F' : TypeVec n ‚Üí Type u} [MvFunctor F'] [LawfulMvFunctor F']
    (R : Œ≤ ‚äó Œ≤ ‚üπ ¬´repeat¬ª n Prop) (x : F' Œ±) (f g : Œ± ‚üπ Œ≤) (h : Œ± ‚üπ Subtype_ R)
    (hh : subtypeVal _ ‚äö h = (f ‚äó' g) ‚äö prod.diag) : LiftR' R (f <$$> x) (g <$$> x) := by
  rw [LiftR_def]
  -- ‚ä¢ ‚àÉ u, (prod.fst ‚äö subtypeVal R) <$$> u = f <$$> x ‚àß (prod.snd ‚äö subtypeVal R) ‚Ä¶
  exists h <$$> x
  -- ‚ä¢ (prod.fst ‚äö subtypeVal R) <$$> h <$$> x = f <$$> x ‚àß (prod.snd ‚äö subtypeVal  ‚Ä¶
  rw [MvFunctor.map_map, comp_assoc, hh, ‚Üê comp_assoc, fst_prod_mk, comp_assoc, fst_diag]
  -- ‚ä¢ (f ‚äö TypeVec.id) <$$> x = f <$$> x ‚àß (prod.snd ‚äö subtypeVal R) <$$> h <$$> x ‚Ä¶
  rw [MvFunctor.map_map, comp_assoc, hh, ‚Üê comp_assoc, snd_prod_mk, comp_assoc, snd_diag]
  -- ‚ä¢ (f ‚äö TypeVec.id) <$$> x = f <$$> x ‚àß (g ‚äö TypeVec.id) <$$> x = g <$$> x
  dsimp [LiftR']; constructor <;> rfl
  -- ‚ä¢ f <$$> x = f <$$> x ‚àß g <$$> x = g <$$> x
                  -- ‚ä¢ f <$$> x = f <$$> x
                                  -- üéâ no goals
                                  -- üéâ no goals
#align mvqpf.liftr_map MvQPF.liftR_map

open Function

theorem liftR_map_last [lawful: LawfulMvFunctor F]
    {Œ± : TypeVec n} {Œπ Œπ'} (R : Œπ' ‚Üí Œπ' ‚Üí Prop)
    (x : F (Œ± ::: Œπ)) (f g : Œπ ‚Üí Œπ') (hh : ‚àÄ x : Œπ, R (f x) (g x)) :
    LiftR' (RelLast' _ R) ((id ::: f) <$$> x) ((id ::: g) <$$> x) :=
  let h : Œπ ‚Üí { x : Œπ' √ó Œπ' // uncurry R x } := fun x => ‚ü®(f x, g x), hh x‚ü©
  let b : (Œ± ::: Œπ) ‚üπ _ := @diagSub n Œ± ::: h
  let c :
    (Subtype_ Œ±.repeatEq ::: { x // uncurry R x }) ‚üπ
      ((fun i : Fin2 n => { x // ofRepeat (Œ±.RelLast' R i.fs x) }) ::: Subtype (uncurry R)) :=
    ofSubtype _ ::: id
  have hh :
    subtypeVal _ ‚äö toSubtype _ ‚äö fromAppend1DropLast ‚äö c ‚äö b =
      ((id ::: f) ‚äó' (id ::: g)) ‚äö prod.diag := by
    dsimp
    -- ‚ä¢ subtypeVal (RelLast' Œ± R) ‚äö toSubtype (RelLast' Œ± R) ‚äö fromAppend1DropLast ‚äö ‚Ä¶
    apply eq_of_drop_last_eq
    -- ‚ä¢ dropFun (subtypeVal (RelLast' Œ± R) ‚äö toSubtype (RelLast' Œ± R) ‚äö fromAppend1D ‚Ä¶
    ¬∑ dsimp
      -- ‚ä¢ subtypeVal (repeatEq Œ±) ‚äö dropFun (toSubtype (RelLast' Œ± R)) ‚äö ofSubtype (re ‚Ä¶
      simp only [prod_map_id, dropFun_prod, dropFun_appendFun, dropFun_diag, id_comp,
        dropFun_toSubtype]
      erw [toSubtype_of_subtype_assoc, id_comp]
      -- ‚ä¢ (fun i x => subtypeVal (repeatEq Œ±) i (diagSub i x)) = prod.diag
      clear liftR_map_last q mvf lawful F x R f g hh h b c
      -- ‚ä¢ (fun i x => subtypeVal (repeatEq Œ±) i (diagSub i x)) = prod.diag
      ext (i x) : 2
      -- ‚ä¢ subtypeVal (repeatEq Œ±) i (diagSub i x) = prod.diag i x
      induction i with
      | fz => rfl
      | fs _ ih =>
        apply ih
    simp only [lastFun_from_append1_drop_last, lastFun_toSubtype, lastFun_appendFun,
      lastFun_subtypeVal, comp.left_id, lastFun_comp, lastFun_prod]
    ext1
    -- ‚ä¢ (Subtype.val ‚àò fun x => { val := (f x, g x), property := (_ : R (f x) (g x)) ‚Ä¶
    rfl
    -- üéâ no goals
  liftR_map _ _ _ _ (toSubtype _ ‚äö fromAppend1DropLast ‚äö c ‚äö b) hh
#align mvqpf.liftr_map_last MvQPF.liftR_map_last

theorem liftR_map_last' [LawfulMvFunctor F] {Œ± : TypeVec n} {Œπ} (R : Œπ ‚Üí Œπ ‚Üí Prop) (x : F (Œ± ::: Œπ))
    (f : Œπ ‚Üí Œπ) (hh : ‚àÄ x : Œπ, R (f x) x) : LiftR' (RelLast' _ R) ((id ::: f) <$$> x) x := by
  have := liftR_map_last R x f id hh
  -- ‚ä¢ LiftR' (RelLast' Œ± R) ((TypeVec.id ::: f) <$$> x) x
  rwa [appendFun_id_id, MvFunctor.id_map] at this
  -- üéâ no goals
#align mvqpf.liftr_map_last' MvQPF.liftR_map_last'

end LiftRMap

variable {F: TypeVec (n + 1) ‚Üí Type u} [MvFunctor F] [q : MvQPF F]

theorem Cofix.abs_repr {Œ±} (x : Cofix F Œ±) : Quot.mk _ (Cofix.repr x) = x := by
  let R := fun x y : Cofix F Œ± => abs (repr y) = x
  -- ‚ä¢ Quot.mk Mcongr (repr x) = x
  refine' Cofix.bisim‚ÇÇ R _ _ _ rfl
  -- ‚ä¢ ‚àÄ (x y : Cofix F Œ±), R x y ‚Üí LiftR' (RelLast' Œ± R) (dest x) (dest y)
  clear x;
  -- ‚ä¢ ‚àÄ (x y : Cofix F Œ±), R x y ‚Üí LiftR' (RelLast' Œ± R) (dest x) (dest y)
  rintro x y h;
  -- ‚ä¢ LiftR' (RelLast' Œ± R) (dest x) (dest y)
  subst h
  -- ‚ä¢ LiftR' (RelLast' Œ± R) (dest (abs (repr y))) (dest y)
  dsimp [Cofix.dest, Cofix.abs]
  -- ‚ä¢ LiftR' (RelLast' Œ± fun x y => Quot.mk Mcongr (repr y) = x) ((TypeVec.id :::  ‚Ä¶
  induction y using Quot.ind
  -- ‚ä¢ LiftR' (RelLast' Œ± fun x y => Quot.mk Mcongr (repr y) = x) ((TypeVec.id :::  ‚Ä¶
  simp only [Cofix.repr, M.dest_corec, abs_map, MvQPF.abs_repr, Function.comp]
  -- ‚ä¢ LiftR' (RelLast' Œ± fun x y => Quot.mk Mcongr (M.corec (P F) (fun x => MvQPF. ‚Ä¶
  conv =>
    congr
    rfl
    rw [Cofix.dest]
  rw [MvFunctor.map_map, MvFunctor.map_map, ‚ÜêappendFun_comp_id, ‚ÜêappendFun_comp_id]
  -- ‚ä¢ LiftR' (RelLast' Œ± fun x y => Quot.mk Mcongr (M.corec (P F) (fun x => MvQPF. ‚Ä¶
  apply liftR_map_last
  -- ‚ä¢ ‚àÄ (x : M (P F) Œ±), Quot.mk Mcongr (M.corec (P F) (fun x => MvQPF.repr (dest  ‚Ä¶
  intros
  -- ‚ä¢ Quot.mk Mcongr (M.corec (P F) (fun x => MvQPF.repr (dest x)) (Quot.mk Mcongr ‚Ä¶
  rfl
  -- üéâ no goals
#align mvqpf.cofix.abs_repr MvQPF.Cofix.abs_repr

end MvQPF

namespace Mathlib.Tactic.MvBisim

open Lean Expr Elab Term Tactic Meta Qq

/-- tactic for proof by bisimulation -/
syntax "mv_bisim" (ppSpace colGt term) (" with" (ppSpace colGt binderIdent)+)? : tactic

elab_rules : tactic
  | `(tactic| mv_bisim $e $[ with $ids:binderIdent*]?) => do
    let ids : TSyntaxArray `Lean.binderIdent := ids.getD #[]
    let idsn (n : ‚Ñï) : Name :=
      match ids[n]? with
      | some s =>
        match s with
        | `(binderIdent| $n:ident) => n.getId
        | `(binderIdent| _) => `_
        | _ => unreachable!
      | none => `_
    let idss (n : ‚Ñï) : TacticM (TSyntax `rcasesPat) := do
      match ids[n]? with
      | some s =>
        match s with
        | `(binderIdent| $n:ident) => `(rcasesPat| $n)
        | `(binderIdent| _%$b) => `(rcasesPat| _%$b)
        | _ => unreachable!
      | none => `(rcasesPat| _)
    withMainContext do
      let e ‚Üê Tactic.elabTerm e none
      let f ‚Üê liftMetaTacticAux fun g => do
        let (#[fv], g) ‚Üê g.generalize #[{ expr := e }] | unreachable!
        return (mkFVar fv, [g])
      withMainContext do
        let some (t, l, r) ‚Üê matchEq? (‚Üê getMainTarget) | throwError "goal is not an equality"
        let ex ‚Üê
          withLocalDecl (idsn 1) .default t fun v‚ÇÄ =>
            withLocalDecl (idsn 2) .default t fun v‚ÇÅ => do
              let x‚ÇÄ ‚Üê mkEq v‚ÇÄ l
              let x‚ÇÅ ‚Üê mkEq v‚ÇÅ r
              let xx ‚Üê mkAppM ``And #[x‚ÇÄ, x‚ÇÅ]
              let ex‚ÇÅ ‚Üê mkLambdaFVars #[f] xx
              let ex‚ÇÇ ‚Üê mkAppM ``Exists #[ex‚ÇÅ]
              mkLambdaFVars #[v‚ÇÄ, v‚ÇÅ] ex‚ÇÇ
        let R ‚Üê liftMetaTacticAux fun g => do
          let g‚ÇÅ ‚Üê g.define (idsn 0) (‚Üê mkArrow t (‚Üê mkArrow t (mkSort .zero))) ex
          let (Rv, g‚ÇÇ) ‚Üê g‚ÇÅ.intro1P
          return (mkFVar Rv, [g‚ÇÇ])
        withMainContext do
          ids[0]?.forM fun s => addLocalVarInfoForBinderIdent R s
          let sR ‚Üê exprToSyntax R
          evalTactic <| ‚Üê `(tactic|
            refine MvQPF.Cofix.bisim‚ÇÇ $sR ?_ _ _ ‚ü®_, rfl, rfl‚ü©;
            rintro $(‚Üê idss 1) $(‚Üê idss 2) ‚ü®$(‚Üê idss 3), $(‚Üê idss 4), $(‚Üê idss 5)‚ü©)
          liftMetaTactic fun g => return [‚Üê g.clear f.fvarId!]
    for n in [6 : ids.size] do
      let name := ids[n]!
      logWarningAt name m!"unused name: {name}"

end Mathlib.Tactic.MvBisim

namespace MvQPF

open TypeVec MvPFunctor

open MvFunctor (LiftP LiftR)

variable {n : ‚Ñï} {F : TypeVec.{u} (n + 1) ‚Üí Type u} [mvf : MvFunctor F] [q : MvQPF F]

theorem corec_roll {Œ± : TypeVec n} {X Y} {x‚ÇÄ : X} (f : X ‚Üí Y) (g : Y ‚Üí F (Œ± ::: X)) :
    Cofix.corec (g ‚àò f) x‚ÇÄ = Cofix.corec (MvFunctor.map (id ::: f) ‚àò g) (f x‚ÇÄ) := by
  mv_bisim x‚ÇÄ with R a b x Ha Hb
  -- ‚ä¢ LiftR' (RelLast' Œ± R) (Cofix.dest a) (Cofix.dest b)
  rw [Ha, Hb, Cofix.dest_corec, Cofix.dest_corec, Function.comp_apply, Function.comp_apply]
  -- ‚ä¢ LiftR' (RelLast' Œ± R) ((TypeVec.id ::: Cofix.corec (g ‚àò f)) <$$> g (f x)) (( ‚Ä¶
  rw [MvFunctor.map_map, ‚Üê appendFun_comp_id]
  -- ‚ä¢ LiftR' (RelLast' Œ± R) ((TypeVec.id ::: Cofix.corec (g ‚àò f)) <$$> g (f x)) (( ‚Ä¶
  refine' liftR_map_last _ _ _ _ _
  -- ‚ä¢ ‚àÄ (x : X), R (Cofix.corec (g ‚àò f) x) ((Cofix.corec (MvFunctor.map (TypeVec.i ‚Ä¶
  intro a; refine' ‚ü®a, rfl, rfl‚ü©
  -- ‚ä¢ R (Cofix.corec (g ‚àò f) a) ((Cofix.corec (MvFunctor.map (TypeVec.id ::: f) ‚àò  ‚Ä¶
           -- üéâ no goals
#align mvqpf.corec_roll MvQPF.corec_roll

theorem Cofix.dest_corec' {Œ± : TypeVec.{u} n} {Œ≤ : Type u}
    (g : Œ≤ ‚Üí F (Œ±.append1 (Sum (Cofix F Œ±) Œ≤))) (x : Œ≤) :
    Cofix.dest (Cofix.corec' g x) =
      appendFun id (Sum.elim _root_.id (Cofix.corec' g)) <$$> g x := by
  rw [Cofix.corec', Cofix.dest_corec]; dsimp
  -- ‚ä¢ (TypeVec.id ::: corec (Sum.elim (MvFunctor.map (TypeVec.id ::: Sum.inl) ‚àò de ‚Ä¶
                                       -- ‚ä¢ (TypeVec.id ::: corec (Sum.elim (MvFunctor.map (TypeVec.id ::: Sum.inl) ‚àò de ‚Ä¶
  congr!; ext (i | i) <;> erw [corec_roll] <;> dsimp [Cofix.corec']
  -- ‚ä¢ corec (Sum.elim (MvFunctor.map (TypeVec.id ::: Sum.inl) ‚àò dest) g) = Sum.eli ‚Ä¶
          -- ‚ä¢ corec (Sum.elim (MvFunctor.map (TypeVec.id ::: Sum.inl) ‚àò dest) g) (Sum.inl  ‚Ä¶
                          -- ‚ä¢ corec (MvFunctor.map (TypeVec.id ::: fun x => x) ‚àò Sum.rec (fun val => (MvFu ‚Ä¶
                          -- ‚ä¢ corec (MvFunctor.map (TypeVec.id ::: fun x => x) ‚àò Sum.rec (fun val => (MvFu ‚Ä¶
                                               -- ‚ä¢ corec (MvFunctor.map (TypeVec.id ::: fun x => x) ‚àò Sum.rec (fun val => (Type ‚Ä¶
                                               -- ‚ä¢ corec (MvFunctor.map (TypeVec.id ::: fun x => x) ‚àò Sum.rec (fun val => (Type ‚Ä¶
  ¬∑ mv_bisim i with R a b x Ha Hb
    -- ‚ä¢ LiftR' (RelLast' Œ± R) (dest a) (dest b)
    rw [Ha, Hb, Cofix.dest_corec]
    -- ‚ä¢ LiftR' (RelLast' Œ± R) ((TypeVec.id ::: corec (MvFunctor.map (TypeVec.id :::  ‚Ä¶
    dsimp [Function.comp]
    -- ‚ä¢ LiftR' (RelLast' Œ± fun a b => ‚àÉ x, a = corec (fun x => (TypeVec.id ::: fun x ‚Ä¶
    repeat rw [MvFunctor.map_map, ‚Üê appendFun_comp_id]
    -- ‚ä¢ LiftR' (RelLast' Œ± fun a b => ‚àÉ x, a = corec (fun x => (TypeVec.id ::: fun x ‚Ä¶
    apply liftR_map_last'
    -- ‚ä¢ ‚àÄ (x : Cofix F Œ±), ‚àÉ x_1, (((corec fun x => (TypeVec.id ::: fun x => x) <$$> ‚Ä¶
    dsimp [Function.comp]
    -- ‚ä¢ ‚àÄ (x : Cofix F Œ±), ‚àÉ x_1, corec (fun x => (TypeVec.id ::: fun x => x) <$$> S ‚Ä¶
    intros
    -- ‚ä¢ ‚àÉ x, corec (fun x => (TypeVec.id ::: fun x => x) <$$> Sum.rec (fun val => (T ‚Ä¶
    exact ‚ü®_, rfl, rfl‚ü©
    -- üéâ no goals
  ¬∑ congr with y
    -- ‚ä¢ (MvFunctor.map (TypeVec.id ::: fun x => x) ‚àò Sum.rec (fun val => (TypeVec.id ‚Ä¶
    erw [appendFun_id_id]
    -- ‚ä¢ (MvFunctor.map TypeVec.id ‚àò Sum.rec (fun val => (TypeVec.id ::: Sum.inl) <$$ ‚Ä¶
    simp [MvFunctor.id_map, Sum.elim]
    -- üéâ no goals
#align mvqpf.cofix.dest_corec' MvQPF.Cofix.dest_corec'

theorem Cofix.dest_corec‚ÇÅ {Œ± : TypeVec n} {Œ≤ : Type u}
    (g : ‚àÄ {X}, (Cofix F Œ± ‚Üí X) ‚Üí (Œ≤ ‚Üí X) ‚Üí Œ≤ ‚Üí F (Œ±.append1 X)) (x : Œ≤)
    (h : ‚àÄ (X Y) (f : Cofix F Œ± ‚Üí X) (f' : Œ≤ ‚Üí X) (k : X ‚Üí Y),
      g (k ‚àò f) (k ‚àò f') x = (id ::: k) <$$> g f f' x) :
    Cofix.dest (Cofix.corec‚ÇÅ (@g) x) = g id (Cofix.corec‚ÇÅ @g) x := by
  rw [Cofix.corec‚ÇÅ, Cofix.dest_corec', ‚Üê h]; rfl
  -- ‚ä¢ g (Sum.elim _root_.id (corec' fun x => g Sum.inl Sum.inr x) ‚àò Sum.inl) (Sum. ‚Ä¶
                                             -- üéâ no goals
#align mvqpf.cofix.dest_corec‚ÇÅ MvQPF.Cofix.dest_corec‚ÇÅ

instance mvqpfCofix : MvQPF (Cofix F) where
  P         := q.P.mp
  abs       := Quot.mk Mcongr
  repr      := Cofix.repr
  abs_repr  := Cofix.abs_repr
  abs_map   := by intros; rfl
                  -- ‚ä¢ (fun {Œ±} => Quot.mk Mcongr) (f‚úù <$$> p‚úù) = f‚úù <$$> (fun {Œ±} => Quot.mk Mcong ‚Ä¶
                          -- üéâ no goals
#align mvqpf.mvqpf_cofix MvQPF.mvqpfCofix

end MvQPF
