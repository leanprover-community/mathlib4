/-
Copyright (c) 2022 Eric Rodriguez. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Rodriguez
-/
import Mathlib.Algebra.BigOperators.Order
import Mathlib.Data.Fintype.BigOperators
import Mathlib.Data.Int.Lemmas

#align_import data.sign from "leanprover-community/mathlib"@"2445c98ae4b87eabebdde552593519b9b6dc350c"
/-!
# Sign function

This file defines the sign function for types with zero and a decidable less-than relation, and
proves some basic theorems about it.
-/

-- Porting note: Cannot automatically derive Fintype, added manually
/-- The type of signs. -/
inductive SignType
  | zero
  | neg
  | pos
  deriving DecidableEq, Inhabited
#align sign_type SignType

-- Porting note: these lemmas are autogenerated by the inductive definition and are not
-- in simple form due to the below `x_eq_x` lemmas
attribute [nolint simpNF] SignType.zero.sizeOf_spec
attribute [nolint simpNF] SignType.neg.sizeOf_spec
attribute [nolint simpNF] SignType.pos.sizeOf_spec

namespace SignType

-- Porting note: Added Fintype SignType manually
instance : Fintype SignType :=
   Fintype.ofMultiset (zero :: neg :: pos :: List.nil) (fun x â†¦ by cases x <;> simp only)
                                                                               -- ğŸ‰ no goals
                                                                               -- ğŸ‰ no goals
                                                                               -- ğŸ‰ no goals

instance : Zero SignType :=
  âŸ¨zeroâŸ©

instance : One SignType :=
  âŸ¨posâŸ©

instance : Neg SignType :=
  âŸ¨fun s =>
    match s with
    | neg => pos
    | zero => zero
    | pos => negâŸ©

@[simp]
theorem zero_eq_zero : zero = 0 :=
  rfl
#align sign_type.zero_eq_zero SignType.zero_eq_zero

@[simp]
theorem neg_eq_neg_one : neg = -1 :=
  rfl
#align sign_type.neg_eq_neg_one SignType.neg_eq_neg_one

@[simp]
theorem pos_eq_one : pos = 1 :=
  rfl
#align sign_type.pos_eq_one SignType.pos_eq_one

instance : Mul SignType :=
  âŸ¨fun x y =>
    match x with
    | neg => -y
    | zero => zero
    | pos => yâŸ©

/-- The less-than-or-equal relation on signs. -/
protected inductive LE : SignType â†’ SignType â†’ Prop
  | of_neg (a) : SignType.LE neg a
  | zero : SignType.LE zero zero
  | of_pos (a) : SignType.LE a pos
#align sign_type.le SignType.LE

instance : LE SignType :=
  âŸ¨SignType.LEâŸ©

instance LE.decidableRel : DecidableRel SignType.LE := fun a b => by
  cases a <;> cases b <;> first | exact isTrue (by constructor)| exact isFalse (by rintro âŸ¨_âŸ©)
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals

instance decidableEq : DecidableEq SignType := fun a b => by
  cases a <;> cases b <;> first | exact isTrue (by constructor)| exact isFalse (by rintro âŸ¨_âŸ©)
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals

private lemma mul_comm : âˆ€ (a b : SignType), a * b = b * a := by rintro âŸ¨âŸ© âŸ¨âŸ© <;> rfl
                                                                                  -- ğŸ‰ no goals
                                                                                  -- ğŸ‰ no goals
                                                                                  -- ğŸ‰ no goals
                                                                                  -- ğŸ‰ no goals
                                                                                  -- ğŸ‰ no goals
                                                                                  -- ğŸ‰ no goals
                                                                                  -- ğŸ‰ no goals
                                                                                  -- ğŸ‰ no goals
                                                                                  -- ğŸ‰ no goals
private lemma mul_assoc : âˆ€ (a b c : SignType), (a * b) * c = a * (b * c) := by
  rintro âŸ¨âŸ© âŸ¨âŸ© âŸ¨âŸ© <;> rfl
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals
                      -- ğŸ‰ no goals

/- We can define a `Field` instance on `SignType`, but it's not mathematically sensible,
so we only define the `CommGroupWithZero`. -/
instance : CommGroupWithZero SignType where
  zero := 0
  one := 1
  mul := (Â· * Â·)
  inv := id
  mul_zero a := by cases a <;> rfl
                               -- ğŸ‰ no goals
                               -- ğŸ‰ no goals
                              -- ğŸ‰ no goals
                              -- ğŸ‰ no goals
                              -- ğŸ‰ no goals
                              -- ğŸ‰ no goals
                              -- ğŸ‰ no goals
                              -- ğŸ‰ no goals
                               -- ğŸ‰ no goals
                               -- ğŸ‰ no goals
                               -- ğŸ‰ no goals
                               -- ğŸ‰ no goals
  zero_mul a := by cases a <;> rfl
  mul_one a := by cases a <;> rfl
  one_mul a := by cases a <;> rfl
  mul_inv_cancel a ha := by cases a <;> trivial
                                        -- ğŸ‰ no goals
                                        -- ğŸ‰ no goals
                                        -- ğŸ‰ no goals
                              -- ğŸ‰ no goals
  mul_comm := mul_comm
  mul_assoc := mul_assoc
  exists_pair_ne := âŸ¨0, 1, by rintro âŸ¨_âŸ©âŸ©
  inv_zero := rfl

private lemma le_antisymm (a b : SignType) (_ : a â‰¤ b) (_: b â‰¤ a) : a = b := by
  cases a <;> cases b <;> trivial
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals
                          -- ğŸ‰ no goals

private lemma le_trans (a b c : SignType) (_ : a â‰¤ b) (_: b â‰¤ c) : a â‰¤ c := by
  cases a <;> cases b <;> cases c <;> first | tauto | constructor
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals
                                      -- ğŸ‰ no goals

instance : LinearOrder SignType where
  le := (Â· â‰¤ Â·)
  le_refl a := by cases a <;> constructor
                              -- ğŸ‰ no goals
                              -- ğŸ‰ no goals
                              -- ğŸ‰ no goals
  le_total a b := by cases a <;> cases b <;> first | left; constructor | right; constructor
                                             -- ğŸ‰ no goals
                                             -- ğŸ‰ no goals
                                             -- ğŸ‰ no goals
                                             -- ğŸ‰ no goals
                                             -- ğŸ‰ no goals
                                             -- ğŸ‰ no goals
                                             -- ğŸ‰ no goals
                                             -- ğŸ‰ no goals
                                             -- ğŸ‰ no goals
  le_antisymm := le_antisymm
  le_trans := le_trans
  decidableLE := LE.decidableRel
  decidableEq := SignType.decidableEq

instance : BoundedOrder SignType where
  top := 1
  le_top := LE.of_pos
  bot := -1
  bot_le := LE.of_neg

instance : HasDistribNeg SignType :=
  { neg_neg := fun x => by cases x <;> rfl
                                       -- ğŸ‰ no goals
                                       -- ğŸ‰ no goals
                                       -- ğŸ‰ no goals
    neg_mul := fun x y => by cases x <;> cases y <;> rfl
                                                     -- ğŸ‰ no goals
                                                     -- ğŸ‰ no goals
                                                     -- ğŸ‰ no goals
                                                     -- ğŸ‰ no goals
                                                     -- ğŸ‰ no goals
                                                     -- ğŸ‰ no goals
                                                     -- ğŸ‰ no goals
                                                     -- ğŸ‰ no goals
                                                     -- ğŸ‰ no goals
    mul_neg := fun x y => by cases x <;> cases y <;> rfl }
                                                     -- ğŸ‰ no goals
                                                     -- ğŸ‰ no goals
                                                     -- ğŸ‰ no goals
                                                     -- ğŸ‰ no goals
                                                     -- ğŸ‰ no goals
                                                     -- ğŸ‰ no goals
                                                     -- ğŸ‰ no goals
                                                     -- ğŸ‰ no goals
                                                     -- ğŸ‰ no goals

/-- `SignType` is equivalent to `Fin 3`. -/
def fin3Equiv : SignType â‰ƒ* Fin 3 where
  toFun a :=
    match a with
    | 0 => âŸ¨0, by simpâŸ©
                  -- ğŸ‰ no goals
    | 1 => âŸ¨1, by simpâŸ©
                  -- ğŸ‰ no goals
    | -1 => âŸ¨2, by simpâŸ©
                   -- ğŸ‰ no goals
  invFun a :=
    match a with
    | âŸ¨0, _âŸ© => 0
    | âŸ¨1, _âŸ© => 1
    | âŸ¨2, _âŸ© => -1
    | âŸ¨n + 3, hâŸ© => (h.not_le le_add_self).elim
  left_inv a := by cases a <;> rfl
                               -- ğŸ‰ no goals
                               -- ğŸ‰ no goals
                               -- ğŸ‰ no goals
  right_inv a :=
    match a with
    | âŸ¨0, _âŸ© => by simp
                   -- ğŸ‰ no goals
    | âŸ¨1, _âŸ© => by simp
                   -- ğŸ‰ no goals
    | âŸ¨2, _âŸ© => by simp
                   -- ğŸ‰ no goals
    | âŸ¨n + 3, hâŸ© => by simp at h
                       -- ğŸ‰ no goals
  map_mul' a b := by
    cases a <;> cases b <;> simp
                            -- ğŸ‰ no goals
                            -- ğŸ‰ no goals
                            -- ğŸ‰ no goals
                            -- ğŸ‰ no goals
                            -- ğŸ‰ no goals
                            -- ğŸ‰ no goals
                            -- ğŸ‰ no goals
                            -- ğŸ‰ no goals
                            -- ğŸ‰ no goals
#align sign_type.fin3_equiv SignType.fin3Equiv

section CaseBashing

-- Porting note: a lot of these thms used to use decide! which is not implemented yet
theorem nonneg_iff {a : SignType} : 0 â‰¤ a â†” a = 0 âˆ¨ a = 1 := by cases a <;> decide
                                                                            -- ğŸ‰ no goals
                                                                            -- ğŸ‰ no goals
                                                                            -- ğŸ‰ no goals
#align sign_type.nonneg_iff SignType.nonneg_iff

theorem nonneg_iff_ne_neg_one {a : SignType} : 0 â‰¤ a â†” a â‰  -1 := by cases a <;> decide
                                                                                -- ğŸ‰ no goals
                                                                                -- ğŸ‰ no goals
                                                                                -- ğŸ‰ no goals
#align sign_type.nonneg_iff_ne_neg_one SignType.nonneg_iff_ne_neg_one

theorem neg_one_lt_iff {a : SignType} : -1 < a â†” 0 â‰¤ a := by cases a <;> decide
                                                                         -- ğŸ‰ no goals
                                                                         -- ğŸ‰ no goals
                                                                         -- ğŸ‰ no goals
#align sign_type.neg_one_lt_iff SignType.neg_one_lt_iff

theorem nonpos_iff {a : SignType} : a â‰¤ 0 â†” a = -1 âˆ¨ a = 0 := by cases a <;> decide
                                                                             -- ğŸ‰ no goals
                                                                             -- ğŸ‰ no goals
                                                                             -- ğŸ‰ no goals
#align sign_type.nonpos_iff SignType.nonpos_iff

theorem nonpos_iff_ne_one {a : SignType} : a â‰¤ 0 â†” a â‰  1 := by cases a <;> decide
                                                                           -- ğŸ‰ no goals
                                                                           -- ğŸ‰ no goals
                                                                           -- ğŸ‰ no goals
#align sign_type.nonpos_iff_ne_one SignType.nonpos_iff_ne_one

theorem lt_one_iff {a : SignType} : a < 1 â†” a â‰¤ 0 := by cases a <;> decide
                                                                    -- ğŸ‰ no goals
                                                                    -- ğŸ‰ no goals
                                                                    -- ğŸ‰ no goals
#align sign_type.lt_one_iff SignType.lt_one_iff

@[simp]
theorem neg_iff {a : SignType} : a < 0 â†” a = -1 := by cases a <;> decide
                                                                  -- ğŸ‰ no goals
                                                                  -- ğŸ‰ no goals
                                                                  -- ğŸ‰ no goals
#align sign_type.neg_iff SignType.neg_iff

@[simp]
theorem le_neg_one_iff {a : SignType} : a â‰¤ -1 â†” a = -1 :=
  le_bot_iff
#align sign_type.le_neg_one_iff SignType.le_neg_one_iff

@[simp]
theorem pos_iff {a : SignType} : 0 < a â†” a = 1 := by cases a <;> decide
                                                                 -- ğŸ‰ no goals
                                                                 -- ğŸ‰ no goals
                                                                 -- ğŸ‰ no goals
#align sign_type.pos_iff SignType.pos_iff

@[simp]
theorem one_le_iff {a : SignType} : 1 â‰¤ a â†” a = 1 :=
  top_le_iff
#align sign_type.one_le_iff SignType.one_le_iff

@[simp]
theorem neg_one_le (a : SignType) : -1 â‰¤ a :=
  bot_le
#align sign_type.neg_one_le SignType.neg_one_le

@[simp]
theorem le_one (a : SignType) : a â‰¤ 1 :=
  le_top
#align sign_type.le_one SignType.le_one

@[simp]
theorem not_lt_neg_one (a : SignType) : Â¬a < -1 :=
  not_lt_bot
#align sign_type.not_lt_neg_one SignType.not_lt_neg_one

@[simp]
theorem not_one_lt (a : SignType) : Â¬1 < a :=
  not_top_lt
#align sign_type.not_one_lt SignType.not_one_lt

@[simp]
theorem self_eq_neg_iff (a : SignType) : a = -a â†” a = 0 := by cases a <;> decide
                                                                          -- ğŸ‰ no goals
                                                                          -- ğŸ‰ no goals
                                                                          -- ğŸ‰ no goals
#align sign_type.self_eq_neg_iff SignType.self_eq_neg_iff

@[simp]
theorem neg_eq_self_iff (a : SignType) : -a = a â†” a = 0 := by cases a <;> decide
                                                                          -- ğŸ‰ no goals
                                                                          -- ğŸ‰ no goals
                                                                          -- ğŸ‰ no goals
#align sign_type.neg_eq_self_iff SignType.neg_eq_self_iff

@[simp]
theorem neg_one_lt_one : (-1 : SignType) < 1 :=
  bot_lt_top
#align sign_type.neg_one_lt_one SignType.neg_one_lt_one

end CaseBashing

section cast

variable {Î± : Type*} [Zero Î±] [One Î±] [Neg Î±]

/-- Turn a `SignType` into zero, one, or minus one. This is a coercion instance, but note it is
only a `CoeTC` instance: see note [use has_coe_t]. -/
@[coe]
def cast : SignType â†’ Î±
  | zero => 0
  | pos => 1
  | neg => -1
#align sign_type.cast SignType.cast

-- Porting note: Translated has_coe_t to CoeTC
instance : CoeTC SignType Î± :=
  âŸ¨castâŸ©

-- Porting note: `cast_eq_coe` removed, syntactic equality

@[simp]
theorem coe_zero : â†‘(0 : SignType) = (0 : Î±) :=
  rfl
#align sign_type.coe_zero SignType.coe_zero

@[simp]
theorem coe_one : â†‘(1 : SignType) = (1 : Î±) :=
  rfl
#align sign_type.coe_one SignType.coe_one

@[simp]
theorem coe_neg_one : â†‘(-1 : SignType) = (-1 : Î±) :=
  rfl
#align sign_type.coe_neg_one SignType.coe_neg_one

end cast

/-- `SignType.cast` as a `MulWithZeroHom`. -/
@[simps]
def castHom {Î±} [MulZeroOneClass Î±] [HasDistribNeg Î±] : SignType â†’*â‚€ Î± where
  toFun := cast
  map_zero' := rfl
  map_one' := rfl
  map_mul' x y := by cases x <;> cases y <;> simp [zero_eq_zero, pos_eq_one, neg_eq_neg_one]
                                             -- ğŸ‰ no goals
                                             -- ğŸ‰ no goals
                                             -- ğŸ‰ no goals
                                             -- ğŸ‰ no goals
                                             -- ğŸ‰ no goals
                                             -- ğŸ‰ no goals
                                             -- ğŸ‰ no goals
                                             -- ğŸ‰ no goals
                                             -- ğŸ‰ no goals
#align sign_type.cast_hom SignType.castHom

--Porting note: new theorem
theorem univ_eq : (Finset.univ : Finset SignType) = {0, -1, 1} := by
  decide
  -- ğŸ‰ no goals

theorem range_eq {Î±} (f : SignType â†’ Î±) : Set.range f = {f zero, f neg, f pos} := by
  classical rw [â† Fintype.coe_image_univ, univ_eq]
  -- âŠ¢ â†‘(Finset.image f {0, -1, 1}) = {f zero, f neg, f pos}
  classical simp [Finset.coe_insert]
  -- ğŸ‰ no goals
#align sign_type.range_eq SignType.range_eq

end SignType

variable {Î± : Type*}

open SignType

section Preorder

variable [Zero Î±] [Preorder Î±] [DecidableRel ((Â· < Â·) : Î± â†’ Î± â†’ Prop)] {a : Î±}

-- Porting note: needed to rename this from sign to SignType.sign to avoid ambiguity with Int.sign
/-- The sign of an element is 1 if it's positive, -1 if negative, 0 otherwise. -/
def SignType.sign : Î± â†’o SignType :=
  âŸ¨fun a => if 0 < a then 1 else if a < 0 then -1 else 0, fun a b h => by
    dsimp
    -- âŠ¢ (if 0 < a then 1 else if a < 0 then -1 else 0) â‰¤ if 0 < b then 1 else if b < â€¦
    split_ifs with hâ‚ hâ‚‚ hâ‚ƒ hâ‚„ _ _ hâ‚‚ hâ‚ƒ <;> try constructor
                                             -- ğŸ‰ no goals
                                             -- âŠ¢ 1 â‰¤ -1
                                             -- âŠ¢ 1 â‰¤ 0
                                             -- ğŸ‰ no goals
                                             -- ğŸ‰ no goals
                                             -- ğŸ‰ no goals
                                             -- ğŸ‰ no goals
                                             -- âŠ¢ 0 â‰¤ -1
                                             -- ğŸ‰ no goals
    Â· cases lt_irrefl 0 (hâ‚.trans <| h.trans_lt hâ‚ƒ)
      -- ğŸ‰ no goals
    Â· cases hâ‚‚ (hâ‚.trans_le h)
      -- ğŸ‰ no goals
    Â· cases hâ‚„ (h.trans_lt hâ‚ƒ)âŸ©
      -- ğŸ‰ no goals
#align sign SignType.sign

theorem sign_apply : sign a = ite (0 < a) 1 (ite (a < 0) (-1) 0) :=
  rfl
#align sign_apply sign_apply

@[simp]
theorem sign_zero : sign (0 : Î±) = 0 := by simp [sign_apply]
                                           -- ğŸ‰ no goals
#align sign_zero sign_zero

@[simp]
theorem sign_pos (ha : 0 < a) : sign a = 1 := by rwa [sign_apply, if_pos]
                                                 -- ğŸ‰ no goals
#align sign_pos sign_pos

@[simp]
theorem sign_neg (ha : a < 0) : sign a = -1 := by rwa [sign_apply, if_neg <| asymm ha, if_pos]
                                                  -- ğŸ‰ no goals
#align sign_neg sign_neg

theorem sign_eq_one_iff : sign a = 1 â†” 0 < a := by
  refine' âŸ¨fun h => _, fun h => sign_pos hâŸ©
  -- âŠ¢ 0 < a
  by_contra hn
  -- âŠ¢ False
  rw [sign_apply, if_neg hn] at h
  -- âŠ¢ False
  split_ifs at h
  -- ğŸ‰ no goals
#align sign_eq_one_iff sign_eq_one_iff

theorem sign_eq_neg_one_iff : sign a = -1 â†” a < 0 := by
  refine' âŸ¨fun h => _, fun h => sign_neg hâŸ©
  -- âŠ¢ a < 0
  rw [sign_apply] at h
  -- âŠ¢ a < 0
  split_ifs at h
  -- âŠ¢ a < 0
  Â· assumption
    -- ğŸ‰ no goals
#align sign_eq_neg_one_iff sign_eq_neg_one_iff

end Preorder

section LinearOrder

variable [Zero Î±] [LinearOrder Î±] {a : Î±}

@[simp]
theorem sign_eq_zero_iff : sign a = 0 â†” a = 0 := by
  refine' âŸ¨fun h => _, fun h => h.symm â–¸ sign_zeroâŸ©
  -- âŠ¢ a = 0
  rw [sign_apply] at h
  -- âŠ¢ a = 0
  split_ifs at h with h_1 h_2
  -- âŠ¢ a = 0
  cases' h
  -- âŠ¢ a = 0
  exact (le_of_not_lt h_1).eq_of_not_lt h_2
  -- ğŸ‰ no goals
#align sign_eq_zero_iff sign_eq_zero_iff

theorem sign_ne_zero : sign a â‰  0 â†” a â‰  0 :=
  sign_eq_zero_iff.not
#align sign_ne_zero sign_ne_zero

@[simp]
theorem sign_nonneg_iff : 0 â‰¤ sign a â†” 0 â‰¤ a := by
  rcases lt_trichotomy 0 a with (h | h | h)
  Â· simp [h, h.le]
    -- ğŸ‰ no goals
  Â· simp [â†h]
    -- ğŸ‰ no goals
  Â· simp [h, h.not_le]
    -- ğŸ‰ no goals
#align sign_nonneg_iff sign_nonneg_iff

@[simp]
theorem sign_nonpos_iff : sign a â‰¤ 0 â†” a â‰¤ 0 := by
  rcases lt_trichotomy 0 a with (h | h | h)
  Â· simp [h, h.not_le]
    -- ğŸ‰ no goals
  Â· simp [â†h]
    -- ğŸ‰ no goals
  Â· simp [h, h.le]
    -- ğŸ‰ no goals
#align sign_nonpos_iff sign_nonpos_iff

end LinearOrder

section OrderedSemiring

variable [OrderedSemiring Î±] [DecidableRel ((Â· < Â·) : Î± â†’ Î± â†’ Prop)] [Nontrivial Î±]

-- @[simp] -- Porting note: simp can prove this
theorem sign_one : sign (1 : Î±) = 1 :=
  sign_pos zero_lt_one
#align sign_one sign_one

end OrderedSemiring

section LinearOrderedRing

variable [LinearOrderedRing Î±] {a b : Î±}

/- I'm not sure why this is necessary, see https://leanprover.zulipchat.com/#narrow/stream/
113488-general/topic/type.20class.20inference.20issues/near/276937942 -/
attribute [local instance] LinearOrderedRing.decidableLT

theorem sign_mul (x y : Î±) : sign (x * y) = sign x * sign y := by
  rcases lt_trichotomy x 0 with (hx | hx | hx) <;> rcases lt_trichotomy y 0 with (hy | hy | hy) <;>
    simp [hx, hy, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
    -- ğŸ‰ no goals
    -- ğŸ‰ no goals
    -- ğŸ‰ no goals
    -- ğŸ‰ no goals
    -- ğŸ‰ no goals
    -- ğŸ‰ no goals
    -- ğŸ‰ no goals
    -- ğŸ‰ no goals
    -- ğŸ‰ no goals
#align sign_mul sign_mul

@[simp] theorem sign_mul_abs (x : Î±) : (sign x * |x| : Î±) = x := by
  rcases lt_trichotomy x 0 with (hx | rfl | hx)
  Â· rw [sign_neg hx, abs_of_neg hx, coe_neg_one, neg_one_mul, neg_neg]
    -- ğŸ‰ no goals
  Â· rw [abs_zero, mul_zero]
    -- ğŸ‰ no goals
  Â· rw [sign_pos hx, abs_of_pos hx, coe_one, one_mul]
    -- ğŸ‰ no goals

@[simp] theorem abs_mul_sign (x : Î±) : (|x| * sign x : Î±) = x := by
  rcases lt_trichotomy x 0 with (hx | rfl | hx)
  Â· rw [sign_neg hx, abs_of_neg hx, coe_neg_one, mul_neg_one, neg_neg]
    -- ğŸ‰ no goals
  Â· rw [abs_zero, zero_mul]
    -- ğŸ‰ no goals
  Â· rw [sign_pos hx, abs_of_pos hx, coe_one, mul_one]
    -- ğŸ‰ no goals

/-- `SignType.sign` as a `MonoidWithZeroHom` for a nontrivial ordered semiring. Note that linearity
is required; consider â„‚ with the order `z â‰¤ w` iff they have the same imaginary part and
`z - w â‰¤ 0` in the reals; then `1 + I` and `1 - I` are incomparable to zero, and thus we have:
`0 * 0 = SignType.sign (1 + I) * SignType.sign (1 - I) â‰  SignType.sign 2 = 1`.
(`Complex.orderedCommRing`) -/
def signHom : Î± â†’*â‚€ SignType where
  toFun := sign
  map_zero' := sign_zero
  map_one' := sign_one
  map_mul' := sign_mul
#align sign_hom signHom

theorem sign_pow (x : Î±) (n : â„•) : sign (x ^ n) = sign x ^ n := map_pow signHom x n
#align sign_pow sign_pow

end LinearOrderedRing

section AddGroup

variable [AddGroup Î±] [Preorder Î±] [DecidableRel ((Â· < Â·) : Î± â†’ Î± â†’ Prop)]

theorem Left.sign_neg [CovariantClass Î± Î± (Â· + Â·) (Â· < Â·)] (a : Î±) : sign (-a) = -sign a := by
  simp_rw [sign_apply, Left.neg_pos_iff, Left.neg_neg_iff]
  -- âŠ¢ (if a < 0 then 1 else if 0 < a then -1 else 0) = -if 0 < a then 1 else if a  â€¦
  split_ifs with h h'
  Â· exact False.elim (lt_asymm h h')
    -- ğŸ‰ no goals
  Â· simp
    -- ğŸ‰ no goals
  Â· simp
    -- ğŸ‰ no goals
  Â· simp
    -- ğŸ‰ no goals
#align left.sign_neg Left.sign_neg

theorem Right.sign_neg [CovariantClass Î± Î± (Function.swap (Â· + Â·)) (Â· < Â·)] (a : Î±) :
    sign (-a) = -sign a := by
  simp_rw [sign_apply, Right.neg_pos_iff, Right.neg_neg_iff]
  -- âŠ¢ (if a < 0 then 1 else if 0 < a then -1 else 0) = -if 0 < a then 1 else if a  â€¦
  split_ifs with h h'
  Â· exact False.elim (lt_asymm h h')
    -- ğŸ‰ no goals
  Â· simp
    -- ğŸ‰ no goals
  Â· simp
    -- ğŸ‰ no goals
  Â· simp
    -- ğŸ‰ no goals
#align right.sign_neg Right.sign_neg

end AddGroup

section LinearOrderedAddCommGroup
open BigOperators

variable [LinearOrderedAddCommGroup Î±]

/- I'm not sure why this is necessary, see
https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Decidable.20vs.20decidable_rel
-/
attribute [local instance] LinearOrderedAddCommGroup.decidableLT

theorem sign_sum {Î¹ : Type*} {s : Finset Î¹} {f : Î¹ â†’ Î±} (hs : s.Nonempty) (t : SignType)
    (h : âˆ€ i âˆˆ s, sign (f i) = t) : sign (âˆ‘ i in s, f i) = t := by
  cases t
  Â· simp_rw [zero_eq_zero, sign_eq_zero_iff] at h âŠ¢
    -- âŠ¢ âˆ‘ i in s, f i = 0
    exact Finset.sum_eq_zero h
    -- ğŸ‰ no goals
  Â· simp_rw [neg_eq_neg_one, sign_eq_neg_one_iff] at h âŠ¢
    -- âŠ¢ âˆ‘ i in s, f i < 0
    exact Finset.sum_neg h hs
    -- ğŸ‰ no goals
  Â· simp_rw [pos_eq_one, sign_eq_one_iff] at h âŠ¢
    -- âŠ¢ 0 < âˆ‘ i in s, f i
    exact Finset.sum_pos h hs
    -- ğŸ‰ no goals
#align sign_sum sign_sum

end LinearOrderedAddCommGroup

namespace Int

theorem sign_eq_sign (n : â„¤) : Int.sign n = SignType.sign n := by
  obtain (n | _) | _ := n <;> simp [sign, Int.sign_neg, negSucc_lt_zero]
                              -- ğŸ‰ no goals
                              -- ğŸ‰ no goals
                              -- ğŸ‰ no goals
#align int.sign_eq_sign Int.sign_eq_sign

end Int

open Finset Nat

open BigOperators

/- Porting note: For all the following theorems, needed to add {Î± : Type u_1} to the assumptions
because lean4 infers Î± to live in a different universe u_2 otherwise -/
private theorem exists_signed_sum_aux {Î± : Type u_1} [DecidableEq Î±] (s : Finset Î±) (f : Î± â†’ â„¤) :
    âˆƒ (Î² : Type u_1) (t : Finset Î²) (sgn : Î² â†’ SignType) (g : Î² â†’ Î±),
      (âˆ€ b, g b âˆˆ s) âˆ§
        (t.card = âˆ‘ a in s, (f a).natAbs) âˆ§
          âˆ€ a âˆˆ s, (âˆ‘ b in t, if g b = a then (sgn b : â„¤) else 0) = f a := by
  refine'
    âŸ¨(Î£ _ : { x // x âˆˆ s }, â„•), Finset.univ.sigma fun a => range (f a).natAbs,
      fun a => sign (f a.1), fun a => a.1, fun a => a.1.2, _, _âŸ©
  Â· simp [sum_attach (f := fun a => (f a).natAbs)]
    -- ğŸ‰ no goals
  Â· intro x hx
    -- âŠ¢ (âˆ‘ b in Finset.sigma univ fun a => range (Int.natAbs (f â†‘a)), if (fun a => â†‘ â€¦
    simp [sum_sigma, hx, â† Int.sign_eq_sign, Int.sign_mul_abs, mul_comm |f _|,
      sum_attach (s := s) (f := fun y => if y = x then f y else 0)]

/-- We can decompose a sum of absolute value `n` into a sum of `n` signs. -/
theorem exists_signed_sum {Î± : Type u_1} [DecidableEq Î±] (s : Finset Î±) (f : Î± â†’ â„¤) :
    âˆƒ (Î² : Type u_1) (_ : Fintype Î²) (sgn : Î² â†’ SignType) (g : Î² â†’ Î±),
      (âˆ€ b, g b âˆˆ s) âˆ§
        (Fintype.card Î² = âˆ‘ a in s, (f a).natAbs) âˆ§
          âˆ€ a âˆˆ s, (âˆ‘ b, if g b = a then (sgn b : â„¤) else 0) = f a :=
  let âŸ¨Î², t, sgn, g, hg, ht, hfâŸ© := exists_signed_sum_aux s f
  âŸ¨t, inferInstance, fun b => sgn b, fun b => g b, fun b => hg b, by simp [ht], fun a ha =>
                                                                     -- ğŸ‰ no goals
    (@sum_attach _ _ t _ fun b => ite (g b = a) (sgn b : â„¤) 0).trans <| hf _ haâŸ©
#align exists_signed_sum exists_signed_sum

/-- We can decompose a sum of absolute value less than `n` into a sum of at most `n` signs. -/
theorem exists_signed_sum' {Î± : Type u_1} [Nonempty Î±] [DecidableEq Î±] (s : Finset Î±) (f : Î± â†’ â„¤)
  (n : â„•) (h : (âˆ‘ i in s, (f i).natAbs) â‰¤ n) :
    âˆƒ (Î² : Type u_1) (_ : Fintype Î²) (sgn : Î² â†’ SignType) (g : Î² â†’ Î±),
      (âˆ€ b, g b âˆ‰ s â†’ sgn b = 0) âˆ§
        Fintype.card Î² = n âˆ§ âˆ€ a âˆˆ s, (âˆ‘ i, if g i = a then (sgn i : â„¤) else 0) = f a := by
  obtain âŸ¨Î², _, sgn, g, hg, hÎ², hfâŸ© := exists_signed_sum s f
  -- âŠ¢ âˆƒ Î² x sgn g, (âˆ€ (b : Î²), Â¬g b âˆˆ s â†’ sgn b = 0) âˆ§ Fintype.card Î² = n âˆ§ âˆ€ (a : â€¦
  refine'
    âŸ¨Sum Î² (Fin (n - âˆ‘ i in s, (f i).natAbs)), inferInstance, Sum.elim sgn 0,
      Sum.elim g (Classical.arbitrary (Fin (n - Finset.sum s fun i => Int.natAbs (f i)) â†’ Î±)),
        _, by simp [hÎ², h], fun a ha => by simp [hf _ ha]âŸ©
  rintro (b | b) hb
  -- âŠ¢ Sum.elim sgn 0 (Sum.inl b) = 0
  Â· cases hb (hg _)
    -- ğŸ‰ no goals
  Â· rfl
    -- ğŸ‰ no goals
#align exists_signed_sum' exists_signed_sum'
