-- REMOVE
/-- Adding row `j` of matrix `M` times scalar `-x` to row `i` and then adding row `j` times `x` to
row `i` will return the original matrix `M`. -/
@[simp]
theorem addMulRow_addMulRow_neg_cancel_right [Ring R] [AddCommGroup α] [Module R α]
    (M : Matrix m n α) (i : m) (j : m) (h1 : j ≠ i) (x : R) :
    addMulRow (addMulRow M i j (-x)) i j x = M := by
  unfold addMulRow
  ext k l
  by_cases h : k = i
  · rw [h]
    repeat rw [updateRow_self]
    rw [updateRow_ne]
    simp
    exact h1
  · rw [updateRow_ne h]
    rw [updateRow_ne h]

/-! ### extra -/

/-- The value at row `i` and column `l` of matrix `M` will be 1 after multiplying row `i` by the
multiplicative inverse of the value located at row `i` and column `l`, which must be non-zero. -/
@[simp]
theorem mulRow_inv_cancel [DecidableEq α] [DivisionRing α] {y : ℕ} {z : ℕ}
    (M : Matrix (Fin y) (Fin z) α) (i : Fin y) (l : Fin z) (h : M i l ≠ 0) :
    (mulRow M i (1/(M i l))) i l = 1 := by
  unfold mulRow
  simp only [one_div, updateRow_self, Pi.smul_apply, smul_eq_mul]
  rw [inv_mul_cancel₀]
  exact h


/-! ### extra -/

/-- The value at row `i` and column `l` of matrix `M` will be 0 after adding row `j` times the
negative of the value at row `i` and column `l` divided by the value at row `j` and column `l`
to row `i`. -/
@[simp]
theorem addMulRow_inv_cancel [DecidableEq α] [DivisionRing α] {y : ℕ} {z : ℕ}
    (M : Matrix (Fin y) (Fin z) α) (i : Fin y) (j : Fin y) (l : Fin z) (h : M j l ≠ 0) :
    (addMulRow M i j (-(M i l)*(1/(M j l)))) i l = 0 := by
  unfold addMulRow
  simp only [one_div, neg_mul, neg_smul, updateRow_self, Pi.add_apply, Pi.neg_apply, Pi.smul_apply,
    smul_eq_mul]
  rw [mul_assoc, inv_mul_cancel₀]
  simp
  exact h


-- /-- Multiplying row `i` of matrix `M` by a non-zero scalar `x` and then by `x`'s multiplicative
-- inverse will return the original matrix `M`. -/
-- @[simp]
-- theorem mulRow_mulRow_inv_cancel_left [GroupWithZero R] [MulAction R α] (M : Matrix m n α) (i : m)
--     (x : R) (hx : x ≠ 0) :
--     mulRow (mulRow M i x) i (x⁻¹) = M := by
--   unfold mulRow
--   ext k l
--   by_cases h : k = i
--   · rw [h]
--     repeat rw [updateRow_self]
--     simp
--     rw [inv_smul_smul₀]
--     --rw [smul_smul (x⁻¹) x (M i l)]
--     --rw [inv_mul_cancel₀]
--     simp
--     exact hx
--   · repeat rw [updateRow_ne h]

-- /-- Multiplying row `i` of matrix `M` by a non-zero scalar `x`'s multiplicative inverse and then by
-- `x`' will return the original matrix `M`. -/
-- @[simp]
-- theorem mulRow_mulRow_inv_cancel_right [GroupWithZero R] [MulAction R α] (M : Matrix m n α) (i : m)
--     (x : R) (hx : x ≠ 0) :
--     mulRow (mulRow M i x⁻¹) i (x) = M := by
--   unfold mulRow
--   ext k l
--   by_cases h : k = i
--   · rw [h]
--     repeat rw [updateRow_self]
--     simp
--     rw [smul_inv_smul₀]
--     --rw [smul_smul x (x⁻¹) (M i l)]
--     --rw [mul_inv_cancel₀]
--     simp
--     exact hx
--   · repeat rw [updateRow_ne h]



-- All of this is withing NonAssocRing:
-- mul_apply: [Fintype m] [Mul α] [AddCommMonoid α]
-- one_apply: [DecidableEq n] [Zero α] [One α]
-- one_mul : [MulOneClass M]
-- sum_ite_eq: [AddCommMonoid β]


-- [SMul R α] [Zero α] [One α] are for sure needed
-- smul_zero: [Zero A] [SMulZeroClass M A]
-- mul_apply: [Fintype m] [Mul α] [AddCommMonoid α]
-- smul_one_mul: [MulOneClass N] [SMul M N] [IsScalarTower M N N]
-- zero_mul:  [self : MulZeroClass M₀]
-- sum_ite_eq: [AddCommMonoid β]

-- /-- Multiplying matrix `M` by the elementary matrix derived from multiplying row `i` of the
-- identity matrix by scalar `x` is equivalent to multiplying row `i` of matrix `M` by scalar `x` -/
-- @[simp]
-- theorem mulRow_elem_mat_eq_mulRow [Fintype m] [NonAssocSemiring α] [SMulZeroClass R α]
--     [IsScalarTower R α α] (M : Matrix m m α) (i : m) (x : R) :
--     (mulRow_elem_mat i x) * M = mulRow M i x := by
--   rw [mulRow_elem_mat]
--   ext k l
--   by_cases h : k = i
--   · rw [h, mulRow_eq_mul_row]
--     rw [mul_apply, mulRow_eq_mul_row]
--     simp only [Pi.smul_apply]
--     simp_rw [one_apply]
--     simp only [smul_ite, smul_zero, ite_mul, smul_one_mul, zero_mul, Finset.sum_ite_eq,
--       Finset.mem_univ, ↓reduceIte]
--   · rw [mulRow_other_rows_same]
--     rw [mul_apply, mulRow_other_rows_same]
--     simp_rw [one_apply]
--     simp
--     repeat exact h

-- /-! ### mulRow elementary matrix has a left inverse -/

-- /-- Multiplying the elementary matrix derived from  multiplying row `i` of the identity matrix by
-- scalar `x` of the identity matrix by itself reverts it to the identity matrix. `mulRow_elem_mat`
-- is it's own inverse. -/
-- theorem mulRow_elem_inv [Fintype m] [NonAssocSemiring α] [SMulZeroClass R α] [IsScalarTower R α α]
--     [Group R] [MulAction R α] (i : m) (x : R) :
--     mulRow_elem_mat i x⁻¹ * mulRow_elem_mat i x = (1 : Matrix m m α) := by
--   rw [mulRow_elem_mat_eq_mulRow, mulRow_elem_mat, mulRow_mulRow_inv_cancel_left]





-- /-- Adding row `j` of matrix `M` times scalar `x` to row `i` and then adding row `j` times `-x` to
-- row `i` will return the original matrix `M`. -/
-- @[simp]
-- theorem addMulRow_addMulRow_neg_cancel_left [AddSemigroup R] [Neg R] [AddLeftCancelMonoid α] [SMul R α]
--     (M : Matrix m n α) (i : m) (j : m) (h1 : j ≠ i) (x : R) :
--     addMulRow (addMulRow M i j x) i j (-x) = M := by
--   unfold addMulRow
--   ext k l
--   by_cases h : k = i
--   · rw [h]
--     repeat rw [updateRow_self]
--     rw [updateRow_ne]
--     simp only [Pi.add_apply, Pi.smul_apply]
--     rw [add_assoc]
--     simp only [add_right_eq_self]



--     --exact h1
--   · rw [updateRow_ne h]
--     rw [updateRow_ne h]


-- /-- Adding row `j` of matrix `M` times scalar `x` to row `i` and then adding row `j` times `-x` to
-- row `i` will return the original matrix `M`. -/
-- @[simp]
-- theorem addMulRow_addMulRow_neg_cancel_left [AddGroup R] [AddGroup α] [SMul R α]
--     (M : Matrix m n α) (i : m) (j : m) (h1 : j ≠ i) (x : R) :
--     addMulRow (addMulRow M i j x) i j (-x) = M := by
--   unfold addMulRow
--   ext k l
--   by_cases h : k = i
--   · rw [h]
--     repeat rw [updateRow_self]
--     rw [updateRow_ne]
--     --rw [add_assoc]
--     simp only [Pi.add_apply, Pi.smul_apply]
--     rw [add_assoc]
--     simp only [add_right_eq_self]

--     exact h1
--   · rw [updateRow_ne h]
--     rw [updateRow_ne h]
