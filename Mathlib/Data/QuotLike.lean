/-
Copyright (c) 2024 Yuyang Zhao. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yuyang Zhao
-/
import Mathlib.Logic.Relator
import Mathlib.Logic.Unique
import Qq.MetaM

/-!
# Typeclass for quotient types

This typeclass is primarily for use by type synonyms of `Quot` and `Quotient`.

Using `QuotLike` API for type synonyms of `Quot` and `Quotient` will avoid defeq abuse caused by
directly using `Quot` and `Quotient` APIs.

## Main definitions

* `QuotLike Q α r`      : the type `Q` is canonically isomorphic to `Quot α r`.
                          used for deriving `QuotLike` instances from the output type.
* `QuotLike.HasQuot`    : used for deriving `QuotLike` instances from the input type.
* `QuotLike.Hint`       : used for deriving `QuotLike` instances from the hint.
* `QuotLike.HasQuotHint`: used for deriving `QuotLike` instances from the hint and the input type.
* `mkQ`                 : the canonical quotient map inferred from the output type

## Notations

* `⟦a⟧`                 : the canonical quotient map inferred from the output type
* `mkQ'` `⟦a⟧'`         : the canonical quotient map inferred from
                            the input type via typeclass `QuotLike.HasQuot`
* `mkQ_h` `⟦a⟧_h`       : the canonical quotient map inferred from
                            the hint via typeclass `QuotLike.Hint`
                            or the hint and the input type via typeclass `QuotLike.HasQuotHint`
-/

/--
The definition of `QuotLike`. It is needed to avoid name clashes
between `QuotLike.rec` `QuotLike.recOn` and the autogenerated recursors.
-/
class QuotLikeStruct (Q : Sort*) (α : outParam Sort*) (r : outParam (α → α → Prop)) where
  /-- The canonical quotient map. Inferred from the output type. -/
  mkQ : α → Q := by exact Quot.mk _
  /-- The canonical map from quotient to `Quot r`. -/
  toQuot : Q → Quot r := by exact (·)
  toQuot_mkQ : ∀ a, toQuot (mkQ a) = Quot.mk r a := by exact fun _ ↦ rfl
  mkQ_surjective : Function.Surjective mkQ := by exact Quot.exists_rep
  /--
  The analogue of `Quot.sound`: If `a` and `b` are related by the relation,
  then they have equal equivalence classes.
  -/
  sound {a b : α} : r a b → mkQ a = mkQ b := by exact Quot.sound

/--
The class `QuotLike Q α r` expresses the type `Q` is canonically isomorphic to `Quot α r`.

Using `QuotLike` API for type synonyms of `Quot` and `Quotient` will avoid defeq abuse caused by
directly using `Quot` and `Quotient` APIs.
-/
abbrev QuotLike := QuotLikeStruct

export QuotLikeStruct (mkQ)

namespace QuotLike

export QuotLikeStruct (mkQ toQuot)

alias toQuot_mkQ := QuotLikeStruct.toQuot_mkQ
alias sound := QuotLikeStruct.sound

attribute [simp] toQuot_mkQ

open Lean Elab Term Meta Qq

@[inherit_doc mkQ]
elab "⟦" a:term "⟧" : term <= Q => do
  synthesizeSyntheticMVars
  let Q ← instantiateMVars Q
  if Q.isMVar then
    tryPostpone
    throwError "The output type must be known."
  let v ← match ← inferType Q with | .sort v => pure v | _ => mkFreshLevelMVar
  have Q : Q(Sort v) := Q
  let α ← mkFreshExprMVarQ q(Sort $(← mkFreshLevelMVar))
  let r ← mkFreshExprMVarQ q($α → $α → Prop)
  let .some inst ← trySynthInstanceQ q(QuotLike $Q $α $r) |
    tryPostpone
    throwError "Cannot find `QuotLike` instance for type `{Q}`."
  pure q(@mkQ $Q $α $r $inst $(← Qq.elabTermEnsuringTypeQ a q($α)))

open PrettyPrinter.Delaborator SubExpr in
/-- Delaborator for `mkQ` -/
@[delab app.QuotLikeStruct.mkQ]
def delabMkQ : Delab := do
  guard <| (← getExpr).isAppOfArity' ``mkQ 5
  let a ← withNaryArg 4 delab
  `(⟦$a⟧)

@[inherit_doc mkQ]
macro "⟦" a:term " : " α:term "⟧" : term => `(⟦($a : $α)⟧)

/--
`QuotLike.HasQuot` is used for deriving `QuotLike` instances from the input type.

The instances of `QuotLike.HasQuot` may be defined for types that have specific uses.

```
instance : QuotLike.HasQuot ZFSet PSet PSet.Equiv where
```

They are also usually defined as scoped or local instances.

```
scoped instance {α} [s : Setoid α] : QuotLike.HasQuot (Quotient s) α (· ≈ ·) where
```
-/
class HasQuot (Q : outParam Sort*) (α : Sort*) (r : outParam (α → α → Prop))
    [QuotLike Q α r] : Prop where

/-- The canonical quotient map. Inferred from the input type via typeclass `QuotLike.HasQuot`. -/
syntax (name := mkQ') "mkQ'" : term

@[term_elab QuotLike.mkQ', inherit_doc QuotLike.mkQ']
def mkQ'Impl : TermElab := fun stx typ? => do
  let .some expectedType := typ? |
    let α ← mkFreshTypeMVar
    let β ← mkFreshTypeMVar
    postponeElabTerm stx (some (← mkArrow α β))
  synthesizeSyntheticMVars
  let expectedType ← instantiateMVars expectedType
  let expectedType ← whnf expectedType
  let .forallE _ α _ _ := expectedType |
    if expectedType.isMVar then tryPostpone
    throwError "Expected type is not a function."
  if α.isMVar then
    tryPostpone
    throwError "The input type must be known."
  let Q ← mkFreshExprMVarQ q(Sort $(← mkFreshLevelMVar))
  let u ← match ← inferType α with | .sort u => pure u | _ => mkFreshLevelMVar
  have α : Q(Sort u) := α
  let r ← mkFreshExprMVarQ q($α → $α → Prop)
  let inst ← mkFreshExprMVarQ q(QuotLike $Q $α $r)
  let .some _ ← trySynthInstanceQ q(@HasQuot $Q $α $r $inst) |
    tryPostpone
    throwError "Cannot find `QuotLike.HasQuot` instance for type `{α}`."
  pure q(@mkQ $Q $α $r $inst)

/-- The canonical quotient map. Inferred from the input type. -/
macro "⟦" t:term "⟧'" : term => `(mkQ' $t)

/-- The canonical quotient map. Inferred from the input type. -/
macro "⟦" t:term " : " α:term "⟧'" : term => `(⟦($t : $α)⟧')

/--
`QuotLike.Hint` is used for deriving `QuotLike` instances from the hint.

```
scoped instance {α} (r : α → α → Prop) : QuotLike.Hint r (Quot r) α r where
```

```
instance (p : Submodule R M) : QuotLike.Hint p (M ⧸ p) M p.quotientRel where
```
-/
class Hint {Hint : Sort*} (hint : Hint)
    (Q : outParam Sort*) (α : outParam Sort*) (r : outParam (α → α → Prop))
    [QuotLike Q α r] : Prop where

/--
`QuotLike.HasQuotHint` is used for deriving `QuotLike` instances from the hint and the input type.

```
scoped instance [Group G] [MulAction G α] :
    QuotLike.HasQuotHint G (MulAction.orbitRel.Quotient G α) α (MulAction.orbitRel G α) where
```
-/
class HasQuotHint {Hint : Sort*} (hint : Hint)
    (Q : outParam Sort*) (α : Sort*) (r : outParam (α → α → Prop))
    [QuotLike Q α r] : Prop where

/-- The canonical quotient map. Inferred from the hint via typeclass `QuotLike.Hint` or
the hint and the input type via typeclass `QuotLike.HasQuotHint`. -/
syntax:max (name := mkQ_) "mkQ_" term:max : term

@[term_elab QuotLike.mkQ_, inherit_doc QuotLike.mkQ_]
def mkQ_Impl : TermElab := fun stx typ? => do
  let `(mkQ_ $h) := stx | throwUnsupportedSyntax
  let h ← withSynthesize do elabTerm h none
  synthesizeSyntheticMVars
  let h ← instantiateMVars h
  let H ← inferType h
  let v ← match ← inferType H with | .sort v => pure v | _ => mkFreshLevelMVar
  have H : Q(Sort v) := H
  have h : Q($H) := h

  let Q ← mkFreshExprMVarQ q(Sort $(← mkFreshLevelMVar))
  let α ← mkFreshExprMVarQ q(Sort $(← mkFreshLevelMVar))
  let r ← mkFreshExprMVarQ q($α → $α → Prop)
  let inst ← mkFreshExprMVarQ q(QuotLike $Q $α $r)
  if let .some _ ← trySynthInstanceQ q(@Hint $H $h $Q $α $r $inst) then
    return q(@QuotLikeStruct.mkQ $Q $α $r $inst)

  let .some expectedType := typ? |
    let α ← mkFreshTypeMVar
    let β ← mkFreshTypeMVar
    postponeElabTerm stx (some (← mkArrow α β))
  let expectedType ← instantiateMVars expectedType
  let expectedType ← whnf expectedType
  let .forallE _ α _ _ := expectedType |
    if expectedType.isMVar then tryPostpone
    throwError "Expected type is not a function."
  if α.isMVar then
    tryPostpone
    throwError "The input type is not known, cannot find an instance of `QuotLike.Hint` \
                  for hint `{h}`."

  let Q ← mkFreshExprMVarQ q(Sort $(← mkFreshLevelMVar))
  let u ← match ← inferType α with | .sort u => pure u | _ => mkFreshLevelMVar
  have α : Q(Sort u) := α
  let r ← mkFreshExprMVarQ q($α → $α → Prop)
  let inst ← mkFreshExprMVarQ q(QuotLike $Q $α $r)
  let .some _ ← trySynthInstanceQ q(@HasQuotHint $H $h $Q $α $r $inst) |
    tryPostpone
    throwError "Cannot find an instance of `QuotLike.Hint` for hint `{h}` or \
                  an instance of `QuotLike.HasQuotHint` for input type `{α}` and hint `{h}`."
  pure q(@QuotLikeStruct.mkQ $Q $α $r $inst)

/-- The canonical quotient map. Inferred from the hint via typeclass `QuotLike.Hint` or
the hint and the input type via typeclass `QuotLike.HasQuotHint`. -/
macro:max "⟦" t:term "⟧_" h:term:max : term => `(mkQ_$h $t)

/-- The canonical quotient map. Inferred from the hint via typeclass `QuotLike.Hint` or
the hint and the input type via typeclass `QuotLike.HasQuotHint`. -/
macro:max "⟦" t:term " : " α:term "⟧_" h:term:max : term => `(⟦($t : $α)⟧_$h)

end QuotLike

namespace Quot

instance instQuotLike {α} (r : α → α → Prop) : QuotLike (Quot r) α r where

@[nolint defLemma docBlame]
scoped instance instQuotLikeHint {α} (r : α → α → Prop) :
    QuotLike.Hint r (Quot r) α r where

end Quot

namespace Quotient

instance instQuotLike {α} (s : Setoid α) : QuotLike (Quotient s) α (· ≈ ·) where
  mkQ := Quotient.mk _

@[nolint defLemma docBlame]
scoped instance instHasQuot {α} [s : Setoid α] : QuotLike.HasQuot (Quotient s) α (· ≈ ·) where

end Quotient

namespace QuotLike

section

variable {Q : Sort*} {α : Sort*} {r : α → α → Prop} [QuotLike Q α r]

/--
The analogue of `Quot.lift`: if `f : α → β` respects the relation `r`,
then it lifts to a function on `Q` such that `lift f h ⟦a⟧ = f a`.
-/
protected def lift {β : Sort*} (f : α → β) (h : ∀ (a b : α), r a b → f a = f b) : Q → β :=
  fun q ↦ Quot.lift f h (toQuot q)

/--
The analogue of `Quot.liftOn`: if `f : α → β` respects the relation `r`,
then it lifts to a function on `Q` such that `liftOn ⟦a⟧ f h = f a`.
-/
protected abbrev liftOn {β : Sort*} (q : Q) (f : α → β) (c : (a b : α) → r a b → f a = f b) : β :=
  QuotLike.lift f c q

@[simp]
theorem lift_mkQ {β : Sort*} (f : α → β) (h : ∀ a₁ a₂, r a₁ a₂ → f a₁ = f a₂) (a : α) :
    QuotLike.lift f h (⟦a⟧ : Q) = f a := by
  rw [QuotLike.lift, toQuot_mkQ]

theorem liftOn_mkQ {β : Sort*} (a : α) (f : α → β) (h : ∀ a₁ a₂, r a₁ a₂ → f a₁ = f a₂) :
    QuotLike.liftOn (⟦a⟧ : Q) f h = f a :=
  lift_mkQ f h a

theorem exists_rep (q : Q) : ∃ a, ⟦a⟧ = q :=
  QuotLikeStruct.mkQ_surjective q

@[elab_as_elim]
theorem ind {motive : Q → Prop}
    (h : (a : α) → motive ⟦a⟧) (q : Q) : motive q :=
  (exists_rep q).rec fun a ha ↦ ha ▸ h a

@[elab_as_elim]
protected theorem inductionOn {motive : Q → Prop}
    (q : Q) (h : (a : α) → motive ⟦a⟧) : motive q :=
  ind h q

section
variable {motive : Q → Sort*} (f : (a : α) → motive ⟦a⟧)

/-- Auxiliary definition for `Quot.rec`. -/
@[reducible, macro_inline]
protected def indep (a : α) : PSigma motive :=
  ⟨⟦a⟧, f a⟩

protected theorem indepCoherent
    (h : (a b : α) → (p : r a b) → Eq.ndrec (f a) (sound p) = f b) :
    (a b : α) → r a b → QuotLike.indep f a = QuotLike.indep f b :=
  fun a b e ↦ PSigma.eta (sound e) (h a b e)

protected theorem liftIndepPr1
    (h : ∀ (a b : α) (p : r a b), Eq.ndrec (f a) (sound p) = f b) (q : Q) :
    (QuotLike.lift (QuotLike.indep f) (QuotLike.indepCoherent f h) q).1 = q := by
  induction q using QuotLike.ind
  rw [lift_mkQ]

end

/-- The analogue of `Quot.rec` for `QuotLike`. See `Quot.rec`. -/
@[inline, elab_as_elim]
protected def rec {motive : Q → Sort*}
    (f : (a : α) → motive ⟦a⟧)
    (h : (a b : α) → (p : r a b) → Eq.ndrec (f a) (sound p) = f b)
    (q : Q) :
    motive q :=
  Eq.ndrecOn (QuotLike.liftIndepPr1 f h q)
    ((QuotLike.lift (QuotLike.indep f) (QuotLike.indepCoherent f h) q).2)

@[simp]
theorem rec_mkQ {motive : Q → Sort*}
    (f : (a : α) → motive ⟦a⟧)
    (h : (a b : α) → (p : r a b) → Eq.ndrec (f a) (sound p) = f b)
    (a : α) :
    _root_.QuotLike.rec (motive := motive) f h ⟦a⟧ = f a := by
  rw [_root_.QuotLike.rec, ← heq_iff_eq, eqRec_heq_iff_heq, lift_mkQ]

/-- The analogue of `Quot.recOn` for `QuotLike`. See `Quot.recOn`. -/
@[elab_as_elim]
protected abbrev recOn {motive : Q → Sort*}
    (q : Q)
    (f : (a : α) → motive ⟦a⟧)
    (h : (a b : α) → (p : r a b) → Eq.ndrec (f a) (sound p) = f b) :
    motive q :=
  _root_.QuotLike.rec f h q

/-- The analogue of `Quot.recOnSubsingleton` for `QuotLike`. See `Quot.recOnSubsingleton`. -/
@[elab_as_elim]
protected abbrev recOnSubsingleton {motive : Q → Sort*}
    [_h : ∀ a, Subsingleton (motive ⟦a⟧)]
    (q : Q)
    (f : (a : α) → motive ⟦a⟧) :
    motive q :=
  _root_.QuotLike.recOn q f (fun _ _ _ ↦ Subsingleton.elim _ _)

/-- The analogue of `Quot.hrecOn` for `QuotLike`. See `Quot.hrecOn`. -/
@[elab_as_elim]
protected abbrev hrecOn {motive : Q → Sort*}
    (q : Q)
    (f : (a : α) → motive ⟦a⟧)
    (h : (a b : α) → r a b → HEq (f a) (f b)) :
    motive q :=
  _root_.QuotLike.recOn q f fun a b p ↦ eq_of_heq <| (eqRec_heq_self _ _).trans (h a b p)

theorem hrecOn_mkQ {motive : Q → Sort*}
    (a : α)
    (f : (a : α) → motive ⟦a⟧)
    (h : (a b : α) → r a b → HEq (f a) (f b)) :
    QuotLike.hrecOn (motive := motive) ⟦a⟧ f h = f a := by
  simp

end

section

variable {Qa α : Sort*} {ra : α → α → Prop} [QuotLike Qa α ra]
variable {Qb β : Sort*} {rb : β → β → Prop} [QuotLike Qb β rb]
variable {Qc γ : Sort*} {rc : γ → γ → Prop} [QuotLike Qc γ rc]
variable {φ : Sort*}

/-- Map a function `f : α → β` that sends equivalent elements to equivalent elements to a
function `f : Qa → Qb`. -/
protected def map (f : α → β) (h : (ra ⇒ rb) f f) : Qa → Qb :=
  (QuotLike.lift fun x ↦ ⟦f x⟧) fun _ _ ↦ (QuotLike.sound <| h ·)

@[simp]
theorem map_mkQ (f : α → β) (h : (ra ⇒ rb) f f) (a : α) :
    QuotLike.map f h (⟦a⟧ : Qa) = (⟦f a⟧ : Qb) :=
  lift_mkQ _ _ _

/-- Lift a binary function to a quotient on both arguments. -/
protected def lift₂'
    (f : α → β → φ)
    (ha : ∀ a₁ a₂ b, ra a₁ a₂ → f a₁ b = f a₂ b)
    (hb : ∀ a b₁ b₂, rb b₁ b₂ → f a b₁ = f a b₂) :
    Qa → Qb → φ :=
  QuotLike.lift (fun a ↦ QuotLike.lift (f a) (hb a))
    (fun a₁ a₂ h ↦ funext (QuotLike.ind (fun b ↦ by simpa [lift_mkQ] using ha a₁ a₂ b h)))

@[simp]
lemma lift₂'_mkQ
    (f : α → β → φ)
    (ha : ∀ a₁ a₂ b, ra a₁ a₂ → f a₁ b = f a₂ b)
    (hb : ∀ a b₁ b₂, rb b₁ b₂ → f a b₁ = f a b₂)
    (a : α) (b : β) :
    QuotLike.lift₂' f ha hb (⟦a⟧ : Qa) (⟦b⟧ : Qb) = f a b := by
  simp [QuotLike.lift₂']

/-- Lift a binary function to a quotient on both arguments. -/
protected abbrev liftOn₂'
    (qa : Qa) (qb : Qb)
    (f : α → β → φ)
    (ha : ∀ a₁ a₂ b, ra a₁ a₂ → f a₁ b = f a₂ b)
    (hb : ∀ a b₁ b₂, rb b₁ b₂ → f a b₁ = f a b₂) : φ :=
  QuotLike.lift₂' f ha hb qa qb

lemma liftOn₂'_mkQ
    (a : α) (b : β)
    (f : α → β → φ)
    (ha : ∀ a₁ a₂ b, ra a₁ a₂ → f a₁ b = f a₂ b)
    (hb : ∀ a b₁ b₂, rb b₁ b₂ → f a b₁ = f a b₂) :
    QuotLike.liftOn₂' (⟦a⟧ : Qa) (⟦b⟧ : Qb) f ha hb = f a b := by
  simp

/-- Lift a binary function to a quotient on both arguments. -/
protected abbrev lift₂ [IsRefl α ra] [IsRefl β rb]
    (f : α → β → φ)
    (h : ∀ a₁ b₁ a₂ b₂, ra a₁ a₂ → rb b₁ b₂ → f a₁ b₁ = f a₂ b₂) :
    Qa → Qb → φ :=
  QuotLike.lift₂' f (h · _ · · · (refl _)) (h · · _ · (refl _) ·)

lemma lift₂_mkQ [IsRefl α ra] [IsRefl β rb]
    (f : α → β → φ)
    (h : ∀ a₁ b₁ a₂ b₂, ra a₁ a₂ → rb b₁ b₂ → f a₁ b₁ = f a₂ b₂)
    (a : α) (b : β) :
    QuotLike.lift₂ f h (⟦a⟧ : Qa) (⟦b⟧ : Qb) = f a b := by
  simp

/-- Lift a binary function to a quotient on both arguments. -/
protected abbrev liftOn₂ [IsRefl α ra] [IsRefl β rb]
    (qa : Qa) (qb : Qb)
    (f : α → β → φ)
    (h : ∀ a₁ b₁ a₂ b₂, ra a₁ a₂ → rb b₁ b₂ → f a₁ b₁ = f a₂ b₂) : φ :=
  QuotLike.lift₂ f h qa qb

lemma liftOn₂_mkQ [IsRefl α ra] [IsRefl β rb]
    (a : α) (b : β)
    (f : α → β → φ)
    (h : ∀ a₁ b₁ a₂ b₂, ra a₁ a₂ → rb b₁ b₂ → f a₁ b₁ = f a₂ b₂) :
    QuotLike.liftOn₂ (⟦a⟧ : Qa) (⟦b⟧ : Qb) f h = f a b := by
  simp

/-- Map a function `f : α → β → γ` that sends equivalent elements to equivalent elements to a
function `f : Qa → Qb → Qc`. -/
protected def map₂ [IsRefl α ra] [IsRefl β rb] (f : α → β → γ)
    (h : (ra ⇒ rb ⇒ rc) f f) : Qa → Qb → Qc :=
  (QuotLike.lift₂ fun x y ↦ ⟦f x y⟧) fun _ _ _ _ ↦ (QuotLike.sound <| h · ·)

@[simp]
theorem map₂_mkQ [IsRefl α ra] [IsRefl β rb] (f : α → β → γ) (h : (ra ⇒ rb ⇒ rc) f f)
    (a : α) (b : β) :
    QuotLike.map₂ f h (⟦a⟧ : Qa) (⟦b⟧ : Qb) = (⟦f a b⟧ : Qc) := by
  simp [QuotLike.map₂]

@[elab_as_elim]
protected theorem ind₂ {motive : Qa → Qb → Prop}
    (h : (a : α) → (b : β) → motive ⟦a⟧ ⟦b⟧)
    (qa : Qa) (qb : Qb) :
    motive qa qb :=
  QuotLike.ind (QuotLike.ind h qa) qb

@[elab_as_elim]
protected theorem inductionOn₂ {motive : Qa → Qb → Prop}
    (qa : Qa) (qb : Qb)
    (h : (a : α) → (b : β) → motive ⟦a⟧ ⟦b⟧) :
    motive qa qb :=
  QuotLike.ind₂ h qa qb

/-- A binary version of `Quot.recOnSubsingleton`. -/
@[elab_as_elim]
protected def recOnSubsingleton₂ {motive : Qa → Qb → Sort*}
    [_h : ∀ a b, Subsingleton (motive ⟦a⟧ ⟦b⟧)]
    (qa : Qa) (qb : Qb) (f : ∀ a b, motive ⟦a⟧ ⟦b⟧) :
    motive qa qb :=
  QuotLike.recOnSubsingleton (_h := fun _ ↦ QuotLike.ind inferInstance qb) qa
    fun a ↦ QuotLike.recOnSubsingleton qb fun b ↦ f a b

/-- Recursion on two `QuotLike` arguments `qa` and `qb`, result type depends on `⟦a⟧` and `⟦b⟧`. -/
@[elab_as_elim]
protected def hrecOn₂ [IsRefl α ra] [IsRefl β rb] {motive : Qa → Qb → Sort*}
    (qa : Qa) (qb : Qb) (f : ∀ a b, motive ⟦a⟧ ⟦b⟧)
    (h : ∀ a₁ b₁ a₂ b₂, ra a₁ a₂ → rb b₁ b₂ → HEq (f a₁ b₁) (f a₂ b₂)) :
    motive qa qb :=
  QuotLike.hrecOn qa
    (fun a ↦ QuotLike.hrecOn qb (f a) (fun b₁ b₂ pb ↦ h _ _ _ _ (refl _) pb))
    fun a₁ a₂ pa ↦ by exact QuotLike.inductionOn qb fun b ↦ by simp [h, pa, refl]

@[simp]
theorem hrecOn₂_mkQ [IsRefl α ra] [IsRefl β rb] {motive : Qa → Qb → Sort*}
    (a : α) (b : β) (f : ∀ a b, motive ⟦a⟧ ⟦b⟧)
    (h : ∀ a₁ b₁ a₂ b₂, ra a₁ a₂ → rb b₁ b₂ → HEq (f a₁ b₁) (f a₂ b₂)) :
    QuotLike.hrecOn₂ (motive := motive) ⟦a⟧ ⟦b⟧ f h = f a b := by
  simp [QuotLike.hrecOn₂]

@[elab_as_elim]
protected theorem ind₃ {motive : Qa → Qb → Qc → Prop}
    (h : (a : α) → (b : β) → (c : γ) → motive ⟦a⟧ ⟦b⟧ ⟦c⟧)
    (qa : Qa) (qb : Qb) (qc : Qc) :
    motive qa qb qc :=
  QuotLike.ind (QuotLike.ind₂ h qa qb) qc

@[elab_as_elim]
protected theorem inductionOn₃ {motive : Qa → Qb → Qc → Prop}
    (qa : Qa) (qb : Qb) (qc : Qc)
    (h : (a : α) → (b : β) → (c : γ) → motive ⟦a⟧ ⟦b⟧ ⟦c⟧) :
    motive qa qb qc :=
  QuotLike.ind₃ h qa qb qc

end

section

variable {Q α : Sort*} {r : α → α → Prop} [QuotLike Q α r]

/-- Makes a quotient from `Quot r`. -/
def ofQuot : Quot r → Q :=
  Quot.lift mkQ fun _ _ ↦ sound

@[simp]
theorem ofQuot_toQuot (q : Q) : ofQuot (toQuot q) = q :=
  ind (fun a ↦ by rw [toQuot_mkQ, ofQuot]) q

@[simp]
theorem toQuot_ofQuot (q : Quot r) : toQuot (ofQuot q : Q) = q :=
  Quot.ind (β := fun q ↦ toQuot (ofQuot q) = q) toQuot_mkQ q

theorem toQuot_injective : Function.Injective (toQuot (Q := Q)) :=
  Function.LeftInverse.injective ofQuot_toQuot

theorem eq_iff_quotMk {a b : α} : (⟦a⟧ : Q) = ⟦b⟧ ↔ Quot.mk r a = Quot.mk r b := by
  rw [← toQuot_mkQ (Q := Q), ← toQuot_mkQ (Q := Q), toQuot_injective.eq_iff]

theorem Quot.exact {α r} [IsEquiv α r] {a b : α} : Quot.mk r a = Quot.mk r b → r a b :=
  Quotient.exact (s := ⟨r, refl, symm, _root_.trans⟩)

theorem exact [IsEquiv α r] {a b : α} : (⟦a⟧ : Q) = ⟦b⟧ → r a b :=
  fun h ↦ Quot.exact (eq_iff_quotMk.mp h)

@[simp]
theorem eq [IsEquiv α r] {a b : α} : (⟦a⟧ : Q) = ⟦b⟧ ↔ r a b :=
  ⟨exact, sound⟩

alias mkQ_eq_mkQ := eq

protected theorem «forall» {p : Q → Prop} : (∀ q, p q) ↔ ∀ a, p ⟦a⟧ :=
  ⟨fun h _ ↦ h _, QuotLike.ind⟩

protected theorem «exists» {p : Q → Prop} : (∃ q, p q) ↔ ∃ a, p ⟦a⟧ :=
  ⟨fun ⟨q, hq⟩ ↦ QuotLike.ind .intro q hq, fun ⟨a, ha⟩ ↦ ⟨⟦a⟧, ha⟩⟩

instance (priority := 800) [Nonempty α] : Nonempty Q :=
  Nonempty.map mkQ ‹_›

instance (priority := 800) [Inhabited α] : Inhabited Q :=
  ⟨⟦default⟧⟩

instance (priority := 800) [Subsingleton α] : Subsingleton Q where
  allEq := QuotLike.ind₂ fun x y ↦ congrArg mkQ (Subsingleton.elim x y)

instance (priority := 800) [Unique α] : Unique Q := Unique.mk' _

instance (priority := 800) [IsEquiv α r] [dec : DecidableRel r] : DecidableEq Q :=
  fun q₁ q₂ ↦ QuotLike.recOnSubsingleton₂ q₁ q₂ fun a₁ a₂ ↦
    match dec a₁ a₂ with
    | isTrue  h₁ => isTrue (QuotLike.sound h₁)
    | isFalse h₂ => isFalse (fun h ↦ absurd (QuotLike.exact h) h₂)

theorem mkQ_surjective :
    Function.Surjective (mkQ (Q := Q)) :=
  QuotLikeStruct.mkQ_surjective

@[simp]
theorem lift_surjective {β : Sort*} {f : α → β} {h : ∀ a b, r a b → f a = f b} :
    Function.Surjective (QuotLike.lift f h : Q → β) ↔ Function.Surjective f :=
  ⟨fun hf => by simpa only [lift_mkQ, Function.comp_def] using hf.comp QuotLike.exists_rep,
    fun hf y => let ⟨x, hx⟩ := hf y; ⟨mkQ x, by simpa only [lift_mkQ] using hx⟩⟩

@[simp]
lemma liftOn_surjective {β : Sort*} {f : α → β} {h : ∀ a b, r a b → f a = f b} :
    Function.Surjective (fun x : Q ↦ QuotLike.liftOn x f h) ↔ Function.Surjective f :=
  lift_surjective

@[simp]
theorem lift_comp_mkQ {β : Sort*} {f : α → β} (h : ∀ a b, r a b → f a = f b) :
    (QuotLike.lift f h : Q → β) ∘ mkQ = f :=
  funext <| QuotLike.lift_mkQ f h

instance (priority := 800) (f : α → Prop) [hf : DecidablePred f] (h : ∀ a b, r a b → f a = f b) :
    DecidablePred (QuotLike.lift f h : Q → Prop) :=
  fun q ↦ QuotLike.recOnSubsingleton q fun _ ↦ by simpa using hf _

instance (priority := 800)
    {Qa α : Sort*} {ra : α → α → Prop} [QuotLike Qa α ra] [IsRefl α ra]
    {Qb β : Sort*} {rb : β → β → Prop} [QuotLike Qb β rb] [IsRefl β rb]
    (f : α → β → Prop) [hf : ∀ a, DecidablePred (f a)]
    (h : ∀ a₁ b₁ a₂ b₂, ra a₁ a₂ → rb b₁ b₂ → f a₁ b₁ = f a₂ b₂)
    (qa : Qa) (qb : Qb) :
    Decidable (QuotLike.lift₂ f h qa qb) :=
  QuotLike.recOnSubsingleton₂ qa qb fun _ _ ↦ by simpa using hf _ _

/-- Choose an element of the equivalence class using the axiom of choice. -/
noncomputable def out (q : Q) : α :=
  Classical.choose (exists_rep q)

@[simp]
theorem mkQ_out (q : Q) : ⟦QuotLike.out q⟧ = q :=
  Classical.choose_spec (exists_rep q)

theorem mkQ_eq_iff_out [IsEquiv α r] {x : α} {y : Q} :
    ⟦x⟧ = y ↔ r x (out y) := by
  rw [← eq (Q := Q), mkQ_out]

theorem eq_mkQ_iff_out [IsEquiv α r] {x : Q} {y : α} :
    x = ⟦y⟧ ↔ r (out x) y := by
  rw [← eq (Q := Q), mkQ_out]

variable (Q) in
theorem out_mkQ_rel [IsEquiv α r] (a : α) : r (out (⟦a⟧ : Q)) a :=
  exact (mkQ_out _)

variable (Q) in
theorem rel_out_mkQ [IsEquiv α r] (a : α) : r a (out (⟦a⟧ : Q)) :=
  exact (mkQ_out _).symm

variable (Q) in
theorem out_rel_out [IsEquiv α r] {x y : Q} : r (out x) (out y) ↔ x = y := by
  rw [← eq_mkQ_iff_out (Q := Q), mkQ_out]

theorem out_injective [IsEquiv α r] : Function.Injective (QuotLike.out : Q → α) :=
  fun _ _ h ↦ out_rel_out _ |>.1 <| h ▸ refl _

@[simp]
theorem out_inj {x y : Q} [IsEquiv α r] : out x = out y ↔ x = y :=
  ⟨fun h ↦ out_injective h, fun h ↦ h ▸ rfl⟩

@[elab_as_elim]
theorem inductionOnPi {ι : Sort*} {Q : ι → Sort*} {α : ι → Sort*}
    {r : (i : ι) → α i → α i → Prop} [∀ i, QuotLike (Q i) (α i) (r i)]
    {p : (∀ i, Q i) → Prop} (q : ∀ i, Q i)
    (h : ∀ a : ∀ i, α i, p fun i ↦ ⟦a i⟧) : p q := by
  rw [← (funext fun i ↦ QuotLike.mkQ_out (q i) : (fun i ↦ ⟦out (q i)⟧) = q)]
  apply h

theorem nonempty_quotient_iff (s : Setoid α) : Nonempty (Quotient s) ↔ Nonempty α :=
  ⟨fun ⟨a⟩ ↦ Quotient.inductionOn a Nonempty.intro, fun ⟨a⟩ ↦ ⟨⟦a⟧⟩⟩

end

end QuotLike

export QuotLike (mkQ_eq_mkQ)
