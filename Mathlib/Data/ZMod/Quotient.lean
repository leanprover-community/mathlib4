/-
Copyright (c) 2021 Anne Baanen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anne Baanen
-/
import Mathlib.Data.ZMod.Basic
import Mathlib.GroupTheory.GroupAction.Quotient
import Mathlib.RingTheory.Int.Basic
import Mathlib.RingTheory.Ideal.QuotientOperations
import Mathlib.Algebra.Hom.Equiv.TypeTags

#align_import data.zmod.quotient from "leanprover-community/mathlib"@"da420a8c6dd5bdfb85c4ced85c34388f633bc6ff"

/-!
# `ZMod n` and quotient groups / rings

This file relates `ZMod n` to the quotient group
`‚Ñ§ / AddSubgroup.zmultiples (n : ‚Ñ§)` and to the quotient ring
`‚Ñ§ ‚ß∏ Ideal.span {(n : ‚Ñ§)}`.

## Main definitions

 - `ZMod.quotientZmultiplesNatEquivZMod` and `ZMod.quotientZmultiplesEquivZMod`:
   `ZMod n` is the group quotient of `‚Ñ§` by `n ‚Ñ§ := AddSubgroup.zmultiples (n)`,
   (where `n : ‚Ñï` and `n : ‚Ñ§` respectively)
 - `ZMod.quotient_span_nat_equiv_zmod` and `ZMod.quotientSpanEquivZMod `:
   `ZMod n` is the ring quotient of `‚Ñ§` by `n ‚Ñ§ : Ideal.span {n}`
   (where `n : ‚Ñï` and `n : ‚Ñ§` respectively)
 - `ZMod.lift n f` is the map from `ZMod n` induced by `f : ‚Ñ§ ‚Üí+ A` that maps `n` to `0`.

## Tags

zmod, quotient group, quotient ring, ideal quotient
-/


open QuotientAddGroup

open ZMod

variable (n : ‚Ñï) {A R : Type*} [AddGroup A] [Ring R]

namespace Int

/-- `‚Ñ§` modulo multiples of `n : ‚Ñï` is `ZMod n`. -/
def quotientZmultiplesNatEquivZMod : ‚Ñ§ ‚ß∏ AddSubgroup.zmultiples (n : ‚Ñ§) ‚âÉ+ ZMod n :=
  (quotientAddEquivOfEq (ZMod.ker_int_castAddHom _)).symm.trans <|
    quotientKerEquivOfRightInverse (Int.castAddHom (ZMod n)) (‚Üë) int_cast_zmod_cast
#align int.quotient_zmultiples_nat_equiv_zmod Int.quotientZmultiplesNatEquivZMod

/-- `‚Ñ§` modulo multiples of `a : ‚Ñ§` is `ZMod a.nat_abs`. -/
def quotientZmultiplesEquivZMod (a : ‚Ñ§) : ‚Ñ§ ‚ß∏ AddSubgroup.zmultiples a ‚âÉ+ ZMod a.natAbs :=
  (quotientAddEquivOfEq (zmultiples_natAbs a)).symm.trans (quotientZmultiplesNatEquivZMod a.natAbs)
#align int.quotient_zmultiples_equiv_zmod Int.quotientZmultiplesEquivZMod

/-- `‚Ñ§` modulo the ideal generated by `n : ‚Ñï` is `ZMod n`. -/
def quotientSpanNatEquivZMod : ‚Ñ§ ‚ß∏ Ideal.span {(n : ‚Ñ§)} ‚âÉ+* ZMod n :=
  (Ideal.quotEquivOfEq (ZMod.ker_int_castRingHom _)).symm.trans <|
    RingHom.quotientKerEquivOfRightInverse <|
      show Function.RightInverse (‚Üë) (Int.castRingHom (ZMod n)) from int_cast_zmod_cast
#align int.quotient_span_nat_equiv_zmod Int.quotientSpanNatEquivZMod

/-- `‚Ñ§` modulo the ideal generated by `a : ‚Ñ§` is `ZMod a.nat_abs`. -/
def quotientSpanEquivZMod (a : ‚Ñ§) : ‚Ñ§ ‚ß∏ Ideal.span ({a} : Set ‚Ñ§) ‚âÉ+* ZMod a.natAbs :=
  (Ideal.quotEquivOfEq (span_natAbs a)).symm.trans (quotientSpanNatEquivZMod a.natAbs)
#align int.quotient_span_equiv_zmod Int.quotientSpanEquivZMod

end Int

namespace AddAction

open AddSubgroup AddMonoidHom AddEquiv Function

variable {Œ± Œ≤ : Type*} [AddGroup Œ±] (a : Œ±) [AddAction Œ± Œ≤] (b : Œ≤)

/-- The quotient `(‚Ñ§ ‚àô a) ‚ß∏ (stabilizer b)` is cyclic of order `minimalPeriod ((+·µ•) a) b`. -/
noncomputable def zmultiplesQuotientStabilizerEquiv :
    zmultiples a ‚ß∏ stabilizer (zmultiples a) b ‚âÉ+ ZMod (minimalPeriod ((¬∑ +·µ• ¬∑) a) b) :=
  (ofBijective
          (map _ (stabilizer (zmultiples a) b) (zmultiplesHom (zmultiples a) ‚ü®a, mem_zmultiples a‚ü©)
            (by
              rw [zmultiples_le, mem_comap, mem_stabilizer_iff, zmultiplesHom_apply, coe_nat_zsmul]
              -- ‚ä¢ minimalPeriod ((fun x x_1 => x +·µ• x_1) a) b ‚Ä¢ { val := a, property := (_ : a ‚Ä¶
              simp_rw [‚Üê vadd_iterate]
              -- ‚ä¢ (fun x => { val := a, property := (_ : a ‚àà zmultiples a) } +·µ• x)^[minimalPer ‚Ä¶
              exact isPeriodicPt_minimalPeriod ((¬∑ +·µ• ¬∑) a) b))
              -- üéâ no goals
          ‚ü®by
            rw [‚Üê ker_eq_bot_iff, eq_bot_iff]
            -- ‚ä¢ ker (QuotientAddGroup.map (zmultiples ‚Üë(minimalPeriod ((fun x x_1 => x +·µ• x_ ‚Ä¶
            refine' fun q => induction_on' q fun n hn => _
            -- ‚ä¢ ‚Üën ‚àà ‚ä•
            rw [mem_bot, eq_zero_iff, Int.mem_zmultiples_iff, ‚Üê
              zsmul_vadd_eq_iff_minimalPeriod_dvd]
            exact (eq_zero_iff _).mp hn, fun q =>
            -- üéâ no goals
            induction_on' q fun ‚ü®_, n, rfl‚ü© => ‚ü®n, rfl‚ü©‚ü©).symm.trans
    (Int.quotientZmultiplesNatEquivZMod (minimalPeriod ((¬∑ +·µ• ¬∑) a) b))
#align add_action.zmultiples_quotient_stabilizer_equiv AddAction.zmultiplesQuotientStabilizerEquiv

theorem zmultiplesQuotientStabilizerEquiv_symm_apply (n : ZMod (minimalPeriod ((¬∑ +·µ• ¬∑) a) b)) :
    (zmultiplesQuotientStabilizerEquiv a b).symm n =
      (n : ‚Ñ§) ‚Ä¢ (‚ü®a, mem_zmultiples a‚ü© : zmultiples a) :=
  rfl
#align add_action.zmultiples_quotient_stabilizer_equiv_symm_apply AddAction.zmultiplesQuotientStabilizerEquiv_symm_apply

end AddAction

namespace MulAction

open AddAction Subgroup AddSubgroup Function

variable {Œ± Œ≤ : Type*} [Group Œ±] (a : Œ±) [MulAction Œ± Œ≤] (b : Œ≤)

/-- The quotient `(a ^ ‚Ñ§) ‚ß∏ (stabilizer b)` is cyclic of order `minimalPeriod ((‚Ä¢) a) b`. -/
noncomputable def zpowersQuotientStabilizerEquiv :
    zpowers a ‚ß∏ stabilizer (zpowers a) b ‚âÉ* Multiplicative (ZMod (minimalPeriod ((¬∑ ‚Ä¢ ¬∑) a) b)) :=
  letI f := zmultiplesQuotientStabilizerEquiv (Additive.ofMul a) b
  AddEquiv.toMultiplicative f
#align mul_action.zpowers_quotient_stabilizer_equiv MulAction.zpowersQuotientStabilizerEquiv

theorem zpowersQuotientStabilizerEquiv_symm_apply (n : ZMod (minimalPeriod ((¬∑ ‚Ä¢ ¬∑) a) b)) :
    (zpowersQuotientStabilizerEquiv a b).symm n = (‚ü®a, mem_zpowers a‚ü© : zpowers a) ^ (n : ‚Ñ§) :=
  rfl
#align mul_action.zpowers_quotient_stabilizer_equiv_symm_apply MulAction.zpowersQuotientStabilizerEquiv_symm_apply

/-- The orbit `(a ^ ‚Ñ§) ‚Ä¢ b` is a cycle of order `minimalPeriod ((‚Ä¢) a) b`. -/
noncomputable def orbitZpowersEquiv : orbit (zpowers a) b ‚âÉ ZMod (minimalPeriod ((¬∑ ‚Ä¢ ¬∑) a) b) :=
  (orbitEquivQuotientStabilizer _ b).trans (zpowersQuotientStabilizerEquiv a b).toEquiv
#align mul_action.orbit_zpowers_equiv MulAction.orbitZpowersEquiv

/-- The orbit `(‚Ñ§ ‚Ä¢ a) +·µ• b` is a cycle of order `minimalPeriod ((+·µ•) a) b`. -/
noncomputable def _root_.AddAction.orbitZmultiplesEquiv {Œ± Œ≤ : Type*} [AddGroup Œ±] (a : Œ±)
    [AddAction Œ± Œ≤] (b : Œ≤) :
    AddAction.orbit (zmultiples a) b ‚âÉ ZMod (minimalPeriod ((¬∑ +·µ• ¬∑) a) b) :=
  (AddAction.orbitEquivQuotientStabilizer (zmultiples a) b).trans
    (zmultiplesQuotientStabilizerEquiv a b).toEquiv
#align add_action.orbit_zmultiples_equiv AddAction.orbitZmultiplesEquiv

attribute [to_additive existing AddAction.orbitZmultiplesEquiv] orbitZpowersEquiv

@[to_additive orbit_zmultiples_equiv_symm_apply]
theorem orbitZpowersEquiv_symm_apply (k : ZMod (minimalPeriod ((¬∑ ‚Ä¢ ¬∑) a) b)) :
    (orbitZpowersEquiv a b).symm k =
      (‚ü®a, mem_zpowers a‚ü© : zpowers a) ^ (k : ‚Ñ§) ‚Ä¢ ‚ü®b, mem_orbit_self b‚ü© :=
  rfl
#align mul_action.orbit_zpowers_equiv_symm_apply MulAction.orbitZpowersEquiv_symm_apply
#align add_action.orbit_zmultiples_equiv_symm_apply AddAction.orbit_zmultiples_equiv_symm_apply

theorem orbitZpowersEquiv_symm_apply' (k : ‚Ñ§) :
    (orbitZpowersEquiv a b).symm k =
      (‚ü®a, mem_zpowers a‚ü© : zpowers a) ^ k ‚Ä¢ ‚ü®b, mem_orbit_self b‚ü© := by
  rw [orbitZpowersEquiv_symm_apply, ZMod.coe_int_cast]
  -- ‚ä¢ { val := a, property := (_ : a ‚àà zpowers a) } ^ (k % ‚Üë(minimalPeriod ((fun x ‚Ä¶
  exact Subtype.ext (zpow_smul_mod_minimalPeriod _ _ k)
  -- üéâ no goals
#align mul_action.orbit_zpowers_equiv_symm_apply' MulAction.orbitZpowersEquiv_symm_apply'

theorem _root_.AddAction.orbitZmultiplesEquiv_symm_apply' {Œ± Œ≤ : Type*} [AddGroup Œ±] (a : Œ±)
    [AddAction Œ± Œ≤] (b : Œ≤) (k : ‚Ñ§) :
    (AddAction.orbitZmultiplesEquiv a b).symm k =
      k ‚Ä¢ (‚ü®a, mem_zmultiples a‚ü© : zmultiples a) +·µ• ‚ü®b, AddAction.mem_orbit_self b‚ü© := by
  rw [AddAction.orbit_zmultiples_equiv_symm_apply, ZMod.coe_int_cast]
  -- ‚ä¢ (k % ‚Üë(minimalPeriod ((fun x x_1 => x +·µ• x_1) a) b)) ‚Ä¢ { val := a, property  ‚Ä¶
  -- porting note: times out without `a b` explicit
  exact Subtype.ext (zsmul_vadd_mod_minimalPeriod a b k)
  -- üéâ no goals
#align add_action.orbit_zmultiples_equiv_symm_apply' AddAction.orbitZmultiplesEquiv_symm_apply'

attribute [to_additive existing AddAction.orbitZmultiplesEquiv_symm_apply']
  orbitZpowersEquiv_symm_apply'

@[to_additive]
theorem minimalPeriod_eq_card [Fintype (orbit (zpowers a) b)] :
    minimalPeriod ((¬∑ ‚Ä¢ ¬∑) a) b = Fintype.card (orbit (zpowers a) b) := by
  -- porting note: added `(_)` to find `Fintype` by unification
  rw [‚Üê Fintype.ofEquiv_card (orbitZpowersEquiv a b), @ZMod.card _ (_)]
  -- üéâ no goals
#align mul_action.minimal_period_eq_card MulAction.minimalPeriod_eq_card
#align add_action.minimal_period_eq_card AddAction.minimalPeriod_eq_card

@[to_additive]
instance minimalPeriod_pos [Finite <| orbit (zpowers a) b] :
    NeZero <| minimalPeriod ((¬∑ ‚Ä¢ ¬∑) a) b :=
  ‚ü®by
    cases nonempty_fintype (orbit (zpowers a) b)
    -- ‚ä¢ minimalPeriod ((fun x x_1 => x ‚Ä¢ x_1) a) b ‚â† 0
    haveI : Nonempty (orbit (zpowers a) b) := (orbit_nonempty b).to_subtype
    -- ‚ä¢ minimalPeriod ((fun x x_1 => x ‚Ä¢ x_1) a) b ‚â† 0
    rw [minimalPeriod_eq_card]
    -- ‚ä¢ Fintype.card ‚Üë(orbit { x // x ‚àà zpowers a } b) ‚â† 0
    exact Fintype.card_ne_zero‚ü©
    -- üéâ no goals
#align mul_action.minimal_period_pos MulAction.minimalPeriod_pos
#align add_action.minimal_period_pos AddAction.minimalPeriod_pos

end MulAction

section Group

open Subgroup

variable {Œ± : Type*} [Group Œ±] (a : Œ±)

/-- See also `orderOf_eq_card_zpowers`. -/
@[to_additive add_order_eq_card_zmultiples' "See also `add_order_eq_card_zmultiples`."]
theorem order_eq_card_zpowers' : orderOf a = Nat.card (zpowers a) := by
  have := Nat.card_congr (MulAction.orbitZpowersEquiv a (1 : Œ±))
  -- ‚ä¢ orderOf a = Nat.card { x // x ‚àà zpowers a }
  rwa [Nat.card_zmod, orbit_subgroup_one_eq_self, eq_comm] at this
  -- üéâ no goals
#align order_eq_card_zpowers' order_eq_card_zpowers'
#align add_order_eq_card_zmultiples' add_order_eq_card_zmultiples'

variable {a}

@[to_additive IsOfFinAddOrder.finite_zmultiples]
theorem IsOfFinOrder.finite_zpowers (h : IsOfFinOrder a) : Finite <| zpowers a := by
  rw [‚Üê orderOf_pos_iff, order_eq_card_zpowers'] at h
  -- ‚ä¢ Finite { x // x ‚àà zpowers a }
  exact Nat.finite_of_card_ne_zero h.ne.symm
  -- üéâ no goals
#align is_of_fin_order.finite_zpowers IsOfFinOrder.finite_zpowers
#align is_of_fin_add_order.finite_zmultiples IsOfFinAddOrder.finite_zmultiples

end Group
