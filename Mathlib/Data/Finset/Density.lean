/-
Copyright (c) 2023 Ya√´l Dillies. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Ya√´l Dillies
-/
import Mathlib.Algebra.Order.Field.Basic
import Mathlib.Algebra.Order.Field.Rat
import Mathlib.Data.Fintype.Card

/-!
# Density of a finite set

This defines the density of a `Finset` and provides induction principles for finsets.

## Main declarations

* `Finset.dens s`: Density of `s : Finset Œ±` in `Œ±` as a nonnegative rational number.

## Implementation notes

There are many other ways to talk about the density of a finset and provide its API:
1. Use the uniform measure
2. Define finitely additive functions and generalise the `Finset.card` API to it. This could either
  be done with
  a. A structure `FinitelyAdditiveFun`
  b. A typeclass `IsFinitelyAdditiveFun`

Solution 1 would mean importing measure theory in simple files (not necessarily bad, but not
amazing), and every single API lemma would require the user to prove that all the sets they are
talking about are measurable in the trivial sigma-algebra (quite terrible user experience).

Solution 2 would mean that some API lemmas about density don't contain `dens` in their name because
they are general results about finitely additive functions. But not all lemmas would be like that
either since some really are `dens`-specific. Hence the user would need to think about whether the
lemma they are looking for is generally true for finitely additive measure or whether it is
`dens`-specific.

On top of this, solution 2.a would break dot notation on `Finset.dens` (possibly fixable by
introducing notation for `‚áëFinset.dens`) and solution 2.b would run the risk of being bad
performance-wise.

These considerations more generally apply to `Finset.card` and `Finset.sum` and demonstrate that
overengineering basic definitions is likely to hinder user experience.
-/

-- TODO
-- assert_not_exists Ring

open Function Multiset Nat

variable {ùïú Œ± Œ≤ : Type*} [Fintype Œ±]

namespace Finset
variable {s t : Finset Œ±} {a b : Œ±}

/-- Density of a finset.

`dens s` is the number of elements of `s` divided by the size of the ambient type `Œ±`. -/
def dens (s : Finset Œ±) : ‚Ñö‚â•0 := s.card / Fintype.card Œ±

lemma dens_eq_card_div_card (s : Finset Œ±) : dens s = s.card / Fintype.card Œ± := rfl

@[simp] lemma dens_empty : dens (‚àÖ : Finset Œ±) = 0 := by simp [dens]

@[simp] lemma dens_singleton (a : Œ±) : dens ({a} : Finset Œ±) = (Fintype.card Œ± : ‚Ñö‚â•0)‚Åª¬π := by
  simp [dens]

@[simp] lemma dens_cons (h : a ‚àâ s) : (s.cons a h).dens = dens s + (Fintype.card Œ± : ‚Ñö‚â•0)‚Åª¬π := by
  simp [dens, add_div]

@[simp] lemma dens_disjUnion (s t : Finset Œ±) (h) : dens (s.disjUnion t h) = dens s + dens t := by
  simp_rw [dens, card_disjUnion, Nat.cast_add, add_div]

@[simp] lemma dens_eq_zero : dens s = 0 ‚Üî s = ‚àÖ := by
  simp (config := { contextual := true }) [dens, Fintype.card_eq_zero_iff, eq_empty_of_isEmpty]

lemma dens_ne_zero : dens s ‚â† 0 ‚Üî s.Nonempty := dens_eq_zero.not.trans nonempty_iff_ne_empty.symm

@[simp] lemma dens_pos : 0 < dens s ‚Üî s.Nonempty := pos_iff_ne_zero.trans dens_ne_zero

protected alias ‚ü®_, Nonempty.dens_pos‚ü© := dens_pos
protected alias ‚ü®_, Nonempty.dens_ne_zero‚ü© := dens_ne_zero

lemma dens_le_dens (h : s ‚äÜ t) : dens s ‚â§ dens t :=
  div_le_div_of_nonneg_right (mod_cast card_mono h) $ by positivity

lemma dens_lt_dens (h : s ‚äÇ t) : dens s < dens t :=
  div_lt_div_of_pos_right (mod_cast card_strictMono h) $ by
    cases isEmpty_or_nonempty Œ±
    ¬∑ simp [Subsingleton.elim s t, ssubset_irrfl] at h
    ¬∑ exact mod_cast Fintype.card_pos

@[mono] lemma dens_mono : Monotone (dens : Finset Œ± ‚Üí ‚Ñö‚â•0) := fun _ _ ‚Ü¶ dens_le_dens
@[mono] lemma dens_strictMono : StrictMono (dens : Finset Œ± ‚Üí ‚Ñö‚â•0) := fun _ _ ‚Ü¶ dens_lt_dens

lemma dens_map_le [Fintype Œ≤] (f : Œ± ‚Ü™ Œ≤) : dens (s.map f) ‚â§ dens s := by
  cases isEmpty_or_nonempty Œ±
  ¬∑ simp [Subsingleton.elim s ‚àÖ]
  simp_rw [dens, card_map]
  gcongr
  ¬∑ positivity
  ¬∑ exact mod_cast Fintype.card_pos
  ¬∑ exact Fintype.card_le_of_injective _ f.2

section Nonempty
variable [Nonempty Œ±]

@[simp] lemma dens_univ : dens (univ : Finset Œ±) = 1 := by simp [dens, card_univ]

@[simp] lemma dens_eq_one : dens s = 1 ‚Üî s = univ := by
  simp [dens, div_eq_one_iff_eq, card_eq_iff_eq_univ]

lemma dens_ne_one : dens s ‚â† 1 ‚Üî s ‚â† univ := dens_eq_one.not

end Nonempty

section Lattice
variable [DecidableEq Œ±]

lemma dens_union_add_dens_inter (s t : Finset Œ±) :
    dens (s ‚à™ t) + dens (s ‚à© t) = dens s + dens t := by
  simp_rw [dens, ‚Üê add_div, ‚Üê Nat.cast_add, card_union_add_card_inter]

lemma dens_inter_add_dens_union (s t : Finset Œ±) :
    dens (s ‚à© t) + dens (s ‚à™ t) = dens s + dens t := by rw [add_comm, dens_union_add_dens_inter]

@[simp] lemma dens_union_of_disjoint (h : Disjoint s t) : dens (s ‚à™ t) = dens s + dens t := by
  rw [‚Üê disjUnion_eq_union s t h, dens_disjUnion _ _ _]

lemma dens_sdiff_add_dens_eq_dens (h : s ‚äÜ t) : dens (t \ s) + dens s = dens t := by
  simp [dens, ‚Üê card_sdiff_add_card_eq_card h, add_div]

lemma dens_sdiff_add_dens (s t : Finset Œ±) : dens (s \ t) + dens t = (s ‚à™ t).dens := by
  rw [‚Üê dens_union_of_disjoint sdiff_disjoint, sdiff_union_self_eq_union]

lemma dens_sdiff_comm (h : card s = card t) : dens (s \ t) = dens (t \ s) :=
  add_left_injective (dens t) $ by
    simp_rw [dens_sdiff_add_dens, union_comm s, ‚Üê dens_sdiff_add_dens, dens, h]

@[simp]
lemma dens_sdiff_add_dens_inter (s t : Finset Œ±) : dens (s \ t) + dens (s ‚à© t) = dens s := by
  rw [‚Üê dens_union_of_disjoint (disjoint_sdiff_inter _ _), sdiff_union_inter]

@[simp]
lemma dens_inter_add_dens_sdiff (s t : Finset Œ±) : dens (s ‚à© t) + dens (s \ t) = dens s := by
  rw [add_comm, dens_sdiff_add_dens_inter]

lemma dens_filter_add_dens_filter_not_eq_dens {Œ± : Type*} [Fintype Œ±] {s : Finset Œ±}
    (p : Œ± ‚Üí Prop) [DecidablePred p] [‚àÄ x, Decidable (¬¨p x)] :
    dens (s.filter p) + dens (s.filter fun a ‚Ü¶ ¬¨ p a) = dens s := by
  classical
  rw [‚Üê dens_union_of_disjoint (disjoint_filter_filter_neg ..), filter_union_filter_neg_eq]

lemma dens_union_le (s t : Finset Œ±) : dens (s ‚à™ t) ‚â§ dens s + dens t :=
  dens_union_add_dens_inter s t ‚ñ∏ le_add_of_nonneg_right zero_le'

lemma dens_le_dens_sdiff_add_dens : dens s ‚â§ dens (s \ t) + dens t :=
  dens_sdiff_add_dens s _ ‚ñ∏ dens_le_dens subset_union_left

lemma dens_sdiff (h : s ‚äÜ t) : dens (t \ s) = dens t - dens s :=
  eq_tsub_of_add_eq (dens_sdiff_add_dens_eq_dens h)

lemma le_dens_sdiff (s t : Finset Œ±) : dens t - dens s ‚â§ dens (t \ s) :=
  tsub_le_iff_right.2 dens_le_dens_sdiff_add_dens

end Lattice
end Finset
