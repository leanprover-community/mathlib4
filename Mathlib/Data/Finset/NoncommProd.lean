/-
Copyright (c) 2021 Yakov Pechersky. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yakov Pechersky
-/
import Mathlib.Data.Fintype.Card
import Mathlib.Algebra.Hom.Commute
import Mathlib.Algebra.BigOperators.Basic

#align_import data.finset.noncomm_prod from "leanprover-community/mathlib"@"509de852e1de55e1efa8eacfa11df0823f26f226"

/-!
# Products (respectively, sums) over a finset or a multiset.

The regular `Finset.prod` and `Multiset.prod` require `[CommMonoid Î±]`.
Often, there are collections `s : Finset Î±` where `[Monoid Î±]` and we know,
in a dependent fashion, that for all the terms `âˆ€ (x âˆˆ s) (y âˆˆ s), Commute x y`.
This allows to still have a well-defined product over `s`.

## Main definitions

- `Finset.noncommProd`, requiring a proof of commutativity of held terms
- `Multiset.noncommProd`, requiring a proof of commutativity of held terms

## Implementation details

While `List.prod` is defined via `List.foldl`, `noncommProd` is defined via
`Multiset.foldr` for neater proofs and definitions. By the commutativity assumption,
the two must be equal.

TODO: Tidy up this file by using the fact that the submonoid generated by commuting
elements is commutative and using the `Finset.prod` versions of lemmas to prove the `noncommProd`
version.
-/

variable {F Î¹ Î± Î² Î³ : Type*} (f : Î± â†’ Î² â†’ Î²) (op : Î± â†’ Î± â†’ Î±)

namespace Multiset

/-- Fold of a `s : Multiset Î±` with `f : Î± â†’ Î² â†’ Î²`, given a proof that `LeftCommutative f`
on all elements `x âˆˆ s`. -/
def noncommFoldr (s : Multiset Î±)
    (comm : { x | x âˆˆ s }.Pairwise fun x y => âˆ€ b, f x (f y b) = f y (f x b)) (b : Î²) : Î² :=
  s.attach.foldr (f âˆ˜ Subtype.val)
    (fun âŸ¨_, hxâŸ© âŸ¨_, hyâŸ© =>
      haveI : IsRefl Î± fun x y => âˆ€ b, f x (f y b) = f y (f x b) := âŸ¨fun _ _ => rflâŸ©
      comm.of_refl hx hy)
    b
#align multiset.noncomm_foldr Multiset.noncommFoldr

@[simp]
theorem noncommFoldr_coe (l : List Î±) (comm) (b : Î²) :
    noncommFoldr f (l : Multiset Î±) comm b = l.foldr f b := by
  simp only [noncommFoldr, coe_foldr, coe_attach, List.attach, Function.comp]
  -- âŠ¢ List.foldr (fun x => f â†‘x) b (List.pmap Subtype.mk l (_ : âˆ€ (x : Î±), x âˆˆ l â†’ â€¦
  rw [â† List.foldr_map]
  -- âŠ¢ List.foldr f b (List.map (fun x => â†‘x) (List.pmap Subtype.mk l (_ : âˆ€ (x : Î± â€¦
  simp [List.map_pmap, List.pmap_eq_map]
  -- ğŸ‰ no goals
#align multiset.noncomm_foldr_coe Multiset.noncommFoldr_coe

@[simp]
theorem noncommFoldr_empty (h) (b : Î²) : noncommFoldr f (0 : Multiset Î±) h b = b :=
  rfl
#align multiset.noncomm_foldr_empty Multiset.noncommFoldr_empty

theorem noncommFoldr_cons (s : Multiset Î±) (a : Î±) (h h') (b : Î²) :
    noncommFoldr f (a ::â‚˜ s) h b = f a (noncommFoldr f s h' b) := by
  induction s using Quotient.inductionOn
  -- âŠ¢ noncommFoldr f (a ::â‚˜ Quotient.mk (List.isSetoid Î±) aâœ) h b = f a (noncommFo â€¦
  simp
  -- ğŸ‰ no goals
#align multiset.noncomm_foldr_cons Multiset.noncommFoldr_cons

theorem noncommFoldr_eq_foldr (s : Multiset Î±) (h : LeftCommutative f) (b : Î²) :
    noncommFoldr f s (fun x _ y _ _ => h x y) b = foldr f h b s := by
  induction s using Quotient.inductionOn
  -- âŠ¢ noncommFoldr f (Quotient.mk (List.isSetoid Î±) aâœ) (_ : âˆ€ (x : Î±), x âˆˆ {x | x â€¦
  simp
  -- ğŸ‰ no goals
#align multiset.noncomm_foldr_eq_foldr Multiset.noncommFoldr_eq_foldr

section assoc

variable [assoc : IsAssociative Î± op]

/-- Fold of a `s : Multiset Î±` with an associative `op : Î± â†’ Î± â†’ Î±`, given a proofs that `op`
is commutative on all elements `x âˆˆ s`. -/
def noncommFold (s : Multiset Î±) (comm : { x | x âˆˆ s }.Pairwise fun x y => op x y = op y x) :
    Î± â†’ Î± :=
  noncommFoldr op s fun x hx y hy h b => by rw [â† assoc.assoc, comm hx hy h, assoc.assoc]
                                            -- ğŸ‰ no goals
#align multiset.noncomm_fold Multiset.noncommFold

@[simp]
theorem noncommFold_coe (l : List Î±) (comm) (a : Î±) :
    noncommFold op (l : Multiset Î±) comm a = l.foldr op a := by simp [noncommFold]
                                                                -- ğŸ‰ no goals
#align multiset.noncomm_fold_coe Multiset.noncommFold_coe

@[simp]
theorem noncommFold_empty (h) (a : Î±) : noncommFold op (0 : Multiset Î±) h a = a :=
  rfl
#align multiset.noncomm_fold_empty Multiset.noncommFold_empty

theorem noncommFold_cons (s : Multiset Î±) (a : Î±) (h h') (x : Î±) :
    noncommFold op (a ::â‚˜ s) h x = op a (noncommFold op s h' x) := by
  induction s using Quotient.inductionOn
  -- âŠ¢ noncommFold op (a ::â‚˜ Quotient.mk (List.isSetoid Î±) aâœ) h x = op a (noncommF â€¦
  simp
  -- ğŸ‰ no goals
#align multiset.noncomm_fold_cons Multiset.noncommFold_cons

theorem noncommFold_eq_fold (s : Multiset Î±) [IsCommutative Î± op] (a : Î±) :
    noncommFold op s (fun x _ y _ _ => IsCommutative.comm x y) a = fold op a s := by
  induction s using Quotient.inductionOn
  -- âŠ¢ noncommFold op (Quotient.mk (List.isSetoid Î±) aâœ) (_ : âˆ€ (x : Î±), x âˆˆ {x | x â€¦
  simp
  -- ğŸ‰ no goals
#align multiset.noncomm_fold_eq_fold Multiset.noncommFold_eq_fold

end assoc

variable [Monoid Î±] [Monoid Î²]

/-- Product of a `s : Multiset Î±` with `[Monoid Î±]`, given a proof that `*` commutes
on all elements `x âˆˆ s`. -/
@[to_additive
      "Sum of a `s : Multiset Î±` with `[AddMonoid Î±]`, given a proof that `+` commutes
      on all elements `x âˆˆ s`."]
def noncommProd (s : Multiset Î±) (comm : { x | x âˆˆ s }.Pairwise Commute) : Î± :=
  s.noncommFold (Â· * Â·) comm 1
#align multiset.noncomm_prod Multiset.noncommProd
#align multiset.noncomm_sum Multiset.noncommSum

@[to_additive (attr := simp)]
theorem noncommProd_coe (l : List Î±) (comm) : noncommProd (l : Multiset Î±) comm = l.prod := by
  rw [noncommProd]
  -- âŠ¢ noncommFold (fun x x_1 => x * x_1) (â†‘l) comm 1 = List.prod l
  simp only [noncommFold_coe]
  -- âŠ¢ List.foldr (fun x x_1 => x * x_1) 1 l = List.prod l
  induction' l with hd tl hl
  -- âŠ¢ List.foldr (fun x x_1 => x * x_1) 1 [] = List.prod []
  Â· simp
    -- ğŸ‰ no goals
  Â· rw [List.prod_cons, List.foldr, hl]
    -- âŠ¢ Set.Pairwise {x | x âˆˆ â†‘tl} Commute
    intro x hx y hy
    -- âŠ¢ x â‰  y â†’ Commute x y
    exact comm (List.mem_cons_of_mem _ hx) (List.mem_cons_of_mem _ hy)
    -- ğŸ‰ no goals
#align multiset.noncomm_prod_coe Multiset.noncommProd_coe
#align multiset.noncomm_sum_coe Multiset.noncommSum_coe

@[to_additive (attr := simp)]
theorem noncommProd_empty (h) : noncommProd (0 : Multiset Î±) h = 1 :=
  rfl
#align multiset.noncomm_prod_empty Multiset.noncommProd_empty
#align multiset.noncomm_sum_empty Multiset.noncommSum_empty

@[to_additive (attr := simp)]
theorem noncommProd_cons (s : Multiset Î±) (a : Î±) (comm) :
    noncommProd (a ::â‚˜ s) comm = a * noncommProd s (comm.mono fun _ => mem_cons_of_mem) := by
  induction s using Quotient.inductionOn
  -- âŠ¢ noncommProd (a ::â‚˜ Quotient.mk (List.isSetoid Î±) aâœ) comm = a * noncommProd  â€¦
  simp
  -- ğŸ‰ no goals
#align multiset.noncomm_prod_cons Multiset.noncommProd_cons
#align multiset.noncomm_sum_cons Multiset.noncommSum_cons

@[to_additive]
theorem noncommProd_cons' (s : Multiset Î±) (a : Î±) (comm) :
    noncommProd (a ::â‚˜ s) comm = noncommProd s (comm.mono fun _ => mem_cons_of_mem) * a := by
  induction' s using Quotient.inductionOn with s
  -- âŠ¢ noncommProd (a ::â‚˜ Quotient.mk (List.isSetoid Î±) s) comm = noncommProd (Quot â€¦
  simp only [quot_mk_to_coe, cons_coe, noncommProd_coe, List.prod_cons]
  -- âŠ¢ a * List.prod s = List.prod s * a
  induction' s with hd tl IH
  -- âŠ¢ a * List.prod [] = List.prod [] * a
  Â· simp
    -- ğŸ‰ no goals
  Â· rw [List.prod_cons, mul_assoc, â† IH, â† mul_assoc, â† mul_assoc]
    -- âŠ¢ a * hd * List.prod tl = hd * a * List.prod tl
    Â· congr 1
      -- âŠ¢ a * hd = hd * a
      apply comm.of_refl <;> simp
      -- âŠ¢ a âˆˆ {x | x âˆˆ a ::â‚˜ Quotient.mk (List.isSetoid Î±) (hd :: tl)}
                             -- ğŸ‰ no goals
                             -- ğŸ‰ no goals
    Â· intro x hx y hy
      -- âŠ¢ x â‰  y â†’ Commute x y
      simp only [quot_mk_to_coe, List.mem_cons, mem_coe, cons_coe] at hx hy
      -- âŠ¢ x â‰  y â†’ Commute x y
      apply comm
      -- âŠ¢ x âˆˆ {x | x âˆˆ a ::â‚˜ Quotient.mk (List.isSetoid Î±) (hd :: tl)}
      Â· cases hx <;> simp [*]
        -- âŠ¢ x âˆˆ {x | x âˆˆ a ::â‚˜ Quotient.mk (List.isSetoid Î±) (hd :: tl)}
                     -- ğŸ‰ no goals
                     -- ğŸ‰ no goals
      Â· cases hy <;> simp [*]
        -- âŠ¢ y âˆˆ {x | x âˆˆ a ::â‚˜ Quotient.mk (List.isSetoid Î±) (hd :: tl)}
                     -- ğŸ‰ no goals
                     -- ğŸ‰ no goals
#align multiset.noncomm_prod_cons' Multiset.noncommProd_cons'
#align multiset.noncomm_sum_cons' Multiset.noncommSum_cons'

@[to_additive]
theorem noncommProd_add (s t : Multiset Î±) (comm) :
    noncommProd (s + t) comm =
      noncommProd s (comm.mono <| subset_of_le <| s.le_add_right t) *
        noncommProd t (comm.mono <| subset_of_le <| t.le_add_left s) := by
  rcases s with âŸ¨âŸ©
  -- âŠ¢ noncommProd (Quot.mk Setoid.r aâœ + t) comm = noncommProd (Quot.mk Setoid.r a â€¦
  rcases t with âŸ¨âŸ©
  -- âŠ¢ noncommProd (Quot.mk Setoid.r aâœÂ¹ + Quot.mk Setoid.r aâœ) comm = noncommProd  â€¦
  simp
  -- ğŸ‰ no goals
#align multiset.noncomm_prod_add Multiset.noncommProd_add
#align multiset.noncomm_sum_add Multiset.noncommSum_add

@[to_additive]
protected theorem noncommProd_map_aux [MonoidHomClass F Î± Î²] (s : Multiset Î±)
    (comm : { x | x âˆˆ s }.Pairwise Commute) (f : F) : { x | x âˆˆ s.map f }.Pairwise Commute := by
  simp only [Multiset.mem_map]
  -- âŠ¢ Set.Pairwise {x | âˆƒ a, a âˆˆ s âˆ§ â†‘f a = x} Commute
  rintro _ âŸ¨x, hx, rflâŸ© _ âŸ¨y, hy, rflâŸ© _
  -- âŠ¢ Commute (â†‘f x) (â†‘f y)
  exact (comm.of_refl hx hy).map f
  -- ğŸ‰ no goals
#align multiset.noncomm_prod_map_aux Multiset.noncommProd_map_aux
#align multiset.noncomm_sum_map_aux Multiset.noncommSum_map_aux

@[to_additive]
theorem noncommProd_map [MonoidHomClass F Î± Î²] (s : Multiset Î±) (comm) (f : F) :
    f (s.noncommProd comm) = (s.map f).noncommProd (Multiset.noncommProd_map_aux s comm f) := by
  induction s using Quotient.inductionOn
  -- âŠ¢ â†‘f (noncommProd (Quotient.mk (List.isSetoid Î±) aâœ) comm) = noncommProd (map  â€¦
  simpa using map_list_prod f _
  -- ğŸ‰ no goals
#align multiset.noncomm_prod_map Multiset.noncommProd_map
#align multiset.noncomm_sum_map Multiset.noncommSum_map

@[to_additive noncommSum_eq_card_nsmul]
theorem noncommProd_eq_pow_card (s : Multiset Î±) (comm) (m : Î±) (h : âˆ€ x âˆˆ s, x = m) :
    s.noncommProd comm = m ^ Multiset.card s := by
  induction s using Quotient.inductionOn
  -- âŠ¢ noncommProd (Quotient.mk (List.isSetoid Î±) aâœ) comm = m ^ â†‘card (Quotient.mk â€¦
  simp only [quot_mk_to_coe, noncommProd_coe, coe_card, mem_coe] at *
  -- âŠ¢ List.prod aâœ = m ^ List.length aâœ
  exact List.prod_eq_pow_card _ m h
  -- ğŸ‰ no goals
#align multiset.noncomm_prod_eq_pow_card Multiset.noncommProd_eq_pow_card
#align multiset.noncomm_sum_eq_card_nsmul Multiset.noncommSum_eq_card_nsmul

@[to_additive]
theorem noncommProd_eq_prod {Î± : Type*} [CommMonoid Î±] (s : Multiset Î±) :
    (noncommProd s fun _ _ _ _ _ => Commute.all _ _) = prod s := by
  induction s using Quotient.inductionOn
  -- âŠ¢ noncommProd (Quotient.mk (List.isSetoid Î±) aâœ) (_ : âˆ€ (x : Î±), x âˆˆ {x | x âˆˆ  â€¦
  simp
  -- ğŸ‰ no goals
#align multiset.noncomm_prod_eq_prod Multiset.noncommProd_eq_prod
#align multiset.noncomm_sum_eq_sum Multiset.noncommSum_eq_sum

@[to_additive noncommSum_addCommute]
theorem noncommProd_commute (s : Multiset Î±) (comm) (y : Î±) (h : âˆ€ x âˆˆ s, Commute y x) :
    Commute y (s.noncommProd comm) := by
  induction s using Quotient.inductionOn
  -- âŠ¢ Commute y (noncommProd (Quotient.mk (List.isSetoid Î±) aâœ) comm)
  simp only [quot_mk_to_coe, noncommProd_coe]
  -- âŠ¢ Commute y (List.prod aâœ)
  exact Commute.list_prod_right _ _ h
  -- ğŸ‰ no goals
#align multiset.noncomm_prod_commute Multiset.noncommProd_commute
#align multiset.noncomm_sum_add_commute Multiset.noncommSum_addCommute

end Multiset

namespace Finset

variable [Monoid Î²] [Monoid Î³]


/-- Proof used in definition of `Finset.noncommProd` -/
@[to_additive]
theorem noncommProd_lemma (s : Finset Î±) (f : Î± â†’ Î²)
    (comm : (s : Set Î±).Pairwise fun a b => Commute (f a) (f b)) :
    Set.Pairwise { x | x âˆˆ Multiset.map f s.val } Commute := by
  simp_rw [Multiset.mem_map]
  -- âŠ¢ Set.Pairwise {x | âˆƒ a, a âˆˆ s.val âˆ§ f a = x} Commute
  rintro _ âŸ¨a, ha, rflâŸ© _ âŸ¨b, hb, rflâŸ© _
  -- âŠ¢ Commute (f a) (f b)
  exact comm.of_refl ha hb
  -- ğŸ‰ no goals

/-- Product of a `s : Finset Î±` mapped with `f : Î± â†’ Î²` with `[Monoid Î²]`,
given a proof that `*` commutes on all elements `f x` for `x âˆˆ s`. -/
@[to_additive
      "Sum of a `s : Finset Î±` mapped with `f : Î± â†’ Î²` with `[AddMonoid Î²]`,
given a proof that `+` commutes on all elements `f x` for `x âˆˆ s`."]
def noncommProd (s : Finset Î±) (f : Î± â†’ Î²)
    (comm : (s : Set Î±).Pairwise fun a b => Commute (f a) (f b)) : Î² :=
  (s.1.map f).noncommProd <| noncommProd_lemma s f comm
#align finset.noncomm_prod Finset.noncommProd
#align finset.noncomm_sum Finset.noncommSum

@[to_additive (attr := congr)]
theorem noncommProd_congr {sâ‚ sâ‚‚ : Finset Î±} {f g : Î± â†’ Î²} (hâ‚ : sâ‚ = sâ‚‚)
    (hâ‚‚ : âˆ€ x âˆˆ sâ‚‚, f x = g x) (comm) :
    noncommProd sâ‚ f comm =
      noncommProd sâ‚‚ g fun x hx y hy h => by
        dsimp only
        -- âŠ¢ Commute (g x) (g y)
        rw [â† hâ‚‚ _ hx, â† hâ‚‚ _ hy]
        -- âŠ¢ Commute (f x) (f y)
        subst hâ‚
        -- âŠ¢ Commute (f x) (f y)
        exact comm hx hy h :=
        -- ğŸ‰ no goals
  by simp_rw [noncommProd, Multiset.map_congr (congr_arg _ hâ‚) hâ‚‚]
     -- ğŸ‰ no goals
#align finset.noncomm_prod_congr Finset.noncommProd_congr
#align finset.noncomm_sum_congr Finset.noncommSum_congr

@[to_additive (attr := simp)]
theorem noncommProd_toFinset [DecidableEq Î±] (l : List Î±) (f : Î± â†’ Î²) (comm) (hl : l.Nodup) :
    noncommProd l.toFinset f comm = (l.map f).prod := by
  rw [â† List.dedup_eq_self] at hl
  -- âŠ¢ noncommProd (List.toFinset l) f comm = List.prod (List.map f l)
  simp [noncommProd, hl]
  -- ğŸ‰ no goals
#align finset.noncomm_prod_to_finset Finset.noncommProd_toFinset
#align finset.noncomm_sum_to_finset Finset.noncommSum_toFinset

@[to_additive (attr := simp)]
theorem noncommProd_empty (f : Î± â†’ Î²) (h) : noncommProd (âˆ… : Finset Î±) f h = 1 :=
  rfl
#align finset.noncomm_prod_empty Finset.noncommProd_empty
#align finset.noncomm_sum_empty Finset.noncommSum_empty

@[to_additive (attr := simp)]
theorem noncommProd_insert_of_not_mem [DecidableEq Î±] (s : Finset Î±) (a : Î±) (f : Î± â†’ Î²) (comm)
    (ha : a âˆ‰ s) :
    noncommProd (insert a s) f comm =
      f a * noncommProd s f (comm.mono fun _ => mem_insert_of_mem) :=
  calc noncommProd (insert a s) f comm
     = Multiset.noncommProd ((insert a s).val.map f) _ := rfl
   _ = Multiset.noncommProd (f a ::â‚˜ s.1.map f)
     (by convert noncommProd_lemma _ f comm using 3
         -- âŠ¢ xâœ âˆˆ f a ::â‚˜ Multiset.map f s.val â†” xâœ âˆˆ Multiset.map f (insert a s).val
         simp [@eq_comm _ (f a)]) := by
         -- ğŸ‰ no goals
       { congr
         rw [insert_val_of_not_mem ha, Multiset.map_cons] }
   _ = _ := by rw [Multiset.noncommProd_cons, noncommProd]
               -- ğŸ‰ no goals
#align finset.noncomm_prod_insert_of_not_mem Finset.noncommProd_insert_of_not_mem
#align finset.noncomm_sum_insert_of_not_mem Finset.noncommSum_insert_of_not_mem

@[to_additive]
theorem noncommProd_insert_of_not_mem' [DecidableEq Î±] (s : Finset Î±) (a : Î±) (f : Î± â†’ Î²) (comm)
    (ha : a âˆ‰ s) :
    noncommProd (insert a s) f comm =
      noncommProd s f (comm.mono fun _ => mem_insert_of_mem) * f a :=
  calc noncommProd (insert a s) f comm
     = Multiset.noncommProd ((insert a s).val.map f) _ := rfl
   _ = Multiset.noncommProd (f a ::â‚˜ s.1.map f)
     (by convert noncommProd_lemma _ f comm using 3
         -- âŠ¢ xâœ âˆˆ f a ::â‚˜ Multiset.map f s.val â†” xâœ âˆˆ Multiset.map f (insert a s).val
         simp [@eq_comm _ (f a)]) := by
         -- ğŸ‰ no goals
       { congr
         rw [insert_val_of_not_mem ha, Multiset.map_cons] }
   _ = _ := by rw [Multiset.noncommProd_cons', noncommProd]
               -- ğŸ‰ no goals
#align finset.noncomm_prod_insert_of_not_mem' Finset.noncommProd_insert_of_not_mem'
#align finset.noncomm_sum_insert_of_not_mem' Finset.noncommSum_insert_of_not_mem'

@[to_additive (attr := simp)]
theorem noncommProd_singleton (a : Î±) (f : Î± â†’ Î²) :
    noncommProd ({a} : Finset Î±) f
        (by
          norm_cast
          -- âŠ¢ Set.Pairwise {a} fun a b => Commute (f a) (f b)
          exact Set.pairwise_singleton _ _) =
          -- ğŸ‰ no goals
      f a := mul_one _
#align finset.noncomm_prod_singleton Finset.noncommProd_singleton
#align finset.noncomm_sum_singleton Finset.noncommSum_singleton

@[to_additive]
theorem noncommProd_map [MonoidHomClass F Î² Î³] (s : Finset Î±) (f : Î± â†’ Î²) (comm) (g : F) :
    g (s.noncommProd f comm) =
      s.noncommProd (fun i => g (f i)) fun x hx y hy _ => (comm.of_refl hx hy).map g :=
  by simp [noncommProd, Multiset.noncommProd_map]
     -- ğŸ‰ no goals
#align finset.noncomm_prod_map Finset.noncommProd_map
#align finset.noncomm_sum_map Finset.noncommSum_map

@[to_additive noncommSum_eq_card_nsmul]
theorem noncommProd_eq_pow_card (s : Finset Î±) (f : Î± â†’ Î²) (comm) (m : Î²) (h : âˆ€ x âˆˆ s, f x = m) :
    s.noncommProd f comm = m ^ s.card := by
  rw [noncommProd, Multiset.noncommProd_eq_pow_card _ _ m]
  -- âŠ¢ m ^ â†‘Multiset.card (Multiset.map f s.val) = m ^ card s
  simp only [Finset.card_def, Multiset.card_map]
  -- âŠ¢ âˆ€ (x : Î²), x âˆˆ Multiset.map f s.val â†’ x = m
  simpa using h
  -- ğŸ‰ no goals
#align finset.noncomm_prod_eq_pow_card Finset.noncommProd_eq_pow_card
#align finset.noncomm_sum_eq_card_nsmul Finset.noncommSum_eq_card_nsmul

@[to_additive noncommSum_addCommute]
theorem noncommProd_commute (s : Finset Î±) (f : Î± â†’ Î²) (comm) (y : Î²)
    (h : âˆ€ x âˆˆ s, Commute y (f x)) : Commute y (s.noncommProd f comm) := by
  apply Multiset.noncommProd_commute
  -- âŠ¢ âˆ€ (x : Î²), x âˆˆ Multiset.map f s.val â†’ Commute y x
  intro y
  -- âŠ¢ y âˆˆ Multiset.map f s.val â†’ Commute yâœ y
  rw [Multiset.mem_map]
  -- âŠ¢ (âˆƒ a, a âˆˆ s.val âˆ§ f a = y) â†’ Commute yâœ y
  rintro âŸ¨x, âŸ¨hx, rflâŸ©âŸ©
  -- âŠ¢ Commute y (f x)
  exact h x hx
  -- ğŸ‰ no goals
#align finset.noncomm_prod_commute Finset.noncommProd_commute
#align finset.noncomm_sum_add_commute Finset.noncommSum_addCommute

@[to_additive]
theorem noncommProd_eq_prod {Î² : Type*} [CommMonoid Î²] (s : Finset Î±) (f : Î± â†’ Î²) :
    (noncommProd s f fun _ _ _ _ _ => Commute.all _ _) = s.prod f := by
  classical
    induction' s using Finset.induction_on with a s ha IH
    Â· simp
    Â· simp [ha, IH]
#align finset.noncomm_prod_eq_prod Finset.noncommProd_eq_prod
#align finset.noncomm_sum_eq_sum Finset.noncommSum_eq_sum

/-- The non-commutative version of `Finset.prod_union` -/
@[to_additive "The non-commutative version of `finset.sum_union`"]
theorem noncommProd_union_of_disjoint [DecidableEq Î±] {s t : Finset Î±} (h : Disjoint s t)
    (f : Î± â†’ Î²) (comm : { x | x âˆˆ s âˆª t }.Pairwise fun a b => Commute (f a) (f b)) :
    noncommProd (s âˆª t) f comm =
      noncommProd s f (comm.mono <| coe_subset.2 <| subset_union_left _ _) *
        noncommProd t f (comm.mono <| coe_subset.2 <| subset_union_right _ _) := by
  obtain âŸ¨sl, sl', rflâŸ© := exists_list_nodup_eq s
  -- âŠ¢ noncommProd (List.toFinset sl âˆª t) f comm = noncommProd (List.toFinset sl) f â€¦
  obtain âŸ¨tl, tl', rflâŸ© := exists_list_nodup_eq t
  -- âŠ¢ noncommProd (List.toFinset sl âˆª List.toFinset tl) f comm = noncommProd (List â€¦
  rw [List.disjoint_toFinset_iff_disjoint] at h
  -- âŠ¢ noncommProd (List.toFinset sl âˆª List.toFinset tl) f comm = noncommProd (List â€¦
  calc noncommProd (List.toFinset sl âˆª List.toFinset tl) f comm
     = noncommProd âŸ¨â†‘(sl ++ tl), Multiset.coe_nodup.2 (sl'.append tl' h)âŸ© f
         (by convert comm; simp [Set.ext_iff]) := noncommProd_congr (by ext; simp) (by simp) _
   _ = noncommProd (List.toFinset sl) f (comm.mono <| coe_subset.2 <| subset_union_left _ _) *
         noncommProd (List.toFinset tl) f (comm.mono <| coe_subset.2 <| subset_union_right _ _) :=
    by simp [noncommProd, List.dedup_eq_self.2 sl', List.dedup_eq_self.2 tl', h]
#align finset.noncomm_prod_union_of_disjoint Finset.noncommProd_union_of_disjoint
#align finset.noncomm_sum_union_of_disjoint Finset.noncommSum_union_of_disjoint

@[to_additive]
theorem noncommProd_mul_distrib_aux {s : Finset Î±} {f : Î± â†’ Î²} {g : Î± â†’ Î²}
    (comm_ff : (s : Set Î±).Pairwise fun x y => Commute (f x) (f y))
    (comm_gg : (s : Set Î±).Pairwise fun x y => Commute (g x) (g y))
    (comm_gf : (s : Set Î±).Pairwise fun x y => Commute (g x) (f y)) :
    (s : Set Î±).Pairwise fun x y => Commute ((f * g) x) ((f * g) y) := by
  intro x hx y hy h
  -- âŠ¢ Commute ((f * g) x) ((f * g) y)
  apply Commute.mul_left <;> apply Commute.mul_right
  -- âŠ¢ Commute (f x) ((f * g) y)
                             -- âŠ¢ Commute (f x) (f y)
                             -- âŠ¢ Commute (g x) (f y)
  Â· exact comm_ff.of_refl hx hy
    -- ğŸ‰ no goals
  Â· exact (comm_gf hy hx h.symm).symm
    -- ğŸ‰ no goals
  Â· exact comm_gf hx hy h
    -- ğŸ‰ no goals
  Â· exact comm_gg.of_refl hx hy
    -- ğŸ‰ no goals
#align finset.noncomm_prod_mul_distrib_aux Finset.noncommProd_mul_distrib_aux
#align finset.noncomm_sum_add_distrib_aux Finset.noncommSum_add_distrib_aux

/-- The non-commutative version of `Finset.prod_mul_distrib` -/
@[to_additive "The non-commutative version of `Finset.sum_add_distrib`"]
theorem noncommProd_mul_distrib {s : Finset Î±} (f : Î± â†’ Î²) (g : Î± â†’ Î²) (comm_ff comm_gg comm_gf) :
    noncommProd s (f * g) (noncommProd_mul_distrib_aux comm_ff comm_gg comm_gf) =
      noncommProd s f comm_ff * noncommProd s g comm_gg := by
  classical
    induction' s using Finset.induction_on with x s hnmem ih
    Â· simp
    simp only [Finset.noncommProd_insert_of_not_mem _ _ _ _ hnmem]
    specialize
      ih (comm_ff.mono fun _ => mem_insert_of_mem) (comm_gg.mono fun _ => mem_insert_of_mem)
        (comm_gf.mono fun _ => mem_insert_of_mem)
    rw [ih, Pi.mul_apply]
    simp only [mul_assoc]
    congr 1
    simp only [â† mul_assoc]
    congr 1
    refine' noncommProd_commute _ _ _ _ fun y hy => _
    exact comm_gf (mem_insert_self x s) (mem_insert_of_mem hy) (ne_of_mem_of_not_mem hy hnmem).symm
#align finset.noncomm_prod_mul_distrib Finset.noncommProd_mul_distrib
#align finset.noncomm_sum_add_distrib Finset.noncommSum_add_distrib

section FinitePi

variable {M : Î¹ â†’ Type*} [âˆ€ i, Monoid (M i)]

@[to_additive]
theorem noncommProd_mul_single [Fintype Î¹] [DecidableEq Î¹] (x : âˆ€ i, M i) :
    (univ.noncommProd (fun i => Pi.mulSingle i (x i)) fun i _ j _ _ =>
        Pi.mulSingle_apply_commute x i j) = x := by
  ext i
  -- âŠ¢ noncommProd univ (fun i => Pi.mulSingle i (x i)) (_ : âˆ€ (i : Î¹), i âˆˆ â†‘univ â†’ â€¦
  apply (univ.noncommProd_map (fun i => MonoidHom.single M i (x i)) _ (Pi.evalMonoidHom M i)).trans
  -- âŠ¢ noncommProd univ (fun i_1 => â†‘(Pi.evalMonoidHom M i) (â†‘(MonoidHom.single M i â€¦
  refine' (noncommProd_congr (insert_erase (mem_univ i)).symm _ _).trans _
  Â· intro i _ j _ _
    -- âŠ¢ Commute ((fun i => â†‘(MonoidHom.single M i) (x i)) i) ((fun i => â†‘(MonoidHom. â€¦
    exact Pi.mulSingle_apply_commute x i j
    -- ğŸ‰ no goals
  Â· intro j
    -- âŠ¢ (fun x => M i) (noncommProd univ (fun i => â†‘(MonoidHom.single M i) (x i)) (_ â€¦
    exact Pi.mulSingle j (x j) i
    -- ğŸ‰ no goals
  Â· intro j _; dsimp
    -- âŠ¢ â†‘(Pi.evalMonoidHom M i) (â†‘(MonoidHom.single M j) (x j)) = Pi.mulSingle j (x  â€¦
               -- ğŸ‰ no goals
  Â· rw [noncommProd_insert_of_not_mem _ _ _ _ (not_mem_erase _ _),
      noncommProd_eq_pow_card (univ.erase i), one_pow, mul_one]
    simp
    -- âŠ¢ âˆ€ (x_1 : Î¹), x_1 âˆˆ erase univ i â†’ Pi.mulSingle x_1 (x x_1) i = 1
    Â· intro j hj
      -- âŠ¢ Pi.mulSingle j (x j) i = 1
      simp at hj
      -- âŠ¢ Pi.mulSingle j (x j) i = 1
      simp [Pi.mulSingle, Function.update]
      -- âŠ¢ âˆ€ (h : i = j), (_ : j = i) â–¸ x j = 1
      intro h
      -- âŠ¢ (_ : j = i) â–¸ x j = 1
      simp [*] at *
      -- ğŸ‰ no goals
#align finset.noncomm_prod_mul_single Finset.noncommProd_mul_single
#align finset.noncomm_sum_single Finset.noncommSum_single

@[to_additive]
theorem _root_.MonoidHom.pi_ext [Finite Î¹] [DecidableEq Î¹] {f g : (âˆ€ i, M i) â†’* Î³}
    (h : âˆ€ i x, f (Pi.mulSingle i x) = g (Pi.mulSingle i x)) : f = g := by
  cases nonempty_fintype Î¹
  -- âŠ¢ f = g
  ext x
  -- âŠ¢ â†‘f x = â†‘g x
  rw [â† noncommProd_mul_single x, univ.noncommProd_map, univ.noncommProd_map]
  -- âŠ¢ noncommProd univ (fun i => â†‘f (Pi.mulSingle i (x i))) (_ : âˆ€ (x_1 : Î¹), x_1  â€¦
  congr 1 with i; exact h i (x i)
  -- âŠ¢ â†‘f (Pi.mulSingle i (x i)) = â†‘g (Pi.mulSingle i (x i))
                  -- ğŸ‰ no goals
#align monoid_hom.pi_ext MonoidHom.pi_ext
#align add_monoid_hom.pi_ext AddMonoidHom.pi_ext

end FinitePi

end Finset
