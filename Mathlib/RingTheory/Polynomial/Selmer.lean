/-
Copyright (c) 2022 Thomas Browning. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Thomas Browning
-/
import Mathlib.Data.Polynomial.UnitTrinomial
import Mathlib.FieldTheory.PolynomialGaloisGroup
import Mathlib.NumberTheory.NumberField.Discriminant
import Mathlib.RingTheory.Polynomial.GaussLemma
import Mathlib.Tactic.LinearCombination

#align_import ring_theory.polynomial.selmer from "leanprover-community/mathlib"@"3e00d81bdcbf77c8188bbd18f5524ddc3ed8cac6"

/-!
# Irreducibility of Selmer Polynomials

This file proves irreducibility of the Selmer polynomials `X ^ n - X - 1`.

## Main results

- `X_pow_sub_X_sub_one_irreducible`: The Selmer polynomials `X ^ n - X - 1` are irreducible.

TODO: Show that the Selmer polynomials have full Galois group.
-/


namespace Polynomial

open scoped Polynomial

variable {n : â„•}

theorem X_pow_sub_X_sub_one_irreducible_aux (z : â„‚) : Â¬(z ^ n = z + 1 âˆ§ z ^ n + z ^ 2 = 0) := by
  rintro âŸ¨h1, h2âŸ©
  replace h3 : z ^ 3 = 1
  Â· linear_combination (1 - z - z ^ 2 - z ^ n) * h1 + (z ^ n - 2) * h2
  have key : z ^ n = 1 âˆ¨ z ^ n = z âˆ¨ z ^ n = z ^ 2 := by
    rw [â† Nat.mod_add_div n 3, pow_add, pow_mul, h3, one_pow, mul_one]
    have : n % 3 < 3 := Nat.mod_lt n zero_lt_three
    interval_cases n % 3 <;>
    simp only [this, pow_zero, pow_one, eq_self_iff_true, or_true_iff, true_or_iff]
  have z_ne_zero : z â‰  0 := fun h =>
    zero_ne_one ((zero_pow zero_lt_three).symm.trans (show (0 : â„‚) ^ 3 = 1 from h â–¸ h3))
  rcases key with (key | key | key)
  Â· exact z_ne_zero (by rwa [key, self_eq_add_left] at h1)
  Â· exact one_ne_zero (by rwa [key, self_eq_add_right] at h1)
  Â· exact z_ne_zero (pow_eq_zero (by rwa [key, add_self_eq_zero] at h2))
set_option linter.uppercaseLean3 false in
#align polynomial.X_pow_sub_X_sub_one_irreducible_aux Polynomial.X_pow_sub_X_sub_one_irreducible_aux

theorem X_pow_sub_X_sub_one_irreducible (hn1 : n â‰  1) : Irreducible (X ^ n - X - 1 : â„¤[X]) := by
  by_cases hn0 : n = 0
  Â· rw [hn0, pow_zero, sub_sub, add_comm, â† sub_sub, sub_self, zero_sub]
    exact Associated.irreducible âŸ¨-1, mul_neg_one XâŸ© irreducible_X
  have hn : 1 < n := Nat.one_lt_iff_ne_zero_and_ne_one.mpr âŸ¨hn0, hn1âŸ©
  have hp : (X ^ n - X - 1 : â„¤[X]) = trinomial 0 1 n (-1) (-1) 1 := by
    simp only [trinomial, C_neg, C_1]; ring
  rw [hp]
  apply IsUnitTrinomial.irreducible_of_coprime' âŸ¨0, 1, n, zero_lt_one, hn, -1, -1, 1, rflâŸ©
  rintro z âŸ¨h1, h2âŸ©
  apply X_pow_sub_X_sub_one_irreducible_aux z
  rw [trinomial_mirror zero_lt_one hn (-1 : â„¤Ë£).ne_zero (1 : â„¤Ë£).ne_zero] at h2
  simp_rw [trinomial, aeval_add, aeval_mul, aeval_X_pow, aeval_C,
    Units.val_neg, Units.val_one, map_neg, map_one] at h1 h2
  replace h1 : z ^ n = z + 1 := by linear_combination h1
  replace h2 := mul_eq_zero_of_left h2 z
  rw [add_mul, add_mul, add_zero, mul_assoc (-1 : â„‚), â† pow_succ', Nat.sub_add_cancel hn.le] at h2
  rw [h1] at h2 âŠ¢
  exact âŸ¨rfl, by linear_combination -h2âŸ©
set_option linter.uppercaseLean3 false in
#align polynomial.X_pow_sub_X_sub_one_irreducible Polynomial.X_pow_sub_X_sub_one_irreducible

theorem X_pow_sub_X_sub_one_irreducible_rat (hn1 : n â‰  1) : Irreducible (X ^ n - X - 1 : â„š[X]) := by
  by_cases hn0 : n = 0
  Â· rw [hn0, pow_zero, sub_sub, add_comm, â† sub_sub, sub_self, zero_sub]
    exact Associated.irreducible âŸ¨-1, mul_neg_one XâŸ© irreducible_X
  have hp : (X ^ n - X - 1 : â„¤[X]) = trinomial 0 1 n (-1) (-1) 1 := by
    simp only [trinomial, C_neg, C_1]; ring
  have hn : 1 < n := Nat.one_lt_iff_ne_zero_and_ne_one.mpr âŸ¨hn0, hn1âŸ©
  have h := (IsPrimitive.Int.irreducible_iff_irreducible_map_cast ?_).mp
    (X_pow_sub_X_sub_one_irreducible hn1)
  Â· rwa [Polynomial.map_sub, Polynomial.map_sub, Polynomial.map_pow, Polynomial.map_one,
      Polynomial.map_X] at h
  Â· exact hp.symm â–¸ (trinomial_monic zero_lt_one hn).isPrimitive
set_option linter.uppercaseLean3 false in
#align polynomial.X_pow_sub_X_sub_one_irreducible_rat Polynomial.X_pow_sub_X_sub_one_irreducible_rat

open Equiv Pointwise

lemma swap_mem_stabilizer_iff {Î± : Type*} [DecidableEq Î±] (S : Set Î±) (a b : Î±) :
    swap a b âˆˆ MulAction.stabilizer (Perm Î±) S â†” (a âˆˆ S â†” b âˆˆ S) := by
  rw [MulAction.mem_stabilizer_iff, Set.ext_iff, â† swap_inv]
  simp_rw [Set.mem_inv_smul_set_iff, Perm.smul_def, swap_apply_def]
  exact âŸ¨fun h â†¦ by simpa [Iff.comm] using h a, by intros; split_ifs <;> simp [*]âŸ©

/-- A transitive permutation group generated by transpositions must be the whole symmetric group -/
lemma closure_of_isSwap_of_isPretransitive {Î± : Type*} [DecidableEq Î±] [Finite Î±]
    (S : Set (Perm Î±)) (hS : âˆ€ Ïƒ âˆˆ S, Ïƒ.IsSwap) [MulAction.IsPretransitive (Subgroup.closure S) Î±] :
    Subgroup.closure S = âŠ¤ := by
  -- first separate out the case when `Î±` is empty
  rcases isEmpty_or_nonempty Î± with _ | âŸ¨âŸ¨a0âŸ©âŸ©
  Â· apply Subsingleton.elim
  -- `P T` says that `closure S` contains all transpositions of elements of `T`
  let P : Set Î± â†’ Prop := fun T â†¦ âˆ€ x âˆˆ T, âˆ€ y âˆˆ T, x â‰  y â†’ swap x y âˆˆ Subgroup.closure S
  -- it suffices to show `P Set.univ`, since then `closure S` contains all transpositions
  suffices : P Set.univ
  Â· rw [eq_top_iff, â† Perm.closure_isSwap, Subgroup.closure_le]
    rintro - âŸ¨x, y, hxy, rflâŸ©
    exact this x (Set.mem_univ x) y (Set.mem_univ y) hxy
  -- we will prove `P Set.univ` by induction, adding one element at a time
  apply Set.Finite.induction_to_univ âˆ… (by simp)
  -- we assume `P T`, and must prove `P ({b} âˆª T)` for some `b âˆ‰ T`
  intro T hT ih
  -- first separate out the case where `T` is empty
  rcases T.eq_empty_or_nonempty with rfl | hT'
  Â· exact âŸ¨a0, Set.not_mem_empty a0, by simpâŸ©
  -- we can show that `S` does not stabilize `T`
  have key0 : Â¬ Subgroup.closure S â‰¤ MulAction.stabilizer (Perm Î±) T
  Â· -- we can find `a âˆˆ T` and `b âˆ‰ T`
    obtain âŸ¨a, haâŸ© := hT'
    obtain âŸ¨b, hbâŸ© := T.ne_univ_iff_exists_not_mem.mp hT
    -- the action is transitive, so we can find `Ïƒ âˆˆ closure S` with `Ïƒ a = b`
    obtain âŸ¨âŸ¨Ïƒ, hÏƒâŸ©, rflâŸ© := MulAction.exists_smul_eq (Subgroup.closure S) a b
    exact fun h â†¦ hb (h hÏƒ â–¸ Set.smul_mem_smul_set ha)
  -- we can find `swap a b âˆˆ closure S` with `a âˆˆ T` and `b âˆ‰ T`
  have key : âˆƒ a b, swap a b âˆˆ S âˆ§ a âˆˆ T âˆ§ b âˆ‰ T
  Â· rw [Subgroup.closure_le, Set.not_subset] at key0
    -- we can find `Ï„ = swap x y âˆˆ S` with `Ï„ âˆ‰ MulAction.stabilizer (Perm Î±) T`
    obtain âŸ¨Ï„, hÏ„, hÏ„'âŸ© := key0
    obtain âŸ¨x, y, -, rflâŸ© := hS Ï„ hÏ„
    rw [SetLike.mem_coe, swap_mem_stabilizer_iff, not_iff] at hÏ„'
    by_cases hx : x âˆˆ T
    Â· exact âŸ¨x, y, hÏ„, hx, fun hy â†¦ hÏ„'.mpr hy hxâŸ©
    Â· exact âŸ¨y, x, swap_comm x y â–¸ hÏ„, hÏ„'.mp hx, hxâŸ©
  -- now we have `a âˆˆ T` and `b âˆ‰ T` and `swap a b âˆˆ Subgroup.closure S`
  obtain âŸ¨a, b, hab, ha, hbâŸ© := key
  replace hab := Subgroup.subset_closure hab
  refine' âŸ¨b, hb, _âŸ©
  -- we will prove `P ({b} âˆª T)` with a case bash
  rintro x (rfl | hx) y (rfl | hy) hxy
  Â· contradiction
  Â· rcases eq_or_ne y a with rfl | h
    Â· exact swap_comm x y â–¸ hab
    rw [â† swap_mul_swap_mul_swap h hxy.symm]
    exact Subgroup.mul_mem _ (Subgroup.mul_mem _ hab (ih y hy a ha h)) hab
  Â· rcases eq_or_ne x a with rfl | h
    Â· exact swap_comm x y â–¸ hab
    rw [swap_comm, â† swap_mul_swap_mul_swap h hxy]
    exact Subgroup.mul_mem _ (Subgroup.mul_mem _ hab (ih x hx a ha h)) hab
  Â· exact ih x hx y hy hxy

/- A transitive permutation group generated by transpositions must be the entire symmetric group -/
lemma surjective_of_isSwap_of_isPretransitive
    {Î± Î² : Type*} [Group Î±] [MulAction Î± Î²] [DecidableEq Î²] [Finite Î²]
    [h : MulAction.IsPretransitive Î± Î²] (S : Set Î±)
    (hS1 : âˆ€ Ïƒ âˆˆ S, Perm.IsSwap (MulAction.toPermHom Î± Î² Ïƒ)) (hS2 : Subgroup.closure S = âŠ¤) :
    Function.Surjective (MulAction.toPermHom Î± Î²) := by
  rw [â† MonoidHom.range_top_iff_surjective]
  have := MulAction.IsPretransitive.of_compHom (Î± := Î²) (MulAction.toPermHom Î± Î²).rangeRestrict
  rw [MonoidHom.range_eq_map, â† hS2, MonoidHom.map_closure] at this âŠ¢
  exact closure_of_isSwap_of_isPretransitive _ (Set.ball_image_iff.mpr hS1)

open IntermediateField

attribute [local instance] Gal.splits_â„š_â„‚

instance {Î± Î² : Type*} [Monoid Î±] [Subsingleton Î²] [MulAction Î± Î²] :
    MulAction.IsPretransitive Î± Î² :=
  âŸ¨fun _ _ â†¦ âŸ¨1, Subsingleton.elim _ _âŸ©âŸ©

open NumberField

def reshom {K : Type*} [Field K] (Ïƒ : K â†’+* K) : ğ“ K â†’+* ğ“ K :=
  Ïƒ.restrict (ğ“ K) (ğ“ K) (fun _ â†¦ map_isIntegral_int Ïƒ)

def res' {K : Type*} [Field K] (Ïƒ : K â‰ƒ+* K) : ğ“ K â‰ƒ+* ğ“ K :=
  RingEquiv.ofHomInv (reshom Ïƒ) (reshom Ïƒ.symm)
    (by ext x; exact Ïƒ.symm_apply_apply x) (by ext x; exact Ïƒ.apply_symm_apply x)

def res {K : Type*} [Field K] {Ï„ : Type*} [RingEquivClass Ï„ K K] (Ïƒ : Ï„) : ğ“ K â‰ƒ+* ğ“ K :=
  res' (RingEquivClass.toRingEquiv Ïƒ)

theorem X_pow_sub_X_sub_one_gal :
    Function.Bijective (Gal.galActionHom (X ^ n - X - 1 : â„š[X]) â„‚) := by
  let f : â„š[X] := X ^ n - X - 1
  change Function.Bijective (Gal.galActionHom f â„‚)
  have : MulAction.IsPretransitive f.Gal (f.rootSet â„‚)
  Â· rcases eq_or_ne n 1 with rfl | hn
    Â· have : IsEmpty (rootSet f â„‚) := by simp
      infer_instance
    exact Gal.galAction_isPretransitive _ _ (X_pow_sub_X_sub_one_irreducible_rat hn)
  let K := f.SplittingField
  let R := ğ“ K
  let S0 : Set f.Gal := â‹ƒ (q : Ideal R) (hq : q.IsMaximal), {Ïƒ | âˆ€ x : R, res Ïƒ x - x âˆˆ q}
  let S : Set f.Gal := S0 \ {1}
  have hS0 : Subgroup.closure S0 = âŠ¤
  Â· sorry
  have hS1 : Subgroup.closure S = âŠ¤
  Â· have h : Subgroup.closure (S0 âˆ© {1}) = âŠ¥
    Â· rw [eq_bot_iff, â† Subgroup.closure_singleton_one]
      exact Subgroup.closure_mono (Set.inter_subset_right S0 {1})
    rw [â† hS0, â† Set.diff_union_inter S0 {1}, Subgroup.closure_union, h, sup_bot_eq]
  have hS2 : âˆ€ Ïƒ âˆˆ S, Perm.IsSwap (MulAction.toPermHom f.Gal (f.rootSet â„‚) Ïƒ)
  Â· rintro Ïƒ âŸ¨hÏƒ, hÏƒ1 : Ïƒ â‰  1âŸ©
    rw [Set.mem_iUnion] at hÏƒ
    obtain âŸ¨q, hÏƒâŸ© := hÏƒ
    rw [Set.mem_iUnion] at hÏƒ
    obtain âŸ¨hq, hÏƒ : âˆ€ x : R, res Ïƒ x - x âˆˆ qâŸ© := hÏƒ
    let F := R â§¸ q
    let Ï€ : R â†’+* F := Ideal.Quotient.mk q
    have : Field F := Ideal.Quotient.field q
    -- finite field, might not need to consider the characteristic
    -- reduce to action on roots in R
    sorry
  exact âŸ¨Gal.galActionHom_injective f â„‚, surjective_of_isSwap_of_isPretransitive S hS2 hS1âŸ©

  -- have : âˆ€ p : Nat.Primes, âˆ€ q : factors (map (algebraMap â„¤ R) p)
  -- roots lie in the ring of integers OK
  -- if q is a prime idea of OK, then there is a ring homomorphism to the finite field OK/q
  -- the whole Galois group acts on OK
  -- the decomposition group acts on OK/q
  -- the inertia group acts trivially on OK/q
  --
  -- there are n roots in OK
  -- there are n or n-1 roots in OK/q (possible double root)
  -- Let Ïƒ(x) = x (mod p) for all x in OK
  -- If there are n roots in OK/q, then Ïƒ must act trivially on the roots in OK
  -- If x and y collapse (mod p), then maybe Ïƒ swaps x and y, but no more
  -- Now run through p's and Ïƒ's

  -- the key is proving closure/generating
  -- we need to know that if a subgroup contains every Ïƒ(x) = x (mod p) for every p, then it's âŠ¤
  -- we need to know that if a subfield is fixed by ..., then it's âŠ¥
  -- key facts from algebraic number theory: p divides discriminant implies ramified
  -- ramified means there exists Ïƒ(x) = x (mod p)

#check NumberField.discr_gt_one

end Polynomial
