/-
Copyright (c) 2022 Thomas Browning. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Thomas Browning
-/
module

public import Mathlib.Analysis.Complex.Polynomial.UnitTrinomial
public import Mathlib.FieldTheory.Finite.GaloisField
public import Mathlib.FieldTheory.Galois.IsGaloisGroup
public import Mathlib.FieldTheory.KrullTopology
public import Mathlib.FieldTheory.Relrank
public import Mathlib.GroupTheory.Perm.ClosureSwap
public import Mathlib.NumberTheory.NumberField.Discriminant.Basic
public import Mathlib.NumberTheory.NumberField.Discriminant.Different
public import Mathlib.NumberTheory.NumberField.Ideal.Basic
public import Mathlib.NumberTheory.RamificationInertia.Galois
public import Mathlib.RingTheory.Ideal.Over
public import Mathlib.RingTheory.IntegralClosure.IntegralRestrict
public import Mathlib.RingTheory.Invariant.Basic

/-!
# Irreducibility and Galois Groups of Selmer Polynomials

This file shows that the Selmer polynomial `X ^ n - X - 1` is irreducible with Galois group `S_n`.

## Main results

- `X_pow_sub_X_sub_one_irreducible`: The Selmer polynomials `X ^ n - X - 1` are irreducible.
- `X_pow_sub_X_sub_one_gal`: The Selmer polynomial `X ^ n - X - 1` has Galois group `S_n`.
-/

public section

namespace Polynomial

variable {R S : Type*} [CommRing R] [CommRing S] [Algebra R S] [IsDomain S]
  {G : Type*} [Group G] [MulSemiringAction G S] [SMulCommClass G R S] {f : R[X]}

/-- If the roots of `f` in `S` have at most one collision mod `p`, then a `MulSemiringAction` on
the roots in `S` must be the identity permutation or a transposition. -/
theorem Splits.isSwap_toPermHom_apply_of_mem_inertia [DecidableEq (f.rootSet S)]
    (hf : (f.map (algebraMap R S)).Splits)
    (p : Ideal S) [p.IsPrime] (hp : (f.rootSet S).ncard â‰¤ (f.rootSet (S â§¸ p)).ncard + 1)
    (g : G) (hg : g âˆˆ p.toAddSubgroup.inertia G) :
    MulAction.toPermHom G (f.rootSet S) g = 1 âˆ¨ (MulAction.toPermHom G (f.rootSet S) g).IsSwap := by
  classical
  by_cases hfp : f.map (algebraMap R (S â§¸ p)) = 0
  Â· rw [rootSet_def f (S â§¸ p), aroots_def, hfp, roots_zero, Multiset.toFinset_zero,
      Finset.coe_empty, Set.ncard_empty, zero_add, Set.ncard_le_one_iff_subsingleton,
      â† Set.subsingleton_coe] at hp
    exact Or.inl (Subsingleton.elim _ _)
  let Ï€ : S â†’â‚[R] S â§¸ p := Ideal.Quotient.mkâ‚ R p
  rw [â† hf.image_rootSet_of_map_ne_zero Ï€ hfp, Set.ncard_le_ncard_image_add_one_iff] at hp
  have hÏ€ (x : S) : Ï€ (g â€¢ x) = Ï€ x := (Ideal.Quotient.mk_eq_mk_iff_sub_mem (g â€¢ x) x).mpr (hg x)
  rw [or_iff_not_imp_left, Equiv.ext_iff, not_forall]
  rintro âŸ¨x, hx : g â€¢ x â‰  xâŸ©
  refine âŸ¨g â€¢ x, x, hx, ?_âŸ©
  ext z
  simp only [Equiv.swap_apply_def, MulAction.toPermHom_apply, MulAction.toPerm_apply]
  split_ifs with hz hz'
  Â· subst hz
    have key := hp (g â€¢ g â€¢ x) (g â€¢ g â€¢ x).2 (g â€¢ x) (g â€¢ x).2 (g â€¢ x) (g â€¢ x).2 x x.2
      (by simp [hÏ€]) (by simp [hÏ€]) (by simpa [â† rootSet.coe_smul]) (by simpa [â† rootSet.coe_smul])
    grind [rootSet.coe_smul]
  Â· simp [hz']
  Â· have key := hp (g â€¢ z) (g â€¢ z).2 z z.2 (g â€¢ x) (g â€¢ x).2 x x.2 (by simp [hÏ€]) (by simp [hÏ€])
    grind [rootSet.coe_smul, SetLike.coe_eq_coe]

/-- If for each maximal ideal `m`, the roots of `f` in `S` have at most one collision mod `m`, and
if a group `G` acting transitively on the roots in `S` is generated by inertia subgroups, then `G`
surjects onto the full symmetric group of the roots in `S`. -/
theorem Splits.toPermHom_surjective_of_supr_inertia_eq_top
    (hf : (f.map (algebraMap R S)).Splits) [MulAction.IsPretransitive G (f.rootSet S)]
    (h : âˆ€ m : MaximalSpectrum S, (f.rootSet S).ncard â‰¤ (f.rootSet (S â§¸ m.asIdeal)).ncard + 1)
    (hG : â¨† m : MaximalSpectrum S, m.asIdeal.toAddSubgroup.inertia G = âŠ¤) :
    Function.Surjective (MulAction.toPermHom G (f.rootSet S)) := by
  classical
  apply surjective_of_isSwap_of_isPretransitive'
      (â‹ƒ m : MaximalSpectrum S, m.asIdeal.toAddSubgroup.inertia G)
  Â· intro Ïƒ hÏƒ
    obtain âŸ¨m, hmâŸ© := Set.mem_iUnion.mp hÏƒ
    exact hf.isSwap_toPermHom_apply_of_mem_inertia m.asIdeal (h m) Ïƒ hm
  Â· simpa [Subgroup.closure_iUnion]

end Polynomial

section Inertia

open scoped Pointwise

-- PR #30666
section ram

variable {K ğ’ª : Type*} [Field K] [NumberField K] [CommRing ğ’ª] [Algebra ğ’ª K]
variable [IsIntegralClosure ğ’ª â„¤ K]

lemma NumberField.exists_not_isUramifiedAt_int (H : 1 < Module.finrank â„š K) :
    âˆƒ (P : Ideal ğ’ª) (_ : P.IsMaximal), P â‰  âŠ¥ âˆ§ Â¬ Algebra.IsUnramifiedAt â„¤ P :=
  sorry

end ram

section ram

open IsGaloisGroup

open NumberField

-- PR #30666
theorem Ideal.IsMaximal.ne_bot_of_isIntegral_int {R : Type*} [CommRing R]
    [CharZero R] [Algebra.IsIntegral â„¤ R] (I : Ideal R) [hI : I.IsMaximal] : I â‰  âŠ¥ :=
  Ring.ne_bot_of_isMaximal_of_not_isField hI <|
    Int.not_isField âˆ˜ isField_of_isIntegral_of_isField (FaithfulSMul.algebraMap_injective â„¤ R)

theorem NumberField.supr_inertia_eq_top (K : Type*) [Field K] [NumberField K]
    (G : Type*) [Group G] [MulSemiringAction G K] [IsGaloisGroup G â„š K] :
    â¨† m : MaximalSpectrum (ğ“ K), m.asIdeal.toAddSubgroup.inertia G = âŠ¤ := by
  have : Finite G := IsGaloisGroup.finite G â„š K
  set H : Subgroup G := â¨† m : MaximalSpectrum (ğ“ K), m.asIdeal.toAddSubgroup.inertia G
  set F : IntermediateField â„š K := FixedPoints.intermediateField H
  suffices Module.finrank â„š F â‰¤ 1 by
    rw [eq_top_iff, â† fixingSubgroup_fixedPoints G â„š K H, â† le_fixedPoints_iff_le_fixingSubgroup,
      fixedPoints_top, le_bot_iff, â† IntermediateField.finrank_eq_one_iff]
    exact le_antisymm this Module.finrank_pos
  suffices h : âˆ€ (m : Ideal (ğ“ F)) (hm : m.IsMaximal), Algebra.IsUnramifiedAt â„¤ m by
    contrapose! h
    obtain âŸ¨p, h1, h2, h3âŸ© := NumberField.exists_not_isUramifiedAt_int (ğ’ª := ğ“ F) h
    exact âŸ¨p, h1, h3âŸ©
  intro m _
  have hm2 := Ideal.IsMaximal.ne_bot_of_isIntegral_int m
  rw [Algebra.isUnramifiedAt_iff_of_isDedekindDomain hm2]
  obtain âŸ¨m, hm, âŸ¨rflâŸ©âŸ© := Ideal.exists_maximal_ideal_liesOver_of_isIntegral (S := ğ“ K) m
  rw [Ideal.under_under]
  have hm1 := Ideal.IsMaximal.ne_bot_of_isIntegral_int (m.under â„¤)
  have h : m.toAddSubgroup.inertia G â‰¤ H :=
    le_iSup (fun m : MaximalSpectrum (ğ“ K) â†¦ m.asIdeal.toAddSubgroup.inertia G) âŸ¨m, hmâŸ©
  replace h : Nat.card (m.toAddSubgroup.inertia H) = Nat.card (m.toAddSubgroup.inertia G) := by
    rw [â† Subgroup.map_subgroupOf_eq_of_le h, Subgroup.card_subtype,
      AddSubgroup.subgroupOf_inertia]
  let := Ideal.Quotient.field m
  let := Ideal.Quotient.field (m.under (ğ“ F))
  let := Ideal.Quotient.field (m.under â„¤)
  rw [Ideal.card_inertia_eq_ramificationIdxIn (G := H) (m.under (ğ“ F)) hm2 m,
    Ideal.card_inertia_eq_ramificationIdxIn (G := G) (m.under â„¤) hm1 m,
    Ideal.ramificationIdxIn_eq_ramificationIdx (m.under (ğ“ F)) m H,
    Ideal.ramificationIdxIn_eq_ramificationIdx (m.under â„¤) m G] at h
  have key := Ideal.ramificationIdx_algebra_tower (Ideal.map_ne_bot_of_ne_bot hm2)
    (Ideal.map_ne_bot_of_ne_bot hm1) Ideal.map_comap_le
  rwa [h, right_eq_mulâ‚€ (Ideal.IsDedekindDomain.ramificationIdx_ne_zero_of_liesOver m hm1)] at key

def MaximalSpectrum.equiv {R S : Type*} [CommSemiring R] [CommSemiring S] (e : R â‰ƒ+* S) :
    MaximalSpectrum R â‰ƒ MaximalSpectrum S where
  toFun m := âŸ¨m.asIdeal.map e, Ideal.map_isMaximal_of_equiv eâŸ©
  invFun m := âŸ¨m.asIdeal.comap e, Ideal.comap_isMaximal_of_equiv eâŸ©
  left_inv m := by simp [Ideal.comap_map_of_bijective e e.bijective]
  right_inv m := by simp [Ideal.map_comap_eq_self_of_equiv]

-- generalize from `ğ“ K` to `IsIntegralClosure`?
theorem genthm (K : Type*) [Field K] [NumberField K]
    (R : Type*) [CommRing R] [Algebra R K] [IsIntegralClosure R â„¤ K]
    (G : Type*) [Group G] [MulSemiringAction G K]
    [MulSemiringAction G R] [IsGaloisGroup G â„š K] :
    â¨† m : MaximalSpectrum R, m.asIdeal.toAddSubgroup.inertia G = âŠ¤ := by
  rw [â† NumberField.supr_inertia_eq_top K G]
  refine (MaximalSpectrum.equiv (IsIntegralClosure.equiv â„¤ (ğ“ K) K R).symm).iSup_congr fun m â†¦ ?_
  ext
  simp [MaximalSpectrum.equiv]
  sorry

end ram

end Inertia

namespace Polynomial

section Moore

open Equiv Pointwise

open IntermediateField

attribute [-instance] Polynomial.Gal.galActionAux -- should be local to PolynomialGaloisGroup.lean

attribute [-instance] Gal.smul Gal.galAction -- todo: redefine in more general semiring context

attribute [local instance] Gal.splits_â„š_â„‚

open NumberField

-- todo: can we drop monic?
theorem tada'' (fâ‚€ : â„¤[X]) (hfâ‚€ : Monic fâ‚€) (hfâ‚€' : Irreducible fâ‚€)
    (h : âˆ€ (F : Type) [Field F], (fâ‚€.map (algebraMap â„¤ F)).Splits â†’
      fâ‚€.natDegree â‰¤ (fâ‚€.rootSet F).ncard + 1) :
    -- condition on at most on root collision mod p :
    Function.Bijective (Gal.galActionHom (fâ‚€.map (algebraMap â„¤ â„š)) â„‚) := by
  classical
  let f : â„š[X] := fâ‚€.map (algebraMap â„¤ â„š)
  have hf : Monic f := hfâ‚€.map (algebraMap â„¤ â„š)
  have hf' : Irreducible f := hfâ‚€.irreducible_iff_irreducible_map_fraction_map.mp hfâ‚€'
  let K := f.SplittingField
  -- have : Fact (f.map (algebraMap â„š K)).Splits := âŸ¨SplittingField.splits fâŸ©
  have : NumberField K := by constructor
  have : IsGalois â„š K := by constructor
  let R := ğ“ K
  let G := f.Gal
  have h_transitive := Gal.galAction_isPretransitive f â„‚ hf'
  let e := Polynomial.Gal.rootsEquivRoots f â„‚
  have he : Gal.galActionHom f â„‚ = e.permCongrHom.toMonoidHom.comp
      (MulAction.toPermHom G (f.rootSet K)) := by
    ext; simp [Gal.galActionHom, Polynomial.Gal.smul_def, G, K, e]
  -- switch immediately from `f.rootSet â„‚` to `f.rootSet R`
  have hÏ† : Set.MapsTo (algebraMap R K) (fâ‚€.rootSet R) (f.rootSet K) := by
    intro x hx
    rw [hf.mem_rootSet, aeval_map_algebraMap, aeval_algebraMap_apply,
      aeval_eq_zero_of_mem_rootSet hx, map_zero]
  let Ï† : fâ‚€.rootSet R â†’ f.rootSet K := hÏ†.restrict
  have hÏ†1 : âˆ€ g : G, âˆ€ x : fâ‚€.rootSet R, Ï† (g â€¢ x) = g â€¢ Ï† x := by
    intro g x
    ext
    rfl
  have hÏ†2 : Function.Bijective (hÏ†.restrict) := by
    rw [Function.Bijective, hÏ†.restrict_inj, hÏ†.restrict_surjective_iff]
    refine âŸ¨RingOfIntegers.coe_injective.injOn, ?_âŸ©
    intro x hx
    have h0 : aeval x fâ‚€ = 0 := by
      rwa [mem_rootSet, aeval_map_algebraMap, and_iff_right hf.ne_zero] at hx
    let y : integralClosure â„¤ K := âŸ¨x, fâ‚€, hfâ‚€, h0âŸ©
    refine âŸ¨y, ?_, rflâŸ©
    rw [mem_rootSet, and_iff_right hfâ‚€.ne_zero]
    simpa using (aeval_algebraMap_apply K y fâ‚€).symm.trans h0
  let e' := Equiv.ofBijective hÏ†.restrict hÏ†2
  have he' : MulAction.toPermHom G (f.rootSet K) = e'.permCongrHom.toMonoidHom.comp
      (MulAction.toPermHom G (fâ‚€.rootSet R)) := by
    ext g x
    obtain âŸ¨y, rflâŸ© := e'.surjective x
    simp
    rfl
  suffices Function.Surjective (MulAction.toPermHom G (fâ‚€.rootSet R)) by
    use Polynomial.Gal.galActionHom_injective f â„‚
    rw [he, he']
    exact (e.permCongrHom.toEquiv.comp_surjective _).mpr
      ((e'.permCongrHom.toEquiv.comp_surjective _).mpr this)
  replace h_transitive : MulAction.IsPretransitive G (fâ‚€.rootSet R) := by
    refine âŸ¨fun x y â†¦ ?_âŸ©
    obtain âŸ¨g, hgâŸ© := h_transitive.exists_smul_eq (e (e' x)) (e (e' y))
    refine âŸ¨g, e'.injective (e.injective ?_)âŸ©
    rw [â† hg]
    rw [MonoidHom.ext_iff] at he
    specialize he g
    rw [Equiv.ext_iff] at he
    specialize he (e (e' x))
    simp at he
    exact he.symm
  have h1 : (fâ‚€.map (algebraMap â„¤ R)).Splits := by
    have h : (f.map (algebraMap â„š K)).Splits := SplittingField.splits f
    rw [map_map, â† IsScalarTower.algebraMap_eq, IsScalarTower.algebraMap_eq â„¤ R K, â† map_map] at h
    refine h.of_splits_map_of_injective RingOfIntegers.coe_injective ?_
    intro x hx
    rw [map_map, â† IsScalarTower.algebraMap_eq, IsScalarTower.algebraMap_eq â„¤ â„š K, â† map_map] at hx
    obtain âŸ¨y, hyâŸ© := hÏ†2.2 âŸ¨x, (by
      rw [hf.mem_rootSet] -- some sort of mem_rootSet_iff_mem_roots_map lemma?
      rwa [mem_roots_iff_aeval_eq_zero, aeval_map_algebraMap] at hx
      exact (hf.map (algebraMap â„š K)).ne_zero
    )âŸ©
    exact âŸ¨y, Subtype.ext_iff.mp hyâŸ©
  have : IsGaloisGroup G â„š K := IsGaloisGroup.of_isGalois â„š K
  refine h1.toPermHom_surjective_of_supr_inertia_eq_top (fun m â†¦ ?_)
    (NumberField.supr_inertia_eq_top K G)
  let := Ideal.Quotient.field m.asIdeal
  refine le_trans (fâ‚€.ncard_rootSet_le R) (h (R â§¸ m.asIdeal) ?_)
  rw [IsScalarTower.algebraMap_eq â„¤ R (R â§¸ m.asIdeal), â† Polynomial.map_map]
  exact h1.map _

end Moore

open scoped Polynomial

variable {n : â„•}

theorem X_pow_sub_X_sub_one_irreducible_aux (z : â„‚) : Â¬(z ^ n = z + 1 âˆ§ z ^ n + z ^ 2 = 0) := by
  rintro âŸ¨h1, h2âŸ©
  replace h3 : z ^ 3 = 1 := by
    linear_combination (1 - z - z ^ 2 - z ^ n) * h1 + (z ^ n - 2) * h2
  have key : z ^ n = 1 âˆ¨ z ^ n = z âˆ¨ z ^ n = z ^ 2 := by
    rw [â† Nat.mod_add_div n 3, pow_add, pow_mul, h3, one_pow, mul_one]
    have : n % 3 < 3 := Nat.mod_lt n zero_lt_three
    interval_cases n % 3 <;>
    simp only [pow_zero, pow_one, or_true, true_or]
  have z_ne_zero : z â‰  0 := fun h =>
    zero_ne_one ((zero_pow three_ne_zero).symm.trans (show (0 : â„‚) ^ 3 = 1 from h â–¸ h3))
  rcases key with (key | key | key)
  Â· exact z_ne_zero (by rwa [key, right_eq_add] at h1)
  Â· exact one_ne_zero (by rwa [key, left_eq_add] at h1)
  Â· exact z_ne_zero (eq_zero_of_pow_eq_zero (by rwa [key, add_self_eq_zero] at h2))

theorem X_pow_sub_X_sub_one_irreducible (hn1 : n â‰  1) : Irreducible (X ^ n - X - 1 : â„¤[X]) := by
  by_cases hn0 : n = 0
  Â· rw [hn0, pow_zero, sub_sub, add_comm, â† sub_sub, sub_self, zero_sub]
    exact Associated.irreducible âŸ¨-1, mul_neg_one XâŸ© irreducible_X
  have hn : 1 < n := Nat.one_lt_iff_ne_zero_and_ne_one.mpr âŸ¨hn0, hn1âŸ©
  have hp : (X ^ n - X - 1 : â„¤[X]) = trinomial 0 1 n (-1) (-1) 1 := by
    simp only [trinomial, C_neg, C_1]; ring
  rw [hp]
  apply IsUnitTrinomial.irreducible_of_coprime' âŸ¨0, 1, n, zero_lt_one, hn, -1, -1, 1, rflâŸ©
  rintro z âŸ¨h1, h2âŸ©
  apply X_pow_sub_X_sub_one_irreducible_aux (n := n) z
  rw [trinomial_mirror zero_lt_one hn (-1 : â„¤Ë£).ne_zero (1 : â„¤Ë£).ne_zero] at h2
  simp_rw [trinomial, aeval_add, aeval_mul, aeval_X_pow, aeval_C,
    Units.val_neg, Units.val_one, map_neg, map_one] at h1 h2
  replace h1 : z ^ n = z + 1 := by linear_combination h1
  replace h2 := mul_eq_zero_of_left h2 z
  rw [add_mul, add_mul, add_zero, mul_assoc (-1 : â„‚), â† pow_succ, Nat.sub_add_cancel hn.le] at h2
  rw [h1] at h2 âŠ¢
  exact âŸ¨rfl, by linear_combination -h2âŸ©

theorem X_pow_sub_X_sub_one_irreducible_rat (hn1 : n â‰  1) : Irreducible (X ^ n - X - 1 : â„š[X]) := by
  by_cases hn0 : n = 0
  Â· rw [hn0, pow_zero, sub_sub, add_comm, â† sub_sub, sub_self, zero_sub]
    exact Associated.irreducible âŸ¨-1, mul_neg_one XâŸ© irreducible_X
  have hp : (X ^ n - X - 1 : â„¤[X]) = trinomial 0 1 n (-1) (-1) 1 := by
    simp only [trinomial, C_neg, C_1]; ring
  have hn : 1 < n := Nat.one_lt_iff_ne_zero_and_ne_one.mpr âŸ¨hn0, hn1âŸ©
  have h := (IsPrimitive.Int.irreducible_iff_irreducible_map_cast ?_).mp
    (X_pow_sub_X_sub_one_irreducible hn1)
  Â· rwa [Polynomial.map_sub, Polynomial.map_sub, Polynomial.map_pow, Polynomial.map_one,
      Polynomial.map_X] at h
  Â· exact hp â–¸ (trinomial_monic zero_lt_one hn).isPrimitive

open Equiv Pointwise

open IntermediateField

attribute [local instance] Gal.splits_â„š_â„‚

theorem X_pow_sub_X_sub_one_gal :
    Function.Bijective (Gal.galActionHom (X ^ n - X - 1 : â„š[X]) â„‚) := by
  rcases le_or_gt n 1 with hn | hn
  Â· have : Subsingleton ((X ^ n - X - 1 : â„š[X]).rootSet â„‚) := by
      apply Finset.card_le_one_iff_subsingleton_coe.mp
      grw [Multiset.toFinset_card_le, card_roots', natDegree_map_le, natDegree_sub_le,
        natDegree_sub_le, natDegree_X_pow, natDegree_X, natDegree_one, hn, max_self, Nat.max_zero]
    have : Unique ((X ^ n - X - 1 : â„š[X]).Gal) := by
      refine Gal.uniqueGalOfSplits _ (Splits.of_natDegree_le_one (by compute_degree!))
    apply Unique.bijective
  have hp : (X ^ n - X - 1 : â„¤[X]) = trinomial 0 1 n (-1) (-1) 1 := by
    simp only [trinomial, C_neg, C_1]; ring
  have h := tada'' (X ^ n - X - 1) (hp â–¸ trinomial_monic zero_lt_one hn)
    (X_pow_sub_X_sub_one_irreducible hn.ne') ?_
  Â· rwa [Polynomial.map_sub, Polynomial.map_sub, Polynomial.map_pow, Polynomial.map_one,
      Polynomial.map_X] at h
  Â· classical
    intro F _ hF
    have := hF.natDegree_eq_card_roots
    rw [Monic.natDegree_map (hp â–¸ trinomial_monic zero_lt_one hn)] at this
    rw [this]
    rw [rootSet_def, aroots_def, Set.ncard_coe_finset]
    rw [Multiset.card_le_card_toFinset_add_one_iff]
    have h : âˆ€ x : F, 1 < (map (algebraMap â„¤ F) (X ^ n - X - 1)).roots.count x â†’
        x = n / (1 - n) âˆ§ x â‰  0 := by
      intro x hx
      rw [count_roots, one_lt_rootMultiplicity_iff_isRoot_iterate_derivative
        (Monic.map _ (hp â–¸ trinomial_monic zero_lt_one hn)).ne_zero] at hx
      have hx0 := hx 0 one_pos.le
      have hx1 := hx 1 le_rfl
      simp [derivative_X_pow, sub_eq_iff_eq_add] at hx0 hx1
      rw [pow_sub_of_lt x hn, pow_one, hx0] at hx1
      have hx0 : x â‰  0 := by
        rintro rfl
        simp at hx1
      rw [â† mul_assoc, mul_inv_eq_oneâ‚€ hx0] at hx1
      rw [mul_add, mul_one, eq_comm, â† sub_eq_iff_eq_add, â† one_sub_mul, mul_comm] at hx1
      refine âŸ¨eq_div_of_mul_eq ?_ hx1, hx0âŸ©
      rw [sub_ne_zero]
      rintro hn0
      rw [â† hn0] at hx1
      simp at hx1
    intro x y hx hy
    have hx' := h x hx
    replace hy := h y hy
    use hx'.1.trans hy.1.symm
    refine le_antisymm ?_ hx
    rw [count_roots]
    by_contra! hx''
    replace hx'' := Polynomial.isRoot_iterate_derivative_of_lt_rootMultiplicity hx''
    simp [derivative_X_pow, Nat.cast_sub hn.le, sub_eq_zero, hx'.2] at hx''
    grind

end Polynomial
