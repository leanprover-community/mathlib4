/-
Copyright (c) 2025 Fabrizio Barroero. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Fabrizio Barroero
-/

import Mathlib.Order.CompletePartialOrder
import Mathlib.RingTheory.Ideal.Quotient.Operations
import Mathlib.RingTheory.Polynomial.Content

/-!
# The content ideal of a polynomial

In this file we introduce the content ideal of a polynomial `p : R[X]` as the ideal generated by its
coefficients, and we prove some basic properties about it.

## Main Definitions
Let `p : R[X]`.
- `p.contentIdeal` is the `Ideal R` generated by the coefficients of `p`.

## Main Results
- `Polynomial.contentIdeal_mul_le_mul_contentIdeal`: the content ideal of the product of two
  polynomials is contained in the product of their content ideals.
- `Polynomial.isPrimitive_of_contentIdeal_eq_top`: if the content ideal of `p` is the whole ring,
  then `p` is primitive.
- `Submodule.IsPrincipal.isPrimitive_iff_contentIdeal_eq_top`: in case the content ideal of `p` is
  principal, `p` is primitive if and only if its content ideal is the whole ring.
- `Polynomial.mul_contentIdeal_le_radical_contentIdeal_mul`: the product of the content ideals of
  two polynomials is contained in the radical of the content ideal of their product.
- `Submodule.IsPrincipal.contentIdeal_eq_span_content_of_isPrincipal`: if the content ideal of `p`
  is principal, then it is equal to the ideal generated by the content of `p`.
- `contentIdeal_mul_eq_top_of_contentIdeal_eq_top`: if the content ideals of two
  polynomials are the whole ring, then the content ideal of their product is the whole ring. This
  is also often called Gauss' Lemma.

## TODO

- Prove the Dedekind-Mertens lemma, see https://www.cse.chalmers.se/~coquand/mertens.pdf

-/

namespace Polynomial

open Ideal

variable {R S : Type*} [Semiring R] [Semiring S] (p : R[X])

/-- The content ideal of a polynomial `p` is the ideal generated by its coefficients. -/
def contentIdeal := span p.coeffs.toSet

theorem contentIdeal_def : p.contentIdeal = span p.coeffs.toSet := rfl

@[simp]
theorem contenIdeal_zero : (0 : R[X]).contentIdeal = ⊥ := by
  simp [contentIdeal_def]

@[simp]
theorem contentIdeal_eq_bot_iff : p.contentIdeal = ⊥ ↔ p = 0 := by
  simp only [contentIdeal_def, span_eq_bot]
  refine ⟨?_, fun h ↦ by simp [h]⟩
  contrapose!
  exact fun h ↦ ⟨p.leadingCoeff, coeff_mem_coeffs p p.natDegree (leadingCoeff_ne_zero.mpr h),
    leadingCoeff_ne_zero.mpr h⟩

theorem coeff_mem_contentIdeal (n : ℕ) : p.coeff n ∈ p.contentIdeal := by
  by_cases h : p.coeff n = 0
  · simp [h]
  · apply subset_span
    simpa using coeff_mem_coeffs p n h

@[simp]
theorem contentIdeal_monomial (n : ℕ) (r : R) : (monomial n r).contentIdeal = span {r} := by
  by_cases h : r = 0 <;>
  simp [h, Set.singleton_zero, contentIdeal_def, coeffs_monomial]

@[simp]
theorem contentIdeal_C (r : R) : (C r).contentIdeal = span {r} := by
  rw [← monomial_zero_left]
  exact contentIdeal_monomial 0 r

@[simp]
theorem contentIdeal_one : (1 : R[X]).contentIdeal = ⊤ := by
  rw [← span_singleton_one, ← contentIdeal_C 1, C_1]

theorem contentIdeal_FG : p.contentIdeal.FG := ⟨p.coeffs, rfl⟩

theorem contentIdeal_map_eq_map_contentIdeal (f : R →+* S) :
    (p.map f).contentIdeal = p.contentIdeal.map f := by
  suffices span ((map f p).coeffs ∪ {0}) = span (f '' p.coeffs ∪ {0}) by
    simpa [contentIdeal_def, map_span]
  congr 1
  ext s
  by_cases hs : s = 0
  · simp [hs]
  · aesop (add simp mem_coeffs_iff)

theorem contentIdeal_mul_le_mul_contentIdeal (q : R[X]) :
    (p * q).contentIdeal ≤ p.contentIdeal * q.contentIdeal := by
  rw [contentIdeal_def, span_le]
  simp only [Set.subset_def, Finset.mem_coe, mem_coeffs_iff]
  rintro r ⟨n, _, rfl⟩
  simp [coeff_mul, _root_.sum_mem, Submodule.mul_mem_mul, coeff_mem_contentIdeal]

section CommSemiring

variable {R : Type*} [CommSemiring R] {p q : R[X]}

theorem contentIdeal_le_contentIdeal_of_dvd (hpq : p ∣ q) : q.contentIdeal ≤ p.contentIdeal := by
  obtain ⟨p', rfl⟩ := hpq
  exact le_trans (p.contentIdeal_mul_le_mul_contentIdeal p') mul_le_right

theorem _root_.Submodule.IsPrincipal.contentIdeal_generator_dvd_coeff
    (h_prin : p.contentIdeal.IsPrincipal) (n : ℕ) : h_prin.generator ∣ p.coeff n := by
  have := p.coeff_mem_contentIdeal n
  rw [Submodule.IsPrincipal.mem_iff_eq_smul_generator] at this
  obtain ⟨_, ha⟩ := this
  simp [ha]

theorem _root_.Submodule.IsPrincipal.contentIdeal_generator_dvd
    (h_prin : p.contentIdeal.IsPrincipal) : C h_prin.generator ∣ p := by
  rw [C_dvd_iff_dvd_coeff]
  exact fun i ↦ h_prin.contentIdeal_generator_dvd_coeff i

theorem _root_.Submodule.IsPrincipal.contentIdeal_le_span_iff_dvd
    (h_prin : p.contentIdeal.IsPrincipal) (r : R) :
    p.contentIdeal ≤ span {r} ↔ C r ∣ p := by
  constructor
  · rw [← p.contentIdeal.span_singleton_generator]
    intro _
    calc
    C r ∣ C h_prin.generator := by
      apply _root_.map_dvd C
      rwa [← span_singleton_le_span_singleton]
     _   ∣ p := h_prin.contentIdeal_generator_dvd
  · rw [← contentIdeal_C r]
    exact fun h ↦ contentIdeal_le_contentIdeal_of_dvd h

/-- If the coefficients of `p` geneate the whole ring, then `p` is primitive. -/
theorem isPrimitive_of_contentIdeal_eq_top (h : p.contentIdeal = ⊤) : p.IsPrimitive := by
  have h_prin : p.contentIdeal.IsPrincipal := by
    rw [h]
    exact top_isPrincipal
  intro r
  simp [← h_prin.contentIdeal_le_span_iff_dvd r, h]

theorem _root_.Submodule.IsPrincipal.isPrimitive_iff_contentIdeal_eq_top
    (h_prin : p.contentIdeal.IsPrincipal) : p.IsPrimitive ↔ p.contentIdeal = ⊤ := by
  refine ⟨?_, fun h ↦ isPrimitive_of_contentIdeal_eq_top h⟩
  contrapose!
  simp only [IsPrimitive, not_forall]
  intro _
  use h_prin.generator, h_prin.contentIdeal_generator_dvd
  simp_all [← Ideal.span_singleton_eq_top]

theorem contentIdeal_eq_top_of_contentIdeal_mul_eq_top
    (h : (p * q).contentIdeal = ⊤) : p.contentIdeal = ⊤ := by
  apply le_antisymm le_top
  calc
  ⊤ = (p * q).contentIdeal := h.symm
  _ ≤ p.contentIdeal * q.contentIdeal := contentIdeal_mul_le_mul_contentIdeal p q
  _ ≤ p.contentIdeal := mul_le_right

end CommSemiring

section Ring

variable {R : Type*} [CommRing R] {p q : R[X]}

theorem mul_contentIdeal_le_radical_contentIdeal_mul :
    p.contentIdeal * q.contentIdeal ≤ ((p * q).contentIdeal).radical := by
  rw [radical_eq_sInf, le_sInf_iff]
  intro P ⟨hpq, hPprime⟩
  rw [hPprime.mul_le]
  rw [← Ideal.mk_ker (I := P)] at hpq ⊢
  simpa only [← map_eq_bot_iff_le_ker, ← contentIdeal_map_eq_map_contentIdeal, Polynomial.map_mul,
    contentIdeal_eq_bot_iff, mul_eq_zero] using hpq

theorem contentIdeal_mul_eq_top_of_contentIdeal_eq_top (hp : p.contentIdeal = ⊤)
    (hq : q.contentIdeal = ⊤) : (p * q).contentIdeal = ⊤ := by
  rw [← Ideal.radical_eq_top]
  apply le_antisymm le_top
  calc
    ⊤ = p.contentIdeal * q.contentIdeal := by simp [hp, hq]
    _ ≤ ((p * q).contentIdeal).radical := mul_contentIdeal_le_radical_contentIdeal_mul

end Ring
section NormalizedGCDMonoid

variable {R : Type*} [CommRing R] [IsDomain R] [NormalizedGCDMonoid R] {p : R[X]}

theorem contentIdeal_le_span_content : p.contentIdeal ≤ span {p.content} := by
  rw [contentIdeal_def, span_le]
  intro _ h1
  rw [Finset.mem_coe, mem_coeffs_iff] at h1
  obtain ⟨n, _, h2⟩ := h1
  rw [SetLike.mem_coe, h2, mem_span_singleton]
  exact content_dvd_coeff n

theorem _root_.Submodule.IsPrincipal.contentIdeal_eq_span_content_of_isPrincipal
    (h_prin : p.contentIdeal.IsPrincipal) : p.contentIdeal = span {p.content} := by
  apply le_antisymm contentIdeal_le_span_content
  rw [← p.contentIdeal.span_singleton_generator, span_singleton_le_span_singleton, content,
    Finset.dvd_gcd_iff]
  exact fun n _ ↦ h_prin.contentIdeal_generator_dvd_coeff n

end NormalizedGCDMonoid

section IsBezout

variable {R : Type*} [CommSemiring R] [IsBezout R] (p : R[X])

/-- The polynomial `p` is primitive if and only if the coefficients of `p` geneate the whole ring.
-/
theorem isPrimitive_iff_contentIdeal_eq_top : p.IsPrimitive ↔ p.contentIdeal = ⊤ :=
  (IsBezout.isPrincipal_of_FG _ p.contentIdeal_FG).isPrimitive_iff_contentIdeal_eq_top

end IsBezout

end Polynomial
