/-
Copyright (c) 2025 Fabrizio Barroero. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Fabrizio Barroero
-/

import Mathlib.Order.CompletePartialOrder
import Mathlib.RingTheory.Ideal.BigOperators
import Mathlib.RingTheory.Polynomial.Content

/-!
# The content ideal of a polynomial

In this file we introduce the content ideal of a polynomial `p : R[X]` as the ideal generated by its
coefficients, and we prove some basic properties about it.

## Main Definitions
Let `p : R[X]`.
- `p.contentIdeal` is the `Ideal R` generated by the coefficients of `p`.

## Main Results
- `Polynomial.isPrimitive_of_contentIdeal_eq_top`: if the content ideal of `p` is the whole ring,
  then `p` is primitive.
- `Submodule.IsPrincipal.isPrimitive_iff_contentIdeal_eq_top`: in case the content ideal of `p` is
  principal, `p` is primitive if and only if its content ideal is the whole ring.
- `Submodule.IsPrincipal.contentIdeal_eq_span_content_of_isPrincipal`: if the content ideal of `p`
  is principal, then it is equal to the ideal generated by the content of `p`.

## TODO

- Prove the Dedekind-Mertens lemma, see https://www.cse.chalmers.se/~coquand/mertens.pdf

-/

namespace Polynomial

open Ideal

variable {R : Type*} [Semiring R] (p : R[X])

/-- The content ideal of a polynomial `p` is the ideal generated by its coefficients. -/
def contentIdeal := span p.coeffs.toSet

theorem contentIdeal_def : p.contentIdeal = span p.coeffs.toSet := rfl

@[simp]
theorem contenIdeal_zero : (0 : R[X]).contentIdeal = ⊥ := by
  simp [contentIdeal_def]

@[simp]
theorem contentIdeal_eq_bot_iff : p.contentIdeal = ⊥ ↔ p = 0 := by
  simp only [contentIdeal_def, span_eq_bot]
  refine ⟨?_, fun h ↦ by simp [h]⟩
  contrapose!
  exact fun h ↦ ⟨p.leadingCoeff, coeff_mem_coeffs p p.natDegree (leadingCoeff_ne_zero.mpr h),
    leadingCoeff_ne_zero.mpr h⟩

theorem coeff_mem_contentIdeal (n : ℕ) : p.coeff n ∈ p.contentIdeal := by
  by_cases h : p.coeff n = 0
  · simp [h]
  · apply subset_span
    simpa using coeff_mem_coeffs p n h

@[simp]
theorem contentIdeal_monomial (n : ℕ) (r : R) : (monomial n r).contentIdeal = span {r} := by
  by_cases h : r = 0 <;>
  simp [h, Set.singleton_zero, contentIdeal_def, coeffs_monomial]

@[simp]
theorem contentIdeal_C (r : R) : (C r).contentIdeal = span {r} := by
  rw [← monomial_zero_left]
  exact contentIdeal_monomial 0 r

theorem contentIdeal_FG : p.contentIdeal.FG := ⟨p.coeffs, rfl⟩

section CommSemiring

variable {R : Type*} [CommSemiring R] {p q : R[X]}

theorem contentIdeal_le_contentIdeal_of_dvd (hpq : p ∣ q) :
    q.contentIdeal ≤ p.contentIdeal := by
  rw [contentIdeal_def, span_le]
  intro _ h1
  rw [Finset.mem_coe, mem_coeffs_iff] at h1
  obtain ⟨_, _, h2⟩ := h1
  obtain ⟨_, h3⟩ := hpq
  rw [h3, coeff_mul] at h2
  rw [h2]
  exact Ideal.sum_mem _ <| fun _ _ ↦ mul_mem_right _ _ <| coeff_mem_contentIdeal p _

theorem _root_.Submodule.IsPrincipal.contentIdeal_generator_dvd_coeff
    (h_prin : p.contentIdeal.IsPrincipal) (n : ℕ) : h_prin.generator ∣ p.coeff n := by
  have := p.coeff_mem_contentIdeal n
  rw [Submodule.IsPrincipal.mem_iff_eq_smul_generator] at this
  obtain ⟨_, ha⟩ := this
  simp [ha]

theorem _root_.Submodule.IsPrincipal.contentIdeal_generator_dvd
    (h_prin : p.contentIdeal.IsPrincipal) : C h_prin.generator ∣ p := by
  rw [C_dvd_iff_dvd_coeff]
  exact fun i ↦ h_prin.contentIdeal_generator_dvd_coeff i

theorem _root_.Submodule.IsPrincipal.contentIdeal_le_span_iff_dvd
    (h_prin : p.contentIdeal.IsPrincipal) (r : R) :
    p.contentIdeal ≤ span {r} ↔ C r ∣ p := by
  constructor
  · rw [← p.contentIdeal.span_singleton_generator]
    intro _
    calc
    C r ∣ C h_prin.generator := by
      apply _root_.map_dvd C
      rwa [← span_singleton_le_span_singleton]
     _   ∣ p := h_prin.contentIdeal_generator_dvd
  · rw [← contentIdeal_C r]
    exact fun h ↦ contentIdeal_le_contentIdeal_of_dvd h

/-- If the coefficients of `p` geneate the whole ring, then `p` is primitive. -/
theorem isPrimitive_of_contentIdeal_eq_top (h : p.contentIdeal = ⊤) : p.IsPrimitive := by
  have h_prin : p.contentIdeal.IsPrincipal := by
    rw [h]
    exact top_isPrincipal
  intro r
  simp [← h_prin.contentIdeal_le_span_iff_dvd r, h]

theorem _root_.Submodule.IsPrincipal.isPrimitive_iff_contentIdeal_eq_top
    (h_prin : p.contentIdeal.IsPrincipal) : p.IsPrimitive ↔ p.contentIdeal = ⊤ := by
  refine ⟨?_, fun h ↦ isPrimitive_of_contentIdeal_eq_top h⟩
  contrapose!
  simp only [IsPrimitive, not_forall]
  intro _
  use h_prin.generator, h_prin.contentIdeal_generator_dvd
  simp_all [← Ideal.span_singleton_eq_top]

end CommSemiring

section NormalizedGCDMonoid

variable {R : Type*} [CommRing R] [IsDomain R] [NormalizedGCDMonoid R] {p : R[X]}

theorem contentIdeal_le_span_content : p.contentIdeal ≤ span {p.content} := by
  rw [contentIdeal_def, span_le]
  intro _ h1
  rw [Finset.mem_coe, mem_coeffs_iff] at h1
  obtain ⟨n, _, h2⟩ := h1
  rw [SetLike.mem_coe, h2, mem_span_singleton]
  exact content_dvd_coeff n

theorem _root_.Submodule.IsPrincipal.contentIdeal_eq_span_content_of_isPrincipal
    (h_prin : p.contentIdeal.IsPrincipal) : p.contentIdeal = span {p.content} := by
  apply le_antisymm contentIdeal_le_span_content
  rw [← p.contentIdeal.span_singleton_generator, span_singleton_le_span_singleton, content,
    Finset.dvd_gcd_iff]
  exact fun n _ ↦ h_prin.contentIdeal_generator_dvd_coeff n

end NormalizedGCDMonoid

section IsBezout

variable {R : Type*} [CommSemiring R] [IsBezout R] (p : R[X])

/-- The polynomial `p` is primitive if and only if the coefficients of `p` geneate the whole ring.
-/
theorem isPrimitive_iff_contentIdeal_eq_top : p.IsPrimitive ↔ p.contentIdeal = ⊤ :=
  (IsBezout.isPrincipal_of_FG _ p.contentIdeal_FG).isPrimitive_iff_contentIdeal_eq_top

end IsBezout

end Polynomial
