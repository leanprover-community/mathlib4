/-
Copyright (c) 2022 Riccardo Brasca. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Riccardo Brasca
-/
import Mathlib.Data.Nat.Choose.Dvd
import Mathlib.RingTheory.IntegralClosure.IntegrallyClosed
import Mathlib.RingTheory.Norm.Transitivity
import Mathlib.RingTheory.Polynomial.Cyclotomic.Expand

/-!
# Eisenstein polynomials
In this file we gather more miscellaneous results about Eisenstein polynomials

## Main results
* `mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt`: let `K` be the field of fraction
  of an integrally closed domain `R` and let `L` be an extension of `K`, generated by an integral
  power basis `B` such that the minimal polynomial of `B.gen` is Eisenstein at `p`. Given `z : L`
  integral over `R`, if `p ^ n ‚Ä¢ z ‚àà adjoin R {B.gen}`, then `z ‚àà adjoin R {B.gen}`.
  Together with `Algebra.discr_mul_isIntegral_mem_adjoin` this result often allows to compute the
  ring of integers of `L`.

-/

universe u v w z

variable {R : Type u}

open Ideal Algebra Finset

open scoped Polynomial

section Cyclotomic

variable (p : ‚Ñï)

local notation "ùìü" => Submodule.span ‚Ñ§ {(p : ‚Ñ§)}

open Polynomial

theorem cyclotomic_comp_X_add_one_isEisensteinAt [hp : Fact p.Prime] :
    ((cyclotomic p ‚Ñ§).comp (X + 1)).IsEisensteinAt ùìü := by
  refine Monic.isEisensteinAt_of_mem_of_notMem ?_
      (Ideal.IsPrime.ne_top <| (Ideal.span_singleton_prime (mod_cast hp.out.ne_zero)).2 <|
        Nat.prime_iff_prime_int.1 hp.out) (fun {i hi} => ?_) ?_
  ¬∑ rw [show (X + 1 : ‚Ñ§[X]) = X + C 1 by simp]
    refine (cyclotomic.monic p ‚Ñ§).comp (monic_X_add_C 1) fun h => ?_
    rw [natDegree_X_add_C] at h
    exact zero_ne_one h.symm
  ¬∑ rw [cyclotomic_prime, geom_sum_X_comp_X_add_one_eq_sum, ‚Üê lcoeff_apply, map_sum]
    conv =>
      congr
      congr
      next => skip
      congr
      next => skip
      ext
      rw [lcoeff_apply, ‚Üê C_eq_natCast, C_mul_X_pow_eq_monomial, coeff_monomial]
    rw [natDegree_comp, show (X + 1 : ‚Ñ§[X]) = X + C 1 by simp, natDegree_X_add_C, mul_one,
      natDegree_cyclotomic, Nat.totient_prime hp.out] at hi
    simp only [hi.trans_le (Nat.sub_le _ _), sum_ite_eq', mem_range, if_true,
      Ideal.submodule_span_eq, Ideal.mem_span_singleton, Int.natCast_dvd_natCast]
    exact hp.out.dvd_choose_self i.succ_ne_zero (lt_tsub_iff_right.1 hi)
  ¬∑ rw [coeff_zero_eq_eval_zero, eval_comp, cyclotomic_prime, eval_add, eval_X, eval_one, zero_add,
      eval_geom_sum, one_geom_sum, Ideal.submodule_span_eq, Ideal.span_singleton_pow,
      Ideal.mem_span_singleton]
    intro h
    obtain ‚ü®k, hk‚ü© := Int.natCast_dvd_natCast.1 h
    rw [mul_assoc, mul_comm 1, mul_one] at hk
    nth_rw 1 [‚Üê Nat.mul_one p] at hk
    rw [mul_right_inj' hp.out.ne_zero] at hk
    exact Nat.Prime.not_dvd_one hp.out (Dvd.intro k hk.symm)

theorem cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt [hp : Fact p.Prime] (n : ‚Ñï) :
    ((cyclotomic (p ^ (n + 1)) ‚Ñ§).comp (X + 1)).IsEisensteinAt ùìü := by
  refine Monic.isEisensteinAt_of_mem_of_notMem ?_
      (Ideal.IsPrime.ne_top <| (Ideal.span_singleton_prime (mod_cast hp.out.ne_zero)).2 <|
        Nat.prime_iff_prime_int.1 hp.out) ?_ ?_
  ¬∑ rw [show (X + 1 : ‚Ñ§[X]) = X + C 1 by simp]
    refine (cyclotomic.monic _ ‚Ñ§).comp (monic_X_add_C 1) fun h => ?_
    rw [natDegree_X_add_C] at h
    exact zero_ne_one h.symm
  ¬∑ induction n with
    | zero =>
      intro i hi
      rw [Nat.zero_add, pow_one] at hi ‚ä¢
      exact (cyclotomic_comp_X_add_one_isEisensteinAt p).mem hi
    | succ n hn =>
      intro i hi
      rw [Ideal.submodule_span_eq, Ideal.mem_span_singleton, ‚Üê ZMod.intCast_zmod_eq_zero_iff_dvd,
        show ‚Üë(_ : ‚Ñ§) = Int.castRingHom (ZMod p) _ by rfl, ‚Üê coeff_map, map_comp, map_cyclotomic,
        Polynomial.map_add, map_X, Polynomial.map_one, pow_add, pow_one,
        cyclotomic_mul_prime_dvd_eq_pow, pow_comp, ‚Üê ZMod.expand_card, coeff_expand hp.out.pos]
      ¬∑ simp only [ite_eq_right_iff]
        rintro ‚ü®k, hk‚ü©
        rw [natDegree_comp, show (X + 1 : ‚Ñ§[X]) = X + C 1 by simp, natDegree_X_add_C, mul_one,
          natDegree_cyclotomic, Nat.totient_prime_pow hp.out (Nat.succ_pos _), Nat.add_one_sub_one]
          at hn hi
        rw [hk, pow_succ', mul_assoc] at hi
        rw [hk, mul_comm, Nat.mul_div_cancel _ hp.out.pos]
        replace hn := hn (lt_of_mul_lt_mul_left' hi)
        rw [Ideal.submodule_span_eq, Ideal.mem_span_singleton, ‚Üê ZMod.intCast_zmod_eq_zero_iff_dvd,
           show ‚Üë(_ : ‚Ñ§) = Int.castRingHom (ZMod p) _ by rfl, ‚Üê coeff_map] at hn
        simpa [map_comp] using hn
      ¬∑ exact ‚ü®p ^ n, by rw [pow_succ']‚ü©
  ¬∑ rw [coeff_zero_eq_eval_zero, eval_comp, cyclotomic_prime_pow_eq_geom_sum hp.out, eval_add,
      eval_X, eval_one, zero_add, eval_finset_sum]
    simp only [eval_pow, eval_X, one_pow, sum_const, card_range, Nat.smul_one_eq_cast,
      submodule_span_eq, Ideal.submodule_span_eq, Ideal.span_singleton_pow,
      Ideal.mem_span_singleton]
    intro h
    obtain ‚ü®k, hk‚ü© := Int.natCast_dvd_natCast.1 h
    rw [mul_assoc, mul_comm 1, mul_one] at hk
    nth_rw 1 [‚Üê Nat.mul_one p] at hk
    rw [mul_right_inj' hp.out.ne_zero] at hk
    exact Nat.Prime.not_dvd_one hp.out (Dvd.intro k hk.symm)

end Cyclotomic

section IsIntegral

variable {K : Type v} {L : Type z} {p : R} [CommRing R] [Field K] [Field L]
variable [Algebra K L] [Algebra R L] [Algebra R K] [IsScalarTower R K L]
variable [IsDomain R] [IsFractionRing R K] [IsIntegrallyClosed R]

local notation "ùìü" => Submodule.span R {(p : R)}

open IsIntegrallyClosed PowerBasis Nat Polynomial IsScalarTower

/-- Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be an extension
of `K`, generated by an integral power basis `B` such that the minimal polynomial of `B.gen` is
Eisenstein at `p`. Given `z : L` integral over `R`, if `Q : R[X]` is such that
`aeval B.gen Q = p ‚Ä¢ z`, then `p ‚à£ Q.coeff 0`. -/
theorem dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}
    (hp : Prime p) (hBint : IsIntegral R B.gen) {z : L} {Q : R[X]} (hQ : aeval B.gen Q = p ‚Ä¢ z)
    (hzint : IsIntegral R z) (hei : (minpoly R B.gen).IsEisensteinAt ùìü) : p ‚à£ Q.coeff 0 := by
  -- First define some abbreviations.
  letI := B.finite
  let P := minpoly R B.gen
  obtain ‚ü®n, hn‚ü© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  have finrank_K_L : Module.finrank K L = B.dim := B.finrank
  have deg_K_P : (minpoly K B.gen).natDegree = B.dim := B.natDegree_minpoly
  have deg_R_P : P.natDegree = B.dim := by
    rw [‚Üê deg_K_P, minpoly.isIntegrallyClosed_eq_field_fractions' K hBint,
      (minpoly.monic hBint).natDegree_map (algebraMap R K)]
  choose! f hf using
    hei.isWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le (minpoly.aeval R B.gen)
      (minpoly.monic hBint)
  simp only [P, (minpoly.monic hBint).natDegree_map, deg_R_P] at hf
  -- The Eisenstein condition shows that `p` divides `Q.coeff 0`
  -- if `p^n.succ` divides the following multiple of `Q.coeff 0^n.succ`:
  suffices
      p ^ n.succ ‚à£ Q.coeff 0 ^ n.succ * ((-1) ^ (n.succ * n) * (minpoly R B.gen).coeff 0 ^ n) by
    have hndiv : ¬¨p ^ 2 ‚à£ (minpoly R B.gen).coeff 0 := fun h =>
      hei.notMem ((span_singleton_pow p 2).symm ‚ñ∏ Ideal.mem_span_singleton.2 h)
    refine @Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd R _ _ _ _ n hp (?_ : _ ‚à£ _) hndiv
    convert (IsUnit.dvd_mul_right ‚ü®(-1) ^ (n.succ * n), rfl‚ü©).mpr this using 1
    push_cast
    ring_nf
    rw [mul_comm _ 2, pow_mul, neg_one_sq, one_pow, mul_one]
  -- We claim the quotient of `Q^n * _` by `p^n` is the following `r`:
  have aux : ‚àÄ i ‚àà (range (Q.natDegree + 1)).erase 0, B.dim ‚â§ i + n := by grind
  have hintsum :
    IsIntegral R
      (z * B.gen ^ n - ‚àë x ‚àà (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ f (x + n)) := by
    refine (hzint.mul (hBint.pow _)).sub (.sum _ fun i hi => .smul _ ?_)
    exact adjoin_le_integralClosure hBint (hf _ (aux i hi)).1
  obtain ‚ü®r, hr‚ü© := isIntegral_iff.1 (isIntegral_norm K hintsum)
  use r
  -- Do the computation in `K` so we can work in terms of `z` instead of `r`.
  apply IsFractionRing.injective R K
  simp only [map_mul, map_pow, map_neg, map_one]
  -- Both sides are actually norms:
  calc
    _ = norm K (Q.coeff 0 ‚Ä¢ B.gen ^ n) := ?_
    _ = norm K (p ‚Ä¢ (z * B.gen ^ n) -
          ‚àë x ‚àà (range (Q.natDegree + 1)).erase 0, p ‚Ä¢ Q.coeff x ‚Ä¢ f (x + n)) :=
        (congr_arg (norm K) (eq_sub_of_add_eq ?_))
    _ = _ := ?_
  ¬∑ simp only [Algebra.smul_def, algebraMap_apply R K L, Algebra.norm_algebraMap, map_mul,
      map_pow, finrank_K_L, PowerBasis.norm_gen_eq_coeff_zero_minpoly,
      minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, coeff_map, ‚Üê hn]
    ring
  swap
  ¬∑ simp_rw [‚Üê smul_sum, ‚Üê smul_sub, Algebra.smul_def p, algebraMap_apply R K L, map_mul,
      Algebra.norm_algebraMap, finrank_K_L, hr, ‚Üê hn]
  calc
    _ = (Q.coeff 0 ‚Ä¢ ‚Üë1 + ‚àë x ‚àà (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ B.gen ^ x) *
          B.gen ^ n := ?_
    _ = (Q.coeff 0 ‚Ä¢ B.gen ^ 0 +
        ‚àë x ‚àà (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ B.gen ^ x) * B.gen ^ n := by
      rw [pow_zero]
    _ = aeval B.gen Q * B.gen ^ n := ?_
    _ = _ := by rw [hQ, Algebra.smul_mul_assoc]
  ¬∑ have : ‚àÄ i ‚àà (range (Q.natDegree + 1)).erase 0,
        Q.coeff i ‚Ä¢ (B.gen ^ i * B.gen ^ n) = p ‚Ä¢ Q.coeff i ‚Ä¢ f (i + n) := by
      intro i hi
      rw [‚Üê pow_add, ‚Üê (hf _ (aux i hi)).2, ‚Üê Algebra.smul_def, smul_smul, mul_comm _ p, smul_smul]
    simp only [add_mul, smul_mul_assoc, one_mul, sum_mul, sum_congr rfl this]
  ¬∑ rw [aeval_eq_sum_range,
      Finset.add_sum_erase (range (Q.natDegree + 1)) fun i => Q.coeff i ‚Ä¢ B.gen ^ i]
    simp

theorem mem_adjoin_of_dvd_coeff_of_dvd_aeval {A B : Type*} [CommSemiring A] [Ring B]
    [Algebra A B] [NoZeroSMulDivisors A B] {Q : A[X]} {p : A} {x z : B} (hp : p ‚â† 0)
    (hQ : ‚àÄ i ‚àà range (Q.natDegree + 1), p ‚à£ Q.coeff i) (hz : aeval x Q = p ‚Ä¢ z) :
    z ‚àà adjoin A ({x} : Set B) := by
  choose! f hf using hQ
  rw [aeval_eq_sum_range, sum_range] at hz
  conv_lhs at hz =>
    congr
    next => skip
    ext i
    rw [hf i (mem_range.2 (Fin.is_lt i)), ‚Üê smul_smul]
  rw [‚Üê smul_sum] at hz
  rw [‚Üê smul_right_injective _ hp hz]
  exact
    Subalgebra.sum_mem _ fun _ _ =>
      Subalgebra.smul_mem _ (Subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton _)) _) _

/-- Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be an extension
of `K`, generated by an integral power basis `B` such that the minimal polynomial of `B.gen` is
Eisenstein at `p`. Given `z : L` integral over `R`, if `p ‚Ä¢ z ‚àà adjoin R {B.gen}`, then
`z ‚àà adjoin R {B.gen}`. -/
theorem mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}
    (hp : Prime p) (hBint : IsIntegral R B.gen) {z : L} (hzint : IsIntegral R z)
    (hz : p ‚Ä¢ z ‚àà adjoin R ({B.gen} : Set L)) (hei : (minpoly R B.gen).IsEisensteinAt ùìü) :
    z ‚àà adjoin R ({B.gen} : Set L) := by
  -- First define some abbreviations.
  have hndiv : ¬¨p ^ 2 ‚à£ (minpoly R B.gen).coeff 0 := fun h =>
    hei.notMem ((span_singleton_pow p 2).symm ‚ñ∏ Ideal.mem_span_singleton.2 h)
  have := B.finite
  set P := minpoly R B.gen with hP
  obtain ‚ü®n, hn‚ü© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  haveI : NoZeroSMulDivisors R L := NoZeroSMulDivisors.trans_faithfulSMul R K L
  let _ := P.map (algebraMap R L)
  -- There is a polynomial `Q` such that `p ‚Ä¢ z = aeval B.gen Q`. We can assume that
  -- `Q.degree < P.degree` and `Q ‚â† 0`.
  rw [adjoin_singleton_eq_range_aeval] at hz
  obtain ‚ü®Q‚ÇÅ, hQ‚ü© := hz
  set Q := Q‚ÇÅ %‚Çò P with hQ‚ÇÅ
  replace hQ : aeval B.gen Q = p ‚Ä¢ z := by
    rw [‚Üê modByMonic_add_div Q‚ÇÅ (minpoly.monic hBint)] at hQ
    simpa using hQ
  by_cases hQzero : Q = 0
  ¬∑ simp only [hQzero, Algebra.smul_def, zero_eq_mul, aeval_zero] at hQ
    rcases hQ with H | H‚ÇÅ
    ¬∑ have : Function.Injective (algebraMap R L) := by
        rw [algebraMap_eq R K L]
        exact (algebraMap K L).injective.comp (IsFractionRing.injective R K)
      exfalso
      exact hp.ne_zero ((injective_iff_map_eq_zero _).1 this _ H)
    ¬∑ rw [H‚ÇÅ]
      exact Subalgebra.zero_mem _
  -- It is enough to prove that all coefficients of `Q` are divisible by `p`, by induction.
  -- The base case is `dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt`.
  refine mem_adjoin_of_dvd_coeff_of_dvd_aeval hp.ne_zero (fun i => ?_) hQ
  induction i using Nat.case_strong_induction_on with
  | hz =>
    intro
    exact dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt hp hBint hQ hzint hei
  | hi j hind =>
    intro hj
    convert hp.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd (n := n) _ hndiv
    -- Two technical results we will need about `P.natDegree` and `Q.natDegree`.
    have H := degree_modByMonic_lt Q‚ÇÅ (minpoly.monic hBint)
    rw [‚Üê hQ‚ÇÅ, ‚Üê hP] at H
    replace H := Nat.lt_iff_add_one_le.1
      (lt_of_lt_of_le
        (lt_of_le_of_lt (Nat.lt_iff_add_one_le.1 (Nat.lt_of_succ_lt_succ (mem_range.1 hj)))
          (lt_succ_self _)) (Nat.lt_iff_add_one_le.1 ((natDegree_lt_natDegree_iff hQzero).2 H)))
    have Hj : Q.natDegree + 1 = j + 1 + (Q.natDegree - j) := by
      rw [‚Üê add_comm 1, ‚Üê add_comm 1, add_assoc, add_right_inj,
        ‚Üê Nat.add_sub_assoc (Nat.lt_of_succ_lt_succ (mem_range.1 hj)).le, add_comm,
        Nat.add_sub_cancel]
    -- By induction hypothesis we can find `g : ‚Ñï ‚Üí R` such that
    -- `k ‚àà range (j + 1) ‚Üí Q.coeff k ‚Ä¢ B.gen ^ k = (algebraMap R L) p * g k ‚Ä¢ B.gen ^ k`-
    choose! g hg using hind
    replace hg : ‚àÄ k ‚àà range (j + 1), Q.coeff k ‚Ä¢ B.gen ^ k =
        algebraMap R L p * g k ‚Ä¢ B.gen ^ k := by
      intro k hk
      rw [hg k (mem_range_succ_iff.1 hk)
        (mem_range_succ_iff.2
          (le_trans (mem_range_succ_iff.1 hk) (succ_le_iff.1 (mem_range_succ_iff.1 hj)).le)),
        Algebra.smul_def, Algebra.smul_def, RingHom.map_mul, mul_assoc]
    -- Since `minpoly R B.gen` is Eisenstein, we can find `f : ‚Ñï ‚Üí L` such that
    -- `(map (algebraMap R L) (minpoly R B.gen)).nat_degree ‚â§ i` implies `f i ‚àà adjoin R {B.gen}`
    -- and `(algebraMap R L) p * f i = B.gen ^ i`. We will also need `hf‚ÇÅ`, a reformulation of this
    -- property.
    choose! f hf using
      IsWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le (minpoly.aeval R B.gen)
        (minpoly.monic hBint) hei.isWeaklyEisensteinAt
    have hf‚ÇÅ : ‚àÄ k ‚àà (range (Q.natDegree - j)).erase 0,
        Q.coeff (j + 1 + k) ‚Ä¢ B.gen ^ (j + 1 + k) * B.gen ^ (P.natDegree - (j + 2)) =
        (algebraMap R L) p * Q.coeff (j + 1 + k) ‚Ä¢ f (k + P.natDegree - 1) := by
      intro k hk
      rw [smul_mul_assoc, ‚Üê pow_add, ‚Üê Nat.add_sub_assoc H, add_comm (j + 1) 1,
        add_assoc (j + 1), add_comm _ (k + P.natDegree), Nat.add_sub_add_right,
        ‚Üê (hf (k + P.natDegree - 1) _).2, mul_smul_comm]
      rw [(minpoly.monic hBint).natDegree_map, add_comm, Nat.add_sub_assoc, le_add_iff_nonneg_right]
      ¬∑ exact Nat.zero_le _
      ¬∑ refine one_le_iff_ne_zero.2 fun h => ?_
        rw [h] at hk
        simp at hk
    -- The Eisenstein condition shows that `p` divides `Q.coeff j`
    -- if `p^n.succ` divides the following multiple of `Q.coeff (succ j)^n.succ`:
    suffices
        p ^ n.succ ‚à£ Q.coeff (succ j) ^ n.succ *
          (minpoly R B.gen).coeff 0 ^ (succ j + (P.natDegree - (j + 2))) by
      convert this
      rw [Nat.succ_eq_add_one, add_assoc, ‚Üê Nat.add_sub_assoc H, add_comm (j + 1),
        Nat.add_sub_add_left, ‚Üê Nat.add_sub_assoc, Nat.add_sub_add_left, hP, ‚Üê
        (minpoly.monic hBint).natDegree_map (algebraMap R K), ‚Üê
        minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, natDegree_minpoly, hn, Nat.sub_one,
        Nat.pred_succ]
      cutsat
    -- Using `hQ : aeval B.gen Q = p ‚Ä¢ z`, we write `p ‚Ä¢ z` as a sum of terms of degree less than
    -- `j+1`, that are multiples of `p` by induction, and terms of degree at least `j+1`.
    rw [aeval_eq_sum_range, Hj, range_add, sum_union (disjoint_range_addLeftEmbedding _ _),
      sum_congr rfl hg, add_comm] at hQ
    -- We multiply this equality by `B.gen ^ (P.natDegree-(j+2))`, so we can use `hf‚ÇÅ` on the terms
    -- we didn't know were multiples of `p`, and we take the norm on both sides.
    replace hQ := congr_arg (fun x => x * B.gen ^ (P.natDegree - (j + 2))) hQ
    simp_rw [sum_map, addLeftEmbedding_apply, add_mul, sum_mul, mul_assoc] at hQ
    rw [‚Üê insert_erase
      (mem_range.2 (tsub_pos_iff_lt.2 <| Nat.lt_of_succ_lt_succ <| mem_range.1 hj)),
      sum_insert (notMem_erase 0 _), add_zero, sum_congr rfl hf‚ÇÅ, ‚Üê mul_sum, ‚Üê mul_sum, add_assoc,
      ‚Üê mul_add, smul_mul_assoc, ‚Üê pow_add, Algebra.smul_def] at hQ
    replace hQ := congr_arg (norm K) (eq_sub_of_add_eq hQ)
    -- We obtain an equality of elements of `K`, but everything is integral, so we can move to `R`
    -- and simplify `hQ`.
    have hintsum : IsIntegral R (z * B.gen ^ (P.natDegree - (j + 2)) -
        (‚àë x ‚àà (range (Q.natDegree - j)).erase 0,
          Q.coeff (j + 1 + x) ‚Ä¢ f (x + P.natDegree - 1) +
            ‚àë x ‚àà range (j + 1), g x ‚Ä¢ B.gen ^ x * B.gen ^ (P.natDegree - (j + 2)))) := by
      refine (hzint.mul (hBint.pow _)).sub
        (.add (.sum _ fun k hk => .smul _ ?_)
          (.sum _ fun k _ => .mul (.smul _ (.pow hBint _)) (hBint.pow _)))
      refine adjoin_le_integralClosure hBint (hf _ ?_).1
      rw [(minpoly.monic hBint).natDegree_map (algebraMap R L)]
      rw [add_comm, Nat.add_sub_assoc, le_add_iff_nonneg_right]
      ¬∑ exact _root_.zero_le _
      ¬∑ refine one_le_iff_ne_zero.2 fun h => ?_
        rw [h] at hk
        simp at hk
    obtain ‚ü®r, hr‚ü© := isIntegral_iff.1 (isIntegral_norm K hintsum)
    rw [Algebra.smul_def, mul_assoc, ‚Üê mul_sub, map_mul, algebraMap_apply R K L, map_pow,
      Algebra.norm_algebraMap, map_mul, algebraMap_apply R K L, Algebra.norm_algebraMap,
      finrank B, ‚Üê hr, PowerBasis.norm_gen_eq_coeff_zero_minpoly,
      minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, coeff_map,
      show (-1 : K) = algebraMap R K (-1) by simp, ‚Üê map_pow, ‚Üê map_pow, ‚Üê map_mul, ‚Üê
      map_pow, ‚Üê map_mul, ‚Üê map_pow, ‚Üê map_mul] at hQ
    -- We can now finish the proof.
    have hppdiv : p ^ B.dim ‚à£ p ^ B.dim * r := dvd_mul_of_dvd_left dvd_rfl _
    rwa [‚Üê IsFractionRing.injective R K hQ, mul_comm, ‚Üê Units.coe_neg_one, mul_pow, ‚Üê
      Units.val_pow_eq_pow_val, ‚Üê Units.val_pow_eq_pow_val, mul_assoc,
      Units.dvd_mul_left, mul_comm, ‚Üê Nat.succ_eq_add_one, hn] at hppdiv

/-- Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be an extension
of `K`, generated by an integral power basis `B` such that the minimal polynomial of `B.gen` is
Eisenstein at `p`. Given `z : L` integral over `R`, if `p ^ n ‚Ä¢ z ‚àà adjoin R {B.gen}`, then
`z ‚àà adjoin R {B.gen}`. Together with `Algebra.discr_mul_isIntegral_mem_adjoin` this result often
allows to compute the ring of integers of `L`. -/
theorem mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}
    (hp : Prime p) (hBint : IsIntegral R B.gen) {n : ‚Ñï} {z : L} (hzint : IsIntegral R z)
    (hz : p ^ n ‚Ä¢ z ‚àà adjoin R ({B.gen} : Set L)) (hei : (minpoly R B.gen).IsEisensteinAt ùìü) :
    z ‚àà adjoin R ({B.gen} : Set L) := by
  induction n with
  | zero => simpa using hz
  | succ n hn =>
    rw [_root_.pow_succ', mul_smul] at hz
    exact
      hn (mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt hp hBint (hzint.smul _) hz hei)

end IsIntegral
