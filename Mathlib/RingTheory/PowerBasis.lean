/-
Copyright (c) 2020 Anne Baanen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anne Baanen
-/
import Mathlib.FieldTheory.Minpoly.Field

#align_import ring_theory.power_basis from "leanprover-community/mathlib"@"d1d69e99ed34c95266668af4e288fc1c598b9a7f"

/-!
# Power basis

This file defines a structure `PowerBasis R S`, giving a basis of the
`R`-algebra `S` as a finite list of powers `1, x, ..., x^n`.
For example, if `x` is algebraic over a ring/field, adjoining `x`
gives a `PowerBasis` structure generated by `x`.

## Definitions

* `PowerBasis R A`: a structure containing an `x` and an `n` such that
`1, x, ..., x^n` is a basis for the `R`-algebra `A` (viewed as an `R`-module).

* `finrank (hf : f â‰  0) : FiniteDimensional.finrank K (AdjoinRoot f) = f.natDegree`,
  the dimension of `AdjoinRoot f` equals the degree of `f`

* `PowerBasis.lift (pb : PowerBasis R S)`: if `y : S'` satisfies the same
  equations as `pb.gen`, this is the map `S â†’â‚[R] S'` sending `pb.gen` to `y`

* `PowerBasis.equiv`: if two power bases satisfy the same equations, they are
  equivalent as algebras

## Implementation notes

Throughout this file, `R`, `S`, `A`, `B` ... are `CommRing`s, and `K`, `L`, ... are `Field`s.
`S` is an `R`-algebra, `B` is an `A`-algebra, `L` is a `K`-algebra.

## Tags

power basis, powerbasis

-/


open Polynomial

open Polynomial

variable {R S T : Type*} [CommRing R] [Ring S] [Algebra R S]

variable {A B : Type*} [CommRing A] [CommRing B] [IsDomain B] [Algebra A B]

variable {K : Type*} [Field K]

/-- `pb : PowerBasis R S` states that `1, pb.gen, ..., pb.gen ^ (pb.dim - 1)`
is a basis for the `R`-algebra `S` (viewed as `R`-module).

This is a structure, not a class, since the same algebra can have many power bases.
For the common case where `S` is defined by adjoining an integral element to `R`,
the canonical power basis is given by `{Algebra,IntermediateField}.adjoin.powerBasis`.
-/
-- @[nolint has_nonempty_instance] -- Porting note: doesn't exist
structure PowerBasis (R S : Type*) [CommRing R] [Ring S] [Algebra R S] where
  gen : S
  dim : â„•
  basis : Basis (Fin dim) R S
  basis_eq_pow : âˆ€ (i), basis i = gen ^ (i : â„•)
#align power_basis PowerBasis

-- this is usually not needed because of `basis_eq_pow` but can be needed in some cases;
-- in such circumstances, add it manually using `@[simps dim gen basis]`.
initialize_simps_projections PowerBasis (-basis)

namespace PowerBasis

@[simp]
theorem coe_basis (pb : PowerBasis R S) : â‡‘pb.basis = fun i : Fin pb.dim => pb.gen ^ (i : â„•) :=
  funext pb.basis_eq_pow
#align power_basis.coe_basis PowerBasis.coe_basis

/-- Cannot be an instance because `PowerBasis` cannot be a class. -/
theorem finiteDimensional [Algebra K S] (pb : PowerBasis K S) : FiniteDimensional K S :=
  FiniteDimensional.of_fintype_basis pb.basis
#align power_basis.finite_dimensional PowerBasis.finiteDimensional

theorem finrank [Algebra K S] (pb : PowerBasis K S) : FiniteDimensional.finrank K S = pb.dim := by
  rw [FiniteDimensional.finrank_eq_card_basis pb.basis, Fintype.card_fin]
  -- ğŸ‰ no goals
#align power_basis.finrank PowerBasis.finrank

theorem mem_span_pow' {x y : S} {d : â„•} :
    y âˆˆ Submodule.span R (Set.range fun i : Fin d => x ^ (i : â„•)) â†”
      âˆƒ f : R[X], f.degree < d âˆ§ y = aeval x f := by
  have : (Set.range fun i : Fin d => x ^ (i : â„•)) = (fun i : â„• => x ^ i) '' â†‘(Finset.range d) := by
    ext n
    simp_rw [Set.mem_range, Set.mem_image, Finset.mem_coe, Finset.mem_range]
    exact âŸ¨fun âŸ¨âŸ¨i, hiâŸ©, hyâŸ© => âŸ¨i, hi, hyâŸ©, fun âŸ¨i, hi, hyâŸ© => âŸ¨âŸ¨i, hiâŸ©, hyâŸ©âŸ©
  simp only [this, Finsupp.mem_span_image_iff_total, degree_lt_iff_coeff_zero,
    exists_iff_exists_finsupp, coeff, aeval, evalâ‚‚RingHom', evalâ‚‚_eq_sum, Polynomial.sum, support,
    Finsupp.mem_supported', Finsupp.total, Finsupp.sum, Algebra.smul_def, evalâ‚‚_zero, exists_prop,
    LinearMap.id_coe, evalâ‚‚_one, id.def, not_lt, Finsupp.coe_lsum, LinearMap.coe_smulRight,
    Finset.mem_range, AlgHom.coe_mks, Finset.mem_coe]
  simp_rw [@eq_comm _ y]
  -- âŠ¢ (âˆƒ l, (âˆ€ (x : â„•), d â‰¤ x â†’ â†‘l x = 0) âˆ§ (Finset.sum l.support fun x_1 => â†‘(alg â€¦
  exact Iff.rfl
  -- ğŸ‰ no goals
#align power_basis.mem_span_pow' PowerBasis.mem_span_pow'

theorem mem_span_pow {x y : S} {d : â„•} (hd : d â‰  0) :
    y âˆˆ Submodule.span R (Set.range fun i : Fin d => x ^ (i : â„•)) â†”
      âˆƒ f : R[X], f.natDegree < d âˆ§ y = aeval x f := by
  rw [mem_span_pow']
  -- âŠ¢ (âˆƒ f, degree f < â†‘d âˆ§ y = â†‘(aeval x) f) â†” âˆƒ f, natDegree f < d âˆ§ y = â†‘(aeval â€¦
  constructor <;>
  -- âŠ¢ (âˆƒ f, degree f < â†‘d âˆ§ y = â†‘(aeval x) f) â†’ âˆƒ f, natDegree f < d âˆ§ y = â†‘(aeval â€¦
    Â· rintro âŸ¨f, h, hyâŸ©
      -- âŠ¢ âˆƒ f, natDegree f < d âˆ§ y = â†‘(aeval x) f
      -- âŠ¢ âˆƒ f, degree f < â†‘d âˆ§ y = â†‘(aeval x) f
      -- âŠ¢ natDegree f < d
      refine' âŸ¨f, _, hyâŸ©
      -- âŠ¢ natDegree f < d
      -- âŠ¢ degree f < â†‘d
        -- âŠ¢ 0 < d
      by_cases hf : f = 0
        -- ğŸ‰ no goals
      -- âŠ¢ degree f < â†‘d
      -- âŠ¢ natDegree f < d
      Â· simp only [hf, natDegree_zero, degree_zero] at h âŠ¢
        -- ğŸ‰ no goals
        -- âŠ¢ âŠ¥ < â†‘d
        first | exact lt_of_le_of_ne (Nat.zero_le d) hd.symm | exact WithBot.bot_lt_coe d
        -- ğŸ‰ no goals
      simp_all only [degree_eq_natDegree hf]
      -- âŠ¢ â†‘(natDegree f) < â†‘d
      Â· first | exact WithBot.coe_lt_coe.1 h | exact WithBot.coe_lt_coe.2 h
        -- ğŸ‰ no goals
#align power_basis.mem_span_pow PowerBasis.mem_span_pow

theorem dim_ne_zero [Nontrivial S] (pb : PowerBasis R S) : pb.dim â‰  0 := fun h =>
  not_nonempty_iff.mpr (h.symm â–¸ Fin.isEmpty : IsEmpty (Fin pb.dim)) pb.basis.index_nonempty
#align power_basis.dim_ne_zero PowerBasis.dim_ne_zero

theorem dim_pos [Nontrivial S] (pb : PowerBasis R S) : 0 < pb.dim :=
  Nat.pos_of_ne_zero pb.dim_ne_zero
#align power_basis.dim_pos PowerBasis.dim_pos

theorem exists_eq_aeval [Nontrivial S] (pb : PowerBasis R S) (y : S) :
    âˆƒ f : R[X], f.natDegree < pb.dim âˆ§ y = aeval pb.gen f :=
  (mem_span_pow pb.dim_ne_zero).mp (by simpa using pb.basis.mem_span y)
                                       -- ğŸ‰ no goals
#align power_basis.exists_eq_aeval PowerBasis.exists_eq_aeval

theorem exists_eq_aeval' (pb : PowerBasis R S) (y : S) : âˆƒ f : R[X], y = aeval pb.gen f := by
  nontriviality S
  -- âŠ¢ âˆƒ f, y = â†‘(aeval pb.gen) f
  obtain âŸ¨f, _, hfâŸ© := exists_eq_aeval pb y
  -- âŠ¢ âˆƒ f, y = â†‘(aeval pb.gen) f
  exact âŸ¨f, hfâŸ©
  -- ğŸ‰ no goals
#align power_basis.exists_eq_aeval' PowerBasis.exists_eq_aeval'

theorem algHom_ext {S' : Type*} [Semiring S'] [Algebra R S'] (pb : PowerBasis R S)
    â¦ƒf g : S â†’â‚[R] S'â¦„ (h : f pb.gen = g pb.gen) : f = g := by
  ext x
  -- âŠ¢ â†‘f x = â†‘g x
  obtain âŸ¨f, rflâŸ© := pb.exists_eq_aeval' x
  -- âŠ¢ â†‘fâœ (â†‘(aeval pb.gen) f) = â†‘g (â†‘(aeval pb.gen) f)
  rw [â† Polynomial.aeval_algHom_apply, â† Polynomial.aeval_algHom_apply, h]
  -- ğŸ‰ no goals
#align power_basis.alg_hom_ext PowerBasis.algHom_ext

section minpoly

open BigOperators

variable [Algebra A S]

/-- `pb.minpolyGen` is the minimal polynomial for `pb.gen`. -/
noncomputable def minpolyGen (pb : PowerBasis A S) : A[X] :=
  X ^ pb.dim - âˆ‘ i : Fin pb.dim, C (pb.basis.repr (pb.gen ^ pb.dim) i) * X ^ (i : â„•)
#align power_basis.minpoly_gen PowerBasis.minpolyGen

theorem aeval_minpolyGen (pb : PowerBasis A S) : aeval pb.gen (minpolyGen pb) = 0 := by
  simp_rw [minpolyGen, AlgHom.map_sub, AlgHom.map_sum, AlgHom.map_mul, AlgHom.map_pow, aeval_C, â†
    Algebra.smul_def, aeval_X]
  refine' sub_eq_zero.mpr ((pb.basis.total_repr (pb.gen ^ pb.dim)).symm.trans _)
  -- âŠ¢ â†‘(Finsupp.total (Fin pb.dim) S A â†‘pb.basis) (â†‘pb.basis.repr (pb.gen ^ pb.dim â€¦
  rw [Finsupp.total_apply, Finsupp.sum_fintype] <;>
  -- âŠ¢ âˆ‘ i : Fin pb.dim, â†‘(â†‘pb.basis.repr (pb.gen ^ pb.dim)) i â€¢ â†‘pb.basis i = âˆ‘ x  â€¦
    simp only [pb.coe_basis, zero_smul, eq_self_iff_true, imp_true_iff]
    -- ğŸ‰ no goals
    -- ğŸ‰ no goals
#align power_basis.aeval_minpoly_gen PowerBasis.aeval_minpolyGen

theorem minpolyGen_monic (pb : PowerBasis A S) : Monic (minpolyGen pb) := by
  nontriviality A
  -- âŠ¢ Monic (minpolyGen pb)
  apply (monic_X_pow _).sub_of_left _
  -- âŠ¢ degree (âˆ‘ i : Fin pb.dim, â†‘C (â†‘(â†‘pb.basis.repr (pb.gen ^ pb.dim)) i) * X ^ â†‘ â€¦
  rw [degree_X_pow]
  -- âŠ¢ degree (âˆ‘ i : Fin pb.dim, â†‘C (â†‘(â†‘pb.basis.repr (pb.gen ^ pb.dim)) i) * X ^ â†‘ â€¦
  exact degree_sum_fin_lt _
  -- ğŸ‰ no goals
#align power_basis.minpoly_gen_monic PowerBasis.minpolyGen_monic

theorem dim_le_natDegree_of_root (pb : PowerBasis A S) {p : A[X]} (ne_zero : p â‰  0)
    (root : aeval pb.gen p = 0) : pb.dim â‰¤ p.natDegree := by
  refine' le_of_not_lt fun hlt => ne_zero _
  -- âŠ¢ p = 0
  rw [p.as_sum_range' _ hlt, Finset.sum_range]
  -- âŠ¢ âˆ‘ i : Fin pb.dim, â†‘(monomial â†‘i) (coeff p â†‘i) = 0
  refine' Fintype.sum_eq_zero _ fun i => _
  -- âŠ¢ â†‘(monomial â†‘i) (coeff p â†‘i) = 0
  simp_rw [aeval_eq_sum_range' hlt, Finset.sum_range, â† pb.basis_eq_pow] at root
  -- âŠ¢ â†‘(monomial â†‘i) (coeff p â†‘i) = 0
  have := Fintype.linearIndependent_iff.1 pb.basis.linearIndependent _ root
  -- âŠ¢ â†‘(monomial â†‘i) (coeff p â†‘i) = 0
  rw [this, monomial_zero_right]
  -- ğŸ‰ no goals
#align power_basis.dim_le_nat_degree_of_root PowerBasis.dim_le_natDegree_of_root

theorem dim_le_degree_of_root (h : PowerBasis A S) {p : A[X]} (ne_zero : p â‰  0)
    (root : aeval h.gen p = 0) : â†‘h.dim â‰¤ p.degree := by
  rw [degree_eq_natDegree ne_zero]
  -- âŠ¢ â†‘h.dim â‰¤ â†‘(natDegree p)
  exact WithBot.coe_le_coe.2 (h.dim_le_natDegree_of_root ne_zero root)
  -- ğŸ‰ no goals
#align power_basis.dim_le_degree_of_root PowerBasis.dim_le_degree_of_root

theorem degree_minpolyGen [Nontrivial A] (pb : PowerBasis A S) :
    degree (minpolyGen pb) = pb.dim := by
  unfold minpolyGen
  -- âŠ¢ degree (X ^ pb.dim - âˆ‘ i : Fin pb.dim, â†‘C (â†‘(â†‘pb.basis.repr (pb.gen ^ pb.dim â€¦
  rw [degree_sub_eq_left_of_degree_lt] <;> rw [degree_X_pow]
  -- âŠ¢ degree (X ^ pb.dim) = â†‘pb.dim
                                           -- ğŸ‰ no goals
                                           -- âŠ¢ degree (âˆ‘ i : Fin pb.dim, â†‘C (â†‘(â†‘pb.basis.repr (pb.gen ^ pb.dim)) i) * X ^ â†‘ â€¦
  apply degree_sum_fin_lt
  -- ğŸ‰ no goals
#align power_basis.degree_minpoly_gen PowerBasis.degree_minpolyGen

theorem natDegree_minpolyGen [Nontrivial A] (pb : PowerBasis A S) :
    natDegree (minpolyGen pb) = pb.dim :=
  natDegree_eq_of_degree_eq_some pb.degree_minpolyGen
#align power_basis.nat_degree_minpoly_gen PowerBasis.natDegree_minpolyGen

@[simp]
theorem minpolyGen_eq (pb : PowerBasis A S) : pb.minpolyGen = minpoly A pb.gen := by
  nontriviality A
  -- âŠ¢ minpolyGen pb = minpoly A pb.gen
  refine' minpoly.unique' A _ pb.minpolyGen_monic pb.aeval_minpolyGen fun q hq =>
    or_iff_not_imp_left.2 fun hn0 h0 => _
  exact (pb.dim_le_degree_of_root hn0 h0).not_lt (pb.degree_minpolyGen â–¸ hq)
  -- ğŸ‰ no goals
#align power_basis.minpoly_gen_eq PowerBasis.minpolyGen_eq

theorem isIntegral_gen (pb : PowerBasis A S) : IsIntegral A pb.gen :=
  âŸ¨minpolyGen pb, minpolyGen_monic pb, aeval_minpolyGen pbâŸ©
#align power_basis.is_integral_gen PowerBasis.isIntegral_gen

@[simp]
theorem degree_minpoly [Nontrivial A] (pb : PowerBasis A S) : degree (minpoly A pb.gen) = pb.dim :=
  by rw [â† minpolyGen_eq, degree_minpolyGen]
     -- ğŸ‰ no goals
#align power_basis.degree_minpoly PowerBasis.degree_minpoly

@[simp]
theorem natDegree_minpoly [Nontrivial A] (pb : PowerBasis A S) :
    (minpoly A pb.gen).natDegree = pb.dim := by rw [â† minpolyGen_eq, natDegree_minpolyGen]
                                                -- ğŸ‰ no goals
#align power_basis.nat_degree_minpoly PowerBasis.natDegree_minpoly

protected theorem leftMulMatrix (pb : PowerBasis A S) : Algebra.leftMulMatrix pb.basis pb.gen =
    @Matrix.of (Fin pb.dim) (Fin pb.dim) _ fun i j =>
      if â†‘j + 1 = pb.dim then -pb.minpolyGen.coeff â†‘i else if (i : â„•) = j + 1 then 1 else 0 := by
  cases subsingleton_or_nontrivial A; Â· apply Subsingleton.elim
  -- âŠ¢ â†‘(Algebra.leftMulMatrix pb.basis) pb.gen = â†‘Matrix.of fun i j => if â†‘j + 1 = â€¦
                                        -- ğŸ‰ no goals
  rw [Algebra.leftMulMatrix_apply, â† LinearEquiv.eq_symm_apply, LinearMap.toMatrix_symm]
  -- âŠ¢ â†‘(Algebra.lmul A S) pb.gen = â†‘(Matrix.toLin pb.basis pb.basis) (â†‘Matrix.of f â€¦
  refine' pb.basis.ext fun k => _
  -- âŠ¢ â†‘(â†‘(Algebra.lmul A S) pb.gen) (â†‘pb.basis k) = â†‘(â†‘(Matrix.toLin pb.basis pb.b â€¦
  simp_rw [Matrix.toLin_self, Matrix.of_apply, pb.basis_eq_pow]
  -- âŠ¢ â†‘(â†‘(Algebra.lmul A S) pb.gen) (pb.gen ^ â†‘k) = âˆ‘ x : Fin pb.dim, (if â†‘k + 1 = â€¦
  apply (pow_succ _ _).symm.trans
  -- âŠ¢ pb.gen ^ (â†‘k + 1) = âˆ‘ x : Fin pb.dim, (if â†‘k + 1 = pb.dim then -coeff (minpo â€¦
  split_ifs with h
  -- âŠ¢ pb.gen ^ (â†‘k + 1) = âˆ‘ x : Fin pb.dim, -coeff (minpolyGen pb) â†‘x â€¢ pb.gen ^ â†‘x
  Â· simp_rw [h, neg_smul, Finset.sum_neg_distrib, eq_neg_iff_add_eq_zero]
    -- âŠ¢ pb.gen ^ pb.dim + âˆ‘ x : Fin pb.dim, coeff (minpolyGen pb) â†‘x â€¢ pb.gen ^ â†‘x = 0
    convert pb.aeval_minpolyGen
    -- âŠ¢ pb.gen ^ pb.dim + âˆ‘ x : Fin pb.dim, coeff (minpolyGen pb) â†‘x â€¢ pb.gen ^ â†‘x = â€¦
    rw [add_comm, aeval_eq_sum_range, Finset.sum_range_succ, â† leadingCoeff,
      pb.minpolyGen_monic.leadingCoeff, one_smul, natDegree_minpolyGen, Finset.sum_range]
  Â· rw [Fintype.sum_eq_single (âŸ¨(k : â„•) + 1, lt_of_le_of_ne k.2 hâŸ© : Fin pb.dim), if_pos, one_smul]
    -- âŠ¢ â†‘{ val := â†‘k + 1, isLt := (_ : â†‘k + 1 < pb.dim) } = â†‘k + 1
    Â· rfl
      -- ğŸ‰ no goals
    intro x hx
    -- âŠ¢ (if â†‘x = â†‘k + 1 then 1 else 0) â€¢ pb.gen ^ â†‘x = 0
    rw [if_neg, zero_smul]
    -- âŠ¢ Â¬â†‘x = â†‘k + 1
    apply mt Fin.ext hx
    -- ğŸ‰ no goals
#align power_basis.left_mul_matrix PowerBasis.leftMulMatrix

end minpoly

section Equiv

variable [Algebra A S] {S' : Type*} [Ring S'] [Algebra A S']

theorem constr_pow_aeval (pb : PowerBasis A S) {y : S'} (hy : aeval y (minpoly A pb.gen) = 0)
    (f : A[X]) : pb.basis.constr A (fun i => y ^ (i : â„•)) (aeval pb.gen f) = aeval y f := by
  cases subsingleton_or_nontrivial A
  -- âŠ¢ â†‘(â†‘(Basis.constr pb.basis A) fun i => y ^ â†‘i) (â†‘(aeval pb.gen) f) = â†‘(aeval  â€¦
  Â· rw [(Subsingleton.elim _ _ : f = 0), aeval_zero, map_zero, aeval_zero]
    -- ğŸ‰ no goals
  rw [â† aeval_modByMonic_eq_self_of_root (minpoly.monic pb.isIntegral_gen) (minpoly.aeval _ _), â†
    @aeval_modByMonic_eq_self_of_root _ _ _ _ _ f _ (minpoly.monic pb.isIntegral_gen) y hy]
  by_cases hf : f %â‚˜ minpoly A pb.gen = 0
  -- âŠ¢ â†‘(â†‘(Basis.constr pb.basis A) fun i => y ^ â†‘i) (â†‘(aeval pb.gen) (f %â‚˜ minpoly â€¦
  Â· simp only [hf, AlgHom.map_zero, LinearMap.map_zero]
    -- ğŸ‰ no goals
  have : (f %â‚˜ minpoly A pb.gen).natDegree < pb.dim := by
    rw [â† pb.natDegree_minpoly]
    apply natDegree_lt_natDegree hf
    exact degree_modByMonic_lt _ (minpoly.monic pb.isIntegral_gen)
  rw [aeval_eq_sum_range' this, aeval_eq_sum_range' this, LinearMap.map_sum]
  -- âŠ¢ (Finset.sum (Finset.range pb.dim) fun i => â†‘(â†‘(Basis.constr pb.basis A) fun  â€¦
  refine' Finset.sum_congr rfl fun i (hi : i âˆˆ Finset.range pb.dim) => _
  -- âŠ¢ â†‘(â†‘(Basis.constr pb.basis A) fun i => y ^ â†‘i) (coeff (f %â‚˜ minpoly A pb.gen) â€¦
  rw [Finset.mem_range] at hi
  -- âŠ¢ â†‘(â†‘(Basis.constr pb.basis A) fun i => y ^ â†‘i) (coeff (f %â‚˜ minpoly A pb.gen) â€¦
  rw [LinearMap.map_smul]
  -- âŠ¢ coeff (f %â‚˜ minpoly A pb.gen) i â€¢ â†‘(â†‘(Basis.constr pb.basis A) fun i => y ^  â€¦
  congr
  -- âŠ¢ â†‘(â†‘(Basis.constr pb.basis A) fun i => y ^ â†‘i) (pb.gen ^ i) = y ^ i
  rw [â† Fin.val_mk hi, â† pb.basis_eq_pow âŸ¨i, hiâŸ©, Basis.constr_basis]
  -- ğŸ‰ no goals
#align power_basis.constr_pow_aeval PowerBasis.constr_pow_aeval

theorem constr_pow_gen (pb : PowerBasis A S) {y : S'} (hy : aeval y (minpoly A pb.gen) = 0) :
    pb.basis.constr A (fun i => y ^ (i : â„•)) pb.gen = y := by
  convert pb.constr_pow_aeval hy X <;> rw [aeval_X]
  -- âŠ¢ pb.gen = â†‘(aeval pb.gen) X
                                       -- ğŸ‰ no goals
                                       -- ğŸ‰ no goals
#align power_basis.constr_pow_gen PowerBasis.constr_pow_gen

theorem constr_pow_algebraMap (pb : PowerBasis A S) {y : S'} (hy : aeval y (minpoly A pb.gen) = 0)
    (x : A) : pb.basis.constr A (fun i => y ^ (i : â„•)) (algebraMap A S x) = algebraMap A S' x := by
  convert pb.constr_pow_aeval hy (C x) <;> rw [aeval_C]
  -- âŠ¢ â†‘(algebraMap A S) x = â†‘(aeval pb.gen) (â†‘C x)
                                           -- ğŸ‰ no goals
                                           -- ğŸ‰ no goals
#align power_basis.constr_pow_algebra_map PowerBasis.constr_pow_algebraMap

theorem constr_pow_mul (pb : PowerBasis A S) {y : S'} (hy : aeval y (minpoly A pb.gen) = 0)
    (x x' : S) : pb.basis.constr A (fun i => y ^ (i : â„•)) (x * x') =
      pb.basis.constr A (fun i => y ^ (i : â„•)) x * pb.basis.constr A (fun i => y ^ (i : â„•)) x' := by
  obtain âŸ¨f, rflâŸ© := pb.exists_eq_aeval' x
  -- âŠ¢ â†‘(â†‘(Basis.constr pb.basis A) fun i => y ^ â†‘i) (â†‘(aeval pb.gen) f * x') = â†‘(â†‘ â€¦
  obtain âŸ¨g, rflâŸ© := pb.exists_eq_aeval' x'
  -- âŠ¢ â†‘(â†‘(Basis.constr pb.basis A) fun i => y ^ â†‘i) (â†‘(aeval pb.gen) f * â†‘(aeval p â€¦
  simp only [â† aeval_mul, pb.constr_pow_aeval hy]
  -- ğŸ‰ no goals
#align power_basis.constr_pow_mul PowerBasis.constr_pow_mul

/-- `pb.lift y hy` is the algebra map sending `pb.gen` to `y`,
where `hy` states the higher powers of `y` are the same as the higher powers of `pb.gen`.

See `PowerBasis.liftEquiv` for a bundled equiv sending `âŸ¨y, hyâŸ©` to the algebra map.
-/
noncomputable def lift (pb : PowerBasis A S) (y : S') (hy : aeval y (minpoly A pb.gen) = 0) :
    S â†’â‚[A] S' :=
  { pb.basis.constr A fun i => y ^ (i : â„•) with
    map_one' := by convert pb.constr_pow_algebraMap hy 1 using 2 <;> rw [RingHom.map_one]
                   -- âŠ¢ 1 = â†‘(algebraMap A S) 1
                                                                     -- ğŸ‰ no goals
                                                                     -- ğŸ‰ no goals
    map_zero' := by convert pb.constr_pow_algebraMap hy 0 using 2 <;> rw [RingHom.map_zero]
                    -- âŠ¢ 0 = â†‘(algebraMap A S) 0
                                                                      -- ğŸ‰ no goals
                                                                      -- ğŸ‰ no goals
    map_mul' := pb.constr_pow_mul hy
    commutes' := pb.constr_pow_algebraMap hy }
#align power_basis.lift PowerBasis.lift

@[simp]
theorem lift_gen (pb : PowerBasis A S) (y : S') (hy : aeval y (minpoly A pb.gen) = 0) :
    pb.lift y hy pb.gen = y :=
  pb.constr_pow_gen hy
#align power_basis.lift_gen PowerBasis.lift_gen

@[simp]
theorem lift_aeval (pb : PowerBasis A S) (y : S') (hy : aeval y (minpoly A pb.gen) = 0) (f : A[X]) :
    pb.lift y hy (aeval pb.gen f) = aeval y f :=
  pb.constr_pow_aeval hy f
#align power_basis.lift_aeval PowerBasis.lift_aeval

/-- `pb.liftEquiv` states that roots of the minimal polynomial of `pb.gen` correspond to
maps sending `pb.gen` to that root.

This is the bundled equiv version of `PowerBasis.lift`.
If the codomain of the `AlgHom`s is an integral domain, then the roots form a multiset,
see `liftEquiv'` for the corresponding statement.
-/
@[simps]
noncomputable def liftEquiv (pb : PowerBasis A S) :
    (S â†’â‚[A] S') â‰ƒ { y : S' // aeval y (minpoly A pb.gen) = 0 } where
  toFun f := âŸ¨f pb.gen, by rw [aeval_algHom_apply, minpoly.aeval, f.map_zero]âŸ©
                           -- ğŸ‰ no goals
  invFun y := pb.lift y y.2
  left_inv f := pb.algHom_ext <| lift_gen _ _ _
  right_inv y := Subtype.ext <| lift_gen _ _ y.prop
#align power_basis.lift_equiv PowerBasis.liftEquiv

/-- `pb.liftEquiv'` states that elements of the root set of the minimal
polynomial of `pb.gen` correspond to maps sending `pb.gen` to that root. -/
@[simps! (config := { fullyApplied := false })]
noncomputable def liftEquiv' (pb : PowerBasis A S) :
    (S â†’â‚[A] B) â‰ƒ { y : B // y âˆˆ ((minpoly A pb.gen).map (algebraMap A B)).roots } :=
  pb.liftEquiv.trans ((Equiv.refl _).subtypeEquiv fun x => by
    rw [Equiv.refl_apply, mem_roots_iff_aeval_eq_zero]
    -- âŠ¢ â†‘(aeval x) (minpoly A pb.gen) = 0 â†” â†‘(aeval x) (map (algebraMap A B) (minpol â€¦
    Â· simp
      -- ğŸ‰ no goals
    Â· exact map_monic_ne_zero (minpoly.monic pb.isIntegral_gen))
      -- ğŸ‰ no goals
#align power_basis.lift_equiv' PowerBasis.liftEquiv'

/-- There are finitely many algebra homomorphisms `S â†’â‚[A] B` if `S` is of the form `A[x]`
and `B` is an integral domain. -/
noncomputable def AlgHom.fintype (pb : PowerBasis A S) : Fintype (S â†’â‚[A] B) :=
  letI := Classical.decEq B
  Fintype.ofEquiv _ pb.liftEquiv'.symm
#align power_basis.alg_hom.fintype PowerBasis.AlgHom.fintype

/-- `pb.equivOfRoot pb' hâ‚ hâ‚‚` is an equivalence of algebras with the same power basis,
where "the same" means that `pb` is a root of `pb'`s minimal polynomial and vice versa.

See also `PowerBasis.equivOfMinpoly` which takes the hypothesis that the
minimal polynomials are identical.
-/
@[simps! (config := { isSimp := false }) apply]
noncomputable def equivOfRoot (pb : PowerBasis A S) (pb' : PowerBasis A S')
    (hâ‚ : aeval pb.gen (minpoly A pb'.gen) = 0) (hâ‚‚ : aeval pb'.gen (minpoly A pb.gen) = 0) :
    S â‰ƒâ‚[A] S' :=
  AlgEquiv.ofAlgHom (pb.lift pb'.gen hâ‚‚) (pb'.lift pb.gen hâ‚)
    (by
      ext x
      -- âŠ¢ â†‘(AlgHom.comp (lift pb pb'.gen hâ‚‚) (lift pb' pb.gen hâ‚)) x = â†‘(AlgHom.id A S â€¦
      obtain âŸ¨f, hf, rflâŸ© := pb'.exists_eq_aeval' x
      -- âŠ¢ â†‘(AlgHom.comp (lift pb pb'.gen hâ‚‚) (lift pb' pb.gen hâ‚)) (â†‘(aeval pb'.gen) f â€¦
      simp)
      -- ğŸ‰ no goals
    (by
      ext x
      -- âŠ¢ â†‘(AlgHom.comp (lift pb' pb.gen hâ‚) (lift pb pb'.gen hâ‚‚)) x = â†‘(AlgHom.id A S â€¦
      obtain âŸ¨f, hf, rflâŸ© := pb.exists_eq_aeval' x
      -- âŠ¢ â†‘(AlgHom.comp (lift pb' pb.gen hâ‚) (lift pb pb'.gen hâ‚‚)) (â†‘(aeval pb.gen) f) â€¦
      simp)
      -- ğŸ‰ no goals
#align power_basis.equiv_of_root PowerBasis.equivOfRoot

@[simp]
theorem equivOfRoot_aeval (pb : PowerBasis A S) (pb' : PowerBasis A S')
    (hâ‚ : aeval pb.gen (minpoly A pb'.gen) = 0) (hâ‚‚ : aeval pb'.gen (minpoly A pb.gen) = 0)
    (f : A[X]) : pb.equivOfRoot pb' hâ‚ hâ‚‚ (aeval pb.gen f) = aeval pb'.gen f :=
  pb.lift_aeval _ hâ‚‚ _
#align power_basis.equiv_of_root_aeval PowerBasis.equivOfRoot_aeval

@[simp]
theorem equivOfRoot_gen (pb : PowerBasis A S) (pb' : PowerBasis A S')
    (hâ‚ : aeval pb.gen (minpoly A pb'.gen) = 0) (hâ‚‚ : aeval pb'.gen (minpoly A pb.gen) = 0) :
    pb.equivOfRoot pb' hâ‚ hâ‚‚ pb.gen = pb'.gen :=
  pb.lift_gen _ hâ‚‚
#align power_basis.equiv_of_root_gen PowerBasis.equivOfRoot_gen

@[simp]
theorem equivOfRoot_symm (pb : PowerBasis A S) (pb' : PowerBasis A S')
    (hâ‚ : aeval pb.gen (minpoly A pb'.gen) = 0) (hâ‚‚ : aeval pb'.gen (minpoly A pb.gen) = 0) :
    (pb.equivOfRoot pb' hâ‚ hâ‚‚).symm = pb'.equivOfRoot pb hâ‚‚ hâ‚ :=
  rfl
#align power_basis.equiv_of_root_symm PowerBasis.equivOfRoot_symm

/-- `pb.equivOfMinpoly pb' h` is an equivalence of algebras with the same power basis,
where "the same" means that they have identical minimal polynomials.

See also `PowerBasis.equivOfRoot` which takes the hypothesis that each generator is a root of the
other basis' minimal polynomial; `PowerBasis.equivOfRoot` is more general if `A` is not a field.
-/
@[simps! (config := { isSimp := false }) apply]
noncomputable def equivOfMinpoly (pb : PowerBasis A S) (pb' : PowerBasis A S')
    (h : minpoly A pb.gen = minpoly A pb'.gen) : S â‰ƒâ‚[A] S' :=
  pb.equivOfRoot pb' (h â–¸ minpoly.aeval _ _) (h.symm â–¸ minpoly.aeval _ _)
#align power_basis.equiv_of_minpoly PowerBasis.equivOfMinpoly

@[simp]
theorem equivOfMinpoly_aeval (pb : PowerBasis A S) (pb' : PowerBasis A S')
    (h : minpoly A pb.gen = minpoly A pb'.gen) (f : A[X]) :
    pb.equivOfMinpoly pb' h (aeval pb.gen f) = aeval pb'.gen f :=
  pb.equivOfRoot_aeval pb' _ _ _
#align power_basis.equiv_of_minpoly_aeval PowerBasis.equivOfMinpoly_aeval

@[simp]
theorem equivOfMinpoly_gen (pb : PowerBasis A S) (pb' : PowerBasis A S')
    (h : minpoly A pb.gen = minpoly A pb'.gen) : pb.equivOfMinpoly pb' h pb.gen = pb'.gen :=
  pb.equivOfRoot_gen pb' _ _
#align power_basis.equiv_of_minpoly_gen PowerBasis.equivOfMinpoly_gen

@[simp]
theorem equivOfMinpoly_symm (pb : PowerBasis A S) (pb' : PowerBasis A S')
    (h : minpoly A pb.gen = minpoly A pb'.gen) :
    (pb.equivOfMinpoly pb' h).symm = pb'.equivOfMinpoly pb h.symm :=
  rfl
#align power_basis.equiv_of_minpoly_symm PowerBasis.equivOfMinpoly_symm

end Equiv

end PowerBasis

open PowerBasis

/-- Useful lemma to show `x` generates a power basis:
the powers of `x` less than the degree of `x`'s minimal polynomial are linearly independent. -/
theorem linearIndependent_pow [Algebra K S] (x : S) :
    LinearIndependent K fun i : Fin (minpoly K x).natDegree => x ^ (i : â„•) := by
  by_cases IsIntegral K x; swap
  -- âŠ¢ LinearIndependent K fun i => x ^ â†‘i
  -- âŠ¢ LinearIndependent K fun i => x ^ â†‘i
                           -- âŠ¢ LinearIndependent K fun i => x ^ â†‘i
  Â· rw [minpoly.eq_zero h, natDegree_zero]
    -- âŠ¢ LinearIndependent K fun i => x ^ â†‘i
    exact linearIndependent_empty_type
    -- ğŸ‰ no goals
  refine' Fintype.linearIndependent_iff.2 fun g hg i => _
  -- âŠ¢ g i = 0
  simp only at hg
  -- âŠ¢ g i = 0
  simp_rw [Algebra.smul_def, â† aeval_monomial, â† map_sum] at hg
  -- âŠ¢ g i = 0
  apply (fun hn0 => (minpoly.degree_le_of_ne_zero K x (mt (fun h0 => ?_) hn0) hg).not_lt).mtr
  -- âŠ¢ degree (Finset.sum Finset.univ fun x_1 => â†‘(monomial â†‘x_1) (g x_1)) < degree â€¦
  Â· simp_rw [â† C_mul_X_pow_eq_monomial]
    -- âŠ¢ degree (Finset.sum Finset.univ fun x_1 => â†‘C (g x_1) * X ^ â†‘x_1) < degree (m â€¦
    exact (degree_eq_natDegree <| minpoly.ne_zero h).symm â–¸ degree_sum_fin_lt _
    -- ğŸ‰ no goals
  Â· apply_fun lcoeff K i at h0
    -- âŠ¢ g i = 0
    simp_rw [map_sum, lcoeff_apply, coeff_monomial, Fin.val_eq_val, Finset.sum_ite_eq'] at h0
    -- âŠ¢ g i = 0
    exact (if_pos <| Finset.mem_univ _).symm.trans h0
    -- ğŸ‰ no goals
#align linear_independent_pow linearIndependent_pow

theorem IsIntegral.mem_span_pow [Nontrivial R] {x y : S} (hx : IsIntegral R x)
    (hy : âˆƒ f : R[X], y = aeval x f) :
    y âˆˆ Submodule.span R (Set.range fun i : Fin (minpoly R x).natDegree => x ^ (i : â„•)) := by
  obtain âŸ¨f, rflâŸ© := hy
  -- âŠ¢ â†‘(aeval x) f âˆˆ Submodule.span R (Set.range fun i => x ^ â†‘i)
  apply mem_span_pow'.mpr _
  -- âŠ¢ âˆƒ f_1, degree f_1 < â†‘(natDegree (minpoly R x)) âˆ§ â†‘(aeval x) f = â†‘(aeval x) f_1
  have := minpoly.monic hx
  -- âŠ¢ âˆƒ f_1, degree f_1 < â†‘(natDegree (minpoly R x)) âˆ§ â†‘(aeval x) f = â†‘(aeval x) f_1
  refine' âŸ¨f %â‚˜ minpoly R x, (degree_modByMonic_lt _ this).trans_le degree_le_natDegree, _âŸ©
  -- âŠ¢ â†‘(aeval x) f = â†‘(aeval x) (f %â‚˜ minpoly R x)
  conv_lhs => rw [â† modByMonic_add_div f this]
  -- âŠ¢ â†‘(aeval x) (f %â‚˜ minpoly R x + minpoly R x * (f /â‚˜ minpoly R x)) = â†‘(aeval x â€¦
  simp only [add_zero, zero_mul, minpoly.aeval, aeval_add, AlgHom.map_mul]
  -- ğŸ‰ no goals
#align is_integral.mem_span_pow IsIntegral.mem_span_pow

namespace PowerBasis

section Map

variable {S' : Type*} [CommRing S'] [Algebra R S']

/-- `PowerBasis.map pb (e : S â‰ƒâ‚[R] S')` is the power basis for `S'` generated by `e pb.gen`. -/
@[simps dim gen basis]
noncomputable def map (pb : PowerBasis R S) (e : S â‰ƒâ‚[R] S') : PowerBasis R S' where
  dim := pb.dim
  basis := pb.basis.map e.toLinearEquiv
  gen := e pb.gen
  basis_eq_pow i := by rw [Basis.map_apply, pb.basis_eq_pow, e.toLinearEquiv_apply, e.map_pow]
                       -- ğŸ‰ no goals
#align power_basis.map PowerBasis.map

variable [Algebra A S] [Algebra A S']

-- @[simp] -- Porting note: simp can prove this
theorem minpolyGen_map (pb : PowerBasis A S) (e : S â‰ƒâ‚[A] S') :
    (pb.map e).minpolyGen = pb.minpolyGen := by
  dsimp only [minpolyGen, map_dim]
  -- âŠ¢ (X ^ pb.dim - Finset.sum Finset.univ fun i => â†‘C (â†‘(â†‘(map pb e).basis.repr ( â€¦
  -- Turn `Fin (pb.map e).dim` into `Fin pb.dim`
  simp only [LinearEquiv.trans_apply, map_basis, Basis.map_repr, map_gen,
    AlgEquiv.toLinearEquiv_apply, e.toLinearEquiv_symm, AlgEquiv.map_pow,
    AlgEquiv.symm_apply_apply, sub_right_inj]
#align power_basis.minpoly_gen_map PowerBasis.minpolyGen_map

@[simp]
theorem equivOfRoot_map (pb : PowerBasis A S) (e : S â‰ƒâ‚[A] S') (hâ‚ hâ‚‚) :
    pb.equivOfRoot (pb.map e) hâ‚ hâ‚‚ = e := by
  ext x
  -- âŠ¢ â†‘(equivOfRoot pb (map pb e) hâ‚ hâ‚‚) x = â†‘e x
  obtain âŸ¨f, rflâŸ© := pb.exists_eq_aeval' x
  -- âŠ¢ â†‘(equivOfRoot pb (map pb e) hâ‚ hâ‚‚) (â†‘(aeval pb.gen) f) = â†‘e (â†‘(aeval pb.gen) â€¦
  simp [aeval_algEquiv]
  -- ğŸ‰ no goals
#align power_basis.equiv_of_root_map PowerBasis.equivOfRoot_map

@[simp]
theorem equivOfMinpoly_map (pb : PowerBasis A S) (e : S â‰ƒâ‚[A] S')
    (h : minpoly A pb.gen = minpoly A (pb.map e).gen) : pb.equivOfMinpoly (pb.map e) h = e :=
  pb.equivOfRoot_map _ _ _
#align power_basis.equiv_of_minpoly_map PowerBasis.equivOfMinpoly_map

end Map

section Adjoin

open Algebra

theorem adjoin_gen_eq_top (B : PowerBasis R S) : adjoin R ({B.gen} : Set S) = âŠ¤ := by
  rw [â† toSubmodule_eq_top, _root_.eq_top_iff, â† B.basis.span_eq, Submodule.span_le]
  -- âŠ¢ Set.range â†‘B.basis âŠ† â†‘(â†‘Subalgebra.toSubmodule (adjoin R {B.gen}))
  rintro x âŸ¨i, rflâŸ©
  -- âŠ¢ â†‘B.basis i âˆˆ â†‘(â†‘Subalgebra.toSubmodule (adjoin R {B.gen}))
  rw [B.basis_eq_pow i]
  -- âŠ¢ B.gen ^ â†‘i âˆˆ â†‘(â†‘Subalgebra.toSubmodule (adjoin R {B.gen}))
  exact Subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton _)) _
  -- ğŸ‰ no goals
#align power_basis.adjoin_gen_eq_top PowerBasis.adjoin_gen_eq_top

theorem adjoin_eq_top_of_gen_mem_adjoin {B : PowerBasis R S} {x : S}
    (hx : B.gen âˆˆ adjoin R ({x} : Set S)) : adjoin R ({x} : Set S) = âŠ¤ := by
  rw [_root_.eq_top_iff, â† B.adjoin_gen_eq_top]
  -- âŠ¢ adjoin R {B.gen} â‰¤ adjoin R {x}
  refine' adjoin_le _
  -- âŠ¢ {B.gen} âŠ† â†‘(adjoin R {x})
  simp [hx]
  -- ğŸ‰ no goals
#align power_basis.adjoin_eq_top_of_gen_mem_adjoin PowerBasis.adjoin_eq_top_of_gen_mem_adjoin

end Adjoin

end PowerBasis
