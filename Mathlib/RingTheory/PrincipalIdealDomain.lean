/-
Copyright (c) 2018 Chris Hughes. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Chris Hughes, Morenikeji Neri
-/
import Mathlib.Algebra.EuclideanDomain.Instances
import Mathlib.RingTheory.UniqueFactorizationDomain

#align_import ring_theory.principal_ideal_domain from "leanprover-community/mathlib"@"6010cf523816335f7bae7f8584cb2edaace73940"

/-!
# Principal ideal rings and principal ideal domains

A principal ideal ring (PIR) is a ring in which all left ideals are principal. A
principal ideal domain (PID) is an integral domain which is a principal ideal ring.

# Main definitions

Note that for principal ideal domains, one should use
`[IsDomain R] [IsPrincipalIdealRing R]`. There is no explicit definition of a PID.
Theorems about PID's are in the `principal_ideal_ring` namespace.

- `IsPrincipalIdealRing`: a predicate on rings, saying that every left ideal is principal.
- `generator`: a generator of a principal ideal (or more generally submodule)
- `to_unique_factorization_monoid`: a PID is a unique factorization domain

# Main results

- `to_maximal_ideal`: a non-zero prime ideal in a PID is maximal.
- `EuclideanDomain.to_principal_ideal_domain` : a Euclidean domain is a PID.

-/


universe u v

variable {R : Type u} {M : Type v}

open Set Function

open Submodule

open Classical

section

variable [Ring R] [AddCommGroup M] [Module R M]

-- Porting note: renamed field to `principal'` and added `principal` to fix explicit argument
/-- An `R`-submodule of `M` is principal if it is generated by one element. -/
@[mk_iff]
class Submodule.IsPrincipal (S : Submodule R M) : Prop where
  principal' : âˆƒ a, S = span R {a}
#align submodule.is_principal Submodule.IsPrincipal

theorem Submodule.IsPrincipal.principal (S : Submodule R M) [Submodule.IsPrincipal S] :
    âˆƒ a, S = span R {a} :=
  Submodule.IsPrincipal.principal'
#align submodule.is_principal.principal Submodule.IsPrincipal.principal

instance bot_isPrincipal : (âŠ¥ : Submodule R M).IsPrincipal :=
  âŸ¨âŸ¨0, by simpâŸ©âŸ©
          -- ğŸ‰ no goals
#align bot_is_principal bot_isPrincipal

instance top_isPrincipal : (âŠ¤ : Submodule R R).IsPrincipal :=
  âŸ¨âŸ¨1, Ideal.span_singleton_one.symmâŸ©âŸ©
#align top_is_principal top_isPrincipal

variable (R)

/-- A ring is a principal ideal ring if all (left) ideals are principal. -/
@[mk_iff isPrincipalIdealRing_iff]
class IsPrincipalIdealRing (R : Type u) [Ring R] : Prop where
  principal : âˆ€ S : Ideal R, S.IsPrincipal
#align is_principal_ideal_ring IsPrincipalIdealRing

attribute [instance] IsPrincipalIdealRing.principal

instance (priority := 100) DivisionRing.isPrincipalIdealRing (K : Type u) [DivisionRing K] :
    IsPrincipalIdealRing K where
  principal S := by
    rcases Ideal.eq_bot_or_top S with (rfl | rfl)
    -- âŠ¢ IsPrincipal âŠ¥
    apply bot_isPrincipal
    -- âŠ¢ IsPrincipal âŠ¤
    apply top_isPrincipal
    -- ğŸ‰ no goals
#align division_ring.is_principal_ideal_ring DivisionRing.isPrincipalIdealRing

end

namespace Submodule.IsPrincipal

variable [AddCommGroup M]

section Ring

variable [Ring R] [Module R M]

/-- `generator I`, if `I` is a principal submodule, is an `x âˆˆ M` such that `span R {x} = I` -/
noncomputable def generator (S : Submodule R M) [S.IsPrincipal] : M :=
  Classical.choose (principal S)
#align submodule.is_principal.generator Submodule.IsPrincipal.generator

theorem span_singleton_generator (S : Submodule R M) [S.IsPrincipal] : span R {generator S} = S :=
  Eq.symm (Classical.choose_spec (principal S))
#align submodule.is_principal.span_singleton_generator Submodule.IsPrincipal.span_singleton_generator

theorem _root_.Ideal.span_singleton_generator (I : Ideal R) [I.IsPrincipal] :
    Ideal.span ({generator I} : Set R) = I :=
  Eq.symm (Classical.choose_spec (principal I))
#align ideal.span_singleton_generator Ideal.span_singleton_generator

@[simp]
theorem generator_mem (S : Submodule R M) [S.IsPrincipal] : generator S âˆˆ S := by
  conv_rhs => rw [â† span_singleton_generator S]
  -- âŠ¢ generator S âˆˆ span R {generator S}
  exact subset_span (mem_singleton _)
  -- ğŸ‰ no goals
#align submodule.is_principal.generator_mem Submodule.IsPrincipal.generator_mem

theorem mem_iff_eq_smul_generator (S : Submodule R M) [S.IsPrincipal] {x : M} :
    x âˆˆ S â†” âˆƒ s : R, x = s â€¢ generator S := by
  simp_rw [@eq_comm _ x, â† mem_span_singleton, span_singleton_generator]
  -- ğŸ‰ no goals
#align submodule.is_principal.mem_iff_eq_smul_generator Submodule.IsPrincipal.mem_iff_eq_smul_generator

theorem eq_bot_iff_generator_eq_zero (S : Submodule R M) [S.IsPrincipal] :
    S = âŠ¥ â†” generator S = 0 := by rw [â† @span_singleton_eq_bot R M, span_singleton_generator]
                                  -- ğŸ‰ no goals
#align submodule.is_principal.eq_bot_iff_generator_eq_zero Submodule.IsPrincipal.eq_bot_iff_generator_eq_zero

end Ring

section CommRing

variable [CommRing R] [Module R M]

theorem mem_iff_generator_dvd (S : Ideal R) [S.IsPrincipal] {x : R} : x âˆˆ S â†” generator S âˆ£ x :=
  (mem_iff_eq_smul_generator S).trans (exists_congr fun a => by simp only [mul_comm, smul_eq_mul])
                                                                -- ğŸ‰ no goals
#align submodule.is_principal.mem_iff_generator_dvd Submodule.IsPrincipal.mem_iff_generator_dvd

theorem prime_generator_of_isPrime (S : Ideal R) [Submodule.IsPrincipal S] [is_prime : S.IsPrime]
    (ne_bot : S â‰  âŠ¥) : Prime (generator S) :=
  âŸ¨fun h => ne_bot ((eq_bot_iff_generator_eq_zero S).2 h), fun h =>
    is_prime.ne_top (S.eq_top_of_isUnit_mem (generator_mem S) h), fun _ _ => by
    simpa only [â† mem_iff_generator_dvd S] using is_prime.2âŸ©
    -- ğŸ‰ no goals
#align submodule.is_principal.prime_generator_of_is_prime Submodule.IsPrincipal.prime_generator_of_isPrime

-- Note that the converse may not hold if `Ï•` is not injective.
theorem generator_map_dvd_of_mem {N : Submodule R M} (Ï• : M â†’â‚—[R] R) [(N.map Ï•).IsPrincipal] {x : M}
    (hx : x âˆˆ N) : generator (N.map Ï•) âˆ£ Ï• x := by
  rw [â† mem_iff_generator_dvd, Submodule.mem_map]
  -- âŠ¢ âˆƒ y, y âˆˆ N âˆ§ â†‘Ï• y = â†‘Ï• x
  exact âŸ¨x, hx, rflâŸ©
  -- ğŸ‰ no goals
#align submodule.is_principal.generator_map_dvd_of_mem Submodule.IsPrincipal.generator_map_dvd_of_mem

-- Note that the converse may not hold if `Ï•` is not injective.
theorem generator_submoduleImage_dvd_of_mem {N O : Submodule R M} (hNO : N â‰¤ O) (Ï• : O â†’â‚—[R] R)
    [(Ï•.submoduleImage N).IsPrincipal] {x : M} (hx : x âˆˆ N) :
    generator (Ï•.submoduleImage N) âˆ£ Ï• âŸ¨x, hNO hxâŸ© := by
  rw [â† mem_iff_generator_dvd, LinearMap.mem_submoduleImage_of_le hNO]
  -- âŠ¢ âˆƒ y yN, â†‘Ï• { val := y, property := (_ : y âˆˆ O) } = â†‘Ï• { val := x, property : â€¦
  exact âŸ¨x, hx, rflâŸ©
  -- ğŸ‰ no goals
#align submodule.is_principal.generator_submodule_image_dvd_of_mem Submodule.IsPrincipal.generator_submoduleImage_dvd_of_mem

end CommRing

end Submodule.IsPrincipal

namespace IsPrime

open Submodule.IsPrincipal Ideal

-- TODO -- for a non-ID one could perhaps prove that if p < q are prime then q maximal;
-- 0 isn't prime in a non-ID PIR but the Krull dimension is still <= 1.
-- The below result follows from this, but we could also use the below result to
-- prove this (quotient out by p).
theorem to_maximal_ideal [CommRing R] [IsDomain R] [IsPrincipalIdealRing R] {S : Ideal R}
    [hpi : IsPrime S] (hS : S â‰  âŠ¥) : IsMaximal S :=
  isMaximal_iff.2
    âŸ¨(ne_top_iff_one S).1 hpi.1, by
      intro T x hST hxS hxT
      -- âŠ¢ 1 âˆˆ T
      cases' (mem_iff_generator_dvd _).1 (hST <| generator_mem S) with z hz
      -- âŠ¢ 1 âˆˆ T
      cases hpi.mem_or_mem (show generator T * z âˆˆ S from hz â–¸ generator_mem S)
      -- âŠ¢ 1 âˆˆ T
      case inl h =>
        have hTS : T â‰¤ S
        rwa [â† T.span_singleton_generator, Ideal.span_le, singleton_subset_iff]
        exact (hxS <| hTS hxT).elim
      case inr h =>
        cases' (mem_iff_generator_dvd _).1 h with y hy
        have : generator S â‰  0 := mt (eq_bot_iff_generator_eq_zero _).2 hS
        rw [â† mul_one (generator S), hy, mul_left_comm, mul_right_inj' this] at hz
        exact hz.symm â–¸ T.mul_mem_right _ (generator_mem T)âŸ©
#align is_prime.to_maximal_ideal IsPrime.to_maximal_ideal

end IsPrime

section

open EuclideanDomain

variable [EuclideanDomain R]

theorem mod_mem_iff {S : Ideal R} {x y : R} (hy : y âˆˆ S) : x % y âˆˆ S â†” x âˆˆ S :=
  âŸ¨fun hxy => div_add_mod x y â–¸ S.add_mem (S.mul_mem_right _ hy) hxy, fun hx =>
    (mod_eq_sub_mul_div x y).symm â–¸ S.sub_mem hx (S.mul_mem_right _ hy)âŸ©
#align mod_mem_iff mod_mem_iff

-- see Note [lower instance priority]
instance (priority := 100) EuclideanDomain.to_principal_ideal_domain : IsPrincipalIdealRing R
    where principal S :=
    âŸ¨if h : { x : R | x âˆˆ S âˆ§ x â‰  0 }.Nonempty then
        have wf : WellFounded (EuclideanDomain.r : R â†’ R â†’ Prop) := EuclideanDomain.r_wellFounded
        have hmin : WellFounded.min wf { x : R | x âˆˆ S âˆ§ x â‰  0 } h âˆˆ S âˆ§
            WellFounded.min wf { x : R | x âˆˆ S âˆ§ x â‰  0 } h â‰  0 :=
          WellFounded.min_mem wf { x : R | x âˆˆ S âˆ§ x â‰  0 } h
        âŸ¨WellFounded.min wf { x : R | x âˆˆ S âˆ§ x â‰  0 } h,
          Submodule.ext fun x => âŸ¨fun hx =>
            div_add_mod x (WellFounded.min wf { x : R | x âˆˆ S âˆ§ x â‰  0 } h) â–¸
              (Ideal.mem_span_singleton.2 <| dvd_add (dvd_mul_right _ _) <| by
                have : x % WellFounded.min wf { x : R | x âˆˆ S âˆ§ x â‰  0 } h âˆ‰
                    { x : R | x âˆˆ S âˆ§ x â‰  0 } :=
                  fun hâ‚ => WellFounded.not_lt_min wf _ h hâ‚ (mod_lt x hmin.2)
                have : x % WellFounded.min wf { x : R | x âˆˆ S âˆ§ x â‰  0 } h = 0 := by
                  simp only [not_and_or, Set.mem_setOf_eq, not_ne_iff] at this
                  exact this.neg_resolve_left <| (mod_mem_iff hmin.1).2 hx
                simp [*]),
                -- ğŸ‰ no goals
              fun hx =>
                let âŸ¨y, hyâŸ© := Ideal.mem_span_singleton.1 hx
                hy.symm â–¸ S.mul_mem_right _ hmin.1âŸ©âŸ©
      else âŸ¨0, Submodule.ext fun a => by
            rw [â† @Submodule.bot_coe R R _ _ _, span_eq, Submodule.mem_bot]
            -- âŠ¢ a âˆˆ S â†” a = 0
            exact âŸ¨fun haS => by_contra fun ha0 => h âŸ¨a, âŸ¨haS, ha0âŸ©âŸ©,
              fun hâ‚ => hâ‚.symm â–¸ S.zero_memâŸ©âŸ©âŸ©
#align euclidean_domain.to_principal_ideal_domain EuclideanDomain.to_principal_ideal_domain

end

theorem IsField.isPrincipalIdealRing {R : Type*} [CommRing R] (h : IsField R) :
    IsPrincipalIdealRing R :=
  @EuclideanDomain.to_principal_ideal_domain R (@Field.toEuclideanDomain R h.toField)
#align is_field.is_principal_ideal_ring IsField.isPrincipalIdealRing

namespace PrincipalIdealRing

open IsPrincipalIdealRing

-- see Note [lower instance priority]
instance (priority := 100) isNoetherianRing [Ring R] [IsPrincipalIdealRing R] :
    IsNoetherianRing R :=
  isNoetherianRing_iff.2
    âŸ¨fun s : Ideal R => by
      rcases (IsPrincipalIdealRing.principal s).principal with âŸ¨a, rflâŸ©
      -- âŠ¢ FG (span R {a})
      rw [â† Finset.coe_singleton]
      -- âŠ¢ FG (span R â†‘{a})
      exact âŸ¨{a}, SetLike.coe_injective rflâŸ©âŸ©
      -- ğŸ‰ no goals
#align principal_ideal_ring.is_noetherian_ring PrincipalIdealRing.isNoetherianRing

theorem isMaximal_of_irreducible [CommRing R] [IsPrincipalIdealRing R] {p : R}
    (hp : Irreducible p) : Ideal.IsMaximal (span R ({p} : Set R)) :=
  âŸ¨âŸ¨mt Ideal.span_singleton_eq_top.1 hp.1, fun I hI => by
      rcases principal I with âŸ¨a, rflâŸ©
      -- âŠ¢ span R {a} = âŠ¤
      erw [Ideal.span_singleton_eq_top]
      -- âŠ¢ IsUnit a
      rcases Ideal.span_singleton_le_span_singleton.1 (le_of_lt hI) with âŸ¨b, rflâŸ©
      -- âŠ¢ IsUnit a
      refine' (of_irreducible_mul hp).resolve_right (mt (fun hb => _) (not_le_of_lt hI))
      -- âŠ¢ span R {a} â‰¤ span R {a * b}
      erw [Ideal.span_singleton_le_span_singleton, IsUnit.mul_right_dvd hb]âŸ©âŸ©
      -- ğŸ‰ no goals
#align principal_ideal_ring.is_maximal_of_irreducible PrincipalIdealRing.isMaximal_of_irreducible

variable [CommRing R] [IsDomain R] [IsPrincipalIdealRing R]

theorem irreducible_iff_prime {p : R} : Irreducible p â†” Prime p :=
  âŸ¨fun hp => (Ideal.span_singleton_prime hp.ne_zero).1 <| (isMaximal_of_irreducible hp).isPrime,
    Prime.irreducibleâŸ©
#align principal_ideal_ring.irreducible_iff_prime PrincipalIdealRing.irreducible_iff_prime

theorem associates_irreducible_iff_prime : âˆ€ {p : Associates R}, Irreducible p â†” Prime p :=
  fun {p} => (Associates.irreducible_iff_prime_iff.1 fun _ => irreducible_iff_prime) p
#align principal_ideal_ring.associates_irreducible_iff_prime PrincipalIdealRing.associates_irreducible_iff_prime

section

open Classical

/-- `factors a` is a multiset of irreducible elements whose product is `a`, up to units -/
noncomputable def factors (a : R) : Multiset R :=
  if h : a = 0 then âˆ… else Classical.choose (WfDvdMonoid.exists_factors a h)
#align principal_ideal_ring.factors PrincipalIdealRing.factors

theorem factors_spec (a : R) (h : a â‰  0) :
    (âˆ€ b âˆˆ factors a, Irreducible b) âˆ§ Associated (factors a).prod a := by
  unfold factors; rw [dif_neg h]
  -- âŠ¢ (âˆ€ (b : R), (b âˆˆ if h : a = 0 then âˆ… else choose (_ : âˆƒ f, (âˆ€ (b : R), b âˆˆ f â€¦
                  -- âŠ¢ (âˆ€ (b : R), b âˆˆ choose (_ : âˆƒ f, (âˆ€ (b : R), b âˆˆ f â†’ Irreducible b) âˆ§ Associ â€¦
  exact Classical.choose_spec (WfDvdMonoid.exists_factors a h)
  -- ğŸ‰ no goals
#align principal_ideal_ring.factors_spec PrincipalIdealRing.factors_spec

theorem ne_zero_of_mem_factors {R : Type v} [CommRing R] [IsDomain R] [IsPrincipalIdealRing R]
    {a b : R} (ha : a â‰  0) (hb : b âˆˆ factors a) : b â‰  0 :=
  Irreducible.ne_zero ((factors_spec a ha).1 b hb)
#align principal_ideal_ring.ne_zero_of_mem_factors PrincipalIdealRing.ne_zero_of_mem_factors

theorem mem_submonoid_of_factors_subset_of_units_subset (s : Submonoid R) {a : R} (ha : a â‰  0)
    (hfac : âˆ€ b âˆˆ factors a, b âˆˆ s) (hunit : âˆ€ c : RË£, (c : R) âˆˆ s) : a âˆˆ s := by
  rcases(factors_spec a ha).2 with âŸ¨c, hcâŸ©
  -- âŠ¢ a âˆˆ s
  rw [â† hc]
  -- âŠ¢ Multiset.prod (factors a) * â†‘c âˆˆ s
  exact mul_mem (multiset_prod_mem _ hfac) (hunit _)
  -- ğŸ‰ no goals
#align principal_ideal_ring.mem_submonoid_of_factors_subset_of_units_subset PrincipalIdealRing.mem_submonoid_of_factors_subset_of_units_subset

/-- If a `RingHom` maps all units and all factors of an element `a` into a submonoid `s`, then it
also maps `a` into that submonoid. -/
theorem ringHom_mem_submonoid_of_factors_subset_of_units_subset {R S : Type*} [CommRing R]
    [IsDomain R] [IsPrincipalIdealRing R] [Semiring S] (f : R â†’+* S) (s : Submonoid S) (a : R)
    (ha : a â‰  0) (h : âˆ€ b âˆˆ factors a, f b âˆˆ s) (hf : âˆ€ c : RË£, f c âˆˆ s) : f a âˆˆ s :=
  mem_submonoid_of_factors_subset_of_units_subset (s.comap f.toMonoidHom) ha h hf
#align principal_ideal_ring.ring_hom_mem_submonoid_of_factors_subset_of_units_subset PrincipalIdealRing.ringHom_mem_submonoid_of_factors_subset_of_units_subset

-- see Note [lower instance priority]
/-- A principal ideal domain has unique factorization -/
instance (priority := 100) to_uniqueFactorizationMonoid : UniqueFactorizationMonoid R :=
  { (IsNoetherianRing.wfDvdMonoid : WfDvdMonoid R) with
    irreducible_iff_prime := PrincipalIdealRing.irreducible_iff_prime }
#align principal_ideal_ring.to_unique_factorization_monoid PrincipalIdealRing.to_uniqueFactorizationMonoid

end

end PrincipalIdealRing

section Surjective

open Submodule

variable {S N : Type*} [Ring R] [AddCommGroup M] [AddCommGroup N] [Ring S]

variable [Module R M] [Module R N]

theorem Submodule.IsPrincipal.of_comap (f : M â†’â‚—[R] N) (hf : Function.Surjective f)
    (S : Submodule R N) [hI : IsPrincipal (S.comap f)] : IsPrincipal S :=
  âŸ¨âŸ¨f (IsPrincipal.generator (S.comap f)), by
      rw [â† Set.image_singleton, â† Submodule.map_span, IsPrincipal.span_singleton_generator,
        Submodule.map_comap_eq_of_surjective hf]âŸ©âŸ©
#align submodule.is_principal.of_comap Submodule.IsPrincipal.of_comap

theorem Ideal.IsPrincipal.of_comap (f : R â†’+* S) (hf : Function.Surjective f) (I : Ideal S)
    [hI : IsPrincipal (I.comap f)] : IsPrincipal I :=
  âŸ¨âŸ¨f (IsPrincipal.generator (I.comap f)), by
      rw [Ideal.submodule_span_eq, â† Set.image_singleton, â† Ideal.map_span,
        Ideal.span_singleton_generator, Ideal.map_comap_of_surjective f hf]âŸ©âŸ©
#align ideal.is_principal.of_comap Ideal.IsPrincipal.of_comap

/-- The surjective image of a principal ideal ring is again a principal ideal ring. -/
theorem IsPrincipalIdealRing.of_surjective [IsPrincipalIdealRing R] (f : R â†’+* S)
    (hf : Function.Surjective f) : IsPrincipalIdealRing S :=
  âŸ¨fun I => Ideal.IsPrincipal.of_comap f hf IâŸ©
#align is_principal_ideal_ring.of_surjective IsPrincipalIdealRing.of_surjective

end Surjective

section

open Ideal

variable [CommRing R] [IsDomain R] [IsPrincipalIdealRing R] [GCDMonoid R]

theorem span_gcd (x y : R) : span ({gcd x y} : Set R) = span ({x, y} : Set R) := by
  obtain âŸ¨d, hdâŸ© := IsPrincipalIdealRing.principal (span ({x, y} : Set R))
  -- âŠ¢ Ideal.span {gcd x y} = Ideal.span {x, y}
  rw [submodule_span_eq] at hd
  -- âŠ¢ Ideal.span {gcd x y} = Ideal.span {x, y}
  rw [hd]
  -- âŠ¢ Ideal.span {gcd x y} = Ideal.span {d}
  suffices Associated d (gcd x y) by
    obtain âŸ¨D, HDâŸ© := this
    rw [â† HD]
    exact span_singleton_mul_right_unit D.isUnit _
  apply associated_of_dvd_dvd
  -- âŠ¢ d âˆ£ gcd x y
  Â· rw [dvd_gcd_iff]
    -- âŠ¢ d âˆ£ x âˆ§ d âˆ£ y
    constructor <;> rw [â† Ideal.mem_span_singleton, â† hd, Ideal.mem_span_pair]
    -- âŠ¢ d âˆ£ x
                    -- âŠ¢ âˆƒ a b, a * x + b * y = x
                    -- âŠ¢ âˆƒ a b, a * x + b * y = y
    Â· use 1, 0
      -- âŠ¢ 1 * x + 0 * y = x
      rw [one_mul, zero_mul, add_zero]
      -- ğŸ‰ no goals
    Â· use 0, 1
      -- âŠ¢ 0 * x + 1 * y = y
      rw [one_mul, zero_mul, zero_add]
      -- ğŸ‰ no goals
  Â· obtain âŸ¨r, s, rflâŸ© : âˆƒ r s, r * x + s * y = d := by
      rw [â† Ideal.mem_span_pair, hd, Ideal.mem_span_singleton]
    apply dvd_add <;> apply dvd_mul_of_dvd_right
    -- âŠ¢ gcd x y âˆ£ r * x
                      -- âŠ¢ gcd x y âˆ£ x
                      -- âŠ¢ gcd x y âˆ£ y
    exacts [gcd_dvd_left x y, gcd_dvd_right x y]
    -- ğŸ‰ no goals
#align span_gcd span_gcd

theorem gcd_dvd_iff_exists (a b : R) {z} : gcd a b âˆ£ z â†” âˆƒ x y, z = a * x + b * y := by
  simp_rw [mul_comm a, mul_comm b, @eq_comm _ z, â† Ideal.mem_span_pair, â† span_gcd,
    Ideal.mem_span_singleton]
#align gcd_dvd_iff_exists gcd_dvd_iff_exists

/-- **BÃ©zout's lemma** -/
theorem exists_gcd_eq_mul_add_mul (a b : R) : âˆƒ x y, gcd a b = a * x + b * y := by
  rw [â† gcd_dvd_iff_exists]
  -- ğŸ‰ no goals
#align exists_gcd_eq_mul_add_mul exists_gcd_eq_mul_add_mul

theorem gcd_isUnit_iff (x y : R) : IsUnit (gcd x y) â†” IsCoprime x y := by
  rw [IsCoprime, â† Ideal.mem_span_pair, â† span_gcd, â† span_singleton_eq_top, eq_top_iff_one]
  -- ğŸ‰ no goals
#align gcd_is_unit_iff gcd_isUnit_iff

-- this should be proved for UFDs surely?
theorem isCoprime_of_dvd (x y : R) (nonzero : Â¬(x = 0 âˆ§ y = 0))
    (H : âˆ€ z âˆˆ nonunits R, z â‰  0 â†’ z âˆ£ x â†’ Â¬z âˆ£ y) : IsCoprime x y := by
  rw [â† gcd_isUnit_iff]
  -- âŠ¢ IsUnit (gcd x y)
  by_contra h
  -- âŠ¢ False
  refine' H _ h _ (gcd_dvd_left _ _) (gcd_dvd_right _ _)
  -- âŠ¢ gcd x y â‰  0
  rwa [Ne, gcd_eq_zero_iff]
  -- ğŸ‰ no goals
#align is_coprime_of_dvd isCoprime_of_dvd

-- this should be proved for UFDs surely?
theorem dvd_or_coprime (x y : R) (h : Irreducible x) : x âˆ£ y âˆ¨ IsCoprime x y := by
  refine' or_iff_not_imp_left.2 fun h' => _
  -- âŠ¢ IsCoprime x y
  apply isCoprime_of_dvd
  -- âŠ¢ Â¬(x = 0 âˆ§ y = 0)
  Â· rintro âŸ¨rfl, rflâŸ©
    -- âŠ¢ False
    simp at h
    -- ğŸ‰ no goals
  Â· rintro z nu - âŸ¨w, rflâŸ© dy
    -- âŠ¢ False
    refine' h' (dvd_trans _ dy)
    -- âŠ¢ z * w âˆ£ z
    simpa using mul_dvd_mul_left z (isUnit_iff_dvd_one.1 <| (of_irreducible_mul h).resolve_left nu)
    -- ğŸ‰ no goals
#align dvd_or_coprime dvd_or_coprime

theorem isCoprime_of_irreducible_dvd {x y : R} (nonzero : Â¬(x = 0 âˆ§ y = 0))
    (H : âˆ€ z : R, Irreducible z â†’ z âˆ£ x â†’ Â¬z âˆ£ y) : IsCoprime x y := by
  apply isCoprime_of_dvd x y nonzero
  -- âŠ¢ âˆ€ (z : R), z âˆˆ nonunits R â†’ z â‰  0 â†’ z âˆ£ x â†’ Â¬z âˆ£ y
  intro z znu znz zx zy
  -- âŠ¢ False
  obtain âŸ¨i, h1, h2âŸ© := WfDvdMonoid.exists_irreducible_factor znu znz
  -- âŠ¢ False
  apply H i h1 <;>
  -- âŠ¢ i âˆ£ x
    Â· apply dvd_trans h2
      -- âŠ¢ z âˆ£ x
      -- âŠ¢ z âˆ£ y
      -- ğŸ‰ no goals
      assumption
      -- ğŸ‰ no goals
#align is_coprime_of_irreducible_dvd isCoprime_of_irreducible_dvd

theorem isCoprime_of_prime_dvd {x y : R} (nonzero : Â¬(x = 0 âˆ§ y = 0))
    (H : âˆ€ z : R, Prime z â†’ z âˆ£ x â†’ Â¬z âˆ£ y) : IsCoprime x y :=
  isCoprime_of_irreducible_dvd nonzero fun z zi => H z <| GCDMonoid.prime_of_irreducible zi
#align is_coprime_of_prime_dvd isCoprime_of_prime_dvd

theorem Irreducible.coprime_iff_not_dvd {p n : R} (pp : Irreducible p) :
    IsCoprime p n â†” Â¬p âˆ£ n := by
  constructor
  -- âŠ¢ IsCoprime p n â†’ Â¬p âˆ£ n
  Â· intro co H
    -- âŠ¢ False
    apply pp.not_unit
    -- âŠ¢ IsUnit p
    rw [isUnit_iff_dvd_one]
    -- âŠ¢ p âˆ£ 1
    apply IsCoprime.dvd_of_dvd_mul_left co
    -- âŠ¢ p âˆ£ n * 1
    rw [mul_one n]
    -- âŠ¢ p âˆ£ n
    exact H
    -- ğŸ‰ no goals
  Â· intro nd
    -- âŠ¢ IsCoprime p n
    apply isCoprime_of_irreducible_dvd
    -- âŠ¢ Â¬(p = 0 âˆ§ n = 0)
    Â· rintro âŸ¨hp, -âŸ©
      -- âŠ¢ False
      exact pp.ne_zero hp
      -- ğŸ‰ no goals
    rintro z zi zp zn
    -- âŠ¢ False
    exact nd ((zi.associated_of_dvd pp zp).symm.dvd.trans zn)
    -- ğŸ‰ no goals
#align irreducible.coprime_iff_not_dvd Irreducible.coprime_iff_not_dvd

theorem Prime.coprime_iff_not_dvd {p n : R} (pp : Prime p) : IsCoprime p n â†” Â¬p âˆ£ n :=
  pp.irreducible.coprime_iff_not_dvd
#align prime.coprime_iff_not_dvd Prime.coprime_iff_not_dvd

theorem Irreducible.dvd_iff_not_coprime {p n : R} (hp : Irreducible p) : p âˆ£ n â†” Â¬IsCoprime p n :=
  iff_not_comm.2 hp.coprime_iff_not_dvd
#align irreducible.dvd_iff_not_coprime Irreducible.dvd_iff_not_coprime

theorem Irreducible.coprime_pow_of_not_dvd {p a : R} (m : â„•) (hp : Irreducible p) (h : Â¬p âˆ£ a) :
    IsCoprime a (p ^ m) :=
  (hp.coprime_iff_not_dvd.2 h).symm.pow_right
#align irreducible.coprime_pow_of_not_dvd Irreducible.coprime_pow_of_not_dvd

theorem Irreducible.coprime_or_dvd {p : R} (hp : Irreducible p) (i : R) : IsCoprime p i âˆ¨ p âˆ£ i :=
  (_root_.em _).imp_right hp.dvd_iff_not_coprime.2
#align irreducible.coprime_or_dvd Irreducible.coprime_or_dvd

theorem exists_associated_pow_of_mul_eq_pow' {a b c : R} (hab : IsCoprime a b) {k : â„•}
    (h : a * b = c ^ k) : âˆƒ d : R, Associated (d ^ k) a :=
  exists_associated_pow_of_mul_eq_pow ((gcd_isUnit_iff _ _).mpr hab) h
#align exists_associated_pow_of_mul_eq_pow' exists_associated_pow_of_mul_eq_pow'

end

section PrincipalOfPrime

open Set Ideal

variable (R) [CommRing R]

/-- `nonPrincipals R` is the set of all ideals of `R` that are not principal ideals. -/
def nonPrincipals :=
  { I : Ideal R | Â¬I.IsPrincipal }
#align non_principals nonPrincipals

theorem nonPrincipals_def {I : Ideal R} : I âˆˆ nonPrincipals R â†” Â¬I.IsPrincipal :=
  Iff.rfl
#align non_principals_def nonPrincipals_def

variable {R}

theorem nonPrincipals_eq_empty_iff : nonPrincipals R = âˆ… â†” IsPrincipalIdealRing R := by
  simp [Set.eq_empty_iff_forall_not_mem, isPrincipalIdealRing_iff, nonPrincipals_def]
  -- ğŸ‰ no goals
#align non_principals_eq_empty_iff nonPrincipals_eq_empty_iff

/-- Any chain in the set of non-principal ideals has an upper bound which is non-principal.
(Namely, the union of the chain is such an upper bound.)
-/
theorem nonPrincipals_zorn (c : Set (Ideal R)) (hs : c âŠ† nonPrincipals R)
    (hchain : IsChain (Â· â‰¤ Â·) c) {K : Ideal R} (hKmem : K âˆˆ c) :
    âˆƒ I âˆˆ nonPrincipals R, âˆ€ J âˆˆ c, J â‰¤ I := by
  refine' âŸ¨sSup c, _, fun J hJ => le_sSup hJâŸ©
  -- âŠ¢ sSup c âˆˆ nonPrincipals R
  rintro âŸ¨x, hxâŸ©
  -- âŠ¢ False
  have hxmem : x âˆˆ sSup c := hx.symm â–¸ Submodule.mem_span_singleton_self x
  -- âŠ¢ False
  obtain âŸ¨J, hJc, hxJâŸ© := (Submodule.mem_sSup_of_directed âŸ¨K, hKmemâŸ© hchain.directedOn).1 hxmem
  -- âŠ¢ False
  have hsSupJ : sSup c = J := le_antisymm (by simp [hx, Ideal.span_le, hxJ]) (le_sSup hJc)
  -- âŠ¢ False
  specialize hs hJc
  -- âŠ¢ False
  rw [â† hsSupJ, hx, nonPrincipals_def] at hs
  -- âŠ¢ False
  exact hs âŸ¨âŸ¨x, rflâŸ©âŸ©
  -- ğŸ‰ no goals
#align non_principals_zorn nonPrincipals_zorn

/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/
theorem IsPrincipalIdealRing.of_prime (H : âˆ€ P : Ideal R, P.IsPrime â†’ P.IsPrincipal) :
    IsPrincipalIdealRing R := by
  -- Suppose the set of `nonPrincipals` is not empty.
  rw [â† nonPrincipals_eq_empty_iff, Set.eq_empty_iff_forall_not_mem]
  -- âŠ¢ âˆ€ (x : Ideal R), Â¬x âˆˆ nonPrincipals R
  intro J hJ
  -- âŠ¢ False
  -- We will show a maximal element `I âˆˆ nonPrincipals R` (which exists by Zorn) is prime.
  obtain âŸ¨I, Ibad, -, ImaxâŸ© := zorn_nonempty_partialOrderâ‚€ (nonPrincipals R) nonPrincipals_zorn _ hJ
  -- âŠ¢ False
  have Imax' : âˆ€ {J}, I < J â†’ J.IsPrincipal := by
    intro J hJ
    by_contra He
    exact hJ.ne (Imax _ ((nonPrincipals_def R).2 He) hJ.le).symm
  by_cases hI1 : I = âŠ¤
  -- âŠ¢ False
  Â· subst hI1
    -- âŠ¢ False
    exact Ibad top_isPrincipal
    -- ğŸ‰ no goals
  -- Let `x y : R` with `x * y âˆˆ I` and suppose WLOG `y âˆ‰ I`.
  refine' Ibad (H I âŸ¨hI1, fun {x y} hxy => or_iff_not_imp_right.mpr fun hy => _âŸ©)
  -- âŠ¢ x âˆˆ I
  obtain âŸ¨a, haâŸ© : (I âŠ” span {y}).IsPrincipal :=
    Imax' (left_lt_sup.mpr (mt I.span_singleton_le_iff_mem.mp hy))
  -- Then `x âˆˆ I.colon (span {y})`, which is equal to `I` if it's not principal.
  suffices He : Â¬(I.colon (span {y})).IsPrincipal
  -- âŠ¢ x âˆˆ I
  Â· rw [â† Imax _ ((nonPrincipals_def R).2 He) fun a ha =>
        Ideal.mem_colon_singleton.2 (mul_mem_right _ _ ha)]
    exact Ideal.mem_colon_singleton.2 hxy
    -- ğŸ‰ no goals
  -- So suppose for the sake of contradiction that both `I âŠ” span {y}` and `I.colon (span {y})`
  -- are principal.
  rintro âŸ¨b, hbâŸ©
  -- âŠ¢ False
  -- We will show `I` is generated by `a * b`.
  refine (nonPrincipals_def _).1 Ibad âŸ¨a * b, ?_âŸ©
  -- âŠ¢ I = Submodule.span R {a * b}
  refine'
    le_antisymm (Î± := Ideal R) (fun i hi => _) <| (span_singleton_mul_span_singleton a b).ge.trans _
  Â· have hisup : i âˆˆ I âŠ” span {y} := Ideal.mem_sup_left hi
    -- âŠ¢ i âˆˆ Submodule.span R {a * b}
    have : y âˆˆ I âŠ” span {y} := Ideal.mem_sup_right (Ideal.mem_span_singleton_self y)
    -- âŠ¢ i âˆˆ Submodule.span R {a * b}
    erw [ha, mem_span_singleton'] at hisup this
    -- âŠ¢ i âˆˆ Submodule.span R {a * b}
    obtain âŸ¨v, rflâŸ© := this
    -- âŠ¢ i âˆˆ Submodule.span R {a * b}
    obtain âŸ¨u, rflâŸ© := hisup
    -- âŠ¢ u * a âˆˆ Submodule.span R {a * b}
    have hucolon : u âˆˆ I.colon (span {v * a}) := by
      rw [Ideal.mem_colon_singleton, mul_comm v, â† mul_assoc]
      exact mul_mem_right _ _ hi
    erw [hb, mem_span_singleton'] at hucolon
    -- âŠ¢ u * a âˆˆ Submodule.span R {a * b}
    obtain âŸ¨z, rflâŸ© := hucolon
    -- âŠ¢ z * b * a âˆˆ Submodule.span R {a * b}
    exact mem_span_singleton'.2 âŸ¨z, by ringâŸ©
    -- ğŸ‰ no goals
  Â· rw [â† Ideal.submodule_span_eq, â† ha, Ideal.sup_mul, sup_le_iff,
      span_singleton_mul_span_singleton, mul_comm y, Ideal.span_singleton_le_iff_mem]
    exact âŸ¨mul_le_right, Ideal.mem_colon_singleton.1 <| hb.symm â–¸ Ideal.mem_span_singleton_self bâŸ©
    -- ğŸ‰ no goals
#align is_principal_ideal_ring.of_prime IsPrincipalIdealRing.of_prime

end PrincipalOfPrime
