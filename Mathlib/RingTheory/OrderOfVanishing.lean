/-
Copyright (c) 2025 Raphael Douglas Giles. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Raphael Douglas Giles
-/
import Mathlib.RingTheory.KrullDimension.NonZeroDivisors
import Mathlib.RingTheory.Length
import Mathlib.RingTheory.HopkinsLevitzki

/-!
# Order of vanishing

This file defines the order of vanishing of an element of a ring as the length of the quotient of
the ring by the ideal generated by that element. We also define the extension of this notion to the
field of fractions
-/

open LinearMap Multiplicative Pointwise IsLocalization Ideal

variable {R : Type*} {M : Type*} [AddCommMonoid M]

namespace Ring

variable (R) [Ring R]
/--
Order of vanishing function for elements of a ring.
-/
@[stacks 02MD]
noncomputable
def ord (x : R) : ℕ∞ := Module.length R (R ⧸ Ideal.span {x})

/--
The order of vanishing of `1` is `0`.
-/
@[simp]
lemma ord_one : ord R 1 = 0 := by
  simp_all [ord, Module.length_eq_zero_iff,
    Ideal.span_singleton_one, Submodule.Quotient.subsingleton_iff]

end Ring



variable [CommRing R] [Module R M]

/--
The map `R ⧸ I →ₗ[R] R ⧸ (a • I)` defined by multiplication by `a`
-/
def Ideal.mulQuot (a : R) (I : Ideal R) :
    R ⧸ I →ₗ[R] R ⧸ (a • I) :=
  Submodule.mapQ _ _ (LinearMap.mul R R a) (Submodule.le_comap_map _ _)

/--
The map `R ⧸ I →ₗ[R] R ⧸ (a • I)` defined by multiplication by `a` is injective if `a` is
a nonzero divisor.
-/
lemma Ideal.mulQuot_injective {a : R} (I : Ideal R) (ha : a ∈ nonZeroDivisors R) :
    Function.Injective (Ideal.mulQuot a I) := by
  simp only [mulQuot, Submodule.mapQ, ← ker_eq_bot]
  apply Submodule.ker_liftQ_eq_bot'
  apply le_antisymm
  · have : Submodule.map (mul R R a) I = a • I := rfl
    rw [le_ker_iff_map, Submodule.map_comp, this, Submodule.mkQ_map_self]
  · have m : I = Submodule.comap (mul R R a) (a • I) := by
      ext b
      exact (Submodule.mul_mem_smul_iff ha).symm
    simp [←m, ker_comp]
/--
The quotient map `(R ⧸ a • I) →ₗ[R] (R ⧸ Ideal.span {a})`.
-/
def Ideal.quotOfMul (a : R) (I : Ideal R) :
    (R ⧸ a • I) →ₗ[R] (R ⧸ Ideal.span {a}) :=
  Submodule.factor <| Submodule.singleton_set_smul I a ▸ Submodule.smul_le_span {a} I

/--
The quotient map `(R ⧸ a • I) →ₗ[R] (R ⧸ Ideal.span {a})` is surjective.
-/
lemma Ideal.quotOfMul_surjective {a : R} (I : Ideal R) :
    Function.Surjective (Ideal.quotOfMul a I) := by
  simp only [Ideal.quotOfMul]
  exact Submodule.factor_surjective <|
    Submodule.singleton_set_smul I a ▸ Submodule.smul_le_span {a} I

/--
The sequence `R ⧸ I →ₗ[R] R ⧸ (a • I) →ₗ[R] R ⧸ (Ideal.span {a})` given by multiplication
by `a` then quotienting by the ideal generated by `a` is exact.
-/
lemma Ideal.exact_mulQuot_quotOfMul {a : R} (I : Ideal R) :
    Function.Exact (Ideal.mulQuot a I) (Ideal.quotOfMul a I) := by
  simp only [exact_iff]
  have : ker (Ideal.quotOfMul a I) = a • ⊤ := by
    simp only [Ideal.quotOfMul, Submodule.factor, Submodule.mapQ, comp_id, Submodule.ker_liftQ,
      Submodule.ker_mkQ]
    suffices Submodule.map (Submodule.mkQ (a • I)) (Submodule.span R {a}) = a • ⊤ by exact this
    rw [Submodule.map_span]
    simp only [Submodule.mkQ_apply, Quotient.mk_eq_mk, Set.image_singleton, Ideal.Quotient.smul_top]
  simp [this, Ideal.mulQuot, Submodule.mapQ.eq_1, Submodule.range_liftQ,
   range_comp, Ideal.Quotient.smul_top, ← Ideal.submodule_span_eq, LinearMap.map_span]

namespace Ring
variable (R)
/--
The order of vanishing of `a * b` is the order of vanishing of `a` plus the order
of vanishing of `b`.
-/
theorem ord_mul {a b : R} (hb : b ∈ nonZeroDivisors R) :
    Ring.ord R (a * b) = Ring.ord R a + Ring.ord R b := by
  have := Module.length_eq_add_of_exact (Ideal.mulQuot b (Ideal.span {a}))
          (Ideal.quotOfMul b (Ideal.span {a})) (Ideal.mulQuot_injective (Ideal.span {a}) hb)
          (Ideal.quotOfMul_surjective (Ideal.span {a}))
          (Ideal.exact_mulQuot_quotOfMul (Ideal.span {a}))
  simp only [Ring.ord, submodule_span_eq, ← this]
  have lem : (({b} : Set R) • Ideal.span {a}) = Ideal.span {b * a} := by
    simp [←Ideal.submodule_span_eq, Submodule.set_smul_span]
  have : (({b} : Set R) • Ideal.span {a}) = b • Ideal.span {a} := Submodule.singleton_set_smul
    (Ideal.span {a}) b
  rw [this] at lem
  rw [lem, mul_comm]

open Classical in
/--
Zero preserving monoid homomorphism from a nontrivial commutative ring `R` to `ℕₘ₀`.

Note that we cannot just use `fun x ↦ ord R x` without further assumptions on `R`.
This is because if R is finite length, then ord R 0 will be some non top value,
meaning in this case `0` will not be mapped to `⊤`.
-/
@[stacks 02MD]
noncomputable
def ordMonoidWithZeroHom [Nontrivial R] : R →*₀ ℤₘ₀ where
  toFun x := if x ∈ nonZeroDivisors R
             then WithZero.map' (Nat.castAddMonoidHom ℤ).toMultiplicative (Ring.ord R x)
             else 0
  map_zero' := by
    simp [nonZeroDivisors, exists_ne]
  map_one' := by
    simp [nonZeroDivisors, Ring.ord_one]
    rfl
  map_mul' := by
    intro x y
    split_ifs
    · rename_i _ b
      rw[← MonoidWithZeroHom.map_mul]
      congr
      exact ord_mul R b
    all_goals simp_all [mul_mem_nonZeroDivisors]

/--
The quotient of a Noetherian ring of krull dimension less than or equal to `1` by a principal ideal
is of finite length.
-/
theorem _root_.isFiniteLength_quotient_span_singleton [IsNoetherianRing R]
    [Ring.KrullDimLE 1 R] {x : R} (hx : x ∈ nonZeroDivisors R) :
    IsFiniteLength R (R ⧸ Ideal.span {x}) := by
  rw [isFiniteLength_iff_isNoetherian_isArtinian]
  suffices IsArtinianRing (R ⧸ Ideal.span {x}) from
    ⟨isNoetherian_quotient (Ideal.span {x}),
      isArtinian_of_surjective_algebraMap (Ideal.Quotient.mk_surjective (I := .span {x}))⟩
  rw [isArtinianRing_iff_krullDimLE_zero, Ring.KrullDimLE, Order.krullDimLE_iff,
    ← WithBot.add_le_add_iff_right' (c := 1) (by simp) (WithBot.coe_eq_coe.not.mpr (by simp)),
    Nat.cast_zero, zero_add]
  exact (ringKrullDim_quotient_succ_le_of_nonZeroDivisor hx).trans (Order.KrullDimLE.krullDim_le)

variable [Nontrivial R] [IsNoetherianRing R] [Ring.KrullDimLE 1 R]
variable {K : Type*} [Field K] [Algebra R K] [IsFractionRing R K]
/--
Order of vanishing function for elements of the fraction field defined as the extension of
`CommRing.ordMonoidWithZeroHom` to the field of fractions.
-/
@[stacks 02MD]
noncomputable
def ordFrac : K →*₀ ℤₘ₀ :=
  letI f := Submonoid.LocalizationWithZeroMap.lift (toLocalizationWithZeroMap (nonZeroDivisors R) K)
    (ordMonoidWithZeroHom R)
  haveI : ∀ (y : ↥(nonZeroDivisors R)), IsUnit (ordMonoidWithZeroHom R ↑y) := by
    intro y
    simp only [ Equiv.toFun_as_coe, MonoidWithZeroHom.coe_comp, MonoidWithZeroHom.coe_mk,
      ZeroHom.coe_mk, Function.comp_apply, isUnit_iff_ne_zero, ne_eq]
    simp [ordMonoidWithZeroHom, ord]
    have := Module.length_ne_top_iff.mpr <| isFiniteLength_quotient_span_singleton R y.2
    have : ∀ k,
      (WithZero.map' (AddMonoidHom.toMultiplicative (Nat.castAddMonoidHom ℤ))) k = 0 ↔ k = 0 := by
        intro k
        cases k
        all_goals simp
    simpa [this]
  f this

lemma ordFrac_eq_ord (x : R) (hx : x ≠ 0) : ordFrac R (algebraMap R K x) =
  ordMonoidWithZeroHom R x := by
  have := (FaithfulSMul.algebraMap_injective R K).isDomain
  refine (Submonoid.LocalizationMap.lift_eq ..).trans ?_
  simp [ordMonoidWithZeroHom, mem_nonZeroDivisors_iff_ne_zero.mpr hx]

lemma ordFrac_eq_div (a : nonZeroDivisors R) (b : nonZeroDivisors R) :
  ordFrac R (IsLocalization.mk' K a.1 b) = ordMonoidWithZeroHom R a / ordMonoidWithZeroHom R b := by
  simp [ordFrac_eq_ord]

end Ring
