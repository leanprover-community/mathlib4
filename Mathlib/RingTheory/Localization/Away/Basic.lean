/-
Copyright (c) 2018 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau, Mario Carneiro, Johan Commelin, Amelia Livingston, Anne Baanen
-/
import Mathlib.Init.Data.Int.CompLemmas
import Mathlib.RingTheory.UniqueFactorizationDomain
import Mathlib.RingTheory.Localization.Basic

#align_import ring_theory.localization.away.basic from "leanprover-community/mathlib"@"a7c017d750512a352b623b1824d75da5998457d0"

/-!
# Localizations away from an element

## Main definitions

 * `IsLocalization.Away (x : R) S` expresses that `S` is a localization away from `x`, as an
   abbreviation of `IsLocalization (Submonoid.powers x) S`.
 * `exists_reduced_fraction' (hb : b ‚â† 0)` produces a reduced fraction of the form `b = a * x^n` for
   some `n : ‚Ñ§` and some `a : R` that is not divisible by `x`.

## Implementation notes

See `Mathlib/RingTheory/Localization/Basic.lean` for a design overview.

## Tags
localization, ring localization, commutative ring localization, characteristic predicate,
commutative ring, field of fractions
-/


section CommSemiring

variable {R : Type*} [CommSemiring R] (M : Submonoid R) {S : Type*} [CommSemiring S]

variable [Algebra R S] {P : Type*} [CommSemiring P]

namespace IsLocalization

section Away

variable (x : R)

/-- Given `x : R`, the typeclass `IsLocalization.Away x S` states that `S` is
isomorphic to the localization of `R` at the submonoid generated by `x`. -/
abbrev Away (S : Type*) [CommSemiring S] [Algebra R S] :=
  IsLocalization (Submonoid.powers x) S
#align is_localization.away IsLocalization.Away

namespace Away

variable [IsLocalization.Away x S]

/-- Given `x : R` and a localization map `F : R ‚Üí+* S` away from `x`, `invSelf` is `(F x)‚Åª¬π`. -/
noncomputable def invSelf : S :=
  mk' S (1 : R) ‚ü®x, Submonoid.mem_powers _‚ü©
#align is_localization.away.inv_self IsLocalization.Away.invSelf

@[simp]
theorem mul_invSelf : algebraMap R S x * invSelf x = 1 := by
  convert IsLocalization.mk'_mul_mk'_eq_one (M := Submonoid.powers x) (S := S) _ 1
  -- ‚ä¢ ‚Üë(algebraMap R S) x = mk' S (‚Üë{ val := x, property := (_ : x ‚àà Submonoid.pow ‚Ä¶
  symm
  -- ‚ä¢ mk' S (‚Üë{ val := x, property := (_ : x ‚àà Submonoid.powers x) }) 1 = ‚Üë(algebr ‚Ä¶
  apply IsLocalization.mk'_one
  -- üéâ no goals
#align is_localization.away.mul_inv_self IsLocalization.Away.mul_invSelf

variable {g : R ‚Üí+* P}

/-- Given `x : R`, a localization map `F : R ‚Üí+* S` away from `x`, and a map of `CommSemiring`s
`g : R ‚Üí+* P` such that `g x` is invertible, the homomorphism induced from `S` to `P` sending
`z : S` to `g y * (g x)‚Åª‚Åø`, where `y : R, n : ‚Ñï` are such that `z = F y * (F x)‚Åª‚Åø`. -/
noncomputable def lift (hg : IsUnit (g x)) : S ‚Üí+* P :=
  IsLocalization.lift fun y : Submonoid.powers x =>
    show IsUnit (g y.1) by
      obtain ‚ü®n, hn‚ü© := y.2
      -- ‚ä¢ IsUnit (‚Üëg ‚Üëy)
      rw [‚Üê hn, g.map_pow]
      -- ‚ä¢ IsUnit (‚Üëg x ^ n)
      exact IsUnit.map (powMonoidHom n : P ‚Üí* P) hg
      -- üéâ no goals
#align is_localization.away.lift IsLocalization.Away.lift

@[simp]
theorem AwayMap.lift_eq (hg : IsUnit (g x)) (a : R) : lift x hg ((algebraMap R S) a) = g a :=
  IsLocalization.lift_eq _ _
#align is_localization.away.away_map.lift_eq IsLocalization.Away.AwayMap.lift_eq

@[simp]
theorem AwayMap.lift_comp (hg : IsUnit (g x)) : (lift x hg).comp (algebraMap R S) = g :=
  IsLocalization.lift_comp _
#align is_localization.away.away_map.lift_comp IsLocalization.Away.AwayMap.lift_comp

/-- Given `x y : R` and localizations `S`, `P` away from `x` and `x * y`
respectively, the homomorphism induced from `S` to `P`. -/
noncomputable def awayToAwayRight (y : R) [Algebra R P] [IsLocalization.Away (x * y) P] : S ‚Üí+* P :=
  lift x <|
    show IsUnit ((algebraMap R P) x) from
      isUnit_of_mul_eq_one ((algebraMap R P) x) (mk' P y ‚ü®x * y, Submonoid.mem_powers _‚ü©) <| by
        rw [mul_mk'_eq_mk'_of_mul, mk'_self]
        -- üéâ no goals
#align is_localization.away.away_to_away_right IsLocalization.Away.awayToAwayRight

variable (S) (Q : Type*) [CommSemiring Q] [Algebra P Q]

/-- Given a map `f : R ‚Üí+* S` and an element `r : R`, we may construct a map `R·µ£ ‚Üí+* S·µ£`. -/
noncomputable def map (f : R ‚Üí+* P) (r : R) [IsLocalization.Away r S]
    [IsLocalization.Away (f r) Q] : S ‚Üí+* Q :=
  IsLocalization.map Q f
    (show Submonoid.powers r ‚â§ (Submonoid.powers (f r)).comap f by
      rintro x ‚ü®n, rfl‚ü©
      -- ‚ä¢ (fun x x_1 => x ^ x_1) r n ‚àà Submonoid.comap f (Submonoid.powers (‚Üëf r))
      use n
      -- ‚ä¢ (fun x x_1 => x ^ x_1) (‚Üëf r) n = ‚Üëf ((fun x x_1 => x ^ x_1) r n)
      simp)
      -- üéâ no goals
#align is_localization.away.map IsLocalization.Away.map

end Away

end Away

variable [IsLocalization M S]

section AtUnits

variable (R) (S)

/-- The localization at a module of units is isomorphic to the ring. -/
noncomputable def atUnits (H : ‚àÄ x : M, IsUnit (x : R)) : R ‚âÉ‚Çê[R] S := by
  refine' AlgEquiv.ofBijective (Algebra.ofId R S) ‚ü®_, _‚ü©
  -- ‚ä¢ Function.Injective ‚Üë(Algebra.ofId R S)
  ¬∑ intro x y hxy
    -- ‚ä¢ x = y
    obtain ‚ü®c, eq‚ü© := (IsLocalization.eq_iff_exists M S).mp hxy
    -- ‚ä¢ x = y
    obtain ‚ü®u, hu‚ü© := H c
    -- ‚ä¢ x = y
    rwa [‚Üê hu, Units.mul_right_inj] at eq
    -- üéâ no goals
  ¬∑ intro y
    -- ‚ä¢ ‚àÉ a, ‚Üë(Algebra.ofId R S) a = y
    obtain ‚ü®‚ü®x, s‚ü©, eq‚ü© := IsLocalization.surj M y
    -- ‚ä¢ ‚àÉ a, ‚Üë(Algebra.ofId R S) a = y
    obtain ‚ü®u, hu‚ü© := H s
    -- ‚ä¢ ‚àÉ a, ‚Üë(Algebra.ofId R S) a = y
    use x * u.inv
    -- ‚ä¢ ‚Üë(Algebra.ofId R S) (x * u.inv) = y
    dsimp [Algebra.ofId, RingHom.toFun_eq_coe, AlgHom.coe_mks]
    -- ‚ä¢ ‚Üë(algebraMap R S) (x * ‚Üëu‚Åª¬π) = y
    rw [RingHom.map_mul, ‚Üê eq, ‚Üê hu, mul_assoc, ‚Üê RingHom.map_mul]
    -- ‚ä¢ y * ‚Üë(algebraMap R S) (‚Üëu * ‚Üëu‚Åª¬π) = y
    simp
    -- üéâ no goals
#align is_localization.at_units IsLocalization.atUnits

/-- The localization away from a unit is isomorphic to the ring. -/
noncomputable def atUnit (x : R) (e : IsUnit x) [IsLocalization.Away x S] : R ‚âÉ‚Çê[R] S := by
  apply atUnits R (Submonoid.powers x)
  -- ‚ä¢ ‚àÄ (x_1 : { x_1 // x_1 ‚àà Submonoid.powers x }), IsUnit ‚Üëx_1
  rintro ‚ü®xn, n, hxn‚ü©
  -- ‚ä¢ IsUnit ‚Üë{ val := xn, property := (_ : ‚àÉ y, (fun x x_1 => x ^ x_1) x y = xn) }
  obtain ‚ü®u, hu‚ü© := e
  -- ‚ä¢ IsUnit ‚Üë{ val := xn, property := (_ : ‚àÉ y, (fun x x_1 => x ^ x_1) x y = xn) }
  rw [isUnit_iff_exists_inv]
  -- ‚ä¢ ‚àÉ b, ‚Üë{ val := xn, property := (_ : ‚àÉ y, (fun x x_1 => x ^ x_1) x y = xn) }  ‚Ä¶
  use u.inv ^ n
  -- ‚ä¢ ‚Üë{ val := xn, property := (_ : ‚àÉ y, (fun x x_1 => x ^ x_1) x y = xn) } * u.i ‚Ä¶
  simp [‚Üê hxn, ‚Üê hu, ‚Üê mul_pow]
  -- üéâ no goals
#align is_localization.at_unit IsLocalization.atUnit

/-- The localization at one is isomorphic to the ring. -/
noncomputable def atOne [IsLocalization.Away (1 : R) S] : R ‚âÉ‚Çê[R] S :=
  @atUnit R _ S _ _ (1 : R) isUnit_one _
#align is_localization.at_one IsLocalization.atOne

theorem away_of_isUnit_of_bijective {R : Type*} (S : Type*) [CommRing R] [CommRing S]
    [Algebra R S] {r : R} (hr : IsUnit r) (H : Function.Bijective (algebraMap R S)) :
    IsLocalization.Away r S :=
  { map_units' := by
      rintro ‚ü®_, n, rfl‚ü©
      -- ‚ä¢ IsUnit (‚Üë(algebraMap R S) ‚Üë{ val := (fun x x_1 => x ^ x_1) r n, property :=  ‚Ä¶
      exact (algebraMap R S).isUnit_map (hr.pow _)
      -- üéâ no goals
    surj' := fun z => by
      obtain ‚ü®z', rfl‚ü© := H.2 z
      -- ‚ä¢ ‚àÉ x, ‚Üë(algebraMap R S) z' * ‚Üë(algebraMap R S) ‚Üëx.snd = ‚Üë(algebraMap R S) x.fst
      exact ‚ü®‚ü®z', 1‚ü©, by simp‚ü©
      -- üéâ no goals
    eq_iff_exists' := fun {x y} => by
      erw [H.1.eq_iff]
      -- ‚ä¢ x = y ‚Üî ‚àÉ c, ‚Üëc * x = ‚Üëc * y
      constructor
      -- ‚ä¢ x = y ‚Üí ‚àÉ c, ‚Üëc * x = ‚Üëc * y
      ¬∑ rintro rfl
        -- ‚ä¢ ‚àÉ c, ‚Üëc * x = ‚Üëc * x
        exact ‚ü®1, rfl‚ü©
        -- üéâ no goals
      ¬∑ rintro ‚ü®‚ü®_, n, rfl‚ü©, e‚ü©
        -- ‚ä¢ x = y
        exact (hr.pow _).mul_right_inj.mp e }
        -- üéâ no goals
#align is_localization.away_of_is_unit_of_bijective IsLocalization.away_of_isUnit_of_bijective

end AtUnits

end IsLocalization

namespace Localization

open IsLocalization

variable {M}

/-- Given a map `f : R ‚Üí+* S` and an element `r : R`, such that `f r` is invertible,
  we may construct a map `R·µ£ ‚Üí+* S`. -/
noncomputable abbrev awayLift (f : R ‚Üí+* P) (r : R) (hr : IsUnit (f r)) :
    Localization.Away r ‚Üí+* P :=
  IsLocalization.Away.lift r hr
#align localization.away_lift Localization.awayLift

/-- Given a map `f : R ‚Üí+* S` and an element `r : R`, we may construct a map `R·µ£ ‚Üí+* S·µ£`. -/
noncomputable abbrev awayMap (f : R ‚Üí+* P) (r : R) :
    Localization.Away r ‚Üí+* Localization.Away (f r) :=
  IsLocalization.Away.map _ _ f r
#align localization.away_map Localization.awayMap

end Localization

end CommSemiring

open Localization

variable {R : Type*} [CommRing R]

section NumDen

open UniqueFactorizationMonoid IsLocalization

variable (x : R)

variable (B : Type*) [CommRing B] [Algebra R B] [IsLocalization.Away x B]

/-- `selfZpow x (m : ‚Ñ§)` is `x ^ m` as an element of the localization away from `x`. -/
noncomputable def selfZpow (m : ‚Ñ§) : B :=
  if _ : 0 ‚â§ m then algebraMap _ _ x ^ m.natAbs else mk' _ (1 : R) (Submonoid.pow x m.natAbs)
#align self_zpow selfZpow

theorem selfZpow_of_nonneg {n : ‚Ñ§} (hn : 0 ‚â§ n) : selfZpow x B n = algebraMap R B x ^ n.natAbs :=
  dif_pos hn
#align self_zpow_of_nonneg selfZpow_of_nonneg

@[simp]
theorem selfZpow_coe_nat (d : ‚Ñï) : selfZpow x B d = algebraMap R B x ^ d :=
  selfZpow_of_nonneg _ _ (Int.coe_nat_nonneg d)
#align self_zpow_coe_nat selfZpow_coe_nat

@[simp]
theorem selfZpow_zero : selfZpow x B 0 = 1 := by
  simp [selfZpow_of_nonneg _ _ le_rfl]
  -- üéâ no goals
#align self_zpow_zero selfZpow_zero

theorem selfZpow_of_neg {n : ‚Ñ§} (hn : n < 0) :
    selfZpow x B n = mk' _ (1 : R) (Submonoid.pow x n.natAbs) :=
  dif_neg hn.not_le
#align self_zpow_of_neg selfZpow_of_neg

theorem selfZpow_of_nonpos {n : ‚Ñ§} (hn : n ‚â§ 0) :
    selfZpow x B n = mk' _ (1 : R) (Submonoid.pow x n.natAbs) := by
  by_cases hn0 : n = 0
  -- ‚ä¢ selfZpow x B n = mk' B 1 (Submonoid.pow x (Int.natAbs n))
  ¬∑ simp [hn0, selfZpow_zero, Submonoid.pow_apply]
    -- üéâ no goals
  ¬∑ simp [selfZpow_of_neg _ _ (lt_of_le_of_ne hn hn0)]
    -- üéâ no goals
#align self_zpow_of_nonpos selfZpow_of_nonpos

@[simp]
theorem selfZpow_neg_coe_nat (d : ‚Ñï) : selfZpow x B (-d) = mk' _ (1 : R) (Submonoid.pow x d) := by
  simp [selfZpow_of_nonpos _ _ (neg_nonpos.mpr (Int.coe_nat_nonneg d))]
  -- üéâ no goals
#align self_zpow_neg_coe_nat selfZpow_neg_coe_nat

@[simp]
theorem selfZpow_sub_cast_nat {n m : ‚Ñï} :
    selfZpow x B (n - m) = mk' _ (x ^ n) (Submonoid.pow x m) := by
  by_cases h : m ‚â§ n
  -- ‚ä¢ selfZpow x B (‚Üën - ‚Üëm) = mk' B (x ^ n) (Submonoid.pow x m)
  ¬∑ rw [IsLocalization.eq_mk'_iff_mul_eq, Submonoid.pow_apply, Subtype.coe_mk, ‚Üê Int.ofNat_sub h,
      selfZpow_coe_nat, ‚Üê map_pow, ‚Üê map_mul, ‚Üê pow_add, Nat.sub_add_cancel h]
  ¬∑ rw [‚Üê neg_sub, ‚Üê Int.ofNat_sub (le_of_not_le h), selfZpow_neg_coe_nat,
      IsLocalization.mk'_eq_iff_eq]
    simp [Submonoid.pow_apply, ‚Üê pow_add, Nat.sub_add_cancel (le_of_not_le h)]
    -- üéâ no goals
#align self_zpow_sub_cast_nat selfZpow_sub_cast_nat

@[simp]
theorem selfZpow_add {n m : ‚Ñ§} : selfZpow x B (n + m) = selfZpow x B n * selfZpow x B m := by
  cases' le_or_lt 0 n with hn hn <;> cases' le_or_lt 0 m with hm hm
  -- ‚ä¢ selfZpow x B (n + m) = selfZpow x B n * selfZpow x B m
                                     -- ‚ä¢ selfZpow x B (n + m) = selfZpow x B n * selfZpow x B m
                                     -- ‚ä¢ selfZpow x B (n + m) = selfZpow x B n * selfZpow x B m
  ¬∑ rw [selfZpow_of_nonneg _ _ hn, selfZpow_of_nonneg _ _ hm,
      selfZpow_of_nonneg _ _ (add_nonneg hn hm), Int.natAbs_add_nonneg hn hm, pow_add]
  ¬∑ have : n + m = n.natAbs - m.natAbs := by
      rw [Int.natAbs_of_nonneg hn, Int.ofNat_natAbs_of_nonpos hm.le, sub_neg_eq_add]
    rw [selfZpow_of_nonneg _ _ hn, selfZpow_of_neg _ _ hm, this, selfZpow_sub_cast_nat,
      IsLocalization.mk'_eq_mul_mk'_one, map_pow]
  ¬∑ have : n + m = m.natAbs - n.natAbs := by
      rw [Int.natAbs_of_nonneg hm, Int.ofNat_natAbs_of_nonpos hn.le, sub_neg_eq_add, add_comm]
    rw [selfZpow_of_nonneg _ _ hm, selfZpow_of_neg _ _ hn, this, selfZpow_sub_cast_nat,
      IsLocalization.mk'_eq_mul_mk'_one, map_pow, mul_comm]
  ¬∑ rw [selfZpow_of_neg _ _ hn, selfZpow_of_neg _ _ hm, selfZpow_of_neg _ _ (add_neg hn hm),
      Int.natAbs_add_neg hn hm, ‚Üê mk'_mul, one_mul]
    congr
    -- ‚ä¢ Submonoid.pow x (Int.natAbs n + Int.natAbs m) = Submonoid.pow x (Int.natAbs  ‚Ä¶
    ext
    -- ‚ä¢ ‚Üë(Submonoid.pow x (Int.natAbs n + Int.natAbs m)) = ‚Üë(Submonoid.pow x (Int.na ‚Ä¶
    simp [pow_add]
    -- üéâ no goals
#align self_zpow_add selfZpow_add

theorem selfZpow_mul_neg (d : ‚Ñ§) : selfZpow x B d * selfZpow x B (-d) = 1 := by
  by_cases hd : d ‚â§ 0
  -- ‚ä¢ selfZpow x B d * selfZpow x B (-d) = 1
  ¬∑ erw [selfZpow_of_nonpos x B hd, selfZpow_of_nonneg, ‚Üê map_pow, Int.natAbs_neg,
      IsLocalization.mk'_spec, map_one]
    apply nonneg_of_neg_nonpos
    -- ‚ä¢ - -d ‚â§ 0
    rwa [neg_neg]
    -- üéâ no goals
  ¬∑ erw [selfZpow_of_nonneg x B (le_of_not_le hd), selfZpow_of_nonpos, ‚Üê map_pow, Int.natAbs_neg,
      @IsLocalization.mk'_spec' R _ (Submonoid.powers x) B _ _ _ 1 (Submonoid.pow x d.natAbs),
      map_one]
    refine' nonpos_of_neg_nonneg (le_of_lt _)
    -- ‚ä¢ 0 < - -d
    rwa [neg_neg, ‚Üê not_le]
    -- üéâ no goals
#align self_zpow_mul_neg selfZpow_mul_neg

theorem selfZpow_neg_mul (d : ‚Ñ§) : selfZpow x B (-d) * selfZpow x B d = 1 := by
  rw [mul_comm, selfZpow_mul_neg x B d]
  -- üéâ no goals
#align self_zpow_neg_mul selfZpow_neg_mul

theorem selfZpow_pow_sub (a : R) (b : B) (m d : ‚Ñ§) :
    selfZpow x B (m - d) * mk' B a (1 : Submonoid.powers x) = b ‚Üî
      selfZpow x B m * mk' B a (1 : Submonoid.powers x) = selfZpow x B d * b := by
  rw [sub_eq_add_neg, selfZpow_add, mul_assoc, mul_comm _ (mk' B a 1), ‚Üê mul_assoc]
  -- ‚ä¢ selfZpow x B m * mk' B a 1 * selfZpow x B (-d) = b ‚Üî selfZpow x B m * mk' B  ‚Ä¶
  constructor
  -- ‚ä¢ selfZpow x B m * mk' B a 1 * selfZpow x B (-d) = b ‚Üí selfZpow x B m * mk' B  ‚Ä¶
  ¬∑ intro h
    -- ‚ä¢ selfZpow x B m * mk' B a 1 = selfZpow x B d * b
    have := congr_arg (fun s : B => s * selfZpow x B d) h
    -- ‚ä¢ selfZpow x B m * mk' B a 1 = selfZpow x B d * b
    simp only at this
    -- ‚ä¢ selfZpow x B m * mk' B a 1 = selfZpow x B d * b
    rwa [mul_assoc, mul_assoc, selfZpow_neg_mul, mul_one, mul_comm b _] at this
    -- üéâ no goals
  ¬∑ intro h
    -- ‚ä¢ selfZpow x B m * mk' B a 1 * selfZpow x B (-d) = b
    have := congr_arg (fun s : B => s * selfZpow x B (-d)) h
    -- ‚ä¢ selfZpow x B m * mk' B a 1 * selfZpow x B (-d) = b
    simp only at this
    -- ‚ä¢ selfZpow x B m * mk' B a 1 * selfZpow x B (-d) = b
    rwa [mul_comm _ b, mul_assoc b _ _, selfZpow_mul_neg, mul_one] at this
    -- üéâ no goals
#align self_zpow_pow_sub selfZpow_pow_sub

variable [IsDomain R] [NormalizationMonoid R] [UniqueFactorizationMonoid R]

theorem exists_reduced_fraction' {b : B} (hb : b ‚â† 0) (hx : Irreducible x) :
    ‚àÉ (a : R) (n : ‚Ñ§), ¬¨x ‚à£ a ‚àß selfZpow x B n * algebraMap R B a = b := by
  obtain ‚ü®‚ü®a‚ÇÄ, y‚ü©, H‚ü© := surj (Submonoid.powers x) b
  -- ‚ä¢ ‚àÉ a n, ¬¨x ‚à£ a ‚àß selfZpow x B n * ‚Üë(algebraMap R B) a = b
  obtain ‚ü®d, hy‚ü© := (Submonoid.mem_powers_iff y.1 x).mp y.2
  -- ‚ä¢ ‚àÉ a n, ¬¨x ‚à£ a ‚àß selfZpow x B n * ‚Üë(algebraMap R B) a = b
  have ha‚ÇÄ : a‚ÇÄ ‚â† 0 := by
    haveI :=
      @isDomain_of_le_nonZeroDivisors B _ R _ _ _ (Submonoid.powers x) _
        (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
    simp only [map_zero, ‚Üê hy, map_pow] at H
    apply ((injective_iff_map_eq_zero' (algebraMap R B)).mp _ a‚ÇÄ).mpr.mt
    rw [‚Üê H]
    apply mul_ne_zero hb (pow_ne_zero _ _)
    exact
      IsLocalization.to_map_ne_zero_of_mem_nonZeroDivisors B
        (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
        (mem_nonZeroDivisors_iff_ne_zero.mpr hx.ne_zero)
    exact IsLocalization.injective B (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
  simp only [‚Üê hy] at H
  -- ‚ä¢ ‚àÉ a n, ¬¨x ‚à£ a ‚àß selfZpow x B n * ‚Üë(algebraMap R B) a = b
  classical
  obtain ‚ü®m, a, hyp1, hyp2‚ü© := max_power_factor ha‚ÇÄ hx
  refine' ‚ü®a, m - d, _‚ü©
  rw [‚Üê mk'_one (M := Submonoid.powers x) B, selfZpow_pow_sub, selfZpow_coe_nat, selfZpow_coe_nat,
    ‚Üê map_pow _ _ d, mul_comm _ b, H, hyp2, map_mul, map_pow _ _ m]
  exact ‚ü®hyp1, congr_arg _ (IsLocalization.mk'_one _ _)‚ü©
#align exists_reduced_fraction' exists_reduced_fraction'

end NumDen
