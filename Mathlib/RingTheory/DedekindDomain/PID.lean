/-
Copyright (c) 2023 Anne Baanen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anne Baanen
-/
import Mathlib.RingTheory.DedekindDomain.Dvr
import Mathlib.RingTheory.DedekindDomain.Ideal

#align_import ring_theory.dedekind_domain.pid from "leanprover-community/mathlib"@"6010cf523816335f7bae7f8584cb2edaace73940"

/-!
# Proving a Dedekind domain is a PID

This file contains some results that we can use to show all ideals in a Dedekind domain are
principal.

## Main results

 * `Ideal.IsPrincipal.of_finite_maximals_of_isUnit`: an invertible ideal in a commutative ring
   with finitely many maximal ideals, is a principal ideal.
 * `IsPrincipalIdealRing.of_finite_primes`: if a Dedekind domain has finitely many prime ideals,
   it is a principal ideal domain.
-/


variable {R : Type*} [CommRing R]

open Ideal

open UniqueFactorizationMonoid

open scoped BigOperators

open scoped nonZeroDivisors

open UniqueFactorizationMonoid

/-- Let `P` be a prime ideal, `x ‚àà P \ P¬≤` and `x ‚àâ Q` for all prime ideals `Q ‚â† P`.
Then `P` is generated by `x`. -/
theorem Ideal.eq_span_singleton_of_mem_of_not_mem_sq_of_not_mem_prime_ne {P : Ideal R}
    (hP : P.IsPrime) [IsDomain R] [IsDedekindDomain R] {x : R} (x_mem : x ‚àà P) (hxP2 : x ‚àâ P ^ 2)
    (hxQ : ‚àÄ Q : Ideal R, IsPrime Q ‚Üí Q ‚â† P ‚Üí x ‚àâ Q) : P = Ideal.span {x} := by
  letI := Classical.decEq (Ideal R)
  -- ‚ä¢ P = span {x}
  have hx0 : x ‚â† 0 := by
    rintro rfl
    exact hxP2 (zero_mem _)
  by_cases hP0 : P = ‚ä•
  -- ‚ä¢ P = span {x}
  ¬∑ subst hP0
    -- ‚ä¢ ‚ä• = span {x}
    -- Porting note: was `simpa using hxP2` but that hypothesis didn't even seem relevant in Lean 3
    rwa [eq_comm, span_singleton_eq_bot, ‚Üê mem_bot]
    -- üéâ no goals
  have hspan0 : span ({x} : Set R) ‚â† ‚ä• := mt Ideal.span_singleton_eq_bot.mp hx0
  -- ‚ä¢ P = span {x}
  have span_le := (Ideal.span_singleton_le_iff_mem _).mpr x_mem
  -- ‚ä¢ P = span {x}
  refine'
    associated_iff_eq.mp
      ((associated_iff_normalizedFactors_eq_normalizedFactors hP0 hspan0).mpr
        (le_antisymm ((dvd_iff_normalizedFactors_le_normalizedFactors hP0 hspan0).mp _) _))
  ¬∑ rwa [Ideal.dvd_iff_le, Ideal.span_singleton_le_iff_mem]
    -- üéâ no goals
  simp only [normalizedFactors_irreducible (Ideal.prime_of_isPrime hP0 hP).irreducible,
    normalize_eq, Multiset.le_iff_count, Multiset.count_singleton]
  intro Q
  -- ‚ä¢ Multiset.count Q (normalizedFactors (span {x})) ‚â§ if Q = P then 1 else 0
  split_ifs with hQ
  -- ‚ä¢ Multiset.count Q (normalizedFactors (span {x})) ‚â§ 1
  ¬∑ subst hQ
    -- ‚ä¢ Multiset.count Q (normalizedFactors (span {x})) ‚â§ 1
    refine' (Ideal.count_normalizedFactors_eq _ _).le <;>
    -- ‚ä¢ span {x} ‚â§ Q ^ 1
        simp only [Ideal.span_singleton_le_iff_mem, pow_one] <;>
        -- ‚ä¢ x ‚àà Q
        -- ‚ä¢ ¬¨x ‚àà Q ^ (1 + 1)
      assumption
      -- üéâ no goals
      -- üéâ no goals
  by_cases hQp : IsPrime Q
  -- ‚ä¢ Multiset.count Q (normalizedFactors (span {x})) ‚â§ 0
  ¬∑ skip
    -- ‚ä¢ Multiset.count Q (normalizedFactors (span {x})) ‚â§ 0
    refine' (Ideal.count_normalizedFactors_eq _ _).le <;>
    -- ‚ä¢ span {x} ‚â§ Q ^ 0
      -- Porting note: included `zero_add` in the simp arguments
      simp only [Ideal.span_singleton_le_iff_mem, zero_add, pow_one, pow_zero, one_eq_top,
                 Submodule.mem_top]
    exact hxQ _ hQp hQ
    -- üéâ no goals
  ¬∑ exact
      (Multiset.count_eq_zero.mpr fun hQi =>
          hQp
            (isPrime_of_prime
              (irreducible_iff_prime.mp (irreducible_of_normalized_factor _ hQi)))).le
#align ideal.eq_span_singleton_of_mem_of_not_mem_sq_of_not_mem_prime_ne Ideal.eq_span_singleton_of_mem_of_not_mem_sq_of_not_mem_prime_ne

-- Porting note: replaced three implicit coercions of `I` with explicit `(I : Submodule R A)`
theorem FractionalIdeal.isPrincipal_of_unit_of_comap_mul_span_singleton_eq_top {R A : Type*}
    [CommRing R] [CommRing A] [Algebra R A] {S : Submonoid R} [IsLocalization S A]
    (I : (FractionalIdeal S A)À£) {v : A} (hv : v ‚àà (‚ÜëI‚Åª¬π : FractionalIdeal S A))
    (h : Submodule.comap (Algebra.linearMap R A) ((I : Submodule R A) * Submodule.span R {v}) = ‚ä§) :
    Submodule.IsPrincipal (I : Submodule R A) := by
  have hinv := I.mul_inv
  -- ‚ä¢ Submodule.IsPrincipal ‚Üë‚ÜëI
  set J := Submodule.comap (Algebra.linearMap R A) ((I : Submodule R A) * Submodule.span R {v})
  -- ‚ä¢ Submodule.IsPrincipal ‚Üë‚ÜëI
  have hJ : IsLocalization.coeSubmodule A J = ‚ÜëI * Submodule.span R {v} := by
    -- Porting note: had to insert `val_eq_coe` into this rewrite.
    -- Arguably this is because `Subtype.ext_iff` is breaking the `FractionalIdeal` API.
    rw [Subtype.ext_iff, val_eq_coe, coe_mul, val_eq_coe, coe_one] at hinv
    apply Submodule.map_comap_eq_self
    rw [‚Üê Submodule.one_eq_range, ‚Üê hinv]
    exact Submodule.mul_le_mul_right ((Submodule.span_singleton_le_iff_mem _ _).2 hv)
  have : (1 : A) ‚àà ‚ÜëI * Submodule.span R {v} := by
    rw [‚Üê hJ, h, IsLocalization.coeSubmodule_top, Submodule.mem_one]
    exact ‚ü®1, (algebraMap R _).map_one‚ü©
  obtain ‚ü®w, hw, hvw‚ü© := Submodule.mem_mul_span_singleton.1 this
  -- ‚ä¢ Submodule.IsPrincipal ‚Üë‚ÜëI
  refine' ‚ü®‚ü®w, _‚ü©‚ü©
  -- ‚ä¢ ‚Üë‚ÜëI = Submodule.span R {w}
  rw [‚Üê FractionalIdeal.coe_spanSingleton S, ‚Üê inv_inv I, eq_comm]
  -- ‚ä¢ ‚Üë(spanSingleton S w) = ‚Üë‚ÜëI‚Åª¬π‚Åª¬π
  refine' congr_arg (‚Üë) (Units.eq_inv_of_mul_eq_one_left (le_antisymm _ _))
  -- ‚ä¢ ‚ÜëI‚Åª¬π * spanSingleton S w ‚â§ 1
  ¬∑ conv_rhs => rw [‚Üê hinv, mul_comm]
    -- ‚ä¢ ‚ÜëI‚Åª¬π * spanSingleton S w ‚â§ ‚ÜëI‚Åª¬π * ‚ÜëI
    apply FractionalIdeal.mul_le_mul_left (FractionalIdeal.spanSingleton_le_iff_mem.mpr hw)
    -- üéâ no goals
  ¬∑ rw [FractionalIdeal.one_le, ‚Üê hvw, mul_comm]
    -- ‚ä¢ v * w ‚àà ‚ÜëI‚Åª¬π * spanSingleton S w
    exact FractionalIdeal.mul_mem_mul hv (FractionalIdeal.mem_spanSingleton_self _ _)
    -- üéâ no goals
#align fractional_ideal.is_principal_of_unit_of_comap_mul_span_singleton_eq_top FractionalIdeal.isPrincipal_of_unit_of_comap_mul_span_singleton_eq_top

/--
An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.

https://math.stackexchange.com/a/95857 -/
theorem FractionalIdeal.isPrincipal.of_finite_maximals_of_inv {A : Type*} [CommRing A]
    [Algebra R A] {S : Submonoid R} [IsLocalization S A] (hS : S ‚â§ R‚Å∞)
    (hf : {I : Ideal R | I.IsMaximal}.Finite) (I I' : FractionalIdeal S A) (hinv : I * I' = 1) :
    Submodule.IsPrincipal (I : Submodule R A) := by
  have hinv' := hinv
  -- ‚ä¢ Submodule.IsPrincipal ‚ÜëI
  rw [Subtype.ext_iff, val_eq_coe, coe_mul] at hinv
  -- ‚ä¢ Submodule.IsPrincipal ‚ÜëI
  let s := hf.toFinset
  -- ‚ä¢ Submodule.IsPrincipal ‚ÜëI
  haveI := Classical.decEq (Ideal R)
  -- ‚ä¢ Submodule.IsPrincipal ‚ÜëI
  have coprime : ‚àÄ M ‚àà s, ‚àÄ M' ‚àà s.erase M, M ‚äî M' = ‚ä§ := by
    simp_rw [Finset.mem_erase, hf.mem_toFinset]
    rintro M hM M' ‚ü®hne, hM'‚ü©
    exact Ideal.IsMaximal.coprime_of_ne hM hM' hne.symm
  have nle : ‚àÄ M ‚àà s, ¬¨‚®Ö M' ‚àà s.erase M, M' ‚â§ M := fun M hM =>
    left_lt_sup.1
      ((hf.mem_toFinset.1 hM).ne_top.lt_top.trans_eq (Ideal.sup_iInf_eq_top <| coprime M hM).symm)
  have : ‚àÄ M ‚àà s, ‚àÉ a ‚àà I, ‚àÉ b ‚àà I', a * b ‚àâ IsLocalization.coeSubmodule A M := by
    intro M hM; by_contra' h
    obtain ‚ü®x, hx, hxM‚ü© :=
      SetLike.exists_of_lt
        ((IsLocalization.coeSubmodule_strictMono hS (hf.mem_toFinset.1 hM).ne_top.lt_top).trans_eq
          hinv.symm)
    refine' hxM (Submodule.map‚ÇÇ_le.2 _ hx); exact h
  choose! a ha b hb hm using this
  -- ‚ä¢ Submodule.IsPrincipal ‚ÜëI
  choose! u hu hum using fun M hM => SetLike.not_le_iff_exists.1 (nle M hM)
  -- ‚ä¢ Submodule.IsPrincipal ‚ÜëI
  let v := ‚àë M in s, u M ‚Ä¢ b M
  -- ‚ä¢ Submodule.IsPrincipal ‚ÜëI
  have hv : v ‚àà I' := Submodule.sum_mem _ fun M hM => Submodule.smul_mem _ _ <| hb M hM
  -- ‚ä¢ Submodule.IsPrincipal ‚ÜëI
  refine'
    FractionalIdeal.isPrincipal_of_unit_of_comap_mul_span_singleton_eq_top
      (Units.mkOfMulEqOne I I' hinv') hv (of_not_not fun h => _)
  obtain ‚ü®M, hM, hJM‚ü© := Ideal.exists_le_maximal _ h
  -- ‚ä¢ False
  replace hM := hf.mem_toFinset.2 hM
  -- ‚ä¢ False
  have : ‚àÄ a ‚àà I, ‚àÄ b ‚àà I', ‚àÉ c, algebraMap R _ c = a * b := by
    intro a ha b hb; have hi := hinv.le
    obtain ‚ü®c, -, hc‚ü© := hi (Submodule.mul_mem_mul ha hb)
    exact ‚ü®c, hc‚ü©
  have hmem : a M * v ‚àà IsLocalization.coeSubmodule A M := by
    obtain ‚ü®c, hc‚ü© := this _ (ha M hM) v hv
    refine' IsLocalization.coeSubmodule_mono _ hJM ‚ü®c, _, hc‚ü©
    have := Submodule.mul_mem_mul (ha M hM) (Submodule.mem_span_singleton_self v)
    rwa [‚Üê hc] at this
  simp_rw [Finset.mul_sum, mul_smul_comm] at hmem
  -- ‚ä¢ False
  rw [‚Üê s.add_sum_erase _ hM, Submodule.add_mem_iff_left] at hmem
  -- ‚ä¢ False
  ¬∑ refine' hm M hM _
    -- ‚ä¢ a M * b M ‚àà IsLocalization.coeSubmodule A M
    obtain ‚ü®c, hc : algebraMap R A c = a M * b M‚ü© := this _ (ha M hM) _ (hb M hM)
    -- ‚ä¢ a M * b M ‚àà IsLocalization.coeSubmodule A M
    rw [‚Üê hc] at hmem ‚ä¢
    -- ‚ä¢ ‚Üë(algebraMap R A) c ‚àà IsLocalization.coeSubmodule A M
    rw [Algebra.smul_def, ‚Üê _root_.map_mul] at hmem
    -- ‚ä¢ ‚Üë(algebraMap R A) c ‚àà IsLocalization.coeSubmodule A M
    obtain ‚ü®d, hdM, he‚ü© := hmem
    -- ‚ä¢ ‚Üë(algebraMap R A) c ‚àà IsLocalization.coeSubmodule A M
    rw [IsLocalization.injective _ hS he] at hdM
    -- ‚ä¢ ‚Üë(algebraMap R A) c ‚àà IsLocalization.coeSubmodule A M
    exact
      Submodule.mem_map_of_mem
        (((hf.mem_toFinset.1 hM).isPrime.mem_or_mem hdM).resolve_left <| hum M hM)
  ¬∑ refine' Submodule.sum_mem _ fun M' hM' => _
    -- ‚ä¢ u M' ‚Ä¢ (a M * b M') ‚àà IsLocalization.coeSubmodule A M
    rw [Finset.mem_erase] at hM'
    -- ‚ä¢ u M' ‚Ä¢ (a M * b M') ‚àà IsLocalization.coeSubmodule A M
    obtain ‚ü®c, hc‚ü© := this _ (ha M hM) _ (hb M' hM'.2)
    -- ‚ä¢ u M' ‚Ä¢ (a M * b M') ‚àà IsLocalization.coeSubmodule A M
    rw [‚Üê hc, Algebra.smul_def, ‚Üê _root_.map_mul]
    -- ‚ä¢ ‚Üë(algebraMap R A) (u M' * c) ‚àà IsLocalization.coeSubmodule A M
    specialize hu M' hM'.2
    -- ‚ä¢ ‚Üë(algebraMap R A) (u M' * c) ‚àà IsLocalization.coeSubmodule A M
    simp_rw [Ideal.mem_iInf, Finset.mem_erase] at hu
    -- ‚ä¢ ‚Üë(algebraMap R A) (u M' * c) ‚àà IsLocalization.coeSubmodule A M
    exact Submodule.mem_map_of_mem (M.mul_mem_right _ <| hu M ‚ü®hM'.1.symm, hM‚ü©)
    -- üéâ no goals
#align fractional_ideal.is_principal.of_finite_maximals_of_inv FractionalIdeal.isPrincipal.of_finite_maximals_of_inv

/-- An invertible ideal in a commutative ring with finitely many maximal ideals is principal.

https://math.stackexchange.com/a/95857 -/
theorem Ideal.IsPrincipal.of_finite_maximals_of_isUnit (hf : {I : Ideal R | I.IsMaximal}.Finite)
    {I : Ideal R} (hI : IsUnit (I : FractionalIdeal R‚Å∞ (FractionRing R))) : I.IsPrincipal :=
  (IsLocalization.coeSubmodule_isPrincipal _ le_rfl).mp
    (FractionalIdeal.isPrincipal.of_finite_maximals_of_inv le_rfl hf I
      (‚ÜëhI.unit‚Åª¬π : FractionalIdeal R‚Å∞ (FractionRing R)) hI.unit.mul_inv)
#align ideal.is_principal.of_finite_maximals_of_is_unit Ideal.IsPrincipal.of_finite_maximals_of_isUnit

/-- A Dedekind domain is a PID if its set of primes is finite. -/
theorem IsPrincipalIdealRing.of_finite_primes [IsDomain R] [IsDedekindDomain R]
    (h : {I : Ideal R | I.IsPrime}.Finite) : IsPrincipalIdealRing R :=
  ‚ü®fun I => by
    obtain rfl | hI := eq_or_ne I ‚ä•
    -- ‚ä¢ Submodule.IsPrincipal ‚ä•
    ¬∑ exact bot_isPrincipal
      -- üéâ no goals
    apply Ideal.IsPrincipal.of_finite_maximals_of_isUnit
    -- ‚ä¢ Set.Finite {I | IsMaximal I}
    ¬∑ apply h.subset; exact @Ideal.IsMaximal.isPrime _ _
      -- ‚ä¢ {I | IsMaximal I} ‚äÜ {I | IsPrime I}
                      -- üéâ no goals
    ¬∑ exact isUnit_of_mul_eq_one _ _ (FractionalIdeal.coe_ideal_mul_inv I hI)‚ü©
      -- üéâ no goals
#align is_principal_ideal_ring.of_finite_primes IsPrincipalIdealRing.of_finite_primes

variable [IsDomain R] [IsDedekindDomain R]

variable (S : Type*) [CommRing S] [IsDomain S]

variable [Algebra R S] [Module.Free R S] [Module.Finite R S]

variable (p : Ideal R) (hp0 : p ‚â† ‚ä•) [IsPrime p]

variable {S‚Çö : Type*} [CommRing S‚Çö] [Algebra S S‚Çö]

variable [IsLocalization (Algebra.algebraMapSubmonoid S p.primeCompl) S‚Çö]

variable [Algebra R S‚Çö] [IsScalarTower R S S‚Çö]

/- The first hypothesis below follows from properties of the localization but is needed for the
second, so we leave it to the user to provide (automatically). -/
variable [IsDomain S‚Çö] [IsDedekindDomain S‚Çö]

/-- If `p` is a prime in the Dedekind domain `R`, `S` an extension of `R` and `S‚Çö` the localization
of `S` at `p`, then all primes in `S‚Çö` are factors of the image of `p` in `S‚Çö`. -/
theorem IsLocalization.OverPrime.mem_normalizedFactors_of_isPrime [DecidableEq (Ideal S‚Çö)]
    {P : Ideal S‚Çö} (hP : IsPrime P) (hP0 : P ‚â† ‚ä•) :
    P ‚àà normalizedFactors (Ideal.map (algebraMap R S‚Çö) p) := by
  have non_zero_div : Algebra.algebraMapSubmonoid S p.primeCompl ‚â§ S‚Å∞ :=
    map_le_nonZeroDivisors_of_injective _ (NoZeroSMulDivisors.algebraMap_injective _ _)
      p.primeCompl_le_nonZeroDivisors
  letI : Algebra (Localization.AtPrime p) S‚Çö := localizationAlgebra p.primeCompl S
  -- ‚ä¢ P ‚àà normalizedFactors (Ideal.map (algebraMap R S‚Çö) p)
  haveI : IsScalarTower R (Localization.AtPrime p) S‚Çö :=
    IsScalarTower.of_algebraMap_eq fun x => by
      -- Porting note: replaced `erw` with a `rw` followed by `exact` to help infer implicits
      rw [IsScalarTower.algebraMap_apply R S]
      exact (IsLocalization.map_eq (T := Algebra.algebraMapSubmonoid S (primeCompl p))
        (Submonoid.le_comap_map _) x).symm
  obtain ‚ü®pid, p', ‚ü®hp'0, hp'p‚ü©, hpu‚ü© :=
    (DiscreteValuationRing.iff_pid_with_one_nonzero_prime (Localization.AtPrime p)).mp
      (IsLocalization.AtPrime.discreteValuationRing_of_dedekind_domain R hp0 _)
  have : LocalRing.maximalIdeal (Localization.AtPrime p) ‚â† ‚ä• := by
    rw [Submodule.ne_bot_iff] at hp0 ‚ä¢
    obtain ‚ü®x, x_mem, x_ne‚ü© := hp0
    exact
      ‚ü®algebraMap _ _ x, (IsLocalization.AtPrime.to_map_mem_maximal_iff _ _ _).mpr x_mem,
        IsLocalization.to_map_ne_zero_of_mem_nonZeroDivisors _ p.primeCompl_le_nonZeroDivisors
          (mem_nonZeroDivisors_of_ne_zero x_ne)‚ü©
  rw [‚Üê Multiset.singleton_le, ‚Üê normalize_eq P, ‚Üê
    normalizedFactors_irreducible (Ideal.prime_of_isPrime hP0 hP).irreducible, ‚Üê
    dvd_iff_normalizedFactors_le_normalizedFactors hP0, dvd_iff_le,
    IsScalarTower.algebraMap_eq R (Localization.AtPrime p) S‚Çö, ‚Üê Ideal.map_map,
    Localization.AtPrime.map_eq_maximalIdeal, Ideal.map_le_iff_le_comap,
    hpu (LocalRing.maximalIdeal _) ‚ü®this, _‚ü©, hpu (comap _ _) ‚ü®_, _‚ü©]
  ¬∑ have hRS : Algebra.IsIntegral R S :=
      isIntegral_of_noetherian (isNoetherian_of_isNoetherianRing_of_finite R S)
    exact mt (Ideal.eq_bot_of_comap_eq_bot (isIntegral_localization hRS)) hP0
    -- üéâ no goals
  ¬∑ exact Ideal.comap_isPrime (algebraMap (Localization.AtPrime p) S‚Çö) P
    -- üéâ no goals
  ¬∑ exact (LocalRing.maximalIdeal.isMaximal _).isPrime
    -- üéâ no goals
  ¬∑ rw [Ne.def, zero_eq_bot, Ideal.map_eq_bot_iff_of_injective]
    -- ‚ä¢ ¬¨p = ‚ä•
    ¬∑ assumption
      -- üéâ no goals
    rw [IsScalarTower.algebraMap_eq R S S‚Çö]
    -- ‚ä¢ Function.Injective ‚Üë(RingHom.comp (algebraMap S S‚Çö) (algebraMap R S))
    exact
      (IsLocalization.injective S‚Çö non_zero_div).comp (NoZeroSMulDivisors.algebraMap_injective _ _)
#align is_localization.over_prime.mem_normalized_factors_of_is_prime IsLocalization.OverPrime.mem_normalizedFactors_of_isPrime

/-- Let `p` be a prime in the Dedekind domain `R` and `S` be an integral extension of `R`,
then the localization `S‚Çö` of `S` at `p` is a PID. -/
theorem IsDedekindDomain.isPrincipalIdealRing_localization_over_prime :
    IsPrincipalIdealRing S‚Çö := by
  letI := Classical.decEq (Ideal S‚Çö)
  -- ‚ä¢ IsPrincipalIdealRing S‚Çö
  letI := Classical.decPred fun P : Ideal S‚Çö => P.IsPrime
  -- ‚ä¢ IsPrincipalIdealRing S‚Çö
  refine'
    IsPrincipalIdealRing.of_finite_primes
      (Set.Finite.ofFinset
        (Finset.filter (fun P => P.IsPrime)
          ({‚ä•} ‚à™ (normalizedFactors (Ideal.map (algebraMap R S‚Çö) p)).toFinset))
        fun P => _)
  rw [Finset.mem_filter, Finset.mem_union, Finset.mem_singleton, Set.mem_setOf,
    Multiset.mem_toFinset]
  exact
    and_iff_right_of_imp fun hP =>
      or_iff_not_imp_left.mpr (IsLocalization.OverPrime.mem_normalizedFactors_of_isPrime S p hp0 hP)
#align is_dedekind_domain.is_principal_ideal_ring_localization_over_prime IsDedekindDomain.isPrincipalIdealRing_localization_over_prime
