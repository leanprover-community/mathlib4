/-
Copyright (c) 2022 David Kurniadi Angdinata. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Kurniadi Angdinata
-/
import Mathlib.Algebra.Hom.Equiv.TypeTags
import Mathlib.Data.ZMod.Quotient
import Mathlib.RingTheory.DedekindDomain.AdicValuation
import Mathlib.RingTheory.Norm

#align_import ring_theory.dedekind_domain.selmer_group from "leanprover-community/mathlib"@"2032a878972d5672e7c27c957e7a6e297b044973"

/-!
# Selmer groups of fraction fields of Dedekind domains

Let $K$ be the field of fractions of a Dedekind domain $R$. For any set $S$ of prime ideals in the
height one spectrum of $R$, and for any natural number $n$, the Selmer group $K(S, n)$ is defined to
be the subgroup of the unit group $K^\times$ modulo $n$-th powers where each element has $v$-adic
valuation divisible by $n$ for all prime ideals $v$ away from $S$. In other words, this is precisely
$$ K(S, n) := \{x(K^\times)^n \in K^\times / (K^\times)^n \ \mid \
                \forall v \notin S, \ \mathrm{ord}_v(x) \equiv 0 \pmod n\}. $$

There is a fundamental short exact sequence
$$ 1 \to R_S^\times / (R_S^\times)^n \to K(S, n) \to \mathrm{Cl}_S(R)[n] \to 0, $$
where $R_S^\times$ is the $S$-unit group of $R$ and $\mathrm{Cl}_S(R)$ is the $S$-class group of
$R$. If the flanking groups are both finite, then $K(S, n)$ is finite by the first isomorphism
theorem. Such is the case when $R$ is the ring of integers of a number field $K$, $S$ is finite, and
$n$ is positive, in which case $R_S^\times$ is finitely generated by Dirichlet's unit theorem and
$\mathrm{Cl}_S(R)$ is finite by the class number theorem.

This file defines the Selmer group $K(S, n)$ and some basic facts.

## Main definitions

 * `IsDedekindDomain.selmerGroup`: the Selmer group.
 * TODO: maps in the sequence.

## Main statements

 * TODO: proofs of exactness of the sequence.
 * TODO: proofs of finiteness for global fields.

## Notations

 * `K‚üÆS, n‚üØ`: the Selmer group with parameters `K`, `S`, and `n`.

## Implementation notes

The Selmer group is typically defined as a subgroup of the Galois cohomology group $H^1(K, \mu_n)$
with certain local conditions defined by $v$-adic valuations, where $\mu_n$ is the group of $n$-th
roots of unity over a separable closure of $K$. Here $H^1(K, \mu_n)$ is identified with
$K^\times / (K^\times)^n$ by the long exact sequence from Kummer theory and Hilbert's theorem 90,
and the fundamental short exact sequence becomes an easy consequence of the snake lemma. This file
will define all the maps explicitly for computational purposes, but isomorphisms to the Galois
cohomological definition will be provided when possible.

## References

https://doc.sagemath.org/html/en/reference/number_fields/sage/rings/number_field/selmer_group.html

## Tags

class group, selmer group, unit group
-/

set_option quotPrecheck false
local notation K "/" n => KÀ£ ‚ß∏ (powMonoidHom n : KÀ£ ‚Üí* KÀ£).range

namespace IsDedekindDomain

noncomputable section

open scoped Classical DiscreteValuation nonZeroDivisors

universe u v

variable {R : Type u} [CommRing R] [IsDomain R] [IsDedekindDomain R] {K : Type v} [Field K]
  [Algebra R K] [IsFractionRing R K] (v : HeightOneSpectrum R)

/-! ### Valuations of non-zero elements -/


namespace HeightOneSpectrum

/-- The multiplicative `v`-adic valuation on `KÀ£`. -/
def valuationOfNeZeroToFun (x : KÀ£) : Multiplicative ‚Ñ§ :=
  let hx := IsLocalization.sec R‚Å∞ (x : K)
  Multiplicative.ofAdd <|
    (-(Associates.mk v.asIdeal).count (Associates.mk <| Ideal.span {hx.fst}).factors : ‚Ñ§) -
      (-(Associates.mk v.asIdeal).count (Associates.mk <| Ideal.span {(hx.snd : R)}).factors : ‚Ñ§)
#align is_dedekind_domain.height_one_spectrum.valuation_of_ne_zero_to_fun IsDedekindDomain.HeightOneSpectrum.valuationOfNeZeroToFun

@[simp]
theorem valuationOfNeZeroToFun_eq (x : KÀ£) :
    (v.valuationOfNeZeroToFun x : ‚Ñ§‚Çò‚ÇÄ) = v.valuation (x : K) := by
  rw [show v.valuation (x : K) = _ * _ by rfl]
  -- ‚ä¢ ‚Üë(valuationOfNeZeroToFun v x) = ‚Üë‚Üë(intValuation v).toMonoidWithZeroHom (Subm ‚Ä¶
  rw [Units.val_inv_eq_inv_val]
  -- ‚ä¢ ‚Üë(valuationOfNeZeroToFun v x) = ‚Üë‚Üë(intValuation v).toMonoidWithZeroHom (Subm ‚Ä¶
  change _ = ite _ _ _ * (ite _ _ _)‚Åª¬π
  -- ‚ä¢ ‚Üë(valuationOfNeZeroToFun v x) = (if (Submonoid.LocalizationMap.sec (IsLocali ‚Ä¶
  rw [IsLocalization.toLocalizationMap_sec]
  -- ‚ä¢ ‚Üë(valuationOfNeZeroToFun v x) = (if (IsLocalization.sec R‚Å∞ ‚Üëx).fst = 0 then  ‚Ä¶
  rw [if_neg <| IsLocalization.sec_fst_ne_zero le_rfl x.ne_zero, if_neg ?_]
  -- ‚ä¢ ‚Üë(valuationOfNeZeroToFun v x) = ‚Üë(‚ÜëMultiplicative.ofAdd (-‚Üë(Associates.count ‚Ä¶
  rfl
  -- ‚ä¢ ¬¨‚Üë(SubmonoidClass.subtype R‚Å∞) (IsLocalization.sec R‚Å∞ ‚Üëx).snd = 0
  exact nonZeroDivisors.coe_ne_zero _
  -- üéâ no goals
#align is_dedekind_domain.height_one_spectrum.valuation_of_ne_zero_to_fun_eq IsDedekindDomain.HeightOneSpectrum.valuationOfNeZeroToFun_eq

/-- The multiplicative `v`-adic valuation on `KÀ£`. -/
def valuationOfNeZero : KÀ£ ‚Üí* Multiplicative ‚Ñ§ where
  toFun := v.valuationOfNeZeroToFun
  map_one' := by rw [‚Üê WithZero.coe_inj, valuationOfNeZeroToFun_eq]; exact map_one _
                 -- ‚ä¢ ‚Üë(valuation v) ‚Üë1 = ‚Üë1
                                                                     -- üéâ no goals
  map_mul' _ _ := by
    rw [‚Üê WithZero.coe_inj, WithZero.coe_mul]
    -- ‚ä¢ ‚Üë(OneHom.toFun { toFun := valuationOfNeZeroToFun v, map_one' := (_ : valuati ‚Ä¶
    simp only [valuationOfNeZeroToFun_eq]; exact map_mul _ _ _
    -- ‚ä¢ ‚Üë(valuation v) ‚Üë(x‚úù¬π * x‚úù) = ‚Üë(valuation v) ‚Üëx‚úù¬π * ‚Üë(valuation v) ‚Üëx‚úù
                                           -- üéâ no goals
#align is_dedekind_domain.height_one_spectrum.valuation_of_ne_zero IsDedekindDomain.HeightOneSpectrum.valuationOfNeZero

@[simp]
theorem valuationOfNeZero_eq (x : KÀ£) : (v.valuationOfNeZero x : ‚Ñ§‚Çò‚ÇÄ) = v.valuation (x : K) :=
  valuationOfNeZeroToFun_eq v x
#align is_dedekind_domain.height_one_spectrum.valuation_of_ne_zero_eq IsDedekindDomain.HeightOneSpectrum.valuationOfNeZero_eq

@[simp]
theorem valuation_of_unit_eq (x : RÀ£) :
    v.valuationOfNeZero (Units.map (algebraMap R K : R ‚Üí* K) x) = 1 := by
  rw [‚Üê WithZero.coe_inj, valuationOfNeZero_eq, Units.coe_map, eq_iff_le_not_lt]
  -- ‚ä¢ ‚Üë(valuation v) (‚Üë‚Üë(algebraMap R K) ‚Üëx) ‚â§ ‚Üë1 ‚àß ¬¨‚Üë(valuation v) (‚Üë‚Üë(algebraMap ‚Ä¶
  constructor
  -- ‚ä¢ ‚Üë(valuation v) (‚Üë‚Üë(algebraMap R K) ‚Üëx) ‚â§ ‚Üë1
  ¬∑ exact v.valuation_le_one x
    -- üéâ no goals
  ¬∑ cases' x with x _ hx _
    -- ‚ä¢ ¬¨‚Üë(valuation v) (‚Üë‚Üë(algebraMap R K) ‚Üë{ val := x, inv := inv‚úù, val_inv := hx, ‚Ä¶
    change ¬¨v.valuation (algebraMap R K x) < 1
    -- ‚ä¢ ¬¨‚Üë(valuation v) (‚Üë(algebraMap R K) x) < 1
    apply_fun v.intValuation at hx
    -- ‚ä¢ ¬¨‚Üë(valuation v) (‚Üë(algebraMap R K) x) < 1
    rw [map_one, map_mul] at hx
    -- ‚ä¢ ¬¨‚Üë(valuation v) (‚Üë(algebraMap R K) x) < 1
    rw [not_lt, ‚Üê hx, ‚Üê mul_one <| v.valuation _, valuation_of_algebraMap,
      mul_le_mul_left‚ÇÄ <| left_ne_zero_of_mul_eq_one hx]
    exact v.int_valuation_le_one _
    -- üéâ no goals
#align is_dedekind_domain.height_one_spectrum.valuation_of_unit_eq IsDedekindDomain.HeightOneSpectrum.valuation_of_unit_eq

-- Porting note: invalid attribute 'semireducible', declaration is in an imported module
-- attribute [local semireducible] MulOpposite

/-- The multiplicative `v`-adic valuation on `KÀ£` modulo `n`-th powers. -/
def valuationOfNeZeroMod (n : ‚Ñï) : (K/n) ‚Üí* Multiplicative (ZMod n) :=
  (Int.quotientZmultiplesNatEquivZMod n).toMultiplicative.toMonoidHom.comp <|
    QuotientGroup.map (powMonoidHom n : KÀ£ ‚Üí* KÀ£).range
      (AddSubgroup.toSubgroup (AddSubgroup.zmultiples (n : ‚Ñ§)))
      v.valuationOfNeZero
      (by
        rintro _ ‚ü®x, rfl‚ü©
        -- ‚ä¢ ‚Üë(powMonoidHom n) x ‚àà Subgroup.comap (valuationOfNeZero v) (‚ÜëAddSubgroup.toS ‚Ä¶
        exact
          ‚ü®v.valuationOfNeZero x, by simp only [powMonoidHom_apply, map_pow, Int.toAdd_pow]; rfl‚ü©)
#align is_dedekind_domain.height_one_spectrum.valuation_of_ne_zero_mod IsDedekindDomain.HeightOneSpectrum.valuationOfNeZeroMod

@[simp]
theorem valuation_of_unit_mod_eq (n : ‚Ñï) (x : RÀ£) :
    v.valuationOfNeZeroMod n (Units.map (algebraMap R K : R ‚Üí* K) x : K/n) = 1 := by
  rw [valuationOfNeZeroMod, MonoidHom.comp_apply, ‚Üê QuotientGroup.coe_mk',
    QuotientGroup.map_mk' (G := KÀ£) (N := MonoidHom.range (powMonoidHom n)),
    valuation_of_unit_eq, QuotientGroup.mk_one, map_one]
#align is_dedekind_domain.height_one_spectrum.valuation_of_unit_mod_eq IsDedekindDomain.HeightOneSpectrum.valuation_of_unit_mod_eq

end HeightOneSpectrum

/-! ### Selmer groups -/


variable {S S' : Set <| HeightOneSpectrum R} {n : ‚Ñï}

/-- The Selmer group `K‚üÆS, n‚üØ`. -/
def selmerGroup : Subgroup <| K/n where
  carrier := {x : K/n | ‚àÄ (v) (_ : v ‚àâ S), (v : HeightOneSpectrum R).valuationOfNeZeroMod n x = 1}
  one_mem' _ _ := by rw [map_one]
                     -- üéâ no goals
                            -- üéâ no goals
  mul_mem' hx hy v hv := by rw [map_mul, hx v hv, hy v hv, one_mul]
  inv_mem' hx v hv := by rw [map_inv, hx v hv, inv_one]
                         -- üéâ no goals
#align is_dedekind_domain.selmer_group IsDedekindDomain.selmerGroup

-- Porting note: was `scoped[SelmerGroup]` but that does not work even using `open SelmerGroup`
local notation K "‚üÆ" S "," n "‚üØ" => @selmerGroup _ _ _ _ K _ _ _ S n

namespace selmerGroup

theorem monotone (hS : S ‚â§ S') : K‚üÆS,n‚üØ ‚â§ K‚üÆS',n‚üØ := fun _ hx v => hx v ‚àò mt (@hS v)
#align is_dedekind_domain.selmer_group.monotone IsDedekindDomain.selmerGroup.monotone

/-- The multiplicative `v`-adic valuations on `K‚üÆS, n‚üØ` for all `v ‚àà S`. -/
def valuation : K‚üÆS,n‚üØ ‚Üí* S ‚Üí Multiplicative (ZMod n) where
  toFun x v := (v : HeightOneSpectrum R).valuationOfNeZeroMod n (x : K/n)
  map_one' := funext fun v => map_one _
  map_mul' x y := by simp only [Submonoid.coe_mul, Subgroup.coe_toSubmonoid, map_mul]; rfl
                     -- ‚ä¢ (fun v => ‚Üë(HeightOneSpectrum.valuationOfNeZeroMod (‚Üëv) n) ‚Üëx * ‚Üë(HeightOneS ‚Ä¶
                                                                                       -- üéâ no goals
#align is_dedekind_domain.selmer_group.valuation IsDedekindDomain.selmerGroup.valuation

theorem valuation_ker_eq :
    valuation.ker = K‚üÆ(‚àÖ : Set <| HeightOneSpectrum R),n‚üØ.subgroupOf (K‚üÆS,n‚üØ) := by
  ext ‚ü®_, hx‚ü©
  -- ‚ä¢ { val := val‚úù, property := hx } ‚àà MonoidHom.ker valuation ‚Üî { val := val‚úù, p ‚Ä¶
  constructor
  -- ‚ä¢ { val := val‚úù, property := hx } ‚àà MonoidHom.ker valuation ‚Üí { val := val‚úù, p ‚Ä¶
  ¬∑ intro hx' v _
    -- ‚ä¢ ‚Üë(HeightOneSpectrum.valuationOfNeZeroMod v n) (‚Üë(Subgroup.subtype selmerGrou ‚Ä¶
    by_cases hv : v ‚àà S
    -- ‚ä¢ ‚Üë(HeightOneSpectrum.valuationOfNeZeroMod v n) (‚Üë(Subgroup.subtype selmerGrou ‚Ä¶
    ¬∑ exact congr_fun hx' ‚ü®v, hv‚ü©
      -- üéâ no goals
    ¬∑ exact hx v hv
      -- üéâ no goals
  ¬∑ exact fun hx' => funext fun v => hx' v <| Set.not_mem_empty v
    -- üéâ no goals
#align is_dedekind_domain.selmer_group.valuation_ker_eq IsDedekindDomain.selmerGroup.valuation_ker_eq

/-- The natural homomorphism from `RÀ£` to `K‚üÆ‚àÖ, n‚üØ`. -/
def fromUnit {n : ‚Ñï} : RÀ£ ‚Üí* K‚üÆ(‚àÖ : Set <| HeightOneSpectrum R),n‚üØ where
  toFun x :=
    ‚ü®QuotientGroup.mk <| Units.map (algebraMap R K).toMonoidHom x, fun v _ =>
      v.valuation_of_unit_mod_eq n x‚ü©
  map_one' := by simp only [map_one, QuotientGroup.mk_one, Subgroup.mk_eq_one_iff]
                 -- üéâ no goals
  map_mul' _ _ := by simp only [RingHom.toMonoidHom_eq_coe, map_mul, MonoidHom.mem_range,
    powMonoidHom_apply, QuotientGroup.mk_mul, Submonoid.mk_mul_mk]
#align is_dedekind_domain.selmer_group.from_unit IsDedekindDomain.selmerGroup.fromUnit

theorem fromUnit_ker [hn : Fact <| 0 < n] :
    (@fromUnit R _ _ _ K _ _ _ n).ker = (powMonoidHom n : RÀ£ ‚Üí* RÀ£).range := by
  ext ‚ü®_, _, _, _‚ü©
  -- ‚ä¢ { val := val‚úù, inv := inv‚úù, val_inv := val_inv‚úù, inv_val := inv_val‚úù } ‚àà Mon ‚Ä¶
  constructor
  -- ‚ä¢ { val := val‚úù, inv := inv‚úù, val_inv := val_inv‚úù, inv_val := inv_val‚úù } ‚àà Mon ‚Ä¶
  ¬∑ intro hx
    -- ‚ä¢ { val := val‚úù, inv := inv‚úù, val_inv := val_inv‚úù, inv_val := inv_val‚úù } ‚àà Mon ‚Ä¶
    rcases(QuotientGroup.eq_one_iff _).mp (Subtype.mk.inj hx) with ‚ü®‚ü®v, i, vi, iv‚ü©, hx‚ü©
    -- ‚ä¢ { val := val‚úù, inv := inv‚úù, val_inv := val_inv‚úù, inv_val := inv_val‚úù } ‚àà Mon ‚Ä¶
    have hv : ‚Üë(_ ^ n : KÀ£) = algebraMap R K _ := by exact congr_arg Units.val hx
    -- ‚ä¢ { val := val‚úù, inv := inv‚úù, val_inv := val_inv‚úù, inv_val := inv_val‚úù } ‚àà Mon ‚Ä¶
    have hi : ‚Üë(_ ^ n : KÀ£)‚Åª¬π = algebraMap R K _ := by exact congr_arg Units.inv hx
    -- ‚ä¢ { val := val‚úù, inv := inv‚úù, val_inv := val_inv‚úù, inv_val := inv_val‚úù } ‚àà Mon ‚Ä¶
    rw [Units.val_pow_eq_pow_val] at hv
    -- ‚ä¢ { val := val‚úù, inv := inv‚úù, val_inv := val_inv‚úù, inv_val := inv_val‚úù } ‚àà Mon ‚Ä¶
    rw [‚Üê inv_pow, Units.inv_mk, Units.val_pow_eq_pow_val] at hi
    -- ‚ä¢ { val := val‚úù, inv := inv‚úù, val_inv := val_inv‚úù, inv_val := inv_val‚úù } ‚àà Mon ‚Ä¶
    rcases IsIntegrallyClosed.exists_algebraMap_eq_of_isIntegral_pow (R := R) (x := v) hn.out
        (hv.symm ‚ñ∏ isIntegral_algebraMap) with
      ‚ü®v', rfl‚ü©
    rcases IsIntegrallyClosed.exists_algebraMap_eq_of_isIntegral_pow (R := R) (x := i) hn.out
        (hi.symm ‚ñ∏ isIntegral_algebraMap) with
      ‚ü®i', rfl‚ü©
    rw [‚Üê map_mul, map_eq_one_iff _ <| NoZeroSMulDivisors.algebraMap_injective R K] at vi
    -- ‚ä¢ { val := val‚úù, inv := inv‚úù, val_inv := val_inv‚úù, inv_val := inv_val‚úù } ‚àà Mon ‚Ä¶
    rw [‚Üê map_mul, map_eq_one_iff _ <| NoZeroSMulDivisors.algebraMap_injective R K] at iv
    -- ‚ä¢ { val := val‚úù, inv := inv‚úù, val_inv := val_inv‚úù, inv_val := inv_val‚úù } ‚àà Mon ‚Ä¶
    rw [Units.val_mk, ‚Üê map_pow] at hv
    -- ‚ä¢ { val := val‚úù, inv := inv‚úù, val_inv := val_inv‚úù, inv_val := inv_val‚úù } ‚àà Mon ‚Ä¶
    exact ‚ü®‚ü®v', i', vi, iv‚ü©, by
      simpa only [Units.ext_iff, powMonoidHom_apply, Units.val_pow_eq_pow_val] using
         NoZeroSMulDivisors.algebraMap_injective R K hv‚ü©
  ¬∑ rintro ‚ü®x, hx‚ü©
    -- ‚ä¢ { val := val‚úù, inv := inv‚úù, val_inv := val_inv‚úù, inv_val := inv_val‚úù } ‚àà Mon ‚Ä¶
    rw [‚Üê hx]
    -- ‚ä¢ ‚Üë(powMonoidHom n) x ‚àà MonoidHom.ker fromUnit
    exact Subtype.mk_eq_mk.mpr <| (QuotientGroup.eq_one_iff _).mpr ‚ü®Units.map (algebraMap R K) x,
      by simp only [powMonoidHom_apply, RingHom.toMonoidHom_eq_coe, map_pow]‚ü©
#align is_dedekind_domain.selmer_group.from_unit_ker IsDedekindDomain.selmerGroup.fromUnit_ker

/-- The injection induced by the natural homomorphism from `RÀ£` to `K‚üÆ‚àÖ, n‚üØ`. -/
def fromUnitLift [Fact <| 0 < n] : (R/n) ‚Üí* K‚üÆ(‚àÖ : Set <| HeightOneSpectrum R),n‚üØ :=
  (QuotientGroup.kerLift _).comp
    (QuotientGroup.quotientMulEquivOfEq (fromUnit_ker (R := R))).symm.toMonoidHom
#align is_dedekind_domain.selmer_group.from_unit_lift IsDedekindDomain.selmerGroup.fromUnitLift

theorem fromUnitLift_injective [Fact <| 0 < n] :
    Function.Injective <| @fromUnitLift R _ _ _ K _ _ _ n _ := by
  dsimp only [fromUnitLift, MonoidHom.coe_comp, MulEquiv.coe_toMonoidHom]
  -- ‚ä¢ Function.Injective (‚Üë(QuotientGroup.kerLift fromUnit) ‚àò ‚Üë(MulEquiv.symm (Quo ‚Ä¶
  exact Function.Injective.comp (QuotientGroup.kerLift_injective _) (MulEquiv.injective _)
  -- üéâ no goals
#align is_dedekind_domain.selmer_group.from_unit_lift_injective IsDedekindDomain.selmerGroup.fromUnitLift_injective

end selmerGroup

end

end IsDedekindDomain
