/-
Copyright (c) 2021 Chris Hughes. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Chris Hughes
-/
import Mathlib.RingTheory.Adjoin.Basic
import Mathlib.LinearAlgebra.LinearIndependent
import Mathlib.RingTheory.MvPolynomial.Basic
import Mathlib.Data.MvPolynomial.Supported
import Mathlib.RingTheory.Algebraic
import Mathlib.Data.MvPolynomial.Equiv

#align_import ring_theory.algebraic_independent from "leanprover-community/mathlib"@"949dc57e616a621462062668c9f39e4e17b64b69"

/-!
# Algebraic Independence

This file defines algebraic independence of a family of element of an `R` algebra.

## Main definitions

* `AlgebraicIndependent` - `AlgebraicIndependent R x` states the family of elements `x`
  is algebraically independent over `R`, meaning that the canonical map out of the multivariable
  polynomial ring is injective.

* `AlgebraicIndependent.repr` - The canonical map from the subalgebra generated by an
  algebraic independent family into the polynomial ring.

## References

* [Stacks: Transcendence](https://stacks.math.columbia.edu/tag/030D)

## TODO
Prove that a ring is an algebraic extension of the subalgebra generated by a transcendence basis.

## Tags
transcendence basis, transcendence degree, transcendence

-/


noncomputable section

open Function Set Subalgebra MvPolynomial Algebra

open Classical BigOperators

universe x u v w

variable {Î¹ : Type*} {Î¹' : Type*} (R : Type*) {K : Type*}

variable {A : Type*} {A' A'' : Type*} {V : Type u} {V' : Type*}

variable (x : Î¹ â†’ A)

variable [CommRing R] [CommRing A] [CommRing A'] [CommRing A'']

variable [Algebra R A] [Algebra R A'] [Algebra R A'']

variable {a b : R}

/-- `AlgebraicIndependent R x` states the family of elements `x`
  is algebraically independent over `R`, meaning that the canonical
  map out of the multivariable polynomial ring is injective. -/
def AlgebraicIndependent : Prop :=
  Injective (MvPolynomial.aeval x : MvPolynomial Î¹ R â†’â‚[R] A)
#align algebraic_independent AlgebraicIndependent

variable {R} {x}

theorem algebraicIndependent_iff_ker_eq_bot :
    AlgebraicIndependent R x â†”
      RingHom.ker (MvPolynomial.aeval x : MvPolynomial Î¹ R â†’â‚[R] A).toRingHom = âŠ¥ :=
  RingHom.injective_iff_ker_eq_bot _
#align algebraic_independent_iff_ker_eq_bot algebraicIndependent_iff_ker_eq_bot

theorem algebraicIndependent_iff :
    AlgebraicIndependent R x â†”
      âˆ€ p : MvPolynomial Î¹ R, MvPolynomial.aeval (x : Î¹ â†’ A) p = 0 â†’ p = 0 :=
  injective_iff_map_eq_zero _
#align algebraic_independent_iff algebraicIndependent_iff

theorem AlgebraicIndependent.eq_zero_of_aeval_eq_zero (h : AlgebraicIndependent R x) :
    âˆ€ p : MvPolynomial Î¹ R, MvPolynomial.aeval (x : Î¹ â†’ A) p = 0 â†’ p = 0 :=
  algebraicIndependent_iff.1 h
#align algebraic_independent.eq_zero_of_aeval_eq_zero AlgebraicIndependent.eq_zero_of_aeval_eq_zero

theorem algebraicIndependent_iff_injective_aeval :
    AlgebraicIndependent R x â†” Injective (MvPolynomial.aeval x : MvPolynomial Î¹ R â†’â‚[R] A) :=
  Iff.rfl
#align algebraic_independent_iff_injective_aeval algebraicIndependent_iff_injective_aeval

@[simp]
theorem algebraicIndependent_empty_type_iff [IsEmpty Î¹] :
    AlgebraicIndependent R x â†” Injective (algebraMap R A) := by
  have : aeval x = (Algebra.ofId R A).comp (@isEmptyAlgEquiv R Î¹ _ _).toAlgHom := by
    ext i
    exact IsEmpty.elim' â€¹IsEmpty Î¹â€º i
  rw [AlgebraicIndependent, this, â† Injective.of_comp_iff' _ (@isEmptyAlgEquiv R Î¹ _ _).bijective]
  -- âŠ¢ Injective â†‘(AlgHom.comp (ofId R A) â†‘(isEmptyAlgEquiv R Î¹)) â†” Injective (â†‘(al â€¦
  rfl
  -- ğŸ‰ no goals
#align algebraic_independent_empty_type_iff algebraicIndependent_empty_type_iff

namespace AlgebraicIndependent

variable (hx : AlgebraicIndependent R x)

theorem algebraMap_injective : Injective (algebraMap R A) := by
  simpa [â† MvPolynomial.algebraMap_eq, Function.comp] using
    (Injective.of_comp_iff (algebraicIndependent_iff_injective_aeval.1 hx) MvPolynomial.C).2
      (MvPolynomial.C_injective _ _)
#align algebraic_independent.algebra_map_injective AlgebraicIndependent.algebraMap_injective

theorem linearIndependent : LinearIndependent R x := by
  rw [linearIndependent_iff_injective_total]
  -- âŠ¢ Injective â†‘(Finsupp.total Î¹ A R x)
  have : Finsupp.total Î¹ A R x =
      (MvPolynomial.aeval x).toLinearMap.comp (Finsupp.total Î¹ _ R X) := by
    ext
    simp
  rw [this]
  -- âŠ¢ Injective â†‘(LinearMap.comp (AlgHom.toLinearMap (aeval x)) (Finsupp.total Î¹ ( â€¦
  refine' hx.comp _
  -- âŠ¢ Injective fun x => â†‘(Finsupp.total Î¹ (MvPolynomial Î¹ R) R X) x
  rw [â† linearIndependent_iff_injective_total]
  -- âŠ¢ LinearIndependent R X
  exact linearIndependent_X _ _
  -- ğŸ‰ no goals
#align algebraic_independent.linear_independent AlgebraicIndependent.linearIndependent

protected theorem injective [Nontrivial R] : Injective x :=
  hx.linearIndependent.injective
#align algebraic_independent.injective AlgebraicIndependent.injective

theorem ne_zero [Nontrivial R] (i : Î¹) : x i â‰  0 :=
  hx.linearIndependent.ne_zero i
#align algebraic_independent.ne_zero AlgebraicIndependent.ne_zero

theorem comp (f : Î¹' â†’ Î¹) (hf : Function.Injective f) : AlgebraicIndependent R (x âˆ˜ f) := by
  intro p q
  -- âŠ¢ â†‘(aeval (x âˆ˜ f)) p = â†‘(aeval (x âˆ˜ f)) q â†’ p = q
  simpa [aeval_rename, (rename_injective f hf).eq_iff] using @hx (rename f p) (rename f q)
  -- ğŸ‰ no goals
#align algebraic_independent.comp AlgebraicIndependent.comp

theorem coe_range : AlgebraicIndependent R ((â†‘) : range x â†’ A) := by
  simpa using hx.comp _ (rangeSplitting_injective x)
  -- ğŸ‰ no goals
#align algebraic_independent.coe_range AlgebraicIndependent.coe_range

theorem map {f : A â†’â‚[R] A'} (hf_inj : Set.InjOn f (adjoin R (range x))) :
    AlgebraicIndependent R (f âˆ˜ x) := by
  have : aeval (f âˆ˜ x) = f.comp (aeval x) := by ext; simp
  -- âŠ¢ AlgebraicIndependent R (â†‘f âˆ˜ x)
  have h : âˆ€ p : MvPolynomial Î¹ R, aeval x p âˆˆ (@aeval R _ _ _ _ _ ((â†‘) : range x â†’ A)).range := by
    intro p
    rw [AlgHom.mem_range]
    refine' âŸ¨MvPolynomial.rename (codRestrict x (range x) mem_range_self) p, _âŸ©
    simp [Function.comp, aeval_rename]
  intro x y hxy
  -- âŠ¢ x = y
  rw [this] at hxy
  -- âŠ¢ x = y
  rw [adjoin_eq_range] at hf_inj
  -- âŠ¢ x = y
  exact hx (hf_inj (h x) (h y) hxy)
  -- ğŸ‰ no goals
#align algebraic_independent.map AlgebraicIndependent.map

theorem map' {f : A â†’â‚[R] A'} (hf_inj : Injective f) : AlgebraicIndependent R (f âˆ˜ x) :=
  hx.map (injOn_of_injective hf_inj _)
#align algebraic_independent.map' AlgebraicIndependent.map'

theorem of_comp (f : A â†’â‚[R] A') (hfv : AlgebraicIndependent R (f âˆ˜ x)) :
    AlgebraicIndependent R x := by
  have : aeval (f âˆ˜ x) = f.comp (aeval x) := by ext; simp
  -- âŠ¢ AlgebraicIndependent R x
  rw [AlgebraicIndependent, this, AlgHom.coe_comp] at hfv
  -- âŠ¢ AlgebraicIndependent R x
  exact hfv.of_comp
  -- ğŸ‰ no goals
#align algebraic_independent.of_comp AlgebraicIndependent.of_comp

end AlgebraicIndependent

open AlgebraicIndependent

theorem AlgHom.algebraicIndependent_iff (f : A â†’â‚[R] A') (hf : Injective f) :
    AlgebraicIndependent R (f âˆ˜ x) â†” AlgebraicIndependent R x :=
  âŸ¨fun h => h.of_comp f, fun h => h.map (injOn_of_injective hf _)âŸ©
#align alg_hom.algebraic_independent_iff AlgHom.algebraicIndependent_iff

@[nontriviality]
theorem algebraicIndependent_of_subsingleton [Subsingleton R] : AlgebraicIndependent R x :=
  algebraicIndependent_iff.2 fun _ _ => Subsingleton.elim _ _
#align algebraic_independent_of_subsingleton algebraicIndependent_of_subsingleton

theorem algebraicIndependent_equiv (e : Î¹ â‰ƒ Î¹') {f : Î¹' â†’ A} :
    AlgebraicIndependent R (f âˆ˜ e) â†” AlgebraicIndependent R f :=
  âŸ¨fun h => Function.comp.right_id f â–¸ e.self_comp_symm â–¸ h.comp _ e.symm.injective,
    fun h => h.comp _ e.injectiveâŸ©
#align algebraic_independent_equiv algebraicIndependent_equiv

theorem algebraicIndependent_equiv' (e : Î¹ â‰ƒ Î¹') {f : Î¹' â†’ A} {g : Î¹ â†’ A} (h : f âˆ˜ e = g) :
    AlgebraicIndependent R g â†” AlgebraicIndependent R f :=
  h â–¸ algebraicIndependent_equiv e
#align algebraic_independent_equiv' algebraicIndependent_equiv'

theorem algebraicIndependent_subtype_range {Î¹} {f : Î¹ â†’ A} (hf : Injective f) :
    AlgebraicIndependent R ((â†‘) : range f â†’ A) â†” AlgebraicIndependent R f :=
  Iff.symm <| algebraicIndependent_equiv' (Equiv.ofInjective f hf) rfl
#align algebraic_independent_subtype_range algebraicIndependent_subtype_range

alias âŸ¨AlgebraicIndependent.of_subtype_range, _âŸ© := algebraicIndependent_subtype_range
#align algebraic_independent.of_subtype_range AlgebraicIndependent.of_subtype_range

theorem algebraicIndependent_image {Î¹} {s : Set Î¹} {f : Î¹ â†’ A} (hf : Set.InjOn f s) :
    (AlgebraicIndependent R fun x : s => f x) â†” AlgebraicIndependent R fun x : f '' s => (x : A) :=
  algebraicIndependent_equiv' (Equiv.Set.imageOfInjOn _ _ hf) rfl
#align algebraic_independent_image algebraicIndependent_image

theorem algebraicIndependent_adjoin (hs : AlgebraicIndependent R x) :
    @AlgebraicIndependent Î¹ R (adjoin R (range x))
      (fun i : Î¹ => âŸ¨x i, subset_adjoin (mem_range_self i)âŸ©) _ _ _ :=
  AlgebraicIndependent.of_comp (adjoin R (range x)).val hs
#align algebraic_independent_adjoin algebraicIndependent_adjoin

/-- A set of algebraically independent elements in an algebra `A` over a ring `K` is also
algebraically independent over a subring `R` of `K`. -/
theorem AlgebraicIndependent.restrictScalars {K : Type*} [CommRing K] [Algebra R K] [Algebra K A]
    [IsScalarTower R K A] (hinj : Function.Injective (algebraMap R K))
    (ai : AlgebraicIndependent K x) : AlgebraicIndependent R x := by
  have : (aeval x : MvPolynomial Î¹ K â†’â‚[K] A).toRingHom.comp (MvPolynomial.map (algebraMap R K)) =
      (aeval x : MvPolynomial Î¹ R â†’â‚[R] A).toRingHom := by
    ext <;> simp [algebraMap_eq_smul_one]
  show Injective (aeval x).toRingHom
  -- âŠ¢ Injective â†‘â†‘(aeval x)
  rw [â† this, RingHom.coe_comp]
  -- âŠ¢ Injective (â†‘â†‘(aeval x) âˆ˜ â†‘(MvPolynomial.map (algebraMap R K)))
  exact Injective.comp ai (MvPolynomial.map_injective _ hinj)
  -- ğŸ‰ no goals
#align algebraic_independent.restrict_scalars AlgebraicIndependent.restrictScalars

/-- Every finite subset of an algebraically independent set is algebraically independent. -/
theorem algebraicIndependent_finset_map_embedding_subtype (s : Set A)
    (li : AlgebraicIndependent R ((â†‘) : s â†’ A)) (t : Finset s) :
    AlgebraicIndependent R ((â†‘) : Finset.map (Embedding.subtype s) t â†’ A) := by
  let f : t.map (Embedding.subtype s) â†’ s := fun x =>
    âŸ¨x.1, by
      obtain âŸ¨x, hâŸ© := x
      rw [Finset.mem_map] at h
      obtain âŸ¨a, _, rflâŸ© := h
      simp only [Subtype.coe_prop, Embedding.coe_subtype]âŸ©
  convert AlgebraicIndependent.comp li f _
  -- âŠ¢ Injective f
  rintro âŸ¨x, hxâŸ© âŸ¨y, hyâŸ©
  -- âŠ¢ f { val := x, property := hx } = f { val := y, property := hy } â†’ { val := x â€¦
  rw [Finset.mem_map] at hx hy
  -- âŠ¢ f { val := x, property := hxâœ } = f { val := y, property := hyâœ } â†’ { val := â€¦
  obtain âŸ¨a, _, rflâŸ© := hx
  -- âŠ¢ f { val := â†‘(Embedding.subtype s) a, property := hx } = f { val := y, proper â€¦
  obtain âŸ¨b, _, rflâŸ© := hy
  -- âŠ¢ f { val := â†‘(Embedding.subtype s) a, property := hx } = f { val := â†‘(Embeddi â€¦
  simp only [imp_self, Subtype.mk_eq_mk]
  -- ğŸ‰ no goals
#align algebraic_independent_finset_map_embedding_subtype algebraicIndependent_finset_map_embedding_subtype

/-- If every finite set of algebraically independent element has cardinality at most `n`,
then the same is true for arbitrary sets of algebraically independent elements. -/
theorem algebraicIndependent_bounded_of_finset_algebraicIndependent_bounded {n : â„•}
    (H : âˆ€ s : Finset A, (AlgebraicIndependent R fun i : s => (i : A)) â†’ s.card â‰¤ n) :
    âˆ€ s : Set A, AlgebraicIndependent R ((â†‘) : s â†’ A) â†’ Cardinal.mk s â‰¤ n := by
  intro s li
  -- âŠ¢ Cardinal.mk â†‘s â‰¤ â†‘n
  apply Cardinal.card_le_of
  -- âŠ¢ âˆ€ (s_1 : Finset â†‘s), Finset.card s_1 â‰¤ n
  intro t
  -- âŠ¢ Finset.card t â‰¤ n
  rw [â† Finset.card_map (Embedding.subtype s)]
  -- âŠ¢ Finset.card (Finset.map (Embedding.subtype s) t) â‰¤ n
  apply H
  -- âŠ¢ AlgebraicIndependent R fun i => â†‘i
  apply algebraicIndependent_finset_map_embedding_subtype _ li
  -- ğŸ‰ no goals
#align algebraic_independent_bounded_of_finset_algebraic_independent_bounded algebraicIndependent_bounded_of_finset_algebraicIndependent_bounded

section Subtype

theorem AlgebraicIndependent.restrict_of_comp_subtype {s : Set Î¹}
    (hs : AlgebraicIndependent R (x âˆ˜ (â†‘) : s â†’ A)) : AlgebraicIndependent R (s.restrict x) :=
  hs
#align algebraic_independent.restrict_of_comp_subtype AlgebraicIndependent.restrict_of_comp_subtype

variable (R A)

theorem algebraicIndependent_empty_iff :
    AlgebraicIndependent R ((â†‘) : (âˆ… : Set A) â†’ A) â†” Injective (algebraMap R A) := by simp
                                                                                      -- ğŸ‰ no goals
#align algebraic_independent_empty_iff algebraicIndependent_empty_iff

variable {R A}

theorem AlgebraicIndependent.mono {t s : Set A} (h : t âŠ† s)
    (hx : AlgebraicIndependent R ((â†‘) : s â†’ A)) : AlgebraicIndependent R ((â†‘) : t â†’ A) := by
  simpa [Function.comp] using hx.comp (inclusion h) (inclusion_injective h)
  -- ğŸ‰ no goals
#align algebraic_independent.mono AlgebraicIndependent.mono

end Subtype

theorem AlgebraicIndependent.to_subtype_range {Î¹} {f : Î¹ â†’ A} (hf : AlgebraicIndependent R f) :
    AlgebraicIndependent R ((â†‘) : range f â†’ A) := by
  nontriviality R
  -- âŠ¢ AlgebraicIndependent R Subtype.val
  rwa [algebraicIndependent_subtype_range hf.injective]
  -- ğŸ‰ no goals
#align algebraic_independent.to_subtype_range AlgebraicIndependent.to_subtype_range

theorem AlgebraicIndependent.to_subtype_range' {Î¹} {f : Î¹ â†’ A} (hf : AlgebraicIndependent R f) {t}
    (ht : range f = t) : AlgebraicIndependent R ((â†‘) : t â†’ A) :=
  ht â–¸ hf.to_subtype_range
#align algebraic_independent.to_subtype_range' AlgebraicIndependent.to_subtype_range'

theorem algebraicIndependent_comp_subtype {s : Set Î¹} :
    AlgebraicIndependent R (x âˆ˜ (â†‘) : s â†’ A) â†”
      âˆ€ p âˆˆ MvPolynomial.supported R s, aeval x p = 0 â†’ p = 0 := by
  have : (aeval (x âˆ˜ (â†‘) : s â†’ A) : _ â†’â‚[R] _) = (aeval x).comp (rename (â†‘)) := by ext; simp
  -- âŠ¢ AlgebraicIndependent R (x âˆ˜ Subtype.val) â†” âˆ€ (p : MvPolynomial Î¹ R), p âˆˆ sup â€¦
  have : âˆ€ p : MvPolynomial s R, rename ((â†‘) : s â†’ Î¹) p = 0 â†” p = 0 :=
    (injective_iff_map_eq_zero' (rename ((â†‘) : s â†’ Î¹) : MvPolynomial s R â†’â‚[R] _).toRingHom).1
      (rename_injective _ Subtype.val_injective)
  simp [algebraicIndependent_iff, supported_eq_range_rename, *]
  -- ğŸ‰ no goals
#align algebraic_independent_comp_subtype algebraicIndependent_comp_subtype

theorem algebraicIndependent_subtype {s : Set A} :
    AlgebraicIndependent R ((â†‘) : s â†’ A) â†”
      âˆ€ p : MvPolynomial A R, p âˆˆ MvPolynomial.supported R s â†’ aeval id p = 0 â†’ p = 0 := by
  apply @algebraicIndependent_comp_subtype _ _ _ id
  -- ğŸ‰ no goals
#align algebraic_independent_subtype algebraicIndependent_subtype

theorem algebraicIndependent_of_finite (s : Set A)
    (H : âˆ€ (t) (_ : t âŠ† s), t.Finite â†’ AlgebraicIndependent R ((â†‘) : t â†’ A)) :
    AlgebraicIndependent R ((â†‘) : s â†’ A) :=
  algebraicIndependent_subtype.2 fun p hp =>
    algebraicIndependent_subtype.1 (H _ (mem_supported.1 hp) (Finset.finite_toSet _)) _ (by simp)
                                                                                            -- ğŸ‰ no goals
#align algebraic_independent_of_finite algebraicIndependent_of_finite

theorem AlgebraicIndependent.image_of_comp {Î¹ Î¹'} (s : Set Î¹) (f : Î¹ â†’ Î¹') (g : Î¹' â†’ A)
    (hs : AlgebraicIndependent R fun x : s => g (f x)) :
    AlgebraicIndependent R fun x : f '' s => g x := by
  nontriviality R
  -- âŠ¢ AlgebraicIndependent R fun x => g â†‘x
  have : InjOn f s := injOn_iff_injective.2 hs.injective.of_comp
  -- âŠ¢ AlgebraicIndependent R fun x => g â†‘x
  exact (algebraicIndependent_equiv' (Equiv.Set.imageOfInjOn f s this) rfl).1 hs
  -- ğŸ‰ no goals
#align algebraic_independent.image_of_comp AlgebraicIndependent.image_of_comp

theorem AlgebraicIndependent.image {Î¹} {s : Set Î¹} {f : Î¹ â†’ A}
    (hs : AlgebraicIndependent R fun x : s => f x) :
    AlgebraicIndependent R fun x : f '' s => (x : A) := by
  convert AlgebraicIndependent.image_of_comp s f id hs
  -- ğŸ‰ no goals
#align algebraic_independent.image AlgebraicIndependent.image

theorem algebraicIndependent_iUnion_of_directed {Î· : Type*} [Nonempty Î·] {s : Î· â†’ Set A}
    (hs : Directed (Â· âŠ† Â·) s) (h : âˆ€ i, AlgebraicIndependent R ((â†‘) : s i â†’ A)) :
    AlgebraicIndependent R ((â†‘) : (â‹ƒ i, s i) â†’ A) := by
  refine' algebraicIndependent_of_finite (â‹ƒ i, s i) fun t ht ft => _
  -- âŠ¢ AlgebraicIndependent R Subtype.val
  rcases finite_subset_iUnion ft ht with âŸ¨I, fi, hIâŸ©
  -- âŠ¢ AlgebraicIndependent R Subtype.val
  rcases hs.finset_le fi.toFinset with âŸ¨i, hiâŸ©
  -- âŠ¢ AlgebraicIndependent R Subtype.val
  exact (h i).mono (Subset.trans hI <| iUnionâ‚‚_subset fun j hj => hi j (fi.mem_toFinset.2 hj))
  -- ğŸ‰ no goals
#align algebraic_independent_Union_of_directed algebraicIndependent_iUnion_of_directed

theorem algebraicIndependent_sUnion_of_directed {s : Set (Set A)} (hsn : s.Nonempty)
    (hs : DirectedOn (Â· âŠ† Â·) s) (h : âˆ€ a âˆˆ s, AlgebraicIndependent R ((â†‘) : a â†’ A)) :
    AlgebraicIndependent R ((â†‘) : â‹ƒâ‚€ s â†’ A) := by
  letI : Nonempty s := Nonempty.to_subtype hsn
  -- âŠ¢ AlgebraicIndependent R Subtype.val
  rw [sUnion_eq_iUnion]
  -- âŠ¢ AlgebraicIndependent R Subtype.val
  exact algebraicIndependent_iUnion_of_directed hs.directed_val (by simpa using h)
  -- ğŸ‰ no goals
#align algebraic_independent_sUnion_of_directed algebraicIndependent_sUnion_of_directed

theorem exists_maximal_algebraicIndependent (s t : Set A) (hst : s âŠ† t)
    (hs : AlgebraicIndependent R ((â†‘) : s â†’ A)) :
    âˆƒ u : Set A, AlgebraicIndependent R ((â†‘) : u â†’ A) âˆ§ s âŠ† u âˆ§ u âŠ† t âˆ§
      âˆ€ x : Set A, AlgebraicIndependent R ((â†‘) : x â†’ A) â†’ u âŠ† x â†’ x âŠ† t â†’ x = u := by
  rcases zorn_subset_nonempty { u : Set A | AlgebraicIndependent R ((â†‘) : u â†’ A) âˆ§ s âŠ† u âˆ§ u âŠ† t }
      (fun c hc chainc hcn =>
        âŸ¨â‹ƒâ‚€ c, by
          refine' âŸ¨âŸ¨algebraicIndependent_sUnion_of_directed hcn chainc.directedOn
              fun a ha => (hc ha).1, _, _âŸ©, _âŸ©
          Â· cases' hcn with x hx
            exact subset_sUnion_of_subset _ x (hc hx).2.1 hx
          Â· exact sUnion_subset fun x hx => (hc hx).2.2
          Â· intro s
            exact subset_sUnion_of_memâŸ©)
      s âŸ¨hs, Set.Subset.refl s, hstâŸ© with
    âŸ¨u, âŸ¨huai, _, hutâŸ©, hsu, hxâŸ©
  use u, huai, hsu, hut
  -- âŠ¢ âˆ€ (x : Set A), AlgebraicIndependent R Subtype.val â†’ u âŠ† x â†’ x âŠ† t â†’ x = u
  intro x hxai huv hxt
  -- âŠ¢ x = u
  exact hx _ âŸ¨hxai, _root_.trans hsu huv, hxtâŸ© huv
  -- ğŸ‰ no goals
#align exists_maximal_algebraic_independent exists_maximal_algebraicIndependent

section repr

variable (hx : AlgebraicIndependent R x)

/-- Canonical isomorphism between polynomials and the subalgebra generated by
  algebraically independent elements. -/
@[simps!]
def AlgebraicIndependent.aevalEquiv (hx : AlgebraicIndependent R x) :
    MvPolynomial Î¹ R â‰ƒâ‚[R] Algebra.adjoin R (range x) := by
  apply
    AlgEquiv.ofBijective (AlgHom.codRestrict (@aeval R A Î¹ _ _ _ x) (Algebra.adjoin R (range x)) _)
  swap
  -- âŠ¢ âˆ€ (x_1 : MvPolynomial Î¹ R), â†‘(aeval x) x_1 âˆˆ adjoin R (range x)
  Â· intro x
    -- âŠ¢ â†‘(aeval xâœ) x âˆˆ adjoin R (range xâœ)
    rw [adjoin_range_eq_range_aeval]
    -- âŠ¢ â†‘(aeval xâœ) x âˆˆ AlgHom.range (aeval xâœ)
    exact AlgHom.mem_range_self _ _
    -- ğŸ‰ no goals
  Â· constructor
    -- âŠ¢ Injective â†‘(AlgHom.codRestrict (aeval x) (adjoin R (range x)) (_ : âˆ€ (x_1 :  â€¦
    Â· exact (AlgHom.injective_codRestrict _ _ _).2 hx
      -- ğŸ‰ no goals
    Â· rintro âŸ¨x, hxâŸ©
      -- âŠ¢ âˆƒ a, â†‘(AlgHom.codRestrict (aeval xâœ) (adjoin R (range xâœ)) (_ : âˆ€ (x : MvPol â€¦
      rw [adjoin_range_eq_range_aeval] at hx
      -- âŠ¢ âˆƒ a, â†‘(AlgHom.codRestrict (aeval xâœ) (adjoin R (range xâœ)) (_ : âˆ€ (x : MvPol â€¦
      rcases hx with âŸ¨y, rflâŸ©
      -- âŠ¢ âˆƒ a, â†‘(AlgHom.codRestrict (aeval x) (adjoin R (range x)) (_ : âˆ€ (x_1 : MvPol â€¦
      use y
      -- âŠ¢ â†‘(AlgHom.codRestrict (aeval x) (adjoin R (range x)) (_ : âˆ€ (x_1 : MvPolynomi â€¦
      ext
      -- âŠ¢ â†‘(â†‘(AlgHom.codRestrict (aeval x) (adjoin R (range x)) (_ : âˆ€ (x_1 : MvPolyno â€¦
      simp
      -- ğŸ‰ no goals
#align algebraic_independent.aeval_equiv AlgebraicIndependent.aevalEquiv

--@[simp] Porting note: removing simp because the linter complains about deterministic timeout
theorem AlgebraicIndependent.algebraMap_aevalEquiv (hx : AlgebraicIndependent R x)
    (p : MvPolynomial Î¹ R) :
    algebraMap (Algebra.adjoin R (range x)) A (hx.aevalEquiv p) = aeval x p :=
  rfl
#align algebraic_independent.algebra_map_aeval_equiv AlgebraicIndependent.algebraMap_aevalEquiv

/-- The canonical map from the subalgebra generated by an algebraic independent family
  into the polynomial ring. -/
def AlgebraicIndependent.repr (hx : AlgebraicIndependent R x) :
    Algebra.adjoin R (range x) â†’â‚[R] MvPolynomial Î¹ R :=
  hx.aevalEquiv.symm
#align algebraic_independent.repr AlgebraicIndependent.repr

@[simp]
theorem AlgebraicIndependent.aeval_repr (p) : aeval x (hx.repr p) = p :=
  Subtype.ext_iff.1 (AlgEquiv.apply_symm_apply hx.aevalEquiv p)
#align algebraic_independent.aeval_repr AlgebraicIndependent.aeval_repr

theorem AlgebraicIndependent.aeval_comp_repr : (aeval x).comp hx.repr = Subalgebra.val _ :=
  AlgHom.ext <| hx.aeval_repr
#align algebraic_independent.aeval_comp_repr AlgebraicIndependent.aeval_comp_repr

theorem AlgebraicIndependent.repr_ker :
    RingHom.ker (hx.repr : adjoin R (range x) â†’+* MvPolynomial Î¹ R) = âŠ¥ :=
  (RingHom.injective_iff_ker_eq_bot _).1 (AlgEquiv.injective _)
#align algebraic_independent.repr_ker AlgebraicIndependent.repr_ker

end repr

-- TODO - make this an `AlgEquiv`
/-- The isomorphism between `MvPolynomial (Option Î¹) R` and the polynomial ring over
the algebra generated by an algebraically independent family. -/
def AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin (hx : AlgebraicIndependent R x) :
    MvPolynomial (Option Î¹) R â‰ƒ+* Polynomial (adjoin R (Set.range x)) :=
  (MvPolynomial.optionEquivLeft _ _).toRingEquiv.trans
    (Polynomial.mapEquiv hx.aevalEquiv.toRingEquiv)
#align algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin

@[simp]
theorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_apply
    (hx : AlgebraicIndependent R x) (y) :
    hx.mvPolynomialOptionEquivPolynomialAdjoin y =
      Polynomial.map (hx.aevalEquiv : MvPolynomial Î¹ R â†’+* adjoin R (range x))
        (aeval (fun o : Option Î¹ => o.elim Polynomial.X fun s : Î¹ => Polynomial.C (X s)) y) :=
  rfl
#align algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_apply AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_apply

--@[simp] Porting note: removing simp because the linter complains about deterministic timeout
theorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_C
    (hx : AlgebraicIndependent R x) (r) :
    hx.mvPolynomialOptionEquivPolynomialAdjoin (C r) = Polynomial.C (algebraMap _ _ r) := by
  rw [AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_apply, aeval_C,
    IsScalarTower.algebraMap_apply R (MvPolynomial Î¹ R), â† Polynomial.C_eq_algebraMap,
    Polynomial.map_C, RingHom.coe_coe, AlgEquiv.commutes]
set_option linter.uppercaseLean3 false in
#align algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_C AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_C

--@[simp] Porting note: simp can prove it
theorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_none
    (hx : AlgebraicIndependent R x) :
    hx.mvPolynomialOptionEquivPolynomialAdjoin (X none) = Polynomial.X := by
  rw [AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_apply, aeval_X, Option.elim,
    Polynomial.map_X]
set_option linter.uppercaseLean3 false in
#align algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_X_none AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_none

--@[simp] Porting note: simp can prove it
theorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_some
    (hx : AlgebraicIndependent R x) (i) :
    hx.mvPolynomialOptionEquivPolynomialAdjoin (X (some i)) =
      Polynomial.C (hx.aevalEquiv (X i)) := by
  rw [AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_apply, aeval_X, Option.elim,
    Polynomial.map_C, RingHom.coe_coe]
set_option linter.uppercaseLean3 false in
#align algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_X_some AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_some

set_option synthInstance.maxHeartbeats 1000000 in
set_option maxHeartbeats 1000000 in
theorem AlgebraicIndependent.aeval_comp_mvPolynomialOptionEquivPolynomialAdjoin
    (hx : AlgebraicIndependent R x) (a : A) :
    RingHom.comp
        (â†‘(Polynomial.aeval a : Polynomial (adjoin R (Set.range x)) â†’â‚[_] A) :
          Polynomial (adjoin R (Set.range x)) â†’+* A)
        hx.mvPolynomialOptionEquivPolynomialAdjoin.toRingHom =
      â†‘(MvPolynomial.aeval fun o : Option Î¹ => o.elim a x : MvPolynomial (Option Î¹) R â†’â‚[R] A) := by
  refine' MvPolynomial.ringHom_ext _ _ <;>
  -- âŠ¢ âˆ€ (r : R), â†‘(RingHom.comp (â†‘(Polynomial.aeval a)) (RingEquiv.toRingHom (mvPo â€¦
    simp only [RingHom.comp_apply, RingEquiv.toRingHom_eq_coe, RingEquiv.coe_toRingHom,
      AlgHom.coe_toRingHom, AlgHom.coe_toRingHom]
  Â· intro r
    -- âŠ¢ â†‘(Polynomial.aeval a) (â†‘(mvPolynomialOptionEquivPolynomialAdjoin hx) (â†‘C r)) â€¦
    rw [hx.mvPolynomialOptionEquivPolynomialAdjoin_C, aeval_C, Polynomial.aeval_C,
      IsScalarTower.algebraMap_apply R (adjoin R (range x)) A]
  Â· rintro (âŸ¨âŸ© | âŸ¨iâŸ©)
    -- âŠ¢ â†‘(Polynomial.aeval a) (â†‘(mvPolynomialOptionEquivPolynomialAdjoin hx) (X none â€¦
    Â· rw [hx.mvPolynomialOptionEquivPolynomialAdjoin_X_none, aeval_X, Polynomial.aeval_X,
        Option.elim]
    Â· rw [hx.mvPolynomialOptionEquivPolynomialAdjoin_X_some, Polynomial.aeval_C,
        hx.algebraMap_aevalEquiv, aeval_X, aeval_X, Option.elim]
#align algebraic_independent.aeval_comp_mv_polynomial_option_equiv_polynomial_adjoin AlgebraicIndependent.aeval_comp_mvPolynomialOptionEquivPolynomialAdjoin

theorem AlgebraicIndependent.option_iff (hx : AlgebraicIndependent R x) (a : A) :
    (AlgebraicIndependent R fun o : Option Î¹ => o.elim a x) â†”
      Â¬IsAlgebraic (adjoin R (Set.range x)) a := by
  rw [algebraicIndependent_iff_injective_aeval, isAlgebraic_iff_not_injective, Classical.not_not, â†
    AlgHom.coe_toRingHom, â† hx.aeval_comp_mvPolynomialOptionEquivPolynomialAdjoin,
    RingHom.coe_comp]
  exact Injective.of_comp_iff' (Polynomial.aeval a)
    (mvPolynomialOptionEquivPolynomialAdjoin hx).bijective
#align algebraic_independent.option_iff AlgebraicIndependent.option_iff

variable (R)

/-- A family is a transcendence basis if it is a maximal algebraically independent subset. -/
def IsTranscendenceBasis (x : Î¹ â†’ A) : Prop :=
  AlgebraicIndependent R x âˆ§
    âˆ€ (s : Set A) (_ : AlgebraicIndependent R ((â†‘) : s â†’ A)) (_ : range x â‰¤ s), range x = s
#align is_transcendence_basis IsTranscendenceBasis

theorem exists_isTranscendenceBasis (h : Injective (algebraMap R A)) :
    âˆƒ s : Set A, IsTranscendenceBasis R ((â†‘) : s â†’ A) := by
  cases' exists_maximal_algebraicIndependent (âˆ… : Set A) Set.univ (Set.subset_univ _)
      ((algebraicIndependent_empty_iff R A).2 h) with
    s hs
  use s, hs.1
  -- âŠ¢ âˆ€ (s_1 : Set A), AlgebraicIndependent R Subtype.val â†’ range Subtype.val â‰¤ s_ â€¦
  intro t ht hr
  -- âŠ¢ range Subtype.val = t
  simp only [Subtype.range_coe_subtype, setOf_mem_eq] at *
  -- âŠ¢ s = t
  exact Eq.symm (hs.2.2.2 t ht hr (Set.subset_univ _))
  -- ğŸ‰ no goals
#align exists_is_transcendence_basis exists_isTranscendenceBasis

variable {R}

theorem AlgebraicIndependent.isTranscendenceBasis_iff {Î¹ : Type w} {R : Type u} [CommRing R]
    [Nontrivial R] {A : Type v} [CommRing A] [Algebra R A] {x : Î¹ â†’ A}
    (i : AlgebraicIndependent R x) :
    IsTranscendenceBasis R x â†”
      âˆ€ (Îº : Type v) (w : Îº â†’ A) (_ : AlgebraicIndependent R w) (j : Î¹ â†’ Îº) (_ : w âˆ˜ j = x),
        Surjective j := by
  fconstructor
  -- âŠ¢ IsTranscendenceBasis R x â†’ âˆ€ (Îº : Type v) (w : Îº â†’ A), AlgebraicIndependent  â€¦
  Â· rintro p Îº w i' j rfl
    -- âŠ¢ Surjective j
    have p := p.2 (range w) i'.coe_range (range_comp_subset_range _ _)
    -- âŠ¢ Surjective j
    rw [range_comp, â† @image_univ _ _ w] at p
    -- âŠ¢ Surjective j
    exact range_iff_surjective.mp (image_injective.mpr i'.injective p)
    -- ğŸ‰ no goals
  Â· intro p
    -- âŠ¢ IsTranscendenceBasis R x
    use i
    -- âŠ¢ âˆ€ (s : Set A), AlgebraicIndependent R Subtype.val â†’ range x â‰¤ s â†’ range x = s
    intro w i' h
    -- âŠ¢ range x = w
    specialize p w ((â†‘) : w â†’ A) i' (fun i => âŸ¨x i, range_subset_iff.mp h iâŸ©) (by ext; simp)
    -- âŠ¢ range x = w
    have q := congr_arg (fun s => ((â†‘) : w â†’ A) '' s) p.range_eq
    -- âŠ¢ range x = w
    dsimp at q
    -- âŠ¢ range x = w
    rw [â† image_univ, image_image] at q
    -- âŠ¢ range x = w
    simpa using q
    -- ğŸ‰ no goals
#align algebraic_independent.is_transcendence_basis_iff AlgebraicIndependent.isTranscendenceBasis_iff

theorem IsTranscendenceBasis.isAlgebraic [Nontrivial R] (hx : IsTranscendenceBasis R x) :
    IsAlgebraic (adjoin R (range x)) A := by
  intro a
  -- âŠ¢ _root_.IsAlgebraic { x_1 // x_1 âˆˆ adjoin R (range x) } a
  rw [â† not_iff_comm.1 (hx.1.option_iff _).symm]
  -- âŠ¢ Â¬AlgebraicIndependent R fun o => Option.elim o a x
  intro ai
  -- âŠ¢ False
  have hâ‚ : range x âŠ† range fun o : Option Î¹ => o.elim a x := by
    rintro x âŸ¨y, rflâŸ©
    exact âŸ¨some y, rflâŸ©
  have hâ‚‚ : range x â‰  range fun o : Option Î¹ => o.elim a x := by
    intro h
    have : a âˆˆ range x := by
      rw [h]
      exact âŸ¨none, rflâŸ©
    rcases this with âŸ¨b, rflâŸ©
    have : some b = none := ai.injective rfl
    simpa
  exact hâ‚‚ (hx.2 (Set.range fun o : Option Î¹ => o.elim a x)
    ((algebraicIndependent_subtype_range ai.injective).2 ai) hâ‚)
#align is_transcendence_basis.is_algebraic IsTranscendenceBasis.isAlgebraic

section Field

variable [Field K] [Algebra K A]

/-Porting note: removing `simp`, not in simp normal form. Could make `Function.Injective f` a
simp lemma when `f` is a field hom, and then simp would prove this -/
theorem algebraicIndependent_empty_type [IsEmpty Î¹] [Nontrivial A] : AlgebraicIndependent K x := by
  rw [algebraicIndependent_empty_type_iff]
  -- âŠ¢ Injective â†‘(algebraMap K A)
  exact RingHom.injective _
  -- ğŸ‰ no goals
#align algebraic_independent_empty_type algebraicIndependent_empty_type

theorem algebraicIndependent_empty [Nontrivial A] :
    AlgebraicIndependent K ((â†‘) : (âˆ… : Set A) â†’ A) :=
  algebraicIndependent_empty_type
#align algebraic_independent_empty algebraicIndependent_empty

end Field
