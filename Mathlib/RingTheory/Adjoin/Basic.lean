/-
Copyright (c) 2019 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau
-/
import Mathlib.Algebra.Algebra.Operations
import Mathlib.Algebra.Algebra.Subalgebra.Tower
import Mathlib.LinearAlgebra.Prod
import Mathlib.LinearAlgebra.Finsupp

#align_import ring_theory.adjoin.basic from "leanprover-community/mathlib"@"a35ddf20601f85f78cd57e7f5b09ed528d71b7af"

/-!
# Adjoining elements to form subalgebras

This file develops the basic theory of subalgebras of an R-algebra generated
by a set of elements. A basic interface for `adjoin` is set up.

## Tags

adjoin, algebra

-/


universe uR uS uA uB

open Pointwise

open Submodule Subsemiring

variable {R : Type uR} {S : Type uS} {A : Type uA} {B : Type uB}

namespace Algebra

section Semiring

variable [CommSemiring R] [CommSemiring S] [Semiring A] [Semiring B]

variable [Algebra R S] [Algebra R A] [Algebra S A] [Algebra R B] [IsScalarTower R S A]
variable {s t : Set A}

theorem subset_adjoin : s âŠ† adjoin R s :=
  Algebra.gc.le_u_l s
#align algebra.subset_adjoin Algebra.subset_adjoin

theorem adjoin_le {S : Subalgebra R A} (H : s âŠ† S) : adjoin R s â‰¤ S :=
  Algebra.gc.l_le H
#align algebra.adjoin_le Algebra.adjoin_le

theorem adjoin_eq_sInf : adjoin R s = sInf { p : Subalgebra R A | s âŠ† p } :=
  le_antisymm (le_sInf fun _ h => adjoin_le h) (sInf_le subset_adjoin)
#align algebra.adjoin_eq_Inf Algebra.adjoin_eq_sInf

theorem adjoin_le_iff {S : Subalgebra R A} : adjoin R s â‰¤ S â†” s âŠ† S :=
  Algebra.gc _ _
#align algebra.adjoin_le_iff Algebra.adjoin_le_iff

theorem adjoin_mono (H : s âŠ† t) : adjoin R s â‰¤ adjoin R t :=
  Algebra.gc.monotone_l H
#align algebra.adjoin_mono Algebra.adjoin_mono

theorem adjoin_eq_of_le (S : Subalgebra R A) (hâ‚ : s âŠ† S) (hâ‚‚ : S â‰¤ adjoin R s) : adjoin R s = S :=
  le_antisymm (adjoin_le hâ‚) hâ‚‚
#align algebra.adjoin_eq_of_le Algebra.adjoin_eq_of_le

theorem adjoin_eq (S : Subalgebra R A) : adjoin R â†‘S = S :=
  adjoin_eq_of_le _ (Set.Subset.refl _) subset_adjoin
#align algebra.adjoin_eq Algebra.adjoin_eq

theorem adjoin_iUnion {Î± : Type*} (s : Î± â†’ Set A) :
    adjoin R (Set.iUnion s) = â¨† i : Î±, adjoin R (s i) :=
  (@Algebra.gc R A _ _ _).l_iSup
#align algebra.adjoin_Union Algebra.adjoin_iUnion

theorem adjoin_attach_biUnion [DecidableEq A] {Î± : Type*} {s : Finset Î±} (f : s â†’ Finset A) :
    adjoin R (s.attach.biUnion f : Set A) = â¨† x, adjoin R (f x) := by simp [adjoin_iUnion]
                                                                      -- ğŸ‰ no goals
#align algebra.adjoin_attach_bUnion Algebra.adjoin_attach_biUnion

@[elab_as_elim]
theorem adjoin_induction {p : A â†’ Prop} {x : A} (h : x âˆˆ adjoin R s) (Hs : âˆ€ x âˆˆ s, p x)
    (Halg : âˆ€ r, p (algebraMap R A r)) (Hadd : âˆ€ x y, p x â†’ p y â†’ p (x + y))
    (Hmul : âˆ€ x y, p x â†’ p y â†’ p (x * y)) : p x :=
  let S : Subalgebra R A :=
    { carrier := p
      mul_mem' := Hmul _ _
      add_mem' := Hadd _ _
      algebraMap_mem' := Halg }
  adjoin_le (show s â‰¤ S from Hs) h
#align algebra.adjoin_induction Algebra.adjoin_induction

/-- Induction principle for the algebra generated by a set `s`: show that `p x y` holds for any
`x y âˆˆ adjoin R s` given that it holds for `x y âˆˆ s` and that it satisfies a number of
natural properties. -/
@[elab_as_elim]
theorem adjoin_inductionâ‚‚ {p : A â†’ A â†’ Prop} {a b : A} (ha : a âˆˆ adjoin R s) (hb : b âˆˆ adjoin R s)
    (Hs : âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, p x y) (Halg : âˆ€ râ‚ râ‚‚, p (algebraMap R A râ‚) (algebraMap R A râ‚‚))
    (Halg_left : âˆ€ (r), âˆ€ x âˆˆ s, p (algebraMap R A r) x)
    (Halg_right : âˆ€ (r), âˆ€ x âˆˆ s, p x (algebraMap R A r))
    (Hadd_left : âˆ€ xâ‚ xâ‚‚ y, p xâ‚ y â†’ p xâ‚‚ y â†’ p (xâ‚ + xâ‚‚) y)
    (Hadd_right : âˆ€ x yâ‚ yâ‚‚, p x yâ‚ â†’ p x yâ‚‚ â†’ p x (yâ‚ + yâ‚‚))
    (Hmul_left : âˆ€ xâ‚ xâ‚‚ y, p xâ‚ y â†’ p xâ‚‚ y â†’ p (xâ‚ * xâ‚‚) y)
    (Hmul_right : âˆ€ x yâ‚ yâ‚‚, p x yâ‚ â†’ p x yâ‚‚ â†’ p x (yâ‚ * yâ‚‚)) : p a b := by
  refine' adjoin_induction hb _ (fun r => _) (Hadd_right a) (Hmul_right a)
  -- âŠ¢ âˆ€ (x : A), x âˆˆ s â†’ p a x
  Â· exact adjoin_induction ha Hs Halg_left
      (fun x y Hx Hy z hz => Hadd_left x y z (Hx z hz) (Hy z hz))
      fun x y Hx Hy z hz => Hmul_left x y z (Hx z hz) (Hy z hz)
  Â· exact adjoin_induction ha (Halg_right r) (fun r' => Halg r' r)
      (fun x y => Hadd_left x y ((algebraMap R A) r))
      fun x y => Hmul_left x y ((algebraMap R A) r)
#align algebra.adjoin_inductionâ‚‚ Algebra.adjoin_inductionâ‚‚

/-- The difference with `Algebra.adjoin_induction` is that this acts on the subtype. -/
@[elab_as_elim]
theorem adjoin_induction' {p : adjoin R s â†’ Prop} (Hs : âˆ€ (x) (h : x âˆˆ s), p âŸ¨x, subset_adjoin hâŸ©)
    (Halg : âˆ€ r, p (algebraMap R _ r)) (Hadd : âˆ€ x y, p x â†’ p y â†’ p (x + y))
    (Hmul : âˆ€ x y, p x â†’ p y â†’ p (x * y)) (x : adjoin R s) : p x :=
  Subtype.recOn x fun x hx => by
    refine' Exists.elim _ fun (hx : x âˆˆ adjoin R s) (hc : p âŸ¨x, hxâŸ©) => hc
    -- âŠ¢ âˆƒ x_1, p { val := x, property := x_1 }
    exact adjoin_induction hx (fun x hx => âŸ¨subset_adjoin hx, Hs x hxâŸ©)
      (fun r => âŸ¨Subalgebra.algebraMap_mem _ r, Halg râŸ©)
      (fun x y hx hy =>
        Exists.elim hx fun hx' hx =>
          Exists.elim hy fun hy' hy => âŸ¨Subalgebra.add_mem _ hx' hy', Hadd _ _ hx hyâŸ©)
      fun x y hx hy =>
        Exists.elim hx fun hx' hx =>
          Exists.elim hy fun hy' hy => âŸ¨Subalgebra.mul_mem _ hx' hy', Hmul _ _ hx hyâŸ©
#align algebra.adjoin_induction' Algebra.adjoin_induction'

@[simp]
theorem adjoin_adjoin_coe_preimage {s : Set A} : adjoin R (((â†‘) : adjoin R s â†’ A) â»Â¹' s) = âŠ¤ := by
  refine'
    eq_top_iff.2 fun x =>
      -- porting note: Lean could no longer infer the motive
      adjoin_induction' (p := fun y => y âˆˆ adjoin R (((â†‘) : adjoin R s â†’ A) â»Â¹' s))
      (fun a ha => _) (fun r => _) (fun _ _ => _) (fun _ _ => _) x
  Â· exact subset_adjoin ha
    -- ğŸ‰ no goals
  Â· exact Subalgebra.algebraMap_mem _ r
    -- ğŸ‰ no goals
  Â· exact Subalgebra.add_mem _
    -- ğŸ‰ no goals
  Â· exact Subalgebra.mul_mem _
    -- ğŸ‰ no goals
#align algebra.adjoin_adjoin_coe_preimage Algebra.adjoin_adjoin_coe_preimage

theorem adjoin_union (s t : Set A) : adjoin R (s âˆª t) = adjoin R s âŠ” adjoin R t :=
  (Algebra.gc : GaloisConnection _ ((â†‘) : Subalgebra R A â†’ Set A)).l_sup
#align algebra.adjoin_union Algebra.adjoin_union

variable (R A)

@[simp]
theorem adjoin_empty : adjoin R (âˆ… : Set A) = âŠ¥ :=
  show adjoin R âŠ¥ = âŠ¥ by
    apply GaloisConnection.l_bot
    -- âŠ¢ GaloisConnection (adjoin R) ?u
    exact Algebra.gc
    -- ğŸ‰ no goals
#align algebra.adjoin_empty Algebra.adjoin_empty

@[simp]
theorem adjoin_univ : adjoin R (Set.univ : Set A) = âŠ¤ :=
  eq_top_iff.2 fun _x => subset_adjoin <| Set.mem_univ _
#align algebra.adjoin_univ Algebra.adjoin_univ

variable {A} (s)

theorem adjoin_eq_span : Subalgebra.toSubmodule (adjoin R s) = span R (Submonoid.closure s) := by
  apply le_antisymm
  -- âŠ¢ â†‘Subalgebra.toSubmodule (adjoin R s) â‰¤ span R â†‘(Submonoid.closure s)
  Â· intro r hr
    -- âŠ¢ r âˆˆ span R â†‘(Submonoid.closure s)
    rcases Subsemiring.mem_closure_iff_exists_list.1 hr with âŸ¨L, HL, rflâŸ©
    -- âŠ¢ List.sum (List.map List.prod L) âˆˆ span R â†‘(Submonoid.closure s)
    clear hr
    -- âŠ¢ List.sum (List.map List.prod L) âˆˆ span R â†‘(Submonoid.closure s)
    induction' L with hd tl ih
    -- âŠ¢ List.sum (List.map List.prod []) âˆˆ span R â†‘(Submonoid.closure s)
    Â· exact zero_mem _
      -- ğŸ‰ no goals
    rw [List.forall_mem_cons] at HL
    -- âŠ¢ List.sum (List.map List.prod (hd :: tl)) âˆˆ span R â†‘(Submonoid.closure s)
    rw [List.map_cons, List.sum_cons]
    -- âŠ¢ List.prod hd + List.sum (List.map List.prod tl) âˆˆ span R â†‘(Submonoid.closure â€¦
    refine' Submodule.add_mem _ _ (ih HL.2)
    -- âŠ¢ List.prod hd âˆˆ span R â†‘(Submonoid.closure s)
    replace HL := HL.1
    -- âŠ¢ List.prod hd âˆˆ span R â†‘(Submonoid.closure s)
    clear ih tl
    -- âŠ¢ List.prod hd âˆˆ span R â†‘(Submonoid.closure s)
    suffices âˆƒ (z r : _) (_hr : r âˆˆ Submonoid.closure s), z â€¢ r = List.prod hd by
      rcases this with âŸ¨z, r, hr, hzrâŸ©
      rw [â† hzr]
      exact smul_mem _ _ (subset_span hr)
    induction' hd with hd tl ih
    -- âŠ¢ âˆƒ z r _hr, z â€¢ r = List.prod []
    Â· exact âŸ¨1, 1, (Submonoid.closure s).one_mem', one_smul _ _âŸ©
      -- ğŸ‰ no goals
    rw [List.forall_mem_cons] at HL
    -- âŠ¢ âˆƒ z r _hr, z â€¢ r = List.prod (hd :: tl)
    rcases ih HL.2 with âŸ¨z, r, hr, hzrâŸ©
    -- âŠ¢ âˆƒ z r _hr, z â€¢ r = List.prod (hd :: tl)
    rw [List.prod_cons, â† hzr]
    -- âŠ¢ âˆƒ z_1 r_1 _hr, z_1 â€¢ r_1 = hd * z â€¢ r
    rcases HL.1 with (âŸ¨hd, rflâŸ© | hs)
    -- âŠ¢ âˆƒ z_1 r_1 _hr, z_1 â€¢ r_1 = â†‘(algebraMap R A) hd * z â€¢ r
    Â· refine' âŸ¨hd * z, r, hr, _âŸ©
      -- âŠ¢ (hd * z) â€¢ r = â†‘(algebraMap R A) hd * z â€¢ r
      rw [Algebra.smul_def, Algebra.smul_def, (algebraMap _ _).map_mul, _root_.mul_assoc]
      -- ğŸ‰ no goals
    Â· exact
        âŸ¨z, hd * r, Submonoid.mul_mem _ (Submonoid.subset_closure hs) hr,
          (mul_smul_comm _ _ _).symmâŸ©
  refine' span_le.2 _
  -- âŠ¢ â†‘(Submonoid.closure s) âŠ† â†‘(â†‘Subalgebra.toSubmodule (adjoin R s))
  change Submonoid.closure s â‰¤ (adjoin R s).toSubsemiring.toSubmonoid
  -- âŠ¢ Submonoid.closure s â‰¤ (adjoin R s).toSubsemiring.toSubmonoid
  exact Submonoid.closure_le.2 subset_adjoin
  -- ğŸ‰ no goals
#align algebra.adjoin_eq_span Algebra.adjoin_eq_span

theorem span_le_adjoin (s : Set A) : span R s â‰¤ Subalgebra.toSubmodule (adjoin R s) :=
  span_le.mpr subset_adjoin
#align algebra.span_le_adjoin Algebra.span_le_adjoin

theorem adjoin_toSubmodule_le {s : Set A} {t : Submodule R A} :
    Subalgebra.toSubmodule (adjoin R s) â‰¤ t â†” â†‘(Submonoid.closure s) âŠ† (t : Set A) := by
  rw [adjoin_eq_span, span_le]
  -- ğŸ‰ no goals
#align algebra.adjoin_to_submodule_le Algebra.adjoin_toSubmodule_le

theorem adjoin_eq_span_of_subset {s : Set A} (hs : â†‘(Submonoid.closure s) âŠ† (span R s : Set A)) :
    Subalgebra.toSubmodule (adjoin R s) = span R s :=
  le_antisymm ((adjoin_toSubmodule_le R).mpr hs) (span_le_adjoin R s)
#align algebra.adjoin_eq_span_of_subset Algebra.adjoin_eq_span_of_subset

@[simp]
theorem adjoin_span {s : Set A} : adjoin R (Submodule.span R s : Set A) = adjoin R s :=
  le_antisymm (adjoin_le (span_le_adjoin _ _)) (adjoin_mono Submodule.subset_span)
#align algebra.adjoin_span Algebra.adjoin_span

theorem adjoin_image (f : A â†’â‚[R] B) (s : Set A) : adjoin R (f '' s) = (adjoin R s).map f :=
  le_antisymm (adjoin_le <| Set.image_subset _ subset_adjoin) <|
    Subalgebra.map_le.2 <| adjoin_le <| Set.image_subset_iff.1 <| by
      -- porting note: I don't understand how this worked in Lean 3 with just `subset_adjoin`
      simp only [Set.image_id', coe_carrier_toSubmonoid, Subalgebra.coe_toSubsemiring,
        Subalgebra.coe_comap]
      exact fun x hx => subset_adjoin âŸ¨x, hx, rflâŸ©
      -- ğŸ‰ no goals
#align algebra.adjoin_image Algebra.adjoin_image

@[simp]
theorem adjoin_insert_adjoin (x : A) : adjoin R (insert x â†‘(adjoin R s)) = adjoin R (insert x s) :=
  le_antisymm
    (adjoin_le
      (Set.insert_subset_iff.mpr
        âŸ¨subset_adjoin (Set.mem_insert _ _), adjoin_mono (Set.subset_insert _ _)âŸ©))
    (Algebra.adjoin_mono (Set.insert_subset_insert Algebra.subset_adjoin))
#align algebra.adjoin_insert_adjoin Algebra.adjoin_insert_adjoin

theorem adjoin_prod_le (s : Set A) (t : Set B) :
    adjoin R (s Ã—Ë¢ t) â‰¤ (adjoin R s).prod (adjoin R t) :=
  adjoin_le <| Set.prod_mono subset_adjoin subset_adjoin
#align algebra.adjoin_prod_le Algebra.adjoin_prod_le

theorem mem_adjoin_of_map_mul {s} {x : A} {f : A â†’â‚—[R] B} (hf : âˆ€ aâ‚ aâ‚‚, f (aâ‚ * aâ‚‚) = f aâ‚ * f aâ‚‚)
    (h : x âˆˆ adjoin R s) : f x âˆˆ adjoin R (f '' (s âˆª {1})) := by
  refine'
    @adjoin_induction R A _ _ _ _ (fun a => f a âˆˆ adjoin R (f '' (s âˆª {1}))) x h
      (fun a ha => subset_adjoin âŸ¨a, âŸ¨Set.subset_union_left _ _ ha, rflâŸ©âŸ©) (fun r => _)
      (fun y z hy hz => by simpa [hy, hz] using Subalgebra.add_mem _ hy hz) fun y z hy hz => by
      simpa [hy, hz, hf y z] using Subalgebra.mul_mem _ hy hz
  have : f 1 âˆˆ adjoin R (f '' (s âˆª {1})) :=
    subset_adjoin âŸ¨1, âŸ¨Set.subset_union_right _ _ <| Set.mem_singleton 1, rflâŸ©âŸ©
  convert Subalgebra.smul_mem (adjoin R (f '' (s âˆª {1}))) this r
  -- âŠ¢ â†‘f (â†‘(algebraMap R A) r) = r â€¢ â†‘f 1
  rw [algebraMap_eq_smul_one]
  -- âŠ¢ â†‘f (r â€¢ 1) = r â€¢ â†‘f 1
  exact f.map_smul _ _
  -- ğŸ‰ no goals
#align algebra.mem_adjoin_of_map_mul Algebra.mem_adjoin_of_map_mul

theorem adjoin_inl_union_inr_eq_prod (s) (t) :
    adjoin R (LinearMap.inl R A B '' (s âˆª {1}) âˆª LinearMap.inr R A B '' (t âˆª {1})) =
      (adjoin R s).prod (adjoin R t) := by
  apply le_antisymm
  -- âŠ¢ adjoin R (â†‘(LinearMap.inl R A B) '' (s âˆª {1}) âˆª â†‘(LinearMap.inr R A B) '' (t â€¦
  Â· simp only [adjoin_le_iff, Set.insert_subset_iff, Subalgebra.zero_mem, Subalgebra.one_mem,
      subset_adjoin,-- the rest comes from `squeeze_simp`
      Set.union_subset_iff,
      LinearMap.coe_inl, Set.mk_preimage_prod_right, Set.image_subset_iff, SetLike.mem_coe,
      Set.mk_preimage_prod_left, LinearMap.coe_inr, and_self_iff, Set.union_singleton,
      Subalgebra.coe_prod]
  Â· rintro âŸ¨a, bâŸ© âŸ¨ha, hbâŸ©
    -- âŠ¢ (a, b) âˆˆ adjoin R (â†‘(LinearMap.inl R A B) '' (s âˆª {1}) âˆª â†‘(LinearMap.inr R A â€¦
    let P := adjoin R (LinearMap.inl R A B '' (s âˆª {1}) âˆª LinearMap.inr R A B '' (t âˆª {1}))
    -- âŠ¢ (a, b) âˆˆ adjoin R (â†‘(LinearMap.inl R A B) '' (s âˆª {1}) âˆª â†‘(LinearMap.inr R A â€¦
    have Ha : (a, (0 : B)) âˆˆ adjoin R (LinearMap.inl R A B '' (s âˆª {1})) :=
      mem_adjoin_of_map_mul R LinearMap.inl_map_mul ha
    have Hb : ((0 : A), b) âˆˆ adjoin R (LinearMap.inr R A B '' (t âˆª {1})) :=
      mem_adjoin_of_map_mul R LinearMap.inr_map_mul hb
    replace Ha : (a, (0 : B)) âˆˆ P := adjoin_mono (Set.subset_union_left _ _) Ha
    -- âŠ¢ (a, b) âˆˆ adjoin R (â†‘(LinearMap.inl R A B) '' (s âˆª {1}) âˆª â†‘(LinearMap.inr R A â€¦
    replace Hb : ((0 : A), b) âˆˆ P := adjoin_mono (Set.subset_union_right _ _) Hb
    -- âŠ¢ (a, b) âˆˆ adjoin R (â†‘(LinearMap.inl R A B) '' (s âˆª {1}) âˆª â†‘(LinearMap.inr R A â€¦
    simpa using Subalgebra.add_mem _ Ha Hb
    -- ğŸ‰ no goals
#align algebra.adjoin_inl_union_inr_eq_prod Algebra.adjoin_inl_union_inr_eq_prod

/-- If all elements of `s : Set A` commute pairwise, then `adjoin R s` is a commutative
semiring.  -/
def adjoinCommSemiringOfComm {s : Set A} (hcomm : âˆ€ a âˆˆ s, âˆ€ b âˆˆ s, a * b = b * a) :
    CommSemiring (adjoin R s) :=
  { (adjoin R s).toSemiring with
    mul_comm := fun x y => by
      ext
      -- âŠ¢ â†‘(x * y) = â†‘(y * x)
      simp only [Subalgebra.coe_mul]
      -- âŠ¢ â†‘x * â†‘y = â†‘y * â†‘x
      exact adjoin_inductionâ‚‚ x.prop y.prop hcomm (fun _ _ => by rw [commutes])
        (fun r x _hx => commutes r x) (fun r x _hx => (commutes r x).symm)
        (fun _ _ _ hâ‚ hâ‚‚ => by simp only [add_mul, mul_add, hâ‚, hâ‚‚])
        (fun _ _ _ hâ‚ hâ‚‚ => by simp only [add_mul, mul_add, hâ‚, hâ‚‚])
        (fun xâ‚ xâ‚‚ yâ‚ hâ‚ hâ‚‚ => by rw [mul_assoc, hâ‚‚, â† mul_assoc yâ‚, â† hâ‚, mul_assoc xâ‚])
        fun xâ‚ xâ‚‚ yâ‚ hâ‚ hâ‚‚ => by rw [mul_assoc xâ‚‚, â† hâ‚‚, â† mul_assoc xâ‚‚, â† hâ‚, â† mul_assoc] }
#align algebra.adjoin_comm_semiring_of_comm Algebra.adjoinCommSemiringOfComm

theorem adjoin_singleton_one : adjoin R ({1} : Set A) = âŠ¥ :=
  eq_bot_iff.2 <| adjoin_le <| Set.singleton_subset_iff.2 <| SetLike.mem_coe.2 <| one_mem _
#align algebra.adjoin_singleton_one Algebra.adjoin_singleton_one

theorem self_mem_adjoin_singleton (x : A) : x âˆˆ adjoin R ({x} : Set A) :=
  Algebra.subset_adjoin (Set.mem_singleton_iff.mpr rfl)
#align algebra.self_mem_adjoin_singleton Algebra.self_mem_adjoin_singleton

variable (A) in
theorem adjoin_algebraMap (s : Set S) :
    adjoin R (algebraMap S A '' s) = (adjoin R s).map (IsScalarTower.toAlgHom R S A) :=
  adjoin_image R (IsScalarTower.toAlgHom R S A) s
#align algebra.adjoin_algebra_map Algebra.adjoin_algebraMap

theorem adjoin_algebraMap_image_union_eq_adjoin_adjoin (s : Set S) (t : Set A) :
    adjoin R (algebraMap S A '' s âˆª t) = (adjoin (adjoin R s) t).restrictScalars R :=
  le_antisymm
    (closure_mono <|
      Set.union_subset (Set.range_subset_iff.2 fun r => Or.inl âŸ¨algebraMap R (adjoin R s) r,
        (IsScalarTower.algebraMap_apply _ _ _ _).symmâŸ©)
        (Set.union_subset_union_left _ fun _ âŸ¨_x, hx, hxsâŸ© => hxs â–¸ âŸ¨âŸ¨_, subset_adjoin hxâŸ©, rflâŸ©))
    (closure_le.2 <|
      Set.union_subset (Set.range_subset_iff.2 fun x => adjoin_mono (Set.subset_union_left _ _) <|
        Algebra.adjoin_algebraMap R A s â–¸ âŸ¨x, x.prop, rflâŸ©)
        (Set.Subset.trans (Set.subset_union_right _ _) subset_adjoin))

theorem adjoin_adjoin_of_tower (s : Set A) : adjoin S (adjoin R s : Set A) = adjoin S s := by
  apply le_antisymm (adjoin_le _)
  -- âŠ¢ adjoin S s â‰¤ adjoin S â†‘(adjoin R s)
  Â· exact adjoin_mono subset_adjoin
    -- ğŸ‰ no goals
  Â· change adjoin R s â‰¤ (adjoin S s).restrictScalars R
    -- âŠ¢ adjoin R s â‰¤ Subalgebra.restrictScalars R (adjoin S s)
    refine' adjoin_le _
    -- âŠ¢ s âŠ† â†‘(Subalgebra.restrictScalars R (adjoin S s))
    -- porting note: unclear why this was broken
    have : (Subalgebra.restrictScalars R (adjoin S s) : Set A) = adjoin S s := rfl
    -- âŠ¢ s âŠ† â†‘(Subalgebra.restrictScalars R (adjoin S s))
    rw [this]
    -- âŠ¢ s âŠ† â†‘(adjoin S s)
    exact subset_adjoin
    -- ğŸ‰ no goals
#align algebra.adjoin_adjoin_of_tower Algebra.adjoin_adjoin_of_tower

@[simp]
theorem adjoin_top :
    adjoin (âŠ¤ : Subalgebra R S) t = (adjoin S t).restrictScalars (âŠ¤ : Subalgebra R S) :=
  let equivTop : Subalgebra (âŠ¤ : Subalgebra R S) A â‰ƒo Subalgebra S A :=
    { toFun := fun s => { s with algebraMap_mem' := fun r => s.algebraMap_mem âŸ¨r, trivialâŸ© }
      invFun := fun s => s.restrictScalars _
      left_inv := fun _ => SetLike.coe_injective rfl
      right_inv := fun _ => SetLike.coe_injective rfl
      map_rel_iff' := @fun _ _ => Iff.rfl }
  le_antisymm
    (adjoin_le <| show t âŠ† adjoin S t from subset_adjoin)
    (equivTop.symm_apply_le.mpr <|
      adjoin_le <| show t âŠ† adjoin (âŠ¤ : Subalgebra R S) t from subset_adjoin)

end Semiring

section CommSemiring

variable [CommSemiring R] [CommSemiring A]

variable [Algebra R A] {s t : Set A}

variable (R s t)

theorem adjoin_union_eq_adjoin_adjoin :
    adjoin R (s âˆª t) = (adjoin (adjoin R s) t).restrictScalars R := by
  simpa using adjoin_algebraMap_image_union_eq_adjoin_adjoin R s t
  -- ğŸ‰ no goals
#align algebra.adjoin_union_eq_adjoin_adjoin Algebra.adjoin_union_eq_adjoin_adjoin

theorem adjoin_union_coe_submodule :
    Subalgebra.toSubmodule (adjoin R (s âˆª t)) =
      Subalgebra.toSubmodule (adjoin R s) * Subalgebra.toSubmodule (adjoin R t) := by
  rw [adjoin_eq_span, adjoin_eq_span, adjoin_eq_span, span_mul_span]
  -- âŠ¢ span R â†‘(Submonoid.closure (s âˆª t)) = span R (â†‘(Submonoid.closure s) * â†‘(Sub â€¦
  congr 1 with z; simp [Submonoid.closure_union, Submonoid.mem_sup, Set.mem_mul]
  -- âŠ¢ z âˆˆ â†‘(Submonoid.closure (s âˆª t)) â†” z âˆˆ â†‘(Submonoid.closure s) * â†‘(Submonoid. â€¦
                  -- ğŸ‰ no goals
#align algebra.adjoin_union_coe_submodule Algebra.adjoin_union_coe_submodule

variable {R}

theorem pow_smul_mem_of_smul_subset_of_mem_adjoin [CommSemiring B] [Algebra R B] [Algebra A B]
    [IsScalarTower R A B] (r : A) (s : Set B) (B' : Subalgebra R B) (hs : r â€¢ s âŠ† B') {x : B}
    (hx : x âˆˆ adjoin R s) (hr : algebraMap A B r âˆˆ B') : âˆƒ nâ‚€ : â„•, âˆ€ n â‰¥ nâ‚€, r ^ n â€¢ x âˆˆ B' := by
  -- porting note: use `replace` because we don't have `change ... at` yet
  replace hx : x âˆˆ Subalgebra.toSubmodule (adjoin R s) := hx
  -- âŠ¢ âˆƒ nâ‚€, âˆ€ (n : â„•), n â‰¥ nâ‚€ â†’ r ^ n â€¢ x âˆˆ B'
  rw [adjoin_eq_span, Finsupp.mem_span_iff_total] at hx
  -- âŠ¢ âˆƒ nâ‚€, âˆ€ (n : â„•), n â‰¥ nâ‚€ â†’ r ^ n â€¢ x âˆˆ B'
  rcases hx with âŸ¨l, rfl : (l.sum fun (i : Submonoid.closure s) (c : R) => c â€¢ (i : B)) = xâŸ©
  -- âŠ¢ âˆƒ nâ‚€, âˆ€ (n : â„•), n â‰¥ nâ‚€ â†’ (r ^ n â€¢ Finsupp.sum l fun i c => c â€¢ â†‘i) âˆˆ B'
  choose nâ‚ nâ‚‚ using fun x : Submonoid.closure s => Submonoid.pow_smul_mem_closure_smul r s x.prop
  -- âŠ¢ âˆƒ nâ‚€, âˆ€ (n : â„•), n â‰¥ nâ‚€ â†’ (r ^ n â€¢ Finsupp.sum l fun i c => c â€¢ â†‘i) âˆˆ B'
  use l.support.sup nâ‚
  -- âŠ¢ âˆ€ (n : â„•), n â‰¥ Finset.sup l.support nâ‚ â†’ (r ^ n â€¢ Finsupp.sum l fun i c => c â€¦
  intro n hn
  -- âŠ¢ (r ^ n â€¢ Finsupp.sum l fun i c => c â€¢ â†‘i) âˆˆ B'
  rw [Finsupp.smul_sum]
  -- âŠ¢ (Finsupp.sum l fun a b => r ^ n â€¢ b â€¢ â†‘a) âˆˆ B'
  refine' B'.toSubmodule.sum_mem _
  -- âŠ¢ âˆ€ (c : â†‘â†‘(Submonoid.closure s)), c âˆˆ l.support â†’ (fun a b => r ^ n â€¢ b â€¢ â†‘a) â€¦
  intro a ha
  -- âŠ¢ (fun a b => r ^ n â€¢ b â€¢ â†‘a) a (â†‘l a) âˆˆ â†‘Subalgebra.toSubmodule B'
  have : n â‰¥ nâ‚ a := le_trans (Finset.le_sup ha) hn
  -- âŠ¢ (fun a b => r ^ n â€¢ b â€¢ â†‘a) a (â†‘l a) âˆˆ â†‘Subalgebra.toSubmodule B'
  dsimp only
  -- âŠ¢ r ^ n â€¢ â†‘l a â€¢ â†‘a âˆˆ â†‘Subalgebra.toSubmodule B'
  rw [â† tsub_add_cancel_of_le this, pow_add, â† smul_smul, â†
    IsScalarTower.algebraMap_smul A (l a) (a : B), smul_smul (r ^ nâ‚ a), mul_comm, â† smul_smul,
    smul_def, map_pow, IsScalarTower.algebraMap_smul]
  apply Subalgebra.mul_mem _ (Subalgebra.pow_mem _ hr _) _
  -- âŠ¢ â†‘l a â€¢ r ^ nâ‚ a â€¢ â†‘a âˆˆ B'
  refine' Subalgebra.smul_mem _ _ _
  -- âŠ¢ r ^ nâ‚ a â€¢ â†‘a âˆˆ B'
  change _ âˆˆ B'.toSubmonoid
  -- âŠ¢ r ^ nâ‚ a â€¢ â†‘a âˆˆ B'.toSubmonoid
  rw [â† Submonoid.closure_eq B'.toSubmonoid]
  -- âŠ¢ r ^ nâ‚ a â€¢ â†‘a âˆˆ Submonoid.closure â†‘B'.toSubmonoid
  apply Submonoid.closure_mono hs (nâ‚‚ a)
  -- ğŸ‰ no goals
#align algebra.pow_smul_mem_of_smul_subset_of_mem_adjoin Algebra.pow_smul_mem_of_smul_subset_of_mem_adjoin

theorem pow_smul_mem_adjoin_smul (r : R) (s : Set A) {x : A} (hx : x âˆˆ adjoin R s) :
    âˆƒ nâ‚€ : â„•, âˆ€ n â‰¥ nâ‚€, r ^ n â€¢ x âˆˆ adjoin R (r â€¢ s) :=
  pow_smul_mem_of_smul_subset_of_mem_adjoin r s _ subset_adjoin hx (Subalgebra.algebraMap_mem _ _)
#align algebra.pow_smul_mem_adjoin_smul Algebra.pow_smul_mem_adjoin_smul

end CommSemiring

section Ring

variable [CommRing R] [Ring A]

variable [Algebra R A] {s t : Set A}

theorem adjoin_int (s : Set R) : adjoin â„¤ s = subalgebraOfSubring (Subring.closure s) :=
  le_antisymm (adjoin_le Subring.subset_closure)
    (Subring.closure_le.2 subset_adjoin : Subring.closure s â‰¤ (adjoin â„¤ s).toSubring)
#align algebra.adjoin_int Algebra.adjoin_int

theorem mem_adjoin_iff {s : Set A} {x : A} :
    x âˆˆ adjoin R s â†” x âˆˆ Subring.closure (Set.range (algebraMap R A) âˆª s) :=
  âŸ¨fun hx =>
    Subsemiring.closure_induction hx Subring.subset_closure (Subring.zero_mem _) (Subring.one_mem _)
      (fun _ _ => Subring.add_mem _) fun _ _ => Subring.mul_mem _,
    suffices Subring.closure (Set.range (algebraMap R A) âˆª s) â‰¤ (adjoin R s).toSubring
      from (show (_ : Set A) âŠ† _ from this) (a := x)
    -- porting note: Lean doesn't seem to recognize the defeq between the order on subobjects and
    -- subsets of their coercions to sets as easily as in Lean 3
    Subring.closure_le.2 Subsemiring.subset_closureâŸ©
#align algebra.mem_adjoin_iff Algebra.mem_adjoin_iff

theorem adjoin_eq_ring_closure (s : Set A) :
    (adjoin R s).toSubring = Subring.closure (Set.range (algebraMap R A) âˆª s) :=
  Subring.ext fun _x => mem_adjoin_iff
#align algebra.adjoin_eq_ring_closure Algebra.adjoin_eq_ring_closure

variable (R)

/-- If all elements of `s : Set A` commute pairwise, then `adjoin R s` is a commutative
ring.  -/
def adjoinCommRingOfComm {s : Set A} (hcomm : âˆ€ a âˆˆ s, âˆ€ b âˆˆ s, a * b = b * a) :
    CommRing (adjoin R s) :=
  { (adjoin R s).toRing, adjoinCommSemiringOfComm R hcomm with }
#align algebra.adjoin_comm_ring_of_comm Algebra.adjoinCommRingOfComm

end Ring

end Algebra

open Algebra Subalgebra

namespace AlgHom

variable [CommSemiring R] [Semiring A] [Semiring B] [Algebra R A] [Algebra R B]

theorem map_adjoin (Ï† : A â†’â‚[R] B) (s : Set A) : (adjoin R s).map Ï† = adjoin R (Ï† '' s) :=
  (adjoin_image _ _ _).symm
#align alg_hom.map_adjoin AlgHom.map_adjoin

theorem adjoin_le_equalizer (Ï†â‚ Ï†â‚‚ : A â†’â‚[R] B) {s : Set A} (h : s.EqOn Ï†â‚ Ï†â‚‚) :
    adjoin R s â‰¤ Ï†â‚.equalizer Ï†â‚‚ :=
  adjoin_le h
#align alg_hom.adjoin_le_equalizer AlgHom.adjoin_le_equalizer

theorem ext_of_adjoin_eq_top {s : Set A} (h : adjoin R s = âŠ¤) â¦ƒÏ†â‚ Ï†â‚‚ : A â†’â‚[R] Bâ¦„
    (hs : s.EqOn Ï†â‚ Ï†â‚‚) : Ï†â‚ = Ï†â‚‚ :=
  ext fun _x => adjoin_le_equalizer Ï†â‚ Ï†â‚‚ hs <| h.symm â–¸ trivial
#align alg_hom.ext_of_adjoin_eq_top AlgHom.ext_of_adjoin_eq_top

end AlgHom
