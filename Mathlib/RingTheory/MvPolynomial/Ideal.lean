/-
Copyright (c) 2023 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser
-/
import Mathlib.Algebra.MonoidAlgebra.Ideal
import Mathlib.Data.MvPolynomial.Division

#align_import ring_theory.mv_polynomial.ideal from "leanprover-community/mathlib"@"72c366d0475675f1309d3027d3d7d47ee4423951"

/-!
# Lemmas about ideals of `MvPolynomial`

Notably this contains results about monomial ideals.

## Main results

* `MvPolynomial.mem_ideal_span_monomial_image`
* `MvPolynomial.mem_ideal_span_X_image`
-/


variable {Ïƒ R : Type*}

namespace MvPolynomial

variable [CommSemiring R]

/-- `x` is in a monomial ideal generated by `s` iff every element of its support dominates one of
the generators. Note that `si â‰¤ xi` is analogous to saying that the monomial corresponding to `si`
divides the monomial corresponding to `xi`. -/
theorem mem_ideal_span_monomial_image {x : MvPolynomial Ïƒ R} {s : Set (Ïƒ â†’â‚€ â„•)} :
    x âˆˆ Ideal.span ((fun s => monomial s (1 : R)) '' s) â†” âˆ€ xi âˆˆ x.support, âˆƒ si âˆˆ s, si â‰¤ xi := by
  refine' AddMonoidAlgebra.mem_ideal_span_of'_image.trans _
  -- âŠ¢ (âˆ€ (m : Ïƒ â†’â‚€ â„•), m âˆˆ x.support â†’ âˆƒ m', m' âˆˆ s âˆ§ âˆƒ d, m = d + m') â†” âˆ€ (xi : Ïƒ â€¦
  simp_rw [le_iff_exists_add, add_comm]
  -- âŠ¢ (âˆ€ (m : Ïƒ â†’â‚€ â„•), m âˆˆ x.support â†’ âˆƒ m', m' âˆˆ s âˆ§ âˆƒ d, m = m' + d) â†” âˆ€ (xi : Ïƒ â€¦
  rfl
  -- ðŸŽ‰ no goals
#align mv_polynomial.mem_ideal_span_monomial_image MvPolynomial.mem_ideal_span_monomial_image

theorem mem_ideal_span_monomial_image_iff_dvd {x : MvPolynomial Ïƒ R} {s : Set (Ïƒ â†’â‚€ â„•)} :
    x âˆˆ Ideal.span ((fun s => monomial s (1 : R)) '' s) â†”
      âˆ€ xi âˆˆ x.support, âˆƒ si âˆˆ s, monomial si 1 âˆ£ monomial xi (x.coeff xi) := by
  refine' mem_ideal_span_monomial_image.trans (forallâ‚‚_congr fun xi hxi => _)
  -- âŠ¢ (âˆƒ si, si âˆˆ s âˆ§ si â‰¤ xi) â†” âˆƒ si, si âˆˆ s âˆ§ â†‘(monomial si) 1 âˆ£ â†‘(monomial xi)  â€¦
  simp_rw [monomial_dvd_monomial, one_dvd, and_true_iff, mem_support_iff.mp hxi, false_or_iff]
  -- ðŸŽ‰ no goals
#align mv_polynomial.mem_ideal_span_monomial_image_iff_dvd MvPolynomial.mem_ideal_span_monomial_image_iff_dvd

/-- `x` is in a monomial ideal generated by variables `X` iff every element of its support
has a component in `s`. -/
theorem mem_ideal_span_X_image {x : MvPolynomial Ïƒ R} {s : Set Ïƒ} :
    x âˆˆ Ideal.span (MvPolynomial.X '' s : Set (MvPolynomial Ïƒ R)) â†”
      âˆ€ m âˆˆ x.support, âˆƒ i âˆˆ s, (m : Ïƒ â†’â‚€ â„•) i â‰  0 := by
  have := @mem_ideal_span_monomial_image Ïƒ R _ x ((fun i => Finsupp.single i 1) '' s)
  -- âŠ¢ x âˆˆ Ideal.span (X '' s) â†” âˆ€ (m : Ïƒ â†’â‚€ â„•), m âˆˆ support x â†’ âˆƒ i, i âˆˆ s âˆ§ â†‘m i  â€¦
  rw [Set.image_image] at this
  -- âŠ¢ x âˆˆ Ideal.span (X '' s) â†” âˆ€ (m : Ïƒ â†’â‚€ â„•), m âˆˆ support x â†’ âˆƒ i, i âˆˆ s âˆ§ â†‘m i  â€¦
  refine' this.trans _
  -- âŠ¢ (âˆ€ (xi : Ïƒ â†’â‚€ â„•), xi âˆˆ support x â†’ âˆƒ si, si âˆˆ (fun i => Finsupp.single i 1)  â€¦
  simp [Nat.one_le_iff_ne_zero]
  -- ðŸŽ‰ no goals
set_option linter.uppercaseLean3 false in
#align mv_polynomial.mem_ideal_span_X_image MvPolynomial.mem_ideal_span_X_image

end MvPolynomial
