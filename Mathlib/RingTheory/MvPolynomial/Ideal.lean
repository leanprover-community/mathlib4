/-
Copyright (c) 2023 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser, Bingyu Xia
-/
module

public import Mathlib.Algebra.MonoidAlgebra.Ideal
public import Mathlib.Algebra.MvPolynomial.Division
public import Mathlib.RingTheory.MvPolynomial.MonomialOrder

/-!
# Lemmas about ideals of `MvPolynomial`

Notably this contains results about monomial ideals.

## Main results

* `MvPolynomial.mem_ideal_span_monomial_image`
* `MvPolynomial.mem_ideal_span_X_image`
* `MvPolynomial.mem_pow_idealOfVars_iff`

-/

public section


variable {σ R : Type*}

namespace MvPolynomial

variable [CommSemiring R]

/-- `x` is in a monomial ideal generated by `s` iff every element of its support dominates one of
the generators. Note that `si ≤ xi` is analogous to saying that the monomial corresponding to `si`
divides the monomial corresponding to `xi`. -/
theorem mem_ideal_span_monomial_image {x : MvPolynomial σ R} {s : Set (σ →₀ ℕ)} :
    x ∈ Ideal.span ((fun s => monomial s (1 : R)) '' s) ↔ ∀ xi ∈ x.support, ∃ si ∈ s, si ≤ xi := by
  refine AddMonoidAlgebra.mem_ideal_span_of'_image.trans ?_
  simp_rw [le_iff_exists_add, add_comm]
  rfl

theorem mem_ideal_span_monomial_image_iff_dvd {x : MvPolynomial σ R} {s : Set (σ →₀ ℕ)} :
    x ∈ Ideal.span ((fun s => monomial s (1 : R)) '' s) ↔
      ∀ xi ∈ x.support, ∃ si ∈ s, monomial si 1 ∣ monomial xi (x.coeff xi) := by
  refine mem_ideal_span_monomial_image.trans (forall₂_congr fun xi hxi => ?_)
  simp_rw [monomial_dvd_monomial, one_dvd, and_true, mem_support_iff.mp hxi, false_or]

/-- `x` is in a monomial ideal generated by variables `X` iff every element of its support
has a component in `s`. -/
theorem mem_ideal_span_X_image {x : MvPolynomial σ R} {s : Set σ} :
    x ∈ Ideal.span (MvPolynomial.X '' s : Set (MvPolynomial σ R)) ↔
      ∀ m ∈ x.support, ∃ i ∈ s, (m : σ →₀ ℕ) i ≠ 0 := by
  have := @mem_ideal_span_monomial_image σ R _ x ((fun i => Finsupp.single i 1) '' s)
  rw [Set.image_image] at this
  refine this.trans ?_
  simp [Nat.one_le_iff_ne_zero]

section idealOfVars

open Finset Finsupp

variable (σ R) in
/-- The ideal spanned by all of the variables. -/
def idealOfVars : Ideal (MvPolynomial σ R) := .span (Set.range X)

/-- The `n`th power of `idealOfVars` is spanned by all monomials of total degree `n`. -/
theorem pow_idealOfVars_eq_span (n) : idealOfVars σ R ^ n =
    .span ((fun x ↦ monomial x 1) '' {x | x.sum (fun _ => id) = n}) := by
  classical
  by_cases h' : Subsingleton R
  · exact Subsingleton.allEq ..
  rw [not_subsingleton_iff_nontrivial] at h'
  rw [idealOfVars, Ideal.span, Submodule.span_pow]
  congr; ext p
  simp only [Set.mem_pow_iff_prod, Set.mem_range, Set.mem_image, Set.mem_setOf_eq]
  refine ⟨fun ⟨f, h, hf⟩ => ?_, fun ⟨x, x_sum, hx⟩ => ?_⟩
  · choose i hi using h
    use ∑ j, single (i j) 1; constructor
    · simp [← Finsupp.sum_finset_sum_index]
    simp only [← hf, ← hi, monomial_sum_index, C_1, one_mul]
    rfl
  let l := x.toMultiset.toList
  have hl : n = l.length := by
    rw [Multiset.length_toList, card_toMultiset, x_sum]
  use fun i => X (l.get (Fin.cast hl i))
  simp only [List.get_eq_getElem, exists_apply_eq_apply, implies_true, true_and]
  rw [← Fintype.prod_equiv (finCongr (Eq.symm hl)) (fun i ↦ X l[i]) _ (by simp)]
  simp only [Fin.getElem_fin, Fin.prod_univ_fun_getElem, Multiset.prod_map_toList, toMultiset_map,
    prod_toMultiset, l]
  rw [prod, mapDomain_support_of_injective X_injective, ← hx, monomial_eq, C_1, one_mul, prod,
    prod_image (by simp)]
  refine prod_congr rfl (fun _ _ => ?_)
  rw [mapDomain_apply X_injective]

theorem mem_pow_idealOfVars_iff (n : ℕ) (p : MvPolynomial σ R) :
    p ∈ idealOfVars σ R ^ n ↔ ∀ x ∈ p.support, n ≤ x.sum (fun _ => id) := by
  classical
  constructor
  · rw [pow_idealOfVars_eq_span]
    refine Submodule.span_induction (fun u u_in x hx ↦ ?_) ?_ (fun _ _ _ _ _ _ _ h ↦ ?_)
      (fun r p p_in h x hx ↦ ?_)
    · simp only [Set.mem_image, Set.mem_setOf_eq] at u_in
      rcases u_in with ⟨v, v_sum, hv⟩
      simp only [← hv, mem_support_iff, coeff_monomial, ne_eq, ite_eq_right_iff,
        Classical.not_imp] at hx
      rw [← hx.left, v_sum]
    · simp
    · apply support_add at h
      grind only [= mem_union]
    rw [smul_eq_mul] at hx
    obtain ⟨u, u_in, v, v_in, huv⟩ := mem_add.mp (support_mul _ _ hx)
    rw [← huv, sum_add_index' (by simp) (by simp)]
    grind only
  intro h; rw [as_sum p]
  refine Ideal.sum_mem _ (fun x x_in ↦ ?_)
  rw [pow_idealOfVars_eq_span, mem_ideal_span_monomial_image]
  simp only [mem_support_iff, coeff_monomial, ne_eq, ite_eq_right_iff, Classical.not_imp,
    Set.mem_setOf_eq, and_imp, forall_eq']
  intro; specialize h x x_in
  clear * - h; revert n
  induction x using Finsupp.induction with
  | zero => simp_all
  | single_add a b f a_nIn b_ne ih =>
    intro n hn
    rw [sum_add_index' (by simp) (by simp), sum_single_index (by simp), id_eq] at hn
    by_cases h' : n < b
    · use single a n; constructor
      · simp
      simp only [single_le_iff, Finsupp.coe_add, Pi.add_apply, single_eq_same]
      lia
    obtain ⟨y, y_sum, hy⟩ := ih (n - b) (by lia)
    use single a b + y; constructor
    · rw [sum_add_index' (by simp) (by simp), sum_single_index (by simp), id_eq, y_sum]
      lia
    simpa

theorem mem_pow_idealOfVars_iff' (n : ℕ) (p : MvPolynomial σ R) :
    p ∈ idealOfVars σ R ^ n ↔ ∀ x, x.sum (fun _ => id) < n → p.coeff x = 0 := by
  grind only [mem_pow_idealOfVars_iff, mem_support_iff]

theorem monomial_mem_pow_idealOfVars_iff (n : ℕ) (x : σ →₀ ℕ) {r : R} (h : r ≠ 0) :
    monomial x r ∈ idealOfVars σ R ^ n ↔ n ≤ x.sum fun _ => id := by
  classical
  grind only [mem_pow_idealOfVars_iff, mem_support_iff, coeff_monomial]

theorem C_mem_pow_idealOfVars_iff (n r) : C r ∈ idealOfVars σ R ^ n ↔ r = 0 ∨ n = 0 := by
  by_cases h : r = 0
  · simp [h]
  simpa [h] using monomial_mem_pow_idealOfVars_iff (σ := σ) n 0 h

end idealOfVars

end MvPolynomial

namespace MonomialOrder

variable [CommSemiring R] {m : MonomialOrder σ}
open Ideal

lemma span_leadingTerm_sdiff_singleton_zero (B : Set (MvPolynomial σ R)) :
    span (m.leadingTerm '' (B \ {0})) = span (m.leadingTerm '' B) :=
  m.image_leadingTerm_sdiff_singleton_zero B ▸ Ideal.span_sdiff_singleton_zero

lemma span_leadingTerm_insert_zero (B : Set (MvPolynomial σ R)) :
    span (m.leadingTerm '' (insert 0 B)) = span (m.leadingTerm '' B) := by
  by_cases h : 0 ∈ B
  · rw [Set.insert_eq_of_mem h]
  · simp [image_leadingTerm_insert_zero]

lemma span_leadingTerm_eq_span_monomial {B : Set (MvPolynomial σ R)}
    (hB : ∀ p ∈ B, IsUnit (m.leadingCoeff p)) :
    span (m.leadingTerm '' B) =
      span ((fun p ↦ MvPolynomial.monomial (m.degree p) (1 : R)) '' B) := by
  classical
  apply le_antisymm
  all_goals
    rw [Ideal.span_le, Set.image_subset_iff]
    intro p hp
  · rw [Set.mem_preimage, SetLike.mem_coe, ← C_mul_leadingCoeff_monomial_degree]
    exact Ideal.mul_mem_left _ _ (Ideal.subset_span ⟨_, hp, rfl⟩)
  · rw [Set.mem_preimage, SetLike.mem_coe]
    convert (span <| m.leadingTerm '' B).mul_mem_left
      (MvPolynomial.C (hB p hp).unit⁻¹.val) <| subset_span ⟨p, hp, rfl⟩
    rw [← C_mul_leadingCoeff_monomial_degree, ← mul_assoc, ← map_mul,
      IsUnit.val_inv_mul, MvPolynomial.C_1, one_mul]

lemma span_leadingTerm_eq_span_monomial₀ {B : Set (MvPolynomial σ R)}
    (hB : ∀ p ∈ B, IsUnit (m.leadingCoeff p) ∨ p = 0) :
    span (m.leadingTerm '' B) =
      span ((fun p ↦ MvPolynomial.monomial (m.degree p) 1) '' (B \ {0})) := by
  rw [← m.span_leadingTerm_sdiff_singleton_zero]
  apply span_leadingTerm_eq_span_monomial
  simp_intro .. [or_iff_not_imp_right.mp (hB _ _)]

lemma span_leadingTerm_eq_span_monomial' {k : Type*} [Field k] {B : Set (MvPolynomial σ k)} :
    span (m.leadingTerm '' B) =
      span ((fun p ↦ MvPolynomial.monomial (m.degree p) 1) '' (B \ {0})) := by
  apply span_leadingTerm_eq_span_monomial₀
  simp [em']

lemma sPolynomial_mem_sup_ideal {R : Type*} [CommRing R]
    {I J : Ideal <| MvPolynomial σ R} {p q : MvPolynomial σ R}
    (hp : p ∈ I) (hq : q ∈ J) : m.sPolynomial p q ∈ I ⊔ J :=
  sub_mem (mul_mem_left _ _ (mem_sup_left hp)) (mul_mem_left _ _ (mem_sup_right hq))

lemma sPolynomial_mem_ideal {R : Type*} [CommRing R]
    {I : Ideal <| MvPolynomial σ R} {p q : MvPolynomial σ R}
    (hp : p ∈ I) (hq : q ∈ I) : m.sPolynomial p q ∈ I :=
  sub_mem (mul_mem_left I _ hp) (mul_mem_left I _ hq)

end MonomialOrder
