/-
Copyright (c) 2023 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser, Bingyu Xia, Andrew Wang
-/
module

public import Mathlib.Algebra.MonoidAlgebra.Ideal
public import Mathlib.Algebra.MvPolynomial.Division
public import Mathlib.RingTheory.MvPolynomial.MonomialOrder
public import Mathlib.RingTheory.MvPolynomial.Basic
public import Mathlib.Algebra.Group.Pointwise.Set.Finsupp
public import Mathlib.Data.Finsupp.Weight
public import Mathlib.Algebra.Order.Group.Pointwise.Interval
public import Mathlib.RingTheory.Ideal.Operations

/-!
# Lemmas about ideals of `MvPolynomial`

Notably this contains results about monomial ideals.

## Main results

* `MvPolynomial.mem_ideal_span_monomial_image`
* `MvPolynomial.mem_ideal_span_X_image`
* `MvPolynomial.mem_pow_idealOfVars_iff`
-/

public section


variable {σ R : Type*}

namespace MvPolynomial

variable [CommSemiring R]

/-- `x` is in a monomial ideal generated by `s` iff every element of its support dominates one of
the generators. Note that `si ≤ xi` is analogous to saying that the monomial corresponding to `si`
divides the monomial corresponding to `xi`. -/
theorem mem_ideal_span_monomial_image {x : MvPolynomial σ R} {s : Set (σ →₀ ℕ)} :
    x ∈ Ideal.span ((fun s => monomial s (1 : R)) '' s) ↔ ∀ xi ∈ x.support, ∃ si ∈ s, si ≤ xi := by
  refine AddMonoidAlgebra.mem_ideal_span_of'_image.trans ?_
  simp_rw [le_iff_exists_add, add_comm]
  rfl

theorem mem_ideal_span_monomial_image_iff_dvd {x : MvPolynomial σ R} {s : Set (σ →₀ ℕ)} :
    x ∈ Ideal.span ((fun s => monomial s (1 : R)) '' s) ↔
      ∀ xi ∈ x.support, ∃ si ∈ s, monomial si 1 ∣ monomial xi (x.coeff xi) := by
  refine mem_ideal_span_monomial_image.trans (forall₂_congr fun xi hxi => ?_)
  simp_rw [monomial_dvd_monomial, one_dvd, and_true, mem_support_iff.mp hxi, false_or]

/-- `x` is in a monomial ideal generated by variables `X` iff every element of its support
has a component in `s`. -/
theorem mem_ideal_span_X_image {x : MvPolynomial σ R} {s : Set σ} :
    x ∈ Ideal.span (MvPolynomial.X '' s : Set (MvPolynomial σ R)) ↔
      ∀ m ∈ x.support, ∃ i ∈ s, (m : σ →₀ ℕ) i ≠ 0 := by
  have := @mem_ideal_span_monomial_image σ R _ x ((fun i => Finsupp.single i 1) '' s)
  rw [Set.image_image] at this
  refine this.trans ?_
  simp [Nat.one_le_iff_ne_zero]

section idealOfVars

open Finset Finsupp

variable (σ R) in
/-- The ideal spanned by all variables. -/
def idealOfVars : Ideal (MvPolynomial σ R) := .span (Set.range X)

lemma idealOfVars_eq_restrictSupportIdeal :
    idealOfVars σ R = restrictSupportIdeal _ _ ((isUpperSet_Ici 1).preimage degree_mono) := by
  apply le_antisymm
  · simp [idealOfVars, Ideal.span_le, Set.range_subset_iff, restrictSupportIdeal, X]
  · change restrictSupport _ _ ≤ (idealOfVars σ R).restrictScalars R
    rw [restrictSupport_eq_span, Submodule.span_le, Set.image_subset_iff]
    intro x hx
    obtain ⟨i, hi⟩ : x.support.Nonempty := by aesop
    obtain ⟨c, rfl⟩ := le_iff_exists_add'.mp (show single i 1 ≤ x by simp_all; lia)
    simpa [monomial_add_single] using Ideal.mul_mem_left _ _ (Ideal.subset_span (by simp))

open Pointwise in
theorem pow_idealOfVars (n : ℕ) :
    idealOfVars σ R ^ n = restrictSupportIdeal _ _ ((isUpperSet_Ici n).preimage degree_mono) := by
  rw [idealOfVars_eq_restrictSupportIdeal]
  apply Submodule.restrictScalars_injective R
  by_cases hn : n = 0
  · simp [hn, show Set.Ici 0 = Set.univ by ext; simp, Ideal.one_eq_top]
  rw [Submodule.restrictScalars_pow hn]
  refine (restrictSupport_nsmul ..).symm.trans (congr_arg (restrictSupport R) ?_)
  obtain ⟨n, rfl⟩ := Nat.exists_eq_add_of_le' (Nat.one_le_cast_iff_ne_zero.mpr hn)
  clear hn; induction n with
  | zero => simp
  | succ n ih =>
    rw [succ_nsmul, ih]
    refine Set.Subset.antisymm (Set.Subset.trans (Set.preimage_add_preimage_subset _)
      (Set.preimage_mono (Set.Ici_add_Ici_subset ..))) ?_
    simp only [Set.subset_def, Set.mem_preimage, Set.mem_Ici, Set.mem_add]
    intro x x_deg
    obtain ⟨i, i_in⟩ := support_nonempty_iff (f := x).mpr (by grind only [= map_zero])
    obtain ⟨z, hz⟩ := exists_add_of_le (show single i 1 ≤ x by simp_all; lia)
    rw [add_comm, hz, map_add, degree_single, Nat.add_le_add_iff_left] at x_deg
    exact ⟨z, x_deg, ⟨single i 1, by simp, by rw [hz, add_comm]⟩⟩

/-- The `n`th power of `idealOfVars` is spanned by all monomials of total degree `n`. -/
theorem pow_idealOfVars_eq_span (n) : idealOfVars σ R ^ n =
    .span ((fun x ↦ monomial x 1) '' {x | x.sum (fun _ => id) = n}) := by
  rw [idealOfVars, Ideal.span, Submodule.span_pow, ← Set.image_univ,
    Set.image_pow_eq_image_finsupp_prod]
  simp [monomial_eq]

theorem mem_pow_idealOfVars_iff (n : ℕ) (p : MvPolynomial σ R) :
    p ∈ idealOfVars σ R ^ n ↔ ∀ x ∈ p.support, n ≤ x.sum (fun _ => id) := by
  rw [pow_idealOfVars]
  simp [restrictSupportIdeal, mem_restrictSupport_iff, Set.subset_def, sum, degree]

theorem mem_pow_idealOfVars_iff' (n : ℕ) (p : MvPolynomial σ R) :
    p ∈ idealOfVars σ R ^ n ↔ ∀ x, x.sum (fun _ => id) < n → p.coeff x = 0 := by
  grind only [mem_pow_idealOfVars_iff, mem_support_iff]

theorem monomial_mem_pow_idealOfVars_iff (n : ℕ) (x : σ →₀ ℕ) {r : R} (h : r ≠ 0) :
    monomial x r ∈ idealOfVars σ R ^ n ↔ n ≤ x.sum fun _ => id := by
  classical
  grind only [mem_pow_idealOfVars_iff, mem_support_iff, coeff_monomial]

theorem C_mem_pow_idealOfVars_iff (n r) : C r ∈ idealOfVars σ R ^ n ↔ r = 0 ∨ n = 0 := by
  by_cases h : r = 0
  · simp [h]
  simpa [h] using monomial_mem_pow_idealOfVars_iff (σ := σ) n 0 h

end idealOfVars

end MvPolynomial

namespace MonomialOrder

variable [CommSemiring R] {m : MonomialOrder σ}
open Ideal

lemma span_leadingTerm_sdiff_singleton_zero (B : Set (MvPolynomial σ R)) :
    span (m.leadingTerm '' (B \ {0})) = span (m.leadingTerm '' B) :=
  m.image_leadingTerm_sdiff_singleton_zero B ▸ Ideal.span_sdiff_singleton_zero

lemma span_leadingTerm_insert_zero (B : Set (MvPolynomial σ R)) :
    span (m.leadingTerm '' (insert 0 B)) = span (m.leadingTerm '' B) := by
  by_cases h : 0 ∈ B
  · rw [Set.insert_eq_of_mem h]
  · simp [image_leadingTerm_insert_zero]

lemma span_leadingTerm_eq_span_monomial {B : Set (MvPolynomial σ R)}
    (hB : ∀ p ∈ B, IsUnit (m.leadingCoeff p)) :
    span (m.leadingTerm '' B) =
      span ((fun p ↦ MvPolynomial.monomial (m.degree p) (1 : R)) '' B) := by
  classical
  apply le_antisymm
  all_goals
    rw [Ideal.span_le, Set.image_subset_iff]
    intro p hp
  · rw [Set.mem_preimage, SetLike.mem_coe, ← C_mul_leadingCoeff_monomial_degree]
    exact Ideal.mul_mem_left _ _ (Ideal.subset_span ⟨_, hp, rfl⟩)
  · rw [Set.mem_preimage, SetLike.mem_coe]
    convert (span <| m.leadingTerm '' B).mul_mem_left
      (MvPolynomial.C (hB p hp).unit⁻¹.val) <| subset_span ⟨p, hp, rfl⟩
    rw [← C_mul_leadingCoeff_monomial_degree, ← mul_assoc, ← map_mul,
      IsUnit.val_inv_mul, MvPolynomial.C_1, one_mul]

lemma span_leadingTerm_eq_span_monomial₀ {B : Set (MvPolynomial σ R)}
    (hB : ∀ p ∈ B, IsUnit (m.leadingCoeff p) ∨ p = 0) :
    span (m.leadingTerm '' B) =
      span ((fun p ↦ MvPolynomial.monomial (m.degree p) 1) '' (B \ {0})) := by
  rw [← m.span_leadingTerm_sdiff_singleton_zero]
  apply span_leadingTerm_eq_span_monomial
  simp_intro .. [or_iff_not_imp_right.mp (hB _ _)]

lemma span_leadingTerm_eq_span_monomial' {k : Type*} [Field k] {B : Set (MvPolynomial σ k)} :
    span (m.leadingTerm '' B) =
      span ((fun p ↦ MvPolynomial.monomial (m.degree p) 1) '' (B \ {0})) := by
  apply span_leadingTerm_eq_span_monomial₀
  simp [em']

lemma sPolynomial_mem_sup_ideal {R : Type*} [CommRing R]
    {I J : Ideal <| MvPolynomial σ R} {p q : MvPolynomial σ R}
    (hp : p ∈ I) (hq : q ∈ J) : m.sPolynomial p q ∈ I ⊔ J :=
  sub_mem (mul_mem_left _ _ (mem_sup_left hp)) (mul_mem_left _ _ (mem_sup_right hq))

lemma sPolynomial_mem_ideal {R : Type*} [CommRing R]
    {I : Ideal <| MvPolynomial σ R} {p q : MvPolynomial σ R}
    (hp : p ∈ I) (hq : q ∈ I) : m.sPolynomial p q ∈ I :=
  sub_mem (mul_mem_left I _ hp) (mul_mem_left I _ hq)

end MonomialOrder
