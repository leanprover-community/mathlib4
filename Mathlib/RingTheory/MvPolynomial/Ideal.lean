/-
Copyright (c) 2023 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser, Bingyu Xia
-/
module

public import Mathlib.Algebra.MonoidAlgebra.Ideal
public import Mathlib.Algebra.MvPolynomial.Division
public import Mathlib.RingTheory.MvPolynomial.MonomialOrder

/-!
# Lemmas about ideals of `MvPolynomial`

Notably this contains results about monomial ideals.

## Main results

* `MvPolynomial.mem_ideal_span_monomial_image`
* `MvPolynomial.mem_ideal_span_X_image`
* `MvPolynomial.mem_pow_idealOfVars_iff`

-/

@[expose] public section


variable {σ R : Type*}

namespace MvPolynomial

variable [CommSemiring R]

/-- `x` is in a monomial ideal generated by `s` iff every element of its support dominates one of
the generators. Note that `si ≤ xi` is analogous to saying that the monomial corresponding to `si`
divides the monomial corresponding to `xi`. -/
theorem mem_ideal_span_monomial_image {x : MvPolynomial σ R} {s : Set (σ →₀ ℕ)} :
    x ∈ Ideal.span ((fun s => monomial s (1 : R)) '' s) ↔ ∀ xi ∈ x.support, ∃ si ∈ s, si ≤ xi := by
  refine AddMonoidAlgebra.mem_ideal_span_of'_image.trans ?_
  simp_rw [le_iff_exists_add, add_comm]
  rfl

theorem mem_ideal_span_monomial_image_iff_dvd {x : MvPolynomial σ R} {s : Set (σ →₀ ℕ)} :
    x ∈ Ideal.span ((fun s => monomial s (1 : R)) '' s) ↔
      ∀ xi ∈ x.support, ∃ si ∈ s, monomial si 1 ∣ monomial xi (x.coeff xi) := by
  refine mem_ideal_span_monomial_image.trans (forall₂_congr fun xi hxi => ?_)
  simp_rw [monomial_dvd_monomial, one_dvd, and_true, mem_support_iff.mp hxi, false_or]

/-- `x` is in a monomial ideal generated by variables `X` iff every element of its support
has a component in `s`. -/
theorem mem_ideal_span_X_image {x : MvPolynomial σ R} {s : Set σ} :
    x ∈ Ideal.span (MvPolynomial.X '' s : Set (MvPolynomial σ R)) ↔
      ∀ m ∈ x.support, ∃ i ∈ s, (m : σ →₀ ℕ) i ≠ 0 := by
  have := @mem_ideal_span_monomial_image σ R _ x ((fun i => Finsupp.single i 1) '' s)
  rw [Set.image_image] at this
  refine this.trans ?_
  simp [Nat.one_le_iff_ne_zero]

section idealOfVars

open Finset Finsupp

variable (σ R) in
/-- The ideal spanned by all of the variables. -/
def idealOfVars : Ideal (MvPolynomial σ R) := .span (Set.range (MvPolynomial.X))

/-- The `n`th power of `idealOfVars` is spanned by all monomials of total degree `n`. -/
theorem pow_idealOfVars_eq_span (n) : idealOfVars σ R ^ n =
    Ideal.span ((fun x ↦ monomial x 1) '' {x | x.sum (fun _ => id) = n}) := by
  classical
  by_cases h' : Subsingleton R
  · trans 1
    · exact Subsingleton.eq_one _
    symm; exact Subsingleton.eq_one _
  rw [not_subsingleton_iff_nontrivial] at h'
  rw [idealOfVars, Ideal.span, Submodule.span_pow]
  congr; ext p
  simp only [Set.mem_pow_iff_prod, Set.mem_range, Set.mem_image, Set.mem_setOf_eq]
  refine ⟨fun ⟨f, h, hf⟩ => ?_, fun ⟨x, x_sum, hx⟩ => ?_⟩
  · choose i hi using h
    use ∑ j, single (i j) 1; constructor
    · simp [← Finsupp.sum_finset_sum_index]
    simp only [← hf, ← hi, monomial_sum_index, C_1, one_mul]
    rfl
  let l := x.toMultiset.toList
  have hl : n = l.length := by
    rw [Multiset.length_toList, card_toMultiset, x_sum]
  use fun i => X (l.get (Fin.cast hl i))
  simp only [List.get_eq_getElem, exists_apply_eq_apply, implies_true, true_and]
  rw [← Fintype.prod_equiv (finCongr (Eq.symm hl)) (fun i ↦ X l[i]) _ (by simp)]
  simp only [Fin.getElem_fin, Fin.prod_univ_fun_getElem, Multiset.prod_map_toList, toMultiset_map,
    prod_toMultiset, l]
  rw [prod, mapDomain_support_of_injective X_injective, ← hx, monomial_eq, C_1, one_mul, prod,
    prod_image (by simp)]
  refine prod_congr rfl (fun _ _ => ?_)
  rw [mapDomain_apply X_injective]

theorem monomial_mem_pow_idealOfVars_iff (n : ℕ) (x : σ →₀ ℕ) {r : R} (h : r ≠ 0) :
    monomial x r ∈ idealOfVars σ R ^ n ↔ n ≤ x.sum fun _ => id := by
  classical
  refine ⟨fun h' => ?_, fun h' => ?_⟩
  · rw [pow_idealOfVars_eq_span, Ideal.span, Submodule.mem_span_image_iff_exists_fun] at h'
    rcases h' with ⟨t, t_sbst, c, hc⟩
    by_contra! hx
    apply congrArg (coeff x) at hc
    simp only [univ_eq_attach, smul_eq_mul, coeff_sum, coeff_mul_monomial', mul_one, sum_ite,
      sum_const_zero, add_zero, coeff_monomial, ↓reduceIte] at hc
    have : filter (fun y => y.val ≤ x) t.attach = ∅ := by
      simp only [filter_eq_empty_iff, mem_attach, forall_const, Subtype.forall]
      intro y y_in hy
      revert hx; rw [imp_false, not_lt]
      simp only [Set.subset_def, SetLike.mem_coe, Set.mem_setOf_eq] at t_sbst
      rw [← t_sbst y y_in]
      exact sum_le_sum_index hy (by simp [Monotone]) (by simp)
    rw [this, sum_empty] at hc
    exact absurd hc.symm h
  rw [pow_idealOfVars_eq_span, mem_ideal_span_monomial_image]
  simp only [mem_support_iff, coeff_monomial, ne_eq, ite_eq_right_iff, h, imp_false,
    Decidable.not_not, Set.mem_setOf_eq, forall_eq']
  rw [← Finsupp.card_toMultiset] at h'
  obtain ⟨y, t_le, hy⟩ := Multiset.exists_le_card_eq h'
  use y.toFinsupp; constructor
  · rw [Multiset.toFinsupp_sum_eq, hy]
  simp only [Multiset.le_iff_count, count_toMultiset] at t_le
  rwa [Multiset.toFinsupp, AddEquiv.coe_mk, Equiv.coe_fn_mk, le_def, coe_mk]

theorem C_mem_pow_idealOfVars_iff (n r) : C r ∈ idealOfVars σ R ^ n ↔ r = 0 ∨ n = 0 := by
  by_cases h : r = 0
  · simp [h]
  simpa [h] using monomial_mem_pow_idealOfVars_iff (σ := σ) n 0 h

theorem mem_pow_idealOfVars_iff (n : ℕ) (p : MvPolynomial σ R) :
    p ∈ idealOfVars σ R ^ n ↔ ∀ x, x.sum (fun _ => id) < n → p.coeff x = 0 := by
  classical
  constructor
  · rw [pow_idealOfVars_eq_span]
    refine Submodule.span_induction (fun u u_in x hx ↦ ?_) ?_ (fun _ _ _ _ h h' _ hx ↦ ?_)
      (fun q r _ h s hx ↦ ?_)
    · simp only [Set.mem_image, Set.mem_setOf_eq] at u_in
      rcases u_in with ⟨v, v_sum, hv⟩
      rw [← hv, coeff_monomial, if_neg (by grind only)]
    · simp
    · rw [coeff_add, h _ hx, h' _ hx, zero_add]
    rw [smul_eq_mul, coeff_mul]
    refine sum_eq_zero (fun u u_in ↦ mul_eq_zero_of_right _ (h _ ?_))
    exact lt_of_le_of_lt (sum_le_sum_index (antidiagonal.snd_le u_in)
      (by simp [Monotone]) (by simp)) hx
  intro h; rw [as_sum p]
  refine Ideal.sum_mem _ (fun x x_in ↦ ?_)
  by_cases h' : coeff x p = 0
  · simp [h']
  rw [monomial_mem_pow_idealOfVars_iff _ _ h']
  revert h'; contrapose!
  exact h x

end idealOfVars

end MvPolynomial

namespace MonomialOrder

variable [CommSemiring R] {m : MonomialOrder σ}
open Ideal

lemma span_leadingTerm_sdiff_singleton_zero (B : Set (MvPolynomial σ R)) :
    span (m.leadingTerm '' (B \ {0})) = span (m.leadingTerm '' B) :=
  m.image_leadingTerm_sdiff_singleton_zero B ▸ Ideal.span_sdiff_singleton_zero

lemma span_leadingTerm_insert_zero (B : Set (MvPolynomial σ R)) :
    span (m.leadingTerm '' (insert 0 B)) = span (m.leadingTerm '' B) := by
  by_cases h : 0 ∈ B
  · rw [Set.insert_eq_of_mem h]
  · simp [image_leadingTerm_insert_zero]

lemma span_leadingTerm_eq_span_monomial {B : Set (MvPolynomial σ R)}
    (hB : ∀ p ∈ B, IsUnit (m.leadingCoeff p)) :
    span (m.leadingTerm '' B) =
      span ((fun p ↦ MvPolynomial.monomial (m.degree p) (1 : R)) '' B) := by
  classical
  apply le_antisymm
  all_goals
    rw [Ideal.span_le, Set.image_subset_iff]
    intro p hp
  · rw [Set.mem_preimage, SetLike.mem_coe, ← C_mul_leadingCoeff_monomial_degree]
    exact Ideal.mul_mem_left _ _ (Ideal.subset_span ⟨_, hp, rfl⟩)
  · rw [Set.mem_preimage, SetLike.mem_coe]
    convert (span <| m.leadingTerm '' B).mul_mem_left
      (MvPolynomial.C (hB p hp).unit⁻¹.val) <| subset_span ⟨p, hp, rfl⟩
    rw [← C_mul_leadingCoeff_monomial_degree, ← mul_assoc, ← map_mul,
      IsUnit.val_inv_mul, MvPolynomial.C_1, one_mul]

lemma span_leadingTerm_eq_span_monomial₀ {B : Set (MvPolynomial σ R)}
    (hB : ∀ p ∈ B, IsUnit (m.leadingCoeff p) ∨ p = 0) :
    span (m.leadingTerm '' B) =
      span ((fun p ↦ MvPolynomial.monomial (m.degree p) 1) '' (B \ {0})) := by
  rw [← m.span_leadingTerm_sdiff_singleton_zero]
  apply span_leadingTerm_eq_span_monomial
  simp_intro .. [or_iff_not_imp_right.mp (hB _ _)]

lemma span_leadingTerm_eq_span_monomial' {k : Type*} [Field k] {B : Set (MvPolynomial σ k)} :
    span (m.leadingTerm '' B) =
      span ((fun p ↦ MvPolynomial.monomial (m.degree p) 1) '' (B \ {0})) := by
  apply span_leadingTerm_eq_span_monomial₀
  simp [em']

lemma sPolynomial_mem_sup_ideal {R : Type*} [CommRing R]
    {I J : Ideal <| MvPolynomial σ R} {p q : MvPolynomial σ R}
    (hp : p ∈ I) (hq : q ∈ J) : m.sPolynomial p q ∈ I ⊔ J :=
  sub_mem (mul_mem_left _ _ (mem_sup_left hp)) (mul_mem_left _ _ (mem_sup_right hq))

lemma sPolynomial_mem_ideal {R : Type*} [CommRing R]
    {I : Ideal <| MvPolynomial σ R} {p q : MvPolynomial σ R}
    (hp : p ∈ I) (hq : q ∈ I) : m.sPolynomial p q ∈ I :=
  sub_mem (mul_mem_left I _ hp) (mul_mem_left I _ hq)

end MonomialOrder
