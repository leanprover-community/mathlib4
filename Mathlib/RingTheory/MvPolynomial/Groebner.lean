/-
Copyright (c) 2025 Junyu Guo and Hao Shen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Junyu Guo, Hao Shen
-/
module

public import Mathlib.RingTheory.MvPolynomial.Groebner.Remainder
public import Mathlib.RingTheory.Noetherian.Defs

/-! # Gröbner Basis

Definition:

* `MonomialOrder.IsGroebnerBasis m G I`: Given a monomial order `m`, a subset `G` of an ideal `I`
  is said to be a Gröbner basis if:
  (1) `G` is contained in `I` (i.e., all polynomials in `G` belong to the ideal `I`).
  (2) The ideal generated by the leading terms of all polynomials in `I` is equal to
    the ideal generated by the leading terms of the polynomials in `G`.

Buchberger criterion is proved with the following sequence of theorems, where each one is proved
(directly or indirectly) with some of theorems before it:

* `MonomialOrder.remainder_eq_zero_iff_mem_ideal_of_isGroebnerBasis`: Given a remainder of a
  polynomial on division by a Gröbner basis of an ideal, the remainder is 0 if and only if the
  polynomial is in the ideal.

* `MonomialOrder.isRemainder_zero_iff_mem_ideal_of_isGroebnerBasis`: Given a Gröbner basis of an
  ideal, 0 is a remainder of a polynomial on division by the Gröbner basis if and only if the
  polynomial is in the ideal `I`.

* `MonomialOrder.ideal_eq_span_of_isGroebnerBasis`: Gröbner basis of any ideal spans the ideal.

* `MonomialOrder.isGroebnerBasis_iff_subset_ideal_and_isRemainder_zero`: A set of polynomials is a
  Gröbner basis of an ideal if and only if it is a subset of this ideal and 0 is a remainder of
  each member of this ideal on division by this set.

* `MonomialOrder.isGroebnerBasis_iff_isRemainder_sPolynomial_zero` (Buchberger Criterion): a basis
  of an ideal is a Gröbner basis of it if and only if 0 is a remainder of echo sPolynomial between
  two polynomials on the basis.

Other main theroems:

* `MonomialOrder.existsUnique_isRemainder_of_isGroebnerBasis`: Remainder of any polynomial on
  division by a Gröbner basis exists and is unique.

* `MonomialOrder.exists_isGroebnerBasis_finite`: Finite Gröbner basis exists for any ideal of a
noetherian multivariate polynomial ring.

## Naming convention

Some theorems with an argument in type `Set (MvPolynomial σ R)` have 3 variants, named as following
respectively:

* without suffix `'` or `₀`: leading coefficients of all polynomials in the set are non-zero
  divisors `· ∈ nonZeroDivisors (MvPolynomial σ R)` (or invertible `IsUnit ·`, depending on the
  theorem);
* with suffix `₀`: leading coefficients of echo polynomial in the set is non-zero divisors (or
  invertible) or 0 `· = 0`;
* with suffix `'`: no hypotheses on leading coefficients, while requiring `R` be a ring with no zero
  divisors `NoZeroDivisors R` (or be a field `Field k`, where the ring is denoted as `k`).

## Reference : [Cox2015]

-/

@[expose] public section

namespace MonomialOrder

open MvPolynomial

open scoped MonomialOrder

section CommSemiring
variable {σ : Type*} (m : MonomialOrder σ)

variable {R : Type*} [CommSemiring R]
variable (f p : MvPolynomial σ R) (B : Set (MvPolynomial σ R)) (r : MvPolynomial σ R)

/-- A subset `G` of an ideal `I` is said to be a Gröbner basis if:

1. `G` is contained in `I` (i.e., all polynomials in `G` belong to the ideal `I`).
2. The ideal generated by the leading terms of all polynomials in `I` is equal to
   the ideal generated by the leading terms of the polynomials in `G`.
-/
def IsGroebnerBasis {R : Type*} [CommSemiring R] (G : Set (MvPolynomial σ R))
    (I : Ideal (MvPolynomial σ R)) :=
  G ⊆ I ∧ Ideal.span (m.leadingTerm '' ↑I) = Ideal.span (m.leadingTerm '' G)

@[simp]
lemma isGroebnerBasis_self (I : Ideal (MvPolynomial σ R)) :
    m.IsGroebnerBasis I I := by
  simp [IsGroebnerBasis]

@[simp]
lemma isGroebnerBasis_sdiff_singleton_zero (G : Set (MvPolynomial σ R))
    (I : Ideal (MvPolynomial σ R)) :
    m.IsGroebnerBasis (G \ {0}) I ↔ m.IsGroebnerBasis G I := by
  simp [IsGroebnerBasis, m.span_leadingTerm_sdiff_singleton_zero]

@[simp]
lemma isGroebnerBasis_insert_zero (G : Set (MvPolynomial σ R))
    (I : Ideal (MvPolynomial σ R)) :
    m.IsGroebnerBasis (insert 0 G) I ↔ m.IsGroebnerBasis G I := by
  unfold IsGroebnerBasis
  congr! 1
  · constructor
    · intro h x hx
      apply h
      simp [hx]
    · simp [Set.insert_subset_iff]
  · simp [m.span_leadingTerm_insert_zero]

/-- Finite Gröbner basis exists for any ideal of a noetherian multivariate polynomial ring. -/
theorem exists_isGroebnerBasis_finite [inst : IsNoetherianRing (MvPolynomial σ R)]
    (I : Ideal (MvPolynomial σ R)) :
    ∃ G : Set (MvPolynomial σ R), m.IsGroebnerBasis G ↑I ∧ G.Finite := by
  -- todo: Ideal.fg_span_iff_fg_span_finset_subset
  have key := (Submodule.fg_span_iff_fg_span_finset_subset _).mp <|
    inst.noetherian <| Ideal.span <| m.leadingTerm '' ↑I
  simp only [Set.subset_image_iff] at key
  rcases key with ⟨s, ⟨G', hG'I, hG's⟩, hIs⟩
  have ⟨G, hG, hG₁⟩ := hG's ▸ Set.exists_subset_bijOn G' m.leadingTerm
  use G
  split_ands
  · exact subset_trans hG hG'I
  · rwa [hG₁.image_eq]
  · simp [Set.BijOn.finite_iff_finite hG₁]

end CommSemiring

section CommRing

variable {σ : Type*} {m : MonomialOrder σ} {R : Type*} [CommRing R]

/-- Given a remainder `r` of a polynomial `p` on division by a Gröbner basis `G` of an ideal `I`,
the remainder `r` is 0 if and only if `p` is in the ideal `I`.

Any leading coefficient of polynomial in the Gröbner basis `G` is required to be a unit. -/
theorem remainder_eq_zero_iff_mem_ideal_of_isGroebnerBasis
    {p : MvPolynomial σ R} {G : Set (MvPolynomial σ R)} {I : Ideal (MvPolynomial σ R)}
    {r : MvPolynomial σ R} (hG : ∀ g ∈ G, IsUnit (m.leadingCoeff g)) (h : m.IsGroebnerBasis G I)
    (hr : m.IsRemainder p G r) :
    r = 0 ↔ p ∈ I := by
  constructor
  · rw [← m.mem_ideal_iff_of_isRemainder h.1 hr]
    simp_intro ..
  intro h_p_mem
  rcases h with ⟨h_G', h_span⟩
  have ⟨⟨q, h_p_eq_sum_r, h_r_reduced⟩, h_degree⟩ := hr
  rw [h_p_eq_sum_r, Ideal.add_mem_iff_right] at h_p_mem
  on_goal 2 =>
    exact Ideal.span_le.mpr h_G' <| (Finsupp.mem_span_iff_linearCombination ..).mpr ⟨_, rfl⟩
  apply Set.mem_image_of_mem m.leadingTerm at h_p_mem
  -- todo: Ideal.mem_span_of_mem
  apply Submodule.mem_span_of_mem (R := MvPolynomial σ R) at h_p_mem
  contrapose! h_p_mem with h_r_ne_zero
  simpa [h_span] using term_notMem_span_leadingTerm_of_isRemainder hG hr _ (by simp [h_r_ne_zero])

/-- Given a remainder `r` of a polynomial `p` on division by a Gröbner basis `G` of an ideal `I`,
the remainder `r` is 0 if and only if `p` is in the ideal `I`.

It is a variant of `MonomialOrder.remainder_eq_zero_iff_mem_ideal_of_isGroebnerBasis`, allowing the
Gröbner basis to contain also 0, besides polynomials with invertible leading coefficients. -/
theorem remainder_eq_zero_iff_mem_ideal_of_isGroebnerBasis₀ {p : MvPolynomial σ R}
    {G : Set (MvPolynomial σ R)} {I : Ideal (MvPolynomial σ R)} {r : MvPolynomial σ R}
    (hG : ∀ g ∈ G, IsUnit (m.leadingCoeff g) ∨ g = 0) (h : m.IsGroebnerBasis G I)
    (hr : m.IsRemainder p G r) :
    r = 0 ↔ p ∈ I := by
  rw [← m.isGroebnerBasis_sdiff_singleton_zero] at h
  rw [← m.isRemainder_sdiff_singleton_zero_iff_isRemainder] at hr
  refine m.remainder_eq_zero_iff_mem_ideal_of_isGroebnerBasis ?_ h hr
  simp_intro .. [or_iff_not_imp_right.mp (hG _ _)]

/-- Given a Gröbner basis `G` of an ideal `I`, 0 is a remainder on division by `G` if and
only if `p` is in the ideal `I`.
-/
theorem isRemainder_zero_iff_mem_ideal_of_isGroebnerBasis {p : MvPolynomial σ R}
    {G : Set (MvPolynomial σ R)} {I : Ideal (MvPolynomial σ R)}
    (hG : ∀ g ∈ G, IsUnit (m.leadingCoeff g))
    (h : m.IsGroebnerBasis G I) :
    m.IsRemainder p G 0 ↔ p ∈ I := by
  constructor
  · intro hr
    apply (remainder_eq_zero_iff_mem_ideal_of_isGroebnerBasis hG h hr).mp rfl
  · intro hp
    obtain ⟨r, hr⟩ := m.exists_isRemainder₀ (fun g a ↦ Or.symm (Or.inr (hG g a))) p
    rwa [(remainder_eq_zero_iff_mem_ideal_of_isGroebnerBasis hG h hr).mpr hp] at hr

lemma isRemainder_zero_iff_mem_ideal_of_isGroebnerBasis₀ {p : MvPolynomial σ R}
    {G : Set (MvPolynomial σ R)} {I : Ideal (MvPolynomial σ R)}
    (hG : ∀ g ∈ G, IsUnit (m.leadingCoeff g) ∨ g = 0)
    (h : m.IsGroebnerBasis G I) :
    m.IsRemainder p G 0 ↔ p ∈ I := by
  rw [← m.isGroebnerBasis_sdiff_singleton_zero] at h
  rw [← m.isRemainder_sdiff_singleton_zero_iff_isRemainder]
  refine m.isRemainder_zero_iff_mem_ideal_of_isGroebnerBasis ?_ h
  simp_intro a b [or_iff_not_imp_right.mp (hG _ _)]

/-- Gröbner basis of any ideal spans the ideal. -/
theorem ideal_eq_span_of_isGroebnerBasis {G : Set (MvPolynomial σ R)} {I : Ideal (MvPolynomial σ R)}
    (hG : ∀ g ∈ G, IsUnit (m.leadingCoeff g)) (h : m.IsGroebnerBasis G I) :
    I = Ideal.span G := by
  apply le_antisymm
  · intro p hp
    rw [← isRemainder_zero_iff_mem_ideal_of_isGroebnerBasis hG h] at hp
    obtain ⟨⟨f, h_eq, h_deg⟩, h_remain⟩ := hp
    rw [h_eq, Finsupp.linearCombination_apply, add_zero]
    apply Ideal.sum_mem
    intro g hg
    rcases g with ⟨g, gG'⟩
    exact Ideal.mul_mem_left _ _ (Ideal.subset_span gG')
  · intro p hp
    suffices Ideal.span ↑G ≤ I from this hp
    apply Ideal.span_le.mpr
    intro p hp'
    exact h.1 hp'

theorem isGroebnerBasis_iff_ideal_eq_span_and_isGroebnerBasis_span (G : Set (MvPolynomial σ R))
    (I : Ideal (MvPolynomial σ R)) (hG : ∀ g ∈ G, IsUnit (m.leadingCoeff g)) :
    m.IsGroebnerBasis G I ↔ (I = Ideal.span G ∧ m.IsGroebnerBasis G (Ideal.span G)) := by
  constructor
  · intro this
    simpa [ideal_eq_span_of_isGroebnerBasis hG this]
  · simp_intro ..

theorem isGroebnerBasis_iff_span_eq_and_degree_le (G : Set (MvPolynomial σ R))
    (I : Ideal (MvPolynomial σ R)) (hG : ∀ g ∈ G, IsUnit (m.leadingCoeff g)) :
    m.IsGroebnerBasis G I ↔
      Ideal.span G = I ∧ ∀ p ∈ I, p ≠ 0 → ∃ g ∈ G, m.degree g ≤ m.degree p := by
  classical
  constructor
  · intro h
    exists (m.ideal_eq_span_of_isGroebnerBasis hG h).symm
    intro p hp hp0
    apply m.exists_degree_le_degree_of_isRemainder_zero _ hp0 ↑G
      (by simp_intro .. [(hG _ _).mem_nonZeroDivisors])
    exact (m.isRemainder_zero_iff_mem_ideal_of_isGroebnerBasis hG h).mpr hp
  rintro ⟨hG', h_degree⟩
  constructor
  · exact hG' ▸ Submodule.subset_span
  rw [← hG']
  apply le_antisymm
  · apply Ideal.span_le.mpr
    intro p' hp
    rcases hp with ⟨p, hp', hp'₁⟩
    rw [hG'] at hp'
    rw [←hp'₁, leadingTerm, SetLike.mem_coe,
      m.span_leadingTerm_eq_span_monomial (by simp_intro .. [hG]),
      ← Set.image_image (monomial · 1) _ _, mem_ideal_span_monomial_image]
    intro j hj
    specialize h_degree p
    simp_all [MonomialOrder.leadingCoeff_eq_zero_iff]
  · rw [hG']
    apply Ideal.span_mono
    exact Set.image_mono (hG' ▸ Submodule.subset_span)

/-- A set of polynomials is a Gröbner basis of an ideal if and only if it is a subset of this ideal
and 0 is a remainder of each member of this ideal on division by this set.

Any leading coefficient of polynomial in the set is required to be a unit. -/
theorem isGroebnerBasis_iff_subset_ideal_and_isRemainder_zero
    (G : Set (MvPolynomial σ R)) (I : Ideal (MvPolynomial σ R))
    (hG : ∀ g ∈ G, IsUnit (m.leadingCoeff g)) :
    m.IsGroebnerBasis G I ↔ G ⊆ I ∧ ∀ p ∈ I, m.IsRemainder p G 0 := by
  constructor
  · intro h
    exists h.1
    intro p h_p_in_I
    rwa [isRemainder_zero_iff_mem_ideal_of_isGroebnerBasis hG h]
  · intro h
    rcases h with ⟨h_G, h_remainder⟩
    rw [m.isGroebnerBasis_iff_span_eq_and_degree_le G I hG]
    constructor
    · apply le_antisymm (Ideal.span_le.mpr h_G)
      intro p hp
      specialize h_remainder p hp
      exact m.mem_ideal_of_isRemainder_of_mem_ideal Ideal.subset_span h_remainder (Ideal.zero_mem _)
    · intro p hp hp0
      exact m.exists_degree_le_degree_of_isRemainder_zero p hp0 G
        (by simp_intro .. [(hG _ _).mem_nonZeroDivisors]) (h_remainder p hp)

/-- A set of polynomials is a Gröbner basis of an ideal if and only if it is a subset of this ideal
and 0 is a remainder of each member of this ideal on division by this set.

It is a variant of `MonomialOrder.isGroebnerBasis_iff_subset_ideal_and_isRemainder_zero`, allowing
the set to contain also 0, besides polynomials with invertible leading coefficients. -/
theorem isGroebnerBasis_iff_subset_ideal_and_isRemainder_zero₀ (G : Set (MvPolynomial σ R))
    (I : Ideal (MvPolynomial σ R)) (hG : ∀ g ∈ G, IsUnit (m.leadingCoeff g) ∨ g = 0) :
    m.IsGroebnerBasis G I ↔ G ⊆ I ∧ ∀ p ∈ I, m.IsRemainder p G 0 := by
  rw [← m.isGroebnerBasis_sdiff_singleton_zero]
  convert m.isGroebnerBasis_iff_subset_ideal_and_isRemainder_zero (G \ {0}) I _ using 2
  · simp
  · simp [m.isRemainder_sdiff_singleton_zero_iff_isRemainder]
  · simp_intro .. [or_iff_not_imp_right.mp (hG _ _)]

theorem span_leadingTerm_eq_span_monomial_of_isGroebnerBasis {G : Set (MvPolynomial σ R)}
    {I : Ideal (MvPolynomial σ R)}
    (h : m.IsGroebnerBasis G I) (hG : ∀ g ∈ G, IsUnit (m.leadingCoeff g)) :
    Ideal.span (m.leadingTerm '' ↑G) =
    Ideal.span ((fun p ↦ monomial (m.degree p) (1 : R)) '' (I \ {(0 : MvPolynomial σ R)})) := by
  classical
  wlog hR : Nontrivial R
  · rw [not_nontrivial_iff_subsingleton] at hR
    exact ((Submodule.subsingleton_iff _).mpr inferInstance).elim _ _
  rw [m.span_leadingTerm_eq_span_monomial (B := (↑G : Set (MvPolynomial σ R))) hG]
  apply le_antisymm
  · rw [Ideal.span_le]
    refine subset_trans ?_ Submodule.subset_span
    apply Set.image_mono
    apply Set.subset_diff_singleton h.1
    contrapose! hG
    use 0
    simpa
  · rw [Ideal.span_le]
    intro x
    simp? says
      simp only [Set.mem_image, Set.mem_diff, SetLike.mem_coe, Set.mem_singleton_iff, ne_eq,
        forall_exists_index, and_imp]
    intro y hy hy0 hxy
    rw [← hxy, ← Set.image_image (monomial · 1) _ _, mem_ideal_span_monomial_image]
    simpa using ((m.isGroebnerBasis_iff_span_eq_and_degree_le _ _ hG).mp h).2 y hy hy0

theorem span_leadingTerm_eq_span_monomial_of_isGroebnerBasis₀ {G : Set (MvPolynomial σ R)}
    {I : Ideal (MvPolynomial σ R)}
    (h : m.IsGroebnerBasis G I) (hG : ∀ g ∈ G, IsUnit (m.leadingCoeff g) ∨ g = 0) :
    Ideal.span (m.leadingTerm '' ↑G) =
    Ideal.span ((fun p ↦ monomial (m.degree p) (1 : R)) '' (I \ {(0 : MvPolynomial σ R)})) := by
  rw [← m.isGroebnerBasis_sdiff_singleton_zero] at h
  convert m.span_leadingTerm_eq_span_monomial_of_isGroebnerBasis h _ using 1
  · simp [m.image_leadingTerm_sdiff_singleton_zero]
  · simp_intro .. [or_iff_not_imp_right.mp (hG _ _)]

/-- Remainder of any polynomial on division by a Gröbner basis exists and is unique.

Any leading coefficient of polynomial in the Gröbner basis is required to be a unit. -/
theorem existsUnique_isRemainder_of_isGroebnerBasis {G : Set (MvPolynomial σ R)}
    {I : Ideal (MvPolynomial σ R)}
    (h : m.IsGroebnerBasis G I) (hG : ∀ g ∈ G, IsUnit (m.leadingCoeff g)) (p : MvPolynomial σ R) :
    ∃! (r : MvPolynomial σ R), m.IsRemainder p G r := by
  apply existsUnique_of_exists_of_unique (m.exists_isRemainder hG p)
  intro r₁ r₂ hr₁ hr₂
  rw [← sub_eq_zero]
  by_contra! hrne0
  have hr := (m.degree_mem_support_iff _).mpr hrne0
  apply m.sub_monomial_notMem_span_leadingTerm_of_isRemainder (B := ↑G) hG hr₁ hr₂ at hr
  rw [m.span_leadingTerm_eq_span_monomial_of_isGroebnerBasis h hG] at hr
  apply hr
  apply Submodule.mem_span_of_mem
  apply Set.mem_image_of_mem
  simpa [hrne0] using m.sub_mem_ideal_of_isRemainder_of_subset_ideal h.1 hr₁ hr₂

/-- Remainder of any polynomial on division by a Gröbner basis exists and is unique.

It is a variant of `MonomialOrder.existsUnique_isRemainder_of_isGroebnerBasis`, allowing the
Gröbner basis to contain also 0, besides polynomials with invertible leading coefficients. -/
theorem existsUnique_isRemainder_of_isGroebnerBasis₀ {G : Set (MvPolynomial σ R)}
    {I : Ideal (MvPolynomial σ R)}
    (h : m.IsGroebnerBasis G I) (hG : ∀ g ∈ G, IsUnit (m.leadingCoeff g) ∨ g = 0)
    (p : MvPolynomial σ R) :
    ∃! (r : MvPolynomial σ R), m.IsRemainder p G r := by
  rw [← m.isGroebnerBasis_sdiff_singleton_zero] at h
  simp_rw [← m.isRemainder_sdiff_singleton_zero_iff_isRemainder p G]
  convert m.existsUnique_isRemainder_of_isGroebnerBasis h _ p
  simp_intro .. [or_iff_not_imp_right.mp (hG _ _)]

end CommRing

section Field

variable {k : Type*} [Field k] {σ : Type*} {m : MonomialOrder σ}

/-- Given a remainder `r` of a polynomial `p` on division by a Gröbner basis `G` of an ideal `I`,
the remainder `r` is 0 if and only if `p` is in the ideal `I`.

It is a variant of `MonomialOrder.remainder_eq_zero_iff_mem_ideal_of_isGroebnerBasis`, over a field
and without hypothesis on leading coefficients in the Gröbner basis. -/
theorem remainder_eq_zero_iff_mem_ideal_of_isGroebnerBasis' {p : MvPolynomial σ k}
    {G : Set (MvPolynomial σ k)} {I : Ideal (MvPolynomial σ k)}
    {r : MvPolynomial σ k}
    (h : m.IsGroebnerBasis G I)
    (hr : m.IsRemainder p G r) :
    r = 0 ↔ p ∈ I := by
  refine remainder_eq_zero_iff_mem_ideal_of_isGroebnerBasis₀ ?_ h hr
  simp [em']

lemma isRemainder_zero_iff_mem_ideal_of_isGroebnerBasis' {p : MvPolynomial σ k}
    {G : Set (MvPolynomial σ k)} {I : Ideal (MvPolynomial σ k)}
    (h : m.IsGroebnerBasis G I) :
    m.IsRemainder p G 0 ↔ p ∈ I := by
  refine m.isRemainder_zero_iff_mem_ideal_of_isGroebnerBasis₀ ?_ h
  simp [em']

/-- A set of polynomials is a Gröbner basis of an ideal if and only if it is a subset of this ideal
and 0 is a remainder of each member of this ideal on division by this set.

It is a variant of `MonomialOrder.isGroebnerBasis_iff_subset_ideal_and_isRemainder_zero`,
over a field and without hypothesis on leading coefficients in the set. -/
theorem isGroebnerBasis_iff_subset_ideal_and_isRemainder_zero'
    (G : Set (MvPolynomial σ k)) (I : Ideal (MvPolynomial σ k)) :
    m.IsGroebnerBasis G I ↔ G ⊆ I ∧ ∀ p ∈ I, m.IsRemainder p G 0 :=
  m.isGroebnerBasis_iff_subset_ideal_and_isRemainder_zero₀ G I (by simp [em'])

/-- Buchberger Criterion: a basis of an ideal is a Gröbner basis of it if and only if 0 is a
remainder of echo sPolynomial between two polynomials on the basis. -/
theorem isGroebnerBasis_iff_isRemainder_sPolynomial_zero (G : Set (MvPolynomial σ k)) :
    m.IsGroebnerBasis G (Ideal.span G) ↔
    ∀ (g₁ g₂ : G), m.IsRemainder (m.sPolynomial g₁ g₂ : MvPolynomial σ k) G 0 := by
  /- The informal proof is attached in comment blocks (`/- -/`), where math expressions are written
  in `$ $` or `$$ $$` like in LaTeX or Markdown, while we tend to use unicode symbols like Lean code
  instead of LaTeX commands are used for readability. And every block roughly corresponds with codes
  below it and above the next comment block (if it exists). And inline comments are technical
  details in formalization. -/
  classical
  constructor
  · /- (←) Easy to prove. -/
    intro h g₁ g₂
    rw [m.isGroebnerBasis_iff_subset_ideal_and_isRemainder_zero'] at h
    apply h.2
    apply m.sPolynomial_mem_ideal <;> exact Set.mem_of_mem_of_subset (by simp) h.1
  /- (→)
  We only need to prove for all $p ∈ ⟨G⟩$ (`p ∈ Ideal.span G`),
  $0$ is a remainder of $p$ on division by $G$ (`m.IsRemainder p G 0`), i.e.
  to prove that these exists finite subset $G'$ of $G$ and $f$
  s.t. $p = ∑_{g ∈ G'} f(g) * g$ and $∀ g ∈ G', degree(f(g) * g) ≤ degree(p)$. -/
  intro hsPoly
  rw [isGroebnerBasis_iff_subset_ideal_and_isRemainder_zero']
  exists Ideal.subset_span
  intro p hp
  simp_rw [isRemainder_def'', add_zero]
  refine ⟨?_, by simp⟩
  -- todo: Ideal.mem_span_iff_exists_finset_subset
  apply Submodule.mem_span_iff_exists_finset_subset.mp at hp
  /- From $p ∈ ⟨G⟩$, we get immediately that all condition we needed above except for
  $∀ g ∈ G', degree(f(g) * g) ≤ degree(p)$.
  We assume it doesn't hold, i.e. $max_{g ∈ G'} degree(f(g) * g) > degree(p)$. -/
  obtain ⟨f₀, G'₀, hG', ⟨hG'subsetG, hsumf⟩⟩ := hp
  by_cases! h : G'₀.sup (fun g ↦ (m.toSyn <| m.degree <| g * (f₀ g))) ≤ m.toSyn (m.degree p)
  · exact ⟨f₀, G'₀, hG', hsumf.symm, by simpa using h⟩
  /- We have now $P(max_{g ∈ G'} degree(f(g) * g))$ where
  $P(a) : ∃ finite G' ⊆ G and f, p = ∑ g ∈ G', f(g) * g ∧ ∀ g ∈ G', degree(f(g) * g) ≤ a$,
  and we will prove an assertion that, for each $a > degree(p)$, if $P(a)$, then there exists
  $degree(g) ≤ a' < a$ s.t. $P(a')$ also holds. With this assertion, we can get $P(degree(p))$ by
  well-founded induction on $a$. -/
  refine WellFounded.induction_bot (WellFoundedLT.toWellFoundedRelation.wf)
    (a := G'₀.sup fun g ↦ (m.toSyn <| m.degree <| g * (f₀ g))) (bot := m.toSyn (m.degree p))
    (C := fun a ↦ m.toSyn (m.degree p) ≤ a ∧
      ∃ (f : MvPolynomial σ k → MvPolynomial σ k) (G' : Finset (MvPolynomial σ k)),
        ↑G' ⊆ G ∧
        p = ∑ g ∈ G', (f g) * g ∧
        ∀ g ∈ G', (m.toSyn <| m.degree <| g * f g) ≤ a)
    (fun a ha ⟨ha', ⟨f, G', hG'subsetG, hsumf, h_deg_le⟩⟩ ↦ ?_)
    ⟨le_of_lt h, ⟨f₀, G'₀, hG', hsumf.symm, by apply Finset.le_sup⟩⟩ |>.2
  /- We start to prove the assertion. Assume $a > degree(p)$ (`ha`), $G' ⊆ G$ (`hG'subsetG`),
  $f$ (`f`) s.t. $p = ∑ g ∈ G', f(g) g$ (`hsumf`), and
  $∀ g ∈ G', degree(f(g) g) ≤ a$ (`h_deg_le`).
  Without loss of generality, we can assume $f(g)$ vanishes when $g ∉ G'$.  -/
  clear! f₀ G'₀
  wlog hf₀support : ∀ g, g ∉ G' → f g = 0 generalizing f
  · specialize this (fun g ↦ if g ∈ G' then f g else 0); simp_all
  apply lt_of_le_of_ne' ha' at ha
  /- Let $lt'(g) := leadingTerm(g) if degree(f(g) * g) = a, or else 0$ (`lt'`).
  $$ p = ∑ g ∈ G', f(g) * g
       = ∑ g ∈ G' with (degree(f(g) * g) = a), leadingTerm(f(g)) * g +
        ∑ g ∈ G', (f(g) - lt'(g)) * g.$$ (`hp`) -/
  let degFgEqA g := (m.toSyn <| m.degree <| f g * g) = a
  let lt' g := if degFgEqA g then m.leadingTerm (f g) else 0
  have hp := calc
    p = ∑ g ∈ G', f g * g := hsumf
    _ = ∑ g ∈ G' with degFgEqA g, m.leadingTerm (f g) * g +
        ∑ g ∈ G', (f g - lt' g) * g := by
      simp [← Finset.sum_add_distrib, ← add_mul, ← ite_zero_mul, Finset.sum_filter, -ite_mul, lt']
  /- For any $g ∈ G'$, it can be easily seen that $degree (f(g) - lt'(g)) g$ is either less than $a$
  or equal to $0$, so $degree( (f(g) - lt'(g)) * g ) < a$, and $∑ g ∈ G', (f(g) - lt'(g)) * g < a$.
  Since $$degree( ∑ g ∈ G' with (degree(f(g) * g) = a), leadingTerm(f(g)) * g +
      ∑ g ∈ G', (f(g) - lt'(g)) * g )
    = degree(p) < a,$$
  we can obtain $degree( ∑ g ∈ G' with (degree(f(g) * g) = a), leadingTerm(f(g)) * g ) < a$.
  Obviously, for all $g ∈ G'$ s.t. $degree(f(g) g) = a$, $degree(leadingTerm(f(g)) g))$ is also $a$.
  So this sum can be decomposed into a sum of S-polynomials: there exists $c(g₁, g₂) ∈ k$ (`c`)
  for each $g₁, g₂ ∈ {g ∈ G' | degree(f(g) * g) = a}$, s.t.
  $$∑ g ∈ G' with (degree(f(g) * g) = a), leadingTerm(f(g)) * g
    = ∑ g₁, g₂ ∈ \{g ∈ G' | degree(f(g) * g) = a\},
          c(g₁, g₂) * sPoly(leadingTerm(f(g₁)) g₁, leadingTerm(f(g₂)) g₂)
    = ∑ g₁, g₂ ∈ \{g ∈ G' | degree(f(g) * g) = a\},
          c(g₁, g₂) * leadingCoeff(g₁ g₂) *
            (lcm(lm(f(g₁) * g₁), lm(f(g₂) * g₂)) / lcm(lm(g₁), lm(g₂))) *
          sPoly(g₁, g₂),$$ (`h_sum_sPoly`)
  where $lm(g)$ is leading monomial of $g$ ($x^degree(g)$ if we ignore edge case that $g = 0$),
  and $lcm(lm(g₁), lm(g₂))$ is least common multiple of $lm(g₁)$ and $lm(g₂)$.
  Formalization of $lcm$ is mainly based on operations on `Finsupp` instead of `MvPolynomial`.
  (For more formalization details, see the docstring of `MonomialOrder.sPolynomial`.) -/
  have h_a_gt_zero : 0 < a := bot_lt_of_lt ha
  obtain ⟨c, h_sum_sPoly⟩ := m.sPolynomial_decomposition' (d := a) (B := G'.filter degFgEqA)
    (fun g ↦ m.leadingTerm (f g) * g) (by simp_intro .. [degFgEqA, Finset.mem_filter]) <| by
      simp only [← sub_eq_iff_eq_add.mpr hp]
      apply lt_of_le_of_lt m.degree_sub_le
      simp? [ha] says simp only [sup_lt_iff, ha, true_and]
      apply lt_of_le_of_lt m.degree_sum_le
      simp only [Finset.sup_lt_iff h_a_gt_zero, lt']
      intro g hg
      wlog h : degFgEqA g
      · simpa [h] using lt_of_le_of_ne (mul_comm g _ ▸ h_deg_le g hg) h
      simp? [h] says simp only [h, ↓reduceIte]
      wlog! +distrib h' : f g - m.leadingTerm (f g) ≠ 0 ∧ g ≠ 0
      · obtain h' | h' := h' <;> simp [h_a_gt_zero, h']
      apply lt_of_le_of_lt' (h_deg_le g hg)
      rw [mul_comm g, m.degree_mul_lt_iff_left_lt_of_ne_zero h'.1 h'.2]
      exact m.degree_sub_leadingTerm_lt_degree (m.degree_ne_zero_of_sub_leadingTerm_ne_zero h'.1)
  conv at h_sum_sPoly =>
    rhs
    simp only [m.sPolynomial_mul_leadingTerm', ← G'.filter degFgEqA |>.sum_coe_sort]
  /- For echo $g₁, g₂ ∈ G$, $0$ is a remainder of $sPoly(g₁, g₂)$ on division
  by G, and thus we obtain its "quotient" in form of a finitely supported function $q_{g₁, g₂}$
  s.t. it satisfies the following conditions (`hq`):
    - $supp(q_{g₁, g₂}) ⊆ G$ (`h_q_support_subset_G`),
    - $sPoly(g₁, g₂) = ∑ g ∈ G, q_{g₁, g₂}(g) * g$,
    - $∀ g ∈ G, degree(q_{g₁, g₂}(g) * g) ≤ degree(sPoly(g₁, g₂))$, and
    - if $sPoly(g₁, g₂) = 0$ then $q_{g₁, g₂} = 0$. -/
  simp? [isRemainder_def'₁, -Subtype.forall] at hsPoly says
    simp only [isRemainder_def'₁, add_zero, support_zero, Finset.notMem_empty, ne_eq,
      IsEmpty.forall_iff, implies_true, and_true] at hsPoly
  replace hsPoly (g₁ g₂ : G'.filter degFgEqA) :=
    hsPoly ⟨g₁, hG'subsetG <| G'.mem_of_mem_filter _ g₁.2⟩
      ⟨g₂, hG'subsetG <| G'.mem_of_mem_filter _ g₂.2⟩
  let q (g₁ g₂ : G'.filter degFgEqA) := (hsPoly g₁ g₂).choose
  have hq (g₁ g₂ : G'.filter degFgEqA) := (hsPoly g₁ g₂).choose_spec
  -- I'd like to get rid of `.choose` in following formalization.
  simp_rw [show _ = q _ _ by unfold q; rfl] at hq
  -- TODO: a variant of `generalize` tactic that can replace with arguments
  clear_value q -- clear its value to ensure we will not use it (optional)
  have h_q_support_subset_G (g₁ g₂) := (hq g₁ g₂).1
  /- Let $G''$ be $G' ∪ (∪ g₁, g₂ ∈ \{g ∈ G' | degree(f(g) * g) = a\}, supp(q_{g₁, g₂})).$
  Obviously, $G''$ is a finite subset of $G$, and
  $support(q_{g₁, g₂}) ⊆ G''$ for all $g₁, g₂ ∈ \{g ∈ G' | degree(f(g) * g) = a\}$.
  Then for all $g₁, g₂ ∈ \{g ∈ G' | degree(f(g) * g) = a\}$,
  $sPoly(g₁, g₂) = ∑ g ∈ G'', q_{g₁, g₂}(g) * g$. -/
  let G'' : Finset (MvPolynomial σ k) := G' ∪
    (G'.filter degFgEqA).attach.biUnion fun b₁ ↦
      (G'.filter degFgEqA).attach.biUnion fun b₂ ↦ (q b₁ b₂).support
  conv at hq =>
    ext g₁ g₂
    simp [Finsupp.linearCombination_apply_of_mem_supported
        (l := (q g₁ g₂)) (s := G'')
        (hs := by
          simp? [Finsupp.mem_supported, G''] says
            simp only [Finset.coe_union, Finset.coe_biUnion, Finset.coe_attach, Set.mem_univ,
              Set.iUnion_true, Finsupp.mem_supported, G'']
          apply Set.subset_union_of_subset_right
          exact Set.subset_iUnion₂_of_subset g₁ g₂ subset_rfl)]
  /- Substituting them into our decomposition by S-polynomials, we have:
  $$∑ g ∈ G' with (degree(f(g) * g) = a), leadingTerm(f(g)) * g
    = ∑ g₁, g₂ ∈ \{g ∈ G' | degree(f(g) * g) = a\},
        c(g₁, g₂) * leadingCoeff(g₁) * leadingCoeff(g₂) *
          (lcm(lm(f(g₁) * g₁), lm(f(g₂) * g₂)) / lcm(lm(g₁), lm(g₂))) * sPoly(g₁, g₂).$$

  For simplify we denote $c(g₁, g₂) * leadingCoeff(g₁) * leadingCoeff(g₂)$ as $c'$. Then
  $$∑ g ∈ G' with (degree(f(g) * g) = a), leadingTerm(f(g)) * g
    = ∑ g₁, g₂ ∈ \{g ∈ G' | degree(f(g) * g) = a\},
        c'(g₁, g₂)•(lcm(lm(f(g₁) * g₁), lm(f(g₂) * g₂)) / lcm(lm(g₁), lm(g₂))) *
        ∑ g ∈ G'', q_{g₁, g₂}(g) * g
    = ∑ g ∈ G'',
        (∑ g₁, g₂ ∈ \{g ∈ G' | degree(f(g) * g) = a\},
          c'(g₁, g₂)•(lcm(lm(f(g₁) * g₁), lm(f(g₂) * g₂)) / lcm(lm(g₁), lm(g₂))) * q_{g₁, g₂}(g)) *
        g. $$ (`h_sum_sPoly`)

  Note: degree(s) of $(f(g) - lt'(g)) * g$ and
    $c'(g₁, g₂)•(lcm(lm(f(g₁) * g₁), lm(f(g₂) * g₂)) / lcm(lm(g₁), lm(g₂))) * q_{g₁, g₂} * g$ are
    both less than $a$. It is a key to complete the proof. We will proof it at the end. -/
  simp_rw [(hq _ _).2.1] at h_sum_sPoly
  replace hq (g₁ g₂ : G'.filter degFgEqA) := (hq g₁ g₂).2.2
  clear hsPoly -- clear the infoview (optional)
  let c' g₁ g₂ := c g₁ g₂ • (m.leadingCoeff (f g₁) * m.leadingCoeff (f g₂))
  simp_rw [Finset.mul_sum, ← mul_assoc, Finset.smul_sum,
    ← smul_mul_assoc, smul_monomial, Finset.sum_comm (t:=G''), ← Finset.sum_mul,
    show _ = c' _ _ by unfold c'; exact rfl] at h_sum_sPoly
  clear_value c'
  /- With the assumption that $f(g)$ vanishes when $g ∉ G'$ and $G'' ⊆ G'$, we have
  $$p = ∑ g ∈ G' with (degree(f(g) * g) = a), leadingTerm(f(g)) * g + ∑ g ∈ G', (f(g) - lt'(g)) * g
    = ∑ g ∈ G' with (degree(f(g) * g) = a), leadingTerm(f(g)) * g + ∑ g ∈ G'', (f(g) - lt'(g)) * g
    = ∑ g ∈ G'',
        (∑ g₁, g₂ ∈ \{g ∈ G' | degree(f(g) * g) = a\},
           c'(g₁, g₂)•(lcm(lm(f(g₁) * g₁), lm(f(g₂) * g₂)) / lcm(lm(g₁), lm(g₂))) * q_{g₁, g₂}(g)) *
        g +
      ∑ g ∈ G'', (f(g) - lt'(g)) * g
    = ∑ g ∈ G'',
        (∑ g₁, g₂ ∈ \{g ∈ G' | degree(f(g) * g) = a\},
           c'(g₁, g₂)•(lcm(lm(f(g₁) * g₁), lm(f(g₂) * g₂)) / lcm(lm(g₁), lm(g₂))) * q_{g₁, g₂}(g) +
         (f(g) - lt'(g))) *
        g.$$ -/
  convert_to p = _ + ∑ g ∈ G'', (f g - lt' g) * g using 2 at hp
  · exact Finset.sum_subset (by simp [G'']) (by simp_intro .. [hf₀support, lt'])
  simp_rw [h_sum_sPoly, ← Finset.sum_add_distrib, ← add_mul] at hp
  /- Let $f'(g)$ be
  $$∑ g₁, g₂ ∈ \{g ∈ G' | degree(f(g) * g) = a\},
      c'(g₁, g₂)•(lcm(lm(f(g₁) * g₁), lm(f(g₂) * g₂)) / lcm(lm(g₁), lm(g₂))) * q_{g₁, g₂}(g)
    + (f(g) - lt'(g)),$$
  and $a'$ be $max(degree(p), max_{g ∈ G''} f'(g) * g$. Than we have $p = ∑ g ∈ G'', f'(g) * g$,
  and apparently $degree(p) ≤ a'$ and $∀ g ∈ G'', a' ≤ f'(g) * g$.
  We will show $P(a')$ hold on $a'$ by $f'$, $G''$. -/
  -- use `by exact hp` to assign a long expression (which we don't want to write) to `?f'`
  refine ⟨m.toSyn (m.degree p) ⊔ G''.sup fun g ↦ m.toSyn <| m.degree <| ?f' g * g, (?_ : _ < _),
    by simp, ?f', G'', by simp [G'', hG'subsetG, h_q_support_subset_G], by exact hp, ?le_max⟩
  case le_max =>
    intro h g
    rw [mul_comm]
    exact le_trans (Finset.le_sup (f := fun g ↦ m.toSyn <| m.degree <| ?f' g * g) g) le_sup_right
  /- It remains to be proved that $a' < a$.
  It suffices that $degree(f'(g) * g) < a$ for all $g ∈ G''$. Then it suffices that, degree(s) of
  the left side (too long...) and the right side $f(g) - lt'(g)$ of the outermost $+$ in $f'$
  multiplied by $g$ respective are both less than $a$ for all $g ∈ G''$.
  -/
  clear hp h_sum_sPoly -- remove them since they're long and will not be used anymore
  simp? [ha, Finset.sup_lt_iff h_a_gt_zero, add_mul] says
    simp only [Finset.univ_eq_attach, add_mul, sup_lt_iff, ha, Finset.sup_lt_iff h_a_gt_zero,
      true_and]
  intro g hg'
  apply lt_of_le_of_lt degree_add_le
  apply max_lt
  · /- To prove the left side, it suffices to show
    $degree(c'(g₁, g₂)•(lcm(lm(f(g₁) * g₁), lm(f(g₂) * g₂)) / lcm(lm(g₁), lm(g₂))) *
      q_{g₁, g₂}(g) * g) < a$
    for all $g₁, g₂ ∈ \{g ∈ G' | degree(f(g) * g) = a\}$ (`g₁`, `g₂`). -/
    simp_rw [Finset.sum_mul]
    refine lt_of_le_of_lt m.degree_sum_le <| (Finset.sup_lt_iff h_a_gt_zero).mpr ?_
    simp? [-Finset.mem_filter, -Subtype.forall] says simp only [Finset.mem_attach, forall_const]
    intro g₁
    refine lt_of_le_of_lt m.degree_sum_le <| (Finset.sup_lt_iff h_a_gt_zero).mpr ?_
    simp? [-Finset.mem_filter, -Subtype.forall] says simp only [Finset.mem_attach, forall_const]
    intro g₂
    /- Without loss of generality, we assume $sPoly(g₁, g₂) ≠ 0$.
    (If it is $0$, then $q_{g₁, g₂} = 0$).
    $$degree(
      c'(g₁, g₂) • (lcm(lm(f(g₁) * g₁), lm(f(g₂) * g₂)) / lcm(lm(g₁), lm(g₂))) * q_{g₁, g₂}(g) * g)
    ≤ degree(lcm(lm(f(g₁) * g₁), lm(f(g₂) * g₂))) - degree(lcm(lm(g₁), lm(g₂))) +
        degree(q_{g₁, g₂}(g) * g)$$ -/
    obtain ⟨h_deg_gq_le_sPoly, h_q_eq_0_of_sPoly_eq_0⟩ := hq g₁ g₂ g <| by
      simp? [G'', -Subtype.exists, -Finset.mem_attach, -Finsupp.mem_support_iff] at hg' says
        simp only [Finset.mem_union, Finset.mem_biUnion, G''] at hg'
      rcases hg' with hg' | ⟨a, -, b, -, hh'⟩
      · exact Set.mem_of_subset_of_mem hG'subsetG hg'
      · exact h_q_support_subset_G _ _ hh'
    wlog! hsPoly_ne_0 : m.sPolynomial g₁.val g₂.val ≠ 0
    · simp [h_q_eq_0_of_sPoly_eq_0 hsPoly_ne_0, h_a_gt_zero]
    rw [mul_assoc]
    apply lt_of_le_of_lt degree_mul_le
    rw [AddEquiv.map_add]
    refine add_lt_of_add_lt_right ?_ (degree_monomial_le _)
    /- $$... ≤ degree(lcm(lm(f(g₁) * g₁), lm(f(g₂) * g₂))) - degree(lcm(lm(g₁), lm(g₂))) +
                degree(sPoly(g₁, g₂))$$ -/
    apply lt_of_le_of_lt (add_le_add_right (mul_comm g (q _ _ g) ▸ h_deg_gq_le_sPoly) _)
    /- $$... < degree(lcm(lm(f(g₁) * g₁), lm(f(g₂) * g₂))) - degree(lcm(lm(g₁), lm(g₂))) +
                degree(lcm(lm(g₁), lm(g₂)))$$ -/
    apply lt_of_lt_of_le (add_lt_add_right (m.degree_sPolynomial_lt_sup_degree hsPoly_ne_0) _)
    /- $$... = degree(lcm(lm(f(g₁) * g₁), lm(f(g₂) * g₂))).$$ -/
    have hfgg₁ := (G'.mem_filter.mp g₁.2).2
    have hfgg₂ := (G'.mem_filter.mp g₂.2).2
    simp [degFgEqA, eq_comm] at hfgg₁ hfgg₂
    rw [← AddEquiv.map_add, tsub_add_cancel_of_le <| sup_le_sup _ _]
    /- $$... ≤ a.$$ -/
    · simp_all
    · simp [m.degree_mul' <|
        ne_zero_of_degree_ne_zero <| m.toSyn.map_ne_zero_iff.mp <| hfgg₁ ▸ h_a_gt_zero.ne']
    · simp [m.degree_mul' <|
        ne_zero_of_degree_ne_zero <| m.toSyn.map_ne_zero_iff.mp <| hfgg₂ ▸ h_a_gt_zero.ne']
  · /- It is easy to prove $degree(f(g) - lt'(g)) < a$. -/
    wlog h : degFgEqA g
    · by_cases hg'G' : g ∈ G'
      · simp [h, lt', lt_of_le_of_ne (mul_comm (f g) g ▸ h_deg_le g hg'G') h]
      · simp [hg'G', h_a_gt_zero, lt', hf₀support]
    simp? [h, lt'] says simp only [h, ↓reduceIte, lt']
    wlog! +distrib hLTgg' : f g - m.leadingTerm (f g) ≠ 0
    · simp [hLTgg', h_a_gt_zero]
    rw [← h] at ⊢ h_a_gt_zero
    apply ne_of_lt at h_a_gt_zero
    rw [ne_eq, eq_comm, toSyn_eq_zero_iff] at h_a_gt_zero
    obtain ⟨gg'_ne_zero, g_ne_zero⟩ := mul_ne_zero_iff.mp (m.ne_zero_of_degree_ne_zero h_a_gt_zero)
    simp [degree_mul hLTgg' g_ne_zero, degree_mul gg'_ne_zero g_ne_zero,
      m.degree_sub_leadingTerm_lt_degree (m.degree_ne_zero_of_sub_leadingTerm_ne_zero hLTgg')]

/-- Buchberger Criterion: a basis of an ideal is a Gröbner basis of it if and only if any
remainder of echo sPolynomial between two polynomials on the basis is 0.

It is a variant of `MonomialOrder.isGroebnerBasis_iff_isRemainder_sPolynomial_zero`. -/
theorem isGroebnerBasis_iff_isRemainder_sPolynomial_zero' (G : Set (MvPolynomial σ k)) :
    m.IsGroebnerBasis G (Ideal.span G) ↔
    ∀ (g₁ g₂ : G) (r : MvPolynomial σ k),
      m.IsRemainder (m.sPolynomial g₁ g₂ : MvPolynomial σ k) G r → r = 0 := by
  constructor
  · intro h g₁ g₂ r hr
    apply (remainder_eq_zero_iff_mem_ideal_of_isGroebnerBasis' h hr).mpr
    rw [m.isGroebnerBasis_iff_subset_ideal_and_isRemainder_zero'] at h
    apply m.sPolynomial_mem_ideal
    <;> exact Set.mem_of_subset_of_mem h.1 (by simp)
  · rw [isGroebnerBasis_iff_isRemainder_sPolynomial_zero]
    intro h g₁ g₂
    obtain ⟨r, hr⟩ := m.exists_isRemainder' G (m.sPolynomial (R := k) ↑g₁ ↑g₂)
    rwa [h g₁ g₂ r hr] at hr

end Field

end MonomialOrder
