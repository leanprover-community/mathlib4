/-
Copyright (c) 2020 Johan Commelin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin, Robert Y. Lewis
-/
import Mathlib.RingTheory.WittVector.StructurePolynomial

/-!
# Witt vectors

In this file we define the type of `p`-typical Witt vectors and ring operations on it.
The ring axioms are verified in `Mathlib/RingTheory/WittVector/Basic.lean`.

For a fixed commutative ring `R` and prime `p`,
a Witt vector `x : ùïé R` is an infinite sequence `‚Ñï ‚Üí R` of elements of `R`.
However, the ring operations `+` and `*` are not defined in the obvious component-wise way.
Instead, these operations are defined via certain polynomials
using the machinery in `Mathlib/RingTheory/WittVector/StructurePolynomial.lean`.
The `n`th value of the sum of two Witt vectors can depend on the `0`-th through `n`th values
of the summands. This effectively simulates a ‚Äúcarrying‚Äù operation.

## Main definitions

* `WittVector p R`: the type of `p`-typical Witt vectors with coefficients in `R`.
* `WittVector.coeff x n`: projects the `n`th value of the Witt vector `x`.

## Notation

We use notation `ùïé R`, entered `\bbW`, for the Witt vectors over `R`.

## References

* [Hazewinkel, *Witt Vectors*][Haze09]

* [Commelin and Lewis, *Formalizing the Ring of Witt Vectors*][CL21]
-/


noncomputable section

/-- `WittVector p R` is the ring of `p`-typical Witt vectors over the commutative ring `R`,
where `p` is a prime number.

If `p` is invertible in `R`, this ring is isomorphic to `‚Ñï ‚Üí R` (the product of `‚Ñï` copies of `R`).
If `R` is a ring of characteristic `p`, then `WittVector p R` is a ring of characteristic `0`.
The canonical example is `WittVector p (ZMod p)`,
which is isomorphic to the `p`-adic integers `‚Ñ§_[p]`. -/
structure WittVector (p : ‚Ñï) (R : Type*) where mk' ::
  /-- `x.coeff n` is the `n`th coefficient of the Witt vector `x`.

  This concept does not have a standard name in the literature.
  -/
  coeff : ‚Ñï ‚Üí R

-- Porting note: added to make the `p` argument explicit
/-- Construct a Witt vector `mk p x : ùïé R` from a sequence `x` of elements of `R`. -/
def WittVector.mk (p : ‚Ñï) {R : Type*} (coeff : ‚Ñï ‚Üí R) : WittVector p R := mk' coeff

variable {p : ‚Ñï}

/- We cannot make this `localized` notation, because the `p` on the RHS doesn't occur on the left
Hiding the `p` in the notation is very convenient, so we opt for repeating the `local notation`
in other files that use Witt vectors. -/
local notation "ùïé" => WittVector p -- type as `\bbW`

namespace WittVector

variable {R : Type*}

@[ext]
theorem ext {x y : ùïé R} (h : ‚àÄ n, x.coeff n = y.coeff n) : x = y := by
  cases x
  cases y
  simp only at h
  simp [Function.funext_iff, h]

variable (p)

theorem coeff_mk (x : ‚Ñï ‚Üí R) : (mk p x).coeff = x :=
  rfl

/- These instances are not needed for the rest of the development,
but it is interesting to establish early on that `WittVector p` is a lawful functor. -/
instance : Functor (WittVector p) where
  map f v := mk p (f ‚àò v.coeff)
  mapConst a _ := mk p fun _ => a

instance : LawfulFunctor (WittVector p) where
  map_const := rfl
  -- Porting note: no longer needs to deconstruct `v` to conclude `{coeff := v.coeff} = v`
  id_map _ := rfl
  comp_map _ _ _ := rfl

variable [hp : Fact p.Prime] [CommRing R]

open MvPolynomial

section RingOperations

/-- The polynomials used for defining the element `0` of the ring of Witt vectors. -/
def wittZero : ‚Ñï ‚Üí MvPolynomial (Fin 0 √ó ‚Ñï) ‚Ñ§ :=
  wittStructureInt p 0

/-- The polynomials used for defining the element `1` of the ring of Witt vectors. -/
def wittOne : ‚Ñï ‚Üí MvPolynomial (Fin 0 √ó ‚Ñï) ‚Ñ§ :=
  wittStructureInt p 1

/-- The polynomials used for defining the addition of the ring of Witt vectors. -/
def wittAdd : ‚Ñï ‚Üí MvPolynomial (Fin 2 √ó ‚Ñï) ‚Ñ§ :=
  wittStructureInt p (X 0 + X 1)

/-- The polynomials used for defining repeated addition of the ring of Witt vectors. -/
def wittNSMul (n : ‚Ñï) : ‚Ñï ‚Üí MvPolynomial (Fin 1 √ó ‚Ñï) ‚Ñ§ :=
  wittStructureInt p (n ‚Ä¢ X (0 : (Fin 1)))

/-- The polynomials used for defining repeated addition of the ring of Witt vectors. -/
def wittZSMul (n : ‚Ñ§) : ‚Ñï ‚Üí MvPolynomial (Fin 1 √ó ‚Ñï) ‚Ñ§ :=
  wittStructureInt p (n ‚Ä¢ X (0 : (Fin 1)))

/-- The polynomials used for describing the subtraction of the ring of Witt vectors. -/
def wittSub : ‚Ñï ‚Üí MvPolynomial (Fin 2 √ó ‚Ñï) ‚Ñ§ :=
  wittStructureInt p (X 0 - X 1)

/-- The polynomials used for defining the multiplication of the ring of Witt vectors. -/
def wittMul : ‚Ñï ‚Üí MvPolynomial (Fin 2 √ó ‚Ñï) ‚Ñ§ :=
  wittStructureInt p (X 0 * X 1)

/-- The polynomials used for defining the negation of the ring of Witt vectors. -/
def wittNeg : ‚Ñï ‚Üí MvPolynomial (Fin 1 √ó ‚Ñï) ‚Ñ§ :=
  wittStructureInt p (-X 0)

/-- The polynomials used for defining repeated addition of the ring of Witt vectors. -/
def wittPow (n : ‚Ñï) : ‚Ñï ‚Üí MvPolynomial (Fin 1 √ó ‚Ñï) ‚Ñ§ :=
  wittStructureInt p (X 0 ^ n)

variable {p}


/-- An auxiliary definition used in `WittVector.eval`.
Evaluates a polynomial whose variables come from the disjoint union of `k` copies of `‚Ñï`,
with a curried evaluation `x`.
This can be defined more generally but we use only a specific instance here. -/
def peval {k : ‚Ñï} (œÜ : MvPolynomial (Fin k √ó ‚Ñï) ‚Ñ§) (x : Fin k ‚Üí ‚Ñï ‚Üí R) : R :=
  aeval (Function.uncurry x) œÜ

/-- Let `œÜ` be a family of polynomials, indexed by natural numbers, whose variables come from the
disjoint union of `k` copies of `‚Ñï`, and let `x·µ¢` be a Witt vector for `0 ‚â§ i < k`.

`eval œÜ x` evaluates `œÜ` mapping the variable `X_(i, n)` to the `n`th coefficient of `x·µ¢`.

Instantiating `œÜ` with certain polynomials defined in
`Mathlib/RingTheory/WittVector/StructurePolynomial.lean` establishes the
ring operations on `ùïé R`. For example, `WittVector.wittAdd` is such a `œÜ` with `k = 2`;
evaluating this at `(x‚ÇÄ, x‚ÇÅ)` gives us the sum of two Witt vectors `x‚ÇÄ + x‚ÇÅ`.
-/
def eval {k : ‚Ñï} (œÜ : ‚Ñï ‚Üí MvPolynomial (Fin k √ó ‚Ñï) ‚Ñ§) (x : Fin k ‚Üí ùïé R) : ùïé R :=
  mk p fun n => peval (œÜ n) fun i => (x i).coeff

variable (R) [Fact p.Prime]

instance : Zero (ùïé R) :=
  ‚ü®eval (wittZero p) ![]‚ü©

instance : Inhabited (ùïé R) :=
  ‚ü®0‚ü©

instance : One (ùïé R) :=
  ‚ü®eval (wittOne p) ![]‚ü©

instance : Add (ùïé R) :=
  ‚ü®fun x y => eval (wittAdd p) ![x, y]‚ü©

instance : Sub (ùïé R) :=
  ‚ü®fun x y => eval (wittSub p) ![x, y]‚ü©

instance hasNatScalar : SMul ‚Ñï (ùïé R) :=
  ‚ü®fun n x => eval (wittNSMul p n) ![x]‚ü©

instance hasIntScalar : SMul ‚Ñ§ (ùïé R) :=
  ‚ü®fun n x => eval (wittZSMul p n) ![x]‚ü©

instance : Mul (ùïé R) :=
  ‚ü®fun x y => eval (wittMul p) ![x, y]‚ü©

instance : Neg (ùïé R) :=
  ‚ü®fun x => eval (wittNeg p) ![x]‚ü©

instance hasNatPow : Pow (ùïé R) ‚Ñï :=
  ‚ü®fun x n => eval (wittPow p n) ![x]‚ü©

instance : NatCast (ùïé R) :=
  ‚ü®Nat.unaryCast‚ü©

instance : IntCast (ùïé R) :=
  ‚ü®Int.castDef‚ü©

end RingOperations

section WittStructureSimplifications

@[simp]
theorem wittZero_eq_zero (n : ‚Ñï) : wittZero p n = 0 := by
  apply MvPolynomial.map_injective (Int.castRingHom ‚Ñö) Int.cast_injective
  simp only [wittZero, wittStructureRat, bind‚ÇÅ, aeval_zero', constantCoeff_xInTermsOfW, map_zero,
    map_wittStructureInt]

@[simp]
theorem wittOne_zero_eq_one : wittOne p 0 = 1 := by
  apply MvPolynomial.map_injective (Int.castRingHom ‚Ñö) Int.cast_injective
  simp only [wittOne, wittStructureRat, xInTermsOfW_zero, map_one, bind‚ÇÅ_X_right,
    map_wittStructureInt]

@[simp]
theorem wittOne_pos_eq_zero (n : ‚Ñï) (hn : 0 < n) : wittOne p n = 0 := by
  apply MvPolynomial.map_injective (Int.castRingHom ‚Ñö) Int.cast_injective
  simp only [wittOne, wittStructureRat, RingHom.map_zero, map_one, RingHom.map_one,
    map_wittStructureInt]
  induction n using Nat.strong_induction_on with | h n IH => ?_
  rw [xInTermsOfW_eq]
  simp only [map_mul, map_sub, map_sum, map_pow, bind‚ÇÅ_X_right,
    bind‚ÇÅ_C_right]
  rw [sub_mul, one_mul]
  rw [Finset.sum_eq_single 0]
  ¬∑ simp only [invOf_eq_inv, one_mul, inv_pow, tsub_zero, RingHom.map_one, pow_zero]
    simp only [one_pow, one_mul, xInTermsOfW_zero, sub_self, bind‚ÇÅ_X_right]
  ¬∑ intro i hin hi0
    rw [Finset.mem_range] at hin
    rw [IH _ hin (Nat.pos_of_ne_zero hi0), zero_pow (pow_ne_zero _ hp.1.ne_zero), mul_zero]
  ¬∑ rw [Finset.mem_range]; intro; contradiction

@[simp]
theorem wittAdd_zero : wittAdd p 0 = X (0, 0) + X (1, 0) := by
  apply MvPolynomial.map_injective (Int.castRingHom ‚Ñö) Int.cast_injective
  simp only [wittAdd, wittStructureRat, map_add, rename_X, xInTermsOfW_zero, map_X,
    wittPolynomial_zero, bind‚ÇÅ_X_right, map_wittStructureInt]

@[simp]
theorem wittSub_zero : wittSub p 0 = X (0, 0) - X (1, 0) := by
  apply MvPolynomial.map_injective (Int.castRingHom ‚Ñö) Int.cast_injective
  simp only [wittSub, wittStructureRat, map_sub, rename_X, xInTermsOfW_zero, map_X,
    wittPolynomial_zero, bind‚ÇÅ_X_right, map_wittStructureInt]

@[simp]
theorem wittMul_zero : wittMul p 0 = X (0, 0) * X (1, 0) := by
  apply MvPolynomial.map_injective (Int.castRingHom ‚Ñö) Int.cast_injective
  simp only [wittMul, wittStructureRat, rename_X, xInTermsOfW_zero, map_X, wittPolynomial_zero,
    map_mul, bind‚ÇÅ_X_right, map_wittStructureInt]

@[simp]
theorem wittNeg_zero : wittNeg p 0 = -X (0, 0) := by
  apply MvPolynomial.map_injective (Int.castRingHom ‚Ñö) Int.cast_injective
  simp only [wittNeg, wittStructureRat, rename_X, xInTermsOfW_zero, map_X, wittPolynomial_zero,
    map_neg, bind‚ÇÅ_X_right, map_wittStructureInt]

@[simp]
theorem constantCoeff_wittAdd (n : ‚Ñï) : constantCoeff (wittAdd p n) = 0 := by
  apply constantCoeff_wittStructureInt p _ _ n
  simp only [add_zero, RingHom.map_add, constantCoeff_X]

@[simp]
theorem constantCoeff_wittSub (n : ‚Ñï) : constantCoeff (wittSub p n) = 0 := by
  apply constantCoeff_wittStructureInt p _ _ n
  simp only [sub_zero, RingHom.map_sub, constantCoeff_X]

@[simp]
theorem constantCoeff_wittMul (n : ‚Ñï) : constantCoeff (wittMul p n) = 0 := by
  apply constantCoeff_wittStructureInt p _ _ n
  simp only [mul_zero, RingHom.map_mul, constantCoeff_X]

@[simp]
theorem constantCoeff_wittNeg (n : ‚Ñï) : constantCoeff (wittNeg p n) = 0 := by
  apply constantCoeff_wittStructureInt p _ _ n
  simp only [neg_zero, RingHom.map_neg, constantCoeff_X]

@[simp]
theorem constantCoeff_wittNSMul (m : ‚Ñï) (n : ‚Ñï) : constantCoeff (wittNSMul p m n) = 0 := by
  apply constantCoeff_wittStructureInt p _ _ n
  simp only [smul_zero, map_nsmul, constantCoeff_X]

@[simp]
theorem constantCoeff_wittZSMul (z : ‚Ñ§) (n : ‚Ñï) : constantCoeff (wittZSMul p z n) = 0 := by
  apply constantCoeff_wittStructureInt p _ _ n
  simp only [smul_zero, map_zsmul, constantCoeff_X]

end WittStructureSimplifications

section Coeff

variable (R)

@[simp]
theorem zero_coeff (n : ‚Ñï) : (0 : ùïé R).coeff n = 0 :=
  show (aeval _ (wittZero p n) : R) = 0 by simp only [wittZero_eq_zero, map_zero]

@[simp]
theorem one_coeff_zero : (1 : ùïé R).coeff 0 = 1 :=
  show (aeval _ (wittOne p 0) : R) = 1 by simp only [wittOne_zero_eq_one, map_one]

@[simp]
theorem one_coeff_eq_of_pos (n : ‚Ñï) (hn : 0 < n) : coeff (1 : ùïé R) n = 0 :=
  show (aeval _ (wittOne p n) : R) = 0 by simp only [hn, wittOne_pos_eq_zero, map_zero]

variable {p R}

@[simp]
theorem v2_coeff {p' R'} (x y : WittVector p' R') (i : Fin 2) :
    (![x, y] i).coeff = ![x.coeff, y.coeff] i := by fin_cases i <;> simp

-- Porting note: the lemmas below needed `coeff_mk` added to the `simp` calls

theorem add_coeff (x y : ùïé R) (n : ‚Ñï) :
    (x + y).coeff n = peval (wittAdd p n) ![x.coeff, y.coeff] := by
  simp [(¬∑ + ¬∑), Add.add, eval, coeff_mk]

theorem sub_coeff (x y : ùïé R) (n : ‚Ñï) :
    (x - y).coeff n = peval (wittSub p n) ![x.coeff, y.coeff] := by
  simp [(¬∑ - ¬∑), Sub.sub, eval, coeff_mk]

theorem mul_coeff (x y : ùïé R) (n : ‚Ñï) :
    (x * y).coeff n = peval (wittMul p n) ![x.coeff, y.coeff] := by
  simp [(¬∑ * ¬∑), Mul.mul, eval, coeff_mk]

theorem neg_coeff (x : ùïé R) (n : ‚Ñï) : (-x).coeff n = peval (wittNeg p n) ![x.coeff] := by
  simp [Neg.neg, eval, Matrix.cons_fin_one, coeff_mk]

theorem nsmul_coeff (m : ‚Ñï) (x : ùïé R) (n : ‚Ñï) :
    (m ‚Ä¢ x).coeff n = peval (wittNSMul p m n) ![x.coeff] := by
  simp [(¬∑ ‚Ä¢ ¬∑), SMul.smul, eval, Matrix.cons_fin_one, coeff_mk]

theorem zsmul_coeff (m : ‚Ñ§) (x : ùïé R) (n : ‚Ñï) :
    (m ‚Ä¢ x).coeff n = peval (wittZSMul p m n) ![x.coeff] := by
  simp [(¬∑ ‚Ä¢ ¬∑), SMul.smul, eval, Matrix.cons_fin_one, coeff_mk]

theorem pow_coeff (m : ‚Ñï) (x : ùïé R) (n : ‚Ñï) :
    (x ^ m).coeff n = peval (wittPow p m n) ![x.coeff] := by
  simp [(¬∑ ^ ¬∑), Pow.pow, eval, Matrix.cons_fin_one, coeff_mk]

theorem add_coeff_zero (x y : ùïé R) : (x + y).coeff 0 = x.coeff 0 + y.coeff 0 := by
  simp [add_coeff, peval]

theorem mul_coeff_zero (x y : ùïé R) : (x * y).coeff 0 = x.coeff 0 * y.coeff 0 := by
  simp [mul_coeff, peval]

end Coeff

theorem wittAdd_vars (n : ‚Ñï) : (wittAdd p n).vars ‚äÜ Finset.univ √óÀ¢ Finset.range (n + 1) :=
  wittStructureInt_vars _ _ _

theorem wittSub_vars (n : ‚Ñï) : (wittSub p n).vars ‚äÜ Finset.univ √óÀ¢ Finset.range (n + 1) :=
  wittStructureInt_vars _ _ _

theorem wittMul_vars (n : ‚Ñï) : (wittMul p n).vars ‚äÜ Finset.univ √óÀ¢ Finset.range (n + 1) :=
  wittStructureInt_vars _ _ _

theorem wittNeg_vars (n : ‚Ñï) : (wittNeg p n).vars ‚äÜ Finset.univ √óÀ¢ Finset.range (n + 1) :=
  wittStructureInt_vars _ _ _

theorem wittNSMul_vars (m : ‚Ñï) (n : ‚Ñï) :
    (wittNSMul p m n).vars ‚äÜ Finset.univ √óÀ¢ Finset.range (n + 1) :=
  wittStructureInt_vars _ _ _

theorem wittZSMul_vars (m : ‚Ñ§) (n : ‚Ñï) :
    (wittZSMul p m n).vars ‚äÜ Finset.univ √óÀ¢ Finset.range (n + 1) :=
  wittStructureInt_vars _ _ _

theorem wittPow_vars (m : ‚Ñï) (n : ‚Ñï) : (wittPow p m n).vars ‚äÜ Finset.univ √óÀ¢ Finset.range (n + 1) :=
  wittStructureInt_vars _ _ _

end WittVector
