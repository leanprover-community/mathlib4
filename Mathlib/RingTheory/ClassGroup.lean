/-
Copyright (c) 2021 Anne Baanen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anne Baanen
-/
import Mathlib.GroupTheory.QuotientGroup
import Mathlib.RingTheory.DedekindDomain.Ideal

#align_import ring_theory.class_group from "leanprover-community/mathlib"@"565eb991e264d0db702722b4bde52ee5173c9950"

/-!
# The ideal class group

This file defines the ideal class group `ClassGroup R` of fractional ideals of `R`
inside its field of fractions.

## Main definitions
 - `toPrincipalIdeal` sends an invertible `x : K` to an invertible fractional ideal
 - `ClassGroup` is the quotient of invertible fractional ideals modulo `toPrincipalIdeal.range`
 - `ClassGroup.mk0` sends a nonzero integral ideal in a Dedekind domain to its class

## Main results
 - `ClassGroup.mk0_eq_mk0_iff` shows the equivalence with the "classical" definition,
   where `I ~ J` iff `x I = y J` for `x y ‚â† (0 : R)`

## Implementation details

The definition of `ClassGroup R` involves `FractionRing R`. However, the API should be completely
identical no matter the choice of field of fractions for `R`.
-/


variable {R K L : Type*} [CommRing R]

variable [Field K] [Field L] [DecidableEq L]

variable [Algebra R K] [IsFractionRing R K]

variable [Algebra K L] [FiniteDimensional K L]

variable [Algebra R L] [IsScalarTower R K L]

open scoped nonZeroDivisors

open IsLocalization IsFractionRing FractionalIdeal Units

section

variable (R K)

/-- `toPrincipalIdeal R K x` sends `x ‚â† 0 : K` to the fractional `R`-ideal generated by `x` -/
irreducible_def toPrincipalIdeal : KÀ£ ‚Üí* (FractionalIdeal R‚Å∞ K)À£ :=
  { toFun := fun x =>
      ‚ü®spanSingleton _ x, spanSingleton _ x‚Åª¬π, by
        simp only [spanSingleton_one, Units.mul_inv', spanSingleton_mul_spanSingleton], by
        -- üéâ no goals
        simp only [spanSingleton_one, Units.inv_mul', spanSingleton_mul_spanSingleton]‚ü©
        -- üéâ no goals
    map_mul' := fun x y =>
      ext (by simp only [Units.val_mk, Units.val_mul, spanSingleton_mul_spanSingleton])
              -- üéâ no goals
                        -- üéâ no goals
    map_one' := ext (by simp only [spanSingleton_one, Units.val_mk, Units.val_one]) }
#align to_principal_ideal toPrincipalIdeal

variable {R K}

@[simp]
theorem coe_toPrincipalIdeal (x : KÀ£) :
    (toPrincipalIdeal R K x : FractionalIdeal R‚Å∞ K) = spanSingleton _ (x : K) := by
  simp only [toPrincipalIdeal]; rfl
  -- ‚ä¢ ‚Üë(‚Üë{ toOneHom := { toFun := fun x => { val := spanSingleton R‚Å∞ ‚Üëx, inv := sp ‚Ä¶
                                -- üéâ no goals
#align coe_to_principal_ideal coe_toPrincipalIdeal

@[simp]
theorem toPrincipalIdeal_eq_iff {I : (FractionalIdeal R‚Å∞ K)À£} {x : KÀ£} :
    toPrincipalIdeal R K x = I ‚Üî spanSingleton R‚Å∞ (x : K) = I := by
  simp only [toPrincipalIdeal]; exact Units.ext_iff
  -- ‚ä¢ ‚Üë{ toOneHom := { toFun := fun x => { val := spanSingleton R‚Å∞ ‚Üëx, inv := span ‚Ä¶
                                -- üéâ no goals
#align to_principal_ideal_eq_iff toPrincipalIdeal_eq_iff

theorem mem_principal_ideals_iff {I : (FractionalIdeal R‚Å∞ K)À£} :
    I ‚àà (toPrincipalIdeal R K).range ‚Üî ‚àÉ x : K, spanSingleton R‚Å∞ x = I := by
  simp only [MonoidHom.mem_range, toPrincipalIdeal_eq_iff]
  -- ‚ä¢ (‚àÉ x, spanSingleton R‚Å∞ ‚Üëx = ‚ÜëI) ‚Üî ‚àÉ x, spanSingleton R‚Å∞ x = ‚ÜëI
  constructor <;> rintro ‚ü®x, hx‚ü©
  -- ‚ä¢ (‚àÉ x, spanSingleton R‚Å∞ ‚Üëx = ‚ÜëI) ‚Üí ‚àÉ x, spanSingleton R‚Å∞ x = ‚ÜëI
                  -- ‚ä¢ ‚àÉ x, spanSingleton R‚Å∞ x = ‚ÜëI
                  -- ‚ä¢ ‚àÉ x, spanSingleton R‚Å∞ ‚Üëx = ‚ÜëI
  ¬∑ exact ‚ü®x, hx‚ü©
    -- üéâ no goals
  ¬∑ refine ‚ü®Units.mk0 x ?_, hx‚ü©
    -- ‚ä¢ x ‚â† 0
    rintro rfl
    -- ‚ä¢ False
    simp [I.ne_zero.symm] at hx
    -- üéâ no goals
#align mem_principal_ideals_iff mem_principal_ideals_iff

instance PrincipalIdeals.normal : (toPrincipalIdeal R K).range.Normal :=
  Subgroup.normal_of_comm _
#align principal_ideals.normal PrincipalIdeals.normal

end

variable (R)

variable [IsDomain R]

/-- The ideal class group of `R` is the group of invertible fractional ideals
modulo the principal ideals. -/
def ClassGroup :=
  (FractionalIdeal R‚Å∞ (FractionRing R))À£ ‚ß∏ (toPrincipalIdeal R (FractionRing R)).range
#align class_group ClassGroup

noncomputable instance : CommGroup (ClassGroup R) :=
  QuotientGroup.Quotient.commGroup (toPrincipalIdeal R (FractionRing R)).range

noncomputable instance : Inhabited (ClassGroup R) := ‚ü®1‚ü©

variable {R}

/-- Send a nonzero fractional ideal to the corresponding class in the class group. -/
noncomputable def ClassGroup.mk : (FractionalIdeal R‚Å∞ K)À£ ‚Üí* ClassGroup R :=
  (QuotientGroup.mk' (toPrincipalIdeal R (FractionRing R)).range).comp
    (Units.map (FractionalIdeal.canonicalEquiv R‚Å∞ K (FractionRing R)))
#align class_group.mk ClassGroup.mk

-- Can't be `@[simp]` because it can't figure out the quotient relation.
theorem ClassGroup.Quot_mk_eq_mk (I : (FractionalIdeal R‚Å∞ (FractionRing R))À£) :
    Quot.mk _ I = ClassGroup.mk I := by
  rw [ClassGroup.mk, canonicalEquiv_self, RingEquiv.coe_monoidHom_refl, Units.map_id,
      MonoidHom.comp_apply, MonoidHom.id_apply, QuotientGroup.mk'_apply]
  rfl
  -- üéâ no goals

theorem ClassGroup.mk_eq_mk {I J : (FractionalIdeal R‚Å∞ <| FractionRing R)À£} :
    ClassGroup.mk I = ClassGroup.mk J ‚Üî
      ‚àÉ x : (FractionRing R)À£, I * toPrincipalIdeal R (FractionRing R) x = J := by
  erw [QuotientGroup.mk'_eq_mk', canonicalEquiv_self, Units.map_id, Set.exists_range_iff]
  -- ‚ä¢ (‚àÉ i, ‚Üë(MonoidHom.id (FractionalIdeal R‚Å∞ (FractionRing R))À£) I * ‚Üë(toPrincip ‚Ä¶
  rfl
  -- üéâ no goals
#align class_group.mk_eq_mk ClassGroup.mk_eq_mk

theorem ClassGroup.mk_eq_mk_of_coe_ideal {I J : (FractionalIdeal R‚Å∞ <| FractionRing R)À£}
    {I' J' : Ideal R} (hI : (I : FractionalIdeal R‚Å∞ <| FractionRing R) = I')
    (hJ : (J : FractionalIdeal R‚Å∞ <| FractionRing R) = J') :
    ClassGroup.mk I = ClassGroup.mk J ‚Üî
      ‚àÉ x y : R, x ‚â† 0 ‚àß y ‚â† 0 ‚àß Ideal.span {x} * I' = Ideal.span {y} * J' := by
  rw [ClassGroup.mk_eq_mk]
  -- ‚ä¢ (‚àÉ x, I * ‚Üë(toPrincipalIdeal R (FractionRing R)) x = J) ‚Üî ‚àÉ x y, x ‚â† 0 ‚àß y ‚â† ‚Ä¶
  constructor
  -- ‚ä¢ (‚àÉ x, I * ‚Üë(toPrincipalIdeal R (FractionRing R)) x = J) ‚Üí ‚àÉ x y, x ‚â† 0 ‚àß y ‚â† ‚Ä¶
  ¬∑ rintro ‚ü®x, rfl‚ü©
    -- ‚ä¢ ‚àÉ x y, x ‚â† 0 ‚àß y ‚â† 0 ‚àß Ideal.span {x} * I' = Ideal.span {y} * J'
    rw [Units.val_mul, hI, coe_toPrincipalIdeal, mul_comm,
      spanSingleton_mul_coeIdeal_eq_coeIdeal] at hJ
    exact ‚ü®_, _, sec_fst_ne_zero (R := R) le_rfl x.ne_zero,
      sec_snd_ne_zero (R := R) le_rfl (x : FractionRing R), hJ‚ü©
  ¬∑ rintro ‚ü®x, y, hx, hy, h‚ü©
    -- ‚ä¢ ‚àÉ x, I * ‚Üë(toPrincipalIdeal R (FractionRing R)) x = J
    constructor
    -- ‚ä¢ I * ‚Üë(toPrincipalIdeal R (FractionRing R)) ?mpr.intro.intro.intro.intro.w = J
    rw [mul_comm, ‚Üê Units.eq_iff, Units.val_mul, coe_toPrincipalIdeal]
    -- ‚ä¢ spanSingleton R‚Å∞ ‚Üë?mpr.intro.intro.intro.intro.h * ‚ÜëI = ‚ÜëJ
    convert
      (mk'_mul_coeIdeal_eq_coeIdeal (FractionRing R) <| mem_nonZeroDivisors_of_ne_zero hy).2 h
    apply (Ne.isUnit _).unit_spec
    -- ‚ä¢ mk' (FractionRing R) x { val := y, property := (_ : y ‚àà R‚Å∞) } ‚â† 0
    rwa [Ne, mk'_eq_zero_iff_eq_zero]
    -- üéâ no goals
#align class_group.mk_eq_mk_of_coe_ideal ClassGroup.mk_eq_mk_of_coe_ideal

theorem ClassGroup.mk_eq_one_of_coe_ideal {I : (FractionalIdeal R‚Å∞ <| FractionRing R)À£}
    {I' : Ideal R} (hI : (I : FractionalIdeal R‚Å∞ <| FractionRing R) = I') :
    ClassGroup.mk I = 1 ‚Üî ‚àÉ x : R, x ‚â† 0 ‚àß I' = Ideal.span {x} := by
  rw [‚Üê map_one (ClassGroup.mk (R := R) (K := FractionRing R)),
    ClassGroup.mk_eq_mk_of_coe_ideal hI (?_ : _ = ‚Üë(‚ä§ : Ideal R))]
  any_goals rfl
  -- ‚ä¢ (‚àÉ x y, x ‚â† 0 ‚àß y ‚â† 0 ‚àß Ideal.span {x} * I' = Ideal.span {y} * ‚ä§) ‚Üî ‚àÉ x, x ‚â† ‚Ä¶
  constructor
  -- ‚ä¢ (‚àÉ x y, x ‚â† 0 ‚àß y ‚â† 0 ‚àß Ideal.span {x} * I' = Ideal.span {y} * ‚ä§) ‚Üí ‚àÉ x, x ‚â† ‚Ä¶
  ¬∑ rintro ‚ü®x, y, hx, hy, h‚ü©
    -- ‚ä¢ ‚àÉ x, x ‚â† 0 ‚àß I' = Ideal.span {x}
    rw [Ideal.mul_top] at h
    -- ‚ä¢ ‚àÉ x, x ‚â† 0 ‚àß I' = Ideal.span {x}
    rcases Ideal.mem_span_singleton_mul.mp ((Ideal.span_singleton_le_iff_mem _).mp h.ge) with
      ‚ü®i, _hi, rfl‚ü©
    rw [‚Üê Ideal.span_singleton_mul_span_singleton, Ideal.span_singleton_mul_right_inj hx] at h
    -- ‚ä¢ ‚àÉ x, x ‚â† 0 ‚àß I' = Ideal.span {x}
    exact ‚ü®i, right_ne_zero_of_mul hy, h‚ü©
    -- üéâ no goals
  ¬∑ rintro ‚ü®x, hx, rfl‚ü©
    -- ‚ä¢ ‚àÉ x_1 y, x_1 ‚â† 0 ‚àß y ‚â† 0 ‚àß Ideal.span {x_1} * Ideal.span {x} = Ideal.span {y ‚Ä¶
    exact ‚ü®1, x, one_ne_zero, hx, by rw [Ideal.span_singleton_one, Ideal.top_mul, Ideal.mul_top]‚ü©
    -- üéâ no goals
#align class_group.mk_eq_one_of_coe_ideal ClassGroup.mk_eq_one_of_coe_ideal

variable (K)

/-- Induction principle for the class group: to show something holds for all `x : ClassGroup R`,
we can choose a fraction field `K` and show it holds for the equivalence class of each
`I : FractionalIdeal R‚Å∞ K`. -/
@[elab_as_elim]
theorem ClassGroup.induction {P : ClassGroup R ‚Üí Prop}
    (h : ‚àÄ I : (FractionalIdeal R‚Å∞ K)À£, P (ClassGroup.mk I)) (x : ClassGroup R) : P x :=
  QuotientGroup.induction_on x fun I => by
    have : I = (Units.mapEquiv (canonicalEquiv R‚Å∞ K (FractionRing R)).toMulEquiv)
      (Units.mapEquiv (canonicalEquiv R‚Å∞ (FractionRing R) K).toMulEquiv I) := by
      simp [‚Üê Units.eq_iff]
    rw [congr_arg (QuotientGroup.mk (s := (toPrincipalIdeal R (FractionRing R)).range)) this]
    -- ‚ä¢ P ‚Üë(‚Üë(Units.mapEquiv (RingEquiv.toMulEquiv (canonicalEquiv R‚Å∞ K (FractionRin ‚Ä¶
    exact h _
    -- üéâ no goals
#align class_group.induction ClassGroup.induction

/-- The definition of the class group does not depend on the choice of field of fractions. -/
noncomputable def ClassGroup.equiv :
    ClassGroup R ‚âÉ* (FractionalIdeal R‚Å∞ K)À£ ‚ß∏ (toPrincipalIdeal R K).range := by
  haveI : Subgroup.map
    (Units.mapEquiv (canonicalEquiv R‚Å∞ (FractionRing R) K).toMulEquiv).toMonoidHom
    (toPrincipalIdeal R (FractionRing R)).range = (toPrincipalIdeal R K).range := by
    ext I
    simp only [Subgroup.mem_map, mem_principal_ideals_iff]
    constructor
    ¬∑ rintro ‚ü®I, ‚ü®x, hx‚ü©, rfl‚ü©
      refine ‚ü®FractionRing.algEquiv R K x, ?_‚ü©
      simp only [RingEquiv.toMulEquiv_eq_coe, MulEquiv.coe_toMonoidHom, coe_mapEquiv, ‚Üê hx,
        RingEquiv.coe_toMulEquiv, canonicalEquiv_spanSingleton]
      rfl
    ¬∑ rintro ‚ü®x, hx‚ü©
      refine ‚ü®Units.mapEquiv (canonicalEquiv R‚Å∞ K (FractionRing R)).toMulEquiv I,
        ‚ü®(FractionRing.algEquiv R K).symm x, ?_‚ü©, Units.ext ?_‚ü©
      ¬∑ simp only [RingEquiv.toMulEquiv_eq_coe, coe_mapEquiv, ‚Üê hx, RingEquiv.coe_toMulEquiv,
          canonicalEquiv_spanSingleton]
        rfl
      ¬∑ simp only [RingEquiv.toMulEquiv_eq_coe, MulEquiv.coe_toMonoidHom, coe_mapEquiv,
          RingEquiv.coe_toMulEquiv, canonicalEquiv_canonicalEquiv, canonicalEquiv_self,
          RingEquiv.refl_apply]
  exact @QuotientGroup.congr (FractionalIdeal R‚Å∞ (FractionRing R))À£ _ (FractionalIdeal R‚Å∞ K)À£ _
    (toPrincipalIdeal R (FractionRing R)).range (toPrincipalIdeal R K).range _ _
    (Units.mapEquiv (FractionalIdeal.canonicalEquiv R‚Å∞ (FractionRing R) K).toMulEquiv) this
#align class_group.equiv ClassGroup.equiv

@[simp]
theorem ClassGroup.equiv_mk (K' : Type*) [Field K'] [Algebra R K'] [IsFractionRing R K']
    (I : (FractionalIdeal R‚Å∞ K)À£) :
    ClassGroup.equiv K' (ClassGroup.mk I) =
      QuotientGroup.mk' _ (Units.mapEquiv (‚Üë(FractionalIdeal.canonicalEquiv R‚Å∞ K K')) I) := by
  rw [ClassGroup.equiv, ClassGroup.mk, MonoidHom.comp_apply, QuotientGroup.congr_mk']
  -- ‚ä¢ ‚Üë(QuotientGroup.mk' (MonoidHom.range (toPrincipalIdeal R K'))) (‚Üë(Units.mapE ‚Ä¶
  congr
  -- ‚ä¢ ‚Üë(Units.mapEquiv (RingEquiv.toMulEquiv (canonicalEquiv R‚Å∞ (FractionRing R) K ‚Ä¶
  rw [‚Üê Units.eq_iff, Units.coe_mapEquiv, Units.coe_mapEquiv, Units.coe_map]
  -- ‚ä¢ ‚Üë(RingEquiv.toMulEquiv (canonicalEquiv R‚Å∞ (FractionRing R) K')) (‚Üë‚Üë(canonica ‚Ä¶
  exact FractionalIdeal.canonicalEquiv_canonicalEquiv _ _ _ _ _
  -- üéâ no goals
#align class_group.equiv_mk ClassGroup.equiv_mk

@[simp]
theorem ClassGroup.mk_canonicalEquiv (K' : Type*) [Field K'] [Algebra R K'] [IsFractionRing R K']
    (I : (FractionalIdeal R‚Å∞ K)À£) :
    ClassGroup.mk (Units.map (‚Üë(canonicalEquiv R‚Å∞ K K')) I : (FractionalIdeal R‚Å∞ K')À£) =
      ClassGroup.mk I := by
  rw [ClassGroup.mk, MonoidHom.comp_apply, ‚Üê MonoidHom.comp_apply (Units.map _), ‚Üê Units.map_comp, ‚Üê
      RingEquiv.coe_monoidHom_trans, FractionalIdeal.canonicalEquiv_trans_canonicalEquiv]
  rfl
  -- üéâ no goals
#align class_group.mk_canonical_equiv ClassGroup.mk_canonicalEquiv

/-- Send a nonzero integral ideal to an invertible fractional ideal. -/
noncomputable def FractionalIdeal.mk0 [IsDedekindDomain R] : (Ideal R)‚Å∞ ‚Üí* (FractionalIdeal R‚Å∞ K)À£
    where
  toFun I := Units.mk0 I (coeIdeal_ne_zero.mpr <| mem_nonZeroDivisors_iff_ne_zero.mp I.2)
  map_one' := by simp
                 -- üéâ no goals
  map_mul' x y := by simp
                     -- üéâ no goals
#align fractional_ideal.mk0 FractionalIdeal.mk0

@[simp]
theorem FractionalIdeal.coe_mk0 [IsDedekindDomain R] (I : (Ideal R)‚Å∞) :
    (FractionalIdeal.mk0 K I : FractionalIdeal R‚Å∞ K) = I := rfl
#align fractional_ideal.coe_mk0 FractionalIdeal.coe_mk0

theorem FractionalIdeal.canonicalEquiv_mk0 [IsDedekindDomain R] (K' : Type*) [Field K']
    [Algebra R K'] [IsFractionRing R K'] (I : (Ideal R)‚Å∞) :
    FractionalIdeal.canonicalEquiv R‚Å∞ K K' (FractionalIdeal.mk0 K I) = FractionalIdeal.mk0 K' I :=
  by simp only [FractionalIdeal.coe_mk0, FractionalIdeal.canonicalEquiv_coeIdeal]
     -- üéâ no goals
#align fractional_ideal.canonical_equiv_mk0 FractionalIdeal.canonicalEquiv_mk0

@[simp]
theorem FractionalIdeal.map_canonicalEquiv_mk0 [IsDedekindDomain R] (K' : Type*) [Field K']
    [Algebra R K'] [IsFractionRing R K'] (I : (Ideal R)‚Å∞) :
    Units.map (‚Üë(FractionalIdeal.canonicalEquiv R‚Å∞ K K')) (FractionalIdeal.mk0 K I) =
      FractionalIdeal.mk0 K' I :=
  Units.ext (FractionalIdeal.canonicalEquiv_mk0 K K' I)
#align fractional_ideal.map_canonical_equiv_mk0 FractionalIdeal.map_canonicalEquiv_mk0

/-- Send a nonzero ideal to the corresponding class in the class group. -/
noncomputable def ClassGroup.mk0 [IsDedekindDomain R] : (Ideal R)‚Å∞ ‚Üí* ClassGroup R :=
  ClassGroup.mk.comp (FractionalIdeal.mk0 (FractionRing R))
#align class_group.mk0 ClassGroup.mk0

@[simp]
theorem ClassGroup.mk_mk0 [IsDedekindDomain R] (I : (Ideal R)‚Å∞) :
    ClassGroup.mk (FractionalIdeal.mk0 K I) = ClassGroup.mk0 I := by
  rw [ClassGroup.mk0, MonoidHom.comp_apply, ‚Üê ClassGroup.mk_canonicalEquiv K (FractionRing R),
    FractionalIdeal.map_canonicalEquiv_mk0]
#align class_group.mk_mk0 ClassGroup.mk_mk0

@[simp]
theorem ClassGroup.equiv_mk0 [IsDedekindDomain R] (I : (Ideal R)‚Å∞) :
    ClassGroup.equiv K (ClassGroup.mk0 I) =
      QuotientGroup.mk' (toPrincipalIdeal R K).range (FractionalIdeal.mk0 K I) := by
  rw [ClassGroup.mk0, MonoidHom.comp_apply, ClassGroup.equiv_mk]
  -- ‚ä¢ ‚Üë(QuotientGroup.mk' (MonoidHom.range (toPrincipalIdeal R K))) (‚Üë(Units.mapEq ‚Ä¶
  congr 1
  -- ‚ä¢ ‚Üë(Units.mapEquiv ‚Üë(canonicalEquiv R‚Å∞ (FractionRing R) K)) (‚Üë(FractionalIdeal ‚Ä¶
  simp [‚Üê Units.eq_iff]
  -- üéâ no goals
#align class_group.equiv_mk0 ClassGroup.equiv_mk0

theorem ClassGroup.mk0_eq_mk0_iff_exists_fraction_ring [IsDedekindDomain R] {I J : (Ideal R)‚Å∞} :
    ClassGroup.mk0 I =
      ClassGroup.mk0 J ‚Üî ‚àÉ (x : _) (_ : x ‚â† (0 : K)), spanSingleton R‚Å∞ x * I = J := by
  refine (ClassGroup.equiv K).injective.eq_iff.symm.trans ?_
  -- ‚ä¢ ‚Üë(equiv K) (‚Üëmk0 I) = ‚Üë(equiv K) (‚Üëmk0 J) ‚Üî ‚àÉ x x_1, spanSingleton R‚Å∞ x * ‚Üë‚Üë ‚Ä¶
  simp only [ClassGroup.equiv_mk0, QuotientGroup.mk'_eq_mk', mem_principal_ideals_iff,
    Units.ext_iff, Units.val_mul, FractionalIdeal.coe_mk0, exists_prop]
  constructor
  -- ‚ä¢ (‚àÉ z, (‚àÉ x, spanSingleton R‚Å∞ x = ‚Üëz) ‚àß ‚Üë‚ÜëI * ‚Üëz = ‚Üë‚ÜëJ) ‚Üí ‚àÉ x, x ‚â† 0 ‚àß spanSi ‚Ä¶
  ¬∑ rintro ‚ü®X, ‚ü®x, hX‚ü©, hx‚ü©
    -- ‚ä¢ ‚àÉ x, x ‚â† 0 ‚àß spanSingleton R‚Å∞ x * ‚Üë‚ÜëI = ‚Üë‚ÜëJ
    refine ‚ü®x, ?_, ?_‚ü©
    -- ‚ä¢ x ‚â† 0
    ¬∑ rintro rfl; simp [X.ne_zero.symm] at hX
      -- ‚ä¢ False
                  -- üéâ no goals
    simpa only [hX, mul_comm] using hx
    -- üéâ no goals
  ¬∑ rintro ‚ü®x, hx, eq_J‚ü©
    -- ‚ä¢ ‚àÉ z, (‚àÉ x, spanSingleton R‚Å∞ x = ‚Üëz) ‚àß ‚Üë‚ÜëI * ‚Üëz = ‚Üë‚ÜëJ
    refine ‚ü®Units.mk0 _ (spanSingleton_ne_zero_iff.mpr hx), ‚ü®x, rfl‚ü©, ?_‚ü©
    -- ‚ä¢ ‚Üë‚ÜëI * ‚Üë(Units.mk0 (spanSingleton R‚Å∞ x) (_ : spanSingleton R‚Å∞ x ‚â† 0)) = ‚Üë‚ÜëJ
    simpa only [mul_comm] using eq_J
    -- üéâ no goals
#align class_group.mk0_eq_mk0_iff_exists_fraction_ring ClassGroup.mk0_eq_mk0_iff_exists_fraction_ring

variable {K}

theorem ClassGroup.mk0_eq_mk0_iff [IsDedekindDomain R] {I J : (Ideal R)‚Å∞} :
    ClassGroup.mk0 I = ClassGroup.mk0 J ‚Üî
      ‚àÉ (x y : R) (_hx : x ‚â† 0) (_hy : y ‚â† 0), Ideal.span {x} * (I : Ideal R) =
      Ideal.span {y} * J := by
  refine (ClassGroup.mk0_eq_mk0_iff_exists_fraction_ring (FractionRing R)).trans ‚ü®?_, ?_‚ü©
  -- ‚ä¢ (‚àÉ x x_1, spanSingleton R‚Å∞ x * ‚Üë‚ÜëI = ‚Üë‚ÜëJ) ‚Üí ‚àÉ x y _hx _hy, Ideal.span {x} *  ‚Ä¶
  ¬∑ rintro ‚ü®z, hz, h‚ü©
    -- ‚ä¢ ‚àÉ x y _hx _hy, Ideal.span {x} * ‚ÜëI = Ideal.span {y} * ‚ÜëJ
    obtain ‚ü®x, ‚ü®y, hy‚ü©, rfl‚ü© := IsLocalization.mk'_surjective R‚Å∞ z
    -- ‚ä¢ ‚àÉ x y _hx _hy, Ideal.span {x} * ‚ÜëI = Ideal.span {y} * ‚ÜëJ
    refine ‚ü®x, y, ?_, mem_nonZeroDivisors_iff_ne_zero.mp hy, ?_‚ü©
    -- ‚ä¢ x ‚â† 0
    ¬∑ rintro hx; apply hz
      -- ‚ä¢ False
                 -- ‚ä¢ mk' (FractionRing R) x { val := y, property := hy } = 0
      rw [hx, IsFractionRing.mk'_eq_div, _root_.map_zero, zero_div]
      -- üéâ no goals
    ¬∑ exact (FractionalIdeal.mk'_mul_coeIdeal_eq_coeIdeal _ hy).mp h
      -- üéâ no goals
  ¬∑ rintro ‚ü®x, y, hx, hy, h‚ü©
    -- ‚ä¢ ‚àÉ x x_1, spanSingleton R‚Å∞ x * ‚Üë‚ÜëI = ‚Üë‚ÜëJ
    have hy' : y ‚àà R‚Å∞ := mem_nonZeroDivisors_iff_ne_zero.mpr hy
    -- ‚ä¢ ‚àÉ x x_1, spanSingleton R‚Å∞ x * ‚Üë‚ÜëI = ‚Üë‚ÜëJ
    refine ‚ü®IsLocalization.mk' _ x ‚ü®y, hy'‚ü©, ?_, ?_‚ü©
    -- ‚ä¢ mk' (FractionRing R) x { val := y, property := hy' } ‚â† 0
    ¬∑ contrapose! hx
      -- ‚ä¢ x = 0
      rwa [mk'_eq_iff_eq_mul, zero_mul, ‚Üê (algebraMap R (FractionRing R)).map_zero,
        (IsFractionRing.injective R (FractionRing R)).eq_iff] at hx
    ¬∑ exact (FractionalIdeal.mk'_mul_coeIdeal_eq_coeIdeal _ hy').mpr h
      -- üéâ no goals
#align class_group.mk0_eq_mk0_iff ClassGroup.mk0_eq_mk0_iff

/-- Maps a nonzero fractional ideal to an integral representative in the class group. -/
noncomputable def ClassGroup.integralRep
    (I : FractionalIdeal R‚Å∞ (FractionRing R)) :
    Ideal R :=
  let a := I.2.choose
  { carrier := {x | (algebraMap R _ a)‚Åª¬π * algebraMap R _ x ‚àà I.1}
    add_mem' := by
      simp only [Set.mem_setOf_eq, RingHom.map_add, mul_add]
      -- ‚ä¢ ‚àÄ {a b : R}, (‚Üë(algebraMap R (FractionRing R)) (Exists.choose (_ : IsFractio ‚Ä¶
      exact fun ha hb => Submodule.add_mem _ ha hb
      -- üéâ no goals
    zero_mem' := by
      simp only [Set.mem_setOf_eq, RingHom.map_zero, mul_zero]
      -- ‚ä¢ 0 ‚àà ‚ÜëI
      exact Submodule.zero_mem _
      -- üéâ no goals
    smul_mem' := by
      intro c _ hb
      -- ‚ä¢ c ‚Ä¢ x‚úù ‚àà { toAddSubsemigroup := { carrier := {x | (‚Üë(algebraMap R (FractionR ‚Ä¶
      simp only [smul_eq_mul, Set.mem_setOf_eq, RingHom.map_mul,
        mul_left_comm ((algebraMap R (FractionRing R)) a)‚Åª¬π]
      rw [‚Üê Algebra.smul_def c]
      -- ‚ä¢ c ‚Ä¢ ((‚Üë(algebraMap R (FractionRing R)) (Exists.choose (_ : IsFractional R‚Å∞ ‚Üë ‚Ä¶
      exact Submodule.smul_mem _ c hb }
      -- üéâ no goals

theorem ClassGroup.integralRep_mem_nonZeroDivisors
    {I} (hI : I ‚â† 0) :
    ClassGroup.integralRep I ‚àà (Ideal R)‚Å∞ := by
  let a := I.2.choose
  -- ‚ä¢ integralRep I ‚àà (Ideal R)‚Å∞
  have a_ne_zero' := I.2.choose_spec.1
  -- ‚ä¢ integralRep I ‚àà (Ideal R)‚Å∞
  have a_ne_zero := mem_nonZeroDivisors_iff_ne_zero.mp a_ne_zero'
  -- ‚ä¢ integralRep I ‚àà (Ideal R)‚Å∞
  have fa_ne_zero : (algebraMap R (FractionRing R)) a ‚â† 0 :=
    IsFractionRing.to_map_ne_zero_of_mem_nonZeroDivisors a_ne_zero'
  rw [mem_nonZeroDivisors_iff_ne_zero, Submodule.zero_eq_bot, Submodule.ne_bot_iff]
  -- ‚ä¢ ‚àÉ x, x ‚àà integralRep I ‚àß x ‚â† 0
  obtain ‚ü®x, x_ne, x_mem‚ü© := exists_ne_zero_mem_isInteger hI
  -- ‚ä¢ ‚àÉ x, x ‚àà integralRep I ‚àß x ‚â† 0
  refine ‚ü®a*x, ?_, mul_ne_zero a_ne_zero x_ne‚ü©
  -- ‚ä¢ a * x ‚àà integralRep I
  change ((algebraMap R _) a)‚Åª¬π * (algebraMap R _) (a * x) ‚àà I
  -- ‚ä¢ (‚Üë(algebraMap R (FractionRing R)) a)‚Åª¬π * ‚Üë(algebraMap R (FractionRing R)) (a ‚Ä¶
  rwa [RingHom.map_mul, ‚Üê mul_assoc, inv_mul_cancel fa_ne_zero, one_mul]
  -- üéâ no goals

theorem ClassGroup.mk0_integralRep [IsDedekindDomain R]
    (I : (FractionalIdeal R‚Å∞ (FractionRing R))À£) :
    ClassGroup.mk0 ‚ü®ClassGroup.integralRep I, ClassGroup.integralRep_mem_nonZeroDivisors I.ne_zero‚ü©
      = ClassGroup.mk I := by
  let a := I.1.2.choose
  -- ‚ä¢ ‚Üëmk0 { val := integralRep ‚ÜëI, property := (_ : integralRep ‚ÜëI ‚àà (Ideal R)‚Å∞)  ‚Ä¶
  have a_ne_zero' := I.1.2.choose_spec.1
  -- ‚ä¢ ‚Üëmk0 { val := integralRep ‚ÜëI, property := (_ : integralRep ‚ÜëI ‚àà (Ideal R)‚Å∞)  ‚Ä¶
  have ha := I.1.2.choose_spec.2
  -- ‚ä¢ ‚Üëmk0 { val := integralRep ‚ÜëI, property := (_ : integralRep ‚ÜëI ‚àà (Ideal R)‚Å∞)  ‚Ä¶
  have fa_ne_zero : (algebraMap R (FractionRing R)) a ‚â† 0 :=
    IsFractionRing.to_map_ne_zero_of_mem_nonZeroDivisors a_ne_zero'
  symm
  -- ‚ä¢ ‚Üëmk I = ‚Üëmk0 { val := integralRep ‚ÜëI, property := (_ : integralRep ‚ÜëI ‚àà (Ide ‚Ä¶
  apply Quotient.sound
  -- ‚ä¢ ‚Üë(Units.map ‚Üë(canonicalEquiv R‚Å∞ (FractionRing R) (FractionRing R))) I ‚âà ‚Üë(Un ‚Ä¶
  change @Setoid.r _
    (QuotientGroup.leftRel (toPrincipalIdeal R (FractionRing R)).range) _ _
  rw [canonicalEquiv_self, RingEquiv.coe_monoidHom_refl, Units.map_id, MonoidHom.id_apply,
      MonoidHom.id_apply, QuotientGroup.leftRel_apply]
  refine ‚ü®Units.mk0 (algebraMap R _ a) fa_ne_zero, ?_‚ü©
  -- ‚ä¢ ‚Üë(toPrincipalIdeal R (FractionRing R)) (Units.mk0 (‚Üë(algebraMap R (FractionR ‚Ä¶
  rw [_root_.eq_inv_mul_iff_mul_eq, eq_comm, mul_comm I]
  -- ‚ä¢ ‚Üë(FractionalIdeal.mk0 (FractionRing R)) { val := integralRep ‚ÜëI, property := ‚Ä¶
  apply Units.ext
  -- ‚ä¢ ‚Üë(‚Üë(FractionalIdeal.mk0 (FractionRing R)) { val := integralRep ‚ÜëI, property  ‚Ä¶
  simp only [FractionalIdeal.coe_mk0, FractionalIdeal.map_canonicalEquiv_mk0,
    Units.val_mk0, coe_toPrincipalIdeal, Units.val_mul,
    FractionalIdeal.eq_spanSingleton_mul]
  constructor
  -- ‚ä¢ ‚àÄ (zI : FractionRing R), zI ‚àà ‚Üë(integralRep ‚ÜëI) ‚Üí ‚àÉ zJ, zJ ‚àà ‚ÜëI ‚àß ‚Üë(algebraM ‚Ä¶
  ¬∑ intro zJ' hzJ'
    -- ‚ä¢ ‚àÉ zJ, zJ ‚àà ‚ÜëI ‚àß ‚Üë(algebraMap R (FractionRing R)) (Exists.choose (_ : IsFract ‚Ä¶
    obtain ‚ü®zJ, hzJ, rfl‚ü© := (mem_coeIdeal R‚Å∞).mp hzJ'
    -- ‚ä¢ ‚àÉ zJ_1, zJ_1 ‚àà ‚ÜëI ‚àß ‚Üë(algebraMap R (FractionRing R)) (Exists.choose (_ : IsF ‚Ä¶
    refine ‚ü®_, hzJ, ?_‚ü©
    -- ‚ä¢ ‚Üë(algebraMap R (FractionRing R)) (Exists.choose (_ : IsFractional R‚Å∞ ‚Üë‚ÜëI)) * ‚Ä¶
    rw [‚Üê mul_assoc, mul_inv_cancel fa_ne_zero, one_mul]
    -- üéâ no goals
  ¬∑ intro zI' hzI'
    -- ‚ä¢ ‚Üë(algebraMap R (FractionRing R)) (Exists.choose (_ : IsFractional R‚Å∞ ‚Üë‚ÜëI)) * ‚Ä¶
    obtain ‚ü®y, hy‚ü© := ha zI' hzI'
    -- ‚ä¢ ‚Üë(algebraMap R (FractionRing R)) (Exists.choose (_ : IsFractional R‚Å∞ ‚Üë‚ÜëI)) * ‚Ä¶
    rw [‚Üê Algebra.smul_def, mem_coeIdeal]
    -- ‚ä¢ ‚àÉ x', x' ‚àà integralRep ‚ÜëI ‚àß ‚Üë(algebraMap R (FractionRing R)) x' = Exists.cho ‚Ä¶
    refine' ‚ü®y, _, hy‚ü©
    -- ‚ä¢ y ‚àà integralRep ‚ÜëI
    show (algebraMap R _ a)‚Åª¬π * algebraMap R _ y ‚àà (I : FractionalIdeal R‚Å∞ (FractionRing R))
    -- ‚ä¢ (‚Üë(algebraMap R (FractionRing R)) a)‚Åª¬π * ‚Üë(algebraMap R (FractionRing R)) y  ‚Ä¶
    rwa [hy, Algebra.smul_def, ‚Üê mul_assoc, inv_mul_cancel fa_ne_zero, one_mul]
    -- üéâ no goals

theorem ClassGroup.mk0_surjective [IsDedekindDomain R] :
    Function.Surjective (ClassGroup.mk0 : (Ideal R)‚Å∞ ‚Üí ClassGroup R) := by
  rintro ‚ü®I‚ü©
  -- ‚ä¢ ‚àÉ a, ‚Üëmk0 a = Quot.mk Setoid.r I
  refine ‚ü®‚ü® ClassGroup.integralRep I.1, ClassGroup.integralRep_mem_nonZeroDivisors I.ne_zero‚ü©, ?_‚ü©
  -- ‚ä¢ ‚Üëmk0 { val := integralRep ‚ÜëI, property := (_ : integralRep ‚ÜëI ‚àà (Ideal R)‚Å∞)  ‚Ä¶
  rw [ClassGroup.mk0_integralRep, ClassGroup.Quot_mk_eq_mk]
  -- üéâ no goals
#align class_group.mk0_surjective ClassGroup.mk0_surjective

theorem ClassGroup.mk_eq_one_iff {I : (FractionalIdeal R‚Å∞ K)À£} :
    ClassGroup.mk I = 1 ‚Üî (I : Submodule R K).IsPrincipal := by
  rw [‚Üê (ClassGroup.equiv K).injective.eq_iff]
  -- ‚ä¢ ‚Üë(equiv K) (‚Üëmk I) = ‚Üë(equiv K) 1 ‚Üî Submodule.IsPrincipal ‚Üë‚ÜëI
  simp only [equiv_mk, canonicalEquiv_self, RingEquiv.coe_mulEquiv_refl, QuotientGroup.mk'_apply,
    _root_.map_one, QuotientGroup.eq_one_iff, MonoidHom.mem_range, ext_iff, coe_toPrincipalIdeal,
    coe_mapEquiv, MulEquiv.refl_apply]
  refine ‚ü®fun ‚ü®x, hx‚ü© => ‚ü®‚ü®x, by rw [‚Üê hx, coe_spanSingleton]‚ü©‚ü©, ?_‚ü©
  -- ‚ä¢ Submodule.IsPrincipal ‚Üë‚ÜëI ‚Üí ‚àÉ x, spanSingleton R‚Å∞ ‚Üëx = ‚ÜëI
  intro hI
  -- ‚ä¢ ‚àÉ x, spanSingleton R‚Å∞ ‚Üëx = ‚ÜëI
  obtain ‚ü®x, hx‚ü© := @Submodule.IsPrincipal.principal _ _ _ _ _ _ hI
  -- ‚ä¢ ‚àÉ x, spanSingleton R‚Å∞ ‚Üëx = ‚ÜëI
  have hx' : (I : FractionalIdeal R‚Å∞ K) = spanSingleton R‚Å∞ x := by
    apply Subtype.coe_injective
    simp only [val_eq_coe, hx, coe_spanSingleton]
  refine ‚ü®Units.mk0 x ?_, ?_‚ü©
  -- ‚ä¢ x ‚â† 0
  ¬∑ intro x_eq; apply Units.ne_zero I; simp [hx', x_eq]
    -- ‚ä¢ False
                -- ‚ä¢ ‚ÜëI = 0
                                       -- üéâ no goals
  ¬∑ simp [hx']
    -- üéâ no goals
#align class_group.mk_eq_one_iff ClassGroup.mk_eq_one_iff

theorem ClassGroup.mk0_eq_one_iff [IsDedekindDomain R] {I : Ideal R} (hI : I ‚àà (Ideal R)‚Å∞) :
    ClassGroup.mk0 ‚ü®I, hI‚ü© = 1 ‚Üî I.IsPrincipal :=
  ClassGroup.mk_eq_one_iff.trans (coeSubmodule_isPrincipal R _)
#align class_group.mk0_eq_one_iff ClassGroup.mk0_eq_one_iff

/-- The class group of principal ideal domain is finite (in fact a singleton).

See `ClassGroup.fintypeOfAdmissibleOfFinite` for a finiteness proof that works for rings of integers
of global fields.
-/
noncomputable instance [IsPrincipalIdealRing R] : Fintype (ClassGroup R) where
  elems := {1}
  complete := by
    refine ClassGroup.induction (R := R) (FractionRing R) (fun I => ?_)
    -- ‚ä¢ ‚ÜëClassGroup.mk I ‚àà {1}
    rw [Finset.mem_singleton]
    -- ‚ä¢ ‚ÜëClassGroup.mk I = 1
    exact ClassGroup.mk_eq_one_iff.mpr (I : FractionalIdeal R‚Å∞ (FractionRing R)).isPrincipal
    -- üéâ no goals

/-- The class number of a principal ideal domain is `1`. -/
theorem card_classGroup_eq_one [IsPrincipalIdealRing R] : Fintype.card (ClassGroup R) = 1 := by
  rw [Fintype.card_eq_one_iff]
  -- ‚ä¢ ‚àÉ x, ‚àÄ (y : ClassGroup R), y = x
  use 1
  -- ‚ä¢ ‚àÄ (y : ClassGroup R), y = 1
  refine ClassGroup.induction (R := R) (FractionRing R) (fun I => ?_)
  -- ‚ä¢ ‚ÜëClassGroup.mk I = 1
  exact ClassGroup.mk_eq_one_iff.mpr (I : FractionalIdeal R‚Å∞ (FractionRing R)).isPrincipal
  -- üéâ no goals
#align card_class_group_eq_one card_classGroup_eq_one

/-- The class number is `1` iff the ring of integers is a principal ideal domain. -/
theorem card_classGroup_eq_one_iff [IsDedekindDomain R] [Fintype (ClassGroup R)] :
    Fintype.card (ClassGroup R) = 1 ‚Üî IsPrincipalIdealRing R := by
  constructor; swap; ¬∑ intros; convert card_classGroup_eq_one (R := R)
  -- ‚ä¢ Fintype.card (ClassGroup R) = 1 ‚Üí IsPrincipalIdealRing R
               -- ‚ä¢ IsPrincipalIdealRing R ‚Üí Fintype.card (ClassGroup R) = 1
                       -- ‚ä¢ Fintype.card (ClassGroup R) = 1
                               -- üéâ no goals
  rw [Fintype.card_eq_one_iff]
  -- ‚ä¢ (‚àÉ x, ‚àÄ (y : ClassGroup R), y = x) ‚Üí IsPrincipalIdealRing R
  rintro ‚ü®I, hI‚ü©
  -- ‚ä¢ IsPrincipalIdealRing R
  have eq_one : ‚àÄ J : ClassGroup R, J = 1 := fun J => (hI J).trans (hI 1).symm
  -- ‚ä¢ IsPrincipalIdealRing R
  refine ‚ü®fun I => ?_‚ü©
  -- ‚ä¢ Submodule.IsPrincipal I
  by_cases hI : I = ‚ä•
  -- ‚ä¢ Submodule.IsPrincipal I
  ¬∑ rw [hI]; exact bot_isPrincipal
    -- ‚ä¢ Submodule.IsPrincipal ‚ä•
             -- üéâ no goals
  ¬∑ exact (ClassGroup.mk0_eq_one_iff (mem_nonZeroDivisors_iff_ne_zero.mpr hI)).mp (eq_one _)
    -- üéâ no goals
#align card_class_group_eq_one_iff card_classGroup_eq_one_iff
