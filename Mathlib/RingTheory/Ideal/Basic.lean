/-
Copyright (c) 2018 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau, Chris Hughes, Mario Carneiro
-/
import Mathlib.Algebra.Associated
import Mathlib.LinearAlgebra.Basic
import Mathlib.Order.Atoms
import Mathlib.Order.CompactlyGenerated
import Mathlib.Tactic.Abel
import Mathlib.Data.Nat.Choose.Sum
import Mathlib.LinearAlgebra.Finsupp

#align_import ring_theory.ideal.basic from "leanprover-community/mathlib"@"dc6c365e751e34d100e80fe6e314c3c3e0fd2988"

/-!

# Ideals over a ring

This file defines `Ideal R`, the type of (left) ideals over a ring `R`.
Note that over commutative rings, left ideals and two-sided ideals are equivalent.

## Implementation notes

`Ideal R` is implemented using `Submodule R R`, where `‚Ä¢` is interpreted as `*`.

## TODO

Support right ideals, and two-sided ideals over non-commutative rings.
-/


universe u v w

variable {Œ± : Type u} {Œ≤ : Type v}

open Set Function

open BigOperators Pointwise

/-- A (left) ideal in a semiring `R` is an additive submonoid `s` such that
`a * b ‚àà s` whenever `b ‚àà s`. If `R` is a ring, then `s` is an additive subgroup.  -/
@[reducible]
def Ideal (R : Type u) [Semiring R] :=
  Submodule R R
#align ideal Ideal

section Semiring

namespace Ideal

variable [Semiring Œ±] (I : Ideal Œ±) {a b : Œ±}

protected theorem zero_mem : (0 : Œ±) ‚àà I :=
  Submodule.zero_mem I
#align ideal.zero_mem Ideal.zero_mem

protected theorem add_mem : a ‚àà I ‚Üí b ‚àà I ‚Üí a + b ‚àà I :=
  Submodule.add_mem I
#align ideal.add_mem Ideal.add_mem

variable (a)

theorem mul_mem_left : b ‚àà I ‚Üí a * b ‚àà I :=
  Submodule.smul_mem I a
#align ideal.mul_mem_left Ideal.mul_mem_left

variable {a}

@[ext]
theorem ext {I J : Ideal Œ±} (h : ‚àÄ x, x ‚àà I ‚Üî x ‚àà J) : I = J :=
  Submodule.ext h
#align ideal.ext Ideal.ext

theorem sum_mem (I : Ideal Œ±) {Œπ : Type*} {t : Finset Œπ} {f : Œπ ‚Üí Œ±} :
    (‚àÄ c ‚àà t, f c ‚àà I) ‚Üí (‚àë i in t, f i) ‚àà I :=
  Submodule.sum_mem I
#align ideal.sum_mem Ideal.sum_mem

theorem eq_top_of_unit_mem (x y : Œ±) (hx : x ‚àà I) (h : y * x = 1) : I = ‚ä§ :=
  eq_top_iff.2 fun z _ =>
    calc
      z = z * (y * x) := by simp [h]
                            -- üéâ no goals
      _ = z * y * x := Eq.symm <| mul_assoc z y x
      _ ‚àà I := I.mul_mem_left _ hx
#align ideal.eq_top_of_unit_mem Ideal.eq_top_of_unit_mem

theorem eq_top_of_isUnit_mem {x} (hx : x ‚àà I) (h : IsUnit x) : I = ‚ä§ :=
  let ‚ü®y, hy‚ü© := h.exists_left_inv
  eq_top_of_unit_mem I x y hx hy
#align ideal.eq_top_of_is_unit_mem Ideal.eq_top_of_isUnit_mem

theorem eq_top_iff_one : I = ‚ä§ ‚Üî (1 : Œ±) ‚àà I :=
  ‚ü®by rintro rfl; trivial, fun h => eq_top_of_unit_mem _ _ 1 h (by simp)‚ü©
      -- ‚ä¢ 1 ‚àà ‚ä§
                  -- üéâ no goals
                                                                   -- üéâ no goals
#align ideal.eq_top_iff_one Ideal.eq_top_iff_one

theorem ne_top_iff_one : I ‚â† ‚ä§ ‚Üî (1 : Œ±) ‚àâ I :=
  not_congr I.eq_top_iff_one
#align ideal.ne_top_iff_one Ideal.ne_top_iff_one

@[simp]
theorem unit_mul_mem_iff_mem {x y : Œ±} (hy : IsUnit y) : y * x ‚àà I ‚Üî x ‚àà I := by
  refine' ‚ü®fun h => _, fun h => I.mul_mem_left y h‚ü©
  -- ‚ä¢ x ‚àà I
  obtain ‚ü®y', hy'‚ü© := hy.exists_left_inv
  -- ‚ä¢ x ‚àà I
  have := I.mul_mem_left y' h
  -- ‚ä¢ x ‚àà I
  rwa [‚Üê mul_assoc, hy', one_mul] at this
  -- üéâ no goals
#align ideal.unit_mul_mem_iff_mem Ideal.unit_mul_mem_iff_mem

/-- The ideal generated by a subset of a ring -/
def span (s : Set Œ±) : Ideal Œ± :=
  Submodule.span Œ± s
#align ideal.span Ideal.span

@[simp]
theorem submodule_span_eq {s : Set Œ±} : Submodule.span Œ± s = Ideal.span s :=
  rfl
#align ideal.submodule_span_eq Ideal.submodule_span_eq

@[simp]
theorem span_empty : span (‚àÖ : Set Œ±) = ‚ä• :=
  Submodule.span_empty
#align ideal.span_empty Ideal.span_empty

@[simp]
theorem span_univ : span (Set.univ : Set Œ±) = ‚ä§ :=
  Submodule.span_univ
#align ideal.span_univ Ideal.span_univ

theorem span_union (s t : Set Œ±) : span (s ‚à™ t) = span s ‚äî span t :=
  Submodule.span_union _ _
#align ideal.span_union Ideal.span_union

theorem span_iUnion {Œπ} (s : Œπ ‚Üí Set Œ±) : span (‚ãÉ i, s i) = ‚®Ü i, span (s i) :=
  Submodule.span_iUnion _
#align ideal.span_Union Ideal.span_iUnion

theorem mem_span {s : Set Œ±} (x) : x ‚àà span s ‚Üî ‚àÄ p : Ideal Œ±, s ‚äÜ p ‚Üí x ‚àà p :=
  mem_iInter‚ÇÇ
#align ideal.mem_span Ideal.mem_span

theorem subset_span {s : Set Œ±} : s ‚äÜ span s :=
  Submodule.subset_span
#align ideal.subset_span Ideal.subset_span

theorem span_le {s : Set Œ±} {I} : span s ‚â§ I ‚Üî s ‚äÜ I :=
  Submodule.span_le
#align ideal.span_le Ideal.span_le

theorem span_mono {s t : Set Œ±} : s ‚äÜ t ‚Üí span s ‚â§ span t :=
  Submodule.span_mono
#align ideal.span_mono Ideal.span_mono

@[simp]
theorem span_eq : span (I : Set Œ±) = I :=
  Submodule.span_eq _
#align ideal.span_eq Ideal.span_eq

@[simp]
theorem span_singleton_one : span ({1} : Set Œ±) = ‚ä§ :=
  (eq_top_iff_one _).2 <| subset_span <| mem_singleton _
#align ideal.span_singleton_one Ideal.span_singleton_one

theorem mem_span_insert {s : Set Œ±} {x y} :
    x ‚àà span (insert y s) ‚Üî ‚àÉ a, ‚àÉ z ‚àà span s, x = a * y + z :=
  Submodule.mem_span_insert
#align ideal.mem_span_insert Ideal.mem_span_insert

theorem mem_span_singleton' {x y : Œ±} : x ‚àà span ({y} : Set Œ±) ‚Üî ‚àÉ a, a * y = x :=
  Submodule.mem_span_singleton
#align ideal.mem_span_singleton' Ideal.mem_span_singleton'

theorem span_singleton_le_iff_mem {x : Œ±} : span {x} ‚â§ I ‚Üî x ‚àà I :=
  Submodule.span_singleton_le_iff_mem _ _
#align ideal.span_singleton_le_iff_mem Ideal.span_singleton_le_iff_mem

theorem span_singleton_mul_left_unit {a : Œ±} (h2 : IsUnit a) (x : Œ±) :
    span ({a * x} : Set Œ±) = span {x} := by
  apply le_antisymm <;> rw [span_singleton_le_iff_mem, mem_span_singleton']
  -- ‚ä¢ span {a * x} ‚â§ span {x}
                        -- ‚ä¢ ‚àÉ a_1, a_1 * x = a * x
                        -- ‚ä¢ ‚àÉ a_1, a_1 * (a * x) = x
  exacts [‚ü®a, rfl‚ü©, ‚ü®_, h2.unit.inv_mul_cancel_left x‚ü©]
  -- üéâ no goals
#align ideal.span_singleton_mul_left_unit Ideal.span_singleton_mul_left_unit

theorem span_insert (x) (s : Set Œ±) : span (insert x s) = span ({x} : Set Œ±) ‚äî span s :=
  Submodule.span_insert x s
#align ideal.span_insert Ideal.span_insert

theorem span_eq_bot {s : Set Œ±} : span s = ‚ä• ‚Üî ‚àÄ x ‚àà s, (x : Œ±) = 0 :=
  Submodule.span_eq_bot
#align ideal.span_eq_bot Ideal.span_eq_bot

@[simp]
theorem span_singleton_eq_bot {x} : span ({x} : Set Œ±) = ‚ä• ‚Üî x = 0 :=
  Submodule.span_singleton_eq_bot
#align ideal.span_singleton_eq_bot Ideal.span_singleton_eq_bot

theorem span_singleton_ne_top {Œ± : Type*} [CommSemiring Œ±] {x : Œ±} (hx : ¬¨IsUnit x) :
    Ideal.span ({x} : Set Œ±) ‚â† ‚ä§ :=
  (Ideal.ne_top_iff_one _).mpr fun h1 =>
    let ‚ü®y, hy‚ü© := Ideal.mem_span_singleton'.mp h1
    hx ‚ü®‚ü®x, y, mul_comm y x ‚ñ∏ hy, hy‚ü©, rfl‚ü©
#align ideal.span_singleton_ne_top Ideal.span_singleton_ne_top

@[simp]
theorem span_zero : span (0 : Set Œ±) = ‚ä• := by rw [‚Üê Set.singleton_zero, span_singleton_eq_bot]
                                               -- üéâ no goals
#align ideal.span_zero Ideal.span_zero

@[simp]
theorem span_one : span (1 : Set Œ±) = ‚ä§ := by rw [‚Üê Set.singleton_one, span_singleton_one]
                                              -- üéâ no goals
#align ideal.span_one Ideal.span_one

theorem span_eq_top_iff_finite (s : Set Œ±) :
    span s = ‚ä§ ‚Üî ‚àÉ s' : Finset Œ±, ‚Üës' ‚äÜ s ‚àß span (s' : Set Œ±) = ‚ä§ := by
  simp_rw [eq_top_iff_one]
  -- ‚ä¢ 1 ‚àà span s ‚Üî ‚àÉ s', ‚Üës' ‚äÜ s ‚àß 1 ‚àà span ‚Üës'
  exact ‚ü®Submodule.mem_span_finite_of_mem_span, fun ‚ü®s', h‚ÇÅ, h‚ÇÇ‚ü© => span_mono h‚ÇÅ h‚ÇÇ‚ü©
  -- üéâ no goals
#align ideal.span_eq_top_iff_finite Ideal.span_eq_top_iff_finite

theorem mem_span_singleton_sup {S : Type*} [CommSemiring S] {x y : S} {I : Ideal S} :
    x ‚àà Ideal.span {y} ‚äî I ‚Üî ‚àÉ a : S, ‚àÉ b ‚àà I, a * y + b = x := by
  rw [Submodule.mem_sup]
  -- ‚ä¢ (‚àÉ y_1, y_1 ‚àà span {y} ‚àß ‚àÉ z, z ‚àà I ‚àß y_1 + z = x) ‚Üî ‚àÉ a b, b ‚àà I ‚àß a * y +  ‚Ä¶
  constructor
  -- ‚ä¢ (‚àÉ y_1, y_1 ‚àà span {y} ‚àß ‚àÉ z, z ‚àà I ‚àß y_1 + z = x) ‚Üí ‚àÉ a b, b ‚àà I ‚àß a * y +  ‚Ä¶
  ¬∑ rintro ‚ü®ya, hya, b, hb, rfl‚ü©
    -- ‚ä¢ ‚àÉ a b_1, b_1 ‚àà I ‚àß a * y + b_1 = ya + b
    obtain ‚ü®a, rfl‚ü© := mem_span_singleton'.mp hya
    -- ‚ä¢ ‚àÉ a_1 b_1, b_1 ‚àà I ‚àß a_1 * y + b_1 = a * y + b
    exact ‚ü®a, b, hb, rfl‚ü©
    -- üéâ no goals
  ¬∑ rintro ‚ü®a, b, hb, rfl‚ü©
    -- ‚ä¢ ‚àÉ y_1, y_1 ‚àà span {y} ‚àß ‚àÉ z, z ‚àà I ‚àß y_1 + z = a * y + b
    exact ‚ü®a * y, Ideal.mem_span_singleton'.mpr ‚ü®a, rfl‚ü©, b, hb, rfl‚ü©
    -- üéâ no goals
#align ideal.mem_span_singleton_sup Ideal.mem_span_singleton_sup

/-- The ideal generated by an arbitrary binary relation.
-/
def ofRel (r : Œ± ‚Üí Œ± ‚Üí Prop) : Ideal Œ± :=
  Submodule.span Œ± { x | ‚àÉ (a b : _) (_h : r a b), x + b = a }
#align ideal.of_rel Ideal.ofRel

/-- An ideal `P` of a ring `R` is prime if `P ‚â† R` and `xy ‚àà P ‚Üí x ‚àà P ‚à® y ‚àà P` -/
class IsPrime (I : Ideal Œ±) : Prop where
  /-- The prime ideal is not the entire ring. -/
  ne_top' : I ‚â† ‚ä§
  /-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/
  mem_or_mem' : ‚àÄ {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I
#align ideal.is_prime Ideal.IsPrime

theorem isPrime_iff {I : Ideal Œ±} : IsPrime I ‚Üî I ‚â† ‚ä§ ‚àß ‚àÄ {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I :=
  ‚ü®fun h => ‚ü®h.1, h.2‚ü©, fun h => ‚ü®h.1, h.2‚ü©‚ü©
#align ideal.is_prime_iff Ideal.isPrime_iff

theorem IsPrime.ne_top {I : Ideal Œ±} (hI : I.IsPrime) : I ‚â† ‚ä§ :=
  hI.1
#align ideal.is_prime.ne_top Ideal.IsPrime.ne_top

theorem IsPrime.mem_or_mem {I : Ideal Œ±} (hI : I.IsPrime) {x y : Œ±} : x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I :=
  hI.2
#align ideal.is_prime.mem_or_mem Ideal.IsPrime.mem_or_mem

theorem IsPrime.mem_or_mem_of_mul_eq_zero {I : Ideal Œ±} (hI : I.IsPrime) {x y : Œ±} (h : x * y = 0) :
    x ‚àà I ‚à® y ‚àà I :=
  hI.mem_or_mem (h.symm ‚ñ∏ I.zero_mem)
#align ideal.is_prime.mem_or_mem_of_mul_eq_zero Ideal.IsPrime.mem_or_mem_of_mul_eq_zero

theorem IsPrime.mem_of_pow_mem {I : Ideal Œ±} (hI : I.IsPrime) {r : Œ±} (n : ‚Ñï) (H : r ^ n ‚àà I) :
    r ‚àà I := by
  induction' n with n ih
  -- ‚ä¢ r ‚àà I
  ¬∑ rw [pow_zero] at H
    -- ‚ä¢ r ‚àà I
    exact (mt (eq_top_iff_one _).2 hI.1).elim H
    -- üéâ no goals
  ¬∑ rw [pow_succ] at H
    -- ‚ä¢ r ‚àà I
    exact Or.casesOn (hI.mem_or_mem H) id ih
    -- üéâ no goals
#align ideal.is_prime.mem_of_pow_mem Ideal.IsPrime.mem_of_pow_mem

theorem not_isPrime_iff {I : Ideal Œ±} :
    ¬¨I.IsPrime ‚Üî I = ‚ä§ ‚à® ‚àÉ (x : Œ±) (_hx : x ‚àâ I) (y : Œ±) (_hy : y ‚àâ I), x * y ‚àà I := by
  simp_rw [Ideal.isPrime_iff, not_and_or, Ne.def, Classical.not_not, not_forall, not_or]
  -- ‚ä¢ (I = ‚ä§ ‚à® ‚àÉ x x_1 h, ¬¨x ‚àà I ‚àß ¬¨x_1 ‚àà I) ‚Üî I = ‚ä§ ‚à® ‚àÉ x _hx y _hy, x * y ‚àà I
  exact
    or_congr Iff.rfl
      ‚ü®fun ‚ü®x, y, hxy, hx, hy‚ü© => ‚ü®x, hx, y, hy, hxy‚ü©, fun ‚ü®x, hx, y, hy, hxy‚ü© =>
        ‚ü®x, y, hxy, hx, hy‚ü©‚ü©
#align ideal.not_is_prime_iff Ideal.not_isPrime_iff

theorem zero_ne_one_of_proper {I : Ideal Œ±} (h : I ‚â† ‚ä§) : (0 : Œ±) ‚â† 1 := fun hz =>
  I.ne_top_iff_one.1 h <| hz ‚ñ∏ I.zero_mem
#align ideal.zero_ne_one_of_proper Ideal.zero_ne_one_of_proper

theorem bot_prime {R : Type*} [Ring R] [IsDomain R] : (‚ä• : Ideal R).IsPrime :=
  ‚ü®fun h => one_ne_zero (by rwa [Ideal.eq_top_iff_one, Submodule.mem_bot] at h), fun h =>
                            -- üéâ no goals
    mul_eq_zero.mp (by simpa only [Submodule.mem_bot] using h)‚ü©
                       -- üéâ no goals
#align ideal.bot_prime Ideal.bot_prime

/-- An ideal is maximal if it is maximal in the collection of proper ideals. -/
class IsMaximal (I : Ideal Œ±) : Prop where
  /-- The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,
  and there are no other proper ideals strictly containing it. -/
  out : IsCoatom I
#align ideal.is_maximal Ideal.IsMaximal

theorem isMaximal_def {I : Ideal Œ±} : I.IsMaximal ‚Üî IsCoatom I :=
  ‚ü®fun h => h.1, fun h => ‚ü®h‚ü©‚ü©
#align ideal.is_maximal_def Ideal.isMaximal_def

theorem IsMaximal.ne_top {I : Ideal Œ±} (h : I.IsMaximal) : I ‚â† ‚ä§ :=
  (isMaximal_def.1 h).1
#align ideal.is_maximal.ne_top Ideal.IsMaximal.ne_top

theorem isMaximal_iff {I : Ideal Œ±} :
    I.IsMaximal ‚Üî (1 : Œ±) ‚àâ I ‚àß ‚àÄ (J : Ideal Œ±) (x), I ‚â§ J ‚Üí x ‚àâ I ‚Üí x ‚àà J ‚Üí (1 : Œ±) ‚àà J :=
  isMaximal_def.trans <|
    and_congr I.ne_top_iff_one <|
      forall_congr' fun J => by
        rw [lt_iff_le_not_le];
        -- ‚ä¢ I ‚â§ J ‚àß ¬¨J ‚â§ I ‚Üí J = ‚ä§ ‚Üî ‚àÄ (x : Œ±), I ‚â§ J ‚Üí ¬¨x ‚àà I ‚Üí x ‚àà J ‚Üí 1 ‚àà J
          exact
            ‚ü®fun H x h hx‚ÇÅ hx‚ÇÇ => J.eq_top_iff_one.1 <| H ‚ü®h, not_subset.2 ‚ü®_, hx‚ÇÇ, hx‚ÇÅ‚ü©‚ü©,
              fun H ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© =>
              let ‚ü®x, xJ, xI‚ü© := not_subset.1 h‚ÇÇ
              J.eq_top_iff_one.2 <| H x h‚ÇÅ xI xJ‚ü©
#align ideal.is_maximal_iff Ideal.isMaximal_iff

theorem IsMaximal.eq_of_le {I J : Ideal Œ±} (hI : I.IsMaximal) (hJ : J ‚â† ‚ä§) (IJ : I ‚â§ J) : I = J :=
  eq_iff_le_not_lt.2 ‚ü®IJ, fun h => hJ (hI.1.2 _ h)‚ü©
#align ideal.is_maximal.eq_of_le Ideal.IsMaximal.eq_of_le

instance : IsCoatomic (Ideal Œ±) := by
  apply CompleteLattice.coatomic_of_top_compact
  -- ‚ä¢ CompleteLattice.IsCompactElement ‚ä§
  rw [‚Üê span_singleton_one]
  -- ‚ä¢ CompleteLattice.IsCompactElement (span {1})
  exact Submodule.singleton_span_isCompactElement 1
  -- üéâ no goals

theorem IsMaximal.coprime_of_ne {M M' : Ideal Œ±} (hM : M.IsMaximal) (hM' : M'.IsMaximal)
    (hne : M ‚â† M') : M ‚äî M' = ‚ä§ := by
  contrapose! hne with h
  -- ‚ä¢ M = M'
  exact hM.eq_of_le hM'.ne_top (le_sup_left.trans_eq (hM'.eq_of_le h le_sup_right).symm)
  -- üéâ no goals
#align ideal.is_maximal.coprime_of_ne Ideal.IsMaximal.coprime_of_ne

/-- **Krull's theorem**: if `I` is an ideal that is not the whole ring, then it is included in some
    maximal ideal. -/
theorem exists_le_maximal (I : Ideal Œ±) (hI : I ‚â† ‚ä§) : ‚àÉ M : Ideal Œ±, M.IsMaximal ‚àß I ‚â§ M :=
  let ‚ü®m, hm‚ü© := (eq_top_or_exists_le_coatom I).resolve_left hI
  ‚ü®m, ‚ü®‚ü®hm.1‚ü©, hm.2‚ü©‚ü©
#align ideal.exists_le_maximal Ideal.exists_le_maximal

variable (Œ±)

/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/
theorem exists_maximal [Nontrivial Œ±] : ‚àÉ M : Ideal Œ±, M.IsMaximal :=
  let ‚ü®I, ‚ü®hI, _‚ü©‚ü© := exists_le_maximal (‚ä• : Ideal Œ±) bot_ne_top
  ‚ü®I, hI‚ü©
#align ideal.exists_maximal Ideal.exists_maximal

variable {Œ±}

instance [Nontrivial Œ±] : Nontrivial (Ideal Œ±) := by
  rcases@exists_maximal Œ± _ _ with ‚ü®M, hM, _‚ü©
  -- ‚ä¢ Nontrivial (Ideal Œ±)
  exact nontrivial_of_ne M ‚ä§ hM
  -- üéâ no goals

/-- If P is not properly contained in any maximal ideal then it is not properly contained
  in any proper ideal -/
theorem maximal_of_no_maximal {R : Type u} [Semiring R] {P : Ideal R}
    (hmax : ‚àÄ m : Ideal R, P < m ‚Üí ¬¨IsMaximal m) (J : Ideal R) (hPJ : P < J) : J = ‚ä§ := by
  by_contra hnonmax
  -- ‚ä¢ False
  rcases exists_le_maximal J hnonmax with ‚ü®M, hM1, hM2‚ü©
  -- ‚ä¢ False
  exact hmax M (lt_of_lt_of_le hPJ hM2) hM1
  -- üéâ no goals
#align ideal.maximal_of_no_maximal Ideal.maximal_of_no_maximal

theorem span_pair_comm {x y : Œ±} : (span {x, y} : Ideal Œ±) = span {y, x} := by
  simp only [span_insert, sup_comm]
  -- üéâ no goals
#align ideal.span_pair_comm Ideal.span_pair_comm

theorem mem_span_pair {x y z : Œ±} : z ‚àà span ({x, y} : Set Œ±) ‚Üî ‚àÉ a b, a * x + b * y = z :=
  Submodule.mem_span_pair
#align ideal.mem_span_pair Ideal.mem_span_pair

@[simp]
theorem span_pair_add_mul_left {R : Type u} [CommRing R] {x y : R} (z : R) :
    (span {x + y * z, y} : Ideal R) = span {x, y} := by
  ext
  -- ‚ä¢ x‚úù ‚àà span {x + y * z, y} ‚Üî x‚úù ‚àà span {x, y}
  rw [mem_span_pair, mem_span_pair]
  -- ‚ä¢ (‚àÉ a b, a * (x + y * z) + b * y = x‚úù) ‚Üî ‚àÉ a b, a * x + b * y = x‚úù
  exact
    ‚ü®fun ‚ü®a, b, h‚ü© =>
      ‚ü®a, b + a * z, by
        rw [‚Üê h]
        ring1‚ü©,
      fun ‚ü®a, b, h‚ü© =>
      ‚ü®a, b - a * z, by
        rw [‚Üê h]
        ring1‚ü©‚ü©
#align ideal.span_pair_add_mul_left Ideal.span_pair_add_mul_left

@[simp]
theorem span_pair_add_mul_right {R : Type u} [CommRing R] {x y : R} (z : R) :
    (span {x, y + x * z} : Ideal R) = span {x, y} := by
  rw [span_pair_comm, span_pair_add_mul_left, span_pair_comm]
  -- üéâ no goals
#align ideal.span_pair_add_mul_right Ideal.span_pair_add_mul_right

theorem IsMaximal.exists_inv {I : Ideal Œ±} (hI : I.IsMaximal) {x} (hx : x ‚àâ I) :
    ‚àÉ y, ‚àÉ i ‚àà I, y * x + i = 1 := by
  cases' isMaximal_iff.1 hI with H‚ÇÅ H‚ÇÇ
  -- ‚ä¢ ‚àÉ y i, i ‚àà I ‚àß y * x + i = 1
  rcases mem_span_insert.1
      (H‚ÇÇ (span (insert x I)) x (Set.Subset.trans (subset_insert _ _) subset_span) hx
        (subset_span (mem_insert _ _))) with
    ‚ü®y, z, hz, hy‚ü©
  refine' ‚ü®y, z, _, hy.symm‚ü©
  -- ‚ä¢ z ‚àà I
  rwa [‚Üê span_eq I]
  -- üéâ no goals
#align ideal.is_maximal.exists_inv Ideal.IsMaximal.exists_inv

section Lattice

variable {R : Type u} [Semiring R]

-- porting note: is this the right approach? or is there a better way to prove? (next 4 decls)
theorem mem_sup_left {S T : Ideal R} : ‚àÄ {x : R}, x ‚àà S ‚Üí x ‚àà S ‚äî T :=
  @le_sup_left _ _ S T
#align ideal.mem_sup_left Ideal.mem_sup_left

theorem mem_sup_right {S T : Ideal R} : ‚àÄ {x : R}, x ‚àà T ‚Üí x ‚àà S ‚äî T :=
  @le_sup_right _ _ S T
#align ideal.mem_sup_right Ideal.mem_sup_right

theorem mem_iSup_of_mem {Œπ : Sort*} {S : Œπ ‚Üí Ideal R} (i : Œπ) : ‚àÄ {x : R}, x ‚àà S i ‚Üí x ‚àà iSup S :=
  @le_iSup _ _ _ S _
#align ideal.mem_supr_of_mem Ideal.mem_iSup_of_mem

theorem mem_sSup_of_mem {S : Set (Ideal R)} {s : Ideal R} (hs : s ‚àà S) :
    ‚àÄ {x : R}, x ‚àà s ‚Üí x ‚àà sSup S :=
  @le_sSup _ _ _ _ hs
#align ideal.mem_Sup_of_mem Ideal.mem_sSup_of_mem

theorem mem_sInf {s : Set (Ideal R)} {x : R} : x ‚àà sInf s ‚Üî ‚àÄ ‚¶ÉI‚¶Ñ, I ‚àà s ‚Üí x ‚àà I :=
  ‚ü®fun hx I his => hx I ‚ü®I, iInf_pos his‚ü©, fun H _I ‚ü®_J, hij‚ü© => hij ‚ñ∏ fun _S ‚ü®hj, hS‚ü© => hS ‚ñ∏ H hj‚ü©
#align ideal.mem_Inf Ideal.mem_sInf

@[simp 1001] -- porting note: increased priority to appease `simpNF`
theorem mem_inf {I J : Ideal R} {x : R} : x ‚àà I ‚äì J ‚Üî x ‚àà I ‚àß x ‚àà J :=
  Iff.rfl
#align ideal.mem_inf Ideal.mem_inf

@[simp 1001] -- porting note: increased priority to appease `simpNF`
theorem mem_iInf {Œπ : Sort*} {I : Œπ ‚Üí Ideal R} {x : R} : x ‚àà iInf I ‚Üî ‚àÄ i, x ‚àà I i :=
  Submodule.mem_iInf _
#align ideal.mem_infi Ideal.mem_iInf

@[simp 1001] -- porting note: increased priority to appease `simpNF`
theorem mem_bot {x : R} : x ‚àà (‚ä• : Ideal R) ‚Üî x = 0 :=
  Submodule.mem_bot _
#align ideal.mem_bot Ideal.mem_bot

end Lattice

section Pi

variable (Œπ : Type v)

/-- `I^n` as an ideal of `R^n`. -/
def pi : Ideal (Œπ ‚Üí Œ±) where
  carrier := { x | ‚àÄ i, x i ‚àà I }
  zero_mem' _i := I.zero_mem
  add_mem' ha hb i := I.add_mem (ha i) (hb i)
  smul_mem' a _b hb i := I.mul_mem_left (a i) (hb i)
#align ideal.pi Ideal.pi

theorem mem_pi (x : Œπ ‚Üí Œ±) : x ‚àà I.pi Œπ ‚Üî ‚àÄ i, x i ‚àà I :=
  Iff.rfl
#align ideal.mem_pi Ideal.mem_pi

end Pi

theorem sInf_isPrime_of_isChain {s : Set (Ideal Œ±)} (hs : s.Nonempty) (hs' : IsChain (¬∑ ‚â§ ¬∑) s)
    (H : ‚àÄ p ‚àà s, Ideal.IsPrime p) : (sInf s).IsPrime :=
  ‚ü®fun e =>
    let ‚ü®x, hx‚ü© := hs
    (H x hx).ne_top (eq_top_iff.mpr (e.symm.trans_le (sInf_le hx))),
    fun e =>
    or_iff_not_imp_left.mpr fun hx => by
      rw [Ideal.mem_sInf] at hx e ‚ä¢
      -- ‚ä¢ ‚àÄ ‚¶ÉI : Ideal Œ±‚¶Ñ, I ‚àà s ‚Üí y‚úù ‚àà I
      push_neg at hx
      -- ‚ä¢ ‚àÄ ‚¶ÉI : Ideal Œ±‚¶Ñ, I ‚àà s ‚Üí y‚úù ‚àà I
      obtain ‚ü®I, hI, hI'‚ü© := hx
      -- ‚ä¢ ‚àÄ ‚¶ÉI : Ideal Œ±‚¶Ñ, I ‚àà s ‚Üí y‚úù ‚àà I
      intro J hJ
      -- ‚ä¢ y‚úù ‚àà J
      cases' hs'.total hI hJ with h h
      -- ‚ä¢ y‚úù ‚àà J
      ¬∑ exact h (((H I hI).mem_or_mem (e hI)).resolve_left hI')
        -- üéâ no goals
      ¬∑ exact ((H J hJ).mem_or_mem (e hJ)).resolve_left fun x => hI' <| h x‚ü©
        -- üéâ no goals
#align ideal.Inf_is_prime_of_is_chain Ideal.sInf_isPrime_of_isChain

end Ideal

end Semiring

section CommSemiring

variable {a b : Œ±}

-- A separate namespace definition is needed because the variables were historically in a different
-- order.
namespace Ideal

variable [CommSemiring Œ±] (I : Ideal Œ±)

@[simp]
theorem mul_unit_mem_iff_mem {x y : Œ±} (hy : IsUnit y) : x * y ‚àà I ‚Üî x ‚àà I :=
  mul_comm y x ‚ñ∏ unit_mul_mem_iff_mem I hy
#align ideal.mul_unit_mem_iff_mem Ideal.mul_unit_mem_iff_mem

theorem mem_span_singleton {x y : Œ±} : x ‚àà span ({y} : Set Œ±) ‚Üî y ‚à£ x :=
  mem_span_singleton'.trans <| exists_congr fun _ => by rw [eq_comm, mul_comm]
                                                        -- üéâ no goals
#align ideal.mem_span_singleton Ideal.mem_span_singleton

theorem mem_span_singleton_self (x : Œ±) : x ‚àà span ({x} : Set Œ±) :=
  mem_span_singleton.mpr dvd_rfl
#align ideal.mem_span_singleton_self Ideal.mem_span_singleton_self

theorem span_singleton_le_span_singleton {x y : Œ±} :
    span ({x} : Set Œ±) ‚â§ span ({y} : Set Œ±) ‚Üî y ‚à£ x :=
  span_le.trans <| singleton_subset_iff.trans mem_span_singleton
#align ideal.span_singleton_le_span_singleton Ideal.span_singleton_le_span_singleton

theorem span_singleton_eq_span_singleton {Œ± : Type u} [CommRing Œ±] [IsDomain Œ±] {x y : Œ±} :
    span ({x} : Set Œ±) = span ({y} : Set Œ±) ‚Üî Associated x y := by
  rw [‚Üê dvd_dvd_iff_associated, le_antisymm_iff, and_comm]
  -- ‚ä¢ span {y} ‚â§ span {x} ‚àß span {x} ‚â§ span {y} ‚Üî x ‚à£ y ‚àß y ‚à£ x
  apply and_congr <;> rw [span_singleton_le_span_singleton]
  -- ‚ä¢ span {y} ‚â§ span {x} ‚Üî x ‚à£ y
                      -- üéâ no goals
                      -- üéâ no goals
#align ideal.span_singleton_eq_span_singleton Ideal.span_singleton_eq_span_singleton

theorem span_singleton_mul_right_unit {a : Œ±} (h2 : IsUnit a) (x : Œ±) :
    span ({x * a} : Set Œ±) = span {x} := by rw [mul_comm, span_singleton_mul_left_unit h2]
                                            -- üéâ no goals
#align ideal.span_singleton_mul_right_unit Ideal.span_singleton_mul_right_unit

theorem span_singleton_eq_top {x} : span ({x} : Set Œ±) = ‚ä§ ‚Üî IsUnit x := by
  rw [isUnit_iff_dvd_one, ‚Üê span_singleton_le_span_singleton, span_singleton_one, eq_top_iff]
  -- üéâ no goals
#align ideal.span_singleton_eq_top Ideal.span_singleton_eq_top

theorem span_singleton_prime {p : Œ±} (hp : p ‚â† 0) : IsPrime (span ({p} : Set Œ±)) ‚Üî Prime p := by
  simp [isPrime_iff, Prime, span_singleton_eq_top, hp, mem_span_singleton]
  -- üéâ no goals
#align ideal.span_singleton_prime Ideal.span_singleton_prime

theorem IsMaximal.isPrime {I : Ideal Œ±} (H : I.IsMaximal) : I.IsPrime :=
  ‚ü®H.1.1, @fun x y hxy =>
    or_iff_not_imp_left.2 fun hx => by
      let J : Ideal Œ± := Submodule.span Œ± (insert x ‚ÜëI)
      -- ‚ä¢ y ‚àà I
      have IJ : I ‚â§ J := Set.Subset.trans (subset_insert _ _) subset_span
      -- ‚ä¢ y ‚àà I
      have xJ : x ‚àà J := Ideal.subset_span (Set.mem_insert x I)
      -- ‚ä¢ y ‚àà I
      cases' isMaximal_iff.1 H with _ oJ
      -- ‚ä¢ y ‚àà I
      specialize oJ J x IJ hx xJ
      -- ‚ä¢ y ‚àà I
      rcases Submodule.mem_span_insert.mp oJ with ‚ü®a, b, h, oe‚ü©
      -- ‚ä¢ y ‚àà I
      obtain F : y * 1 = y * (a ‚Ä¢ x + b) := congr_arg (fun g : Œ± => y * g) oe
      -- ‚ä¢ y ‚àà I
      rw [‚Üê mul_one y, F, mul_add, mul_comm, smul_eq_mul, mul_assoc]
      -- ‚ä¢ a * (x * y) + y * b ‚àà I
      refine' Submodule.add_mem I (I.mul_mem_left a hxy) (Submodule.smul_mem I y _)
      -- ‚ä¢ b ‚àà I
      rwa [Submodule.span_eq] at h‚ü©
      -- üéâ no goals
#align ideal.is_maximal.is_prime Ideal.IsMaximal.isPrime

-- see Note [lower instance priority]
instance (priority := 100) IsMaximal.isPrime' (I : Ideal Œ±) : ‚àÄ [_H : I.IsMaximal], I.IsPrime :=
  @IsMaximal.isPrime _ _ _
#align ideal.is_maximal.is_prime' Ideal.IsMaximal.isPrime'

theorem span_singleton_lt_span_singleton [CommRing Œ≤] [IsDomain Œ≤] {x y : Œ≤} :
    span ({x} : Set Œ≤) < span ({y} : Set Œ≤) ‚Üî DvdNotUnit y x := by
  rw [lt_iff_le_not_le, span_singleton_le_span_singleton, span_singleton_le_span_singleton,
    dvd_and_not_dvd_iff]
#align ideal.span_singleton_lt_span_singleton Ideal.span_singleton_lt_span_singleton

theorem factors_decreasing [CommRing Œ≤] [IsDomain Œ≤] (b‚ÇÅ b‚ÇÇ : Œ≤) (h‚ÇÅ : b‚ÇÅ ‚â† 0) (h‚ÇÇ : ¬¨IsUnit b‚ÇÇ) :
    span ({b‚ÇÅ * b‚ÇÇ} : Set Œ≤) < span {b‚ÇÅ} :=
  lt_of_le_not_le
    (Ideal.span_le.2 <| singleton_subset_iff.2 <| Ideal.mem_span_singleton.2 ‚ü®b‚ÇÇ, rfl‚ü©) fun h =>
    h‚ÇÇ <| isUnit_of_dvd_one <|
        (mul_dvd_mul_iff_left h‚ÇÅ).1 <| by rwa [mul_one, ‚Üê Ideal.span_singleton_le_span_singleton]
                                          -- üéâ no goals
#align ideal.factors_decreasing Ideal.factors_decreasing

variable (b)

theorem mul_mem_right (h : a ‚àà I) : a * b ‚àà I :=
  mul_comm b a ‚ñ∏ I.mul_mem_left b h
#align ideal.mul_mem_right Ideal.mul_mem_right

variable {b}

theorem pow_mem_of_mem (ha : a ‚àà I) (n : ‚Ñï) (hn : 0 < n) : a ^ n ‚àà I :=
  Nat.casesOn n (Not.elim (by decide))
                              -- üéâ no goals
    (fun m _hm => (pow_succ a m).symm ‚ñ∏ I.mul_mem_right (a ^ m) ha) hn
#align ideal.pow_mem_of_mem Ideal.pow_mem_of_mem

theorem IsPrime.mul_mem_iff_mem_or_mem {I : Ideal Œ±} (hI : I.IsPrime) :
    ‚àÄ {x y : Œ±}, x * y ‚àà I ‚Üî x ‚àà I ‚à® y ‚àà I := @fun x y =>
  ‚ü®hI.mem_or_mem, by
    rintro (h | h)
    -- ‚ä¢ x * y ‚àà I
    exacts [I.mul_mem_right y h, I.mul_mem_left x h]‚ü©
    -- üéâ no goals
#align ideal.is_prime.mul_mem_iff_mem_or_mem Ideal.IsPrime.mul_mem_iff_mem_or_mem

theorem IsPrime.pow_mem_iff_mem {I : Ideal Œ±} (hI : I.IsPrime) {r : Œ±} (n : ‚Ñï) (hn : 0 < n) :
    r ^ n ‚àà I ‚Üî r ‚àà I :=
  ‚ü®hI.mem_of_pow_mem n, fun hr => I.pow_mem_of_mem hr n hn‚ü©
#align ideal.is_prime.pow_mem_iff_mem Ideal.IsPrime.pow_mem_iff_mem

theorem pow_multiset_sum_mem_span_pow [DecidableEq Œ±] (s : Multiset Œ±) (n : ‚Ñï) :
    s.sum ^ (Multiset.card s * n + 1) ‚àà
    span ((s.map fun (x:Œ±) ‚Ü¶ x ^ (n + 1)).toFinset : Set Œ±) := by
  induction' s using Multiset.induction_on with a s hs
  -- ‚ä¢ Multiset.sum 0 ^ (‚ÜëMultiset.card 0 * n + 1) ‚àà span ‚Üë(Multiset.toFinset (Mult ‚Ä¶
  ¬∑ simp
    -- üéâ no goals
  simp only [Finset.coe_insert, Multiset.map_cons, Multiset.toFinset_cons, Multiset.sum_cons,
    Multiset.card_cons, add_pow]
  refine' Submodule.sum_mem _ _
  -- ‚ä¢ ‚àÄ (c : ‚Ñï), c ‚àà Finset.range ((‚ÜëMultiset.card s + 1) * n + 1 + 1) ‚Üí a ^ c * M ‚Ä¶
  intro c _hc
  -- ‚ä¢ a ^ c * Multiset.sum s ^ ((‚ÜëMultiset.card s + 1) * n + 1 - c) * ‚Üë(Nat.choose ‚Ä¶
  rw [mem_span_insert]
  -- ‚ä¢ ‚àÉ a_1 z, z ‚àà span ‚Üë(Multiset.toFinset (Multiset.map (fun x => x ^ (n + 1)) s ‚Ä¶
  by_cases h : n + 1 ‚â§ c
  -- ‚ä¢ ‚àÉ a_1 z, z ‚àà span ‚Üë(Multiset.toFinset (Multiset.map (fun x => x ^ (n + 1)) s ‚Ä¶
  ¬∑ refine' ‚ü®a ^ (c - (n + 1)) * s.sum ^ ((Multiset.card s + 1) * n + 1 - c) *
      ((Multiset.card s + 1) * n + 1).choose c, 0, Submodule.zero_mem _, _‚ü©
    rw [mul_comm _ (a ^ (n + 1))]
    -- ‚ä¢ a ^ c * Multiset.sum s ^ ((‚ÜëMultiset.card s + 1) * n + 1 - c) * ‚Üë(Nat.choose ‚Ä¶
    simp_rw [‚Üê mul_assoc]
    -- ‚ä¢ a ^ c * Multiset.sum s ^ ((‚ÜëMultiset.card s + 1) * n + 1 - c) * ‚Üë(Nat.choose ‚Ä¶
    rw [‚Üê pow_add, add_zero, add_tsub_cancel_of_le h]
    -- üéâ no goals
  ¬∑ use 0
    -- ‚ä¢ ‚àÉ z, z ‚àà span ‚Üë(Multiset.toFinset (Multiset.map (fun x => x ^ (n + 1)) s)) ‚àß ‚Ä¶
    simp_rw [zero_mul, zero_add]
    -- ‚ä¢ ‚àÉ z, z ‚àà span ‚Üë(Multiset.toFinset (Multiset.map (fun x => x ^ (n + 1)) s)) ‚àß ‚Ä¶
    refine' ‚ü®_, _, rfl‚ü©
    -- ‚ä¢ a ^ c * Multiset.sum s ^ ((‚ÜëMultiset.card s + 1) * n + 1 - c) * ‚Üë(Nat.choose ‚Ä¶
    replace h : c ‚â§ n := Nat.lt_succ_iff.mp (not_le.mp h)
    -- ‚ä¢ a ^ c * Multiset.sum s ^ ((‚ÜëMultiset.card s + 1) * n + 1 - c) * ‚Üë(Nat.choose ‚Ä¶
    have : (Multiset.card s + 1) * n + 1 - c = Multiset.card s * n + 1 + (n - c) := by
      rw [add_mul, one_mul, add_assoc, add_comm n 1, ‚Üê add_assoc, add_tsub_assoc_of_le h]
    rw [this, pow_add]
    -- ‚ä¢ a ^ c * (Multiset.sum s ^ (‚ÜëMultiset.card s * n + 1) * Multiset.sum s ^ (n - ‚Ä¶
    simp_rw [mul_assoc, mul_comm (s.sum ^ (Multiset.card s * n + 1)), ‚Üê mul_assoc]
    -- ‚ä¢ a ^ c * Multiset.sum s ^ (n - c) * ‚Üë(Nat.choose ((‚ÜëMultiset.card s + 1) * n  ‚Ä¶
    exact mul_mem_left _ _ hs
    -- üéâ no goals
#align ideal.pow_multiset_sum_mem_span_pow Ideal.pow_multiset_sum_mem_span_pow

theorem sum_pow_mem_span_pow {Œπ} (s : Finset Œπ) (f : Œπ ‚Üí Œ±) (n : ‚Ñï) :
    (‚àë i in s, f i) ^ (s.card * n + 1) ‚àà span ((fun i => f i ^ (n + 1)) '' s) := by
  classical
  simpa only [Multiset.card_map, Multiset.map_map, comp_apply, Multiset.toFinset_map,
    Finset.coe_image, Finset.val_toFinset] using pow_multiset_sum_mem_span_pow (s.1.map f) n
#align ideal.sum_pow_mem_span_pow Ideal.sum_pow_mem_span_pow

theorem span_pow_eq_top (s : Set Œ±) (hs : span s = ‚ä§) (n : ‚Ñï) :
    span ((fun (x : Œ±) => x ^ n) '' s) = ‚ä§ := by
  rw [eq_top_iff_one]
  -- ‚ä¢ 1 ‚àà span ((fun x => x ^ n) '' s)
  cases' n with n
  -- ‚ä¢ 1 ‚àà span ((fun x => x ^ Nat.zero) '' s)
  ¬∑ obtain rfl | ‚ü®x, hx‚ü© := eq_empty_or_nonempty s
    -- ‚ä¢ 1 ‚àà span ((fun x => x ^ Nat.zero) '' ‚àÖ)
    ¬∑ rw [Set.image_empty, hs]
      -- ‚ä¢ 1 ‚àà ‚ä§
      trivial
      -- üéâ no goals
    ¬∑ exact subset_span ‚ü®_, hx, pow_zero _‚ü©
      -- üéâ no goals
  rw [eq_top_iff_one, span, Finsupp.mem_span_iff_total] at hs
  -- ‚ä¢ 1 ‚àà span ((fun x => x ^ Nat.succ n) '' s)
  rcases hs with ‚ü®f, hf‚ü©
  -- ‚ä¢ 1 ‚àà span ((fun x => x ^ Nat.succ n) '' s)
  have hf : (f.support.sum fun a => f a * a) = 1 := hf -- Porting note: was `change ... at hf`
  -- ‚ä¢ 1 ‚àà span ((fun x => x ^ Nat.succ n) '' s)
  have := sum_pow_mem_span_pow f.support (fun a => f a * a) n
  -- ‚ä¢ 1 ‚àà span ((fun x => x ^ Nat.succ n) '' s)
  rw [hf, one_pow] at this
  -- ‚ä¢ 1 ‚àà span ((fun x => x ^ Nat.succ n) '' s)
  refine' span_le.mpr _ this
  -- ‚ä¢ (fun i => (‚Üëf i * ‚Üëi) ^ (n + 1)) '' ‚Üëf.support ‚äÜ ‚Üë(span ((fun x => x ^ Nat.s ‚Ä¶
  rintro _ hx
  -- ‚ä¢ a‚úù ‚àà ‚Üë(span ((fun x => x ^ Nat.succ n) '' s))
  simp_rw [Set.mem_image] at hx
  -- ‚ä¢ a‚úù ‚àà ‚Üë(span ((fun x => x ^ Nat.succ n) '' s))
  rcases hx with ‚ü®x, _, rfl‚ü©
  -- ‚ä¢ (‚Üëf x * ‚Üëx) ^ (n + 1) ‚àà ‚Üë(span ((fun x => x ^ Nat.succ n) '' s))
  have : span ({(x:Œ±) ^ (n + 1)} : Set Œ±) ‚â§ span ((fun x : Œ± => x ^ (n + 1)) '' s) := by
    rw [span_le, Set.singleton_subset_iff]
    exact subset_span ‚ü®x, x.prop, rfl‚ü©
  refine' this _
  -- ‚ä¢ (‚Üëf x * ‚Üëx) ^ (n + 1) ‚àà span {‚Üëx ^ (n + 1)}
  rw [mul_pow, mem_span_singleton]
  -- ‚ä¢ ‚Üëx ^ (n + 1) ‚à£ ‚Üëf x ^ (n + 1) * ‚Üëx ^ (n + 1)
  exact ‚ü®f x ^ (n + 1), mul_comm _ _‚ü©
  -- üéâ no goals
#align ideal.span_pow_eq_top Ideal.span_pow_eq_top

end Ideal

end CommSemiring

section Ring

namespace Ideal

variable [Ring Œ±] (I : Ideal Œ±) {a b : Œ±}

protected theorem neg_mem_iff : -a ‚àà I ‚Üî a ‚àà I :=
  Submodule.neg_mem_iff I
#align ideal.neg_mem_iff Ideal.neg_mem_iff

protected theorem add_mem_iff_left : b ‚àà I ‚Üí (a + b ‚àà I ‚Üî a ‚àà I) :=
  Submodule.add_mem_iff_left I
#align ideal.add_mem_iff_left Ideal.add_mem_iff_left

protected theorem add_mem_iff_right : a ‚àà I ‚Üí (a + b ‚àà I ‚Üî b ‚àà I) :=
  Submodule.add_mem_iff_right I
#align ideal.add_mem_iff_right Ideal.add_mem_iff_right

protected theorem sub_mem : a ‚àà I ‚Üí b ‚àà I ‚Üí a - b ‚àà I :=
  Submodule.sub_mem I
#align ideal.sub_mem Ideal.sub_mem

theorem mem_span_insert' {s : Set Œ±} {x y} : x ‚àà span (insert y s) ‚Üî ‚àÉ a, x + a * y ‚àà span s :=
  Submodule.mem_span_insert'
#align ideal.mem_span_insert' Ideal.mem_span_insert'

@[simp]
theorem span_singleton_neg (x : Œ±) : (span {-x} : Ideal Œ±) = span {x} := by
  ext
  -- ‚ä¢ x‚úù ‚àà span {-x} ‚Üî x‚úù ‚àà span {x}
  simp only [mem_span_singleton']
  -- ‚ä¢ (‚àÉ a, a * -x = x‚úù) ‚Üî ‚àÉ a, a * x = x‚úù
  exact ‚ü®fun ‚ü®y, h‚ü© => ‚ü®-y, h ‚ñ∏ neg_mul_comm y x‚ü©, fun ‚ü®y, h‚ü© => ‚ü®-y, h ‚ñ∏ neg_mul_neg y x‚ü©‚ü©
  -- üéâ no goals
#align ideal.span_singleton_neg Ideal.span_singleton_neg

end Ideal

end Ring

section DivisionSemiring

variable {K : Type u} [DivisionSemiring K] (I : Ideal K)

namespace Ideal

/-- All ideals in a division (semi)ring are trivial. -/
theorem eq_bot_or_top : I = ‚ä• ‚à® I = ‚ä§ := by
  rw [or_iff_not_imp_right]
  -- ‚ä¢ ¬¨I = ‚ä§ ‚Üí I = ‚ä•
  change _ ‚â† _ ‚Üí _
  -- ‚ä¢ I ‚â† ‚ä§ ‚Üí I = ‚ä•
  rw [Ideal.ne_top_iff_one]
  -- ‚ä¢ ¬¨1 ‚àà I ‚Üí I = ‚ä•
  intro h1
  -- ‚ä¢ I = ‚ä•
  rw [eq_bot_iff]
  -- ‚ä¢ I ‚â§ ‚ä•
  intro r hr
  -- ‚ä¢ r ‚àà ‚ä•
  by_cases H : r = 0; ¬∑ simpa
  -- ‚ä¢ r ‚àà ‚ä•
                        -- üéâ no goals
  simpa [H, h1] using I.mul_mem_left r‚Åª¬π hr
  -- üéâ no goals
#align ideal.eq_bot_or_top Ideal.eq_bot_or_top

/-- Ideals of a `DivisionSemiring` are a simple order. Thanks to the way abbreviations work,
this automatically gives an `IsSimpleModule K` instance. -/
instance isSimpleOrder : IsSimpleOrder (Ideal K) :=
  ‚ü®eq_bot_or_top‚ü©
#align ideal.is_simple_order Ideal.isSimpleOrder

theorem eq_bot_of_prime [h : I.IsPrime] : I = ‚ä• :=
  or_iff_not_imp_right.mp I.eq_bot_or_top h.1
#align ideal.eq_bot_of_prime Ideal.eq_bot_of_prime

theorem bot_isMaximal : IsMaximal (‚ä• : Ideal K) :=
  ‚ü®‚ü®fun h => absurd ((eq_top_iff_one (‚ä§ : Ideal K)).mp rfl) (by rw [‚Üê h]; simp), fun I hI =>
                                                                -- ‚ä¢ ¬¨1 ‚àà ‚ä•
                                                                          -- üéâ no goals
      or_iff_not_imp_left.mp (eq_bot_or_top I) (ne_of_gt hI)‚ü©‚ü©
#align ideal.bot_is_maximal Ideal.bot_isMaximal

end Ideal

end DivisionSemiring

section CommRing

namespace Ideal

theorem mul_sub_mul_mem {R : Type*} [CommRing R] (I : Ideal R) {a b c d : R} (h1 : a - b ‚àà I)
    (h2 : c - d ‚àà I) : a * c - b * d ‚àà I := by
  rw [show a * c - b * d = (a - b) * c + b * (c - d) by rw [sub_mul, mul_sub]; abel]
  -- ‚ä¢ (a - b) * c + b * (c - d) ‚àà I
  exact I.add_mem (I.mul_mem_right _ h1) (I.mul_mem_left _ h2)
  -- üéâ no goals
#align ideal.mul_sub_mul_mem Ideal.mul_sub_mul_mem

end Ideal

end CommRing

-- TODO: consider moving the lemmas below out of the `Ring` namespace since they are
-- about `CommSemiring`s.
namespace Ring

variable {R : Type*} [CommSemiring R]

theorem exists_not_isUnit_of_not_isField [Nontrivial R] (hf : ¬¨IsField R) :
    ‚àÉ (x : R) (_hx : x ‚â† (0 : R)), ¬¨IsUnit x := by
  have : ¬¨_ := fun h => hf ‚ü®exists_pair_ne R, mul_comm, h‚ü©
  -- ‚ä¢ ‚àÉ x _hx, ¬¨IsUnit x
  simp_rw [isUnit_iff_exists_inv]
  -- ‚ä¢ ‚àÉ x h, ¬¨‚àÉ b, x * b = 1
  push_neg at this ‚ä¢
  -- ‚ä¢ ‚àÉ x h, ‚àÄ (b : R), x * b ‚â† 1
  obtain ‚ü®x, hx, not_unit‚ü© := this
  -- ‚ä¢ ‚àÉ x h, ‚àÄ (b : R), x * b ‚â† 1
  exact ‚ü®x, hx, not_unit‚ü©
  -- üéâ no goals
#align ring.exists_not_is_unit_of_not_is_field Ring.exists_not_isUnit_of_not_isField

theorem not_isField_iff_exists_ideal_bot_lt_and_lt_top [Nontrivial R] :
    ¬¨IsField R ‚Üî ‚àÉ I : Ideal R, ‚ä• < I ‚àß I < ‚ä§ := by
  constructor
  -- ‚ä¢ ¬¨IsField R ‚Üí ‚àÉ I, ‚ä• < I ‚àß I < ‚ä§
  ¬∑ intro h
    -- ‚ä¢ ‚àÉ I, ‚ä• < I ‚àß I < ‚ä§
    obtain ‚ü®x, nz, nu‚ü© := exists_not_isUnit_of_not_isField h
    -- ‚ä¢ ‚àÉ I, ‚ä• < I ‚àß I < ‚ä§
    use Ideal.span {x}
    -- ‚ä¢ ‚ä• < Ideal.span {x} ‚àß Ideal.span {x} < ‚ä§
    rw [bot_lt_iff_ne_bot, lt_top_iff_ne_top]
    -- ‚ä¢ Ideal.span {x} ‚â† ‚ä• ‚àß Ideal.span {x} ‚â† ‚ä§
    exact ‚ü®mt Ideal.span_singleton_eq_bot.mp nz, mt Ideal.span_singleton_eq_top.mp nu‚ü©
    -- üéâ no goals
  ¬∑ rintro ‚ü®I, bot_lt, lt_top‚ü© hf
    -- ‚ä¢ False
    obtain ‚ü®x, mem, ne_zero‚ü© := SetLike.exists_of_lt bot_lt
    -- ‚ä¢ False
    rw [Submodule.mem_bot] at ne_zero
    -- ‚ä¢ False
    obtain ‚ü®y, hy‚ü© := hf.mul_inv_cancel ne_zero
    -- ‚ä¢ False
    rw [lt_top_iff_ne_top, Ne.def, Ideal.eq_top_iff_one, ‚Üê hy] at lt_top
    -- ‚ä¢ False
    exact lt_top (I.mul_mem_right _ mem)
    -- üéâ no goals
#align ring.not_is_field_iff_exists_ideal_bot_lt_and_lt_top Ring.not_isField_iff_exists_ideal_bot_lt_and_lt_top

theorem not_isField_iff_exists_prime [Nontrivial R] :
    ¬¨IsField R ‚Üî ‚àÉ p : Ideal R, p ‚â† ‚ä• ‚àß p.IsPrime :=
  not_isField_iff_exists_ideal_bot_lt_and_lt_top.trans
    ‚ü®fun ‚ü®I, bot_lt, lt_top‚ü© =>
      let ‚ü®p, hp, le_p‚ü© := I.exists_le_maximal (lt_top_iff_ne_top.mp lt_top)
      ‚ü®p, bot_lt_iff_ne_bot.mp (lt_of_lt_of_le bot_lt le_p), hp.isPrime‚ü©,
      fun ‚ü®p, ne_bot, Prime‚ü© => ‚ü®p, bot_lt_iff_ne_bot.mpr ne_bot, lt_top_iff_ne_top.mpr Prime.1‚ü©‚ü©
#align ring.not_is_field_iff_exists_prime Ring.not_isField_iff_exists_prime

/-- Also see `Ideal.isSimpleOrder` for the forward direction as an instance when `R` is a
division (semi)ring.

This result actually holds for all division semirings, but we lack the predicate to state it. -/
theorem isField_iff_isSimpleOrder_ideal : IsField R ‚Üî IsSimpleOrder (Ideal R) := by
  cases subsingleton_or_nontrivial R
  -- ‚ä¢ IsField R ‚Üî IsSimpleOrder (Ideal R)
  ¬∑ exact
      ‚ü®fun h => (not_isField_of_subsingleton _ h).elim, fun h =>
        (false_of_nontrivial_of_subsingleton <| Ideal R).elim‚ü©
  rw [‚Üê not_iff_not, Ring.not_isField_iff_exists_ideal_bot_lt_and_lt_top, ‚Üê not_iff_not]
  -- ‚ä¢ (¬¨‚àÉ I, ‚ä• < I ‚àß I < ‚ä§) ‚Üî ¬¨¬¨IsSimpleOrder (Ideal R)
  push_neg
  -- ‚ä¢ (‚àÄ (I : Ideal R), ‚ä• < I ‚Üí ¬¨I < ‚ä§) ‚Üî IsSimpleOrder (Ideal R)
  simp_rw [lt_top_iff_ne_top, bot_lt_iff_ne_bot, ‚Üê or_iff_not_imp_left, not_ne_iff]
  -- ‚ä¢ (‚àÄ (I : Ideal R), I = ‚ä• ‚à® I = ‚ä§) ‚Üî IsSimpleOrder (Ideal R)
  exact ‚ü®fun h => ‚ü®h‚ü©, fun h => h.2‚ü©
  -- üéâ no goals
#align ring.is_field_iff_is_simple_order_ideal Ring.isField_iff_isSimpleOrder_ideal

/-- When a ring is not a field, the maximal ideals are nontrivial. -/
theorem ne_bot_of_isMaximal_of_not_isField [Nontrivial R] {M : Ideal R} (max : M.IsMaximal)
    (not_field : ¬¨IsField R) : M ‚â† ‚ä• := by
  rintro h
  -- ‚ä¢ False
  rw [h] at max
  -- ‚ä¢ False
  rcases max with ‚ü®‚ü®_h1, h2‚ü©‚ü©
  -- ‚ä¢ False
  obtain ‚ü®I, hIbot, hItop‚ü© := not_isField_iff_exists_ideal_bot_lt_and_lt_top.mp not_field
  -- ‚ä¢ False
  exact ne_of_lt hItop (h2 I hIbot)
  -- üéâ no goals
#align ring.ne_bot_of_is_maximal_of_not_is_field Ring.ne_bot_of_isMaximal_of_not_isField

end Ring

namespace Ideal

variable {R : Type u} [CommRing R] [Nontrivial R]

theorem bot_lt_of_maximal (M : Ideal R) [hm : M.IsMaximal] (non_field : ¬¨IsField R) : ‚ä• < M := by
  rcases Ring.not_isField_iff_exists_ideal_bot_lt_and_lt_top.1 non_field with ‚ü®I, Ibot, Itop‚ü©
  -- ‚ä¢ ‚ä• < M
  constructor; ¬∑ simp
  -- ‚ä¢ ‚Üë‚ä• ‚äÜ ‚ÜëM
                 -- üéâ no goals
  intro mle
  -- ‚ä¢ False
  apply lt_irrefl (‚ä§ : Ideal R)
  -- ‚ä¢ ‚ä§ < ‚ä§
  have : M = ‚ä• := eq_bot_iff.mpr mle
  -- ‚ä¢ ‚ä§ < ‚ä§
  rw [‚Üêthis] at Ibot
  -- ‚ä¢ ‚ä§ < ‚ä§
  rwa [hm.1.2 I Ibot] at Itop
  -- üéâ no goals
#align ideal.bot_lt_of_maximal Ideal.bot_lt_of_maximal

end Ideal

variable {a b : Œ±}

/-- The set of non-invertible elements of a monoid. -/
def nonunits (Œ± : Type u) [Monoid Œ±] : Set Œ± :=
  { a | ¬¨IsUnit a }
#align nonunits nonunits

@[simp]
theorem mem_nonunits_iff [Monoid Œ±] : a ‚àà nonunits Œ± ‚Üî ¬¨IsUnit a :=
  Iff.rfl
#align mem_nonunits_iff mem_nonunits_iff

theorem mul_mem_nonunits_right [CommMonoid Œ±] : b ‚àà nonunits Œ± ‚Üí a * b ‚àà nonunits Œ± :=
  mt isUnit_of_mul_isUnit_right
#align mul_mem_nonunits_right mul_mem_nonunits_right

theorem mul_mem_nonunits_left [CommMonoid Œ±] : a ‚àà nonunits Œ± ‚Üí a * b ‚àà nonunits Œ± :=
  mt isUnit_of_mul_isUnit_left
#align mul_mem_nonunits_left mul_mem_nonunits_left

theorem zero_mem_nonunits [Semiring Œ±] : 0 ‚àà nonunits Œ± ‚Üî (0 : Œ±) ‚â† 1 :=
  not_congr isUnit_zero_iff
#align zero_mem_nonunits zero_mem_nonunits

@[simp 1001] -- increased priority to appease `simpNF`
theorem one_not_mem_nonunits [Monoid Œ±] : (1 : Œ±) ‚àâ nonunits Œ± :=
  not_not_intro isUnit_one
#align one_not_mem_nonunits one_not_mem_nonunits

theorem coe_subset_nonunits [Semiring Œ±] {I : Ideal Œ±} (h : I ‚â† ‚ä§) : (I : Set Œ±) ‚äÜ nonunits Œ± :=
  fun _x hx hu => h <| I.eq_top_of_isUnit_mem hx hu
#align coe_subset_nonunits coe_subset_nonunits

theorem exists_max_ideal_of_mem_nonunits [CommSemiring Œ±] (h : a ‚àà nonunits Œ±) :
    ‚àÉ I : Ideal Œ±, I.IsMaximal ‚àß a ‚àà I := by
  have : Ideal.span ({a} : Set Œ±) ‚â† ‚ä§ := by
    intro H
    rw [Ideal.span_singleton_eq_top] at H
    contradiction
  rcases Ideal.exists_le_maximal _ this with ‚ü®I, Imax, H‚ü©
  -- ‚ä¢ ‚àÉ I, Ideal.IsMaximal I ‚àß a ‚àà I
  use I, Imax
  -- ‚ä¢ a ‚àà I
  apply H
  -- ‚ä¢ a ‚àà Ideal.span {a}
  apply Ideal.subset_span
  -- ‚ä¢ a ‚àà {a}
  exact Set.mem_singleton a
  -- üéâ no goals
#align exists_max_ideal_of_mem_nonunits exists_max_ideal_of_mem_nonunits
