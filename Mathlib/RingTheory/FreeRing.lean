/-
Copyright (c) 2019 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau, Johan Commelin
-/
import Mathlib.Algebra.FreeMonoid.Basic
import Mathlib.GroupTheory.FreeAbelianGroup
import Mathlib.Algebra.MonoidAlgebra.Basic

/-!
# Free rings

The theory of the free ring over a type.

## Main definitions

* `FreeRing α` : the free (not commutative in general) ring over a type.
* `lift (f : α → R)` : the ring hom `FreeRing α →+* R` induced by `f`.
* `map (f : α → β)` : the ring hom `FreeRing α →+* FreeRing β` induced by `f`.

## Implementation details

`FreeRing α` is implemented as the free abelian group over the free monoid on `α`.

## Tags

free ring

-/


universe u v

/--
If `α` is a type, then `FreeRing α` is the free ring generated by `α`.
This is a ring equipped with a function `FreeRing.of : α → FreeRing α` which has
the following universal property: if `R` is any ring, and `f : α → R` is any function,
then this function is the composite of `FreeRing.of` and a unique ring homomorphism
`FreeRing.lift f : FreeRing α →+* R`.

A typical element of `FreeRing α` is a `ℤ`-linear combination of
formal products of elements of `α`.
For example if `x` and `y` are terms of type `α` then `3 * x * y * x - 2 * y * x + 1` is a
"typical" element of `FreeRing α`. In particular if `α` is empty
then `FreeRing α` is isomorphic to `ℤ`, and if `α` has one term `t`
then `FreeRing α` is isomorphic to the polynomial ring `ℤ[t]`.
If `α` has two or more terms then `FreeRing α` is not commutative.
One can think of `FreeRing α` as the free non-commutative polynomial ring
with coefficients in the integers and variables indexed by `α`.
-/
def FreeRing (α : Type u) : Type u :=
  MonoidAlgebra ℤ (FreeMonoid α)

noncomputable instance (α : Type u) : Ring (FreeRing α) :=
  MonoidAlgebra.ring

instance (α : Type u) : Inhabited (FreeRing α) := by
  dsimp only [FreeRing]
  infer_instance

instance (α : Type u) : Nontrivial (FreeRing α) :=
  inferInstanceAs <| Nontrivial (MonoidAlgebra _ _)

namespace FreeRing

variable {α : Type u}

/-- The canonical map from α to `FreeRing α`. -/
noncomputable def of (x : α) : FreeRing α :=
  MonoidAlgebra.of ℤ (FreeMonoid α) (FreeMonoid.of x)

theorem of_injective : Function.Injective (of : α → FreeRing α) :=
  MonoidAlgebra.of_injective.comp FreeMonoid.of_injective

@[simp]
theorem of_ne_zero (x : α) : of x ≠ 0 := MonoidAlgebra.single_ne_zero.2 Int.one_ne_zero

@[simp]
theorem zero_ne_of (x : α) : 0 ≠ of x := (of_ne_zero x).symm

@[simp]
theorem of_ne_one (x : α) : of x ≠ 1 := MonoidAlgebra.of_injective.ne <| FreeMonoid.of_ne_one _

@[simp]
theorem one_ne_of (x : α) : 1 ≠ of x := MonoidAlgebra.of_injective.ne <| FreeMonoid.one_ne_of _

@[elab_as_elim, induction_eliminator]
protected theorem induction_on {motive : FreeRing α → Prop} (z : FreeRing α)
    (neg_one : motive (-1)) (of : ∀ b, motive (of b))
    (add : ∀ x y, motive x → motive y → motive (x + y))
    (mul : ∀ x y, motive x → motive y → motive (x * y)) : motive z :=
  have neg : ∀ x, motive x → motive (-x) := fun x ih => neg_one_mul x ▸ mul _ _ neg_one ih
  have one : motive 1 := neg_neg (1 : FreeRing α) ▸ neg _ neg_one
  have zero : motive 0 := add_neg_cancel (1 : FreeRing α) ▸ add 1 (-1) one neg_one
  have intCast (n : ℤ) : motive n :=
    Int.induction_on n (by simpa using zero) (fun n ih => by simpa using add n 1 ih one)
      (fun n ih => by simpa [← sub_eq_add_neg] using add _ _ ih neg_one)
  MonoidAlgebra.induction_on z (Multiplicative.rec fun k => FreeMonoid.inductionOn k one of
    fun x y ihx ihy => by
      simpa [MonoidAlgebra.single_mul_single, FreeRing] using mul _ _ ihx ihy)
    add fun r f ih => zsmul_eq_mul f r ▸ mul r f (intCast r) ih


section lift

variable {R : Type v} [Ring R] (f : α → R)

/-- The ring homomorphism `FreeRing α →+* R` induced from a map `α → R`. -/
noncomputable def lift : (α → R) ≃ (FreeRing α →+* R) :=
  (FreeMonoid.lift.trans (MonoidAlgebra.lift ℤ (FreeMonoid α) R)).trans RingHom.equivIntAlgHom.symm

@[simp]
theorem lift_of (x : α) : lift f (of x) = f x :=
  congr_fun (lift.left_inv f) x

@[simp]
theorem lift_comp_of (f : FreeRing α →+* R) : lift (f ∘ of) = f :=
  lift.right_inv f

@[ext]
theorem hom_ext ⦃f g : FreeRing α →+* R⦄ (h : ∀ x, f (of x) = g (of x)) : f = g :=
  lift.symm.injective (funext h)

end lift

variable {β : Type v} (f : α → β)

/-- The canonical ring homomorphism `FreeRing α →+* FreeRing β` generated by a map `α → β`. -/
noncomputable def map : FreeRing α →+* FreeRing β :=
  lift <| of ∘ f

@[simp]
theorem map_of (x : α) : map f (of x) = of (f x) :=
  lift_of _ _

end FreeRing
