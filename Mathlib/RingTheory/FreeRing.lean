/-
Copyright (c) 2019 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau, Johan Commelin
-/
import Mathlib.GroupTheory.FreeAbelianGroup

#align_import ring_theory.free_ring from "leanprover-community/mathlib"@"d6814c584384ddf2825ff038e868451a7c956f31"

/-!
# Free rings

The theory of the free ring over a type.

## Main definitions

* `FreeRing Î±` : the free (not commutative in general) ring over a type.
* `lift (f : Î± â†’ R)` : the ring hom `FreeRing Î± â†’+* R` induced by `f`.
* `map (f : Î± â†’ Î²)` : the ring hom `FreeRing Î± â†’+* FreeRing Î²` induced by `f`.

## Implementation details

`FreeRing Î±` is implemented as the free abelian group over the free monoid on `Î±`.

## Tags

free ring

-/


universe u v

/-- The free ring over a type `Î±`. -/
def FreeRing (Î± : Type u) : Type u :=
  FreeAbelianGroup <| FreeMonoid Î±
#align free_ring FreeRing

instance (Î± : Type u) : Ring (FreeRing Î±) :=
  FreeAbelianGroup.ring _

instance (Î± : Type u) : Inhabited (FreeRing Î±) := by
  dsimp only [FreeRing]
  -- âŠ¢ Inhabited (FreeAbelianGroup (FreeMonoid Î±))
  infer_instance
  -- ðŸŽ‰ no goals

namespace FreeRing

variable {Î± : Type u}

/-- The canonical map from Î± to `FreeRing Î±`. -/
def of (x : Î±) : FreeRing Î± :=
  FreeAbelianGroup.of (FreeMonoid.of x)
#align free_ring.of FreeRing.of

theorem of_injective : Function.Injective (of : Î± â†’ FreeRing Î±) :=
  FreeAbelianGroup.of_injective.comp FreeMonoid.of_injective
#align free_ring.of_injective FreeRing.of_injective

@[elab_as_elim]
protected theorem induction_on {C : FreeRing Î± â†’ Prop} (z : FreeRing Î±) (hn1 : C (-1))
    (hb : âˆ€ b, C (of b)) (ha : âˆ€ x y, C x â†’ C y â†’ C (x + y)) (hm : âˆ€ x y, C x â†’ C y â†’ C (x * y)) :
    C z :=
  have hn : âˆ€ x, C x â†’ C (-x) := fun x ih => neg_one_mul x â–¸ hm _ _ hn1 ih
  have h1 : C 1 := neg_neg (1 : FreeRing Î±) â–¸ hn _ hn1
  FreeAbelianGroup.induction_on z (add_left_neg (1 : FreeRing Î±) â–¸ ha _ _ hn1 h1)
    (fun m => List.recOn m h1 fun a m ih => by
      -- porting note: in mathlib, convert was not necessary, `exact hm _ _ (hb a) ih` worked fine
      convert hm _ _ (hb a) ih
      -- âŠ¢ FreeAbelianGroup.of (a :: m) = of a * FreeAbelianGroup.of m
      rw [of, â† FreeAbelianGroup.of_mul]
      -- âŠ¢ FreeAbelianGroup.of (a :: m) = FreeAbelianGroup.of (FreeMonoid.of a * m)
      rfl)
      -- ðŸŽ‰ no goals
    (fun m ih => hn _ ih) ha
#align free_ring.induction_on FreeRing.induction_on

section lift

variable {R : Type v} [Ring R] (f : Î± â†’ R)

/-- The ring homomorphism `FreeRing Î± â†’+* R` induced from a map `Î± â†’ R`. -/
def lift : (Î± â†’ R) â‰ƒ (FreeRing Î± â†’+* R) :=
  FreeMonoid.lift.trans FreeAbelianGroup.liftMonoid
#align free_ring.lift FreeRing.lift

@[simp]
theorem lift_of (x : Î±) : lift f (of x) = f x :=
  congr_fun (lift.left_inv f) x
#align free_ring.lift_of FreeRing.lift_of

@[simp]
theorem lift_comp_of (f : FreeRing Î± â†’+* R) : lift (f âˆ˜ of) = f :=
  lift.right_inv f
#align free_ring.lift_comp_of FreeRing.lift_comp_of

@[ext]
theorem hom_ext â¦ƒf g : FreeRing Î± â†’+* Râ¦„ (h : âˆ€ x, f (of x) = g (of x)) : f = g :=
  lift.symm.injective (funext h)
#align free_ring.hom_ext FreeRing.hom_ext

end lift

variable {Î² : Type v} (f : Î± â†’ Î²)

/-- The canonical ring homomorphism `FreeRing Î± â†’+* FreeRing Î²` generated by a map `Î± â†’ Î²`. -/
def map : FreeRing Î± â†’+* FreeRing Î² :=
  lift <| of âˆ˜ f
#align free_ring.map FreeRing.map

@[simp]
theorem map_of (x : Î±) : map f (of x) = of (f x) :=
  lift_of _ _
#align free_ring.map_of FreeRing.map_of

end FreeRing
