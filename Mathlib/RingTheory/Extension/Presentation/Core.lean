/-
Copyright (c) 2025 Christian Merten. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Christian Merten
-/
module

public import Mathlib.RingTheory.Extension.Presentation.Submersive

/-!
# Presentations on subrings

In this file we establish the API for realising a presentation over a
subring of `R`. We define a property `HasCoeffs R₀` for a presentation `P` to mean
the (sub)ring `R₀` contains the coefficients of the relations of `P`.
subring `R₀` of `R` that contains the coefficients of the relations
In this case there exists a model of `S` over `R₀`, i.e., there exists an `R₀`-algebra `S₀`
such that `S` is isomorphic to `R ⊗[R₀] S₀`.

If the presentation is finite, `R₀` may be chosen as a Noetherian ring. In this case,
this API can be used to remove Noetherian hypothesis in certain cases.

-/

@[expose] public section

open TensorProduct

variable {R S ι σ : Type*} [CommRing R] [CommRing S] [Algebra R S]

variable {P : Algebra.Presentation R S ι σ}

namespace Algebra.Presentation

variable (P) in
/-- The coefficients of a presentation are the coefficients of the relations. -/
def coeffs : Set R := ⋃ (i : σ), (P.relation i).coeffs

lemma coeffs_relation_subset_coeffs (x : σ) :
    ((P.relation x).coeffs : Set R) ⊆ P.coeffs :=
  Set.subset_iUnion_of_subset x (by simp)

lemma finite_coeffs [Finite σ] : P.coeffs.Finite :=
  Set.finite_iUnion fun _ ↦ Finset.finite_toSet _

variable (P) in
/-- The core of a presentation is the subalgebra generated by the coefficients of the relations. -/
def core : Subalgebra ℤ R := Algebra.adjoin _ P.coeffs

variable (P) in
lemma coeffs_subset_core : P.coeffs ⊆ P.core := Algebra.subset_adjoin

lemma coeffs_relation_subset_core (x : σ) :
    ((P.relation x).coeffs : Set R) ⊆ P.core :=
  subset_trans (P.coeffs_relation_subset_coeffs x) P.coeffs_subset_core

variable (P) in
/-- The core coerced to a type for performance reasons. -/
def Core : Type _ := P.core

instance : CommRing P.Core := fast_instance% (inferInstanceAs <| CommRing P.core)
instance : Algebra P.Core R := fast_instance% (inferInstanceAs <| Algebra P.core R)
instance : FaithfulSMul P.Core R := inferInstanceAs <| FaithfulSMul P.core R
instance : Algebra P.Core S := fast_instance% (inferInstanceAs <| Algebra P.core S)
instance : IsScalarTower P.Core R S := inferInstanceAs <| IsScalarTower P.core R S

instance [Finite σ] : FiniteType ℤ P.Core := .adjoin_of_finite P.finite_coeffs

variable (P) in
/--
A ring `R₀` has the coefficients of the presentation `P` if the coefficients of the relations of `P`
lie in the image of `R₀` in `R`.
The smallest subring of `R` satisfying this is given by `Algebra.Presentation.Core P`.
-/
class HasCoeffs (R₀ : Type*) [CommRing R₀] [Algebra R₀ R] [Algebra R₀ S]
    [IsScalarTower R₀ R S] where
  coeffs_subset_range : P.coeffs ⊆ Set.range (algebraMap R₀ R)

instance : P.HasCoeffs P.Core where
  coeffs_subset_range := by
    refine subset_trans P.coeffs_subset_core ?_
    simp [Core, Subalgebra.algebraMap_eq]

variable (R₀ : Type*) [CommRing R₀] [Algebra R₀ R] [Algebra R₀ S] [IsScalarTower R₀ R S]
  [P.HasCoeffs R₀]

lemma coeffs_subset_range : (P.coeffs : Set R) ⊆ Set.range (algebraMap R₀ R) :=
  HasCoeffs.coeffs_subset_range

lemma HasCoeffs.of_isScalarTower {R₁ : Type*} [CommRing R₁] [Algebra R₀ R₁] [Algebra R₁ R]
    [IsScalarTower R₀ R₁ R] [Algebra R₁ S] [IsScalarTower R₁ R S] :
    P.HasCoeffs R₁ := by
  refine ⟨subset_trans (P.coeffs_subset_range R₀) ?_⟩
  simp [IsScalarTower.algebraMap_eq R₀ R₁ R, RingHom.coe_comp, Set.range_comp]

instance (s : Set R) : P.HasCoeffs (Algebra.adjoin R₀ s) := HasCoeffs.of_isScalarTower R₀

lemma HasCoeffs.coeffs_relation_mem_range (x : σ) :
    ↑(P.relation x).coeffs ⊆ Set.range (algebraMap R₀ R) :=
  subset_trans (P.coeffs_relation_subset_coeffs x) HasCoeffs.coeffs_subset_range

lemma HasCoeffs.relation_mem_range_map (x : σ) :
    P.relation x ∈ Set.range (MvPolynomial.map (algebraMap R₀ R)) := by
  rw [MvPolynomial.mem_range_map_iff_coeffs_subset]
  exact HasCoeffs.coeffs_relation_mem_range R₀ x

/-- The `r`-th relation of `P` as a polynomial in `R₀`. This is the (arbitrary) choice of a
pre-image under the map `R₀[X] → R[X]`. -/
noncomputable def relationOfHasCoeffs (r : σ) : MvPolynomial ι R₀ :=
  (HasCoeffs.relation_mem_range_map (P := P) R₀ r).choose

lemma map_relationOfHasCoeffs (r : σ) :
    MvPolynomial.map (algebraMap R₀ R) (P.relationOfHasCoeffs R₀ r) = P.relation r :=
  (HasCoeffs.relation_mem_range_map R₀ r).choose_spec

@[simp]
lemma aeval_val_relationOfHasCoeffs (r : σ) :
    MvPolynomial.aeval P.val (P.relationOfHasCoeffs R₀ r) = 0 := by
  rw [← MvPolynomial.aeval_map_algebraMap R, map_relationOfHasCoeffs, aeval_val_relation]

@[simp]
lemma algebraTensorAlgEquiv_symm_relation (r : σ) :
    (MvPolynomial.algebraTensorAlgEquiv R₀ R).symm (P.relation r) =
      1 ⊗ₜ P.relationOfHasCoeffs R₀ r := by
  rw [← map_relationOfHasCoeffs R₀, MvPolynomial.algebraTensorAlgEquiv_symm_map]

/-- The model of `S` over a `R₀` that contains the coefficients of `P` is `R₀[X]` quotiented by the
same relations. -/
abbrev ModelOfHasCoeffs : Type _ :=
  MvPolynomial ι R₀ ⧸ (Ideal.span <| Set.range (P.relationOfHasCoeffs R₀))

instance [Finite ι] [Finite σ] : Algebra.FinitePresentation R₀ (P.ModelOfHasCoeffs R₀) := by
  classical
  cases nonempty_fintype σ
  exact .quotient ⟨Finset.image (P.relationOfHasCoeffs R₀) .univ, by simp⟩

variable (P) in
/-- (Implementation detail): The underlying `AlgHom` of `tensorModelOfHasCoeffsEquiv`. -/
noncomputable def tensorModelOfHasCoeffsHom : R ⊗[R₀] P.ModelOfHasCoeffs R₀ →ₐ[R] S :=
  Algebra.TensorProduct.lift (Algebra.ofId R S)
    (Ideal.Quotient.liftₐ _ (MvPolynomial.aeval P.val) <| by
      simp_rw [← RingHom.mem_ker, ← SetLike.le_def, Ideal.span_le]
      rintro a ⟨i, rfl⟩
      simp)
    fun _ _ ↦ Commute.all _ _

@[simp]
lemma tensorModelOfHasCoeffsHom_tmul (x : R) (y : MvPolynomial ι R₀) :
    P.tensorModelOfHasCoeffsHom R₀ (x ⊗ₜ y) = algebraMap R S x * MvPolynomial.aeval P.val y :=
  rfl

variable (P) in
/-- (Implementation detail): The inverse of `tensorModelOfHasCoeffsHom`. -/
noncomputable def tensorModelOfHasCoeffsInv : S →ₐ[R] R ⊗[R₀] P.ModelOfHasCoeffs R₀ :=
  (Ideal.Quotient.liftₐ _
    ((Algebra.TensorProduct.map (.id R R) (Ideal.Quotient.mkₐ _ _)).comp
      (MvPolynomial.algebraTensorAlgEquiv R₀ R).symm.toAlgHom) <| by
    simp_rw [← RingHom.mem_ker, ← SetLike.le_def]
    rw [← P.span_range_relation_eq_ker, Ideal.span_le]
    rintro a ⟨i, rfl⟩
    simp only [AlgEquiv.toAlgHom_eq_coe, SetLike.mem_coe, RingHom.mem_ker, AlgHom.coe_comp,
      AlgHom.coe_coe, Function.comp_apply, algebraTensorAlgEquiv_symm_relation]
    simp only [TensorProduct.map_tmul, AlgHom.coe_id, id_eq, Ideal.Quotient.mkₐ_eq_mk,
      Ideal.Quotient.mk_span_range, tmul_zero]).comp
    (P.quotientEquiv.restrictScalars R).symm.toAlgHom

@[simp]
lemma tensorModelOfHasCoeffsInv_aeval_val (x : MvPolynomial ι R₀) :
    P.tensorModelOfHasCoeffsInv R₀ (MvPolynomial.aeval P.val x) =
      1 ⊗ₜ[R₀] (Ideal.Quotient.mk _ x) := by
  rw [← MvPolynomial.aeval_map_algebraMap R, ← Generators.algebraMap_apply, ← quotientEquiv_mk]
  simp [tensorModelOfHasCoeffsInv, -quotientEquiv_symm, -quotientEquiv_mk]

set_option backward.privateInPublic true in
private lemma hom_comp_inv :
    (P.tensorModelOfHasCoeffsHom R₀).comp (P.tensorModelOfHasCoeffsInv R₀) = AlgHom.id R S := by
  have h : Function.Surjective
      ((P.quotientEquiv.restrictScalars R).toAlgHom.comp (Ideal.Quotient.mkₐ _ _)) :=
    (P.quotientEquiv.restrictScalars R).surjective.comp Ideal.Quotient.mk_surjective
  simp only [← AlgHom.cancel_right h, tensorModelOfHasCoeffsInv, AlgEquiv.toAlgHom_eq_coe,
    AlgHom.id_comp]
  rw [AlgHom.comp_assoc, AlgHom.comp_assoc, ← AlgHom.comp_assoc _ _ (Ideal.Quotient.mkₐ R P.ker),
    AlgEquiv.symm_comp, AlgHom.id_comp]
  ext x
  simp

set_option backward.privateInPublic true in
private lemma inv_comp_hom :
    (P.tensorModelOfHasCoeffsInv R₀).comp (P.tensorModelOfHasCoeffsHom R₀) = AlgHom.id R _ := by
  ext x
  obtain ⟨x, rfl⟩ := Ideal.Quotient.mk_surjective x
  simp

set_option backward.privateInPublic true in
set_option backward.privateInPublic.warn false in
/-- The natural isomorphism `R ⊗[R₀] S₀ ≃ₐ[R] S`. -/
noncomputable def tensorModelOfHasCoeffsEquiv : R ⊗[R₀] P.ModelOfHasCoeffs R₀ ≃ₐ[R] S :=
  AlgEquiv.ofAlgHom (P.tensorModelOfHasCoeffsHom R₀) (P.tensorModelOfHasCoeffsInv R₀)
    (P.hom_comp_inv R₀) (P.inv_comp_hom R₀)

@[simp]
lemma tensorModelOfHasCoeffsEquiv_tmul (x : R) (y : MvPolynomial ι R₀) :
    P.tensorModelOfHasCoeffsEquiv R₀ (x ⊗ₜ y) = algebraMap R S x * MvPolynomial.aeval P.val y :=
  rfl

@[simp]
lemma tensorModelOfHasCoeffsEquiv_symm_tmul (x : MvPolynomial ι R₀) :
    (P.tensorModelOfHasCoeffsEquiv R₀).symm (MvPolynomial.aeval P.val x) =
      1 ⊗ₜ[R₀] (Ideal.Quotient.mk _ x) :=
  tensorModelOfHasCoeffsInv_aeval_val _ x

end Algebra.Presentation
namespace Algebra.PreSubmersivePresentation

variable (P : Algebra.PreSubmersivePresentation R S ι σ)
variable (R₀ : Type*) [CommRing R₀] [Algebra R₀ R] [Algebra R₀ S] [IsScalarTower R₀ R S]
  [P.HasCoeffs R₀]

/-- The presubmersive presentation on `P.ModelOfHasCoeffs R₀` provided `P.HasCoeffs R₀`. -/
@[simps!]
noncomputable def ofHasCoeffs :
    Algebra.PreSubmersivePresentation R₀ (P.ModelOfHasCoeffs R₀) ι σ where
  __ := Algebra.Presentation.naive
  map := P.map
  map_inj := P.map_inj

end Algebra.PreSubmersivePresentation

namespace Algebra.SubmersivePresentation

variable [Finite σ] (P : Algebra.SubmersivePresentation R S ι σ)

lemma exists_sum_eq_σ_jacobian_mul_σ_jacobian_inv_sub_one
    [DecidableEq σ] [Fintype σ] :
    ∃ v : σ → MvPolynomial ι R, ∑ i, v i * P.relation i =
        P.jacobiMatrix.det * P.σ ↑(P.jacobian_isUnit.unit⁻¹) - 1 := by
  have H : P.jacobiMatrix.det * P.σ ↑(P.jacobian_isUnit.unit⁻¹) - 1 ∈ P.ker := by
    simp [PreSubmersivePresentation.jacobian_eq_jacobiMatrix_det]
  rwa [← P.span_range_relation_eq_ker, Ideal.mem_span_range_iff_exists_fun] at H

/-- An arbitrarily chosen relation exhibiting the fact that `P.jacobian` is invertible. -/
noncomputable
def jacobianRelations (s : σ) : MvPolynomial ι R :=
  letI := Fintype.ofFinite σ
  letI := Classical.decEq σ
  P.exists_sum_eq_σ_jacobian_mul_σ_jacobian_inv_sub_one.choose s

lemma jacobianRelations_spec [DecidableEq σ] [Fintype σ] :
    ∑ i, P.jacobianRelations i * P.relation i =
      P.jacobiMatrix.det * P.σ ↑(P.jacobian_isUnit.unit⁻¹) - 1 := by
  delta jacobianRelations
  convert P.exists_sum_eq_σ_jacobian_mul_σ_jacobian_inv_sub_one.choose_spec

/-- The set of coefficients that is enough to descend a submersive presentation `P`. -/
def coeffs : Set R :=
  P.toPresentation.coeffs ∪ (P.σ (P.jacobian_isUnit.unit⁻¹ :)).coeffs ∪
    ⋃ i, (P.jacobianRelations i).coeffs

lemma finite_coeffs : P.coeffs.Finite :=
  .union (P.toPresentation.finite_coeffs.union (by simp))
    (.iUnion Set.finite_univ (by simp) (by simp))

lemma coeffs_toPresentation_subset_coeffs : P.toPresentation.coeffs ⊆ P.coeffs :=
  Set.subset_union_left.trans Set.subset_union_left

/-- A type class witnessing the fact that `R₀` contains enough coefficients to descend
`P` to a submersive presentation. -/
class HasCoeffs (R₀ : Type*) [CommRing R₀] [Algebra R₀ R] [Algebra R₀ S]
    [IsScalarTower R₀ R S] where
  coeffs_subset_range : P.coeffs ⊆ ↑(algebraMap R₀ R).range

variable (R₀ : Type*) [CommRing R₀] [Algebra R₀ R] [Algebra R₀ S] [IsScalarTower R₀ R S]
  [P.HasCoeffs R₀]

instance (priority := low) : P.toPresentation.HasCoeffs R₀ where
  coeffs_subset_range := P.coeffs_toPresentation_subset_coeffs.trans HasCoeffs.coeffs_subset_range

/-- The jacobian of a presentation in the smaller coefficient ring, provided `P.HasCoeffs R₀`. -/
noncomputable
def jacobianOfHasCoeffs : MvPolynomial ι R₀ :=
  letI := Classical.decEq σ
  letI := Fintype.ofFinite σ
  (P.toPreSubmersivePresentation.ofHasCoeffs R₀).jacobiMatrix.det

@[simp]
lemma map_jacobianOfHasCoeffs [Fintype σ] [DecidableEq σ] :
    (P.jacobianOfHasCoeffs R₀).map (algebraMap R₀ R) = P.jacobiMatrix.det := by
  rw [jacobianOfHasCoeffs, @RingHom.map_det]
  congr! 1
  ext1 i j
  simp [Presentation.map_relationOfHasCoeffs, ← MvPolynomial.pderiv_map,
    PreSubmersivePresentation.jacobiMatrix_apply]

@[simp]
lemma aeval_jacobianOfHasCoeffs :
    MvPolynomial.aeval P.val (P.jacobianOfHasCoeffs R₀) = P.jacobian := by
  classical
  let : Fintype σ := Fintype.ofFinite _
  rw [← MvPolynomial.aeval_map_algebraMap R, map_jacobianOfHasCoeffs,
    P.jacobian_eq_jacobiMatrix_det, Generators.algebraMap_apply]

/-- The inverse jacobian of a presentation in the smaller coefficient ring,
provided `P.HasCoeffs R₀`. -/
noncomputable
def invJacobianOfHasCoeffs : MvPolynomial ι R₀ :=
  (MvPolynomial.mem_range_map_iff_coeffs_subset.mpr
    ((Set.subset_union_right.trans Set.subset_union_left).trans
      (HasCoeffs.coeffs_subset_range (P := P)))).choose

@[simp]
lemma map_invJacobianOfHasCoeffs :
    (P.invJacobianOfHasCoeffs R₀).map (algebraMap R₀ R) = P.σ ↑(P.jacobian_isUnit.unit⁻¹) :=
  (MvPolynomial.mem_range_map_iff_coeffs_subset.mpr
    ((Set.subset_union_right.trans Set.subset_union_left).trans
      (HasCoeffs.coeffs_subset_range (P := P)))).choose_spec

@[simp]
lemma aeval_invJacobianOfHasCoeffs :
    MvPolynomial.aeval P.val (P.invJacobianOfHasCoeffs R₀) = ↑(P.jacobian_isUnit.unit⁻¹) := by
  simpa [-map_invJacobianOfHasCoeffs, MvPolynomial.aeval_map_algebraMap] using
    congr(MvPolynomial.aeval P.val $(P.map_invJacobianOfHasCoeffs R₀))

/-- An arbitrarily chosen relation exhibiting the fact that `P.jacobian` is invertible,
provided `P.HasCoeffs R₀`. -/
noncomputable
def jacobianRelationsOfHasCoeffs (i : σ) : MvPolynomial ι R₀ :=
  (MvPolynomial.mem_range_map_iff_coeffs_subset.mpr
    ((Set.subset_iUnion _ i).trans (Set.subset_union_right.trans
      (HasCoeffs.coeffs_subset_range (P := P))))).choose

@[simp]
lemma map_jacobianRelationsOfHasCoeffs (i : σ) :
    (P.jacobianRelationsOfHasCoeffs R₀ i).map (algebraMap R₀ R) = P.jacobianRelations i :=
  (MvPolynomial.mem_range_map_iff_coeffs_subset.mpr
    ((Set.subset_iUnion _ i).trans (Set.subset_union_right.trans
      (HasCoeffs.coeffs_subset_range (P := P))))).choose_spec

lemma sum_jacobianRelationsOfHasCoeffs_mul_relationOfHasCoeffs [FaithfulSMul R₀ R] [Fintype σ] :
    ∑ i, P.jacobianRelationsOfHasCoeffs R₀ i * P.relationOfHasCoeffs R₀ i =
      P.jacobianOfHasCoeffs R₀ * P.invJacobianOfHasCoeffs R₀ - 1 := by
  classical
  apply MvPolynomial.map_injective _ (FaithfulSMul.algebraMap_injective R₀ R)
  simp [P.map_relationOfHasCoeffs, jacobianRelations_spec]

/-- The submersive presentation on `P.ModelOfHasCoeffs R₀` provided `P.HasCoeffs R₀`. -/
noncomputable
def ofHasCoeffs [FaithfulSMul R₀ R] :
    Algebra.SubmersivePresentation R₀ (P.ModelOfHasCoeffs R₀) ι σ where
  __ := P.toPreSubmersivePresentation.ofHasCoeffs R₀
  jacobian_isUnit := by
    classical
    let : Fintype σ := Fintype.ofFinite _
    have := congr((Ideal.Quotient.mk _ : _ →+* P.ModelOfHasCoeffs R₀)
      $(P.sum_jacobianRelationsOfHasCoeffs_mul_relationOfHasCoeffs R₀))
    simp only [map_sum, map_mul, Ideal.Quotient.mk_span_range, mul_zero, Finset.sum_const_zero,
      map_sub, map_one, @eq_comm (P.ModelOfHasCoeffs R₀) 0, sub_eq_zero] at this
    convert IsUnit.of_mul_eq_one _ this
    rw [PreSubmersivePresentation.jacobian_eq_jacobiMatrix_det]
    simp [jacobianOfHasCoeffs]

end Algebra.SubmersivePresentation
