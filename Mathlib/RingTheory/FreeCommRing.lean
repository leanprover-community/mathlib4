/-
Copyright (c) 2019 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau, Johan Commelin
-/
import Mathlib.Data.MvPolynomial.Equiv
import Mathlib.Data.MvPolynomial.CommRing
import Mathlib.Logic.Equiv.Functor
import Mathlib.RingTheory.FreeRing

#align_import ring_theory.free_comm_ring from "leanprover-community/mathlib"@"62c0a4ef1441edb463095ea02a06e87f3dfe135c"

/-!
# Free commutative rings

The theory of the free commutative ring generated by a type `Œ±`.
It is isomorphic to the polynomial ring over ‚Ñ§ with variables
in `Œ±`

## Main definitions

* `FreeCommRing Œ±`     : the free commutative ring on a type Œ±
* `lift (f : Œ± ‚Üí R)` : the ring hom `FreeCommRing Œ± ‚Üí+* R` induced by functoriality from `f`.
* `map (f : Œ± ‚Üí Œ≤)`      : the ring hom `FreeCommRing Œ± ‚Üí*+ FreeCommRing Œ≤` induced by
                           functoriality from f.

## Main results

`FreeCommRing` has functorial properties (it is an adjoint to the forgetful functor).
In this file we have:

* `of : Œ± ‚Üí FreeCommRing Œ±`
* `lift (f : Œ± ‚Üí R) : FreeCommRing Œ± ‚Üí+* R`
* `map (f : Œ± ‚Üí Œ≤) : FreeCommRing Œ± ‚Üí+* FreeCommRing Œ≤`

* `freeCommRingEquivMvPolynomialInt : FreeCommRing Œ± ‚âÉ+* MvPolynomial Œ± ‚Ñ§` :
    `FreeCommRing Œ±` is isomorphic to a polynomial ring.



## Implementation notes

`FreeCommRing Œ±` is implemented not using `MvPolynomial` but
directly as the free abelian group on `Multiset Œ±`, the type
of monomials in this free commutative ring.

## Tags

free commutative ring, free ring
-/


noncomputable section

open Classical Polynomial

universe u v

variable (Œ± : Type u)

/-- `FreeCommRing Œ±` is the free commutative ring on the type `Œ±`. -/
def FreeCommRing (Œ± : Type u) : Type u :=
  FreeAbelianGroup <| Multiplicative <| Multiset Œ±
#align free_comm_ring FreeCommRing

--Porting note: two instances below couldn't be derived
instance FreeCommRing.instCommRing : CommRing (FreeCommRing Œ±) := by
  delta FreeCommRing; infer_instance
  -- ‚ä¢ CommRing (FreeAbelianGroup (Multiplicative (Multiset Œ±)))
                      -- üéâ no goals
#align free_comm_ring.comm_ring FreeCommRing.instCommRing

instance FreeCommRing.instInhabited : Inhabited (FreeCommRing Œ±) := by
  delta FreeCommRing; infer_instance
  -- ‚ä¢ Inhabited (FreeAbelianGroup (Multiplicative (Multiset Œ±)))
                      -- üéâ no goals
#align free_comm_ring.inhabited FreeCommRing.instInhabited

namespace FreeCommRing

variable {Œ±}

/-- The canonical map from `Œ±` to the free commutative ring on `Œ±`. -/
def of (x : Œ±) : FreeCommRing Œ± :=
  FreeAbelianGroup.of <| Multiplicative.ofAdd ({x} : Multiset Œ±)
#align free_comm_ring.of FreeCommRing.of

theorem of_injective : Function.Injective (of : Œ± ‚Üí FreeCommRing Œ±) :=
  FreeAbelianGroup.of_injective.comp fun _ _ =>
    (Multiset.coe_eq_coe.trans List.singleton_perm_singleton).mp
#align free_comm_ring.of_injective FreeCommRing.of_injective

-- Porting note: added to ease a proof in `Algebra.DirectLimit`
lemma of_cons (a : Œ±) (m : Multiset Œ±) :
  (FreeAbelianGroup.of (Multiplicative.ofAdd (a ::‚Çò m))) =
  @HMul.hMul _ (FreeCommRing Œ±) (FreeCommRing Œ±) _ (of a)
    (FreeAbelianGroup.of (Multiplicative.ofAdd m)) := by
  dsimp [FreeCommRing]
  -- ‚ä¢ FreeAbelianGroup.of (‚ÜëMultiplicative.ofAdd (a ::‚Çò m)) = of a * FreeAbelianGr ‚Ä¶
  rw [‚Üê Multiset.singleton_add, ofAdd_add,
    of, FreeAbelianGroup.of_mul_of]

@[elab_as_elim]
protected theorem induction_on {C : FreeCommRing Œ± ‚Üí Prop} (z : FreeCommRing Œ±) (hn1 : C (-1))
    (hb : ‚àÄ b, C (of b)) (ha : ‚àÄ x y, C x ‚Üí C y ‚Üí C (x + y)) (hm : ‚àÄ x y, C x ‚Üí C y ‚Üí C (x * y)) :
    C z :=
  have hn : ‚àÄ x, C x ‚Üí C (-x) := fun x ih => neg_one_mul x ‚ñ∏ hm _ _ hn1 ih
  have h1 : C 1 := neg_neg (1 : FreeCommRing Œ±) ‚ñ∏ hn _ hn1
  FreeAbelianGroup.induction_on z (add_left_neg (1 : FreeCommRing Œ±) ‚ñ∏ ha _ _ hn1 h1)
    (fun m => Multiset.induction_on m h1 fun a m ih => by
      convert hm (of a) _ (hb a) ih
      -- ‚ä¢ FreeAbelianGroup.of (a ::‚Çò m) = of a * FreeAbelianGroup.of m
      apply of_cons)
      -- üéâ no goals
    (fun m ih => hn _ ih) ha
#align free_comm_ring.induction_on FreeCommRing.induction_on

section lift

variable {R : Type v} [CommRing R] (f : Œ± ‚Üí R)

/-- A helper to implement `lift`. This is essentially `FreeCommMonoid.lift`, but this does not
currently exist. -/
private def liftToMultiset : (Œ± ‚Üí R) ‚âÉ (Multiplicative (Multiset Œ±) ‚Üí* R) where
  toFun f :=
    { toFun := fun s => (s.toAdd.map f).prod
      map_mul' := fun x y =>
        calc
          _ = Multiset.prod (Multiset.map f x + Multiset.map f y) := by
            rw [‚Üê Multiset.map_add]
            -- ‚ä¢ OneHom.toFun { toFun := fun s => Multiset.prod (Multiset.map f (‚ÜëMultiplicat ‚Ä¶
            rfl
            -- üéâ no goals
          _ = _ := Multiset.prod_add _ _
      map_one' := rfl }
  invFun F x := F (Multiplicative.ofAdd ({x} : Multiset Œ±))
  left_inv f := funext fun x => show (Multiset.map f {x}).prod = _ by simp
                                                                      -- üéâ no goals
  right_inv F := MonoidHom.ext fun x =>
    let F' := MonoidHom.toAdditive'' F
    let x' := Multiplicative.toAdd x
    show (Multiset.map (fun a => F' {a}) x').sum = F' x' by
      erw [‚Üê Multiset.map_map (fun x => F' x) (fun x => {x}), ‚Üê AddMonoidHom.map_multiset_sum]
      -- ‚ä¢ ‚ÜëF' (Multiset.sum (Multiset.map (fun x => {x}) x')) = ‚ÜëF' x'
      exact F.congr_arg (Multiset.sum_map_singleton x')
      -- üéâ no goals

/-- Lift a map `Œ± ‚Üí R` to an additive group homomorphism `FreeCommRing Œ± ‚Üí R`. -/
def lift : (Œ± ‚Üí R) ‚âÉ (FreeCommRing Œ± ‚Üí+* R) :=
  Equiv.trans liftToMultiset FreeAbelianGroup.liftMonoid
#align free_comm_ring.lift FreeCommRing.lift

@[simp]
theorem lift_of (x : Œ±) : lift f (of x) = f x :=
  (FreeAbelianGroup.lift.of _ _).trans <| mul_one _
#align free_comm_ring.lift_of FreeCommRing.lift_of

@[simp]
theorem lift_comp_of (f : FreeCommRing Œ± ‚Üí+* R) : lift (f ‚àò of) = f :=
  RingHom.ext fun x =>
    FreeCommRing.induction_on x (by rw [RingHom.map_neg, RingHom.map_one, f.map_neg, f.map_one])
                                    -- üéâ no goals
      (lift_of _) (fun x y ihx ihy => by rw [RingHom.map_add, f.map_add, ihx, ihy])
                                         -- üéâ no goals
      fun x y ihx ihy => by rw [RingHom.map_mul, f.map_mul, ihx, ihy]
                            -- üéâ no goals
#align free_comm_ring.lift_comp_of FreeCommRing.lift_comp_of

@[ext 1100]
theorem hom_ext ‚¶Éf g : FreeCommRing Œ± ‚Üí+* R‚¶Ñ (h : ‚àÄ x, f (of x) = g (of x)) : f = g :=
  lift.symm.injective (funext h)
#align free_comm_ring.hom_ext FreeCommRing.hom_ext

end lift

variable {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤)

/-- A map `f : Œ± ‚Üí Œ≤` produces a ring homomorphism `FreeCommRing Œ± ‚Üí+* FreeCommRing Œ≤`. -/
def map : FreeCommRing Œ± ‚Üí+* FreeCommRing Œ≤ :=
  lift <| of ‚àò f
#align free_comm_ring.map FreeCommRing.map

@[simp]
theorem map_of (x : Œ±) : map f (of x) = of (f x) :=
  lift_of _ _
#align free_comm_ring.map_of FreeCommRing.map_of

/-- `is_supported x s` means that all monomials showing up in `x` have variables in `s`. -/
def IsSupported (x : FreeCommRing Œ±) (s : Set Œ±) : Prop :=
  x ‚àà Subring.closure (of '' s)
#align free_comm_ring.is_supported FreeCommRing.IsSupported

section IsSupported

variable {x y : FreeCommRing Œ±} {s t : Set Œ±}

theorem isSupported_upwards (hs : IsSupported x s) (hst : s ‚äÜ t) : IsSupported x t :=
  Subring.closure_mono (Set.monotone_image hst) hs
#align free_comm_ring.is_supported_upwards FreeCommRing.isSupported_upwards

theorem isSupported_add (hxs : IsSupported x s) (hys : IsSupported y s) : IsSupported (x + y) s :=
  Subring.add_mem _ hxs hys
#align free_comm_ring.is_supported_add FreeCommRing.isSupported_add

theorem isSupported_neg (hxs : IsSupported x s) : IsSupported (-x) s :=
  Subring.neg_mem _ hxs
#align free_comm_ring.is_supported_neg FreeCommRing.isSupported_neg

theorem isSupported_sub (hxs : IsSupported x s) (hys : IsSupported y s) : IsSupported (x - y) s :=
  Subring.sub_mem _ hxs hys
#align free_comm_ring.is_supported_sub FreeCommRing.isSupported_sub

theorem isSupported_mul (hxs : IsSupported x s) (hys : IsSupported y s) : IsSupported (x * y) s :=
  Subring.mul_mem _ hxs hys
#align free_comm_ring.is_supported_mul FreeCommRing.isSupported_mul

theorem isSupported_zero : IsSupported 0 s :=
  Subring.zero_mem _
#align free_comm_ring.is_supported_zero FreeCommRing.isSupported_zero

theorem isSupported_one : IsSupported 1 s :=
  Subring.one_mem _
#align free_comm_ring.is_supported_one FreeCommRing.isSupported_one

theorem isSupported_int {i : ‚Ñ§} {s : Set Œ±} : IsSupported (‚Üëi) s :=
  Int.induction_on i isSupported_zero
    (fun i hi => by rw [Int.cast_add, Int.cast_one]; exact isSupported_add hi isSupported_one)
                    -- ‚ä¢ IsSupported (‚Üë‚Üëi + 1) s
                                                     -- üéâ no goals
    fun i hi => by rw [Int.cast_sub, Int.cast_one]; exact isSupported_sub hi isSupported_one
                   -- ‚ä¢ IsSupported (‚Üë(-‚Üëi) - 1) s
                                                    -- üéâ no goals
#align free_comm_ring.is_supported_int FreeCommRing.isSupported_int

end IsSupported

/-- The restriction map from `FreeCommRing Œ±` to `FreeCommRing s` where `s : Set Œ±`, defined
  by sending all variables not in `s` to zero. -/
def restriction (s : Set Œ±) [DecidablePred (¬∑ ‚àà s)] : FreeCommRing Œ± ‚Üí+* FreeCommRing s :=
  lift (fun a => if H : a ‚àà s then of ‚ü®a, H‚ü© else 0)
#align free_comm_ring.restriction FreeCommRing.restriction

section Restriction

variable (s : Set Œ±) [DecidablePred (¬∑ ‚àà s)] (x y : FreeCommRing Œ±)

@[simp]
theorem restriction_of (p) : restriction s (of p) = if H : p ‚àà s then of ‚ü®p, H‚ü© else 0 :=
  lift_of _ _
#align free_comm_ring.restriction_of FreeCommRing.restriction_of

end Restriction

theorem isSupported_of {p} {s : Set Œ±} : IsSupported (of p) s ‚Üî p ‚àà s :=
  suffices IsSupported (of p) s ‚Üí p ‚àà s from ‚ü®this, fun hps => Subring.subset_closure ‚ü®p, hps, rfl‚ü©‚ü©
  fun hps : IsSupported (of p) s => by
  haveI := Classical.decPred s
  -- ‚ä¢ p ‚àà s
  have : ‚àÄ x, IsSupported x s ‚Üí
        ‚àÉ n : ‚Ñ§, lift (fun a => if a ‚àà s then (0 : ‚Ñ§[X]) else Polynomial.X) x = n := by
    intro x hx
    refine' Subring.InClosure.recOn hx _ _ _ _
    ¬∑ use 1
      rw [RingHom.map_one]
      norm_cast
    ¬∑ use -1
      rw [RingHom.map_neg, RingHom.map_one, Int.cast_neg, Int.cast_one]
    ¬∑ rintro _ ‚ü®z, hzs, rfl‚ü© _ _
      use 0
      rw [RingHom.map_mul, lift_of, if_pos hzs, zero_mul]
      norm_cast
    ¬∑ rintro x y ‚ü®q, hq‚ü© ‚ü®r, hr‚ü©
      refine' ‚ü®q + r, _‚ü©
      rw [RingHom.map_add, hq, hr]
      norm_cast
  specialize this (of p) hps
  -- ‚ä¢ p ‚àà s
  rw [lift_of] at this
  -- ‚ä¢ p ‚àà s
  split_ifs at this with h
  -- ‚ä¢ p ‚àà s
  ¬∑ exact h
    -- üéâ no goals
  exfalso
  -- ‚ä¢ False
  apply Ne.symm Int.zero_ne_one
  -- ‚ä¢ 1 = 0
  rcases this with ‚ü®w, H‚ü©
  -- ‚ä¢ 1 = 0
  rw [‚Üê Polynomial.C_eq_int_cast] at H
  -- ‚ä¢ 1 = 0
  have : Polynomial.X.coeff 1 = (Polynomial.C ‚Üëw).coeff 1 := by rw [H]; rfl
  -- ‚ä¢ 1 = 0
  rwa [Polynomial.coeff_C, if_neg (one_ne_zero : 1 ‚â† 0), Polynomial.coeff_X, if_pos rfl] at this
  -- üéâ no goals
#align free_comm_ring.is_supported_of FreeCommRing.isSupported_of

-- Porting note: Changed `(Subtype.val : s ‚Üí Œ±)` to `(‚Üë)` in the type
theorem map_subtype_val_restriction {x} (s : Set Œ±) [DecidablePred (¬∑ ‚àà s)]
    (hxs : IsSupported x s) : map (‚Üë) (restriction s x) = x := by
  refine' Subring.InClosure.recOn hxs _ _ _ _
  ¬∑ rw [RingHom.map_one]
    -- ‚ä¢ ‚Üë(map Subtype.val) 1 = 1
    rfl
    -- üéâ no goals
  ¬∑ rw [map_neg, map_one]
    -- ‚ä¢ ‚Üë(map Subtype.val) (-1) = -1
    rfl
    -- üéâ no goals
  ¬∑ rintro _ ‚ü®p, hps, rfl‚ü© n ih
    -- ‚ä¢ ‚Üë(map Subtype.val) (‚Üë(restriction s) (of p * n)) = of p * n
    rw [RingHom.map_mul, restriction_of, dif_pos hps, RingHom.map_mul, map_of, ih]
    -- üéâ no goals
  ¬∑ intro x y ihx ihy
    -- ‚ä¢ ‚Üë(map Subtype.val) (‚Üë(restriction s) (x + y)) = x + y
    rw [RingHom.map_add, RingHom.map_add, ihx, ihy]
    -- üéâ no goals
#align free_comm_ring.map_subtype_val_restriction FreeCommRing.map_subtype_val_restriction

theorem exists_finite_support (x : FreeCommRing Œ±) : ‚àÉ s : Set Œ±, Set.Finite s ‚àß IsSupported x s :=
  FreeCommRing.induction_on x ‚ü®‚àÖ, Set.finite_empty, isSupported_neg isSupported_one‚ü©
    (fun p => ‚ü®{p}, Set.finite_singleton p, isSupported_of.2 <| Set.mem_singleton _‚ü©)
    (fun _ _ ‚ü®s, hfs, hxs‚ü© ‚ü®t, hft, hxt‚ü© =>
      ‚ü®s ‚à™ t, hfs.union hft,
        isSupported_add (isSupported_upwards hxs <| Set.subset_union_left s t)
          (isSupported_upwards hxt <| Set.subset_union_right s t)‚ü©)
    fun _ _ ‚ü®s, hfs, hxs‚ü© ‚ü®t, hft, hxt‚ü© =>
    ‚ü®s ‚à™ t, hfs.union hft,
      isSupported_mul (isSupported_upwards hxs <| Set.subset_union_left s t)
        (isSupported_upwards hxt <| Set.subset_union_right s t)‚ü©
#align free_comm_ring.exists_finite_support FreeCommRing.exists_finite_support

theorem exists_finset_support (x : FreeCommRing Œ±) : ‚àÉ s : Finset Œ±, IsSupported x ‚Üës :=
  let ‚ü®s, hfs, hxs‚ü© := exists_finite_support x
  ‚ü®hfs.toFinset, by rwa [Set.Finite.coe_toFinset]‚ü©
                    -- üéâ no goals
#align free_comm_ring.exists_finset_support FreeCommRing.exists_finset_support

end FreeCommRing

namespace FreeRing

open Function

/-- The canonical ring homomorphism from the free ring generated by `Œ±` to the free commutative ring
    generated by `Œ±`. -/
def toFreeCommRing {Œ±} : FreeRing Œ± ‚Üí+* FreeCommRing Œ± :=
  FreeRing.lift FreeCommRing.of
#align free_ring.to_free_comm_ring FreeRing.toFreeCommRing

/-- The coercion defined by the canonical ring homomorphism from the free ring generated by `Œ±` to
the free commutative ring generated by `Œ±`. -/
@[coe] def castFreeCommRing {Œ±} : FreeRing Œ± ‚Üí FreeCommRing Œ± := toFreeCommRing

instance FreeCommRing.instCoe : Coe (FreeRing Œ±) (FreeCommRing Œ±) :=
  ‚ü®castFreeCommRing‚ü©
#align free_ring.free_comm_ring.has_coe FreeRing.FreeCommRing.instCoe

/-- The natural map `FreeRing Œ± ‚Üí FreeCommRing Œ±`, as a `RingHom`. -/
def coeRingHom : FreeRing Œ± ‚Üí+* FreeCommRing Œ± :=
  toFreeCommRing
#align free_ring.coe_ring_hom FreeRing.coeRingHom

@[simp, norm_cast]
protected theorem coe_zero : ‚Üë(0 : FreeRing Œ±) = (0 : FreeCommRing Œ±) := rfl
#align free_ring.coe_zero FreeRing.coe_zero

@[simp, norm_cast]
protected theorem coe_one : ‚Üë(1 : FreeRing Œ±) = (1 : FreeCommRing Œ±) := rfl
#align free_ring.coe_one FreeRing.coe_one

variable {Œ±}

@[simp]
protected theorem coe_of (a : Œ±) : ‚Üë(FreeRing.of a) = FreeCommRing.of a :=
  FreeRing.lift_of _ _
#align free_ring.coe_of FreeRing.coe_of

@[simp, norm_cast]
protected theorem coe_neg (x : FreeRing Œ±) : ‚Üë(-x) = -(x : FreeCommRing Œ±) := by
  rw [castFreeCommRing, map_neg]
  -- üéâ no goals
#align free_ring.coe_neg FreeRing.coe_neg

@[simp, norm_cast]
protected theorem coe_add (x y : FreeRing Œ±) : ‚Üë(x + y) = (x : FreeCommRing Œ±) + y :=
  (FreeRing.lift _).map_add _ _
#align free_ring.coe_add FreeRing.coe_add

@[simp, norm_cast]
protected theorem coe_sub (x y : FreeRing Œ±) : ‚Üë(x - y) = (x : FreeCommRing Œ±) - y := by
  rw [castFreeCommRing, map_sub]
  -- üéâ no goals
#align free_ring.coe_sub FreeRing.coe_sub

@[simp, norm_cast]
protected theorem coe_mul (x y : FreeRing Œ±) : ‚Üë(x * y) = (x : FreeCommRing Œ±) * y :=
  (FreeRing.lift _).map_mul _ _
#align free_ring.coe_mul FreeRing.coe_mul

variable (Œ±)

protected theorem coe_surjective : Surjective ((‚Üë) : FreeRing Œ± ‚Üí FreeCommRing Œ±) := fun x => by
  induction x using FreeCommRing.induction_on with
  | hn1 =>
    use -1
    rfl
  | hb b =>
    exact ‚ü®FreeRing.of b, rfl‚ü©
  | ha _ _ hx hy =>
    rcases hx with ‚ü®x, rfl‚ü©; rcases hy with ‚ü®y, rfl‚ü©
    exact ‚ü®x + y, (FreeRing.lift _).map_add _ _‚ü©
  | hm _ _ hx hy =>
    rcases hx with ‚ü®x, rfl‚ü©; rcases hy with ‚ü®y, rfl‚ü©
    exact ‚ü®x * y, (FreeRing.lift _).map_mul _ _‚ü©
#align free_ring.coe_surjective FreeRing.coe_surjective

theorem coe_eq : ((‚Üë) : FreeRing Œ± ‚Üí FreeCommRing Œ±) =
      @Functor.map FreeAbelianGroup _ _ _ fun l : List Œ± => (l : Multiset Œ±) := by
  funext x
  -- ‚ä¢ ‚Üëx = (fun l => ‚Üël) <$> x
  erw [castFreeCommRing, toFreeCommRing, FreeRing.lift, Equiv.coe_trans, Function.comp,
    FreeAbelianGroup.liftMonoid_coe (FreeMonoid.lift FreeCommRing.of)]
  dsimp [Functor.map]
  -- ‚ä¢ ‚Üë(‚ÜëFreeAbelianGroup.lift ‚Üë(‚ÜëFreeMonoid.lift FreeCommRing.of)) x = ‚Üë(‚ÜëFreeAbe ‚Ä¶
  rw [‚Üê AddMonoidHom.coe_coe]
  -- ‚ä¢ ‚Üë‚Üë(‚ÜëFreeAbelianGroup.lift ‚Üë(‚ÜëFreeMonoid.lift FreeCommRing.of)) x = ‚Üë(‚ÜëFreeAb ‚Ä¶
  apply FreeAbelianGroup.lift.unique; intro L
  -- ‚ä¢ ‚àÄ (x : FreeMonoid Œ±), ‚Üë‚Üë(‚ÜëFreeAbelianGroup.lift ‚Üë(‚ÜëFreeMonoid.lift FreeCommR ‚Ä¶
                                      -- ‚ä¢ ‚Üë‚Üë(‚ÜëFreeAbelianGroup.lift ‚Üë(‚ÜëFreeMonoid.lift FreeCommRing.of)) (FreeAbelianG ‚Ä¶
  erw [FreeAbelianGroup.lift.of, Function.comp]
  -- ‚ä¢ ‚Üë(‚ÜëFreeMonoid.lift FreeCommRing.of) L = FreeAbelianGroup.of ‚ÜëL
  exact
    FreeMonoid.recOn L rfl fun hd tl ih => by
      rw [(FreeMonoid.lift _).map_mul, FreeMonoid.lift_eval_of, ih]
      conv_lhs => reduce
#align free_ring.coe_eq FreeRing.coe_eq

/-- If Œ± has size at most 1 then the natural map from the free ring on `Œ±` to the
    free commutative ring on `Œ±` is an isomorphism of rings. -/
def subsingletonEquivFreeCommRing [Subsingleton Œ±] : FreeRing Œ± ‚âÉ+* FreeCommRing Œ± :=
  RingEquiv.ofBijective (coeRingHom _) (by
    have : (coeRingHom _ : FreeRing Œ± ‚Üí FreeCommRing Œ±) =
        Functor.mapEquiv FreeAbelianGroup (Multiset.subsingletonEquiv Œ±) :=
      coe_eq Œ±
    rw [this]
    -- ‚ä¢ Bijective ‚Üë(Functor.mapEquiv FreeAbelianGroup (Multiset.subsingletonEquiv Œ±))
    apply Equiv.bijective)
    -- üéâ no goals
#align free_ring.subsingleton_equiv_free_comm_ring FreeRing.subsingletonEquivFreeCommRing

instance instCommRing [Subsingleton Œ±] : CommRing (FreeRing Œ±) :=
  { inferInstanceAs (Ring (FreeRing Œ±)) with
    mul_comm := fun x y => by
      rw [‚Üê (subsingletonEquivFreeCommRing Œ±).symm_apply_apply (y * x),
        (subsingletonEquivFreeCommRing Œ±).map_mul, mul_comm,
        ‚Üê (subsingletonEquivFreeCommRing Œ±).map_mul,
        (subsingletonEquivFreeCommRing Œ±).symm_apply_apply] }
#align free_ring.comm_ring FreeRing.instCommRing

end FreeRing

/-- The free commutative ring on `Œ±` is isomorphic to the polynomial ring over ‚Ñ§ with
    variables in `Œ±` -/
def freeCommRingEquivMvPolynomialInt : FreeCommRing Œ± ‚âÉ+* MvPolynomial Œ± ‚Ñ§ :=
  RingEquiv.ofHomInv (FreeCommRing.lift <| (fun a => MvPolynomial.X a : Œ± ‚Üí MvPolynomial Œ± ‚Ñ§))
    (MvPolynomial.eval‚ÇÇHom (Int.castRingHom (FreeCommRing Œ±)) FreeCommRing.of)
    (by ext; simp) (by ext <;> simp)
        -- ‚ä¢ ‚Üë(RingHom.comp ‚Üë(MvPolynomial.eval‚ÇÇHom (Int.castRingHom (FreeCommRing Œ±)) Fr ‚Ä¶
             -- üéâ no goals
                       -- ‚ä¢ MvPolynomial.coeff m‚úù (‚Üë(RingHom.comp (RingHom.comp ‚Üë(‚ÜëFreeCommRing.lift fun ‚Ä¶
                               -- üéâ no goals
                               -- üéâ no goals
#align free_comm_ring_equiv_mv_polynomial_int freeCommRingEquivMvPolynomialInt

/-- The free commutative ring on the empty type is isomorphic to `‚Ñ§`. -/
def freeCommRingPemptyEquivInt : FreeCommRing PEmpty.{u + 1} ‚âÉ+* ‚Ñ§ :=
  RingEquiv.trans (freeCommRingEquivMvPolynomialInt _) (MvPolynomial.isEmptyRingEquiv _ PEmpty)
#align free_comm_ring_pempty_equiv_int freeCommRingPemptyEquivInt

/-- The free commutative ring on a type with one term is isomorphic to `‚Ñ§[X]`. -/
def freeCommRingPunitEquivPolynomialInt : FreeCommRing PUnit.{u + 1} ‚âÉ+* ‚Ñ§[X] :=
  (freeCommRingEquivMvPolynomialInt _).trans (MvPolynomial.pUnitAlgEquiv ‚Ñ§).toRingEquiv
#align free_comm_ring_punit_equiv_polynomial_int freeCommRingPunitEquivPolynomialInt

open FreeRing

/-- The free ring on the empty type is isomorphic to `‚Ñ§`. -/
def freeRingPemptyEquivInt : FreeRing PEmpty.{u + 1} ‚âÉ+* ‚Ñ§ :=
  RingEquiv.trans (subsingletonEquivFreeCommRing _) freeCommRingPemptyEquivInt
#align free_ring_pempty_equiv_int freeRingPemptyEquivInt

/-- The free ring on a type with one term is isomorphic to `‚Ñ§[X]`. -/
def freeRingPunitEquivPolynomialInt : FreeRing PUnit.{u + 1} ‚âÉ+* ‚Ñ§[X] :=
  RingEquiv.trans (subsingletonEquivFreeCommRing _) freeCommRingPunitEquivPolynomialInt
#align free_ring_punit_equiv_polynomial_int freeRingPunitEquivPolynomialInt
