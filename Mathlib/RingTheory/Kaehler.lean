/-
Copyright Â© 2020 NicolÃ² Cavalleri. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: NicolÃ² Cavalleri, Andrew Yang
-/
import Mathlib.RingTheory.Derivation.ToSquareZero
import Mathlib.RingTheory.Ideal.Cotangent
import Mathlib.RingTheory.IsTensorProduct

#align_import ring_theory.kaehler from "leanprover-community/mathlib"@"4b92a463033b5587bb011657e25e4710bfca7364"

/-!
# The module of kaehler differentials

## Main results

- `KaehlerDifferential`: The module of kaehler differentials. For an `R`-algebra `S`, we provide
  the notation `Î©[Sâ„R]` for `KaehlerDifferential R S`.
  Note that the slash is `\textfractionsolidus`.
- `KaehlerDifferential.D`: The derivation into the module of kaehler differentials.
- `KaehlerDifferential.span_range_derivation`: The image of `D` spans `Î©[Sâ„R]` as an `S`-module.
- `KaehlerDifferential.linearMapEquivDerivation`:
  The isomorphism `Hom_R(Î©[Sâ„R], M) â‰ƒâ‚—[S] Der_R(S, M)`.
- `KaehlerDifferential.quotKerTotalEquiv`: An alternative description of `Î©[Sâ„R]` as `S` copies
  of `S` with kernel (`KaehlerDifferential.kerTotal`) generated by the relations:
  1. `dx + dy = d(x + y)`
  2. `x dy + y dx = d(x * y)`
  3. `dr = 0` for `r âˆˆ R`
- `KaehlerDifferential.map`: Given a map between the arrows `R â†’ A` and `S â†’ B`, we have an
  `A`-linear map `Î©[Aâ„R] â†’ Î©[Bâ„S]`.

## Future project

- Define the `IsKaehlerDifferential` predicate.
-/

section KaehlerDifferential

open scoped TensorProduct
open Algebra

universe u v

variable (R : Type u) (S : Type v) [CommRing R] [CommRing S] [Algebra R S]

/-- The kernel of the multiplication map `S âŠ—[R] S â†’â‚[R] S`. -/
abbrev KaehlerDifferential.ideal : Ideal (S âŠ—[R] S) :=
  RingHom.ker (TensorProduct.lmul' R : S âŠ—[R] S â†’â‚[R] S)
#align kaehler_differential.ideal KaehlerDifferential.ideal

variable {S}

theorem KaehlerDifferential.one_smul_sub_smul_one_mem_ideal (a : S) :
    (1 : S) âŠ—â‚œ[R] a - a âŠ—â‚œ[R] (1 : S) âˆˆ KaehlerDifferential.ideal R S := by simp [RingHom.mem_ker]
                                                                            -- ğŸ‰ no goals
#align kaehler_differential.one_smul_sub_smul_one_mem_ideal KaehlerDifferential.one_smul_sub_smul_one_mem_ideal

variable {R}

variable {M : Type*} [AddCommGroup M] [Module R M] [Module S M] [IsScalarTower R S M]

/-- For a `R`-derivation `S â†’ M`, this is the map `S âŠ—[R] S â†’â‚—[S] M` sending `s âŠ—â‚œ t â†¦ s â€¢ D t`. -/
def Derivation.tensorProductTo (D : Derivation R S M) : S âŠ—[R] S â†’â‚—[S] M :=
  TensorProduct.AlgebraTensorModule.lift ((LinearMap.lsmul S (S â†’â‚—[R] M)).flip D.toLinearMap)
#align derivation.tensor_product_to Derivation.tensorProductTo

theorem Derivation.tensorProductTo_tmul (D : Derivation R S M) (s t : S) :
    D.tensorProductTo (s âŠ—â‚œ t) = s â€¢ D t := rfl
#align derivation.tensor_product_to_tmul Derivation.tensorProductTo_tmul

theorem Derivation.tensorProductTo_mul (D : Derivation R S M) (x y : S âŠ—[R] S) :
    D.tensorProductTo (x * y) =
      TensorProduct.lmul' (S := S) R x â€¢ D.tensorProductTo y +
        TensorProduct.lmul' (S := S) R y â€¢ D.tensorProductTo x := by
  refine TensorProduct.induction_on x ?_ ?_ ?_
  Â· rw [zero_mul, map_zero, map_zero, zero_smul, smul_zero, add_zero]
    -- ğŸ‰ no goals
  swap
  -- âŠ¢ âˆ€ (x y_1 : S âŠ—[R] S), â†‘(tensorProductTo D) (x * y) = â†‘(TensorProduct.lmul' R â€¦
  Â· intro xâ‚ yâ‚ hâ‚ hâ‚‚
    -- âŠ¢ â†‘(tensorProductTo D) ((xâ‚ + yâ‚) * y) = â†‘(TensorProduct.lmul' R) (xâ‚ + yâ‚) â€¢  â€¦
    rw [add_mul, map_add, map_add, map_add, add_smul, smul_add, hâ‚, hâ‚‚, add_add_add_comm]
    -- ğŸ‰ no goals
  intro xâ‚ xâ‚‚
  -- âŠ¢ â†‘(tensorProductTo D) (xâ‚ âŠ—â‚œ[R] xâ‚‚ * y) = â†‘(TensorProduct.lmul' R) (xâ‚ âŠ—â‚œ[R]  â€¦
  refine TensorProduct.induction_on y ?_ ?_ ?_
  Â· rw [mul_zero, map_zero, map_zero, zero_smul, smul_zero, add_zero]
    -- ğŸ‰ no goals
  swap
  -- âŠ¢ âˆ€ (x y : S âŠ—[R] S), â†‘(tensorProductTo D) (xâ‚ âŠ—â‚œ[R] xâ‚‚ * x) = â†‘(TensorProduct â€¦
  Â· intro xâ‚ yâ‚ hâ‚ hâ‚‚
    -- âŠ¢ â†‘(tensorProductTo D) (xâ‚âœ âŠ—â‚œ[R] xâ‚‚ * (xâ‚ + yâ‚)) = â†‘(TensorProduct.lmul' R) ( â€¦
    rw [mul_add, map_add, map_add, map_add, add_smul, smul_add, hâ‚, hâ‚‚, add_add_add_comm]
    -- ğŸ‰ no goals
  intro x y
  -- âŠ¢ â†‘(tensorProductTo D) (xâ‚ âŠ—â‚œ[R] xâ‚‚ * x âŠ—â‚œ[R] y) = â†‘(TensorProduct.lmul' R) (x â€¦
  simp only [TensorProduct.tmul_mul_tmul, Derivation.tensorProductTo,
    TensorProduct.AlgebraTensorModule.lift_apply, TensorProduct.lift.tmul',
    TensorProduct.lmul'_apply_tmul]
  dsimp
  -- âŠ¢ (xâ‚ * x) â€¢ â†‘D (xâ‚‚ * y) = (xâ‚ * xâ‚‚) â€¢ x â€¢ â†‘D y + (x * y) â€¢ xâ‚ â€¢ â†‘D xâ‚‚
  rw [D.leibniz]
  -- âŠ¢ (xâ‚ * x) â€¢ (xâ‚‚ â€¢ â†‘D y + y â€¢ â†‘D xâ‚‚) = (xâ‚ * xâ‚‚) â€¢ x â€¢ â†‘D y + (x * y) â€¢ xâ‚ â€¢ â†‘ â€¦
  simp only [smul_smul, smul_add, mul_comm (x * y) xâ‚, mul_right_comm xâ‚ xâ‚‚, â† mul_assoc]
  -- ğŸ‰ no goals
#align derivation.tensor_product_to_mul Derivation.tensorProductTo_mul

variable (R S)

/-- The kernel of `S âŠ—[R] S â†’â‚[R] S` is generated by `1 âŠ— s - s âŠ— 1` as a `S`-module. -/
theorem KaehlerDifferential.submodule_span_range_eq_ideal :
    Submodule.span S (Set.range fun s : S => (1 : S) âŠ—â‚œ[R] s - s âŠ—â‚œ[R] (1 : S)) =
      (KaehlerDifferential.ideal R S).restrictScalars S := by
  apply le_antisymm
  -- âŠ¢ Submodule.span S (Set.range fun s => 1 âŠ—â‚œ[R] s - s âŠ—â‚œ[R] 1) â‰¤ Submodule.rest â€¦
  Â· rw [Submodule.span_le]
    -- âŠ¢ (Set.range fun s => 1 âŠ—â‚œ[R] s - s âŠ—â‚œ[R] 1) âŠ† â†‘(Submodule.restrictScalars S ( â€¦
    rintro _ âŸ¨s, rflâŸ©
    -- âŠ¢ (fun s => 1 âŠ—â‚œ[R] s - s âŠ—â‚œ[R] 1) s âˆˆ â†‘(Submodule.restrictScalars S (ideal R  â€¦
    exact KaehlerDifferential.one_smul_sub_smul_one_mem_ideal _ _
    -- ğŸ‰ no goals
  Â· rintro x (hx : _ = _)
    -- âŠ¢ x âˆˆ Submodule.span S (Set.range fun s => 1 âŠ—â‚œ[R] s - s âŠ—â‚œ[R] 1)
    have : x - TensorProduct.lmul' (S := S) R x âŠ—â‚œ[R] (1 : S) = x := by
      rw [hx, TensorProduct.zero_tmul, sub_zero]
    rw [â† this]
    -- âŠ¢ x - â†‘(TensorProduct.lmul' R) x âŠ—â‚œ[R] 1 âˆˆ Submodule.span S (Set.range fun s = â€¦
    clear this hx
    -- âŠ¢ x - â†‘(TensorProduct.lmul' R) x âŠ—â‚œ[R] 1 âˆˆ Submodule.span S (Set.range fun s = â€¦
    refine TensorProduct.induction_on x ?_ ?_ ?_
    Â· rw [map_zero, TensorProduct.zero_tmul, sub_zero]; exact zero_mem _
      -- âŠ¢ 0 âˆˆ Submodule.span S (Set.range fun s => 1 âŠ—â‚œ[R] s - s âŠ—â‚œ[R] 1)
                                                        -- ğŸ‰ no goals
    Â· intro x y
      -- âŠ¢ x âŠ—â‚œ[R] y - â†‘(TensorProduct.lmul' R) (x âŠ—â‚œ[R] y) âŠ—â‚œ[R] 1 âˆˆ Submodule.span S  â€¦
      have : x âŠ—â‚œ[R] y - (x * y) âŠ—â‚œ[R] (1 : S) = x â€¢ ((1 : S) âŠ—â‚œ y - y âŠ—â‚œ (1 : S)) := by
        simp_rw [smul_sub, TensorProduct.smul_tmul', smul_eq_mul, mul_one]
      rw [TensorProduct.lmul'_apply_tmul, this]
      -- âŠ¢ x â€¢ (1 âŠ—â‚œ[R] y - y âŠ—â‚œ[R] 1) âˆˆ Submodule.span S (Set.range fun s => 1 âŠ—â‚œ[R] s â€¦
      refine Submodule.smul_mem _ x ?_
      -- âŠ¢ 1 âŠ—â‚œ[R] y - y âŠ—â‚œ[R] 1 âˆˆ Submodule.span S (Set.range fun s => 1 âŠ—â‚œ[R] s - s âŠ— â€¦
      apply Submodule.subset_span
      -- âŠ¢ 1 âŠ—â‚œ[R] y - y âŠ—â‚œ[R] 1 âˆˆ Set.range fun s => 1 âŠ—â‚œ[R] s - s âŠ—â‚œ[R] 1
      exact Set.mem_range_self y
      -- ğŸ‰ no goals
    Â· intro x y hx hy
      -- âŠ¢ x + y - â†‘(TensorProduct.lmul' R) (x + y) âŠ—â‚œ[R] 1 âˆˆ Submodule.span S (Set.ran â€¦
      rw [map_add, TensorProduct.add_tmul, â† sub_add_sub_comm]
      -- âŠ¢ x - â†‘(TensorProduct.lmul' R) x âŠ—â‚œ[R] 1 + (y - â†‘(TensorProduct.lmul' R) y âŠ—â‚œ[ â€¦
      exact add_mem hx hy
      -- ğŸ‰ no goals
#align kaehler_differential.submodule_span_range_eq_ideal KaehlerDifferential.submodule_span_range_eq_ideal

theorem KaehlerDifferential.span_range_eq_ideal :
    Ideal.span (Set.range fun s : S => (1 : S) âŠ—â‚œ[R] s - s âŠ—â‚œ[R] (1 : S)) =
      KaehlerDifferential.ideal R S := by
  apply le_antisymm
  -- âŠ¢ Ideal.span (Set.range fun s => 1 âŠ—â‚œ[R] s - s âŠ—â‚œ[R] 1) â‰¤ ideal R S
  Â· rw [Ideal.span_le]
    -- âŠ¢ (Set.range fun s => 1 âŠ—â‚œ[R] s - s âŠ—â‚œ[R] 1) âŠ† â†‘(ideal R S)
    rintro _ âŸ¨s, rflâŸ©
    -- âŠ¢ (fun s => 1 âŠ—â‚œ[R] s - s âŠ—â‚œ[R] 1) s âˆˆ â†‘(ideal R S)
    exact KaehlerDifferential.one_smul_sub_smul_one_mem_ideal _ _
    -- ğŸ‰ no goals
  Â· change (KaehlerDifferential.ideal R S).restrictScalars S â‰¤ (Ideal.span _).restrictScalars S
    -- âŠ¢ Submodule.restrictScalars S (ideal R S) â‰¤ Submodule.restrictScalars S (Ideal â€¦
    rw [â† KaehlerDifferential.submodule_span_range_eq_ideal, Ideal.span]
    -- âŠ¢ Submodule.span S (Set.range fun s => 1 âŠ—â‚œ[R] s - s âŠ—â‚œ[R] 1) â‰¤ Submodule.rest â€¦
    conv_rhs => rw [â† Submodule.span_span_of_tower S]
    -- âŠ¢ Submodule.span S (Set.range fun s => 1 âŠ—â‚œ[R] s - s âŠ—â‚œ[R] 1) â‰¤ Submodule.rest â€¦
    exact Submodule.subset_span
    -- ğŸ‰ no goals
#align kaehler_differential.span_range_eq_ideal KaehlerDifferential.span_range_eq_ideal

/-- The module of KÃ¤hler differentials (Kahler differentials, Kaehler differentials).
This is implemented as `I / I ^ 2` with `I` the kernel of the multiplication map `S âŠ—[R] S â†’â‚[R] S`.
To view elements as a linear combination of the form `s â€¢ D s'`, use
`KaehlerDifferential.tensorProductTo_surjective` and `Derivation.tensorProductTo_tmul`.

We also provide the notation `Î©[Sâ„R]` for `KaehlerDifferential R S`.
Note that the slash is `\textfractionsolidus`.
-/
def KaehlerDifferential : Type _ :=
  (KaehlerDifferential.ideal R S).Cotangent
#align kaehler_differential KaehlerDifferential

instance : AddCommGroup (KaehlerDifferential R S) := by
  unfold KaehlerDifferential
  -- âŠ¢ AddCommGroup (Ideal.Cotangent (KaehlerDifferential.ideal R S))
  infer_instance
  -- ğŸ‰ no goals

instance KaehlerDifferential.module : Module (S âŠ—[R] S) (KaehlerDifferential R S) :=
  Ideal.Cotangent.moduleOfTower _
#align kaehler_differential.module KaehlerDifferential.module

notation:100 "Î©[" S "â„" R "]" => KaehlerDifferential R S

instance : Nonempty (Î©[Sâ„R]) := âŸ¨0âŸ©

instance KaehlerDifferential.module' {R' : Type*} [CommRing R'] [Algebra R' S]
  [SMulCommClass R R' S] :
    Module R' (Î©[Sâ„R]) :=
  Submodule.Quotient.module' _
#align kaehler_differential.module' KaehlerDifferential.module'

instance : IsScalarTower S (S âŠ—[R] S) (Î©[Sâ„R]) :=
  Ideal.Cotangent.isScalarTower _

instance KaehlerDifferential.isScalarTower_of_tower {Râ‚ Râ‚‚ : Type*} [CommRing Râ‚] [CommRing Râ‚‚]
    [Algebra Râ‚ S] [Algebra Râ‚‚ S] [SMul Râ‚ Râ‚‚]
    [SMulCommClass R Râ‚ S] [SMulCommClass R Râ‚‚ S] [IsScalarTower Râ‚ Râ‚‚ S] :
    IsScalarTower Râ‚ Râ‚‚ (Î©[Sâ„R]) :=
  Submodule.Quotient.isScalarTower _ _

#align kaehler_differential.is_scalar_tower_of_tower KaehlerDifferential.isScalarTower_of_tower

instance KaehlerDifferential.isScalarTower' : IsScalarTower R (S âŠ—[R] S) (Î©[Sâ„R]) :=
  Submodule.Quotient.isScalarTower _ _
#align kaehler_differential.is_scalar_tower' KaehlerDifferential.isScalarTower'

/-- The quotient map `I â†’ Î©[Sâ„R]` with `I` being the kernel of `S âŠ—[R] S â†’ S`. -/
def KaehlerDifferential.fromIdeal : KaehlerDifferential.ideal R S â†’â‚—[S âŠ—[R] S] Î©[Sâ„R] :=
  (KaehlerDifferential.ideal R S).toCotangent
#align kaehler_differential.from_ideal KaehlerDifferential.fromIdeal

/-- (Implementation) The underlying linear map of the derivation into `Î©[Sâ„R]`. -/
def KaehlerDifferential.DLinearMap : S â†’â‚—[R] Î©[Sâ„R] :=
  ((KaehlerDifferential.fromIdeal R S).restrictScalars R).comp
    ((TensorProduct.includeRight.toLinearMap - TensorProduct.includeLeft.toLinearMap :
            S â†’â‚—[R] S âŠ—[R] S).codRestrict
        ((KaehlerDifferential.ideal R S).restrictScalars R)
        (KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R) :
      _ â†’â‚—[R] _)
set_option linter.uppercaseLean3 false in
#align kaehler_differential.D_linear_map KaehlerDifferential.DLinearMap

theorem KaehlerDifferential.DLinearMap_apply (s : S) :
    KaehlerDifferential.DLinearMap R S s =
      (KaehlerDifferential.ideal R S).toCotangent
        âŸ¨1 âŠ—â‚œ s - s âŠ—â‚œ 1, KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R sâŸ© := rfl
set_option linter.uppercaseLean3 false in
#align kaehler_differential.D_linear_map_apply KaehlerDifferential.DLinearMap_apply

/-- The universal derivation into `Î©[Sâ„R]`. -/
def KaehlerDifferential.D : Derivation R S (Î©[Sâ„R]) :=
  { toLinearMap := KaehlerDifferential.DLinearMap R S
    map_one_eq_zero' := by
      dsimp [KaehlerDifferential.DLinearMap_apply]
      -- âŠ¢ Submodule.Quotient.mk { val := 1 âŠ—â‚œ[R] 1 - 1 âŠ—â‚œ[R] 1, property := (_ : 1 âŠ—â‚œ[ â€¦
      congr
      -- âŠ¢ 1 âŠ—â‚œ[R] 1 - 1 âŠ—â‚œ[R] 1 = 0
      rw [sub_self]
      -- ğŸ‰ no goals
    leibniz' := fun a b => by
      have : LinearMap.CompatibleSMul { x // x âˆˆ ideal R S } (Î©[Sâ„R]) S (S âŠ—[R] S) := inferInstance
      -- âŠ¢ â†‘(DLinearMap R S) (a * b) = a â€¢ â†‘(DLinearMap R S) b + b â€¢ â†‘(DLinearMap R S) a
      dsimp [KaehlerDifferential.DLinearMap_apply, - Ideal.toCotangent_apply]
      -- âŠ¢ â†‘(Ideal.toCotangent (ideal R S)) { val := 1 âŠ—â‚œ[R] (a * b) - (a * b) âŠ—â‚œ[R] 1, â€¦
      rw [â† LinearMap.map_smul_of_tower (Mâ‚‚ := Î©[Sâ„R]),
        â† LinearMap.map_smul_of_tower (Mâ‚‚ := Î©[Sâ„R]), â† map_add, Ideal.toCotangent_eq, pow_two]
      convert Submodule.mul_mem_mul (KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R a : _)
        (KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R b : _) using 1
      simp only [AddSubgroupClass.coe_sub, Submodule.coe_add, Submodule.coe_mk,
        TensorProduct.tmul_mul_tmul, mul_sub, sub_mul, mul_comm b, Submodule.coe_smul_of_tower,
        smul_sub, TensorProduct.smul_tmul', smul_eq_mul, mul_one]
      ring_nf }
      -- ğŸ‰ no goals
set_option linter.uppercaseLean3 false in
#align kaehler_differential.D KaehlerDifferential.D

theorem KaehlerDifferential.D_apply (s : S) :
    KaehlerDifferential.D R S s =
      (KaehlerDifferential.ideal R S).toCotangent
        âŸ¨1 âŠ—â‚œ s - s âŠ—â‚œ 1, KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R sâŸ© := rfl
set_option linter.uppercaseLean3 false in
#align kaehler_differential.D_apply KaehlerDifferential.D_apply

theorem KaehlerDifferential.span_range_derivation :
    Submodule.span S (Set.range <| KaehlerDifferential.D R S) = âŠ¤ := by
  rw [_root_.eq_top_iff]
  -- âŠ¢ âŠ¤ â‰¤ Submodule.span S (Set.range â†‘(D R S))
  rintro x -
  -- âŠ¢ x âˆˆ Submodule.span S (Set.range â†‘(D R S))
  obtain âŸ¨âŸ¨x, hxâŸ©, rflâŸ© := Ideal.toCotangent_surjective _ x
  -- âŠ¢ â†‘(Ideal.toCotangent (ideal R S)) { val := x, property := hx } âˆˆ Submodule.sp â€¦
  have : x âˆˆ (KaehlerDifferential.ideal R S).restrictScalars S := hx
  -- âŠ¢ â†‘(Ideal.toCotangent (ideal R S)) { val := x, property := hx } âˆˆ Submodule.sp â€¦
  rw [â† KaehlerDifferential.submodule_span_range_eq_ideal] at this
  -- âŠ¢ â†‘(Ideal.toCotangent (ideal R S)) { val := x, property := hx } âˆˆ Submodule.sp â€¦
  suffices âˆƒ hx, (KaehlerDifferential.ideal R S).toCotangent âŸ¨x, hxâŸ© âˆˆ
      Submodule.span S (Set.range <| KaehlerDifferential.D R S) by
    exact this.choose_spec
  refine Submodule.span_induction this ?_ ?_ ?_ ?_
  Â· rintro _ âŸ¨x, rflâŸ©
    -- âŠ¢ âˆƒ hx, â†‘(Ideal.toCotangent (ideal R S)) { val := (fun s => 1 âŠ—â‚œ[R] s - s âŠ—â‚œ[R â€¦
    refine âŸ¨KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R x, ?_âŸ©
    -- âŠ¢ â†‘(Ideal.toCotangent (ideal R S)) { val := (fun s => 1 âŠ—â‚œ[R] s - s âŠ—â‚œ[R] 1) x â€¦
    apply Submodule.subset_span
    -- âŠ¢ â†‘(Ideal.toCotangent (ideal R S)) { val := (fun s => 1 âŠ—â‚œ[R] s - s âŠ—â‚œ[R] 1) x â€¦
    exact âŸ¨x, KaehlerDifferential.DLinearMap_apply R S xâŸ©
    -- ğŸ‰ no goals
  Â· exact âŸ¨zero_mem _, Submodule.zero_mem _âŸ©
    -- ğŸ‰ no goals
  Â· rintro x y âŸ¨hxâ‚, hxâ‚‚âŸ© âŸ¨hyâ‚, hyâ‚‚âŸ©; exact âŸ¨add_mem hxâ‚ hyâ‚, Submodule.add_mem _ hxâ‚‚ hyâ‚‚âŸ©
    -- âŠ¢ âˆƒ hx, â†‘(Ideal.toCotangent (ideal R S)) { val := x + y, property := hx } âˆˆ Su â€¦
                                      -- ğŸ‰ no goals
  Â· rintro r x âŸ¨hxâ‚, hxâ‚‚âŸ©;
    -- âŠ¢ âˆƒ hx, â†‘(Ideal.toCotangent (ideal R S)) { val := r â€¢ x, property := hx } âˆˆ Su â€¦
    exact âŸ¨((KaehlerDifferential.ideal R S).restrictScalars S).smul_mem r hxâ‚,
      Submodule.smul_mem _ r hxâ‚‚âŸ©
#align kaehler_differential.span_range_derivation KaehlerDifferential.span_range_derivation

variable {R S}

/-- The linear map from `Î©[Sâ„R]`, associated with a derivation. -/
def Derivation.liftKaehlerDifferential (D : Derivation R S M) : Î©[Sâ„R] â†’â‚—[S] M := by
  refine LinearMap.comp ((((KaehlerDifferential.ideal R S) â€¢
    (âŠ¤ : Submodule (S âŠ—[R] S) (KaehlerDifferential.ideal R S))).restrictScalars S).liftQ ?_ ?_)
    (Submodule.Quotient.restrictScalarsEquiv S _).symm.toLinearMap
  Â· exact D.tensorProductTo.comp ((KaehlerDifferential.ideal R S).subtype.restrictScalars S)
    -- ğŸ‰ no goals
  Â· intro x hx
    -- âŠ¢ x âˆˆ LinearMap.ker (LinearMap.comp (tensorProductTo D) (â†‘S (Submodule.subtype â€¦
    change _ = _
    -- âŠ¢ â†‘(LinearMap.comp (tensorProductTo D) (â†‘S (Submodule.subtype (KaehlerDifferen â€¦
    refine Submodule.smul_induction_on hx ?_ ?_
    -- âŠ¢ âˆ€ (r : S âŠ—[R] S), r âˆˆ KaehlerDifferential.ideal R S â†’ âˆ€ (n : { x // x âˆˆ Kaeh â€¦
    Â· rintro x (hx : _ = _) y -
      -- âŠ¢ â†‘(LinearMap.comp (tensorProductTo D) (â†‘S (Submodule.subtype (KaehlerDifferen â€¦
      dsimp
      -- âŠ¢ â†‘(tensorProductTo D) â†‘(x â€¢ y) = 0
      rw [show â†‘(x â€¢ y) = x * â†‘y by rfl, Derivation.tensorProductTo_mul, hx, y.prop, zero_smul,
        zero_smul, zero_add]
    Â· intro x y ex ey; rw [map_add, ex, ey, zero_add]
      -- âŠ¢ â†‘(LinearMap.comp (tensorProductTo D) (â†‘S (Submodule.subtype (KaehlerDifferen â€¦
                       -- ğŸ‰ no goals
#align derivation.lift_kaehler_differential Derivation.liftKaehlerDifferential

theorem Derivation.liftKaehlerDifferential_apply (D : Derivation R S M) (x) :
    D.liftKaehlerDifferential ((KaehlerDifferential.ideal R S).toCotangent x) =
      D.tensorProductTo x := rfl
#align derivation.lift_kaehler_differential_apply Derivation.liftKaehlerDifferential_apply

theorem Derivation.liftKaehlerDifferential_comp (D : Derivation R S M) :
    D.liftKaehlerDifferential.compDer (KaehlerDifferential.D R S) = D := by
  ext a
  -- âŠ¢ â†‘(â†‘(LinearMap.compDer (liftKaehlerDifferential D)) (KaehlerDifferential.D R  â€¦
  dsimp [KaehlerDifferential.D_apply]
  -- âŠ¢ â†‘(liftKaehlerDifferential D) (Submodule.Quotient.mk { val := 1 âŠ—â‚œ[R] a - a âŠ— â€¦
  refine (D.liftKaehlerDifferential_apply _).trans ?_
  -- âŠ¢ â†‘(tensorProductTo D) â†‘{ val := 1 âŠ—â‚œ[R] a - a âŠ—â‚œ[R] 1, property := (_ : 1 âŠ—â‚œ[ â€¦
  rw [Subtype.coe_mk, map_sub, Derivation.tensorProductTo_tmul, Derivation.tensorProductTo_tmul,
    one_smul, D.map_one_eq_zero, smul_zero, sub_zero]
#align derivation.lift_kaehler_differential_comp Derivation.liftKaehlerDifferential_comp

@[simp]
theorem Derivation.liftKaehlerDifferential_comp_D (D' : Derivation R S M) (x : S) :
    D'.liftKaehlerDifferential (KaehlerDifferential.D R S x) = D' x := by
-- Porting note: original proof (timeout)
--  Derivation.congr_fun D'.liftKaehlerDifferential_comp x
  rw [â† Derivation.congr_fun D'.liftKaehlerDifferential_comp x]
  -- âŠ¢ â†‘(liftKaehlerDifferential D') (â†‘(KaehlerDifferential.D R S) x) = â†‘(â†‘(LinearM â€¦
  simp
  -- ğŸ‰ no goals
set_option linter.uppercaseLean3 false in
#align derivation.lift_kaehler_differential_comp_D Derivation.liftKaehlerDifferential_comp_D

@[ext]
theorem Derivation.liftKaehlerDifferential_unique (f f' : Î©[Sâ„R] â†’â‚—[S] M)
    (hf : f.compDer (KaehlerDifferential.D R S) = f'.compDer (KaehlerDifferential.D R S)) :
    f = f' := by
  apply LinearMap.ext
  -- âŠ¢ âˆ€ (x : Î©[Sâ„R]), â†‘f x = â†‘f' x
  intro x
  -- âŠ¢ â†‘f x = â†‘f' x
  have : x âˆˆ Submodule.span S (Set.range <| KaehlerDifferential.D R S) := by
    rw [KaehlerDifferential.span_range_derivation]; trivial
  refine Submodule.span_induction this ?_ ?_ ?_ ?_
  Â· rintro _ âŸ¨x, rflâŸ©; exact congr_arg (fun D : Derivation R S M => D x) hf
    -- âŠ¢ â†‘f (â†‘(KaehlerDifferential.D R S) x) = â†‘f' (â†‘(KaehlerDifferential.D R S) x)
                       -- ğŸ‰ no goals
  Â· rw [map_zero, map_zero]
    -- ğŸ‰ no goals
  Â· intro x y hx hy; rw [map_add, map_add, hx, hy]
    -- âŠ¢ â†‘f (x + y) = â†‘f' (x + y)
                     -- ğŸ‰ no goals
  Â· intro a x e; simp [e]
    -- âŠ¢ â†‘f (a â€¢ x) = â†‘f' (a â€¢ x)
                 -- ğŸ‰ no goals
#align derivation.lift_kaehler_differential_unique Derivation.liftKaehlerDifferential_unique

variable (R S)

theorem Derivation.liftKaehlerDifferential_D :
    (KaehlerDifferential.D R S).liftKaehlerDifferential = LinearMap.id :=
  Derivation.liftKaehlerDifferential_unique _ _
    (KaehlerDifferential.D R S).liftKaehlerDifferential_comp
set_option linter.uppercaseLean3 false in
#align derivation.lift_kaehler_differential_D Derivation.liftKaehlerDifferential_D

variable {R S}

theorem KaehlerDifferential.D_tensorProductTo (x : KaehlerDifferential.ideal R S) :
    (KaehlerDifferential.D R S).tensorProductTo x =
      (KaehlerDifferential.ideal R S).toCotangent x := by
  rw [â† Derivation.liftKaehlerDifferential_apply, Derivation.liftKaehlerDifferential_D]
  -- âŠ¢ â†‘LinearMap.id (â†‘(Ideal.toCotangent (ideal R S)) x) = â†‘(Ideal.toCotangent (id â€¦
  rfl
  -- ğŸ‰ no goals
set_option linter.uppercaseLean3 false in
#align kaehler_differential.D_tensor_product_to KaehlerDifferential.D_tensorProductTo

variable (R S)

theorem KaehlerDifferential.tensorProductTo_surjective :
    Function.Surjective (KaehlerDifferential.D R S).tensorProductTo := by
  intro x; obtain âŸ¨x, rflâŸ© := (KaehlerDifferential.ideal R S).toCotangent_surjective x
  -- âŠ¢ âˆƒ a, â†‘(Derivation.tensorProductTo (D R S)) a = x
           -- âŠ¢ âˆƒ a, â†‘(Derivation.tensorProductTo (D R S)) a = â†‘(Ideal.toCotangent (ideal R  â€¦
  exact âŸ¨x, KaehlerDifferential.D_tensorProductTo xâŸ©
  -- ğŸ‰ no goals
#align kaehler_differential.tensor_product_to_surjective KaehlerDifferential.tensorProductTo_surjective

/-- The `S`-linear maps from `Î©[Sâ„R]` to `M` are (`S`-linearly) equivalent to `R`-derivations
from `S` to `M`.  -/
def KaehlerDifferential.linearMapEquivDerivation : (Î©[Sâ„R] â†’â‚—[S] M) â‰ƒâ‚—[S] Derivation R S M :=
  { Derivation.llcomp.flip <| KaehlerDifferential.D R S with
    invFun := Derivation.liftKaehlerDifferential
    left_inv := fun _ =>
      Derivation.liftKaehlerDifferential_unique _ _ (Derivation.liftKaehlerDifferential_comp _)
    right_inv := Derivation.liftKaehlerDifferential_comp }
#align kaehler_differential.linear_map_equiv_derivation KaehlerDifferential.linearMapEquivDerivation

/-- The quotient ring of `S âŠ— S â§¸ J ^ 2` by `Î©[Sâ„R]` is isomorphic to `S`. -/
def KaehlerDifferential.quotientCotangentIdealRingEquiv :
    (S âŠ— S â§¸ KaehlerDifferential.ideal R S ^ 2) â§¸ (KaehlerDifferential.ideal R S).cotangentIdeal â‰ƒ+*
      S := by
  have : Function.RightInverse (TensorProduct.includeLeft (R := R) (A := S) (B := S))
      (â†‘(TensorProduct.lmul' R : S âŠ—[R] S â†’â‚[R] S) : S âŠ—[R] S â†’+* S) := by
    intro x; rw [AlgHom.coe_toRingHom, â† AlgHom.comp_apply, TensorProduct.lmul'_comp_includeLeft]
    rfl
  refine (Ideal.quotCotangent _).trans ?_
  -- âŠ¢ S âŠ—[R] S â§¸ ideal R S â‰ƒ+* S
  refine (Ideal.quotEquivOfEq ?_).trans (RingHom.quotientKerEquivOfRightInverse this)
  -- âŠ¢ ideal R S = RingHom.ker â†‘(TensorProduct.lmul' R)
  ext; rfl
  -- âŠ¢ xâœ âˆˆ ideal R S â†” xâœ âˆˆ RingHom.ker â†‘(TensorProduct.lmul' R)
       -- ğŸ‰ no goals
#align kaehler_differential.quotient_cotangent_ideal_ring_equiv KaehlerDifferential.quotientCotangentIdealRingEquiv

/-- The quotient ring of `S âŠ— S â§¸ J ^ 2` by `Î©[Sâ„R]` is isomorphic to `S` as an `S`-algebra. -/
def KaehlerDifferential.quotientCotangentIdeal :
    ((S âŠ— S â§¸ KaehlerDifferential.ideal R S ^ 2) â§¸
        (KaehlerDifferential.ideal R S).cotangentIdeal) â‰ƒâ‚[S] S :=
  { KaehlerDifferential.quotientCotangentIdealRingEquiv R S with
    commutes' := (KaehlerDifferential.quotientCotangentIdealRingEquiv R S).apply_symm_apply }
#align kaehler_differential.quotient_cotangent_ideal KaehlerDifferential.quotientCotangentIdeal

theorem KaehlerDifferential.End_equiv_aux (f : S â†’â‚[R] S âŠ— S â§¸ KaehlerDifferential.ideal R S ^ 2) :
    (Ideal.Quotient.mkâ‚ R (KaehlerDifferential.ideal R S).cotangentIdeal).comp f =
        IsScalarTower.toAlgHom R S _ â†”
      (TensorProduct.lmul' R : S âŠ—[R] S â†’â‚[R] S).kerSquareLift.comp f = AlgHom.id R S := by
  rw [AlgHom.ext_iff, AlgHom.ext_iff]
  -- âŠ¢ (âˆ€ (x : S), â†‘(AlgHom.comp (Ideal.Quotient.mkâ‚ R (Ideal.cotangentIdeal (ideal â€¦
  apply forall_congr'
  -- âŠ¢ âˆ€ (a : S), â†‘(AlgHom.comp (Ideal.Quotient.mkâ‚ R (Ideal.cotangentIdeal (ideal  â€¦
  intro x
  -- âŠ¢ â†‘(AlgHom.comp (Ideal.Quotient.mkâ‚ R (Ideal.cotangentIdeal (ideal R S))) f) x â€¦
  have eâ‚ : (TensorProduct.lmul' R : S âŠ—[R] S â†’â‚[R] S).kerSquareLift (f x) =
      KaehlerDifferential.quotientCotangentIdealRingEquiv R S
        (Ideal.Quotient.mk (KaehlerDifferential.ideal R S).cotangentIdeal <| f x) := by
    generalize f x = y; obtain âŸ¨y, rflâŸ© := Ideal.Quotient.mk_surjective y; rfl
  have eâ‚‚ :
    x = KaehlerDifferential.quotientCotangentIdealRingEquiv R S (IsScalarTower.toAlgHom R S _ x) :=
    (mul_one x).symm
  constructor
  -- âŠ¢ â†‘(AlgHom.comp (Ideal.Quotient.mkâ‚ R (Ideal.cotangentIdeal (ideal R S))) f) x â€¦
  Â· intro e
    -- âŠ¢ â†‘(AlgHom.comp (AlgHom.kerSquareLift (TensorProduct.lmul' R)) f) x = â†‘(AlgHom â€¦
    exact (eâ‚.trans (@RingEquiv.congr_arg _ _ _ _ _ _
      (KaehlerDifferential.quotientCotangentIdealRingEquiv R S) _ _ e)).trans eâ‚‚.symm
  Â· intro e; apply (KaehlerDifferential.quotientCotangentIdealRingEquiv R S).injective
    -- âŠ¢ â†‘(AlgHom.comp (Ideal.Quotient.mkâ‚ R (Ideal.cotangentIdeal (ideal R S))) f) x â€¦
             -- âŠ¢ â†‘(quotientCotangentIdealRingEquiv R S) (â†‘(AlgHom.comp (Ideal.Quotient.mkâ‚ R  â€¦
    exact eâ‚.symm.trans (e.trans eâ‚‚)
    -- ğŸ‰ no goals
#align kaehler_differential.End_equiv_aux KaehlerDifferential.End_equiv_aux

set_option maxHeartbeats 700000 in
-- Porting note: extra heartbeats are needed to infer the instance
-- Module S { x // x âˆˆ Ideal.cotangentIdeal (ideal R S) }
set_option synthInstance.maxHeartbeats 200000 in
-- This has type
-- `Derivation R S (Î©[Sâ„R]) â‰ƒâ‚—[R] Derivation R S (KaehlerDifferential.ideal R S).cotangentIdeal`
-- But lean times-out if this is given explicitly.
/-- Derivations into `Î©[Sâ„R]` is equivalent to derivations
into `(KaehlerDifferential.ideal R S).cotangentIdeal`. -/
noncomputable def KaehlerDifferential.endEquivDerivation' :=
  @LinearEquiv.compDer R _ S _ _ (Î©[Sâ„R]) _ _ _ (KaehlerDifferential.ideal R S).cotangentIdeal
    _ _ _ _ _ ((KaehlerDifferential.ideal R S).cotangentEquivIdeal.restrictScalars S)
#align kaehler_differential.End_equiv_derivation' KaehlerDifferential.endEquivDerivation'

/-- (Implementation) An `Equiv` version of `KaehlerDifferential.End_equiv_aux`.
Used in `KaehlerDifferential.endEquiv`. -/
def KaehlerDifferential.endEquivAuxEquiv :
    { f //
        (Ideal.Quotient.mkâ‚ R (KaehlerDifferential.ideal R S).cotangentIdeal).comp f =
          IsScalarTower.toAlgHom R S _ } â‰ƒ
      { f // (TensorProduct.lmul' R : S âŠ—[R] S â†’â‚[R] S).kerSquareLift.comp f = AlgHom.id R S } :=
  (Equiv.refl _).subtypeEquiv (KaehlerDifferential.End_equiv_aux R S)
#align kaehler_differential.End_equiv_aux_equiv KaehlerDifferential.endEquivAuxEquiv


set_option maxHeartbeats 1200000 in
set_option synthInstance.maxHeartbeats 1000000 in
/--
The endomorphisms of `Î©[Sâ„R]` corresponds to sections of the surjection `S âŠ—[R] S â§¸ J ^ 2 â†’â‚[R] S`,
with `J` being the kernel of the multiplication map `S âŠ—[R] S â†’â‚[R] S`.
-/
noncomputable def KaehlerDifferential.endEquiv :
    Module.End S (Î©[Sâ„R]) â‰ƒ
      { f // (TensorProduct.lmul' R : S âŠ—[R] S â†’â‚[R] S).kerSquareLift.comp f = AlgHom.id R S } :=
  (KaehlerDifferential.linearMapEquivDerivation R S).toEquiv.trans <|
    (KaehlerDifferential.endEquivDerivation' R S).toEquiv.trans <|
      (derivationToSquareZeroEquivLift (KaehlerDifferential.ideal R S).cotangentIdeal
            (KaehlerDifferential.ideal R S).cotangentIdeal_square).trans <|
        KaehlerDifferential.endEquivAuxEquiv R S
#align kaehler_differential.End_equiv KaehlerDifferential.endEquiv

section Presentation

open KaehlerDifferential (D)

open Finsupp (single)

/-- The `S`-submodule of `S â†’â‚€ S` (the direct sum of copies of `S` indexed by `S`) generated by
the relations:
1. `dx + dy = d(x + y)`
2. `x dy + y dx = d(x * y)`
3. `dr = 0` for `r âˆˆ R`
where `db` is the unit in the copy of `S` with index `b`.

This is the kernel of the surjection `Finsupp.total S Î©[Sâ„R] S (KaehlerDifferential.D R S)`.
See `KaehlerDifferential.kerTotal_eq` and `KaehlerDifferential.total_surjective`.
-/
noncomputable def KaehlerDifferential.kerTotal : Submodule S (S â†’â‚€ S) :=
  Submodule.span S
    (((Set.range fun x : S Ã— S => single x.1 1 + single x.2 1 - single (x.1 + x.2) 1) âˆª
        Set.range fun x : S Ã— S => single x.2 x.1 + single x.1 x.2 - single (x.1 * x.2) 1) âˆª
      Set.range fun x : R => single (algebraMap R S x) 1)
#align kaehler_differential.ker_total KaehlerDifferential.kerTotal

-- Porting note: was `local notation x "ğ–£" y => (KaehlerDifferential.kerTotal R S).mkQ (single y x)`
-- but `notation3` wants an explicit expansion to be able to generate a pretty printer.
local notation3 x "ğ–£" y =>
  FunLike.coe (Submodule.mkQ (KaehlerDifferential.kerTotal R S)) (single y x)

theorem KaehlerDifferential.kerTotal_mkQ_single_add (x y z) : (zğ–£x + y) = (zğ–£x) + zğ–£y := by
  rw [â† map_add, eq_comm, â† sub_eq_zero, â† map_sub (Submodule.mkQ (kerTotal R S)),
    Submodule.mkQ_apply, Submodule.Quotient.mk_eq_zero]
  simp_rw [â† Finsupp.smul_single_one _ z, â† smul_add, â† smul_sub]
  -- âŠ¢ z â€¢ (single x 1 + single y 1 - single (x + y) 1) âˆˆ kerTotal R S
  exact Submodule.smul_mem _ _ (Submodule.subset_span (Or.inl <| Or.inl <| âŸ¨âŸ¨_, _âŸ©, rflâŸ©))
  -- ğŸ‰ no goals
#align kaehler_differential.ker_total_mkq_single_add KaehlerDifferential.kerTotal_mkQ_single_add

theorem KaehlerDifferential.kerTotal_mkQ_single_mul (x y z) :
    (zğ–£x * y) = ((z * x)ğ–£y) + (z * y)ğ–£x := by
  rw [â† map_add, eq_comm, â† sub_eq_zero, â† map_sub (Submodule.mkQ (kerTotal R S)),
    Submodule.mkQ_apply, Submodule.Quotient.mk_eq_zero]
  simp_rw [â† Finsupp.smul_single_one _ z, â† @smul_eq_mul _ _ z, â† Finsupp.smul_single, â† smul_add,
    â† smul_sub]
  exact Submodule.smul_mem _ _ (Submodule.subset_span (Or.inl <| Or.inr <| âŸ¨âŸ¨_, _âŸ©, rflâŸ©))
  -- ğŸ‰ no goals
#align kaehler_differential.ker_total_mkq_single_mul KaehlerDifferential.kerTotal_mkQ_single_mul

theorem KaehlerDifferential.kerTotal_mkQ_single_algebraMap (x y) : (yğ–£algebraMap R S x) = 0 := by
  rw [Submodule.mkQ_apply, Submodule.Quotient.mk_eq_zero, â† Finsupp.smul_single_one _ y]
  -- âŠ¢ y â€¢ single (â†‘(algebraMap R S) x) 1 âˆˆ kerTotal R S
  exact Submodule.smul_mem _ _ (Submodule.subset_span (Or.inr <| âŸ¨_, rflâŸ©))
  -- ğŸ‰ no goals
#align kaehler_differential.ker_total_mkq_single_algebra_map KaehlerDifferential.kerTotal_mkQ_single_algebraMap

theorem KaehlerDifferential.kerTotal_mkQ_single_algebraMap_one (x) : (xğ–£1) = 0 := by
  rw [â† (algebraMap R S).map_one, KaehlerDifferential.kerTotal_mkQ_single_algebraMap]
  -- ğŸ‰ no goals
#align kaehler_differential.ker_total_mkq_single_algebra_map_one KaehlerDifferential.kerTotal_mkQ_single_algebraMap_one

theorem KaehlerDifferential.kerTotal_mkQ_single_smul (r : R) (x y) : (yğ–£r â€¢ x) = r â€¢ yğ–£x := by
  rw [Algebra.smul_def, KaehlerDifferential.kerTotal_mkQ_single_mul,
    KaehlerDifferential.kerTotal_mkQ_single_algebraMap, add_zero, â† LinearMap.map_smul_of_tower,
    Finsupp.smul_single, mul_comm, Algebra.smul_def]
#align kaehler_differential.ker_total_mkq_single_smul KaehlerDifferential.kerTotal_mkQ_single_smul

/-- The (universal) derivation into `(S â†’â‚€ S) â§¸ KaehlerDifferential.kerTotal R S`. -/
noncomputable def KaehlerDifferential.derivationQuotKerTotal :
    Derivation R S ((S â†’â‚€ S) â§¸ KaehlerDifferential.kerTotal R S) where
  toFun x := 1ğ–£x
  map_add' x y := KaehlerDifferential.kerTotal_mkQ_single_add _ _ _ _ _
  map_smul' r s := KaehlerDifferential.kerTotal_mkQ_single_smul _ _ _ _ _
  map_one_eq_zero' := KaehlerDifferential.kerTotal_mkQ_single_algebraMap_one _ _ _
  leibniz' a b :=
    (KaehlerDifferential.kerTotal_mkQ_single_mul _ _ _ _ _).trans
      (by simp_rw [â† Finsupp.smul_single_one _ (1 * _ : S)]; dsimp; simp)
          -- âŠ¢ â†‘(Submodule.mkQ (kerTotal R S)) ((1 * a) â€¢ single b 1) + â†‘(Submodule.mkQ (ke â€¦
                                                             -- âŠ¢ (1 * a) â€¢ Submodule.Quotient.mk (single b 1) + (1 * b) â€¢ Submodule.Quotient. â€¦
                                                                    -- ğŸ‰ no goals
#align kaehler_differential.derivation_quot_ker_total KaehlerDifferential.derivationQuotKerTotal

theorem KaehlerDifferential.derivationQuotKerTotal_apply (x) :
    KaehlerDifferential.derivationQuotKerTotal R S x = 1ğ–£x :=
  rfl
#align kaehler_differential.derivation_quot_ker_total_apply KaehlerDifferential.derivationQuotKerTotal_apply

theorem KaehlerDifferential.derivationQuotKerTotal_lift_comp_total :
    (KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential.comp
        (Finsupp.total S (Î©[Sâ„R]) S (KaehlerDifferential.D R S)) =
      Submodule.mkQ _ := by
  apply Finsupp.lhom_ext
  -- âŠ¢ âˆ€ (a b : S), â†‘(LinearMap.comp (Derivation.liftKaehlerDifferential (derivatio â€¦
  intro a b
  -- âŠ¢ â†‘(LinearMap.comp (Derivation.liftKaehlerDifferential (derivationQuotKerTotal â€¦
  conv_rhs => rw [â† Finsupp.smul_single_one a b, LinearMap.map_smul]
  -- âŠ¢ â†‘(LinearMap.comp (Derivation.liftKaehlerDifferential (derivationQuotKerTotal â€¦
  simp [KaehlerDifferential.derivationQuotKerTotal_apply]
  -- ğŸ‰ no goals
#align kaehler_differential.derivation_quot_ker_total_lift_comp_total KaehlerDifferential.derivationQuotKerTotal_lift_comp_total

theorem KaehlerDifferential.kerTotal_eq :
    LinearMap.ker (Finsupp.total S (Î©[Sâ„R]) S (KaehlerDifferential.D R S)) =
      KaehlerDifferential.kerTotal R S := by
  apply le_antisymm
  -- âŠ¢ LinearMap.ker (Finsupp.total S (Î©[Sâ„R]) S â†‘(D R S)) â‰¤ kerTotal R S
  Â· conv_rhs => rw [â† (KaehlerDifferential.kerTotal R S).ker_mkQ]
    -- âŠ¢ LinearMap.ker (Finsupp.total S (Î©[Sâ„R]) S â†‘(D R S)) â‰¤ LinearMap.ker (Submodu â€¦
    rw [â† KaehlerDifferential.derivationQuotKerTotal_lift_comp_total]
    -- âŠ¢ LinearMap.ker (Finsupp.total S (Î©[Sâ„R]) S â†‘(D R S)) â‰¤ LinearMap.ker (LinearM â€¦
    exact LinearMap.ker_le_ker_comp _ _
    -- ğŸ‰ no goals
  Â· rw [KaehlerDifferential.kerTotal, Submodule.span_le]
    -- âŠ¢ (((Set.range fun x => single x.fst 1 + single x.snd 1 - single (x.fst + x.sn â€¦
    rintro _ ((âŸ¨âŸ¨x, yâŸ©, rflâŸ© | âŸ¨âŸ¨x, yâŸ©, rflâŸ©) | âŸ¨x, rflâŸ©) <;> dsimp <;> simp [LinearMap.mem_ker]
                                                              -- âŠ¢ single x 1 + single y 1 - single (x + y) 1 âˆˆ â†‘(LinearMap.ker (Finsupp.total  â€¦
                                                              -- âŠ¢ single y x + single x y - single (x * y) 1 âˆˆ â†‘(LinearMap.ker (Finsupp.total  â€¦
                                                              -- âŠ¢ single (â†‘(algebraMap R S) x) 1 âˆˆ â†‘(LinearMap.ker (Finsupp.total S (Î©[Sâ„R]) S â€¦
                                                                        -- ğŸ‰ no goals
                                                                        -- ğŸ‰ no goals
                                                                        -- ğŸ‰ no goals
#align kaehler_differential.ker_total_eq KaehlerDifferential.kerTotal_eq

theorem KaehlerDifferential.total_surjective :
    Function.Surjective (Finsupp.total S (Î©[Sâ„R]) S (KaehlerDifferential.D R S)) := by
  rw [â† LinearMap.range_eq_top, Finsupp.range_total, KaehlerDifferential.span_range_derivation]
  -- ğŸ‰ no goals
#align kaehler_differential.total_surjective KaehlerDifferential.total_surjective

set_option maxHeartbeats 400000 in
/-- `Î©[Sâ„R]` is isomorphic to `S` copies of `S` with kernel `KaehlerDifferential.kerTotal`. -/
@[simps!]
noncomputable def KaehlerDifferential.quotKerTotalEquiv :
    ((S â†’â‚€ S) â§¸ KaehlerDifferential.kerTotal R S) â‰ƒâ‚—[S] Î©[Sâ„R] :=
  { (KaehlerDifferential.kerTotal R S).liftQ
      (Finsupp.total S (Î©[Sâ„R]) S (KaehlerDifferential.D R S))
      (KaehlerDifferential.kerTotal_eq R S).ge with
    invFun := (KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential
    left_inv := by
      intro x
      -- âŠ¢ â†‘(Derivation.liftKaehlerDifferential (derivationQuotKerTotal R S)) (AddHom.t â€¦
      obtain âŸ¨x, rflâŸ© := Submodule.mkQ_surjective _ x
      -- âŠ¢ â†‘(Derivation.liftKaehlerDifferential (derivationQuotKerTotal R S)) (AddHom.t â€¦
      exact
        LinearMap.congr_fun (KaehlerDifferential.derivationQuotKerTotal_lift_comp_total R S : _) x
    right_inv := by
      intro x
      -- âŠ¢ AddHom.toFun { toAddHom := srcâœ.toAddHom, map_smul' := (_ : âˆ€ (r : S) (x : ( â€¦
      obtain âŸ¨x, rflâŸ© := KaehlerDifferential.total_surjective R S x
      -- âŠ¢ AddHom.toFun { toAddHom := srcâœ.toAddHom, map_smul' := (_ : âˆ€ (r : S) (x : ( â€¦
      erw [LinearMap.congr_fun (KaehlerDifferential.derivationQuotKerTotal_lift_comp_total R S : _)
          x]
      rfl }
      -- ğŸ‰ no goals
#align kaehler_differential.quot_ker_total_equiv KaehlerDifferential.quotKerTotalEquiv

theorem KaehlerDifferential.quotKerTotalEquiv_symm_comp_D :
    (KaehlerDifferential.quotKerTotalEquiv R S).symm.toLinearMap.compDer
        (KaehlerDifferential.D R S) =
      KaehlerDifferential.derivationQuotKerTotal R S := by
  convert (KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential_comp
  -- ğŸ‰ no goals
set_option linter.uppercaseLean3 false in
#align kaehler_differential.quot_ker_total_equiv_symm_comp_D KaehlerDifferential.quotKerTotalEquiv_symm_comp_D

variable (A B : Type*) [CommRing A] [CommRing B] [Algebra R A] [Algebra S B] [Algebra R B]

variable [Algebra A B] [IsScalarTower R S B] [IsScalarTower R A B]

-- The map `(A â†’â‚€ A) â†’â‚—[A] (B â†’â‚€ B)`
local macro "finsupp_map" : term =>
  `((Finsupp.mapRange.linearMap (Algebra.linearMap A B)).comp
    (Finsupp.lmapDomain A A (algebraMap A B)))

set_option maxHeartbeats 400000 in
theorem KaehlerDifferential.kerTotal_map (h : Function.Surjective (algebraMap A B)) :
    (KaehlerDifferential.kerTotal R A).map finsupp_map âŠ”
        Submodule.span A (Set.range fun x : S => single (algebraMap S B x) (1 : B)) =
      (KaehlerDifferential.kerTotal S B).restrictScalars _ := by
  rw [KaehlerDifferential.kerTotal, Submodule.map_span, KaehlerDifferential.kerTotal,
    Submodule.restrictScalars_span _ _ h]
  -- Porting note: the proof is diverging from the mathlib3 proof here.
  -- `map_sub` and `map_add` are not firing so we need to use `LinearMap.map_*` instead
  simp_rw [Set.image_union, Submodule.span_union, â† Set.image_univ, Set.image_image, Set.image_univ,
    LinearMap.map_sub, LinearMap.map_add]
  simp only [LinearMap.comp_apply, Finsupp.lmapDomain_apply, Finsupp.mapDomain_single,
    Finsupp.mapRange.linearMap_apply, Finsupp.mapRange_single, Algebra.linearMap_apply,
    map_one, map_add, map_mul]
  simp_rw [sup_assoc, â† (h.Prod_map h).range_comp]
  -- âŠ¢ Submodule.span A (Set.range fun x => single (â†‘(algebraMap A B) x.fst) 1 + si â€¦
  congr 3
  -- âŠ¢ Submodule.span A (Set.range fun x => single (â†‘(algebraMap A B) (â†‘(algebraMap â€¦
  -- Porting note: new
  simp_rw [â† IsScalarTower.algebraMap_apply R A B]
  -- âŠ¢ Submodule.span A (Set.range fun x => single (â†‘(algebraMap R B) x) 1) âŠ” Submo â€¦
  rw [sup_eq_right]
  -- âŠ¢ Submodule.span A (Set.range fun x => single (â†‘(algebraMap R B) x) 1) â‰¤ Submo â€¦
  apply Submodule.span_mono
  -- âŠ¢ (Set.range fun x => single (â†‘(algebraMap R B) x) 1) âŠ† Set.range fun x => sin â€¦
  simp_rw [IsScalarTower.algebraMap_apply R S B]
  -- âŠ¢ (Set.range fun x => single (â†‘(algebraMap S B) (â†‘(algebraMap R S) x)) 1) âŠ† Se â€¦
  exact Set.range_comp_subset_range (algebraMap R S) fun x => single (algebraMap S B x) (1 : B)
  -- ğŸ‰ no goals
#align kaehler_differential.ker_total_map KaehlerDifferential.kerTotal_map

end Presentation

section ExactSequence

/- We have the commutative diagram
A --â†’ B
â†‘     â†‘
|     |
R --â†’ S -/
variable (A B : Type*) [CommRing A] [CommRing B] [Algebra R A] [Algebra R B]

variable [Algebra A B] [Algebra S B] [IsScalarTower R A B] [IsScalarTower R S B]

variable {R B}

/-- For a tower `R â†’ A â†’ B` and an `R`-derivation `B â†’ M`, we may compose with `A â†’ B` to obtain an
`R`-derivation `A â†’ M`. -/
def Derivation.compAlgebraMap [Module A M] [Module B M] [IsScalarTower A B M]
    (d : Derivation R B M) : Derivation R A M where
  map_one_eq_zero' := by simp
                         -- ğŸ‰ no goals
  leibniz' a b := by simp
                     -- ğŸ‰ no goals
  toLinearMap := d.toLinearMap.comp (IsScalarTower.toAlgHom R A B).toLinearMap
#align derivation.comp_algebra_map Derivation.compAlgebraMap

variable (R B)
variable [SMulCommClass S A B]

/-- The map `Î©[Aâ„R] â†’â‚—[A] Î©[Bâ„R]` given a square
A --â†’ B
â†‘     â†‘
|     |
R --â†’ S -/
def KaehlerDifferential.map : Î©[Aâ„R] â†’â‚—[A] Î©[Bâ„S] :=
  Derivation.liftKaehlerDifferential
    (((KaehlerDifferential.D S B).restrictScalars R).compAlgebraMap A)
#align kaehler_differential.map KaehlerDifferential.map

theorem KaehlerDifferential.map_compDer :
    (KaehlerDifferential.map R S A B).compDer (KaehlerDifferential.D R A) =
      ((KaehlerDifferential.D S B).restrictScalars R).compAlgebraMap A :=
  Derivation.liftKaehlerDifferential_comp _
#align kaehler_differential.map_comp_der KaehlerDifferential.map_compDer

theorem KaehlerDifferential.map_D (x : A) :
    KaehlerDifferential.map R S A B (KaehlerDifferential.D R A x) =
      KaehlerDifferential.D S B (algebraMap A B x) :=
  Derivation.congr_fun (KaehlerDifferential.map_compDer R S A B) x
set_option linter.uppercaseLean3 false in
#align kaehler_differential.map_D KaehlerDifferential.map_D

open IsScalarTower (toAlgHom)

theorem KaehlerDifferential.map_surjective_of_surjective
    (h : Function.Surjective (algebraMap A B)) :
    Function.Surjective (KaehlerDifferential.map R S A B) := by
  rw [â† LinearMap.range_eq_top, _root_.eq_top_iff, â† @Submodule.restrictScalars_top B A,
    â† KaehlerDifferential.span_range_derivation, Submodule.restrictScalars_span _ _ h,
    Submodule.span_le]
  rintro _ âŸ¨x, rflâŸ©
  -- âŠ¢ â†‘(D S B) x âˆˆ â†‘(LinearMap.range (map R S A B))
  obtain âŸ¨y, rflâŸ© := h x
  -- âŠ¢ â†‘(D S B) (â†‘(algebraMap A B) y) âˆˆ â†‘(LinearMap.range (map R S A B))
  rw [â† KaehlerDifferential.map_D R S A B]
  -- âŠ¢ â†‘(map R S A B) (â†‘(D R A) y) âˆˆ â†‘(LinearMap.range (map R S A B))
  exact âŸ¨_, rflâŸ©
  -- ğŸ‰ no goals
#align kaehler_differential.map_surjective_of_surjective KaehlerDifferential.map_surjective_of_surjective

/-- The lift of the map `Î©[Aâ„R] â†’â‚—[A] Î©[Bâ„R]` to the base change along `A â†’ B`.
This is the first map in the exact sequence `B âŠ—[A] Î©[Aâ„R] â†’ Î©[Bâ„R] â†’ Î©[Bâ„A] â†’ 0`. -/
noncomputable def KaehlerDifferential.mapBaseChange : B âŠ—[A] Î©[Aâ„R] â†’â‚—[B] Î©[Bâ„R] :=
  (TensorProduct.isBaseChange A (Î©[Aâ„R]) B).lift (KaehlerDifferential.map R R A B)
#align kaehler_differential.map_base_change KaehlerDifferential.mapBaseChange

@[simp]
theorem KaehlerDifferential.mapBaseChange_tmul (x : B) (y : Î©[Aâ„R]) :
    KaehlerDifferential.mapBaseChange R A B (x âŠ—â‚œ y) = x â€¢ KaehlerDifferential.map R R A B y := by
  conv_lhs => rw [â† mul_one x, â† smul_eq_mul, â† TensorProduct.smul_tmul', LinearMap.map_smul]
  -- âŠ¢ x â€¢ â†‘(mapBaseChange R A B) (1 âŠ—â‚œ[A] y) = x â€¢ â†‘(map R R A B) y
  congr 1
  -- âŠ¢ â†‘(mapBaseChange R A B) (1 âŠ—â‚œ[A] y) = â†‘(map R R A B) y
  exact IsBaseChange.lift_eq _ _ _
  -- ğŸ‰ no goals
#align kaehler_differential.map_base_change_tmul KaehlerDifferential.mapBaseChange_tmul

end ExactSequence

end KaehlerDifferential
