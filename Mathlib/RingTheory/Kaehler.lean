/-
Copyright ¬© 2020 Nicol√≤ Cavalleri. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Nicol√≤ Cavalleri, Andrew Yang
-/
import Mathlib.RingTheory.Derivation.ToSquareZero
import Mathlib.RingTheory.Ideal.Cotangent
import Mathlib.RingTheory.IsTensorProduct
import Mathlib.LinearAlgebra.TensorProduct.RightExactness
import Mathlib.Data.MvPolynomial.Pderiv
import Mathlib.Data.Polynomial.Derivation

#align_import ring_theory.kaehler from "leanprover-community/mathlib"@"4b92a463033b5587bb011657e25e4710bfca7364"

/-!
# The module of kaehler differentials

## Main results

- `KaehlerDifferential`: The module of kaehler differentials. For an `R`-algebra `S`, we provide
  the notation `Œ©[S‚ÅÑR]` for `KaehlerDifferential R S`.
  Note that the slash is `\textfractionsolidus`.
- `KaehlerDifferential.D`: The derivation into the module of kaehler differentials.
- `KaehlerDifferential.span_range_derivation`: The image of `D` spans `Œ©[S‚ÅÑR]` as an `S`-module.
- `KaehlerDifferential.linearMapEquivDerivation`:
  The isomorphism `Hom_R(Œ©[S‚ÅÑR], M) ‚âÉ‚Çó[S] Der_R(S, M)`.
- `KaehlerDifferential.quotKerTotalEquiv`: An alternative description of `Œ©[S‚ÅÑR]` as `S` copies
  of `S` with kernel (`KaehlerDifferential.kerTotal`) generated by the relations:
  1. `dx + dy = d(x + y)`
  2. `x dy + y dx = d(x * y)`
  3. `dr = 0` for `r ‚àà R`
- `KaehlerDifferential.map`: Given a map between the arrows `R ‚Üí A` and `S ‚Üí B`, we have an
  `A`-linear map `Œ©[A‚ÅÑR] ‚Üí Œ©[B‚ÅÑS]`.

## Future project

- Define the `IsKaehlerDifferential` predicate.
-/

suppress_compilation

section KaehlerDifferential

open scoped TensorProduct
open Algebra

universe u v

variable (R : Type u) (S : Type v) [CommRing R] [CommRing S] [Algebra R S]

/-- The kernel of the multiplication map `S ‚äó[R] S ‚Üí‚Çê[R] S`. -/
abbrev KaehlerDifferential.ideal : Ideal (S ‚äó[R] S) :=
  RingHom.ker (TensorProduct.lmul' R : S ‚äó[R] S ‚Üí‚Çê[R] S)
#align kaehler_differential.ideal KaehlerDifferential.ideal

variable {S}

theorem KaehlerDifferential.one_smul_sub_smul_one_mem_ideal (a : S) :
    (1 : S) ‚äó‚Çú[R] a - a ‚äó‚Çú[R] (1 : S) ‚àà KaehlerDifferential.ideal R S := by simp [RingHom.mem_ker]
#align kaehler_differential.one_smul_sub_smul_one_mem_ideal KaehlerDifferential.one_smul_sub_smul_one_mem_ideal

variable {R}
variable {M : Type*} [AddCommGroup M] [Module R M] [Module S M] [IsScalarTower R S M]

/-- For a `R`-derivation `S ‚Üí M`, this is the map `S ‚äó[R] S ‚Üí‚Çó[S] M` sending `s ‚äó‚Çú t ‚Ü¶ s ‚Ä¢ D t`. -/
def Derivation.tensorProductTo (D : Derivation R S M) : S ‚äó[R] S ‚Üí‚Çó[S] M :=
  TensorProduct.AlgebraTensorModule.lift ((LinearMap.lsmul S (S ‚Üí‚Çó[R] M)).flip D.toLinearMap)
#align derivation.tensor_product_to Derivation.tensorProductTo

theorem Derivation.tensorProductTo_tmul (D : Derivation R S M) (s t : S) :
    D.tensorProductTo (s ‚äó‚Çú t) = s ‚Ä¢ D t := rfl
#align derivation.tensor_product_to_tmul Derivation.tensorProductTo_tmul

theorem Derivation.tensorProductTo_mul (D : Derivation R S M) (x y : S ‚äó[R] S) :
    D.tensorProductTo (x * y) =
      TensorProduct.lmul' (S := S) R x ‚Ä¢ D.tensorProductTo y +
        TensorProduct.lmul' (S := S) R y ‚Ä¢ D.tensorProductTo x := by
  refine TensorProduct.induction_on x ?_ ?_ ?_
  ¬∑ rw [zero_mul, map_zero, map_zero, zero_smul, smul_zero, add_zero]
  swap
  ¬∑ intro x‚ÇÅ y‚ÇÅ h‚ÇÅ h‚ÇÇ
    rw [add_mul, map_add, map_add, map_add, add_smul, smul_add, h‚ÇÅ, h‚ÇÇ, add_add_add_comm]
  intro x‚ÇÅ x‚ÇÇ
  refine TensorProduct.induction_on y ?_ ?_ ?_
  ¬∑ rw [mul_zero, map_zero, map_zero, zero_smul, smul_zero, add_zero]
  swap
  ¬∑ intro x‚ÇÅ y‚ÇÅ h‚ÇÅ h‚ÇÇ
    rw [mul_add, map_add, map_add, map_add, add_smul, smul_add, h‚ÇÅ, h‚ÇÇ, add_add_add_comm]
  intro x y
  simp only [TensorProduct.tmul_mul_tmul, Derivation.tensorProductTo,
    TensorProduct.AlgebraTensorModule.lift_apply, TensorProduct.lift.tmul',
    TensorProduct.lmul'_apply_tmul]
  dsimp
  rw [D.leibniz]
  simp only [smul_smul, smul_add, mul_comm (x * y) x‚ÇÅ, mul_right_comm x‚ÇÅ x‚ÇÇ, ‚Üê mul_assoc]
#align derivation.tensor_product_to_mul Derivation.tensorProductTo_mul

variable (R S)

/-- The kernel of `S ‚äó[R] S ‚Üí‚Çê[R] S` is generated by `1 ‚äó s - s ‚äó 1` as a `S`-module. -/
theorem KaehlerDifferential.submodule_span_range_eq_ideal :
    Submodule.span S (Set.range fun s : S => (1 : S) ‚äó‚Çú[R] s - s ‚äó‚Çú[R] (1 : S)) =
      (KaehlerDifferential.ideal R S).restrictScalars S := by
  apply le_antisymm
  ¬∑ rw [Submodule.span_le]
    rintro _ ‚ü®s, rfl‚ü©
    exact KaehlerDifferential.one_smul_sub_smul_one_mem_ideal _ _
  ¬∑ rintro x (hx : _ = _)
    have : x - TensorProduct.lmul' (S := S) R x ‚äó‚Çú[R] (1 : S) = x := by
      rw [hx, TensorProduct.zero_tmul, sub_zero]
    rw [‚Üê this]
    clear this hx
    refine TensorProduct.induction_on x ?_ ?_ ?_
    ¬∑ rw [map_zero, TensorProduct.zero_tmul, sub_zero]; exact zero_mem _
    ¬∑ intro x y
      have : x ‚äó‚Çú[R] y - (x * y) ‚äó‚Çú[R] (1 : S) = x ‚Ä¢ ((1 : S) ‚äó‚Çú y - y ‚äó‚Çú (1 : S)) := by
        simp_rw [smul_sub, TensorProduct.smul_tmul', smul_eq_mul, mul_one]
      rw [TensorProduct.lmul'_apply_tmul, this]
      refine Submodule.smul_mem _ x ?_
      apply Submodule.subset_span
      exact Set.mem_range_self y
    ¬∑ intro x y hx hy
      rw [map_add, TensorProduct.add_tmul, ‚Üê sub_add_sub_comm]
      exact add_mem hx hy
#align kaehler_differential.submodule_span_range_eq_ideal KaehlerDifferential.submodule_span_range_eq_ideal

theorem KaehlerDifferential.span_range_eq_ideal :
    Ideal.span (Set.range fun s : S => (1 : S) ‚äó‚Çú[R] s - s ‚äó‚Çú[R] (1 : S)) =
      KaehlerDifferential.ideal R S := by
  apply le_antisymm
  ¬∑ rw [Ideal.span_le]
    rintro _ ‚ü®s, rfl‚ü©
    exact KaehlerDifferential.one_smul_sub_smul_one_mem_ideal _ _
  ¬∑ change (KaehlerDifferential.ideal R S).restrictScalars S ‚â§ (Ideal.span _).restrictScalars S
    rw [‚Üê KaehlerDifferential.submodule_span_range_eq_ideal, Ideal.span]
    conv_rhs => rw [‚Üê Submodule.span_span_of_tower S]
    exact Submodule.subset_span
#align kaehler_differential.span_range_eq_ideal KaehlerDifferential.span_range_eq_ideal

/-- The module of K√§hler differentials (Kahler differentials, Kaehler differentials).
This is implemented as `I / I ^ 2` with `I` the kernel of the multiplication map `S ‚äó[R] S ‚Üí‚Çê[R] S`.
To view elements as a linear combination of the form `s ‚Ä¢ D s'`, use
`KaehlerDifferential.tensorProductTo_surjective` and `Derivation.tensorProductTo_tmul`.

We also provide the notation `Œ©[S‚ÅÑR]` for `KaehlerDifferential R S`.
Note that the slash is `\textfractionsolidus`.
-/
def KaehlerDifferential : Type v :=
  (KaehlerDifferential.ideal R S).Cotangent
#align kaehler_differential KaehlerDifferential

instance : AddCommGroup (KaehlerDifferential R S) := by
  unfold KaehlerDifferential
  infer_instance

instance KaehlerDifferential.module : Module (S ‚äó[R] S) (KaehlerDifferential R S) :=
  Ideal.Cotangent.moduleOfTower _
#align kaehler_differential.module KaehlerDifferential.module

@[inherit_doc KaehlerDifferential]
notation:100 "Œ©[" S "‚ÅÑ" R "]" => KaehlerDifferential R S

instance : Nonempty (Œ©[S‚ÅÑR]) := ‚ü®0‚ü©

instance KaehlerDifferential.module' {R' : Type*} [CommRing R'] [Algebra R' S]
  [SMulCommClass R R' S] :
    Module R' (Œ©[S‚ÅÑR]) :=
  Submodule.Quotient.module' _
#align kaehler_differential.module' KaehlerDifferential.module'

instance : IsScalarTower S (S ‚äó[R] S) (Œ©[S‚ÅÑR]) :=
  Ideal.Cotangent.isScalarTower _

instance KaehlerDifferential.isScalarTower_of_tower {R‚ÇÅ R‚ÇÇ : Type*} [CommRing R‚ÇÅ] [CommRing R‚ÇÇ]
    [Algebra R‚ÇÅ S] [Algebra R‚ÇÇ S] [SMul R‚ÇÅ R‚ÇÇ]
    [SMulCommClass R R‚ÇÅ S] [SMulCommClass R R‚ÇÇ S] [IsScalarTower R‚ÇÅ R‚ÇÇ S] :
    IsScalarTower R‚ÇÅ R‚ÇÇ (Œ©[S‚ÅÑR]) :=
  Submodule.Quotient.isScalarTower _ _

#align kaehler_differential.is_scalar_tower_of_tower KaehlerDifferential.isScalarTower_of_tower

instance KaehlerDifferential.isScalarTower' : IsScalarTower R (S ‚äó[R] S) (Œ©[S‚ÅÑR]) :=
  Submodule.Quotient.isScalarTower _ _
#align kaehler_differential.is_scalar_tower' KaehlerDifferential.isScalarTower'

/-- The quotient map `I ‚Üí Œ©[S‚ÅÑR]` with `I` being the kernel of `S ‚äó[R] S ‚Üí S`. -/
def KaehlerDifferential.fromIdeal : KaehlerDifferential.ideal R S ‚Üí‚Çó[S ‚äó[R] S] Œ©[S‚ÅÑR] :=
  (KaehlerDifferential.ideal R S).toCotangent
#align kaehler_differential.from_ideal KaehlerDifferential.fromIdeal

/-- (Implementation) The underlying linear map of the derivation into `Œ©[S‚ÅÑR]`. -/
def KaehlerDifferential.DLinearMap : S ‚Üí‚Çó[R] Œ©[S‚ÅÑR] :=
  ((KaehlerDifferential.fromIdeal R S).restrictScalars R).comp
    ((TensorProduct.includeRight.toLinearMap - TensorProduct.includeLeft.toLinearMap :
            S ‚Üí‚Çó[R] S ‚äó[R] S).codRestrict
        ((KaehlerDifferential.ideal R S).restrictScalars R)
        (KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R) :
      _ ‚Üí‚Çó[R] _)
set_option linter.uppercaseLean3 false in
#align kaehler_differential.D_linear_map KaehlerDifferential.DLinearMap

theorem KaehlerDifferential.DLinearMap_apply (s : S) :
    KaehlerDifferential.DLinearMap R S s =
      (KaehlerDifferential.ideal R S).toCotangent
        ‚ü®1 ‚äó‚Çú s - s ‚äó‚Çú 1, KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R s‚ü© := rfl
set_option linter.uppercaseLean3 false in
#align kaehler_differential.D_linear_map_apply KaehlerDifferential.DLinearMap_apply

/-- The universal derivation into `Œ©[S‚ÅÑR]`. -/
def KaehlerDifferential.D : Derivation R S (Œ©[S‚ÅÑR]) :=
  { toLinearMap := KaehlerDifferential.DLinearMap R S
    map_one_eq_zero' := by
      dsimp [KaehlerDifferential.DLinearMap_apply]
      congr
      rw [sub_self]
    leibniz' := fun a b => by
      have : LinearMap.CompatibleSMul { x // x ‚àà ideal R S } (Œ©[S‚ÅÑR]) S (S ‚äó[R] S) := inferInstance
      dsimp [KaehlerDifferential.DLinearMap_apply, - Ideal.toCotangent_apply]
      -- This used to be `rw`, but we need `erw` after leanprover/lean4#2644
      erw [‚Üê LinearMap.map_smul_of_tower (M‚ÇÇ := Œ©[S‚ÅÑR]),
        ‚Üê LinearMap.map_smul_of_tower (M‚ÇÇ := Œ©[S‚ÅÑR]), ‚Üê map_add, Ideal.toCotangent_eq, pow_two]
      convert Submodule.mul_mem_mul (KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R a : _)
        (KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R b : _) using 1
      simp only [AddSubgroupClass.coe_sub, Submodule.coe_add, Submodule.coe_mk,
        TensorProduct.tmul_mul_tmul, mul_sub, sub_mul, mul_comm b, Submodule.coe_smul_of_tower,
        smul_sub, TensorProduct.smul_tmul', smul_eq_mul, mul_one]
      ring_nf }
set_option linter.uppercaseLean3 false in
#align kaehler_differential.D KaehlerDifferential.D

theorem KaehlerDifferential.D_apply (s : S) :
    KaehlerDifferential.D R S s =
      (KaehlerDifferential.ideal R S).toCotangent
        ‚ü®1 ‚äó‚Çú s - s ‚äó‚Çú 1, KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R s‚ü© := rfl
set_option linter.uppercaseLean3 false in
#align kaehler_differential.D_apply KaehlerDifferential.D_apply

theorem KaehlerDifferential.span_range_derivation :
    Submodule.span S (Set.range <| KaehlerDifferential.D R S) = ‚ä§ := by
  rw [_root_.eq_top_iff]
  rintro x -
  obtain ‚ü®‚ü®x, hx‚ü©, rfl‚ü© := Ideal.toCotangent_surjective _ x
  have : x ‚àà (KaehlerDifferential.ideal R S).restrictScalars S := hx
  rw [‚Üê KaehlerDifferential.submodule_span_range_eq_ideal] at this
  suffices ‚àÉ hx, (KaehlerDifferential.ideal R S).toCotangent ‚ü®x, hx‚ü© ‚àà
      Submodule.span S (Set.range <| KaehlerDifferential.D R S) by
    exact this.choose_spec
  refine Submodule.span_induction this ?_ ?_ ?_ ?_
  ¬∑ rintro _ ‚ü®x, rfl‚ü©
    refine ‚ü®KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R x, ?_‚ü©
    apply Submodule.subset_span
    exact ‚ü®x, KaehlerDifferential.DLinearMap_apply R S x‚ü©
  ¬∑ exact ‚ü®zero_mem _, Submodule.zero_mem _‚ü©
  ¬∑ rintro x y ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü© ‚ü®hy‚ÇÅ, hy‚ÇÇ‚ü©; exact ‚ü®add_mem hx‚ÇÅ hy‚ÇÅ, Submodule.add_mem _ hx‚ÇÇ hy‚ÇÇ‚ü©
  ¬∑ rintro r x ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©;
    exact ‚ü®((KaehlerDifferential.ideal R S).restrictScalars S).smul_mem r hx‚ÇÅ,
      Submodule.smul_mem _ r hx‚ÇÇ‚ü©
#align kaehler_differential.span_range_derivation KaehlerDifferential.span_range_derivation

variable {R S}

/-- The linear map from `Œ©[S‚ÅÑR]`, associated with a derivation. -/
def Derivation.liftKaehlerDifferential (D : Derivation R S M) : Œ©[S‚ÅÑR] ‚Üí‚Çó[S] M := by
  refine LinearMap.comp ((((KaehlerDifferential.ideal R S) ‚Ä¢
    (‚ä§ : Submodule (S ‚äó[R] S) (KaehlerDifferential.ideal R S))).restrictScalars S).liftQ ?_ ?_)
    (Submodule.Quotient.restrictScalarsEquiv S _).symm.toLinearMap
  ¬∑ exact D.tensorProductTo.comp ((KaehlerDifferential.ideal R S).subtype.restrictScalars S)
  ¬∑ intro x hx
    rw [LinearMap.mem_ker]
    refine Submodule.smul_induction_on hx ?_ ?_
    ¬∑ rintro x hx y -
      rw [RingHom.mem_ker] at hx
      dsimp
      rw [Derivation.tensorProductTo_mul, hx, y.prop, zero_smul, zero_smul, zero_add]
    ¬∑ intro x y ex ey; rw [map_add, ex, ey, zero_add]
#align derivation.lift_kaehler_differential Derivation.liftKaehlerDifferential

theorem Derivation.liftKaehlerDifferential_apply (D : Derivation R S M) (x) :
    D.liftKaehlerDifferential ((KaehlerDifferential.ideal R S).toCotangent x) =
      D.tensorProductTo x := rfl
#align derivation.lift_kaehler_differential_apply Derivation.liftKaehlerDifferential_apply

theorem Derivation.liftKaehlerDifferential_comp (D : Derivation R S M) :
    D.liftKaehlerDifferential.compDer (KaehlerDifferential.D R S) = D := by
  ext a
  dsimp [KaehlerDifferential.D_apply]
  refine (D.liftKaehlerDifferential_apply _).trans ?_
  rw [Subtype.coe_mk, map_sub, Derivation.tensorProductTo_tmul, Derivation.tensorProductTo_tmul,
    one_smul, D.map_one_eq_zero, smul_zero, sub_zero]
#align derivation.lift_kaehler_differential_comp Derivation.liftKaehlerDifferential_comp

@[simp]
theorem Derivation.liftKaehlerDifferential_comp_D (D' : Derivation R S M) (x : S) :
    D'.liftKaehlerDifferential (KaehlerDifferential.D R S x) = D' x :=
  Derivation.congr_fun D'.liftKaehlerDifferential_comp x
set_option linter.uppercaseLean3 false in
#align derivation.lift_kaehler_differential_comp_D Derivation.liftKaehlerDifferential_comp_D

@[ext]
theorem Derivation.liftKaehlerDifferential_unique (f f' : Œ©[S‚ÅÑR] ‚Üí‚Çó[S] M)
    (hf : f.compDer (KaehlerDifferential.D R S) = f'.compDer (KaehlerDifferential.D R S)) :
    f = f' := by
  apply LinearMap.ext
  intro x
  have : x ‚àà Submodule.span S (Set.range <| KaehlerDifferential.D R S) := by
    rw [KaehlerDifferential.span_range_derivation]; trivial
  refine Submodule.span_induction this ?_ ?_ ?_ ?_
  ¬∑ rintro _ ‚ü®x, rfl‚ü©; exact congr_arg (fun D : Derivation R S M => D x) hf
  ¬∑ rw [map_zero, map_zero]
  ¬∑ intro x y hx hy; rw [map_add, map_add, hx, hy]
  ¬∑ intro a x e; simp [e]
#align derivation.lift_kaehler_differential_unique Derivation.liftKaehlerDifferential_unique

variable (R S)

theorem Derivation.liftKaehlerDifferential_D :
    (KaehlerDifferential.D R S).liftKaehlerDifferential = LinearMap.id :=
  Derivation.liftKaehlerDifferential_unique _ _
    (KaehlerDifferential.D R S).liftKaehlerDifferential_comp
set_option linter.uppercaseLean3 false in
#align derivation.lift_kaehler_differential_D Derivation.liftKaehlerDifferential_D

variable {R S}

theorem KaehlerDifferential.D_tensorProductTo (x : KaehlerDifferential.ideal R S) :
    (KaehlerDifferential.D R S).tensorProductTo x =
      (KaehlerDifferential.ideal R S).toCotangent x := by
  rw [‚Üê Derivation.liftKaehlerDifferential_apply, Derivation.liftKaehlerDifferential_D]
  rfl
set_option linter.uppercaseLean3 false in
#align kaehler_differential.D_tensor_product_to KaehlerDifferential.D_tensorProductTo

variable (R S)

theorem KaehlerDifferential.tensorProductTo_surjective :
    Function.Surjective (KaehlerDifferential.D R S).tensorProductTo := by
  intro x; obtain ‚ü®x, rfl‚ü© := (KaehlerDifferential.ideal R S).toCotangent_surjective x
  exact ‚ü®x, KaehlerDifferential.D_tensorProductTo x‚ü©
#align kaehler_differential.tensor_product_to_surjective KaehlerDifferential.tensorProductTo_surjective

/-- The `S`-linear maps from `Œ©[S‚ÅÑR]` to `M` are (`S`-linearly) equivalent to `R`-derivations
from `S` to `M`.  -/
@[simps! symm_apply apply_apply]
def KaehlerDifferential.linearMapEquivDerivation : (Œ©[S‚ÅÑR] ‚Üí‚Çó[S] M) ‚âÉ‚Çó[S] Derivation R S M :=
  { Derivation.llcomp.flip <| KaehlerDifferential.D R S with
    invFun := Derivation.liftKaehlerDifferential
    left_inv := fun _ =>
      Derivation.liftKaehlerDifferential_unique _ _ (Derivation.liftKaehlerDifferential_comp _)
    right_inv := Derivation.liftKaehlerDifferential_comp }
#align kaehler_differential.linear_map_equiv_derivation KaehlerDifferential.linearMapEquivDerivation

/-- The quotient ring of `S ‚äó S ‚ß∏ J ^ 2` by `Œ©[S‚ÅÑR]` is isomorphic to `S`. -/
def KaehlerDifferential.quotientCotangentIdealRingEquiv :
    (S ‚äó S ‚ß∏ KaehlerDifferential.ideal R S ^ 2) ‚ß∏ (KaehlerDifferential.ideal R S).cotangentIdeal ‚âÉ+*
      S := by
  have : Function.RightInverse (TensorProduct.includeLeft (R := R) (A := S) (B := S))
      (‚Üë(TensorProduct.lmul' R : S ‚äó[R] S ‚Üí‚Çê[R] S) : S ‚äó[R] S ‚Üí+* S) := by
    intro x; rw [AlgHom.coe_toRingHom, ‚Üê AlgHom.comp_apply, TensorProduct.lmul'_comp_includeLeft]
    rfl
  refine (Ideal.quotCotangent _).trans ?_
  refine (Ideal.quotEquivOfEq ?_).trans (RingHom.quotientKerEquivOfRightInverse this)
  ext; rfl
#align kaehler_differential.quotient_cotangent_ideal_ring_equiv KaehlerDifferential.quotientCotangentIdealRingEquiv

/-- The quotient ring of `S ‚äó S ‚ß∏ J ^ 2` by `Œ©[S‚ÅÑR]` is isomorphic to `S` as an `S`-algebra. -/
def KaehlerDifferential.quotientCotangentIdeal :
    ((S ‚äó S ‚ß∏ KaehlerDifferential.ideal R S ^ 2) ‚ß∏
        (KaehlerDifferential.ideal R S).cotangentIdeal) ‚âÉ‚Çê[S] S :=
  { KaehlerDifferential.quotientCotangentIdealRingEquiv R S with
    commutes' := (KaehlerDifferential.quotientCotangentIdealRingEquiv R S).apply_symm_apply }
#align kaehler_differential.quotient_cotangent_ideal KaehlerDifferential.quotientCotangentIdeal

theorem KaehlerDifferential.End_equiv_aux (f : S ‚Üí‚Çê[R] S ‚äó S ‚ß∏ KaehlerDifferential.ideal R S ^ 2) :
    (Ideal.Quotient.mk‚Çê R (KaehlerDifferential.ideal R S).cotangentIdeal).comp f =
        IsScalarTower.toAlgHom R S _ ‚Üî
      (TensorProduct.lmul' R : S ‚äó[R] S ‚Üí‚Çê[R] S).kerSquareLift.comp f = AlgHom.id R S := by
  rw [AlgHom.ext_iff, AlgHom.ext_iff]
  apply forall_congr'
  intro x
  have e‚ÇÅ : (TensorProduct.lmul' R : S ‚äó[R] S ‚Üí‚Çê[R] S).kerSquareLift (f x) =
      KaehlerDifferential.quotientCotangentIdealRingEquiv R S
        (Ideal.Quotient.mk (KaehlerDifferential.ideal R S).cotangentIdeal <| f x) := by
    generalize f x = y; obtain ‚ü®y, rfl‚ü© := Ideal.Quotient.mk_surjective y; rfl
  have e‚ÇÇ :
    x = KaehlerDifferential.quotientCotangentIdealRingEquiv R S (IsScalarTower.toAlgHom R S _ x) :=
    (mul_one x).symm
  constructor
  ¬∑ intro e
    exact (e‚ÇÅ.trans (@RingEquiv.congr_arg _ _ _ _ _ _
      (KaehlerDifferential.quotientCotangentIdealRingEquiv R S) _ _ e)).trans e‚ÇÇ.symm
  ¬∑ intro e; apply (KaehlerDifferential.quotientCotangentIdealRingEquiv R S).injective
    exact e‚ÇÅ.symm.trans (e.trans e‚ÇÇ)
#align kaehler_differential.End_equiv_aux KaehlerDifferential.End_equiv_aux

/- Note: Lean is slow to synthesize theses instances (times out).
  Without them the endEquivDerivation' and endEquivAuxEquiv both have significant timeouts.
  In Mathlib 3, it was slow but not this slow. -/
/-- A shortcut instance to prevent timing out. Hopefully to be removed in the future. -/
local instance smul_SSmod_SSmod : SMul (S ‚äó[R] S ‚ß∏ KaehlerDifferential.ideal R S ^ 2)
    (S ‚äó[R] S ‚ß∏ KaehlerDifferential.ideal R S ^ 2) := Mul.toSMul _

/-- A shortcut instance to prevent timing out. Hopefully to be removed in the future. -/
@[nolint defLemma]
local instance isScalarTower_S_right :
    IsScalarTower S (S ‚äó[R] S ‚ß∏ KaehlerDifferential.ideal R S ^ 2)
      (S ‚äó[R] S ‚ß∏ KaehlerDifferential.ideal R S ^ 2) := Ideal.Quotient.isScalarTower_right

/-- A shortcut instance to prevent timing out. Hopefully to be removed in the future. -/
@[nolint defLemma]
local instance isScalarTower_R_right :
    IsScalarTower R (S ‚äó[R] S ‚ß∏ KaehlerDifferential.ideal R S ^ 2)
      (S ‚äó[R] S ‚ß∏ KaehlerDifferential.ideal R S ^ 2) := Ideal.Quotient.isScalarTower_right

/-- A shortcut instance to prevent timing out. Hopefully to be removed in the future. -/
@[nolint defLemma]
local instance isScalarTower_SS_right : IsScalarTower (S ‚äó[R] S)
    (S ‚äó[R] S ‚ß∏ KaehlerDifferential.ideal R S ^ 2) (S ‚äó[R] S ‚ß∏ KaehlerDifferential.ideal R S ^ 2) :=
  Ideal.Quotient.isScalarTower_right

/-- A shortcut instance to prevent timing out. Hopefully to be removed in the future. -/
local instance instS : Module S (KaehlerDifferential.ideal R S).cotangentIdeal :=
  Submodule.module' _

/-- A shortcut instance to prevent timing out. Hopefully to be removed in the future. -/
local instance instR : Module R (KaehlerDifferential.ideal R S).cotangentIdeal :=
  Submodule.module' _

/-- A shortcut instance to prevent timing out. Hopefully to be removed in the future. -/
local instance instSS : Module (S ‚äó[R] S) (KaehlerDifferential.ideal R S).cotangentIdeal :=
  Submodule.module' _

/-- Derivations into `Œ©[S‚ÅÑR]` is equivalent to derivations
into `(KaehlerDifferential.ideal R S).cotangentIdeal`. -/
noncomputable def KaehlerDifferential.endEquivDerivation' :
    Derivation R S (Œ©[S‚ÅÑR]) ‚âÉ‚Çó[R] Derivation R S (ideal R S).cotangentIdeal :=
  LinearEquiv.compDer ((KaehlerDifferential.ideal R S).cotangentEquivIdeal.restrictScalars S)
#align kaehler_differential.End_equiv_derivation' KaehlerDifferential.endEquivDerivation'

/-- (Implementation) An `Equiv` version of `KaehlerDifferential.End_equiv_aux`.
Used in `KaehlerDifferential.endEquiv`. -/
def KaehlerDifferential.endEquivAuxEquiv :
    { f //
        (Ideal.Quotient.mk‚Çê R (KaehlerDifferential.ideal R S).cotangentIdeal).comp f =
          IsScalarTower.toAlgHom R S _ } ‚âÉ
      { f // (TensorProduct.lmul' R : S ‚äó[R] S ‚Üí‚Çê[R] S).kerSquareLift.comp f = AlgHom.id R S } :=
  (Equiv.refl _).subtypeEquiv (KaehlerDifferential.End_equiv_aux R S)
#align kaehler_differential.End_equiv_aux_equiv KaehlerDifferential.endEquivAuxEquiv

/--
The endomorphisms of `Œ©[S‚ÅÑR]` corresponds to sections of the surjection `S ‚äó[R] S ‚ß∏ J ^ 2 ‚Üí‚Çê[R] S`,
with `J` being the kernel of the multiplication map `S ‚äó[R] S ‚Üí‚Çê[R] S`.
-/
noncomputable def KaehlerDifferential.endEquiv :
    Module.End S (Œ©[S‚ÅÑR]) ‚âÉ
      { f // (TensorProduct.lmul' R : S ‚äó[R] S ‚Üí‚Çê[R] S).kerSquareLift.comp f = AlgHom.id R S } :=
  (KaehlerDifferential.linearMapEquivDerivation R S).toEquiv.trans <|
    (KaehlerDifferential.endEquivDerivation' R S).toEquiv.trans <|
      (derivationToSquareZeroEquivLift (KaehlerDifferential.ideal R S).cotangentIdeal
            (KaehlerDifferential.ideal R S).cotangentIdeal_square).trans <|
        KaehlerDifferential.endEquivAuxEquiv R S
#align kaehler_differential.End_equiv KaehlerDifferential.endEquiv

section Presentation

open KaehlerDifferential (D)

open Finsupp (single)

/-- The `S`-submodule of `S ‚Üí‚ÇÄ S` (the direct sum of copies of `S` indexed by `S`) generated by
the relations:
1. `dx + dy = d(x + y)`
2. `x dy + y dx = d(x * y)`
3. `dr = 0` for `r ‚àà R`
where `db` is the unit in the copy of `S` with index `b`.

This is the kernel of the surjection `Finsupp.total S Œ©[S‚ÅÑR] S (KaehlerDifferential.D R S)`.
See `KaehlerDifferential.kerTotal_eq` and `KaehlerDifferential.total_surjective`.
-/
noncomputable def KaehlerDifferential.kerTotal : Submodule S (S ‚Üí‚ÇÄ S) :=
  Submodule.span S
    (((Set.range fun x : S √ó S => single x.1 1 + single x.2 1 - single (x.1 + x.2) 1) ‚à™
        Set.range fun x : S √ó S => single x.2 x.1 + single x.1 x.2 - single (x.1 * x.2) 1) ‚à™
      Set.range fun x : R => single (algebraMap R S x) 1)
#align kaehler_differential.ker_total KaehlerDifferential.kerTotal

unsuppress_compilation in
-- Porting note: was `local notation x "ùñ£" y => (KaehlerDifferential.kerTotal R S).mkQ (single y x)`
-- but not having `DFunLike.coe` leads to `kerTotal_mkQ_single_smul` failing.
local notation3 x "ùñ£" y => DFunLike.coe (KaehlerDifferential.kerTotal R S).mkQ (single y x)

theorem KaehlerDifferential.kerTotal_mkQ_single_add (x y z) : (zùñ£x + y) = (zùñ£x) + zùñ£y := by
  rw [‚Üê map_add, eq_comm, ‚Üê sub_eq_zero, ‚Üê map_sub (Submodule.mkQ (kerTotal R S)),
    Submodule.mkQ_apply, Submodule.Quotient.mk_eq_zero]
  simp_rw [‚Üê Finsupp.smul_single_one _ z, ‚Üê smul_add, ‚Üê smul_sub]
  exact Submodule.smul_mem _ _ (Submodule.subset_span (Or.inl <| Or.inl <| ‚ü®‚ü®_, _‚ü©, rfl‚ü©))
#align kaehler_differential.ker_total_mkq_single_add KaehlerDifferential.kerTotal_mkQ_single_add

theorem KaehlerDifferential.kerTotal_mkQ_single_mul (x y z) :
    (zùñ£x * y) = ((z * x)ùñ£y) + (z * y)ùñ£x := by
  rw [‚Üê map_add, eq_comm, ‚Üê sub_eq_zero, ‚Üê map_sub (Submodule.mkQ (kerTotal R S)),
    Submodule.mkQ_apply, Submodule.Quotient.mk_eq_zero]
  simp_rw [‚Üê Finsupp.smul_single_one _ z, ‚Üê @smul_eq_mul _ _ z, ‚Üê Finsupp.smul_single, ‚Üê smul_add,
    ‚Üê smul_sub]
  exact Submodule.smul_mem _ _ (Submodule.subset_span (Or.inl <| Or.inr <| ‚ü®‚ü®_, _‚ü©, rfl‚ü©))
#align kaehler_differential.ker_total_mkq_single_mul KaehlerDifferential.kerTotal_mkQ_single_mul

theorem KaehlerDifferential.kerTotal_mkQ_single_algebraMap (x y) : (yùñ£algebraMap R S x) = 0 := by
  rw [Submodule.mkQ_apply, Submodule.Quotient.mk_eq_zero, ‚Üê Finsupp.smul_single_one _ y]
  exact Submodule.smul_mem _ _ (Submodule.subset_span (Or.inr <| ‚ü®_, rfl‚ü©))
#align kaehler_differential.ker_total_mkq_single_algebra_map KaehlerDifferential.kerTotal_mkQ_single_algebraMap

theorem KaehlerDifferential.kerTotal_mkQ_single_algebraMap_one (x) : (xùñ£1) = 0 := by
  rw [‚Üê (algebraMap R S).map_one, KaehlerDifferential.kerTotal_mkQ_single_algebraMap]
#align kaehler_differential.ker_total_mkq_single_algebra_map_one KaehlerDifferential.kerTotal_mkQ_single_algebraMap_one

theorem KaehlerDifferential.kerTotal_mkQ_single_smul (r : R) (x y) : (yùñ£r ‚Ä¢ x) = r ‚Ä¢ yùñ£x := by
  letI : SMulZeroClass R S := inferInstance
  rw [Algebra.smul_def, KaehlerDifferential.kerTotal_mkQ_single_mul,
    KaehlerDifferential.kerTotal_mkQ_single_algebraMap, add_zero, ‚Üê LinearMap.map_smul_of_tower,
    Finsupp.smul_single, mul_comm, Algebra.smul_def]
#align kaehler_differential.ker_total_mkq_single_smul KaehlerDifferential.kerTotal_mkQ_single_smul

/-- The (universal) derivation into `(S ‚Üí‚ÇÄ S) ‚ß∏ KaehlerDifferential.kerTotal R S`. -/
noncomputable def KaehlerDifferential.derivationQuotKerTotal :
    Derivation R S ((S ‚Üí‚ÇÄ S) ‚ß∏ KaehlerDifferential.kerTotal R S) where
  toFun x := 1ùñ£x
  map_add' x y := KaehlerDifferential.kerTotal_mkQ_single_add _ _ _ _ _
  map_smul' r s := KaehlerDifferential.kerTotal_mkQ_single_smul _ _ _ _ _
  map_one_eq_zero' := KaehlerDifferential.kerTotal_mkQ_single_algebraMap_one _ _ _
  leibniz' a b :=
    (KaehlerDifferential.kerTotal_mkQ_single_mul _ _ _ _ _).trans
      (by simp_rw [‚Üê Finsupp.smul_single_one _ (1 * _ : S)]; dsimp; simp)
#align kaehler_differential.derivation_quot_ker_total KaehlerDifferential.derivationQuotKerTotal

theorem KaehlerDifferential.derivationQuotKerTotal_apply (x) :
    KaehlerDifferential.derivationQuotKerTotal R S x = 1ùñ£x :=
  rfl
#align kaehler_differential.derivation_quot_ker_total_apply KaehlerDifferential.derivationQuotKerTotal_apply

theorem KaehlerDifferential.derivationQuotKerTotal_lift_comp_total :
    (KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential.comp
        (Finsupp.total S (Œ©[S‚ÅÑR]) S (KaehlerDifferential.D R S)) =
      Submodule.mkQ _ := by
  apply Finsupp.lhom_ext
  intro a b
  conv_rhs => rw [‚Üê Finsupp.smul_single_one a b, LinearMap.map_smul]
  simp [KaehlerDifferential.derivationQuotKerTotal_apply]
#align kaehler_differential.derivation_quot_ker_total_lift_comp_total KaehlerDifferential.derivationQuotKerTotal_lift_comp_total

theorem KaehlerDifferential.kerTotal_eq :
    LinearMap.ker (Finsupp.total S (Œ©[S‚ÅÑR]) S (KaehlerDifferential.D R S)) =
      KaehlerDifferential.kerTotal R S := by
  apply le_antisymm
  ¬∑ conv_rhs => rw [‚Üê (KaehlerDifferential.kerTotal R S).ker_mkQ]
    rw [‚Üê KaehlerDifferential.derivationQuotKerTotal_lift_comp_total]
    exact LinearMap.ker_le_ker_comp _ _
  ¬∑ rw [KaehlerDifferential.kerTotal, Submodule.span_le]
    rintro _ ((‚ü®‚ü®x, y‚ü©, rfl‚ü© | ‚ü®‚ü®x, y‚ü©, rfl‚ü©) | ‚ü®x, rfl‚ü©) <;> dsimp <;> simp [LinearMap.mem_ker]
#align kaehler_differential.ker_total_eq KaehlerDifferential.kerTotal_eq

theorem KaehlerDifferential.total_surjective :
    Function.Surjective (Finsupp.total S (Œ©[S‚ÅÑR]) S (KaehlerDifferential.D R S)) := by
  rw [‚Üê LinearMap.range_eq_top, Finsupp.range_total, KaehlerDifferential.span_range_derivation]
#align kaehler_differential.total_surjective KaehlerDifferential.total_surjective

/-- `Œ©[S‚ÅÑR]` is isomorphic to `S` copies of `S` with kernel `KaehlerDifferential.kerTotal`. -/
@[simps!]
noncomputable def KaehlerDifferential.quotKerTotalEquiv :
    ((S ‚Üí‚ÇÄ S) ‚ß∏ KaehlerDifferential.kerTotal R S) ‚âÉ‚Çó[S] Œ©[S‚ÅÑR] :=
  { (KaehlerDifferential.kerTotal R S).liftQ
      (Finsupp.total S (Œ©[S‚ÅÑR]) S (KaehlerDifferential.D R S))
      (KaehlerDifferential.kerTotal_eq R S).ge with
    invFun := (KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential
    left_inv := by
      intro x
      obtain ‚ü®x, rfl‚ü© := Submodule.mkQ_surjective _ x
      exact
        LinearMap.congr_fun (KaehlerDifferential.derivationQuotKerTotal_lift_comp_total R S : _) x
    right_inv := by
      intro x
      obtain ‚ü®x, rfl‚ü© := KaehlerDifferential.total_surjective R S x
      have := LinearMap.congr_fun (KaehlerDifferential.derivationQuotKerTotal_lift_comp_total R S) x
      rw [LinearMap.comp_apply] at this
      rw [this]
      rfl }
#align kaehler_differential.quot_ker_total_equiv KaehlerDifferential.quotKerTotalEquiv

theorem KaehlerDifferential.quotKerTotalEquiv_symm_comp_D :
    (KaehlerDifferential.quotKerTotalEquiv R S).symm.toLinearMap.compDer
        (KaehlerDifferential.D R S) =
      KaehlerDifferential.derivationQuotKerTotal R S := by
  convert (KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential_comp
set_option linter.uppercaseLean3 false in
#align kaehler_differential.quot_ker_total_equiv_symm_comp_D KaehlerDifferential.quotKerTotalEquiv_symm_comp_D

variable (A B : Type*) [CommRing A] [CommRing B] [Algebra R A] [Algebra S B] [Algebra R B]
variable [Algebra A B] [IsScalarTower R S B] [IsScalarTower R A B]

unsuppress_compilation in
-- The map `(A ‚Üí‚ÇÄ A) ‚Üí‚Çó[A] (B ‚Üí‚ÇÄ B)`
local macro "finsupp_map" : term =>
  `((Finsupp.mapRange.linearMap (Algebra.linearMap A B)).comp
    (Finsupp.lmapDomain A A (algebraMap A B)))

theorem KaehlerDifferential.kerTotal_map (h : Function.Surjective (algebraMap A B)) :
    (KaehlerDifferential.kerTotal R A).map finsupp_map ‚äî
        Submodule.span A (Set.range fun x : S => single (algebraMap S B x) (1 : B)) =
      (KaehlerDifferential.kerTotal S B).restrictScalars _ := by
  rw [KaehlerDifferential.kerTotal, Submodule.map_span, KaehlerDifferential.kerTotal,
    Submodule.restrictScalars_span _ _ h]
  -- Porting note: the proof is diverging from the mathlib3 proof here.
  -- `map_sub` and `map_add` are not firing so we need to use `LinearMap.map_*` instead
  simp_rw [Set.image_union, Submodule.span_union, ‚Üê Set.image_univ, Set.image_image, Set.image_univ,
    LinearMap.map_sub, LinearMap.map_add]
  simp only [LinearMap.comp_apply, Finsupp.lmapDomain_apply, Finsupp.mapDomain_single,
    Finsupp.mapRange.linearMap_apply, Finsupp.mapRange_single, Algebra.linearMap_apply,
    map_one, map_add, map_mul]
  simp_rw [sup_assoc, ‚Üê (h.Prod_map h).range_comp]
  congr!
  -- Porting note: new
  simp_rw [‚Üê IsScalarTower.algebraMap_apply R A B]
  rw [sup_eq_right]
  apply Submodule.span_mono
  simp_rw [IsScalarTower.algebraMap_apply R S B]
  exact Set.range_comp_subset_range (algebraMap R S) fun x => single (algebraMap S B x) (1 : B)
#align kaehler_differential.ker_total_map KaehlerDifferential.kerTotal_map

theorem KaehlerDifferential.kerTotal_map' (h : Function.Surjective (algebraMap A B)) :
    (KaehlerDifferential.kerTotal R A ‚äî
      Submodule.span A (Set.range fun x ‚Ü¶ single (algebraMap R A x) 1)).map finsupp_map =
      (KaehlerDifferential.kerTotal R B).restrictScalars _ := by
  rw [Submodule.map_sup, ‚Üê kerTotal_map R R A B h, Submodule.map_span, ‚Üê Set.range_comp]
  congr
  refine congr_arg Set.range ?_
  ext; simp [IsScalarTower.algebraMap_eq R A B]

end Presentation

section ExactSequence

/- We have the commutative diagram
A --‚Üí B
‚Üë     ‚Üë
|     |
R --‚Üí S -/
variable (A B : Type*) [CommRing A] [CommRing B] [Algebra R A] [Algebra R B]
variable [Algebra A B] [Algebra S B] [IsScalarTower R A B] [IsScalarTower R S B]
variable [SMulCommClass S A B]

/-- The map `Œ©[A‚ÅÑR] ‚Üí‚Çó[A] Œ©[B‚ÅÑS]` given a square
A --‚Üí B
‚Üë     ‚Üë
|     |
R --‚Üí S -/
def KaehlerDifferential.map : Œ©[A‚ÅÑR] ‚Üí‚Çó[A] Œ©[B‚ÅÑS] :=
  Derivation.liftKaehlerDifferential
    (((KaehlerDifferential.D S B).restrictScalars R).compAlgebraMap A)
#align kaehler_differential.map KaehlerDifferential.map

theorem KaehlerDifferential.map_compDer :
    (KaehlerDifferential.map R S A B).compDer (KaehlerDifferential.D R A) =
      ((KaehlerDifferential.D S B).restrictScalars R).compAlgebraMap A :=
  Derivation.liftKaehlerDifferential_comp _
#align kaehler_differential.map_comp_der KaehlerDifferential.map_compDer

@[simp]
theorem KaehlerDifferential.map_D (x : A) :
    KaehlerDifferential.map R S A B (KaehlerDifferential.D R A x) =
      KaehlerDifferential.D S B (algebraMap A B x) :=
  Derivation.congr_fun (KaehlerDifferential.map_compDer R S A B) x
set_option linter.uppercaseLean3 false in
#align kaehler_differential.map_D KaehlerDifferential.map_D

unsuppress_compilation in
-- The map `(A ‚Üí‚ÇÄ A) ‚Üí‚Çó[A] (B ‚Üí‚ÇÄ B)`
local macro "finsupp_map" : term =>
  `((Finsupp.mapRange.linearMap (Algebra.linearMap A B)).comp
    (Finsupp.lmapDomain A A (algebraMap A B)))

theorem KaehlerDifferential.ker_map :
    LinearMap.ker (KaehlerDifferential.map R S A B) =
      (((kerTotal S B).restrictScalars A).comap finsupp_map).map
        (Finsupp.total A (Œ©[A‚ÅÑR]) A (D R A)) := by
  rw [‚Üê Submodule.map_comap_eq_of_surjective (total_surjective R A) (LinearMap.ker _)]
  congr 1
  ext x
  simp only [Submodule.mem_comap, LinearMap.mem_ker, Finsupp.apply_total, ‚Üê kerTotal_eq,
    Submodule.restrictScalars_mem]
  simp only [Finsupp.total_apply, Function.comp_apply, LinearMap.coe_comp, Finsupp.lmapDomain_apply,
    Finsupp.mapRange.linearMap_apply]
  rw [Finsupp.sum_mapRange_index, Finsupp.sum_mapDomain_index]
  ¬∑ simp [ofId]
  ¬∑ simp
  ¬∑ simp [add_smul]
  ¬∑ simp

open IsScalarTower (toAlgHom)

theorem KaehlerDifferential.map_surjective_of_surjective
    (h : Function.Surjective (algebraMap A B)) :
    Function.Surjective (KaehlerDifferential.map R S A B) := by
  rw [‚Üê LinearMap.range_eq_top, _root_.eq_top_iff, ‚Üê @Submodule.restrictScalars_top A B,
    ‚Üê KaehlerDifferential.span_range_derivation, Submodule.restrictScalars_span _ _ h,
    Submodule.span_le]
  rintro _ ‚ü®x, rfl‚ü©
  obtain ‚ü®y, rfl‚ü© := h x
  rw [‚Üê KaehlerDifferential.map_D R S A B]
  exact ‚ü®_, rfl‚ü©
#align kaehler_differential.map_surjective_of_surjective KaehlerDifferential.map_surjective_of_surjective

/-- The lift of the map `Œ©[A‚ÅÑR] ‚Üí‚Çó[A] Œ©[B‚ÅÑR]` to the base change along `A ‚Üí B`.
This is the first map in the exact sequence `B ‚äó[A] Œ©[A‚ÅÑR] ‚Üí Œ©[B‚ÅÑR] ‚Üí Œ©[B‚ÅÑA] ‚Üí 0`. -/
noncomputable def KaehlerDifferential.mapBaseChange : B ‚äó[A] Œ©[A‚ÅÑR] ‚Üí‚Çó[B] Œ©[B‚ÅÑR] :=
  (TensorProduct.isBaseChange A (Œ©[A‚ÅÑR]) B).lift (KaehlerDifferential.map R R A B)
#align kaehler_differential.map_base_change KaehlerDifferential.mapBaseChange

@[simp]
theorem KaehlerDifferential.mapBaseChange_tmul (x : B) (y : Œ©[A‚ÅÑR]) :
    KaehlerDifferential.mapBaseChange R A B (x ‚äó‚Çú y) = x ‚Ä¢ KaehlerDifferential.map R R A B y := by
  conv_lhs => rw [‚Üê mul_one x, ‚Üê smul_eq_mul, ‚Üê TensorProduct.smul_tmul', LinearMap.map_smul]
  congr 1
  exact IsBaseChange.lift_eq _ _ _
#align kaehler_differential.map_base_change_tmul KaehlerDifferential.mapBaseChange_tmul

lemma KaehlerDifferential.range_mapBaseChange :
    LinearMap.range (mapBaseChange R A B) = LinearMap.ker (map R A B B) := by
  apply le_antisymm
  ¬∑ rintro _ ‚ü®x, rfl‚ü©
    induction' x using TensorProduct.induction_on with r s
    ¬∑ simp
    ¬∑ obtain ‚ü®x, rfl‚ü© := total_surjective _ _ s
      simp only [mapBaseChange_tmul, LinearMap.mem_ker, map_smul]
      induction x using Finsupp.induction_linear
      ¬∑ simp
      ¬∑ simp [smul_add, *]
      ¬∑ simp
    ¬∑ rw [map_add]; exact add_mem ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫
  ¬∑ convert_to (kerTotal A B).map (Finsupp.total B (Œ©[B‚ÅÑR]) B (D R B)) ‚â§ _
    ¬∑ rw [KaehlerDifferential.ker_map]
      congr 1
      convert Submodule.comap_id _
      ¬∑ ext; simp
    rw [Submodule.map_le_iff_le_comap, kerTotal, Submodule.span_le]
    rintro f ((‚ü®‚ü®x, y‚ü©, rfl‚ü©|‚ü®‚ü®x, y‚ü©, rfl‚ü©)|‚ü®x, rfl‚ü©)
    ¬∑ use 0; simp
    ¬∑ use 0; simp
    ¬∑ use 1 ‚äó‚Çú D _ _ x; simp

@[simps]
def KaehlerDifferential.kerCotangentToTensor :
    RingHom.ker (algebraMap A B) ‚Üí‚Çó[A] B ‚äó[A] Œ©[A‚ÅÑR] where
  toFun x := 1 ‚äó‚Çú D R A x
  map_add' x y := by simp [TensorProduct.tmul_add]
  map_smul' r x := by { simp [TensorProduct.tmul_add, TensorProduct.smul_tmul',
    ‚Üê algebraMap_eq_smul_one, (RingHom.mem_ker _).mp x.prop] }

def KaehlerDifferential.tensorKerCotangentToTensor :
    B ‚äó[A] RingHom.ker (algebraMap A B) ‚Üí‚Çó[B] B ‚äó[A] Œ©[A‚ÅÑR] :=
  TensorProduct.AlgebraTensorModule.lift ((Algebra.lsmul B B (RingHom.ker
    (algebraMap A B) ‚Üí‚Çó[A] B ‚äó[A] Œ©[A‚ÅÑR])).toLinearMap.flip (kerCotangentToTensor R A B))

@[simp]
lemma KaehlerDifferential.tensorKerCotangentToTensor_tmul (x y) :
    tensorKerCotangentToTensor R A B (x ‚äó‚Çú y) = x ‚äó‚Çú D R A y := by
  simp [tensorKerCotangentToTensor, TensorProduct.smul_tmul']

lemma KaehlerDifferential.ker_map_of_surjective (h : Function.Surjective (algebraMap A B)) :
    LinearMap.ker (map R R A B) =
      (LinearMap.ker finsupp_map).map (Finsupp.total A _ A (D R A)) := by
  rw [ker_map, ‚Üê kerTotal_map' R A B h, Submodule.comap_map_eq, Submodule.map_sup,
    Submodule.map_sup, ‚Üê kerTotal_eq, ‚Üê Submodule.comap_bot, Submodule.map_comap_eq_of_surjective,
    bot_sup_eq, Submodule.map_span, ‚Üê Set.range_comp]
  convert bot_sup_eq _
  rw [Submodule.span_eq_bot]; simp
  exact total_surjective _ _

lemma KaehlerDifferential.range_tensorKerCotangentToTensor
  (h : Function.Surjective (algebraMap A B)) :
    LinearMap.range (tensorKerCotangentToTensor R A B) = LinearMap.ker (mapBaseChange R A B) := by
  classical
  apply le_antisymm
  ¬∑ rintro _ ‚ü®x, rfl‚ü©
    induction' x using TensorProduct.induction_on with x y
    ¬∑ simp
    ¬∑ simp [(RingHom.mem_ker _).mp y.prop]
    ¬∑ rw [map_add]; exact add_mem ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫
  ¬∑ intro x hx
    obtain ‚ü®x, rfl‚ü© := (LinearMap.rTensor_surjective (Œ©[A‚ÅÑR])
      (g := (Algebra.ofId A B).toLinearMap) h).comp (TensorProduct.lid A _).symm.surjective x
    replace hx : x ‚àà LinearMap.ker (map R R A B) := by simpa using hx
    rw [ker_map_of_surjective R A B h] at hx
    obtain ‚ü®x, hx, rfl‚ü© := hx
    rw [‚Üê Finsupp.sum_single x, Finsupp.sum, ‚Üê Finset.sum_fiberwise_of_maps_to
      (fun _ ‚Ü¶ Finset.mem_image_of_mem (algebraMap A B))]
    simp only [Function.comp_apply, map_sum (s := x.support.image (algebraMap A B))]
    apply sum_mem
    intro c _
    simp only [Finset.filter_congr_decidable, TensorProduct.lid_symm_apply, LinearMap.rTensor_tmul,
      AlgHom.toLinearMap_apply, map_one, LinearMap.mem_range]
    simp only [map_sum, Finsupp.total_single]
    have : (x.support.filter (algebraMap A B ¬∑ = c)).sum x ‚àà RingHom.ker (algebraMap A B) := by
      simpa [Finsupp.mapDomain, Finsupp.sum, Finsupp.finset_sum_apply, RingHom.mem_ker,
        Finsupp.single_apply, ‚Üê Finset.sum_filter] using DFunLike.congr_fun hx c
    obtain ‚ü®a, ha‚ü© := h c
    use (x.support.filter (algebraMap A B ¬∑ = c)).attach.sum fun i ‚Ü¶ x i ‚Ä¢ 1 ‚äó‚Çú ‚ü®i - a, ?_‚ü©; swap
    ¬∑ have : x i ‚â† 0 ‚àß algebraMap A B i = c := by simpa using i.prop
      simp [RingHom.mem_ker, ha, this.2]
    ¬∑ simp only [map_sum, LinearMap.map_smul_of_tower, tensorKerCotangentToTensor_tmul, map_sub]
      simp_rw [‚Üê TensorProduct.tmul_smul]
      simp only [smul_sub, TensorProduct.tmul_sub, Finset.sum_sub_distrib, ‚Üê TensorProduct.tmul_sum,
        ‚Üê Finset.sum_smul, Finset.sum_attach, sub_eq_self,
        Finset.sum_attach (f := fun i ‚Ü¶ x i ‚Ä¢ D R A i)]
      rw [‚Üê TensorProduct.smul_tmul, ‚Üê algebraMap_eq_smul_one, (RingHom.mem_ker _).mp this,
        TensorProduct.zero_tmul]

variable {P} [CommRing P] [Algebra R P] (f : P ‚Üí‚Çê[R] A)

@[simps]
def KaehlerDifferential.derivationOfSplit
    (g : A ‚Üí‚Çê[R] P ‚ß∏ (RingHom.ker f.toRingHom) ^ 2)
    (hg : f.kerSquareLift.comp g = AlgHom.id R A) :
    Derivation R (P ‚ß∏ (RingHom.ker f.toRingHom) ^ 2) (RingHom.ker f.toRingHom).cotangentIdeal where
  toFun x := ‚ü®x - (g (f.kerSquareLift x)), (by
    rw [‚Üê AlgHom.ker_kerSquareLift f, RingHom.mem_ker, map_sub]
    show f.kerSquareLift x - (f.kerSquareLift.comp g) (f.kerSquareLift x) = 0
    rw [hg, AlgHom.id_apply, sub_self])‚ü©
  map_add' x y := Subtype.ext (by simp; ring)
  map_smul' r x := Subtype.ext (show _ = r ‚Ä¢ (x - _) by simp only [AlgHom.toRingHom_eq_coe,
    map_smul, smul_sub])
  map_one_eq_zero' := Subtype.ext (show 1 - _ = 0 by simp only [AlgHom.toRingHom_eq_coe, map_one,
    sub_self])
  leibniz' x y := by
    apply Subtype.ext
    show _ - _ = x * (y - _) + y * (x - _)
    simp only [AlgHom.toRingHom_eq_coe, map_mul]
    rw [eq_comm, ‚Üê sub_eq_zero]
    trans (x - g (f.kerSquareLift x)) * (y - g (f.kerSquareLift y))
    ¬∑ generalize g (f.kerSquareLift x) = x'; generalize g (f.kerSquareLift y) = y'; ring
    rw [‚Üê Ideal.mem_bot, ‚Üê Ideal.cotangentIdeal_square, pow_two (RingHom.ker _).cotangentIdeal]
    have : ‚àÄ x, x - g (f.kerSquareLift x) ‚àà (RingHom.ker f.toRingHom).cotangentIdeal := by
      intro x
      rw [‚Üê AlgHom.ker_kerSquareLift f, RingHom.mem_ker, map_sub]
      show f.kerSquareLift x - (f.kerSquareLift.comp g) (f.kerSquareLift x) = 0
      rw [hg, AlgHom.id_apply, sub_self]
    apply Ideal.mul_mem_mul (this x) (this y)

noncomputable
def quotientTensorEquiv {R} [CommRing R] (I : Ideal R) (M) [AddCommGroup M] [Module R M] :
    (R ‚ß∏ I) ‚äó[R] M ‚âÉ‚Çó[R] M ‚ß∏ (I ‚Ä¢ ‚ä§ : Submodule R M) := by
  refine LinearEquiv.ofBijective (_root_.TensorProduct.lift (Submodule.liftQ I
    ((Algebra.lsmul R R M).toLinearMap.compr‚ÇÇ (Submodule.mkQ _)) ?_)) ‚ü®?_, ?_‚ü©
  ¬∑ intro i hi; ext m
    suffices Submodule.mkQ (I ‚Ä¢ ‚ä§ : Submodule R M) (i ‚Ä¢ m) = 0 by simpa using this
    rw [Submodule.mkQ_apply, Submodule.Quotient.mk_eq_zero]
    exact Submodule.smul_mem_smul hi Submodule.mem_top
  ¬∑ rw [injective_iff_map_eq_zero]
    intro x hx
    obtain ‚ü®x, rfl‚ü© := (LinearMap.rTensor_surjective M (g := (Algebra.ofId R (R ‚ß∏ I)).toLinearMap)
      Ideal.Quotient.mk_surjective).comp (_root_.TensorProduct.lid R M).symm.surjective x
    have hx : Submodule.Quotient.mk ((1 : R) ‚Ä¢ x) = 0 := hx
    rw [Submodule.Quotient.mk_eq_zero, one_smul] at hx
    suffices (1 : R ‚ß∏ I) ‚äó‚Çú[R] x = 0 by simpa using this
    refine Submodule.smul_induction_on hx ?_ ?_
    ¬∑ intros r hr n _; rw [‚Üê TensorProduct.smul_tmul, ‚Üê algebraMap_eq_smul_one,
        Ideal.Quotient.algebraMap_eq, Ideal.Quotient.eq_zero_iff_mem.mpr hr, TensorProduct.zero_tmul]
    ¬∑ intro x y hx hy; rw [TensorProduct.tmul_add, hx, hy, zero_add]
  ¬∑ intro x
    obtain ‚ü®x, rfl‚ü© := Submodule.mkQ_surjective _ x
    use (1 : R ‚ß∏ I) ‚äó‚Çú[R] x
    exact one_smul R (Submodule.mkQ (I ‚Ä¢ ‚ä§ : Submodule R M) x)

noncomputable
def tensorEquivOfSurjective {R S} [CommRing R] [CommRing S] [Algebra R S]
    (h : Function.Surjective (algebraMap R S)) {M} [AddCommGroup M] [Module R M] :
    S ‚äó[R] M ‚âÉ‚Çó[R] M ‚ß∏ ((RingHom.ker (algebraMap R S)) ‚Ä¢ ‚ä§ : Submodule R M) :=
  (_root_.TensorProduct.congr (Ideal.quotientKerAlgEquivOfSurjective (f := Algebra.ofId R S)
    h).symm.toLinearEquiv (LinearEquiv.refl R M)).trans (quotientTensorEquiv _ M)

noncomputable
def Ideal.tensorKerEquivCotangentIdeal {R S} [CommRing R] [CommRing S] [Algebra R S]
      (hf : Function.Surjective (algebraMap R S)) :
    S ‚äó[R] (RingHom.ker (algebraMap R S)) ‚âÉ‚Çó[R] (RingHom.ker (algebraMap R S)).cotangentIdeal :=
  (tensorEquivOfSurjective hf).trans (Ideal.cotangentEquivIdeal _)

@[simp]
lemma Ideal.tensorKerEquivCotangentIdeal_tmul {R S} [CommRing R] [CommRing S] [Algebra R S]
      (hf : Function.Surjective (algebraMap R S)) (x) (y) :
    (tensorKerEquivCotangentIdeal hf ((algebraMap R S x) ‚äó‚Çú y)).1 = ‚Üë(x * y : R) := by
  simp only [tensorKerEquivCotangentIdeal, tensorEquivOfSurjective, LinearEquiv.trans_apply,
    TensorProduct.congr_tmul, AlgEquiv.toLinearEquiv_apply, AlgEquiv.commutes,
    Quotient.algebraMap_eq, LinearEquiv.refl_apply, _root_.map_mul]
  rfl

@[simp]
lemma Ideal.tensorKerEquivCotangentIdeal_one_tmul {R S} [CommRing R] [CommRing S] [Algebra R S]
      (hf : Function.Surjective (algebraMap R S)) (x) :
    (tensorKerEquivCotangentIdeal hf (1 ‚äó‚Çú x)).1 = ‚Üë(x : R) := by
  rw [‚Üê (algebraMap R S).map_one, tensorKerEquivCotangentIdeal_tmul, one_mul]

variable {A}
variable [Algebra P A] [IsScalarTower R P A] (h : Function.Surjective (algebraMap P A))

set_option synthInstance.maxHeartbeats 1000000 in
set_option maxHeartbeats 1000000 in
noncomputable
def KaehlerDifferential.derivationCotangentIdealEquiv :
    Derivation R P (RingHom.ker (algebraMap P A)).cotangentIdeal ‚âÉ‚Çó[P]
      (A ‚äó[P] Œ©[P‚ÅÑR] ‚Üí‚Çó[A] A ‚äó[P] RingHom.ker (algebraMap P A)) :=
  (((linearMapEquivDerivation R P).symm.trans
    (Ideal.tensorKerEquivCotangentIdeal h).symm.congrRight).trans
    (LinearMap.ringLmapEquivSelf A P _).symm).trans
    (TensorProduct.AlgebraTensorModule.lift.equiv P A P A (Œ©[P‚ÅÑR]) _)

@[simp]
lemma KaehlerDifferential.derivationCotangentIdealEquiv_apply
    (D : Derivation R P _) (x : P) (y : P) :
    derivationCotangentIdealEquiv R h D (algebraMap P A x ‚äó‚Çú KaehlerDifferential.D R P y) =
      x ‚Ä¢ (Ideal.tensorKerEquivCotangentIdeal h).symm (D y) := by
  apply (Ideal.tensorKerEquivCotangentIdeal h).injective
  ext
  simp [derivationCotangentIdealEquiv, TensorProduct.AlgebraTensorModule.lift.equiv,
    LinearEquiv.congrRight]

@[simp]
lemma KaehlerDifferential.derivationCotangentIdealEquiv_apply_one_tmul
    (D : Derivation R P _) (x : P) :
    derivationCotangentIdealEquiv R h D (1 ‚äó‚Çú KaehlerDifferential.D R P x) =
      (Ideal.tensorKerEquivCotangentIdeal h).symm (D x) := by
  rw [‚Üê (algebraMap P A).map_one, derivationCotangentIdealEquiv_apply, one_smul]

@[simp]
lemma KaehlerDifferential.derivationCotangentIdealEquiv_symm_apply
    (l) (x : P) :
    (derivationCotangentIdealEquiv R h).symm l x =
      Ideal.tensorKerEquivCotangentIdeal h (l (1 ‚äó‚Çú D R P x)) := rfl

set_option synthInstance.maxHeartbeats 1000000 in
noncomputable
def KaehlerDifferential.tensorKerCotangentToTensorRetraction
      (g : A ‚Üí‚Çê[R] P ‚ß∏ (RingHom.ker (algebraMap P A)) ^ 2)
      (hg : (IsScalarTower.toAlgHom R P A).kerSquareLift.comp g = AlgHom.id R A) :
    A ‚äó[P] Œ©[P‚ÅÑR] ‚Üí‚Çó[A] (A ‚äó[P] RingHom.ker (algebraMap P A)) :=
  derivationCotangentIdealEquiv R h
    ((derivationOfSplit R A (IsScalarTower.toAlgHom R P A) g hg).compAlgebraMap P)

@[simp]
lemma KaehlerDifferential.tensorKerCotangentToTensorRetraction_apply
      (g : A ‚Üí‚Çê[R] P ‚ß∏ (RingHom.ker (algebraMap P A)) ^ 2)
      (hg : (IsScalarTower.toAlgHom R P A).kerSquareLift.comp g = AlgHom.id R A)
      (x y : P) :
    tensorKerCotangentToTensorRetraction R h g hg (algebraMap P A x ‚äó‚Çú D R P y) =
    x ‚Ä¢ (Ideal.tensorKerEquivCotangentIdeal h).symm
      (derivationOfSplit R A (IsScalarTower.toAlgHom R P A) g hg y) := by
  rw [tensorKerCotangentToTensorRetraction, derivationCotangentIdealEquiv_apply]
  rfl

@[simp]
lemma KaehlerDifferential.tensorKerCotangentToTensorRetraction_apply_one_tmul
      (g : A ‚Üí‚Çê[R] P ‚ß∏ (RingHom.ker (algebraMap P A)) ^ 2)
      (hg : (IsScalarTower.toAlgHom R P A).kerSquareLift.comp g = AlgHom.id R A)
      (x : P) :
    tensorKerCotangentToTensorRetraction R h g hg (1 ‚äó‚Çú D R P x) =
    (Ideal.tensorKerEquivCotangentIdeal h).symm
      (derivationOfSplit R A (IsScalarTower.toAlgHom R P A) g hg x) := by
  rw [tensorKerCotangentToTensorRetraction, derivationCotangentIdealEquiv_apply_one_tmul]
  rfl

@[simp]
lemma LinearEquiv.compDer_apply {R A M} [CommSemiring R] [CommSemiring A] [AddCommMonoid M]
    [Algebra R A] [Module A M] [Module R M] {N} [AddCommMonoid N] [Module A N] [Module R N]
    [IsScalarTower R A M] [IsScalarTower R A N] (e : M ‚âÉ‚Çó[A] N) (d : Derivation R A M) (x) :
  e.compDer d x = e (d x) := rfl

lemma KaehlerDifferential.tensorKerCotangentToTensorRetraction_comp [Algebra P A] [IsScalarTower R P A]
      (h : Function.Surjective (algebraMap P A))
      (g : A ‚Üí‚Çê[R] P ‚ß∏ (RingHom.ker (algebraMap P A)) ^ 2)
      (hg : (IsScalarTower.toAlgHom R P A).kerSquareLift.comp g = AlgHom.id R A) :
    (tensorKerCotangentToTensorRetraction R h g hg).comp
      (KaehlerDifferential.tensorKerCotangentToTensor R P A) = LinearMap.id := by
  ext x
  apply (Ideal.tensorKerEquivCotangentIdeal h).injective
  ext
  simp only [TensorProduct.AlgebraTensorModule.curry_apply, TensorProduct.curry_apply,
    LinearMap.coe_restrictScalars, LinearMap.coe_comp, Function.comp_apply,
    tensorKerCotangentToTensor_tmul, tensorKerCotangentToTensorRetraction_apply_one_tmul,
    LinearEquiv.apply_symm_apply, derivationOfSplit_apply_coe, LinearMap.id_coe, id_eq]
  simp only [AlgHom.toRingHom_eq_coe, Ideal.tensorKerEquivCotangentIdeal, tensorEquivOfSurjective,
    LinearEquiv.trans_apply, TensorProduct.congr_tmul, AlgEquiv.toLinearEquiv_apply, map_one,
    LinearEquiv.refl_apply]
  show _ = Ideal.Quotient.mk _ (1 * x : P)
  simp only [AlgHom.toRingHom_eq_coe, Ideal.Quotient.algebraMap_eq, one_mul]
  refine sub_eq_self.mpr ?_
  show g (algebraMap P A x) = 0
  rw [(RingHom.mem_ker _).mp x.prop, map_zero]

set_option synthInstance.maxHeartbeats 1000000 in
set_option maxHeartbeats 1000000 in
def KaehlerDifferential.liftOftensorKerCotangentToTensorRetractionAux
      (l : A ‚äó[P] Œ©[P‚ÅÑR] ‚Üí‚Çó[A] (A ‚äó[P] RingHom.ker (algebraMap P A))) :
    P ‚Üí‚Çê[R] P ‚ß∏ (RingHom.ker (algebraMap P A)) ^ 2 := by
  refine AlgHom.ofLinearMap ((IsScalarTower.toAlgHom R P _).toLinearMap -
    (((RingHom.ker (algebraMap P A)).cotangentIdeal.subtype.restrictScalars P).compDer
      ((derivationCotangentIdealEquiv R h).symm l)).toLinearMap) ?_ ?_
  ¬∑ simp
  ¬∑ intro x y
    suffices ((derivationCotangentIdealEquiv R h).symm l x).1 *
        ((derivationCotangentIdealEquiv R h).symm l y).1 = 0 by
      simp [this, mul_sub, sub_mul, Algebra.smul_def, -derivationCotangentIdealEquiv_symm_apply];
      ring
    rw [‚Üê Ideal.mem_bot, ‚Üê Ideal.cotangentIdeal_square, pow_two (RingHom.ker _).cotangentIdeal]
    exact Ideal.mul_mem_mul ((derivationCotangentIdealEquiv R h).symm l x).prop
      ((derivationCotangentIdealEquiv R h).symm l y).prop

def KaehlerDifferential.liftOfTensorKerCotangentToTensorRetraction
      (l : A ‚äó[P] Œ©[P‚ÅÑR] ‚Üí‚Çó[A] (A ‚äó[P] RingHom.ker (algebraMap P A)))
      (hl : l.comp (tensorKerCotangentToTensor R P A) = LinearMap.id) :
    A ‚Üí‚Çê[R] P ‚ß∏ (RingHom.ker (algebraMap P A)) ^ 2 := by
  refine (Ideal.Quotient.lift‚Çê (RingHom.ker (algebraMap P A))
    (liftOftensorKerCotangentToTensorRetractionAux R h l) ?_).comp
    (Ideal.quotientKerAlgEquivOfSurjective (f := IsScalarTower.toAlgHom R P A) h).symm.toAlgHom
  intro x hx
  have := DFunLike.congr_fun hl (1 ‚äó‚Çú ‚ü®x, hx‚ü©)
  simp only [LinearMap.coe_comp, Function.comp_apply, tensorKerCotangentToTensor_tmul,
    LinearMap.id_coe, id_eq] at this
  simp [liftOftensorKerCotangentToTensorRetractionAux, sub_eq_zero, this]

lemma KaehlerDifferential.liftOfTensorKerCotangentToTensorRetractionAux_apply
      (l : A ‚äó[P] Œ©[P‚ÅÑR] ‚Üí‚Çó[A] (A ‚äó[P] RingHom.ker (algebraMap P A))) (x : P) :
    liftOftensorKerCotangentToTensorRetractionAux R h l x =
      x - (derivationCotangentIdealEquiv R h).symm l x := rfl

lemma KaehlerDifferential.liftOfTensorKerCotangentToTensorRetraction_apply
      (l : A ‚äó[P] Œ©[P‚ÅÑR] ‚Üí‚Çó[A] (A ‚äó[P] RingHom.ker (algebraMap P A))) (hl) (x : P) :
    liftOfTensorKerCotangentToTensorRetraction R h l hl (algebraMap P A x) =
      x - (derivationCotangentIdealEquiv R h).symm l x := by
  rw [‚Üê liftOfTensorKerCotangentToTensorRetractionAux_apply,
    liftOfTensorKerCotangentToTensorRetraction, AlgHom.comp_apply]
  have : (Ideal.quotientKerAlgEquivOfSurjective
      (f := IsScalarTower.toAlgHom R P A) h).symm.toAlgHom (algebraMap P A x) = x := by
    apply (Ideal.quotientKerAlgEquivOfSurjective
      (f := IsScalarTower.toAlgHom R P A) h).injective
    exact AlgEquiv.apply_symm_apply _ _
  erw [this]
  rfl

lemma KaehlerDifferential.liftOfTensorKerCotangentToTensorRetraction_comp
      (l : A ‚äó[P] Œ©[P‚ÅÑR] ‚Üí‚Çó[A] (A ‚äó[P] RingHom.ker (algebraMap P A)))
      (hl : l.comp (tensorKerCotangentToTensor R P A) = LinearMap.id) :
    (IsScalarTower.toAlgHom R P A).kerSquareLift.comp
      (liftOfTensorKerCotangentToTensorRetraction R h l hl) = AlgHom.id R A := by
  ext x
  obtain ‚ü®x, rfl‚ü© := h x
  rw [AlgHom.comp_apply]
  erw [liftOfTensorKerCotangentToTensorRetraction_apply R h l hl x]
  simp only [AlgHom.toRingHom_eq_coe, derivationCotangentIdealEquiv_symm_apply, map_sub,
    AlgHom.coe_id, id_eq]
  show algebraMap P A x - _ = algebraMap P A x
  apply sub_eq_self.mpr ?_
  rw [‚Üê RingHom.mem_ker]
  erw [AlgHom.ker_kerSquareLift]
  exact (Ideal.tensorKerEquivCotangentIdeal h _).prop

lemma KaehlerDifferential.tensorKerCotangentToTensorRetractionEquiv :
    { l : A ‚äó[P] Œ©[P‚ÅÑR] ‚Üí‚Çó[A] (A ‚äó[P] RingHom.ker (algebraMap P A)) //
      l.comp (tensorKerCotangentToTensor R P A) = LinearMap.id } ‚âÉ
    { g : A ‚Üí‚Çê[R] P ‚ß∏ (RingHom.ker (algebraMap P A)) ^ 2 //
        (IsScalarTower.toAlgHom R P A).kerSquareLift.comp g = AlgHom.id R A } where
  toFun l := ‚ü®_, liftOfTensorKerCotangentToTensorRetraction_comp R h _ l.prop‚ü©
  invFun g := ‚ü®_, tensorKerCotangentToTensorRetraction_comp R h _ g.prop‚ü©
  left_inv l := by
    ext x
    simp only [TensorProduct.AlgebraTensorModule.curry_apply, TensorProduct.curry_apply,
      LinearMap.coe_restrictScalars]
    obtain ‚ü®x, rfl‚ü© := total_surjective _ _ x
    induction' x using Finsupp.induction_linear with _ _ _ _ x y
    ¬∑ simp
    ¬∑ simp only [map_add, TensorProduct.tmul_add, *]
    ¬∑ apply (Ideal.tensorKerEquivCotangentIdeal h).injective
      ext
      simp only [Finsupp.total_single, TensorProduct.tmul_smul, LinearMap.map_smul_of_tower,
        tensorKerCotangentToTensorRetraction_apply_one_tmul, AlgHom.toRingHom_eq_coe, map_smul,
        LinearEquiv.apply_symm_apply, Submodule.coe_smul_of_tower]
      erw [derivationOfSplit_apply_coe, Ideal.Quotient.lift_mk,
        liftOfTensorKerCotangentToTensorRetraction_apply]
      simp only [AlgHom.toRingHom_eq_coe, derivationCotangentIdealEquiv_symm_apply, ‚Üê sub_add]
      erw [sub_self]
      rw [zero_add]
  right_inv g := by
    ext x
    obtain ‚ü®x, rfl‚ü© := h x
    simp only [AlgHom.toRingHom_eq_coe]
    erw [liftOfTensorKerCotangentToTensorRetraction_apply]
    simp only [derivationCotangentIdealEquiv_symm_apply,
      tensorKerCotangentToTensorRetraction_apply_one_tmul, AlgHom.toRingHom_eq_coe,
      LinearEquiv.apply_symm_apply]
    erw [derivationOfSplit_apply_coe, sub_sub_cancel]
    rfl

end ExactSequence

section MvPolynomial

def KaehlerDifferential.mvPolynomial_equiv (œÉ : Type*) :
    Œ©[MvPolynomial œÉ R‚ÅÑR] ‚âÉ‚Çó[MvPolynomial œÉ R] œÉ ‚Üí‚ÇÄ MvPolynomial œÉ R where
  __ := (MvPolynomial.mkDerivation _ (Finsupp.single ¬∑ 1)).liftKaehlerDifferential
  invFun := Finsupp.total œÉ _ _ (fun x ‚Ü¶ D _ _ (MvPolynomial.X x))
  right_inv := by
    intro x
    induction' x using Finsupp.induction_linear with _ _ _ _ a b
    ¬∑ simp only [AddHom.toFun_eq_coe, LinearMap.coe_toAddHom]; rw [map_zero, map_zero]
    ¬∑ simp only [AddHom.toFun_eq_coe, LinearMap.coe_toAddHom, map_add] at *; simp only [*]
    ¬∑ simp [LinearMap.map_smul, -map_smul]
  left_inv := by
    intro x
    obtain ‚ü®x, rfl‚ü© := total_surjective _ _ x
    induction' x using Finsupp.induction_linear with _ _ _ _ a b
    ¬∑ simp only [AddHom.toFun_eq_coe, LinearMap.coe_toAddHom]; rw [map_zero, map_zero, map_zero]
    ¬∑ simp only [map_add, AddHom.toFun_eq_coe, LinearMap.coe_toAddHom] at *; simp only [*]
    ¬∑ simp only [AddHom.toFun_eq_coe, LinearMap.coe_toAddHom, Finsupp.total_single,
        LinearMap.map_smul, Derivation.liftKaehlerDifferential_comp_D]
      congr 1
      induction a using MvPolynomial.induction_on
      ¬∑ simp only [MvPolynomial.derivation_C, map_zero]
      ¬∑ simp only [map_add, *]
      ¬∑ simp [*]

def KaehlerDifferential.mvPolynomialBasis (œÉ) : Basis œÉ (MvPolynomial œÉ R) (Œ©[MvPolynomial œÉ R‚ÅÑR]) :=
  ‚ü®mvPolynomial_equiv R œÉ‚ü©

lemma KaehlerDifferential.mvPolynomialBasis_repr_comp_D (œÉ) :
    (mvPolynomialBasis R œÉ).repr.toLinearMap.compDer (D _ _) =
      MvPolynomial.mkDerivation _ (Finsupp.single ¬∑ 1) :=
  Derivation.liftKaehlerDifferential_comp _

lemma KaehlerDifferential.mvPolynomialBasis_repr_D (œÉ) (x) :
    (mvPolynomialBasis R œÉ).repr (D _ _ x) =
      MvPolynomial.mkDerivation R (Finsupp.single ¬∑ (1 : MvPolynomial œÉ R)) x :=
  Derivation.congr_fun (mvPolynomialBasis_repr_comp_D R œÉ) x

@[simp]
lemma KaehlerDifferential.mvPolynomialBasis_repr_D_X (œÉ) (i) :
    (mvPolynomialBasis R œÉ).repr (D _ _ (.X i)) = Finsupp.single i 1 := by
  simp [mvPolynomialBasis_repr_D]

@[simp]
lemma KaehlerDifferential.mvPolynomialBasis_repr_apply (œÉ) (x) (i) :
    (mvPolynomialBasis R œÉ).repr (D _ _ x) i = MvPolynomial.pderiv i x := by
  classical
  suffices ((Finsupp.lapply i).comp
    (mvPolynomialBasis R œÉ).repr.toLinearMap).compDer (D _ _) = MvPolynomial.pderiv i by
    rw [‚Üê this]; rfl
  apply MvPolynomial.derivation_ext
  intro j
  simp [Finsupp.single_apply, Pi.single_apply]

@[simp]
lemma KaehlerDifferential.mvPolynomialBasis_repr_symm_single (œÉ) (i) (x) :
    (mvPolynomialBasis R œÉ).repr.symm (Finsupp.single i x) = x ‚Ä¢ D _ _ (.X i) := by
  apply (mvPolynomialBasis R œÉ).repr.injective; simp [LinearEquiv.map_smul, -map_smul]

@[simp]
lemma KaehlerDifferential.mvPolynomialBasis_apply (œÉ) (i) :
    mvPolynomialBasis R œÉ i = D _ _ (.X i) :=
  (mvPolynomialBasis_repr_symm_single R œÉ i 1).trans (one_smul _ _)

instance (œÉ) : Module.Free (MvPolynomial œÉ R) (Œ©[MvPolynomial œÉ R‚ÅÑR]) :=
  .of_basis (KaehlerDifferential.mvPolynomialBasis R œÉ)

end MvPolynomial

section Polynomial

open Polynomial

@[simp]
lemma Derivation.apply_aeval (D : Derivation R S M) (P : R[X]) (x : S) :
    D (aeval x P) = aeval x (derivative P) ‚Ä¢ D x := by
  induction P using Polynomial.induction_on
  ¬∑ simp
  ¬∑ simp [add_smul, *]
  ¬∑ simp [mul_smul, nsmul_eq_smul_cast S]

lemma KaehlerDifferential.polynomial_D_apply (P : R[X]) :
    D R R[X] P = derivative P ‚Ä¢ D R R[X] X := by
  rw [‚Üê aeval_X_left_apply P, (D R R[X]).apply_aeval, aeval_X_left_apply, aeval_X_left_apply]

def KaehlerDifferential.polynomialEquiv : Œ©[R[X]‚ÅÑR] ‚âÉ‚Çó[R[X]] R[X] where
  __ := derivative'.liftKaehlerDifferential
  invFun := (Algebra.lsmul R R _).toLinearMap.flip (D R R[X] X)
  left_inv := by
    intro x
    obtain ‚ü®x, rfl‚ü© := total_surjective _ _ x
    induction' x using Finsupp.induction_linear with x y hx hy x y
    ¬∑ simp
    ¬∑ simp only [map_add, AddHom.toFun_eq_coe, LinearMap.coe_toAddHom, LinearMap.flip_apply,
        AlgHom.toLinearMap_apply, lsmul_coe] at *; simp only [*]
    ¬∑ simp [polynomial_D_apply _ x]
  right_inv x := by simp

lemma KaehlerDifferential.polynomialEquiv_comp_D :
    (polynomialEquiv R).compDer (D R R[X]) = derivative' :=
  Derivation.liftKaehlerDifferential_comp _

@[simp]
lemma KaehlerDifferential.polynomialEquiv_D (P) :
    polynomialEquiv R (D R R[X] P) = derivative P :=
  Derivation.congr_fun (polynomialEquiv_comp_D R) P

@[simp]
lemma KaehlerDifferential.polynomialEquiv_symm (P) :
    (polynomialEquiv R).symm P = P ‚Ä¢ D R R[X] X := rfl

end Polynomial

end KaehlerDifferential
