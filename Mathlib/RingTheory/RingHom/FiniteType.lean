/-
Copyright (c) 2021 Andrew Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Andrew Yang
-/
import Mathlib.RingTheory.LocalProperties
import Mathlib.RingTheory.Localization.InvSubmonoid

#align_import ring_theory.ring_hom.finite_type from "leanprover-community/mathlib"@"64fc7238fb41b1a4f12ff05e3d5edfa360dd768c"

/-!

# The meta properties of finite-type ring homomorphisms.

The main result is `RingHom.finiteType_is_local`.

-/


namespace RingHom

open scoped Pointwise

theorem finiteType_stableUnderComposition : StableUnderComposition @FiniteType := by
  introv R hf hg
  -- ‚ä¢ FiniteType (comp g f)
  exact hg.comp hf
  -- üéâ no goals
#align ring_hom.finite_type_stable_under_composition RingHom.finiteType_stableUnderComposition

theorem finiteType_holdsForLocalizationAway : HoldsForLocalizationAway @FiniteType := by
  introv R _
  -- ‚ä¢ FiniteType (algebraMap R S)
  suffices Algebra.FiniteType R S by
    rw [RingHom.FiniteType]
    convert this; ext;
    rw [Algebra.smul_def]; rfl
  exact IsLocalization.finiteType_of_monoid_fg (Submonoid.powers r) S
  -- üéâ no goals
#align ring_hom.finite_type_holds_for_localization_away RingHom.finiteType_holdsForLocalizationAway

theorem finiteType_ofLocalizationSpanTarget : OfLocalizationSpanTarget @FiniteType := by
  -- Setup algebra intances.
  rw [ofLocalizationSpanTarget_iff_finite]
  -- ‚ä¢ OfLocalizationFiniteSpanTarget @FiniteType
  introv R hs H
  -- ‚ä¢ FiniteType f
  classical
  letI := f.toAlgebra
  replace H : ‚àÄ r : s, Algebra.FiniteType R (Localization.Away (r : S))
  ¬∑ intro r; simp_rw [RingHom.FiniteType] at H; convert H r; ext; simp_rw [Algebra.smul_def]; rfl
  replace H := fun r => (H r).1
  constructor
  -- Suppose `s : Finset S` spans `S`, and each `S·µ£` is finitely generated as an `R`-algebra.
  -- Say `t r : Finset S·µ£` generates `S·µ£`. By assumption, we may find `l·µ¢` such that
  -- `‚àë l·µ¢ * s·µ¢ = 1`. I claim that all `s` and `l` and the numerators of `t` and generates `S`.
  choose t ht using H
  obtain ‚ü®l, hl‚ü© :=
    (Finsupp.mem_span_iff_total S (s : Set S) 1).mp
      (show (1 : S) ‚àà Ideal.span (s : Set S) by rw [hs]; trivial)
  let sf := fun x : s => IsLocalization.finsetIntegerMultiple (Submonoid.powers (x : S)) (t x)
  use s.attach.biUnion sf ‚à™ s ‚à™ l.support.image l
  rw [eq_top_iff]
  -- We need to show that every `x` falls in the subalgebra generated by those elements.
  -- Since all `s` and `l` are in the subalgebra, it suffices to check that `s·µ¢ ^ n·µ¢ ‚Ä¢ x` falls in
  -- the algebra for each `s·µ¢` and some `n·µ¢`.
  rintro x -
  apply Subalgebra.mem_of_span_eq_top_of_smul_pow_mem _ (s : Set S) l hl _ _ x _
  ¬∑ intro x hx
    apply Algebra.subset_adjoin
    rw [Finset.coe_union, Finset.coe_union]
    exact Or.inl (Or.inr hx)
  ¬∑ intro i
    by_cases h : l i = 0; ¬∑ rw [h]; exact zero_mem _
    apply Algebra.subset_adjoin
    rw [Finset.coe_union, Finset.coe_image]
    exact Or.inr (Set.mem_image_of_mem _ (Finsupp.mem_support_iff.mpr h))
  ¬∑ intro r
    rw [Finset.coe_union, Finset.coe_union, Finset.coe_biUnion]
    -- Since all `s·µ¢` and numerators of `t r` are in the algebra, it suffices to show that the
    -- image of `x` in `S·µ£` falls in the `R`-adjoin of `t r`, which is of course true.
    -- Porting note: The following `obtain` fails because Lean wants to know right away what the
    -- placeholders are, so we need to provide a little more guidance
    -- obtain ‚ü®‚ü®_, n‚ÇÇ, rfl‚ü©, hn‚ÇÇ‚ü© := IsLocalization.exists_smul_mem_of_mem_adjoin
    --   (Submonoid.powers (r : S)) x (t r) (Algebra.adjoin R _) _ _ _
    rw [show ‚àÄ A : Set S, (‚àÉ n, (r : S) ^ n ‚Ä¢ x ‚àà Algebra.adjoin R A) ‚Üî
      (‚àÉ m : (Submonoid.powers (r : S)), (m : S) ‚Ä¢ x ‚àà Algebra.adjoin R A) by
      { exact fun _ => by simp [Submonoid.mem_powers_iff] }]
    refine IsLocalization.exists_smul_mem_of_mem_adjoin
      (Submonoid.powers (r : S)) x (t r) (Algebra.adjoin R _) ?_ ?_ ?_
    ¬∑ intro x hx
      apply Algebra.subset_adjoin
      exact Or.inl (Or.inl ‚ü®_, ‚ü®r, rfl‚ü©, _, ‚ü®s.mem_attach r, rfl‚ü©, hx‚ü©)
    ¬∑ rw [Submonoid.powers_eq_closure, Submonoid.closure_le, Set.singleton_subset_iff]
      apply Algebra.subset_adjoin
      exact Or.inl (Or.inr r.2)
    ¬∑ rw [ht]; trivial
#align ring_hom.finite_type_of_localization_span_target RingHom.finiteType_ofLocalizationSpanTarget

theorem finiteType_is_local : PropertyIsLocal @FiniteType :=
  ‚ü®localization_finiteType, finiteType_ofLocalizationSpanTarget, finiteType_stableUnderComposition,
    finiteType_holdsForLocalizationAway‚ü©
#align ring_hom.finite_type_is_local RingHom.finiteType_is_local

theorem finiteType_respectsIso : RingHom.RespectsIso @RingHom.FiniteType :=
  RingHom.finiteType_is_local.respectsIso
#align ring_hom.finite_type_respects_iso RingHom.finiteType_respectsIso

end RingHom
