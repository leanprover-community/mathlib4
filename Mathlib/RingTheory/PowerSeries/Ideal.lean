/-
Copyright (c) 2025 Riccardo Brasca. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Riccardo Brasca, Anthony Fernandes, Marc Robin
-/

import Mathlib.RingTheory.PowerSeries.Inverse
import Mathlib.RingTheory.PowerSeries.Trunc
import Mathlib.RingTheory.Finiteness.Ideal
import Mathlib.RingTheory.Noetherian.OfPrime

/-!
# Ideals in power series.

We gather miscellaneous results about prime ideals in `R⟦X⟧`. More precisely, we prove that, given
a prime ideal `I` of `R⟦X⟧` such that the ideal generated by the constant coefficients of the
`f ∈ I` is generated by `n` elements, then `I` is generated by at `n + 1` elements (actually it is
generated by `n` elements if `X ∉ I` and `n + 1` elements otherwise). This implies immediately that
`R⟦X⟧` is noetherian if `R` is. We follow the proof given in [zbMATH05171613].


## Main results

* `PowerSeries.Ideal.eq_span_insert_X_of_Xmem_of_span_eq` : given an ideal `I` of `R⟦X⟧` such that
  `X ∈ I`, if `I.map constantCoeff` is generated by `S : Set T`, then `I` is generated by
  `insert X (C '' S)`.
* `PowerSeries.Ideal.exist_eq_span_eq_ncard_of_X_not_mem` : given a prime ideal `I` of `R⟦X⟧` such
  that `X ∉ I`, if `I.map constantCoeff` is generated by a finite set `S : Set T`, then there exists
  `T : Set R`, of the same cardinality as `S`, that generates `I`.
* `PowerSeries.Ideal.IsPrime.FG_iff` : a prime ideal `P` of `R⟦X⟧` is finitely generated if and only
  if `P.map constantCoeff` is finitely generated.

## Implementation details

There is a simpler proof of `IsNoetherianRing R → IsNoetherianRing R⟦X⟧`, similar to that for
polynomials. On the other hand our proof has the advantage of giving explicitly the number of
generators, and it will be used to prove, for a domain `R`, that
`IsPrincipalIdealRing R → UniqueFactorizationMonoid R⟦X⟧`.

-/

variable {R : Type*}

open Ideal Set Finset

namespace PowerSeries.Ideal

section Semiring

variable [Semiring R]

lemma mem_map_constantCoeff_iff {I : Ideal R⟦X⟧} {r : R} :
    r ∈ I.map constantCoeff ↔ ∃ f ∈ I, f.constantCoeff = r :=
  I.mem_map_iff_of_surjective _ constantCoeff_surj

lemma constantCoeff_mem_map_of_mem {I : Ideal R⟦X⟧} {f : R⟦X⟧} (hf : f ∈ I) :
    f.constantCoeff ∈ I.map constantCoeff :=
  mem_map_constantCoeff_iff.2 ⟨_, hf, rfl⟩

end Semiring

variable [CommRing R] {I : Ideal R⟦X⟧} {g : R⟦X⟧} (hg : g ∈ I)

section Xmem

theorem map_constantCoeff_le_self_of_Xmem (hXI : X ∈ I) :
  (C (R := R))'' I.map constantCoeff ≤ I := by
  intro f ⟨r, hr, hf⟩
  obtain ⟨g, hg, hgr⟩ := mem_map_constantCoeff_iff.1 hr
  rw [← hf, ← hgr, eq_sub_of_add_eq' g.eq_X_mul_shift_add_const.symm]
  refine I.sub_mem hg (I.mul_mem_right _ hXI)

variable {S : Set R}

/-- Given an ideal `I` of `R⟦X⟧` such that `X ∈ I`, if `I.map constantCoeff` is generated by
`S : Set T`, then `I` is generated by `insert X (C '' S)`. -/
theorem eq_span_insert_X_of_Xmem_of_span_eq (hXI : X ∈ I) (hSI : span S = I.map constantCoeff) :
    I = span (insert X (C '' S)) := by
  ext f
  rw [mem_span_insert, ← map_span, hSI]
  refine ⟨fun hf ↦ ⟨mk fun p ↦ coeff (p + 1) f, C f.constantCoeff, mem_map_of_mem _
    (constantCoeff_mem_map_of_mem hf), f.eq_shift_mul_X_add_const⟩, fun ⟨F, G, hG, hf⟩ ↦ ?_⟩
  rw [hf]
  exact I.add_mem (I.mul_mem_left _ hXI) (span_le.2 (map_constantCoeff_le_self_of_Xmem hXI) hG)

end Xmem

section X_notMem

variable (hXI : X ∉ I) {k : ℕ} {a : Fin k → R} (haI : span (range a) = I.map constantCoeff)

section F

include haI in
private lemma exists_F : ∀ i, ∃ F ∈ I, F.constantCoeff = a i :=
  fun i ↦ mem_map_constantCoeff_iff.1 <| haI ▸ subset_span (mem_range_self i)

/-- Given `a : Fin k → R` such that `(haI : span (range a) = I.map constantCoeff)`, we construct
`F : Fin k → R⟦X⟧` such that `F i ∈ I` and `(F i).constantCoeff = a i` for all `i`. -/
private noncomputable def F i :=
  (exists_F haI i).choose

private lemma F_apply_mem_I (i : Fin k) : F haI i ∈ I :=
  (exists_F haI i).choose_spec.1

private lemma constantCoeff_F_apply (i : Fin k) : (F haI i).constantCoeff = a i :=
  (exists_F haI i).choose_spec.2

end F

section T

include haI hg in
private lemma exists_T : ∃ T : Fin k → R, ∑ i, T i * a i = g.constantCoeff :=
  mem_span_range_iff_exists_fun.1 (haI ▸ constantCoeff_mem_map_of_mem hg)

/-- Given `a : Fin k → R` such that `(haP : span (range a) = I.map constantCoeff)` and `g : R⟦X⟧`
such `(hg : g ∈ I)`, we construct `T : Fin k → R⟦X⟧` such that `∑ i, T i * a i = g.constantCoeff`
for all `i`. -/
private noncomputable def T : Fin k → R :=
  (exists_T hg haI).choose

private lemma sum_T : ∑ i, T hg haI i * a i = g.constantCoeff :=
  (exists_T hg haI).choose_spec

end T

variable [I_prime : I.IsPrime]

private noncomputable def g' (hI : X ∉ I) : ℕ → I
| 0 => ⟨g, hg⟩
| n + 1 =>
  ⟨mk fun p ↦ coeff (p + 1) (g' hI n) - ∑ i, T (g' hI n).2 haI i * coeff (p + 1) (F haI i), by
    have h := sub_const_eq_X_mul_shift ((g' hI n).1 - ∑ i, C (T (g' hI n).2 haI i) * F haI i)
    simp only [map_sub, map_sum, _root_.map_mul, constantCoeff_C, constantCoeff_F_apply, sum_T,
      sub_self, map_zero, sub_zero, coeff_C_mul] at h
    have : ∑ i, C (T (g' hI n).2 haI i) * F haI i ∈ I :=
      I.sum_mem fun i _ ↦ I.mul_mem_left _ (F_apply_mem_I haI i)
    exact (I_prime.mul_mem_iff_mem_or_mem.1 (h ▸ I.sub_mem (g' hI n).2 this)).resolve_left hI⟩

private lemma g'_sub_sum_T (n : ℕ) (hI : X ∉ I) :
    (g' hg haI hI n).1 - ∑ i, C (T (g' hg haI hI n).2 haI i) * F haI i =
      X * (g' hg haI hI (n + 1)).1 := by
  simpa [sum_T, constantCoeff_F_apply] using sub_const_eq_X_mul_shift
    ((g' hg haI hI n).1 - ∑ i, C (T (g' hg haI hI n).2 haI i) * F haI i)

/-- Given `a : Fin k → R` such that `(haP : span (range a) = I.map constantCoeff)` and `g : R⟦X⟧`
such `(hg : g ∈ I)`, we construct `H : Fin k → R⟦X⟧` such that `g = ∑ i, H i * F i`. -/
private noncomputable def H (hI : X ∉ I) (i : Fin k) : R⟦X⟧ :=
  mk fun n ↦ T (g' hg haI hI n).2 haI i

private lemma g_sub_sum_trunc_H (hI : X ∉ I) (n : ℕ) :
    g - ∑ i, trunc n (H hg haI hI i) * F haI i = X ^ n * (g' hg haI hI n).1 := by
  induction n with
  | zero => simp [g']
  | succ n hn =>
    conv =>
      enter [1, 2, 2, i]
      rw [trunc_succ, Polynomial.coe_add, Polynomial.coe_monomial, add_mul, ← mul_one (coeff n _),
        ← smul_eq_mul (b := 1), map_smul, ← X_pow_eq, smul_eq_C_mul, mul_comm _ (X ^ n), mul_assoc]
    rw [sum_add_distrib, sub_add_eq_sub_sub, hn, ← mul_sum, ← mul_sub]
    simp only [H, coeff_mk, g'_sub_sum_T]
    ring

private lemma sum_H_mul_F (hI : X ∉ I) : ∑ i, H hg haI hI i * F haI i = g := by
  symm
  refine sub_eq_zero.1 ?_
  ext n
  conv =>
    enter [1, 2, 2, 2, i]
    rw [eq_X_pow_mul_shift_add_trunc (n + 1) (H hg haI hI i), add_comm, add_mul, mul_assoc]
  rw [sum_add_distrib, sub_add_eq_sub_sub, g_sub_sum_trunc_H, ← mul_sum]
  simp [coeff_X_pow_mul']

private theorem I_eq_span_range (hI : X ∉ I) : I = span (range (F haI)) :=
  le_antisymm
    (fun _ hg ↦ mem_span_range_iff_exists_fun.2 ⟨_, sum_H_mul_F hg haI hI⟩)
    (span_le.2 <| range_subset_iff.2 <| F_apply_mem_I haI)

/-- Given a prime ideal `I` of `R⟦X⟧` such that `X ∉ I`, if `I.map constantCoeff` is generated by a
finite set `S : Set T`, then there exists `T : Set R`, of the same cardinality as `S`, that
generates `I`. -/
theorem exist_eq_span_eq_ncard_of_X_not_mem (hI : X ∉ I) {S : Set R}
    (hSI : span S = I.map constantCoeff) (hS : S.Finite) :
      ∃ T, I = span T ∧ T.Finite ∧ T.ncard = S.ncard := by
  obtain ⟨k, a, a_injective, rfl⟩ := Finite.fin_param hS
  refine ⟨_, I_eq_span_range hSI hI, finite_range _, trans (b := k) ?_ ?_⟩ <;>
  rw [Set.ncard_range_of_injective, Nat.card_fin]
  · intro _ _ this
    apply_fun constantCoeff at this
    simp only [constantCoeff_F_apply] at this
    exact a_injective this
  · exact a_injective

end X_notMem

/-- A prime ideal `P` of `R⟦X⟧` is finitely generated if and only if `P.map constantCoeff` is
finitely generated. -/
lemma IsPrime.FG_iff {P : Ideal R⟦X⟧} [P.IsPrime] : P.FG ↔ (P.map constantCoeff).FG := by
  constructor
  · exact (FG.map · _)
  · intro ⟨S, hS⟩
    by_cases hX : X ∈ P
    · have H := eq_span_insert_X_of_Xmem_of_span_eq hX hS
      have : (insert X <| (C (R := R))'' S).Finite :=
        Finite.insert X <| Finite.image _ S.finite_toSet
      lift insert X <| (C (R := R))'' S to Finset R⟦X⟧ using this with T hT
      exact ⟨T, hT ▸ H.symm⟩
    · obtain ⟨T, hT, hT₂, _⟩ := exist_eq_span_eq_ncard_of_X_not_mem hX hS S.finite_toSet
      lift T to Finset R⟦X⟧ using hT₂
      exact ⟨T, hT.symm⟩

/-- If `R` is noetherian then so is `R⟦X⟧`. -/
instance [IsNoetherianRing R] : IsNoetherianRing R⟦X⟧ :=
  IsNoetherianRing.of_prime fun P _ ↦
    IsPrime.FG_iff.2 <| (isNoetherianRing_iff_ideal_fg R).1 inferInstance (P.map constantCoeff)

end PowerSeries.Ideal
