/-
Copyright (c) 2022 Andrew Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Andrew Yang
-/
import Mathlib.RingTheory.FiniteType

#align_import ring_theory.rees_algebra from "leanprover-community/mathlib"@"70fd9563a21e7b963887c9360bd29b2393e6225a"

/-!

# Rees algebra

The Rees algebra of an ideal `I` is the subalgebra `R[It]` of `R[t]` defined as `R[It] = â¨â‚™ Iâ¿ tâ¿`.
This is used to prove the Artin-Rees lemma, and will potentially enable us to calculate some
blowup in the future.

## Main definition

- `reesAlgebra` : The Rees algebra of an ideal `I`, defined as a subalgebra of `R[X]`.
- `adjoin_monomial_eq_reesAlgebra` : The Rees algebra is generated by the degree one elements.
- `reesAlgebra.fg` : The Rees algebra of a f.g. ideal is of finite type. In particular, this
implies that the rees algebra over a noetherian ring is still noetherian.

-/


universe u v

variable {R M : Type u} [CommRing R] [AddCommGroup M] [Module R M] (I : Ideal R)

open Polynomial

open Polynomial BigOperators

/-- The Rees algebra of an ideal `I`, defined as the subalgebra of `R[X]` whose `i`-th coefficient
falls in `I ^ i`. -/
def reesAlgebra : Subalgebra R R[X] where
  carrier := { f | âˆ€ i, f.coeff i âˆˆ I ^ i }
  mul_mem' hf hg i := by
    rw [coeff_mul]
    -- âŠ¢ âˆ‘ x in Finset.Nat.antidiagonal i, coeff aâœ x.fst * coeff bâœ x.snd âˆˆ I ^ i
    apply Ideal.sum_mem
    -- âŠ¢ âˆ€ (c : â„• Ã— â„•), c âˆˆ Finset.Nat.antidiagonal i â†’ coeff aâœ c.fst * coeff bâœ c.s â€¦
    rintro âŸ¨j, kâŸ© e
    -- âŠ¢ coeff aâœ (j, k).fst * coeff bâœ (j, k).snd âˆˆ I ^ i
    rw [â† Finset.Nat.mem_antidiagonal.mp e, pow_add]
    -- âŠ¢ coeff aâœ (j, k).fst * coeff bâœ (j, k).snd âˆˆ I ^ (j, k).fst * I ^ (j, k).snd
    exact Ideal.mul_mem_mul (hf j) (hg k)
    -- ğŸ‰ no goals
  one_mem' i := by
    rw [coeff_one]
    -- âŠ¢ (if 0 = i then 1 else 0) âˆˆ I ^ i
    split_ifs with h
    -- âŠ¢ 1 âˆˆ I ^ i
    Â· subst h
      -- âŠ¢ 1 âˆˆ I ^ 0
      simp
      -- ğŸ‰ no goals
    Â· simp
      -- ğŸ‰ no goals
  add_mem' hf hg i := by
    rw [coeff_add]
    -- âŠ¢ coeff aâœ i + coeff bâœ i âˆˆ I ^ i
    exact Ideal.add_mem _ (hf i) (hg i)
    -- ğŸ‰ no goals
  zero_mem' i := Ideal.zero_mem _
  algebraMap_mem' r i := by
    rw [algebraMap_apply, coeff_C]
    -- âŠ¢ (if i = 0 then â†‘(algebraMap R R) r else 0) âˆˆ I ^ i
    split_ifs with h
    -- âŠ¢ â†‘(algebraMap R R) r âˆˆ I ^ i
    Â· subst h
      -- âŠ¢ â†‘(algebraMap R R) r âˆˆ I ^ 0
      simp
      -- ğŸ‰ no goals
    Â· simp
      -- ğŸ‰ no goals
#align rees_algebra reesAlgebra

theorem mem_reesAlgebra_iff (f : R[X]) : f âˆˆ reesAlgebra I â†” âˆ€ i, f.coeff i âˆˆ I ^ i :=
  Iff.rfl
#align mem_rees_algebra_iff mem_reesAlgebra_iff

theorem mem_reesAlgebra_iff_support (f : R[X]) :
    f âˆˆ reesAlgebra I â†” âˆ€ i âˆˆ f.support, f.coeff i âˆˆ I ^ i := by
  apply forall_congr'
  -- âŠ¢ âˆ€ (a : â„•), coeff f a âˆˆ I ^ a â†” a âˆˆ support f â†’ coeff f a âˆˆ I ^ a
  intro a
  -- âŠ¢ coeff f a âˆˆ I ^ a â†” a âˆˆ support f â†’ coeff f a âˆˆ I ^ a
  rw [mem_support_iff, Iff.comm, imp_iff_right_iff, Ne.def, â† imp_iff_not_or]
  -- âŠ¢ coeff f a = 0 â†’ coeff f a âˆˆ I ^ a
  exact fun e => e.symm â–¸ (I ^ a).zero_mem
  -- ğŸ‰ no goals
#align mem_rees_algebra_iff_support mem_reesAlgebra_iff_support

theorem reesAlgebra.monomial_mem {I : Ideal R} {i : â„•} {r : R} :
    monomial i r âˆˆ reesAlgebra I â†” r âˆˆ I ^ i := by
  simp (config := { contextual := true }) [mem_reesAlgebra_iff_support, coeff_monomial, â†
    imp_iff_not_or]
#align rees_algebra.monomial_mem reesAlgebra.monomial_mem

theorem monomial_mem_adjoin_monomial {I : Ideal R} {n : â„•} {r : R} (hr : r âˆˆ I ^ n) :
    monomial n r âˆˆ Algebra.adjoin R (Submodule.map (monomial 1 : R â†’â‚—[R] R[X]) I : Set R[X]) := by
  induction' n with n hn generalizing r
  -- âŠ¢ â†‘(monomial Nat.zero) r âˆˆ Algebra.adjoin R â†‘(Submodule.map (monomial 1) I)
  Â· exact Subalgebra.algebraMap_mem _ _
    -- ğŸ‰ no goals
  Â· rw [pow_succ] at hr
    -- âŠ¢ â†‘(monomial (Nat.succ n)) r âˆˆ Algebra.adjoin R â†‘(Submodule.map (monomial 1) I)
    apply Submodule.smul_induction_on
      -- Porting note: did not need help with motive previously
      (p := fun r => (monomial (Nat.succ n)) r âˆˆ Algebra.adjoin R (Submodule.map (monomial 1) I)) hr
    Â· intro r hr s hs
      -- âŠ¢ â†‘(monomial (Nat.succ n)) (r â€¢ s) âˆˆ Algebra.adjoin R â†‘(Submodule.map (monomia â€¦
      rw [Nat.succ_eq_one_add, smul_eq_mul, â† monomial_mul_monomial]
      -- âŠ¢ â†‘(monomial 1) r * â†‘(monomial n) s âˆˆ Algebra.adjoin R â†‘(Submodule.map (monomi â€¦
      exact Subalgebra.mul_mem _ (Algebra.subset_adjoin (Set.mem_image_of_mem _ hr)) (hn hs)
      -- ğŸ‰ no goals
    Â· intro x y hx hy
      -- âŠ¢ â†‘(monomial (Nat.succ n)) (x + y) âˆˆ Algebra.adjoin R â†‘(Submodule.map (monomia â€¦
      rw [monomial_add]
      -- âŠ¢ â†‘(monomial (Nat.succ n)) x + â†‘(monomial (Nat.succ n)) y âˆˆ Algebra.adjoin R â†‘ â€¦
      exact Subalgebra.add_mem _ hx hy
      -- ğŸ‰ no goals
#align monomial_mem_adjoin_monomial monomial_mem_adjoin_monomial

theorem adjoin_monomial_eq_reesAlgebra :
    Algebra.adjoin R (Submodule.map (monomial 1 : R â†’â‚—[R] R[X]) I : Set R[X]) = reesAlgebra I := by
  apply le_antisymm
  -- âŠ¢ Algebra.adjoin R â†‘(Submodule.map (monomial 1) I) â‰¤ reesAlgebra I
  Â· apply Algebra.adjoin_le _
    -- âŠ¢ â†‘(Submodule.map (monomial 1) I) âŠ† â†‘(reesAlgebra I)
    rintro _ âŸ¨r, hr, rflâŸ©
    -- âŠ¢ â†‘(monomial 1) r âˆˆ â†‘(reesAlgebra I)
    exact reesAlgebra.monomial_mem.mpr (by rwa [pow_one])
    -- ğŸ‰ no goals
  Â· intro p hp
    -- âŠ¢ p âˆˆ Algebra.adjoin R â†‘(Submodule.map (monomial 1) I)
    rw [p.as_sum_support]
    -- âŠ¢ âˆ‘ i in support p, â†‘(monomial i) (coeff p i) âˆˆ Algebra.adjoin R â†‘(Submodule.m â€¦
    apply Subalgebra.sum_mem _ _
    -- âŠ¢ âˆ€ (x : â„•), x âˆˆ support p â†’ â†‘(monomial x) (coeff p x) âˆˆ Algebra.adjoin R â†‘(Su â€¦
    rintro i -
    -- âŠ¢ â†‘(monomial i) (coeff p i) âˆˆ Algebra.adjoin R â†‘(Submodule.map (monomial 1) I)
    exact monomial_mem_adjoin_monomial (hp i)
    -- ğŸ‰ no goals
#align adjoin_monomial_eq_rees_algebra adjoin_monomial_eq_reesAlgebra

variable {I}

theorem reesAlgebra.fg (hI : I.FG) : (reesAlgebra I).FG := by
  classical
    obtain âŸ¨s, hsâŸ© := hI
    rw [â† adjoin_monomial_eq_reesAlgebra, â† hs]
    use s.image (monomial 1)
    rw [Finset.coe_image]
    change
      _ =
        Algebra.adjoin R
          (Submodule.map (monomial 1 : R â†’â‚—[R] R[X]) (Submodule.span R â†‘s) : Set R[X])
    rw [Submodule.map_span, Algebra.adjoin_span]
#align rees_algebra.fg reesAlgebra.fg

instance [IsNoetherianRing R] : Algebra.FiniteType R (reesAlgebra I) :=
  âŸ¨(reesAlgebra I).fg_top.mpr (reesAlgebra.fg <| IsNoetherian.noetherian I)âŸ©

instance [IsNoetherianRing R] : IsNoetherianRing (reesAlgebra I) :=
  Algebra.FiniteType.isNoetherianRing R _
