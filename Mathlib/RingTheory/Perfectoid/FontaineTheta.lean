/-
Copyright (c) 2025 Jiedong Jiang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jiedong Jiang
-/
module

public import Mathlib.RingTheory.AdicCompletion.Functoriality
public import Mathlib.RingTheory.AdicCompletion.RingHom
public import Mathlib.RingTheory.Perfectoid.Untilt
public import Mathlib.RingTheory.WittVector.TeichmullerSeries

/-!
# Fontaine's Î¸ map
In this file, we define Fontaine's `Î¸` map, which is a ring
homomorphism from the Witt vector `ğ• Râ™­` of the tilt of a perfectoid ring `R`
to `R` itself. Our definition of `Î¸` does not require that `R` is perfectoid in the first place.
We only need `R` to be `p`-adically complete.

## Main Definitions
* `fontaineTheta` : Fontaine's Î¸ map, which is a ring homomorphism from `ğ• Râ™­` to `R`.

## Main Theorems
* `fontaineTheta_teichmuller` : `Î¸([x])` is the untilt of `x`.
* `fontaineTheta_surjective` : Fontaine's Î¸ map is surjective.

## TODO
Establish that our definition (explicit construction of `Î¸ mod p ^ n`) agrees with the
deformation-theoretic approach via the cotangent complex, as in
[Bhatt, *Lecture notes for a class on perfectoid spaces*.
Remark 6.1.7](https://www.math.ias.edu/~bhatt/teaching/mat679w17/lectures.pdf).

## Tags
Fontaine's theta map, perfectoid theory, p-adic Hodge theory

## Reference

* [Fontaine, *Sur Certains Types de ReprÃ©sentations p-Adiques du Groupe de Galois d'un Corps Local;
Construction d'un Anneau de Barsotti-Tate*][fontaine1982certains]
* [Fontaine, *Le corps des pÃ©riodes p-adiques*][fontaine1994corps]

-/

@[expose] public section

universe u

open Ideal Quotient PreTilt WittVector

noncomputable section

variable {R : Type u} [CommRing R] {p : â„•} [Fact p.Prime]

local notation "ğ• " A:100 => WittVector p A
local notation A "â™­" => PreTilt A p
local notation3 "ğ”­" => span {(p : R)}

namespace WittVector

/-!
## Î¸ as a ring homomorphism
Let `ğ”­` denote the ideal of `R` generated by the prime number `p`. In this section, we first
define the ring homomorphism `fontaineThetaModPPow : ğ• Râ™­ â†’+* R â§¸ ğ”­ ^ (n + 1)`.
Then we show they are compatible with each other and lift to a
ring homomorphism `fontaineTheta : ğ• Râ™­ â†’+* R`.

To prove this, we define `fontaineThetaModPPow` as a composition of the following ring
homomorphisms.

`ğ• Râ™­ --ğ•(Frob^-n)-> ğ• Râ™­ --ğ•(coeff 0)-> ğ•(R/ğ”­) --gh_n-> R/ğ”­^(n+1)`

Here, the ring map `gh_n` fits in the following diagram.

```
ğ•(R)  --ghost_n->   R
|                   |
v                   v
ğ•(R/ğ”­) --gh_n-> R/ğ”­^(n+1)
```
-/

theorem ker_map_le_ker_mk_comp_ghostComponent (n : â„•) :
    RingHom.ker (WittVector.map (Ideal.Quotient.mk ğ”­)) â‰¤
    RingHom.ker (((Ideal.Quotient.mk (ğ”­ ^ (n + 1)))).comp
    (WittVector.ghostComponent (p := p) n)) := by
  intro x
  simp only [RingHom.mem_ker, map_eq_zero_iff, RingHom.comp_apply]
  intro h
  simp only [ghostComponent]
  apply_fun Ideal.quotEquivOfEq (Ideal.span_singleton_pow _ (n + 1))
  simp only [RingHom.coe_comp, Function.comp_apply, Pi.evalRingHom_apply, ghostMap_apply,
    quotEquivOfEq_mk, map_zero]
  simp only [eq_zero_iff_dvd] at h âŠ¢
  exact pow_dvd_ghostComponent_of_dvd_coeff (fun _ _ â†¦ h _)

/--
The lift ring map `gh_n : ğ•(R/ğ”­) â†’+* R/ğ”­^(n+1)` of the `n`-th ghost component
`ğ•(R) â†’+* R` along the surjective ring map `ğ•(R) â†’+* ğ•(R/ğ”­)`.
-/
def ghostComponentModPPow (n : â„•) : ğ• (R â§¸ ğ”­) â†’+* R â§¸ ğ”­ ^ (n + 1) :=
  RingHom.liftOfSurjective (WittVector.map (Ideal.Quotient.mk ğ”­))
    (map_surjective _ Ideal.Quotient.mk_surjective) âŸ¨((Ideal.Quotient.mk (ğ”­ ^ (n + 1)))).comp
      (WittVector.ghostComponent n), ker_map_le_ker_mk_comp_ghostComponent nâŸ©

@[simp]
theorem ghostComponentModPPow_map_mk (n : â„•) (x : ğ• R) :
    ghostComponentModPPow n (WittVector.map (Ideal.Quotient.mk ğ”­) x) =
    WittVector.ghostComponent n x :=
  RingHom.liftOfSurjective_comp_apply ..

@[simp]
theorem quotEquivOfEq_ghostComponentModPPow (x : ğ• (R â§¸ ğ”­)) (h : ğ”­ ^ (0 + 1) = ğ”­) :
    quotEquivOfEq h (ghostComponentModPPow 0 x) = ghostComponent 0 x := by
  obtain âŸ¨y, hyâŸ© := map_surjective _ Ideal.Quotient.mk_surjective x
  simp [â† hy, ghostComponent_apply]

variable [Fact Â¬IsUnit (p : R)] [IsAdicComplete (span {(p : R)}) R]
-- local notation ğ”­ does not work in [IsAdicComplete (span {(p : R)}) R]

@[simp]
theorem ghostComponentModPPow_teichmuller_coeff (n : â„•) (x : Râ™­) :
    ghostComponentModPPow n (teichmuller p (PreTilt.coeff n x)) =
    Ideal.Quotient.mk (ğ”­ ^ (n + 1)) x.untilt := by
  simpa using ghostComponentModPPow_map_mk n
    (teichmuller p ((((_root_.frobeniusEquiv _ p).symm ^ n) x).untilt))

variable (R p) in
/--
The Fontaine's theta map modulo `p^(n+1)`.
It is the composition of the following ring homomorphisms.
`ğ• Râ™­ --ğ•(Frob^-n)-> ğ• Râ™­ --ğ•(coeff 0)-> ğ•(R/p) --gh_n-> R/p^(n+1)`
-/
def fontaineThetaModPPow (n : â„•) : ğ• Râ™­ â†’+* R â§¸ ğ”­ ^ (n + 1) :=
  (ghostComponentModPPow n).comp (((WittVector.map (PreTilt.coeff 0))).comp
    (WittVector.map ((_root_.frobeniusEquiv (Râ™­) p).symm ^ n : Râ™­ â†’+* Râ™­)))

@[simp]
theorem fontaineThetaModPPow_teichmuller (n : â„•) (x : Râ™­) :
    fontaineThetaModPPow R p n (teichmuller p x) = Ideal.Quotient.mk _ x.untilt := by
  simp [fontaineThetaModPPow]

theorem factorPowSucc_comp_fontaineThetaModPPow (n : â„•) :
    (factorPowSucc _ _).comp (fontaineThetaModPPow R p (n + 1)) = fontaineThetaModPPow R p n := by
  apply eq_of_apply_teichmuller_eq ((factorPowSucc _ _).comp (fontaineThetaModPPow R p (n + 1)))
    (fontaineThetaModPPow R p n)
  Â· use n + 1
    have : p = Ideal.Quotient.mk (ğ”­ ^ (n + 1)) p := by
      simp [map_natCast]
    rw [this, â† map_pow, Ideal.Quotient.eq_zero_iff_mem]
    exact Ideal.pow_mem_pow (mem_span_singleton_self _) _
  simp [fontaineThetaModPPow]

theorem factorPowSucc_fontaineThetaModPPow_eq (n : â„•) (x : ğ• Râ™­) :
    factorPowSucc _ _ ((fontaineThetaModPPow R p (n + 1)) x) = fontaineThetaModPPow R p n x := by
  simp [â† factorPowSucc_comp_fontaineThetaModPPow n]

open IsAdicComplete

variable (R p) in
/--
The Fontaine's Î¸ map from `ğ• Râ™­` to `R`.
It is the limit of the ring maps `fontaineThetaModPPow n` from `ğ• Râ™­` to `R/p^(n+1)`.
-/
def fontaineTheta : ğ• Râ™­ â†’+* R :=
  Order.succ_strictMono.liftRingHom ğ”­ _ (factorPowSucc_comp_fontaineThetaModPPow _)

theorem mk_pow_fontaineTheta (n : â„•) (x : ğ• Râ™­) :
    Ideal.Quotient.mk (ğ”­ ^ (n + 1)) (fontaineTheta R p x) = fontaineThetaModPPow R p n x :=
  Order.succ_strictMono.mk_liftRingHom ğ”­ _ (factorPowSucc_comp_fontaineThetaModPPow _) x

theorem mk_fontaineTheta (x : ğ• Râ™­) :
    Ideal.Quotient.mk ğ”­ (fontaineTheta R p x) = PreTilt.coeff 0 (x.coeff 0) := by
  have := mk_pow_fontaineTheta 0 x
  simp only [Nat.reduceAdd] at this
  apply_fun Ideal.quotEquivOfEq (pow_one (p : R) â–¸ Ideal.span_singleton_pow (p : R) 1) at this
  simp only [quotEquivOfEq_mk] at this
  rw [this]
  simp [fontaineThetaModPPow, ghostComponent_apply, RingHom.one_def]

@[simp]
theorem fontaineTheta_teichmuller (x : Râ™­) : fontaineTheta R p (teichmuller p x) = x.untilt := by
  rw [IsHausdorff.eq_iff_smodEq (I := ğ”­)]
  simp only [smul_eq_mul, mul_top]
  intro n
  cases n
  Â· simp
  Â· simp [SModEq, mk_pow_fontaineTheta]

end WittVector

variable [Fact Â¬IsUnit (p : R)] [IsAdicComplete (span {(p : R)}) R]

/-- If the Frobenius map is surjective on `R/pR`, then the Fontaine's Î¸ map is surjective. -/
theorem surjective_fontaineTheta (hF : Function.Surjective (frobenius (ModP R p) p)) :
    Function.Surjective (fontaineTheta R p) := by
  have : Ideal.map (fontaineTheta R p) (span {(p : ğ• Râ™­)}) = ğ”­ := by
    simp [map_span]
  have _ : IsHausdorff ((span {(p : ğ• Râ™­)}).map (fontaineTheta R p)) R := by
    rw [this]
    infer_instance
  apply surjective_of_mk_map_comp_surjective (fontaineTheta R p) (I := span {(p : ğ• Râ™­)})
  simp only [RingHom.coe_comp]
  suffices h : Function.Surjective (Ideal.Quotient.mk ğ”­ âˆ˜ fontaineTheta R p) by
    rwa [Ideal.map_span, Set.image_singleton, map_natCast]
  have : Ideal.Quotient.mk ğ”­ âˆ˜ fontaineTheta R p = (fun x â†¦
      PreTilt.coeff 0 x) âˆ˜ fun (x : ğ• Râ™­) â†¦ (x.coeff 0) := by
    ext
    simp [mk_fontaineTheta]
  rw [this]
  apply Function.Surjective.comp
  Â· exact Perfection.coeff_surjective hF 0
  Â· exact WittVector.coeff_surjective 0
