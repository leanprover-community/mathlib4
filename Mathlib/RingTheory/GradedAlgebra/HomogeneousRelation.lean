/-
Copyright (c) 2025 Jingting Wang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zhixuan Dai, Yiming Fu, Zhenyan Fu, Raphael Douglas Giles, Jiedong Jiang, Jingting Wang
-/
import Mathlib.Algebra.RingQuot
import Mathlib.RingTheory.GradedAlgebra.Basic

/-!
# Homogeneous Relation

In this file, we define the property of an ideal being homogeneous.

## Main Definitions

* `IsHomogeneousRelation`: a relation `r : A â†’ A â†’ Prop` is homogeneous with respect to the grading
  `ğ’œ` if `r x y` implies that for every index `i`, the projection of `x` and `y` onto the `i`-th
  grading piece satisfies the equivalence relation generated by `r`.

## Main Results

* We proved that taking `RingQuot` of a graded ring (or graded algebra) by a homogeneous relation
  gives a graded strucutre on the quotient ring.
-/

variable {Î¹ : Type*} [DecidableEq Î¹] [AddMonoid Î¹]
variable {A : Type*} [Semiring A]

/-- a relation `r : A â†’ A â†’ Prop` is homogeneous with respect to the grading `ğ’œ` if `r x y` implies
  that for every index `i`, the projection of `x` and `y` onto the `i`-th grading piece satisfies
  the equivalence relation generated by `r`. -/
class IsHomogeneousRelation {Ïƒ : Type*} [SetLike Ïƒ A] [AddSubmonoidClass Ïƒ A] (ğ’œ : Î¹ â†’ Ïƒ)
  [GradedRing ğ’œ] (r : A â†’ A â†’ Prop) : Prop where
  is_homogeneous' : âˆ€ {x y : A}, r x y â†’
  âˆ€ i : Î¹, (Relation.EqvGen r) ((GradedRing.proj ğ’œ i) x) ((GradedRing.proj ğ’œ i) y)

namespace HomogeneousRelation

section RingCon

variable {Ïƒ : Type*} [SetLike Ïƒ A] [AddSubmonoidClass Ïƒ A]
variable (ğ’œ : Î¹ â†’ Ïƒ) [GradedRing ğ’œ] (rel : A â†’ A â†’ Prop)

open Relation GradedRing

lemma eqvGen_ringQuot_of_eqvGen {a b : A} (h : EqvGen rel a b) :
    EqvGen (RingQuot.Rel rel) a b := Relation.EqvGen.mono (fun _ _ h' â†¦ RingQuot.Rel.of h') h

lemma eqvGen_ringQuot_add_right {a b c : A} (h : EqvGen (RingQuot.Rel rel) a b) :
    EqvGen (RingQuot.Rel rel) (a + c) (b + c) := by
  induction h with
  | rel x y hxy =>
    apply EqvGen.rel
    exact RingQuot.Rel.add_left hxy
  | refl x =>
    exact Quot.eqvGen_exact rfl
  | symm x y h1 h2 =>
    exact EqvGen.symm (x + c) (y + c) h2
  | trans x y z _ _ h1 h2 =>
    exact EqvGen.trans (x + c) (y + c) (z + c) h1 h2

lemma eqvGen_ringQuot_mul_left {a b c : A} (h : EqvGen (RingQuot.Rel rel) a b) :
    EqvGen (RingQuot.Rel rel) (a * c) (b * c) := by
  induction h with
  | rel x y hxy =>
    apply EqvGen.rel
    exact RingQuot.Rel.mul_left hxy
  | refl x =>
    exact Quot.eqvGen_exact rfl
  | symm x y h1 h2 =>
    exact EqvGen.symm (x * c) (y * c) h2
  | trans x y z _ _ h1 h2 =>
    exact EqvGen.trans (x * c) (y * c) (z * c) h1 h2

lemma eqvGen_ringQuot_mul_right {a b c : A} (h : EqvGen (RingQuot.Rel rel) a b) :
    EqvGen (RingQuot.Rel rel) (c * a) (c * b) := by
  induction h with
  | rel x y hxy =>
    apply EqvGen.rel
    exact RingQuot.Rel.mul_right hxy
  | refl x =>
    exact Quot.eqvGen_exact rfl
  | symm x y h1 h2 =>
    exact EqvGen.symm (c * x) (c * y) h2
  | trans x y z _ _ h1 h2 =>
    exact EqvGen.trans (c * x) (c * y) (c * z) h1 h2

/-- To prove a relation between two products, it suffices to prove that
the relation is multiplicative and holds on factors. -/
@[to_additive "To prove a relation between two sums, it suffices to prove that
the relation is additive and holds on summands."]
lemma Finset.relation_prod_induction {Î± : Type*} {s : Finset Î±} [DecidableEq Î±]
    {M : Type*} [CommMonoid M] (f : Î± â†’ M) (g : Î± â†’ M) (r : M â†’ M â†’ Prop)
    (hom : âˆ€ (a b c d : M), r a b â†’ r c d â†’ r (a * c) (b * d)) (unit : r 1 1)
    (base : âˆ€ x âˆˆ s, r (f x) (g x)) :
    r (âˆ x âˆˆ s, f x) (âˆ x âˆˆ s, g x) := by
  induction s using Finset.induction with
  | empty => simpa
  | insert _ _ => simp_all

lemma coe_mul_sum_support_subset {Î¹ : Type*} {Ïƒ : Type*} {R : Type*} [DecidableEq Î¹]
    [Semiring R] [SetLike Ïƒ R] [AddSubmonoidClass Ïƒ R] (A : Î¹ â†’ Ïƒ)
    [(i : Î¹) â†’ (x : â†¥(A i)) â†’ Decidable (x â‰  0)] (r r' : DirectSum Î¹ fun i â†¦ â†¥(A i))
    {S T: Finset Î¹} (hS : DFinsupp.support r âŠ† S) (hT : DFinsupp.support r' âŠ† T)
    (p : Î¹ Ã— Î¹ â†’ Prop) [DecidablePred p] :
    âˆ‘ ij âˆˆ Finset.filter p (DFinsupp.support r Ã—Ë¢ DFinsupp.support r'), ((r ij.1) * (r' ij.2) : R) =
    âˆ‘ ij âˆˆ Finset.filter p (S Ã—Ë¢ T), ((r ij.1) * (r' ij.2) : R) := by
  rw [Finset.sum_filter, Finset.sum_filter]
  apply Finset.sum_subset (Finset.product_subset_product hS hT)
  intro x _ hx
  simp only [Finset.mem_product, DFinsupp.mem_support_toFun, ne_eq, not_and, not_not] at hx
  have : ((r x.1) * (r' x.2) : R) = 0 := by
    by_cases h : r x.1 = 0
    Â· simp [h]
    Â· simp [hx h]
  simp [this]

private noncomputable instance : (i : Î¹) â†’ (x : â†¥(ğ’œ i)) â†’ Decidable (x â‰  0) :=
    fun _ x â†¦ Classical.propDecidable (x â‰  0)

theorem eqvGen_proj_mul_right {a b c : A} (n : Î¹)
    (h : âˆ€ (i : Î¹), EqvGen (RingQuot.Rel rel) ((proj ğ’œ i) a) ((proj ğ’œ i) b)) :
    EqvGen (RingQuot.Rel rel) ((proj ğ’œ n) (a * c)) ((proj ğ’œ n) (b * c)) := by
  simp only [proj_apply] at h
  simp only [proj_apply, DirectSum.decompose_mul, DirectSum.coe_mul_apply]
  rw [coe_mul_sum_support_subset ğ’œ _ _ Finset.subset_union_left (Set.Subset.refl _),
    coe_mul_sum_support_subset ğ’œ _ _ Finset.subset_union_right (Set.Subset.refl _)]
  apply Finset.relation_sum_induction
  Â· intro _ _ _ _ hab hcd
    rw [RingQuot.eqvGen_rel_eq] at hab hcd âŠ¢
    exact RingConGen.Rel.add hab hcd
  Â· rw [RingQuot.eqvGen_rel_eq]
    exact RingConGen.Rel.refl 0
  Â· exact fun x _ => eqvGen_ringQuot_mul_left rel (h x.1)

theorem eqvGen_proj_mul_left {a b c : A} (n : Î¹)
    (h : âˆ€ (i : Î¹), EqvGen (RingQuot.Rel rel) ((proj ğ’œ i) a) ((proj ğ’œ i) b)) :
    EqvGen (RingQuot.Rel rel) ((proj ğ’œ n) (c * a)) ((proj ğ’œ n) (c * b)) := by
  simp only [proj_apply] at h
  simp only [proj_apply, DirectSum.decompose_mul, DirectSum.coe_mul_apply]
  rw [coe_mul_sum_support_subset ğ’œ _ _ (Set.Subset.refl _) Finset.subset_union_left,
    coe_mul_sum_support_subset ğ’œ _ _ (Set.Subset.refl _) Finset.subset_union_right]
  apply Finset.relation_sum_induction
  Â· intro _ _ _ _ hab hcd
    rw [RingQuot.eqvGen_rel_eq] at hab hcd âŠ¢
    exact RingConGen.Rel.add hab hcd
  Â· rw [RingQuot.eqvGen_rel_eq]
    exact RingConGen.Rel.refl 0
  Â· exact fun x _ => eqvGen_ringQuot_mul_right rel (h x.2)

variable [IsHomogeneousRelation ğ’œ rel]

instance : IsHomogeneousRelation ğ’œ (RingQuot.Rel rel) := âŸ¨by
  intro x y h; induction h
  case of x y h_rel =>
    intro n
    apply eqvGen_ringQuot_of_eqvGen
    exact IsHomogeneousRelation.is_homogeneous' h_rel n
  case add_left a b c h_rel h =>
    intro n
    rw [map_add, map_add]
    exact eqvGen_ringQuot_add_right rel (h n)
  case mul_left a b c h_rel h =>
    intro n
    exact eqvGen_proj_mul_right ğ’œ rel n h
  case mul_right c a b h_rel h =>
    intro n
    exact eqvGen_proj_mul_left ğ’œ rel n hâŸ©

instance : IsHomogeneousRelation ğ’œ (Relation.EqvGen rel) := by
  apply IsHomogeneousRelation.mk
  rw [Equivalence.eqvGen_eq (Relation.EqvGen.is_equivalence rel)]
  intro x y h
  induction h with
  | refl => exact fun i â†¦ Quot.eqvGen_exact rfl
  | symm x y _ h1 =>
    exact fun i â†¦ EqvGen.symm ((proj ğ’œ i) x) ((proj ğ’œ i) y) (h1 i)
  | trans j k l _ _ h2 h3 =>
    exact fun i â†¦
      EqvGen.trans ((proj ğ’œ i) j) ((proj ğ’œ i) k) ((proj ğ’œ i) l)
        (h2 i) (h3 i)
  | rel _ _ h4 =>
    exact fun i â†¦ IsHomogeneousRelation.is_homogeneous' h4 i

instance : IsHomogeneousRelation ğ’œ (RingConGen.Rel rel) :=
  (RingQuot.eqvGen_rel_eq rel) â–¸ inferInstance

end RingCon

section GradedRing

variable (ğ’œ : Î¹ â†’ AddSubmonoid A) [inst : GradedRing ğ’œ] (rel : A â†’ A â†’ Prop)

instance : SetLike.GradedMonoid ((AddSubmonoid.map (RingQuot.mkRingHom rel)).comp ğ’œ) where
  one_mem := by
    use 1
    constructor
    Â· exact SetLike.GradedOne.one_mem
    Â· exact map_one (RingQuot.mkRingHom rel)
  mul_mem := by
    intro x y gi gj hi hj
    simp only [Function.comp_apply, Submodule.mem_map]
    rcases hi with âŸ¨a, ha1, ha2âŸ©
    rcases hj with âŸ¨b, hb1, hb2âŸ©
    use a * b
    constructor
    Â· exact SetLike.GradedMul.mul_mem ha1 hb1
    Â· rw [map_mul, ha2, hb2]

open DirectSum

@[simp]
lemma decomposeRingEquiv_apply (a : A) :
    decomposeRingEquiv ğ’œ a = decompose ğ’œ a := rfl

lemma RingEquiv.comp_inj {A B C : Type*} [NonAssocSemiring A] [NonAssocSemiring B]
    [NonAssocSemiring C] (e : A â‰ƒ+* B) {f g : B â†’+* C}
    (h : f.comp e.toRingHom = g.comp e.toRingHom) : f = g := RingHom.ext
    fun x â†¦ (by simpa using congr($h (e.symm x)))

private def RingHomAux : (â¨ i, ğ’œ i) â†’+* â¨ i, (AddSubmonoid.map (RingQuot.mkRingHom rel) âˆ˜ ğ’œ) i := by
  apply toSemiring (fun i â†¦ (of _ i).comp <| (RingQuot.mkRingHom rel).addSubmonoidMap (ğ’œ i))
  Â· simp only [Function.comp_apply, RingHom.toAddMonoidHom_eq_coe, AddMonoidHom.coe_comp]
    congr 1; ext
    exact map_one (RingQuot.mkRingHom rel)
  Â· intro i j ai aj
    simp only [Function.comp_apply, GradedMonoid.GMul.mul, HMul.hMul, AddMonoidHom.coe_comp,
      Mul.mul, mulHom, toAddMonoid_of, AddMonoidHom.flip_apply, AddMonoidHom.compHom_apply_apply,
      gMulHom_apply_apply]
    congr 1; ext
    exact map_mul (RingQuot.mkRingHom rel) _ _

variable [IsHomogeneousRelation ğ’œ rel]

noncomputable instance : GradedRing ((AddSubmonoid.map (RingQuot.mkRingHom rel)).comp ğ’œ) := by
  refine GradedRing.ofRingHom ((AddSubmonoid.map (RingQuot.mkRingHom rel)).comp ğ’œ)
    (RingQuot.lift âŸ¨(RingHomAux ğ’œ rel).comp (decomposeRingEquiv ğ’œ), ?_âŸ©) ?_ ?_
  Â· intro x y h; ext j
    simp only [Function.comp_apply, RingHomAux, RingHom.toAddMonoidHom_eq_coe, RingHom.coe_comp,
      RingHom.coe_coe, decomposeRingEquiv_apply, toSemiring_apply, SetLike.coe_eq_coe]
    rw [â† map_eq_toAddMonoid]
    apply Subtype.ext
    show (RingQuot.mkRingHom rel) (GradedRing.proj ğ’œ j x) =
      (RingQuot.mkRingHom rel) (GradedRing.proj ğ’œ j y)
    have := â€¹IsHomogeneousRelation ğ’œ relâ€º.is_homogeneous' h j
    suffices h : âˆ€ u v : A, Relation.EqvGen rel u v â†’
      RingQuot.mkRingHom rel u = RingQuot.mkRingHom rel v from h _ _ this
    intro u v h
    induction h with
    | rel _ _ h' => exact RingQuot.mkRingHom_rel h'
    | refl u => rfl
    | symm _ _ _ h' => exact h'.symm
    | trans _ _ _ _ _ h' h'' => exact h'.trans h''
  Â· apply RingQuot.ringQuot_ext
    apply RingEquiv.comp_inj (decomposeRingEquiv ğ’œ).symm
    ext i x
    simp only [Function.comp_apply, RingHomAux, RingHom.toAddMonoidHom_eq_coe,
      RingEquiv.toRingHom_eq_coe, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, RingHom.coe_comp,
      RingHom.coe_coe, RingQuot.lift_mkRingHom_apply, RingEquiv.apply_symm_apply, toSemiring_apply,
      toAddMonoid_of, RingHomCompTriple.comp_eq]
    erw [coeRingHom_of, coeRingHom_of]
    rfl
  Â· intro i âŸ¨_, âŸ¨y, hy, rflâŸ©âŸ©
    simp [RingHomAux, decompose_of_mem ğ’œ hy]
    rfl

end GradedRing

section GradedAlgebra

variable {R : Type*} [CommSemiring R] [Algebra R A]
variable (ğ’œ : Î¹ â†’ Submodule R A) [inst : GradedAlgebra ğ’œ] (rel : A â†’ A â†’ Prop)

instance : SetLike.GradedMonoid ((Submodule.map (RingQuot.mkAlgHom R rel)).comp ğ’œ) where
  one_mem := by
    use 1
    constructor
    Â· exact SetLike.GradedOne.one_mem
    Â· exact map_one (RingQuot.mkAlgHom R rel)
  mul_mem := by
    intro x y gi gj hi hj
    simp only [Function.comp_apply, Submodule.mem_map]
    rcases hi with âŸ¨a, ha1, ha2âŸ©
    rcases hj with âŸ¨b, hb1, hb2âŸ©
    use a * b
    constructor
    Â· exact SetLike.GradedMul.mul_mem ha1 hb1
    Â· rw [map_mul, ha2, hb2]

open DirectSum

variable [IsHomogeneousRelation ğ’œ rel]

instance : GradedAlgebra ((Submodule.map (RingQuot.mkAlgHom R rel)).comp ğ’œ) := by
  refine GradedAlgebra.ofAlgHom _
    (RingQuot.liftAlgHom R (s := rel) âŸ¨(toAlgebra R (fun i â†¦ ğ’œ i)
      (fun i â†¦ (lof R Î¹ _ i).comp (RingQuot.mkAlgHom R rel |>.toLinearMap.submoduleMap (ğ’œ i)))
        ?_ ?_).comp (decomposeAlgEquiv ğ’œ), ?_âŸ©) ?_ ?_
  Â· simp only [Function.comp_apply, LinearMap.coe_comp, one_def, lof_eq_of]
    congr 1; ext
    exact map_one (RingQuot.mkAlgHom R rel)
  Â· intro i j ai aj
    simp only [Function.comp_apply, GradedMonoid.GMul.mul, HMul.hMul, LinearMap.coe_comp, lof_eq_of,
      Mul.mul, mulHom, toAddMonoid_of, AddMonoidHom.flip_apply, AddMonoidHom.coe_comp,
      AddMonoidHom.compHom_apply_apply, gMulHom_apply_apply]
    congr 1; ext
    exact map_mul (RingQuot.mkAlgHom R rel) _ _
  Â· intro x y h; ext j
    simp [lof_eq_of, LinearMap.coe_addMonoidHom_comp, â† map_eq_toAddMonoid]
    apply Subtype.ext
    show (RingQuot.mkAlgHom R rel) (GradedRing.proj ğ’œ j x) =
      (RingQuot.mkAlgHom R rel) (GradedRing.proj ğ’œ j y)
    have := â€¹IsHomogeneousRelation ğ’œ relâ€º.is_homogeneous' h j
    suffices h : âˆ€ u v : A, Relation.EqvGen rel u v â†’
      RingQuot.mkAlgHom R rel u = RingQuot.mkAlgHom R rel v from h _ _ this
    intro u v h
    induction h with
    | rel _ _ h' => exact RingQuot.mkAlgHom_rel R h'
    | refl u => rfl
    | symm _ _ _ h' => exact h'.symm
    | trans _ _ _ _ _ h' h'' => exact h'.trans h''
  Â· apply RingQuot.ringQuot_ext' R
    apply AlgEquiv.comp_inj (decomposeAlgEquiv ğ’œ).symm
    ext i x
    simp only [Function.comp_apply, AlgEquiv.toAlgHom_eq_coe, AlgHom.comp_toLinearMap,
      AlgEquiv.toAlgHom_toLinearMap, LinearMap.coe_comp, lof_eq_of, AlgEquiv.toLinearMap_apply,
      decomposeAlgEquiv_symm_apply, decompose_symm_of, AlgHom.toLinearMap_apply,
      RingQuot.liftAlgHom_mkAlgHom_apply, AlgHom.coe_comp, AlgHom.coe_coe, decomposeAlgEquiv_apply,
      decompose_coe, toAlgebra_apply, toSemiring_apply, toAddMonoid_of,
      LinearMap.toAddMonoidHom_coe, AlgHom.id_comp]
    erw [coeAlgHom_of]
    rfl
  Â· intro i âŸ¨_, âŸ¨y, hy, rflâŸ©âŸ©
    simp [decompose_of_mem ğ’œ hy]
    rfl

end GradedAlgebra

end HomogeneousRelation
