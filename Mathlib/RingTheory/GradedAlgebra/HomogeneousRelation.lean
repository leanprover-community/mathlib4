/-
Copyright (c) 2025 Jingting Wang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zhixuan Dai, Yiming Fu, Zhenyan Fu, Raphael Douglas Giles, Jiedong Jiang, Jingting Wang
-/
import Mathlib.Algebra.RingQuot
import Mathlib.RingTheory.GradedAlgebra.Basic
import Mathlib.GroupTheory.Congruence.BigOperators

/-!
# Homogeneous Relation

In this file, we define the property of an ideal being homogeneous.

## Main Definitions

* `IsHomogeneousRelation`: a relation `r : A → A → Prop` is homogeneous with respect to the grading
  `𝒜` if `r x y` implies that for every index `i`, the projection of `x` and `y` onto the `i`-th
  grading piece satisfies the equivalence relation generated by `r`.

## Main Results

* We proved that taking `RingQuot` of a graded ring (or graded algebra) by a homogeneous relation
  gives a graded strucutre on the quotient ring.
-/

variable {ι : Type*} [DecidableEq ι] [AddMonoid ι]
variable {A : Type*} [Semiring A]

/-- a relation `r : A → A → Prop` is homogeneous with respect to the grading `𝒜` if `r x y` implies
  that for every index `i`, the projection of `x` and `y` onto the `i`-th grading piece satisfies
  the equivalence relation generated by `r`. -/
class IsHomogeneousRelation {σ : Type*} [SetLike σ A] [AddSubmonoidClass σ A] (𝒜 : ι → σ)
  [GradedRing 𝒜] (r : A → A → Prop) : Prop where
  is_homogeneous' : ∀ {x y : A}, r x y →
  ∀ i : ι, (Relation.EqvGen r) ((GradedRing.proj 𝒜 i) x) ((GradedRing.proj 𝒜 i) y)

lemma coe_mul_sum_support_subset {ι : Type*} {σ : Type*} {R : Type*} [DecidableEq ι]
    [Semiring R] [SetLike σ R] [AddSubmonoidClass σ R] (A : ι → σ)
    [(i : ι) → (x : ↥(A i)) → Decidable (x ≠ 0)] (r r' : DirectSum ι fun i ↦ ↥(A i))
    {S T : Finset ι} (hS : DFinsupp.support r ⊆ S) (hT : DFinsupp.support r' ⊆ T)
    (p : ι × ι → Prop) [DecidablePred p] :
    ∑ ij ∈ Finset.filter p (DFinsupp.support r ×ˢ DFinsupp.support r'), ((r ij.1) * (r' ij.2) : R) =
    ∑ ij ∈ Finset.filter p (S ×ˢ T), ((r ij.1) * (r' ij.2) : R) := by
  rw [Finset.sum_filter, Finset.sum_filter]
  apply Finset.sum_subset (Finset.product_subset_product hS hT)
  intro x _ hx
  simp only [Finset.mem_product, DFinsupp.mem_support_toFun, ne_eq, not_and, not_not] at hx
  have : ((r x.1) * (r' x.2) : R) = 0 := by
    by_cases h : r x.1 = 0
    · simp [h]
    · simp [hx h]
  simp [this]

namespace HomogeneousRelation

section RingCon

variable {σ : Type*} [SetLike σ A] [AddSubmonoidClass σ A]
variable (𝒜 : ι → σ) [GradedRing 𝒜] (rel : A → A → Prop)

open Relation GradedRing

private noncomputable instance : (i : ι) → (x : ↥(𝒜 i)) → Decidable (x ≠ 0) :=
    fun _ x ↦ Classical.propDecidable (x ≠ 0)

theorem eqvGen_proj_mul_right {a b c : A} (n : ι)
    (h : ∀ (i : ι), (RingConGen.Rel rel) ((proj 𝒜 i) a) ((proj 𝒜 i) b)) :
    (RingConGen.Rel rel) ((proj 𝒜 n) (a * c)) ((proj 𝒜 n) (b * c)) := by
  simp only [proj_apply] at h
  simp only [proj_apply, DirectSum.decompose_mul, DirectSum.coe_mul_apply]
  rw [coe_mul_sum_support_subset 𝒜 _ _ Finset.subset_union_left (Set.Subset.refl _),
    coe_mul_sum_support_subset 𝒜 _ _ Finset.subset_union_right (Set.Subset.refl _)]
  apply (ringConGen rel).toAddCon.finset_sum _ fun i hi ↦ ?_
  exact RingConGen.Rel.mul (h i.1) (RingConGen.Rel.refl _)

theorem eqvGen_proj_mul_left {a b c : A} (n : ι)
    (h : ∀ (i : ι), (RingConGen.Rel rel) ((proj 𝒜 i) a) ((proj 𝒜 i) b)) :
    (RingConGen.Rel rel) ((proj 𝒜 n) (c * a)) ((proj 𝒜 n) (c * b)) := by
  simp only [proj_apply] at h
  simp only [proj_apply, DirectSum.decompose_mul, DirectSum.coe_mul_apply]
  rw [coe_mul_sum_support_subset 𝒜 _ _ (Set.Subset.refl _) Finset.subset_union_left,
    coe_mul_sum_support_subset 𝒜 _ _ (Set.Subset.refl _) Finset.subset_union_right]
  apply (ringConGen rel).toAddCon.finset_sum _ fun i hi ↦ ?_
  exact RingConGen.Rel.mul (RingConGen.Rel.refl _) (h i.2)

variable [inst : IsHomogeneousRelation 𝒜 rel]

instance : IsHomogeneousRelation 𝒜 (RingQuot.Rel rel) := by
  apply IsHomogeneousRelation.mk
  rw [RingQuot.eqvGen_rel_eq]
  intro x y h
  induction h with
  | of h_rel =>
    intro i
    rw [← RingQuot.eqvGen_rel_eq]
    exact Relation.EqvGen.mono (fun _ _ h' ↦ RingQuot.Rel.of h') (inst.is_homogeneous' h_rel i)
  | add_left _ h =>
    intro i
    rw [map_add, map_add]
    exact RingConGen.Rel.add (h i) (RingConGen.Rel.refl _)
  | mul_left _ h =>
    exact fun n ↦ eqvGen_proj_mul_right 𝒜 rel n h
  | mul_right _ h =>
    exact fun n ↦ eqvGen_proj_mul_left 𝒜 rel n h

instance : IsHomogeneousRelation 𝒜 (Relation.EqvGen rel) := by
  apply IsHomogeneousRelation.mk
  rw [Equivalence.eqvGen_eq (Relation.EqvGen.is_equivalence rel)]
  intro x y h
  induction h with
  | refl =>
    exact fun i ↦ Quot.eqvGen_exact rfl
  | symm x y _ h1 =>
    exact fun i ↦ EqvGen.symm ((proj 𝒜 i) x) ((proj 𝒜 i) y) (h1 i)
  | trans j k l _ _ h2 h3 =>
    exact (fun i ↦ EqvGen.trans ((proj 𝒜 i) j) ((proj 𝒜 i) k) ((proj 𝒜 i) l) (h2 i) (h3 i))
  | rel _ _ h4 =>
    exact fun i ↦ IsHomogeneousRelation.is_homogeneous' h4 i

instance : IsHomogeneousRelation 𝒜 (RingConGen.Rel rel) :=
  (RingQuot.eqvGen_rel_eq rel) ▸ inferInstance

end RingCon

section GradedRing

variable (𝒜 : ι → AddSubmonoid A) [inst : GradedRing 𝒜] (rel : A → A → Prop)

instance : SetLike.GradedMonoid ((AddSubmonoid.map (RingQuot.mkRingHom rel)).comp 𝒜) where
  one_mem := ⟨1, ⟨SetLike.GradedOne.one_mem, map_one (RingQuot.mkRingHom rel)⟩⟩
  mul_mem := fun x y gi gj ⟨a, ha1, ha2⟩ ⟨b, hb1, hb2⟩ ↦
    ⟨(a * b), ⟨SetLike.GradedMul.mul_mem ha1 hb1, by rw [map_mul, ha2, hb2]⟩⟩

open DirectSum

variable [IsHomogeneousRelation 𝒜 rel]

noncomputable instance : GradedRing ((AddSubmonoid.map (RingQuot.mkRingHom rel)).comp 𝒜) := by
  refine GradedRing.ofRingHom ((AddSubmonoid.map (RingQuot.mkRingHom rel)).comp 𝒜)
    (RingQuot.lift ⟨(toSemiring
      (fun i ↦ (of _ i).comp (RingQuot.mkRingHom rel |>.addSubmonoidMap (𝒜 i)))
        ?_ ?_).comp (decomposeRingEquiv 𝒜), ?_⟩) ?_ ?_
  · simp only [Function.comp_apply, RingHom.toAddMonoidHom_eq_coe, AddMonoidHom.coe_comp]
    congr 1
    exact Subtype.ext <| map_one (RingQuot.mkRingHom rel)
  · intro i j ai aj
    simp only [Function.comp_apply, GradedMonoid.GMul.mul, HMul.hMul, AddMonoidHom.coe_comp,
      Mul.mul, mulHom, toAddMonoid_of, AddMonoidHom.flip_apply, AddMonoidHom.compHom_apply_apply,
      gMulHom_apply_apply]
    congr 1
    exact Subtype.ext <| map_mul (RingQuot.mkRingHom rel) _ _
  · intro x y h
    ext j
    simp only [Function.comp_apply, RingHom.toAddMonoidHom_eq_coe, RingHom.coe_comp,
      RingHom.coe_coe, decomposeRingEquiv_apply, toSemiring_apply, SetLike.coe_eq_coe]
    rw [← map_eq_toAddMonoid]
    apply Subtype.ext
    change (RingQuot.mkRingHom rel) (GradedRing.proj 𝒜 j x) =
      (RingQuot.mkRingHom rel) (GradedRing.proj 𝒜 j y)
    have := ‹IsHomogeneousRelation 𝒜 rel›.is_homogeneous' h j
    suffices h : ∀ u v : A, Relation.EqvGen rel u v →
      RingQuot.mkRingHom rel u = RingQuot.mkRingHom rel v from h _ _ this
    intro u v h
    induction h with
    | rel _ _ h' => exact RingQuot.mkRingHom_rel h'
    | refl u => rfl
    | symm _ _ _ h' => exact h'.symm
    | trans _ _ _ _ _ h' h'' => exact h'.trans h''
  · apply RingQuot.ringQuot_ext
    apply RingEquiv.comp_inj (decomposeRingEquiv 𝒜).symm
    ext i x
    simp only [Function.comp_apply, RingHom.toAddMonoidHom_eq_coe, RingEquiv.toRingHom_eq_coe,
      AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, RingHom.coe_comp, RingHom.coe_coe,
      RingQuot.lift_mkRingHom_apply, RingEquiv.apply_symm_apply, toSemiring_apply, toAddMonoid_of,
      RingHomCompTriple.comp_eq]
    erw [coeRingHom_of, coeRingHom_of]
    rfl
  · intro i ⟨_, ⟨y, hy, rfl⟩⟩
    simp [decompose_of_mem 𝒜 hy]
    rfl

end GradedRing

section GradedAlgebra

variable {R : Type*} [CommSemiring R] [Algebra R A]
variable (𝒜 : ι → Submodule R A) [inst : GradedAlgebra 𝒜] (rel : A → A → Prop)

instance : SetLike.GradedMonoid ((Submodule.map (RingQuot.mkAlgHom R rel)).comp 𝒜) where
  one_mem := ⟨1, ⟨SetLike.GradedOne.one_mem, map_one (RingQuot.mkAlgHom R rel)⟩⟩
  mul_mem := fun x y gi gj ⟨a, ha1, ha2⟩ ⟨b, hb1, hb2⟩ ↦
    ⟨(a * b), ⟨SetLike.GradedMul.mul_mem ha1 hb1, by rw [map_mul, ha2, hb2]⟩⟩

open DirectSum

variable [IsHomogeneousRelation 𝒜 rel]

instance : GradedAlgebra ((Submodule.map (RingQuot.mkAlgHom R rel)).comp 𝒜) := by
  refine GradedAlgebra.ofAlgHom _
    (RingQuot.liftAlgHom R (s := rel) ⟨(toAlgebra R (fun i ↦ 𝒜 i)
      (fun i ↦ (lof R ι _ i).comp (RingQuot.mkAlgHom R rel |>.toLinearMap.submoduleMap (𝒜 i)))
        ?_ ?_).comp (decomposeAlgEquiv 𝒜), ?_⟩) ?_ ?_
  · simp only [Function.comp_apply, LinearMap.coe_comp, one_def, lof_eq_of]
    congr 1
    exact Subtype.ext <| map_one (RingQuot.mkAlgHom R rel)
  · intro i j ai aj
    simp only [Function.comp_apply, GradedMonoid.GMul.mul, HMul.hMul, LinearMap.coe_comp, lof_eq_of,
      Mul.mul, mulHom, toAddMonoid_of, AddMonoidHom.flip_apply, AddMonoidHom.coe_comp,
      AddMonoidHom.compHom_apply_apply, gMulHom_apply_apply]
    congr 1
    exact Subtype.ext <| map_mul (RingQuot.mkAlgHom R rel) _ _
  · intro x y h
    ext j
    simp [LinearMap.coe_addMonoidHom_comp, ← map_eq_toAddMonoid]
    apply Subtype.ext
    change (RingQuot.mkAlgHom R rel) (GradedRing.proj 𝒜 j x) =
      (RingQuot.mkAlgHom R rel) (GradedRing.proj 𝒜 j y)
    have := ‹IsHomogeneousRelation 𝒜 rel›.is_homogeneous' h j
    suffices h : ∀ u v : A, Relation.EqvGen rel u v →
      RingQuot.mkAlgHom R rel u = RingQuot.mkAlgHom R rel v from h _ _ this
    intro u v h
    induction h with
    | rel _ _ h' => exact RingQuot.mkAlgHom_rel R h'
    | refl u => rfl
    | symm _ _ _ h' => exact h'.symm
    | trans _ _ _ _ _ h' h'' => exact h'.trans h''
  · apply RingQuot.ringQuot_ext' R
    apply AlgEquiv.comp_inj (decomposeAlgEquiv 𝒜).symm
    ext i x
    simp only [Function.comp_apply, AlgEquiv.toAlgHom_eq_coe, AlgHom.comp_toLinearMap,
      AlgEquiv.toAlgHom_toLinearMap, LinearMap.coe_comp, lof_eq_of, AlgEquiv.toLinearMap_apply,
      decomposeAlgEquiv_symm_apply, decompose_symm_of, AlgHom.toLinearMap_apply,
      RingQuot.liftAlgHom_mkAlgHom_apply, AlgHom.coe_comp, AlgHom.coe_coe, decomposeAlgEquiv_apply,
      decompose_coe, toAlgebra_apply, toSemiring_apply, toAddMonoid_of,
      LinearMap.toAddMonoidHom_coe, AlgHom.id_comp]
    erw [coeAlgHom_of]
    rfl
  · intro i ⟨_, ⟨y, hy, rfl⟩⟩
    simp [decompose_of_mem 𝒜 hy]
    rfl

end GradedAlgebra

end HomogeneousRelation
