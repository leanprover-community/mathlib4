/-
Copyright (c) 2023 Fangming Li. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Fangming Li
-/
import Mathlib.RingTheory.Noetherian
import Mathlib.RingTheory.GradedAlgebra.HomogeneousIdeal
import Mathlib.RingTheory.FiniteType
import Mathlib.Algebra.Module.GradeZeroModule
import Mathlib.RingTheory.Adjoin.Basic

/-!
# The properties of a graded Noetherian ring.

This file proves some properties of a graded Noetherian ring:
1. The 0-th grade of a Noetherian ring is also a Noetherian ring.
2. For a Noetherian ring `A` which is internally graded by `ğ’œ`,
   `â¨_{i>0} ğ’œáµ¢` is finitely generated as an ideal of `A`.
-/


namespace GradedRing

section Ring

variable {Î¹ A Ïƒ : Type*}
variable [Ring A] [IsNoetherianRing A]
variable [DecidableEq Î¹] [CanonicallyOrderedAddCommMonoid Î¹]
variable [SetLike Ïƒ A] [AddSubgroupClass Ïƒ A]
variable (ğ’œ : Î¹ â†’ Ïƒ) [GradedRing ğ’œ]


/--
If the internally graded ring `A` is Noetherian, then `ğ’œ 0` is a Noetherian ring.
-/
instance GradeZero.subring_isNoetherianRing_of_isNoetherianRing : IsNoetherianRing (ğ’œ 0) :=
  isNoetherianRing_of_surjective A (ğ’œ 0) (GradedRing.projZeroRingHom' ğ’œ)
  (GradedRing.projZeroRingHom'_surjective ğ’œ)

end Ring

section CommRing

variable {A M : Type*}
variable [CommRing A] [AddCommGroup M] [Module A M]
variable [finite_module : Module.Finite A M] [noetherian_ring : IsNoetherianRing A]
variable (ğ’œ : â„• â†’ AddSubgroup A) [GradedRing ğ’œ]
variable (â„³ : â„• â†’ AddSubgroup M) [SetLike.GradedSMul ğ’œ â„³] [DirectSum.Decomposition â„³]

instance : Algebra (ğ’œ 0) A := Algebra.ofSubring (SetLike.GradeZero.subring ğ’œ)

open BigOperators Pointwise SetLike

namespace finite_algebra_over_degree_zero_subring

/--
Since `A` is noetherian, `Aâ‚Š` (the irrelevant ideal) can be homogeneously generated by a finset set.
-/
noncomputable def generating_set : Finset A :=
  (Ideal.fg_iff_homogeneously_fg _  |>.mp <|
    isNoetherianRing_iff_ideal_fg A |>.mp inferInstance
      (HomogeneousIdeal.irrelevant ğ’œ).toIdeal).choose

lemma homogeneous_of_mem_generating_set (a : A) (ha : a âˆˆ generating_set ğ’œ) : Homogeneous ğ’œ a :=
  (Ideal.fg_iff_homogeneously_fg _  |>.mp <|
    isNoetherianRing_iff_ideal_fg A |>.mp inferInstance
      (HomogeneousIdeal.irrelevant ğ’œ).toIdeal).choose_spec.1 a ha |>.1

lemma ne_zero_of_mem_generating_set (a : A) (ha : a âˆˆ generating_set ğ’œ) : a â‰  0 :=
  (Ideal.fg_iff_homogeneously_fg _  |>.mp <|
    isNoetherianRing_iff_ideal_fg A |>.mp inferInstance
      (HomogeneousIdeal.irrelevant ğ’œ).toIdeal).choose_spec.1 a ha |>.2

lemma irrelevant_eq_span_generating_set :
    (HomogeneousIdeal.irrelevant ğ’œ).toIdeal = Ideal.span (generating_set ğ’œ) :=
  (Ideal.fg_iff_homogeneously_fg _  |>.mp <|
    isNoetherianRing_iff_ideal_fg A |>.mp inferInstance
      (HomogeneousIdeal.irrelevant ğ’œ).toIdeal).choose_spec.2


variable {ğ’œ} in
/--
Since each element in the generating set is homogeneous, we can pick the degree of an element.
-/
noncomputable def degA : â¦ƒa : Aâ¦„ â†’ (ha : a âˆˆ generating_set ğ’œ) â†’ â„• :=
  fun _ ha â†¦ (homogeneous_of_mem_generating_set ğ’œ _ ha).choose

variable {ğ’œ} in
lemma h_degA : â¦ƒa : Aâ¦„ â†’ (ha : a âˆˆ generating_set ğ’œ) â†’ a âˆˆ ğ’œ (degA ha) :=
  fun _ ha â†¦ (homogeneous_of_mem_generating_set ğ’œ _ ha).choose_spec

lemma pos_deg_of_mem (a : A) (h1 : a âˆˆ generating_set ğ’œ) (h2 : a â‰  0) : 0 < degA h1 := by
  by_contra! rid
  simp only [nonpos_iff_eq_zero] at rid
  have m : a âˆˆ Ideal.span (generating_set ğ’œ) := Ideal.subset_span h1
  have h_deg1 := h_degA h1
  rw [rid] at h_deg1
  erw [â† irrelevant_eq_span_generating_set ğ’œ, HomogeneousIdeal.mem_irrelevant_iff,
    GradedRing.proj_apply, DirectSum.decompose_of_mem_same (hx := h_deg1)] at m
  exact h2 m

lemma algebra_eq_join : (âŠ¤ : Subalgebra (ğ’œ 0) A) = Algebra.adjoin (ğ’œ 0) (generating_set ğ’œ) := by
  classical
  let S : Finset A := generating_set ğ’œ
  let hS1 := homogeneous_of_mem_generating_set ğ’œ
  let hS2 := irrelevant_eq_span_generating_set ğ’œ
  choose deg h_deg1 using hS1
  have h_deg0 (a : A) (h1 : a âˆˆ S) (h2 : a â‰  0) : 0 < deg a h1
  Â· by_contra! rid
    simp only [nonpos_iff_eq_zero] at rid
    have m : a âˆˆ Ideal.span S := Ideal.subset_span h1
    specialize h_deg1 a h1
    rw [rid] at h_deg1
    erw [â† hS2, HomogeneousIdeal.mem_irrelevant_iff, GradedRing.proj_apply,
      DirectSum.decompose_of_mem_same (hx := h_deg1)] at m
    exact h2 m

  suffices subset (m : â„•) : (ğ’œ m : Set A) âŠ† (Algebra.adjoin (ğ’œ 0) (S : Set A))
  Â· refine le_antisymm (fun a _ â†¦ ?_) le_top
    rw [â† DirectSum.sum_support_decompose ğ’œ a]
    exact Subalgebra.sum_mem _ fun j _ â†¦ subset j <| Subtype.mem _

  suffices (n : â„•) :
    ğ’œ n.succ = â¨† (s : {s : S | deg s.1 s.2 â‰¤ n + 1 }), (s : A) â€¢ ğ’œ (n.succ - deg _ s.1.2)
  Â· cases m with | zero => ?_ | succ m => ?_
    Â· simp only [Nat.zero_eq]
      intro x hx
      show _ âˆˆ Subsemiring.closure (_ âˆª _)
      rw [Subsemiring.closure_union (Set.range <| algebraMap (ğ’œ 0) A) S]
      exact @le_sup_left (Subsemiring A) _ (Subsemiring.closure _) (Subsemiring.closure _) _ <|
        Subsemiring.subset_closure âŸ¨âŸ¨_, hxâŸ©, rflâŸ©
    induction' m using Nat.strong_induction_on with m ih
    rw [this]
    intro x hx
    simp only [SetLike.mem_coe] at hx âŠ¢
    refine AddSubgroup.iSup_induction (C := fun y â†¦ y âˆˆ Algebra.adjoin (ğ’œ 0) (S : Set A))
      (fun (s : {s : S | deg s.1 s.2 â‰¤ m + 1 }) â†¦ (s : A) â€¢ ğ’œ (m.succ - deg _ s.1.2)) hx ?_ ?_ ?_
    Â· rintro âŸ¨âŸ¨x, hx1âŸ©, (hx2 : deg _ _ â‰¤ _)âŸ© y hy1
      simp only at hy1
      rw [AddSubgroup.mem_smul_pointwise_iff_exists] at hy1
      obtain âŸ¨y, hy1, rflâŸ© := hy1
      by_cases ineq1 : x = 0
      Â· rw [ineq1, zero_smul]; exact Subalgebra.zero_mem _

      by_cases ineq0 : m < deg x hx1
      Â· have eq0 : m.succ - deg x hx1 = 0
        Â· simp only [tsub_eq_zero_iff_le]
          exact ineq0
        rw [eq0] at hy1
        refine Subalgebra.mul_mem _ (show _ âˆˆ Subsemiring.closure (_ âˆª _) from ?_)
          (show _ âˆˆ Subsemiring.closure (_ âˆª _) from ?_) <;>
        rw [Subsemiring.closure_union (Set.range <| algebraMap (ğ’œ 0) A) S]
        Â· exact @le_sup_right (Subsemiring A) _ (Subsemiring.closure _) (Subsemiring.closure _) _ <|
            Subsemiring.subset_closure hx1
        Â· exact @le_sup_left (Subsemiring A) _ (Subsemiring.closure _) (Subsemiring.closure _) _ <|
            Subsemiring.subset_closure âŸ¨âŸ¨_, hy1âŸ©, rflâŸ©
      simp only [not_lt] at ineq0
      specialize ih (m - deg _ hx1) (Nat.sub_lt_self (h_deg0 _ hx1 ineq1) ineq0) <|
        show y âˆˆ _ by
          simp only [SetLike.mem_coe]
          convert hy1 using 2
          rw [Nat.succ_sub]
          exact ineq0
      refine Subalgebra.mul_mem _ (show _ âˆˆ Subsemiring.closure (_ âˆª _) from ?_) ih
      rw [Subsemiring.closure_union (Set.range <| algebraMap (ğ’œ 0) A) S]
      exact @le_sup_right (Subsemiring A) _ (Subsemiring.closure _) (Subsemiring.closure _) _ <|
        Subsemiring.subset_closure hx1

    Â· exact Subalgebra.zero_mem _
    Â· intros _ _ h1 h2
      exact Subalgebra.add_mem _ h1 h2

  ext x; constructor
  Â· intro hx
    have m : x âˆˆ (HomogeneousIdeal.irrelevant ğ’œ).toIdeal
    Â· erw [HomogeneousIdeal.mem_irrelevant_iff, GradedRing.proj_apply,
        DirectSum.decompose_of_mem_ne (hx := hx)]
      norm_num
    erw [hS2, mem_span_set] at m
    obtain âŸ¨f, hf, (eq0 : âˆ‘ i in f.support, f i * i = x)âŸ© := m
    replace eq0 :=
      calc x
        = (DirectSum.decompose ğ’œ x (n + 1) : A) :=
          by simp only [DirectSum.of_eq_same, DirectSum.decompose_of_mem ğ’œ hx]
      _ = DirectSum.decompose ğ’œ (âˆ‘ a in f.support, f a * a) (n + 1) := by rw [eq0]
      _ = âˆ‘ a in f.support, (DirectSum.decompose ğ’œ (f a * a) (n + 1) : A) :=
          by change GradedRing.proj ğ’œ (n + 1) (âˆ‘ a in f.support, f a * a : A) = _
             rw [map_sum]
             rfl
      _ = âˆ‘ a in f.support.attach, (DirectSum.decompose ğ’œ (f a * a) (n + 1) : A) :=
          Finset.sum_attach _ _ |>.symm
      _ = âˆ‘ a in f.support.attach,
            if deg a (hf a.2) â‰¤ n + 1
            then (DirectSum.decompose ğ’œ (f a) ((n + 1) - deg a (hf a.2)) * a : A)
            else 0 := Finset.sum_congr rfl fun a _ â†¦
          DirectSum.coe_decompose_mul_of_right_mem ğ’œ (n + 1) (h_deg1 a (hf a.2)) (a := f a)

    rw [eq0]
    refine AddSubgroup.sum_mem _ fun a _ â†¦ ?_

    split_ifs with h
    Â· refine AddSubgroup.mem_iSup_of_mem âŸ¨âŸ¨a, hf a.2âŸ©, hâŸ© ?_
      rw [AddSubgroup.mem_smul_pointwise_iff_exists]
      exact âŸ¨DirectSum.decompose ğ’œ (f a) ((n + 1) - deg a (hf a.2)), SetLike.coe_mem _,
        by rw [mul_comm]; rflâŸ©
    Â· exact AddSubgroup.zero_mem _
  Â· intro hx
    refine AddSubgroup.iSup_induction (C := fun y â†¦ y âˆˆ ğ’œ n.succ)
      (fun (s : {s : S | deg s.1 s.2 â‰¤ n + 1 }) â†¦ (s : A) â€¢ ğ’œ (n.succ - deg _ s.1.2)) hx ?_ ?_ ?_
    Â· rintro âŸ¨âŸ¨x, hx1âŸ©, (hx2 : deg _ _ â‰¤ _)âŸ© z hz1
      simp only at hz1
      rw [AddSubgroup.mem_smul_pointwise_iff_exists] at hz1
      obtain âŸ¨z, hz1, rflâŸ© := hz1
      specialize h_deg1 _ hx1
      convert SetLike.mul_mem_graded h_deg1 hz1 using 2
      rw [â† Nat.add_sub_assoc, add_comm, Nat.add_sub_cancel]
      exact hx2
    Â· exact AddSubgroup.zero_mem _
    Â· intros _ _ h1 h2
      exact AddSubgroup.add_mem _ h1 h2

/--
if `f` maps `aáµ¢` to `náµ¢`
then `f` represents the monomial `âˆáµ¢ aáµ¢ ^ náµ¢`
-/
def eval_monomial (f : A â†’â‚€ â„•) : A :=
  âˆ a in f.support, a ^ (f a)

/--
suppose `f` represents the monomial `âˆáµ¢ aáµ¢ ^ náµ¢` and each `aáµ¢` has degree `dáµ¢`, then the monomial
has degree `âˆ‘áµ¢ náµ¢ * dáµ¢`
-/
def degree_monomial
    (f : A â†’â‚€ â„•)
    (deg : â¦ƒa : Aâ¦„ â†’ (ha : a âˆˆ f.support) â†’ â„•) : â„• :=
  âˆ‘ i in f.support.attach, deg i.2 * f i

lemma eval_monomial_mem_aux {Î¹ : Type*} (s : Finset Î¹)
    (deg : s â†’ â„•)
    (pow : s â†’ â„•)
    (f : s â†’ A)
    (h_deg : âˆ€ i, f i âˆˆ ğ’œ (deg i)):
    âˆ i in s.attach, f i ^ (pow i) âˆˆ ğ’œ (âˆ‘ i in s.attach, deg i * pow i) := by
  classical
  induction' s using Finset.induction_on with a s h ih
  Â· simp only [Finset.attach_empty, Finset.prod_empty, Finset.sum_empty]
    exact (SetLike.GradeZero.subring ğ’œ).one_mem
  Â· simp only [Finset.attach_insert]
    rw [Finset.prod_insert (by simpa), Finset.sum_insert (by simpa)]
    refine SetLike.mul_mem_graded ?_ ?_
    Â· rw [mul_comm, â† smul_eq_mul]
      refine SetLike.pow_mem_graded _ ?_
      exact h_deg âŸ¨a, by aesopâŸ©
    Â· simp only [Finset.mem_attach, Subtype.mk.injEq, forall_true_left, Subtype.forall, imp_self,
      implies_true, Finset.prod_image, Finset.sum_image]
      apply ih
      rintro âŸ¨i, hiâŸ©
      exact h_deg âŸ¨i, by aesopâŸ©

lemma eval_monomial_mem
    (f : A â†’â‚€ â„•)
    (deg : â¦ƒa : Aâ¦„ â†’ (ha : a âˆˆ f.support) â†’ â„•)
    (h_deg :  â¦ƒa : Aâ¦„ â†’ (ha : a âˆˆ f.support) â†’ a âˆˆ ğ’œ (deg ha)) :
    eval_monomial f âˆˆ ğ’œ (degree_monomial f deg) := by
  classical
  delta eval_monomial degree_monomial
  convert eval_monomial_mem_aux ğ’œ f.support
    (fun i â†¦ deg i.2) (fun i â†¦ f i) Subtype.val (fun âŸ¨i, hiâŸ© â†¦ h_deg hi)
  exact Finset.prod_attach _ _ |>.symm

lemma eval_monomial_homogeneous (f : A â†’â‚€ â„•) (hf : f.support âŠ† generating_set ğ’œ) :
    Homogeneous ğ’œ (eval_monomial f) := by
  let deg â¦ƒa : Aâ¦„ (ha : a âˆˆ f.support) : â„• :=
    (homogeneous_of_mem_generating_set ğ’œ _ <| hf ha).choose
  have h_deg1 â¦ƒa : Aâ¦„ (ha : a âˆˆ f.support) : a âˆˆ ğ’œ (deg ha) :=
    (homogeneous_of_mem_generating_set ğ’œ _ <| hf ha).choose_spec
  exact âŸ¨degree_monomial _ deg, eval_monomial_mem (deg := deg) (h_deg := h_deg1)âŸ©

lemma top_eq_span_monomial :
    (âŠ¤ : Submodule (ğ’œ 0) A) =
    Submodule.span (ğ’œ 0)
      {a | âˆƒ (f : A â†’â‚€ â„•), f.support âŠ† generating_set ğ’œ âˆ§ a = eval_monomial f } := by
  classical
  refine le_antisymm ?_ le_top
  rintro x -
  have hx : x âˆˆ (âŠ¤ : Subalgebra (ğ’œ 0) A) := âŸ¨âŸ©
  rw [algebra_eq_join] at hx
  refine Algebra.adjoin_induction hx ?_ ?_ ?_ ?_
  Â· intro x hx
    refine Submodule.subset_span âŸ¨Finsupp.single x 1,
      Finsupp.support_single_subset.trans (by simpa), ?_âŸ©
    Â· delta eval_monomial
      have eq1 : (Finsupp.single x 1).support = {x} :=
        le_antisymm Finsupp.support_single_subset (by simp)
      simp [eq1]
  Â· intro r
    change (r : A) âˆˆ Submodule.span (ğ’œ 0) _
    rw [show (r : A) = (r : A) â€¢ (1 : A) by rw [smul_eq_mul, mul_one]]
    exact Submodule.smul_mem _ _ <| Submodule.subset_span âŸ¨0, by simp, by simp [eval_monomial]âŸ©
  Â· intro a b ha hb
    exact Submodule.add_mem _ ha hb
  Â· intro a b ha hb
    apply Submodule.span_inductionâ‚‚ ha hb
    Â· rintro _ âŸ¨f, hf, rflâŸ© _ âŸ¨g, hg, rflâŸ©
      refine Submodule.subset_span âŸ¨(f + g : A â†’â‚€ â„•), ?_, ?_âŸ©
      Â· exact Finsupp.support_add (gâ‚ := f) (gâ‚‚ := g) |>.trans <|
          sup_le (Î± := Finset A) hf hg
      Â· simp only [eval_monomial, Finsupp.coe_add, Pi.add_apply]
        rw [Finset.prod_subset (h := hf), Finset.prod_subset (h := hg),
          Finset.prod_subset (h := (_ : (f + g).support âŠ† generating_set ğ’œ))]
        rotate_left
        Â· intro x _ hx2
          simp only [Finsupp.mem_support_iff, Finsupp.coe_add, Pi.add_apply, ne_eq, add_eq_zero,
            not_and, not_forall, not_not, exists_prop] at hx2
          rw [pow_add, hx2.1, hx2.2, pow_zero, one_mul]
        Â· exact Finsupp.support_add (gâ‚ := f) (gâ‚‚ := g) |>.trans <|
            sup_le (Î± := Finset A) hf hg
        Â· intro x _ hx2
          simp only [Finsupp.mem_support_iff, ne_eq, not_not] at hx2
          rw [hx2, pow_zero]
        Â· intro x _ hx2
          simp only [Finsupp.mem_support_iff, ne_eq, not_not] at hx2
          rw [hx2, pow_zero]

        simp_rw [pow_add]
        rw [Finset.prod_mul_distrib]
    Â· intro y
      rw [zero_mul]
      exact Submodule.zero_mem _
    Â· intro x
      rw [mul_zero]
      exact Submodule.zero_mem _
    Â· intro xâ‚ xâ‚‚ y hxâ‚ hxâ‚‚
      rw [add_mul]
      exact Submodule.add_mem _ hxâ‚ hxâ‚‚
    Â· intro x yâ‚ yâ‚‚ hyâ‚ hyâ‚‚
      rw [mul_add]
      exact Submodule.add_mem _ hyâ‚ hyâ‚‚
    Â· intro r x y h
      change ((r : A) * x) * y âˆˆ _
      rw [mul_assoc, â† smul_eq_mul]
      exact Submodule.smul_mem _ _ h
    Â· intro r x y h
      change x * ((r : A) * y) âˆˆ _
      rw [show x * (r * y) = r * (x * y) by ring, â† smul_eq_mul]
      exact Submodule.smul_mem _ _ h

end finite_algebra_over_degree_zero_subring

/--
If `A â‰… â¨áµ¢, Aáµ¢` is a noetherian graded ring, then `A` is a finite `Aâ‚€`-algebra.
-/
instance finite_algebra_over_degree_zero_subring : Algebra.FiniteType (ğ’œ 0) A := by
  constructor
  exact âŸ¨finite_algebra_over_degree_zero_subring.generating_set ğ’œ,
    finite_algebra_over_degree_zero_subring.algebra_eq_join ğ’œ |>.symmâŸ©

lemma top_eq_adjoin_finitely_many_homogeneous_elements_over_degree_zero_subring  :
    âˆƒ (S : Finset A) (_ : âˆ€ s âˆˆ S, SetLike.Homogeneous ğ’œ s),
      (Algebra.adjoin (ğ’œ 0) (S : Set A) = âŠ¤) := by
  exact âŸ¨finite_algebra_over_degree_zero_subring.generating_set ğ’œ,
    finite_algebra_over_degree_zero_subring.homogeneous_of_mem_generating_set ğ’œ,
    finite_algebra_over_degree_zero_subring.algebra_eq_join ğ’œ |>.symmâŸ©

namespace finite_module_over_degree_zero_subring

variable (A) in
/--
Since `A` is noetherian and `M` is a finite module, then `M` can be homogeneously generated by a
finite set.
-/
noncomputable def generatingSetModule : Finset M :=
  Submodule.fg_iff_homogeneously_fg (A := A) (â„³ := â„³) (p := âŠ¤) |>.mp finite_module.out |>.choose

lemma homogeneous_of_mem_generatingSetModule (m : M) (hm : m âˆˆ generatingSetModule A â„³) :
    Homogeneous â„³ m :=
  Submodule.fg_iff_homogeneously_fg (A := A) (â„³ := â„³) (p := âŠ¤) |>.mp finite_module.out
  |>.choose_spec.1 m hm |>.1

lemma generatingSetModule_span :
    (âŠ¤ : Submodule A M) = Submodule.span A (generatingSetModule A â„³) :=
  Submodule.fg_iff_homogeneously_fg (A := A) (â„³ := â„³) (p := âŠ¤) |>.mp finite_module.out
  |>.choose_spec.2


open finite_algebra_over_degree_zero_subring

variable {â„³} in
/--
Since each element in the generating set is homogeneous, we can pick a degree for each element.
-/
noncomputable def degM : (m : M) â†’ m âˆˆ generatingSetModule A â„³ â†’ â„• :=
  fun m hm â†¦ homogeneous_of_mem_generatingSetModule (A := A) â„³ m hm |>.choose

variable {â„³} in
lemma h_degM : âˆ€ (m : M) (hm : m âˆˆ generatingSetModule A â„³), m âˆˆ â„³ (degM m hm) :=
  fun m hm â†¦ homogeneous_of_mem_generatingSetModule (A := A) â„³ m hm |>.choose_spec

lemma Finset.single_le_sum' {Î¹ : Type*}
    {s : Finset Î¹} {f : s â†’ â„•} (a : s) : f a â‰¤ âˆ‘ x in s.attach, f x := by
  classical
  induction' s using Finset.induction_on with i s h ih
  Â· cases' a with a ha
    simp only [Finset.not_mem_empty] at ha
  Â· cases' a with a ha
    simp only [Finset.mem_insert] at ha

    rw [Finset.attach_insert, Finset.sum_insert (by simpa)]
    simp only [Finset.mem_attach, Subtype.mk.injEq, forall_true_left, Subtype.forall, imp_self,
      implies_true, Finset.sum_image]
    cases' ha with ha ha
    Â· subst ha
      rw [le_add_iff_nonneg_right]
      norm_num

    Â· specialize ih (f := fun x â†¦ f âŸ¨x.1, by aesopâŸ©) âŸ¨a, haâŸ©
      refine ih.trans ?_
      rw [le_add_iff_nonneg_left]
      norm_num

lemma monomial_finite_of_bounded_degree (k : â„•) :
    {p | âˆƒ (hp1 : p.support âŠ† generating_set ğ’œ),
      (degree_monomial p fun a ha â†¦ degA (hp1 ha)) â‰¤ k}.Finite := by
  let S := {p | âˆƒ (hp1 : p.support âŠ† generating_set ğ’œ),
    (degree_monomial p fun a ha â†¦ degA (hp1 ha)) â‰¤ k}
  let e : (s : S) â†’ (generating_set ğ’œ â†’ Finset.range (k + 1)) :=
    fun s a â†¦ âŸ¨s.1 a, by
      have le1 : Finset.sum _ _ â‰¤ _ := s.2.2
      dsimp only at le1
      simp only [Set.mem_setOf_eq] at le1
      by_cases mem1 : a.1 âˆˆ s.1.support
      Â· have le2 : degA (s.2.1 mem1) * s.1 a.1 â‰¤ k
        Â· refine le_trans ?_ le1
          exact Finset.single_le_sum' (s := s.1.support)
            (f := fun i â†¦ degA (s.2.1 i.2) * s.1 i.1) (a := âŸ¨a, mem1âŸ©)
        by_cases le3 : a.1 = 0
        Â· exfalso
          exact ne_zero_of_mem_generating_set ğ’œ a (s.2.1 mem1) le3
        Â· have le4 := pos_deg_of_mem ğ’œ a (s.2.1 mem1) le3
          have le5 : s.1 a.1 â‰¤ k
          Â· have := Nat.div_le_div_right (c := degA (s.2.1 mem1)) le2
            erw [mul_comm, Nat.mul_div_cancel _ le4] at this
            refine this.trans (Nat.div_le_self _ _)
          simp only [Set.mem_setOf_eq, Finset.mem_union, Finset.mem_range, Finset.mem_singleton]
          rw [Nat.lt_succ_iff]
          exact le5
      Â· simp only [Set.mem_setOf_eq, Finsupp.mem_support_iff, ne_eq, not_not] at mem1
        rw [mem1]
        aesopâŸ©
  suffices : Finite S
  Â· exact Set.toFinite _
  suffices inj : Function.Injective e
  Â· exact Finite.of_injective _ inj

  intro s1 s2 h
  ext a
  simp only [Set.coe_setOf, Set.mem_setOf_eq] at h
  by_cases mem1 : a âˆˆ s1.1.support âˆ¨ a âˆˆ s2.1.support
  Â· refine Subtype.ext_iff.mp <| congr_fun h âŸ¨a, ?_âŸ©
    rcases mem1 with mem1|mem1
    Â· exact s1.2.1 mem1
    Â· exact s2.2.1 mem1
  Â· push_neg at mem1
    simp only [Set.mem_setOf_eq, Finsupp.mem_support_iff, ne_eq, not_not] at mem1
    rw [mem1.1, mem1.2]

lemma generatingSet_is_finite (k : â„•) :
    {x : â„³ k |
      âˆƒ (Ï‰ : M) (_ : Ï‰ âˆˆ generatingSetModule A â„³)
        (p : A â†’â‚€ â„•) (hp1 : p.support âŠ† generating_set ğ’œ),
      degree_monomial p (fun a ha â†¦ degA (hp1 ha)) â‰¤ k âˆ§
      (x : M) = eval_monomial p â€¢ Ï‰ }.Finite := by
  let S := {x : â„³ k |
      âˆƒ (Ï‰ : M) (_ : Ï‰ âˆˆ generatingSetModule A â„³)
        (p : A â†’â‚€ â„•) (hp1 : p.support âŠ† generating_set ğ’œ),
      degree_monomial p (fun a ha â†¦ degA (hp1 ha)) â‰¤ k âˆ§
      (x : M) = eval_monomial p â€¢ Ï‰ }
  change S.Finite
  have eq1 := calc
      S = â‹ƒ (Ï‰ âˆˆ generatingSetModule A â„³),
            {x : â„³ k | âˆƒ (p : A â†’â‚€ â„•) (hp1 : p.support âŠ† generating_set ğ’œ),
              degree_monomial p (fun a ha â†¦ degA (hp1 ha)) â‰¤ k âˆ§
              (x : M) = eval_monomial p â€¢ Ï‰} := by ext s; simp
      _ = â‹ƒ (Ï‰ âˆˆ generatingSetModule A â„³),
          â‹ƒ (p âˆˆ {p : A â†’â‚€ â„• |
                âˆƒ (hp1 : p.support âŠ† generating_set ğ’œ),
                    degree_monomial p (fun a ha â†¦ degA (hp1 ha)) â‰¤ k}),
            {x : â„³ k | (x : M) = eval_monomial p â€¢ Ï‰} := by ext; simp
  rw [eq1]
  apply Set.Finite.biUnion' (hs := (generatingSetModule A â„³).finite_toSet)
  intro Ï‰ _
  apply Set.Finite.biUnion
  Â· apply monomial_finite_of_bounded_degree
  Â· rintro p âŸ¨_, _âŸ©
    have fin1 : Subsingleton {x : â„³ k | â†‘x = eval_monomial p â€¢ Ï‰}
    Â· constructor
      rintro âŸ¨x, (hx : _ = _)âŸ© âŸ¨y, (hy : _ = _)âŸ©
      ext
      rw [hx, hy]
    exact Set.toFinite _

set_option maxHeartbeats 400000 in
lemma kth_degree_eq_span (k : â„•) :
    (âŠ¤ : Submodule (ğ’œ 0) (â„³ k)) =
    Submodule.span (ğ’œ 0)
      {x : â„³ k |
        âˆƒ (Ï‰ : M) (_ : Ï‰ âˆˆ generatingSetModule A â„³ )
          (p : A â†’â‚€ â„•) (hp1 : p.support âŠ† generating_set ğ’œ),
        degree_monomial p (fun a ha â†¦ degA (hp1 ha)) â‰¤ k âˆ§
        (x : M) = eval_monomial p â€¢ Ï‰ } := by
  refine le_antisymm ?_ le_top
  rintro âŸ¨x, hxâŸ© -

  have mem1 : x âˆˆ (âŠ¤ : Submodule A M) := âŸ¨âŸ©
  rw [generatingSetModule_span (A := A) â„³, mem_span_set] at mem1

  obtain âŸ¨f, f_support_le, (eq0 : âˆ‘ i in f.support, (f i) â€¢ i = x)âŸ© := mem1

  have mem1 (a : A) : a âˆˆ (âŠ¤ : Submodule (ğ’œ 0) A) := âŸ¨âŸ©
  simp_rw [top_eq_span_monomial ğ’œ, mem_span_set] at mem1
  choose r hr1 hr2 using mem1
  change âˆ€ a, âˆ‘ j in (r a).support, (r a) j â€¢ j = a at hr2
  replace hr1 (a : A) : âˆ€ j âˆˆ (r a).support, âˆƒ f, f.support âŠ† generating_set ğ’œ âˆ§ j = eval_monomial f
  Â· specialize hr1 a
    exact hr1
  choose p hp1 hp2 using hr1
  replace eq0 := calc
      x = âˆ‘ i in f.support, (f i) â€¢ i := eq0.symm
      _ = âˆ‘ i in f.support, (âˆ‘ j in (r (f i)).support, r (f i) j â€¢ j) â€¢ i :=
          Finset.sum_congr rfl fun x _ â†¦ by
            congr 1
            rw [hr2 (f x)]
      _ = âˆ‘ i in f.support, âˆ‘ j in (r (f i)).support, (r (f i) j â€¢ j) â€¢ i :=
          Finset.sum_congr rfl fun x _ â†¦ Finset.sum_smul
      _ = âˆ‘ i in f.support, âˆ‘ j in (r (f i)).support, (r (f i) j : A) â€¢ (j : A) â€¢ (i : M) :=
          Finset.sum_congr rfl fun x _ â†¦ Finset.sum_congr rfl fun y _ â†¦ by
            change ((r (f x) y : A) * y) â€¢ _ = _
            rw [mul_smul]
      _ = âˆ‘ i in f.support, âˆ‘ j in (r (f i)).support.attach,
            (r (f i) j : A) â€¢ (j : A) â€¢ (i : M) :=
          Finset.sum_congr rfl fun _ _ â†¦ Finset.sum_attach _ _ |>.symm
      _ = âˆ‘ i in f.support, âˆ‘ j in (r (f i)).support.attach,
            (r (f i) j : A) â€¢ (eval_monomial (p _ _ j.2) : A) â€¢ (i : M) :=
          Finset.sum_congr rfl fun i _ â†¦ Finset.sum_congr rfl fun j _ â†¦ by
            congr 2
            exact hp2 _ _ j.2
  apply_fun GradedModule.proj â„³ k at eq0
  conv_lhs at eq0 => rw [GradedModule.proj_apply, DirectSum.decompose_of_mem_same _ hx]
  simp_rw [map_sum] at eq0
  replace eq0 := calc
    x = âˆ‘ i in f.support, âˆ‘ j in (r (f i)).support.attach,
          GradedModule.proj â„³ k ((r (f i) j : A) â€¢ (eval_monomial (p _ _ j.2) : A) â€¢ (i : M)) := eq0
    _ = âˆ‘ i in f.support, âˆ‘ j in (r (f i)).support.attach,
          GradedModule.proj â„³ k (((r (f i) j : A) * (eval_monomial (p _ _ j.2) : A)) â€¢ (i : M)) :=
        Finset.sum_congr rfl fun i _ â†¦ Finset.sum_congr rfl fun j _ â†¦ by rw [mul_smul]
    _ = âˆ‘ i in f.support.attach, âˆ‘ j in (r (f i)).support.attach,
          GradedModule.proj â„³ k (((r (f i) j : A) * (eval_monomial (p _ _ j.2) : A)) â€¢ (i : M)) :=
        Finset.sum_attach _ _ |>.symm
    _ = âˆ‘ i in f.support.attach, âˆ‘ j in (r (f i)).support.attach,
          if degM (i : M) (f_support_le i.2) â‰¤ k
          then
            GradedRing.proj ğ’œ (k - degM (i : M) (f_support_le i.2))
              ((r (f i) j : A) * (eval_monomial (p _ _ j.2) : A)) â€¢ (i : M)
          else 0 :=
        Finset.sum_congr rfl fun i _ â†¦ Finset.sum_congr rfl fun j _ â†¦ by
          rw [GradedModule.proj_smul_mem_right ğ’œ â„³ _ _ (h_degM (i : M) (f_support_le i.2))]
    _ = âˆ‘ i in f.support.attach.filter fun i : f.support â†¦ degM _ (f_support_le i.2) â‰¤ k,
        âˆ‘ j in (r (f i)).support.attach,
          GradedRing.proj ğ’œ (k - degM _ (f_support_le i.2))
            ((r (f i) j : A) * (eval_monomial (p _ _ j.2) : A)) â€¢ (i : M) := by
        rw [Finset.sum_filter]
        refine Finset.sum_congr rfl ?_
        rintro âŸ¨i, hiâŸ© -
        split_ifs with ineq1
        Â· rfl
        Â· rw [Finset.sum_const, smul_zero]
    _ = âˆ‘ i in f.support.attach.filter fun i : f.support â†¦ degM _ (f_support_le i.2) â‰¤ k,
        (âˆ‘ j in (r (f i)).support.attach,
          GradedRing.proj ğ’œ (k - degM _ (f_support_le i.2))
            ((r (f i) j : A) * (eval_monomial (p _ _ j.2) : A))) â€¢ (i : M) :=
        Finset.sum_congr rfl fun _ _ â†¦ by rw [Finset.sum_smul]
    _ = âˆ‘ i in f.support.attach.filter fun i : f.support â†¦ degM _ (f_support_le i.2) â‰¤ k,
        (âˆ‘ j in (r (f i)).support.attach,
          if degree_monomial (p _ _ j.2) (fun a ha â†¦ degA (hp1 _ _ j.2 ha)) â‰¤
              k - degM _ (f_support_le i.2)
          then
            GradedRing.proj ğ’œ
              ((k - degM _ (f_support_le i.2)) -
                degree_monomial (p _ _ j.2) fun a ha â†¦ degA (hp1 _ _ j.2 ha))
              (r (f i) j : A) * (eval_monomial (p _ _ j.2) : A)
          else 0) â€¢ (i : M) := by
        refine Finset.sum_congr rfl ?_
        rintro âŸ¨i, hi1âŸ© _
        congr 1
        refine Finset.sum_congr rfl ?_
        rintro âŸ¨j, hjâŸ© -
        rw [proj_apply, DirectSum.coe_decompose_mul_of_right_mem ğ’œ]
        pick_goal 2
        Â· apply eval_monomial_mem ğ’œ (p _ _ hj) (fun a ha â†¦ degA (hp1 _ _ hj ha))
          rintro a ha
          apply h_degA (hp1 _ _ hj ha)
        rfl
    _ = âˆ‘ i in f.support.attach.filter fun i : f.support â†¦ degM _ (f_support_le i.2) â‰¤ k,
        (âˆ‘ j in (r (f i)).support.attach.filter
          fun j : (r (f i)).support â†¦
            degree_monomial (p _ _ j.2) (fun a ha â†¦ degA (hp1 _ _ j.2 ha)) â‰¤
            k - degM _ (f_support_le i.2),
          GradedRing.proj ğ’œ
              ((k - degM _ (f_support_le i.2)) -
                degree_monomial (p _ _ j.2) fun a ha â†¦ degA (hp1 _ _ j.2 ha))
              (r (f i) j : A) * (eval_monomial (p _ _ j.2) : A)) â€¢ (i : M) :=
        Finset.sum_congr rfl fun _ _ â†¦ by rw [Finset.sum_filter]
    _ = âˆ‘ i in f.support.attach.filter fun i : f.support â†¦ degM _ (f_support_le i.2) â‰¤ k,
        âˆ‘ j in (r (f i)).support.attach.filter
          fun j : (r (f i)).support â†¦
            degree_monomial (p _ _ j.2) (fun a ha â†¦ degA (hp1 _ _ j.2 ha)) â‰¤
            k - degM _ (f_support_le i.2),
          (GradedRing.proj ğ’œ
              ((k - degM _ (f_support_le i.2)) -
                degree_monomial (p _ _ j.2) fun a ha â†¦ degA (hp1 _ _ j.2 ha))
              (r (f i) j : A) * (eval_monomial (p _ _ j.2) : A)) â€¢ (i : M) :=
        Finset.sum_congr rfl fun _ _ â†¦ by rw [Finset.sum_smul]
    _ = âˆ‘ i in f.support.attach.filter fun i : f.support â†¦ degM _ (f_support_le i.2) â‰¤ k,
        âˆ‘ j in (r (f i)).support.attach.filter
          fun j : (r (f i)).support â†¦
            degree_monomial (p _ _ j.2) (fun a ha â†¦ degA (hp1 _ _ j.2 ha)) â‰¤
            k - degM _ (f_support_le i.2),
          (GradedRing.proj ğ’œ
              ((k - degM _ (f_support_le i.2)) -
                degree_monomial (p _ _ j.2) fun a ha â†¦ degA (hp1 _ _ j.2 ha))
              (r (f i) j : A)) â€¢ (eval_monomial (p _ _ j.2) : A) â€¢ (i : M) :=
        Finset.sum_congr rfl fun _ _ â†¦ Finset.sum_congr rfl fun _ _ â†¦ by rw [mul_smul]
    _ = âˆ‘ i in f.support.attach.filter fun i : f.support â†¦ degM _ (f_support_le i.2) â‰¤ k,
        âˆ‘ j in (r (f i)).support.attach.filter
          fun j : (r (f i)).support â†¦
            degree_monomial (p _ _ j.2) (fun a ha â†¦ degA (hp1 _ _ j.2 ha)) â‰¤
            k - degM _ (f_support_le i.2),
          (if degree_monomial (p _ _ j.2) (fun a ha â†¦ degA (hp1 _ _ j.2 ha)) =
              k - degM _ (f_support_le i.2)
            then (r (f i) j : A)
            else 0) â€¢ (eval_monomial (p _ _ j.2) : A) â€¢ (i : M) :=
        Finset.sum_congr rfl fun i _ â†¦ Finset.sum_congr rfl fun j hj â†¦ by
          congr 1
          split_ifs with ineq1
          Â· rw [ineq1, Nat.sub_self, proj_apply, DirectSum.decompose_of_mem_same]
            exact SetLike.coe_mem _
          Â· rw [proj_apply, DirectSum.decompose_of_mem_ne (hx := SetLike.coe_mem _)]
            intro rid
            rw [eq_comm, Nat.sub_eq_zero_iff_le] at rid
            rw [Finset.mem_filter] at hj
            exact ineq1 <| le_antisymm hj.2 rid
    _ = âˆ‘ i in f.support.attach.filter fun i : f.support â†¦ degM _ (f_support_le i.2) â‰¤ k,
        âˆ‘ j in (r (f i)).support.attach.filter
          fun j : (r (f i)).support â†¦
            degree_monomial (p _ _ j.2) (fun a ha â†¦ degA (hp1 _ _ j.2 ha)) =
            k - degM _ (f_support_le i.2),
          (r (f i) j : A) â€¢ (eval_monomial (p _ _ j.2) : A) â€¢ (i : M) := by
        refine Finset.sum_congr rfl ?_
        rintro âŸ¨i, hi1âŸ© _
        rw [Finset.sum_filter, Finset.sum_filter]
        refine Finset.sum_congr rfl ?_
        rintro âŸ¨h, hj1âŸ© -
        simp only [ite_smul, zero_smul, ite_eq_left_iff, not_le]
        intro rid
        rw [if_neg (Ne.symm (ne_of_lt rid))]
    _ = âˆ‘ i in (f.support.attach.filter fun i : f.support â†¦ degM _ (f_support_le i.2) â‰¤ k).attach,
        âˆ‘ j in (r (f i)).support.attach.filter
          fun j : (r (f i)).support â†¦
            degree_monomial (p _ _ j.2) (fun a ha â†¦ degA (hp1 _ _ j.2 ha)) =
            k - degM _ (f_support_le i.1.2),
          (r (f i) j : A) â€¢ (eval_monomial (p _ _ j.2) : A) â€¢ (i : M) :=
        Finset.sum_attach _ _ |>.symm
    _ = âˆ‘ i in (f.support.attach.filter fun i : f.support â†¦ degM _ (f_support_le i.2) â‰¤ k).attach,
        âˆ‘ j in ((r (f i)).support.attach.filter
          fun j : (r (f i)).support â†¦
            degree_monomial (p _ _ j.2) (fun a ha â†¦ degA (hp1 _ _ j.2 ha)) =
            k - degM _ (f_support_le i.1.2)).attach,
          (r (f i) j : A) â€¢ (eval_monomial (p _ _ j.1.2) : A) â€¢ (i : M) :=
        Finset.sum_congr rfl fun _ _ â†¦ Finset.sum_attach _ _ |>.symm

  replace eq0 :
    (âŸ¨x, hxâŸ© : â„³ k) =
    âˆ‘ i in (f.support.attach.filter fun i : f.support â†¦ degM _ (f_support_le i.2) â‰¤ k).attach,
        âˆ‘ j in ((r (f i)).support.attach.filter
          fun j : (r (f i)).support â†¦
            degree_monomial (p _ _ j.2) (fun a ha â†¦ degA (hp1 _ _ j.2 ha)) =
            k - degM _ (f_support_le i.1.2)).attach,
          r (f i) j â€¢ (âŸ¨(eval_monomial (p _ _ j.1.2) : A) â€¢ (i : M), by
            have mem1 := eval_monomial_mem ğ’œ (p _ _ j.1.2) (fun a ha â†¦ degA (hp1 _ _ j.1.2 ha))
              (fun a ha â†¦ h_degA (hp1 _ _ j.1.2 ha))
            have mem2 := h_degM _ (f_support_le i.1.2)
            convert (inferInstance : SetLike.GradedSMul ğ’œ â„³).smul_mem mem1 mem2
            have mem3 := j.2
            simp only [Finset.filter_congr_decidable, Finset.mem_filter, Finset.mem_attach,
              true_and] at mem3
            rw [mem3, vadd_eq_add, Nat.sub_add_cancel]
            simpa using i.2âŸ© : â„³ k)
  Â· ext
    refine eq0.trans ?_
    rw [AddSubgroup.val_finset_sum]
    refine Finset.sum_congr rfl ?_
    rintro âŸ¨j, hj1âŸ© -
    rw [AddSubgroup.val_finset_sum]
    rfl

  rw [eq0]
  refine Submodule.sum_mem _ ?_
  rintro âŸ¨âŸ¨i, hi1âŸ©, hi2âŸ© -
  simp only [Finset.mem_filter, Finset.mem_attach, true_and] at hi2
  refine Submodule.sum_mem _ ?_
  rintro âŸ¨âŸ¨j, hj1âŸ©, hj2âŸ© -
  simp only [Finset.filter_congr_decidable, Finset.mem_filter, Finset.mem_attach, true_and] at hj2
  refine Submodule.smul_mem _ _ <| Submodule.subset_span
    âŸ¨i, f_support_le hi1, p _ _ hj1, hp1 _ _ hj1, ?_, rflâŸ©

  rw [hj2]
  exact Nat.sub_le _ _

end finite_module_over_degree_zero_subring

open finite_module_over_degree_zero_subring finite_algebra_over_degree_zero_subring in
instance (k : â„•) : Module.Finite (ğ’œ 0) (â„³ k) :=
  âŸ¨Set.Finite.toFinset (generatingSet_is_finite ğ’œ â„³ k),
    by simpa only [Set.Finite.coe_toFinset] using (kth_degree_eq_span ğ’œ â„³ k).symmâŸ©

end CommRing

end GradedRing
