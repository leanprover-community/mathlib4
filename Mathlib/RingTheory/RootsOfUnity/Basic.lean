/-
Copyright (c) 2020 Johan Commelin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin
-/
import Mathlib.Algebra.CharP.Two
import Mathlib.Algebra.NeZero
import Mathlib.Algebra.GCDMonoid.IntegrallyClosed
import Mathlib.Data.Polynomial.RingDivision
import Mathlib.FieldTheory.Finite.Basic
import Mathlib.FieldTheory.Separable
import Mathlib.GroupTheory.SpecificGroups.Cyclic
import Mathlib.NumberTheory.Divisors
import Mathlib.RingTheory.IntegralDomain
import Mathlib.Tactic.Zify

#align_import ring_theory.roots_of_unity.basic from "leanprover-community/mathlib"@"7fdeecc0d03cd40f7a165e6cf00a4d2286db599f"

/-!
# Roots of unity and primitive roots of unity

We define roots of unity in the context of an arbitrary commutative monoid,
as a subgroup of the group of units. We also define a predicate `IsPrimitiveRoot` on commutative
monoids, expressing that an element is a primitive root of unity.

## Main definitions

* `rootsOfUnity n M`, for `n : ‚Ñï+` is the subgroup of the units of a commutative monoid `M`
  consisting of elements `x` that satisfy `x ^ n = 1`.
* `IsPrimitiveRoot Œ∂ k`: an element `Œ∂` is a primitive `k`-th root of unity if `Œ∂ ^ k = 1`,
  and if `l` satisfies `Œ∂ ^ l = 1` then `k ‚à£ l`.
* `primitiveRoots k R`: the finset of primitive `k`-th roots of unity in an integral domain `R`.
* `IsPrimitiveRoot.autToPow`: the monoid hom that takes an automorphism of a ring to the power
  it sends that specific primitive root, as a member of `(ZMod n)À£`.

## Main results

* `rootsOfUnity.isCyclic`: the roots of unity in an integral domain form a cyclic group.
* `IsPrimitiveRoot.zmodEquivZpowers`: `ZMod k` is equivalent to
  the subgroup generated by a primitive `k`-th root of unity.
* `IsPrimitiveRoot.zpowers_eq`: in an integral domain, the subgroup generated by
  a primitive `k`-th root of unity is equal to the `k`-th roots of unity.
* `IsPrimitiveRoot.card_primitiveRoots`: if an integral domain
   has a primitive `k`-th root of unity, then it has `œÜ k` of them.

## Implementation details

It is desirable that `rootsOfUnity` is a subgroup,
and it will mainly be applied to rings (e.g. the ring of integers in a number field) and fields.
We therefore implement it as a subgroup of the units of a commutative monoid.

We have chosen to define `rootsOfUnity n` for `n : ‚Ñï+`, instead of `n : ‚Ñï`,
because almost all lemmas need the positivity assumption,
and in particular the type class instances for `Fintype` and `IsCyclic`.

On the other hand, for primitive roots of unity, it is desirable to have a predicate
not just on units, but directly on elements of the ring/field.
For example, we want to say that `exp (2 * pi * I / n)` is a primitive `n`-th root of unity
in the complex numbers, without having to turn that number into a unit first.

This creates a little bit of friction, but lemmas like `IsPrimitiveRoot.isUnit` and
`IsPrimitiveRoot.coe_units_iff` should provide the necessary glue.

-/


open scoped Classical BigOperators Polynomial

noncomputable section

open Polynomial

open Finset

variable {M N G R S F : Type*}

variable [CommMonoid M] [CommMonoid N] [DivisionCommMonoid G]

section rootsOfUnity

variable {k l : ‚Ñï+}

/-- `rootsOfUnity k M` is the subgroup of elements `m : MÀ£` that satisfy `m ^ k = 1`. -/
def rootsOfUnity (k : ‚Ñï+) (M : Type*) [CommMonoid M] : Subgroup MÀ£ where
  carrier := {Œ∂ | Œ∂ ^ (k : ‚Ñï) = 1}
  one_mem' := one_pow _
  mul_mem' _ _ := by simp_all only [Set.mem_setOf_eq, mul_pow, one_mul]
                     -- üéâ no goals
  inv_mem' _ := by simp_all only [Set.mem_setOf_eq, inv_pow, inv_one]
                   -- üéâ no goals
#align roots_of_unity rootsOfUnity

@[simp]
theorem mem_rootsOfUnity (k : ‚Ñï+) (Œ∂ : MÀ£) : Œ∂ ‚àà rootsOfUnity k M ‚Üî Œ∂ ^ (k : ‚Ñï) = 1 :=
  Iff.rfl
#align mem_roots_of_unity mem_rootsOfUnity

theorem mem_rootsOfUnity' (k : ‚Ñï+) (Œ∂ : MÀ£) : Œ∂ ‚àà rootsOfUnity k M ‚Üî (Œ∂ : M) ^ (k : ‚Ñï) = 1 := by
  rw [mem_rootsOfUnity]; norm_cast
  -- ‚ä¢ Œ∂ ^ ‚Üëk = 1 ‚Üî ‚ÜëŒ∂ ^ ‚Üëk = 1
                         -- üéâ no goals
#align mem_roots_of_unity' mem_rootsOfUnity'

theorem rootsOfUnity.coe_injective {n : ‚Ñï+} :
    Function.Injective (fun x : rootsOfUnity n M ‚Ü¶ x.val.val) :=
  Units.ext.comp fun _ _ => Subtype.eq
#align roots_of_unity.coe_injective rootsOfUnity.coe_injective

/-- Make an element of `rootsOfUnity` from a member of the base ring, and a proof that it has
a positive power equal to one. -/
@[simps! coe_val]
def rootsOfUnity.mkOfPowEq (Œ∂ : M) {n : ‚Ñï+} (h : Œ∂ ^ (n : ‚Ñï) = 1) : rootsOfUnity n M :=
  ‚ü®Units.ofPowEqOne Œ∂ n h n.ne_zero, Units.pow_ofPowEqOne _ _‚ü©
#align roots_of_unity.mk_of_pow_eq rootsOfUnity.mkOfPowEq
#align roots_of_unity.mk_of_pow_eq_coe_coe rootsOfUnity.val_mkOfPowEq_coe

@[simp]
theorem rootsOfUnity.coe_mkOfPowEq {Œ∂ : M} {n : ‚Ñï+} (h : Œ∂ ^ (n : ‚Ñï) = 1) :
    ((rootsOfUnity.mkOfPowEq _ h : MÀ£) : M) = Œ∂ :=
  rfl
#align roots_of_unity.coe_mk_of_pow_eq rootsOfUnity.coe_mkOfPowEq

theorem rootsOfUnity_le_of_dvd (h : k ‚à£ l) : rootsOfUnity k M ‚â§ rootsOfUnity l M := by
  obtain ‚ü®d, rfl‚ü© := h
  -- ‚ä¢ rootsOfUnity k M ‚â§ rootsOfUnity (k * d) M
  intro Œ∂ h
  -- ‚ä¢ Œ∂ ‚àà rootsOfUnity (k * d) M
  simp_all only [mem_rootsOfUnity, PNat.mul_coe, pow_mul, one_pow]
  -- üéâ no goals
#align roots_of_unity_le_of_dvd rootsOfUnity_le_of_dvd

theorem map_rootsOfUnity (f : MÀ£ ‚Üí* NÀ£) (k : ‚Ñï+) : (rootsOfUnity k M).map f ‚â§ rootsOfUnity k N := by
  rintro _ ‚ü®Œ∂, h, rfl‚ü©
  -- ‚ä¢ ‚Üëf Œ∂ ‚àà rootsOfUnity k N
  simp_all only [‚Üê map_pow, mem_rootsOfUnity, SetLike.mem_coe, MonoidHom.map_one]
  -- üéâ no goals
#align map_roots_of_unity map_rootsOfUnity

@[norm_cast]
theorem rootsOfUnity.coe_pow [CommMonoid R] (Œ∂ : rootsOfUnity k R) (m : ‚Ñï) :
    ((Œ∂ ^ m : RÀ£) : R) = ((Œ∂ : RÀ£) : R) ^ m := by
  rw [Subgroup.coe_pow, Units.val_pow_eq_pow_val]
  -- üéâ no goals
#align roots_of_unity.coe_pow rootsOfUnity.coe_pow

section CommSemiring

variable [CommSemiring R] [CommSemiring S]

/-- Restrict a ring homomorphism to the nth roots of unity. -/
def restrictRootsOfUnity [RingHomClass F R S] (œÉ : F) (n : ‚Ñï+) :
    rootsOfUnity n R ‚Üí* rootsOfUnity n S :=
  let h : ‚àÄ Œæ : rootsOfUnity n R, (œÉ (Œæ : RÀ£)) ^ (n : ‚Ñï) = 1 := fun Œæ => by
    rw [‚Üê map_pow, ‚Üê Units.val_pow_eq_pow_val, show (Œæ : RÀ£) ^ (n : ‚Ñï) = 1 from Œæ.2, Units.val_one,
      map_one œÉ]
  { toFun := fun Œæ =>
      ‚ü®@unitOfInvertible _ _ _ (invertibleOfPowEqOne _ _ (h Œæ) n.ne_zero), by
        ext; rw [Units.val_pow_eq_pow_val]; exact h Œæ‚ü©
        -- ‚ä¢ ‚Üë(unitOfInvertible (‚ÜëœÉ ‚Üë‚ÜëŒæ) ^ ‚Üën) = ‚Üë1
             -- ‚ä¢ ‚Üë(unitOfInvertible (‚ÜëœÉ ‚Üë‚ÜëŒæ)) ^ ‚Üën = ‚Üë1
                                            -- üéâ no goals
    map_one' := by ext; exact map_one œÉ
                   -- ‚ä¢ ‚Üë‚Üë((fun Œæ => { val := unitOfInvertible (‚ÜëœÉ ‚Üë‚ÜëŒæ), property := (_ : unitOfInve ‚Ä¶
                        -- üéâ no goals
    map_mul' := fun Œæ‚ÇÅ Œæ‚ÇÇ => by ext; rw [Subgroup.coe_mul, Units.val_mul]; exact map_mul œÉ _ _ }
                                -- ‚ä¢ ‚Üë‚Üë(OneHom.toFun { toFun := fun Œæ => { val := unitOfInvertible (‚ÜëœÉ ‚Üë‚ÜëŒæ), prop ‚Ä¶
                                     -- ‚ä¢ ‚Üë‚Üë(OneHom.toFun { toFun := fun Œæ => { val := unitOfInvertible (‚ÜëœÉ ‚Üë‚ÜëŒæ), prop ‚Ä¶
                                                                           -- üéâ no goals
#align restrict_roots_of_unity restrictRootsOfUnity

@[simp]
theorem restrictRootsOfUnity_coe_apply [RingHomClass F R S] (œÉ : F) (Œ∂ : rootsOfUnity k R) :
    (restrictRootsOfUnity œÉ k Œ∂ : SÀ£) = œÉ (Œ∂ : RÀ£) :=
  rfl
#align restrict_roots_of_unity_coe_apply restrictRootsOfUnity_coe_apply

/-- Restrict a ring isomorphism to the nth roots of unity. -/
nonrec def RingEquiv.restrictRootsOfUnity (œÉ : R ‚âÉ+* S) (n : ‚Ñï+) :
    rootsOfUnity n R ‚âÉ* rootsOfUnity n S where
  toFun := restrictRootsOfUnity œÉ.toRingHom n
  invFun := restrictRootsOfUnity œÉ.symm.toRingHom n
  left_inv Œæ := by ext; exact œÉ.symm_apply_apply (Œæ : RÀ£)
                   -- ‚ä¢ ‚Üë‚Üë(‚Üë(_root_.restrictRootsOfUnity (toRingHom (RingEquiv.symm œÉ)) n) (‚Üë(_root_ ‚Ä¶
                        -- üéâ no goals
  right_inv Œæ := by ext; exact œÉ.apply_symm_apply (Œæ : SÀ£)
                    -- ‚ä¢ ‚Üë‚Üë(‚Üë(_root_.restrictRootsOfUnity (toRingHom œÉ) n) (‚Üë(_root_.restrictRootsOfU ‚Ä¶
                         -- üéâ no goals
  map_mul' := (restrictRootsOfUnity _ n).map_mul
#align ring_equiv.restrict_roots_of_unity RingEquiv.restrictRootsOfUnity

@[simp]
theorem RingEquiv.restrictRootsOfUnity_coe_apply (œÉ : R ‚âÉ+* S) (Œ∂ : rootsOfUnity k R) :
    (œÉ.restrictRootsOfUnity k Œ∂ : SÀ£) = œÉ (Œ∂ : RÀ£) :=
  rfl
#align ring_equiv.restrict_roots_of_unity_coe_apply RingEquiv.restrictRootsOfUnity_coe_apply

@[simp]
theorem RingEquiv.restrictRootsOfUnity_symm (œÉ : R ‚âÉ+* S) :
    (œÉ.restrictRootsOfUnity k).symm = œÉ.symm.restrictRootsOfUnity k :=
  rfl
#align ring_equiv.restrict_roots_of_unity_symm RingEquiv.restrictRootsOfUnity_symm

end CommSemiring

section IsDomain

variable [CommRing R] [IsDomain R]

theorem mem_rootsOfUnity_iff_mem_nthRoots {Œ∂ : RÀ£} :
    Œ∂ ‚àà rootsOfUnity k R ‚Üî (Œ∂ : R) ‚àà nthRoots k (1 : R) := by
  simp only [mem_rootsOfUnity, mem_nthRoots k.pos, Units.ext_iff, Units.val_one,
    Units.val_pow_eq_pow_val]
#align mem_roots_of_unity_iff_mem_nth_roots mem_rootsOfUnity_iff_mem_nthRoots

variable (k R)

/-- Equivalence between the `k`-th roots of unity in `R` and the `k`-th roots of `1`.

This is implemented as equivalence of subtypes,
because `rootsOfUnity` is a subgroup of the group of units,
whereas `nthRoots` is a multiset. -/
def rootsOfUnityEquivNthRoots : rootsOfUnity k R ‚âÉ { x // x ‚àà nthRoots k (1 : R) } := by
  refine'
    { toFun := fun x => ‚ü®(x : RÀ£), mem_rootsOfUnity_iff_mem_nthRoots.mp x.2‚ü©
      invFun := fun x => ‚ü®‚ü®x, ‚Üëx ^ (k - 1 : ‚Ñï), _, _‚ü©, _‚ü©
      left_inv := _
      right_inv := _ }
  pick_goal 4; ¬∑ rintro ‚ü®x, hx‚ü©; ext; rfl
                 -- ‚ä¢ (fun x => { val := { val := ‚Üëx, inv := ‚Üëx ^ (‚Üëk - 1), val_inv := (_ : ‚Üëx * ? ‚Ä¶
                                 -- ‚ä¢ ‚Üë‚Üë((fun x => { val := { val := ‚Üëx, inv := ‚Üëx ^ (‚Üëk - 1), val_inv := (_ : ‚Üëx  ‚Ä¶
                                      -- üéâ no goals
  pick_goal 4; ¬∑ rintro ‚ü®x, hx‚ü©; ext; rfl
                 -- ‚ä¢ (fun x => { val := ‚Üë‚Üëx, property := (_ : ‚Üë‚Üëx ‚àà nthRoots (‚Üëk) 1) }) ((fun x = ‚Ä¶
                                 -- ‚ä¢ ‚Üë((fun x => { val := ‚Üë‚Üëx, property := (_ : ‚Üë‚Üëx ‚àà nthRoots (‚Üëk) 1) }) ((fun x ‚Ä¶
                                      -- üéâ no goals
  all_goals
    rcases x with ‚ü®x, hx‚ü©; rw [mem_nthRoots k.pos] at hx
    simp only [Subtype.coe_mk, ‚Üê pow_succ, ‚Üê pow_succ', hx,
      tsub_add_cancel_of_le (show 1 ‚â§ (k : ‚Ñï) from k.one_le)]
  ¬∑ show (_ : RÀ£) ^ (k : ‚Ñï) = 1
    -- ‚ä¢ { val := x, inv := x ^ (‚Üëk - 1), val_inv := (_ : ‚Üë{ val := x, property := hx ‚Ä¶
    simp only [Units.ext_iff, hx, Units.val_mk, Units.val_one, Subtype.coe_mk,
      Units.val_pow_eq_pow_val]
#align roots_of_unity_equiv_nth_roots rootsOfUnityEquivNthRoots

variable {k R}

@[simp]
theorem rootsOfUnityEquivNthRoots_apply (x : rootsOfUnity k R) :
    (rootsOfUnityEquivNthRoots R k x : R) = ((x : RÀ£) : R) :=
  rfl
#align roots_of_unity_equiv_nth_roots_apply rootsOfUnityEquivNthRoots_apply

@[simp]
theorem rootsOfUnityEquivNthRoots_symm_apply (x : { x // x ‚àà nthRoots k (1 : R) }) :
    (((rootsOfUnityEquivNthRoots R k).symm x : RÀ£) : R) = (x : R) :=
  rfl
#align roots_of_unity_equiv_nth_roots_symm_apply rootsOfUnityEquivNthRoots_symm_apply

variable (k R)

instance rootsOfUnity.fintype : Fintype (rootsOfUnity k R) :=
  Fintype.ofEquiv { x // x ‚àà nthRoots k (1 : R) } <| (rootsOfUnityEquivNthRoots R k).symm
#align roots_of_unity.fintype rootsOfUnity.fintype

instance rootsOfUnity.isCyclic : IsCyclic (rootsOfUnity k R) :=
  isCyclic_of_subgroup_isDomain ((Units.coeHom R).comp (rootsOfUnity k R).subtype)
    (Units.ext.comp Subtype.val_injective)
#align roots_of_unity.is_cyclic rootsOfUnity.isCyclic

theorem card_rootsOfUnity : Fintype.card (rootsOfUnity k R) ‚â§ k :=
  calc
    Fintype.card (rootsOfUnity k R) = Fintype.card { x // x ‚àà nthRoots k (1 : R) } :=
      Fintype.card_congr (rootsOfUnityEquivNthRoots R k)
    _ ‚â§ Multiset.card (nthRoots k (1 : R)).attach := (Multiset.card_le_of_le (Multiset.dedup_le _))
    _ = Multiset.card (nthRoots k (1 : R)) := Multiset.card_attach
    _ ‚â§ k := card_nthRoots k 1
#align card_roots_of_unity card_rootsOfUnity

variable {k R}

theorem map_rootsOfUnity_eq_pow_self [RingHomClass F R R] (œÉ : F) (Œ∂ : rootsOfUnity k R) :
    ‚àÉ m : ‚Ñï, œÉ (Œ∂ : RÀ£) = ((Œ∂ : RÀ£) : R) ^ m := by
  obtain ‚ü®m, hm‚ü© := MonoidHom.map_cyclic (restrictRootsOfUnity œÉ k)
  -- ‚ä¢ ‚àÉ m, ‚ÜëœÉ ‚Üë‚ÜëŒ∂ = ‚Üë‚ÜëŒ∂ ^ m
  rw [‚Üê restrictRootsOfUnity_coe_apply, hm, zpow_eq_mod_orderOf, ‚Üê Int.toNat_of_nonneg
      (m.emod_nonneg (Int.coe_nat_ne_zero.mpr (pos_iff_ne_zero.mp (orderOf_pos Œ∂)))),
    zpow_ofNat, rootsOfUnity.coe_pow]
  exact ‚ü®(m % orderOf Œ∂).toNat, rfl‚ü©
  -- üéâ no goals
#align map_root_of_unity_eq_pow_self map_rootsOfUnity_eq_pow_self

end IsDomain

section Reduced

variable (R) [CommRing R] [IsReduced R]

local macro_rules | `($x ^ $y) => `(HPow.hPow $x $y) -- Porting note: See issue lean4#2220

-- @[simp] -- Porting note: simp normal form is `mem_rootsOfUnity_prime_pow_mul_iff'`
theorem mem_rootsOfUnity_prime_pow_mul_iff (p k : ‚Ñï) (m : ‚Ñï+) [hp : Fact p.Prime] [CharP R p]
    {Œ∂ : RÀ£} : Œ∂ ‚àà rootsOfUnity (‚ü®p, hp.1.pos‚ü© ^ k * m) R ‚Üî Œ∂ ‚àà rootsOfUnity m R := by
  simp only [mem_rootsOfUnity', PNat.mul_coe, PNat.pow_coe, PNat.mk_coe,
    CharP.pow_prime_pow_mul_eq_one_iff]
#align mem_roots_of_unity_prime_pow_mul_iff mem_rootsOfUnity_prime_pow_mul_iff

@[simp]
theorem mem_rootsOfUnity_prime_pow_mul_iff' (p k : ‚Ñï) (m : ‚Ñï+) [hp : Fact p.Prime] [CharP R p]
    {Œ∂ : RÀ£} : Œ∂ ^ (p ^ k * ‚Üëm) = 1 ‚Üî Œ∂ ‚àà rootsOfUnity m R := by
  rw [‚Üê PNat.mk_coe p hp.1.pos, ‚Üê PNat.pow_coe, ‚Üê PNat.mul_coe, ‚Üê mem_rootsOfUnity,
    mem_rootsOfUnity_prime_pow_mul_iff]

end Reduced

end rootsOfUnity

/-- An element `Œ∂` is a primitive `k`-th root of unity if `Œ∂ ^ k = 1`,
and if `l` satisfies `Œ∂ ^ l = 1` then `k ‚à£ l`. -/
structure IsPrimitiveRoot (Œ∂ : M) (k : ‚Ñï) : Prop where
  pow_eq_one : Œ∂ ^ (k : ‚Ñï) = 1
  dvd_of_pow_eq_one : ‚àÄ l : ‚Ñï, Œ∂ ^ l = 1 ‚Üí k ‚à£ l
#align is_primitive_root IsPrimitiveRoot

/-- Turn a primitive root Œº into a member of the `rootsOfUnity` subgroup. -/
@[simps!]
def IsPrimitiveRoot.toRootsOfUnity {Œº : M} {n : ‚Ñï+} (h : IsPrimitiveRoot Œº n) : rootsOfUnity n M :=
  rootsOfUnity.mkOfPowEq Œº h.pow_eq_one
#align is_primitive_root.to_roots_of_unity IsPrimitiveRoot.toRootsOfUnity
#align is_primitive_root.coe_to_roots_of_unity_coe IsPrimitiveRoot.val_toRootsOfUnity_coe
#align is_primitive_root.coe_inv_to_roots_of_unity_coe IsPrimitiveRoot.val_inv_toRootsOfUnity_coe

section primitiveRoots

variable {k : ‚Ñï}

/-- `primitiveRoots k R` is the finset of primitive `k`-th roots of unity
in the integral domain `R`. -/
def primitiveRoots (k : ‚Ñï) (R : Type*) [CommRing R] [IsDomain R] : Finset R :=
  (nthRoots k (1 : R)).toFinset.filter fun Œ∂ => IsPrimitiveRoot Œ∂ k
#align primitive_roots primitiveRoots

variable [CommRing R] [IsDomain R]

@[simp]
theorem mem_primitiveRoots {Œ∂ : R} (h0 : 0 < k) : Œ∂ ‚àà primitiveRoots k R ‚Üî IsPrimitiveRoot Œ∂ k := by
  rw [primitiveRoots, mem_filter, Multiset.mem_toFinset, mem_nthRoots h0, and_iff_right_iff_imp]
  -- ‚ä¢ IsPrimitiveRoot Œ∂ k ‚Üí Œ∂ ^ k = 1
  exact IsPrimitiveRoot.pow_eq_one
  -- üéâ no goals
#align mem_primitive_roots mem_primitiveRoots

@[simp]
theorem primitiveRoots_zero : primitiveRoots 0 R = ‚àÖ := by
  rw [primitiveRoots, nthRoots_zero, Multiset.toFinset_zero, Finset.filter_empty]
  -- üéâ no goals
#align primitive_roots_zero primitiveRoots_zero

theorem isPrimitiveRoot_of_mem_primitiveRoots {Œ∂ : R} (h : Œ∂ ‚àà primitiveRoots k R) :
    IsPrimitiveRoot Œ∂ k :=
  k.eq_zero_or_pos.elim (fun hk => by simp [hk] at h) fun hk => (mem_primitiveRoots hk).1 h
                                      -- üéâ no goals
#align is_primitive_root_of_mem_primitive_roots isPrimitiveRoot_of_mem_primitiveRoots

end primitiveRoots

namespace IsPrimitiveRoot

variable {k l : ‚Ñï}

theorem iff_def (Œ∂ : M) (k : ‚Ñï) : IsPrimitiveRoot Œ∂ k ‚Üî Œ∂ ^ k = 1 ‚àß ‚àÄ l : ‚Ñï, Œ∂ ^ l = 1 ‚Üí k ‚à£ l :=
  ‚ü®fun ‚ü®h1, h2‚ü© => ‚ü®h1, h2‚ü©, fun ‚ü®h1, h2‚ü© => ‚ü®h1, h2‚ü©‚ü©
#align is_primitive_root.iff_def IsPrimitiveRoot.iff_def

theorem mk_of_lt (Œ∂ : M) (hk : 0 < k) (h1 : Œ∂ ^ k = 1) (h : ‚àÄ l : ‚Ñï, 0 < l ‚Üí l < k ‚Üí Œ∂ ^ l ‚â† 1) :
    IsPrimitiveRoot Œ∂ k := by
  refine' ‚ü®h1, fun l hl => _‚ü©
  -- ‚ä¢ k ‚à£ l
  suffices k.gcd l = k by exact this ‚ñ∏ k.gcd_dvd_right l
  -- ‚ä¢ Nat.gcd k l = k
  rw [eq_iff_le_not_lt]
  -- ‚ä¢ Nat.gcd k l ‚â§ k ‚àß ¬¨Nat.gcd k l < k
  refine' ‚ü®Nat.le_of_dvd hk (k.gcd_dvd_left l), _‚ü©
  -- ‚ä¢ ¬¨Nat.gcd k l < k
  intro h'; apply h _ (Nat.gcd_pos_of_pos_left _ hk) h'
  -- ‚ä¢ False
            -- ‚ä¢ Œ∂ ^ Nat.gcd k l = 1
  exact pow_gcd_eq_one _ h1 hl
  -- üéâ no goals
#align is_primitive_root.mk_of_lt IsPrimitiveRoot.mk_of_lt

section CommMonoid

variable {Œ∂ : M} {f : F} (h : IsPrimitiveRoot Œ∂ k)

@[nontriviality]
theorem of_subsingleton [Subsingleton M] (x : M) : IsPrimitiveRoot x 1 :=
  ‚ü®Subsingleton.elim _ _, fun _ _ => one_dvd _‚ü©
#align is_primitive_root.of_subsingleton IsPrimitiveRoot.of_subsingleton

theorem pow_eq_one_iff_dvd (l : ‚Ñï) : Œ∂ ^ l = 1 ‚Üî k ‚à£ l :=
  ‚ü®h.dvd_of_pow_eq_one l, by
    rintro ‚ü®i, rfl‚ü©; simp only [pow_mul, h.pow_eq_one, one_pow, PNat.mul_coe]‚ü©
    -- ‚ä¢ Œ∂ ^ (k * i) = 1
                     -- üéâ no goals
#align is_primitive_root.pow_eq_one_iff_dvd IsPrimitiveRoot.pow_eq_one_iff_dvd

theorem isUnit (h : IsPrimitiveRoot Œ∂ k) (h0 : 0 < k) : IsUnit Œ∂ := by
  apply isUnit_of_mul_eq_one Œ∂ (Œ∂ ^ (k - 1))
  -- ‚ä¢ Œ∂ * Œ∂ ^ (k - 1) = 1
  rw [‚Üê pow_succ, tsub_add_cancel_of_le h0.nat_succ_le, h.pow_eq_one]
  -- üéâ no goals
#align is_primitive_root.is_unit IsPrimitiveRoot.isUnit

theorem pow_ne_one_of_pos_of_lt (h0 : 0 < l) (hl : l < k) : Œ∂ ^ l ‚â† 1 :=
  mt (Nat.le_of_dvd h0 ‚àò h.dvd_of_pow_eq_one _) <| not_le_of_lt hl
#align is_primitive_root.pow_ne_one_of_pos_of_lt IsPrimitiveRoot.pow_ne_one_of_pos_of_lt

theorem ne_one (hk : 1 < k) : Œ∂ ‚â† 1 :=
  h.pow_ne_one_of_pos_of_lt zero_lt_one hk ‚àò (pow_one Œ∂).trans
#align is_primitive_root.ne_one IsPrimitiveRoot.ne_one

theorem pow_inj (h : IsPrimitiveRoot Œ∂ k) ‚¶Éi j : ‚Ñï‚¶Ñ (hi : i < k) (hj : j < k) (H : Œ∂ ^ i = Œ∂ ^ j) :
    i = j := by
  wlog hij : i ‚â§ j generalizing i j
  -- ‚ä¢ i = j
  ¬∑ exact (this hj hi H.symm (le_of_not_le hij)).symm
    -- üéâ no goals
  apply le_antisymm hij
  -- ‚ä¢ j ‚â§ i
  rw [‚Üê tsub_eq_zero_iff_le]
  -- ‚ä¢ j - i = 0
  apply Nat.eq_zero_of_dvd_of_lt _ (lt_of_le_of_lt tsub_le_self hj)
  -- ‚ä¢ k ‚à£ j - i
  apply h.dvd_of_pow_eq_one
  -- ‚ä¢ Œ∂ ^ (j - i) = 1
  rw [‚Üê ((h.isUnit (lt_of_le_of_lt (Nat.zero_le _) hi)).pow i).mul_left_inj, ‚Üê pow_add,
    tsub_add_cancel_of_le hij, H, one_mul]
#align is_primitive_root.pow_inj IsPrimitiveRoot.pow_inj

theorem one : IsPrimitiveRoot (1 : M) 1 :=
  { pow_eq_one := pow_one _
    dvd_of_pow_eq_one := fun _ _ => one_dvd _ }
#align is_primitive_root.one IsPrimitiveRoot.one

@[simp]
theorem one_right_iff : IsPrimitiveRoot Œ∂ 1 ‚Üî Œ∂ = 1 := by
  clear h
  -- ‚ä¢ IsPrimitiveRoot Œ∂ 1 ‚Üî Œ∂ = 1
  constructor
  -- ‚ä¢ IsPrimitiveRoot Œ∂ 1 ‚Üí Œ∂ = 1
  ¬∑ intro h; rw [‚Üê pow_one Œ∂, h.pow_eq_one]
    -- ‚ä¢ Œ∂ = 1
             -- üéâ no goals
  ¬∑ rintro rfl; exact one
    -- ‚ä¢ IsPrimitiveRoot 1 1
                -- üéâ no goals
#align is_primitive_root.one_right_iff IsPrimitiveRoot.one_right_iff

@[simp]
theorem coe_submonoidClass_iff {M B : Type*} [CommMonoid M] [SetLike B M] [SubmonoidClass B M]
    {N : B} {Œ∂ : N} : IsPrimitiveRoot (Œ∂ : M) k ‚Üî IsPrimitiveRoot Œ∂ k := by
  simp_rw [iff_def]
  -- ‚ä¢ (‚ÜëŒ∂ ^ k = 1 ‚àß ‚àÄ (l : ‚Ñï), ‚ÜëŒ∂ ^ l = 1 ‚Üí k ‚à£ l) ‚Üî Œ∂ ^ k = 1 ‚àß ‚àÄ (l : ‚Ñï), Œ∂ ^ l  ‚Ä¶
  norm_cast
  -- üéâ no goals
#align is_primitive_root.coe_submonoid_class_iff IsPrimitiveRoot.coe_submonoidClass_iff

@[simp]
theorem coe_units_iff {Œ∂ : MÀ£} : IsPrimitiveRoot (Œ∂ : M) k ‚Üî IsPrimitiveRoot Œ∂ k := by
  simp only [iff_def, Units.ext_iff, Units.val_pow_eq_pow_val, Units.val_one]
  -- üéâ no goals
#align is_primitive_root.coe_units_iff IsPrimitiveRoot.coe_units_iff

-- Porting note `variable` above already contains `(h : IsPrimitiveRoot Œ∂ k)`
theorem pow_of_coprime (i : ‚Ñï) (hi : i.coprime k) : IsPrimitiveRoot (Œ∂ ^ i) k := by
  by_cases h0 : k = 0
  -- ‚ä¢ IsPrimitiveRoot (Œ∂ ^ i) k
  ¬∑ subst k; simp_all only [pow_one, Nat.coprime_zero_right]
    -- ‚ä¢ IsPrimitiveRoot (Œ∂ ^ i) 0
             -- üéâ no goals
  rcases h.isUnit (Nat.pos_of_ne_zero h0) with ‚ü®Œ∂, rfl‚ü©
  -- ‚ä¢ IsPrimitiveRoot (‚ÜëŒ∂ ^ i) k
  rw [‚Üê Units.val_pow_eq_pow_val]
  -- ‚ä¢ IsPrimitiveRoot (‚Üë(Œ∂ ^ i)) k
  rw [coe_units_iff] at h ‚ä¢
  -- ‚ä¢ IsPrimitiveRoot (Œ∂ ^ i) k
  refine'
    { pow_eq_one := by rw [‚Üê pow_mul', pow_mul, h.pow_eq_one, one_pow]
      dvd_of_pow_eq_one := _ }
  intro l hl
  -- ‚ä¢ k ‚à£ l
  apply h.dvd_of_pow_eq_one
  -- ‚ä¢ Œ∂ ^ l = 1
  rw [‚Üê pow_one Œ∂, ‚Üê zpow_ofNat Œ∂, ‚Üê hi.gcd_eq_one, Nat.gcd_eq_gcd_ab, zpow_add, mul_pow,
    ‚Üê zpow_ofNat, ‚Üê zpow_mul, mul_right_comm]
  simp only [zpow_mul, hl, h.pow_eq_one, one_zpow, one_pow, one_mul, zpow_ofNat]
  -- üéâ no goals
#align is_primitive_root.pow_of_coprime IsPrimitiveRoot.pow_of_coprime

theorem pow_of_prime (h : IsPrimitiveRoot Œ∂ k) {p : ‚Ñï} (hprime : Nat.Prime p) (hdiv : ¬¨p ‚à£ k) :
    IsPrimitiveRoot (Œ∂ ^ p) k :=
  h.pow_of_coprime p (hprime.coprime_iff_not_dvd.2 hdiv)
#align is_primitive_root.pow_of_prime IsPrimitiveRoot.pow_of_prime

theorem pow_iff_coprime (h : IsPrimitiveRoot Œ∂ k) (h0 : 0 < k) (i : ‚Ñï) :
    IsPrimitiveRoot (Œ∂ ^ i) k ‚Üî i.coprime k := by
  refine' ‚ü®_, h.pow_of_coprime i‚ü©
  -- ‚ä¢ IsPrimitiveRoot (Œ∂ ^ i) k ‚Üí Nat.coprime i k
  intro hi
  -- ‚ä¢ Nat.coprime i k
  obtain ‚ü®a, ha‚ü© := i.gcd_dvd_left k
  -- ‚ä¢ Nat.coprime i k
  obtain ‚ü®b, hb‚ü© := i.gcd_dvd_right k
  -- ‚ä¢ Nat.coprime i k
  suffices b = k by
    -- Porting note: was `rwa [this, ‚Üê one_mul k, mul_left_inj' h0.ne', eq_comm] at hb`
    rw [this, eq_comm, Nat.mul_left_eq_self_iff h0] at hb
    rwa [Nat.coprime]
  rw [ha] at hi
  -- ‚ä¢ b = k
  rw [mul_comm] at hb
  -- ‚ä¢ b = k
  apply Nat.dvd_antisymm ‚ü®i.gcd k, hb‚ü© (hi.dvd_of_pow_eq_one b _)
  -- ‚ä¢ (Œ∂ ^ (Nat.gcd i k * a)) ^ b = 1
  rw [‚Üê pow_mul', ‚Üê mul_assoc, ‚Üê hb, pow_mul, h.pow_eq_one, one_pow]
  -- üéâ no goals
#align is_primitive_root.pow_iff_coprime IsPrimitiveRoot.pow_iff_coprime

protected theorem orderOf (Œ∂ : M) : IsPrimitiveRoot Œ∂ (orderOf Œ∂) :=
  ‚ü®pow_orderOf_eq_one Œ∂, fun _ => orderOf_dvd_of_pow_eq_one‚ü©
#align is_primitive_root.order_of IsPrimitiveRoot.orderOf

theorem unique {Œ∂ : M} (hk : IsPrimitiveRoot Œ∂ k) (hl : IsPrimitiveRoot Œ∂ l) : k = l :=
  Nat.dvd_antisymm (hk.2 _ hl.1) (hl.2 _ hk.1)
#align is_primitive_root.unique IsPrimitiveRoot.unique

theorem eq_orderOf : k = orderOf Œ∂ :=
  h.unique (IsPrimitiveRoot.orderOf Œ∂)
#align is_primitive_root.eq_order_of IsPrimitiveRoot.eq_orderOf

protected theorem iff (hk : 0 < k) :
    IsPrimitiveRoot Œ∂ k ‚Üî Œ∂ ^ k = 1 ‚àß ‚àÄ l : ‚Ñï, 0 < l ‚Üí l < k ‚Üí Œ∂ ^ l ‚â† 1 := by
  refine' ‚ü®fun h => ‚ü®h.pow_eq_one, fun l hl' hl => _‚ü©,
    fun ‚ü®hŒ∂, hl‚ü© => IsPrimitiveRoot.mk_of_lt Œ∂ hk hŒ∂ hl‚ü©
  rw [h.eq_orderOf] at hl
  -- ‚ä¢ Œ∂ ^ l ‚â† 1
  exact pow_ne_one_of_lt_orderOf' hl'.ne' hl
  -- üéâ no goals
#align is_primitive_root.iff IsPrimitiveRoot.iff

protected theorem not_iff : ¬¨IsPrimitiveRoot Œ∂ k ‚Üî orderOf Œ∂ ‚â† k :=
  ‚ü®fun h hk => h <| hk ‚ñ∏ IsPrimitiveRoot.orderOf Œ∂,
    fun h hk => h.symm <| hk.unique <| IsPrimitiveRoot.orderOf Œ∂‚ü©
#align is_primitive_root.not_iff IsPrimitiveRoot.not_iff

theorem pow_of_dvd (h : IsPrimitiveRoot Œ∂ k) {p : ‚Ñï} (hp : p ‚â† 0) (hdiv : p ‚à£ k) :
    IsPrimitiveRoot (Œ∂ ^ p) (k / p) := by
  suffices orderOf (Œ∂ ^ p) = k / p by exact this ‚ñ∏ IsPrimitiveRoot.orderOf (Œ∂ ^ p)
  -- ‚ä¢ orderOf (Œ∂ ^ p) = k / p
  rw [orderOf_pow' _ hp, ‚Üê eq_orderOf h, Nat.gcd_eq_right hdiv]
  -- üéâ no goals
#align is_primitive_root.pow_of_dvd IsPrimitiveRoot.pow_of_dvd

protected theorem mem_rootsOfUnity {Œ∂ : MÀ£} {n : ‚Ñï+} (h : IsPrimitiveRoot Œ∂ n) :
    Œ∂ ‚àà rootsOfUnity n M :=
  h.pow_eq_one
#align is_primitive_root.mem_roots_of_unity IsPrimitiveRoot.mem_rootsOfUnity

/-- If there is an `n`-th primitive root of unity in `R` and `b` divides `n`,
then there is a `b`-th primitive root of unity in `R`. -/
theorem pow {n : ‚Ñï} {a b : ‚Ñï} (hn : 0 < n) (h : IsPrimitiveRoot Œ∂ n) (hprod : n = a * b) :
    IsPrimitiveRoot (Œ∂ ^ a) b := by
  subst n
  -- ‚ä¢ IsPrimitiveRoot (Œ∂ ^ a) b
  simp only [iff_def, ‚Üê pow_mul, h.pow_eq_one, eq_self_iff_true, true_and_iff]
  -- ‚ä¢ ‚àÄ (l : ‚Ñï), Œ∂ ^ (a * l) = 1 ‚Üí b ‚à£ l
  intro l hl
  -- ‚ä¢ b ‚à£ l
  -- Porting note: was `by rintro rfl; simpa only [Nat.not_lt_zero, zero_mul] using hn`
  have ha0 : a ‚â† 0 := left_ne_zero_of_mul hn.ne'
  -- ‚ä¢ b ‚à£ l
  rw [‚Üê mul_dvd_mul_iff_left ha0]
  -- ‚ä¢ a * b ‚à£ a * l
  exact h.dvd_of_pow_eq_one _ hl
  -- üéâ no goals
#align is_primitive_root.pow IsPrimitiveRoot.pow

section Maps

open Function

theorem map_of_injective [MonoidHomClass F M N] (h : IsPrimitiveRoot Œ∂ k) (hf : Injective f) :
    IsPrimitiveRoot (f Œ∂) k where
  pow_eq_one := by rw [‚Üê map_pow, h.pow_eq_one, _root_.map_one]
                   -- üéâ no goals
  dvd_of_pow_eq_one := by
    rw [h.eq_orderOf]
    -- ‚ä¢ ‚àÄ (l : ‚Ñï), ‚Üëf Œ∂ ^ l = 1 ‚Üí orderOf Œ∂ ‚à£ l
    intro l hl
    -- ‚ä¢ orderOf Œ∂ ‚à£ l
    rw [‚Üê map_pow, ‚Üê map_one f] at hl
    -- ‚ä¢ orderOf Œ∂ ‚à£ l
    exact orderOf_dvd_of_pow_eq_one (hf hl)
    -- üéâ no goals
#align is_primitive_root.map_of_injective IsPrimitiveRoot.map_of_injective

theorem of_map_of_injective [MonoidHomClass F M N] (h : IsPrimitiveRoot (f Œ∂) k)
    (hf : Injective f) : IsPrimitiveRoot Œ∂ k where
  pow_eq_one := by apply_fun f; rw [map_pow, _root_.map_one, h.pow_eq_one]
                   -- ‚ä¢ ‚Üëf (Œ∂ ^ k) = ‚Üëf 1
                                -- üéâ no goals
  dvd_of_pow_eq_one := by
    rw [h.eq_orderOf]
    -- ‚ä¢ ‚àÄ (l : ‚Ñï), Œ∂ ^ l = 1 ‚Üí orderOf (‚Üëf Œ∂) ‚à£ l
    intro l hl
    -- ‚ä¢ orderOf (‚Üëf Œ∂) ‚à£ l
    apply_fun f at hl
    -- ‚ä¢ orderOf (‚Üëf Œ∂) ‚à£ l
    rw [map_pow, _root_.map_one] at hl
    -- ‚ä¢ orderOf (‚Üëf Œ∂) ‚à£ l
    exact orderOf_dvd_of_pow_eq_one hl
    -- üéâ no goals
#align is_primitive_root.of_map_of_injective IsPrimitiveRoot.of_map_of_injective

theorem map_iff_of_injective [MonoidHomClass F M N] (hf : Injective f) :
    IsPrimitiveRoot (f Œ∂) k ‚Üî IsPrimitiveRoot Œ∂ k :=
  ‚ü®fun h => h.of_map_of_injective hf, fun h => h.map_of_injective hf‚ü©
#align is_primitive_root.map_iff_of_injective IsPrimitiveRoot.map_iff_of_injective

end Maps

end CommMonoid

section CommMonoidWithZero

variable {M‚ÇÄ : Type*} [CommMonoidWithZero M‚ÇÄ]

theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : M‚ÇÄ) 0 :=
  ‚ü®pow_zero 0, fun l hl => by
    simpa [zero_pow_eq, show ‚àÄ p, ¬¨p ‚Üí False ‚Üî p from @Classical.not_not] using hl‚ü©
    -- üéâ no goals
#align is_primitive_root.zero IsPrimitiveRoot.zero

protected theorem ne_zero [Nontrivial M‚ÇÄ] {Œ∂ : M‚ÇÄ} (h : IsPrimitiveRoot Œ∂ k) : k ‚â† 0 ‚Üí Œ∂ ‚â† 0 :=
  mt fun hn => h.unique (hn.symm ‚ñ∏ IsPrimitiveRoot.zero)
#align is_primitive_root.ne_zero IsPrimitiveRoot.ne_zero

end CommMonoidWithZero

section DivisionCommMonoid

variable {Œ∂ : G}

theorem zpow_eq_one (h : IsPrimitiveRoot Œ∂ k) : Œ∂ ^ (k : ‚Ñ§) = 1 := by
  rw [zpow_ofNat]; exact h.pow_eq_one
  -- ‚ä¢ Œ∂ ^ k = 1
                   -- üéâ no goals
#align is_primitive_root.zpow_eq_one IsPrimitiveRoot.zpow_eq_one

theorem zpow_eq_one_iff_dvd (h : IsPrimitiveRoot Œ∂ k) (l : ‚Ñ§) : Œ∂ ^ l = 1 ‚Üî (k : ‚Ñ§) ‚à£ l := by
  by_cases h0 : 0 ‚â§ l
  -- ‚ä¢ Œ∂ ^ l = 1 ‚Üî ‚Üëk ‚à£ l
  ¬∑ lift l to ‚Ñï using h0; rw [zpow_ofNat]; norm_cast; exact h.pow_eq_one_iff_dvd l
    -- ‚ä¢ Œ∂ ^ ‚Üël = 1 ‚Üî ‚Üëk ‚à£ ‚Üël
                          -- ‚ä¢ Œ∂ ^ l = 1 ‚Üî ‚Üëk ‚à£ ‚Üël
                                           -- ‚ä¢ Œ∂ ^ l = 1 ‚Üî k ‚à£ l
                                                      -- üéâ no goals
  ¬∑ have : 0 ‚â§ -l := by simp only [not_le, neg_nonneg] at h0 ‚ä¢; exact le_of_lt h0
    -- ‚ä¢ Œ∂ ^ l = 1 ‚Üî ‚Üëk ‚à£ l
    lift -l to ‚Ñï using this with l' hl'
    -- ‚ä¢ Œ∂ ^ l = 1 ‚Üî ‚Üëk ‚à£ l
    rw [‚Üê dvd_neg, ‚Üê hl']
    -- ‚ä¢ Œ∂ ^ l = 1 ‚Üî ‚Üëk ‚à£ ‚Üël'
    norm_cast
    -- ‚ä¢ Œ∂ ^ l = 1 ‚Üî k ‚à£ l'
    rw [‚Üê h.pow_eq_one_iff_dvd, ‚Üê inv_inj, ‚Üê zpow_neg, ‚Üê hl', zpow_ofNat, inv_one]
    -- üéâ no goals
#align is_primitive_root.zpow_eq_one_iff_dvd IsPrimitiveRoot.zpow_eq_one_iff_dvd

theorem inv (h : IsPrimitiveRoot Œ∂ k) : IsPrimitiveRoot Œ∂‚Åª¬π k :=
  { pow_eq_one := by simp only [h.pow_eq_one, inv_one, eq_self_iff_true, inv_pow]
                     -- üéâ no goals
    dvd_of_pow_eq_one := by
      intro l hl
      -- ‚ä¢ k ‚à£ l
      apply h.dvd_of_pow_eq_one l
      -- ‚ä¢ Œ∂ ^ l = 1
      rw [‚Üê inv_inj, ‚Üê inv_pow, hl, inv_one] }
      -- üéâ no goals
#align is_primitive_root.inv IsPrimitiveRoot.inv

@[simp]
theorem inv_iff : IsPrimitiveRoot Œ∂‚Åª¬π k ‚Üî IsPrimitiveRoot Œ∂ k := by
  refine' ‚ü®_, fun h => inv h‚ü©; intro h; rw [‚Üê inv_inv Œ∂]; exact inv h
  -- ‚ä¢ IsPrimitiveRoot Œ∂‚Åª¬π k ‚Üí IsPrimitiveRoot Œ∂ k
                               -- ‚ä¢ IsPrimitiveRoot Œ∂ k
                                        -- ‚ä¢ IsPrimitiveRoot Œ∂‚Åª¬π‚Åª¬π k
                                                          -- üéâ no goals
#align is_primitive_root.inv_iff IsPrimitiveRoot.inv_iff

theorem zpow_of_gcd_eq_one (h : IsPrimitiveRoot Œ∂ k) (i : ‚Ñ§) (hi : i.gcd k = 1) :
    IsPrimitiveRoot (Œ∂ ^ i) k := by
  by_cases h0 : 0 ‚â§ i
  -- ‚ä¢ IsPrimitiveRoot (Œ∂ ^ i) k
  ¬∑ lift i to ‚Ñï using h0
    -- ‚ä¢ IsPrimitiveRoot (Œ∂ ^ ‚Üëi) k
    rw [zpow_ofNat]
    -- ‚ä¢ IsPrimitiveRoot (Œ∂ ^ i) k
    exact h.pow_of_coprime i hi
    -- üéâ no goals
  have : 0 ‚â§ -i := by simp only [not_le, neg_nonneg] at h0 ‚ä¢; exact le_of_lt h0
  -- ‚ä¢ IsPrimitiveRoot (Œ∂ ^ i) k
  lift -i to ‚Ñï using this with i' hi'
  -- ‚ä¢ IsPrimitiveRoot (Œ∂ ^ i) k
  rw [‚Üê inv_iff, ‚Üê zpow_neg, ‚Üê hi', zpow_ofNat]
  -- ‚ä¢ IsPrimitiveRoot (Œ∂ ^ i') k
  apply h.pow_of_coprime
  -- ‚ä¢ Nat.coprime i' k
  rw [Int.gcd, ‚Üê Int.natAbs_neg, ‚Üê hi'] at hi
  -- ‚ä¢ Nat.coprime i' k
  exact hi
  -- üéâ no goals
#align is_primitive_root.zpow_of_gcd_eq_one IsPrimitiveRoot.zpow_of_gcd_eq_one

end DivisionCommMonoid

section IsDomain

variable {Œ∂ : R}

variable [CommRing R] [IsDomain R]

@[simp]
theorem primitiveRoots_one : primitiveRoots 1 R = {(1 : R)} := by
  apply Finset.eq_singleton_iff_unique_mem.2
  -- ‚ä¢ 1 ‚àà primitiveRoots 1 R ‚àß ‚àÄ (x : R), x ‚àà primitiveRoots 1 R ‚Üí x = 1
  constructor
  -- ‚ä¢ 1 ‚àà primitiveRoots 1 R
  ¬∑ simp only [IsPrimitiveRoot.one_right_iff, mem_primitiveRoots zero_lt_one]
    -- üéâ no goals
  ¬∑ intro x hx
    -- ‚ä¢ x = 1
    rw [mem_primitiveRoots zero_lt_one, IsPrimitiveRoot.one_right_iff] at hx
    -- ‚ä¢ x = 1
    exact hx
    -- üéâ no goals
#align is_primitive_root.primitive_roots_one IsPrimitiveRoot.primitiveRoots_one

theorem neZero' {n : ‚Ñï+} (hŒ∂ : IsPrimitiveRoot Œ∂ n) : NeZero ((n : ‚Ñï) : R) := by
  let p := ringChar R
  -- ‚ä¢ NeZero ‚Üë‚Üën
  have hfin := multiplicity.finite_nat_iff.2 ‚ü®CharP.char_ne_one R p, n.pos‚ü©
  -- ‚ä¢ NeZero ‚Üë‚Üën
  obtain ‚ü®m, hm‚ü© := multiplicity.exists_eq_pow_mul_and_not_dvd hfin
  -- ‚ä¢ NeZero ‚Üë‚Üën
  by_cases hp : p ‚à£ n
  -- ‚ä¢ NeZero ‚Üë‚Üën
  ¬∑ obtain ‚ü®k, hk‚ü© := Nat.exists_eq_succ_of_ne_zero (multiplicity.pos_of_dvd hfin hp).ne'
    -- ‚ä¢ NeZero ‚Üë‚Üën
    haveI : NeZero p := NeZero.of_pos (Nat.pos_of_dvd_of_pos hp n.pos)
    -- ‚ä¢ NeZero ‚Üë‚Üën
    haveI hpri : Fact p.Prime := CharP.char_is_prime_of_pos R p
    -- ‚ä¢ NeZero ‚Üë‚Üën
    have := hŒ∂.pow_eq_one
    -- ‚ä¢ NeZero ‚Üë‚Üën
    rw [hm.1, hk, pow_succ, mul_assoc, pow_mul', ‚Üê frobenius_def, ‚Üê frobenius_one p] at this
    -- ‚ä¢ NeZero ‚Üë‚Üën
    exfalso
    -- ‚ä¢ False
    have hpos : 0 < p ^ k * m := by
      refine' mul_pos (pow_pos hpri.1.pos _) (Nat.pos_of_ne_zero fun h => _)
      have H := hm.1
      rw [h] at H
      simp at H
    refine' hŒ∂.pow_ne_one_of_pos_of_lt hpos _ (frobenius_inj R p this)
    -- ‚ä¢ p ^ k * m < ‚Üën
    ¬∑ rw [hm.1, hk, pow_succ, mul_assoc, mul_comm p]
      -- ‚ä¢ p ^ k * m < p ^ k * m * p
      exact lt_mul_of_one_lt_right hpos hpri.1.one_lt
      -- üéâ no goals
  ¬∑ exact NeZero.of_not_dvd R hp
    -- üéâ no goals
#align is_primitive_root.ne_zero' IsPrimitiveRoot.neZero'

nonrec theorem mem_nthRootsFinset (hŒ∂ : IsPrimitiveRoot Œ∂ k) (hk : 0 < k) :
    Œ∂ ‚àà nthRootsFinset k R :=
  (mem_nthRootsFinset hk).2 hŒ∂.pow_eq_one
#align is_primitive_root.mem_nth_roots_finset IsPrimitiveRoot.mem_nthRootsFinset

end IsDomain

section IsDomain

variable [CommRing R]

variable {Œ∂ : RÀ£} (h : IsPrimitiveRoot Œ∂ k)

theorem eq_neg_one_of_two_right [NoZeroDivisors R] {Œ∂ : R} (h : IsPrimitiveRoot Œ∂ 2) : Œ∂ = -1 := by
  apply (eq_or_eq_neg_of_sq_eq_sq Œ∂ 1 _).resolve_left
  -- ‚ä¢ ¬¨Œ∂ = 1
  ¬∑ rw [‚Üê pow_one Œ∂]; apply h.pow_ne_one_of_pos_of_lt <;> decide
    -- ‚ä¢ ¬¨Œ∂ ^ 1 = 1
                      -- ‚ä¢ 0 < 1
                                                          -- üéâ no goals
                                                          -- üéâ no goals
  ¬∑ simp only [h.pow_eq_one, one_pow]
    -- üéâ no goals
#align is_primitive_root.eq_neg_one_of_two_right IsPrimitiveRoot.eq_neg_one_of_two_right

theorem neg_one (p : ‚Ñï) [Nontrivial R] [h : CharP R p] (hp : p ‚â† 2) :
    IsPrimitiveRoot (-1 : R) 2 := by
  convert IsPrimitiveRoot.orderOf (-1 : R)
  -- ‚ä¢ 2 = orderOf (-1)
  rw [orderOf_neg_one, if_neg]
  -- ‚ä¢ ¬¨ringChar R = 2
  rwa [ringChar.eq_iff.mpr h]
  -- üéâ no goals
#align is_primitive_root.neg_one IsPrimitiveRoot.neg_one

/-- If `1 < k` then `(‚àë i in range k, Œ∂ ^ i) = 0`. -/
theorem geom_sum_eq_zero [IsDomain R] {Œ∂ : R} (hŒ∂ : IsPrimitiveRoot Œ∂ k) (hk : 1 < k) :
    ‚àë i in range k, Œ∂ ^ i = 0 := by
  refine' eq_zero_of_ne_zero_of_mul_left_eq_zero (sub_ne_zero_of_ne (hŒ∂.ne_one hk).symm) _
  -- ‚ä¢ (1 - Œ∂) * ‚àë i in range k, Œ∂ ^ i = 0
  rw [mul_neg_geom_sum, hŒ∂.pow_eq_one, sub_self]
  -- üéâ no goals
#align is_primitive_root.geom_sum_eq_zero IsPrimitiveRoot.geom_sum_eq_zero

/-- If `1 < k`, then `Œ∂ ^ k.pred = -(‚àë i in range k.pred, Œ∂ ^ i)`. -/
theorem pow_sub_one_eq [IsDomain R] {Œ∂ : R} (hŒ∂ : IsPrimitiveRoot Œ∂ k) (hk : 1 < k) :
    Œ∂ ^ k.pred = -‚àë i in range k.pred, Œ∂ ^ i := by
  rw [eq_neg_iff_add_eq_zero, add_comm, ‚Üê sum_range_succ, ‚Üê Nat.succ_eq_add_one,
    Nat.succ_pred_eq_of_pos (pos_of_gt hk), hŒ∂.geom_sum_eq_zero hk]
#align is_primitive_root.pow_sub_one_eq IsPrimitiveRoot.pow_sub_one_eq

/-- The (additive) monoid equivalence between `ZMod k`
and the powers of a primitive root of unity `Œ∂`. -/
def zmodEquivZpowers (h : IsPrimitiveRoot Œ∂ k) : ZMod k ‚âÉ+ Additive (Subgroup.zpowers Œ∂) :=
  AddEquiv.ofBijective
    (AddMonoidHom.liftOfRightInverse (Int.castAddHom <| ZMod k) _ ZMod.int_cast_rightInverse
      ‚ü®{  toFun := fun i => Additive.ofMul (‚ü®_, i, rfl‚ü© : Subgroup.zpowers Œ∂)
          map_zero' := by simp only [zpow_zero]; rfl
                          -- ‚ä¢ ‚ÜëAdditive.ofMul { val := 1, property := (_ : (fun x => x ‚àà Subgroup.zpowers  ‚Ä¶
                                                 -- üéâ no goals
          map_add' := by intro i j; simp only [zpow_add]; rfl }, fun i hi => by
                         -- ‚ä¢ ZeroHom.toFun { toFun := fun i => ‚ÜëAdditive.ofMul { val := (fun x x_1 => x ^ ‚Ä¶
                                    -- ‚ä¢ ‚ÜëAdditive.ofMul { val := Œ∂ ^ i * Œ∂ ^ j, property := (_ : (fun x => x ‚àà Subgr ‚Ä¶
                                                          -- üéâ no goals
        simp only [AddMonoidHom.mem_ker, CharP.int_cast_eq_zero_iff (ZMod k) k, AddMonoidHom.coe_mk,
          Int.coe_castAddHom] at hi ‚ä¢
        obtain ‚ü®i, rfl‚ü© := hi
        -- ‚ä¢ ‚Üë{ toFun := fun i => ‚ÜëAdditive.ofMul { val := Œ∂ ^ i, property := (_ : ‚àÉ y, ( ‚Ä¶
        simp [zpow_mul, h.pow_eq_one, one_zpow, zpow_ofNat]‚ü©)
        -- üéâ no goals
    (by
      constructor
      -- ‚ä¢ Function.Injective ‚Üë(‚Üë(AddMonoidHom.liftOfRightInverse (Int.castAddHom (ZMod ‚Ä¶
      ¬∑ rw [injective_iff_map_eq_zero]
        -- ‚ä¢ ‚àÄ (a : ZMod k), ‚Üë(‚Üë(AddMonoidHom.liftOfRightInverse (Int.castAddHom (ZMod k) ‚Ä¶
        intro i hi
        -- ‚ä¢ i = 0
        rw [Subtype.ext_iff] at hi
        -- ‚ä¢ i = 0
        have := (h.zpow_eq_one_iff_dvd _).mp hi
        -- ‚ä¢ i = 0
        rw [‚Üê (CharP.int_cast_eq_zero_iff (ZMod k) k _).mpr this, eq_comm]
        -- ‚ä¢ ‚Üë‚Üëi = i
        exact ZMod.int_cast_rightInverse i
        -- üéâ no goals
      ¬∑ rintro ‚ü®Œæ, i, rfl‚ü©
        -- ‚ä¢ ‚àÉ a, ‚Üë(‚Üë(AddMonoidHom.liftOfRightInverse (Int.castAddHom (ZMod k)) ZMod.cast ‚Ä¶
        refine' ‚ü®Int.castAddHom (ZMod k) i, _‚ü©
        -- ‚ä¢ ‚Üë(‚Üë(AddMonoidHom.liftOfRightInverse (Int.castAddHom (ZMod k)) ZMod.cast (_ : ‚Ä¶
        rw [AddMonoidHom.liftOfRightInverse_comp_apply]
        -- ‚ä¢ ‚Üë‚Üë{ val := { toZeroHom := { toFun := fun i => ‚ÜëAdditive.ofMul { val := (fun  ‚Ä¶
        rfl)
        -- üéâ no goals
#align is_primitive_root.zmod_equiv_zpowers IsPrimitiveRoot.zmodEquivZpowers

@[simp]
theorem zmodEquivZpowers_apply_coe_int (i : ‚Ñ§) :
    h.zmodEquivZpowers i = Additive.ofMul (‚ü®Œ∂ ^ i, i, rfl‚ü© : Subgroup.zpowers Œ∂) := by
  rw [zmodEquivZpowers, AddEquiv.ofBijective_apply] -- Porting note: Original proof didn't have `rw`
  -- ‚ä¢ ‚Üë(‚Üë(AddMonoidHom.liftOfRightInverse (Int.castAddHom (ZMod k)) ZMod.cast (_ : ‚Ä¶
  exact AddMonoidHom.liftOfRightInverse_comp_apply _ _ ZMod.int_cast_rightInverse _ _
  -- üéâ no goals
#align is_primitive_root.zmod_equiv_zpowers_apply_coe_int IsPrimitiveRoot.zmodEquivZpowers_apply_coe_int

@[simp]
theorem zmodEquivZpowers_apply_coe_nat (i : ‚Ñï) :
    h.zmodEquivZpowers i = Additive.ofMul (‚ü®Œ∂ ^ i, i, rfl‚ü© : Subgroup.zpowers Œ∂) := by
  have : (i : ZMod k) = (i : ‚Ñ§) := by norm_cast
  -- ‚ä¢ ‚Üë(zmodEquivZpowers h) ‚Üëi = ‚ÜëAdditive.ofMul { val := Œ∂ ^ i, property := (_ :  ‚Ä¶
  simp only [this, zmodEquivZpowers_apply_coe_int, zpow_ofNat]
  -- üéâ no goals
#align is_primitive_root.zmod_equiv_zpowers_apply_coe_nat IsPrimitiveRoot.zmodEquivZpowers_apply_coe_nat

@[simp]
theorem zmodEquivZpowers_symm_apply_zpow (i : ‚Ñ§) :
    h.zmodEquivZpowers.symm (Additive.ofMul (‚ü®Œ∂ ^ i, i, rfl‚ü© : Subgroup.zpowers Œ∂)) = i := by
  rw [‚Üê h.zmodEquivZpowers.symm_apply_apply i, zmodEquivZpowers_apply_coe_int]
  -- üéâ no goals
#align is_primitive_root.zmod_equiv_zpowers_symm_apply_zpow IsPrimitiveRoot.zmodEquivZpowers_symm_apply_zpow

@[simp]
theorem zmodEquivZpowers_symm_apply_zpow' (i : ‚Ñ§) : h.zmodEquivZpowers.symm ‚ü®Œ∂ ^ i, i, rfl‚ü© = i :=
  h.zmodEquivZpowers_symm_apply_zpow i
#align is_primitive_root.zmod_equiv_zpowers_symm_apply_zpow' IsPrimitiveRoot.zmodEquivZpowers_symm_apply_zpow'

@[simp]
theorem zmodEquivZpowers_symm_apply_pow (i : ‚Ñï) :
    h.zmodEquivZpowers.symm (Additive.ofMul (‚ü®Œ∂ ^ i, i, rfl‚ü© : Subgroup.zpowers Œ∂)) = i := by
  rw [‚Üê h.zmodEquivZpowers.symm_apply_apply i, zmodEquivZpowers_apply_coe_nat]
  -- üéâ no goals
#align is_primitive_root.zmod_equiv_zpowers_symm_apply_pow IsPrimitiveRoot.zmodEquivZpowers_symm_apply_pow

@[simp]
theorem zmodEquivZpowers_symm_apply_pow' (i : ‚Ñï) : h.zmodEquivZpowers.symm ‚ü®Œ∂ ^ i, i, rfl‚ü© = i :=
  h.zmodEquivZpowers_symm_apply_pow i
#align is_primitive_root.zmod_equiv_zpowers_symm_apply_pow' IsPrimitiveRoot.zmodEquivZpowers_symm_apply_pow'

variable [IsDomain R]

theorem zpowers_eq {k : ‚Ñï+} {Œ∂ : RÀ£} (h : IsPrimitiveRoot Œ∂ k) :
    Subgroup.zpowers Œ∂ = rootsOfUnity k R := by
  apply SetLike.coe_injective
  -- ‚ä¢ ‚Üë(Subgroup.zpowers Œ∂) = ‚Üë(rootsOfUnity k R)
  haveI F : Fintype (Subgroup.zpowers Œ∂) := Fintype.ofEquiv _ h.zmodEquivZpowers.toEquiv
  -- ‚ä¢ ‚Üë(Subgroup.zpowers Œ∂) = ‚Üë(rootsOfUnity k R)
  refine'
    @Set.eq_of_subset_of_card_le RÀ£ (Subgroup.zpowers Œ∂) (rootsOfUnity k R) F
      (rootsOfUnity.fintype R k)
      (Subgroup.zpowers_le_of_mem <| show Œ∂ ‚àà rootsOfUnity k R from h.pow_eq_one) _
  calc
    Fintype.card (rootsOfUnity k R) ‚â§ k := card_rootsOfUnity R k
    _ = Fintype.card (ZMod k) := (ZMod.card k).symm
    _ = Fintype.card (Subgroup.zpowers Œ∂) := Fintype.card_congr h.zmodEquivZpowers.toEquiv
#align is_primitive_root.zpowers_eq IsPrimitiveRoot.zpowers_eq

-- Porting note: rephrased the next few lemmas to avoid `‚àÉ (Prop)`
theorem eq_pow_of_mem_rootsOfUnity {k : ‚Ñï+} {Œ∂ Œæ : RÀ£} (h : IsPrimitiveRoot Œ∂ k)
    (hŒæ : Œæ ‚àà rootsOfUnity k R) : ‚àÉ (i : ‚Ñï), i < k ‚àß Œ∂ ^ i = Œæ := by
  obtain ‚ü®n, rfl‚ü© : ‚àÉ n : ‚Ñ§, Œ∂ ^ n = Œæ := by rwa [‚Üê h.zpowers_eq] at hŒæ
  -- ‚ä¢ ‚àÉ i, i < ‚Üëk ‚àß Œ∂ ^ i = Œ∂ ^ n
  have hk0 : (0 : ‚Ñ§) < k := by exact_mod_cast k.pos
  -- ‚ä¢ ‚àÉ i, i < ‚Üëk ‚àß Œ∂ ^ i = Œ∂ ^ n
  let i := n % k
  -- ‚ä¢ ‚àÉ i, i < ‚Üëk ‚àß Œ∂ ^ i = Œ∂ ^ n
  have hi0 : 0 ‚â§ i := Int.emod_nonneg _ (ne_of_gt hk0)
  -- ‚ä¢ ‚àÉ i, i < ‚Üëk ‚àß Œ∂ ^ i = Œ∂ ^ n
  lift i to ‚Ñï using hi0 with i‚ÇÄ hi‚ÇÄ
  -- ‚ä¢ ‚àÉ i, i < ‚Üëk ‚àß Œ∂ ^ i = Œ∂ ^ n
  refine' ‚ü®i‚ÇÄ, _, _‚ü©
  -- ‚ä¢ i‚ÇÄ < ‚Üëk
  ¬∑ zify; rw [hi‚ÇÄ]; exact Int.emod_lt_of_pos _ hk0
    -- ‚ä¢ ‚Üëi‚ÇÄ < ‚Üë‚Üëk
          -- ‚ä¢ i < ‚Üë‚Üëk
                    -- üéâ no goals
  ¬∑ rw [‚Üê zpow_ofNat, hi‚ÇÄ, ‚Üê Int.emod_add_ediv n k, zpow_add, zpow_mul, h.zpow_eq_one, one_zpow,
      mul_one]
#align is_primitive_root.eq_pow_of_mem_roots_of_unity IsPrimitiveRoot.eq_pow_of_mem_rootsOfUnity

theorem eq_pow_of_pow_eq_one {k : ‚Ñï} {Œ∂ Œæ : R} (h : IsPrimitiveRoot Œ∂ k) (hŒæ : Œæ ^ k = 1)
    (h0 : 0 < k) : ‚àÉ i < k, Œ∂ ^ i = Œæ := by
  lift Œ∂ to RÀ£ using h.isUnit h0
  -- ‚ä¢ ‚àÉ i, i < k ‚àß ‚ÜëŒ∂ ^ i = Œæ
  lift Œæ to RÀ£ using isUnit_ofPowEqOne hŒæ h0.ne'
  -- ‚ä¢ ‚àÉ i, i < k ‚àß ‚ÜëŒ∂ ^ i = ‚ÜëŒæ
  lift k to ‚Ñï+ using h0
  -- ‚ä¢ ‚àÉ i, i < ‚Üëk ‚àß ‚ÜëŒ∂ ^ i = ‚ÜëŒæ
  simp only [‚Üê Units.val_pow_eq_pow_val, ‚Üê Units.ext_iff]
  -- ‚ä¢ ‚àÉ i, i < ‚Üëk ‚àß Œ∂ ^ i = Œæ
  rw [coe_units_iff] at h
  -- ‚ä¢ ‚àÉ i, i < ‚Üëk ‚àß Œ∂ ^ i = Œæ
  apply h.eq_pow_of_mem_rootsOfUnity
  -- ‚ä¢ Œæ ‚àà rootsOfUnity k R
  rw [mem_rootsOfUnity, Units.ext_iff, Units.val_pow_eq_pow_val, hŒæ, Units.val_one]
  -- üéâ no goals
#align is_primitive_root.eq_pow_of_pow_eq_one IsPrimitiveRoot.eq_pow_of_pow_eq_one

theorem isPrimitiveRoot_iff' {k : ‚Ñï+} {Œ∂ Œæ : RÀ£} (h : IsPrimitiveRoot Œ∂ k) :
    IsPrimitiveRoot Œæ k ‚Üî ‚àÉ i < (k : ‚Ñï), i.coprime k ‚àß Œ∂ ^ i = Œæ := by
  constructor
  -- ‚ä¢ IsPrimitiveRoot Œæ ‚Üëk ‚Üí ‚àÉ i, i < ‚Üëk ‚àß Nat.coprime i ‚Üëk ‚àß Œ∂ ^ i = Œæ
  ¬∑ intro hŒæ
    -- ‚ä¢ ‚àÉ i, i < ‚Üëk ‚àß Nat.coprime i ‚Üëk ‚àß Œ∂ ^ i = Œæ
    obtain ‚ü®i, hik, rfl‚ü© := h.eq_pow_of_mem_rootsOfUnity hŒæ.pow_eq_one
    -- ‚ä¢ ‚àÉ i_1, i_1 < ‚Üëk ‚àß Nat.coprime i_1 ‚Üëk ‚àß Œ∂ ^ i_1 = Œ∂ ^ i
    rw [h.pow_iff_coprime k.pos] at hŒæ
    -- ‚ä¢ ‚àÉ i_1, i_1 < ‚Üëk ‚àß Nat.coprime i_1 ‚Üëk ‚àß Œ∂ ^ i_1 = Œ∂ ^ i
    exact ‚ü®i, hik, hŒæ, rfl‚ü©
    -- üéâ no goals
  ¬∑ rintro ‚ü®i, -, hi, rfl‚ü©; exact h.pow_of_coprime i hi
    -- ‚ä¢ IsPrimitiveRoot (Œ∂ ^ i) ‚Üëk
                            -- üéâ no goals
#align is_primitive_root.is_primitive_root_iff' IsPrimitiveRoot.isPrimitiveRoot_iff'

theorem isPrimitiveRoot_iff {k : ‚Ñï} {Œ∂ Œæ : R} (h : IsPrimitiveRoot Œ∂ k) (h0 : 0 < k) :
    IsPrimitiveRoot Œæ k ‚Üî ‚àÉ i < k, i.coprime k ‚àß Œ∂ ^ i = Œæ := by
  constructor
  -- ‚ä¢ IsPrimitiveRoot Œæ k ‚Üí ‚àÉ i, i < k ‚àß Nat.coprime i k ‚àß Œ∂ ^ i = Œæ
  ¬∑ intro hŒæ
    -- ‚ä¢ ‚àÉ i, i < k ‚àß Nat.coprime i k ‚àß Œ∂ ^ i = Œæ
    obtain ‚ü®i, hik, rfl‚ü© := h.eq_pow_of_pow_eq_one hŒæ.pow_eq_one h0
    -- ‚ä¢ ‚àÉ i_1, i_1 < k ‚àß Nat.coprime i_1 k ‚àß Œ∂ ^ i_1 = Œ∂ ^ i
    rw [h.pow_iff_coprime h0] at hŒæ
    -- ‚ä¢ ‚àÉ i_1, i_1 < k ‚àß Nat.coprime i_1 k ‚àß Œ∂ ^ i_1 = Œ∂ ^ i
    exact ‚ü®i, hik, hŒæ, rfl‚ü©
    -- üéâ no goals
  ¬∑ rintro ‚ü®i, -, hi, rfl‚ü©; exact h.pow_of_coprime i hi
    -- ‚ä¢ IsPrimitiveRoot (Œ∂ ^ i) k
                            -- üéâ no goals
#align is_primitive_root.is_primitive_root_iff IsPrimitiveRoot.isPrimitiveRoot_iff

theorem card_rootsOfUnity' {n : ‚Ñï+} (h : IsPrimitiveRoot Œ∂ n) :
    Fintype.card (rootsOfUnity n R) = n := by
  let e := h.zmodEquivZpowers
  -- ‚ä¢ Fintype.card { x // x ‚àà rootsOfUnity n R } = ‚Üën
  haveI F : Fintype (Subgroup.zpowers Œ∂) := Fintype.ofEquiv _ e.toEquiv
  -- ‚ä¢ Fintype.card { x // x ‚àà rootsOfUnity n R } = ‚Üën
  calc
    Fintype.card (rootsOfUnity n R) = Fintype.card (Subgroup.zpowers Œ∂) :=
      Fintype.card_congr <| by rw [h.zpowers_eq]
    _ = Fintype.card (ZMod n) := (Fintype.card_congr e.toEquiv.symm)
    _ = n := ZMod.card n
#align is_primitive_root.card_roots_of_unity' IsPrimitiveRoot.card_rootsOfUnity'

theorem card_rootsOfUnity {Œ∂ : R} {n : ‚Ñï+} (h : IsPrimitiveRoot Œ∂ n) :
    Fintype.card (rootsOfUnity n R) = n := by
  obtain ‚ü®Œ∂, hŒ∂‚ü© := h.isUnit n.pos
  -- ‚ä¢ Fintype.card { x // x ‚àà rootsOfUnity n R } = ‚Üën
  rw [‚Üê hŒ∂, IsPrimitiveRoot.coe_units_iff] at h
  -- ‚ä¢ Fintype.card { x // x ‚àà rootsOfUnity n R } = ‚Üën
  exact h.card_rootsOfUnity'
  -- üéâ no goals
#align is_primitive_root.card_roots_of_unity IsPrimitiveRoot.card_rootsOfUnity

/-- The cardinality of the multiset `nthRoots ‚Üën (1 : R)` is `n`
if there is a primitive root of unity in `R`. -/
nonrec theorem card_nthRoots {Œ∂ : R} {n : ‚Ñï} (h : IsPrimitiveRoot Œ∂ n) :
    Multiset.card (nthRoots n (1 : R)) = n := by
  cases' Nat.eq_zero_or_pos n with hzero hpos
  -- ‚ä¢ ‚ÜëMultiset.card (nthRoots n 1) = n
  ¬∑ simp only [hzero, Multiset.card_zero, nthRoots_zero]
    -- üéâ no goals
  rw [eq_iff_le_not_lt]
  -- ‚ä¢ ‚ÜëMultiset.card (nthRoots n 1) ‚â§ n ‚àß ¬¨‚ÜëMultiset.card (nthRoots n 1) < n
  use card_nthRoots n 1
  -- ‚ä¢ ¬¨‚ÜëMultiset.card (nthRoots n 1) < n
  ¬∑ rw [not_lt]
    -- ‚ä¢ n ‚â§ ‚ÜëMultiset.card (nthRoots n 1)
    have hcard :
        Fintype.card { x // x ‚àà nthRoots n (1 : R) } ‚â§ Multiset.card (nthRoots n (1 : R)).attach :=
      Multiset.card_le_of_le (Multiset.dedup_le _)
    rw [Multiset.card_attach] at hcard
    -- ‚ä¢ n ‚â§ ‚ÜëMultiset.card (nthRoots n 1)
    rw [‚Üê PNat.toPNat'_coe hpos] at hcard h ‚ä¢
    -- ‚ä¢ ‚Üë(Nat.toPNat' n) ‚â§ ‚ÜëMultiset.card (nthRoots (‚Üë(Nat.toPNat' n)) 1)
    set m := Nat.toPNat' n
    -- ‚ä¢ ‚Üëm ‚â§ ‚ÜëMultiset.card (nthRoots (‚Üëm) 1)
    rw [‚Üê Fintype.card_congr (rootsOfUnityEquivNthRoots R m), card_rootsOfUnity h] at hcard
    -- ‚ä¢ ‚Üëm ‚â§ ‚ÜëMultiset.card (nthRoots (‚Üëm) 1)
    exact hcard
    -- üéâ no goals
#align is_primitive_root.card_nth_roots IsPrimitiveRoot.card_nthRoots

/-- The multiset `nthRoots ‚Üën (1 : R)` has no repeated elements
if there is a primitive root of unity in `R`. -/
theorem nthRoots_nodup {Œ∂ : R} {n : ‚Ñï} (h : IsPrimitiveRoot Œ∂ n) : (nthRoots n (1 : R)).Nodup := by
  cases' Nat.eq_zero_or_pos n with hzero hpos
  -- ‚ä¢ Multiset.Nodup (nthRoots n 1)
  ¬∑ simp only [hzero, Multiset.nodup_zero, nthRoots_zero]
    -- üéâ no goals
  apply (Multiset.dedup_eq_self (Œ± := R)).1
  -- ‚ä¢ Multiset.dedup (nthRoots n 1) = nthRoots n 1
  rw [eq_iff_le_not_lt]
  -- ‚ä¢ Multiset.dedup (nthRoots n 1) ‚â§ nthRoots n 1 ‚àß ¬¨Multiset.dedup (nthRoots n 1 ‚Ä¶
  constructor
  -- ‚ä¢ Multiset.dedup (nthRoots n 1) ‚â§ nthRoots n 1
  ¬∑ exact Multiset.dedup_le (nthRoots n (1 : R))
    -- üéâ no goals
  ¬∑ by_contra ha
    -- ‚ä¢ False
    replace ha := Multiset.card_lt_of_lt ha
    -- ‚ä¢ False
    rw [card_nthRoots h] at ha
    -- ‚ä¢ False
    have hrw : Multiset.card (nthRoots n (1 : R)).dedup =
        Fintype.card { x // x ‚àà nthRoots n (1 : R) } := by
      set fs := (‚ü®(nthRoots n (1 : R)).dedup, Multiset.nodup_dedup _‚ü© : Finset R)
      rw [‚Üê Finset.card_mk, Fintype.card_of_subtype fs _]
      intro x
      simp only [Multiset.mem_dedup, Finset.mem_mk]
    rw [‚Üê PNat.toPNat'_coe hpos] at h hrw ha
    -- ‚ä¢ False
    set m := Nat.toPNat' n
    -- ‚ä¢ False
    rw [hrw, ‚Üê Fintype.card_congr (rootsOfUnityEquivNthRoots R m), card_rootsOfUnity h] at ha
    -- ‚ä¢ False
    exact Nat.lt_asymm ha ha
    -- üéâ no goals
#align is_primitive_root.nth_roots_nodup IsPrimitiveRoot.nthRoots_nodup

@[simp]
theorem card_nthRootsFinset {Œ∂ : R} {n : ‚Ñï} (h : IsPrimitiveRoot Œ∂ n) :
    (nthRootsFinset n R).card = n := by
  rw [nthRootsFinset, ‚Üê Multiset.toFinset_eq (nthRoots_nodup h), card_mk, h.card_nthRoots]
  -- üéâ no goals
#align is_primitive_root.card_nth_roots_finset IsPrimitiveRoot.card_nthRootsFinset

open scoped Nat

/-- If an integral domain has a primitive `k`-th root of unity, then it has `œÜ k` of them. -/
theorem card_primitiveRoots {Œ∂ : R} {k : ‚Ñï} (h : IsPrimitiveRoot Œ∂ k) :
    (primitiveRoots k R).card = œÜ k := by
  by_cases h0 : k = 0
  -- ‚ä¢ card (primitiveRoots k R) = œÜ k
  ¬∑ simp [h0]
    -- üéâ no goals
  symm
  -- ‚ä¢ œÜ k = card (primitiveRoots k R)
  refine' Finset.card_congr (fun i _ => Œ∂ ^ i) _ _ _
  ¬∑ simp only [true_and_iff, and_imp, mem_filter, mem_range, mem_univ]
    -- ‚ä¢ ‚àÄ (a : ‚Ñï), a < k ‚Üí Nat.coprime k a ‚Üí Œ∂ ^ a ‚àà primitiveRoots k R
    rintro i - hi
    -- ‚ä¢ Œ∂ ^ i ‚àà primitiveRoots k R
    rw [mem_primitiveRoots (Nat.pos_of_ne_zero h0)]
    -- ‚ä¢ IsPrimitiveRoot (Œ∂ ^ i) k
    exact h.pow_of_coprime i hi.symm
    -- üéâ no goals
  ¬∑ simp only [true_and_iff, and_imp, mem_filter, mem_range, mem_univ]
    -- ‚ä¢ ‚àÄ (a b : ‚Ñï), a < k ‚Üí Nat.coprime k a ‚Üí b < k ‚Üí Nat.coprime k b ‚Üí Œ∂ ^ a = Œ∂ ^ ‚Ä¶
    rintro i j hi - hj - H
    -- ‚ä¢ i = j
    exact h.pow_inj hi hj H
    -- üéâ no goals
  ¬∑ simp only [exists_prop, true_and_iff, mem_filter, mem_range, mem_univ]
    -- ‚ä¢ ‚àÄ (b : R), b ‚àà primitiveRoots k R ‚Üí ‚àÉ a, (a < k ‚àß Nat.coprime k a) ‚àß Œ∂ ^ a = b
    intro Œæ hŒæ
    -- ‚ä¢ ‚àÉ a, (a < k ‚àß Nat.coprime k a) ‚àß Œ∂ ^ a = Œæ
    rw [mem_primitiveRoots (Nat.pos_of_ne_zero h0),
      h.isPrimitiveRoot_iff (Nat.pos_of_ne_zero h0)] at hŒæ
    rcases hŒæ with ‚ü®i, hin, hi, H‚ü©
    -- ‚ä¢ ‚àÉ a, (a < k ‚àß Nat.coprime k a) ‚àß Œ∂ ^ a = Œæ
    exact ‚ü®i, ‚ü®hin, hi.symm‚ü©, H‚ü©
    -- üéâ no goals
#align is_primitive_root.card_primitive_roots IsPrimitiveRoot.card_primitiveRoots

/-- The sets `primitiveRoots k R` are pairwise disjoint. -/
theorem disjoint {k l : ‚Ñï} (h : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=
  Finset.disjoint_left.2 fun _ hk hl =>
    h <|
      (isPrimitiveRoot_of_mem_primitiveRoots hk).unique <| isPrimitiveRoot_of_mem_primitiveRoots hl
#align is_primitive_root.disjoint IsPrimitiveRoot.disjoint

/-- `nthRoots n` as a `Finset` is equal to the union of `primitiveRoots i R` for `i ‚à£ n`
if there is a primitive root of unity in `R`.
This holds for any `Nat`, not just `PNat`, see `nthRoots_one_eq_bUnion_primitive_roots`. -/
theorem nthRoots_one_eq_biUnion_primitiveRoots' {Œ∂ : R} {n : ‚Ñï+} (h : IsPrimitiveRoot Œ∂ n) :
    nthRootsFinset n R = (Nat.divisors ‚Üën).biUnion fun i => primitiveRoots i R := by
  symm
  -- ‚ä¢ (Finset.biUnion (Nat.divisors ‚Üën) fun i => primitiveRoots i R) = nthRootsFin ‚Ä¶
  apply Finset.eq_of_subset_of_card_le
  -- ‚ä¢ (Finset.biUnion (Nat.divisors ‚Üën) fun i => primitiveRoots i R) ‚äÜ nthRootsFin ‚Ä¶
  ¬∑ intro x
    -- ‚ä¢ (x ‚àà Finset.biUnion (Nat.divisors ‚Üën) fun i => primitiveRoots i R) ‚Üí x ‚àà nth ‚Ä¶
    simp only [nthRootsFinset, ‚Üê Multiset.toFinset_eq (nthRoots_nodup h), exists_prop,
      Finset.mem_biUnion, Finset.mem_filter, Finset.mem_range, mem_nthRoots, Finset.mem_mk,
      Nat.mem_divisors, and_true_iff, Ne.def, PNat.ne_zero, PNat.pos, not_false_iff]
    rintro ‚ü®a, ‚ü®d, hd‚ü©, ha‚ü©
    -- ‚ä¢ x ^ ‚Üën = 1
    have hazero : 0 < a := by
      contrapose! hd with ha0
      simp_all only [nonpos_iff_eq_zero, zero_mul]
      exact n.ne_zero
    rw [mem_primitiveRoots hazero] at ha
    -- ‚ä¢ x ^ ‚Üën = 1
    rw [hd, pow_mul, ha.pow_eq_one, one_pow]
    -- üéâ no goals
  ¬∑ apply le_of_eq
    -- ‚ä¢ card (nthRootsFinset (‚Üën) R) = card (Finset.biUnion (Nat.divisors ‚Üën) fun i  ‚Ä¶
    rw [h.card_nthRootsFinset, Finset.card_biUnion]
    -- ‚ä¢ ‚Üën = ‚àë u in Nat.divisors ‚Üën, card (primitiveRoots u R)
    ¬∑ nth_rw 1 [‚Üê Nat.sum_totient n]
      -- ‚ä¢ Finset.sum (Nat.divisors ‚Üën) œÜ = ‚àë u in Nat.divisors ‚Üën, card (primitiveRoot ‚Ä¶
      refine' sum_congr rfl _
      -- ‚ä¢ ‚àÄ (x : ‚Ñï), x ‚àà Nat.divisors ‚Üën ‚Üí œÜ x = card (primitiveRoots x R)
      simp only [Nat.mem_divisors]
      -- ‚ä¢ ‚àÄ (x : ‚Ñï), x ‚à£ ‚Üën ‚àß ‚Üën ‚â† 0 ‚Üí œÜ x = card (primitiveRoots x R)
      rintro k ‚ü®‚ü®d, hd‚ü©, -‚ü©
      -- ‚ä¢ œÜ k = card (primitiveRoots k R)
      rw [mul_comm] at hd
      -- ‚ä¢ œÜ k = card (primitiveRoots k R)
      rw [(h.pow n.pos hd).card_primitiveRoots]
      -- üéâ no goals
    ¬∑ intro i _ j _ hdiff
      -- ‚ä¢ Disjoint (primitiveRoots i R) (primitiveRoots j R)
      exact disjoint hdiff
      -- üéâ no goals
#align is_primitive_root.nth_roots_one_eq_bUnion_primitive_roots' IsPrimitiveRoot.nthRoots_one_eq_biUnion_primitiveRoots'

/-- `nthRoots n` as a `Finset` is equal to the union of `primitiveRoots i R` for `i ‚à£ n`
if there is a primitive root of unity in `R`. -/
theorem nthRoots_one_eq_biUnion_primitiveRoots {Œ∂ : R} {n : ‚Ñï} (h : IsPrimitiveRoot Œ∂ n) :
    nthRootsFinset n R = (Nat.divisors n).biUnion fun i => primitiveRoots i R := by
  by_cases hn : n = 0
  -- ‚ä¢ nthRootsFinset n R = Finset.biUnion (Nat.divisors n) fun i => primitiveRoots ‚Ä¶
  ¬∑ simp [hn]
    -- üéâ no goals
  exact nthRoots_one_eq_biUnion_primitiveRoots' (n := ‚ü®n, Nat.pos_of_ne_zero hn‚ü©) h
  -- üéâ no goals
#align is_primitive_root.nth_roots_one_eq_bUnion_primitive_roots IsPrimitiveRoot.nthRoots_one_eq_biUnion_primitiveRoots

end IsDomain

section Automorphisms

variable [CommRing S] [IsDomain S] {Œº : S} {n : ‚Ñï+} (hŒº : IsPrimitiveRoot Œº n) (R) [CommRing R]
  [Algebra R S]

/-- The `MonoidHom` that takes an automorphism to the power of Œº that Œº gets mapped to under it. -/
noncomputable def autToPow : (S ‚âÉ‚Çê[R] S) ‚Üí* (ZMod n)À£ :=
  let Œº' := hŒº.toRootsOfUnity
  have ho : orderOf Œº' = n := by
    rw [hŒº.eq_orderOf, ‚Üê hŒº.val_toRootsOfUnity_coe, orderOf_units, orderOf_subgroup]
    -- üéâ no goals
  MonoidHom.toHomUnits
    { toFun := fun œÉ => (map_rootsOfUnity_eq_pow_self œÉ.toAlgHom Œº').choose
      map_one' := by
        dsimp only
        -- ‚ä¢ ‚Üë(Exists.choose (_ : ‚àÉ m, ‚Üë‚Üë1 ‚Üë‚Üë(toRootsOfUnity hŒº) = ‚Üë‚Üë(toRootsOfUnity hŒº)  ‚Ä¶
        generalize_proofs h1
        -- ‚ä¢ ‚Üë(Exists.choose h1) = 1
        have h := h1.choose_spec
        -- ‚ä¢ ‚Üë(Exists.choose h1) = 1
        dsimp only [AlgEquiv.one_apply, AlgEquiv.toRingEquiv_eq_coe, RingEquiv.toRingHom_eq_coe,
          RingEquiv.coe_toRingHom, AlgEquiv.coe_ringEquiv] at *
        replace h : Œº' = Œº' ^ h1.choose :=
          rootsOfUnity.coe_injective (by simpa only [rootsOfUnity.coe_pow] using h)
        nth_rw 1 [‚Üê pow_one Œº'] at h
        -- ‚ä¢ ‚Üë(Exists.choose h1) = 1
        rw [‚Üê Nat.cast_one, ZMod.nat_cast_eq_nat_cast_iff, ‚Üê ho, ‚Üê pow_eq_pow_iff_modEq Œº', h]
        -- üéâ no goals
      map_mul' := by
        intro x y
        -- ‚ä¢ OneHom.toFun { toFun := fun œÉ => ‚Üë(Exists.choose (_ : ‚àÉ m, ‚Üë‚ÜëœÉ ‚Üë‚ÜëŒº' = ‚Üë‚ÜëŒº' ^ ‚Ä¶
        dsimp only
        -- ‚ä¢ ‚Üë(Exists.choose (_ : ‚àÉ m, ‚Üë‚Üë(x * y) ‚Üë‚Üë(toRootsOfUnity hŒº) = ‚Üë‚Üë(toRootsOfUnit ‚Ä¶
        generalize_proofs hxy' hx' hy'
        -- ‚ä¢ ‚Üë(Exists.choose hxy') = ‚Üë(Exists.choose hx') * ‚Üë(Exists.choose hy')
        have hxy := hxy'.choose_spec
        -- ‚ä¢ ‚Üë(Exists.choose hxy') = ‚Üë(Exists.choose hx') * ‚Üë(Exists.choose hy')
        have hx := hx'.choose_spec
        -- ‚ä¢ ‚Üë(Exists.choose hxy') = ‚Üë(Exists.choose hx') * ‚Üë(Exists.choose hy')
        have hy := hy'.choose_spec
        -- ‚ä¢ ‚Üë(Exists.choose hxy') = ‚Üë(Exists.choose hx') * ‚Üë(Exists.choose hy')
        dsimp only [AlgEquiv.toRingEquiv_eq_coe, RingEquiv.toRingHom_eq_coe,
          RingEquiv.coe_toRingHom, AlgEquiv.coe_ringEquiv, AlgEquiv.mul_apply] at *
        replace hxy : x (((Œº' : SÀ£) : S) ^ hy'.choose) = ((Œº' : SÀ£) : S) ^ hxy'.choose := hy ‚ñ∏ hxy
        -- ‚ä¢ ‚Üë(Exists.choose hxy') = ‚Üë(Exists.choose hx') * ‚Üë(Exists.choose hy')
        rw [x.map_pow] at hxy
        -- ‚ä¢ ‚Üë(Exists.choose hxy') = ‚Üë(Exists.choose hx') * ‚Üë(Exists.choose hy')
        replace hxy : (((Œº' : SÀ£) : S) ^ hx'.choose) ^ hy'.choose = ((Œº' : SÀ£) : S) ^ hxy'.choose :=
          hx ‚ñ∏ hxy
        rw [‚Üê pow_mul] at hxy
        -- ‚ä¢ ‚Üë(Exists.choose hxy') = ‚Üë(Exists.choose hx') * ‚Üë(Exists.choose hy')
        replace hxy : Œº' ^ (hx'.choose * hy'.choose) = Œº' ^ hxy'.choose :=
          rootsOfUnity.coe_injective (by simpa only [rootsOfUnity.coe_pow] using hxy)
        rw [‚Üê Nat.cast_mul, ZMod.nat_cast_eq_nat_cast_iff, ‚Üê ho, ‚Üê pow_eq_pow_iff_modEq Œº', hxy] }
        -- üéâ no goals
#align is_primitive_root.aut_to_pow IsPrimitiveRoot.autToPow

-- We are not using @[simps] in aut_to_pow to avoid a timeout.
theorem coe_autToPow_apply (f : S ‚âÉ‚Çê[R] S) :
    (autToPow R hŒº f : ZMod n) =
      ((map_rootsOfUnity_eq_pow_self f hŒº.toRootsOfUnity).choose : ZMod n) :=
  rfl
#align is_primitive_root.coe_aut_to_pow_apply IsPrimitiveRoot.coe_autToPow_apply

@[simp]
theorem autToPow_spec (f : S ‚âÉ‚Çê[R] S) : Œº ^ (hŒº.autToPow R f : ZMod n).val = f Œº := by
  rw [IsPrimitiveRoot.coe_autToPow_apply]
  -- ‚ä¢ Œº ^ ZMod.val ‚Üë(Exists.choose (_ : ‚àÉ m, ‚Üëf ‚Üë‚Üë(toRootsOfUnity hŒº) = ‚Üë‚Üë(toRoots ‚Ä¶
  generalize_proofs h
  -- ‚ä¢ Œº ^ ZMod.val ‚Üë(Exists.choose h) = ‚Üëf Œº
  have := h.choose_spec
  -- ‚ä¢ Œº ^ ZMod.val ‚Üë(Exists.choose h) = ‚Üëf Œº
  dsimp only [AlgEquiv.toAlgHom_eq_coe, AlgEquiv.coe_algHom] at this
  -- ‚ä¢ Œº ^ ZMod.val ‚Üë(Exists.choose h) = ‚Üëf Œº
  refine' (_ : ((hŒº.toRootsOfUnity : SÀ£) : S) ^ _ = _).trans this.symm
  -- ‚ä¢ ‚Üë‚Üë(toRootsOfUnity hŒº) ^ ZMod.val ‚Üë(Exists.choose h) = ‚Üë‚Üë(toRootsOfUnity hŒº)  ‚Ä¶
  rw [‚Üê rootsOfUnity.coe_pow, ‚Üê rootsOfUnity.coe_pow]
  -- ‚ä¢ ‚Üë‚Üë(toRootsOfUnity hŒº ^ ZMod.val ‚Üë(Exists.choose h)) = ‚Üë‚Üë(toRootsOfUnity hŒº ^ ‚Ä¶
  congr 2
  -- ‚ä¢ toRootsOfUnity hŒº ^ ZMod.val ‚Üë(Exists.choose h) = toRootsOfUnity hŒº ^ Exists ‚Ä¶
  rw [pow_eq_pow_iff_modEq, ZMod.val_nat_cast, hŒº.eq_orderOf, ‚Üê orderOf_subgroup, ‚Üê orderOf_units]
  -- ‚ä¢ Exists.choose h % orderOf Œº ‚â° Exists.choose h [MOD orderOf ‚Üë‚Üë(toRootsOfUnity ‚Ä¶
  exact Nat.mod_modEq _ _
  -- üéâ no goals
#align is_primitive_root.aut_to_pow_spec IsPrimitiveRoot.autToPow_spec

end Automorphisms

end IsPrimitiveRoot
