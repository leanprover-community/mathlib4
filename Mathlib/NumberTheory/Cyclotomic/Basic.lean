/-
Copyright (c) 2021 Riccardo Brasca. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Riccardo Brasca
-/
import Mathlib.RingTheory.Polynomial.Cyclotomic.Roots
import Mathlib.NumberTheory.NumberField.Basic
import Mathlib.FieldTheory.Galois

#align_import number_theory.cyclotomic.basic from "leanprover-community/mathlib"@"4b05d3f4f0601dca8abf99c4ec99187682ed0bba"

/-!
# Cyclotomic extensions

Let `A` and `B` be commutative rings with `Algebra A B`. For `S : Set ‚Ñï+`, we define a class
`IsCyclotomicExtension S A B` expressing the fact that `B` is obtained from `A` by adding `n`-th
primitive roots of unity, for all `n ‚àà S`.

## Main definitions

* `IsCyclotomicExtension S A B` : means that `B` is obtained from `A` by adding `n`-th primitive
  roots of unity, for all `n ‚àà S`.
* `CyclotomicField`: given `n : ‚Ñï+` and a field `K`, we define `CyclotomicField n K` as the
  splitting field of `cyclotomic n K`. If `n` is nonzero in `K`, it has the instance
  `IsCyclotomicExtension {n} K (CyclotomicField n K)`.
* `CyclotomicRing` : if `A` is a domain with fraction field `K` and `n : ‚Ñï+`, we define
  `CyclotomicRing n A K` as the `A`-subalgebra of `CyclotomicField n K` generated by the roots of
  `X ^ n - 1`. If `n` is nonzero in `A`, it has the instance
  `IsCyclotomicExtension {n} A (CyclotomicRing n A K)`.

## Main results

* `IsCyclotomicExtension.trans` : if `IsCyclotomicExtension S A B` and
  `IsCyclotomicExtension T B C`, then `IsCyclotomicExtension (S ‚à™ T) A C` if
  `Function.Injective (algebraMap B C)`.
* `IsCyclotomicExtension.union_right` : given `IsCyclotomicExtension (S ‚à™ T) A B`, then
  `IsCyclotomicExtension T (adjoin A { b : B | ‚àÉ a : ‚Ñï+, a ‚àà S ‚àß b ^ (a : ‚Ñï) = 1 }) B`.
* `IsCyclotomicExtension.union_left` : given `IsCyclotomicExtension T A B` and `S ‚äÜ T`, then
  `IsCyclotomicExtension S A (adjoin A { b : B | ‚àÉ a : ‚Ñï+, a ‚àà S ‚àß b ^ (a : ‚Ñï) = 1 })`.
* `IsCyclotomicExtension.finite` : if `S` is finite and `IsCyclotomicExtension S A B`, then
  `B` is a finite `A`-algebra.
* `IsCyclotomicExtension.numberField` : a finite cyclotomic extension of a number field is a
  number field.
* `IsCyclotomicExtension.splitting_field_X_pow_sub_one` : if `IsCyclotomicExtension {n} K L`,
  then `L` is the splitting field of `X ^ n - 1`.
* `IsCyclotomicExtension.splitting_field_cyclotomic` : if `IsCyclotomicExtension {n} K L`,
  then `L` is the splitting field of `cyclotomic n K`.

## Implementation details

Our definition of `IsCyclotomicExtension` is very general, to allow rings of any characteristic
and infinite extensions, but it will mainly be used in the case `S = {n}` and for integral domains.
All results are in the `IsCyclotomicExtension` namespace.
Note that some results, for example `IsCyclotomicExtension.trans`,
`IsCyclotomicExtension.finite`, `IsCyclotomicExtension.numberField`,
`IsCyclotomicExtension.finiteDimensional`, `IsCyclotomicExtension.isGalois` and
`CyclotomicField.algebraBase` are lemmas, but they can be made local instances. Some of them are
included in the `Cyclotomic` locale.

-/


open Polynomial Algebra FiniteDimensional Set

open scoped BigOperators

universe u v w z

variable (n : ‚Ñï+) (S T : Set ‚Ñï+) (A : Type u) (B : Type v) (K : Type w) (L : Type z)

variable [CommRing A] [CommRing B] [Algebra A B]

variable [Field K] [Field L] [Algebra K L]

noncomputable section

/-- Given an `A`-algebra `B` and `S : Set ‚Ñï+`, we define `IsCyclotomicExtension S A B` requiring
that there is an `n`-th primitive root of unity in `B` for all `n ‚àà S` and that `B` is generated
over `A` by the roots of `X ^ n - 1`. -/

@[mk_iff]
class IsCyclotomicExtension : Prop where
  /-- For all `n ‚àà S`, there exists a primitive `n`-th root of unity in `B`. -/
  exists_prim_root {n : ‚Ñï+} (ha : n ‚àà S) : ‚àÉ r : B, IsPrimitiveRoot r n
  /-- The `n`-th roots of unity, for `n ‚àà S`, generate `B` as an `A`-algebra. -/
  adjoin_roots : ‚àÄ x : B, x ‚àà adjoin A {b : B | ‚àÉ n : ‚Ñï+, n ‚àà S ‚àß b ^ (n : ‚Ñï) = 1}
#align is_cyclotomic_extension IsCyclotomicExtension

namespace IsCyclotomicExtension

section Basic

/-- A reformulation of `IsCyclotomicExtension` that uses `‚ä§`. -/
theorem iff_adjoin_eq_top :
    IsCyclotomicExtension S A B ‚Üî
      (‚àÄ n : ‚Ñï+, n ‚àà S ‚Üí ‚àÉ r : B, IsPrimitiveRoot r n) ‚àß
        adjoin A {b : B | ‚àÉ n : ‚Ñï+, n ‚àà S ‚àß b ^ (n : ‚Ñï) = 1} = ‚ä§ :=
  ‚ü®fun h => ‚ü®fun _ => h.exists_prim_root, Algebra.eq_top_iff.2 h.adjoin_roots‚ü©, fun h =>
    ‚ü®h.1 _, Algebra.eq_top_iff.1 h.2‚ü©‚ü©
#align is_cyclotomic_extension.iff_adjoin_eq_top IsCyclotomicExtension.iff_adjoin_eq_top

/-- A reformulation of `IsCyclotomicExtension` in the case `S` is a singleton. -/
theorem iff_singleton :
    IsCyclotomicExtension {n} A B ‚Üî
      (‚àÉ r : B, IsPrimitiveRoot r n) ‚àß ‚àÄ x, x ‚àà adjoin A {b : B | b ^ (n : ‚Ñï) = 1} :=
  by simp [IsCyclotomicExtension_iff]
     -- üéâ no goals
#align is_cyclotomic_extension.iff_singleton IsCyclotomicExtension.iff_singleton

/-- If `IsCyclotomicExtension ‚àÖ A B`, then the image of `A` in `B` equals `B`. -/
theorem empty [h : IsCyclotomicExtension ‚àÖ A B] : (‚ä• : Subalgebra A B) = ‚ä§ := by
  simpa [Algebra.eq_top_iff, IsCyclotomicExtension_iff] using h
  -- üéâ no goals
#align is_cyclotomic_extension.empty IsCyclotomicExtension.empty

/-- If `IsCyclotomicExtension {1} A B`, then the image of `A` in `B` equals `B`. -/
theorem singleton_one [h : IsCyclotomicExtension {1} A B] : (‚ä• : Subalgebra A B) = ‚ä§ :=
  Algebra.eq_top_iff.2 fun x => by
    simpa [adjoin_singleton_one] using ((IsCyclotomicExtension_iff _ _ _).1 h).2 x
    -- üéâ no goals
#align is_cyclotomic_extension.singleton_one IsCyclotomicExtension.singleton_one

variable {A B}

/-- If `(‚ä• : SubAlgebra A B) = ‚ä§`, then `IsCyclotomicExtension ‚àÖ A B`. -/
theorem singleton_zero_of_bot_eq_top (h : (‚ä• : Subalgebra A B) = ‚ä§) :
    IsCyclotomicExtension ‚àÖ A B := by
-- Porting note: Lean3 is able to infer `A`.
  refine' (iff_adjoin_eq_top _ A _).2
    ‚ü®fun s hs => by simp at hs, _root_.eq_top_iff.2 fun x hx => _‚ü©
  rw [‚Üê h] at hx
  -- ‚ä¢ x ‚àà adjoin A {b | ‚àÉ n, n ‚àà ‚àÖ ‚àß b ^ ‚Üën = 1}
  simpa using hx
  -- üéâ no goals
#align is_cyclotomic_extension.singleton_zero_of_bot_eq_top IsCyclotomicExtension.singleton_zero_of_bot_eq_top

variable (A B)

/-- Transitivity of cyclotomic extensions. -/
theorem trans (C : Type w) [CommRing C] [Algebra A C] [Algebra B C] [IsScalarTower A B C]
    [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C]
    (h : Function.Injective (algebraMap B C)) : IsCyclotomicExtension (S ‚à™ T) A C := by
  refine' ‚ü®fun hn => _, fun x => _‚ü©
  -- ‚ä¢ ‚àÉ r, IsPrimitiveRoot r ‚Üën‚úù
  ¬∑ cases' hn with hn hn
    -- ‚ä¢ ‚àÉ r, IsPrimitiveRoot r ‚Üën‚úù
    ¬∑ obtain ‚ü®b, hb‚ü© := ((IsCyclotomicExtension_iff _ _ _).1 hS).1 hn
      -- ‚ä¢ ‚àÉ r, IsPrimitiveRoot r ‚Üën‚úù
      refine' ‚ü®algebraMap B C b, _‚ü©
      -- ‚ä¢ IsPrimitiveRoot (‚Üë(algebraMap B C) b) ‚Üën‚úù
      exact hb.map_of_injective h
      -- üéâ no goals
    ¬∑ exact ((IsCyclotomicExtension_iff _ _ _).1 hT).1 hn
      -- üéâ no goals
  ¬∑ refine' adjoin_induction (((IsCyclotomicExtension_iff T B _).1 hT).2 x)
      (fun c ‚ü®n, hn‚ü© => subset_adjoin ‚ü®n, Or.inr hn.1, hn.2‚ü©) (fun b => _)
      (fun x y hx hy => Subalgebra.add_mem _ hx hy) fun x y hx hy => Subalgebra.mul_mem _ hx hy
    ¬∑ let f := IsScalarTower.toAlgHom A B C
      -- ‚ä¢ ‚Üë(algebraMap B C) b ‚àà adjoin A {b | ‚àÉ n, n ‚àà S ‚à™ T ‚àß b ^ ‚Üën = 1}
      have hb : f b ‚àà (adjoin A {b : B | ‚àÉ a : ‚Ñï+, a ‚àà S ‚àß b ^ (a : ‚Ñï) = 1}).map f :=
        ‚ü®b, ((IsCyclotomicExtension_iff _ _ _).1 hS).2 b, rfl‚ü©
      rw [IsScalarTower.toAlgHom_apply, ‚Üê adjoin_image] at hb
      -- ‚ä¢ ‚Üë(algebraMap B C) b ‚àà adjoin A {b | ‚àÉ n, n ‚àà S ‚à™ T ‚àß b ^ ‚Üën = 1}
      refine' adjoin_mono (fun y hy => _) hb
      -- ‚ä¢ y ‚àà {b | ‚àÉ n, n ‚àà S ‚à™ T ‚àß b ^ ‚Üën = 1}
      obtain ‚ü®b‚ÇÅ, ‚ü®‚ü®n, hn‚ü©, h‚ÇÅ‚ü©‚ü© := hy
      -- ‚ä¢ y ‚àà {b | ‚àÉ n, n ‚àà S ‚à™ T ‚àß b ^ ‚Üën = 1}
      exact ‚ü®n, ‚ü®mem_union_left T hn.1, by rw [‚Üê h‚ÇÅ, ‚Üê AlgHom.map_pow, hn.2, AlgHom.map_one]‚ü©‚ü©
      -- üéâ no goals
#align is_cyclotomic_extension.trans IsCyclotomicExtension.trans

@[nontriviality]
theorem subsingleton_iff [Subsingleton B] : IsCyclotomicExtension S A B ‚Üî S = { } ‚à® S = {1} := by
  constructor
  -- ‚ä¢ IsCyclotomicExtension S A B ‚Üí S = ‚àÖ ‚à® S = {1}
  ¬∑ rintro ‚ü®hprim, -‚ü©
    -- ‚ä¢ S = ‚àÖ ‚à® S = {1}
    rw [‚Üê subset_singleton_iff_eq]
    -- ‚ä¢ S ‚äÜ {1}
    intro t ht
    -- ‚ä¢ t ‚àà {1}
    obtain ‚ü®Œ∂, hŒ∂‚ü© := hprim ht
    -- ‚ä¢ t ‚àà {1}
    rw [mem_singleton_iff, ‚Üê PNat.coe_eq_one_iff]
    -- ‚ä¢ ‚Üët = 1
    exact_mod_cast hŒ∂.unique (IsPrimitiveRoot.of_subsingleton Œ∂)
    -- üéâ no goals
  ¬∑ rintro (rfl | rfl)
    -- ‚ä¢ IsCyclotomicExtension ‚àÖ A B
-- Porting note: `R := A` was not needed.
    ¬∑ exact ‚ü®fun h => h.elim, fun x => by convert (mem_top (R := A) : x ‚àà ‚ä§)‚ü©
      -- üéâ no goals
    ¬∑ rw [iff_singleton]
      -- ‚ä¢ (‚àÉ r, IsPrimitiveRoot r ‚Üë1) ‚àß ‚àÄ (x : B), x ‚àà adjoin A {b | b ^ ‚Üë1 = 1}
      exact ‚ü®‚ü®0, IsPrimitiveRoot.of_subsingleton 0‚ü©,
        fun x => by convert (mem_top (R := A) : x ‚àà ‚ä§)‚ü©
#align is_cyclotomic_extension.subsingleton_iff IsCyclotomicExtension.subsingleton_iff

/-- If `B` is a cyclotomic extension of `A` given by roots of unity of order in `S ‚à™ T`, then `B`
is a cyclotomic extension of `adjoin A { b : B | ‚àÉ a : ‚Ñï+, a ‚àà S ‚àß b ^ (a : ‚Ñï) = 1 } ` given by
roots of unity of order in `T`. -/
theorem union_right [h : IsCyclotomicExtension (S ‚à™ T) A B] :
    IsCyclotomicExtension T (adjoin A {b : B | ‚àÉ a : ‚Ñï+, a ‚àà S ‚àß b ^ (a : ‚Ñï) = 1}) B := by
  have : {b : B | ‚àÉ n : ‚Ñï+, n ‚àà S ‚à™ T ‚àß b ^ (n : ‚Ñï) = 1} =
      {b : B | ‚àÉ n : ‚Ñï+, n ‚àà S ‚àß b ^ (n : ‚Ñï) = 1} ‚à™
        {b : B | ‚àÉ n : ‚Ñï+, n ‚àà T ‚àß b ^ (n : ‚Ñï) = 1} := by
    refine' le_antisymm _ _
    ¬∑ rintro x ‚ü®n, hn‚ÇÅ | hn‚ÇÇ, hnpow‚ü©
      ¬∑ left; exact ‚ü®n, hn‚ÇÅ, hnpow‚ü©
      ¬∑ right; exact ‚ü®n, hn‚ÇÇ, hnpow‚ü©
    ¬∑ rintro x (‚ü®n, hn‚ü© | ‚ü®n, hn‚ü©)
      ¬∑ exact ‚ü®n, Or.inl hn.1, hn.2‚ü©
      ¬∑ exact ‚ü®n, Or.inr hn.1, hn.2‚ü©
  refine' ‚ü®fun hn => ((IsCyclotomicExtension_iff _ A _).1 h).1 (mem_union_right S hn), fun b => _‚ü©
  -- ‚ä¢ b ‚àà adjoin { x // x ‚àà adjoin A {b | ‚àÉ a, a ‚àà S ‚àß b ^ ‚Üëa = 1} } {b | ‚àÉ n, n ‚àà ‚Ä¶
  replace h := ((IsCyclotomicExtension_iff _ _ _).1 h).2 b
  -- ‚ä¢ b ‚àà adjoin { x // x ‚àà adjoin A {b | ‚àÉ a, a ‚àà S ‚àß b ^ ‚Üëa = 1} } {b | ‚àÉ n, n ‚àà ‚Ä¶
  rwa [this, adjoin_union_eq_adjoin_adjoin, Subalgebra.mem_restrictScalars] at h
  -- üéâ no goals
#align is_cyclotomic_extension.union_right IsCyclotomicExtension.union_right

/-- If `B` is a cyclotomic extension of `A` given by roots of unity of order in `T` and `S ‚äÜ T`,
then `adjoin A { b : B | ‚àÉ a : ‚Ñï+, a ‚àà S ‚àß b ^ (a : ‚Ñï) = 1 }` is a cyclotomic extension of `B`
given by roots of unity of order in `S`. -/
theorem union_left [h : IsCyclotomicExtension T A B] (hS : S ‚äÜ T) :
    IsCyclotomicExtension S A (adjoin A {b : B | ‚àÉ a : ‚Ñï+, a ‚àà S ‚àß b ^ (a : ‚Ñï) = 1}) := by
  refine' ‚ü®@fun n hn => _, fun b => _‚ü©
  -- ‚ä¢ ‚àÉ r, IsPrimitiveRoot r ‚Üën
  ¬∑ obtain ‚ü®b, hb‚ü© := ((IsCyclotomicExtension_iff _ _ _).1 h).1 (hS hn)
    -- ‚ä¢ ‚àÉ r, IsPrimitiveRoot r ‚Üën
    refine' ‚ü®‚ü®b, subset_adjoin ‚ü®n, hn, hb.pow_eq_one‚ü©‚ü©, _‚ü©
    -- ‚ä¢ IsPrimitiveRoot { val := b, property := (_ : b ‚àà ‚Üë(adjoin A {b | ‚àÉ a, a ‚àà S  ‚Ä¶
    rwa [‚Üê IsPrimitiveRoot.coe_submonoidClass_iff, Subtype.coe_mk]
    -- üéâ no goals
  ¬∑ convert mem_top (R := A) (x := b)
    -- ‚ä¢ adjoin A {b | ‚àÉ n, n ‚àà S ‚àß b ^ ‚Üën = 1} = ‚ä§
    rw [‚Üê adjoin_adjoin_coe_preimage, preimage_setOf_eq]
    -- ‚ä¢ adjoin A {b | ‚àÉ n, n ‚àà S ‚àß b ^ ‚Üën = 1} = adjoin A {a | ‚àÉ a_1, a_1 ‚àà S ‚àß ‚Üëa ^ ‚Ä¶
    norm_cast
    -- üéâ no goals
#align is_cyclotomic_extension.union_left IsCyclotomicExtension.union_left

variable {n S}

/-- If `‚àÄ s ‚àà S, n ‚à£ s` and `S` is not empty, then `IsCyclotomicExtension S A B` implies
`IsCyclotomicExtension (S ‚à™ {n}) A B`. -/
theorem of_union_of_dvd (h : ‚àÄ s ‚àà S, n ‚à£ s) (hS : S.Nonempty) [H : IsCyclotomicExtension S A B] :
    IsCyclotomicExtension (S ‚à™ {n}) A B := by
  refine' (iff_adjoin_eq_top _ A _).2 ‚ü®fun s hs => _, _‚ü©
  -- ‚ä¢ ‚àÉ r, IsPrimitiveRoot r ‚Üës
  ¬∑ rw [mem_union, mem_singleton_iff] at hs
    -- ‚ä¢ ‚àÉ r, IsPrimitiveRoot r ‚Üës
    obtain hs | rfl := hs
    -- ‚ä¢ ‚àÉ r, IsPrimitiveRoot r ‚Üës
    ¬∑ exact H.exists_prim_root hs
      -- üéâ no goals
    ¬∑ obtain ‚ü®m, hm‚ü© := hS
      -- ‚ä¢ ‚àÉ r, IsPrimitiveRoot r ‚Üës
      obtain ‚ü®x, rfl‚ü© := h m hm
      -- ‚ä¢ ‚àÉ r, IsPrimitiveRoot r ‚Üës
      obtain ‚ü®Œ∂, hŒ∂‚ü© := H.exists_prim_root hm
      -- ‚ä¢ ‚àÉ r, IsPrimitiveRoot r ‚Üës
      refine' ‚ü®Œ∂ ^ (x : ‚Ñï), _‚ü©
      -- ‚ä¢ IsPrimitiveRoot (Œ∂ ^ ‚Üëx) ‚Üës
      convert hŒ∂.pow_of_dvd x.ne_zero (dvd_mul_left (x : ‚Ñï) s)
      -- ‚ä¢ ‚Üës = ‚Üë(s * x) / ‚Üëx
      simp only [PNat.mul_coe, Nat.mul_div_left, PNat.pos]
      -- üéâ no goals
  ¬∑ refine' _root_.eq_top_iff.2 _
    -- ‚ä¢ ‚ä§ ‚â§ adjoin A {b | ‚àÉ n_1, n_1 ‚àà S ‚à™ {n} ‚àß b ^ ‚Üën_1 = 1}
    rw [‚Üê ((iff_adjoin_eq_top S A B).1 H).2]
    -- ‚ä¢ adjoin A {b | ‚àÉ n, n ‚àà S ‚àß b ^ ‚Üën = 1} ‚â§ adjoin A {b | ‚àÉ n_1, n_1 ‚àà S ‚à™ {n}  ‚Ä¶
    refine' adjoin_mono fun x hx => _
    -- ‚ä¢ x ‚àà {b | ‚àÉ n_1, n_1 ‚àà S ‚à™ {n} ‚àß b ^ ‚Üën_1 = 1}
    simp only [union_singleton, mem_insert_iff, mem_setOf_eq] at hx ‚ä¢
    -- ‚ä¢ ‚àÉ n_1, (n_1 = n ‚à® n_1 ‚àà S) ‚àß x ^ ‚Üën_1 = 1
    obtain ‚ü®m, hm‚ü© := hx
    -- ‚ä¢ ‚àÉ n_1, (n_1 = n ‚à® n_1 ‚àà S) ‚àß x ^ ‚Üën_1 = 1
    exact ‚ü®m, ‚ü®Or.inr hm.1, hm.2‚ü©‚ü©
    -- üéâ no goals
#align is_cyclotomic_extension.of_union_of_dvd IsCyclotomicExtension.of_union_of_dvd

/-- If `‚àÄ s ‚àà S, n ‚à£ s` and `S` is not empty, then `IsCyclotomicExtension S A B` if and only if
`IsCyclotomicExtension (S ‚à™ {n}) A B`. -/
theorem iff_union_of_dvd (h : ‚àÄ s ‚àà S, n ‚à£ s) (hS : S.Nonempty) :
    IsCyclotomicExtension S A B ‚Üî IsCyclotomicExtension (S ‚à™ {n}) A B := by
  refine'
    ‚ü®fun H => of_union_of_dvd A B h hS, fun H => (iff_adjoin_eq_top _ A _).2 ‚ü®fun s hs => _, _‚ü©‚ü©
  ¬∑ exact H.exists_prim_root (subset_union_left _ _ hs)
    -- üéâ no goals
  ¬∑ rw [_root_.eq_top_iff, ‚Üê ((iff_adjoin_eq_top _ A B).1 H).2]
    -- ‚ä¢ adjoin A {b | ‚àÉ n_1, n_1 ‚àà S ‚à™ {n} ‚àß b ^ ‚Üën_1 = 1} ‚â§ adjoin A {b | ‚àÉ n, n ‚àà  ‚Ä¶
    refine' adjoin_mono fun x hx => _
    -- ‚ä¢ x ‚àà {b | ‚àÉ n, n ‚àà S ‚àß b ^ ‚Üën = 1}
    simp only [union_singleton, mem_insert_iff, mem_setOf_eq] at hx ‚ä¢
    -- ‚ä¢ ‚àÉ n, n ‚àà S ‚àß x ^ ‚Üën = 1
    obtain ‚ü®m, rfl | hm, hxpow‚ü© := hx
    -- ‚ä¢ ‚àÉ n, n ‚àà S ‚àß x ^ ‚Üën = 1
    ¬∑ obtain ‚ü®y, hy‚ü© := hS
      -- ‚ä¢ ‚àÉ n, n ‚àà S ‚àß x ^ ‚Üën = 1
      refine' ‚ü®y, ‚ü®hy, _‚ü©‚ü©
      -- ‚ä¢ x ^ ‚Üëy = 1
      obtain ‚ü®z, rfl‚ü© := h y hy
      -- ‚ä¢ x ^ ‚Üë(m * z) = 1
      simp only [PNat.mul_coe, pow_mul, hxpow, one_pow]
      -- üéâ no goals
    ¬∑ exact ‚ü®m, ‚ü®hm, hxpow‚ü©‚ü©
      -- üéâ no goals
#align is_cyclotomic_extension.iff_union_of_dvd IsCyclotomicExtension.iff_union_of_dvd

variable (n S)

/-- `IsCyclotomicExtension S A B` is equivalent to `IsCyclotomicExtension (S ‚à™ {1}) A B`. -/
theorem iff_union_singleton_one :
    IsCyclotomicExtension S A B ‚Üî IsCyclotomicExtension (S ‚à™ {1}) A B := by
  obtain hS | rfl := S.eq_empty_or_nonempty.symm
  -- ‚ä¢ IsCyclotomicExtension S A B ‚Üî IsCyclotomicExtension (S ‚à™ {1}) A B
  ¬∑ exact iff_union_of_dvd _ _ (fun s _ => one_dvd _) hS
    -- üéâ no goals
  rw [empty_union]
  -- ‚ä¢ IsCyclotomicExtension ‚àÖ A B ‚Üî IsCyclotomicExtension {1} A B
  refine' ‚ü®fun H => _, fun H => _‚ü©
  -- ‚ä¢ IsCyclotomicExtension {1} A B
  ¬∑ refine' (iff_adjoin_eq_top _ A _).2 ‚ü®fun s hs => ‚ü®1, by simp [mem_singleton_iff.1 hs]‚ü©, _‚ü©
    -- ‚ä¢ adjoin A {b | ‚àÉ n, n ‚àà {1} ‚àß b ^ ‚Üën = 1} = ‚ä§
    simp [adjoin_singleton_one, empty]
    -- üéâ no goals
  ¬∑ refine' (iff_adjoin_eq_top _ A _).2 ‚ü®fun s hs => (not_mem_empty s hs).elim, _‚ü©
    -- ‚ä¢ adjoin A {b | ‚àÉ n, n ‚àà ‚àÖ ‚àß b ^ ‚Üën = 1} = ‚ä§
    simp [@singleton_one A B _ _ _ H]
    -- üéâ no goals
#align is_cyclotomic_extension.iff_union_singleton_one IsCyclotomicExtension.iff_union_singleton_one

variable {A B}

/-- If `(‚ä• : SubAlgebra A B) = ‚ä§`, then `IsCyclotomicExtension {1} A B`. -/
theorem singleton_one_of_bot_eq_top (h : (‚ä• : Subalgebra A B) = ‚ä§) :
    IsCyclotomicExtension {1} A B := by
  convert (iff_union_singleton_one _ A _).1 (singleton_zero_of_bot_eq_top h)
  -- ‚ä¢ {1} = ‚àÖ ‚à™ {1}
  simp
  -- üéâ no goals
#align is_cyclotomic_extension.singleton_one_of_bot_eq_top IsCyclotomicExtension.singleton_one_of_bot_eq_top

/-- If `Function.Surjective (algebraMap A B)`, then `IsCyclotomicExtension {1} A B`. -/
theorem singleton_one_of_algebraMap_bijective (h : Function.Surjective (algebraMap A B)) :
    IsCyclotomicExtension {1} A B :=
  singleton_one_of_bot_eq_top (surjective_algebraMap_iff.1 h).symm
#align is_cyclotomic_extension.singleton_one_of_algebra_map_bijective IsCyclotomicExtension.singleton_one_of_algebraMap_bijective

variable (A B)

/-- Given `(f : B ‚âÉ‚Çê[A] C)`, if `IsCyclotomicExtension S A B` then
`IsCyclotomicExtension S A C`. -/
protected
theorem equiv {C : Type*} [CommRing C] [Algebra A C] [h : IsCyclotomicExtension S A B]
    (f : B ‚âÉ‚Çê[A] C) : IsCyclotomicExtension S A C := by
  letI : Algebra B C := f.toAlgHom.toRingHom.toAlgebra
  -- ‚ä¢ IsCyclotomicExtension S A C
  haveI : IsCyclotomicExtension {1} B C := singleton_one_of_algebraMap_bijective f.surjective
  -- ‚ä¢ IsCyclotomicExtension S A C
  haveI : IsScalarTower A B C := IsScalarTower.of_ring_hom f.toAlgHom
  -- ‚ä¢ IsCyclotomicExtension S A C
  exact (iff_union_singleton_one _ _ _).2 (trans S {1} A B C f.injective)
  -- üéâ no goals
#align is_cyclotomic_extension.equiv IsCyclotomicExtension.equiv

protected
theorem neZero [h : IsCyclotomicExtension {n} A B] [IsDomain B] : NeZero ((n : ‚Ñï) : B) := by
  obtain ‚ü®‚ü®r, hr‚ü©, -‚ü© := (iff_singleton n A B).1 h
  -- ‚ä¢ NeZero ‚Üë‚Üën
  exact hr.neZero'
  -- üéâ no goals
#align is_cyclotomic_extension.ne_zero IsCyclotomicExtension.neZero

protected
theorem neZero' [IsCyclotomicExtension {n} A B] [IsDomain B] : NeZero ((n : ‚Ñï) : A) := by
  haveI := IsCyclotomicExtension.neZero n A B
  -- ‚ä¢ NeZero ‚Üë‚Üën
  exact NeZero.nat_of_neZero (algebraMap A B)
  -- üéâ no goals
#align is_cyclotomic_extension.ne_zero' IsCyclotomicExtension.neZero'

end Basic

section Fintype

theorem finite_of_singleton [IsDomain B] [h : IsCyclotomicExtension {n} A B] :
    Module.Finite A B := by
  classical
  rw [Module.finite_def, ‚Üê top_toSubmodule, ‚Üê ((iff_adjoin_eq_top _ _ _).1 h).2]
  refine' FG_adjoin_of_finite _ fun b hb => _
  ¬∑ simp only [mem_singleton_iff, exists_eq_left]
    have : {b : B | b ^ (n : ‚Ñï) = 1} = (nthRoots n (1 : B)).toFinset :=
      Set.ext fun x => ‚ü®fun h => by simpa using h, fun h => by simpa using h‚ü©
    rw [this]
    exact (nthRoots (‚Üën) 1).toFinset.finite_toSet
  ¬∑ simp only [mem_singleton_iff, exists_eq_left, mem_setOf_eq] at hb
    refine' ‚ü®X ^ (n : ‚Ñï) - 1, ‚ü®monic_X_pow_sub_C _ n.pos.ne.symm, by simp [hb]‚ü©‚ü©
#align is_cyclotomic_extension.finite_of_singleton IsCyclotomicExtension.finite_of_singleton

/-- If `S` is finite and `IsCyclotomicExtension S A B`, then `B` is a finite `A`-algebra. -/
protected
theorem finite [IsDomain B] [h‚ÇÅ : Finite S] [h‚ÇÇ : IsCyclotomicExtension S A B] :
    Module.Finite A B := by
  cases' nonempty_fintype S with h
  -- ‚ä¢ Module.Finite A B
  revert h‚ÇÇ A B
  -- ‚ä¢ ‚àÄ (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_ ‚Ä¶
  refine' Set.Finite.induction_on (Set.Finite.intro h) (fun A B => _) @fun n S _ _ H A B => _
  -- ‚ä¢ ‚àÄ [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] [inst_3 : ‚Ä¶
  ¬∑ intro _ _ _ _ _
    -- ‚ä¢ Module.Finite A B
    refine' Module.finite_def.2 ‚ü®({1} : Finset B), _‚ü©
    -- ‚ä¢ Submodule.span A ‚Üë{1} = ‚ä§
    simp [‚Üê top_toSubmodule, ‚Üê empty, toSubmodule_bot]
    -- üéâ no goals
  ¬∑ intro _ _ _ _ h
    -- ‚ä¢ Module.Finite A B
    haveI : IsCyclotomicExtension S A (adjoin A {b : B | ‚àÉ n : ‚Ñï+, n ‚àà S ‚àß b ^ (n : ‚Ñï) = 1}) :=
      union_left _ (insert n S) _ _ (subset_insert n S)
    haveI := H A (adjoin A {b : B | ‚àÉ n : ‚Ñï+, n ‚àà S ‚àß b ^ (n : ‚Ñï) = 1})
    -- ‚ä¢ Module.Finite A B
    have : Module.Finite (adjoin A {b : B | ‚àÉ n : ‚Ñï+, n ‚àà S ‚àß b ^ (n : ‚Ñï) = 1}) B := by
      rw [‚Üê union_singleton] at h
      letI := @union_right S {n} A B _ _ _ h
      exact finite_of_singleton n _ _
    exact Module.Finite.trans (adjoin A {b : B | ‚àÉ n : ‚Ñï+, n ‚àà S ‚àß b ^ (n : ‚Ñï) = 1}) _
    -- üéâ no goals
#align is_cyclotomic_extension.finite IsCyclotomicExtension.finite

/-- A cyclotomic finite extension of a number field is a number field. -/
theorem numberField [h : NumberField K] [Finite S] [IsCyclotomicExtension S K L] : NumberField L :=
  { to_charZero := charZero_of_injective_algebraMap (algebraMap K L).injective
    to_finiteDimensional := by
      haveI := charZero_of_injective_algebraMap (algebraMap K L).injective
      -- ‚ä¢ FiniteDimensional ‚Ñö L
      haveI := IsCyclotomicExtension.finite S K L
      -- ‚ä¢ FiniteDimensional ‚Ñö L
      exact Module.Finite.trans K _ }
      -- üéâ no goals
#align is_cyclotomic_extension.number_field IsCyclotomicExtension.numberField

/-- A finite cyclotomic extension of an integral noetherian domain is integral -/
theorem integral [IsDomain B] [IsNoetherianRing A] [Finite S] [IsCyclotomicExtension S A B] :
    Algebra.IsIntegral A B :=
  letI := IsCyclotomicExtension.finite S A B; isIntegral_of_noetherian <|
    isNoetherian_of_isNoetherianRing_of_finite A B
#align is_cyclotomic_extension.integral IsCyclotomicExtension.integral

/-- If `S` is finite and `IsCyclotomicExtension S K A`, then `finiteDimensional K A`. -/
theorem finiteDimensional (C : Type z) [Finite S] [CommRing C] [Algebra K C] [IsDomain C]
    [IsCyclotomicExtension S K C] : FiniteDimensional K C :=
  IsCyclotomicExtension.finite S K C
#align is_cyclotomic_extension.finite_dimensional IsCyclotomicExtension.finiteDimensional

end Fintype

section

variable {A B}

theorem adjoin_roots_cyclotomic_eq_adjoin_nth_roots [IsDomain B] {Œ∂ : B} {n : ‚Ñï+}
    (hŒ∂ : IsPrimitiveRoot Œ∂ n) :
    adjoin A ((cyclotomic n A).rootSet B) =
      adjoin A {b : B | ‚àÉ a : ‚Ñï+, a ‚àà ({n} : Set ‚Ñï+) ‚àß b ^ (a : ‚Ñï) = 1} := by
  simp only [mem_singleton_iff, exists_eq_left, map_cyclotomic]
  -- ‚ä¢ adjoin A (rootSet (cyclotomic (‚Üën) A) B) = adjoin A {b | b ^ ‚Üën = 1}
  refine' le_antisymm (adjoin_mono fun x hx => _) (adjoin_le fun x hx => _)
  -- ‚ä¢ x ‚àà {b | b ^ ‚Üën = 1}
  ¬∑ rw [mem_rootSet'] at hx
    -- ‚ä¢ x ‚àà {b | b ^ ‚Üën = 1}
    simp only [mem_singleton_iff, exists_eq_left, mem_setOf_eq]
    -- ‚ä¢ x ^ ‚Üën = 1
    rw [isRoot_of_unity_iff n.pos]
    -- ‚ä¢ ‚àÉ i, i ‚àà Nat.divisors ‚Üën ‚àß IsRoot (cyclotomic i B) x
    refine' ‚ü®n, Nat.mem_divisors_self n n.ne_zero, _‚ü©
    -- ‚ä¢ IsRoot (cyclotomic (‚Üën) B) x
    rw [IsRoot.def, ‚Üê map_cyclotomic n (algebraMap A B), eval_map, ‚Üê aeval_def]
    -- ‚ä¢ ‚Üë(aeval x) (cyclotomic (‚Üën) A) = 0
    exact hx.2
    -- üéâ no goals
  ¬∑ simp only [mem_singleton_iff, exists_eq_left, mem_setOf_eq] at hx
    -- ‚ä¢ x ‚àà ‚Üë(adjoin A (rootSet (cyclotomic (‚Üën) A) B))
    obtain ‚ü®i, _, rfl‚ü© := hŒ∂.eq_pow_of_pow_eq_one hx n.pos
    -- ‚ä¢ Œ∂ ^ i ‚àà ‚Üë(adjoin A (rootSet (cyclotomic (‚Üën) A) B))
    refine' SetLike.mem_coe.2 (Subalgebra.pow_mem _ (subset_adjoin _) _)
    -- ‚ä¢ Œ∂ ‚àà rootSet (cyclotomic (‚Üën) A) B
    rw [mem_rootSet', map_cyclotomic, aeval_def, ‚Üê eval_map, map_cyclotomic, ‚Üê IsRoot]
    -- ‚ä¢ cyclotomic (‚Üën) B ‚â† 0 ‚àß IsRoot (cyclotomic (‚Üën) B) Œ∂
    refine' ‚ü®cyclotomic_ne_zero n B, hŒ∂.isRoot_cyclotomic n.pos‚ü©
    -- üéâ no goals
#align is_cyclotomic_extension.adjoin_roots_cyclotomic_eq_adjoin_nth_roots IsCyclotomicExtension.adjoin_roots_cyclotomic_eq_adjoin_nth_roots

theorem adjoin_roots_cyclotomic_eq_adjoin_root_cyclotomic {n : ‚Ñï+} [IsDomain B] {Œ∂ : B}
    (hŒ∂ : IsPrimitiveRoot Œ∂ n) : adjoin A ((cyclotomic n A).rootSet B) = adjoin A {Œ∂} := by
  refine' le_antisymm (adjoin_le fun x hx => _) (adjoin_mono fun x hx => _)
  -- ‚ä¢ x ‚àà ‚Üë(adjoin A {Œ∂})
  ¬∑ suffices hx : x ^ n.1 = 1
    -- ‚ä¢ x ‚àà ‚Üë(adjoin A {Œ∂})
    obtain ‚ü®i, _, rfl‚ü© := hŒ∂.eq_pow_of_pow_eq_one hx n.pos
    -- ‚ä¢ Œ∂ ^ i ‚àà ‚Üë(adjoin A {Œ∂})
    exact SetLike.mem_coe.2 (Subalgebra.pow_mem _ (subset_adjoin <| mem_singleton Œ∂) _)
    -- ‚ä¢ x ^ ‚Üën = 1
    refine' (isRoot_of_unity_iff n.pos B).2 _
    -- ‚ä¢ ‚àÉ i, i ‚àà Nat.divisors ‚Üën ‚àß IsRoot (cyclotomic i B) x
    refine' ‚ü®n, Nat.mem_divisors_self n n.ne_zero, _‚ü©
    -- ‚ä¢ IsRoot (cyclotomic (‚Üën) B) x
    rw [mem_rootSet', aeval_def, ‚Üê eval_map, map_cyclotomic, ‚Üê IsRoot] at hx
    -- ‚ä¢ IsRoot (cyclotomic (‚Üën) B) x
    exact hx.2
    -- üéâ no goals
  ¬∑ simp only [mem_singleton_iff, exists_eq_left, mem_setOf_eq] at hx
    -- ‚ä¢ x ‚àà rootSet (cyclotomic (‚Üën) A) B
    simpa only [hx, mem_rootSet', map_cyclotomic, aeval_def, ‚Üê eval_map, IsRoot] using
      And.intro (cyclotomic_ne_zero n B) (hŒ∂.isRoot_cyclotomic n.pos)
#align is_cyclotomic_extension.adjoin_roots_cyclotomic_eq_adjoin_root_cyclotomic IsCyclotomicExtension.adjoin_roots_cyclotomic_eq_adjoin_root_cyclotomic

theorem adjoin_primitive_root_eq_top {n : ‚Ñï+} [IsDomain B] [h : IsCyclotomicExtension {n} A B]
    {Œ∂ : B} (hŒ∂ : IsPrimitiveRoot Œ∂ n) : adjoin A ({Œ∂} : Set B) = ‚ä§ := by
  classical
  rw [‚Üê adjoin_roots_cyclotomic_eq_adjoin_root_cyclotomic hŒ∂]
  rw [adjoin_roots_cyclotomic_eq_adjoin_nth_roots hŒ∂]
  exact ((iff_adjoin_eq_top {n} A B).mp h).2
#align is_cyclotomic_extension.adjoin_primitive_root_eq_top IsCyclotomicExtension.adjoin_primitive_root_eq_top

variable (A)

theorem _root_.IsPrimitiveRoot.adjoin_isCyclotomicExtension {Œ∂ : B} {n : ‚Ñï+}
    (h : IsPrimitiveRoot Œ∂ n) : IsCyclotomicExtension {n} A (adjoin A ({Œ∂} : Set B)) :=
  { exists_prim_root := fun hi => by
      rw [Set.mem_singleton_iff] at hi
      -- ‚ä¢ ‚àÉ r, IsPrimitiveRoot r ‚Üën‚úù
      refine' ‚ü®‚ü®Œ∂, subset_adjoin <| Set.mem_singleton Œ∂‚ü©, _‚ü©
      -- ‚ä¢ IsPrimitiveRoot { val := Œ∂, property := (_ : Œ∂ ‚àà ‚Üë(adjoin A {Œ∂})) } ‚Üën‚úù
      rwa [‚Üê IsPrimitiveRoot.coe_submonoidClass_iff, Subtype.coe_mk, hi]
      -- üéâ no goals
    adjoin_roots := fun x => by
      refine
        adjoin_induction'
          (x := x) (fun b hb => ?_) (fun a => ?_) (fun b‚ÇÅ b‚ÇÇ hb‚ÇÅ hb‚ÇÇ => ?_)
          (fun b‚ÇÅ b‚ÇÇ hb‚ÇÅ hb‚ÇÇ => ?_)
      ¬∑ rw [Set.mem_singleton_iff] at hb
        -- ‚ä¢ { val := b, property := (_ : b ‚àà ‚Üë(adjoin A {Œ∂})) } ‚àà adjoin A {b | ‚àÉ n_1, n ‚Ä¶
        refine' subset_adjoin _
        -- ‚ä¢ { val := b, property := (_ : b ‚àà ‚Üë(adjoin A {Œ∂})) } ‚àà {b | ‚àÉ n_1, n_1 ‚àà {n}  ‚Ä¶
        simp only [mem_singleton_iff, exists_eq_left, mem_setOf_eq, hb]
        -- ‚ä¢ { val := Œ∂, property := (_ : (fun x => x ‚àà adjoin A {Œ∂}) Œ∂) } ^ ‚Üën = 1
        rw [‚Üê Subalgebra.coe_eq_one, Subalgebra.coe_pow, Subtype.coe_mk]
        -- ‚ä¢ Œ∂ ^ ‚Üën = 1
        exact ((IsPrimitiveRoot.iff_def Œ∂ n).1 h).1
        -- üéâ no goals
      ¬∑ exact Subalgebra.algebraMap_mem _ _
        -- üéâ no goals
      ¬∑ exact Subalgebra.add_mem _ hb‚ÇÅ hb‚ÇÇ
        -- üéâ no goals
      ¬∑ exact Subalgebra.mul_mem _ hb‚ÇÅ hb‚ÇÇ }
        -- üéâ no goals
#align is_primitive_root.adjoin_is_cyclotomic_extension IsPrimitiveRoot.adjoin_isCyclotomicExtension

end

section Field

variable {n S}

/-- A cyclotomic extension splits `X ^ n - 1` if `n ‚àà S`.-/
theorem splits_X_pow_sub_one [H : IsCyclotomicExtension S K L] (hS : n ‚àà S) :
    Splits (algebraMap K L) (X ^ (n : ‚Ñï) - 1) := by
  rw [‚Üê splits_id_iff_splits, Polynomial.map_sub, Polynomial.map_one, Polynomial.map_pow,
    Polynomial.map_X]
  obtain ‚ü®z, hz‚ü© := ((IsCyclotomicExtension_iff _ _ _).1 H).1 hS
  -- ‚ä¢ Splits (RingHom.id L) (X ^ ‚Üën - 1)
  exact X_pow_sub_one_splits hz
  -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align is_cyclotomic_extension.splits_X_pow_sub_one IsCyclotomicExtension.splits_X_pow_sub_one

/-- A cyclotomic extension splits `cyclotomic n K` if `n ‚àà S` and `ne_zero (n : K)`.-/
theorem splits_cyclotomic [IsCyclotomicExtension S K L] (hS : n ‚àà S) :
    Splits (algebraMap K L) (cyclotomic n K) := by
  refine' splits_of_splits_of_dvd _ (X_pow_sub_C_ne_zero n.pos _) (splits_X_pow_sub_one K L hS) _
  -- ‚ä¢ cyclotomic (‚Üën) K ‚à£ X ^ ‚Üën - ‚ÜëC 1
  use ‚àè i : ‚Ñï in (n : ‚Ñï).properDivisors, Polynomial.cyclotomic i K
  -- ‚ä¢ X ^ ‚Üën - ‚ÜëC 1 = cyclotomic (‚Üën) K * ‚àè i in Nat.properDivisors ‚Üën, cyclotomic ‚Ä¶
  rw [(eq_cyclotomic_iff n.pos _).1 rfl, RingHom.map_one]
  -- üéâ no goals
#align is_cyclotomic_extension.splits_cyclotomic IsCyclotomicExtension.splits_cyclotomic

variable (n S)

section Singleton

variable [IsCyclotomicExtension {n} K L]

/-- If `IsCyclotomicExtension {n} K L`, then `L` is the splitting field of `X ^ n - 1`. -/
theorem isSplittingField_X_pow_sub_one : IsSplittingField K L (X ^ (n : ‚Ñï) - 1) :=
  { splits' := splits_X_pow_sub_one K L (mem_singleton n)
    adjoin_rootSet' := by
      rw [‚Üê ((iff_adjoin_eq_top {n} K L).1 inferInstance).2]
      -- ‚ä¢ adjoin K (rootSet (X ^ ‚Üën - 1) L) = adjoin K {b | ‚àÉ n_1, n_1 ‚àà {n} ‚àß b ^ ‚Üën_ ‚Ä¶
      congr
      -- ‚ä¢ rootSet (X ^ ‚Üën - 1) L = {b | ‚àÉ n_1, n_1 ‚àà {n} ‚àß b ^ ‚Üën_1 = 1}
      refine' Set.ext fun x => _
      -- ‚ä¢ x ‚àà rootSet (X ^ ‚Üën - 1) L ‚Üî x ‚àà {b | ‚àÉ n_1, n_1 ‚àà {n} ‚àß b ^ ‚Üën_1 = 1}
      simp only [Polynomial.map_pow, mem_singleton_iff, Multiset.mem_toFinset, exists_eq_left,
        mem_setOf_eq, Polynomial.map_X, Polynomial.map_one, Finset.mem_coe, Polynomial.map_sub]
      simp only [mem_rootSet', map_sub, map_pow, aeval_one, aeval_X, sub_eq_zero, map_X,
        and_iff_right_iff_imp, Polynomial.map_sub, Polynomial.map_pow, Polynomial.map_one]
      exact fun _ => X_pow_sub_C_ne_zero n.pos (1 : L) }
      -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align is_cyclotomic_extension.splitting_field_X_pow_sub_one
       IsCyclotomicExtension.isSplittingField_X_pow_sub_one

/-- Any two `n`-th cyclotomic extensions are isomorphic. -/
def algEquiv (L' : Type*) [Field L'] [Algebra K L'] [IsCyclotomicExtension {n} K L'] :
    L ‚âÉ‚Çê[K] L' :=
  let h‚ÇÅ := isSplittingField_X_pow_sub_one n K L
  let h‚ÇÇ := isSplittingField_X_pow_sub_one n K L'
  (@IsSplittingField.algEquiv K L _ _ _ (X ^ (n : ‚Ñï) - 1) h‚ÇÅ).trans
    (@IsSplittingField.algEquiv K L' _ _ _ (X ^ (n : ‚Ñï) - 1) h‚ÇÇ).symm
#align is_cyclotomic_extension.alg_equiv IsCyclotomicExtension.algEquiv

scoped[Cyclotomic] attribute [instance] IsCyclotomicExtension.isSplittingField_X_pow_sub_one

theorem isGalois : IsGalois K L :=
  letI := isSplittingField_X_pow_sub_one n K L
  IsGalois.of_separable_splitting_field (X_pow_sub_one_separable_iff.2
    (IsCyclotomicExtension.neZero' n K L).1)
#align is_cyclotomic_extension.is_galois IsCyclotomicExtension.isGalois

/-- If `IsCyclotomicExtension {n} K L`, then `L` is the splitting field of `cyclotomic n K`. -/
theorem splitting_field_cyclotomic : IsSplittingField K L (cyclotomic n K) :=
  { splits' := splits_cyclotomic K L (mem_singleton n)
    adjoin_rootSet' := by
      rw [‚Üê ((iff_adjoin_eq_top {n} K L).1 inferInstance).2]
      -- ‚ä¢ adjoin K (rootSet (cyclotomic (‚Üën) K) L) = adjoin K {b | ‚àÉ n_1, n_1 ‚àà {n} ‚àß  ‚Ä¶
      letI := Classical.decEq L
      -- ‚ä¢ adjoin K (rootSet (cyclotomic (‚Üën) K) L) = adjoin K {b | ‚àÉ n_1, n_1 ‚àà {n} ‚àß  ‚Ä¶
      -- todo: make `exists_prim_root` take an explicit `L`
      obtain ‚ü®Œ∂ : L, hŒ∂‚ü© := IsCyclotomicExtension.exists_prim_root K (B := L) (mem_singleton n)
      -- ‚ä¢ adjoin K (rootSet (cyclotomic (‚Üën) K) L) = adjoin K {b | ‚àÉ n_1, n_1 ‚àà {n} ‚àß  ‚Ä¶
      exact adjoin_roots_cyclotomic_eq_adjoin_nth_roots hŒ∂ }
      -- üéâ no goals
#align is_cyclotomic_extension.splitting_field_cyclotomic IsCyclotomicExtension.splitting_field_cyclotomic

scoped[Cyclotomic] attribute [instance] IsCyclotomicExtension.splitting_field_cyclotomic

end Singleton

end Field

end IsCyclotomicExtension

section CyclotomicField

/-- Given `n : ‚Ñï+` and a field `K`, we define `CyclotomicField n K` as the
splitting field of `cyclotomic n K`. If `n` is nonzero in `K`, it has
the instance `IsCyclotomicExtension {n} K (CyclotomicField n K)`. -/
def CyclotomicField : Type w :=
  (cyclotomic n K).SplittingField
#align cyclotomic_field CyclotomicField

namespace CyclotomicField

--Porting note: could not be derived
instance : Field (CyclotomicField n K) := by
  delta CyclotomicField; infer_instance
  -- ‚ä¢ Field (SplittingField (cyclotomic (‚Üën) K))
                         -- üéâ no goals

--Porting note: could not be derived
instance algebra : Algebra K (CyclotomicField n K) := by
  delta CyclotomicField; infer_instance
  -- ‚ä¢ Algebra K (SplittingField (cyclotomic (‚Üën) K))
                         -- üéâ no goals

--Porting note: could not be derived
instance : Inhabited (CyclotomicField n K) := by
  delta CyclotomicField; infer_instance
  -- ‚ä¢ Inhabited (SplittingField (cyclotomic (‚Üën) K))
                         -- üéâ no goals

instance [CharZero K] : CharZero (CyclotomicField n K) :=
  charZero_of_injective_algebraMap (algebraMap K _).injective

instance isCyclotomicExtension [NeZero ((n : ‚Ñï) : K)] :
    IsCyclotomicExtension {n} K (CyclotomicField n K) := by
  haveI : NeZero ((n : ‚Ñï) : CyclotomicField n K) :=
    NeZero.nat_of_injective (algebraMap K _).injective
  letI := Classical.decEq (CyclotomicField n K)
  -- ‚ä¢ IsCyclotomicExtension {n} K (CyclotomicField n K)
  obtain ‚ü®Œ∂, hŒ∂‚ü© :=
    exists_root_of_splits (algebraMap K (CyclotomicField n K)) (SplittingField.splits _)
      (degree_cyclotomic_pos n K n.pos).ne'
  rw [‚Üê eval_map, ‚Üê IsRoot.def, map_cyclotomic, isRoot_cyclotomic_iff] at hŒ∂
  -- ‚ä¢ IsCyclotomicExtension {n} K (CyclotomicField n K)
-- Porting note: the first `?_` was `forall_eq.2 ‚ü®Œ∂, hŒ∂‚ü©` that now fails.
  refine ‚ü®?_, ?_‚ü©
  -- ‚ä¢ ‚àÄ {n_1 : ‚Ñï+}, n_1 ‚àà {n} ‚Üí ‚àÉ r, IsPrimitiveRoot r ‚Üën_1
  ¬∑ simp only [mem_singleton_iff, forall_eq]
    -- ‚ä¢ ‚àÉ r, IsPrimitiveRoot r ‚Üën
    exact ‚ü®Œ∂, hŒ∂‚ü©
    -- üéâ no goals
  ¬∑ rw [‚Üê Algebra.eq_top_iff, ‚Üê SplittingField.adjoin_rootSet, eq_comm]
    -- ‚ä¢ adjoin K (rootSet (cyclotomic (‚Üën) K) (SplittingField (cyclotomic (‚Üën) K)))  ‚Ä¶
    exact IsCyclotomicExtension.adjoin_roots_cyclotomic_eq_adjoin_nth_roots hŒ∂
    -- üéâ no goals
#align cyclotomic_field.is_cyclotomic_extension CyclotomicField.isCyclotomicExtension

end CyclotomicField

end CyclotomicField

section IsDomain

variable [Algebra A K] [IsFractionRing A K]

section CyclotomicRing

/-- If `K` is the fraction field of `A`, the `A`-algebra structure on `CyclotomicField n K`.
-/
@[nolint unusedArguments]
instance CyclotomicField.algebraBase : Algebra A (CyclotomicField n K) :=
  SplittingField.algebra' (cyclotomic n K)
#align cyclotomic_field.algebra_base CyclotomicField.algebraBase

/-- Ensure there are no diamonds when `A = ‚Ñ§`. -/
example : algebraInt (CyclotomicField n ‚Ñö) = CyclotomicField.algebraBase _ _ _ :=
  rfl

instance CyclotomicField.algebra' {R : Type*} [CommRing R] [Algebra R K] :
    Algebra R (CyclotomicField n K) :=
  SplittingField.algebra' (cyclotomic n K)
#align cyclotomic_field.algebra' CyclotomicField.algebra'

instance {R : Type*} [CommRing R] [Algebra R K] : IsScalarTower R K (CyclotomicField n K) :=
  SplittingField.isScalarTower _

instance CyclotomicField.noZeroSMulDivisors : NoZeroSMulDivisors A (CyclotomicField n K) := by
  refine' NoZeroSMulDivisors.of_algebraMap_injective _
  -- ‚ä¢ Function.Injective ‚Üë(algebraMap A (CyclotomicField n K))
  rw [IsScalarTower.algebraMap_eq A K (CyclotomicField n K)]
  -- ‚ä¢ Function.Injective ‚Üë(RingHom.comp (algebraMap K (CyclotomicField n K)) (alge ‚Ä¶
  exact
    (Function.Injective.comp (NoZeroSMulDivisors.algebraMap_injective K (CyclotomicField n K))
      (IsFractionRing.injective A K) : _)
#align cyclotomic_field.no_zero_smul_divisors CyclotomicField.noZeroSMulDivisors

/-- If `A` is a domain with fraction field `K` and `n : ‚Ñï+`, we define `CyclotomicRing n A K` as
the `A`-subalgebra of `CyclotomicField n K` generated by the roots of `X ^ n - 1`. If `n`
is nonzero in `A`, it has the instance `IsCyclotomicExtension {n} A (CyclotomicRing n A K)`. -/
@[nolint unusedArguments]
def CyclotomicRing : Type w :=
  adjoin A {b : CyclotomicField n K | b ^ (n : ‚Ñï) = 1}
--deriving CommRing, IsDomain, Inhabited
#align cyclotomic_ring CyclotomicRing

namespace CyclotomicRing

--Porting note: could not be derived
instance : CommRing (CyclotomicRing n A K) := by
  delta CyclotomicRing; infer_instance
  -- ‚ä¢ CommRing { x // x ‚àà adjoin A {b | b ^ ‚Üën = 1} }
                        -- üéâ no goals

--Porting note: could not be derived
instance : IsDomain (CyclotomicRing n A K) := by
  delta CyclotomicRing; infer_instance
  -- ‚ä¢ IsDomain { x // x ‚àà adjoin A {b | b ^ ‚Üën = 1} }
                        -- üéâ no goals

--Porting note: could not be derived
instance : Inhabited (CyclotomicRing n A K) := by
  delta CyclotomicRing; infer_instance
  -- ‚ä¢ Inhabited { x // x ‚àà adjoin A {b | b ^ ‚Üën = 1} }
                        -- üéâ no goals

/-- The `A`-algebra structure on `CyclotomicRing n A K`. -/
instance algebraBase : Algebra A (CyclotomicRing n A K) :=
  (adjoin A _).algebra
#align cyclotomic_ring.algebra_base CyclotomicRing.algebraBase

-- Ensure that there is no diamonds with ‚Ñ§.
example {n : ‚Ñï+} : CyclotomicRing.algebraBase n ‚Ñ§ ‚Ñö = algebraInt _ :=
  rfl

instance : NoZeroSMulDivisors A (CyclotomicRing n A K) :=
  (adjoin A _).noZeroSMulDivisors_bot

theorem algebraBase_injective : Function.Injective <| algebraMap A (CyclotomicRing n A K) :=
  NoZeroSMulDivisors.algebraMap_injective _ _
#align cyclotomic_ring.algebra_base_injective CyclotomicRing.algebraBase_injective

instance : Algebra (CyclotomicRing n A K) (CyclotomicField n K) :=
  (adjoin A _).toAlgebra

theorem adjoin_algebra_injective :
    Function.Injective <| algebraMap (CyclotomicRing n A K) (CyclotomicField n K) :=
  Subtype.val_injective
#align cyclotomic_ring.adjoin_algebra_injective CyclotomicRing.adjoin_algebra_injective

instance : NoZeroSMulDivisors (CyclotomicRing n A K) (CyclotomicField n K) :=
  NoZeroSMulDivisors.of_algebraMap_injective (adjoin_algebra_injective n A K)

instance : IsScalarTower A (CyclotomicRing n A K) (CyclotomicField n K) :=
  IsScalarTower.subalgebra' _ _ _ _

instance isCyclotomicExtension [NeZero ((n : ‚Ñï) : A)] :
    IsCyclotomicExtension {n} A (CyclotomicRing n A K) where
  exists_prim_root := @fun a han => by
    rw [mem_singleton_iff] at han
    -- ‚ä¢ ‚àÉ r, IsPrimitiveRoot r ‚Üëa
    subst a
    -- ‚ä¢ ‚àÉ r, IsPrimitiveRoot r ‚Üën
    haveI := NeZero.of_noZeroSMulDivisors A K n
    -- ‚ä¢ ‚àÉ r, IsPrimitiveRoot r ‚Üën
    haveI := NeZero.of_noZeroSMulDivisors A (CyclotomicField n K) n
    -- ‚ä¢ ‚àÉ r, IsPrimitiveRoot r ‚Üën
    obtain ‚ü®Œº, hŒº‚ü© := (CyclotomicField.isCyclotomicExtension n K).exists_prim_root (mem_singleton n)
    -- ‚ä¢ ‚àÉ r, IsPrimitiveRoot r ‚Üën
    refine' ‚ü®‚ü®Œº, subset_adjoin _‚ü©, _‚ü©
    -- ‚ä¢ Œº ‚àà {b | b ^ ‚Üën = 1}
    ¬∑ apply (isRoot_of_unity_iff n.pos (CyclotomicField n K)).mpr
      -- ‚ä¢ ‚àÉ i, i ‚àà Nat.divisors ‚Üën ‚àß IsRoot (cyclotomic i (CyclotomicField n K)) Œº
      refine' ‚ü®n, Nat.mem_divisors_self _ n.ne_zero, _‚ü©
      -- ‚ä¢ IsRoot (cyclotomic (‚Üën) (CyclotomicField n K)) Œº
      rwa [‚Üê isRoot_cyclotomic_iff] at hŒº
      -- üéâ no goals
    ¬∑ rwa [‚Üê IsPrimitiveRoot.coe_submonoidClass_iff, Subtype.coe_mk]
      -- üéâ no goals
  adjoin_roots x := by
    refine'
      adjoin_induction' (fun y hy => _) (fun a => _) (fun y z hy hz => _) (fun y z hy hz => _) x
    ¬∑ refine' subset_adjoin _
      -- ‚ä¢ { val := y, property := (_ : y ‚àà ‚Üë(adjoin A {b | b ^ ‚Üën = 1})) } ‚àà {b | ‚àÉ n_ ‚Ä¶
      simp only [mem_singleton_iff, exists_eq_left, mem_setOf_eq]
      -- ‚ä¢ { val := y, property := (_ : y ‚àà ‚Üë(adjoin A {b | b ^ ‚Üën = 1})) } ^ ‚Üën = 1
      rwa [‚Üê Subalgebra.coe_eq_one, Subalgebra.coe_pow, Subtype.coe_mk]
      -- üéâ no goals
    ¬∑ exact Subalgebra.algebraMap_mem _ a
      -- üéâ no goals
    ¬∑ exact Subalgebra.add_mem _ hy hz
      -- üéâ no goals
    ¬∑ exact Subalgebra.mul_mem _ hy hz
      -- üéâ no goals
#align cyclotomic_ring.is_cyclotomic_extension CyclotomicRing.isCyclotomicExtension

instance [IsDomain A] [NeZero ((n : ‚Ñï) : A)] :
    IsFractionRing (CyclotomicRing n A K) (CyclotomicField n K) where
  map_units' := fun ‚ü®x, hx‚ü© => by
    rw [isUnit_iff_ne_zero]
    -- ‚ä¢ ‚Üë(algebraMap (CyclotomicRing n A K) (CyclotomicField n K)) ‚Üë{ val := x, prop ‚Ä¶
    apply map_ne_zero_of_mem_nonZeroDivisors
    -- ‚ä¢ Function.Injective ‚Üë(algebraMap (CyclotomicRing n A K) (CyclotomicField n K))
    apply adjoin_algebra_injective
    -- ‚ä¢ ‚Üë{ val := x, property := hx } ‚àà nonZeroDivisors (CyclotomicRing n A K)
    exact hx
    -- üéâ no goals
  surj' x := by
    letI : NeZero ((n : ‚Ñï) : K) := NeZero.nat_of_injective (IsFractionRing.injective A K)
    -- ‚ä¢ ‚àÉ x_1, x * ‚Üë(algebraMap (CyclotomicRing n A K) (CyclotomicField n K)) ‚Üëx_1.s ‚Ä¶
    refine
      Algebra.adjoin_induction
        (((IsCyclotomicExtension.iff_singleton n K (CyclotomicField n K)).1
              (CyclotomicField.isCyclotomicExtension n K)).2
          x)
        (fun y hy => ?_) (fun k => ?_) ?_ ?_
-- Porting note: the last goal was `by simpa` that now fails.
    ¬∑ exact ‚ü®‚ü®‚ü®y, subset_adjoin hy‚ü©, 1‚ü©, by simp; rfl‚ü©
      -- üéâ no goals
    ¬∑ have : IsLocalization (nonZeroDivisors A) K := inferInstance
      -- ‚ä¢ ‚àÉ x, ‚Üë(algebraMap K (CyclotomicField n K)) k * ‚Üë(algebraMap (CyclotomicRing  ‚Ä¶
      replace := this.surj
      -- ‚ä¢ ‚àÉ x, ‚Üë(algebraMap K (CyclotomicField n K)) k * ‚Üë(algebraMap (CyclotomicRing  ‚Ä¶
      obtain ‚ü®‚ü®z, w‚ü©, hw‚ü© := this k
      -- ‚ä¢ ‚àÉ x, ‚Üë(algebraMap K (CyclotomicField n K)) k * ‚Üë(algebraMap (CyclotomicRing  ‚Ä¶
      refine' ‚ü®‚ü®algebraMap A (CyclotomicRing n A K) z, algebraMap A (CyclotomicRing n A K) w,
        map_mem_nonZeroDivisors _ (algebraBase_injective n A K) w.2‚ü©, _‚ü©
      letI : IsScalarTower A K (CyclotomicField n K) :=
        IsScalarTower.of_algebraMap_eq (congr_fun rfl)
      rw [‚Üê IsScalarTower.algebraMap_apply, ‚Üê IsScalarTower.algebraMap_apply,
        @IsScalarTower.algebraMap_apply A K _ _ _ _ _ (_root_.CyclotomicField.algebra n K) _ _ w,
        ‚Üê RingHom.map_mul, hw, ‚Üê IsScalarTower.algebraMap_apply]
    ¬∑ rintro y z ‚ü®a, ha‚ü© ‚ü®b, hb‚ü©
      -- ‚ä¢ ‚àÉ x, (y + z) * ‚Üë(algebraMap (CyclotomicRing n A K) (CyclotomicField n K)) ‚Üëx ‚Ä¶
      refine' ‚ü®‚ü®a.1 * b.2 + b.1 * a.2, a.2 * b.2, mul_mem_nonZeroDivisors.2 ‚ü®a.2.2, b.2.2‚ü©‚ü©, _‚ü©
      -- ‚ä¢ (y + z) * ‚Üë(algebraMap (CyclotomicRing n A K) (CyclotomicField n K)) ‚Üë(a.fst ‚Ä¶
      rw [RingHom.map_mul, add_mul, ‚Üê mul_assoc, ha,
        mul_comm ((algebraMap (CyclotomicRing n A K) _) ‚Üëa.2), ‚Üê mul_assoc, hb]
      simp only [map_add, map_mul]
      -- üéâ no goals
    ¬∑ rintro y z ‚ü®a, ha‚ü© ‚ü®b, hb‚ü©
      -- ‚ä¢ ‚àÉ x, y * z * ‚Üë(algebraMap (CyclotomicRing n A K) (CyclotomicField n K)) ‚Üëx.s ‚Ä¶
      refine' ‚ü®‚ü®a.1 * b.1, a.2 * b.2, mul_mem_nonZeroDivisors.2 ‚ü®a.2.2, b.2.2‚ü©‚ü©, _‚ü©
      -- ‚ä¢ y * z * ‚Üë(algebraMap (CyclotomicRing n A K) (CyclotomicField n K)) ‚Üë(a.fst * ‚Ä¶
      rw [RingHom.map_mul, mul_comm ((algebraMap (CyclotomicRing n A K) _) ‚Üëa.2), mul_assoc, ‚Üê
        mul_assoc z, hb, ‚Üê mul_comm ((algebraMap (CyclotomicRing n A K) _) ‚Üëa.2), ‚Üê mul_assoc, ha]
      simp only [map_mul]
      -- üéâ no goals
  eq_iff_exists' := @fun x y =>
    ‚ü®fun h => ‚ü®1, by rw [adjoin_algebra_injective n A K h]‚ü©, fun ‚ü®c, hc‚ü© => by
                     -- üéâ no goals
      rw [mul_left_cancel‚ÇÄ (nonZeroDivisors.ne_zero c.prop) hc]‚ü©
      -- üéâ no goals

theorem eq_adjoin_primitive_root {Œº : CyclotomicField n K} (h : IsPrimitiveRoot Œº n) :
    CyclotomicRing n A K = adjoin A ({Œº} : Set (CyclotomicField n K)) := by
  rw [‚Üê IsCyclotomicExtension.adjoin_roots_cyclotomic_eq_adjoin_root_cyclotomic h,
    IsCyclotomicExtension.adjoin_roots_cyclotomic_eq_adjoin_nth_roots h]
  simp [CyclotomicRing]
  -- üéâ no goals
#align cyclotomic_ring.eq_adjoin_primitive_root CyclotomicRing.eq_adjoin_primitive_root

end CyclotomicRing

end CyclotomicRing

end IsDomain

section IsAlgClosed

variable [IsAlgClosed K]

/-- Algebraically closed fields are `S`-cyclotomic extensions over themselves if
`NeZero ((a : ‚Ñï) : K))` for all `a ‚àà S`. -/
theorem IsAlgClosed.isCyclotomicExtension (h : ‚àÄ a ‚àà S, NeZero ((a : ‚Ñï) : K)) :
    IsCyclotomicExtension S K K := by
  refine' ‚ü®@fun a ha => _, Algebra.eq_top_iff.mp <| Subsingleton.elim _ _‚ü©
  -- ‚ä¢ ‚àÉ r, IsPrimitiveRoot r ‚Üëa
  obtain ‚ü®r, hr‚ü© := IsAlgClosed.exists_aeval_eq_zero K _ (degree_cyclotomic_pos a K a.pos).ne'
  -- ‚ä¢ ‚àÉ r, IsPrimitiveRoot r ‚Üëa
  refine' ‚ü®r, _‚ü©
  -- ‚ä¢ IsPrimitiveRoot r ‚Üëa
  haveI := h a ha
  -- ‚ä¢ IsPrimitiveRoot r ‚Üëa
  rwa [coe_aeval_eq_eval, ‚Üê IsRoot.def, isRoot_cyclotomic_iff] at hr
  -- üéâ no goals
#align is_alg_closed.is_cyclotomic_extension IsAlgClosed.isCyclotomicExtension

instance IsAlgClosedOfCharZero.isCyclotomicExtension [CharZero K] :
    ‚àÄ S, IsCyclotomicExtension S K K := fun S =>
  IsAlgClosed.isCyclotomicExtension S K fun _ _ => inferInstance
#align is_alg_closed_of_char_zero.is_cyclotomic_extension IsAlgClosedOfCharZero.isCyclotomicExtension

end IsAlgClosed
