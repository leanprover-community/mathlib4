import Mathlib.RingTheory.Polynomial.Eisenstein.IsIntegral
import Mathlib.NumberTheory.KroneckerWeber.Cyclotomic.GaloisActionOnCyclo
import Mathlib.NumberTheory.Cyclotomic.Rat
import Mathlib.NumberTheory.KroneckerWeber.Cyclotomic.UnitLemmas
import Mathlib.RingTheory.DedekindDomain.Ideal
import Mathlib.NumberTheory.KroneckerWeber.Cyclotomic.CyclotomicUnits
import Mathlib.Algebra.CharP.Quotient

universe u

open FiniteDimensional Polynomial Algebra Nat Finset Fintype

variable (p : ‚Ñï+) (L : Type u) [Field L] [CharZero L] [IsCyclotomicExtension {p} ‚Ñö L]

instance Ring.toSubtractionMonoid {S : Type*} [Ring S] : SubtractionMonoid S := inferInstance

section IntFacts

open scoped NumberField BigOperators

instance {K : Type*} [Field K] : Module (ùìû K) (ùìû K) := Semiring.toModule

open Ideal IsCyclotomicExtension

theorem exists_int_sub_pow_prime_dvd {A : Type _} [CommRing A] [IsCyclotomicExtension {p} ‚Ñ§ A]
    [hp : Fact (p : ‚Ñï).Prime] (a : A) : ‚àÉ m : ‚Ñ§, a ^ (p : ‚Ñï) - m ‚àà span ({(p : A)} : Set A) := by
  have : a ‚àà Algebra.adjoin ‚Ñ§ _ := @adjoin_roots {p} ‚Ñ§ A _ _ _ _ a
  refine Algebra.adjoin_induction ?_ ?_ ?_ ?_ this
  ¬∑ intro x hx
    rcases hx with ‚ü®hx_w, hx_m, hx_p‚ü©
    simp only [Set.mem_singleton_iff] at hx_m
    rw [hx_m] at hx_p
    simp only [hx_p]
    use 1
    simp
  ¬∑ intro r
    use r ^ (p : ‚Ñï)
    simp
  ¬∑ rintro x y _ _ ‚ü®b, hb‚ü© ‚ü®c, hc‚ü©
    obtain ‚ü®r, hr‚ü© := exists_add_pow_prime_eq hp.out x y
    rw [hr]
    use c + b
    push_cast
    rw [sub_add_eq_sub_sub, sub_eq_add_neg, sub_eq_add_neg, add_comm _ (‚Üë‚Üëp * r), add_assoc,
      add_assoc]
    apply Ideal.add_mem _ _
    ¬∑ convert Ideal.add_mem _ hb hc using 1
      ring
    ¬∑ rw [mem_span_singleton]
      exact dvd_mul_right _ _
  ¬∑ rintro x y _ _ ‚ü®b, hb‚ü© ‚ü®c, hc‚ü©
    rw [mul_pow]
    use b * c
    have := Ideal.mul_mem_left _ (x ^ (p : ‚Ñï)) hc
    rw [mul_sub] at this
    rw [‚Üê Ideal.Quotient.eq_zero_iff_mem, map_sub] at this hb ‚ä¢
    convert this using 2
    rw [Int.cast_mul, _root_.map_mul, _root_.map_mul]
    congr 1
    exact (sub_eq_zero.mp hb).symm

local notation "R" => ùìû (CyclotomicField p ‚Ñö)

-- TODO I (alex) am not sure whether this is better as ideal span,
-- or fractional_ideal.span_singleton
/-- The principal ideal generated by `x + y Œ∂^i` for integer `x` and `y` -/
@[nolint unusedArguments]
noncomputable
def fltIdeals [Fact (p : ‚Ñï).Prime] (x y : ‚Ñ§) {Œ∑ : R} (_ : Œ∑ ‚àà nthRootsFinset p R) : Ideal R :=
  Ideal.span ({x + Œ∑ * y} : Set R)

variable {p}

-- why does this not update (n : ‚Ñï+)?
theorem mem_fltIdeals [Fact (p : ‚Ñï).Prime] (x y : ‚Ñ§) {Œ∑ : R} (hŒ∑ : Œ∑ ‚àà nthRootsFinset p R) :
    ‚Üëx + Œ∑ * ‚Üëy ‚àà fltIdeals p x y hŒ∑ :=
  mem_span_singleton.mpr dvd_rfl

theorem Ideal.le_add {S : Type _} [CommRing S] (a b c d : Ideal S) (hab : a ‚â§ b) (hcd : c ‚â§ d) :
    a + c ‚â§ b + d := by
  simp at *
  constructor
  apply le_trans hab (@le_sup_left _ _ _ _)
  apply le_trans hcd (@le_sup_right _ _ _ _)

theorem not_coprime_not_top {S : Type _} [CommRing S] (a b : Ideal S) :
    ¬¨IsCoprime a b ‚Üî a + b ‚â† ‚ä§ := by
  apply not_congr
  rw [IsCoprime]
  constructor
  intro h
  obtain ‚ü®x, y, hxy‚ü© := h
  rw [eq_top_iff_one]
  have h2 : x * a + y * b ‚â§ a + b := by apply Ideal.le_add; all_goals apply mul_le_left
  apply h2
  rw [hxy]
  simp
  intro h
  refine ‚ü®1, 1, ?_‚ü©
  simp only [one_eq_top, top_mul, Submodule.add_eq_sup, ge_iff_le]
  rw [‚Üê h]
  rfl

instance a1 : IsGalois ‚Ñö (CyclotomicField p ‚Ñö) :=
  IsCyclotomicExtension.isGalois p _ _

instance a2 : FiniteDimensional ‚Ñö (CyclotomicField p ‚Ñö) :=
  IsCyclotomicExtension.finiteDimensional {p} _ _

instance a3 : NumberField (CyclotomicField p ‚Ñö) :=
  IsCyclotomicExtension.numberField {p} ‚Ñö _

open IsPrimitiveRoot

theorem nth_roots_prim [Fact (p : ‚Ñï).Prime] {Œ∑ : R} (hŒ∑ : Œ∑ ‚àà nthRootsFinset p R) (hne1 : Œ∑ ‚â† 1) :
    IsPrimitiveRoot Œ∑ p := by
  classical
  have hŒ∂' := (zeta_spec p ‚Ñö (CyclotomicField p ‚Ñö)).unit'_coe
  rw [nthRoots_one_eq_biUnion_primitiveRoots] at hŒ∑
  simp only [mem_biUnion] at hŒ∑
  obtain ‚ü®a, ha, h2‚ü© := hŒ∑
  have ha2 : a = p := by
    rw [Nat.Prime.divisors (Fact.out : Nat.Prime p), mem_insert, mem_singleton] at ha
    cases' ha with ha ha
    exfalso
    rw [ha] at h2
    simp at h2
    rw [h2] at hne1
    exact hne1 rfl
    exact ha
  rw [ha2] at h2
  have hn : 0 < (p : ‚Ñï) := by norm_num
  rw [mem_primitiveRoots hn] at h2
  exact h2

theorem prim_coe (Œ∂ : R) (hŒ∂ : IsPrimitiveRoot Œ∂ p) : IsPrimitiveRoot (Œ∂ : CyclotomicField p ‚Ñö) p :=
  coe_submonoidClass_iff.mpr hŒ∂

theorem zeta_sub_one_dvb_p [Fact (p : ‚Ñï).Prime] (ph : 5 ‚â§ p) {Œ∑ : R} (hŒ∑ : Œ∑ ‚àà nthRootsFinset p R)
    (hne1 : Œ∑ ‚â† 1) : 1 - Œ∑ ‚à£ (p : R) := by
  have h00 : 1 - Œ∑ ‚à£ (p : R) ‚Üî Œ∑ - 1 ‚à£ (p : R) :=  by
    have hh : -(Œ∑ - 1) = 1 - Œ∑ := by ring
    simp_rw [‚Üê hh]
    apply neg_dvd
  rw [h00]
  have : IsPrimitiveRoot (Œ∑ : CyclotomicField p ‚Ñö) p := by
    apply prim_coe Œ∑ (nth_roots_prim hŒ∑ hne1)
  have h0 : p ‚â† 2 := by
    intro hP
    rw [hP] at ph
    contradiction
  have h := RingOfIntegers.dvd_norm ‚Ñö (Œ∑ - 1 : R)
  have h2 := IsPrimitiveRoot.norm_sub_one_of_prime_ne_two' this (cyclotomic.irreducible_rat p.2) h0
  convert h
  ext
  rw [show (Œ∑ : CyclotomicField p ‚Ñö) - 1 = (Œ∑ - 1 : _) by simp] at h2
  rw [RingOfIntegers.coe_algebraMap_norm, h2]
  simp

theorem one_sub_zeta_prime [Fact (p : ‚Ñï).Prime] {Œ∑ : R} (hŒ∑ : Œ∑ ‚àà nthRootsFinset p R)
    (hne1 : Œ∑ ‚â† 1) : Prime (1 - Œ∑) := by
  have h := prim_coe Œ∑ (nth_roots_prim hŒ∑ hne1)
  simpa using h.zeta_sub_one_prime'.neg

theorem diff_of_roots [hp : Fact (p : ‚Ñï).Prime] (ph : 5 ‚â§ p) {Œ∑‚ÇÅ Œ∑‚ÇÇ : R}
    (hŒ∑‚ÇÅ : Œ∑‚ÇÅ ‚àà nthRootsFinset p R) (hŒ∑‚ÇÇ : Œ∑‚ÇÇ ‚àà nthRootsFinset p R) (hdiff : Œ∑‚ÇÅ ‚â† Œ∑‚ÇÇ)
    (hwlog : Œ∑‚ÇÅ ‚â† 1) : ‚àÉ u : RÀ£, Œ∑‚ÇÅ - Œ∑‚ÇÇ = u * (1 - Œ∑‚ÇÅ) := by
  replace ph : 2 ‚â§ p := le_trans (by decide) ph
  have h := nth_roots_prim hŒ∑‚ÇÅ hwlog
  obtain ‚ü®i, ‚ü®H, hi‚ü©‚ü© := h.eq_pow_of_pow_eq_one ((mem_nthRootsFinset hp.out.pos).1 hŒ∑‚ÇÇ)
  have hi1 : 1 ‚â† i := by
    intro hi1
    rw [‚Üê hi1, pow_one] at hi
    exact hdiff hi
  obtain ‚ü®u, hu‚ü© :=
    CyclotomicUnit.IsPrimitiveRoot.zeta_pow_sub_eq_unit_zeta_sub_one R ph hp.out hp.out.one_lt H
      hi1 h
  exact ‚ü®u, by rw [‚Üê hu, hi, pow_one]‚ü©

theorem diff_of_roots2 [Fact (p : ‚Ñï).Prime] (ph : 5 ‚â§ p) {Œ∑‚ÇÅ Œ∑‚ÇÇ : R} (hŒ∑‚ÇÅ : Œ∑‚ÇÅ ‚àà nthRootsFinset p R)
    (hŒ∑‚ÇÇ : Œ∑‚ÇÇ ‚àà nthRootsFinset p R) (hdiff : Œ∑‚ÇÅ ‚â† Œ∑‚ÇÇ) (hwlog : Œ∑‚ÇÅ ‚â† 1) :
    ‚àÉ u : RÀ£, Œ∑‚ÇÇ - Œ∑‚ÇÅ = u * (1 - Œ∑‚ÇÅ) := by
  obtain ‚ü®u, hu‚ü© := diff_of_roots ph hŒ∑‚ÇÅ hŒ∑‚ÇÇ hdiff hwlog
  exact ‚ü®-u, by simp [‚Üê hu]‚ü©

lemma fltIdeals_coprime2_lemma [Fact (p : ‚Ñï).Prime] (ph : 5 ‚â§ p) {x y : ‚Ñ§} {Œ∑‚ÇÅ Œ∑‚ÇÇ : R}
    (hŒ∑‚ÇÅ : Œ∑‚ÇÅ ‚àà nthRootsFinset p R)
    (hŒ∑‚ÇÇ : Œ∑‚ÇÇ ‚àà nthRootsFinset p R) (hdiff : Œ∑‚ÇÅ ‚â† Œ∑‚ÇÇ) (hp : IsCoprime x y)
    (hp2 : ¬¨(p : ‚Ñ§) ‚à£ (x + y : ‚Ñ§)) (hwlog : Œ∑‚ÇÅ ‚â† 1) :
    (fltIdeals p x y hŒ∑‚ÇÅ) ‚äî (fltIdeals p x y hŒ∑‚ÇÇ) = ‚ä§ := by
  -- Note: `by_contra h` was extremely slow here.
  apply by_contradiction
  intro h
  let I := fltIdeals p x y hŒ∑‚ÇÅ ‚äî fltIdeals p x y hŒ∑‚ÇÇ
  obtain ‚ü®P, hP1, hP2‚ü© := exists_le_maximal I h
  have hiP : fltIdeals p x y hŒ∑‚ÇÅ ‚â§ P := le_trans le_sup_left hP2
  have hel1 : ‚àÉ v : RÀ£, (v : R) * y * (1 - Œ∑‚ÇÅ) ‚àà I := by
    obtain ‚ü®v, hv‚ü© := diff_of_roots ph hŒ∑‚ÇÅ hŒ∑‚ÇÇ hdiff hwlog
    refine ‚ü®v, ?_‚ü©
    have := Ideal.sub_mem _
      (mem_sup_left (mem_fltIdeals x y hŒ∑‚ÇÅ)) (mem_sup_right (mem_fltIdeals x y hŒ∑‚ÇÇ))
    rwa [add_sub_add_left_eq_sub, ‚Üê sub_mul, hv, mul_right_comm] at this
  have hel2 : ‚àÉ v : RÀ£, (v : R) * x * (1 - Œ∑‚ÇÅ) ‚àà I := by
    obtain ‚ü®v, hv‚ü© := diff_of_roots2 ph hŒ∑‚ÇÅ hŒ∑‚ÇÇ hdiff hwlog
    refine ‚ü®v, ?_‚ü©
    have := Ideal.add_mem _ (mul_mem_left _ Œ∑‚ÇÇ (mem_sup_left (mem_fltIdeals x y hŒ∑‚ÇÅ)))
        (mul_mem_left _ (-Œ∑‚ÇÅ) (mem_sup_right (mem_fltIdeals x y hŒ∑‚ÇÇ)))
    have h1 : Œ∑‚ÇÇ * (‚Üëx + Œ∑‚ÇÅ * ‚Üëy) + -Œ∑‚ÇÅ * (‚Üëx + Œ∑‚ÇÇ * ‚Üëy) = (Œ∑‚ÇÇ - Œ∑‚ÇÅ) * x := by ring
    rwa [h1, hv, mul_right_comm] at this
  have hel11 : (y : R) * (1 - Œ∑‚ÇÅ) ‚àà P := by
    obtain ‚ü®v, hv‚ü© := hel1
    rw [mul_assoc] at hv
    have hvunit : IsUnit (v : R) := Units.isUnit v
    apply (unit_mul_mem_iff_mem P hvunit).1 _
    apply hP2
    apply hv
  have hel22 : (x : R) * (1 - Œ∑‚ÇÅ) ‚àà P := by
    obtain ‚ü®v, hv‚ü© := hel2
    rw [mul_assoc] at hv
    have hvunit : IsUnit (v : R) := Units.isUnit v
    apply (unit_mul_mem_iff_mem P hvunit).1 _
    apply hP2
    apply hv
  have hPrime := hP1.isPrime
  have hprime2 := IsPrime.mem_or_mem hPrime hel11
  have hprime3 := IsPrime.mem_or_mem hPrime hel22
  have HC : 1 - Œ∑‚ÇÅ ‚àà P ‚Üí False := by
    intro h
    have eta_sub_one_ne_zero := sub_ne_zero.mpr (Ne.symm hwlog)
    have hŒ∑prime : IsPrime (Ideal.span ({1 - Œ∑‚ÇÅ} : Set R)) := by
      rw [span_singleton_prime eta_sub_one_ne_zero]
      apply one_sub_zeta_prime hŒ∑‚ÇÅ hwlog
    have H5 : IsPrime (Ideal.span ({(p : ‚Ñ§)} : Set ‚Ñ§)) := by
      have h2 : (p : ‚Ñ§) ‚â† 0 := by simp
      have h1 : Prime (p : ‚Ñ§) := by
        rw [‚Üê prime_iff_prime_int]
        exact Fact.out
      rw [span_singleton_prime h2]
      apply h1
    have hŒ∑P : Ideal.span ({1 - Œ∑‚ÇÅ} : Set R) = P := by
      have hle : Ideal.span ({1 - Œ∑‚ÇÅ} : Set R) ‚â§ P := by rw [span_le]; simp [h]
      apply (@Ring.DimensionLeOne.prime_le_prime_iff_eq _ _ _ _ _ hŒ∑prime hPrime _).1 hle
      intro hbot
      rw [span_eq_bot] at hbot
      simp only [Set.mem_singleton_iff, forall_eq, sub_eq_zero] at hbot
      exact hwlog hbot.symm
    have hcapZ : P.comap (Int.castRingHom R) = Ideal.span ({(p : ‚Ñ§)} : Set ‚Ñ§) := by
      have H1 : Ideal.span ({(p : ‚Ñ§)} : Set ‚Ñ§) ‚â§ P.comap (Int.castRingHom R) := by
        rw [‚Üê hŒ∑P]
        apply le_comap_of_map_le _
        rw [map_span]
        simp
        rw [span_singleton_le_span_singleton]
        apply zeta_sub_one_dvb_p ph hŒ∑‚ÇÅ hwlog
      have H2 : IsPrime (P.comap (Int.castRingHom R)) := by
        exact IsPrime.comap _
      have H4 : Ideal.span ({(p : ‚Ñ§)} : Set ‚Ñ§) ‚â† ‚ä• := by simp
      apply ((@Ring.DimensionLeOne.prime_le_prime_iff_eq _ _ _ _ _ H5 H2 H4).1 H1).symm
    have hxyinP : (x + y : R) ‚àà P := by
      have H1 : (x : R) + Œ∑‚ÇÅ * y ‚àà P := by
        apply hiP
        apply Submodule.mem_span_singleton_self
      have H2 : Œ∑‚ÇÅ * y = y - y * (1 - Œ∑‚ÇÅ) := by ring
      rw [H2] at H1
      have H3 : ‚Üëx + (‚Üëy - ‚Üëy * (1 - Œ∑‚ÇÅ)) = ‚Üëx + ‚Üëy + -‚Üëy * (1 - Œ∑‚ÇÅ) := by ring
      rw [H3] at H1
      have H4 : -‚Üëy * (1 - Œ∑‚ÇÅ) ‚àà P := by
        rw [‚Üê hŒ∑P]; rw [Ideal.mem_span_singleton']
        exact ‚ü®-(y : R), rfl‚ü©
      apply (Ideal.add_mem_iff_left P H4).1 H1
    have hxyinP2 : x + y ‚àà Ideal.span ({(p : ‚Ñ§)} : Set ‚Ñ§) := by rw [‚Üê hcapZ]; simp [hxyinP]
    rw [mem_span_singleton] at hxyinP2
    apply absurd hxyinP2 hp2
  cases' hprime2 with hprime2 hprime2
  cases' hprime3 with hprime3 hprime3
  obtain ‚ü®a, b, hab‚ü© := hp
  have hone := P.add_mem (Ideal.mul_mem_left P a hprime3) (Ideal.mul_mem_left P b hprime2)
  norm_cast at hone
  rw [hab] at hone
  norm_cast at hone
  rw [‚Üê eq_top_iff_one] at hone
  have hcontra := IsPrime.ne_top hPrime
  rw [hone] at hcontra
  simp only [Ne, eq_self_iff_true, not_true] at hcontra
  apply HC hprime3
  apply HC hprime2

theorem fltIdeals_coprime2 [Fact (p : ‚Ñï).Prime] (ph : 5 ‚â§ p) {x y : ‚Ñ§} {Œ∑‚ÇÅ Œ∑‚ÇÇ : R}
    (hŒ∑‚ÇÅ : Œ∑‚ÇÅ ‚àà nthRootsFinset p R)
    (hŒ∑‚ÇÇ : Œ∑‚ÇÇ ‚àà nthRootsFinset p R) (hdiff : Œ∑‚ÇÅ ‚â† Œ∑‚ÇÇ) (hp : IsCoprime x y)
    (hp2 : ¬¨(p : ‚Ñ§) ‚à£ (x + y : ‚Ñ§)) (hwlog : Œ∑‚ÇÅ ‚â† 1) : IsCoprime (fltIdeals p x y hŒ∑‚ÇÅ)
    (fltIdeals p x y hŒ∑‚ÇÇ) := by
  apply not_not.mp
  rw [not_coprime_not_top, not_not]
  exact fltIdeals_coprime2_lemma ph hŒ∑‚ÇÅ hŒ∑‚ÇÇ hdiff hp hp2 hwlog

theorem aux_lem_flt [Fact (p : ‚Ñï).Prime] {x y z : ‚Ñ§} (H : x ^ (p : ‚Ñï) + y ^ (p : ‚Ñï) = z ^ (p : ‚Ñï))
    (caseI : ¬¨‚Üëp ‚à£ x * y * z) : ¬¨(p : ‚Ñ§) ‚à£ (x + y : ‚Ñ§) := by
  intro habs
  replace habs : ‚Üë(p : ‚Ñï) ‚à£ (x + y : ‚Ñ§) := by simpa using habs
  rw [‚Üê ZMod.intCast_zmod_eq_zero_iff_dvd, Int.cast_add] at habs
  replace H := congr_arg (fun x : ‚Ñ§ => (x : ZMod p)) H.symm
  simp only [Int.cast_add, Int.cast_pow, ZMod.pow_card, habs,
    ZMod.intCast_zmod_eq_zero_iff_dvd] at H
  exact caseI (Dvd.dvd.mul_left H _)

theorem fltIdeals_coprime (hpri : (p : ‚Ñï).Prime) (p5 : 5 ‚â§ p) {x y z : ‚Ñ§}
    (H : x ^ (p : ‚Ñï) + y ^ (p : ‚Ñï) = z ^ (p : ‚Ñï)) {Œ∑‚ÇÅ Œ∑‚ÇÇ : R} (hxy : IsCoprime x y)
    (hŒ∑‚ÇÅ : Œ∑‚ÇÅ ‚àà nthRootsFinset p R) (hŒ∑‚ÇÇ : Œ∑‚ÇÇ ‚àà nthRootsFinset p R) (hdiff : Œ∑‚ÇÅ ‚â† Œ∑‚ÇÇ)
    (caseI : ¬¨‚Üëp ‚à£ x * y * z) :
    have : Fact (p : ‚Ñï).Prime := ‚ü®hpri‚ü©
    IsCoprime (fltIdeals p x y hŒ∑‚ÇÅ) (fltIdeals p x y hŒ∑‚ÇÇ) := by
  have : Fact (p : ‚Ñï).Prime := ‚ü®hpri‚ü©
  by_cases h : Œ∑‚ÇÅ ‚â† 1
  apply fltIdeals_coprime2 p5 hŒ∑‚ÇÅ hŒ∑‚ÇÇ hdiff hxy (aux_lem_flt H caseI) h
  have h2 : Œ∑‚ÇÇ ‚â† 1 := by
    simp at h
    rw [h] at hdiff
    exact hdiff.symm
  have := fltIdeals_coprime2 p5 hŒ∑‚ÇÇ hŒ∑‚ÇÅ hdiff.symm hxy (aux_lem_flt H caseI) h2
  apply IsCoprime.symm
  exact this

variable {L}

theorem dvd_last_coeff_cycl_integer [hp : Fact (p : ‚Ñï).Prime] {Œ∂ : ùìû L}
    (hŒ∂ : IsPrimitiveRoot Œ∂ p) {f : Fin p ‚Üí ‚Ñ§}
    (hf : ‚àÉ i, f i = 0) {m : ‚Ñ§} (hdiv : ‚Üëm ‚à£ ‚àë j, f j ‚Ä¢ Œ∂ ^ (j : ‚Ñï)) :
    m ‚à£ f ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü© := by
  obtain ‚ü®i, Hi‚ü© := hf
  have hlast :
    (Fin.castOrderIso (succ_pred_prime hp.out)) (Fin.last (p : ‚Ñï).pred) =
    ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü© := Fin.ext rfl
  have h : ‚àÄ x, (Fin.castOrderIso (succ_pred_prime hp.out)) (Fin.castSuccEmb x) =
    ‚ü®x, lt_trans x.2 (pred_lt hp.out.ne_zero)‚ü© := fun x => Fin.ext rfl
  let Œ∂' := (Œ∂ : L)
  have hŒ∂' : IsPrimitiveRoot Œ∂' p := IsPrimitiveRoot.coe_submonoidClass_iff.2 hŒ∂
  have hcoe : Œ∂ = ‚ü®Œ∂', hŒ∂'.isIntegral p.pos‚ü© := by rfl
  set b := hŒ∂'.integralPowerBasis' with hb
  have hdim : b.dim = (p : ‚Ñï).pred := by rw [hŒ∂'.power_basis_int'_dim, totient_prime hp.out,
    pred_eq_sub_one]
  by_cases H : i = ‚ü®(p : ‚Ñï) - 1, pred_lt hp.out.ne_zero‚ü©
  ¬∑ simp [H.symm, Hi]
  have hi : ‚Üëi < (p : ‚Ñï) - 1 := by
    by_contra! habs
    simp [le_antisymm habs (le_pred_of_lt (Fin.is_lt i))] at H
  obtain ‚ü®y, hy‚ü© := hdiv
  rw [‚Üê Equiv.sum_comp (Fin.castOrderIso (succ_pred_prime hp.out)).toEquiv,
    Fin.sum_univ_castSucc] at hy
  simp only [hlast, h, RelIso.coe_fn_toEquiv, Fin.val_mk] at hy
  rw [hŒ∂.pow_sub_one_eq hp.out.one_lt, ‚Üê sum_neg_distrib, smul_sum, sum_range, ‚Üê sum_add_distrib,
    ‚Üê (Fin.castOrderIso hdim).toEquiv.sum_comp] at hy
  simp only [RelIso.coe_fn_toEquiv, Fin.coe_cast, mul_neg, ‚Üê Subtype.coe_inj, Fin.coe_castSucc,
    Fin.coe_orderIso_apply] at hy
  conv_lhs at hy =>
    congr; rfl; ext x
    rw [smul_neg]
    congr; congr; rfl; congr
    rw [hcoe, ‚Üê IsPrimitiveRoot.toInteger, ‚Üê hŒ∂'.integralPowerBasis'_gen, ‚Üê hb]
    rfl; rfl; congr; congr; rfl; congr
    rw [hcoe, ‚Üê IsPrimitiveRoot.toInteger, ‚Üê hŒ∂'.integralPowerBasis'_gen, ‚Üê hb]
  conv_lhs at hy =>
    congr; rfl; ext x
    rw [‚Üê show ‚àÄ y, _ = _ from fun y => congr_fun b.coe_basis y, ‚Üê sub_eq_add_neg]
  rw [sum_sub_distrib] at hy
  replace hy := congr_arg (b.basis.coord ((Fin.castOrderIso hdim.symm) ‚ü®i, hi‚ü©)) hy
  rw [‚Üê b.basis.equivFun_symm_apply, ‚Üê b.basis.equivFun_symm_apply, LinearMap.map_sub,
    b.basis.coord_equivFun_symm, b.basis.coord_equivFun_symm, ‚Üê smul_eq_mul,
    Int.cast_smul_eq_zsmul] at hy
  obtain ‚ü®n, hn‚ü© := b.basis.dvd_coord_smul ((Fin.castOrderIso hdim.symm) ‚ü®i, hi‚ü©) y m
  rw [hn] at hy
  simp only [Fin.castOrderIso_apply, Fin.cast_mk, Fin.castSucc_mk, Fin.eta, Hi, zero_sub,
    neg_eq_iff_eq_neg] at hy
  erw [hy] -- pred vs - 1
  simp [dvd_neg]

theorem dvd_coeff_cycl_integer (hp : (p : ‚Ñï).Prime) {Œ∂ : ùìû L} (hŒ∂ : IsPrimitiveRoot Œ∂ p)
    {f : Fin p ‚Üí ‚Ñ§} (hf : ‚àÉ i, f i = 0) {m : ‚Ñ§} (hdiv : ‚Üëm ‚à£ ‚àë j, f j ‚Ä¢ Œ∂ ^ (j : ‚Ñï)) :
    ‚àÄ j, m ‚à£ f j := by
  let Œ∂' := (Œ∂ : L)
  have : Fact (p : ‚Ñï).Prime := ‚ü®hp‚ü©
  have hŒ∂' : IsPrimitiveRoot Œ∂' p := IsPrimitiveRoot.coe_submonoidClass_iff.2 hŒ∂
  have hcoe : Œ∂ = ‚ü®Œ∂', hŒ∂'.isIntegral p.pos‚ü© := by rfl
  have hlast : (Fin.castOrderIso (succ_pred_prime hp)) (Fin.last (p : ‚Ñï).pred) =
      ‚ü®(p : ‚Ñï).pred, pred_lt hp.ne_zero‚ü© := Fin.ext rfl
  have h : ‚àÄ x, (Fin.castOrderIso (succ_pred_prime hp)) (Fin.castSuccEmb x) =
    ‚ü®x, lt_trans x.2 (pred_lt hp.ne_zero)‚ü© := fun x => Fin.ext rfl
  set b := hŒ∂'.integralPowerBasis' with hb
  have hdim : b.dim = (p : ‚Ñï).pred := by rw [hŒ∂'.power_basis_int'_dim, totient_prime hp,
    pred_eq_sub_one]
  have last_dvd := dvd_last_coeff_cycl_integer hŒ∂ hf hdiv
  intro j
  by_cases H : j = ‚ü®(p : ‚Ñï) - 1, pred_lt hp.ne_zero‚ü©
  ¬∑ simpa [H] using last_dvd
  have hj : ‚Üëj < (p : ‚Ñï) - 1 := by
    by_contra! habs
    simp [le_antisymm habs (le_pred_of_lt (Fin.is_lt j))] at H
  obtain ‚ü®y, hy‚ü© := hdiv
  rw [‚Üê Equiv.sum_comp (Fin.castOrderIso (succ_pred_prime hp)).toEquiv, Fin.sum_univ_castSucc] at hy
  simp only [hlast, h, RelIso.coe_fn_toEquiv, Fin.val_mk] at hy
  rw [hŒ∂.pow_sub_one_eq hp.one_lt, ‚Üê sum_neg_distrib, smul_sum, sum_range, ‚Üê sum_add_distrib,
    ‚Üê (Fin.castOrderIso hdim).toEquiv.sum_comp] at hy
  simp only [RelIso.coe_fn_toEquiv, Fin.coe_cast, mul_neg, ‚Üê Subtype.coe_inj, Fin.coe_castSucc,
    Fin.coe_orderIso_apply] at hy
  conv_lhs at hy =>
    congr; rfl; ext x
    rw [smul_neg]
    congr; congr; rfl; congr
    rw [hcoe, ‚Üê IsPrimitiveRoot.toInteger, ‚Üê hŒ∂'.integralPowerBasis'_gen, ‚Üê hb]
    rfl; rfl; congr; congr; rfl; congr
    rw [hcoe, ‚Üê IsPrimitiveRoot.toInteger, ‚Üê hŒ∂'.integralPowerBasis'_gen, ‚Üê hb]
  conv_lhs at hy =>
    congr; rfl; ext x
    rw [‚Üê show ‚àÄ y, _ = _ from fun y => congr_fun b.coe_basis y, ‚Üê sub_eq_add_neg]
  rw [sum_sub_distrib] at hy
  replace hy := congr_arg (b.basis.coord ((Fin.castOrderIso hdim.symm) ‚ü®j, hj‚ü©)) hy
  rw [‚Üê b.basis.equivFun_symm_apply, ‚Üê b.basis.equivFun_symm_apply, LinearMap.map_sub,
    b.basis.coord_equivFun_symm, b.basis.coord_equivFun_symm] at hy
  simp only [Fin.castOrderIso_apply, Fin.cast_mk, Fin.castSucc_mk, Fin.eta, Basis.coord_apply,
    sub_eq_iff_eq_add] at hy
  obtain ‚ü®n, hn‚ü© := b.basis.dvd_coord_smul ((Fin.cast hdim.symm) ‚ü®j, hj‚ü©) y m
  rw [hy, ‚Üê smul_eq_mul, Int.cast_smul_eq_zsmul, ‚Üê b.basis.coord_apply, ‚Üê Fin.cast_mk, hn]
  exact dvd_add (dvd_mul_right _ _) last_dvd

end IntFacts
