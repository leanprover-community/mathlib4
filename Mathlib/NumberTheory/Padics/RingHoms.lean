/-
Copyright (c) 2020 Johan Commelin, Robert Y. Lewis. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin, Robert Y. Lewis
-/
import Mathlib.Data.ZMod.Basic
import Mathlib.NumberTheory.Padics.PadicIntegers

#align_import number_theory.padics.ring_homs from "leanprover-community/mathlib"@"565eb991e264d0db702722b4bde52ee5173c9950"

/-!

# Relating `â„¤_[p]` to `ZMod (p ^ n)`

In this file we establish connections between the `p`-adic integers $\mathbb{Z}_p$
and the integers modulo powers of `p`, $\mathbb{Z}/p^n\mathbb{Z}$.

## Main declarations

We show that $\mathbb{Z}_p$ has a ring hom to $\mathbb{Z}/p^n\mathbb{Z}$ for each `n`.
The case for `n = 1` is handled separately, since it is used in the general construction
and we may want to use it without the `^1` getting in the way.
* `PadicInt.toZMod`: ring hom to `ZMod p`
* `PadicInt.toZModPow`: ring hom to `ZMod (p^n)`
* `PadicInt.ker_toZMod` / `PadicInt.ker_toZModPow`: the kernels of these maps are the ideals
  generated by `p^n`

We also establish the universal property of $\mathbb{Z}_p$ as a projective limit.
Given a family of compatible ring homs $f_k : R \to \mathbb{Z}/p^n\mathbb{Z}$,
there is a unique limit $R \to \mathbb{Z}_p$.
* `PadicInt.lift`: the limit function
* `PadicInt.lift_spec` / `PadicInt.lift_unique`: the universal property

## Implementation notes

The ring hom constructions go through an auxiliary constructor `PadicInt.toZModHom`,
which removes some boilerplate code.

-/


noncomputable section

open Classical Nat LocalRing Padic

namespace PadicInt

variable {p : â„•} [hp_prime : Fact p.Prime]

section RingHoms

/-! ### Ring homomorphisms to `ZMod p` and `ZMod (p ^ n)` -/


variable (p) (r : â„š)

/-- `modPart p r` is an integer that satisfies
`â€–(r - modPart p r : â„š_[p])â€– < 1` when `â€–(r : â„š_[p])â€– â‰¤ 1`,
see `PadicInt.norm_sub_modPart`.
It is the unique non-negative integer that is `< p` with this property.

(Note that this definition assumes `r : â„š`.
See `PadicInt.zmodRepr` for a version that takes values in `â„•`
and works for arbitrary `x : â„¤_[p]`.) -/
def modPart : â„¤ :=
  r.num * gcdA r.den p % p
#align padic_int.mod_part PadicInt.modPart

variable {p}

theorem modPart_lt_p : modPart p r < p := by
  convert Int.emod_lt _ _
  -- âŠ¢ â†‘p = |â†‘p|
  Â· simp
    -- ğŸ‰ no goals
  Â· exact_mod_cast hp_prime.1.ne_zero
    -- ğŸ‰ no goals
#align padic_int.mod_part_lt_p PadicInt.modPart_lt_p

theorem modPart_nonneg : 0 â‰¤ modPart p r :=
  Int.emod_nonneg _ <| by exact_mod_cast hp_prime.1.ne_zero
                          -- ğŸ‰ no goals
#align padic_int.mod_part_nonneg PadicInt.modPart_nonneg

theorem isUnit_den (r : â„š) (h : â€–(r : â„š_[p])â€– â‰¤ 1) : IsUnit (r.den : â„¤_[p]) := by
  rw [isUnit_iff]
  -- âŠ¢ â€–â†‘r.denâ€– = 1
  apply le_antisymm (r.den : â„¤_[p]).2
  -- âŠ¢ 1 â‰¤ â€–â†‘â†‘r.denâ€–
  rw [â† not_lt, coe_nat_cast]
  -- âŠ¢ Â¬â€–â†‘r.denâ€– < 1
  intro norm_denom_lt
  -- âŠ¢ False
  have hr : â€–(r * r.den : â„š_[p])â€– = â€–(r.num : â„š_[p])â€– := by
    congr
    rw_mod_cast [@Rat.mul_den_eq_num r]
  rw [padicNormE.mul] at hr
  -- âŠ¢ False
  have key : â€–(r.num : â„š_[p])â€– < 1 := by
    calc
      _ = _ := hr.symm
      _ < 1 * 1 := (mul_lt_mul' h norm_denom_lt (norm_nonneg _) zero_lt_one)
      _ = 1 := mul_one 1

  have : â†‘p âˆ£ r.num âˆ§ (p : â„¤) âˆ£ r.den := by
    simp only [â† norm_int_lt_one_iff_dvd, â† padic_norm_e_of_padicInt]
    exact âŸ¨key, norm_denom_ltâŸ©
  apply hp_prime.1.not_dvd_one
  -- âŠ¢ p âˆ£ 1
  rwa [â† r.reduced.gcd_eq_one, Nat.dvd_gcd_iff, â† Int.coe_nat_dvd_left, â† Int.coe_nat_dvd]
  -- ğŸ‰ no goals
#align padic_int.is_unit_denom PadicInt.isUnit_den

theorem norm_sub_modPart_aux (r : â„š) (h : â€–(r : â„š_[p])â€– â‰¤ 1) :
    â†‘p âˆ£ r.num - r.num * r.den.gcdA p % p * â†‘r.den := by
  rw [â† ZMod.int_cast_zmod_eq_zero_iff_dvd]
  -- âŠ¢ â†‘(r.num - r.num * gcdA r.den p % â†‘p * â†‘r.den) = 0
  simp only [Int.cast_ofNat, ZMod.nat_cast_mod, Int.cast_mul, Int.cast_sub]
  -- âŠ¢ â†‘r.num - â†‘(r.num * gcdA r.den p % â†‘p) * â†‘r.den = 0
  have := congr_arg (fun x => x % p : â„¤ â†’ ZMod p) (gcd_eq_gcd_ab r.den p)
  -- âŠ¢ â†‘r.num - â†‘(r.num * gcdA r.den p % â†‘p) * â†‘r.den = 0
  simp only [Int.cast_ofNat, CharP.cast_eq_zero, EuclideanDomain.mod_zero, Int.cast_add,
    Int.cast_mul, zero_mul, add_zero] at this
  push_cast
  -- âŠ¢ â†‘r.num - â†‘r.num * â†‘(gcdA r.den p) * â†‘r.den = 0
  rw [mul_right_comm, mul_assoc, â† this]
  -- âŠ¢ â†‘r.num - â†‘r.num * â†‘(Nat.gcd r.den p) = 0
  suffices rdcp : r.den.coprime p
  -- âŠ¢ â†‘r.num - â†‘r.num * â†‘(Nat.gcd r.den p) = 0
  Â· rw [rdcp.gcd_eq_one]
    -- âŠ¢ â†‘r.num - â†‘r.num * â†‘1 = 0
    simp only [mul_one, cast_one, sub_self]
    -- ğŸ‰ no goals
  apply coprime.symm
  -- âŠ¢ coprime p r.den
  apply (coprime_or_dvd_of_prime hp_prime.1 _).resolve_right
  -- âŠ¢ Â¬p âˆ£ r.den
  rw [â† Int.coe_nat_dvd, â† norm_int_lt_one_iff_dvd, not_lt]
  -- âŠ¢ 1 â‰¤ â€–â†‘â†‘r.denâ€–
  apply ge_of_eq
  -- âŠ¢ â€–â†‘â†‘r.denâ€– = 1
  rw [â† isUnit_iff]
  -- âŠ¢ IsUnit â†‘â†‘r.den
  exact isUnit_den r h
  -- ğŸ‰ no goals
#align padic_int.norm_sub_mod_part_aux PadicInt.norm_sub_modPart_aux

theorem norm_sub_modPart (h : â€–(r : â„š_[p])â€– â‰¤ 1) : â€–(âŸ¨r, hâŸ© - modPart p r : â„¤_[p])â€– < 1 := by
  let n := modPart p r
  -- âŠ¢ â€–{ val := â†‘r, property := h } - â†‘(modPart p r)â€– < 1
  rw [norm_lt_one_iff_dvd, â† (isUnit_den r h).dvd_mul_right]
  -- âŠ¢ â†‘p âˆ£ ({ val := â†‘r, property := h } - â†‘(modPart p r)) * â†‘r.den
  suffices â†‘p âˆ£ r.num - n * r.den by
    convert(Int.castRingHom â„¤_[p]).map_dvd this
    simp only [sub_mul, Int.cast_ofNat, eq_intCast, Int.cast_mul, sub_left_inj, Int.cast_sub]
    apply Subtype.coe_injective
    simp only [coe_mul, Subtype.coe_mk, coe_nat_cast]
    rw_mod_cast [@Rat.mul_den_eq_num r]
    rfl
  exact norm_sub_modPart_aux r h
  -- ğŸ‰ no goals
#align padic_int.norm_sub_mod_part PadicInt.norm_sub_modPart

theorem exists_mem_range_of_norm_rat_le_one (h : â€–(r : â„š_[p])â€– â‰¤ 1) :
    âˆƒ n : â„¤, 0 â‰¤ n âˆ§ n < p âˆ§ â€–(âŸ¨r, hâŸ© - n : â„¤_[p])â€– < 1 :=
  âŸ¨modPart p r, modPart_nonneg _, modPart_lt_p _, norm_sub_modPart _ hâŸ©
#align padic_int.exists_mem_range_of_norm_rat_le_one PadicInt.exists_mem_range_of_norm_rat_le_one

theorem zmod_congr_of_sub_mem_span_aux (n : â„•) (x : â„¤_[p]) (a b : â„¤)
    (ha : x - a âˆˆ (Ideal.span {(p : â„¤_[p]) ^ n}))
    (hb : x - b âˆˆ (Ideal.span {(p : â„¤_[p]) ^ n})) : (a : ZMod (p ^ n)) = b := by
  rw [Ideal.mem_span_singleton] at ha hb
  -- âŠ¢ â†‘a = â†‘b
  rw [â† sub_eq_zero, â† Int.cast_sub, ZMod.int_cast_zmod_eq_zero_iff_dvd, Int.coe_nat_pow]
  -- âŠ¢ â†‘p ^ n âˆ£ a - b
  rw [â† dvd_neg, neg_sub] at ha
  -- âŠ¢ â†‘p ^ n âˆ£ a - b
  have := dvd_add ha hb
  -- âŠ¢ â†‘p ^ n âˆ£ a - b
  rwa [sub_eq_add_neg, sub_eq_add_neg, add_assoc, neg_add_cancel_left, â† sub_eq_add_neg, â†
    Int.cast_sub, pow_p_dvd_int_iff, Nat.cast_pow] at this
#align padic_int.zmod_congr_of_sub_mem_span_aux PadicInt.zmod_congr_of_sub_mem_span_aux

theorem zmod_congr_of_sub_mem_span (n : â„•) (x : â„¤_[p]) (a b : â„•)
    (ha : x - a âˆˆ (Ideal.span {(p : â„¤_[p]) ^ n}))
    (hb : x - b âˆˆ (Ideal.span {(p : â„¤_[p]) ^ n})) : (a : ZMod (p ^ n)) = b := by
  simpa using zmod_congr_of_sub_mem_span_aux n x a b ha hb
  -- ğŸ‰ no goals
#align padic_int.zmod_congr_of_sub_mem_span PadicInt.zmod_congr_of_sub_mem_span

theorem zmod_congr_of_sub_mem_max_ideal (x : â„¤_[p]) (m n : â„•) (hm : x - m âˆˆ maximalIdeal â„¤_[p])
    (hn : x - n âˆˆ maximalIdeal â„¤_[p]) : (m : ZMod p) = n := by
  rw [maximalIdeal_eq_span_p] at hm hn
  -- âŠ¢ â†‘m = â†‘n
  have := zmod_congr_of_sub_mem_span_aux 1 x m n
  -- âŠ¢ â†‘m = â†‘n
  simp only [pow_one] at this
  -- âŠ¢ â†‘m = â†‘n
  specialize this hm hn
  -- âŠ¢ â†‘m = â†‘n
  apply_fun ZMod.castHom (show p âˆ£ p ^ 1 by rw [pow_one]) (ZMod p) at this
  -- âŠ¢ â†‘m = â†‘n
  simp only [map_intCast] at this
  -- âŠ¢ â†‘m = â†‘n
  simpa only [Int.cast_ofNat] using this
  -- ğŸ‰ no goals
#align padic_int.zmod_congr_of_sub_mem_max_ideal PadicInt.zmod_congr_of_sub_mem_max_ideal

variable (x : â„¤_[p])

theorem exists_mem_range : âˆƒ n : â„•, n < p âˆ§ x - n âˆˆ maximalIdeal â„¤_[p] := by
  simp only [maximalIdeal_eq_span_p, Ideal.mem_span_singleton, â† norm_lt_one_iff_dvd]
  -- âŠ¢ âˆƒ n, n < p âˆ§ â€–x - â†‘nâ€– < 1
  obtain âŸ¨r, hrâŸ© := rat_dense p (x : â„š_[p]) zero_lt_one
  -- âŠ¢ âˆƒ n, n < p âˆ§ â€–x - â†‘nâ€– < 1
  have H : â€–(r : â„š_[p])â€– â‰¤ 1 := by
    rw [norm_sub_rev] at hr
    calc
      _ = â€–(r : â„š_[p]) - x + xâ€– := by ring_nf
      _ â‰¤ _ := padicNormE.nonarchimedean _ _
      _ â‰¤ _ := max_le (le_of_lt hr) x.2

  obtain âŸ¨n, hzn, hnp, hnâŸ© := exists_mem_range_of_norm_rat_le_one r H
  -- âŠ¢ âˆƒ n, n < p âˆ§ â€–x - â†‘nâ€– < 1
  lift n to â„• using hzn
  -- âŠ¢ âˆƒ n, n < p âˆ§ â€–x - â†‘nâ€– < 1
  use n
  -- âŠ¢ n < p âˆ§ â€–x - â†‘nâ€– < 1
  constructor
  -- âŠ¢ n < p
  Â· exact_mod_cast hnp
    -- ğŸ‰ no goals
  simp only [norm_def, coe_sub, Subtype.coe_mk, coe_nat_cast] at hn âŠ¢
  -- âŠ¢ â€–â†‘x - â†‘nâ€– < 1
  rw [show (x - n : â„š_[p]) = x - r + (r - n) by ring]
  -- âŠ¢ â€–â†‘x - â†‘r + (â†‘r - â†‘n)â€– < 1
  apply lt_of_le_of_lt (padicNormE.nonarchimedean _ _)
  -- âŠ¢ max â€–â†‘x - â†‘râ€– â€–â†‘r - â†‘nâ€– < 1
  apply max_lt hr
  -- âŠ¢ â€–â†‘r - â†‘nâ€– < 1
  simpa using hn
  -- ğŸ‰ no goals
#align padic_int.exists_mem_range PadicInt.exists_mem_range

/-- `zmod_repr x` is the unique natural number smaller than `p`
satisfying `â€–(x - zmod_repr x : â„¤_[p])â€– < 1`.
-/
def zmodRepr : â„• :=
  Classical.choose (exists_mem_range x)
#align padic_int.zmod_repr PadicInt.zmodRepr

theorem zmodRepr_spec : zmodRepr x < p âˆ§ x - zmodRepr x âˆˆ maximalIdeal â„¤_[p] :=
  Classical.choose_spec (exists_mem_range x)
#align padic_int.zmod_repr_spec PadicInt.zmodRepr_spec

theorem zmodRepr_lt_p : zmodRepr x < p :=
  (zmodRepr_spec _).1
#align padic_int.zmod_repr_lt_p PadicInt.zmodRepr_lt_p

theorem sub_zmodRepr_mem : x - zmodRepr x âˆˆ maximalIdeal â„¤_[p] :=
  (zmodRepr_spec _).2
#align padic_int.sub_zmod_repr_mem PadicInt.sub_zmodRepr_mem

/-- `toZModHom` is an auxiliary constructor for creating ring homs from `â„¤_[p]` to `ZMod v`.
-/
def toZModHom (v : â„•) (f : â„¤_[p] â†’ â„•) (f_spec : âˆ€ x, x - f x âˆˆ (Ideal.span {â†‘v} : Ideal â„¤_[p]))
    (f_congr :
      âˆ€ (x : â„¤_[p]) (a b : â„•),
        x - a âˆˆ (Ideal.span {â†‘v} : Ideal â„¤_[p]) â†’
          x - b âˆˆ (Ideal.span {â†‘v} : Ideal â„¤_[p]) â†’ (a : ZMod v) = b) :
    â„¤_[p] â†’+* ZMod v where
  toFun x := f x
  map_zero' := by
    dsimp only
    -- âŠ¢ â†‘(f 0) = 0
    rw [f_congr (0 : â„¤_[p]) _ 0, cast_zero]
    -- âŠ¢ 0 - â†‘(f 0) âˆˆ Ideal.span {â†‘v}
    Â· exact f_spec _
      -- ğŸ‰ no goals
    -- âŠ¢ â†‘(f 1) = 1
    Â· simp only [sub_zero, cast_zero, Submodule.zero_mem]
    -- âŠ¢ 1 - â†‘(f 1) âˆˆ Ideal.span {â†‘v}
      -- ğŸ‰ no goals
      -- ğŸ‰ no goals
  map_one' := by
      -- ğŸ‰ no goals
    dsimp only
    rw [f_congr (1 : â„¤_[p]) _ 1, cast_one]
    Â· exact f_spec _
    Â· simp only [sub_self, cast_one, Submodule.zero_mem]
  map_add' := by
    intro x y
    -- âŠ¢ OneHom.toFun (â†‘{ toOneHom := { toFun := fun x => â†‘(f x), map_one' := (_ : (f â€¦
    dsimp only
    -- âŠ¢ â†‘(f (x + y)) = â†‘(f x) + â†‘(f y)
    rw [f_congr (x + y) _ (f x + f y), cast_add]
    -- âŠ¢ OneHom.toFun { toFun := fun x => â†‘(f x), map_one' := (_ : (fun x => â†‘(f x))  â€¦
    -- âŠ¢ x + y - â†‘(f (x + y)) âˆˆ Ideal.span {â†‘v}
    -- âŠ¢ â†‘(f (x * y)) = â†‘(f x) * â†‘(f y)
    Â· exact f_spec _
    -- âŠ¢ x * y - â†‘(f (x * y)) âˆˆ Ideal.span {â†‘v}
      -- ğŸ‰ no goals
      -- ğŸ‰ no goals
    Â· convert Ideal.add_mem _ (f_spec x) (f_spec y) using 1
      -- âŠ¢ x * y - â†‘(f x * f y) âˆˆ Ideal.span {â†‘v}
      -- âŠ¢ x + y - â†‘(f x + f y) = x - â†‘(f x) + (y - â†‘(f y))
      -- âŠ¢ x * y - â†‘(f x * f y) = x * (y - â†‘(f y)) + (x - â†‘(f x)) * â†‘(f y)
      rw [cast_add]
      -- âŠ¢ x * y - â†‘(f x) * â†‘(f y) = x * (y - â†‘(f y)) + (x - â†‘(f x)) * â†‘(f y)
      -- âŠ¢ x + y - (â†‘(f x) + â†‘(f y)) = x - â†‘(f x) + (y - â†‘(f y))
      -- ğŸ‰ no goals
      ring
      -- ğŸ‰ no goals
  map_mul' := by
    intro x y
    dsimp only
    rw [f_congr (x * y) _ (f x * f y), cast_mul]
    Â· exact f_spec _
    Â· let I : Ideal â„¤_[p] := Ideal.span {â†‘v}
      convert I.add_mem (I.mul_mem_left x (f_spec y)) (I.mul_mem_right â†‘(f y) (f_spec x)) using 1
      rw [cast_mul]
      ring
#align padic_int.to_zmod_hom PadicInt.toZModHom

/-- `toZMod` is a ring hom from `â„¤_[p]` to `ZMod p`,
with the equality `toZMod x = (zmodRepr x : ZMod p)`.
-/
def toZMod : â„¤_[p] â†’+* ZMod p :=
  toZModHom p zmodRepr
    (by
      rw [â† maximalIdeal_eq_span_p]
      -- âŠ¢ âˆ€ (x : â„¤_[p]), x - â†‘(zmodRepr x) âˆˆ maximalIdeal â„¤_[p]
      exact sub_zmodRepr_mem)
      -- ğŸ‰ no goals
    (by
      rw [â† maximalIdeal_eq_span_p]
      -- âŠ¢ âˆ€ (x : â„¤_[p]) (a b : â„•), x - â†‘a âˆˆ maximalIdeal â„¤_[p] â†’ x - â†‘b âˆˆ maximalIdeal â€¦
      exact zmod_congr_of_sub_mem_max_ideal)
      -- ğŸ‰ no goals
#align padic_int.to_zmod PadicInt.toZMod

/-- `z - (toZMod z : â„¤_[p])` is contained in the maximal ideal of `â„¤_[p]`, for every `z : â„¤_[p]`.

The coercion from `ZMod p` to `â„¤_[p]` is `ZMod.cast`,
which coerces `ZMod p` into arbitrary rings.
This is unfortunate, but a consequence of the fact that we allow `ZMod p`
to coerce to rings of arbitrary characteristic, instead of only rings of characteristic `p`.
This coercion is only a ring homomorphism if it coerces into a ring whose characteristic divides
`p`. While this is not the case here we can still make use of the coercion.
-/
theorem toZMod_spec : x - (toZMod x : â„¤_[p]) âˆˆ maximalIdeal â„¤_[p] := by
  convert sub_zmodRepr_mem x using 2
  -- âŠ¢ â†‘(â†‘toZMod x) = â†‘(zmodRepr x)
  dsimp [toZMod, toZModHom]
  -- âŠ¢ â†‘â†‘(zmodRepr x) = â†‘(zmodRepr x)
  rcases exists_eq_add_of_lt hp_prime.1.pos with âŸ¨p', rflâŸ©
  -- âŠ¢ â†‘â†‘(zmodRepr x) = â†‘(zmodRepr x)
  change â†‘((_ : ZMod (0 + p' + 1)).val) = (_ : â„¤_[0 + p' + 1])
  -- âŠ¢ â†‘(ZMod.val â†‘(zmodRepr x)) = â†‘(zmodRepr x)
  simp only [ZMod.val_nat_cast, add_zero, add_def, Nat.cast_inj, zero_add]
  -- âŠ¢ zmodRepr x % (p' + 1) = zmodRepr x
  apply mod_eq_of_lt
  -- âŠ¢ zmodRepr x < p' + 1
  simpa only [zero_add] using zmodRepr_lt_p x
  -- ğŸ‰ no goals
#align padic_int.to_zmod_spec PadicInt.toZMod_spec

theorem ker_toZMod : RingHom.ker (toZMod : â„¤_[p] â†’+* ZMod p) = maximalIdeal â„¤_[p] := by
  ext x
  -- âŠ¢ x âˆˆ RingHom.ker toZMod â†” x âˆˆ maximalIdeal â„¤_[p]
  rw [RingHom.mem_ker]
  -- âŠ¢ â†‘toZMod x = 0 â†” x âˆˆ maximalIdeal â„¤_[p]
  constructor
  -- âŠ¢ â†‘toZMod x = 0 â†’ x âˆˆ maximalIdeal â„¤_[p]
  Â· intro h
    -- âŠ¢ x âˆˆ maximalIdeal â„¤_[p]
    simpa only [h, ZMod.cast_zero, sub_zero] using toZMod_spec x
    -- ğŸ‰ no goals
  Â· intro h
    -- âŠ¢ â†‘toZMod x = 0
    rw [â† sub_zero x] at h
    -- âŠ¢ â†‘toZMod x = 0
    dsimp [toZMod, toZModHom]
    -- âŠ¢ â†‘(zmodRepr x) = 0
    convert zmod_congr_of_sub_mem_max_ideal x _ 0 _ h
    -- âŠ¢ 0 = â†‘0
    norm_cast
    -- âŠ¢ x - â†‘(zmodRepr x) âˆˆ maximalIdeal â„¤_[p]
    apply sub_zmodRepr_mem
    -- ğŸ‰ no goals
#align padic_int.ker_to_zmod PadicInt.ker_toZMod

/-- `appr n x` gives a value `v : â„•` such that `x` and `â†‘v : â„¤_p` are congruent mod `p^n`.
See `appr_spec`. -/
-- Porting note: removing irreducible solves a lot of problems
noncomputable def appr : â„¤_[p] â†’ â„• â†’ â„•
  | _x, 0 => 0
  | x, n + 1 =>
    let y := x - appr x n
    if hy : y = 0 then appr x n
    else
      let u := (unitCoeff hy : â„¤_[p])
      appr x n + p ^ n * (toZMod ((u * (p : â„¤_[p]) ^ (y.valuation - n).natAbs) : â„¤_[p])).val
#align padic_int.appr PadicInt.appr

theorem appr_lt (x : â„¤_[p]) (n : â„•) : x.appr n < p ^ n := by
  induction' n with n ih generalizing x
  -- âŠ¢ appr x zero < p ^ zero
  Â· simp only [appr, zero_eq, _root_.pow_zero, zero_lt_one]
    -- ğŸ‰ no goals
  simp only [appr, map_natCast, ZMod.nat_cast_self, RingHom.map_pow, Int.natAbs, RingHom.map_mul]
  -- âŠ¢ (if h : x - â†‘(appr x n) = 0 then appr x n
  have hp : p ^ n < p ^ (n + 1) := by apply pow_lt_pow hp_prime.1.one_lt (lt_add_one n)
  -- âŠ¢ (if h : x - â†‘(appr x n) = 0 then appr x n
  split_ifs with h
  Â· apply lt_trans (ih _) hp
    -- ğŸ‰ no goals
  Â· calc
      _ < p ^ n + p ^ n * (p - 1) := ?_
      _ = p ^ (n + 1) := ?_

    Â· apply add_lt_add_of_lt_of_le (ih _)
      -- âŠ¢ p ^ n *
      apply Nat.mul_le_mul_left
      -- âŠ¢ ZMod.val
      apply le_pred_of_lt
      -- âŠ¢ ZMod.val
      apply ZMod.val_lt
      -- ğŸ‰ no goals
    Â· rw [mul_tsub, mul_one, â† _root_.pow_succ']
      -- âŠ¢ p ^ n + (p ^ (n + 1) - p ^ n) = p ^ (n + 1)
      apply add_tsub_cancel_of_le (le_of_lt hp)
      -- ğŸ‰ no goals
#align padic_int.appr_lt PadicInt.appr_lt

theorem appr_mono (x : â„¤_[p]) : Monotone x.appr := by
  apply monotone_nat_of_le_succ
  -- âŠ¢ âˆ€ (n : â„•), appr x n â‰¤ appr x (n + 1)
  intro n
  -- âŠ¢ appr x n â‰¤ appr x (n + 1)
  dsimp [appr]
  -- âŠ¢ appr x n â‰¤ if hy : x - â†‘(appr x n) = 0 then appr x n else appr x n + p ^ n * â€¦
  split_ifs; Â· rfl
  -- âŠ¢ appr x n â‰¤ appr x n
               -- ğŸ‰ no goals
  apply Nat.le_add_right
  -- ğŸ‰ no goals
#align padic_int.appr_mono PadicInt.appr_mono

theorem dvd_appr_sub_appr (x : â„¤_[p]) (m n : â„•) (h : m â‰¤ n) : p ^ m âˆ£ x.appr n - x.appr m := by
  obtain âŸ¨k, rflâŸ© := Nat.exists_eq_add_of_le h; clear h
  -- âŠ¢ p ^ m âˆ£ appr x (m + k) - appr x m
                                                -- âŠ¢ p ^ m âˆ£ appr x (m + k) - appr x m
  induction' k with k ih
  -- âŠ¢ p ^ m âˆ£ appr x (m + zero) - appr x m
  Â· simp only [zero_eq, add_zero, le_refl, tsub_eq_zero_of_le, ne_eq, Nat.isUnit_iff, dvd_zero]
    -- ğŸ‰ no goals
  rw [Nat.succ_eq_add_one, â† add_assoc]
  -- âŠ¢ p ^ m âˆ£ appr x (m + k + 1) - appr x m
  dsimp [appr]
  -- âŠ¢ p ^ m âˆ£ (if hy : x - â†‘(appr x (m + k)) = 0 then appr x (m + k) else appr x ( â€¦
  split_ifs with h
  -- âŠ¢ p ^ m âˆ£ appr x (m + k) - appr x m
  Â· exact ih
    -- ğŸ‰ no goals
  rw [add_comm, add_tsub_assoc_of_le (appr_mono _ (Nat.le_add_right m k))]
  -- âŠ¢ p ^ m âˆ£ p ^ (m + k) * ZMod.val (â†‘toZMod (â†‘(unitCoeff h) * â†‘p ^ Int.natAbs (v â€¦
  apply dvd_add _ ih
  -- âŠ¢ p ^ m âˆ£ p ^ (m + k) * ZMod.val (â†‘toZMod (â†‘(unitCoeff h) * â†‘p ^ Int.natAbs (v â€¦
  apply dvd_mul_of_dvd_left
  -- âŠ¢ p ^ m âˆ£ p ^ (m + k)
  apply pow_dvd_pow _ (Nat.le_add_right m k)
  -- ğŸ‰ no goals
#align padic_int.dvd_appr_sub_appr PadicInt.dvd_appr_sub_appr

theorem appr_spec (n : â„•) : âˆ€ x : â„¤_[p], x - appr x n âˆˆ Ideal.span {(p : â„¤_[p]) ^ n} := by
  simp only [Ideal.mem_span_singleton]
  -- âŠ¢ âˆ€ (x : â„¤_[p]), â†‘p ^ n âˆ£ x - â†‘(appr x n)
  induction' n with n ih
  -- âŠ¢ âˆ€ (x : â„¤_[p]), â†‘p ^ zero âˆ£ x - â†‘(appr x zero)
  Â· simp only [zero_eq, _root_.pow_zero, isUnit_one, IsUnit.dvd, forall_const]
    -- ğŸ‰ no goals
  intro x
  -- âŠ¢ â†‘p ^ succ n âˆ£ x - â†‘(appr x (succ n))
  dsimp only [appr]
  -- âŠ¢ â†‘p ^ succ n âˆ£ x - â†‘(if hy : x - â†‘(appr x n) = 0 then appr x n else appr x n  â€¦
  split_ifs with h
  -- âŠ¢ â†‘p ^ succ n âˆ£ x - â†‘(appr x n)
  Â· rw [h]
    -- âŠ¢ â†‘p ^ succ n âˆ£ 0
    apply dvd_zero
    -- ğŸ‰ no goals
  push_cast
  -- âŠ¢ â†‘p ^ succ n âˆ£ x - (â†‘(appr x n) + â†‘p ^ n * â†‘(ZMod.val (â†‘toZMod (â†‘(unitCoeff h â€¦
  rw [sub_add_eq_sub_sub]
  -- âŠ¢ â†‘p ^ succ n âˆ£ x - â†‘(appr x n) - â†‘p ^ n * â†‘(ZMod.val (â†‘toZMod (â†‘(unitCoeff h) â€¦
  obtain âŸ¨c, hcâŸ© := ih x
  -- âŠ¢ â†‘p ^ succ n âˆ£ x - â†‘(appr x n) - â†‘p ^ n * â†‘(ZMod.val (â†‘toZMod (â†‘(unitCoeff h) â€¦
  simp only [map_natCast, ZMod.nat_cast_self, RingHom.map_pow, RingHom.map_mul, ZMod.nat_cast_val]
  -- âŠ¢ â†‘p ^ succ n âˆ£ x - â†‘(appr x n) - â†‘p ^ n * â†‘(â†‘toZMod â†‘(unitCoeff h) * 0 ^ Int. â€¦
  have hc' : c â‰  0 := by
    rintro rfl
    simp only [mul_zero] at hc
    contradiction
  conv_rhs =>
    congr
    simp only [hc]
  rw [show (x - (appr x n : â„¤_[p])).valuation = ((p : â„¤_[p]) ^ n * c).valuation by rw [hc]]
  -- âŠ¢ â†‘p ^ succ n âˆ£ â†‘p ^ n * c - â†‘p ^ n * â†‘(â†‘toZMod â†‘(unitCoeff h) * 0 ^ Int.natAb â€¦
  rw [valuation_p_pow_mul _ _ hc', add_sub_cancel', _root_.pow_succ', â† mul_sub]
  -- âŠ¢ â†‘p ^ n * â†‘p âˆ£ â†‘p ^ n * (c - â†‘(â†‘toZMod â†‘(unitCoeff h) * 0 ^ Int.natAbs (valua â€¦
  apply mul_dvd_mul_left
  -- âŠ¢ â†‘p âˆ£ c - â†‘(â†‘toZMod â†‘(unitCoeff h) * 0 ^ Int.natAbs (valuation c))
  obtain hc0 | hc0 := c.valuation.natAbs.eq_zero_or_pos
  -- âŠ¢ â†‘p âˆ£ c - â†‘(â†‘toZMod â†‘(unitCoeff h) * 0 ^ Int.natAbs (valuation c))
  Â· simp only [hc0, mul_one, _root_.pow_zero]
    -- âŠ¢ â†‘p âˆ£ c - â†‘(â†‘toZMod â†‘(unitCoeff h))
    rw [mul_comm, unitCoeff_spec h] at hc
    -- âŠ¢ â†‘p âˆ£ c - â†‘(â†‘toZMod â†‘(unitCoeff h))
    suffices c = unitCoeff h by
      rw [â† this, â† Ideal.mem_span_singleton, â† maximalIdeal_eq_span_p]
      apply toZMod_spec
    obtain âŸ¨c, rflâŸ© : IsUnit c := by
      -- TODO: write a `CanLift` instance for units
      rw [Int.natAbs_eq_zero] at hc0
      rw [isUnit_iff, norm_eq_pow_val hc', hc0, neg_zero, zpow_zero]
    rw [DiscreteValuationRing.unit_mul_pow_congr_unit _ _ _ _ _ hc]
    -- âŠ¢ Irreducible â†‘p
    exact irreducible_p
    -- ğŸ‰ no goals
  Â· rw [zero_pow hc0]
    -- âŠ¢ â†‘p âˆ£ c - â†‘(â†‘toZMod â†‘(unitCoeff h) * 0)
    simp only [sub_zero, ZMod.cast_zero, mul_zero]
    -- âŠ¢ â†‘p âˆ£ c
    rw [unitCoeff_spec hc']
    -- âŠ¢ â†‘p âˆ£ â†‘(unitCoeff hc') * â†‘p ^ Int.natAbs (valuation c)
    exact (dvd_pow_self (p : â„¤_[p]) hc0.ne').mul_left _
    -- ğŸ‰ no goals
#align padic_int.appr_spec PadicInt.appr_spec

/-- A ring hom from `â„¤_[p]` to `ZMod (p^n)`, with underlying function `PadicInt.appr n`. -/
def toZModPow (n : â„•) : â„¤_[p] â†’+* ZMod (p ^ n) :=
  toZModHom (p ^ n) (fun x => appr x n)
    (by
      intros
      -- âŠ¢ xâœ - â†‘((fun x => appr x n) xâœ) âˆˆ Ideal.span {â†‘(p ^ n)}
      rw [Nat.cast_pow]
      -- âŠ¢ xâœ - â†‘((fun x => appr x n) xâœ) âˆˆ Ideal.span {â†‘p ^ n}
      exact appr_spec n _)
      -- ğŸ‰ no goals
    (by
      intro x a b ha hb
      -- âŠ¢ â†‘a = â†‘b
      apply zmod_congr_of_sub_mem_span n x a b
      -- âŠ¢ x - â†‘a âˆˆ Ideal.span {â†‘p ^ n}
      Â· simpa using ha
        -- ğŸ‰ no goals
      Â· simpa using hb)
        -- ğŸ‰ no goals
#align padic_int.to_zmod_pow PadicInt.toZModPow

theorem ker_toZModPow (n : â„•) :
  RingHom.ker (toZModPow n : â„¤_[p] â†’+* ZMod (p ^ n)) = Ideal.span {(p : â„¤_[p]) ^ n} := by
  ext x
  -- âŠ¢ x âˆˆ RingHom.ker (toZModPow n) â†” x âˆˆ Ideal.span {â†‘p ^ n}
  rw [RingHom.mem_ker]
  -- âŠ¢ â†‘(toZModPow n) x = 0 â†” x âˆˆ Ideal.span {â†‘p ^ n}
  constructor
  -- âŠ¢ â†‘(toZModPow n) x = 0 â†’ x âˆˆ Ideal.span {â†‘p ^ n}
  Â· intro h
    -- âŠ¢ x âˆˆ Ideal.span {â†‘p ^ n}
    suffices x.appr n = 0 by
      convert appr_spec n x
      simp only [this, sub_zero, cast_zero]
    dsimp [toZModPow, toZModHom] at h
    -- âŠ¢ appr x n = 0
    rw [ZMod.nat_cast_zmod_eq_zero_iff_dvd] at h
    -- âŠ¢ appr x n = 0
    apply eq_zero_of_dvd_of_lt h (appr_lt _ _)
    -- ğŸ‰ no goals
  Â· intro h
    -- âŠ¢ â†‘(toZModPow n) x = 0
    rw [â† sub_zero x] at h
    -- âŠ¢ â†‘(toZModPow n) x = 0
    dsimp [toZModPow, toZModHom]
    -- âŠ¢ â†‘(appr x n) = 0
    rw [zmod_congr_of_sub_mem_span n x _ 0 _ h, cast_zero]
    -- âŠ¢ x - â†‘(appr x n) âˆˆ Ideal.span {â†‘p ^ n}
    apply appr_spec
    -- ğŸ‰ no goals
#align padic_int.ker_to_zmod_pow PadicInt.ker_toZModPow

-- @[simp] -- Porting note: not in simpNF
theorem zmod_cast_comp_toZModPow (m n : â„•) (h : m â‰¤ n) :
    (ZMod.castHom (pow_dvd_pow p h) (ZMod (p ^ m))).comp (@toZModPow p _ n) = @toZModPow p _ m := by
  apply ZMod.ringHom_eq_of_ker_eq
  -- âŠ¢ RingHom.ker (RingHom.comp (ZMod.castHom (_ : p ^ m âˆ£ p ^ n) (ZMod (p ^ m)))  â€¦
  ext x
  -- âŠ¢ x âˆˆ RingHom.ker (RingHom.comp (ZMod.castHom (_ : p ^ m âˆ£ p ^ n) (ZMod (p ^ m â€¦
  rw [RingHom.mem_ker, RingHom.mem_ker]
  -- âŠ¢ â†‘(RingHom.comp (ZMod.castHom (_ : p ^ m âˆ£ p ^ n) (ZMod (p ^ m))) (toZModPow  â€¦
  simp only [Function.comp_apply, ZMod.castHom_apply, RingHom.coe_comp]
  -- âŠ¢ â†‘(â†‘(toZModPow n) x) = 0 â†” â†‘(toZModPow m) x = 0
  simp only [toZModPow, toZModHom, RingHom.coe_mk]
  -- âŠ¢ â†‘(â†‘{ toOneHom := { toFun := fun x => â†‘(appr x n), map_one' := (_ : (fun x => â€¦
  dsimp
  -- âŠ¢ â†‘â†‘(appr x n) = 0 â†” â†‘(appr x m) = 0
  rw [ZMod.cast_nat_cast (pow_dvd_pow p h),
    zmod_congr_of_sub_mem_span m (x.appr n) (x.appr n) (x.appr m)]
  Â· rw [sub_self]
    -- âŠ¢ 0 âˆˆ Ideal.span {â†‘p ^ m}
    apply Ideal.zero_mem _
    -- ğŸ‰ no goals
  Â· rw [Ideal.mem_span_singleton]
    -- âŠ¢ â†‘p ^ m âˆ£ â†‘(appr x n) - â†‘(appr x m)
    rcases dvd_appr_sub_appr x m n h with âŸ¨c, hcâŸ©
    -- âŠ¢ â†‘p ^ m âˆ£ â†‘(appr x n) - â†‘(appr x m)
    use c
    -- âŠ¢ â†‘(appr x n) - â†‘(appr x m) = â†‘p ^ m * â†‘c
    rw [â† Nat.cast_sub (appr_mono _ h), hc, Nat.cast_mul, Nat.cast_pow]
    -- ğŸ‰ no goals
#align padic_int.zmod_cast_comp_to_zmod_pow PadicInt.zmod_cast_comp_toZModPow

@[simp]
theorem cast_toZModPow (m n : â„•) (h : m â‰¤ n) (x : â„¤_[p]) : â†‘(toZModPow n x) = toZModPow m x := by
  rw [â† zmod_cast_comp_toZModPow _ _ h]
  -- âŠ¢ â†‘(â†‘(toZModPow n) x) = â†‘(RingHom.comp (ZMod.castHom (_ : p ^ m âˆ£ p ^ n) (ZMod â€¦
  rfl
  -- ğŸ‰ no goals
#align padic_int.cast_to_zmod_pow PadicInt.cast_toZModPow

theorem denseRange_nat_cast : DenseRange (Nat.cast : â„• â†’ â„¤_[p]) := by
  intro x
  -- âŠ¢ x âˆˆ closure (Set.range Nat.cast)
  rw [Metric.mem_closure_range_iff]
  -- âŠ¢ âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ k, dist x â†‘k < Îµ
  intro Îµ hÎµ
  -- âŠ¢ âˆƒ k, dist x â†‘k < Îµ
  obtain âŸ¨n, hnâŸ© := exists_pow_neg_lt p hÎµ
  -- âŠ¢ âˆƒ k, dist x â†‘k < Îµ
  use x.appr n
  -- âŠ¢ dist x â†‘(appr x n) < Îµ
  rw [dist_eq_norm]
  -- âŠ¢ â€–x - â†‘(appr x n)â€– < Îµ
  apply lt_of_le_of_lt _ hn
  -- âŠ¢ â€–x - â†‘(appr x n)â€– â‰¤ â†‘p ^ (-â†‘n)
  rw [norm_le_pow_iff_mem_span_pow]
  -- âŠ¢ x - â†‘(appr x n) âˆˆ Ideal.span {â†‘p ^ n}
  apply appr_spec
  -- ğŸ‰ no goals
#align padic_int.dense_range_nat_cast PadicInt.denseRange_nat_cast

theorem denseRange_int_cast : DenseRange (Int.cast : â„¤ â†’ â„¤_[p]) := by
  intro x
  -- âŠ¢ x âˆˆ closure (Set.range Int.cast)
  refine DenseRange.induction_on denseRange_nat_cast x ?_ ?_
  -- âŠ¢ IsClosed {b | b âˆˆ closure (Set.range Int.cast)}
  Â· exact isClosed_closure
    -- ğŸ‰ no goals
  Â· intro a
    -- âŠ¢ â†‘a âˆˆ closure (Set.range Int.cast)
    apply subset_closure
    -- âŠ¢ â†‘a âˆˆ Set.range Int.cast
    exact Set.mem_range_self _
    -- ğŸ‰ no goals
#align padic_int.dense_range_int_cast PadicInt.denseRange_int_cast

end RingHoms

section lift

/-! ### Universal property as projective limit -/


open CauSeq PadicSeq

variable {R : Type*} [NonAssocSemiring R] (f : âˆ€ k : â„•, R â†’+* ZMod (p ^ k))
  (f_compat : âˆ€ (k1 k2) (hk : k1 â‰¤ k2), (ZMod.castHom (pow_dvd_pow p hk) _).comp (f k2) = f k1)

/-- Given a family of ring homs `f : Î  n : â„•, R â†’+* ZMod (p ^ n)`,
`nthHom f r` is an integer-valued sequence
whose `n`th value is the unique integer `k` such that `0 â‰¤ k < p ^ n`
and `f n r = (k : ZMod (p ^ n))`.
-/
def nthHom (r : R) : â„• â†’ â„¤ := fun n => (f n r : ZMod (p ^ n)).val
#align padic_int.nth_hom PadicInt.nthHom

@[simp]
theorem nthHom_zero : nthHom f 0 = 0 := by simp [nthHom]; rfl
                                           -- âŠ¢ (fun n => 0) = 0
                                                          -- ğŸ‰ no goals
#align padic_int.nth_hom_zero PadicInt.nthHom_zero

variable {f}

theorem pow_dvd_nthHom_sub (r : R) (i j : â„•) (h : i â‰¤ j) :
    (p : â„¤) ^ i âˆ£ nthHom f r j - nthHom f r i := by
  specialize f_compat i j h
  -- âŠ¢ â†‘p ^ i âˆ£ nthHom f r j - nthHom f r i
  rw [â† Int.coe_nat_pow, â† ZMod.int_cast_zmod_eq_zero_iff_dvd, Int.cast_sub]
  -- âŠ¢ â†‘(nthHom f r j) - â†‘(nthHom f r i) = 0
  dsimp [nthHom]
  -- âŠ¢ â†‘â†‘(ZMod.val (â†‘(f j) r)) - â†‘â†‘(ZMod.val (â†‘(f i) r)) = 0
  rw [â† f_compat, RingHom.comp_apply]
  -- âŠ¢ â†‘â†‘(ZMod.val (â†‘(f j) r)) - â†‘â†‘(ZMod.val (â†‘(ZMod.castHom (_ : p ^ i âˆ£ p ^ j) (Z â€¦
  simp only [ZMod.cast_id, ZMod.castHom_apply, sub_self, ZMod.nat_cast_val, ZMod.int_cast_cast]
  -- ğŸ‰ no goals
#align padic_int.pow_dvd_nth_hom_sub PadicInt.pow_dvd_nthHom_sub

theorem isCauSeq_nthHom (r : R) : IsCauSeq (padicNorm p) fun n => nthHom f r n := by
  intro Îµ hÎµ
  -- âŠ¢ âˆƒ i, âˆ€ (j : â„•), j â‰¥ i â†’ padicNorm p ((fun n => â†‘(nthHom f r n)) j - (fun n = â€¦
  obtain âŸ¨k, hkâŸ© : âˆƒ k : â„•, (p : â„š) ^ (-((k : â„•) : â„¤)) < Îµ := exists_pow_neg_lt_rat p hÎµ
  -- âŠ¢ âˆƒ i, âˆ€ (j : â„•), j â‰¥ i â†’ padicNorm p ((fun n => â†‘(nthHom f r n)) j - (fun n = â€¦
  use k
  -- âŠ¢ âˆ€ (j : â„•), j â‰¥ k â†’ padicNorm p ((fun n => â†‘(nthHom f r n)) j - (fun n => â†‘(n â€¦
  intro j hj
  -- âŠ¢ padicNorm p ((fun n => â†‘(nthHom f r n)) j - (fun n => â†‘(nthHom f r n)) k) < Îµ
  refine' lt_of_le_of_lt _ hk
  -- âŠ¢ padicNorm p ((fun n => â†‘(nthHom f r n)) j - (fun n => â†‘(nthHom f r n)) k) â‰¤  â€¦
  norm_cast
  -- âŠ¢ padicNorm p â†‘(nthHom f r j - nthHom f r k) â‰¤ â†‘p ^ (-â†‘k)
  rw [â† padicNorm.dvd_iff_norm_le]
  -- âŠ¢ â†‘(p ^ k) âˆ£ nthHom f r j - nthHom f r k
  exact_mod_cast pow_dvd_nthHom_sub f_compat r k j hj
  -- ğŸ‰ no goals
#align padic_int.is_cau_seq_nth_hom PadicInt.isCauSeq_nthHom

/-- `nthHomSeq f_compat r` bundles `PadicInt.nthHom f r`
as a Cauchy sequence of rationals with respect to the `p`-adic norm.
The `n`th value of the sequence is `((f n r).val : â„š)`.
-/
def nthHomSeq (r : R) : PadicSeq p :=
  âŸ¨fun n => nthHom f r n, isCauSeq_nthHom f_compat râŸ©
#align padic_int.nth_hom_seq PadicInt.nthHomSeq

-- this lemma ran into issues after changing to `NeZero` and I'm not sure why.
theorem nthHomSeq_one : nthHomSeq f_compat 1 â‰ˆ 1 := by
  intro Îµ hÎµ
  -- âŠ¢ âˆƒ i, âˆ€ (j : â„•), j â‰¥ i â†’ padicNorm p (â†‘(nthHomSeq f_compat 1 - 1) j) < Îµ
  change _ < _ at hÎµ
  -- âŠ¢ âˆƒ i, âˆ€ (j : â„•), j â‰¥ i â†’ padicNorm p (â†‘(nthHomSeq f_compat 1 - 1) j) < Îµ
  use 1
  -- âŠ¢ âˆ€ (j : â„•), j â‰¥ 1 â†’ padicNorm p (â†‘(nthHomSeq f_compat 1 - 1) j) < Îµ
  intro j hj
  -- âŠ¢ padicNorm p (â†‘(nthHomSeq f_compat 1 - 1) j) < Îµ
  haveI : Fact (1 < p ^ j) := âŸ¨Nat.one_lt_pow _ _ (by linarith) hp_prime.1.one_ltâŸ©
  -- âŠ¢ padicNorm p (â†‘(nthHomSeq f_compat 1 - 1) j) < Îµ
  suffices ((1 : ZMod (p ^ j)) : â„š) = 1 by simp [nthHomSeq, nthHom, this, hÎµ]
  -- âŠ¢ â†‘1 = 1
  rw [ZMod.cast_eq_val, ZMod.val_one, Nat.cast_one]
  -- ğŸ‰ no goals
#align padic_int.nth_hom_seq_one PadicInt.nthHomSeq_one

theorem nthHomSeq_add (r s : R) :
    nthHomSeq f_compat (r + s) â‰ˆ nthHomSeq f_compat r + nthHomSeq f_compat s := by
  intro Îµ hÎµ
  -- âŠ¢ âˆƒ i, âˆ€ (j : â„•), j â‰¥ i â†’ padicNorm p (â†‘(nthHomSeq f_compat (r + s) - (nthHomS â€¦
  obtain âŸ¨n, hnâŸ© := exists_pow_neg_lt_rat p hÎµ
  -- âŠ¢ âˆƒ i, âˆ€ (j : â„•), j â‰¥ i â†’ padicNorm p (â†‘(nthHomSeq f_compat (r + s) - (nthHomS â€¦
  use n
  -- âŠ¢ âˆ€ (j : â„•), j â‰¥ n â†’ padicNorm p (â†‘(nthHomSeq f_compat (r + s) - (nthHomSeq f_ â€¦
  intro j hj
  -- âŠ¢ padicNorm p (â†‘(nthHomSeq f_compat (r + s) - (nthHomSeq f_compat r + nthHomSe â€¦
  dsimp [nthHomSeq]
  -- âŠ¢ padicNorm p (â†‘(nthHom (fun k2 => f k2) (r + s) j) - (â†‘(nthHom (fun k2 => f k â€¦
  apply lt_of_le_of_lt _ hn
  -- âŠ¢ padicNorm p (â†‘(nthHom (fun k2 => f k2) (r + s) j) - (â†‘(nthHom (fun k2 => f k â€¦
  rw [â† Int.cast_add, â† Int.cast_sub, â† padicNorm.dvd_iff_norm_le, â†
    ZMod.int_cast_zmod_eq_zero_iff_dvd]
  dsimp [nthHom]
  -- âŠ¢ â†‘(â†‘(ZMod.val (â†‘(f j) (r + s))) - â†‘(ZMod.val (â†‘(f j) r) + ZMod.val (â†‘(f j) s) â€¦
  simp only [ZMod.nat_cast_val, RingHom.map_add, Int.cast_sub, ZMod.int_cast_cast, Int.cast_add]
  -- âŠ¢ â†‘(â†‘(f j) r + â†‘(f j) s) - â†‘â†‘(ZMod.val (â†‘(f j) r) + ZMod.val (â†‘(f j) s)) = 0
  rw [ZMod.cast_add (show p ^ n âˆ£ p ^ j from pow_dvd_pow _ hj)]
  -- âŠ¢ â†‘(â†‘(f j) r) + â†‘(â†‘(f j) s) - â†‘â†‘(ZMod.val (â†‘(f j) r) + ZMod.val (â†‘(f j) s)) = 0
  simp only [cast_add, ZMod.nat_cast_val, Int.cast_add, ZMod.int_cast_cast, sub_self]
  -- ğŸ‰ no goals
#align padic_int.nth_hom_seq_add PadicInt.nthHomSeq_add

theorem nthHomSeq_mul (r s : R) :
    nthHomSeq f_compat (r * s) â‰ˆ nthHomSeq f_compat r * nthHomSeq f_compat s := by
  intro Îµ hÎµ
  -- âŠ¢ âˆƒ i, âˆ€ (j : â„•), j â‰¥ i â†’ padicNorm p (â†‘(nthHomSeq f_compat (r * s) - nthHomSe â€¦
  obtain âŸ¨n, hnâŸ© := exists_pow_neg_lt_rat p hÎµ
  -- âŠ¢ âˆƒ i, âˆ€ (j : â„•), j â‰¥ i â†’ padicNorm p (â†‘(nthHomSeq f_compat (r * s) - nthHomSe â€¦
  use n
  -- âŠ¢ âˆ€ (j : â„•), j â‰¥ n â†’ padicNorm p (â†‘(nthHomSeq f_compat (r * s) - nthHomSeq f_c â€¦
  intro j hj
  -- âŠ¢ padicNorm p (â†‘(nthHomSeq f_compat (r * s) - nthHomSeq f_compat r * nthHomSeq â€¦
  dsimp [nthHomSeq]
  -- âŠ¢ padicNorm p (â†‘(nthHom (fun k2 => f k2) (r * s) j) - â†‘(nthHom (fun k2 => f k2 â€¦
  apply lt_of_le_of_lt _ hn
  -- âŠ¢ padicNorm p (â†‘(nthHom (fun k2 => f k2) (r * s) j) - â†‘(nthHom (fun k2 => f k2 â€¦
  rw [â† Int.cast_mul, â† Int.cast_sub, â† padicNorm.dvd_iff_norm_le, â†
    ZMod.int_cast_zmod_eq_zero_iff_dvd]
  dsimp [nthHom]
  -- âŠ¢ â†‘(â†‘(ZMod.val (â†‘(f j) (r * s))) - â†‘(ZMod.val (â†‘(f j) r)) * â†‘(ZMod.val (â†‘(f j) â€¦
  simp only [ZMod.nat_cast_val, RingHom.map_mul, Int.cast_sub, ZMod.int_cast_cast, Int.cast_mul]
  -- âŠ¢ â†‘(â†‘(f j) r * â†‘(f j) s) - â†‘(â†‘(f j) r) * â†‘(â†‘(f j) s) = 0
  rw [ZMod.cast_mul (show p ^ n âˆ£ p ^ j from pow_dvd_pow _ hj), sub_self]
  -- ğŸ‰ no goals
#align padic_int.nth_hom_seq_mul PadicInt.nthHomSeq_mul

/--
`limNthHom f_compat r` is the limit of a sequence `f` of compatible ring homs `R â†’+* ZMod (p^k)`.
This is itself a ring hom: see `PadicInt.lift`.
-/
def limNthHom (r : R) : â„¤_[p] :=
  ofIntSeq (nthHom f r) (isCauSeq_nthHom f_compat r)
#align padic_int.lim_nth_hom PadicInt.limNthHom

theorem limNthHom_spec (r : R) :
    âˆ€ Îµ : â„, 0 < Îµ â†’ âˆƒ N : â„•, âˆ€ n â‰¥ N, â€–limNthHom f_compat r - nthHom f r nâ€– < Îµ := by
  intro Îµ hÎµ
  -- âŠ¢ âˆƒ N, âˆ€ (n : â„•), n â‰¥ N â†’ â€–limNthHom f_compat r - â†‘(nthHom f r n)â€– < Îµ
  obtain âŸ¨Îµ', hÎµ'0, hÎµ'âŸ© : âˆƒ v : â„š, (0 : â„) < v âˆ§ â†‘v < Îµ := exists_rat_btwn hÎµ
  -- âŠ¢ âˆƒ N, âˆ€ (n : â„•), n â‰¥ N â†’ â€–limNthHom f_compat r - â†‘(nthHom f r n)â€– < Îµ
  norm_cast at hÎµ'0
  -- âŠ¢ âˆƒ N, âˆ€ (n : â„•), n â‰¥ N â†’ â€–limNthHom f_compat r - â†‘(nthHom f r n)â€– < Îµ
  obtain âŸ¨N, hNâŸ© := padicNormE.defn (nthHomSeq f_compat r) hÎµ'0
  -- âŠ¢ âˆƒ N, âˆ€ (n : â„•), n â‰¥ N â†’ â€–limNthHom f_compat r - â†‘(nthHom f r n)â€– < Îµ
  use N
  -- âŠ¢ âˆ€ (n : â„•), n â‰¥ N â†’ â€–limNthHom f_compat r - â†‘(nthHom f r n)â€– < Îµ
  intro n hn
  -- âŠ¢ â€–limNthHom f_compat r - â†‘(nthHom f r n)â€– < Îµ
  apply _root_.lt_trans _ hÎµ'
  -- âŠ¢ â€–limNthHom f_compat r - â†‘(nthHom f r n)â€– < â†‘Îµ'
  change (padicNormE _  : â„) < _
  -- âŠ¢ â†‘(â†‘padicNormE â†‘(limNthHom f_compat r - â†‘(nthHom f r n))) < â†‘Îµ'
  norm_cast
  -- âŠ¢ â†‘padicNormE â†‘(limNthHom f_compat r - â†‘(nthHom f r n)) < Îµ'
  exact hN _ hn
  -- ğŸ‰ no goals
#align padic_int.lim_nth_hom_spec PadicInt.limNthHom_spec

theorem limNthHom_zero : limNthHom f_compat 0 = 0 := by simp [limNthHom]; rfl
                                                        -- âŠ¢ ofIntSeq 0 (_ : IsCauSeq (padicNorm p) fun n => â†‘(OfNat.ofNat 0 n)) = 0
                                                                          -- ğŸ‰ no goals
#align padic_int.lim_nth_hom_zero PadicInt.limNthHom_zero

theorem limNthHom_one : limNthHom f_compat 1 = 1 :=
  Subtype.ext <| Quot.sound <| nthHomSeq_one f_compat
#align padic_int.lim_nth_hom_one PadicInt.limNthHom_one

theorem limNthHom_add (r s : R) :
    limNthHom f_compat (r + s) = limNthHom f_compat r + limNthHom f_compat s :=
  Subtype.ext <| Quot.sound <| nthHomSeq_add f_compat _ _
#align padic_int.lim_nth_hom_add PadicInt.limNthHom_add

theorem limNthHom_mul (r s : R) :
    limNthHom f_compat (r * s) = limNthHom f_compat r * limNthHom f_compat s :=
  Subtype.ext <| Quot.sound <| nthHomSeq_mul f_compat _ _
#align padic_int.lim_nth_hom_mul PadicInt.limNthHom_mul

-- TODO: generalize this to arbitrary complete discrete valuation rings
/-- `lift f_compat` is the limit of a sequence `f` of compatible ring homs `R â†’+* ZMod (p^k)`,
with the equality `lift f_compat r = PadicInt.limNthHom f_compat r`.
-/
def lift : R â†’+* â„¤_[p] where
  toFun := limNthHom f_compat
  map_one' := limNthHom_one f_compat
  map_mul' := limNthHom_mul f_compat
  map_zero' := limNthHom_zero f_compat
  map_add' := limNthHom_add f_compat
#align padic_int.lift PadicInt.lift

theorem lift_sub_val_mem_span (r : R) (n : â„•) :
    lift f_compat r - (f n r).val âˆˆ (Ideal.span {(p : â„¤_[p]) ^ n}) := by
  obtain âŸ¨k, hkâŸ© :=
    limNthHom_spec f_compat r _
      (show (0 : â„) < (p : â„) ^ (-n : â„¤) from Nat.zpow_pos_of_pos hp_prime.1.pos _)
  have := le_of_lt (hk (max n k) (le_max_right _ _))
  -- âŠ¢ â†‘(lift f_compat) r - â†‘(ZMod.val (â†‘(f n) r)) âˆˆ Ideal.span {â†‘p ^ n}
  rw [norm_le_pow_iff_mem_span_pow] at this
  -- âŠ¢ â†‘(lift f_compat) r - â†‘(ZMod.val (â†‘(f n) r)) âˆˆ Ideal.span {â†‘p ^ n}
  dsimp [lift]
  -- âŠ¢ limNthHom f_compat r - â†‘(ZMod.val (â†‘(f n) r)) âˆˆ Ideal.span {â†‘p ^ n}
  rw [sub_eq_sub_add_sub (limNthHom f_compat r) _ â†‘(nthHom f r (max n k))]
  -- âŠ¢ â†‘(nthHom f r (max n k)) - â†‘(ZMod.val (â†‘(f n) r)) + (limNthHom f_compat r - â†‘ â€¦
  apply Ideal.add_mem _ _ this
  -- âŠ¢ â†‘(nthHom f r (max n k)) - â†‘(ZMod.val (â†‘(f n) r)) âˆˆ Ideal.span {â†‘p ^ n}
  rw [Ideal.mem_span_singleton]
  -- âŠ¢ â†‘p ^ n âˆ£ â†‘(nthHom f r (max n k)) - â†‘(ZMod.val (â†‘(f n) r))
  convert
    (Int.castRingHom â„¤_[p]).map_dvd (pow_dvd_nthHom_sub f_compat r n (max n k) (le_max_left _ _))
  Â· rw [map_pow]; rfl
    -- âŠ¢ â†‘p ^ n = â†‘(Int.castRingHom â„¤_[p]) â†‘p ^ n
                  -- ğŸ‰ no goals
  Â· rw [map_sub]; rfl
    -- âŠ¢ â†‘(nthHom f r (max n k)) - â†‘(ZMod.val (â†‘(f n) r)) = â†‘(Int.castRingHom â„¤_[p])  â€¦
                  -- ğŸ‰ no goals
#align padic_int.lift_sub_val_mem_span PadicInt.lift_sub_val_mem_span

/-- One part of the universal property of `â„¤_[p]` as a projective limit.
See also `PadicInt.lift_unique`.
-/
theorem lift_spec (n : â„•) : (toZModPow n).comp (lift f_compat) = f n := by
  ext r
  -- âŠ¢ â†‘(RingHom.comp (toZModPow n) (lift f_compat)) r = â†‘(f n) r
  rw [RingHom.comp_apply, â† ZMod.nat_cast_zmod_val (f n r), â† map_natCast <| toZModPow n, â†
    sub_eq_zero, â† RingHom.map_sub, â† RingHom.mem_ker, ker_toZModPow]
  apply lift_sub_val_mem_span
  -- ğŸ‰ no goals
#align padic_int.lift_spec PadicInt.lift_spec

/-- One part of the universal property of `â„¤_[p]` as a projective limit.
See also `PadicInt.lift_spec`.
-/
theorem lift_unique (g : R â†’+* â„¤_[p]) (hg : âˆ€ n, (toZModPow n).comp g = f n) :
    lift f_compat = g := by
  ext1 r
  -- âŠ¢ â†‘(lift f_compat) r = â†‘g r
  apply eq_of_forall_dist_le
  -- âŠ¢ âˆ€ (Îµ : â„), Îµ > 0 â†’ dist (â†‘(lift f_compat) r) (â†‘g r) â‰¤ Îµ
  intro Îµ hÎµ
  -- âŠ¢ dist (â†‘(lift f_compat) r) (â†‘g r) â‰¤ Îµ
  obtain âŸ¨n, hnâŸ© := exists_pow_neg_lt p hÎµ
  -- âŠ¢ dist (â†‘(lift f_compat) r) (â†‘g r) â‰¤ Îµ
  apply le_trans _ (le_of_lt hn)
  -- âŠ¢ dist (â†‘(lift f_compat) r) (â†‘g r) â‰¤ â†‘p ^ (-â†‘n)
  rw [dist_eq_norm, norm_le_pow_iff_mem_span_pow, â† ker_toZModPow, RingHom.mem_ker,
    RingHom.map_sub, â† RingHom.comp_apply, â† RingHom.comp_apply, lift_spec, hg, sub_self]
#align padic_int.lift_unique PadicInt.lift_unique

@[simp]
theorem lift_self (z : â„¤_[p]) : @lift p _ â„¤_[p] _ toZModPow zmod_cast_comp_toZModPow z = z := by
  show _ = RingHom.id _ z
  -- âŠ¢ â†‘(lift (_ : âˆ€ (m n : â„•) (h : m â‰¤ n), RingHom.comp (ZMod.castHom (_ : p ^ m âˆ£ â€¦
  rw [@lift_unique p _ â„¤_[p] _ _ zmod_cast_comp_toZModPow (RingHom.id â„¤_[p])]
  -- âŠ¢ âˆ€ (n : â„•), RingHom.comp (toZModPow n) (RingHom.id â„¤_[p]) = toZModPow n
  intro; rw [RingHom.comp_id]
  -- âŠ¢ RingHom.comp (toZModPow nâœ) (RingHom.id â„¤_[p]) = toZModPow nâœ
         -- ğŸ‰ no goals
#align padic_int.lift_self PadicInt.lift_self

end lift

theorem ext_of_toZModPow {x y : â„¤_[p]} : (âˆ€ n, toZModPow n x = toZModPow n y) â†” x = y := by
  constructor
  -- âŠ¢ (âˆ€ (n : â„•), â†‘(toZModPow n) x = â†‘(toZModPow n) y) â†’ x = y
  Â· intro h
    -- âŠ¢ x = y
    rw [â† lift_self x, â† lift_self y]
    -- âŠ¢ â†‘(lift (_ : âˆ€ (m n : â„•) (h : m â‰¤ n), RingHom.comp (ZMod.castHom (_ : p ^ m âˆ£ â€¦
    simp [lift, limNthHom, nthHom, h]
    -- ğŸ‰ no goals
  Â· rintro rfl _
    -- âŠ¢ â†‘(toZModPow nâœ) x = â†‘(toZModPow nâœ) x
    rfl
    -- ğŸ‰ no goals
#align padic_int.ext_of_to_zmod_pow PadicInt.ext_of_toZModPow

theorem toZModPow_eq_iff_ext {R : Type*} [NonAssocSemiring R] {g g' : R â†’+* â„¤_[p]} :
    (âˆ€ n, (toZModPow n).comp g = (toZModPow n).comp g') â†” g = g' := by
  constructor
  -- âŠ¢ (âˆ€ (n : â„•), RingHom.comp (toZModPow n) g = RingHom.comp (toZModPow n) g') â†’  â€¦
  Â· intro hg
    -- âŠ¢ g = g'
    ext x : 1
    -- âŠ¢ â†‘g x = â†‘g' x
    apply ext_of_toZModPow.mp
    -- âŠ¢ âˆ€ (n : â„•), â†‘(toZModPow n) (â†‘g x) = â†‘(toZModPow n) (â†‘g' x)
    intro n
    -- âŠ¢ â†‘(toZModPow n) (â†‘g x) = â†‘(toZModPow n) (â†‘g' x)
    show (toZModPow n).comp g x = (toZModPow n).comp g' x
    -- âŠ¢ â†‘(RingHom.comp (toZModPow n) g) x = â†‘(RingHom.comp (toZModPow n) g') x
    rw [hg n]
    -- ğŸ‰ no goals
  Â· rintro rfl _
    -- âŠ¢ RingHom.comp (toZModPow nâœ) g = RingHom.comp (toZModPow nâœ) g
    rfl
    -- ğŸ‰ no goals
#align padic_int.to_zmod_pow_eq_iff_ext PadicInt.toZModPow_eq_iff_ext

end PadicInt
