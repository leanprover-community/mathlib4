/-
Copyright (c) 2025 Xavier Roblot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Xavier Roblot
-/
import Mathlib.Analysis.Asymptotics.SpecificAsymptotics
import Mathlib.Analysis.InnerProductSpace.Calculus
import Mathlib.Analysis.SpecialFunctions.ImproperIntegrals
import Mathlib.NumberTheory.AbelSummation
import Mathlib.NumberTheory.LSeries.Basic

/-!

=======
# Partial sums of coefficients of L-series

We prove several results involving partial sums of coefficients (or norm of coefficients) of
L-series.

## Main results

* `LSeriesSummable_of_sum_norm_bigO`: for `f : ‚Ñï ‚Üí ‚ÑÇ`, if the partial sums
  `‚àë k ‚àà Icc 1 n, ‚Äñf k‚Äñ` are `O(n ^ r)` for some real `0 ‚â§ r`, then the L-series `LSeries f`
  converges at `s : ‚ÑÇ` for all `s` such that `r < s.re`.

* `LSeries_eq_mul_integral` : for `f : ‚Ñï ‚Üí ‚ÑÇ`, if the partial sums `‚àë k ‚àà Icc 1 n, f k` are
  `O(n ^ r)` for some real `0 ‚â§ r` and the L-series `LSeries f` converges at `s : ‚ÑÇ` with
  `r < s.re`, then `LSeries f s = s * ‚à´ t in Set.Ioi 1, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * t ^ (-(s + 1))`.

* `LSeries_tendsto_sub_mul_nhds_one_of_tendsto_sum_div` : assume that `f : ‚Ñï ‚Üí ‚ÑÇ` satifies that
  `(‚àë k ‚àà Icc 1 n, f k) / n` tends to some complex number `l` when `n ‚Üí ‚àû` and that the L-series
  `LSeries f` converges for all `s : ‚Ñù` such that `1 < s`. Then `(s - 1) * LSeries f s` tends
  to `l` when `s ‚Üí 1` with `1 < s`.

-/

open Finset Filter MeasureTheory Topology Complex Asymptotics

section summable

variable {f : ‚Ñï ‚Üí ‚ÑÇ} {r : ‚Ñù} {s : ‚ÑÇ}

private theorem LSeriesSummable_of_sum_norm_bigO_aux (hf : f 0 = 0)
    (hO : (fun n ‚Ü¶ ‚àë k ‚àà Icc 1 n, ‚Äñf k‚Äñ) =O[atTop] fun n ‚Ü¶ (n : ‚Ñù) ^ r)
    (hr : 0 ‚â§ r) (hs : r < s.re) :
    LSeriesSummable f s := by
  have h‚ÇÅ : -s ‚â† 0 := neg_ne_zero.mpr <| ne_zero_of_re_pos (hr.trans_lt hs)
  have h‚ÇÇ : (-s).re + r ‚â§ 0 := by
    rw [neg_re, neg_add_nonpos_iff]
    exact hs.le
  have h‚ÇÉ (t : ‚Ñù) (ht : t ‚àà Set.Ici 1) : DifferentiableAt ‚Ñù (fun x : ‚Ñù ‚Ü¶ ‚Äñ(x : ‚ÑÇ) ^ (-s)‚Äñ) t :=
    have ht' : t ‚â† 0 := (zero_lt_one.trans_le ht).ne'
    (differentiableAt_id.ofReal_cpow_const ht' h‚ÇÅ).norm ‚Ñù <|
      (cpow_ne_zero_iff_of_exponent_ne_zero h‚ÇÅ).mpr <| ofReal_ne_zero.mpr ht'
  have h‚ÇÑ : (deriv fun t : ‚Ñù ‚Ü¶ ‚Äñ(t : ‚ÑÇ) ^ (-s)‚Äñ) =·∂†[atTop] fun t ‚Ü¶ -s.re * t ^ (-(s.re +1)) := by
    filter_upwards [eventually_gt_atTop 0] with t ht
    rw [deriv_norm_ofReal_cpow _ ht, neg_re, neg_add']
  simp_rw [LSeriesSummable, funext (LSeries.term_def‚ÇÄ hf s), mul_comm (f _)]
  refine summable_mul_of_bigO_atTop' (f := fun t ‚Ü¶ (t : ‚ÑÇ) ^ (-s))
    (g := fun t ‚Ü¶ t ^ (-(s.re + 1) + r)) _ h‚ÇÉ ?_ ?_ ?_ ?_
  ¬∑ refine (integrableOn_Ici_iff_integrableOn_Ioi.mpr
      (integrableOn_Ioi_deriv_norm_ofReal_cpow zero_lt_one ?_)).locallyIntegrableOn
    exact neg_re _ ‚ñ∏ neg_nonpos.mpr  <| hr.trans hs.le
  ¬∑ refine (IsBigO.mul_atTop_rpow_natCast_of_isBigO_rpow _ _ _ ?_ hO h‚ÇÇ).congr_right  (by simp)
    exact (norm_ofReal_cpow_eventually_eq_atTop _).isBigO.natCast_atTop
  ¬∑ refine h‚ÇÑ.isBigO.of_const_mul_right.mul_atTop_rpow_of_isBigO_rpow _ r _ ?_ le_rfl
    exact (hO.comp_tendsto tendsto_nat_floor_atTop).trans <|
      isEquivalent_nat_floor.isBigO.rpow hr (eventually_ge_atTop 0)
  ¬∑ rwa [integrableAtFilter_rpow_atTop_iff, neg_add_lt_iff_lt_add, add_neg_cancel_right]

/-- If the partial sums `‚àë k ‚àà Icc 1 n, ‚Äñf k‚Äñ` are `O(n ^ r)` for some real `0 ‚â§ r`, then the
L-series `LSeries f` converges at `s : ‚ÑÇ` for all `s` such that `r < s.re`. -/
theorem LSeriesSummable_of_sum_norm_bigO
    (hO : (fun n ‚Ü¶ ‚àë k ‚àà Icc 1 n, ‚Äñf k‚Äñ) =O[atTop] fun n ‚Ü¶ (n : ‚Ñù) ^ r)
    (hr : 0 ‚â§ r) (hs : r < s.re) :
    LSeriesSummable f s := by
  have h‚ÇÅ : (fun n ‚Ü¶ if n = 0 then 0 else f n) =·∂†[atTop] f := by
    filter_upwards [eventually_ne_atTop 0] with n hn using by simp_rw [if_neg hn]
  refine (LSeriesSummable_of_sum_norm_bigO_aux (if_pos rfl) ?_ hr hs).congr' _ h‚ÇÅ
  refine hO.congr' (Eventually.of_forall fun _ ‚Ü¶ Finset.sum_congr rfl fun _ h ‚Ü¶ ?_) EventuallyEq.rfl
  rw [if_neg (zero_lt_one.trans_le (mem_Icc.mp h).1).ne']

/-- If `f` takes nonnegative real values and the partial sums `‚àë k ‚àà Icc 1 n, f k` are `O(n ^ r)`
for some real `0 ‚â§ r`, then the L-series `LSeries f` converges at `s : ‚ÑÇ` for all `s`
such that `r < s.re`. -/
theorem LSeriesSummable_of_sum_norm_bigO_and_nonneg
    {f : ‚Ñï ‚Üí ‚Ñù} (hO : (fun n ‚Ü¶ ‚àë k ‚àà Icc 1 n, f k) =O[atTop] fun n ‚Ü¶ (n : ‚Ñù) ^ r)
    (hf : ‚àÄ n, 0 ‚â§ f n) (hr : 0 ‚â§ r) (hs : r < s.re) :
    LSeriesSummable (fun n ‚Ü¶ f n) s :=
  LSeriesSummable_of_sum_norm_bigO (by simpa [_root_.abs_of_nonneg (hf _)]) hr hs

end summable

section integralrepresentation

private theorem LSeries_eq_mul_integral_aux {f : ‚Ñï ‚Üí ‚ÑÇ} (hf : f 0 = 0) {r : ‚Ñù} (hr : 0 ‚â§ r) {s : ‚ÑÇ}
    (hs : r < s.re) (hS : LSeriesSummable f s)
    (hO : (fun n ‚Ü¶ ‚àë k ‚àà Icc 1 n, f k) =O[atTop] fun n ‚Ü¶ (n : ‚Ñù) ^ r) :
    LSeries f s = s * ‚à´ t in Set.Ioi (1 : ‚Ñù), (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * t ^ (- (s + 1)) := by
  have h‚ÇÅ : (-s - 1).re + r < -1 := by
    rwa [sub_re, one_re, neg_re, neg_sub_left, neg_add_lt_iff_lt_add, add_neg_cancel_comm]
  have h‚ÇÇ : s ‚â† 0 := ne_zero_of_re_pos (hr.trans_lt hs)
  have h‚ÇÉ (t : ‚Ñù) (ht : t ‚àà Set.Ici 1) : DifferentiableAt ‚Ñù (fun x : ‚Ñù ‚Ü¶ (x : ‚ÑÇ) ^ (-s)) t :=
    differentiableAt_id.ofReal_cpow_const (zero_lt_one.trans_le ht).ne' (neg_ne_zero.mpr h‚ÇÇ)
  have h‚ÇÑ : ‚àÄ n, ‚àë k ‚àà Icc 0 n, f k = ‚àë k ‚àà Icc 1 n, f k := fun n ‚Ü¶ by
    rw [‚Üê Nat.Icc_insert_succ_left n.zero_le, sum_insert (by aesop), hf, zero_add, zero_add]
  simp_rw [‚Üê h‚ÇÑ] at hO
  rw [‚Üê integral_mul_left]
  refine tendsto_nhds_unique ((tendsto_add_atTop_iff_nat 1).mpr hS.hasSum.tendsto_sum_nat) ?_
  simp_rw [Nat.range_succ_eq_Icc_zero, LSeries.term_def‚ÇÄ hf, mul_comm (f _)]
  convert tendsto_sum_mul_atTop_nhds_one_sub_integral‚ÇÄ (f := fun x ‚Ü¶ (x : ‚ÑÇ) ^ (-s)) (l := 0)
    ?_ hf h‚ÇÉ ?_ ?_ ?_ (integrableAtFilter_rpow_atTop_iff.mpr h‚ÇÅ)
  ¬∑ rw [zero_sub, ‚Üê integral_neg]
    refine setIntegral_congr_fun measurableSet_Ioi fun t ht ‚Ü¶ ?_
    rw [deriv_ofReal_cpow_const (zero_lt_one.trans ht).ne', h‚ÇÑ]
    ¬∑ ring_nf
    ¬∑ exact neg_ne_zero.mpr <| ne_zero_of_re_pos (hr.trans_lt hs)
  ¬∑ refine (integrableOn_Ici_iff_integrableOn_Ioi.mpr <|
      integrableOn_Ioi_deriv_ofReal_cpow zero_lt_one
        (by simpa using hr.trans_lt hs)).locallyIntegrableOn
  ¬∑ have hlim : Tendsto (fun n : ‚Ñï ‚Ü¶ (n : ‚Ñù) ^ (-(s.re - r))) atTop (ùìù 0) :=
      (tendsto_rpow_neg_atTop (by rwa [sub_pos])).comp tendsto_natCast_atTop_atTop
    refine (IsBigO.mul_atTop_rpow_natCast_of_isBigO_rpow (-s.re) _ _ ?_ hO ?_).trans_tendsto hlim
    ¬∑ exact isBigO_norm_left.mp <| (norm_ofReal_cpow_eventually_eq_atTop _).isBigO.natCast_atTop
    ¬∑ linarith
  ¬∑ refine .mul_atTop_rpow_of_isBigO_rpow (-(s + 1).re) r _ ?_ ?_ (by rw [‚Üê neg_re, neg_add'])
    ¬∑ simpa [- neg_add_rev, neg_add'] using isBigO_deriv_ofReal_cpow_const_atTop _
    ¬∑ exact (hO.comp_tendsto tendsto_nat_floor_atTop).trans <|
        isEquivalent_nat_floor.isBigO.rpow hr (eventually_ge_atTop 0)

/-- If the partial sums `‚àë k ‚àà Icc 1 n, f k` are `O(n ^ r)` for some real `0 ‚â§ r` and the
L-series `LSeries f` converges at `s : ‚ÑÇ` with `r < s.re`, then
`LSeries f s = s * ‚à´ t in Set.Ioi 1, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * t ^ (-(s + 1))`. -/
theorem LSeries_eq_mul_integral (f : ‚Ñï ‚Üí ‚ÑÇ) {r : ‚Ñù} (hr : 0 ‚â§ r) {s : ‚ÑÇ} (hs : r < s.re)
    (hS : LSeriesSummable f s)
    (hO : (fun n ‚Ü¶ ‚àë k ‚àà Icc 1 n, f k) =O[atTop] fun n ‚Ü¶ (n : ‚Ñù) ^ r) :
    LSeries f s = s * ‚à´ t in Set.Ioi (1 : ‚Ñù), (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * t ^ (-(s + 1)) := by
  rw [‚Üê LSeriesSummable_congr' s (f := fun n ‚Ü¶ if n = 0 then 0 else f n)
    (by filter_upwards [eventually_ne_atTop 0] with n h using if_neg h)] at hS
  have (n) : ‚àë k ‚àà Icc 1 n, (if k = 0 then 0 else f k) = ‚àë k ‚àà Icc 1 n, f k :=
    Finset.sum_congr rfl fun k hk ‚Ü¶ by rw [if_neg (zero_lt_one.trans_le (mem_Icc.mp hk).1).ne']
  rw [‚Üê LSeries_congr _ (fun _ ‚Ü¶ if_neg _), LSeries_eq_mul_integral_aux (if_pos rfl) hr hs hS] <;>
  simp_all

/-- A version of `LSeries_eq_mul_integral` where we use the stronger condition that the partial sums
`‚àë k ‚àà Icc 1 n, ‚Äñf k‚Äñ` are `O(n ^ r)` to deduce the integral representation. -/
theorem LSeries_eq_mul_integral' (f : ‚Ñï ‚Üí ‚ÑÇ) {r : ‚Ñù} (hr : 0 ‚â§ r) {s : ‚ÑÇ} (hs : r < s.re)
    (hO : (fun n ‚Ü¶ ‚àë k ‚àà Icc 1 n, ‚Äñf k‚Äñ) =O[atTop] fun n ‚Ü¶ (n : ‚Ñù) ^ r) :
    LSeries f s = s * ‚à´ t in Set.Ioi (1 : ‚Ñù), (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * t ^ (-(s + 1)) :=
  LSeries_eq_mul_integral _ hr hs (LSeriesSummable_of_sum_norm_bigO hO hr hs) <|
    (isBigO_of_le _ fun _ ‚Ü¶ (norm_sum_le _ _).trans <| Real.le_norm_self _).trans hO

/-- If `f` takes nonnegative real values and the partial sums `‚àë k ‚àà Icc 1 n, f k` are `O(n ^ r)`
for some real `0 ‚â§ r`, then for `s : ‚ÑÇ` with `r < s.re`, we have
`LSeries f s = s * ‚à´ t in Set.Ioi 1, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * t ^ (-(s + 1))`. -/
theorem LSeries_eq_mul_integral_of_nonneg (f : ‚Ñï ‚Üí ‚Ñù) {r : ‚Ñù} (hr : 0 ‚â§ r) {s : ‚ÑÇ} (hs : r < s.re)
    (hO : (fun n ‚Ü¶ ‚àë k ‚àà Icc 1 n, f k) =O[atTop] fun n ‚Ü¶ (n : ‚Ñù) ^ r) (hf : ‚àÄ n, 0 ‚â§ f n) :
    LSeries (fun n ‚Ü¶ f n) s =
      s * ‚à´ t in Set.Ioi (1 : ‚Ñù), (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, (f k : ‚ÑÇ)) * t ^ (-(s + 1)) :=
  LSeries_eq_mul_integral' _ hr hs <| hO.congr_left fun _ ‚Ü¶ by simp [_root_.abs_of_nonneg (hf _)]

end integralrepresentation

noncomputable section residue

variable {f : ‚Ñï ‚Üí ‚ÑÇ}

section lemmas

-- Miscellaneous results

-- inline
-- private theorem norm_mul_id_mul_norm_cpow_succ {Œµ t : ‚Ñù} {c : ‚ÑÇ} (hŒµ : 0 ‚â§ Œµ) (ht : t ‚â† 0) :
--     ‚ÄñŒµ * t‚Äñ * ‚Äñ(t : ‚ÑÇ) ^ (- (c + 1))‚Äñ = Œµ * ‚Äñ(t : ‚ÑÇ) ^ (- c)‚Äñ := by
--   replace ht := ofReal_ne_zero.mpr ht
--   rw [‚Üê norm_real, ‚Üê  norm_mul, ofReal_mul, mul_assoc, norm_mul, norm_real, Real.norm_of_nonneg hŒµ,
--     neg_add', cpow_sub _ _ ht, cpow_one, mul_div_cancel‚ÇÄ _ ht]

-- Move
theorem Complex.abs_ofReal_cpow_le_abs_ofReal_cpow {t : ‚Ñù} (ht : 1 ‚â§ t) {c d : ‚ÑÇ} (h : c.re ‚â§ d.re) :
    abs ((t : ‚ÑÇ) ^ c) ‚â§ abs ((t : ‚ÑÇ) ^ d) := by
  simp_rw [abs_cpow_eq_rpow_re_of_pos (zero_lt_one.trans_le ht)]
  refine Real.rpow_le_rpow_of_exponent_le ht h

-- keep (generalize)
-- private theorem norm_cpow_le_norm_cpow {t : ‚Ñù} {c d : ‚ÑÇ} (ht : 1 ‚â§ t) (hc : d.re ‚â§ c.re) :
--    ‚Äñ(t : ‚ÑÇ) ^ (-c)‚Äñ ‚â§ ‚Äñ(t : ‚ÑÇ) ^ (-d)‚Äñ := by
--  sorry
--  simp_rw [eqOn_norm_cpow (zero_lt_one.trans_le ht)]
--  refine Real.rpow_le_rpow_of_exponent_le ht (neg_le_neg_iff.mpr hc)

-- keep
private theorem isBigO_of_tendsto_sum_div {ùïú : Type*} [RCLike ùïú] {f : ‚Ñï ‚Üí ùïú} {l : ùïú}
    (hlim : Tendsto (fun n : ‚Ñï ‚Ü¶ (‚àë k ‚àà Icc 1 n, f k) / n) atTop (ùìù l)) :
    (fun n : ‚Ñï ‚Ü¶ ‚àë k ‚àà Icc 1 n, f k) =O[atTop] fun n ‚Ü¶ (n : ‚Ñù) ^ (1 : ‚Ñù) := by
  simp_rw [Real.rpow_one]
  refine isBigO_norm_left.mp <| isBigO_of_div_tendsto_nhds ?_ ‚Äñl‚Äñ ?_
  ¬∑ filter_upwards [eventually_ne_atTop 0] with _ h using by simp [h]
  ¬∑ simpa only [Function.comp_def, norm_div, RCLike.norm_natCast] using (tendsto_norm.comp hlim)

-- Some more results about integrability

-- inline
private theorem intOn_norm_cpow {T : ‚Ñù} (hT : 0 < T) {c : ‚ÑÇ} (hc : 1 < c.re) :
    IntegrableOn (fun t : ‚Ñù ‚Ü¶ ‚Äñ(t : ‚ÑÇ) ^ (-c)‚Äñ) (Set.Ioi T) := sorry
--  ((integrableOn_Ioi_rpow_iff hT).mpr (by rwa [neg_lt_neg_iff])).congr_fun
--    (eqOn_norm_cpow.symm.mono (Set.Ioi_subset_Ioi hT.le)) measurableSet_Ioi

-- inline
private theorem intOn_norm_mul_id_mul_norm_cpow_succ {Œµ : ‚Ñù} {T : ‚Ñù} {c : ‚ÑÇ} (hŒµ : 0 ‚â§ Œµ)
    (hT : 0 < T) (hc : 1 < c.re) :
    IntegrableOn (fun t : ‚Ñù ‚Ü¶ ‚ÄñŒµ * t‚Äñ * ‚Äñ(t : ‚ÑÇ) ^ (-(c + 1))‚Äñ) (Set.Ioi T) := by
  refine IntegrableOn.congr_fun (f := fun t : ‚Ñù ‚Ü¶ Œµ * ‚Äñ(t : ‚ÑÇ) ^ (-c)‚Äñ) ?_ ?_ measurableSet_Ioi
  ¬∑ exact (intOn_norm_cpow hT hc).const_mul _
  ¬∑ sorry
    -- exact fun t ht ‚Ü¶ (norm_mul_id_mul_norm_cpow_succ hŒµ (hT.trans ht).ne').symm

private theorem locintOn_sum_mul_cpow {a : ‚Ñù} {c : ‚ÑÇ} (ha : 0 < a) (hc : 0 < c.re) :
    LocallyIntegrableOn (fun t ‚Ü¶ (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * ‚Üët ^ (-(c + 1))) (Set.Ici a) := by
  sorry
--  simp_rw [mul_comm]
--  refine locallyIntegrableOn_mul_sum_Icc _ ha.le <|
--    integrableOn_Ici_iff_integrableOn_Ioi.mpr (intO_cpow ha ?_)
--  rwa [add_re, one_re, lt_add_iff_pos_left]

-- keep
private theorem intOn_sum_mul_cpow {f : ‚Ñï ‚Üí ‚ÑÇ} {a : ‚Ñù} {c : ‚ÑÇ} (ha : 0 < a) (hc : 1 < c.re)
    (hf : (fun n : ‚Ñï ‚Ü¶ ‚àë k ‚àà Icc 1 n, f k) =O[atTop] fun t ‚Ü¶ (t : ‚Ñù) ^ (1 : ‚Ñù)) :
    IntegrableOn (fun t : ‚Ñù ‚Ü¶ (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (-(c + 1))) (Set.Ici a) := by
  sorry
--  refine (locintOn_sum_mul_cpow ha (zero_lt_one.trans hc)).integrableOn_of_isBigO_atTop ?_ <|
--    integrableAtFilter_rpow_atTop (by rwa [neg_lt_neg_iff])
--  refine mul_atTop_of_le 1 (-(c + 1).re) _ (floor_atTop zero_le_one hf) ?_ ?_
--  ¬∑ exact isBigO_norm_left.mp <| norm_cpow_atTop
--  ¬∑ rw [add_re, one_re, neg_add_rev, add_neg_cancel_left]

-- not clear
private theorem intOn_Icc_cpow {a b : ‚Ñù} {c : ‚ÑÇ} (ha : 0 < a) :
    IntegrableOn (fun t : ‚Ñù ‚Ü¶ (t : ‚ÑÇ) ^ (-c)) (Set.Icc a b) := by
  refine ContinuousOn.integrableOn_compact isCompact_Icc ?_
  exact continuous_ofReal.continuousOn.cpow_const
    (fun x hx ‚Ü¶ ofReal_mem_slitPlane.mpr (ha.trans_le hx.1))

-- inline
private theorem intOn_Icc_sum_mul_cpow {a b : ‚Ñù} {c : ‚ÑÇ} (ha : 0 < a) :
    IntegrableOn (fun t : ‚Ñù ‚Ü¶ (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (-c)) (Set.Icc a b) := by
  simp_rw [mul_comm]
  exact integrableOn_mul_sum_Icc _ ha.le (intOn_Icc_cpow ha)

-- Some results about integrals

-- inline
private theorem int_Ioi_eq {a b : ‚Ñù} (h : a ‚â§ b) {g : ‚Ñù ‚Üí ‚ÑÇ} (hg : IntegrableOn g (Set.Ioi a)) :
    ‚à´ (t : ‚Ñù) in Set.Ioi a, g t =
      (‚à´ (t : ‚Ñù) in Set.Ioc a b, g t) + ‚à´ (t : ‚Ñù) in Set.Ioi b, g t := by
  rw [‚Üê Set.Ioc_union_Ioi_eq_Ioi h, setIntegral_union (Set.Ioc_disjoint_Ioi le_rfl)
    measurableSet_Ioi (hg.mono_set Set.Ioc_subset_Ioi_self) (hg.mono_set (Set.Ioi_subset_Ioi h))]

-- -- inline
-- private theorem sub_mul_int_rpow {s : ‚Ñù} (hs : 1 < s) :
--     (s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi 1, t ^ (-s) = 1 := by
--   rw [integral_Ioi_rpow_of_lt (by rwa [neg_lt_neg_iff]) zero_lt_one, Real.one_rpow, neg_div,
--     ‚Üê one_div_neg_eq_neg_one_div, neg_add', neg_neg, mul_one_div, div_self (sub_ne_zero.mpr hs.ne')]

-- inline
-- private theorem sub_mul_int_cpow {s : ‚ÑÇ} (hs : 1 < s.re) :
--     (s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi 1, (t : ‚ÑÇ) ^ (-s : ‚ÑÇ) = 1 := by
--   have : 1 - s ‚â† 0 := by
--     contrapose! hs
--     rw [‚Üê sub_eq_zero.mp hs, one_re]
--   rw [integral_Ioi_cpow_of_lt (by rwa [neg_re, neg_lt_neg_iff]) zero_lt_one, ofReal_one, one_cpow,
--     ‚Üê mul_div_assoc, mul_neg_one, neg_add_eq_sub, neg_sub, div_self this]

-- keep
private theorem norm_mul_int_cpow_le {T : ‚Ñù} {c l : ‚ÑÇ} (hc : 1 ‚â§ c.re):
    ‚Äñl * ‚à´ (t : ‚Ñù) in Set.Ioc 1 T, (t : ‚ÑÇ) ^ (-c)‚Äñ ‚â§
      ‚Äñl‚Äñ * ‚à´ (t : ‚Ñù) in Set.Ioc 1 T, ‚Äñ(t : ‚ÑÇ) ^ (-1 : ‚ÑÇ)‚Äñ := by
  by_cases hT : 1 < T
  ¬∑ rw [norm_mul]
    refine mul_le_mul_of_nonneg_left (le_trans (norm_integral_le_integral_norm _)
      (setIntegral_mono_on ?_ ?_ measurableSet_Ioc fun t ht ‚Ü¶ ?_)) (norm_nonneg _)
    ¬∑ exact (integrableOn_Icc_iff_integrableOn_Ioc.mp <| intOn_Icc_cpow zero_lt_one).norm
    ¬∑ exact (integrableOn_Icc_iff_integrableOn_Ioc.mp <| intOn_Icc_cpow zero_lt_one).norm
    ¬∑ refine abs_ofReal_cpow_le_abs_ofReal_cpow ht.1.le ?_
      rwa [neg_re, neg_re, one_re, neg_le_neg_iff]
  ¬∑ rw [Set.Ioc_eq_empty hT, setIntegral_empty, setIntegral_empty, mul_zero, norm_zero, mul_zero]

-- keep
private theorem norm_int_sum_mul_cpow_le {T : ‚Ñù} {c : ‚ÑÇ} (hc : 1 ‚â§ c.re) :
    ‚Äñ‚à´ (t : ‚Ñù) in Set.Ioc 1 T, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (-(c + 1))‚Äñ ‚â§
      ‚à´ (t : ‚Ñù) in Set.Ioc 1 T, ‚Äñ(‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (-2 : ‚ÑÇ)‚Äñ := by
  by_cases hT : 1 < T
  ¬∑ refine le_trans (norm_integral_le_integral_norm _) <|
      setIntegral_mono_on ?_ ?_ measurableSet_Ioc fun t ht ‚Ü¶ ?_
    ¬∑ exact (integrableOn_Icc_iff_integrableOn_Ioc.mp <| intOn_Icc_sum_mul_cpow zero_lt_one).norm
    ¬∑ exact (integrableOn_Icc_iff_integrableOn_Ioc.mp <| intOn_Icc_sum_mul_cpow zero_lt_one).norm
    ¬∑ rw [norm_mul, norm_mul]
      refine mul_le_mul_of_nonneg_left (abs_ofReal_cpow_le_abs_ofReal_cpow ht.1.le ?_)
        (norm_nonneg _)
      rw [neg_re, neg_re, add_re, one_re, re_ofNat]
      linarith
  ¬∑ rw [Set.Ioc_eq_empty hT, setIntegral_empty, setIntegral_empty, norm_zero]



end lemmas

section newlemmas

theorem toto {s : ‚Ñù} (S : ‚Ñù ‚Üí ‚ÑÇ) :
    IntegrableOn (fun t ‚Ü¶ ‚ÄñS t‚Äñ * (t ^ (-s - 1))) (Set.Ioi 1) := by

  sorry

end newlemmas

section proof

variable {l : ‚ÑÇ} (hlim : Tendsto (fun n : ‚Ñï ‚Ü¶ (‚àë k ‚àà Icc 1 n, f k) / n) atTop (ùìù l))

include hlim in
private theorem aux‚ÇÅ {Œµ : ‚Ñù} (hŒµ : Œµ > 0) :
    ‚àÄ·∂† t : ‚Ñù in atTop, ‚Äñ(‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) - l * t‚Äñ < Œµ * t := by
  have h_lim' : Tendsto (fun t : ‚Ñù ‚Ü¶ (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k : ‚ÑÇ) / t) atTop (ùìù l) := by
    refine (mul_one l ‚ñ∏ ofReal_one ‚ñ∏ ((hlim.comp tendsto_nat_floor_atTop).mul <|
      tendsto_ofReal_iff.mpr <| tendsto_nat_floor_div_atTop)).congr' ?_
    filter_upwards [eventually_ge_atTop 1] with t ht
    rw [Function.comp_def, ofReal_div, ofReal_natCast, div_mul_div_cancel‚ÇÄ (by
      rwa [Nat.cast_ne_zero, ne_eq, Nat.floor_eq_zero, not_lt])]
  rw [Metric.tendsto_nhds] at h_lim'
  filter_upwards [eventually_gt_atTop 0, h_lim' Œµ hŒµ] with t ht‚ÇÅ ht‚ÇÇ
  rwa [dist_eq_norm, div_sub' _ _ _ (ne_zero_of_re_pos ht‚ÇÅ), norm_div, norm_real,
    Real.norm_of_nonneg ht‚ÇÅ.le, mul_comm, div_lt_iff‚ÇÄ ht‚ÇÅ] at ht‚ÇÇ

private theorem aux‚ÇÇ {s T Œµ : ‚Ñù} {S : ‚Ñù ‚Üí ‚ÑÇ} (hS : Measurable S) (hŒµ : 0 < Œµ) (hs : 1 < s)
    (hT‚ÇÄ : 1 ‚â§ T) (hT : ‚àÄ t > T, ‚ÄñS t - l * t‚Äñ ‚â§ Œµ * t) :
    (s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi T, ‚ÄñS t - l * t‚Äñ * t ^ (-s - 1) ‚â§ Œµ := by
  have h {t : ‚Ñù} : t ^ (-s) = t * t ^ (-s - 1) := sorry
  calc
    _ ‚â§ (s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi T, Œµ * t ^ (-s) := ?_
    _ ‚â§ Œµ * ((s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi 1, t ^ (-s)) := ?_
    _ = Œµ := ?_
  ¬∑ refine mul_le_mul_of_nonneg_left (setIntegral_mono_on ?_ ?_ measurableSet_Ioi fun t ht ‚Ü¶ ?_) ?_
    ¬∑ refine (toto _).mono_set ?_
      sorry -- Integrable (fun t ‚Ü¶ ‚ÄñS t - l * ‚Üët‚Äñ * t ^ (-s - 1)) (volume.restrict (Set.Ioi T))
    ¬∑ exact (integrableOn_Ioi_rpow_of_lt (neg_lt_neg_iff.mpr hs)
        (zero_lt_one.trans_le hT‚ÇÄ)).const_mul  _
    ¬∑ rw [h, ‚Üê mul_assoc]
      refine mul_le_mul_of_nonneg_right ?_ ?_
      ¬∑ exact hT t ht
      ¬∑ sorry
    ¬∑ sorry
  ¬∑ rw [integral_mul_left, ‚Üê mul_assoc, ‚Üê mul_assoc, mul_comm Œµ]
    gcongr
    ¬∑ sorry
    ¬∑ refine setIntegral_mono_set ?_ ?_ ?_
      ¬∑ exact integrableOn_Ioi_rpow_of_lt (neg_lt_neg_iff.mpr hs) zero_lt_one
      ¬∑ sorry
      ¬∑ sorry
  ¬∑ sorry

variable (hfS : ‚àÄ s : ‚Ñù, 1 < s ‚Üí LSeriesSummable f s)

include hlim hfS in
private theorem aux‚ÇÉ {Œµ : ‚Ñù} (hŒµ : Œµ > 0) :
    ‚àÉ C ‚â• 0, ‚àÄ s : ‚Ñù, 1 < s ‚Üí ‚Äñ(s - 1) * LSeries f s - s * l‚Äñ ‚â§ (s - 1) * s * C + s * Œµ := by
  obtain ‚ü®T, hT‚ÇÅ, hT‚ü© :=
    (eventually_forall_ge_atTop.mpr (aux‚ÇÅ hlim hŒµ)).frequently.forall_exists_of_atTop 1
  set S : ‚Ñù ‚Üí ‚ÑÇ := fun t ‚Ü¶ ‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k
  let C := ‚à´ t in Set.Ioc 1 T, ‚ÄñS t - l * t‚Äñ * t ^ (-1 - 1 : ‚Ñù)
  refine ‚ü®C, sorry, fun s hs ‚Ü¶ ?_‚ü©
  have h‚ÇÇ : (s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi 1, (t : ‚ÑÇ) ^ (-s : ‚ÑÇ) = 1 := sorry

  let Cs := ‚à´ t in Set.Ioc 1 T, ‚ÄñS t - l * t‚Äñ * t ^ (-s - 1)
  have : Cs ‚â§ C := by
    refine setIntegral_mono_on ?_ ?_ measurableSet_Ioc fun t ht ‚Ü¶ ?_
    ¬∑ refine (toto _).mono_set ?_
      sorry -- IntegrableOn (fun t ‚Ü¶ ‚ÄñS t - l * ‚Üët‚Äñ * t ^ (-s - 1)) (Set.Ioc 1 T) volume
    ¬∑ refine (toto _).mono_set ?_
      sorry -- IntegrableOn (fun t ‚Ü¶ ‚ÄñS t - l * ‚Üët‚Äñ * t ^ (-1 - 1)) (Set.Ioc 1 T) volume
    ¬∑ gcongr
      exact ht.1.le
  calc
    _ = ‚Äñ(s - 1) * s *
          ((‚à´ (t : ‚Ñù) in Set.Ioi 1, S t * (t : ‚ÑÇ) ^ (-s - 1 : ‚ÑÇ))
            - ‚à´ (t : ‚Ñù) in Set.Ioi 1, l * (t : ‚ÑÇ) ^ ((-s : ‚ÑÇ)))‚Äñ := ?_
    _ = ‚Äñ(s - 1) * s *
          ‚à´ (t : ‚Ñù) in Set.Ioi 1, (S t * (t : ‚ÑÇ) ^ (-s - 1 : ‚ÑÇ) - l * t ^ (-s : ‚ÑÇ))‚Äñ := ?_
    _ = ‚Äñ(s - 1) * s * ‚à´ (t : ‚Ñù) in Set.Ioi 1, (S t - l * t) * (t : ‚ÑÇ) ^ (-s - 1 : ‚ÑÇ)‚Äñ := ?_
    _ ‚â§ (s - 1) * s * ‚à´ (t : ‚Ñù) in Set.Ioi 1, ‚ÄñS t - l * t‚Äñ * t ^ (-s - 1) := ?_
    _ = (s - 1) * s * (Cs + ‚à´ (t : ‚Ñù) in Set.Ioi T, ‚ÄñS t - l * t‚Äñ * t ^ (-s - 1)) := ?_
    _ ‚â§ (s - 1) * s * C +
          s * ((s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi T, ‚ÄñS t - l * t‚Äñ * t ^ (-s - 1)) := ?_
    _ ‚â§ (s - 1) * s * C + s * Œµ := ?_
  ¬∑ sorry
  ¬∑ rw [integral_sub]
    ¬∑ sorry -- Integrable (fun t ‚Ü¶ S t * ‚Üët ^ (-‚Üës - 1))) (volume.restrict (Set.Ioi 1))
    ¬∑ exact (integrableOn_Ioi_cpow_of_lt
        (by rwa [neg_re, ofReal_re, neg_lt_neg_iff]) zero_lt_one).const_mul  _
  ¬∑ congr 2
    refine setIntegral_congr_fun ?_ ?_
    ¬∑ sorry
    ¬∑ sorry
  ¬∑ rw [norm_mul]
    sorry
  ¬∑ rw [‚Üê Set.Ioc_union_Ioi_eq_Ioi hT‚ÇÅ, setIntegral_union (Set.Ioc_disjoint_Ioi le_rfl)
      measurableSet_Ioi]
    ¬∑ refine (toto _).mono_set ?_
      sorry -- IntegrableOn (fun t ‚Ü¶ ‚ÄñS t - l * ‚Üët‚Äñ * t ^ (-s - 1))) (Set.Ioc 1 T) volume
    ¬∑ refine (toto _).mono_set ?_
      sorry -- IntegrableOn (fun t ‚Ü¶ ‚ÄñS t - l * ‚Üët‚Äñ * t ^ (-s - 1))) (Set.Ioi T) volume
  ¬∑ rw [mul_add, ‚Üê mul_assoc, mul_comm s]
    refine add_le_add_right (mul_le_mul_of_nonneg_left this ?_) _
    sorry -- 0 ‚â§ (s - 1) * s
  ¬∑ gcongr
    refine aux‚ÇÇ ?_ hŒµ hs hT‚ÇÅ ?_
    ¬∑ sorry
    ¬∑ intro t ht
      exact (hT t ht.le).le



-- private theorem aux‚ÇÇ {s T Œµ : ‚Ñù} {g : ‚Ñù ‚Üí ‚ÑÇ} (hg : Measurable g) (hŒµ : 0 < Œµ) (hs : 1 < s)
--     (hT‚ÇÄ : 1 ‚â§ T) (hT : ‚àÄ t > T, ‚Äñg t - l * t‚Äñ ‚â§ Œµ * t) :
--     (s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi T, ‚Äñg t * ‚Üët ^ (-((s : ‚ÑÇ) + 1)) - l * t ^ (-(s : ‚ÑÇ))‚Äñ ‚â§ Œµ := by
--   have h‚ÇÅ {t : ‚Ñù} {s : ‚ÑÇ} : t ‚â† 0 ‚Üí t * (t : ‚ÑÇ) ^ (-(s + 1)) = t ^ (-s) := fun ht ‚Ü¶ by
--     replace ht := ofReal_ne_zero.mpr ht
--     rw [neg_add', cpow_sub _ _ ht, cpow_one, mul_div_cancel‚ÇÄ _ ht]
--   have h‚ÇÇ {a : ‚Ñù} (ha : 0 < a) :
--       IntegrableOn (fun t : ‚Ñù ‚Ü¶ ‚ÄñŒµ * t‚Äñ * ‚Äñ(t : ‚ÑÇ) ^ (-((s : ‚ÑÇ) + 1))‚Äñ) (Set.Ioi a) := by
--     refine IntegrableOn.congr_fun (f := fun t : ‚Ñù ‚Ü¶ ‚ÄñŒµ‚Äñ * ‚Äñ(t : ‚ÑÇ) ^ (-s : ‚ÑÇ)‚Äñ) ?_ (fun t ht ‚Ü¶ ?_)
--       measurableSet_Ioi
--     ¬∑ exact (integrableOn_Ioi_norm_cpow_of_lt
--         (by rwa [neg_re, ofReal_re, neg_lt_neg_iff]) ha).const_mul _
--     ¬∑ rw [norm_mul, ‚Üê norm_real t, mul_assoc, ‚Üê norm_mul, h‚ÇÅ (ha.trans ht).ne']
--   have h‚ÇÉ : IntegrableOn (fun t ‚Ü¶ ‚Äñg t - l * t‚Äñ * ‚Äñ(t : ‚ÑÇ) ^ (-((s : ‚ÑÇ) + 1))‚Äñ) (Set.Ioi T) := by
--     refine Integrable.mono (h‚ÇÇ (zero_lt_one.trans_le hT‚ÇÄ)) ?_ ?_
--     ¬∑ exact Measurable.aestronglyMeasurable (by fun_prop)
--     ¬∑ rw [ae_restrict_iff' measurableSet_Ioi]
--       filter_upwards with t ht
--       rw [norm_mul, norm_mul, norm_norm, norm_norm, norm_norm]
--       sorry
--       -- exact mul_le_mul_of_nonneg_right (hT t ht) (norm_nonneg _)
--   calc
--     _ = (s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi T, ‚Äñ(g t - l * t) * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ)‚Äñ := ?_
-- --    _ ‚â§ (s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi T, ‚Äñ(g t - l * t)‚Äñ * ‚Äñ(t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ)‚Äñ := ?_
--     _ ‚â§ (s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi T, Œµ * t * ‚Äñ(t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ)‚Äñ := ?_
--     _ = (s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi T, Œµ * ‚Äñ(t : ‚ÑÇ) ^ (-(s : ‚ÑÇ))‚Äñ := ?_
--     _ ‚â§ (s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi 1, Œµ * ‚Äñ(t : ‚ÑÇ) ^ (-(s : ‚ÑÇ))‚Äñ := ?_
--     _ = Œµ * ((s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi 1, t ^ (-s)) := ?_
--     _ = Œµ := ?_
--   ¬∑ congr 1
--     refine setIntegral_congr_fun measurableSet_Ioi fun t ht ‚Ü¶ ?_
--     rw [sub_mul, mul_assoc, h‚ÇÅ (zero_lt_one.trans (hT‚ÇÄ.trans_lt ht)).ne']
--   ¬∑ simp_rw [norm_mul]
--     refine mul_le_mul_of_nonneg_left ?_ (sub_pos_of_lt hs).le
--     refine setIntegral_mono_on ?_ ?_ measurableSet_Ioi ?_
--     ¬∑ sorry -- IntegrableOn (fun t ‚Ü¶ Œµ * t * ‚Äñ‚Üët ^ (-(‚Üës + 1))‚Äñ) (Set.Ioi T) volume
--     ¬∑ sorry -- IntegrableOn (fun t ‚Ü¶ Œµ * t * ‚Äñ‚Üët ^ (-(‚Üës + 1))‚Äñ) (Set.Ioi T) volum
--     ¬∑ intro t ht
--       refine mul_le_mul_of_nonneg_right ?_ (norm_nonneg _)
--       exact hT t ht
--   ¬∑ refine congr_arg (_ * ¬∑) (setIntegral_congr_fun measurableSet_Ioi fun t ht ‚Ü¶ ?_)
--     replace ht : 0 < t := (zero_le_one.trans hT‚ÇÄ).trans_lt ht
--     rw [‚Üê h‚ÇÅ (s := s) ht.ne', norm_mul, norm_real, Real.norm_of_nonneg ht.le, mul_assoc]
--   ¬∑ refine mul_le_mul_of_nonneg_left ?_ (sub_pos_of_lt hs).le
--     refine setIntegral_mono_set ?_ ?_ ?_
--     ¬∑ sorry -- IntegrableOn (fun t ‚Ü¶ Œµ * ‚Äñ‚Üët ^ (-‚Üës)‚Äñ) (Set.Ioi 1) volume
--     ¬∑ filter_upwards with _ using mul_nonneg hŒµ.le (norm_nonneg _)
--     ¬∑ exact HasSubset.Subset.eventuallyLE <| Set.Ioi_subset_Ioi hT‚ÇÄ
--   ¬∑ rw [integral_mul_left, ‚Üê mul_assoc, ‚Üê mul_assoc, mul_comm Œµ]
--     refine congr_arg (_ * ¬∑) (setIntegral_congr_fun measurableSet_Ioi fun t ht ‚Ü¶ ?_)
--     replace ht : 0 ‚â§ t := zero_le_one.trans ht.le
--     rw [‚Üê ofReal_neg, ‚Üê ofReal_cpow ht, norm_real, Real.norm_of_nonneg (Real.rpow_nonneg ht _)]
--   ¬∑ rw [integral_Ioi_rpow_of_lt (by rwa [neg_lt_neg_iff]) zero_lt_one, Real.one_rpow, show -s + 1 =
--       -(s - 1) by ring, neg_div_neg_eq, mul_one_div, div_self (sub_pos_of_lt hs).ne', mul_one]

  --   exact mul_le_mul_of_nonneg_left (norm_integral_le_integral_norm _) (sub_pos_of_lt hs).le
  -- ¬∑ exact mul_le_mul_of_nonneg_left (setIntegral_mono_on h‚ÇÉ (h‚ÇÇ (zero_lt_one.trans_le hT‚ÇÄ))
  --     measurableSet_Ioi (fun t ht ‚Ü¶ mul_le_mul_of_nonneg_right (hT t ht) (norm_nonneg _)))
  --     (sub_pos_of_lt hs).le
  -- ¬∑ refine mul_le_mul_of_nonneg_left ?_ (sub_pos_of_lt hs).le
  --   ¬∑ refine setIntegral_mono_set (h‚ÇÇ zero_lt_one) ?_ ?_
  --     ¬∑ filter_upwards with _ using mul_nonneg (norm_nonneg _) (norm_nonneg _)
  --     ¬∑ exact HasSubset.Subset.eventuallyLE <| Set.Ioi_subset_Ioi hT‚ÇÄ
  -- ¬∑ refine congr_arg (_ * ¬∑) (setIntegral_congr_fun measurableSet_Ioi fun t ht ‚Ü¶ ?_)
  --   rw [norm_mul, Real.norm_of_nonneg hŒµ.le, ‚Üê norm_real, mul_assoc, ‚Üê norm_mul,
  --     h‚ÇÅ (zero_lt_one.trans ht).ne']
  -- ¬∑ rw [integral_mul_left, ‚Üê mul_assoc, mul_comm _ Œµ, ‚Üê mul_assoc]
  --   refine congr_arg (_ * ¬∑) (setIntegral_congr_fun measurableSet_Ioi fun t ht ‚Ü¶ ?_)
  --   have ht : 0 ‚â§ t := zero_le_one.trans ht.le
  --   rw [‚Üê ofReal_neg, ‚Üê ofReal_cpow ht, norm_real, Real.norm_of_nonneg (Real.rpow_nonneg ht _)]
  -- ¬∑ rw [integral_Ioi_rpow_of_lt (by rwa [neg_lt_neg_iff]) zero_lt_one, Real.one_rpow, show -s + 1 =
  --     -(s - 1) by ring, neg_div_neg_eq, mul_one_div, div_self (sub_pos_of_lt hs).ne', mul_one]













#exit






  sorry
  calc
    _ = ‚Äñ(s - 1) * s *
          ((‚à´ (t : ‚Ñù) in Set.Ioi 1, S t * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ))
            - ‚à´ (t : ‚Ñù) in Set.Ioi 1, l * (t : ‚ÑÇ) ^ (-(s : ‚ÑÇ)))‚Äñ := ?_
    _ = ‚Äñ(s - 1) * s *
        ‚à´ (t : ‚Ñù) in Set.Ioi 1, (S t * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ) - l * t ^ (-(s : ‚ÑÇ)))‚Äñ := ?_
    _ ‚â§ (s - 1) * s *
          ‚à´ (t : ‚Ñù) in Set.Ioi 1, ‚ÄñS t * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ) - l * t ^ (-(s : ‚ÑÇ))‚Äñ := ?_
    _ = (s - 1) * s * (Cs +
        ‚à´ (t : ‚Ñù) in Set.Ioi T, ‚ÄñS t * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ) - l * t ^ (-(s : ‚ÑÇ))‚Äñ) := ?_
    _ ‚â§ (s - 1) * s * ‚ÄñC‚Äñ + s * ((s - 1) *
          ‚à´ (t : ‚Ñù) in Set.Ioi T, ‚ÄñS t * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ) - l * t ^ (-(s : ‚ÑÇ))‚Äñ) := ?_
    _ ‚â§ (s - 1) * s * ‚ÄñC‚Äñ + s * Œµ := ?_
  ¬∑ rw [mul_sub, integral_mul_left, ‚Üê mul_assoc, mul_rotate _ _ l, mul_assoc, mul_assoc, h‚ÇÇ,
      mul_one, mul_comm _ l, LSeries_eq_mul_integral _ zero_le_one (by rwa [ofReal_re]) (hfS _ hs)]
    exact isBigO_of_tendsto_sum_div hlim
  ¬∑ rw [integral_sub]
    ¬∑
      sorry
      -- Integrable (fun t ‚Ü¶ S t * ‚Üët ^ (-(‚Üës + 1))) (volume.restrict (Set.Ioi 1))
    ¬∑ sorry
      -- Integrable (fun t ‚Ü¶ l * ‚Üët ^ (-‚Üës)) (volume.restrict (Set.Ioi 1))
  ¬∑ rw [norm_mul, show ((s : ‚ÑÇ) - 1) * s = ((s - 1) * s : ‚Ñù) by simp, norm_real,
      Real.norm_of_nonneg]
    ¬∑ refine mul_le_mul_of_nonneg_left ?_ ?_
      ¬∑ exact norm_integral_le_integral_norm _
      ¬∑ sorry -- 0 ‚â§ (s - 1) * s
    ¬∑ sorry -- 0 ‚â§ (s - 1) * s
  ¬∑ rw [‚Üê Set.Ioc_union_Ioi_eq_Ioi hT‚ÇÅ, setIntegral_union (Set.Ioc_disjoint_Ioi le_rfl)
      measurableSet_Ioi]
    ¬∑ sorry
      -- IntegrableOn (fun t ‚Ü¶ S t * ‚Üët ^ (-(‚Üës + 1)) - l * ‚Üët ^ (-‚Üës)) (Set.Ioc 1 T) volume
    ¬∑ sorry
      -- IntegrableOn (fun t ‚Ü¶ S t * ‚Üët ^ (-(‚Üës + 1)) - l * ‚Üët ^ (-‚Üës)) (Set.Ioi T) volume
  ¬∑ rw [‚Üê mul_assoc, mul_comm s, ‚Üê mul_add]
    gcongr

#exit
    ¬∑ sorry  -- 0 ‚â§ (s - 1) * s
    ¬∑ refine (norm_add_le _ _).trans ?_
      gcongr
      ¬∑ sorry -- ‚ÄñCs‚Äñ ‚â§ ‚ÄñC‚Äñ
      exact norm_integral_le_integral_norm _
  ¬∑ gcongr
    refine aux‚ÇÇ ?_ hŒµ hs hT‚ÇÅ ?_
    ¬∑ sorry -- Measurable S
    ¬∑ intro t ht
      exact (hT t ht.le).le

#exit

include hlim hfS in
private theorem aux‚ÇÉ {Œµ : ‚Ñù} (hŒµ : Œµ > 0) :
    ‚àÉ C ‚â• 0, ‚àÄ s : ‚Ñù, 1 < s ‚Üí ‚Äñ(s - 1) * LSeries f s - l * s‚Äñ ‚â§ (s - 1) * s * C + s * Œµ := by
  obtain ‚ü®T, hT‚ÇÅ, hT‚ü© :=
    (eventually_forall_ge_atTop.mpr (aux‚ÇÅ hlim hŒµ)).frequently.forall_exists_of_atTop 1
  set S : ‚Ñù ‚Üí ‚ÑÇ := fun t ‚Ü¶ ‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k
  let C‚ÇÅ := ‚à´ t in Set.Ioc 1 T, ‚ÄñS t * (t : ‚ÑÇ) ^ (-2 : ‚ÑÇ)‚Äñ
  let C‚ÇÇ := ‚Äñl‚Äñ * ‚à´ t in Set.Ioc 1 T, ‚Äñ(t : ‚ÑÇ) ^ (-1 : ‚ÑÇ)‚Äñ
  have h‚ÇÅ : 0 ‚â§ C‚ÇÅ + C‚ÇÇ := add_nonneg (integral_nonneg fun _ ‚Ü¶ norm_nonneg _) <|
      mul_nonneg (norm_nonneg _) (integral_nonneg fun _ ‚Ü¶ norm_nonneg _)
  refine ‚ü®C‚ÇÅ + C‚ÇÇ, h‚ÇÅ, fun s hs ‚Ü¶ ?_‚ü©
  let C‚ÇÅs := ‚à´ t in Set.Ioc 1 T, S t * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ)
  let C‚ÇÇs := l * ‚à´ t in Set.Ioc 1 T, (t : ‚ÑÇ) ^ (-s : ‚ÑÇ)
  let Cs := ‚à´ t in Set.Ioc 1 T, S t * (t : ‚ÑÇ) ^ (-(s + 1 : ‚ÑÇ)) - l * (t : ‚ÑÇ) ^ (-(s : ‚ÑÇ))
  let C := ‚à´ t in Set.Ioc 1 T, ‚ÄñS t * (t : ‚ÑÇ) ^ (-(1 + 1 : ‚ÑÇ))‚Äñ + ‚Äñl * (t : ‚ÑÇ) ^ (-(1 : ‚ÑÇ))‚Äñ

  have h‚ÇÇ : (s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi 1, (t : ‚ÑÇ) ^ (-s : ‚ÑÇ) = 1 := sorry
  have h‚ÇÉ {a b : ‚Ñù} (h : a ‚â§ b) {g : ‚Ñù ‚Üí ‚ÑÇ} (hg : IntegrableOn g (Set.Ioi a)) :
      ‚à´ (t : ‚Ñù) in Set.Ioi a, g t =
        (‚à´ (t : ‚Ñù) in Set.Ioc a b, g t) + ‚à´ (t : ‚Ñù) in Set.Ioi b, g t := by
    rw [‚Üê Set.Ioc_union_Ioi_eq_Ioi h, setIntegral_union (Set.Ioc_disjoint_Ioi le_rfl)
      measurableSet_Ioi (hg.mono_set Set.Ioc_subset_Ioi_self) (hg.mono_set (Set.Ioi_subset_Ioi h))]
  calc
    _ = ‚Äñ(s - 1) * s *
          ((‚à´ (t : ‚Ñù) in Set.Ioi 1, S t * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ))
            - ‚à´ (t : ‚Ñù) in Set.Ioi 1, l * (t : ‚ÑÇ) ^ (-(s : ‚ÑÇ)))‚Äñ := ?_
    _ = ‚Äñ(s - 1) * s *
        ‚à´ (t : ‚Ñù) in Set.Ioi 1, (S t * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ) - l * t ^ (-(s : ‚ÑÇ)))‚Äñ := ?_
    _ ‚â§ (s - 1) * s *
          ‚Äñ‚à´ (t : ‚Ñù) in Set.Ioi 1, S t * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ) - l * t ^ (-(s : ‚ÑÇ))‚Äñ := ?_
    _ = (s - 1) * s * ‚ÄñCs +
        ‚à´ (t : ‚Ñù) in Set.Ioi T, S t * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ) - l * t ^ (-(s : ‚ÑÇ))‚Äñ := ?_
    _ ‚â§ (s - 1) * s * ‚ÄñC‚Äñ + s * ((s - 1) *
          ‚à´ (t : ‚Ñù) in Set.Ioi T, ‚ÄñS t * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ) - l * t ^ (-(s : ‚ÑÇ))‚Äñ) := ?_
    _ ‚â§ (s - 1) * s * ‚ÄñC‚Äñ + s * Œµ := ?_
  ¬∑ rw [mul_sub, integral_mul_left, ‚Üê mul_assoc, mul_rotate _ _ l, mul_assoc, mul_assoc, h‚ÇÇ,
      mul_one, mul_comm _ l, LSeries_eq_mul_integral _ zero_le_one (by rwa [ofReal_re]) (hfS _ hs)]
    exact isBigO_of_tendsto_sum_div hlim
  ¬∑ rw [integral_sub]
    ¬∑
      sorry
      -- Integrable (fun t ‚Ü¶ S t * ‚Üët ^ (-(‚Üës + 1))) (volume.restrict (Set.Ioi 1))
    ¬∑ sorry
      -- Integrable (fun t ‚Ü¶ l * ‚Üët ^ (-‚Üës)) (volume.restrict (Set.Ioi 1))
  ¬∑ rw [norm_mul, norm_mul, show (s : ‚ÑÇ) - 1 = (s - 1 : ‚Ñù) by simp, norm_real, norm_real,
      Real.norm_of_nonneg, Real.norm_of_nonneg]
    sorry -- 0 ‚â§ s
    sorry -- 0 ‚â§ s - 1
  ¬∑ rw [‚Üê Set.Ioc_union_Ioi_eq_Ioi hT‚ÇÅ, setIntegral_union (Set.Ioc_disjoint_Ioi le_rfl)
      measurableSet_Ioi]
    ¬∑ sorry
      -- IntegrableOn (fun t ‚Ü¶ S t * ‚Üët ^ (-(‚Üës + 1)) - l * ‚Üët ^ (-‚Üës)) (Set.Ioc 1 T) volume
    ¬∑ sorry
      -- IntegrableOn (fun t ‚Ü¶ S t * ‚Üët ^ (-(‚Üës + 1)) - l * ‚Üët ^ (-‚Üës)) (Set.Ioi T) volume
  ¬∑ rw [‚Üê mul_assoc, mul_comm s, ‚Üê mul_add]
    gcongr
    ¬∑ sorry  -- 0 ‚â§ (s - 1) * s
    ¬∑ refine (norm_add_le _ _).trans ?_
      gcongr
      ¬∑ sorry -- ‚ÄñCs‚Äñ ‚â§ ‚ÄñC‚Äñ
      exact norm_integral_le_integral_norm _
  ¬∑ gcongr
    refine aux‚ÇÇ ?_ hŒµ hs hT‚ÇÅ ?_
    ¬∑ sorry -- Measurable S
    ¬∑ intro t ht
      exact (hT t ht.le).le





#exit

  ¬∑ rw [LSeries_eq_mul_integral _ zero_le_one (by rwa [ofReal_re]) (hfS _ hs), mul_sub,
        ‚Üê mul_assoc _ l, mul_rotate _ _ l, mul_assoc, mul_assoc, h‚ÇÇ, mul_one, mul_comm l]
    exact isBigO_of_tendsto_sum_div hlim
  ¬∑ rw [h‚ÇÉ hT‚ÇÅ, h‚ÇÉ hT‚ÇÅ]
    ¬∑ sorry
    ¬∑ sorry
  ¬∑ refine le_trans (norm_add_le _ _) <| le_trans (add_le_add_right (norm_sub_le _ _) _) ?_
    rw [norm_mul (((s : ‚ÑÇ) - 1) * s), norm_mul (((s : ‚ÑÇ) - 1) * s), norm_mul (((s : ‚ÑÇ) - 1) * s),
      show (((s : ‚ÑÇ) - 1) * s)  = ((s - 1) * s : ‚Ñù) by rw [ofReal_mul, ofReal_sub,
        ofReal_one], Complex.norm_real, Real.norm_of_nonneg]
    sorry
  ¬∑




#exit



include hlim hfS in
private theorem key_step {Œµ : ‚Ñù} (hŒµ : Œµ > 0) :
    ‚àÉ C ‚â• 0, ‚àÄ s : ‚Ñù, 1 < s ‚Üí ‚Äñ(s - 1) * LSeries f s - l * s‚Äñ ‚â§ (s - 1) * s * C + s * Œµ := by
  obtain ‚ü®T', hT'‚ü© := (eventually_atTop).mp <| aux‚ÇÅ hlim hŒµ
  let T := max 1 T'
  have hT‚ÇÄ : 0 < T := zero_lt_one.trans_le (le_max_left _ _)
  let C‚ÇÅ := ‚à´ t in Set.Ioc 1 T, ‚Äñ(‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (-2 : ‚ÑÇ)‚Äñ
  let C‚ÇÇ := ‚Äñl‚Äñ * ‚à´ t in Set.Ioc 1 T, ‚Äñ(t : ‚ÑÇ) ^ (-1 : ‚ÑÇ)‚Äñ
  refine ‚ü®C‚ÇÅ + C‚ÇÇ, ?_, fun s hs ‚Ü¶ ?_‚ü©
  ¬∑ exact add_nonneg (integral_nonneg fun _ ‚Ü¶ norm_nonneg _) <|
      mul_nonneg (norm_nonneg _) (integral_nonneg fun _ ‚Ü¶ norm_nonneg _)
  ¬∑ have h‚ÇÉ : (s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi 1, t ^ (-s) = 1 := by
      sorry
--   rw [integral_Ioi_rpow_of_lt (by rwa [neg_lt_neg_iff]) zero_lt_one, Real.one_rpow, neg_div,
--     ‚Üê one_div_neg_eq_neg_one_div, neg_add', neg_neg, mul_one_div, div_self (sub_ne_zero.mpr hs.ne')]
    have h‚ÇÑ : (s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi 1, (t : ‚ÑÇ) ^ (-s : ‚ÑÇ) = 1 := sorry
-- private theorem sub_mul_int_cpow {s : ‚ÑÇ} (hs : 1 < s.re) :
--     (s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi 1, (t : ‚ÑÇ) ^ (-s : ‚ÑÇ) = 1 := by
--   have : 1 - s ‚â† 0 := by
--     contrapose! hs
--     rw [‚Üê sub_eq_zero.mp hs, one_re]
--   rw [integral_Ioi_cpow_of_lt (by rwa [neg_re, neg_lt_neg_iff]) zero_lt_one, ofReal_one, one_cpow,
--     ‚Üê mul_div_assoc, mul_neg_one, neg_add_eq_sub, neg_sub, div_self this]
    have hs' : 0 ‚â§ (s - 1) * s := mul_nonneg (sub_nonneg.mpr hs.le) (zero_le_one.trans hs.le)
--    have hT‚ÇÅ : ‚àÄ t ‚àà Set.Ioi T,
--        ‚Äñ‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k - l * t‚Äñ * ‚Äñ(t : ‚ÑÇ) ^ (-((s : ‚ÑÇ) + 1))‚Äñ ‚â§ ‚ÄñŒµ * t‚Äñ *
--          ‚Äñ(t : ‚ÑÇ) ^ (-((s : ‚ÑÇ) + 1))‚Äñ := fun t ht ‚Ü¶ by
--      refine mul_le_mul_of_nonneg_right ?_ (norm_nonneg _)
--      rw [Real.norm_of_nonneg (mul_nonneg hŒµ.le (hT‚ÇÄ.trans ht).le)]
--      exact (hT' _ (le_trans (le_max_right 1 T') ht.le)).le
    let C‚ÇÅs := ‚à´ t in Set.Ioc 1 T, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ)
    let C‚ÇÇs := l * ‚à´ t in Set.Ioc 1 T, (t : ‚ÑÇ) ^ (-s : ‚ÑÇ)
    calc
      _ = ‚Äñ(s - 1) * s *
            ((‚à´ (t : ‚Ñù) in Set.Ioi 1, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ))
              - l * ‚à´ (t : ‚Ñù) in Set.Ioi 1, (t : ‚ÑÇ) ^ (-s : ‚ÑÇ))‚Äñ := ?_
      _ = ‚Äñ(s - 1) * s *
            ((‚à´ (t : ‚Ñù) in Set.Ioc 1 T, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ)) +
              (‚à´ (t : ‚Ñù) in Set.Ioi T, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ))
                - l * ((‚à´ (t : ‚Ñù) in Set.Ioc 1 T, (t : ‚ÑÇ) ^ (-s : ‚ÑÇ))
                  + (‚à´ (t : ‚Ñù) in Set.Ioi T, (t : ‚ÑÇ) ^ (-s : ‚ÑÇ))))‚Äñ := ?_
      _ = ‚Äñ(s - 1) * s * C‚ÇÅs  -(s - 1) * s * C‚ÇÇs +
            (s - 1) * s *
              ((‚à´ (t : ‚Ñù) in Set.Ioi T, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ)) -
                l * (‚à´ (t : ‚Ñù) in Set.Ioi T, (t : ‚ÑÇ) ^ (-s : ‚ÑÇ)))‚Äñ := by congr; ring
      _ ‚â§ (s - 1) * s * ‚ÄñC‚ÇÅs‚Äñ + (s - 1) * s * ‚ÄñC‚ÇÇs‚Äñ +
            (s - 1) * s *
              ‚Äñ(‚à´ (t : ‚Ñù) in Set.Ioi T, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ)) -
                l * (‚à´ (t : ‚Ñù) in Set.Ioi T, (t : ‚ÑÇ) ^ (-s : ‚ÑÇ))‚Äñ := ?_
      _ ‚â§ (s - 1) * s * C‚ÇÅ + (s - 1) * s * C‚ÇÇ +
            (s - 1) * s *
              ‚Äñ‚à´ (t : ‚Ñù) in Set.Ioi T,
                (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ) - l * (t : ‚ÑÇ) ^ (-s : ‚ÑÇ)‚Äñ := ?_
      _ ‚â§ (s - 1) * s * (C‚ÇÅ + C‚ÇÇ) + s * Œµ := ?_
    ¬∑ rw [LSeries_eq_mul_integral _ zero_le_one (by rwa [ofReal_re]) (hfS _ hs), mul_sub,
        ‚Üê mul_assoc _ l, mul_rotate _ _ l, mul_assoc, mul_assoc, h‚ÇÑ, mul_one, mul_comm l]
      exact isBigO_of_tendsto_sum_div hlim -- Factor out this result?
    ¬∑ rw [int_Ioi_eq (le_max_left _ _), int_Ioi_eq (le_max_left 1 _)]
      ¬∑ rw [integrableOn_Ioi_cpow_iff zero_lt_one]
        rwa [neg_re, ofReal_re, neg_lt_neg_iff]
      ¬∑ refine integrableOn_Ici_iff_integrableOn_Ioi.mp <|
          intOn_sum_mul_cpow zero_lt_one ?_ (isBigO_of_tendsto_sum_div hlim)
        rwa [ofReal_re]
    ¬∑ refine le_trans (norm_add_le _ _) <| le_trans (add_le_add_right (norm_sub_le _ _) _) ?_
      rw [norm_mul (((s : ‚ÑÇ) - 1) * s), norm_mul (((s : ‚ÑÇ) - 1) * s), norm_mul (((s : ‚ÑÇ) - 1) * s),
        show (((s : ‚ÑÇ) - 1) * s)  = ((s - 1) * s : ‚Ñù) by rw [ofReal_mul, ofReal_sub,
          ofReal_one], Complex.norm_real, Real.norm_of_nonneg hs']
    ¬∑ gcongr
      ¬∑ exact norm_int_sum_mul_cpow_le (by rw [ofReal_re]; exact hs.le)
      ¬∑ exact norm_mul_int_cpow_le (by rw [ofReal_re]; exact hs.le)
      ¬∑ rw [integral_sub, integral_mul_left]
        ¬∑ exact integrableOn_Ici_iff_integrableOn_Ioi.mp <|
            intOn_sum_mul_cpow hT‚ÇÄ (by rwa [ofReal_re]) (isBigO_of_tendsto_sum_div hlim)
        ¬∑ refine Integrable.const_mul ?_ _ -- (intO_cpow hT (by rwa [ofReal_re])) _
          rw [‚Üê IntegrableOn, integrableOn_Ioi_cpow_iff hT‚ÇÄ]
          rwa [neg_re, ofReal_re, neg_lt_neg_iff]
    ¬∑ rw [‚Üê mul_add, mul_comm _ s, mul_assoc, mul_assoc]
      gcongr
      refine aux‚ÇÇ ?_ hŒµ hs (le_max_left _ _) fun t ht ‚Ü¶ ?_
      ¬∑ -- Using exact does not work here
        convert Measurable.comp' (by measurability : Measurable fun n : ‚Ñï ‚Ü¶ ‚àë k ‚àà Icc 1 n, f k)
          (Nat.measurable_floor (R := ‚Ñù))
      ¬∑ rw [Real.norm_of_nonneg (mul_nonneg hŒµ.le (hT‚ÇÄ.trans ht).le)]
        exact (hT' t ((le_max_right _ _).trans ht.le)).le








include hlim hfS in
private theorem key_step0 {Œµ : ‚Ñù} (hŒµ : Œµ > 0) :
    ‚àÉ C ‚â• 0, ‚àÄ s : ‚Ñù, 1 < s ‚Üí ‚Äñ(s - 1) * LSeries f s - l * s‚Äñ ‚â§ (s - 1) * s * C + s * Œµ := by
  have h‚ÇÅ : Measurable (fun t : ‚Ñù ‚Ü¶ ‚Äñ(‚àë k in Icc 1 ‚åät‚åã‚Çä, f k) - l * t‚Äñ) :=
    (((by exact fun _ _ ‚Ü¶ trivial : Measurable fun n : ‚Ñï ‚Ü¶ ‚àë k ‚àà Icc 1 n, f k).comp'
      Nat.measurable_floor).sub (by fun_prop)).norm

  have h‚ÇÇ {t : ‚Ñù} {s : ‚ÑÇ} : t ‚â† 0 ‚Üí t * (t : ‚ÑÇ) ^ (-s - 1) = t ^ (-s) := fun ht ‚Ü¶ by
    replace ht := ofReal_ne_zero.mpr ht
    rw [cpow_sub _ _ ht, cpow_one, mul_div_cancel‚ÇÄ _ ht]





  obtain ‚ü®T', hT'‚ü© := (eventually_atTop).mp <| step1 hlim hŒµ
  let T := max 1 T'
  have hT‚ÇÄ : 0 < T := zero_lt_one.trans_le (le_max_left _ _)
  let C‚ÇÅ := ‚à´ t in Set.Ioc 1 T, ‚Äñ(‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (-2 : ‚ÑÇ)‚Äñ
  let C‚ÇÇ := ‚Äñl‚Äñ * ‚à´ t in Set.Ioc 1 T, ‚Äñ(t : ‚ÑÇ) ^ (-1 : ‚ÑÇ)‚Äñ
  refine ‚ü®C‚ÇÅ + C‚ÇÇ, ?_, fun s hs ‚Ü¶ ?_‚ü©
  ¬∑ exact add_nonneg (integral_nonneg fun _ ‚Ü¶ norm_nonneg _) <|
      mul_nonneg (norm_nonneg _) (integral_nonneg fun _ ‚Ü¶ norm_nonneg _)
  ¬∑ have h‚ÇÉ : (s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi 1, t ^ (-s) = 1 := by
      sorry
--   rw [integral_Ioi_rpow_of_lt (by rwa [neg_lt_neg_iff]) zero_lt_one, Real.one_rpow, neg_div,
--     ‚Üê one_div_neg_eq_neg_one_div, neg_add', neg_neg, mul_one_div, div_self (sub_ne_zero.mpr hs.ne')]

    have h‚ÇÑ : (s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi 1, (t : ‚ÑÇ) ^ (-s : ‚ÑÇ) = 1 := sorry
-- private theorem sub_mul_int_cpow {s : ‚ÑÇ} (hs : 1 < s.re) :
--     (s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi 1, (t : ‚ÑÇ) ^ (-s : ‚ÑÇ) = 1 := by
--   have : 1 - s ‚â† 0 := by
--     contrapose! hs
--     rw [‚Üê sub_eq_zero.mp hs, one_re]
--   rw [integral_Ioi_cpow_of_lt (by rwa [neg_re, neg_lt_neg_iff]) zero_lt_one, ofReal_one, one_cpow,
--     ‚Üê mul_div_assoc, mul_neg_one, neg_add_eq_sub, neg_sub, div_self this]

    have hs' : 0 ‚â§ (s - 1) * s := mul_nonneg (sub_nonneg.mpr hs.le) (zero_le_one.trans hs.le)
    have hT‚ÇÅ : ‚àÄ t ‚àà Set.Ioi T,
        ‚Äñ‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k - l * t‚Äñ * ‚Äñ(t : ‚ÑÇ) ^ (-((s : ‚ÑÇ) + 1))‚Äñ ‚â§ ‚ÄñŒµ * t‚Äñ *
          ‚Äñ(t : ‚ÑÇ) ^ (-((s : ‚ÑÇ) + 1))‚Äñ := fun t ht ‚Ü¶ by
      refine mul_le_mul_of_nonneg_right ?_ (norm_nonneg _)
      rw [Real.norm_of_nonneg (mul_nonneg hŒµ.le (hT‚ÇÄ.trans ht).le)]
      exact (hT' _ (le_trans (le_max_right 1 T') ht.le)).le
    let C‚ÇÅs := ‚à´ t in Set.Ioc 1 T, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ)
    let C‚ÇÇs := l * ‚à´ t in Set.Ioc 1 T, (t : ‚ÑÇ) ^ (-s : ‚ÑÇ)
    calc
      _ = ‚Äñ(s - 1) * s *
            ((‚à´ (t : ‚Ñù) in Set.Ioi 1, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ))
              - l * ‚à´ (t : ‚Ñù) in Set.Ioi 1, (t : ‚ÑÇ) ^ (-s : ‚ÑÇ))‚Äñ := ?_
      _ = ‚Äñ(s - 1) * s *
            ((‚à´ (t : ‚Ñù) in Set.Ioc 1 T, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ)) +
              (‚à´ (t : ‚Ñù) in Set.Ioi T, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ))
                - l * ((‚à´ (t : ‚Ñù) in Set.Ioc 1 T, (t : ‚ÑÇ) ^ (-s : ‚ÑÇ))
                  + (‚à´ (t : ‚Ñù) in Set.Ioi T, (t : ‚ÑÇ) ^ (-s : ‚ÑÇ))))‚Äñ := ?_
      _ = ‚Äñ(s - 1) * s * C‚ÇÅs  -(s - 1) * s * C‚ÇÇs +
            (s - 1) * s *
              ((‚à´ (t : ‚Ñù) in Set.Ioi T, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ)) -
                l * (‚à´ (t : ‚Ñù) in Set.Ioi T, (t : ‚ÑÇ) ^ (-s : ‚ÑÇ)))‚Äñ := by congr; ring
      _ ‚â§ (s - 1) * s * ‚ÄñC‚ÇÅs‚Äñ + (s - 1) * s * ‚ÄñC‚ÇÇs‚Äñ +
            (s - 1) * s *
              ‚Äñ(‚à´ (t : ‚Ñù) in Set.Ioi T, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ)) -
                l * (‚à´ (t : ‚Ñù) in Set.Ioi T, (t : ‚ÑÇ) ^ (-s : ‚ÑÇ))‚Äñ := ?_
      _ ‚â§ (s - 1) * s * C‚ÇÅ + (s - 1) * s * C‚ÇÇ +
            (s - 1) * s *
              ‚Äñ‚à´ (t : ‚Ñù) in Set.Ioi T,
                (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ) - l * (t : ‚ÑÇ) ^ (-s : ‚ÑÇ)‚Äñ := ?_
      _ = (s - 1) * s * (C‚ÇÅ + C‚ÇÇ) +
            (s - 1) * s *
              ‚Äñ‚à´ (t : ‚Ñù) in Set.Ioi T,
                ((‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) - l * t) * (t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ)‚Äñ := ?_
      _ ‚â§ (s - 1) * s * (C‚ÇÅ + C‚ÇÇ) +
            (s - 1) * s *
              ‚à´ (t : ‚Ñù) in Set.Ioi T,
                ‚Äñ((‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) - l * t)‚Äñ * ‚Äñ(t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ)‚Äñ := ?_
      _ ‚â§ (s - 1) * s * (C‚ÇÅ + C‚ÇÇ) +
            (s - 1) * s * ‚à´ (t : ‚Ñù) in Set.Ioi T, ‚ÄñŒµ * t‚Äñ * ‚Äñ(t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ)‚Äñ := ?_
      _ ‚â§ (s - 1) * s * (C‚ÇÅ + C‚ÇÇ) +
            (s - 1) * s * ‚à´ (t : ‚Ñù) in Set.Ioi 1, ‚ÄñŒµ * t‚Äñ * ‚Äñ(t : ‚ÑÇ) ^ (-(s + 1) : ‚ÑÇ)‚Äñ := ?_
      _ = (s - 1) * s * (C‚ÇÅ + C‚ÇÇ) +
            (s - 1) * s * ‚à´ (t : ‚Ñù) in Set.Ioi 1, Œµ * ‚Äñ(t : ‚ÑÇ) ^ (-s : ‚ÑÇ)‚Äñ := ?_
      _ = (s - 1) * s * (C‚ÇÅ + C‚ÇÇ) +
            s * Œµ * ((s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi 1, t ^ (-s)) := ?_
      _ = (s - 1) * s * (C‚ÇÅ + C‚ÇÇ) + s * Œµ := by rw [h‚ÇÉ, mul_one]
    ¬∑ rw [LSeries_eq_mul_integral _ zero_le_one (by rwa [ofReal_re]) (hfS _ hs), mul_sub,
        ‚Üê mul_assoc _ l, mul_rotate _ _ l, mul_assoc, mul_assoc, h‚ÇÑ, mul_one, mul_comm l]
      exact isBigO_of_tendsto_sum_div hlim -- Factor out this result?
    ¬∑ rw [int_Ioi_eq (le_max_left _ _), int_Ioi_eq (le_max_left 1 _)]
      ¬∑ rw [integrableOn_Ioi_cpow_iff zero_lt_one]
        rwa [neg_re, ofReal_re, neg_lt_neg_iff]
      ¬∑ refine integrableOn_Ici_iff_integrableOn_Ioi.mp <|
          intOn_sum_mul_cpow zero_lt_one ?_ (isBigO_of_tendsto_sum_div hlim)
        rwa [ofReal_re]
    ¬∑ refine le_trans (norm_add_le _ _) <| le_trans (add_le_add_right (norm_sub_le _ _) _) ?_
      rw [norm_mul (((s : ‚ÑÇ) - 1) * s), norm_mul (((s : ‚ÑÇ) - 1) * s), norm_mul (((s : ‚ÑÇ) - 1) * s),
        show (((s : ‚ÑÇ) - 1) * s)  = ((s - 1) * s : ‚Ñù) by rw [ofReal_mul, ofReal_sub,
          ofReal_one], Complex.norm_real, Real.norm_of_nonneg hs']
    ¬∑ gcongr
      ¬∑ exact norm_int_sum_mul_cpow_le (by rw [ofReal_re]; exact hs.le)
      ¬∑ exact norm_mul_int_cpow_le (by rw [ofReal_re]; exact hs.le)
      ¬∑ rw [integral_sub, integral_mul_left]
        ¬∑ exact integrableOn_Ici_iff_integrableOn_Ioi.mp <|
            intOn_sum_mul_cpow hT‚ÇÄ (by rwa [ofReal_re]) (isBigO_of_tendsto_sum_div hlim)
        ¬∑ refine Integrable.const_mul ?_ _ -- (intO_cpow hT (by rwa [ofReal_re])) _
          rw [‚Üê IntegrableOn, integrableOn_Ioi_cpow_iff hT‚ÇÄ]
          rwa [neg_re, ofReal_re, neg_lt_neg_iff]
    ¬∑ rw [mul_add]
      congr 3
      refine setIntegral_congr_fun measurableSet_Ioi fun t ht ‚Ü¶ ?_
      rw [sub_mul, neg_add', mul_assoc, h‚ÇÇ (hT‚ÇÄ.trans ht).ne']
    ¬∑ refine add_le_add_left (mul_le_mul_of_nonneg_left ?_ hs') _
      exact le_of_le_of_eq (norm_integral_le_integral_norm _) (by simp_rw [norm_mul])
    ¬∑ refine add_le_add_left (mul_le_mul_of_nonneg_left
        (setIntegral_mono_on ?_ ?_ measurableSet_Ioi hT‚ÇÅ) hs') _
      ¬∑ refine Integrable.mono
          (intOn_norm_mul_id_mul_norm_cpow_succ hŒµ.le hT‚ÇÄ (by rwa [ofReal_re])) ?_
          ((ae_restrict_iff' measurableSet_Ioi).mpr ?_)
        ¬∑ exact Measurable.aestronglyMeasurable <| h‚ÇÅ.mul (by fun_prop)
        ¬∑ filter_upwards with t ht
          rw [Real.norm_of_nonneg (by positivity), Real.norm_of_nonneg (by positivity)]
          exact hT‚ÇÅ t ht
      ¬∑ exact intOn_norm_mul_id_mul_norm_cpow_succ hŒµ.le hT‚ÇÄ (by rwa [ofReal_re])
    ¬∑ refine add_le_add_left (mul_le_mul_of_nonneg_left (setIntegral_mono_set ?_ ?_ ?_) hs') _
      ¬∑ refine intOn_norm_mul_id_mul_norm_cpow_succ hŒµ.le zero_lt_one (by rwa [ofReal_re])
      ¬∑ filter_upwards with _ using mul_nonneg (norm_nonneg _) (norm_nonneg _)
      ¬∑ exact HasSubset.Subset.eventuallyLE <| Set.Ioi_subset_Ioi (le_max_left _ _)
    ¬∑ congr 2
      refine setIntegral_congr_fun measurableSet_Ioi fun t ht ‚Ü¶ ?_
      rw [norm_mul, mul_assoc, Real.norm_of_nonneg hŒµ.le, ‚Üê norm_real, ‚Üê norm_mul, neg_add',
        h‚ÇÇ (zero_lt_one.trans ht).ne']
    ¬∑ rw [integral_mul_left, ‚Üê mul_assoc, ‚Üê mul_assoc, ‚Üê mul_rotate _ s]
      congr 2
      refine setIntegral_congr_fun measurableSet_Ioi fun t ht ‚Ü¶ ?_
      rw [Complex.norm_eq_abs, Complex.abs_cpow_eq_rpow_re_of_pos (zero_lt_one.trans ht), neg_re,
        ofReal_re]

include hlim hfS in
theorem LSeries_tendsto_sub_mul_nhds_one_of_tendsto_sum_div :
    Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * LSeries f s) (ùìù[>] 1) (ùìù l) := by
  refine Metric.tendsto_nhdsWithin_nhds.mpr fun Œµ hŒµ ‚Ü¶ ?_
  have hŒµ6 : 0 < Œµ / 6 := by positivity
  have hŒµ3 : 0 < Œµ / 3 := by positivity
  obtain ‚ü®C, hC‚ÇÅ, hC‚ÇÇ‚ü© := key_step hlim hfS hŒµ6
  have lim1 : Tendsto (fun s ‚Ü¶ (s - 1) * s * C) (ùìù[>] 1) (ùìù 0) := by
    have : ContinuousAt (fun s ‚Ü¶ (s - 1) * s * C) 1 := by fun_prop
    convert tendsto_nhdsWithin_of_tendsto_nhds this.tendsto
    rw [sub_self, zero_mul, zero_mul]
  have lim2 : Tendsto (fun s : ‚Ñù ‚Ü¶ s * l) (ùìù[>] 1) (ùìù l) := by
    have : ContinuousAt (fun s : ‚Ñù ‚Ü¶ s * l) 1 := by fun_prop
    convert tendsto_nhdsWithin_of_tendsto_nhds this.tendsto
    rw [Complex.ofReal_one, one_mul]
  rw [Metric.tendsto_nhdsWithin_nhds] at lim1 lim2
  obtain ‚ü®Œ¥‚ÇÅ, _, hŒ¥‚ÇÅ‚ü© := lim1 _ hŒµ3
  obtain ‚ü®Œ¥‚ÇÇ, _, hŒ¥‚ÇÇ‚ü© := lim2 _ hŒµ3
  refine ‚ü®min 1 (min Œ¥‚ÇÅ Œ¥‚ÇÇ), by positivity, fun s hs‚ÇÅ hs‚ÇÇ ‚Ü¶ ?_‚ü©
  specialize hC‚ÇÇ s hs‚ÇÅ
  specialize hŒ¥‚ÇÅ hs‚ÇÅ <| hs‚ÇÇ.trans_le <| (min_le_right _ _).trans (min_le_left _ _)
  specialize hŒ¥‚ÇÇ hs‚ÇÅ <| hs‚ÇÇ.trans_le <| (min_le_right _ _).trans (min_le_right _ _)
  rw [dist_eq_norm] at hŒ¥‚ÇÅ hŒ¥‚ÇÇ hs‚ÇÇ ‚ä¢
  rw [sub_zero, Real.norm_of_nonneg (mul_nonneg
    (mul_nonneg (sub_nonneg.mpr hs‚ÇÅ.le) (zero_lt_one.trans hs‚ÇÅ).le) hC‚ÇÅ)] at hŒ¥‚ÇÅ
  have sle2 : s < 2 := by
    have := (abs_lt.mp <| Real.norm_eq_abs _ ‚ñ∏ (hs‚ÇÇ.trans_le (min_le_left _ _))).2
    rwa [sub_lt_iff_lt_add', one_add_one_eq_two] at this
  calc
    _ ‚â§ ‚Äñ(s - 1) * LSeries f s - l * s‚Äñ + ‚Äñl * s - l‚Äñ := norm_sub_le_norm_sub_add_norm_sub _ _ _
    _ < (s - 1) * s * C + s * (Œµ / 6) + (Œµ / 3) := add_lt_add_of_le_of_lt hC‚ÇÇ (by rwa [mul_comm])
    _ ‚â§ (Œµ / 3) + s * (Œµ / 6) + (Œµ / 3) := by gcongr
    _ < (Œµ / 3) + (Œµ / 3) + (Œµ / 3) := ?_
    _ = Œµ := add_thirds Œµ
  refine add_lt_add_right (add_lt_add_left ?_ (Œµ / 3)) (Œµ / 3)
  exact lt_of_lt_of_eq ((mul_lt_mul_right hŒµ6).mpr sle2) (by ring)

theorem LSeries_tendsto_sub_mul_nhds_one_of_tendsto_sum_div_and_nonneg (f : ‚Ñï ‚Üí ‚Ñù) {l : ‚Ñù}
    (hf : Tendsto (fun n ‚Ü¶ (‚àë k ‚àà Icc 1 n, f k) / (n : ‚Ñù)) atTop (ùìù l))
    (hf' : ‚àÄ n, 0 ‚â§ f n) :
    Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * LSeries (fun n ‚Ü¶ f n) s) (ùìù[>] 1) (ùìù l) := by
  refine  LSeries_tendsto_sub_mul_nhds_one_of_tendsto_sum_div (f := fun n ‚Ü¶ f n)
    (hf.ofReal.congr fun _ ‚Ü¶ ?_) fun s hs ‚Ü¶ ?_
  ¬∑ simp_rw [ofReal_div, ofReal_sum, ofReal_natCast]
  ¬∑ exact LSeriesSummable_of_sum_norm_bigO_and_nonneg
      (isBigO_of_tendsto_sum_div hf) hf' zero_le_one (by rwa [ofReal_re])

end proof

end residue
