/-
Copyright (c) 2021 Alex Zhao. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Alex Zhao
-/
import Mathlib.Data.Nat.ModEq
import Mathlib.GroupTheory.Submonoid.Basic
import Mathlib.GroupTheory.Submonoid.Membership
import Mathlib.Tactic.Ring
import Mathlib.Tactic.Zify

#align_import number_theory.frobenius_number from "leanprover-community/mathlib"@"1126441d6bccf98c81214a0780c73d499f6721fe"

/-!
# Frobenius Number in Two Variables

In this file we first define a predicate for Frobenius numbers, then solve the 2-variable variant
of this problem.

## Theorem Statement

Given a finite set of relatively prime integers all greater than 1, their Frobenius number is the
largest positive integer that cannot be expressed as a sum of nonnegative multiples of these
integers. Here we show the Frobenius number of two relatively prime integers `m` and `n` greater
than 1 is `m * n - m - n`. This result is also known as the Chicken McNugget Theorem.

## Implementation Notes

First we define Frobenius numbers in general using `IsGreatest` and `AddSubmonoid.closure`. Then
we proceed to compute the Frobenius number of `m` and `n`.

For the upper bound, we begin with an auxiliary lemma showing `m * n` is not attainable, then show
`m * n - m - n` is not attainable. Then for the construction, we create a `k_1` which is `k mod n`
and `0 mod m`, then show it is at most `k`. Then `k_1` is a multiple of `m`, so `(k-k_1)`
is a multiple of n, and we're done.

## Tags

frobenius number, chicken mcnugget, chinese remainder theorem, add_submonoid.closure
-/


open Nat

/-- A natural number `n` is the **Frobenius number** of a set of natural numbers `s` if it is an
upper bound on the complement of the additive submonoid generated by `s`.
In other words, it is the largest number that can not be expressed as a sum of numbers in `s`. -/
def FrobeniusNumber (n : â„•) (s : Set â„•) : Prop :=
  IsGreatest { k | k âˆ‰ AddSubmonoid.closure s } n
#align is_frobenius_number FrobeniusNumber

variable {m n : â„•}

/-- The **Chicken McNugget theorem** stating that the Frobenius number
  of positive numbers `m` and `n` is `m * n - m - n`. -/
theorem frobeniusNumber_pair (cop : coprime m n) (hm : 1 < m) (hn : 1 < n) :
    FrobeniusNumber (m * n - m - n) {m, n} := by
  simp_rw [FrobeniusNumber, AddSubmonoid.mem_closure_pair]
  -- âŠ¢ IsGreatest {k | Â¬âˆƒ m_1 n_1, m_1 â€¢ m + n_1 â€¢ n = k} (m * n - m - n)
  have hmn : m + n â‰¤ m * n := add_le_mul hm hn
  -- âŠ¢ IsGreatest {k | Â¬âˆƒ m_1 n_1, m_1 â€¢ m + n_1 â€¢ n = k} (m * n - m - n)
  constructor
  -- âŠ¢ m * n - m - n âˆˆ {k | Â¬âˆƒ m_1 n_1, m_1 â€¢ m + n_1 â€¢ n = k}
  Â· push_neg
    -- âŠ¢ m * n - m - n âˆˆ {k | âˆ€ (m_1 n_1 : â„•), m_1 â€¢ m + n_1 â€¢ n â‰  k}
    intro a b h
    -- âŠ¢ False
    apply cop.mul_add_mul_ne_mul (add_one_ne_zero a) (add_one_ne_zero b)
    -- âŠ¢ (a + 1) * m + (b + 1) * n = m * n
    simp only [Nat.sub_sub, smul_eq_mul] at h
    -- âŠ¢ (a + 1) * m + (b + 1) * n = m * n
    zify [hmn] at h âŠ¢
    -- âŠ¢ (â†‘a + 1) * â†‘m + (â†‘b + 1) * â†‘n = â†‘m * â†‘n
    rw [â† sub_eq_zero] at h âŠ¢
    -- âŠ¢ (â†‘a + 1) * â†‘m + (â†‘b + 1) * â†‘n - â†‘m * â†‘n = 0
    rw [â† h]
    -- âŠ¢ (â†‘a + 1) * â†‘m + (â†‘b + 1) * â†‘n - â†‘m * â†‘n = â†‘a * â†‘m + â†‘b * â†‘n - (â†‘m * â†‘n - (â†‘m â€¦
    ring
    -- ðŸŽ‰ no goals
  Â· intro k hk
    -- âŠ¢ k â‰¤ m * n - m - n
    dsimp at hk
    -- âŠ¢ k â‰¤ m * n - m - n
    contrapose! hk
    -- âŠ¢ âˆƒ m_1 n_1, m_1 * m + n_1 * n = k
    let x := chineseRemainder cop 0 k
    -- âŠ¢ âˆƒ m_1 n_1, m_1 * m + n_1 * n = k
    have hx : x.val < m * n := chineseRemainder_lt_mul cop 0 k (ne_bot_of_gt hm) (ne_bot_of_gt hn)
    -- âŠ¢ âˆƒ m_1 n_1, m_1 * m + n_1 * n = k
    suffices key : x.1 â‰¤ k
    -- âŠ¢ âˆƒ m_1 n_1, m_1 * m + n_1 * n = k
    Â· obtain âŸ¨a, haâŸ© := modEq_zero_iff_dvd.mp x.2.1
      -- âŠ¢ âˆƒ m_1 n_1, m_1 * m + n_1 * n = k
      obtain âŸ¨b, hbâŸ© := (modEq_iff_dvd' key).mp x.2.2
      -- âŠ¢ âˆƒ m_1 n_1, m_1 * m + n_1 * n = k
      exact âŸ¨a, b, by rw [mul_comm, â† ha, mul_comm, â† hb, Nat.add_sub_of_le key]âŸ©
      -- ðŸŽ‰ no goals
    refine' ModEq.le_of_lt_add x.2.2 (lt_of_le_of_lt _ (add_lt_add_right hk n))
    -- âŠ¢ â†‘x â‰¤ m * n - m - n + n
    rw [Nat.sub_add_cancel (le_tsub_of_add_le_left hmn)]
    -- âŠ¢ â†‘x â‰¤ m * n - m
    exact
      ModEq.le_of_lt_add
        (x.2.1.trans (modEq_zero_iff_dvd.mpr (Nat.dvd_sub' (dvd_mul_right m n) dvd_rfl)).symm)
        (lt_of_lt_of_le hx le_tsub_add)
#align is_frobenius_number_pair frobeniusNumber_pair
