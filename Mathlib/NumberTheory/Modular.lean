/-
Copyright (c) 2021 Alex Kontorovich and Heather Macbeth and Marc Masdeu. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Alex Kontorovich, Heather Macbeth, Marc Masdeu
-/
import Mathlib.Analysis.Complex.UpperHalfPlane.Basic
import Mathlib.LinearAlgebra.GeneralLinearGroup
import Mathlib.LinearAlgebra.Matrix.GeneralLinearGroup
import Mathlib.Topology.Instances.Matrix
import Mathlib.Topology.Algebra.Module.FiniteDimension

#align_import number_theory.modular from "leanprover-community/mathlib"@"2196ab363eb097c008d4497125e0dde23fb36db2"

/-!
# The action of the modular group SL(2, ‚Ñ§) on the upper half-plane

We define the action of `SL(2,‚Ñ§)` on `‚Ñç` (via restriction of the `SL(2,‚Ñù)` action in
`Analysis.Complex.UpperHalfPlane`). We then define the standard fundamental domain
(`ModularGroup.fd`, `ùíü`) for this action and show
(`ModularGroup.exists_smul_mem_fd`) that any point in `‚Ñç` can be
moved inside `ùíü`.

## Main definitions

The standard (closed) fundamental domain of the action of `SL(2,‚Ñ§)` on `‚Ñç`, denoted `ùíü`:
`fd := {z | 1 ‚â§ (z : ‚ÑÇ).normSq ‚àß |z.re| ‚â§ (1 : ‚Ñù) / 2}`

The standard open fundamental domain of the action of `SL(2,‚Ñ§)` on `‚Ñç`, denoted `ùíü·µí`:
`fdo := {z | 1 < (z : ‚ÑÇ).normSq ‚àß |z.re| < (1 : ‚Ñù) / 2}`

These notations are localized in the `Modular` locale and can be enabled via `open scoped Modular`.

## Main results

Any `z : ‚Ñç` can be moved to `ùíü` by an element of `SL(2,‚Ñ§)`:
`exists_smul_mem_fd (z : ‚Ñç) : ‚àÉ g : SL(2,‚Ñ§), g ‚Ä¢ z ‚àà ùíü`

If both `z` and `Œ≥ ‚Ä¢ z` are in the open domain `ùíü·µí` then `z = Œ≥ ‚Ä¢ z`:
`eq_smul_self_of_mem_fdo_mem_fdo {z : ‚Ñç} {g : SL(2,‚Ñ§)} (hz : z ‚àà ùíü·µí) (hg : g ‚Ä¢ z ‚àà ùíü·µí) : z = g ‚Ä¢ z`

# Discussion

Standard proofs make use of the identity

`g ‚Ä¢ z = a / c - 1 / (c (cz + d))`

for `g = [[a, b], [c, d]]` in `SL(2)`, but this requires separate handling of whether `c = 0`.
Instead, our proof makes use of the following perhaps novel identity (see
`ModularGroup.smul_eq_lcRow0_add`):

`g ‚Ä¢ z = (a c + b d) / (c^2 + d^2) + (d z - c) / ((c^2 + d^2) (c z + d))`

where there is no issue of division by zero.

Another feature is that we delay until the very end the consideration of special matrices
`T=[[1,1],[0,1]]` (see `ModularGroup.T`) and `S=[[0,-1],[1,0]]` (see `ModularGroup.S`), by
instead using abstract theory on the properness of certain maps (phrased in terms of the filters
`Filter.cocompact`, `Filter.cofinite`, etc) to deduce existence theorems, first to prove the
existence of `g` maximizing `(g‚Ä¢z).im` (see `ModularGroup.exists_max_im`), and then among
those, to minimize `|(g‚Ä¢z).re|` (see `ModularGroup.exists_row_one_eq_and_min_re`).
-/


open Complex hiding abs_two

open Matrix hiding mul_smul

open Matrix.SpecialLinearGroup UpperHalfPlane ModularGroup

noncomputable section

local notation "SL(" n ", " R ")" => SpecialLinearGroup (Fin n) R

local macro "‚Üë‚Çò" t:term:80 : term => `(term| ($t : Matrix (Fin 2) (Fin 2) ‚Ñ§))

open scoped UpperHalfPlane ComplexConjugate

namespace ModularGroup

variable {g : SL(2, ‚Ñ§)} (z : ‚Ñç)

section BottomRow

/-- The two numbers `c`, `d` in the "bottom_row" of `g=[[*,*],[c,d]]` in `SL(2, ‚Ñ§)` are coprime. -/
theorem bottom_row_coprime {R : Type*} [CommRing R] (g : SL(2, R)) :
    IsCoprime ((‚Üëg : Matrix (Fin 2) (Fin 2) R) 1 0) ((‚Üëg : Matrix (Fin 2) (Fin 2) R) 1 1) := by
  use -(‚Üëg : Matrix (Fin 2) (Fin 2) R) 0 1, (‚Üëg : Matrix (Fin 2) (Fin 2) R) 0 0
  rw [add_comm, neg_mul, ‚Üê sub_eq_add_neg, ‚Üê det_fin_two]
  exact g.det_coe
#align modular_group.bottom_row_coprime ModularGroup.bottom_row_coprime

/-- Every pair `![c, d]` of coprime integers is the "bottom_row" of some element `g=[[*,*],[c,d]]`
of `SL(2,‚Ñ§)`. -/
theorem bottom_row_surj {R : Type*} [CommRing R] :
    Set.SurjOn (fun g : SL(2, R) => (‚Üëg : Matrix (Fin 2) (Fin 2) R) 1) Set.univ
      {cd | IsCoprime (cd 0) (cd 1)} := by
  rintro cd ‚ü®b‚ÇÄ, a, gcd_eqn‚ü©
  let A := of ![![a, -b‚ÇÄ], cd]
  have det_A_1 : det A = 1 := by
    convert gcd_eqn
    rw [det_fin_two]
    simp [A, (by ring : a * cd 1 + b‚ÇÄ * cd 0 = b‚ÇÄ * cd 0 + a * cd 1)]
  refine' ‚ü®‚ü®A, det_A_1‚ü©, Set.mem_univ _, _‚ü©
  ext; simp [A]
#align modular_group.bottom_row_surj ModularGroup.bottom_row_surj

end BottomRow

section TendstoLemmas

open Filter ContinuousLinearMap

attribute [local simp] ContinuousLinearMap.coe_smul

/-- The function `(c,d) ‚Üí |cz+d|^2` is proper, that is, preimages of bounded-above sets are finite.
-/
theorem tendsto_normSq_coprime_pair :
    Filter.Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * z + p 1)) cofinite atTop := by
  -- using this instance rather than the automatic `Function.module` makes unification issues in
  -- `LinearEquiv.closedEmbedding_of_injective` less bad later in the proof.
  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
  let œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
  let f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1
  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by
    ext1
    dsimp only [œÄ‚ÇÄ, œÄ‚ÇÅ, f, LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight,
      LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =
      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp_def]
    rw [ofReal_intCast, ofReal_intCast]
  rw [this]
  have hf : LinearMap.ker f = ‚ä• := by
    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=
      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]
    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0
      rw [f_def, add_im, im_ofReal_mul, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := f.closedEmbedding_of_injective hf
  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite
    ¬∑ rw [coprod·µ¢_cofinite]
    ¬∑ rw [coprod·µ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)
#align modular_group.tendsto_norm_sq_coprime_pair ModularGroup.tendsto_normSq_coprime_pair

/-- Given `coprime_pair` `p=(c,d)`, the matrix `[[a,b],[*,*]]` is sent to `a*c+b*d`.
  This is the linear map version of this operation.
-/
def lcRow0 (p : Fin 2 ‚Üí ‚Ñ§) : Matrix (Fin 2) (Fin 2) ‚Ñù ‚Üí‚Çó[‚Ñù] ‚Ñù :=
  ((p 0 : ‚Ñù) ‚Ä¢ LinearMap.proj (0 : Fin 2) +
      (p 1 : ‚Ñù) ‚Ä¢ LinearMap.proj (1 : Fin 2) : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù).comp
    (LinearMap.proj 0)
#align modular_group.lc_row0 ModularGroup.lcRow0

@[simp]
theorem lcRow0_apply (p : Fin 2 ‚Üí ‚Ñ§) (g : Matrix (Fin 2) (Fin 2) ‚Ñù) :
    lcRow0 p g = p 0 * g 0 0 + p 1 * g 0 1 :=
  rfl
#align modular_group.lc_row0_apply ModularGroup.lcRow0_apply

/-- Linear map sending the matrix [a, b; c, d] to the matrix [ac‚ÇÄ + bd‚ÇÄ, - ad‚ÇÄ + bc‚ÇÄ; c, d], for
some fixed `(c‚ÇÄ, d‚ÇÄ)`. -/
@[simps!]
def lcRow0Extend {cd : Fin 2 ‚Üí ‚Ñ§} (hcd : IsCoprime (cd 0) (cd 1)) :
    Matrix (Fin 2) (Fin 2) ‚Ñù ‚âÉ‚Çó[‚Ñù] Matrix (Fin 2) (Fin 2) ‚Ñù :=
  LinearEquiv.piCongrRight
    ![by
      refine'
        LinearMap.GeneralLinearGroup.generalLinearEquiv ‚Ñù (Fin 2 ‚Üí ‚Ñù)
          (GeneralLinearGroup.toLinear (planeConformalMatrix (cd 0 : ‚Ñù) (-(cd 1 : ‚Ñù)) _))
      norm_cast
      rw [neg_sq]
      exact hcd.sq_add_sq_ne_zero, LinearEquiv.refl ‚Ñù (Fin 2 ‚Üí ‚Ñù)]
#align modular_group.lc_row0_extend ModularGroup.lcRow0Extend

-- `simpNF` times out, but only in CI where all of `Mathlib` is imported
attribute [nolint simpNF] lcRow0Extend_apply lcRow0Extend_symm_apply

/-- The map `lcRow0` is proper, that is, preimages of cocompact sets are finite in
`[[* , *], [c, d]]`. -/
theorem tendsto_lcRow0 {cd : Fin 2 ‚Üí ‚Ñ§} (hcd : IsCoprime (cd 0) (cd 1)) :
    Tendsto (fun g : { g : SL(2, ‚Ñ§) // (‚Üë‚Çòg) 1 = cd } => lcRow0 cd ‚Üë(‚Üëg : SL(2, ‚Ñù))) cofinite
      (cocompact ‚Ñù) := by
  let mB : ‚Ñù ‚Üí Matrix (Fin 2) (Fin 2) ‚Ñù := fun t => of ![![t, (-(1 : ‚Ñ§) : ‚Ñù)], (‚Üë) ‚àò cd]
  have hmB : Continuous mB := by
    refine' continuous_matrix _
    simp only [mB, Fin.forall_fin_two, continuous_const, continuous_id', of_apply, cons_val_zero,
      cons_val_one, and_self_iff]
  refine' Filter.Tendsto.of_tendsto_comp _ (comap_cocompact_le hmB)
  let f‚ÇÅ : SL(2, ‚Ñ§) ‚Üí Matrix (Fin 2) (Fin 2) ‚Ñù := fun g =>
    Matrix.map (‚Üëg : Matrix _ _ ‚Ñ§) ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù)
  have cocompact_‚Ñù_to_cofinite_‚Ñ§_matrix :
    Tendsto (fun m : Matrix (Fin 2) (Fin 2) ‚Ñ§ => Matrix.map m ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù)) cofinite
      (cocompact _) := by
    simpa only [coprod·µ¢_cofinite, coprod·µ¢_cocompact] using
      Tendsto.pi_map_coprod·µ¢ fun _ : Fin 2 =>
        Tendsto.pi_map_coprod·µ¢ fun _ : Fin 2 => Int.tendsto_coe_cofinite
  have hf‚ÇÅ : Tendsto f‚ÇÅ cofinite (cocompact _) :=
    cocompact_‚Ñù_to_cofinite_‚Ñ§_matrix.comp Subtype.coe_injective.tendsto_cofinite
  have hf‚ÇÇ : ClosedEmbedding (lcRow0Extend hcd) :=
    (lcRow0Extend hcd).toContinuousLinearEquiv.toHomeomorph.closedEmbedding
  convert hf‚ÇÇ.tendsto_cocompact.comp (hf‚ÇÅ.comp Subtype.coe_injective.tendsto_cofinite) using 1
  ext ‚ü®g, rfl‚ü© i j : 3
  fin_cases i <;> [fin_cases j; skip]
  -- the following are proved by `simp`, but it is replaced by `simp only` to avoid timeouts.
  ¬∑ simp only [mB, mulVec, dotProduct, Fin.sum_univ_two, coe_matrix_coe,
      Int.coe_castRingHom, lcRow0_apply, Function.comp_apply, cons_val_zero, lcRow0Extend_apply,
      LinearMap.GeneralLinearGroup.coeFn_generalLinearEquiv, GeneralLinearGroup.coe_toLinear,
      val_planeConformalMatrix, neg_neg, mulVecLin_apply, cons_val_one, head_cons, of_apply,
      Fin.mk_zero, Fin.mk_one]
  ¬∑ convert congr_arg (fun n : ‚Ñ§ => (-n : ‚Ñù)) g.det_coe.symm using 1
    simp only [f‚ÇÅ, mulVec, dotProduct, Fin.sum_univ_two, Matrix.det_fin_two, Function.comp_apply,
      Subtype.coe_mk, lcRow0Extend_apply, cons_val_zero,
      LinearMap.GeneralLinearGroup.coeFn_generalLinearEquiv, GeneralLinearGroup.coe_toLinear,
      val_planeConformalMatrix, mulVecLin_apply, cons_val_one, head_cons, map_apply, neg_mul,
      Int.cast_sub, Int.cast_mul, neg_sub, of_apply, Fin.mk_zero, Fin.mk_one]
    ring
  ¬∑ rfl
#align modular_group.tendsto_lc_row0 ModularGroup.tendsto_lcRow0

/-- This replaces `(g‚Ä¢z).re = a/c + *` in the standard theory with the following novel identity:
  `g ‚Ä¢ z = (a c + b d) / (c^2 + d^2) + (d z - c) / ((c^2 + d^2) (c z + d))`
  which does not need to be decomposed depending on whether `c = 0`. -/
theorem smul_eq_lcRow0_add {p : Fin 2 ‚Üí ‚Ñ§} (hp : IsCoprime (p 0) (p 1)) (hg : (‚Üë‚Çòg) 1 = p) :
    ‚Üë(g ‚Ä¢ z) =
      (lcRow0 p ‚Üë(g : SL(2, ‚Ñù)) : ‚ÑÇ) / ((p 0 : ‚ÑÇ) ^ 2 + (p 1 : ‚ÑÇ) ^ 2) +
        ((p 1 : ‚ÑÇ) * z - p 0) / (((p 0 : ‚ÑÇ) ^ 2 + (p 1 : ‚ÑÇ) ^ 2) * (p 0 * z + p 1)) := by
  have nonZ1 : (p 0 : ‚ÑÇ) ^ 2 + (p 1 : ‚ÑÇ) ^ 2 ‚â† 0 := mod_cast hp.sq_add_sq_ne_zero
  have : ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p ‚â† 0 := fun h => hp.ne_zero (by ext i; simpa using congr_fun h i)
  have nonZ2 : (p 0 : ‚ÑÇ) * z + p 1 ‚â† 0 := by simpa using linear_ne_zero _ z this
  field_simp [nonZ1, nonZ2, denom_ne_zero, num]
  rw [(by simp :
    (p 1 : ‚ÑÇ) * z - p 0 = (p 1 * z - p 0) * ‚Üë(Matrix.det (‚Üëg : Matrix (Fin 2) (Fin 2) ‚Ñ§)))]
  rw [‚Üê hg, det_fin_two]
  simp only [Int.coe_castRingHom, coe_matrix_coe, Int.cast_mul, ofReal_intCast, map_apply, denom,
    Int.cast_sub, coe_GLPos_coe_GL_coe_matrix, coe'_apply_complex]
  ring
#align modular_group.smul_eq_lc_row0_add ModularGroup.smul_eq_lcRow0_add

theorem tendsto_abs_re_smul {p : Fin 2 ‚Üí ‚Ñ§} (hp : IsCoprime (p 0) (p 1)) :
    Tendsto
      (fun g : { g : SL(2, ‚Ñ§) // (‚Üë‚Çòg) 1 = p } => |((g : SL(2, ‚Ñ§)) ‚Ä¢ z).re|) cofinite atTop := by
  suffices
    Tendsto (fun g : (fun g : SL(2, ‚Ñ§) => (‚Üë‚Çòg) 1) ‚Åª¬π' {p} => ((g : SL(2, ‚Ñ§)) ‚Ä¢ z).re) cofinite
      (cocompact ‚Ñù)
    by exact tendsto_norm_cocompact_atTop.comp this
  have : ((p 0 : ‚Ñù) ^ 2 + (p 1 : ‚Ñù) ^ 2)‚Åª¬π ‚â† 0 := by
    apply inv_ne_zero
    exact mod_cast hp.sq_add_sq_ne_zero
  let f := Homeomorph.mulRight‚ÇÄ _ this
  let ff := Homeomorph.addRight
    (((p 1 : ‚ÑÇ) * z - p 0) / (((p 0 : ‚ÑÇ) ^ 2 + (p 1 : ‚ÑÇ) ^ 2) * (p 0 * z + p 1))).re
  convert (f.trans ff).closedEmbedding.tendsto_cocompact.comp (tendsto_lcRow0 hp) with _ _ g
  change
    ((g : SL(2, ‚Ñ§)) ‚Ä¢ z).re =
      lcRow0 p ‚Üë(‚Üëg : SL(2, ‚Ñù)) / ((p 0 : ‚Ñù) ^ 2 + (p 1 : ‚Ñù) ^ 2) +
        Complex.re (((p 1 : ‚ÑÇ) * z - p 0) / (((p 0 : ‚ÑÇ) ^ 2 + (p 1 : ‚ÑÇ) ^ 2) * (p 0 * z + p 1)))
  exact mod_cast congr_arg Complex.re (smul_eq_lcRow0_add z hp g.2)
#align modular_group.tendsto_abs_re_smul ModularGroup.tendsto_abs_re_smul

end TendstoLemmas

section FundamentalDomain

set_option linter.uppercaseLean3 false

attribute [local simp] UpperHalfPlane.coe_smul re_smul

/-- For `z : ‚Ñç`, there is a `g : SL(2,‚Ñ§)` maximizing `(g‚Ä¢z).im` -/
theorem exists_max_im : ‚àÉ g : SL(2, ‚Ñ§), ‚àÄ g' : SL(2, ‚Ñ§), (g' ‚Ä¢ z).im ‚â§ (g ‚Ä¢ z).im := by
  classical
  let s : Set (Fin 2 ‚Üí ‚Ñ§) := {cd | IsCoprime (cd 0) (cd 1)}
  have hs : s.Nonempty := ‚ü®![1, 1], isCoprime_one_left‚ü©
  obtain ‚ü®p, hp_coprime, hp‚ü© :=
    Filter.Tendsto.exists_within_forall_le hs (tendsto_normSq_coprime_pair z)
  obtain ‚ü®g, -, hg‚ü© := bottom_row_surj hp_coprime
  refine ‚ü®g, fun g' => ?_‚ü©
  rw [ModularGroup.im_smul_eq_div_normSq, ModularGroup.im_smul_eq_div_normSq,
    div_le_div_left]
  ¬∑ simpa [‚Üê hg] using hp ((‚Üë‚Çòg') 1) (bottom_row_coprime g')
  ¬∑ exact z.im_pos
  ¬∑ exact normSq_denom_pos g' z
  ¬∑ exact normSq_denom_pos g z
#align modular_group.exists_max_im ModularGroup.exists_max_im

/-- Given `z : ‚Ñç` and a bottom row `(c,d)`, among the `g : SL(2,‚Ñ§)` with this bottom row, minimize
  `|(g‚Ä¢z).re|`.  -/
theorem exists_row_one_eq_and_min_re {cd : Fin 2 ‚Üí ‚Ñ§} (hcd : IsCoprime (cd 0) (cd 1)) :
    ‚àÉ g : SL(2, ‚Ñ§), (‚Üë‚Çòg) 1 = cd ‚àß ‚àÄ g' : SL(2, ‚Ñ§), (‚Üë‚Çòg) 1 = (‚Üë‚Çòg') 1 ‚Üí
      |(g ‚Ä¢ z).re| ‚â§ |(g' ‚Ä¢ z).re| := by
  haveI : Nonempty { g : SL(2, ‚Ñ§) // (‚Üë‚Çòg) 1 = cd } :=
    let ‚ü®x, hx‚ü© := bottom_row_surj hcd
    ‚ü®‚ü®x, hx.2‚ü©‚ü©
  obtain ‚ü®g, hg‚ü© := Filter.Tendsto.exists_forall_le (tendsto_abs_re_smul z hcd)
  refine ‚ü®g, g.2, ?_‚ü©
  intro g1 hg1
  have : g1 ‚àà (fun g : SL(2, ‚Ñ§) => (‚Üë‚Çòg) 1) ‚Åª¬π' {cd} := by
    rw [Set.mem_preimage, Set.mem_singleton_iff]
    exact Eq.trans hg1.symm (Set.mem_singleton_iff.mp (Set.mem_preimage.mp g.2))
  exact hg ‚ü®g1, this‚ü©
#align modular_group.exists_row_one_eq_and_min_re ModularGroup.exists_row_one_eq_and_min_re

theorem coe_T_zpow_smul_eq {n : ‚Ñ§} : (‚Üë(T ^ n ‚Ä¢ z) : ‚ÑÇ) = z + n := by
  rw [sl_moeb, UpperHalfPlane.coe_smul]
  simp [coe_T_zpow, denom, num, -map_zpow]
#align modular_group.coe_T_zpow_smul_eq ModularGroup.coe_T_zpow_smul_eq

theorem re_T_zpow_smul (n : ‚Ñ§) : (T ^ n ‚Ä¢ z).re = z.re + n := by
  rw [‚Üê coe_re, coe_T_zpow_smul_eq, add_re, intCast_re, coe_re]
#align modular_group.re_T_zpow_smul ModularGroup.re_T_zpow_smul

theorem im_T_zpow_smul (n : ‚Ñ§) : (T ^ n ‚Ä¢ z).im = z.im := by
  rw [‚Üê coe_im, coe_T_zpow_smul_eq, add_im, intCast_im, add_zero, coe_im]
#align modular_group.im_T_zpow_smul ModularGroup.im_T_zpow_smul

theorem re_T_smul : (T ‚Ä¢ z).re = z.re + 1 := by simpa using re_T_zpow_smul z 1
#align modular_group.re_T_smul ModularGroup.re_T_smul

theorem im_T_smul : (T ‚Ä¢ z).im = z.im := by simpa using im_T_zpow_smul z 1
#align modular_group.im_T_smul ModularGroup.im_T_smul

theorem re_T_inv_smul : (T‚Åª¬π ‚Ä¢ z).re = z.re - 1 := by simpa using re_T_zpow_smul z (-1)
#align modular_group.re_T_inv_smul ModularGroup.re_T_inv_smul

theorem im_T_inv_smul : (T‚Åª¬π ‚Ä¢ z).im = z.im := by simpa using im_T_zpow_smul z (-1)
#align modular_group.im_T_inv_smul ModularGroup.im_T_inv_smul

variable {z}

-- If instead we had `g` and `T` of type `PSL(2, ‚Ñ§)`, then we could simply state `g = T^n`.
theorem exists_eq_T_zpow_of_c_eq_zero (hc : (‚Üë‚Çòg) 1 0 = 0) :
    ‚àÉ n : ‚Ñ§, ‚àÄ z : ‚Ñç, g ‚Ä¢ z = T ^ n ‚Ä¢ z := by
  have had := g.det_coe
  replace had : (‚Üë‚Çòg) 0 0 * (‚Üë‚Çòg) 1 1 = 1 := by rw [det_fin_two, hc] at had; linarith
  rcases Int.eq_one_or_neg_one_of_mul_eq_one' had with (‚ü®ha, hd‚ü© | ‚ü®ha, hd‚ü©)
  ¬∑ use (‚Üë‚Çòg) 0 1
    suffices g = T ^ (‚Üë‚Çòg) 0 1 by intro z; conv_lhs => rw [this]
    ext i j; fin_cases i <;> fin_cases j <;>
      simp [ha, hc, hd, coe_T_zpow, show (1 : Fin (0 + 2)) = (1 : Fin 2) from rfl]
  ¬∑ use -((‚Üë‚Çòg) 0 1)
    suffices g = -T ^ (-((‚Üë‚Çòg) 0 1)) by intro z; conv_lhs => rw [this, SL_neg_smul]
    ext i j; fin_cases i <;> fin_cases j <;>
      simp [ha, hc, hd, coe_T_zpow, show (1 : Fin (0 + 2)) = (1 : Fin 2) from rfl]
#align modular_group.exists_eq_T_zpow_of_c_eq_zero ModularGroup.exists_eq_T_zpow_of_c_eq_zero

-- If `c = 1`, then `g` factorises into a product terms involving only `T` and `S`.
theorem g_eq_of_c_eq_one (hc : (‚Üë‚Çòg) 1 0 = 1) : g = T ^ (‚Üë‚Çòg) 0 0 * S * T ^ (‚Üë‚Çòg) 1 1 := by
  have hg := g.det_coe.symm
  replace hg : (‚Üë‚Çòg) 0 1 = (‚Üë‚Çòg) 0 0 * (‚Üë‚Çòg) 1 1 - 1 := by rw [det_fin_two, hc] at hg; linarith
  refine Subtype.ext ?_
  conv_lhs => rw [Matrix.eta_fin_two (‚Üë‚Çòg)]
  rw [hc, hg]
  simp only [coe_mul, coe_T_zpow, coe_S, mul_fin_two]
  congrm !![?_, ?_; ?_, ?_] <;> ring
#align modular_group.g_eq_of_c_eq_one ModularGroup.g_eq_of_c_eq_one

/-- If `1 < |z|`, then `|S ‚Ä¢ z| < 1`. -/
theorem normSq_S_smul_lt_one (h : 1 < normSq z) : normSq ‚Üë(S ‚Ä¢ z) < 1 := by
  simpa [coe_S, num, denom] using (inv_lt_inv z.normSq_pos zero_lt_one).mpr h
#align modular_group.norm_sq_S_smul_lt_one ModularGroup.normSq_S_smul_lt_one

/-- If `|z| < 1`, then applying `S` strictly decreases `im`. -/
theorem im_lt_im_S_smul (h : normSq z < 1) : z.im < (S ‚Ä¢ z).im := by
  have : z.im < z.im / normSq (z : ‚ÑÇ) := by
    have imz : 0 < z.im := im_pos z
    apply (lt_div_iff z.normSq_pos).mpr
    nlinarith
  convert this
  simp only [ModularGroup.im_smul_eq_div_normSq]
  simp [denom, coe_S]
#align modular_group.im_lt_im_S_smul ModularGroup.im_lt_im_S_smul

/-- The standard (closed) fundamental domain of the action of `SL(2,‚Ñ§)` on `‚Ñç`. -/
def fd : Set ‚Ñç :=
  {z | 1 ‚â§ normSq (z : ‚ÑÇ) ‚àß |z.re| ‚â§ (1 : ‚Ñù) / 2}
#align modular_group.fd ModularGroup.fd

/-- The standard open fundamental domain of the action of `SL(2,‚Ñ§)` on `‚Ñç`. -/
def fdo : Set ‚Ñç :=
  {z | 1 < normSq (z : ‚ÑÇ) ‚àß |z.re| < (1 : ‚Ñù) / 2}
#align modular_group.fdo ModularGroup.fdo

@[inherit_doc ModularGroup.fd]
scoped[Modular] notation "ùíü" => ModularGroup.fd

@[inherit_doc ModularGroup.fdo]
scoped[Modular] notation "ùíü·µí" => ModularGroup.fdo

open scoped Modular

theorem abs_two_mul_re_lt_one_of_mem_fdo (h : z ‚àà ùíü·µí) : |2 * z.re| < 1 := by
  rw [abs_mul, abs_two, ‚Üê lt_div_iff' (zero_lt_two' ‚Ñù)]
  exact h.2
#align modular_group.abs_two_mul_re_lt_one_of_mem_fdo ModularGroup.abs_two_mul_re_lt_one_of_mem_fdo

theorem three_lt_four_mul_im_sq_of_mem_fdo (h : z ‚àà ùíü·µí) : 3 < 4 * z.im ^ 2 := by
  have : 1 < z.re * z.re + z.im * z.im := by simpa [Complex.normSq_apply] using h.1
  have := h.2
  cases abs_cases z.re <;> nlinarith
#align modular_group.three_lt_four_mul_im_sq_of_mem_fdo ModularGroup.three_lt_four_mul_im_sq_of_mem_fdo

/-- If `z ‚àà ùíü·µí`, and `n : ‚Ñ§`, then `|z + n| > 1`. -/
theorem one_lt_normSq_T_zpow_smul (hz : z ‚àà ùíü·µí) (n : ‚Ñ§) : 1 < normSq (T ^ n ‚Ä¢ z : ‚Ñç) := by
  have hz‚ÇÅ : 1 < z.re * z.re + z.im * z.im := hz.1
  have hzn := Int.nneg_mul_add_sq_of_abs_le_one n (abs_two_mul_re_lt_one_of_mem_fdo hz).le
  have : 1 < (z.re + ‚Üën) * (z.re + ‚Üën) + z.im * z.im := by linarith
  simpa [coe_T_zpow, normSq, num, denom, -map_zpow]
#align modular_group.one_lt_norm_sq_T_zpow_smul ModularGroup.one_lt_normSq_T_zpow_smul

theorem eq_zero_of_mem_fdo_of_T_zpow_mem_fdo {n : ‚Ñ§} (hz : z ‚àà ùíü·µí) (hg : T ^ n ‚Ä¢ z ‚àà ùíü·µí) :
    n = 0 := by
  suffices |(n : ‚Ñù)| < 1 by
    rwa [‚Üê Int.cast_abs, ‚Üê Int.cast_one, Int.cast_lt, Int.abs_lt_one_iff] at this
  have h‚ÇÅ := hz.2
  have h‚ÇÇ := hg.2
  rw [re_T_zpow_smul] at h‚ÇÇ
  calc
    |(n : ‚Ñù)| ‚â§ |z.re| + |z.re + (n : ‚Ñù)| := abs_add' (n : ‚Ñù) z.re
    _ < 1 / 2 + 1 / 2 := add_lt_add h‚ÇÅ h‚ÇÇ
    _ = 1 := add_halves 1
#align modular_group.eq_zero_of_mem_fdo_of_T_zpow_mem_fdo ModularGroup.eq_zero_of_mem_fdo_of_T_zpow_mem_fdo

/-- First Fundamental Domain Lemma: Any `z : ‚Ñç` can be moved to `ùíü` by an element of
`SL(2,‚Ñ§)` -/
theorem exists_smul_mem_fd (z : ‚Ñç) : ‚àÉ g : SL(2, ‚Ñ§), g ‚Ä¢ z ‚àà ùíü := by
  -- obtain a g‚ÇÄ which maximizes im (g ‚Ä¢ z),
  obtain ‚ü®g‚ÇÄ, hg‚ÇÄ‚ü© := exists_max_im z
  -- then among those, minimize re
  obtain ‚ü®g, hg, hg'‚ü© := exists_row_one_eq_and_min_re z (bottom_row_coprime g‚ÇÄ)
  refine ‚ü®g, ?_‚ü©
  -- `g` has same max im property as `g‚ÇÄ`
  have hg‚ÇÄ' : ‚àÄ g' : SL(2, ‚Ñ§), (g' ‚Ä¢ z).im ‚â§ (g ‚Ä¢ z).im := by
    have hg'' : (g ‚Ä¢ z).im = (g‚ÇÄ ‚Ä¢ z).im := by
      rw [ModularGroup.im_smul_eq_div_normSq, ModularGroup.im_smul_eq_div_normSq,
        denom_apply, denom_apply, hg]
    simpa only [hg''] using hg‚ÇÄ
  constructor
  ¬∑ -- Claim: `1 ‚â§ ‚áënorm_sq ‚Üë(g ‚Ä¢ z)`. If not, then `S‚Ä¢g‚Ä¢z` has larger imaginary part
    contrapose! hg‚ÇÄ'
    refine ‚ü®S * g, ?_‚ü©
    rw [mul_smul]
    exact im_lt_im_S_smul hg‚ÇÄ'
  ¬∑ show |(g ‚Ä¢ z).re| ‚â§ 1 / 2
    -- if not, then either `T` or `T'` decrease |Re|.
    rw [abs_le]
    constructor
    ¬∑ contrapose! hg'
      refine' ‚ü®T * g, (T_mul_apply_one _).symm, _‚ü©
      rw [mul_smul, re_T_smul]
      cases abs_cases ((g ‚Ä¢ z).re + 1) <;> cases abs_cases (g ‚Ä¢ z).re <;> linarith
    ¬∑ contrapose! hg'
      refine' ‚ü®T‚Åª¬π * g, (T_inv_mul_apply_one _).symm, _‚ü©
      rw [mul_smul, re_T_inv_smul]
      cases abs_cases ((g ‚Ä¢ z).re - 1) <;> cases abs_cases (g ‚Ä¢ z).re <;> linarith
#align modular_group.exists_smul_mem_fd ModularGroup.exists_smul_mem_fd

section UniqueRepresentative

/-- An auxiliary result en route to `ModularGroup.c_eq_zero`. -/
theorem abs_c_le_one (hz : z ‚àà ùíü·µí) (hg : g ‚Ä¢ z ‚àà ùíü·µí) : |(‚Üë‚Çòg) 1 0| ‚â§ 1 := by
  let c' : ‚Ñ§ := (‚Üë‚Çòg) 1 0
  let c : ‚Ñù := (c' : ‚Ñù)
  suffices 3 * c ^ 2 < 4 by
    rw [‚Üê Int.cast_pow, ‚Üê Int.cast_three, ‚Üê Int.cast_four, ‚Üê Int.cast_mul, Int.cast_lt] at this
    replace this : c' ^ 2 ‚â§ 1 ^ 2 := by linarith
    rwa [sq_le_sq, abs_one] at this
  suffices c ‚â† 0 ‚Üí 9 * c ^ 4 < 16 by
    rcases eq_or_ne c 0 with (hc | hc)
    ¬∑ rw [hc]; norm_num
    ¬∑ refine' (abs_lt_of_sq_lt_sq' _ (by norm_num)).2
      specialize this hc
      linarith
  intro hc
  replace hc : 0 < c ^ 4 := by
    change 0 < c ^ (2 * 2); rw [pow_mul]; apply sq_pos_of_pos (sq_pos_of_ne_zero hc)
  have h‚ÇÅ :=
    mul_lt_mul_of_pos_right
      (mul_lt_mul'' (three_lt_four_mul_im_sq_of_mem_fdo hg) (three_lt_four_mul_im_sq_of_mem_fdo hz)
        (by linarith) (by linarith))
      hc
  have h‚ÇÇ : (c * z.im) ^ 4 / normSq (denom (‚Üëg) z) ^ 2 ‚â§ 1 :=
    div_le_one_of_le
      (pow_four_le_pow_two_of_pow_two_le (UpperHalfPlane.c_mul_im_sq_le_normSq_denom z g))
      (sq_nonneg _)
  let nsq := normSq (denom g z)
  calc
    9 * c ^ 4 < c ^ 4 * z.im ^ 2 * (g ‚Ä¢ z).im ^ 2 * 16 := by linarith
    _ = c ^ 4 * z.im ^ 4 / nsq ^ 2 * 16 := by
      rw [ModularGroup.im_smul_eq_div_normSq, div_pow]
      ring
    _ ‚â§ 16 := by rw [‚Üê mul_pow]; linarith
#align modular_group.abs_c_le_one ModularGroup.abs_c_le_one

/-- An auxiliary result en route to `ModularGroup.eq_smul_self_of_mem_fdo_mem_fdo`. -/
theorem c_eq_zero (hz : z ‚àà ùíü·µí) (hg : g ‚Ä¢ z ‚àà ùíü·µí) : (‚Üë‚Çòg) 1 0 = 0 := by
  have hp : ‚àÄ {g' : SL(2, ‚Ñ§)}, g' ‚Ä¢ z ‚àà ùíü·µí ‚Üí (‚Üë‚Çòg') 1 0 ‚â† 1 := by
    intro g' hg'
    by_contra hc
    let a := (‚Üë‚Çòg') 0 0
    let d := (‚Üë‚Çòg') 1 1
    have had : T ^ (-a) * g' = S * T ^ d := by rw [g_eq_of_c_eq_one hc]; group
    let w := T ^ (-a) ‚Ä¢ g' ‚Ä¢ z
    have h‚ÇÅ : w = S ‚Ä¢ T ^ d ‚Ä¢ z := by simp only [w, ‚Üê mul_smul, had]
    replace h‚ÇÅ : normSq w < 1 := h‚ÇÅ.symm ‚ñ∏ normSq_S_smul_lt_one (one_lt_normSq_T_zpow_smul hz d)
    have h‚ÇÇ : 1 < normSq w := one_lt_normSq_T_zpow_smul hg' (-a)
    linarith
  have hn : (‚Üë‚Çòg) 1 0 ‚â† -1 := by
    intro hc
    replace hc : (‚Üë‚Çò(-g)) 1 0 = 1 := by simp [‚Üê neg_eq_iff_eq_neg.mpr hc]
    replace hg : -g ‚Ä¢ z ‚àà ùíü·µí := (SL_neg_smul g z).symm ‚ñ∏ hg
    exact hp hg hc
  specialize hp hg
  rcases Int.abs_le_one_iff.mp <| abs_c_le_one hz hg with ‚ü®‚ü© <;> tauto
#align modular_group.c_eq_zero ModularGroup.c_eq_zero

/-- Second Fundamental Domain Lemma: if both `z` and `g ‚Ä¢ z` are in the open domain `ùíü·µí`,
where `z : ‚Ñç` and `g : SL(2,‚Ñ§)`, then `z = g ‚Ä¢ z`. -/
theorem eq_smul_self_of_mem_fdo_mem_fdo (hz : z ‚àà ùíü·µí) (hg : g ‚Ä¢ z ‚àà ùíü·µí) : z = g ‚Ä¢ z := by
  obtain ‚ü®n, hn‚ü© := exists_eq_T_zpow_of_c_eq_zero (c_eq_zero hz hg)
  rw [hn] at hg ‚ä¢
  simp [eq_zero_of_mem_fdo_of_T_zpow_mem_fdo hz hg, one_smul]
#align modular_group.eq_smul_self_of_mem_fdo_mem_fdo ModularGroup.eq_smul_self_of_mem_fdo_mem_fdo

end UniqueRepresentative

end FundamentalDomain

end ModularGroup
