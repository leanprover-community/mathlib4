/-
Copyright (c) 2025 X. Roblot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Xavier Roblot
-/
import Mathlib.NumberTheory.NumberField.InfinitePlace.TotallyRealComplex
import Mathlib.NumberTheory.NumberField.Units.Regulator
import Mathlib.RingTheory.RootsOfUnity.Complex

/-!
# CM-extension of number fields

A CM-extension `K/F` of number fields is an extension where `K` is totally complex, `F` is
totally real and `K` is a quadratic extension of `F`. In this situation, the totally real
subfield `F` is (isomorphic to) the maximal real subfield `K‚Å∫` of `K`.

## Main definitions and results

* `NumberField.IsCMField`: A predicate that says that if a number field is CM, then it is a totally
  complex quadratic extension of its totally real subfield

* `NumberField.CMExtension.equivMaximalRealSubfield`: Any field `F` such that `K/F` is a
  CM-extension is isomorphic to the maximal real subfield `K‚Å∫` of `K`.

* `NumberField.CMExtension.complexConj_eq_self_iff`: all the elements of `K` fixed by the
  complex conjugation come from the maximal real subfield `F`.

* `NumberField.CMExtension.indexRealUnits_eq_one_or_two`: the index of the subgroup of `(ùìû K)À£`
  generated by the real units and the roots of unity is equal to `1` or `2`
  (see `NumberField.IsCMField.indexRealUnits_eq_two_iff` for the computation of this index).

* `NumberField.IsCMField.regulator_div_regulator_eq_two_pow_mul_indexRealUnits_inv`: ratio of
  regulators of `K` and `K‚Å∫`.

* `NumberField.IsCM.ofIsCMExtension`: Assume that there exists `F` such that `K/F` is a
  CM-extension. Then `K` is CM.

* `NumberField.IsCMField.of_isMulCommutative`: A totally complex abelian extension of `‚Ñö` is CM.

## Implementation note

Most results are proved for the case of a CM field, that is `K` is totally complex quadratic
extension of its totally real. These results live in the `NumberField.IsCMField` namespace. Some
results deal with the general case `K/F`, where `K` is totally complex, `F` is totally real and
`K` is a quadratic extension of `F`, and live in the `NumberField.CMExtension` namespace. Note that
results for the general case can be deduced for the CM case by using the isomorphism
`equivMaximalRealSubfield` between `F` and `K‚Å∫` mentioned above.

-/

open NumberField ComplexEmbedding InfinitePlace Algebra

open scoped ComplexConjugate

namespace NumberField

section maximalRealSubfield

/--
A number field `K` is `CM` if `K` is a totally complex quadratic extension of its maximal
real subfield `K‚Å∫`.
-/
class IsCMField (K : Type*) [Field K] [NumberField K] [IsTotallyComplex K] : Prop where
  is_quadratic : IsQuadraticExtension (maximalRealSubfield K) K

namespace IsCMField

open ComplexEmbedding

variable (K : Type*) [Field K] [NumberField K] [IsTotallyComplex K] [IsCMField K]

local notation3 "K‚Å∫" => maximalRealSubfield K

instance isQuadraticExtension : IsQuadraticExtension K‚Å∫ K :=
  IsCMField.is_quadratic

theorem card_infinitePlace_eq_card_infinitePlace :
    Fintype.card (InfinitePlace K‚Å∫) = Fintype.card (InfinitePlace K) := by
  rw [card_eq_nrRealPlaces_add_nrComplexPlaces, card_eq_nrRealPlaces_add_nrComplexPlaces,
    IsTotallyComplex.nrRealPlaces_eq_zero K, IsTotallyReal.nrComplexPlaces_eq_zero, zero_add,
    add_zero, ‚Üê IsTotallyReal.finrank, ‚Üê Nat.mul_left_cancel_iff zero_lt_two,
    ‚Üê IsTotallyComplex.finrank, ‚Üê Module.finrank_mul_finrank ‚Ñö K‚Å∫ K, mul_comm,
    IsQuadraticExtension.finrank_eq_two _ K]

/--
The equiv between the infinite places of `K` and the infinite places of `K‚Å∫` induced by the
restriction to `K‚Å∫`, see `equivInfinitePlace_apply`.
-/
noncomputable def equivInfinitePlace : InfinitePlace K ‚âÉ InfinitePlace K‚Å∫ :=
  Equiv.ofBijective (fun w ‚Ü¶ w.comap (algebraMap K‚Å∫ K))
   <| (Fintype.bijective_iff_surjective_and_card _).mpr
      ‚ü®comap_surjective, (card_infinitePlace_eq_card_infinitePlace K).symm‚ü©

@[simp]
theorem equivInfinitePlace_apply (w : InfinitePlace K) :
    equivInfinitePlace K w = w.comap (algebraMap K‚Å∫ K) := rfl

@[simp]
theorem equivInfinitePlace_symm_apply (w : InfinitePlace K‚Å∫) (x : K‚Å∫) :
    (equivInfinitePlace K).symm w (algebraMap K‚Å∫ K x) = w x := by
  rw [‚Üê comap_apply, ‚Üê equivInfinitePlace_apply, Equiv.apply_symm_apply]

theorem units_rank_eq_units_rank :
    Units.rank K‚Å∫ = Units.rank K := by
  rw [Units.rank, Units.rank, card_infinitePlace_eq_card_infinitePlace K]

theorem exists_isConj (œÜ : K ‚Üí+* ‚ÑÇ) :
    ‚àÉ œÉ : K ‚âÉ‚Çê[K‚Å∫] K, IsConj œÜ œÉ :=
  exists_isConj_of_isRamified <|
    isRamified_iff.mpr ‚ü®IsTotallyComplex.isComplex _, IsTotallyReal.isReal _‚ü©

/--
All the conjugations of a CM-field over its maximal real subfield are the same.
-/
theorem isConj_eq_isConj {œÜ œà : K ‚Üí+* ‚ÑÇ} {œÉ œÑ : K ‚âÉ‚Çê[K‚Å∫] K}
    (hœÜ : IsConj œÜ œÉ) (hœà : IsConj œà œÑ) : œÉ = œÑ := by
  have : Nat.card (K ‚âÉ‚Çê[K‚Å∫] K) = 2 :=
    (IsQuadraticExtension.finrank_eq_two K‚Å∫ K) ‚ñ∏ IsGalois.card_aut_eq_finrank K‚Å∫ K
  rw [Nat.card_eq_two_iff' 1] at this
  exact ExistsUnique.unique this
    ((isConj_ne_one_iff hœÜ).mpr <| IsTotallyComplex.complexEmbedding_not_isReal œÜ)
    ((isConj_ne_one_iff hœà).mpr <| IsTotallyComplex.complexEmbedding_not_isReal œà)

/--
The complex conjugation of the CM-field `K`.
-/
noncomputable def complexConj : K ‚âÉ‚Çê[K‚Å∫] K :=
  (exists_isConj K (Classical.choice (inferInstance : Nonempty _))).choose

/--
The complex conjugation is the conjugation of any complex embedding of a CM-field.
-/
theorem isConj_complexConj (œÜ : K ‚Üí+* ‚ÑÇ) : IsConj œÜ (complexConj K) := by
  obtain ‚ü®œÉ, hœÉ‚ü© := exists_isConj _ œÜ
  have := (exists_isConj K (Classical.choice (inferInstance : Nonempty (K ‚Üí+* ‚ÑÇ)))).choose_spec
  rwa [isConj_eq_isConj K hœÉ this] at hœÉ

@[simp]
theorem complexEmbedding_complexConj (œÜ : K ‚Üí+* ‚ÑÇ) (x : K) :
    œÜ (complexConj K x) = conj (œÜ x) := by
  rw [IsConj.eq (isConj_complexConj K œÜ), RCLike.star_def]

@[simp]
theorem infinitePlace_complexConj (w : InfinitePlace K) (x : K) :
    w (complexConj K x) = w x := by
  rw [‚Üê norm_embedding_eq, complexEmbedding_complexConj, Complex.norm_conj, norm_embedding_eq]

@[simp]
theorem complexConj_apply_apply (x : K) :
    complexConj K (complexConj K x) = x := by
  let œÜ : K ‚Üí+* ‚ÑÇ := Classical.choice (inferInstance : Nonempty _)
  exact isConj_apply_apply (isConj_complexConj K œÜ) x

theorem complexConj_ne_one :
    complexConj K ‚â† (1 : K ‚âÉ‚Çê[K‚Å∫] K) :=
  (isConj_ne_one_iff
    (exists_isConj K (Classical.choice (inferInstance : Nonempty _))).choose_spec).mpr <|
      IsTotallyComplex.complexEmbedding_not_isReal _

@[simp]
theorem complexConj_apply_eq_self (x : K‚Å∫) : complexConj K x = x := AlgEquiv.commutes _ x

/--
The complex conjugation is an automorphism of degree `2`.
-/
theorem orderOf_complexConj :
    orderOf (complexConj K) = 2 :=
  orderOf_eq_prime_iff.mpr ‚ü®by ext; simp, complexConj_ne_one K‚ü©

/--
The complex conjugation generates the Galois group of `K/K‚Å∫`.
-/
theorem zpowers_complexConj_eq_top :
    Subgroup.zpowers (complexConj K) = ‚ä§ := by
  refine Subgroup.eq_top_of_card_eq _ ?_
  rw [Nat.card_zpowers, orderOf_complexConj, IsGalois.card_aut_eq_finrank,
    IsQuadraticExtension.finrank_eq_two]

/--
An element of `K` is fixed by the complex conjugation iff it lies in `K‚Å∫`.
-/
@[simp]
theorem complexConj_eq_self_iff (x : K) :
    complexConj K x = x ‚Üî x ‚àà K‚Å∫ := by
  convert (IntermediateField.mem_fixedField_iff (‚ä§ : Subgroup (K ‚âÉ‚Çê[K‚Å∫] K)) x).symm using 1
  ¬∑ rw [‚Üê zpowers_complexConj_eq_top, Subgroup.forall_mem_zpowers]
    exact (MulAction.mem_fixedBy_zpowers_iff_mem_fixedBy (g := (complexConj K))).symm
  ¬∑ rw [IsGalois.fixedField_top, IntermediateField.mem_bot]
    aesop

protected theorem RingOfIntegers.complexConj_eq_self_iff (x : ùìû K) :
    complexConj K x = x ‚Üî ‚àÉ y : ùìû K‚Å∫, algebraMap (ùìû K‚Å∫) K y = x := by
  rw [complexConj_eq_self_iff]
  refine ‚ü®fun h ‚Ü¶ ?_, fun ‚ü®y, hy‚ü© ‚Ü¶ ?_‚ü©
  ¬∑ have : IsIntegral ‚Ñ§ (‚ü®x, h‚ü© : K‚Å∫) :=
      (isIntegral_algebraMap_iff (FaithfulSMul.algebraMap_injective K‚Å∫ K)).mp x.isIntegral_coe
    refine ‚ü®‚ü®‚ü®x, h‚ü©, this‚ü©, ?_‚ü©
    rw [IsScalarTower.algebraMap_apply (ùìû K‚Å∫) K‚Å∫, RingOfIntegers.map_mk]
    rfl
  ¬∑ rw [‚Üê hy, IsScalarTower.algebraMap_apply (ùìû K‚Å∫) K‚Å∫]
    exact SetLike.coe_mem _

protected theorem Units.complexConj_eq_self_iff (u : (ùìû K)À£) :
    complexConj K u = u ‚Üî ‚àÉ v : (ùìû K‚Å∫)À£, algebraMap (ùìû K‚Å∫) K v = u := by
  rw [RingOfIntegers.complexConj_eq_self_iff, Units.coe_coe]
  refine ‚ü®fun ‚ü®y, hy‚ü© ‚Ü¶ ?_, fun ‚ü®v, hv‚ü© ‚Ü¶ ‚ü®v, by rw [hv]‚ü©‚ü©
  have : IsUnit y := by
    apply IsUnit.of_map (algebraMap (ùìû K‚Å∫) (ùìû K))
    rw [show algebraMap (ùìû K‚Å∫) (ùìû K) y = u by exact RingOfIntegers.ext hy]
    exact u.isUnit
  exact ‚ü®this.unit, by simp [hy]‚ü©

noncomputable instance starRing : StarRing K where
  star := complexConj K
  star_involutive _ := complexConj_apply_apply _ _
  star_mul _ _ := by rw [map_mul, mul_comm]
  star_add _ _ := by rw [map_add]

/--
A variant of the complex conjugation defined as an `AlgEquiv` on the ring of integers.
-/
noncomputable abbrev ringOfIntegersComplexConj : (ùìû K) ‚âÉ‚Çê[ùìû K‚Å∫] (ùìû K) :=
  RingOfIntegers.mapAlgEquiv (complexConj K)

@[simp]
theorem coe_ringOfIntegersComplexConj (x : ùìû K) :
    (ringOfIntegersComplexConj K x : K) = complexConj K x := rfl

theorem ringOfIntegersComplexConj_eq_self_iff (x : ùìû K) :
    ringOfIntegersComplexConj K x = x ‚Üî x ‚àà Set.range (algebraMap (ùìû K‚Å∫) (ùìû K)) := by
  refine ‚ü®fun h ‚Ü¶ ?_, ?_‚ü©
  ¬∑ rw [RingOfIntegers.ext_iff, coe_ringOfIntegersComplexConj,
      RingOfIntegers.complexConj_eq_self_iff] at h
    obtain ‚ü®y, hy‚ü© := h
    exact ‚ü®y, RingOfIntegers.ext_iff.mpr hy‚ü©
  ¬∑ rintro ‚ü®y, rfl‚ü©
    simp

section units

open Units

/--
The complex conjugation as an isomorphism of the units of `K`. -/
noncomputable abbrev unitsComplexConj : (ùìû K)À£ ‚âÉ* (ùìû K)À£ :=
  Units.mapEquiv <| RingOfIntegers.mapRingEquiv (complexConj K).toRingEquiv

/--
The subgroup of `(ùìû K)À£` generated by the units of `K‚Å∫`. These units are exactly the units fixed
by the complex conjugation, see `IsCMField.unitsComplexConj_eq_self_iff`.
-/
def realUnits : Subgroup (ùìû K)À£ := (Units.map (algebraMap (ùìû K‚Å∫) (ùìû K)).toMonoidHom).range

omit [IsTotallyComplex K] [IsCMField K] in
theorem mem_realUnits_iff (u : (ùìû K)À£) :
    u ‚àà realUnits K ‚Üî ‚àÉ v : (ùìû K‚Å∫)À£, algebraMap (ùìû K‚Å∫) (ùìû K) v = u := by
  simp [realUnits, MonoidHom.mem_range, RingHom.toMonoidHom_eq_coe, Units.ext_iff]

theorem unitsComplexConj_eq_self_iff (u : (ùìû K)À£) :
    unitsComplexConj K u = u ‚Üî u ‚àà realUnits K := by
  simp_rw [Units.ext_iff,  mem_realUnits_iff, RingOfIntegers.ext_iff, Units.coe_mapEquiv,
    AlgEquiv.toRingEquiv_eq_coe, RingEquiv.coe_toMulEquiv, RingOfIntegers.mapRingEquiv_apply,
    AlgEquiv.coe_ringEquiv, Units.complexConj_eq_self_iff,
    IsScalarTower.algebraMap_apply (ùìû K‚Å∫) (ùìû K) K]

/--
The image of a root of unity by the complex conjugation is its inverse.
This is the version of `Complex.conj_rootsOfUnity` for CM-fields.
-/
@[simp]
theorem complexConj_torsion (Œ∂ : torsion K) :
    complexConj K (Œ∂.val : K) = (Œ∂.val : K)‚Åª¬π := by
  let œÜ : K ‚Üí+* ‚ÑÇ := Classical.choice (inferInstance : Nonempty _)
  apply œÜ.injective
  rw [complexEmbedding_complexConj, ‚Üê Units.complexEmbedding_apply,
    Complex.conj_rootsOfUnity (n := torsionOrder K), Units.val_inv_eq_inv_val,
    Units.complexEmbedding_apply, map_inv‚ÇÄ]
  exact map_complexEmbedding_torsion K œÜ ‚ñ∏ Subgroup.apply_coe_mem_map _ _ _

theorem unitsComplexConj_torsion (Œ∂ : torsion K) :
    unitsComplexConj K Œ∂ = Œ∂‚Åª¬π := by
  apply coe_injective
  simp

/--
The map `(ùìû K)À£ ‚Üí* torsion K` defined by `u ‚Ü¶ u * (conj u)‚Åª¬π`.
-/
noncomputable def unitsMulComplexConjInv : (ùìû K)À£ ‚Üí* torsion K where
  toFun := fun u ‚Ü¶ ‚ü®u * (unitsComplexConj K u)‚Åª¬π, (mem_torsion K).mpr fun _ ‚Ü¶ by simp‚ü©
  map_one' := by simp
  map_mul' := by
    intro _ _
    rw [MulMemClass.mk_mul_mk, Subtype.mk_eq_mk]
    apply coe_injective
    simp only [map_mul, mul_inv_rev, Units.val_mul, map_units_inv]
    ring

theorem unitsMulComplexConjInv_apply (u : (ùìû K)À£) :
    unitsMulComplexConjInv K u = u * (unitsComplexConj K u)‚Åª¬π := rfl

@[simp]
theorem unitsMulComplexConjInv_apply_torsion (Œ∂ : torsion K) :
    unitsMulComplexConjInv K Œ∂ = Œ∂ ^ 2 :=
  Subtype.eq <| by simp [unitsMulComplexConjInv_apply, unitsComplexConj_torsion, pow_two]

/--
The action of `unitsMulComplexConjInv` of the torsion is the same as the 2-power map.
-/
theorem map_unitsMulComplexConjInv_torsion :
    Subgroup.map (unitsMulComplexConjInv K) (torsion K) = (powMonoidHom 2).range := by
  rw [‚Üê MonoidHom.restrict_range]
  exact congr_arg (MonoidHom.range ¬∑) (MonoidHom.ext fun Œ∂ ‚Ü¶ by simp)

/--
The kernel of `unitsMulComplexConjInv` is the subgroup of real units.
-/
theorem unitsMulComplexConjInv_ker :
    (unitsMulComplexConjInv K).ker = realUnits K := by
  ext
  rw [MonoidHom.mem_ker, Subtype.ext_iff, unitsMulComplexConjInv_apply, OneMemClass.coe_one,
    mul_inv_eq_one, eq_comm, unitsComplexConj_eq_self_iff]

/--
The index of the image of `unitsMulComplexConjInv` divides `2`.
-/
theorem index_unitsMulComplexConjInv_range_dvd :
    (unitsMulComplexConjInv K).range.index ‚à£ 2 := by
  suffices (powMonoidHom 2 : _ ‚Üí* torsion K).range.index = 2 by
    refine this ‚ñ∏ Subgroup.index_dvd_of_le ?_
    rintro _ ‚ü®Œ∂, _, rfl‚ü©
    exact ‚ü®Œ∂, Subtype.ext_iff.mpr (by simp [pow_two])‚ü©
  rw [IsCyclic.index_powMonoidHom_range, Nat.gcd_eq_right_iff_dvd, Nat.card_eq_fintype_card]
  exact Even.two_dvd <| even_torsionOrder K

/--
The index of the subgroup of `(ùìû K)À£` generated by the real units and the roots of unity. This
index is equal to `1` or `2`, see `indexRealUnits_eq_one_or_two` and `indexRealUnits_eq_two_iff`.
-/
noncomputable abbrev indexRealUnits : ‚Ñï := (realUnits K ‚äî torsion K).index

theorem indexRealUnits_mul_eq :
    indexRealUnits K * (unitsMulComplexConjInv K).range.index = 2 := by
  rw [indexRealUnits, sup_comm]
  convert (Subgroup.index_map (torsion K) (unitsMulComplexConjInv K)).symm
  ¬∑ rw [unitsMulComplexConjInv_ker]
  ¬∑ rw [map_unitsMulComplexConjInv_torsion, IsCyclic.index_powMonoidHom_range, Nat.gcd_eq_right]
    rw [Nat.card_eq_fintype_card]
    exact even_iff_two_dvd.mp (even_torsionOrder K)

/--
The index of the subgroup of `(ùìû K)À£` generated by the real units and the roots of unity is
equal to `1` or `2` (see `NumberField.IsCMField.indexRealUnits_eq_two_iff` for the computation
of this index).
-/
theorem indexRealUnits_eq_one_or_two :
    indexRealUnits K = 1 ‚à® indexRealUnits K = 2 := by
  have h‚ÇÅ := indexRealUnits_mul_eq K
  obtain h‚ÇÇ | h‚ÇÇ := (Nat.dvd_prime Nat.prime_two).mp <| index_unitsMulComplexConjInv_range_dvd K
  ¬∑ exact Or.inr <| by rwa [h‚ÇÇ, mul_one] at h‚ÇÅ
  ¬∑ exact Or.inl <| by rwa [h‚ÇÇ, Nat.mul_eq_right two_ne_zero] at h‚ÇÅ

/--
The index of the subgroup of `(ùìû K)À£` generated by the real units and the roots of unity is equal
to `2` iff there exists a unit whose image by `unitsMulComplexConjInv` generates the torsion
subgroup of `K`.
-/
theorem indexRealUnits_eq_two_iff :
    indexRealUnits K = 2 ‚Üî
      ‚àÉ u : (ùìû K)À£, Subgroup.zpowers (unitsMulComplexConjInv K u) = ‚ä§ := by
  suffices (‚àÉ u : (ùìû K)À£, Subgroup.zpowers (unitsMulComplexConjInv K u) = ‚ä§) ‚Üî
      (unitsMulComplexConjInv K).range.index = 1 by
    rw [this]
    have h_eq := indexRealUnits_mul_eq K
    refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
    ¬∑ rwa [h, Nat.mul_eq_left two_ne_zero] at h_eq
    ¬∑ rwa [h, mul_one] at h_eq
  refine ‚ü®fun ‚ü®u, hu‚ü© ‚Ü¶ Subgroup.index_eq_one.mpr (top_le_iff.mp ?_), fun h ‚Ü¶ ?_‚ü©
  ¬∑ refine le_of_eq_of_le ?_ ((Subgroup.zpowers u).map_le_range (unitsMulComplexConjInv K))
    rw [MonoidHom.map_zpowers, ‚Üê hu]
  ¬∑ obtain ‚ü®Œ∂, hŒ∂‚ü© := exists_zpow_surjective (torsion K)
    rw [Subgroup.index_eq_one, MonoidHom.range_eq_top] at h
    obtain ‚ü®u, rfl‚ü© := h Œ∂
    exact ‚ü®u, (Subgroup.eq_top_iff' _).mpr hŒ∂‚ü©

/--
The fundamental system of units of `K‚Å∫` as a family of `(ùìû K)À£`.
-/
noncomputable def realFundSystem : Fin (rank K) ‚Üí (ùìû K)À£ :=
   fun i ‚Ü¶ (Units.map (algebraMap (ùìû K‚Å∫) (ùìû K)).toMonoidHom)
    (fundSystem K‚Å∫ (finCongr (units_rank_eq_units_rank K).symm i))

theorem closure_realFundSystem_sup_torsion :
    Subgroup.closure (Set.range (realFundSystem K)) ‚äî torsion K = realUnits K ‚äî torsion K := by
  have : Subgroup.map (Units.map (algebraMap (ùìû K‚Å∫) (ùìû K))) (torsion K‚Å∫) ‚â§ torsion K := by
    rintro _ ‚ü®x, hx, rfl‚ü©
    exact MonoidHom.isOfFinOrder _ hx
  rw [realUnits, MonoidHom.range_eq_map, ‚Üê closure_fundSystem_sup_torsion_eq_top, Subgroup.map_sup,
    sup_assoc, RingHom.toMonoidHom_eq_coe, sup_eq_right.mpr this, MonoidHom.map_closure]
  congr; ext
  simp [realFundSystem, Equiv.exists_congr_left (finCongr (units_rank_eq_units_rank K).symm)]

open dirichletUnitTheorem in
theorem regOfFamily_realFunSystem :
    regOfFamily (realFundSystem K) = 2 ^ rank K * regulator K‚Å∫ := by
  classical
  let W‚ÇÄ := (equivInfinitePlace K).symm w‚ÇÄ
  let f : {w : InfinitePlace K // w ‚â† W‚ÇÄ} ‚âÉ {w : InfinitePlace K‚Å∫ // w ‚â† w‚ÇÄ} :=
    (equivInfinitePlace K).subtypeEquiv fun w ‚Ü¶ by rw [not_iff_not, Equiv.eq_symm_apply]
  let g := ((finCongr (units_rank_eq_units_rank K).symm).trans (equivFinRank K‚Å∫)).trans f.symm
  rw [show (2 : ‚Ñù) ^ rank K = |‚àè w : {w : InfinitePlace K‚Å∫ // w ‚â† w‚ÇÄ}, 2| by
    rw [Finset.prod_const, abs_pow, abs_of_pos zero_lt_two, ‚Üê units_rank_eq_units_rank K, rank]
    simp]
  rw [regulator_eq_regOfFamily_fundSystem, regOfFamily_eq_det _ W‚ÇÄ g.symm, regOfFamily_eq_det',
    ‚Üê abs_mul, ‚Üê Matrix.det_mul_column, ‚Üê Matrix.det_reindex_self f, Matrix.reindex_apply]
  congr; ext i w
  rw [Matrix.submatrix_apply, Matrix.of_apply, Matrix.of_apply,
    show f.symm w = (equivInfinitePlace K).symm w.1 by rfl,
    show algebraMap (ùìû K) K _ = algebraMap K‚Å∫ K _ by rfl, equivInfinitePlace_symm_apply]
  simp [f, g]

theorem regulator_div_regulator_eq_two_pow_mul_indexRealUnits_inv :
    regulator K / regulator K‚Å∫ = 2 ^ rank K * (indexRealUnits K : ‚Ñù)‚Åª¬π := by
  rw [indexRealUnits, ‚Üê closure_realFundSystem_sup_torsion, ‚Üê regOfFamily_div_regulator
    (realFundSystem K), regOfFamily_realFunSystem, inv_div, ‚Üê mul_div_assoc, mul_div_mul_comm,
    div_self (by positivity), one_mul]

end units

end IsCMField

end maximalRealSubfield

namespace CMExtension

variable (F K : Type*) [Field F] [NumberField F] [IsTotallyReal F] [Field K] [NumberField K]
  [IsTotallyComplex K] [Algebra F K] [IsQuadraticExtension F K]

theorem eq_maximalRealSubfield (E : Subfield K) [IsTotallyReal E] [IsQuadraticExtension E K] :
    E = maximalRealSubfield K := by
  refine le_antisymm (IsTotallyReal.le_maximalRealSubfield E) ?_
  by_contra! h
  have h' : E ‚äî (maximalRealSubfield K) = ‚ä§ := by
    let L : IntermediateField E K := (E ‚äî (maximalRealSubfield K)).toIntermediateField
      (fun x ‚Ü¶ (le_sup_left (a := E)) x.prop)
    have := ((IntermediateField.isSimpleOrder_of_finrank_prime E K
      (IsQuadraticExtension.finrank_eq_two E K ‚ñ∏ Nat.prime_two)).eq_bot_or_eq_top L).resolve_left ?_
    ¬∑ simpa [L] using congr_arg IntermediateField.toSubfield this
    ¬∑ contrapose! h
      rw [‚Üê SetLike.coe_set_eq, Subfield.coe_toIntermediateField] at h
      rw [‚Üê sup_eq_left, ‚Üê SetLike.coe_set_eq, h, IntermediateField.coe_bot]
      aesop
  have : IsTotallyReal K := (h' ‚ñ∏ isTotallyReal_sup).ofRingEquiv Subring.topEquiv
  obtain w : InfinitePlace K := Classical.choice (inferInstance : Nonempty _)
  exact (not_isReal_iff_isComplex.mpr (IsTotallyComplex.isComplex w)) (IsTotallyReal.isReal w)

/--
Any field `F` such that `K/F` is a CM-extension is isomorphic to the maximal real subfield of `K`.
-/
noncomputable def equivMaximalRealSubfield :
    F ‚âÉ+* maximalRealSubfield K :=
  (algebraMap F K).rangeRestrictFieldEquiv.trans (RingEquiv.subfieldCongr (by
    have := IsTotallyReal.ofRingEquiv (algebraMap F K).rangeRestrictFieldEquiv
    have : IsQuadraticExtension (algebraMap F K).fieldRange K :=
    { finrank_eq_two' :=
        (IsQuadraticExtension.finrank_eq_two F K) ‚ñ∏ Algebra.finrank_eq_of_equiv_equiv
          (algebraMap F K).rangeRestrictFieldEquiv.symm (RingEquiv.refl K) (by ext; simp; rfl) }
    exact eq_maximalRealSubfield K (algebraMap F K).fieldRange))

@[simp]
theorem equivMaximalRealSubfield_apply (x : F) :
    equivMaximalRealSubfield F K x = algebraMap F K x := rfl

@[simp]
theorem algebraMap_equivMaximalRealSubfield_symm_apply (x : maximalRealSubfield K) :
    algebraMap F K ((CMExtension.equivMaximalRealSubfield F K).symm x) =
      algebraMap (maximalRealSubfield K) K x := by
  simpa using (equivMaximalRealSubfield_apply F K ((equivMaximalRealSubfield F K).symm x)).symm

include F in
/--
If `K/F` is a CM-extension then `K` is a CM-field.
-/
theorem _root_.NumberField.IsCMField.ofCMExtension :
    IsCMField K where
  is_quadratic := ‚ü®(IsQuadraticExtension.finrank_eq_two F K) ‚ñ∏ finrank_eq_of_equiv_equiv
      (CMExtension.equivMaximalRealSubfield F K).symm (RingEquiv.refl K) (by ext; simp)‚ü©

open IntermediateField in
/--
A totally complex field that has a unique complex conjugation is CM.
-/
theorem _root_.NumberField.IsCMField.of_forall_isConj {œÉ : Gal(K/‚Ñö)}
    (hœÉ : ‚àÄ œÜ : K ‚Üí+* ‚ÑÇ, IsConj œÜ œÉ) : IsCMField K := by
  have : IsTotallyReal (fixedField (Subgroup.zpowers œÉ)) := ‚ü®fun w ‚Ü¶ by
    obtain ‚ü®W, rfl‚ü© := w.comap_surjective (K := K)
    let œÑ := subgroupEquivAlgEquiv _ ‚ü®œÉ, Subgroup.mem_zpowers œÉ‚ü©
    have hœÑ : IsConj W.embedding œÑ := hœÉ _
    simpa [‚Üê isReal_mk_iff, ‚Üê InfinitePlace.comap_mk, mk_embedding] using hœÑ.isReal_comp‚ü©
  have : IsQuadraticExtension (fixedField (Subgroup.zpowers œÉ)) K := ‚ü®by
    let œÜ : K ‚Üí+* ‚ÑÇ := Classical.choice (inferInstance : Nonempty _)
    have hœÉ' : œÉ ‚â† 1 :=
      (isConj_ne_one_iff (hœÉ œÜ)).mpr <| IsTotallyComplex.complexEmbedding_not_isReal œÜ
    rw [finrank_fixedField_eq_card, Nat.card_zpowers, orderOf_isConj_two_of_ne_one (hœÉ œÜ) hœÉ']‚ü©
  exact IsCMField.ofCMExtension (fixedField (Subgroup.zpowers œÉ)) K

/--
A totally complex abelian extension of `‚Ñö` is CM.
-/
instance of_isMulCommutative [IsGalois ‚Ñö K] [IsMulCommutative Gal(K/‚Ñö)] :
    IsCMField K := by
  let œÜ : K ‚Üí+* ‚ÑÇ := Classical.choice (inferInstance : Nonempty _)
  obtain ‚ü®œÉ, hœÉ‚ÇÅ‚ü© : ‚àÉ œÉ : Gal(K/‚Ñö), ComplexEmbedding.IsConj œÜ œÉ :=
    exists_isConj_of_isRamified <|
      isRamified_iff.mpr ‚ü®IsTotallyComplex.isComplex _, IsTotallyReal.isReal _‚ü©
  have hœÉ‚ÇÇ : ‚àÄ (œÜ : K ‚Üí+* ‚ÑÇ), ComplexEmbedding.IsConj œÜ œÉ := by
    intro œà
    obtain ‚ü®ŒΩ, rfl‚ü© := exists_comp_symm_eq_of_comp_eq (k := ‚Ñö) œÜ œà (by ext; simp)
    rw [show œÉ = ŒΩ.symm‚Åª¬π * œÉ * ŒΩ.symm by simp]
    exact hœÉ‚ÇÅ.comp _
  exact IsCMField.of_forall_isConj K hœÉ‚ÇÇ

end CMExtension

end NumberField
