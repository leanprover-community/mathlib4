/-
Copyright (c) 2024 Xavier Roblot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Xavier Roblot
-/
import Mathlib.Algebra.Module.ZLattice.Covolume
import Mathlib.LinearAlgebra.Matrix.Determinant.Misc
import Mathlib.NumberTheory.NumberField.Units.DirichletTheorem

/-!
# Regulator of a number field

We define and prove basic results about the regulator of a number field `K`.

## Main definitions and results

* `NumberField.Units.regOfFamily`: the regulator of a family of units of `K`.

* `NumberField.Units.regulator`: the regulator of the number field `K`.

* `Number.Field.Units.regOfFamily_eq_det`: For any infinite place `w'`, the regulator of the
  family `u` is equal to the absolute value of the determinant of the matrix
  `(mult w * log w (u i)))_i, w` where `w` runs through the infinite places distinct from `w'`.

* `Number.Field.Units.regOfFamily_div_regOfFamily`: Let `u` and `v` be two families of units. Assume
  that the subgroup `U` generated by `u` and `torsion K` is contained in the subgroup `V` generated
  by `v` and `torsion K`. Then the ratio `regOfFamily u / regOfFamily v` is equal to the
  index of `U` inside `V`.

## Tags
number field, units, regulator
-/

open scoped NumberField

noncomputable section

namespace NumberField.Units

variable (K : Type*) [Field K]

open MeasureTheory NumberField.InfinitePlace Module Submodule
  NumberField NumberField.Units.dirichletUnitTheorem

variable [NumberField K]

open scoped Classical in
/--
An `equiv` between `Fin (rank K)`, used to index the family of units, and `{w // w â‰  wâ‚€}`
the index of the `logSpace`.
-/
def equivFinRank : Fin (rank K) â‰ƒ {w : InfinitePlace K // w â‰  wâ‚€} :=
  Fintype.equivOfCardEq <| by
    rw [Fintype.card_subtype_compl, Fintype.card_ofSubsingleton, Fintype.card_fin, rank]

section regOfFamily

open Matrix

variable {K}

/--
A family of units is of maximal rank if its image by `logEmbedding` is linearly independent
over `â„`.
-/
abbrev IsMaxRank (u : Fin (rank K) â†’ (ð“ž K)Ë£) : Prop :=
  LinearIndependent â„ (fun i â†¦ logEmbedding K (Additive.ofMul (u i)))

open scoped Classical in
/--
The images by `logEmbedding` of a family of units of maximal rank form a basis of `logSpace K`.
-/
def basisOfIsMaxRank {u : Fin (rank K) â†’ (ð“ž K)Ë£} (hu : IsMaxRank u) :
    Basis (Fin (rank K)) â„ (logSpace K) :=
  (basisOfPiSpaceOfLinearIndependent
    ((linearIndependent_equiv (equivFinRank K).symm).mpr hu)).reindex (equivFinRank K).symm

@[simp]
theorem basisOfIsMaxRank_apply {u : Fin (rank K) â†’ (ð“ž K)Ë£} (hu : IsMaxRank u) (i : Fin (rank K)) :
    (basisOfIsMaxRank hu) i = logEmbedding K (Additive.ofMul (u i)) := by
  simp [basisOfIsMaxRank, Basis.coe_reindex, Equiv.symm_symm, Function.comp_apply,
    coe_basisOfPiSpaceOfLinearIndependent]

theorem span_basisOfIsMaxRank {u : Fin (rank K) â†’ (ð“ž K)Ë£} (hu : IsMaxRank u) :
    (span â„¤ (Set.range (basisOfIsMaxRank hu))).toAddSubgroup =
      AddSubgroup.map (logEmbedding K) (Subgroup.closure (Set.range u)).toAddSubgroup := by
  rw [Subgroup.toAddSubgroup_closure, AddMonoidHom.map_closure, â† span_int_eq_addSubgroupClosure]
  congr; ext; simp

theorem finiteIndex_iff_sup_torsion_finiteIndex (s : Subgroup (ð“ž K)Ë£) :
    s.FiniteIndex â†” (s âŠ” torsion K).FiniteIndex := by
  refine âŸ¨fun h â†¦ Subgroup.finiteIndex_of_le le_sup_left, fun h â†¦ ?_âŸ©
  rw [Subgroup.finiteIndex_iff, â† Subgroup.relIndex_mul_index (le_sup_left : s â‰¤ s âŠ” torsion K)]
  refine Nat.mul_ne_zero ?_ (Subgroup.finiteIndex_iff.mp h)
  rw [Subgroup.relIndex_sup_left]
  exact Subgroup.FiniteIndex.index_ne_zero

open Subgroup in
/--
A family of units is of maximal rank iff the index of the subgroup it generates has finite index.
-/
theorem isMaxRank_iff_closure_finiteIndex {u : Fin (rank K) â†’ (ð“ž K)Ë£} :
    IsMaxRank u â†” (closure (Set.range u)).FiniteIndex := by
  classical
  have hâ‚ : (closure (Set.range u) âŠ” torsion K).index â‰  0 â†”
      Finite (unitLattice K â§¸ span â„¤ (Set.range ((logEmbeddingEquiv K) âˆ˜ Additive.toMul.symm âˆ˜
        QuotientGroup.mk âˆ˜ u))) := by
    change _ â†” Finite ((unitLattice K).toAddSubgroup â§¸ (span â„¤ (Set.range _)).toAddSubgroup)
    rw [â† AddSubgroup.index_ne_zero_iff_finite]
    have := index_map (closure (Set.range u)) (QuotientGroup.mk' (torsion K))
    rw [QuotientGroup.ker_mk', QuotientGroup.range_mk', index_top, mul_one] at this
    rw [â† this, â† index_toAddSubgroup, â† AddSubgroup.index_map_equiv
      _ (logEmbeddingEquiv K).toAddEquiv, Set.range_comp, â† map_span (logEmbeddingEquiv K),
      â† map_coe_toLinearMap, map_toAddSubgroup, span_int_eq_addSubgroupClosure,
      MonoidHom.map_closure, toAddSubgroup_closure, Set.range_comp, Set.range_comp,
      QuotientGroup.coe_mk', Set.preimage_equiv_eq_image_symm]
    exact Iff.rfl
  have hâ‚‚ : DiscreteTopology
      (span â„¤ (Set.range fun i â†¦ (logEmbedding K) (Additive.ofMul (u i)))) := by
    refine DiscreteTopology.of_subset (inferInstance : DiscreteTopology (unitLattice K)) ?_
    rw [SetLike.coe_subset_coe, Submodule.span_le]
    rintro _ âŸ¨i, rflâŸ©
    exact âŸ¨Additive.ofMul (u i), mem_top, rflâŸ©
  rw [finiteIndex_iff_sup_torsion_finiteIndex, finiteIndex_iff, hâ‚, finiteQuotient_iff,
    unitLattice_rank, â† Set.finrank, IsMaxRank, linearIndependent_iff_card_eq_finrank_span,
    Real.finrank_eq_int_finrank_of_discrete hâ‚‚, Set.finrank, Set.finrank, â† finrank_map_subtype_eq,
    map_span, â† Set.range_comp', eq_comm]
  simp

open scoped Classical in
/--
The regulator of a family of units of `K`.
-/
def regOfFamily (u : Fin (rank K) â†’ (ð“ž K)Ë£) : â„ :=
  if hu : IsMaxRank u then
    ZLattice.covolume (span â„¤ (Set.range (basisOfIsMaxRank hu)))
  else 0

theorem regOfFamily_eq_zero {u : Fin (rank K) â†’ (ð“ž K)Ë£} (hu : Â¬ IsMaxRank u) :
    regOfFamily u = 0 := by
  rw [regOfFamily, dif_neg hu]

open scoped Classical in
theorem regOfFamily_of_isMaxRank {u : Fin (rank K) â†’ (ð“ž K)Ë£} (hu : IsMaxRank u) :
    regOfFamily u = ZLattice.covolume (span â„¤ (Set.range (basisOfIsMaxRank hu))) := by
  rw [regOfFamily, dif_pos hu]

theorem regOfFamily_pos {u : Fin (rank K) â†’ (ð“ž K)Ë£} (hu : IsMaxRank u) :
    0 < regOfFamily u := by
  classical
  rw [regOfFamily_of_isMaxRank hu]
  exact ZLattice.covolume_pos _ volume

theorem regOfFamily_ne_zero {u : Fin (rank K) â†’ (ð“ž K)Ë£} (hu : IsMaxRank u) :
    regOfFamily u â‰  0 := (regOfFamily_pos hu).ne'

theorem regOfFamily_ne_zero_iff {u : Fin (rank K) â†’ (ð“ž K)Ë£} :
    regOfFamily u â‰  0 â†” IsMaxRank u :=
  âŸ¨by simpa using (fun hu â†¦ regOfFamily_eq_zero hu).mt, fun hu â†¦ regOfFamily_ne_zero huâŸ©

open scoped Classical in
theorem regOfFamily_eq_det' (u : Fin (rank K) â†’ (ð“ž K)Ë£) :
    regOfFamily u =
      |(of fun i â†¦ logEmbedding K (Additive.ofMul (u ((equivFinRank K).symm i)))).det| := by
  by_cases hu : IsMaxRank u
  Â· rw [regOfFamily_of_isMaxRank hu, ZLattice.covolume_eq_det _
      (((basisOfIsMaxRank hu).restrictScalars â„¤).reindex (equivFinRank K)), Basis.coe_reindex]
    congr 3 with i
    simp [basisOfIsMaxRank_apply hu]
  Â· rw [regOfFamily_eq_zero hu, det_eq_zero_of_not_linearIndependent_rows, abs_zero]
    rwa [IsMaxRank, â† linearIndependent_equiv (equivFinRank K).symm] at hu

open scoped Classical in
/--
Let `u : Fin (rank K) â†’ (ð“ž K)Ë£` be a family of units and let `wâ‚` and `wâ‚‚` be two infinite
places. Then, the two square matrices with entries `(mult w * log w (u i))_i` where `w â‰  w_j` for
`j = 1, 2` have the same determinant in absolute value.
-/
theorem abs_det_eq_abs_det (u : Fin (rank K) â†’ (ð“ž K)Ë£)
    {wâ‚ wâ‚‚ : InfinitePlace K} (eâ‚ : {w // w â‰  wâ‚} â‰ƒ Fin (rank K))
    (eâ‚‚ : {w // w â‰  wâ‚‚} â‰ƒ Fin (rank K)) :
    |(of fun i w : {w // w â‰  wâ‚} â†¦ (mult w.val : â„) * (w.val (u (eâ‚ i) : K)).log).det| =
    |(of fun i w : {w // w â‰  wâ‚‚} â†¦ (mult w.val : â„) * (w.val (u (eâ‚‚ i) : K)).log).det| := by
  -- We construct an equiv `Fin (rank K + 1) â‰ƒ InfinitePlace K` from `eâ‚‚.symm`
  let f : Fin (rank K + 1) â‰ƒ InfinitePlace K :=
    (finSuccEquiv _).trans ((Equiv.optionSubtype _).symm eâ‚.symm).val
  -- And `g` corresponds to the restriction of `fâ»Â¹` to `{w // w â‰  wâ‚‚}`
  let g : {w // w â‰  wâ‚‚} â‰ƒ Fin (rank K) :=
    (Equiv.subtypeEquiv f.symm (fun _ â†¦ by simp [f])).trans
      (finSuccAboveEquiv (f.symm wâ‚‚)).symm
  have h_col := congr_arg abs <| det_permute (g.trans eâ‚‚.symm)
    (of fun i w : {w // w â‰  wâ‚‚} â†¦ (mult w.val : â„) * (w.val (u (eâ‚‚ i) : K)).log)
  rw [abs_mul, â† Int.cast_abs, Equiv.Perm.sign_abs, Int.cast_one, one_mul] at h_col
  rw [â† h_col]
  have h := congr_arg abs <| submatrix_succAbove_det_eq_negOnePow_submatrix_succAbove_det'
    (of fun i w â†¦ (mult (f w) : â„) * ((f w) (u i)).log) ?_ 0 (f.symm wâ‚‚)
  Â· rw [â† det_reindex_self eâ‚, â† det_reindex_self g]
    Â· rw [Units.smul_def, abs_zsmul, Int.abs_negOnePow, one_smul] at h
      convert h
      Â· ext; simp only [ne_eq, reindex_apply, submatrix_apply, of_apply, Equiv.apply_symm_apply,
          Equiv.trans_apply, Fin.succAbove_zero, id_eq, finSuccEquiv_succ,
          Equiv.optionSubtype_symm_apply_apply_coe, f]
      Â· ext; simp only [ne_eq, Equiv.coe_trans, reindex_apply, submatrix_apply, Function.comp_apply,
          Equiv.apply_symm_apply, id_eq, of_apply]; rfl
  Â· intro _
    simp_rw [of_apply, â† Real.log_pow]
    rw [â† Real.log_prod, Equiv.prod_comp f (fun w â†¦ (w (u _) ^ (mult w))), prod_eq_abs_norm,
      Units.norm, Rat.cast_one, Real.log_one]
    exact fun _ _ â†¦ pow_ne_zero _ <| (map_ne_zero _).mpr (coe_ne_zero _)

open scoped Classical in
/--
For any infinite place `w'`, the regulator of the family `u` is equal to the absolute value of
the determinant of the matrix with entries `(mult w * log w (u i))_i` for `w â‰  w'`.
-/
theorem regOfFamily_eq_det (u : Fin (rank K) â†’ (ð“ž K)Ë£) (w' : InfinitePlace K)
    (e : {w // w â‰  w'} â‰ƒ Fin (rank K)) :
    regOfFamily u =
      |(of fun i w : {w // w â‰  w'} â†¦ (mult w.val : â„) * Real.log (w.val (u (e i) : K))).det| := by
  simp [regOfFamily_eq_det', abs_det_eq_abs_det u e (equivFinRank K).symm, logEmbedding]

open scoped Classical in
/--
The degree of `K` times the regulator of the family `u` is equal to the absolute value of the
determinant of the matrix whose columns are
`(mult w * log w (fundSystem K i))_i, w` and the column `(mult w)_w`.
-/
theorem finrank_mul_regOfFamily_eq_det (u : Fin (rank K) â†’ (ð“ž K)Ë£) (w' : InfinitePlace K)
    (e : {w // w â‰  w'} â‰ƒ Fin (rank K)) :
    finrank â„š K * regOfFamily u =
      |(of (fun i w : InfinitePlace K â†¦
        if h : i = w' then (w.mult : â„) else w.mult * (w (u (e âŸ¨i, hâŸ©))).log)).det| := by
  let f : Fin (rank K + 1) â‰ƒ InfinitePlace K :=
    (finSuccEquiv _).trans ((Equiv.optionSubtype _).symm e.symm).val
  let g : {w // w â‰  w'} â‰ƒ Fin (rank K) :=
    (Equiv.subtypeEquiv f.symm (fun _ â†¦ by simp [f])).trans (finSuccAboveEquiv (f.symm w')).symm
  rw [â† det_reindex_self f.symm, det_eq_sum_row_mul_submatrix_succAbove_succAbove_det _ (f.symm w')
    (f.symm w'), abs_mul, abs_mul, abs_neg_one_pow, one_mul]
  Â· simp_rw [reindex_apply, submatrix_submatrix, â† f.symm.sum_comp, f.symm_symm, submatrix_apply,
      Function.comp_def, Equiv.apply_symm_apply, of_apply, dif_pos, â† Nat.cast_sum, sum_mult_eq,
      Nat.abs_cast]
    rw [regOfFamily_eq_det u w' e, â† Matrix.det_reindex_self g]
    congr with i j
    rw [reindex_apply, submatrix_apply, submatrix_apply, of_apply, of_apply, dif_neg]
    rfl
  Â· simp_rw [Equiv.forall_congr_left f, â† f.symm.sum_comp, reindex_apply, submatrix_apply,
      of_apply, f.symm_symm, f.apply_symm_apply, Finset.sum_dite_irrel, ne_eq,
      EmbeddingLike.apply_eq_iff_eq]
    intro _ h
    rw [dif_neg h, sum_mult_mul_log]

end regOfFamily

section regulator

open scoped Classical in
/-- The regulator of a number field `K`. -/
def regulator : â„ := ZLattice.covolume (unitLattice K)

theorem isMaxRank_fundSystem :
    IsMaxRank (fundSystem K) := by
  classical
  convert ((basisUnitLattice K).ofZLatticeBasis â„ (unitLattice K)).linearIndependent
  rw [logEmbedding_fundSystem, Basis.ofZLatticeBasis_apply]

open scoped Classical in
theorem basisOfIsMaxRank_fundSystem :
    basisOfIsMaxRank (isMaxRank_fundSystem K) = (basisUnitLattice K).ofZLatticeBasis â„ := by
  ext
  rw [Basis.ofZLatticeBasis_apply, basisOfIsMaxRank_apply, logEmbedding_fundSystem]

theorem regulator_eq_regOfFamily_fundSystem :
    regulator K = regOfFamily (fundSystem K) := by
  classical
  rw [regOfFamily_of_isMaxRank (isMaxRank_fundSystem K), regulator,
    â† (basisUnitLattice K).ofZLatticeBasis_span â„, basisOfIsMaxRank_fundSystem]

theorem regulator_pos : 0 < regulator K :=
  regulator_eq_regOfFamily_fundSystem K â–¸ regOfFamily_pos (isMaxRank_fundSystem K)

theorem regulator_ne_zero : regulator K â‰  0 :=
  (regulator_pos K).ne'

open scoped Classical in
theorem regulator_eq_det' :
    regulator K = |(Matrix.of fun i â†¦
      logEmbedding K (Additive.ofMul (fundSystem K ((equivFinRank K).symm i)))).det| := by
  rw [regulator_eq_regOfFamily_fundSystem, regOfFamily_eq_det']

open scoped Classical in
/--
For any infinite place `w'`, the regulator is equal to the absolute value of the determinant
of the matrix with entries `(mult w * log w (fundSystem K i))_i` for `w â‰  w'`.
-/
theorem regulator_eq_det (w' : InfinitePlace K) (e : {w // w â‰  w'} â‰ƒ Fin (rank K)) :
    regulator K =
      |(Matrix.of fun i w : {w // w â‰  w'} â†¦ (mult w.val : â„) *
        Real.log (w.val (fundSystem K (e i) : K))).det| := by
  rw [regulator_eq_regOfFamily_fundSystem, regOfFamily_eq_det]

open scoped Classical in
/--
The degree of `K` times the regulator of `K` is equal to the absolute value of the determinant of
the matrix whose columns are `(mult w * log w (fundSystem K i))_i, w` and the column `(mult w)_w`.
-/
theorem finrank_mul_regulator_eq_det (w' : InfinitePlace K) (e : {w // w â‰  w'} â‰ƒ Fin (rank K)) :
    finrank â„š K * regulator K =
      |(Matrix.of (fun i w : InfinitePlace K â†¦
        if h : i = w' then (w.mult : â„) else w.mult * (w (fundSystem K (e âŸ¨i, hâŸ©))).log)).det| := by
  rw [regulator_eq_regOfFamily_fundSystem, finrank_mul_regOfFamily_eq_det]

end regulator

section index

open ZLattice

variable {K}

/--
Let `u` and `v` be two families of units. Assume that the subgroup `U` generated by `u` and
`torsion K` is contained in the subgroup `V` generated by `v` and `torsion K`. Then the ratio
`regOfFamily u / regOfFamily v` is equal to the index of `U` inside `V`.
-/
theorem regOfFamily_div_regOfFamily {u v : Fin (rank K) â†’ (ð“ž K)Ë£} (hv : IsMaxRank v)
    (h : Subgroup.closure (Set.range u) âŠ” torsion K â‰¤ Subgroup.closure (Set.range v) âŠ” torsion K) :
    regOfFamily u / regOfFamily v = (Subgroup.closure (Set.range u) âŠ” (torsion K)).relIndex
      (Subgroup.closure (Set.range v) âŠ” (torsion K)) := by
  classical
  by_cases hu : IsMaxRank u
  Â· have : span â„¤ (Set.range (basisOfIsMaxRank hu)) â‰¤ span â„¤ (Set.range (basisOfIsMaxRank hv)) := by
      rw [â† toAddSubgroup_le, span_basisOfIsMaxRank hu, span_basisOfIsMaxRank hv,
        â† map_logEmbedding_sup_torsion (Subgroup.closure (Set.range u)).toAddSubgroup,
        â† map_logEmbedding_sup_torsion (Subgroup.closure (Set.range v)).toAddSubgroup,
        â† SupHomClass.map_sup, â† SupHomClass.map_sup]
      exact AddSubgroup.map_mono <| (OrderIso.le_iff_le Subgroup.toAddSubgroup).mpr h
    rw [regOfFamily_of_isMaxRank hu, regOfFamily_of_isMaxRank hv,
      covolume_div_covolume_eq_relIndex _ _ this, span_basisOfIsMaxRank hu,
      span_basisOfIsMaxRank hv, AddSubgroup.relIndex_map_map, logEmbedding_ker,
      â† OrderIso.map_sup, â† OrderIso.map_sup, â† Subgroup.relIndex_toAddSubgroup]
  Â· rw [regOfFamily_eq_zero hu, zero_div, eq_comm, Nat.cast_eq_zero]
    have : (Subgroup.closure (Set.range v) âŠ” torsion K).index â‰  0 := by
      rw [â† Subgroup.finiteIndex_iff, â† finiteIndex_iff_sup_torsion_finiteIndex]
      exact isMaxRank_iff_closure_finiteIndex.mp hv
    rwa [â† mul_eq_zero_iff_right this, Subgroup.relIndex_mul_index h,
      â† Subgroup.not_finiteIndex_iff, â† finiteIndex_iff_sup_torsion_finiteIndex,
      â† isMaxRank_iff_closure_finiteIndex.not]

/--
Let `u` be a family of units. Then the ratio `regOfFamily u / regulator K` is equal to the index
of the subgroup generated by `u` and `torsion K` inside the group of units of `K`.
-/
theorem regOfFamily_div_regulator (u : Fin (rank K) â†’ (ð“ž K)Ë£) :
    regOfFamily u / regulator K = (Subgroup.closure (Set.range u) âŠ” (torsion K)).index := by
  rw [regulator_eq_regOfFamily_fundSystem, regOfFamily_div_regOfFamily (isMaxRank_fundSystem K)
    (by simp only [closure_fundSystem_sup_torsion_eq_top, le_top]),
    closure_fundSystem_sup_torsion_eq_top, Subgroup.relIndex_top_right]

end index

end Units

end NumberField
