/-
Copyright (c) 2025 Xavier Roblot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Xavier Roblot
-/
import Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone

/-!
# Fundamental Cone: set of elements of norm ‚â§ 1

In this file, we study the subset `NormLeOne` of the `fundamentalCone` of elements `x` with
`mixedEmbedding.norm x ‚â§ 1`.

Mainly, we prove that this is bounded, its frontier has volume zero and compute its volume.

## Strategy of proof

The proof is loosely based on the strategy given in [D. Marcus, *Number Fields*][marcus1977number].

1. since `NormLeOne K` is norm-stable, in the sense that
  `normLeOne K = normAtAllPlaces‚Åª¬π' (normAtAllPlaces '' (normLeOne K))`,
  see `normLeOne_eq_primeage_image`, it's enough to study the subset
  `normAtAllPlaces '' (normLeOne K)` of `realSpace K`.

2. A description of `normAtAllPlaces '' (normLeOne K)` is given by `normAtAllPlaces_normLeOne`, it
  is the set of `x : realSpace K`, nonnegative at all places, whose norm is nonzero and `‚â§ 1` and
  such that `logMap x` is in the `fundamentalDomain` of `basisUnitLattice K`.
  Note that, here and elsewhere, we identify `x` with its image in `mixedSpace K` given
  by `mixedSpaceOfRealSpace x`.

3. In order to describe the inverse image in `realSpace K` of the `fundamentalDomain` of
  `basisUnitLattice K`, we define the map `expMap : realSpace K ‚Üí realSpace K` that is, in
  some way, the right inverse of `logMap`, see `logMap_expMap`.

4. Denote by `Œ∑·µ¢` (with `i ‚â† w‚ÇÄ` where `w‚ÇÄ` is the distinguished infinite place,
  see the description of `logSpace` below) the fundamental system of units given by
  `fundSystem` and let `|Œ∑·µ¢|` denote `normAtAllPlaces (mixedEmbedding Œ∑·µ¢))`, that is the vector
  `(w (Œ∑·µ¢))_w` in `realSpace K`. Then, the image of `|Œ∑·µ¢|` by `expMap.symm` form a basis of the
  subspace `{x : realSpace K | ‚àë w, x w = 0}`. We complete by adding the vector `(mult w)_w` to
  get a basis, called `completeBasis`, of `realSpace K`. The basis `completeBasis K` has
  the property that, for `i ‚â† w‚ÇÄ`, the image of `completeBasis K i` by the
  natural restriction map `realSpace K ‚Üí logSpace K` is `basisUnitLattice K`.

5. At this point, we can construct the map `expMapBasis` that plays a crucial part in the proof.
  It is the map that sends `x : realSpace K` to `Real.exp (x w‚ÇÄ) * ‚àè_{i ‚â† w‚ÇÄ} |Œ∑·µ¢| ^ x i`, see
  `expMapBasis_apply'`.

## Spaces and maps

To help understand the proof, we make a list of (almost) all the spaces and maps used and
their connections (as hinted above, we do not mention the map `mixedSpaceOfRealSpace` since we
identify `realSpace K` with its image in `mixedSpace K`).

* `mixedSpace`: the set `({w // IsReal w} ‚Üí ‚Ñù) √ó (w // IsComplex w ‚Üí ‚ÑÇ)` where `w` denote the
  infinite places of `K`.

* `realSpace`: the set `w ‚Üí ‚Ñù` where `w` denote the infinite places of `K`

* `logSpace`: the set `{w // w ‚â† w‚ÇÄ} ‚Üí ‚Ñù` where `w‚ÇÄ` is a distinguished place of `K`. It is the set
  used in the proof of Dirichlet Unit Theorem.

* `mixedEmbedding : K ‚Üí mixedSpace K`: the map that sends `x : K` to `œÜ_w(x)` where, for all
  infinite place `w`, `œÜ_w : K ‚Üí ‚Ñù` or `‚ÑÇ`, resp. if `w` is real or if `w` is complex, denote a
  complex embedding associated to `w`.

* `logEmbedding : (ùìû K)À£ ‚Üí logSpace K`: the map that sends the unit `u : (ùìû K)À£` to
  `(mult w * log (w u))_w` for `w ‚â† w‚ÇÄ`. Its image is `unitLattice K`, a `‚Ñ§`-lattice of
  `logSpace K`, that admits `basisUnitLattice K` as a basis.

* `logMap : mixedSpace K ‚Üí logSpace K`: this map is defined such that it factors `logEmbedding`,
  that is, for `u : (ùìû K)À£`, `logMap (mixedEmbedding x) = logEmbedding x`, and that
  `logMap (c ‚Ä¢ x) = logMap x` for `c ‚â† 0` and `norm x ‚â† 0`. The inverse image of the fundamental
  domain of `basisUnitLattice K` by `logMap` (minus the elements of norm zero) is
  `fundamentalCone K`.

* `expMap : realSpace K ‚Üí realSpace K`: the right inverse of `logMap` in the sense that
  `logMap (expMap x) = (x_w)_{w ‚â† w‚ÇÄ}`.

* `expMapBasis : realSpace K ‚Üí realSpace K`: the map that sends `x : realSpace K` to
  `Real.exp (x w‚ÇÄ) * ‚àè_{i ‚â† w‚ÇÄ} |Œ∑·µ¢| ^ x i` where `|Œ∑·µ¢|` denote the vector of `realSpace K` given
  by `w (Œ∑·µ¢)` and `Œ∑·µ¢` denote the units in `fundSystem K`.

-/

variable (K : Type*) [Field K]

open Finset NumberField NumberField.InfinitePlace NumberField.mixedEmbedding NumberField.Units
  NumberField.Units.dirichletUnitTheorem

namespace NumberField.mixedEmbedding.fundamentalCone

section normAtAllPlaces

variable [NumberField K]

variable {K}

theorem logMap_normAtAllPlaces (x : mixedSpace K) :
    logMap (mixedSpaceOfRealSpace (normAtAllPlaces x)) = logMap x :=
  logMap_eq_of_normAtPlace_eq
    fun w ‚Ü¶ by rw [normAtPlace_mixedSpaceOfRealSpace (normAtPlace_nonneg w x)]

theorem norm_normAtAllPlaces (x : mixedSpace K) :
    mixedEmbedding.norm (mixedSpaceOfRealSpace (normAtAllPlaces x)) = mixedEmbedding.norm x := by
  simp_rw [mixedEmbedding.norm_apply,
    normAtPlace_mixedSpaceOfRealSpace (normAtAllPlaces_nonneg _ _)]

theorem normAtAllPlaces_mem_fundamentalCone_iff {x : mixedSpace K} :
    mixedSpaceOfRealSpace (normAtAllPlaces x) ‚àà fundamentalCone K ‚Üî x ‚àà fundamentalCone K := by
  simp_rw [fundamentalCone, Set.mem_diff, Set.mem_preimage, logMap_normAtAllPlaces,
    Set.mem_setOf_eq, norm_normAtAllPlaces]

end normAtAllPlaces

section normLeOne_def

variable [NumberField K]

/--
The set of elements of the `fundamentalCone` of `norm ‚â§ 1`.
-/
abbrev normLeOne : Set (mixedSpace K) := fundamentalCone K ‚à© {x | mixedEmbedding.norm x ‚â§ 1}

variable {K} in
theorem mem_normLeOne {x : mixedSpace K} :
    x ‚àà normLeOne K ‚Üî x ‚àà fundamentalCone K ‚àß mixedEmbedding.norm x ‚â§ 1 := Set.mem_sep_iff

theorem normLeOne_eq_primeage_image :
    normLeOne K = normAtAllPlaces‚Åª¬π' (normAtAllPlaces '' (normLeOne K)) := by
  refine subset_antisymm (Set.subset_preimage_image _ _) ?_
  rintro x ‚ü®y, hy‚ÇÅ, hy‚ÇÇ‚ü©
  rw [mem_normLeOne, ‚Üê normAtAllPlaces_mem_fundamentalCone_iff, ‚Üê norm_normAtAllPlaces,
    ‚Üê mem_normLeOne] at hy‚ÇÅ ‚ä¢
  rwa [‚Üê hy‚ÇÇ]

open scoped Classical in
theorem normAtAllPlaces_normLeOne :
    normAtAllPlaces '' (normLeOne K) =
    mixedSpaceOfRealSpace‚Åª¬π'
      (logMap‚Åª¬π'
          ZSpan.fundamentalDomain ((basisUnitLattice K).ofZLatticeBasis ‚Ñù (unitLattice K))) ‚à©
      {x | (‚àÄ w, 0 ‚â§ x w)} ‚à©
      {x | mixedEmbedding.norm (mixedSpaceOfRealSpace x) ‚â† 0} ‚à©
      {x | mixedEmbedding.norm (mixedSpaceOfRealSpace x) ‚â§ 1} := by
  ext x
  refine ‚ü®?_, fun ‚ü®‚ü®‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, h‚ÇÉ‚ü©, h‚ÇÑ‚ü© ‚Ü¶ ?_‚ü©
  ¬∑ rintro ‚ü®y, ‚ü®‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, h‚ÇÉ‚ü©, rfl‚ü©
    refine ‚ü®‚ü®‚ü®?_, ?_‚ü©, ?_‚ü©, ?_‚ü©
    ¬∑ rwa [Set.mem_preimage, ‚Üê logMap_normAtAllPlaces] at h‚ÇÅ
    ¬∑ exact fun w ‚Ü¶ normAtPlace_nonneg w y
    ¬∑ rwa [Set.mem_setOf_eq, ‚Üê norm_normAtAllPlaces] at h‚ÇÇ
    ¬∑ rwa [Set.mem_setOf_eq, ‚Üê norm_normAtAllPlaces] at h‚ÇÉ
  ¬∑ exact ‚ü®mixedSpaceOfRealSpace x, ‚ü®‚ü®h‚ÇÅ, h‚ÇÉ‚ü©, h‚ÇÑ‚ü©, normAtAllPlaces_mixedSpaceOfRealSpace h‚ÇÇ‚ü©

end normLeOne_def

noncomputable section expMap

variable {K}

/--
The component of `expMap` at the place `w`.
-/
@[simps]
def expMap_single (w : InfinitePlace K) : PartialHomeomorph ‚Ñù ‚Ñù where
  toFun := fun x ‚Ü¶ Real.exp ((w.mult : ‚Ñù)‚Åª¬π * x)
  invFun := fun x ‚Ü¶ w.mult * Real.log x
  source := Set.univ
  target := Set.Ioi 0
  open_source := isOpen_univ
  open_target := isOpen_Ioi
  map_source' _ _ := Real.exp_pos _
  map_target' _ _ := trivial
  left_inv' _ _ := by simp only [Real.log_exp, mul_inv_cancel_left‚ÇÄ mult_coe_ne_zero]
  right_inv' _ h := by simp only [inv_mul_cancel_left‚ÇÄ mult_coe_ne_zero, Real.exp_log h]
  continuousOn_toFun := (continuousOn_const.mul continuousOn_id).rexp
  continuousOn_invFun := continuousOn_const.mul (Real.continuousOn_log.mono (by aesop))

variable [NumberField K]

/--
The map from `realSpace K ‚Üí realSpace K` whose components is given by `expMap_single`. It is, in
some respect, a right inverse of `logMap`, see `logMap_expMap`.
-/
def expMap : PartialHomeomorph (realSpace K) (realSpace K) :=
  PartialHomeomorph.pi fun w ‚Ü¶ expMap_single w

variable (K)

theorem expMap_source :
    expMap.source = (Set.univ : Set (realSpace K)) := by
  simp_rw [expMap, PartialHomeomorph.pi_toPartialEquiv, PartialEquiv.pi_source, expMap_single,
    Set.pi_univ Set.univ]

theorem expMap_target :
    expMap.target = Set.univ.pi fun (_ : InfinitePlace K) ‚Ü¶ Set.Ioi 0 := by
  simp_rw [expMap, PartialHomeomorph.pi_toPartialEquiv, PartialEquiv.pi_target, expMap_single]

variable {K}

@[simp]
theorem expMap_apply (x : realSpace K) (w : InfinitePlace K) :
    expMap x w = Real.exp ((‚Üëw.mult)‚Åª¬π * x w) := rfl

theorem expMap_pos (x : realSpace K) (w : InfinitePlace K) :
    0 < expMap x w := Real.exp_pos _

theorem expMap_smul (c : ‚Ñù) (x : realSpace K) :
    expMap (c ‚Ä¢ x) = (expMap x) ^ c := by
  ext
  simp [mul_comm c _, ‚Üê mul_assoc, Real.exp_mul]

theorem expMap_add (x y : realSpace K) :
    expMap (x + y) = expMap x * expMap y := by
  ext
  simp [mul_add, Real.exp_add]

theorem expMap_sum {Œπ : Type*} (s : Finset Œπ) (f : Œπ ‚Üí realSpace K) :
    expMap (‚àë i ‚àà s, f i) = ‚àè i ‚àà s, expMap (f i) := by
  ext
  simp [‚Üê Real.exp_sum, ‚Üê mul_sum]

@[simp]
theorem expMap_symm_apply (x : realSpace K) (w : InfinitePlace K) :
    expMap.symm x w = ‚Üëw.mult * Real.log (x w) := rfl

theorem logMap_expMap {x : realSpace K}
    (hx : mixedEmbedding.norm (mixedSpaceOfRealSpace (expMap x)) = 1) :
    logMap (mixedSpaceOfRealSpace (expMap x)) = fun w ‚Ü¶ x w.1 := by
  ext
  rw [logMap, normAtPlace_mixedSpaceOfRealSpace (Real.exp_nonneg _), expMap_apply, Real.log_exp,
    mul_sub, mul_inv_cancel_left‚ÇÄ mult_coe_ne_zero, hx, Real.log_one, zero_mul, mul_zero, sub_zero]

theorem sum_expMap_symm_apply {x : K} (hx : x ‚â† 0) :
    ‚àë w : InfinitePlace K, expMap.symm ((normAtAllPlaces (mixedEmbedding K x))) w =
      Real.log (|Algebra.norm ‚Ñö x| : ‚Ñö) := by
  simp_rw [‚Üê prod_eq_abs_norm, Real.log_prod _ _ (fun _ _ ‚Ü¶ pow_ne_zero _ ((map_ne_zero _).mpr hx)),
    Real.log_pow, expMap_symm_apply, normAtAllPlaces_mixedEmbedding]

end expMap

noncomputable section completeBasis

variable [NumberField K]

variable {K}

open scoped Classical in
/--
A fixed equiv between `Fin (rank K)` and `{w : InfinitePlace K // w ‚â† w‚ÇÄ}`.
-/
def equivFinRank : Fin (rank K) ‚âÉ {w : InfinitePlace K // w ‚â† w‚ÇÄ} :=
  Fintype.equivOfCardEq <| by
    rw [Fintype.card_subtype_compl, Fintype.card_ofSubsingleton, Fintype.card_fin, rank]

open scoped Classical in
variable (K) in
/--
A family of elements in the `realSpace K` formed of the image of the fundamental units
and the vector `(mult w)_w`. This family is in fact a basis of `realSpace K`, see `completeBasis`.
-/
def completeFamily : InfinitePlace K ‚Üí realSpace K :=
  fun i ‚Ü¶ if hi : i = w‚ÇÄ then fun w ‚Ü¶ mult w else
    expMap.symm <| normAtAllPlaces <| mixedEmbedding K <| fundSystem K <| equivFinRank.symm ‚ü®i, hi‚ü©

/--
An auxiliary map from `realSpace K` to `logSpace K` used to prove that `completeFamily` is
linearly independent, see `linearIndependent_completeFamily`.
-/
def realSpaceToLogSpace : realSpace K ‚Üí‚Çó[‚Ñù] {w : InfinitePlace K // w ‚â† w‚ÇÄ} ‚Üí ‚Ñù where
  toFun := fun x w ‚Ü¶ x w.1 - w.1.mult * (‚àë w', x w') * (Module.finrank ‚Ñö K : ‚Ñù)‚Åª¬π
  map_add' := fun _ _ ‚Ü¶ funext fun _ ‚Ü¶ by simpa [sum_add_distrib] using by ring
  map_smul' := fun _ _ ‚Ü¶ funext fun _ ‚Ü¶ by simpa [‚Üê mul_sum] using by ring

theorem realSpaceToLogSpace_apply (x :realSpace K) (w : {w : InfinitePlace K // w ‚â† w‚ÇÄ}) :
    realSpaceToLogSpace x w = x w - w.1.mult * (‚àë w', x w') * (Module.finrank ‚Ñö K : ‚Ñù)‚Åª¬π := rfl

theorem realSpaceToLogSpace_expMap_symm {x : K} (hx : x ‚â† 0) :
    realSpaceToLogSpace (expMap.symm (normAtAllPlaces (mixedEmbedding K x))) =
      logMap (mixedEmbedding K x) := by
  ext w
  simp_rw [realSpaceToLogSpace_apply, sum_expMap_symm_apply hx, expMap_symm_apply,
    logMap, normAtPlace_apply, mul_sub, mul_assoc, norm_eq_norm]

theorem realSpaceToLogSpace_completeFamily_of_eq :
    realSpaceToLogSpace (completeFamily K w‚ÇÄ) = 0 := by
  ext
  rw [realSpaceToLogSpace_apply, completeFamily, dif_pos rfl, ‚Üê Nat.cast_sum, sum_mult_eq,
    mul_inv_cancel_right‚ÇÄ (Nat.cast_ne_zero.mpr Module.finrank_pos.ne'), sub_self, Pi.zero_apply]

theorem realSpaceToLogSpace_completeFamily_of_ne (i : {w : InfinitePlace K // w ‚â† w‚ÇÄ}) :
    realSpaceToLogSpace (completeFamily K i) = basisUnitLattice K (equivFinRank.symm i) := by
  ext
  rw [‚Üê logEmbedding_fundSystem, ‚Üê logMap_eq_logEmbedding, completeFamily, dif_neg,
    realSpaceToLogSpace_expMap_symm]
  exact coe_ne_zero _

theorem sum_eq_zero_of_mem_span_completeFamily {x : realSpace K}
    (hx : x ‚àà Submodule.span ‚Ñù (Set.range fun w : {w // w ‚â† w‚ÇÄ} ‚Ü¶ completeFamily K w.1)) :
    ‚àë w, x w = 0 := by
  induction hx using Submodule.span_induction with
  | mem _ h =>
      obtain ‚ü®w, rfl‚ü© := h
      simp_rw [completeFamily,  dif_neg w.prop, sum_expMap_symm_apply (coe_ne_zero _),
        Units.norm, Rat.cast_one, Real.log_one]
  | zero => simp
  | add _ _ _ _ hx hy => simp [sum_add_distrib, hx, hy]
  | smul _ _ _ hx => simp [‚Üê mul_sum, hx]

variable (K)

theorem linearIndependent_completeFamily :
    LinearIndependent ‚Ñù (completeFamily K) := by
  classical
  have h‚ÇÅ : LinearIndependent ‚Ñù (fun w : {w // w ‚â† w‚ÇÄ} ‚Ü¶ completeFamily K w.1) := by
    refine LinearIndependent.of_comp realSpaceToLogSpace ?_
    simp_rw [Function.comp_def, realSpaceToLogSpace_completeFamily_of_ne]
    convert (((basisUnitLattice K).ofZLatticeBasis ‚Ñù _).reindex equivFinRank).linearIndependent
    simp
  have h‚ÇÇ : completeFamily K w‚ÇÄ ‚àâ Submodule.span ‚Ñù
      (Set.range (fun w : {w // w ‚â† w‚ÇÄ} ‚Ü¶ completeFamily K w.1)) := by
    intro h
    have := sum_eq_zero_of_mem_span_completeFamily h
    rw [completeFamily, dif_pos rfl, ‚Üê Nat.cast_sum, sum_mult_eq, Nat.cast_eq_zero] at this
    exact Module.finrank_pos.ne' this
  rw [‚Üê linearIndependent_equiv (Equiv.optionSubtypeNe w‚ÇÄ), linearIndependent_option]
  exact ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©

/--
A basis of `realSpace K` formed by the image of the fundamental units
(which form a basis of a subspace `{x : realSpace K | ‚àë w, x w = 0}`) and the vector `(mult w)_w`.
For `i ‚â† w‚ÇÄ`, the image of `completeBasis K i` by the natural restriction map
`realSpace K ‚Üí logSpace K` is `basisUnitLattice K`
-/
def completeBasis : Basis (InfinitePlace K) ‚Ñù (realSpace K) :=
  basisOfLinearIndependentOfCardEqFinrank (linearIndependent_completeFamily K)
    (Module.finrank_fintype_fun_eq_card _).symm

theorem completeBasis_apply_of_eq :
    completeBasis K w‚ÇÄ = fun w ‚Ü¶ (mult w : ‚Ñù) := by
  rw [completeBasis, coe_basisOfLinearIndependentOfCardEqFinrank, completeFamily, dif_pos rfl]

theorem completeBasis_apply_of_ne (i : {w : InfinitePlace K // w ‚â† w‚ÇÄ}) :
    completeBasis K i =
      expMap.symm (normAtAllPlaces (mixedEmbedding K (fundSystem K (equivFinRank.symm i)))) := by
  rw [completeBasis, coe_basisOfLinearIndependentOfCardEqFinrank, completeFamily, dif_neg]

theorem expMap_basis_of_eq :
    expMap (completeBasis K w‚ÇÄ) = fun _ ‚Ü¶ Real.exp 1 := by
  ext
  simp_rw [expMap_apply, completeBasis_apply_of_eq, inv_mul_cancel‚ÇÄ mult_coe_ne_zero]

theorem expMap_basis_of_ne (i : {w : InfinitePlace K // w ‚â† w‚ÇÄ}) :
    expMap (completeBasis K i) =
      normAtAllPlaces (mixedEmbedding K (fundSystem K (equivFinRank.symm i))) := by
  rw [completeBasis_apply_of_ne, PartialHomeomorph.right_inv _
    (by simp [expMap_target, pos_at_place])]

end completeBasis

noncomputable section expMapBasis

variable [NumberField K]

variable {K}

/--
The map that sends `x : realSpace K` to
`Real.exp (x w‚ÇÄ) * ‚àè_{i ‚â† w‚ÇÄ} |Œ∑·µ¢| ^ x i` where `|Œ∑·µ¢|` denote the vector of `realSpace K` given
by `w (Œ∑·µ¢)` and `Œ∑·µ¢` denote the units in `fundSystem K`, see `expMapBasis_apply'`.
-/
def expMapBasis : PartialHomeomorph (realSpace K) (realSpace K) :=
  (completeBasis K).equivFunL.symm.toHomeomorph.transPartialHomeomorph expMap

variable (K)

theorem expMapBasis_source :
    expMapBasis.source = (Set.univ : Set (realSpace K)) := by
  simp [expMapBasis, expMap_source]

variable {K}

theorem expMapBasis_pos (x : realSpace K) (w : InfinitePlace K) :
    0 < expMapBasis x w := expMap_pos _ _

theorem expMapBasis_nonneg (x : realSpace K) (w : InfinitePlace K) :
    0 ‚â§ expMapBasis x w := (expMapBasis_pos _ _).le

theorem expMapBasis_apply (x : realSpace K) :
    expMapBasis x = expMap ((completeBasis K).equivFun.symm x) := rfl

open scoped Classical in
theorem expMapBasis_apply' (x : realSpace K) :
    expMapBasis x = Real.exp (x w‚ÇÄ) ‚Ä¢
      fun w : InfinitePlace K ‚Ü¶
         ‚àè i : {w // w ‚â† w‚ÇÄ}, w (fundSystem K (equivFinRank.symm i)) ^ x i := by
  simp_rw [expMapBasis_apply, Basis.equivFun_symm_apply, Fintype.sum_eq_add_sum_subtype_ne _ w‚ÇÄ,
    expMap_add, expMap_smul, expMap_basis_of_eq, Pi.pow_def, Real.exp_one_rpow, Pi.mul_def,
    expMap_sum, expMap_smul, expMap_basis_of_ne, Pi.smul_def, smul_eq_mul, prod_apply, Pi.pow_apply,
    normAtAllPlaces_mixedEmbedding]

end expMapBasis

end NumberField.mixedEmbedding.fundamentalCone
