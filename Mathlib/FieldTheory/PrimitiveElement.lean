/-
Copyright (c) 2020 Thomas Browning, Patrick Lutz. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Thomas Browning, Patrick Lutz
-/
import Mathlib.FieldTheory.SplittingField.Construction
import Mathlib.FieldTheory.IsAlgClosed.Basic
import Mathlib.FieldTheory.Separable
import Mathlib.RingTheory.IntegralDomain

#align_import field_theory.primitive_element from "leanprover-community/mathlib"@"df76f43357840485b9d04ed5dee5ab115d420e87"

/-!
# Primitive Element Theorem

In this file we prove the primitive element theorem.

## Main results

- `exists_primitive_element`: a finite separable extension `E / F` has a primitive element, i.e.
  there is an `α : E` such that `F⟮α⟯ = (⊤ : Subalgebra F E)`.

- `exists_primitive_element_iff_finite_intermediateField`: a finite extension `E / F` has a
  primitive element if and only if the intermediate fields between `E / F` are finitely many.

## Implementation notes

In declaration names, `primitive_element` abbreviates `adjoin_simple_eq_top`:
it stands for the statement `F⟮α⟯ = (⊤ : Subalgebra F E)`. We did not add an extra
declaration `IsPrimitiveElement F α := F⟮α⟯ = (⊤ : Subalgebra F E)` because this
requires more unfolding without much obvious benefit.

## Tags

primitive element, separable field extension, separable extension, intermediate field, adjoin,
exists_adjoin_simple_eq_top

-/


noncomputable section

open scoped Classical Polynomial

open FiniteDimensional Polynomial IntermediateField

namespace Field

section PrimitiveElementFinite

variable (F : Type*) [Field F] (E : Type*) [Field E] [Algebra F E]

/-! ### Primitive element theorem for finite fields -/


/-- **Primitive element theorem** assuming E is finite. -/
theorem exists_primitive_element_of_finite_top [Finite E] : ∃ α : E, F⟮α⟯ = ⊤ := by
  obtain ⟨α, hα⟩ := @IsCyclic.exists_generator (Units E) _ _
  use α
  apply eq_top_iff.mpr
  rintro x -
  by_cases hx : x = 0
  · rw [hx]
    exact F⟮α.val⟯.zero_mem
  · obtain ⟨n, hn⟩ := Set.mem_range.mp (hα (Units.mk0 x hx))
    simp only at hn
    rw [show x = α ^ n by norm_cast; rw [hn, Units.val_mk0], Units.val_zpow_eq_zpow_val]
    exact zpow_mem (mem_adjoin_simple_self F (E := E) ↑α) n
#align field.exists_primitive_element_of_finite_top Field.exists_primitive_element_of_finite_top

/-- Primitive element theorem for finite dimensional extension of a finite field. -/
theorem exists_primitive_element_of_finite_bot [Finite F] [FiniteDimensional F E] :
    ∃ α : E, F⟮α⟯ = ⊤ :=
  haveI : Finite E := finite_of_finite F E
  exists_primitive_element_of_finite_top F E
#align field.exists_primitive_element_of_finite_bot Field.exists_primitive_element_of_finite_bot

end PrimitiveElementFinite

/-! ### Primitive element theorem for infinite fields -/


section PrimitiveElementInf

variable {F : Type*} [Field F] [Infinite F] {E : Type*} [Field E] (ϕ : F →+* E) (α β : E)

theorem primitive_element_inf_aux_exists_c (f g : F[X]) :
    ∃ c : F, ∀ α' ∈ (f.map ϕ).roots, ∀ β' ∈ (g.map ϕ).roots, -(α' - α) / (β' - β) ≠ ϕ c := by
  let sf := (f.map ϕ).roots
  let sg := (g.map ϕ).roots
  let s := (sf.bind fun α' => sg.map fun β' => -(α' - α) / (β' - β)).toFinset
  let s' := s.preimage ϕ fun x _ y _ h => ϕ.injective h
  obtain ⟨c, hc⟩ := Infinite.exists_not_mem_finset s'
  simp_rw [Finset.mem_preimage, Multiset.mem_toFinset, Multiset.mem_bind, Multiset.mem_map] at hc
  push_neg at hc
  exact ⟨c, hc⟩
#align field.primitive_element_inf_aux_exists_c Field.primitive_element_inf_aux_exists_c

variable (F)

variable [Algebra F E]

/-- This is the heart of the proof of the primitive element theorem. It shows that if `F` is
infinite and `α` and `β` are separable over `F` then `F⟮α, β⟯` is generated by a single element. -/
theorem primitive_element_inf_aux [IsSeparable F E] : ∃ γ : E, F⟮α, β⟯ = F⟮γ⟯ := by
  have hα := IsSeparable.isIntegral F α
  have hβ := IsSeparable.isIntegral F β
  let f := minpoly F α
  let g := minpoly F β
  let ιFE := algebraMap F E
  let ιEE' := algebraMap E (SplittingField (g.map ιFE))
  obtain ⟨c, hc⟩ := primitive_element_inf_aux_exists_c (ιEE'.comp ιFE) (ιEE' α) (ιEE' β) f g
  let γ := α + c • β
  suffices β_in_Fγ : β ∈ F⟮γ⟯
  · use γ
    apply le_antisymm
    · rw [adjoin_le_iff]
      have α_in_Fγ : α ∈ F⟮γ⟯ := by
        rw [← add_sub_cancel α (c • β)]
        exact F⟮γ⟯.sub_mem (mem_adjoin_simple_self F γ) (F⟮γ⟯.toSubalgebra.smul_mem β_in_Fγ c)
      exact fun x hx => by
        -- Porting note: was `by cases hx <;> cases hx <;> cases hx <;> assumption`
        cases' hx with hx hx
        · rwa [← hx] at α_in_Fγ
        · cases hx; norm_cast
    · rw [adjoin_simple_le_iff]
      have α_in_Fαβ : α ∈ F⟮α, β⟯ := subset_adjoin F {α, β} (Set.mem_insert α {β})
      have β_in_Fαβ : β ∈ F⟮α, β⟯ := subset_adjoin F {α, β} (Set.mem_insert_of_mem α rfl)
      exact F⟮α, β⟯.add_mem α_in_Fαβ (F⟮α, β⟯.smul_mem β_in_Fαβ)
  let p := EuclideanDomain.gcd ((f.map (algebraMap F F⟮γ⟯)).comp
    (C (AdjoinSimple.gen F γ) - (C ↑c : F⟮γ⟯[X]) * X)) (g.map (algebraMap F F⟮γ⟯))
  let h := EuclideanDomain.gcd ((f.map ιFE).comp (C γ - C (ιFE c) * X)) (g.map ιFE)
  have map_g_ne_zero : g.map ιFE ≠ 0 := map_ne_zero (minpoly.ne_zero hβ)
  have h_ne_zero : h ≠ 0 :=
    mt EuclideanDomain.gcd_eq_zero_iff.mp (not_and.mpr fun _ => map_g_ne_zero)
  suffices p_linear : p.map (algebraMap F⟮γ⟯ E) = C h.leadingCoeff * (X - C β)
  · have finale : β = algebraMap F⟮γ⟯ E (-p.coeff 0 / p.coeff 1) := by
      rw [map_div₀, RingHom.map_neg, ← coeff_map, ← coeff_map, p_linear]
      -- Porting note: had to add `-map_add` to avoid going in the wrong direction.
      simp [mul_sub, coeff_C, mul_div_cancel_left β (mt leadingCoeff_eq_zero.mp h_ne_zero),
        -map_add]
      -- Porting note: an alternative solution is:
      -- simp_rw [Polynomial.coeff_C_mul, Polynomial.coeff_sub, mul_sub,
      --   Polynomial.coeff_X_zero, Polynomial.coeff_X_one, mul_zero, mul_one, zero_sub, neg_neg,
      --   Polynomial.coeff_C, eq_self_iff_true, Nat.one_ne_zero, if_true, if_false, mul_zero,
      --   sub_zero, mul_div_cancel_left β (mt leadingCoeff_eq_zero.mp h_ne_zero)]
    rw [finale]
    exact Subtype.mem (-p.coeff 0 / p.coeff 1)
  have h_sep : h.Separable := separable_gcd_right _ (IsSeparable.separable F β).map
  have h_root : h.eval β = 0 := by
    apply eval_gcd_eq_zero
    · rw [eval_comp, eval_sub, eval_mul, eval_C, eval_C, eval_X, eval_map, ← aeval_def, ←
        Algebra.smul_def, add_sub_cancel, minpoly.aeval]
    · rw [eval_map, ← aeval_def, minpoly.aeval]
  have h_splits : Splits ιEE' h :=
    splits_of_splits_gcd_right ιEE' map_g_ne_zero (SplittingField.splits _)
  have h_roots : ∀ x ∈ (h.map ιEE').roots, x = ιEE' β := by
    intro x hx
    rw [mem_roots_map h_ne_zero] at hx
    specialize hc (ιEE' γ - ιEE' (ιFE c) * x) (by
      have f_root := root_left_of_root_gcd hx
      rw [eval₂_comp, eval₂_sub, eval₂_mul, eval₂_C, eval₂_C, eval₂_X, eval₂_map] at f_root
      exact (mem_roots_map (minpoly.ne_zero hα)).mpr f_root)
    specialize hc x (by
      rw [mem_roots_map (minpoly.ne_zero hβ), ← eval₂_map]
      exact root_right_of_root_gcd hx)
    by_contra a
    apply hc
    apply (div_eq_iff (sub_ne_zero.mpr a)).mpr
    simp only [Algebra.smul_def, RingHom.map_add, RingHom.map_mul, RingHom.comp_apply]
    ring
  rw [← eq_X_sub_C_of_separable_of_root_eq h_sep h_root h_splits h_roots]
  trans EuclideanDomain.gcd (?_ : E[X]) (?_ : E[X])
  · dsimp only
    convert (gcd_map (algebraMap F⟮γ⟯ E)).symm
  · simp only [map_comp, Polynomial.map_map, ← IsScalarTower.algebraMap_eq, Polynomial.map_sub,
      map_C, AdjoinSimple.algebraMap_gen, map_add, Polynomial.map_mul, map_X]
    congr
#align field.primitive_element_inf_aux Field.primitive_element_inf_aux

/-- If `F` is infinite and `E/F` has only finitely many intermediate fields, then for any
`α` and `β` in `E`, `F⟮α, β⟯` is generated by a single element. -/
theorem primitive_element_inf_aux_of_finite_intermediateField
    [Finite (IntermediateField F E)] : ∃ γ : E, F⟮α, β⟯ = F⟮γ⟯ := by
  let f : F → IntermediateField F E := fun x => F⟮α + x • β⟯
  obtain ⟨K, hinf⟩ := Finite.exists_infinite_fiber f
  replace hinf : Nontrivial (Set.preimage f {K}) := inferInstance
  obtain ⟨x, y, hneq⟩ := hinf.exists_pair_ne
  replace hneq : (x : F) ≠ (y : F) := fun h => hneq (SetCoe.ext h)
  have hx : f x = K := Set.mem_singleton_iff.1 $ Set.mem_preimage.1 $ Subtype.mem x
  have hy : f y = K := Set.mem_singleton_iff.1 $ Set.mem_preimage.1 $ Subtype.mem y
  simp only at hx
  simp only at hy
  use α + (x : F) • β
  apply le_antisymm
  · rw [hx, adjoin_le_iff]
    have αxβ_in_K : α + (x : F) • β ∈ F⟮α + (x : F) • β⟯ := mem_adjoin_simple_self F _
    have αyβ_in_K : α + (y : F) • β ∈ F⟮α + (y : F) • β⟯ := mem_adjoin_simple_self F _
    rw [hx] at αxβ_in_K
    rw [hy] at αyβ_in_K
    have β_in_K := K.sub_mem αxβ_in_K αyβ_in_K
    rw [show (α + (x : F) • β) - (α + (y : F) • β) = ((x : F) - (y : F)) • β by
      rw [sub_smul]
      abel1] at β_in_K
    replace β_in_K := K.smul_mem β_in_K (x := ((x : F) - (y : F))⁻¹)
    rw [smul_smul, inv_mul_eq_div, div_self (sub_ne_zero.2 hneq), one_smul] at β_in_K
    have α_in_K : α ∈ K := by
      rw [← add_sub_cancel α ((x : F) • β)]
      exact K.sub_mem αxβ_in_K (K.smul_mem β_in_K (x := (x : F)))
    exact fun x hx => by
      cases' hx with hx hx
      · rwa [← hx] at α_in_K
      · cases hx; norm_cast
  · rw [adjoin_simple_le_iff]
    have α_in_Fαβ : α ∈ F⟮α, β⟯ := subset_adjoin F {α, β} (Set.mem_insert α {β})
    have β_in_Fαβ : β ∈ F⟮α, β⟯ := subset_adjoin F {α, β} (Set.mem_insert_of_mem α rfl)
    exact F⟮α, β⟯.add_mem α_in_Fαβ (F⟮α, β⟯.smul_mem β_in_Fαβ)

end PrimitiveElementInf

variable (F E : Type*) [Field F] [Field E]

variable [Algebra F E] [FiniteDimensional F E]

section SeparableAssumption

variable [IsSeparable F E]

/-- **Primitive element theorem**: a finite separable field extension `E` of `F` has a
  primitive element, i.e. there is an `α ∈ E` such that `F⟮α⟯ = (⊤ : Subalgebra F E)`. -/
theorem exists_primitive_element : ∃ α : E, F⟮α⟯ = ⊤ := by
  rcases isEmpty_or_nonempty (Fintype F) with (F_inf | ⟨⟨F_finite⟩⟩)
  · let P : IntermediateField F E → Prop := fun K => ∃ α : E, F⟮α⟯ = K
    have base : P ⊥ := ⟨0, adjoin_zero⟩
    have ih : ∀ (K : IntermediateField F E) (x : E), P K → P (K⟮x⟯.restrictScalars F) := by
      intro K β hK
      cases' hK with α hK
      rw [← hK, adjoin_simple_adjoin_simple]
      haveI : Infinite F := isEmpty_fintype.mp F_inf
      cases' primitive_element_inf_aux F α β with γ hγ
      exact ⟨γ, hγ.symm⟩
    exact induction_on_adjoin P base ih ⊤
  · exact exists_primitive_element_of_finite_bot F E
#align field.exists_primitive_element Field.exists_primitive_element

/-- Alternative phrasing of primitive element theorem:
a finite separable field extension has a basis `1, α, α^2, ..., α^n`.

See also `exists_primitive_element`. -/
noncomputable def powerBasisOfFiniteOfSeparable : PowerBasis F E :=
  let α := (exists_primitive_element F E).choose
  let pb := adjoin.powerBasis (IsSeparable.isIntegral F α)
  have e : F⟮α⟯ = ⊤ := (exists_primitive_element F E).choose_spec
  pb.map ((IntermediateField.equivOfEq e).trans IntermediateField.topEquiv)
#align field.power_basis_of_finite_of_separable Field.powerBasisOfFiniteOfSeparable

end SeparableAssumption

section FiniteIntermediateField

theorem exists_primitive_element_of_finite_intermediateField :
    Finite (IntermediateField F E) → ∃ α : E, F⟮α⟯ = ⊤ := by
  intro h
  rcases isEmpty_or_nonempty (Fintype F) with (F_inf | ⟨⟨F_finite⟩⟩)
  · let P : IntermediateField F E → Prop := fun K => ∃ α : E, F⟮α⟯ = K
    have base : P ⊥ := ⟨0, adjoin_zero⟩
    have ih : ∀ (K : IntermediateField F E) (x : E), P K → P (K⟮x⟯.restrictScalars F) := by
      intro K β hK
      cases' hK with α hK
      rw [← hK, adjoin_simple_adjoin_simple]
      haveI : Infinite F := isEmpty_fintype.mp F_inf
      cases' primitive_element_inf_aux_of_finite_intermediateField F α β with γ hγ
      exact ⟨γ, hγ.symm⟩
    exact induction_on_adjoin P base ih ⊤
  · exact exists_primitive_element_of_finite_bot F E

lemma finite_intermediateField_of_exists_primitive_element.aux_finrank
    (K : IntermediateField F E) :
    letI : Algebra K (⊤ : IntermediateField K E) := IntermediateField.algebra _
    letI : Module K (⊤ : IntermediateField K E) := Algebra.toModule
    finrank K (⊤ : IntermediateField K E) = finrank K E := by
  letI : Algebra K (⊤ : IntermediateField K E) := IntermediateField.algebra _
  letI : Module K (⊤ : IntermediateField K E) := Algebra.toModule
  apply LinearEquiv.finrank_eq
  exact {
    toFun := fun x => x.1,
    map_add' := fun x y => by simp only [IntermediateField.coe_add],
    map_smul' := fun r x => by
      simp only [AddHom.toFun, RingHom.id_apply]
      letI : SMul K K := Algebra.toSMul (self := Algebra.id K)
      letI : IsScalarTower K K E := IsScalarTower.left K
      exact IntermediateField.coe_smul (⊤ : IntermediateField K E) r x,
    invFun := fun x => ⟨x, mem_top⟩,
    left_inv := fun x => by simp only,
    right_inv := fun x => by simp only,
  }

lemma finite_intermediateField_of_exists_primitive_element.aux_1
    (S : Set E) (hprim : adjoin F S = ⊤) (K : IntermediateField F E) :
    adjoin K S = ⊤ := by
  apply restrictScalars_injective (K := F) (L' := K) (L := E)
  rw [restrictScalars_top, ← top_le_iff, ← hprim, adjoin_le_iff,
    coe_restrictScalars, ← adjoin_le_iff]

lemma finite_intermediateField_of_exists_primitive_element.aux_2
    (α : E) (hprim : F⟮α⟯ = ⊤) (K K' : IntermediateField F E)
    (heq : (minpoly K α).map (algebraMap K E) = (minpoly K' α).map (algebraMap K' E)) :
    K = K ⊓ K' := by
  set g := (minpoly K α).map (algebraMap K E)
  set K'' := K ⊓ K'
  let p : Polynomial K'' := Finset.sum g.support fun n => C ⟨g.coeff n,
    (mem_inf (S := K) (T := K')).2
      ⟨by rw [coeff_map]; exact ((minpoly K α).coeff n).property,
        by rw [heq, coeff_map]; exact ((minpoly K' α).coeff n).property⟩⟩ * X ^ n
  have hp : p.map (algebraMap K'' E) = g := by
    rw [← sum_C_mul_X_pow_eq g, Polynomial.sum_def, Polynomial.map_sum]
    congr
    funext n
    rw [Polynomial.map_mul, Polynomial.map_pow, Polynomial.map_X, Polynomial.map_C]
    congr
  let q := minpoly K'' α
  obtain ⟨r, hqdvdp⟩ := show q ∣ p by
    apply minpoly.dvd
    rw [aeval_def, eval₂_eq_eval_map, hp, ← eval₂_eq_eval_map, ← aeval_def]
    exact minpoly.aeval K α
  have hpne0 : q * r ≠ 0 := by
    apply_fun Polynomial.map (algebraMap K'' E)
    rw [← hqdvdp, hp, Polynomial.map_zero,
      Polynomial.map_ne_zero_iff $ NoZeroSMulDivisors.algebraMap_injective K E]
    exact minpoly.ne_zero $ isAlgebraic_iff_isIntegral.1 $ isAlgebraic_of_finite K α
  have hpdeg := IntermediateField.adjoin.finrank (K := K) (x := α) (hx := isIntegral_of_finite K α)
  rw [Field.finite_intermediateField_of_exists_primitive_element.aux_1 F E _ hprim K,
    Field.finite_intermediateField_of_exists_primitive_element.aux_finrank F E K,
    ← Polynomial.natDegree_map_eq_of_injective (NoZeroSMulDivisors.algebraMap_injective K E)
      (minpoly K α),
    show (minpoly K α).map (algebraMap K E) = g by rfl,
    ← hp,
    Polynomial.natDegree_map_eq_of_injective (NoZeroSMulDivisors.algebraMap_injective K'' E),
    hqdvdp,
    Polynomial.natDegree_mul (left_ne_zero_of_mul hpne0) (right_ne_zero_of_mul hpne0),
    ← IntermediateField.adjoin.finrank (K := K'') (x := α) (hx := isIntegral_of_finite K'' α),
    Field.finite_intermediateField_of_exists_primitive_element.aux_1 F E _ hprim K'',
    Field.finite_intermediateField_of_exists_primitive_element.aux_finrank F E K''] at hpdeg
  replace hpdeg : finrank K E ≥ finrank K'' E := by linarith only [hpdeg, Nat.le_add_right]
  exact (eq_of_le_of_finrank_le' inf_le_left hpdeg).symm

lemma finite_intermediateField_of_exists_primitive_element.aux_fin
    (f : Polynomial E) (h : f ≠ 0) :
    Finite { g : Polynomial E // g.Monic ∧ g ∣ f } := by
  set G := { g : Polynomial E // g.Monic ∧ g ∣ f }
  let y : Associates $ Polynomial E := Associates.mk f
  have hy : y ≠ 0 := Associates.mk_ne_zero.mpr h
  let H := { x : Associates $ Polynomial E // x ∣ y }
  have hfin : Finite H := @Finite.of_fintype _ $ UniqueFactorizationMonoid.fintypeSubtypeDvd y hy
  let i : G → H := fun x => ⟨Associates.mk x.1, Associates.mk_dvd_mk.2 x.2.2⟩
  have hinj : Function.Injective i := fun x y heq => by
    rw [Subtype.mk.injEq, Associates.mk_eq_mk_iff_associated] at heq
    obtain ⟨z, h⟩ := heq
    obtain ⟨c, ⟨_, h2⟩⟩ := Polynomial.isUnit_iff.1 (Units.isUnit z)
    have h' := congr_arg Polynomial.leadingCoeff h
    rw [mul_comm, Polynomial.leadingCoeff_mul_monic x.2.1, y.2.1,
      ← h2, Polynomial.leadingCoeff_C] at h'
    rw [← h2, h', map_one, mul_one] at h
    rwa [Subtype.mk.injEq]
  exact Finite.of_injective i hinj

-- A finite simple extension has only finitely many intermediate fields
theorem finite_intermediateField_of_exists_primitive_element :
    (∃ α : E, F⟮α⟯ = ⊤) → Finite (IntermediateField F E) := by
  intro ⟨α, hprim⟩
  -- Let `f` be the minimal polynomial of `α ∈ E` over `F`
  let f : Polynomial F := minpoly F α
  let G := { g : Polynomial E // g.Monic ∧ g ∣ f.map (algebraMap F E) }
  -- Then `f` has only finitely many monic factors
  have hfin : Finite G := Field.finite_intermediateField_of_exists_primitive_element.aux_fin
    E (f.map (algebraMap F E)) $ by
      rw [Polynomial.map_ne_zero_iff $ NoZeroSMulDivisors.algebraMap_injective F E]
      exact minpoly.ne_zero_of_finite F α
  -- If `K` is an intermediate field of `E/F`, let `g` be the minimal polynomial of `α` over `K`
  -- which is a monic factor of `f`
  let g : IntermediateField F E → G := fun K =>
    ⟨(minpoly K α).map (algebraMap K E), ⟨Monic.map (algebraMap K E) $
      minpoly.monic $ isAlgebraic_iff_isIntegral.1 $ isAlgebraic_of_finite K α,
    by
      obtain ⟨fac, hfac⟩ := minpoly.dvd_map_of_isScalarTower F K α
      use fac.map (algebraMap K E)
      apply_fun Polynomial.map (algebraMap K E) at hfac
      rw [← Polynomial.map_mul, ← hfac, Polynomial.map_map]
      congr 1⟩⟩
  -- The map `K ↦ g` is injective
  have hinj : Function.Injective g := fun K K' heq => by
    rw [Subtype.mk.injEq] at heq
    have h := Field.finite_intermediateField_of_exists_primitive_element.aux_2
      F E α hprim K K' heq
    rwa [inf_comm, ← Field.finite_intermediateField_of_exists_primitive_element.aux_2
      F E α hprim K' K heq.symm] at h
  -- Therefore there are only finitely many intermediate fields
  exact Finite.of_injective g hinj

/-- **Steinitz theorem**: a finite extension `E` of `F` has a
  primitive element (i.e. there is an `α ∈ E` such that `F⟮α⟯ = (⊤ : Subalgebra F E)`)
  if and only if there exist only finitely many intermediate fields between `E` and `F`. -/
theorem exists_primitive_element_iff_finite_intermediateField :
    (∃ α : E, F⟮α⟯ = ⊤) ↔ Finite (IntermediateField F E) :=
  ⟨Field.finite_intermediateField_of_exists_primitive_element F E,
    Field.exists_primitive_element_of_finite_intermediateField F E⟩

end FiniteIntermediateField

end Field

@[simp]
theorem AlgHom.card (F E K : Type*) [Field F] [Field E] [Field K] [IsAlgClosed K] [Algebra F E]
    [FiniteDimensional F E] [IsSeparable F E] [Algebra F K] :
    Fintype.card (E →ₐ[F] K) = finrank F E := by
  convert (AlgHom.card_of_powerBasis (L := K) (Field.powerBasisOfFiniteOfSeparable F E)
    (IsSeparable.separable _ _) (IsAlgClosed.splits_codomain _)).trans (PowerBasis.finrank _).symm
#align alg_hom.card AlgHom.card
