/-
Copyright (c) 2020 Thomas Browning, Patrick Lutz. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Thomas Browning, Patrick Lutz
-/
import Mathlib.FieldTheory.SplittingField.Construction
import Mathlib.FieldTheory.IsAlgClosed.Basic
import Mathlib.FieldTheory.Separable
import Mathlib.RingTheory.IntegralDomain

#align_import field_theory.primitive_element from "leanprover-community/mathlib"@"df76f43357840485b9d04ed5dee5ab115d420e87"

/-!
# Primitive Element Theorem

In this file we prove the primitive element theorem.

## Main results

- `exists_primitive_element`: a finite separable extension `E / F` has a primitive element, i.e.
  there is an `Î± : E` such that `FâŸ®Î±âŸ¯ = (âŠ¤ : Subalgebra F E)`.

## Implementation notes

In declaration names, `primitive_element` abbreviates `adjoin_simple_eq_top`:
it stands for the statement `FâŸ®Î±âŸ¯ = (âŠ¤ : Subalgebra F E)`. We did not add an extra
declaration `IsPrimitiveElement F Î± := FâŸ®Î±âŸ¯ = (âŠ¤ : Subalgebra F E)` because this
requires more unfolding without much obvious benefit.

## Tags

primitive element, separable field extension, separable extension, intermediate field, adjoin,
exists_adjoin_simple_eq_top

-/


noncomputable section

open scoped Classical Polynomial

open FiniteDimensional Polynomial IntermediateField

namespace Field

section PrimitiveElementFinite

variable (F : Type*) [Field F] (E : Type*) [Field E] [Algebra F E]

/-! ### Primitive element theorem for finite fields -/


/-- **Primitive element theorem** assuming E is finite. -/
theorem exists_primitive_element_of_finite_top [Finite E] : âˆƒ Î± : E, FâŸ®Î±âŸ¯ = âŠ¤ := by
  obtain âŸ¨Î±, hÎ±âŸ© := @IsCyclic.exists_generator (Units E) _ _
  -- âŠ¢ âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤
  use Î±
  -- âŠ¢ FâŸ®â†‘Î±âŸ¯ = âŠ¤
  apply eq_top_iff.mpr
  -- âŠ¢ âŠ¤ â‰¤ FâŸ®â†‘Î±âŸ¯
  rintro x -
  -- âŠ¢ x âˆˆ FâŸ®â†‘Î±âŸ¯
  by_cases hx : x = 0
  -- âŠ¢ x âˆˆ FâŸ®â†‘Î±âŸ¯
  Â· rw [hx]
    -- âŠ¢ 0 âˆˆ FâŸ®â†‘Î±âŸ¯
    exact FâŸ®Î±.valâŸ¯.zero_mem
    -- ğŸ‰ no goals
  Â· obtain âŸ¨n, hnâŸ© := Set.mem_range.mp (hÎ± (Units.mk0 x hx))
    -- âŠ¢ x âˆˆ FâŸ®â†‘Î±âŸ¯
    simp only at hn
    -- âŠ¢ x âˆˆ FâŸ®â†‘Î±âŸ¯
    rw [show x = Î± ^ n by norm_cast; rw [hn, Units.val_mk0], Units.val_zpow_eq_zpow_val]
    -- âŠ¢ â†‘Î± ^ n âˆˆ FâŸ®â†‘Î±âŸ¯
    exact zpow_mem (mem_adjoin_simple_self F (E := E) â†‘Î±) n
    -- ğŸ‰ no goals
#align field.exists_primitive_element_of_finite_top Field.exists_primitive_element_of_finite_top

/-- Primitive element theorem for finite dimensional extension of a finite field. -/
theorem exists_primitive_element_of_finite_bot [Finite F] [FiniteDimensional F E] :
    âˆƒ Î± : E, FâŸ®Î±âŸ¯ = âŠ¤ :=
  haveI : Finite E := finite_of_finite F E
  exists_primitive_element_of_finite_top F E
#align field.exists_primitive_element_of_finite_bot Field.exists_primitive_element_of_finite_bot

end PrimitiveElementFinite

/-! ### Primitive element theorem for infinite fields -/


section PrimitiveElementInf

variable {F : Type*} [Field F] [Infinite F] {E : Type*} [Field E] (Ï• : F â†’+* E) (Î± Î² : E)

theorem primitive_element_inf_aux_exists_c (f g : F[X]) :
    âˆƒ c : F, âˆ€ Î±' âˆˆ (f.map Ï•).roots, âˆ€ Î²' âˆˆ (g.map Ï•).roots, -(Î±' - Î±) / (Î²' - Î²) â‰  Ï• c := by
  let sf := (f.map Ï•).roots
  -- âŠ¢ âˆƒ c, âˆ€ (Î±' : E), Î±' âˆˆ roots (Polynomial.map Ï• f) â†’ âˆ€ (Î²' : E), Î²' âˆˆ roots (P â€¦
  let sg := (g.map Ï•).roots
  -- âŠ¢ âˆƒ c, âˆ€ (Î±' : E), Î±' âˆˆ roots (Polynomial.map Ï• f) â†’ âˆ€ (Î²' : E), Î²' âˆˆ roots (P â€¦
  let s := (sf.bind fun Î±' => sg.map fun Î²' => -(Î±' - Î±) / (Î²' - Î²)).toFinset
  -- âŠ¢ âˆƒ c, âˆ€ (Î±' : E), Î±' âˆˆ roots (Polynomial.map Ï• f) â†’ âˆ€ (Î²' : E), Î²' âˆˆ roots (P â€¦
  let s' := s.preimage Ï• fun x _ y _ h => Ï•.injective h
  -- âŠ¢ âˆƒ c, âˆ€ (Î±' : E), Î±' âˆˆ roots (Polynomial.map Ï• f) â†’ âˆ€ (Î²' : E), Î²' âˆˆ roots (P â€¦
  obtain âŸ¨c, hcâŸ© := Infinite.exists_not_mem_finset s'
  -- âŠ¢ âˆƒ c, âˆ€ (Î±' : E), Î±' âˆˆ roots (Polynomial.map Ï• f) â†’ âˆ€ (Î²' : E), Î²' âˆˆ roots (P â€¦
  simp_rw [Finset.mem_preimage, Multiset.mem_toFinset, Multiset.mem_bind, Multiset.mem_map] at hc
  -- âŠ¢ âˆƒ c, âˆ€ (Î±' : E), Î±' âˆˆ roots (Polynomial.map Ï• f) â†’ âˆ€ (Î²' : E), Î²' âˆˆ roots (P â€¦
  push_neg at hc
  -- âŠ¢ âˆƒ c, âˆ€ (Î±' : E), Î±' âˆˆ roots (Polynomial.map Ï• f) â†’ âˆ€ (Î²' : E), Î²' âˆˆ roots (P â€¦
  exact âŸ¨c, hcâŸ©
  -- ğŸ‰ no goals
#align field.primitive_element_inf_aux_exists_c Field.primitive_element_inf_aux_exists_c

variable (F)

variable [Algebra F E]

-- This is the heart of the proof of the primitive element theorem. It shows that if `F` is
-- infinite and `Î±` and `Î²` are separable over `F` then `FâŸ®Î±, Î²âŸ¯` is generated by a single element.
theorem primitive_element_inf_aux [IsSeparable F E] : âˆƒ Î³ : E, FâŸ®Î±, Î²âŸ¯ = FâŸ®Î³âŸ¯ := by
  have hÎ± := IsSeparable.isIntegral F Î±
  -- âŠ¢ âˆƒ Î³, FâŸ®Î±, Î²âŸ¯ = FâŸ®Î³âŸ¯
  have hÎ² := IsSeparable.isIntegral F Î²
  -- âŠ¢ âˆƒ Î³, FâŸ®Î±, Î²âŸ¯ = FâŸ®Î³âŸ¯
  let f := minpoly F Î±
  -- âŠ¢ âˆƒ Î³, FâŸ®Î±, Î²âŸ¯ = FâŸ®Î³âŸ¯
  let g := minpoly F Î²
  -- âŠ¢ âˆƒ Î³, FâŸ®Î±, Î²âŸ¯ = FâŸ®Î³âŸ¯
  let Î¹FE := algebraMap F E
  -- âŠ¢ âˆƒ Î³, FâŸ®Î±, Î²âŸ¯ = FâŸ®Î³âŸ¯
  let Î¹EE' := algebraMap E (SplittingField (g.map Î¹FE))
  -- âŠ¢ âˆƒ Î³, FâŸ®Î±, Î²âŸ¯ = FâŸ®Î³âŸ¯
  obtain âŸ¨c, hcâŸ© := primitive_element_inf_aux_exists_c (Î¹EE'.comp Î¹FE) (Î¹EE' Î±) (Î¹EE' Î²) f g
  -- âŠ¢ âˆƒ Î³, FâŸ®Î±, Î²âŸ¯ = FâŸ®Î³âŸ¯
  let Î³ := Î± + c â€¢ Î²
  -- âŠ¢ âˆƒ Î³, FâŸ®Î±, Î²âŸ¯ = FâŸ®Î³âŸ¯
  suffices Î²_in_FÎ³ : Î² âˆˆ FâŸ®Î³âŸ¯
  -- âŠ¢ âˆƒ Î³, FâŸ®Î±, Î²âŸ¯ = FâŸ®Î³âŸ¯
  Â· use Î³
    -- âŠ¢ FâŸ®Î±, Î²âŸ¯ = FâŸ®Î³âŸ¯
    apply le_antisymm
    -- âŠ¢ FâŸ®Î±, Î²âŸ¯ â‰¤ FâŸ®Î³âŸ¯
    Â· rw [adjoin_le_iff]
      -- âŠ¢ {Î±, Î²} â‰¤ â†‘FâŸ®Î³âŸ¯
      have Î±_in_FÎ³ : Î± âˆˆ FâŸ®Î³âŸ¯ := by
        rw [â† add_sub_cancel Î± (c â€¢ Î²)]
        exact FâŸ®Î³âŸ¯.sub_mem (mem_adjoin_simple_self F Î³) (FâŸ®Î³âŸ¯.toSubalgebra.smul_mem Î²_in_FÎ³ c)
      exact fun x hx => by
        -- Porting note: was `by cases hx <;> cases hx <;> cases hx <;> assumption`
        cases' hx with hx hx
        Â· rwa [â† hx] at Î±_in_FÎ³
        Â· cases hx; norm_cast
    Â· rw [adjoin_simple_le_iff]
      -- âŠ¢ Î³ âˆˆ FâŸ®Î±, Î²âŸ¯
      have Î±_in_FÎ±Î² : Î± âˆˆ FâŸ®Î±, Î²âŸ¯ := subset_adjoin F {Î±, Î²} (Set.mem_insert Î± {Î²})
      -- âŠ¢ Î³ âˆˆ FâŸ®Î±, Î²âŸ¯
      have Î²_in_FÎ±Î² : Î² âˆˆ FâŸ®Î±, Î²âŸ¯ := subset_adjoin F {Î±, Î²} (Set.mem_insert_of_mem Î± rfl)
      -- âŠ¢ Î³ âˆˆ FâŸ®Î±, Î²âŸ¯
      exact FâŸ®Î±, Î²âŸ¯.add_mem Î±_in_FÎ±Î² (FâŸ®Î±, Î²âŸ¯.smul_mem Î²_in_FÎ±Î²)
      -- ğŸ‰ no goals
  let p := EuclideanDomain.gcd ((f.map (algebraMap F FâŸ®Î³âŸ¯)).comp
    (C (AdjoinSimple.gen F Î³) - (C â†‘c : FâŸ®Î³âŸ¯[X]) * X)) (g.map (algebraMap F FâŸ®Î³âŸ¯))
  let h := EuclideanDomain.gcd ((f.map Î¹FE).comp (C Î³ - C (Î¹FE c) * X)) (g.map Î¹FE)
  -- âŠ¢ Î² âˆˆ FâŸ®Î³âŸ¯
  have map_g_ne_zero : g.map Î¹FE â‰  0 := map_ne_zero (minpoly.ne_zero hÎ²)
  -- âŠ¢ Î² âˆˆ FâŸ®Î³âŸ¯
  have h_ne_zero : h â‰  0 :=
    mt EuclideanDomain.gcd_eq_zero_iff.mp (not_and.mpr fun _ => map_g_ne_zero)
  suffices p_linear : p.map (algebraMap FâŸ®Î³âŸ¯ E) = C h.leadingCoeff * (X - C Î²)
  -- âŠ¢ Î² âˆˆ FâŸ®Î³âŸ¯
  Â· have finale : Î² = algebraMap FâŸ®Î³âŸ¯ E (-p.coeff 0 / p.coeff 1) := by
      rw [map_divâ‚€, RingHom.map_neg, â† coeff_map, â† coeff_map, p_linear]
      -- Porting note: had to add `-map_add` to avoid going in the wrong direction.
      simp [mul_sub, coeff_C, mul_div_cancel_left Î² (mt leadingCoeff_eq_zero.mp h_ne_zero),
        -map_add]
      -- Porting note: an alternative solution is:
      -- simp_rw [Polynomial.coeff_C_mul, Polynomial.coeff_sub, mul_sub,
      --   Polynomial.coeff_X_zero, Polynomial.coeff_X_one, mul_zero, mul_one, zero_sub, neg_neg,
      --   Polynomial.coeff_C, eq_self_iff_true, Nat.one_ne_zero, if_true, if_false, mul_zero,
      --   sub_zero, mul_div_cancel_left Î² (mt leadingCoeff_eq_zero.mp h_ne_zero)]
    rw [finale]
    -- âŠ¢ â†‘(algebraMap { x // x âˆˆ FâŸ®Î³âŸ¯ } E) (-coeff p 0 / coeff p 1) âˆˆ FâŸ®Î³âŸ¯
    exact Subtype.mem (-p.coeff 0 / p.coeff 1)
    -- ğŸ‰ no goals
  have h_sep : h.Separable := separable_gcd_right _ (IsSeparable.separable F Î²).map
  -- âŠ¢ Polynomial.map (algebraMap { x // x âˆˆ FâŸ®Î³âŸ¯ } E) p = â†‘C (leadingCoeff h) * (X â€¦
  have h_root : h.eval Î² = 0 := by
    apply eval_gcd_eq_zero
    Â· rw [eval_comp, eval_sub, eval_mul, eval_C, eval_C, eval_X, eval_map, â† aeval_def, â†
        Algebra.smul_def, add_sub_cancel, minpoly.aeval]
    Â· rw [eval_map, â† aeval_def, minpoly.aeval]
  have h_splits : Splits Î¹EE' h :=
    splits_of_splits_gcd_right Î¹EE' map_g_ne_zero (SplittingField.splits _)
  have h_roots : âˆ€ x âˆˆ (h.map Î¹EE').roots, x = Î¹EE' Î² := by
    intro x hx
    rw [mem_roots_map h_ne_zero] at hx
    specialize hc (Î¹EE' Î³ - Î¹EE' (Î¹FE c) * x) (by
      have f_root := root_left_of_root_gcd hx
      rw [evalâ‚‚_comp, evalâ‚‚_sub, evalâ‚‚_mul, evalâ‚‚_C, evalâ‚‚_C, evalâ‚‚_X, evalâ‚‚_map] at f_root
      exact (mem_roots_map (minpoly.ne_zero hÎ±)).mpr f_root)
    specialize hc x (by
      rw [mem_roots_map (minpoly.ne_zero hÎ²), â† evalâ‚‚_map]
      exact root_right_of_root_gcd hx)
    by_contra a
    apply hc
    apply (div_eq_iff (sub_ne_zero.mpr a)).mpr
    simp only [Algebra.smul_def, RingHom.map_add, RingHom.map_mul, RingHom.comp_apply]
    ring
  rw [â† eq_X_sub_C_of_separable_of_root_eq h_sep h_root h_splits h_roots]
  -- âŠ¢ Polynomial.map (algebraMap { x // x âˆˆ FâŸ®Î³âŸ¯ } E) p = h
  trans EuclideanDomain.gcd (?_ : E[X]) (?_ : E[X])
  Â· dsimp only
    -- âŠ¢ Polynomial.map (algebraMap { x // x âˆˆ FâŸ®Î± + c â€¢ Î²âŸ¯ } E) (EuclideanDomain.gcd â€¦
    convert (gcd_map (algebraMap FâŸ®Î³âŸ¯ E)).symm
    -- ğŸ‰ no goals
  Â· simp [map_comp, Polynomial.map_map, â† IsScalarTower.algebraMap_eq]
    -- âŠ¢ EuclideanDomain.gcd (comp (Polynomial.map (algebraMap F E) (minpoly F Î±)) (â†‘ â€¦
    congr
    -- ğŸ‰ no goals
#align field.primitive_element_inf_aux Field.primitive_element_inf_aux

end PrimitiveElementInf

variable (F E : Type*) [Field F] [Field E]

variable [Algebra F E] [FiniteDimensional F E]

section SeparableAssumption

variable [IsSeparable F E]

/-- Primitive element theorem: a finite separable field extension `E` of `F` has a
  primitive element, i.e. there is an `Î± âˆˆ E` such that `FâŸ®Î±âŸ¯ = (âŠ¤ : Subalgebra F E)`.-/
theorem exists_primitive_element : âˆƒ Î± : E, FâŸ®Î±âŸ¯ = âŠ¤ := by
  rcases isEmpty_or_nonempty (Fintype F) with (F_inf | âŸ¨âŸ¨F_finiteâŸ©âŸ©)
  -- âŠ¢ âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤
  Â· let P : IntermediateField F E â†’ Prop := fun K => âˆƒ Î± : E, FâŸ®Î±âŸ¯ = K
    -- âŠ¢ âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤
    have base : P âŠ¥ := âŸ¨0, adjoin_zeroâŸ©
    -- âŠ¢ âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤
    have ih : âˆ€ (K : IntermediateField F E) (x : E), P K â†’ P (KâŸ®xâŸ¯.restrictScalars F) := by
      intro K Î² hK
      cases' hK with Î± hK
      rw [â† hK, adjoin_simple_adjoin_simple]
      haveI : Infinite F := isEmpty_fintype.mp F_inf
      cases' primitive_element_inf_aux F Î± Î² with Î³ hÎ³
      exact âŸ¨Î³, hÎ³.symmâŸ©
    exact induction_on_adjoin P base ih âŠ¤
    -- ğŸ‰ no goals
  Â· exact exists_primitive_element_of_finite_bot F E
    -- ğŸ‰ no goals
#align field.exists_primitive_element Field.exists_primitive_element

/-- Alternative phrasing of primitive element theorem:
a finite separable field extension has a basis `1, Î±, Î±^2, ..., Î±^n`.

See also `exists_primitive_element`. -/
noncomputable def powerBasisOfFiniteOfSeparable : PowerBasis F E :=
  let Î± := (exists_primitive_element F E).choose
  let pb := adjoin.powerBasis (IsSeparable.isIntegral F Î±)
  have e : FâŸ®Î±âŸ¯ = âŠ¤ := (exists_primitive_element F E).choose_spec
  pb.map ((IntermediateField.equivOfEq e).trans IntermediateField.topEquiv)
#align field.power_basis_of_finite_of_separable Field.powerBasisOfFiniteOfSeparable

end SeparableAssumption

end Field

@[simp]
theorem AlgHom.card (F E K : Type*) [Field F] [Field E] [Field K] [IsAlgClosed K] [Algebra F E]
    [FiniteDimensional F E] [IsSeparable F E] [Algebra F K] :
    Fintype.card (E â†’â‚[F] K) = finrank F E := by
  convert (AlgHom.card_of_powerBasis (L := K) (Field.powerBasisOfFiniteOfSeparable F E)
    (IsSeparable.separable _ _) (IsAlgClosed.splits_codomain _)).trans (PowerBasis.finrank _).symm
#align alg_hom.card AlgHom.card
