/-
Copyright (c) 2024 Jujian Zhang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jujian Zhang
-/
import Mathlib.CategoryTheory.Limits.ConcreteCategory.Basic
import Mathlib.Algebra.Module.LinearMap.Defs
import Mathlib.CategoryTheory.ConcreteCategory.Elementwise
import Mathlib.Tactic.ApplyFun

/-!

# Colimits in concrete categories with algebraic structures

Let `C` be a concrete category and `F : J ‚•§ C` a filtered diagram in `C`. We discuss some results
about `colimit F` when objects and morphisms in `C` have some algebraic structures.

## Main results
- `CategoryTheory.Limits.Concrete.colimit_rep_eq_zero`: Let `C` be a category where its objects have
  zero elements and morphisms preserve zero. If `x : F‚±º` is mapped to `0` in the colimit, then
  there exists a `i ‚ü∂ j` such that `x` restricted to `i` is already `0`.

- `CategoryTheory.Limits.Concrete.colimit_no_zero_smul_divisor`: Let `C` be a category where its
  objects are `R`-modules and morphisms `R`-linear maps. Let `r : R` be an element without zero
  smul divisors for all small sections, i.e. there exists some `j : J` such that for all `j ‚ü∂ i`
  and `x : F·µ¢` we have `r ‚Ä¢ x = 0` implies `x = 0`, then if `r ‚Ä¢ x = 0` for `x : colimit F`, then
  `x = 0`.

Let `R` be the filtered colimit of rings `{R‚±º}` and `M` be the filtered colimit of abelian groups
`{M‚±º}`  with `j` running through the same filtered index category `J`. If for each `j ‚àà J`, `M‚±º` is
an `R‚±º`-module such that the `R‚±º`-actions are compatible, then `M` is an `R‚±º`-module for all `j`
and `M` is an `R`-module.

- `Module.overFilteredColimits.moduleColimitColimit`: Let `R` and `M` be as above, then `M` is an
  `R`-module.

- `Module.overFilteredColimits.smul_spec`: Let `R` and `M` be as above, then the `R`-action on `M`
  is given by the following: if `s : R‚±º‚ÇÅ` and `t : M‚±º‚ÇÇ` where `j‚ÇÅ ‚â§ j‚ÇÉ` and `j‚ÇÇ ‚â§ j‚ÇÉ`, then
  `[s] ‚Ä¢ [m]` is equal to `[s|‚±º‚ÇÉ ‚Ä¢ m |‚±º‚ÇÉ]` where `[...]` is the equivalence class in the colimit.

## Implementation notes on `Module.overFilteredColimits`

1. We choose not to use `PresheafOfModules` to avoid code duplication:
consider `R : J ‚•§ CommRingCat` and `M : J ‚•§ AddCommGrp`, then `colimit M` is both a
`colimit R`-module and a `colimit (R ‚ãô forget‚ÇÇ CommRingCat RingCat)`-module; the two module
structures are virtually the same. This situation manifests in stalks of sheaves of modules:
for any scheme `X` and a sheaf of `ùí™_X`-module `‚Ñ≥`, we want to think the stalk `‚Ñ≥‚Çì` as an
`ùí™_{X,x}`-module. But since `PresheafOfModules` requires a presheaf of `RingCat` not `CommRingCat`,
`ùí™_{X,x}` can mean two things in Lean:
1. `TopCat.Presheaf.stalk X.presheaf x` or
2. `TopCat.Presheaf.stsalk X.ringCatSheaf.presheaf x`
The module sturectures of `‚Ñ≥‚Çì` over both interpretations are the same. Thus instead of choosing a
category, we work in some concrete categories that behaves like `RingCat` and `AddCommGrp`.
For example if `‚Ñ≥` is an `ùí™_X`-algebras, this setup is still valid and can be extended to give an
algebra instance.

2. Other than `Module.overFilteredColimits.{moduleColimitColimit, smul_spec}`, everything else in
this namespace is implementation details and is probably not very useful.

-/

universe t w v v' u u' r uc‚ÇÅ uc‚ÇÇ

open CategoryTheory

namespace CategoryTheory.Limits.Concrete

attribute [local instance] ConcreteCategory.instFunLike ConcreteCategory.hasCoeToSort

variable {C : Type u} [Category.{v} C] [ConcreteCategory.{max t w} C] {J : Type w} [Category.{r} J]

section zero

theorem colimit_rep_eq_zero
    (F : J ‚•§ C) [PreservesColimit F (forget C)] [IsFiltered J]
    [‚àÄ c : C, Zero c] [‚àÄ {c c' : C}, ZeroHomClass (c ‚ü∂ c') c c'] [HasColimit F]
    (j : J) (x : F.obj j) (hx : colimit.Œπ F j x = 0) :
    ‚àÉ (j' : J) (i : j ‚ü∂ j'), F.map i x = 0 := by
  rw [show 0 = colimit.Œπ F j 0 by simp, colimit_rep_eq_iff_exists] at hx
  obtain ‚ü®j', i, y, g‚ü© := hx
  exact ‚ü®j', i, g ‚ñ∏ by simp‚ü©

end zero

section module

/--
if `r` has no zero smul divisors for all small-enough sections, then `r` has no zero smul divisors
in the colimit.
-/
lemma colimit_no_zero_smul_divisor
    (F : J ‚•§ C) [PreservesColimit F (forget C)] [IsFiltered J] [HasColimit F]
    (R : Type*) [Semiring R]
    [‚àÄ c : C, AddCommMonoid c] [‚àÄ c : C, Module R c]
    [‚àÄ {c c' : C}, LinearMapClass (c ‚ü∂ c') R c c']
    (r : R) (H : ‚àÉ (j' : J), ‚àÄ (j : J) (_ : j' ‚ü∂ j), ‚àÄ (c : F.obj j), r ‚Ä¢ c = 0 ‚Üí c = 0)
    (x : (forget C).obj (colimit F)) (hx : r ‚Ä¢ x = 0) : x = 0 := by
  classical
  obtain ‚ü®j, x, rfl‚ü© := Concrete.colimit_exists_rep F x
  rw [‚Üê map_smul] at hx
  obtain ‚ü®j', i, h‚ü© := Concrete.colimit_rep_eq_zero (hx := hx)
  obtain ‚ü®j'', H‚ü© := H
  simpa [elementwise_of% (colimit.w F), map_zero] using congr(colimit.Œπ F _
    $(H (IsFiltered.sup {j, j', j''} { ‚ü®j, j', by simp, by simp, i‚ü© })
      (IsFiltered.toSup _ _ <| by simp)
      (F.map (IsFiltered.toSup _ _ <| by simp) x)
      (by rw [‚Üê IsFiltered.toSup_commutes (f := i) (mY := by simp) (mf := by simp), F.map_comp,
        comp_apply, ‚Üê map_smul, ‚Üê map_smul, h, map_zero])))

end module

section module_over_filtered_colimit

/-!
# Module structure of `colim M·µ¢` over `colim R·µ¢`

Let `R` be the filtered colimit of rings `{R‚±º}` and `M` be the filtered colimit of abelian groups
`{M‚±º}`  with `j` running through the same filtered index category `J`. If for each `j ‚àà J`, `M‚±º` is
an `R‚±º`-module such that the `R‚±º`-actions are compatible, then `M` is an `R‚±º`-module for all `j`
and `M` is an `R`-module. We put a module structure on `colim M·µ¢` over `colim R·µ¢` where the scalar
multiplication is given by `r ‚Ä¢ m = [a|‚Çõ ‚Ä¢ b|‚Çõ]` where `a : R·µ¢` and `b : M‚±º` represent `r` and `m`
and `s` refines both `i` and `j`.

-/

variable {‚Ñúùî¶ùî´ùî§ : Type u} [Category.{u'} ‚Ñúùî¶ùî´ùî§] [ConcreteCategory.{max uc‚ÇÅ w} ‚Ñúùî¶ùî´ùî§]
variable {ùîÑùîü : Type v} [Category.{v'} ùîÑùîü] [ConcreteCategory.{max uc‚ÇÇ w} ùîÑùîü]
variable (‚Ñõ : J ‚•§ ‚Ñúùî¶ùî´ùî§) (‚Ñ≥ : J ‚•§ ùîÑùîü)

variable [‚àÄ x : ‚Ñúùî¶ùî´ùî§, Semiring x] [‚àÄ x : ùîÑùîü, AddCommMonoid x]
variable [‚àÄ x y : ‚Ñúùî¶ùî´ùî§, RingHomClass (x ‚ü∂ y) x y]
variable [‚àÄ x y : ùîÑùîü, AddMonoidHomClass (x ‚ü∂ y) x y]

variable [HasColimit ‚Ñõ] [HasColimit ‚Ñ≥]
variable [PreservesColimit ‚Ñõ (forget ‚Ñúùî¶ùî´ùî§)] [PreservesColimit ‚Ñ≥ (forget ùîÑùîü)]

variable [‚àÄ c, Module (‚Ñõ.obj c) (‚Ñ≥.obj c)]
variable [compatible_smul : Fact <| ‚àÄ {c‚ÇÅ c‚ÇÇ : J} (i‚ÇÅ : c‚ÇÅ ‚ü∂ c‚ÇÇ) (r : ‚Ñõ.obj c‚ÇÅ) (m : ‚Ñ≥.obj c‚ÇÅ),
    ‚Ñ≥.map i‚ÇÅ (r ‚Ä¢ m) = ‚Ñõ.map i‚ÇÅ r ‚Ä¢ ‚Ñ≥.map i‚ÇÅ m]

variable [IsFiltered J]

namespace Module.overFilteredColimits

variable {‚Ñõ ‚Ñ≥} in
/--
Let `R` be the filtered colimit of rings `{R‚±º}` and `M` be the filtered colimit of
abelian groups `{M‚±º}`  with the same filtered indexing category `J`, if for each `j ‚àà J`,
`M‚±º` is an `R‚±º`-module such that the `R‚±º`-actions are compatible, then there is a heterogeneous
scalar multiplication `R·µ¢ ‚Üí M‚±º ‚Üí M‚Çñ` for every `i ‚Üí j` and `i ‚Üí k`.
-/
def hSMul {c‚ÇÅ c‚ÇÇ c‚ÇÉ : J} (i‚ÇÅ : c‚ÇÅ ‚ü∂ c‚ÇÉ) (i‚ÇÇ : c‚ÇÇ ‚ü∂ c‚ÇÉ)
    (r : ‚Ñõ.obj c‚ÇÅ) (m : ‚Ñ≥.obj c‚ÇÇ) : ‚Ñ≥.obj c‚ÇÉ :=
  ‚Ñõ.map i‚ÇÅ r ‚Ä¢ ‚Ñ≥.map i‚ÇÇ m

section hSMul

variable {c‚ÇÅ c‚ÇÇ c‚ÇÉ : J} (i‚ÇÅ : c‚ÇÅ ‚ü∂ c‚ÇÉ) (i‚ÇÇ : c‚ÇÇ ‚ü∂ c‚ÇÉ)
variable (r : ‚Ñõ.obj c‚ÇÅ) (m : ‚Ñ≥.obj c‚ÇÇ)

omit [‚àÄ (x y : ùîÑùîü), AddMonoidHomClass (x ‚ü∂ y) x y]
  [HasColimit ‚Ñõ] [HasColimit ‚Ñ≥]
  [PreservesColimit ‚Ñõ (forget ‚Ñúùî¶ùî´ùî§)] [PreservesColimit ‚Ñ≥ (forget ùîÑùîü)]
  compatible_smul [IsFiltered J] in
@[simp]
lemma one_hSMul :
    hSMul i‚ÇÅ i‚ÇÇ (1 : ‚Ñõ.obj c‚ÇÅ) m = (‚Ñ≥.map i‚ÇÇ m) := by
  simp [hSMul]

omit [‚àÄ (x y : ùîÑùîü), AddMonoidHomClass (x ‚ü∂ y) x y]
  [HasColimit ‚Ñõ] [HasColimit ‚Ñ≥]
  [PreservesColimit ‚Ñõ (forget ‚Ñúùî¶ùî´ùî§)] [PreservesColimit ‚Ñ≥ (forget ùîÑùîü)]
  compatible_smul [IsFiltered J] in
lemma mul_hSMul (r‚ÇÅ r‚ÇÇ : ‚Ñõ.obj c‚ÇÅ) : hSMul i‚ÇÅ i‚ÇÇ (r‚ÇÅ * r‚ÇÇ) m =
    hSMul i‚ÇÅ (ùüô _) r‚ÇÅ (hSMul i‚ÇÅ i‚ÇÇ r‚ÇÇ m) := by
  simp only [hSMul, map_mul, mul_smul]
  rw [‚Ñ≥.map_id, id_apply]

omit [‚àÄ (x y : ‚Ñúùî¶ùî´ùî§), RingHomClass (x ‚ü∂ y) x y]
  [HasColimit ‚Ñõ] [HasColimit ‚Ñ≥]
  [PreservesColimit ‚Ñõ (forget ‚Ñúùî¶ùî´ùî§)] [PreservesColimit ‚Ñ≥ (forget ùîÑùîü)]
  compatible_smul [IsFiltered J] in
@[simp]
lemma hSMul_zero : hSMul (‚Ñ≥ := ‚Ñ≥) i‚ÇÅ i‚ÇÇ r 0 = 0 := by
  simp [hSMul]

omit [‚àÄ (x y : ‚Ñúùî¶ùî´ùî§), RingHomClass (x ‚ü∂ y) x y]
  [HasColimit ‚Ñõ] [HasColimit ‚Ñ≥]
  [PreservesColimit ‚Ñõ (forget ‚Ñúùî¶ùî´ùî§)] [PreservesColimit ‚Ñ≥ (forget ùîÑùîü)]
  compatible_smul [IsFiltered J] in
lemma hSMul_add (m‚ÇÅ m‚ÇÇ : ‚Ñ≥.obj c‚ÇÇ) : hSMul i‚ÇÅ i‚ÇÇ r (m‚ÇÅ + m‚ÇÇ) =
    hSMul i‚ÇÅ i‚ÇÇ r m‚ÇÅ + hSMul i‚ÇÅ i‚ÇÇ r m‚ÇÇ := by
  simp [hSMul, smul_add]

omit [‚àÄ (x y : ùîÑùîü), AddMonoidHomClass (x ‚ü∂ y) x y]
  [HasColimit ‚Ñõ] [HasColimit ‚Ñ≥]
  [PreservesColimit ‚Ñõ (forget ‚Ñúùî¶ùî´ùî§)] [PreservesColimit ‚Ñ≥ (forget ùîÑùîü)]
  compatible_smul [IsFiltered J] in
lemma add_hSMul (r‚ÇÅ r‚ÇÇ : ‚Ñõ.obj c‚ÇÅ) (m : ‚Ñ≥.obj c‚ÇÇ) :
    hSMul i‚ÇÅ i‚ÇÇ (r‚ÇÅ + r‚ÇÇ) m = hSMul i‚ÇÅ i‚ÇÇ r‚ÇÅ m + hSMul i‚ÇÅ i‚ÇÇ r‚ÇÇ m := by
  simp [hSMul, add_smul]

omit [‚àÄ (x y : ùîÑùîü), AddMonoidHomClass (x ‚ü∂ y) x y]
  [HasColimit ‚Ñõ] [HasColimit ‚Ñ≥]
  [PreservesColimit ‚Ñõ (forget ‚Ñúùî¶ùî´ùî§)] [PreservesColimit ‚Ñ≥ (forget ùîÑùîü)]
  compatible_smul [IsFiltered J] in
@[simp]
lemma zero_hSMul : hSMul i‚ÇÅ i‚ÇÇ (0 : ‚Ñõ.obj c‚ÇÅ) m = 0 := by
  simp [hSMul]

omit [‚àÄ (x y : ‚Ñúùî¶ùî´ùî§), RingHomClass (x ‚ü∂ y) x y] [‚àÄ (x y : ùîÑùîü), AddMonoidHomClass (x ‚ü∂ y) x y] in
lemma hSMul_respect_Œπ
    {c‚ÇÅ c‚ÇÇ c‚ÇÉ : J} (i‚ÇÅ : c‚ÇÅ ‚ü∂ c‚ÇÉ) (i‚ÇÇ : c‚ÇÇ ‚ü∂ c‚ÇÉ)
    (r : ‚Ñõ.obj c‚ÇÅ) (x : ‚Ñ≥.obj c‚ÇÇ)
    {d‚ÇÅ d‚ÇÇ d‚ÇÉ : J} (j‚ÇÅ : d‚ÇÅ ‚ü∂ d‚ÇÉ) (j‚ÇÇ :  d‚ÇÇ ‚ü∂ d‚ÇÉ)
    (r' : ‚Ñõ.obj d‚ÇÅ) (x' : ‚Ñ≥.obj d‚ÇÇ)
    (hrr' : colimit.Œπ ‚Ñõ _ r = colimit.Œπ ‚Ñõ _ r')
    (hmm' : colimit.Œπ ‚Ñ≥ _ x = colimit.Œπ ‚Ñ≥ _ x') :
    colimit.Œπ ‚Ñ≥ _ (hSMul i‚ÇÅ i‚ÇÇ r x) =
    colimit.Œπ ‚Ñ≥ _ (hSMul j‚ÇÅ j‚ÇÇ r' x') := by
  classical
  obtain ‚ü®m, fm‚ÇÅ, fm‚ÇÇ, hm‚ü© := Concrete.colimit_exists_of_rep_eq (h := hrr')
  obtain ‚ü®n, fn‚ÇÅ, fn‚ÇÇ, hn‚ü© := Concrete.colimit_exists_of_rep_eq (h := hmm')
  rw [Concrete.colimit_rep_eq_iff_exists]
  let O : Finset J := { c‚ÇÅ, c‚ÇÇ, c‚ÇÉ, d‚ÇÅ, d‚ÇÇ, d‚ÇÉ, m, n }
  let H : Finset ((X : J) √ó' (Y : J) √ó' (_ : X ‚àà O) √ó' (_ : Y ‚àà O) √ó' (X ‚ü∂ Y)) :=
  { ‚ü®c‚ÇÅ, m, by simp [O], by simp [O], fm‚ÇÅ‚ü©,
    ‚ü®d‚ÇÅ, m, by simp [O], by simp [O], fm‚ÇÇ‚ü©,
    ‚ü®c‚ÇÇ, n, by simp [O], by simp [O], fn‚ÇÅ‚ü©,
    ‚ü®d‚ÇÇ, n, by simp [O], by simp [O], fn‚ÇÇ‚ü©,
    ‚ü®c‚ÇÅ, c‚ÇÉ, by simp [O], by simp [O], i‚ÇÅ‚ü©,
    ‚ü®c‚ÇÇ, c‚ÇÉ, by simp [O], by simp [O], i‚ÇÇ‚ü©,
    ‚ü®d‚ÇÅ, d‚ÇÉ, by simp [O], by simp [O], j‚ÇÅ‚ü©,
    ‚ü®d‚ÇÇ, d‚ÇÉ, by simp [O], by simp [O], j‚ÇÇ‚ü© }

  let S := IsFiltered.sup O H

  refine ‚ü®S, IsFiltered.toSup O H (by simp [O]), IsFiltered.toSup _ _ (by simp [O]), ?_‚ü©
  delta hSMul
  rw [compatible_smul.out, compatible_smul.out]
  apply_fun ‚Ñõ.map (IsFiltered.toSup O H (by simp [O])) at hm
  rw [‚Üê comp_apply, ‚Üê comp_apply, ‚Üê ‚Ñõ.map_comp, ‚Üê ‚Ñõ.map_comp] at hm

  apply_fun ‚Ñ≥.map (IsFiltered.toSup O H (by simp [O])) at hn
  rw [‚Üê comp_apply, ‚Üê comp_apply, ‚Üê ‚Ñ≥.map_comp, ‚Üê ‚Ñ≥.map_comp] at hn

  rw [‚Üê comp_apply, ‚Üê comp_apply, ‚Üê comp_apply, ‚Üê comp_apply, ‚Üê ‚Ñõ.map_comp, ‚Üê ‚Ñõ.map_comp,
    ‚Üê ‚Ñ≥.map_comp, ‚Üê ‚Ñ≥.map_comp]
  convert congr($hm ‚Ä¢ $hn) using 1 <;> congr 3
  ¬∑ rw [IsFiltered.toSup_commutes O H (f := i‚ÇÅ), IsFiltered.toSup_commutes O H (f := fm‚ÇÅ)]
    ¬∑ simp only [Finset.mem_insert, Finset.mem_singleton, true_or, O]
    ¬∑ simp only [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, true_and, Finset.mem_singleton,
      true_or, O, H]
    ¬∑ simp only [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, true_and, Finset.mem_singleton,
      true_or, or_true, O, H]
  ¬∑ rw [IsFiltered.toSup_commutes O H (f := i‚ÇÇ), IsFiltered.toSup_commutes O H (f := fn‚ÇÅ)]
    ¬∑ simp only [Finset.mem_insert, Finset.mem_singleton, true_or, or_true, O]
    ¬∑ simp only [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, true_and, Finset.mem_singleton,
      true_or, or_true, O, H]
    ¬∑ simp only [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, true_and, Finset.mem_singleton,
      true_or, or_true, O, H]
  ¬∑ rw [IsFiltered.toSup_commutes O H (f := j‚ÇÅ), IsFiltered.toSup_commutes O H (f := fm‚ÇÇ)]
    ¬∑ simp only [Finset.mem_insert, Finset.mem_singleton, true_or, or_true, O]
    ¬∑ simp only [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, true_and, Finset.mem_singleton,
      true_or, or_true, O, H]
    ¬∑ simp only [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, true_and, Finset.mem_singleton,
      true_or, or_true, O, H]
  ¬∑ rw [IsFiltered.toSup_commutes O H (f := j‚ÇÇ), IsFiltered.toSup_commutes O H (f := fn‚ÇÇ)]
    ¬∑ simp only [Finset.mem_insert, Finset.mem_singleton, true_or, or_true, O]
    ¬∑ simp only [Finset.mem_insert, PSigma.mk.injEq, Finset.mem_singleton, heq_eq_eq, true_and,
      true_or, or_true, O, H]
    ¬∑ simp only [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, true_and, Finset.mem_singleton,
      or_true, O, H]

end hSMul

variable {‚Ñõ ‚Ñ≥} in
/--
Let `R` be the filtered colimit of rings `{R‚±º}` and `M` be the filtered colimit of
abelian groups `{M‚±º}` with the same filtered indexing category `j ‚àà J`, if for each `j ‚àà J`,
`M‚±º` is an `R‚±º`-module such that the `R‚±º`-actions are compatible with the morphisms in `J`,
then there is a scalar multiplication `R‚±º ‚Üí M ‚Üí M` for every `j ‚àà J`.
-/
noncomputable def smulColimit {c : J} (r : ‚Ñõ.obj c) (m : colimit (C := ùîÑùîü) ‚Ñ≥) :
    colimit (C := ùîÑùîü) ‚Ñ≥ :=
  colimit.Œπ ‚Ñ≥ (IsFiltered.max c (Concrete.indexRepColimit ‚Ñ≥ m))
   (hSMul (IsFiltered.leftToMax _ _) (IsFiltered.rightToMax _ _)
    r (Concrete.repColimit ‚Ñ≥ m))

section smulColimit

omit [‚àÄ (x y : ‚Ñúùî¶ùî´ùî§), RingHomClass (x ‚ü∂ y) x y] [‚àÄ (x y : ùîÑùîü), AddMonoidHomClass (x ‚ü∂ y) x y] in
@[simp]
lemma smulColimit_smul_rep (c‚ÇÅ c‚ÇÇ : J) (r : ‚Ñõ.obj c‚ÇÅ) (m : ‚Ñ≥.obj c‚ÇÇ) :
    smulColimit r (colimit.Œπ ‚Ñ≥ c‚ÇÇ m) =
    colimit.Œπ ‚Ñ≥ (IsFiltered.max c‚ÇÅ c‚ÇÇ)
    (hSMul (IsFiltered.leftToMax _ _) (IsFiltered.rightToMax _ _) r m) := by
  apply hSMul_respect_Œπ
  ¬∑ rfl
  ¬∑ rw [Concrete.Œπ_repColimit_eq]

omit [‚àÄ (x y : ùîÑùîü), AddMonoidHomClass (x ‚ü∂ y) x y] in
@[simp]
lemma smulColimit_one_smul (c : J) (m : colimit (C := ùîÑùîü) ‚Ñ≥) :
    smulColimit (1 : ‚Ñõ.obj c) m = m := by
  rw [show m = colimit.Œπ ‚Ñ≥ (Concrete.indexRepColimit ‚Ñ≥ m) _ by
    rw [Concrete.Œπ_repColimit_eq], smulColimit_smul_rep, one_hSMul, colimit.w_apply]

omit [‚àÄ (x y : ùîÑùîü), AddMonoidHomClass (x ‚ü∂ y) x y] in
lemma smulColimit_mul_smul (c : J) (r‚ÇÅ r‚ÇÇ : ‚Ñõ.obj c)
    (m : colimit (C := ùîÑùîü) ‚Ñ≥) :
    smulColimit (r‚ÇÅ * r‚ÇÇ) m = smulColimit r‚ÇÅ (smulColimit r‚ÇÇ m) := by
  simp only [show m = colimit.Œπ ‚Ñ≥ (Concrete.indexRepColimit ‚Ñ≥ m) _ by
    rw [Concrete.Œπ_repColimit_eq], smulColimit_smul_rep, mul_hSMul]
  apply hSMul_respect_Œπ
  ¬∑ rfl
  ¬∑ apply hSMul_respect_Œπ
    ¬∑ rfl
    ¬∑ rw [Concrete.Œπ_repColimit_eq]


omit [‚àÄ (x y : ‚Ñúùî¶ùî´ùî§), RingHomClass (x ‚ü∂ y) x y] in
@[simp]
lemma smulColimit_smul_zero (c : J) (r : ‚Ñõ.obj c) : smulColimit (‚Ñ≥ := ‚Ñ≥) r 0 = 0 := by
  rw [show (0 : colimit (C := ùîÑùîü) ‚Ñ≥) = colimit.Œπ (C := ùîÑùîü) ‚Ñ≥ c 0 by rw [map_zero],
    smulColimit_smul_rep, hSMul_zero, map_zero, map_zero]

omit [‚àÄ (x y : ‚Ñúùî¶ùî´ùî§), RingHomClass (x ‚ü∂ y) x y] in
lemma smulColimit_smul_add (c : J) (r : ‚Ñõ.obj c) (m‚ÇÅ m‚ÇÇ : colimit (C := ùîÑùîü) ‚Ñ≥) :
    smulColimit r (m‚ÇÅ + m‚ÇÇ) = smulColimit r m‚ÇÅ + smulColimit r m‚ÇÇ := by
  classical
  let O : Finset J :=
    { c, Concrete.indexRepColimit ‚Ñ≥ m‚ÇÅ, Concrete.indexRepColimit ‚Ñ≥ m‚ÇÇ }
  let j : J := IsFiltered.sup O ‚àÖ

  have eq‚ÇÅ : m‚ÇÅ = colimit.Œπ ‚Ñ≥ j
      (‚Ñ≥.map (IsFiltered.toSup O ‚àÖ <| by simp [O]) (Concrete.repColimit ‚Ñ≥ m‚ÇÅ)) := by
    simp only [colimit.w_apply, Concrete.Œπ_repColimit_eq]
  have eq‚ÇÇ : m‚ÇÇ = colimit.Œπ ‚Ñ≥ j
      (‚Ñ≥.map (IsFiltered.toSup O ‚àÖ <| by simp [O]) (Concrete.repColimit ‚Ñ≥ m‚ÇÇ)) := by
    simp only [colimit.w_apply, Concrete.Œπ_repColimit_eq]
  have eq‚ÇÉ : m‚ÇÅ + m‚ÇÇ = colimit.Œπ ‚Ñ≥ j
      (‚Ñ≥.map (IsFiltered.toSup O ‚àÖ <| by simp [O]) (Concrete.repColimit ‚Ñ≥ m‚ÇÅ) +
       ‚Ñ≥.map (IsFiltered.toSup O ‚àÖ <| by simp [O]) (Concrete.repColimit ‚Ñ≥ m‚ÇÇ)) := by
    simp only [map_add, colimit.w_apply, Concrete.Œπ_repColimit_eq]

  rw [eq‚ÇÉ]
  conv_rhs => rw [eq‚ÇÅ]; rhs; rw [eq‚ÇÇ]
  rw [smulColimit_smul_rep, smulColimit_smul_rep, smulColimit_smul_rep, hSMul_add, map_add]

lemma smulColimit_add_smul (c : J) (r‚ÇÅ r‚ÇÇ : ‚Ñõ.obj c) (m : colimit (C := ùîÑùîü) ‚Ñ≥) :
    smulColimit (r‚ÇÅ + r‚ÇÇ) m = smulColimit r‚ÇÅ m + smulColimit r‚ÇÇ m := by
  simp only [show m = colimit.Œπ ‚Ñ≥ (Concrete.indexRepColimit ‚Ñ≥ m) _ by
    rw [Concrete.Œπ_repColimit_eq], smulColimit_smul_rep, add_hSMul, map_add]

@[simp]
lemma smulColimit_zero_smul (c : J) (m : colimit (C := ùîÑùîü) ‚Ñ≥) :
    smulColimit (‚Ñ≥ := ‚Ñ≥) (0 : ‚Ñõ.obj c) m = 0 := by
  simp only [show m = colimit.Œπ ‚Ñ≥ (Concrete.indexRepColimit ‚Ñ≥ m) _ by
    rw [Concrete.Œπ_repColimit_eq], smulColimit_smul_rep, zero_hSMul, map_zero]

end smulColimit

noncomputable instance moduleObjColimit (j : J) :
    Module (‚Ñõ.obj j) (colimit (C := ùîÑùîü) ‚Ñ≥) where
  smul := smulColimit
  one_smul := smulColimit_one_smul _ _ _
  mul_smul := smulColimit_mul_smul _ _ _
  smul_zero := smulColimit_smul_zero _ _ _
  smul_add := smulColimit_smul_add _ _ _
  add_smul := smulColimit_add_smul _ _ _
  zero_smul := smulColimit_zero_smul _ _ _

variable {‚Ñõ ‚Ñ≥} in
/--
Let `R` be the filtered colimit of rings `{R‚±º}` and `M` be the filtered colimit of
abelian groups `{M‚±º}`  with the same filtered indexing category `J`. If for each `j ‚àà J`, `M‚±º` is an
`R‚±º`-module such that the `R‚±º`-actions are compatible with the morphisms in `J`, then there is a
natural scalar multiplication `R ‚Üí M ‚Üí M`.
-/
noncomputable def colimitsmulColimit (r : colimit (C := ‚Ñúùî¶ùî´ùî§) ‚Ñõ) (m : colimit (C := ùîÑùîü) ‚Ñ≥) :
    colimit (C := ùîÑùîü) ‚Ñ≥ :=
  (smulColimit (Concrete.repColimit ‚Ñõ r) m)

section colimitsmulColimit

omit [‚àÄ (x y : ‚Ñúùî¶ùî´ùî§), RingHomClass (x ‚ü∂ y) x y] [‚àÄ (x y : ùîÑùîü), AddMonoidHomClass (x ‚ü∂ y) x y] in
@[simp]
lemma colimitsmulColimit_rep_smul {c : J} (r : ‚Ñõ.obj c) (m : colimit (C := ùîÑùîü) ‚Ñ≥) :
    colimitsmulColimit (colimit.Œπ ‚Ñõ c r) m = smulColimit r m := by
  rw [show m = colimit.Œπ ‚Ñ≥ (Concrete.indexRepColimit ‚Ñ≥ m) _ by
    rw [Concrete.Œπ_repColimit_eq], smulColimit_smul_rep]
  apply hSMul_respect_Œπ
  ¬∑ rw [Concrete.Œπ_repColimit_eq]
  ¬∑ rw [Concrete.Œπ_repColimit_eq, Concrete.Œπ_repColimit_eq]

omit [‚àÄ (x y : ùîÑùîü), AddMonoidHomClass (x ‚ü∂ y) x y] in
@[simp]
lemma colimitsmulColimit_one_smul (m : colimit (C := ùîÑùîü) ‚Ñ≥) :
    colimitsmulColimit (1 : colimit (C := ‚Ñúùî¶ùî´ùî§) ‚Ñõ) m = m := by
  let c : J := (inferInstance : IsFiltered J).2.some
  rw [show (1 : colimit (C := ‚Ñúùî¶ùî´ùî§) ‚Ñõ) = colimit.Œπ ‚Ñõ c 1 by
    rw [map_one], colimitsmulColimit_rep_smul, smulColimit_one_smul]

omit [‚àÄ (x y : ùîÑùîü), AddMonoidHomClass (x ‚ü∂ y) x y] in
lemma colimitsmulColimit_mul_smul
    (r‚ÇÅ r‚ÇÇ : colimit (C := ‚Ñúùî¶ùî´ùî§) ‚Ñõ) (m : colimit (C := ùîÑùîü) ‚Ñ≥) :
    colimitsmulColimit (r‚ÇÅ * r‚ÇÇ) m = colimitsmulColimit r‚ÇÅ (colimitsmulColimit r‚ÇÇ m) := by
  classical
  let O : Finset J :=
    {  Concrete.indexRepColimit ‚Ñõ r‚ÇÅ, Concrete.indexRepColimit ‚Ñõ r‚ÇÇ }
  let j : J := IsFiltered.sup O ‚àÖ
  have eq‚ÇÅ : r‚ÇÅ = colimit.Œπ ‚Ñõ j
      (‚Ñõ.map (IsFiltered.toSup O ‚àÖ <| by simp [O]) (Concrete.repColimit ‚Ñõ r‚ÇÅ)) := by
    rw [colimit.w_apply, Concrete.Œπ_repColimit_eq]
  have eq‚ÇÇ : r‚ÇÇ = colimit.Œπ ‚Ñõ j
      (‚Ñõ.map (IsFiltered.toSup O ‚àÖ <| by simp [O]) (Concrete.repColimit ‚Ñõ r‚ÇÇ)) := by
    rw [colimit.w_apply, Concrete.Œπ_repColimit_eq]
  have eq‚ÇÉ : r‚ÇÅ * r‚ÇÇ = colimit.Œπ ‚Ñõ j
      (‚Ñõ.map (IsFiltered.toSup O ‚àÖ <| by simp [O]) (Concrete.repColimit ‚Ñõ r‚ÇÅ) *
       ‚Ñõ.map (IsFiltered.toSup O ‚àÖ <| by simp [O]) (Concrete.repColimit ‚Ñõ r‚ÇÇ)) := by
    rw [map_mul, colimit.w_apply, colimit.w_apply, Concrete.Œπ_repColimit_eq,
      Concrete.Œπ_repColimit_eq]
  rw [eq‚ÇÉ]
  conv_rhs => rw [eq‚ÇÅ]; rhs; rw [eq‚ÇÇ]
  rw [colimitsmulColimit_rep_smul, colimitsmulColimit_rep_smul, colimitsmulColimit_rep_smul,
    smulColimit_mul_smul]

omit [‚àÄ (x y : ‚Ñúùî¶ùî´ùî§), RingHomClass (x ‚ü∂ y) x y] in
@[simp]
lemma colimitsmulColimit_smul_zero (r : colimit (C := ‚Ñúùî¶ùî´ùî§) ‚Ñõ) :
    colimitsmulColimit (‚Ñ≥ := ‚Ñ≥) r 0 = 0 := by
  rw [show r = colimit.Œπ ‚Ñõ (Concrete.indexRepColimit ‚Ñõ r) _ by
    rw [Concrete.Œπ_repColimit_eq], colimitsmulColimit_rep_smul, smulColimit_smul_zero]

omit [‚àÄ (x y : ‚Ñúùî¶ùî´ùî§), RingHomClass (x ‚ü∂ y) x y] in
lemma colimitsmulColimit_smul_add (r : colimit (C := ‚Ñúùî¶ùî´ùî§) ‚Ñõ) (m‚ÇÅ m‚ÇÇ : colimit (C := ùîÑùîü) ‚Ñ≥) :
    colimitsmulColimit r (m‚ÇÅ + m‚ÇÇ) = colimitsmulColimit r m‚ÇÅ + colimitsmulColimit r m‚ÇÇ := by
  simp only [show r = colimit.Œπ ‚Ñõ (Concrete.indexRepColimit ‚Ñõ r) _ by
      rw [Concrete.Œπ_repColimit_eq],
    colimitsmulColimit_rep_smul, smulColimit_smul_add]

lemma colimitsmulColimit_add_smul (r‚ÇÅ r‚ÇÇ : colimit (C := ‚Ñúùî¶ùî´ùî§) ‚Ñõ) (m : colimit (C := ùîÑùîü) ‚Ñ≥) :
    colimitsmulColimit (r‚ÇÅ + r‚ÇÇ) m = colimitsmulColimit r‚ÇÅ m + colimitsmulColimit r‚ÇÇ m := by
  classical
  let O : Finset J :=
    {  Concrete.indexRepColimit ‚Ñõ r‚ÇÅ, Concrete.indexRepColimit ‚Ñõ r‚ÇÇ }
  let j : J := IsFiltered.sup O ‚àÖ
  have eq‚ÇÅ : r‚ÇÅ = colimit.Œπ ‚Ñõ j
      (‚Ñõ.map (IsFiltered.toSup O ‚àÖ <| by simp [O]) (Concrete.repColimit ‚Ñõ r‚ÇÅ)) := by
    rw [colimit.w_apply, Concrete.Œπ_repColimit_eq]
  have eq‚ÇÇ : r‚ÇÇ = colimit.Œπ ‚Ñõ j
      (‚Ñõ.map (IsFiltered.toSup O ‚àÖ <| by simp [O]) (Concrete.repColimit ‚Ñõ r‚ÇÇ)) := by
    rw [colimit.w_apply, Concrete.Œπ_repColimit_eq]
  have eq‚ÇÉ : r‚ÇÅ + r‚ÇÇ = colimit.Œπ ‚Ñõ j
      (‚Ñõ.map (IsFiltered.toSup O ‚àÖ <| by simp [O]) (Concrete.repColimit ‚Ñõ r‚ÇÅ) +
       ‚Ñõ.map (IsFiltered.toSup O ‚àÖ <| by simp [O]) (Concrete.repColimit ‚Ñõ r‚ÇÇ)) := by
    rw [map_add]
    rw [colimit.w_apply, colimit.w_apply, Concrete.Œπ_repColimit_eq, Concrete.Œπ_repColimit_eq]
  rw [eq‚ÇÉ]
  conv_rhs => rw [eq‚ÇÅ]; rhs; rw [eq‚ÇÇ]
  rw [colimitsmulColimit_rep_smul, colimitsmulColimit_rep_smul, colimitsmulColimit_rep_smul,
    smulColimit_add_smul]

@[simp]
lemma colimitsmulColimit_zero_smul (m : colimit (C := ùîÑùîü) ‚Ñ≥) :
    colimitsmulColimit (0 : colimit (C := ‚Ñúùî¶ùî´ùî§) ‚Ñõ) m = 0 := by
  let c : J := (inferInstance : IsFiltered J).2.some
  rw [show (0 : colimit (C := ‚Ñúùî¶ùî´ùî§) ‚Ñõ) = colimit.Œπ ‚Ñõ c 0 by rw [map_zero],
    colimitsmulColimit_rep_smul, smulColimit_zero_smul]

end colimitsmulColimit

noncomputable instance moduleColimitColimit :
    Module (colimit (C := ‚Ñúùî¶ùî´ùî§) ‚Ñõ) (colimit (C := ùîÑùîü) ‚Ñ≥) where
  smul := colimitsmulColimit
  one_smul := colimitsmulColimit_one_smul _ _
  mul_smul := colimitsmulColimit_mul_smul _ _
  smul_zero := colimitsmulColimit_smul_zero _ _
  smul_add := colimitsmulColimit_smul_add _ _
  add_smul := colimitsmulColimit_add_smul _ _
  zero_smul := colimitsmulColimit_zero_smul _ _

lemma smul_spec
    (j‚ÇÅ j‚ÇÇ j‚ÇÉ : J) (i‚ÇÅ : j‚ÇÅ ‚ü∂ j‚ÇÉ) (i‚ÇÇ : j‚ÇÇ ‚ü∂ j‚ÇÉ)
    (s : ‚Ñõ.obj j‚ÇÅ) (t : ‚Ñ≥.obj j‚ÇÇ) :
    colimit.Œπ ‚Ñõ j‚ÇÅ s ‚Ä¢ colimit.Œπ ‚Ñ≥ j‚ÇÇ t = colimit.Œπ ‚Ñ≥ j‚ÇÉ (‚Ñõ.map i‚ÇÅ s ‚Ä¢ ‚Ñ≥.map i‚ÇÇ t) :=
  show colimitsmulColimit _ _ = colimit.Œπ ‚Ñ≥ j‚ÇÉ (‚Ñõ.map i‚ÇÅ s ‚Ä¢ ‚Ñ≥.map i‚ÇÇ t) by
    rw [colimitsmulColimit_rep_smul, smulColimit_smul_rep]
    apply hSMul_respect_Œπ <;> rfl

/--
an alternative to `Module.overFilteredColimits.smul_spec` that assumes the same index throughout.
-/
lemma smul_spec' {j : J} (s : ‚Ñõ.obj j) (t : ‚Ñ≥.obj j) :
    colimit.Œπ ‚Ñõ j s ‚Ä¢ colimit.Œπ ‚Ñ≥ j t = colimit.Œπ ‚Ñ≥ j (s ‚Ä¢ t) := by
  simp only [smul_spec _ _ j j j (ùüô _) (ùüô _), CategoryTheory.Functor.map_id, id_apply]

end Module.overFilteredColimits

end module_over_filtered_colimit

end CategoryTheory.Limits.Concrete
