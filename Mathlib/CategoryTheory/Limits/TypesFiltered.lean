/-
Copyright (c) 2018 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison, Reid Barton
-/
import Mathlib.CategoryTheory.Limits.Types
import Mathlib.CategoryTheory.Filtered.Basic

#align_import category_theory.limits.types from "leanprover-community/mathlib"@"4aa2a2e17940311e47007f087c9df229e7f12942"

/-!
# Filtered colimits in the category of types.

We give a characterisation of the equality in filtered colimits in `Type` as a
lemma `CategoryTheory.Limits.Types.FilteredColimit.colimit_eq_iff`:
`colimit.Î¹ F i xi = colimit.Î¹ F j xj â†” âˆƒ k (f : i âŸ¶ k) (g : j âŸ¶ k), F.map f xi = F.map g xj`.

-/

open CategoryTheory CategoryTheory.Limits

universe v u w

namespace CategoryTheory.Limits.Types.FilteredColimit

variable {J : Type v} [Category.{w} J] (F : J â¥¤ Type u) [HasColimit F]

attribute [local instance] small_quot_of_hasColimit

/- For filtered colimits of types, we can give an explicit description
  of the equivalence relation generated by the relation used to form
  the colimit.  -/

/-- An alternative relation on `Î£ j, F.obj j`,
which generates the same equivalence relation as we use to define the colimit in `Type` above,
but that is more convenient when working with filtered colimits.

Elements in `F.obj j` and `F.obj j'` are equivalent if there is some `k : J` to the right
where their images are equal.
-/
protected def Rel (x y : Î£ j, F.obj j) : Prop :=
  âˆƒ (k : _) (f : x.1 âŸ¶ k) (g : y.1 âŸ¶ k), F.map f x.2 = F.map g y.2
#align category_theory.limits.types.filtered_colimit.rel CategoryTheory.Limits.Types.FilteredColimit.Rel

theorem rel_of_quot_rel (x y : Î£ j, F.obj j) :
    Quot.Rel F x y â†’ FilteredColimit.Rel.{v, u} F x y :=
  fun âŸ¨f, hâŸ© => âŸ¨y.1, f, ğŸ™ y.1, by rw [â† h, FunctorToTypes.map_id_apply]âŸ©
#align category_theory.limits.types.filtered_colimit.rel_of_quot_rel CategoryTheory.Limits.Types.FilteredColimit.rel_of_quot_rel

theorem eqvGen_quot_rel_of_rel (x y : Î£ j, F.obj j) :
    FilteredColimit.Rel.{v, u} F x y â†’ EqvGen (Quot.Rel F) x y := fun âŸ¨k, f, g, hâŸ© => by
  refine' EqvGen.trans _ âŸ¨k, F.map f x.2âŸ© _ _ _
  Â· exact (EqvGen.rel _ _ âŸ¨f, rflâŸ©)
  Â· exact (EqvGen.symm _ _ (EqvGen.rel _ _ âŸ¨g, hâŸ©))
#align category_theory.limits.types.filtered_colimit.eqv_gen_quot_rel_of_rel CategoryTheory.Limits.Types.FilteredColimit.eqvGen_quot_rel_of_rel

--attribute [local elab_without_expected_type] nat_trans.app

/-- Recognizing filtered colimits of types. -/
noncomputable def isColimitOf (t : Cocone F) (hsurj : âˆ€ x : t.pt, âˆƒ i xi, x = t.Î¹.app i xi)
    (hinj :
      âˆ€ i j xi xj,
        t.Î¹.app i xi = t.Î¹.app j xj â†’ âˆƒ (k : _) (f : i âŸ¶ k) (g : j âŸ¶ k), F.map f xi = F.map g xj) :
    IsColimit t := by
  -- Strategy: Prove that the map from "the" colimit of F (defined above) to t.X
  -- is a bijection.
  apply IsColimit.ofIsoColimit (colimit.isColimit F)
  refine' Cocones.ext (Equiv.toIso (Equiv.ofBijective _ _)) _
  Â· exact colimit.desc F t
  Â· constructor
    Â· show Function.Injective _
      intro a b h
      rcases jointly_surjective F (colimit.isColimit F) a with âŸ¨i, xi, rflâŸ©
      rcases jointly_surjective F (colimit.isColimit F) b with âŸ¨j, xj, rflâŸ©
      replace h : (colimit.Î¹ F i â‰« colimit.desc F t) xi = (colimit.Î¹ F j â‰« colimit.desc F t) xj := h
      rw [colimit.Î¹_desc, colimit.Î¹_desc] at h
      rcases hinj i j xi xj h with âŸ¨k, f, g, h'âŸ©
      change colimit.Î¹ F i xi = colimit.Î¹ F j xj
      rw [â† colimit.w F f, â† colimit.w F g]
      change colimit.Î¹ F k (F.map f xi) = colimit.Î¹ F k (F.map g xj)
      rw [h']
    Â· show Function.Surjective _
      intro x
      rcases hsurj x with âŸ¨i, xi, rflâŸ©
      use colimit.Î¹ F i xi
      apply Colimit.Î¹_desc_apply
  Â· intro j
    apply colimit.Î¹_desc
#align category_theory.limits.types.filtered_colimit.is_colimit_of CategoryTheory.Limits.Types.FilteredColimit.isColimitOf

variable [IsFilteredOrEmpty J]

protected theorem rel_equiv : _root_.Equivalence (FilteredColimit.Rel.{v, u} F) where
  refl x := âŸ¨x.1, ğŸ™ x.1, ğŸ™ x.1, rflâŸ©
  symm := fun âŸ¨k, f, g, hâŸ© => âŸ¨k, g, f, h.symmâŸ©
  trans {x y z} := fun âŸ¨k, f, g, hâŸ© âŸ¨k', f', g', h'âŸ© =>
    let âŸ¨l, fl, gl, _âŸ© := IsFilteredOrEmpty.cocone_objs k k'
    let âŸ¨m, n, hnâŸ© := IsFilteredOrEmpty.cocone_maps (g â‰« fl) (f' â‰« gl)
    âŸ¨m, f â‰« fl â‰« n, g' â‰« gl â‰« n,
      calc
        F.map (f â‰« fl â‰« n) x.2 = F.map (fl â‰« n) (F.map f x.2) := by simp
        _ = F.map (fl â‰« n) (F.map g y.2) := by rw [h]
        _ = F.map ((g â‰« fl) â‰« n) y.2 := by simp
        _ = F.map ((f' â‰« gl) â‰« n) y.2 := by rw [hn]
        _ = F.map (gl â‰« n) (F.map f' y.2) := by simp
        _ = F.map (gl â‰« n) (F.map g' z.2) := by rw [h']
        _ = F.map (g' â‰« gl â‰« n) z.2 := by simpâŸ©
#align category_theory.limits.types.filtered_colimit.rel_equiv CategoryTheory.Limits.Types.FilteredColimit.rel_equiv

protected theorem rel_eq_eqvGen_quot_rel :
    FilteredColimit.Rel.{v, u} F = EqvGen (Quot.Rel F) := by
  ext âŸ¨j, xâŸ© âŸ¨j', yâŸ©
  constructor
  Â· apply eqvGen_quot_rel_of_rel
  Â· rw [â† (FilteredColimit.rel_equiv F).eqvGen_iff]
    exact EqvGen.mono (rel_of_quot_rel F)
#align category_theory.limits.types.filtered_colimit.rel_eq_eqv_gen_quot_rel CategoryTheory.Limits.Types.FilteredColimit.rel_eq_eqvGen_quot_rel

theorem colimit_eq_iff_aux {i j : J} {xi : F.obj i} {xj : F.obj j} :
    (colimitCocone F).Î¹.app i xi = (colimitCocone F).Î¹.app j xj â†”
      FilteredColimit.Rel.{v, u} F âŸ¨i, xiâŸ© âŸ¨j, xjâŸ© := by
  dsimp
  rw [â† (equivShrink _).symm.injective.eq_iff, Equiv.symm_apply_apply, Equiv.symm_apply_apply,
    Quot.eq, FilteredColimit.rel_eq_eqvGen_quot_rel]
#align category_theory.limits.types.filtered_colimit.colimit_eq_iff_aux CategoryTheory.Limits.Types.FilteredColimit.colimit_eq_iff_aux

theorem isColimit_eq_iff {t : Cocone F} (ht : IsColimit t) {i j : J} {xi : F.obj i} {xj : F.obj j} :
    t.Î¹.app i xi = t.Î¹.app j xj â†” âˆƒ (k : _) (f : i âŸ¶ k) (g : j âŸ¶ k), F.map f xi = F.map g xj := by
  refine' Iff.trans _ (colimit_eq_iff_aux F)
  rw [â† (IsColimit.coconePointUniqueUpToIso ht (colimitCoconeIsColimit F)).toEquiv.injective.eq_iff]
  convert Iff.rfl
  Â· exact (congrFun
      (IsColimit.comp_coconePointUniqueUpToIso_hom ht (colimitCoconeIsColimit F) _) xi).symm
  Â· exact (congrFun
      (IsColimit.comp_coconePointUniqueUpToIso_hom ht (colimitCoconeIsColimit F) _) xj).symm
#align category_theory.limits.types.filtered_colimit.is_colimit_eq_iff CategoryTheory.Limits.Types.FilteredColimit.isColimit_eq_iff

theorem colimit_eq_iff {i j : J} {xi : F.obj i} {xj : F.obj j} :
    colimit.Î¹ F i xi = colimit.Î¹ F j xj â†”
      âˆƒ (k : _) (f : i âŸ¶ k) (g : j âŸ¶ k), F.map f xi = F.map g xj :=
  isColimit_eq_iff _ (colimit.isColimit F)
#align category_theory.limits.types.filtered_colimit.colimit_eq_iff CategoryTheory.Limits.Types.FilteredColimit.colimit_eq_iff

end CategoryTheory.Limits.Types.FilteredColimit
