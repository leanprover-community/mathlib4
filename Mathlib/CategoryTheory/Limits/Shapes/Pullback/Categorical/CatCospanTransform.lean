/-
Copyright (c) 2025 Robin Carlier. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Robin Carlier
-/
import Mathlib.CategoryTheory.CatCommSq

/-! # Morphisms of categorical cospans.

Given `F : A ‚•§ B`, `G : C ‚•§ B`, `F' : A' ‚•§ B'` and `G' : C' ‚•§ B'`,
this files defines `CatCospanTransform F G F' G'`, the category of
"categorical transformations" from the (categorical) cospan `F G` to
the (categorical) cospan `F' G'`. Such a transformation consists of a
diagram

```
    F   G
  A ‚•§ B ‚•¢ C
H‚ÇÅ|   |H‚ÇÇ |H‚ÇÉ
  v   v   v
  A'‚•§ B'‚•¢ C'
    F'  G'
```

with specified `CatCommSq`s expressing 2-commutativity of the squares. These
transformations are used to encode 2-functoriality of categorical pullback squares.
-/

namespace CategoryTheory.Limits

universe v‚ÇÅ v‚ÇÇ v‚ÇÉ v‚ÇÑ v‚ÇÖ v‚ÇÜ v‚Çá v‚Çà v‚Çâ v‚ÇÅ‚ÇÄ v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÇ v‚ÇÅ‚ÇÉ v‚ÇÅ‚ÇÑ v‚ÇÅ‚ÇÖ
universe u‚ÇÅ u‚ÇÇ u‚ÇÉ u‚ÇÑ u‚ÇÖ u‚ÇÜ u‚Çá u‚Çà u‚Çâ u‚ÇÅ‚ÇÄ u‚ÇÅ‚ÇÅ u‚ÇÅ‚ÇÇ u‚ÇÅ‚ÇÉ u‚ÇÅ‚ÇÑ u‚ÇÅ‚ÇÖ

/-- A `CatCospanTransform F G F' G'` is a diagram
```
    F   G
  A ‚•§ B ‚•¢ C
H‚ÇÅ|   |H‚ÇÇ |H‚ÇÉ
  v   v   v
  A'‚•§ B'‚•¢ C'
    F'  G'
```
with specified `CatCommSq`s expressing 2-commutativity of the squares. -/
structure CatCospanTransform
    {A : Type u‚ÇÅ} {B : Type u‚ÇÇ} {C : Type u‚ÇÉ}
    [Category.{v‚ÇÅ} A] [Category.{v‚ÇÇ} B] [Category.{v‚ÇÉ} C]
    (F : A ‚•§ B) (G : C ‚•§ B)
    {A' : Type u‚ÇÑ} {B' : Type u‚ÇÖ} {C' : Type u‚ÇÜ}
    [Category.{v‚ÇÑ} A'] [Category.{v‚ÇÖ} B'] [Category.{v‚ÇÜ} C']
    (F' : A' ‚•§ B') (G' : C' ‚•§ B') where
  /-- the functor on the left component -/
  left : A ‚•§ A'
  /-- the functor on the base component -/
  base : B ‚•§ B'
  /-- the functor on the right component -/
  right : C ‚•§ C'
  /-- a `CatCommSq` bundling the natural isomorphism `F ‚ãô base ‚âÖ left ‚ãô F'`. -/
  squareLeft : CatCommSq F left base F' := by infer_instance
  /-- a `CatCommSq` bundling the natural isomorphism `G ‚ãô base ‚âÖ right ‚ãô G'`. -/
  squareRight : CatCommSq G right base G' := by infer_instance

namespace CatCospanTransform

section

variable {A : Type u‚ÇÅ} {B : Type u‚ÇÇ} {C : Type u‚ÇÉ}
  [Category.{v‚ÇÅ} A] [Category.{v‚ÇÇ} B] [Category.{v‚ÇÉ} C]
  (F : A ‚•§ B) (G : C ‚•§ B)

attribute [local instance] CatCommSq.vId in
/-- The identity `CatCospanTransform` -/
@[simps]
def id : CatCospanTransform F G F G where
  left := ùü≠ A
  base := ùü≠ B
  right := ùü≠ C

variable {F G}
/-- Composition of `CatCospanTransforms` is defined "componentwise". -/
@[simps]
def comp
    {A' : Type u‚ÇÑ} {B' : Type u‚ÇÖ} {C' : Type u‚ÇÜ}
    [Category.{v‚ÇÑ} A'] [Category.{v‚ÇÖ} B'] [Category.{v‚ÇÜ} C']
    {F' : A' ‚•§ B'} {G' : C' ‚•§ B'}
    {A'' : Type u‚Çá} {B'' : Type u‚Çà} {C'' : Type u‚Çâ}
    [Category.{v‚Çá} A''] [Category.{v‚Çà} B''] [Category.{v‚Çâ} C'']
    {F'' : A'' ‚•§ B''} {G'' : C'' ‚•§ B''}
    (œà : CatCospanTransform F G F' G') (œà' : CatCospanTransform F' G' F'' G'') :
    CatCospanTransform F G F'' G'' where
  left := œà.left ‚ãô œà'.left
  base := œà.base ‚ãô œà'.base
  right := œà.right ‚ãô œà'.right
  squareLeft := œà.squareLeft.vComp' œà'.squareLeft
  squareRight := œà.squareRight.vComp' œà'.squareRight

end

end CatCospanTransform

variable {A : Type u‚ÇÅ} {B : Type u‚ÇÇ} {C : Type u‚ÇÉ}
    {A' : Type u‚ÇÑ} {B' : Type u‚ÇÖ} {C' : Type u‚ÇÜ}
    {A'' : Type u‚Çá} {B'' : Type u‚Çà} {C'' : Type u‚Çâ}
    [Category.{v‚ÇÅ} A] [Category.{v‚ÇÇ} B] [Category.{v‚ÇÉ} C]
    {F : A ‚•§ B} {G : C ‚•§ B}
    [Category.{v‚ÇÑ} A'] [Category.{v‚ÇÖ} B'] [Category.{v‚ÇÜ} C']
    {F' : A' ‚•§ B'} {G' : C' ‚•§ B'}
    [Category.{v‚Çá} A''] [Category.{v‚Çà} B''] [Category.{v‚Çâ} C'']
    {F'' : A'' ‚•§ B''} {G'' : C'' ‚•§ B''}

/-- A morphism of `CatCospanTransform F G F' G'` is a triple of natural
transformations between the component functors, subjects to
coherence conditions respective to the squares. -/
structure CatCospanTransformMorphism
    (œà œà' : CatCospanTransform F G F' G') where
  /-- the natural transformations between the left components -/
  left : œà.left ‚ü∂ œà'.left
  /-- the natural transformations between the right components -/
  right : œà.right ‚ü∂ œà'.right
  /-- the natural transformations between the base components -/
  base : œà.base ‚ü∂ œà'.base
  /-- the coherence condition for the left square -/
  left_coherence :
      œà.squareLeft.iso.hom ‚â´ Functor.whiskerRight left F' =
      Functor.whiskerLeft F base ‚â´ œà'.squareLeft.iso.hom := by
    aesop_cat
  /-- the coherence condition for the right square -/
  right_coherence :
      œà.squareRight.iso.hom ‚â´ Functor.whiskerRight right G' =
      Functor.whiskerLeft G base ‚â´ œà'.squareRight.iso.hom := by
    aesop_cat

namespace CatCospanTransform

attribute [reassoc (attr := simp)]
  CatCospanTransformMorphism.left_coherence
  CatCospanTransformMorphism.right_coherence

@[simps]
instance category : Category (CatCospanTransform F G F' G') where
  Hom œà œà' := CatCospanTransformMorphism œà œà'
  id œà :=
    { left := ùüô _
      right := ùüô _
      base := ùüô _ }
  comp Œ± Œ≤ :=
    { left := Œ±.left ‚â´ Œ≤.left
      right := Œ±.right ‚â´ Œ≤.right
      base := Œ±.base ‚â´ Œ≤.base}

attribute [local ext] CatCospanTransformMorphism in
@[ext]
lemma hom_ext {œà œà' : CatCospanTransform F G F' G'} {Œ∏ Œ∏' : œà ‚ü∂ œà'}
    (hl : Œ∏.left = Œ∏'.left) (hr : Œ∏.right = Œ∏'.right) (hb : Œ∏.base = Œ∏'.base) :
    Œ∏ = Œ∏' := by
  apply CatCospanTransformMorphism.ext <;> assumption

end CatCospanTransform

namespace CatCospanTransformMorphism

@[reassoc (attr := simp)]
lemma left_coherence_app {œà œà' : CatCospanTransform F G F' G'}
    (Œ± : œà ‚ü∂ œà') (x : A) :
    œà.squareLeft.iso.hom.app x ‚â´ F'.map (Œ±.left.app x) =
    Œ±.base.app (F.obj x) ‚â´ œà'.squareLeft.iso.hom.app x :=
  congr_app Œ±.left_coherence x

@[reassoc (attr := simp)]
lemma right_coherence_app {œà œà' : CatCospanTransform F G F' G'}
    (Œ± : œà ‚ü∂ œà') (x : C) :
    œà.squareRight.iso.hom.app x ‚â´ G'.map (Œ±.right.app x) =
    Œ±.base.app (G.obj x) ‚â´ œà'.squareRight.iso.hom.app x :=
  congr_app Œ±.right_coherence x

/-- Whiskering left of a `CatCospanTransformMorphism` by a `CatCospanTransform`. -/
@[simps]
def whiskerLeft (œÜ : CatCospanTransform F G F' G')
    {œà œà' : CatCospanTransform F' G' F'' G''} (Œ± : œà ‚ü∂ œà') :
    (œÜ.comp œà) ‚ü∂ (œÜ.comp œà') where
  left := Functor.whiskerLeft œÜ.left Œ±.left
  right := Functor.whiskerLeft œÜ.right Œ±.right
  base := Functor.whiskerLeft œÜ.base Œ±.base

/-- Whiskering right of a `CatCospanTransformMorphism` by a `CatCospanTransform`. -/
@[simps]
def whiskerRight {œà œà' : CatCospanTransform F G F' G'} (Œ± : œà ‚ü∂ œà')
    (œÜ : CatCospanTransform F' G' F'' G'') :
    (œà.comp œÜ) ‚ü∂ (œà'.comp œÜ) where
  left := Functor.whiskerRight Œ±.left œÜ.left
  right := Functor.whiskerRight Œ±.right œÜ.right
  base := Functor.whiskerRight Œ±.base œÜ.base
  left_coherence := by
    ext x
    dsimp
    simp only [CatCommSq.vComp_iso_hom_app, Category.assoc]
    rw [‚Üê Functor.map_comp_assoc, ‚Üê left_coherence_app, Functor.map_comp_assoc]
    simp
  right_coherence := by
    ext x
    dsimp
    simp only [CatCommSq.vComp_iso_hom_app, Category.assoc]
    rw [‚Üê Functor.map_comp_assoc, ‚Üê right_coherence_app, Functor.map_comp_assoc]
    simp

end CatCospanTransformMorphism

namespace CatCospanTransform

/-- A constructor for isomorphisms of `CatCospanTransform`'s. -/
@[simps]
def mkIso {œà œà' : CatCospanTransform F G F' G'}
    (left : œà.left ‚âÖ œà'.left) (right : œà.right ‚âÖ œà'.right)
    (base : œà.base ‚âÖ œà'.base)
    (left_coherence :
        œà.squareLeft.iso.hom ‚â´ Functor.whiskerRight left.hom F' =
        Functor.whiskerLeft F base.hom ‚â´ œà'.squareLeft.iso.hom := by
      aesop_cat)
    (right_coherence :
        œà.squareRight.iso.hom ‚â´ Functor.whiskerRight right.hom G' =
        Functor.whiskerLeft G base.hom ‚â´ œà'.squareRight.iso.hom := by
      aesop_cat) :
    œà ‚âÖ œà' where
  hom :=
    { left := left.hom
      right := right.hom
      base := base.hom }
  inv :=
    { left := left.inv
      right := right.inv
      base := base.inv
      left_coherence := by
        simpa using œà'.squareLeft.iso.hom ‚â´=
          IsIso.inv_eq_inv.mpr left_coherence =‚â´
          œà.squareLeft.iso.hom
      right_coherence := by
        simpa using œà'.squareRight.iso.hom ‚â´=
          IsIso.inv_eq_inv.mpr right_coherence =‚â´
          œà.squareRight.iso.hom }

/-- The left unitor isomorphism for categorical cospan transformations. -/
@[simps!]
def leftUnitor (œÜ : CatCospanTransform F G F' G') :
    (CatCospanTransform.id F G).comp œÜ ‚âÖ œÜ :=
  mkIso œÜ.left.leftUnitor œÜ.right.leftUnitor œÜ.base.leftUnitor

/-- The right unitor isomorphism for categorical cospan transformations. -/
@[simps!]
def rightUnitor (œÜ : CatCospanTransform F G F' G') :
    œÜ.comp (.id F' G') ‚âÖ œÜ :=
  mkIso œÜ.left.rightUnitor œÜ.right.rightUnitor œÜ.base.rightUnitor

/-- The associator isomorphism for categorical cospan transformations. -/
@[simps!]
def associator {A''' : Type u‚ÇÅ‚ÇÄ} {B''' : Type u‚ÇÅ‚ÇÅ} {C''' : Type u‚ÇÅ‚ÇÇ}
    [Category.{v‚ÇÅ‚ÇÄ} A'''] [Category.{v‚ÇÅ‚ÇÅ} B'''] [Category.{v‚ÇÅ‚ÇÇ} C''']
    {F''' : A''' ‚•§ B'''} {G''' : C''' ‚•§ B'''}
    (œÜ : CatCospanTransform F G F' G') (œÜ' : CatCospanTransform F' G' F'' G'')
    (œÜ'' : CatCospanTransform F'' G'' F''' G''') :
    (œÜ.comp œÜ').comp œÜ'' ‚âÖ œÜ.comp (œÜ'.comp œÜ'') :=
  mkIso
    (œÜ.left.associator œÜ'.left œÜ''.left)
    (œÜ.right.associator œÜ'.right œÜ''.right)
    (œÜ.base.associator œÜ'.base œÜ''.base)

section lemmas

-- We scope the notations with notations from bicategories to make life easier.
-- Due to performance issues, these notations should not be in scope at the same time
-- as the ones in bicategories.

@[inherit_doc] scoped infixr:81 " ‚óÅ " => CatCospanTransformMorphism.whiskerLeft
@[inherit_doc] scoped infixl:81 " ‚ñ∑ " => CatCospanTransformMorphism.whiskerRight
@[inherit_doc] scoped notation "Œ±_" => CatCospanTransform.associator
@[inherit_doc] scoped notation "Œª_" => CatCospanTransform.leftUnitor
@[inherit_doc] scoped notation "œÅ_" => CatCospanTransform.rightUnitor

variable
    {A''' : Type u‚ÇÅ‚ÇÄ} {B''' : Type u‚ÇÅ‚ÇÅ} {C''' : Type u‚ÇÅ‚ÇÇ}
    [Category.{v‚ÇÅ‚ÇÄ} A'''] [Category.{v‚ÇÅ‚ÇÅ} B'''] [Category.{v‚ÇÅ‚ÇÇ} C''']
    {F''' : A''' ‚•§ B'''} {G''' : C''' ‚•§ B'''}
    {œà œà' œà'' : CatCospanTransform F G F' G'}
    (Œ∑ : œà ‚ü∂ œà') (Œ∑' : œà' ‚ü∂ œà'')
    {œÜ œÜ' œÜ'' : CatCospanTransform F' G' F'' G''}
    (Œ∏ : œÜ ‚ü∂ œÜ') (Œ∏' : œÜ' ‚ü∂ œÜ'')
    {œÑ œÑ' : CatCospanTransform F'' G'' F''' G'''}
    (Œ≥ : œÑ ‚ü∂ œÑ')

@[reassoc]
lemma whisker_exchange : œà ‚óÅ Œ∏ ‚â´ Œ∑ ‚ñ∑ œÜ' = Œ∑ ‚ñ∑ œÜ ‚â´ œà' ‚óÅ Œ∏ := by aesop_cat

@[simp]
lemma id_whiskerRight : ùüô œà ‚ñ∑ œÜ = ùüô _ := by aesop_cat

@[reassoc]
lemma whiskerRight_id : Œ∑ ‚ñ∑ (.id _ _) = (œÅ_ _).hom ‚â´ Œ∑ ‚â´ (œÅ_ _).inv := by aesop_cat

@[simp, reassoc]
lemma comp_whiskerRight : (Œ∑ ‚â´ Œ∑') ‚ñ∑ œÜ = Œ∑ ‚ñ∑ œÜ ‚â´ Œ∑' ‚ñ∑ œÜ := by aesop_cat

@[reassoc]
lemma whiskerRight_comp :
    Œ∑ ‚ñ∑ (œÜ.comp œÑ) = (Œ±_ _ _ _).inv ‚â´ (Œ∑ ‚ñ∑ œÜ) ‚ñ∑ œÑ ‚â´ (Œ±_ _ _ _ ).hom := by
  aesop_cat

@[simp]
lemma whiskerleft_id : œà ‚óÅ ùüô œÜ = ùüô _ := by aesop_cat

@[reassoc]
lemma id_whiskerLeft : (.id _ _) ‚óÅ Œ∑ = (Œª_ _).hom ‚â´ Œ∑ ‚â´ (Œª_ _).inv := by aesop_cat

@[simp, reassoc]
lemma whiskerLeft_comp : œà ‚óÅ (Œ∏ ‚â´ Œ∏') = (œà ‚óÅ Œ∏) ‚â´ (œà ‚óÅ Œ∏') := by aesop_cat

@[reassoc]
lemma comp_whiskerLeft :
    (œà.comp œÜ) ‚óÅ Œ≥ = (Œ±_ _ _ _).hom ‚â´ (œà ‚óÅ (œÜ ‚óÅ Œ≥)) ‚â´ (Œ±_ _ _ _).inv := by
  aesop_cat

@[reassoc]
lemma pentagon
    {A'''' : Type u‚ÇÅ‚ÇÉ} {B'''' : Type u‚ÇÅ‚ÇÑ} {C'''' : Type u‚ÇÅ‚ÇÖ}
    [Category.{v‚ÇÅ‚ÇÉ} A''''] [Category.{v‚ÇÅ‚ÇÑ} B''''] [Category.{v‚ÇÅ‚ÇÖ} C'''']
    {F'''' : A'''' ‚•§ B''''} {G'''' : C'''' ‚•§ B''''}
    {œÉ : CatCospanTransform F''' G''' F'''' G''''} :
    (Œ±_ œà œÜ œÑ).hom ‚ñ∑ œÉ ‚â´ (Œ±_ œà (œÜ.comp œÑ) œÉ).hom ‚â´ œà ‚óÅ (Œ±_ œÜ œÑ œÉ).hom =
      (Œ±_ (œà.comp œÜ) œÑ œÉ).hom ‚â´ (Œ±_ œà œÜ (œÑ.comp œÉ)).hom := by
  aesop_cat

@[reassoc]
lemma triangle :
    (Œ±_ œà (.id _ _) œÜ).hom ‚â´ œà ‚óÅ (Œª_ œÜ).hom = (œÅ_ œà).hom ‚ñ∑ œÜ := by
  aesop_cat

@[reassoc]
lemma triangle_inv :
     (Œ±_ œà (.id _ _) œÜ).inv ‚â´ (œÅ_ œà).hom ‚ñ∑ œÜ = œà ‚óÅ (Œª_ œÜ).hom := by
  aesop_cat

section Isos

variable {œà œà' : CatCospanTransform F G F' G'} (Œ∑ : œà ‚ü∂ œà') [IsIso Œ∑]
    {œÜ œÜ' : CatCospanTransform F' G' F'' G''} (Œ∏ : œÜ ‚ü∂ œÜ') [IsIso Œ∏]

instance : IsIso (œà ‚óÅ Œ∏) :=
    ‚ü®œà ‚óÅ inv Œ∏, ‚ü®by simp [‚Üê whiskerLeft_comp], by simp [‚Üê whiskerLeft_comp]‚ü©‚ü©

lemma inv_whiskerLeft : inv (œà ‚óÅ Œ∏) = œà ‚óÅ inv Œ∏ := by
  apply IsIso.inv_eq_of_hom_inv_id
  simp [‚Üê whiskerLeft_comp]

instance : IsIso (Œ∑ ‚ñ∑ œÜ) :=
    ‚ü®inv Œ∑ ‚ñ∑ œÜ, ‚ü®by simp [‚Üê comp_whiskerRight], by simp [‚Üê comp_whiskerRight]‚ü©‚ü©

lemma inv_whiskerRight : inv (Œ∑ ‚ñ∑ œÜ) = inv Œ∑ ‚ñ∑ œÜ := by
  apply IsIso.inv_eq_of_hom_inv_id
  simp [‚Üê comp_whiskerRight]

end Isos

end lemmas

end CatCospanTransform

end CategoryTheory.Limits
