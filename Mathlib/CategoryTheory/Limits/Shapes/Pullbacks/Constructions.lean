/-
Copyright (c) 2018 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison, Markus Himmel, Bhavik Mehta, Andrew Yang, Emily Riehl
-/

import Mathlib.CategoryTheory.Limits.Shapes.Pullbacks.HasPullback
import Mathlib.CategoryTheory.Limits.Shapes.Pullbacks.Mono

#align_import category_theory.limits.shapes.pullbacks from "leanprover-community/mathlib"@"7316286ff2942aa14e540add9058c6b0aa1c8070"

/-!
# Constructions with pullbacks

The file `Pullbacks/Diagrams.lean` provides results for some different constructions using
pullbacks. The dual results for pushouts are also available in this file.

## Main results
* The pullback by an isomorphism.

* Pasting laws

* Associativity of pullbacks

-/

noncomputable section

open CategoryTheory

universe w v‚ÇÅ v‚ÇÇ v u u‚ÇÇ

namespace CategoryTheory.Limits

open WalkingSpan.Hom WalkingCospan.Hom WidePullbackShape.Hom WidePushoutShape.Hom

variable {C : Type u} [Category.{v} C] {W X Y Z : C}

section PullbackLeftIso

open WalkingCospan

-- TODO: this could go in pullback cone.... (would allow mono to move elsewhere)
variable (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [IsIso f]

/-- If `f : X ‚ü∂ Z` is iso, then `X √ó[Z] Y ‚âÖ Y`. This is the explicit limit cone. -/
def pullbackConeOfLeftIso : PullbackCone f g :=
  PullbackCone.mk (g ‚â´ inv f) (ùüô _) <| by simp
#align category_theory.limits.pullback_cone_of_left_iso CategoryTheory.Limits.pullbackConeOfLeftIso

@[simp]
theorem pullbackConeOfLeftIso_x : (pullbackConeOfLeftIso f g).pt = Y := rfl
set_option linter.uppercaseLean3 false in
#align category_theory.limits.pullback_cone_of_left_iso_X CategoryTheory.Limits.pullbackConeOfLeftIso_x

@[simp]
theorem pullbackConeOfLeftIso_fst : (pullbackConeOfLeftIso f g).fst = g ‚â´ inv f := rfl
#align category_theory.limits.pullback_cone_of_left_iso_fst CategoryTheory.Limits.pullbackConeOfLeftIso_fst

@[simp]
theorem pullbackConeOfLeftIso_snd : (pullbackConeOfLeftIso f g).snd = ùüô _ := rfl
#align category_theory.limits.pullback_cone_of_left_iso_snd CategoryTheory.Limits.pullbackConeOfLeftIso_snd

-- Porting note (#10618): simp can prove this; removed simp
theorem pullbackConeOfLeftIso_œÄ_app_none : (pullbackConeOfLeftIso f g).œÄ.app none = g := by simp
#align category_theory.limits.pullback_cone_of_left_iso_œÄ_app_none CategoryTheory.Limits.pullbackConeOfLeftIso_œÄ_app_none

@[simp]
theorem pullbackConeOfLeftIso_œÄ_app_left : (pullbackConeOfLeftIso f g).œÄ.app left = g ‚â´ inv f :=
  rfl
#align category_theory.limits.pullback_cone_of_left_iso_œÄ_app_left CategoryTheory.Limits.pullbackConeOfLeftIso_œÄ_app_left

@[simp]
theorem pullbackConeOfLeftIso_œÄ_app_right : (pullbackConeOfLeftIso f g).œÄ.app right = ùüô _ := rfl
#align category_theory.limits.pullback_cone_of_left_iso_œÄ_app_right CategoryTheory.Limits.pullbackConeOfLeftIso_œÄ_app_right

/-- Verify that the constructed limit cone is indeed a limit. -/
def pullbackConeOfLeftIsoIsLimit : IsLimit (pullbackConeOfLeftIso f g) :=
  PullbackCone.isLimitAux' _ fun s => ‚ü®s.snd, by simp [‚Üê s.condition_assoc]‚ü©
#align category_theory.limits.pullback_cone_of_left_iso_is_limit CategoryTheory.Limits.pullbackConeOfLeftIsoIsLimit

theorem hasPullback_of_left_iso : HasPullback f g :=
  ‚ü®‚ü®‚ü®_, pullbackConeOfLeftIsoIsLimit f g‚ü©‚ü©‚ü©
#align category_theory.limits.has_pullback_of_left_iso CategoryTheory.Limits.hasPullback_of_left_iso

attribute [local instance] hasPullback_of_left_iso

instance pullback_snd_iso_of_left_iso : IsIso (pullback.snd : pullback f g ‚ü∂ _) := by
  refine ‚ü®‚ü®pullback.lift (g ‚â´ inv f) (ùüô _) (by simp), ?_, by simp‚ü©‚ü©
  ext
  ¬∑ simp [‚Üê pullback.condition_assoc]
  ¬∑ simp [pullback.condition_assoc]
#align category_theory.limits.pullback_snd_iso_of_left_iso CategoryTheory.Limits.pullback_snd_iso_of_left_iso

variable (i : Z ‚ü∂ W) [Mono i]

-- TODO: can golf this easily w/ nth_rw + exact (or just simpa only!)
instance hasPullback_of_right_factors_mono (f : X ‚ü∂ Z) : HasPullback i (f ‚â´ i) := by
  conv =>
    congr
    rw [‚Üê Category.id_comp i]
  infer_instance
#align category_theory.limits.has_pullback_of_right_factors_mono CategoryTheory.Limits.hasPullback_of_right_factors_mono

instance pullback_snd_iso_of_right_factors_mono (f : X ‚ü∂ Z) :
    IsIso (pullback.snd : pullback i (f ‚â´ i) ‚ü∂ _) := by
  #adaptation_note /-- nightly-testing 2024-04-01
  this could not be placed directly in the `show from` without `dsimp` -/
  have := limit.isoLimitCone_hom_œÄ ‚ü®_, pullbackIsPullbackOfCompMono (ùüô _) f i‚ü© WalkingCospan.right
  dsimp only [cospan_right, id_eq, eq_mpr_eq_cast, PullbackCone.mk_pt, PullbackCone.mk_œÄ_app,
    Functor.const_obj_obj, cospan_one] at this
  convert (congrArg IsIso (show _ ‚â´ pullback.snd = _ from this)).mp inferInstance
  ¬∑ exact (Category.id_comp _).symm
  ¬∑ exact (Category.id_comp _).symm
#align category_theory.limits.pullback_snd_iso_of_right_factors_mono CategoryTheory.Limits.pullback_snd_iso_of_right_factors_mono

end PullbackLeftIso

section PullbackRightIso

open WalkingCospan

variable (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [IsIso g]

/-- If `g : Y ‚ü∂ Z` is iso, then `X √ó[Z] Y ‚âÖ X`. This is the explicit limit cone. -/
def pullbackConeOfRightIso : PullbackCone f g :=
  PullbackCone.mk (ùüô _) (f ‚â´ inv g) <| by simp
#align category_theory.limits.pullback_cone_of_right_iso CategoryTheory.Limits.pullbackConeOfRightIso

@[simp]
theorem pullbackConeOfRightIso_x : (pullbackConeOfRightIso f g).pt = X := rfl
set_option linter.uppercaseLean3 false in
#align category_theory.limits.pullback_cone_of_right_iso_X CategoryTheory.Limits.pullbackConeOfRightIso_x

@[simp]
theorem pullbackConeOfRightIso_fst : (pullbackConeOfRightIso f g).fst = ùüô _ := rfl
#align category_theory.limits.pullback_cone_of_right_iso_fst CategoryTheory.Limits.pullbackConeOfRightIso_fst

@[simp]
theorem pullbackConeOfRightIso_snd : (pullbackConeOfRightIso f g).snd = f ‚â´ inv g := rfl
#align category_theory.limits.pullback_cone_of_right_iso_snd CategoryTheory.Limits.pullbackConeOfRightIso_snd

-- Porting note (#10618): simp can prove this; removed simps
theorem pullbackConeOfRightIso_œÄ_app_none : (pullbackConeOfRightIso f g).œÄ.app none = f := by simp
#align category_theory.limits.pullback_cone_of_right_iso_œÄ_app_none CategoryTheory.Limits.pullbackConeOfRightIso_œÄ_app_none

@[simp]
theorem pullbackConeOfRightIso_œÄ_app_left : (pullbackConeOfRightIso f g).œÄ.app left = ùüô _ :=
  rfl
#align category_theory.limits.pullback_cone_of_right_iso_œÄ_app_left CategoryTheory.Limits.pullbackConeOfRightIso_œÄ_app_left

@[simp]
theorem pullbackConeOfRightIso_œÄ_app_right : (pullbackConeOfRightIso f g).œÄ.app right = f ‚â´ inv g :=
  rfl
#align category_theory.limits.pullback_cone_of_right_iso_œÄ_app_right CategoryTheory.Limits.pullbackConeOfRightIso_œÄ_app_right

/-- Verify that the constructed limit cone is indeed a limit. -/
def pullbackConeOfRightIsoIsLimit : IsLimit (pullbackConeOfRightIso f g) :=
  PullbackCone.isLimitAux' _ fun s => ‚ü®s.fst, by simp [s.condition_assoc]‚ü©
#align category_theory.limits.pullback_cone_of_right_iso_is_limit CategoryTheory.Limits.pullbackConeOfRightIsoIsLimit

theorem hasPullback_of_right_iso : HasPullback f g :=
  ‚ü®‚ü®‚ü®_, pullbackConeOfRightIsoIsLimit f g‚ü©‚ü©‚ü©
#align category_theory.limits.has_pullback_of_right_iso CategoryTheory.Limits.hasPullback_of_right_iso

attribute [local instance] hasPullback_of_right_iso

instance pullback_snd_iso_of_right_iso : IsIso (pullback.fst : pullback f g ‚ü∂ _) := by
  refine ‚ü®‚ü®pullback.lift (ùüô _) (f ‚â´ inv g) (by simp), ?_, by simp‚ü©‚ü©
  ext
  ¬∑ simp
  ¬∑ simp [pullback.condition_assoc]
#align category_theory.limits.pullback_snd_iso_of_right_iso CategoryTheory.Limits.pullback_snd_iso_of_right_iso

variable (i : Z ‚ü∂ W) [Mono i]

instance hasPullback_of_left_factors_mono (f : X ‚ü∂ Z) : HasPullback (f ‚â´ i) i := by
  conv =>
    congr
    case g => rw [‚Üê Category.id_comp i]
  infer_instance
#align category_theory.limits.has_pullback_of_left_factors_mono CategoryTheory.Limits.hasPullback_of_left_factors_mono

instance pullback_snd_iso_of_left_factors_mono (f : X ‚ü∂ Z) :
    IsIso (pullback.fst : pullback (f ‚â´ i) i ‚ü∂ _) := by
  #adaptation_note /-- nightly-testing 2024-04-01
  this could not be placed directly in the `show from` without `dsimp` -/
  have := limit.isoLimitCone_hom_œÄ ‚ü®_, pullbackIsPullbackOfCompMono f (ùüô _) i‚ü© WalkingCospan.left
  dsimp only [cospan_left, id_eq, eq_mpr_eq_cast, PullbackCone.mk_pt, PullbackCone.mk_œÄ_app,
    Functor.const_obj_obj, cospan_one] at this
  convert (congrArg IsIso (show _ ‚â´ pullback.fst = _ from this)).mp inferInstance
  ¬∑ exact (Category.id_comp _).symm
  ¬∑ exact (Category.id_comp _).symm
#align category_theory.limits.pullback_snd_iso_of_left_factors_mono CategoryTheory.Limits.pullback_snd_iso_of_left_factors_mono

end PullbackRightIso

section PushoutLeftIso

open WalkingSpan

variable (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [IsIso f]

/-- If `f : X ‚ü∂ Y` is iso, then `Y ‚®ø[X] Z ‚âÖ Z`. This is the explicit colimit cocone. -/
def pushoutCoconeOfLeftIso : PushoutCocone f g :=
  PushoutCocone.mk (inv f ‚â´ g) (ùüô _) <| by simp
#align category_theory.limits.pushout_cocone_of_left_iso CategoryTheory.Limits.pushoutCoconeOfLeftIso

@[simp]
theorem pushoutCoconeOfLeftIso_x : (pushoutCoconeOfLeftIso f g).pt = Z := rfl
set_option linter.uppercaseLean3 false in
#align category_theory.limits.pushout_cocone_of_left_iso_X CategoryTheory.Limits.pushoutCoconeOfLeftIso_x

@[simp]
theorem pushoutCoconeOfLeftIso_inl : (pushoutCoconeOfLeftIso f g).inl = inv f ‚â´ g := rfl
#align category_theory.limits.pushout_cocone_of_left_iso_inl CategoryTheory.Limits.pushoutCoconeOfLeftIso_inl

@[simp]
theorem pushoutCoconeOfLeftIso_inr : (pushoutCoconeOfLeftIso f g).inr = ùüô _ := rfl
#align category_theory.limits.pushout_cocone_of_left_iso_inr CategoryTheory.Limits.pushoutCoconeOfLeftIso_inr

-- Porting note (#10618): simp can prove this; removed simp
theorem pushoutCoconeOfLeftIso_Œπ_app_none : (pushoutCoconeOfLeftIso f g).Œπ.app none = g := by
  simp
#align category_theory.limits.pushout_cocone_of_left_iso_Œπ_app_none CategoryTheory.Limits.pushoutCoconeOfLeftIso_Œπ_app_none

@[simp]
theorem pushoutCoconeOfLeftIso_Œπ_app_left : (pushoutCoconeOfLeftIso f g).Œπ.app left = inv f ‚â´ g :=
  rfl
#align category_theory.limits.pushout_cocone_of_left_iso_Œπ_app_left CategoryTheory.Limits.pushoutCoconeOfLeftIso_Œπ_app_left

@[simp]
theorem pushoutCoconeOfLeftIso_Œπ_app_right : (pushoutCoconeOfLeftIso f g).Œπ.app right = ùüô _ := rfl
#align category_theory.limits.pushout_cocone_of_left_iso_Œπ_app_right CategoryTheory.Limits.pushoutCoconeOfLeftIso_Œπ_app_right

/-- Verify that the constructed cocone is indeed a colimit. -/
def pushoutCoconeOfLeftIsoIsLimit : IsColimit (pushoutCoconeOfLeftIso f g) :=
  PushoutCocone.isColimitAux' _ fun s => ‚ü®s.inr, by simp [‚Üê s.condition]‚ü©
#align category_theory.limits.pushout_cocone_of_left_iso_is_limit CategoryTheory.Limits.pushoutCoconeOfLeftIsoIsLimit

theorem hasPushout_of_left_iso : HasPushout f g :=
  ‚ü®‚ü®‚ü®_, pushoutCoconeOfLeftIsoIsLimit f g‚ü©‚ü©‚ü©
#align category_theory.limits.has_pushout_of_left_iso CategoryTheory.Limits.hasPushout_of_left_iso

attribute [local instance] hasPushout_of_left_iso

instance pushout_inr_iso_of_left_iso : IsIso (pushout.inr : _ ‚ü∂ pushout f g) := by
  refine ‚ü®‚ü®pushout.desc (inv f ‚â´ g) (ùüô _) (by simp), by simp, ?_‚ü©‚ü©
  ext
  ¬∑ simp [‚Üê pushout.condition]
  ¬∑ simp [pushout.condition_assoc]
#align category_theory.limits.pushout_inr_iso_of_left_iso CategoryTheory.Limits.pushout_inr_iso_of_left_iso

variable (h : W ‚ü∂ X) [Epi h]

instance hasPushout_of_right_factors_epi (f : X ‚ü∂ Y) : HasPushout h (h ‚â´ f) := by
  conv =>
    congr
    rw [‚Üê Category.comp_id h]
  infer_instance
#align category_theory.limits.has_pushout_of_right_factors_epi CategoryTheory.Limits.hasPushout_of_right_factors_epi

instance pushout_inr_iso_of_right_factors_epi (f : X ‚ü∂ Y) :
    IsIso (pushout.inr : _ ‚ü∂ pushout h (h ‚â´ f)) := by
  convert (congrArg IsIso (show pushout.inr ‚â´ _ = _ from colimit.isoColimitCocone_Œπ_inv
    ‚ü®_, pushoutIsPushoutOfEpiComp (ùüô _) f h‚ü© WalkingSpan.right)).mp
    inferInstance
  ¬∑ apply (Category.comp_id _).symm
  ¬∑ apply (Category.comp_id _).symm
#align category_theory.limits.pushout_inr_iso_of_right_factors_epi CategoryTheory.Limits.pushout_inr_iso_of_right_factors_epi

end PushoutLeftIso

section PushoutRightIso

open WalkingSpan

variable (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [IsIso g]

/-- If `f : X ‚ü∂ Z` is iso, then `Y ‚®ø[X] Z ‚âÖ Y`. This is the explicit colimit cocone. -/
def pushoutCoconeOfRightIso : PushoutCocone f g :=
  PushoutCocone.mk (ùüô _) (inv g ‚â´ f) <| by simp
#align category_theory.limits.pushout_cocone_of_right_iso CategoryTheory.Limits.pushoutCoconeOfRightIso

@[simp]
theorem pushoutCoconeOfRightIso_x : (pushoutCoconeOfRightIso f g).pt = Y := rfl
set_option linter.uppercaseLean3 false in
#align category_theory.limits.pushout_cocone_of_right_iso_X CategoryTheory.Limits.pushoutCoconeOfRightIso_x

@[simp]
theorem pushoutCoconeOfRightIso_inl : (pushoutCoconeOfRightIso f g).inl = ùüô _ := rfl
#align category_theory.limits.pushout_cocone_of_right_iso_inl CategoryTheory.Limits.pushoutCoconeOfRightIso_inl

@[simp]
theorem pushoutCoconeOfRightIso_inr : (pushoutCoconeOfRightIso f g).inr = inv g ‚â´ f := rfl
#align category_theory.limits.pushout_cocone_of_right_iso_inr CategoryTheory.Limits.pushoutCoconeOfRightIso_inr

-- Porting note (#10618): simp can prove this; removed simp
theorem pushoutCoconeOfRightIso_Œπ_app_none : (pushoutCoconeOfRightIso f g).Œπ.app none = f := by
  simp
#align category_theory.limits.pushout_cocone_of_right_iso_Œπ_app_none CategoryTheory.Limits.pushoutCoconeOfRightIso_Œπ_app_none

@[simp]
theorem pushoutCoconeOfRightIso_Œπ_app_left : (pushoutCoconeOfRightIso f g).Œπ.app left = ùüô _ := rfl
#align category_theory.limits.pushout_cocone_of_right_iso_Œπ_app_left CategoryTheory.Limits.pushoutCoconeOfRightIso_Œπ_app_left

@[simp]
theorem pushoutCoconeOfRightIso_Œπ_app_right :
    (pushoutCoconeOfRightIso f g).Œπ.app right = inv g ‚â´ f := rfl
#align category_theory.limits.pushout_cocone_of_right_iso_Œπ_app_right CategoryTheory.Limits.pushoutCoconeOfRightIso_Œπ_app_right

/-- Verify that the constructed cocone is indeed a colimit. -/
def pushoutCoconeOfRightIsoIsLimit : IsColimit (pushoutCoconeOfRightIso f g) :=
  PushoutCocone.isColimitAux' _ fun s => ‚ü®s.inl, by simp [‚Üê s.condition]‚ü©
#align category_theory.limits.pushout_cocone_of_right_iso_is_limit CategoryTheory.Limits.pushoutCoconeOfRightIsoIsLimit

theorem hasPushout_of_right_iso : HasPushout f g :=
  ‚ü®‚ü®‚ü®_, pushoutCoconeOfRightIsoIsLimit f g‚ü©‚ü©‚ü©
#align category_theory.limits.has_pushout_of_right_iso CategoryTheory.Limits.hasPushout_of_right_iso

attribute [local instance] hasPushout_of_right_iso

instance pushout_inl_iso_of_right_iso : IsIso (pushout.inl : _ ‚ü∂ pushout f g) := by
  refine ‚ü®‚ü®pushout.desc (ùüô _) (inv g ‚â´ f) (by simp), by simp, ?_‚ü©‚ü©
  ext
  ¬∑ simp [‚Üê pushout.condition]
  ¬∑ simp [pushout.condition]
#align category_theory.limits.pushout_inl_iso_of_right_iso CategoryTheory.Limits.pushout_inl_iso_of_right_iso

variable (h : W ‚ü∂ X) [Epi h]

instance hasPushout_of_left_factors_epi (f : X ‚ü∂ Y) : HasPushout (h ‚â´ f) h := by
  conv =>
    congr
    case g => rw [‚Üê Category.comp_id h]
  infer_instance
#align category_theory.limits.has_pushout_of_left_factors_epi CategoryTheory.Limits.hasPushout_of_left_factors_epi

instance pushout_inl_iso_of_left_factors_epi (f : X ‚ü∂ Y) :
    IsIso (pushout.inl : _ ‚ü∂ pushout (h ‚â´ f) h) := by
  convert (congrArg IsIso (show pushout.inl ‚â´ _ = _ from colimit.isoColimitCocone_Œπ_inv
    ‚ü®_, pushoutIsPushoutOfEpiComp f (ùüô _) h‚ü© WalkingSpan.left)).mp
        inferInstance;
  ¬∑ exact (Category.comp_id _).symm
  ¬∑ exact (Category.comp_id _).symm
#align category_theory.limits.pushout_inl_iso_of_left_factors_epi CategoryTheory.Limits.pushout_inl_iso_of_left_factors_epi

end PushoutRightIso

section PasteLemma

variable {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ X‚ÇÇ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ X‚ÇÉ) (g‚ÇÅ : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) (g‚ÇÇ : Y‚ÇÇ ‚ü∂ Y‚ÇÉ)
variable (i‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (i‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (i‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ)
variable (h‚ÇÅ : i‚ÇÅ ‚â´ g‚ÇÅ = f‚ÇÅ ‚â´ i‚ÇÇ) (h‚ÇÇ : i‚ÇÇ ‚â´ g‚ÇÇ = f‚ÇÇ ‚â´ i‚ÇÉ)

/-- Given

X‚ÇÅ - f‚ÇÅ -> X‚ÇÇ - f‚ÇÇ -> X‚ÇÉ
|          |          |
i‚ÇÅ         i‚ÇÇ         i‚ÇÉ
‚à®          ‚à®          ‚à®
Y‚ÇÅ - g‚ÇÅ -> Y‚ÇÇ - g‚ÇÇ -> Y‚ÇÉ

Then the big square is a pullback if both the small squares are.
-/
def bigSquareIsPullback (H : IsLimit (PullbackCone.mk _ _ h‚ÇÇ))
    (H' : IsLimit (PullbackCone.mk _ _ h‚ÇÅ)) :
    IsLimit
      (PullbackCone.mk _ _
        (show i‚ÇÅ ‚â´ g‚ÇÅ ‚â´ g‚ÇÇ = (f‚ÇÅ ‚â´ f‚ÇÇ) ‚â´ i‚ÇÉ by
          rw [‚Üê Category.assoc, h‚ÇÅ, Category.assoc, h‚ÇÇ, Category.assoc])) := by
  fapply PullbackCone.isLimitAux'
  intro s
  have : (s.fst ‚â´ g‚ÇÅ) ‚â´ g‚ÇÇ = s.snd ‚â´ i‚ÇÉ := by rw [‚Üê s.condition, Category.assoc]
  rcases PullbackCone.IsLimit.lift' H (s.fst ‚â´ g‚ÇÅ) s.snd this with ‚ü®l‚ÇÅ, hl‚ÇÅ, hl‚ÇÅ'‚ü©
  rcases PullbackCone.IsLimit.lift' H' s.fst l‚ÇÅ hl‚ÇÅ.symm with ‚ü®l‚ÇÇ, hl‚ÇÇ, hl‚ÇÇ'‚ü©
  use l‚ÇÇ
  use hl‚ÇÇ
  use
    show l‚ÇÇ ‚â´ f‚ÇÅ ‚â´ f‚ÇÇ = s.snd by
      rw [‚Üê hl‚ÇÅ', ‚Üê hl‚ÇÇ', Category.assoc]
      rfl
  intro m hm‚ÇÅ hm‚ÇÇ
  apply PullbackCone.IsLimit.hom_ext H'
  ¬∑ erw [hm‚ÇÅ, hl‚ÇÇ]
  ¬∑ apply PullbackCone.IsLimit.hom_ext H
    ¬∑ erw [Category.assoc, ‚Üê h‚ÇÅ, ‚Üê Category.assoc, hm‚ÇÅ, ‚Üê hl‚ÇÇ, Category.assoc, Category.assoc, h‚ÇÅ]
      rfl
    ¬∑ erw [Category.assoc, hm‚ÇÇ, ‚Üê hl‚ÇÅ', ‚Üê hl‚ÇÇ']
#align category_theory.limits.big_square_is_pullback CategoryTheory.Limits.bigSquareIsPullback

/-- Given

X‚ÇÅ - f‚ÇÅ -> X‚ÇÇ - f‚ÇÇ -> X‚ÇÉ
|          |          |
i‚ÇÅ         i‚ÇÇ         i‚ÇÉ
‚à®          ‚à®          ‚à®
Y‚ÇÅ - g‚ÇÅ -> Y‚ÇÇ - g‚ÇÇ -> Y‚ÇÉ

Then the big square is a pushout if both the small squares are.
-/
def bigSquareIsPushout (H : IsColimit (PushoutCocone.mk _ _ h‚ÇÇ))
    (H' : IsColimit (PushoutCocone.mk _ _ h‚ÇÅ)) :
    IsColimit
      (PushoutCocone.mk _ _
        (show i‚ÇÅ ‚â´ g‚ÇÅ ‚â´ g‚ÇÇ = (f‚ÇÅ ‚â´ f‚ÇÇ) ‚â´ i‚ÇÉ by
          rw [‚Üê Category.assoc, h‚ÇÅ, Category.assoc, h‚ÇÇ, Category.assoc])) := by
  fapply PushoutCocone.isColimitAux'
  intro s
  have : i‚ÇÅ ‚â´ s.inl = f‚ÇÅ ‚â´ f‚ÇÇ ‚â´ s.inr := by rw [s.condition, Category.assoc]
  rcases PushoutCocone.IsColimit.desc' H' s.inl (f‚ÇÇ ‚â´ s.inr) this with ‚ü®l‚ÇÅ, hl‚ÇÅ, hl‚ÇÅ'‚ü©
  rcases PushoutCocone.IsColimit.desc' H l‚ÇÅ s.inr hl‚ÇÅ' with ‚ü®l‚ÇÇ, hl‚ÇÇ, hl‚ÇÇ'‚ü©
  use l‚ÇÇ
  use
    show (g‚ÇÅ ‚â´ g‚ÇÇ) ‚â´ l‚ÇÇ = s.inl by
      rw [‚Üê hl‚ÇÅ, ‚Üê hl‚ÇÇ, Category.assoc]
      rfl
  use hl‚ÇÇ'
  intro m hm‚ÇÅ hm‚ÇÇ
  apply PushoutCocone.IsColimit.hom_ext H
  ¬∑ apply PushoutCocone.IsColimit.hom_ext H'
    ¬∑ erw [‚Üê Category.assoc, hm‚ÇÅ, hl‚ÇÇ, hl‚ÇÅ]
    ¬∑ erw [‚Üê Category.assoc, h‚ÇÇ, Category.assoc, hm‚ÇÇ, ‚Üê hl‚ÇÇ', ‚Üê Category.assoc, ‚Üê Category.assoc, ‚Üê
        h‚ÇÇ]
      rfl
  ¬∑ erw [hm‚ÇÇ, hl‚ÇÇ']
#align category_theory.limits.big_square_is_pushout CategoryTheory.Limits.bigSquareIsPushout

/-- Given

X‚ÇÅ - f‚ÇÅ -> X‚ÇÇ - f‚ÇÇ -> X‚ÇÉ
|          |          |
i‚ÇÅ         i‚ÇÇ         i‚ÇÉ
‚à®          ‚à®          ‚à®
Y‚ÇÅ - g‚ÇÅ -> Y‚ÇÇ - g‚ÇÇ -> Y‚ÇÉ

Then the left square is a pullback if the right square and the big square are.
-/
def leftSquareIsPullback (H : IsLimit (PullbackCone.mk _ _ h‚ÇÇ))
    (H' :
      IsLimit
        (PullbackCone.mk _ _
          (show i‚ÇÅ ‚â´ g‚ÇÅ ‚â´ g‚ÇÇ = (f‚ÇÅ ‚â´ f‚ÇÇ) ‚â´ i‚ÇÉ by
            rw [‚Üê Category.assoc, h‚ÇÅ, Category.assoc, h‚ÇÇ, Category.assoc]))) :
    IsLimit (PullbackCone.mk _ _ h‚ÇÅ) := by
  fapply PullbackCone.isLimitAux'
  intro s
  have : s.fst ‚â´ g‚ÇÅ ‚â´ g‚ÇÇ = (s.snd ‚â´ f‚ÇÇ) ‚â´ i‚ÇÉ := by
    rw [‚Üê Category.assoc, s.condition, Category.assoc, Category.assoc, h‚ÇÇ]
  rcases PullbackCone.IsLimit.lift' H' s.fst (s.snd ‚â´ f‚ÇÇ) this with ‚ü®l‚ÇÅ, hl‚ÇÅ, hl‚ÇÅ'‚ü©
  use l‚ÇÅ
  use hl‚ÇÅ
  constructor
  ¬∑ apply PullbackCone.IsLimit.hom_ext H
    ¬∑ erw [Category.assoc, ‚Üê h‚ÇÅ, ‚Üê Category.assoc, hl‚ÇÅ, s.condition]
      rfl
    ¬∑ erw [Category.assoc, hl‚ÇÅ']
      rfl
  ¬∑ intro m hm‚ÇÅ hm‚ÇÇ
    apply PullbackCone.IsLimit.hom_ext H'
    ¬∑ erw [hm‚ÇÅ, hl‚ÇÅ]
    ¬∑ erw [hl‚ÇÅ', ‚Üê hm‚ÇÇ]
      exact (Category.assoc _ _ _).symm
#align category_theory.limits.left_square_is_pullback CategoryTheory.Limits.leftSquareIsPullback

/-- Given

X‚ÇÅ - f‚ÇÅ -> X‚ÇÇ - f‚ÇÇ -> X‚ÇÉ
|          |          |
i‚ÇÅ         i‚ÇÇ         i‚ÇÉ
‚à®          ‚à®          ‚à®
Y‚ÇÅ - g‚ÇÅ -> Y‚ÇÇ - g‚ÇÇ -> Y‚ÇÉ

Then the right square is a pushout if the left square and the big square are.
-/
def rightSquareIsPushout (H : IsColimit (PushoutCocone.mk _ _ h‚ÇÅ))
    (H' :
      IsColimit
        (PushoutCocone.mk _ _
          (show i‚ÇÅ ‚â´ g‚ÇÅ ‚â´ g‚ÇÇ = (f‚ÇÅ ‚â´ f‚ÇÇ) ‚â´ i‚ÇÉ by
            rw [‚Üê Category.assoc, h‚ÇÅ, Category.assoc, h‚ÇÇ, Category.assoc]))) :
    IsColimit (PushoutCocone.mk _ _ h‚ÇÇ) := by
  fapply PushoutCocone.isColimitAux'
  intro s
  have : i‚ÇÅ ‚â´ g‚ÇÅ ‚â´ s.inl = (f‚ÇÅ ‚â´ f‚ÇÇ) ‚â´ s.inr := by
    rw [Category.assoc, ‚Üê s.condition, ‚Üê Category.assoc, ‚Üê Category.assoc, h‚ÇÅ]
  rcases PushoutCocone.IsColimit.desc' H' (g‚ÇÅ ‚â´ s.inl) s.inr this with ‚ü®l‚ÇÅ, hl‚ÇÅ, hl‚ÇÅ'‚ü©
  dsimp at *
  use l‚ÇÅ
  refine ‚ü®?_, ?_, ?_‚ü©
  ¬∑ apply PushoutCocone.IsColimit.hom_ext H
    ¬∑ erw [‚Üê Category.assoc, hl‚ÇÅ]
      rfl
    ¬∑ erw [‚Üê Category.assoc, h‚ÇÇ, Category.assoc, hl‚ÇÅ', s.condition]
  ¬∑ exact hl‚ÇÅ'
  ¬∑ intro m hm‚ÇÅ hm‚ÇÇ
    apply PushoutCocone.IsColimit.hom_ext H'
    ¬∑ erw [hl‚ÇÅ, Category.assoc, hm‚ÇÅ]
    ¬∑ erw [hm‚ÇÇ, hl‚ÇÅ']
#align category_theory.limits.right_square_is_pushout CategoryTheory.Limits.rightSquareIsPushout

end PasteLemma

section

variable (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) (f' : W ‚ü∂ X)
variable [HasPullback f g] [HasPullback f' (pullback.fst : pullback f g ‚ü∂ _)]
variable [HasPullback (f' ‚â´ f) g]

/-- The canonical isomorphism `W √ó[X] (X √ó[Z] Y) ‚âÖ W √ó[Z] Y` -/
noncomputable def pullbackRightPullbackFstIso :
    pullback f' (pullback.fst : pullback f g ‚ü∂ _) ‚âÖ pullback (f' ‚â´ f) g := by
  let this :=
    bigSquareIsPullback (pullback.snd : pullback f' (pullback.fst : pullback f g ‚ü∂ _) ‚ü∂ _)
      pullback.snd f' f pullback.fst pullback.fst g pullback.condition pullback.condition
      (pullbackIsPullback _ _) (pullbackIsPullback _ _)
  exact (this.conePointUniqueUpToIso (pullbackIsPullback _ _) : _)
#align category_theory.limits.pullback_right_pullback_fst_iso CategoryTheory.Limits.pullbackRightPullbackFstIso

@[reassoc (attr := simp)]
theorem pullbackRightPullbackFstIso_hom_fst :
    (pullbackRightPullbackFstIso f g f').hom ‚â´ pullback.fst = pullback.fst :=
  IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingCospan.left
#align category_theory.limits.pullback_right_pullback_fst_iso_hom_fst CategoryTheory.Limits.pullbackRightPullbackFstIso_hom_fst

@[reassoc (attr := simp)]
theorem pullbackRightPullbackFstIso_hom_snd :
    (pullbackRightPullbackFstIso f g f').hom ‚â´ pullback.snd = pullback.snd ‚â´ pullback.snd :=
  IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingCospan.right
#align category_theory.limits.pullback_right_pullback_fst_iso_hom_snd CategoryTheory.Limits.pullbackRightPullbackFstIso_hom_snd

@[reassoc (attr := simp)]
theorem pullbackRightPullbackFstIso_inv_fst :
    (pullbackRightPullbackFstIso f g f').inv ‚â´ pullback.fst = pullback.fst :=
  IsLimit.conePointUniqueUpToIso_inv_comp _ _ WalkingCospan.left
#align category_theory.limits.pullback_right_pullback_fst_iso_inv_fst CategoryTheory.Limits.pullbackRightPullbackFstIso_inv_fst

@[reassoc (attr := simp)]
theorem pullbackRightPullbackFstIso_inv_snd_snd :
    (pullbackRightPullbackFstIso f g f').inv ‚â´ pullback.snd ‚â´ pullback.snd = pullback.snd :=
  IsLimit.conePointUniqueUpToIso_inv_comp _ _ WalkingCospan.right
#align category_theory.limits.pullback_right_pullback_fst_iso_inv_snd_snd CategoryTheory.Limits.pullbackRightPullbackFstIso_inv_snd_snd

@[reassoc (attr := simp)]
theorem pullbackRightPullbackFstIso_inv_snd_fst :
    (pullbackRightPullbackFstIso f g f').inv ‚â´ pullback.snd ‚â´ pullback.fst = pullback.fst ‚â´ f' := by
  rw [‚Üê pullback.condition]
  exact pullbackRightPullbackFstIso_inv_fst_assoc _ _ _ _
#align category_theory.limits.pullback_right_pullback_fst_iso_inv_snd_fst CategoryTheory.Limits.pullbackRightPullbackFstIso_inv_snd_fst

end

section

variable (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) (g' : Z ‚ü∂ W)
variable [HasPushout f g] [HasPushout (pushout.inr : _ ‚ü∂ pushout f g) g']
variable [HasPushout f (g ‚â´ g')]

/-- The canonical isomorphism `(Y ‚®ø[X] Z) ‚®ø[Z] W ‚âÖ Y √ó[X] W` -/
noncomputable def pushoutLeftPushoutInrIso :
    pushout (pushout.inr : _ ‚ü∂ pushout f g) g' ‚âÖ pushout f (g ‚â´ g') :=
  ((bigSquareIsPushout g g' _ _ f _ _ pushout.condition pushout.condition (pushoutIsPushout _ _)
          (pushoutIsPushout _ _)).coconePointUniqueUpToIso
      (pushoutIsPushout _ _) :
    _)
#align category_theory.limits.pushout_left_pushout_inr_iso CategoryTheory.Limits.pushoutLeftPushoutInrIso

@[reassoc (attr := simp)]
theorem inl_pushoutLeftPushoutInrIso_inv :
    pushout.inl ‚â´ (pushoutLeftPushoutInrIso f g g').inv = pushout.inl ‚â´ pushout.inl :=
  ((bigSquareIsPushout g g' _ _ f _ _ pushout.condition pushout.condition (pushoutIsPushout _ _)
          (pushoutIsPushout _ _)).comp_coconePointUniqueUpToIso_inv
      (pushoutIsPushout _ _) WalkingSpan.left :
    _)
#align category_theory.limits.inl_pushout_left_pushout_inr_iso_inv CategoryTheory.Limits.inl_pushoutLeftPushoutInrIso_inv

@[reassoc (attr := simp)]
theorem inr_pushoutLeftPushoutInrIso_hom :
    pushout.inr ‚â´ (pushoutLeftPushoutInrIso f g g').hom = pushout.inr :=
  ((bigSquareIsPushout g g' _ _ f _ _ pushout.condition pushout.condition (pushoutIsPushout _ _)
          (pushoutIsPushout _ _)).comp_coconePointUniqueUpToIso_hom
      (pushoutIsPushout _ _) WalkingSpan.right :
    _)
#align category_theory.limits.inr_pushout_left_pushout_inr_iso_hom CategoryTheory.Limits.inr_pushoutLeftPushoutInrIso_hom

@[reassoc (attr := simp)]
theorem inr_pushoutLeftPushoutInrIso_inv :
    pushout.inr ‚â´ (pushoutLeftPushoutInrIso f g g').inv = pushout.inr := by
  rw [Iso.comp_inv_eq, inr_pushoutLeftPushoutInrIso_hom]
#align category_theory.limits.inr_pushout_left_pushout_inr_iso_inv CategoryTheory.Limits.inr_pushoutLeftPushoutInrIso_inv

@[reassoc (attr := simp)]
theorem inl_inl_pushoutLeftPushoutInrIso_hom :
    pushout.inl ‚â´ pushout.inl ‚â´ (pushoutLeftPushoutInrIso f g g').hom = pushout.inl := by
  rw [‚Üê Category.assoc, ‚Üê Iso.eq_comp_inv, inl_pushoutLeftPushoutInrIso_inv]
#align category_theory.limits.inl_inl_pushout_left_pushout_inr_iso_hom CategoryTheory.Limits.inl_inl_pushoutLeftPushoutInrIso_hom

@[reassoc (attr := simp)]
theorem inr_inl_pushoutLeftPushoutInrIso_hom :
    pushout.inr ‚â´ pushout.inl ‚â´ (pushoutLeftPushoutInrIso f g g').hom = g' ‚â´ pushout.inr := by
  rw [‚Üê Category.assoc, ‚Üê Iso.eq_comp_inv, Category.assoc, inr_pushoutLeftPushoutInrIso_inv,
    pushout.condition]
#align category_theory.limits.inr_inl_pushout_left_pushout_inr_iso_hom CategoryTheory.Limits.inr_inl_pushoutLeftPushoutInrIso_hom

end

section PullbackAssoc

/-
The objects and morphisms are as follows:

           Z‚ÇÇ - g‚ÇÑ -> X‚ÇÉ
           |          |
           g‚ÇÉ         f‚ÇÑ
           ‚à®          ‚à®
Z‚ÇÅ - g‚ÇÇ -> X‚ÇÇ - f‚ÇÉ -> Y‚ÇÇ
|          |
g‚ÇÅ         f‚ÇÇ
‚à®          ‚à®
X‚ÇÅ - f‚ÇÅ -> Y‚ÇÅ

where the two squares are pullbacks.

We can then construct the pullback squares

W  - l‚ÇÇ -> Z‚ÇÇ - g‚ÇÑ -> X‚ÇÉ
|                     |
l‚ÇÅ                    f‚ÇÑ
‚à®                     ‚à®
Z‚ÇÅ - g‚ÇÇ -> X‚ÇÇ - f‚ÇÉ -> Y‚ÇÇ

and

W' - l‚ÇÇ' -> Z‚ÇÇ
|           |
l‚ÇÅ'         g‚ÇÉ
‚à®           ‚à®
Z‚ÇÅ          X‚ÇÇ
|           |
g‚ÇÅ          f‚ÇÇ
‚à®           ‚à®
X‚ÇÅ -  f‚ÇÅ -> Y‚ÇÅ

We will show that both `W` and `W'` are pullbacks over `g‚ÇÅ, g‚ÇÇ`, and thus we may construct a
canonical isomorphism between them. -/
variable {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÅ) (f‚ÇÉ : X‚ÇÇ ‚ü∂ Y‚ÇÇ)
variable (f‚ÇÑ : X‚ÇÉ ‚ü∂ Y‚ÇÇ) [HasPullback f‚ÇÅ f‚ÇÇ] [HasPullback f‚ÇÉ f‚ÇÑ]

local notation "Z‚ÇÅ" => pullback f‚ÇÅ f‚ÇÇ

local notation "Z‚ÇÇ" => pullback f‚ÇÉ f‚ÇÑ

local notation "g‚ÇÅ" => (pullback.fst : Z‚ÇÅ ‚ü∂ X‚ÇÅ)

local notation "g‚ÇÇ" => (pullback.snd : Z‚ÇÅ ‚ü∂ X‚ÇÇ)

local notation "g‚ÇÉ" => (pullback.fst : Z‚ÇÇ ‚ü∂ X‚ÇÇ)

local notation "g‚ÇÑ" => (pullback.snd : Z‚ÇÇ ‚ü∂ X‚ÇÉ)

local notation "W" => pullback (g‚ÇÇ ‚â´ f‚ÇÉ) f‚ÇÑ

local notation "W'" => pullback f‚ÇÅ (g‚ÇÉ ‚â´ f‚ÇÇ)

local notation "l‚ÇÅ" => (pullback.fst : W ‚ü∂ Z‚ÇÅ)

local notation "l‚ÇÇ" =>
  (pullback.lift (pullback.fst ‚â´ g‚ÇÇ) pullback.snd
      (Eq.trans (Category.assoc _ _ _) pullback.condition) :
    W ‚ü∂ Z‚ÇÇ)

local notation "l‚ÇÅ'" =>
  (pullback.lift pullback.fst (pullback.snd ‚â´ g‚ÇÉ)
      (pullback.condition.trans (Eq.symm (Category.assoc _ _ _))) :
    W' ‚ü∂ Z‚ÇÅ)

local notation "l‚ÇÇ'" => (pullback.snd : W' ‚ü∂ Z‚ÇÇ)

/-- `(X‚ÇÅ √ó[Y‚ÇÅ] X‚ÇÇ) √ó[Y‚ÇÇ] X‚ÇÉ` is the pullback `(X‚ÇÅ √ó[Y‚ÇÅ] X‚ÇÇ) √ó[X‚ÇÇ] (X‚ÇÇ √ó[Y‚ÇÇ] X‚ÇÉ)`. -/
def pullbackPullbackLeftIsPullback [HasPullback (g‚ÇÇ ‚â´ f‚ÇÉ) f‚ÇÑ] : IsLimit (PullbackCone.mk l‚ÇÅ l‚ÇÇ
    (show l‚ÇÅ ‚â´ g‚ÇÇ = l‚ÇÇ ‚â´ g‚ÇÉ from (pullback.lift_fst _ _ _).symm)) := by
  apply leftSquareIsPullback
  ¬∑ exact pullbackIsPullback f‚ÇÉ f‚ÇÑ
  convert pullbackIsPullback (g‚ÇÇ ‚â´ f‚ÇÉ) f‚ÇÑ
  rw [pullback.lift_snd]
#align category_theory.limits.pullback_pullback_left_is_pullback CategoryTheory.Limits.pullbackPullbackLeftIsPullback

/-- `(X‚ÇÅ √ó[Y‚ÇÅ] X‚ÇÇ) √ó[Y‚ÇÇ] X‚ÇÉ` is the pullback `X‚ÇÅ √ó[Y‚ÇÅ] (X‚ÇÇ √ó[Y‚ÇÇ] X‚ÇÉ)`. -/
def pullbackAssocIsPullback [HasPullback (g‚ÇÇ ‚â´ f‚ÇÉ) f‚ÇÑ] :
    IsLimit
      (PullbackCone.mk (l‚ÇÅ ‚â´ g‚ÇÅ) l‚ÇÇ
        (show (l‚ÇÅ ‚â´ g‚ÇÅ) ‚â´ f‚ÇÅ = l‚ÇÇ ‚â´ g‚ÇÉ ‚â´ f‚ÇÇ by
          rw [pullback.lift_fst_assoc, Category.assoc, Category.assoc, pullback.condition])) := by
  apply PullbackCone.isLimitOfFlip
  apply bigSquareIsPullback
  ¬∑ apply PullbackCone.isLimitOfFlip
    exact pullbackIsPullback f‚ÇÅ f‚ÇÇ
  ¬∑ apply PullbackCone.isLimitOfFlip
    apply pullbackPullbackLeftIsPullback
  ¬∑ exact pullback.lift_fst _ _ _
  ¬∑ exact pullback.condition.symm
#align category_theory.limits.pullback_assoc_is_pullback CategoryTheory.Limits.pullbackAssocIsPullback

theorem hasPullback_assoc [HasPullback (g‚ÇÇ ‚â´ f‚ÇÉ) f‚ÇÑ] : HasPullback f‚ÇÅ (g‚ÇÉ ‚â´ f‚ÇÇ) :=
  ‚ü®‚ü®‚ü®_, pullbackAssocIsPullback f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ‚ü©‚ü©‚ü©
#align category_theory.limits.has_pullback_assoc CategoryTheory.Limits.hasPullback_assoc

/-- `X‚ÇÅ √ó[Y‚ÇÅ] (X‚ÇÇ √ó[Y‚ÇÇ] X‚ÇÉ)` is the pullback `(X‚ÇÅ √ó[Y‚ÇÅ] X‚ÇÇ) √ó[X‚ÇÇ] (X‚ÇÇ √ó[Y‚ÇÇ] X‚ÇÉ)`. -/
def pullbackPullbackRightIsPullback [HasPullback f‚ÇÅ (g‚ÇÉ ‚â´ f‚ÇÇ)] :
    IsLimit (PullbackCone.mk l‚ÇÅ' l‚ÇÇ' (show l‚ÇÅ' ‚â´ g‚ÇÇ = l‚ÇÇ' ‚â´ g‚ÇÉ from pullback.lift_snd _ _ _)) := by
  apply PullbackCone.isLimitOfFlip
  apply leftSquareIsPullback
  ¬∑ apply PullbackCone.isLimitOfFlip
    exact pullbackIsPullback f‚ÇÅ f‚ÇÇ
  ¬∑ apply PullbackCone.isLimitOfFlip
    exact IsLimit.ofIsoLimit (pullbackIsPullback f‚ÇÅ (g‚ÇÉ ‚â´ f‚ÇÇ))
      (PullbackCone.ext (Iso.refl _) (by simp) (by simp))
  ¬∑ exact pullback.condition.symm
#align category_theory.limits.pullback_pullback_right_is_pullback CategoryTheory.Limits.pullbackPullbackRightIsPullback

/-- `X‚ÇÅ √ó[Y‚ÇÅ] (X‚ÇÇ √ó[Y‚ÇÇ] X‚ÇÉ)` is the pullback `(X‚ÇÅ √ó[Y‚ÇÅ] X‚ÇÇ) √ó[Y‚ÇÇ] X‚ÇÉ`. -/
def pullbackAssocSymmIsPullback [HasPullback f‚ÇÅ (g‚ÇÉ ‚â´ f‚ÇÇ)] :
    IsLimit
      (PullbackCone.mk l‚ÇÅ' (l‚ÇÇ' ‚â´ g‚ÇÑ)
        (show l‚ÇÅ' ‚â´ g‚ÇÇ ‚â´ f‚ÇÉ = (l‚ÇÇ' ‚â´ g‚ÇÑ) ‚â´ f‚ÇÑ by
          rw [pullback.lift_snd_assoc, Category.assoc, Category.assoc, pullback.condition])) := by
  apply bigSquareIsPullback
  ¬∑ exact pullbackIsPullback f‚ÇÉ f‚ÇÑ
  ¬∑ apply pullbackPullbackRightIsPullback
#align category_theory.limits.pullback_assoc_symm_is_pullback CategoryTheory.Limits.pullbackAssocSymmIsPullback

theorem hasPullback_assoc_symm [HasPullback f‚ÇÅ (g‚ÇÉ ‚â´ f‚ÇÇ)] : HasPullback (g‚ÇÇ ‚â´ f‚ÇÉ) f‚ÇÑ :=
  ‚ü®‚ü®‚ü®_, pullbackAssocSymmIsPullback f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ‚ü©‚ü©‚ü©
#align category_theory.limits.has_pullback_assoc_symm CategoryTheory.Limits.hasPullback_assoc_symm

/- Porting note: these don't seem to be propagating change from
-- variable [HasPullback (g‚ÇÇ ‚â´ f‚ÇÉ) f‚ÇÑ] [HasPullback f‚ÇÅ (g‚ÇÉ ‚â´ f‚ÇÇ)] -/
variable [HasPullback (g‚ÇÇ ‚â´ f‚ÇÉ) f‚ÇÑ] [HasPullback f‚ÇÅ ((pullback.fst : Z‚ÇÇ ‚ü∂ X‚ÇÇ) ‚â´ f‚ÇÇ)]

/-- The canonical isomorphism `(X‚ÇÅ √ó[Y‚ÇÅ] X‚ÇÇ) √ó[Y‚ÇÇ] X‚ÇÉ ‚âÖ X‚ÇÅ √ó[Y‚ÇÅ] (X‚ÇÇ √ó[Y‚ÇÇ] X‚ÇÉ)`. -/
noncomputable def pullbackAssoc [HasPullback ((pullback.snd : Z‚ÇÅ ‚ü∂ X‚ÇÇ) ‚â´ f‚ÇÉ) f‚ÇÑ]
    [HasPullback f‚ÇÅ ((pullback.fst : Z‚ÇÇ ‚ü∂ X‚ÇÇ) ‚â´ f‚ÇÇ)] :
    pullback (pullback.snd ‚â´ f‚ÇÉ : pullback f‚ÇÅ f‚ÇÇ ‚ü∂ _) f‚ÇÑ ‚âÖ
      pullback f‚ÇÅ (pullback.fst ‚â´ f‚ÇÇ : pullback f‚ÇÉ f‚ÇÑ ‚ü∂ _) :=
  (pullbackPullbackLeftIsPullback f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ).conePointUniqueUpToIso
    (pullbackPullbackRightIsPullback f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ)
#align category_theory.limits.pullback_assoc CategoryTheory.Limits.pullbackAssoc

@[reassoc (attr := simp)]
theorem pullbackAssoc_inv_fst_fst [HasPullback ((pullback.snd : Z‚ÇÅ ‚ü∂ X‚ÇÇ) ‚â´ f‚ÇÉ) f‚ÇÑ]
    [HasPullback f‚ÇÅ ((pullback.fst : Z‚ÇÇ ‚ü∂ X‚ÇÇ) ‚â´ f‚ÇÇ)] :
    (pullbackAssoc f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ).inv ‚â´ pullback.fst ‚â´ pullback.fst = pullback.fst := by
  trans l‚ÇÅ' ‚â´ pullback.fst
  ¬∑ rw [‚Üê Category.assoc]
    congr 1
    exact IsLimit.conePointUniqueUpToIso_inv_comp _ _ WalkingCospan.left
  ¬∑ exact pullback.lift_fst _ _ _
#align category_theory.limits.pullback_assoc_inv_fst_fst CategoryTheory.Limits.pullbackAssoc_inv_fst_fst

@[reassoc (attr := simp)]
theorem pullbackAssoc_hom_fst [HasPullback ((pullback.snd : Z‚ÇÅ ‚ü∂ X‚ÇÇ) ‚â´ f‚ÇÉ) f‚ÇÑ]
    [HasPullback f‚ÇÅ ((pullback.fst : Z‚ÇÇ ‚ü∂ X‚ÇÇ) ‚â´ f‚ÇÇ)] :
    (pullbackAssoc f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ).hom ‚â´ pullback.fst = pullback.fst ‚â´ pullback.fst := by
  rw [‚Üê Iso.eq_inv_comp, pullbackAssoc_inv_fst_fst]
#align category_theory.limits.pullback_assoc_hom_fst CategoryTheory.Limits.pullbackAssoc_hom_fst

@[reassoc (attr := simp)]
theorem pullbackAssoc_hom_snd_fst [HasPullback ((pullback.snd : Z‚ÇÅ ‚ü∂ X‚ÇÇ) ‚â´ f‚ÇÉ) f‚ÇÑ]
    [HasPullback f‚ÇÅ ((pullback.fst : Z‚ÇÇ ‚ü∂ X‚ÇÇ) ‚â´ f‚ÇÇ)] : (pullbackAssoc f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ).hom ‚â´
    pullback.snd ‚â´ pullback.fst = pullback.fst ‚â´ pullback.snd := by
  trans l‚ÇÇ ‚â´ pullback.fst
  ¬∑ rw [‚Üê Category.assoc]
    congr 1
    exact IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingCospan.right
  ¬∑ exact pullback.lift_fst _ _ _
#align category_theory.limits.pullback_assoc_hom_snd_fst CategoryTheory.Limits.pullbackAssoc_hom_snd_fst

@[reassoc (attr := simp)]
theorem pullbackAssoc_hom_snd_snd [HasPullback ((pullback.snd : Z‚ÇÅ ‚ü∂ X‚ÇÇ) ‚â´ f‚ÇÉ) f‚ÇÑ]
    [HasPullback f‚ÇÅ ((pullback.fst : Z‚ÇÇ ‚ü∂ X‚ÇÇ) ‚â´ f‚ÇÇ)] :
    (pullbackAssoc f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ).hom ‚â´ pullback.snd ‚â´ pullback.snd = pullback.snd := by
  trans l‚ÇÇ ‚â´ pullback.snd
  ¬∑ rw [‚Üê Category.assoc]
    congr 1
    exact IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingCospan.right
  ¬∑ exact pullback.lift_snd _ _ _
#align category_theory.limits.pullback_assoc_hom_snd_snd CategoryTheory.Limits.pullbackAssoc_hom_snd_snd

@[reassoc (attr := simp)]
theorem pullbackAssoc_inv_fst_snd [HasPullback ((pullback.snd : Z‚ÇÅ ‚ü∂ X‚ÇÇ) ‚â´ f‚ÇÉ) f‚ÇÑ]
    [HasPullback f‚ÇÅ ((pullback.fst : Z‚ÇÇ ‚ü∂ X‚ÇÇ) ‚â´ f‚ÇÇ)] :
    (pullbackAssoc f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ).inv ‚â´ pullback.fst ‚â´ pullback.snd =
    pullback.snd ‚â´ pullback.fst := by rw [Iso.inv_comp_eq, pullbackAssoc_hom_snd_fst]
#align category_theory.limits.pullback_assoc_inv_fst_snd CategoryTheory.Limits.pullbackAssoc_inv_fst_snd

@[reassoc (attr := simp)]
theorem pullbackAssoc_inv_snd [HasPullback ((pullback.snd : Z‚ÇÅ ‚ü∂ X‚ÇÇ) ‚â´ f‚ÇÉ) f‚ÇÑ]
    [HasPullback f‚ÇÅ ((pullback.fst : Z‚ÇÇ ‚ü∂ X‚ÇÇ) ‚â´ f‚ÇÇ)] :
    (pullbackAssoc f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ).inv ‚â´ pullback.snd = pullback.snd ‚â´ pullback.snd := by
  rw [Iso.inv_comp_eq, pullbackAssoc_hom_snd_snd]
#align category_theory.limits.pullback_assoc_inv_snd CategoryTheory.Limits.pullbackAssoc_inv_snd

end PullbackAssoc

section PushoutAssoc

/-
The objects and morphisms are as follows:

           Z‚ÇÇ - g‚ÇÑ -> X‚ÇÉ
           |          |
           g‚ÇÉ         f‚ÇÑ
           ‚à®          ‚à®
Z‚ÇÅ - g‚ÇÇ -> X‚ÇÇ - f‚ÇÉ -> Y‚ÇÇ
|          |
g‚ÇÅ         f‚ÇÇ
‚à®          ‚à®
X‚ÇÅ - f‚ÇÅ -> Y‚ÇÅ

where the two squares are pushouts.

We can then construct the pushout squares

Z‚ÇÅ - g‚ÇÇ -> X‚ÇÇ - f‚ÇÉ -> Y‚ÇÇ
|                     |
g‚ÇÅ                    l‚ÇÇ
‚à®                     ‚à®
X‚ÇÅ - f‚ÇÅ -> Y‚ÇÅ - l‚ÇÅ -> W

and

Z‚ÇÇ - g‚ÇÑ  -> X‚ÇÉ
|           |
g‚ÇÉ          f‚ÇÑ
‚à®           ‚à®
X‚ÇÇ          Y‚ÇÇ
|           |
f‚ÇÇ          l‚ÇÇ'
‚à®           ‚à®
Y‚ÇÅ - l‚ÇÅ' -> W'

We will show that both `W` and `W'` are pushouts over `f‚ÇÇ, f‚ÇÉ`, and thus we may construct a
canonical isomorphism between them. -/
variable {X‚ÇÅ X‚ÇÇ X‚ÇÉ Z‚ÇÅ Z‚ÇÇ : C} (g‚ÇÅ : Z‚ÇÅ ‚ü∂ X‚ÇÅ) (g‚ÇÇ : Z‚ÇÅ ‚ü∂ X‚ÇÇ) (g‚ÇÉ : Z‚ÇÇ ‚ü∂ X‚ÇÇ)
variable (g‚ÇÑ : Z‚ÇÇ ‚ü∂ X‚ÇÉ) [HasPushout g‚ÇÅ g‚ÇÇ] [HasPushout g‚ÇÉ g‚ÇÑ]

local notation "Y‚ÇÅ" => pushout g‚ÇÅ g‚ÇÇ

local notation "Y‚ÇÇ" => pushout g‚ÇÉ g‚ÇÑ

local notation "f‚ÇÅ" => (pushout.inl : X‚ÇÅ ‚ü∂ Y‚ÇÅ)

local notation "f‚ÇÇ" => (pushout.inr : X‚ÇÇ ‚ü∂ Y‚ÇÅ)

local notation "f‚ÇÉ" => (pushout.inl : X‚ÇÇ ‚ü∂ Y‚ÇÇ)

local notation "f‚ÇÑ" => (pushout.inr : X‚ÇÉ ‚ü∂ Y‚ÇÇ)

local notation "W" => pushout g‚ÇÅ (g‚ÇÇ ‚â´ f‚ÇÉ)

local notation "W'" => pushout (g‚ÇÉ ‚â´ f‚ÇÇ) g‚ÇÑ

local notation "l‚ÇÅ" =>
  (pushout.desc pushout.inl (f‚ÇÉ ‚â´ pushout.inr) (pushout.condition.trans (Category.assoc _ _ _)) :
    Y‚ÇÅ ‚ü∂ W)

local notation "l‚ÇÇ" => (pushout.inr : Y‚ÇÇ ‚ü∂ W)

local notation "l‚ÇÅ'" => (pushout.inl : Y‚ÇÅ ‚ü∂ W')

local notation "l‚ÇÇ'" =>
  (pushout.desc (f‚ÇÇ ‚â´ pushout.inl) pushout.inr
      (Eq.trans (Eq.symm (Category.assoc _ _ _)) pushout.condition) :
    Y‚ÇÇ ‚ü∂ W')

/-- `(X‚ÇÅ ‚®ø[Z‚ÇÅ] X‚ÇÇ) ‚®ø[Z‚ÇÇ] X‚ÇÉ` is the pushout `(X‚ÇÅ ‚®ø[Z‚ÇÅ] X‚ÇÇ) √ó[X‚ÇÇ] (X‚ÇÇ ‚®ø[Z‚ÇÇ] X‚ÇÉ)`. -/
def pushoutPushoutLeftIsPushout [HasPushout (g‚ÇÉ ‚â´ f‚ÇÇ) g‚ÇÑ] :
    IsColimit
      (PushoutCocone.mk l‚ÇÅ' l‚ÇÇ' (show f‚ÇÇ ‚â´ l‚ÇÅ' = f‚ÇÉ ‚â´ l‚ÇÇ' from (pushout.inl_desc _ _ _).symm)) := by
  apply PushoutCocone.isColimitOfFlip
  apply rightSquareIsPushout
  ¬∑ apply PushoutCocone.isColimitOfFlip
    exact pushoutIsPushout g‚ÇÉ g‚ÇÑ
  ¬∑ exact IsColimit.ofIsoColimit (PushoutCocone.flipIsColimit (pushoutIsPushout (g‚ÇÉ ‚â´ f‚ÇÇ) g‚ÇÑ))
      (PushoutCocone.ext (Iso.refl _) (by simp) (by simp))
  ¬∑ exact pushout.condition.symm
#align category_theory.limits.pushout_pushout_left_is_pushout CategoryTheory.Limits.pushoutPushoutLeftIsPushout

/-- `(X‚ÇÅ ‚®ø[Z‚ÇÅ] X‚ÇÇ) ‚®ø[Z‚ÇÇ] X‚ÇÉ` is the pushout `X‚ÇÅ ‚®ø[Z‚ÇÅ] (X‚ÇÇ ‚®ø[Z‚ÇÇ] X‚ÇÉ)`. -/
def pushoutAssocIsPushout [HasPushout (g‚ÇÉ ‚â´ f‚ÇÇ) g‚ÇÑ] :
    IsColimit
      (PushoutCocone.mk (f‚ÇÅ ‚â´ l‚ÇÅ') l‚ÇÇ'
        (show g‚ÇÅ ‚â´ f‚ÇÅ ‚â´ l‚ÇÅ' = (g‚ÇÇ ‚â´ f‚ÇÉ) ‚â´ l‚ÇÇ' by
          rw [Category.assoc, pushout.inl_desc, pushout.condition_assoc])) := by
  apply bigSquareIsPushout
  ¬∑ apply pushoutPushoutLeftIsPushout
  ¬∑ exact pushoutIsPushout _ _
#align category_theory.limits.pushout_assoc_is_pushout CategoryTheory.Limits.pushoutAssocIsPushout

theorem hasPushout_assoc [HasPushout (g‚ÇÉ ‚â´ f‚ÇÇ) g‚ÇÑ] : HasPushout g‚ÇÅ (g‚ÇÇ ‚â´ f‚ÇÉ) :=
  ‚ü®‚ü®‚ü®_, pushoutAssocIsPushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ‚ü©‚ü©‚ü©
#align category_theory.limits.has_pushout_assoc CategoryTheory.Limits.hasPushout_assoc

/-- `X‚ÇÅ ‚®ø[Z‚ÇÅ] (X‚ÇÇ ‚®ø[Z‚ÇÇ] X‚ÇÉ)` is the pushout `(X‚ÇÅ ‚®ø[Z‚ÇÅ] X‚ÇÇ) √ó[X‚ÇÇ] (X‚ÇÇ ‚®ø[Z‚ÇÇ] X‚ÇÉ)`. -/
def pushoutPushoutRightIsPushout [HasPushout g‚ÇÅ (g‚ÇÇ ‚â´ f‚ÇÉ)] :
    IsColimit (PushoutCocone.mk l‚ÇÅ l‚ÇÇ (show f‚ÇÇ ‚â´ l‚ÇÅ = f‚ÇÉ ‚â´ l‚ÇÇ from pushout.inr_desc _ _ _)) := by
  apply rightSquareIsPushout
  ¬∑ exact pushoutIsPushout _ _
  ¬∑ convert pushoutIsPushout g‚ÇÅ (g‚ÇÇ ‚â´ f‚ÇÉ)
    rw [pushout.inl_desc]
#align category_theory.limits.pushout_pushout_right_is_pushout CategoryTheory.Limits.pushoutPushoutRightIsPushout

/-- `X‚ÇÅ ‚®ø[Z‚ÇÅ] (X‚ÇÇ ‚®ø[Z‚ÇÇ] X‚ÇÉ)` is the pushout `(X‚ÇÅ ‚®ø[Z‚ÇÅ] X‚ÇÇ) ‚®ø[Z‚ÇÇ] X‚ÇÉ`. -/
def pushoutAssocSymmIsPushout [HasPushout g‚ÇÅ (g‚ÇÇ ‚â´ f‚ÇÉ)] :
    IsColimit
      (PushoutCocone.mk l‚ÇÅ (f‚ÇÑ ‚â´ l‚ÇÇ)
        (show (g‚ÇÉ ‚â´ f‚ÇÇ) ‚â´ l‚ÇÅ = g‚ÇÑ ‚â´ f‚ÇÑ ‚â´ l‚ÇÇ by
          rw [Category.assoc, pushout.inr_desc, pushout.condition_assoc])) := by
  apply PushoutCocone.isColimitOfFlip
  apply bigSquareIsPushout
  ¬∑ apply PushoutCocone.isColimitOfFlip
    apply pushoutPushoutRightIsPushout
  ¬∑ apply PushoutCocone.isColimitOfFlip
    exact pushoutIsPushout g‚ÇÉ g‚ÇÑ
  ¬∑ exact pushout.condition.symm
  ¬∑ exact (pushout.inr_desc _ _ _).symm
#align category_theory.limits.pushout_assoc_symm_is_pushout CategoryTheory.Limits.pushoutAssocSymmIsPushout

theorem hasPushout_assoc_symm [HasPushout g‚ÇÅ (g‚ÇÇ ‚â´ f‚ÇÉ)] : HasPushout (g‚ÇÉ ‚â´ f‚ÇÇ) g‚ÇÑ :=
  ‚ü®‚ü®‚ü®_, pushoutAssocSymmIsPushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ‚ü©‚ü©‚ü©
#align category_theory.limits.has_pushout_assoc_symm CategoryTheory.Limits.hasPushout_assoc_symm

-- Porting note: these are not propagating so moved into statements
-- variable [HasPushout (g‚ÇÉ ‚â´ f‚ÇÇ) g‚ÇÑ] [HasPushout g‚ÇÅ (g‚ÇÇ ‚â´ f‚ÇÉ)]

/-- The canonical isomorphism `(X‚ÇÅ ‚®ø[Z‚ÇÅ] X‚ÇÇ) ‚®ø[Z‚ÇÇ] X‚ÇÉ ‚âÖ X‚ÇÅ ‚®ø[Z‚ÇÅ] (X‚ÇÇ ‚®ø[Z‚ÇÇ] X‚ÇÉ)`. -/
noncomputable def pushoutAssoc [HasPushout (g‚ÇÉ ‚â´ (pushout.inr : X‚ÇÇ ‚ü∂ Y‚ÇÅ)) g‚ÇÑ]
    [HasPushout g‚ÇÅ (g‚ÇÇ ‚â´ (pushout.inl : X‚ÇÇ ‚ü∂ Y‚ÇÇ))] :
    pushout (g‚ÇÉ ‚â´ pushout.inr : _ ‚ü∂ pushout g‚ÇÅ g‚ÇÇ) g‚ÇÑ ‚âÖ
      pushout g‚ÇÅ (g‚ÇÇ ‚â´ pushout.inl : _ ‚ü∂ pushout g‚ÇÉ g‚ÇÑ) :=
  (pushoutPushoutLeftIsPushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).coconePointUniqueUpToIso
    (pushoutPushoutRightIsPushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ)
#align category_theory.limits.pushout_assoc CategoryTheory.Limits.pushoutAssoc

@[reassoc (attr := simp)]
theorem inl_inl_pushoutAssoc_hom [HasPushout (g‚ÇÉ ‚â´ (pushout.inr : X‚ÇÇ ‚ü∂ Y‚ÇÅ)) g‚ÇÑ]
    [HasPushout g‚ÇÅ (g‚ÇÇ ‚â´ (pushout.inl : X‚ÇÇ ‚ü∂ Y‚ÇÇ))] :
    pushout.inl ‚â´ pushout.inl ‚â´ (pushoutAssoc g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).hom = pushout.inl := by
  trans f‚ÇÅ ‚â´ l‚ÇÅ
  ¬∑ congr 1
    exact
      (pushoutPushoutLeftIsPushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).comp_coconePointUniqueUpToIso_hom _
        WalkingCospan.left
  ¬∑ exact pushout.inl_desc _ _ _
#align category_theory.limits.inl_inl_pushout_assoc_hom CategoryTheory.Limits.inl_inl_pushoutAssoc_hom

@[reassoc (attr := simp)]
theorem inr_inl_pushoutAssoc_hom [HasPushout (g‚ÇÉ ‚â´ (pushout.inr : X‚ÇÇ ‚ü∂ Y‚ÇÅ)) g‚ÇÑ]
    [HasPushout g‚ÇÅ (g‚ÇÇ ‚â´ (pushout.inl : X‚ÇÇ ‚ü∂ Y‚ÇÇ))] :
    pushout.inr ‚â´ pushout.inl ‚â´ (pushoutAssoc g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).hom = pushout.inl ‚â´ pushout.inr := by
  trans f‚ÇÇ ‚â´ l‚ÇÅ
  ¬∑ congr 1
    exact
      (pushoutPushoutLeftIsPushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).comp_coconePointUniqueUpToIso_hom _
        WalkingCospan.left
  ¬∑ exact pushout.inr_desc _ _ _
#align category_theory.limits.inr_inl_pushout_assoc_hom CategoryTheory.Limits.inr_inl_pushoutAssoc_hom

@[reassoc (attr := simp)]
theorem inr_inr_pushoutAssoc_inv [HasPushout (g‚ÇÉ ‚â´ (pushout.inr : X‚ÇÇ ‚ü∂ Y‚ÇÅ)) g‚ÇÑ]
    [HasPushout g‚ÇÅ (g‚ÇÇ ‚â´ (pushout.inl : X‚ÇÇ ‚ü∂ Y‚ÇÇ))] :
    pushout.inr ‚â´ pushout.inr ‚â´ (pushoutAssoc g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).inv = pushout.inr := by
  trans f‚ÇÑ ‚â´ l‚ÇÇ'
  ¬∑ congr 1
    exact
      (pushoutPushoutLeftIsPushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).comp_coconePointUniqueUpToIso_inv
        (pushoutPushoutRightIsPushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ) WalkingCospan.right
  ¬∑ exact pushout.inr_desc _ _ _
#align category_theory.limits.inr_inr_pushout_assoc_inv CategoryTheory.Limits.inr_inr_pushoutAssoc_inv

@[reassoc (attr := simp)]
theorem inl_pushoutAssoc_inv [HasPushout (g‚ÇÉ ‚â´ (pushout.inr : X‚ÇÇ ‚ü∂ Y‚ÇÅ)) g‚ÇÑ]
    [HasPushout g‚ÇÅ (g‚ÇÇ ‚â´ (pushout.inl : X‚ÇÇ ‚ü∂ Y‚ÇÇ))] :
    pushout.inl ‚â´ (pushoutAssoc g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).inv = pushout.inl ‚â´ pushout.inl := by
  rw [Iso.comp_inv_eq, Category.assoc, inl_inl_pushoutAssoc_hom]
#align category_theory.limits.inl_pushout_assoc_inv CategoryTheory.Limits.inl_pushoutAssoc_inv

@[reassoc (attr := simp)]
theorem inl_inr_pushoutAssoc_inv [HasPushout (g‚ÇÉ ‚â´ (pushout.inr : X‚ÇÇ ‚ü∂ Y‚ÇÅ)) g‚ÇÑ]
    [HasPushout g‚ÇÅ (g‚ÇÇ ‚â´ (pushout.inl : X‚ÇÇ ‚ü∂ Y‚ÇÇ))] :
    pushout.inl ‚â´ pushout.inr ‚â´ (pushoutAssoc g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).inv = pushout.inr ‚â´ pushout.inl := by
  rw [‚Üê Category.assoc, Iso.comp_inv_eq, Category.assoc, inr_inl_pushoutAssoc_hom]
#align category_theory.limits.inl_inr_pushout_assoc_inv CategoryTheory.Limits.inl_inr_pushoutAssoc_inv

@[reassoc (attr := simp)]
theorem inr_pushoutAssoc_hom [HasPushout (g‚ÇÉ ‚â´ (pushout.inr : X‚ÇÇ ‚ü∂ Y‚ÇÅ)) g‚ÇÑ]
    [HasPushout g‚ÇÅ (g‚ÇÇ ‚â´ (pushout.inl : X‚ÇÇ ‚ü∂ Y‚ÇÇ))] :
    pushout.inr ‚â´ (pushoutAssoc g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).hom = pushout.inr ‚â´ pushout.inr := by
  rw [‚Üê Iso.eq_comp_inv, Category.assoc, inr_inr_pushoutAssoc_inv]
#align category_theory.limits.inr_pushout_assoc_hom CategoryTheory.Limits.inr_pushoutAssoc_hom

end PushoutAssoc

end CategoryTheory.Limits
