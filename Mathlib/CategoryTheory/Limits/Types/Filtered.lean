/-
Copyright (c) 2018 Kim Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison, Reid Barton
-/
import Mathlib.CategoryTheory.Limits.Types.Colimits
import Mathlib.CategoryTheory.Filtered.Basic

/-!
# Filtered colimits in the category of types.

We give a characterisation of the equality in filtered colimits in `Type` as a
lemma `CategoryTheory.Limits.Types.FilteredColimit.colimit_eq_iff`:
`colimit.Œπ F i xi = colimit.Œπ F j xj ‚Üî ‚àÉ k (f : i ‚ü∂ k) (g : j ‚ü∂ k), F.map f xi = F.map g xj`.

-/

open CategoryTheory CategoryTheory.Limits

universe v u w

namespace CategoryTheory.Limits.Types.FilteredColimit

variable {J : Type v} [Category.{w} J] (F : J ‚•§ Type u)

attribute [local instance] small_quot_of_hasColimit

/- For filtered colimits of types, we can give an explicit description
  of the equivalence relation generated by the relation used to form
  the colimit. -/

/-- An alternative relation on `Œ£ j, F.obj j`,
which generates the same equivalence relation as we use to define the colimit in `Type` above,
but that is more convenient when working with filtered colimits.

Elements in `F.obj j` and `F.obj j'` are equivalent if there is some `k : J` to the right
where their images are equal.
-/
protected def Rel (x y : Œ£ j, F.obj j) : Prop :=
  ‚àÉ (k : _) (f : x.1 ‚ü∂ k) (g : y.1 ‚ü∂ k), F.map f x.2 = F.map g y.2

theorem rel_of_quot_rel (x y : Œ£ j, F.obj j) :
    Quot.Rel F x y ‚Üí FilteredColimit.Rel.{v, u} F x y :=
  fun ‚ü®f, h‚ü© => ‚ü®y.1, f, ùüô y.1, by rw [‚Üê h, FunctorToTypes.map_id_apply]‚ü©

theorem eqvGen_quot_rel_of_rel (x y : Œ£ j, F.obj j) :
    FilteredColimit.Rel.{v, u} F x y ‚Üí Relation.EqvGen (Quot.Rel F) x y := fun ‚ü®k, f, g, h‚ü© => by
  refine Relation.EqvGen.trans _ ‚ü®k, F.map f x.2‚ü© _ ?_ ?_
  ¬∑ exact (Relation.EqvGen.rel _ _ ‚ü®f, rfl‚ü©)
  ¬∑ exact (Relation.EqvGen.symm _ _ (Relation.EqvGen.rel _ _ ‚ü®g, h‚ü©))

/-- Recognizing filtered colimits of types. -/
noncomputable def isColimitOf (t : Cocone F) (hsurj : ‚àÄ x : t.pt, ‚àÉ i xi, x = t.Œπ.app i xi)
    (hinj :
      ‚àÄ i j xi xj,
        t.Œπ.app i xi = t.Œπ.app j xj ‚Üí ‚àÉ (k : _) (f : i ‚ü∂ k) (g : j ‚ü∂ k), F.map f xi = F.map g xj) :
    IsColimit t := by
  let Œ± : t.pt ‚Üí J := fun x => (hsurj x).choose
  let f : ‚àÄ (x : t.pt), F.obj (Œ± x) := fun x => (hsurj x).choose_spec.choose
  have hf : ‚àÄ (x : t.pt), x = t.Œπ.app _ (f x) := fun x => (hsurj x).choose_spec.choose_spec
  exact
    { desc := fun s x => s.Œπ.app _ (f x)
      fac := fun s j => by
        ext y
        obtain ‚ü®k, l, g, eq‚ü© := hinj _ _ _ _ (hf (t.Œπ.app j y))
        have h := congr_fun (s.Œπ.naturality g) (f (t.Œπ.app j y))
        have h' := congr_fun (s.Œπ.naturality l) y
        dsimp at h h' ‚ä¢
        rw [‚Üê h, ‚Üê eq, h']
      uniq := fun s m hm => by
        ext x
        dsimp
        nth_rw 1 [hf x]
        rw [‚Üê hm, types_comp_apply] }

variable [IsFilteredOrEmpty J]

/-- Recognizing filtered colimits of types. The injectivity condition here is
slightly easier to check as compared to `isColimitOf`. -/
noncomputable def isColimitOf' (t : Cocone F) (hsurj : ‚àÄ x : t.pt, ‚àÉ i xi, x = t.Œπ.app i xi)
    (hinj : ‚àÄ i x y, t.Œπ.app i x = t.Œπ.app i y ‚Üí ‚àÉ (k : _) (f : i ‚ü∂ k), F.map f x = F.map f y) :
    IsColimit t :=
  isColimitOf _ _ hsurj (fun i j xi xj h ‚Ü¶ by
    obtain ‚ü®k, g, hg‚ü© := hinj (IsFiltered.max i j) (F.map (IsFiltered.leftToMax i j) xi)
      (F.map (IsFiltered.rightToMax i j) xj) (by simp [FunctorToTypes.naturality, h])
    exact ‚ü®k, IsFiltered.leftToMax i j ‚â´ g, IsFiltered.rightToMax i j ‚â´ g, by simpa using hg‚ü©)

protected theorem rel_equiv : _root_.Equivalence (FilteredColimit.Rel.{v, u} F) where
  refl x := ‚ü®x.1, ùüô x.1, ùüô x.1, rfl‚ü©
  symm := fun ‚ü®k, f, g, h‚ü© => ‚ü®k, g, f, h.symm‚ü©
  trans {x y z} := fun ‚ü®k, f, g, h‚ü© ‚ü®k', f', g', h'‚ü© =>
    let ‚ü®l, fl, gl, _‚ü© := IsFilteredOrEmpty.cocone_objs k k'
    let ‚ü®m, n, hn‚ü© := IsFilteredOrEmpty.cocone_maps (g ‚â´ fl) (f' ‚â´ gl)
    ‚ü®m, f ‚â´ fl ‚â´ n, g' ‚â´ gl ‚â´ n,
      calc
        F.map (f ‚â´ fl ‚â´ n) x.2 = F.map (fl ‚â´ n) (F.map f x.2) := by simp
        _ = F.map (fl ‚â´ n) (F.map g y.2) := by rw [h]
        _ = F.map ((g ‚â´ fl) ‚â´ n) y.2 := by simp
        _ = F.map ((f' ‚â´ gl) ‚â´ n) y.2 := by rw [hn]
        _ = F.map (gl ‚â´ n) (F.map f' y.2) := by simp
        _ = F.map (gl ‚â´ n) (F.map g' z.2) := by rw [h']
        _ = F.map (g' ‚â´ gl ‚â´ n) z.2 := by simp‚ü©

protected theorem rel_eq_eqvGen_quot_rel :
    FilteredColimit.Rel.{v, u} F = Relation.EqvGen (Quot.Rel F) := by
  ext ‚ü®j, x‚ü© ‚ü®j', y‚ü©
  constructor
  ¬∑ apply eqvGen_quot_rel_of_rel
  ¬∑ rw [‚Üê (FilteredColimit.rel_equiv F).eqvGen_iff]
    exact Relation.EqvGen.mono (rel_of_quot_rel F)

theorem colimit_eq_iff_aux [HasColimit F] {i j : J} {xi : F.obj i} {xj : F.obj j} :
    (colimitCocone F).Œπ.app i xi = (colimitCocone F).Œπ.app j xj ‚Üî
      FilteredColimit.Rel.{v, u} F ‚ü®i, xi‚ü© ‚ü®j, xj‚ü© := by
  dsimp
  rw [‚Üê (equivShrink _).symm.injective.eq_iff, Equiv.symm_apply_apply, Equiv.symm_apply_apply,
    Quot.eq, FilteredColimit.rel_eq_eqvGen_quot_rel]

theorem isColimit_eq_iff {t : Cocone F} (ht : IsColimit t) {i j : J} {xi : F.obj i} {xj : F.obj j} :
    t.Œπ.app i xi = t.Œπ.app j xj ‚Üî ‚àÉ (k : _) (f : i ‚ü∂ k) (g : j ‚ü∂ k), F.map f xi = F.map g xj := by
  have : HasColimit F := ‚ü®_, ht‚ü©
  refine Iff.trans ?_ (colimit_eq_iff_aux F)
  rw [‚Üê (IsColimit.coconePointUniqueUpToIso ht (colimitCoconeIsColimit F)).toEquiv.injective.eq_iff]
  convert Iff.rfl
  ¬∑ exact (congrFun
      (IsColimit.comp_coconePointUniqueUpToIso_hom ht (colimitCoconeIsColimit F) _) xi).symm
  ¬∑ exact (congrFun
      (IsColimit.comp_coconePointUniqueUpToIso_hom ht (colimitCoconeIsColimit F) _) xj).symm

variable {F} in
theorem isColimit_eq_iff' {t : Cocone F} (ht : IsColimit t) {i : J} (x y : F.obj i) :
    t.Œπ.app i x = t.Œπ.app i y ‚Üî ‚àÉ (j : _) (f : i ‚ü∂ j), F.map f x = F.map f y := by
  rw [isColimit_eq_iff _ ht]
  constructor
  ¬∑ rintro ‚ü®k, f, g, h‚ü©
    refine ‚ü®IsFiltered.coeq f g, f ‚â´ IsFiltered.coeqHom f g, ?_‚ü©
    conv_rhs => rw [IsFiltered.coeq_condition]
    simp only [FunctorToTypes.map_comp_apply, h]
  ¬∑ rintro ‚ü®j, f, h‚ü©
    exact ‚ü®j, f, f, h‚ü©

theorem colimit_eq_iff [HasColimit F] {i j : J} {xi : F.obj i} {xj : F.obj j} :
    colimit.Œπ F i xi = colimit.Œπ F j xj ‚Üî
      ‚àÉ (k : _) (f : i ‚ü∂ k) (g : j ‚ü∂ k), F.map f xi = F.map g xj :=
  isColimit_eq_iff _ (colimit.isColimit F)

end CategoryTheory.Limits.Types.FilteredColimit
