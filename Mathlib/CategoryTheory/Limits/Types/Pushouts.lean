/-
Copyright (c) 2025 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
module

public import Mathlib.CategoryTheory.Limits.Types.Pullbacks

/-!
# Pushouts in `Type`

We describe the pushout of two maps `f : S ‚ü∂ X‚ÇÅ` and `g : S ‚ü∂ X‚ÇÇ`
in the category of types as the quotient of `X‚ÇÅ ‚äï X‚ÇÇ` by the
equivalence relation generated by a relation. We also study
the particular case when `f` is injective (in the file
`CategoryTheory.Types.Monomorphisms`, it is deduced that monomorphisms
are stable under cobase change in the category of types).

-/

@[expose] public section

universe u

namespace CategoryTheory.Limits.Types

instance : HasPushouts.{u} (Type u) :=
  hasPushouts_of_hasWidePushouts.{u} (Type u)

variable {S X‚ÇÅ X‚ÇÇ : Type u} (f : S ‚ü∂ X‚ÇÅ) (g : S ‚ü∂ X‚ÇÇ)

/-- The pushout of two maps `f : S ‚ü∂ X‚ÇÅ` and `g : S ‚ü∂ X‚ÇÇ` is the quotient
by the equivalence relation on `X‚ÇÅ ‚äï X‚ÇÇ` generated by this relation. -/
inductive Pushout.Rel (f : S ‚ü∂ X‚ÇÅ) (g : S ‚ü∂ X‚ÇÇ) : X‚ÇÅ ‚äï X‚ÇÇ ‚Üí X‚ÇÅ ‚äï X‚ÇÇ ‚Üí Prop
  | inl_inr (s : S) : Pushout.Rel f g (Sum.inl (f s)) (Sum.inr (g s))

/-- Construction of the pushout in the category of types, as a quotient of `X‚ÇÅ ‚äï X‚ÇÇ`. -/
def Pushout : Type u := _root_.Quot (Pushout.Rel f g)

/-- In case `f : S ‚ü∂ X‚ÇÅ` is a monomorphism, this relation is the equivalence relation
generated by `Pushout.Rel f g`. -/
inductive Pushout.Rel' : X‚ÇÅ ‚äï X‚ÇÇ ‚Üí X‚ÇÅ ‚äï X‚ÇÇ ‚Üí Prop
  | refl (x : X‚ÇÅ ‚äï X‚ÇÇ) : Rel' x x
  | inl_inl (x‚ÇÄ y‚ÇÄ : S) (h : g x‚ÇÄ = g y‚ÇÄ) : Rel' (Sum.inl (f x‚ÇÄ)) (Sum.inl (f y‚ÇÄ))
  | inl_inr (s : S) : Rel' (Sum.inl (f s)) (Sum.inr (g s))
  | inr_inl (s : S) : Rel' (Sum.inr (g s)) (Sum.inl (f s))

/-- The quotient of `X‚ÇÅ ‚äï X‚ÇÇ` by the relation `PushoutRel' f g`. -/
def Pushout' : Type u := _root_.Quot (Pushout.Rel' f g)

namespace Pushout

/-- The left inclusion in the constructed pushout `Pushout f g`. -/
@[simp]
def inl : X‚ÇÅ ‚ü∂ Pushout f g := fun x => Quot.mk _ (Sum.inl x)

/-- The right inclusion in the constructed pushout `Pushout f g`. -/
@[simp]
def inr : X‚ÇÇ ‚ü∂ Pushout f g := fun x => Quot.mk _ (Sum.inr x)

lemma condition : f ‚â´ inl f g = g ‚â´ inr f g := by
  ext x
  exact Quot.sound (Rel.inl_inr x)

/-- The constructed pushout cocone in the category of types. -/
@[simps!]
def cocone : PushoutCocone f g := PushoutCocone.mk _ _ (condition f g)

/-- The cocone `cocone f g` is colimit. -/
def isColimitCocone : IsColimit (cocone f g) :=
  PushoutCocone.IsColimit.mk _ (fun s => Quot.lift (fun x => match x with
      | Sum.inl x‚ÇÅ => s.inl x‚ÇÅ
      | Sum.inr x‚ÇÇ => s.inr x‚ÇÇ) (by
    rintro _ _ ‚ü®t‚ü©
    exact congr_fun s.condition t)) (fun _ => rfl) (fun _ => rfl) (fun s m h‚ÇÅ h‚ÇÇ => by
      ext ‚ü®x‚ÇÅ | x‚ÇÇ‚ü©
      ¬∑ exact congr_fun h‚ÇÅ x‚ÇÅ
      ¬∑ exact congr_fun h‚ÇÇ x‚ÇÇ)

@[simp]
lemma inl_rel'_inl_iff (x‚ÇÅ y‚ÇÅ : X‚ÇÅ) :
    Rel' f g (Sum.inl x‚ÇÅ) (Sum.inl y‚ÇÅ) ‚Üî x‚ÇÅ = y‚ÇÅ ‚à®
      ‚àÉ (x‚ÇÄ y‚ÇÄ : S) (_ : g x‚ÇÄ = g y‚ÇÄ), x‚ÇÅ = f x‚ÇÄ ‚àß y‚ÇÅ = f y‚ÇÄ := by
  constructor
  ¬∑ rintro (_ | ‚ü®_, _, h‚ü©)
    ¬∑ exact Or.inl rfl
    ¬∑ exact Or.inr ‚ü®_, _, h, rfl, rfl‚ü©
  ¬∑ rintro (rfl | ‚ü®_, _, h, rfl, rfl‚ü©)
    ¬∑ apply Rel'.refl
    ¬∑ exact Rel'.inl_inl _ _ h

@[simp]
lemma inl_rel'_inr_iff (x‚ÇÅ : X‚ÇÅ) (x‚ÇÇ : X‚ÇÇ) :
    Rel' f g (Sum.inl x‚ÇÅ) (Sum.inr x‚ÇÇ) ‚Üî
      ‚àÉ (s : S), x‚ÇÅ = f s ‚àß x‚ÇÇ = g s := by
  constructor
  ¬∑ rintro ‚ü®_‚ü©
    exact ‚ü®_, rfl, rfl‚ü©
  ¬∑ rintro ‚ü®s, rfl, rfl‚ü©
    exact Rel'.inl_inr _

@[simp]
lemma inr_rel'_inr_iff (x‚ÇÇ y‚ÇÇ : X‚ÇÇ) :
    Rel' f g (Sum.inr x‚ÇÇ) (Sum.inr y‚ÇÇ) ‚Üî x‚ÇÇ = y‚ÇÇ := by
  constructor
  ¬∑ rintro ‚ü®_‚ü©
    rfl
  ¬∑ rintro rfl
    apply Rel'.refl

variable {f g}

lemma Rel'.symm {x y : X‚ÇÅ ‚äï X‚ÇÇ} (h : Rel' f g x y) :
    Rel' f g y x := by
  obtain _ | ‚ü®_, _, h‚ü© | _ | _ := h
  ¬∑ apply Rel'.refl
  ¬∑ exact Rel'.inl_inl _ _ h.symm
  ¬∑ exact Rel'.inr_inl _
  ¬∑ exact Rel'.inl_inr _

variable (f g)

lemma equivalence_rel' [Mono f] : _root_.Equivalence (Rel' f g) where
  refl := Rel'.refl
  symm h := h.symm
  trans := by
    rintro x y z (_ | ‚ü®_, _, h‚ü© | s | _) hyz
    ¬∑ exact hyz
    ¬∑ obtain z‚ÇÅ | z‚ÇÇ := z
      ¬∑ rw [inl_rel'_inl_iff] at hyz
        obtain rfl | ‚ü®_, _, h', h'', rfl‚ü© := hyz
        ¬∑ exact Rel'.inl_inl _ _ h
        ¬∑ obtain rfl := (mono_iff_injective f).1 inferInstance h''
          exact Rel'.inl_inl _ _ (h.trans h')
      ¬∑ rw [inl_rel'_inr_iff] at hyz
        obtain ‚ü®s, hs, rfl‚ü© := hyz
        obtain rfl := (mono_iff_injective f).1 inferInstance hs
        rw [‚Üê h]
        apply Rel'.inl_inr
    ¬∑ obtain z‚ÇÅ | z‚ÇÇ := z
      ¬∑ replace hyz := hyz.symm
        rw [inl_rel'_inr_iff] at hyz
        obtain ‚ü®s', rfl, hs'‚ü© := hyz
        exact Rel'.inl_inl _ _ hs'
      ¬∑ rw [inr_rel'_inr_iff] at hyz
        subst hyz
        apply Rel'.inl_inr
    ¬∑ obtain z‚ÇÅ | z‚ÇÇ := z
      ¬∑ rw [inl_rel'_inl_iff] at hyz
        obtain rfl | ‚ü®_, _, h, h', rfl‚ü© := hyz
        ¬∑ apply Rel'.inr_inl
        ¬∑ obtain rfl := (mono_iff_injective f).1 inferInstance h'
          rw [h]
          apply Rel'.inr_inl
      ¬∑ rw [inl_rel'_inr_iff] at hyz
        obtain ‚ü®s, hs, rfl‚ü© := hyz
        obtain rfl := (mono_iff_injective f).1 inferInstance hs
        apply Rel'.refl

/-- The obvious equivalence `Pushout f g ‚âÉ Pushout' f g`. -/
def equivPushout' : Pushout f g ‚âÉ Pushout' f g where
  toFun := Quot.lift (Quot.mk _) (by
    rintro _ _ ‚ü®‚ü©
    apply Quot.sound
    apply Rel'.inl_inr)
  invFun := Quot.lift (Quot.mk _) (by
    rintro a b (_ | ‚ü®x‚ÇÄ, y‚ÇÄ, h‚ü© | _ | _)
    ¬∑ rfl
    ¬∑ have h‚ÇÄ : Rel f g _ _ := Rel.inl_inr x‚ÇÄ
      rw [Quot.sound h‚ÇÄ, h]
      symm
      apply Quot.sound
      apply Rel.inl_inr
    ¬∑ apply Quot.sound
      apply Rel.inl_inr
    ¬∑ symm
      apply Quot.sound
      apply Rel.inl_inr)
  left_inv := by rintro ‚ü®x‚ü©; rfl
  right_inv := by rintro ‚ü®x‚ü©; rfl

lemma quot_mk_eq_iff [Mono f] (a b : X‚ÇÅ ‚äï X‚ÇÇ) :
    (Quot.mk _ a : Pushout f g) = Quot.mk _ b ‚Üî Rel' f g a b := by
  rw [‚Üê (equivalence_rel' f g).quot_mk_eq_iff]
  exact ‚ü®fun h => (equivPushout' f g).symm.injective h,
    fun h => (equivPushout' f g).injective h‚ü©

lemma inl_eq_inr_iff [Mono f] (x‚ÇÅ : X‚ÇÅ) (x‚ÇÇ : X‚ÇÇ) :
    (inl f g x‚ÇÅ = inr f g x‚ÇÇ) ‚Üî
      ‚àÉ (s : S), f s = x‚ÇÅ ‚àß g s = x‚ÇÇ := by
  refine (Pushout.quot_mk_eq_iff f g (Sum.inl x‚ÇÅ) (Sum.inr x‚ÇÇ)).trans ?_
  constructor
  ¬∑ rintro ‚ü®‚ü©
    exact ‚ü®_, rfl, rfl‚ü©
  ¬∑ rintro ‚ü®s, rfl, rfl‚ü©
    apply Rel'.inl_inr

instance mono_inr [Mono f] : Mono (inr f g) := by
  rw [mono_iff_injective]
  intro x‚ÇÇ y‚ÇÇ h
  simpa using (Pushout.quot_mk_eq_iff f g (Sum.inr x‚ÇÇ) (Sum.inr y‚ÇÇ)).1 h

end Pushout

variable {f g}

lemma pushoutCocone_inl_eq_inr_imp_of_iso {c c' : PushoutCocone f g} (e : c ‚âÖ c')
    (x‚ÇÅ : X‚ÇÅ) (x‚ÇÇ : X‚ÇÇ) (h : c.inl x‚ÇÅ = c.inr x‚ÇÇ) :
    c'.inl x‚ÇÅ = c'.inr x‚ÇÇ := by
  convert congr_arg e.hom.hom h
  ¬∑ exact congr_fun (e.hom.w WalkingSpan.left).symm x‚ÇÅ
  ¬∑ exact congr_fun (e.hom.w WalkingSpan.right).symm x‚ÇÇ

lemma pushoutCocone_inl_eq_inr_iff_of_iso {c c' : PushoutCocone f g} (e : c ‚âÖ c')
    (x‚ÇÅ : X‚ÇÅ) (x‚ÇÇ : X‚ÇÇ) :
    c.inl x‚ÇÅ = c.inr x‚ÇÇ ‚Üî c'.inl x‚ÇÅ = c'.inr x‚ÇÇ := by
  constructor
  ¬∑ apply pushoutCocone_inl_eq_inr_imp_of_iso e
  ¬∑ apply pushoutCocone_inl_eq_inr_imp_of_iso e.symm

lemma pushoutCocone_inl_eq_inr_iff_of_isColimit {c : PushoutCocone f g} (hc : IsColimit c)
    (h‚ÇÅ : Function.Injective f) (x‚ÇÅ : X‚ÇÅ) (x‚ÇÇ : X‚ÇÇ) :
    c.inl x‚ÇÅ = c.inr x‚ÇÇ ‚Üî ‚àÉ (s : S), f s = x‚ÇÅ ‚àß g s = x‚ÇÇ := by
  rw [pushoutCocone_inl_eq_inr_iff_of_iso
    (Cocones.ext (IsColimit.coconePointUniqueUpToIso hc (Pushout.isColimitCocone f g))
    (by simp))]
  have := (mono_iff_injective f).2 h‚ÇÅ
  apply Pushout.inl_eq_inr_iff

lemma pushoutCocone_inr_mono_of_isColimit {c : PushoutCocone f g} (hc : IsColimit c)
    [Mono f] : Mono c.inr := by
  change Mono ((Pushout.inr f g) ‚â´
    ((Cocones.forget _).mapIso
      (Cocones.ext (IsColimit.coconePointUniqueUpToIso hc
        (Pushout.isColimitCocone f g)) (by simp))).inv)
  infer_instance

lemma pushoutCocone_inr_injective_of_isColimit {c : PushoutCocone f g} (hc : IsColimit c)
    (h‚ÇÅ : Function.Injective f) : Function.Injective c.inr := by
  rw [‚Üê mono_iff_injective] at h‚ÇÅ ‚ä¢
  exact pushoutCocone_inr_mono_of_isColimit hc

instance mono_inl [Mono g] : Mono (Pushout.inl f g) :=
  pushoutCocone_inr_mono_of_isColimit
    (PushoutCocone.flipIsColimit (Pushout.isColimitCocone f g))

instance [Mono f] : Mono (pushout.inr f g) :=
  (pushoutCocone_inr_mono_of_isColimit (pushoutIsPushout f g) :)

instance [Mono g] : Mono (pushout.inl f g) :=
  pushoutCocone_inr_mono_of_isColimit
    (PushoutCocone.flipIsColimit (pushoutIsPushout f g))

section

variable {X‚ÇÅ X‚ÇÇ X‚ÇÉ X‚ÇÑ X‚ÇÖ : Type u} {t : X‚ÇÅ ‚ü∂ X‚ÇÇ} {r : X‚ÇÇ ‚ü∂ X‚ÇÑ}
  {l : X‚ÇÅ ‚ü∂ X‚ÇÉ} {b : X‚ÇÉ ‚ü∂ X‚ÇÑ}

lemma eq_or_eq_of_isPushout (h : IsPushout t l r b)
    (x‚ÇÑ : X‚ÇÑ) : (‚àÉ x‚ÇÇ, r x‚ÇÇ = x‚ÇÑ) ‚à® ‚àÉ x‚ÇÉ, b x‚ÇÉ = x‚ÇÑ := by
  obtain ‚ü®j, x, rfl‚ü© := jointly_surjective_of_isColimit h.isColimit x‚ÇÑ
  obtain (_ | _ | _) := j
  ¬∑ exact Or.inl ‚ü®t x, by simp‚ü©
  ¬∑ exact Or.inl ‚ü®x, rfl‚ü©
  ¬∑ exact Or.inr ‚ü®x, rfl‚ü©

lemma eq_or_eq_of_isPushout' (h : IsPushout t l r b)
    (x‚ÇÑ : X‚ÇÑ) : (‚àÉ x‚ÇÇ, r x‚ÇÇ = x‚ÇÑ) ‚à® ‚àÉ x‚ÇÉ, b x‚ÇÉ = x‚ÇÑ ‚àß x‚ÇÉ ‚àâ Set.range l := by
  obtain h‚ÇÅ | ‚ü®x‚ÇÉ, hx‚ÇÉ‚ü© := eq_or_eq_of_isPushout h x‚ÇÑ
  ¬∑ exact Or.inl h‚ÇÅ
  ¬∑ by_cases h‚ÇÇ : x‚ÇÉ ‚àà Set.range l
    ¬∑ obtain ‚ü®x‚ÇÅ, rfl‚ü© := h‚ÇÇ
      exact Or.inl ‚ü®t x‚ÇÅ, by simpa only [‚Üê hx‚ÇÉ] using congr_fun h.w x‚ÇÅ‚ü©
    ¬∑ exact Or.inr ‚ü®x‚ÇÉ, hx‚ÇÉ, h‚ÇÇ‚ü©

/-- A pushout square in `Type` where the top map is injective is a pullback square.
This is also essentially the lemma `isPullback_of_isPushout_of_mono_left`
from the file `CategoryTheory.Adhesive` in the case of the adhesive category of types. -/
lemma isPullback_of_isPushout (h : IsPushout t l r b) (ht : Function.Injective t) :
    IsPullback t l r b := by
  rw [isPullback_iff]
  refine ‚ü®h.w, fun x‚ÇÅ y‚ÇÅ ‚ü®h‚ÇÇ, _‚ü© ‚Ü¶ ht h‚ÇÇ, fun x‚ÇÇ x‚ÇÉ hx ‚Ü¶ ?_‚ü©
  have := (pushoutCocone_inl_eq_inr_iff_of_isColimit h.isColimit ht x‚ÇÇ x‚ÇÉ).1 hx
  grind

/-- Consider a pushout square involving types `X‚ÇÅ`, `X‚ÇÇ`, `X‚ÇÉ` and `X‚ÇÑ`:
```
     t
 X‚ÇÅ  ‚ü∂  X‚ÇÇ
l|     |r  \
 v   b  v   \ r'
 X‚ÇÉ  ‚ü∂  X‚ÇÑ   \
  \       k\  |
   \ b'     v v
    \______> X‚ÇÖ
```
Let `k : X‚ÇÑ ‚ü∂ X‚ÇÖ`, `r' : X‚ÇÇ ‚ü∂ X‚ÇÖ` and `b' : X‚ÇÉ ‚ü∂ X‚ÇÖ` be such
that `r ‚â´ k = r'` and `b ‚â´ k = b'`. Assume that
the outer square is a pullback, that `r'` is a monomorphism
and that `b'` is injective on the complement of the range of `l`,
then `k : X‚ÇÑ ‚ü∂ X‚ÇÖ` is a monomorphism. -/
lemma mono_of_isPushout_of_isPullback {k : X‚ÇÑ ‚ü∂ X‚ÇÖ} (h‚ÇÅ : IsPushout t l r b)
    {r' : X‚ÇÇ ‚ü∂ X‚ÇÖ} {b' : X‚ÇÉ ‚ü∂ X‚ÇÖ} (h‚ÇÇ : IsPullback t l r' b')
    (facr : r ‚â´ k = r') (facb : b ‚â´ k = b') [hr' : Mono r']
    (H : ‚àÄ (x‚ÇÉ y‚ÇÉ : X‚ÇÉ) (_ : x‚ÇÉ ‚àâ Set.range l) (_ : y‚ÇÉ ‚àâ Set.range l),
      b' x‚ÇÉ = b' y‚ÇÉ ‚Üí x‚ÇÉ = y‚ÇÉ) :
    Mono k := by
  subst facr facb
  have : Function.Injective l :=
    fun x‚ÇÅ y‚ÇÅ h ‚Ü¶ ext_of_isPullback h‚ÇÇ ((mono_iff_injective _).1 hr'
      ((congr_fun h‚ÇÇ.w x‚ÇÅ).trans (Eq.trans (by simp [h]) (congr_fun h‚ÇÇ.w.symm y‚ÇÅ)))) h
  rw [mono_iff_injective] at hr' ‚ä¢
  have w := congr_fun h‚ÇÅ.w
  dsimp at w
  intro x‚ÇÉ y‚ÇÉ eq
  obtain (‚ü®x‚ÇÇ, rfl‚ü© | ‚ü®x‚ÇÉ, rfl, hx‚ÇÉ‚ü©) := eq_or_eq_of_isPushout' h‚ÇÅ x‚ÇÉ <;>
  obtain (‚ü®y‚ÇÇ, rfl‚ü© | ‚ü®y‚ÇÉ, rfl, hy‚ÇÉ‚ü©) := eq_or_eq_of_isPushout' h‚ÇÅ y‚ÇÉ
  ¬∑ obtain rfl : x‚ÇÇ = y‚ÇÇ := hr' eq
    rfl
  ¬∑ obtain ‚ü®x‚ÇÅ, rfl, rfl‚ü© := exists_of_isPullback h‚ÇÇ x‚ÇÇ y‚ÇÉ eq
    rw [w]
  ¬∑ obtain ‚ü®x‚ÇÅ, rfl, rfl‚ü© := exists_of_isPullback h‚ÇÇ y‚ÇÇ x‚ÇÉ eq.symm
    rw [w]
  ¬∑ obtain rfl := H x‚ÇÉ y‚ÇÉ hx‚ÇÉ hy‚ÇÉ eq
    rfl

/-- Consider a diagram where the outer square involving types `X‚ÇÅ`, `X‚ÇÇ`, `X‚ÇÉ` and `X‚ÇÖ`
is a pullback, where the two bottom and right triangles commute:
```
     t
 X‚ÇÅ  ‚ü∂  X‚ÇÇ
l|     |r  \
 v   b  v   \ r'
 X‚ÇÉ  ‚ü∂  X‚ÇÑ   \
  \       k\  |
   \ b'     v v
    \______> X‚ÇÖ
```
Assume that `r'` and `k` are monomorphisms, that `r` and `b` are jointly surjective,
and that `b'` is injective on the complement of the range of `l`, then
the top-left square is a pushout. -/
lemma isPushout_of_isPullback_of_mono {k : X‚ÇÑ ‚ü∂ X‚ÇÖ}
    {r' : X‚ÇÇ ‚ü∂ X‚ÇÖ} {b' : X‚ÇÉ ‚ü∂ X‚ÇÖ} (h‚ÇÅ : IsPullback t l r' b')
    (facr : r ‚â´ k = r') (facb : b ‚â´ k = b') [Mono r'] [Mono k]
    (h‚ÇÇ : Set.range r ‚äî Set.range b = Set.univ)
    (H : ‚àÄ (x‚ÇÉ y‚ÇÉ : X‚ÇÉ) (_ : x‚ÇÉ ‚àâ Set.range l) (_ : y‚ÇÉ ‚àâ Set.range l),
      b' x‚ÇÉ = b' y‚ÇÉ ‚Üí x‚ÇÉ = y‚ÇÉ) :
    IsPushout t l r b := by
  obtain ‚ü®œÜ, hœÜ‚ÇÅ, hœÜ‚ÇÇ‚ü© := pushout.exists_desc t l r b
    (by simp only [‚Üê cancel_mono k, Category.assoc, facr, facb, h‚ÇÅ.w])
  have := mono_of_isPushout_of_isPullback (IsPushout.of_hasPushout t l) h‚ÇÅ
    (k := œÜ ‚â´ k) (by cat_disch) (by cat_disch) H
  have : IsIso œÜ := by
    rw [isIso_iff_bijective]
    refine ‚ü®(mono_iff_injective _).1 (mono_of_mono œÜ k), fun x‚ÇÑ ‚Ü¶ ?_‚ü©
    have hx‚ÇÑ := Set.mem_univ x‚ÇÑ
    simp only [‚Üê h‚ÇÇ, Set.sup_eq_union, Set.mem_union, Set.mem_range] at hx‚ÇÑ
    obtain (‚ü®x‚ÇÇ, rfl‚ü© | ‚ü®x‚ÇÉ, rfl‚ü©) := hx‚ÇÑ
    ¬∑ exact ‚ü®_, congr_fun hœÜ‚ÇÅ x‚ÇÇ‚ü©
    ¬∑ exact ‚ü®_, congr_fun hœÜ‚ÇÇ x‚ÇÉ‚ü©
  exact IsPushout.of_iso (IsPushout.of_hasPushout t l)
    (Iso.refl _) (Iso.refl _) (Iso.refl _) (asIso œÜ) (by simp) (by simp)
    (by simpa) (by simpa)

/-- Consider a pullback square of types where the right map is a monomorphism.
If the right and bottom map are jointly surjective, and the bottom map
is injective on the complement on the range of the left map, then the square
is a pushout square. -/
lemma isPushout_of_isPullback_of_mono'
    (h‚ÇÅ : IsPullback t l r b) [Mono r]
    (h‚ÇÇ : Set.range r ‚äî Set.range b = Set.univ)
    (H : ‚àÄ (x‚ÇÉ y‚ÇÉ : X‚ÇÉ) (_ : x‚ÇÉ ‚àâ Set.range l) (_ : y‚ÇÉ ‚àâ Set.range l),
      b x‚ÇÉ = b y‚ÇÉ ‚Üí x‚ÇÉ = y‚ÇÉ) :
    IsPushout t l r b :=
  isPushout_of_isPullback_of_mono (k := ùüô _) h‚ÇÅ (by simp) (by simp) h‚ÇÇ H

end

end CategoryTheory.Limits.Types
