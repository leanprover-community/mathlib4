/-
Copyright (c) 2025 JoÃ«l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: JoÃ«l Riou
-/
import Mathlib.CategoryTheory.Filtered.Basic
import Mathlib.CategoryTheory.Limits.Types.ColimitType

/-!
# Filtered colimits of types

In this file, given a functor `F : J â¥¤ Type wâ‚€` from a filtered category `J`,
we compute the equivalence relation generated by
`F.ColimitTypeRel` on `(j : J) Ã— (F.obj j)`.
Given `c : CoconeTypes F`, we deduce a lemma
`Functor.CoconeTypes.injective_descColimitType_iff_of_isFiltered` which gives
a concrete condition under which the map
`F.descColimitType c : F.ColimitType â†’ c.pt` is injective, which is an
important step when proving `c.IsColimit`.

-/

universe wâ‚ wâ‚€ v u

namespace CategoryTheory

open IsFiltered

variable {J : Type u} [Category.{v} J] [IsFiltered J]

namespace Functor

variable (F : J â¥¤ Type wâ‚€)

lemma eqvGen_colimitTypeRel_iff_of_isFiltered
    (x y : (j : J) Ã— (F.obj j)) :
    Relation.EqvGen F.ColimitTypeRel x y â†”
      âˆƒ (k : J) (f : x.1 âŸ¶ k) (g : y.1 âŸ¶ k), F.map f x.2 = F.map g y.2 := by
  constructor
  Â· intro h
    induction h with
    | rel x y h =>
      obtain âŸ¨f, hâŸ© := h
      exact âŸ¨y.1, f, ğŸ™ _, by simpa using h.symmâŸ©
    | refl x => exact âŸ¨x.1, ğŸ™ _, ğŸ™ _, rflâŸ©
    | symm _ _ _ h =>
      obtain âŸ¨k, f, g, hâŸ© := h
      exact âŸ¨k, g, f, h.symmâŸ©
    | trans x y z _ _ h h' =>
      obtain âŸ¨k, f, g, hâŸ© := h
      obtain âŸ¨k', f', g', h'âŸ© := h'
      obtain âŸ¨l, a, b, h''âŸ© := span g f'
      refine âŸ¨l, f â‰« a, g' â‰« b, ?_âŸ©
      rw [FunctorToTypes.map_comp_apply, FunctorToTypes.map_comp_apply _ g', h, â† h',
        â† FunctorToTypes.map_comp_apply, â† FunctorToTypes.map_comp_apply, h'']
  Â· rintro âŸ¨k, f, f', hâŸ©
    apply Relation.EqvGen.trans (y := âŸ¨k, F.map f' y.2âŸ©)
    Â· exact .rel _ _ âŸ¨f, by rw [â† h]âŸ©
    Â· exact .symm _ _ (.rel _ _ âŸ¨f', rflâŸ©)

lemma Î¹ColimitType_eq_iff_of_isFiltered {j j' : J} (x : F.obj j) (y : F.obj j') :
    F.Î¹ColimitType j x = F.Î¹ColimitType j' y â†”
      âˆƒ (k : J) (f : j âŸ¶ k) (f' : j' âŸ¶ k), F.map f x = F.map f' y := by
  rw [Î¹ColimitType_eq_iff, eqvGen_colimitTypeRel_iff_of_isFiltered]

/-- More precise variant of the lemma `Î¹ColimitType_eq_iff_of_isFiltered`
in the case both `x` and `y` and in the same type `F.obj j`. -/
lemma Î¹ColimitType_eq_iff_of_isFiltered' {j : J} (x y : F.obj j) :
    F.Î¹ColimitType j x = F.Î¹ColimitType j y â†”
      âˆƒ (k : J) (f : j âŸ¶ k), F.map f x = F.map f y := by
  rw [Î¹ColimitType_eq_iff_of_isFiltered]
  constructor
  Â· rintro âŸ¨k, f, f', hâŸ©
    refine âŸ¨coeq f f', f â‰« coeqHom f f', ?_âŸ©
    nth_rw 2 [coeq_condition]
    simp [h]
  Â· rintro âŸ¨k, f, hâŸ©
    exact âŸ¨k, f, f, hâŸ©

namespace CoconeTypes

variable {F} (c : CoconeTypes.{wâ‚} F)

lemma descColimitType_injective_iff_of_isFiltered :
    Function.Injective (F.descColimitType c) â†”
      âˆ€ (j j' : J) (x : F.obj j) (x' : F.obj j'), c.Î¹ j x = c.Î¹ j' x' â†’
        âˆƒ (k : J) (f : j âŸ¶ k) (f' : j' âŸ¶ k), F.map f x = F.map f' x' := by
  constructor
  Â· intro h j j' x x' eq
    have : F.Î¹ColimitType j x = F.Î¹ColimitType j' x' := h eq
    rwa [Î¹ColimitType_eq_iff_of_isFiltered] at this
  Â· intro h x x' eq
    obtain âŸ¨i, x, rflâŸ© := F.Î¹ColimitType_jointly_surjective x
    obtain âŸ¨i', x', rflâŸ© := F.Î¹ColimitType_jointly_surjective x'
    simp only [descColimitType_Î¹ColimitType_apply] at eq
    obtain âŸ¨k, f, f', eqâŸ© := h _ _ _ _ eq
    rw [â† F.Î¹ColimitType_map f x, eq, F.Î¹ColimitType_map]

/-- Variant of `descColimitType_injective_iff_of_isFiltered` where we
assume both elements `x` and `x'` are in the same type `F.obj j`. -/
lemma descColimitType_injective_iff_of_isFiltered' :
    Function.Injective (F.descColimitType c) â†”
      âˆ€ (j : J) (x x' : F.obj j), c.Î¹ j x = c.Î¹ j x' â†’
        âˆƒ (k : J) (f : j âŸ¶ k), F.map f x = F.map f x' := by
  rw [descColimitType_injective_iff_of_isFiltered]
  constructor
  Â· intro h j x x' eq
    obtain âŸ¨k, f, f', eqâŸ© := h _ _ _ _ eq
    refine âŸ¨coeq f f', f â‰« coeqHom f f', ?_âŸ©
    rw [FunctorToTypes.map_comp_apply, eq, â† FunctorToTypes.map_comp_apply,
      coeq_condition]
  Â· intro h j j' x x' eq
    obtain âŸ¨k, g, eqâŸ© := h (max j j') (F.map (leftToMax _ _) x)
      (F.map (rightToMax _ _) x') (by simpa only [c.Î¹_naturality_apply])
    exact âŸ¨k, leftToMax _ _ â‰« g, rightToMax _ _ â‰« g,
      by simp only [FunctorToTypes.map_comp_apply, eq]âŸ©

end CoconeTypes

end Functor

end CategoryTheory
