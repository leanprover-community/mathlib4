/-
Copyright (c) 2025 Joël Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joël Riou
-/
import Mathlib.CategoryTheory.Filtered.Basic
import Mathlib.CategoryTheory.Limits.Types.ColimitType

/-!
# Filtered colimits of types

In this file, given a functor `F : J ⥤ Type w₀` from a filtered category `J`,
we compute the equivalence relation generated by
`F.ColimitTypeRel` on `(j : J) × (F.obj j)`.
Given `c : CoconeTypes F`, we deduce a lemma
`Functor.CoconeTypes.injective_descColimitType_iff_of_isFiltered` which gives
a concrete condition under which the map
`F.descColimitType c : F.ColimitType → c.pt` is injective, which is an
important step when proving `c.IsColimit`.

-/

universe w₁ w₀ v u

namespace CategoryTheory

open IsFiltered

variable {J : Type u} [Category.{v} J] [IsFiltered J]

namespace Functor

variable (F : J ⥤ Type w₀)

lemma eqvGen_colimitTypeRel_iff_of_isFiltered
    (x y : (j : J) × (F.obj j)) :
    Relation.EqvGen F.ColimitTypeRel x y ↔
      ∃ (k : J) (f : x.1 ⟶ k) (g : y.1 ⟶ k), F.map f x.2 = F.map g y.2 := by
  constructor
  · intro h
    induction h with
    | rel x y h =>
      obtain ⟨f, h⟩ := h
      exact ⟨y.1, f, 𝟙 _, by simpa using h.symm⟩
    | refl x => exact ⟨x.1, 𝟙 _, 𝟙 _, rfl⟩
    | symm _ _ _ h =>
      obtain ⟨k, f, g, h⟩ := h
      exact ⟨k, g, f, h.symm⟩
    | trans x y z _ _ h h' =>
      obtain ⟨k, f, g, h⟩ := h
      obtain ⟨k', f', g', h'⟩ := h'
      obtain ⟨l, a, b, h''⟩ := span g f'
      refine ⟨l, f ≫ a, g' ≫ b, ?_⟩
      rw [FunctorToTypes.map_comp_apply, FunctorToTypes.map_comp_apply _ g', h, ← h',
        ← FunctorToTypes.map_comp_apply, ← FunctorToTypes.map_comp_apply, h'']
  · rintro ⟨k, f, f', h⟩
    apply Relation.EqvGen.trans (y := ⟨k, F.map f' y.2⟩)
    · exact .rel _ _ ⟨f, by rw [← h]⟩
    · exact .symm _ _ (.rel _ _ ⟨f', rfl⟩)

lemma ιColimitType_eq_iff_of_isFiltered {j j' : J} (x : F.obj j) (y : F.obj j') :
    F.ιColimitType j x = F.ιColimitType j' y ↔
      ∃ (k : J) (f : j ⟶ k) (f' : j' ⟶ k), F.map f x = F.map f' y := by
  rw [ιColimitType_eq_iff, eqvGen_colimitTypeRel_iff_of_isFiltered]

/-- More precise variant of the lemma `ιColimitType_eq_iff_of_isFiltered`
in the case both `x` and `y` and in the same type `F.obj j`. -/
lemma ιColimitType_eq_iff_of_isFiltered' {j : J} (x y : F.obj j) :
    F.ιColimitType j x = F.ιColimitType j y ↔
      ∃ (k : J) (f : j ⟶ k), F.map f x = F.map f y := by
  rw [ιColimitType_eq_iff_of_isFiltered]
  constructor
  · rintro ⟨k, f, f', h⟩
    refine ⟨coeq f f', f ≫ coeqHom f f', ?_⟩
    nth_rw 2 [coeq_condition]
    simp [h]
  · rintro ⟨k, f, h⟩
    exact ⟨k, f, f, h⟩

namespace CoconeTypes

variable {F} (c : CoconeTypes.{w₁} F)

lemma descColimitType_injective_iff_of_isFiltered :
    Function.Injective (F.descColimitType c) ↔
      ∀ (j j' : J) (x : F.obj j) (x' : F.obj j'), c.ι j x = c.ι j' x' →
        ∃ (k : J) (f : j ⟶ k) (f' : j' ⟶ k), F.map f x = F.map f' x' := by
  constructor
  · intro h j j' x x' eq
    have : F.ιColimitType j x = F.ιColimitType j' x' := h eq
    rwa [ιColimitType_eq_iff_of_isFiltered] at this
  · intro h x x' eq
    obtain ⟨i, x, rfl⟩ := F.ιColimitType_jointly_surjective x
    obtain ⟨i', x', rfl⟩ := F.ιColimitType_jointly_surjective x'
    simp only [descColimitType_ιColimitType_apply] at eq
    obtain ⟨k, f, f', eq⟩ := h _ _ _ _ eq
    rw [← F.ιColimitType_map f x, eq, F.ιColimitType_map]

/-- Variant of `descColimitType_injective_iff_of_isFiltered` where we
assume both elements `x` and `x'` are in the same type `F.obj j`. -/
lemma descColimitType_injective_iff_of_isFiltered' :
    Function.Injective (F.descColimitType c) ↔
      ∀ (j : J) (x x' : F.obj j), c.ι j x = c.ι j x' →
        ∃ (k : J) (f : j ⟶ k), F.map f x = F.map f x' := by
  rw [descColimitType_injective_iff_of_isFiltered]
  constructor
  · intro h j x x' eq
    obtain ⟨k, f, f', eq⟩ := h _ _ _ _ eq
    refine ⟨coeq f f', f ≫ coeqHom f f', ?_⟩
    rw [FunctorToTypes.map_comp_apply, eq, ← FunctorToTypes.map_comp_apply,
      coeq_condition]
  · intro h j j' x x' eq
    obtain ⟨k, g, eq⟩ := h (max j j') (F.map (leftToMax _ _) x)
      (F.map (rightToMax _ _) x') (by simpa only [c.ι_naturality_apply])
    exact ⟨k, leftToMax _ _ ≫ g, rightToMax _ _ ≫ g,
      by simp only [FunctorToTypes.map_comp_apply, eq]⟩

end CoconeTypes

end Functor

end CategoryTheory
