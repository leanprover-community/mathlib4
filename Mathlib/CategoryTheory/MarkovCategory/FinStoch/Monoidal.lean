/-
Copyright (c) 2025 Jacob Reinhold. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jacob Reinhold
-/
import Mathlib.CategoryTheory.MarkovCategory.FinStoch.Basic
import Mathlib.CategoryTheory.Monoidal.Category
import Mathlib.Data.NNReal.Basic

/-!
# Monoidal Structure on FinStoch

Tensor products model independent parallel processes.

## Main definitions

* `associator` - Isomorphism `(X ‚äó Y) ‚äó Z ‚âÖ X ‚äó (Y ‚äó Z)`
* `leftUnitor` - Isomorphism `I ‚äó X ‚âÖ X`
* `rightUnitor` - Isomorphism `X ‚äó I ‚âÖ X`

## Implementation notes

Structural morphisms use deterministic functions.
Proofs use functional reasoning instead of matrix calculations.

## References

* [Fritz, *A synthetic approach to Markov kernels, conditional independence
  and theorems on sufficient statistics*][fritz2020]

## Tags

Markov category, monoidal category, stochastic matrix
-/

namespace CategoryTheory.MarkovCategory

open FinStoch MonoidalCategory

universe u

open FinStoch



/-! ### Structural isomorphisms using DetMorphism -/

/-- Rearranges `((X ‚äó Y) ‚äó Z)` to `(X ‚äó (Y ‚äó Z))`. -/
def associator (X Y Z : FinStoch) :
    (tensorObj (tensorObj X Y) Z) ‚âÖ (tensorObj X (tensorObj Y Z)) where
  hom := (associatorDet X Y Z).toStochastic
  inv := (associatorInvDet X Y Z).toStochastic
  hom_inv_id := by
    apply StochasticMatrix.ext
    ext ‚ü®‚ü®x, y‚ü©, z‚ü© ‚ü®‚ü®x', y'‚ü©, z'‚ü©
    simp only [CategoryStruct.comp, StochasticMatrix.comp]
    -- Associator is deterministic: ((x,y),z) ‚Üí (x,(y,z)) ‚Üí ((x,y),z)
    -- The only non-zero path is through the intermediate (x,(y,z))
    rw [Finset.sum_eq_single ‚ü®x, ‚ü®y, z‚ü©‚ü©]
    ¬∑ simp only [associatorDet, associatorInvDet, DetMorphism.ofFunc]; cat_disch
    ¬∑ intro b _ hb; simp only [associatorDet, associatorInvDet, DetMorphism.ofFunc]; cat_disch
    ¬∑ intro h; exfalso; exact h (Finset.mem_univ _)
  inv_hom_id := by
    apply StochasticMatrix.ext
    ext ‚ü®x, ‚ü®y, z‚ü©‚ü© ‚ü®x', ‚ü®y', z'‚ü©‚ü©
    simp only [CategoryStruct.comp, StochasticMatrix.comp]
    -- Inverse path: (x,(y,z)) ‚Üí ((x,y),z) ‚Üí (x,(y,z))
    rw [Finset.sum_eq_single ‚ü®‚ü®x, y‚ü©, z‚ü©]
    ¬∑ simp only [associatorInvDet, associatorDet, DetMorphism.ofFunc]; cat_disch
    ¬∑ intro b _ hb; simp only [associatorInvDet, associatorDet, DetMorphism.ofFunc]; cat_disch
    ¬∑ intro h; exfalso; exact h (Finset.mem_univ _)

/-- Removes trivial left factor from `I ‚äó X` to get `X`. -/
def leftUnitor (X : FinStoch) : (tensorObj tensorUnit X) ‚âÖ X where
  hom := (leftUnitorDet X).toStochastic
  inv := (leftUnitorInvDet X).toStochastic
  hom_inv_id := by
    apply StochasticMatrix.ext
    ext ‚ü®‚ü®‚ü©, x‚ü© ‚ü®‚ü®‚ü©, x'‚ü©
    simp only [CategoryStruct.comp, StochasticMatrix.comp]
    -- ((),x) ‚Üí x ‚Üí ((),x) is identity
    rw [Finset.sum_eq_single x]
    ¬∑ simp only [leftUnitorDet, leftUnitorInvDet, DetMorphism.ofFunc]; cat_disch
    ¬∑ intro b _ hb; simp only [leftUnitorDet, leftUnitorInvDet, DetMorphism.ofFunc]; cat_disch
    ¬∑ intro h; exfalso; exact h (Finset.mem_univ _)
  inv_hom_id := by
    apply StochasticMatrix.ext
    ext x x'
    simp only [CategoryStruct.comp, StochasticMatrix.comp]
    -- x ‚Üí ((),x) ‚Üí x is identity
    rw [Finset.sum_eq_single ‚ü®‚ü®‚ü©, x‚ü©]
    ¬∑ simp only [leftUnitorInvDet, leftUnitorDet, DetMorphism.ofFunc]; cat_disch
    ¬∑ intro b _ hb; simp only [leftUnitorInvDet, leftUnitorDet, DetMorphism.ofFunc]; cat_disch
    ¬∑ intro h; exfalso; exact h (Finset.mem_univ _)

/-- Removes trivial right factor from `X ‚äó I` to get `X`. -/
def rightUnitor (X : FinStoch) : (tensorObj X tensorUnit) ‚âÖ X where
  hom := (rightUnitorDet X).toStochastic
  inv := (rightUnitorInvDet X).toStochastic
  hom_inv_id := by
    apply StochasticMatrix.ext
    ext ‚ü®x, ‚ü®‚ü©‚ü© ‚ü®x', ‚ü®‚ü©‚ü©
    simp only [CategoryStruct.comp, StochasticMatrix.comp]
    rw [Finset.sum_eq_single x]
    ¬∑ simp only [rightUnitorDet, rightUnitorInvDet, DetMorphism.ofFunc]; cat_disch
    ¬∑ intro b _ hb; simp only [rightUnitorDet, rightUnitorInvDet, DetMorphism.ofFunc]; cat_disch
    ¬∑ intro h; exfalso; exact h (Finset.mem_univ _)
  inv_hom_id := by
    apply StochasticMatrix.ext
    ext x x'
    simp only [CategoryStruct.comp, StochasticMatrix.comp]
    rw [Finset.sum_eq_single ‚ü®x, ‚ü®‚ü©‚ü©]
    ¬∑ simp only [rightUnitorInvDet, rightUnitorDet, DetMorphism.ofFunc]; cat_disch
    ¬∑ intro b _ hb; simp only [rightUnitorInvDet, rightUnitorDet, DetMorphism.ofFunc]; cat_disch
    ¬∑ intro h; exfalso; exact h (Finset.mem_univ _)

/-- Basic monoidal structure on FinStoch using tensor products. -/
instance : MonoidalCategoryStruct FinStoch where
  tensorObj := tensorObj
  tensorUnit := tensorUnit
  tensorHom f g := StochasticMatrix.tensor f g
  whiskerLeft := fun X {_ _} f => StochasticMatrix.tensor (ùüô X) f
  whiskerRight := fun {_ _} f Y => StochasticMatrix.tensor f (ùüô Y)
  associator := associator
  leftUnitor := leftUnitor
  rightUnitor := rightUnitor

/-! ### Simp lemmas for structural morphisms -/

/-- Matrix entry for associator. -/
@[simp]
lemma associator_matrix (X Y Z : FinStoch) (xyz : ((X ‚äó Y) ‚äó Z).carrier)
    (xyz' : (X ‚äó (Y ‚äó Z)).carrier) :
    (MonoidalCategoryStruct.associator X Y Z).hom.toMatrix xyz xyz' =
    if xyz.1.1 = xyz'.1 ‚àß xyz.1.2 = xyz'.2.1 ‚àß xyz.2 = xyz'.2.2 then 1 else 0 := by
  simp only [MonoidalCategoryStruct.associator, associator, DetMorphism.toMatrix_apply]
  simp only [associatorDet, DetMorphism.ofFunc]
  -- The associator permutation: ((x,y),z) ‚Ü¶ (x,(y,z))
  aesop

/-- Matrix entry for left unitor. -/
@[simp]
lemma leftUnitor_matrix (X : FinStoch) (ux : (FinStoch.tensorUnit ‚äó X).carrier)
    (x : X.carrier) :
    (MonoidalCategoryStruct.leftUnitor X).hom.toMatrix ux x =
    if ux.2 = x then 1 else 0 := by
  simp only [MonoidalCategoryStruct.leftUnitor, leftUnitor, DetMorphism.toMatrix_apply]
  simp only [leftUnitorDet, DetMorphism.ofFunc]
  obtain ‚ü®‚ü®‚ü©, x'‚ü© := ux
  simp only

/-- Matrix entry for right unitor. -/
@[simp]
lemma rightUnitor_matrix (X : FinStoch) (xu : (X ‚äó FinStoch.tensorUnit).carrier)
    (x : X.carrier) :
    (MonoidalCategoryStruct.rightUnitor X).hom.toMatrix xu x =
    if xu.1 = x then 1 else 0 := by
  simp only [MonoidalCategoryStruct.rightUnitor, rightUnitor]
  simp only [rightUnitorDet, DetMorphism.ofFunc]
  obtain ‚ü®x', ‚ü®‚ü©‚ü© := xu
  simp only


/-- FinStoch forms a monoidal category. -/
instance : MonoidalCategory FinStoch where
  tensorHom_def := by
    intros X‚ÇÅ Y‚ÇÅ X‚ÇÇ Y‚ÇÇ f g
    apply StochasticMatrix.ext
    ext ‚ü®x‚ÇÅ, x‚ÇÇ‚ü© ‚ü®y‚ÇÅ, y‚ÇÇ‚ü©
    simp only [MonoidalCategoryStruct.tensorHom, StochasticMatrix.tensor,
               MonoidalCategoryStruct.whiskerRight, MonoidalCategoryStruct.whiskerLeft,
               CategoryStruct.comp, StochasticMatrix.comp]
    -- f ‚äó g = (f ‚äó id) ‚àò (id ‚äó g) = f(x‚ÇÅ,y‚ÇÅ) * g(x‚ÇÇ,y‚ÇÇ)
    rw [Finset.sum_eq_single ‚ü®y‚ÇÅ, x‚ÇÇ‚ü©]
    ¬∑ simp only [StochasticMatrix.id, CategoryStruct.id]
      cat_disch
    ¬∑ simp only [StochasticMatrix.id, CategoryStruct.id]
      cat_disch
    ¬∑ intro h; exfalso; exact h (Finset.mem_univ _)
  id_tensorHom_id := by
    intros X Y
    apply StochasticMatrix.ext
    ext ‚ü®x, y‚ü© ‚ü®x', y'‚ü©
    simp only [MonoidalCategoryStruct.tensorHom, StochasticMatrix.tensor]
    simp only [CategoryStruct.id, StochasticMatrix.id]
    by_cases hx : x = x'
    ¬∑ by_cases hy : y = y'
      ¬∑ simp [hx, hy]
      ¬∑ simp [hx, hy]
        split_ifs with h
        ¬∑ exfalso
          obtain ‚ü®_, h2‚ü© := h
          exact hy rfl
        ¬∑ rfl
    ¬∑ simp [hx]
      split_ifs with h
      ¬∑ exfalso
        obtain ‚ü®h1, _‚ü© := h
        exact hx rfl
      ¬∑ rfl
  tensorHom_comp_tensorHom := by
    intros X‚ÇÅ Y‚ÇÅ Z‚ÇÅ X‚ÇÇ Y‚ÇÇ Z‚ÇÇ f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ
    apply StochasticMatrix.ext
    ext ‚ü®x‚ÇÅ, x‚ÇÇ‚ü© ‚ü®z‚ÇÅ, z‚ÇÇ‚ü©
    simp only [CategoryStruct.comp, StochasticMatrix.comp,
               MonoidalCategoryStruct.tensorHom, StochasticMatrix.tensor]
    rw [Finset.sum_mul_sum]
    simp_rw [‚Üê Finset.sum_product']
    ac_rfl
  whiskerLeft_id := by
    intros X Y
    apply StochasticMatrix.ext
    ext ‚ü®x, y‚ü© ‚ü®x', y'‚ü©
    simp only [MonoidalCategoryStruct.whiskerLeft, StochasticMatrix.tensor]
    simp only [CategoryStruct.id, StochasticMatrix.id]
    by_cases hx : x = x'
    ¬∑ by_cases hy : y = y'
      ¬∑ subst hx hy; simp
      ¬∑ subst hx
        simp [hy]
        by_cases h : (x, y) = (x, y')
        ¬∑ exfalso
          simp only [Prod.mk.injEq] at h
          obtain ‚ü®_, h2‚ü© := h
          exact hy h2
        ¬∑ simp [h]
    ¬∑ simp [hx]
      by_cases h : (x, y) = (x', y')
      ¬∑ exfalso
        simp only [Prod.mk.injEq] at h
        obtain ‚ü®h1, _‚ü© := h
        exact hx h1
      ¬∑ simp [h]
  id_whiskerRight := by
    intros X Y
    apply StochasticMatrix.ext
    ext ‚ü®x, y‚ü© ‚ü®x', y'‚ü©
    simp only [MonoidalCategoryStruct.whiskerRight, StochasticMatrix.tensor]
    simp only [CategoryStruct.id, StochasticMatrix.id]
    by_cases hx : x = x'
    ¬∑ by_cases hy : y = y'
      ¬∑ subst hx hy
        simp
      ¬∑ subst hx
        simp [hy]
        by_cases h : (x, y) = (x, y')
        ¬∑ exfalso
          simp only [Prod.mk.injEq] at h
          obtain ‚ü®_, h2‚ü© := h
          exact hy h2
        ¬∑ simp [h]
    ¬∑ simp [hx]
      by_cases h : (x, y) = (x', y')
      ¬∑ exfalso
        simp only [Prod.mk.injEq] at h
        obtain ‚ü®h1, _‚ü© := h
        exact hx h1
      ¬∑ simp [h]
  associator_naturality := by
    intros X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ f‚ÇÅ f‚ÇÇ f‚ÇÉ
    apply StochasticMatrix.ext
    ext ‚ü®‚ü®x‚ÇÅ, x‚ÇÇ‚ü©, x‚ÇÉ‚ü© ‚ü®y‚ÇÅ, ‚ü®y‚ÇÇ, y‚ÇÉ‚ü©‚ü©
    simp only [CategoryStruct.comp, StochasticMatrix.comp,
               MonoidalCategoryStruct.tensorHom, StochasticMatrix.tensor]
    -- Naturality: Œ± ‚àò (f‚ÇÅ‚äóf‚ÇÇ‚äóf‚ÇÉ) = (f‚ÇÅ‚äó(f‚ÇÇ‚äóf‚ÇÉ)) ‚àò Œ±
    -- Both paths factor through the same intermediate states
    rw [Finset.sum_eq_single ‚ü®‚ü®y‚ÇÅ, y‚ÇÇ‚ü©, y‚ÇÉ‚ü©]
    ¬∑ simp [associator_matrix]
      rw [Finset.sum_eq_single ‚ü®x‚ÇÅ, ‚ü®x‚ÇÇ, x‚ÇÉ‚ü©‚ü©]
      ¬∑ norm_num; ring
      ¬∑ intro ‚ü®x‚ÇÅ', ‚ü®x‚ÇÇ', x‚ÇÉ'‚ü©‚ü© _ h_ne
        by_cases h : x‚ÇÅ' = x‚ÇÅ ‚àß x‚ÇÇ' = x‚ÇÇ ‚àß x‚ÇÉ' = x‚ÇÉ
        ¬∑ exfalso
          apply h_ne
          simp [h]
        ¬∑ aesop
      ¬∑ intro; exfalso; apply ‚Äπ_‚Ä∫; exact Finset.mem_univ _
    ¬∑ intro ‚ü®‚ü®y‚ÇÅ', y‚ÇÇ'‚ü©, y‚ÇÉ'‚ü© _ h_ne
      by_cases h : y‚ÇÅ' = y‚ÇÅ ‚àß y‚ÇÇ' = y‚ÇÇ ‚àß y‚ÇÉ' = y‚ÇÉ
      ¬∑ exfalso
        apply h_ne
        simp only [h]
      ¬∑ -- Associator is deterministic, gives 0 for non-matching indices
        have h_assoc_zero : (MonoidalCategoryStruct.associator Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ).hom.toMatrix
                              ((y‚ÇÅ', y‚ÇÇ'), y‚ÇÉ') (y‚ÇÅ, y‚ÇÇ, y‚ÇÉ) = 0 := by
          simp [associator_matrix, h]
        rw [h_assoc_zero, mul_zero]
    ¬∑ intro; exfalso; apply ‚Äπ_‚Ä∫; exact Finset.mem_univ _
  leftUnitor_naturality := by
    intros X Y f
    apply StochasticMatrix.ext
    ext ‚ü®‚ü®‚ü©, x‚ü© y
    simp only [CategoryStruct.comp, StochasticMatrix.comp]
    rw [Finset.sum_eq_single ‚ü®‚ü®‚ü©, y‚ü©]
    ¬∑ simp [MonoidalCategoryStruct.whiskerLeft, StochasticMatrix.tensor,
            CategoryStruct.id, StochasticMatrix.id]
    ¬∑ intro ‚ü®‚ü®‚ü©, y'‚ü© _ h_ne
      have h_neq : y' ‚â† y := by
        intro h_eq
        apply h_ne
        simp only [h_eq]
      simp only [MonoidalCategoryStruct.whiskerLeft, StochasticMatrix.tensor,
                 CategoryStruct.id, StochasticMatrix.id]
      have h_unitor_zero : (MonoidalCategoryStruct.leftUnitor Y).hom.toMatrix (‚ü®‚ü©, y') y = 0 := by
        simp [leftUnitor_matrix, h_neq]
      simp [h_unitor_zero]
    ¬∑ intro h; exfalso; exact h (Finset.mem_univ _)
  rightUnitor_naturality := by
    intros X Y f
    apply StochasticMatrix.ext
    ext ‚ü®x, ‚ü®‚ü©‚ü© y
    simp only [CategoryStruct.comp, StochasticMatrix.comp]
    rw [Finset.sum_eq_single ‚ü®y, ‚ü®‚ü©‚ü©]
    ¬∑ simp only [MonoidalCategoryStruct.whiskerRight, StochasticMatrix.tensor,
                 CategoryStruct.id, StochasticMatrix.id]
      have h_right_unitor : (MonoidalCategoryStruct.rightUnitor Y).hom.toMatrix (y,‚ü®‚ü©) y = 1 := by
        simp [rightUnitor_matrix]
      simp only [h_right_unitor, mul_one]
      rw [Finset.sum_eq_single x]
      ¬∑ have h_right_unitor :
          (MonoidalCategoryStruct.rightUnitor X).hom.toMatrix (x, ‚ü®‚ü©) x = 1 := by
          simp [rightUnitor_matrix]
        simp [h_right_unitor]
      ¬∑ intro x' _ h_ne
        have h_unitor_zero :
          (MonoidalCategoryStruct.rightUnitor X).hom.toMatrix (x, ‚ü®‚ü©) x' = 0 := by
          simp only [rightUnitor_matrix]
          rw [if_neg h_ne.symm]
        simp [h_unitor_zero]
      ¬∑ intro h; exfalso; exact h (Finset.mem_univ _)
    ¬∑ intro ‚ü®y', ‚ü®‚ü©‚ü© _ h_ne
      have h_neq : y' ‚â† y := by
        intro h_eq
        apply h_ne
        simp only [h_eq]
      simp only [MonoidalCategoryStruct.whiskerRight, StochasticMatrix.tensor,
                 CategoryStruct.id, StochasticMatrix.id]
      have h_unitor_zero : (MonoidalCategoryStruct.rightUnitor Y).hom.toMatrix (y', ‚ü®‚ü©) y = 0 := by
        simp [rightUnitor_matrix, h_neq]
      simp [h_unitor_zero]
    ¬∑ intro h; exfalso; exact h (Finset.mem_univ _)
  pentagon := by
    intros W X Y Z
    apply StochasticMatrix.ext
    ext ‚ü®‚ü®‚ü®w, x‚ü©, y‚ü©, z‚ü© ‚ü®w', ‚ü®x', ‚ü®y', z'‚ü©‚ü©‚ü©
    -- Pentagon coherence: both paths from ((w,x),y,z) to (w,(x,(y,z))) are equal
    simp only [CategoryStruct.comp, StochasticMatrix.comp]
    -- Left path: ((w,x),y,z) ‚Üí (w,(x,y),z) ‚Üí (w,((x,y),z)) ‚Üí (w,(x,(y,z)))
    rw [Finset.sum_eq_single ‚ü®‚ü®w, ‚ü®x, y‚ü©‚ü©, z‚ü©]
    ¬∑ rw [Finset.sum_eq_single ‚ü®w, ‚ü®‚ü®x, y‚ü©, z‚ü©‚ü©]
      ¬∑ -- Right path: ((w,x),y,z) ‚Üí ((w,x),(y,z)) ‚Üí (w,(x,(y,z)))
        rw [Finset.sum_eq_single ‚ü®‚ü®w, x‚ü©, ‚ü®y, z‚ü©‚ü©]
        ¬∑ -- Both paths use deterministic permutations
          simp only [MonoidalCategoryStruct.whiskerRight, MonoidalCategoryStruct.whiskerLeft,
                     StochasticMatrix.tensor, associator_matrix,
                     CategoryStruct.id, StochasticMatrix.id]
          -- All components must match for non-zero contribution
          by_cases hw : w = w'
          ¬∑ by_cases hx : x = x'
            ¬∑ by_cases hy : y = y'
              ¬∑ by_cases hz : z = z'
                ¬∑ subst hw hx hy hz; simp
                ¬∑ simp [hw, hx, hy, hz]
                  subst hw hx hy
                  split
                  ¬∑ grind only
                  ¬∑ rfl
              ¬∑ simp [hw, hx, hy]
                subst hw hx
                split
                ¬∑ grind only
                ¬∑ rfl
            ¬∑ simp [hw, hx]
          ¬∑ simp [hw]
        ¬∑ intro b _ hb
          simp only [associator_matrix, mul_eq_zero]
          left
          split_ifs with h
          ¬∑ exfalso
            obtain ‚ü®h1, h2, h3‚ü© := h
            have : b = ‚ü®‚ü®w, x‚ü©, ‚ü®y, z‚ü©‚ü© := by
              cases b; simp [h1, h2, h3]
            exact hb this
          ¬∑ rfl
        ¬∑ intro h; exfalso; exact h (Finset.mem_univ _)
      ¬∑ intro a _ ha
        simp only [associator_matrix, mul_eq_zero]
        left
        split_ifs with h
        ¬∑ exfalso
          obtain ‚ü®h1, h2, h3‚ü© := h
          have : a = ‚ü®w, ‚ü®‚ü®x, y‚ü©, z‚ü©‚ü© := by
            cases a; simp [h1, h2, h3]
          exact ha this
        ¬∑ rfl
      ¬∑ intro h; exfalso; exact h (Finset.mem_univ _)
    ¬∑ intro b _ hb
      simp only [MonoidalCategoryStruct.whiskerRight, StochasticMatrix.tensor,
                 associator_matrix, CategoryStruct.id, StochasticMatrix.id, mul_eq_zero]
      left
      split_ifs with h
      ¬∑ exfalso
        obtain ‚ü®hw, hx, hy‚ü© := h
        have : b = ‚ü®‚ü®w, ‚ü®x, y‚ü©‚ü©, z‚ü© := by
          cases b; simp_all only [Finset.mem_univ, Prod.mk.eta, ne_eq, not_true_eq_false]
        exact hb this
      ¬∑ right; rfl
      ¬∑ left; rfl
      ¬∑ left; rfl
    ¬∑ intro h; exfalso; exact h (Finset.mem_univ _)
  triangle := by
    intros X Y
    apply StochasticMatrix.ext
    ext ‚ü®‚ü®x, ‚ü®‚ü©‚ü©, y‚ü© ‚ü®x', y'‚ü©
    -- Triangle coherence: associator and unitors interact correctly
    -- Both paths: ((x,()),y) ‚Üí (x,y) via different unit eliminations
    simp only [CategoryStruct.comp, StochasticMatrix.comp]
    -- Unique intermediate state is (x,((),y))
    rw [Finset.sum_eq_single ‚ü®x, ‚ü®‚ü®‚ü©, y‚ü©‚ü©]
    ¬∑ simp only [associator_matrix, MonoidalCategoryStruct.whiskerLeft,
                 MonoidalCategoryStruct.whiskerRight, StochasticMatrix.tensor,
                 leftUnitor_matrix, rightUnitor_matrix, CategoryStruct.id, StochasticMatrix.id]
      by_cases hx : x = x'
      ¬∑ by_cases hy : y = y'
        ¬∑ subst hx hy; simp
        ¬∑ simp [hx, hy]
      ¬∑ simp [hx]
    ¬∑ intro a _ ha
      obtain ‚ü®x‚ÇÅ, ‚ü®‚ü®‚ü©, y‚ÇÅ‚ü©‚ü© := a
      cat_disch
    ¬∑ intro h; exfalso; exact h (Finset.mem_univ _)

end CategoryTheory.MarkovCategory
