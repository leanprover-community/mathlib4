/-
Copyright (c) 2025 Christian Merten. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Christian Merten
-/
import Mathlib.CategoryTheory.Sites.Precoverage

/-!
# 0-hypercovers

Given a coverage `J` on a category `C`, we define the type
of `0`-hypercovers of an object `S : C`. They consists of a covering family
of morphisms `X i ‚ü∂ S` indexed by a type `I‚ÇÄ` such that the induced presieve is in `J`.

We define this with respect to a coverage and not to a Grothendieck topology, because this
yields more control over the components of the cover.
-/

universe w'' w' w v u

namespace CategoryTheory

open Category Limits

variable {C : Type u} [Category.{v} C]

/-- The categorical data that is involved in a `0`-hypercover of an object `S`. This
consists of a family of morphisms `f i : X i ‚ü∂ S` for `i : I‚ÇÄ`. -/
@[ext]
structure PreZeroHypercover (S : C) where
  /-- the index type of the covering of `S` -/
  I‚ÇÄ : Type w
  /-- the objects in the covering of `S` -/
  X (i : I‚ÇÄ) : C
  /-- the morphisms in the covering of `S` -/
  f (i : I‚ÇÄ) : X i ‚ü∂ S

namespace PreZeroHypercover

variable {S T : C} (E : PreZeroHypercover.{w} S) (F : PreZeroHypercover.{w'} S)

/-- The assumption that the pullback of `X i‚ÇÅ` and `X i‚ÇÇ` over `S` exists
for any `i‚ÇÅ` and `i‚ÇÇ`. -/
abbrev HasPullbacks := ‚àÄ (i‚ÇÅ i‚ÇÇ : E.I‚ÇÄ), HasPullback (E.f i‚ÇÅ) (E.f i‚ÇÇ)

/-- The presieve of `S` that is generated by the morphisms `f i : X i ‚ü∂ S`. -/
abbrev presieve‚ÇÄ : Presieve S := .ofArrows _ E.f

@[simp, grind ‚Üê]
lemma presieve‚ÇÄ_f (i : E.I‚ÇÄ) : E.presieve‚ÇÄ (E.f i) := ‚ü®i‚ü©

/-- The sieve of `S` that is generated by the morphisms `f i : X i ‚ü∂ S`. -/
abbrev sieve‚ÇÄ : Sieve S := .ofArrows _ E.f

@[grind ‚Üê]
lemma sieve‚ÇÄ_f (i : E.I‚ÇÄ) : E.sieve‚ÇÄ (E.f i) := ‚ü®_, ùüô _, E.f i, ‚ü®i‚ü©, by simp‚ü©

/-- The pre-`0`-hypercover defined by a single morphism. -/
@[simps]
def singleton (f : S ‚ü∂ T) : PreZeroHypercover.{w} T where
  I‚ÇÄ := PUnit
  X _ := S
  f _ := f

@[simp]
lemma presieve‚ÇÄ_singleton (f : S ‚ü∂ T) : (singleton f).presieve‚ÇÄ = .singleton f := by
  simp [singleton, presieve‚ÇÄ, Presieve.ofArrows_pUnit]

/-- Pullback of a pre-`0`-hypercover along a morphism. The components are `pullback f (E.f i)`. -/
@[simps]
noncomputable
def pullback‚ÇÅ (f : S ‚ü∂ T) (E : PreZeroHypercover.{w} T) [‚àÄ i, HasPullback f (E.f i)] :
    PreZeroHypercover.{w} S where
  I‚ÇÄ := E.I‚ÇÄ
  X i := pullback f (E.f i)
  f _ := pullback.fst _ _

/-- Pullback of a pre-`0`-hypercover along a morphism. The components are `pullback (E.f i) f`. -/
@[simps]
noncomputable
def pullback‚ÇÇ (f : S ‚ü∂ T) (E : PreZeroHypercover.{w} T) [‚àÄ i, HasPullback (E.f i) f] :
    PreZeroHypercover.{w} S where
  I‚ÇÄ := E.I‚ÇÄ
  X i := pullback (E.f i) f
  f _ := pullback.snd _ _

lemma presieve‚ÇÄ_pullback‚ÇÅ (f : S ‚ü∂ T) (E : PreZeroHypercover.{w} T) [‚àÄ i, HasPullback (E.f i) f] :
    presieve‚ÇÄ (E.pullback‚ÇÇ f) = E.presieve‚ÇÄ.pullbackArrows f := by
  refine le_antisymm ?_ ?_
  ¬∑ rintro - - ‚ü®i‚ü©
    use _, _, i
  ¬∑ rintro W g ‚ü®-, -, ‚ü®i‚ü©‚ü©
    use i

lemma sieve‚ÇÄ_pullback‚ÇÅ (f : S ‚ü∂ T) (E : PreZeroHypercover.{w} T) [‚àÄ i, HasPullback f (E.f i)] :
    (E.pullback‚ÇÅ f).sieve‚ÇÄ = E.sieve‚ÇÄ.pullback f := by
  rw [sieve‚ÇÄ, sieve‚ÇÄ]
  refine le_antisymm ?_ ?_
  ¬∑ rw [Sieve.ofArrows, Sieve.generate_le_iff]
    intro Y g ‚ü®i‚ü©
    use E.X i, pullback.snd f (E.f i), E.f i, ‚ü®i‚ü©, pullback.condition.symm
  ¬∑ rintro Z g ‚ü®W, p, q, ‚ü®i‚ü©, hp‚ü©
    use pullback f (E.f i), pullback.lift g p hp.symm, pullback.fst _ _, ‚ü®i‚ü©
    simp

/-- Refining each component of a pre-`0`-hypercover yields a refined pre-`0`-hypercover of the
base. -/
@[simps]
def bind (E : PreZeroHypercover.{w} T) (F : ‚àÄ i, PreZeroHypercover.{w'} (E.X i)) :
    PreZeroHypercover.{max w w'} T where
  I‚ÇÄ := Œ£ (i : E.I‚ÇÄ), (F i).I‚ÇÄ
  X := fun ‚ü®i, j‚ü© ‚Ü¶ (F i).X j
  f := fun ‚ü®i, j‚ü© ‚Ü¶ (F i).f j ‚â´ E.f i

/-- Replace the indexing type of a pre-`0`-hypercover. -/
@[simps]
def reindex (E : PreZeroHypercover.{w} T) {Œπ : Type w'} (e : Œπ ‚âÉ E.I‚ÇÄ) :
    PreZeroHypercover.{w'} T where
  I‚ÇÄ := Œπ
  X := E.X ‚àò e
  f i := E.f (e i)

@[simp]
lemma presieve‚ÇÄ_reindex {Œπ : Type w'} (e : Œπ ‚âÉ E.I‚ÇÄ) : (E.reindex e).presieve‚ÇÄ = E.presieve‚ÇÄ := by
  refine le_antisymm (fun Y g ‚ü®i‚ü© ‚Ü¶ ‚ü®e i‚ü©) fun Y g ‚ü®i‚ü© ‚Ü¶ ?_
  obtain ‚ü®i, rfl‚ü© := e.surjective i
  exact ‚ü®i‚ü©

/-- Pairwise intersection of two pre-`0`-hypercovers. -/
@[simps!]
noncomputable
def inter (E : PreZeroHypercover.{w} T) (F : PreZeroHypercover.{w'} T)
    [‚àÄ i j, HasPullback (E.f i) (F.f j)] :
    PreZeroHypercover.{max w w'} T :=
  (E.bind (fun i ‚Ü¶ F.pullback‚ÇÅ (E.f i))).reindex (Equiv.sigmaEquivProd _ _).symm

lemma inter_def [‚àÄ i j, HasPullback (E.f i) (F.f j)] :
    E.inter F = (E.bind (fun i ‚Ü¶ F.pullback‚ÇÅ (E.f i))).reindex (Equiv.sigmaEquivProd _ _).symm :=
  rfl

@[simps]
def pushforwardIso (E : PreZeroHypercover.{w} T) (e : T ‚âÖ S) : PreZeroHypercover.{w} S where
  I‚ÇÄ := E.I‚ÇÄ
  X := E.X
  f i := E.f i ‚â´ e.hom

/-- Disjoint union of two pre-`0`-hypercovers. -/
@[simps I‚ÇÄ, simps -isSimp X f]
def sum {X : C} (E : PreZeroHypercover.{w} X) (F : PreZeroHypercover.{w'} X) :
    PreZeroHypercover.{max w w'} X where
  I‚ÇÄ := E.I‚ÇÄ ‚äï F.I‚ÇÄ
  X := Sum.elim E.X F.X
  f
    | .inl i => E.f i
    | .inr i => F.f i

@[simp] lemma sum_X_inl (i : E.I‚ÇÄ) : (E.sum F).X (.inl i) = E.X i := rfl

@[simp] lemma sum_X_inr (i : F.I‚ÇÄ) : (E.sum F).X (.inr i) = F.X i := rfl

@[simp] lemma sum_f_inl (i : E.I‚ÇÄ) : (E.sum F).f (.inl i) = E.f i := rfl

@[simp] lemma sum_f_inr (i : F.I‚ÇÄ) : (E.sum F).f (.inr i) = F.f i := rfl

@[simp]
lemma presieve‚ÇÄ_sum : (E.sum F).presieve‚ÇÄ = E.presieve‚ÇÄ ‚äî F.presieve‚ÇÄ := by
  rw [presieve‚ÇÄ, presieve‚ÇÄ, presieve‚ÇÄ]
  apply le_antisymm
  ¬∑ intro Z g ‚ü®i‚ü©
    cases i
    ¬∑ exact Or.inl (.mk _)
    ¬∑ exact Or.inr (.mk _)
  ¬∑ rintro Z g (‚ü®‚ü®i‚ü©‚ü©|‚ü®‚ü®i‚ü©‚ü©)
    ¬∑ exact ‚ü®Sum.inl i‚ü©
    ¬∑ exact ‚ü®Sum.inr i‚ü©

/-- Add a morphism to a pre-`0`-hypercover. -/
@[simps! I‚ÇÄ]
def add (E : PreZeroHypercover.{w} S) {T : C} (f : T ‚ü∂ S) : PreZeroHypercover.{w} S :=
  (E.sum (.singleton f)).reindex (Equiv.optionEquivSumPUnit.{0} E.I‚ÇÄ)

@[simp] lemma add_X_some {T : C} (f : T ‚ü∂ S) (i : E.I‚ÇÄ) : (E.add f).X (some i) = E.X i := rfl

@[simp] lemma add_X_none {T : C} (f : T ‚ü∂ S) : (E.add f).X none = T := rfl

@[simp] lemma add_f_some {T : C} (f : T ‚ü∂ S) (i : E.I‚ÇÄ) : (E.add f).f (some i) = E.f i := rfl

@[simp] lemma add_f_nome {T : C} (f : T ‚ü∂ S) : (E.add f).f none = f := rfl

@[simp] lemma presieve‚ÇÄ_add {T : C} (f : T ‚ü∂ S) :
    (E.add f).presieve‚ÇÄ = E.presieve‚ÇÄ ‚äî .singleton f := by
  simp [add, presieve‚ÇÄ_reindex, presieve‚ÇÄ_sum]
>>>>>>> upstream/master

section Category

variable {E : PreZeroHypercover.{w} S} {F : PreZeroHypercover.{w'} S}

/-- A morphism of pre-`0`-hypercovers of `S` is a family of refinement morphisms commuting
with the structure morphisms of `E` and `F`. -/
@[ext]
structure Hom (E : PreZeroHypercover.{w} S) (F : PreZeroHypercover.{w'} S) where
  /-- The map between indexing types of the coverings of `S` -/
  s‚ÇÄ (i : E.I‚ÇÄ) : F.I‚ÇÄ
  /-- The refinement morphisms between objects in the coverings of `S`. -/
  h‚ÇÄ (i : E.I‚ÇÄ) : E.X i ‚ü∂ F.X (s‚ÇÄ i)
  w‚ÇÄ (i : E.I‚ÇÄ) : h‚ÇÄ i ‚â´ F.f (s‚ÇÄ i) = E.f i := by cat_disch

attribute [reassoc (attr := simp)] Hom.w‚ÇÄ

/-- The identity refinement of a pre-`0`-hypercover. -/
@[simps]
def Hom.id (E : PreZeroHypercover S) : Hom E E where
  s‚ÇÄ := _root_.id
  h‚ÇÄ _ := ùüô _

variable {G : PreZeroHypercover S}

/-- Composition of refinement morphisms of pre-`0`-hypercovers. -/
@[simps]
def Hom.comp (f : E.Hom F) (g : F.Hom G) : E.Hom G where
  s‚ÇÄ := g.s‚ÇÄ ‚àò f.s‚ÇÄ
  h‚ÇÄ i := f.h‚ÇÄ i ‚â´ g.h‚ÇÄ _

@[simps! id_s‚ÇÄ id_h‚ÇÄ comp_s‚ÇÄ comp_h‚ÇÄ]
instance : Category (PreZeroHypercover S) where
  Hom := Hom
  id E := Hom.id E
  comp f g := f.comp g

lemma Hom.ext' {E : PreZeroHypercover.{w} S} {F : PreZeroHypercover.{w'} S}
    {f g : E.Hom F} (hs : f.s‚ÇÄ = g.s‚ÇÄ) (hh : ‚àÄ i, f.h‚ÇÄ i = g.h‚ÇÄ i ‚â´ eqToHom (by rw [hs])) :
    f = g := by
  cases f
  cases g
  simp only at hs
  subst hs
  simp only [eqToHom_refl, Category.comp_id] at hh
  simp only [PreZeroHypercover.Hom.mk.injEq, heq_eq_eq, true_and]
  ext
  apply hh

end Category

@[simps]
noncomputable
def pullback‚ÇÅId (E : PreZeroHypercover S) [‚àÄ (i : E.I‚ÇÄ), HasPullback (ùüô S) (E.f i)] :
    E.pullback‚ÇÅ (ùüô S) ‚âÖ E where
  hom.s‚ÇÄ := id
  hom.h‚ÇÄ i := pullback.snd _ _
  hom.w‚ÇÄ i := by simp [‚Üê pullback.condition]
  inv.s‚ÇÄ := id
  inv.h‚ÇÄ i := pullback.lift (E.f i) (ùüô _)
  hom_inv_id := by
    refine PreZeroHypercover.Hom.ext' rfl fun i ‚Ü¶ ?_
    apply pullback.hom_ext <;> simp [‚Üê pullback.condition]
  inv_hom_id := PreZeroHypercover.Hom.ext' rfl (by simp)

@[simps]
noncomputable
def pullback‚ÇÅComp {S T W : C} (E : PreZeroHypercover.{w} S) (f : W ‚ü∂ T) (g : T ‚ü∂ S)
    [‚àÄ (i : E.I‚ÇÄ), HasPullback (f ‚â´ g) (E.f i)] [‚àÄ (i : E.I‚ÇÄ), HasPullback g (E.f i)]
    [‚àÄ i, HasPullback f (pullback.fst g (E.f i))]
    [‚àÄ (i : (pullback‚ÇÅ g E).I‚ÇÄ), HasPullback f ((pullback‚ÇÅ g E).f i)] :
    E.pullback‚ÇÅ (f ‚â´ g) ‚âÖ (E.pullback‚ÇÅ g).pullback‚ÇÅ f where
  hom.s‚ÇÄ := id
  hom.h‚ÇÄ i := (pullbackRightPullbackFstIso _ _ _).inv
  inv.s‚ÇÄ := id
  inv.h‚ÇÄ i := (pullbackRightPullbackFstIso _ _ _).hom
  hom_inv_id := PreZeroHypercover.Hom.ext' rfl (by simp)
  inv_hom_id := PreZeroHypercover.Hom.ext' rfl (by simp)

variable {F : PreZeroHypercover.{w'} S} {G : PreZeroHypercover.{w''} S}

/-- The left inclusion into the disjoint union. -/
@[simps]
def sumInl : E.Hom (E.sum F) where
  s‚ÇÄ := Sum.inl
  h‚ÇÄ _ := ùüô _

/-- The right inclusion into the disjoint union. -/
@[simps]
def sumInr : F.Hom (E.sum F) where
  s‚ÇÄ := Sum.inr
  h‚ÇÄ _ := ùüô _

/-- To give a refinement of the disjoint union, it suffices to give refinements of both
components. -/
@[simps]
def sumLift (f : E.Hom G) (g : F.Hom G) : (E.sum F).Hom G where
  s‚ÇÄ := Sum.elim f.s‚ÇÄ g.s‚ÇÄ
  h‚ÇÄ
    | .inl i => f.h‚ÇÄ i
    | .inr i => g.h‚ÇÄ i

end PreZeroHypercover

namespace Precoverage

variable {J : Precoverage C}

/-- The type of `0`-hypercovers of an object `S : C` in a category equipped with a
coverage `J`. This can be constructed from a covering of `S`. -/
structure ZeroHypercover (J : Precoverage C) (S : C) extends PreZeroHypercover.{w} S where
  mem‚ÇÄ : toPreZeroHypercover.presieve‚ÇÄ ‚àà J S

namespace ZeroHypercover

variable {S T : C}

/-- The `0`-hypercover defined by a single covering morphism. -/
@[simps toPreZeroHypercover]
def singleton (f : S ‚ü∂ T) (hf : Presieve.singleton f ‚àà J T) :
    J.ZeroHypercover T where
  __ := PreZeroHypercover.singleton f
  mem‚ÇÄ := by
    simpa [PreZeroHypercover.presieve‚ÇÄ, PreZeroHypercover.singleton, Presieve.ofArrows_pUnit]

/-- Pullback of a `0`-hypercover along a morphism. The components are `pullback f (E.f i)`. -/
@[simps toPreZeroHypercover]
noncomputable
def pullback‚ÇÅ [J.IsStableUnderBaseChange] (f : S ‚ü∂ T) (E : ZeroHypercover.{w} J T)
    [‚àÄ i, HasPullback f (E.f i)] : J.ZeroHypercover S where
  __ := E.toPreZeroHypercover.pullback‚ÇÅ f
  mem‚ÇÄ := J.mem_coverings_of_isPullback E.f E.mem‚ÇÄ f _
    (fun _ ‚Ü¶ pullback.snd _ _) fun i ‚Ü¶ IsPullback.of_hasPullback f (E.f i)

/-- Pullback of a `0`-hypercover along a morphism. The components are `pullback (E.f i) f`. -/
@[simps toPreZeroHypercover]
noncomputable
def pullback‚ÇÇ [J.IsStableUnderBaseChange] (f : S ‚ü∂ T) (E : ZeroHypercover.{w} J T)
    [‚àÄ i, HasPullback (E.f i) f] : J.ZeroHypercover S where
  __ := E.toPreZeroHypercover.pullback‚ÇÇ f
  mem‚ÇÄ := J.mem_coverings_of_isPullback E.f E.mem‚ÇÄ f _
    (fun _ ‚Ü¶ pullback.fst _ _) fun i ‚Ü¶ (IsPullback.of_hasPullback (E.f i) f).flip

/-- Refining each component of a `0`-hypercover yields a refined `0`-hypercover of the base. -/
@[simps toPreZeroHypercover]
def bind [J.IsStableUnderComposition] (E : ZeroHypercover.{w} J T)
    (F : ‚àÄ i, ZeroHypercover.{w'} J (E.X i)) :
    ZeroHypercover.{max w w'} J T where
  __ := E.toPreZeroHypercover.bind (fun i ‚Ü¶ (F i).toPreZeroHypercover)
  mem‚ÇÄ :=
    comp_mem_coverings (f := E.f) (g := fun i j ‚Ü¶ (F i).f j) E.mem‚ÇÄ (fun i ‚Ü¶ (F i).mem‚ÇÄ)

/-- Pairwise intersection of two `0`-hypercovers. -/
@[simps toPreZeroHypercover]
noncomputable
def inter [J.IsStableUnderBaseChange] [J.IsStableUnderComposition] (E : ZeroHypercover.{w} J T)
    (F : ZeroHypercover.{w'} J T) [‚àÄ i j, HasPullback (E.f i) (F.f j)] :
    ZeroHypercover.{max w w'} J T where
  __ := E.toPreZeroHypercover.inter F.toPreZeroHypercover
  mem‚ÇÄ := by
    rw [PreZeroHypercover.inter_def, PreZeroHypercover.presieve‚ÇÄ_reindex]
    exact (E.bind (fun i ‚Ü¶ F.pullback‚ÇÅ (E.f i))).mem‚ÇÄ

/-- Replace the indexing type of a `0`-hypercover. -/
@[simps toPreZeroHypercover]
def reindex (E : ZeroHypercover.{w} J T) {Œπ : Type w'} (e : Œπ ‚âÉ E.I‚ÇÄ) :
    ZeroHypercover.{w'} J T where
  __ := E.toPreZeroHypercover.reindex e
  mem‚ÇÄ := by simp [E.mem‚ÇÄ]

/-- Disjoint union of two `0`-hypercovers. -/
@[simps toPreZeroHypercover]
def sum [J.IsStableUnderSup] (E : ZeroHypercover.{w} J S) (F : ZeroHypercover.{w'} J S) :
    ZeroHypercover.{max w w'} J S where
  __ := E.toPreZeroHypercover.sum F.toPreZeroHypercover
  mem‚ÇÄ := by
    rw [PreZeroHypercover.presieve‚ÇÄ_sum]
    exact J.sup_mem_coverings E.mem‚ÇÄ F.mem‚ÇÄ

/-- Add a single morphism to a `0`-hypercover. -/
@[simps toPreZeroHypercover]
def add (E : ZeroHypercover.{w} J S) {T : C} (f : T ‚ü∂ S)
    (hf : E.presieve‚ÇÄ ‚äî Presieve.singleton f ‚àà J S) :
    ZeroHypercover.{w} J S where
  __ := E.toPreZeroHypercover.add f
  mem‚ÇÄ := by rwa [PreZeroHypercover.presieve‚ÇÄ_add]

variable (J) in
/-- A morphism of `0`-hypercovers is a morphism of the underlying pre-`0`-hypercovers. -/
abbrev Hom (E : ZeroHypercover.{w} J S) (F : ZeroHypercover.{w'} J S) :=
  E.toPreZeroHypercover.Hom F.toPreZeroHypercover

@[simps! id_s‚ÇÄ id_h‚ÇÄ comp_s‚ÇÄ comp_h‚ÇÄ]
instance : Category (ZeroHypercover.{w} J S) where
  Hom := Hom J
  id _ := PreZeroHypercover.Hom.id _
  comp := PreZeroHypercover.Hom.comp

end ZeroHypercover

lemma mem_iff_exists_zeroHypercover {X : C} {R : Presieve X} :
    R ‚àà J X ‚Üî ‚àÉ (ùí∞ : ZeroHypercover.{max u v} J X), R = Presieve.ofArrows ùí∞.X ùí∞.f := by
  refine ‚ü®fun hR ‚Ü¶ ?_, fun ‚ü®ùí∞, hR‚ü© ‚Ü¶ hR ‚ñ∏ ùí∞.mem‚ÇÄ‚ü©
  obtain ‚ü®Œπ, Y, f, rfl‚ü© := R.exists_eq_ofArrows
  use ‚ü®‚ü®Œπ, Y, f‚ü©, hR‚ü©

end Precoverage

end CategoryTheory
