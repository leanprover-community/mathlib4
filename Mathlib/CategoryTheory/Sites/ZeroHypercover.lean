/-
Copyright (c) 2025 Christian Merten. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Christian Merten
-/
import Mathlib.CategoryTheory.Sites.Coverage

/-!
# 0-hypercovers

Given a coverage `J` on a category `C`, we define the tyoe
of `0`-hypercovers of an object `S : C`. They consists of a covering family
of morphisms `X i ‚ü∂ S` indexed by a type `I‚ÇÄ` such that the induced presieve is in `J`.

We define this with respect to a coverage and not to a Grothendieck topology, because this
yields more control over the components of the cover.
-/

universe w' w v u

namespace CategoryTheory

open Category Limits

variable {C : Type u} [Category.{v} C]

/-- The categorical data that is involved in a `0`-hypercover of an object `S`. This
consists of a family of morphisms `f i : X i ‚ü∂ S` for `i : I‚ÇÄ`. -/
structure PreZeroHypercover (S : C) where
  /-- the index type of the covering of `S` -/
  I‚ÇÄ : Type w
  /-- the objects in the covering of `S` -/
  X (i : I‚ÇÄ) : C
  /-- the morphisms in the covering of `S` -/
  f (i : I‚ÇÄ) : X i ‚ü∂ S

namespace PreZeroHypercover

variable {S T : C} (E : PreZeroHypercover.{w} S)

/-- The assumption that the pullback of `X i‚ÇÅ` and `X i‚ÇÇ` over `S` exists
for any `i‚ÇÅ` and `i‚ÇÇ`. -/
abbrev HasPullbacks := ‚àÄ (i‚ÇÅ i‚ÇÇ : E.I‚ÇÄ), HasPullback (E.f i‚ÇÅ) (E.f i‚ÇÇ)

/-- The presieve of `S` that is generated by the morphisms `f i : X i ‚ü∂ S`. -/
abbrev presieve‚ÇÄ : Presieve S := .ofArrows _ E.f

/-- The sieve of `S` that is generated by the morphisms `f i : X i ‚ü∂ S`. -/
abbrev sieve‚ÇÄ : Sieve S := .ofArrows _ E.f

/-- The pre-`0`-hypercover defined by a single morphism. -/
@[simps]
def singleton (f : S ‚ü∂ T) : PreZeroHypercover.{w} T where
  I‚ÇÄ := PUnit
  X _ := S
  f _ := f

/-- Pullback of a pre-`0`-hypercover along a morphism. The components are `pullback f (E.f i)`. -/
@[simps]
noncomputable
def pullback‚ÇÅ (f : S ‚ü∂ T) (E : PreZeroHypercover.{w} T) [‚àÄ i, HasPullback f (E.f i)] :
    PreZeroHypercover.{w} S where
  I‚ÇÄ := E.I‚ÇÄ
  X i := pullback f (E.f i)
  f _ := pullback.fst _ _

/-- Pullback of a pre-`0`-hypercover along a morphism. The components are `pullback (E.f i) f`. -/
@[simps]
noncomputable
def pullback‚ÇÇ (f : S ‚ü∂ T) (E : PreZeroHypercover.{w} T) [‚àÄ i, HasPullback (E.f i) f] :
    PreZeroHypercover.{w} S where
  I‚ÇÄ := E.I‚ÇÄ
  X i := pullback (E.f i) f
  f _ := pullback.snd _ _

lemma presieve‚ÇÄ_pullback‚ÇÅ [Limits.HasPullbacks C] (f : S ‚ü∂ T) (E : PreZeroHypercover.{w} T) :
    presieve‚ÇÄ (E.pullback‚ÇÇ f) = E.presieve‚ÇÄ.pullbackArrows f := by
  refine le_antisymm ?_ ?_
  ¬∑ rintro - - ‚ü®i‚ü©
    use _, _, i
  ¬∑ rintro W g ‚ü®-, -, ‚ü®i‚ü©‚ü©
    use i

lemma sieve‚ÇÄ_pullback‚ÇÅ (f : S ‚ü∂ T) (E : PreZeroHypercover.{w} T) [‚àÄ i, HasPullback f (E.f i)] :
    (E.pullback‚ÇÅ f).sieve‚ÇÄ = E.sieve‚ÇÄ.pullback f := by
  rw [sieve‚ÇÄ, sieve‚ÇÄ]
  refine le_antisymm ?_ ?_
  ¬∑ rw [Sieve.ofArrows, Sieve.generate_le_iff]
    intro Y g ‚ü®i‚ü©
    use E.X i, pullback.snd f (E.f i), E.f i, ‚ü®i‚ü©, pullback.condition.symm
  ¬∑ rintro Z g ‚ü®W, p, q, ‚ü®i‚ü©, hp‚ü©
    use pullback f (E.f i), pullback.lift g p hp.symm, pullback.fst _ _, ‚ü®i‚ü©
    simp

/-- Refining each component of a pre-`0`-hypercover yields a refined pre-`0`-hypercover of the
base. -/
@[simps]
def bind (E : PreZeroHypercover.{w} T) (F : ‚àÄ i, PreZeroHypercover.{w'} (E.X i)) :
    PreZeroHypercover.{max w w'} T where
  I‚ÇÄ := Œ£ (i : E.I‚ÇÄ), (F i).I‚ÇÄ
  X := fun ‚ü®i, j‚ü© ‚Ü¶ (F i).X j
  f := fun ‚ü®i, j‚ü© ‚Ü¶ (F i).f j ‚â´ E.f i

section Category

variable {E : PreZeroHypercover.{w} S} {F : PreZeroHypercover.{w'} S}

/-- A morphism of pre-`0`-hypercovers of `S` is a family of refinement morphisms commuting
with the structure morphisms of `E` and `F`. -/
@[ext]
structure Hom (E : PreZeroHypercover.{w} S) (F : PreZeroHypercover.{w'} S) where
  /-- The map between indexing types of the coverings of `S` -/
  s‚ÇÄ (i : E.I‚ÇÄ) : F.I‚ÇÄ
  /-- The refinement morphisms between objects in the coverings of `S`. -/
  h‚ÇÄ (i : E.I‚ÇÄ) : E.X i ‚ü∂ F.X (s‚ÇÄ i)
  w‚ÇÄ (i : E.I‚ÇÄ) : h‚ÇÄ i ‚â´ F.f (s‚ÇÄ i) = E.f i := by aesop_cat

attribute [reassoc (attr := simp)] Hom.w‚ÇÄ

/-- The identity refinement of a pre-`0`-hypercover. -/
@[simps]
def Hom.id (E : PreZeroHypercover S) : Hom E E where
  s‚ÇÄ := _root_.id
  h‚ÇÄ _ := ùüô _

variable {G : PreZeroHypercover S}

/-- Composition of refinement morphisms of pre-`0`-hypercovers. -/
@[simps]
def Hom.comp (f : E.Hom F) (g : F.Hom G) : E.Hom G where
  s‚ÇÄ := g.s‚ÇÄ ‚àò f.s‚ÇÄ
  h‚ÇÄ i := f.h‚ÇÄ i ‚â´ g.h‚ÇÄ _

@[simps! id_s‚ÇÄ id_h‚ÇÄ comp_s‚ÇÄ comp_h‚ÇÄ]
instance : Category (PreZeroHypercover S) where
  Hom := Hom
  id E := Hom.id E
  comp f g := f.comp g

lemma Hom.ext' {E : PreZeroHypercover.{w} S} {F : PreZeroHypercover.{w'} S}
    {f g : E.Hom F} (hs : f.s‚ÇÄ = g.s‚ÇÄ) (hh : ‚àÄ i, f.h‚ÇÄ i = g.h‚ÇÄ i ‚â´ eqToHom (by rw [hs])) :
    f = g := by
  cases f
  cases g
  simp only at hs
  subst hs
  simp only [eqToHom_refl, Category.comp_id] at hh
  simp only [PreZeroHypercover.Hom.mk.injEq, heq_eq_eq, true_and]
  ext
  apply hh

end Category

@[simps]
noncomputable
def pullback‚ÇÅId (E : PreZeroHypercover S) [‚àÄ (i : E.I‚ÇÄ), HasPullback (ùüô S) (E.f i)] :
    E.pullback‚ÇÅ (ùüô S) ‚âÖ E where
  hom.s‚ÇÄ := id
  hom.h‚ÇÄ i := pullback.snd _ _
  hom.w‚ÇÄ i := by simp [‚Üê pullback.condition]
  inv.s‚ÇÄ := id
  inv.h‚ÇÄ i := pullback.lift (E.f i) (ùüô _)
  hom_inv_id := by
    refine PreZeroHypercover.Hom.ext' rfl fun i ‚Ü¶ ?_
    apply pullback.hom_ext <;> simp [‚Üê pullback.condition]
  inv_hom_id := PreZeroHypercover.Hom.ext' rfl (by simp)

@[simps]
noncomputable
def pullback‚ÇÅComp {S T W : C} (E : PreZeroHypercover.{w} S) (f : W ‚ü∂ T) (g : T ‚ü∂ S)
    [‚àÄ (i : E.I‚ÇÄ), HasPullback (f ‚â´ g) (E.f i)] [‚àÄ (i : E.I‚ÇÄ), HasPullback g (E.f i)]
    [‚àÄ i, HasPullback f (pullback.fst g (E.f i))]
    [‚àÄ (i : (pullback‚ÇÅ g E).I‚ÇÄ), HasPullback f ((pullback‚ÇÅ g E).f i)] :
    E.pullback‚ÇÅ (f ‚â´ g) ‚âÖ (E.pullback‚ÇÅ g).pullback‚ÇÅ f where
  hom.s‚ÇÄ := id
  hom.h‚ÇÄ i := (pullbackRightPullbackFstIso _ _ _).inv
  inv.s‚ÇÄ := id
  inv.h‚ÇÄ i := (pullbackRightPullbackFstIso _ _ _).hom
  hom_inv_id := PreZeroHypercover.Hom.ext' rfl (by simp)
  inv_hom_id := PreZeroHypercover.Hom.ext' rfl (by simp)

end PreZeroHypercover

namespace Coverage

variable (J : Coverage C)

/-- The type of `0`-hypercovers of an object `S : C` in a category equipped with a
coverage `J`. This can be constructed from a covering of `S`. -/
structure ZeroHypercover (S : C) extends PreZeroHypercover.{w} S where
  mem‚ÇÄ : toPreZeroHypercover.presieve‚ÇÄ ‚àà J S

namespace ZeroHypercover

variable {S T : C}

/-- The `0`-hypercover defined by a single covering morphism. -/
@[simps toPreZeroHypercover]
def singleton (f : S ‚ü∂ T) (hf : Presieve.singleton f ‚àà J T) :
    J.ZeroHypercover T where
  __ := PreZeroHypercover.singleton f
  mem‚ÇÄ := by
    simpa [PreZeroHypercover.presieve‚ÇÄ, PreZeroHypercover.singleton, Presieve.ofArrows_pUnit]

/-- Pullback of a `0`-hypercover along a morphism. The components are `pullback f (E.f i)`. -/
@[simps toPreZeroHypercover]
noncomputable
def pullback‚ÇÅ [J.IsStableUnderBaseChange] [Limits.HasPullbacks C] (f : S ‚ü∂ T)
    (E : ZeroHypercover.{w} J T) :
    J.ZeroHypercover S where
  __ := E.toPreZeroHypercover.pullback‚ÇÅ f
  mem‚ÇÄ := J.mem_covering_of_isPullback E.f E.mem‚ÇÄ f _
    (fun _ ‚Ü¶ pullback.snd _ _) fun i ‚Ü¶ IsPullback.of_hasPullback f (E.f i)

/-- Pullback of a `0`-hypercover along a morphism. The components are `pullback (E.f i) f`. -/
@[simps toPreZeroHypercover]
noncomputable
def pullback‚ÇÇ [J.IsStableUnderBaseChange] [Limits.HasPullbacks C] (f : S ‚ü∂ T)
    (E : ZeroHypercover.{w} J T) :
    J.ZeroHypercover S where
  __ := E.toPreZeroHypercover.pullback‚ÇÇ f
  mem‚ÇÄ := J.mem_covering_of_isPullback E.f E.mem‚ÇÄ f _
    (fun _ ‚Ü¶ pullback.fst _ _) fun i ‚Ü¶ (IsPullback.of_hasPullback (E.f i) f).flip

/-- Refining each component of a `0`-hypercover yields a refined `0`-hypercover of the base. -/
def bind [J.IsStableUnderComposition] (E : ZeroHypercover.{w} J T)
    (F : ‚àÄ i, ZeroHypercover.{w'} J (E.X i)) :
    ZeroHypercover.{max w w'} J T where
  __ := E.toPreZeroHypercover.bind (fun i ‚Ü¶ (F i).toPreZeroHypercover)
  mem‚ÇÄ :=
    mem_covering_comp (f := E.f) (g := fun i j ‚Ü¶ (F i).f j) E.mem‚ÇÄ (fun i ‚Ü¶ (F i).mem‚ÇÄ)

/-- A morphism of `0`-hypercovers is a morphism of the underlying pre-`0`-hypercovers. -/
abbrev Hom (E : ZeroHypercover.{w} J S) (F : ZeroHypercover.{w'} J S) :=
  E.toPreZeroHypercover.Hom F.toPreZeroHypercover

@[simps! id_s‚ÇÄ id_h‚ÇÄ comp_s‚ÇÄ comp_h‚ÇÄ]
instance : Category (ZeroHypercover.{w} J S) where
  Hom := Hom J
  id _ := PreZeroHypercover.Hom.id _
  comp := PreZeroHypercover.Hom.comp

end ZeroHypercover

end Coverage

end CategoryTheory
