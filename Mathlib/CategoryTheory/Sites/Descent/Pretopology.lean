/-
Copyright (c) 2025 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
module

public import Mathlib.CategoryTheory.Sites.Descent.IsStack

/-!
# Characterization of (pre)stacks for a pretopology

Let `F : LocallyDiscrete C·µí·µñ ‚•§·µñ Cat` be a pseudofunctor.
Assuming `F` is a prestack for a Grothendieck topology `J`,
we show that if `f : X i ‚ü∂ S` and `f' : X' j ‚ü∂ S` are two covering
families of morphisms in `S` such that the sieve generated by `f'` is
contained in the sieve generated by `f`, then the functor
`F.DescentData f ‚•§ F.DescentData f'` is fully faithful.
It follows that if the descent is effective for the family `f'`,
then it is also effective for the family `f`.

Now, assume that `J` is a pretopology on `C`. We deduce from the
results above that `F` is a prestack (resp. a stack) for the
Grothendieck topology associated to `J` if the functors
`F.toDescentData f` attached to presieves in `J` are
fully faithful (resp. equivalences).

-/

@[expose] public section

universe t t' v' v u' u

namespace CategoryTheory

open Limits Opposite Bicategory

namespace Pseudofunctor

open DescentData LocallyDiscreteOpToCat

variable {C : Type u} [Category.{v} C] (F : LocallyDiscrete C·µí·µñ ‚•§·µñ Cat.{v', u'})

section

variable {J : GrothendieckTopology C} [F.IsPrestack J]

variable {Œπ : Type t} {S : C} {X : Œπ ‚Üí C} {f : ‚àÄ i, X i ‚ü∂ S}
  {Œπ' : Type t'} {X' : Œπ' ‚Üí C} {f' : ‚àÄ j, X' j ‚ü∂ S}
  {Œ± : Œπ' ‚Üí Œπ} {p' : ‚àÄ j, X' j ‚ü∂ X (Œ± j)} (w : ‚àÄ j, p' j ‚â´ f (Œ± j) = f' j)
  (hf' : Sieve.ofArrows _ f' ‚àà J S)

include hf' in
lemma faithful_pullFunctor :
    (pullFunctor F (f := f) (p := ùüô _) (f' := f') (p' := p') (by cat_disch)).Faithful where
  map_injective {D‚ÇÅ D‚ÇÇ œÜ œÜ'} hœÜ := by
    ext i
    refine F.presheafHomObjHomEquiv.injective ?_i
    have : (Sieve.overEquiv (Over.mk (ùüô (X i)))).symm
      (Sieve.pullback (f i) (Sieve.ofArrows X' f')) ‚àà J.over (X i) _ := by
      simpa only [J.mem_over_iff, Equiv.apply_symm_apply] using J.pullback_stable (f i) hf'
    refine (((isSheaf_iff_isSheaf_of_type _ _).1
      (IsPrestack.isSheaf _ _ _)).isSeparated _ this).ext ?_
    rintro Z g ‚ü®Y, p, c, ‚ü®j‚ü©, hp‚ü©
    dsimp at p hp
    have : g.left = Z.hom := by simpa using Over.w g
    have (œà : D‚ÇÅ ‚ü∂ D‚ÇÇ) :
      (F.presheafHom _ _).map g.op (F.presheafHomObjHomEquiv (œà.hom i)) =
        D‚ÇÅ.hom (Z.hom ‚â´ f i) Z.hom (p ‚â´ p' j) ‚â´
          pullHom ((F.map (p' j).op.toLoc).toFunctor.map (œà.hom (Œ± j))) p _ _ ‚â´
          D‚ÇÇ.hom (Z.hom ‚â´ f i) (p ‚â´ p' j) Z.hom := by
      dsimp [presheafHomObjHomEquiv]
      sorry
    replace hœÜ := congr_fun (congr_arg DescentData.Hom.hom hœÜ) j
    dsimp at hœÜ
    simp only [this, hœÜ]

namespace full_pullFunctor

variable {F} {D‚ÇÅ D‚ÇÇ : F.DescentData f}
  (œÜ : (pullFunctor F (p := ùüô _) (f' := f') (p' := p') (by cat_disch)).obj D‚ÇÅ ‚ü∂
    (pullFunctor F (p := ùüô _) (f' := f') (p' := p') (by cat_disch)).obj D‚ÇÇ)

variable (f f') in
abbrev sieve (i : Œπ) : Sieve (Over.mk (ùüô (X i))) :=
  (Sieve.overEquiv (Over.mk (ùüô (X i)))).symm
    (Sieve.pullback (f i) (Sieve.ofArrows X' f'))

include hf' in
variable (f) in
lemma sieve_mem (i : Œπ) : sieve f f' i ‚àà J.over _ _ := by
  simpa only [J.mem_over_iff, Equiv.apply_symm_apply] using J.pullback_stable (f i) hf'

lemma mem_sieve {i : Œπ} {Z : C} (q : Z ‚ü∂ X i) ‚¶Éj : Œπ'‚¶Ñ (a : Z ‚ü∂ X' j)
    (fac : a ‚â´ f' j = q ‚â´ f i) :
    sieve f f' i (Over.homMk q : Over.mk q ‚ü∂ Over.mk (ùüô (X i))) :=
  ‚ü®_, a, f' j, ‚ü®j‚ü©, fac‚ü©

namespace sieve

variable {i : Œπ} {Z : C} {q : Z ‚ü∂ X i}
  (hq : sieve f f' i (Over.homMk q : Over.mk q ‚ü∂ Over.mk (ùüô X i)))

include hq in
lemma exists_fac : ‚àÉ (j : Œπ') (a : Z ‚ü∂ X' j), a ‚â´ f' j = q ‚â´ f i := by
  obtain ‚ü®_, q, _, ‚ü®j‚ü©, fac‚ü© := hq
  exact ‚ü®j, q, fac‚ü©

noncomputable def idx : Œπ' := (exists_fac hq).choose

noncomputable def a : Z ‚ü∂ X' (idx hq) := (exists_fac hq).choose_spec.choose

lemma fac : (a hq) ‚â´ f' (idx hq) = q ‚â´ f i := (exists_fac hq).choose_spec.choose_spec

end sieve

def mor ‚¶Éi : Œπ‚¶Ñ {Z : C} (q : Z ‚ü∂ X i) ‚¶Éj : Œπ'‚¶Ñ (a : Z ‚ü∂ X' j)
    (fac : a ‚â´ f' j = q ‚â´ f i) :
    (presheafHom F (D‚ÇÅ.obj i) (D‚ÇÇ.obj i)).obj (op (Over.mk q)) :=
  D‚ÇÅ.hom (q ‚â´ f i) q (a ‚â´ p' j) ‚â´ pullHom (œÜ.hom j) a _ _ ‚â´ D‚ÇÇ.hom (q ‚â´ f i) (a ‚â´ p' j) q

lemma mor_eq ‚¶Éi : Œπ‚¶Ñ {Z : C} (q : Z ‚ü∂ X i) ‚¶Éj : Œπ'‚¶Ñ (a : Z ‚ü∂ X' j)
    (fac : a ‚â´ f' j = q ‚â´ f i) (q' : Z ‚ü∂ S) (hq' : q ‚â´ f i = q')
    (a' : Z ‚ü∂ X (Œ± j)) (ha' : a ‚â´ p' j = a') :
    mor w œÜ q a fac =
      D‚ÇÅ.hom q' q a' ‚â´ pullHom (œÜ.hom j) a _ _ ‚â´ D‚ÇÇ.hom q' a' q := by
  subst hq' ha'
  rfl

include w œÜ in
lemma mor_precomp ‚¶Éi : Œπ‚¶Ñ {Z : C} (q : Z ‚ü∂ X i) ‚¶Éj : Œπ'‚¶Ñ (a : Z ‚ü∂ X' j)
    (fac : a ‚â´ f' j = q ‚â´ f i) {Z' : C} (r : Z' ‚ü∂ Z)
    (r' : Z' ‚ü∂ X i) (hr' : r ‚â´ q = r')
    (a' : Z' ‚ü∂ X' j) (ha' : r ‚â´ a = a') :
    mor w œÜ r' a' (by cat_disch) =
      (presheafHom F (D‚ÇÅ.obj i) (D‚ÇÇ.obj i)).map (Over.homMk r).op (mor w œÜ q a fac) := by
  sorry

lemma mor_unique ‚¶Éi : Œπ‚¶Ñ {Z : C} (q : Z ‚ü∂ X i)
    ‚¶Éj‚ÇÅ : Œπ'‚¶Ñ (a‚ÇÅ : Z ‚ü∂ X' j‚ÇÅ) (fac‚ÇÅ : a‚ÇÅ ‚â´ f' j‚ÇÅ = q ‚â´ f i)
    ‚¶Éj‚ÇÇ : Œπ'‚¶Ñ (a‚ÇÇ : Z ‚ü∂ X' j‚ÇÇ) (fac‚ÇÇ : a‚ÇÇ ‚â´ f' j‚ÇÇ = q ‚â´ f i) :
    mor w œÜ q a‚ÇÅ fac‚ÇÅ = mor w œÜ q a‚ÇÇ fac‚ÇÇ := by
  sorry

noncomputable def familyOfElements (i : Œπ) :
    Presieve.FamilyOfElements (presheafHom F (D‚ÇÅ.obj i) (D‚ÇÇ.obj i)) (sieve f f' i).arrows :=
  fun Z q hq ‚Ü¶
    mor w œÜ _ _ (sieve.fac (f := f) (f' := f') (q := Z.hom) (by
      convert hq
      ext
      simpa using (Over.w q).symm))

lemma familyOfElements_eq {i : Œπ} {Z : Over (X i)} (g : Z ‚ü∂ Over.mk (ùüô (X i)))
    ‚¶Éj : Œπ'‚¶Ñ (a : Z.left ‚ü∂ X' j) (fac : a ‚â´ f' j = Z.hom ‚â´ f i) :
    familyOfElements w œÜ i g (by
      rw [show g = Over.homMk Z.hom by ext; simpa using Over.w g]
      exact mem_sieve _ _ fac) = mor w œÜ _ _ fac :=
  mor_unique _ _ _ _ _ _ _

lemma _root_.CategoryTheory.Over.homMk_surjective {S : C} {X Y : Over S} (f : X ‚ü∂ Y) :
    ‚àÉ (g : X.left ‚ü∂ Y.left) (hg : g ‚â´ Y.hom = X.hom), f = Over.homMk g :=
  ‚ü®f.left, by simp‚ü©

lemma compatible_familyOfElements (i : Œπ) :
    (familyOfElements w œÜ i).Compatible := by
  intro Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ fac
  obtain rfl : f‚ÇÅ = Over.homMk Y‚ÇÅ.hom := by ext; simpa using Over.w f‚ÇÅ
  obtain rfl : f‚ÇÇ = Over.homMk Y‚ÇÇ.hom := by ext; simpa using Over.w f‚ÇÇ
  obtain ‚ü®g‚ÇÅ, hg‚ÇÅ, rfl‚ü© := Over.homMk_surjective g‚ÇÅ
  obtain ‚ü®g‚ÇÇ, hg‚ÇÇ, rfl‚ü© := Over.homMk_surjective g‚ÇÇ
  obtain ‚ü®_, a‚ÇÅ, _, ‚ü®j‚ÇÅ‚ü©, fac‚ÇÅ‚ü© := h‚ÇÅ
  obtain ‚ü®_, a‚ÇÇ, _, ‚ü®j‚ÇÇ‚ü©, fac‚ÇÇ‚ü© := h‚ÇÇ
  dsimp at a‚ÇÅ a‚ÇÇ fac‚ÇÅ fac‚ÇÇ
  rw [familyOfElements_eq _ _ _ _ fac‚ÇÅ, familyOfElements_eq _ _ _ _ fac‚ÇÇ,
    ‚Üê mor_precomp w œÜ Y‚ÇÅ.hom a‚ÇÅ fac‚ÇÅ _ _ hg‚ÇÅ _ rfl,
    ‚Üê mor_precomp w œÜ Y‚ÇÇ.hom a‚ÇÇ fac‚ÇÇ _ _ hg‚ÇÇ _ rfl]
  apply mor_unique

include hf' in
noncomputable def hom (i : Œπ) : D‚ÇÅ.obj i ‚ü∂ D‚ÇÇ.obj i :=
  F.presheafHomObjHomEquiv.symm
    (Presieve.IsSheafFor.amalgamate (Presieve.IsSheaf.isSheafFor _
    ((isSheaf_iff_isSheaf_of_type _ _).1 (IsPrestack.isSheaf J _ _)) _
      (by simpa using sieve_mem _ hf' i)) _
        (compatible_familyOfElements w œÜ i))

lemma map_hom ‚¶Éi : Œπ‚¶Ñ ‚¶ÉY : C‚¶Ñ (q : Y ‚ü∂ X i) ‚¶Éj : Œπ'‚¶Ñ
    (a : Y ‚ü∂ X' j) (fac : a ‚â´ f' j = q ‚â´ f i) :
    (F.map q.op.toLoc).toFunctor.map (hom w hf' œÜ i) = mor w œÜ q a fac := by
  let s := Presieve.IsSheafFor.amalgamate (Presieve.IsSheaf.isSheafFor _
    ((isSheaf_iff_isSheaf_of_type _ _).1 (IsPrestack.isSheaf J _ _)) _
      (by simpa using sieve_mem _ hf' i)) _
        (compatible_familyOfElements w œÜ i)
  have hs : (familyOfElements w œÜ i).IsAmalgamation s :=
    Presieve.IsSheafFor.isAmalgamation (Presieve.IsSheaf.isSheafFor _
      ((isSheaf_iff_isSheaf_of_type _ _).1 (IsPrestack.isSheaf J _ _)) _
        (by simpa using sieve_mem _ hf' i)) (compatible_familyOfElements w œÜ i)
  change (F.map q.op.toLoc).toFunctor.map (F.presheafHomObjHomEquiv.symm s) = _
  simpa [familyOfElements_eq w œÜ (Z := Over.mk q) _ a fac,
    presheafHomObjHomEquiv, pullHom, mapComp'_id_comp_hom_app,
    mapComp'_id_comp_inv_app] using hs _ (mem_sieve _ _ fac)

@[reassoc]
lemma comm ‚¶ÉY : C‚¶Ñ (q : Y ‚ü∂ S) ‚¶Éi‚ÇÅ i‚ÇÇ : Œπ‚¶Ñ
    (f‚ÇÅ : Y ‚ü∂ X i‚ÇÅ) (f‚ÇÇ : Y ‚ü∂ X i‚ÇÇ) (hf‚ÇÅ : f‚ÇÅ ‚â´ f i‚ÇÅ = q) (hf‚ÇÇ : f‚ÇÇ ‚â´ f i‚ÇÇ = q) :
    (F.map f‚ÇÅ.op.toLoc).toFunctor.map (hom w hf' œÜ i‚ÇÅ) ‚â´ D‚ÇÇ.hom q f‚ÇÅ f‚ÇÇ =
    D‚ÇÅ.hom q f‚ÇÅ f‚ÇÇ ‚â´ (F.map f‚ÇÇ.op.toLoc).toFunctor.map (hom w hf' œÜ i‚ÇÇ) := by
  rw [‚Üê cancel_mono (D‚ÇÇ.hom q f‚ÇÇ f‚ÇÅ), Category.assoc,
    Category.assoc, DescentData.hom_comp, D‚ÇÇ.hom_self _ _ hf‚ÇÅ, Category.comp_id]
  sorry

end full_pullFunctor

open full_pullFunctor in
include w hf' in
lemma full_pullFunctor :
    (pullFunctor F (f := f) (p := ùüô _) (f' := f') (p' := p') (by cat_disch)).Full where
  map_surjective {D‚ÇÅ D‚ÇÇ} œÜ :=
    ‚ü®{ hom := fun i ‚Ü¶ hom w hf' œÜ i, comm := comm _ _ _ }, by
      ext i
      dsimp
      rw [map_hom _ _ _ _ (ùüô _) (by cat_disch),
        mor_eq _ _ _ _ _ (f' i) (by cat_disch) (p' i) (by simp), pullHom_id,
        D‚ÇÅ.hom_self _ _ (by cat_disch), D‚ÇÇ.hom_self _ _ (by cat_disch),
        Category.id_comp, Category.comp_id]‚ü©

noncomputable def fullyFaithfulPullFunctor :
    (pullFunctor F (f := f) (p := ùüô _) (f' := f') (p' := p') (by cat_disch)).FullyFaithful := by
  have := F.faithful_pullFunctor w hf'
  have := F.full_pullFunctor w hf'
  exact .ofFullyFaithful _

lemma isEquivalence_toDescentData_of_sieve_le
    (h‚ÇÅ : Sieve.ofArrows _ f' ‚àà J _)
    (h‚ÇÇ : Sieve.ofArrows _ f' ‚â§ Sieve.ofArrows _ f)
    [(F.toDescentData f').IsEquivalence] :
    (F.toDescentData f).IsEquivalence := by
  let H (i' : Œπ') : ‚àÉ (i : Œπ) (p : X' i' ‚ü∂ X i), p ‚â´ f i = f' i' := by
    obtain ‚ü®_, p, _, ‚ü®i‚ü©, fac‚ü© := h‚ÇÇ _ (Sieve.ofArrows_mk _ f' i')
    exact ‚ü®_, _, fac‚ü©
  choose Œ± p hp using H
  obtain ‚ü®H, h, ‚ü®e‚ü©‚ü© :
      ‚àÉ (H : _ ‚•§ _) (_ : H.FullyFaithful),
        Nonempty (F.toDescentData f ‚ãô H ‚âÖ F.toDescentData f') := by
    refine ‚ü®pullFunctor F (p := ùüô _) (p' := p) (by cat_disch), ?_, ?_‚ü©
    ¬∑ refine F.fullyFaithfulPullFunctor hp h‚ÇÅ
    ¬∑ exact ‚ü®toDescentDataCompPullFunctorIso _ _ ‚â™‚â´
          (Functor.isoWhiskerRight (Cat.Hom.toNatIso (F.mapId _)) _) ‚â™‚â´
            Functor.leftUnitor _‚ü©
  have := (F.fullyFaithfulToDescentData _ (J.superset_covering h‚ÇÇ h‚ÇÅ)).faithful
  have := (F.fullyFaithfulToDescentData _ (J.superset_covering h‚ÇÇ h‚ÇÅ)).full
  have : (F.toDescentData f).EssSurj := ‚ü®fun D ‚Ü¶
    ‚ü®_, ‚ü®h.preimageIso (e.app _ ‚â™‚â´ (F.toDescentData f').objObjPreimageIso (H.obj D))‚ü©‚ü©‚ü©
  exact { }

end

section

variable {F} [HasPullbacks C] {J : Pretopology C}

lemma IsPrestack.of_pretopology
    (hF : ‚àÄ (S : C) (R : Presieve S) (hR : R ‚àà J S),
      (F.toDescentData (fun (f : R.category) ‚Ü¶ f.obj.hom)).FullyFaithful) :
    F.IsPrestack J.toGrothendieck := by
  sorry

lemma IsStack.of_pretopology
    (hF : ‚àÄ (S : C) (R : Presieve S) (_ : R ‚àà J S),
      (F.toDescentData (fun (f : R.category) ‚Ü¶ f.obj.hom)).IsEquivalence) :
    F.IsStack J.toGrothendieck := by
  have : F.IsPrestack J.toGrothendieck := .of_pretopology (fun S R hR ‚Ü¶ by
    have := hF S R hR
    exact .ofFullyFaithful _)
  constructor
  rintro S R ‚ü®R', hR', h‚ü©
  have := hF S R' hR'
  have h‚ÇÅ : Sieve.ofArrows _ (fun (f : R'.category) ‚Ü¶ f.obj.hom) ‚àà J.toGrothendieck _ :=
    ‚ü®_, hR', fun _ g hg ‚Ü¶ ‚ü®_, ùüô _, g, .mk (Œπ := R'.category) ‚ü®Over.mk g, hg‚ü©, by simp‚ü©‚ü©
  have h‚ÇÇ : Sieve.ofArrows _ (fun (f : R'.category) ‚Ü¶ f.obj.hom) ‚â§
    Sieve.ofArrows _ (fun (f : R.arrows.category) ‚Ü¶ f.obj.hom) := by
      rw [Sieve.generate_le_iff]
      rintro _ _ ‚ü®r, hr‚ü©
      exact ‚ü®_, ùüô _, r.hom, .mk (Œπ := R.arrows.category) ‚ü®_, h _ hr‚ü©, by simp‚ü©
  have := F.isEquivalence_toDescentData_of_sieve_le h‚ÇÅ h‚ÇÇ
  infer_instance

end

end Pseudofunctor

end CategoryTheory
