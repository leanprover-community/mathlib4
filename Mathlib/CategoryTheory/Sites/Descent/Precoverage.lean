/-
Copyright (c) 2025 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
module

public import Mathlib.CategoryTheory.Sites.Descent.IsStack

/-!
# Characterization of (pre)stacks for a precoverage

Let `F : LocallyDiscrete C·µí·µñ ‚•§·µñ Cat` be a pseudofunctor.
Assuming `F` is a prestack for a Grothendieck topology `J`,
we show that if `f : X i ‚ü∂ S` and `f' : X' j ‚ü∂ S` are two covering
families of morphisms in `S` such that the sieve generated by `f'` is
contained in the sieve generated by `f`, then the functor
`F.DescentData f ‚•§ F.DescentData f'` is full.

TODO (@joelriou): show that the functor is also faithful, and deduce
characterizations of (pre)stacks.

-/

@[expose] public section

universe t t' v' v u' u

namespace CategoryTheory

open Limits Opposite Bicategory

namespace Pseudofunctor

open DescentData LocallyDiscreteOpToCat

variable {C : Type u} [Category.{v} C] (F : LocallyDiscrete C·µí·µñ ‚•§·µñ Cat.{v', u'})

section

variable {J : GrothendieckTopology C} [F.IsPrestack J]

variable {Œπ : Type t} {S : C} {X : Œπ ‚Üí C} {f : ‚àÄ i, X i ‚ü∂ S}
  {Œπ' : Type t'} {X' : Œπ' ‚Üí C} {f' : ‚àÄ j, X' j ‚ü∂ S}
  {Œ± : Œπ' ‚Üí Œπ} {p' : ‚àÄ j, X' j ‚ü∂ X (Œ± j)} (w : ‚àÄ j, p' j ‚â´ f (Œ± j) = f' j)
  (hf' : Sieve.ofArrows _ f' ‚àà J S)

namespace full_pullFunctor

variable {F} {D‚ÇÅ D‚ÇÇ : F.DescentData f}
  (œÜ : (pullFunctor F (p := ùüô _) (f' := f') (p' := p') (by cat_disch)).obj D‚ÇÅ ‚ü∂
    (pullFunctor F (p := ùüô _) (f' := f') (p' := p') (by cat_disch)).obj D‚ÇÇ)

variable (f f') in
/-- Given two families of morphims `f i : X i ‚ü∂ S` and `f' j : X' j ‚ü∂ S`,
this is the sieve on `Over.mk (ùüô (X i)) : Over (X i)` which corresponds
to the sieve of `X i` that is obtained by pulling back by `f i` the sieve
generated by `f'`. -/
abbrev sieve (i : Œπ) : Sieve (Over.mk (ùüô (X i))) :=
  (Sieve.overEquiv (Over.mk (ùüô (X i)))).symm
    (Sieve.pullback (f i) (Sieve.ofArrows X' f'))

include hf' in
variable (f) in
lemma sieve_mem (i : Œπ) : sieve f f' i ‚àà J.over _ _ := by
  simpa only [J.mem_over_iff, Equiv.apply_symm_apply] using J.pullback_stable (f i) hf'

lemma mem_sieve {i : Œπ} {Z : C} (q : Z ‚ü∂ X i) ‚¶Éj : Œπ'‚¶Ñ (a : Z ‚ü∂ X' j)
    (fac : a ‚â´ f' j = q ‚â´ f i := by cat_disch) :
    sieve f f' i (Over.homMk q : Over.mk q ‚ü∂ Over.mk (ùüô (X i))) :=
  ‚ü®_, a, f' j, ‚ü®j‚ü©, fac‚ü©

namespace sieve

variable {i : Œπ} {Z : C} {q : Z ‚ü∂ X i}
  (hq : sieve f f' i (Over.homMk q : Over.mk q ‚ü∂ Over.mk (ùüô X i)))

include hq in
lemma exists_fac : ‚àÉ (j : Œπ') (a : Z ‚ü∂ X' j), a ‚â´ f' j = q ‚â´ f i := by
  obtain ‚ü®_, q, _, ‚ü®j‚ü©, fac‚ü© := hq
  exact ‚ü®j, q, fac‚ü©

/-- If a morphism `q : Z ‚ü∂ X i` belongs to `sieve f f' i`, this is a choice of
index `j` such that there exists a factorization `a ‚â´ f' j = q ‚â´ f i` for
some `a`. -/
noncomputable def idx : Œπ' := (exists_fac hq).choose

/-- If a morphism `q : Z ‚ü∂ X i` belongs to `sieve f f' i`, this is a choice of
a morphism `a : Z ‚ü∂ X' j` for some `j` such that `a ‚â´ f' j = q ‚â´ f i`. -/
noncomputable def a : Z ‚ü∂ X' (idx hq) := (exists_fac hq).choose_spec.choose

@[reassoc]
lemma fac : a hq ‚â´ f' (idx hq) = q ‚â´ f i := (exists_fac hq).choose_spec.choose_spec

end sieve

/-- Given two family of morphisms `f : X i ‚ü∂ S` and `f' : X' j ‚ü∂ S`,
two objects `D‚ÇÅ D‚ÇÇ : F.DescentData f`, a morphism `œÜ` between the images in
`F.DescentData f'` of `D‚ÇÅ` and `D‚ÇÇ` by a functor `pullFunctor`, and a factorization
`a ‚â´ f' j = q ‚â´ f i`, this is the section on `Over.mk q` of the presheaf
of morphisms from `D‚ÇÅ.obj i` to `D‚ÇÇ.obj i` that is obtained by pulling back `œÜ.hom j`. -/
def mor ‚¶Éi : Œπ‚¶Ñ {Z : C} (q : Z ‚ü∂ X i) ‚¶Éj : Œπ'‚¶Ñ (a : Z ‚ü∂ X' j)
    (fac : a ‚â´ f' j = q ‚â´ f i := by cat_disch) :
    (F.presheafHom (D‚ÇÅ.obj i) (D‚ÇÇ.obj i)).obj (op (Over.mk q)) :=
  D‚ÇÅ.hom (q ‚â´ f i) q (a ‚â´ p' j) ‚â´ pullHom (œÜ.hom j) a _ _ ‚â´ D‚ÇÇ.hom (q ‚â´ f i) (a ‚â´ p' j) q

lemma mor_eq ‚¶Éi : Œπ‚¶Ñ {Z : C} (q : Z ‚ü∂ X i) ‚¶Éj : Œπ'‚¶Ñ (a : Z ‚ü∂ X' j)
    (fac : a ‚â´ f' j = q ‚â´ f i) (q' : Z ‚ü∂ S) (a' : Z ‚ü∂ X (Œ± j))
    (hq' : q ‚â´ f i = q' := by cat_disch) (ha' : a ‚â´ p' j = a' := by cat_disch) :
    mor w œÜ q a fac =
      D‚ÇÅ.hom q' q a' ‚â´ pullHom (œÜ.hom j) a _ _ ‚â´ D‚ÇÇ.hom q' a' q := by
  subst hq' ha'
  rfl

include w œÜ in
lemma mor_precomp ‚¶Éi : Œπ‚¶Ñ {Z : C} (q : Z ‚ü∂ X i) ‚¶Éj : Œπ'‚¶Ñ (a : Z ‚ü∂ X' j)
    (fac : a ‚â´ f' j = q ‚â´ f i) {Z' : C} (r : Z' ‚ü∂ Z)
    (r' : Z' ‚ü∂ X i) (a' : Z' ‚ü∂ X' j) (hr' : r ‚â´ q = r' := by cat_disch)
    (ha' : r ‚â´ a = a' := by cat_disch) :
    mor w œÜ r' a' (by cat_disch) =
      (F.presheafHom (D‚ÇÅ.obj i) (D‚ÇÇ.obj i)).map (Over.homMk r).op (mor w œÜ q a fac) := by
  dsimp
  rw [mor_eq _ _ _ _ _ (r ‚â´ q ‚â´ f i) (r ‚â´ a ‚â´ p' j),
    mor_eq _ _ _ _ _ _ _ rfl rfl,
    ‚Üê D‚ÇÅ.pullHom_hom r (q ‚â´ f i) _ rfl q (a ‚â´ p' j) rfl (by cat_disch) r' _ hr' rfl,
    ‚Üê D‚ÇÇ.pullHom_hom r (q ‚â´ f i) _ rfl (a ‚â´ p' j) q (by cat_disch) rfl _ r' rfl hr']
  have := F.mapComp'_naturality_2 a.op.toLoc r.op.toLoc a'.op.toLoc (by cat_disch) (œÜ.hom j)
  dsimp [pullHom] at this ‚ä¢
  simp only [Category.assoc, Functor.map_comp, ‚Üê this,
    Cat.Hom.inv_hom_id_toNatTrans_app_assoc,
    mapComp'‚ÇÄ‚ÇÅ‚ÇÉ_hom_comp_whiskerLeft_mapComp'_hom_app_assoc F
    (p' j).op.toLoc a.op.toLoc r.op.toLoc ((p' j).op.toLoc ‚â´ a.op.toLoc) a'.op.toLoc
      (((p' j).op.toLoc ‚â´ a.op.toLoc) ‚â´ r.op.toLoc) rfl (by grind) (by grind),
    ‚Üê mapComp'_inv_whiskerRight_mapComp'‚ÇÄ‚ÇÇ‚ÇÉ_inv_app_assoc F
    (p' j).op.toLoc a.op.toLoc r.op.toLoc ((p' j).op.toLoc ‚â´ a.op.toLoc) a'.op.toLoc
      (((p' j).op.toLoc ‚â´ a.op.toLoc) ‚â´ r.op.toLoc) rfl (by grind) (by grind)]

lemma mor_unique ‚¶Éi : Œπ‚¶Ñ {Z : C} (q : Z ‚ü∂ X i)
    ‚¶Éj‚ÇÅ : Œπ'‚¶Ñ (a‚ÇÅ : Z ‚ü∂ X' j‚ÇÅ) ‚¶Éj‚ÇÇ : Œπ'‚¶Ñ (a‚ÇÇ : Z ‚ü∂ X' j‚ÇÇ)
    (fac‚ÇÅ : a‚ÇÅ ‚â´ f' j‚ÇÅ = q ‚â´ f i := by cat_disch)
    (fac‚ÇÇ : a‚ÇÇ ‚â´ f' j‚ÇÇ = q ‚â´ f i := by cat_disch) :
    mor w œÜ q a‚ÇÅ fac‚ÇÅ = mor w œÜ q a‚ÇÇ fac‚ÇÇ := by
  have := œÜ.comm (q ‚â´ f i) a‚ÇÅ a‚ÇÇ fac‚ÇÅ fac‚ÇÇ
  dsimp at this
  rw [pullFunctorObjHom_eq _ _ _ _ _ (q ‚â´ f i) (a‚ÇÅ ‚â´ p' j‚ÇÅ) (a‚ÇÇ ‚â´ p' j‚ÇÇ) rfl,
    pullFunctorObjHom_eq _ _ _ _ _ (q ‚â´ f i) (a‚ÇÅ ‚â´ p' j‚ÇÅ) (a‚ÇÇ ‚â´ p' j‚ÇÇ) rfl,
    map_eq_pullHom _ _ _ _ (by exact rfl) rfl, map_eq_pullHom _ _ _ _ rfl rfl] at this
  dsimp at this
  simp only [Category.assoc, Cat.Hom.hom_inv_id_toNatTrans_app_assoc, cancel_epi] at this
  simp only [‚Üê Category.assoc, cancel_mono] at this
  rw [‚Üê cancel_mono (D‚ÇÇ.hom (q ‚â´ f i) (a‚ÇÇ ‚â´ p' j‚ÇÇ) q), Category.assoc,
    D‚ÇÇ.hom_comp] at this
  rw [mor_eq _ _ _ _ _ _ _ rfl rfl, mor_eq _ _ _ _ _ _ _ rfl rfl, this]
  simp

/-- Given two family of morphisms `f : X i ‚ü∂ S` and `f' : X' j ‚ü∂ S`,
two objects `D‚ÇÅ D‚ÇÇ : F.DescentData f`, a morphism `œÜ` between the images in
`F.DescentData f'` of `D‚ÇÅ` and `D‚ÇÇ` by a functor `pullFunctor`. This is
a family of elements of the sheaf of morphisms from `D‚ÇÅ.obj i` to `D‚ÇÇ.obj i`
that is deduced from `œÜ` over a covering sieve. See `hom` below for the glued
morphism `D‚ÇÅ.obj i ‚ü∂ D‚ÇÇ.obj i` when `f'` is a covering family and `F` is a prestack. -/
noncomputable def familyOfElements (i : Œπ) :
    Presieve.FamilyOfElements (F.presheafHom (D‚ÇÅ.obj i) (D‚ÇÇ.obj i)) (sieve f f' i).arrows :=
  fun Z q hq ‚Ü¶
    mor w œÜ _ _ (sieve.fac (f := f) (f' := f') (q := Z.hom) (by
      convert hq
      ext
      simpa using (Over.w q).symm))

lemma familyOfElements_eq {i : Œπ} {Z : Over (X i)} (g : Z ‚ü∂ Over.mk (ùüô (X i)))
    ‚¶Éj : Œπ'‚¶Ñ (a : Z.left ‚ü∂ X' j) (fac : a ‚â´ f' j = Z.hom ‚â´ f i := by cat_disch) :
    familyOfElements w œÜ i g (by
      rw [show g = Over.homMk Z.hom by ext; simpa using Over.w g]
      exact mem_sieve _ _ fac) = mor w œÜ _ _ fac :=
  mor_unique _ _ _ _ _ _ _

lemma compatible_familyOfElements (i : Œπ) :
    (familyOfElements w œÜ i).Compatible := by
  intro Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ fac
  obtain rfl : f‚ÇÅ = Over.homMk Y‚ÇÅ.hom := by ext; simpa using Over.w f‚ÇÅ
  obtain rfl : f‚ÇÇ = Over.homMk Y‚ÇÇ.hom := by ext; simpa using Over.w f‚ÇÇ
  obtain ‚ü®g‚ÇÅ, hg‚ÇÅ, rfl‚ü© := Over.homMk_surjective g‚ÇÅ
  obtain ‚ü®g‚ÇÇ, hg‚ÇÇ, rfl‚ü© := Over.homMk_surjective g‚ÇÇ
  obtain ‚ü®_, a‚ÇÅ, _, ‚ü®j‚ÇÅ‚ü©, fac‚ÇÅ‚ü© := h‚ÇÅ
  obtain ‚ü®_, a‚ÇÇ, _, ‚ü®j‚ÇÇ‚ü©, fac‚ÇÇ‚ü© := h‚ÇÇ
  dsimp at a‚ÇÅ a‚ÇÇ fac‚ÇÅ fac‚ÇÇ
  rw [familyOfElements_eq _ _ _ _ fac‚ÇÅ, familyOfElements_eq _ _ _ _ fac‚ÇÇ,
    ‚Üê mor_precomp w œÜ Y‚ÇÅ.hom a‚ÇÅ fac‚ÇÅ _ _ _ hg‚ÇÅ rfl,
    ‚Üê mor_precomp w œÜ Y‚ÇÇ.hom a‚ÇÇ fac‚ÇÇ _ _ _ hg‚ÇÇ rfl]
  apply mor_unique

include hf' in
/-- Given two families of morphisms `f : X i ‚ü∂ S` and `f' : X' j ‚ü∂ S`,
two objects `D‚ÇÅ D‚ÇÇ : F.DescentData f`, a morphism `œÜ` between the images in
`F.DescentData f'` of `D‚ÇÅ` and `D‚ÇÇ` by a functor `pullFunctor`. When `F`
is a prestack and `f'` a covering family, this is the morphism `D‚ÇÅ.obj i ‚ü∂ D‚ÇÇ.obj i`
that is deduced from `œÜ` by gluing. -/
noncomputable def hom (i : Œπ) : D‚ÇÅ.obj i ‚ü∂ D‚ÇÇ.obj i :=
  F.presheafHomObjHomEquiv.symm
    (Presieve.IsSheafFor.amalgamate (Presieve.IsSheaf.isSheafFor _
    ((isSheaf_iff_isSheaf_of_type _ _).1 (IsPrestack.isSheaf J _ _)) _
      (by simpa using sieve_mem _ hf' i)) _
        (compatible_familyOfElements w œÜ i))

lemma map_hom ‚¶Éi : Œπ‚¶Ñ ‚¶ÉY : C‚¶Ñ (q : Y ‚ü∂ X i) ‚¶Éj : Œπ'‚¶Ñ
    (a : Y ‚ü∂ X' j) (fac : a ‚â´ f' j = q ‚â´ f i := by cat_disch) :
    (F.map q.op.toLoc).toFunctor.map (hom w hf' œÜ i) = mor w œÜ q a fac := by
  let s := Presieve.IsSheafFor.amalgamate (Presieve.IsSheaf.isSheafFor _
    ((isSheaf_iff_isSheaf_of_type _ _).1 (IsPrestack.isSheaf J _ _)) _
      (by simpa using sieve_mem _ hf' i)) _
        (compatible_familyOfElements w œÜ i)
  have hs : (familyOfElements w œÜ i).IsAmalgamation s :=
    Presieve.IsSheafFor.isAmalgamation (Presieve.IsSheaf.isSheafFor _
      ((isSheaf_iff_isSheaf_of_type _ _).1 (IsPrestack.isSheaf J _ _)) _
        (by simpa using sieve_mem _ hf' i)) (compatible_familyOfElements w œÜ i)
  change (F.map q.op.toLoc).toFunctor.map (F.presheafHomObjHomEquiv.symm s) = _
  simpa [familyOfElements_eq w œÜ (Z := Over.mk q) _ a fac,
    presheafHomObjHomEquiv, pullHom, mapComp'_id_comp_hom_app,
    mapComp'_id_comp_inv_app] using hs _ (mem_sieve _ _ fac)

@[reassoc]
lemma comm ‚¶ÉW : C‚¶Ñ (q : W ‚ü∂ S) ‚¶Éi‚ÇÅ i‚ÇÇ : Œπ‚¶Ñ
    (f‚ÇÅ : W ‚ü∂ X i‚ÇÅ) (f‚ÇÇ : W ‚ü∂ X i‚ÇÇ) (hf‚ÇÅ : f‚ÇÅ ‚â´ f i‚ÇÅ = q := by cat_disch)
    (hf‚ÇÇ : f‚ÇÇ ‚â´ f i‚ÇÇ = q := by cat_disch) :
    (F.map f‚ÇÅ.op.toLoc).toFunctor.map (hom w hf' œÜ i‚ÇÅ) ‚â´ D‚ÇÇ.hom q f‚ÇÅ f‚ÇÇ =
    D‚ÇÅ.hom q f‚ÇÅ f‚ÇÇ ‚â´ (F.map f‚ÇÇ.op.toLoc).toFunctor.map (hom w hf' œÜ i‚ÇÇ) := by
  rw [‚Üê cancel_mono (D‚ÇÇ.hom q f‚ÇÇ f‚ÇÅ), Category.assoc,
    Category.assoc, DescentData.hom_comp, D‚ÇÇ.hom_self _ _ hf‚ÇÅ, Category.comp_id]
  have H : (Sieve.overEquiv (Over.mk f‚ÇÅ)).symm
      (Sieve.pullback q (Sieve.ofArrows X' f')) ‚àà J.over _ _ := by
    rw [J.mem_over_iff, Equiv.apply_symm_apply]
    exact J.pullback_stable _ hf'
  refine ((isSheaf_iff_isSheaf_of_type _ _).1
    (IsPrestack.isSheaf J (D‚ÇÅ.obj i‚ÇÅ) (D‚ÇÇ.obj i‚ÇÅ)) _ H).isSeparatedFor.ext ?_
  rintro T p ‚ü®_, g, _, ‚ü®j‚ü©, fac‚ü©
  obtain ‚ü®T, t, rfl‚ü© := T.mk_surjective
  obtain ‚ü®p, hp, rfl‚ü© := Over.homMk_surjective p
  dsimp [pullHom] at t g p hp fac ‚ä¢
  subst hp
  simp only [mapComp'_inv_naturality, Cat.Hom.comp_toFunctor, Functor.comp_obj,
    Cat.Hom.hom_inv_id_toNatTrans_app_assoc, Functor.map_comp, Category.assoc]
  rw [‚Üê F.mapComp'_naturality_1 f‚ÇÇ.op.toLoc p.op.toLoc (p ‚â´ f‚ÇÇ).op.toLoc (by grind),
    map_hom _ _ _ _ g (by grind), map_hom _ _ _ _ g (by grind),
    mor_eq _ _ _ _ (by grind) (p ‚â´ q) _ (by grind) rfl,
    mor_eq _ _ _ _ (by grind) (p ‚â´ q) _ (by grind) rfl,
    map_eq_pullHom _ _ _ _ rfl rfl, map_eq_pullHom _ _ _ _ rfl rfl,
    pullHom_hom _ _ _ _ rfl _ _ hf‚ÇÅ hf‚ÇÇ _ _ rfl rfl,
    pullHom_hom _ _ _ _ rfl _ _ hf‚ÇÇ hf‚ÇÅ _ _ rfl rfl]
  simp

end full_pullFunctor

open full_pullFunctor in
include w hf' in
lemma full_pullFunctor :
    (pullFunctor F (f := f) (p := ùüô _) (f' := f') (p' := p') (by cat_disch)).Full where
  map_surjective {D‚ÇÅ D‚ÇÇ} œÜ :=
    ‚ü®{ hom := fun i ‚Ü¶ hom w hf' œÜ i, comm := comm _ _ _ }, by
      ext i
      dsimp
      rw [map_hom _ _ _ _ (ùüô _) (by cat_disch),
        mor_eq _ _ _ _ _ (f' i) (p' i), pullHom_id,
        D‚ÇÅ.hom_self _ _ (by cat_disch), D‚ÇÇ.hom_self _ _ (by cat_disch),
        Category.id_comp, Category.comp_id]‚ü©

end

end Pseudofunctor

end CategoryTheory
