/-
Copyright (c) 2025 JoÃ«l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: JoÃ«l Riou
-/
module

public import Mathlib.CategoryTheory.Sites.Descent.IsStack

/-!
# Characterization of (pre)stacks for a precoverage

Let `F : LocallyDiscrete Cáµ’áµ– â¥¤áµ– Cat` be a pseudofunctor.
Assuming `F` is a prestack for a Grothendieck topology `J`,
we show that if `f : X i âŸ¶ S` and `f' : X' j âŸ¶ S` are two covering
families of morphisms in `S` such that the sieve generated by `f'` is
contained in the sieve generated by `f`, then the functor
`F.DescentData f â¥¤ F.DescentData f'` is full.

TODO (@joelriou): show that the functor is also faithful, and deduce
characterizations of (pre)stacks.

-/

@[expose] public section

universe t t' v' v u' u

namespace CategoryTheory

open Limits Opposite Bicategory

namespace Pseudofunctor

open DescentData LocallyDiscreteOpToCat

variable {C : Type u} [Category.{v} C] (F : LocallyDiscrete Cáµ’áµ– â¥¤áµ– Cat.{v', u'})

section

variable {J : GrothendieckTopology C} [F.IsPrestack J]

variable {Î¹ : Type t} {S : C} {X : Î¹ â†’ C} {f : âˆ€ i, X i âŸ¶ S}
  {Î¹' : Type t'} {X' : Î¹' â†’ C} {f' : âˆ€ j, X' j âŸ¶ S}
  {Î± : Î¹' â†’ Î¹} {p' : âˆ€ j, X' j âŸ¶ X (Î± j)} (w : âˆ€ j, p' j â‰« f (Î± j) = f' j)
  (hf' : Sieve.ofArrows _ f' âˆˆ J S)

namespace full_pullFunctor

variable {F} {Dâ‚ Dâ‚‚ : F.DescentData f}
  (Ï† : (pullFunctor F (p := ğŸ™ _) (f' := f') (p' := p') (by cat_disch)).obj Dâ‚ âŸ¶
    (pullFunctor F (p := ğŸ™ _) (f' := f') (p' := p') (by cat_disch)).obj Dâ‚‚)

variable (f f') in
/-- Given two families of morphims `f i : X i âŸ¶ S` and `f' j : X' j âŸ¶ S`,
this is the sieve on `Over.mk (ğŸ™ (X i)) : Over (X i)` which corresponds
to the sieve of `X i` that is obtained by pulling back by `f i` the sieve
generated by `f'`. -/
abbrev sieve (i : Î¹) : Sieve (Over.mk (ğŸ™ (X i))) :=
  (Sieve.overEquiv (Over.mk (ğŸ™ (X i)))).symm
    (Sieve.pullback (f i) (Sieve.ofArrows X' f'))

include hf' in
variable (f) in
lemma sieve_mem (i : Î¹) : sieve f f' i âˆˆ J.over _ _ := by
  simpa only [J.mem_over_iff, Equiv.apply_symm_apply] using J.pullback_stable (f i) hf'

lemma mem_sieve {i : Î¹} {Z : C} (q : Z âŸ¶ X i) â¦ƒj : Î¹'â¦„ (a : Z âŸ¶ X' j)
    (fac : a â‰« f' j = q â‰« f i) :
    sieve f f' i (Over.homMk q : Over.mk q âŸ¶ Over.mk (ğŸ™ (X i))) :=
  âŸ¨_, a, f' j, âŸ¨jâŸ©, facâŸ©

namespace sieve

variable {i : Î¹} {Z : C} {q : Z âŸ¶ X i}
  (hq : sieve f f' i (Over.homMk q : Over.mk q âŸ¶ Over.mk (ğŸ™ X i)))

include hq in
lemma exists_fac : âˆƒ (j : Î¹') (a : Z âŸ¶ X' j), a â‰« f' j = q â‰« f i := by
  obtain âŸ¨_, q, _, âŸ¨jâŸ©, facâŸ© := hq
  exact âŸ¨j, q, facâŸ©

/-- If a morphism `q : Z âŸ¶ X i` belongs to `sieve f f' i`, this is a choice of
index `j` such that there exists a factorization `a â‰« f' j = q â‰« f i` for
some `a`. -/
noncomputable def idx : Î¹' := (exists_fac hq).choose

/-- If a morphism `q : Z âŸ¶ X i` belongs to `sieve f f' i`, this is a choice of
a morphism `a : Z âŸ¶ X' j` for some `j` such that `a â‰« f' j = q â‰« f i`. -/
noncomputable def a : Z âŸ¶ X' (idx hq) := (exists_fac hq).choose_spec.choose

@[reassoc]
lemma fac : a hq â‰« f' (idx hq) = q â‰« f i := (exists_fac hq).choose_spec.choose_spec

end sieve

/-- Given two family of morphisms `f : X i âŸ¶ S` and `f' : X' j âŸ¶ S`,
two objects `Dâ‚ Dâ‚‚ : F.DescentData f`, a morphism `Ï†` between the images in
`F.DescentData f'` of `Dâ‚` and `Dâ‚‚` by a functor `pullFunctor`, and a factorization
`a â‰« f' j = q â‰« f i`, this is the section on `Over.mk q` of the presheaf
of morphisms from `Dâ‚.obj i` to `Dâ‚‚.obj i` that is obtained by pulling back `Ï†.hom j`. -/
def mor â¦ƒi : Î¹â¦„ {Z : C} (q : Z âŸ¶ X i) â¦ƒj : Î¹'â¦„ (a : Z âŸ¶ X' j)
    (fac : a â‰« f' j = q â‰« f i) :
    (F.presheafHom (Dâ‚.obj i) (Dâ‚‚.obj i)).obj (op (Over.mk q)) :=
  Dâ‚.hom (q â‰« f i) q (a â‰« p' j) â‰« pullHom (Ï†.hom j) a _ _ â‰« Dâ‚‚.hom (q â‰« f i) (a â‰« p' j) q

lemma mor_eq â¦ƒi : Î¹â¦„ {Z : C} (q : Z âŸ¶ X i) â¦ƒj : Î¹'â¦„ (a : Z âŸ¶ X' j)
    (fac : a â‰« f' j = q â‰« f i) (q' : Z âŸ¶ S) (hq' : q â‰« f i = q')
    (a' : Z âŸ¶ X (Î± j)) (ha' : a â‰« p' j = a') :
    mor w Ï† q a fac =
      Dâ‚.hom q' q a' â‰« pullHom (Ï†.hom j) a _ _ â‰« Dâ‚‚.hom q' a' q := by
  subst hq' ha'
  rfl

include w Ï† in
lemma mor_precomp â¦ƒi : Î¹â¦„ {Z : C} (q : Z âŸ¶ X i) â¦ƒj : Î¹'â¦„ (a : Z âŸ¶ X' j)
    (fac : a â‰« f' j = q â‰« f i) {Z' : C} (r : Z' âŸ¶ Z)
    (r' : Z' âŸ¶ X i) (hr' : r â‰« q = r')
    (a' : Z' âŸ¶ X' j) (ha' : r â‰« a = a') :
    mor w Ï† r' a' (by cat_disch) =
      (F.presheafHom (Dâ‚.obj i) (Dâ‚‚.obj i)).map (Over.homMk r).op (mor w Ï† q a fac) := by
  dsimp
  rw [mor_eq _ _ _ _ _ (r â‰« q â‰« f i) (by cat_disch) (r â‰« a â‰« p' j) (by cat_disch),
    mor_eq _ _ _ _ _ _ rfl _ rfl,
    â† Dâ‚.pullHom_hom r (q â‰« f i) _ rfl q (a â‰« p' j) rfl (by cat_disch) r' _ hr' rfl,
    â† Dâ‚‚.pullHom_hom r (q â‰« f i) _ rfl (a â‰« p' j) q (by cat_disch) rfl _ r' rfl hr']
  have := F.mapComp'_naturality_2 a.op.toLoc r.op.toLoc a'.op.toLoc (by cat_disch) (Ï†.hom j)
  dsimp [pullHom] at this âŠ¢
  simp only [Category.assoc, Functor.map_comp, â† this,
    Cat.Hom.inv_hom_id_toNatTrans_app_assoc,
    mapComp'â‚€â‚â‚ƒ_hom_comp_whiskerLeft_mapComp'_hom_app_assoc F
    (p' j).op.toLoc a.op.toLoc r.op.toLoc ((p' j).op.toLoc â‰« a.op.toLoc) a'.op.toLoc
      (((p' j).op.toLoc â‰« a.op.toLoc) â‰« r.op.toLoc) rfl (by grind) (by grind),
    â† mapComp'_inv_whiskerRight_mapComp'â‚€â‚‚â‚ƒ_inv_app_assoc F
    (p' j).op.toLoc a.op.toLoc r.op.toLoc ((p' j).op.toLoc â‰« a.op.toLoc) a'.op.toLoc
      (((p' j).op.toLoc â‰« a.op.toLoc) â‰« r.op.toLoc) rfl (by grind) (by grind)]

lemma mor_unique â¦ƒi : Î¹â¦„ {Z : C} (q : Z âŸ¶ X i)
    â¦ƒjâ‚ : Î¹'â¦„ (aâ‚ : Z âŸ¶ X' jâ‚) (facâ‚ : aâ‚ â‰« f' jâ‚ = q â‰« f i)
    â¦ƒjâ‚‚ : Î¹'â¦„ (aâ‚‚ : Z âŸ¶ X' jâ‚‚) (facâ‚‚ : aâ‚‚ â‰« f' jâ‚‚ = q â‰« f i) :
    mor w Ï† q aâ‚ facâ‚ = mor w Ï† q aâ‚‚ facâ‚‚ := by
  have := Ï†.comm (q â‰« f i) aâ‚ aâ‚‚ facâ‚ facâ‚‚
  dsimp at this
  rw [pullFunctorObjHom_eq _ _ _ _ _ (q â‰« f i) (aâ‚ â‰« p' jâ‚) (aâ‚‚ â‰« p' jâ‚‚) rfl,
    pullFunctorObjHom_eq _ _ _ _ _ (q â‰« f i) (aâ‚ â‰« p' jâ‚) (aâ‚‚ â‰« p' jâ‚‚) rfl,
    map_eq_pullHom _ _ _ _ (by exact rfl) rfl, map_eq_pullHom _ _ _ _ rfl rfl] at this
  dsimp at this
  simp only [Category.assoc, Cat.Hom.hom_inv_id_toNatTrans_app_assoc, cancel_epi] at this
  simp only [â† Category.assoc, cancel_mono] at this
  rw [â† cancel_mono (Dâ‚‚.hom (q â‰« f i) (aâ‚‚ â‰« p' jâ‚‚) q), Category.assoc,
    Dâ‚‚.hom_comp] at this
  rw [mor_eq _ _ _ _ _ _ rfl _ rfl, mor_eq _ _ _ _ _ _ rfl _ rfl, this]
  simp

/-- Given two family of morphisms `f : X i âŸ¶ S` and `f' : X' j âŸ¶ S`,
two objects `Dâ‚ Dâ‚‚ : F.DescentData f`, a morphism `Ï†` between the images in
`F.DescentData f'` of `Dâ‚` and `Dâ‚‚` by a functor `pullFunctor`. This is
a family of elements of the sheaf of morphisms from `Dâ‚.obj i` to `Dâ‚‚.obj i`
that is deduced from `Ï†` over a covering sieve. See `hom` below for the glued
morphism `Dâ‚.obj i âŸ¶ Dâ‚‚.obj i` when `f'` is a covering family and `F` is a prestack. -/
noncomputable def familyOfElements (i : Î¹) :
    Presieve.FamilyOfElements (F.presheafHom (Dâ‚.obj i) (Dâ‚‚.obj i)) (sieve f f' i).arrows :=
  fun Z q hq â†¦
    mor w Ï† _ _ (sieve.fac (f := f) (f' := f') (q := Z.hom) (by
      convert hq
      ext
      simpa using (Over.w q).symm))

lemma familyOfElements_eq {i : Î¹} {Z : Over (X i)} (g : Z âŸ¶ Over.mk (ğŸ™ (X i)))
    â¦ƒj : Î¹'â¦„ (a : Z.left âŸ¶ X' j) (fac : a â‰« f' j = Z.hom â‰« f i) :
    familyOfElements w Ï† i g (by
      rw [show g = Over.homMk Z.hom by ext; simpa using Over.w g]
      exact mem_sieve _ _ fac) = mor w Ï† _ _ fac :=
  mor_unique _ _ _ _ _ _ _

lemma compatible_familyOfElements (i : Î¹) :
    (familyOfElements w Ï† i).Compatible := by
  intro Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ fac
  obtain rfl : fâ‚ = Over.homMk Yâ‚.hom := by ext; simpa using Over.w fâ‚
  obtain rfl : fâ‚‚ = Over.homMk Yâ‚‚.hom := by ext; simpa using Over.w fâ‚‚
  obtain âŸ¨gâ‚, hgâ‚, rflâŸ© := Over.homMk_surjective gâ‚
  obtain âŸ¨gâ‚‚, hgâ‚‚, rflâŸ© := Over.homMk_surjective gâ‚‚
  obtain âŸ¨_, aâ‚, _, âŸ¨jâ‚âŸ©, facâ‚âŸ© := hâ‚
  obtain âŸ¨_, aâ‚‚, _, âŸ¨jâ‚‚âŸ©, facâ‚‚âŸ© := hâ‚‚
  dsimp at aâ‚ aâ‚‚ facâ‚ facâ‚‚
  rw [familyOfElements_eq _ _ _ _ facâ‚, familyOfElements_eq _ _ _ _ facâ‚‚,
    â† mor_precomp w Ï† Yâ‚.hom aâ‚ facâ‚ _ _ hgâ‚ _ rfl,
    â† mor_precomp w Ï† Yâ‚‚.hom aâ‚‚ facâ‚‚ _ _ hgâ‚‚ _ rfl]
  apply mor_unique

include hf' in
/-- Given two family of morphisms `f : X i âŸ¶ S` and `f' : X' j âŸ¶ S`,
two objects `Dâ‚ Dâ‚‚ : F.DescentData f`, a morphism `Ï†` between the images in
`F.DescentData f'` of `Dâ‚` and `Dâ‚‚` by a functor `pullFunctor`. When `F`
is a prestack and `f'` a covering family, this is the morphism `Dâ‚.obj i âŸ¶ Dâ‚‚.obj i`
that is deduced from `Ï†` by gluing. -/
noncomputable def hom (i : Î¹) : Dâ‚.obj i âŸ¶ Dâ‚‚.obj i :=
  F.presheafHomObjHomEquiv.symm
    (Presieve.IsSheafFor.amalgamate (Presieve.IsSheaf.isSheafFor _
    ((isSheaf_iff_isSheaf_of_type _ _).1 (IsPrestack.isSheaf J _ _)) _
      (by simpa using sieve_mem _ hf' i)) _
        (compatible_familyOfElements w Ï† i))

lemma map_hom â¦ƒi : Î¹â¦„ â¦ƒY : Câ¦„ (q : Y âŸ¶ X i) â¦ƒj : Î¹'â¦„
    (a : Y âŸ¶ X' j) (fac : a â‰« f' j = q â‰« f i) :
    (F.map q.op.toLoc).toFunctor.map (hom w hf' Ï† i) = mor w Ï† q a fac := by
  let s := Presieve.IsSheafFor.amalgamate (Presieve.IsSheaf.isSheafFor _
    ((isSheaf_iff_isSheaf_of_type _ _).1 (IsPrestack.isSheaf J _ _)) _
      (by simpa using sieve_mem _ hf' i)) _
        (compatible_familyOfElements w Ï† i)
  have hs : (familyOfElements w Ï† i).IsAmalgamation s :=
    Presieve.IsSheafFor.isAmalgamation (Presieve.IsSheaf.isSheafFor _
      ((isSheaf_iff_isSheaf_of_type _ _).1 (IsPrestack.isSheaf J _ _)) _
        (by simpa using sieve_mem _ hf' i)) (compatible_familyOfElements w Ï† i)
  change (F.map q.op.toLoc).toFunctor.map (F.presheafHomObjHomEquiv.symm s) = _
  simpa [familyOfElements_eq w Ï† (Z := Over.mk q) _ a fac,
    presheafHomObjHomEquiv, pullHom, mapComp'_id_comp_hom_app,
    mapComp'_id_comp_inv_app] using hs _ (mem_sieve _ _ fac)

@[reassoc]
lemma comm â¦ƒW : Câ¦„ (q : W âŸ¶ S) â¦ƒiâ‚ iâ‚‚ : Î¹â¦„
    (fâ‚ : W âŸ¶ X iâ‚) (fâ‚‚ : W âŸ¶ X iâ‚‚) (hfâ‚ : fâ‚ â‰« f iâ‚ = q) (hfâ‚‚ : fâ‚‚ â‰« f iâ‚‚ = q) :
    (F.map fâ‚.op.toLoc).toFunctor.map (hom w hf' Ï† iâ‚) â‰« Dâ‚‚.hom q fâ‚ fâ‚‚ =
    Dâ‚.hom q fâ‚ fâ‚‚ â‰« (F.map fâ‚‚.op.toLoc).toFunctor.map (hom w hf' Ï† iâ‚‚) := by
  rw [â† cancel_mono (Dâ‚‚.hom q fâ‚‚ fâ‚), Category.assoc,
    Category.assoc, DescentData.hom_comp, Dâ‚‚.hom_self _ _ hfâ‚, Category.comp_id]
  have H : (Sieve.overEquiv (Over.mk fâ‚)).symm
      (Sieve.pullback q (Sieve.ofArrows X' f')) âˆˆ J.over _ _ := by
    rw [J.mem_over_iff, Equiv.apply_symm_apply]
    exact J.pullback_stable _ hf'
  refine ((isSheaf_iff_isSheaf_of_type _ _).1
    (IsPrestack.isSheaf J (Dâ‚.obj iâ‚) (Dâ‚‚.obj iâ‚)) _ H).isSeparatedFor.ext ?_
  rintro T p âŸ¨_, g, _, âŸ¨jâŸ©, facâŸ©
  obtain âŸ¨T, t, rflâŸ© := T.mk_surjective
  obtain âŸ¨p, hp, rflâŸ© := Over.homMk_surjective p
  dsimp [pullHom] at t g p hp fac âŠ¢
  subst hp
  simp only [mapComp'_inv_naturality, Cat.Hom.comp_toFunctor, Functor.comp_obj,
    Cat.Hom.hom_inv_id_toNatTrans_app_assoc, Functor.map_comp, Category.assoc]
  rw [â† F.mapComp'_naturality_1 fâ‚‚.op.toLoc p.op.toLoc (p â‰« fâ‚‚).op.toLoc (by grind),
    map_hom _ _ _ _ g (by grind), map_hom _ _ _ _ g (by grind),
    mor_eq _ _ _ _ (by grind) (p â‰« q) (by grind) _ rfl,
    mor_eq _ _ _ _ (by grind) (p â‰« q) (by grind) _ rfl,
    map_eq_pullHom _ _ _ _ rfl rfl, map_eq_pullHom _ _ _ _ rfl rfl,
    pullHom_hom _ _ _ _ rfl _ _ hfâ‚ hfâ‚‚ _ _ rfl rfl,
    pullHom_hom _ _ _ _ rfl _ _ hfâ‚‚ hfâ‚ _ _ rfl rfl]
  simp

end full_pullFunctor

open full_pullFunctor in
include w hf' in
lemma full_pullFunctor :
    (pullFunctor F (f := f) (p := ğŸ™ _) (f' := f') (p' := p') (by cat_disch)).Full where
  map_surjective {Dâ‚ Dâ‚‚} Ï† :=
    âŸ¨{ hom := fun i â†¦ hom w hf' Ï† i, comm := comm _ _ _ }, by
      ext i
      dsimp
      rw [map_hom _ _ _ _ (ğŸ™ _) (by cat_disch),
        mor_eq _ _ _ _ _ (f' i) (by cat_disch) (p' i) (by simp), pullHom_id,
        Dâ‚.hom_self _ _ (by cat_disch), Dâ‚‚.hom_self _ _ (by cat_disch),
        Category.id_comp, Category.comp_id]âŸ©

end

end Pseudofunctor

end CategoryTheory
