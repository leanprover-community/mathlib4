/-
Copyright (c) 2025 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
module

public import Mathlib.CategoryTheory.Sites.Descent.IsStack

/-!
# Characterization of (pre)stacks for a precoverage

Let `F : LocallyDiscrete C·µí·µñ ‚•§·µñ Cat` be a pseudofunctor.
Assuming `F` is a prestack for a Grothendieck topology `J`,
we show that if `f : X i ‚ü∂ S` and `f' : X' j ‚ü∂ S` are two covering
families of morphisms in `S` such that the sieve generated by `f'` is
contained in the sieve generated by `f`, then the functor
`F.DescentData f ‚•§ F.DescentData f'` is fully faithful.
It follows that if the descent is effective for the family `f'`,
then it is also effective for the family `f`. We translate this
result in terms of the predicate `IsStackFor` as the lemma
`IsStackFor.of_le`: if `R ‚â§ R'` is an inequality of presieves
where `R` is covering, then `F.IsStackFor R` implies `F.IsStackFor R'`.

Now, assume that `J` is a precoverage on `C` which satisfies slightly
stronger axioms than pretopologies (`HasIsos`, `J.IsStableUnderBaseChange`,
and `J.IsStableUnderComposition`). We deduce from the
results above that `F` is a prestack (resp. a stack) for the
Grothendieck topology associated to `J` if `F` satisfies
`F.IsPrestackFor R` (resp. `F.IsStackFor R`) for the presieves `R`
that are part of `J`.

-/

@[expose] public section

universe t t' v' v u' u

namespace CategoryTheory

open Limits Opposite Bicategory

namespace Pseudofunctor

open DescentData LocallyDiscreteOpToCat

variable {C : Type u} [Category.{v} C] (F : LocallyDiscrete C·µí·µñ ‚•§·µñ Cat.{v', u'})

section

variable {J : GrothendieckTopology C} [F.IsPrestack J]

variable {Œπ : Type t} {S : C} {X : Œπ ‚Üí C} {f : ‚àÄ i, X i ‚ü∂ S}
  {Œπ' : Type t'} {X' : Œπ' ‚Üí C} {f' : ‚àÄ j, X' j ‚ü∂ S}
  {Œ± : Œπ' ‚Üí Œπ} {p' : ‚àÄ j, X' j ‚ü∂ X (Œ± j)} (w : ‚àÄ j, p' j ‚â´ f (Œ± j) = f' j)
  (hf' : Sieve.ofArrows _ f' ‚àà J S)

include hf' in
lemma faithful_pullFunctor :
    (pullFunctor F (f := f) (p := ùüô _) (f' := f') (p' := p') (by cat_disch)).Faithful where
  map_injective {D‚ÇÅ D‚ÇÇ œÜ œÜ'} hœÜ := by
    ext i
    refine F.presheafHomObjHomEquiv.injective ?_i
    have : (Sieve.overEquiv (Over.mk (ùüô (X i)))).symm
      (Sieve.pullback (f i) (Sieve.ofArrows X' f')) ‚àà J.over (X i) _ := by
      simpa only [J.mem_over_iff, Equiv.apply_symm_apply] using J.pullback_stable (f i) hf'
    refine (((isSheaf_iff_isSheaf_of_type _ _).1
      (IsPrestack.isSheaf _ _ _)).isSeparated _ this).ext ?_
    rintro Z g ‚ü®Y, p, c, ‚ü®j‚ü©, hp‚ü©
    dsimp at p hp
    have : g.left = Z.hom := by simpa using Over.w g
    have (œà : D‚ÇÅ ‚ü∂ D‚ÇÇ) :
      (F.presheafHom _ _).map g.op (F.presheafHomObjHomEquiv (œà.hom i)) =
        D‚ÇÅ.hom (Z.hom ‚â´ f i) Z.hom (p ‚â´ p' j) ‚â´
          pullHom ((F.map (p' j).op.toLoc).toFunctor.map (œà.hom (Œ± j))) p _ _ ‚â´
          D‚ÇÇ.hom (Z.hom ‚â´ f i) (p ‚â´ p' j) Z.hom := by
      obtain rfl : g = Over.homMk Z.hom := by cat_disch
      have := œà.comm _ Z.hom (p ‚â´ p' j) rfl (by grind)
      dsimp [presheafHomObjHomEquiv, pullHom] at this ‚ä¢
      simp [mapComp'_inv_naturality, Cat.Hom.comp_toFunctor,
        Functor.comp_obj, Cat.Hom.hom_inv_id_toNatTrans_app_assoc, ‚Üê reassoc_of% this,
        D‚ÇÇ.hom_self _ _ rfl, F.mapComp'_id_comp_inv_app, ‚Üê Functor.map_comp,
        F.mapComp'_id_comp_hom_app_assoc]
    replace hœÜ := congr_fun (congr_arg DescentData.Hom.hom hœÜ) j
    dsimp at hœÜ
    simp only [this, hœÜ]

namespace full_pullFunctor

variable {F} {D‚ÇÅ D‚ÇÇ : F.DescentData f}
  (œÜ : (pullFunctor F (p := ùüô _) (f' := f') (p' := p') (by cat_disch)).obj D‚ÇÅ ‚ü∂
    (pullFunctor F (p := ùüô _) (f' := f') (p' := p') (by cat_disch)).obj D‚ÇÇ)

variable (f f') in
/-- Given two families of morphims `f i : X i ‚ü∂ S` and `f' j : X' j ‚ü∂ S`,
this is the sieve of `Over.mk (ùüô (X i)) : Over (X i)` which corresponds
to the sieve of `X i` that is obtained by pulling back by `f i` the sieve
generated by `f`. -/
abbrev sieve (i : Œπ) : Sieve (Over.mk (ùüô (X i))) :=
  (Sieve.overEquiv (Over.mk (ùüô (X i)))).symm
    (Sieve.pullback (f i) (Sieve.ofArrows X' f'))

include hf' in
variable (f) in
lemma sieve_mem (i : Œπ) : sieve f f' i ‚àà J.over _ _ := by
  simpa only [J.mem_over_iff, Equiv.apply_symm_apply] using J.pullback_stable (f i) hf'

lemma mem_sieve {i : Œπ} {Z : C} (q : Z ‚ü∂ X i) ‚¶Éj : Œπ'‚¶Ñ (a : Z ‚ü∂ X' j)
    (fac : a ‚â´ f' j = q ‚â´ f i) :
    sieve f f' i (Over.homMk q : Over.mk q ‚ü∂ Over.mk (ùüô (X i))) :=
  ‚ü®_, a, f' j, ‚ü®j‚ü©, fac‚ü©

namespace sieve

variable {i : Œπ} {Z : C} {q : Z ‚ü∂ X i}
  (hq : sieve f f' i (Over.homMk q : Over.mk q ‚ü∂ Over.mk (ùüô X i)))

include hq in
lemma exists_fac : ‚àÉ (j : Œπ') (a : Z ‚ü∂ X' j), a ‚â´ f' j = q ‚â´ f i := by
  obtain ‚ü®_, q, _, ‚ü®j‚ü©, fac‚ü© := hq
  exact ‚ü®j, q, fac‚ü©

/-- If a morphism `q : Z ‚ü∂ X i` belongs to `sieve f f' i`, this is a choice of
index `j` such that there exists a factorization `a ‚â´ f' j = q ‚â´ f i` for
some `a`. -/
noncomputable def idx : Œπ' := (exists_fac hq).choose

/-- If a morphism `q : Z ‚ü∂ X i` belongs to `sieve f f' i`, this is a choice of
of a morphism `a : Z ‚ü∂ X' j` for some `j` such that `a ‚â´ f' j = q ‚â´ f i`. -/
noncomputable def a : Z ‚ü∂ X' (idx hq) := (exists_fac hq).choose_spec.choose

@[reassoc]
lemma fac : a hq ‚â´ f' (idx hq) = q ‚â´ f i := (exists_fac hq).choose_spec.choose_spec

end sieve
/-- Given two family of morphisms `f : X i ‚ü∂ S` and `f' : X' j ‚ü∂ S`,
two objects `D‚ÇÅ D‚ÇÇ : F.DescentData f`, a morphism `œÜ` between the images in
`F.DescentData f'` of `D‚ÇÅ` and `D‚ÇÇ` by a functor `pullFunctor`, and a factorization
`a ‚â´ f' j = q ‚â´ f i`, this is the section on `Over.mk q` of the presheaf
of morphisms from `D‚ÇÅ.obj i` to `D‚ÇÇ.obj i` that is obtained by pulling back `œÜ.hom j`. -/
def mor ‚¶Éi : Œπ‚¶Ñ {Z : C} (q : Z ‚ü∂ X i) ‚¶Éj : Œπ'‚¶Ñ (a : Z ‚ü∂ X' j)
    (fac : a ‚â´ f' j = q ‚â´ f i) :
    (F.presheafHom (D‚ÇÅ.obj i) (D‚ÇÇ.obj i)).obj (op (Over.mk q)) :=
  D‚ÇÅ.hom (q ‚â´ f i) q (a ‚â´ p' j) ‚â´ pullHom (œÜ.hom j) a _ _ ‚â´ D‚ÇÇ.hom (q ‚â´ f i) (a ‚â´ p' j) q

lemma mor_eq ‚¶Éi : Œπ‚¶Ñ {Z : C} (q : Z ‚ü∂ X i) ‚¶Éj : Œπ'‚¶Ñ (a : Z ‚ü∂ X' j)
    (fac : a ‚â´ f' j = q ‚â´ f i) (q' : Z ‚ü∂ S) (hq' : q ‚â´ f i = q')
    (a' : Z ‚ü∂ X (Œ± j)) (ha' : a ‚â´ p' j = a') :
    mor w œÜ q a fac =
      D‚ÇÅ.hom q' q a' ‚â´ pullHom (œÜ.hom j) a _ _ ‚â´ D‚ÇÇ.hom q' a' q := by
  subst hq' ha'
  rfl

include w œÜ in
lemma mor_precomp ‚¶Éi : Œπ‚¶Ñ {Z : C} (q : Z ‚ü∂ X i) ‚¶Éj : Œπ'‚¶Ñ (a : Z ‚ü∂ X' j)
    (fac : a ‚â´ f' j = q ‚â´ f i) {Z' : C} (r : Z' ‚ü∂ Z)
    (r' : Z' ‚ü∂ X i) (hr' : r ‚â´ q = r')
    (a' : Z' ‚ü∂ X' j) (ha' : r ‚â´ a = a') :
    mor w œÜ r' a' (by cat_disch) =
      (F.presheafHom (D‚ÇÅ.obj i) (D‚ÇÇ.obj i)).map (Over.homMk r).op (mor w œÜ q a fac) := by
  dsimp
  rw [mor_eq _ _ _ _ _ (r ‚â´ q ‚â´ f i) (by cat_disch) (r ‚â´ a ‚â´ p' j) (by cat_disch),
    mor_eq _ _ _ _ _ _ rfl _ rfl,
    ‚Üê D‚ÇÅ.pullHom_hom r (q ‚â´ f i) _ rfl q (a ‚â´ p' j) rfl (by cat_disch) r' _ hr' rfl,
    ‚Üê D‚ÇÇ.pullHom_hom r (q ‚â´ f i) _ rfl (a ‚â´ p' j) q (by cat_disch) rfl _ r' rfl hr']
  have := F.mapComp'_naturality_2 a.op.toLoc r.op.toLoc a'.op.toLoc (by cat_disch) (œÜ.hom j)
  dsimp [pullHom] at this ‚ä¢
  simp only [Category.assoc, Functor.map_comp, ‚Üê this,
    Cat.Hom.inv_hom_id_toNatTrans_app_assoc,
    mapComp'‚ÇÄ‚ÇÅ‚ÇÉ_hom_comp_whiskerLeft_mapComp'_hom_app_assoc F
    (p' j).op.toLoc a.op.toLoc r.op.toLoc ((p' j).op.toLoc ‚â´ a.op.toLoc) a'.op.toLoc
      (((p' j).op.toLoc ‚â´ a.op.toLoc) ‚â´ r.op.toLoc) rfl (by grind) (by grind),
    ‚Üê mapComp'_inv_whiskerRight_mapComp'‚ÇÄ‚ÇÇ‚ÇÉ_inv_app_assoc F
    (p' j).op.toLoc a.op.toLoc r.op.toLoc ((p' j).op.toLoc ‚â´ a.op.toLoc) a'.op.toLoc
      (((p' j).op.toLoc ‚â´ a.op.toLoc) ‚â´ r.op.toLoc) rfl (by grind) (by grind)]

lemma mor_unique ‚¶Éi : Œπ‚¶Ñ {Z : C} (q : Z ‚ü∂ X i)
    ‚¶Éj‚ÇÅ : Œπ'‚¶Ñ (a‚ÇÅ : Z ‚ü∂ X' j‚ÇÅ) (fac‚ÇÅ : a‚ÇÅ ‚â´ f' j‚ÇÅ = q ‚â´ f i)
    ‚¶Éj‚ÇÇ : Œπ'‚¶Ñ (a‚ÇÇ : Z ‚ü∂ X' j‚ÇÇ) (fac‚ÇÇ : a‚ÇÇ ‚â´ f' j‚ÇÇ = q ‚â´ f i) :
    mor w œÜ q a‚ÇÅ fac‚ÇÅ = mor w œÜ q a‚ÇÇ fac‚ÇÇ := by
  have := œÜ.comm (q ‚â´ f i) a‚ÇÅ a‚ÇÇ fac‚ÇÅ fac‚ÇÇ
  dsimp at this
  rw [pullFunctorObjHom_eq _ _ _ _ _ (q ‚â´ f i) (a‚ÇÅ ‚â´ p' j‚ÇÅ) (a‚ÇÇ ‚â´ p' j‚ÇÇ) rfl,
    pullFunctorObjHom_eq _ _ _ _ _ (q ‚â´ f i) (a‚ÇÅ ‚â´ p' j‚ÇÅ) (a‚ÇÇ ‚â´ p' j‚ÇÇ) rfl,
    map_eq_pullHom _ _ _ _ (by exact rfl) rfl, map_eq_pullHom _ _ _ _ rfl rfl] at this
  dsimp at this
  simp only [Category.assoc, Cat.Hom.hom_inv_id_toNatTrans_app_assoc, cancel_epi] at this
  simp only [‚Üê Category.assoc, cancel_mono] at this
  rw [‚Üê cancel_mono (D‚ÇÇ.hom (q ‚â´ f i) (a‚ÇÇ ‚â´ p' j‚ÇÇ) q), Category.assoc,
    D‚ÇÇ.hom_comp] at this
  rw [mor_eq _ _ _ _ _ _ rfl _ rfl, mor_eq _ _ _ _ _ _ rfl _ rfl, this]
  simp

/-- Given two family of morphisms `f : X i ‚ü∂ S` and `f' : X' j ‚ü∂ S`,
two objects `D‚ÇÅ D‚ÇÇ : F.DescentData f`, a morphism `œÜ` between the images in
`F.DescentData f'` of `D‚ÇÅ` and `D‚ÇÇ` by a functor `pullFunctor`. This is
a family of elements of the sheaf of morphisms from `D‚ÇÅ.obj i` to `D‚ÇÇ.obj i`
that is deduced from `œÜ` over a covering sieve. See `hom` below for the glued
morphism `D‚ÇÅ.obj i ‚ü∂ D‚ÇÇ.obj i` when `f'` is a covering family and `F` is a prestack. -/
noncomputable def familyOfElements (i : Œπ) :
    Presieve.FamilyOfElements (F.presheafHom (D‚ÇÅ.obj i) (D‚ÇÇ.obj i)) (sieve f f' i).arrows :=
  fun Z q hq ‚Ü¶
    mor w œÜ _ _ (sieve.fac (f := f) (f' := f') (q := Z.hom) (by
      convert hq
      ext
      simpa using (Over.w q).symm))

lemma familyOfElements_eq {i : Œπ} {Z : Over (X i)} (g : Z ‚ü∂ Over.mk (ùüô (X i)))
    ‚¶Éj : Œπ'‚¶Ñ (a : Z.left ‚ü∂ X' j) (fac : a ‚â´ f' j = Z.hom ‚â´ f i) :
    familyOfElements w œÜ i g (by
      rw [show g = Over.homMk Z.hom by ext; simpa using Over.w g]
      exact mem_sieve _ _ fac) = mor w œÜ _ _ fac :=
  mor_unique _ _ _ _ _ _ _

lemma compatible_familyOfElements (i : Œπ) :
    (familyOfElements w œÜ i).Compatible := by
  intro Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ fac
  obtain rfl : f‚ÇÅ = Over.homMk Y‚ÇÅ.hom := by ext; simpa using Over.w f‚ÇÅ
  obtain rfl : f‚ÇÇ = Over.homMk Y‚ÇÇ.hom := by ext; simpa using Over.w f‚ÇÇ
  obtain ‚ü®g‚ÇÅ, hg‚ÇÅ, rfl‚ü© := Over.homMk_surjective g‚ÇÅ
  obtain ‚ü®g‚ÇÇ, hg‚ÇÇ, rfl‚ü© := Over.homMk_surjective g‚ÇÇ
  obtain ‚ü®_, a‚ÇÅ, _, ‚ü®j‚ÇÅ‚ü©, fac‚ÇÅ‚ü© := h‚ÇÅ
  obtain ‚ü®_, a‚ÇÇ, _, ‚ü®j‚ÇÇ‚ü©, fac‚ÇÇ‚ü© := h‚ÇÇ
  dsimp at a‚ÇÅ a‚ÇÇ fac‚ÇÅ fac‚ÇÇ
  rw [familyOfElements_eq _ _ _ _ fac‚ÇÅ, familyOfElements_eq _ _ _ _ fac‚ÇÇ,
    ‚Üê mor_precomp w œÜ Y‚ÇÅ.hom a‚ÇÅ fac‚ÇÅ _ _ hg‚ÇÅ _ rfl,
    ‚Üê mor_precomp w œÜ Y‚ÇÇ.hom a‚ÇÇ fac‚ÇÇ _ _ hg‚ÇÇ _ rfl]
  apply mor_unique

include hf' in
/-- Given two family of morphisms `f : X i ‚ü∂ S` and `f' : X' j ‚ü∂ S`,
two objects `D‚ÇÅ D‚ÇÇ : F.DescentData f`, a morphism `œÜ` between the images in
`F.DescentData f'` of `D‚ÇÅ` and `D‚ÇÇ` by a functor `pullFunctor`. When `F`
is a prestack and `f'` a covering family, this is the morphism `D‚ÇÅ.obj i ‚ü∂ D‚ÇÇ.obj i`
that is deduced from `œÜ` by gluing. -/
noncomputable def hom (i : Œπ) : D‚ÇÅ.obj i ‚ü∂ D‚ÇÇ.obj i :=
  F.presheafHomObjHomEquiv.symm
    (Presieve.IsSheafFor.amalgamate (Presieve.IsSheaf.isSheafFor _
    ((isSheaf_iff_isSheaf_of_type _ _).1 (IsPrestack.isSheaf J _ _)) _
      (by simpa using sieve_mem _ hf' i)) _
        (compatible_familyOfElements w œÜ i))

lemma map_hom ‚¶Éi : Œπ‚¶Ñ ‚¶ÉY : C‚¶Ñ (q : Y ‚ü∂ X i) ‚¶Éj : Œπ'‚¶Ñ
    (a : Y ‚ü∂ X' j) (fac : a ‚â´ f' j = q ‚â´ f i) :
    (F.map q.op.toLoc).toFunctor.map (hom w hf' œÜ i) = mor w œÜ q a fac := by
  let s := Presieve.IsSheafFor.amalgamate (Presieve.IsSheaf.isSheafFor _
    ((isSheaf_iff_isSheaf_of_type _ _).1 (IsPrestack.isSheaf J _ _)) _
      (by simpa using sieve_mem _ hf' i)) _
        (compatible_familyOfElements w œÜ i)
  have hs : (familyOfElements w œÜ i).IsAmalgamation s :=
    Presieve.IsSheafFor.isAmalgamation (Presieve.IsSheaf.isSheafFor _
      ((isSheaf_iff_isSheaf_of_type _ _).1 (IsPrestack.isSheaf J _ _)) _
        (by simpa using sieve_mem _ hf' i)) (compatible_familyOfElements w œÜ i)
  change (F.map q.op.toLoc).toFunctor.map (F.presheafHomObjHomEquiv.symm s) = _
  simpa [familyOfElements_eq w œÜ (Z := Over.mk q) _ a fac,
    presheafHomObjHomEquiv, pullHom, mapComp'_id_comp_hom_app,
    mapComp'_id_comp_inv_app] using hs _ (mem_sieve _ _ fac)

@[reassoc]
lemma comm ‚¶ÉW : C‚¶Ñ (q : W ‚ü∂ S) ‚¶Éi‚ÇÅ i‚ÇÇ : Œπ‚¶Ñ
    (f‚ÇÅ : W ‚ü∂ X i‚ÇÅ) (f‚ÇÇ : W ‚ü∂ X i‚ÇÇ) (hf‚ÇÅ : f‚ÇÅ ‚â´ f i‚ÇÅ = q) (hf‚ÇÇ : f‚ÇÇ ‚â´ f i‚ÇÇ = q) :
    (F.map f‚ÇÅ.op.toLoc).toFunctor.map (hom w hf' œÜ i‚ÇÅ) ‚â´ D‚ÇÇ.hom q f‚ÇÅ f‚ÇÇ =
    D‚ÇÅ.hom q f‚ÇÅ f‚ÇÇ ‚â´ (F.map f‚ÇÇ.op.toLoc).toFunctor.map (hom w hf' œÜ i‚ÇÇ) := by
  rw [‚Üê cancel_mono (D‚ÇÇ.hom q f‚ÇÇ f‚ÇÅ), Category.assoc,
    Category.assoc, DescentData.hom_comp, D‚ÇÇ.hom_self _ _ hf‚ÇÅ, Category.comp_id]
  have H : (Sieve.overEquiv (Over.mk f‚ÇÅ)).symm
      (Sieve.pullback q (Sieve.ofArrows X' f')) ‚àà J.over _ _ := by
    rw [J.mem_over_iff, Equiv.apply_symm_apply]
    exact J.pullback_stable _ hf'
  refine ((isSheaf_iff_isSheaf_of_type _ _).1
    (IsPrestack.isSheaf J (D‚ÇÅ.obj i‚ÇÅ) (D‚ÇÇ.obj i‚ÇÅ)) _ H).isSeparatedFor.ext ?_
  rintro T p ‚ü®_, g, _, ‚ü®j‚ü©, fac‚ü©
  obtain ‚ü®T, t, rfl‚ü© := T.mk_surjective
  obtain ‚ü®p, hp, rfl‚ü© := Over.homMk_surjective p
  dsimp [pullHom] at t g p hp fac ‚ä¢
  subst hp
  simp only [mapComp'_inv_naturality, Cat.Hom.comp_toFunctor, Functor.comp_obj,
    Cat.Hom.hom_inv_id_toNatTrans_app_assoc, Functor.map_comp, Category.assoc]
  rw [‚Üê F.mapComp'_naturality_1 f‚ÇÇ.op.toLoc p.op.toLoc (p ‚â´ f‚ÇÇ).op.toLoc (by grind),
    map_hom _ _ _ _ g (by grind), map_hom _ _ _ _ g (by grind),
    mor_eq _ _ _ _ (by grind) (p ‚â´ q) (by grind) _ rfl,
    mor_eq _ _ _ _ (by grind) (p ‚â´ q) (by grind) _ rfl,
    map_eq_pullHom _ _ _ _ rfl rfl, map_eq_pullHom _ _ _ _ rfl rfl,
    pullHom_hom _ _ _ _ rfl _ _ hf‚ÇÅ hf‚ÇÇ _ _ rfl rfl,
    pullHom_hom _ _ _ _ rfl _ _ hf‚ÇÇ hf‚ÇÅ _ _ rfl rfl]
  simp

end full_pullFunctor

open full_pullFunctor in
include w hf' in
lemma full_pullFunctor :
    (pullFunctor F (f := f) (p := ùüô _) (f' := f') (p' := p') (by cat_disch)).Full where
  map_surjective {D‚ÇÅ D‚ÇÇ} œÜ :=
    ‚ü®{ hom := fun i ‚Ü¶ hom w hf' œÜ i, comm := comm _ _ _ }, by
      ext i
      dsimp
      rw [map_hom _ _ _ _ (ùüô _) (by cat_disch),
        mor_eq _ _ _ _ _ (f' i) (by cat_disch) (p' i) (by simp), pullHom_id,
        D‚ÇÅ.hom_self _ _ (by cat_disch), D‚ÇÇ.hom_self _ _ (by cat_disch),
        Category.id_comp, Category.comp_id]‚ü©

/-- Let `F` be a prestack for a Grothendieck topology `J`,
`f : X i ‚ü∂ S` and `f' : X' j ‚ü∂ S` be two families of morphisms.
Assume that `f'` is a covering family for `J`, then
functors `F.pullFunctor .. : F.DescentData f ‚•§ F.DescentData f'`
are fully faithful. -/
noncomputable def fullyFaithfulPullFunctor :
    (pullFunctor F (f := f) (p := ùüô _) (f' := f') (p' := p') (by cat_disch)).FullyFaithful := by
  have := F.faithful_pullFunctor w hf'
  have := F.full_pullFunctor w hf'
  exact .ofFullyFaithful _

lemma isEquivalence_toDescentData_of_sieve_le
    (h‚ÇÅ : Sieve.ofArrows _ f' ‚àà J _)
    (h‚ÇÇ : Sieve.ofArrows _ f' ‚â§ Sieve.ofArrows _ f)
    [(F.toDescentData f').IsEquivalence] :
    (F.toDescentData f).IsEquivalence := by
  let H (i' : Œπ') : ‚àÉ (i : Œπ) (p : X' i' ‚ü∂ X i), p ‚â´ f i = f' i' := by
    obtain ‚ü®_, p, _, ‚ü®i‚ü©, fac‚ü© := h‚ÇÇ _ (Sieve.ofArrows_mk _ f' i')
    exact ‚ü®_, _, fac‚ü©
  choose Œ± p hp using H
  obtain ‚ü®H, h, ‚ü®e‚ü©‚ü© :
      ‚àÉ (H : _ ‚•§ _) (_ : H.FullyFaithful),
        Nonempty (F.toDescentData f ‚ãô H ‚âÖ F.toDescentData f') := by
    refine ‚ü®pullFunctor F (p := ùüô _) (p' := p) (by cat_disch), ?_, ?_‚ü©
    ¬∑ refine F.fullyFaithfulPullFunctor hp h‚ÇÅ
    ¬∑ exact ‚ü®toDescentDataCompPullFunctorIso _ _ ‚â™‚â´
          (Functor.isoWhiskerRight (Cat.Hom.toNatIso (F.mapId _)) _) ‚â™‚â´
            Functor.leftUnitor _‚ü©
  have := (F.fullyFaithfulToDescentData _ (J.superset_covering h‚ÇÇ h‚ÇÅ)).faithful
  have := (F.fullyFaithfulToDescentData _ (J.superset_covering h‚ÇÇ h‚ÇÅ)).full
  have : (F.toDescentData f).EssSurj := ‚ü®fun D ‚Ü¶
    ‚ü®_, ‚ü®h.preimageIso (e.app _ ‚â™‚â´ (F.toDescentData f').objObjPreimageIso (H.obj D))‚ü©‚ü©‚ü©
  exact { }

end

/-- If `F` is a prestack for a Grothendieck topology `J` and `F` is a stack
for a covering presieve `R`, then it is also a stack for `R'` if `R ‚â§ R'`. -/
lemma IsStackFor.of_le {S : C} {R : Presieve S}
    (hR‚ÇÅ : F.IsStackFor R) {J : GrothendieckTopology C}
    (hR‚ÇÇ : Sieve.generate R ‚àà J S) [F.IsPrestack J] {R' : Presieve S} (h : R ‚â§ R') :
    F.IsStackFor R' := by
  obtain ‚ü®Œπ, _, f, rfl‚ü© := R.exists_eq_ofArrows
  obtain ‚ü®Œπ', _, f', rfl‚ü© := R'.exists_eq_ofArrows
  rw [isStackFor_ofArrows_iff] at hR‚ÇÅ ‚ä¢
  exact isEquivalence_toDescentData_of_sieve_le _ hR‚ÇÇ (Sieve.generate_mono h)

/-- If `F` is a prestack for a Grothendieck topology `J` and `F` is a stack
for a covering sieve `R`, then it is also a stack for `R'` if `R ‚â§ R'`. -/
lemma IsStackFor.of_le' {S : C} {R : Sieve S}
    (hR‚ÇÅ : F.IsStackFor R.arrows) {J : GrothendieckTopology C}
    (hR‚ÇÇ : R ‚àà J S) [F.IsPrestack J] {R' : Sieve S} (h : R ‚â§ R') :
    F.IsStackFor R'.arrows :=
  hR‚ÇÅ.of_le _ (by simpa) h

section

variable {F} [HasPullbacks C] {J : Precoverage C}
  [J.HasIsos] [J.IsStableUnderBaseChange] [J.IsStableUnderComposition]

/-- If a precoverage satisfies `HasIsos`, `IsStableUnderBaseChange` and
`IsStableUnderComposition` (which is a slightly stronger condition as compared
to pretopologies), then in order to check that a pseudofunctor is a prestack
it suffices to check that it is a prestack for the presieves that are
part of the precoverage. -/
lemma IsPrestack.of_precoverage
    (hF : ‚àÄ (S : C) (R : Presieve S) (_ : R ‚àà J.coverings S), F.IsPrestackFor R) :
    F.IsPrestack J.toGrothendieck where
  isSheaf {S} M N := by
    rw [isSheaf_iff_isSheaf_of_type,
      over_toGrothendieck_eq_toGrothendieck_comap_forget,
      ‚Üê Precoverage.toGrothendieck_toPretopology,
      Presieve.isSheaf_pretopology]
    intro X R hR
    simp only [Precoverage.toPretopology_toPrecoverage, Precoverage.mem_comap_iff,
      Over.forget_obj] at hR
    obtain ‚ü®R', hR'‚ü© := (Sieve.overEquiv _).symm.surjective (Sieve.generate R)
    rw [Presieve.isSheafFor_iff_generate]
    apply IsPrestackFor.isSheafFor'
    simpa [Sieve.overEquiv_generate, Presieve.functorPushforward_overForget]
      using hF _ _ hR

/-- If a precoverage satisfies `HasIsos`, `IsStableUnderBaseChange` and
`IsStableUnderComposition` (which is a slightly stronger condition as compared
to pretopologies), then in order to check that a pseudofunctor is a stack
it suffices to check that it is a stack for the presieves that are
part of the precoverage. -/
lemma IsStack.of_precoverage
    (hF : ‚àÄ (S : C) (R : Presieve S) (_ : R ‚àà J.coverings S), F.IsStackFor R) :
    F.IsStack J.toGrothendieck := by
  have := IsPrestack.of_precoverage (fun S R hR ‚Ü¶ (hF _ _ hR).isPrestackFor)
  refine ‚ü®fun {S} R hR ‚Ü¶ IsStackFor.essSurj ?_‚ü©
  rw [‚Üê J.toGrothendieck_toPretopology] at hR
  obtain ‚ü®R', hR', h‚ü© := hR
  dsimp at hR'
  exact (hF _ _ hR').of_le _ (Precoverage.generate_mem_toGrothendieck hR') h

end

end Pseudofunctor

end CategoryTheory
