/-
Copyright (c) 2025 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
module

public import Mathlib.CategoryTheory.Sites.Descent.IsStack

/-!
# Characterization of (pre)stacks for a precoverage

Let `F : LocallyDiscrete C·µí·µñ ‚•§·µñ Cat` be a pseudofunctor.
Assuming `F` is a prestack for a Grothendieck topology `J`,
we show that if `f : X i ‚ü∂ S` and `f' : X' j ‚ü∂ S` are two covering
families of morphisms in `S` such that the sieve generated by `f'` is
contained in the sieve generated by `f`, then the functor
`F.DescentData f ‚•§ F.DescentData f'` is fully faithful.
It follows that if the descent is effective for the family `f'`,
then it is also effective for the family `f`.

Now, assume that `J` is a precoverage on `C` which satisfies slightly
stronger axioms than pretopologies (`HasIsos`, `J.IsStableUnderBaseChange`,
and `J.IsStableUnderComposition`). We deduce from the
results above that `F` is a prestack (resp. a stack) for the
Grothendieck topology associated to `J` if the functors
`F.toDescentData f` attached to presieves in `J` are
fully faithful (resp. equivalences).

-/

@[expose] public section

universe t t' v' v u' u

namespace CategoryTheory

lemma Over.mk_surjective {C : Type*} [Category* C] {S : C} (X : Over S) :
    ‚àÉ (Y : C) (f : Y ‚ü∂ S), X = Over.mk f :=
  ‚ü®_, X.hom, rfl‚ü©

lemma _root_.CategoryTheory.Over.homMk_surjective {C : Type*} [Category* C]
    {S : C} {X Y : Over S} (f : X ‚ü∂ Y) :
    ‚àÉ (g : X.left ‚ü∂ Y.left) (hg : g ‚â´ Y.hom = X.hom), f = Over.homMk g :=
  ‚ü®f.left, by simp‚ü©

open Limits Opposite Bicategory

namespace Pseudofunctor

open DescentData LocallyDiscreteOpToCat

variable {C : Type u} [Category.{v} C] (F : LocallyDiscrete C·µí·µñ ‚•§·µñ Cat.{v', u'})

section

variable {J : GrothendieckTopology C} [F.IsPrestack J]

variable {Œπ : Type t} {S : C} {X : Œπ ‚Üí C} {f : ‚àÄ i, X i ‚ü∂ S}
  {Œπ' : Type t'} {X' : Œπ' ‚Üí C} {f' : ‚àÄ j, X' j ‚ü∂ S}
  {Œ± : Œπ' ‚Üí Œπ} {p' : ‚àÄ j, X' j ‚ü∂ X (Œ± j)} (w : ‚àÄ j, p' j ‚â´ f (Œ± j) = f' j)
  (hf' : Sieve.ofArrows _ f' ‚àà J S)

include hf' in
lemma faithful_pullFunctor :
    (pullFunctor F (f := f) (p := ùüô _) (f' := f') (p' := p') (by cat_disch)).Faithful where
  map_injective {D‚ÇÅ D‚ÇÇ œÜ œÜ'} hœÜ := by
    ext i
    refine F.presheafHomObjHomEquiv.injective ?_i
    have : (Sieve.overEquiv (Over.mk (ùüô (X i)))).symm
      (Sieve.pullback (f i) (Sieve.ofArrows X' f')) ‚àà J.over (X i) _ := by
      simpa only [J.mem_over_iff, Equiv.apply_symm_apply] using J.pullback_stable (f i) hf'
    refine (((isSheaf_iff_isSheaf_of_type _ _).1
      (IsPrestack.isSheaf _ _ _)).isSeparated _ this).ext ?_
    rintro Z g ‚ü®Y, p, c, ‚ü®j‚ü©, hp‚ü©
    dsimp at p hp
    have : g.left = Z.hom := by simpa using Over.w g
    have (œà : D‚ÇÅ ‚ü∂ D‚ÇÇ) :
      (F.presheafHom _ _).map g.op (F.presheafHomObjHomEquiv (œà.hom i)) =
        D‚ÇÅ.hom (Z.hom ‚â´ f i) Z.hom (p ‚â´ p' j) ‚â´
          pullHom ((F.map (p' j).op.toLoc).toFunctor.map (œà.hom (Œ± j))) p _ _ ‚â´
          D‚ÇÇ.hom (Z.hom ‚â´ f i) (p ‚â´ p' j) Z.hom := by
      obtain rfl : g = Over.homMk Z.hom := by cat_disch
      have := œà.comm _ Z.hom (p ‚â´ p' j) rfl (by grind)
      dsimp [presheafHomObjHomEquiv, pullHom] at this ‚ä¢
      simp [mapComp'_inv_naturality, Cat.Hom.comp_toFunctor,
        Functor.comp_obj, Cat.Hom.hom_inv_id_toNatTrans_app_assoc, ‚Üê reassoc_of% this,
        D‚ÇÇ.hom_self _ _ rfl, F.mapComp'_id_comp_inv_app, ‚Üê Functor.map_comp,
        F.mapComp'_id_comp_hom_app_assoc]
    replace hœÜ := congr_fun (congr_arg DescentData.Hom.hom hœÜ) j
    dsimp at hœÜ
    simp only [this, hœÜ]

namespace full_pullFunctor

variable {F} {D‚ÇÅ D‚ÇÇ : F.DescentData f}
  (œÜ : (pullFunctor F (p := ùüô _) (f' := f') (p' := p') (by cat_disch)).obj D‚ÇÅ ‚ü∂
    (pullFunctor F (p := ùüô _) (f' := f') (p' := p') (by cat_disch)).obj D‚ÇÇ)

variable (f f') in
abbrev sieve (i : Œπ) : Sieve (Over.mk (ùüô (X i))) :=
  (Sieve.overEquiv (Over.mk (ùüô (X i)))).symm
    (Sieve.pullback (f i) (Sieve.ofArrows X' f'))

include hf' in
variable (f) in
lemma sieve_mem (i : Œπ) : sieve f f' i ‚àà J.over _ _ := by
  simpa only [J.mem_over_iff, Equiv.apply_symm_apply] using J.pullback_stable (f i) hf'

lemma mem_sieve {i : Œπ} {Z : C} (q : Z ‚ü∂ X i) ‚¶Éj : Œπ'‚¶Ñ (a : Z ‚ü∂ X' j)
    (fac : a ‚â´ f' j = q ‚â´ f i) :
    sieve f f' i (Over.homMk q : Over.mk q ‚ü∂ Over.mk (ùüô (X i))) :=
  ‚ü®_, a, f' j, ‚ü®j‚ü©, fac‚ü©

namespace sieve

variable {i : Œπ} {Z : C} {q : Z ‚ü∂ X i}
  (hq : sieve f f' i (Over.homMk q : Over.mk q ‚ü∂ Over.mk (ùüô X i)))

include hq in
lemma exists_fac : ‚àÉ (j : Œπ') (a : Z ‚ü∂ X' j), a ‚â´ f' j = q ‚â´ f i := by
  obtain ‚ü®_, q, _, ‚ü®j‚ü©, fac‚ü© := hq
  exact ‚ü®j, q, fac‚ü©

noncomputable def idx : Œπ' := (exists_fac hq).choose

noncomputable def a : Z ‚ü∂ X' (idx hq) := (exists_fac hq).choose_spec.choose

lemma fac : (a hq) ‚â´ f' (idx hq) = q ‚â´ f i := (exists_fac hq).choose_spec.choose_spec

end sieve

def mor ‚¶Éi : Œπ‚¶Ñ {Z : C} (q : Z ‚ü∂ X i) ‚¶Éj : Œπ'‚¶Ñ (a : Z ‚ü∂ X' j)
    (fac : a ‚â´ f' j = q ‚â´ f i) :
    (presheafHom F (D‚ÇÅ.obj i) (D‚ÇÇ.obj i)).obj (op (Over.mk q)) :=
  D‚ÇÅ.hom (q ‚â´ f i) q (a ‚â´ p' j) ‚â´ pullHom (œÜ.hom j) a _ _ ‚â´ D‚ÇÇ.hom (q ‚â´ f i) (a ‚â´ p' j) q

lemma mor_eq ‚¶Éi : Œπ‚¶Ñ {Z : C} (q : Z ‚ü∂ X i) ‚¶Éj : Œπ'‚¶Ñ (a : Z ‚ü∂ X' j)
    (fac : a ‚â´ f' j = q ‚â´ f i) (q' : Z ‚ü∂ S) (hq' : q ‚â´ f i = q')
    (a' : Z ‚ü∂ X (Œ± j)) (ha' : a ‚â´ p' j = a') :
    mor w œÜ q a fac =
      D‚ÇÅ.hom q' q a' ‚â´ pullHom (œÜ.hom j) a _ _ ‚â´ D‚ÇÇ.hom q' a' q := by
  subst hq' ha'
  rfl

include w œÜ in
lemma mor_precomp ‚¶Éi : Œπ‚¶Ñ {Z : C} (q : Z ‚ü∂ X i) ‚¶Éj : Œπ'‚¶Ñ (a : Z ‚ü∂ X' j)
    (fac : a ‚â´ f' j = q ‚â´ f i) {Z' : C} (r : Z' ‚ü∂ Z)
    (r' : Z' ‚ü∂ X i) (hr' : r ‚â´ q = r')
    (a' : Z' ‚ü∂ X' j) (ha' : r ‚â´ a = a') :
    mor w œÜ r' a' (by cat_disch) =
      (presheafHom F (D‚ÇÅ.obj i) (D‚ÇÇ.obj i)).map (Over.homMk r).op (mor w œÜ q a fac) := by
  dsimp
  rw [mor_eq _ _ _ _ _ (r ‚â´ q ‚â´ f i) (by cat_disch) (r ‚â´ a ‚â´ p' j) (by cat_disch),
    mor_eq _ _ _ _ _ _ rfl _ rfl,
    ‚Üê D‚ÇÅ.pullHom_hom r (q ‚â´ f i) _ rfl q (a ‚â´ p' j) rfl (by cat_disch) r' _ hr' rfl,
    ‚Üê D‚ÇÇ.pullHom_hom r (q ‚â´ f i) _ rfl (a ‚â´ p' j) q (by cat_disch) rfl _ r' rfl hr']
  have := F.mapComp'_naturality_2 a.op.toLoc r.op.toLoc a'.op.toLoc (by cat_disch) (œÜ.hom j)
  dsimp [pullHom] at this ‚ä¢
  simp only [Category.assoc, Functor.map_comp, ‚Üê this,
    Cat.Hom.inv_hom_id_toNatTrans_app_assoc,
    mapComp'‚ÇÄ‚ÇÅ‚ÇÉ_hom_comp_whiskerLeft_mapComp'_hom_app_assoc F
    (p' j).op.toLoc a.op.toLoc r.op.toLoc ((p' j).op.toLoc ‚â´ a.op.toLoc) a'.op.toLoc
      (((p' j).op.toLoc ‚â´ a.op.toLoc) ‚â´ r.op.toLoc) rfl (by grind) (by grind),
    ‚Üê mapComp'_inv_whiskerRight_mapComp'‚ÇÄ‚ÇÇ‚ÇÉ_inv_app_assoc F
    (p' j).op.toLoc a.op.toLoc r.op.toLoc ((p' j).op.toLoc ‚â´ a.op.toLoc) a'.op.toLoc
      (((p' j).op.toLoc ‚â´ a.op.toLoc) ‚â´ r.op.toLoc) rfl (by grind) (by grind)]

lemma mor_unique ‚¶Éi : Œπ‚¶Ñ {Z : C} (q : Z ‚ü∂ X i)
    ‚¶Éj‚ÇÅ : Œπ'‚¶Ñ (a‚ÇÅ : Z ‚ü∂ X' j‚ÇÅ) (fac‚ÇÅ : a‚ÇÅ ‚â´ f' j‚ÇÅ = q ‚â´ f i)
    ‚¶Éj‚ÇÇ : Œπ'‚¶Ñ (a‚ÇÇ : Z ‚ü∂ X' j‚ÇÇ) (fac‚ÇÇ : a‚ÇÇ ‚â´ f' j‚ÇÇ = q ‚â´ f i) :
    mor w œÜ q a‚ÇÅ fac‚ÇÅ = mor w œÜ q a‚ÇÇ fac‚ÇÇ := by
  have := œÜ.comm (q ‚â´ f i) a‚ÇÅ a‚ÇÇ fac‚ÇÅ fac‚ÇÇ
  dsimp at this
  rw [pullFunctorObjHom_eq _ _ _ _ _ (q ‚â´ f i) (a‚ÇÅ ‚â´ p' j‚ÇÅ) (a‚ÇÇ ‚â´ p' j‚ÇÇ) rfl,
    pullFunctorObjHom_eq _ _ _ _ _ (q ‚â´ f i) (a‚ÇÅ ‚â´ p' j‚ÇÅ) (a‚ÇÇ ‚â´ p' j‚ÇÇ) rfl,
    map_eq_pullHom _ _ _ _ (by exact rfl) rfl, map_eq_pullHom _ _ _ _ rfl rfl] at this
  dsimp at this
  simp only [Category.assoc, Cat.Hom.hom_inv_id_toNatTrans_app_assoc, cancel_epi] at this
  simp only [‚Üê Category.assoc, cancel_mono] at this
  rw [‚Üê cancel_mono (D‚ÇÇ.hom (q ‚â´ f i) (a‚ÇÇ ‚â´ p' j‚ÇÇ) q), Category.assoc,
    D‚ÇÇ.hom_comp] at this
  rw [mor_eq _ _ _ _ _ _ rfl _ rfl, mor_eq _ _ _ _ _ _ rfl _ rfl, this]
  simp

noncomputable def familyOfElements (i : Œπ) :
    Presieve.FamilyOfElements (presheafHom F (D‚ÇÅ.obj i) (D‚ÇÇ.obj i)) (sieve f f' i).arrows :=
  fun Z q hq ‚Ü¶
    mor w œÜ _ _ (sieve.fac (f := f) (f' := f') (q := Z.hom) (by
      convert hq
      ext
      simpa using (Over.w q).symm))

lemma familyOfElements_eq {i : Œπ} {Z : Over (X i)} (g : Z ‚ü∂ Over.mk (ùüô (X i)))
    ‚¶Éj : Œπ'‚¶Ñ (a : Z.left ‚ü∂ X' j) (fac : a ‚â´ f' j = Z.hom ‚â´ f i) :
    familyOfElements w œÜ i g (by
      rw [show g = Over.homMk Z.hom by ext; simpa using Over.w g]
      exact mem_sieve _ _ fac) = mor w œÜ _ _ fac :=
  mor_unique _ _ _ _ _ _ _

lemma compatible_familyOfElements (i : Œπ) :
    (familyOfElements w œÜ i).Compatible := by
  intro Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ fac
  obtain rfl : f‚ÇÅ = Over.homMk Y‚ÇÅ.hom := by ext; simpa using Over.w f‚ÇÅ
  obtain rfl : f‚ÇÇ = Over.homMk Y‚ÇÇ.hom := by ext; simpa using Over.w f‚ÇÇ
  obtain ‚ü®g‚ÇÅ, hg‚ÇÅ, rfl‚ü© := Over.homMk_surjective g‚ÇÅ
  obtain ‚ü®g‚ÇÇ, hg‚ÇÇ, rfl‚ü© := Over.homMk_surjective g‚ÇÇ
  obtain ‚ü®_, a‚ÇÅ, _, ‚ü®j‚ÇÅ‚ü©, fac‚ÇÅ‚ü© := h‚ÇÅ
  obtain ‚ü®_, a‚ÇÇ, _, ‚ü®j‚ÇÇ‚ü©, fac‚ÇÇ‚ü© := h‚ÇÇ
  dsimp at a‚ÇÅ a‚ÇÇ fac‚ÇÅ fac‚ÇÇ
  rw [familyOfElements_eq _ _ _ _ fac‚ÇÅ, familyOfElements_eq _ _ _ _ fac‚ÇÇ,
    ‚Üê mor_precomp w œÜ Y‚ÇÅ.hom a‚ÇÅ fac‚ÇÅ _ _ hg‚ÇÅ _ rfl,
    ‚Üê mor_precomp w œÜ Y‚ÇÇ.hom a‚ÇÇ fac‚ÇÇ _ _ hg‚ÇÇ _ rfl]
  apply mor_unique

include hf' in
noncomputable def hom (i : Œπ) : D‚ÇÅ.obj i ‚ü∂ D‚ÇÇ.obj i :=
  F.presheafHomObjHomEquiv.symm
    (Presieve.IsSheafFor.amalgamate (Presieve.IsSheaf.isSheafFor _
    ((isSheaf_iff_isSheaf_of_type _ _).1 (IsPrestack.isSheaf J _ _)) _
      (by simpa using sieve_mem _ hf' i)) _
        (compatible_familyOfElements w œÜ i))

lemma map_hom ‚¶Éi : Œπ‚¶Ñ ‚¶ÉY : C‚¶Ñ (q : Y ‚ü∂ X i) ‚¶Éj : Œπ'‚¶Ñ
    (a : Y ‚ü∂ X' j) (fac : a ‚â´ f' j = q ‚â´ f i) :
    (F.map q.op.toLoc).toFunctor.map (hom w hf' œÜ i) = mor w œÜ q a fac := by
  let s := Presieve.IsSheafFor.amalgamate (Presieve.IsSheaf.isSheafFor _
    ((isSheaf_iff_isSheaf_of_type _ _).1 (IsPrestack.isSheaf J _ _)) _
      (by simpa using sieve_mem _ hf' i)) _
        (compatible_familyOfElements w œÜ i)
  have hs : (familyOfElements w œÜ i).IsAmalgamation s :=
    Presieve.IsSheafFor.isAmalgamation (Presieve.IsSheaf.isSheafFor _
      ((isSheaf_iff_isSheaf_of_type _ _).1 (IsPrestack.isSheaf J _ _)) _
        (by simpa using sieve_mem _ hf' i)) (compatible_familyOfElements w œÜ i)
  change (F.map q.op.toLoc).toFunctor.map (F.presheafHomObjHomEquiv.symm s) = _
  simpa [familyOfElements_eq w œÜ (Z := Over.mk q) _ a fac,
    presheafHomObjHomEquiv, pullHom, mapComp'_id_comp_hom_app,
    mapComp'_id_comp_inv_app] using hs _ (mem_sieve _ _ fac)

@[reassoc]
lemma comm ‚¶ÉW : C‚¶Ñ (q : W ‚ü∂ S) ‚¶Éi‚ÇÅ i‚ÇÇ : Œπ‚¶Ñ
    (f‚ÇÅ : W ‚ü∂ X i‚ÇÅ) (f‚ÇÇ : W ‚ü∂ X i‚ÇÇ) (hf‚ÇÅ : f‚ÇÅ ‚â´ f i‚ÇÅ = q) (hf‚ÇÇ : f‚ÇÇ ‚â´ f i‚ÇÇ = q) :
    (F.map f‚ÇÅ.op.toLoc).toFunctor.map (hom w hf' œÜ i‚ÇÅ) ‚â´ D‚ÇÇ.hom q f‚ÇÅ f‚ÇÇ =
    D‚ÇÅ.hom q f‚ÇÅ f‚ÇÇ ‚â´ (F.map f‚ÇÇ.op.toLoc).toFunctor.map (hom w hf' œÜ i‚ÇÇ) := by
  rw [‚Üê cancel_mono (D‚ÇÇ.hom q f‚ÇÇ f‚ÇÅ), Category.assoc,
    Category.assoc, DescentData.hom_comp, D‚ÇÇ.hom_self _ _ hf‚ÇÅ, Category.comp_id]
  have H : (Sieve.overEquiv (Over.mk f‚ÇÅ)).symm
      (Sieve.pullback q (Sieve.ofArrows X' f')) ‚àà J.over _ _ := by
    rw [J.mem_over_iff, Equiv.apply_symm_apply]
    exact J.pullback_stable _ hf'
  refine ((isSheaf_iff_isSheaf_of_type _ _).1
    (IsPrestack.isSheaf J (D‚ÇÅ.obj i‚ÇÅ) (D‚ÇÇ.obj i‚ÇÅ)) _ H).isSeparatedFor.ext ?_
  rintro T p ‚ü®_, g, _, ‚ü®j‚ü©, fac‚ü©
  obtain ‚ü®T, t, rfl‚ü© := T.mk_surjective
  obtain ‚ü®p, hp, rfl‚ü© := Over.homMk_surjective p
  dsimp [pullHom] at t g p hp fac ‚ä¢
  subst hp
  simp only [mapComp'_inv_naturality, Cat.Hom.comp_toFunctor, Functor.comp_obj,
    Cat.Hom.hom_inv_id_toNatTrans_app_assoc, Functor.map_comp, Category.assoc]
  rw [‚Üê F.mapComp'_naturality_1 f‚ÇÇ.op.toLoc p.op.toLoc (p ‚â´ f‚ÇÇ).op.toLoc (by grind),
    map_hom _ _ _ _ g (by grind), map_hom _ _ _ _ g (by grind),
    mor_eq _ _ _ _ (by grind) (p ‚â´ q) (by grind) _ rfl,
    mor_eq _ _ _ _ (by grind) (p ‚â´ q) (by grind) _ rfl,
    map_eq_pullHom _ _ _ _ rfl rfl, map_eq_pullHom _ _ _ _ rfl rfl,
    pullHom_hom _ _ _ _ rfl _ _ hf‚ÇÅ hf‚ÇÇ _ _ rfl rfl,
    pullHom_hom _ _ _ _ rfl _ _ hf‚ÇÇ hf‚ÇÅ _ _ rfl rfl]
  simp

end full_pullFunctor

open full_pullFunctor in
include w hf' in
lemma full_pullFunctor :
    (pullFunctor F (f := f) (p := ùüô _) (f' := f') (p' := p') (by cat_disch)).Full where
  map_surjective {D‚ÇÅ D‚ÇÇ} œÜ :=
    ‚ü®{ hom := fun i ‚Ü¶ hom w hf' œÜ i, comm := comm _ _ _ }, by
      ext i
      dsimp
      rw [map_hom _ _ _ _ (ùüô _) (by cat_disch),
        mor_eq _ _ _ _ _ (f' i) (by cat_disch) (p' i) (by simp), pullHom_id,
        D‚ÇÅ.hom_self _ _ (by cat_disch), D‚ÇÇ.hom_self _ _ (by cat_disch),
        Category.id_comp, Category.comp_id]‚ü©

noncomputable def fullyFaithfulPullFunctor :
    (pullFunctor F (f := f) (p := ùüô _) (f' := f') (p' := p') (by cat_disch)).FullyFaithful := by
  have := F.faithful_pullFunctor w hf'
  have := F.full_pullFunctor w hf'
  exact .ofFullyFaithful _

lemma isEquivalence_toDescentData_of_sieve_le
    (h‚ÇÅ : Sieve.ofArrows _ f' ‚àà J _)
    (h‚ÇÇ : Sieve.ofArrows _ f' ‚â§ Sieve.ofArrows _ f)
    [(F.toDescentData f').IsEquivalence] :
    (F.toDescentData f).IsEquivalence := by
  let H (i' : Œπ') : ‚àÉ (i : Œπ) (p : X' i' ‚ü∂ X i), p ‚â´ f i = f' i' := by
    obtain ‚ü®_, p, _, ‚ü®i‚ü©, fac‚ü© := h‚ÇÇ _ (Sieve.ofArrows_mk _ f' i')
    exact ‚ü®_, _, fac‚ü©
  choose Œ± p hp using H
  obtain ‚ü®H, h, ‚ü®e‚ü©‚ü© :
      ‚àÉ (H : _ ‚•§ _) (_ : H.FullyFaithful),
        Nonempty (F.toDescentData f ‚ãô H ‚âÖ F.toDescentData f') := by
    refine ‚ü®pullFunctor F (p := ùüô _) (p' := p) (by cat_disch), ?_, ?_‚ü©
    ¬∑ refine F.fullyFaithfulPullFunctor hp h‚ÇÅ
    ¬∑ exact ‚ü®toDescentDataCompPullFunctorIso _ _ ‚â™‚â´
          (Functor.isoWhiskerRight (Cat.Hom.toNatIso (F.mapId _)) _) ‚â™‚â´
            Functor.leftUnitor _‚ü©
  have := (F.fullyFaithfulToDescentData _ (J.superset_covering h‚ÇÇ h‚ÇÅ)).faithful
  have := (F.fullyFaithfulToDescentData _ (J.superset_covering h‚ÇÇ h‚ÇÅ)).full
  have : (F.toDescentData f).EssSurj := ‚ü®fun D ‚Ü¶
    ‚ü®_, ‚ü®h.preimageIso (e.app _ ‚â™‚â´ (F.toDescentData f').objObjPreimageIso (H.obj D))‚ü©‚ü©‚ü©
  exact { }

end

section

variable {F} [HasPullbacks C] {J : Precoverage C}
  [J.HasIsos] [J.IsStableUnderBaseChange] [J.IsStableUnderComposition]

lemma IsPrestack.of_precoverage
    (hF : ‚àÄ (S : C) (R : Presieve S) (_ : R ‚àà J S),
      (F.toDescentData (fun (f : R.category) ‚Ü¶ f.obj.hom)).FullyFaithful) :
    F.IsPrestack J.toGrothendieck where
  isSheaf {S} M N :=
    (isSheaf_iff_isSheaf_of_type ..).2 (by
      rw [over_toGrothendieck_eq_toGrothendieck_comap_forget,
        ‚Üê Precoverage.toGrothendieck_toPretopology,
        Presieve.isSheaf_pretopology]
      intro X R hR
      simp only [Precoverage.toPretopology_toPrecoverage, Precoverage.mem_comap_iff,
        Over.forget_obj] at hR
      obtain ‚ü®R', hR'‚ü© := (Sieve.overEquiv _).symm.surjective (Sieve.generate R)
      obtain ‚ü®Œπ, Z, f, hf‚ü© := Presieve.exists_eq_ofArrows R'.arrows
      have := (bijective_toDescentData_map_iff' (M := M) (N := N) (p := X.hom) f).1 (by
        suffices Nonempty ((F.toDescentData f).FullyFaithful) from this.some.map_bijective _ _
        refine (nonempty_fullyFaithful_toDescentData_iff_of_sieve_eq _ _ _ ?_).1 ‚ü®hF _ _ hR‚ü©
        refine le_antisymm ?_ ?_
        ¬∑ simp only [Sieve.generate_le_iff]
          rintro _ _ ‚ü®‚ü®W, hW‚ü©‚ü©
          obtain ‚ü®W, g, rfl‚ü© := W.mk_surjective
          obtain ‚ü®W', hW, b, hb, fac‚ü© := hW.exists
          obtain ‚ü®W', g', rfl‚ü© := W'.mk_surjective
          obtain rfl : W = W' := hW
          obtain rfl : g = b.left := by simpa using fac
          replace hb := Sieve.le_generate _ _ hb
          rw [‚Üê hR'] at hb
          replace hb := (Sieve.overEquiv_symm_iff _ _).1 hb
          rw [hf] at hb
          exact Sieve.le_generate _ _ hb
        ¬∑ simp only [Sieve.generate_le_iff]
          rintro _ _ ‚ü®i‚ü©
          let g : Over.mk (f i ‚â´ X.hom) ‚ü∂ X := Over.homMk (f i)
          have hg : Sieve.generate R g := by
            simp only [‚Üê hR', Functor.const_obj_obj, Sieve.overEquiv_symm_iff, Over.mk_left, hf]
            exact ‚ü®i‚ü©
          obtain ‚ü®T, p, q, hq, fac‚ü© := hg
          replace fac := (Over.forget _).congr_map fac
          let a : (Presieve.map (Over.forget S) R).category := ‚ü®Over.mk q.left, ‚ü®hq‚ü©‚ü©
          exact ‚ü®_, p.left, _, ‚ü®a‚ü©, fac‚ü©)
      rw [Presieve.isSheafFor_iff_generate] at this ‚ä¢
      convert this using 1
      rw [‚Üê hR']
      refine le_antisymm ?_ ?_
      ¬∑ rintro W g hg
        replace hg := (Sieve.overEquiv_symm_iff _ _).1 hg
        obtain ‚ü®W, p, rfl‚ü© := W.mk_surjective
        obtain ‚ü®g, hg', rfl‚ü© := Over.homMk_surjective g
        rw [hf] at hg
        dsimp at hg
        obtain ‚ü®i‚ü© := hg
        exact ‚ü®Over.mk (f i ‚â´ X.hom), Over.homMk (ùüô _), _, ‚ü®i‚ü©, by cat_disch‚ü©
      ¬∑ rintro W _ ‚ü®_, a, _, ‚ü®i‚ü©, rfl‚ü©
        refine (Sieve.overEquiv_symm_iff _ _).2 (R'.downward_closed ?_ _)
        rw [hf]
        exact .mk i)

lemma IsStack.of_precoverage
    (hF : ‚àÄ (S : C) (R : Presieve S) (_ : R ‚àà J S),
      (F.toDescentData (fun (f : R.category) ‚Ü¶ f.obj.hom)).IsEquivalence) :
    F.IsStack J.toGrothendieck := by
  have : F.IsPrestack J.toGrothendieck := .of_precoverage (fun S R hR ‚Ü¶ by
    have := hF S R hR
    exact .ofFullyFaithful _)
  rw [‚Üê J.toGrothendieck_toPretopology] at this ‚ä¢
  constructor
  rintro S R ‚ü®R', hR', h‚ü©
  have := hF S R' hR'
  have h‚ÇÅ : Sieve.ofArrows _ (fun (f : R'.category) ‚Ü¶ f.obj.hom) ‚àà
      J.toPretopology.toGrothendieck _ :=
    ‚ü®_, hR', fun _ g hg ‚Ü¶ ‚ü®_, ùüô _, g, .mk (Œπ := R'.category) ‚ü®Over.mk g, hg‚ü©, by simp‚ü©‚ü©
  have h‚ÇÇ : Sieve.ofArrows _ (fun (f : R'.category) ‚Ü¶ f.obj.hom) ‚â§
    Sieve.ofArrows _ (fun (f : R.arrows.category) ‚Ü¶ f.obj.hom) := by
      rw [Sieve.generate_le_iff]
      rintro _ _ ‚ü®r, hr‚ü©
      exact ‚ü®_, ùüô _, r.hom, .mk (Œπ := R.arrows.category) ‚ü®_, h _ hr‚ü©, by simp‚ü©
  have := F.isEquivalence_toDescentData_of_sieve_le h‚ÇÅ h‚ÇÇ
  infer_instance

end

end Pseudofunctor

end CategoryTheory
