/-
Copyright (c) 2025 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou, Christian Merten
-/
import Mathlib.CategoryTheory.Sites.Descent.DescentDataPrime
--import Mathlib.CategoryTheory.Sites.Descent.DescentDataAsCoalgebra
import Mathlib.CategoryTheory.Sites.Descent.IsStack
import Mathlib.CategoryTheory.Bicategory.Adjunction.Adj
import Mathlib.CategoryTheory.Bicategory.Adjunction.BaseChange

/-!
# Descent data ...

-/

namespace CategoryTheory

@[simps]
def Bicategory.Adjunction.toCategory {C D : Cat} {F : C ‚ü∂ D} {G : D ‚ü∂ C}
    (adj : Bicategory.Adjunction F G) :
    CategoryTheory.Adjunction F G where
  unit := adj.unit
  counit := adj.counit
  left_triangle_components X := by
    have := congr_app adj.left_triangle X
    dsimp [leftZigzag, bicategoricalComp] at this
    simpa [Cat.associator_hom_app, Cat.leftUnitor_hom_app, Cat.rightUnitor_inv_app] using this
  right_triangle_components X := by
    have := congr_app adj.right_triangle X
    dsimp [rightZigzag, bicategoricalComp] at this
    simpa [Cat.associator_inv_app, Cat.leftUnitor_inv_app] using this

open Opposite Limits Bicategory

@[reassoc (attr := simp)]
lemma Bicategory.Adj.hom_inv_id_œÑl_app {C D : Adj Cat} {f g : C ‚ü∂ D} (u : f ‚âÖ g) (M) :
    u.hom.œÑl.app M ‚â´ u.inv.œÑl.app M = ùüô _ := by
  rw [‚Üê NatTrans.comp_app, Adj.hom_inv_id_œÑl]
  simp

@[reassoc (attr := simp)]
lemma Bicategory.Adj.inv_hom_id_œÑl_app {C D : Adj Cat} {f g : C ‚ü∂ D} (u : f ‚âÖ g) (M) :
    u.inv.œÑl.app M ‚â´ u.hom.œÑl.app M = ùüô _ := by
  rw [‚Üê NatTrans.comp_app, Adj.inv_hom_id_œÑl]
  simp

@[reassoc (attr := simp)]
lemma Bicategory.Adj.hom_inv_id_œÑr_app {C D : Adj Cat} {f g : C ‚ü∂ D} (u : f ‚âÖ g) (M) :
    u.hom.œÑr.app M ‚â´ u.inv.œÑr.app M = ùüô _ := by
  rw [‚Üê NatTrans.comp_app, Adj.hom_inv_id_œÑr]
  simp

@[reassoc (attr := simp)]
lemma Bicategory.Adj.inv_hom_id_œÑr_app {C D : Adj Cat} {f g : C ‚ü∂ D} (u : f ‚âÖ g) (M) :
    u.inv.œÑr.app M ‚â´ u.hom.œÑr.app M = ùüô _ := by
  rw [‚Üê NatTrans.comp_app, Adj.inv_hom_id_œÑr]
  simp

namespace Pseudofunctor

open LocallyDiscreteOpToCat

variable {C : Type*} [Category C] (F : Pseudofunctor (LocallyDiscrete C·µí·µñ) (Adj Cat))

instance {X Y : C} (f : X ‚ü∂ Y) [IsIso f] (F : Pseudofunctor (LocallyDiscrete C) (Adj Cat)) :
    (F.map (.toLoc f)).l.IsEquivalence := by
  change ((F.comp Adj.forget‚ÇÅ).map f.toLoc).IsEquivalence
  infer_instance

instance (X : LocallyDiscrete C)  (F : Pseudofunctor (LocallyDiscrete C) (Adj Cat)) :
    (F.map (ùüô X)).l.IsEquivalence := by
  obtain ‚ü®X‚ü© := X
  change (F.map (ùüô X).toLoc).l.IsEquivalence
  infer_instance

-- TODO: add `Pseudofunctor.comp_mapComp'`
lemma mapComp'_comp_forget‚ÇÅ_hom {C : Type*} [Bicategory C] [Strict C]
    (F : Pseudofunctor C (Adj Cat))
    {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (fg : X ‚ü∂ Z) (hfg : f ‚â´ g = fg) :
    ((F.comp Adj.forget‚ÇÅ).mapComp' f g fg hfg).hom =
      (F.mapComp' f g fg hfg).hom.œÑl := by
  simp [Adj.comp_forget‚ÇÅ_mapComp']

lemma mapComp'_comp_forget‚ÇÅ_inv {C : Type*} [Bicategory C] [Strict C]
    (F : Pseudofunctor C (Adj Cat))
    {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (fg : X ‚ü∂ Z) (hfg : f ‚â´ g = fg) :
    ((F.comp Adj.forget‚ÇÅ).mapComp' f g fg hfg).inv =
      (F.mapComp' f g fg hfg).inv.œÑl := by
  simp [Adj.comp_forget‚ÇÅ_mapComp']

section

variable {C B : Type*} [Bicategory C] [Strict C] [Bicategory B]
    (F : Pseudofunctor C (Adj B))

end

variable {Œπ : Type*} {S : C} {X : Œπ ‚Üí C} {f : ‚àÄ i, X i ‚ü∂ S}
  (sq : ‚àÄ i j, ChosenPullback (f i) (f j))
  (sq‚ÇÉ : ‚àÄ (i‚ÇÅ i‚ÇÇ i‚ÇÉ : Œπ), ChosenPullback‚ÇÉ (sq i‚ÇÅ i‚ÇÇ) (sq i‚ÇÇ i‚ÇÉ) (sq i‚ÇÅ i‚ÇÉ))

namespace DescentData''

variable {F sq}
section

variable {obj : ‚àÄ (i : Œπ), (F.obj (.mk (op (X i)))).obj}
  (hom : ‚àÄ (i‚ÇÅ i‚ÇÇ : Œπ), obj i‚ÇÅ ‚ü∂ (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).r.obj
    ((F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÇ.op.toLoc).l.obj (obj i‚ÇÇ)))

def homComp (i‚ÇÅ i‚ÇÇ i‚ÇÉ : Œπ) : obj i‚ÇÅ ‚ü∂ (F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ.op.toLoc).r.obj
      ((F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÉ.op.toLoc).l.obj (obj i‚ÇÉ)) :=
  hom i‚ÇÅ i‚ÇÇ ‚â´ (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).r.map
      ((F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÇ.op.toLoc).l.map (hom i‚ÇÇ i‚ÇÉ)) ‚â´
        (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).r.map
          ((F.baseChange (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).isPullback‚ÇÇ.toCommSq.flip.op.toLoc).app _) ‚â´
    (Adj.rIso (F.mapComp' (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÇ.op.toLoc
          (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ.op.toLoc (by aesoptoloc))).inv.app _ ‚â´
    (F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ.op.toLoc).r.map
      ((Adj.lIso (F.mapComp' (sq i‚ÇÇ i‚ÇÉ).p‚ÇÇ.op.toLoc (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÇ‚ÇÉ.op.toLoc
          (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÉ.op.toLoc (by aesoptoloc))).inv.app _)

end

section

variable {X‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ : C}
  {obj‚ÇÅ : (F.obj (.mk (op X‚ÇÅ))).obj} {obj‚ÇÇ : (F.obj (.mk (op X‚ÇÇ))).obj}
  {p‚ÇÅ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÅ} {p‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÇ}
  (hom : obj‚ÇÅ ‚ü∂ (F.map p‚ÇÅ.op.toLoc).r.obj ((F.map p‚ÇÇ.op.toLoc).l.obj obj‚ÇÇ))

def pullHom'' ‚¶ÉY‚ÇÅ‚ÇÇ : C‚¶Ñ (p‚ÇÅ‚ÇÇ : Y‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÅ‚ÇÇ) (q‚ÇÅ : Y‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÅ) (q‚ÇÇ : Y‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÇ)
    (hq‚ÇÅ : p‚ÇÅ‚ÇÇ ‚â´ p‚ÇÅ = q‚ÇÅ := by aesop_cat) (hq‚ÇÇ : p‚ÇÅ‚ÇÇ ‚â´ p‚ÇÇ = q‚ÇÇ := by aesop_cat) :
    obj‚ÇÅ ‚ü∂ (F.map q‚ÇÅ.op.toLoc).r.obj ((F.map q‚ÇÇ.op.toLoc).l.obj obj‚ÇÇ) :=
  hom ‚â´ (F.map p‚ÇÅ.op.toLoc).r.map ((F.map p‚ÇÅ‚ÇÇ.op.toLoc).adj.unit.app _) ‚â´
    (Adj.rIso (F.mapComp' p‚ÇÅ.op.toLoc p‚ÇÅ‚ÇÇ.op.toLoc q‚ÇÅ.op.toLoc (by aesoptoloc))).inv.app _ ‚â´
      (F.map q‚ÇÅ.op.toLoc).r.map
    ((Adj.lIso (F.mapComp' p‚ÇÇ.op.toLoc p‚ÇÅ‚ÇÇ.op.toLoc q‚ÇÇ.op.toLoc (by aesoptoloc))).inv.app _)

end

@[reassoc]
lemma mapComp'_œÑl_œÑr_compatibility
    ‚¶ÉX Y Z : C‚¶Ñ (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (fg : X ‚ü∂ Z) (hfg : f ‚â´ g = fg)
    (obj : (F.obj (.mk (op Y))).obj) :
    (F.map fg.op.toLoc).l.map
      ((F.map g.op.toLoc).r.map ((F.map f.op.toLoc).adj.unit.app obj)) ‚â´
      (F.map fg.op.toLoc).l.map
        ((F.mapComp' g.op.toLoc f.op.toLoc fg.op.toLoc (by aesoptoloc)).hom.œÑr.app
          (((F.map f.op.toLoc).l.obj obj))) ‚â´
      (F.map fg.op.toLoc).adj.counit.app ((F.map f.op.toLoc).l.obj obj) =
    (F.mapComp' g.op.toLoc f.op.toLoc fg.op.toLoc (by aesoptoloc)).hom.œÑl.app _ ‚â´
      (F.map f.op.toLoc).l.map ((F.map g.op.toLoc).adj.counit.app obj) := by
  simpa [Cat.associator_hom_app, Cat.associator_inv_app, Cat.rightUnitor_inv_app,
    Cat.leftUnitor_hom_app] using
    NatTrans.congr_app
      (Adj.unit_comp_mapComp'_hom_œÑr_comp_counit F g.op.toLoc f.op.toLoc fg.op.toLoc
        (by aesoptoloc)) obj

lemma homEquiv_symm_pullHom'' ‚¶ÉX‚ÇÅ X‚ÇÇ : C‚¶Ñ
    ‚¶Éobj‚ÇÅ : (F.obj (.mk (op X‚ÇÅ))).obj‚¶Ñ ‚¶Éobj‚ÇÇ : (F.obj (.mk (op X‚ÇÇ))).obj‚¶Ñ
    ‚¶ÉX‚ÇÅ‚ÇÇ : C‚¶Ñ ‚¶Ép‚ÇÅ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÅ‚¶Ñ ‚¶Ép‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÇ‚¶Ñ
    (hom : obj‚ÇÅ ‚ü∂ (F.map p‚ÇÅ.op.toLoc).r.obj ((F.map p‚ÇÇ.op.toLoc).l.obj obj‚ÇÇ))
    ‚¶ÉY‚ÇÅ‚ÇÇ : C‚¶Ñ (g : Y‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÅ‚ÇÇ) (gp‚ÇÅ : Y‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÅ) (gp‚ÇÇ : Y‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÇ)
    (hgp‚ÇÅ : g ‚â´ p‚ÇÅ = gp‚ÇÅ) (hgp‚ÇÇ : g ‚â´ p‚ÇÇ = gp‚ÇÇ) :
    ((F.map gp‚ÇÅ.op.toLoc).adj.toCategory.homEquiv _ _ ).symm (pullHom'' hom g gp‚ÇÅ gp‚ÇÇ hgp‚ÇÅ hgp‚ÇÇ) =
      pullHom (F := F.comp Adj.forget‚ÇÅ)
        ((((F.map p‚ÇÅ.op.toLoc).adj.toCategory).homEquiv _ _ ).symm hom) g gp‚ÇÅ gp‚ÇÇ hgp‚ÇÅ hgp‚ÇÇ := by
  rw [Adjunction.homEquiv_counit, Adjunction.homEquiv_counit]
  dsimp [pullHom'', pullHom]
  simp only [Functor.map_comp, Category.assoc, Adj.comp_forget‚ÇÅ_mapComp', Adj.lIso_hom,
    Adj.lIso_inv]
  erw [‚Üê NatTrans.naturality_assoc]
  dsimp
  congr 1
  have := (F.map gp‚ÇÅ.op.toLoc).adj.toCategory.counit.naturality
    ((F.mapComp' p‚ÇÇ.op.toLoc g.op.toLoc gp‚ÇÇ.op.toLoc (by aesoptoloc)).inv.œÑl.app obj‚ÇÇ)
  dsimp at this
  rw [this, mapComp'_œÑl_œÑr_compatibility_assoc _ _ _ hgp‚ÇÅ]

section

variable
    ‚¶ÉX‚ÇÅ‚ÇÇ X X S : C‚¶Ñ ‚¶Ép‚ÇÅ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚¶Ñ ‚¶Ép‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚¶Ñ ‚¶Éf : X ‚ü∂ S‚¶Ñ
    (sq : CommSq p‚ÇÅ p‚ÇÇ f f) (obj : (F.obj (.mk (op X))).obj)

@[reassoc]
lemma map_baseChange_comp_counit (g : X ‚ü∂ X‚ÇÅ‚ÇÇ) (hg‚ÇÅ : g ‚â´ p‚ÇÅ = ùüô X) (hg‚ÇÇ : g ‚â´ p‚ÇÇ = ùüô X) :
    (F.map g.op.toLoc).l.map
      ((F.map p‚ÇÅ.op.toLoc).l.map ((F.baseChange sq.flip.op.toLoc).app obj)) ‚â´
    (F.map g.op.toLoc).l.map
       ((F.map p‚ÇÅ.op.toLoc).adj.counit.app _) =
    (F.mapComp' p‚ÇÅ.op.toLoc g.op.toLoc (ùüô _) (by aesoptoloc)).inv.œÑl.app
      ((F.map f.op.toLoc).l.obj ((F.map f.op.toLoc).r.obj obj)) ‚â´
      (F.map (ùüô _)).l.map ((F.map f.op.toLoc).adj.counit.app _) ‚â´
      (F.mapComp' p‚ÇÇ.op.toLoc g.op.toLoc (ùüô _) (by aesoptoloc)).hom.œÑl.app obj := by
  have := NatTrans.congr_app
    (F.whiskerRight_whiskerBaseChange_self_self _ _ _ sq.flip.op.toLoc g.op.toLoc (by aesoptoloc)
      (by aesoptoloc)) obj
  simp [Cat.associator_inv_app, Cat.associator_hom_app, Cat.leftUnitor_hom_app,
    Adj.comp_forget‚ÇÅ_mapComp', whiskerBaseChange_eq',
    Adjunction.homEquiv‚ÇÇ_symm_apply] at this
  rw [this]
  erw [‚Üê NatTrans.naturality_assoc]
  rfl

end


end DescentData''

open DescentData'' in
structure DescentData'' where
  obj (i : Œπ) : (F.obj (.mk (op (X i)))).obj
  hom (i‚ÇÅ i‚ÇÇ : Œπ) : obj i‚ÇÅ ‚ü∂
    (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).r.obj
      ((F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÇ.op.toLoc).l.obj (obj i‚ÇÇ))
  hom_self (i : Œπ) (Œ¥ : (sq i i).Diagonal) :
    pullHom'' (hom i i) Œ¥.f (ùüô _) (ùüô _) = (F.map (ùüô (.mk (op (X i))))).adj.unit.app _
  hom_comp (i‚ÇÅ i‚ÇÇ i‚ÇÉ : Œπ) :
    homComp sq‚ÇÉ hom i‚ÇÅ i‚ÇÇ i‚ÇÉ = pullHom'' (hom i‚ÇÅ i‚ÇÉ) (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÉ _ _

namespace DescentData''

section Category

variable {F sq sq‚ÇÉ}

@[ext]
structure Hom (D‚ÇÅ D‚ÇÇ : F.DescentData'' sq sq‚ÇÉ) where
  hom (i : Œπ) : D‚ÇÅ.obj i ‚ü∂ D‚ÇÇ.obj i
  comm (i‚ÇÅ i‚ÇÇ : Œπ) :
    D‚ÇÅ.hom i‚ÇÅ i‚ÇÇ ‚â´ (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).r.map
      ((F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÇ.op.toLoc).l.map (hom i‚ÇÇ)) = hom i‚ÇÅ ‚â´ D‚ÇÇ.hom i‚ÇÅ i‚ÇÇ := by aesop_cat

attribute [reassoc (attr := simp)] Hom.comm

@[simps]
def Hom.id (D : F.DescentData'' sq sq‚ÇÉ) : Hom D D where
  hom _ := ùüô _

@[simps]
def Hom.comp {D‚ÇÅ D‚ÇÇ D‚ÇÉ : F.DescentData'' sq sq‚ÇÉ} (f : Hom D‚ÇÅ D‚ÇÇ) (g : Hom D‚ÇÇ D‚ÇÉ) : Hom D‚ÇÅ D‚ÇÉ where
  hom i := f.hom i ‚â´ g.hom i

instance : Category (F.DescentData'' sq sq‚ÇÉ) where
  Hom := Hom
  id := Hom.id
  comp := Hom.comp

@[ext]
lemma hom_ext {D‚ÇÅ D‚ÇÇ : F.DescentData'' sq sq‚ÇÉ} {f g : D‚ÇÅ ‚ü∂ D‚ÇÇ}
    (h : ‚àÄ i, f.hom i = g.hom i) : f = g :=
  Hom.ext (funext h)

@[reassoc, simp]
lemma comp_hom {D‚ÇÅ D‚ÇÇ D‚ÇÉ : F.DescentData'' sq sq‚ÇÉ} (f : D‚ÇÅ ‚ü∂ D‚ÇÇ) (g : D‚ÇÇ ‚ü∂ D‚ÇÉ) (i : Œπ) :
    (f ‚â´ g).hom i = f.hom i ‚â´ g.hom i :=
  rfl

@[simp]
lemma id_hom (D : F.DescentData'' sq sq‚ÇÉ) (i : Œπ) :
    Hom.hom (ùüô D) i = ùüô _ :=
  rfl

@[simps]
def isoMk {D‚ÇÅ D‚ÇÇ : F.DescentData'' sq sq‚ÇÉ} (e : ‚àÄ (i : Œπ), D‚ÇÅ.obj i ‚âÖ D‚ÇÇ.obj i)
    (comm : ‚àÄ (i‚ÇÅ i‚ÇÇ : Œπ), D‚ÇÅ.hom i‚ÇÅ i‚ÇÇ ‚â´ (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).r.map
      ((F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÇ.op.toLoc).l.map (e i‚ÇÇ).hom) =
        (e i‚ÇÅ).hom ‚â´ D‚ÇÇ.hom i‚ÇÅ i‚ÇÇ := by aesop_cat) :
    D‚ÇÅ ‚âÖ D‚ÇÇ where
  hom :=
    { hom i := (e i).hom
      comm := comm }
  inv :=
    { hom i := (e i).inv
      comm i‚ÇÅ i‚ÇÇ := by
        rw [‚Üê cancel_epi (e i‚ÇÅ).hom, ‚Üê reassoc_of% comm i‚ÇÅ i‚ÇÇ]
        simp [‚Üê Functor.map_comp] }

end Category

variable {F} {sq} {obj : ‚àÄ (i : Œπ), (F.obj (.mk (op (X i)))).obj}
  (hom : ‚àÄ i‚ÇÅ i‚ÇÇ, obj i‚ÇÅ ‚ü∂ (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).r.obj
    ((F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÇ.op.toLoc).l.obj (obj i‚ÇÇ)))

section

def dataEquivDescentData' :
    (‚àÄ i‚ÇÅ i‚ÇÇ, obj i‚ÇÅ ‚ü∂ (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).r.obj
      ((F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÇ.op.toLoc).l.obj (obj i‚ÇÇ))) ‚âÉ
    (‚àÄ i‚ÇÅ i‚ÇÇ, (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).l.obj (obj i‚ÇÅ) ‚ü∂
      (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÇ.op.toLoc).l.obj (obj i‚ÇÇ)) :=
  Equiv.piCongrRight (fun i‚ÇÅ ‚Ü¶ Equiv.piCongrRight (fun i‚ÇÇ ‚Ü¶
    (((F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).adj.toCategory).homEquiv _ _).symm))

lemma hom_self_iff_dataEquivDescentData' ‚¶Éi : Œπ‚¶Ñ (Œ¥ : (sq i i).Diagonal) :
    pullHom'' (hom i i) Œ¥.f (ùüô _) (ùüô _) = (F.map (ùüô (.mk (op (X i))))).adj.unit.app _ ‚Üî
    DescentData'.pullHom' (F := F.comp Adj.forget‚ÇÅ)
        (dataEquivDescentData' hom) (f i) (ùüô (X i)) (ùüô (X i)) = ùüô _ := by
  trans ((F.map (ùüô (.mk (op (X i))))).adj.toCategory.homEquiv _ _).symm
    (pullHom'' (hom i i) Œ¥.f (ùüô (X i)) (ùüô (X i))) = ùüô _
  ¬∑ dsimp
    rw [‚Üê Adjunction.toCategory_unit, ‚Üê Adjunction.homEquiv_id,
      Equiv.apply_eq_iff_eq_symm_apply, Equiv.symm_symm]
  ¬∑ convert Iff.rfl using 2
    have := homEquiv_symm_pullHom'' (hom _ _) Œ¥.f (ùüô _) (ùüô _) (by simp) (by simp)
    dsimp at this ‚ä¢
    rw [this]
    apply DescentData'.pullHom'_eq_pullHom <;> simp

lemma homEquiv_symm_pullHom''_eq_pullHom'_dataEquivDescentData' (i‚ÇÅ i‚ÇÇ i‚ÇÉ : Œπ) :
    (((F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ.op.toLoc).adj.toCategory).homEquiv _ _).symm
      (pullHom'' (hom i‚ÇÅ i‚ÇÉ) (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÉ _ _) =
        DescentData'.pullHom' (F := F.comp Adj.forget‚ÇÅ)
          (dataEquivDescentData' hom) (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÉ := by
  rw [homEquiv_symm_pullHom'', dataEquivDescentData']
  simp only [comp_toPrelaxFunctor, PrelaxFunctor.comp_toPrelaxFunctorStruct,
    PrelaxFunctorStruct.comp_toPrefunctor, Prefunctor.comp_obj, Adj.forget‚ÇÅ_obj,
    Prefunctor.comp_map, Adj.forget‚ÇÅ_map]
  rw [DescentData'.pullHom'_eq_pullHom _ (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p _ _ _ _ (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÉ]
  ¬∑ rfl
  ¬∑ simp
  ¬∑ simp

variable (i‚ÇÅ i‚ÇÇ i‚ÇÉ : Œπ)

@[reassoc]
lemma map_p‚ÇÅ‚ÇÇ_baseChange_comp_counit (i‚ÇÅ i‚ÇÇ i‚ÇÉ : Œπ) (M) :
    (F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÇ.op.toLoc).l.map
      ((F.baseChange (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).isPullback‚ÇÇ.toCommSq.flip.op.toLoc).app M) ‚â´
      (F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÇ.op.toLoc).adj.counit.app _ =
    (F.mapComp' (sq i‚ÇÅ i‚ÇÇ).p‚ÇÇ.op.toLoc (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÇ.op.toLoc
        (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÇ.op.toLoc (by aesoptoloc)).inv.œÑl.app _ ‚â´
      (F.mapComp' (sq i‚ÇÇ i‚ÇÉ).p‚ÇÅ.op.toLoc (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÇ‚ÇÉ.op.toLoc
        (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÇ.op.toLoc (by aesoptoloc)).hom.œÑl.app _ ‚â´
      (F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÇ‚ÇÉ.op.toLoc).l.map
        ((F.map (sq i‚ÇÇ i‚ÇÉ).p‚ÇÅ.op.toLoc).adj.counit.app _) ‚â´
        (by dsimp; exact eqToHom rfl) := by
  have h1 := congr($(F.whiskerBaseChange_eq_whiskerRight_baseChange
    (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).isPullback‚ÇÇ.toCommSq.flip.op.toLoc).app M)
  have h2 := congr($(F.whiskerBaseChange_eq_whiskerLeft_isoMapOfCommSq
    (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).isPullback‚ÇÇ.toCommSq.flip.op.toLoc).app M)
  dsimp at h1 h2
  rw [h2] at h1
  simp [Cat.associator_hom_app, Cat.associator_inv_app, Cat.rightUnitor_inv_app,
    Cat.leftUnitor_hom_app, Cat.rightUnitor_hom_app] at h1
  rw [‚Üê h1]
  simp only [Cat.comp_obj, Cat.id_obj, Adj.comp_l, eqToHom_refl, id_eq, Category.comp_id]
  rw [F.isoMapOfCommSq_eq _ (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÇ.op.toLoc (by aesoptoloc)]
  simp

-- TODO: fix the name, this has nothing to do with `baseChange`, could maybe even be inlined by
-- adding some more lemmas
@[reassoc]
lemma baseChange_eq'' (i‚ÇÅ i‚ÇÇ i‚ÇÉ : Œπ) (M)
    (f : (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÇ.op.toLoc).l.obj ((F.map (sq i‚ÇÇ i‚ÇÉ).p‚ÇÅ.op.toLoc).r.obj M) ‚ü∂
      (F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÇ.op.toLoc).r.obj ((F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÇ‚ÇÉ.op.toLoc).l.obj M)) :
    (F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ.op.toLoc).l.map
    ((F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).r.map f) ‚â´
      (F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ.op.toLoc).l.map
        ((F.mapComp' _ _ (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ.op.toLoc (by aesoptoloc)).hom.œÑr.app _) ‚â´
      (F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ.op.toLoc).adj.counit.app _ =
      ((F.mapComp' (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÇ.op.toLoc
        (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ.op.toLoc (by aesoptoloc)).hom.œÑl.app _) ‚â´
        (F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÇ.op.toLoc).l.map
          ((F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).adj.counit.app _) ‚â´
    (F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÇ.op.toLoc).l.map f ‚â´
      (F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÇ.op.toLoc).adj.counit.app _ := by
  have := Adj.counit_map_of_comp F (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÇ.op.toLoc
    (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ.op.toLoc (by aesoptoloc)
  rw [this]
  simp [Cat.associator_hom_app, Cat.associator_inv_app, Cat.rightUnitor_inv_app,
    Cat.leftUnitor_hom_app]
  congr 1
  rw [‚Üê (F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÇ.op.toLoc).l.map_comp_assoc]
  rw [‚Üê (F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÇ.op.toLoc).l.map_comp_assoc]
  rw [Category.assoc]
  rw [‚Üê (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).l.map_comp]
  rw [‚Üê NatTrans.comp_app]
  rw [Adj.hom_inv_id_œÑr]
  simp only [Adj.comp_r, Cat.id_app, Cat.comp_obj, Functor.map_id, Category.comp_id]
  rw [‚Üê (F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÇ.op.toLoc).l.map_comp_assoc]
  erw [(F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).adj.counit.naturality]
  simp

-- TODO: clean this up, it's an `erw`-massacre
lemma homEquiv_symm_homComp (i‚ÇÅ i‚ÇÇ i‚ÇÉ : Œπ) :
    (((F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ.op.toLoc).adj.toCategory).homEquiv _ _).symm
      (homComp sq‚ÇÉ hom i‚ÇÅ i‚ÇÇ i‚ÇÉ) =
        DescentData'.pullHom' (F := F.comp Adj.forget‚ÇÅ)
        (dataEquivDescentData' hom) (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÇ ‚â´
      DescentData'.pullHom'
        (dataEquivDescentData' hom) (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÇ (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÉ := by
  rw [DescentData'.pullHom'‚ÇÅ‚ÇÇ_eq_pullHom_of_chosenPullback‚ÇÉ]
  rw [DescentData'.pullHom'‚ÇÇ‚ÇÉ_eq_pullHom_of_chosenPullback‚ÇÉ]
  rw [dataEquivDescentData']
  dsimp only [comp_toPrelaxFunctor, PrelaxFunctor.comp_toPrelaxFunctorStruct,
    PrelaxFunctorStruct.comp_toPrefunctor, Prefunctor.comp_obj, Adj.forget‚ÇÅ_obj,
    Prefunctor.comp_map, Adj.forget‚ÇÅ_map, Equiv.piCongrRight_apply, Pi.map_apply]
  simp_rw [Adjunction.homEquiv_counit]
  dsimp only [Adjunction.toCategory_counit]
  rw [homComp]
  simp only [Cat.comp_obj, Adj.comp_r, Adj.rIso_inv, Adj.comp_l, Adj.lIso_inv, Functor.map_comp,
    Category.assoc, pullHom, comp_toPrelaxFunctor, PrelaxFunctor.comp_toPrelaxFunctorStruct,
    PrelaxFunctorStruct.comp_toPrefunctor, Prefunctor.comp_obj, Adj.forget‚ÇÅ_obj,
    Prefunctor.comp_map, Adj.forget‚ÇÅ_map]
  erw [(F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ.op.toLoc).adj.counit.naturality]
  dsimp only [Cat.comp_obj, Cat.id_obj, Cat.id_map]
  rw [baseChange_eq''_assoc]
  rw [map_p‚ÇÅ‚ÇÇ_baseChange_comp_counit_assoc]
  simp only [Cat.comp_obj, Adj.comp_l, Cat.id_obj, eqToHom_refl, id_eq, Category.id_comp,
    NatTrans.naturality_assoc, Cat.comp_map]
  rw [mapComp'_comp_forget‚ÇÅ_hom]
  rw [mapComp'_comp_forget‚ÇÅ_hom]
  rw [mapComp'_comp_forget‚ÇÅ_inv]
  rw [mapComp'_comp_forget‚ÇÅ_inv]
  congr 2
  rw [‚Üê (F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÇ.op.toLoc).l.map_comp_assoc]
  erw [(F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).adj.counit.naturality]
  simp only [Cat.comp_obj, Cat.id_obj, Cat.id_map, Functor.map_comp, Category.assoc]
  erw [(F.mapComp' _ _ _ _).inv.œÑl.naturality_assoc]
  simp

lemma hom_comp_iff_dataEquivDescentData' (i‚ÇÅ i‚ÇÇ i‚ÇÉ : Œπ) :
    homComp sq‚ÇÉ hom i‚ÇÅ i‚ÇÇ i‚ÇÉ = pullHom'' (hom i‚ÇÅ i‚ÇÉ) (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÉ _ _ ‚Üî
      DescentData'.pullHom' (F := F.comp Adj.forget‚ÇÅ)
        (dataEquivDescentData' hom) (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÇ ‚â´
      DescentData'.pullHom'
        (dataEquivDescentData' hom) (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÇ (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÉ =
      DescentData'.pullHom'
        (dataEquivDescentData' hom) (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÉ := by
  rw [‚Üê homEquiv_symm_pullHom''_eq_pullHom'_dataEquivDescentData', ‚Üê homEquiv_symm_homComp]
  simp

variable
  (obj‚ÇÅ obj‚ÇÇ : (i : Œπ) ‚Üí (F.obj { as := op (X i) }).obj)
  (hom‚ÇÅ : (i‚ÇÅ i‚ÇÇ : Œπ) ‚Üí obj‚ÇÅ i‚ÇÅ ‚ü∂
    (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).r.obj ((F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÇ.op.toLoc).l.obj (obj‚ÇÅ i‚ÇÇ)))
  (hom‚ÇÇ : (i‚ÇÅ i‚ÇÇ : Œπ) ‚Üí obj‚ÇÇ i‚ÇÅ ‚ü∂
    (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).r.obj ((F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÇ.op.toLoc).l.obj (obj‚ÇÇ i‚ÇÇ)))
  (hom : (i : Œπ) ‚Üí obj‚ÇÅ i ‚ü∂ obj‚ÇÇ i)

lemma hom_comm_iff_dataEquivDescentData' (i‚ÇÅ i‚ÇÇ : Œπ) :
    hom‚ÇÅ i‚ÇÅ i‚ÇÇ ‚â´ (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).r.map
      ((F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÇ.op.toLoc).l.map (hom i‚ÇÇ)) = hom i‚ÇÅ ‚â´ hom‚ÇÇ i‚ÇÅ i‚ÇÇ ‚Üî
    (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).l.map (hom i‚ÇÅ) ‚â´ dataEquivDescentData' hom‚ÇÇ i‚ÇÅ i‚ÇÇ =
      dataEquivDescentData' hom‚ÇÅ i‚ÇÅ i‚ÇÇ ‚â´ (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÇ.op.toLoc).l.map (hom i‚ÇÇ) := by
  conv_lhs =>
    rw [‚Üê Equiv.apply_eq_iff_eq
      (((F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).adj.toCategory).homEquiv (obj‚ÇÅ i‚ÇÅ) _).symm, Eq.comm]
  congr!
  ¬∑ simp [dataEquivDescentData', Adjunction.homEquiv_symm_apply]
  ¬∑ simp only [Adjunction.homEquiv_symm_apply, Functor.map_comp, Adjunction.toCategory_counit,
      Category.assoc, dataEquivDescentData', Equiv.piCongrRight_apply, Pi.map_apply]
    congr 1
    apply (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).adj.counit.naturality

@[simps]
def toDescentData' : F.DescentData'' sq sq‚ÇÉ ‚•§ (F.comp Adj.forget‚ÇÅ).DescentData' sq sq‚ÇÉ where
  obj D :=
    { obj := D.obj
      hom := dataEquivDescentData' D.hom
      pullHom'_hom_self i := by
        obtain ‚ü®Œ¥‚ü© := inferInstanceAs (Nonempty (sq i i).Diagonal)
        rw [‚Üê hom_self_iff_dataEquivDescentData']
        exact D.hom_self i Œ¥
      pullHom'_hom_comp i‚ÇÅ i‚ÇÇ i‚ÇÉ := by
        rw [‚Üê hom_comp_iff_dataEquivDescentData']
        exact D.hom_comp i‚ÇÅ i‚ÇÇ i‚ÇÉ }
  map {D‚ÇÅ D‚ÇÇ} f :=
    { hom i := f.hom i
      comm i‚ÇÅ i‚ÇÇ := by
        dsimp
        rw [‚Üê hom_comm_iff_dataEquivDescentData']
        exact f.comm i‚ÇÅ i‚ÇÇ }

@[simps]
def fromDescentData' : (F.comp Adj.forget‚ÇÅ).DescentData' sq sq‚ÇÉ ‚•§ F.DescentData'' sq sq‚ÇÉ where
  obj D :=
    { obj := D.obj
      hom := dataEquivDescentData'.symm D.hom
      hom_self i Œ¥ := by
        rw [hom_self_iff_dataEquivDescentData']
        simp
      hom_comp i‚ÇÅ i‚ÇÇ i‚ÇÉ := by
        rw [hom_comp_iff_dataEquivDescentData']
        simp }
  map {D‚ÇÅ D‚ÇÇ} f :=
    { hom i := f.hom i
      comm i‚ÇÅ i‚ÇÇ := by
        dsimp
        rw [hom_comm_iff_dataEquivDescentData']
        simpa using f.comm i‚ÇÅ i‚ÇÇ }

set_option maxHeartbeats 240000 in
-- TODO: automation is slow here
@[simps]
def equivDescentData' :
    F.DescentData'' sq sq‚ÇÉ ‚âå (F.comp Adj.forget‚ÇÅ).DescentData' sq sq‚ÇÉ where
  functor := toDescentData' sq‚ÇÉ
  inverse := fromDescentData' sq‚ÇÉ
  unitIso := NatIso.ofComponents
    (fun D ‚Ü¶ isoMk (fun i ‚Ü¶ Iso.refl _) (fun i‚ÇÅ i‚ÇÇ ‚Ü¶ by simp [toDescentData']))
  counitIso := NatIso.ofComponents
    (fun D ‚Ü¶ DescentData'.isoMk (fun i ‚Ü¶ Iso.refl _) (fun i‚ÇÅ i‚ÇÇ ‚Ü¶ by simp [fromDescentData']))

end

section

variable [‚àÄ i‚ÇÅ i‚ÇÇ, IsIso (F.baseChange (sq i‚ÇÅ i‚ÇÇ).isPullback.toCommSq.flip.op.toLoc)]
  [‚àÄ i‚ÇÅ i‚ÇÇ i‚ÇÉ, IsIso (F.baseChange (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).isPullback‚ÇÇ.toCommSq.flip.op.toLoc)]

noncomputable def dataEquivCoalgebra
  [‚àÄ i‚ÇÅ i‚ÇÇ, IsIso (F.baseChange (sq i‚ÇÅ i‚ÇÇ).isPullback.toCommSq.flip.op.toLoc)] :
    (‚àÄ i‚ÇÅ i‚ÇÇ, obj i‚ÇÅ ‚ü∂ (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).r.obj
      ((F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÇ.op.toLoc).l.obj (obj i‚ÇÇ))) ‚âÉ
    (‚àÄ i‚ÇÅ i‚ÇÇ, obj i‚ÇÅ ‚ü∂ (F.map (f i‚ÇÅ).op.toLoc).l.obj ((F.map (f i‚ÇÇ).op.toLoc).r.obj (obj i‚ÇÇ))) :=
  Equiv.piCongrRight (fun i‚ÇÅ ‚Ü¶ Equiv.piCongrRight (fun i‚ÇÇ ‚Ü¶
    Iso.homCongr (Iso.refl _)
      ((asIso (F.baseChange (sq i‚ÇÅ i‚ÇÇ).isPullback.toCommSq.flip.op.toLoc)).symm.app _)))

lemma hom_self_iff_dataEquivCoalgebra ‚¶Éi : Œπ‚¶Ñ (Œ¥ : (sq i i).Diagonal):
    pullHom'' (hom i i) Œ¥.f (ùüô _) (ùüô _) = (F.map (ùüô (.mk (op (X i))))).adj.unit.app _ ‚Üî
    dataEquivCoalgebra hom i i ‚â´ (F.map (f i).op.toLoc).adj.counit.app _ = ùüô _ := by
  obtain ‚ü®hom, rfl‚ü© := dataEquivCoalgebra.symm.surjective hom
  rw [Equiv.apply_symm_apply]
  dsimp [dataEquivCoalgebra]
  rw [Category.id_comp,
    ‚Üê ((F.map (ùüô (X i)).op.toLoc).adj.toCategory.homEquiv _ _ ).symm.injective.eq_iff,
    homEquiv_symm_pullHom'']
  dsimp
  rw [‚Üê Adjunction.toCategory_unit, ‚Üê Adjunction.homEquiv_id, Equiv.symm_apply_apply]
  trans (F.map (ùüô { as := op (X i) })).l.map
      (hom i i ‚â´ (F.map (f i).op.toLoc).adj.counit.app (obj i)) = ùüô _ ; swap
  ¬∑ rw [‚Üê Functor.map_id]
    have : Functor.Faithful (F.map (ùüô { as := op (X i) })).l := inferInstance
    rw [Functor.map_injective_iff]
  ¬∑ convert Iff.rfl using 2
    dsimp [pullHom]
    simp [Adjunction.homEquiv_counit]
    erw [‚Üê NatTrans.naturality_assoc]
    congr 1
    simp [Adj.comp_forget‚ÇÅ_mapComp']
    rw [map_baseChange_comp_counit_assoc (sq i i).commSq (obj i) Œ¥.f (by simp) (by simp)]
    dsimp
    rw [‚Üê Adj.lIso_hom, ‚Üê Adj.lIso_inv, Iso.hom_inv_id_app_assoc,
      ‚Üê Adj.lIso_hom, ‚Üê Adj.lIso_inv, Iso.hom_inv_id_app, Category.comp_id]

variable (obj) in
private noncomputable def correction (i‚ÇÅ i‚ÇÇ i‚ÇÉ : Œπ) :
    (F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ.op.toLoc).r.obj
      ((F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÉ.op.toLoc).l.obj (obj i‚ÇÉ)) ‚ü∂
      (F.map (f i‚ÇÅ).op.toLoc).l.obj
        ((F.map (f i‚ÇÇ).op.toLoc).r.obj
          ((F.map (f i‚ÇÇ).op.toLoc).l.obj
            ((F.map (f i‚ÇÉ).op.toLoc).r.obj (obj i‚ÇÉ)))) :=
  (F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ.op.toLoc).r.map
    ((F.mapComp' (sq i‚ÇÇ i‚ÇÉ).p‚ÇÇ.op.toLoc (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÇ‚ÇÉ.op.toLoc
      (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÉ.op.toLoc (by aesoptoloc)).hom.œÑl.app _) ‚â´
      (F.mapComp' (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÇ.op.toLoc
        (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ.op.toLoc (by aesoptoloc)).inv.œÑr.app _ ‚â´
        (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).r.map
          (inv ((F.baseChange (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).isPullback‚ÇÇ.toCommSq.flip.op.toLoc).app _)) ‚â´
          (inv (F.baseChange (sq i‚ÇÅ i‚ÇÇ).isPullback.toCommSq.flip.op.toLoc)).app _ ‚â´
          (F.map (f i‚ÇÅ).op.toLoc).l.map ((F.map (f i‚ÇÇ).op.toLoc).r.map
            (inv ((F.baseChange (sq i‚ÇÇ i‚ÇÉ).isPullback.toCommSq.flip.op.toLoc).app _)))

private instance (i‚ÇÅ i‚ÇÇ i‚ÇÉ : Œπ) : IsIso (correction sq‚ÇÉ obj i‚ÇÅ i‚ÇÇ i‚ÇÉ) := by
  dsimp [correction]
  -- TODO: does not work without these auxiliary instances
  have : IsIso (F.mapComp' (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÇ.op.toLoc
    (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ.op.toLoc (by aesoptoloc)).inv.œÑr := inferInstance
  have : IsIso (F.mapComp' (sq i‚ÇÇ i‚ÇÉ).p‚ÇÇ.op.toLoc (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÇ‚ÇÉ.op.toLoc
    (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÉ.op.toLoc (by aesoptoloc)).hom.œÑl := inferInstance
  infer_instance

private lemma homComp_correction (i‚ÇÅ i‚ÇÇ i‚ÇÉ : Œπ) :
    homComp sq‚ÇÉ hom i‚ÇÅ i‚ÇÇ i‚ÇÉ ‚â´ correction sq‚ÇÉ obj i‚ÇÅ i‚ÇÇ i‚ÇÉ = dataEquivCoalgebra hom i‚ÇÅ i‚ÇÇ ‚â´
      (F.map (f i‚ÇÅ).op.toLoc).l.map
        ((F.map (f i‚ÇÇ).op.toLoc).r.map (dataEquivCoalgebra hom i‚ÇÇ i‚ÇÉ)) := by
  simp only [homComp, Cat.comp_obj, Adj.comp_r, Adj.rIso_inv, Adj.comp_l, Adj.lIso_inv,
    NatTrans.naturality_assoc, Cat.comp_map, Category.assoc, correction]
  rw [‚Üê NatTrans.comp_app_assoc]
  rw [Adj.hom_inv_id_œÑr]
  simp only [Cat.comp_obj, Adj.comp_r, Cat.id_app, Category.id_comp]
  nth_rw 3 [‚Üê (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).r.map_comp_assoc]
  rw [‚Üê (F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÇ.op.toLoc).r.map_comp]
  rw [‚Üê NatTrans.comp_app]
  rw [Adj.inv_hom_id_œÑl]
  simp only [Adj.comp_l, Cat.id_app, Cat.comp_obj, Functor.map_id, Category.id_comp]
  nth_rw 2 [‚Üê (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).r.map_comp_assoc]
  simp only [IsIso.hom_inv_id, Functor.map_id, Functor.map_inv, Category.id_comp]
  dsimp [dataEquivCoalgebra]
  simp only [NatIso.isIso_inv_app, Cat.comp_obj, Category.id_comp, Functor.map_comp,
    Functor.map_inv, Category.assoc]
  congr 1
  simp_rw [‚Üê Category.assoc]
  congr 1
  rw [‚Üê NatIso.isIso_inv_app]
  exact (inv (F.baseChange (sq i‚ÇÅ i‚ÇÇ).isPullback.toCommSq.flip.op.toLoc)).naturality _

set_option maxHeartbeats 202000 in
-- TODO: this proof needs improvement
private lemma pullHom''_correction (i‚ÇÅ i‚ÇÇ i‚ÇÉ : Œπ) :
    pullHom'' (hom i‚ÇÅ i‚ÇÉ) (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÉ (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÉ ‚â´
        correction sq‚ÇÉ obj i‚ÇÅ i‚ÇÇ i‚ÇÉ =
    dataEquivCoalgebra hom i‚ÇÅ i‚ÇÉ ‚â´
      (F.map (f i‚ÇÅ).op.toLoc).l.map ((F.map (f i‚ÇÇ).op.toLoc).adj.unit.app
        ((F.map (f i‚ÇÉ).op.toLoc).r.toPrefunctor.1 (obj i‚ÇÉ))) := by
  dsimp only [pullHom'', Cat.comp_obj, Adj.comp_r, Adj.rIso_inv, Adj.comp_l, Adj.lIso_inv,
    dataEquivCoalgebra, Equiv.piCongrRight_apply, Pi.map_apply, Iso.homCongr_apply, Iso.refl_inv,
    Iso.app_hom, Iso.symm_hom, asIso_inv]
  simp only [Category.assoc, NatIso.isIso_inv_app, Cat.comp_obj, Category.id_comp]
  congr 1
  simp only [correction, Adj.comp_l, Cat.comp_obj, Adj.comp_r, Functor.map_inv,
    NatTrans.naturality_assoc, Cat.comp_map, IsIso.eq_inv_comp]
  have h := F.baseChange_triple (sq i‚ÇÅ i‚ÇÇ).isPullback.toCommSq.flip.op.toLoc
    (sq i‚ÇÇ i‚ÇÉ).isPullback.toCommSq.flip.op.toLoc
    (sq i‚ÇÅ i‚ÇÉ).isPullback.toCommSq.flip.op.toLoc
    (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).isPullback‚ÇÅ.op.toLoc
    (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).isPullback‚ÇÇ.flip.op.toLoc
    (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).isPullback‚ÇÉ.op.toLoc
  have h' := congr($(h).app (obj i‚ÇÉ))
  simp only [Cat.comp_obj, Cat.comp_app, Cat.id_obj, Cat.whiskerLeft_app, Cat.leftUnitor_inv_app,
    eqToHom_refl, Cat.whiskerRight_app, Cat.associator_hom_app, Category.comp_id, Category.id_comp,
    Adj.comp_r, Bicategory.whiskerRight_comp, Adj.comp_l, Category.assoc,
    pentagon_hom_inv_inv_inv_inv_assoc, pentagon_hom_hom_inv_hom_hom_assoc, Cat.associator_inv_app,
    Functor.map_id] at h'
  rw [reassoc_of% h', F.isoMapOfCommSq_eq _ (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ.op.toLoc (by aesoptoloc),
    F.isoMapOfCommSq_eq _ (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÉ.op.toLoc (by aesoptoloc)]
  simp only [Iso.trans_hom, Iso.symm_hom, Adj.comp_œÑl, Adj.comp_l, Cat.comp_app, Cat.comp_obj,
    Functor.map_comp, Adj.comp_œÑr, Adj.comp_r, Category.assoc, Adj.inv_hom_id_œÑr_app_assoc,
    Adj.hom_inv_id_œÑr_app_assoc]
  nth_rw 4 [‚Üê (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).r.map_comp_assoc]
  rw [‚Üê (F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÇ.op.toLoc).r.map_comp]
  simp only [Adj.hom_inv_id_œÑl_app, Functor.map_id, Category.id_comp]
  nth_rw 3 [‚Üê (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).r.map_comp_assoc]
  rw [‚Üê (F.map (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÇ.op.toLoc).r.map_comp]
  simp only [Adj.inv_hom_id_œÑl_app, Functor.map_id, Category.comp_id]
  simp only [Adj.comp_l, Cat.comp_obj, Functor.map_id, Category.id_comp, IsIso.hom_inv_id_assoc]
  erw [‚Üê NatTrans.naturality_assoc]
  simp only [Cat.comp_obj, Cat.comp_map]
  rw [CategoryTheory.NatIso.isIso_inv_app]
  simp

lemma hom_comp_iff_dataEquivCoalgebra (i‚ÇÅ i‚ÇÇ i‚ÇÉ : Œπ) :
    homComp sq‚ÇÉ hom i‚ÇÅ i‚ÇÇ i‚ÇÉ = pullHom'' (hom i‚ÇÅ i‚ÇÉ) (sq‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ).p‚ÇÅ‚ÇÉ _ _ ‚Üî
    dataEquivCoalgebra hom i‚ÇÅ i‚ÇÇ ‚â´ (F.map (f i‚ÇÅ).op.toLoc).l.map
      ((F.map (f i‚ÇÇ).op.toLoc).r.map (dataEquivCoalgebra hom i‚ÇÇ i‚ÇÉ)) =
    dataEquivCoalgebra hom i‚ÇÅ i‚ÇÉ ‚â´
      (F.map (f i‚ÇÅ).op.toLoc).l.map ((F.map (f i‚ÇÇ).op.toLoc).adj.unit.app _) := by
  conv_lhs => rw [‚Üê cancel_mono (correction sq‚ÇÉ obj i‚ÇÅ i‚ÇÇ i‚ÇÉ)]
  rw [homComp_correction, pullHom''_correction]

variable
  (obj‚ÇÅ obj‚ÇÇ : (i : Œπ) ‚Üí (F.obj { as := op (X i) }).obj)
  (hom‚ÇÅ : (i‚ÇÅ i‚ÇÇ : Œπ) ‚Üí obj‚ÇÅ i‚ÇÅ ‚ü∂
    (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).r.obj ((F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÇ.op.toLoc).l.obj (obj‚ÇÅ i‚ÇÇ)))
  (hom‚ÇÇ : (i‚ÇÅ i‚ÇÇ : Œπ) ‚Üí obj‚ÇÇ i‚ÇÅ ‚ü∂
    (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).r.obj ((F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÇ.op.toLoc).l.obj (obj‚ÇÇ i‚ÇÇ)))
  (hom : (i : Œπ) ‚Üí obj‚ÇÅ i ‚ü∂ obj‚ÇÇ i)

lemma hom_comm_iff_dataEquivCoalgebra (i‚ÇÅ i‚ÇÇ : Œπ) :
    hom‚ÇÅ i‚ÇÅ i‚ÇÇ ‚â´ (F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÅ.op.toLoc).r.map
      ((F.map (sq i‚ÇÅ i‚ÇÇ).p‚ÇÇ.op.toLoc).l.map (hom i‚ÇÇ)) = hom i‚ÇÅ ‚â´ hom‚ÇÇ i‚ÇÅ i‚ÇÇ ‚Üî
    dataEquivCoalgebra hom‚ÇÅ i‚ÇÅ i‚ÇÇ ‚â´
        (F.map (f i‚ÇÅ).op.toLoc).l.map ((F.map (f i‚ÇÇ).op.toLoc).r.map (hom i‚ÇÇ)) =
      hom i‚ÇÅ ‚â´ dataEquivCoalgebra hom‚ÇÇ i‚ÇÅ i‚ÇÇ := by
  obtain ‚ü®hom‚ÇÅ, rfl‚ü© := dataEquivCoalgebra.symm.surjective hom‚ÇÅ
  obtain ‚ü®hom‚ÇÇ, rfl‚ü© := dataEquivCoalgebra.symm.surjective hom‚ÇÇ
  simp only [dataEquivCoalgebra, Equiv.piCongrRight_symm_apply, Pi.map_apply, Iso.homCongr_symm,
    Iso.refl_symm, Iso.homCongr_apply, Iso.refl_inv, Iso.symm_hom, Iso.app_inv, Iso.symm_inv,
    asIso_hom, Category.id_comp, Category.assoc, Equiv.piCongrRight_apply, Iso.app_hom, asIso_inv,
    NatIso.isIso_inv_app, Cat.comp_obj, IsIso.hom_inv_id, Category.comp_id]
  conv_rhs =>
    rw [‚Üê cancel_mono ((F.baseChange (sq i‚ÇÅ i‚ÇÇ).isPullback.toCommSq.flip.op.toLoc).app (obj‚ÇÇ i‚ÇÇ))]
  simp_rw [Category.assoc]
  congr! 2
  exact ((F.baseChange (sq i‚ÇÅ i‚ÇÇ).isPullback.toCommSq.flip.op.toLoc).naturality _).symm

end

end DescentData''

end Pseudofunctor

end CategoryTheory
