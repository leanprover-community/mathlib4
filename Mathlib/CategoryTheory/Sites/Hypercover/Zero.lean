/-
Copyright (c) 2025 Christian Merten. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Christian Merten
-/
module

public import Mathlib.CategoryTheory.Sites.Precoverage

/-!
# 0-hypercovers

Given a coverage `J` on a category `C`, we define the type
of `0`-hypercovers of an object `S : C`. They consist of a covering family
of morphisms `X i ‚ü∂ S` indexed by a type `I‚ÇÄ` such that the induced presieve is in `J`.

We define this with respect to a coverage and not to a Grothendieck topology, because this
yields more control over the components of the cover.
-/

@[expose] public section

universe w'' w' w v u

namespace CategoryTheory

open Category Limits

variable {C : Type u} [Category.{v} C]

/-- The categorical data that is involved in a `0`-hypercover of an object `S`. This
consists of a family of morphisms `f i : X i ‚ü∂ S` for `i : I‚ÇÄ`. -/
@[ext]
structure PreZeroHypercover (S : C) where
  /-- the index type of the covering of `S` -/
  I‚ÇÄ : Type w
  /-- the objects in the covering of `S` -/
  X (i : I‚ÇÄ) : C
  /-- the morphisms in the covering of `S` -/
  f (i : I‚ÇÄ) : X i ‚ü∂ S

namespace PreZeroHypercover

variable {S T : C} (E : PreZeroHypercover.{w} S) (F : PreZeroHypercover.{w'} S)

/-- The assumption that the pullback of `X i‚ÇÅ` and `X i‚ÇÇ` over `S` exists
for any `i‚ÇÅ` and `i‚ÇÇ`. -/
abbrev HasPullbacks := ‚àÄ (i‚ÇÅ i‚ÇÇ : E.I‚ÇÄ), HasPullback (E.f i‚ÇÅ) (E.f i‚ÇÇ)

/-- The presieve of `S` that is generated by the morphisms `f i : X i ‚ü∂ S`. -/
abbrev presieve‚ÇÄ : Presieve S := .ofArrows _ E.f

@[simp]
lemma presieve‚ÇÄ_f (i : E.I‚ÇÄ) : E.presieve‚ÇÄ (E.f i) := ‚ü®i‚ü©

grind_pattern presieve‚ÇÄ_f => E.presieve‚ÇÄ (E.f i)

/-- The sieve of `S` that is generated by the morphisms `f i : X i ‚ü∂ S`. -/
abbrev sieve‚ÇÄ : Sieve S := .ofArrows _ E.f

lemma sieve‚ÇÄ_f (i : E.I‚ÇÄ) : E.sieve‚ÇÄ (E.f i) := ‚ü®_, ùüô _, E.f i, ‚ü®i‚ü©, by simp‚ü©

grind_pattern sieve‚ÇÄ_f => E.sieve‚ÇÄ (E.f i)

/-- The pre-`0`-hypercover defined by a single morphism. -/
@[simps]
def singleton (f : S ‚ü∂ T) : PreZeroHypercover.{w} T where
  I‚ÇÄ := PUnit
  X _ := S
  f _ := f

@[simp]
lemma presieve‚ÇÄ_singleton (f : S ‚ü∂ T) : (singleton f).presieve‚ÇÄ = .singleton f := by
  simp [singleton, presieve‚ÇÄ, Presieve.ofArrows_pUnit]

instance (f : S ‚ü∂ T) : Unique (PreZeroHypercover.singleton f).I‚ÇÄ :=
  inferInstanceAs <| Unique PUnit

/-- Pullback of a pre-`0`-hypercover along a morphism. The components are `pullback f (E.f i)`. -/
@[simps]
noncomputable
def pullback‚ÇÅ (f : S ‚ü∂ T) (E : PreZeroHypercover.{w} T) [‚àÄ i, HasPullback f (E.f i)] :
    PreZeroHypercover.{w} S where
  I‚ÇÄ := E.I‚ÇÄ
  X i := pullback f (E.f i)
  f _ := pullback.fst _ _

/-- Pullback of a pre-`0`-hypercover along a morphism. The components are `pullback (E.f i) f`. -/
@[simps]
noncomputable
def pullback‚ÇÇ (f : S ‚ü∂ T) (E : PreZeroHypercover.{w} T) [‚àÄ i, HasPullback (E.f i) f] :
    PreZeroHypercover.{w} S where
  I‚ÇÄ := E.I‚ÇÄ
  X i := pullback (E.f i) f
  f _ := pullback.snd _ _

lemma presieve‚ÇÄ_pullback‚ÇÅ (f : S ‚ü∂ T) (E : PreZeroHypercover.{w} T) [‚àÄ i, HasPullback (E.f i) f] :
    presieve‚ÇÄ (E.pullback‚ÇÇ f) = E.presieve‚ÇÄ.pullbackArrows f := by
  refine le_antisymm ?_ ?_
  ¬∑ rintro - - ‚ü®i‚ü©
    use _, _, i
  ¬∑ rintro W g ‚ü®-, -, ‚ü®i‚ü©‚ü©
    use i

/-- If `{U·µ¢}` covers `X`, this is the pre-`0`-hypercover of `X √ó[Z] Y` given by `{U·µ¢ √ó[Z] Y}`. -/
@[simps]
noncomputable def pullbackCoverOfLeft {X : C} (E : PreZeroHypercover X) {Y Z : C}
    (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [HasPullback f g] [‚àÄ i, HasPullback (E.f i ‚â´ f) g] :
    PreZeroHypercover (pullback f g) where
  I‚ÇÄ := E.I‚ÇÄ
  X i := pullback (E.f i ‚â´ f) g
  f i := pullback.map _ _ _ _ (E.f i) (ùüô Y) (ùüô Z) (by simp) (by simp)

/-- If `{U·µ¢}` covers `Y`, this is the pre-`0`-hypercover of `X √ó[Z] Y` given by `{X √ó[Z] U·µ¢}`. -/
@[simps]
noncomputable def pullbackCoverOfRight {Y : C} (E : PreZeroHypercover.{w} Y) {X Z : C}
    (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [HasPullback f g] [‚àÄ i, HasPullback f (E.f i ‚â´ g)] :
    PreZeroHypercover.{w} (pullback f g) where
  I‚ÇÄ := E.I‚ÇÄ
  X i := pullback f (E.f i ‚â´ g)
  f i := pullback.map _ _ _ _ (ùüô X) (E.f i) (ùüô Z) (by simp) (by simp)

/-- Refining each component of a pre-`0`-hypercover yields a refined pre-`0`-hypercover of the
base. -/
@[simps]
def bind (E : PreZeroHypercover.{w} T) (F : ‚àÄ i, PreZeroHypercover.{w'} (E.X i)) :
    PreZeroHypercover.{max w w'} T where
  I‚ÇÄ := Œ£ (i : E.I‚ÇÄ), (F i).I‚ÇÄ
  X ij := (F ij.1).X ij.2
  f ij := (F ij.1).f ij.2 ‚â´ E.f ij.1

/-- Restrict the indexing type to `Œπ` by precomposing with a function `Œπ ‚Üí E.I‚ÇÄ`. -/
@[simps]
def restrictIndex (E : PreZeroHypercover.{w} T) {Œπ : Type w'} (f : Œπ ‚Üí E.I‚ÇÄ) :
    PreZeroHypercover.{w'} T where
  I‚ÇÄ := Œπ
  X := E.X ‚àò f
  f i := E.f (f i)

@[simp]
lemma presieve‚ÇÄ_restrictIndex_equiv {Œπ : Type w'} (e : Œπ ‚âÉ E.I‚ÇÄ) :
    (E.restrictIndex e).presieve‚ÇÄ = E.presieve‚ÇÄ := by
  refine le_antisymm (fun Y g ‚ü®i‚ü© ‚Ü¶ ‚ü®e i‚ü©) fun Y g ‚ü®i‚ü© ‚Ü¶ ?_
  obtain ‚ü®i, rfl‚ü© := e.surjective i
  exact ‚ü®i‚ü©

/-- Replace the indexing type of a pre-`0`-hypercover. -/
@[simps!]
def reindex (E : PreZeroHypercover.{w} T) {Œπ : Type w'} (e : Œπ ‚âÉ E.I‚ÇÄ) :
    PreZeroHypercover.{w'} T :=
  E.restrictIndex e

@[simp]
lemma presieve‚ÇÄ_reindex {Œπ : Type w'} (e : Œπ ‚âÉ E.I‚ÇÄ) : (E.reindex e).presieve‚ÇÄ = E.presieve‚ÇÄ := by
  simp [reindex]

/-- Pairwise intersection of two pre-`0`-hypercovers. -/
@[simps!]
noncomputable
def inter (E : PreZeroHypercover.{w} T) (F : PreZeroHypercover.{w'} T)
    [‚àÄ i j, HasPullback (E.f i) (F.f j)] :
    PreZeroHypercover.{max w w'} T :=
  (E.bind (fun i ‚Ü¶ F.pullback‚ÇÅ (E.f i))).reindex (Equiv.sigmaEquivProd _ _).symm

lemma inter_def [‚àÄ i j, HasPullback (E.f i) (F.f j)] :
    E.inter F = (E.bind (fun i ‚Ü¶ F.pullback‚ÇÅ (E.f i))).reindex (Equiv.sigmaEquivProd _ _).symm :=
  rfl

/-- Disjoint union of two pre-`0`-hypercovers. -/
@[simps I‚ÇÄ, simps -isSimp X f]
def sum {X : C} (E : PreZeroHypercover.{w} X) (F : PreZeroHypercover.{w'} X) :
    PreZeroHypercover.{max w w'} X where
  I‚ÇÄ := E.I‚ÇÄ ‚äï F.I‚ÇÄ
  X := Sum.elim E.X F.X
  f
    | .inl i => E.f i
    | .inr i => F.f i

@[simp] lemma sum_X_inl (i : E.I‚ÇÄ) : (E.sum F).X (.inl i) = E.X i := rfl

@[simp] lemma sum_X_inr (i : F.I‚ÇÄ) : (E.sum F).X (.inr i) = F.X i := rfl

@[simp] lemma sum_f_inl (i : E.I‚ÇÄ) : (E.sum F).f (.inl i) = E.f i := rfl

@[simp] lemma sum_f_inr (i : F.I‚ÇÄ) : (E.sum F).f (.inr i) = F.f i := rfl

@[simp]
lemma presieve‚ÇÄ_sum : (E.sum F).presieve‚ÇÄ = E.presieve‚ÇÄ ‚äî F.presieve‚ÇÄ := by
  rw [presieve‚ÇÄ, presieve‚ÇÄ, presieve‚ÇÄ]
  apply le_antisymm
  ¬∑ intro Z g ‚ü®i‚ü©
    cases i
    ¬∑ exact Or.inl (.mk _)
    ¬∑ exact Or.inr (.mk _)
  ¬∑ rintro Z g (‚ü®‚ü®i‚ü©‚ü© | ‚ü®‚ü®i‚ü©‚ü©)
    ¬∑ exact ‚ü®Sum.inl i‚ü©
    ¬∑ exact ‚ü®Sum.inr i‚ü©

/-- Add a morphism to a pre-`0`-hypercover. -/
@[simps! I‚ÇÄ]
def add (E : PreZeroHypercover.{w} S) {T : C} (f : T ‚ü∂ S) : PreZeroHypercover.{w} S :=
  (E.sum (.singleton f)).reindex (Equiv.optionEquivSumPUnit.{0} E.I‚ÇÄ)

@[simp] lemma add_X_some {T : C} (f : T ‚ü∂ S) (i : E.I‚ÇÄ) : (E.add f).X (some i) = E.X i := rfl

@[simp] lemma add_X_none {T : C} (f : T ‚ü∂ S) : (E.add f).X none = T := rfl

@[simp] lemma add_f_some {T : C} (f : T ‚ü∂ S) (i : E.I‚ÇÄ) : (E.add f).f (some i) = E.f i := rfl

@[simp] lemma add_f_nome {T : C} (f : T ‚ü∂ S) : (E.add f).f none = f := rfl

@[simp] lemma presieve‚ÇÄ_add {T : C} (f : T ‚ü∂ S) :
    (E.add f).presieve‚ÇÄ = E.presieve‚ÇÄ ‚äî .singleton f := by
  simp [add, presieve‚ÇÄ_reindex, presieve‚ÇÄ_sum]

/-- The single object pre-`0`-hypercover obtained from taking the coproduct of the components. -/
@[simps I‚ÇÄ X]
def sigmaOfIsColimit (E : PreZeroHypercover.{w} S) {c : Cofan E.X} (hc : IsColimit c) :
    PreZeroHypercover.{w} S where
  I‚ÇÄ := PUnit
  X _ := c.pt
  f _ := Cofan.IsColimit.desc hc E.f

@[reassoc (attr := simp)]
lemma inj_sigmaOfIsColimit_f (E : PreZeroHypercover.{w} S) {c : Cofan E.X} (hc : IsColimit c)
    (i : E.I‚ÇÄ) (r : PUnit) :
    c.inj i ‚â´ (E.sigmaOfIsColimit hc).f r = E.f i := by
  simp [PreZeroHypercover.sigmaOfIsColimit]

section Category

variable {E : PreZeroHypercover.{w} S} {F : PreZeroHypercover.{w'} S}

/-- A morphism of pre-`0`-hypercovers of `S` is a family of refinement morphisms commuting
with the structure morphisms of `E` and `F`. -/
@[ext]
structure Hom (E : PreZeroHypercover.{w} S) (F : PreZeroHypercover.{w'} S) where
  /-- The map between indexing types of the coverings of `S` -/
  s‚ÇÄ (i : E.I‚ÇÄ) : F.I‚ÇÄ
  /-- The refinement morphisms between objects in the coverings of `S`. -/
  h‚ÇÄ (i : E.I‚ÇÄ) : E.X i ‚ü∂ F.X (s‚ÇÄ i)
  w‚ÇÄ (i : E.I‚ÇÄ) : h‚ÇÄ i ‚â´ F.f (s‚ÇÄ i) = E.f i := by cat_disch

attribute [reassoc (attr := simp)] Hom.w‚ÇÄ

/-- The identity refinement of a pre-`0`-hypercover. -/
@[simps]
def Hom.id (E : PreZeroHypercover S) : Hom E E where
  s‚ÇÄ := _root_.id
  h‚ÇÄ _ := ùüô _

variable {G : PreZeroHypercover S}

/-- Composition of refinement morphisms of pre-`0`-hypercovers. -/
@[simps]
def Hom.comp (f : E.Hom F) (g : F.Hom G) : E.Hom G where
  s‚ÇÄ := g.s‚ÇÄ ‚àò f.s‚ÇÄ
  h‚ÇÄ i := f.h‚ÇÄ i ‚â´ g.h‚ÇÄ _

@[simps! id_s‚ÇÄ id_h‚ÇÄ comp_s‚ÇÄ comp_h‚ÇÄ]
instance : Category (PreZeroHypercover S) where
  Hom := Hom
  id E := Hom.id E
  comp f g := f.comp g

lemma Hom.ext' {E : PreZeroHypercover.{w} S} {F : PreZeroHypercover.{w'} S}
    {f g : E.Hom F} (hs : f.s‚ÇÄ = g.s‚ÇÄ) (hh : ‚àÄ i, f.h‚ÇÄ i = g.h‚ÇÄ i ‚â´ eqToHom (by rw [hs])) :
    f = g := by
  cases f
  cases g
  simp only at hs
  cat_disch

lemma Hom.ext'_iff {E : PreZeroHypercover.{w} S} {F : PreZeroHypercover.{w'} S}
    {f g : E.Hom F} :
    f = g ‚Üî ‚àÉ (hs : f.s‚ÇÄ = g.s‚ÇÄ), ‚àÄ i, f.h‚ÇÄ i = g.h‚ÇÄ i ‚â´ eqToHom (by rw [hs]) :=
  ‚ü®fun h ‚Ü¶ h ‚ñ∏ by simp, fun ‚ü®hs, hh‚ü© ‚Ü¶ Hom.ext' hs hh‚ü©

/-- Constructor for isomorphisms of pre-`0`-hypercovers. -/
@[simps]
def isoMk {S : C} {E F : PreZeroHypercover.{w} S}
    (s‚ÇÄ : E.I‚ÇÄ ‚âÉ F.I‚ÇÄ) (h‚ÇÄ : ‚àÄ i, E.X i ‚âÖ F.X (s‚ÇÄ i))
    (w‚ÇÄ : ‚àÄ i, (h‚ÇÄ i).hom ‚â´ F.f _ = E.f _ := by cat_disch) :
    E ‚âÖ F where
  hom.s‚ÇÄ := s‚ÇÄ
  hom.h‚ÇÄ i := (h‚ÇÄ i).hom
  inv.s‚ÇÄ := s‚ÇÄ.symm
  inv.h‚ÇÄ i := eqToHom (by simp) ‚â´ (h‚ÇÄ _).inv
  inv.w‚ÇÄ i := by
    obtain ‚ü®i, rfl‚ü© := s‚ÇÄ.surjective i
    simp only [‚Üê cancel_epi (h‚ÇÄ i).hom, w‚ÇÄ, Category.assoc, Equiv.symm_apply_apply,
      eqToHom_iso_hom_naturality_assoc, Iso.hom_inv_id_assoc]
    rw [‚Üê CategoryTheory.eqToHom_naturality _ (by simp)]
    simp
  hom_inv_id := Hom.ext' (by ext; simp) (fun i ‚Ü¶ by simp)
  inv_hom_id := Hom.ext' (by ext; simp) (fun i ‚Ü¶ by simp)

@[simp]
lemma hom_inv_s‚ÇÄ_apply {E F : PreZeroHypercover.{w} S} (e : E ‚âÖ F) (i : E.I‚ÇÄ) :
    e.inv.s‚ÇÄ (e.hom.s‚ÇÄ i) = i :=
  congr($(e.hom_inv_id).s‚ÇÄ i)

@[simp]
lemma inv_hom_s‚ÇÄ_apply {E F : PreZeroHypercover.{w} S} (e : E ‚âÖ F) (i : F.I‚ÇÄ) :
    e.hom.s‚ÇÄ (e.inv.s‚ÇÄ i) = i :=
  congr($(e.inv_hom_id).s‚ÇÄ i)

@[reassoc (attr := simp)]
lemma hom_inv_h‚ÇÄ {E F : PreZeroHypercover.{w} S} (e : E ‚âÖ F) (i : E.I‚ÇÄ) :
    e.hom.h‚ÇÄ i ‚â´ e.inv.h‚ÇÄ (e.hom.s‚ÇÄ i) = eqToHom (by simp) := by
  obtain ‚ü®hs, hh‚ü© := Hom.ext'_iff.mp e.hom_inv_id
  simpa using hh i

@[reassoc (attr := simp)]
lemma inv_hom_h‚ÇÄ {E F : PreZeroHypercover.{w} S} (e : E ‚âÖ F) (i : F.I‚ÇÄ) :
    e.inv.h‚ÇÄ i ‚â´ e.hom.h‚ÇÄ (e.inv.s‚ÇÄ i) = eqToHom (by simp) := by
  obtain ‚ü®hs, hh‚ü© := Hom.ext'_iff.mp e.inv_hom_id
  simpa using hh i

instance {E F : PreZeroHypercover.{w} S} (e : E ‚âÖ F) (i : E.I‚ÇÄ) :
    IsIso (e.hom.h‚ÇÄ i) := by
  use e.inv.h‚ÇÄ (e.hom.s‚ÇÄ i) ‚â´ eqToHom (by simp)
  rw [hom_inv_h‚ÇÄ_assoc, eqToHom_trans, eqToHom_refl, Category.assoc,
    ‚Üê eqToHom_naturality _ (by simp), inv_hom_h‚ÇÄ_assoc]
  simp

instance {E F : PreZeroHypercover.{w} S} (e : E ‚âÖ F) (i : F.I‚ÇÄ) :
    IsIso (e.inv.h‚ÇÄ i) :=
  .of_isIso_fac_right (inv_hom_h‚ÇÄ e i)

@[reassoc (attr := simp)]
lemma inv_hom_h‚ÇÄ_comp_f {E F : PreZeroHypercover.{w} S} (e : E ‚âÖ F) (i : E.I‚ÇÄ) :
    inv (e.hom.h‚ÇÄ i) ‚â´ E.f i = F.f _ := by simp

@[reassoc (attr := simp)]
lemma inv_inv_h‚ÇÄ_comp_f {E F : PreZeroHypercover.{w} S} (e : E ‚âÖ F) (i : F.I‚ÇÄ) :
    inv (e.inv.h‚ÇÄ i) ‚â´ F.f i = E.f _ := by simp

end Category

section Functoriality

variable {D : Type*} [Category* D] {F : C ‚•§ D}

/-- The image of a pre-`0`-hypercover under a functor. -/
@[simps]
def map (F : C ‚•§ D) (E : PreZeroHypercover.{w} S) : PreZeroHypercover.{w} (F.obj S) where
  I‚ÇÄ := E.I‚ÇÄ
  X i := F.obj (E.X i)
  f i := F.map (E.f i)

lemma presieve‚ÇÄ_map : (E.map F).presieve‚ÇÄ = E.presieve‚ÇÄ.map F :=
  (Presieve.map_ofArrows _).symm

end Functoriality

/-- Pullback symmetry isomorphism. -/
@[simps]
noncomputable def pullbackIso {S T : C} (f : S ‚ü∂ T) (E : PreZeroHypercover.{w} T)
    [‚àÄ (i : E.I‚ÇÄ), HasPullback f (E.f i)] [‚àÄ (i : E.I‚ÇÄ), HasPullback (E.f i) f] :
    E.pullback‚ÇÅ f ‚âÖ E.pullback‚ÇÇ f where
  hom.s‚ÇÄ := id
  hom.h‚ÇÄ i := (pullbackSymmetry _ _).hom
  inv.s‚ÇÄ := id
  inv.h‚ÇÄ i := (pullbackSymmetry _ _).inv
  hom_inv_id := by
    apply Hom.ext (by rfl)
    simp only [heq_eq_eq]
    ext i
    simp
  inv_hom_id := by
    apply Hom.ext (by rfl)
    simp only [heq_eq_eq]
    ext i
    simp

section

variable (F : PreZeroHypercover.{w'} S) {G : PreZeroHypercover.{w''} S}

/-- The left inclusion into the disjoint union. -/
@[simps]
def sumInl : E.Hom (E.sum F) where
  s‚ÇÄ := Sum.inl
  h‚ÇÄ _ := ùüô _

/-- The right inclusion into the disjoint union. -/
@[simps]
def sumInr : F.Hom (E.sum F) where
  s‚ÇÄ := Sum.inr
  h‚ÇÄ _ := ùüô _

variable {E F} in
/-- To give a refinement of the disjoint union, it suffices to give refinements of both
components. -/
@[simps]
def sumLift (f : E.Hom G) (g : F.Hom G) : (E.sum F).Hom G where
  s‚ÇÄ := Sum.elim f.s‚ÇÄ g.s‚ÇÄ
  h‚ÇÄ
    | .inl i => f.h‚ÇÄ i
    | .inr i => g.h‚ÇÄ i

variable [‚àÄ (i : E.I‚ÇÄ) (j : F.I‚ÇÄ), HasPullback (E.f i) (F.f j)]

/-- First projection from the intersection of two pre-`0`-hypercovers. -/
@[simps]
noncomputable
def interFst : Hom (inter E F) E where
  s‚ÇÄ i := i.1
  h‚ÇÄ _ := pullback.fst _ _

/-- Second projection from the intersection of two pre-`0`-hypercovers. -/
@[simps]
noncomputable
def interSnd : Hom (inter E F) F where
  s‚ÇÄ i := i.2
  h‚ÇÄ _ := pullback.snd _ _
  w‚ÇÄ i := by simp [‚Üê pullback.condition]

variable {E F} in
/-- Universal property of the intersection of two pre-`0`-hypercovers. -/
@[simps]
noncomputable
def interLift (f : G.Hom E) (g : G.Hom F) :
    G.Hom (E.inter F) where
  s‚ÇÄ i := ‚ü®f.s‚ÇÄ i, g.s‚ÇÄ i‚ü©
  h‚ÇÄ i := pullback.lift (f.h‚ÇÄ i) (g.h‚ÇÄ i) (by simp)

end

/-- If `{U·µ¢}` covers `X`, the pre-`0`-hypercover `{U·µ¢ √ó[Z] Y}` of `X √ó[Z] Y` is isomorphic
to the pullback of `{U·µ¢}` along the first projection. -/
noncomputable
def pullbackCoverOfLeftIsoPullback‚ÇÅ {X : C} (E : PreZeroHypercover X) {Y Z : C}
    (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [HasPullback f g] [‚àÄ i, HasPullback (pullback.fst f g) (E.f i)]
    [‚àÄ i, HasPullback (E.f i) (pullback.fst f g)] :
    E.pullbackCoverOfLeft f g ‚âÖ pullback‚ÇÅ (pullback.fst f g) E :=
  PreZeroHypercover.isoMk (.refl _)
    (fun _ ‚Ü¶ (pullbackRightPullbackFstIso _ _ _).symm ‚â™‚â´ pullbackSymmetry _ _)

/-- If `{U·µ¢}` covers `Y`, the pre-`0`-hypercover `{X √ó[Z] U·µ¢}` of `X √ó[Z] Y` is isomorphic
to the pullback of `{U·µ¢}` along the second projection. -/
noncomputable
def pullbackCoverOfRightIsoPullback‚ÇÇ {Y : C} (E : PreZeroHypercover Y) {X Z : C}
    (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [HasPullback f g] [‚àÄ (i : E.I‚ÇÄ), HasPullback (E.f i) (pullback.snd f g)]
    [‚àÄ i, HasPullback (pullback.snd f g) (E.f i)] :
    E.pullbackCoverOfRight f g ‚âÖ pullback‚ÇÇ (pullback.snd f g) E :=
  PreZeroHypercover.isoMk (.refl _)
    (fun _ ‚Ü¶ (pullbackLeftPullbackSndIso _ _ _).symm ‚â™‚â´ pullbackSymmetry _ _)

end PreZeroHypercover

/-- The pre-`0`-hypercover associated to a presieve `R`. It is indexed by the morphisms in `R`. -/
@[simps -isSimp]
def Presieve.preZeroHypercover {S : C} (R : Presieve S) : PreZeroHypercover.{max u v} S where
  I‚ÇÄ := R.uncurry
  X i := i.1.1
  f i := i.1.2

@[simp]
lemma Presieve.presieve‚ÇÄ_preZeroHypercover {S : C} (R : Presieve S) :
    R.preZeroHypercover.presieve‚ÇÄ = R := by
  refine le_antisymm ?_ ?_
  ¬∑ rintro - - ‚ü®i‚ü©
    exact i.2
  ¬∑ intro Y f h
    let i : R.uncurry := ‚ü®‚ü®Y, f‚ü©, h‚ü©
    exact .mk i

lemma Presieve.exists_eq_preZeroHypercover {S : C} (R : Presieve S) :
    ‚àÉ (E : PreZeroHypercover.{max u v} S), R = E.presieve‚ÇÄ :=
  ‚ü®R.preZeroHypercover, by simp‚ü©

/-- The deduplication of a pre-`0`-hypercover `E` in universe `w` to a pre-`0`-hypercover in
universe `max u v`. This is indexed by the morphisms of `E`. -/
@[simps! -isSimp]
def PreZeroHypercover.shrink {S : C} (E : PreZeroHypercover.{w} S) :
    PreZeroHypercover.{max u v} S :=
  E.presieve‚ÇÄ.preZeroHypercover

@[simp]
lemma PreZeroHypercover.presieve‚ÇÄ_shrink {S : C} (E : PreZeroHypercover.{w} S) :
    E.shrink.presieve‚ÇÄ = E.presieve‚ÇÄ :=
  E.presieve‚ÇÄ.presieve‚ÇÄ_preZeroHypercover

lemma PreZeroHypercover.shrink_eq_shrink_of_presieve‚ÇÄ_eq_presieve‚ÇÄ {S : C}
    {E F : PreZeroHypercover.{w} S} (h : E.presieve‚ÇÄ = F.presieve‚ÇÄ) :
    E.shrink = F.shrink := by
  rw [shrink, shrink, h]

lemma PreZeroHypercover.presieve‚ÇÄ_eq_presieve‚ÇÄ_iff {S : C} {E F : PreZeroHypercover.{w} S} :
    E.presieve‚ÇÄ = F.presieve‚ÇÄ ‚Üî E.shrink = F.shrink := by
  refine ‚ü®fun h ‚Ü¶ shrink_eq_shrink_of_presieve‚ÇÄ_eq_presieve‚ÇÄ h, fun h ‚Ü¶ ?_‚ü©
  rw [‚Üê E.presieve‚ÇÄ_shrink, ‚Üê F.presieve‚ÇÄ_shrink, h]

/-- `E` refines its deduplication. -/
def PreZeroHypercover.toShrink {S : C} (E : PreZeroHypercover.{w} S) : E.Hom E.shrink where
  s‚ÇÄ i := ‚ü®‚ü®_, E.f i‚ü©, .mk i‚ü©
  h‚ÇÄ i := ùüô _

/-- The deduplication of `E` refines `E`. -/
noncomputable
def PreZeroHypercover.fromShrink {S : C} (E : PreZeroHypercover.{w} S) : E.shrink.Hom E where
  s‚ÇÄ i := (Presieve.ofArrows_surj _ _ i.2).choose
  h‚ÇÄ i := eqToHom (Presieve.ofArrows_surj _ _ i.2).choose_spec.1.symm
  w‚ÇÄ i := (Presieve.ofArrows_surj _ _ i.2).choose_spec.2.symm

section

/-- A precoverage respects isomorphisms if the property of being covering
is stable under isomorphism.
Use `PreZeroHypercover.presieve‚ÇÄ_mem_of_iso` for no universe restrictions. -/
class Precoverage.RespectsIso (J : Precoverage C) : Prop where
  of_iso {S : C} {E F : PreZeroHypercover.{max u v} S} (e : E ‚âÖ F) :
    E.presieve‚ÇÄ ‚àà J S ‚Üí F.presieve‚ÇÄ ‚àà J S

variable {J : Precoverage C}

lemma Precoverage.RespectsIso.of_forall_exists_iso [J.RespectsIso] {S : C} {R T : Presieve S}
    (hRT : ‚àÄ ‚¶ÉZ : C‚¶Ñ (g : Z ‚ü∂ S), R g ‚Üí ‚àÉ (Y : C) (e : Y ‚âÖ Z), T (e.hom ‚â´ g))
    (hTR : ‚àÄ ‚¶ÉZ : C‚¶Ñ (g : Z ‚ü∂ S), T g ‚Üí ‚àÉ (Y : C) (e : Y ‚âÖ Z), R (e.hom ‚â´ g))
    (hR : R ‚àà J S) :
    T ‚àà J S := by
  choose YR eR hTeg using hRT
  choose YT eT hReg using hTR
  let E : PreZeroHypercover S :=
    { I‚ÇÄ := R.uncurry ‚äï T.uncurry
      X i := i.elim (fun j ‚Ü¶ j.1.1) (fun j ‚Ü¶ YT _ j.2)
      f i :=
        match i with
        | .inl i => by exact i.1.2
        | .inr i => by exact (eT _ i.2).hom ‚â´ i.1.2 }
  let F : PreZeroHypercover S :=
    { I‚ÇÄ := R.uncurry ‚äï T.uncurry
      X i := i.elim (fun j ‚Ü¶ YR _ j.2) (fun j ‚Ü¶ j.1.1)
      f i :=
        match i with
        | .inl i => by exact (eR _ i.2).hom ‚â´ i.1.2
        | .inr i => by exact i.1.2 }
  let e : E ‚âÖ F := by
    refine PreZeroHypercover.isoMk (Equiv.refl _) (fun i ‚Ü¶ ?_) (fun i ‚Ü¶ ?_)
    ¬∑ match i with
      | .inl i => dsimp [E, F]; symm; exact eR _ _
      | .inr i => dsimp [E, F]; apply eT
    ¬∑ cases i <;> simp [E, F]
  have hER : E.presieve‚ÇÄ = R := by
    refine le_antisymm ?_ fun Y g hg ‚Ü¶ .mk (Sum.inl (‚ü®‚ü®Y, g‚ü©, hg‚ü© : R.uncurry))
    rintro - - ‚ü®i‚ü©
    match i with
    | .inl i => exact i.2
    | .inr i => apply hReg
  have hFT : F.presieve‚ÇÄ = T := by
    refine le_antisymm ?_ fun Y g hg ‚Ü¶ .mk (Sum.inr (‚ü®‚ü®Y, g‚ü©, hg‚ü© : T.uncurry))
    rintro - - ‚ü®i‚ü©
    match i with
    | .inl i => apply hTeg
    | .inr i => exact i.2
  rw [‚Üê hFT]
  apply RespectsIso.of_iso e
  rwa [hER]

lemma PreZeroHypercover.presieve‚ÇÄ_mem_of_iso [J.RespectsIso] {S : C} {E F : PreZeroHypercover.{w} S}
    (e : E ‚âÖ F) (hE : E.presieve‚ÇÄ ‚àà J S) : F.presieve‚ÇÄ ‚àà J S := by
  refine Precoverage.RespectsIso.of_forall_exists_iso ?_ ?_ hE
  ¬∑ intro Z _ ‚ü®i‚ü©
    use F.X (e.hom.s‚ÇÄ i), (asIso (e.hom.h‚ÇÄ i)).symm
    simp
  ¬∑ intro Z _ ‚ü®i‚ü©
    use E.X (e.inv.s‚ÇÄ i), (asIso (e.inv.h‚ÇÄ i)).symm
    simp

lemma PreZeroHypercover.presieve‚ÇÄ_mem_iff_of_iso [J.RespectsIso] {S : C}
    {E F : PreZeroHypercover.{w} S} (e : E ‚âÖ F) :
    E.presieve‚ÇÄ ‚àà J S ‚Üî F.presieve‚ÇÄ ‚àà J S :=
  ‚ü®fun h ‚Ü¶ E.presieve‚ÇÄ_mem_of_iso e h, fun h ‚Ü¶ F.presieve‚ÇÄ_mem_of_iso e.symm h‚ü©

end

namespace Precoverage

variable {J : Precoverage C}

/-- The type of `0`-hypercovers of an object `S : C` in a category equipped with a
coverage `J`. This can be constructed from a covering of `S`. -/
structure ZeroHypercover (J : Precoverage C) (S : C) extends PreZeroHypercover.{w} S where
  mem‚ÇÄ : toPreZeroHypercover.presieve‚ÇÄ ‚àà J S

namespace ZeroHypercover

variable {S T : C}

/-- The `0`-hypercover defined by a single covering morphism. -/
@[simps toPreZeroHypercover]
def singleton (f : S ‚ü∂ T) (hf : Presieve.singleton f ‚àà J T) :
    J.ZeroHypercover T where
  __ := PreZeroHypercover.singleton f
  mem‚ÇÄ := by
    simpa [PreZeroHypercover.presieve‚ÇÄ, PreZeroHypercover.singleton, Presieve.ofArrows_pUnit]

/-- Pullback of a `0`-hypercover along a morphism. The components are `pullback f (E.f i)`. -/
@[simps toPreZeroHypercover]
noncomputable
def pullback‚ÇÅ [J.IsStableUnderBaseChange] (f : S ‚ü∂ T) (E : ZeroHypercover.{w} J T)
    [‚àÄ i, HasPullback f (E.f i)] : J.ZeroHypercover S where
  __ := E.toPreZeroHypercover.pullback‚ÇÅ f
  mem‚ÇÄ := J.mem_coverings_of_isPullback E.f E.mem‚ÇÄ f _
    (fun _ ‚Ü¶ pullback.snd _ _) fun i ‚Ü¶ IsPullback.of_hasPullback f (E.f i)

/-- Pullback of a `0`-hypercover along a morphism. The components are `pullback (E.f i) f`. -/
@[simps toPreZeroHypercover]
noncomputable
def pullback‚ÇÇ [J.IsStableUnderBaseChange] (f : S ‚ü∂ T) (E : ZeroHypercover.{w} J T)
    [‚àÄ i, HasPullback (E.f i) f] : J.ZeroHypercover S where
  __ := E.toPreZeroHypercover.pullback‚ÇÇ f
  mem‚ÇÄ := J.mem_coverings_of_isPullback E.f E.mem‚ÇÄ f _
    (fun _ ‚Ü¶ pullback.fst _ _) fun i ‚Ü¶ (IsPullback.of_hasPullback (E.f i) f).flip

/-- Refining each component of a `0`-hypercover yields a refined `0`-hypercover of the base. -/
@[simps toPreZeroHypercover]
def bind [J.IsStableUnderComposition] (E : ZeroHypercover.{w} J T)
    (F : ‚àÄ i, ZeroHypercover.{w'} J (E.X i)) :
    ZeroHypercover.{max w w'} J T where
  __ := E.toPreZeroHypercover.bind (fun i ‚Ü¶ (F i).toPreZeroHypercover)
  mem‚ÇÄ :=
    comp_mem_coverings (f := E.f) (g := fun i j ‚Ü¶ (F i).f j) E.mem‚ÇÄ (fun i ‚Ü¶ (F i).mem‚ÇÄ)

/-- Pairwise intersection of two `0`-hypercovers. -/
@[simps toPreZeroHypercover]
noncomputable
def inter [J.IsStableUnderBaseChange] [J.IsStableUnderComposition] (E : ZeroHypercover.{w} J T)
    (F : ZeroHypercover.{w'} J T) [‚àÄ i j, HasPullback (E.f i) (F.f j)] :
    ZeroHypercover.{max w w'} J T where
  __ := E.toPreZeroHypercover.inter F.toPreZeroHypercover
  mem‚ÇÄ := by
    rw [PreZeroHypercover.inter_def, PreZeroHypercover.presieve‚ÇÄ_reindex]
    exact (E.bind (fun i ‚Ü¶ F.pullback‚ÇÅ (E.f i))).mem‚ÇÄ

/-- Replace the indexing type of a `0`-hypercover. -/
@[simps toPreZeroHypercover]
def reindex (E : ZeroHypercover.{w} J T) {Œπ : Type w'} (e : Œπ ‚âÉ E.I‚ÇÄ) :
    ZeroHypercover.{w'} J T where
  __ := E.toPreZeroHypercover.reindex e
  mem‚ÇÄ := by simp [E.mem‚ÇÄ]

/-- Disjoint union of two `0`-hypercovers. -/
@[simps toPreZeroHypercover]
def sum [J.IsStableUnderSup] (E : ZeroHypercover.{w} J S) (F : ZeroHypercover.{w'} J S) :
    ZeroHypercover.{max w w'} J S where
  __ := E.toPreZeroHypercover.sum F.toPreZeroHypercover
  mem‚ÇÄ := by
    rw [PreZeroHypercover.presieve‚ÇÄ_sum]
    exact J.sup_mem_coverings E.mem‚ÇÄ F.mem‚ÇÄ

/-- Add a single morphism to a `0`-hypercover. -/
@[simps toPreZeroHypercover]
def add (E : ZeroHypercover.{w} J S) {T : C} (f : T ‚ü∂ S)
    (hf : E.presieve‚ÇÄ ‚äî Presieve.singleton f ‚àà J S) :
    ZeroHypercover.{w} J S where
  __ := E.toPreZeroHypercover.add f
  mem‚ÇÄ := by rwa [PreZeroHypercover.presieve‚ÇÄ_add]

/-- If `L` is a finer precoverage than `K`, any `0`-hypercover wrt. `K` is in particular
a `0`-hypercover wrt. to `L`. -/
@[simps toPreZeroHypercover]
def weaken {K L : Precoverage C} {X : C} (E : Precoverage.ZeroHypercover K X) (h : K ‚â§ L) :
    Precoverage.ZeroHypercover L X where
  __ := E
  mem‚ÇÄ := h _ E.mem‚ÇÄ

instance (K : Precoverage C) [K.HasPullbacks] {X Y : C} (E : K.ZeroHypercover X) (f : Y ‚ü∂ X) :
    E.presieve‚ÇÄ.HasPullbacks f :=
  K.hasPullbacks_of_mem _ E.mem‚ÇÄ

instance {X Y : C} (E : PreZeroHypercover X) (f : Y ‚ü∂ X) [E.presieve‚ÇÄ.HasPullbacks f]
    (i : E.I‚ÇÄ) : HasPullback (E.f i) f :=
  E.presieve‚ÇÄ.hasPullback f ‚ü®i‚ü©

instance {X Y : C} (E : PreZeroHypercover X) (f : Y ‚ü∂ X) [E.presieve‚ÇÄ.HasPullbacks f]
    (i : E.I‚ÇÄ) : HasPullback f (E.f i) :=
  hasPullback_symmetry (E.f i) f

variable (J) in
/-- A morphism of `0`-hypercovers is a morphism of the underlying pre-`0`-hypercovers. -/
abbrev Hom (E : ZeroHypercover.{w} J S) (F : ZeroHypercover.{w'} J S) :=
  E.toPreZeroHypercover.Hom F.toPreZeroHypercover

@[simps! id_s‚ÇÄ id_h‚ÇÄ comp_s‚ÇÄ comp_h‚ÇÄ]
instance : Category (ZeroHypercover.{w} J S) where
  Hom := Hom J
  id _ := PreZeroHypercover.Hom.id _
  comp := PreZeroHypercover.Hom.comp

/-- An isomorphism in `0`-hypercovers is an isomorphism of the underlying pre-`0`-hypercovers. -/
@[simps]
def isoMk {E F : ZeroHypercover.{w} J S} (e : E.toPreZeroHypercover ‚âÖ F.toPreZeroHypercover) :
    E ‚âÖ F where
  hom := e.hom
  inv := e.inv
  hom_inv_id := e.hom_inv_id
  inv_hom_id := e.inv_hom_id

section Functoriality

variable {D : Type*} [Category* D] {F : C ‚•§ D} {K : Precoverage D}

/-- The image of a `0`-hypercover under a functor. -/
@[simps toPreZeroHypercover]
def map (F : C ‚•§ D) (E : ZeroHypercover.{w} J S) (h : J ‚â§ K.comap F) :
    ZeroHypercover.{w} K (F.obj S) where
  __ := E.toPreZeroHypercover.map F
  mem‚ÇÄ := by
    rw [PreZeroHypercover.presieve‚ÇÄ_map, ‚Üê mem_comap_iff]
    exact h _ E.mem‚ÇÄ

end Functoriality

lemma presieve‚ÇÄ_mem_of_iso [J.RespectsIso] {S : C} {E : J.ZeroHypercover S}
    {F : PreZeroHypercover.{w} S} (e : E.toPreZeroHypercover ‚âÖ F) :
    F.presieve‚ÇÄ ‚àà J S :=
  E.toPreZeroHypercover.presieve‚ÇÄ_mem_of_iso e E.mem‚ÇÄ

/--
A `w`-`0`-hypercover `E` is `w'`-small if there exists an indexing type `Œπ` in `Type w'` and a
restriction map `Œπ ‚Üí E.I‚ÇÄ` such that the restriction of `E` to `Œπ` is still covering.

Note: This is weaker than `E.I‚ÇÄ` being `w'`-small. For example, every Zariski cover of
`X : Scheme.{u}` is `u`-small, because `X` itself suffices as indexing type.
-/
protected class Small (E : ZeroHypercover.{w} J S) where
  exists_restrictIndex_mem (E) : ‚àÉ (Œπ : Type w') (f : Œπ ‚Üí E.I‚ÇÄ), (E.restrictIndex f).presieve‚ÇÄ ‚àà J S

instance (E : ZeroHypercover.{w} J S) [Small.{w'} E.I‚ÇÄ] : ZeroHypercover.Small.{w'} E where
  exists_restrictIndex_mem := ‚ü®_, (equivShrink E.I‚ÇÄ).symm, by simp [E.mem‚ÇÄ]‚ü©

/-- The `w'`-index type of a `w'`-small `0`-hypercover. -/
def Small.Index (E : ZeroHypercover.{w} J S) [ZeroHypercover.Small.{w'} E] : Type w' :=
  (Small.exists_restrictIndex_mem E).choose

/-- The index restriction function of a small `0`-hypercover. -/
noncomputable def Small.restrictFun (E : ZeroHypercover.{w} J S) [ZeroHypercover.Small.{w'} E] :
    Index E ‚Üí E.I‚ÇÄ :=
  (Small.exists_restrictIndex_mem E).choose_spec.choose

lemma Small.mem‚ÇÄ (E : ZeroHypercover.{w} J S) [ZeroHypercover.Small.{w'} E] :
    (E.restrictIndex <| Small.restrictFun E).presieve‚ÇÄ ‚àà J S :=
  (Small.exists_restrictIndex_mem E).choose_spec.choose_spec

instance (E : ZeroHypercover.{w} J S) : ZeroHypercover.Small.{max u v} E where
  exists_restrictIndex_mem := by
    obtain ‚ü®Œπ, Y, f, h‚ü© := E.presieve‚ÇÄ.exists_eq_ofArrows
    have (Z : C) (g : Z ‚ü∂ S) (hg : Presieve.ofArrows Y f g) :
        ‚àÉ (j : E.I‚ÇÄ) (h : Z = E.X j), g = eqToHom h ‚â´ E.f j := by
      obtain ‚ü®j‚ü© : E.presieve‚ÇÄ g := by rwa [h]
      use j, rfl
      simp
    choose j h‚ÇÅ h‚ÇÇ using this
    refine ‚ü®Œπ, fun i ‚Ü¶ j _ _ (.mk i), ?_‚ü©
    convert E.mem‚ÇÄ
    exact le_antisymm (fun Z g ‚ü®i‚ü© ‚Ü¶ ‚ü®_‚ü©) (h ‚ñ∏ fun Z g ‚ü®i‚ü© ‚Ü¶ .mk' i (h‚ÇÅ _ _ _) (h‚ÇÇ _ _ _))

/-- Restrict a `w'`-small `0`-hypercover to a `w'`-`0`-hypercover. -/
@[simps toPreZeroHypercover]
noncomputable
def restrictIndexOfSmall (E : ZeroHypercover.{w} J S) [ZeroHypercover.Small.{w'} E] :
    ZeroHypercover.{w'} J S where
  __ := E.toPreZeroHypercover.restrictIndex (Small.restrictFun E)
  mem‚ÇÄ := Small.mem‚ÇÄ E

instance (E : ZeroHypercover.{w} J S) [ZeroHypercover.Small.{w'} E] {T : C} (f : T ‚ü∂ S)
    [IsStableUnderBaseChange J] [‚àÄ (i : E.I‚ÇÄ), HasPullback f (E.f i)] :
    ZeroHypercover.Small.{w'} (E.pullback‚ÇÅ f) := by
  use Small.Index E, Small.restrictFun E
  have _ (i) : HasPullback f (E.restrictIndexOfSmall.f i) := by dsimp; infer_instance
  exact ((restrictIndexOfSmall.{w'} E).pullback‚ÇÅ f).mem‚ÇÄ

end ZeroHypercover

lemma mem_iff_exists_zeroHypercover {X : C} {R : Presieve X} :
    R ‚àà J X ‚Üî ‚àÉ (ùí∞ : ZeroHypercover.{max u v} J X), R = Presieve.ofArrows ùí∞.X ùí∞.f := by
  refine ‚ü®fun hR ‚Ü¶ ?_, fun ‚ü®ùí∞, hR‚ü© ‚Ü¶ hR ‚ñ∏ ùí∞.mem‚ÇÄ‚ü©
  obtain ‚ü®Œπ, Y, f, rfl‚ü© := R.exists_eq_ofArrows
  use ‚ü®‚ü®Œπ, Y, f‚ü©, hR‚ü©

lemma le_of_zeroHypercover {J K : Precoverage C}
    (h : ‚àÄ ‚¶ÉX : C‚¶Ñ ‚¶ÉE : ZeroHypercover.{max u v} J X‚¶Ñ, E.presieve‚ÇÄ ‚àà K X) :
    J ‚â§ K := by
  intro X R hR
  obtain ‚ü®E, rfl‚ü© := R.exists_eq_preZeroHypercover
  exact h (E := ‚ü®E, hR‚ü©)

/-- A precoverage is `w`-small, if every `0`-hypercover is `w`-small. -/
class Small (J : Precoverage C) : Prop where
  zeroHypercoverSmall : ‚àÄ {S : C} (E : ZeroHypercover.{max u v} J S), ZeroHypercover.Small.{w'} E

instance (J : Precoverage C) [Small.{w} J] {S : C} (E : ZeroHypercover.{w'} J S) :
    ZeroHypercover.Small.{w} E := by
  have : ZeroHypercover.Small.{w} (ZeroHypercover.restrictIndexOfSmall.{max u v} E) :=
    Small.zeroHypercoverSmall _
  let E' := ZeroHypercover.restrictIndexOfSmall.{w}
    (ZeroHypercover.restrictIndexOfSmall.{max u v} E)
  use E'.I‚ÇÄ, ZeroHypercover.Small.restrictFun _ ‚àò ZeroHypercover.Small.restrictFun _
  exact E'.mem‚ÇÄ

instance [IsStableUnderBaseChange J] : RespectsIso J where
  of_iso {S E F} e h := by
    refine J.mem_coverings_of_isPullback (fun i ‚Ü¶ E.f (e.inv.s‚ÇÄ i)) ?_ (ùüô S) _ (fun i ‚Ü¶ ?_) ?_
    ¬∑ convert h
      exact Presieve.ofArrows_comp_eq_of_surjective _ (fun i ‚Ü¶ ‚ü®e.hom.s‚ÇÄ i, by simp‚ü©)
    ¬∑ exact e.inv.h‚ÇÄ i
    ¬∑ intro i
      exact CategoryTheory.IsPullback.of_vert_isIso (by simp)

namespace ZeroHypercover

variable [J.IsStableUnderBaseChange]

/-- If `{U·µ¢}` covers `X`, this is the `0`-hypercover of `X √ó[Z] Y` given by `{U·µ¢ √ó[Z] Y}`. -/
@[simps toPreZeroHypercover]
noncomputable def pullbackCoverOfLeft {X : C} (E : J.ZeroHypercover X) {Y Z : C}
    (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [HasPullback f g] [‚àÄ i, HasPullback (E.f i) (pullback.fst f g)] :
    J.ZeroHypercover (pullback f g) where
  __ := E.toPreZeroHypercover.pullbackCoverOfLeft f g
  mem‚ÇÄ := (E.pullback‚ÇÅ (pullback.fst f g)).presieve‚ÇÄ_mem_of_iso
    (E.pullbackCoverOfLeftIsoPullback‚ÇÅ _ _).symm

/-- If `{U·µ¢}` covers `Y`, this is the `0`-hypercover of `X √ó[Z] Y` given by `{X √ó[Z] U·µ¢}`. -/
@[simps toPreZeroHypercover]
noncomputable def pullbackCoverOfRight {Y : C} (E : J.ZeroHypercover Y) {X Z : C}
    (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [HasPullback f g] [‚àÄ i, HasPullback (E.f i) (pullback.snd f g)] :
    J.ZeroHypercover (pullback f g) where
  __ := E.toPreZeroHypercover.pullbackCoverOfRight f g
  mem‚ÇÄ := (E.pullback‚ÇÇ (pullback.snd f g)).presieve‚ÇÄ_mem_of_iso
    (E.pullbackCoverOfRightIsoPullback‚ÇÇ _ _).symm

end ZeroHypercover

end Precoverage

end CategoryTheory
