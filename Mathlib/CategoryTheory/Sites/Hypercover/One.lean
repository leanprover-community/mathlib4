/-
Copyright (c) 2024 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathlib.CategoryTheory.Sites.Sheaf
import Mathlib.CategoryTheory.Sites.Hypercover.Zero

/-!
# 1-hypercovers

Given a Grothendieck topology `J` on a category `C`, we define the type of
`1`-hypercovers of an object `S : C`. They consists of a covering family
of morphisms `X i ‚ü∂ S` indexed by a type `I‚ÇÄ` and, for each tuple `(i‚ÇÅ, i‚ÇÇ)`
of elements of `I‚ÇÄ`, a "covering `Y j` of the fibre product of `X i‚ÇÅ` and
`X i‚ÇÇ` over `S`", a condition which is phrased here without assuming that
the fibre product actually exist.

The definition `OneHypercover.isLimitMultifork` shows that if `E` is a
`1`-hypercover of `S`, and `F` is a sheaf, then `F.obj (op S)`
identifies to the multiequalizer of suitable maps
`F.obj (op (E.X i)) ‚ü∂ F.obj (op (E.Y j))`.

-/

universe w' w v u

namespace CategoryTheory

open Category Limits

variable {C : Type u} [Category.{v} C] {A : Type*} [Category A]

/-- The categorical data that is involved in a `1`-hypercover of an object `S`. This
consists of a family of morphisms `f i : X i ‚ü∂ S` for `i : I‚ÇÄ`, and for each
tuple `(i‚ÇÅ, i‚ÇÇ)` of elements in `I‚ÇÄ`, a family of objects `Y j` indexed by
a type `I‚ÇÅ i‚ÇÅ i‚ÇÇ`, which are equipped with a map to the fibre product of `X i‚ÇÅ`
and `X i‚ÇÇ`, which is phrased here as the data of the two projections
`p‚ÇÅ : Y j ‚ü∂ X i‚ÇÅ`, `p‚ÇÇ : Y j ‚ü∂ X i‚ÇÇ` and the relation `p‚ÇÅ j ‚â´ f i‚ÇÅ = p‚ÇÇ j ‚â´ f i‚ÇÇ`.
(See `GrothendieckTopology.OneHypercover` for the topological conditions.) -/
structure PreOneHypercover (S : C) extends PreZeroHypercover.{w} S where
  /-- the index type of the coverings of the fibre products -/
  I‚ÇÅ (i‚ÇÅ i‚ÇÇ : I‚ÇÄ) : Type w
  /-- the objects in the coverings of the fibre products -/
  Y ‚¶Éi‚ÇÅ i‚ÇÇ : I‚ÇÄ‚¶Ñ (j : I‚ÇÅ i‚ÇÅ i‚ÇÇ) : C
  /-- the first projection `Y j ‚ü∂ X i‚ÇÅ` -/
  p‚ÇÅ ‚¶Éi‚ÇÅ i‚ÇÇ : I‚ÇÄ‚¶Ñ (j : I‚ÇÅ i‚ÇÅ i‚ÇÇ) : Y j ‚ü∂ X i‚ÇÅ
  /-- the second projection `Y j ‚ü∂ X i‚ÇÇ` -/
  p‚ÇÇ ‚¶Éi‚ÇÅ i‚ÇÇ : I‚ÇÄ‚¶Ñ (j : I‚ÇÅ i‚ÇÅ i‚ÇÇ) : Y j ‚ü∂ X i‚ÇÇ
  w ‚¶Éi‚ÇÅ i‚ÇÇ : I‚ÇÄ‚¶Ñ (j : I‚ÇÅ i‚ÇÅ i‚ÇÇ) : p‚ÇÅ j ‚â´ f i‚ÇÅ = p‚ÇÇ j ‚â´ f i‚ÇÇ

namespace PreOneHypercover

variable {S : C} (E : PreOneHypercover.{w} S)

/-- Given an object `W` equipped with morphisms `p‚ÇÅ : W ‚ü∂ E.X i‚ÇÅ`, `p‚ÇÇ : W ‚ü∂ E.X i‚ÇÇ`,
this is the sieve of `W` which consists of morphisms `g : Z ‚ü∂ W` such that there exists `j`
and `h : Z ‚ü∂ E.Y j` such that `g ‚â´ p‚ÇÅ = h ‚â´ E.p‚ÇÅ j` and `g ‚â´ p‚ÇÇ = h ‚â´ E.p‚ÇÇ j`.
See lemmas `sieve‚ÇÅ_eq_pullback_sieve‚ÇÅ'` and `sieve‚ÇÅ'_eq_sieve‚ÇÅ` for equational lemmas
regarding this sieve. -/
@[simps]
def sieve‚ÇÅ {i‚ÇÅ i‚ÇÇ : E.I‚ÇÄ} {W : C} (p‚ÇÅ : W ‚ü∂ E.X i‚ÇÅ) (p‚ÇÇ : W ‚ü∂ E.X i‚ÇÇ) : Sieve W where
  arrows Z g := ‚àÉ (j : E.I‚ÇÅ i‚ÇÅ i‚ÇÇ) (h : Z ‚ü∂ E.Y j), g ‚â´ p‚ÇÅ = h ‚â´ E.p‚ÇÅ j ‚àß g ‚â´ p‚ÇÇ = h ‚â´ E.p‚ÇÇ j
  downward_closed := by
    rintro Z Z' g ‚ü®j, h, fac‚ÇÅ, fac‚ÇÇ‚ü© œÜ
    exact ‚ü®j, œÜ ‚â´ h, by simpa using œÜ ‚â´= fac‚ÇÅ, by simpa using œÜ ‚â´= fac‚ÇÇ‚ü©

section

variable {i‚ÇÅ i‚ÇÇ : E.I‚ÇÄ} [HasPullback (E.f i‚ÇÅ) (E.f i‚ÇÇ)]

/-- The obvious morphism `E.Y j ‚ü∂ pullback (E.f i‚ÇÅ) (E.f i‚ÇÇ)` given by `E : PreOneHypercover S`. -/
noncomputable abbrev toPullback (j : E.I‚ÇÅ i‚ÇÅ i‚ÇÇ) [HasPullback (E.f i‚ÇÅ) (E.f i‚ÇÇ)] :
    E.Y j ‚ü∂ pullback (E.f i‚ÇÅ) (E.f i‚ÇÇ) :=
  pullback.lift (E.p‚ÇÅ j) (E.p‚ÇÇ j) (E.w j)

variable (i‚ÇÅ i‚ÇÇ) in
/-- The sieve of `pullback (E.f i‚ÇÅ) (E.f i‚ÇÇ)` given by `E : PreOneHypercover S`. -/
noncomputable def sieve‚ÇÅ' : Sieve (pullback (E.f i‚ÇÅ) (E.f i‚ÇÇ)) :=
  Sieve.ofArrows _ (fun (j : E.I‚ÇÅ i‚ÇÅ i‚ÇÇ) => E.toPullback j)

lemma sieve‚ÇÅ_eq_pullback_sieve‚ÇÅ' {W : C} (p‚ÇÅ : W ‚ü∂ E.X i‚ÇÅ) (p‚ÇÇ : W ‚ü∂ E.X i‚ÇÇ)
    (w : p‚ÇÅ ‚â´ E.f i‚ÇÅ = p‚ÇÇ ‚â´ E.f i‚ÇÇ) :
    E.sieve‚ÇÅ p‚ÇÅ p‚ÇÇ = (E.sieve‚ÇÅ' i‚ÇÅ i‚ÇÇ).pullback (pullback.lift _ _ w) := by
  ext Z g
  constructor
  ¬∑ rintro ‚ü®j, h, fac‚ÇÅ, fac‚ÇÇ‚ü©
    exact ‚ü®_, h, _, ‚ü®j‚ü©, by cat_disch‚ü©
  ¬∑ rintro ‚ü®_, h, w, ‚ü®j‚ü©, fac‚ü©
    exact ‚ü®j, h, by simpa using fac.symm =‚â´ pullback.fst _ _,
      by simpa using fac.symm =‚â´ pullback.snd _ _‚ü©

variable (i‚ÇÅ i‚ÇÇ) in
lemma sieve‚ÇÅ'_eq_sieve‚ÇÅ : E.sieve‚ÇÅ' i‚ÇÅ i‚ÇÇ = E.sieve‚ÇÅ (pullback.fst _ _) (pullback.snd _ _) := by
  rw [‚Üê Sieve.pullback_id (S := E.sieve‚ÇÅ' i‚ÇÅ i‚ÇÇ),
    sieve‚ÇÅ_eq_pullback_sieve‚ÇÅ' _ _ _ pullback.condition]
  congr
  cat_disch

end

/-- The sigma type of all `E.I‚ÇÅ i‚ÇÅ i‚ÇÇ` for `‚ü®i‚ÇÅ, i‚ÇÇ‚ü© : E.I‚ÇÄ √ó E.I‚ÇÄ`. -/
abbrev I‚ÇÅ' : Type w := Sigma (fun (i : E.I‚ÇÄ √ó E.I‚ÇÄ) => E.I‚ÇÅ i.1 i.2)

/-- The shape of the multiforks attached to `E : PreOneHypercover S`. -/
@[simps]
def multicospanShape : MulticospanShape where
  L := E.I‚ÇÄ
  R := E.I‚ÇÅ'
  fst j := j.1.1
  snd j := j.1.2

/-- The diagram of the multifork attached to a presheaf
`F : C·µí·µñ ‚•§ A`, `S : C` and `E : PreOneHypercover S`. -/
@[simps]
def multicospanIndex (F : C·µí·µñ ‚•§ A) : MulticospanIndex E.multicospanShape A where
  left i := F.obj (Opposite.op (E.X i))
  right j := F.obj (Opposite.op (E.Y j.2))
  fst j := F.map ((E.p‚ÇÅ j.2).op)
  snd j := F.map ((E.p‚ÇÇ j.2).op)

/-- The multifork attached to a presheaf `F : C·µí·µñ ‚•§ A`, `S : C` and `E : PreOneHypercover S`. -/
def multifork (F : C·µí·µñ ‚•§ A) :
    Multifork (E.multicospanIndex F) :=
  Multifork.ofŒπ _ (F.obj (Opposite.op S)) (fun i‚ÇÄ => F.map (E.f i‚ÇÄ).op) (by
    rintro ‚ü®‚ü®i‚ÇÅ, i‚ÇÇ‚ü©, (j : E.I‚ÇÅ i‚ÇÅ i‚ÇÇ)‚ü©
    dsimp
    simp only [‚Üê F.map_comp, ‚Üê op_comp, E.w])

section Category

/-- A morphism of pre-`1`-hypercovers of `S` is a family of refinement morphisms commuting
with the structure morphisms of `E` and `F`. -/
@[ext]
structure Hom (E F : PreOneHypercover S) extends
    E.toPreZeroHypercover.Hom F.toPreZeroHypercover where
  /-- The map between indexing types of the coverings of the fibre products over `S`. -/
  s‚ÇÅ {i j : E.I‚ÇÄ} (k : E.I‚ÇÅ i j) : F.I‚ÇÅ (s‚ÇÄ i) (s‚ÇÄ j)
  /-- The refinement morphisms between objects in the coverings of the fibre products over `S`. -/
  h‚ÇÅ {i j : E.I‚ÇÄ} (k : E.I‚ÇÅ i j) : E.Y k ‚ü∂ F.Y (s‚ÇÅ k)
  w‚ÇÅ‚ÇÅ {i j : E.I‚ÇÄ} (k : E.I‚ÇÅ i j) : h‚ÇÅ k ‚â´ F.p‚ÇÅ (s‚ÇÅ k) = E.p‚ÇÅ k ‚â´ h‚ÇÄ i := by cat_disch
  w‚ÇÅ‚ÇÇ {i j : E.I‚ÇÄ} (k : E.I‚ÇÅ i j) : h‚ÇÅ k ‚â´ F.p‚ÇÇ (s‚ÇÅ k) = E.p‚ÇÇ k ‚â´ h‚ÇÄ j := by cat_disch

attribute [reassoc] Hom.w‚ÇÅ‚ÇÅ Hom.w‚ÇÅ‚ÇÇ

/-- The identity refinement of a pre-`1`-hypercover. -/
@[simps!]
def Hom.id (E : PreOneHypercover S) : Hom E E where
  __ := PreZeroHypercover.Hom.id _
  s‚ÇÅ := _root_.id
  h‚ÇÅ _ := ùüô _

variable {E : PreOneHypercover.{w} S} {F : PreOneHypercover.{w'} S}
  {G : PreOneHypercover S}

/-- Composition of refinement morphisms of pre-`1`-hypercovers. -/
@[simps!]
def Hom.comp (f : E.Hom F) (g : F.Hom G) : E.Hom G where
  __ := PreZeroHypercover.Hom.comp _ _
  s‚ÇÅ := g.s‚ÇÅ ‚àò f.s‚ÇÅ
  h‚ÇÅ i := f.h‚ÇÅ i ‚â´ g.h‚ÇÅ _
  w‚ÇÅ‚ÇÅ := by simp [w‚ÇÅ‚ÇÅ, w‚ÇÅ‚ÇÅ_assoc]
  w‚ÇÅ‚ÇÇ := by simp [w‚ÇÅ‚ÇÇ, w‚ÇÅ‚ÇÇ_assoc]

/-- The induced index map `E.I‚ÇÅ' ‚Üí F.I‚ÇÅ'` from a refinement morphism `E ‚ü∂ F`. -/
@[simp]
def Hom.s‚ÇÅ' (f : E.Hom F) (k : E.I‚ÇÅ') : F.I‚ÇÅ' :=
  ‚ü®‚ü®f.s‚ÇÄ k.1.1, f.s‚ÇÄ k.1.2‚ü©, f.s‚ÇÅ k.2‚ü©

@[simps! id_s‚ÇÄ id_s‚ÇÅ id_h‚ÇÄ id_h‚ÇÅ comp_s‚ÇÄ comp_s‚ÇÅ comp_h‚ÇÄ comp_h‚ÇÅ]
instance : Category (PreOneHypercover S) where
  Hom := Hom
  id E := Hom.id E
  comp f g := f.comp g

/-- The forgetful functor from pre-`1`-hypercovers to pre-`0`-hypercovers. -/
@[simps]
def oneToZero : PreOneHypercover.{w} S ‚•§ PreZeroHypercover.{w} S where
  obj f := f.1
  map f := f.1

/-- A refinement morphism `E ‚ü∂ F` induces a morphism on associated multiequalizers. -/
def Hom.mapMultiforkOfIsLimit (f : E.Hom F) (P : C·µí·µñ ‚•§ A) {c : Multifork (E.multicospanIndex P)}
    (hc : IsLimit c) (d : Multifork (F.multicospanIndex P)) :
    d.pt ‚ü∂ c.pt :=
  Multifork.IsLimit.lift hc (fun a ‚Ü¶ d.Œπ (f.s‚ÇÄ a) ‚â´ P.map (f.h‚ÇÄ a).op) <| by
    intro (k : E.I‚ÇÅ')
    simp only [multicospanIndex_right, multicospanShape_fst, multicospanIndex_left,
      multicospanIndex_fst, assoc, multicospanShape_snd, multicospanIndex_snd]
    have heq := d.condition (f.s‚ÇÅ' k)
    simp only [Hom.s‚ÇÅ', multicospanIndex_right, multicospanShape_fst, multicospanIndex_left,
      multicospanIndex_fst, multicospanShape_snd, multicospanIndex_snd] at heq
    rw [‚Üê Functor.map_comp, ‚Üê op_comp, ‚Üê Hom.w‚ÇÅ‚ÇÅ, ‚Üê Functor.map_comp, ‚Üê op_comp, ‚Üê Hom.w‚ÇÅ‚ÇÇ]
    rw [op_comp, Functor.map_comp, reassoc_of% heq, op_comp, Functor.map_comp]

@[reassoc (attr := simp)]
lemma Hom.mapMultiforkOfIsLimit_Œπ {E F : PreOneHypercover.{w} S}
    (f : E.Hom F) (P : C·µí·µñ ‚•§ A) {c : Multifork (E.multicospanIndex P)} (hc : IsLimit c)
    (d : Multifork (F.multicospanIndex P)) (a : E.I‚ÇÄ) :
    f.mapMultiforkOfIsLimit P hc d ‚â´ c.Œπ a = d.Œπ (f.s‚ÇÄ a) ‚â´ P.map (f.h‚ÇÄ a).op := by
  simp [mapMultiforkOfIsLimit]

end Category

end PreOneHypercover

namespace GrothendieckTopology

variable (J : GrothendieckTopology C)

/-- The type of `1`-hypercovers of an object `S : C` in a category equipped with a
Grothendieck topology `J`. This can be constructed from a covering of `S` and
a covering of the fibre products of the objects in this covering (see `OneHypercover.mk'`). -/
structure OneHypercover (S : C) extends PreOneHypercover.{w} S where
  mem‚ÇÄ : toPreOneHypercover.sieve‚ÇÄ ‚àà J S
  mem‚ÇÅ (i‚ÇÅ i‚ÇÇ : I‚ÇÄ) ‚¶ÉW : C‚¶Ñ (p‚ÇÅ : W ‚ü∂ X i‚ÇÅ) (p‚ÇÇ : W ‚ü∂ X i‚ÇÇ) (w : p‚ÇÅ ‚â´ f i‚ÇÅ = p‚ÇÇ ‚â´ f i‚ÇÇ) :
    toPreOneHypercover.sieve‚ÇÅ p‚ÇÅ p‚ÇÇ ‚àà J W

variable {J}

lemma OneHypercover.mem_sieve‚ÇÅ' {S : C} (E : J.OneHypercover S)
    (i‚ÇÅ i‚ÇÇ : E.I‚ÇÄ) [HasPullback (E.f i‚ÇÅ) (E.f i‚ÇÇ)] :
    E.sieve‚ÇÅ' i‚ÇÅ i‚ÇÇ ‚àà J _ := by
  rw [E.sieve‚ÇÅ'_eq_sieve‚ÇÅ]
  exact mem‚ÇÅ _ _ _ _ _ pullback.condition

namespace OneHypercover

/-- In order to check that a certain data is a `1`-hypercover of `S`, it suffices to
check that the data provides a covering of `S` and of the fibre products. -/
@[simps toPreOneHypercover]
def mk' {S : C} (E : PreOneHypercover S) [E.HasPullbacks]
    (mem‚ÇÄ : E.sieve‚ÇÄ ‚àà J S) (mem‚ÇÅ' : ‚àÄ (i‚ÇÅ i‚ÇÇ : E.I‚ÇÄ), E.sieve‚ÇÅ' i‚ÇÅ i‚ÇÇ ‚àà J _) :
    J.OneHypercover S where
  toPreOneHypercover := E
  mem‚ÇÄ := mem‚ÇÄ
  mem‚ÇÅ i‚ÇÅ i‚ÇÇ W p‚ÇÅ p‚ÇÇ w := by
    rw [E.sieve‚ÇÅ_eq_pullback_sieve‚ÇÅ' _ _ w]
    exact J.pullback_stable' _ (mem‚ÇÅ' i‚ÇÅ i‚ÇÇ)

section

variable {S : C} (E : J.OneHypercover S) (F : Sheaf J A)

section

variable {E F}
variable (c : Multifork (E.multicospanIndex F.val))

/-- Auxiliary definition of `isLimitMultifork`. -/
noncomputable def multiforkLift : c.pt ‚ü∂ F.val.obj (Opposite.op S) :=
  F.cond.amalgamateOfArrows _ E.mem‚ÇÄ c.Œπ (fun W i‚ÇÅ i‚ÇÇ p‚ÇÅ p‚ÇÇ w => by
    apply F.cond.hom_ext ‚ü®_, E.mem‚ÇÅ _ _ _ _ w‚ü©
    rintro ‚ü®T, g, j, h, fac‚ÇÅ, fac‚ÇÇ‚ü©
    dsimp
    simp only [assoc, ‚Üê Functor.map_comp, ‚Üê op_comp, fac‚ÇÅ, fac‚ÇÇ]
    simp only [op_comp, Functor.map_comp]
    simpa using c.condition ‚ü®‚ü®i‚ÇÅ, i‚ÇÇ‚ü©, j‚ü© =‚â´ F.val.map h.op)

@[reassoc]
lemma multiforkLift_map (i‚ÇÄ : E.I‚ÇÄ) : multiforkLift c ‚â´ F.val.map (E.f i‚ÇÄ).op = c.Œπ i‚ÇÄ := by
  simp [multiforkLift]

end

/-- If `E : J.OneHypercover S` and `F : Sheaf J A`, then `F.obj (op S)` is
a multiequalizer of suitable maps `F.obj (op (E.X i)) ‚ü∂ F.obj (op (E.Y j))`
induced by `E.p‚ÇÅ j` and `E.p‚ÇÇ j`. -/
noncomputable def isLimitMultifork : IsLimit (E.multifork F.1) :=
  Multifork.IsLimit.mk _ (fun c => multiforkLift c) (fun c => multiforkLift_map c) (by
    intro c m hm
    apply F.cond.hom_ext_ofArrows _ E.mem‚ÇÄ
    intro i‚ÇÄ
    dsimp only
    rw [multiforkLift_map]
    exact hm i‚ÇÄ)

end

section Category

variable {S : C} {E : OneHypercover.{w} J S} {F : OneHypercover.{w'} J S}

/-- A morphism of `1`-hypercovers is a morphism of the underlying pre-`1`-hypercovers. -/
abbrev Hom (E : OneHypercover.{w} J S) (F : OneHypercover.{w'} J S) :=
  E.toPreOneHypercover.Hom F.toPreOneHypercover

end Category

end OneHypercover

namespace Cover

variable {X : C} (S : J.Cover X)

/-- The tautological 1-pre-hypercover induced by `S : J.Cover X`. Its index type `I‚ÇÄ`
is given by `S.Arrow` (i.e. all the morphisms in the sieve `S`), while `I‚ÇÅ` is given
by all possible pullback cones. -/
@[simps]
def preOneHypercover : PreOneHypercover.{max u v} X where
  I‚ÇÄ := S.Arrow
  X f := f.Y
  f f := f.f
  I‚ÇÅ f‚ÇÅ f‚ÇÇ := f‚ÇÅ.Relation f‚ÇÇ
  Y _ _ r := r.Z
  p‚ÇÅ _ _ r := r.g‚ÇÅ
  p‚ÇÇ _ _ r := r.g‚ÇÇ
  w _ _ r := r.w

@[simp]
lemma preOneHypercover_sieve‚ÇÄ : S.preOneHypercover.sieve‚ÇÄ = S.1 := by
  ext Y f
  constructor
  ¬∑ rintro ‚ü®_, _, _, ‚ü®g‚ü©, rfl‚ü©
    exact S.1.downward_closed g.hf _
  ¬∑ intro hf
    exact Sieve.ofArrows_mk _ _ ({ hf := hf, .. } : S.Arrow)

lemma preOneHypercover_sieve‚ÇÅ (f‚ÇÅ f‚ÇÇ : S.Arrow) {W : C} (p‚ÇÅ : W ‚ü∂ f‚ÇÅ.Y) (p‚ÇÇ : W ‚ü∂ f‚ÇÇ.Y)
    (w : p‚ÇÅ ‚â´ f‚ÇÅ.f = p‚ÇÇ ‚â´ f‚ÇÇ.f) :
    S.preOneHypercover.sieve‚ÇÅ p‚ÇÅ p‚ÇÇ = ‚ä§ := by
  ext Y f
  simp only [Sieve.top_apply, iff_true]
  exact ‚ü®{ w := w, .. }, f, rfl, rfl‚ü©

/-- The tautological 1-hypercover induced by `S : J.Cover X`. Its index type `I‚ÇÄ`
is given by `S.Arrow` (i.e. all the morphisms in the sieve `S`), while `I‚ÇÅ` is given
by all possible pullback cones. -/
@[simps toPreOneHypercover]
def oneHypercover : J.OneHypercover X where
  toPreOneHypercover := S.preOneHypercover
  mem‚ÇÄ := by simp
  mem‚ÇÅ f‚ÇÅ f‚ÇÇ _ p‚ÇÅ p‚ÇÇ w := by simp [S.preOneHypercover_sieve‚ÇÅ f‚ÇÅ f‚ÇÇ p‚ÇÅ p‚ÇÇ w]

end Cover

end GrothendieckTopology

end CategoryTheory
