/-
Copyright (c) 2020 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta
-/
import Mathlib.CategoryTheory.Sites.Pretopology
import Mathlib.CategoryTheory.Sites.IsSheafFor

/-!
# Sheaves of types on a Grothendieck topology

Defines the notion of a sheaf of types (usually called a sheaf of sets by mathematicians)
on a category equipped with a Grothendieck topology, as well as a range of equivalent
conditions useful in different situations.

In `Mathlib/CategoryTheory/Sites/IsSheafFor.lean` it is defined what it means for a presheaf to be a
sheaf *for* a particular sieve. Given a Grothendieck topology `J`, `P` is a sheaf if it is a sheaf
for every sieve in the topology. See `IsSheaf`.

In the case where the topology is generated by a basis, it suffices to check `P` is a sheaf for
every presieve in the pretopology. See `isSheaf_pretopology`.

We also provide equivalent conditions to satisfy alternate definitions given in the literature.

* Stacks: In `Equalizer.Presieve.sheaf_condition`, the sheaf condition at a presieve is shown to be
  equivalent to that of https://stacks.math.columbia.edu/tag/00VM (and combined with
  `isSheaf_pretopology`, this shows the notions of `IsSheaf` are exactly equivalent.)

  The condition of https://stacks.math.columbia.edu/tag/00Z8 is virtually identical to the
  statement of `isSheafFor_iff_yonedaSheafCondition` (since the bijection described there carries
  the same information as the unique existence.)

* Maclane-Moerdijk [MM92]: Using `compatible_iff_sieveCompatible`, the definitions of `IsSheaf`
  are equivalent. There are also alternate definitions given:
  - Sheaf for a pretopology (Prop 1): `isSheaf_pretopology` combined with `pullbackCompatible_iff`.
  - Sheaf for a pretopology as equalizer (Prop 1, bis): `Equalizer.Presieve.sheaf_condition`
    combined with the previous.

## References

* [MM92]: *Sheaves in geometry and logic*, Saunders MacLane, and Ieke Moerdijk:
  Chapter III, Section 4.
* [Elephant]: *Sketches of an Elephant*, P. T. Johnstone: C2.1.
* https://stacks.math.columbia.edu/tag/00VL (sheaves on a pretopology or site)
* https://stacks.math.columbia.edu/tag/00ZB (sheaves on a topology)

-/


universe w w' v u

namespace CategoryTheory

open Opposite CategoryTheory Category Limits Sieve

namespace Presieve

variable {C : Type u} [Category.{v} C]
variable {P : C·µí·µñ ‚•§ Type w}
variable {X : C}
variable (J J‚ÇÇ : GrothendieckTopology C)

/-- A presheaf is separated for a topology if it is separated for every sieve in the topology. -/
def IsSeparated (P : C·µí·µñ ‚•§ Type w) : Prop :=
  ‚àÄ ‚¶ÉX‚¶Ñ (S : Sieve X), S ‚àà J X ‚Üí IsSeparatedFor P (S : Presieve X)

/-- A presheaf is a sheaf for a topology if it is a sheaf for every sieve in the topology.

If the given topology is given by a pretopology, `isSheaf_pretopology` shows it suffices to
check the sheaf condition at presieves in the pretopology.
-/
def IsSheaf (P : C·µí·µñ ‚•§ Type w) : Prop :=
  ‚àÄ ‚¶ÉX‚¶Ñ (S : Sieve X), S ‚àà J X ‚Üí IsSheafFor P (S : Presieve X)

theorem IsSheaf.isSheafFor {P : C·µí·µñ ‚•§ Type w} (hp : IsSheaf J P) (R : Presieve X)
    (hr : generate R ‚àà J X) : IsSheafFor P R :=
  (isSheafFor_iff_generate R).2 <| hp _ hr

theorem isSheaf_of_le (P : C·µí·µñ ‚•§ Type w) {J‚ÇÅ J‚ÇÇ : GrothendieckTopology C} :
    J‚ÇÅ ‚â§ J‚ÇÇ ‚Üí IsSheaf J‚ÇÇ P ‚Üí IsSheaf J‚ÇÅ P := fun h t _ S hS => t S (h _ hS)

theorem isSeparated_of_le (P : C·µí·µñ ‚•§ Type w) {J‚ÇÅ J‚ÇÇ : GrothendieckTopology C} :
    J‚ÇÅ ‚â§ J‚ÇÇ ‚Üí IsSeparated J‚ÇÇ P ‚Üí IsSeparated J‚ÇÅ P :=
  fun h hP _ S hS ‚Ü¶ hP S <| h _ hS

variable {J} in
theorem IsSheaf.isSeparated {P : C·µí·µñ ‚•§ Type w} (h : IsSheaf J P) : IsSeparated J P :=
  fun _ S hS => (h S hS).isSeparatedFor

@[deprecated (since := "2025-08-28")] alias isSeparated_of_isSheaf := IsSheaf.isSeparated

variable {J} in
/-- If `P` is separated and every compatible family of elements of `P` for a covering
sieve has an amalgamation, `P` is a sheaf. -/
theorem IsSeparated.isSheaf {P : C·µí·µñ ‚•§ Type w} (h : IsSeparated J P) (h' : ‚àÄ X, ‚àÄ S ‚àà J X,
      ‚àÄ x : FamilyOfElements P S.arrows, x.Compatible ‚Üí ‚àÉ t, x.IsAmalgamation t) :
    IsSheaf J P :=
  fun _ S hS ‚Ü¶ (h S hS).isSheafFor <| h' _ S hS

section

variable {J} {P‚ÇÅ : C·µí·µñ ‚•§ Type w} {P‚ÇÇ : C·µí·µñ ‚•§ Type w'}
  (e : ‚àÄ ‚¶ÉX : C‚¶Ñ, P‚ÇÅ.obj (op X) ‚âÉ P‚ÇÇ.obj (op X))
  (he : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : X ‚ü∂ Y) (x : P‚ÇÅ.obj (op Y)),
    e (P‚ÇÅ.map f.op x) = P‚ÇÇ.map f.op (e x))

include he in
lemma isSheaf_of_nat_equiv (hP‚ÇÅ : Presieve.IsSheaf J P‚ÇÅ) :
    Presieve.IsSheaf J P‚ÇÇ := fun _ R hR ‚Ü¶
  isSheafFor_of_nat_equiv e he (hP‚ÇÅ R hR)

include he in
lemma isSheaf_iff_of_nat_equiv :
    Presieve.IsSheaf J P‚ÇÅ ‚Üî Presieve.IsSheaf J P‚ÇÇ :=
  ‚ü®fun hP‚ÇÅ ‚Ü¶ isSheaf_of_nat_equiv e he hP‚ÇÅ,
    fun hP‚ÇÇ ‚Ü¶
      isSheaf_of_nat_equiv (fun _ ‚Ü¶ (@e _).symm) (fun X Y f x ‚Ü¶ by
        obtain ‚ü®y, rfl‚ü© := e.surjective x
        refine e.injective ?_
        simp only [Equiv.apply_symm_apply, Equiv.symm_apply_apply, he]) hP‚ÇÇ‚ü©

end

/-- The property of being a sheaf is preserved by isomorphism. -/
theorem isSheaf_iso {P' : C·µí·µñ ‚•§ Type w} (i : P ‚âÖ P') (h : IsSheaf J P) : IsSheaf J P' :=
  fun _ S hS => isSheafFor_iso i (h S hS)

/-- The property of being separated is preserved under isomorphisms. -/
theorem isSeparated_iso {P' : C·µí·µñ ‚•§ Type w} (i : P ‚âÖ P') (hP : IsSeparated J P) :
    IsSeparated J P' :=
  fun _ S hS ‚Ü¶ isSeparatedFor_iso i (hP S hS)

theorem isSheaf_of_yoneda {P : C·µí·µñ ‚•§ Type v}
    (h : ‚àÄ {X} (S : Sieve X), S ‚àà J X ‚Üí YonedaSheafCondition P S) : IsSheaf J P := fun _ _ hS =>
  isSheafFor_iff_yonedaSheafCondition.2 (h _ hS)

/-- For a topology generated by a basis, it suffices to check the sheaf condition on the basis
presieves only.
-/
theorem isSheaf_pretopology [HasPullbacks C] (K : Pretopology C) :
    IsSheaf K.toGrothendieck P ‚Üî ‚àÄ {X : C} (R : Presieve X), R ‚àà K X ‚Üí IsSheafFor P R := by
  constructor
  ¬∑ intro PJ X R hR
    rw [isSheafFor_iff_generate]
    apply PJ (Sieve.generate R) ‚ü®_, hR, le_generate R‚ü©
  ¬∑ rintro PK X S ‚ü®R, hR, RS‚ü©
    have gRS : ‚áë(generate R) ‚â§ S := by
      apply giGenerate.gc.monotone_u
      rwa [generate_le_iff]
    apply isSheafFor_subsieve P gRS _
    intro Y f
    rw [‚Üê pullbackArrows_comm, ‚Üê isSheafFor_iff_generate]
    exact PK (pullbackArrows f R) (K.pullbacks f R hR)

/-- Any presheaf is a sheaf for the bottom (trivial) Grothendieck topology. -/
theorem isSheaf_bot : IsSheaf (‚ä• : GrothendieckTopology C) P := fun X => by
  simp [isSheafFor_top_sieve]

/-- The composition of a sheaf with a ULift functor is still a sheaf. -/
theorem isSheaf_comp_uliftFunctor (h : IsSheaf J P) : IsSheaf J (P ‚ãô uliftFunctor.{w'}) :=
  isSheaf_of_nat_equiv (fun _ => Equiv.ulift.symm) (fun _ _ _ _ => rfl) h

/--
For a presheaf of the form `yoneda.obj W`, a compatible family of elements on a sieve
is the same as a co-cone over the sieve. Constructing a co-cone from a compatible family works for
any presieve, as does constructing a family of elements from a co-cone. Showing compatibility of the
family needs the sieve condition.
Note: This is related to `CategoryTheory.Presheaf.conesEquivSieveCompatibleFamily`
-/
def compatibleYonedaFamily_toCocone (R : Presieve X) (W : C) (x : FamilyOfElements (yoneda.obj W) R)
    (hx : FamilyOfElements.Compatible x) :
    Cocone (R.diagram) where
  pt := W
  Œπ :=
    { app := fun f => x f.obj.hom f.property
      naturality := by
        intro g‚ÇÅ g‚ÇÇ F
        simp only [Functor.id_obj, Functor.comp_obj, ObjectProperty.Œπ_obj, Over.forget_obj,
          Functor.const_obj_obj, Functor.comp_map, ObjectProperty.Œπ_map, Over.forget_map,
          Functor.const_obj_map, comp_id]
        rw [‚Üê Category.id_comp (x g‚ÇÅ.obj.hom g‚ÇÅ.property)]
        apply hx
        simp only [Functor.id_obj, Over.w, Opposite.unop_op, Category.id_comp] }

/-- Construct a family of elements from a cocone. -/
def yonedaFamilyOfElements_fromCocone (R : Presieve X) (s : Cocone (diagram R)) :
    FamilyOfElements (yoneda.obj s.pt) R :=
  fun _ f hf => s.Œπ.app ‚ü®Over.mk f, hf‚ü©

end Presieve

namespace Sieve
open Presieve

variable {C : Type u} [Category.{v} C]
variable {X : C}

theorem yonedaFamily_fromCocone_compatible (S : Sieve X) (s : Cocone (diagram S.arrows)) :
    FamilyOfElements.Compatible <| yonedaFamilyOfElements_fromCocone S.arrows s := by
  intro Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ hgf
  have Hs := s.Œπ.naturality
  simp only [Functor.id_obj, yoneda_obj_obj, Opposite.unop_op, yoneda_obj_map, Quiver.Hom.unop_op]
  dsimp [yonedaFamilyOfElements_fromCocone]
  have hgf‚ÇÅ : S.arrows (g‚ÇÅ ‚â´ f‚ÇÅ) := by exact Sieve.downward_closed S hf‚ÇÅ g‚ÇÅ
  have hgf‚ÇÇ : S.arrows (g‚ÇÇ ‚â´ f‚ÇÇ) := by exact Sieve.downward_closed S hf‚ÇÇ g‚ÇÇ
  let F : (Over.mk (g‚ÇÅ ‚â´ f‚ÇÅ) : Over X) ‚ü∂ (Over.mk (g‚ÇÇ ‚â´ f‚ÇÇ) : Over X) := Over.homMk (ùüô Z)
  let F‚ÇÅ : (Over.mk (g‚ÇÅ ‚â´ f‚ÇÅ) : Over X) ‚ü∂ (Over.mk f‚ÇÅ : Over X) := Over.homMk g‚ÇÅ
  let F‚ÇÇ : (Over.mk (g‚ÇÇ ‚â´ f‚ÇÇ) : Over X) ‚ü∂ (Over.mk f‚ÇÇ : Over X) := Over.homMk g‚ÇÇ
  have hF := @Hs ‚ü®Over.mk (g‚ÇÅ ‚â´ f‚ÇÅ), hgf‚ÇÅ‚ü© ‚ü®Over.mk (g‚ÇÇ ‚â´ f‚ÇÇ), hgf‚ÇÇ‚ü© F
  have hF‚ÇÅ := @Hs ‚ü®Over.mk (g‚ÇÅ ‚â´ f‚ÇÅ), hgf‚ÇÅ‚ü© ‚ü®Over.mk f‚ÇÅ, hf‚ÇÅ‚ü© F‚ÇÅ
  have hF‚ÇÇ := @Hs ‚ü®Over.mk (g‚ÇÇ ‚â´ f‚ÇÇ), hgf‚ÇÇ‚ü© ‚ü®Over.mk f‚ÇÇ, hf‚ÇÇ‚ü© F‚ÇÇ
  cat_disch

/--
The base of a sieve `S` is a colimit of `S` iff all Yoneda-presheaves satisfy
the sheaf condition for `S`.
-/
theorem forallYonedaIsSheaf_iff_colimit (S : Sieve X) :
    (‚àÄ W : C, Presieve.IsSheafFor (yoneda.obj W) (S : Presieve X)) ‚Üî
      Nonempty (IsColimit S.arrows.cocone) := by
  constructor
  ¬∑ intro H
    refine Nonempty.intro ?_
    exact
    { desc := fun s => H s.pt (yonedaFamilyOfElements_fromCocone S.arrows s)
        (yonedaFamily_fromCocone_compatible S s) |>.choose
      fac := by
        intro s f
        replace H := H s.pt (yonedaFamilyOfElements_fromCocone S.arrows s)
          (yonedaFamily_fromCocone_compatible S s)
        have ht := H.choose_spec.1 f.obj.hom f.property
        cat_disch
      uniq := by
        intro s Fs HFs
        replace H := H s.pt (yonedaFamilyOfElements_fromCocone S.arrows s)
          (yonedaFamily_fromCocone_compatible S s)
        apply H.choose_spec.2 Fs
        exact fun _ f hf => HFs ‚ü®Over.mk f, hf‚ü© }
  ¬∑ intro H W x hx
    replace H := Classical.choice H
    let s := compatibleYonedaFamily_toCocone S.arrows W x hx
    use H.desc s
    constructor
    ¬∑ exact fun _ f hf => (H.fac s) ‚ü®Over.mk f, hf‚ü©
    ¬∑ exact fun g hg => H.uniq s g (fun ‚ü®‚ü®f, _, hom‚ü©, hf‚ü© => hg hom hf)

end Sieve

end CategoryTheory
