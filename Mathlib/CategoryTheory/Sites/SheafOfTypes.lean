/-
Copyright (c) 2020 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta
-/
import Mathlib.CategoryTheory.Sites.Pretopology
import Mathlib.CategoryTheory.Sites.IsSheafFor

/-!
# Sheaves of types on a Grothendieck topology

Defines the notion of a sheaf of types (usually called a sheaf of sets by mathematicians)
on a category equipped with a Grothendieck topology, as well as a range of equivalent
conditions useful in different situations.

In `Mathlib/CategoryTheory/Sites/IsSheafFor.lean` it is defined what it means for a presheaf to be a
sheaf *for* a particular sieve. Given a Grothendieck topology `J`, `P` is a sheaf if it is a sheaf
for every sieve in the topology. See `IsSheaf`.

In the case where the topology is generated by a basis, it suffices to check `P` is a sheaf for
every presieve in the pretopology. See `isSheaf_pretopology`.

We also provide equivalent conditions to satisfy alternate definitions given in the literature.

* Stacks: In `Equalizer.Presieve.sheaf_condition`, the sheaf condition at a presieve is shown to be
  equivalent to that of https://stacks.math.columbia.edu/tag/00VM (and combined with
  `isSheaf_pretopology`, this shows the notions of `IsSheaf` are exactly equivalent.)

  The condition of https://stacks.math.columbia.edu/tag/00Z8 is virtually identical to the
  statement of `isSheafFor_iff_yonedaSheafCondition` (since the bijection described there carries
  the same information as the unique existence.)

* Maclane-Moerdijk [MM92]: Using `compatible_iff_sieveCompatible`, the definitions of `IsSheaf`
  are equivalent. There are also alternate definitions given:
  - Sheaf for a pretopology (Prop 1): `isSheaf_pretopology` combined with `pullbackCompatible_iff`.
  - Sheaf for a pretopology as equalizer (Prop 1, bis): `Equalizer.Presieve.sheaf_condition`
    combined with the previous.

## References

* [MM92]: *Sheaves in geometry and logic*, Saunders MacLane, and Ieke Moerdijk:
  Chapter III, Section 4.
* [Elephant]: *Sketches of an Elephant*, P. T. Johnstone: C2.1.
* https://stacks.math.columbia.edu/tag/00VL (sheaves on a pretopology or site)
* https://stacks.math.columbia.edu/tag/00ZB (sheaves on a topology)

-/


universe w w' v u

namespace CategoryTheory

open Opposite CategoryTheory Category Limits Sieve

namespace Presieve

variable {C : Type u} [Category.{v} C]
variable {P : Cáµ’áµ– â¥¤ Type w}
variable {X : C}
variable (J Jâ‚‚ : GrothendieckTopology C)

/-- A presheaf is separated for a topology if it is separated for every sieve in the topology. -/
def IsSeparated (P : Cáµ’áµ– â¥¤ Type w) : Prop :=
  âˆ€ {X} (S : Sieve X), S âˆˆ J X â†’ IsSeparatedFor P (S : Presieve X)

/-- A presheaf is a sheaf for a topology if it is a sheaf for every sieve in the topology.

If the given topology is given by a pretopology, `isSheaf_pretopology` shows it suffices to
check the sheaf condition at presieves in the pretopology.
-/
def IsSheaf (P : Cáµ’áµ– â¥¤ Type w) : Prop :=
  âˆ€ â¦ƒXâ¦„ (S : Sieve X), S âˆˆ J X â†’ IsSheafFor P (S : Presieve X)

theorem IsSheaf.isSheafFor {P : Cáµ’áµ– â¥¤ Type w} (hp : IsSheaf J P) (R : Presieve X)
    (hr : generate R âˆˆ J X) : IsSheafFor P R :=
  (isSheafFor_iff_generate R).2 <| hp _ hr

theorem isSheaf_of_le (P : Cáµ’áµ– â¥¤ Type w) {Jâ‚ Jâ‚‚ : GrothendieckTopology C} :
    Jâ‚ â‰¤ Jâ‚‚ â†’ IsSheaf Jâ‚‚ P â†’ IsSheaf Jâ‚ P := fun h t _ S hS => t S (h _ hS)

variable {J} in
theorem IsSheaf.isSeparated {P : Cáµ’áµ– â¥¤ Type w} (h : IsSheaf J P) : IsSeparated J P :=
  fun S hS => (h S hS).isSeparatedFor

@[deprecated (since := "2025-08-28")] alias isSeparated_of_isSheaf := IsSheaf.isSeparated

section

variable {J} {Pâ‚ : Cáµ’áµ– â¥¤ Type w} {Pâ‚‚ : Cáµ’áµ– â¥¤ Type w'}
  (e : âˆ€ â¦ƒX : Câ¦„, Pâ‚.obj (op X) â‰ƒ Pâ‚‚.obj (op X))
  (he : âˆ€ â¦ƒX Y : Câ¦„ (f : X âŸ¶ Y) (x : Pâ‚.obj (op Y)),
    e (Pâ‚.map f.op x) = Pâ‚‚.map f.op (e x))

include he in
lemma isSheaf_of_nat_equiv (hPâ‚ : Presieve.IsSheaf J Pâ‚) :
    Presieve.IsSheaf J Pâ‚‚ := fun _ R hR â†¦
  isSheafFor_of_nat_equiv e he (hPâ‚ R hR)

include he in
lemma isSheaf_iff_of_nat_equiv :
    Presieve.IsSheaf J Pâ‚ â†” Presieve.IsSheaf J Pâ‚‚ :=
  âŸ¨fun hPâ‚ â†¦ isSheaf_of_nat_equiv e he hPâ‚,
    fun hPâ‚‚ â†¦
      isSheaf_of_nat_equiv (fun _ â†¦ (@e _).symm) (fun X Y f x â†¦ by
        obtain âŸ¨y, rflâŸ© := e.surjective x
        refine e.injective ?_
        simp only [Equiv.apply_symm_apply, Equiv.symm_apply_apply, he]) hPâ‚‚âŸ©

end

/-- The property of being a sheaf is preserved by isomorphism. -/
theorem isSheaf_iso {P' : Cáµ’áµ– â¥¤ Type w} (i : P â‰… P') (h : IsSheaf J P) : IsSheaf J P' :=
  fun _ S hS => isSheafFor_iso i (h S hS)

theorem isSheaf_of_yoneda {P : Cáµ’áµ– â¥¤ Type v}
    (h : âˆ€ {X} (S : Sieve X), S âˆˆ J X â†’ YonedaSheafCondition P S) : IsSheaf J P := fun _ _ hS =>
  isSheafFor_iff_yonedaSheafCondition.2 (h _ hS)

/-- For a topology generated by a basis, it suffices to check the sheaf condition on the basis
presieves only.
-/
theorem isSheaf_pretopology [HasPullbacks C] (K : Pretopology C) :
    IsSheaf (K.toGrothendieck C) P â†” âˆ€ {X : C} (R : Presieve X), R âˆˆ K X â†’ IsSheafFor P R := by
  constructor
  Â· intro PJ X R hR
    rw [isSheafFor_iff_generate]
    apply PJ (Sieve.generate R) âŸ¨_, hR, le_generate RâŸ©
  Â· rintro PK X S âŸ¨R, hR, RSâŸ©
    have gRS : â‡‘(generate R) â‰¤ S := by
      apply giGenerate.gc.monotone_u
      rwa [generate_le_iff]
    apply isSheafFor_subsieve P gRS _
    intro Y f
    rw [â† pullbackArrows_comm, â† isSheafFor_iff_generate]
    exact PK (pullbackArrows f R) (K.pullbacks f R hR)

/-- Any presheaf is a sheaf for the bottom (trivial) Grothendieck topology. -/
theorem isSheaf_bot : IsSheaf (âŠ¥ : GrothendieckTopology C) P := fun X => by
  simp [isSheafFor_top_sieve]

/-- The composition of a sheaf with a ULift functor is still a sheaf. -/
theorem isSheaf_comp_uliftFunctor (h : IsSheaf J P) : IsSheaf J (P â‹™ uliftFunctor.{w'}) :=
  isSheaf_of_nat_equiv (fun _ => Equiv.ulift.symm) (fun _ _ _ _ => rfl) h

/--
For a presheaf of the form `yoneda.obj W`, a compatible family of elements on a sieve
is the same as a co-cone over the sieve. Constructing a co-cone from a compatible family works for
any presieve, as does constructing a family of elements from a co-cone. Showing compatibility of the
family needs the sieve condition.
Note: This is related to `CategoryTheory.Presheaf.conesEquivSieveCompatibleFamily`
-/
def compatibleYonedaFamily_toCocone (R : Presieve X) (W : C) (x : FamilyOfElements (yoneda.obj W) R)
    (hx : FamilyOfElements.Compatible x) :
    Cocone (R.diagram) where
  pt := W
  Î¹ :=
    { app := fun f => x f.obj.hom f.property
      naturality := by
        intro gâ‚ gâ‚‚ F
        simp only [Functor.id_obj, Functor.comp_obj, ObjectProperty.Î¹_obj, Over.forget_obj,
          Functor.const_obj_obj, Functor.comp_map, ObjectProperty.Î¹_map, Over.forget_map,
          Functor.const_obj_map, comp_id]
        rw [â† Category.id_comp (x gâ‚.obj.hom gâ‚.property)]
        apply hx
        simp only [Functor.id_obj, Over.w, Opposite.unop_op, Category.id_comp] }

/-- Construct a family of elements from a cocone. -/
def yonedaFamilyOfElements_fromCocone (R : Presieve X) (s : Cocone (diagram R)) :
    FamilyOfElements (yoneda.obj s.pt) R :=
  fun _ f hf => s.Î¹.app âŸ¨Over.mk f, hfâŸ©

end Presieve

namespace Sieve
open Presieve

variable {C : Type u} [Category.{v} C]
variable {X : C}

theorem yonedaFamily_fromCocone_compatible (S : Sieve X) (s : Cocone (diagram S.arrows)) :
    FamilyOfElements.Compatible <| yonedaFamilyOfElements_fromCocone S.arrows s := by
  intro Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ hfâ‚ hfâ‚‚ hgf
  have Hs := s.Î¹.naturality
  simp only [Functor.id_obj, yoneda_obj_obj, Opposite.unop_op, yoneda_obj_map, Quiver.Hom.unop_op]
  dsimp [yonedaFamilyOfElements_fromCocone]
  have hgfâ‚ : S.arrows (gâ‚ â‰« fâ‚) := by exact Sieve.downward_closed S hfâ‚ gâ‚
  have hgfâ‚‚ : S.arrows (gâ‚‚ â‰« fâ‚‚) := by exact Sieve.downward_closed S hfâ‚‚ gâ‚‚
  let F : (Over.mk (gâ‚ â‰« fâ‚) : Over X) âŸ¶ (Over.mk (gâ‚‚ â‰« fâ‚‚) : Over X) := Over.homMk (ðŸ™ Z)
  let Fâ‚ : (Over.mk (gâ‚ â‰« fâ‚) : Over X) âŸ¶ (Over.mk fâ‚ : Over X) := Over.homMk gâ‚
  let Fâ‚‚ : (Over.mk (gâ‚‚ â‰« fâ‚‚) : Over X) âŸ¶ (Over.mk fâ‚‚ : Over X) := Over.homMk gâ‚‚
  have hF := @Hs âŸ¨Over.mk (gâ‚ â‰« fâ‚), hgfâ‚âŸ© âŸ¨Over.mk (gâ‚‚ â‰« fâ‚‚), hgfâ‚‚âŸ© F
  have hFâ‚ := @Hs âŸ¨Over.mk (gâ‚ â‰« fâ‚), hgfâ‚âŸ© âŸ¨Over.mk fâ‚, hfâ‚âŸ© Fâ‚
  have hFâ‚‚ := @Hs âŸ¨Over.mk (gâ‚‚ â‰« fâ‚‚), hgfâ‚‚âŸ© âŸ¨Over.mk fâ‚‚, hfâ‚‚âŸ© Fâ‚‚
  cat_disch

/--
The base of a sieve `S` is a colimit of `S` iff all Yoneda-presheaves satisfy
the sheaf condition for `S`.
-/
theorem forallYonedaIsSheaf_iff_colimit (S : Sieve X) :
    (âˆ€ W : C, Presieve.IsSheafFor (yoneda.obj W) (S : Presieve X)) â†”
      Nonempty (IsColimit S.arrows.cocone) := by
  constructor
  Â· intro H
    refine Nonempty.intro ?_
    exact
    { desc := fun s => H s.pt (yonedaFamilyOfElements_fromCocone S.arrows s)
        (yonedaFamily_fromCocone_compatible S s) |>.choose
      fac := by
        intro s f
        replace H := H s.pt (yonedaFamilyOfElements_fromCocone S.arrows s)
          (yonedaFamily_fromCocone_compatible S s)
        have ht := H.choose_spec.1 f.obj.hom f.property
        cat_disch
      uniq := by
        intro s Fs HFs
        replace H := H s.pt (yonedaFamilyOfElements_fromCocone S.arrows s)
          (yonedaFamily_fromCocone_compatible S s)
        apply H.choose_spec.2 Fs
        exact fun _ f hf => HFs âŸ¨Over.mk f, hfâŸ© }
  Â· intro H W x hx
    replace H := Classical.choice H
    let s := compatibleYonedaFamily_toCocone S.arrows W x hx
    use H.desc s
    constructor
    Â· exact fun _ f hf => (H.fac s) âŸ¨Over.mk f, hfâŸ©
    Â· exact fun g hg => H.uniq s g (fun âŸ¨âŸ¨f, _, homâŸ©, hfâŸ© => hg hom hf)

end Sieve

end CategoryTheory
