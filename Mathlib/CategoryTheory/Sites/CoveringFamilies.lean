/-
Copyright (c) 2024 Lagrange Mathematics and Computing Research Center. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anthony Bordg
-/
import Mathlib.CategoryTheory.Sites.Coverage

/-!
# Covering Families and their generated topology

Following Laurent Lafforgue, given a category `C`, we introduce the notion
`CategoryTheory.CoveringFamilies C` of covering families on `C`, i.e. a coverage
`CategoryTheory.Coverage C` satisfying three additional axioms, and we define
`CategoryTheory.CoveringFamilies.GeneratedTopology C cf` the topology on `C` generated by a
collection `cf` of covering families as the topology generated by its underlying coverage.

## Main Results

⋆ `CategoryTheory.CoveringFamilies.covering_of_generatedTopology_iff` : we give an explicit
  characterization of the covering sieves of the topology generated by covering families.

## References

⋆ Le problème de l'engendrement des topologies de Grothendieck, slides (not publicly available yet)
  of a talk given by Laurent Lafforgue at Centre Lagrange on 26th April 2024.

## Tags

Grothendieck topology, sieve, generated topology, coverage, covering families
-/

namespace CategoryTheory

variable (C : Type*) [Category C]

/-! ### The notion of covering families -/

open Sieve

/-- A collection of `CoveringFamilies` on `C` is a `Coverage` on `C` satisfying three additional
axioms. -/
structure CoveringFamilies extends Coverage C where
  /-- Every presieve generated by a morphism that has a section is a covering presieve. -/
  retraction_mem : ∀ ⦃X Y : C⦄ ⦃f : Y ⟶ X⦄, IsSplitEpi f → Presieve.singleton f ∈ covering X
   /-- Every presieve whose generated sieve contains a covering presieve is a covering presieve. -/
  heredity : ∀ ⦃X : C⦄ (P : Presieve X), (∃ Q, Q ∈ covering X ∧ Q ≤ generate P) → P ∈ covering X
  /-- A covering of a covering presieve is a covering presieve. -/
  multicomposition_stable : ∀ ⦃X : C⦄ (P : Presieve X)
    (Q : ∀ ⦃Xi : C⦄ ⦃f : Xi ⟶ X⦄, P f → Presieve Xi), P ∈ covering X →
      (hQ : ∀ ⦃Xi : C⦄ ⦃f : Xi ⟶ X⦄ (p : P f), Q p ∈ covering Xi) → P.bind Q ∈ covering X

variable (cf : CoveringFamilies C)

namespace CoveringFamilies

/-- `covering_of_generatedTopology_iff` gives an explicit characterization of the covering sieves
of the topology generated by a collection `cf` of covering families, those are exactly the sieves
that contain the sieve generated by a covering presieve. -/
theorem covering_of_generatedTopology_iff {X : C} (S : Sieve X) :
    (cf.toGrothendieck).sieves X S ↔ ∃ P ∈ cf.covering X, generate P ≤ S := by
  constructor
  · intro hS
    induction hS with
    | of X S hS => use S, hS
    | top X =>
        use Presieve.singleton (𝟙 X)
        constructor
        · exact cf.retraction_mem (IsSplitEpi.of_iso (𝟙 X))
        · rw [generate_of_singleton_isSplitEpi (𝟙 X)]
    | transitive X R S _ _ hR hS =>
        obtain ⟨P, h1P, h2P⟩ := hR
        have hS' : ∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, P f →
          ∃ P ∈ cf.covering Y, generate P ≤ pullback f S := by
            intro Y f hf
            have : R.arrows f := by
              apply h2P
              apply le_generate
              exact hf
            apply hS
            simpa
        let Q : ∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, P f → Presieve Y := fun Y f p => Exists.choose (hS' p)
        use P.bind Q
        constructor
        · apply multicomposition_stable
          exact h1P
          intro Xi f p
          cases Exists.choose_spec (hS' p)
          simpa
        · rw [generate_le_iff (P.bind Q) S]
          intro Z h Hh
          obtain ⟨Xi, g, f, hf, hg, eq⟩ := Hh
          rw [<- eq]
          rcases (Exists.choose_spec (hS' hf)) with ⟨_, hQ⟩
          apply hQ
          apply le_generate
          exact hg
  · intro hS
    have : S.arrows ∈ cf.covering X := by
      apply cf.heredity
      rw [generate_sieve S]
      rcases hS with ⟨P, h1P, h2P⟩
      use P, h1P
      apply LE.le.trans (le_generate P)
      exact h2P
    rw [← generate_sieve S]
    apply Coverage.Saturate.of X S
    simpa

end CoveringFamilies

end CategoryTheory
