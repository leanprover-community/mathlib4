/-
Copyright (c) 2024 Lagrange Mathematics and Computing Research Center. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anthony Bordg
-/
import Mathlib.CategoryTheory.Sites.Coverage

/-!
# Covering Families and their generated topology

Following Laurent Lafforgue, given a category `C`, we introduce the notion
`CategoryTheory.CoveringFamilies C` of covering families on `C`, i.e. a coverage
`CategoryTheory.Coverage C` satisfying three additional axioms, and we define
`CategoryTheory.CoveringFamilies.GeneratedTopology C cf` the topology on `C` generated by a
collection `cf` of covering families as the topology generated by its underlying coverage.

## Main Results

â‹† `CategoryTheory.CoveringFamilies.covering_of_generatedTopology_iff` : we give an explicit
  characterization of the covering sieves of the topology generated by covering families.

## References

â‹† Le problÃ¨me de l'engendrement des topologies de Grothendieck, slides (not publicly available yet)
  of a talk given by Laurent Lafforgue at Centre Lagrange on 26th April 2024.

## Tags

Grothendieck topology, sieve, generated topology, coverage, covering families
-/

namespace CategoryTheory

variable (C : Type*) [Category C]

/-! ### The notion of covering families -/

open Sieve

/-- A collection of `CoveringFamilies` on `C` is a `Coverage` on `C` satisfying three additional
axioms. -/
structure CoveringFamilies extends Coverage C where
  /-- Every presieve generated by a morphism that has a section is a covering presieve. -/
  retraction_mem : âˆ€ â¦ƒX Y : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, IsSplitEpi f â†’ Presieve.singleton f âˆˆ covering X
   /-- Every presieve whose generated sieve contains a covering presieve is a covering presieve. -/
  heredity : âˆ€ â¦ƒX : Câ¦„ (P : Presieve X), (âˆƒ Q, Q âˆˆ covering X âˆ§ Q â‰¤ generate P) â†’ P âˆˆ covering X
  /-- A covering of a covering presieve is a covering presieve. -/
  multicomposition_stable : âˆ€ â¦ƒX : Câ¦„ (P : Presieve X)
    (Q : âˆ€ â¦ƒXi : Câ¦„ â¦ƒf : Xi âŸ¶ Xâ¦„, P f â†’ Presieve Xi), P âˆˆ covering X â†’
      (hQ : âˆ€ â¦ƒXi : Câ¦„ â¦ƒf : Xi âŸ¶ Xâ¦„ (p : P f), Q p âˆˆ covering Xi) â†’ P.bind Q âˆˆ covering X

variable (cf : CoveringFamilies C)

namespace CoveringFamilies

/-- `covering_of_generatedTopology_iff` gives an explicit characterization of the covering sieves
of the topology generated by a collection `cf` of covering families, those are exactly the sieves
that contain the sieve generated by a covering presieve. -/
theorem covering_of_generatedTopology_iff {X : C} (S : Sieve X) :
    (cf.toGrothendieck).sieves X S â†” âˆƒ P âˆˆ cf.covering X, generate P â‰¤ S := by
  constructor
  Â· intro hS
    induction hS with
    | of X S hS => use S, hS
    | top X =>
        use Presieve.singleton (ðŸ™ X)
        constructor
        Â· exact cf.retraction_mem (IsSplitEpi.of_iso (ðŸ™ X))
        Â· rw [generate_of_singleton_isSplitEpi (ðŸ™ X)]
    | transitive X R S _ _ hR hS =>
        obtain âŸ¨P, h1P, h2PâŸ© := hR
        have hS' : âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, P f â†’
          âˆƒ P âˆˆ cf.covering Y, generate P â‰¤ pullback f S := by
            intro Y f hf
            have : R.arrows f := by
              apply h2P
              apply le_generate
              exact hf
            apply hS
            simpa
        let Q : âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, P f â†’ Presieve Y := fun Y f p => Exists.choose (hS' p)
        use P.bind Q
        constructor
        Â· apply multicomposition_stable
          exact h1P
          intro Xi f p
          cases Exists.choose_spec (hS' p)
          simpa
        Â· rw [generate_le_iff (P.bind Q) S]
          intro Z h Hh
          obtain âŸ¨Xi, g, f, hf, hg, eqâŸ© := Hh
          rw [<- eq]
          rcases (Exists.choose_spec (hS' hf)) with âŸ¨_, hQâŸ©
          apply hQ
          apply le_generate
          exact hg
  Â· intro hS
    have : S.arrows âˆˆ cf.covering X := by
      apply cf.heredity
      rw [generate_sieve S]
      rcases hS with âŸ¨P, h1P, h2PâŸ©
      use P, h1P
      apply LE.le.trans (le_generate P)
      exact h2P
    rw [â† generate_sieve S]
    apply Coverage.Saturate.of X S
    simpa

end CoveringFamilies

end CategoryTheory
