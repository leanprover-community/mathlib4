/-
Copyright (c) 2024 Lagrange Mathematics and Computing Research Center. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anthony Bordg
-/
import Mathlib.CategoryTheory.Sites.Grothendieck

/-!
# The Topology Generated by Covering Families

Given a category `C`, we introduce the Grothendieck topology `Basis.GeneratedTopology`
on `C` generated by a basis. This topology is defined as the intersection of all the Grothendieck
topologies `J` on `C` satisfying that for every element `P` of the basis the sieve generated by `P`
is `J`-covering. Following Laurent Lafforgue, we also introduce the notion `CoveringFamilies` of
covering families, i.e. a basis satisfying four axioms, and we define by an explicit formula the
Grothendieck topology `CoveringFamilies.GeneratedTopology` generated by these covering families.

## Main Results

- `characterization_of_generatedtopology` : Given a collection of covering families, we show that
the topology generated by this collection and the topology generated by its underlying basis
coincide, offering in this case an explicit characterization of the covering sieves of the latter.

## References

â‹† Le problÃ¨me de l'engendrement des topologies de Grothendieck, slides (not publicly available yet
as of July 2024) of a talk given by Laurent Lafforgue at Centre Lagrange on 26th April 2024.

## Tags

Grothendieck topology, sieve, generated topology, basis, covering families
-/

universe u v

open CategoryTheory Sieve

variable {C : Type u} [Category.{v} C]

namespace Basis

/-! ### The Grothendieck topology generated by a basis and the notion of covering families -/

/-- `Basis.GeneratedTopology` defines the Grothendieck topology generated by a `basis`, i.e. by
a set of presieves on `X` for every object `X` of the category `C`. -/
def GeneratedTopology (basis : (X : C) â†’ Set (Presieve X)) : GrothendieckTopology C :=
  sInf {J : GrothendieckTopology C | âˆ€ {X P}, P âˆˆ basis X â†’ generate P âˆˆ J.sieves X}

/-- A notion of covering families consists of a `basis` satisfying four axioms. -/
structure CoveringFamilies where
  /-- A `basis` consists of a set of presieves, called the covering families, for each object `X`
  of `C`. -/
  basis : (X : C) â†’ Set (Presieve X)
  /-- Every presieve generated by a morphism that has a section belongs to the basis. -/
  retraction_mem : âˆ€ â¦ƒX Y : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, IsSplitEpi f â†’ Presieve.singleton f âˆˆ basis X
  /-- Every presieve whose generated sieve contains an element of the basis belongs to the basis.
  -/
  heredity : âˆ€ â¦ƒX : Câ¦„ (P : Presieve X), (âˆƒ Q, Q âˆˆ basis X âˆ§ Q â‰¤ generate P) â†’ P âˆˆ basis X
  /-- For every element `P` of `basis X` and every morphism `f : Y âŸ¶ X`, there exists an element
  `Q` of `basis Y` such that the set of composites `g â‰« f`, where `g` belongs to `Q`, factors
  through the sieve generated by `P`. -/
  pullback_stable : âˆ€ â¦ƒX Y : Câ¦„ (P : Presieve X) (f : Y âŸ¶ X), P âˆˆ basis X â†’
    (âˆƒ Q, Q âˆˆ basis Y âˆ§ (fun Z => {g â‰« f | (g : Z âŸ¶ Y) (_ : Q g)}) â‰¤ generate P)
  /-- A covering of a covering family is a covering family. -/
  multicomposition_stable : âˆ€ â¦ƒX : Câ¦„ (P : Presieve X)
    (Q : âˆ€ â¦ƒXi : Câ¦„ â¦ƒf : Xi âŸ¶ Xâ¦„, P f â†’ Presieve Xi), P âˆˆ basis X â†’
      (hQ : âˆ€ â¦ƒXi : Câ¦„ â¦ƒf : Xi âŸ¶ Xâ¦„ (p : P f), Q p âˆˆ basis Xi) â†’ P.bind Q âˆˆ basis X

end Basis

open Basis

variable (cf : CoveringFamilies (C := C))

namespace CoveringFamilies

/-! ### The Grothendieck topology generated by covering families -/

/-- `CoveringFamilies.GeneratedTopology` defines the topology generated by a collection of covering
families. -/
def GeneratedTopology : GrothendieckTopology C where
  sieves X S := âˆƒ P âˆˆ cf.basis X, generate P â‰¤ S
  top_mem' X := by
    use Presieve.singleton (ğŸ™ X)
    constructor
    Â· apply cf.retraction_mem
      apply IsSplitEpi.of_iso
    Â· simp
  pullback_stable' X Y S f hS := by
    rcases hS with âŸ¨P, h1P, h2PâŸ©
    rcases cf.pullback_stable P f h1P with âŸ¨Q, h1Q, h2QâŸ©
    use Q
    constructor
    Â· exact h1Q
    Â· intros Z g hg; simp
      rw [generate_apply Q Z g] at hg
      rcases hg with âŸ¨Z', h, g', h1g', h2g'âŸ©
      rw [â† h2g']
      rw [Category.assoc h g' f]
      apply S.downward_closed
      have hg : g' â‰« f âˆˆ {g â‰« f | (g : Z' âŸ¶ Y) (_ : Q g)} := by
        use g', h1g'
      specialize h2Q Z' hg
      apply h2P
      exact h2Q
  transitive' := by admit

/-- The covering sieves with respect to the topology generated by a collection of covering families
are exactly the sieves generated by the elements of the underlying basis. -/
@[simp]
theorem generatedTopology_covering_iff {X : C} (S : Sieve X) :
    S âˆˆ (GeneratedTopology cf).sieves X â†” âˆƒ P âˆˆ cf.basis X, S = generate P := by
  constructor
  Â· intro hS
    use S
    constructor
    Â· rcases hS with âŸ¨P, h1P, h2PâŸ©
      apply cf.heredity S.arrows
      use P, h1P
      rw [generate_sieve S]
      apply le_trans (le_generate P) h2P
    Â· apply symm
      exact S.generate_sieve
  Â· intro hS
    rcases hS with âŸ¨P, h1P, h2PâŸ©
    use P, h1P
    rw [â† h2P]

end CoveringFamilies

namespace Basis

/-- Given a collection of covering families, the topology generated by this collection and the
topology generated by its underlying basis coincide, providing in this case an explicit
characterization of the covering sieves of the latter. -/
theorem characterization_of_generatedTopology {X : C} (S : Sieve X) :
    S âˆˆ (GeneratedTopology cf.basis).sieves X â†” âˆƒ P âˆˆ cf.basis X, S = generate P := by
  constructor
  Â· intro hS
    have : S âˆˆ (CoveringFamilies.GeneratedTopology cf).sieves X := by
      let E := {J : GrothendieckTopology C | âˆ€ {X P}, P âˆˆ cf.basis X â†’ generate P âˆˆ J.sieves X}
      apply CompleteLattice.sInf_le E
      Â· intros X P hP
        rw [CoveringFamilies.generatedTopology_covering_iff]
        use P, hP
      Â· exact hS
    simpa
  Â· intros hS JX hJX
    rcases hJX with âŸ¨Js, hJXâŸ©
    rcases Js with âŸ¨Js, J, hJ, hJsâŸ©
    rw [â† hJX]; simp
    rw [â† hJs]
    rcases hS with âŸ¨P, h1P, h2PâŸ©
    rw [h2P]
    apply hJ
    exact h1P

end Basis
