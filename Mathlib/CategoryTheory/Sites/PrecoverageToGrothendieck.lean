/-
Copyright (c) 2025 BenoÃ®t Guillemet. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Adam Topaz, BenoÃ®t Guillemet
-/
module

public import Mathlib.CategoryTheory.Sites.Precoverage
public import Mathlib.CategoryTheory.Sites.SheafOfTypes

/-!

# Grothendieck topology generated by a precoverage

For any category `C`, we define the Grothendieck topology generated by a precoverage `J` on `C`.
It is the smallest Grothendieck topology containing all the sieves generated by the covering
presieves of `J`.

The main definitions and theorems are:
- `Precoverage.toGrothendieck`: The Grothendieck topology generated by the sieves generated by the
  covering presieves of `J`.
- `Precoverage.toGrothendieck_eq_sInf`: The Grothendieck topology generated by `J` is the infimum
  of the Grothendieck topologies containing all the sieves generated by the covering presieves
  of `J`.
- `Presieve.isSheaf_toGrothendieck_iff`: Given `J : Precoverage C` with associated Grothendieck
  topology `K`, a `Type*`-valued presheaf on `C` is a sheaf for `K` if and only if it is a sheaf
  for all pullbacks of the covering presieves of `J`.
-/

@[expose] public section

namespace CategoryTheory

variable {C : Type _} [Category C]

namespace Precoverage

variable {J : Precoverage C}

/--
An auxiliary definition used to define the Grothendieck topology associated to a precoverage.
See `Precoverage.toGrothendieck`.
-/
inductive Saturate (J : Precoverage C) : (X : C) â†’ Sieve X â†’ Prop where
  | of (X : C) (S : Presieve X) (hS : S âˆˆ J X) : J.Saturate X (Sieve.generate S)
  | top (X : C) : J.Saturate X âŠ¤
  | pullback (X : C) (S : Sieve X) : J.Saturate X S â†’ âˆ€ (Y : C) (f : Y âŸ¶ X),
      J.Saturate Y (S.pullback f)
  | transitive (X : C) (S R : Sieve X) : J.Saturate X S â†’
      (âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, S f â†’ J.Saturate Y (R.pullback f)) â†’ J.Saturate X R

/--
The Grothendieck topology associated to a precoverage `J`.
It is defined *inductively* as follows:
1. If `S` is a covering presieve for `J`, then the sieve generated by `S` is a covering
  sieve for the associated Grothendieck topology.
2. The top sieves are in the associated Grothendieck topology.
3. Add all sieves required by the pullback stability condition of a Grothendieck topology.
4. Add all sieves required by the *local character* axiom of a Grothendieck topology.
-/
def toGrothendieck (J : Precoverage C) : GrothendieckTopology C where
  sieves := J.Saturate
  top_mem' := .top
  pullback_stable' _ _ _ _ hS := .pullback _ _ hS _ _
  transitive' _ _ hS _ hR := .transitive _ _ _ hS hR

lemma mem_toGrothendieck_iff {X : C} {S : Sieve X} :
    S âˆˆ J.toGrothendieck X â†” J.Saturate X S := .rfl

@[grind .]
lemma generate_mem_toGrothendieck {X : C} {R : Presieve X} (hR : R âˆˆ J X) :
    Sieve.generate R âˆˆ J.toGrothendieck X :=
  .of _ _ hR

/--
An alternative characterization of the Grothendieck topology associated to a precoverage `J`:
it is the infimum of all Grothendieck topologies containing `Sieve.generate S` for all presieves
`S` in `J`.
-/
lemma toGrothendieck_eq_sInf (J : Precoverage C) :
    J.toGrothendieck =
      sInf { K | âˆ€ â¦ƒX : Câ¦„ (S : Presieve X), S âˆˆ J X â†’ Sieve.generate S âˆˆ K X } := by
  refine le_antisymm ?_ ?_
  Â· rw [le_sInf_iff]
    intro K hK _ _ hS
    induction hS with
    | of _ _ hS => exact hK _ hS
    | top => exact K.top_mem _
    | pullback _ _ _ _ _ ih => exact K.pullback_stable _ ih
    | transitive _ _ _ _ _ ih1 ih2 => exact K.transitive ih1 _ ih2
  Â· exact sInf_le (fun _ _ hS => .of _ _ hS)

/--
The main theorem of this file: given a precoverage `J` on `C`, a `Type*`-valued presheaf on `C` is
a sheaf for the associated Grothendieck topology if and only if it is a sheaf for all pullback
sieves of presieves in `J`.
-/
theorem isSheaf_toGrothendieck_iff (P : Cáµ’áµ– â¥¤ Type*) :
    Presieve.IsSheaf J.toGrothendieck P â†”
      (âˆ€ {X Y : C} {f : Y âŸ¶ X} (R : Presieve X), R âˆˆ J X â†’
        Presieve.IsSheafFor P ((Sieve.generate R).pullback f).arrows) := by
  constructor
  Â· refine fun H _ _ _ _ hR => H.isSheafFor _ _ ?_
    rw [Sieve.generate_sieve]
    exact J.toGrothendieck.pullback_stable _ (Saturate.of _ _ hR)
  Â· intro H X S hS
    -- This is the key point of the proof:
    -- We must generalize the induction in the correct way.
    suffices âˆ€ â¦ƒY : Câ¦„ (f : Y âŸ¶ X), Presieve.IsSheafFor P (S.pullback f).arrows by
      simpa using this (f := ğŸ™ _)
    induction hS with
    | of X S hS =>
      exact fun _ _ => H S hS
    | top =>
      simp [Presieve.isSheafFor_top_sieve P]
    | pullback X S hS _ f ih =>
      intro Y f
      rw [â† S.pullback_comp]
      exact ih (f â‰« _)
    | transitive X R S hS h H1 H2 =>
      intro Y f
      simp only [â† Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor] at *
      choose H1 H1' using H1
      choose H2 H2' using H2
      refine âŸ¨?_, fun x hx => ?_âŸ©
      Â· intro x tâ‚ tâ‚‚ hâ‚ hâ‚‚
        refine (H1 f).ext (fun Z g hg => ?_)
        refine (H2 hg (ğŸ™ _)).ext (fun ZZ gg hgg => ?_)
        simp only [Sieve.pullback_id, Sieve.pullback_apply] at hgg
        simp only [â† types_comp_apply]
        rw [â† P.map_comp, â† op_comp, hâ‚, hâ‚‚]
        simpa only [Sieve.pullback_apply, Category.assoc] using hgg
      let y : âˆ€ â¦ƒZ : Câ¦„ (g : Z âŸ¶ Y),
        ((S.pullback (g â‰« f)).pullback (ğŸ™ _)).arrows.FamilyOfElements P :=
        fun Z g ZZ gg hgg => x (gg â‰« g) (by simpa using hgg)
      have hy : âˆ€ â¦ƒZ : Câ¦„ (g : Z âŸ¶ Y), (y g).Compatible := by
        intro Z g Yâ‚ Yâ‚‚ ZZ gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ h
        rw [hx]
        rw [reassoc_of% h]
      choose z hz using fun â¦ƒZ : Câ¦„ â¦ƒg : Z âŸ¶ Yâ¦„ (hg : R.pullback f g) =>
        H2' hg (ğŸ™ _) (y g) (hy g)
      let q : (R.pullback f).arrows.FamilyOfElements P := fun Z g hg => z hg
      have hq : q.Compatible := by
        intro Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ h
        apply (H2 hâ‚ gâ‚).ext
        intro ZZ gg hgg
        simp only [â† types_comp_apply]
        rw [â† P.map_comp, â† P.map_comp, â† op_comp, â† op_comp, hz, hz]
        Â· dsimp [y]; congr 1; simp only [Category.assoc, h]
        Â· simpa [reassoc_of% h] using hgg
        Â· simpa using hgg
      obtain âŸ¨t, htâŸ© := H1' f q hq
      refine âŸ¨t, fun Z g hg => ?_âŸ©
      refine (H1 (g â‰« f)).ext (fun ZZ gg hgg => ?_)
      rw [â† types_comp_apply _ (P.map gg.op), â† P.map_comp, â† op_comp, ht]
      on_goal 2 => simpa using hgg
      refine (H2 hgg (ğŸ™ _)).ext (fun ZZZ ggg hggg => ?_)
      rw [â† types_comp_apply _ (P.map ggg.op), â† P.map_comp, â† op_comp, hz]
      on_goal 2 => simpa using hggg
      refine (H2 hgg ggg).ext (fun ZZZZ gggg _ => ?_)
      rw [â† types_comp_apply _ (P.map gggg.op), â† P.map_comp, â† op_comp]
      apply hx
      simp

end Precoverage

@[grind .]
lemma Presieve.IsSheaf.isSheafFor_of_mem_precoverage {J : Precoverage C} {P : Cáµ’áµ– â¥¤ Type*}
    (h : Presieve.IsSheaf J.toGrothendieck P) {S : C} {R : Presieve S}
    (hR : R âˆˆ J S) : R.IsSheafFor P := by
  rw [J.isSheaf_toGrothendieck_iff] at h
  simpa [Presieve.isSheafFor_iff_generate] using h (f := ğŸ™ S) R hR

end CategoryTheory
