/-
Copyright (c) 2025 Beno√Æt Guillemet. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Adam Topaz, Beno√Æt Guillemet
-/
module

public import Mathlib.CategoryTheory.Sites.Hypercover.Zero
public import Mathlib.CategoryTheory.Sites.SheafOfTypes

/-!

# Grothendieck topology generated by a precoverage

For any category `C`, we define the Grothendieck topology generated by a precoverage `J` on `C`.
It is the smallest Grothendieck topology containing all the sieves generated by the covering
presieves of `J`.

The main definitions and theorems are:
- `Precoverage.toGrothendieck`: The Grothendieck topology generated by the sieves generated by the
  covering presieves of `J`.
- `Precoverage.toGrothendieck_eq_sInf`: The Grothendieck topology generated by `J` is the infimum
  of the Grothendieck topologies containing all the sieves generated by the covering presieves
  of `J`.
- `Presieve.isSheaf_toGrothendieck_iff`: Given `J : Precoverage C` with associated Grothendieck
  topology `K`, a `Type*`-valued presheaf on `C` is a sheaf for `K` if and only if it is a sheaf
  for all pullbacks of the covering presieves of `J`.
-/

@[expose] public section

namespace CategoryTheory

variable {C : Type _} [Category C]

namespace Precoverage

variable {J : Precoverage C}

/--
An auxiliary definition used to define the Grothendieck topology associated to a precoverage.
See `Precoverage.toGrothendieck`.
-/
inductive Saturate (J : Precoverage C) : (X : C) ‚Üí Sieve X ‚Üí Prop where
  | of (X : C) (S : Presieve X) (hS : S ‚àà J X) : J.Saturate X (Sieve.generate S)
  | top (X : C) : J.Saturate X ‚ä§
  | pullback (X : C) (S : Sieve X) : J.Saturate X S ‚Üí ‚àÄ (Y : C) (f : Y ‚ü∂ X),
      J.Saturate Y (S.pullback f)
  | transitive (X : C) (S R : Sieve X) : J.Saturate X S ‚Üí
      (‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí J.Saturate Y (R.pullback f)) ‚Üí J.Saturate X R

/--
The Grothendieck topology associated to a precoverage `J`.
It is defined *inductively* as follows:
1. If `S` is a covering presieve for `J`, then the sieve generated by `S` is a covering
  sieve for the associated Grothendieck topology.
2. The top sieves are in the associated Grothendieck topology.
3. Add all sieves required by the pullback stability condition of a Grothendieck topology.
4. Add all sieves required by the *local character* axiom of a Grothendieck topology.
-/
def toGrothendieck (J : Precoverage C) : GrothendieckTopology C where
  sieves := J.Saturate
  top_mem' := .top
  pullback_stable' _ _ _ _ hS := .pullback _ _ hS _ _
  transitive' _ _ hS _ hR := .transitive _ _ _ hS hR

lemma mem_toGrothendieck_iff {X : C} {S : Sieve X} :
    S ‚àà J.toGrothendieck X ‚Üî J.Saturate X S := .rfl

@[grind .]
lemma generate_mem_toGrothendieck {X : C} {R : Presieve X} (hR : R ‚àà J X) :
    Sieve.generate R ‚àà J.toGrothendieck X :=
  .of _ _ hR

/--
An alternative characterization of the Grothendieck topology associated to a precoverage `J`:
it is the infimum of all Grothendieck topologies containing `Sieve.generate S` for all presieves
`S` in `J`.
-/
lemma toGrothendieck_eq_sInf (J : Precoverage C) :
    J.toGrothendieck =
      sInf { K | ‚àÄ ‚¶ÉX : C‚¶Ñ (S : Presieve X), S ‚àà J X ‚Üí Sieve.generate S ‚àà K X } := by
  refine le_antisymm ?_ ?_
  ¬∑ rw [le_sInf_iff]
    intro K hK _ _ hS
    induction hS with
    | of _ _ hS => exact hK _ hS
    | top => exact K.top_mem _
    | pullback _ _ _ _ _ ih => exact K.pullback_stable _ ih
    | transitive _ _ _ _ _ ih1 ih2 => exact K.transitive ih1 _ ih2
  ¬∑ exact sInf_le (fun _ _ hS => .of _ _ hS)

/--
The main theorem of this file: given a precoverage `J` on `C`, a `Type*`-valued presheaf on `C` is
a sheaf for the associated Grothendieck topology if and only if it is a sheaf for all pullback
sieves of presieves in `J`.
-/
theorem isSheaf_toGrothendieck_iff (P : C·µí·µñ ‚•§ Type*) :
    Presieve.IsSheaf J.toGrothendieck P ‚Üî
      (‚àÄ {X Y : C} {f : Y ‚ü∂ X} (R : Presieve X), R ‚àà J X ‚Üí
        Presieve.IsSheafFor P ((Sieve.generate R).pullback f).arrows) := by
  constructor
  ¬∑ refine fun H _ _ _ _ hR => H.isSheafFor _ _ ?_
    rw [Sieve.generate_sieve]
    exact J.toGrothendieck.pullback_stable _ (Saturate.of _ _ hR)
  ¬∑ intro H X S hS
    -- This is the key point of the proof:
    -- We must generalize the induction in the correct way.
    suffices ‚àÄ ‚¶ÉY : C‚¶Ñ (f : Y ‚ü∂ X), Presieve.IsSheafFor P (S.pullback f).arrows by
      simpa using this (f := ùüô _)
    induction hS with
    | of X S hS =>
      exact fun _ _ => H S hS
    | top =>
      simp [Presieve.isSheafFor_top P]
    | pullback X S hS _ f ih =>
      intro Y f
      rw [‚Üê S.pullback_comp]
      exact ih (f ‚â´ _)
    | transitive X R S hS h H1 H2 =>
      intro Y f
      simp only [‚Üê Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor] at *
      choose H1 H1' using H1
      choose H2 H2' using H2
      refine ‚ü®?_, fun x hx => ?_‚ü©
      ¬∑ intro x t‚ÇÅ t‚ÇÇ h‚ÇÅ h‚ÇÇ
        refine (H1 f).ext (fun Z g hg => ?_)
        refine (H2 hg (ùüô _)).ext (fun ZZ gg hgg => ?_)
        simp only [Sieve.pullback_id, Sieve.pullback_apply] at hgg
        simp only [‚Üê types_comp_apply]
        rw [‚Üê P.map_comp, ‚Üê op_comp, h‚ÇÅ, h‚ÇÇ]
        simpa only [Sieve.pullback_apply, Category.assoc] using hgg
      let y : ‚àÄ ‚¶ÉZ : C‚¶Ñ (g : Z ‚ü∂ Y),
        ((S.pullback (g ‚â´ f)).pullback (ùüô _)).arrows.FamilyOfElements P :=
        fun Z g ZZ gg hgg => x (gg ‚â´ g) (by simpa using hgg)
      have hy : ‚àÄ ‚¶ÉZ : C‚¶Ñ (g : Z ‚ü∂ Y), (y g).Compatible := by
        intro Z g Y‚ÇÅ Y‚ÇÇ ZZ g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ h
        rw [hx]
        rw [reassoc_of% h]
      choose z hz using fun ‚¶ÉZ : C‚¶Ñ ‚¶Ég : Z ‚ü∂ Y‚¶Ñ (hg : R.pullback f g) =>
        H2' hg (ùüô _) (y g) (hy g)
      let q : (R.pullback f).arrows.FamilyOfElements P := fun Z g hg => z hg
      have hq : q.Compatible := by
        intro Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ h
        apply (H2 h‚ÇÅ g‚ÇÅ).ext
        intro ZZ gg hgg
        simp only [‚Üê types_comp_apply]
        rw [‚Üê P.map_comp, ‚Üê P.map_comp, ‚Üê op_comp, ‚Üê op_comp, hz, hz]
        ¬∑ dsimp [y]; congr 1; simp only [Category.assoc, h]
        ¬∑ simpa [reassoc_of% h] using hgg
        ¬∑ simpa using hgg
      obtain ‚ü®t, ht‚ü© := H1' f q hq
      refine ‚ü®t, fun Z g hg => ?_‚ü©
      refine (H1 (g ‚â´ f)).ext (fun ZZ gg hgg => ?_)
      rw [‚Üê types_comp_apply _ (P.map gg.op), ‚Üê P.map_comp, ‚Üê op_comp, ht]
      on_goal 2 => simpa using hgg
      refine (H2 hgg (ùüô _)).ext (fun ZZZ ggg hggg => ?_)
      rw [‚Üê types_comp_apply _ (P.map ggg.op), ‚Üê P.map_comp, ‚Üê op_comp, hz]
      on_goal 2 => simpa using hggg
      refine (H2 hgg ggg).ext (fun ZZZZ gggg _ => ?_)
      rw [‚Üê types_comp_apply _ (P.map gggg.op), ‚Üê P.map_comp, ‚Üê op_comp]
      apply hx
      simp

lemma mem_toGrothendieck_iff_of_isStableUnderComposition [IsStableUnderComposition J]
    [IsStableUnderBaseChange J] [J.HasPullbacks] [HasIsos J] {X : C} {S : Sieve X} :
    S ‚àà J.toGrothendieck X ‚Üî ‚àÉ R ‚àà J X, R ‚â§ S := by
  refine ‚ü®fun hS ‚Ü¶ ?_, fun ‚ü®R, hR, hle‚ü© ‚Ü¶ ?_‚ü©
  ¬∑ induction hS with
    | of X R hR =>
      use R, hR
      exact Sieve.le_generate R
    | top X =>
      exact ‚ü®Presieve.singleton (ùüô X), mem_coverings_of_isIso (ùüô X), by simp‚ü©
    | pullback X S hS Y f h =>
      obtain ‚ü®R, hR, hle‚ü© := h
      have : R.HasPullbacks f := J.hasPullbacks_of_mem f hR
      refine ‚ü®R.pullbackArrows f, pullbackArrows_mem f hR, ?_‚ü©
      rw [‚Üê Sieve.generate_le_iff, Sieve.pullbackArrows_comm]
      apply Sieve.pullback_monotone
      rwa [Sieve.generate_le_iff]
    | transitive X S T hS hT hleS hleT =>
      obtain ‚ü®R, hR, hle‚ü© := hleS
      rw [mem_iff_exists_zeroHypercover] at hR
      obtain ‚ü®E, rfl‚ü© := hR
      replace hleT (i : E.I‚ÇÄ) : ‚àÉ (F : J.ZeroHypercover (E.X i)),
          F.presieve‚ÇÄ ‚â§ (Sieve.pullback (E.f i) T).arrows := by
        obtain ‚ü®R', hR', hle'‚ü© := hleT (hle _ ‚ü®i‚ü©)
        rw [mem_iff_exists_zeroHypercover] at hR'
        obtain ‚ü®F, rfl‚ü© := hR'
        use F
      choose F hle' using hleT
      refine ‚ü®(E.bind F).presieve‚ÇÄ, (E.bind F).mem‚ÇÄ, ?_‚ü©
      rw [Presieve.ofArrows_le_iff]
      intro i
      exact hle' _ _ ‚ü®i.snd‚ü©
  ¬∑ rw [‚Üê Sieve.generate_le_iff] at hle
    apply GrothendieckTopology.superset_covering _ hle
    exact generate_mem_toGrothendieck hR

lemma toGrothendieck_toPretopology_eq_toGrothendieck [IsStableUnderComposition J]
    [IsStableUnderBaseChange J] [Limits.HasPullbacks C] [HasIsos J] :
    J.toPretopology.toGrothendieck = J.toGrothendieck := by
  ext
  exact J.mem_toGrothendieck_iff_of_isStableUnderComposition.symm

end Precoverage

@[grind .]
lemma Presieve.IsSheaf.isSheafFor_of_mem_precoverage {J : Precoverage C} {P : C·µí·µñ ‚•§ Type*}
    (h : Presieve.IsSheaf J.toGrothendieck P) {S : C} {R : Presieve S}
    (hR : R ‚àà J S) : R.IsSheafFor P := by
  rw [J.isSheaf_toGrothendieck_iff] at h
  simpa [Presieve.isSheafFor_iff_generate] using h (f := ùüô S) R hR

end CategoryTheory
