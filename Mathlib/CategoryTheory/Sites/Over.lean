/-
Copyright (c) 2023 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathlib.CategoryTheory.Sites.CoverLifting

/-! Localization

In this file, given a Grothendieck topology `J` on a category `C` and `X : C`, we construct
a Grothendieck topology `J.over X` on the category `Over X`. In order to do this,
we first construct a bijection `Sieve.overEquiv Y : Sieve Y ‚âÉ Sieve Y.left`
for all `Y : Over X`. Then, as it is stated in SGA 4 III 5.2.1, a sieve of `Y : Over X`
is covering for `J.over X` if and only if the corresponding sieve of `Y.left`
is covering for `J`. As a result, the forgetful functor
`Over.forget X : Over X ‚•§ X` is both cover-preserving and cover-lifting.

-/

universe v' v u' u

namespace CategoryTheory

open Category

variable {C : Type u} [Category.{v} C]

namespace Sieve

/-- The equivalence `Sieve Y ‚âÉ Sieve Y.left` for all `Y : Over X`. -/
def overEquiv {X : C} (Y : Over X) :
    Sieve Y ‚âÉ Sieve Y.left where
  toFun S := Sieve.functorPushforward (Over.forget X) S
  invFun S' := Sieve.functorPullback (Over.forget X) S'
  left_inv S := by
    ext Z g
    dsimp [Presieve.functorPullback, Presieve.functorPushforward]
    constructor
    ¬∑ rintro ‚ü®W, a, b, h, w‚ü©
      let c : Z ‚ü∂ W := Over.homMk b
        (by rw [‚Üê Over.w g, w, assoc, Over.w a])
      rw [show g = c ‚â´ a by ext; exact w]
      exact S.downward_closed h _
    ¬∑ intro h
      exact ‚ü®Z, g, ùüô _, h, by simp‚ü©
  right_inv S := by
    ext Z g
    dsimp [Presieve.functorPullback, Presieve.functorPushforward]
    constructor
    ¬∑ rintro ‚ü®W, a, b, h, rfl‚ü©
      exact S.downward_closed h _
    ¬∑ intro h
      exact ‚ü®Over.mk ((g ‚â´ Y.hom)), Over.homMk g, ùüô _, h, by simp‚ü©

@[simp]
lemma overEquiv_top {X : C} (Y : Over X) :
    overEquiv Y ‚ä§ = ‚ä§ := by
  ext Z g
  simp only [top_apply, iff_true]
  dsimp [overEquiv, Presieve.functorPushforward]
  exact ‚ü®Y, ùüô Y, g, by simp, by simp‚ü©

@[simp]
lemma overEquiv_symm_top {X : C} (Y : Over X) :
    (overEquiv Y).symm ‚ä§ = ‚ä§ :=
  (overEquiv Y).injective (by simp)

lemma overEquiv_pullback {X : C} {Y‚ÇÅ Y‚ÇÇ : Over X} (f : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) (S : Sieve Y‚ÇÇ) :
    overEquiv _ (S.pullback f) = (overEquiv _ S).pullback f.left := by
  ext Z g
  dsimp [overEquiv, Presieve.functorPushforward]
  constructor
  ¬∑ rintro ‚ü®W, a, b, h, rfl‚ü©
    exact ‚ü®W, a ‚â´ f, b, h, by simp‚ü©
  ¬∑ rintro ‚ü®W, a, b, h, w‚ü©
    let T := Over.mk (b ‚â´ W.hom)
    let c : T ‚ü∂ Y‚ÇÅ := Over.homMk g (by dsimp; rw [‚Üê Over.w a, ‚Üê reassoc_of% w, Over.w f])
    let d : T ‚ü∂ W := Over.homMk b
    refine' ‚ü®T, c, ùüô Z, _, by simp‚ü©
    rw [show c ‚â´ f = d ‚â´ a by ext; exact w]
    exact S.downward_closed h _

@[simp]
lemma overEquiv_symm_iff {X : C} {Y : Over X} (S : Sieve Y.left) {Z : Over X} (f : Z ‚ü∂ Y) :
    (overEquiv Y).symm S f ‚Üî S f.left := by
  rfl

lemma overEquiv_iff {X : C} {Y : Over X} (S : Sieve Y) {Z : C} (f : Z ‚ü∂ Y.left) :
    overEquiv Y S f ‚Üî S (Over.homMk f : Over.mk (f ‚â´ Y.hom) ‚ü∂ Y) := by
  obtain ‚ü®S, rfl‚ü© := (overEquiv Y).symm.surjective S
  simp

end Sieve

variable (J : GrothendieckTopology C)

namespace GrothendieckTopology

/-- The Grothendieck topology on the category `Over X` for any `X : C` that is
induced by a Grothendieck topology on `C`. -/
def over (X : C) : GrothendieckTopology (Over X) where
  sieves Y S := Sieve.overEquiv Y S ‚àà J Y.left
  top_mem' Y := by
    change _ ‚àà J Y.left
    simp
  pullback_stable' Y‚ÇÅ Y‚ÇÇ S‚ÇÅ f h‚ÇÅ := by
    change _ ‚àà J _ at h‚ÇÅ ‚ä¢
    rw [Sieve.overEquiv_pullback]
    exact J.pullback_stable _ h‚ÇÅ
  transitive' Y S (hS : _ ‚àà J _) R hR := J.transitive hS _ (fun Z f hf => by
    have hf' : _ ‚àà J _ := hR ((Sieve.overEquiv_iff _ _).1 hf)
    rw [Sieve.overEquiv_pullback] at hf'
    exact hf')

lemma mem_over_iff {X : C} {Y : Over X} (S : Sieve Y) :
    S ‚àà (J.over X) Y ‚Üî Sieve.overEquiv _ S ‚àà J Y.left := by
  rfl

lemma overEquiv_symm_mem_over {X : C} (Y : Over X) (S : Sieve Y.left) (hS : S ‚àà J Y.left) :
    (Sieve.overEquiv Y).symm S ‚àà (J.over X) Y := by
  simpa only [mem_over_iff, Equiv.apply_symm_apply] using hS

lemma over_forget_coverPreserving (X : C) :
    CoverPreserving (J.over X) J (Over.forget X) where
  cover_preserve hS := hS

lemma over_forget_coverLifting (X : C) :
    CoverLifting (J.over X) J (Over.forget X) where
  cover_lift hS := J.overEquiv_symm_mem_over _ _ hS

lemma over_forget_compatiblePreserving (X : C) :
    CompatiblePreserving J (Over.forget X) where
  Compatible {F Z T x hx Y‚ÇÅ Y‚ÇÇ W f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ hg‚ÇÅ hg‚ÇÇ h} := by
    let W' : Over X := Over.mk (f‚ÇÅ ‚â´ Y‚ÇÅ.hom)
    let g‚ÇÅ' : W' ‚ü∂ Y‚ÇÅ := Over.homMk f‚ÇÅ
    let g‚ÇÇ' : W' ‚ü∂ Y‚ÇÇ := Over.homMk f‚ÇÇ (by simpa using h.symm =‚â´ Z.hom)
    exact hx g‚ÇÅ' g‚ÇÇ' hg‚ÇÅ hg‚ÇÇ (by ext; exact h)

/-- The pullback functor `Sheaf J A ‚•§ Sheaf (J.over X) A` -/
abbrev overPullback (A : Type u') [Category.{v'} A] (X : C) :
    Sheaf J A ‚•§ Sheaf (J.over X) A :=
  Sites.pullback A (J.over_forget_compatiblePreserving X) (J.over_forget_coverPreserving X)

end GrothendieckTopology

end CategoryTheory
