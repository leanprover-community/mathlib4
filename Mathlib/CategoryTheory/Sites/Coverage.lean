/-
Copyright (c) 2023 Adam Topaz. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Adam Topaz
-/
module

public import Mathlib.CategoryTheory.Sites.PrecoverageToGrothendieck

/-!

# Coverages

A coverage `K` on a category `C` is a set of presieves associated to every object `X : C`,
called "covering presieves".
This collection must satisfy a certain "pullback compatibility" condition, saying that
whenever `S` is a covering presieve on `X` and `f : Y âŸ¶ X` is a morphism, then there exists
some covering sieve `T` on `Y` such that `T` factors through `S` along `f`.

The main difference between a coverage and a Grothendieck pretopology is that we *do not*
require `C` to have pullbacks.
This is useful, for example, when we want to consider the Grothendieck topology on the category
of extremally disconnected sets in the context of condensed mathematics.

A more concrete example: If `â„¬` is a basis for a topology on a type `X` (in the sense of
`TopologicalSpace.IsTopologicalBasis`) then it naturally induces a coverage on `Opens X`
whose associated Grothendieck topology is the one induced by the topology
on `X` generated by `â„¬`. (Project: Formalize this!)

## Main Definitions and Results:

All definitions are in the `CategoryTheory` namespace.

- `Coverage C`: The type of coverages on `C`.
- `GrothendieckTopology.toCoverage C`: A function which associates a coverage to any Grothendieck
  topology.
- `Coverage.toGrothendieck C`: A function which associates a Grothendieck topology to any coverage.
- `Coverage.gi`: The two functions above form a Galois insertion.
- `Presieve.isSheaf_coverage`: Given `K : Coverage C` with associated
  Grothendieck topology `J`, a `Type*`-valued presheaf on `C` is a sheaf for `K` if and only if
  it is a sheaf for `J`.

## References
We don't follow any particular reference, but the arguments can probably be distilled from
the following sources:
- [Elephant]: *Sketches of an Elephant*, P. T. Johnstone: C2.1.
- [nLab, *Coverage*](https://ncatlab.org/nlab/show/coverage)
-/

@[expose] public section

namespace CategoryTheory

universe w w'

variable {C D : Type _} [Category C] [Category D]

open Limits

namespace Presieve

/--
Given a morphism `f : Y âŸ¶ X`, a presieve `S` on `Y` and presieve `T` on `X`,
we say that *`S` factors through `T` along `f`*, written `S.FactorsThruAlong T f`,
provided that for any morphism `g : Z âŸ¶ Y` in `S`, there exists some
morphism `e : W âŸ¶ X` in `T` and some morphism `i : Z âŸ¶ W` such that the obvious
square commutes: `i â‰« e = g â‰« f`.

This is used in the definition of a coverage.
-/
def FactorsThruAlong {X Y : C} (S : Presieve Y) (T : Presieve X) (f : Y âŸ¶ X) : Prop :=
  âˆ€ â¦ƒZ : Câ¦„ â¦ƒg : Z âŸ¶ Yâ¦„, S g â†’
  âˆƒ (W : C) (i : Z âŸ¶ W) (e : W âŸ¶ X), T e âˆ§ i â‰« e = g â‰« f

lemma FactorsThruAlong.pullbackArrows {X Y : C} (f : X âŸ¶ Y)
    (R : Presieve Y) [R.HasPullbacks f] :
    (Presieve.pullbackArrows f R).FactorsThruAlong R f := by
  intro Z g âŸ¨W, b, hbâŸ©
  have := R.hasPullback f hb
  refine âŸ¨_, pullback.fst _ _, b, hb, pullback.conditionâŸ©

/--
Given `S T : Presieve X`, we say that `S` factors through `T` if any morphism in `S`
factors through some morphism in `T`.

The lemma `Presieve.isSheafFor_of_factorsThru` gives a *sufficient* condition for a
presheaf to be a sheaf for a presieve `T`, in terms of `S.FactorsThru T`, provided
that the presheaf is a sheaf for `S`.
-/
def FactorsThru {X : C} (S T : Presieve X) : Prop :=
  âˆ€ â¦ƒZ : Câ¦„ â¦ƒg : Z âŸ¶ Xâ¦„, S g â†’
  âˆƒ (W : C) (i : Z âŸ¶ W) (e : W âŸ¶ X), T e âˆ§ i â‰« e = g

@[simp]
lemma factorsThruAlong_id {X : C} (S T : Presieve X) :
    S.FactorsThruAlong T (ğŸ™ X) â†” S.FactorsThru T := by
  simp [FactorsThruAlong, FactorsThru]

lemma factorsThru_of_le {X : C} (S T : Presieve X) (h : S â‰¤ T) :
    S.FactorsThru T :=
  fun Y g hg => âŸ¨Y, ğŸ™ _, g, h _ hg, by simpâŸ©

lemma le_of_factorsThru_sieve {X : C} (S : Presieve X) (T : Sieve X) (h : S.FactorsThru T) :
    S â‰¤ T := by
  rintro Y f hf
  obtain âŸ¨W, i, e, h1, rflâŸ© := h hf
  exact T.downward_closed h1 _

lemma factorsThru_top {X : C} (S : Presieve X) : S.FactorsThru âŠ¤ :=
  factorsThru_of_le _ _ le_top

lemma isSheafFor_of_factorsThru
    {X : C} {S T : Presieve X}
    (P : Cáµ’áµ– â¥¤ Type*)
    (H : S.FactorsThru T) (hS : S.IsSheafFor P)
    (h : âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, T f â†’ âˆƒ (R : Presieve Y),
      R.IsSeparatedFor P âˆ§ R.FactorsThruAlong S f) :
    T.IsSheafFor P := by
  simp only [â† Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor] at *
  choose W i e h1 h2 using H
  refine âŸ¨?_, fun x hx => ?_âŸ©
  Â· intro x yâ‚ yâ‚‚ hâ‚ hâ‚‚
    refine hS.1.ext (fun Y g hg => ?_)
    simp only [â† h2 hg, op_comp, P.map_comp, types_comp_apply, hâ‚ _ (h1 _ ), hâ‚‚ _ (h1 _)]
  let y : S.FamilyOfElements P := fun Y g hg => P.map (i _).op (x (e hg) (h1 _))
  have hy : y.Compatible := by
    intro Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ h
    rw [â† types_comp_apply (P.map (i hâ‚).op) (P.map gâ‚.op),
      â† types_comp_apply (P.map (i hâ‚‚).op) (P.map gâ‚‚.op),
      â† P.map_comp, â† op_comp, â† P.map_comp, â† op_comp]
    apply hx
    simp only [h2, h, Category.assoc]
  let âŸ¨_, h2'âŸ© := hS
  obtain âŸ¨z, hzâŸ© := h2' y hy
  refine âŸ¨z, fun Y g hg => ?_âŸ©
  obtain âŸ¨R, hR1, hR2âŸ© := h hg
  choose WW ii ee hh1 hh2 using hR2
  refine hR1.ext (fun Q t ht => ?_)
  rw [â† types_comp_apply (P.map g.op) (P.map t.op), â† P.map_comp, â† op_comp, â† hh2 ht,
    op_comp, P.map_comp, types_comp_apply, hz _ (hh1 _),
    â† types_comp_apply _ (P.map (ii ht).op), â† P.map_comp, â† op_comp]
  apply hx
  simp only [Category.assoc, h2, hh2]


end Presieve

variable (C) in
/--
The type `Coverage C` of coverages on `C`.
A coverage is a collection of *covering* presieves on every object `X : C`,
which satisfies a *pullback compatibility* condition.
Explicitly, this condition says that whenever `S` is a covering presieve for `X` and
`f : Y âŸ¶ X` is a morphism, then there exists some covering presieve `T` for `Y`
such that `T` factors through `S` along `f`.
-/
@[ext]
structure Coverage extends Precoverage C where
  /-- Given any covering sieve `S` on `X` and a morphism `f : Y âŸ¶ X`, there exists
  some covering sieve `T` on `Y` such that `T` factors through `S` along `f`. -/
  pullback : âˆ€ â¦ƒX Y : Câ¦„ (f : Y âŸ¶ X) (S : Presieve X) (_ : S âˆˆ coverings X),
    âˆƒ (T : Presieve Y), T âˆˆ coverings Y âˆ§ T.FactorsThruAlong S f

namespace Coverage

@[deprecated (since := "2025-08-28")]
alias covering := Precoverage.coverings

instance : CoeFun (Coverage C) (fun _ => (X : C) â†’ Set (Presieve X)) where
  coe J := J.coverings

end Coverage

/--
Associate a coverage to any Grothendieck topology.
If `J` is a Grothendieck topology, and `K` is the associated coverage, then a presieve
`S` is a covering presieve for `K` if and only if the sieve that it generates is a
covering sieve for `J`.
-/
def GrothendieckTopology.toCoverage (J : GrothendieckTopology C) : Coverage C where
  coverings X := { S | Sieve.generate S âˆˆ J X }
  pullback := by
    intro X Y f S (hS : Sieve.generate S âˆˆ J X)
    refine âŸ¨(Sieve.generate S).pullback f, ?_, fun Z g h => hâŸ©
    dsimp
    rw [Sieve.generate_sieve]
    exact J.pullback_stable _ hS

@[deprecated (since := "2025-09-19")]
alias Coverage.ofGrothendieck := GrothendieckTopology.toCoverage

lemma GrothendieckTopology.mem_toCoverage_iff {X : C} {S : Presieve X}
    (J : GrothendieckTopology C) :
    S âˆˆ J.toCoverage X â†” Sieve.generate S âˆˆ J X := Iff.rfl

@[deprecated (since := "2025-09-19")]
alias ofGrothendieck_iff := GrothendieckTopology.mem_toCoverage_iff

namespace Coverage

/--
An auxiliary definition used to define the Grothendieck topology associated to a
coverage. See `Coverage.toGrothendieck`.
-/
inductive Saturate (K : Coverage C) : (X : C) â†’ Sieve X â†’ Prop where
  | of (X : C) (S : Presieve X) (hS : S âˆˆ K X) : Saturate K X (Sieve.generate S)
  | top (X : C) : Saturate K X âŠ¤
  | transitive (X : C) (R S : Sieve X) :
    Saturate K X R â†’
    (âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, R f â†’ Saturate K Y (S.pullback f)) â†’
    Saturate K X S

lemma eq_top_pullback {X Y : C} {S T : Sieve X} (h : S â‰¤ T) (f : Y âŸ¶ X) (hf : S f) :
    T.pullback f = âŠ¤ := by
  ext Z g
  simp only [Sieve.pullback_apply, Sieve.top_apply, iff_true]
  apply h
  apply S.downward_closed
  exact hf

lemma saturate_of_superset (K : Coverage C) {X : C} {S T : Sieve X} (h : S â‰¤ T)
    (hS : Saturate K X S) : Saturate K X T := by
  apply Saturate.transitive _ _ _ hS
  intro Y g hg
  rw [eq_top_pullback (h := h)]
  Â· apply Saturate.top
  Â· assumption

/--
The Grothendieck topology associated to a coverage `K`.
It is defined *inductively* as follows:
1. If `S` is a covering presieve for `K`, then the sieve generated by `S` is a covering
  sieve for the associated Grothendieck topology.
2. The top sieves are in the associated Grothendieck topology.
3. Add all sieves required by the *local character* axiom of a Grothendieck topology.

The pullback compatibility condition for a coverage ensures that the
associated Grothendieck topology is pullback stable, and so an additional constructor
in the inductive construction is not needed.
-/
def toGrothendieck (K : Coverage C) : GrothendieckTopology C where
  sieves := Saturate K
  top_mem' := .top
  pullback_stable' := by
    intro X Y S f hS
    induction hS generalizing Y with
    | of X S hS =>
      obtain âŸ¨R,hR1,hR2âŸ© := K.pullback f S hS
      suffices Sieve.generate R â‰¤ (Sieve.generate S).pullback f from
        saturate_of_superset _ this (Saturate.of _ _ hR1)
      rintro Z g âŸ¨W, i, e, h1, h2âŸ©
      obtain âŸ¨WW, ii, ee, hh1, hh2âŸ© := hR2 h1
      refine âŸ¨WW, i â‰« ii, ee, hh1, ?_âŸ©
      simp only [hh2, reassoc_of% h2, Category.assoc]
    | top X => apply Saturate.top
    | transitive X R S _ hS H1 _ =>
      apply Saturate.transitive
      Â· apply H1 f
      intro Z g hg
      rw [â† Sieve.pullback_comp]
      exact hS hg
  transitive' _ _ hS _ hR := .transitive _ _ _ hS hR

lemma mem_toGrothendieck {K : Coverage C} {X : C} {S : Sieve X} :
    S âˆˆ K.toGrothendieck X â†” Saturate K X S := .rfl

instance : PartialOrder (Coverage C) where
  le A B := A.coverings â‰¤ B.coverings
  le_refl _ _ := le_refl _
  le_trans _ _ _ h1 h2 X := le_trans (h1 X) (h2 X)
  le_antisymm _ _ h1 h2 := Coverage.ext <| funext <|
    fun X => le_antisymm (h1 X) (h2 X)

variable (C) in
/--
The two constructions `Coverage.toGrothendieck` and `Coverage.ofGrothendieck` form
a Galois insertion.
-/
def gi : GaloisInsertion (toGrothendieck (C := C)) (GrothendieckTopology.toCoverage (C := C)) where
  choice K _ := toGrothendieck K
  choice_eq := fun _ _ => rfl
  le_l_u J X S hS := by
    rw [â† Sieve.generate_sieve S]
    apply Saturate.of
    dsimp [GrothendieckTopology.toCoverage]
    rwa [Sieve.generate_sieve S]
  gc K J := by
    constructor
    Â· intro H X S hS
      exact H _ <| Saturate.of _ _ hS
    Â· intro H X S hS
      induction hS with
      | of X S hS => exact H _ hS
      | top => apply J.top_mem
      | transitive X R S _ _ H1 H2 => exact J.transitive H1 _ H2

/--
An alternative characterization of the Grothendieck topology associated to a coverage `K`:
it is the infimum of all Grothendieck topologies whose associated coverage contains `K`.
-/
theorem toGrothendieck_eq_sInf (K : Coverage C) : toGrothendieck K =
    sInf {J | K â‰¤ J.toCoverage } := by
  apply le_antisymm
  Â· apply le_sInf
    intro J hJ X S hS
    induction hS with
    | of X S hS => apply hJ; assumption
    | top => apply J.top_mem
    | transitive X R S _ _ H1 H2 => exact J.transitive H1 _ H2
  Â· apply sInf_le
    intro X S hS
    apply Saturate.of _ _ hS

instance : SemilatticeSup (Coverage C) where
  sup x y :=
  { coverings := fun B â†¦ x B âˆª y B
    pullback := by
      rintro X Y f S (hx | hy)
      Â· obtain âŸ¨T, hTâŸ© := x.pullback f S hx
        exact âŸ¨T, Or.inl hT.1, hT.2âŸ©
      Â· obtain âŸ¨T, hTâŸ© := y.pullback f S hy
        exact âŸ¨T, Or.inr hT.1, hT.2âŸ© }
  toPartialOrder := inferInstance
  le_sup_left _ _ _ := Set.subset_union_left
  le_sup_right _ _ _ := Set.subset_union_right
  sup_le _ _ _ hx hy X := Set.union_subset_iff.mpr âŸ¨hx X, hy XâŸ©

@[simp]
lemma sup_covering (x y : Coverage C) (B : C) :
    (x âŠ” y) B = x B âˆª y B :=
  rfl

/--
Any sieve that contains a covering presieve for a coverage is a covering sieve for the associated
Grothendieck topology.
-/
theorem mem_toGrothendieck_sieves_of_superset (K : Coverage C) {X : C} {S : Sieve X}
    {R : Presieve X} (h : R â‰¤ S) (hR : R âˆˆ K X) : S âˆˆ K.toGrothendieck X :=
  K.saturate_of_superset ((Sieve.generate_le_iff _ _).mpr h) (Coverage.Saturate.of X _ hR)

end Coverage

/-- Any pretopology is a coverage. -/
def Pretopology.toCoverage [HasPullbacks C] (J : Pretopology C) : Coverage C where
  coverings := J
  pullback _ _ f R hR := âŸ¨R.pullbackArrows f, J.pullbacks _ _ hR, .pullbackArrows f RâŸ©

@[simp]
lemma Pretopology.mem_toCoverage [HasPullbacks C] (J : Pretopology C) {X : C} (S : Presieve X) :
    S âˆˆ J.toCoverage X â†” S âˆˆ J X := .rfl

lemma Pretopology.toGrothendieck_toCoverage [HasPullbacks C] (J : Pretopology C) :
    J.toCoverage.toGrothendieck = J.toGrothendieck := by
  ext T S
  rw [mem_toGrothendieck, Coverage.mem_toGrothendieck]
  refine âŸ¨fun h â†¦ ?_, fun âŸ¨R, hR, hleâŸ© â†¦ ?_âŸ©
  Â· induction h with
    | of X S hS => use S, hS, Sieve.le_generate S
    | top X => use Presieve.singleton (ğŸ™ X), J.has_isos (ğŸ™ X), le_top
    | transitive X R S hR hRS hle hfS =>
        obtain âŸ¨R', hR', hleâŸ© := hle
        choose S' hS' hS'le using hfS
        refine âŸ¨Presieve.bind R' (fun Y f hf â†¦ S' (hle _ hf)), ?_, fun Z u hu â†¦ ?_âŸ©
        Â· exact J.transitive R' (fun Y f hf â†¦ S' (hle Y hf)) hR' fun Y f H â†¦ hS' (hle Y H)
        Â· obtain âŸ¨W, g, w, hw, hg, rflâŸ© := hu
          exact hS'le _ _ hg
  Â· refine Coverage.saturate_of_superset _ ?_ (.of _ _ hR)
    rwa [Sieve.generate_le_iff]

/-- A precoverage with pullbacks defines a coverage. -/
@[simps toPrecoverage]
def Precoverage.toCoverage (J : Precoverage C) [J.HasPullbacks] [J.IsStableUnderBaseChange] :
    Coverage C where
  __ := J
  pullback X Y f S hS := by
    have : S.HasPullbacks f := J.hasPullbacks_of_mem _ hS
    exact âŸ¨S.pullbackArrows f, J.pullbackArrows_mem _ hS,
      Presieve.FactorsThruAlong.pullbackArrows f SâŸ©

lemma Precoverage.toGrothendieck_toCoverage {J : Precoverage C} [J.HasPullbacks]
    [J.IsStableUnderBaseChange] :
    J.toCoverage.toGrothendieck = J.toGrothendieck := by
  refine le_antisymm ?_ ?_
  Â· intro _ _ hS
    induction hS with
    | of _ _ hS => exact generate_mem_toGrothendieck hS
    | top => exact J.toGrothendieck.top_mem _
    | transitive _ _ _ _ _ ih1 ih2 => exact J.toGrothendieck.transitive ih1 _ ih2
  Â· intro _ _ hS
    induction hS with
    | of _ _ hS => exact .of _ _ hS
    | top => exact J.toCoverage.toGrothendieck.top_mem _
    | pullback _ _ _ _ ih => exact J.toCoverage.toGrothendieck.pullback_stable _ ih
    | transitive _ _ _ _ _ ih1 ih2 => exact J.toCoverage.toGrothendieck.transitive ih1 _ ih2

namespace GrothendieckTopology

/-- The induced coverage by a Grothendieck topology as a precoverage. -/
def toPrecoverage (J : GrothendieckTopology C) : Precoverage C :=
  J.toCoverage.toPrecoverage

lemma mem_toPrecoverage_iff (J : GrothendieckTopology C) {S : C} (R : Presieve S) :
    R âˆˆ toPrecoverage J S â†” Sieve.generate R âˆˆ J S := .rfl

instance (J : GrothendieckTopology C) : (toPrecoverage J).HasIsos where
  mem_coverings_of_isIso f hf := by simp [mem_toPrecoverage_iff]

instance (J : GrothendieckTopology C) : (toPrecoverage J).IsStableUnderComposition where
  comp_mem_coverings {Î¹} S X f hf Ïƒ Y g hg := by
    rw [mem_toPrecoverage_iff, â† Presieve.bindOfArrows_ofArrows]
    exact J.bindOfArrows hf hg

instance (J : GrothendieckTopology C) : (toPrecoverage J).IsStableUnderBaseChange where
  mem_coverings_of_isPullback {Î¹} S X f hf Y g P pâ‚ pâ‚‚ h := by
    rw [mem_toPrecoverage_iff, â† Sieve.ofArrows, Sieve.ofArrows_eq_pullback_of_isPullback _ h]
    exact J.pullback_stable _ hf

end GrothendieckTopology

/-- `toGrothendieck` and `toPrecoverage` form a Galois connection on the domains where they are
defined. -/
lemma Precoverage.toGrothendieck_le_iff_le_toPrecoverage {K : Precoverage C}
    {J : GrothendieckTopology C} [K.HasPullbacks] [K.IsStableUnderBaseChange] :
    K.toGrothendieck â‰¤ J â†” K â‰¤ J.toPrecoverage := by
  rw [â† toGrothendieck_toCoverage]
  exact (Coverage.gi C).gc _ _

lemma Coverage.toGrothendieck_toPrecoverage (J : Coverage C) :
    J.toPrecoverage.toGrothendieck = J.toGrothendieck := by
  refine le_antisymm ?_ ?_
  Â· rw [Precoverage.toGrothendieck_eq_sInf]
    exact sInf_le (fun _ _ hS => .of _ _ hS)
  Â· intro _ _ hS
    induction hS with
    | of _ _ hS => exact .of _ _ hS
    | top => exact J.toPrecoverage.toGrothendieck.top_mem _
    | transitive _ _ _ _ _ ih ih' => exact J.toPrecoverage.toGrothendieck.transitive ih _ ih'

open Coverage

namespace Presieve

/--
The main theorem of this file: Given a coverage `K` on `C`,
a `Type*`-valued presheaf on `C` is a sheaf for `K` if and only if it is a sheaf for
the associated Grothendieck topology.
-/
theorem isSheaf_coverage (K : Coverage C) (P : Cáµ’áµ– â¥¤ Type*) :
    Presieve.IsSheaf K.toGrothendieck P â†”
    (âˆ€ {X : C} (R : Presieve X), R âˆˆ K X â†’ Presieve.IsSheafFor P R) := by
  rw [â† toGrothendieck_toPrecoverage, Precoverage.isSheaf_toGrothendieck_iff]
  constructor
  Â· intro H X S hS
    simpa [â† Presieve.isSheafFor_iff_generate] using H (f := ğŸ™ X) S hS
  Â· intro H X Y f S hS
    obtain âŸ¨T, hT1, hT2âŸ© := K.pullback f S hS
    apply Presieve.isSheafFor_of_factorsThru (S := T)
    Â· intro Z g hg
      obtain âŸ¨W, i, e, h1, h2âŸ© := hT2 hg
      exact âŸ¨Z, ğŸ™ _, g, âŸ¨W, i, e, h1, h2âŸ©, by simpâŸ©
    Â· apply H; assumption
    Â· intro Z g _
      obtain âŸ¨R, hR1, hR2âŸ© := K.pullback g _ hT1
      exact âŸ¨R, (H _ hR1).isSeparatedFor, hR2âŸ©

/--
A presheaf is a sheaf for the Grothendieck topology generated by a union of coverages iff it is a
sheaf for the Grothendieck topology generated by each coverage separately.
-/
theorem isSheaf_sup (K L : Coverage C) (P : Cáµ’áµ– â¥¤ Type*) :
    (Presieve.IsSheaf (K âŠ” L).toGrothendieck) P â†”
    (Presieve.IsSheaf K.toGrothendieck) P âˆ§ (Presieve.IsSheaf L.toGrothendieck) P := by
  refine âŸ¨fun h â†¦ âŸ¨Presieve.isSheaf_of_le _ ((gi C).gc.monotone_l le_sup_left) h,
      Presieve.isSheaf_of_le _ ((gi C).gc.monotone_l le_sup_right) hâŸ©, fun h â†¦ ?_âŸ©
  rw [isSheaf_coverage, isSheaf_coverage] at h
  rw [isSheaf_coverage]
  intro X R hR
  rcases hR with hR | hR
  Â· exact h.1 R hR
  Â· exact h.2 R hR

end Presieve

namespace Presheaf

theorem isSheaf_iff_isLimit_coverage (K : Coverage C) (P : Cáµ’áµ– â¥¤ D) :
    Presheaf.IsSheaf K.toGrothendieck P â†” âˆ€ â¦ƒX : Câ¦„ (R : Presieve X),
      R âˆˆ K X â†’
        Nonempty (IsLimit (P.mapCone (Sieve.generate R).arrows.cocone.op)) := by
  simp only [Presheaf.IsSheaf, Presieve.isSheaf_coverage, isLimit_iff_isSheafFor,
    â† Presieve.isSheafFor_iff_generate]
  aesop

theorem isSheaf_sup (K L : Coverage C) (P : Cáµ’áµ– â¥¤ D) :
    (IsSheaf (K âŠ” L).toGrothendieck) P â†”
    (IsSheaf K.toGrothendieck) P âˆ§ (IsSheaf L.toGrothendieck) P :=
  âŸ¨fun h â†¦ âŸ¨fun E â†¦ ((Presieve.isSheaf_sup K L _).mp (h E)).1, fun E â†¦
    ((Presieve.isSheaf_sup K L _).mp (h E)).2âŸ©,
      fun âŸ¨hâ‚, hâ‚‚âŸ© E â†¦ (Presieve.isSheaf_sup K L _).mpr âŸ¨hâ‚ E, hâ‚‚ EâŸ©âŸ©

end Presheaf

end CategoryTheory
