/-
Copyright (c) 2023 Adam Topaz. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Adam Topaz
-/
import Mathlib.CategoryTheory.Sites.Sheaf
import Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq

/-!

# Coverages

A coverage `K` on a category `C` is a set of presieves associated to every object `X : C`,
called "covering presieves".
This collection must satisfy a certain "pullback compatibility" condition, saying that
whenever `S` is a covering presieve on `X` and `f : Y ‚ü∂ X` is a morphism, then there exists
some covering sieve `T` on `Y` such that `T` factors through `S` along `f`.

The main difference between a coverage and a Grothendieck pretopology is that we *do not*
require `C` to have pullbacks.
This is useful, for example, when we want to consider the Grothendieck topology on the category
of extremally disconnected sets in the context of condensed mathematics.

A more concrete example: If `‚Ñ¨` is a basis for a topology on a type `X` (in the sense of
`TopologicalSpace.IsTopologicalBasis`) then it naturally induces a coverage on `Opens X`
whose associated Grothendieck topology is the one induced by the topology
on `X` generated by `‚Ñ¨`. (Project: Formalize this!)

## Main Definitions and Results:

All definitions are in the `CategoryTheory` namespace.

- `Coverage C`: The type of coverages on `C`.
- `Coverage.ofGrothendieck C`: A function which associates a coverage to any Grothendieck topology.
- `Coverage.toGrothendieck C`: A function which associates a Grothendieck topology to any coverage.
- `Coverage.gi`: The two functions above form a Galois insertion.
- `Presieve.isSheaf_coverage`: Given `K : Coverage C` with associated
  Grothendieck topology `J`, a `Type*`-valued presheaf on `C` is a sheaf for `K` if and only if
  it is a sheaf for `J`.

# References
We don't follow any particular reference, but the arguments can probably be distilled from
the following sources:
- [Elephant]: *Sketches of an Elephant*, P. T. Johnstone: C2.1.
- [nLab, *Coverage*](https://ncatlab.org/nlab/show/coverage)
-/

namespace CategoryTheory

universe w w'

variable {C D : Type _} [Category C] [Category D]

open Limits

namespace Presieve

/--
Given a morphism `f : Y ‚ü∂ X`, a presieve `S` on `Y` and presieve `T` on `X`,
we say that *`S` factors through `T` along `f`*, written `S.FactorsThruAlong T f`,
provided that for any morphism `g : Z ‚ü∂ Y` in `S`, there exists some
morphism `e : W ‚ü∂ X` in `T` and some morphism `i : Z ‚ü∂ W` such that the obvious
square commutes: `i ‚â´ e = g ‚â´ f`.

This is used in the definition of a coverage.
-/
def FactorsThruAlong {X Y : C} (S : Presieve Y) (T : Presieve X) (f : Y ‚ü∂ X) : Prop :=
  ‚àÄ ‚¶ÉZ : C‚¶Ñ ‚¶Ég : Z ‚ü∂ Y‚¶Ñ, S g ‚Üí
  ‚àÉ (W : C) (i : Z ‚ü∂ W) (e : W ‚ü∂ X), T e ‚àß i ‚â´ e = g ‚â´ f

lemma FactorsThruAlong.pullbackArrows [HasPullbacks C] {X Y : C} (f : X ‚ü∂ Y)
    (R : Presieve Y) :
    (Presieve.pullbackArrows f R).FactorsThruAlong R f := by
  intro Z g ‚ü®W, b, hb‚ü©
  refine ‚ü®_, pullback.fst _ _, b, hb, pullback.condition‚ü©

/--
Given `S T : Presieve X`, we say that `S` factors through `T` if any morphism in `S`
factors through some morphism in `T`.

The lemma `Presieve.isSheafFor_of_factorsThru` gives a *sufficient* condition for a
presheaf to be a sheaf for a presieve `T`, in terms of `S.FactorsThru T`, provided
that the presheaf is a sheaf for `S`.
-/
def FactorsThru {X : C} (S T : Presieve X) : Prop :=
  ‚àÄ ‚¶ÉZ : C‚¶Ñ ‚¶Ég : Z ‚ü∂ X‚¶Ñ, S g ‚Üí
  ‚àÉ (W : C) (i : Z ‚ü∂ W) (e : W ‚ü∂ X), T e ‚àß i ‚â´ e = g

@[simp]
lemma factorsThruAlong_id {X : C} (S T : Presieve X) :
    S.FactorsThruAlong T (ùüô X) ‚Üî S.FactorsThru T := by
  simp [FactorsThruAlong, FactorsThru]

lemma factorsThru_of_le {X : C} (S T : Presieve X) (h : S ‚â§ T) :
    S.FactorsThru T :=
  fun Y g hg => ‚ü®Y, ùüô _, g, h _ hg, by simp‚ü©

lemma le_of_factorsThru_sieve {X : C} (S : Presieve X) (T : Sieve X) (h : S.FactorsThru T) :
    S ‚â§ T := by
  rintro Y f hf
  obtain ‚ü®W, i, e, h1, rfl‚ü© := h hf
  exact T.downward_closed h1 _

lemma factorsThru_top {X : C} (S : Presieve X) : S.FactorsThru ‚ä§ :=
  factorsThru_of_le _ _ le_top

lemma isSheafFor_of_factorsThru
    {X : C} {S T : Presieve X}
    (P : C·µí·µñ ‚•§ Type*)
    (H : S.FactorsThru T) (hS : S.IsSheafFor P)
    (h : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, T f ‚Üí ‚àÉ (R : Presieve Y),
      R.IsSeparatedFor P ‚àß R.FactorsThruAlong S f) :
    T.IsSheafFor P := by
  simp only [‚Üê Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor] at *
  choose W i e h1 h2 using H
  refine ‚ü®?_, fun x hx => ?_‚ü©
  ¬∑ intro x y‚ÇÅ y‚ÇÇ h‚ÇÅ h‚ÇÇ
    refine hS.1.ext (fun Y g hg => ?_)
    simp only [‚Üê h2 hg, op_comp, P.map_comp, types_comp_apply, h‚ÇÅ _ (h1 _ ), h‚ÇÇ _ (h1 _)]
  let y : S.FamilyOfElements P := fun Y g hg => P.map (i _).op (x (e hg) (h1 _))
  have hy : y.Compatible := by
    intro Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ h
    rw [‚Üê types_comp_apply (P.map (i h‚ÇÅ).op) (P.map g‚ÇÅ.op),
      ‚Üê types_comp_apply (P.map (i h‚ÇÇ).op) (P.map g‚ÇÇ.op),
      ‚Üê P.map_comp, ‚Üê op_comp, ‚Üê P.map_comp, ‚Üê op_comp]
    apply hx
    simp only [h2, h, Category.assoc]
  let ‚ü®_, h2'‚ü© := hS
  obtain ‚ü®z, hz‚ü© := h2' y hy
  refine ‚ü®z, fun Y g hg => ?_‚ü©
  obtain ‚ü®R, hR1, hR2‚ü© := h hg
  choose WW ii ee hh1 hh2 using hR2
  refine hR1.ext (fun Q t ht => ?_)
  rw [‚Üê types_comp_apply (P.map g.op) (P.map t.op), ‚Üê P.map_comp, ‚Üê op_comp, ‚Üê hh2 ht,
    op_comp, P.map_comp, types_comp_apply, hz _ (hh1 _),
    ‚Üê types_comp_apply _ (P.map (ii ht).op), ‚Üê P.map_comp, ‚Üê op_comp]
  apply hx
  simp only [Category.assoc, h2, hh2]


end Presieve

variable (C) in
/--
The type `Coverage C` of coverages on `C`.
A coverage is a collection of *covering* presieves on every object `X : C`,
which satisfies a *pullback compatibility* condition.
Explicitly, this condition says that whenever `S` is a covering presieve for `X` and
`f : Y ‚ü∂ X` is a morphism, then there exists some covering presieve `T` for `Y`
such that `T` factors through `S` along `f`.
-/
@[ext]
structure Coverage where
  /-- The collection of covering presieves for an object `X`. -/
  covering : ‚àÄ (X : C), Set (Presieve X)
  /-- Given any covering sieve `S` on `X` and a morphism `f : Y ‚ü∂ X`, there exists
  some covering sieve `T` on `Y` such that `T` factors through `S` along `f`. -/
  pullback : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : Y ‚ü∂ X) (S : Presieve X) (_ : S ‚àà covering X),
    ‚àÉ (T : Presieve Y), T ‚àà covering Y ‚àß T.FactorsThruAlong S f

namespace Coverage

instance : CoeFun (Coverage C) (fun _ => (X : C) ‚Üí Set (Presieve X)) where
  coe := covering

variable (C) in
/--
Associate a coverage to any Grothendieck topology.
If `J` is a Grothendieck topology, and `K` is the associated coverage, then a presieve
`S` is a covering presieve for `K` if and only if the sieve that it generates is a
covering sieve for `J`.
-/
def ofGrothendieck (J : GrothendieckTopology C) : Coverage C where
  covering X := { S | Sieve.generate S ‚àà J X }
  pullback := by
    intro X Y f S (hS : Sieve.generate S ‚àà J X)
    refine ‚ü®(Sieve.generate S).pullback f, ?_, fun Z g h => h‚ü©
    dsimp
    rw [Sieve.generate_sieve]
    exact J.pullback_stable _ hS

lemma ofGrothendieck_iff {X : C} {S : Presieve X} (J : GrothendieckTopology C) :
    S ‚àà ofGrothendieck _ J X ‚Üî Sieve.generate S ‚àà J X := Iff.rfl

/--
An auxiliary definition used to define the Grothendieck topology associated to a
coverage. See `Coverage.toGrothendieck`.
-/
inductive Saturate (K : Coverage C) : (X : C) ‚Üí Sieve X ‚Üí Prop where
  | of (X : C) (S : Presieve X) (hS : S ‚àà K X) : Saturate K X (Sieve.generate S)
  | top (X : C) : Saturate K X ‚ä§
  | transitive (X : C) (R S : Sieve X) :
    Saturate K X R ‚Üí
    (‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, R f ‚Üí Saturate K Y (S.pullback f)) ‚Üí
    Saturate K X S

lemma eq_top_pullback {X Y : C} {S T : Sieve X} (h : S ‚â§ T) (f : Y ‚ü∂ X) (hf : S f) :
    T.pullback f = ‚ä§ := by
  ext Z g
  simp only [Sieve.pullback_apply, Sieve.top_apply, iff_true]
  apply h
  apply S.downward_closed
  exact hf

lemma saturate_of_superset (K : Coverage C) {X : C} {S T : Sieve X} (h : S ‚â§ T)
    (hS : Saturate K X S) : Saturate K X T := by
  apply Saturate.transitive _ _ _ hS
  intro Y g hg
  rw [eq_top_pullback (h := h)]
  ¬∑ apply Saturate.top
  ¬∑ assumption

variable (C) in
/--
The Grothendieck topology associated to a coverage `K`.
It is defined *inductively* as follows:
1. If `S` is a covering presieve for `K`, then the sieve generated by `S` is a covering
  sieve for the associated Grothendieck topology.
2. The top sieves are in the associated Grothendieck topology.
3. Add all sieves required by the *local character* axiom of a Grothendieck topology.

The pullback compatibility condition for a coverage ensures that the
associated Grothendieck topology is pullback stable, and so an additional constructor
in the inductive construction is not needed.
-/
def toGrothendieck (K : Coverage C) : GrothendieckTopology C where
  sieves := Saturate K
  top_mem' := .top
  pullback_stable' := by
    intro X Y S f hS
    induction hS generalizing Y with
    | of X S hS =>
      obtain ‚ü®R,hR1,hR2‚ü© := K.pullback f S hS
      suffices Sieve.generate R ‚â§ (Sieve.generate S).pullback f from
        saturate_of_superset _ this (Saturate.of _ _ hR1)
      rintro Z g ‚ü®W, i, e, h1, h2‚ü©
      obtain ‚ü®WW, ii, ee, hh1, hh2‚ü© := hR2 h1
      refine ‚ü®WW, i ‚â´ ii, ee, hh1, ?_‚ü©
      simp only [hh2, reassoc_of% h2, Category.assoc]
    | top X => apply Saturate.top
    | transitive X R S _ hS H1 _ =>
      apply Saturate.transitive
      ¬∑ apply H1 f
      intro Z g hg
      rw [‚Üê Sieve.pullback_comp]
      exact hS hg
  transitive' _ _ hS _ hR := .transitive _ _ _ hS hR

instance : PartialOrder (Coverage C) where
  le A B := A.covering ‚â§ B.covering
  le_refl _ _ := le_refl _
  le_trans _ _ _ h1 h2 X := le_trans (h1 X) (h2 X)
  le_antisymm _ _ h1 h2 := Coverage.ext <| funext <|
    fun X => le_antisymm (h1 X) (h2 X)

variable (C) in
/--
The two constructions `Coverage.toGrothendieck` and `Coverage.ofGrothendieck` form
a Galois insertion.
-/
def gi : GaloisInsertion (toGrothendieck C) (ofGrothendieck C) where
  choice K _ := toGrothendieck _ K
  choice_eq := fun _ _ => rfl
  le_l_u J X S hS := by
    rw [‚Üê Sieve.generate_sieve S]
    apply Saturate.of
    dsimp [ofGrothendieck]
    rwa [Sieve.generate_sieve S]
  gc K J := by
    constructor
    ¬∑ intro H X S hS
      exact H _ <| Saturate.of _ _ hS
    ¬∑ intro H X S hS
      induction hS with
      | of X S hS => exact H _ hS
      | top => apply J.top_mem
      | transitive X R S _ _ H1 H2 => exact J.transitive H1 _ H2

/--
An alternative characterization of the Grothendieck topology associated to a coverage `K`:
it is the infimum of all Grothendieck topologies whose associated coverage contains `K`.
-/
theorem toGrothendieck_eq_sInf (K : Coverage C) : toGrothendieck _ K =
    sInf {J | K ‚â§ ofGrothendieck _ J } := by
  apply le_antisymm
  ¬∑ apply le_sInf; intro J hJ
    intro X S hS
    induction hS with
    | of X S hS => apply hJ; assumption
    | top => apply J.top_mem
    | transitive X R S _ _ H1 H2 => exact J.transitive H1 _ H2
  ¬∑ apply sInf_le
    intro X S hS
    apply Saturate.of _ _ hS

instance : SemilatticeSup (Coverage C) where
  sup x y :=
  { covering := fun B ‚Ü¶ x.covering B ‚à™ y.covering B
    pullback := by
      rintro X Y f S (hx | hy)
      ¬∑ obtain ‚ü®T, hT‚ü© := x.pullback f S hx
        exact ‚ü®T, Or.inl hT.1, hT.2‚ü©
      ¬∑ obtain ‚ü®T, hT‚ü© := y.pullback f S hy
        exact ‚ü®T, Or.inr hT.1, hT.2‚ü© }
  toPartialOrder := inferInstance
  le_sup_left _ _ _ := Set.subset_union_left
  le_sup_right _ _ _ := Set.subset_union_right
  sup_le _ _ _ hx hy X := Set.union_subset_iff.mpr ‚ü®hx X, hy X‚ü©

@[simp]
lemma sup_covering (x y : Coverage C) (B : C) :
    (x ‚äî y).covering B = x.covering B ‚à™ y.covering B :=
  rfl

/--
Any sieve that contains a covering presieve for a coverage is a covering sieve for the associated
Grothendieck topology.
-/
theorem mem_toGrothendieck_sieves_of_superset (K : Coverage C) {X : C} {S : Sieve X}
    {R : Presieve X} (h : R ‚â§ S) (hR : R ‚àà K.covering X) : S ‚àà (K.toGrothendieck C) X :=
  K.saturate_of_superset ((Sieve.generate_le_iff _ _).mpr h) (Coverage.Saturate.of X _ hR)

/-- A coverage is stable under base change if pullbacks of covering presieves
are covering presieves.
Note: This is stronger than the analogous requirement for a `Pretopology`, because
`IsPullback` does not imply equality with the (arbitrarily) chosen pullbacks in `C`. -/
class IsStableUnderBaseChange (J : Coverage C) : Prop where
  mem_covering_of_isPullback {Œπ : Type w} {S : C} {X : Œπ ‚Üí C} (f : ‚àÄ i, X i ‚ü∂ S)
    (hR : Presieve.ofArrows X f ‚àà J S) {Y : C} (g : Y ‚ü∂ S)
    {P : Œπ ‚Üí C} (p‚ÇÅ : ‚àÄ i, P i ‚ü∂ Y) (p‚ÇÇ : ‚àÄ i, P i ‚ü∂ X i)
    (h : ‚àÄ i, IsPullback (p‚ÇÅ i) (p‚ÇÇ i) g (f i)) :
    .ofArrows P p‚ÇÅ ‚àà J Y

/-- A coverage is stable under composition if the indexed composition
of coverings is again a covering.
Note: This is stronger than the analogous requirement for a `Pretopology`, because
this is in general not equal to a `Presieve.bind`. -/
class IsStableUnderComposition (J : Coverage C) : Prop where
  mem_covering_comp {Œπ : Type w}
    {S : C} {X : Œπ ‚Üí C} (f : ‚àÄ i, X i ‚ü∂ S) (hf : Presieve.ofArrows X f ‚àà J S)
    {œÉ : Œπ ‚Üí Type w'} {Y : ‚àÄ (i : Œπ), œÉ i ‚Üí C}
    (g : ‚àÄ i j, Y i j ‚ü∂ X i) (hg : ‚àÄ i, Presieve.ofArrows (Y i) (g i) ‚àà J (X i)) :
    .ofArrows (fun p : Œ£ i, œÉ i ‚Ü¶ Y _ p.2) (fun _ ‚Ü¶ g _ _ ‚â´ f _) ‚àà J S

alias mem_covering_of_isPullback := IsStableUnderBaseChange.mem_covering_of_isPullback

alias mem_covering_comp := IsStableUnderComposition.mem_covering_comp

end Coverage

/-- Any pretopology is a coverage. -/
def Pretopology.toCoverage [HasPullbacks C] (J : Pretopology C) : Coverage C where
  covering := J
  pullback _ _ f R hR := ‚ü®R.pullbackArrows f, J.pullbacks _ _ hR, .pullbackArrows f R‚ü©

open Coverage

namespace Presieve

/--
The main theorem of this file: Given a coverage `K` on `C`,
a `Type*`-valued presheaf on `C` is a sheaf for `K` if and only if it is a sheaf for
the associated Grothendieck topology.
-/
theorem isSheaf_coverage (K : Coverage C) (P : C·µí·µñ ‚•§ Type*) :
    Presieve.IsSheaf (toGrothendieck _ K) P ‚Üî
    (‚àÄ {X : C} (R : Presieve X), R ‚àà K X ‚Üí Presieve.IsSheafFor P R) := by
  constructor
  ¬∑ intro H X R hR
    rw [Presieve.isSheafFor_iff_generate]
    apply H _ <| Saturate.of _ _ hR
  ¬∑ intro H X S hS
    -- This is the key point of the proof:
    -- We must generalize the induction in the correct way.
    suffices ‚àÄ ‚¶ÉY : C‚¶Ñ (f : Y ‚ü∂ X), Presieve.IsSheafFor P (S.pullback f).arrows by
      simpa using this (f := ùüô _)
    induction hS with
    | of X S hS =>
      intro Y f
      obtain ‚ü®T, hT1, hT2‚ü© := K.pullback f S hS
      apply Presieve.isSheafFor_of_factorsThru (S := T)
      ¬∑ intro Z g hg
        obtain ‚ü®W, i, e, h1, h2‚ü© := hT2 hg
        exact ‚ü®Z, ùüô _, g, ‚ü®W, i, e, h1, h2‚ü©, by simp‚ü©
      ¬∑ apply H; assumption
      ¬∑ intro Z g _
        obtain ‚ü®R, hR1, hR2‚ü© := K.pullback g _ hT1
        exact ‚ü®R, (H _ hR1).isSeparatedFor, hR2‚ü©
    | top => intros; simpa using Presieve.isSheafFor_top_sieve _
    | transitive X R S _ _ H1 H2 =>
      intro Y f
      simp only [‚Üê Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor] at *
      choose H1 H1' using H1
      choose H2 H2' using H2
      refine ‚ü®?_, fun x hx => ?_‚ü©
      ¬∑ intro x t‚ÇÅ t‚ÇÇ h‚ÇÅ h‚ÇÇ
        refine (H1 f).ext (fun Z g hg => ?_)
        refine (H2 hg (ùüô _)).ext (fun ZZ gg hgg => ?_)
        simp only [Sieve.pullback_id, Sieve.pullback_apply] at hgg
        simp only [‚Üê types_comp_apply]
        rw [‚Üê P.map_comp, ‚Üê op_comp, h‚ÇÅ, h‚ÇÇ]
        simpa only [Sieve.pullback_apply, Category.assoc] using hgg
      let y : ‚àÄ ‚¶ÉZ : C‚¶Ñ (g : Z ‚ü∂ Y),
        ((S.pullback (g ‚â´ f)).pullback (ùüô _)).arrows.FamilyOfElements P :=
        fun Z g ZZ gg hgg => x (gg ‚â´ g) (by simpa using hgg)
      have hy : ‚àÄ ‚¶ÉZ : C‚¶Ñ (g : Z ‚ü∂ Y), (y g).Compatible := by
        intro Z g Y‚ÇÅ Y‚ÇÇ ZZ g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ h
        rw [hx]
        rw [reassoc_of% h]
      choose z hz using fun ‚¶ÉZ : C‚¶Ñ ‚¶Ég : Z ‚ü∂ Y‚¶Ñ (hg : R.pullback f g) =>
        H2' hg (ùüô _) (y g) (hy g)
      let q : (R.pullback f).arrows.FamilyOfElements P := fun Z g hg => z hg
      have hq : q.Compatible := by
        intro Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ h
        apply (H2 h‚ÇÅ g‚ÇÅ).ext
        intro ZZ gg hgg
        simp only [‚Üê types_comp_apply]
        rw [‚Üê P.map_comp, ‚Üê P.map_comp, ‚Üê op_comp, ‚Üê op_comp, hz, hz]
        ¬∑ dsimp [y]; congr 1; simp only [Category.assoc, h]
        ¬∑ simpa [reassoc_of% h] using hgg
        ¬∑ simpa using hgg
      obtain ‚ü®t, ht‚ü© := H1' f q hq
      refine ‚ü®t, fun Z g hg => ?_‚ü©
      refine (H1 (g ‚â´ f)).ext (fun ZZ gg hgg => ?_)
      rw [‚Üê types_comp_apply _ (P.map gg.op), ‚Üê P.map_comp, ‚Üê op_comp, ht]
      on_goal 2 => simpa using hgg
      refine (H2 hgg (ùüô _)).ext (fun ZZZ ggg hggg => ?_)
      rw [‚Üê types_comp_apply _ (P.map ggg.op), ‚Üê P.map_comp, ‚Üê op_comp, hz]
      on_goal 2 => simpa using hggg
      refine (H2 hgg ggg).ext (fun ZZZZ gggg _ => ?_)
      rw [‚Üê types_comp_apply _ (P.map gggg.op), ‚Üê P.map_comp, ‚Üê op_comp]
      apply hx
      simp

/--
A presheaf is a sheaf for the Grothendieck topology generated by a union of coverages iff it is a
sheaf for the Grothendieck topology generated by each coverage separately.
-/
theorem isSheaf_sup (K L : Coverage C) (P : C·µí·µñ ‚•§ Type*) :
    (Presieve.IsSheaf ((K ‚äî L).toGrothendieck C)) P ‚Üî
    (Presieve.IsSheaf (K.toGrothendieck C)) P ‚àß (Presieve.IsSheaf (L.toGrothendieck C)) P := by
  refine ‚ü®fun h ‚Ü¶ ‚ü®Presieve.isSheaf_of_le _ ((gi C).gc.monotone_l le_sup_left) h,
      Presieve.isSheaf_of_le _ ((gi C).gc.monotone_l le_sup_right) h‚ü©, fun h ‚Ü¶ ?_‚ü©
  rw [isSheaf_coverage, isSheaf_coverage] at h
  rw [isSheaf_coverage]
  intro X R hR
  rcases hR with hR | hR
  ¬∑ exact h.1 R hR
  ¬∑ exact h.2 R hR

end Presieve

namespace Presheaf

theorem isSheaf_iff_isLimit_coverage (K : Coverage C) (P : C·µí·µñ ‚•§ D) :
    Presheaf.IsSheaf (toGrothendieck _ K) P ‚Üî ‚àÄ ‚¶ÉX : C‚¶Ñ (R : Presieve X),
      R ‚àà K.covering X ‚Üí
        Nonempty (IsLimit (P.mapCone (Sieve.generate R).arrows.cocone.op)) := by
  simp only [Presheaf.IsSheaf, Presieve.isSheaf_coverage, isLimit_iff_isSheafFor,
    ‚Üê Presieve.isSheafFor_iff_generate]
  aesop

theorem isSheaf_sup (K L : Coverage C) (P : C·µí·µñ ‚•§ D) :
    (IsSheaf ((K ‚äî L).toGrothendieck C)) P ‚Üî
    (IsSheaf (K.toGrothendieck C)) P ‚àß (IsSheaf (L.toGrothendieck C)) P :=
  ‚ü®fun h ‚Ü¶ ‚ü®fun E ‚Ü¶ ((Presieve.isSheaf_sup K L _).mp (h E)).1, fun E ‚Ü¶
    ((Presieve.isSheaf_sup K L _).mp (h E)).2‚ü©,
      fun ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© E ‚Ü¶ (Presieve.isSheaf_sup K L _).mpr ‚ü®h‚ÇÅ E, h‚ÇÇ E‚ü©‚ü©

end Presheaf

end CategoryTheory
