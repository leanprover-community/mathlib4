/-
Copyright (c) 2023 Dagur Asgeirsson. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Dagur Asgeirsson, Filippo A. E. Nuccio, Riccardo Brasca
-/
import Mathlib.CategoryTheory.Limits.Preserves.Finite
import Mathlib.CategoryTheory.Limits.Preserves.Shapes.Products
import Mathlib.CategoryTheory.Limits.Shapes.DisjointCoproduct
import Mathlib.CategoryTheory.Sites.Coherent
import Mathlib.Tactic.ApplyFun
/-!

# The Regular and Extensive Coverages

This file defines two coverages on a category `C`.

The first one is called the *regular* coverage and for that to exist, the category `C` must satisfy
a condition called `Preregular C`. This means that effective epimorphisms can be "pulled back". The
covering sieves of this coverage are generated by presieves consisting of a single effective
epimorphism.

The second one is called the *extensive* coverage and for that to exist, the category `C` must
satisfy a condition called `Extensive C`. This means `C` has finite coproducts and that those
are preserved by pullbacks. The covering sieves of this coverage are generated by presieves
consisting finitely many arrows that together induce an isomorphism from the coproduct to the
target.

In `extensive_union_regular_generates_coherent`, we prove that the union of these two coverages
generates the coherent topology on `C` if `C` is precoherent, extensive and regular.

In `isSheafFor_extensive_of_preservesFiniteProducts`, we prove that a finite product preserving
presheaf satisfies the sheaf condition for a sieve consiting of finitely many arrows that together
induce an isomorphism from the coproduct of their sources.

TODO: figure out under what conditions `Preregular` and `Extensive`Â are implied by `Precoherent` and
vice versa.

-/

universe v u w

namespace CategoryTheory

open Limits

variable (C : Type u) [Category.{v} C]

/--
The condition `Preregular C` is property that effective epis can be "pulled back" along any
morphism. This is satisfied e.g. by categories that have pullbacks that preserve effective
epimorphisms (like `Profinite` and `CompHaus`), and categories where every object is projective
(like  `Stonean`).
-/
class Preregular : Prop where
  /--
  For `X`, `Y`, `Z`, `f`, `g` like in the diagram, where `g` is an effective epi, there exists
  an object `W`, an effective epi `h : W âŸ¶ X` and a morphism `i : W âŸ¶ Z` making the diagram
  commute.
  ```
  W --i-â†’ Z
  |       |
  h       g
  â†“       â†“
  X --f-â†’ Y
  ```
  -/
  exists_fac : âˆ€ {X Y Z : C} (f : X âŸ¶ Y) (g : Z âŸ¶ Y) [EffectiveEpi g],
    (âˆƒ (W : C) (h : W âŸ¶ X) (_ : EffectiveEpi h) (i : W âŸ¶ Z), i â‰« g = h â‰« f)

/--
Describes the property of having pullbacks of morphsims into a finite coproduct, where one
of the morphisms is an inclusion map into the coproduct (up to isomorphism).
-/
class HasPullbacksOfInclusions : Prop where
    /-- For any morphism `f : X âŸ¶ Z`, where `Z` is the coproduct of `i : (a : Î±) â†’ Y a âŸ¶ Z` with
    `Î±` finite, the pullback of `f` and `i a` exists for every `a : Î±`. -/
    has_pullback : âˆ€ {X Z : C} {Î± : Type w} (f : X âŸ¶ Z) {Y : (a : Î±) â†’ C}
    (i : (a : Î±) â†’ Y a âŸ¶ Z) [Fintype Î±] [HasCoproduct Y] [IsIso (Sigma.desc i)] (a : Î±),
    HasPullback f (i a)

instance [HasPullbacksOfInclusions C] {X Z : C} {Î± : Type w} (f : X âŸ¶ Z) {Y : (a : Î±) â†’ C}
    (i : (a : Î±) â†’ Y a âŸ¶ Z) [Fintype Î±] [HasCoproduct Y] [IsIso (Sigma.desc i)] (a : Î±) :
    HasPullback f (i a) := HasPullbacksOfInclusions.has_pullback f i a

/--
If `C` has pullbacks then it has the pullbacks relevant to `HasPullbacksOfInclusions`.
-/
instance (priority := 10) [HasPullbacks C] :
  HasPullbacksOfInclusions C := âŸ¨fun _ _ _ => inferInstanceâŸ©

/--
A category is *extensive* if it has all finite coproducts and those coproducts are preserved
by pullbacks (we only require the relevant pullbacks to exist, via `HasPullbacksOfInclusions`).

TODO: relate this to the class `FinitaryExtensive`
-/
class Preextensive extends HasFiniteCoproducts C, HasPullbacksOfInclusions C : Prop where
  /-- Pulling back an isomorphism from a coproduct yields an isomorphism. -/
  sigma_desc_iso : âˆ€ {Î± : Type} [Fintype Î±] {X : C} {Z : Î± â†’ C} (Ï€ : (a : Î±) â†’ Z a âŸ¶ X)
    {Y : C} (f : Y âŸ¶ X) (_ : IsIso (Sigma.desc Ï€)),
    IsIso (Sigma.desc ((fun _ â†¦ pullback.fst) : (a : Î±) â†’ pullback f (Ï€ a) âŸ¶ _))

class Extensive extends Preextensive C, CoproductsDisjoint C

/--
The regular coverage on a regular category `C`.
-/
def regularCoverage [Preregular C] : Coverage C where
  covering B := { S | âˆƒ (X : C) (f : X âŸ¶ B), S = Presieve.ofArrows (fun (_ : Unit) â†¦ X)
    (fun (_ : Unit) â†¦ f) âˆ§ EffectiveEpi f }
  pullback := by
    intro X Y f S âŸ¨Z, Ï€, hÏ€, h_epiâŸ©
    have := Preregular.exists_fac f Ï€
    obtain âŸ¨W, h, _, i, thisâŸ© := this
    refine âŸ¨Presieve.singleton h, âŸ¨?_, ?_âŸ©âŸ©
    Â· exact âŸ¨W, h, by {rw [Presieve.ofArrows_pUnit h]}, inferInstanceâŸ©
    Â· intro W g hg
      cases hg
      refine âŸ¨Z, i, Ï€, âŸ¨?_, thisâŸ©âŸ©
      cases hÏ€
      rw [Presieve.ofArrows_pUnit]
      exact Presieve.singleton.mk

/--
The extensive coverage on an extensive category `C`
-/
def extensiveCoverage [Preextensive C] : Coverage C where
  covering B := { S | âˆƒ (Î± : Type) (_ : Fintype Î±) (X : Î± â†’ C) (Ï€ : (a : Î±) â†’ (X a âŸ¶ B)),
    S = Presieve.ofArrows X Ï€ âˆ§ IsIso (Sigma.desc Ï€) }
  pullback := by
    intro X Y f S âŸ¨Î±, hÎ±, Z, Ï€, hS, h_isoâŸ©
    let Z' : Î± â†’ C := fun a â†¦ pullback f (Ï€ a)
    let Ï€' : (a : Î±) â†’ Z' a âŸ¶ Y := fun a â†¦ pullback.fst
    refine âŸ¨@Presieve.ofArrows C _ _ Î± Z' Ï€', âŸ¨?_, ?_âŸ©âŸ©
    Â· constructor
      exact âŸ¨hÎ±, Z', Ï€', âŸ¨by simp only, Preextensive.sigma_desc_iso (fun x => Ï€ x) f h_isoâŸ©âŸ©
    Â· intro W g hg
      rcases hg with âŸ¨aâŸ©
      refine âŸ¨Z a, pullback.snd, Ï€ a, ?_, by rw [CategoryTheory.Limits.pullback.condition]âŸ©
      rw [hS]
      refine Presieve.ofArrows.mk a


/-- The union of the extensive and regular coverages generates the coherent topology on `C`. -/
lemma extensive_regular_generate_coherent [Preregular C] [Preextensive C] [Precoherent C] :
    ((extensiveCoverage C) âŠ” (regularCoverage C)).toGrothendieck =
    (coherentTopology C) := by
  ext B S
  refine âŸ¨fun h â†¦ ?_, fun h â†¦ ?_âŸ©
  Â· induction h with
    | of Y T hT =>
      apply Coverage.saturate.of
      simp only [Coverage.sup_covering, Set.mem_union] at hT
      exact Or.elim hT
        (fun âŸ¨Î±, x, X, Ï€, âŸ¨h, _âŸ©âŸ© â†¦ âŸ¨Î±, x, X, Ï€, âŸ¨h, inferInstanceâŸ©âŸ©)
        (fun âŸ¨Z, f, âŸ¨h, _âŸ©âŸ© â†¦ âŸ¨Unit, inferInstance, fun _ â†¦ Z, fun _ â†¦ f, âŸ¨h, inferInstanceâŸ©âŸ©)
    | top => apply Coverage.saturate.top
    | transitive Y T => apply Coverage.saturate.transitive Y T<;> [assumption; assumption]
  Â· induction h with
    | of Y T hT =>
      obtain âŸ¨I, hI, X, f, âŸ¨h, hTâŸ©âŸ© := hT
      let Ï† := fun (i : I) â†¦ Sigma.Î¹ X i
      let F := Sigma.desc f
      let Z := Sieve.generate T
      let Xs := (âˆ fun (i : I) => X i)
      let Zf := Sieve.generate (Presieve.ofArrows (fun (_ : Unit) â†¦ Xs) (fun (_ : Unit) â†¦ F))
      apply Coverage.saturate.transitive Y Zf
      Â· apply Coverage.saturate.of
        simp only [Coverage.sup_covering, extensiveCoverage, regularCoverage, Set.mem_union,
          Set.mem_setOf_eq]
        exact Or.inr âŸ¨Xs, F, âŸ¨rfl, inferInstanceâŸ©âŸ©
      Â· intro R g hZfg
        dsimp at hZfg
        rw [Presieve.ofArrows_pUnit] at hZfg
        obtain âŸ¨W, Ïˆ, Ïƒ, âŸ¨hW, hW'âŸ©âŸ© := hZfg
        induction hW
        rw [â† hW', Sieve.pullback_comp Z]
        suffices Sieve.pullback Ïˆ ((Sieve.pullback F) Z) âˆˆ GrothendieckTopology.sieves
          ((extensiveCoverage C) âŠ” (regularCoverage C)).toGrothendieck R by assumption
        apply GrothendieckTopology.pullback_stable'
        suffices Coverage.saturate ((extensiveCoverage C) âŠ” (regularCoverage C)) Xs
          (Z.pullback F) by assumption
        suffices : Sieve.generate (Presieve.ofArrows X Ï†) â‰¤ Z.pullback F
        Â· apply Coverage.saturate_of_superset _ this
          apply Coverage.saturate.of
          simp only [Coverage.sup_covering, extensiveCoverage, regularCoverage, Set.mem_union,
            Set.mem_setOf_eq]
          refine Or.inl âŸ¨I, hI, X, Ï†, âŸ¨rfl, ?_âŸ©âŸ©
          suffices Sigma.desc Ï† = ðŸ™ _ by rw [this]; infer_instance
          ext
          simp only [colimit.Î¹_desc, Cofan.mk_pt, Cofan.mk_Î¹_app, Category.comp_id]
        intro Q q hq
        simp only [Sieve.pullback_apply, Sieve.generate_apply]
        simp only [Sieve.generate_apply] at hq
        obtain âŸ¨E, e, r, hqâŸ© := hq
        refine' âŸ¨E, e, r â‰« F, âŸ¨_, _âŸ©âŸ©
        Â· rw [h]
          induction hq.1
          simp only [colimit.Î¹_desc, Cofan.mk_pt, Cofan.mk_Î¹_app]
          exact Presieve.ofArrows.mk _
        Â· rw [â† hq.2]
          simp only [Category.assoc]
    | top => apply Coverage.saturate.top
    | transitive Y T => apply Coverage.saturate.transitive Y T<;> [assumption; assumption]

section ExtensiveSheaves

variable [Preextensive C] {C}

/-- A presieve is *extensive* if it is finite and its arrows induce an isomorphism from the
coproduct to the target. -/
class Presieve.extensive [HasFiniteCoproducts C] {X : C} (R : Presieve X) :
    Prop where
  /-- `R` consists of a finite collection of arrows that together induce an isomorphism from the
  coproduct of their sources. -/
  arrows_sigma_desc_iso : âˆƒ (Î± : Type) (_ : Fintype Î±) (Z : Î± â†’ C) (Ï€ : (a : Î±) â†’ (Z a âŸ¶ X)),
    R = Presieve.ofArrows Z Ï€ âˆ§ IsIso (Sigma.desc Ï€)

instance {X : C} (S : Presieve X) [S.extensive] : S.hasPullbacks where
  has_pullbacks := by
    obtain âŸ¨_, _, _, _, hS, _âŸ© := Presieve.extensive.arrows_sigma_desc_iso (R := S)
    intro _ _ f hf _ hg
    rw [hS] at hf hg
    cases' hg with b
    apply HasPullbacksOfInclusions.has_pullback f

namespace ExtensiveSheafConditionProof

lemma sigma_surjective {Î± : Type} {Z : Î± â†’ C} {X : C} (Ï€ : (a : Î±) â†’ Z a âŸ¶ X) :
    Function.Surjective (fun a => âŸ¨Z a, Ï€ a, Presieve.ofArrows.mk aâŸ© :
    Î± â†’ Î£(Y : C), { f : Y âŸ¶ X // Presieve.ofArrows Z Ï€ f }) :=
  fun âŸ¨_, âŸ¨_, hfâŸ©âŸ© â†¦ by cases' hf with a _; exact âŸ¨a, rflâŸ©

-- noncomputable
-- def map {Î± : Type} {Z : Î± â†’ C} {X : C} (Ï€ : (a : Î±) â†’ Z a âŸ¶ X) :
--     (Î£(Y : C), { f : Y âŸ¶ X // Presieve.ofArrows Z Ï€ f }) â†’ Î± :=
--   Function.surjInv (sigma_surjective Ï€)

-- def map2 {Î± : Type} {Z : Î± â†’ C} {X : C} (Ï€ : (a : Î±) â†’ Z a âŸ¶ X)
--     (f : Î£(Y : C), { f : Y âŸ¶ X // Presieve.ofArrows Z Ï€ f }) :
--     f.fst âŸ¶ Z (map Ï€ f) := sorry

lemma map_eq {Î± : Type} {Z : Î± â†’ C} {X : C} (Ï€ : (a : Î±) â†’ Z a âŸ¶ X)
    (f : Î£(Y : C), { f : Y âŸ¶ X // Presieve.ofArrows Z Ï€ f }) :
    âˆƒ i, f.fst = Z i := by
  obtain âŸ¨Y, g, hâŸ© := f
  cases' h with i
  exact âŸ¨i, rflâŸ©

open Opposite

instance {Î± : Type} {Z : Î± â†’ C} {X : C} {Ï€ : (a : Î±) â†’ Z a âŸ¶ X} [Fintype Î±] :
    HasProduct fun (x : Î£(Y : C), { f : Y âŸ¶ X // Presieve.ofArrows Z Ï€ f }) â†¦ (op x.1) :=
  haveI := Finite.of_surjective _ (sigma_surjective.{v, u} Ï€)
  inferInstance

/-- The canonical map from `Equalizer.FirstObj` to a product indexed by `Î±` -/
noncomputable
def prod_map {Î± : Type} {Z : Î± â†’ C} {X : C} (Ï€ : (a : Î±) â†’ Z a âŸ¶ X) (F : Cáµ’áµ– â¥¤ Type max u v) :
    (âˆ fun (f : (Î£(Y : C), { f : Y âŸ¶ X // Presieve.ofArrows Z Ï€ f })) => F.obj (op f.fst)) âŸ¶
    âˆ fun a => F.obj (op (Z a)) :=
  Pi.lift (fun a => Pi.Ï€ (fun (f : (Î£(Y : C), { f : Y âŸ¶ X // Presieve.ofArrows Z Ï€ f })) =>
    F.obj (op f.fst)) âŸ¨Z a, Ï€ a, Presieve.ofArrows.mk aâŸ©)

noncomputable
def prod_map' {Î± : Type} {Z : Î± â†’ C} {X : C} (Ï€ : (a : Î±) â†’ Z a âŸ¶ X) (F : Cáµ’áµ– â¥¤ Type max u v) :
    (âˆ fun (f : (Î£(Y : C), { f : Y âŸ¶ X // Presieve.ofArrows Z Ï€ f })) => F.obj (op f.fst)) âŸ¶
    âˆ fun a => F.obj (op (Z a)) :=
  Pi.map' (fun a => âŸ¨Z a, Ï€ a, Presieve.ofArrows.mk aâŸ©) (fun _ â†¦ F.map (ðŸ™ _))

/-- The canonical map from `Equalizer.FirstObj` to a product indexed by `Î±` -/
noncomputable
def prod_map_inv' {Î± : Type} {Z : Î± â†’ C} {X : C} (Ï€ : (a : Î±) â†’ Z a âŸ¶ X) (F : Cáµ’áµ– â¥¤ Type max u v) :
     (âˆ fun a => F.obj (op (Z a))) âŸ¶
    (âˆ fun (f : (Î£(Y : C), { f : Y âŸ¶ X // Presieve.ofArrows Z Ï€ f })) => F.obj (op f.fst)) :=
  Pi.map' (fun f â†¦ (map_eq Ï€ f).choose) (fun f â†¦ F.map (eqToHom (map_eq Ï€ f).choose_spec).op)

/-- The canonical map from `Equalizer.FirstObj` to a product indexed by `Î±` -/
noncomputable
def prod_map_inv {Î± : Type} {Z : Î± â†’ C} {X : C} (Ï€ : (a : Î±) â†’ Z a âŸ¶ X) (F : Cáµ’áµ– â¥¤ Type max u v) :
     (âˆ fun a => F.obj (op (Z a))) âŸ¶
    (âˆ fun (f : (Î£(Y : C), { f : Y âŸ¶ X // Presieve.ofArrows Z Ï€ f })) => F.obj (op f.fst)) :=
  Pi.lift (fun f â†¦ (Pi.Ï€ (fun a => F.obj (op (Z a))) (map_eq Ï€ f).choose â‰«
    F.map (eqToHom (map_eq Ï€ f).choose_spec).op))

/-- The inverse to `Equalizer.forkMap F (Presieve.ofArrows Z Ï€)`. -/
noncomputable
def firstObj_to_base {Î± : Type} [Fintype Î±] {Z : Î± â†’ C} {X : C} (Ï€ : (a : Î±) â†’ Z a âŸ¶ X)
    (F : Cáµ’áµ– â¥¤ Type max u v) [PreservesFiniteProducts F] [IsIso (Sigma.desc Ï€)] :
    Equalizer.FirstObj F (Presieve.ofArrows Z Ï€) âŸ¶ F.obj (op X) :=
  haveI : PreservesLimit (Discrete.functor fun a => op (Z a)) F :=
    (PreservesFiniteProducts.preserves Î±).preservesLimit
  (prod_map Ï€ F) â‰« ((Limits.PreservesProduct.iso F (fun a => op <| Z a)).inv â‰«
    F.map (opCoproductIsoProduct Z).inv â‰« F.map (inv (Sigma.desc Ï€).op))

lemma comp_inv_desc_eq_Î¹ {Î± : Type} [Fintype Î±] {Z : Î± â†’ C} {X : C} (Ï€ : (a : Î±) â†’ Z a âŸ¶ X)
    [IsIso (Sigma.desc Ï€)] (a : Î±) : Ï€ a â‰« inv (Sigma.desc Ï€) = Sigma.Î¹ _ a := by
  simp only [IsIso.comp_inv_eq, colimit.Î¹_desc, Cofan.mk_pt, Cofan.mk_Î¹_app]

@[simp]
lemma PreservesProduct.isoInvCompMap {C : Type u} [Category C] {D : Type v} [Category D] (F : C â¥¤ D)
    {J : Type w} {f : J â†’ C} [HasProduct f] [HasProduct (fun j => F.obj (f j))]
    [PreservesLimit (Discrete.functor f) F] (j : J) :
    (PreservesProduct.iso F f).inv â‰« F.map (Pi.Ï€ _ j) = Pi.Ï€ _ j :=
  IsLimit.conePointUniqueUpToIso_inv_comp _ (limit.isLimit _) (âŸ¨jâŸ© : Discrete J)

instance {Î± : Type} [Fintype Î±] {Z : Î± â†’ C} {F : C â¥¤ Type w}
    [PreservesFiniteProducts F] : PreservesLimit (Discrete.functor fun a => (Z a)) F :=
  (PreservesFiniteProducts.preserves Î±).preservesLimit

instance {X : C} (S : Presieve X) [S.extensive]
    {F : Cáµ’áµ– â¥¤ Type max u v} [PreservesFiniteProducts F] : IsIso (Equalizer.forkMap F S) := by
  obtain âŸ¨Î±, _, Z, Ï€, hS, _âŸ© := Presieve.extensive.arrows_sigma_desc_iso (R := S)
  subst hS
  refine' âŸ¨firstObj_to_base Ï€ F,_,_âŸ©
  Â· simp only [firstObj_to_base, â† Category.assoc, Functor.map_inv,
      IsIso.comp_inv_eq, Category.id_comp, â† Functor.mapIso_inv, Iso.comp_inv_eq,
      Functor.mapIso_hom, Iso.comp_inv_eq, â† Functor.map_comp,
      desc_op_comp_opCoproductIsoProduct_hom, PreservesProduct.iso_hom, map_lift_piComparison,
      colimit.Î¹_desc, Cofan.mk_pt, Cofan.mk_Î¹_app]
    funext s
    ext a
    simp only [prod_map, types_comp_apply, Types.Limit.lift_Ï€_apply, Fan.mk_pt, Fan.mk_Ï€_app,
      Equalizer.forkMap, Types.pi_lift_Ï€_apply]
  Â· refine Limits.Pi.hom_ext _ _ (fun f => ?_)
    simp only [Equalizer.forkMap, Category.assoc, limit.lift_Ï€, Fan.mk_pt, Fan.mk_Ï€_app,
      Category.id_comp]
    obtain âŸ¨a, haâŸ© := sigma_surjective Ï€ f
    rw [firstObj_to_base, Category.assoc, Category.assoc, Category.assoc, â† Functor.map_comp,
      â† op_inv, â† op_comp, â† ha, comp_inv_desc_eq_Î¹, â† Functor.map_comp,
      opCoproductIsoProduct_inv_comp_Î¹, PreservesProduct.isoInvCompMap F a]
    simp only [prod_map, limit.lift_Ï€, Fan.mk_pt, Fan.mk_Ï€_app]

end ExtensiveSheafConditionProof

open ExtensiveSheafConditionProof

lemma isSheafFor_extensive_of_preservesFiniteProducts {X : C} (S : Presieve X) [S.extensive]
    (F : Cáµ’áµ– â¥¤ Type max u v) [PreservesFiniteProducts F] :
    Presieve.IsSheafFor F S := by
  refine' (Equalizer.Presieve.sheaf_condition F S).2 _
  rw [Limits.Types.type_equalizer_iff_unique]
  suffices : IsIso (Equalizer.forkMap F S)
  Â· intro y _
    refine' âŸ¨inv (Equalizer.forkMap F S) y, _, fun yâ‚ hyâ‚ => _âŸ©
    Â· change (inv (Equalizer.forkMap F S) â‰« (Equalizer.forkMap F S)) y = y
      rw [IsIso.inv_hom_id, types_id_apply]
    Â· replace hyâ‚ := congr_arg (inv (Equalizer.forkMap F S)) hyâ‚
      change ((Equalizer.forkMap F S) â‰« inv (Equalizer.forkMap F S)) _ = _ at hyâ‚
      rwa [IsIso.hom_inv_id, types_id_apply] at hyâ‚
  infer_instance

namespace ExtensiveSheafConditionProof

open Opposite

variable {Î± : Type} [Fintype Î±] (Z : Î± â†’ C) (F : Cáµ’áµ– â¥¤ Type max u v)
    (hF : Presieve.IsSheafFor F (Presieve.ofArrows Z (fun j â†¦ Sigma.Î¹ Z j)))

-- instance : (Presieve.ofArrows Z (fun j â†¦ Sigma.Î¹ Z j)).hasPullbacks := sorry

instance : (Presieve.ofArrows Z (fun j â†¦ Sigma.Î¹ Z j)).extensive := sorry

lemma sigma_injective [Extensive C] : Function.Injective (fun a => âŸ¨Z a, (fun j â†¦ Sigma.Î¹ Z j) a,
    Presieve.ofArrows.mk aâŸ© : Î± â†’ Î£(Y : C), { f : Y âŸ¶ _ //
    Presieve.ofArrows Z (fun j â†¦ Sigma.Î¹ Z j) f }) := by
  intro a b h
  simp only [Sigma.mk.inj_iff] at h
  by_contra hh
  rw [and_iff_not_or_not] at h
  apply h
  sorry

lemma eq_comp_of_heq {X Y Z W : C} (h : Y = Z) (f : Y âŸ¶ W) (g : Z âŸ¶ W) (i : X âŸ¶ Y) (j : X âŸ¶ Z)
    (hfg : HEq f g) (hij : i = j â‰« eqToHom h.symm) : i â‰« f = j â‰« g := by
  cases h; cases hfg; cases hij; simp only [eqToHom_refl, Category.comp_id]

lemma heq_of_eq_comp {X Y Z : C} (h : Y = Z) (f : X âŸ¶ Y) (g : X âŸ¶ Z) (hfg : f â‰« eqToHom h = g) :
    HEq f g := by
  cases h; cases hfg; simp only [eqToHom_refl, Category.comp_id, heq_eq_eq]


lemma prod_map_inj : Function.Injective (prod_map (fun j â†¦ Sigma.Î¹ Z j) F) := by
  intro a b h
  ext âŸ¨fâŸ©
  obtain âŸ¨c, hcâŸ© := sigma_surjective (fun j â†¦ Sigma.Î¹ Z j) f
  subst hc
  apply_fun Pi.Ï€ (fun i â†¦ F.obj (op (Z i))) c at h
  simp only [prod_map, Types.pi_lift_Ï€_apply] at h
  exact h

-- âŸ¨fâŸ© : Discrete (Î£(Y : C), { Ï† : Y âŸ¶ âˆ Z // Presieve.ofArrows Z (fun j â†¦ Sigma.Î¹ Z j) Ï† })

lemma prod_map_surj : Function.Surjective (prod_map (fun j â†¦ Sigma.Î¹ Z j) F) := by
  intro a
  let g := fun f â†¦ (Pi.Ï€ (fun a â†¦ F.obj (op (Z a))) (map_eq (fun j â†¦ Sigma.Î¹ Z j) f).choose â‰«
    F.map (eqToHom (map_eq (fun j â†¦ Sigma.Î¹ Z j) f).choose_spec).op) a
  refine âŸ¨Types.Limit.mk (Discrete.functor (fun (f : (Î£(Y : C), { f : Y âŸ¶ _ //
      Presieve.ofArrows Z (fun j â†¦ Sigma.Î¹ Z j) f })) â†¦ F.obj (op f.fst))) (fun f â†¦ g f.1) ?_, ?_âŸ©
  Â· intro âŸ¨jâŸ© âŸ¨kâŸ© f
    cases Discrete.eq_of_hom f
    rfl
  Â· ext âŸ¨jâŸ©
    simp only [Discrete.functor_obj, prod_map, eqToHom_op, types_comp_apply, Types.pi_lift_Ï€_apply,
      Types.Limit.Ï€_mk, Pi.Ï€]
    have : âˆ€ b, limit.Ï€ (Discrete.functor (fun a â†¦ F.obj (op (Z a)))) b =
        Pi.Ï€ (fun a â†¦ F.obj (op (Z a))) b.1 := by intros; rfl
    rw [this, this]
    dsimp
    have h := map_eq (fun j â†¦ Sigma.Î¹ Z j)
    sorry

lemma prod_map_inv_inj : Function.Injective (prod_map_inv (fun j â†¦ Sigma.Î¹ Z j) F) := by
  intro a b h
  ext âŸ¨jâŸ©
  simp only [prod_map_inv, eqToHom_op] at h
  sorry

lemma prod_map_inv_surj : Function.Injective (prod_map_inv (fun j â†¦ Sigma.Î¹ Z j) F) := sorry

lemma prod_map_comp_inv :
    prod_map' (fun j â†¦ Sigma.Î¹ Z j) F â‰« prod_map_inv' (fun j â†¦ Sigma.Î¹ Z j) F = ðŸ™ _ := by
  simp only [prod_map', Functor.map_id, prod_map_inv', eqToHom_op]
  rw [Pi.map'_comp_map', â† Pi.map'_id_id]
  refine Pi.map'_eq ?_ ?_
  Â· funext x
    simp only [Function.comp_apply, id_eq]
    sorry
  Â· intro b; ext; simp; sorry

lemma prod_map_inv_comp :
    prod_map_inv' (fun j â†¦ Sigma.Î¹ Z j) F â‰« prod_map' (fun j â†¦ Sigma.Î¹ Z j) F  = ðŸ™ _ := by
  simp only [prod_map_inv', eqToHom_op, prod_map', Functor.map_id]
  rw [Pi.map'_comp_map', â† Pi.map'_id_id]
  refine Pi.map'_eq ?_ ?_
  Â· ext x; simp only [Function.comp_apply, id_eq]; sorry
  Â· intro b; ext; simp; sorry

lemma one : F.map (opCoproductIsoProduct Z).inv â‰«
    Equalizer.forkMap F (Presieve.ofArrows Z (fun j â†¦ Sigma.Î¹ Z j)) â‰« prod_map _ F =
    piComparison F (fun z â†¦ op (Z z)) := by
  have : (Equalizer.forkMap F (Presieve.ofArrows Z (fun j â†¦ Sigma.Î¹ Z j)) â‰«
      prod_map (fun j â†¦ Sigma.Î¹ Z j) F) = Pi.lift (fun j â†¦ F.map ((fun j â†¦ Sigma.Î¹ Z j) j).op) := by
    ext; simp [prod_map, Equalizer.forkMap]
  rw [this]
  have t : Pi.lift (fun j â†¦ Pi.Ï€ (fun a â†¦ (op (Z a))) j) = ðŸ™ _ := by ext; simp -- why not just simp?
  have hh : (fun j â†¦ (opCoproductIsoProduct Z).inv â‰« (Sigma.Î¹ Z j).op) =
      fun j â†¦ Pi.Ï€ (fun a â†¦ (op (Z a))) j
  Â· ext j
    exact opCoproductIsoProduct_inv_comp_Î¹ _ _
  have : F.map (Pi.lift (fun j â†¦ (opCoproductIsoProduct Z).inv â‰« (Sigma.Î¹ Z j).op)) â‰«
      piComparison F (fun z â†¦ op (Z z)) =
      (F.map (opCoproductIsoProduct Z).inv â‰« Pi.lift fun j â†¦ F.map ((fun j â†¦ Sigma.Î¹ Z j) j).op)
  Â· rw [hh, t]
    ext j x
    simp only [Functor.map_id, Category.id_comp, piComparison, types_comp_apply,
      Types.pi_lift_Ï€_apply, â† FunctorToTypes.map_comp_apply, congr_fun hh j]
  rw [â† this, hh]
  congr
  ext
  simp [t]

lemma two : Equalizer.Presieve.firstMap F (Presieve.ofArrows Z (fun j â†¦ Sigma.Î¹ Z j)) =
    Equalizer.Presieve.secondMap F (Presieve.ofArrows Z (fun j â†¦ Sigma.Î¹ Z j)) := by
  ext a
  simp only [Equalizer.Presieve.SecondObj, Equalizer.Presieve.firstMap,
    Equalizer.Presieve.secondMap]
  ext âŸ¨jâŸ©
  simp only [Discrete.functor_obj, Types.pi_lift_Ï€_apply, types_comp_apply]
  obtain âŸ¨âŸ¨j1, f1, h1âŸ©, âŸ¨j2, f2, h2âŸ©âŸ© := j
  cases' h1 with i1
  cases' h2 with i2
  by_cases hi : i1 = i2
  Â· rw [hi]
    sorry
  Â· sorry


end ExtensiveSheafConditionProof

open Opposite

noncomputable
instance (F : Cáµ’áµ– â¥¤ Type max u v) (h : âˆ€ {X : C} (S : Presieve X) [S.extensive], S.IsSheafFor F) :
    PreservesFiniteProducts F := by
  constructor
  intro J _
  constructor
  intro K
  let k : J â†’ Cáµ’áµ– := fun j â†¦ K.obj âŸ¨jâŸ©
  let i : K â‰… (Discrete.functor k) := Discrete.natIsoFunctor
  let S := (Presieve.ofArrows (fun j â†¦ unop (k j)) (fun j â†¦ Sigma.Î¹ (fun j â†¦ unop (k j)) j))
  specialize h S
  refine @preservesLimitOfIsoDiagram _ _ _ _ _ _ _ _ F i.symm ?_
  refine @PreservesProduct.ofIsoComparison _ _ _ _ F _ k _ _ ?_
  have hh : piComparison F (fun j â†¦ op (unop (k j))) = piComparison F k := rfl
  rw [â† hh]
  rw [(one (fun j â†¦ (k j).unop) F).symm]
  refine @IsIso.comp_isIso _ _ _ _ _ _ _ inferInstance ?_
  refine @IsIso.comp_isIso _ _ _ _ _ _ _ ?_ ?_
  Â· rw [isIso_iff_bijective, Function.bijective_iff_existsUnique]
    rw [Equalizer.Presieve.sheaf_condition, Limits.Types.type_equalizer_iff_unique] at h
    exact fun b â†¦ h b (congr_fun (two (fun j â†¦ unop (k j)) F) b)
  Â· sorry
    -- refine Limits.Pi.hom_ext _ _ (fun f => ?_)

    -- rw [isIso_iff_bijective]
    -- refine âŸ¨fun a b hab â†¦ ?_, fun a â†¦ ?_âŸ©
    -- Â· ext Y f hf
    --   cases' hf with i
    --   simp only [prod_map, op_unop] at hab
    --   sorry
    -- Â· refine âŸ¨prod_map_inv _ _ a, ?_âŸ©
    --   ext j
    --   sorry

    -- refine âŸ¨prod_map_inv _ _, ?_, ?_âŸ©
    -- Â· -- simp only [prod_map, op_unop, Category.comp_id, prod_map_inv, eqToHom_op]
    --   ext a Y f hf
    --   cases' hf with i
    --   dsimp only [prod_map_inv, prod_map]
    --   simp only [op_unop, eqToHom_op, types_comp_apply, Types.pi_lift_Ï€_apply, types_id_apply]
    --   sorry
    -- Â· simp only [prod_map_inv, op_unop, eqToHom_op, prod_map, Category.comp_id]
    --   ext
    --   dsimp only [op_unop, types_comp_apply, types_id_apply]
    --   simp only [Types.pi_lift_Ï€_apply, op_unop, types_comp_apply]
    --   -- Types.pi_lift_Ï€_apply
    --   sorry



end ExtensiveSheaves

end CategoryTheory
