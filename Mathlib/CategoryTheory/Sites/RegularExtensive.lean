/-
Copyright (c) 2023 Dagur Asgeirsson. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Dagur Asgeirsson, Filippo A. E. Nuccio, Riccardo Brasca
-/
import Mathlib.CategoryTheory.Preadditive.Projective
import Mathlib.CategoryTheory.Sites.Coherent
import Mathlib.CategoryTheory.Extensive
import Mathlib.CategoryTheory.Sites.EqualizerSheafCondition
import Mathlib.Tactic.ApplyFun
/-!

# The Regular and Extensive Coverages

This file defines two coverages on a category `C`.

The first one is called the *regular* coverage and for that to exist, the category `C` must satisfy
a condition called `Preregular C`. This means that effective epimorphisms can be "pulled back". The
covering sieves of this coverage are generated by presieves consisting of a single effective
epimorphism.

The second one is called the *extensive* coverage and for that to exist, the category `C` must
satisfy a condition called `FinitaryPreExtensive C`. This means `C` has finite coproducts and that
those are preserved by pullbacks. The covering sieves of this coverage are generated by presieves
consisting finitely many arrows that together induce an isomorphism from the coproduct to the
target.

In `extensive_union_regular_generates_coherent`, we prove that the union of these two coverages
generates the coherent topology on `C` if `C` is precoherent, extensive and regular.

In `isSheafFor_regular_of_hasPullbacks`Â we prove that a presheaf satisfying an "equaliser condition"
satisfies the sheaf condition for a presieve consisting of a single effective epimorphism. In
`isSheafFor_regular_of_projective`, we prove that every presheaf satisfies the sheaf condition for
such presieves with projective target.

TODO: figure out under what conditions `Preregular` and `Extensive`Â are implied by `Precoherent` and
vice versa.

-/

universe v u w

namespace CategoryTheory

open Limits

variable (C : Type u) [Category.{v} C]

/--
The condition `Preregular C` is property that effective epis can be "pulled back" along any
morphism. This is satisfied e.g. by categories that have pullbacks that preserve effective
epimorphisms (like `Profinite` and `CompHaus`), and categories where every object is projective
(like  `Stonean`).
-/
class Preregular : Prop where
  /--
  For `X`, `Y`, `Z`, `f`, `g` like in the diagram, where `g` is an effective epi, there exists
  an object `W`, an effective epi `h : W âŸ¶ X` and a morphism `i : W âŸ¶ Z` making the diagram
  commute.
  ```
  W --i-â†’ Z
  |       |
  h       g
  â†“       â†“
  X --f-â†’ Y
  ```
  -/
  exists_fac : âˆ€ {X Y Z : C} (f : X âŸ¶ Y) (g : Z âŸ¶ Y) [EffectiveEpi g],
    (âˆƒ (W : C) (h : W âŸ¶ X) (_ : EffectiveEpi h) (i : W âŸ¶ Z), i â‰« g = h â‰« f)

/--
The regular coverage on a regular category `C`.
-/
def regularCoverage [Preregular C] : Coverage C where
  covering B := { S | âˆƒ (X : C) (f : X âŸ¶ B), S = Presieve.ofArrows (fun (_ : Unit) â†¦ X)
    (fun (_ : Unit) â†¦ f) âˆ§ EffectiveEpi f }
  pullback := by
    intro X Y f S âŸ¨Z, Ï€, hÏ€, h_epiâŸ©
    have := Preregular.exists_fac f Ï€
    obtain âŸ¨W, h, _, i, thisâŸ© := this
    refine âŸ¨Presieve.singleton h, âŸ¨?_, ?_âŸ©âŸ©
    Â· exact âŸ¨W, h, by {rw [Presieve.ofArrows_pUnit h]}, inferInstanceâŸ©
    Â· intro W g hg
      cases hg
      refine âŸ¨Z, i, Ï€, âŸ¨?_, thisâŸ©âŸ©
      cases hÏ€
      rw [Presieve.ofArrows_pUnit]
      exact Presieve.singleton.mk

/--
The extensive coverage on an extensive category `C`
-/
def extensiveCoverage [FinitaryPreExtensive C] : Coverage C where
  covering B := { S | âˆƒ (Î± : Type) (_ : Fintype Î±) (X : Î± â†’ C) (Ï€ : (a : Î±) â†’ (X a âŸ¶ B)),
    S = Presieve.ofArrows X Ï€ âˆ§ IsIso (Sigma.desc Ï€) }
  pullback := by
    intro X Y f S âŸ¨Î±, hÎ±, Z, Ï€, hS, h_isoâŸ©
    let Z' : Î± â†’ C := fun a â†¦ pullback f (Ï€ a)
    let Ï€' : (a : Î±) â†’ Z' a âŸ¶ Y := fun a â†¦ pullback.fst
    refine âŸ¨@Presieve.ofArrows C _ _ Î± Z' Ï€', âŸ¨?_, ?_âŸ©âŸ©
    Â· constructor
      exact âŸ¨hÎ±, Z', Ï€', âŸ¨by simp only, FinitaryPreExtensive.sigma_desc_iso (fun x => Ï€ x) f h_isoâŸ©âŸ©
    Â· intro W g hg
      rcases hg with âŸ¨aâŸ©
      refine âŸ¨Z a, pullback.snd, Ï€ a, ?_, by rw [CategoryTheory.Limits.pullback.condition]âŸ©
      rw [hS]
      exact Presieve.ofArrows.mk a


/-- The union of the extensive and regular coverages generates the coherent topology on `C`. -/
lemma extensive_regular_generate_coherent [Preregular C] [FinitaryPreExtensive C] [Precoherent C] :
    ((extensiveCoverage C) âŠ” (regularCoverage C)).toGrothendieck =
    (coherentTopology C) := by
  ext B S
  refine âŸ¨fun h â†¦ ?_, fun h â†¦ ?_âŸ©
  Â· induction h with
    | of Y T hT =>
      apply Coverage.saturate.of
      simp only [Coverage.sup_covering, Set.mem_union] at hT
      exact Or.elim hT
        (fun âŸ¨Î±, x, X, Ï€, âŸ¨h, _âŸ©âŸ© â†¦ âŸ¨Î±, x, X, Ï€, âŸ¨h, inferInstanceâŸ©âŸ©)
        (fun âŸ¨Z, f, âŸ¨h, _âŸ©âŸ© â†¦ âŸ¨Unit, inferInstance, fun _ â†¦ Z, fun _ â†¦ f, âŸ¨h, inferInstanceâŸ©âŸ©)
    | top => apply Coverage.saturate.top
    | transitive Y T => apply Coverage.saturate.transitive Y T<;> [assumption; assumption]
  Â· induction h with
    | of Y T hT =>
      obtain âŸ¨I, hI, X, f, âŸ¨h, hTâŸ©âŸ© := hT
      let Ï† := fun (i : I) â†¦ Sigma.Î¹ X i
      let F := Sigma.desc f
      let Z := Sieve.generate T
      let Xs := (âˆ fun (i : I) => X i)
      let Zf := Sieve.generate (Presieve.ofArrows (fun (_ : Unit) â†¦ Xs) (fun (_ : Unit) â†¦ F))
      apply Coverage.saturate.transitive Y Zf
      Â· apply Coverage.saturate.of
        simp only [Coverage.sup_covering, extensiveCoverage, regularCoverage, Set.mem_union,
          Set.mem_setOf_eq]
        exact Or.inr âŸ¨Xs, F, âŸ¨rfl, inferInstanceâŸ©âŸ©
      Â· intro R g hZfg
        dsimp at hZfg
        rw [Presieve.ofArrows_pUnit] at hZfg
        obtain âŸ¨W, Ïˆ, Ïƒ, âŸ¨hW, hW'âŸ©âŸ© := hZfg
        induction hW
        rw [â† hW', Sieve.pullback_comp Z]
        suffices Sieve.pullback Ïˆ ((Sieve.pullback F) Z) âˆˆ GrothendieckTopology.sieves
          ((extensiveCoverage C) âŠ” (regularCoverage C)).toGrothendieck R by assumption
        apply GrothendieckTopology.pullback_stable'
        suffices Coverage.saturate ((extensiveCoverage C) âŠ” (regularCoverage C)) Xs
          (Z.pullback F) by assumption
        suffices : Sieve.generate (Presieve.ofArrows X Ï†) â‰¤ Z.pullback F
        Â· apply Coverage.saturate_of_superset _ this
          apply Coverage.saturate.of
          simp only [Coverage.sup_covering, extensiveCoverage, regularCoverage, Set.mem_union,
            Set.mem_setOf_eq]
          refine Or.inl âŸ¨I, hI, X, Ï†, âŸ¨rfl, ?_âŸ©âŸ©
          suffices Sigma.desc Ï† = ğŸ™ _ by rw [this]; infer_instance
          ext
          simp only [colimit.Î¹_desc, Cofan.mk_pt, Cofan.mk_Î¹_app, Category.comp_id]
        intro Q q hq
        simp only [Sieve.pullback_apply, Sieve.generate_apply]
        simp only [Sieve.generate_apply] at hq
        obtain âŸ¨E, e, r, hqâŸ© := hq
        refine' âŸ¨E, e, r â‰« F, âŸ¨_, _âŸ©âŸ©
        Â· rw [h]
          induction hq.1
          simp only [colimit.Î¹_desc, Cofan.mk_pt, Cofan.mk_Î¹_app]
          exact Presieve.ofArrows.mk _
        Â· rw [â† hq.2]
          simp only [Category.assoc]
    | top => apply Coverage.saturate.top
    | transitive Y T => apply Coverage.saturate.transitive Y T<;> [assumption; assumption]

section RegularSheaves

variable {C}

open Opposite

/-- A presieve is *regular* if it consists of a single effective epimorphism. -/
class Presieve.regular {X : C} (R : Presieve X) : Prop where
  /-- `R` consists of a single epimorphism. -/
  single_epi : âˆƒ (Y : C) (f : Y âŸ¶ X), R = Presieve.ofArrows (fun (_ : Unit) â†¦ Y)
    (fun (_ : Unit) â†¦ f) âˆ§ EffectiveEpi f

/--
The map to the explicit equalizer used in the sheaf condition.
-/
def MapToEqualizer (P : Cáµ’áµ– â¥¤ Type (max u v)) {W X B : C} (f : X âŸ¶ B)
    (gâ‚ gâ‚‚ : W âŸ¶ X) (w : gâ‚ â‰« f = gâ‚‚ â‰« f) :
    P.obj (op B) â†’ { x : P.obj (op X) | P.map gâ‚.op x = P.map gâ‚‚.op x } :=
  fun t â†¦ âŸ¨P.map f.op t, by
    change (P.map _ â‰« P.map _) _ = (P.map _ â‰« P.map _) _;
    simp_rw [â† P.map_comp, â† op_comp, w] âŸ©

/--
The sheaf condition with respect to regular presieves, given the existence of the relavant pullback.
-/
def EqualizerCondition (P : Cáµ’áµ– â¥¤ Type (max u v)) : Prop :=
  âˆ€ (X B : C) (Ï€ : X âŸ¶ B) [EffectiveEpi Ï€] [HasPullback Ï€ Ï€], Function.Bijective
    (MapToEqualizer P Ï€ (pullback.fst (f := Ï€) (g := Ï€)) (pullback.snd (f := Ï€) (g := Ï€))
    pullback.condition)

/--
The `FirstObj`Â in the sheaf condition diagram is isomorphic to `F` applied to `X`.
-/
noncomputable
def EqualizerFirstObjIso (F : Cáµ’áµ– â¥¤ Type (max u v)) {B X : C} (Ï€ : X âŸ¶ B) :
    Equalizer.FirstObj F (Presieve.singleton Ï€) â‰… F.obj (op X) :=
  CategoryTheory.Equalizer.firstObjEqFamily F (Presieve.singleton Ï€) â‰ªâ‰«
  { hom := fun e â†¦ e Ï€ (Presieve.singleton_self Ï€)
    inv := fun e _ _ h â†¦ by
      induction h with
      | mk => exact e
    hom_inv_id := by
      funext _ _ _ h
      induction h with
      | mk => rfl
    inv_hom_id := by aesop }

instance {B X : C} (Ï€ : X âŸ¶ B) [EffectiveEpi Ï€] [HasPullback Ï€ Ï€] :
    (Presieve.singleton Ï€).hasPullbacks where
  has_pullbacks hf _ hg := by
    cases hf
    cases hg
    infer_instance

/--
The `SecondObj`Â in the sheaf condition diagram is isomorphic to `F`Â applied to the pullback of `Ï€`Â 
with itself
-/
noncomputable
def EqualizerSecondObjIso (F : Cáµ’áµ– â¥¤ Type (max u v)) {B X : C} (Ï€ : X âŸ¶ B) [EffectiveEpi Ï€]
    [HasPullback Ï€ Ï€] :
    Equalizer.Presieve.SecondObj F (Presieve.singleton Ï€) â‰… F.obj (op (Limits.pullback Ï€ Ï€)) :=
  Types.productIso.{max u v, max u v} _ â‰ªâ‰«
  { hom := fun e â†¦ e (âŸ¨X, âŸ¨Ï€, Presieve.singleton_self Ï€âŸ©âŸ©, âŸ¨X, âŸ¨Ï€, Presieve.singleton_self Ï€âŸ©âŸ©)
    inv := fun x âŸ¨âŸ¨_, âŸ¨_, hâ‚âŸ©âŸ© , âŸ¨_, âŸ¨_, hâ‚‚âŸ©âŸ©âŸ© â†¦ by
      induction hâ‚
      induction hâ‚‚
      exact x
    hom_inv_id := by
      funext _ âŸ¨âŸ¨_, âŸ¨_, hâ‚âŸ©âŸ© , âŸ¨_, âŸ¨_, hâ‚‚âŸ©âŸ©âŸ©
      induction hâ‚
      induction hâ‚‚
      rfl
    inv_hom_id := by aesop }

lemma EqualizerCondition.isSheafFor {B : C} {S : Presieve B} [S.regular] [S.hasPullbacks]
    {F : Cáµ’áµ– â¥¤ Type (max u v)}
    (hFecs : EqualizerCondition F) : S.IsSheafFor F := by
  obtain âŸ¨X, Ï€, âŸ¨hS, Ï€surjâŸ©âŸ© := Presieve.regular.single_epi (R := S)
  rw [Presieve.ofArrows_pUnit] at hS
  haveI : (Presieve.singleton Ï€).hasPullbacks := by rw [â† hS]; infer_instance
  haveI : HasPullback Ï€ Ï€ :=
    Presieve.hasPullbacks.has_pullbacks (Presieve.singleton.mk) (Presieve.singleton.mk)
  subst hS
  rw [Equalizer.Presieve.sheaf_condition, Limits.Types.type_equalizer_iff_unique]
  intro y h
  specialize hFecs X B Ï€
  have hy : F.map (pullback.fst (f := Ï€) (g := Ï€)).op ((EqualizerFirstObjIso F Ï€).hom y) =
      F.map (pullback.snd (f := Ï€) (g := Ï€)).op ((EqualizerFirstObjIso F Ï€).hom y) :=
    calc
      _ = (Equalizer.Presieve.firstMap F (Presieve.singleton Ï€) â‰«
          (EqualizerSecondObjIso F Ï€).hom) y := by
          simp [EqualizerSecondObjIso, EqualizerFirstObjIso, Equalizer.Presieve.firstMap]
      _ = (Equalizer.Presieve.secondMap F (Presieve.singleton Ï€) â‰« (EqualizerSecondObjIso F Ï€).hom)
          y := by simp only [Equalizer.Presieve.SecondObj, types_comp_apply]; rw [h]
      _ = _ := by
          simp [EqualizerSecondObjIso, EqualizerFirstObjIso, Equalizer.Presieve.secondMap]
  obtain âŸ¨x, âŸ¨hxâ‚, hxâ‚‚âŸ©âŸ© : âˆƒ! x, F.map Ï€.op x = (EqualizerFirstObjIso F Ï€).hom y
  Â· rw [Function.bijective_iff_existsUnique] at hFecs
    specialize hFecs âŸ¨(EqualizerFirstObjIso F Ï€).hom y, hyâŸ©
    obtain âŸ¨x, âŸ¨hxâ‚, hxâ‚‚âŸ©âŸ© := hFecs
    refine âŸ¨x, âŸ¨Subtype.ext_iff.mp hxâ‚, ?_âŸ©âŸ©
    intros
    apply hxâ‚‚
    rwa [Subtype.ext_iff]
  have fork_comp : Equalizer.forkMap F (Presieve.singleton Ï€) â‰« (EqualizerFirstObjIso F Ï€).hom =
      F.map Ï€.op := by ext; simp [EqualizerFirstObjIso, Equalizer.forkMap]
  rw [â† fork_comp] at hxâ‚ hxâ‚‚
  refine âŸ¨x, âŸ¨?_, ?_âŸ©âŸ©
  Â· apply_fun (EqualizerFirstObjIso F Ï€).hom using injective_of_mono (EqualizerFirstObjIso F Ï€).hom
    exact hxâ‚
  Â· intro z hz
    apply_fun (EqualizerFirstObjIso F Ï€).hom at hz
    exact hxâ‚‚ z hz

lemma IsSheafForRegular.equalizerCondition {F : Cáµ’áµ– â¥¤ Type (max u v)}
    (hSF : âˆ€ {B : C} (S : Presieve B) [S.regular] [S.hasPullbacks], S.IsSheafFor F) :
    EqualizerCondition F := by
  intro X B Ï€ _ _
  haveI : (Presieve.singleton Ï€).regular :=
    âŸ¨X, Ï€, âŸ¨(Presieve.ofArrows_pUnit Ï€).symm, inferInstanceâŸ©âŸ©
  specialize hSF (Presieve.singleton Ï€)
  rw [Equalizer.Presieve.sheaf_condition, Limits.Types.type_equalizer_iff_unique] at hSF
  rw [Function.bijective_iff_existsUnique]
  intro âŸ¨b, hbâŸ©
  specialize hSF ((EqualizerFirstObjIso F Ï€).inv b) ?_
  Â· apply_fun (EqualizerSecondObjIso F Ï€).hom using injective_of_mono _
    calc
      _ = F.map (pullback.fst (f := Ï€) (g := Ï€)).op b := by
        simp only [Equalizer.Presieve.SecondObj, EqualizerSecondObjIso, Equalizer.Presieve.firstMap,
          EqualizerFirstObjIso, Iso.trans_inv, types_comp_apply, Equalizer.firstObjEqFamily_inv,
          Iso.trans_hom, Types.productIso_hom_comp_eval_apply, Types.Limit.lift_Ï€_apply', Fan.mk_pt,
          Fan.mk_Ï€_app]; rfl
      _ = F.map (pullback.snd (f := Ï€) (g := Ï€)).op b := hb
      _ = ((EqualizerFirstObjIso F Ï€).inv â‰« Equalizer.Presieve.secondMap F (Presieve.singleton Ï€) â‰«
        (EqualizerSecondObjIso F Ï€).hom) b := by
          simp only [EqualizerFirstObjIso, Iso.trans_inv, Equalizer.Presieve.SecondObj,
            Equalizer.Presieve.secondMap, EqualizerSecondObjIso, Iso.trans_hom,
            Types.productIso_hom_comp_eval, limit.lift_Ï€, Fan.mk_pt, Fan.mk_Ï€_app, types_comp_apply,
            Equalizer.firstObjEqFamily_inv, Types.Limit.lift_Ï€_apply']; rfl
  Â· obtain âŸ¨a, âŸ¨haâ‚, haâ‚‚âŸ©âŸ© := hSF
    refine âŸ¨a, âŸ¨?_, ?_âŸ©âŸ©
    Â· ext
      dsimp [MapToEqualizer]
      apply_fun (EqualizerFirstObjIso F Ï€).hom at haâ‚
      simp only [inv_hom_id_apply] at haâ‚
      rw [â† haâ‚]
      simp only [EqualizerFirstObjIso, Equalizer.forkMap, Iso.trans_hom, types_comp_apply,
        Equalizer.firstObjEqFamily_hom, Types.pi_lift_Ï€_apply]
    Â· intro y hy
      apply haâ‚‚
      apply_fun (EqualizerFirstObjIso F Ï€).hom using injective_of_mono _
      simp only [inv_hom_id_apply]
      simp only [MapToEqualizer, Set.mem_setOf_eq, Subtype.mk.injEq] at hy
      rw [â† hy]
      simp only [EqualizerFirstObjIso, Equalizer.forkMap, Iso.trans_hom, types_comp_apply,
        Equalizer.firstObjEqFamily_hom, Types.pi_lift_Ï€_apply]

lemma isSheafFor_regular_of_projective {X : C} (S : Presieve X) [S.regular] [Projective X]
    (F : Cáµ’áµ– â¥¤ Type (max u v)) : S.IsSheafFor F := by
  obtain âŸ¨Y, f, rfl, hfâŸ© := Presieve.regular.single_epi (R := S)
  let g := Projective.factorThru (ğŸ™ _) f
  have hfg : g â‰« f = ğŸ™ _ := by
    simp only [Projective.factorThru_comp]
  intro y hy
  refine' âŸ¨F.map g.op <| y f <| Presieve.ofArrows.mk (), fun Z h hZ => _, fun z hz => _âŸ©
  Â· cases' hZ with u
    have := hy (fâ‚ := f) (fâ‚‚ := f) (ğŸ™ Y) (f â‰« g) (Presieve.ofArrows.mk ())
        (Presieve.ofArrows.mk ()) ?_
    Â· rw [op_id, F.map_id, types_id_apply] at this
      rw [â† types_comp_apply (F.map g.op) (F.map f.op), â† F.map_comp, â† op_comp]
      exact this.symm
    Â· rw [Category.id_comp, Category.assoc, hfg, Category.comp_id]
  Â· have := congr_arg (F.map g.op) <| hz f (Presieve.ofArrows.mk ())
    rwa [â† types_comp_apply (F.map f.op) (F.map g.op), â† F.map_comp, â† op_comp, hfg, op_id,
      F.map_id, types_id_apply] at this

lemma isSheaf_iff_equalizerCondition (F : Cáµ’áµ– â¥¤ Type (max u v)) [Preregular C] [HasPullbacks C] :
    Presieve.IsSheaf (regularCoverage C).toGrothendieck F â†” EqualizerCondition F := by
  rw [Presieve.isSheaf_coverage]
  refine âŸ¨?_, ?_âŸ©
  Â· intro h
    apply IsSheafForRegular.equalizerCondition
    intro B S _ _
    apply h S
    obtain âŸ¨Y, f, rfl, _âŸ© := Presieve.regular.single_epi (R := S)
    use Y, f
  Â· intro h X S âŸ¨Y, f, hhâŸ©
    haveI : S.regular := âŸ¨Y, f, hhâŸ©
    exact h.isSheafFor

lemma isSheaf_of_projective (F : Cáµ’áµ– â¥¤ Type (max u v)) [Preregular C] [âˆ€ (X : C), Projective X] :
    Presieve.IsSheaf (regularCoverage C).toGrothendieck F := by
  rw [Presieve.isSheaf_coverage]
  intro X S âŸ¨Y, f, hhâŸ©
  haveI : S.regular := âŸ¨Y, f, hhâŸ©
  exact isSheafFor_regular_of_projective _ _

end RegularSheaves

end CategoryTheory
