/-
Copyright (c) 2023 Dagur Asgeirsson. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Dagur Asgeirsson, Filippo A. E. Nuccio, Riccardo Brasca
-/
import Mathlib.CategoryTheory.Extensive
import Mathlib.CategoryTheory.Preadditive.Projective
import Mathlib.CategoryTheory.Sites.Coherent
import Mathlib.CategoryTheory.Sites.Preserves
/-!

# The Regular and Extensive Coverages

This file defines two coverages on a category `C`.

The first one is called the *regular* coverage and for that to exist, the category `C` must satisfy
a condition called `Preregular C`. This means that effective epimorphisms can be "pulled back". The
covering sieves of this coverage are generated by presieves consisting of a single effective
epimorphism.

The second one is called the *extensive* coverage and for that to exist, the category `C` must
satisfy a condition called `FinitaryPreExtensive C`. This means `C` has finite coproducts and that
those are preserved by pullbacks. The covering sieves of this coverage are generated by presieves
consisting finitely many arrows that together induce an isomorphism from the coproduct to the
target. This condition is weaker than `FinitaryExtensive`, where in addition finite coproducts are
disjoint.

## Main results

* `instance : Precoherent C` given `Preregular C` and `FinitaryPreExtensive C`.

* `extensive_union_regular_generates_coherent`: the union of the regular and extensive coverages
  generates the coherent topology on `C` if `C` is precoherent, preextensive and preregular.

* `isSheaf_iff_equalizerCondition`:Â In a preregular category with pullbacks, the sheaves for the
  regular topology are precisely the presheaves satisfying an equaliser condition with respect to
  effective epimorphisms.

* `isSheaf_of_projective`: In a preregular category in which every object is projective, every
  presheaf is a sheaf for the regular topology.

* `isSheaf_iff_preservesFiniteProducts`: In a finitary extensive category, the sheaves for the
  extensive topology are precisely those preserving finite products.

-/

universe v u w

namespace CategoryTheory

open Limits

variable (C : Type u) [Category.{v} C]

/--
The condition `Preregular C` is property that effective epis can be "pulled back" along any
morphism. This is satisfied e.g. by categories that have pullbacks that preserve effective
epimorphisms (like `Profinite` and `CompHaus`), and categories where every object is projective
(like  `Stonean`).
-/
class Preregular : Prop where
  /--
  For `X`, `Y`, `Z`, `f`, `g` like in the diagram, where `g` is an effective epi, there exists
  an object `W`, an effective epi `h : W âŸ¶ X` and a morphism `i : W âŸ¶ Z` making the diagram
  commute.
  ```
  W --i-â†’ Z
  |       |
  h       g
  â†“       â†“
  X --f-â†’ Y
  ```
  -/
  exists_fac : âˆ€ {X Y Z : C} (f : X âŸ¶ Y) (g : Z âŸ¶ Y) [EffectiveEpi g],
    (âˆƒ (W : C) (h : W âŸ¶ X) (_ : EffectiveEpi h) (i : W âŸ¶ Z), i â‰« g = h â‰« f)

instance [Precoherent C] [HasFiniteCoproducts C] : Preregular C where
  exists_fac {X Y Z} f g _ := by
    have hp := Precoherent.pullback f PUnit (fun () â†¦ Z) (fun () â†¦ g)
    simp only [exists_const] at hp
    rw [â† effectiveEpi_iff_effectiveEpiFamily g] at hp
    obtain âŸ¨Î², _, Xâ‚‚, Ï€â‚‚, h, Î¹, hÎ¹âŸ© := hp inferInstance
    refine âŸ¨âˆ Xâ‚‚, Sigma.desc Ï€â‚‚, inferInstance, Sigma.desc Î¹, ?_âŸ©
    ext b
    simpa using hÎ¹ b

/--
The regular coverage on a regular category `C`.
-/
def regularCoverage [Preregular C] : Coverage C where
  covering B := { S | âˆƒ (X : C) (f : X âŸ¶ B), S = Presieve.ofArrows (fun (_ : Unit) â†¦ X)
    (fun (_ : Unit) â†¦ f) âˆ§ EffectiveEpi f }
  pullback := by
    intro X Y f S âŸ¨Z, Ï€, hÏ€, h_epiâŸ©
    have := Preregular.exists_fac f Ï€
    obtain âŸ¨W, h, _, i, thisâŸ© := this
    refine âŸ¨Presieve.singleton h, âŸ¨?_, ?_âŸ©âŸ©
    Â· exact âŸ¨W, h, by {rw [Presieve.ofArrows_pUnit h]}, inferInstanceâŸ©
    Â· intro W g hg
      cases hg
      refine âŸ¨Z, i, Ï€, âŸ¨?_, thisâŸ©âŸ©
      cases hÏ€
      rw [Presieve.ofArrows_pUnit]
      exact Presieve.singleton.mk

/--
The extensive coverage on an extensive category `C`

TODO: use general colimit API instead of `IsIso (Sigma.desc Ï€)`
-/
def extensiveCoverage [FinitaryPreExtensive C] : Coverage C where
  covering B := { S | âˆƒ (Î± : Type) (_ : Fintype Î±) (X : Î± â†’ C) (Ï€ : (a : Î±) â†’ (X a âŸ¶ B)),
    S = Presieve.ofArrows X Ï€ âˆ§ IsIso (Sigma.desc Ï€) }
  pullback := by
    intro X Y f S âŸ¨Î±, hÎ±, Z, Ï€, hS, h_isoâŸ©
    let Z' : Î± â†’ C := fun a â†¦ pullback f (Ï€ a)
    let Ï€' : (a : Î±) â†’ Z' a âŸ¶ Y := fun a â†¦ pullback.fst
    refine âŸ¨@Presieve.ofArrows C _ _ Î± Z' Ï€', âŸ¨?_, ?_âŸ©âŸ©
    Â· constructor
      exact âŸ¨hÎ±, Z', Ï€', âŸ¨by simp only, FinitaryPreExtensive.sigma_desc_iso (fun x => Ï€ x) f h_isoâŸ©âŸ©
    Â· intro W g hg
      rcases hg with âŸ¨aâŸ©
      refine âŸ¨Z a, pullback.snd, Ï€ a, ?_, by rw [CategoryTheory.Limits.pullback.condition]âŸ©
      rw [hS]
      exact Presieve.ofArrows.mk a

theorem effectiveEpi_desc_iff_effectiveEpiFamily [FinitaryPreExtensive C] {Î± : Type} [Fintype Î±]
    {B : C} (X : Î± â†’ C) (Ï€ : (a : Î±) â†’ X a âŸ¶ B) :
    EffectiveEpi (Sigma.desc Ï€) â†” EffectiveEpiFamily X Ï€ := by
  exact âŸ¨fun h â†¦ âŸ¨âŸ¨@effectiveEpiFamilyStructOfEffectiveEpiDesc _ _ _ _ X Ï€ _ h _ _ (fun g â†¦
    (FinitaryPreExtensive.sigma_desc_iso (fun a â†¦ Sigma.Î¹ X a) g inferInstance).epi_of_iso)âŸ©âŸ©,
    fun _ â†¦ inferInstanceâŸ©

instance [FinitaryPreExtensive C] [Preregular C] : Precoherent C where
  pullback {Bâ‚ Bâ‚‚} f Î± _ Xâ‚ Ï€â‚ h := by
    refine âŸ¨Î±, inferInstance, ?_âŸ©
    obtain âŸ¨Y, g, _, g', hgâŸ© := Preregular.exists_fac f (Sigma.desc Ï€â‚)
    let Xâ‚‚ := fun a â†¦ pullback g' (Sigma.Î¹ Xâ‚ a)
    let Ï€â‚‚ := fun a â†¦ pullback.fst (f := g') (g := Sigma.Î¹ Xâ‚ a) â‰« g
    let Ï€' := fun a â†¦ pullback.fst (f := g') (g := Sigma.Î¹ Xâ‚ a)
    have _ := FinitaryPreExtensive.sigma_desc_iso (fun a â†¦ Sigma.Î¹ Xâ‚ a) g' inferInstance
    refine âŸ¨Xâ‚‚, Ï€â‚‚, ?_, ?_âŸ©
    Â· have : (Sigma.desc Ï€' â‰« g) = Sigma.desc Ï€â‚‚ := by ext; simp
      rw [â† effectiveEpi_desc_iff_effectiveEpiFamily, â† this]
      infer_instance
    Â· refine âŸ¨id, fun b â†¦ pullback.snd, fun b â†¦ ?_âŸ©
      simp only [id_eq, Category.assoc, â† hg]
      rw [â† Category.assoc, pullback.condition]
      simp

/-- The union of the extensive and regular coverages generates the coherent topology on `C`. -/
lemma extensive_regular_generate_coherent [Preregular C] [FinitaryPreExtensive C] :
    ((extensiveCoverage C) âŠ” (regularCoverage C)).toGrothendieck =
    (coherentTopology C) := by
  ext B S
  refine âŸ¨fun h â†¦ ?_, fun h â†¦ ?_âŸ©
  Â· induction h with
    | of Y T hT =>
      apply Coverage.saturate.of
      simp only [Coverage.sup_covering, Set.mem_union] at hT
      exact Or.elim hT
        (fun âŸ¨Î±, x, X, Ï€, âŸ¨h, _âŸ©âŸ© â†¦ âŸ¨Î±, x, X, Ï€, âŸ¨h, inferInstanceâŸ©âŸ©)
        (fun âŸ¨Z, f, âŸ¨h, _âŸ©âŸ© â†¦ âŸ¨Unit, inferInstance, fun _ â†¦ Z, fun _ â†¦ f, âŸ¨h, inferInstanceâŸ©âŸ©)
    | top => apply Coverage.saturate.top
    | transitive Y T => apply Coverage.saturate.transitive Y T<;> [assumption; assumption]
  Â· induction h with
    | of Y T hT =>
      obtain âŸ¨I, hI, X, f, âŸ¨h, hTâŸ©âŸ© := hT
      let Ï† := fun (i : I) â†¦ Sigma.Î¹ X i
      let F := Sigma.desc f
      let Z := Sieve.generate T
      let Xs := (âˆ fun (i : I) => X i)
      let Zf := Sieve.generate (Presieve.ofArrows (fun (_ : Unit) â†¦ Xs) (fun (_ : Unit) â†¦ F))
      apply Coverage.saturate.transitive Y Zf
      Â· apply Coverage.saturate.of
        simp only [Coverage.sup_covering, extensiveCoverage, regularCoverage, Set.mem_union,
          Set.mem_setOf_eq]
        exact Or.inr âŸ¨Xs, F, âŸ¨rfl, inferInstanceâŸ©âŸ©
      Â· intro R g hZfg
        dsimp at hZfg
        rw [Presieve.ofArrows_pUnit] at hZfg
        obtain âŸ¨W, Ïˆ, Ïƒ, âŸ¨hW, hW'âŸ©âŸ© := hZfg
        induction hW
        rw [â† hW', Sieve.pullback_comp Z]
        suffices Sieve.pullback Ïˆ ((Sieve.pullback F) Z) âˆˆ GrothendieckTopology.sieves
          ((extensiveCoverage C) âŠ” (regularCoverage C)).toGrothendieck R by assumption
        apply GrothendieckTopology.pullback_stable'
        suffices Coverage.saturate ((extensiveCoverage C) âŠ” (regularCoverage C)) Xs
          (Z.pullback F) by assumption
        suffices : Sieve.generate (Presieve.ofArrows X Ï†) â‰¤ Z.pullback F
        Â· apply Coverage.saturate_of_superset _ this
          apply Coverage.saturate.of
          simp only [Coverage.sup_covering, extensiveCoverage, regularCoverage, Set.mem_union,
            Set.mem_setOf_eq]
          refine Or.inl âŸ¨I, hI, X, Ï†, âŸ¨rfl, ?_âŸ©âŸ©
          suffices Sigma.desc Ï† = ğŸ™ _ by rw [this]; infer_instance
          ext
          simp only [colimit.Î¹_desc, Cofan.mk_pt, Cofan.mk_Î¹_app, Category.comp_id]
        intro Q q hq
        simp only [Sieve.pullback_apply, Sieve.generate_apply]
        simp only [Sieve.generate_apply] at hq
        obtain âŸ¨E, e, r, hqâŸ© := hq
        refine' âŸ¨E, e, r â‰« F, âŸ¨_, _âŸ©âŸ©
        Â· rw [h]
          induction hq.1
          simp only [colimit.Î¹_desc, Cofan.mk_pt, Cofan.mk_Î¹_app]
          exact Presieve.ofArrows.mk _
        Â· rw [â† hq.2]
          simp only [Category.assoc]
    | top => apply Coverage.saturate.top
    | transitive Y T => apply Coverage.saturate.transitive Y T<;> [assumption; assumption]

section RegularSheaves

variable {C}

open Opposite Presieve

/-- A presieve is *regular* if it consists of a single effective epimorphism. -/
class Presieve.regular {X : C} (R : Presieve X) : Prop where
  /-- `R` consists of a single epimorphism. -/
  single_epi : âˆƒ (Y : C) (f : Y âŸ¶ X), R = Presieve.ofArrows (fun (_ : Unit) â†¦ Y)
    (fun (_ : Unit) â†¦ f) âˆ§ EffectiveEpi f

namespace regularCoverage

/--
The map to the explicit equalizer used in the sheaf condition.
-/
def MapToEqualizer (P : Cáµ’áµ– â¥¤ Type*) {W X B : C} (f : X âŸ¶ B)
    (gâ‚ gâ‚‚ : W âŸ¶ X) (w : gâ‚ â‰« f = gâ‚‚ â‰« f) :
    P.obj (op B) â†’ { x : P.obj (op X) | P.map gâ‚.op x = P.map gâ‚‚.op x } := fun t â†¦
  âŸ¨P.map f.op t, by simp only [Set.mem_setOf_eq, â† FunctorToTypes.map_comp_apply, â† op_comp, w]âŸ©

/--
The sheaf condition with respect to regular presieves, given the existence of the relavant pullback.
-/
def EqualizerCondition (P : Cáµ’áµ– â¥¤ Type*) : Prop :=
  âˆ€ (X B : C) (Ï€ : X âŸ¶ B) [EffectiveEpi Ï€] [HasPullback Ï€ Ï€], Function.Bijective
    (MapToEqualizer P Ï€ (pullback.fst (f := Ï€) (g := Ï€)) (pullback.snd (f := Ï€) (g := Ï€))
    pullback.condition)

theorem equalizerCondition_iff_bla_w (P : Cáµ’áµ– â¥¤ Type*) {X B : C} (Ï€ : X âŸ¶ B) [HasPullback Ï€ Ï€] :
    P.map Ï€.op â‰« P.map (pullback.fst (f := Ï€) (g := Ï€)).op =
      P.map Ï€.op â‰« P.map (pullback.snd).op := by
  simp only [â† Functor.map_comp, â† op_comp, pullback.condition]

-- theorem equalizerCondition_iff_bla (P : Cáµ’áµ– â¥¤ Type*) : EqualizerCondition P â†”
--     âˆ€ (X B : C) (Ï€ : X âŸ¶ B) [EffectiveEpi Ï€] [HasPullback Ï€ Ï€], Function.Bijective
--     (equalizer.lift (P.map Ï€.op) (equalizerCondition_iff_bla_w P Ï€)) := sorry

theorem equalizerCondition_iff_bla (P : Cáµ’áµ– â¥¤ Type*) : EqualizerCondition P â†”
    âˆ€ (X B : C) (Ï€ : X âŸ¶ B) [EffectiveEpi Ï€] [HasPullback Ï€ Ï€], IsIso
    (equalizer.lift (P.map Ï€.op) (equalizerCondition_iff_bla_w P Ï€)) := by
  unfold EqualizerCondition
  refine âŸ¨fun h X B Ï€ _ _ â†¦ ?_, fun h X B Ï€ _ _ â†¦ ?_âŸ©
  Â· specialize h X B Ï€
    rw [â† isIso_iff_bijective] at h
    sorry
  Â· specialize h X B Ï€
    sorry

@[simps]
noncomputable
def preservesPullbackIso {D : Type*} [Category D] (P : Cáµ’áµ– â¥¤ Type*) (F : D â¥¤ C)
    {X B : D} (Ï€ : X âŸ¶ B) [HasPullback Ï€ Ï€] [PreservesLimit (cospan Ï€ Ï€) F] :
    haveI := hasPullback_of_preservesPullback F Ï€ Ï€
    (equalizer (P.map (pullback.fst (f := (F.map Ï€)) (g := (F.map Ï€))).op)
      (P.map (pullback.snd).op)) â‰…
      equalizer ((F.op â‹™ P).map (pullback.fst (f := Ï€) (g := Ï€)).op)
        ((F.op â‹™ P).map pullback.snd.op) where
  hom := equalizer.lift (equalizer.Î¹ _ _) (by
    simp only [Functor.comp_obj, Functor.op_obj, unop_op, Functor.comp_map, Functor.op_map,
      Quiver.Hom.unop_op]
    haveI := hasPullback_of_preservesPullback F Ï€ Ï€
    have h := equalizer.condition (P.map (pullback.fst (f := (F.map Ï€)) (g := (F.map Ï€))).op)
      (P.map (pullback.snd).op)
    have hâ‚ := PreservesPullback.iso_hom_fst F Ï€ Ï€
    have hâ‚‚ := PreservesPullback.iso_hom_snd F Ï€ Ï€
    simp only [â† hâ‚, â† hâ‚‚, op_comp, Functor.map_comp, â† Category.assoc, h])
  inv := equalizer.lift (equalizer.Î¹ _ _) (by
    simp only [Functor.comp_obj, Functor.op_obj, unop_op, Functor.comp_map, Functor.op_map,
      Quiver.Hom.unop_op]
    haveI := hasPullback_of_preservesPullback F Ï€ Ï€
    have hâ‚ := PreservesPullback.iso_inv_fst F Ï€ Ï€
    have hâ‚‚ := PreservesPullback.iso_inv_snd F Ï€ Ï€
    simp only [â† hâ‚, â† hâ‚‚, op_comp, Functor.map_comp]
    rw [â† Category.assoc, equalizer.condition]
    rfl)
  hom_inv_id := by
    apply equalizer.hom_ext
    simp only [Functor.comp_obj, Functor.op_obj, unop_op, Functor.comp_map, Functor.op_map,
      Quiver.Hom.unop_op, Category.assoc, limit.lift_Ï€, op_comp, id_eq, eq_mpr_eq_cast, cast_eq,
      Fork.ofÎ¹_pt, Fork.ofÎ¹_Ï€_app, Category.id_comp]
    exact equalizer.lift_Î¹ _ _
  inv_hom_id := by
    apply equalizer.hom_ext
    simp only [Functor.comp_obj, Functor.op_obj, unop_op, Functor.comp_map, Functor.op_map,
      Quiver.Hom.unop_op, Category.assoc, Category.id_comp]
    erw [equalizer.lift_Î¹, equalizer.lift_Î¹]


  -- hom := pullback.lift pullback.fst pullback.snd (by
  --   simp only [Functor.comp_obj, Functor.op_obj, unop_op, Functor.comp_map, Functor.op_map,
  --     Quiver.Hom.unop_op]
  --   have := hasPullback_of_preservesPullback F Ï€ Ï€
  --   rw [â† PreservesPullback.iso_hom_fst F, â† PreservesPullback.iso_hom_snd F]
  --   simp only [op_comp, Functor.map_comp, â† Category.assoc, pullback.condition])
  -- inv := pullback.lift pullback.fst pullback.snd (by
  --   simp only [Functor.comp_obj, Functor.op_obj, unop_op, Functor.comp_map, Functor.op_map,
  --     Quiver.Hom.unop_op]
  --   have := hasPullback_of_preservesPullback F Ï€ Ï€
  --   rw [â† PreservesPullback.iso_inv_fst F Ï€ Ï€]
  --   simp only [op_comp, Functor.map_comp, â† Category.assoc, pullback.condition]
  --   rw [â† PreservesPullback.iso_inv_snd F Ï€ Ï€]
  --   simp only [op_comp, Functor.map_comp, â† Category.assoc, pullback.condition])
  -- hom_inv_id := by
  --   ext1
  --   Â· simp only [Functor.comp_obj, Functor.op_obj, unop_op, Functor.comp_map, Functor.op_map,
  --       Quiver.Hom.unop_op, Category.assoc, limit.lift_Ï€, op_comp, id_eq, eq_mpr_eq_cast,
  --       PullbackCone.mk_pt, PullbackCone.mk_Ï€_app, Category.id_comp]
  --     exact pullback.lift_fst _ _ _
  --   Â· simp only [Functor.comp_obj, Functor.op_obj, unop_op, Functor.comp_map, Functor.op_map,
  --       Quiver.Hom.unop_op, Category.assoc, limit.lift_Ï€, op_comp, id_eq, eq_mpr_eq_cast,
  --       PullbackCone.mk_pt, PullbackCone.mk_Ï€_app, Category.id_comp]
  --     exact pullback.lift_snd _ _ _
  -- inv_hom_id := by
  --   ext1
  --   Â· simp only [Functor.comp_obj, Functor.op_obj, unop_op, Functor.comp_map, Functor.op_map,
  --       Quiver.Hom.unop_op, Category.assoc, Category.id_comp]
  --     erw [pullback.lift_fst, pullback.lift_fst]
  --   Â· simp only [Functor.comp_obj, Functor.op_obj, unop_op, Functor.comp_map, Functor.op_map,
  --       Quiver.Hom.unop_op, Category.assoc, Category.id_comp]
  --     erw [pullback.lift_snd, pullback.lift_snd]

theorem mapToEqualizer_pullback_comp {D : Type*} [Category D] (P : Cáµ’áµ– â¥¤ Type*) (F : D â¥¤ C)
    {X B : D} (Ï€ : X âŸ¶ B) [HasPullback Ï€ Ï€] [PreservesLimit (cospan Ï€ Ï€) F] :
    haveI := hasPullback_of_preservesPullback F Ï€ Ï€
    (equalizer.lift ((F.op â‹™ P).map Ï€.op)
      (equalizerCondition_iff_bla_w (F.op â‹™ P) Ï€)) =
    (equalizer.lift (P.map (F.map Ï€).op)
      (equalizerCondition_iff_bla_w P (F.map Ï€))) â‰« (preservesPullbackIso P F Ï€).hom := by
  simp only [Functor.comp_obj, Functor.op_obj, unop_op, Functor.comp_map, Functor.op_map,
    Quiver.Hom.unop_op, preservesPullbackIso]
  apply equalizer.hom_ext
  simp only [Functor.comp_obj, Functor.op_obj, unop_op, Functor.comp_map, Functor.op_map,
    Quiver.Hom.unop_op, Category.assoc]
  erw [equalizer.lift_Î¹, equalizer.lift_Î¹, equalizer.lift_Î¹]

theorem equalizerCondition_precomp_of_preservesPullback {D : Type*} [Category D] (P : Cáµ’áµ– â¥¤ Type*)
    (F : D â¥¤ C)
    [âˆ€ {X B} (Ï€ : X âŸ¶ B) [EffectiveEpi Ï€], PreservesLimit (cospan Ï€ Ï€) F]
    [F.PreservesEffectiveEpis]
    (hP : EqualizerCondition P) : EqualizerCondition (F.op â‹™ P) := by
  rw [equalizerCondition_iff_bla] at hP âŠ¢
  intro X B Ï€ _ _
  have := hasPullback_of_preservesPullback F Ï€ Ï€
  have := hP (F.obj X) (F.obj B) (F.map Ï€)
  rw [mapToEqualizer_pullback_comp (F := F)]
  exact IsIso.comp_isIso

theorem equalizerCondition_of_natIso_aux
    {P : Cáµ’áµ– â¥¤ Type*} {P' : Cáµ’áµ– â¥¤ Type _} (i : P â‰… P') {X B : C} (Ï€ : X âŸ¶ B) [EffectiveEpi Ï€]
    [HasPullback Ï€ Ï€] :
    (equalizer.Î¹ (P.map (pullback.fst (f := Ï€) (g := Ï€)).op) (P.map pullback.snd.op) â‰«
      i.hom.app (op X)) â‰« P'.map pullback.fst.op =
      (equalizer.Î¹ (P.map pullback.fst.op) (P.map pullback.snd.op) â‰« i.hom.app (op X)) â‰«
      P'.map (pullback.snd  (f := Ï€) (g := Ï€)).op := by
  rw [Category.assoc, Category.assoc, â† i.hom.naturality (pullback.fst (f := Ï€) (g := Ï€)).op,
    â† i.hom.naturality (pullback.snd (f := Ï€) (g := Ï€)).op, â† Category.assoc, equalizer.condition]
  simp

theorem equalizerCondition_of_natIso {P : Cáµ’áµ– â¥¤ Type*} {P' : Cáµ’áµ– â¥¤ Type _} (i : P â‰… P')
    (hP : EqualizerCondition P) :
    EqualizerCondition P' := by
  rw [equalizerCondition_iff_bla] at hP âŠ¢
  intro X B Ï€ _ _
  specialize hP X B Ï€
  have h : equalizer.lift (P'.map Ï€.op) (equalizerCondition_iff_bla_w P' Ï€) =
      i.inv.app (op B) â‰«
      equalizer.lift (P.map Ï€.op) (equalizerCondition_iff_bla_w P Ï€) â‰«
      equalizer.lift (equalizer.Î¹ _ _ â‰« i.hom.app (op X))
      (equalizerCondition_of_natIso_aux i Ï€) := by
    apply equalizer.hom_ext
    simp
  rw [h]
  sorry -- infer_instance

theorem equalizerCondition_of_isEquivalence {D : Type*} [Category D] (P : Cáµ’áµ– â¥¤ Type*)
    (e : C â‰Œ D) : EqualizerCondition P â†” EqualizerCondition (e.op.inverse â‹™ P) :=
  âŸ¨fun h â†¦ equalizerCondition_precomp_of_preservesPullback P e.inverse h, fun h â†¦
    equalizerCondition_of_natIso (e.op.funInvIdAssoc P)
      (equalizerCondition_precomp_of_preservesPullback (e.op.inverse â‹™ P) e.functor h)âŸ©

lemma EqualizerCondition.isSheafFor {B : C} {S : Presieve B} [S.regular] [S.hasPullbacks]
    {F : Cáµ’áµ– â¥¤ Type*}
    (hF : EqualizerCondition F) : S.IsSheafFor F := by
  obtain âŸ¨X, Ï€, hS, Ï€surjâŸ© := Presieve.regular.single_epi (R := S)
  subst hS
  rw [isSheafFor_arrows_iff_pullbacks]
  intro y h
  have : (Presieve.singleton Ï€).hasPullbacks := by rw [â† ofArrows_pUnit]; infer_instance
  have : HasPullback Ï€ Ï€ := hasPullbacks.has_pullbacks Presieve.singleton.mk Presieve.singleton.mk
  specialize hF X B Ï€
  rw [Function.bijective_iff_existsUnique] at hF
  obtain âŸ¨t, ht, ht'âŸ© := hF âŸ¨y (), h () ()âŸ©
  refine âŸ¨t, fun _ â†¦ ?_, fun x h â†¦ ht' x ?_âŸ©
  Â· simpa [MapToEqualizer] using ht
  Â· simpa [MapToEqualizer] using h ()

lemma equalizerCondition_of_regular {F : Cáµ’áµ– â¥¤ Type*}
    (hSF : âˆ€ {B : C} (S : Presieve B) [S.regular] [S.hasPullbacks], S.IsSheafFor F) :
    EqualizerCondition F := by
  intro X B Ï€ _ _
  have : (ofArrows (fun _ â†¦ X) (fun _ â†¦ Ï€)).regular := âŸ¨X, Ï€, rfl, inferInstanceâŸ©
  have : (ofArrows (fun () â†¦ X) (fun _ â†¦ Ï€)).hasPullbacks := âŸ¨
      fun hf _ hg â†¦ (by cases hf; cases hg; infer_instance)âŸ©
  specialize hSF (ofArrows (fun () â†¦ X) (fun _ â†¦ Ï€))
  rw [isSheafFor_arrows_iff_pullbacks] at hSF
  rw [Function.bijective_iff_existsUnique]
  intro âŸ¨x, hxâŸ©
  obtain âŸ¨t, ht, ht'âŸ© := hSF (fun _ â†¦ x) (fun _ _ â†¦ hx)
  refine âŸ¨t, ?_, fun y h â†¦ ht' y ?_âŸ©
  Â· simpa [MapToEqualizer] using ht ()
  Â· simpa [MapToEqualizer] using h

lemma isSheafFor_regular_of_projective {X : C} (S : Presieve X) [S.regular] [Projective X]
    (F : Cáµ’áµ– â¥¤ Type*) : S.IsSheafFor F := by
  obtain âŸ¨Y, f, rfl, hfâŸ© := Presieve.regular.single_epi (R := S)
  rw [isSheafFor_arrows_iff]
  refine fun x hx â†¦ âŸ¨F.map (Projective.factorThru (ğŸ™ _) f).op <| x (), fun _ â†¦ ?_, fun y h â†¦ ?_âŸ©
  Â· simpa using (hx () () Y (ğŸ™ Y) (f â‰« (Projective.factorThru (ğŸ™ _) f)) (by simp)).symm
  Â· simp only [â† h (), â† FunctorToTypes.map_comp_apply, â† op_comp, Projective.factorThru_comp,
      op_id, FunctorToTypes.map_id_apply]

lemma EqualizerCondition.isSheaf_iff (F : Cáµ’áµ– â¥¤ Type*)
    [âˆ€ â¦ƒX Y : Câ¦„ (Ï€ : X âŸ¶ Y) [EffectiveEpi Ï€], HasPullback Ï€ Ï€] [Preregular C] :
    Presieve.IsSheaf (regularCoverage C).toGrothendieck F â†” EqualizerCondition F := by
  rw [Presieve.isSheaf_coverage]
  refine âŸ¨fun h â†¦ equalizerCondition_of_regular fun S âŸ¨Y, f, hhâŸ© _ â†¦ h S âŸ¨Y, f, hhâŸ©, ?_âŸ©
  rintro h X S âŸ¨Y, f, rfl, hfâŸ©
  exact @isSheafFor _ _ _ _ âŸ¨Y, f, rfl, hfâŸ© âŸ¨fun g _ h â†¦ by cases g; cases h; infer_instanceâŸ© _ h

lemma isSheaf_of_projective (F : Cáµ’áµ– â¥¤ Type*) [Preregular C] [âˆ€ (X : C), Projective X] :
    IsSheaf (regularCoverage C).toGrothendieck F :=
  (isSheaf_coverage _ _).mpr fun S âŸ¨_, hâŸ© â†¦ have : S.regular := âŸ¨_, hâŸ©
    isSheafFor_regular_of_projective _ _

/-- Every Yoneda-presheaf is a sheaf for the regular topology. -/
theorem isSheaf_yoneda_obj [Preregular C] (W : C)  :
    Presieve.IsSheaf (regularCoverage C).toGrothendieck (yoneda.obj W) := by
  rw [isSheaf_coverage]
  intro X S âŸ¨_, hSâŸ©
  have : S.regular := âŸ¨_, hSâŸ©
  obtain âŸ¨Y, f, rfl, hfâŸ© := Presieve.regular.single_epi (R := S)
  have h_colim := isColimitOfEffectiveEpiStruct f hf.effectiveEpi.some
  rw [â† Sieve.generateSingleton_eq, â† Presieve.ofArrows_pUnit] at h_colim
  intro x hx
  let x_ext := Presieve.FamilyOfElements.sieveExtend x
  have hx_ext := Presieve.FamilyOfElements.Compatible.sieveExtend hx
  let S := Sieve.generate (Presieve.ofArrows (fun () â†¦ Y) (fun () â†¦ f))
  obtain âŸ¨t, t_amalg, t_uniqâŸ© :=
    (Sieve.forallYonedaIsSheaf_iff_colimit S).mpr âŸ¨h_colimâŸ© W x_ext hx_ext
  refine âŸ¨t, ?_, ?_âŸ©
  Â· convert Presieve.isAmalgamation_restrict (Sieve.le_generate
      (Presieve.ofArrows (fun () â†¦ Y) (fun () â†¦ f))) _ _ t_amalg
    exact (Presieve.restrict_extend hx).symm
  Â· exact fun y hy â†¦ t_uniq y <| Presieve.isAmalgamation_sieveExtend x y hy

/-- The regular topology on any preregular category is subcanonical. -/
theorem subcanonical [Preregular C] : Sheaf.Subcanonical (regularCoverage C).toGrothendieck :=
  Sheaf.Subcanonical.of_yoneda_isSheaf _ isSheaf_yoneda_obj

end regularCoverage

end RegularSheaves

section ExtensiveSheaves

variable [FinitaryPreExtensive C] {C}

/-- A presieve is *extensive* if it is finite and its arrows induce an isomorphism from the
coproduct to the target. -/
class Presieve.extensive {X : C} (R : Presieve X) :
    Prop where
  /-- `R` consists of a finite collection of arrows that together induce an isomorphism from the
  coproduct of their sources. -/
  arrows_nonempty_isColimit : âˆƒ (Î± : Type) (_ : Fintype Î±) (Z : Î± â†’ C) (Ï€ : (a : Î±) â†’ (Z a âŸ¶ X)),
    R = Presieve.ofArrows Z Ï€ âˆ§ Nonempty (IsColimit (Cofan.mk X Ï€))

instance {X : C} (S : Presieve X) [S.extensive] : S.hasPullbacks where
  has_pullbacks := by
    obtain âŸ¨_, _, _, _, rfl, âŸ¨hcâŸ©âŸ© := Presieve.extensive.arrows_nonempty_isColimit (R := S)
    intro _ _ _ _ _ hg
    cases hg
    apply FinitaryPreExtensive.hasPullbacks_of_is_coproduct hc

instance {Î± : Type} [Fintype Î±] {Z : Î± â†’ C} {F : C â¥¤ Type w}
    [PreservesFiniteProducts F] : PreservesLimit (Discrete.functor fun a => (Z a)) F :=
  (PreservesFiniteProducts.preserves Î±).preservesLimit

open Presieve Opposite

/--
A finite product preserving presheaf is a sheaf for the extensive topology on a category which is
`FinitaryPreExtensive`.
-/
theorem isSheafFor_extensive_of_preservesFiniteProducts {X : C} (S : Presieve X) [S.extensive]
    (F : Cáµ’áµ– â¥¤ Type max u v) [PreservesFiniteProducts F] : S.IsSheafFor F  := by
  obtain âŸ¨_, _, Z, Ï€, rfl, âŸ¨hcâŸ©âŸ© := extensive.arrows_nonempty_isColimit (R := S)
  have : (ofArrows Z (Cofan.mk X Ï€).inj).hasPullbacks :=
    (inferInstance : (ofArrows Z Ï€).hasPullbacks)
  exact isSheafFor_of_preservesProduct _ _ hc

instance {Î± : Type} [Fintype Î±] (Z : Î± â†’ C) : (ofArrows Z (fun i â†¦ Sigma.Î¹ Z i)).extensive :=
  âŸ¨âŸ¨Î±, inferInstance, Z, (fun i â†¦ Sigma.Î¹ Z i), rfl, âŸ¨coproductIsCoproduct _âŸ©âŸ©âŸ©

/--
A presheaf on a category which is `FinitaryExtensive`Â is a sheaf iff it preserves finite products.
-/
theorem isSheaf_iff_preservesFiniteProducts [FinitaryExtensive C] (F : Cáµ’áµ– â¥¤ Type max u v) :
    Presieve.IsSheaf (extensiveCoverage C).toGrothendieck F â†”
    Nonempty (PreservesFiniteProducts F) := by
  refine âŸ¨fun hF â†¦ âŸ¨âŸ¨fun Î± _ â†¦ âŸ¨fun {K} â†¦ ?_âŸ©âŸ©âŸ©, fun hF â†¦ ?_âŸ©
  Â· rw [Presieve.isSheaf_coverage] at hF
    let Z : Î± â†’ C := fun i â†¦ unop (K.obj âŸ¨iâŸ©)
    have : (Presieve.ofArrows Z (Cofan.mk (âˆ Z) (Sigma.Î¹ Z)).inj).hasPullbacks :=
      (inferInstance : (Presieve.ofArrows Z (Sigma.Î¹ Z)).hasPullbacks)
    have : âˆ€ (i : Î±), Mono (Cofan.inj (Cofan.mk (âˆ Z) (Sigma.Î¹ Z)) i) :=
      (inferInstance : âˆ€ (i : Î±), Mono (Sigma.Î¹ Z i))
    let i : K â‰… Discrete.functor (fun i â†¦ op (Z i)) := Discrete.natIsoFunctor
    let _ : PreservesLimit (Discrete.functor (fun i â†¦ op (Z i))) F :=
        Presieve.preservesProductOfIsSheafFor F ?_ initialIsInitial _ (coproductIsCoproduct Z)
        (FinitaryExtensive.isPullback_initial_to_sigma_Î¹ Z)
        (hF (Presieve.ofArrows Z (fun i â†¦ Sigma.Î¹ Z i)) ?_)
    Â· exact preservesLimitOfIsoDiagram F i.symm
    Â· apply hF
      refine âŸ¨Empty, inferInstance, Empty.elim, IsEmpty.elim inferInstance, rfl, âŸ¨default,?_, ?_âŸ©âŸ©
      Â· ext b
        cases b
      Â· simp only [eq_iff_true_of_subsingleton]
    Â· refine âŸ¨Î±, inferInstance, Z, (fun i â†¦ Sigma.Î¹ Z i), rfl, ?_âŸ©
      suffices Sigma.desc (fun i â†¦ Sigma.Î¹ Z i) = ğŸ™ _ by rw [this]; infer_instance
      ext
      simp
  Â· let _ := hF.some
    rw [Presieve.isSheaf_coverage]
    intro X R âŸ¨Y, Î±, Z, Ï€, hR, hiâŸ©
    have : IsIso (Sigma.desc (Cofan.inj (Cofan.mk X Ï€))) := hi
    have : R.extensive := âŸ¨Y, Î±, Z, Ï€, hR, âŸ¨Cofan.isColimitOfIsIsoSigmaDesc (Cofan.mk X Ï€)âŸ©âŸ©
    exact isSheafFor_extensive_of_preservesFiniteProducts R F

end ExtensiveSheaves

end CategoryTheory
