/-
Copyright (c) 2023 Adam Topaz. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Adam Topaz
-/
import Mathlib.CategoryTheory.Sites.Sieves
import Mathlib.CategoryTheory.EffectiveEpi.Basic
/-!

# Effective epimorphic sieves

We define the notion of effective epimorphic (pre)sieves and provide some API for relating the
notion with the notions of effective epimorphism and effective epimorphic family.

More precisely, if `f` is a morphism, then `f` is an effective epi if and only if the sieve
it generates is effective epimorphic; see `CategoryTheory.Sieve.effectiveEpimorphic_singleton`.
The analogous statement for a family of morphisms is in the theorem
`CategoryTheory.Sieve.effectiveEpimorphic_family`.

-/

namespace CategoryTheory

open Limits

variable {C : Type*} [Category C]

/-- A sieve is effective epimorphic if the associated cocone is a colimit cocone. -/
def Sieve.EffectiveEpimorphic {X : C} (S : Sieve X) : Prop :=
  Nonempty (IsColimit (S : Presieve X).cocone)

/-- A presieve is effective epimorphic if the cocone associated to the sieve it generates
is a colimit cocone. -/
abbrev Presieve.EffectiveEpimorphic {X : C} (S : Presieve X) : Prop :=
  (Sieve.generate S).EffectiveEpimorphic

/--
The sieve of morphisms which factor through a given morphism `f`.
This is equal to `Sieve.generate (Presieve.singleton f)`, but has
more convenient definitional properties.
-/
def Sieve.generateSingleton {X Y : C} (f : Y âŸ¶ X) : Sieve X where
  arrows Z := { g | âˆƒ (e : Z âŸ¶ Y), e â‰« f = g }
  downward_closed := by
    rintro W Z g âŸ¨e,rflâŸ© q
    exact âŸ¨q â‰« e, by simpâŸ©

lemma Sieve.generateSingleton_eq {X Y : C} (f : Y âŸ¶ X) :
    Sieve.generate (Presieve.singleton f) = Sieve.generateSingleton f := by
  ext Z g
  constructor
  Â· rintro âŸ¨W,i,p,âŸ¨âŸ©,rflâŸ©
    exact âŸ¨i,rflâŸ©
  Â· rintro âŸ¨g,hâŸ©
    exact âŸ¨Y,g,f,âŸ¨âŸ©,hâŸ©

/--
Implementation: This is a construction which will be used in the proof that
the sieve generated by a single arrow is effective epimorphic if and only if
the arrow is an effective epi.
-/
def isColimitOfEffectiveEpiStruct {X Y : C} (f : Y âŸ¶ X) (Hf : EffectiveEpiStruct f) :
    IsColimit (Sieve.generateSingleton f : Presieve X).cocone :=
  letI D := ObjectProperty.FullSubcategory fun T : Over X => Sieve.generateSingleton f T.hom
  letI F : D â¥¤ _ := (Sieve.generateSingleton f).arrows.diagram
  { desc := fun S => Hf.desc (S.Î¹.app âŸ¨Over.mk f, âŸ¨ğŸ™ _, by simpâŸ©âŸ©) <| by
      intro Z gâ‚ gâ‚‚ h
      let Y' : D := âŸ¨Over.mk f, ğŸ™ _, by simpâŸ©
      let Z' : D := âŸ¨Over.mk (gâ‚ â‰« f), gâ‚, rflâŸ©
      let gâ‚' : Z' âŸ¶ Y' := Over.homMk gâ‚
      let gâ‚‚' : Z' âŸ¶ Y' := Over.homMk gâ‚‚ (by simp [Y', Z', h])
      change F.map gâ‚' â‰« _ = F.map gâ‚‚' â‰« _
      simp only [Y', F, S.w]
    fac := by
      rintro S âŸ¨T,g,hTâŸ©
      dsimp
      nth_rewrite 1 [â† hT, Category.assoc, Hf.fac]
      let y : D := âŸ¨Over.mk f, ğŸ™ _, by simpâŸ©
      let x : D := âŸ¨Over.mk T.hom, g, hTâŸ©
      let g' : x âŸ¶ y := Over.homMk g
      change F.map g' â‰« _ = _
      rw [S.w]
      rfl
    uniq := by
      intro S m hm
      dsimp
      generalize_proofs h1 h2
      apply Hf.uniq _ h2
      exact hm âŸ¨Over.mk f, ğŸ™ _, by simpâŸ© }

/--
Implementation: This is a construction which will be used in the proof that
the sieve generated by a single arrow is effective epimorphic if and only if
the arrow is an effective epi.
-/
noncomputable
def effectiveEpiStructOfIsColimit {X Y : C} (f : Y âŸ¶ X)
    (Hf : IsColimit (Sieve.generateSingleton f : Presieve X).cocone) :
    EffectiveEpiStruct f :=
  let aux {W : C} (e : Y âŸ¶ W)
    (h : âˆ€ {Z : C} (gâ‚ gâ‚‚ : Z âŸ¶ Y), gâ‚ â‰« f = gâ‚‚ â‰« f â†’ gâ‚ â‰« e = gâ‚‚ â‰« e) :
    Cocone (Sieve.generateSingleton f).arrows.diagram :=
    { pt := W
      Î¹ := {
        app := fun âŸ¨_,hTâŸ© => hT.choose â‰« e
        naturality := by
          rintro âŸ¨A,hAâŸ© âŸ¨B,hBâŸ© (q : A âŸ¶ B)
          dsimp; simp only [â† Category.assoc, Category.comp_id]
          apply h
          rw [Category.assoc, hB.choose_spec, hA.choose_spec, Over.w] } }
  { desc := fun {_} e h => Hf.desc (aux e h)
    fac := by
      intro W e h
      dsimp
      have := Hf.fac (aux e h) âŸ¨Over.mk f, ğŸ™ _, by simpâŸ©
      dsimp [aux] at this; rw [this]; clear this
      nth_rewrite 2 [â† Category.id_comp e]
      apply h
      generalize_proofs hh
      rw [hh.choose_spec, Category.id_comp]
    uniq := by
      intro W e h m hm
      dsimp
      apply Hf.uniq (aux e h)
      rintro âŸ¨A,g,hAâŸ©
      dsimp
      nth_rewrite 1 [â† hA, Category.assoc, hm]
      apply h
      generalize_proofs hh
      rwa [hh.choose_spec] }

theorem Sieve.effectiveEpimorphic_singleton {X Y : C} (f : Y âŸ¶ X) :
    (Presieve.singleton f).EffectiveEpimorphic â†” (EffectiveEpi f) := by
  constructor
  Â· intro (h : Nonempty _)
    rw [Sieve.generateSingleton_eq] at h
    constructor
    apply Nonempty.map (effectiveEpiStructOfIsColimit _) h
  Â· rintro âŸ¨hâŸ©
    change Nonempty _
    rw [Sieve.generateSingleton_eq]
    apply Nonempty.map (isColimitOfEffectiveEpiStruct _) h

/--
The sieve of morphisms which factor through a morphism in a given family.
This is equal to `Sieve.generate (Presieve.ofArrows X Ï€)`, but has
more convenient definitional properties.
-/
def Sieve.generateFamily {B : C} {Î± : Type*} (X : Î± â†’ C) (Ï€ : (a : Î±) â†’ (X a âŸ¶ B)) :
    Sieve B where
  arrows Y := { f | âˆƒ (a : Î±) (g : Y âŸ¶ X a), g â‰« Ï€ a = f }
  downward_closed := by
    rintro Yâ‚ Yâ‚‚ gâ‚ âŸ¨a,q,rflâŸ© e
    exact âŸ¨a, e â‰« q, by simpâŸ©

lemma Sieve.generateFamily_eq {B : C} {Î± : Type*} (X : Î± â†’ C) (Ï€ : (a : Î±) â†’ (X a âŸ¶ B)) :
    Sieve.generate (Presieve.ofArrows X Ï€) = Sieve.generateFamily X Ï€ := by
  ext Y g
  constructor
  Â· rintro âŸ¨W, g, f, âŸ¨aâŸ©, rflâŸ©
    exact âŸ¨a, g, rflâŸ©
  Â· rintro âŸ¨a, g, rflâŸ©
    exact âŸ¨_, g, Ï€ a, âŸ¨aâŸ©, rflâŸ©

/--
Implementation: This is a construction which will be used in the proof that
the sieve generated by a family of arrows is effective epimorphic if and only if
the family is an effective epi.
-/
def isColimitOfEffectiveEpiFamilyStruct {B : C} {Î± : Type*}
    (X : Î± â†’ C) (Ï€ : (a : Î±) â†’ (X a âŸ¶ B)) (H : EffectiveEpiFamilyStruct X Ï€) :
    IsColimit (Sieve.generateFamily X Ï€ : Presieve B).cocone :=
  letI D := ObjectProperty.FullSubcategory fun T : Over B => Sieve.generateFamily X Ï€ T.hom
  letI F : D â¥¤ _ := (Sieve.generateFamily X Ï€).arrows.diagram
  { desc := fun S => H.desc (fun a => S.Î¹.app âŸ¨Over.mk (Ï€ a), âŸ¨a,ğŸ™ _, by simpâŸ©âŸ©) <| by
      intro Z aâ‚ aâ‚‚ gâ‚ gâ‚‚ h
      dsimp
      let Aâ‚ : D := âŸ¨Over.mk (Ï€ aâ‚), aâ‚, ğŸ™ _, by simpâŸ©
      let Aâ‚‚ : D := âŸ¨Over.mk (Ï€ aâ‚‚), aâ‚‚, ğŸ™ _, by simpâŸ©
      let Z' : D := âŸ¨Over.mk (gâ‚ â‰« Ï€ aâ‚), aâ‚, gâ‚, rflâŸ©
      let iâ‚ : Z' âŸ¶ Aâ‚ := Over.homMk gâ‚
      let iâ‚‚ : Z' âŸ¶ Aâ‚‚ := Over.homMk gâ‚‚
      change F.map iâ‚ â‰« _ = F.map iâ‚‚ â‰« _
      simp only [F, Aâ‚, Aâ‚‚, S.w]
    fac := by
      intro S âŸ¨T, a, (g : T.left âŸ¶ X a), hTâŸ©
      dsimp
      nth_rewrite 1 [â† hT, Category.assoc, H.fac]
      let A : D := âŸ¨Over.mk (Ï€ a), a, ğŸ™ _, by simpâŸ©
      let B : D := âŸ¨Over.mk T.hom, a, g, hTâŸ©
      let i : B âŸ¶ A := Over.homMk g
      change F.map i â‰« _ = _
      rw [S.w]
      rfl
    uniq := by
      intro S m hm; dsimp
      apply H.uniq
      intro a
      exact hm âŸ¨Over.mk (Ï€ a), a, ğŸ™ _, by simpâŸ© }

/--
Implementation: This is a construction which will be used in the proof that
the sieve generated by a family of arrows is effective epimorphic if and only if
the family is an effective epi.
-/
noncomputable
def effectiveEpiFamilyStructOfIsColimit {B : C} {Î± : Type*}
    (X : Î± â†’ C) (Ï€ : (a : Î±) â†’ (X a âŸ¶ B))
    (H : IsColimit (Sieve.generateFamily X Ï€ : Presieve B).cocone) :
    EffectiveEpiFamilyStruct X Ï€ :=
  let aux {W : C} (e : (a : Î±) â†’ (X a âŸ¶ W))
    (h : âˆ€ {Z : C} (aâ‚ aâ‚‚ : Î±) (gâ‚ : Z âŸ¶ X aâ‚) (gâ‚‚ : Z âŸ¶ X aâ‚‚),
      gâ‚ â‰« Ï€ _ = gâ‚‚ â‰« Ï€ _ â†’ gâ‚ â‰« e _ = gâ‚‚ â‰« e _) :
    Cocone (Sieve.generateFamily X Ï€).arrows.diagram := {
      pt := W
      Î¹ := {
        app := fun âŸ¨_,hTâŸ© => hT.choose_spec.choose â‰« e hT.choose
        naturality := by
          intro âŸ¨A,a,(gâ‚ : A.left âŸ¶ _),haâŸ© âŸ¨B,b,(gâ‚‚ : B.left âŸ¶ _),hbâŸ© (q : A âŸ¶ B)
          dsimp; rw [Category.comp_id, â† Category.assoc]
          apply h; rw [Category.assoc]
          generalize_proofs h1 h2 h3 h4
          rw [h2.choose_spec, h4.choose_spec, Over.w] } }
  { desc := fun {_} e h => H.desc (aux e h)
    fac := by
      intro W e h a
      dsimp
      have := H.fac (aux e h) âŸ¨Over.mk (Ï€ a), a, ğŸ™ _, by simpâŸ©
      dsimp [aux] at this; rw [this]; clear this
      conv_rhs => rw [â† Category.id_comp (e a)]
      apply h
      generalize_proofs h1 h2
      rw [h2.choose_spec, Category.id_comp]
    uniq := by
      intro W e h m hm
      apply H.uniq (aux e h)
      rintro âŸ¨T, a, (g : T.left âŸ¶ _), haâŸ©
      dsimp
      nth_rewrite 1 [â† ha, Category.assoc, hm]
      apply h
      generalize_proofs h1 h2
      rwa [h2.choose_spec] }

theorem Sieve.effectiveEpimorphic_family {B : C} {Î± : Type*}
    (X : Î± â†’ C) (Ï€ : (a : Î±) â†’ (X a âŸ¶ B)) :
    (Presieve.ofArrows X Ï€).EffectiveEpimorphic â†” EffectiveEpiFamily X Ï€ := by
  constructor
  Â· intro (h : Nonempty _)
    rw [Sieve.generateFamily_eq] at h
    constructor
    apply Nonempty.map (effectiveEpiFamilyStructOfIsColimit _ _) h
  Â· rintro âŸ¨hâŸ©
    change Nonempty _
    rw [Sieve.generateFamily_eq]
    apply Nonempty.map (isColimitOfEffectiveEpiFamilyStruct _ _) h

end CategoryTheory
