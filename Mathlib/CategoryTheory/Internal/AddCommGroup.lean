/-
Copyright (c) 2024 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathlib.CategoryTheory.Internal.Basic
import Mathlib.CategoryTheory.Internal.ObjOperation

/-!
# Internal abelian groups

-/

namespace CategoryTheory

open Limits

namespace Internal

open ConcreteCategory

variable {C D : Type _} [Category C] [Category D]

def zero (G : Internal Ab C) (X : C) : Zero (X ‚ü∂ G.obj) where
  zero := (addCommGroupCat_zero.onInternal G).app _ PUnit.unit

def add (G : Internal Ab C) (X : C) : Add (X ‚ü∂ G.obj) where
  add := fun a b => (addCommGroupCat_add.onInternal G).app _ ‚ü®a, b‚ü©

def neg (G : Internal Ab C) (X : C) : Neg (X ‚ü∂ G.obj) where
  neg := (addCommGroupCat_neg.onInternal G).app (Opposite.op X)

def addCommGroup (G : Internal Ab C) (X : C) :
    AddCommGroup (X ‚ü∂ G.obj) := by
  letI := zero G
  letI := add G
  letI := neg G
  exact
    { zero_add := congr_fun (congr_app (addCommGroupCat_zero_add.onInternal G) (Opposite.op X))
      add_assoc := fun a b c =>
        congr_fun (congr_app (addCommGroupCat_add_assoc.onInternal G) _) ‚ü®a, ‚ü®b, c‚ü©‚ü©
      add_zero := congr_fun (congr_app (addCommGroupCat_add_zero.onInternal G) (Opposite.op X))
      neg_add_cancel := congr_fun
        (congr_app (addCommGroupCat_add_left_neg.onInternal G) (Opposite.op X))
      add_comm := fun a b =>
         congr_fun (congr_app (addCommGroupCat_add_comm.onInternal G) (Opposite.op X)) ‚ü®a, b‚ü©
      nsmul := nsmulRec
      zsmul := zsmulRec }

@[simp]
lemma addCommGroup_add (G : Internal Ab C) {X : C} (a b : X ‚ü∂ G.obj) :
    letI := addCommGroup G X
    a + b = (addCommGroupCat_add.onInternal G).app _ ‚ü®a, b‚ü© := rfl

@[simp]
def addCommGroup_addMonoidHom (G : Internal Ab C) {X Y : C} (f : X ‚ü∂ Y) :
    letI := addCommGroup G X
    letI := addCommGroup G Y
    (Y ‚ü∂ G.obj) ‚Üí+ (X ‚ü∂ G.obj) :=
  letI := addCommGroup G X
  letI := addCommGroup G Y
  AddMonoidHom.mk' (fun œÜ => f ‚â´ œÜ)
    (fun a b => (congr_fun ((addCommGroupCat_add.onInternal G).naturality f.op) ‚ü®a, b‚ü©).symm)

/-- `addCommGroup_addMonoidHom'`. -/
@[simp]
def addCommGroup_addMonoidHom' {G‚ÇÅ G‚ÇÇ : Internal Ab C} (f : G‚ÇÅ ‚ü∂ G‚ÇÇ) (f_obj : G‚ÇÅ.obj ‚ü∂ G‚ÇÇ.obj)
  (h : f_obj = (Internal.objFunctor _ _).map f) (X : C) :
    letI := addCommGroup G‚ÇÅ X
    letI := addCommGroup G‚ÇÇ X
    (X ‚ü∂ G‚ÇÅ.obj) ‚Üí+ (X ‚ü∂ G‚ÇÇ.obj) :=
  letI := addCommGroup G‚ÇÅ X
  letI := addCommGroup G‚ÇÇ X
  AddMonoidHom.mk' (fun œÜ => œÜ ‚â´ f_obj)
    (fun a b => (congr_fun (congr_app
      (addCommGroupCat_add.onInternal_naturality f f_obj h) _) ‚ü®a, b‚ü©).symm)

structure AddCommGroupCatObjOperations (G : C)
    [HasTerminal C] [HasBinaryProduct G G] [HasBinaryProduct G (G ‚®Ø G)] where
  zero : ObjOperation‚ÇÄ G
  neg : ObjOperation‚ÇÅ G
  add : ObjOperation‚ÇÇ G
  add_assoc : add.assoc
  add_zero : add.add_zero zero
  zero_add : add.zero_add zero
  add_comm : add.comm
  add_left_neg : add.add_left_neg neg zero

namespace AddCommGroupCatObjOperations

section

variable {G : C} [HasTerminal C] [HasBinaryProduct G G] [HasBinaryProduct G (G ‚®Ø G)]
  (h : AddCommGroupCatObjOperations G)

noncomputable def presheafObjZero (Y : C) : Zero (Y ‚ü∂ G) where
  zero := ((ObjOperation‚ÇÄ.yonedaEquiv G) h.zero).app (Opposite.op Y) PUnit.unit

noncomputable def presheafObjNeg (Y : C) : Neg (Y ‚ü∂ G) where
  neg := ((ObjOperation‚ÇÅ.yonedaEquiv G) h.neg).app (Opposite.op Y)

noncomputable def presheafObjAdd (Y : C) : Add (Y ‚ü∂ G) where
  add a b := ((ObjOperation‚ÇÇ.yonedaEquiv G) h.add).app (Opposite.op Y) ‚ü®a, b‚ü©

noncomputable def presheafObj (Y : C) : AddCommGroup (Y ‚ü∂ G) := by
  letI := presheafObjZero h Y
  letI := presheafObjNeg h Y
  letI := presheafObjAdd h Y
  exact
    { add_assoc := fun a b c => congr_fun
        (congr_app ((ObjOperation‚ÇÇ.assoc_iff h.add).1 h.add_assoc) (Opposite.op Y)) ‚ü®a, b, c‚ü©
      add_zero := congr_fun (congr_app ((ObjOperation‚ÇÇ.add_zero_iff h.add h.zero).1 h.add_zero)
        (Opposite.op Y))
      zero_add := congr_fun (congr_app ((ObjOperation‚ÇÇ.zero_add_iff h.add h.zero).1 h.zero_add)
        (Opposite.op Y))
      neg_add_cancel := congr_fun (congr_app
        ((ObjOperation‚ÇÇ.add_left_neg_iff h.add h.neg h.zero).1 h.add_left_neg) (Opposite.op Y))
      add_comm := fun a b => congr_fun (congr_app ((ObjOperation‚ÇÇ.comm_iff h.add).1 h.add_comm)
        (Opposite.op Y)) ‚ü®a, b‚ü©
      nsmul := nsmulRec
      zsmul := zsmulRec }

@[simp]
noncomputable def presheaf_map {Y‚ÇÅ Y‚ÇÇ : C} (f : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) :
    letI := h.presheafObj Y‚ÇÅ
    letI := h.presheafObj Y‚ÇÇ
    AddCommGrp.of (Y‚ÇÇ ‚ü∂ G) ‚ü∂ AddCommGrp.of (Y‚ÇÅ ‚ü∂ G) :=
  letI := h.presheafObj Y‚ÇÅ
  letI := h.presheafObj Y‚ÇÇ
  AddCommGrp.ofHom (AddMonoidHom.mk' (fun g => f ‚â´ g)
    (fun a b => (congr_fun (((ObjOperation‚ÇÇ.yonedaEquiv G) h.add).naturality f.op) ‚ü®a, b‚ü©).symm))

noncomputable def presheaf : C·µí·µñ ‚•§ Ab := by
  letI := fun (Y : C) => h.presheafObj Y
  exact
  { obj := fun Y => AddCommGrp.of (Y.unop ‚ü∂ G)
    map := fun f => h.presheaf_map f.unop }

@[simps]
noncomputable def internal :
  Internal Ab C where
  obj := G
  presheaf := h.presheaf
  iso := Iso.refl _

@[simp]
lemma internal_presheaf_add {X : C} (x y : X ‚ü∂ G) :
  @HAdd.hAdd (h.internal.presheaf.obj (Opposite.op X))
    (h.internal.presheaf.obj (Opposite.op X)) _ _ x y = prod.lift x y ‚â´ h.add := rfl

@[simps]
noncomputable def map (F : C ‚•§ D)
    [HasTerminal D] [HasBinaryProduct (F.obj G) (F.obj G)]
    [HasBinaryProduct (F.obj G) (F.obj (G ‚®Ø G))]
    [HasBinaryProduct (F.obj G) (F.obj G ‚®Ø F.obj G)]
    [PreservesLimit (Functor.empty C) F] [PreservesLimit (pair G G) F]
    [PreservesLimit (pair G (G ‚®Ø G)) F] :
    AddCommGroupCatObjOperations (F.obj G) where
  zero := h.zero.map F
  neg := h.neg.map F
  add := h.add.map F
  add_assoc := h.add_assoc.map F
  add_comm := h.add_comm.map F
  add_zero := h.add_zero.map F
  zero_add := h.zero_add.map F
  add_left_neg := h.add_left_neg.map F

end

section

variable (G : Internal Ab C) [HasTerminal C] [HasBinaryProduct G.obj G.obj]
  [HasBinaryProduct G.obj (G.obj ‚®Ø G.obj)]

noncomputable def ofInternal : AddCommGroupCatObjOperations G.obj where
  zero := (ObjOperation‚ÇÄ.yonedaEquiv G.obj).symm (addCommGroupCat_zero.onInternal G)
  neg := (ObjOperation‚ÇÅ.yonedaEquiv G.obj).symm (addCommGroupCat_neg.onInternal G)
  add := (ObjOperation‚ÇÇ.yonedaEquiv G.obj).symm (addCommGroupCat_add.onInternal G)
  add_assoc := (ObjOperation‚ÇÇ.assoc_iff _).2
    (by simpa only [Equiv.apply_symm_apply] using (addCommGroupCat_add_assoc.onInternal G))
  add_zero := (ObjOperation‚ÇÇ.add_zero_iff _ _ ).2
    (by simpa only [Equiv.apply_symm_apply] using (addCommGroupCat_add_zero.onInternal G))
  zero_add := (ObjOperation‚ÇÇ.zero_add_iff _ _ ).2
    (by simpa only [Equiv.apply_symm_apply] using (addCommGroupCat_zero_add.onInternal G))
  add_comm := (ObjOperation‚ÇÇ.comm_iff _).2
    (by simpa only [Equiv.apply_symm_apply] using (addCommGroupCat_add_comm.onInternal G))
  add_left_neg := (ObjOperation‚ÇÇ.add_left_neg_iff _ _ _ ).2
    (by simpa only [Equiv.apply_symm_apply] using (addCommGroupCat_add_left_neg.onInternal G))

end

section

variable {G‚ÇÅ G‚ÇÇ G‚ÇÉ G‚ÇÑ : C} [HasTerminal C]
  [HasBinaryProduct G‚ÇÅ G‚ÇÅ] [HasBinaryProduct G‚ÇÅ (G‚ÇÅ ‚®Ø G‚ÇÅ)]
  [HasBinaryProduct G‚ÇÇ G‚ÇÇ] [HasBinaryProduct G‚ÇÇ (G‚ÇÇ ‚®Ø G‚ÇÇ)]
  [HasBinaryProduct G‚ÇÉ G‚ÇÉ] [HasBinaryProduct G‚ÇÉ (G‚ÇÉ ‚®Ø G‚ÇÉ)]
  [HasBinaryProduct G‚ÇÑ G‚ÇÑ] [HasBinaryProduct G‚ÇÑ (G‚ÇÑ ‚®Ø G‚ÇÑ)]
  (h‚ÇÅ : AddCommGroupCatObjOperations G‚ÇÅ)
  (h‚ÇÇ : AddCommGroupCatObjOperations G‚ÇÇ)
  (h‚ÇÉ : AddCommGroupCatObjOperations G‚ÇÉ)
  (h‚ÇÑ : AddCommGroupCatObjOperations G‚ÇÑ)

@[ext]
structure Hom where
  map : G‚ÇÅ ‚ü∂ G‚ÇÇ
  map_add : h‚ÇÅ.add ‚â´ map = prod.map map map ‚â´ h‚ÇÇ.add := by aesop_cat

namespace Hom

attribute [reassoc] map_add

@[simps]
def id : Hom h‚ÇÅ h‚ÇÅ where
  map := ùüô _

variable {h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ}

@[simps]
def comp (œÜ : Hom h‚ÇÅ h‚ÇÇ) (œà : Hom h‚ÇÇ h‚ÇÉ) : Hom h‚ÇÅ h‚ÇÉ where
  map := œÜ.map ‚â´ œà.map
  map_add := by simp only [Hom.map_add, Hom.map_add_assoc, prod.map_map_assoc]

@[simp] lemma id_comp (œÜ : Hom h‚ÇÅ h‚ÇÇ) : (id h‚ÇÅ).comp œÜ = œÜ := by aesop_cat
@[simp] lemma comp_id (œÜ : Hom h‚ÇÅ h‚ÇÇ) : œÜ.comp (id h‚ÇÇ) = œÜ := by aesop_cat
@[simp] lemma assoc (œÜ‚ÇÅ : Hom h‚ÇÅ h‚ÇÇ) (œÜ‚ÇÇ : Hom h‚ÇÇ h‚ÇÉ) (œÜ‚ÇÉ : Hom h‚ÇÉ h‚ÇÑ) :
  (œÜ‚ÇÅ.comp œÜ‚ÇÇ).comp œÜ‚ÇÉ = œÜ‚ÇÅ.comp (œÜ‚ÇÇ.comp œÜ‚ÇÉ) := by aesop_cat

noncomputable def internal (œÜ : Hom h‚ÇÅ h‚ÇÇ) : h‚ÇÅ.internal ‚ü∂ h‚ÇÇ.internal where
  app X :=
    letI := h‚ÇÅ.presheafObj X.unop
    letI := h‚ÇÇ.presheafObj X.unop
    AddCommGrp.ofHom
      (show (X.unop ‚ü∂ G‚ÇÅ) ‚Üí+ (X.unop ‚ü∂ G‚ÇÇ) from AddMonoidHom.mk' (fun x‚ÇÅ => x‚ÇÅ ‚â´ œÜ.map)
      (fun a b => by
        dsimp
        rw [internal_presheaf_add, internal_presheaf_add]
        simp only [Category.assoc, œÜ.map_add, prod.lift_map_assoc]))
  naturality _ _ _ := by ext; apply Category.assoc

-- simp does not work with this lemma, only erw, why?
lemma internal_app_apply (œÜ : Hom h‚ÇÅ h‚ÇÇ) (X : C) (x : X ‚ü∂ G‚ÇÅ) :
    œÜ.internal.app (Opposite.op X) x = x ‚â´ œÜ.map := rfl

section
variable {G‚ÇÅ G‚ÇÇ : Internal Ab C} [HasTerminal C]
  [HasBinaryProduct G‚ÇÅ.obj G‚ÇÅ.obj] [HasBinaryProduct G‚ÇÅ.obj (G‚ÇÅ.obj ‚®Ø G‚ÇÅ.obj)]
  [HasBinaryProduct G‚ÇÇ.obj G‚ÇÇ.obj] [HasBinaryProduct G‚ÇÇ.obj (G‚ÇÇ.obj ‚®Ø G‚ÇÇ.obj)]

@[simps]
noncomputable def ofInternal (œÜ : G‚ÇÅ ‚ü∂ G‚ÇÇ) : Hom (ofInternal G‚ÇÅ) (ofInternal G‚ÇÇ) where
  map := (Internal.objFunctor _ _).map œÜ
  map_add := by
    dsimp only [AddCommGroupCatObjOperations.ofInternal]
    apply (ObjOperation‚ÇÇ.yonedaEquiv' _ _ _).injective
    rw [ObjOperation‚ÇÇ.yonedaEquiv'_apply_comp]
    erw [Equiv.apply_symm_apply]
    rw [‚Üê Operation‚ÇÇ.onInternal_naturality addCommGroupCat_add œÜ _ rfl]
    erw [ObjOperation‚ÇÇ.yonedaEquiv'_comp_apply, Equiv.apply_symm_apply]

end

end Hom

end

end AddCommGroupCatObjOperations

section

variable (C)
variable [HasTerminal C] [HasBinaryProducts C]

protected structure Ab where
  obj : C
  str : AddCommGroupCatObjOperations obj

instance : Category (Internal.Ab C) where
  Hom G‚ÇÅ G‚ÇÇ := AddCommGroupCatObjOperations.Hom G‚ÇÅ.str G‚ÇÇ.str
  id G := AddCommGroupCatObjOperations.Hom.id G.str
  comp f g := AddCommGroupCatObjOperations.Hom.comp f g

namespace Ab

variable {C}

/-- Constructor for `Internal.Ab C`. -/
@[simps]
def mk' {G : C} (h : AddCommGroupCatObjOperations G) : Internal.Ab C where
  obj := G
  str := h

@[ext]
lemma hom_ext {G‚ÇÅ G‚ÇÇ : Internal.Ab C} (œÜ œÜ' : G‚ÇÅ ‚ü∂ G‚ÇÇ) (h : œÜ.map = œÜ'.map) : œÜ = œÜ' :=
  AddCommGroupCatObjOperations.Hom.ext h

@[simp]
lemma id_map (G : Internal.Ab C) : AddCommGroupCatObjOperations.Hom.map (ùüô G) = ùüô G.obj := rfl

@[simp]
lemma comp_map {G‚ÇÅ G‚ÇÇ G‚ÇÉ : Internal.Ab C} (œÜ : G‚ÇÅ ‚ü∂ G‚ÇÇ) (œà : G‚ÇÇ ‚ü∂ G‚ÇÉ) :
  (œÜ ‚â´ œà).map = œÜ.map ‚â´ œà.map := rfl

variable (C)

def forget : Internal.Ab C ‚•§ C where
  obj G := G.obj
  map f := f.map

namespace Equivalence

@[simps]
noncomputable def functor : Internal.Ab C ‚•§ Internal Ab C where
  obj G :=  G.str.internal
  map œÜ := œÜ.internal
  map_id G := by
    apply NatTrans.ext
    ext ‚ü®X‚ü© (f : X ‚ü∂ G.obj)
    dsimp
    erw [AddCommGroupCatObjOperations.Hom.internal_app_apply]
    simp only [id_map, Category.comp_id]
  map_comp {G‚ÇÅ G‚ÇÇ G‚ÇÉ} œÜ œÜ' := by
    apply NatTrans.ext
    ext ‚ü®X‚ü© (f : X ‚ü∂ G‚ÇÅ.obj)
    dsimp
    erw [AddCommGroupCatObjOperations.Hom.internal_app_apply,
      AddCommGroupCatObjOperations.Hom.internal_app_apply,
      AddCommGroupCatObjOperations.Hom.internal_app_apply]
    simp only [comp_map, Category.assoc]

@[simps]
noncomputable def inverse : Internal Ab C ‚•§ Internal.Ab C where
  obj G := mk' (AddCommGroupCatObjOperations.ofInternal G)
  map œÜ := AddCommGroupCatObjOperations.Hom.ofInternal œÜ
  map_id G := by
    apply AddCommGroupCatObjOperations.Hom.ext
    dsimp
    apply Functor.map_id
  map_comp _ _ := by
    apply AddCommGroupCatObjOperations.Hom.ext
    dsimp
    apply Functor.map_comp

noncomputable def inverseCompForgetIso :
    inverse C ‚ãô Internal.Ab.forget _ ‚âÖ objFunctor _ _ :=
  NatIso.ofComponents (fun F => Iso.refl _) (by aesop_cat)

noncomputable def functorCompObjFunctorIso :
    functor C ‚ãô objFunctor _ _ ‚âÖ Internal.Ab.forget _ :=
  NatIso.ofComponents (fun F => Iso.refl _) (fun {G‚ÇÅ G‚ÇÇ f} => by
    dsimp [forget]
    simp only [Category.comp_id, Category.id_comp]
    apply yoneda.map_injective
    simp only [Internal.map_objFunctor_map,
      AddCommGroupCatObjOperations.internal_obj,
      AddCommGroupCatObjOperations.internal_presheaf,
      AddCommGroupCatObjOperations.internal_iso, Iso.refl_hom,
      Iso.refl_inv, Category.id_comp]
    erw [Category.comp_id]
    rfl)

end Equivalence

/-def equivalence : Internal.Ab C ‚âå Internal AddCommGroupCat C where
  functor := Equivalence.functor C
  inverse := Equivalence.inverse C
  unitIso := sorry
  counitIso := sorry
  functor_unitIso_comp := sorry-/

end Ab

end

end Internal

namespace Functor

variable {C D : Type _}
  [Category C] [HasTerminal C] [HasBinaryProducts C]
  [Category D] [HasTerminal D] [HasBinaryProducts D]
  (F : C ‚•§ D) [PreservesLimitsOfShape (Discrete WalkingPair) F]
    [PreservesLimit (empty C) F]

@[simps]
noncomputable def mapInternalAb : Internal.Ab C ‚•§ Internal.Ab D where
  obj G := Internal.Ab.mk' (G.str.map F)
  map {G‚ÇÅ G‚ÇÇ} f :=
    { map := F.map f.map
      map_add := by
        dsimp [Internal.ObjOperation‚ÇÇ.map]
        simp only [Category.assoc]
        have eq := F.congr_map f.map_add
        simp only [F.map_comp] at eq
        rw [eq]
        simp only [‚Üê Category.assoc]
        congr 1
        rw [‚Üê cancel_mono (PreservesLimitPair.iso F G‚ÇÇ.obj G‚ÇÇ.obj).hom,
          ‚Üê cancel_epi (PreservesLimitPair.iso F G‚ÇÅ.obj G‚ÇÅ.obj).hom]
        simp only [Category.assoc, Iso.hom_inv_id_assoc, Iso.inv_hom_id, Category.comp_id]
        simp only [PreservesLimitPair.iso_hom]
        ext
        ¬∑ simp only [Category.assoc, prodComparison_fst, prod.map_fst,
          prodComparison_fst_assoc, ‚Üê F.map_comp]
        ¬∑ simp only [Category.assoc, prodComparison_snd, prod.map_snd,
          prodComparison_snd_assoc, ‚Üê F.map_comp] }

noncomputable def mapInternalAddCommGroupCat :
    Internal Ab C ‚•§ Internal Ab D :=
  Internal.Ab.Equivalence.inverse C ‚ãô F.mapInternalAb ‚ãô
    Internal.Ab.Equivalence.functor D

noncomputable def mapInternalAbCompForgetIso :
    F.mapInternalAb ‚ãô Internal.Ab.forget _ ‚âÖ
      Internal.Ab.forget _ ‚ãô F :=
  NatIso.ofComponents (fun F => Iso.refl _) (by aesop_cat)

noncomputable def mapInternalAddCommGroupCatCompObjFunctorIso :
    F.mapInternalAddCommGroupCat ‚ãô Internal.objFunctor _ _ ‚âÖ
      Internal.objFunctor _ _ ‚ãô F :=
  calc (Internal.Ab.Equivalence.inverse C ‚ãô F.mapInternalAb ‚ãô
    Internal.Ab.Equivalence.functor D) ‚ãô Internal.objFunctor _ _  ‚âÖ
    Internal.Ab.Equivalence.inverse C ‚ãô F.mapInternalAb ‚ãô Internal.Ab.forget _ :=
      isoWhiskerLeft (Internal.Ab.Equivalence.inverse C ‚ãô F.mapInternalAb)
          (Internal.Ab.Equivalence.functorCompObjFunctorIso D)
  _ ‚âÖ Internal.Ab.Equivalence.inverse C ‚ãô Internal.Ab.forget _ ‚ãô F :=
      isoWhiskerLeft _ F.mapInternalAbCompForgetIso
  _ ‚âÖ _ := isoWhiskerRight (Internal.Ab.Equivalence.inverseCompForgetIso C) F

end Functor

end CategoryTheory
