/-
Copyright (c) 2024 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathlib.CategoryTheory.ConcreteCategory.Operation
import Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts
import Mathlib.CategoryTheory.Limits.Preserves.Shapes.Terminal
import Mathlib.CategoryTheory.Limits.Preserves.Shapes.BinaryProducts

/-!
# Operations on objects in a category

-/

/-- If `f` is injective, `f x‚ÇÅ = y‚ÇÅ`, `f x‚ÇÇ = y‚ÇÇ`, then `x‚ÇÅ = x‚ÇÇ ‚Üî y‚ÇÅ = y‚ÇÇ`. -/
lemma Function.Injective.eq_iff'' {X Y : Type _} {f : X ‚Üí Y} (hf : Function.Injective f)
    (x‚ÇÅ x‚ÇÇ : X) (y‚ÇÅ y‚ÇÇ : Y) (h‚ÇÅ : f x‚ÇÅ = y‚ÇÅ) (h‚ÇÇ : f x‚ÇÇ = y‚ÇÇ) : x‚ÇÅ = x‚ÇÇ ‚Üî y‚ÇÅ = y‚ÇÇ := by
  subst h‚ÇÅ h‚ÇÇ
  constructor
  ¬∑ intro h
    rw [h]
  ¬∑ apply hf

namespace CategoryTheory

variable {C D : Type _} [Category C] [Category D]

namespace Limits

@[reassoc (attr := simp)]
lemma PreservesLimitPair.iso_inv_comp_map_fst (F : C ‚•§ D) (X Y : C) [HasBinaryProduct X Y]
    [HasBinaryProduct (F.obj X) (F.obj Y)] [PreservesLimit (pair X Y) F] :
    (PreservesLimitPair.iso F X Y).inv ‚â´ F.map Limits.prod.fst = prod.fst := by
  rw [‚Üê cancel_epi (PreservesLimitPair.iso F X Y).hom, Iso.hom_inv_id_assoc,
    PreservesLimitPair.iso_hom, prodComparison_fst]

@[reassoc (attr := simp)]
lemma PreservesLimitPair.iso_inv_comp_map_snd (F : C ‚•§ D) (X Y : C) [HasBinaryProduct X Y]
    [HasBinaryProduct (F.obj X) (F.obj Y)] [PreservesLimit (pair X Y) F] :
    (PreservesLimitPair.iso F X Y).inv ‚â´ F.map Limits.prod.snd = prod.snd := by
  rw [‚Üê cancel_epi (PreservesLimitPair.iso F X Y).hom, Iso.hom_inv_id_assoc,
    PreservesLimitPair.iso_hom, prodComparison_snd]

end Limits

open Limits


namespace Internal

def ObjOperation‚ÇÄ [HasTerminal C] (X : C) := ‚ä§_ C ‚ü∂ X

def ObjOperation‚ÇÅ (X : C) := X ‚ü∂ X

def ObjOperation‚ÇÇ (X : C) [HasBinaryProduct X X] := X ‚®Ø X ‚ü∂ X

def ObjOperation‚ÇÉ (X : C) [HasBinaryProduct X X] [HasBinaryProduct X (X ‚®Ø X)] :=
  X ‚®Ø X ‚®Ø X ‚ü∂ X

namespace ObjOperation‚ÇÄ

noncomputable def yonedaEquiv [HasTerminal C] (X : C) :
  ObjOperation‚ÇÄ X ‚âÉ Types.functorOperation‚ÇÄ (yoneda.obj X) where
  toFun f :=
  { app := fun T _ => terminal.from _ ‚â´ f
    naturality := fun _ _ f => by
      ext
      dsimp
      rw [‚Üê Category.assoc]
      congr
      apply Subsingleton.elim }
  invFun œÜ := œÜ.app (Opposite.op (‚ä§_ C)) PUnit.unit
  left_inv := fun f => by
    dsimp
    simp only [Subsingleton.elim (terminal.from (‚ä§_ C)) (ùüô _), Category.id_comp]
  right_inv := fun œÜ => NatTrans.ext (by
    ext T ‚ü®‚ü©
    exact (congr_fun (œÜ.naturality (terminal.from T.unop).op) PUnit.unit).symm)

noncomputable def map {X : C} [HasTerminal C] [HasTerminal D] (h : ObjOperation‚ÇÄ X) (F : C ‚•§ D)
  [PreservesLimit (Functor.empty C) F] :
    ObjOperation‚ÇÄ (F.obj X) :=
  (Limits.PreservesTerminal.iso F).inv ‚â´ F.map h

end ObjOperation‚ÇÄ

namespace ObjOperation‚ÇÅ

def yonedaEquiv (X : C) :
  ObjOperation‚ÇÅ X ‚âÉ Types.functorOperation‚ÇÅ (yoneda.obj X) :=
  Equiv.symm CategoryTheory.yonedaEquiv

def map {X : C} (h : ObjOperation‚ÇÅ X) (F : C ‚•§ D) : ObjOperation‚ÇÅ (F.obj X) :=
  F.map h

end ObjOperation‚ÇÅ

namespace ObjOperation‚ÇÇ

/-- yonedaEquiv' -/
noncomputable def yonedaEquiv' (X Y Z : C) [HasBinaryProduct X Y] :
  (X ‚®Ø Y ‚ü∂ Z) ‚âÉ (Types.functorConcat (yoneda.obj X) (yoneda.obj Y) ‚ü∂ yoneda.obj Z ) where
  toFun f :=
  { app := fun T ‚ü®x, y‚ü© => prod.lift x y ‚â´ f
    naturality := fun _ _ f => by
      ext
      dsimp
      simp only [prod.comp_lift_assoc] }
  invFun œÜ := œÜ.app (Opposite.op (X ‚®Ø Y)) ‚ü®prod.fst, prod.snd‚ü©
  left_inv := by aesop_cat
  right_inv := fun œÜ => by
    ext Z ‚ü®x, y‚ü©
    apply (congr_fun (œÜ.naturality (prod.lift x y).op) ‚ü®prod.fst, prod.snd‚ü©).symm.trans
    dsimp
    simp

lemma yonedaEquiv'_apply_comp {X Y Z Z' : C} [HasBinaryProduct X Y]
    (œÜ : X ‚®Ø Y ‚ü∂ Z) (œà : Z ‚ü∂ Z') :
     (yonedaEquiv' X Y Z') (œÜ ‚â´ œà) =
      (yonedaEquiv' X Y Z) œÜ ‚â´ yoneda.map œà := by
  ext ‚ü®T‚ü© ‚ü®x‚ÇÅ : T ‚ü∂ X, x‚ÇÇ : T ‚ü∂ Y‚ü©
  dsimp [yonedaEquiv']
  simp only [Category.assoc]

lemma yonedaEquiv'_comp_apply {X' Y' X Y Z : C} [HasBinaryProduct X' Y']
  [HasBinaryProduct X Y] (Œ± : X' ‚ü∂ X) (Œ≤ : Y' ‚ü∂ Y) (œÜ : X ‚®Ø Y ‚ü∂ Z) :
    (yonedaEquiv' X' Y' Z) (prod.map Œ± Œ≤ ‚â´ œÜ) =
      (Types.natTransConcat (Types.functorPr‚ÇÅ ‚â´ yoneda.map Œ±)
          (Types.functorPr‚ÇÇ ‚â´ yoneda.map Œ≤)) ‚â´ (yonedaEquiv' X Y Z) œÜ := by
  ext ‚ü®T‚ü© ‚ü®x‚ÇÅ : T ‚ü∂ X', x‚ÇÇ : T ‚ü∂ Y'‚ü©
  dsimp [yonedaEquiv']
  simp only [prod.lift_map_assoc]

noncomputable def yonedaEquiv (X : C) [HasBinaryProduct X X] :
  ObjOperation‚ÇÇ X ‚âÉ Types.functorOperation‚ÇÇ (yoneda.obj X) :=
  yonedaEquiv' X X X

variable {X : C} [HasBinaryProduct X X]

noncomputable def swap (oper : ObjOperation‚ÇÇ X) :
    ObjOperation‚ÇÇ X :=
  prod.lift prod.snd prod.fst ‚â´ oper

lemma swap_yonedaEquiv_inv_apply (oper : Types.functorOperation‚ÇÇ (yoneda.obj X)) :
    ((yonedaEquiv _).symm oper).swap = (yonedaEquiv _).symm oper.swap := by
  simpa using (congr_fun (oper.naturality ((prod.lift prod.snd prod.fst : X ‚®Ø X ‚ü∂ _)).op)
    ‚ü®prod.fst, prod.snd‚ü©).symm

lemma swap_yonedaEquiv_apply (oper : ObjOperation‚ÇÇ X) :
    (yonedaEquiv _ oper).swap = yonedaEquiv _ oper.swap := by
  obtain ‚ü®oper, rfl‚ü© := (yonedaEquiv X).symm.surjective oper
  apply (yonedaEquiv X).symm.injective
  simp only [Equiv.apply_symm_apply, Equiv.symm_apply_apply,
    swap_yonedaEquiv_inv_apply]

def comm (oper : ObjOperation‚ÇÇ X) : Prop := oper = oper.swap

lemma comm_iff (oper : ObjOperation‚ÇÇ X) :
    oper.comm ‚Üî ((yonedaEquiv _) oper).comm := by
  dsimp only [comm, Types.functorOperation‚ÇÇ.comm]
  rw [swap_yonedaEquiv_apply]
  constructor
  ¬∑ intro h
    simp only [‚Üê h]
  ¬∑ apply (yonedaEquiv X).injective

/-- comm_iff' -/
lemma comm_iff' (oper : Types.functorOperation‚ÇÇ (yoneda.obj X)) :
    oper.comm ‚Üî ((yonedaEquiv _).symm oper).comm := by
  rw [comm_iff, Equiv.apply_symm_apply]

variable [HasTerminal C]

def add_left_neg (oper : ObjOperation‚ÇÇ X) (neg : ObjOperation‚ÇÅ X) (zero : ObjOperation‚ÇÄ X) :
  Prop :=
    prod.lift neg (ùüô X) ‚â´ oper = terminal.from X ‚â´ zero

lemma add_left_neg_iff (oper : ObjOperation‚ÇÇ X) (neg : ObjOperation‚ÇÅ X) (zero : ObjOperation‚ÇÄ X) :
    oper.add_left_neg neg zero ‚Üî
      ((yonedaEquiv _) oper).add_left_neg ((ObjOperation‚ÇÅ.yonedaEquiv _) neg)
      ((ObjOperation‚ÇÄ.yonedaEquiv _) zero) := by
  apply (ObjOperation‚ÇÅ.yonedaEquiv X).injective.eq_iff''
  ¬∑ apply (ObjOperation‚ÇÅ.yonedaEquiv X).symm.injective
    simp only [Equiv.symm_apply_apply, Types.natTransConcat, yoneda_obj_obj, NatTrans.id_app,
      types_id_apply]
    congr
    simp [ObjOperation‚ÇÅ.yonedaEquiv, CategoryTheory.yonedaEquiv]
  ¬∑ apply (ObjOperation‚ÇÅ.yonedaEquiv X).symm.injective
    simp only [Equiv.symm_apply_apply, Types.natTransConcat, yoneda_obj_obj, NatTrans.id_app,
      types_id_apply]
    rfl

/-- add_left_neg_iff' -/
lemma add_left_neg_iff' (oper : Types.functorOperation‚ÇÇ (yoneda.obj X))
  (neg : Types.functorOperation‚ÇÅ (yoneda.obj X)) (zero : Types.functorOperation‚ÇÄ (yoneda.obj X)) :
  oper.add_left_neg neg zero ‚Üî
    ((yonedaEquiv _).symm oper).add_left_neg ((ObjOperation‚ÇÅ.yonedaEquiv _).symm neg)
      ((ObjOperation‚ÇÄ.yonedaEquiv _).symm zero) := by
  rw [add_left_neg_iff, Equiv.apply_symm_apply, Equiv.apply_symm_apply, Equiv.apply_symm_apply]

def zero_add (oper : ObjOperation‚ÇÇ X) (zero : ObjOperation‚ÇÄ X) : Prop :=
    prod.lift (terminal.from X ‚â´ zero) (ùüô X) ‚â´ oper = ùüô X

def add_zero (oper : ObjOperation‚ÇÇ X) (zero : ObjOperation‚ÇÄ X) : Prop :=
    prod.lift (ùüô X) (terminal.from X ‚â´ zero) ‚â´ oper = ùüô X

lemma zero_add_iff (oper : ObjOperation‚ÇÇ X) (zero : ObjOperation‚ÇÄ X) :
    oper.zero_add zero ‚Üî
      ((yonedaEquiv _) oper).zero_add ((ObjOperation‚ÇÄ.yonedaEquiv _) zero) := by
  apply (ObjOperation‚ÇÅ.yonedaEquiv X).injective.eq_iff''
  all_goals
    apply (ObjOperation‚ÇÅ.yonedaEquiv X).symm.injective
    simp
    rfl

/-- zero_add_iff' -/
lemma zero_add_iff' (oper : Types.functorOperation‚ÇÇ (yoneda.obj X))
  (zero : Types.functorOperation‚ÇÄ (yoneda.obj X)) :
  oper.zero_add zero ‚Üî
    ((yonedaEquiv _).symm oper).zero_add ((ObjOperation‚ÇÄ.yonedaEquiv _).symm zero) := by
  rw [zero_add_iff, Equiv.apply_symm_apply, Equiv.apply_symm_apply]

lemma add_zero_iff (oper : ObjOperation‚ÇÇ X) (zero : ObjOperation‚ÇÄ X) :
    oper.add_zero zero ‚Üî
      ((yonedaEquiv _) oper).add_zero ((ObjOperation‚ÇÄ.yonedaEquiv _) zero) := by
  apply (ObjOperation‚ÇÅ.yonedaEquiv X).injective.eq_iff''
  all_goals
    apply (ObjOperation‚ÇÅ.yonedaEquiv X).symm.injective
    simp
    rfl

/-- add_zero_iff' -/
lemma add_zero_iff' (oper : Types.functorOperation‚ÇÇ (yoneda.obj X))
  (zero : Types.functorOperation‚ÇÄ (yoneda.obj X)) :
  oper.add_zero zero ‚Üî
    ((yonedaEquiv _).symm oper).add_zero ((ObjOperation‚ÇÄ.yonedaEquiv _).symm zero) := by
  rw [add_zero_iff, Equiv.apply_symm_apply, Equiv.apply_symm_apply]

noncomputable def map (h : ObjOperation‚ÇÇ X) (F : C ‚•§ D) [HasBinaryProduct (F.obj X) (F.obj X)]
  [PreservesLimit (pair X X) F] :
    ObjOperation‚ÇÇ (F.obj X) :=
  (PreservesLimitPair.iso F X X).inv ‚â´ F.map h

omit [HasTerminal C] in
lemma map_swap (h : ObjOperation‚ÇÇ X) (F : C ‚•§ D) [HasBinaryProduct (F.obj X) (F.obj X)]
    [PreservesLimit (pair X X) F] :
    (h.map F).swap = h.swap.map F := by
  dsimp [map, swap]
  simp only [F.map_comp, ‚Üê Category.assoc]
  congr 1
  simp only [‚Üê cancel_mono ((PreservesLimitPair.iso F X X).hom),
    ‚Üê cancel_epi  (PreservesLimitPair.iso F X X).hom,
    Category.assoc, Iso.inv_hom_id, Category.comp_id, Iso.hom_inv_id_assoc]
  apply Limits.prod.hom_ext
  ¬∑ simp only [PreservesLimitPair.iso_hom, prod.comp_lift, prodComparison_snd,
      prodComparison_fst, limit.lift_œÄ, BinaryFan.mk_pt, BinaryFan.œÄ_app_left,
      BinaryFan.mk_fst, Category.assoc, ‚Üê F.map_comp]
  ¬∑ simp only [PreservesLimitPair.iso_hom, prod.comp_lift, prodComparison_snd,
      prodComparison_fst, limit.lift_œÄ, BinaryFan.mk_pt, BinaryFan.œÄ_app_right,
      BinaryFan.mk_snd, Category.assoc, ‚Üê F.map_comp]

omit [HasTerminal C] in
lemma comm.map {add : ObjOperation‚ÇÇ X} (h : add.comm) (F : C ‚•§ D)
    [HasBinaryProduct (F.obj X) (F.obj X)] [PreservesLimit (pair X X) F] :
    (add.map F).comm := by
  dsimp only [comm] at h ‚ä¢
  rw [map_swap, ‚Üê h]

lemma add_zero.map {add : ObjOperation‚ÇÇ X} {zero : ObjOperation‚ÇÄ X}
    (h : add.add_zero zero) (F : C ‚•§ D) [HasTerminal D] [PreservesLimit (Functor.empty C) F]
    [HasBinaryProduct (F.obj X) (F.obj X)] [PreservesLimit (pair X X) F] :
    (add.map F).add_zero (zero.map F) := by
  dsimp only [add_zero]
  refine Eq.trans ?_ ((congr_arg (fun (f : ObjOperation‚ÇÅ X) => f.map F) h).trans ?_)
  ¬∑ dsimp [ObjOperation‚ÇÇ.map, ObjOperation‚ÇÅ.map, ObjOperation‚ÇÄ.map]
    simp only [F.map_comp, ‚Üê Category.assoc]
    congr 1
    simp only [‚Üê cancel_mono (PreservesLimitPair.iso F X X).hom, Category.assoc,
      Iso.inv_hom_id, Category.comp_id]
    apply Limits.prod.hom_ext
    ¬∑ simp only [limit.lift_œÄ, BinaryFan.mk_pt, BinaryFan.œÄ_app_left, BinaryFan.mk_fst,
        PreservesLimitPair.iso_hom, Category.assoc, prodComparison_fst, ‚Üê F.map_comp,
        Functor.map_id]
    ¬∑ simp only [limit.lift_œÄ, BinaryFan.mk_pt, BinaryFan.œÄ_app_right, BinaryFan.mk_snd,
        PreservesLimitPair.iso_hom, Category.assoc, prodComparison_snd, ‚Üê F.map_comp]
      rw [F.map_comp, ‚Üê Category.assoc]
      congr 1
      rw [‚Üê cancel_mono (PreservesTerminal.iso F).hom]
      apply Subsingleton.elim
  ¬∑ apply F.map_id

lemma zero_add.map {add : ObjOperation‚ÇÇ X} {zero : ObjOperation‚ÇÄ X}
    (h : add.zero_add zero) (F : C ‚•§ D) [HasTerminal D] [PreservesLimit (Functor.empty C) F]
    [HasBinaryProduct (F.obj X) (F.obj X)] [PreservesLimit (pair X X) F] :
    (add.map F).zero_add (zero.map F) := by
  --dsimp only [add_zero]
  refine Eq.trans ?_ ((congr_arg (fun (f : ObjOperation‚ÇÅ X) => f.map F) h).trans ?_)
  ¬∑ dsimp [ObjOperation‚ÇÇ.map, ObjOperation‚ÇÅ.map, ObjOperation‚ÇÄ.map]
    simp only [F.map_comp, ‚Üê Category.assoc]
    congr 1
    simp only [‚Üê cancel_mono (PreservesLimitPair.iso F X X).hom, Category.assoc,
      Iso.inv_hom_id, Category.comp_id]
    apply Limits.prod.hom_ext
    ¬∑ simp only [limit.lift_œÄ, BinaryFan.mk_pt, BinaryFan.œÄ_app_left, BinaryFan.mk_fst,
        PreservesLimitPair.iso_hom, Category.assoc, prodComparison_fst, ‚Üê F.map_comp ]
      rw [F.map_comp, ‚Üê Category.assoc]
      congr 1
      rw [‚Üê cancel_mono (PreservesTerminal.iso F).hom]
      apply Subsingleton.elim
    ¬∑ simp only [limit.lift_œÄ, BinaryFan.mk_pt, BinaryFan.œÄ_app_right, BinaryFan.mk_snd,
        PreservesLimitPair.iso_hom, Category.assoc, prodComparison_snd, ‚Üê F.map_comp, F.map_id]
  ¬∑ apply F.map_id

lemma add_left_neg.map {add : ObjOperation‚ÇÇ X} {neg : ObjOperation‚ÇÅ X} {zero : ObjOperation‚ÇÄ X}
    (h : add.add_left_neg neg zero) (F : C ‚•§ D) [HasTerminal D] [PreservesLimit (Functor.empty C) F]
    [HasBinaryProduct (F.obj X) (F.obj X)] [PreservesLimit (pair X X) F] :
    (add.map F).add_left_neg (neg.map F) (zero.map F) := by
  --dsimp only [add_zero]
  refine Eq.trans ?_ ((congr_arg (fun (f : ObjOperation‚ÇÅ X) => f.map F) h).trans ?_)
  ¬∑ dsimp [ObjOperation‚ÇÇ.map, ObjOperation‚ÇÅ.map, ObjOperation‚ÇÄ.map]
    simp only [F.map_comp, ‚Üê Category.assoc]
    congr 1
    simp only [‚Üê cancel_mono (PreservesLimitPair.iso F X X).hom, Category.assoc, Iso.inv_hom_id,
      Category.comp_id]
    apply Limits.prod.hom_ext
    ¬∑ simp only [limit.lift_œÄ, BinaryFan.mk_pt, BinaryFan.œÄ_app_left, BinaryFan.mk_fst,
        PreservesLimitPair.iso_hom, Category.assoc, prodComparison_fst, ‚Üê F.map_comp]
    ¬∑ simp only [limit.lift_œÄ, BinaryFan.mk_pt, BinaryFan.œÄ_app_right, BinaryFan.mk_snd,
        PreservesLimitPair.iso_hom, Category.assoc, prodComparison_snd, ‚Üê F.map_comp, F.map_id]
  ¬∑ dsimp [ObjOperation‚ÇÇ.map, ObjOperation‚ÇÅ.map, ObjOperation‚ÇÄ.map]
    simp only [F.map_comp, ‚Üê Category.assoc]
    congr 1
    rw [‚Üê cancel_mono (PreservesTerminal.iso F).hom]
    apply Subsingleton.elim

end ObjOperation‚ÇÇ

namespace ObjOperation‚ÇÉ

/-- yonedaEquiv' -/
noncomputable def yonedaEquiv' (X‚ÇÅ X‚ÇÇ X‚ÇÉ Y : C) [HasBinaryProduct X‚ÇÇ X‚ÇÉ]
  [HasBinaryProduct X‚ÇÅ (X‚ÇÇ ‚®Ø X‚ÇÉ)] :
  (X‚ÇÅ ‚®Ø (X‚ÇÇ ‚®Ø X‚ÇÉ) ‚ü∂ Y) ‚âÉ
    (Types.functorConcat‚ÇÉ (yoneda.obj X‚ÇÅ) (yoneda.obj X‚ÇÇ) (yoneda.obj X‚ÇÉ) ‚ü∂ yoneda.obj Y) where
  toFun f :=
  { app := fun T ‚ü®x, y, z‚ü© => prod.lift x (prod.lift y z) ‚â´ f
    naturality := fun _ _ f => by
      ext
      dsimp
      simp only [prod.comp_lift_assoc, prod.comp_lift] }
  invFun œÜ := œÜ.app (Opposite.op (X‚ÇÅ ‚®Ø X‚ÇÇ ‚®Ø X‚ÇÉ))
    ‚ü®prod.fst, prod.snd ‚â´ prod.fst, prod.snd ‚â´ prod.snd‚ü©
  left_inv := fun f => by
    convert Category.id_comp f
    exact Limits.prod.hom_ext (by simp) (Limits.prod.hom_ext (by simp) (by simp))
  right_inv := fun œÜ => by
    ext Z ‚ü®x, y, z‚ü©
    refine (congr_fun (œÜ.naturality (prod.lift x (prod.lift y z)).op)
      ‚ü®prod.fst, prod.snd ‚â´ prod.fst, prod.snd ‚â´ prod.snd‚ü©).symm.trans ?_
    dsimp
    simp

noncomputable def yonedaEquiv (X : C) [HasBinaryProduct X X] [HasBinaryProduct X (X ‚®Ø X)] :
  ObjOperation‚ÇÉ X ‚âÉ Types.functorOperation‚ÇÉ (yoneda.obj X) :=
  yonedaEquiv' X X X X

noncomputable def map {X : C} [HasBinaryProduct X X] [HasBinaryProduct X (X ‚®Ø X)]
    (h : ObjOperation‚ÇÉ X) (F : C ‚•§ D) [HasBinaryProduct (F.obj X) (F.obj X)]
    [HasBinaryProduct (F.obj X) (F.obj X ‚®Ø F.obj X)]
    [HasBinaryProduct (F.obj X) (F.obj (X ‚®Ø X))]
    [PreservesLimit (pair X X) F] [PreservesLimit (pair X (X ‚®Ø X)) F] :
    ObjOperation‚ÇÉ (F.obj X) :=
  prod.lift prod.fst (prod.snd ‚â´ (PreservesLimitPair.iso F X X).inv) ‚â´
    (PreservesLimitPair.iso F X (X ‚®Ø X)).inv  ‚â´ F.map h

end ObjOperation‚ÇÉ

namespace ObjOperation‚ÇÇ

variable {X : C} [HasBinaryProduct X X] [HasBinaryProduct X (X ‚®Ø X)]

def assoc (oper : ObjOperation‚ÇÇ X) : Prop :=
  prod.lift (prod.lift prod.fst (prod.snd ‚â´ prod.fst) ‚â´ oper) (prod.snd ‚â´ prod.snd) ‚â´ oper =
    prod.lift prod.fst (prod.snd ‚â´ oper)  ‚â´ oper

lemma assoc_iff (oper : ObjOperation‚ÇÇ X) :
    oper.assoc ‚Üî ((yonedaEquiv _) oper).assoc := by
  apply (ObjOperation‚ÇÉ.yonedaEquiv X).injective.eq_iff''
  ¬∑ apply (ObjOperation‚ÇÉ.yonedaEquiv X).symm.injective
    simp
    rfl
  ¬∑ apply (ObjOperation‚ÇÉ.yonedaEquiv X).symm.injective
    simp only [Equiv.symm_apply_apply, Types.functorConcat‚ÇÉ, Types.natTransConcat,
      Types.functorConcat_obj, yoneda_obj_obj, Types.functorPr‚ÇÉ‚ÇÅ_app, Types.functorPr‚ÇÉ‚ÇÇ_app,
      Types.functorPr‚ÇÉ‚ÇÉ_app, Prod.mk.eta, FunctorToTypes.comp,
      ObjOperation‚ÇÉ.yonedaEquiv, ObjOperation‚ÇÉ.yonedaEquiv', yonedaEquiv, yonedaEquiv']
    dsimp
    congr
    aesop_cat

/-- assoc_iff' -/
lemma assoc_iff' (oper : Types.functorOperation‚ÇÇ (yoneda.obj X)) :
    oper.assoc ‚Üî ((yonedaEquiv _).symm oper).assoc := by
  rw [assoc_iff, Equiv.apply_symm_apply]

lemma assoc.map {add : ObjOperation‚ÇÇ X} (h : add.assoc) (F : C ‚•§ D)
    [HasBinaryProduct (F.obj X) (F.obj X)] [PreservesLimit (pair X X) F]
    [HasBinaryProduct (F.obj X) (F.obj X ‚®Ø F.obj X)]
    [HasBinaryProduct (F.obj X) (F.obj (X ‚®Ø X))]
    [PreservesLimit (pair X (X ‚®Ø X)) F] :
  (add.map F).assoc := by
  dsimp only [assoc] at h ‚ä¢
  refine Eq.trans ?_ ((congr_arg (fun (f : ObjOperation‚ÇÉ X) => f.map F) h).trans ?_)
  ¬∑ dsimp [ObjOperation‚ÇÉ.map, ObjOperation‚ÇÇ.map]
    simp only [F.map_comp, ‚Üê Category.assoc]
    congr 1
    simp only [‚Üê cancel_mono (PreservesLimitPair.iso F X X).hom, Category.assoc, Iso.inv_hom_id,
      Category.comp_id]
    apply Limits.prod.hom_ext
    ¬∑ simp only [limit.lift_œÄ, BinaryFan.mk_pt, BinaryFan.œÄ_app_left, BinaryFan.mk_fst,
        PreservesLimitPair.iso_hom, Category.assoc, prodComparison_fst, ‚Üê F.map_comp]
      simp only [F.map_comp, ‚Üê Category.assoc]
      congr 1
      simp only [‚Üê cancel_mono (PreservesLimitPair.iso F X X).hom, Category.assoc, Iso.inv_hom_id,
        Category.comp_id]
      apply Limits.prod.hom_ext
      ¬∑ simp only [limit.lift_œÄ, BinaryFan.mk_pt, BinaryFan.œÄ_app_left, BinaryFan.mk_fst,
          PreservesLimitPair.iso_hom, Category.assoc, prodComparison_fst, ‚Üê F.map_comp,
          PreservesLimitPair.iso_inv_comp_map_fst]
      ¬∑ simp only [limit.lift_œÄ, BinaryFan.mk_pt, BinaryFan.œÄ_app_right, BinaryFan.mk_snd,
          PreservesLimitPair.iso_hom, Category.assoc, prodComparison_snd, ‚Üê F.map_comp]
        simp only [F.map_comp, PreservesLimitPair.iso_inv_comp_map_snd_assoc,
          limit.lift_œÄ_assoc, BinaryFan.mk_pt, pair_obj_right, BinaryFan.œÄ_app_right,
          BinaryFan.mk_snd, Category.assoc, PreservesLimitPair.iso_inv_comp_map_fst]
    ¬∑ simp only [limit.lift_œÄ, BinaryFan.mk_pt, BinaryFan.œÄ_app_right, BinaryFan.mk_snd,
        PreservesLimitPair.iso_hom, Category.assoc, prodComparison_snd, ‚Üê F.map_comp]
      simp only [Functor.map_comp, PreservesLimitPair.iso_inv_comp_map_snd_assoc,
        limit.lift_œÄ_assoc, BinaryFan.mk_pt, pair_obj_right, BinaryFan.œÄ_app_right,
        BinaryFan.mk_snd, Category.assoc, PreservesLimitPair.iso_inv_comp_map_snd]
  ¬∑ dsimp [ObjOperation‚ÇÉ.map, ObjOperation‚ÇÇ.map]
    simp only [F.map_comp, ‚Üê Category.assoc]
    congr 1
    simp only [‚Üê cancel_mono (PreservesLimitPair.iso F X X).hom, Category.assoc, Iso.inv_hom_id,
      Category.comp_id]
    apply Limits.prod.hom_ext
    ¬∑ simp only [PreservesLimitPair.iso_hom, Category.assoc, prodComparison_fst, ‚Üê F.map_comp,
        limit.lift_œÄ, BinaryFan.mk_pt, BinaryFan.œÄ_app_left, BinaryFan.mk_fst,
        PreservesLimitPair.iso_inv_comp_map_fst]
    ¬∑ simp only [PreservesLimitPair.iso_hom, Category.assoc, prodComparison_snd, limit.lift_œÄ,
        BinaryFan.mk_pt, BinaryFan.œÄ_app_right, BinaryFan.mk_snd, ‚Üê F.map_comp]
      simp only [F.map_comp, ‚Üê Category.assoc]
      congr 1
      simp only [‚Üê cancel_mono (PreservesLimitPair.iso F X X).hom, Category.assoc, Iso.inv_hom_id,
        Category.comp_id]
      apply Limits.prod.hom_ext
      ¬∑ simp
      ¬∑ simp

end ObjOperation‚ÇÇ

end Internal

end CategoryTheory
