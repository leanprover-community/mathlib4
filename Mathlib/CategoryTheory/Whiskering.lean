/-
Copyright (c) 2018 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison

! This file was ported from Lean 3 source module category_theory.whiskering
! leanprover-community/mathlib commit d012cd09a9b256d870751284dd6a29882b0be105
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Isomorphism
import Mathbin.CategoryTheory.Functor.Category
import Mathbin.CategoryTheory.Functor.FullyFaithful

/-!
# Whiskering

Given a functor `F  : C ‚•§ D` and functors `G H : D ‚•§ E` and a natural transformation `Œ± : G ‚ü∂ H`,
we can construct a new natural transformation `F ‚ãô G ‚ü∂ F ‚ãô H`,
called `whisker_left F Œ±`. This is the same as the horizontal composition of `ùüô F` with `Œ±`.

This operation is functorial in `F`, and we package this as `whiskering_left`. Here
`(whiskering_left.obj F).obj G` is `F ‚ãô G`, and
`(whiskering_left.obj F).map Œ±` is `whisker_left F Œ±`.
(That is, we might have alternatively named this as the "left composition functor".)

We also provide analogues for composition on the right, and for these operations on isomorphisms.

At the end of the file, we provide the left and right unitors, and the associator,
for functor composition.
(In fact functor composition is definitionally associative, but very often relying on this causes
extremely slow elaboration, so it is better to insert it explicitly.)
We also show these natural isomorphisms satisfy the triangle and pentagon identities.
-/


namespace CategoryTheory

universe u‚ÇÅ v‚ÇÅ u‚ÇÇ v‚ÇÇ u‚ÇÉ v‚ÇÉ u‚ÇÑ v‚ÇÑ

section

variable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D] {E : Type u‚ÇÉ}
  [Category.{v‚ÇÉ} E]

/-- If `Œ± : G ‚ü∂ H` then
`whisker_left F Œ± : (F ‚ãô G) ‚ü∂ (F ‚ãô H)` has components `Œ±.app (F.obj X)`.
-/
@[simps]
def whiskerLeft (F : C ‚•§ D) {G H : D ‚•§ E} (Œ± : G ‚ü∂ H) :
    F ‚ãô G ‚ü∂ F ‚ãô H where 
  app X := Œ±.app (F.obj X)
  naturality' X Y f := by rw [functor.comp_map, functor.comp_map, Œ±.naturality]
#align category_theory.whisker_left CategoryTheory.whiskerLeft

/-- If `Œ± : G ‚ü∂ H` then
`whisker_right Œ± F : (G ‚ãô F) ‚ü∂ (G ‚ãô F)` has components `F.map (Œ±.app X)`.
-/
@[simps]
def whiskerRight {G H : C ‚•§ D} (Œ± : G ‚ü∂ H) (F : D ‚•§ E) :
    G ‚ãô F ‚ü∂ H ‚ãô F where 
  app X := F.map (Œ±.app X)
  naturality' X Y f := by
    rw [functor.comp_map, functor.comp_map, ‚Üê F.map_comp, ‚Üê F.map_comp, Œ±.naturality]
#align category_theory.whisker_right CategoryTheory.whiskerRight

variable (C D E)

/-- Left-composition gives a functor `(C ‚•§ D) ‚•§ ((D ‚•§ E) ‚•§ (C ‚•§ E))`.

`(whiskering_left.obj F).obj G` is `F ‚ãô G`, and
`(whiskering_left.obj F).map Œ±` is `whisker_left F Œ±`.
-/
@[simps]
def whiskeringLeft :
    (C ‚•§ D) ‚•§
      (D ‚•§ E) ‚•§
        C ‚•§
          E where 
  obj F :=
    { obj := fun G => F ‚ãô G
      map := fun G H Œ± => whiskerLeft F Œ± }
  map F G œÑ :=
    { app := fun H =>
        { app := fun c => H.map (œÑ.app c)
          naturality' := fun X Y f => by dsimp; rw [‚Üê H.map_comp, ‚Üê H.map_comp, ‚Üê œÑ.naturality] }
      naturality' := fun X Y f => by ext; dsimp; rw [f.naturality] }
#align category_theory.whiskering_left CategoryTheory.whiskeringLeft

/-- Right-composition gives a functor `(D ‚•§ E) ‚•§ ((C ‚•§ D) ‚•§ (C ‚•§ E))`.

`(whiskering_right.obj H).obj F` is `F ‚ãô H`, and
`(whiskering_right.obj H).map Œ±` is `whisker_right Œ± H`.
-/
@[simps]
def whiskeringRight :
    (D ‚•§ E) ‚•§
      (C ‚•§ D) ‚•§
        C ‚•§
          E where 
  obj H :=
    { obj := fun F => F ‚ãô H
      map := fun _ _ Œ± => whiskerRight Œ± H }
  map G H œÑ :=
    { app := fun F =>
        { app := fun c => œÑ.app (F.obj c)
          naturality' := fun X Y f => by dsimp; rw [œÑ.naturality] }
      naturality' := fun X Y f => by ext; dsimp; rw [‚Üê nat_trans.naturality] }
#align category_theory.whiskering_right CategoryTheory.whiskeringRight

variable {C} {D} {E}

instance faithful_whiskering_right_obj {F : D ‚•§ E} [Faithful F] :
    Faithful
      ((whiskeringRight C D E).obj
        F) where map_injective' G H Œ± Œ≤ hŒ±Œ≤ :=
    NatTrans.ext _ _ <|
      funext fun X => Functor.map_injective _ <| congr_fun (congr_arg NatTrans.app hŒ±Œ≤) X
#align category_theory.faithful_whiskering_right_obj CategoryTheory.faithful_whiskering_right_obj

@[simp]
theorem whisker_left_id (F : C ‚•§ D) {G : D ‚•§ E} :
    whiskerLeft F (NatTrans.id G) = NatTrans.id (F.comp G) :=
  rfl
#align category_theory.whisker_left_id CategoryTheory.whisker_left_id

@[simp]
theorem whisker_left_id' (F : C ‚•§ D) {G : D ‚•§ E} : whiskerLeft F (ùüô G) = ùüô (F.comp G) :=
  rfl
#align category_theory.whisker_left_id' CategoryTheory.whisker_left_id'

@[simp]
theorem whisker_right_id {G : C ‚•§ D} (F : D ‚•§ E) :
    whiskerRight (NatTrans.id G) F = NatTrans.id (G.comp F) :=
  ((whiskeringRight C D E).obj F).map_id _
#align category_theory.whisker_right_id CategoryTheory.whisker_right_id

@[simp]
theorem whisker_right_id' {G : C ‚•§ D} (F : D ‚•§ E) : whiskerRight (ùüô G) F = ùüô (G.comp F) :=
  ((whiskeringRight C D E).obj F).map_id _
#align category_theory.whisker_right_id' CategoryTheory.whisker_right_id'

@[simp]
theorem whisker_left_comp (F : C ‚•§ D) {G H K : D ‚•§ E} (Œ± : G ‚ü∂ H) (Œ≤ : H ‚ü∂ K) :
    whiskerLeft F (Œ± ‚â´ Œ≤) = whiskerLeft F Œ± ‚â´ whiskerLeft F Œ≤ :=
  rfl
#align category_theory.whisker_left_comp CategoryTheory.whisker_left_comp

@[simp]
theorem whisker_right_comp {G H K : C ‚•§ D} (Œ± : G ‚ü∂ H) (Œ≤ : H ‚ü∂ K) (F : D ‚•§ E) :
    whiskerRight (Œ± ‚â´ Œ≤) F = whiskerRight Œ± F ‚â´ whiskerRight Œ≤ F :=
  ((whiskeringRight C D E).obj F).map_comp Œ± Œ≤
#align category_theory.whisker_right_comp CategoryTheory.whisker_right_comp

/-- If `Œ± : G ‚âÖ H` is a natural isomorphism then
`iso_whisker_left F Œ± : (F ‚ãô G) ‚âÖ (F ‚ãô H)` has components `Œ±.app (F.obj X)`.
-/
def isoWhiskerLeft (F : C ‚•§ D) {G H : D ‚•§ E} (Œ± : G ‚âÖ H) : F ‚ãô G ‚âÖ F ‚ãô H :=
  ((whiskeringLeft C D E).obj F).mapIso Œ±
#align category_theory.iso_whisker_left CategoryTheory.isoWhiskerLeft

@[simp]
theorem iso_whisker_left_hom (F : C ‚•§ D) {G H : D ‚•§ E} (Œ± : G ‚âÖ H) :
    (isoWhiskerLeft F Œ±).Hom = whiskerLeft F Œ±.Hom :=
  rfl
#align category_theory.iso_whisker_left_hom CategoryTheory.iso_whisker_left_hom

@[simp]
theorem iso_whisker_left_inv (F : C ‚•§ D) {G H : D ‚•§ E} (Œ± : G ‚âÖ H) :
    (isoWhiskerLeft F Œ±).inv = whiskerLeft F Œ±.inv :=
  rfl
#align category_theory.iso_whisker_left_inv CategoryTheory.iso_whisker_left_inv

/-- If `Œ± : G ‚âÖ H` then
`iso_whisker_right Œ± F : (G ‚ãô F) ‚âÖ (H ‚ãô F)` has components `F.map_iso (Œ±.app X)`.
-/
def isoWhiskerRight {G H : C ‚•§ D} (Œ± : G ‚âÖ H) (F : D ‚•§ E) : G ‚ãô F ‚âÖ H ‚ãô F :=
  ((whiskeringRight C D E).obj F).mapIso Œ±
#align category_theory.iso_whisker_right CategoryTheory.isoWhiskerRight

@[simp]
theorem iso_whisker_right_hom {G H : C ‚•§ D} (Œ± : G ‚âÖ H) (F : D ‚•§ E) :
    (isoWhiskerRight Œ± F).Hom = whiskerRight Œ±.Hom F :=
  rfl
#align category_theory.iso_whisker_right_hom CategoryTheory.iso_whisker_right_hom

@[simp]
theorem iso_whisker_right_inv {G H : C ‚•§ D} (Œ± : G ‚âÖ H) (F : D ‚•§ E) :
    (isoWhiskerRight Œ± F).inv = whiskerRight Œ±.inv F :=
  rfl
#align category_theory.iso_whisker_right_inv CategoryTheory.iso_whisker_right_inv

instance is_iso_whisker_left (F : C ‚•§ D) {G H : D ‚•§ E} (Œ± : G ‚ü∂ H) [IsIso Œ±] :
    IsIso (whiskerLeft F Œ±) :=
  IsIso.of_iso (isoWhiskerLeft F (asIso Œ±))
#align category_theory.is_iso_whisker_left CategoryTheory.is_iso_whisker_left

instance is_iso_whisker_right {G H : C ‚•§ D} (Œ± : G ‚ü∂ H) (F : D ‚•§ E) [IsIso Œ±] :
    IsIso (whiskerRight Œ± F) :=
  IsIso.of_iso (isoWhiskerRight (asIso Œ±) F)
#align category_theory.is_iso_whisker_right CategoryTheory.is_iso_whisker_right

variable {B : Type u‚ÇÑ} [Category.{v‚ÇÑ} B]

attribute [local elab_without_expected_type] whisker_left whisker_right

@[simp]
theorem whisker_left_twice (F : B ‚•§ C) (G : C ‚•§ D) {H K : D ‚•§ E} (Œ± : H ‚ü∂ K) :
    whiskerLeft F (whiskerLeft G Œ±) = whiskerLeft (F ‚ãô G) Œ± :=
  rfl
#align category_theory.whisker_left_twice CategoryTheory.whisker_left_twice

@[simp]
theorem whisker_right_twice {H K : B ‚•§ C} (F : C ‚•§ D) (G : D ‚•§ E) (Œ± : H ‚ü∂ K) :
    whiskerRight (whiskerRight Œ± F) G = whiskerRight Œ± (F ‚ãô G) :=
  rfl
#align category_theory.whisker_right_twice CategoryTheory.whisker_right_twice

theorem whisker_right_left (F : B ‚•§ C) {G H : C ‚•§ D} (Œ± : G ‚ü∂ H) (K : D ‚•§ E) :
    whiskerRight (whiskerLeft F Œ±) K = whiskerLeft F (whiskerRight Œ± K) :=
  rfl
#align category_theory.whisker_right_left CategoryTheory.whisker_right_left

end

namespace Functor

universe u‚ÇÖ v‚ÇÖ

variable {A : Type u‚ÇÅ} [Category.{v‚ÇÅ} A]

variable {B : Type u‚ÇÇ} [Category.{v‚ÇÇ} B]

/-- The left unitor, a natural isomorphism `((ùü≠ _) ‚ãô F) ‚âÖ F`.
-/
@[simps]
def leftUnitor (F : A ‚•§ B) :
    ùü≠ A ‚ãô F ‚âÖ F where 
  Hom := { app := fun X => ùüô (F.obj X) }
  inv := { app := fun X => ùüô (F.obj X) }
#align category_theory.functor.left_unitor CategoryTheory.Functor.leftUnitor

/-- The right unitor, a natural isomorphism `(F ‚ãô (ùü≠ B)) ‚âÖ F`.
-/
@[simps]
def rightUnitor (F : A ‚•§ B) :
    F ‚ãô ùü≠ B ‚âÖ F where 
  Hom := { app := fun X => ùüô (F.obj X) }
  inv := { app := fun X => ùüô (F.obj X) }
#align category_theory.functor.right_unitor CategoryTheory.Functor.rightUnitor

variable {C : Type u‚ÇÉ} [Category.{v‚ÇÉ} C]

variable {D : Type u‚ÇÑ} [Category.{v‚ÇÑ} D]

/-- The associator for functors, a natural isomorphism `((F ‚ãô G) ‚ãô H) ‚âÖ (F ‚ãô (G ‚ãô H))`.

(In fact, `iso.refl _` will work here, but it tends to make Lean slow later,
and it's usually best to insert explicit associators.)
-/
@[simps]
def associator (F : A ‚•§ B) (G : B ‚•§ C) (H : C ‚•§ D) :
    (F ‚ãô G) ‚ãô H ‚âÖ F ‚ãô G ‚ãô H where 
  Hom := { app := fun _ => ùüô _ }
  inv := { app := fun _ => ùüô _ }
#align category_theory.functor.associator CategoryTheory.Functor.associator

@[protected]
theorem assoc (F : A ‚•§ B) (G : B ‚•§ C) (H : C ‚•§ D) : (F ‚ãô G) ‚ãô H = F ‚ãô G ‚ãô H :=
  rfl
#align category_theory.functor.assoc CategoryTheory.Functor.assoc

theorem triangle (F : A ‚•§ B) (G : B ‚•§ C) :
    (associator F (ùü≠ B) G).Hom ‚â´ whiskerLeft F (leftUnitor G).Hom =
      whiskerRight (rightUnitor F).Hom G :=
  by 
  ext
  dsimp
  simp
#align category_theory.functor.triangle CategoryTheory.Functor.triangle

-- See note [dsimp, simp].
variable {E : Type u‚ÇÖ} [Category.{v‚ÇÖ} E]

variable (F : A ‚•§ B) (G : B ‚•§ C) (H : C ‚•§ D) (K : D ‚•§ E)

theorem pentagon :
    whiskerRight (associator F G H).Hom K ‚â´
        (associator F (G ‚ãô H) K).Hom ‚â´ whiskerLeft F (associator G H K).Hom =
      (associator (F ‚ãô G) H K).Hom ‚â´ (associator F G (H ‚ãô K)).Hom :=
  by 
  ext
  dsimp
  simp
#align category_theory.functor.pentagon CategoryTheory.Functor.pentagon

end Functor

end CategoryTheory

