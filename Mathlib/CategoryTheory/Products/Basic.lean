/-
Copyright (c) 2017 Kim Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Stephen Morgan, Kim Morrison
-/
import Mathlib.CategoryTheory.Functor.Const
import Mathlib.CategoryTheory.Opposites
import Mathlib.Data.Prod.Basic

/-!
# Cartesian products of categories

We define the category instance on `C √ó D` when `C` and `D` are categories.

We define:
* `sectL C Z` : the functor `C ‚•§ C √ó D` given by `X ‚Ü¶ ‚ü®X, Z‚ü©`
* `sectR Z D` : the functor `D ‚•§ C √ó D` given by `Y ‚Ü¶ ‚ü®Z, Y‚ü©`
* `fst`       : the functor `‚ü®X, Y‚ü© ‚Ü¶ X`
* `snd`       : the functor `‚ü®X, Y‚ü© ‚Ü¶ Y`
* `swap`      : the functor `C √ó D ‚•§ D √ó C` given by `‚ü®X, Y‚ü© ‚Ü¶ ‚ü®Y, X‚ü©`
    (and the fact this is an equivalence)

We further define `evaluation : C ‚•§ (C ‚•§ D) ‚•§ D` and `evaluationUncurried : C √ó (C ‚•§ D) ‚•§ D`,
and products of functors and natural transformations, written `F.prod G` and `Œ±.prod Œ≤`.
-/


namespace CategoryTheory

open Functor

-- declare the `v`'s first; see `CategoryTheory.Category` for an explanation
universe v‚ÇÅ v‚ÇÇ v‚ÇÉ v‚ÇÑ u‚ÇÅ u‚ÇÇ u‚ÇÉ u‚ÇÑ

section

variable (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] (D : Type u‚ÇÇ) [Category.{v‚ÇÇ} D]

-- the generates simp lemmas like `id_fst` and `comp_snd`
/-- `prod C D` gives the Cartesian product of two categories. -/
@[simps (notRecursive := []) Hom id_fst id_snd comp_fst comp_snd, stacks 001K]
instance prod : Category.{max v‚ÇÅ v‚ÇÇ} (C √ó D) where
  Hom X Y := (X.1 ‚ü∂ Y.1) √ó (X.2 ‚ü∂ Y.2)
  id X := ‚ü®ùüô X.1, ùüô X.2‚ü©
  comp f g := (f.1 ‚â´ g.1, f.2 ‚â´ g.2)

@[ext]
lemma prod.hom_ext {X Y : C √ó D} {f g : X ‚ü∂ Y} (h‚ÇÅ : f.1 = g.1) (h‚ÇÇ : f.2 = g.2) : f = g := by
  dsimp
  ext <;> assumption

/-- Two rfl lemmas that cannot be generated by `@[simps]`. -/
@[simp]
theorem prod_id (X : C) (Y : D) : ùüô (X, Y) = (ùüô X, ùüô Y) :=
  rfl

@[simp]
theorem prod_comp {P Q R : C} {S T U : D} (f : (P, S) ‚ü∂ (Q, T)) (g : (Q, T) ‚ü∂ (R, U)) :
    f ‚â´ g = (f.1 ‚â´ g.1, f.2 ‚â´ g.2) :=
  rfl

namespace Prod

variable {C D} in
/-- Construct a morphism in a product category by giving its constituent components.
This constructor should be preferred over `Prod.mk`, because lean infers better the
source and target of the resulting morphism. -/
abbrev mkHom {X‚ÇÅ X‚ÇÇ : C} {Y‚ÇÅ Y‚ÇÇ : D} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) (g : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) : (X‚ÇÅ, Y‚ÇÅ) ‚ü∂ (X‚ÇÇ, Y‚ÇÇ) :=
  ‚ü®f, g‚ü©

@[inherit_doc Prod.mkHom]
scoped infixr:70 " √ó‚Çò " => Prod.mkHom

end Prod

-- TODO: is there a nice way to fix the non-terminal simp?
set_option linter.flexible false in
theorem isIso_prod_iff {P Q : C} {S T : D} {f : (P, S) ‚ü∂ (Q, T)} :
    IsIso f ‚Üî IsIso f.1 ‚àß IsIso f.2 := by
  constructor
  ¬∑ rintro ‚ü®g, hfg, hgf‚ü©
    simp? at hfg hgf says simp only [prod_Hom, prod_comp, prod_id, Prod.mk.injEq] at hfg hgf
    rcases hfg with ‚ü®hfg‚ÇÅ, hfg‚ÇÇ‚ü©
    rcases hgf with ‚ü®hgf‚ÇÅ, hgf‚ÇÇ‚ü©
    exact ‚ü®‚ü®‚ü®g.1, hfg‚ÇÅ, hgf‚ÇÅ‚ü©‚ü©, ‚ü®‚ü®g.2, hfg‚ÇÇ, hgf‚ÇÇ‚ü©‚ü©‚ü©
  ¬∑ rintro ‚ü®‚ü®g‚ÇÅ, hfg‚ÇÅ, hgf‚ÇÅ‚ü©, ‚ü®g‚ÇÇ, hfg‚ÇÇ, hgf‚ÇÇ‚ü©‚ü©
    dsimp at hfg‚ÇÅ hgf‚ÇÅ hfg‚ÇÇ hgf‚ÇÇ
    refine ‚ü®‚ü®(g‚ÇÅ, g‚ÇÇ), ?_, ?_‚ü©‚ü©
    repeat { simp; constructor; assumption; assumption }

section

variable {C D}

/-- The isomorphism between `(X.1, X.2)` and `X`. -/
@[simps]
def prod.etaIso (X : C √ó D) : (X.1, X.2) ‚âÖ X where
  hom := (ùüô _, ùüô _)
  inv := (ùüô _, ùüô _)

/-- Construct an isomorphism in `C √ó D` out of two isomorphisms in `C` and `D`. -/
@[simps]
def Iso.prod {P Q : C} {S T : D} (f : P ‚âÖ Q) (g : S ‚âÖ T) : (P, S) ‚âÖ (Q, T) where
  hom := (f.hom, g.hom)
  inv := (f.inv, g.inv)

end

end

section

variable (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] (D : Type u‚ÇÅ) [Category.{v‚ÇÅ} D]

/-- `Category.uniformProd C D` is an additional instance specialised so both factors have the same
universe levels. This helps typeclass resolution.
-/
instance uniformProd : Category (C √ó D) :=
  CategoryTheory.prod C D

end

-- Next we define the natural functors into and out of product categories. For now this doesn't
-- address the universal properties.
namespace Prod

/-- `sectL C Z` is the functor `C ‚•§ C √ó D` given by `X ‚Ü¶ (X, Z)`. -/
@[simps]
def sectL (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D] (Z : D) : C ‚•§ C √ó D where
  obj X := (X, Z)
  map f := (f, ùüô Z)

/-- `sectR Z D` is the functor `D ‚•§ C √ó D` given by `Y ‚Ü¶ (Z, Y)` . -/
@[simps]
def sectR {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] (Z : C) (D : Type u‚ÇÇ) [Category.{v‚ÇÇ} D] : D ‚•§ C √ó D where
  obj X := (Z, X)
  map f := (ùüô Z, f)

variable (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] (D : Type u‚ÇÇ) [Category.{v‚ÇÇ} D]

/-- `fst` is the functor `(X, Y) ‚Ü¶ X`. -/
@[simps]
def fst : C √ó D ‚•§ C where
  obj X := X.1
  map f := f.1

/-- `snd` is the functor `(X, Y) ‚Ü¶ Y`. -/
@[simps]
def snd : C √ó D ‚•§ D where
  obj X := X.2
  map f := f.2

/-- The functor swapping the factors of a Cartesian product of categories, `C √ó D ‚•§ D √ó C`. -/
@[simps]
def swap : C √ó D ‚•§ D √ó C where
  obj X := (X.2, X.1)
  map f := (f.2, f.1)

/-- Swapping the factors of a Cartesian product of categories twice is naturally isomorphic
to the identity functor.
-/
@[simps]
def symmetry : swap C D ‚ãô swap D C ‚âÖ ùü≠ (C √ó D) where
  hom := { app := fun X => ùüô X }
  inv := { app := fun X => ùüô X }

/-- The equivalence, given by swapping factors, between `C √ó D` and `D √ó C`.
-/
@[simps]
def braiding : C √ó D ‚âå D √ó C where
  functor := swap C D
  inverse := swap D C
  unitIso := Iso.refl _
  counitIso := Iso.refl _

instance swapIsEquivalence : (swap C D).IsEquivalence :=
  (by infer_instance : (braiding C D).functor.IsEquivalence)

variable {C D}

/-- Any morphism in a product factors as a morphism whose left component is an identity
followed by a morphism whose right component is an identity. -/
@[reassoc]
lemma fac {x y : C √ó D} (f : x ‚ü∂ y) : f = (ùüô x.1 √ó‚Çò f.2) ‚â´ (f.1 √ó‚Çò (ùüô y.2)) := by simp

/-- Any morphism in a product factors as a morphism whose right component is an identity
followed by a morphism whose left component is an identity. -/
@[reassoc]
lemma fac' {x y : C √ó D} (f : x ‚ü∂ y) : f = (f.1 √ó‚Çò ùüô x.2) ‚â´ ((ùüô y.1) √ó‚Çò f.2) := by simp

end Prod

section

variable (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] (D : Type u‚ÇÇ) [Category.{v‚ÇÇ} D]

/-- The "evaluation at `X`" functor, such that
`(evaluation.obj X).obj F = F.obj X`,
which is functorial in both `X` and `F`.
-/
@[simps]
def evaluation : C ‚•§ (C ‚•§ D) ‚•§ D where
  obj X :=
    { obj := fun F => F.obj X
      map := fun Œ± => Œ±.app X }
  map {_} {_} f :=
    { app := fun F => F.map f }

/-- The "evaluation of `F` at `X`" functor,
as a functor `C √ó (C ‚•§ D) ‚•§ D`.
-/
@[simps]
def evaluationUncurried : C √ó (C ‚•§ D) ‚•§ D where
  obj p := p.2.obj p.1
  map := fun {x} {y} f => x.2.map f.1 ‚â´ f.2.app y.1

variable {C}

/-- The constant functor followed by the evaluation functor is just the identity. -/
@[simps!]
def Functor.constCompEvaluationObj (X : C) : Functor.const C ‚ãô (evaluation C D).obj X ‚âÖ ùü≠ D :=
  NatIso.ofComponents fun _ => Iso.refl _

end

variable {A : Type u‚ÇÅ} [Category.{v‚ÇÅ} A] {B : Type u‚ÇÇ} [Category.{v‚ÇÇ} B] {C : Type u‚ÇÉ}
  [Category.{v‚ÇÉ} C] {D : Type u‚ÇÑ} [Category.{v‚ÇÑ} D]

namespace Functor

/-- The Cartesian product of two functors. -/
@[simps]
def prod (F : A ‚•§ B) (G : C ‚•§ D) : A √ó C ‚•§ B √ó D where
  obj X := (F.obj X.1, G.obj X.2)
  map f := (F.map f.1, G.map f.2)

/- Because of limitations in Lean 3's handling of notations, we do not setup a notation `F √ó G`.
You can use `F.prod G` as a "poor man's infix", or just write `functor.prod F G`. -/
/-- Similar to `prod`, but both functors start from the same category `A` -/
@[simps]
def prod' (F : A ‚•§ B) (G : A ‚•§ C) : A ‚•§ B √ó C where
  obj a := (F.obj a, G.obj a)
  map f := (F.map f, G.map f)

/-- The product `F.prod' G` followed by projection on the first component is isomorphic to `F` -/
@[simps!]
def prod'CompFst (F : A ‚•§ B) (G : A ‚•§ C) : F.prod' G ‚ãô CategoryTheory.Prod.fst B C ‚âÖ F :=
  NatIso.ofComponents fun _ => Iso.refl _

/-- The product `F.prod' G` followed by projection on the second component is isomorphic to `G` -/
@[simps!]
def prod'CompSnd (F : A ‚•§ B) (G : A ‚•§ C) : F.prod' G ‚ãô CategoryTheory.Prod.snd B C ‚âÖ G :=
  NatIso.ofComponents fun _ => Iso.refl _

section

variable (C)

/-- The diagonal functor. -/
@[simps! obj map]
def diag : C ‚•§ C √ó C :=
  (ùü≠ C).prod' (ùü≠ C)

end

end Functor

namespace NatTrans

/-- The Cartesian product of two natural transformations. -/
@[simps! app_fst app_snd]
def prod {F G : A ‚•§ B} {H I : C ‚•§ D} (Œ± : F ‚ü∂ G) (Œ≤ : H ‚ü∂ I) : F.prod H ‚ü∂ G.prod I where
  app X := (Œ±.app X.1, Œ≤.app X.2)

/- Again, it is inadvisable in Lean 3 to setup a notation `Œ± √ó Œ≤`;
use instead `Œ±.prod Œ≤` or `NatTrans.prod Œ± Œ≤`. -/

/-- The Cartesian product of two natural transformations where both functors have the
same source. -/
@[simps! app_fst app_snd]
def prod' {F G : A ‚•§ B} {H K : A ‚•§ C} (Œ± : F ‚ü∂ G) (Œ≤ : H ‚ü∂ K) : F.prod' H ‚ü∂ G.prod' K where
  app X := (Œ±.app X, Œ≤.app X)

end NatTrans

/-- The Cartesian product functor between functor categories -/
@[simps]
def prodFunctor : (A ‚•§ B) √ó (C ‚•§ D) ‚•§ A √ó C ‚•§ B √ó D where
  obj FG := FG.1.prod FG.2
  map nm := NatTrans.prod nm.1 nm.2

namespace NatIso

/-- The Cartesian product of two natural isomorphisms. -/
@[simps]
def prod {F F' : A ‚•§ B} {G G' : C ‚•§ D} (e‚ÇÅ : F ‚âÖ F') (e‚ÇÇ : G ‚âÖ G') :
    F.prod G ‚âÖ F'.prod G' where
  hom := NatTrans.prod e‚ÇÅ.hom e‚ÇÇ.hom
  inv := NatTrans.prod e‚ÇÅ.inv e‚ÇÇ.inv

end NatIso

namespace Equivalence

/-- The Cartesian product of two equivalences of categories. -/
@[simps]
def prod (E‚ÇÅ : A ‚âå B) (E‚ÇÇ : C ‚âå D) : A √ó C ‚âå B √ó D where
  functor := E‚ÇÅ.functor.prod E‚ÇÇ.functor
  inverse := E‚ÇÅ.inverse.prod E‚ÇÇ.inverse
  unitIso := NatIso.prod E‚ÇÅ.unitIso E‚ÇÇ.unitIso
  counitIso := NatIso.prod E‚ÇÅ.counitIso E‚ÇÇ.counitIso

end Equivalence

/-- `F.flip` composed with evaluation is the same as evaluating `F`. -/
@[simps!]
def flipCompEvaluation (F : A ‚•§ B ‚•§ C) (a) : F.flip ‚ãô (evaluation _ _).obj a ‚âÖ F.obj a :=
  NatIso.ofComponents fun b => Iso.refl _

theorem flip_comp_evaluation (F : A ‚•§ B ‚•§ C) (a) : F.flip ‚ãô (evaluation _ _).obj a = F.obj a :=
  rfl

/-- `F` composed with evaluation is the same as evaluating `F.flip`. -/
@[simps!]
def compEvaluation (F : A ‚•§ B ‚•§ C) (b) : F ‚ãô (evaluation _ _).obj b ‚âÖ F.flip.obj b :=
  NatIso.ofComponents fun a => Iso.refl _

theorem comp_evaluation (F : A ‚•§ B ‚•§ C) (b) : F ‚ãô (evaluation _ _).obj b = F.flip.obj b :=
  rfl

/-- Whiskering by `F` and then evaluating at `a` is the same as evaluating at `F.obj a`. -/
@[simps!]
def whiskeringLeftCompEvaluation (F : A ‚•§ B) (a : A) :
    (whiskeringLeft A B C).obj F ‚ãô (evaluation A C).obj a ‚âÖ (evaluation B C).obj (F.obj a) :=
  Iso.refl _

/-- Whiskering by `F` and then evaluating at `a` is the same as evaluating at `F.obj a`. -/
@[simp]
theorem whiskeringLeft_comp_evaluation (F : A ‚•§ B) (a : A) :
    (whiskeringLeft A B C).obj F ‚ãô (evaluation A C).obj a = (evaluation B C).obj (F.obj a) :=
  rfl

/-- Whiskering by `F` and then evaluating at `a` is the same as evaluating at `F` and then
applying `F`. -/
@[simps!]
def whiskeringRightCompEvaluation (F : B ‚•§ C) (a : A) :
    (whiskeringRight A B C).obj F ‚ãô (evaluation _ _).obj a ‚âÖ (evaluation _ _).obj a ‚ãô F :=
  Iso.refl _

/-- Whiskering by `F` and then evaluating at `a` is the same as evaluating at `F` and then
applying `F`. -/
@[simp]
theorem whiskeringRight_comp_evaluation (F : B ‚•§ C) (a : A) :
    (whiskeringRight A B C).obj F ‚ãô (evaluation _ _).obj a = (evaluation _ _).obj a ‚ãô F :=
  rfl

variable (A B C)

/-- The forward direction for `functorProdFunctorEquiv` -/
@[simps]
def prodFunctorToFunctorProd : (A ‚•§ B) √ó (A ‚•§ C) ‚•§ A ‚•§ B √ó C where
  obj F := F.1.prod' F.2
  map {F G} f := NatTrans.prod' f.1 f.2

/-- The backward direction for `functorProdFunctorEquiv` -/
@[simps]
def functorProdToProdFunctor : (A ‚•§ B √ó C) ‚•§ (A ‚•§ B) √ó (A ‚•§ C) where
  obj F := ‚ü®F ‚ãô CategoryTheory.Prod.fst B C, F ‚ãô CategoryTheory.Prod.snd B C‚ü©
  map Œ± := ‚ü®whiskerRight Œ± _, whiskerRight Œ± _‚ü©

/-- The unit isomorphism for `functorProdFunctorEquiv` -/
@[simps!]
def functorProdFunctorEquivUnitIso :
    ùü≠ _ ‚âÖ prodFunctorToFunctorProd A B C ‚ãô functorProdToProdFunctor A B C :=
  NatIso.ofComponents fun F =>
    Functor.prod'CompFst F.fst F.snd |>.prod (Functor.prod'CompSnd F.fst F.snd) |>.trans
      (prod.etaIso F) |>.symm

/-- The counit isomorphism for `functorProdFunctorEquiv` -/
@[simps!]
def functorProdFunctorEquivCounitIso :
    functorProdToProdFunctor A B C ‚ãô prodFunctorToFunctorProd A B C ‚âÖ ùü≠ _ :=
  NatIso.ofComponents fun F => NatIso.ofComponents fun X => prod.etaIso (F.obj X)

/-- The equivalence of categories between `(A ‚•§ B) √ó (A ‚•§ C)` and `A ‚•§ (B √ó C)` -/
@[simps]
def functorProdFunctorEquiv : (A ‚•§ B) √ó (A ‚•§ C) ‚âå A ‚•§ B √ó C :=
  { functor := prodFunctorToFunctorProd A B C,
    inverse := functorProdToProdFunctor A B C,
    unitIso := functorProdFunctorEquivUnitIso A B C,
    counitIso := functorProdFunctorEquivCounitIso A B C, }

section Opposite

open Opposite

/-- The equivalence between the opposite of a product and the product of the opposites. -/
@[simps!]
def prodOpEquiv : (C √ó D)·µí·µñ ‚âå C·µí·µñ √ó D·µí·µñ where
  functor :=
    { obj := fun X ‚Ü¶ ‚ü®op X.unop.1, op X.unop.2‚ü©,
      map := fun f ‚Ü¶ ‚ü®f.unop.1.op, f.unop.2.op‚ü© }
  inverse :=
    { obj := fun ‚ü®X,Y‚ü© ‚Ü¶ op ‚ü®X.unop, Y.unop‚ü©,
      map := fun ‚ü®f,g‚ü© ‚Ü¶ op ‚ü®f.unop, g.unop‚ü© }
  unitIso := Iso.refl _
  counitIso := Iso.refl _

end Opposite

end CategoryTheory
