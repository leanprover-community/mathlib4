/-
Copyright (c) 2023 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathlib.CategoryTheory.Triangulated.Basic
import Mathlib.CategoryTheory.Triangulated.Opposite.Basic

/-!
# Triangles in the opposite category of a (pre)triangulated category

Let `C` be a (pre)triangulated category.
In `CategoryTheory.Triangulated.Opposite.Basic`, we have constructed
a shift on `C·µí·µñ` that will be part of a structure of (pre)triangulated
category. In this file, we construct an equivalence of categories
between `(Triangle C)·µí·µñ` and `Triangle C·µí·µñ`, called
`CategoryTheory.Pretriangulated.triangleOpEquivalence`. It sends a triangle
`X ‚ü∂ Y ‚ü∂ Z ‚ü∂ X‚ü¶1‚üß` in `C` to the triangle `op Z ‚ü∂ op Y ‚ü∂ op X ‚ü∂ (op Z)‚ü¶1‚üß` in `C·µí·µñ`
(without introducing signs).

## References
* [Jean-Louis Verdier, *Des cat√©gories d√©riv√©es des cat√©gories ab√©liennes*][verdier1996]

-/

namespace CategoryTheory.Pretriangulated

open Category Limits Preadditive ZeroObject Opposite

variable (C : Type*) [Category C] [HasShift C ‚Ñ§]

namespace TriangleOpEquivalence

/-- The functor which sends a triangle `X ‚ü∂ Y ‚ü∂ Z ‚ü∂ X‚ü¶1‚üß` in `C` to the triangle
`op Z ‚ü∂ op Y ‚ü∂ op X ‚ü∂ (op Z)‚ü¶1‚üß` in `C·µí·µñ` (without introducing signs). -/
@[simps]
noncomputable def functor : (Triangle C)·µí·µñ ‚•§ Triangle C·µí·µñ where
  obj T := Triangle.mk T.unop.mor‚ÇÇ.op T.unop.mor‚ÇÅ.op
      ((opShiftFunctorEquivalence C 1).counitIso.inv.app (Opposite.op T.unop.obj‚ÇÅ) ‚â´
        T.unop.mor‚ÇÉ.op‚ü¶(1 : ‚Ñ§)‚üß')
  map {T‚ÇÅ T‚ÇÇ} œÜ :=
    { hom‚ÇÅ := œÜ.unop.hom‚ÇÉ.op
      hom‚ÇÇ := œÜ.unop.hom‚ÇÇ.op
      hom‚ÇÉ := œÜ.unop.hom‚ÇÅ.op
      comm‚ÇÅ := Quiver.Hom.unop_inj œÜ.unop.comm‚ÇÇ.symm
      comm‚ÇÇ := Quiver.Hom.unop_inj œÜ.unop.comm‚ÇÅ.symm
      comm‚ÇÉ := by
        dsimp
        rw [assoc, ‚Üê Functor.map_comp, ‚Üê op_comp, ‚Üê œÜ.unop.comm‚ÇÉ, op_comp, Functor.map_comp,
          opShiftFunctorEquivalence_counitIso_inv_naturality_assoc]
        rfl }

/-- The functor which sends a triangle `X ‚ü∂ Y ‚ü∂ Z ‚ü∂ X‚ü¶1‚üß` in `C·µí·µñ` to the triangle
`Z.unop ‚ü∂ Y.unop ‚ü∂ X.unop ‚ü∂ Z.unop‚ü¶1‚üß` in `C` (without introducing signs). -/
@[simps]
noncomputable def inverse : Triangle C·µí·µñ ‚•§ (Triangle C)·µí·µñ where
  obj T := Opposite.op (Triangle.mk T.mor‚ÇÇ.unop T.mor‚ÇÅ.unop
      (((opShiftFunctorEquivalence C 1).unitIso.inv.app T.obj‚ÇÅ).unop ‚â´ T.mor‚ÇÉ.unop‚ü¶(1 : ‚Ñ§)‚üß'))
  map {T‚ÇÅ T‚ÇÇ} œÜ := Quiver.Hom.op
    { hom‚ÇÅ := œÜ.hom‚ÇÉ.unop
      hom‚ÇÇ := œÜ.hom‚ÇÇ.unop
      hom‚ÇÉ := œÜ.hom‚ÇÅ.unop
      comm‚ÇÅ := Quiver.Hom.op_inj œÜ.comm‚ÇÇ.symm
      comm‚ÇÇ := Quiver.Hom.op_inj œÜ.comm‚ÇÅ.symm
      comm‚ÇÉ := Quiver.Hom.op_inj (by
        dsimp
        rw [assoc, ‚Üê opShiftFunctorEquivalence_unitIso_inv_naturality,
          ‚Üê op_comp_assoc, ‚Üê Functor.map_comp, ‚Üê unop_comp, ‚Üê œÜ.comm‚ÇÉ,
          unop_comp, Functor.map_comp, op_comp, assoc]) }

/-- The unit isomorphism of the
equivalence `triangleOpEquivalence C : (Triangle C)·µí·µñ ‚âå Triangle C·µí·µñ` . -/
@[simps!]
noncomputable def unitIso : ùü≠ _ ‚âÖ functor C ‚ãô inverse C :=
  NatIso.ofComponents (fun T => Iso.op
    (Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) (by simp) (by simp)
      (Quiver.Hom.op_inj
        (by simp [shift_unop_opShiftFunctorEquivalence_counitIso_inv_app]))))
    (fun {T‚ÇÅ T‚ÇÇ} f => Quiver.Hom.unop_inj (by aesop_cat))

/-- The counit isomorphism of the
equivalence `triangleOpEquivalence C : (Triangle C)·µí·µñ ‚âå Triangle C·µí·µñ` . -/
@[simps!]
noncomputable def counitIso : inverse C ‚ãô functor C ‚âÖ ùü≠ _ :=
  NatIso.ofComponents (fun T => by
    refine Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) ?_ ?_ ?_
    ¬∑ simp
    ¬∑ simp
    ¬∑ dsimp
      rw [Functor.map_id, comp_id, id_comp, Functor.map_comp,
        ‚Üê opShiftFunctorEquivalence_counitIso_inv_naturality_assoc,
        opShiftFunctorEquivalence_counitIso_inv_app_shift, ‚Üê Functor.map_comp,
        Iso.hom_inv_id_app, Functor.map_id]
      simp only [Functor.id_obj, comp_id])
    (by aesop_cat)

end TriangleOpEquivalence

/-- An anti-equivalence between the categories of triangles in `C` and in `C·µí·µñ`.
A triangle in `C·µí·µñ` shall be distinguished iff it correspond to a distinguished
triangle in `C` via this equivalence. -/
@[simps]
noncomputable def triangleOpEquivalence :
    (Triangle C)·µí·µñ ‚âå Triangle C·µí·µñ where
  functor := TriangleOpEquivalence.functor C
  inverse := TriangleOpEquivalence.inverse C
  unitIso := TriangleOpEquivalence.unitIso C
  counitIso := TriangleOpEquivalence.counitIso C

end CategoryTheory.Pretriangulated
