/-
Copyright (c) 2025 Dagur Asgeirsson. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Dagur Asgeirsson
-/
import Mathlib.CategoryTheory.Localization.Trifunctor
import Mathlib.CategoryTheory.Monoidal.Multifunctor
import Mathlib.CategoryTheory.Monoidal.NaturalTransformation

/-!

# Universal property of localized monoidal categories

This file proves that, given a monoidal localization functor `L : C ⥤ D`, and a functor
`F : D ⥤ E` to a monoidal category, such that `L ⋙ F` is monoidal, then `F` is monoidal. See
`CategoryTheory.Localization.Monoidal.functorMonoidalOfComp`.
-/

universe u

namespace CategoryTheory

open CategoryTheory MonoidalCategory Functor Monoidal LaxMonoidal OplaxMonoidal

namespace Localization.Monoidal

variable {C D E : Type*} [Category C] [Category D] [Category E]
  [MonoidalCategory C] [MonoidalCategory D] [MonoidalCategory E]
  (L : C ⥤ D) (W : MorphismProperty C) [L.IsLocalization W] [L.Monoidal]
  (F : D ⥤ E) (G : C ⥤ E) [G.Monoidal] [W.ContainsIdentities] [Lifting L W G F]

@[simps]
instance lifting₂CurriedTensorPre :
    Lifting₂ L L W W (curriedTensorPre G) (curriedTensorPre F) where
  iso := curriedTensorPreFunctor.mapIso (Lifting.iso L W G F)

@[simps]
instance lifting₂CurriedTensorPost :
    Lifting₂ L L W W (curriedTensorPost G) (curriedTensorPost F) where
  iso := (postcompose₂.obj F).mapIso (curriedTensorPreIsoPost L) ≪≫
    curriedTensorPostFunctor.mapIso (Lifting.iso L W G F)

/--
The natural isomorphism of bifunctors `F - ⊗ F - ≅ F (- ⊗ -)`, given that `L ⋙ F` is monoidal.
-/
noncomputable def curriedTensorPreIsoPost : curriedTensorPre F ≅ curriedTensorPost F :=
  lift₂NatIso L L W W (curriedTensorPre G) (curriedTensorPost G) _ _
    (Functor.curriedTensorPreIsoPost G)

@[reassoc]
lemma curriedTensorPreIsoPost_hom_app_app (X Y : C) :
    letI e := Lifting.iso L W G F
    letI : (L ⋙ F).Monoidal := transport e.symm
    ((curriedTensorPreIsoPost L W F G).hom.app (L.obj X)).app (L.obj Y) =
      μ (L ⋙ F) X Y ≫ F.map (δ L X Y) := by
  simp [curriedTensorPreIsoPost, transport_μ]

@[reassoc]
lemma curriedTensorPreIsoPost_hom_app_app' {X₁ X₂ : C} {Y₁ Y₂ : D} (e₁ : Y₁ ≅ L.obj X₁)
    (e₂ : Y₂ ≅ L.obj X₂) :
    letI e := Lifting.iso L W G F
    letI : (L ⋙ F).Monoidal := transport e.symm
    ((curriedTensorPreIsoPost L W F G).hom.app Y₁).app Y₂ =
      (F.map e₁.hom ⊗ₘ F.map e₂.hom) ≫ μ (L ⋙ F) X₁ X₂ ≫
        F.map (δ L _ _≫ (e₁.inv ⊗ₘ e₂.inv)) := by
  have h₁ := ((curriedTensorPreIsoPost L W F G).hom.app Y₁).naturality e₂.hom
  have h₂ := congr_app ((curriedTensorPreIsoPost L W F G).hom.naturality e₁.hom)
  dsimp at h₁ h₂ ⊢
  rw [← cancel_mono (F.map (Y₁ ◁ e₂.hom)), ← h₁, ← cancel_mono (F.map (e₁.hom ▷ L.obj X₂)),
    Category.assoc, ← h₂, curriedTensorPreIsoPost_hom_app_app]
  simp [← tensorHom_def'_assoc, ← Functor.map_comp, ← tensorHom_def']


/--
Monoidal structure on `F`, given that `L ⋙ F` is monoidal, where `L` is a localization functor.
-/
@[simps!]
noncomputable def functorCoreMonoidalOfComp : F.CoreMonoidal := by
  letI e := Lifting.iso L W G F
  letI : (L ⋙ F).Monoidal := transport e.symm
  refine Functor.CoreMonoidal.ofBifunctor (εIso (L ⋙ F) ≪≫ F.mapIso (εIso L).symm)
    (curriedTensorPreIsoPost L W F G) ?_ ?_ ?_
  · apply natTrans₃_ext L L L W W W (fun X Y Z ↦ ?_)
    dsimp
    rw [curriedTensorPreIsoPost_hom_app_app, curriedTensorPreIsoPost_hom_app_app,
      curriedTensorPreIsoPost_hom_app_app' L W F G (μIso L _ _) (Iso.refl _),
      curriedTensorPreIsoPost_hom_app_app' L W F G (Iso.refl _) (μIso L _ _)]
    -- generated by:
    -- `simp? [← MonoidalCategory.whiskerLeft_comp_assoc, ← comp_whiskerRight_assoc, ← map_comp]`
    simp only [comp_obj, CoreMonoidal.toMonoidal_toLaxMonoidal, comp_whiskerRight, μIso_hom,
      Iso.refl_hom, map_id, tensorHom_id, μIso_inv, Iso.refl_inv, Category.assoc, ← map_comp,
      OplaxMonoidal.associativity, ← comp_whiskerRight_assoc, δ_μ, id_whiskerRight,
      Category.id_comp, MonoidalCategory.whiskerLeft_comp, id_tensorHom,
      ← MonoidalCategory.whiskerLeft_comp_assoc, MonoidalCategory.whiskerLeft_id]
    simp [← comp_obj, ← Functor.comp_map]
  · apply natTrans_ext L W (fun X ↦ ?_)
    -- generated by: `simp? [-Iso.symm_hom, -εIso_hom, -mapIso_symm]`
    simp only [comp_obj, curriedTensor_obj_obj, LaxMonoidal.ofBifunctor.leftMapₗ_app, Iso.trans_hom,
      mapIso_hom, NatTrans.comp_app, whiskeringLeft₂_obj_obj_obj_obj_obj,
      LaxMonoidal.ofBifunctor.topMapₗ_app, comp_whiskerRight, postcompose₂_obj_obj_obj_obj,
      LaxMonoidal.ofBifunctor.bottomMapₗ_app, LaxMonoidal.left_unitality, map_comp, Category.assoc]
    have := NatTrans.congr_app ((curriedTensorPreIsoPost L W F G).hom.naturality (εIso L).symm.hom)
      (L.obj X)
    simp only [whiskeringLeft₂_obj_obj_obj_obj_obj, curriedTensor_obj_obj, NatTrans.comp_app,
      whiskeringLeft₂_obj_obj_obj_map_app, curriedTensor_map_app] at this
    slice_rhs 2 3 => rw [this]
    simp only [comp_obj, curriedTensorPreIsoPost_hom_app_app, Category.assoc]
    change (λ_ ((L ⋙ F).obj _)).hom = _
    rw [LaxMonoidal.left_unitality (L ⋙ F)]
    simp [← Functor.map_comp]
  · apply natTrans_ext L W (fun X ↦ ?_)
    -- generated by `simp? [-Iso.symm_hom, -εIso_hom, -mapIso_symm]`
    simp only [comp_obj, flip_obj_obj, curriedTensor_obj_obj, LaxMonoidal.ofBifunctor.leftMapᵣ_app,
      Iso.trans_hom, mapIso_hom, flipFunctor_obj, NatTrans.comp_app,
      whiskeringLeft₂_obj_obj_obj_obj_obj, LaxMonoidal.ofBifunctor.topMapᵣ_app,
      MonoidalCategory.whiskerLeft_comp, postcompose₂_obj_obj_obj_obj, flipFunctor_map_app_app,
      LaxMonoidal.ofBifunctor.bottomMapᵣ_app, LaxMonoidal.right_unitality, map_comp, Category.assoc]
    have := ((curriedTensorPreIsoPost L W F G).hom.app (L.obj X)).naturality (εIso L).symm.hom
    simp only [whiskeringLeft₂_obj_obj_obj_obj_obj, curriedTensor_obj_obj,
      whiskeringLeft₂_obj_obj_obj_obj_map, curriedTensor_obj_map] at this
    slice_rhs 2 3 => rw [this]
    simp only [comp_obj, curriedTensorPreIsoPost_hom_app_app, Category.assoc]
    change (ρ_ ((L ⋙ F).obj _)).hom = _
    rw [LaxMonoidal.right_unitality (L ⋙ F)]
    simp [← Functor.map_comp]

/--
Monoidal structure on `F`, given that `L ⋙ F` is monoidal, where `L` is a localization functor.
-/
noncomputable def functorMonoidalOfComp : F.Monoidal :=
  (functorCoreMonoidalOfComp L W F G).toMonoidal

@[reassoc]
lemma functorMonoidalOfComp_ε : letI := functorMonoidalOfComp L W F G
    letI e := Lifting.iso L W G F
    ε F = ε G ≫ e.inv.app _ ≫ F.map (η L) := by
  simp [Functor.CoreMonoidal.toLaxMonoidal_ε]

@[reassoc]
lemma functorMonoidalOfComp_μ (X Y : C) : letI := functorMonoidalOfComp L W F G
    letI e := Lifting.iso L W G F
    μ F (L.obj X) (L.obj Y) = (e.hom.app _ ⊗ₘ e.hom.app _) ≫ μ G X Y ≫ e.inv.app _ ≫
        F.map (δ L _ _) := by
  simp [Functor.CoreMonoidal.toLaxMonoidal_μ, curriedTensorPreIsoPost_hom_app_app]

instance natTrans_isMonoidal :
    letI : F.Monoidal := functorMonoidalOfComp L W F G
    (Lifting.iso L W G F).hom.IsMonoidal := by
  letI : F.Monoidal := functorMonoidalOfComp L W F G
  refine ⟨?_, fun _ _ ↦ ?_⟩
  · simp [functorMonoidalOfComp_ε]
  · simp [functorMonoidalOfComp_μ]

end CategoryTheory.Localization.Monoidal
