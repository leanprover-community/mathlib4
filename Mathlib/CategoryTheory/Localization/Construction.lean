/-
Copyright (c) 2022 JoÃ«l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: JoÃ«l Riou
-/
import Mathlib.CategoryTheory.MorphismProperty
import Mathlib.CategoryTheory.Category.QuivCat

#align_import category_theory.localization.construction from "leanprover-community/mathlib"@"1a5e56f2166e4e9d0964c71f4273b1d39227678d"

/-!

# Construction of the localized category

This file constructs the localized category, obtained by formally inverting
a class of maps `W : MorphismProperty C` in a category `C`.

We first construct a quiver `LocQuiver W` whose objects are the same as those
of `C` and whose maps are the maps in `C` and placeholders for the formal
inverses of the maps in `W`.

The localized category `W.Localization` is obtained by taking the quotient
of the path category of `LocQuiver W` by the congruence generated by four
types of relations.

The obvious functor `Q W : C â¥¤ W.Localization` satisfies the universal property
of the localization. Indeed, if `G : C â¥¤ D` sends morphisms in `W` to isomorphisms
in `D` (i.e. we have `hG : W.IsInvertedBy G`), then there exists a unique functor
`G' : W.Localization â¥¤ D` such that `Q W â‰« G' = G`. This `G'` is `lift G hG`.
The expected property of `lift G hG` if expressed by the lemma `fac` and the
uniqueness is expressed by `uniq`.

## References

* [P. Gabriel, M. Zisman, *Calculus of fractions and homotopy theory*][gabriel-zisman-1967]

-/


noncomputable section

open CategoryTheory.Category

namespace CategoryTheory

-- category universes first for convenience
universe uC' uD' uC uD
variable {C : Type uC} [Category.{uC'} C] (W : MorphismProperty C) {D : Type uD} [Category.{uD'} D]

namespace Localization

namespace Construction

-- porting note: removed @[nolint has_nonempty_instance]
/-- If `W : MorphismProperty C`, `LocQuiver W` is a quiver with the same objects
as `C`, and whose morphisms are those in `C` and placeholders for formal
inverses of the morphisms in `W`. -/
structure LocQuiver (W : MorphismProperty C) where
  /-- underlying object -/
  obj : C
#align category_theory.localization.construction.loc_quiver CategoryTheory.Localization.Construction.LocQuiver

instance : Quiver (LocQuiver W) where Hom A B := Sum (A.obj âŸ¶ B.obj) { f : B.obj âŸ¶ A.obj // W f }

/-- The object in the path category of `LocQuiver W` attached to an object in
the category `C` -/
def Î¹Paths (X : C) : Paths (LocQuiver W) :=
  âŸ¨XâŸ©
#align category_theory.localization.construction.Î¹_paths CategoryTheory.Localization.Construction.Î¹Paths

/-- The morphism in the path category associated to a morphism in the original category. -/
@[simp]
def Ïˆâ‚ {X Y : C} (f : X âŸ¶ Y) : Î¹Paths W X âŸ¶ Î¹Paths W Y :=
  Paths.of.map (Sum.inl f)
#align category_theory.localization.construction.Ïˆâ‚ CategoryTheory.Localization.Construction.Ïˆâ‚

/-- The morphism in the path category corresponding to a formal inverse. -/
@[simp]
def Ïˆâ‚‚ {X Y : C} (w : X âŸ¶ Y) (hw : W w) : Î¹Paths W Y âŸ¶ Î¹Paths W X :=
  Paths.of.map (Sum.inr âŸ¨w, hwâŸ©)
#align category_theory.localization.construction.Ïˆâ‚‚ CategoryTheory.Localization.Construction.Ïˆâ‚‚

/-- The relations by which we take the quotient in order to get the localized category. -/
inductive relations : HomRel (Paths (LocQuiver W))
  | id (X : C) : relations (Ïˆâ‚ W (ğŸ™ X)) (ğŸ™ _)
  | comp {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : relations (Ïˆâ‚ W (f â‰« g)) (Ïˆâ‚ W f â‰« Ïˆâ‚ W g)
  | Winvâ‚ {X Y : C} (w : X âŸ¶ Y) (hw : W w) : relations (Ïˆâ‚ W w â‰« Ïˆâ‚‚ W w hw) (ğŸ™ _)
  | Winvâ‚‚ {X Y : C} (w : X âŸ¶ Y) (hw : W w) : relations (Ïˆâ‚‚ W w hw â‰« Ïˆâ‚ W w) (ğŸ™ _)
#align category_theory.localization.construction.relations CategoryTheory.Localization.Construction.relations

end Construction

end Localization

namespace MorphismProperty

open Localization.Construction

-- porting note: removed @[nolint has_nonempty_instance]
/-- The localized category obtained by formally inverting the morphisms
in `W : MorphismProperty C` -/
def Localization :=
  CategoryTheory.Quotient (Localization.Construction.relations W)
#align category_theory.morphism_property.localization CategoryTheory.MorphismProperty.Localization

instance : Category (Localization W) := by
  dsimp only [Localization]
  -- âŠ¢ Category.{?u.3575, uC} (Quotient (relations W))
  infer_instance
  -- ğŸ‰ no goals

/-- The obvious functor `C â¥¤ W.Localization` -/
def Q : C â¥¤ W.Localization
    where
  obj X := (Quotient.functor _).obj (Paths.of.obj âŸ¨XâŸ©)
  map f := (Quotient.functor _).map (Ïˆâ‚ W f)
  map_id X := Quotient.sound _ (relations.id X)
  map_comp f g := Quotient.sound _ (relations.comp f g)
set_option linter.uppercaseLean3 false in
#align category_theory.morphism_property.Q CategoryTheory.MorphismProperty.Q

end MorphismProperty

namespace Localization

namespace Construction

variable {W}
/-- The isomorphism in `W.Localization` associated to a morphism `w` in W -/
def wIso {X Y : C} (w : X âŸ¶ Y) (hw : W w) : Iso (W.Q.obj X) (W.Q.obj Y)
    where
  hom := W.Q.map w
  inv := (Quotient.functor _).map (by dsimp; exact Paths.of.map (Sum.inr âŸ¨w, hwâŸ©))
                                      -- âŠ¢ { obj := Y } âŸ¶ { obj := X }
                                             -- ğŸ‰ no goals
  hom_inv_id := Quotient.sound _ (relations.Winvâ‚ w hw)
  inv_hom_id := Quotient.sound _ (relations.Winvâ‚‚ w hw)
set_option linter.uppercaseLean3 false in
#align category_theory.localization.construction.Wiso CategoryTheory.Localization.Construction.wIso

/-- The formal inverse in `W.Localization` of a morphism `w` in `W`. -/
abbrev winv {X Y : C} (w : X âŸ¶ Y) (hw : W w) :=
  (wIso w hw).inv
set_option linter.uppercaseLean3 false in
#align category_theory.localization.construction.Winv CategoryTheory.Localization.Construction.winv

variable (W)

theorem _root_.CategoryTheory.MorphismProperty.Q_inverts : W.IsInvertedBy W.Q := fun _ _ w hw =>
  IsIso.of_iso (Localization.Construction.wIso w hw)
set_option linter.uppercaseLean3 false in
#align category_theory.morphism_property.Q_inverts CategoryTheory.MorphismProperty.Q_inverts

variable {W} (G : C â¥¤ D) (hG : W.IsInvertedBy G)

/-- The lifting of a functor to the path category of `LocQuiver W` -/
@[simps!]
def liftToPathCategory : Paths (LocQuiver W) â¥¤ D :=
  QuivCat.lift
    { obj := fun X => G.obj X.obj
      map := by
        intros X Y
        -- âŠ¢ (X âŸ¶ Y) â†’ ((fun X => G.obj X.obj) X âŸ¶ (fun X => G.obj X.obj) Y)
        rintro (f | âŸ¨g, hgâŸ©)
        -- âŠ¢ (fun X => G.obj X.obj) X âŸ¶ (fun X => G.obj X.obj) Y
        Â· exact G.map f
          -- ğŸ‰ no goals
        Â· haveI := hG g hg
          -- âŠ¢ (fun X => G.obj X.obj) X âŸ¶ (fun X => G.obj X.obj) Y
          exact inv (G.map g) }
          -- ğŸ‰ no goals
#align category_theory.localization.construction.lift_to_path_category CategoryTheory.Localization.Construction.liftToPathCategory

/-- The lifting of a functor `C â¥¤ D` inverting `W` as a functor `W.Localization â¥¤ D` -/
@[simps!]
def lift : W.Localization â¥¤ D :=
  Quotient.lift (relations W) (liftToPathCategory G hG)
    (by
      rintro âŸ¨XâŸ© âŸ¨YâŸ© fâ‚ fâ‚‚ r
      -- âŠ¢ (liftToPathCategory G hG).map fâ‚ = (liftToPathCategory G hG).map fâ‚‚
      --Porting note: rest of proof was `rcases r with âŸ¨âŸ©; tidy`
      rcases r with (_|_|âŸ¨f,hfâŸ©|âŸ¨f,hfâŸ©)
      Â· aesop_cat
        -- ğŸ‰ no goals
      Â· aesop_cat
        -- ğŸ‰ no goals
      all_goals
        dsimp
        haveI := hG f hf
        simp
        rfl)
#align category_theory.localization.construction.lift CategoryTheory.Localization.Construction.lift

@[simp]
theorem fac : W.Q â‹™ lift G hG = G :=
  Functor.ext (fun X => rfl)
    (by
      intro X Y f
      -- âŠ¢ (MorphismProperty.Q W â‹™ lift G hG).map f = eqToHom (_ : (MorphismProperty.Q  â€¦
      simp only [Functor.comp_map, eqToHom_refl, comp_id, id_comp]
      -- âŠ¢ (lift G hG).map ((MorphismProperty.Q W).map f) = G.map f
      dsimp [MorphismProperty.Q, Quot.liftOn]
      -- âŠ¢ composePath (Quiver.Hom.toPath (G.map f)) = G.map f
      rw [composePath_toPath])
      -- ğŸ‰ no goals
#align category_theory.localization.construction.fac CategoryTheory.Localization.Construction.fac

theorem uniq (Gâ‚ Gâ‚‚ : W.Localization â¥¤ D) (h : W.Q â‹™ Gâ‚ = W.Q â‹™ Gâ‚‚) : Gâ‚ = Gâ‚‚ := by
  suffices h' : Quotient.functor _ â‹™ Gâ‚ = Quotient.functor _ â‹™ Gâ‚‚
  -- âŠ¢ Gâ‚ = Gâ‚‚
  Â· refine' Functor.ext _ _
    -- âŠ¢ âˆ€ (X : MorphismProperty.Localization W), Gâ‚.obj X = Gâ‚‚.obj X
    Â· rintro âŸ¨âŸ¨XâŸ©âŸ©
      -- âŠ¢ Gâ‚.obj { as := { obj := X } } = Gâ‚‚.obj { as := { obj := X } }
      apply Functor.congr_obj h
      -- ğŸ‰ no goals
    Â· rintro âŸ¨âŸ¨XâŸ©âŸ© âŸ¨âŸ¨YâŸ©âŸ© âŸ¨fâŸ©
      -- âŠ¢ Gâ‚.map (Quot.mk (Quotient.CompClosure (relations W)) f) = eqToHom (_ : Gâ‚.ob â€¦
      apply Functor.congr_hom h'
      -- ğŸ‰ no goals
  Â· refine' Paths.ext_functor _ _
    -- âŠ¢ (Quotient.functor (relations W) â‹™ Gâ‚).toPrefunctor.obj = (Quotient.functor ( â€¦
    Â· ext X
      -- âŠ¢ (Quotient.functor (relations W) â‹™ Gâ‚).obj X = (Quotient.functor (relations W â€¦
      cases X
      -- âŠ¢ (Quotient.functor (relations W) â‹™ Gâ‚).obj { obj := objâœ } = (Quotient.functo â€¦
      apply Functor.congr_obj h
      -- ğŸ‰ no goals
    Â· rintro âŸ¨XâŸ© âŸ¨YâŸ© (f | âŸ¨w, hwâŸ©)
      -- âŠ¢ (Quotient.functor (relations W) â‹™ Gâ‚).map (Quiver.Hom.toPath (Sum.inl f)) =  â€¦
      Â· simpa only using Functor.congr_hom h f
        -- ğŸ‰ no goals
      Â· have hw : W.Q.map w = (wIso w hw).hom := rfl
        -- âŠ¢ (Quotient.functor (relations W) â‹™ Gâ‚).map (Quiver.Hom.toPath (Sum.inr { val  â€¦
        have hw' := Functor.congr_hom h w
        -- âŠ¢ (Quotient.functor (relations W) â‹™ Gâ‚).map (Quiver.Hom.toPath (Sum.inr { val  â€¦
        simp only [Functor.comp_map, hw] at hw'
        -- âŠ¢ (Quotient.functor (relations W) â‹™ Gâ‚).map (Quiver.Hom.toPath (Sum.inr { val  â€¦
        refine' Functor.congr_inv_of_congr_hom _ _ _ _ _ hw'
        -- âŠ¢ Gâ‚.obj ((MorphismProperty.Q W).obj Y) = Gâ‚‚.obj ((MorphismProperty.Q W).obj Y)
        all_goals apply Functor.congr_obj h
        -- ğŸ‰ no goals
#align category_theory.localization.construction.uniq CategoryTheory.Localization.Construction.uniq

variable (W)

/-- The canonical bijection between objects in a category and its
localization with respect to a morphism_property `W` -/
@[simps]
def objEquiv : C â‰ƒ W.Localization where
  toFun := W.Q.obj
  invFun X := X.as.obj
  left_inv X := rfl
  right_inv := by
    rintro âŸ¨âŸ¨XâŸ©âŸ©
    -- âŠ¢ (MorphismProperty.Q W).obj ((fun X => X.as.obj) { as := { obj := X } }) = {  â€¦
    rfl
    -- ğŸ‰ no goals
#align category_theory.localization.construction.obj_equiv CategoryTheory.Localization.Construction.objEquiv

variable {W}

/-- A `MorphismProperty` in `W.Localization` is satisfied by all
morphisms in the localized category if it contains the image of the
morphisms in the original category, the inverses of the morphisms
in `W` and if it is stable under composition -/
theorem morphismProperty_is_top (P : MorphismProperty W.Localization)
    (hPâ‚ : âˆ€ â¦ƒX Y : Câ¦„ (f : X âŸ¶ Y), P (W.Q.map f))
    (hPâ‚‚ : âˆ€ â¦ƒX Y : Câ¦„ (w : X âŸ¶ Y) (hw : W w), P (winv w hw)) (hPâ‚ƒ : P.StableUnderComposition) :
    P = âŠ¤ := by
  funext X Y f
  -- âŠ¢ P f = âŠ¤ f
  ext
  -- âŠ¢ P f â†” âŠ¤ f
  constructor
  -- âŠ¢ P f â†’ âŠ¤ f
  Â· intro
    -- âŠ¢ âŠ¤ f
    apply MorphismProperty.top_apply
    -- ğŸ‰ no goals
  Â· intro
    -- âŠ¢ P f
    let G : _ â¥¤ W.Localization := Quotient.functor _
    -- âŠ¢ P f
    haveI : Full G := Quotient.fullFunctor _
    -- âŠ¢ P f
    suffices âˆ€ (Xâ‚ Xâ‚‚ : Paths (LocQuiver W)) (f : Xâ‚ âŸ¶ Xâ‚‚), P (G.map f) by
      rcases X with âŸ¨âŸ¨XâŸ©âŸ©
      rcases Y with âŸ¨âŸ¨YâŸ©âŸ©
      simpa only [Functor.image_preimage] using this _ _ (G.preimage f)
    intros Xâ‚ Xâ‚‚ p
    -- âŠ¢ P (G.map p)
    induction' p with Xâ‚‚ Xâ‚ƒ p g hp
    -- âŠ¢ P (G.map Quiver.Path.nil)
    Â· simpa only [Functor.map_id] using hPâ‚ (ğŸ™ Xâ‚.obj)
      -- ğŸ‰ no goals
    Â· let p' : Xâ‚ âŸ¶Xâ‚‚ := p
      -- âŠ¢ P (G.map (Quiver.Path.cons p g))
      rw [show p'.cons g = p' â‰« Quiver.Hom.toPath g by rfl, G.map_comp]
      -- âŠ¢ P (G.map p' â‰« G.map (Quiver.Hom.toPath g))
      refine' hPâ‚ƒ _ _ hp _
      -- âŠ¢ P (G.map (Quiver.Hom.toPath g))
      rcases g with (g | âŸ¨g, hgâŸ©)
      -- âŠ¢ P (G.map (Quiver.Hom.toPath (Sum.inl g)))
      Â· apply hPâ‚
        -- ğŸ‰ no goals
      Â· apply hPâ‚‚
        -- ğŸ‰ no goals
#align category_theory.localization.construction.morphism_property_is_top CategoryTheory.Localization.Construction.morphismProperty_is_top

/-- A `MorphismProperty` in `W.Localization` is satisfied by all
morphisms in the localized category if it contains the image of the
morphisms in the original category, if is stable under composition
and if the property is stable by passing to inverses. -/
theorem morphismProperty_is_top' (P : MorphismProperty W.Localization)
    (hPâ‚ : âˆ€ â¦ƒX Y : Câ¦„ (f : X âŸ¶ Y), P (W.Q.map f))
    (hPâ‚‚ : âˆ€ â¦ƒX Y : W.Localizationâ¦„ (e : X â‰… Y) (_ : P e.hom), P e.inv)
    (hPâ‚ƒ : P.StableUnderComposition) : P = âŠ¤ :=
  morphismProperty_is_top P hPâ‚ (fun _ _ w _ => hPâ‚‚ _ (hPâ‚ w)) hPâ‚ƒ
#align category_theory.localization.construction.morphism_property_is_top' CategoryTheory.Localization.Construction.morphismProperty_is_top'

namespace NatTransExtension

variable {Fâ‚ Fâ‚‚ : W.Localization â¥¤ D} (Ï„ : W.Q â‹™ Fâ‚ âŸ¶ W.Q â‹™ Fâ‚‚)

/-- If `Fâ‚` and `Fâ‚‚` are functors `W.Localization â¥¤ D` and if we have
`Ï„ : W.Q â‹™ Fâ‚ âŸ¶ W.Q â‹™ Fâ‚‚`, we shall define a natural transformation `Fâ‚ âŸ¶ Fâ‚‚`.
This is the `app` field of this natural transformation. -/
def app (X : W.Localization) : Fâ‚.obj X âŸ¶ Fâ‚‚.obj X :=
  eqToHom (congr_arg Fâ‚.obj ((objEquiv W).right_inv X).symm) â‰«
    Ï„.app ((objEquiv W).invFun X) â‰« eqToHom (congr_arg Fâ‚‚.obj ((objEquiv W).right_inv X))
#align category_theory.localization.construction.nat_trans_extension.app CategoryTheory.Localization.Construction.NatTransExtension.app

@[simp]
theorem app_eq (X : C) : (app Ï„) (W.Q.obj X) = Ï„.app X := by
  simp only [app, eqToHom_refl, comp_id, id_comp]
  -- âŠ¢ NatTrans.app Ï„ (Equiv.invFun (objEquiv W) ((MorphismProperty.Q W).obj X)) =  â€¦
  rfl
  -- ğŸ‰ no goals
#align category_theory.localization.construction.nat_trans_extension.app_eq CategoryTheory.Localization.Construction.NatTransExtension.app_eq

end NatTransExtension

/-- If `Fâ‚` and `Fâ‚‚` are functors `W.Localization â¥¤ D`, a natural transformation `Fâ‚ âŸ¶ Fâ‚‚`
can be obtained from a natural transformation `W.Q â‹™ Fâ‚ âŸ¶ W.Q â‹™ Fâ‚‚`. -/
@[simps]
def natTransExtension {Fâ‚ Fâ‚‚ : W.Localization â¥¤ D} (Ï„ : W.Q â‹™ Fâ‚ âŸ¶ W.Q â‹™ Fâ‚‚) : Fâ‚ âŸ¶ Fâ‚‚
    where
  app := NatTransExtension.app Ï„
  naturality := by
    suffices MorphismProperty.naturalityProperty (NatTransExtension.app Ï„) = âŠ¤ by
      intro X Y f
      simpa only [â† this] using MorphismProperty.top_apply f
    refine' morphismProperty_is_top'
      (MorphismProperty.naturalityProperty (NatTransExtension.app Ï„))
      _ (MorphismProperty.naturalityProperty.stableUnderInverse _)
      (MorphismProperty.naturalityProperty.stableUnderComposition _)
    intros X Y f
    -- âŠ¢ MorphismProperty.naturalityProperty (NatTransExtension.app Ï„) ((MorphismProp â€¦
    dsimp
    -- âŠ¢ Fâ‚.map ((MorphismProperty.Q W).map f) â‰« NatTransExtension.app Ï„ ((MorphismPr â€¦
    simpa only [NatTransExtension.app_eq] using Ï„.naturality f
    -- ğŸ‰ no goals
#align category_theory.localization.construction.nat_trans_extension CategoryTheory.Localization.Construction.natTransExtension

@[simp]
theorem natTransExtension_hcomp {F G : W.Localization â¥¤ D} (Ï„ : W.Q â‹™ F âŸ¶ W.Q â‹™ G) :
    ğŸ™ W.Q â—« natTransExtension Ï„ = Ï„ := by aesop_cat
                                          -- ğŸ‰ no goals
#align category_theory.localization.construction.nat_trans_extension_hcomp CategoryTheory.Localization.Construction.natTransExtension_hcomp

theorem natTrans_hcomp_injective {F G : W.Localization â¥¤ D} {Ï„â‚ Ï„â‚‚ : F âŸ¶ G}
    (h : ğŸ™ W.Q â—« Ï„â‚ = ğŸ™ W.Q â—« Ï„â‚‚) : Ï„â‚ = Ï„â‚‚ := by
  ext X
  -- âŠ¢ NatTrans.app Ï„â‚ X = NatTrans.app Ï„â‚‚ X
  have eq := (objEquiv W).right_inv X
  -- âŠ¢ NatTrans.app Ï„â‚ X = NatTrans.app Ï„â‚‚ X
  simp only [objEquiv] at eq
  -- âŠ¢ NatTrans.app Ï„â‚ X = NatTrans.app Ï„â‚‚ X
  rw [â† eq, â† NatTrans.id_hcomp_app, â† NatTrans.id_hcomp_app, h]
  -- ğŸ‰ no goals
#align category_theory.localization.construction.nat_trans_hcomp_injective CategoryTheory.Localization.Construction.natTrans_hcomp_injective

variable (W D)

namespace WhiskeringLeftEquivalence

/-- The functor `(W.Localization â¥¤ D) â¥¤ (W.FunctorsInverting D)` induced by the
composition with `W.Q : C â¥¤ W.Localization`. -/
@[simps!]
def functor : (W.Localization â¥¤ D) â¥¤ W.FunctorsInverting D :=
  FullSubcategory.lift _ ((whiskeringLeft _ _ D).obj W.Q) fun _ =>
    MorphismProperty.IsInvertedBy.of_comp W W.Q W.Q_inverts _
#align category_theory.localization.construction.whiskering_left_equivalence.functor CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.functor

/-- The function `(W.FunctorsInverting D) â¥¤ (W.Localization â¥¤ D)` induced by
`Construction.lift`. -/
@[simps!]
def inverse : W.FunctorsInverting D â¥¤ W.Localization â¥¤ D
    where
  obj G := lift G.obj G.property
  map Ï„ := natTransExtension (eqToHom (by rw [fac]) â‰« Ï„ â‰« eqToHom (by rw [fac]))
                                          -- ğŸ‰ no goals
                                                                      -- ğŸ‰ no goals
  map_id G :=
    natTrans_hcomp_injective
      (by
        rw [natTransExtension_hcomp]
        -- âŠ¢ eqToHom (_ : MorphismProperty.Q W â‹™ (fun G => lift G.obj (_ : MorphismProper â€¦
        ext X
        -- âŠ¢ NatTrans.app (eqToHom (_ : MorphismProperty.Q W â‹™ (fun G => lift G.obj (_ :  â€¦
        simp only [NatTrans.comp_app, eqToHom_app, eqToHom_refl, comp_id, id_comp,
          NatTrans.hcomp_id_app, NatTrans.id_app, Functor.map_id]
        rfl )
        -- ğŸ‰ no goals
  map_comp Ï„â‚ Ï„â‚‚ :=
    natTrans_hcomp_injective
      (by
        ext X
        -- âŠ¢ NatTrans.app (ğŸ™ (MorphismProperty.Q W) â—« { obj := fun G => lift G.obj (_ : M â€¦
        simp only [natTransExtension_hcomp, NatTrans.comp_app, eqToHom_app, eqToHom_refl,
          id_comp, comp_id, NatTrans.hcomp_app, NatTrans.id_app, Functor.map_id,
          natTransExtension_app, NatTransExtension.app_eq]
        rfl)
        -- ğŸ‰ no goals
#align category_theory.localization.construction.whiskering_left_equivalence.inverse CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.inverse

/-- The unit isomorphism of the equivalence of categories `whiskeringLeftEquivalence W D`. -/
@[simps!]
def unitIso : ğŸ­ (W.Localization â¥¤ D) â‰… functor W D â‹™ inverse W D :=
  eqToIso
    (by
      refine' Functor.ext (fun G => _) fun Gâ‚ Gâ‚‚ Ï„ => _
      -- âŠ¢ (ğŸ­ (MorphismProperty.Localization W â¥¤ D)).obj G = (functor W D â‹™ inverse W D â€¦
      Â· apply uniq
        -- âŠ¢ MorphismProperty.Q W â‹™ (ğŸ­ (MorphismProperty.Localization W â¥¤ D)).obj G = Mor â€¦
        dsimp [Functor]
        -- âŠ¢ MorphismProperty.Q W â‹™ G = MorphismProperty.Q W â‹™ (inverse W D).obj ((functo â€¦
        erw [fac]
        -- âŠ¢ MorphismProperty.Q W â‹™ G = ((functor W D).obj G).obj
        rfl
        -- ğŸ‰ no goals
      Â· apply natTrans_hcomp_injective
        -- âŠ¢ ğŸ™ (MorphismProperty.Q W) â—« (ğŸ­ (MorphismProperty.Localization W â¥¤ D)).map Ï„ = â€¦
        ext X
        -- âŠ¢ NatTrans.app (ğŸ™ (MorphismProperty.Q W) â—« (ğŸ­ (MorphismProperty.Localization W â€¦
        simp)
        -- ğŸ‰ no goals
#align category_theory.localization.construction.whiskering_left_equivalence.unit_iso CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.unitIso

/-- The counit isomorphism of the equivalence of categories `WhiskeringLeftEquivalence W D`. -/
@[simps!]
def counitIso : inverse W D â‹™ functor W D â‰… ğŸ­ (W.FunctorsInverting D) :=
  eqToIso
    (by
      refine' Functor.ext _ _
      -- âŠ¢ âˆ€ (X : MorphismProperty.FunctorsInverting W D), (inverse W D â‹™ functor W D). â€¦
      Â· rintro âŸ¨G, hGâŸ©
        -- âŠ¢ (inverse W D â‹™ functor W D).obj { obj := G, property := hG } = (ğŸ­ (MorphismP â€¦
        ext
        -- âŠ¢ ((inverse W D â‹™ functor W D).obj { obj := G, property := hG }).obj = ((ğŸ­ (Mo â€¦
        exact fac G hG
        -- ğŸ‰ no goals
      Â· rintro âŸ¨Gâ‚, hGâ‚âŸ© âŸ¨Gâ‚‚, hGâ‚‚âŸ© f
        -- âŠ¢ (inverse W D â‹™ functor W D).map f = eqToHom (_ : (inverse W D â‹™ functor W D) â€¦
        ext
        -- âŠ¢ NatTrans.app ((inverse W D â‹™ functor W D).map f) xâœ = NatTrans.app (eqToHom  â€¦
        apply NatTransExtension.app_eq)
        -- ğŸ‰ no goals
#align category_theory.localization.construction.whiskering_left_equivalence.counit_iso CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.counitIso

end WhiskeringLeftEquivalence

/-- The equivalence of categories `(W.localization â¥¤ D) â‰Œ (W.FunctorsInverting D)`
induced by the composition with `W.Q : C â¥¤ W.localization`. -/
def whiskeringLeftEquivalence : W.Localization â¥¤ D â‰Œ W.FunctorsInverting D
    where
  functor := WhiskeringLeftEquivalence.functor W D
  inverse := WhiskeringLeftEquivalence.inverse W D
  unitIso := WhiskeringLeftEquivalence.unitIso W D
  counitIso := WhiskeringLeftEquivalence.counitIso W D
  functor_unitIso_comp F := by
    ext
    -- âŠ¢ NatTrans.app ((WhiskeringLeftEquivalence.functor W D).map (NatTrans.app (Whi â€¦
    simp only [WhiskeringLeftEquivalence.unitIso_hom, eqToHom_app, eqToHom_refl,
      WhiskeringLeftEquivalence.counitIso_hom, eqToHom_map, eqToHom_trans]
    rfl
    -- ğŸ‰ no goals
#align category_theory.localization.construction.whiskering_left_equivalence CategoryTheory.Localization.Construction.whiskeringLeftEquivalence

end Construction

end Localization

end CategoryTheory
