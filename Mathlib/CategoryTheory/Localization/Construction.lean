/-
Copyright (c) 2022 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathlib.CategoryTheory.MorphismProperty.Composition
import Mathlib.CategoryTheory.MorphismProperty.IsInvertedBy
import Mathlib.CategoryTheory.Category.Quiv

/-!

# Construction of the localized category

This file constructs the localized category, obtained by formally inverting
a class of maps `W : MorphismProperty C` in a category `C`.

We first construct a quiver `LocQuiver W` whose objects are the same as those
of `C` and whose maps are the maps in `C` and placeholders for the formal
inverses of the maps in `W`.

The localized category `W.Localization` is obtained by taking the quotient
of the path category of `LocQuiver W` by the congruence generated by four
types of relations.

The obvious functor `Q W : C ‚•§ W.Localization` satisfies the universal property
of the localization. Indeed, if `G : C ‚•§ D` sends morphisms in `W` to isomorphisms
in `D` (i.e. we have `hG : W.IsInvertedBy G`), then there exists a unique functor
`G' : W.Localization ‚•§ D` such that `Q W ‚â´ G' = G`. This `G'` is `lift G hG`.
The expected property of `lift G hG` if expressed by the lemma `fac` and the
uniqueness is expressed by `uniq`.

## References

* [P. Gabriel, M. Zisman, *Calculus of fractions and homotopy theory*][gabriel-zisman-1967]

-/


noncomputable section

open CategoryTheory.Category CategoryTheory.Functor

namespace CategoryTheory

-- category universes first for convenience
universe uC' uD' uC uD
variable {C : Type uC} [Category.{uC'} C] (W : MorphismProperty C) {D : Type uD} [Category.{uD'} D]

namespace Localization

namespace Construction

/-- If `W : MorphismProperty C`, `LocQuiver W` is a quiver with the same objects
as `C`, and whose morphisms are those in `C` and placeholders for formal
inverses of the morphisms in `W`. -/
structure LocQuiver (W : MorphismProperty C) where
  /-- underlying object -/
  obj : C

instance : Quiver (LocQuiver W) where Hom A B := (A.obj ‚ü∂ B.obj) ‚äï { f : B.obj ‚ü∂ A.obj // W f }

/-- The object in the path category of `LocQuiver W` attached to an object in
the category `C` -/
def ŒπPaths (X : C) : Paths (LocQuiver W) :=
  ‚ü®X‚ü©

/-- The morphism in the path category associated to a morphism in the original category. -/
@[simp]
def œà‚ÇÅ {X Y : C} (f : X ‚ü∂ Y) : ŒπPaths W X ‚ü∂ ŒπPaths W Y := (Paths.of _).map (Sum.inl f)

/-- The morphism in the path category corresponding to a formal inverse. -/
@[simp]
def œà‚ÇÇ {X Y : C} (w : X ‚ü∂ Y) (hw : W w) : ŒπPaths W Y ‚ü∂ ŒπPaths W X :=
  (Paths.of _).map (Sum.inr ‚ü®w, hw‚ü©)

/-- The relations by which we take the quotient in order to get the localized category. -/
inductive relations : HomRel (Paths (LocQuiver W))
  | id (X : C) : relations (œà‚ÇÅ W (ùüô X)) (ùüô _)
  | comp {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : relations (œà‚ÇÅ W (f ‚â´ g)) (œà‚ÇÅ W f ‚â´ œà‚ÇÅ W g)
  | Winv‚ÇÅ {X Y : C} (w : X ‚ü∂ Y) (hw : W w) : relations (œà‚ÇÅ W w ‚â´ œà‚ÇÇ W w hw) (ùüô _)
  | Winv‚ÇÇ {X Y : C} (w : X ‚ü∂ Y) (hw : W w) : relations (œà‚ÇÇ W w hw ‚â´ œà‚ÇÅ W w) (ùüô _)

end Construction

end Localization

namespace MorphismProperty

open Localization.Construction

/-- The localized category obtained by formally inverting the morphisms
in `W : MorphismProperty C` -/
def Localization :=
  CategoryTheory.Quotient (Localization.Construction.relations W)

instance : Category (Localization W) := by
  dsimp only [Localization]
  infer_instance

/-- The obvious functor `C ‚•§ W.Localization` -/
def Q : C ‚•§ W.Localization where
  obj X := (Quotient.functor _).obj ((Paths.of _).obj ‚ü®X‚ü©)
  map f := (Quotient.functor _).map (œà‚ÇÅ W f)
  map_id X := Quotient.sound _ (relations.id X)
  map_comp f g := Quotient.sound _ (relations.comp f g)

end MorphismProperty

namespace Localization

namespace Construction

variable {W}
/-- The isomorphism in `W.Localization` associated to a morphism `w` in W -/
def wIso {X Y : C} (w : X ‚ü∂ Y) (hw : W w) : Iso (W.Q.obj X) (W.Q.obj Y) where
  hom := W.Q.map w
  inv := (Quotient.functor _).map (by dsimp; exact (Paths.of _).map (Sum.inr ‚ü®w, hw‚ü©))
  hom_inv_id := Quotient.sound _ (relations.Winv‚ÇÅ w hw)
  inv_hom_id := Quotient.sound _ (relations.Winv‚ÇÇ w hw)

/-- The formal inverse in `W.Localization` of a morphism `w` in `W`. -/
abbrev wInv {X Y : C} (w : X ‚ü∂ Y) (hw : W w) :=
  (wIso w hw).inv

variable (W) in
theorem _root_.CategoryTheory.MorphismProperty.Q_inverts : W.IsInvertedBy W.Q := fun _ _ w hw =>
  (Localization.Construction.wIso w hw).isIso_hom

variable (G : C ‚•§ D) (hG : W.IsInvertedBy G)

/-- The lifting of a functor to the path category of `LocQuiver W` -/
@[simps!]
def liftToPathCategory : Paths (LocQuiver W) ‚•§ D :=
  Quiv.lift
    { obj := fun X => G.obj X.obj
      map := by
        intros X Y
        rintro (f | ‚ü®g, hg‚ü©)
        ¬∑ exact G.map f
        ¬∑ haveI := hG g hg
          exact inv (G.map g) }

/-- The lifting of a functor `C ‚•§ D` inverting `W` as a functor `W.Localization ‚•§ D` -/
@[simps!]
def lift : W.Localization ‚•§ D :=
  Quotient.lift (relations W) (liftToPathCategory G hG)
    (by
      rintro ‚ü®X‚ü© ‚ü®Y‚ü© f‚ÇÅ f‚ÇÇ r
      -- Porting note: rest of proof was `rcases r with ‚ü®‚ü©; tidy`
      rcases r with (_ | _ | ‚ü®f, hf‚ü© | ‚ü®f, hf‚ü©)
      ¬∑ cat_disch
      ¬∑ simp
      all_goals
        dsimp
        haveI := hG f hf
        simp
        rfl)

@[simp]
theorem fac : W.Q ‚ãô lift G hG = G :=
  Functor.ext (fun _ => rfl)
    (by
      intro X Y f
      simp only [Functor.comp_map, eqToHom_refl, comp_id, id_comp]
      dsimp [MorphismProperty.Q, Quot.liftOn, Quotient.functor]
      rw [composePath_toPath])

theorem uniq (G‚ÇÅ G‚ÇÇ : W.Localization ‚•§ D) (h : W.Q ‚ãô G‚ÇÅ = W.Q ‚ãô G‚ÇÇ) : G‚ÇÅ = G‚ÇÇ := by
  suffices h' : Quotient.functor _ ‚ãô G‚ÇÅ = Quotient.functor _ ‚ãô G‚ÇÇ by
    refine Functor.ext ?_ ?_
    ¬∑ rintro ‚ü®‚ü®X‚ü©‚ü©
      apply Functor.congr_obj h
    ¬∑ rintro ‚ü®‚ü®X‚ü©‚ü© ‚ü®‚ü®Y‚ü©‚ü© ‚ü®f‚ü©
      apply Functor.congr_hom h'
  refine Paths.ext_functor ?_ ?_
  ¬∑ ext X
    cases X
    apply Functor.congr_obj h
  ¬∑ rintro ‚ü®X‚ü© ‚ü®Y‚ü© (f | ‚ü®w, hw‚ü©)
    ¬∑ simpa only using Functor.congr_hom h f
    ¬∑ have hw : W.Q.map w = (wIso w hw).hom := rfl
      have hw' := Functor.congr_hom h w
      simp only [Functor.comp_map, hw] at hw'
      refine Functor.congr_inv_of_congr_hom _ _ _ ?_ ?_ hw'
      all_goals apply Functor.congr_obj h

variable (W) in
/-- The canonical bijection between objects in a category and its
localization with respect to a morphism_property `W` -/
@[simps]
def objEquiv : C ‚âÉ W.Localization where
  toFun := W.Q.obj
  invFun X := X.as.obj
  right_inv := by
    rintro ‚ü®‚ü®X‚ü©‚ü©
    rfl

/-- A `MorphismProperty` in `W.Localization` is satisfied by all
morphisms in the localized category if it contains the image of the
morphisms in the original category, the inverses of the morphisms
in `W` and if it is stable under composition -/
theorem morphismProperty_is_top (P : MorphismProperty W.Localization)
    [P.IsStableUnderComposition] (hP‚ÇÅ : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : X ‚ü∂ Y), P (W.Q.map f))
    (hP‚ÇÇ : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (w : X ‚ü∂ Y) (hw : W w), P (wInv w hw)) :
    P = ‚ä§ := by
  funext X Y f
  ext
  constructor
  ¬∑ intro
    apply MorphismProperty.top_apply
  ¬∑ intro
    let G : _ ‚•§ W.Localization := Quotient.functor _
    haveI : G.Full := Quotient.full_functor _
    suffices ‚àÄ (X‚ÇÅ X‚ÇÇ : Paths (LocQuiver W)) (f : X‚ÇÅ ‚ü∂ X‚ÇÇ), P (G.map f) by
      rcases X with ‚ü®‚ü®X‚ü©‚ü©
      rcases Y with ‚ü®‚ü®Y‚ü©‚ü©
      simpa only [Functor.map_preimage] using this _ _ (G.preimage f)
    intros X‚ÇÅ X‚ÇÇ p
    induction p with
    | nil => simpa only [Functor.map_id] using hP‚ÇÅ (ùüô X‚ÇÅ.obj)
    | @cons X‚ÇÇ X‚ÇÉ p g hp =>
      let p' : X‚ÇÅ ‚ü∂X‚ÇÇ := p
      rw [show p'.cons g = p' ‚â´ Quiver.Hom.toPath g by rfl, G.map_comp]
      refine P.comp_mem _ _ hp ?_
      rcases g with (g | ‚ü®g, hg‚ü©)
      ¬∑ apply hP‚ÇÅ
      ¬∑ apply hP‚ÇÇ

/-- A `MorphismProperty` in `W.Localization` is satisfied by all
morphisms in the localized category if it contains the image of the
morphisms in the original category, if is stable under composition
and if the property is stable by passing to inverses. -/
theorem morphismProperty_is_top' (P : MorphismProperty W.Localization)
    [P.IsStableUnderComposition] (hP‚ÇÅ : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : X ‚ü∂ Y), P (W.Q.map f))
    (hP‚ÇÇ : ‚àÄ ‚¶ÉX Y : W.Localization‚¶Ñ (e : X ‚âÖ Y) (_ : P e.hom), P e.inv) : P = ‚ä§ :=
  morphismProperty_is_top P hP‚ÇÅ (fun _ _ w _ => hP‚ÇÇ _ (hP‚ÇÅ w))

namespace NatTransExtension

variable {F‚ÇÅ F‚ÇÇ : W.Localization ‚•§ D} (œÑ : W.Q ‚ãô F‚ÇÅ ‚ü∂ W.Q ‚ãô F‚ÇÇ)

/-- If `F‚ÇÅ` and `F‚ÇÇ` are functors `W.Localization ‚•§ D` and if we have
`œÑ : W.Q ‚ãô F‚ÇÅ ‚ü∂ W.Q ‚ãô F‚ÇÇ`, we shall define a natural transformation `F‚ÇÅ ‚ü∂ F‚ÇÇ`.
This is the `app` field of this natural transformation. -/
def app (X : W.Localization) : F‚ÇÅ.obj X ‚ü∂ F‚ÇÇ.obj X :=
  eqToHom (congr_arg F‚ÇÅ.obj ((objEquiv W).right_inv X).symm) ‚â´
    œÑ.app ((objEquiv W).invFun X) ‚â´ eqToHom (congr_arg F‚ÇÇ.obj ((objEquiv W).right_inv X))

@[simp]
theorem app_eq (X : C) : (app œÑ) (W.Q.obj X) = œÑ.app X := by
  simp only [app, eqToHom_refl, comp_id, id_comp]
  rfl

end NatTransExtension

/-- If `F‚ÇÅ` and `F‚ÇÇ` are functors `W.Localization ‚•§ D`, a natural transformation `F‚ÇÅ ‚ü∂ F‚ÇÇ`
can be obtained from a natural transformation `W.Q ‚ãô F‚ÇÅ ‚ü∂ W.Q ‚ãô F‚ÇÇ`. -/
@[simps]
def natTransExtension {F‚ÇÅ F‚ÇÇ : W.Localization ‚•§ D} (œÑ : W.Q ‚ãô F‚ÇÅ ‚ü∂ W.Q ‚ãô F‚ÇÇ) : F‚ÇÅ ‚ü∂ F‚ÇÇ where
  app := NatTransExtension.app œÑ
  naturality := by
    suffices MorphismProperty.naturalityProperty (NatTransExtension.app œÑ) = ‚ä§ by
      intro X Y f
      simpa only [‚Üê this] using MorphismProperty.top_apply f
    refine morphismProperty_is_top'
      (MorphismProperty.naturalityProperty (NatTransExtension.app œÑ))
      ?_ (MorphismProperty.naturalityProperty.stableUnderInverse _)
    intros X Y f
    dsimp
    simpa only [NatTransExtension.app_eq] using œÑ.naturality f

@[simp]
theorem whiskerLeft_natTransExtension {F G : W.Localization ‚•§ D} (œÑ : W.Q ‚ãô F ‚ü∂ W.Q ‚ãô G) :
    whiskerLeft W.Q (natTransExtension œÑ) = œÑ := by cat_disch

-- This is not a simp lemma, because the simp norm form of the left-hand side uses `whiskerLeft`.
theorem natTransExtension_hcomp {F G : W.Localization ‚•§ D} (œÑ : W.Q ‚ãô F ‚ü∂ W.Q ‚ãô G) :
    ùüô W.Q ‚ó´ natTransExtension œÑ = œÑ := by cat_disch

theorem natTrans_hcomp_injective {F G : W.Localization ‚•§ D} {œÑ‚ÇÅ œÑ‚ÇÇ : F ‚ü∂ G}
    (h : ùüô W.Q ‚ó´ œÑ‚ÇÅ = ùüô W.Q ‚ó´ œÑ‚ÇÇ) : œÑ‚ÇÅ = œÑ‚ÇÇ := by
  ext X
  have eq := (objEquiv W).right_inv X
  simp only [objEquiv] at eq
  rw [‚Üê eq, ‚Üê NatTrans.id_hcomp_app, ‚Üê NatTrans.id_hcomp_app, h]

variable (W D)

namespace WhiskeringLeftEquivalence

/-- The functor `(W.Localization ‚•§ D) ‚•§ (W.FunctorsInverting D)` induced by the
composition with `W.Q : C ‚•§ W.Localization`. -/
@[simps!]
def functor : (W.Localization ‚•§ D) ‚•§ W.FunctorsInverting D :=
  ObjectProperty.lift _ ((whiskeringLeft _ _ D).obj W.Q) fun _ =>
    MorphismProperty.IsInvertedBy.of_comp W W.Q W.Q_inverts _

/-- The function `(W.FunctorsInverting D) ‚•§ (W.Localization ‚•§ D)` induced by
`Construction.lift`. -/
@[simps!]
def inverse : W.FunctorsInverting D ‚•§ W.Localization ‚•§ D where
  obj G := lift G.obj G.property
  map œÑ := natTransExtension (eqToHom (by rw [fac]) ‚â´ œÑ ‚â´ eqToHom (by rw [fac]))
  map_id G :=
    natTrans_hcomp_injective
      (by
        rw [natTransExtension_hcomp]
        ext X
        simp only [NatTrans.comp_app, eqToHom_app, eqToHom_refl, comp_id, id_comp,
          NatTrans.hcomp_id_app, NatTrans.id_app, Functor.map_id]
        rfl)
  map_comp œÑ‚ÇÅ œÑ‚ÇÇ :=
    natTrans_hcomp_injective
      (by
        ext X
        simp only [natTransExtension_hcomp, NatTrans.comp_app, eqToHom_app, eqToHom_refl,
          id_comp, comp_id, NatTrans.hcomp_app, NatTrans.id_app, Functor.map_id,
          natTransExtension_app, NatTransExtension.app_eq]
        rfl)

/-- The unit isomorphism of the equivalence of categories `whiskeringLeftEquivalence W D`. -/
@[simps!]
def unitIso : ùü≠ (W.Localization ‚•§ D) ‚âÖ functor W D ‚ãô inverse W D :=
  eqToIso
    (by
      refine Functor.ext (fun G => ?_) fun G‚ÇÅ G‚ÇÇ œÑ => ?_
      ¬∑ apply uniq
        dsimp [Functor]
        erw [fac]
        rfl
      ¬∑ apply natTrans_hcomp_injective
        ext X
        simp)

/-- The counit isomorphism of the equivalence of categories `WhiskeringLeftEquivalence W D`. -/
@[simps!]
def counitIso : inverse W D ‚ãô functor W D ‚âÖ ùü≠ (W.FunctorsInverting D) :=
  eqToIso
    (by
      refine Functor.ext ?_ ?_
      ¬∑ rintro ‚ü®G, hG‚ü©
        ext
        exact fac G hG
      ¬∑ rintro ‚ü®G‚ÇÅ, hG‚ÇÅ‚ü© ‚ü®G‚ÇÇ, hG‚ÇÇ‚ü© f
        ext
        apply NatTransExtension.app_eq)

end WhiskeringLeftEquivalence

/-- The equivalence of categories `(W.localization ‚•§ D) ‚âå (W.FunctorsInverting D)`
induced by the composition with `W.Q : C ‚•§ W.localization`. -/
def whiskeringLeftEquivalence : W.Localization ‚•§ D ‚âå W.FunctorsInverting D where
  functor := WhiskeringLeftEquivalence.functor W D
  inverse := WhiskeringLeftEquivalence.inverse W D
  unitIso := WhiskeringLeftEquivalence.unitIso W D
  counitIso := WhiskeringLeftEquivalence.counitIso W D
  functor_unitIso_comp F := by
    ext
    simp only [WhiskeringLeftEquivalence.unitIso_hom, eqToHom_app, eqToHom_refl,
      WhiskeringLeftEquivalence.counitIso_hom, eqToHom_map, eqToHom_trans]
    rfl

end Construction

end Localization

end CategoryTheory
