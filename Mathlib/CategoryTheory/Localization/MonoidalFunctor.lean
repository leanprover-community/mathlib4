/-
Copyright (c) 2025 Dagur Asgeirsson. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Dagur Asgeirsson
-/
import Mathlib.CategoryTheory.EffectiveEpi.RegularEpi
import Mathlib.CategoryTheory.Localization.Monoidal
import Mathlib.Combinatorics.Quiver.ReflQuiver
/-!

# Universal property of localized monoidal categories

This file proves that, given a localization functor `L : C ‚•§ D`, such that `C` is a monoidal
category, and a functor `F : D ‚•§ E` to a monoidal category, such that `L ‚ãô F` is monoidal,
then `F` is monoidal with respect to the localized monoidal structure on `D`. See
`CategoryTheory.Localization.Monoidal.functorMonoidalOfComp`.
-/

universe u

namespace CategoryTheory

open CategoryTheory Limits Opposite MonoidalCategory Functor Functor.Monoidal

namespace Localization.Monoidal

variable {C D : Type*} [Category C] [Category D] (L : C ‚•§ D) (W : MorphismProperty C)
  [MonoidalCategory C]

variable [W.IsMonoidal] [L.IsLocalization W] {unit : D} (Œµ : L.obj (ùüô_ C) ‚âÖ unit)

local notation "L'" => toMonoidalCategory L W Œµ

instance : (L').IsLocalization W := inferInstanceAs (L.IsLocalization W)

variable {E : Type*} [Category E] [MonoidalCategory E] (F : LocalizedMonoidal L W Œµ ‚•§ E)
    [(L ‚ãô F).Monoidal]

instance : (L' ‚ãô F).Monoidal := inferInstanceAs (L ‚ãô F).Monoidal

noncomputable instance : Lifting‚ÇÇ L' L' W W
    ((curriedTensor C) ‚ãô (whiskeringRight C C E).obj (L' ‚ãô F))
    (curriedTensor _ ‚ãô (whiskeringRight _ _ _).obj F) := by
  change (Lifting‚ÇÇ L' L' W W
    (((curriedTensor C) ‚ãô (whiskeringRight C C D).obj L') ‚ãô (whiskeringRight C D E).obj _)
    (tensorBifunctor L W Œµ ‚ãô (whiskeringRight _ _ _).obj F))
  apply (config := {allowSynthFailures := true}) Lifting‚ÇÇ.compRight
  exact inferInstanceAs (Lifting‚ÇÇ L L W W (curriedTensor C ‚ãô (whiskeringRight C C D).obj L')
    (Localization.lift‚ÇÇ _ (isInvertedBy‚ÇÇ L W Œµ) L L))

noncomputable instance : Lifting‚ÇÇ L' L' W W
    ((((whiskeringLeft‚ÇÇ _).obj (L' ‚ãô F)).obj (L' ‚ãô F)).obj (curriedTensor E))
    ((((whiskeringLeft‚ÇÇ _).obj F).obj F).obj (curriedTensor E)) where
  iso' := Iso.refl _

/--
The natural isomorphism of bifunctors `F - ‚äó F - ‚âÖ F (- ‚äó -)`, given that `L ‚ãô F` is monoidal.
-/
noncomputable def ŒºNatIso : ((((whiskeringLeft‚ÇÇ _).obj F).obj F).obj (curriedTensor E)) ‚âÖ
    (curriedTensor _ ‚ãô (whiskeringRight _ _ _).obj F) := by
  refine lift‚ÇÇNatIso L' L' W W
    ((((whiskeringLeft‚ÇÇ _).obj (L' ‚ãô F)).obj (L' ‚ãô F)).obj (curriedTensor E))
    ((curriedTensor C) ‚ãô (whiskeringRight C C E).obj (L' ‚ãô F))
    ((((whiskeringLeft‚ÇÇ _).obj F).obj F).obj (curriedTensor E))
    (curriedTensor _ ‚ãô (whiskeringRight _ _ _).obj F)
    ?_
  refine NatIso.ofComponents (fun _ ‚Ü¶ (NatIso.ofComponents (fun _ ‚Ü¶ ŒºIso (L' ‚ãô F) _ _) ?_)) ?_
  ¬∑ intros
    simp only [whiskeringLeft‚ÇÇ_obj_obj_obj_obj_obj, Functor.comp_obj, curriedTensor_obj_obj,
      whiskeringRight_obj_obj, whiskeringLeft‚ÇÇ_obj_obj_obj_obj_map, Functor.comp_map,
      curriedTensor_obj_map, ŒºIso_hom]
    change _ =  _ ‚â´ (L' ‚ãô F).map _
    rw [map_whiskerLeft]
    simp
  ¬∑ intros
    ext
    simp only [Functor.comp_obj, whiskeringRight_obj_obj, curriedTensor_obj_obj,
      whiskeringLeft‚ÇÇ_obj_obj_obj_obj_obj, Functor.comp_map, whiskeringRight_obj_map,
      NatTrans.comp_app, Functor.whiskerRight_app, curriedTensor_map_app,
      NatIso.ofComponents_hom_app, whiskeringLeft‚ÇÇ_obj_obj_obj_map_app]
    change _ = _ ‚â´ (L' ‚ãô F).map _
    rw [map_whiskerRight]
    simp

lemma ŒºNatIso_hom_app_app (X Y : C) :
    ((ŒºNatIso L W Œµ F).hom.app ((L').obj X)).app ((L').obj Y) =
      Functor.LaxMonoidal.Œº (L' ‚ãô F) X Y ‚â´
        F.map (Functor.OplaxMonoidal.Œ¥ L' X Y) := by
  simp [ŒºNatIso, lift‚ÇÇNatIso, Lifting‚ÇÇ.iso, Lifting‚ÇÇ.iso']
  rfl

/--
Variant of `ŒºNatIso_hom_app_app` where the notation `L'` in the first argument is replaced by `L`
-/
lemma ŒºNatIso_hom_app_app' (X Y : C) :
  ((ŒºNatIso L W Œµ F).hom.app (L.obj X)).app ((L').obj Y) =
    Functor.LaxMonoidal.Œº (L ‚ãô F) X Y ‚â´
      F.map (Functor.OplaxMonoidal.Œ¥ L' X Y) :=
  ŒºNatIso_hom_app_app _ _ _ _ X Y

/--
Variant of `ŒºNatIso_hom_app_app` where the notation `L'` in the second argument is replaced by `L`
-/
lemma ŒºNatIso_hom_app_app'' (X Y : C) :
  ((ŒºNatIso L W Œµ F).hom.app ((L').obj X)).app (L.obj Y) =
    Functor.LaxMonoidal.Œº (L ‚ãô F) X Y ‚â´
      F.map (Functor.OplaxMonoidal.Œ¥ L' X Y) :=
  ŒºNatIso_hom_app_app _ _ _ _ X Y

lemma ŒºNatIso_inv_app_app (X Y : C) :
    ((ŒºNatIso L W Œµ F).inv.app ((L').obj X)).app ((L').obj Y) =
      F.map (Functor.LaxMonoidal.Œº L' X Y) ‚â´ Functor.OplaxMonoidal.Œ¥ (L' ‚ãô F) X Y := by
  simp [ŒºNatIso, lift‚ÇÇNatIso, Lifting‚ÇÇ.iso, Lifting‚ÇÇ.iso']
  rfl

@[reassoc]
lemma ŒºNatIso_naturality {X X' Y Y' : LocalizedMonoidal L W Œµ} (f : X ‚ü∂ X') (g : Y ‚ü∂ Y') :
    (F.map f ‚äó‚Çò F.map g) ‚â´ ((ŒºNatIso L W Œµ F).hom.app X').app Y' =
      ((ŒºNatIso L W Œµ F).hom.app X).app Y ‚â´ F.map (f ‚äó‚Çò g) := by
  have := ((ŒºNatIso L W Œµ F).hom.app X').naturality g
  simp only [whiskeringLeft‚ÇÇ_obj_obj_obj_obj_obj, curriedTensor_obj_obj, Functor.comp_obj,
    whiskeringRight_obj_obj, whiskeringLeft‚ÇÇ_obj_obj_obj_obj_map, curriedTensor_obj_map,
    Functor.comp_map] at this
  rw [‚Üê Category.comp_id (F.map f), ‚Üê Category.id_comp (F.map g), MonoidalCategory.tensor_comp,
    MonoidalCategory.id_tensorHom, Category.assoc, this]
  have := (ŒºNatIso L W Œµ F).hom.naturality f
  apply NatTrans.congr_app at this
  simp only [whiskeringLeft‚ÇÇ_obj_obj_obj_obj_obj, curriedTensor_obj_obj, Functor.comp_obj,
    whiskeringRight_obj_obj, NatTrans.comp_app, whiskeringLeft‚ÇÇ_obj_obj_obj_map_app,
    curriedTensor_map_app, Functor.comp_map, whiskeringRight_obj_map,
    Functor.whiskerRight_app] at this
  specialize this Y
  rw [MonoidalCategory.tensorHom_id, ‚Üê Category.assoc, this]
  rw [Category.assoc, ‚Üê F.map_comp]
  congr

lemma ŒºNatIso_associativity_aux (X Y Z : C) :
    ((ŒºNatIso L W Œµ F).hom.app ((L').obj X ‚äó (L').obj Y)).app ((L').obj Z) =
      (((ŒºNatIso L W Œµ F).inv.app ((L').obj X)).app ((L').obj Y)) ‚ñ∑ F.obj ((L').obj Z) ‚â´
      (Œ±_ _ _ _).hom ‚â´
      (F.obj ((L').obj X)) ‚óÅ (((ŒºNatIso L W Œµ F).hom.app ((L').obj Y)).app ((L').obj Z)) ‚â´
      ((ŒºNatIso L W Œµ F).hom.app ((L').obj X)).app ((L').obj Y ‚äó (L').obj Z) ‚â´
      F.map (Œ±_ _ _ _).inv  := by
  simp [ŒºNatIso_inv_app_app, ŒºNatIso_hom_app_app]
  have := ((ŒºNatIso L W Œµ F).hom.app ((L').obj X)).naturality (Functor.LaxMonoidal.Œº L' Y Z)
  simp at this
  change _ = _ ‚â´ (F.mapIso (Functor.mapIso _ (Functor.Monoidal.ŒºIso L' Y Z))).hom at this
  rw [‚Üê Iso.comp_inv_eq] at this
  simp only [Functor.mapIso_inv, ŒºIso_inv, Functor.CoreMonoidal.toMonoidal_toOplaxMonoidal,
    Category.assoc] at this
  change _ ‚â´ _ ‚â´ F.map ((L').obj X ‚óÅ _) = _ at this
  rw [‚Üê this]
  simp [ŒºNatIso_hom_app_app]
  have := (ŒºNatIso L W Œµ F).hom.naturality ((Functor.LaxMonoidal.Œº L' X Y))
  apply NatTrans.congr_app at this
  specialize this ((L').obj Z)
  simp only [whiskeringLeft‚ÇÇ_obj_obj_obj_obj_obj, curriedTensor_obj_obj, Functor.comp_obj,
    whiskeringRight_obj_obj, Functor.CoreMonoidal.toMonoidal_toLaxMonoidal, NatTrans.comp_app,
    whiskeringLeft‚ÇÇ_obj_obj_obj_map_app, curriedTensor_map_app, Functor.comp_map,
    whiskeringRight_obj_map, Functor.whiskerRight_app] at this
  change _ = _ ‚â´ (F.mapIso ((Functor.mapIso _ (Functor.Monoidal.ŒºIso L' _ _)).app _)).hom at this
  rw [‚Üê Iso.comp_inv_eq] at this
  simp only [Functor.mapIso_inv, Iso.app_inv, Category.assoc] at this
  change _ ‚â´ _ ‚â´ F.map (_ ‚ñ∑ (L').obj Z) = _ at this
  rw [‚Üê this]
  simp only [ŒºNatIso_hom_app_app, Functor.comp_obj, Functor.CoreMonoidal.toMonoidal_toOplaxMonoidal,
    ŒºIso_inv, Category.assoc]
  slice_rhs 5 6 =>
    rw [‚Üê MonoidalCategory.whiskerLeft_comp, ‚Üê F.map_comp]
    simp only [Œ¥_Œº, Functor.map_id, MonoidalCategory.whiskerLeft_id]
  simp only [Category.id_comp, Category.assoc, ‚Üê Functor.comp_obj]
  rw [map_associator' (L' ‚ãô F)]
  slice_rhs 2 3 =>
    simp only [Functor.comp_obj]
    rw [‚Üê MonoidalCategory.comp_whiskerRight]
    simp only [Functor.comp_obj, Œ¥_Œº, id_whiskerRight]
  simp only [Functor.comp_obj, Category.id_comp, Functor.comp_map, Category.assoc, whiskerLeft_Œ¥_Œº,
    Category.comp_id, Œ¥_Œº]
  congr 2
  simp only [‚Üê F.map_comp]
  simp

/--
Monoidal structure on `F`, given that `L ‚ãô F` is monoidal, where `L` is a localization functor.
-/
noncomputable def functorCoremonoidalOfComp : F.CoreMonoidal where
  ŒµIso := ŒµIso (L ‚ãô F) ‚â™‚â´ F.mapIso Œµ
  ŒºIso X Y := ((ŒºNatIso L W Œµ F).app X).app Y
  ŒºIso_hom_natural_left f X := NatTrans.congr_app ((ŒºNatIso L W Œµ F).hom.naturality f) X
  ŒºIso_hom_natural_right X f := ((ŒºNatIso L W Œµ F).hom.app X).naturality f
  associativity X Y Z := by
    simp only [Functor.comp_obj, whiskeringRight_obj_obj, Iso.app_hom]
    obtain ‚ü®x, ‚ü®eX‚ü©‚ü© : ‚àÉ x, Nonempty ((L').obj x ‚âÖ X) := ‚ü®_, ‚ü®(L').objObjPreimageIso X‚ü©‚ü©
    obtain ‚ü®y, ‚ü®eY‚ü©‚ü© : ‚àÉ x, Nonempty ((L').obj x ‚âÖ Y) := ‚ü®_, ‚ü®(L').objObjPreimageIso Y‚ü©‚ü©
    obtain ‚ü®z, ‚ü®eZ‚ü©‚ü© : ‚àÉ x, Nonempty ((L').obj x ‚âÖ Z) := ‚ü®_, ‚ü®(L').objObjPreimageIso Z‚ü©‚ü©
    suffices ((ŒºNatIso L W Œµ F).hom.app ((L').obj x)).app ((L').obj y) ‚ñ∑ F.obj ((L').obj z) ‚â´
        ((ŒºNatIso L W Œµ F).hom.app (((L').obj x) ‚äó ((L').obj y))).app ((L').obj z) ‚â´
          F.map (Œ±_ ((L').obj x) ((L').obj y) ((L').obj z)).hom =
        (Œ±_ (F.obj ((L').obj x)) (F.obj ((L').obj y)) (F.obj ((L').obj z))).hom ‚â´
          F.obj ((L').obj x) ‚óÅ ((ŒºNatIso L W Œµ F).hom.app ((L').obj y)).app ((L').obj z) ‚â´
            ((ŒºNatIso L W Œµ F).hom.app ((L').obj x)).app (((L').obj y) ‚äó ((L').obj z)) by
      refine Eq.trans ?_ ((((F.map eX.inv ‚äó‚Çò F.map eY.inv) ‚äó‚Çò F.map eZ.inv) ‚â´= this =‚â´
        (F.map (eX.hom ‚äó‚Çò eY.hom ‚äó‚Çò eZ.hom))).trans ?_)
      ¬∑ simp only [Category.assoc]
        rw [‚Üê F.map_comp, ‚Üê associator_naturality, F.map_comp, ‚Üê ŒºNatIso_naturality_assoc]
        rw [‚Üê Category.comp_id (F.map eZ.inv), ‚Üê Category.id_comp (F.map eX.inv ‚äó‚Çò F.map eY.inv)]
        rw [MonoidalCategory.tensor_comp, MonoidalCategory.tensorHom_id]
        simp only [MonoidalCategory.id_tensorHom, whiskeringLeft‚ÇÇ_obj_obj_obj_obj_obj,
          curriedTensor_obj_obj, Functor.comp_obj, whiskeringRight_obj_obj, Category.assoc]
        rw [‚Üê comp_whiskerRight_assoc, ŒºNatIso_naturality]
        rw [MonoidalCategory.whisker_exchange_assoc]
        simp only [‚Üê Category.assoc]
        congr 2
        simp only [‚Üê MonoidalCategory.tensorHom_id, whiskeringLeft‚ÇÇ_obj_obj_obj_obj_obj,
          curriedTensor_obj_obj, Functor.comp_obj, whiskeringRight_obj_obj, ‚Üê
          MonoidalCategory.id_tensorHom, ‚Üê MonoidalCategory.tensor_comp, Category.comp_id,
          Category.id_comp, Category.assoc, ‚Üê Functor.map_comp, Iso.inv_hom_id, Functor.map_id]
        simp
      ¬∑ simp only [associator_conjugation, whiskeringLeft‚ÇÇ_obj_obj_obj_obj_obj,
          curriedTensor_obj_obj, Functor.comp_obj, whiskeringRight_obj_obj, Category.assoc,
          Iso.inv_hom_id_assoc, Iso.cancel_iso_hom_left]
        rw [‚Üê ŒºNatIso_naturality, ‚Üê MonoidalCategory.id_tensorHom, ‚Üê Functor.map_id]
        simp only [Functor.comp_obj, whiskeringRight_obj_obj, curriedTensor_obj_obj,
          ‚Üê MonoidalCategory.tensor_comp_assoc, ‚Üê Functor.map_comp, Category.id_comp,
          Iso.inv_hom_id]
        rw [ŒºNatIso_naturality_assoc]
        simp only [Functor.map_id, whiskeringRight_obj_obj, Functor.comp_obj, curriedTensor_obj_obj,
          MonoidalCategory.id_tensorHom, MonoidalCategory.whiskerLeft_comp, Category.assoc]
        slice_lhs 2 3 =>
          rw [‚Üê MonoidalCategory.whiskerLeft_comp, ‚Üê Functor.map_comp,
            ‚Üê MonoidalCategory.tensor_comp]
          simp only [Iso.inv_hom_id, MonoidalCategory.tensorHom_id, id_whiskerRight, Functor.map_id,
            MonoidalCategory.whiskerLeft_id]
        simp
    simp only [whiskeringLeft‚ÇÇ_obj_obj_obj_obj_obj, curriedTensor_obj_obj, Functor.comp_obj,
      whiskeringRight_obj_obj, ŒºNatIso_hom_app_app, Functor.CoreMonoidal.toMonoidal_toOplaxMonoidal,
      comp_whiskerRight, Category.assoc, MonoidalCategory.whiskerLeft_comp]
    rw [ŒºNatIso_associativity_aux]
    simp only [Functor.comp_obj, whiskeringRight_obj_obj, whiskeringLeft‚ÇÇ_obj_obj_obj_obj_obj,
      curriedTensor_obj_obj, ŒºNatIso_inv_app_app, Functor.CoreMonoidal.toMonoidal_toLaxMonoidal,
      comp_whiskerRight, ŒºNatIso_hom_app_app, Functor.CoreMonoidal.toMonoidal_toOplaxMonoidal,
      MonoidalCategory.whiskerLeft_comp, Category.assoc, Iso.map_inv_hom_id, Category.comp_id]
    simp only [‚Üê MonoidalCategory.tensorHom_id, ‚Üê MonoidalCategory.id_tensorHom,
      Category.comp_id, ‚Üê MonoidalCategory.tensor_comp_assoc, map_Œ¥_Œº_assoc, Œº_Œ¥, Functor.comp_obj]
    simp
  left_unitality X := by
    obtain ‚ü®x, ‚ü®eX‚ü©‚ü© : ‚àÉ x, Nonempty ((L').obj x ‚âÖ X) := ‚ü®_, ‚ü®(L').objObjPreimageIso X‚ü©‚ü©
    simp only [Functor.comp_obj, Iso.trans_hom, ŒµIso_hom, Functor.mapIso_hom, comp_whiskerRight,
      whiskeringRight_obj_obj, Iso.app_hom, Category.assoc]
    suffices (Œª_ (F.obj ((L').obj x))).hom = Functor.LaxMonoidal.Œµ (L ‚ãô F) ‚ñ∑ F.obj ((L').obj x) ‚â´
        F.map Œµ.hom ‚ñ∑ F.obj ((L').obj x) ‚â´ ((ŒºNatIso L W Œµ F).hom.app (ùüô_ _)).app ((L').obj x) ‚â´
          F.map (Œª_ ((L').obj x)).hom by
      refine Eq.trans ?_ (((_ ‚óÅ F.map eX.inv) ‚â´= this =‚â´ (F.map eX.hom)).trans ?_)
      ¬∑ simp
      ¬∑ simp only [id_whiskerLeft, Functor.comp_obj, whiskeringRight_obj_obj,
          curriedTensor_obj_obj, Functor.LaxMonoidal.left_unitality,
          Functor.CoreMonoidal.toMonoidal_toLaxMonoidal, Functor.map_comp, Category.assoc]
        slice_lhs 5 6 =>
          rw [‚Üê MonoidalCategory.tensorHom_id, ‚Üê Functor.map_id]
          change _ ‚â´ ((ŒºNatIso L W Œµ F).hom.app unit).app _
          rw [ŒºNatIso_naturality, ŒºNatIso_hom_app_app']
        simp only [whiskeringLeft‚ÇÇ_obj_obj_obj_obj_obj, curriedTensor_obj_obj, Functor.comp_obj,
          whiskeringRight_obj_obj, Functor.CoreMonoidal.toMonoidal_toOplaxMonoidal,
          MonoidalCategory.tensorHom_id, Category.assoc, ‚Üê Functor.map_comp]
        have : Functor.LaxMonoidal.Œµ L' = Œµ.inv := rfl
        rw [this, ‚Üê MonoidalCategory.comp_whiskerRight_assoc]
        simp only [Iso.hom_inv_id, id_whiskerRight, Category.id_comp, Œ¥_Œº_assoc, Functor.map_comp]
        slice_rhs 2 3 =>
          rw [‚Üê MonoidalCategory.tensorHom_id, ‚Üê Functor.map_id, ŒºNatIso_naturality]
        rw [@leftUnitor_inv_naturality_assoc]
        rw [Iso.hom_inv_id_assoc, MonoidalCategory.whisker_exchange_assoc]
        congr 1
        rw [‚Üê cancel_epi ((F.obj (L.obj (ùüô_ C))) ‚óÅ F.map eX.hom)]
        conv_rhs => rw [‚Üê MonoidalCategory.id_tensorHom, ‚Üê Functor.map_id, ‚Üê Category.assoc,
          ŒºNatIso_naturality_assoc]
        rw [ŒºNatIso_hom_app_app']
        simp only [whiskeringRight_obj_obj, Functor.comp_obj, curriedTensor_obj_obj,
          Functor.CoreMonoidal.toMonoidal_toOplaxMonoidal, MonoidalCategory.id_tensorHom,
          MonoidalCategory.tensorHom_id, Category.assoc]
        rw [‚Üê MonoidalCategory.whiskerLeft_comp_assoc, ‚Üê Functor.map_comp]
        simp only [Iso.hom_inv_id, Functor.map_id, MonoidalCategory.whiskerLeft_id,
          Category.id_comp, ‚Üê Functor.map_comp]
        congr 2
        rw [MonoidalCategory.whisker_exchange_assoc]
        rw [@leftUnitor_naturality]
        rw [@leftUnitor_hom_app, Œµ']
        slice_rhs 2 3 =>
          rw [‚Üê MonoidalCategory.comp_whiskerRight, Iso.hom_inv_id, whiskerRight_id]
        simp only [Category.id_comp, Category.assoc]
        change _ = _ ‚â´ Functor.LaxMonoidal.Œº L' _ _ ‚â´ _
        simp
    change (Œª_ ((L' ‚ãô F).obj x)).hom = _
    rw [Functor.LaxMonoidal.left_unitality (L' ‚ãô F)]
    simp only [Functor.comp_obj, Functor.comp_map, whiskeringRight_obj_obj, curriedTensor_obj_obj,
      Functor.LaxMonoidal.left_unitality, Functor.CoreMonoidal.toMonoidal_toLaxMonoidal]
    slice_rhs 2 4 =>
      rw [‚Üê MonoidalCategory.tensorHom_id, ‚Üê Functor.map_id]
      change _ ‚â´ ((ŒºNatIso L W Œµ F).hom.app unit).app _
      rw [ŒºNatIso_naturality]
    rw [ŒºNatIso_hom_app_app']
    simp only [whiskeringLeft‚ÇÇ_obj_obj_obj_obj_obj, curriedTensor_obj_obj, Functor.comp_obj,
      whiskeringRight_obj_obj, Functor.CoreMonoidal.toMonoidal_toOplaxMonoidal,
      MonoidalCategory.tensorHom_id, Category.assoc, ‚Üê Functor.map_comp]
    congr
    rw [‚Üê Functor.LaxMonoidal.left_unitality L', leftUnitor_hom_app]
    simp only [Œµ', hom_inv_whiskerRight_assoc]
    change _ = _ ‚â´ Functor.LaxMonoidal.Œº L' _ _ ‚â´ _
    simp
  right_unitality X := by
    obtain ‚ü®x, ‚ü®eX‚ü©‚ü© : ‚àÉ x, Nonempty ((L').obj x ‚âÖ X) := ‚ü®_, ‚ü®(L').objObjPreimageIso X‚ü©‚ü©
    simp only [Functor.comp_obj, Iso.trans_hom, ŒµIso_hom, Functor.mapIso_hom,
      MonoidalCategory.whiskerLeft_comp, whiskeringRight_obj_obj, Iso.app_hom, Category.assoc]
    suffices (œÅ_ (F.obj ((L').obj x))).hom = (F.obj ((L').obj x) ‚óÅ Functor.LaxMonoidal.Œµ (L ‚ãô F)) ‚â´
        (F.obj ((L').obj x) ‚óÅ F.map Œµ.hom) ‚â´ ((ŒºNatIso L W Œµ F).hom.app ((L').obj x)).app (ùüô_ _) ‚â´
          F.map (œÅ_ ((L').obj x)).hom by
      refine Eq.trans ?_ (((F.map eX.inv ‚ñ∑ _) ‚â´= this =‚â´ (F.map eX.hom)).trans ?_)
      ¬∑ simp
      ¬∑ simp only [MonoidalCategory.whiskerRight_id, Functor.comp_obj, whiskeringRight_obj_obj,
        curriedTensor_obj_obj, Functor.LaxMonoidal.right_unitality,
        Functor.CoreMonoidal.toMonoidal_toLaxMonoidal, Functor.map_comp, Category.assoc]
        slice_lhs 5 6 =>
          rw [‚Üê MonoidalCategory.id_tensorHom, ‚Üê Functor.map_id]
          change _ ‚â´ ((ŒºNatIso L W Œµ F).hom.app _).app unit
          rw [ŒºNatIso_naturality, ŒºNatIso_hom_app_app'']
        simp only [whiskeringLeft‚ÇÇ_obj_obj_obj_obj_obj, curriedTensor_obj_obj, Functor.comp_obj,
          whiskeringRight_obj_obj, Functor.CoreMonoidal.toMonoidal_toOplaxMonoidal,
          MonoidalCategory.id_tensorHom, Category.assoc, ‚Üê Functor.map_comp]
        have : Functor.LaxMonoidal.Œµ L' = Œµ.inv := rfl
        rw [this, ‚Üê MonoidalCategory.whiskerLeft_comp_assoc]
        simp only [Iso.hom_inv_id, Functor.map_comp]
        slice_rhs 2 3 =>
          rw [‚Üê MonoidalCategory.id_tensorHom, ‚Üê Functor.map_id, ŒºNatIso_naturality]
        rw [@rightUnitor_inv_naturality_assoc]
        rw [Iso.hom_inv_id_assoc, ‚Üê MonoidalCategory.whisker_exchange_assoc]
        congr 1
        rw [‚Üê cancel_epi (F.map eX.hom ‚ñ∑ (F.obj (L.obj (ùüô_ C))))]
        conv_rhs => rw [‚Üê MonoidalCategory.tensorHom_id, ‚Üê Functor.map_id, ‚Üê Category.assoc,
          ŒºNatIso_naturality_assoc]
        rw [ŒºNatIso_hom_app_app'']
        simp only [whiskeringRight_obj_obj, Functor.comp_obj, curriedTensor_obj_obj,
          Functor.CoreMonoidal.toMonoidal_toOplaxMonoidal, MonoidalCategory.id_tensorHom,
          MonoidalCategory.tensorHom_id, Category.assoc]
        rw [‚Üê MonoidalCategory.comp_whiskerRight_assoc, ‚Üê Functor.map_comp]
        simp only [Iso.hom_inv_id, Functor.map_id, id_whiskerRight, MonoidalCategory.whiskerLeft_id,
          ‚Üê Functor.map_comp, Category.id_comp]
        congr 2
        rw [‚Üê MonoidalCategory.whisker_exchange_assoc]
        rw [@rightUnitor_naturality]
        rw [@rightUnitor_hom_app, Œµ']
        slice_rhs 2 3 =>
          rw [‚Üê MonoidalCategory.whiskerLeft_comp, Iso.hom_inv_id, whiskerLeft_id]
        simp only [Category.assoc]
        rfl
    change (œÅ_ ((L' ‚ãô F).obj x)).hom = _
    rw [Functor.LaxMonoidal.right_unitality (L' ‚ãô F)]
    simp only [Functor.comp_obj, Functor.comp_map, whiskeringRight_obj_obj, curriedTensor_obj_obj,
      Functor.LaxMonoidal.right_unitality, Functor.CoreMonoidal.toMonoidal_toLaxMonoidal,
      Functor.map_comp]
    slice_rhs 2 4 =>
      rw [‚Üê MonoidalCategory.id_tensorHom, ‚Üê Functor.map_id]
      change _ ‚â´ ((ŒºNatIso L W Œµ F).hom.app _).app unit ‚â´ _
      rw [ŒºNatIso_naturality_assoc, ŒºNatIso_hom_app_app'']
    simp only [whiskeringRight_obj_obj, Functor.comp_obj, curriedTensor_obj_obj,
      Functor.CoreMonoidal.toMonoidal_toOplaxMonoidal, MonoidalCategory.id_tensorHom, ‚Üê
      Functor.map_comp, Category.assoc]
    congr
    rw [‚Üê Functor.LaxMonoidal.right_unitality L', rightUnitor_hom_app]
    simp only [Œµ', whiskerLeft_hom_inv_assoc]
    change _ = _ ‚â´ Functor.LaxMonoidal.Œº L' _ _ ‚â´ _
    simp

/--
Monoidal structure on `F`, given that `L ‚ãô F` is monoidal, where `L` is a localization functor.
-/
noncomputable def functorMonoidalOfComp : F.Monoidal :=
  (functorCoremonoidalOfComp L W Œµ F).toMonoidal

end CategoryTheory.Localization.Monoidal
