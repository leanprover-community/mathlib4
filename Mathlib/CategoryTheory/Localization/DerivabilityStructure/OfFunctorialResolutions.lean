/-
Copyright (c) 2025 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathlib.CategoryTheory.Localization.DerivabilityStructure.Constructor

/-!
# Functorial resolutions gives derivability structures

In this file, we provide a constructor for right derivability structures.
We assume that `Œ¶ : LocalizerMorphism W‚ÇÅ W‚ÇÇ` is given by
a fully faithful functor `Œ¶.functor : C‚ÇÅ ‚•§ C‚ÇÇ` and that we have a resolution
functor `œÅ : C‚ÇÇ ‚•§ C‚ÇÅ` with a natural transformation `i : ùü≠ C‚ÇÇ ‚ü∂ œÅ ‚ãô Œ¶.functor`
such that `W‚ÇÇ (i.app X‚ÇÇ)` for any `X‚ÇÇ : C‚ÇÇ`. Moreover, if we assume
that `W‚ÇÅ` is induced by `W‚ÇÇ`, that `W‚ÇÇ` is multiplicative and has
the two out of three property, then `Œ¶` is a right derivability structure.

-/

namespace CategoryTheory

variable {C‚ÇÅ C‚ÇÇ : Type*} [Category C‚ÇÅ] [Category C‚ÇÇ]
  {W‚ÇÅ : MorphismProperty C‚ÇÅ} {W‚ÇÇ : MorphismProperty C‚ÇÇ}

namespace LocalizerMorphism

section right

variable (Œ¶ : LocalizerMorphism W‚ÇÅ W‚ÇÇ)
  {œÅ : C‚ÇÇ ‚•§ C‚ÇÅ} (i : ùü≠ C‚ÇÇ ‚ü∂ œÅ ‚ãô Œ¶.functor) (hi : ‚àÄ X‚ÇÇ, W‚ÇÇ (i.app X‚ÇÇ))

include hi in
lemma hasRightResolutions_arrow_of_functorial_resolutions :
    Œ¶.arrow.HasRightResolutions :=
  fun f ‚Ü¶ ‚ü®{
    X‚ÇÅ := Arrow.mk (œÅ.map f.hom)
    w := Arrow.homMk (i.app _) (i.app _) ((i.naturality f.hom).symm)
    hw := ‚ü®hi _, hi _‚ü© }‚ü©

namespace functorialRightResolutions

variable {Œ¶ i}

/-- If `Œ¶ : LocalizerMorphism W‚ÇÅ W‚ÇÇ` corresponds to a class `W‚ÇÅ` that is
the inverse image of `W‚ÇÇ` by the functor `Œ¶.functor` and that we
have functorial right resolutions, then this is a morphism of localizers
in the other direction. -/
@[simps]
def localizerMorphismInv [W‚ÇÇ.HasTwoOutOfThreeProperty] [Œ¶.IsInduced] :
    LocalizerMorphism W‚ÇÇ W‚ÇÅ where
  functor := œÅ
  map := by
    rw [‚Üê Œ¶.inverseImage_eq]
    intro X Y f hf
    have := i.naturality f
    dsimp at this
    simp only [MorphismProperty.inverseImage_iff]
    rw [‚Üê W‚ÇÇ.precomp_iff _ _ (hi X), ‚Üê this]
    exact W‚ÇÇ.comp_mem _ _ hf (hi Y)

variable [Œ¶.functor.Full] [Œ¶.functor.Faithful]

variable (i) in
/-- If `Œ¶ : LocalizerMorphism W‚ÇÅ W‚ÇÇ` corresponds to a class `W‚ÇÅ` that is
induced by `W‚ÇÇ` via the fully faithful functor `Œ¶.functor` and that we
have functorial right resolutions given by a functor `œÅ : C‚ÇÇ ‚•§ C‚ÇÅ`, then
this is the natural transformation `ùü≠ C‚ÇÅ ‚ü∂ Œ¶.functor ‚ãô œÅ` induced
by `i : ùü≠ C‚ÇÇ ‚ü∂ œÅ ‚ãô Œ¶.functor`. -/
noncomputable def i' : ùü≠ C‚ÇÅ ‚ü∂ Œ¶.functor ‚ãô œÅ :=
  ((whiskeringRight C‚ÇÅ C‚ÇÅ C‚ÇÇ).obj Œ¶.functor).preimage (whiskerLeft Œ¶.functor i)

@[simp]
lemma Œ¶_functor_map_i'_app (X‚ÇÅ : C‚ÇÅ) :
    Œ¶.functor.map ((i' i).app X‚ÇÅ) = i.app (Œ¶.functor.obj X‚ÇÅ) :=
  NatTrans.congr_app (((whiskeringRight C‚ÇÅ C‚ÇÅ C‚ÇÇ).obj Œ¶.functor).map_preimage
    (X := ùü≠ C‚ÇÅ) (Y := Œ¶.functor ‚ãô œÅ) (whiskerLeft Œ¶.functor i)) X‚ÇÅ

include hi in
lemma W‚ÇÅ_i'_app [Œ¶.IsInduced] (X‚ÇÅ : C‚ÇÅ) : W‚ÇÅ ((i' i).app X‚ÇÅ) := by
  simpa only [‚Üê Œ¶.inverseImage_eq, MorphismProperty.inverseImage_iff, Œ¶_functor_map_i'_app]
    using hi (Œ¶.functor.obj X‚ÇÅ)

end functorialRightResolutions

variable [Œ¶.functor.Full] [Œ¶.functor.Faithful] [W‚ÇÇ.HasTwoOutOfThreeProperty]

open functorialRightResolutions
include hi in
lemma isLocalizedEquivalence_of_functorial_right_resolutions [Œ¶.IsInduced] :
    Œ¶.IsLocalizedEquivalence :=
  Œ¶.isLocalizedEquivalence_of_unit_of_unit (localizerMorphismInv hi) (i' i) i
    (W‚ÇÅ_i'_app hi) hi

include hi in
lemma isConnected_rightResolution_of_functorial_resolutions (X‚ÇÇ : C‚ÇÇ) :
    IsConnected (Œ¶.RightResolution X‚ÇÇ) := by
  have : Nonempty (Œ¶.RightResolution X‚ÇÇ) := ‚ü®{ hw := hi X‚ÇÇ, .. }‚ü©
  have : IsPreconnected (Œ¶.RightResolution X‚ÇÇ) := zigzag_isPreconnected (fun R‚ÇÄ R‚ÇÑ ‚Ü¶ by
    let R‚ÇÅ : Œ¶.RightResolution X‚ÇÇ := { hw := W‚ÇÇ.comp_mem _ _ R‚ÇÄ.hw (hi _), .. }
    let R‚ÇÇ : Œ¶.RightResolution X‚ÇÇ := { hw := hi X‚ÇÇ, .. }
    let R‚ÇÉ : Œ¶.RightResolution X‚ÇÇ := { hw := W‚ÇÇ.comp_mem _ _ R‚ÇÑ.hw (hi _), .. }
    let f‚ÇÄ : R‚ÇÄ ‚ü∂ R‚ÇÅ := { f := (i' i).app R‚ÇÄ.X‚ÇÅ }
    let f‚ÇÅ : R‚ÇÇ ‚ü∂ R‚ÇÅ :=
      { f := œÅ.map R‚ÇÄ.w
        comm := (i.naturality R‚ÇÄ.w).symm }
    let f‚ÇÇ : R‚ÇÇ ‚ü∂ R‚ÇÉ :=
      { f := œÅ.map R‚ÇÑ.w
        comm := (i.naturality R‚ÇÑ.w).symm }
    let f‚ÇÉ : R‚ÇÑ ‚ü∂ R‚ÇÉ := { f := (i' i).app R‚ÇÑ.X‚ÇÅ }
    exact (Zigzag.of_hom f‚ÇÄ).trans ((Zigzag.of_inv f‚ÇÅ).trans
      ((Zigzag.of_hom f‚ÇÇ).trans (Zigzag.of_inv f‚ÇÉ))) )
  constructor

include hi in
lemma isRightDerivabilityStructure_of_functorial_resolutions
    [W‚ÇÇ.ContainsIdentities] [Œ¶.IsInduced] :
    Œ¶.IsRightDerivabilityStructure := by
  have := Œ¶.isLocalizedEquivalence_of_functorial_right_resolutions i hi
  have := Œ¶.hasRightResolutions_arrow_of_functorial_resolutions i hi
  have := Œ¶.isConnected_rightResolution_of_functorial_resolutions i hi
  apply IsRightDerivabilityStructure.mk'

end right

section left

variable (Œ¶ : LocalizerMorphism W‚ÇÅ W‚ÇÇ)
  {œÅ : C‚ÇÇ ‚•§ C‚ÇÅ} (p : œÅ ‚ãô Œ¶.functor ‚ü∂ ùü≠ C‚ÇÇ) (hp : ‚àÄ X‚ÇÇ, W‚ÇÇ (p.app X‚ÇÇ))

include hp in
lemma hasLeftResolutions_arrow_of_functorial_resolutions :
    Œ¶.arrow.HasLeftResolutions :=
  fun f ‚Ü¶ ‚ü®{
    X‚ÇÅ := Arrow.mk (œÅ.map f.hom)
    w := Arrow.homMk (p.app _) (p.app _) ((p.naturality f.hom).symm)
    hw := ‚ü®hp _, hp _‚ü© }‚ü©

variable [Œ¶.functor.Full] [Œ¶.functor.Faithful] [W‚ÇÇ.HasTwoOutOfThreeProperty]

include hp
lemma isConnected_leftResolution_of_functorial_resolutions (X‚ÇÇ : C‚ÇÇ) :
    IsConnected (Œ¶.LeftResolution X‚ÇÇ) := by
  have : Œ¶.op.functor.Faithful := by dsimp; infer_instance
  have : Œ¶.op.functor.Full := by dsimp; infer_instance
  have : IsConnected (Œ¶.op.RightResolution (Opposite.op X‚ÇÇ)) :=
    Œ¶.op.isConnected_rightResolution_of_functorial_resolutions (œÅ := œÅ.op)
      (NatTrans.op p) (fun _ ‚Ü¶ hp _) _
  have := isConnected_of_equivalent (LeftResolution.opEquivalence Œ¶ X‚ÇÇ).symm
  exact isConnected_of_isConnected_op

lemma isLocalizedEquivalence_of_functorial_left_resolutions [Œ¶.IsInduced] :
    Œ¶.IsLocalizedEquivalence := by
  rw [‚Üê Œ¶.isLocalizedEquivalence_op_iff]
  have : Œ¶.op.functor.Full := by dsimp; infer_instance
  have : Œ¶.op.functor.Faithful := by dsimp; infer_instance
  exact Œ¶.op.isLocalizedEquivalence_of_functorial_right_resolutions (œÅ := œÅ.op)
    (NatTrans.op p) (fun _ ‚Ü¶ hp _)

lemma isLeftDerivabilityStructure_of_functorial_resolutions [W‚ÇÇ.IsMultiplicative]
    [Œ¶.IsInduced] :
    Œ¶.IsLeftDerivabilityStructure := by
  rw [isLeftDerivabilityStructure_iff_op]
  have : Œ¶.op.functor.Full := by dsimp; infer_instance
  have : Œ¶.op.functor.Faithful := by dsimp; infer_instance
  exact Œ¶.op.isRightDerivabilityStructure_of_functorial_resolutions (œÅ := œÅ.op)
    (NatTrans.op p) (fun _ ‚Ü¶ hp _)

end left

end LocalizerMorphism

end CategoryTheory
