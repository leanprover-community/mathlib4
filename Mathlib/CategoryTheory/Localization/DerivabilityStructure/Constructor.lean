/-
Copyright (c) 2024 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathlib.CategoryTheory.Localization.DerivabilityStructure.Basic

/-!
# Constructor for derivability structures

In this file, we provide a constructor for right derivability structures.
Assume that `W‚ÇÅ` and `W‚ÇÇ` are classes of morphisms in categories `C‚ÇÅ` and `C‚ÇÇ`,
and that we have a localizer morphism `Œ¶ : LocalizerMorphism W‚ÇÅ W‚ÇÇ` that is
a localized equivalence, i.e. `Œ¶.functor` induces an equivalence of categories
between the localized categories. Assume moreover that `W‚ÇÅ` is multiplicative
and `W‚ÇÇ` contains identities. Then, `Œ¶` is a right derivability structure
(`LocalizerMorphism.IsRightDerivabilityStructure.mk'`) if it satisfies the
two following conditions:
* for any `X‚ÇÇ : C‚ÇÇ`, the category `Œ¶.RightResolution X‚ÇÇ` of resolutions of `X‚ÇÇ` is connected
* any arrow in `C‚ÇÇ` admits a resolution (i.e. `Œ¶.arrow.HasRightResolutions` holds, where
  `Œ¶.arrow` is the induced localizer morphism on categories of arrows in `C‚ÇÅ` and `C‚ÇÇ`)

This statement is essentially Lemme 6.5 in
[the paper by Kahn and Maltsiniotis][KahnMaltsiniotis2008].

## References

* [Bruno Kahn and Georges Maltsiniotis, *Structures de d√©rivabilit√©*][KahnMaltsiniotis2008]

-/

namespace CategoryTheory

open Category Localization

variable {C‚ÇÅ C‚ÇÇ : Type*} [Category C‚ÇÅ] [Category C‚ÇÇ]
  {W‚ÇÅ : MorphismProperty C‚ÇÅ} {W‚ÇÇ : MorphismProperty C‚ÇÇ}

namespace LocalizerMorphism
namespace IsRightDerivabilityStructure

section

variable (Œ¶ : LocalizerMorphism W‚ÇÅ W‚ÇÇ)
  [‚àÄ X‚ÇÇ, IsConnected (Œ¶.RightResolution X‚ÇÇ)]
  [Œ¶.arrow.HasRightResolutions] [W‚ÇÇ.ContainsIdentities]

namespace Constructor

variable {D : Type*} [Category D] (L : C‚ÇÇ ‚•§ D) [L.IsLocalization W‚ÇÇ]
  {X‚ÇÇ : C‚ÇÇ} {X‚ÇÉ : D} (y : L.obj X‚ÇÇ ‚ü∂ X‚ÇÉ)

/-- Given `Œ¶ : LocalizerMorphism W‚ÇÅ W‚ÇÇ`, `L : C‚ÇÇ ‚•§ D` a localization functor for `W‚ÇÇ` and
a morphism `y : L.obj X‚ÇÇ ‚ü∂ X‚ÇÉ`, this is the functor which sends `R : Œ¶.RightResolution d` to
`(isoOfHom L W‚ÇÇ R.w R.hw).inv ‚â´ y` in the category `w.CostructuredArrowDownwards y`
where `w` is `TwoSquare.mk Œ¶.functor (Œ¶.functor ‚ãô L) L (ùü≠ _) (Functor.rightUnitor _).inv`. -/
@[simps]
noncomputable def fromRightResolution :
    Œ¶.RightResolution X‚ÇÇ ‚•§ (TwoSquare.mk Œ¶.functor (Œ¶.functor ‚ãô L) L (ùü≠ _)
      (Functor.rightUnitor _).inv).CostructuredArrowDownwards y where
  obj R := CostructuredArrow.mk (Y := StructuredArrow.mk R.w)
    (StructuredArrow.homMk ((isoOfHom L W‚ÇÇ R.w R.hw).inv ‚â´ y))
  map {R R'} œÜ := CostructuredArrow.homMk (StructuredArrow.homMk œÜ.f) (by
    ext
    dsimp
    rw [‚Üê assoc, ‚Üê cancel_epi (isoOfHom L W‚ÇÇ R.w R.hw).hom,
      isoOfHom_hom, isoOfHom_hom_inv_id_assoc, assoc, ‚Üê L.map_comp_assoc,
      œÜ.comm, isoOfHom_hom_inv_id_assoc])

lemma isConnected :
    IsConnected ((TwoSquare.mk Œ¶.functor (Œ¶.functor ‚ãô L) L (ùü≠ _)
      (Functor.rightUnitor _).inv).CostructuredArrowDownwards y) := by
  let w := (TwoSquare.mk Œ¶.functor (Œ¶.functor ‚ãô L) L (ùü≠ _) (Functor.rightUnitor _).inv)
  have : Nonempty (w.CostructuredArrowDownwards y) :=
    ‚ü®(fromRightResolution Œ¶ L y).obj (Classical.arbitrary _)‚ü©
  suffices ‚àÄ (X : w.CostructuredArrowDownwards y),
      ‚àÉ Y, Zigzag X ((fromRightResolution Œ¶ L y).obj Y) by
    refine zigzag_isConnected (fun X X' => ?_)
    obtain ‚ü®Y, hX‚ü© := this X
    obtain ‚ü®Y', hX'‚ü© := this X'
    exact hX.trans ((zigzag_obj_of_zigzag _ (isPreconnected_zigzag Y Y')).trans hX'.symm)
  intro X
  obtain ‚ü®c, g, x, fac, rfl‚ü© := TwoSquare.CostructuredArrowDownwards.mk_surjective X
  dsimp [w] at x fac
  rw [id_comp] at fac
  let œÅ : Œ¶.arrow.RightResolution (Arrow.mk g) := Classical.arbitrary _
  refine ‚ü®RightResolution.mk œÅ.w.left œÅ.hw.1, ?_‚ü©
  have := zigzag_obj_of_zigzag
    (fromRightResolution Œ¶ L x ‚ãô w.costructuredArrowDownwardsPrecomp x y g fac)
      (isPreconnected_zigzag (RightResolution.mk (ùüô _) (W‚ÇÇ.id_mem _))
        (RightResolution.mk œÅ.w.right œÅ.hw.2))
  refine Zigzag.trans ?_ (Zigzag.trans this ?_)
  ¬∑ exact Zigzag.of_hom (eqToHom (by simp))
  ¬∑ apply Zigzag.of_inv
    refine CostructuredArrow.homMk (StructuredArrow.homMk œÅ.X‚ÇÅ.hom (by simp)) ?_
    ext
    dsimp
    rw [‚Üê cancel_epi (isoOfHom L W‚ÇÇ œÅ.w.left œÅ.hw.1).hom, isoOfHom_hom,
      isoOfHom_hom_inv_id_assoc, ‚Üê L.map_comp_assoc, Arrow.w_mk_right, Arrow.mk_hom,
      L.map_comp, assoc, isoOfHom_hom_inv_id_assoc, fac]

end Constructor

/-- If a localizer morphism `Œ¶` is a localized equivalence, then it is a right
derivability structure if the categories of right resolutions are connected and the
categories of right resolutions of arrows are nonempty. -/
lemma mk' [Œ¶.IsLocalizedEquivalence] : Œ¶.IsRightDerivabilityStructure := by
  rw [Œ¶.isRightDerivabilityStructure_iff (Œ¶.functor ‚ãô W‚ÇÇ.Q) W‚ÇÇ.Q (ùü≠ _)
    (Functor.rightUnitor _).symm, TwoSquare.guitartExact_iff_isConnected_downwards]
  intro X‚ÇÇ X‚ÇÉ g
  apply Constructor.isConnected

end

section

variable (Œ¶ : LocalizerMorphism W‚ÇÅ W‚ÇÇ) {D‚ÇÅ D‚ÇÇ : Type*} [Category D‚ÇÅ] [Category D‚ÇÇ]
  (L‚ÇÅ : C‚ÇÅ ‚•§ D‚ÇÅ) (L‚ÇÇ : C‚ÇÇ ‚•§ D‚ÇÇ) [L‚ÇÅ.IsLocalization W‚ÇÅ] [L‚ÇÇ.IsLocalization W‚ÇÇ]
  (F : D‚ÇÅ ‚•§ D‚ÇÇ)
  [F.Full] [F.Faithful] [W‚ÇÇ.ContainsIdentities]
  [‚àÄ X‚ÇÇ, IsConnected (Œ¶.RightResolution X‚ÇÇ)]
  [HasRightResolutions Œ¶.arrow]

-- Kahn-Maltsiniotis, Lemme 6.5
/-- Constructor for right derivability structures. -/
lemma mk'' [CatCommSq Œ¶.functor L‚ÇÅ L‚ÇÇ F] : Œ¶.IsRightDerivabilityStructure := by
  have : Œ¶.IsLocalizedEquivalence := by
    have := Localization.essSurj L‚ÇÇ W‚ÇÇ
    have : F.EssSurj := ‚ü®fun Y => by
      let R : Œ¶.RightResolution (L‚ÇÇ.objPreimage Y) := Classical.arbitrary _
      exact ‚ü®L‚ÇÅ.obj R.X‚ÇÅ, ‚ü®(CatCommSq.iso Œ¶.functor L‚ÇÅ L‚ÇÇ F).symm.app R.X‚ÇÅ ‚â™‚â´
        (Localization.isoOfHom L‚ÇÇ W‚ÇÇ R.w R.hw).symm ‚â™‚â´ L‚ÇÇ.objObjPreimageIso Y‚ü©‚ü©‚ü©
    have : F.IsEquivalence := { }
    exact IsLocalizedEquivalence.mk' Œ¶ L‚ÇÅ L‚ÇÇ F
  apply mk'

end

end IsRightDerivabilityStructure

/-- If a localizer morphism `Œ¶` is a localized equivalence, then it is a left
derivability structure if the categories of left resolutions are connected and the
categories of left resolutions of arrows are nonempty. -/

lemma IsLeftDerivabilityStructure.mk' (Œ¶ : LocalizerMorphism W‚ÇÅ W‚ÇÇ)
    [‚àÄ (X‚ÇÇ : C‚ÇÇ), IsConnected (Œ¶.LeftResolution X‚ÇÇ)]
    [Œ¶.arrow.HasLeftResolutions] [W‚ÇÇ.ContainsIdentities] [Œ¶.IsLocalizedEquivalence] :
    Œ¶.IsLeftDerivabilityStructure := by
  rw [isLeftDerivabilityStructure_iff_op]
  have : Œ¶.op.arrow.HasRightResolutions := by
    rintro ‚ü®‚ü®X‚ü©, ‚ü®Y‚ü©, ‚ü®f : Y ‚ü∂ X‚ü©‚ü©
    have h : Œ¶.arrow.LeftResolution (Arrow.mk f) := Classical.arbitrary _
    exact ‚ü®{
      X‚ÇÅ := Arrow.mk h.X‚ÇÅ.hom.op
      w := Arrow.homMk h.w.right.op h.w.left.op (Quiver.Hom.unop_inj h.w.w.symm)
      hw := ‚ü®h.hw.2, h.hw.1‚ü©
    }‚ü©
  have (X‚ÇÇ : C‚ÇÇ·µí·µñ) : IsConnected (Œ¶.op.RightResolution X‚ÇÇ) :=
    isConnected_of_equivalent (LeftResolution.opEquivalence Œ¶ X‚ÇÇ.unop)
  apply IsRightDerivabilityStructure.mk'

end LocalizerMorphism

end CategoryTheory
