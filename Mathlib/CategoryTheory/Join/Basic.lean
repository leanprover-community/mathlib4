/-
Copyright (c) 2025 Robin Carlier. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Robin Carlier
-/
import Mathlib.CategoryTheory.Functor.Category
import Mathlib.CategoryTheory.Products.Basic

/-!
# Joins of category

Given categories `C, D`, this file constructs a category `C ‚ãÜ D`. Its objects are either
objects of `C` or objects of `D`, morphisms between objects of `C` are morphisms in `C`,
morphisms between object of `D` are morphisms in `D`, and finally, given `c : C` and `d : D`,
there is a unique morphism `c ‚ü∂ d` in `C ‚ãÜ D`.

## Main constructions

* `Join.edge c d`: the unique map from `c` to `d`.
* `Join.inclLeft : C ‚•§ C ‚ãÜ D`, the left inclusion. Its action on morphism is the main entry point
  to construct maps in `C ‚ãÜ D` between objects coming from `C`.
* `Join.inclRight : D ‚•§ C ‚ãÜ D`, the left inclusion. Its action on morphism is the main entry point
  to construct maps in `C ‚ãÜ D` between object coming from `D`.
* `Join.mkFunctor`, A constructor for functors out of a join of categories.
* `Join.mkNatTrans`, A constructor for natural transformations between functors out of a join
  of categories.
* `Join.mkNatIso`, A constructor for natural isomorphisms between functors out of a join
  of categories.

## References

* [Kerodon: section 1.4.3.2](https://kerodon.net/tag/0160)

-/

universe v‚ÇÅ v‚ÇÇ v‚ÇÉ v‚ÇÑ v‚ÇÖ v‚ÇÜ u‚ÇÅ u‚ÇÇ u‚ÇÉ u‚ÇÑ u‚ÇÖ u‚ÇÜ

namespace CategoryTheory

/-- Elements of `Join C D` are either elements of `C` or elements of `D`. -/
-- Impl. : We are not defining it as a type alias for `C ‚äï D` so that we can have
-- aesop to call cases on `Join C D`
inductive Join (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] (D : Type u‚ÇÇ) [Category.{v‚ÇÇ} D] : Type (max u‚ÇÅ u‚ÇÇ)
  | left : C ‚Üí Join C D
  | right : D ‚Üí Join C D

attribute [aesop safe cases (rule_sets := [CategoryTheory])] Join

namespace Join

@[inherit_doc] scoped infixr:30 " ‚ãÜ " => Join

variable (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] (D : Type u‚ÇÇ) [Category.{v‚ÇÇ} D]

section CategoryStructure

variable {C D}

/-- Morphisms in `C ‚ãÜ D` are those of `C` and `D`, plus an unique
morphism `(left c ‚ü∂ right d)` for every `c : C` and `d : D`. -/
def Hom : C ‚ãÜ D ‚Üí C ‚ãÜ D ‚Üí Type (max v‚ÇÅ v‚ÇÇ)
  | .left x, .left y => ULift (x ‚ü∂ y)
  | .right x, .right y => ULift (x ‚ü∂ y)
  | .left _, .right _ => PUnit
  | .right _, .left _ => PEmpty

/-- Identity morphisms in `C ‚ãÜ D` are inherited from those in `C` and `D`. -/
def id : ‚àÄ X : C ‚ãÜ D, Hom X X
  | .left x => ULift.up (ùüô x)
  | .right x => ULift.up (ùüô x)

/-- Composition in `C ‚ãÜ D` is inherited from the compositions in `C` and `D`. -/
def comp : ‚àÄ {x y z : C ‚ãÜ D}, Hom x y ‚Üí Hom y z ‚Üí Hom x z
  | .left _x, .left _y, .left _z, f, g => ULift.up (ULift.down f ‚â´ ULift.down g)
  | .left _x, .left _y, .right _z, _, _ => PUnit.unit
  | .left _x, .right _y, .right _z, _, _ =>  PUnit.unit
  | .right _x, .right _y, .right _z, f, g => ULift.up (ULift.down f ‚â´ ULift.down g)

instance : Category.{max v‚ÇÅ v‚ÇÇ} (C ‚ãÜ D) where
  Hom X Y := Hom X Y
  id _ := id _
  comp := comp
  assoc {a b c d} f g h := by
    cases a <;>
    cases b <;>
    cases c <;>
    cases d <;>
    simp only [Hom, id, comp, Category.assoc] <;>
    tauto
  id_comp {x y} f := by
    cases x <;> cases y <;> simp only [Hom, id, comp, Category.id_comp] <;> tauto
  comp_id {x y} f := by
    cases x <;> cases y <;> simp only [Hom, id, comp, Category.comp_id] <;> tauto

@[aesop safe destruct (rule_sets := [CategoryTheory])]
lemma false_of_right_to_left {X : D} {Y : C} (f : right X ‚ü∂ left Y) : False := (f : PEmpty).elim

instance {X : C} {Y : D} : Unique (left X ‚ü∂ right Y) := inferInstanceAs (Unique PUnit)

/-- Join.edge c d is the unique morphism from c to d. -/
def edge (c : C) (d : D) : left c ‚ü∂ right d := default

end CategoryStructure

section Inclusions

/-- The canonical inclusion from C to `C ‚ãÜ D`.
Terms of the form `(inclLeft C D).map f`should be treated as primitive when working with joins
and one should avoid trying to reduce them. For this reason, there is no `inclLeft_map` simp
lemma. -/
@[simps! obj]
def inclLeft : C ‚•§ C ‚ãÜ D where
  obj := left
  map := ULift.up

/-- The canonical inclusion from D to `C ‚ãÜ D`.
Terms of the form `(inclRight C D).map f`should be treated as primitive when working with joins
and one should avoid trying to reduce them. For this reason, there is no `inclRight_map` simp
lemma. -/
@[simps! obj]
def inclRight : D ‚•§ C ‚ãÜ D where
  obj := right
  map := ULift.up

variable {C D}

/-- An induction principle for morphisms in a join of category: a morphism is either of the form
`(inclLeft _ _).map _`, `(inclRight _ _).map _`, or is `edge _ _`. -/
@[elab_as_elim, cases_eliminator, induction_eliminator]
def homInduction {P : {x y : C ‚ãÜ D} ‚Üí (x ‚ü∂ y) ‚Üí Sort*}
    (left : ‚àÄ x y : C, (f : x ‚ü∂ y) ‚Üí P ((inclLeft C D).map f))
    (right : ‚àÄ x y : D, (f : x ‚ü∂ y) ‚Üí P ((inclRight C D).map f))
    (edge : ‚àÄ (c : C) (d : D), P (edge c d))
    {x y : C ‚ãÜ D} (f : x ‚ü∂ y) : P f :=
  match x, y, f with
  | .left x, .left y, .up f => left x y f
  | .right x, .right y, .up f => right x y f
  | .left x, .right y, _ => edge x y

@[simp]
lemma homInduction_left {P : {x y : C ‚ãÜ D} ‚Üí (x ‚ü∂ y) ‚Üí Sort*}
    (left : ‚àÄ x y : C, (f : x ‚ü∂ y) ‚Üí P ((inclLeft C D).map f))
    (right : ‚àÄ x y : D, (f : x ‚ü∂ y) ‚Üí P ((inclRight C D).map f))
    (edge : ‚àÄ (c : C) (d : D), P (edge c d))
    {x y : C} (f : x ‚ü∂ y) : homInduction left right edge ((inclLeft C D).map f) = left x y f :=
  rfl

@[simp]
lemma homInduction_right {P : {x y : C ‚ãÜ D} ‚Üí (x ‚ü∂ y) ‚Üí Sort*}
    (left : ‚àÄ x y : C, (f : x ‚ü∂ y) ‚Üí P ((inclLeft C D).map f))
    (right : ‚àÄ x y : D, (f : x ‚ü∂ y) ‚Üí P ((inclRight C D).map f))
    (edge : ‚àÄ (c : C) (d : D), P (edge c d))
    {x y : D} (f : x ‚ü∂ y) : homInduction left right edge ((inclRight C D).map f) = right x y f :=
  rfl

@[simp]
lemma homInduction_edge {P : {x y : C ‚ãÜ D} ‚Üí (x ‚ü∂ y) ‚Üí Sort*}
    (left : ‚àÄ x y : C, (f : x ‚ü∂ y) ‚Üí P ((inclLeft C D).map f))
    (right : ‚àÄ x y : D, (f : x ‚ü∂ y) ‚Üí P ((inclRight C D).map f))
    (edge : ‚àÄ (c : C) (d : D), P (edge c d))
    {c : C} {d : D} : homInduction left right edge (Join.edge c d) = edge c d :=
  rfl

variable (C D)

/-- The left inclusion is fully faithful. -/
def inclLeftFullyFaithful: (inclLeft C D).FullyFaithful where
  preimage f := f.down

/-- The right inclusion is fully faithful. -/
def inclRightFullyFaithful: (inclRight C D).FullyFaithful where
  preimage f := f.down

instance inclLeftFull: (inclLeft C D).Full := inclLeftFullyFaithful C D |>.full

instance inclRightFull: (inclRight C D).Full := inclRightFullyFaithful C D |>.full

instance inclLeftFaithFull: (inclLeft C D).Faithful := inclLeftFullyFaithful C D |>.faithful

instance inclRightFaithfull: (inclRight C D).Faithful := inclRightFullyFaithful C D |>.faithful

variable {C} in
/-- A situational lemma to help putting identities in the form `(inclLeft _ _).map _` when using
`homInduction`. -/
lemma id_left (c : C) : ùüô (left c) = (inclLeft C D).map (ùüô c) := rfl

variable {D} in
/-- A situational lemma to help putting identities in the form `(inclRight _ _).map _` when using
`homInduction`. -/
lemma id_right (d : D) : ùüô (right d) = (inclRight C D).map (ùüô d) := rfl

/-- The "canonical" natural transformation from `(Prod.fst C D) ‚ãô inclLeft C D` to
`(Prod.snd C D) ‚ãô inclRight C D`. This is bundling together all the edge morphisms
into the data of a natural transformation. -/
@[simps!]
def edgeTransform :
    Prod.fst C D ‚ãô inclLeft C D ‚ü∂ Prod.snd C D ‚ãô inclRight C D where
  app := fun (c, d) ‚Ü¶ edge c d

end Inclusions

section Functoriality

variable {C D} {E : Type u‚ÇÉ} [Category.{v‚ÇÉ} E] {E' : Type u‚ÇÑ} [Category.{v‚ÇÑ} E']

/-- A pair of functor `F : C ‚•§ E, G : D ‚•§ E` as well as a natural transformation
`Œ± : (Prod.fst C D) ‚ãô F ‚ü∂ (Prod.snd C D) ‚ãô G`. defines a functor out of `C ‚ãÜ D`.
This is the main entry point to define functors out of a join of categories. -/
def mkFunctor (F : C ‚•§ E) (G : D ‚•§ E) (Œ± : Prod.fst C D ‚ãô F ‚ü∂ Prod.snd C D ‚ãô G) :
    C ‚ãÜ D ‚•§ E where
  obj X :=
    match X with
    | .left x => F.obj x
    | .right x => G.obj x
  map f :=
    homInduction
      (left := fun _ _ f ‚Ü¶ F.map f)
      (right := fun _ _ g ‚Ü¶ G.map g)
      (edge := fun c d ‚Ü¶ Œ±.app (c,d))
      f
  map_id x := by
    cases x
    ¬∑ dsimp only [id_left, homInduction_left]
      simp
    ¬∑ dsimp only [id_right, homInduction_right]
      simp
  map_comp {x y z} f g := by
    cases f <;> cases g
    ¬∑ simp [‚Üê Functor.map_comp]
    ¬∑ case left.edge f d => simpa using (Œ±.naturality <| (Prod.sectL _ d).map f).symm
    ¬∑ simp [‚Üê Functor.map_comp]
    ¬∑ case edge.right c _ _ f => simpa using Œ±.naturality <| (Prod.sectR c _).map f

section

variable (F : C ‚•§ E) (G : D ‚•§ E) (Œ± : Prod.fst C D ‚ãô F ‚ü∂ Prod.snd C D ‚ãô G)

-- As these equality of objects are definitional, they should be fine.
@[simp]
lemma mkFunctor_obj_left (c : C) : (mkFunctor F G Œ±).obj (left c) = F.obj c := rfl

@[simp]
lemma mkFunctor_obj_right (d : D) : (mkFunctor F G Œ±).obj (right d) = G.obj d := rfl

@[simp]
lemma mkFunctor_map_inclLeft {c c' : C} (f : c ‚ü∂ c') :
    (mkFunctor F G Œ±).map ((inclLeft C D).map f) = F.map f :=
  rfl

/-- Precomposing `mkFunctor F G Œ±` with the left inclusion gives back `F`. -/
@[simps!]
def mkFunctorLeft : inclLeft C D ‚ãô mkFunctor F G Œ± ‚âÖ F := Iso.refl _

/-- Precomposing `mkFunctor F G Œ±` with the right inclusion gives back `G`. -/
@[simps!]
def mkFunctorRight : inclRight C D ‚ãô mkFunctor F G Œ± ‚âÖ G := Iso.refl _

@[simp]
lemma mkFunctor_map_inclRight {d d' : D} (f : d ‚ü∂ d') :
    (mkFunctor F G Œ±).map ((inclRight C D).map f) = G.map f :=
  rfl

/-- Whiskering `mkFunctor F G Œ±` with the universal transformation gives back `Œ±`. -/
@[simp]
lemma mkFunctor_edgeTransform :
    whiskerRight (edgeTransform C D) (mkFunctor F G Œ±) = Œ± := by
  ext x
  simp [mkFunctor]

@[simp]
lemma mkFunctor_map_edge (c : C) (d : D) :
    (mkFunctor F G Œ±).map (edge c d) = Œ±.app (c, d) :=
  rfl

end

/-- Construct a natural transformation between functors from a join from
the data of natural transformations between each side that are compatible with the
action on edge maps. -/
def mkNatTrans {F : C ‚ãÜ D ‚•§ E} {F' : C ‚ãÜ D ‚•§ E}
    (Œ±‚Çó : inclLeft C D ‚ãô F ‚ü∂ inclLeft C D ‚ãô F') (Œ±·µ£ : inclRight C D ‚ãô F ‚ü∂ inclRight C D ‚ãô F')
    (h : whiskerRight (edgeTransform C D) F ‚â´ whiskerLeft (Prod.snd C D) Œ±·µ£ =
      whiskerLeft (Prod.fst C D) Œ±‚Çó ‚â´ whiskerRight (edgeTransform C D) F' :=
      by aesop_cat) :
    F ‚ü∂ F' where
  app x := match x with
    | left x => Œ±‚Çó.app x
    | right x => Œ±·µ£.app x
  naturality {x y} f := by
    cases f with
    | @left x y f => simpa using Œ±‚Çó.naturality f
    | @right x y f => simpa using Œ±·µ£.naturality f
    | @edge c d => exact funext_iff.mp (NatTrans.ext_iff.mp h) (c, d)

section

variable {F : C ‚ãÜ D ‚•§ E} {F' : C ‚ãÜ D ‚•§ E}
    (Œ±‚Çó : inclLeft C D ‚ãô F ‚ü∂ inclLeft C D ‚ãô F') (Œ±·µ£ : inclRight C D ‚ãô F ‚ü∂ inclRight C D ‚ãô F')
    (h : whiskerRight (edgeTransform C D) F ‚â´ whiskerLeft (Prod.snd C D) Œ±·µ£ =
      whiskerLeft (Prod.fst C D) Œ±‚Çó ‚â´ whiskerRight (edgeTransform C D) F' :=
      by aesop_cat)

@[simp]
lemma mkNatTrans_app_left (c : C) : (mkNatTrans Œ±‚Çó Œ±·µ£ h).app (left c) = Œ±‚Çó.app c := rfl

@[simp]
lemma mkNatTrans_app_right (d : D) : (mkNatTrans Œ±‚Çó Œ±·µ£ h).app (right d) = Œ±·µ£.app d := rfl

@[simp]
lemma whiskerLeft_inclLeft_mkNatTrans : whiskerLeft (inclLeft C D) (mkNatTrans Œ±‚Çó Œ±·µ£ h) = Œ±‚Çó := rfl

@[simp]
lemma whiskerLeft_inclRight_mkNatTrans :
    whiskerLeft (inclRight C D) (mkNatTrans Œ±‚Çó Œ±·µ£ h) = Œ±·µ£ := rfl

end

/-- Two natural transformations between functors out of a join are equal if they are so
after whiskering with the inclusions. -/
lemma natTrans_ext {F F' : C ‚ãÜ D ‚•§ E} {Œ± Œ≤ : F ‚ü∂ F'}
    (h‚ÇÅ : whiskerLeft (inclLeft C D) Œ± = whiskerLeft (inclLeft C D) Œ≤)
    (h‚ÇÇ : whiskerLeft (inclRight C D) Œ± = whiskerLeft (inclRight C D) Œ≤) :
    Œ± = Œ≤ := by
  ext t
  cases t with
  | left t => exact congrArg (fun x ‚Ü¶ x.app t) h‚ÇÅ
  | right t => exact congrArg (fun x ‚Ü¶ x.app t) h‚ÇÇ

lemma eq_mkNatTrans {F F' : C ‚ãÜ D ‚•§ E} (Œ± : F ‚ü∂ F') :
    mkNatTrans (whiskerLeft (inclLeft C D) Œ±) (whiskerLeft (inclRight C D) Œ±) = Œ± := by
  apply natTrans_ext <;> simp

section

/-- `mkNatTrans` respects vertical composition. -/
lemma mkNatTransComp
    {F F' F'' : C ‚ãÜ D ‚•§ E}
    (Œ±‚Çó : inclLeft C D ‚ãô F ‚ü∂ inclLeft C D ‚ãô F')
    (Œ±·µ£ : inclRight C D ‚ãô F ‚ü∂ inclRight C D ‚ãô F')
    (Œ≤‚Çó : inclLeft C D ‚ãô F' ‚ü∂ inclLeft C D ‚ãô F'')
    (Œ≤·µ£ : inclRight C D ‚ãô F' ‚ü∂ inclRight C D ‚ãô F'')
    (h : whiskerRight (edgeTransform C D) F ‚â´ whiskerLeft (Prod.snd C D) Œ±·µ£ =
      whiskerLeft (Prod.fst C D) Œ±‚Çó ‚â´ whiskerRight (edgeTransform C D) F' :=
      by aesop_cat)
    (h' : whiskerRight (edgeTransform C D) F' ‚â´ whiskerLeft (Prod.snd C D) Œ≤·µ£ =
      whiskerLeft (Prod.fst C D) Œ≤‚Çó ‚â´ whiskerRight (edgeTransform C D) F'' := by aesop_cat) :
    mkNatTrans (Œ±‚Çó ‚â´ Œ≤‚Çó) (Œ±·µ£ ‚â´ Œ≤·µ£) (by simp [‚Üê h', reassoc_of% h]) =
    mkNatTrans Œ±‚Çó Œ±·µ£ h ‚â´ mkNatTrans Œ≤‚Çó Œ≤·µ£ h' := by
  apply natTrans_ext <;> aesop_cat

end

/-- Two functors out of a join of category are naturally isomorphic if their
compositions with the inclusions are isomorphic and the whiskering with the canonical
transformation is respected through these isomorphisms. -/
@[simps]
def mkNatIso {F : C ‚ãÜ D ‚•§ E} {G : C ‚ãÜ D ‚•§ E}
    (e‚Çó : inclLeft C D ‚ãô F ‚âÖ inclLeft C D ‚ãô G)
    (e·µ£ : inclRight C D ‚ãô F ‚âÖ inclRight C D ‚ãô G)
    (h : whiskerRight (edgeTransform C D) F ‚â´ (isoWhiskerLeft (Prod.snd C D) e·µ£).hom =
      (isoWhiskerLeft (Prod.fst C D) e‚Çó).hom ‚â´ whiskerRight (edgeTransform C D) G := by aesop_cat) :
    F ‚âÖ G where
  hom := mkNatTrans e‚Çó.hom e·µ£.hom (by simpa using h)
  inv := mkNatTrans e‚Çó.inv e·µ£.inv (by rw [Eq.comm, ‚Üê isoWhiskerLeft_inv, ‚Üê isoWhiskerLeft_inv,
    Iso.inv_comp_eq, ‚Üê Category.assoc, Eq.comm, Iso.comp_inv_eq, h])

/-- A pair of functors ((C ‚•§ E), (D ‚•§ E')) induces a functor `C ‚ãÜ D ‚•§ E ‚ãÜ E'`. -/
def mapPair (F‚Çó : C ‚•§ E) (F·µ£ : D ‚•§ E') : C ‚ãÜ D ‚•§ E ‚ãÜ E' :=
  mkFunctor (F‚Çó ‚ãô inclLeft _ _) (F·µ£ ‚ãô inclRight _ _) { app := fun _ ‚Ü¶ edge _ _ }

section mapPair

variable (F‚Çó : C ‚•§ E) (F·µ£ : D ‚•§ E')

@[simp]
lemma mapPair_obj_left (c : C) : (mapPair F‚Çó F·µ£).obj (left c) = left (F‚Çó.obj c) := rfl

@[simp]
lemma mapPair_obj_right (d : D) : (mapPair F‚Çó F·µ£).obj (right d) = right (F·µ£.obj d) := rfl

@[simp]
lemma mapPair_map_inclLeft {c c' : C} (f : c ‚ü∂ c') :
    (mapPair F‚Çó F·µ£).map ((inclLeft C D).map f) = (inclLeft E E').map (F‚Çó.map f) := rfl

@[simp]
lemma mapPair_map_inclRight {d d' : D} (f : d ‚ü∂ d') :
    (mapPair F‚Çó F·µ£).map ((inclRight C D).map f) = (inclRight E E').map (F·µ£.map f) := rfl

/-- Characterizing `mapPair` on left morphisms. -/
@[simps! hom_app inv_app]
def mapPairLeft : inclLeft _ _ ‚ãô mapPair F‚Çó F·µ£ ‚âÖ F‚Çó ‚ãô inclLeft _ _ := mkFunctorLeft _ _ _

/-- Characterizing `mapPair` on right morphisms. -/
@[simps! hom_app inv_app]
def mapPairRight : inclRight _ _ ‚ãô mapPair F‚Çó F·µ£ ‚âÖ F·µ£ ‚ãô inclRight _ _ := mkFunctorRight _ _ _

end mapPair

/-- Any functor out of a join is naturally isomorphic to a functor of the form `mkFunctor F G Œ±`. -/
@[simps!]
def isoMkFunctor (F : C ‚ãÜ D ‚•§ E) :
    F ‚âÖ mkFunctor (inclLeft C D ‚ãô F) (inclRight C D ‚ãô F) (whiskerRight (edgeTransform C D) F) :=
  mkNatIso (mkFunctorLeft _ _ _).symm (mkFunctorRight _ _ _).symm

/-- `mapPair` respects identities -/
@[simps!]
def mapPairId : mapPair (ùü≠ C) (ùü≠ D) ‚âÖ ùü≠ (C ‚ãÜ D) :=
  mkNatIso
    (mapPairLeft _ _ ‚â™‚â´ Functor.leftUnitor _ ‚â™‚â´ (Functor.rightUnitor _).symm)
    (mapPairRight _ _ ‚â™‚â´ Functor.leftUnitor _ ‚â™‚â´ (Functor.rightUnitor _).symm)

variable {J : Type u‚ÇÖ} [Category.{v‚ÇÖ} J]
  {K : Type u‚ÇÜ} [Category.{v‚ÇÜ} K]

-- @[simps!] times out here
/-- `mapPair` respects composition -/
def mapPairComp (F‚Çó : C ‚•§ E) (F·µ£ : D ‚•§ E') (G‚Çó : E ‚•§ J) (G·µ£ : E' ‚•§ K) :
    mapPair (F‚Çó ‚ãô G‚Çó) (F·µ£ ‚ãô G·µ£) ‚âÖ mapPair F‚Çó F·µ£ ‚ãô mapPair G‚Çó G·µ£ :=
  mkNatIso
    (mapPairLeft (F‚Çó ‚ãô G‚Çó) (F·µ£ ‚ãô G·µ£) ‚â™‚â´
      Functor.associator F‚Çó G‚Çó (inclLeft J K) ‚â™‚â´
      (isoWhiskerLeft F‚Çó (mapPairLeft G‚Çó G·µ£).symm) ‚â™‚â´
      (Functor.associator F‚Çó (inclLeft E E') (mapPair G‚Çó G·µ£)).symm ‚â™‚â´
      isoWhiskerRight (mapPairLeft F‚Çó F·µ£).symm (mapPair G‚Çó G·µ£))
    (mapPairRight (F‚Çó ‚ãô G‚Çó) (F·µ£ ‚ãô G·µ£) ‚â™‚â´
      Functor.associator F·µ£ G·µ£ (inclRight J K) ‚â™‚â´
      (isoWhiskerLeft F·µ£ (mapPairRight G‚Çó G·µ£).symm) ‚â™‚â´
      (Functor.associator F·µ£ (inclRight E E') (mapPair G‚Çó G·µ£)).symm ‚â™‚â´
      isoWhiskerRight (mapPairRight F‚Çó F·µ£).symm (mapPair G‚Çó G·µ£))

section mapPairComp

variable (F‚Çó : C ‚•§ E) (F·µ£ : D ‚•§ E') (G‚Çó : E ‚•§ J) (G·µ£ : E' ‚•§ K)

@[simp]
lemma mapPairComp_hom_app_left (c : C) :
    (mapPairComp F‚Çó F·µ£ G‚Çó G·µ£).hom.app (left c) = ùüô (left (G‚Çó.obj (F‚Çó.obj c))) := by
  dsimp [mapPairComp]
  simp

@[simp]
lemma mapPairComp_hom_app_right (d : D) :
    (mapPairComp F‚Çó F·µ£ G‚Çó G·µ£).hom.app (right d) = ùüô (right (G·µ£.obj (F·µ£.obj d))) := by
  dsimp [mapPairComp]
  simp

@[simp]
lemma mapPairComp_inv_app_left (c : C) :
    (mapPairComp F‚Çó F·µ£ G‚Çó G·µ£).inv.app (left c) = ùüô (left (G‚Çó.obj (F‚Çó.obj c))) := by
  dsimp [mapPairComp]
  simp

@[simp]
lemma mapPairComp_inv_app_right (d : D) :
    (mapPairComp F‚Çó F·µ£ G‚Çó G·µ£).inv.app (right d) = ùüô (right (G·µ£.obj (F·µ£.obj d))) := by
  dsimp [mapPairComp]
  simp

end mapPairComp

end Functoriality

section NaturalTransforms

variable {E : Type u‚ÇÉ} [Category.{v‚ÇÉ} E]
  {E' : Type u‚ÇÑ} [Category.{v‚ÇÑ} E']

variable {C D}

/-- A natural transformation `F‚Çó ‚ü∂ G‚Çó` induces a natural transformation
  `mapPair F‚Çó H ‚ü∂ mapPair G‚Çó H` for every `H : D ‚•§ E'`. -/
@[simps!]
def mapWhiskerRight {F‚Çó : C ‚•§ E} {G‚Çó : C ‚•§ E} (Œ± : F‚Çó ‚ü∂ G‚Çó) (H : D ‚•§ E') :
    mapPair F‚Çó H ‚ü∂ mapPair G‚Çó H :=
  mkNatTrans
    ((mapPairLeft F‚Çó H).hom ‚â´ whiskerRight Œ± (inclLeft E E') ‚â´ (mapPairLeft G‚Çó H).inv)
    ((mapPairRight F‚Çó H).hom ‚â´ whiskerRight (ùüô H) (inclRight E E') ‚â´ (mapPairRight G‚Çó H).inv)

@[simp]
lemma mapWhiskerRight_comp {F‚Çó : C ‚•§ E} {G‚Çó : C ‚•§ E} {H‚Çó : C ‚•§ E}
    (Œ± : F‚Çó ‚ü∂ G‚Çó) (Œ≤ : G‚Çó ‚ü∂ H‚Çó) (H : D ‚•§ E') :
    mapWhiskerRight (Œ± ‚â´ Œ≤) H = mapWhiskerRight Œ± H ‚â´ mapWhiskerRight Œ≤ H := by
  aesop_cat

/-- A natural transformation `F·µ£ ‚ü∂ G·µ£` induces a natural transformation
  `mapPair H F·µ£ ‚ü∂ mapPair H G·µ£` for every `H : C ‚•§ E`. -/
@[simps!]
def mapWhiskerLeft (H : C ‚•§ E) {F·µ£ : D ‚•§ E'} {G·µ£ : D ‚•§ E'} (Œ± : F·µ£ ‚ü∂ G·µ£) :
    mapPair H F·µ£ ‚ü∂ mapPair H G·µ£ :=
  mkNatTrans
    ((mapPairLeft H F·µ£).hom ‚â´ whiskerRight (ùüô H) (inclLeft E E') ‚â´ (mapPairLeft H G·µ£).inv)
    ((mapPairRight H F·µ£).hom ‚â´ whiskerRight Œ± (inclRight E E') ‚â´ (mapPairRight H G·µ£).inv)

@[simp]
lemma mapWhiskerLeft_comp {F·µ£ : D ‚•§ E'} {G·µ£ : D ‚•§ E'} {H·µ£ : D ‚•§ E'}
    (H : C ‚•§ E) (Œ± : F·µ£ ‚ü∂ G·µ£) (Œ≤ : G·µ£ ‚ü∂ H·µ£) :
    mapWhiskerLeft H (Œ± ‚â´ Œ≤) = mapWhiskerLeft H Œ± ‚â´ mapWhiskerLeft H Œ≤ := by
  aesop_cat

/-- One can exchange `mapWhiskerLeft` and `mapWhiskerRight`. -/
lemma mapWhisker_exchange (F‚Çó : C ‚•§ E) (G‚Çó : C ‚•§ E) (F·µ£ : D ‚•§ E') (G·µ£ : D ‚•§ E')
    (Œ±‚Çó : F‚Çó ‚ü∂ G‚Çó) (Œ±·µ£ : F·µ£ ‚ü∂ G·µ£) :
    mapWhiskerLeft F‚Çó Œ±·µ£ ‚â´ mapWhiskerRight Œ±‚Çó G·µ£ =
      mapWhiskerRight Œ±‚Çó F·µ£ ‚â´ mapWhiskerLeft G‚Çó Œ±·µ£ := by
  ext
  aesop_cat

/-- A natural isomorphism `F·µ£ ‚âÖ G·µ£` induces a natural isomorphism
  `mapPair H F·µ£ ‚âÖ mapPair H G·µ£` for every `H : C ‚•§ E`. -/
@[simps!]
def mapIsoWhiskerLeft (H : C ‚•§ E) {F·µ£ : D ‚•§ E'} {G·µ£ : D ‚•§ E'} (Œ± : F·µ£ ‚âÖ G·µ£) :
    mapPair H F·µ£ ‚âÖ mapPair H G·µ£ :=
  mkNatIso
    (mapPairLeft H F·µ£ ‚â™‚â´ isoWhiskerRight (Iso.refl H) (inclLeft _ _) ‚â™‚â´ (mapPairLeft H G·µ£).symm)
    (mapPairRight H F·µ£ ‚â™‚â´ isoWhiskerRight Œ± (inclRight E E') ‚â™‚â´ (mapPairRight H G·µ£).symm)

/-- A natural isomorphism `F·µ£ ‚âÖ G·µ£` induces a natural isomorphism
  `mapPair F‚Çó H ‚âÖ mapPair G‚Çó H` for every `H : C ‚•§ E`. -/
@[simps!]
def mapIsoWhiskerRight {F‚Çó : C ‚•§ E} {G‚Çó : C ‚•§ E} (Œ± : F‚Çó ‚âÖ G‚Çó) (H : D ‚•§ E') :
    mapPair F‚Çó H ‚âÖ mapPair G‚Çó H :=
  mkNatIso
    (mapPairLeft F‚Çó H ‚â™‚â´ isoWhiskerRight Œ± (inclLeft E E') ‚â™‚â´ (mapPairLeft G‚Çó H).symm)
    (mapPairRight F‚Çó H ‚â™‚â´ isoWhiskerRight (Iso.refl H) (inclRight E E') ‚â™‚â´ (mapPairRight G‚Çó H).symm)

lemma mapIsoWhiskerRight_hom {F‚Çó : C ‚•§ E} {G‚Çó : C ‚•§ E} (Œ± : F‚Çó ‚âÖ G‚Çó) (H : D ‚•§ E') :
    (mapIsoWhiskerRight Œ± H).hom = mapWhiskerRight Œ±.hom H := rfl

lemma mapIsoWhiskerRight_inv {F‚Çó : C ‚•§ E} {G‚Çó : C ‚•§ E} (Œ± : F‚Çó ‚âÖ G‚Çó) (H : D ‚•§ E') :
    (mapIsoWhiskerRight Œ± H).inv = mapWhiskerRight Œ±.inv H := by
  ext x
  cases x <;> simp [mapIsoWhiskerRight]

lemma mapIsoWhiskerLeft_hom (H : C ‚•§ E) {F·µ£ : D ‚•§ E'} {G·µ£ : D ‚•§ E'} (Œ± : F·µ£ ‚âÖ G·µ£) :
    (mapIsoWhiskerLeft H Œ±).hom = mapWhiskerLeft H Œ±.hom := rfl

lemma mapIsoWhiskerLeft_inv (H : C ‚•§ E) {F·µ£ : D ‚•§ E'} {G·µ£ : D ‚•§ E'} (Œ± : F·µ£ ‚âÖ G·µ£) :
    (mapIsoWhiskerLeft H Œ±).inv = mapWhiskerLeft H Œ±.inv := by
  ext x
  cases x <;> simp [mapIsoWhiskerLeft]

end NaturalTransforms

section mapPairEquiv

variable {C' : Type u‚ÇÉ} [Category.{v‚ÇÉ} C']
  {D' : Type u‚ÇÑ} [Category.{v‚ÇÑ} D']

variable {C D}

/-- Equivalent categories have equivalent joins. -/
@[simps]
def mapPairEquiv (e : C ‚âå C') (e' : D ‚âå D') : C ‚ãÜ D ‚âå C' ‚ãÜ D' where
  functor := mapPair e.functor e'.functor
  inverse := mapPair e.inverse e'.inverse
  unitIso :=
    mapPairId.symm ‚â™‚â´
      mapIsoWhiskerRight e.unitIso _ ‚â™‚â´
      mapIsoWhiskerLeft _ e'.unitIso ‚â™‚â´
      mapPairComp _ _ _ _
  counitIso :=
    (mapPairComp _ _ _ _).symm ‚â™‚â´
      mapIsoWhiskerRight e.counitIso _ ‚â™‚â´
      mapIsoWhiskerLeft _ e'.counitIso ‚â™‚â´
      mapPairId
  functor_unitIso_comp x := by
    cases x <;>
    simp [‚Üê (inclLeft C' D').map_comp, ‚Üê (inclRight C' D').map_comp]

instance isEquivalenceMapPair {F : C ‚•§ C'} {F' : D ‚•§ D'} [F.IsEquivalence] [F'.IsEquivalence] :
    (mapPair F F').IsEquivalence :=
  inferInstanceAs (mapPairEquiv F.asEquivalence F'.asEquivalence).functor.IsEquivalence

end mapPairEquiv

end Join

end CategoryTheory
