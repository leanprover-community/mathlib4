/-
Copyright (c) 2021 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison

! This file was ported from Lean 3 source module category_theory.monoidal.center
! leanprover-community/mathlib commit 14b69e9f3c16630440a2cbd46f1ddad0d561dee7
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Monoidal.Braided
import Mathbin.CategoryTheory.Functor.ReflectsIsomorphisms
import Mathbin.CategoryTheory.Monoidal.Coherence

/-!
# Half braidings and the Drinfeld center of a monoidal category

We define `center C` to be pairs `‚ü®X, b‚ü©`, where `X : C` and `b` is a half-braiding on `X`.

We show that `center C` is braided monoidal,
and provide the monoidal functor `center.forget` from `center C` back to `C`.

## Future work

Verifying the various axioms here is done by tedious rewriting.
Using the `slice` tactic may make the proofs marginally more readable.

More exciting, however, would be to make possible one of the following options:
1. Integration with homotopy.io / globular to give "picture proofs".
2. The monoidal coherence theorem, so we can ignore associators
   (after which most of these proofs are trivial;
   I'm unsure if the monoidal coherence theorem is even usable in dependent type theory).
3. Automating these proofs using `rewrite_search` or some relative.

-/


open CategoryTheory

open CategoryTheory.MonoidalCategory

universe v v‚ÇÅ v‚ÇÇ v‚ÇÉ u u‚ÇÅ u‚ÇÇ u‚ÇÉ

noncomputable section

namespace CategoryTheory

variable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] [MonoidalCategory C]

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/-- A half-braiding on `X : C` is a family of isomorphisms `X ‚äó U ‚âÖ U ‚äó X`,
monoidally natural in `U : C`.

Thinking of `C` as a 2-category with a single `0`-morphism, these are the same as natural
transformations (in the pseudo- sense) of the identity 2-functor on `C`, which send the unique
`0`-morphism to `X`.
-/
@[nolint has_nonempty_instance]
structure HalfBraiding (X : C) where
  Œ≤ : ‚àÄ U, X ‚äó U ‚âÖ U ‚äó X
  monoidal' :
    ‚àÄ U U',
      (Œ≤ (U ‚äó U')).Hom =
        (Œ±_ _ _ _).inv ‚â´
          ((Œ≤ U).Hom ‚äó ùüô U') ‚â´ (Œ±_ _ _ _).Hom ‚â´ (ùüô U ‚äó (Œ≤ U').Hom) ‚â´ (Œ±_ _ _ _).inv := by
    obviously
  naturality' : ‚àÄ {U U'} (f : U ‚ü∂ U'), (ùüô X ‚äó f) ‚â´ (Œ≤ U').Hom = (Œ≤ U).Hom ‚â´ (f ‚äó ùüô X) := by
    obviously
#align category_theory.half_braiding CategoryTheory.HalfBraiding

restate_axiom half_braiding.monoidal'

attribute [reassoc, simp] half_braiding.monoidal

-- the reassoc lemma is redundant as a simp lemma
restate_axiom half_braiding.naturality'

attribute [simp, reassoc] half_braiding.naturality

variable (C)

/-- The Drinfeld center of a monoidal category `C` has as objects pairs `‚ü®X, b‚ü©`, where `X : C`
and `b` is a half-braiding on `X`.
-/
@[nolint has_nonempty_instance]
def Center :=
  Œ£ X : C, HalfBraiding X
#align category_theory.center CategoryTheory.Center

namespace Center

variable {C}

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/-- A morphism in the Drinfeld center of `C`. -/
@[ext, nolint has_nonempty_instance]
structure Hom (X Y : Center C) where
  f : X.1 ‚ü∂ Y.1
  comm' : ‚àÄ U, (f ‚äó ùüô U) ‚â´ (Y.2.Œ≤ U).Hom = (X.2.Œ≤ U).Hom ‚â´ (ùüô U ‚äó f) := by obviously
#align category_theory.center.hom CategoryTheory.Center.Hom

restate_axiom hom.comm'

attribute [simp, reassoc] hom.comm

instance : Category (Center C) where
  Hom := Hom
  id X := { f := ùüô X.1 }
  comp X Y Z f g := { f := f.f ‚â´ g.f }

@[simp]
theorem id_f (X : Center C) : Hom.f (ùüô X) = ùüô X.1 :=
  rfl
#align category_theory.center.id_f CategoryTheory.Center.id_f

@[simp]
theorem comp_f {X Y Z : Center C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : (f ‚â´ g).f = f.f ‚â´ g.f :=
  rfl
#align category_theory.center.comp_f CategoryTheory.Center.comp_f

@[ext]
theorem ext {X Y : Center C} (f g : X ‚ü∂ Y) (w : f.f = g.f) : f = g := by cases f; cases g; congr;
  exact w
#align category_theory.center.ext CategoryTheory.Center.ext

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/-- Construct an isomorphism in the Drinfeld center from
a morphism whose underlying morphism is an isomorphism.
-/
@[simps]
def isoMk {X Y : Center C} (f : X ‚ü∂ Y) [IsIso f.f] : X ‚âÖ Y
    where
  Hom := f
  inv :=
    ‚ü®inv f.f, fun U => by simp [‚Üê cancel_epi (f.f ‚äó ùüô U), ‚Üê comp_tensor_id_assoc, ‚Üê id_tensor_comp]‚ü©
#align category_theory.center.iso_mk CategoryTheory.Center.isoMk

instance isIso_of_f_isIso {X Y : Center C} (f : X ‚ü∂ Y) [IsIso f.f] : IsIso f :=
  by
  change is_iso (iso_mk f).Hom
  infer_instance
#align category_theory.center.is_iso_of_f_is_iso CategoryTheory.Center.isIso_of_f_isIso

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/-- Auxiliary definition for the `monoidal_category` instance on `center C`. -/
@[simps]
def tensorObj (X Y : Center C) : Center C :=
  ‚ü®X.1 ‚äó Y.1,
    { Œ≤ := fun U =>
        Œ±_ _ _ _ ‚â™‚â´
          (Iso.refl X.1 ‚äó Y.2.Œ≤ U) ‚â™‚â´ (Œ±_ _ _ _).symm ‚â™‚â´ (X.2.Œ≤ U ‚äó Iso.refl Y.1) ‚â™‚â´ Œ±_ _ _ _
      monoidal' := fun U U' => by
        dsimp
        simp only [comp_tensor_id, id_tensor_comp, category.assoc, half_braiding.monoidal]
        -- On the RHS, we'd like to commute `((X.snd.Œ≤ U).hom ‚äó ùüô Y.fst) ‚äó ùüô U'`
        -- and `ùüô U ‚äó ùüô X.fst ‚äó (Y.snd.Œ≤ U').hom` past each other,
        -- but there are some associators we need to get out of the way first.
        slice_rhs 6 8 => rw [pentagon]
        slice_rhs 5 6 => rw [associator_naturality]
        slice_rhs 7 8 => rw [‚Üê associator_naturality]
        slice_rhs 6 7 =>
          rw [tensor_id, tensor_id, tensor_id_comp_id_tensor, ‚Üê id_tensor_comp_tensor_id, ‚Üê
            tensor_id, ‚Üê tensor_id]
        -- Now insert associators as needed to make the four half-braidings look identical
        slice_rhs 10 10 => rw [associator_inv_conjugation]
        slice_rhs 7 7 => rw [associator_inv_conjugation]
        slice_rhs 6 6 => rw [associator_conjugation]
        slice_rhs 3 3 => rw [associator_conjugation]
        -- Finish with an application of the coherence theorem.
        coherence
      naturality' := fun U U' f => by
        dsimp
        rw [category.assoc, category.assoc, category.assoc, category.assoc,
          id_tensor_associator_naturality_assoc, ‚Üê id_tensor_comp_assoc, half_braiding.naturality,
          id_tensor_comp_assoc, associator_inv_naturality_assoc, ‚Üê comp_tensor_id_assoc,
          half_braiding.naturality, comp_tensor_id_assoc, associator_naturality, ‚Üê tensor_id] }‚ü©
#align category_theory.center.tensor_obj CategoryTheory.Center.tensorObj

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/-- Auxiliary definition for the `monoidal_category` instance on `center C`. -/
@[simps]
def tensorHom {X‚ÇÅ Y‚ÇÅ X‚ÇÇ Y‚ÇÇ : Center C} (f : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (g : X‚ÇÇ ‚ü∂ Y‚ÇÇ) :
    tensorObj X‚ÇÅ X‚ÇÇ ‚ü∂ tensorObj Y‚ÇÅ Y‚ÇÇ where
  f := f.f ‚äó g.f
  comm' U := by
    dsimp
    rw [category.assoc, category.assoc, category.assoc, category.assoc, associator_naturality_assoc,
      ‚Üê tensor_id_comp_id_tensor, category.assoc, ‚Üê id_tensor_comp_assoc, g.comm,
      id_tensor_comp_assoc, tensor_id_comp_id_tensor_assoc, ‚Üê id_tensor_comp_tensor_id,
      category.assoc, associator_inv_naturality_assoc, id_tensor_associator_inv_naturality_assoc,
      tensor_id, id_tensor_comp_tensor_id_assoc, ‚Üê tensor_id_comp_id_tensor g.f, category.assoc, ‚Üê
      comp_tensor_id_assoc, f.comm, comp_tensor_id_assoc, id_tensor_associator_naturality,
      associator_naturality_assoc, ‚Üê id_tensor_comp, tensor_id_comp_id_tensor]
#align category_theory.center.tensor_hom CategoryTheory.Center.tensorHom

/-- Auxiliary definition for the `monoidal_category` instance on `center C`. -/
@[simps]
def tensorUnit : Center C :=
  ‚ü®ùüô_ C,
    { Œ≤ := fun U => Œª_ U ‚â™‚â´ (œÅ_ U).symm
      monoidal' := fun U U' => by simp
      naturality' := fun U U' f => by
        dsimp
        rw [left_unitor_naturality_assoc, right_unitor_inv_naturality, category.assoc] }‚ü©
#align category_theory.center.tensor_unit CategoryTheory.Center.tensorUnit

/-- Auxiliary definition for the `monoidal_category` instance on `center C`. -/
def associator (X Y Z : Center C) : tensorObj (tensorObj X Y) Z ‚âÖ tensorObj X (tensorObj Y Z) :=
  isoMk
    ‚ü®(Œ±_ X.1 Y.1 Z.1).Hom, fun U => by
      dsimp
      simp only [comp_tensor_id, id_tensor_comp, ‚Üê tensor_id, associator_conjugation]
      coherence‚ü©
#align category_theory.center.associator CategoryTheory.Center.associator

/-- Auxiliary definition for the `monoidal_category` instance on `center C`. -/
def leftUnitor (X : Center C) : tensorObj tensorUnit X ‚âÖ X :=
  isoMk
    ‚ü®(Œª_ X.1).Hom, fun U => by
      dsimp
      simp only [category.comp_id, category.assoc, tensor_inv_hom_id, comp_tensor_id,
        tensor_id_comp_id_tensor, triangle_assoc_comp_right_inv]
      rw [‚Üê left_unitor_tensor, left_unitor_naturality, left_unitor_tensor'_assoc]‚ü©
#align category_theory.center.left_unitor CategoryTheory.Center.leftUnitor

/-- Auxiliary definition for the `monoidal_category` instance on `center C`. -/
def rightUnitor (X : Center C) : tensorObj X tensorUnit ‚âÖ X :=
  isoMk
    ‚ü®(œÅ_ X.1).Hom, fun U => by
      dsimp
      simp only [tensor_id_comp_id_tensor_assoc, triangle_assoc, id_tensor_comp, category.assoc]
      rw [‚Üê tensor_id_comp_id_tensor_assoc (œÅ_ U).inv, cancel_epi, ‚Üê right_unitor_tensor_inv_assoc,
        ‚Üê right_unitor_inv_naturality_assoc]
      simp‚ü©
#align category_theory.center.right_unitor CategoryTheory.Center.rightUnitor

section

attribute [local simp] associator_naturality left_unitor_naturality right_unitor_naturality pentagon

attribute [local simp] center.associator center.left_unitor center.right_unitor

instance : MonoidalCategory (Center C)
    where
  tensorObj X Y := tensorObj X Y
  tensorHom X‚ÇÅ Y‚ÇÅ X‚ÇÇ Y‚ÇÇ f g := tensorHom f g
  tensorUnit := tensorUnit
  associator := associator
  leftUnitor := leftUnitor
  rightUnitor := rightUnitor

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
@[simp]
theorem tensor_fst (X Y : Center C) : (X ‚äó Y).1 = X.1 ‚äó Y.1 :=
  rfl
#align category_theory.center.tensor_fst CategoryTheory.Center.tensor_fst

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
@[simp]
theorem tensor_Œ≤ (X Y : Center C) (U : C) :
    (X ‚äó Y).2.Œ≤ U =
      Œ±_ _ _ _ ‚â™‚â´
        (Iso.refl X.1 ‚äó Y.2.Œ≤ U) ‚â™‚â´ (Œ±_ _ _ _).symm ‚â™‚â´ (X.2.Œ≤ U ‚äó Iso.refl Y.1) ‚â™‚â´ Œ±_ _ _ _ :=
  rfl
#align category_theory.center.tensor_Œ≤ CategoryTheory.Center.tensor_Œ≤

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
@[simp]
theorem tensor_f {X‚ÇÅ Y‚ÇÅ X‚ÇÇ Y‚ÇÇ : Center C} (f : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (g : X‚ÇÇ ‚ü∂ Y‚ÇÇ) : (f ‚äó g).f = f.f ‚äó g.f :=
  rfl
#align category_theory.center.tensor_f CategoryTheory.Center.tensor_f

@[simp]
theorem tensorUnit_Œ≤ (U : C) : (ùüô_ (Center C)).2.Œ≤ U = Œª_ U ‚â™‚â´ (œÅ_ U).symm :=
  rfl
#align category_theory.center.tensor_unit_Œ≤ CategoryTheory.Center.tensorUnit_Œ≤

@[simp]
theorem associator_hom_f (X Y Z : Center C) : Hom.f (Œ±_ X Y Z).Hom = (Œ±_ X.1 Y.1 Z.1).Hom :=
  rfl
#align category_theory.center.associator_hom_f CategoryTheory.Center.associator_hom_f

@[simp]
theorem associator_inv_f (X Y Z : Center C) : Hom.f (Œ±_ X Y Z).inv = (Œ±_ X.1 Y.1 Z.1).inv := by ext;
  rw [‚Üê associator_hom_f, ‚Üê comp_f, iso.hom_inv_id]; rfl
#align category_theory.center.associator_inv_f CategoryTheory.Center.associator_inv_f

@[simp]
theorem leftUnitor_hom_f (X : Center C) : Hom.f (Œª_ X).Hom = (Œª_ X.1).Hom :=
  rfl
#align category_theory.center.left_unitor_hom_f CategoryTheory.Center.leftUnitor_hom_f

@[simp]
theorem leftUnitor_inv_f (X : Center C) : Hom.f (Œª_ X).inv = (Œª_ X.1).inv := by ext;
  rw [‚Üê left_unitor_hom_f, ‚Üê comp_f, iso.hom_inv_id]; rfl
#align category_theory.center.left_unitor_inv_f CategoryTheory.Center.leftUnitor_inv_f

@[simp]
theorem rightUnitor_hom_f (X : Center C) : Hom.f (œÅ_ X).Hom = (œÅ_ X.1).Hom :=
  rfl
#align category_theory.center.right_unitor_hom_f CategoryTheory.Center.rightUnitor_hom_f

@[simp]
theorem rightUnitor_inv_f (X : Center C) : Hom.f (œÅ_ X).inv = (œÅ_ X.1).inv := by ext;
  rw [‚Üê right_unitor_hom_f, ‚Üê comp_f, iso.hom_inv_id]; rfl
#align category_theory.center.right_unitor_inv_f CategoryTheory.Center.rightUnitor_inv_f

end

section

variable (C)

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/-- The forgetful monoidal functor from the Drinfeld center to the original category. -/
@[simps]
def forget : MonoidalFunctor (Center C) C
    where
  obj X := X.1
  map X Y f := f.f
  Œµ := ùüô (ùüô_ C)
  Œº X Y := ùüô (X.1 ‚äó Y.1)
#align category_theory.center.forget CategoryTheory.Center.forget

instance : ReflectsIsomorphisms (forget C).toFunctor
    where reflects A B f i := by dsimp at i ; skip; change is_iso (iso_mk f).Hom; infer_instance

end

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/-- Auxiliary definition for the `braided_category` instance on `center C`. -/
@[simps]
def braiding (X Y : Center C) : X ‚äó Y ‚âÖ Y ‚äó X :=
  isoMk
    ‚ü®(X.2.Œ≤ Y.1).Hom, fun U => by
      dsimp
      simp only [category.assoc]
      rw [‚Üê is_iso.inv_comp_eq, is_iso.iso.inv_hom, ‚Üê half_braiding.monoidal_assoc, ‚Üê
        half_braiding.naturality_assoc, half_braiding.monoidal]
      simp‚ü©
#align category_theory.center.braiding CategoryTheory.Center.braiding

instance braidedCategoryCenter : BraidedCategory (Center C)
    where
  braiding := braiding
  braiding_naturality' X Y X' Y' f g := by
    ext
    dsimp
    rw [‚Üê tensor_id_comp_id_tensor, category.assoc, half_braiding.naturality, f.comm_assoc,
      id_tensor_comp_tensor_id]
#align category_theory.center.braided_category_center CategoryTheory.Center.braidedCategoryCenter

-- `obviously` handles the hexagon axioms
section

variable [BraidedCategory C]

open BraidedCategory

/-- Auxiliary construction for `of_braided`. -/
@[simps]
def ofBraidedObj (X : C) : Center C :=
  ‚ü®X, {
      Œ≤ := fun Y => Œ≤_ X Y
      monoidal' := fun U U' =>
        by
        rw [iso.eq_inv_comp, ‚Üê category.assoc, ‚Üê category.assoc, iso.eq_comp_inv, category.assoc,
          category.assoc]
        exact hexagon_forward X U U' }‚ü©
#align category_theory.center.of_braided_obj CategoryTheory.Center.ofBraidedObj

variable (C)

/-- The functor lifting a braided category to its center, using the braiding as the half-braiding.
-/
@[simps]
def ofBraided : MonoidalFunctor C (Center C)
    where
  obj := ofBraidedObj
  map X X' f :=
    { f
      comm' := fun U => braiding_naturality _ _ }
  Œµ :=
    { f := ùüô _
      comm' := fun U => by
        dsimp
        rw [tensor_id, category.id_comp, tensor_id, category.comp_id, ‚Üê braiding_right_unitor,
          category.assoc, iso.hom_inv_id, category.comp_id] }
  Œº X Y :=
    { f := ùüô _
      comm' := fun U => by
        dsimp
        rw [tensor_id, tensor_id, category.id_comp, category.comp_id, ‚Üê iso.inv_comp_eq, ‚Üê
          category.assoc, ‚Üê category.assoc, ‚Üê iso.comp_inv_eq, category.assoc, hexagon_reverse,
          category.assoc] }
#align category_theory.center.of_braided CategoryTheory.Center.ofBraided

end

end Center

end CategoryTheory

