/-
Copyright (c) 2024 Lean FRO LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import Mathlib.CategoryTheory.Monoidal.Bimon_
import Mathlib.CategoryTheory.Monoidal.Conv

/-!
# The category of Hopf monoids in a braided monoidal category.


## TODO

* Show that in a Cartesian monoidal category Hopf monoids are exactly group objects.
* Show that `Hopf (ModuleCat R) ‚âå HopfAlgCat R`.
-/

noncomputable section

universe v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ u

open CategoryTheory MonoidalCategory

variable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] [MonoidalCategory.{v‚ÇÅ} C] [BraidedCategory C]

open scoped MonObj ComonObj

/--
A Hopf monoid in a braided category `C` is a bimonoid object in `C` equipped with an antipode.
-/
class HopfObj (X : C) extends BimonObj X where
  /-- The antipode is an endomorphism of the underlying object of the Hopf monoid. -/
  antipode : X ‚ü∂ X
  antipode_left (X) : Œî ‚â´ antipode ‚ñ∑ X ‚â´ Œº = Œµ ‚â´ Œ∑ := by cat_disch
  antipode_right (X) : Œî ‚â´ X ‚óÅ antipode ‚â´ Œº = Œµ ‚â´ Œ∑ := by cat_disch

@[deprecated (since := "2025-09-14")] alias Hopf_Class := HopfObj

namespace HopfObj

@[inherit_doc] scoped notation "ùíÆ" => HopfObj.antipode
@[inherit_doc] scoped notation "ùíÆ["M"]" => HopfObj.antipode (X := M)

attribute [reassoc (attr := simp)] antipode_left antipode_right


end HopfObj

variable (C)

/--
A Hopf monoid in a braided category `C` is a bimonoid object in `C` equipped with an antipode.
-/
structure Hopf where
  /-- The underlying object in the ambient monoidal category -/
  X : C
  [hopf : HopfObj X]

@[deprecated (since := "2025-09-15")] alias Hopf_ := Hopf

attribute [instance] Hopf.hopf

namespace Hopf

variable {C}

/-- A Hopf monoid is a bimonoid. -/
def toBimon (A : Hopf C) : Bimon C := .mk' A.X

@[deprecated (since := "2025-09-15")] alias toBimon_ := toBimon

/--
Morphisms of Hopf monoids are just morphisms of the underlying bimonoids.
In fact they automatically intertwine the antipodes, proved below.
-/
instance : Category (Hopf C) :=
  inferInstanceAs <| Category (InducedCategory (Bimon C) Hopf.toBimon)

end Hopf

namespace HopfObj

variable {C}

/-- Morphisms of Hopf monoids intertwine the antipodes. -/
theorem hom_antipode {A B : C} [HopfObj A] [HopfObj B] (f : A ‚ü∂ B) [IsBimonHom f] :
    f ‚â´ ùíÆ = ùíÆ ‚â´ f := by
  -- We show these elements are equal by exhibiting an element in the convolution algebra
  -- between `A` (as a comonoid) and `B` (as a monoid),
  -- such that the LHS is a left inverse, and the RHS is a right inverse.
  apply left_inv_eq_right_inv
    (M := Conv A B)
    (a := f)
  ¬∑ rw [Conv.mul_eq, Conv.one_eq]
    simp only [comp_whiskerRight, Category.assoc]
    slice_lhs 3 4 =>
      rw [‚Üê whisker_exchange]
    slice_lhs 2 3 =>
      rw [‚Üê tensorHom_def]
    slice_lhs 1 2 =>
      rw [‚Üê IsComonHom.hom_comul f]
    slice_lhs 2 4 =>
      rw [antipode_left]
    slice_lhs 1 2 =>
      rw [IsComonHom.hom_counit]
  ¬∑ rw [Conv.mul_eq, Conv.one_eq]
    simp only [whiskerLeft_comp, Category.assoc]
    slice_lhs 2 3 =>
      rw [‚Üê whisker_exchange]
    slice_lhs 3 4 =>
      rw [‚Üê tensorHom_def]
    slice_lhs 3 4 =>
      rw [‚Üê IsMonHom.mul_hom]
    slice_lhs 1 3 =>
      rw [antipode_right]
    slice_lhs 2 3 =>
      rw [IsMonHom.one_hom]

@[reassoc (attr := simp)]
theorem one_antipode (A : C) [HopfObj A] : Œ∑[A] ‚â´ ùíÆ[A] = Œ∑[A] := by
  have := (rfl : Œ∑[A] ‚â´ Œî[A] ‚â´ (ùíÆ[A] ‚ñ∑ A) ‚â´ Œº[A] = _)
  conv at this =>
    rhs
    rw [antipode_left]
  rw [Bimon.one_comul_assoc, tensorHom_def_assoc, unitors_inv_equal,
    ‚Üê rightUnitor_inv_naturality_assoc, whisker_exchange_assoc, ‚Üê rightUnitor_inv_naturality_assoc,
    rightUnitor_inv_naturality_assoc] at this
  simpa

@[reassoc (attr := simp)]
theorem antipode_counit (A : C) [HopfObj A] : ùíÆ[A] ‚â´ Œµ[A] = Œµ[A] := by
  have := (rfl : Œî[A] ‚â´ (ùíÆ[A] ‚ñ∑ A) ‚â´ Œº[A] ‚â´ Œµ[A] = _)
  conv at this =>
    rhs
    rw [antipode_left_assoc]
  rw [Bimon.mul_counit, tensorHom_def', Category.assoc, ‚Üê whisker_exchange_assoc] at this
  simpa [unitors_equal]

/-!
## The antipode is an antihomomorphism with respect to both the monoid and comonoid structures.
-/

theorem antipode_comul‚ÇÅ (A : C) [HopfObj A] :
    Œî[A] ‚â´
      ùíÆ[A] ‚ñ∑ A ‚â´
      Œî[A] ‚ñ∑ A ‚â´
      (Œ±_ A A A).hom ‚â´
      A ‚óÅ A ‚óÅ Œî[A] ‚â´
      A ‚óÅ (Œ±_ A A A).inv ‚â´
      A ‚óÅ (Œ≤_ A A).hom ‚ñ∑ A ‚â´
      A ‚óÅ (Œ±_ A A A).hom ‚â´
      (Œ±_ A A (A ‚äó A)).inv ‚â´
      (Œº[A] ‚äó‚Çò Œº[A]) =
    Œµ[A] ‚â´ (Œª_ (ùüô_ C)).inv ‚â´ (Œ∑[A] ‚äó‚Çò Œ∑[A]) := by
  slice_lhs 3 5 =>
    rw [‚Üê associator_naturality_right, ‚Üê Category.assoc, ‚Üê tensorHom_def]
  slice_lhs 3 9 =>
    rw [Bimon.compatibility]
  slice_lhs 1 3 =>
    rw [antipode_left]
  simp [MonObj.tensorObj.one_def]

/--
Auxiliary calculation for `antipode_comul`.
This calculation calls for some ASCII art out of This Week's Finds.

```
   |   |
   n   n
  | \ / |
  |  /  |
  | / \ |
  | | S S
  | | \ /
  | |  /
  | | / \
  \ / \ /
   v   v
    \ /
     v
     |
```

We move the left antipode up through the crossing,
the right antipode down through the crossing,
the right multiplication down across the strand,
reassociate the comultiplications,
then use `antipode_right` then `antipode_left` to simplify.
-/
theorem antipode_comul‚ÇÇ (A : C) [HopfObj A] :
    Œî[A] ‚â´
      Œî[A] ‚ñ∑ A ‚â´
      (Œ±_ A A A).hom ‚â´
      A ‚óÅ A ‚óÅ Œî[A] ‚â´
      A ‚óÅ A ‚óÅ (Œ≤_ A A).hom ‚â´
      A ‚óÅ A ‚óÅ (ùíÆ[A] ‚äó‚Çò ùíÆ[A]) ‚â´
      A ‚óÅ (Œ±_ A A A).inv ‚â´
      A ‚óÅ (Œ≤_ A A).hom ‚ñ∑ A ‚â´
      A ‚óÅ (Œ±_ A A A).hom ‚â´
      (Œ±_ A A (A ‚äó A)).inv ‚â´
      (Œº[A] ‚äó‚Çò Œº[A]) =
    Œµ[A] ‚â´ (Œª_ (ùüô_ C)).inv ‚â´ (Œ∑[A] ‚äó‚Çò Œ∑[A]) := by
  -- We should write a version of `slice_lhs` that zooms through whiskerings.
  slice_lhs 6 6 =>
    simp only [tensorHom_def', whiskerLeft_comp]
  slice_lhs 7 8 =>
    rw [‚Üê whiskerLeft_comp, associator_inv_naturality_middle, whiskerLeft_comp]
  slice_lhs 8 9 =>
    rw [‚Üê whiskerLeft_comp, ‚Üê comp_whiskerRight, BraidedCategory.braiding_naturality_right,
      comp_whiskerRight, whiskerLeft_comp]
  slice_lhs 9 10 =>
    rw [‚Üê whiskerLeft_comp, associator_naturality_left, whiskerLeft_comp]
  slice_lhs 5 6 =>
    rw [‚Üê whiskerLeft_comp, ‚Üê whiskerLeft_comp, ‚Üê BraidedCategory.braiding_naturality_left,
      whiskerLeft_comp, whiskerLeft_comp]
  slice_lhs 11 12 =>
    rw [tensorHom_def', ‚Üê Category.assoc, ‚Üê associator_inv_naturality_right]
  slice_lhs 10 11 =>
    rw [‚Üê whiskerLeft_comp, ‚Üê whisker_exchange, whiskerLeft_comp]
  slice_lhs 6 10 =>
    simp only [‚Üê whiskerLeft_comp]
    rw [‚Üê BraidedCategory.hexagon_reverse_assoc, Iso.inv_hom_id_assoc,
      ‚Üê BraidedCategory.braiding_naturality_left]
    simp only [whiskerLeft_comp]
  rw [ComonObj.comul_assoc_flip_assoc, Iso.inv_hom_id_assoc]
  slice_lhs 2 3 =>
    simp only [‚Üê whiskerLeft_comp]
    rw [ComonObj.comul_assoc]
    simp only [whiskerLeft_comp]
  slice_lhs 3 7 =>
    simp only [‚Üê whiskerLeft_comp]
    rw [‚Üê associator_naturality_middle_assoc, Iso.hom_inv_id_assoc]
    simp only [‚Üê comp_whiskerRight]
    rw [antipode_right]
    simp only [comp_whiskerRight]
    simp only [whiskerLeft_comp]
  slice_lhs 2 3 =>
    simp only [‚Üê whiskerLeft_comp]
    rw [ComonObj.counit_comul]
    simp only [whiskerLeft_comp]
  slice_lhs 3 4 =>
    simp only [‚Üê whiskerLeft_comp]
    rw [BraidedCategory.braiding_naturality_left]
    simp only [whiskerLeft_comp]
  slice_lhs 4 5 =>
    simp only [‚Üê whiskerLeft_comp]
    rw [whisker_exchange]
    simp only [whiskerLeft_comp]
  slice_lhs 5 7 =>
    rw [associator_inv_naturality_right_assoc, whisker_exchange]
  simp only [braiding_tensorUnit_left,
    whiskerLeft_comp, whiskerLeft_rightUnitor_inv,
    whiskerRight_id, whiskerLeft_rightUnitor, Category.assoc, Iso.hom_inv_id_assoc,
    Iso.inv_hom_id_assoc, whiskerLeft_inv_hom_assoc, antipode_right_assoc]
  rw [rightUnitor_inv_naturality_assoc, tensorHom_def]
  monoidal

theorem antipode_comul (A : C) [HopfObj A] :
    ùíÆ[A] ‚â´ Œî[A] = Œî[A] ‚â´ (Œ≤_ _ _).hom ‚â´ (ùíÆ[A] ‚äó‚Çò ùíÆ[A]) := by
  -- Again, it is a "left inverse equals right inverse" argument in the convolution monoid.
  apply left_inv_eq_right_inv
    (M := Conv A (A ‚äó A))
    (a := Œî[A])
  ¬∑ rw [Conv.mul_eq, Conv.one_eq]
    simp only [comp_whiskerRight, tensor_whiskerLeft, MonObj.tensorObj.mul_def, Category.assoc,
      MonObj.tensorObj.one_def]
    simp only [tensorŒº]
    simp only [Category.assoc, Iso.inv_hom_id_assoc]
    exact antipode_comul‚ÇÅ A
  ¬∑ rw [Conv.mul_eq, Conv.one_eq]
    simp only [whiskerLeft_comp, tensor_whiskerLeft, Category.assoc, Iso.inv_hom_id_assoc,
      MonObj.tensorObj.mul_def, MonObj.tensorObj.one_def]
    simp only [tensorŒº]
    simp only [Category.assoc, Iso.inv_hom_id_assoc]
    exact antipode_comul‚ÇÇ A

theorem mul_antipode‚ÇÅ (A : C) [HopfObj A] :
    (Œî[A] ‚äó‚Çò Œî[A]) ‚â´
      (Œ±_ A A (A ‚äó A)).hom ‚â´
      A ‚óÅ (Œ±_ A A A).inv ‚â´
      A ‚óÅ (Œ≤_ A A).hom ‚ñ∑ A ‚â´
      (Œ±_ A (A ‚äó A) A).inv ‚â´
      (Œ±_ A A A).inv ‚ñ∑ A ‚â´
      Œº[A] ‚ñ∑ A ‚ñ∑ A ‚â´
      ùíÆ[A] ‚ñ∑ A ‚ñ∑ A ‚â´
      (Œ±_ A A A).hom ‚â´
      A ‚óÅ Œº[A] ‚â´
      Œº[A] =
    (Œµ[A] ‚äó‚Çò Œµ[A]) ‚â´ (Œª_ (ùüô_ C)).hom ‚â´ Œ∑[A] := by
  slice_lhs 8 9 =>
    rw [associator_naturality_left]
  slice_lhs 9 10 =>
    rw [‚Üê whisker_exchange]
  slice_lhs 7 8 =>
    rw [associator_naturality_left]
  slice_lhs 8 9 =>
    rw [‚Üê tensorHom_def]
  simp


/--
Auxiliary calculation for `mul_antipode`.

```
       |
       n
      /  \
     |   n
     |  / \
     |  S S
     |  \ /
     n   /
    / \ / \
    |  /  |
    \ / \ /
     v   v
     |   |
```

We move the leftmost multiplication up, so we can reassociate.
We then move the rightmost comultiplication under the strand,
and simplify using `antipode_right`.
-/
theorem mul_antipode‚ÇÇ (A : C) [HopfObj A] :
    (Œî[A] ‚äó‚Çò Œî[A]) ‚â´
      (Œ±_ A A (A ‚äó A)).hom ‚â´
      A ‚óÅ (Œ±_ A A A).inv ‚â´
      A ‚óÅ (Œ≤_ A A).hom ‚ñ∑ A ‚â´
      (Œ±_ A (A ‚äó A) A).inv ‚â´
      (Œ±_ A A A).inv ‚ñ∑ A ‚â´
      Œº[A] ‚ñ∑ A ‚ñ∑ A ‚â´
      (Œ±_ A A A).hom ‚â´
      A ‚óÅ (Œ≤_ A A).hom ‚â´
      A ‚óÅ (ùíÆ[A] ‚äó‚Çò ùíÆ[A]) ‚â´
      A ‚óÅ Œº[A] ‚â´ Œº[A] =
    (Œµ[A] ‚äó‚Çò Œµ[A]) ‚â´ (Œª_ (ùüô_ C)).hom ‚â´ Œ∑[A] := by
  slice_lhs 7 8 =>
    rw [associator_naturality_left]
  slice_lhs 8 9 =>
    rw [‚Üê whisker_exchange]
  slice_lhs 9 10 =>
    rw [‚Üê whisker_exchange]
  slice_lhs 11 12 =>
    rw [MonObj.mul_assoc_flip]
  slice_lhs 10 11 =>
    rw [associator_inv_naturality_left]
  slice_lhs 11 12 =>
    simp only [‚Üê comp_whiskerRight]
    rw [MonObj.mul_assoc]
    simp only [comp_whiskerRight]
  rw [tensorHom_def]
  rw [tensor_whiskerLeft _ _ (Œ≤_ A A).hom]
  rw [pentagon_inv_inv_hom_hom_inv_assoc]
  slice_lhs 7 8 =>
    rw [Iso.inv_hom_id]
  rw [Category.id_comp]
  slice_lhs 5 7 =>
    simp only [‚Üê whiskerLeft_comp]
    rw [‚Üê BraidedCategory.hexagon_forward]
    simp only [whiskerLeft_comp]
  simp only [tensor_whiskerLeft, Category.assoc, Iso.inv_hom_id_assoc, pentagon_inv_inv_hom_inv_inv,
    whisker_assoc, MonObj.mul_assoc, whiskerLeft_inv_hom_assoc]
  slice_lhs 3 4 =>
    simp only [‚Üê whiskerLeft_comp]
    rw [BraidedCategory.braiding_naturality_right]
    simp only [whiskerLeft_comp]
  rw [tensorHom_def']
  simp only [whiskerLeft_comp]
  slice_lhs 5 6 =>
    simp only [‚Üê whiskerLeft_comp]
    rw [‚Üê associator_naturality_right]
    simp only [whiskerLeft_comp]
  slice_lhs 4 5 =>
    simp only [‚Üê whiskerLeft_comp]
    rw [‚Üê whisker_exchange]
    simp only [whiskerLeft_comp]
  slice_lhs 5 9 =>
    simp only [‚Üê whiskerLeft_comp]
    rw [associator_inv_naturality_middle_assoc, Iso.hom_inv_id_assoc]
    simp only [‚Üê comp_whiskerRight]
    rw [antipode_right]
    simp only [comp_whiskerRight]
    simp only [whiskerLeft_comp]
  slice_lhs 6 7 =>
    simp only [‚Üê whiskerLeft_comp]
    rw [MonObj.one_mul]
    simp only [whiskerLeft_comp]
  slice_lhs 3 4 =>
    simp only [‚Üê whiskerLeft_comp]
    rw [‚Üê BraidedCategory.braiding_naturality_left]
    simp only [whiskerLeft_comp]
  slice_lhs 4 5 =>
    simp only [‚Üê whiskerLeft_comp]
    rw [‚Üê BraidedCategory.braiding_naturality_right]
    simp only [whiskerLeft_comp]
  rw [‚Üê associator_naturality_middle_assoc]
  simp only [braiding_tensorUnit_right, whiskerLeft_comp]
  slice_lhs 6 7 =>
    simp only [‚Üê whiskerLeft_comp]
    rw [Iso.inv_hom_id]
    simp only [whiskerLeft_comp]
  simp only [whiskerLeft_id, Category.id_comp]
  slice_lhs 5 6 =>
    rw [whiskerLeft_rightUnitor, Category.assoc, ‚Üê rightUnitor_naturality]
  rw [associator_inv_naturality_right_assoc, Iso.hom_inv_id_assoc]
  slice_lhs 3 4 =>
    rw [whisker_exchange]
  slice_lhs 1 3 =>
    simp only [‚Üê comp_whiskerRight]
    rw [antipode_right]
    simp only [comp_whiskerRight]
  slice_lhs 2 3 =>
    rw [‚Üê whisker_exchange]
  slice_lhs 1 2 =>
    dsimp
    rw [‚Üê tensorHom_def]
  slice_lhs 2 3 =>
    rw [rightUnitor_naturality]
  monoidal

theorem mul_antipode (A : C) [HopfObj A] :
    Œº[A] ‚â´ ùíÆ[A] = (ùíÆ[A] ‚äó‚Çò ùíÆ[A]) ‚â´ (Œ≤_ _ _).hom ‚â´ Œº[A] := by
  -- Again, it is a "left inverse equals right inverse" argument in the convolution monoid.
  apply left_inv_eq_right_inv
    (M := Conv (A ‚äó A) A)
    (a := Œº[A])
  ¬∑ -- Unfold the algebra structure in the convolution monoid,
    -- then `simp?, simp only [tensor_Œº], simp?`.
    rw [Conv.mul_eq, Conv.one_eq]
    simp only [Comon.tensorObj_comul, whiskerRight_tensor, comp_whiskerRight, Category.assoc,
      Comon.tensorObj_counit]
    simp only [tensorŒº]
    simp only [Category.assoc, pentagon_hom_inv_inv_inv_inv_assoc]
    exact mul_antipode‚ÇÅ A
  ¬∑ rw [Conv.mul_eq, Conv.one_eq]
    simp only [Comon.tensorObj_comul, whiskerRight_tensor,
      BraidedCategory.braiding_naturality_assoc, whiskerLeft_comp, Category.assoc,
      Comon.tensorObj_counit]
    simp only [tensorŒº]
    simp only [Category.assoc, pentagon_hom_inv_inv_inv_inv_assoc]
    exact mul_antipode‚ÇÇ A

/--
In a commutative Hopf algebra, the antipode squares to the identity.
-/
theorem antipode_antipode (A : C) [HopfObj A] (comm : (Œ≤_ _ _).hom ‚â´ Œº[A] = Œº[A]) :
    ùíÆ[A] ‚â´ ùíÆ[A] = ùüô A := by
  -- Again, it is a "left inverse equals right inverse" argument in the convolution monoid.
  apply left_inv_eq_right_inv
    (M := Conv A A)
    (a := ùíÆ[A])
  ¬∑ -- Unfold the algebra structure in the convolution monoid,
    -- then `simp?`.
    rw [Conv.mul_eq, Conv.one_eq]
    simp only [comp_whiskerRight, Category.assoc]
    rw [‚Üê comm, ‚Üê tensorHom_def_assoc, ‚Üê mul_antipode]
    simp
  ¬∑ rw [Conv.mul_eq, Conv.one_eq]
    simp

end HopfObj

end
