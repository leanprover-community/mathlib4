/-
Copyright (c) 2024 Lean FRO LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import Mathlib.CategoryTheory.Monoidal.Mon_
import Mathlib.CategoryTheory.Monoidal.Braided.Opposite
import Mathlib.CategoryTheory.Monoidal.Transport
import Mathlib.CategoryTheory.Monoidal.CoherenceLemmas
import Mathlib.CategoryTheory.Limits.Shapes.Terminal

/-!
# The category of comonoids in a monoidal category.

We define comonoids in a monoidal category `C`,
and show that they are equivalently monoid objects in the opposite category.

We construct the monoidal structure on `Comon_ C`, when `C` is braided.

An oplax monoidal functor takes comonoid objects to comonoid objects.
That is, a oplax monoidal functor `F : C โฅค D` induces a functor `Comon_ C โฅค Comon_ D`.

## TODO
* Comonoid objects in `C` are "just"
  oplax monoidal functors from the trivial monoidal category to `C`.
-/

universe vโ vโ uโ uโ u

open CategoryTheory MonoidalCategory

variable (C : Type uโ) [Category.{vโ} C] [MonoidalCategory.{vโ} C]

/-- A comonoid object internal to a monoidal category.

When the monoidal category is preadditive, this is also sometimes called a "coalgebra object".
-/
structure Comon_ where
  /-- The underlying object of a comonoid object. -/
  X : C
  /-- The counit of a comonoid object. -/
  counit : X โถ ๐_ C
  /-- The comultiplication morphism of a comonoid object. -/
  comul : X โถ X โ X
  counit_comul : comul โซ (counit โท X) = (ฮป_ X).inv := by aesop_cat
  comul_counit : comul โซ (X โ counit) = (ฯ_ X).inv := by aesop_cat
  comul_assoc : comul โซ (X โ comul) โซ (ฮฑ_ X X X).inv = comul โซ (comul โท X) := by aesop_cat

attribute [reassoc (attr := simp)] Comon_.counit_comul Comon_.comul_counit

attribute [reassoc (attr := simp)] Comon_.comul_assoc

namespace Comon_

/-- The trivial comonoid object. We later show this is terminal in `Comon_ C`.
-/
@[simps]
def trivial : Comon_ C where
  X := ๐_ C
  counit := ๐ _
  comul := (ฮป_ _).inv
  comul_assoc := by coherence
  counit_comul := by coherence
  comul_counit := by coherence

instance : Inhabited (Comon_ C) :=
  โจtrivial Cโฉ

variable {C}
variable {M : Comon_ C}

@[reassoc (attr := simp)]
theorem counit_comul_hom {Z : C} (f : M.X โถ Z) : M.comul โซ (M.counit โ f) = f โซ (ฮป_ Z).inv := by
  rw [leftUnitor_inv_naturality, tensorHom_def, counit_comul_assoc]

@[reassoc (attr := simp)]
theorem comul_counit_hom {Z : C} (f : M.X โถ Z) : M.comul โซ (f โ M.counit) = f โซ (ฯ_ Z).inv := by
  rw [rightUnitor_inv_naturality, tensorHom_def', comul_counit_assoc]

@[reassoc (attr := simp)] theorem comul_assoc_flip :
    M.comul โซ (M.comul โท M.X) โซ (ฮฑ_ M.X M.X M.X).hom = M.comul โซ (M.X โ M.comul) := by
  simp [โ comul_assoc_assoc]

/-- A morphism of comonoid objects. -/
@[ext]
structure Hom (M N : Comon_ C) where
  /-- The underlying morphism of a morphism of comonoid objects. -/
  hom : M.X โถ N.X
  hom_counit : hom โซ N.counit = M.counit := by aesop_cat
  hom_comul : hom โซ N.comul = M.comul โซ (hom โ hom) := by aesop_cat

attribute [reassoc (attr := simp)] Hom.hom_counit Hom.hom_comul

/-- The identity morphism on a comonoid object. -/
@[simps]
def id (M : Comon_ C) : Hom M M where
  hom := ๐ M.X

instance homInhabited (M : Comon_ C) : Inhabited (Hom M M) :=
  โจid Mโฉ

/-- Composition of morphisms of monoid objects. -/
@[simps]
def comp {M N O : Comon_ C} (f : Hom M N) (g : Hom N O) : Hom M O where
  hom := f.hom โซ g.hom

instance : Category (Comon_ C) where
  Hom M N := Hom M N
  id := id
  comp f g := comp f g

@[ext] lemma ext {X Y : Comon_ C} {f g : X โถ Y} (w : f.hom = g.hom) : f = g := Hom.ext _ _ w

@[simp] theorem id_hom' (M : Comon_ C) : (๐ M : Hom M M).hom = ๐ M.X := rfl

@[simp]
theorem comp_hom' {M N K : Comon_ C} (f : M โถ N) (g : N โถ K) : (f โซ g).hom = f.hom โซ g.hom :=
  rfl

section

variable (C)

/-- The forgetful functor from comonoid objects to the ambient category. -/
@[simps]
def forget : Comon_ C โฅค C where
  obj A := A.X
  map f := f.hom

end

instance forget_faithful : (@forget C _ _).Faithful where

instance {A B : Comon_ C} (f : A โถ B) [e : IsIso ((forget C).map f)] : IsIso f.hom := e

/-- The forgetful functor from comonoid objects to the ambient category reflects isomorphisms. -/
instance : (forget C).ReflectsIsomorphisms where
  reflects f e :=
    โจโจ{ hom := inv f.hom }, by aesop_catโฉโฉ

/-- Construct an isomorphism of comonoids by giving an isomorphism between the underlying objects
and checking compatibility with counit and comultiplication only in the forward direction.
-/
@[simps]
def mkIso {M N : Comon_ C} (f : M.X โ N.X) (f_counit : f.hom โซ N.counit = M.counit := by aesop_cat)
    (f_comul : f.hom โซ N.comul = M.comul โซ (f.hom โ f.hom) := by aesop_cat) : M โ N where
  hom :=
    { hom := f.hom
      hom_counit := f_counit
      hom_comul := f_comul }
  inv :=
    { hom := f.inv
      hom_counit := by rw [โ f_counit]; simp
      hom_comul := by
        rw [โ cancel_epi f.hom]
        slice_rhs 1 2 => rw [f_comul]
        simp }

instance uniqueHomToTrivial (A : Comon_ C) : Unique (A โถ trivial C) where
  default :=
    { hom := A.counit
      hom_counit := by dsimp; simp
      hom_comul := by dsimp; simp [A.comul_counit, unitors_inv_equal] }
  uniq f := by
    ext; simp
    rw [โ Category.comp_id f.hom]
    erw [f.hom_counit]

open CategoryTheory.Limits

instance : HasTerminal (Comon_ C) :=
  hasTerminal_of_unique (trivial C)

open Opposite

variable (C)

/--
Turn a comonoid object into a monoid object in the opposite category.
-/
@[simps] def Comon_ToMon_OpOp_obj' (A : Comon_ C) : Mon_ (Cแตแต) where
  X := op A.X
  one := A.counit.op
  mul := A.comul.op
  one_mul := by
    rw [โ op_whiskerRight, โ op_comp, counit_comul]
    rfl
  mul_one := by
    rw [โ op_whiskerLeft, โ op_comp, comul_counit]
    rfl
  mul_assoc := by
    rw [โ op_inv_associator, โ op_whiskerRight, โ op_comp, โ op_whiskerLeft, โ op_comp,
      โ comul_assoc, op_comp, op_comp_assoc]
    rfl

/--
The contravariant functor turning comonoid objects into monoid objects in the opposite category.
-/
@[simps] def Comon_ToMon_OpOp : Comon_ C โฅค (Mon_ (Cแตแต))แตแต where
  obj A := op (Comon_ToMon_OpOp_obj' C A)
  map := fun f => op <|
    { hom := f.hom.op
      one_hom := by apply Quiver.Hom.unop_inj; simp
      mul_hom := by apply Quiver.Hom.unop_inj; simp [op_tensorHom] }

/--
Turn a monoid object in the opposite category into a comonoid object.
-/
@[simps] def Mon_OpOpToComon_obj' (A : (Mon_ (Cแตแต))) : Comon_ C where
  X := unop A.X
  counit := A.one.unop
  comul := A.mul.unop
  counit_comul := by rw [โ unop_whiskerRight, โ unop_comp, Mon_.one_mul]; rfl
  comul_counit := by rw [โ unop_whiskerLeft, โ unop_comp, Mon_.mul_one]; rfl
  comul_assoc := by
    rw [โ unop_whiskerRight, โ unop_comp, โ unop_whiskerLeft, โ unop_comp_assoc, Mon_.mul_assoc]
    rfl

/--
The contravariant functor turning monoid objects in the opposite category into comonoid objects.
-/
@[simps]
def Mon_OpOpToComon_ : (Mon_ (Cแตแต))แตแต โฅค Comon_ C where
  obj A := Mon_OpOpToComon_obj' C (unop A)
  map := fun f =>
    { hom := f.unop.hom.unop
      hom_counit := by apply Quiver.Hom.op_inj; simp
      hom_comul := by apply Quiver.Hom.op_inj; simp [op_tensorHom] }

/--
Comonoid objects are contravariantly equivalent to monoid objects in the opposite category.
-/
@[simps]
def Comon_EquivMon_OpOp : Comon_ C โ (Mon_ (Cแตแต))แตแต :=
  { functor := Comon_ToMon_OpOp C
    inverse := Mon_OpOpToComon_ C
    unitIso := NatIso.ofComponents (fun _ => Iso.refl _)
    counitIso := NatIso.ofComponents (fun _ => Iso.refl _) }

/--
Comonoid objects in a braided category form a monoidal category.

This definition is via transporting back and forth to monoids in the opposite category,
-/
instance [BraidedCategory C] : MonoidalCategory (Comon_ C) :=
  Monoidal.transport (Comon_EquivMon_OpOp C).symm

variable [BraidedCategory C]

theorem tensorObj_X (A B : Comon_ C) : (A โ B).X = A.X โ B.X := rfl

theorem tensorObj_counit (A B : Comon_ C) : (A โ B).counit = (A.counit โ B.counit) โซ (ฮป_ _).hom :=
  rfl

/--
Preliminary statement of the comultiplication for a tensor product of comonoids.
This version is the definitional equality provided by transport, and not quite as good as
the version provided in `tensorObj_comul` below.
-/
theorem tensorObj_comul' (A B : Comon_ C) :
    (A โ B).comul =
      (A.comul โ B.comul) โซ (tensor_ฮผ Cแตแต (op A.X, op B.X) (op A.X, op B.X)).unop := by
  rfl

/--
The comultiplication on the tensor product of two comonoids is
the tensor product of the comultiplications followed by the tensor strength
(to shuffle the factors back into order).
-/
theorem tensorObj_comul (A B : Comon_ C) :
    (A โ B).comul = (A.comul โ B.comul) โซ tensor_ฮผ C (A.X, A.X) (B.X, B.X) := by
  rw [tensorObj_comul']
  congr
  simp only [tensor_ฮผ, unop_tensorObj, unop_op]
  apply Quiver.Hom.unop_inj
  dsimp [op_tensorObj, op_associator]
  rw [Category.assoc, Category.assoc, Category.assoc]

/-- The forgetful functor from `Comon_ C` to `C` is monoidal when `C` is braided monoidal. -/
def forgetMonoidal : MonoidalFunctor (Comon_ C) C :=
  { forget C with
    ฮต := ๐ _
    ฮผ := fun X Y => ๐ _ }

@[simp] theorem forgetMonoidal_toFunctor : (forgetMonoidal C).toFunctor = forget C := rfl
@[simp] theorem forgetMonoidal_ฮต : (forgetMonoidal C).ฮต = ๐ (๐_ C) := rfl
@[simp] theorem forgetMonoidal_ฮผ (X Y : Comon_ C) : (forgetMonoidal C).ฮผ X Y = ๐ (X.X โ Y.X) := rfl

end Comon_

namespace CategoryTheory.OplaxMonoidalFunctor

variable {C} {D : Type uโ} [Category.{vโ} D] [MonoidalCategory.{vโ} D]

/-- A oplax monoidal functor takes comonoid objects to comonoid objects.

That is, a oplax monoidal functor `F : C โฅค D` induces a functor `Comon_ C โฅค Comon_ D`.
-/
@[simps]
def mapComon (F : OplaxMonoidalFunctor C D) : Comon_ C โฅค Comon_ D where
  obj A :=
    { X := F.obj A.X
      counit := F.map A.counit โซ F.ฮท
      comul := F.map A.comul โซ F.ฮด _ _
      counit_comul := by
        simp_rw [comp_whiskerRight, Category.assoc, F.ฮด_natural_left_assoc, F.left_unitality,
          โ F.map_comp_assoc, A.counit_comul]
      comul_counit := by
        simp_rw [MonoidalCategory.whiskerLeft_comp, Category.assoc, F.ฮด_natural_right_assoc,
          F.right_unitality, โ F.map_comp_assoc, A.comul_counit]
      comul_assoc := by
        simp_rw [comp_whiskerRight, Category.assoc, F.ฮด_natural_left_assoc,
          MonoidalCategory.whiskerLeft_comp, Category.assoc, F.ฮด_natural_right_assoc,
          โ F.map_comp_assoc, โ A.comul_assoc_flip, F.map_comp, F.associativity_inv]
        slice_lhs 3 4 =>
          rw [โ F.map_comp, Iso.hom_inv_id, F.map_id]
        simp only [Category.id_comp, Category.assoc] }
  map f :=
    { hom := F.map f.hom
      hom_counit := by dsimp; rw [โ F.map_comp_assoc, f.hom_counit]
      hom_comul := by
        dsimp
        rw [Category.assoc, F.ฮด_natural, โ F.map_comp_assoc, โ F.map_comp_assoc, f.hom_comul] }
  map_id A := by ext; simp
  map_comp f g := by ext; simp

-- TODO We haven't yet set up the category structure on `OplaxMonoidalFunctor C D`
-- and so can't state `mapComonFunctor : OplaxMonoidalFunctor C D โฅค Comon_ C โฅค Comon_ D`.

end CategoryTheory.OplaxMonoidalFunctor
