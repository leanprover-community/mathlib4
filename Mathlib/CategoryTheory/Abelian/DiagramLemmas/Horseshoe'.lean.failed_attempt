import Mathlib.CategoryTheory.Abelian.DiagramLemmas.Four
import Mathlib.CategoryTheory.Abelian.ProjectiveResolution
import Mathlib.Algebra.Homology.ShortComplex.ShortExact
import Mathlib.Algebra.Homology.ShortComplex.SnakeLemma
import Mathlib.Algebra.Homology.HomologySequence


open CategoryTheory Limits
open scoped ZeroObject

suppress_compilation

universe u v

variable {ğ’ : Type u} [Category.{v} ğ’] [Abelian ğ’] [EnoughProjectives ğ’]

lemma exact_lemma1 {X Y Z W : ğ’}
    (g : Y âŸ¶ Z) (h : Z âŸ¶ W) (f : X âŸ¶ kernel g) (i : kernel g âŸ¶ Y) (hf : Epi f) (hh : Mono h)
  (hi : i = kernel.Î¹ g) : CategoryTheory.Exact (f â‰« i) (g â‰« h) := by
  suffices Exact i g by
    exact exact_comp_mono (exact_epi_comp this)
  rw [hi]
  exact exact_kernel_Î¹

namespace CategoryTheory.ShortComplex

variable (A B : ShortComplex ğ’) (fAB : A âŸ¶ B)

open Projective

variable {A}
variable (Pâ‚ : ProjectiveResolution A.Xâ‚) (Pâ‚ƒ : ProjectiveResolution A.Xâ‚ƒ)
abbrev horseshoeProjectiveResolutionâ‚ƒ : ProjectiveResolution A.Xâ‚ƒ :=
  projectiveResolution A.Xâ‚ƒ

@[simps]
def row (n : â„•) : ShortComplex ğ’ where
  Xâ‚ := Pâ‚.complex.X n
  Xâ‚‚ := Pâ‚.complex.X n âŠ Pâ‚ƒ.complex.X n
  Xâ‚ƒ := Pâ‚ƒ.complex.X n
  f := biprod.inl
  g := biprod.snd
  zero := by simp

@[simps]
def rowâ‚€ToBase [Epi A.g] : row Pâ‚ Pâ‚ƒ 0 âŸ¶ A where
  Ï„â‚ := Pâ‚.Ï€.f 0
  Ï„â‚‚ := biprod.desc (Pâ‚.Ï€.f 0 â‰« A.f) (factorThru (Pâ‚ƒ.Ï€.f 0) A.g)
  Ï„â‚ƒ := Pâ‚ƒ.Ï€.f 0
  commâ‚â‚‚ := by simp
  commâ‚‚â‚ƒ := by aesop_cat


------------------------------------------------------------------------------------------------------------------------
namespace Hom

variable {B} in
@[simps!]
def ker : ShortComplex ğ’ where
  Xâ‚ := kernel fAB.Ï„â‚
  Xâ‚‚ := kernel fAB.Ï„â‚‚
  Xâ‚ƒ := kernel fAB.Ï„â‚ƒ
  f := kernel.map _ _ A.f B.f fAB.commâ‚â‚‚
  g := kernel.map _ _ A.g B.g fAB.commâ‚‚â‚ƒ
  zero := by
    ext
    simp

variable {B} in
@[simps]
def kerÎ¹ : ker fAB âŸ¶ A where
  Ï„â‚ := kernel.Î¹ _
  Ï„â‚‚ := kernel.Î¹ _
  Ï„â‚ƒ := kernel.Î¹ _
  commâ‚â‚‚ := by simp
  commâ‚‚â‚ƒ := by simp


variable {B} in
@[simps!]
def Coker : ShortComplex ğ’ where
  Xâ‚ := cokernel fAB.Ï„â‚
  Xâ‚‚ := cokernel fAB.Ï„â‚‚
  Xâ‚ƒ := cokernel fAB.Ï„â‚ƒ
  f := cokernel.map _ _ A.f B.f fAB.commâ‚â‚‚
  g := cokernel.map _ _ A.g B.g fAB.commâ‚‚â‚ƒ
  zero := by ext; simp

variable {B} in
@[simps]
def CokerÏ€ : B âŸ¶ Coker fAB where
  Ï„â‚ := cokernel.Ï€ _
  Ï„â‚‚ := cokernel.Ï€ _
  Ï„â‚ƒ := cokernel.Ï€ _
  commâ‚â‚‚ := by simp
  commâ‚‚â‚ƒ := by simp

variable [a_se : Fact <| A.ShortExact] [b_se : Fact <| B.ShortExact]


instance [short_exact : Fact <| A.ShortExact] : Epi A.g := short_exact.out.epi_g

instance [short_exact : Fact <| A.ShortExact] : Mono A.f := short_exact.out.mono_f


variable {B} in
/-- ker f -> A - f -> B -> coker f -/
@[simps!]
def snakeInput :
    SnakeInput ğ’ where
  Lâ‚€ := ker fAB
  Lâ‚ := A
  Lâ‚‚ := B
  Lâ‚ƒ := Coker fAB
  vâ‚€â‚ := kerÎ¹ fAB
  vâ‚â‚‚ := fAB
  vâ‚‚â‚ƒ := CokerÏ€ fAB
  hâ‚€ := by
    apply (config := {allowSynthFailures := true}) KernelFork.IsLimit.ofÎ¹'
    Â· intro C g h
      refine âŸ¨âŸ¨kernel.lift _ g.Ï„â‚ <| ShortComplex.Hom.ext_iff _ _ |>.mp h |>.1,
        kernel.lift _ g.Ï„â‚‚ <| ShortComplex.Hom.ext_iff _ _ |>.mp h |>.2.1,
        kernel.lift _ g.Ï„â‚ƒ <| ShortComplex.Hom.ext_iff _ _ |>.mp h |>.2.2, ?_, ?_âŸ©, ?_âŸ©
      Â· exact equalizer.hom_ext <| by simpa using g.commâ‚â‚‚
      Â· exact equalizer.hom_ext <| by simpa using g.commâ‚‚â‚ƒ
      Â· ext <;> simp
    Â· constructor
      intro C gâ‚ gâ‚‚ h
      ext
      Â· exact equalizer.hom_ext <| by simpa using ShortComplex.Hom.ext_iff _ _ |>.mp h |>.1
      Â· exact equalizer.hom_ext <| by simpa using ShortComplex.Hom.ext_iff _ _ |>.mp h |>.2.1
      Â· exact equalizer.hom_ext <| by simpa using ShortComplex.Hom.ext_iff _ _ |>.mp h |>.2.2
  hâ‚ƒ := by
    apply (config := {allowSynthFailures := true}) CokernelCofork.IsColimit.ofÏ€'
    Â· intro C g h
      refine âŸ¨âŸ¨cokernel.desc _ g.Ï„â‚ <| ShortComplex.Hom.ext_iff _ _ |>.mp h |>.1,
        cokernel.desc _ g.Ï„â‚‚ <| ShortComplex.Hom.ext_iff _ _ |>.mp h |>.2.1,
        cokernel.desc _ g.Ï„â‚ƒ <| ShortComplex.Hom.ext_iff _ _ |>.mp h |>.2.2, ?_, ?_âŸ©, ?_âŸ©
      Â· exact coequalizer.hom_ext <| by simpa using g.commâ‚â‚‚
      Â· exact coequalizer.hom_ext <| by simpa using g.commâ‚‚â‚ƒ
      Â· ext <;> simp
    Â· constructor
      intro C gâ‚ gâ‚‚ h
      ext
      Â· exact coequalizer.hom_ext <| by simpa using ShortComplex.Hom.ext_iff _ _ |>.mp h |>.1
      Â· exact coequalizer.hom_ext <| by simpa using ShortComplex.Hom.ext_iff _ _ |>.mp h |>.2.1
      Â· exact coequalizer.hom_ext <| by simpa using ShortComplex.Hom.ext_iff _ _ |>.mp h |>.2.2
  Lâ‚_exact := a_se.out.exact
  epi_Lâ‚_g := inferInstance
  Lâ‚‚_exact := b_se.out.exact
  mono_Lâ‚‚_f := inferInstance

variable {B} in
lemma snakeInput_Lâ‚€_shortExact [Epi fAB.Ï„â‚] :
    (snakeInput fAB).Lâ‚€.ShortExact where
  exact := (snakeInput fAB).Lâ‚€_exact
  mono_f := by dsimp; infer_instance
  epi_g := by
    dsimp only [snakeInput_Lâ‚€_Xâ‚‚, snakeInput_Lâ‚€_Xâ‚ƒ, snakeInput_Lâ‚€_g]
    have h := Abelian.tfae_epi (cokernel fAB.Ï„â‚) (kernel.map fAB.Ï„â‚‚ fAB.Ï„â‚ƒ A.g B.g fAB.commâ‚‚â‚ƒ)
      |>.out 0 2
    refine h.mpr ?_
    have := (snakeInput fAB).snake_lemma.2 1
    rw [â† exact_iff_shortComplex_exact] at this
    simp only [SnakeInput.composableArrows, ComposableArrows.mkâ‚…, snakeInput_Lâ‚€_Xâ‚‚,
      snakeInput_Lâ‚€_Xâ‚ƒ, snakeInput_Lâ‚ƒ_Xâ‚, snakeInput_Lâ‚ƒ_Xâ‚‚,
      snakeInput_Lâ‚ƒ_Xâ‚ƒ, snakeInput_Lâ‚€_g, snakeInput_Lâ‚ƒ_f,
      snakeInput_Lâ‚ƒ_g, ComposableArrows.mkâ‚„, ComposableArrows.mkâ‚ƒ, ComposableArrows.mkâ‚‚,
      snakeInput_Lâ‚€_Xâ‚, snakeInput_Lâ‚€_f, id_eq, Nat.cast_ofNat,
      Int.Nat.cast_ofNat_Int, Fin.mk_one, ComposableArrows.precomp_obj,
      ComposableArrows.Precomp.obj_one, Fin.zero_eta, ComposableArrows.Precomp.obj_zero,
      ComposableArrows.Precomp.obj_succ, ComposableArrows.map', ComposableArrows.precomp_map,
      ComposableArrows.Precomp.map_one_succ, ComposableArrows.Precomp.map_zero_one,
      ComposableArrows.Precomp.map_succ_succ] at this
    dsimp at this
    convert this using 1
    symm
    convert IsZero.eq_of_tgt _ _ _ using 1
    simp only [snakeInput_Lâ‚ƒ_Xâ‚]
    exact (isZero_zero _).of_iso <| Limits.cokernel.ofEpi _

instance [Epi fAB.Ï„â‚] : Fact (snakeInput fAB).Lâ‚€.ShortExact :=
  âŸ¨snakeInput_Lâ‚€_shortExact _âŸ©

instance ker_short_exact [Epi fAB.Ï„â‚] : Fact <| (ker fAB).ShortExact :=
  âŸ¨snakeInput_Lâ‚€_shortExact _âŸ©

end Hom

def rowSplitting (n) : Splitting (row Pâ‚ Pâ‚ƒ n) where
  r := biprod.fst
  s := biprod.inr
  f_r := by simp
  s_g := by simp
  id := by simp

instance (n) : Fact (ShortExact (row Pâ‚ Pâ‚ƒ n)) := by
  constructor
  apply ShortComplex.Splitting.shortExact
  exact rowSplitting Pâ‚ Pâ‚ƒ _

variable [Fact <| A.ShortExact]

instance : Epi (rowâ‚€ToBase Pâ‚ Pâ‚ƒ).Ï„â‚ := by
  simp only [row_Xâ‚, rowâ‚€ToBase_Ï„â‚]
  infer_instance

instance aux.se0 :
    Fact <| ShortComplex.Hom.ker (rowâ‚€ToBase Pâ‚ Pâ‚ƒ) |>.ShortExact := by
  apply Hom.ker_short_exact


@[simps!?]
def row1ToKer : (row Pâ‚ Pâ‚ƒ 1) âŸ¶ (ShortComplex.Hom.ker (rowâ‚€ToBase Pâ‚ Pâ‚ƒ)) :=
{ Ï„â‚ := kernel.lift _ (Pâ‚.complex.d 1 0) (by simp)
  Ï„â‚‚ := biprod.desc
    (kernel.lift _ (Pâ‚.complex.d 1 0) (by simp) â‰« (ShortComplex.Hom.ker (rowâ‚€ToBase Pâ‚ Pâ‚ƒ)).f)
    (factorThru (kernel.lift _ (Pâ‚ƒ.complex.d 1 0) (by simp))
      (ShortComplex.Hom.ker (rowâ‚€ToBase Pâ‚ Pâ‚ƒ)).g)
  Ï„â‚ƒ := kernel.lift _ (Pâ‚ƒ.complex.d 1 0) (by simp)
  commâ‚â‚‚ := by simp
  commâ‚‚â‚ƒ := by
    simp
    ext
    Â· simp
      erw [kernel.lift_Î¹, kernel.lift_Î¹_assoc]
      rw [Category.assoc, kernel.lift_Î¹_assoc]
      simp
    Â· simp }

@[simps!?]
def rowD10 : (row Pâ‚ Pâ‚ƒ 1) âŸ¶ (row Pâ‚ Pâ‚ƒ 0) :=
row1ToKer _ _ â‰«
{ Ï„â‚ := kernel.Î¹ _
  Ï„â‚‚ := kernel.Î¹ _
  Ï„â‚ƒ := kernel.Î¹ _
  commâ‚â‚‚ := by
    simp
    erw [kernel.lift_Î¹]
    rfl
  commâ‚‚â‚ƒ := by
    simp
    erw [kernel.lift_Î¹]
    rfl }

instance : Fact <| ShortExact (Hom.ker (row1ToKer Pâ‚ Pâ‚ƒ)) := by
  have : QuasiIso' Pâ‚.Ï€ := sorry

  have : CategoryTheory.Exact (Pâ‚.complex.d 1 0) (Pâ‚.Ï€.f 0) := by
    exact HomologicalComplex.Hom.to_singleâ‚€_exact_d_f_at_zero Pâ‚.Ï€

  have : Epi (row1ToKer Pâ‚ Pâ‚ƒ).Ï„â‚ := by
    simp
    apply Exact.epi_kernel_lift
    exact this
  exact Hom.ker_short_exact _ (row1ToKer Pâ‚ Pâ‚ƒ)

def row2ToKer : (row Pâ‚ Pâ‚ƒ 2) âŸ¶ (Hom.ker (row1ToKer Pâ‚ Pâ‚ƒ)) where
  Ï„â‚ := kernel.lift _ (Pâ‚.complex.d 2 1) (by aesop_cat)
  Ï„â‚‚ := biprod.desc
    (kernel.lift _ (Pâ‚.complex.d 2 1) (by aesop_cat) â‰« (Hom.ker (row1ToKer Pâ‚ Pâ‚ƒ)).f)

    (factorThru (kernel.lift _ (Pâ‚ƒ.complex.d 2 1) (by aesop_cat))
      (Hom.ker (row1ToKer Pâ‚ Pâ‚ƒ)).g)
  Ï„â‚ƒ := kernel.lift _ (Pâ‚ƒ.complex.d 2 1) (by aesop_cat)
  commâ‚â‚‚ := by simp
  commâ‚‚â‚ƒ := by
    dsimp
    refine equalizer.hom_ext ?_
    rw [Category.assoc]
    simp only [equalizer_as_kernel, kernel.lift_Î¹, Category.assoc]
    refine biprod.hom_ext' _ _ ?_ ?_
    Â· simp
    Â· simp only [biprod.inr_desc_assoc, BinaryBicone.inr_snd_assoc]
      sorry

@[simps!]
def rowD21 : (row Pâ‚ Pâ‚ƒ 2) âŸ¶ (row Pâ‚ Pâ‚ƒ 1) :=
row2ToKer _ _ â‰«
{ Ï„â‚ := kernel.Î¹ _
  Ï„â‚‚ := kernel.Î¹ _
  Ï„â‚ƒ := kernel.Î¹ _
  commâ‚â‚‚ := by
    simp
    erw [kernel.lift_Î¹]
    rfl
  commâ‚‚â‚ƒ := by
    simp
    erw [kernel.lift_Î¹]
    rfl }


end CategoryTheory.ShortComplex
