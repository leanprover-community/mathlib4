/-
Copyright (c) 2020 Markus Himmel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Markus Himmel, Scott Morrison, Jakob von Raumer
-/
import Mathlib.Algebra.Homology.QuasiIso
import Mathlib.CategoryTheory.Preadditive.ProjectiveResolution
import Mathlib.CategoryTheory.Preadditive.Yoneda.Limits
import Mathlib.CategoryTheory.Preadditive.Yoneda.Projective
import Mathlib.Algebra.Homology.ShortComplex.Abelian

#align_import category_theory.abelian.projective from "leanprover-community/mathlib"@"f0c8bf9245297a541f468be517f1bde6195105e9"

/-!
# Abelian categories with enough projectives have projective resolutions

When `C` is abelian `Projective.d f` and `f` are exact.
Hence, starting from an epimorphism `P âŸ¶ X`, where `P` is projective,
we can apply `Projective.d` repeatedly to obtain a projective resolution of `X`.
-/


noncomputable section

open CategoryTheory CategoryTheory.Limits Opposite

universe v u v' u'

namespace CategoryTheory

open CategoryTheory.Projective

variable {C : Type u} [Category.{v} C] [Abelian C]

/-- When `C` is abelian, `Projective.d f` and `f` are exact. -/
theorem exact_d_f [EnoughProjectives C] {X Y : C} (f : X âŸ¶ Y) :
    (ShortComplex.mk (d f) f (by simp)).Exact := by
  let Î± : ShortComplex.mk (d f) f (by simp) âŸ¶ ShortComplex.mk (kernel.Î¹ f) f (by simp) :=
    { Ï„â‚ := Projective.Ï€ _
      Ï„â‚‚ := ðŸ™ _
      Ï„â‚ƒ := ðŸ™ _  }
  have : Epi Î±.Ï„â‚ := by dsimp; infer_instance
  have : IsIso Î±.Ï„â‚‚ := by dsimp; infer_instance
  have : Mono Î±.Ï„â‚ƒ := by dsimp; infer_instance
  rw [ShortComplex.exact_iff_of_epi_of_isIso_of_mono Î±]
  apply ShortComplex.exact_of_f_is_kernel
  apply kernelIsKernel

/-- The preadditive Co-Yoneda functor on `P` preserves colimits if `P` is projective. -/
def preservesFiniteColimitsPreadditiveCoyonedaObjOfProjective (P : C) [hP : Projective P] :
    PreservesFiniteColimits (preadditiveCoyonedaObj (op P)) := by
  haveI := (projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj' P).mp hP
  -- porting note: this next instance wasn't necessary in Lean 3
  haveI := @Functor.preservesEpimorphisms_of_preserves_of_reflects _ _ _ _ _ _ _ _ this _
  apply Functor.preservesFiniteColimitsOfPreservesEpisAndKernels
#align category_theory.preserves_finite_colimits_preadditive_coyoneda_obj_of_projective CategoryTheory.preservesFiniteColimitsPreadditiveCoyonedaObjOfProjective

/-- An object is projective if its preadditive Co-Yoneda functor preserves finite colimits. -/
theorem projective_of_preservesFiniteColimits_preadditiveCoyonedaObj (P : C)
    [hP : PreservesFiniteColimits (preadditiveCoyonedaObj (op P))] : Projective P := by
  rw [projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj']
  -- porting note: this next line wasn't necessary in Lean 3
  dsimp only [preadditiveCoyoneda]
  infer_instance
#align category_theory.projective_of_preserves_finite_colimits_preadditive_coyoneda_obj CategoryTheory.projective_of_preservesFiniteColimits_preadditiveCoyonedaObj

namespace ProjectiveResolution

/-!
Our goal is to define `ProjectiveResolution.of Z : ProjectiveResolution Z`.
The `0`-th object in this resolution will just be `Projective.over Z`,
i.e. an arbitrarily chosen projective object with a map to `Z`.
After that, we build the `n+1`-st object as `Projective.syzygies`
applied to the previously constructed morphism,
and the map to the `n`-th object as `Projective.d`.
-/


variable [EnoughProjectives C]

-- Porting note: compilation of CategoryTheory.ProjectiveResolution.ofComplex took 4.95s
-- (was much faster in lean 3)
/-- Auxiliary definition for `ProjectiveResolution.of`. -/
@[simps!]
def ofComplex (Z : C) : ChainComplex C â„• :=
  ChainComplex.mk' (Projective.over Z) (Projective.syzygies (Projective.Ï€ Z))
    (Projective.d (Projective.Ï€ Z)) fun âŸ¨_, _, fâŸ© =>
    âŸ¨Projective.syzygies f, Projective.d f, by simpâŸ©
set_option linter.uppercaseLean3 false in
#align category_theory.ProjectiveResolution.of_complex CategoryTheory.ProjectiveResolution.ofComplex

/- Porting note:

The declarations below are very slow.
They could be given better proofs, which would hopefully also be efficient,
by giving better simp lemmas for `ofComplex`.
The current lemmas generated by `@[simps]` are terrible.

As an example, we would like to be able to say:

```
lemma ofComplex_d_shape (Z : C) {i j : â„•} (w : i = j + 1) :
    (ofComplex Z).d (i + 1) (j + 1) = Projective.d ((ofComplex Z).d i j) := by
  sorry
```

but sadly this doesn't typecheck.
Even a version with appropriate `eqToHom`s on the RHS would be helpful.
(We might even want a lemma describing `(ofComplex Z).d i j` on the assumptions
`i = k + 2` and `j = k + 1` for some `k`.)

It may even be possible to adjust `ChainComplex.mk` and `ChainComplex.mk'`
to give better definitional equalities.
See the notes where they are defined asking if there should be further lemmas
describing the inductive steps. The problems apparent here clearly indicate that there should be!
-/

-- Porting note: the Ï€ in `of` was very, very slow. To assist,
-- implicit arguments were filled in and this particular proof was broken
-- out into a separate result
theorem ofComplex_sq_10_comm (Z : C) :
    0 â‰« HomologicalComplex.d ((ChainComplex.singleâ‚€ C).obj Z) 1 0 =
    HomologicalComplex.d (ofComplex Z) 1 0 â‰« Projective.Ï€ Z := by
  simp only [ofComplex_d, eqToHom_refl, Category.id_comp,
    zero_comp]
  erw [Category.assoc, kernel.condition, comp_zero]

lemma ofComplex_exactAt_succ (Z : C) (n : â„•) : (ofComplex Z).ExactAt (n+1) := by
  rw [HomologicalComplex.exactAt_iff' _ (n+1+1) (n+1) n (by simp) (by simp)]
  obtain (_|n) := n
  all_goals
    dsimp [ofComplex, ChainComplex.mk', HomologicalComplex.sc',
      HomologicalComplex.shortComplexFunctor', ChainComplex.mk, ChainComplex.of]
    simp
    apply exact_d_f

/-- In any abelian category with enough projectives,
`ProjectiveResolution.of Z` constructs a projective resolution of the object `Z`.
-/
irreducible_def of (Z : C) : ProjectiveResolution Z :=
  { complex := ofComplex Z
    Ï€ := ChainComplex.mkHom (ofComplex Z) ((ChainComplex.singleâ‚€ C).obj Z) (Projective.Ï€ Z) 0
           (ofComplex_sq_10_comm Z) (fun n _ â†¦ âŸ¨0, by
           -- Porting note: broken ext
            apply HasZeroObject.to_zero_ext âŸ©)
    projective := by rintro (_ | _ | _ | n) <;> apply Projective.projective_over
    hÏ€ := âŸ¨fun n => by
      cases n
      Â· rw [ChainComplex.quasiIsoAtâ‚€_iff, ShortComplex.quasiIso_iff_of_zeros']
        . exact âŸ¨Projective.Ï€_epi Z, by simpa using exact_d_f (Projective.Ï€ Z)âŸ©
        all_goals rfl
        --rw [CochainComplex.quasiIsoAtâ‚€_iff,
        --  ShortComplex.quasiIso_iff_of_zeros]
        --Â· exact âŸ¨Injective.Î¹_mono Z, by simpa using exact_f_d (Injective.Î¹ Z)âŸ©
        --all_goals rfl
      Â· rw [quasiIsoAt_iff_exactAt']
        apply ofComplex_exactAt_succ
        apply ChainComplex.singleâ‚€_exactAtâŸ© }
    --exactâ‚€ := by simpa using exact_d_f (Projective.Ï€ Z)
    --exact := exact_ofComplex Z
    --epi := Projective.Ï€_epi Z }
set_option linter.uppercaseLean3 false in
#align category_theory.ProjectiveResolution.of CategoryTheory.ProjectiveResolution.of

instance (priority := 100) (Z : C) : HasProjectiveResolution Z where out := âŸ¨of ZâŸ©

instance (priority := 100) : HasProjectiveResolutions C where out Z := by infer_instance

end ProjectiveResolution

end CategoryTheory
