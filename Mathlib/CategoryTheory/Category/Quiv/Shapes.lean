/-
Copyright (c) 2025 Robert Maxton. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Robert Maxton
-/

import Mathlib.CategoryTheory.Category.Quiv
import Mathlib.CategoryTheory.Limits.Shapes.Terminal
import Mathlib.CategoryTheory.Generator.Basic

/-!# Shapes in Quiv

In this file, we define a number of quivers, most of which have corresponding notations:
* The `Empty` quiver, which is initial
* The single-vertex zero-edge quiver `Vert`, with the notation `‚ãÜ`
* The single-vertex single-edge quiver `Point`, with the notation `‚≠Æ`, which is terminal
* The `Interval` quiver, with the notation `ùïÄ`

All notations are duplicated: once for when universe levels can be inferred, and once to
allow explicit universe levels to be given.

## TODO
* The subobject classifier in `Quiv`

-/

namespace CategoryTheory.Quiv
universe v u v‚ÇÅ u‚ÇÅ v‚ÇÇ u‚ÇÇ
open Limits

/-- The empty quiver, with no vertices and no edges. -/
def Empty := let _ := PUnit.{v}; PEmpty.{u + 1}

instance : Quiver.{v + 1} Empty.{v} where
  Hom _ _ := PEmpty

instance : IsEmpty Empty where
  false := PEmpty.elim

/-- The single-vertex quiver, with one vertex and no edges. -/
def Vert := let _ := PUnit.{v}; PUnit.{u + 1}

instance : Quiver.{v + 1} Vert.{v} where
  Hom _ _ := PEmpty

@[inherit_doc Vert] scoped notation "‚ãÜ" => Vert
set_option quotPrecheck false in
@[inherit_doc Vert] scoped notation "‚ãÜ.{" v ", " u "}" => Vert.{v, u}

/-- Prefunctors out of `‚ãÜ` are just single objects. -/
def Vert.prefunctor {V : Type u‚ÇÇ} [Quiver.{v‚ÇÇ} V] (v : V) : ‚ãÜ.{v‚ÇÅ, u‚ÇÅ} ‚•§q V :=
  {obj := fun _ ‚Ü¶ v, map := nofun}

/-- Prefunctors out of `‚ãÜ` are equal if they point to the same object. -/
@[ext]
lemma Vert.prefunctor.ext {V : Type u‚ÇÇ} [Quiver.{v‚ÇÇ} V] {F G : ‚ãÜ.{v‚ÇÅ, u‚ÇÅ} ‚•§q V}
    (h : F.obj ‚ü®‚ü© = G.obj ‚ü®‚ü©) : F = G := by
  rcases F with ‚ü®F_obj, F_map‚ü©; rcases G with ‚ü®G_obj, G_map‚ü©
  simp at h
  rw [Prefunctor.mk.injEq]
  constructor
  ¬∑ ext ‚ü®‚ü©; exact h
  ¬∑ apply Function.hfunext rfl
    rintro ‚ü®‚ü© ‚ü®‚ü© -
    apply Function.hfunext rfl
    rintro ‚ü®‚ü© ‚ü®‚ü© -
    apply Function.hfunext rfl
    rintro ‚ü®‚ü©

/-- The interval quiver, with two points and a single edge `.left ‚ü∂ .right`. -/
def Interval := let _ := PUnit.{v}; ULift.{u} WalkingPair

instance : Quiver.{v + 1} Interval.{v} where
  Hom
  | .up .left, .up .right => PUnit
  | _, _ => PEmpty

@[inherit_doc Interval] scoped notation "ùïÄ" => Interval
set_option quotPrecheck false in
@[inherit_doc Interval] scoped notation "ùïÄ.{" v ", " u "}" => Interval.{v, u}

/-- The left point of `ùïÄ`. -/
@[match_pattern] def Interval.left : ùïÄ := .up .left
/-- The right point of `ùïÄ`. -/
@[match_pattern] def Interval.right : ùïÄ := .up .right

@[match_pattern] alias ùïÄ.left := Interval.left
@[match_pattern] alias ùïÄ.right := Interval.right

@[simps] instance : Zero ùïÄ := ‚ü®Interval.left‚ü©
@[simps] instance : One ùïÄ := ‚ü®Interval.right‚ü©

/-- The single edge of `ùïÄ`. -/
@[simp, match_pattern] def Interval.hom : (0 : ùïÄ.{v, u}) ‚ü∂ 1 := ‚ü®‚ü©

alias ùïÄ.hom := Interval.hom

/-- Convenience eliminator for building data on `ùïÄ.hom`.

Can't be a `cases_eliminator` or Lean will try to use it on every morphism in every quiver. -/
@[elab_as_elim]
def Interval.casesOn_hom {motive : {X Y : ùïÄ} ‚Üí (X ‚ü∂ Y) ‚Üí Sort*}
    {X Y : ùïÄ} (f : X ‚ü∂ Y) (hom : motive Interval.hom) : motive f :=
  match X, Y, f with
  | Interval.left, Interval.right, _ => hom

/-- Prefunctors out of `ùïÄ` are just single homs. -/
def Interval.prefunctor {V : Type u‚ÇÇ} [Quiver.{v‚ÇÇ} V] {X Y : V} (f : X ‚ü∂ Y) : ùïÄ.{u‚ÇÅ, v‚ÇÅ} ‚•§q V :=
  { obj := fun | Interval.left => X | Interval.right => Y,
    map := @fun | Interval.left, Interval.right, Interval.hom => f }

/-- Prefunctors out of `ùïÄ` are equal if they point to the same hom. -/
@[ext (iff := false)]
lemma Interval.prefunctor.ext {V : Type u‚ÇÇ} [Quiver.{v‚ÇÇ} V] {F G : ùïÄ.{u‚ÇÅ, v‚ÇÅ} ‚•§q V}
    (h‚ÇÄ : F.obj 0 = G.obj 0) (h‚ÇÅ : F.obj 1 = G.obj 1)
    (h : F.map Interval.hom = Quiver.homOfEq (G.map Interval.hom) h‚ÇÄ.symm h‚ÇÅ.symm) : F = G := by
  rcases F with ‚ü®F_obj, F_map‚ü©; rcases G with ‚ü®G_obj, G_map‚ü©
  -- simp at h‚ÇÄ h‚ÇÅ h
  rw [Prefunctor.mk.injEq]
  constructor
  ¬∑ ext (Interval.left | Interval.right) <;> simpa
  ¬∑ apply Function.hfunext rfl
    rintro X X' ‚ü®‚ü©
    apply Function.hfunext rfl
    rintro Y Y' ‚ü®‚ü©
    apply Function.hfunext rfl
    simp_rw [heq_eq_eq, forall_eq']
    rintro f
    cases f using Interval.casesOn_hom
    simp at h
    simp [h, Quiver.homOfEq_heq]

lemma Interval.prefunctor.ext_iff {V : Type u‚ÇÇ} [Quiver.{v‚ÇÇ} V] {F G : ùïÄ.{u‚ÇÅ, v‚ÇÅ} ‚•§q V} :
    F = G ‚Üî ‚àÉ (h‚ÇÄ : F.obj 0 = G.obj 0) (h‚ÇÅ : F.obj 1 = G.obj 1),
      F.map Interval.hom = Quiver.homOfEq (G.map Interval.hom) h‚ÇÄ.symm h‚ÇÅ.symm := by
  refine ‚ü®fun h => ?_, fun ‚ü®h‚ÇÄ, h‚ÇÅ, h‚ü© => Interval.prefunctor.ext h‚ÇÄ h‚ÇÅ h‚ü©
  subst h; simp

/-- The topos-theory point as a quiver, with a single point (vertex with a self-loop) and no other
vertices or edges. -/
def Point := let _ := PUnit.{v}; PUnit.{u + 1}

instance : Quiver.{v + 1} Point.{v} where
  Hom _ _ := PUnit

@[inherit_doc Point] scoped notation "‚≠Æ" => Point
set_option quotPrecheck false in
@[inherit_doc Point] scoped notation "‚≠Æ.{" v ", " u "}" => Point.{v, u}

/-- Prefunctors out of `‚≠Æ` are just single self-arrows. -/
def Point.prefunctor {V : Type u‚ÇÇ} [Quiver.{v‚ÇÇ} V] {v : V} (Œ± : v ‚ü∂ v) : ‚≠Æ.{v‚ÇÅ, u‚ÇÅ} ‚•§q V :=
  {obj := fun _ ‚Ü¶ v, map := fun _ => Œ±}

/-- Prefunctors out of `‚≠Æ` are equal if they point to the same self-arrow. -/
@[ext (iff := false)]
lemma Point.prefunctor.ext {V : Type u‚ÇÇ} [Quiver.{v‚ÇÇ} V] {F G : ‚≠Æ.{v‚ÇÅ, u‚ÇÅ} ‚•§q V}
    (h_obj : F.obj ‚ü®‚ü© = G.obj ‚ü®‚ü©)
    (h_map : F.map ‚ü®‚ü© = Quiver.homOfEq (G.map ‚ü®‚ü©) h_obj.symm h_obj.symm) : F = G := by
  rcases F with ‚ü®F_obj, F_map‚ü©; rcases G with ‚ü®G_obj, G_map‚ü©
  rw [Prefunctor.mk.injEq]
  constructor
  ¬∑ ext ‚ü®‚ü©; exact h_obj
  ¬∑ apply Function.hfunext rfl
    rintro ‚ü®‚ü© ‚ü®‚ü© -
    apply Function.hfunext rfl
    rintro ‚ü®‚ü© ‚ü®‚ü© -
    apply Function.hfunext rfl
    simp only [heq_eq_eq, forall_eq']
    rintro ‚ü®‚ü©
    simp at h_map
    simp [h_map, Quiver.homOfEq_heq]

lemma Point.prefunctor.ext_iff {V : Type u‚ÇÇ} [Quiver.{v‚ÇÇ} V] {F G : ‚≠Æ.{v‚ÇÅ, u‚ÇÅ} ‚•§q V} :
    F = G ‚Üî ‚àÉ h_obj : F.obj ‚ü®‚ü© = G.obj ‚ü®‚ü©,
      F.map ‚ü®‚ü© = Quiver.homOfEq (G.map ‚ü®‚ü©) h_obj.symm h_obj.symm := by
  refine ‚ü®fun h => ?_, fun ‚ü®h_obj, h_map‚ü© => Point.prefunctor.ext h_obj h_map‚ü©
  subst h; simp

/-- `Empty` is initial in **`Quiv`**. -/
def emptyIsInitial : IsInitial (of Empty) :=
  IsInitial.ofUniqueHom (fun X ‚Ü¶ Prefunctor.mk PEmpty.elim PEmpty.elim)
    fun X ‚ü®obj, map‚ü© ‚Ü¶ by
      congr
      ¬∑ ext ‚ü®‚ü©
      ¬∑ apply Function.hfunext rfl
        rintro ‚ü®‚ü©

instance : HasInitial Quiv := emptyIsInitial.hasInitial

/-- The initial object in **Quiv** is `Empty`. -/
noncomputable def initialIsoEmpty : ‚ä•_ Quiv ‚âÖ of Empty :=
  initialIsoIsInitial emptyIsInitial

/-- `‚≠Æ` is terminal in **Quiv**. -/
def pointIsTerminal : IsTerminal (of ‚≠Æ) :=
  IsTerminal.ofUniqueHom
    (fun X ‚Ü¶ Prefunctor.mk (fun _ ‚Ü¶ ‚ü®‚ü©) (fun _ ‚Ü¶ ‚ü®‚ü©))
    fun X ‚ü®obj, map‚ü© ‚Ü¶ by congr

instance : HasTerminal Quiv := pointIsTerminal.hasTerminal

/-- The terminal object in **Quiv** is ‚≠Æ. -/
noncomputable def terminalIsoPoint : ‚ä§_ Quiv ‚âÖ of ‚≠Æ :=
  terminalIsoIsTerminal pointIsTerminal

end Quiv
end CategoryTheory
