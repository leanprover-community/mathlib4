/-
Copyright (c) 2022 Yuma Mizuno. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yuma Mizuno
-/
import Mathlib.CategoryTheory.Bicategory.Functor

#align_import category_theory.bicategory.free from "leanprover-community/mathlib"@"3d7987cda72abc473c7cdbbb075170e9ac620042"

/-!
# Free bicategories

We define the free bicategory over a quiver. In this bicategory, the 1-morphisms are freely
generated by the arrows in the quiver, and the 2-morphisms are freely generated by the formal
identities, the formal unitors, and the formal associators modulo the relation derived from the
axioms of a bicategory.

## Main definitions

* `FreeBicategory B`: the free bicategory over a quiver `B`.
* `FreeBicategory.lift F`: the pseudofunctor from `FreeBicategory B` to `C` associated with a
  prefunctor `F` from `B` to `C`.
-/


universe w wâ‚ wâ‚‚ v vâ‚ vâ‚‚ u uâ‚ uâ‚‚

namespace CategoryTheory

open Category Bicategory

open Bicategory

/-- Free bicategory over a quiver. Its objects are the same as those in the underlying quiver. -/
def FreeBicategory (B : Type u) :=
  B
#align category_theory.free_bicategory CategoryTheory.FreeBicategory

instance (B : Type u) : âˆ€ [Inhabited B], Inhabited (FreeBicategory B) := by
  intro h
  -- âŠ¢ Inhabited (FreeBicategory B)
  exact id h
  -- ğŸ‰ no goals

namespace FreeBicategory

section

variable {B : Type u} [Quiver.{v + 1} B]

/-- 1-morphisms in the free bicategory. -/
inductive Hom : B â†’ B â†’ Type max u v
  | of {a b : B} (f : a âŸ¶ b) : Hom a b
  | id (a : B) : Hom a a
  | comp {a b c : B} (f : Hom a b) (g : Hom b c) : Hom a c
#align category_theory.free_bicategory.hom CategoryTheory.FreeBicategory.Hom

instance (a b : B) [Inhabited (a âŸ¶ b)] : Inhabited (Hom a b) :=
  âŸ¨Hom.of defaultâŸ©

instance quiver : Quiver.{max u v + 1} (FreeBicategory B) where
  Hom := fun a b : B => Hom a b

instance categoryStruct : CategoryStruct.{max u v} (FreeBicategory B) where
  id  := fun a : B => Hom.id a
  comp := @fun _ _ _ => Hom.comp

/-- Representatives of 2-morphisms in the free bicategory. -/
-- porting note: no such linter
-- @[nolint has_nonempty_instance]
inductive Homâ‚‚ : âˆ€ {a b : FreeBicategory B}, (a âŸ¶ b) â†’ (a âŸ¶ b) â†’ Type max u v
  | id {a b} (f : a âŸ¶ b) : Homâ‚‚ f f
  | vcomp {a b} {f g h : a âŸ¶ b} (Î· : Homâ‚‚ f g) (Î¸ : Homâ‚‚ g h) : Homâ‚‚ f h
  | whisker_left {a b c} (f : a âŸ¶ b) {g h : b âŸ¶ c} (Î· : Homâ‚‚ g h) :
      Homâ‚‚ (f â‰« g) (f â‰« h)-- `Î·` cannot be earlier than `h` since it is a recursive argument.
  | whisker_right {a b c} {f g : a âŸ¶ b} (h : b âŸ¶ c) (Î· : Homâ‚‚ f g) : Homâ‚‚ (f.comp h) (g.comp h)
  | associator {a b c d} (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d) :
      Homâ‚‚ ((f â‰« g) â‰« h) (f â‰« (g â‰« h))
  | associator_inv {a b c d} (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d) :
      Homâ‚‚ (f â‰« (g â‰« h)) ((f â‰« g) â‰« h)
  | right_unitor {a b} (f : a âŸ¶ b) : Homâ‚‚ (f â‰« (ğŸ™ b)) f
  | right_unitor_inv {a b} (f : a âŸ¶ b) : Homâ‚‚ f (f â‰« (ğŸ™ b))
  | left_unitor {a b} (f : a âŸ¶ b) : Homâ‚‚ ((ğŸ™ a) â‰« f) f
  | left_unitor_inv {a b} (f : a âŸ¶ b) : Homâ‚‚ f ((ğŸ™ a) â‰« f)
#align category_theory.free_bicategory.homâ‚‚ CategoryTheory.FreeBicategory.Homâ‚‚

section

-- porting note: commenting out redundant binder annotation update
-- variable {B}

-- mathport name: vcomp
-- The following notations are only used in the definition of `Rel` to simplify the notation.
local infixr:0 " â‰« " => Homâ‚‚.vcomp

-- mathport name: id
local notation "ğŸ™" => Homâ‚‚.id

-- mathport name: whisker_left
local notation f " â— " Î· => Homâ‚‚.whisker_left f Î·

-- mathport name: whisker_right
local notation Î· " â–· " h => Homâ‚‚.whisker_right h Î·

-- mathport name: associator
local notation "Î±_" => Homâ‚‚.associator

-- mathport name: left_unitor
local notation "Î»_" => Homâ‚‚.left_unitor

-- mathport name: right_unitor
local notation "Ï_" => Homâ‚‚.right_unitor

-- mathport name: associator_inv
local notation "Î±â»Â¹_" => Homâ‚‚.associator_inv

-- mathport name: left_unitor_inv
local notation "Î»â»Â¹_" => Homâ‚‚.left_unitor_inv

-- mathport name: right_unitor_inv
local notation "Ïâ»Â¹_" => Homâ‚‚.right_unitor_inv

/-- Relations between 2-morphisms in the free bicategory. -/
inductive Rel : âˆ€ {a b : FreeBicategory B} {f g : a âŸ¶ b}, Homâ‚‚ f g â†’ Homâ‚‚ f g â†’ Prop
  | vcomp_right {a b} {f g h : Hom a b} (Î· : Homâ‚‚ f g) (Î¸â‚ Î¸â‚‚ : Homâ‚‚ g h) :
      Rel Î¸â‚ Î¸â‚‚ â†’ Rel (Î· â‰« Î¸â‚) (Î· â‰« Î¸â‚‚)
  | vcomp_left {a b} {f g h : Hom a b} (Î·â‚ Î·â‚‚ : Homâ‚‚ f g) (Î¸ : Homâ‚‚ g h) :
      Rel Î·â‚ Î·â‚‚ â†’ Rel (Î·â‚ â‰« Î¸) (Î·â‚‚ â‰« Î¸)
  | id_comp {a b} {f g : Hom a b} (Î· : Homâ‚‚ f g) : Rel (ğŸ™ f â‰« Î·) Î·
  | comp_id {a b} {f g : Hom a b} (Î· : Homâ‚‚ f g) : Rel (Î· â‰« ğŸ™ g) Î·
  | assoc {a b} {f g h i : Hom a b} (Î· : Homâ‚‚ f g) (Î¸ : Homâ‚‚ g h) (Î¹ : Homâ‚‚ h i) :
      Rel ((Î· â‰« Î¸) â‰« Î¹) (Î· â‰« Î¸ â‰« Î¹)
  | whisker_left {a b c} (f : Hom a b) (g h : Hom b c) (Î· Î·' : Homâ‚‚ g h) :
      Rel Î· Î·' â†’ Rel (f â— Î·) (f â— Î·')
  | whisker_left_id {a b c} (f : Hom a b) (g : Hom b c) : Rel (f â— ğŸ™ g) (ğŸ™ (f.comp g))
  | whisker_left_comp {a b c} (f : Hom a b) {g h i : Hom b c} (Î· : Homâ‚‚ g h) (Î¸ : Homâ‚‚ h i) :
      Rel (f â— Î· â‰« Î¸) ((f â— Î·) â‰« f â— Î¸)
  | id_whisker_left {a b} {f g : Hom a b} (Î· : Homâ‚‚ f g) : Rel (Hom.id a â— Î·) (Î»_ f â‰« Î· â‰« Î»â»Â¹_ g)
  | comp_whisker_left {a b c d} (f : Hom a b) (g : Hom b c) {h h' : Hom c d} (Î· : Homâ‚‚ h h') :
     Rel (f.comp g â— Î·) (Î±_ f g h â‰« (f â— g â— Î·) â‰« Î±â»Â¹_ f g h')
  | whisker_right {a b c} (f g : Hom a b) (h : Hom b c) (Î· Î·' : Homâ‚‚ f g) :
      Rel Î· Î·' â†’ Rel (Î· â–· h) (Î·' â–· h)
  | id_whisker_right {a b c} (f : Hom a b) (g : Hom b c) : Rel (ğŸ™ f â–· g) (ğŸ™ (f.comp g))
  | comp_whisker_right {a b c} {f g h : Hom a b} (i : Hom b c) (Î· : Homâ‚‚ f g) (Î¸ : Homâ‚‚ g h) :
      Rel ((Î· â‰« Î¸) â–· i) ((Î· â–· i) â‰« Î¸ â–· i)
  | whisker_right_id {a b} {f g : Hom a b} (Î· : Homâ‚‚ f g) : Rel (Î· â–· Hom.id b) (Ï_ f â‰« Î· â‰« Ïâ»Â¹_ g)
  | whisker_right_comp {a b c d} {f f' : Hom a b} (g : Hom b c) (h : Hom c d) (Î· : Homâ‚‚ f f') :
      Rel (Î· â–· g.comp h) (Î±â»Â¹_ f g h â‰« ((Î· â–· g) â–· h) â‰« Î±_ f' g h)
  | whisker_assoc {a b c d} (f : Hom a b) {g g' : Hom b c} (Î· : Homâ‚‚ g g') (h : Hom c d) :
      Rel ((f â— Î·) â–· h) (Î±_ f g h â‰« (f â— Î· â–· h) â‰« Î±â»Â¹_ f g' h)
  | whisker_exchange {a b c} {f g : Hom a b} {h i : Hom b c} (Î· : Homâ‚‚ f g) (Î¸ : Homâ‚‚ h i) :
      Rel ((f â— Î¸) â‰« Î· â–· i) ((Î· â–· h) â‰« g â— Î¸)
  | associator_hom_inv {a b c d} (f : Hom a b) (g : Hom b c) (h : Hom c d) :
      Rel (Î±_ f g h â‰« Î±â»Â¹_ f g h) (ğŸ™ ((f.comp g).comp h))
  | associator_inv_hom {a b c d} (f : Hom a b) (g : Hom b c) (h : Hom c d) :
      Rel (Î±â»Â¹_ f g h â‰« Î±_ f g h) (ğŸ™ (f.comp (g.comp h)))
  | left_unitor_hom_inv {a b} (f : Hom a b) : Rel (Î»_ f â‰« Î»â»Â¹_ f) (ğŸ™ ((Hom.id a).comp f))
  | left_unitor_inv_hom {a b} (f : Hom a b) : Rel (Î»â»Â¹_ f â‰« Î»_ f) (ğŸ™ f)
  | right_unitor_hom_inv {a b} (f : Hom a b) : Rel (Ï_ f â‰« Ïâ»Â¹_ f) (ğŸ™ (f.comp (Hom.id b)))
  | right_unitor_inv_hom {a b} (f : Hom a b) : Rel (Ïâ»Â¹_ f â‰« Ï_ f) (ğŸ™ f)
  | pentagon {a b c d e} (f : Hom a b) (g : Hom b c) (h : Hom c d) (i : Hom d e) :
      Rel ((Î±_ f g h â–· i) â‰« Î±_ f (g.comp h) i â‰« f â— Î±_ g h i)
        (Î±_ (f.comp g) h i â‰« Î±_ f g (h.comp i))
  | triangle {a b c} (f : Hom a b) (g : Hom b c) : Rel (Î±_ f (Hom.id b) g â‰« f â— Î»_ g) (Ï_ f â–· g)
#align category_theory.free_bicategory.rel CategoryTheory.FreeBicategory.Rel

end

-- porting note: commenting out redundant binder annotation update
-- variable {B}

instance homCategory (a b : FreeBicategory B) : Category (a âŸ¶ b) where
  Hom f g := Quot (@Rel _ _ a b f g)
  id f := Quot.mk Rel (Homâ‚‚.id f)
  comp := @fun f g h => Quot.mapâ‚‚ Homâ‚‚.vcomp Rel.vcomp_right Rel.vcomp_left
  id_comp := by
    rintro f g âŸ¨Î·âŸ©
    -- âŠ¢ ğŸ™ f â‰« Quot.mk Rel Î· = Quot.mk Rel Î·
    exact Quot.sound (Rel.id_comp Î·)
    -- ğŸ‰ no goals
  comp_id := by
    rintro f g âŸ¨Î·âŸ©
    -- âŠ¢ Quot.mk Rel Î· â‰« ğŸ™ g = Quot.mk Rel Î·
    exact Quot.sound (Rel.comp_id Î·)
    -- ğŸ‰ no goals
  assoc := by
    rintro f g h i âŸ¨Î·âŸ© âŸ¨Î¸âŸ© âŸ¨Î¹âŸ©
    -- âŠ¢ (Quot.mk Rel Î· â‰« Quot.mk Rel Î¸) â‰« Quot.mk Rel Î¹ = Quot.mk Rel Î· â‰« Quot.mk Re â€¦
    exact Quot.sound (Rel.assoc Î· Î¸ Î¹)
    -- ğŸ‰ no goals
#align category_theory.free_bicategory.hom_category CategoryTheory.FreeBicategory.homCategory

/-- Bicategory structure on the free bicategory. -/
instance bicategory : Bicategory (FreeBicategory B) where
  homCategory := @fun (a b : B) => FreeBicategory.homCategory a b
  whiskerLeft := @fun a b c f g h Î· => Quot.map (Homâ‚‚.whisker_left f) (Rel.whisker_left f g h) Î·
  whiskerLeft_id := @fun a b c f g => Quot.sound (Rel.whisker_left_id f g)
  associator := @fun a b c d f g h =>
    { hom := Quot.mk Rel (Homâ‚‚.associator f g h)
      inv := Quot.mk Rel (Homâ‚‚.associator_inv f g h)
      hom_inv_id := Quot.sound (Rel.associator_hom_inv f g h)
      inv_hom_id := Quot.sound (Rel.associator_inv_hom f g h) }
  leftUnitor := @fun a b f =>
    { hom := Quot.mk Rel (Homâ‚‚.left_unitor f)
      inv := Quot.mk Rel (Homâ‚‚.left_unitor_inv f)
      hom_inv_id := Quot.sound (Rel.left_unitor_hom_inv f)
      inv_hom_id := Quot.sound (Rel.left_unitor_inv_hom f) }
  rightUnitor := @fun a b f =>
    { hom := Quot.mk Rel (Homâ‚‚.right_unitor f)
      inv := Quot.mk Rel (Homâ‚‚.right_unitor_inv f)
      hom_inv_id := Quot.sound (Rel.right_unitor_hom_inv f)
      inv_hom_id := Quot.sound (Rel.right_unitor_inv_hom f) }
  whiskerLeft_comp := by
    rintro a b c f g h i âŸ¨Î·âŸ© âŸ¨Î¸âŸ©
    -- âŠ¢ (fun a b c f g h Î· => Quot.map (Homâ‚‚.whisker_left f) (_ : âˆ€ (Î· Î·' : Homâ‚‚ g h â€¦
    exact Quot.sound (Rel.whisker_left_comp f Î· Î¸)
    -- ğŸ‰ no goals
  id_whiskerLeft := by
    rintro a b f g âŸ¨Î·âŸ©
    -- âŠ¢ (fun a b c f g h Î· => Quot.map (Homâ‚‚.whisker_left f) (_ : âˆ€ (Î· Î·' : Homâ‚‚ g h â€¦
    exact Quot.sound (Rel.id_whisker_left Î·)
    -- ğŸ‰ no goals
  comp_whiskerLeft := by
    rintro a b c d f g h h' âŸ¨Î·âŸ©
    -- âŠ¢ (fun a b c f g h Î· => Quot.map (Homâ‚‚.whisker_left f) (_ : âˆ€ (Î· Î·' : Homâ‚‚ g h â€¦
    exact Quot.sound (Rel.comp_whisker_left f g Î·)
    -- ğŸ‰ no goals
  whiskerRight := @fun a b c f g Î· h => Quot.map (Homâ‚‚.whisker_right h) (Rel.whisker_right f g h) Î·
  id_whiskerRight := @fun a b c f g => Quot.sound (Rel.id_whisker_right f g)
  comp_whiskerRight := by
    rintro a b c f g h âŸ¨Î·âŸ© âŸ¨Î¸âŸ© i
    -- âŠ¢ (fun a b c f g Î· h => Quot.map (Homâ‚‚.whisker_right h) (_ : âˆ€ (Î· Î·' : Homâ‚‚ f  â€¦
    exact Quot.sound (Rel.comp_whisker_right i Î· Î¸)
    -- ğŸ‰ no goals
  whiskerRight_id := by
    rintro a b f g âŸ¨Î·âŸ©
    -- âŠ¢ (fun a b c f g Î· h => Quot.map (Homâ‚‚.whisker_right h) (_ : âˆ€ (Î· Î·' : Homâ‚‚ f  â€¦
    exact Quot.sound (Rel.whisker_right_id Î·)
    -- ğŸ‰ no goals
  whiskerRight_comp := by
    rintro a b c d f f' âŸ¨Î·âŸ© g h
    -- âŠ¢ (fun a b c f g Î· h => Quot.map (Homâ‚‚.whisker_right h) (_ : âˆ€ (Î· Î·' : Homâ‚‚ f  â€¦
    exact Quot.sound (Rel.whisker_right_comp g h Î·)
    -- ğŸ‰ no goals
  whisker_assoc := by
    rintro a b c d f g g' âŸ¨Î·âŸ© h
    -- âŠ¢ (fun a b c f g Î· h => Quot.map (Homâ‚‚.whisker_right h) (_ : âˆ€ (Î· Î·' : Homâ‚‚ f  â€¦
    exact Quot.sound (Rel.whisker_assoc f Î· h)
    -- ğŸ‰ no goals
  whisker_exchange := by
    rintro a b c f g h i âŸ¨Î·âŸ© âŸ¨Î¸âŸ©
    -- âŠ¢ (fun a b c f g h Î· => Quot.map (Homâ‚‚.whisker_left f) (_ : âˆ€ (Î· Î·' : Homâ‚‚ g h â€¦
    exact Quot.sound (Rel.whisker_exchange Î· Î¸)
    -- ğŸ‰ no goals
  pentagon := @fun a b c d e f g h i => Quot.sound (Rel.pentagon f g h i)
  triangle := @fun a b c f g => Quot.sound (Rel.triangle f g)
#align category_theory.free_bicategory.bicategory CategoryTheory.FreeBicategory.bicategory

variable {a b c d : FreeBicategory B}

abbrev Homâ‚‚.mk {f g : a âŸ¶ b} (Î· : Homâ‚‚ f g) : f âŸ¶ g :=
  Quot.mk Rel Î·

@[simp]
theorem mk_vcomp {f g h : a âŸ¶ b} (Î· : Homâ‚‚ f g) (Î¸ : Homâ‚‚ g h) :
    (Î·.vcomp Î¸).mk = (Î·.mk â‰« Î¸.mk : f âŸ¶ h) :=
  rfl
#align category_theory.free_bicategory.mk_vcomp CategoryTheory.FreeBicategory.mk_vcomp

@[simp]
theorem mk_whisker_left (f : a âŸ¶ b) {g h : b âŸ¶ c} (Î· : Homâ‚‚ g h) :
    (Homâ‚‚.whisker_left f Î·).mk = (f â— Î·.mk : f â‰« g âŸ¶ f â‰« h) :=
  rfl
#align category_theory.free_bicategory.mk_whisker_left CategoryTheory.FreeBicategory.mk_whisker_left

@[simp]
theorem mk_whisker_right {f g : a âŸ¶ b} (Î· : Homâ‚‚ f g) (h : b âŸ¶ c) :
    (Homâ‚‚.whisker_right h Î·).mk = (Î·.mk â–· h : f â‰« h âŸ¶ g â‰« h) :=
  rfl
#align category_theory.free_bicategory.mk_whisker_right CategoryTheory.FreeBicategory.mk_whisker_right

variable (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d)

-- Porting note: I can not get this to typecheck, and I don't understand why.
-- theorem id_def : Hom.id a = ğŸ™ a :=
--   rfl
-- #align category_theory.free_bicategory.id_def CategoryTheory.FreeBicategory.id_def
#noalign category_theory.free_bicategory.id_def

theorem comp_def : Hom.comp f g = f â‰« g :=
  rfl
#align category_theory.free_bicategory.comp_def CategoryTheory.FreeBicategory.comp_def

@[simp]
theorem mk_id : Quot.mk _ (Homâ‚‚.id f) = ğŸ™ f :=
  rfl
#align category_theory.free_bicategory.mk_id CategoryTheory.FreeBicategory.mk_id

@[simp]
theorem mk_associator_hom : Quot.mk _ (Homâ‚‚.associator f g h) = (Î±_ f g h).hom :=
  rfl
#align category_theory.free_bicategory.mk_associator_hom CategoryTheory.FreeBicategory.mk_associator_hom

@[simp]
theorem mk_associator_inv : Quot.mk _ (Homâ‚‚.associator_inv f g h) = (Î±_ f g h).inv :=
  rfl
#align category_theory.free_bicategory.mk_associator_inv CategoryTheory.FreeBicategory.mk_associator_inv

@[simp]
theorem mk_left_unitor_hom : Quot.mk _ (Homâ‚‚.left_unitor f) = (Î»_ f).hom :=
  rfl
#align category_theory.free_bicategory.mk_left_unitor_hom CategoryTheory.FreeBicategory.mk_left_unitor_hom

@[simp]
theorem mk_left_unitor_inv : Quot.mk _ (Homâ‚‚.left_unitor_inv f) = (Î»_ f).inv :=
  rfl
#align category_theory.free_bicategory.mk_left_unitor_inv CategoryTheory.FreeBicategory.mk_left_unitor_inv

@[simp]
theorem mk_right_unitor_hom : Quot.mk _ (Homâ‚‚.right_unitor f) = (Ï_ f).hom :=
  rfl
#align category_theory.free_bicategory.mk_right_unitor_hom CategoryTheory.FreeBicategory.mk_right_unitor_hom

@[simp]
theorem mk_right_unitor_inv : Quot.mk _ (Homâ‚‚.right_unitor_inv f) = (Ï_ f).inv :=
  rfl
#align category_theory.free_bicategory.mk_right_unitor_inv CategoryTheory.FreeBicategory.mk_right_unitor_inv

/-- Canonical prefunctor from `B` to `free_bicategory B`. -/
@[simps]
def of : Prefunctor B (FreeBicategory B) where
  obj := id
  map := @fun _ _ => Hom.of
#align category_theory.free_bicategory.of CategoryTheory.FreeBicategory.of

end

section

variable {B : Type uâ‚} [Quiver.{vâ‚ + 1} B] {C : Type uâ‚‚} [CategoryStruct.{vâ‚‚} C]

variable (F : Prefunctor B C)

/-- Auxiliary definition for `lift`. -/
@[simp]
def liftHom : âˆ€ {a b : FreeBicategory B}, (a âŸ¶ b) â†’ (F.obj a âŸ¶ F.obj b)
  | _, _, Hom.of f => F.map f
  | _, _, Hom.id a => ğŸ™ (F.obj a)
  | _, _, Hom.comp f g => liftHom f â‰« liftHom g
#align category_theory.free_bicategory.lift_hom CategoryTheory.FreeBicategory.liftHom

@[simp]
theorem liftHom_id (a : FreeBicategory B) : liftHom F (ğŸ™ a) = ğŸ™ (F.obj a) :=
  rfl
#align category_theory.free_bicategory.lift_hom_id CategoryTheory.FreeBicategory.liftHom_id

@[simp]
theorem liftHom_comp {a b c : FreeBicategory B} (f : a âŸ¶ b) (g : b âŸ¶ c) :
    liftHom F (f â‰« g) = liftHom F f â‰« liftHom F g :=
  rfl
#align category_theory.free_bicategory.lift_hom_comp CategoryTheory.FreeBicategory.liftHom_comp

end

section

variable {B : Type uâ‚} [Quiver.{vâ‚ + 1} B] {C : Type uâ‚‚} [Bicategory.{wâ‚‚, vâ‚‚} C]

variable (F : Prefunctor B C)

/-- Auxiliary definition for `lift`. -/
-- @[simp] -- Porting note: adding `@[simp]` causes a PANIC.
def liftHomâ‚‚ : âˆ€ {a b : FreeBicategory B} {f g : a âŸ¶ b}, Homâ‚‚ f g â†’ (liftHom F f âŸ¶ liftHom F g)
  | _, _, _, _, Homâ‚‚.id _ => ğŸ™ _
  | _, _, _, _, Homâ‚‚.associator _ _ _ => (Î±_ _ _ _).hom
  | _, _, _, _, Homâ‚‚.associator_inv _ _ _ => (Î±_ _ _ _).inv
  | _, _, _, _, Homâ‚‚.left_unitor _ => (Î»_ _).hom
  | _, _, _, _, Homâ‚‚.left_unitor_inv _ => (Î»_ _).inv
  | _, _, _, _, Homâ‚‚.right_unitor _ => (Ï_ _).hom
  | _, _, _, _, Homâ‚‚.right_unitor_inv _ => (Ï_ _).inv
  | _, _, _, _, Homâ‚‚.vcomp Î· Î¸ => liftHomâ‚‚ Î· â‰« liftHomâ‚‚ Î¸
  | _, _, _, _, Homâ‚‚.whisker_left f Î· => liftHom F f â— liftHomâ‚‚ Î·
  | _, _, _, _, Homâ‚‚.whisker_right h Î· => liftHomâ‚‚ Î· â–· liftHom F h
#align category_theory.free_bicategory.lift_homâ‚‚ CategoryTheory.FreeBicategory.liftHomâ‚‚

attribute [local simp] whisker_exchange

theorem liftHomâ‚‚_congr {a b : FreeBicategory B} {f g : a âŸ¶ b} {Î· Î¸ : Homâ‚‚ f g} (H : Rel Î· Î¸) :
    liftHomâ‚‚ F Î· = liftHomâ‚‚ F Î¸ := by induction H <;> (dsimp [liftHomâ‚‚]; aesop_cat)
                                                       -- âŠ¢ liftHomâ‚‚ F Î·âœ â‰« liftHomâ‚‚ F Î¸â‚âœ = liftHomâ‚‚ F Î·âœ â‰« liftHomâ‚‚ F Î¸â‚‚âœ
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ liftHomâ‚‚ F Î·â‚âœ â‰« liftHomâ‚‚ F Î¸âœ = liftHomâ‚‚ F Î·â‚‚âœ â‰« liftHomâ‚‚ F Î¸âœ
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ ğŸ™ (liftHom F fâœ) â‰« liftHomâ‚‚ F Î·âœ = liftHomâ‚‚ F Î·âœ
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ liftHomâ‚‚ F Î·âœ â‰« ğŸ™ (liftHom F gâœ) = liftHomâ‚‚ F Î·âœ
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ (liftHomâ‚‚ F Î·âœ â‰« liftHomâ‚‚ F Î¸âœ) â‰« liftHomâ‚‚ F Î¹âœ = liftHomâ‚‚ F Î·âœ â‰« liftHomâ‚‚ F â€¦
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ liftHom F fâœ â— liftHomâ‚‚ F Î·âœ = liftHom F fâœ â— liftHomâ‚‚ F Î·'âœ
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ liftHom F fâœ â— ğŸ™ (liftHom F gâœ) = ğŸ™ (liftHom F fâœ â‰« liftHom F gâœ)
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ liftHom F fâœ â— (liftHomâ‚‚ F Î·âœ â‰« liftHomâ‚‚ F Î¸âœ) = liftHom F fâœ â— liftHomâ‚‚ F Î· â€¦
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ ğŸ™ (F.obj aâœ) â— liftHomâ‚‚ F Î·âœ = (Î»_ (liftHom F fâœ)).hom â‰« liftHomâ‚‚ F Î·âœ â‰« (Î»_ â€¦
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ (liftHom F fâœ â‰« liftHom F gâœ) â— liftHomâ‚‚ F Î·âœ = (Î±_ (liftHom F fâœ) (liftHom  â€¦
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ liftHomâ‚‚ F Î·âœ â–· liftHom F hâœ = liftHomâ‚‚ F Î·'âœ â–· liftHom F hâœ
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ ğŸ™ (liftHom F fâœ) â–· liftHom F gâœ = ğŸ™ (liftHom F fâœ â‰« liftHom F gâœ)
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ (liftHomâ‚‚ F Î·âœ â‰« liftHomâ‚‚ F Î¸âœ) â–· liftHom F iâœ = liftHomâ‚‚ F Î·âœ â–· liftHom F i â€¦
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ liftHomâ‚‚ F Î·âœ â–· ğŸ™ (F.obj bâœ) = (Ï_ (liftHom F fâœ)).hom â‰« liftHomâ‚‚ F Î·âœ â‰« (Ï_ â€¦
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ liftHomâ‚‚ F Î·âœ â–· (liftHom F gâœ â‰« liftHom F hâœ) = (Î±_ (liftHom F fâœ) (liftHom  â€¦
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ (liftHom F fâœ â— liftHomâ‚‚ F Î·âœ) â–· liftHom F hâœ = (Î±_ (liftHom F fâœ) (liftHom  â€¦
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ liftHom F fâœ â— liftHomâ‚‚ F Î¸âœ â‰« liftHomâ‚‚ F Î·âœ â–· liftHom F iâœ = liftHomâ‚‚ F Î·âœ  â€¦
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ (Î±_ (liftHom F fâœ) (liftHom F gâœ) (liftHom F hâœ)).hom â‰« (Î±_ (liftHom F fâœ) ( â€¦
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ (Î±_ (liftHom F fâœ) (liftHom F gâœ) (liftHom F hâœ)).inv â‰« (Î±_ (liftHom F fâœ) ( â€¦
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ (Î»_ (liftHom F fâœ)).hom â‰« (Î»_ (liftHom F fâœ)).inv = ğŸ™ (ğŸ™ (F.obj aâœ) â‰« liftHo â€¦
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ (Î»_ (liftHom F fâœ)).inv â‰« (Î»_ (liftHom F fâœ)).hom = ğŸ™ (liftHom F fâœ)
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ (Ï_ (liftHom F fâœ)).hom â‰« (Ï_ (liftHom F fâœ)).inv = ğŸ™ (liftHom F fâœ â‰« ğŸ™ (F.o â€¦
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ (Ï_ (liftHom F fâœ)).inv â‰« (Ï_ (liftHom F fâœ)).hom = ğŸ™ (liftHom F fâœ)
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ (Î±_ (liftHom F fâœ) (liftHom F gâœ) (liftHom F hâœ)).hom â–· liftHom F iâœ â‰« (Î±_ ( â€¦
                                                                         -- ğŸ‰ no goals
                                                       -- âŠ¢ (Î±_ (liftHom F fâœ) (ğŸ™ (F.obj bâœ)) (liftHom F gâœ)).hom â‰« liftHom F fâœ â— (Î»_ ( â€¦
                                                                         -- ğŸ‰ no goals
#align category_theory.free_bicategory.lift_homâ‚‚_congr CategoryTheory.FreeBicategory.liftHomâ‚‚_congr

/-- A prefunctor from a quiver `B` to a bicategory `C` can be lifted to a pseudofunctor from
`free_bicategory B` to `C`.
-/
@[simps]
def lift : Pseudofunctor (FreeBicategory B) C where
  obj := F.obj
  map := liftHom F
  mapId a := Iso.refl _
  mapComp f g := Iso.refl _
  mapâ‚‚ := Quot.lift (liftHomâ‚‚ F) fun Î· Î¸ H => liftHomâ‚‚_congr F H
  -- Porting note: We'd really prefer not to be doing this by hand.
  -- in mathlib3 `tidy` did these inductions for us.
  mapâ‚‚_comp := by
    intros a b f g h Î· Î¸
    -- âŠ¢ PrelaxFunctor.mapâ‚‚ { toPrefunctor := { obj := F.obj, map := fun {X Y} => lif â€¦
    apply Quot.rec _ _ Î·
    -- âŠ¢ âˆ€ (a_1 : Homâ‚‚ f g), PrelaxFunctor.mapâ‚‚ { toPrefunctor := { obj := F.obj, map â€¦
    Â· intro Î·
      -- âŠ¢ PrelaxFunctor.mapâ‚‚ { toPrefunctor := { obj := F.obj, map := fun {X Y} => lif â€¦
      apply Quot.rec _ _ Î¸
      -- âŠ¢ âˆ€ (a_1 : Homâ‚‚ g h), PrelaxFunctor.mapâ‚‚ { toPrefunctor := { obj := F.obj, map â€¦
      Â· intro Î¸; rfl
        -- âŠ¢ PrelaxFunctor.mapâ‚‚ { toPrefunctor := { obj := F.obj, map := fun {X Y} => lif â€¦
                 -- ğŸ‰ no goals
      Â· intros; rfl
        -- âŠ¢ (_ : PrelaxFunctor.mapâ‚‚ { toPrefunctor := { obj := F.obj, map := fun {X Y} = â€¦
                -- ğŸ‰ no goals
    Â· intros; rfl
      -- âŠ¢ (_ : PrelaxFunctor.mapâ‚‚ { toPrefunctor := { obj := F.obj, map := fun {X Y} = â€¦
              -- ğŸ‰ no goals
  -- Porting note: still borked from here. The infoview doesn't update properly for me.
  mapâ‚‚_whisker_left := by
    intro a b c f g h Î·
    -- âŠ¢ PrelaxFunctor.mapâ‚‚ { toPrefunctor := { obj := F.obj, map := fun {X Y} => lif â€¦
    apply Quot.rec _ _ Î·
    -- âŠ¢ âˆ€ (a_1 : Homâ‚‚ g h), PrelaxFunctor.mapâ‚‚ { toPrefunctor := { obj := F.obj, map â€¦
    Â· intros; aesop_cat
      -- âŠ¢ PrelaxFunctor.mapâ‚‚ { toPrefunctor := { obj := F.obj, map := fun {X Y} => lif â€¦
              -- ğŸ‰ no goals
    Â· intros; rfl
      -- âŠ¢ (_ : PrelaxFunctor.mapâ‚‚ { toPrefunctor := { obj := F.obj, map := fun {X Y} = â€¦
              -- ğŸ‰ no goals
  mapâ‚‚_whisker_right := by intro _ _ _ _ _ Î· h; dsimp; apply Quot.rec _ _ Î· <;> aesop_cat
                           -- âŠ¢ PrelaxFunctor.mapâ‚‚ { toPrefunctor := { obj := F.obj, map := fun {X Y} => lif â€¦
                                                -- âŠ¢ Quot.lift (liftHomâ‚‚ F) (_ : âˆ€ (Î· Î¸ : Homâ‚‚ (fâœ â‰« h) (gâœ â‰« h)), Rel Î· Î¸ â†’ lift â€¦
                                                       -- âŠ¢ âˆ€ (a : Homâ‚‚ fâœ gâœ), Quot.lift (liftHomâ‚‚ F) (_ : âˆ€ (Î· Î¸ : Homâ‚‚ (fâœ â‰« h) (gâœ â‰« â€¦
                                                                                -- ğŸ‰ no goals
                                                                                -- ğŸ‰ no goals
#align category_theory.free_bicategory.lift CategoryTheory.FreeBicategory.lift

end

end FreeBicategory

end CategoryTheory
