/-
Copyright (c) 2022 Yuma Mizuno. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yuma Mizuno

! This file was ported from Lean 3 source module category_theory.bicategory.coherence_tactic
! leanprover-community/mathlib commit 3d7987cda72abc473c7cdbbb075170e9ac620042
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Bicategory.Coherence

/-!
# A `coherence` tactic for bicategories, and `‚äó‚â´` (composition up to associators)

We provide a `coherence` tactic,
which proves that any two 2-morphisms (with the same source and target)
in a bicategory which are built out of associators and unitors
are equal.

We also provide `f ‚äó‚â´ g`, the `bicategorical_comp` operation,
which automatically inserts associators and unitors as needed
to make the target of `f` match the source of `g`.

This file mainly deals with the type class setup for the coherence tactic. The actual front end
tactic is given in `category_theory/monooidal/coherence.lean` at the same time as the coherence
tactic for monoidal categories.
-/


noncomputable section

universe w v u

open CategoryTheory

open CategoryTheory.FreeBicategory

open scoped Bicategory

variable {B : Type u} [Bicategory.{w, v} B] {a b c d e : B}

namespace CategoryTheory.Bicategory

/-- A typeclass carrying a choice of lift of a 1-morphism from `B` to `free_bicategory B`. -/
class LiftHom {a b : B} (f : a ‚ü∂ b) where
  lift : of.obj a ‚ü∂ of.obj b
#align category_theory.bicategory.lift_hom CategoryTheory.Bicategory.LiftHom

instance liftHomId : LiftHom (ùüô a) where lift := ùüô (of.obj a)
#align category_theory.bicategory.lift_hom_id CategoryTheory.Bicategory.liftHomId

instance liftHomComp (f : a ‚ü∂ b) (g : b ‚ü∂ c) [LiftHom f] [LiftHom g] : LiftHom (f ‚â´ g)
    where lift := LiftHom.lift f ‚â´ LiftHom.lift g
#align category_theory.bicategory.lift_hom_comp CategoryTheory.Bicategory.liftHomComp

instance (priority := 100) liftHomOf (f : a ‚ü∂ b) : LiftHom f where lift := of.map f
#align category_theory.bicategory.lift_hom_of CategoryTheory.Bicategory.liftHomOf

/-- A typeclass carrying a choice of lift of a 2-morphism from `B` to `free_bicategory B`. -/
class LiftHom‚ÇÇ {f g : a ‚ü∂ b} [LiftHom f] [LiftHom g] (Œ∑ : f ‚ü∂ g) where
  lift : LiftHom.lift f ‚ü∂ LiftHom.lift g
#align category_theory.bicategory.lift_hom‚ÇÇ CategoryTheory.Bicategory.LiftHom‚ÇÇ

instance liftHom‚ÇÇId (f : a ‚ü∂ b) [LiftHom f] : LiftHom‚ÇÇ (ùüô f) where lift := ùüô _
#align category_theory.bicategory.lift_hom‚ÇÇ_id CategoryTheory.Bicategory.liftHom‚ÇÇId

instance liftHom‚ÇÇLeftUnitorHom (f : a ‚ü∂ b) [LiftHom f] : LiftHom‚ÇÇ (Œª_ f).Hom
    where lift := (Œª_ (LiftHom.lift f)).Hom
#align category_theory.bicategory.lift_hom‚ÇÇ_left_unitor_hom CategoryTheory.Bicategory.liftHom‚ÇÇLeftUnitorHom

instance liftHom‚ÇÇLeftUnitorInv (f : a ‚ü∂ b) [LiftHom f] : LiftHom‚ÇÇ (Œª_ f).inv
    where lift := (Œª_ (LiftHom.lift f)).inv
#align category_theory.bicategory.lift_hom‚ÇÇ_left_unitor_inv CategoryTheory.Bicategory.liftHom‚ÇÇLeftUnitorInv

instance liftHom‚ÇÇRightUnitorHom (f : a ‚ü∂ b) [LiftHom f] : LiftHom‚ÇÇ (œÅ_ f).Hom
    where lift := (œÅ_ (LiftHom.lift f)).Hom
#align category_theory.bicategory.lift_hom‚ÇÇ_right_unitor_hom CategoryTheory.Bicategory.liftHom‚ÇÇRightUnitorHom

instance liftHom‚ÇÇRightUnitorInv (f : a ‚ü∂ b) [LiftHom f] : LiftHom‚ÇÇ (œÅ_ f).inv
    where lift := (œÅ_ (LiftHom.lift f)).inv
#align category_theory.bicategory.lift_hom‚ÇÇ_right_unitor_inv CategoryTheory.Bicategory.liftHom‚ÇÇRightUnitorInv

instance liftHom‚ÇÇAssociatorHom (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) [LiftHom f] [LiftHom g]
    [LiftHom h] : LiftHom‚ÇÇ (Œ±_ f g h).Hom
    where lift := (Œ±_ (LiftHom.lift f) (LiftHom.lift g) (LiftHom.lift h)).Hom
#align category_theory.bicategory.lift_hom‚ÇÇ_associator_hom CategoryTheory.Bicategory.liftHom‚ÇÇAssociatorHom

instance liftHom‚ÇÇAssociatorInv (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) [LiftHom f] [LiftHom g]
    [LiftHom h] : LiftHom‚ÇÇ (Œ±_ f g h).inv
    where lift := (Œ±_ (LiftHom.lift f) (LiftHom.lift g) (LiftHom.lift h)).inv
#align category_theory.bicategory.lift_hom‚ÇÇ_associator_inv CategoryTheory.Bicategory.liftHom‚ÇÇAssociatorInv

instance liftHom‚ÇÇComp {f g h : a ‚ü∂ b} [LiftHom f] [LiftHom g] [LiftHom h] (Œ∑ : f ‚ü∂ g) (Œ∏ : g ‚ü∂ h)
    [LiftHom‚ÇÇ Œ∑] [LiftHom‚ÇÇ Œ∏] : LiftHom‚ÇÇ (Œ∑ ‚â´ Œ∏) where lift := LiftHom‚ÇÇ.lift Œ∑ ‚â´ LiftHom‚ÇÇ.lift Œ∏
#align category_theory.bicategory.lift_hom‚ÇÇ_comp CategoryTheory.Bicategory.liftHom‚ÇÇComp

instance liftHom‚ÇÇWhiskerLeft (f : a ‚ü∂ b) [LiftHom f] {g h : b ‚ü∂ c} (Œ∑ : g ‚ü∂ h) [LiftHom g]
    [LiftHom h] [LiftHom‚ÇÇ Œ∑] : LiftHom‚ÇÇ (f ‚óÅ Œ∑) where lift := LiftHom.lift f ‚óÅ LiftHom‚ÇÇ.lift Œ∑
#align category_theory.bicategory.lift_hom‚ÇÇ_whisker_left CategoryTheory.Bicategory.liftHom‚ÇÇWhiskerLeft

instance liftHom‚ÇÇWhiskerRight {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) [LiftHom f] [LiftHom g] [LiftHom‚ÇÇ Œ∑]
    {h : b ‚ü∂ c} [LiftHom h] : LiftHom‚ÇÇ (Œ∑ ‚ñ∑ h) where lift := LiftHom‚ÇÇ.lift Œ∑ ‚ñ∑ LiftHom.lift h
#align category_theory.bicategory.lift_hom‚ÇÇ_whisker_right CategoryTheory.Bicategory.liftHom‚ÇÇWhiskerRight

/- ./././Mathport/Syntax/Translate/Command.lean:393:30: infer kinds are unsupported in Lean 4: #[`Hom] [] -/
/-- A typeclass carrying a choice of bicategorical structural isomorphism between two objects.
Used by the `‚äó‚â´` bicategorical composition operator, and the `coherence` tactic.
-/
class BicategoricalCoherence (f g : a ‚ü∂ b) [LiftHom f] [LiftHom g] where
  Hom : f ‚ü∂ g
  [IsIso : IsIso hom]
#align category_theory.bicategory.bicategorical_coherence CategoryTheory.Bicategory.BicategoricalCoherence

attribute [instance] bicategorical_coherence.is_iso

namespace BicategoricalCoherence

@[simps]
instance refl (f : a ‚ü∂ b) [LiftHom f] : BicategoricalCoherence f f :=
  ‚ü®ùüô _‚ü©
#align category_theory.bicategory.bicategorical_coherence.refl CategoryTheory.Bicategory.BicategoricalCoherence.refl

@[simps]
instance whiskerLeft (f : a ‚ü∂ b) (g h : b ‚ü∂ c) [LiftHom f] [LiftHom g] [LiftHom h]
    [BicategoricalCoherence g h] : BicategoricalCoherence (f ‚â´ g) (f ‚â´ h) :=
  ‚ü®f ‚óÅ BicategoricalCoherence.hom g h‚ü©
#align category_theory.bicategory.bicategorical_coherence.whisker_left CategoryTheory.Bicategory.BicategoricalCoherence.whiskerLeft

@[simps]
instance whiskerRight (f g : a ‚ü∂ b) (h : b ‚ü∂ c) [LiftHom f] [LiftHom g] [LiftHom h]
    [BicategoricalCoherence f g] : BicategoricalCoherence (f ‚â´ h) (g ‚â´ h) :=
  ‚ü®BicategoricalCoherence.hom f g ‚ñ∑ h‚ü©
#align category_theory.bicategory.bicategorical_coherence.whisker_right CategoryTheory.Bicategory.BicategoricalCoherence.whiskerRight

@[simps]
instance tensorRight (f : a ‚ü∂ b) (g : b ‚ü∂ b) [LiftHom f] [LiftHom g]
    [BicategoricalCoherence (ùüô b) g] : BicategoricalCoherence f (f ‚â´ g) :=
  ‚ü®(œÅ_ f).inv ‚â´ f ‚óÅ BicategoricalCoherence.hom (ùüô b) g‚ü©
#align category_theory.bicategory.bicategorical_coherence.tensor_right CategoryTheory.Bicategory.BicategoricalCoherence.tensorRight

@[simps]
instance tensorRight' (f : a ‚ü∂ b) (g : b ‚ü∂ b) [LiftHom f] [LiftHom g]
    [BicategoricalCoherence g (ùüô b)] : BicategoricalCoherence (f ‚â´ g) f :=
  ‚ü®f ‚óÅ BicategoricalCoherence.hom g (ùüô b) ‚â´ (œÅ_ f).Hom‚ü©
#align category_theory.bicategory.bicategorical_coherence.tensor_right' CategoryTheory.Bicategory.BicategoricalCoherence.tensorRight'

@[simps]
instance left (f g : a ‚ü∂ b) [LiftHom f] [LiftHom g] [BicategoricalCoherence f g] :
    BicategoricalCoherence (ùüô a ‚â´ f) g :=
  ‚ü®(Œª_ f).Hom ‚â´ BicategoricalCoherence.hom f g‚ü©
#align category_theory.bicategory.bicategorical_coherence.left CategoryTheory.Bicategory.BicategoricalCoherence.left

@[simps]
instance left' (f g : a ‚ü∂ b) [LiftHom f] [LiftHom g] [BicategoricalCoherence f g] :
    BicategoricalCoherence f (ùüô a ‚â´ g) :=
  ‚ü®BicategoricalCoherence.hom f g ‚â´ (Œª_ g).inv‚ü©
#align category_theory.bicategory.bicategorical_coherence.left' CategoryTheory.Bicategory.BicategoricalCoherence.left'

@[simps]
instance right (f g : a ‚ü∂ b) [LiftHom f] [LiftHom g] [BicategoricalCoherence f g] :
    BicategoricalCoherence (f ‚â´ ùüô b) g :=
  ‚ü®(œÅ_ f).Hom ‚â´ BicategoricalCoherence.hom f g‚ü©
#align category_theory.bicategory.bicategorical_coherence.right CategoryTheory.Bicategory.BicategoricalCoherence.right

@[simps]
instance right' (f g : a ‚ü∂ b) [LiftHom f] [LiftHom g] [BicategoricalCoherence f g] :
    BicategoricalCoherence f (g ‚â´ ùüô b) :=
  ‚ü®BicategoricalCoherence.hom f g ‚â´ (œÅ_ g).inv‚ü©
#align category_theory.bicategory.bicategorical_coherence.right' CategoryTheory.Bicategory.BicategoricalCoherence.right'

@[simps]
instance assoc (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) (i : a ‚ü∂ d) [LiftHom f] [LiftHom g] [LiftHom h]
    [LiftHom i] [BicategoricalCoherence (f ‚â´ g ‚â´ h) i] : BicategoricalCoherence ((f ‚â´ g) ‚â´ h) i :=
  ‚ü®(Œ±_ f g h).Hom ‚â´ BicategoricalCoherence.hom (f ‚â´ g ‚â´ h) i‚ü©
#align category_theory.bicategory.bicategorical_coherence.assoc CategoryTheory.Bicategory.BicategoricalCoherence.assoc

@[simps]
instance assoc' (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) (i : a ‚ü∂ d) [LiftHom f] [LiftHom g] [LiftHom h]
    [LiftHom i] [BicategoricalCoherence i (f ‚â´ g ‚â´ h)] : BicategoricalCoherence i ((f ‚â´ g) ‚â´ h) :=
  ‚ü®BicategoricalCoherence.hom i (f ‚â´ g ‚â´ h) ‚â´ (Œ±_ f g h).inv‚ü©
#align category_theory.bicategory.bicategorical_coherence.assoc' CategoryTheory.Bicategory.BicategoricalCoherence.assoc'

end BicategoricalCoherence

/-- Construct an isomorphism between two objects in a bicategorical category
out of unitors and associators. -/
def bicategoricalIso (f g : a ‚ü∂ b) [LiftHom f] [LiftHom g] [BicategoricalCoherence f g] : f ‚âÖ g :=
  asIso (BicategoricalCoherence.hom f g)
#align category_theory.bicategory.bicategorical_iso CategoryTheory.Bicategory.bicategoricalIso

/-- Compose two morphisms in a bicategorical category,
inserting unitors and associators between as necessary. -/
def bicategoricalComp {f g h i : a ‚ü∂ b} [LiftHom g] [LiftHom h] [BicategoricalCoherence g h]
    (Œ∑ : f ‚ü∂ g) (Œ∏ : h ‚ü∂ i) : f ‚ü∂ i :=
  Œ∑ ‚â´ BicategoricalCoherence.hom g h ‚â´ Œ∏
#align category_theory.bicategory.bicategorical_comp CategoryTheory.Bicategory.bicategoricalComp

-- mathport name: bicategorical_comp
scoped[Bicategory] infixr:80 " ‚äó‚â´ " => CategoryTheory.Bicategory.bicategoricalComp

-- type as \ot \gg
/-- Compose two isomorphisms in a bicategorical category,
inserting unitors and associators between as necessary. -/
def bicategoricalIsoComp {f g h i : a ‚ü∂ b} [LiftHom g] [LiftHom h] [BicategoricalCoherence g h]
    (Œ∑ : f ‚âÖ g) (Œ∏ : h ‚âÖ i) : f ‚âÖ i :=
  Œ∑ ‚â™‚â´ asIso (BicategoricalCoherence.hom g h) ‚â™‚â´ Œ∏
#align category_theory.bicategory.bicategorical_iso_comp CategoryTheory.Bicategory.bicategoricalIsoComp

-- mathport name: bicategorical_iso_comp
scoped[Bicategory] infixr:80 " ‚â™‚äó‚â´ " => CategoryTheory.Bicategory.bicategoricalIsoComp

-- type as \ot \gg
example {f' : a ‚ü∂ d} {f : a ‚ü∂ b} {g : b ‚ü∂ c} {h : c ‚ü∂ d} {h' : a ‚ü∂ d} (Œ∑ : f' ‚ü∂ f ‚â´ g ‚â´ h)
    (Œ∏ : (f ‚â´ g) ‚â´ h ‚ü∂ h') : f' ‚ü∂ h' :=
  Œ∑ ‚äó‚â´ Œ∏

-- To automatically insert unitors/associators at the beginning or end,
-- you can use `Œ∑ ‚äó‚â´ ùüô _`
example {f' : a ‚ü∂ d} {f : a ‚ü∂ b} {g : b ‚ü∂ c} {h : c ‚ü∂ d} (Œ∑ : f' ‚ü∂ (f ‚â´ g) ‚â´ h) : f' ‚ü∂ f ‚â´ g ‚â´ h :=
  Œ∑ ‚äó‚â´ ùüô _

@[simp]
theorem bicategoricalComp_refl {f g h : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) (Œ∏ : g ‚ü∂ h) : Œ∑ ‚äó‚â´ Œ∏ = Œ∑ ‚â´ Œ∏ := by
  dsimp [bicategorical_comp]; simp
#align category_theory.bicategory.bicategorical_comp_refl CategoryTheory.Bicategory.bicategoricalComp_refl

end CategoryTheory.Bicategory

open CategoryTheory.Bicategory

namespace Tactic

/- ./././Mathport/Syntax/Translate/Tactic/Mathlib/Core.lean:38:34: unsupported: setup_tactic_parser -/
/- ./././Mathport/Syntax/Translate/Expr.lean:330:4: warning: unsupported (TODO): `[tacs] -/
-- failed to format: unknown constant 'term.pseudo.antiquot'
/-- Coherence tactic for bicategories. -/ unsafe
  def
    bicategorical_coherence
    : tactic Unit
    :=
      focus1
        do
          let o ‚Üê get_options
            set_options <| o `class.instance_max_depth 128
            try sorry
            let q( $ ( lhs ) = $ ( rhs ) ) ‚Üê target
            to_expr
                `
                  `(
                    ( FreeBicategory.lift ( Prefunctor.id _ ) ) . zipWith
                        ( LiftHom‚ÇÇ.lift $ ( lhs ) )
                      =
                      ( FreeBicategory.lift ( Prefunctor.id _ ) ) . zipWith
                        ( LiftHom‚ÇÇ.lift $ ( rhs ) )
                    )
              >>=
              tactic.change
            congr
#align tactic.bicategorical_coherence tactic.bicategorical_coherence

namespace Bicategory

/- ./././Mathport/Syntax/Translate/Expr.lean:330:4: warning: unsupported (TODO): `[tacs] -/
/-- Simp lemmas for rewriting a 2-morphism into a normal form. -/
unsafe def whisker_simps : tactic Unit :=
  sorry
#align tactic.bicategory.whisker_simps tactic.bicategory.whisker_simps

namespace Coherence

-- We have unused typeclass arguments here.
-- They are intentional, to ensure that `simp only [assoc_lift_hom‚ÇÇ]` only left associates
-- bicategorical structural morphisms.
/-- Auxiliary simp lemma for the `coherence` tactic:
this move brackets to the left in order to expose a maximal prefix
built out of unitors and associators.
-/
@[nolint unused_arguments]
theorem assoc_liftHom‚ÇÇ {f g h i : a ‚ü∂ b} [LiftHom f] [LiftHom g] [LiftHom h] (Œ∑ : f ‚ü∂ g) (Œ∏ : g ‚ü∂ h)
    (Œπ : h ‚ü∂ i) [LiftHom‚ÇÇ Œ∑] [LiftHom‚ÇÇ Œ∏] : Œ∑ ‚â´ Œ∏ ‚â´ Œπ = (Œ∑ ‚â´ Œ∏) ‚â´ Œπ :=
  (Category.assoc _ _ _).symm
#align tactic.bicategory.coherence.assoc_lift_hom‚ÇÇ Tactic.Bicategory.Coherence.assoc_liftHom‚ÇÇ

end Coherence

end Bicategory

end Tactic

