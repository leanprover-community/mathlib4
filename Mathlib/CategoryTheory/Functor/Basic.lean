/-
Copyright (c) 2017 Kim Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Tim Baumann, Stephen Morgan, Kim Morrison
-/
import Mathlib.CategoryTheory.Category.Basic
import Mathlib.Combinatorics.Quiver.Prefunctor
import Mathlib.Tactic.CategoryTheory.CheckCompositions

/-!
# Functors

Defines a functor between categories, extending a `Prefunctor` between quivers.

Introduces, in the `CategoryTheory` scope, notations `C â¥¤ D` for the type of all functors
from `C` to `D`, `ğŸ­` for the identity functor and `â‹™` for functor composition.

TODO: Switch to using the `â‡’` arrow.
-/

set_option mathlib.tactic.category.grind true

namespace CategoryTheory

-- declare the `v`'s first; see note [CategoryTheory universes].
universe v vâ‚ vâ‚‚ vâ‚ƒ u uâ‚ uâ‚‚ uâ‚ƒ

section

/-- `Functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id` expresses preservation of identities, and
`map_comp` expresses functoriality. -/
@[stacks 001B]
structure Functor (C : Type uâ‚) [Category.{vâ‚} C] (D : Type uâ‚‚) [Category.{vâ‚‚} D] :
    Type max vâ‚ vâ‚‚ uâ‚ uâ‚‚ where
  /-- The action of a functor on objects. -/
  obj : C â†’ D
  /-- The action of a functor on morphisms. -/
  map : âˆ€ {X Y : C}, (X âŸ¶ Y) â†’ ((obj X) âŸ¶ (obj Y))
  /-- A functor preserves identity morphisms. -/
  map_id : âˆ€ X : C, map (ğŸ™ X) = ğŸ™ (obj X) := by cat_disch
  /-- A functor preserves composition. -/
  map_comp : âˆ€ {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z), map (f â‰« g) = map f â‰« map g := by cat_disch

end

/-- Notation for a functor between categories. -/
-- A functor is basically a function, so give â¥¤ a similar precedence to â†’ (25).
-- For example, `C Ã— D â¥¤ E` should parse as `(C Ã— D) â¥¤ E` not `C Ã— (D â¥¤ E)`.
scoped [CategoryTheory] infixr:26 " â¥¤ " => Functor -- type as \func

attribute [simp] Functor.map_id Functor.map_comp
attribute [grind =] Functor.map_id
attribute [grind _=_] Functor.map_comp

-- Note: We manually add this lemma which could be generated by `reassoc`,
-- since we will import this file into `Mathlib/Tactic/Reassoc.lean`.
lemma Functor.map_comp_assoc {C : Type uâ‚} [Category C] {D : Type uâ‚‚} [Category D] (F : C â¥¤ D)
    {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) {W : D} (h : F.obj Z âŸ¶ W) :
    (F.map (f â‰« g)) â‰« h = F.map f â‰« F.map g â‰« h := by
  grind

namespace Functor

section

variable (C : Type uâ‚) [Category.{vâ‚} C]

initialize_simps_projections Functor

-- We don't use `@[simps]` here because we want `C` implicit for the simp lemmas.
/-- `ğŸ­ C` is the identity functor on a category `C`. -/
protected def id : C â¥¤ C where
  obj X := X
  map f := f

/-- Notation for the identity functor on a category. -/
scoped [CategoryTheory] notation "ğŸ­" => Functor.id -- Type this as `\sb1`

instance : Inhabited (C â¥¤ C) :=
  âŸ¨Functor.id CâŸ©

variable {C}

@[simp, grind =]
theorem id_obj (X : C) : (ğŸ­ C).obj X = X := rfl

@[simp, grind =]
theorem id_map {X Y : C} (f : X âŸ¶ Y) : (ğŸ­ C).map f = f := rfl

end

section

variable {C : Type uâ‚} [Category.{vâ‚} C] {D : Type uâ‚‚} [Category.{vâ‚‚} D]
  {E : Type uâ‚ƒ} [Category.{vâ‚ƒ} E]

/-- The prefunctor between the underlying quivers. -/
@[simps]
def toPrefunctor (F : C â¥¤ D) : Prefunctor C D := { F with }

theorem congr_map (F : C â¥¤ D) {X Y : C} {f g : X âŸ¶ Y}
    (h : f = g) : F.map f = F.map g := by
  rw [h]

/-- `F â‹™ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).
-/
@[simps (attr := grind =) obj]
def comp (F : C â¥¤ D) (G : D â¥¤ E) : C â¥¤ E where
  obj X := G.obj (F.obj X)
  map f := G.map (F.map f)

/-- Notation for composition of functors. -/
scoped [CategoryTheory] infixr:80 " â‹™ " => Functor.comp

@[simp, grind =]
theorem comp_map (F : C â¥¤ D) (G : D â¥¤ E) {X Y : C} (f : X âŸ¶ Y) :
    (F â‹™ G).map f = G.map (F.map f) := rfl

-- These are not simp lemmas because rewriting along equalities between functors
-- is not necessarily a good idea.
-- Natural isomorphisms are also provided in `Whiskering.lean`.
protected theorem comp_id (F : C â¥¤ D) : F â‹™ ğŸ­ D = F := by cases F; rfl

protected theorem id_comp (F : C â¥¤ D) : ğŸ­ C â‹™ F = F := by cases F; rfl

@[simp]
theorem map_dite (F : C â¥¤ D) {X Y : C} {P : Prop} [Decidable P]
    (f : P â†’ (X âŸ¶ Y)) (g : Â¬P â†’ (X âŸ¶ Y)) :
    F.map (if h : P then f h else g h) = if h : P then F.map (f h) else F.map (g h) := by
  cat_disch

@[simp]
theorem toPrefunctor_comp (F : C â¥¤ D) (G : D â¥¤ E) :
    F.toPrefunctor.comp G.toPrefunctor = (F â‹™ G).toPrefunctor := rfl

end

end Functor

end CategoryTheory
