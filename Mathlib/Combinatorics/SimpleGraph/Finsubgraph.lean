/-
Copyright (c) 2022 Joanna Choules. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joanna Choules
-/
import Mathlib.CategoryTheory.CofilteredSystem
import Mathlib.Combinatorics.SimpleGraph.Subgraph

#align_import combinatorics.simple_graph.finsubgraph from "leanprover-community/mathlib"@"c6ef6387ede9983aee397d442974e61f89dfd87b"

/-!
# Homomorphisms from finite subgraphs

This file defines the type of finite subgraphs of a `SimpleGraph` and proves a compactness result
for homomorphisms to a finite codomain.

## Main statements

* `SimpleGraph.nonempty_hom_of_forall_finite_subgraph_hom`: If every finite subgraph of a (possibly
  infinite) graph `G` has a homomorphism to some finite graph `F`, then there is also a homomorphism
  `G ‚Üíg F`.

## Notations

`‚Üífg` is a module-local variant on `‚Üíg` where the domain is a finite subgraph of some supergraph
`G`.

## Implementation notes

The proof here uses compactness as formulated in `nonempty_sections_of_finite_inverse_system`. For
finite subgraphs `G'' ‚â§ G'`, the inverse system `finsubgraphHomFunctor` restricts homomorphisms
`G' ‚Üífg F` to domain `G''`.
-/


open Set CategoryTheory

universe u v

variable {V : Type u} {W : Type v} {G : SimpleGraph V} {F : SimpleGraph W}

namespace SimpleGraph

/-- The subtype of `G.subgraph` comprising those subgraphs with finite vertex sets. -/
abbrev Finsubgraph (G : SimpleGraph V) :=
  { G' : G.Subgraph // G'.verts.Finite }
#align simple_graph.finsubgraph SimpleGraph.Finsubgraph

/-- A graph homomorphism from a finite subgraph of G to F. -/
abbrev FinsubgraphHom (G' : G.Finsubgraph) (F : SimpleGraph W) :=
  G'.val.coe ‚Üíg F
#align simple_graph.finsubgraph_hom SimpleGraph.FinsubgraphHom

local infixl:50 " ‚Üífg " => FinsubgraphHom

instance : OrderBot G.Finsubgraph where
  bot := ‚ü®‚ä•, finite_empty‚ü©
  bot_le _ := bot_le (Œ± := G.Subgraph)

instance : Sup G.Finsubgraph :=
  ‚ü®fun G‚ÇÅ G‚ÇÇ => ‚ü®G‚ÇÅ ‚äî G‚ÇÇ, G‚ÇÅ.2.union G‚ÇÇ.2‚ü©‚ü©

instance : Inf G.Finsubgraph :=
  ‚ü®fun G‚ÇÅ G‚ÇÇ => ‚ü®G‚ÇÅ ‚äì G‚ÇÇ, G‚ÇÅ.2.subset <| inter_subset_left _ _‚ü©‚ü©

instance : DistribLattice G.Finsubgraph :=
  Subtype.coe_injective.distribLattice _ (fun _ _ => rfl) fun _ _ => rfl

instance [Finite V] : Top G.Finsubgraph :=
  ‚ü®‚ü®‚ä§, finite_univ‚ü©‚ü©

instance [Finite V] : SupSet G.Finsubgraph :=
  ‚ü®fun s => ‚ü®‚®Ü G ‚àà s, ‚ÜëG, Set.toFinite _‚ü©‚ü©

instance [Finite V] : InfSet G.Finsubgraph :=
  ‚ü®fun s => ‚ü®‚®Ö G ‚àà s, ‚ÜëG, Set.toFinite _‚ü©‚ü©

instance [Finite V] : CompletelyDistribLattice G.Finsubgraph :=
  Subtype.coe_injective.completelyDistribLattice _ (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl)
    (fun _ => rfl) rfl rfl

/-- The finite subgraph of G generated by a single vertex. -/
def singletonFinsubgraph (v : V) : G.Finsubgraph :=
  ‚ü®SimpleGraph.singletonSubgraph _ v, by simp‚ü©
                                         -- üéâ no goals
#align simple_graph.singleton_finsubgraph SimpleGraph.singletonFinsubgraph

/-- The finite subgraph of G generated by a single edge. -/
def finsubgraphOfAdj {u v : V} (e : G.Adj u v) : G.Finsubgraph :=
  ‚ü®SimpleGraph.subgraphOfAdj _ e, by simp‚ü©
                                     -- üéâ no goals
#align simple_graph.finsubgraph_of_adj SimpleGraph.finsubgraphOfAdj

-- Lemmas establishing the ordering between edge- and vertex-generated subgraphs.
theorem singletonFinsubgraph_le_adj_left {u v : V} {e : G.Adj u v} :
    singletonFinsubgraph u ‚â§ finsubgraphOfAdj e := by
  simp [singletonFinsubgraph, finsubgraphOfAdj]
  -- üéâ no goals
#align simple_graph.singleton_finsubgraph_le_adj_left SimpleGraph.singletonFinsubgraph_le_adj_left

theorem singletonFinsubgraph_le_adj_right {u v : V} {e : G.Adj u v} :
    singletonFinsubgraph v ‚â§ finsubgraphOfAdj e := by
  simp [singletonFinsubgraph, finsubgraphOfAdj]
  -- üéâ no goals
#align simple_graph.singleton_finsubgraph_le_adj_right SimpleGraph.singletonFinsubgraph_le_adj_right

/-- Given a homomorphism from a subgraph to `F`, construct its restriction to a sub-subgraph. -/
def FinsubgraphHom.restrict {G' G'' : G.Finsubgraph} (h : G'' ‚â§ G') (f : G' ‚Üífg F) : G'' ‚Üífg F := by
  refine' ‚ü®fun ‚ü®v, hv‚ü© => f.toFun ‚ü®v, h.1 hv‚ü©, _‚ü©
  -- ‚ä¢ ‚àÄ {a b : ‚Üë(‚ÜëG'').verts},
  rintro ‚ü®u, hu‚ü© ‚ü®v, hv‚ü© huv
  -- ‚ä¢ Adj F
  exact f.map_rel' (h.2 huv)
  -- üéâ no goals
#align simple_graph.finsubgraph_hom.restrict SimpleGraph.FinsubgraphHom.restrict

/-- The inverse system of finite homomorphisms. -/
def finsubgraphHomFunctor (G : SimpleGraph V) (F : SimpleGraph W) : G.Finsubgraph·µí·µñ ‚•§ Type max u v
    where
  obj G' := G'.unop ‚Üífg F
  map g f := f.restrict (CategoryTheory.leOfHom g.unop)
#align simple_graph.finsubgraph_hom_functor SimpleGraph.finsubgraphHomFunctor

/-- If every finite subgraph of a graph `G` has a homomorphism to a finite graph `F`, then there is
a homomorphism from the whole of `G` to `F`. -/
theorem nonempty_hom_of_forall_finite_subgraph_hom [Finite W]
    (h : ‚àÄ G' : G.Subgraph, G'.verts.Finite ‚Üí G'.coe ‚Üíg F) : Nonempty (G ‚Üíg F) := by
  -- Obtain a `Fintype` instance for `W`.
  cases nonempty_fintype W
  -- ‚ä¢ Nonempty (G ‚Üíg F)
  -- Establish the required interface instances.
  haveI : ‚àÄ G' : G.Finsubgraph·µí·µñ, Nonempty ((finsubgraphHomFunctor G F).obj G') := fun G' =>
    ‚ü®h G'.unop G'.unop.property‚ü©
  haveI : ‚àÄ G' : G.Finsubgraph·µí·µñ, Fintype ((finsubgraphHomFunctor G F).obj G') := by
    intro G'
    haveI : Fintype (G'.unop.val.verts : Type u) := G'.unop.property.fintype
    haveI : Fintype (‚Ü•G'.unop.val.verts ‚Üí W) := by classical exact Pi.fintype
    exact Fintype.ofInjective (fun f => f.toFun) RelHom.coe_fn_injective
  -- Use compactness to obtain a section.
  obtain ‚ü®u, hu‚ü© := nonempty_sections_of_finite_inverse_system (finsubgraphHomFunctor G F)
  -- ‚ä¢ Nonempty (G ‚Üíg F)
  refine' ‚ü®‚ü®fun v => _, _‚ü©‚ü©
  -- ‚ä¢ W
  ¬∑ -- Map each vertex using the homomorphism provided for its singleton subgraph.
    exact
      (u (Opposite.op (singletonFinsubgraph v))).toFun
        ‚ü®v, by
          unfold singletonFinsubgraph
          simp‚ü©
  ¬∑ -- Prove that the above mapping preserves adjacency.
    intro v v' e
    -- ‚ä¢ Adj F ((fun v => RelHom.toFun (u (Opposite.op (singletonFinsubgraph v))) { v ‚Ä¶
    simp only
    -- ‚ä¢ Adj F (RelHom.toFun (u (Opposite.op (singletonFinsubgraph v))) { val := v, p ‚Ä¶
    /- The homomorphism for each edge's singleton subgraph agrees with those for its source and
        target vertices. -/
    have hv : Opposite.op (finsubgraphOfAdj e) ‚ü∂ Opposite.op (singletonFinsubgraph v) :=
      Quiver.Hom.op (CategoryTheory.homOfLE singletonFinsubgraph_le_adj_left)
    have hv' : Opposite.op (finsubgraphOfAdj e) ‚ü∂ Opposite.op (singletonFinsubgraph v') :=
      Quiver.Hom.op (CategoryTheory.homOfLE singletonFinsubgraph_le_adj_right)
    rw [‚Üê hu hv, ‚Üê hu hv']
    -- ‚ä¢ Adj F (RelHom.toFun ((finsubgraphHomFunctor G F).map hv (u (Opposite.op (fin ‚Ä¶
    -- porting note: was `apply Hom.map_adj`
    refine' Hom.map_adj (u (Opposite.op (finsubgraphOfAdj e))) _
    -- ‚ä¢ Adj (Subgraph.coe ‚Üë(Opposite.op (finsubgraphOfAdj e)).unop) { val := v, prop ‚Ä¶
    -- `v` and `v'` are definitionally adjacent in `finsubgraphOfAdj e`
    simp [finsubgraphOfAdj]
    -- üéâ no goals
#align simple_graph.nonempty_hom_of_forall_finite_subgraph_hom SimpleGraph.nonempty_hom_of_forall_finite_subgraph_hom

end SimpleGraph
