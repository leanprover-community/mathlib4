/-
Copyright (c) 2022 Ya√´l Dillies, Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Ya√´l Dillies, Bhavik Mehta
-/
import Mathlib.Algebra.GroupPower.Order
import Mathlib.Algebra.Order.Field.Defs
import Mathlib.Combinatorics.Enumerative.DoubleCounting
import Mathlib.Combinatorics.SimpleGraph.Clique
import Mathlib.Tactic.GCongr
import Mathlib.Tactic.Positivity

#align_import combinatorics.SimpleGraph.triangle.basic from "leanprover-community/mathlib"@"3365b20c2ffa7c35e47e5209b89ba9abdddf3ffe"

/-!
# Triangles in graphs

A *triangle* in a simple graph is a `3`-clique, namely a Set of three vertices that are
pairwise adjacent.

This module defines and proves properties about triangles in simple graphs.

## Main declarations

* `SimpleGraph.FarFromTriangleFree`: Predicate for a graph such that one must remove a lot of edges
  from it for it to become triangle-free. This is the crux of the Triangle Removal Lemma.

## TODO

* Generalise `FarFromTriangleFree` to other graphs, to state and prove the Graph Removal Lemma.
-/

open Finset Nat
open Fintype (card)

namespace SimpleGraph

variable {Œ± Œ≤ ùïú : Type*} [LinearOrderedField ùïú] {G H : SimpleGraph Œ±} {Œµ Œ¥ : ùïú} {n : ‚Ñï}
  {s : Finset Œ±}

section LocallyLinear

/-- A graph has edge-disjoint triangles if each edge belongs to at most one triangle. -/
def EdgeDisjointTriangles (G : SimpleGraph Œ±) : Prop :=
  (G.cliqueSet 3).Pairwise fun x y ‚Ü¶ (x ‚à© y : Set Œ±).Subsingleton

/-- A graph is locally linear if each edge belongs to exactly one triangle. -/
def LocallyLinear (G : SimpleGraph Œ±) : Prop :=
  G.EdgeDisjointTriangles ‚àß ‚àÄ ‚¶Éx y‚¶Ñ, G.Adj x y ‚Üí ‚àÉ s, G.IsNClique 3 s ‚àß x ‚àà s ‚àß y ‚àà s

protected lemma LocallyLinear.edgeDisjointTriangles : G.LocallyLinear ‚Üí G.EdgeDisjointTriangles :=
  And.left

nonrec lemma EdgeDisjointTriangles.mono (h : G ‚â§ H) (hH : H.EdgeDisjointTriangles) :
    G.EdgeDisjointTriangles := hH.mono $ cliqueSet_mono h

@[simp] lemma edgeDisjointTriangles_bot : (‚ä• : SimpleGraph Œ±).EdgeDisjointTriangles := by
  simp [EdgeDisjointTriangles]

@[simp] lemma locallyLinear_bot : (‚ä• : SimpleGraph Œ±).LocallyLinear := by simp [LocallyLinear]

lemma EdgeDisjointTriangles.map (f : Œ± ‚Ü™ Œ≤) (hG : G.EdgeDisjointTriangles) :
    (G.map f).EdgeDisjointTriangles := by
  rw [EdgeDisjointTriangles, cliqueSet_map (by norm_num : 3 ‚â† 1),
    ((Finset.map_injective f).injOn _).pairwise_image]
  classical
  rintro s hs t ht hst
  dsimp [Function.onFun]
  rw [‚Üê coe_inter, ‚Üê map_inter, coe_map, coe_inter]
  exact (hG hs ht hst).image _

lemma LocallyLinear.map (f : Œ± ‚Ü™ Œ≤) (hG : G.LocallyLinear) : (G.map f).LocallyLinear := by
  refine ‚ü®hG.1.map _, ?_‚ü©
  rintro _ _ ‚ü®a, b, h, rfl, rfl‚ü©
  obtain ‚ü®s, hs, ha, hb‚ü© := hG.2 h
  exact ‚ü®s.map f, hs.map, mem_map_of_mem _ ha, mem_map_of_mem _ hb‚ü©

@[simp] lemma locallyLinear_comap {G : SimpleGraph Œ≤} {e : Œ± ‚âÉ Œ≤} :
    (G.comap e).LocallyLinear ‚Üî G.LocallyLinear := by
  refine ‚ü®fun h ‚Ü¶ ?_, ?_‚ü©
  ¬∑ rw [‚Üê comap_map_eq e.symm.toEmbedding G, comap_symm, map_symm]
    exact h.map _
  ¬∑ rw [‚Üê Equiv.coe_toEmbedding, ‚Üê map_symm]
    exact LocallyLinear.map _

variable [DecidableEq Œ±]

lemma edgeDisjointTriangles_iff_mem_sym2_subsingleton :
    G.EdgeDisjointTriangles ‚Üî
      ‚àÄ ‚¶Ée : Sym2 Œ±‚¶Ñ, ¬¨ e.IsDiag ‚Üí {s ‚àà G.cliqueSet 3 | e ‚àà (s : Finset Œ±).sym2}.Subsingleton := by
  have (a b) (hab : a ‚â† b) : {s ‚àà (G.cliqueSet 3 : Set (Finset Œ±)) | s(a, b) ‚àà (s : Finset Œ±).sym2}
    = {s | G.Adj a b ‚àß ‚àÉ c, G.Adj a c ‚àß G.Adj b c ‚àß s = {a, b, c}} := by
    ext s
    simp only [mem_sym2_iff, Sym2.mem_iff, forall_eq_or_imp, forall_eq, Set.sep_and,
      Set.mem_inter_iff, Set.mem_sep_iff, mem_cliqueSet_iff, Set.mem_setOf_eq,
      and_and_and_comm (b := _ ‚àà _), and_self, is3Clique_iff]
    constructor
    ¬∑ rintro ‚ü®‚ü®c, d, e, hcd, hce, hde, rfl‚ü©, hab‚ü©
      simp only [mem_insert, mem_singleton] at hab
      obtain ‚ü®rfl | rfl | rfl, rfl | rfl | rfl‚ü© := hab
      any_goals
        simp only [*, adj_comm, true_and, Ne, eq_self_iff_true, not_true] at *
      any_goals
        first
        | exact ‚ü®c, by aesop‚ü©
        | exact ‚ü®d, by aesop‚ü©
        | exact ‚ü®e, by aesop‚ü©
        | simp only [*, adj_comm, true_and, Ne, eq_self_iff_true, not_true] at *
          exact ‚ü®c, by aesop‚ü©
        | simp only [*, adj_comm, true_and, Ne, eq_self_iff_true, not_true] at *
          exact ‚ü®d, by aesop‚ü©
        | simp only [*, adj_comm, true_and, Ne, eq_self_iff_true, not_true] at *
          exact ‚ü®e, by aesop‚ü©
    ¬∑ rintro ‚ü®hab, c, hac, hbc, rfl‚ü©
      refine ‚ü®‚ü®a, b, c, ?_‚ü©, ?_‚ü© <;> simp [*]
  constructor
  ¬∑ rw [Sym2.forall]
    rintro hG a b hab
    simp only [Sym2.isDiag_iff_proj_eq] at hab
    rw [this _ _ (Sym2.mk_isDiag_iff.not.2 hab)]
    rintro _ ‚ü®hab, c, hac, hbc, rfl‚ü© _ ‚ü®-, d, had, hbd, rfl‚ü©
    refine hG.eq ?_ ?_ (Set.Nontrivial.not_subsingleton ‚ü®a, ?_, b, ?_, hab.ne‚ü©) <;>
      simp [is3Clique_triple_iff, *]
  ¬∑ simp only [EdgeDisjointTriangles, is3Clique_iff, Set.Pairwise, mem_cliqueSet_iff, Ne,
      forall_exists_index, and_imp, ‚Üê Set.not_nontrivial_iff (s := _ ‚à© _), not_imp_not,
      Set.Nontrivial, Set.mem_inter_iff, mem_coe]
    rintro hG _ a b c hab hac hbc rfl _ d e f hde hdf hef rfl g hg‚ÇÅ hg‚ÇÇ h hh‚ÇÅ hh‚ÇÇ hgh
    save
    refine hG (Sym2.mk_isDiag_iff.not.2 hgh) ‚ü®‚ü®a, b, c, ?_‚ü©, by simpa using And.intro hg‚ÇÅ hh‚ÇÅ‚ü©
      ‚ü®‚ü®d, e, f, ?_‚ü©, by simpa using And.intro hg‚ÇÇ hh‚ÇÇ‚ü© <;> simp [is3Clique_triple_iff, *]

alias ‚ü®EdgeDisjointTriangles.mem_sym2_subsingleton, _‚ü© :=
  edgeDisjointTriangles_iff_mem_sym2_subsingleton

variable [Fintype Œ±] [DecidableRel G.Adj]

instance EdgeDisjointTriangles.instDecidable : Decidable G.EdgeDisjointTriangles :=
  decidable_of_iff ((G.cliqueFinset 3 : Set (Finset Œ±)).Pairwise fun x y ‚Ü¶ ((x ‚à© y).card ‚â§ 1)) $ by
    simp only [coe_cliqueFinset, EdgeDisjointTriangles, Finset.card_le_one, ‚Üê coe_inter]; rfl

instance LocallyLinear.instDecidable : Decidable G.LocallyLinear := And.decidable

lemma EdgeDisjointTriangles.card_edgeFinset_le (hG : G.EdgeDisjointTriangles) :
    3 * (G.cliqueFinset 3).card ‚â§ G.edgeFinset.card := by
  rw [mul_comm, ‚Üê mul_one G.edgeFinset.card]
  refine card_mul_le_card_mul (fun s e ‚Ü¶ e ‚àà s.sym2) ?_ (fun e he ‚Ü¶ ?_)
  ¬∑ simp only [is3Clique_iff, mem_cliqueFinset_iff, mem_sym2_iff, forall_exists_index, and_imp]
    rintro _ a b c hab hac hbc rfl
    have : Finset.card ({s(a, b), s(a, c), s(b, c)} : Finset (Sym2 Œ±)) = 3 := by
      refine card_eq_three.2 ‚ü®_, _, _, ?_, ?_, ?_, rfl‚ü© <;> simp [hab.ne, hac.ne, hbc.ne]
    rw [‚Üê this]
    refine card_mono ?_
    simp [insert_subset, *]
  ¬∑ simpa only [card_le_one, mem_bipartiteBelow, and_imp, Set.Subsingleton, Set.mem_setOf_eq,
      mem_cliqueFinset_iff, mem_cliqueSet_iff]
      using hG.mem_sym2_subsingleton (G.not_isDiag_of_mem_edgeSet $ mem_edgeFinset.1 he)

lemma LocallyLinear.card_edgeFinset (hG : G.LocallyLinear) :
    G.edgeFinset.card = 3 * (G.cliqueFinset 3).card := by
  refine hG.edgeDisjointTriangles.card_edgeFinset_le.antisymm' ?_
  rw [‚Üê mul_comm, ‚Üê mul_one (Finset.card _)]
  refine card_mul_le_card_mul (fun e s ‚Ü¶ e ‚àà s.sym2) ?_ ?_
  ¬∑ simpa [Sym2.forall, Nat.one_le_iff_ne_zero, -card_eq_zero, card_ne_zero, Finset.Nonempty]
      using hG.2
  simp only [mem_cliqueFinset_iff, is3Clique_iff, forall_exists_index, and_imp]
  rintro _ a b c hab hac hbc rfl
  calc
    _ ‚â§ ({s(a, b), s(a, c), s(b, c)} : Finset _).card := card_le_card ?_
    _ ‚â§ 3 := (card_insert_le _ _).trans (succ_le_succ $ (card_insert_le _ _).trans_eq $ by
      rw [card_singleton])
  simp only [subset_iff, Sym2.forall, mem_sym2_iff, le_eq_subset, mem_bipartiteBelow, mem_insert,
    mem_edgeFinset, mem_singleton, and_imp, mem_edgeSet, Sym2.mem_iff, forall_eq_or_imp,
    forall_eq, Quotient.eq, Sym2.rel_iff]
  rintro d e hde (rfl | rfl | rfl) (rfl | rfl | rfl) <;> simp [*] at *

end LocallyLinear

variable (G Œµ)
variable [Fintype Œ±] [DecidableEq Œ±] [DecidableRel G.Adj] [DecidableRel H.Adj]

/-- A simple graph is *`Œµ`-far from triangle-free* if one must remove at least
`Œµ * (card Œ±) ^ 2` edges to make it triangle-free. -/
def FarFromTriangleFree : Prop := G.DeleteFar (fun H ‚Ü¶ H.CliqueFree 3) <| Œµ * (card Œ± ^ 2 : ‚Ñï)
#align simple_graph.far_from_triangle_free SimpleGraph.FarFromTriangleFree

variable {G Œµ}

theorem farFromTriangleFree_iff :
    G.FarFromTriangleFree Œµ ‚Üî ‚àÄ ‚¶ÉH : SimpleGraph Œ±‚¶Ñ, [DecidableRel H.Adj] ‚Üí H ‚â§ G ‚Üí H.CliqueFree 3 ‚Üí
      Œµ * (card Œ± ^ 2 : ‚Ñï) ‚â§ G.edgeFinset.card - H.edgeFinset.card := deleteFar_iff
#align simple_graph.far_from_triangle_free_iff SimpleGraph.farFromTriangleFree_iff

alias ‚ü®farFromTriangleFree.le_card_sub_card, _‚ü© := farFromTriangleFree_iff
#align simple_graph.far_from_triangle_free.le_card_sub_card SimpleGraph.farFromTriangleFree.le_card_sub_card

nonrec theorem FarFromTriangleFree.mono (hŒµ : G.FarFromTriangleFree Œµ) (h : Œ¥ ‚â§ Œµ) :
    G.FarFromTriangleFree Œ¥ := hŒµ.mono <| by gcongr
#align simple_graph.far_from_triangle_free.mono SimpleGraph.FarFromTriangleFree.mono

theorem FarFromTriangleFree.cliqueFinset_nonempty' (hH : H ‚â§ G) (hG : G.FarFromTriangleFree Œµ)
    (hcard : (G.edgeFinset.card - H.edgeFinset.card : ùïú) < Œµ * (card Œ± ^ 2 : ‚Ñï)) :
    (H.cliqueFinset 3).Nonempty :=
  nonempty_of_ne_empty <|
    cliqueFinset_eq_empty_iff.not.2 fun hH' => (hG.le_card_sub_card hH hH').not_lt hcard
#align simple_graph.far_from_triangle_free.clique_finset_nonempty' SimpleGraph.FarFromTriangleFree.cliqueFinset_nonempty'

variable [Nonempty Œ±]

theorem FarFromTriangleFree.nonpos (h‚ÇÄ : G.FarFromTriangleFree Œµ) (h‚ÇÅ : G.CliqueFree 3) :
    Œµ ‚â§ 0 := by
  have := h‚ÇÄ (empty_subset _)
  rw [coe_empty, Finset.card_empty, cast_zero, deleteEdges_empty_eq] at this
  exact nonpos_of_mul_nonpos_left (this h‚ÇÅ) (cast_pos.2 <| sq_pos_of_pos Fintype.card_pos)
#align simple_graph.far_from_triangle_free.nonpos SimpleGraph.FarFromTriangleFree.nonpos

theorem CliqueFree.not_farFromTriangleFree (hG : G.CliqueFree 3) (hŒµ : 0 < Œµ) :
    ¬¨G.FarFromTriangleFree Œµ := fun h => (h.nonpos hG).not_lt hŒµ
#align simple_graph.clique_free.not_far_from_triangle_free SimpleGraph.CliqueFree.not_farFromTriangleFree

theorem FarFromTriangleFree.not_cliqueFree (hG : G.FarFromTriangleFree Œµ) (hŒµ : 0 < Œµ) :
    ¬¨G.CliqueFree 3 := fun h => (hG.nonpos h).not_lt hŒµ
#align simple_graph.far_from_triangle_free.not_clique_free SimpleGraph.FarFromTriangleFree.not_cliqueFree

theorem FarFromTriangleFree.cliqueFinset_nonempty (hG : G.FarFromTriangleFree Œµ) (hŒµ : 0 < Œµ) :
    (G.cliqueFinset 3).Nonempty :=
  nonempty_of_ne_empty <| cliqueFinset_eq_empty_iff.not.2 <| hG.not_cliqueFree hŒµ
#align simple_graph.far_from_triangle_free.clique_finset_nonempty SimpleGraph.FarFromTriangleFree.cliqueFinset_nonempty

end SimpleGraph
