/-
Copyright (c) 2022 JoÃ«l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: JoÃ«l Riou
-/
import Mathlib.AlgebraicTopology.DoldKan.Decomposition
import Mathlib.Tactic.FinCases

#align_import algebraic_topology.dold_kan.degeneracies from "leanprover-community/mathlib"@"32a7e535287f9c73f2e4d2aef306a39190f0b504"

/-!

# Behaviour of P_infty with respect to degeneracies

For any `X : SimplicialObject C` where `C` is an abelian category,
the projector `PInfty : K[X] âŸ¶ K[X]` is supposed to be the projection
on the normalized subcomplex, parallel to the degenerate subcomplex, i.e.
the subcomplex generated by the images of all `X.Ïƒ i`.

In this file, we obtain `degeneracy_comp_P_infty` which states that
if `X : SimplicialObject C` with `C` a preadditive category,
`Î¸ : [n] âŸ¶ Î”'` is a non injective map in `SimplexCategory`, then
`X.map Î¸.op â‰« P_infty.f n = 0`. It follows from the more precise
statement vanishing statement `Ïƒ_comp_P_eq_zero` for the `P q`.

(See `Equivalence.lean` for the general strategy of proof of the Dold-Kan equivalence.)

-/


open CategoryTheory CategoryTheory.Category CategoryTheory.Limits
  CategoryTheory.Preadditive Simplicial

namespace AlgebraicTopology

namespace DoldKan

variable {C : Type*} [Category C] [Preadditive C]

theorem HigherFacesVanish.comp_Ïƒ {Y : C} {X : SimplicialObject C} {n b q : â„•} {Ï† : Y âŸ¶ X _[n + 1]}
    (v : HigherFacesVanish q Ï†) (hnbq : n + 1 = b + q) :
    HigherFacesVanish q
      (Ï† â‰«
        X.Ïƒ âŸ¨b, by
          simp only [hnbq, Nat.lt_add_one_iff, le_add_iff_nonneg_right, zero_le]âŸ©) :=
          -- ðŸŽ‰ no goals
  fun j hj => by
  rw [assoc, SimplicialObject.Î´_comp_Ïƒ_of_gt', Fin.pred_succ, v.comp_Î´_eq_zero_assoc _ _ hj,
    zero_comp]
  Â· dsimp
    -- âŠ¢ { val := b + 1, isLt := (_ : Nat.succ b < Nat.succ (n + 2)) } < Fin.succ j
    rw [Fin.lt_iff_val_lt_val, Fin.val_succ]
    -- âŠ¢ â†‘{ val := b + 1, isLt := (_ : Nat.succ b < Nat.succ (n + 2)) } < â†‘j + 1
    linarith
    -- ðŸŽ‰ no goals
  Â· intro hj'
    -- âŠ¢ False
    simp only [hnbq, add_comm b, add_assoc, hj', Fin.val_zero, zero_add, add_le_iff_nonpos_right,
      nonpos_iff_eq_zero, add_eq_zero, false_and] at hj
#align algebraic_topology.dold_kan.higher_faces_vanish.comp_Ïƒ AlgebraicTopology.DoldKan.HigherFacesVanish.comp_Ïƒ

theorem Ïƒ_comp_P_eq_zero (X : SimplicialObject C) {n q : â„•} (i : Fin (n + 1)) (hi : n + 1 â‰¤ i + q) :
    X.Ïƒ i â‰« (P q).f (n + 1) = 0 := by
  revert i hi
  -- âŠ¢ âˆ€ (i : Fin (n + 1)), n + 1 â‰¤ â†‘i + q â†’ SimplicialObject.Ïƒ X i â‰« HomologicalCo â€¦
  induction' q with q hq
  -- âŠ¢ âˆ€ (i : Fin (n + 1)), n + 1 â‰¤ â†‘i + Nat.zero â†’ SimplicialObject.Ïƒ X i â‰« Homolo â€¦
  Â· intro i (hi : n + 1 â‰¤ i)
    -- âŠ¢ SimplicialObject.Ïƒ X i â‰« HomologicalComplex.Hom.f (P Nat.zero) (n + 1) = 0
    exfalso
    -- âŠ¢ False
    linarith [Fin.is_lt i]
    -- ðŸŽ‰ no goals
  Â· intro i (hi : n + 1 â‰¤ i + q + 1)
    -- âŠ¢ SimplicialObject.Ïƒ X i â‰« HomologicalComplex.Hom.f (P (Nat.succ q)) (n + 1) = 0
    by_cases n + 1 â‰¤ (i : â„•) + q
    -- âŠ¢ SimplicialObject.Ïƒ X i â‰« HomologicalComplex.Hom.f (P (Nat.succ q)) (n + 1) = 0
    -- âŠ¢ SimplicialObject.Ïƒ X i â‰« HomologicalComplex.Hom.f (P (Nat.succ q)) (n + 1) = 0
    Â· rw [P_succ, HomologicalComplex.comp_f, â† assoc, hq i h, zero_comp]
      -- ðŸŽ‰ no goals
    Â· replace hi : n = i + q := by
        obtain âŸ¨j, hjâŸ© := le_iff_exists_add.mp hi
        rw [â† Nat.lt_succ_iff, Nat.succ_eq_add_one, hj, not_lt, add_le_iff_nonpos_right,
          nonpos_iff_eq_zero] at h
        rw [â† add_left_inj 1, hj, self_eq_add_right, h]
      rcases n with _|n
      -- âŠ¢ SimplicialObject.Ïƒ X i â‰« HomologicalComplex.Hom.f (P (Nat.succ q)) (Nat.zero â€¦
      Â· fin_cases i
        -- âŠ¢ SimplicialObject.Ïƒ X { val := 0, isLt := (_ : 0 < Nat.zero + 1) } â‰« Homologi â€¦
        dsimp at h hi
        -- âŠ¢ SimplicialObject.Ïƒ X { val := 0, isLt := (_ : 0 < Nat.zero + 1) } â‰« Homologi â€¦
        rw [show q = 0 by linarith]
        -- âŠ¢ SimplicialObject.Ïƒ X { val := 0, isLt := (_ : 0 < Nat.zero + 1) } â‰« Homologi â€¦
        change X.Ïƒ 0 â‰« (P 1).f 1 = 0
        -- âŠ¢ SimplicialObject.Ïƒ X 0 â‰« HomologicalComplex.Hom.f (P 1) 1 = 0
        simp only [P_succ, HomologicalComplex.add_f_apply, comp_add,
          HomologicalComplex.id_f, AlternatingFaceMapComplex.obj_d_eq, HÏƒ,
          HomologicalComplex.comp_f, Homotopy.nullHomotopicMap'_f (c_mk 2 1 rfl) (c_mk 1 0 rfl),
          comp_id]
        erw [hÏƒ'_eq' (zero_add 0).symm, hÏƒ'_eq' (add_zero 1).symm, comp_id, Fin.sum_univ_two,
          Fin.sum_univ_succ, Fin.sum_univ_two]
        simp only [Fin.val_zero, pow_zero, pow_one, pow_add, one_smul, neg_smul, Fin.mk_one,
          Fin.val_succ, Fin.val_one, Fin.succ_one_eq_two, P_zero, HomologicalComplex.id_f,
          Fin.val_two, pow_two, mul_neg, one_mul, neg_mul, neg_neg, id_comp, add_comp,
          comp_add, Fin.mk_zero, neg_comp, comp_neg, Fin.succ_zero_eq_one]
        erw [SimplicialObject.Î´_comp_Ïƒ_self, SimplicialObject.Î´_comp_Ïƒ_self_assoc,
          SimplicialObject.Î´_comp_Ïƒ_succ, comp_id,
          SimplicialObject.Î´_comp_Ïƒ_of_le X
            (show (0 : Fin 2) â‰¤ Fin.castSucc 0 by rw [Fin.castSucc_zero]),
          SimplicialObject.Î´_comp_Ïƒ_self_assoc, SimplicialObject.Î´_comp_Ïƒ_succ_assoc]
        simp only [add_right_neg, add_zero, zero_add]
        -- ðŸŽ‰ no goals
      Â· rw [â† id_comp (X.Ïƒ i), â† (P_add_Q_f q n.succ : _ = ðŸ™ (X.obj _)), add_comp, add_comp,
          P_succ]
        have v : HigherFacesVanish q ((P q).f n.succ â‰« X.Ïƒ i) :=
          (HigherFacesVanish.of_P q n).comp_Ïƒ hi
        erw [â† assoc, v.comp_P_eq_self, HomologicalComplex.add_f_apply, Preadditive.comp_add,
          comp_id, v.comp_HÏƒ_eq hi, assoc, SimplicialObject.Î´_comp_Ïƒ_succ_assoc, Fin.eta,
          decomposition_Q n q, sum_comp, sum_comp, Finset.sum_eq_zero, add_zero, add_neg_eq_zero]
        intro j hj
        -- âŠ¢ ((HomologicalComplex.Hom.f (P â†‘j) (n + 1) â‰« SimplicialObject.Î´ X (Fin.succ ( â€¦
        simp only [true_and_iff, Finset.mem_univ, Finset.mem_filter] at hj
        -- âŠ¢ ((HomologicalComplex.Hom.f (P â†‘j) (n + 1) â‰« SimplicialObject.Î´ X (Fin.succ ( â€¦
        simp only [Nat.succ_eq_add_one] at hi
        -- âŠ¢ ((HomologicalComplex.Hom.f (P â†‘j) (n + 1) â‰« SimplicialObject.Î´ X (Fin.succ ( â€¦
        obtain âŸ¨k, hkâŸ© := Nat.le.dest (Nat.lt_succ_iff.mp (Fin.is_lt j))
        -- âŠ¢ ((HomologicalComplex.Hom.f (P â†‘j) (n + 1) â‰« SimplicialObject.Î´ X (Fin.succ ( â€¦
        rw [add_comm] at hk
        -- âŠ¢ ((HomologicalComplex.Hom.f (P â†‘j) (n + 1) â‰« SimplicialObject.Î´ X (Fin.succ ( â€¦
        have hi' : i = Fin.castSucc âŸ¨i, by linarithâŸ© := by
          ext
          simp only [Fin.castSucc_mk, Fin.eta]
        have eq := hq j.revPerm.succ (by
          simp only [â† hk, Fin.revPerm_eq j hk.symm, Nat.succ_eq_add_one, Fin.succ_mk, Fin.val_mk]
          linarith)
        rw [HomologicalComplex.comp_f, assoc, assoc, assoc, hi',
          SimplicialObject.Ïƒ_comp_Ïƒ_assoc, reassoc_of% eq, zero_comp, comp_zero, comp_zero,
          comp_zero]
        simp only [Fin.revPerm_eq j hk.symm, Fin.le_iff_val_le_val, Fin.val_mk]
        -- âŠ¢ â†‘i â‰¤ k
        linarith
        -- ðŸŽ‰ no goals
set_option linter.uppercaseLean3 false in
#align algebraic_topology.dold_kan.Ïƒ_comp_P_eq_zero AlgebraicTopology.DoldKan.Ïƒ_comp_P_eq_zero

@[reassoc (attr := simp)]
theorem Ïƒ_comp_PInfty (X : SimplicialObject C) {n : â„•} (i : Fin (n + 1)) :
    X.Ïƒ i â‰« PInfty.f (n + 1) = 0 := by
  rw [PInfty_f, Ïƒ_comp_P_eq_zero X i]
  -- âŠ¢ n + 1 â‰¤ â†‘i + (n + 1)
  simp only [le_add_iff_nonneg_left, zero_le]
  -- ðŸŽ‰ no goals
set_option linter.uppercaseLean3 false in
#align algebraic_topology.dold_kan.Ïƒ_comp_P_infty AlgebraicTopology.DoldKan.Ïƒ_comp_PInfty

@[reassoc]
theorem degeneracy_comp_PInfty (X : SimplicialObject C) (n : â„•) {Î”' : SimplexCategory}
    (Î¸ : ([n] : SimplexCategory) âŸ¶ Î”') (hÎ¸ : Â¬Mono Î¸) : X.map Î¸.op â‰« PInfty.f n = 0 := by
  rw [SimplexCategory.mono_iff_injective] at hÎ¸
  -- âŠ¢ X.map Î¸.op â‰« HomologicalComplex.Hom.f PInfty n = 0
  cases n
  -- âŠ¢ X.map Î¸.op â‰« HomologicalComplex.Hom.f PInfty Nat.zero = 0
  Â· exfalso
    -- âŠ¢ False
    apply hÎ¸
    -- âŠ¢ Function.Injective â†‘(SimplexCategory.Hom.toOrderHom Î¸)
    intro x y h
    -- âŠ¢ x = y
    fin_cases x
    -- âŠ¢ { val := 0, isLt := (_ : 0 < SimplexCategory.len [Nat.zero] + 1) } = y
    fin_cases y
    -- âŠ¢ { val := 0, isLt := (_ : 0 < SimplexCategory.len [Nat.zero] + 1) } = { val : â€¦
    rfl
    -- ðŸŽ‰ no goals
  Â· obtain âŸ¨i, Î±, hâŸ© := SimplexCategory.eq_Ïƒ_comp_of_not_injective Î¸ hÎ¸
    -- âŠ¢ X.map Î¸.op â‰« HomologicalComplex.Hom.f PInfty (Nat.succ nâœ) = 0
    rw [h, op_comp, X.map_comp, assoc, show X.map (SimplexCategory.Ïƒ i).op = X.Ïƒ i by rfl,
      Ïƒ_comp_PInfty, comp_zero]
set_option linter.uppercaseLean3 false in
#align algebraic_topology.dold_kan.degeneracy_comp_P_infty AlgebraicTopology.DoldKan.degeneracy_comp_PInfty

end DoldKan

end AlgebraicTopology
