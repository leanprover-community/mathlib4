import Mathlib.AlgebraicTopology.SimplicialSet
import Mathlib.CategoryTheory.Limits.Preserves.Limits
import Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts

open CategoryTheory CategoryTheory.Limits Simplicial SimplicialObject

variable (X Y X' Y': SSet) (m n : â„•) (f : X âŸ¶ Y)

example : Î”[m] _[n] =
  (yoneda.obj ([m] : SimplexCategory)).obj (Opposite.op [n]) := rfl

def auxfoomap (m : â„•) : Fin (m + 1) â†’o Fin (1) where
  toFun := fun _ => 0
  monotone' := fun _ _ => by intro ; rfl

def foomap : X âŸ¶ Î”[0] where
  app := by
    intro n _
    exact SimplexCategory.Hom.mk (auxfoomap ((Opposite.unop n).len))

def footerm : IsTerminal Î”[0] := by
  apply Limits.IsTerminal.ofUniqueHom foomap
  intro X f
  ext n X_n
  dsimp [foomap, auxfoomap]
  sorry

/- morphisms Î”[0] âŸ¶ Î”[1] are in bijection with morphisms [0] âŸ¶ [1] in the
    simplex category -/
example : (Î”[0] âŸ¶ Î”[1]) â‰ƒ Î”[1] _[0] := yonedaEquiv

def dâ‚€ : Î”[0] âŸ¶ Î”[1] := yonedaEquiv.invFun (SimplexCategory.Î´ (0 : Fin 2))

def dâ‚ : Î”[0] âŸ¶ Î”[1] := yonedaEquiv.invFun (SimplexCategory.Î´ (1 : Fin 2))

noncomputable section

/-
scrap work
-/
def foob (t) : (X â¨¯ Î”[0]).obj t â‰… (X.obj t â¨¯ Î”[0].obj t) :=
  show ((evaluation _ _).obj t).obj (X â¨¯ Î”[0]) â‰… _ from
  preservesLimitIso _ _ â‰ªâ‰« HasLimit.isoOfNatIso
    (pairComp X Î”[0] ((evaluation SimplexCategoryáµ’áµ– Type).obj t))

def proj_iso : (X â¨¯ Î”[0]) â‰… X :=
  prod.mapIso (eqToIso (Eq.refl _))
    (IsTerminal.uniqueUpToIso terminalIsTerminal footerm).symm â‰ªâ‰«
    (prod.rightUnitor _)

structure SimpHom (fâ‚€ fâ‚ : X âŸ¶ Y) where
  /- the homotopy -/
  h : X â¨¯ Î”[1] âŸ¶ Y
  /- h(x, 0) = fâ‚€ x -/
  map_zero : prod.map (ğŸ™ X) dâ‚€ â‰« h = (proj_iso _).hom â‰« fâ‚€
  /- h(x, 1) = fâ‚ x -/
  map_one : prod.map (ğŸ™ X) dâ‚ â‰« h = Limits.prod.fst â‰« fâ‚


end section
