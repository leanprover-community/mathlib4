/-
Copyright (c) 2025 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
module

public import Mathlib.AlgebraicTopology.SimplexCategory.Truncated
public import Mathlib.CategoryTheory.MorphismProperty.Composition

/-!
# Properties of morphisms in the simplex category

In this file, we show that morphisms in the simplex category
are generated by faces and degeneracies. This is stated by
saying that if `W : MorphismProperty SimplexCategory` is
multiplicative, and contains faces and degeneracies, then `W = ‚ä§`.
This statement is deduced from a similar statement for
the category `SimplexCategory.Truncated d`.

-/

public section

open CategoryTheory

namespace SimplexCategory

lemma Truncated.morphismProperty_eq_top
    {d : ‚Ñï} (W : MorphismProperty (Truncated d)) [W.IsMultiplicative]
    (Œ¥_mem : ‚àÄ (n : ‚Ñï) (hn : n < d) (i : Fin (n + 2)),
      W (Truncated.Œ¥ d i (by dsimp; lia) (by dsimp; lia)))
    (œÉ_mem : ‚àÄ (n : ‚Ñï) (hn : n < d) (i : Fin (n + 1)),
      W (Truncated.œÉ d i (by dsimp; lia) (by dsimp; lia))) :
    W = ‚ä§ := by
  ext ‚ü®a, ha‚ü© ‚ü®b, hb‚ü© f
  simp only [MorphismProperty.top_apply, iff_true]
  induction a using SimplexCategory.rec with | _ a
  induction b using SimplexCategory.rec with | _ b
  dsimp at ha hb
  generalize h : a + b = c
  induction c generalizing a b with
  | zero =>
    obtain rfl : a = 0 := by lia
    obtain rfl : b = 0 := by lia
    obtain rfl : f = ùüô _ := by
      ext i : 3
      apply Subsingleton.elim (Œ± := Fin 1)
    apply MorphismProperty.id_mem
  | succ c hc =>
    by_cases h‚ÇÅ : Function.Surjective f.hom.toOrderHom; swap
    ¬∑ obtain _ | b := b
      ¬∑ exact (h‚ÇÅ (fun _ ‚Ü¶ ‚ü®0, Subsingleton.elim (Œ± := Fin 1) _ _‚ü©)).elim
      ¬∑ obtain ‚ü®i, g', hf'‚ü© := eq_comp_Œ¥_of_not_surjective _ h‚ÇÅ
        replace hf' : f = Hom.tr g' ‚â´ Hom.tr (SimplexCategory.Œ¥ i) :=
          InducedCategory.hom_ext hf'
        rw [hf']
        exact W.comp_mem _ _ (hc _ _ _ _ _ (by lia))
          (Œ¥_mem _ (by lia) _)
    by_cases h‚ÇÇ : Function.Injective f.hom.toOrderHom; swap
    ¬∑ obtain _ | a := a
      ¬∑ exact (h‚ÇÇ (Function.injective_of_subsingleton (Œ± := Fin 1) _)).elim
      ¬∑ obtain ‚ü®i, g', hf'‚ü© := eq_œÉ_comp_of_not_injective _ h‚ÇÇ
        replace hf' : f = Hom.tr (SimplexCategory.œÉ i) ‚â´ Hom.tr g' :=
          InducedCategory.hom_ext hf'
        rw [hf']
        exact W.comp_mem _ _ (œÉ_mem _ (by lia) _) (hc _ _ _ _ _ (by lia))
    rw [‚Üê epi_iff_surjective] at h‚ÇÅ
    rw [‚Üê mono_iff_injective] at h‚ÇÇ
    obtain rfl : a = b := le_antisymm (len_le_of_mono f.hom) (len_le_of_epi f.hom)
    obtain rfl : f = ùüô _ := ObjectProperty.hom_ext _ (SimplexCategory.eq_id_of_epi _)
    apply W.id_mem

lemma morphismProperty_eq_top
    (W : MorphismProperty SimplexCategory) [W.IsMultiplicative]
    (Œ¥_mem : ‚àÄ {n : ‚Ñï} (i : Fin (n + 2)), W (SimplexCategory.Œ¥ i))
    (œÉ_mem : ‚àÄ {n : ‚Ñï} (i : Fin (n + 1)), W (SimplexCategory.œÉ i)) :
    W = ‚ä§ := by
  have hW (d : ‚Ñï) : W.inverseImage (Truncated.inclusion d) = ‚ä§ :=
    Truncated.morphismProperty_eq_top _ (fun _ _ i ‚Ü¶ Œ¥_mem i)
      (fun _ _ i ‚Ü¶ œÉ_mem i)
  ext a b f
  simp only [MorphismProperty.top_apply, iff_true]
  change W.inverseImage (Truncated.inclusion (max a.len b.len))
    (Truncated.Hom.tr f (ha := by simp) (hb := by simp))
  simp only [hW, MorphismProperty.top_apply]

end SimplexCategory
