/-
Copyright (c) 2025 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathlib.AlgebraicTopology.SimplexCategory.Basic
import Mathlib.CategoryTheory.MorphismProperty.Composition

/-!
# Properties of morphisms in the simplex category

In this file, we show that morphisms in the simplex category
are generated by faces and degeneracies. This is stated by
saying that if `W : MorphismProperty SimplexCategory` is
multiplicative, and contains faces and degeneracies, then `W = ‚ä§`.
This statement is deduced from a similar statement for
the category `SimplexCategory.Truncated d`.

-/

open CategoryTheory

namespace SimplexCategory

lemma Truncated.morphismProperty_eq_top
    {d : ‚Ñï} (W : MorphismProperty (Truncated d)) [W.IsMultiplicative]
    (Œ¥_mem : ‚àÄ (n : ‚Ñï) (hn : n < d) (i : Fin (n + 2)),
    W (Hom.tr (n := d) (SimplexCategory.Œ¥ i)))
    (œÉ_mem : ‚àÄ (n : ‚Ñï) (hn : n < d) (i : Fin (n + 1)),
      W (Hom.tr (n := d) (SimplexCategory.œÉ i))) :
    W = ‚ä§ := by
  ext ‚ü®a, ha‚ü© ‚ü®b, hb‚ü© f
  simp only [MorphismProperty.top_apply, iff_true]
  induction' a using SimplexCategory.rec with a
  induction' b using SimplexCategory.rec with b
  dsimp at ha hb
  generalize h : a + b = c
  induction c generalizing a b with
  | zero =>
    obtain rfl : a = 0 := by omega
    obtain rfl : b = 0 := by omega
    obtain rfl : f = ùüô _ := by
      ext i : 3
      apply Subsingleton.elim (Œ± := Fin 1)
    apply MorphismProperty.id_mem
  | succ c hc =>
    by_cases h‚ÇÅ : Function.Surjective f.hom.toOrderHom; swap
    ¬∑ obtain _ | b := b
      ¬∑ exact (h‚ÇÅ (fun _ ‚Ü¶ ‚ü®0, Subsingleton.elim (Œ± := Fin 1) _ _‚ü©)).elim
      ¬∑ obtain ‚ü®i, g', hf'‚ü© := eq_comp_Œ¥_of_not_surjective _ h‚ÇÅ
        obtain rfl : f = Hom.tr g' ‚â´ Hom.tr (SimplexCategory.Œ¥ i) :=
          InducedCategory.hom_ext hf'
        exact W.comp_mem _ _ (hc _ _ _ _ _ (by omega))
          (Œ¥_mem _ (by omega) _)
    by_cases h‚ÇÇ : Function.Injective f.hom.toOrderHom; swap
    ¬∑ obtain _ | a := a
      ¬∑ exact (h‚ÇÇ (Function.injective_of_subsingleton (Œ± := Fin 1) _)).elim
      ¬∑ obtain ‚ü®i, g', hf'‚ü© := eq_œÉ_comp_of_not_injective _ h‚ÇÇ
        obtain rfl : f = Hom.tr (SimplexCategory.œÉ i) ‚â´ Hom.tr g' :=
          InducedCategory.hom_ext hf'
        exact W.comp_mem _ _ (œÉ_mem _ (by omega) _) (hc _ _ _ _ _ (by omega))
    rw [‚Üê epi_iff_surjective] at h‚ÇÅ
    rw [‚Üê mono_iff_injective] at h‚ÇÇ
    obtain rfl : a = b := le_antisymm (len_le_of_mono h‚ÇÇ) (len_le_of_epi h‚ÇÅ)
    obtain rfl : f = ùüô _ := InducedCategory.hom_ext (eq_id_of_mono f.hom)
    apply W.id_mem

lemma morphismProperty_eq_top
    (W : MorphismProperty SimplexCategory) [W.IsMultiplicative]
    (Œ¥_mem : ‚àÄ {n : ‚Ñï} (i : Fin (n + 2)), W (SimplexCategory.Œ¥ i))
    (œÉ_mem : ‚àÄ {n : ‚Ñï} (i : Fin (n + 1)), W (SimplexCategory.œÉ i)) :
    W = ‚ä§ := by
  have hW (d : ‚Ñï) : W.inverseImage (Truncated.inclusion d) = ‚ä§ :=
    Truncated.morphismProperty_eq_top _ (fun _ _ i ‚Ü¶ Œ¥_mem i)
      (fun _ _ i ‚Ü¶ œÉ_mem i)
  ext a b f
  simp only [MorphismProperty.top_apply, iff_true]
  change W.inverseImage (Truncated.inclusion (max a.len b.len))
    (Truncated.Hom.tr f (ha := by simp) (hb := by simp))
  simp only [hW, MorphismProperty.top_apply]

end SimplexCategory
