/-
Copyright (c) 2025 Joël Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joël Riou
-/
module

public import Mathlib.AlgebraicTopology.SimplicialSet.Degenerate

/-!
# The skeleton of a simplicial set

In this file, we define the skeleton `X.skeleton : ℕ →o X.Subcomplex`
of a simplicial set `X`. For any `n : ℕ`, `X.skeleton n` is the
subcomplex of `X` that is generated by (non-degenerate) simplices
of dimension `< n`.

If `i : X ⟶ Y` is a monomorphism, we define
`skeletonOfMono i : ℕ →o Y.Subcomplex` so that
`skeletonOfMono i n = Subcomplex.range i ⊔ Y.skeleton n`.

## TODO
* show that `X.skeleton (n + 1)` is obtained from `X.skeleton n` by
attaching `∂Δ[n] ⟶ Δ[n]` cells (this also holds
for `skeletonOfMono i`) (@joelriou).
* show that `(SSet.sk n).obj X` is isomorphic to `X.skeleton (n + 1)`

-/

@[expose] public section

universe u

open CategoryTheory Simplicial Limits Opposite

namespace SSet

variable (X : SSet.{u})

/-- `X.skeleton n` is the subcomplex of `X` generated by (non-degenerate)
simplices of dimension `< n`. -/
def skeleton : ℕ →o X.Subcomplex where
  toFun n := ⨆ (i : Fin n) (x : X.nonDegenerate i), Subcomplex.ofSimplex x.1
  monotone' i j h := by
    simp only [iSup_le_iff]
    intro k x
    exact le_trans (by exact le_trans (by rfl) (le_iSup _ x))
      (le_iSup _ ⟨k, by lia⟩)

lemma mem_skeleton {i : ℕ} (x : X _⦋i⦌) {n : ℕ} (hi : i < n := by lia) :
    x ∈ (X.skeleton n).obj _ := by
  obtain ⟨j, f, _, y, rfl⟩ := X.exists_nonDegenerate x
  suffices Subcomplex.ofSimplex y.1 ≤ X.skeleton n from
    (X.skeleton n).map _ (this _ (Subcomplex.mem_ofSimplex_obj _))
  exact le_trans (by exact le_trans (by rfl) (le_iSup _ y))
    (le_iSup _ ⟨j, lt_of_le_of_lt
      (SimplexCategory.len_le_of_epi f) hi⟩)

lemma skeleton_obj_eq_top {d n : ℕ} (h : d < n) :
    (X.skeleton n).obj (op ⦋d⦌) = ⊤ := by
  rw [← top_le_iff]
  intro x _
  exact mem_skeleton _ _ h

lemma ofSimplex_le_skeleton {i : ℕ} (x : X _⦋i⦌) {n : ℕ} (hi : i < n) :
    Subcomplex.ofSimplex x ≤ X.skeleton n := by
  simpa using X.mem_skeleton x hi

lemma mem_skeleton_obj_iff_of_nonDegenerate
    {d : ℕ} (x : X.nonDegenerate d) (n : ℕ) :
    x.1 ∈ (X.skeleton n).obj _ ↔ d < n := by
  refine ⟨fun h ↦ ?_, fun _ ↦ X.mem_skeleton _⟩
  obtain ⟨x, hx⟩ := x
  simp only [skeleton, OrderHom.coe_mk, Subfunctor.iSup_obj,
    Set.iUnion_coe_set, Set.mem_iUnion, exists_prop] at h
  obtain ⟨⟨i, hi⟩, y, hy, ⟨f⟩, rfl⟩ := h
  have := X.mono_of_nonDegenerate ⟨_, hx⟩ f y rfl
  have : d ≤ i := SimplexCategory.len_le_of_mono f
  lia

@[simp]
lemma skeleton_zero : X.skeleton 0 = ⊥ := by
  simp [skeleton]

lemma iSup_skeleton :
    ⨆ (n : ℕ), X.skeleton n = ⊤ :=
  le_antisymm (by simp) (by
    rw [Subcomplex.le_iff_contains_nonDegenerate]
    intro n x _
    simp only [Subfunctor.iSup_obj, Set.mem_iUnion]
    exact ⟨n + 1, mem_skeleton _ _ (by lia)⟩)

lemma skeleton_succ (n : ℕ) :
    X.skeleton (n + 1) =
      X.skeleton n ⊔ ⨆ (x : X.nonDegenerate n), Subcomplex.ofSimplex x.1 := by
  apply le_antisymm
  · conv_lhs => dsimp [skeleton]
    simp only [iSup_le_iff]
    rintro ⟨d, hd⟩ x
    rw [Nat.lt_succ_iff] at hd
    obtain hd | rfl := hd.lt_or_eq
    · exact (X.ofSimplex_le_skeleton _ hd).trans le_sup_left
    · exact le_trans (le_trans (by rfl) (le_iSup _ x)) le_sup_right
  · simp only [sup_le_iff, iSup_le_iff]
    constructor
    · exact X.skeleton.monotone (by simp)
    · intro x
      apply X.ofSimplex_le_skeleton _ (by simp)

variable {X} {Y : SSet.{u}} (i : X ⟶ Y)

/-- The skeleton of a monomorphism `i : X ⟶ Y` of simplicial sets.
It sends `n : ℕ` to `Subcomplex.range i ⊔ Y.skeleton n`. -/
@[nolint unusedArguments]
def skeletonOfMono [Mono i] : ℕ →o Y.Subcomplex where
  toFun n := Subcomplex.range i ⊔ Y.skeleton n
  monotone' n m h := by
    dsimp
    simp only [sup_le_iff, le_sup_left, true_and]
    exact le_trans (Y.skeleton.monotone h) le_sup_right

section

variable [Mono i]

lemma skeleton_le_skeletonOfMono (n : ℕ) :
    Y.skeleton n ≤ skeletonOfMono i n := le_sup_right

@[simp]
lemma skeletonOfMono_zero :
    skeletonOfMono i 0 = Subcomplex.range i := by
  simp [skeletonOfMono]

lemma iSup_skeletonOfMono :
    ⨆ (n : ℕ), skeletonOfMono i n = ⊤ := by
  apply le_antisymm (by simp)
  rw [← Y.iSup_skeleton, iSup_le_iff]
  intro n
  exact le_trans (skeleton_le_skeletonOfMono i n) (le_iSup _ n)

lemma mem_skeletonOfMono_obj_iff_of_nonDegenerate
    {d : ℕ} (x : Y.nonDegenerate d) (n : ℕ) :
    x.1 ∈ (skeletonOfMono i n).obj _ ↔
      x.1 ∈ Set.range (i.app _) ∨ d < n := by
  simp [skeletonOfMono, mem_skeleton_obj_iff_of_nonDegenerate]

lemma skeletonOfMono_obj_eq_top {d n : ℕ} (h : d < n) :
    (skeletonOfMono i n).obj (op ⦋d⦌) = ⊤ := by
  rw [← top_le_iff, ← Y.skeleton_obj_eq_top h]
  exact le_sup_right

lemma skeletonOfMono_succ (n : ℕ) :
    skeletonOfMono i (n + 1) =
      skeletonOfMono i n ⊔ ⨆ (x : Y.nonDegenerate n)
        (_ : x.1 ∉ (Subcomplex.range i).obj _), Subcomplex.ofSimplex x.1 := by
  dsimp only [skeletonOfMono, OrderHom.coe_mk]
  apply le_antisymm
  · simp only [sup_le_iff, iSup_le_iff, skeleton_succ]
    refine ⟨le_sup_left.trans le_sup_left,
      le_sup_right.trans le_sup_left, fun x ↦ ?_⟩
    by_cases hx : x.1 ∈ (Subcomplex.range i).obj _
    · exact le_trans (le_trans (by simpa) le_sup_left) le_sup_left
    · exact (le_trans (by exact le_trans (by rfl) (le_iSup _ hx))
        (le_iSup _ x)).trans le_sup_right
  · simp only [sup_le_iff, iSup_le_iff]
    exact ⟨⟨le_sup_left, (Y.skeleton.monotone (by simp)).trans le_sup_right⟩,
      fun _ _ ↦ (Y.ofSimplex_le_skeleton _ (by simp)).trans le_sup_right⟩

end

end SSet
