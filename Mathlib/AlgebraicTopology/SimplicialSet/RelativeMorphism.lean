/-
Copyright (c) 2025 Joël Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joël Riou
-/
module

public import Mathlib.AlgebraicTopology.SimplicialSet.Monoidal
public import Mathlib.AlgebraicTopology.SimplicialSet.Subcomplex

/-!
# Relative morphisms of simplicial sets

Given two simplicial sets `X` and `Y`, and subcomplexes `A` of `X`, and `B` of `Y`,
we introduce a type `RelativeMorphism A B φ` of morphisms `X ⟶ Y` which induce
a given morphism of simplicial sets `A ⟶ B`. We define homotopies between
these relative morphisms and introduce the quotient type of homotopy classes.

-/

@[expose] public section

universe u

open CategoryTheory Simplicial MonoidalCategory CartesianMonoidalCategory

namespace SSet

variable {X Y Z : SSet.{u}} (A : X.Subcomplex) (B : Y.Subcomplex)
  (φ : (A : SSet) ⟶ (B : SSet))

/-- Given a morphism of simplicial sets `φ : A ⟶ B` with `A : X.Subcomplex` and
`B : Y.Subcomplex`, this is the type of morphisms `X ⟶ Y` which induce `φ`. -/
@[ext]
structure RelativeMorphism where
  /-- The underlying morphism of simplicial sets. -/
  map : X ⟶ Y
  comm : A.ι ≫ map = φ ≫ B.ι := by cat_disch

namespace RelativeMorphism

attribute [reassoc (attr := simp)] comm

variable {A} in
/-- The constant relative morphism when the given subcomplex of the target
is generated by a `0`-simplex. -/
@[simps]
def const {y : Y _⦋0⦌} {φ : (A : SSet) ⟶ (Subcomplex.ofSimplex y : SSet)} :
    RelativeMorphism A (Subcomplex.ofSimplex y) φ where
  map := SSet.const y

/-- Given a morphism `f : X ⟶ Y` of simplicial set which sends a `0`-simplex `x` to `y`,
this is the pointed morphism `(X, x) ⟶ (Y, y)`. -/
@[simps]
def ofSimplex₀ (f : X ⟶ Y) (x : X _⦋0⦌) (y : Y _⦋0⦌) (h : f.app _ x = y) :
    RelativeMorphism (.ofSimplex x) (.ofSimplex y)
      (SSet.const ⟨y, Subcomplex.mem_ofSimplex_obj y⟩) where
  map := f

variable {A B φ} (f g : RelativeMorphism A B φ)

lemma map_eq_of_mem {n : SimplexCategoryᵒᵖ} (a : X.obj n) (ha : a ∈ A.obj n) :
    f.map.app n a = φ.app n ⟨a, ha⟩ :=
  congr_fun (congr_app f.comm n) ⟨a, ha⟩

@[simp]
lemma map_coe {n : SimplexCategoryᵒᵖ} (a : A.obj n) :
    f.map.app n a = φ.app n a :=
  map_eq_of_mem _ _ _

lemma image_le : A.image f.map ≤ B := by
  rintro n _ ⟨a, ha, rfl⟩
  have := f.map_coe ⟨a, ha⟩
  aesop

lemma le_preimage : A ≤ B.preimage f.map := by
  simpa only [← Subcomplex.image_le_iff] using f.image_le

/-- The type of homotopies between morphisms of simplicial sets relatively to
given subcomplexes. -/
@[ext]
structure Homotopy where
  /-- The homotopy. -/
  h : X ⊗ Δ[1] ⟶ Y
  h₀ : ι₀ ≫ h = f.map := by cat_disch
  h₁ : ι₁ ≫ h = g.map := by cat_disch
  rel : A.ι ▷ _ ≫ h = fst _ _ ≫ φ ≫ B.ι := by cat_disch

namespace Homotopy

attribute [reassoc (attr := simp)] h₀ h₁ rel

variable {f g} in
/-- Two equal relative morphisms are homotopic. -/
@[simps]
noncomputable def ofEq (h : f = g) : Homotopy f g where
  h := fst _ _ ≫ f.map

/-- A relative morphism is homotopic to itself. -/
@[simps]
noncomputable def refl : Homotopy f f where
  h := fst _ _ ≫ f.map

end Homotopy

variable (A B φ)

/-- The type of homotopy classes of relative morphisms. -/
def HomotopyClass : Type u :=
  Quot (α := RelativeMorphism A B φ) (fun f g ↦ Nonempty (Homotopy f g))

variable {A B φ}

/-- The homotopy class of a relative morphism. -/
def homotopyClass (f : RelativeMorphism A B φ) : HomotopyClass A B φ := Quot.mk _ f

lemma Homotopy.eq {f g : RelativeMorphism A B φ} (h : Homotopy f g) :
    f.homotopyClass = g.homotopyClass :=
  Quot.sound ⟨h⟩

lemma HomotopyClass.eq_homotopyClass (x : HomotopyClass A B φ) :
    ∃ (f : RelativeMorphism A B φ), f.homotopyClass = x :=
  Quot.mk_surjective x

variable {C : Z.Subcomplex} {ψ : (B : SSet) ⟶ (C : SSet)}

/-- The composition of relative morphisms. -/
@[simps]
def comp (f' : RelativeMorphism B C ψ) {φψ : (A : SSet) ⟶ (C : SSet)}
    (fac : φ ≫ ψ = φψ) : RelativeMorphism A C φψ where
  map := f.map ≫ f'.map

variable {f g}

/-- The postcomposition of an homotopy with a relative morphism. -/
@[simps]
noncomputable def Homotopy.postcomp (h : Homotopy f g)
    (f' : RelativeMorphism B C ψ) {φψ : (A : SSet) ⟶ (C : SSet)}
    (fac : φ ≫ ψ = φψ) :
    Homotopy (f.comp f' fac) (g.comp f' fac) where
  h := h.h ≫ f'.map
  rel := by simp [h.rel_assoc, ← fac]

/-- The precomposition of an homotopy with a relative morphism. -/
@[simps]
noncomputable def Homotopy.precomp
    {f' g' : RelativeMorphism B C ψ} (h : Homotopy f' g')
    (f : RelativeMorphism A B φ) {φψ : (A : SSet) ⟶ (C : SSet)}
    (fac : φ ≫ ψ = φψ) :
    Homotopy (f.comp f' fac) (f.comp g' fac) where
  h := f.map ▷ _ ≫ h.h
  rel := by
    rw [← fac, Category.assoc, ← comp_whiskerRight_assoc, f.comm,
      comp_whiskerRight_assoc, h.rel, whiskerRight_fst_assoc]

/-- The postcomposition of an homotopy class by a relative morphism. -/
def HomotopyClass.postcomp (h : HomotopyClass A B φ)
    (f' : RelativeMorphism B C ψ) {φψ : (A : SSet) ⟶ (C : SSet)}
    (fac : φ ≫ ψ = φψ) :
    HomotopyClass A C φψ :=
  Quot.lift (fun f ↦ (f.comp f' fac).homotopyClass)
    (fun _ _ ⟨h⟩ ↦ (h.postcomp f' fac).eq) h

@[simp]
lemma postcomp_homotopyClass
    (f : RelativeMorphism A B φ) (f' : RelativeMorphism B C ψ)
    {φψ : (A : SSet) ⟶ (C : SSet)} (fac : φ ≫ ψ = φψ) :
    f.homotopyClass.postcomp f' fac =
      (f.comp f' fac).homotopyClass := rfl

/-- The precomposition of an homotopy class with a relative morphism. -/
noncomputable def HomotopyClass.precomp
    (h : HomotopyClass B C ψ)
    (f' : RelativeMorphism A B φ) {φψ : (A : SSet) ⟶ (C : SSet)}
    (fac : φ ≫ ψ = φψ) :
    HomotopyClass A C φψ :=
  Quot.lift (fun f ↦ (f'.comp f fac).homotopyClass)
    (fun _ _ ⟨h⟩ ↦ (h.precomp f' fac).eq) h

@[simp]
lemma precomp_homotopyClass
    (f : RelativeMorphism A B φ) (f' : RelativeMorphism B C ψ)
    {φψ : (A : SSet) ⟶ (C : SSet)} (fac : φ ≫ ψ = φψ) :
    f'.homotopyClass.precomp f fac =
      (f.comp f' fac).homotopyClass := rfl

end RelativeMorphism

end SSet
