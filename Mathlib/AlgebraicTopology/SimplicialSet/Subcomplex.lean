/-
Copyright (c) 2025 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathlib.AlgebraicTopology.SimplicialSet.Basic
import Mathlib.CategoryTheory.Subpresheaf.OfSection

/-!
# Subcomplexes of a simplicial set

Given a simplicial set `X`, this file defines the type `X.Subcomplex`
of subcomplexes of `X` as an abbreviation for `Subpresheaf X`.
It also introduces a coercion from `X.Subcomplex` to `SSet`.

## Implementation note

`SSet.{u}` is defined as `C·µí·µñ ‚•§ Type u`, but it is not an abbreviation.
This is the reason why `Subpresheaf.Œπ` is redefined here as `Subcomplex.Œπ`
so that this morphism appears as a morphism in `SSet` instead of a morphism
in the category of presheaves.

-/

universe u

open CategoryTheory Simplicial

namespace SSet

-- Note: this could be obtained as `inferInstanceAs (Balanced (_ ‚•§ _))`
-- by importing `Mathlib.CategoryTheory.Adhesive`, but we give a
-- different proof so as to reduce imports
instance : Balanced SSet.{u} where
  isIso_of_mono_of_epi f _ _ := by
    rw [NatTrans.isIso_iff_isIso_app]
    intro
    rw [isIso_iff_bijective]
    constructor
    ¬∑ rw [‚Üê mono_iff_injective]
      infer_instance
    ¬∑ rw [‚Üê epi_iff_surjective]
      infer_instance

variable (X Y : SSet.{u})

/-- The complete lattice of subcomplexes of a simplicial set. -/
abbrev Subcomplex := Subpresheaf X

variable {X Y}

namespace Subcomplex

/-- The underlying simplicial set of a subcomplex. -/
abbrev toSSet (A : X.Subcomplex) : SSet.{u} := A.toPresheaf

instance : CoeOut X.Subcomplex SSet.{u} where
  coe := fun S ‚Ü¶ S.toSSet

/-- If `A : Subcomplex X`, this is the inclusion `A ‚ü∂ X` in the category `SSet`. -/
abbrev Œπ (A : Subcomplex X) : Quiver.Hom (V := SSet) A X := Subpresheaf.Œπ A

instance (A : X.Subcomplex) : Mono A.Œπ :=
  inferInstanceAs (Mono (Subpresheaf.Œπ A))

section

variable {S‚ÇÅ S‚ÇÇ : X.Subcomplex} (h : S‚ÇÅ ‚â§ S‚ÇÇ)

/-- Given an inequality `S‚ÇÅ ‚â§ S‚ÇÇ` between subcomplexes of a simplicial set,
this is the induced morphism in the category `SSet`. -/
abbrev homOfLE : (S‚ÇÅ : SSet.{u}) ‚ü∂ (S‚ÇÇ : SSet.{u}) := Subpresheaf.homOfLe h

@[reassoc]
lemma homOfLE_comp {S‚ÇÉ : X.Subcomplex} (h' : S‚ÇÇ ‚â§ S‚ÇÉ) :
    homOfLE h ‚â´ homOfLE h' = homOfLE (h.trans h') := rfl

variable (S‚ÇÅ) in
@[simp]
lemma homOfLE_refl : homOfLE (by rfl : S‚ÇÅ ‚â§ S‚ÇÅ) = ùüô _ := rfl

@[simp]
lemma homOfLE_app_val (Œî : SimplexCategory·µí·µñ) (x : S‚ÇÅ.obj Œî) :
    ((homOfLE h).app Œî x).val = x.val := rfl

@[reassoc (attr := simp)]
lemma homOfLE_Œπ : homOfLE h ‚â´ S‚ÇÇ.Œπ = S‚ÇÅ.Œπ := rfl

instance mono_homOfLE : Mono (homOfLE h) := mono_of_mono_fac (homOfLE_Œπ h)

/-- This is the isomorphism of simplicial sets corresponding to
an equality of subcomplexes. -/
@[simps]
def isoOfEq (h : S‚ÇÅ = S‚ÇÇ) : (S‚ÇÅ : SSet.{u}) ‚âÖ S‚ÇÇ where
  hom := homOfLE h.le
  inv := homOfLE h.symm.le

end

/-- The functor which sends `A : X.Subcomplex` to `A.toSSet`. -/
@[simps]
def toSSetFunctor : X.Subcomplex ‚•§ SSet.{u} where
  obj A := A
  map h := homOfLE (leOfHom h)

/-- The subcomplex of a simplicial set that is generated by a simplex. -/
abbrev ofSimplex {n : ‚Ñï} (x : X _‚¶ãn‚¶å) : X.Subcomplex := Subpresheaf.ofSection x

lemma mem_ofSimplex_obj {n : ‚Ñï} (x : X _‚¶ãn‚¶å) :
    x ‚àà (ofSimplex x).obj _ :=
  Subpresheaf.mem_ofSection_obj x

lemma ofSimplex_le_iff {n : ‚Ñï} (x : X _‚¶ãn‚¶å) (A : X.Subcomplex) :
    ofSimplex x ‚â§ A ‚Üî x ‚àà A.obj _ :=
  Subpresheaf.ofSection_le_iff _ _

lemma mem_ofSimplex_obj_iff {n : ‚Ñï} (x : X _‚¶ãn‚¶å) {m : SimplexCategory·µí·µñ} (y : X.obj m) :
    y ‚àà (ofSimplex x).obj m ‚Üî ‚àÉ (f : m.unop ‚ü∂ ‚¶ãn‚¶å), X.map f.op x = y := by
  dsimp [ofSimplex, Subpresheaf.ofSection]
  aesop

section

variable (f : X ‚ü∂ Y)

/-- The range of a morphism of simplicial sets, as a subcomplex. -/
abbrev range : Y.Subcomplex := Subpresheaf.range f

/-- The morphism `X ‚ü∂ Subcomplex.range f` induced by `f : X ‚ü∂ Y`. -/
abbrev toRange : X ‚ü∂ Subcomplex.range f := Subpresheaf.toRange f

@[reassoc (attr := simp)]
lemma toRange_Œπ : toRange f ‚â´ (Subcomplex.range f).Œπ = f := rfl

@[simp]
lemma toRange_app_val {Œî : SimplexCategory·µí·µñ} (x : X.obj Œî) :
    ((toRange f).app Œî x).val = f.app Œî x := rfl

instance : Epi (toRange f) :=
  inferInstanceAs (Epi (Subpresheaf.toRange f))

instance [Mono f] : Mono (toRange f) :=
  mono_of_mono_fac (toRange_Œπ f)

instance [Mono f] : IsIso (toRange f) :=
  isIso_of_mono_of_epi _

end

section

variable (X)

@[simps! inv_app_coe]
def topIso : ((‚ä§ : X.Subcomplex) : SSet) ‚âÖ X :=
  NatIso.ofComponents (fun n ‚Ü¶ (Equiv.Set.univ (X.obj n)).toIso)

@[simp]
lemma topIso_hom : (topIso X).hom = Subcomplex.Œπ _ := rfl

@[reassoc (attr := simp)]
lemma topIso_inv_Œπ : (topIso X).inv ‚â´ Subpresheaf.Œπ _ = ùüô _ := rfl

end

section

variable (f : X ‚ü∂ Y) {B : Y.Subcomplex} (hf : B.preimage f = ‚ä§)

def lift : X ‚ü∂ B :=
  (topIso X).inv ‚â´ homOfLE (by simp [hf]) ‚â´ B.fromPreimage f

@[reassoc (attr := simp)]
lemma lift_Œπ : lift f hf ‚â´ B.Œπ = f := rfl

@[simp]
lemma lift_app_coe {n : SimplexCategory·µí·µñ} (x : X.obj n) :
    ((lift f hf).app _ x).1 = f.app _ x := rfl

end

end Subcomplex

end SSet
