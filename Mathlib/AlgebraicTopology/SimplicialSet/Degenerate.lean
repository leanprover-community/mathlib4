/-
Copyright (c) 2025 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathlib.AlgebraicTopology.SimplicialSet.Basic

/-!
# Degenerate simplices

Given a simplicial set `X` and `n : ‚Ñï`, we define the sets `X.degenerate n`
and `X.nonDegenerate n` of degenerate or non-degenerate simplices of dimension `n`.

Any simplex `x : X _‚¶ãn‚¶å` can be written in a unique way as `X.map f.op y`
for an epimorphism `f : ‚¶ãn‚¶å ‚ü∂ ‚¶ãm‚¶å` and a non-degenerate `m`-simplex `y`
(see lemmas `exists_nonDegenerate`, `unique_nonDegenerate_dim`,
`unique_nonDegenerate_simplex` and `unique_nonDegenerate_map`).

-/

universe u

open CategoryTheory Simplicial Limits Opposite

namespace SSet

variable (X : SSet.{u})

/-- An `n`-simplex of a simplicial set `X` is degenerate if it is in the range
of `X.map f.op` for some morphism `f : [n] ‚ü∂ [m]` with `m < n`. -/
def degenerate (n : ‚Ñï) : Set (X _‚¶ãn‚¶å) :=
  setOf (fun x ‚Ü¶ ‚àÉ (m : ‚Ñï) (_ : m < n) (f : ‚¶ãn‚¶å ‚ü∂ ‚¶ãm‚¶å),
    x ‚àà Set.range (X.map f.op))

/-- The set of `n`-dimensional non-degenerate simplices in a simplicial
set `X` is the complement of `X.degenerate n`. -/
def nonDegenerate (n : ‚Ñï) : Set (X _‚¶ãn‚¶å) := (X.degenerate n)·∂ú

@[simp]
lemma degenerate_zero : X.degenerate 0 = ‚ä• := by
  ext x
  simp only [Set.bot_eq_empty, Set.mem_empty_iff_false, iff_false]
  rintro ‚ü®m, hm, _‚ü©
  simp at hm

@[simp]
lemma nondegenerate_zero : X.nonDegenerate 0 = ‚ä§ := by
  simp [nonDegenerate]

variable {n : ‚Ñï}

lemma mem_nonDegenerate_iff_notMem_degenerate (x : X _‚¶ãn‚¶å) :
    x ‚àà X.nonDegenerate n ‚Üî x ‚àâ X.degenerate n := Iff.rfl

@[deprecated (since := "2025-05-23")]
alias mem_nonDegenerate_iff_not_mem_degenerate := mem_nonDegenerate_iff_notMem_degenerate

lemma mem_degenerate_iff_notMem_nonDegenerate (x : X _‚¶ãn‚¶å) :
    x ‚àà X.degenerate n ‚Üî x ‚àâ X.nonDegenerate n := by
  simp [nonDegenerate]

@[deprecated (since := "2025-05-23")]
alias mem_degenerate_iff_not_mem_nonDegenerate := mem_degenerate_iff_notMem_nonDegenerate

lemma œÉ_mem_degenerate (i : Fin (n + 1)) (x : X _‚¶ãn‚¶å) :
    X.œÉ i x ‚àà X.degenerate (n + 1) :=
  ‚ü®n, by omega, SimplexCategory.œÉ i, Set.mem_range_self x‚ü©

lemma mem_degenerate_iff (x : X _‚¶ãn‚¶å) :
    x ‚àà X.degenerate n ‚Üî ‚àÉ (m : ‚Ñï) (_ : m < n) (f : ‚¶ãn‚¶å ‚ü∂ ‚¶ãm‚¶å) (_ : Epi f),
        x ‚àà Set.range (X.map f.op) := by
  constructor
  ¬∑ rintro ‚ü®m, hm, f, y, hy‚ü©
    rw [‚Üê image.fac f, op_comp] at hy
    have : _ ‚â§ m := SimplexCategory.len_le_of_mono (image.Œπ f)
    exact ‚ü®(image f).len, by omega, factorThruImage f, inferInstance, by aesop‚ü©
  ¬∑ rintro ‚ü®m, hm, f, hf, hx‚ü©
    exact ‚ü®m, hm, f, hx‚ü©

lemma degenerate_eq_iUnion_range_œÉ :
    X.degenerate (n + 1) = ‚ãÉ (i : Fin (n + 1)), Set.range (X.œÉ i) := by
  ext x
  constructor
  ¬∑ intro hx
    rw [mem_degenerate_iff] at hx
    obtain ‚ü®m, hm, f, hf, y, rfl‚ü© := hx
    obtain ‚ü®i, Œ∏, rfl‚ü© := SimplexCategory.eq_œÉ_comp_of_not_injective f (fun hf ‚Ü¶ by
      rw [‚Üê SimplexCategory.mono_iff_injective] at hf
      have := SimplexCategory.le_of_mono f
      omega)
    aesop
  ¬∑ intro hx
    simp only [Set.mem_iUnion, Set.mem_range] at hx
    obtain ‚ü®i, y, rfl‚ü© := hx
    apply œÉ_mem_degenerate

lemma exists_nonDegenerate (x : X _‚¶ãn‚¶å) :
    ‚àÉ (m : ‚Ñï) (f : ‚¶ãn‚¶å ‚ü∂ ‚¶ãm‚¶å) (_ : Epi f)
      (y : X.nonDegenerate m), x = X.map f.op y := by
  induction n with
  | zero =>
      exact ‚ü®0, ùüô _, inferInstance, ‚ü®x, by simp‚ü©, by simp‚ü©
  | succ n hn =>
      by_cases hx : x ‚àà X.nonDegenerate (n + 1)
      ¬∑ exact ‚ü®n + 1, ùüô _, inferInstance, ‚ü®x, hx‚ü©, by simp‚ü©
      ¬∑ simp only [‚Üê mem_degenerate_iff_notMem_nonDegenerate,
          degenerate_eq_iUnion_range_œÉ, Set.mem_iUnion, Set.mem_range] at hx
        obtain ‚ü®i, y, rfl‚ü© := hx
        obtain ‚ü®m, f, hf, z, rfl‚ü© := hn y
        exact ‚ü®_, SimplexCategory.œÉ i ‚â´ f, inferInstance, z, by simp; rfl‚ü©

lemma isIso_of_nonDegenerate (x : X.nonDegenerate n)
    {m : SimplexCategory} (f : ‚¶ãn‚¶å ‚ü∂ m) [Epi f]
    (y : X.obj (op m)) (hy : X.map f.op y = x) :
    IsIso f := by
  obtain ‚ü®x, hx‚ü© := x
  induction' m using SimplexCategory.rec with m
  rw [mem_nonDegenerate_iff_notMem_degenerate] at hx
  by_contra!
  refine hx ‚ü®_, not_le.1 (fun h ‚Ü¶ this ?_), f, y, hy‚ü©
  rw [SimplexCategory.isIso_iff_of_epi]
  exact le_antisymm h (SimplexCategory.len_le_of_epi f)

namespace unique_nonDegenerate

/-!
Auxiliary definitions and lemmas for the lemmas
`unique_nonDegenerate_dim`, `unique_nonDegenerate_simplex` and
`unique_nonDegenerate_map` which assert the uniqueness of the
decomposition obtained in the lemma `exists_nonDegenerate`.
-/

section

variable {X} {x : X _‚¶ãn‚¶å}
  {m‚ÇÅ m‚ÇÇ : ‚Ñï} {f‚ÇÅ : ‚¶ãn‚¶å ‚ü∂ ‚¶ãm‚ÇÅ‚¶å} (hf‚ÇÅ : SplitEpi f‚ÇÅ)
  (y‚ÇÅ : X.nonDegenerate m‚ÇÅ) (hy‚ÇÅ : x = X.map f‚ÇÅ.op y‚ÇÅ)
  (f‚ÇÇ : ‚¶ãn‚¶å ‚ü∂ ‚¶ãm‚ÇÇ‚¶å) (y‚ÇÇ : X _‚¶ãm‚ÇÇ‚¶å) (hy‚ÇÇ : x = X.map f‚ÇÇ.op y‚ÇÇ)

/-- The composition of a section of `f‚ÇÅ` and `f‚ÇÇ`. It is proven below that it
is the identity, see `g_eq_id`. -/
private def g := hf‚ÇÅ.section_ ‚â´ f‚ÇÇ

variable {f‚ÇÇ y‚ÇÅ y‚ÇÇ}

include hf‚ÇÅ hy‚ÇÅ hy‚ÇÇ

private lemma map_g_op_y‚ÇÇ : X.map (g hf‚ÇÅ f‚ÇÇ).op y‚ÇÇ = y‚ÇÅ := by
  dsimp [g]
  rw [FunctorToTypes.map_comp_apply, ‚Üê hy‚ÇÇ, hy‚ÇÅ, ‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp,
    SplitEpi.id, op_id, FunctorToTypes.map_id_apply]

private lemma isIso_factorThruImage_g :
    IsIso (factorThruImage (g hf‚ÇÅ f‚ÇÇ)) := by
  have := map_g_op_y‚ÇÇ hf‚ÇÅ hy‚ÇÅ hy‚ÇÇ
  rw [‚Üê image.fac (g hf‚ÇÅ f‚ÇÇ), op_comp, FunctorToTypes.map_comp_apply] at this
  exact X.isIso_of_nonDegenerate y‚ÇÅ (factorThruImage (g hf‚ÇÅ f‚ÇÇ)) _ this

private lemma mono_g : Mono (g hf‚ÇÅ f‚ÇÇ) := by
  have := isIso_factorThruImage_g hf‚ÇÅ hy‚ÇÅ hy‚ÇÇ
  rw [‚Üê image.fac (g hf‚ÇÅ f‚ÇÇ)]
  infer_instance

private lemma le : m‚ÇÅ ‚â§ m‚ÇÇ :=
  have := isIso_factorThruImage_g hf‚ÇÅ hy‚ÇÅ hy‚ÇÇ
  SimplexCategory.len_le_of_mono
    (factorThruImage (g hf‚ÇÅ f‚ÇÇ) ‚â´ image.Œπ _)

end

variable {X} in
private lemma g_eq_id {x : X _‚¶ãn‚¶å} {m : ‚Ñï} {f‚ÇÅ : ‚¶ãn‚¶å ‚ü∂ ‚¶ãm‚¶å}
    {y‚ÇÅ : X.nonDegenerate m} (hy‚ÇÅ : x = X.map f‚ÇÅ.op y‚ÇÅ)
    {f‚ÇÇ : ‚¶ãn‚¶å ‚ü∂ ‚¶ãm‚¶å} {y‚ÇÇ : X _‚¶ãm‚¶å} (hy‚ÇÇ : x = X.map f‚ÇÇ.op y‚ÇÇ) (hf‚ÇÅ : SplitEpi f‚ÇÅ) :
    g hf‚ÇÅ f‚ÇÇ = ùüô _ := by
  have := mono_g hf‚ÇÅ hy‚ÇÅ hy‚ÇÇ
  apply SimplexCategory.eq_id_of_mono

end unique_nonDegenerate

section

open unique_nonDegenerate

/-!
The following lemmas `unique_nonDegenerate_dim`, `unique_nonDegenerate_simplex` and
`unique_nonDegenerate_map` assert the uniqueness of the decomposition
obtained in the lemma `exists_nonDegenerate`.
-/

lemma unique_nonDegenerate_dim (x : X _‚¶ãn‚¶å) {m‚ÇÅ m‚ÇÇ : ‚Ñï}
    (f‚ÇÅ : ‚¶ãn‚¶å ‚ü∂ ‚¶ãm‚ÇÅ‚¶å) [Epi f‚ÇÅ] (y‚ÇÅ : X.nonDegenerate m‚ÇÅ) (hy‚ÇÅ : x = X.map f‚ÇÅ.op y‚ÇÅ)
    (f‚ÇÇ : ‚¶ãn‚¶å ‚ü∂ ‚¶ãm‚ÇÇ‚¶å) [Epi f‚ÇÇ] (y‚ÇÇ : X.nonDegenerate m‚ÇÇ) (hy‚ÇÇ : x = X.map f‚ÇÇ.op y‚ÇÇ) :
    m‚ÇÅ = m‚ÇÇ := by
  obtain ‚ü®‚ü®hf‚ÇÅ‚ü©‚ü© := isSplitEpi_of_epi f‚ÇÅ
  obtain ‚ü®‚ü®hf‚ÇÇ‚ü©‚ü© := isSplitEpi_of_epi f‚ÇÇ
  exact le_antisymm (le hf‚ÇÅ hy‚ÇÅ hy‚ÇÇ) (le hf‚ÇÇ hy‚ÇÇ hy‚ÇÅ)

lemma unique_nonDegenerate_simplex (x : X _‚¶ãn‚¶å) {m : ‚Ñï}
    (f‚ÇÅ : ‚¶ãn‚¶å ‚ü∂ ‚¶ãm‚¶å) [Epi f‚ÇÅ] (y‚ÇÅ : X.nonDegenerate m) (hy‚ÇÅ : x = X.map f‚ÇÅ.op y‚ÇÅ)
    (f‚ÇÇ : ‚¶ãn‚¶å ‚ü∂ ‚¶ãm‚¶å) (y‚ÇÇ : X.nonDegenerate m) (hy‚ÇÇ : x = X.map f‚ÇÇ.op y‚ÇÇ) :
    y‚ÇÅ = y‚ÇÇ := by
  obtain ‚ü®‚ü®hf‚ÇÅ‚ü©‚ü© := isSplitEpi_of_epi f‚ÇÅ
  ext
  simpa [g_eq_id hy‚ÇÅ hy‚ÇÇ hf‚ÇÅ] using (map_g_op_y‚ÇÇ hf‚ÇÅ hy‚ÇÅ hy‚ÇÇ).symm

lemma unique_nonDegenerate_map (x : X _‚¶ãn‚¶å) {m : ‚Ñï}
    (f‚ÇÅ : ‚¶ãn‚¶å ‚ü∂ ‚¶ãm‚¶å) [Epi f‚ÇÅ] (y‚ÇÅ : X.nonDegenerate m) (hy‚ÇÅ : x = X.map f‚ÇÅ.op y‚ÇÅ)
    (f‚ÇÇ : ‚¶ãn‚¶å ‚ü∂ ‚¶ãm‚¶å) (y‚ÇÇ : X.nonDegenerate m) (hy‚ÇÇ : x = X.map f‚ÇÇ.op y‚ÇÇ) :
    f‚ÇÅ = f‚ÇÇ := by
  ext x : 3
  suffices ‚àÉ (hf‚ÇÅ : SplitEpi f‚ÇÅ), hf‚ÇÅ.section_.toOrderHom (f‚ÇÅ.toOrderHom x) = x by
    obtain ‚ü®hf‚ÇÅ, hf‚ÇÅ'‚ü© := this
    dsimp at hf‚ÇÅ'
    simpa [g, hf‚ÇÅ'] using (SimplexCategory.congr_toOrderHom_apply (g_eq_id hy‚ÇÅ hy‚ÇÇ hf‚ÇÅ)
      (f‚ÇÅ.toOrderHom x)).symm
  obtain ‚ü®‚ü®hf‚ü©‚ü© := isSplitEpi_of_epi f‚ÇÅ
  let Œ± (y : Fin (m + 1)) : Fin (n + 1) :=
    if y = f‚ÇÅ.toOrderHom x then x else hf.section_.toOrderHom y
  have hŒ±‚ÇÅ (y : Fin (m + 1)) : f‚ÇÅ.toOrderHom (Œ± y) = y := by
    dsimp [Œ±]
    split_ifs with hy
    ¬∑ rw [hy]
    ¬∑ apply SimplexCategory.congr_toOrderHom_apply hf.id
  have hŒ±‚ÇÇ : Monotone Œ± := by
    rintro y‚ÇÅ y‚ÇÇ h
    by_contra! h'
    suffices y‚ÇÇ ‚â§ y‚ÇÅ by simp [show y‚ÇÅ = y‚ÇÇ by omega] at h'
    simpa only [hŒ±‚ÇÅ] using f‚ÇÅ.toOrderHom.monotone h'.le
  exact ‚ü®{ section_ := SimplexCategory.Hom.mk ‚ü®Œ±, hŒ±‚ÇÇ‚ü©, id := by ext : 3; apply hŒ±‚ÇÅ },
    by simp [Œ±]‚ü©

end

end SSet
