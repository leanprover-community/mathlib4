/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl
-/
import Mathlib.Order.CompleteLattice
import Mathlib.Order.Synonym
import Mathlib.Order.Hom.Set
import Mathlib.Order.Bounds.Basic

#align_import order.galois_connection from "leanprover-community/mathlib"@"c5c7e2760814660967bc27f0de95d190a22297f3"

/-!
# Galois connections, insertions and coinsertions

Galois connections are order theoretic adjoints, i.e. a pair of functions `u` and `l`,
such that `‚àÄ a b, l a ‚â§ b ‚Üî a ‚â§ u b`.

## Main definitions

* `GaloisConnection`: A Galois connection is a pair of functions `l` and `u` satisfying
  `l a ‚â§ b ‚Üî a ‚â§ u b`. They are special cases of adjoint functors in category theory,
  but do not depend on the category theory library in mathlib.
* `GaloisInsertion`: A Galois insertion is a Galois connection where `l ‚àò u = id`
* `GaloisCoinsertion`: A Galois coinsertion is a Galois connection where `u ‚àò l = id`

## Implementation details

Galois insertions can be used to lift order structures from one type to another.
For example if `Œ±` is a complete lattice, and `l : Œ± ‚Üí Œ≤`, and `u : Œ≤ ‚Üí Œ±` form a Galois insertion,
then `Œ≤` is also a complete lattice. `l` is the lower adjoint and `u` is the upper adjoint.

An example of a Galois insertion is in group theory. If `G` is a group, then there is a Galois
insertion between the set of subsets of `G`, `Set G`, and the set of subgroups of `G`,
`Subgroup G`. The lower adjoint is `Subgroup.closure`, taking the `Subgroup` generated by a `Set`,
and the upper adjoint is the coercion from `Subgroup G` to `Set G`, taking the underlying set
of a subgroup.

Naively lifting a lattice structure along this Galois insertion would mean that the definition
of `inf` on subgroups would be `Subgroup.closure (‚ÜëS ‚à© ‚ÜëT)`. This is an undesirable definition
because the intersection of subgroups is already a subgroup, so there is no need to take the
closure. For this reason a `choice` function is added as a field to the `GaloisInsertion`
structure. It has type `Œ† S : Set G, ‚Üë(closure S) ‚â§ S ‚Üí Subgroup G`. When `‚Üë(closure S) ‚â§ S`, then
`S` is already a subgroup, so this function can be defined using `Subgroup.mk` and not `closure`.
This means the infimum of subgroups will be defined to be the intersection of sets, paired
with a proof that intersection of subgroups is a subgroup, rather than the closure of the
intersection.
-/


open Function OrderDual Set

universe u v w x

variable {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} {Œπ : Sort x} {Œ∫ : Œπ ‚Üí Sort*} {a a‚ÇÅ a‚ÇÇ : Œ±}
  {b b‚ÇÅ b‚ÇÇ : Œ≤}

/-- A Galois connection is a pair of functions `l` and `u` satisfying
  `l a ‚â§ b ‚Üî a ‚â§ u b`. They are special cases of adjoint functors in category theory,
    but do not depend on the category theory library in mathlib. -/
def GaloisConnection [Preorder Œ±] [Preorder Œ≤] (l : Œ± ‚Üí Œ≤) (u : Œ≤ ‚Üí Œ±) :=
  ‚àÄ a b, l a ‚â§ b ‚Üî a ‚â§ u b
#align galois_connection GaloisConnection

/-- Makes a Galois connection from an order-preserving bijection. -/
theorem OrderIso.to_galoisConnection [Preorder Œ±] [Preorder Œ≤] (oi : Œ± ‚âÉo Œ≤) :
    GaloisConnection oi oi.symm := fun _ _ => oi.rel_symm_apply.symm
#align order_iso.to_galois_connection OrderIso.to_galoisConnection

namespace GaloisConnection

section

variable [Preorder Œ±] [Preorder Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : GaloisConnection l u)

theorem monotone_intro (hu : Monotone u) (hl : Monotone l) (hul : ‚àÄ a, a ‚â§ u (l a))
    (hlu : ‚àÄ a, l (u a) ‚â§ a) : GaloisConnection l u := fun _ _ =>
  ‚ü®fun h => (hul _).trans (hu h), fun h => (hl h).trans (hlu _)‚ü©
#align galois_connection.monotone_intro GaloisConnection.monotone_intro

protected theorem dual {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : GaloisConnection l u) :
    GaloisConnection (OrderDual.toDual ‚àò u ‚àò OrderDual.ofDual)
      (OrderDual.toDual ‚àò l ‚àò OrderDual.ofDual) :=
  fun a b => (gc b a).symm
#align galois_connection.dual GaloisConnection.dual

theorem le_iff_le {a : Œ±} {b : Œ≤} : l a ‚â§ b ‚Üî a ‚â§ u b :=
  gc _ _
#align galois_connection.le_iff_le GaloisConnection.le_iff_le

theorem l_le {a : Œ±} {b : Œ≤} : a ‚â§ u b ‚Üí l a ‚â§ b :=
  (gc _ _).mpr
#align galois_connection.l_le GaloisConnection.l_le

theorem le_u {a : Œ±} {b : Œ≤} : l a ‚â§ b ‚Üí a ‚â§ u b :=
  (gc _ _).mp
#align galois_connection.le_u GaloisConnection.le_u

theorem le_u_l (a) : a ‚â§ u (l a) :=
  gc.le_u <| le_rfl
#align galois_connection.le_u_l GaloisConnection.le_u_l

theorem l_u_le (a) : l (u a) ‚â§ a :=
  gc.l_le <| le_rfl
#align galois_connection.l_u_le GaloisConnection.l_u_le

theorem monotone_u : Monotone u := fun a _ H => gc.le_u ((gc.l_u_le a).trans H)
#align galois_connection.monotone_u GaloisConnection.monotone_u

theorem monotone_l : Monotone l :=
  gc.dual.monotone_u.dual
#align galois_connection.monotone_l GaloisConnection.monotone_l

theorem upperBounds_l_image (s : Set Œ±) : upperBounds (l '' s) = u ‚Åª¬π' upperBounds s :=
  Set.ext fun b => by simp [upperBounds, gc _ _]
                      -- üéâ no goals
#align galois_connection.upper_bounds_l_image GaloisConnection.upperBounds_l_image

theorem lowerBounds_u_image (s : Set Œ≤) : lowerBounds (u '' s) = l ‚Åª¬π' lowerBounds s :=
  gc.dual.upperBounds_l_image s
#align galois_connection.lower_bounds_u_image GaloisConnection.lowerBounds_u_image

theorem bddAbove_l_image {s : Set Œ±} : BddAbove (l '' s) ‚Üî BddAbove s :=
  ‚ü®fun ‚ü®x, hx‚ü© => ‚ü®u x, by rwa [gc.upperBounds_l_image] at hx‚ü©, gc.monotone_l.map_bddAbove‚ü©
                           -- üéâ no goals
#align galois_connection.bdd_above_l_image GaloisConnection.bddAbove_l_image

theorem bddBelow_u_image {s : Set Œ≤} : BddBelow (u '' s) ‚Üî BddBelow s :=
  gc.dual.bddAbove_l_image
#align galois_connection.bdd_below_u_image GaloisConnection.bddBelow_u_image

theorem isLUB_l_image {s : Set Œ±} {a : Œ±} (h : IsLUB s a) : IsLUB (l '' s) (l a) :=
  ‚ü®gc.monotone_l.mem_upperBounds_image h.left, fun b hb =>
    gc.l_le <| h.right <| by rwa [gc.upperBounds_l_image] at hb‚ü©
                             -- üéâ no goals
#align galois_connection.is_lub_l_image GaloisConnection.isLUB_l_image

theorem isGLB_u_image {s : Set Œ≤} {b : Œ≤} (h : IsGLB s b) : IsGLB (u '' s) (u b) :=
  gc.dual.isLUB_l_image h
#align galois_connection.is_glb_u_image GaloisConnection.isGLB_u_image

theorem isLeast_l {a : Œ±} : IsLeast { b | a ‚â§ u b } (l a) :=
  ‚ü®gc.le_u_l _, fun _ hb => gc.l_le hb‚ü©
#align galois_connection.is_least_l GaloisConnection.isLeast_l

theorem isGreatest_u {b : Œ≤} : IsGreatest { a | l a ‚â§ b } (u b) :=
  gc.dual.isLeast_l
#align galois_connection.is_greatest_u GaloisConnection.isGreatest_u

theorem isGLB_l {a : Œ±} : IsGLB { b | a ‚â§ u b } (l a) :=
  gc.isLeast_l.isGLB
#align galois_connection.is_glb_l GaloisConnection.isGLB_l

theorem isLUB_u {b : Œ≤} : IsLUB { a | l a ‚â§ b } (u b) :=
  gc.isGreatest_u.isLUB
#align galois_connection.is_lub_u GaloisConnection.isLUB_u

/-- If `(l, u)` is a Galois connection, then the relation `x ‚â§ u (l y)` is a transitive relation.
If `l` is a closure operator (`Submodule.span`, `Subgroup.closure`, ...) and `u` is the coercion to
`Set`, this reads as "if `U` is in the closure of `V` and `V` is in the closure of `W` then `U` is
in the closure of `W`". -/
theorem le_u_l_trans {x y z : Œ±} (hxy : x ‚â§ u (l y)) (hyz : y ‚â§ u (l z)) : x ‚â§ u (l z) :=
  hxy.trans (gc.monotone_u <| gc.l_le hyz)
#align galois_connection.le_u_l_trans GaloisConnection.le_u_l_trans

theorem l_u_le_trans {x y z : Œ≤} (hxy : l (u x) ‚â§ y) (hyz : l (u y) ‚â§ z) : l (u x) ‚â§ z :=
  (gc.monotone_l <| gc.le_u hxy).trans hyz
#align galois_connection.l_u_le_trans GaloisConnection.l_u_le_trans

end

section PartialOrder

variable [PartialOrder Œ±] [Preorder Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : GaloisConnection l u)

theorem u_l_u_eq_u (b : Œ≤) : u (l (u b)) = u b :=
  (gc.monotone_u (gc.l_u_le _)).antisymm (gc.le_u_l _)
#align galois_connection.u_l_u_eq_u GaloisConnection.u_l_u_eq_u

theorem u_l_u_eq_u' : u ‚àò l ‚àò u = u :=
  funext gc.u_l_u_eq_u
#align galois_connection.u_l_u_eq_u' GaloisConnection.u_l_u_eq_u'

theorem u_unique {l' : Œ± ‚Üí Œ≤} {u' : Œ≤ ‚Üí Œ±} (gc' : GaloisConnection l' u') (hl : ‚àÄ a, l a = l' a)
    {b : Œ≤} : u b = u' b :=
  le_antisymm (gc'.le_u <| hl (u b) ‚ñ∏ gc.l_u_le _) (gc.le_u <| (hl (u' b)).symm ‚ñ∏ gc'.l_u_le _)
#align galois_connection.u_unique GaloisConnection.u_unique

/-- If there exists a `b` such that `a = u a`, then `b = l a` is one such element. -/
theorem exists_eq_u (a : Œ±) : (‚àÉ b : Œ≤, a = u b) ‚Üî a = u (l a) :=
  ‚ü®fun ‚ü®_, hS‚ü© => hS.symm ‚ñ∏ (gc.u_l_u_eq_u _).symm, fun HI => ‚ü®_, HI‚ü©‚ü©
#align galois_connection.exists_eq_u GaloisConnection.exists_eq_u

theorem u_eq {z : Œ±} {y : Œ≤} : u y = z ‚Üî ‚àÄ x, x ‚â§ z ‚Üî l x ‚â§ y := by
  constructor
  -- ‚ä¢ u y = z ‚Üí ‚àÄ (x : Œ±), x ‚â§ z ‚Üî l x ‚â§ y
  ¬∑ rintro rfl x
    -- ‚ä¢ x ‚â§ u y ‚Üî l x ‚â§ y
    exact (gc x y).symm
    -- üéâ no goals
  ¬∑ intro H
    -- ‚ä¢ u y = z
    exact ((H <| u y).mpr (gc.l_u_le y)).antisymm ((gc _ _).mp <| (H z).mp le_rfl)
    -- üéâ no goals
#align galois_connection.u_eq GaloisConnection.u_eq

end PartialOrder

section PartialOrder

variable [Preorder Œ±] [PartialOrder Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : GaloisConnection l u)

theorem l_u_l_eq_l (a : Œ±) : l (u (l a)) = l a :=
  (gc.l_u_le _).antisymm (gc.monotone_l (gc.le_u_l _))
#align galois_connection.l_u_l_eq_l GaloisConnection.l_u_l_eq_l

theorem l_u_l_eq_l' : l ‚àò u ‚àò l = l :=
  funext gc.l_u_l_eq_l
#align galois_connection.l_u_l_eq_l' GaloisConnection.l_u_l_eq_l'

theorem l_unique {l' : Œ± ‚Üí Œ≤} {u' : Œ≤ ‚Üí Œ±} (gc' : GaloisConnection l' u') (hu : ‚àÄ b, u b = u' b)
    {a : Œ±} : l a = l' a :=
  le_antisymm (gc.l_le <| (hu (l' a)).symm ‚ñ∏ gc'.le_u_l _) (gc'.l_le <| hu (l a) ‚ñ∏ gc.le_u_l _)
#align galois_connection.l_unique GaloisConnection.l_unique

/-- If there exists an `a` such that `b = l a`, then `a = u b` is one such element. -/
theorem exists_eq_l (b : Œ≤) : (‚àÉ a : Œ±, b = l a) ‚Üî b = l (u b) :=
  ‚ü®fun ‚ü®_, hS‚ü© => hS.symm ‚ñ∏ (gc.l_u_l_eq_l _).symm, fun HI => ‚ü®_, HI‚ü©‚ü©
#align galois_connection.exists_eq_l GaloisConnection.exists_eq_l

theorem l_eq {x : Œ±} {z : Œ≤} : l x = z ‚Üî ‚àÄ y, z ‚â§ y ‚Üî x ‚â§ u y := by
  constructor
  -- ‚ä¢ l x = z ‚Üí ‚àÄ (y : Œ≤), z ‚â§ y ‚Üî x ‚â§ u y
  ¬∑ rintro rfl y
    -- ‚ä¢ l x ‚â§ y ‚Üî x ‚â§ u y
    exact gc x y
    -- üéâ no goals
  ¬∑ intro H
    -- ‚ä¢ l x = z
    exact ((gc _ _).mpr <| (H z).mp le_rfl).antisymm ((H <| l x).mpr (gc.le_u_l x))
    -- üéâ no goals
#align galois_connection.l_eq GaloisConnection.l_eq

end PartialOrder

section OrderTop

variable [PartialOrder Œ±] [Preorder Œ≤] [OrderTop Œ±]

theorem u_eq_top {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : GaloisConnection l u) {x} : u x = ‚ä§ ‚Üî l ‚ä§ ‚â§ x :=
  top_le_iff.symm.trans gc.le_iff_le.symm
#align galois_connection.u_eq_top GaloisConnection.u_eq_top

theorem u_top [OrderTop Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : GaloisConnection l u) : u ‚ä§ = ‚ä§ :=
  gc.u_eq_top.2 le_top
#align galois_connection.u_top GaloisConnection.u_top

end OrderTop

section OrderBot

variable [Preorder Œ±] [PartialOrder Œ≤] [OrderBot Œ≤]

theorem l_eq_bot {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : GaloisConnection l u) {x} : l x = ‚ä• ‚Üî x ‚â§ u ‚ä• :=
  gc.dual.u_eq_top
#align galois_connection.l_eq_bot GaloisConnection.l_eq_bot

theorem l_bot [OrderBot Œ±] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : GaloisConnection l u) : l ‚ä• = ‚ä• :=
  gc.dual.u_top
#align galois_connection.l_bot GaloisConnection.l_bot

end OrderBot

section SemilatticeSup

variable [SemilatticeSup Œ±] [SemilatticeSup Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : GaloisConnection l u)

theorem l_sup : l (a‚ÇÅ ‚äî a‚ÇÇ) = l a‚ÇÅ ‚äî l a‚ÇÇ :=
  (gc.isLUB_l_image isLUB_pair).unique <| by simp only [image_pair, isLUB_pair]
                                             -- üéâ no goals
#align galois_connection.l_sup GaloisConnection.l_sup

end SemilatticeSup

section SemilatticeInf

variable [SemilatticeInf Œ±] [SemilatticeInf Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : GaloisConnection l u)

theorem u_inf : u (b‚ÇÅ ‚äì b‚ÇÇ) = u b‚ÇÅ ‚äì u b‚ÇÇ :=
  gc.dual.l_sup
#align galois_connection.u_inf GaloisConnection.u_inf

end SemilatticeInf

section CompleteLattice

variable [CompleteLattice Œ±] [CompleteLattice Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : GaloisConnection l u)

theorem l_iSup {f : Œπ ‚Üí Œ±} : l (iSup f) = ‚®Ü i, l (f i) :=
  Eq.symm <|
    IsLUB.iSup_eq <|
      show IsLUB (range (l ‚àò f)) (l (iSup f)) by
        rw [range_comp, ‚Üê sSup_range]; exact gc.isLUB_l_image (isLUB_sSup _)
        -- ‚ä¢ IsLUB (l '' range f) (l (sSup (range f)))
                                       -- üéâ no goals
#align galois_connection.l_supr GaloisConnection.l_iSup

theorem l_iSup‚ÇÇ {f : ‚àÄ i, Œ∫ i ‚Üí Œ±} : l (‚®Ü (i) (j), f i j) = ‚®Ü (i) (j), l (f i j) := by
  simp_rw [gc.l_iSup]
  -- üéâ no goals
#align galois_connection.l_supr‚ÇÇ GaloisConnection.l_iSup‚ÇÇ

theorem u_iInf {f : Œπ ‚Üí Œ≤} : u (iInf f) = ‚®Ö i, u (f i) :=
  gc.dual.l_iSup
#align galois_connection.u_infi GaloisConnection.u_iInf

theorem u_iInf‚ÇÇ {f : ‚àÄ i, Œ∫ i ‚Üí Œ≤} : u (‚®Ö (i) (j), f i j) = ‚®Ö (i) (j), u (f i j) :=
  gc.dual.l_iSup‚ÇÇ
#align galois_connection.u_infi‚ÇÇ GaloisConnection.u_iInf‚ÇÇ

theorem l_sSup {s : Set Œ±} : l (sSup s) = ‚®Ü a ‚àà s, l a := by simp only [sSup_eq_iSup, gc.l_iSup]
                                                             -- üéâ no goals
#align galois_connection.l_Sup GaloisConnection.l_sSup

theorem u_sInf {s : Set Œ≤} : u (sInf s) = ‚®Ö a ‚àà s, u a :=
  gc.dual.l_sSup
#align galois_connection.u_Inf GaloisConnection.u_sInf

end CompleteLattice

section LinearOrder

variable [LinearOrder Œ±] [LinearOrder Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : GaloisConnection l u)

theorem lt_iff_lt {a : Œ±} {b : Œ≤} : b < l a ‚Üî u b < a :=
  lt_iff_lt_of_le_iff_le (gc a b)
#align galois_connection.lt_iff_lt GaloisConnection.lt_iff_lt

end LinearOrder

-- Constructing Galois connections
section Constructions

protected theorem id [pŒ± : Preorder Œ±] : @GaloisConnection Œ± Œ± pŒ± pŒ± id id := fun _ _ =>
  Iff.intro (fun x => x) fun x => x
#align galois_connection.id GaloisConnection.id

protected theorem compose [Preorder Œ±] [Preorder Œ≤] [Preorder Œ≥] {l1 : Œ± ‚Üí Œ≤} {u1 : Œ≤ ‚Üí Œ±}
    {l2 : Œ≤ ‚Üí Œ≥} {u2 : Œ≥ ‚Üí Œ≤} (gc1 : GaloisConnection l1 u1) (gc2 : GaloisConnection l2 u2) :
    GaloisConnection (l2 ‚àò l1) (u1 ‚àò u2) := by intro a b; dsimp; rw [gc2, gc1]
                                               -- ‚ä¢ (l2 ‚àò l1) a ‚â§ b ‚Üî a ‚â§ (u1 ‚àò u2) b
                                                          -- ‚ä¢ l2 (l1 a) ‚â§ b ‚Üî a ‚â§ u1 (u2 b)
                                                                 -- üéâ no goals
#align galois_connection.compose GaloisConnection.compose

protected theorem dfun {Œπ : Type u} {Œ± : Œπ ‚Üí Type v} {Œ≤ : Œπ ‚Üí Type w} [‚àÄ i, Preorder (Œ± i)]
    [‚àÄ i, Preorder (Œ≤ i)] (l : ‚àÄ i, Œ± i ‚Üí Œ≤ i) (u : ‚àÄ i, Œ≤ i ‚Üí Œ± i)
    (gc : ‚àÄ i, GaloisConnection (l i) (u i)) :
    GaloisConnection (fun (a : ‚àÄ i, Œ± i) i => l i (a i)) fun b i => u i (b i) := fun a b =>
  forall_congr' fun i => gc i (a i) (b i)
#align galois_connection.dfun GaloisConnection.dfun

protected theorem compl [BooleanAlgebra Œ±] [BooleanAlgebra Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±}
    (gc : GaloisConnection l u) :
    GaloisConnection (compl ‚àò u ‚àò compl) (compl ‚àò l ‚àò compl) := by
  intro a b
  -- ‚ä¢ (compl ‚àò u ‚àò compl) a ‚â§ b ‚Üî a ‚â§ (compl ‚àò l ‚àò compl) b
  dsimp
  -- ‚ä¢ (u a·∂ú)·∂ú ‚â§ b ‚Üî a ‚â§ (l b·∂ú)·∂ú
  rw [le_compl_iff_le_compl, gc, compl_le_iff_compl_le]
  -- üéâ no goals

end Constructions

theorem l_comm_of_u_comm {X : Type*} [Preorder X] {Y : Type*} [Preorder Y] {Z : Type*}
    [Preorder Z] {W : Type*} [PartialOrder W] {lYX : X ‚Üí Y} {uXY : Y ‚Üí X}
    (hXY : GaloisConnection lYX uXY) {lWZ : Z ‚Üí W} {uZW : W ‚Üí Z} (hZW : GaloisConnection lWZ uZW)
    {lWY : Y ‚Üí W} {uYW : W ‚Üí Y} (hWY : GaloisConnection lWY uYW) {lZX : X ‚Üí Z} {uXZ : Z ‚Üí X}
    (hXZ : GaloisConnection lZX uXZ) (h : ‚àÄ w, uXZ (uZW w) = uXY (uYW w)) {x : X} :
    lWZ (lZX x) = lWY (lYX x) :=
  (hXZ.compose hZW).l_unique (hXY.compose hWY) h
#align galois_connection.l_comm_of_u_comm GaloisConnection.l_comm_of_u_comm

theorem u_comm_of_l_comm {X : Type*} [PartialOrder X] {Y : Type*} [Preorder Y] {Z : Type*}
    [Preorder Z] {W : Type*} [Preorder W] {lYX : X ‚Üí Y} {uXY : Y ‚Üí X}
    (hXY : GaloisConnection lYX uXY) {lWZ : Z ‚Üí W} {uZW : W ‚Üí Z} (hZW : GaloisConnection lWZ uZW)
    {lWY : Y ‚Üí W} {uYW : W ‚Üí Y} (hWY : GaloisConnection lWY uYW) {lZX : X ‚Üí Z} {uXZ : Z ‚Üí X}
    (hXZ : GaloisConnection lZX uXZ) (h : ‚àÄ x, lWZ (lZX x) = lWY (lYX x)) {w : W} :
    uXZ (uZW w) = uXY (uYW w) :=
  (hXZ.compose hZW).u_unique (hXY.compose hWY) h
#align galois_connection.u_comm_of_l_comm GaloisConnection.u_comm_of_l_comm

theorem l_comm_iff_u_comm {X : Type*} [PartialOrder X] {Y : Type*} [Preorder Y] {Z : Type*}
    [Preorder Z] {W : Type*} [PartialOrder W] {lYX : X ‚Üí Y} {uXY : Y ‚Üí X}
    (hXY : GaloisConnection lYX uXY) {lWZ : Z ‚Üí W} {uZW : W ‚Üí Z} (hZW : GaloisConnection lWZ uZW)
    {lWY : Y ‚Üí W} {uYW : W ‚Üí Y} (hWY : GaloisConnection lWY uYW) {lZX : X ‚Üí Z} {uXZ : Z ‚Üí X}
    (hXZ : GaloisConnection lZX uXZ) :
    (‚àÄ w : W, uXZ (uZW w) = uXY (uYW w)) ‚Üî ‚àÄ x : X, lWZ (lZX x) = lWY (lYX x) :=
  ‚ü®hXY.l_comm_of_u_comm hZW hWY hXZ, hXY.u_comm_of_l_comm hZW hWY hXZ‚ü©
#align galois_connection.l_comm_iff_u_comm GaloisConnection.l_comm_iff_u_comm

end GaloisConnection

section

variable [CompleteLattice Œ±] [CompleteLattice Œ≤] [CompleteLattice Œ≥] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {s : Set Œ±}
  {t : Set Œ≤} {l u : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {l‚ÇÅ u‚ÇÅ : Œ≤ ‚Üí Œ≥ ‚Üí Œ±} {l‚ÇÇ u‚ÇÇ : Œ± ‚Üí Œ≥ ‚Üí Œ≤}

theorem sSup_image2_eq_sSup_sSup (h‚ÇÅ : ‚àÄ b, GaloisConnection (swap l b) (u‚ÇÅ b))
    (h‚ÇÇ : ‚àÄ a, GaloisConnection (l a) (u‚ÇÇ a)) : sSup (image2 l s t) = l (sSup s) (sSup t) := by
  simp_rw [sSup_image2, ‚Üê (h‚ÇÇ _).l_sSup, ‚Üê (h‚ÇÅ _).l_sSup]
  -- üéâ no goals
#align Sup_image2_eq_Sup_Sup sSup_image2_eq_sSup_sSup

theorem sSup_image2_eq_sSup_sInf (h‚ÇÅ : ‚àÄ b, GaloisConnection (swap l b) (u‚ÇÅ b))
    (h‚ÇÇ : ‚àÄ a, GaloisConnection (l a ‚àò ofDual) (toDual ‚àò u‚ÇÇ a)) :
    sSup (image2 l s t) = l (sSup s) (sInf t) :=
  @sSup_image2_eq_sSup_sSup _ Œ≤·µí·µà _ _ _ _ _ _ _ _ _ h‚ÇÅ h‚ÇÇ
#align Sup_image2_eq_Sup_Inf sSup_image2_eq_sSup_sInf

theorem sSup_image2_eq_sInf_sSup (h‚ÇÅ : ‚àÄ b, GaloisConnection (swap l b ‚àò ofDual) (toDual ‚àò u‚ÇÅ b))
    (h‚ÇÇ : ‚àÄ a, GaloisConnection (l a) (u‚ÇÇ a)) : sSup (image2 l s t) = l (sInf s) (sSup t) :=
  @sSup_image2_eq_sSup_sSup Œ±·µí·µà _ _ _ _ _ _ _ _ _ _ h‚ÇÅ h‚ÇÇ
#align Sup_image2_eq_Inf_Sup sSup_image2_eq_sInf_sSup

theorem sSup_image2_eq_sInf_sInf (h‚ÇÅ : ‚àÄ b, GaloisConnection (swap l b ‚àò ofDual) (toDual ‚àò u‚ÇÅ b))
    (h‚ÇÇ : ‚àÄ a, GaloisConnection (l a ‚àò ofDual) (toDual ‚àò u‚ÇÇ a)) :
    sSup (image2 l s t) = l (sInf s) (sInf t) :=
  @sSup_image2_eq_sSup_sSup Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ _ _ _ h‚ÇÅ h‚ÇÇ
#align Sup_image2_eq_Inf_Inf sSup_image2_eq_sInf_sInf

theorem sInf_image2_eq_sInf_sInf (h‚ÇÅ : ‚àÄ b, GaloisConnection (l‚ÇÅ b) (swap u b))
    (h‚ÇÇ : ‚àÄ a, GaloisConnection (l‚ÇÇ a) (u a)) : sInf (image2 u s t) = u (sInf s) (sInf t) := by
  simp_rw [sInf_image2, ‚Üê (h‚ÇÇ _).u_sInf, ‚Üê (h‚ÇÅ _).u_sInf]
  -- üéâ no goals
#align Inf_image2_eq_Inf_Inf sInf_image2_eq_sInf_sInf

theorem sInf_image2_eq_sInf_sSup (h‚ÇÅ : ‚àÄ b, GaloisConnection (l‚ÇÅ b) (swap u b))
    (h‚ÇÇ : ‚àÄ a, GaloisConnection (toDual ‚àò l‚ÇÇ a) (u a ‚àò ofDual)) :
    sInf (image2 u s t) = u (sInf s) (sSup t) :=
  @sInf_image2_eq_sInf_sInf _ Œ≤·µí·µà _ _ _ _ _ _ _ _ _ h‚ÇÅ h‚ÇÇ
#align Inf_image2_eq_Inf_Sup sInf_image2_eq_sInf_sSup

theorem sInf_image2_eq_sSup_sInf (h‚ÇÅ : ‚àÄ b, GaloisConnection (toDual ‚àò l‚ÇÅ b) (swap u b ‚àò ofDual))
    (h‚ÇÇ : ‚àÄ a, GaloisConnection (l‚ÇÇ a) (u a)) : sInf (image2 u s t) = u (sSup s) (sInf t) :=
  @sInf_image2_eq_sInf_sInf Œ±·µí·µà _ _ _ _ _ _ _ _ _ _ h‚ÇÅ h‚ÇÇ
#align Inf_image2_eq_Sup_Inf sInf_image2_eq_sSup_sInf

theorem sInf_image2_eq_sSup_sSup (h‚ÇÅ : ‚àÄ b, GaloisConnection (toDual ‚àò l‚ÇÅ b) (swap u b ‚àò ofDual))
    (h‚ÇÇ : ‚àÄ a, GaloisConnection (toDual ‚àò l‚ÇÇ a) (u a ‚àò ofDual)) :
    sInf (image2 u s t) = u (sSup s) (sSup t) :=
  @sInf_image2_eq_sInf_sInf Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ _ _ _ h‚ÇÅ h‚ÇÇ
#align Inf_image2_eq_Sup_Sup sInf_image2_eq_sSup_sSup

end

namespace OrderIso

variable [Preorder Œ±] [Preorder Œ≤]

@[simp]
theorem bddAbove_image (e : Œ± ‚âÉo Œ≤) {s : Set Œ±} : BddAbove (e '' s) ‚Üî BddAbove s :=
  e.to_galoisConnection.bddAbove_l_image
#align order_iso.bdd_above_image OrderIso.bddAbove_image

@[simp]
theorem bddBelow_image (e : Œ± ‚âÉo Œ≤) {s : Set Œ±} : BddBelow (e '' s) ‚Üî BddBelow s :=
  e.dual.bddAbove_image
#align order_iso.bdd_below_image OrderIso.bddBelow_image

@[simp]
theorem bddAbove_preimage (e : Œ± ‚âÉo Œ≤) {s : Set Œ≤} : BddAbove (e ‚Åª¬π' s) ‚Üî BddAbove s := by
  rw [‚Üê e.bddAbove_image, e.image_preimage]
  -- üéâ no goals
#align order_iso.bdd_above_preimage OrderIso.bddAbove_preimage

@[simp]
theorem bddBelow_preimage (e : Œ± ‚âÉo Œ≤) {s : Set Œ≤} : BddBelow (e ‚Åª¬π' s) ‚Üî BddBelow s := by
  rw [‚Üê e.bddBelow_image, e.image_preimage]
  -- üéâ no goals
#align order_iso.bdd_below_preimage OrderIso.bddBelow_preimage

end OrderIso

namespace Nat

theorem galoisConnection_mul_div {k : ‚Ñï} (h : 0 < k) :
    GaloisConnection (fun n => n * k) fun n => n / k := fun _ _ => (le_div_iff_mul_le h).symm
#align nat.galois_connection_mul_div Nat.galoisConnection_mul_div

end Nat

-- Porting note: this used to have a `@[nolint has_nonempty_instance]`
/-- A Galois insertion is a Galois connection where `l ‚àò u = id`. It also contains a constructive
choice function, to give better definitional equalities when lifting order structures. Dual
to `GaloisCoinsertion` -/
structure GaloisInsertion {Œ± Œ≤ : Type*} [Preorder Œ±] [Preorder Œ≤] (l : Œ± ‚Üí Œ≤) (u : Œ≤ ‚Üí Œ±) where
  /-- A contructive choice function for images of `l`. -/
  choice : ‚àÄ x : Œ±, u (l x) ‚â§ x ‚Üí Œ≤
  /-- The Galois connection associated to a Galois insertion. -/
  gc : GaloisConnection l u
  /-- Main property of a Galois insertion. -/
  le_l_u : ‚àÄ x, x ‚â§ l (u x)
  /-- Property of the choice function. -/
  choice_eq : ‚àÄ a h, choice a h = l a
#align galois_insertion GaloisInsertion

/-- A constructor for a Galois insertion with the trivial `choice` function. -/
def GaloisInsertion.monotoneIntro {Œ± Œ≤ : Type*} [Preorder Œ±] [Preorder Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±}
    (hu : Monotone u) (hl : Monotone l) (hul : ‚àÄ a, a ‚â§ u (l a)) (hlu : ‚àÄ b, l (u b) = b) :
    GaloisInsertion l u where
  choice x _ := l x
  gc := GaloisConnection.monotone_intro hu hl hul fun b => le_of_eq (hlu b)
  le_l_u b := le_of_eq <| (hlu b).symm
  choice_eq _ _ := rfl
#align galois_insertion.monotone_intro GaloisInsertion.monotoneIntro

/-- Makes a Galois insertion from an order-preserving bijection. -/
protected def OrderIso.toGaloisInsertion [Preorder Œ±] [Preorder Œ≤] (oi : Œ± ‚âÉo Œ≤) :
    GaloisInsertion oi oi.symm where
  choice b _ := oi b
  gc := oi.to_galoisConnection
  le_l_u g := le_of_eq (oi.right_inv g).symm
  choice_eq _ _ := rfl
#align order_iso.to_galois_insertion OrderIso.toGaloisInsertion

/-- Make a `GaloisInsertion l u` from a `GaloisConnection l u` such that `‚àÄ b, b ‚â§ l (u b)` -/
def GaloisConnection.toGaloisInsertion {Œ± Œ≤ : Type*} [Preorder Œ±] [Preorder Œ≤] {l : Œ± ‚Üí Œ≤}
    {u : Œ≤ ‚Üí Œ±} (gc : GaloisConnection l u) (h : ‚àÄ b, b ‚â§ l (u b)) : GaloisInsertion l u :=
  { choice := fun x _ => l x
    gc
    le_l_u := h
    choice_eq := fun _ _ => rfl }
#align galois_connection.to_galois_insertion GaloisConnection.toGaloisInsertion

/-- Lift the bottom along a Galois connection -/
def GaloisConnection.liftOrderBot {Œ± Œ≤ : Type*} [Preorder Œ±] [OrderBot Œ±] [PartialOrder Œ≤]
    {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : GaloisConnection l u) :
    OrderBot Œ≤ where
  bot := l ‚ä•
  bot_le _ := gc.l_le <| bot_le
#align galois_connection.lift_order_bot GaloisConnection.liftOrderBot

namespace GaloisInsertion

variable {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±}

theorem l_u_eq [Preorder Œ±] [PartialOrder Œ≤] (gi : GaloisInsertion l u) (b : Œ≤) : l (u b) = b :=
  (gi.gc.l_u_le _).antisymm (gi.le_l_u _)
#align galois_insertion.l_u_eq GaloisInsertion.l_u_eq

theorem leftInverse_l_u [Preorder Œ±] [PartialOrder Œ≤] (gi : GaloisInsertion l u) :
    LeftInverse l u :=
  gi.l_u_eq
#align galois_insertion.left_inverse_l_u GaloisInsertion.leftInverse_l_u

theorem l_top [Preorder Œ±] [PartialOrder Œ≤] [OrderTop Œ±] [OrderTop Œ≤]
    (gi : GaloisInsertion l u) : l ‚ä§ = ‚ä§ :=
  top_unique <| (gi.le_l_u _).trans <| gi.gc.monotone_l le_top

theorem l_surjective [Preorder Œ±] [PartialOrder Œ≤] (gi : GaloisInsertion l u) : Surjective l :=
  gi.leftInverse_l_u.surjective
#align galois_insertion.l_surjective GaloisInsertion.l_surjective

theorem u_injective [Preorder Œ±] [PartialOrder Œ≤] (gi : GaloisInsertion l u) : Injective u :=
  gi.leftInverse_l_u.injective
#align galois_insertion.u_injective GaloisInsertion.u_injective

theorem l_sup_u [SemilatticeSup Œ±] [SemilatticeSup Œ≤] (gi : GaloisInsertion l u) (a b : Œ≤) :
    l (u a ‚äî u b) = a ‚äî b :=
  calc
    l (u a ‚äî u b) = l (u a) ‚äî l (u b) := gi.gc.l_sup
    _ = a ‚äî b := by simp only [gi.l_u_eq]
                    -- üéâ no goals
#align galois_insertion.l_sup_u GaloisInsertion.l_sup_u

theorem l_iSup_u [CompleteLattice Œ±] [CompleteLattice Œ≤] (gi : GaloisInsertion l u) {Œπ : Sort x}
    (f : Œπ ‚Üí Œ≤) : l (‚®Ü i, u (f i)) = ‚®Ü i, f i :=
  calc
    l (‚®Ü i : Œπ, u (f i)) = ‚®Ü i : Œπ, l (u (f i)) := gi.gc.l_iSup
    _ = ‚®Ü i : Œπ, f i := congr_arg _ <| funext fun i => gi.l_u_eq (f i)
#align galois_insertion.l_supr_u GaloisInsertion.l_iSup_u

theorem l_biSup_u [CompleteLattice Œ±] [CompleteLattice Œ≤] (gi : GaloisInsertion l u) {Œπ : Sort x}
    {p : Œπ ‚Üí Prop} (f : ‚àÄ (i) (_ : p i), Œ≤) : l (‚®Ü (i) (hi), u (f i hi)) = ‚®Ü (i) (hi), f i hi := by
  simp only [iSup_subtype', gi.l_iSup_u]
  -- üéâ no goals
#align galois_insertion.l_bsupr_u GaloisInsertion.l_biSup_u

theorem l_sSup_u_image [CompleteLattice Œ±] [CompleteLattice Œ≤] (gi : GaloisInsertion l u)
    (s : Set Œ≤) : l (sSup (u '' s)) = sSup s := by rw [sSup_image, gi.l_biSup_u, sSup_eq_iSup]
                                                   -- üéâ no goals
#align galois_insertion.l_Sup_u_image GaloisInsertion.l_sSup_u_image

theorem l_inf_u [SemilatticeInf Œ±] [SemilatticeInf Œ≤] (gi : GaloisInsertion l u) (a b : Œ≤) :
    l (u a ‚äì u b) = a ‚äì b :=
  calc
    l (u a ‚äì u b) = l (u (a ‚äì b)) := congr_arg l gi.gc.u_inf.symm
    _ = a ‚äì b := by simp only [gi.l_u_eq]
                    -- üéâ no goals
#align galois_insertion.l_inf_u GaloisInsertion.l_inf_u

theorem l_iInf_u [CompleteLattice Œ±] [CompleteLattice Œ≤] (gi : GaloisInsertion l u) {Œπ : Sort x}
    (f : Œπ ‚Üí Œ≤) : l (‚®Ö i, u (f i)) = ‚®Ö i, f i :=
  calc
    l (‚®Ö i : Œπ, u (f i)) = l (u (‚®Ö i : Œπ, f i)) := congr_arg l gi.gc.u_iInf.symm
    _ = ‚®Ö i : Œπ, f i := gi.l_u_eq _
#align galois_insertion.l_infi_u GaloisInsertion.l_iInf_u

theorem l_biInf_u [CompleteLattice Œ±] [CompleteLattice Œ≤] (gi : GaloisInsertion l u) {Œπ : Sort x}
    {p : Œπ ‚Üí Prop} (f : ‚àÄ (i) (_ : p i), Œ≤) : l (‚®Ö (i) (hi), u (f i hi)) = ‚®Ö (i) (hi), f i hi := by
  simp only [iInf_subtype', gi.l_iInf_u]
  -- üéâ no goals
#align galois_insertion.l_binfi_u GaloisInsertion.l_biInf_u

theorem l_sInf_u_image [CompleteLattice Œ±] [CompleteLattice Œ≤] (gi : GaloisInsertion l u)
    (s : Set Œ≤) : l (sInf (u '' s)) = sInf s := by rw [sInf_image, gi.l_biInf_u, sInf_eq_iInf]
                                                   -- üéâ no goals
#align galois_insertion.l_Inf_u_image GaloisInsertion.l_sInf_u_image

theorem l_iInf_of_ul_eq_self [CompleteLattice Œ±] [CompleteLattice Œ≤] (gi : GaloisInsertion l u)
    {Œπ : Sort x} (f : Œπ ‚Üí Œ±) (hf : ‚àÄ i, u (l (f i)) = f i) : l (‚®Ö i, f i) = ‚®Ö i, l (f i) :=
  calc
    l (‚®Ö i, f i) = l (‚®Ö i : Œπ, u (l (f i))) := by simp [hf]
                                                  -- üéâ no goals
    _ = ‚®Ö i, l (f i) := gi.l_iInf_u _
#align galois_insertion.l_infi_of_ul_eq_self GaloisInsertion.l_iInf_of_ul_eq_self

theorem l_biInf_of_ul_eq_self [CompleteLattice Œ±] [CompleteLattice Œ≤] (gi : GaloisInsertion l u)
    {Œπ : Sort x} {p : Œπ ‚Üí Prop} (f : ‚àÄ (i) (_ : p i), Œ±) (hf : ‚àÄ i hi, u (l (f i hi)) = f i hi) :
    l (‚®Ö (i) (hi), f i hi) = ‚®Ö (i) (hi), l (f i hi) := by
  rw [iInf_subtype', iInf_subtype']
  -- ‚ä¢ l (‚®Ö (x : { i // p i }), f ‚Üëx (_ : p ‚Üëx)) = ‚®Ö (x : { i // p i }), l (f ‚Üëx (_ ‚Ä¶
  exact gi.l_iInf_of_ul_eq_self _ fun _ => hf _ _
  -- üéâ no goals
#align galois_insertion.l_binfi_of_ul_eq_self GaloisInsertion.l_biInf_of_ul_eq_self

theorem u_le_u_iff [Preorder Œ±] [Preorder Œ≤] (gi : GaloisInsertion l u) {a b} : u a ‚â§ u b ‚Üî a ‚â§ b :=
  ‚ü®fun h => (gi.le_l_u _).trans (gi.gc.l_le h), fun h => gi.gc.monotone_u h‚ü©
#align galois_insertion.u_le_u_iff GaloisInsertion.u_le_u_iff

theorem strictMono_u [Preorder Œ±] [Preorder Œ≤] (gi : GaloisInsertion l u) : StrictMono u :=
  strictMono_of_le_iff_le fun _ _ => gi.u_le_u_iff.symm
#align galois_insertion.strict_mono_u GaloisInsertion.strictMono_u

theorem isLUB_of_u_image [Preorder Œ±] [Preorder Œ≤] (gi : GaloisInsertion l u) {s : Set Œ≤} {a : Œ±}
    (hs : IsLUB (u '' s) a) : IsLUB s (l a) :=
  ‚ü®fun x hx => (gi.le_l_u x).trans <| gi.gc.monotone_l <| hs.1 <| mem_image_of_mem _ hx, fun _ hx =>
    gi.gc.l_le <| hs.2 <| gi.gc.monotone_u.mem_upperBounds_image hx‚ü©
#align galois_insertion.is_lub_of_u_image GaloisInsertion.isLUB_of_u_image

theorem isGLB_of_u_image [Preorder Œ±] [Preorder Œ≤] (gi : GaloisInsertion l u) {s : Set Œ≤} {a : Œ±}
    (hs : IsGLB (u '' s) a) : IsGLB s (l a) :=
  ‚ü®fun _ hx => gi.gc.l_le <| hs.1 <| mem_image_of_mem _ hx, fun x hx =>
    (gi.le_l_u x).trans <| gi.gc.monotone_l <| hs.2 <| gi.gc.monotone_u.mem_lowerBounds_image hx‚ü©
#align galois_insertion.is_glb_of_u_image GaloisInsertion.isGLB_of_u_image

section lift

variable [PartialOrder Œ≤]

-- See note [reducible non instances]
/-- Lift the suprema along a Galois insertion -/
@[reducible]
def liftSemilatticeSup [SemilatticeSup Œ±] (gi : GaloisInsertion l u) : SemilatticeSup Œ≤ :=
  { ‚ÄπPartialOrder Œ≤‚Ä∫ with
    sup := fun a b => l (u a ‚äî u b)
    le_sup_left := fun a _ => (gi.le_l_u a).trans <| gi.gc.monotone_l <| le_sup_left
    le_sup_right := fun _ b => (gi.le_l_u b).trans <| gi.gc.monotone_l <| le_sup_right
    sup_le := fun a b c hac hbc =>
      gi.gc.l_le <| sup_le (gi.gc.monotone_u hac) (gi.gc.monotone_u hbc) }
#align galois_insertion.lift_semilattice_sup GaloisInsertion.liftSemilatticeSup

-- See note [reducible non instances]
/-- Lift the infima along a Galois insertion -/
@[reducible]
def liftSemilatticeInf [SemilatticeInf Œ±] (gi : GaloisInsertion l u) : SemilatticeInf Œ≤ :=
  { ‚ÄπPartialOrder Œ≤‚Ä∫ with
    inf := fun a b =>
      gi.choice (u a ‚äì u b) <|
        le_inf (gi.gc.monotone_u <| gi.gc.l_le <| inf_le_left)
          (gi.gc.monotone_u <| gi.gc.l_le <| inf_le_right)
    inf_le_left := by simp only [gi.choice_eq]; exact fun a b => gi.gc.l_le inf_le_left
                      -- ‚ä¢ ‚àÄ (a b : Œ≤), l (u a ‚äì u b) ‚â§ a
                                                -- üéâ no goals
    inf_le_right := by simp only [gi.choice_eq]; exact fun a b => gi.gc.l_le inf_le_right
                       -- ‚ä¢ ‚àÄ (a b : Œ≤), l (u a ‚äì u b) ‚â§ b
                                                 -- üéâ no goals
    le_inf := by
      simp only [gi.choice_eq]
      -- ‚ä¢ ‚àÄ (a b c : Œ≤), a ‚â§ b ‚Üí a ‚â§ c ‚Üí a ‚â§ l (u b ‚äì u c)
      exact fun a b c hac hbc =>
        (gi.le_l_u a).trans <|
          gi.gc.monotone_l <| le_inf (gi.gc.monotone_u hac) (gi.gc.monotone_u hbc) }
#align galois_insertion.lift_semilattice_inf GaloisInsertion.liftSemilatticeInf

-- See note [reducible non instances]
/-- Lift the suprema and infima along a Galois insertion -/
@[reducible]
def liftLattice [Lattice Œ±] (gi : GaloisInsertion l u) : Lattice Œ≤ :=
  { gi.liftSemilatticeSup, gi.liftSemilatticeInf with }
#align galois_insertion.lift_lattice GaloisInsertion.liftLattice

-- See note [reducible non instances]
/-- Lift the top along a Galois insertion -/
@[reducible]
def liftOrderTop [Preorder Œ±] [OrderTop Œ±] (gi : GaloisInsertion l u) :
    OrderTop Œ≤ where
  top := gi.choice ‚ä§ <| le_top
  le_top := by
    simp only [gi.choice_eq]; exact fun b => (gi.le_l_u b).trans (gi.gc.monotone_l le_top)
    -- ‚ä¢ ‚àÄ (a : Œ≤), a ‚â§ l ‚ä§
                              -- üéâ no goals
#align galois_insertion.lift_order_top GaloisInsertion.liftOrderTop

-- See note [reducible non instances]
/-- Lift the top, bottom, suprema, and infima along a Galois insertion -/
@[reducible]
def liftBoundedOrder [Preorder Œ±] [BoundedOrder Œ±] (gi : GaloisInsertion l u) : BoundedOrder Œ≤ :=
  { gi.liftOrderTop, gi.gc.liftOrderBot with }
#align galois_insertion.lift_bounded_order GaloisInsertion.liftBoundedOrder

-- See note [reducible non instances]
/-- Lift all suprema and infima along a Galois insertion -/
@[reducible]
def liftCompleteLattice [CompleteLattice Œ±] (gi : GaloisInsertion l u) : CompleteLattice Œ≤ :=
  { gi.liftBoundedOrder, gi.liftLattice with
    sSup := fun s => l (sSup (u '' s))
    sSup_le := fun s => (gi.isLUB_of_u_image (isLUB_sSup _)).2
    le_sSup := fun s => (gi.isLUB_of_u_image (isLUB_sSup _)).1
    sInf := fun s =>
      gi.choice (sInf (u '' s)) <|
        (isGLB_sInf _).2 <|
          gi.gc.monotone_u.mem_lowerBounds_image (gi.isGLB_of_u_image <| isGLB_sInf _).1
    sInf_le := fun s => by dsimp; rw [gi.choice_eq]; exact (gi.isGLB_of_u_image (isGLB_sInf _)).1
                           -- ‚ä¢ ‚àÄ (a : Œ≤), a ‚àà s ‚Üí choice gi (sInf (u '' s)) (_ : u (l (sInf (u '' s))) ‚â§ sI ‚Ä¶
                                  -- ‚ä¢ ‚àÄ (a : Œ≤), a ‚àà s ‚Üí l (sInf (u '' s)) ‚â§ a
                                                     -- üéâ no goals
    le_sInf := fun s => by dsimp; rw [gi.choice_eq]; exact (gi.isGLB_of_u_image (isGLB_sInf _)).2 }
                           -- ‚ä¢ ‚àÄ (a : Œ≤), (‚àÄ (b : Œ≤), b ‚àà s ‚Üí a ‚â§ b) ‚Üí a ‚â§ choice gi (sInf (u '' s)) (_ : u ‚Ä¶
                                  -- ‚ä¢ ‚àÄ (a : Œ≤), (‚àÄ (b : Œ≤), b ‚àà s ‚Üí a ‚â§ b) ‚Üí a ‚â§ l (sInf (u '' s))
                                                     -- üéâ no goals
#align galois_insertion.lift_complete_lattice GaloisInsertion.liftCompleteLattice

end lift

end GaloisInsertion

-- Porting note: this used to have a `@[nolint has_nonempty_instance]`
/-- A Galois coinsertion is a Galois connection where `u ‚àò l = id`. It also contains a constructive
choice function, to give better definitional equalities when lifting order structures. Dual to
`GaloisInsertion` -/
structure GaloisCoinsertion [Preorder Œ±] [Preorder Œ≤] (l : Œ± ‚Üí Œ≤) (u : Œ≤ ‚Üí Œ±) where
  /-- A contructive choice function for images of `u`. -/
  choice : ‚àÄ x : Œ≤, x ‚â§ l (u x) ‚Üí Œ±
  /-- The Galois connection associated to a Galois coinsertion. -/
  gc : GaloisConnection l u
  /-- Main property of a Galois coinsertion. -/
  u_l_le : ‚àÄ x, u (l x) ‚â§ x
  /-- Property of the choice function. -/
  choice_eq : ‚àÄ a h, choice a h = u a
#align galois_coinsertion GaloisCoinsertion

/-- Make a `GaloisInsertion` between `Œ±·µí·µà` and `Œ≤·µí·µà` from a `GaloisCoinsertion` between `Œ±` and
`Œ≤`. -/
def GaloisCoinsertion.dual [Preorder Œ±] [Preorder Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} :
    GaloisCoinsertion l u ‚Üí GaloisInsertion (toDual ‚àò u ‚àò ofDual) (toDual ‚àò l ‚àò ofDual) :=
  fun x => ‚ü®x.1, x.2.dual, x.3, x.4‚ü©
#align galois_coinsertion.dual GaloisCoinsertion.dual

/-- Make a `GaloisCoinsertion` between `Œ±·µí·µà` and `Œ≤·µí·µà` from a `GaloisInsertion` between `Œ±` and
`Œ≤`. -/
def GaloisInsertion.dual [Preorder Œ±] [Preorder Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} :
    GaloisInsertion l u ‚Üí GaloisCoinsertion (toDual ‚àò u ‚àò ofDual) (toDual ‚àò l ‚àò ofDual) :=
  fun x => ‚ü®x.1, x.2.dual, x.3, x.4‚ü©
#align galois_insertion.dual GaloisInsertion.dual

/-- Make a `GaloisInsertion` between `Œ±` and `Œ≤` from a `GaloisCoinsertion` between `Œ±·µí·µà` and
`Œ≤·µí·µà`. -/
def GaloisCoinsertion.ofDual [Preorder Œ±] [Preorder Œ≤] {l : Œ±·µí·µà ‚Üí Œ≤·µí·µà} {u : Œ≤·µí·µà ‚Üí Œ±·µí·µà} :
    GaloisCoinsertion l u ‚Üí GaloisInsertion (ofDual ‚àò u ‚àò toDual) (ofDual ‚àò l ‚àò toDual) :=
  fun x => ‚ü®x.1, x.2.dual, x.3, x.4‚ü©
#align galois_coinsertion.of_dual GaloisCoinsertion.ofDual

/-- Make a `GaloisCoinsertion` between `Œ±` and `Œ≤` from a `GaloisInsertion` between `Œ±·µí·µà` and
`Œ≤·µí·µà`. -/
def GaloisInsertion.ofDual [Preorder Œ±] [Preorder Œ≤] {l : Œ±·µí·µà ‚Üí Œ≤·µí·µà} {u : Œ≤·µí·µà ‚Üí Œ±·µí·µà} :
    GaloisInsertion l u ‚Üí GaloisCoinsertion (ofDual ‚àò u ‚àò toDual) (ofDual ‚àò l ‚àò toDual) :=
  fun x => ‚ü®x.1, x.2.dual, x.3, x.4‚ü©
#align galois_insertion.of_dual GaloisInsertion.ofDual

/-- Makes a Galois coinsertion from an order-preserving bijection. -/
protected def OrderIso.toGaloisCoinsertion [Preorder Œ±] [Preorder Œ≤] (oi : Œ± ‚âÉo Œ≤) :
    GaloisCoinsertion oi oi.symm where
  choice b _ := oi.symm b
  gc := oi.to_galoisConnection
  u_l_le g := le_of_eq (oi.left_inv g)
  choice_eq _ _ := rfl
#align order_iso.to_galois_coinsertion OrderIso.toGaloisCoinsertion

/-- A constructor for a Galois coinsertion with the trivial `choice` function. -/
def GaloisCoinsertion.monotoneIntro [Preorder Œ±] [Preorder Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±}
    (hu : Monotone u) (hl : Monotone l) (hlu : ‚àÄ b, l (u b) ‚â§ b) (hul : ‚àÄ a, u (l a) = a) :
    GaloisCoinsertion l u :=
  (GaloisInsertion.monotoneIntro hl.dual hu.dual hlu hul).ofDual
#align galois_coinsertion.monotone_intro GaloisCoinsertion.monotoneIntro

/-- Make a `GaloisCoinsertion l u` from a `GaloisConnection l u` such that `‚àÄ b, b ‚â§ l (u b)` -/
def GaloisConnection.toGaloisCoinsertion {Œ± Œ≤ : Type*} [Preorder Œ±] [Preorder Œ≤] {l : Œ± ‚Üí Œ≤}
    {u : Œ≤ ‚Üí Œ±} (gc : GaloisConnection l u) (h : ‚àÄ a, u (l a) ‚â§ a) : GaloisCoinsertion l u :=
  { choice := fun x _ => u x
    gc
    u_l_le := h
    choice_eq := fun _ _ => rfl }
#align galois_connection.to_galois_coinsertion GaloisConnection.toGaloisCoinsertion

/-- Lift the top along a Galois connection -/
def GaloisConnection.liftOrderTop {Œ± Œ≤ : Type*} [PartialOrder Œ±] [Preorder Œ≤] [OrderTop Œ≤]
    {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : GaloisConnection l u) :
    OrderTop Œ± where
  top := u ‚ä§
  le_top _ := gc.le_u <| le_top
#align galois_connection.lift_order_top GaloisConnection.liftOrderTop

namespace GaloisCoinsertion

variable {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±}

theorem u_l_eq [PartialOrder Œ±] [Preorder Œ≤] (gi : GaloisCoinsertion l u) (a : Œ±) : u (l a) = a :=
  gi.dual.l_u_eq a
#align galois_coinsertion.u_l_eq GaloisCoinsertion.u_l_eq

theorem u_l_leftInverse [PartialOrder Œ±] [Preorder Œ≤] (gi : GaloisCoinsertion l u) :
    LeftInverse u l :=
  gi.u_l_eq
#align galois_coinsertion.u_l_left_inverse GaloisCoinsertion.u_l_leftInverse

theorem u_bot [PartialOrder Œ±] [Preorder Œ≤] [OrderBot Œ±] [OrderBot Œ≤] (gi : GaloisCoinsertion l u) :
    u ‚ä• = ‚ä• :=
  gi.dual.l_top

theorem u_surjective [PartialOrder Œ±] [Preorder Œ≤] (gi : GaloisCoinsertion l u) : Surjective u :=
  gi.dual.l_surjective
#align galois_coinsertion.u_surjective GaloisCoinsertion.u_surjective

theorem l_injective [PartialOrder Œ±] [Preorder Œ≤] (gi : GaloisCoinsertion l u) : Injective l :=
  gi.dual.u_injective
#align galois_coinsertion.l_injective GaloisCoinsertion.l_injective

theorem u_inf_l [SemilatticeInf Œ±] [SemilatticeInf Œ≤] (gi : GaloisCoinsertion l u) (a b : Œ±) :
    u (l a ‚äì l b) = a ‚äì b :=
  gi.dual.l_sup_u a b
#align galois_coinsertion.u_inf_l GaloisCoinsertion.u_inf_l

theorem u_iInf_l [CompleteLattice Œ±] [CompleteLattice Œ≤] (gi : GaloisCoinsertion l u) {Œπ : Sort x}
    (f : Œπ ‚Üí Œ±) : u (‚®Ö i, l (f i)) = ‚®Ö i, f i :=
  gi.dual.l_iSup_u _
#align galois_coinsertion.u_infi_l GaloisCoinsertion.u_iInf_l

theorem u_sInf_l_image [CompleteLattice Œ±] [CompleteLattice Œ≤] (gi : GaloisCoinsertion l u)
    (s : Set Œ±) : u (sInf (l '' s)) = sInf s :=
  gi.dual.l_sSup_u_image _
#align galois_coinsertion.u_Inf_l_image GaloisCoinsertion.u_sInf_l_image

theorem u_sup_l [SemilatticeSup Œ±] [SemilatticeSup Œ≤] (gi : GaloisCoinsertion l u) (a b : Œ±) :
    u (l a ‚äî l b) = a ‚äî b :=
  gi.dual.l_inf_u _ _
#align galois_coinsertion.u_sup_l GaloisCoinsertion.u_sup_l

theorem u_iSup_l [CompleteLattice Œ±] [CompleteLattice Œ≤] (gi : GaloisCoinsertion l u) {Œπ : Sort x}
    (f : Œπ ‚Üí Œ±) : u (‚®Ü i, l (f i)) = ‚®Ü i, f i :=
  gi.dual.l_iInf_u _
#align galois_coinsertion.u_supr_l GaloisCoinsertion.u_iSup_l

theorem u_biSup_l [CompleteLattice Œ±] [CompleteLattice Œ≤] (gi : GaloisCoinsertion l u) {Œπ : Sort x}
    {p : Œπ ‚Üí Prop} (f : ‚àÄ (i) (_ : p i), Œ±) : u (‚®Ü (i) (hi), l (f i hi)) = ‚®Ü (i) (hi), f i hi :=
  gi.dual.l_biInf_u _
#align galois_coinsertion.u_bsupr_l GaloisCoinsertion.u_biSup_l

theorem u_sSup_l_image [CompleteLattice Œ±] [CompleteLattice Œ≤] (gi : GaloisCoinsertion l u)
    (s : Set Œ±) : u (sSup (l '' s)) = sSup s :=
  gi.dual.l_sInf_u_image _
#align galois_coinsertion.u_Sup_l_image GaloisCoinsertion.u_sSup_l_image

theorem u_iSup_of_lu_eq_self [CompleteLattice Œ±] [CompleteLattice Œ≤] (gi : GaloisCoinsertion l u)
    {Œπ : Sort x} (f : Œπ ‚Üí Œ≤) (hf : ‚àÄ i, l (u (f i)) = f i) : u (‚®Ü i, f i) = ‚®Ü i, u (f i) :=
  gi.dual.l_iInf_of_ul_eq_self _ hf
#align galois_coinsertion.u_supr_of_lu_eq_self GaloisCoinsertion.u_iSup_of_lu_eq_self

theorem u_biSup_of_lu_eq_self [CompleteLattice Œ±] [CompleteLattice Œ≤] (gi : GaloisCoinsertion l u)
    {Œπ : Sort x} {p : Œπ ‚Üí Prop} (f : ‚àÄ (i) (_ : p i), Œ≤) (hf : ‚àÄ i hi, l (u (f i hi)) = f i hi) :
    u (‚®Ü (i) (hi), f i hi) = ‚®Ü (i) (hi), u (f i hi) :=
  gi.dual.l_biInf_of_ul_eq_self _ hf
#align galois_coinsertion.u_bsupr_of_lu_eq_self GaloisCoinsertion.u_biSup_of_lu_eq_self

theorem l_le_l_iff [Preorder Œ±] [Preorder Œ≤] (gi : GaloisCoinsertion l u) {a b} :
    l a ‚â§ l b ‚Üî a ‚â§ b :=
  gi.dual.u_le_u_iff
#align galois_coinsertion.l_le_l_iff GaloisCoinsertion.l_le_l_iff

theorem strictMono_l [Preorder Œ±] [Preorder Œ≤] (gi : GaloisCoinsertion l u) : StrictMono l :=
  fun _ _ h => gi.dual.strictMono_u h
#align galois_coinsertion.strict_mono_l GaloisCoinsertion.strictMono_l

theorem isGLB_of_l_image [Preorder Œ±] [Preorder Œ≤] (gi : GaloisCoinsertion l u) {s : Set Œ±} {a : Œ≤}
    (hs : IsGLB (l '' s) a) : IsGLB s (u a) :=
  gi.dual.isLUB_of_u_image hs
#align galois_coinsertion.is_glb_of_l_image GaloisCoinsertion.isGLB_of_l_image

theorem isLUB_of_l_image [Preorder Œ±] [Preorder Œ≤] (gi : GaloisCoinsertion l u) {s : Set Œ±} {a : Œ≤}
    (hs : IsLUB (l '' s) a) : IsLUB s (u a) :=
  gi.dual.isGLB_of_u_image hs
#align galois_coinsertion.is_lub_of_l_image GaloisCoinsertion.isLUB_of_l_image

section lift

variable [PartialOrder Œ±]

-- Porting note: In `liftSemilatticeInf` and `liftSemilatticeSup` below, the elaborator
-- seems to struggle with Œ±·µí·µà vs Œ±; the `by exact`s are not present in Lean 3, but without
-- them the declarations compile much more slowly for some reason.
-- Possibly related to the issue discussed at
-- https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Performance.20issue.20with.20.60CompleteBooleanAlgebra.60/near/316760798

-- See note [reducible non instances]
/-- Lift the infima along a Galois coinsertion -/
@[reducible]
def liftSemilatticeInf [SemilatticeInf Œ≤] (gi : GaloisCoinsertion l u) : SemilatticeInf Œ± :=
  { ‚ÄπPartialOrder Œ±‚Ä∫ with
    inf_le_left := fun a b => by
      exact (@OrderDual.semilatticeInf Œ±·µí·µà gi.dual.liftSemilatticeSup).inf_le_left a b
      -- üéâ no goals
    inf_le_right := fun a b => by
      exact (@OrderDual.semilatticeInf Œ±·µí·µà gi.dual.liftSemilatticeSup).inf_le_right a b
      -- üéâ no goals
    le_inf := fun a b c => by
      exact (@OrderDual.semilatticeInf Œ±·µí·µà gi.dual.liftSemilatticeSup).le_inf a b c
      -- üéâ no goals
    inf := fun a b => u (l a ‚äì l b) }
#align galois_coinsertion.lift_semilattice_inf GaloisCoinsertion.liftSemilatticeInf

-- See note [reducible non instances]
/-- Lift the suprema along a Galois coinsertion -/
@[reducible]
def liftSemilatticeSup [SemilatticeSup Œ≤] (gi : GaloisCoinsertion l u) : SemilatticeSup Œ± :=
  { ‚ÄπPartialOrder Œ±‚Ä∫ with
    sup := fun a b =>
      gi.choice (l a ‚äî l b) <|
        sup_le (gi.gc.monotone_l <| gi.gc.le_u <| le_sup_left)
          (gi.gc.monotone_l <| gi.gc.le_u <| le_sup_right)
    le_sup_left := fun a b => by
      exact (@OrderDual.semilatticeSup Œ±·µí·µà gi.dual.liftSemilatticeInf).le_sup_left a b
      -- üéâ no goals
    le_sup_right := fun a b => by
      exact (@OrderDual.semilatticeSup Œ±·µí·µà gi.dual.liftSemilatticeInf).le_sup_right a b
      -- üéâ no goals
    sup_le := fun a b c => by
      exact (@OrderDual.semilatticeSup Œ±·µí·µà gi.dual.liftSemilatticeInf).sup_le a b c }
      -- üéâ no goals
#align galois_coinsertion.lift_semilattice_sup GaloisCoinsertion.liftSemilatticeSup

-- See note [reducible non instances]
/-- Lift the suprema and infima along a Galois coinsertion -/
@[reducible]
def liftLattice [Lattice Œ≤] (gi : GaloisCoinsertion l u) : Lattice Œ± :=
  { gi.liftSemilatticeSup, gi.liftSemilatticeInf with }
#align galois_coinsertion.lift_lattice GaloisCoinsertion.liftLattice

-- See note [reducible non instances]
/-- Lift the bot along a Galois coinsertion -/
@[reducible]
def liftOrderBot [Preorder Œ≤] [OrderBot Œ≤] (gi : GaloisCoinsertion l u) : OrderBot Œ± :=
  { @OrderDual.orderBot _ _ gi.dual.liftOrderTop with bot := gi.choice ‚ä• <| bot_le }
#align galois_coinsertion.lift_order_bot GaloisCoinsertion.liftOrderBot

-- See note [reducible non instances]
/-- Lift the top, bottom, suprema, and infima along a Galois coinsertion -/
@[reducible]
def liftBoundedOrder [Preorder Œ≤] [BoundedOrder Œ≤] (gi : GaloisCoinsertion l u) : BoundedOrder Œ± :=
  { gi.liftOrderBot, gi.gc.liftOrderTop with }
#align galois_coinsertion.lift_bounded_order GaloisCoinsertion.liftBoundedOrder

-- See note [reducible non instances]
/-- Lift all suprema and infima along a Galois coinsertion -/
@[reducible]
def liftCompleteLattice [CompleteLattice Œ≤] (gi : GaloisCoinsertion l u) : CompleteLattice Œ± :=
  { @OrderDual.completeLattice Œ±·µí·µà gi.dual.liftCompleteLattice with
    sInf := fun s => u (sInf (l '' s))
    sSup := fun s => gi.choice (sSup (l '' s)) _ }
#align galois_coinsertion.lift_complete_lattice GaloisCoinsertion.liftCompleteLattice

end lift

end GaloisCoinsertion

/-- If `Œ±` is a partial order with bottom element (e.g., `‚Ñï`, `‚Ñù‚â•0`), then `WithBot.unbot' ‚ä•` and
coercion form a Galois insertion. -/
def WithBot.giUnbot'Bot [Preorder Œ±] [OrderBot Œ±] :
    GaloisInsertion (WithBot.unbot' ‚ä•) (some : Œ± ‚Üí WithBot Œ±) where
  gc _ _ := WithBot.unbot'_bot_le_iff
  le_l_u _ := le_rfl
  choice o _ := o.unbot' ‚ä•
  choice_eq _ _ := rfl
#align with_bot.gi_unbot'_bot WithBot.giUnbot'Bot
