/-
Copyright (c) 2021 Anne Baanen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin, Anne Baanen
-/
import Mathlib.Logic.Function.Iterate
import Mathlib.Order.GaloisConnection
import Mathlib.Order.Hom.Basic

#align_import order.hom.order from "leanprover-community/mathlib"@"ba2245edf0c8bb155f1569fd9b9492a9b384cde6"

/-!
# Lattice structure on order homomorphisms

This file defines the lattice structure on order homomorphisms, which are bundled
monotone functions.

## Main definitions

 * `OrderHom.CompleteLattice`: if `Î²` is a complete lattice, so is `Î± â†’o Î²`

## Tags

monotone map, bundled morphism
-/


namespace OrderHom

variable {Î± Î² : Type*}

section Preorder

variable [Preorder Î±]

instance [SemilatticeSup Î²] : Sup (Î± â†’o Î²) where
  sup f g := âŸ¨fun a => f a âŠ” g a, f.mono.sup g.monoâŸ©

--Porting note: this is the lemma that could have been generated by `@[simps]` on the
--above instance but with a nicer name
@[simp] lemma coe_sup [SemilatticeSup Î²] (f g : Î± â†’o Î²) :
  ((f âŠ” g : Î± â†’o Î²) : Î± â†’ Î²) = (f : Î± â†’ Î²) âŠ” g := rfl

instance [SemilatticeSup Î²] : SemilatticeSup (Î± â†’o Î²) :=
  { (_ : PartialOrder (Î± â†’o Î²)) with
    sup := Sup.sup
    le_sup_left := fun _ _ _ => le_sup_left
    le_sup_right := fun _ _ _ => le_sup_right
    sup_le := fun _ _ _ hâ‚€ hâ‚ x => sup_le (hâ‚€ x) (hâ‚ x) }

instance [SemilatticeInf Î²] : Inf (Î± â†’o Î²) where
  inf f g := âŸ¨fun a => f a âŠ“ g a, f.mono.inf g.monoâŸ©

--Porting note: this is the lemma that could have been generated by `@[simps]` on the
--above instance but with a nicer name
@[simp] lemma coe_inf [SemilatticeInf Î²] (f g : Î± â†’o Î²) :
  ((f âŠ“ g : Î± â†’o Î²) : Î± â†’ Î²) = (f : Î± â†’ Î²) âŠ“ g := rfl

instance [SemilatticeInf Î²] : SemilatticeInf (Î± â†’o Î²) :=
  { (_ : PartialOrder (Î± â†’o Î²)), (dualIso Î± Î²).symm.toGaloisInsertion.liftSemilatticeInf with
    inf := (Â· âŠ“ Â·) }

instance lattice [Lattice Î²] : Lattice (Î± â†’o Î²) :=
  { (_ : SemilatticeSup (Î± â†’o Î²)), (_ : SemilatticeInf (Î± â†’o Î²)) with }

@[simps]
instance [Preorder Î²] [OrderBot Î²] : Bot (Î± â†’o Î²) where
  bot := const Î± âŠ¥

instance orderBot [Preorder Î²] [OrderBot Î²] : OrderBot (Î± â†’o Î²) where
  bot := âŠ¥
  bot_le _ _ := bot_le

@[simps]
instance instTopOrderHom [Preorder Î²] [OrderTop Î²] : Top (Î± â†’o Î²) where
  top := const Î± âŠ¤

instance orderTop [Preorder Î²] [OrderTop Î²] : OrderTop (Î± â†’o Î²) where
  top := âŠ¤
  le_top _ _ := le_top

instance [CompleteLattice Î²] : InfSet (Î± â†’o Î²) where
  sInf s := âŸ¨fun x => â¨… f âˆˆ s, (f : _) x, fun _ _ h => iInfâ‚‚_mono fun f _ => f.mono hâŸ©

@[simp]
theorem sInf_apply [CompleteLattice Î²] (s : Set (Î± â†’o Î²)) (x : Î±) :
    sInf s x = â¨… f âˆˆ s, (f : _) x :=
  rfl
#align order_hom.Inf_apply OrderHom.sInf_apply

theorem iInf_apply {Î¹ : Sort*} [CompleteLattice Î²] (f : Î¹ â†’ Î± â†’o Î²) (x : Î±) :
    (â¨… i, f i) x = â¨… i, f i x :=
  (sInf_apply _ _).trans iInf_range
#align order_hom.infi_apply OrderHom.iInf_apply

@[simp, norm_cast]
theorem coe_iInf {Î¹ : Sort*} [CompleteLattice Î²] (f : Î¹ â†’ Î± â†’o Î²) :
    ((â¨… i, f i : Î± â†’o Î²) : Î± â†’ Î²) = â¨… i, (f i : Î± â†’ Î²) := by
  funext x; simp [iInf_apply]
  -- âŠ¢ â†‘(â¨… (i : Î¹), f i) x = iInf (fun i => â†‘(f i)) x
            -- ğŸ‰ no goals
#align order_hom.coe_infi OrderHom.coe_iInf

instance [CompleteLattice Î²] : SupSet (Î± â†’o Î²) where
  sSup s := âŸ¨fun x => â¨† f âˆˆ s, (f : _) x, fun _ _ h => iSupâ‚‚_mono fun f _ => f.mono hâŸ©

@[simp]
theorem sSup_apply [CompleteLattice Î²] (s : Set (Î± â†’o Î²)) (x : Î±) :
    sSup s x = â¨† f âˆˆ s, (f : _) x :=
  rfl
#align order_hom.Sup_apply OrderHom.sSup_apply

theorem iSup_apply {Î¹ : Sort*} [CompleteLattice Î²] (f : Î¹ â†’ Î± â†’o Î²) (x : Î±) :
    (â¨† i, f i) x = â¨† i, f i x :=
  (sSup_apply _ _).trans iSup_range
#align order_hom.supr_apply OrderHom.iSup_apply

@[simp, norm_cast]
theorem coe_iSup {Î¹ : Sort*} [CompleteLattice Î²] (f : Î¹ â†’ Î± â†’o Î²) :
    ((â¨† i, f i : Î± â†’o Î²) : Î± â†’ Î²) = â¨† i, (f i : Î± â†’ Î²) := by
  funext x; simp [iSup_apply]
  -- âŠ¢ â†‘(â¨† (i : Î¹), f i) x = iSup (fun i => â†‘(f i)) x
            -- ğŸ‰ no goals
#align order_hom.coe_supr OrderHom.coe_iSup

instance [CompleteLattice Î²] : CompleteLattice (Î± â†’o Î²) :=
  { (_ : Lattice (Î± â†’o Î²)), OrderHom.orderTop, OrderHom.orderBot with
    -- sSup := SupSet.sSup   -- Porting note: removed, unnecessary?
    -- Porting note: Added `by apply`, was `fun s f hf x => le_iSup_of_le f (le_iSup _ hf)`
    le_sSup := fun s f hf x => le_iSup_of_le f (by apply le_iSup _ hf)
                                                   -- ğŸ‰ no goals
    sSup_le := fun s f hf x => iSupâ‚‚_le fun g hg => hf g hg x
    --inf := sInf      -- Porting note: removed, unnecessary?
    le_sInf := fun s f hf x => le_iInfâ‚‚ fun g hg => hf g hg x
    sInf_le := fun s f hf x => iInf_le_of_le f (iInf_le _ hf)
    }

theorem iterate_sup_le_sup_iff {Î± : Type*} [SemilatticeSup Î±] (f : Î± â†’o Î±) :
    (âˆ€ nâ‚ nâ‚‚ aâ‚ aâ‚‚, f^[nâ‚ + nâ‚‚] (aâ‚ âŠ” aâ‚‚) â‰¤ f^[nâ‚] aâ‚ âŠ” f^[nâ‚‚] aâ‚‚) â†”
      âˆ€ aâ‚ aâ‚‚, f (aâ‚ âŠ” aâ‚‚) â‰¤ f aâ‚ âŠ” aâ‚‚ := by
  constructor <;> intro h
  -- âŠ¢ (âˆ€ (nâ‚ nâ‚‚ : â„•) (aâ‚ aâ‚‚ : Î±), (â†‘f)^[nâ‚ + nâ‚‚] (aâ‚ âŠ” aâ‚‚) â‰¤ (â†‘f)^[nâ‚] aâ‚ âŠ” (â†‘f)^[ â€¦
                  -- âŠ¢ âˆ€ (aâ‚ aâ‚‚ : Î±), â†‘f (aâ‚ âŠ” aâ‚‚) â‰¤ â†‘f aâ‚ âŠ” aâ‚‚
                  -- âŠ¢ âˆ€ (nâ‚ nâ‚‚ : â„•) (aâ‚ aâ‚‚ : Î±), (â†‘f)^[nâ‚ + nâ‚‚] (aâ‚ âŠ” aâ‚‚) â‰¤ (â†‘f)^[nâ‚] aâ‚ âŠ” (â†‘f)^[n â€¦
  Â· exact h 1 0
    -- ğŸ‰ no goals
  Â· intro nâ‚ nâ‚‚ aâ‚ aâ‚‚
    -- âŠ¢ (â†‘f)^[nâ‚ + nâ‚‚] (aâ‚ âŠ” aâ‚‚) â‰¤ (â†‘f)^[nâ‚] aâ‚ âŠ” (â†‘f)^[nâ‚‚] aâ‚‚
    have h' : âˆ€ n aâ‚ aâ‚‚, f^[n] (aâ‚ âŠ” aâ‚‚) â‰¤ f^[n] aâ‚ âŠ” aâ‚‚ := by
      intro n
      induction' n with n ih <;> intro aâ‚ aâ‚‚
      Â· rfl
      Â· calc
          f^[n + 1] (aâ‚ âŠ” aâ‚‚) = f^[n] (f (aâ‚ âŠ” aâ‚‚)) := Function.iterate_succ_apply f n _
          _ â‰¤ f^[n] (f aâ‚ âŠ” aâ‚‚) := f.mono.iterate n (h aâ‚ aâ‚‚)
          _ â‰¤ f^[n] (f aâ‚) âŠ” aâ‚‚ := ih _ _
          _ = f^[n + 1] aâ‚ âŠ” aâ‚‚ := by rw [â† Function.iterate_succ_apply]
    calc
      f^[nâ‚ + nâ‚‚] (aâ‚ âŠ” aâ‚‚) = f^[nâ‚] (f^[nâ‚‚] (aâ‚ âŠ” aâ‚‚)) :=
        Function.iterate_add_apply f nâ‚ nâ‚‚ _
      _ = f^[nâ‚] (f^[nâ‚‚] (aâ‚‚ âŠ” aâ‚)) := by rw [sup_comm]
      _ â‰¤ f^[nâ‚] (f^[nâ‚‚] aâ‚‚ âŠ” aâ‚) := f.mono.iterate nâ‚ (h' nâ‚‚ _ _)
      _ = f^[nâ‚] (aâ‚ âŠ” f^[nâ‚‚] aâ‚‚) := by rw [sup_comm]
      _ â‰¤ f^[nâ‚] aâ‚ âŠ” f^[nâ‚‚] aâ‚‚ := h' nâ‚ aâ‚ _
#align order_hom.iterate_sup_le_sup_iff OrderHom.iterate_sup_le_sup_iff

end Preorder

end OrderHom
