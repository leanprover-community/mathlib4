/-
Copyright (c) 2022 Johannes HÃ¶lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johanes HÃ¶lzl, Patrick Massot, Yury Kudryashov, Kevin Wilson, Heather Macbeth
-/
import Mathlib.Order.Filter.Basic

/-!
# Product and coproduct filters

In this file we define `Filter.prod f g` (notation: `f Ã—Ë¢ g`) and `Filter.coprod f g`. The product
of two filters is the largest filter `l` such that `Filter.Tendsto Prod.fst l f` and
`Filter.Tendsto Prod.snd l g`.

## Implementation details

The product filter cannot be defined using the monad structure on filters. For example:

```lean
F := do {x â† seq, y â† top, return (x, y)}
G := do {y â† top, x â† seq, return (x, y)}
```
hence:
```lean
s âˆˆ F  â†”  âˆƒ n, [n..âˆ] Ã— univ âŠ† s
s âˆˆ G  â†”  âˆ€ i:â„•, âˆƒ n, [n..âˆ] Ã— {i} âŠ† s
```
Now `â‹ƒ i, [i..âˆ] Ã— {i}` is in `G` but not in `F`.
As product filter we want to have `F` as result.

## Notations

* `f Ã—Ë¢ g` : `Filter.prod f g`, localized in `Filter`.

-/

open Set

open Filter

namespace Filter

variable {Î± Î² Î³ Î´ : Type*} {Î¹ : Sort*}

section Prod

variable {s : Set Î±} {t : Set Î²} {f : Filter Î±} {g : Filter Î²}

/-- Product of filters. This is the filter generated by cartesian products
of elements of the component filters. -/
protected def prod (f : Filter Î±) (g : Filter Î²) : Filter (Î± Ã— Î²) :=
  f.comap Prod.fst âŠ“ g.comap Prod.snd

instance instSProd : SProd (Filter Î±) (Filter Î²) (Filter (Î± Ã— Î²)) where
  sprod := Filter.prod

theorem prod_mem_prod (hs : s âˆˆ f) (ht : t âˆˆ g) : s Ã—Ë¢ t âˆˆ f Ã—Ë¢ g :=
  inter_mem_inf (preimage_mem_comap hs) (preimage_mem_comap ht)

theorem mem_prod_iff {s : Set (Î± Ã— Î²)} {f : Filter Î±} {g : Filter Î²} :
    s âˆˆ f Ã—Ë¢ g â†” âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, tâ‚ Ã—Ë¢ tâ‚‚ âŠ† s := by
  simp only [SProd.sprod, Filter.prod]
  constructor
  Â· rintro âŸ¨tâ‚, âŸ¨sâ‚, hsâ‚, htsâ‚âŸ©, tâ‚‚, âŸ¨sâ‚‚, hsâ‚‚, htsâ‚‚âŸ©, rflâŸ©
    exact âŸ¨sâ‚, hsâ‚, sâ‚‚, hsâ‚‚, fun p âŸ¨h, h'âŸ© => âŸ¨htsâ‚ h, htsâ‚‚ h'âŸ©âŸ©
  Â· rintro âŸ¨tâ‚, htâ‚, tâ‚‚, htâ‚‚, hâŸ©
    exact mem_inf_of_inter (preimage_mem_comap htâ‚) (preimage_mem_comap htâ‚‚) h

@[simp]
theorem prod_mem_prod_iff [f.NeBot] [g.NeBot] : s Ã—Ë¢ t âˆˆ f Ã—Ë¢ g â†” s âˆˆ f âˆ§ t âˆˆ g :=
  âŸ¨fun h =>
    let âŸ¨_s', hs', _t', ht', HâŸ© := mem_prod_iff.1 h
    (prod_subset_prod_iff.1 H).elim
      (fun âŸ¨hs's, ht'tâŸ© => âŸ¨mem_of_superset hs' hs's, mem_of_superset ht' ht'tâŸ©) fun h =>
      h.elim (fun hs'e => absurd hs'e (nonempty_of_mem hs').ne_empty) fun ht'e =>
        absurd ht'e (nonempty_of_mem ht').ne_empty,
    fun h => prod_mem_prod h.1 h.2âŸ©

theorem mem_prod_principal {s : Set (Î± Ã— Î²)} :
    s âˆˆ f Ã—Ë¢ ğ“Ÿ t â†” { a | âˆ€ b âˆˆ t, (a, b) âˆˆ s } âˆˆ f := by
  rw [â† @exists_mem_subset_iff _ f, mem_prod_iff]
  refine exists_congr fun u => Iff.rfl.and âŸ¨?_, fun h => âŸ¨t, mem_principal_self t, ?_âŸ©âŸ©
  Â· rintro âŸ¨v, v_in, hvâŸ© a a_in b b_in
    exact hv (mk_mem_prod a_in <| v_in b_in)
  Â· rintro âŸ¨x, yâŸ© âŸ¨hx, hyâŸ©
    exact h hx y hy

theorem mem_prod_top {s : Set (Î± Ã— Î²)} :
    s âˆˆ f Ã—Ë¢ (âŠ¤ : Filter Î²) â†” { a | âˆ€ b, (a, b) âˆˆ s } âˆˆ f := by
  rw [â† principal_univ, mem_prod_principal]
  simp only [mem_univ, forall_true_left]

theorem eventually_prod_principal_iff {p : Î± Ã— Î² â†’ Prop} {s : Set Î²} :
    (âˆ€á¶  x : Î± Ã— Î² in f Ã—Ë¢ ğ“Ÿ s, p x) â†” âˆ€á¶  x : Î± in f, âˆ€ y : Î², y âˆˆ s â†’ p (x, y) := by
  rw [eventually_iff, eventually_iff, mem_prod_principal]
  simp only [mem_setOf_eq]

theorem comap_prod (f : Î± â†’ Î² Ã— Î³) (b : Filter Î²) (c : Filter Î³) :
    comap f (b Ã—Ë¢ c) = comap (Prod.fst âˆ˜ f) b âŠ“ comap (Prod.snd âˆ˜ f) c := by
  erw [comap_inf, Filter.comap_comap, Filter.comap_comap]

theorem prod_top : f Ã—Ë¢ (âŠ¤ : Filter Î²) = f.comap Prod.fst := by
  dsimp only [SProd.sprod]
  rw [Filter.prod, comap_top, inf_top_eq]

theorem top_prod : (âŠ¤ : Filter Î±) Ã—Ë¢ g = g.comap Prod.snd := by
  dsimp only [SProd.sprod]
  rw [Filter.prod, comap_top, top_inf_eq]

theorem sup_prod (fâ‚ fâ‚‚ : Filter Î±) (g : Filter Î²) : (fâ‚ âŠ” fâ‚‚) Ã—Ë¢ g = (fâ‚ Ã—Ë¢ g) âŠ” (fâ‚‚ Ã—Ë¢ g) := by
  dsimp only [SProd.sprod]
  rw [Filter.prod, comap_sup, inf_sup_right, â† Filter.prod, â† Filter.prod]

theorem prod_sup (f : Filter Î±) (gâ‚ gâ‚‚ : Filter Î²) : f Ã—Ë¢ (gâ‚ âŠ” gâ‚‚) = (f Ã—Ë¢ gâ‚) âŠ” (f Ã—Ë¢ gâ‚‚) := by
  dsimp only [SProd.sprod]
  rw [Filter.prod, comap_sup, inf_sup_left, â† Filter.prod, â† Filter.prod]

theorem eventually_prod_iff {p : Î± Ã— Î² â†’ Prop} :
    (âˆ€á¶  x in f Ã—Ë¢ g, p x) â†”
      âˆƒ pa : Î± â†’ Prop, (âˆ€á¶  x in f, pa x) âˆ§ âˆƒ pb : Î² â†’ Prop, (âˆ€á¶  y in g, pb y) âˆ§
        âˆ€ {x}, pa x â†’ âˆ€ {y}, pb y â†’ p (x, y) := by
  simpa only [Set.prod_subset_iff] using @mem_prod_iff Î± Î² p f g

theorem tendsto_fst : Tendsto Prod.fst (f Ã—Ë¢ g) f :=
  tendsto_inf_left tendsto_comap

theorem tendsto_snd : Tendsto Prod.snd (f Ã—Ë¢ g) g :=
  tendsto_inf_right tendsto_comap

/-- If a function tends to a product `g Ã—Ë¢ h` of filters, then its first component tends to
`g`. See also `Filter.Tendsto.fst_nhds` for the special case of converging to a point in a
product of two topological spaces. -/
theorem Tendsto.fst {h : Filter Î³} {m : Î± â†’ Î² Ã— Î³} (H : Tendsto m f (g Ã—Ë¢ h)) :
    Tendsto (fun a â†¦ (m a).1) f g :=
  tendsto_fst.comp H

/-- If a function tends to a product `g Ã—Ë¢ h` of filters, then its second component tends to
`h`. See also `Filter.Tendsto.snd_nhds` for the special case of converging to a point in a
product of two topological spaces. -/
theorem Tendsto.snd {h : Filter Î³} {m : Î± â†’ Î² Ã— Î³} (H : Tendsto m f (g Ã—Ë¢ h)) :
    Tendsto (fun a â†¦ (m a).2) f h :=
  tendsto_snd.comp H

theorem Tendsto.prod_mk {h : Filter Î³} {mâ‚ : Î± â†’ Î²} {mâ‚‚ : Î± â†’ Î³}
    (hâ‚ : Tendsto mâ‚ f g) (hâ‚‚ : Tendsto mâ‚‚ f h) : Tendsto (fun x => (mâ‚ x, mâ‚‚ x)) f (g Ã—Ë¢ h) :=
  tendsto_inf.2 âŸ¨tendsto_comap_iff.2 hâ‚, tendsto_comap_iff.2 hâ‚‚âŸ©

theorem tendsto_prod_swap : Tendsto (Prod.swap : Î± Ã— Î² â†’ Î² Ã— Î±) (f Ã—Ë¢ g) (g Ã—Ë¢ f) :=
  tendsto_snd.prod_mk tendsto_fst

theorem Eventually.prod_inl {la : Filter Î±} {p : Î± â†’ Prop} (h : âˆ€á¶  x in la, p x) (lb : Filter Î²) :
    âˆ€á¶  x in la Ã—Ë¢ lb, p (x : Î± Ã— Î²).1 :=
  tendsto_fst.eventually h

theorem Eventually.prod_inr {lb : Filter Î²} {p : Î² â†’ Prop} (h : âˆ€á¶  x in lb, p x) (la : Filter Î±) :
    âˆ€á¶  x in la Ã—Ë¢ lb, p (x : Î± Ã— Î²).2 :=
  tendsto_snd.eventually h

theorem Eventually.prod_mk {la : Filter Î±} {pa : Î± â†’ Prop} (ha : âˆ€á¶  x in la, pa x) {lb : Filter Î²}
    {pb : Î² â†’ Prop} (hb : âˆ€á¶  y in lb, pb y) : âˆ€á¶  p in la Ã—Ë¢ lb, pa (p : Î± Ã— Î²).1 âˆ§ pb p.2 :=
  (ha.prod_inl lb).and (hb.prod_inr la)

theorem EventuallyEq.prod_map {Î´} {la : Filter Î±} {fa ga : Î± â†’ Î³} (ha : fa =á¶ [la] ga)
    {lb : Filter Î²} {fb gb : Î² â†’ Î´} (hb : fb =á¶ [lb] gb) :
    Prod.map fa fb =á¶ [la Ã—Ë¢ lb] Prod.map ga gb :=
  (Eventually.prod_mk ha hb).mono fun _ h => Prod.ext h.1 h.2

theorem EventuallyLE.prod_map {Î´} [LE Î³] [LE Î´] {la : Filter Î±} {fa ga : Î± â†’ Î³} (ha : fa â‰¤á¶ [la] ga)
    {lb : Filter Î²} {fb gb : Î² â†’ Î´} (hb : fb â‰¤á¶ [lb] gb) :
    Prod.map fa fb â‰¤á¶ [la Ã—Ë¢ lb] Prod.map ga gb :=
  Eventually.prod_mk ha hb

theorem Eventually.curry {la : Filter Î±} {lb : Filter Î²} {p : Î± Ã— Î² â†’ Prop}
    (h : âˆ€á¶  x in la Ã—Ë¢ lb, p x) : âˆ€á¶  x in la, âˆ€á¶  y in lb, p (x, y) := by
  rcases eventually_prod_iff.1 h with âŸ¨pa, ha, pb, hb, hâŸ©
  exact ha.mono fun a ha => hb.mono fun b hb => h ha hb

protected lemma Frequently.uncurry {la : Filter Î±} {lb : Filter Î²} {p : Î± â†’ Î² â†’ Prop}
    (h : âˆƒá¶  x in la, âˆƒá¶  y in lb, p x y) : âˆƒá¶  xy in la Ã—Ë¢ lb, p xy.1 xy.2 :=
  mt (fun h â†¦ by simpa only [not_frequently] using h.curry) h

/-- A fact that is eventually true about all pairs `l Ã—Ë¢ l` is eventually true about
all diagonal pairs `(i, i)` -/
theorem Eventually.diag_of_prod {p : Î± Ã— Î± â†’ Prop} (h : âˆ€á¶  i in f Ã—Ë¢ f, p i) :
    âˆ€á¶  i in f, p (i, i) := by
  obtain âŸ¨t, ht, s, hs, hstâŸ© := eventually_prod_iff.1 h
  apply (ht.and hs).mono fun x hx => hst hx.1 hx.2

theorem Eventually.diag_of_prod_left {f : Filter Î±} {g : Filter Î³} {p : (Î± Ã— Î±) Ã— Î³ â†’ Prop} :
    (âˆ€á¶  x in (f Ã—Ë¢ f) Ã—Ë¢ g, p x) â†’ âˆ€á¶  x : Î± Ã— Î³ in f Ã—Ë¢ g, p ((x.1, x.1), x.2) := by
  intro h
  obtain âŸ¨t, ht, s, hs, hstâŸ© := eventually_prod_iff.1 h
  exact (ht.diag_of_prod.prod_mk hs).mono fun x hx => by simp only [hst hx.1 hx.2]

theorem Eventually.diag_of_prod_right {f : Filter Î±} {g : Filter Î³} {p : Î± Ã— Î³ Ã— Î³ â†’ Prop} :
    (âˆ€á¶  x in f Ã—Ë¢ (g Ã—Ë¢ g), p x) â†’ âˆ€á¶  x : Î± Ã— Î³ in f Ã—Ë¢ g, p (x.1, x.2, x.2) := by
  intro h
  obtain âŸ¨t, ht, s, hs, hstâŸ© := eventually_prod_iff.1 h
  exact (ht.prod_mk hs.diag_of_prod).mono fun x hx => by simp only [hst hx.1 hx.2]

theorem tendsto_diag : Tendsto (fun i => (i, i)) f (f Ã—Ë¢ f) :=
  tendsto_iff_eventually.mpr fun _ hpr => hpr.diag_of_prod

theorem prod_iInf_left [Nonempty Î¹] {f : Î¹ â†’ Filter Î±} {g : Filter Î²} :
    (â¨… i, f i) Ã—Ë¢ g = â¨… i, f i Ã—Ë¢ g := by
  dsimp only [SProd.sprod]
  rw [Filter.prod, comap_iInf, iInf_inf]
  simp only [Filter.prod, eq_self_iff_true]

theorem prod_iInf_right [Nonempty Î¹] {f : Filter Î±} {g : Î¹ â†’ Filter Î²} :
    (f Ã—Ë¢ â¨… i, g i) = â¨… i, f Ã—Ë¢ g i := by
  dsimp only [SProd.sprod]
  rw [Filter.prod, comap_iInf, inf_iInf]
  simp only [Filter.prod, eq_self_iff_true]

@[mono, gcongr]
theorem prod_mono {fâ‚ fâ‚‚ : Filter Î±} {gâ‚ gâ‚‚ : Filter Î²} (hf : fâ‚ â‰¤ fâ‚‚) (hg : gâ‚ â‰¤ gâ‚‚) :
    fâ‚ Ã—Ë¢ gâ‚ â‰¤ fâ‚‚ Ã—Ë¢ gâ‚‚ :=
  inf_le_inf (comap_mono hf) (comap_mono hg)

@[gcongr]
theorem prod_mono_left (g : Filter Î²) {fâ‚ fâ‚‚ : Filter Î±} (hf : fâ‚ â‰¤ fâ‚‚) : fâ‚ Ã—Ë¢ g â‰¤ fâ‚‚ Ã—Ë¢ g :=
  Filter.prod_mono hf rfl.le

@[gcongr]
theorem prod_mono_right (f : Filter Î±) {gâ‚ gâ‚‚ : Filter Î²} (hf : gâ‚ â‰¤ gâ‚‚) : f Ã—Ë¢ gâ‚ â‰¤ f Ã—Ë¢ gâ‚‚ :=
  Filter.prod_mono rfl.le hf

theorem prod_comap_comap_eq.{u, v, w, x} {Î±â‚ : Type u} {Î±â‚‚ : Type v} {Î²â‚ : Type w} {Î²â‚‚ : Type x}
    {fâ‚ : Filter Î±â‚} {fâ‚‚ : Filter Î±â‚‚} {mâ‚ : Î²â‚ â†’ Î±â‚} {mâ‚‚ : Î²â‚‚ â†’ Î±â‚‚} :
    comap mâ‚ fâ‚ Ã—Ë¢ comap mâ‚‚ fâ‚‚ = comap (fun p : Î²â‚ Ã— Î²â‚‚ => (mâ‚ p.1, mâ‚‚ p.2)) (fâ‚ Ã—Ë¢ fâ‚‚) := by
  simp only [SProd.sprod, Filter.prod, comap_comap, comap_inf, (Â· âˆ˜ Â·)]

theorem prod_comm' : f Ã—Ë¢ g = comap Prod.swap (g Ã—Ë¢ f) := by
  simp only [SProd.sprod, Filter.prod, comap_comap, (Â· âˆ˜ Â·), inf_comm, Prod.swap, comap_inf]

theorem prod_comm : f Ã—Ë¢ g = map (fun p : Î² Ã— Î± => (p.2, p.1)) (g Ã—Ë¢ f) := by
  rw [prod_comm', â† map_swap_eq_comap_swap]
  rfl

theorem mem_prod_iff_left {s : Set (Î± Ã— Î²)} :
    s âˆˆ f Ã—Ë¢ g â†” âˆƒ t âˆˆ f, âˆ€á¶  y in g, âˆ€ x âˆˆ t, (x, y) âˆˆ s := by
  simp only [mem_prod_iff, prod_subset_iff]
  refine exists_congr fun _ => Iff.rfl.and <| Iff.trans ?_ exists_mem_subset_iff
  exact exists_congr fun _ => Iff.rfl.and forallâ‚‚_swap

theorem mem_prod_iff_right {s : Set (Î± Ã— Î²)} :
    s âˆˆ f Ã—Ë¢ g â†” âˆƒ t âˆˆ g, âˆ€á¶  x in f, âˆ€ y âˆˆ t, (x, y) âˆˆ s := by
  rw [prod_comm, mem_map, mem_prod_iff_left]; rfl

@[simp]
theorem map_fst_prod (f : Filter Î±) (g : Filter Î²) [NeBot g] : map Prod.fst (f Ã—Ë¢ g) = f := by
  ext s
  simp only [mem_map, mem_prod_iff_left, mem_preimage, eventually_const, â† subset_def,
    exists_mem_subset_iff]

@[simp]
theorem map_snd_prod (f : Filter Î±) (g : Filter Î²) [NeBot f] : map Prod.snd (f Ã—Ë¢ g) = g := by
  rw [prod_comm, map_map]; apply map_fst_prod

@[simp]
theorem prod_le_prod {fâ‚ fâ‚‚ : Filter Î±} {gâ‚ gâ‚‚ : Filter Î²} [NeBot fâ‚] [NeBot gâ‚] :
    fâ‚ Ã—Ë¢ gâ‚ â‰¤ fâ‚‚ Ã—Ë¢ gâ‚‚ â†” fâ‚ â‰¤ fâ‚‚ âˆ§ gâ‚ â‰¤ gâ‚‚ :=
  âŸ¨fun h =>
    âŸ¨map_fst_prod fâ‚ gâ‚ â–¸ tendsto_fst.mono_left h, map_snd_prod fâ‚ gâ‚ â–¸ tendsto_snd.mono_left hâŸ©,
    fun h => prod_mono h.1 h.2âŸ©

@[simp]
theorem prod_inj {fâ‚ fâ‚‚ : Filter Î±} {gâ‚ gâ‚‚ : Filter Î²} [NeBot fâ‚] [NeBot gâ‚] :
    fâ‚ Ã—Ë¢ gâ‚ = fâ‚‚ Ã—Ë¢ gâ‚‚ â†” fâ‚ = fâ‚‚ âˆ§ gâ‚ = gâ‚‚ := by
  refine âŸ¨fun h => ?_, fun h => h.1 â–¸ h.2 â–¸ rflâŸ©
  have hle : fâ‚ â‰¤ fâ‚‚ âˆ§ gâ‚ â‰¤ gâ‚‚ := prod_le_prod.1 h.le
  haveI := neBot_of_le hle.1; haveI := neBot_of_le hle.2
  exact âŸ¨hle.1.antisymm <| (prod_le_prod.1 h.ge).1, hle.2.antisymm <| (prod_le_prod.1 h.ge).2âŸ©

theorem eventually_swap_iff {p : Î± Ã— Î² â†’ Prop} :
    (âˆ€á¶  x : Î± Ã— Î² in f Ã—Ë¢ g, p x) â†” âˆ€á¶  y : Î² Ã— Î± in g Ã—Ë¢ f, p y.swap := by
  rw [prod_comm]; rfl

theorem prod_assoc (f : Filter Î±) (g : Filter Î²) (h : Filter Î³) :
    map (Equiv.prodAssoc Î± Î² Î³) ((f Ã—Ë¢ g) Ã—Ë¢ h) = f Ã—Ë¢ (g Ã—Ë¢ h) := by
  simp_rw [â† comap_equiv_symm, SProd.sprod, Filter.prod, comap_inf, comap_comap, inf_assoc, (Â· âˆ˜ Â·),
    Equiv.prodAssoc_symm_apply]

theorem prod_assoc_symm (f : Filter Î±) (g : Filter Î²) (h : Filter Î³) :
    map (Equiv.prodAssoc Î± Î² Î³).symm (f Ã—Ë¢ (g Ã—Ë¢ h)) = (f Ã—Ë¢ g) Ã—Ë¢ h := by
  simp_rw [map_equiv_symm, SProd.sprod, Filter.prod, comap_inf, comap_comap, inf_assoc,
    Function.comp, Equiv.prodAssoc_apply]

theorem tendsto_prodAssoc {h : Filter Î³} :
    Tendsto (Equiv.prodAssoc Î± Î² Î³) ((f Ã—Ë¢ g) Ã—Ë¢ h) (f Ã—Ë¢ (g Ã—Ë¢ h)) :=
  (prod_assoc f g h).le

theorem tendsto_prodAssoc_symm {h : Filter Î³} :
    Tendsto (Equiv.prodAssoc Î± Î² Î³).symm (f Ã—Ë¢ (g Ã—Ë¢ h)) ((f Ã—Ë¢ g) Ã—Ë¢ h) :=
  (prod_assoc_symm f g h).le

/-- A useful lemma when dealing with uniformities. -/
theorem map_swap4_prod {h : Filter Î³} {k : Filter Î´} :
    map (fun p : (Î± Ã— Î²) Ã— Î³ Ã— Î´ => ((p.1.1, p.2.1), (p.1.2, p.2.2))) ((f Ã—Ë¢ g) Ã—Ë¢ (h Ã—Ë¢ k)) =
      (f Ã—Ë¢ h) Ã—Ë¢ (g Ã—Ë¢ k) := by
  simp_rw [map_swap4_eq_comap, SProd.sprod, Filter.prod, comap_inf, comap_comap]; ac_rfl

theorem tendsto_swap4_prod {h : Filter Î³} {k : Filter Î´} :
    Tendsto (fun p : (Î± Ã— Î²) Ã— Î³ Ã— Î´ => ((p.1.1, p.2.1), (p.1.2, p.2.2))) ((f Ã—Ë¢ g) Ã—Ë¢ (h Ã—Ë¢ k))
      ((f Ã—Ë¢ h) Ã—Ë¢ (g Ã—Ë¢ k)) :=
  map_swap4_prod.le

theorem prod_map_map_eq.{u, v, w, x} {Î±â‚ : Type u} {Î±â‚‚ : Type v} {Î²â‚ : Type w} {Î²â‚‚ : Type x}
    {fâ‚ : Filter Î±â‚} {fâ‚‚ : Filter Î±â‚‚} {mâ‚ : Î±â‚ â†’ Î²â‚} {mâ‚‚ : Î±â‚‚ â†’ Î²â‚‚} :
    map mâ‚ fâ‚ Ã—Ë¢ map mâ‚‚ fâ‚‚ = map (fun p : Î±â‚ Ã— Î±â‚‚ => (mâ‚ p.1, mâ‚‚ p.2)) (fâ‚ Ã—Ë¢ fâ‚‚) :=
  le_antisymm
    (fun s hs =>
      let âŸ¨sâ‚, hsâ‚, sâ‚‚, hsâ‚‚, hâŸ© := mem_prod_iff.mp hs
      mem_of_superset (prod_mem_prod (image_mem_map hsâ‚) (image_mem_map hsâ‚‚)) <|
        by rwa [prod_image_image_eq, image_subset_iff])
    ((tendsto_map.comp tendsto_fst).prod_mk (tendsto_map.comp tendsto_snd))

theorem prod_map_map_eq' {Î±â‚ : Type*} {Î±â‚‚ : Type*} {Î²â‚ : Type*} {Î²â‚‚ : Type*} (f : Î±â‚ â†’ Î±â‚‚)
    (g : Î²â‚ â†’ Î²â‚‚) (F : Filter Î±â‚) (G : Filter Î²â‚) :
    map f F Ã—Ë¢ map g G = map (Prod.map f g) (F Ã—Ë¢ G) :=
  prod_map_map_eq

theorem prod_map_left (f : Î± â†’ Î²) (F : Filter Î±) (G : Filter Î³) :
    map f F Ã—Ë¢ G = map (Prod.map f id) (F Ã—Ë¢ G) := by
  rw [â† prod_map_map_eq', map_id]

theorem prod_map_right (f : Î² â†’ Î³) (F : Filter Î±) (G : Filter Î²) :
    F Ã—Ë¢ map f G = map (Prod.map id f) (F Ã—Ë¢ G) := by
  rw [â† prod_map_map_eq', map_id]

theorem le_prod_map_fst_snd {f : Filter (Î± Ã— Î²)} : f â‰¤ map Prod.fst f Ã—Ë¢ map Prod.snd f :=
  le_inf le_comap_map le_comap_map

theorem Tendsto.prod_map {Î´ : Type*} {f : Î± â†’ Î³} {g : Î² â†’ Î´} {a : Filter Î±} {b : Filter Î²}
    {c : Filter Î³} {d : Filter Î´} (hf : Tendsto f a c) (hg : Tendsto g b d) :
    Tendsto (Prod.map f g) (a Ã—Ë¢ b) (c Ã—Ë¢ d) := by
  erw [Tendsto, â† prod_map_map_eq]
  exact Filter.prod_mono hf hg

protected theorem map_prod (m : Î± Ã— Î² â†’ Î³) (f : Filter Î±) (g : Filter Î²) :
    map m (f Ã—Ë¢ g) = (f.map fun a b => m (a, b)).seq g := by
  simp only [Filter.ext_iff, mem_map, mem_prod_iff, mem_map_seq_iff, exists_and_left]
  intro s
  constructor
  Â· exact fun âŸ¨t, ht, s, hs, hâŸ© => âŸ¨s, hs, t, ht, fun x hx y hy => @h âŸ¨x, yâŸ© âŸ¨hx, hyâŸ©âŸ©
  Â· exact fun âŸ¨s, hs, t, ht, hâŸ© => âŸ¨t, ht, s, hs, fun âŸ¨x, yâŸ© âŸ¨hx, hyâŸ© => h x hx y hyâŸ©

theorem prod_eq : f Ã—Ë¢ g = (f.map Prod.mk).seq g := f.map_prod id g

theorem prod_inf_prod {fâ‚ fâ‚‚ : Filter Î±} {gâ‚ gâ‚‚ : Filter Î²} :
    (fâ‚ Ã—Ë¢ gâ‚) âŠ“ (fâ‚‚ Ã—Ë¢ gâ‚‚) = (fâ‚ âŠ“ fâ‚‚) Ã—Ë¢ (gâ‚ âŠ“ gâ‚‚) := by
  simp only [SProd.sprod, Filter.prod, comap_inf, inf_comm, inf_assoc, inf_left_comm]

theorem inf_prod {fâ‚ fâ‚‚ : Filter Î±} : (fâ‚ âŠ“ fâ‚‚) Ã—Ë¢ g = (fâ‚ Ã—Ë¢ g) âŠ“ (fâ‚‚ Ã—Ë¢ g) := by
  rw [prod_inf_prod, inf_idem]

theorem prod_inf {gâ‚ gâ‚‚ : Filter Î²} : f Ã—Ë¢ (gâ‚ âŠ“ gâ‚‚) = (f Ã—Ë¢ gâ‚) âŠ“ (f Ã—Ë¢ gâ‚‚) := by
  rw [prod_inf_prod, inf_idem]

@[simp]
theorem prod_principal_principal {s : Set Î±} {t : Set Î²} : ğ“Ÿ s Ã—Ë¢ ğ“Ÿ t = ğ“Ÿ (s Ã—Ë¢ t) := by
  simp only [SProd.sprod, Filter.prod, comap_principal, principal_eq_iff_eq, comap_principal,
    inf_principal]; rfl

@[simp]
theorem pure_prod {a : Î±} {f : Filter Î²} : pure a Ã—Ë¢ f = map (Prod.mk a) f := by
  rw [prod_eq, map_pure, pure_seq_eq_map]

theorem map_pure_prod (f : Î± â†’ Î² â†’ Î³) (a : Î±) (B : Filter Î²) :
    map (Function.uncurry f) (pure a Ã—Ë¢ B) = map (f a) B := by
  rw [Filter.pure_prod]; rfl

@[simp]
theorem prod_pure {b : Î²} : f Ã—Ë¢ pure b = map (fun a => (a, b)) f := by
  rw [prod_eq, seq_pure, map_map]; rfl

theorem prod_pure_pure {a : Î±} {b : Î²} :
    (pure a : Filter Î±) Ã—Ë¢ (pure b : Filter Î²) = pure (a, b) := by simp

theorem principal_prod_principle (a : Î±) (b : Î²) : ğ“Ÿ {a} Ã—Ë¢ ğ“Ÿ {b} = ğ“Ÿ {(a, b)} := by
  simp

@[simp]
theorem prod_eq_bot : f Ã—Ë¢ g = âŠ¥ â†” f = âŠ¥ âˆ¨ g = âŠ¥ := by
  simp_rw [â† empty_mem_iff_bot, mem_prod_iff, subset_empty_iff, prod_eq_empty_iff, â† exists_prop,
    Subtype.exists', exists_or, exists_const, Subtype.exists, exists_prop, exists_eq_right]

@[simp] theorem prod_bot : f Ã—Ë¢ (âŠ¥ : Filter Î²) = âŠ¥ := prod_eq_bot.2 <| Or.inr rfl

@[simp] theorem bot_prod : (âŠ¥ : Filter Î±) Ã—Ë¢ g = âŠ¥ := prod_eq_bot.2 <| Or.inl rfl

theorem prod_neBot : NeBot (f Ã—Ë¢ g) â†” NeBot f âˆ§ NeBot g := by
  simp only [neBot_iff, Ne, prod_eq_bot, not_or]

protected theorem NeBot.prod (hf : NeBot f) (hg : NeBot g) : NeBot (f Ã—Ë¢ g) := prod_neBot.2 âŸ¨hf, hgâŸ©

instance prod.instNeBot [hf : NeBot f] [hg : NeBot g] : NeBot (f Ã—Ë¢ g) := hf.prod hg

@[simp]
lemma disjoint_prod {f' : Filter Î±} {g' : Filter Î²} :
    Disjoint (f Ã—Ë¢ g) (f' Ã—Ë¢ g') â†” Disjoint f f' âˆ¨ Disjoint g g' := by
  simp only [disjoint_iff, prod_inf_prod, prod_eq_bot]

/-- `p âˆ§ q` occurs frequently along the product of two filters
iff both `p` and `q` occur frequently along the corresponding filters. -/
theorem frequently_prod_and {p : Î± â†’ Prop} {q : Î² â†’ Prop} :
    (âˆƒá¶  x in f Ã—Ë¢ g, p x.1 âˆ§ q x.2) â†” (âˆƒá¶  a in f, p a) âˆ§ âˆƒá¶  b in g, q b := by
  simp only [frequently_iff_neBot, â† prod_neBot, â† prod_inf_prod, prod_principal_principal]
  rfl

theorem tendsto_prod_iff {f : Î± Ã— Î² â†’ Î³} {x : Filter Î±} {y : Filter Î²} {z : Filter Î³} :
    Tendsto f (x Ã—Ë¢ y) z â†” âˆ€ W âˆˆ z, âˆƒ U âˆˆ x, âˆƒ V âˆˆ y, âˆ€ x y, x âˆˆ U â†’ y âˆˆ V â†’ f (x, y) âˆˆ W := by
  simp only [tendsto_def, mem_prod_iff, prod_sub_preimage_iff, exists_prop, iff_self_iff]

theorem tendsto_prod_iff' {g' : Filter Î³} {s : Î± â†’ Î² Ã— Î³} :
    Tendsto s f (g Ã—Ë¢ g') â†” Tendsto (fun n => (s n).1) f g âˆ§ Tendsto (fun n => (s n).2) f g' := by
  dsimp only [SProd.sprod]
  unfold Filter.prod
  simp only [tendsto_inf, tendsto_comap_iff, (Â· âˆ˜ Â·)]

theorem le_prod {f : Filter (Î± Ã— Î²)} {g : Filter Î±} {g' : Filter Î²} :
    (f â‰¤ g Ã—Ë¢ g') â†” Tendsto Prod.fst f g âˆ§ Tendsto Prod.snd f g' :=
  tendsto_prod_iff'

end Prod

/-! ### Coproducts of filters -/

section Coprod

variable {f : Filter Î±} {g : Filter Î²}

/-- Coproduct of filters. -/
protected def coprod (f : Filter Î±) (g : Filter Î²) : Filter (Î± Ã— Î²) :=
  f.comap Prod.fst âŠ” g.comap Prod.snd

theorem coprod_eq_prod_top_sup_top_prod (f : Filter Î±) (g : Filter Î²) :
    Filter.coprod f g = f Ã—Ë¢ âŠ¤ âŠ” âŠ¤ Ã—Ë¢ g := by
  rw [prod_top, top_prod]
  rfl

theorem mem_coprod_iff {s : Set (Î± Ã— Î²)} {f : Filter Î±} {g : Filter Î²} :
    s âˆˆ f.coprod g â†” (âˆƒ tâ‚ âˆˆ f, Prod.fst â»Â¹' tâ‚ âŠ† s) âˆ§ âˆƒ tâ‚‚ âˆˆ g, Prod.snd â»Â¹' tâ‚‚ âŠ† s := by
  simp [Filter.coprod]

@[simp]
theorem bot_coprod (l : Filter Î²) : (âŠ¥ : Filter Î±).coprod l = comap Prod.snd l := by
  simp [Filter.coprod]

@[simp]
theorem coprod_bot (l : Filter Î±) : l.coprod (âŠ¥ : Filter Î²) = comap Prod.fst l := by
  simp [Filter.coprod]

theorem bot_coprod_bot : (âŠ¥ : Filter Î±).coprod (âŠ¥ : Filter Î²) = âŠ¥ := by simp

theorem compl_mem_coprod {s : Set (Î± Ã— Î²)} {la : Filter Î±} {lb : Filter Î²} :
    sá¶œ âˆˆ la.coprod lb â†” (Prod.fst '' s)á¶œ âˆˆ la âˆ§ (Prod.snd '' s)á¶œ âˆˆ lb := by
  simp only [Filter.coprod, mem_sup, compl_mem_comap]

@[mono]
theorem coprod_mono {fâ‚ fâ‚‚ : Filter Î±} {gâ‚ gâ‚‚ : Filter Î²} (hf : fâ‚ â‰¤ fâ‚‚) (hg : gâ‚ â‰¤ gâ‚‚) :
    fâ‚.coprod gâ‚ â‰¤ fâ‚‚.coprod gâ‚‚ :=
  sup_le_sup (comap_mono hf) (comap_mono hg)

theorem coprod_neBot_iff : (f.coprod g).NeBot â†” f.NeBot âˆ§ Nonempty Î² âˆ¨ Nonempty Î± âˆ§ g.NeBot := by
  simp [Filter.coprod]

@[instance]
theorem coprod_neBot_left [NeBot f] [Nonempty Î²] : (f.coprod g).NeBot :=
  coprod_neBot_iff.2 (Or.inl âŸ¨â€¹_â€º, â€¹_â€ºâŸ©)

@[instance]
theorem coprod_neBot_right [NeBot g] [Nonempty Î±] : (f.coprod g).NeBot :=
  coprod_neBot_iff.2 (Or.inr âŸ¨â€¹_â€º, â€¹_â€ºâŸ©)

theorem principal_coprod_principal (s : Set Î±) (t : Set Î²) :
    (ğ“Ÿ s).coprod (ğ“Ÿ t) = ğ“Ÿ (sá¶œ Ã—Ë¢ tá¶œ)á¶œ := by
  rw [Filter.coprod, comap_principal, comap_principal, sup_principal, Set.prod_eq, compl_inter,
    preimage_compl, preimage_compl, compl_compl, compl_compl]

-- this inequality can be strict; see `map_const_principal_coprod_map_id_principal` and
-- `map_prod_map_const_id_principal_coprod_principal` below.
theorem map_prod_map_coprod_le.{u, v, w, x} {Î±â‚ : Type u} {Î±â‚‚ : Type v} {Î²â‚ : Type w} {Î²â‚‚ : Type x}
    {fâ‚ : Filter Î±â‚} {fâ‚‚ : Filter Î±â‚‚} {mâ‚ : Î±â‚ â†’ Î²â‚} {mâ‚‚ : Î±â‚‚ â†’ Î²â‚‚} :
    map (Prod.map mâ‚ mâ‚‚) (fâ‚.coprod fâ‚‚) â‰¤ (map mâ‚ fâ‚).coprod (map mâ‚‚ fâ‚‚) := by
  intro s
  simp only [mem_map, mem_coprod_iff]
  rintro âŸ¨âŸ¨uâ‚, huâ‚, hâ‚âŸ©, uâ‚‚, huâ‚‚, hâ‚‚âŸ©
  refine âŸ¨âŸ¨mâ‚ â»Â¹' uâ‚, huâ‚, fun _ hx => hâ‚ ?_âŸ©, âŸ¨mâ‚‚ â»Â¹' uâ‚‚, huâ‚‚, fun _ hx => hâ‚‚ ?_âŸ©âŸ© <;> convert hx

/-- Characterization of the coproduct of the `Filter.map`s of two principal filters `ğ“Ÿ {a}` and
`ğ“Ÿ {i}`, the first under the constant function `fun a => b` and the second under the identity
function. Together with the next lemma, `map_prod_map_const_id_principal_coprod_principal`, this
provides an example showing that the inequality in the lemma `map_prod_map_coprod_le` can be strict.
-/
theorem map_const_principal_coprod_map_id_principal {Î± Î² Î¹ : Type*} (a : Î±) (b : Î²) (i : Î¹) :
    (map (fun _ => b) (ğ“Ÿ {a})).coprod (map id (ğ“Ÿ {i})) =
      ğ“Ÿ ((({b} : Set Î²) Ã—Ë¢ univ) âˆª (univ Ã—Ë¢ ({i} : Set Î¹))) := by
  simp only [map_principal, Filter.coprod, comap_principal, sup_principal, image_singleton,
    image_id, prod_univ, univ_prod, id]

/-- Characterization of the `Filter.map` of the coproduct of two principal filters `ğ“Ÿ {a}` and
`ğ“Ÿ {i}`, under the `Prod.map` of two functions, respectively the constant function `fun a => b` and
the identity function.  Together with the previous lemma,
`map_const_principal_coprod_map_id_principal`, this provides an example showing that the inequality
in the lemma `map_prod_map_coprod_le` can be strict. -/
theorem map_prod_map_const_id_principal_coprod_principal {Î± Î² Î¹ : Type*} (a : Î±) (b : Î²) (i : Î¹) :
    map (Prod.map (fun _ : Î± => b) id) ((ğ“Ÿ {a}).coprod (ğ“Ÿ {i})) =
      ğ“Ÿ (({b} : Set Î²) Ã—Ë¢ (univ : Set Î¹)) := by
  rw [principal_coprod_principal, map_principal]
  congr
  ext âŸ¨b', i'âŸ©
  constructor
  Â· rintro âŸ¨âŸ¨a'', i''âŸ©, _, hâ‚‚, hâ‚ƒâŸ©
    simp
  Â· rintro âŸ¨hâ‚, _âŸ©
    use (a, i')
    simpa using hâ‚.symm

theorem Tendsto.prod_map_coprod {Î´ : Type*} {f : Î± â†’ Î³} {g : Î² â†’ Î´} {a : Filter Î±} {b : Filter Î²}
    {c : Filter Î³} {d : Filter Î´} (hf : Tendsto f a c) (hg : Tendsto g b d) :
    Tendsto (Prod.map f g) (a.coprod b) (c.coprod d) :=
  map_prod_map_coprod_le.trans (coprod_mono hf hg)

end Coprod

end Filter
