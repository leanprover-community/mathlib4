/-
Copyright (c) 2017 Johannes HÃ¶lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes HÃ¶lzl, Jeremy Avigad, Yury Kudryashov, Patrick Massot
-/
import Mathlib.Data.Set.Piecewise
import Mathlib.Order.Filter.Basic

/-!
# Definition of `Filter.atTop` and `Filter.atBot` filters

In this file we define the filters

* `Filter.atTop`: corresponds to `n â†’ +âˆ`;
* `Filter.atBot`: corresponds to `n â†’ -âˆ`.
-/

assert_not_exists Finset

variable {Î¹ Î¹' Î± Î² Î³ : Type*}

open Set

namespace Filter

/-- `atTop` is the filter representing the limit `â†’ âˆ` on an ordered set.
  It is generated by the collection of up-sets `{b | a â‰¤ b}`.
  (The preorder need not have a top element for this to be well defined,
  and indeed is trivial when a top element exists.) -/
def atTop [Preorder Î±] : Filter Î± :=
  â¨… a, ğ“Ÿ (Ici a)

/-- `atBot` is the filter representing the limit `â†’ -âˆ` on an ordered set.
  It is generated by the collection of down-sets `{b | b â‰¤ a}`.
  (The preorder need not have a bottom element for this to be well defined,
  and indeed is trivial when a bottom element exists.) -/
def atBot [Preorder Î±] : Filter Î± :=
  â¨… a, ğ“Ÿ (Iic a)

theorem mem_atTop [Preorder Î±] (a : Î±) : { b : Î± | a â‰¤ b } âˆˆ @atTop Î± _ :=
  mem_iInf_of_mem a <| Subset.refl _

theorem Ici_mem_atTop [Preorder Î±] (a : Î±) : Ici a âˆˆ (atTop : Filter Î±) :=
  mem_atTop a

theorem Ioi_mem_atTop [Preorder Î±] [NoTopOrder Î±] (x : Î±) : Ioi x âˆˆ (atTop : Filter Î±) :=
  let âŸ¨z, hzâŸ© := exists_not_le x
  mem_of_superset (inter_mem (mem_atTop x) (mem_atTop z))
    fun _ âŸ¨hxy, hzyâŸ© â†¦ lt_of_le_not_ge hxy fun hyx â†¦ hz (hzy.trans hyx)

theorem mem_atBot [Preorder Î±] (a : Î±) : { b : Î± | b â‰¤ a } âˆˆ @atBot Î± _ :=
  mem_iInf_of_mem a <| Subset.refl _

theorem Iic_mem_atBot [Preorder Î±] (a : Î±) : Iic a âˆˆ (atBot : Filter Î±) :=
  mem_atBot a

theorem Iio_mem_atBot [Preorder Î±] [NoBotOrder Î±] (x : Î±) : Iio x âˆˆ (atBot : Filter Î±) :=
  let âŸ¨z, hzâŸ© := exists_not_ge x
  mem_of_superset (inter_mem (mem_atBot x) (mem_atBot z))
    fun _ âŸ¨hyx, hyzâŸ© â†¦ lt_of_le_not_ge hyx fun hxy â†¦ hz (hxy.trans hyz)

theorem eventually_ge_atTop [Preorder Î±] (a : Î±) : âˆ€á¶  x in atTop, a â‰¤ x :=
  mem_atTop a

theorem eventually_le_atBot [Preorder Î±] (a : Î±) : âˆ€á¶  x in atBot, x â‰¤ a :=
  mem_atBot a

theorem eventually_gt_atTop [Preorder Î±] [NoTopOrder Î±] (a : Î±) : âˆ€á¶  x in atTop, a < x :=
  Ioi_mem_atTop a

theorem eventually_ne_atTop [Preorder Î±] [NoTopOrder Î±] (a : Î±) : âˆ€á¶  x in atTop, x â‰  a :=
  (eventually_gt_atTop a).mono fun _ â†¦ ne_of_gt

theorem eventually_lt_atBot [Preorder Î±] [NoBotOrder Î±] (a : Î±) : âˆ€á¶  x in atBot, x < a :=
  Iio_mem_atBot a

theorem eventually_ne_atBot [Preorder Î±] [NoBotOrder Î±] (a : Î±) : âˆ€á¶  x in atBot, x â‰  a :=
  (eventually_lt_atBot a).mono fun _ â†¦ ne_of_lt

theorem _root_.IsTop.atTop_eq [Preorder Î±] {a : Î±} (ha : IsTop a) : atTop = ğ“Ÿ (Ici a) :=
  (iInf_le _ _).antisymm <| le_iInf fun b â†¦ principal_mono.2 <| Ici_subset_Ici.2 <| ha b

theorem _root_.IsBot.atBot_eq [Preorder Î±] {a : Î±} (ha : IsBot a) : atBot = ğ“Ÿ (Iic a) :=
  ha.toDual.atTop_eq

theorem atTop_eq_generate_Ici [Preorder Î±] : atTop = generate (range (Ici (Î± := Î±))) := by
  simp only [generate_eq_biInf, atTop, iInf_range]

theorem Frequently.forall_exists_of_atTop [Preorder Î±] {p : Î± â†’ Prop}
    (h : âˆƒá¶  x in atTop, p x) (a : Î±) : âˆƒ b â‰¥ a, p b := by
  rw [Filter.Frequently] at h
  contrapose! h
  exact (eventually_ge_atTop a).mono h

theorem Frequently.forall_exists_of_atBot [Preorder Î±] {p : Î± â†’ Prop}
    (h : âˆƒá¶  x in atBot, p x) (a : Î±) : âˆƒ b â‰¤ a, p b :=
  Frequently.forall_exists_of_atTop (Î± := Î±áµ’áµˆ) h _

lemma atTop_eq_generate_of_forall_exists_le [Preorder Î±] {s : Set Î±} (hs : âˆ€ x, âˆƒ y âˆˆ s, x â‰¤ y) :
    (atTop : Filter Î±) = generate (Ici '' s) := by
  rw [atTop_eq_generate_Ici]
  apply le_antisymm
  Â· rw [le_generate_iff]
    rintro - âŸ¨y, -, rflâŸ©
    exact mem_generate_of_mem âŸ¨y, rflâŸ©
  Â· rw [le_generate_iff]
    rintro - âŸ¨x, -, -, rflâŸ©
    rcases hs x with âŸ¨y, ys, hyâŸ©
    have A : Ici y âˆˆ generate (Ici '' s) := mem_generate_of_mem (mem_image_of_mem _ ys)
    have B : Ici y âŠ† Ici x := Ici_subset_Ici.2 hy
    exact sets_of_superset (generate (Ici '' s)) A B

lemma atTop_eq_generate_of_not_bddAbove [LinearOrder Î±] {s : Set Î±} (hs : Â¬ BddAbove s) :
    (atTop : Filter Î±) = generate (Ici '' s) := by
  refine atTop_eq_generate_of_forall_exists_le fun x â†¦ ?_
  obtain âŸ¨y, hy, hy'âŸ© := not_bddAbove_iff.mp hs x
  exact âŸ¨y, hy, hy'.leâŸ©

end Filter

open Filter

theorem Monotone.piecewise_eventually_eq_iUnion {Î² : Î± â†’ Type*} [Preorder Î¹] {s : Î¹ â†’ Set Î±}
    [âˆ€ i, DecidablePred (Â· âˆˆ s i)] [DecidablePred (Â· âˆˆ â‹ƒ i, s i)]
    (hs : Monotone s) (f g : (a : Î±) â†’ Î² a) (a : Î±) :
    âˆ€á¶  i in atTop, (s i).piecewise f g a = (â‹ƒ i, s i).piecewise f g a := by
  rcases em (âˆƒ i, a âˆˆ s i) with âŸ¨i, hiâŸ© | ha
  Â· refine (eventually_ge_atTop i).mono fun j hij â†¦ ?_
    simp only [Set.piecewise_eq_of_mem, hs hij hi, subset_iUnion _ _ hi]
  Â· filter_upwards with i
    simp only [Set.piecewise_eq_of_notMem, not_exists.1 ha i, mt mem_iUnion.1 ha,
      not_false_eq_true]

theorem Antitone.piecewise_eventually_eq_iInter {Î² : Î± â†’ Type*} [Preorder Î¹] {s : Î¹ â†’ Set Î±}
    [âˆ€ i, DecidablePred (Â· âˆˆ s i)] [DecidablePred (Â· âˆˆ â‹‚ i, s i)]
    (hs : Antitone s) (f g : (a : Î±) â†’ Î² a) (a : Î±) :
    âˆ€á¶  i in atTop, (s i).piecewise f g a = (â‹‚ i, s i).piecewise f g a := by
  classical
  convert â† (compl_anti.comp hs).piecewise_eventually_eq_iUnion g f a using 3
  Â· convert congr_fun (Set.piecewise_compl (s _) g f) a
  Â· simp only [(Â· âˆ˜ Â·), â† compl_iInter, Set.piecewise_compl]
