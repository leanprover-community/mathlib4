/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Jeremy Avigad, Yury Kudryashov, Patrick Massot
-/
import Mathlib.Data.Set.Piecewise
import Mathlib.Order.Filter.Basic

/-!
# Definition of `Filter.atTop` and `Filter.atBot` filters

In this file we define the filters

* `Filter.atTop`: corresponds to `n ‚Üí +‚àû`;
* `Filter.atBot`: corresponds to `n ‚Üí -‚àû`.
-/

assert_not_exists Finset

variable {Œπ Œπ' Œ± Œ≤ Œ≥ : Type*}

open Set

namespace Filter

/-- `atTop` is the filter representing the limit `‚Üí ‚àû` on an ordered set.
  It is generated by the collection of up-sets `{b | a ‚â§ b}`.
  (The preorder need not have a top element for this to be well defined,
  and indeed is trivial when a top element exists.) -/
def atTop [Preorder Œ±] : Filter Œ± :=
  ‚®Ö a, ùìü (Ici a)

/-- `atBot` is the filter representing the limit `‚Üí -‚àû` on an ordered set.
  It is generated by the collection of down-sets `{b | b ‚â§ a}`.
  (The preorder need not have a bottom element for this to be well defined,
  and indeed is trivial when a bottom element exists.) -/
def atBot [Preorder Œ±] : Filter Œ± :=
  ‚®Ö a, ùìü (Iic a)

theorem mem_atTop [Preorder Œ±] (a : Œ±) : { b : Œ± | a ‚â§ b } ‚àà @atTop Œ± _ :=
  mem_iInf_of_mem a <| Subset.refl _

theorem Ici_mem_atTop [Preorder Œ±] (a : Œ±) : Ici a ‚àà (atTop : Filter Œ±) :=
  mem_atTop a

theorem Ioi_mem_atTop [Preorder Œ±] [NoTopOrder Œ±] (x : Œ±) : Ioi x ‚àà (atTop : Filter Œ±) :=
  let ‚ü®z, hz‚ü© := exists_not_le x
  mem_of_superset (inter_mem (mem_atTop x) (mem_atTop z))
    fun _ ‚ü®hxy, hzy‚ü© => lt_of_le_not_ge hxy fun hyx => hz (hzy.trans hyx)

theorem mem_atBot [Preorder Œ±] (a : Œ±) : { b : Œ± | b ‚â§ a } ‚àà @atBot Œ± _ :=
  mem_iInf_of_mem a <| Subset.refl _

theorem Iic_mem_atBot [Preorder Œ±] (a : Œ±) : Iic a ‚àà (atBot : Filter Œ±) :=
  mem_atBot a

theorem Iio_mem_atBot [Preorder Œ±] [NoBotOrder Œ±] (x : Œ±) : Iio x ‚àà (atBot : Filter Œ±) :=
  let ‚ü®z, hz‚ü© := exists_not_ge x
  mem_of_superset (inter_mem (mem_atBot x) (mem_atBot z))
    fun _ ‚ü®hyx, hyz‚ü© => lt_of_le_not_ge hyx fun hxy => hz (hxy.trans hyz)

theorem eventually_ge_atTop [Preorder Œ±] (a : Œ±) : ‚àÄ·∂† x in atTop, a ‚â§ x :=
  mem_atTop a

theorem eventually_le_atBot [Preorder Œ±] (a : Œ±) : ‚àÄ·∂† x in atBot, x ‚â§ a :=
  mem_atBot a

theorem eventually_gt_atTop [Preorder Œ±] [NoTopOrder Œ±] (a : Œ±) : ‚àÄ·∂† x in atTop, a < x :=
  Ioi_mem_atTop a

theorem eventually_ne_atTop [Preorder Œ±] [NoTopOrder Œ±] (a : Œ±) : ‚àÄ·∂† x in atTop, x ‚â† a :=
  (eventually_gt_atTop a).mono fun _ => ne_of_gt

theorem eventually_lt_atBot [Preorder Œ±] [NoBotOrder Œ±] (a : Œ±) : ‚àÄ·∂† x in atBot, x < a :=
  Iio_mem_atBot a

theorem eventually_ne_atBot [Preorder Œ±] [NoBotOrder Œ±] (a : Œ±) : ‚àÄ·∂† x in atBot, x ‚â† a :=
  (eventually_lt_atBot a).mono fun _ => ne_of_lt

theorem _root_.IsTop.atTop_eq [Preorder Œ±] {a : Œ±} (ha : IsTop a) : atTop = ùìü (Ici a) :=
  (iInf_le _ _).antisymm <| le_iInf fun b ‚Ü¶ principal_mono.2 <| Ici_subset_Ici.2 <| ha b

theorem _root_.IsBot.atBot_eq [Preorder Œ±] {a : Œ±} (ha : IsBot a) : atBot = ùìü (Iic a) :=
  ha.toDual.atTop_eq

theorem atTop_eq_generate_Ici [Preorder Œ±] : atTop = generate (range (Ici (Œ± := Œ±))) := by
  simp only [generate_eq_biInf, atTop, iInf_range]

theorem Frequently.forall_exists_of_atTop [Preorder Œ±] {p : Œ± ‚Üí Prop}
    (h : ‚àÉ·∂† x in atTop, p x) (a : Œ±) : ‚àÉ b ‚â• a, p b := by
  rw [Filter.Frequently] at h
  contrapose! h
  exact (eventually_ge_atTop a).mono h

theorem Frequently.forall_exists_of_atBot [Preorder Œ±] {p : Œ± ‚Üí Prop}
    (h : ‚àÉ·∂† x in atBot, p x) (a : Œ±) : ‚àÉ b ‚â§ a, p b :=
  Frequently.forall_exists_of_atTop (Œ± := Œ±·µí·µà) h _

lemma atTop_eq_generate_of_forall_exists_le [Preorder Œ±] {s : Set Œ±} (hs : ‚àÄ x, ‚àÉ y ‚àà s, x ‚â§ y) :
    (atTop : Filter Œ±) = generate (Ici '' s) := by
  rw [atTop_eq_generate_Ici]
  apply le_antisymm
  ¬∑ rw [le_generate_iff]
    rintro - ‚ü®y, -, rfl‚ü©
    exact mem_generate_of_mem ‚ü®y, rfl‚ü©
  ¬∑ rw [le_generate_iff]
    rintro - ‚ü®x, -, -, rfl‚ü©
    rcases hs x with ‚ü®y, ys, hy‚ü©
    have A : Ici y ‚àà generate (Ici '' s) := mem_generate_of_mem (mem_image_of_mem _ ys)
    have B : Ici y ‚äÜ Ici x := Ici_subset_Ici.2 hy
    exact sets_of_superset (generate (Ici '' s)) A B

lemma atTop_eq_generate_of_not_bddAbove [LinearOrder Œ±] {s : Set Œ±} (hs : ¬¨ BddAbove s) :
    (atTop : Filter Œ±) = generate (Ici '' s) := by
  refine atTop_eq_generate_of_forall_exists_le fun x ‚Ü¶ ?_
  obtain ‚ü®y, hy, hy'‚ü© := not_bddAbove_iff.mp hs x
  exact ‚ü®y, hy, hy'.le‚ü©

end Filter

open Filter

theorem Monotone.piecewise_eventually_eq_iUnion {Œ≤ : Œ± ‚Üí Type*} [Preorder Œπ] {s : Œπ ‚Üí Set Œ±}
    [‚àÄ i, DecidablePred (¬∑ ‚àà s i)] [DecidablePred (¬∑ ‚àà ‚ãÉ i, s i)]
    (hs : Monotone s) (f g : (a : Œ±) ‚Üí Œ≤ a) (a : Œ±) :
    ‚àÄ·∂† i in atTop, (s i).piecewise f g a = (‚ãÉ i, s i).piecewise f g a := by
  rcases em (‚àÉ i, a ‚àà s i) with ‚ü®i, hi‚ü© | ha
  ¬∑ refine (eventually_ge_atTop i).mono fun j hij ‚Ü¶ ?_
    simp only [Set.piecewise_eq_of_mem, hs hij hi, subset_iUnion _ _ hi]
  ¬∑ filter_upwards with i
    simp only [Set.piecewise_eq_of_notMem, not_exists.1 ha i, mt mem_iUnion.1 ha,
      not_false_eq_true]

theorem Antitone.piecewise_eventually_eq_iInter {Œ≤ : Œ± ‚Üí Type*} [Preorder Œπ] {s : Œπ ‚Üí Set Œ±}
    [‚àÄ i, DecidablePred (¬∑ ‚àà s i)] [DecidablePred (¬∑ ‚àà ‚ãÇ i, s i)]
    (hs : Antitone s) (f g : (a : Œ±) ‚Üí Œ≤ a) (a : Œ±) :
    ‚àÄ·∂† i in atTop, (s i).piecewise f g a = (‚ãÇ i, s i).piecewise f g a := by
  classical
  convert ‚Üê (compl_anti.comp hs).piecewise_eventually_eq_iUnion g f a using 3
  ¬∑ convert congr_fun (Set.piecewise_compl (s _) g f) a
  ¬∑ simp only [(¬∑ ‚àò ¬∑), ‚Üê compl_iInter, Set.piecewise_compl]
