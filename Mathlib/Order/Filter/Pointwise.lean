/-
Copyright (c) 2019 Zhouhang Zhou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zhouhang Zhou, YaÃ«l Dillies
-/
import Mathlib.Algebra.Group.Action.Pointwise.Set.Basic
import Mathlib.Algebra.GroupWithZero.Action.Defs
import Mathlib.Algebra.GroupWithZero.Units.Basic
import Mathlib.Algebra.Order.Group.OrderIso
import Mathlib.Algebra.Order.Monoid.Defs
import Mathlib.Algebra.Ring.Defs
import Mathlib.Order.Filter.AtTopBot.Map
import Mathlib.Order.Filter.Finite
import Mathlib.Order.Filter.NAry
import Mathlib.Order.Filter.Ultrafilter.Defs

/-!
# Pointwise operations on filters

This file defines pointwise operations on filters. This is useful because usual algebraic operations
distribute over pointwise operations. For example,
* `(fâ‚ * fâ‚‚).map m = fâ‚.map m * fâ‚‚.map m`
* `ğ“ (x * y) = ğ“ x * ğ“ y`

## Main declarations

* `0` (`Filter.instZero`): Pure filter at `0 : Î±`, or alternatively principal filter at `0 : Set Î±`.
* `1` (`Filter.instOne`): Pure filter at `1 : Î±`, or alternatively principal filter at `1 : Set Î±`.
* `f + g` (`Filter.instAdd`): Addition, filter generated by all `s + t` where `s âˆˆ f` and `t âˆˆ g`.
* `f * g` (`Filter.instMul`): Multiplication, filter generated by all `s * t` where `s âˆˆ f` and
  `t âˆˆ g`.
* `-f` (`Filter.instNeg`): Negation, filter of all `-s` where `s âˆˆ f`.
* `fâ»Â¹` (`Filter.instInv`): Inversion, filter of all `sâ»Â¹` where `s âˆˆ f`.
* `f - g` (`Filter.instSub`): Subtraction, filter generated by all `s - t` where `s âˆˆ f` and
  `t âˆˆ g`.
* `f / g` (`Filter.instDiv`): Division, filter generated by all `s / t` where `s âˆˆ f` and `t âˆˆ g`.
* `f +áµ¥ g` (`Filter.instVAdd`): Scalar addition, filter generated by all `s +áµ¥ t` where `s âˆˆ f` and
  `t âˆˆ g`.
* `f -áµ¥ g` (`Filter.instVSub`): Scalar subtraction, filter generated by all `s -áµ¥ t` where `s âˆˆ f`
  and `t âˆˆ g`.
* `f â€¢ g` (`Filter.instSMul`): Scalar multiplication, filter generated by all `s â€¢ t` where
  `s âˆˆ f` and `t âˆˆ g`.
* `a +áµ¥ f` (`Filter.instVAddFilter`): Translation, filter of all `a +áµ¥ s` where `s âˆˆ f`.
* `a â€¢ f` (`Filter.instSMulFilter`): Scaling, filter of all `a â€¢ s` where `s âˆˆ f`.

For `Î±` a semigroup/monoid, `Filter Î±` is a semigroup/monoid.
As an unfortunate side effect, this means that `n â€¢ f`, where `n : â„•`, is ambiguous between
pointwise scaling and repeated pointwise addition. See note [pointwise nat action].

## Implementation notes

We put all instances in the locale `Pointwise`, so that these instances are not available by
default. Note that we do not mark them as reducible (as argued by note [reducible non-instances])
since we expect the locale to be open whenever the instances are actually used (and making the
instances reducible changes the behavior of `simp`).

## Tags

filter multiplication, filter addition, pointwise addition, pointwise multiplication,
-/


open Function Set Filter Pointwise

variable {F Î± Î² Î³ Î´ Îµ : Type*}

namespace Filter

/-! ### `0`/`1` as filters -/


section One

variable [One Î±] {f : Filter Î±} {s : Set Î±}

/-- `1 : Filter Î±` is defined as the filter of sets containing `1 : Î±` in locale `Pointwise`. -/
@[to_additive
/-- `0 : Filter Î±` is defined as the filter of sets containing `0 : Î±` in locale `Pointwise`. -/]
protected def instOne : One (Filter Î±) :=
  âŸ¨pure 1âŸ©

scoped[Pointwise] attribute [instance] Filter.instOne Filter.instZero

@[to_additive (attr := simp)]
theorem mem_one : s âˆˆ (1 : Filter Î±) â†” (1 : Î±) âˆˆ s :=
  mem_pure

@[to_additive]
theorem one_mem_one : (1 : Set Î±) âˆˆ (1 : Filter Î±) :=
  mem_pure.2 Set.one_mem_one

@[to_additive (attr := simp)]
theorem pure_one : pure 1 = (1 : Filter Î±) :=
  rfl

@[to_additive (attr := simp) zero_prod]
theorem one_prod {l : Filter Î²} : (1 : Filter Î±) Ã—Ë¢ l = map (1, Â·) l := pure_prod

@[to_additive (attr := simp) prod_zero]
theorem prod_one {l : Filter Î²} : l Ã—Ë¢ (1 : Filter Î±) = map (Â·, 1) l := prod_pure

@[to_additive (attr := simp)]
theorem principal_one : ğ“Ÿ 1 = (1 : Filter Î±) :=
  principal_singleton _

@[to_additive]
theorem one_neBot : (1 : Filter Î±).NeBot :=
  Filter.pure_neBot

scoped[Pointwise] attribute [instance] one_neBot zero_neBot

@[to_additive (attr := simp)]
protected theorem map_one' (f : Î± â†’ Î²) : (1 : Filter Î±).map f = pure (f 1) :=
  rfl

@[to_additive (attr := simp)]
theorem le_one_iff : f â‰¤ 1 â†” (1 : Set Î±) âˆˆ f :=
  le_pure_iff

@[to_additive]
protected theorem NeBot.le_one_iff (h : f.NeBot) : f â‰¤ 1 â†” f = 1 :=
  h.le_pure_iff

@[to_additive (attr := simp)]
theorem eventually_one {p : Î± â†’ Prop} : (âˆ€á¶  x in 1, p x) â†” p 1 :=
  eventually_pure

@[to_additive (attr := simp)]
theorem tendsto_one {a : Filter Î²} {f : Î² â†’ Î±} : Tendsto f a 1 â†” âˆ€á¶  x in a, f x = 1 :=
  tendsto_pure

@[to_additive zero_prod_zero]
theorem one_prod_one [One Î²] : (1 : Filter Î±) Ã—Ë¢ (1 : Filter Î²) = 1 :=
  prod_pure_pure

/-- `pure` as a `OneHom`. -/
@[to_additive /-- `pure` as a `ZeroHom`. -/]
def pureOneHom : OneHom Î± (Filter Î±) where
  toFun := pure; map_one' := pure_one

@[to_additive (attr := simp)]
theorem coe_pureOneHom : (pureOneHom : Î± â†’ Filter Î±) = pure :=
  rfl

@[to_additive (attr := simp)]
theorem pureOneHom_apply (a : Î±) : pureOneHom a = pure a :=
  rfl

variable [One Î²]

@[to_additive]
protected theorem map_one [FunLike F Î± Î²] [OneHomClass F Î± Î²] (Ï† : F) : map Ï† 1 = 1 := by
  simp

end One

/-! ### Filter negation/inversion -/


section Inv

variable [Inv Î±] {f g : Filter Î±} {s : Set Î±} {a : Î±}

/-- The inverse of a filter is the pointwise preimage under `â»Â¹` of its sets. -/
@[to_additive /-- The negation of a filter is the pointwise preimage under `-` of its sets. -/]
instance instInv : Inv (Filter Î±) :=
  âŸ¨map Inv.invâŸ©

@[to_additive (attr := simp)]
protected theorem map_inv : f.map Inv.inv = fâ»Â¹ :=
  rfl

@[to_additive]
theorem mem_inv : s âˆˆ fâ»Â¹ â†” Inv.inv â»Â¹' s âˆˆ f :=
  Iff.rfl

@[to_additive]
protected theorem inv_le_inv (hf : f â‰¤ g) : fâ»Â¹ â‰¤ gâ»Â¹ :=
  map_mono hf

@[to_additive (attr := simp)]
theorem inv_pure : (pure a : Filter Î±)â»Â¹ = pure aâ»Â¹ :=
  rfl

@[to_additive (attr := simp)]
theorem inv_eq_bot_iff : fâ»Â¹ = âŠ¥ â†” f = âŠ¥ :=
  map_eq_bot_iff

@[to_additive (attr := simp)]
theorem neBot_inv_iff : fâ»Â¹.NeBot â†” NeBot f :=
  map_neBot_iff _

@[to_additive]
protected theorem NeBot.inv : f.NeBot â†’ fâ»Â¹.NeBot := fun h â†¦ h.map _

@[to_additive neg.instNeBot]
lemma inv.instNeBot [NeBot f] : NeBot fâ»Â¹ := .inv â€¹_â€º

scoped[Pointwise] attribute [instance] inv.instNeBot neg.instNeBot

end Inv

section InvolutiveInv

variable [InvolutiveInv Î±] {f g : Filter Î±} {s : Set Î±}

@[to_additive (attr := simp)]
protected lemma comap_inv : comap Inv.inv f = fâ»Â¹ :=
  .symm <| map_eq_comap_of_inverse (inv_comp_inv _) (inv_comp_inv _)

@[to_additive]
theorem inv_mem_inv (hs : s âˆˆ f) : sâ»Â¹ âˆˆ fâ»Â¹ := by rwa [mem_inv, inv_preimage, inv_inv]

/-- Inversion is involutive on `Filter Î±` if it is on `Î±`. -/
@[to_additive /-- Negation is involutive on `Filter Î±` if it is on `Î±`. -/]
protected def instInvolutiveInv : InvolutiveInv (Filter Î±) :=
  { Filter.instInv with
    inv_inv := fun f â†¦ map_map.trans <| by rw [inv_involutive.comp_self, map_id] }

scoped[Pointwise] attribute [instance] Filter.instInvolutiveInv Filter.instInvolutiveNeg

@[to_additive (attr := simp)]
protected theorem inv_le_inv_iff : fâ»Â¹ â‰¤ gâ»Â¹ â†” f â‰¤ g :=
  âŸ¨fun h â†¦ inv_inv f â–¸ inv_inv g â–¸ Filter.inv_le_inv h, Filter.inv_le_invâŸ©

@[to_additive]
theorem inv_le_iff_le_inv : fâ»Â¹ â‰¤ g â†” f â‰¤ gâ»Â¹ := by rw [â† Filter.inv_le_inv_iff, inv_inv]

@[to_additive (attr := simp)]
theorem inv_le_self : fâ»Â¹ â‰¤ f â†” fâ»Â¹ = f :=
  âŸ¨fun h â†¦ h.antisymm <| inv_le_iff_le_inv.1 h, Eq.leâŸ©

end InvolutiveInv

@[to_additive (attr := simp)]
lemma inv_atTop {G : Type*} [CommGroup G] [PartialOrder G] [IsOrderedMonoid G] :
    (atTop : Filter G)â»Â¹ = atBot :=
  (OrderIso.inv G).map_atTop

/-! ### Filter addition/multiplication -/

section Mul

variable [Mul Î±] [Mul Î²] {f fâ‚ fâ‚‚ g gâ‚ gâ‚‚ h : Filter Î±} {s t : Set Î±} {a b : Î±}

/-- The filter `f * g` is generated by `{s * t | s âˆˆ f, t âˆˆ g}` in locale `Pointwise`. -/
@[to_additive
/-- The filter `f + g` is generated by `{s + t | s âˆˆ f, t âˆˆ g}` in locale `Pointwise`. -/]
protected def instMul : Mul (Filter Î±) :=
  âŸ¨/- This is defeq to `mapâ‚‚ (Â· * Â·) f g`, but the hypothesis unfolds to `tâ‚ * tâ‚‚ âŠ† s` rather
  than all the way to `Set.image2 (Â· * Â·) tâ‚ tâ‚‚ âŠ† s`. -/
  fun f g â†¦ { mapâ‚‚ (Â· * Â·) f g with sets := { s | âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, tâ‚ * tâ‚‚ âŠ† s } }âŸ©

scoped[Pointwise] attribute [instance] Filter.instMul Filter.instAdd

@[to_additive (attr := simp)]
theorem mapâ‚‚_mul : mapâ‚‚ (Â· * Â·) f g = f * g :=
  rfl

@[to_additive]
theorem mem_mul : s âˆˆ f * g â†” âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, tâ‚ * tâ‚‚ âŠ† s :=
  Iff.rfl

@[to_additive]
theorem mul_mem_mul : s âˆˆ f â†’ t âˆˆ g â†’ s * t âˆˆ f * g :=
  image2_mem_mapâ‚‚

@[to_additive (attr := simp)]
theorem bot_mul : âŠ¥ * g = âŠ¥ :=
  mapâ‚‚_bot_left

@[to_additive (attr := simp)]
theorem mul_bot : f * âŠ¥ = âŠ¥ :=
  mapâ‚‚_bot_right

@[to_additive (attr := simp)]
theorem mul_eq_bot_iff : f * g = âŠ¥ â†” f = âŠ¥ âˆ¨ g = âŠ¥ :=
  mapâ‚‚_eq_bot_iff

@[to_additive (attr := simp)] -- TODO: make this a scoped instance in the `Pointwise` namespace
lemma mul_neBot_iff : (f * g).NeBot â†” f.NeBot âˆ§ g.NeBot :=
  mapâ‚‚_neBot_iff

@[to_additive]
protected theorem NeBot.mul : NeBot f â†’ NeBot g â†’ NeBot (f * g) :=
  NeBot.mapâ‚‚

@[to_additive]
theorem NeBot.of_mul_left : (f * g).NeBot â†’ f.NeBot :=
  NeBot.of_mapâ‚‚_left

@[to_additive]
theorem NeBot.of_mul_right : (f * g).NeBot â†’ g.NeBot :=
  NeBot.of_mapâ‚‚_right

@[to_additive add.instNeBot]
protected lemma mul.instNeBot [NeBot f] [NeBot g] : NeBot (f * g) := .mul â€¹_â€º â€¹_â€º

scoped[Pointwise] attribute [instance] mul.instNeBot add.instNeBot

@[to_additive (attr := simp)]
theorem pure_mul : pure a * g = g.map (a * Â·) :=
  mapâ‚‚_pure_left

@[to_additive (attr := simp)]
theorem mul_pure : f * pure b = f.map (Â· * b) :=
  mapâ‚‚_pure_right

@[to_additive]
theorem pure_mul_pure : (pure a : Filter Î±) * pure b = pure (a * b) := by simp

@[to_additive (attr := simp)]
theorem le_mul_iff : h â‰¤ f * g â†” âˆ€ â¦ƒsâ¦„, s âˆˆ f â†’ âˆ€ â¦ƒtâ¦„, t âˆˆ g â†’ s * t âˆˆ h :=
  le_mapâ‚‚_iff

@[to_additive]
instance mulLeftMono : MulLeftMono (Filter Î±) :=
  âŸ¨fun _ _ _ â†¦ mapâ‚‚_mono_leftâŸ©

@[to_additive]
instance mulRightMono : MulRightMono (Filter Î±) :=
  âŸ¨fun _ _ _ â†¦ mapâ‚‚_mono_rightâŸ©

@[to_additive]
protected theorem map_mul [FunLike F Î± Î²] [MulHomClass F Î± Î²] (m : F) :
    (fâ‚ * fâ‚‚).map m = fâ‚.map m * fâ‚‚.map m :=
  map_mapâ‚‚_distrib <| map_mul m

/-- `pure` operation as a `MulHom`. -/
@[to_additive /-- The singleton operation as an `AddHom`. -/]
def pureMulHom : Î± â†’â‚™* Filter Î± where
  toFun := pure; map_mul' _ _ := pure_mul_pure.symm

@[to_additive (attr := simp)]
theorem coe_pureMulHom : (pureMulHom : Î± â†’ Filter Î±) = pure :=
  rfl

@[to_additive (attr := simp)]
theorem pureMulHom_apply (a : Î±) : pureMulHom a = pure a :=
  rfl

end Mul

/-! ### Filter subtraction/division -/

section Div

variable [Div Î±] {f fâ‚ fâ‚‚ g gâ‚ gâ‚‚ h : Filter Î±} {s t : Set Î±} {a b : Î±}

/-- The filter `f / g` is generated by `{s / t | s âˆˆ f, t âˆˆ g}` in locale `Pointwise`. -/
@[to_additive
/-- The filter `f - g` is generated by `{s - t | s âˆˆ f, t âˆˆ g}` in locale `Pointwise`. -/]
protected def instDiv : Div (Filter Î±) :=
  âŸ¨/- This is defeq to `mapâ‚‚ (Â· / Â·) f g`, but the hypothesis unfolds to `tâ‚ / tâ‚‚ âŠ† s`
  rather than all the way to `Set.image2 (Â· / Â·) tâ‚ tâ‚‚ âŠ† s`. -/
  fun f g â†¦ { mapâ‚‚ (Â· / Â·) f g with sets := { s | âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, tâ‚ / tâ‚‚ âŠ† s } }âŸ©

scoped[Pointwise] attribute [instance] Filter.instDiv Filter.instSub

@[to_additive (attr := simp)]
theorem mapâ‚‚_div : mapâ‚‚ (Â· / Â·) f g = f / g :=
  rfl

@[to_additive]
theorem mem_div : s âˆˆ f / g â†” âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, tâ‚ / tâ‚‚ âŠ† s :=
  Iff.rfl

@[to_additive]
theorem div_mem_div : s âˆˆ f â†’ t âˆˆ g â†’ s / t âˆˆ f / g :=
  image2_mem_mapâ‚‚

@[to_additive (attr := simp)]
theorem bot_div : âŠ¥ / g = âŠ¥ :=
  mapâ‚‚_bot_left

@[to_additive (attr := simp)]
theorem div_bot : f / âŠ¥ = âŠ¥ :=
  mapâ‚‚_bot_right

@[to_additive (attr := simp)]
theorem div_eq_bot_iff : f / g = âŠ¥ â†” f = âŠ¥ âˆ¨ g = âŠ¥ :=
  mapâ‚‚_eq_bot_iff

@[to_additive (attr := simp)]
theorem div_neBot_iff : (f / g).NeBot â†” f.NeBot âˆ§ g.NeBot :=
  mapâ‚‚_neBot_iff

@[to_additive]
protected theorem NeBot.div : NeBot f â†’ NeBot g â†’ NeBot (f / g) :=
  NeBot.mapâ‚‚

@[to_additive]
theorem NeBot.of_div_left : (f / g).NeBot â†’ f.NeBot :=
  NeBot.of_mapâ‚‚_left

@[to_additive]
theorem NeBot.of_div_right : (f / g).NeBot â†’ g.NeBot :=
  NeBot.of_mapâ‚‚_right

@[to_additive sub.instNeBot]
lemma div.instNeBot [NeBot f] [NeBot g] : NeBot (f / g) := .div â€¹_â€º â€¹_â€º

scoped[Pointwise] attribute [instance] div.instNeBot sub.instNeBot

@[to_additive (attr := simp)]
theorem pure_div : pure a / g = g.map (a / Â·) :=
  mapâ‚‚_pure_left

@[to_additive (attr := simp)]
theorem div_pure : f / pure b = f.map (Â· / b) :=
  mapâ‚‚_pure_right

@[to_additive]
theorem pure_div_pure : (pure a : Filter Î±) / pure b = pure (a / b) := by simp

@[to_additive]
protected theorem div_le_div : fâ‚ â‰¤ fâ‚‚ â†’ gâ‚ â‰¤ gâ‚‚ â†’ fâ‚ / gâ‚ â‰¤ fâ‚‚ / gâ‚‚ :=
  mapâ‚‚_mono

@[to_additive]
protected theorem div_le_div_left : gâ‚ â‰¤ gâ‚‚ â†’ f / gâ‚ â‰¤ f / gâ‚‚ :=
  mapâ‚‚_mono_left

@[to_additive]
protected theorem div_le_div_right : fâ‚ â‰¤ fâ‚‚ â†’ fâ‚ / g â‰¤ fâ‚‚ / g :=
  mapâ‚‚_mono_right

@[to_additive (attr := simp)]
protected theorem le_div_iff : h â‰¤ f / g â†” âˆ€ â¦ƒsâ¦„, s âˆˆ f â†’ âˆ€ â¦ƒtâ¦„, t âˆˆ g â†’ s / t âˆˆ h :=
  le_mapâ‚‚_iff

@[to_additive]
instance covariant_div : CovariantClass (Filter Î±) (Filter Î±) (Â· / Â·) (Â· â‰¤ Â·) :=
  âŸ¨fun _ _ _ â†¦ mapâ‚‚_mono_leftâŸ©

@[to_additive]
instance covariant_swap_div : CovariantClass (Filter Î±) (Filter Î±) (swap (Â· / Â·)) (Â· â‰¤ Â·) :=
  âŸ¨fun _ _ _ â†¦ mapâ‚‚_mono_rightâŸ©

end Div

/-- Repeated pointwise addition (not the same as pointwise repeated addition!) of a `Filter`. See
Note [pointwise nat action]. -/
protected def instNSMul [Zero Î±] [Add Î±] : SMul â„• (Filter Î±) :=
  âŸ¨nsmulRecâŸ©

/-- Repeated pointwise multiplication (not the same as pointwise repeated multiplication!) of a
`Filter`. See Note [pointwise nat action]. -/
@[to_additive existing]
protected def instNPow [One Î±] [Mul Î±] : Pow (Filter Î±) â„• :=
  âŸ¨fun s n â†¦ npowRec n sâŸ©

/-- Repeated pointwise addition/subtraction (not the same as pointwise repeated
addition/subtraction!) of a `Filter`. See Note [pointwise nat action]. -/
protected def instZSMul [Zero Î±] [Add Î±] [Neg Î±] : SMul â„¤ (Filter Î±) :=
  âŸ¨zsmulRecâŸ©

/-- Repeated pointwise multiplication/division (not the same as pointwise repeated
multiplication/division!) of a `Filter`. See Note [pointwise nat action]. -/
@[to_additive existing]
protected def instZPow [One Î±] [Mul Î±] [Inv Î±] : Pow (Filter Î±) â„¤ :=
  âŸ¨fun s n â†¦ zpowRec npowRec n sâŸ©

scoped[Pointwise] attribute [instance] Filter.instNSMul Filter.instNPow
  Filter.instZSMul Filter.instZPow

/-- `Filter Î±` is a `Semigroup` under pointwise operations if `Î±` is. -/
@[to_additive /-- `Filter Î±` is an `AddSemigroup` under pointwise operations if `Î±` is. -/]
protected def semigroup [Semigroup Î±] : Semigroup (Filter Î±) where
  mul := (Â· * Â·)
  mul_assoc _ _ _ := mapâ‚‚_assoc mul_assoc

/-- `Filter Î±` is a `CommSemigroup` under pointwise operations if `Î±` is. -/
@[to_additive /-- `Filter Î±` is an `AddCommSemigroup` under pointwise operations if `Î±` is. -/]
protected def commSemigroup [CommSemigroup Î±] : CommSemigroup (Filter Î±) :=
  { Filter.semigroup with mul_comm := fun _ _ â†¦ mapâ‚‚_comm mul_comm }

section MulOneClass

variable [MulOneClass Î±] [MulOneClass Î²]

/-- `Filter Î±` is a `MulOneClass` under pointwise operations if `Î±` is. -/
@[to_additive /-- `Filter Î±` is an `AddZeroClass` under pointwise operations if `Î±` is. -/]
protected def mulOneClass : MulOneClass (Filter Î±) where
  one := 1
  mul := (Â· * Â·)
  one_mul := mapâ‚‚_left_identity one_mul
  mul_one := mapâ‚‚_right_identity mul_one

scoped[Pointwise] attribute [instance] Filter.semigroup Filter.addSemigroup
  Filter.commSemigroup Filter.addCommSemigroup Filter.mulOneClass Filter.addZeroClass

variable [FunLike F Î± Î²]

/-- If `Ï† : Î± â†’* Î²` then `mapMonoidHom Ï†` is the monoid homomorphism
`Filter Î± â†’* Filter Î²` induced by `map Ï†`. -/
@[to_additive /-- If `Ï† : Î± â†’+ Î²` then `mapAddMonoidHom Ï†` is the monoid homomorphism
`Filter Î± â†’+ Filter Î²` induced by `map Ï†`. -/]
def mapMonoidHom [MonoidHomClass F Î± Î²] (Ï† : F) : Filter Î± â†’* Filter Î² where
  toFun := map Ï†
  map_one' := Filter.map_one Ï†
  map_mul' _ _ := Filter.map_mul Ï†

-- The other direction does not hold in general
@[to_additive]
theorem comap_mul_comap_le [MulHomClass F Î± Î²] (m : F) {f g : Filter Î²} :
    f.comap m * g.comap m â‰¤ (f * g).comap m := fun _ âŸ¨_, âŸ¨tâ‚, htâ‚, tâ‚‚, htâ‚‚, tâ‚tâ‚‚âŸ©, mtâŸ© â†¦
  âŸ¨m â»Â¹' tâ‚, âŸ¨tâ‚, htâ‚, Subset.rflâŸ©, m â»Â¹' tâ‚‚, âŸ¨tâ‚‚, htâ‚‚, Subset.rflâŸ©,
    (preimage_mul_preimage_subset _).trans <| (preimage_mono tâ‚tâ‚‚).trans mtâŸ©

@[to_additive]
theorem Tendsto.mul_mul [MulHomClass F Î± Î²] (m : F) {fâ‚ gâ‚ : Filter Î±} {fâ‚‚ gâ‚‚ : Filter Î²} :
    Tendsto m fâ‚ fâ‚‚ â†’ Tendsto m gâ‚ gâ‚‚ â†’ Tendsto m (fâ‚ * gâ‚) (fâ‚‚ * gâ‚‚) := fun hf hg â†¦
  (Filter.map_mul m).trans_le <| mul_le_mul' hf hg

/-- `pure` as a `MonoidHom`. -/
@[to_additive /-- `pure` as an `AddMonoidHom`. -/]
def pureMonoidHom : Î± â†’* Filter Î± :=
  { pureMulHom, pureOneHom with }

@[to_additive (attr := simp)]
theorem coe_pureMonoidHom : (pureMonoidHom : Î± â†’ Filter Î±) = pure :=
  rfl

@[to_additive (attr := simp)]
theorem pureMonoidHom_apply (a : Î±) : pureMonoidHom a = pure a :=
  rfl

end MulOneClass

section Monoid

variable [Monoid Î±] {f g : Filter Î±} {s : Set Î±} {a : Î±} {m n : â„•}

/-- `Filter Î±` is a `Monoid` under pointwise operations if `Î±` is. -/
@[to_additive /-- `Filter Î±` is an `AddMonoid` under pointwise operations if `Î±` is. -/]
protected def monoid : Monoid (Filter Î±) :=
  { Filter.mulOneClass, Filter.semigroup, @Filter.instNPow Î± _ _ with }

scoped[Pointwise] attribute [instance] Filter.monoid Filter.addMonoid

@[to_additive]
theorem pow_mem_pow (hs : s âˆˆ f) : âˆ€ n : â„•, s ^ n âˆˆ f ^ n
  | 0 => by
    rw [pow_zero]
    exact one_mem_one
  | n + 1 => by
    rw [pow_succ]
    exact mul_mem_mul (pow_mem_pow hs n) hs

@[to_additive (attr := simp) nsmul_bot]
theorem bot_pow {n : â„•} (hn : n â‰  0) : (âŠ¥ : Filter Î±) ^ n = âŠ¥ := by
  rw [â† Nat.sub_one_add_one hn, pow_succ', bot_mul]

@[to_additive]
theorem mul_top_of_one_le (hf : 1 â‰¤ f) : f * âŠ¤ = âŠ¤ := by
  refine top_le_iff.1 fun s â†¦ ?_
  simp only [mem_mul, mem_top, exists_eq_left]
  rintro âŸ¨t, ht, hsâŸ©
  rwa [mul_univ_of_one_mem (mem_one.1 <| hf ht), univ_subset_iff] at hs

@[to_additive]
theorem top_mul_of_one_le (hf : 1 â‰¤ f) : âŠ¤ * f = âŠ¤ := by
  refine top_le_iff.1 fun s â†¦ ?_
  simp only [mem_mul, mem_top, exists_eq_left]
  rintro âŸ¨t, ht, hsâŸ©
  rwa [univ_mul_of_one_mem (mem_one.1 <| hf ht), univ_subset_iff] at hs

@[to_additive (attr := simp)]
theorem top_mul_top : (âŠ¤ : Filter Î±) * âŠ¤ = âŠ¤ :=
  mul_top_of_one_le le_top

@[to_additive nsmul_top]
theorem top_pow : âˆ€ {n : â„•}, n â‰  0 â†’ (âŠ¤ : Filter Î±) ^ n = âŠ¤
  | 0 => fun h â†¦ (h rfl).elim
  | 1 => fun _ â†¦ pow_one _
  | n + 2 => fun _ â†¦ by rw [pow_succ, top_pow n.succ_ne_zero, top_mul_top]

@[to_additive]
protected theorem _root_.IsUnit.filter : IsUnit a â†’ IsUnit (pure a : Filter Î±) :=
  IsUnit.map (pureMonoidHom : Î± â†’* Filter Î±)

end Monoid

/-- `Filter Î±` is a `CommMonoid` under pointwise operations if `Î±` is. -/
@[to_additive /-- `Filter Î±` is an `AddCommMonoid` under pointwise operations if `Î±` is. -/]
protected def commMonoid [CommMonoid Î±] : CommMonoid (Filter Î±) :=
  { Filter.mulOneClass, Filter.commSemigroup with }

section DivisionMonoid

variable [DivisionMonoid Î±] {f g : Filter Î±}

@[to_additive]
protected theorem mul_eq_one_iff : f * g = 1 â†” âˆƒ a b, f = pure a âˆ§ g = pure b âˆ§ a * b = 1 := by
  refine âŸ¨fun hfg â†¦ ?_, ?_âŸ©
  Â· obtain âŸ¨tâ‚, hâ‚, tâ‚‚, hâ‚‚, hâŸ© : (1 : Set Î±) âˆˆ f * g := hfg.symm â–¸ one_mem_one
    have hfg : (f * g).NeBot := hfg.symm.subst one_neBot
    rw [(hfg.nonempty_of_mem <| mul_mem_mul hâ‚ hâ‚‚).subset_one_iff, Set.mul_eq_one_iff] at h
    obtain âŸ¨a, b, rfl, rfl, hâŸ© := h
    refine âŸ¨a, b, ?_, ?_, hâŸ©
    Â· rwa [â† hfg.of_mul_left.le_pure_iff, le_pure_iff]
    Â· rwa [â† hfg.of_mul_right.le_pure_iff, le_pure_iff]
  Â· rintro âŸ¨a, b, rfl, rfl, hâŸ©
    rw [pure_mul_pure, h, pure_one]

/-- `Filter Î±` is a division monoid under pointwise operations if `Î±` is. -/
@[to_additive /-- `Filter Î±` is a subtraction monoid under pointwise operations if `Î±` is. -/]
protected def divisionMonoid : DivisionMonoid (Filter Î±) :=
  { Filter.monoid, Filter.instInvolutiveInv, Filter.instDiv, Filter.instZPow (Î± := Î±) with
    mul_inv_rev := fun _ _ â†¦ map_mapâ‚‚_antidistrib mul_inv_rev
    inv_eq_of_mul := fun s t h â†¦ by
      obtain âŸ¨a, b, rfl, rfl, habâŸ© := Filter.mul_eq_one_iff.1 h
      rw [inv_pure, inv_eq_of_mul_eq_one_right hab]
    div_eq_mul_inv := fun _ _ â†¦ map_mapâ‚‚_distrib_right div_eq_mul_inv }

@[to_additive]
theorem isUnit_iff : IsUnit f â†” âˆƒ a, f = pure a âˆ§ IsUnit a := by
  constructor
  Â· rintro âŸ¨u, rflâŸ©
    obtain âŸ¨a, b, ha, hb, hâŸ© := Filter.mul_eq_one_iff.1 u.mul_inv
    refine âŸ¨a, ha, âŸ¨a, b, h, pure_injective ?_âŸ©, rflâŸ©
    rw [â† pure_mul_pure, â† ha, â† hb]
    exact u.inv_mul
  Â· rintro âŸ¨a, rfl, haâŸ©
    exact ha.filter

end DivisionMonoid

/-- `Filter Î±` is a commutative division monoid under pointwise operations if `Î±` is. -/
@[to_additive subtractionCommMonoid
/-- `Filter Î±` is a commutative subtraction monoid under pointwise operations if `Î±` is. -/]
protected def divisionCommMonoid [DivisionCommMonoid Î±] : DivisionCommMonoid (Filter Î±) :=
  { Filter.divisionMonoid, Filter.commSemigroup with }

/-- `Filter Î±` has distributive negation if `Î±` has. -/
protected def instDistribNeg [Mul Î±] [HasDistribNeg Î±] : HasDistribNeg (Filter Î±) :=
  { Filter.instInvolutiveNeg with
    neg_mul := fun _ _ â†¦ mapâ‚‚_map_left_comm neg_mul
    mul_neg := fun _ _ â†¦ map_mapâ‚‚_right_comm mul_neg }

scoped[Pointwise] attribute [instance] Filter.commMonoid Filter.addCommMonoid Filter.divisionMonoid
  Filter.subtractionMonoid Filter.divisionCommMonoid Filter.subtractionCommMonoid
  Filter.instDistribNeg

section Distrib

variable [Distrib Î±] {f g h : Filter Î±}

/-!
Note that `Filter Î±` is not a `Distrib` because `f * g + f * h` has cross terms that `f * (g + h)`
lacks.
-/

theorem mul_add_subset : f * (g + h) â‰¤ f * g + f * h :=
  mapâ‚‚_distrib_le_left mul_add

theorem add_mul_subset : (f + g) * h â‰¤ f * h + g * h :=
  mapâ‚‚_distrib_le_right add_mul

end Distrib

section MulZeroClass

variable [MulZeroClass Î±] {f g : Filter Î±}

/-! Note that `Filter` is not a `MulZeroClass` because `0 * âŠ¥ â‰  0`. -/

theorem NeBot.mul_zero_nonneg (hf : f.NeBot) : 0 â‰¤ f * 0 :=
  le_mul_iff.2 fun _ hâ‚ _ hâ‚‚ â†¦
    let âŸ¨_, haâŸ© := hf.nonempty_of_mem hâ‚
    âŸ¨_, ha, _, hâ‚‚, mul_zero _âŸ©

theorem NeBot.zero_mul_nonneg (hg : g.NeBot) : 0 â‰¤ 0 * g :=
  le_mul_iff.2 fun _ hâ‚ _ hâ‚‚ â†¦
    let âŸ¨_, hbâŸ© := hg.nonempty_of_mem hâ‚‚
    âŸ¨_, hâ‚, _, hb, zero_mul _âŸ©

end MulZeroClass

section Group

variable [Group Î±] [DivisionMonoid Î²] [FunLike F Î± Î²] [MonoidHomClass F Î± Î²]
  (m : F) {f g fâ‚ gâ‚ : Filter Î±} {fâ‚‚ gâ‚‚ : Filter Î²}

/-! Note that `Filter Î±` is not a group because `f / f â‰  1` in general -/

-- Porting note: increase priority to appease `simpNF` so left-hand side doesn't simplify
@[to_additive (attr := simp 1100)]
protected theorem one_le_div_iff : 1 â‰¤ f / g â†” Â¬Disjoint f g := by
  refine âŸ¨fun h hfg â†¦ ?_, ?_âŸ©
  Â· obtain âŸ¨s, hs, t, ht, hstâŸ© := hfg.le_bot (mem_bot : âˆ… âˆˆ âŠ¥)
    exact Set.one_mem_div_iff.1 (h <| div_mem_div hs ht) (disjoint_iff.2 hst.symm)
  Â· rintro h s âŸ¨tâ‚, hâ‚, tâ‚‚, hâ‚‚, hsâŸ©
    exact hs (Set.one_mem_div_iff.2 fun ht â†¦ h <| disjoint_of_disjoint_of_mem ht hâ‚ hâ‚‚)

@[to_additive]
theorem not_one_le_div_iff : Â¬1 â‰¤ f / g â†” Disjoint f g :=
  Filter.one_le_div_iff.not_left

@[to_additive]
theorem NeBot.one_le_div (h : f.NeBot) : 1 â‰¤ f / f := by
  rintro s âŸ¨tâ‚, hâ‚, tâ‚‚, hâ‚‚, hsâŸ©
  obtain âŸ¨a, haâ‚, haâ‚‚âŸ© := Set.not_disjoint_iff.1 (h.not_disjoint hâ‚ hâ‚‚)
  rw [mem_one, â† div_self' a]
  exact hs (Set.div_mem_div haâ‚ haâ‚‚)

@[to_additive]
theorem isUnit_pure (a : Î±) : IsUnit (pure a : Filter Î±) :=
  (Group.isUnit a).filter

@[simp]
theorem isUnit_iff_singleton : IsUnit f â†” âˆƒ a, f = pure a := by
  simp only [isUnit_iff, Group.isUnit, and_true]

@[to_additive]
theorem map_inv' : fâ»Â¹.map m = (f.map m)â»Â¹ :=
  Semiconj.filter_map (map_inv m) f

@[to_additive]
protected theorem Tendsto.inv_inv : Tendsto m fâ‚ fâ‚‚ â†’ Tendsto m fâ‚â»Â¹ fâ‚‚â»Â¹ := fun hf â†¦
  (Filter.map_inv' m).trans_le <| Filter.inv_le_inv hf

@[to_additive]
protected theorem map_div : (f / g).map m = f.map m / g.map m :=
  map_mapâ‚‚_distrib <| map_div m

@[to_additive]
protected theorem Tendsto.div_div (hf : Tendsto m fâ‚ fâ‚‚) (hg : Tendsto m gâ‚ gâ‚‚) :
    Tendsto m (fâ‚ / gâ‚) (fâ‚‚ / gâ‚‚) :=
  (Filter.map_div m).trans_le <| Filter.div_le_div hf hg

end Group

section GroupWithZero

variable [GroupWithZero Î±] {f g : Filter Î±}

theorem NeBot.div_zero_nonneg (hf : f.NeBot) : 0 â‰¤ f / 0 :=
  Filter.le_div_iff.2 fun _ hâ‚ _ hâ‚‚ â†¦
    let âŸ¨_, haâŸ© := hf.nonempty_of_mem hâ‚
    âŸ¨_, ha, _, hâ‚‚, div_zero _âŸ©

theorem NeBot.zero_div_nonneg (hg : g.NeBot) : 0 â‰¤ 0 / g :=
  Filter.le_div_iff.2 fun _ hâ‚ _ hâ‚‚ â†¦
    let âŸ¨_, hbâŸ© := hg.nonempty_of_mem hâ‚‚
    âŸ¨_, hâ‚, _, hb, zero_div _âŸ©

end GroupWithZero

/-! ### Scalar addition/multiplication of filters -/


section SMul

variable [SMul Î± Î²] {f fâ‚ fâ‚‚ : Filter Î±} {g gâ‚ gâ‚‚ h : Filter Î²} {s : Set Î±} {t : Set Î²} {a : Î±}
  {b : Î²}

/-- The filter `f â€¢ g` is generated by `{s â€¢ t | s âˆˆ f, t âˆˆ g}` in locale `Pointwise`. -/
@[to_additive /-- The filter `f +áµ¥ g` is generated by `{s +áµ¥ t | s âˆˆ f, t âˆˆ g}` in locale
`Pointwise`. -/]
protected def instSMul : SMul (Filter Î±) (Filter Î²) :=
  âŸ¨/- This is defeq to `mapâ‚‚ (Â· â€¢ Â·) f g`, but the hypothesis unfolds to `tâ‚ â€¢ tâ‚‚ âŠ† s`
  rather than all the way to `Set.image2 (Â· â€¢ Â·) tâ‚ tâ‚‚ âŠ† s`. -/
  fun f g â†¦ { mapâ‚‚ (Â· â€¢ Â·) f g with sets := { s | âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, tâ‚ â€¢ tâ‚‚ âŠ† s } }âŸ©

scoped[Pointwise] attribute [instance] Filter.instSMul Filter.instVAdd

@[to_additive (attr := simp)]
theorem mapâ‚‚_smul : mapâ‚‚ (Â· â€¢ Â·) f g = f â€¢ g :=
  rfl

@[to_additive]
theorem mem_smul : t âˆˆ f â€¢ g â†” âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, tâ‚ â€¢ tâ‚‚ âŠ† t :=
  Iff.rfl

@[to_additive]
theorem smul_mem_smul : s âˆˆ f â†’ t âˆˆ g â†’ s â€¢ t âˆˆ f â€¢ g :=
  image2_mem_mapâ‚‚

@[to_additive (attr := simp)]
theorem bot_smul : (âŠ¥ : Filter Î±) â€¢ g = âŠ¥ :=
  mapâ‚‚_bot_left

@[to_additive (attr := simp)]
theorem smul_bot : f â€¢ (âŠ¥ : Filter Î²) = âŠ¥ :=
  mapâ‚‚_bot_right

@[to_additive (attr := simp)]
theorem smul_eq_bot_iff : f â€¢ g = âŠ¥ â†” f = âŠ¥ âˆ¨ g = âŠ¥ :=
  mapâ‚‚_eq_bot_iff

@[to_additive (attr := simp)]
theorem smul_neBot_iff : (f â€¢ g).NeBot â†” f.NeBot âˆ§ g.NeBot :=
  mapâ‚‚_neBot_iff

@[to_additive]
protected theorem NeBot.smul : NeBot f â†’ NeBot g â†’ NeBot (f â€¢ g) :=
  NeBot.mapâ‚‚

@[to_additive]
theorem NeBot.of_smul_left : (f â€¢ g).NeBot â†’ f.NeBot :=
  NeBot.of_mapâ‚‚_left

@[to_additive]
theorem NeBot.of_smul_right : (f â€¢ g).NeBot â†’ g.NeBot :=
  NeBot.of_mapâ‚‚_right

@[to_additive vadd.instNeBot]
lemma smul.instNeBot [NeBot f] [NeBot g] : NeBot (f â€¢ g) := .smul â€¹_â€º â€¹_â€º

scoped[Pointwise] attribute [instance] smul.instNeBot vadd.instNeBot

@[to_additive (attr := simp)]
theorem pure_smul : (pure a : Filter Î±) â€¢ g = g.map (a â€¢ Â·) :=
  mapâ‚‚_pure_left

@[to_additive (attr := simp)]
theorem smul_pure : f â€¢ pure b = f.map (Â· â€¢ b) :=
  mapâ‚‚_pure_right

@[to_additive]
theorem pure_smul_pure : (pure a : Filter Î±) â€¢ (pure b : Filter Î²) = pure (a â€¢ b) := by simp

@[to_additive]
theorem smul_le_smul : fâ‚ â‰¤ fâ‚‚ â†’ gâ‚ â‰¤ gâ‚‚ â†’ fâ‚ â€¢ gâ‚ â‰¤ fâ‚‚ â€¢ gâ‚‚ :=
  mapâ‚‚_mono

@[to_additive]
theorem smul_le_smul_left : gâ‚ â‰¤ gâ‚‚ â†’ f â€¢ gâ‚ â‰¤ f â€¢ gâ‚‚ :=
  mapâ‚‚_mono_left

@[to_additive]
theorem smul_le_smul_right : fâ‚ â‰¤ fâ‚‚ â†’ fâ‚ â€¢ g â‰¤ fâ‚‚ â€¢ g :=
  mapâ‚‚_mono_right

@[to_additive (attr := simp)]
theorem le_smul_iff : h â‰¤ f â€¢ g â†” âˆ€ â¦ƒsâ¦„, s âˆˆ f â†’ âˆ€ â¦ƒtâ¦„, t âˆˆ g â†’ s â€¢ t âˆˆ h :=
  le_mapâ‚‚_iff

@[to_additive]
instance covariant_smul : CovariantClass (Filter Î±) (Filter Î²) (Â· â€¢ Â·) (Â· â‰¤ Â·) :=
  âŸ¨fun _ _ _ â†¦ mapâ‚‚_mono_leftâŸ©

end SMul

/-! ### Scalar subtraction of filters -/


section Vsub

variable [VSub Î± Î²] {f fâ‚ fâ‚‚ g gâ‚ gâ‚‚ : Filter Î²} {h : Filter Î±} {s t : Set Î²} {a b : Î²}

/-- The filter `f -áµ¥ g` is generated by `{s -áµ¥ t | s âˆˆ f, t âˆˆ g}` in locale `Pointwise`. -/
protected def instVSub : VSub (Filter Î±) (Filter Î²) :=
  âŸ¨/- This is defeq to `mapâ‚‚ (-áµ¥) f g`, but the hypothesis unfolds to `tâ‚ -áµ¥ tâ‚‚ âŠ† s` rather than all
  the way to `Set.image2 (-áµ¥) tâ‚ tâ‚‚ âŠ† s`. -/
  fun f g â†¦ { mapâ‚‚ (Â· -áµ¥ Â·) f g with sets := { s | âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, tâ‚ -áµ¥ tâ‚‚ âŠ† s } }âŸ©

scoped[Pointwise] attribute [instance] Filter.instVSub

@[simp]
theorem mapâ‚‚_vsub : mapâ‚‚ (Â· -áµ¥ Â·) f g = f -áµ¥ g :=
  rfl

theorem mem_vsub {s : Set Î±} : s âˆˆ f -áµ¥ g â†” âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, tâ‚ -áµ¥ tâ‚‚ âŠ† s :=
  Iff.rfl

theorem vsub_mem_vsub : s âˆˆ f â†’ t âˆˆ g â†’ s -áµ¥ t âˆˆ f -áµ¥ g :=
  image2_mem_mapâ‚‚

@[simp]
theorem bot_vsub : (âŠ¥ : Filter Î²) -áµ¥ g = âŠ¥ :=
  mapâ‚‚_bot_left

@[simp]
theorem vsub_bot : f -áµ¥ (âŠ¥ : Filter Î²) = âŠ¥ :=
  mapâ‚‚_bot_right

@[simp]
theorem vsub_eq_bot_iff : f -áµ¥ g = âŠ¥ â†” f = âŠ¥ âˆ¨ g = âŠ¥ :=
  mapâ‚‚_eq_bot_iff

@[simp]
theorem vsub_neBot_iff : (f -áµ¥ g : Filter Î±).NeBot â†” f.NeBot âˆ§ g.NeBot :=
  mapâ‚‚_neBot_iff

protected theorem NeBot.vsub : NeBot f â†’ NeBot g â†’ NeBot (f -áµ¥ g) :=
  NeBot.mapâ‚‚

theorem NeBot.of_vsub_left : (f -áµ¥ g : Filter Î±).NeBot â†’ f.NeBot :=
  NeBot.of_mapâ‚‚_left

theorem NeBot.of_vsub_right : (f -áµ¥ g : Filter Î±).NeBot â†’ g.NeBot :=
  NeBot.of_mapâ‚‚_right

lemma vsub.instNeBot [NeBot f] [NeBot g] : NeBot (f -áµ¥ g) := .vsub â€¹_â€º â€¹_â€º

scoped[Pointwise] attribute [instance] vsub.instNeBot

@[simp]
theorem pure_vsub : (pure a : Filter Î²) -áµ¥ g = g.map (a -áµ¥ Â·) :=
  mapâ‚‚_pure_left

@[simp]
theorem vsub_pure : f -áµ¥ pure b = f.map (Â· -áµ¥ b) :=
  mapâ‚‚_pure_right

theorem pure_vsub_pure : (pure a : Filter Î²) -áµ¥ pure b = (pure (a -áµ¥ b) : Filter Î±) := by simp

theorem vsub_le_vsub : fâ‚ â‰¤ fâ‚‚ â†’ gâ‚ â‰¤ gâ‚‚ â†’ fâ‚ -áµ¥ gâ‚ â‰¤ fâ‚‚ -áµ¥ gâ‚‚ :=
  mapâ‚‚_mono

theorem vsub_le_vsub_left : gâ‚ â‰¤ gâ‚‚ â†’ f -áµ¥ gâ‚ â‰¤ f -áµ¥ gâ‚‚ :=
  mapâ‚‚_mono_left

theorem vsub_le_vsub_right : fâ‚ â‰¤ fâ‚‚ â†’ fâ‚ -áµ¥ g â‰¤ fâ‚‚ -áµ¥ g :=
  mapâ‚‚_mono_right

@[simp]
theorem le_vsub_iff : h â‰¤ f -áµ¥ g â†” âˆ€ â¦ƒsâ¦„, s âˆˆ f â†’ âˆ€ â¦ƒtâ¦„, t âˆˆ g â†’ s -áµ¥ t âˆˆ h :=
  le_mapâ‚‚_iff

end Vsub

/-! ### Translation/scaling of filters -/


section SMul

variable [SMul Î± Î²] {f fâ‚ fâ‚‚ : Filter Î²} {s : Set Î²} {a : Î±}

/-- `a â€¢ f` is the map of `f` under `a â€¢` in locale `Pointwise`. -/
@[to_additive /-- `a +áµ¥ f` is the map of `f` under `a +áµ¥` in locale `Pointwise`. -/]
protected def instSMulFilter : SMul Î± (Filter Î²) :=
  âŸ¨fun a â†¦ map (a â€¢ Â·)âŸ©

scoped[Pointwise] attribute [instance] Filter.instSMulFilter Filter.instVAddFilter

@[to_additive (attr := simp)]
protected theorem map_smul : map (fun b â†¦ a â€¢ b) f = a â€¢ f :=
  rfl

@[to_additive]
theorem mem_smul_filter : s âˆˆ a â€¢ f â†” (a â€¢ Â·) â»Â¹' s âˆˆ f := Iff.rfl

@[to_additive]
theorem smul_set_mem_smul_filter : s âˆˆ f â†’ a â€¢ s âˆˆ a â€¢ f :=
  image_mem_map

@[to_additive (attr := simp)]
theorem smul_filter_bot : a â€¢ (âŠ¥ : Filter Î²) = âŠ¥ :=
  map_bot

@[to_additive (attr := simp)]
theorem smul_filter_eq_bot_iff : a â€¢ f = âŠ¥ â†” f = âŠ¥ :=
  map_eq_bot_iff

@[to_additive (attr := simp)]
theorem smul_filter_neBot_iff : (a â€¢ f).NeBot â†” f.NeBot :=
  map_neBot_iff _

@[to_additive]
theorem NeBot.smul_filter : f.NeBot â†’ (a â€¢ f).NeBot := fun h â†¦ h.map _

@[to_additive]
theorem NeBot.of_smul_filter : (a â€¢ f).NeBot â†’ f.NeBot :=
  NeBot.of_map

@[to_additive vadd_filter.instNeBot]
lemma smul_filter.instNeBot [NeBot f] : NeBot (a â€¢ f) := .smul_filter â€¹_â€º

scoped[Pointwise] attribute [instance] smul_filter.instNeBot vadd_filter.instNeBot

@[to_additive]
theorem smul_filter_le_smul_filter (hf : fâ‚ â‰¤ fâ‚‚) : a â€¢ fâ‚ â‰¤ a â€¢ fâ‚‚ :=
  map_mono hf

@[to_additive]
instance covariant_smul_filter : CovariantClass Î± (Filter Î²) (Â· â€¢ Â·) (Â· â‰¤ Â·) :=
  âŸ¨fun _ â†¦ @map_mono Î² Î² _âŸ©

end SMul

@[to_additive]
instance smulCommClass_filter [SMul Î± Î³] [SMul Î² Î³] [SMulCommClass Î± Î² Î³] :
    SMulCommClass Î± Î² (Filter Î³) :=
  âŸ¨fun _ _ _ â†¦ map_comm (funext <| smul_comm _ _) _âŸ©

@[to_additive]
instance smulCommClass_filter' [SMul Î± Î³] [SMul Î² Î³] [SMulCommClass Î± Î² Î³] :
    SMulCommClass Î± (Filter Î²) (Filter Î³) :=
  âŸ¨fun a _ _ â†¦ map_mapâ‚‚_distrib_right <| smul_comm aâŸ©

@[to_additive]
instance smulCommClass_filter'' [SMul Î± Î³] [SMul Î² Î³] [SMulCommClass Î± Î² Î³] :
    SMulCommClass (Filter Î±) Î² (Filter Î³) :=
  haveI := SMulCommClass.symm Î± Î² Î³
  SMulCommClass.symm _ _ _

@[to_additive]
instance smulCommClass [SMul Î± Î³] [SMul Î² Î³] [SMulCommClass Î± Î² Î³] :
    SMulCommClass (Filter Î±) (Filter Î²) (Filter Î³) :=
  âŸ¨fun _ _ _ â†¦ mapâ‚‚_left_comm smul_commâŸ©

@[to_additive]
instance isScalarTower [SMul Î± Î²] [SMul Î± Î³] [SMul Î² Î³] [IsScalarTower Î± Î² Î³] :
    IsScalarTower Î± Î² (Filter Î³) :=
  âŸ¨fun a b f â†¦ by simp only [â† Filter.map_smul, map_map, smul_assoc]; rflâŸ©

@[to_additive]
instance isScalarTower' [SMul Î± Î²] [SMul Î± Î³] [SMul Î² Î³] [IsScalarTower Î± Î² Î³] :
    IsScalarTower Î± (Filter Î²) (Filter Î³) :=
  âŸ¨fun a f g â†¦ by
    refine (map_mapâ‚‚_distrib_left fun _ _ â†¦ ?_).symm
    exact (smul_assoc a _ _).symmâŸ©

@[to_additive]
instance isScalarTower'' [SMul Î± Î²] [SMul Î± Î³] [SMul Î² Î³] [IsScalarTower Î± Î² Î³] :
    IsScalarTower (Filter Î±) (Filter Î²) (Filter Î³) :=
  âŸ¨fun _ _ _ â†¦ mapâ‚‚_assoc smul_assocâŸ©

@[to_additive]
instance isCentralScalar [SMul Î± Î²] [SMul Î±áµáµ’áµ– Î²] [IsCentralScalar Î± Î²] :
    IsCentralScalar Î± (Filter Î²) :=
  âŸ¨fun _ f â†¦ (congr_arg fun m â†¦ map m f) <| funext fun _ â†¦ op_smul_eq_smul _ _âŸ©

/-- A multiplicative action of a monoid `Î±` on a type `Î²` gives a multiplicative action of
`Filter Î±` on `Filter Î²`. -/
@[to_additive /-- An additive action of an additive monoid `Î±` on a type `Î²` gives an additive
action of `Filter Î±` on `Filter Î²`. -/]
protected def mulAction [Monoid Î±] [MulAction Î± Î²] : MulAction (Filter Î±) (Filter Î²) where
  one_smul f := mapâ‚‚_pure_left.trans <| by simp_rw [one_smul, map_id']
  mul_smul _ _ _ := mapâ‚‚_assoc mul_smul

/-- A multiplicative action of a monoid on a type `Î²` gives a multiplicative action on `Filter Î²`.
-/
@[to_additive /-- An additive action of an additive monoid on a type `Î²` gives an additive action on
`Filter Î²`. -/]
protected def mulActionFilter [Monoid Î±] [MulAction Î± Î²] : MulAction Î± (Filter Î²) where
  mul_smul a b f := by simp only [â† Filter.map_smul, map_map, Function.comp_def, â† mul_smul]
  one_smul f := by simp only [â† Filter.map_smul, one_smul, map_id']

scoped[Pointwise] attribute [instance] Filter.mulAction Filter.addAction Filter.mulActionFilter
  Filter.addActionFilter

/-- A distributive multiplicative action of a monoid on an additive monoid `Î²` gives a distributive
multiplicative action on `Filter Î²`. -/
protected def distribMulActionFilter [Monoid Î±] [AddMonoid Î²] [DistribMulAction Î± Î²] :
    DistribMulAction Î± (Filter Î²) where
  smul_add _ _ _ := map_mapâ‚‚_distrib <| smul_add _
  smul_zero _ := (map_pure _ _).trans <| by rw [smul_zero, pure_zero]

/-- A multiplicative action of a monoid on a monoid `Î²` gives a multiplicative action on `Set Î²`. -/
protected noncomputable def mulDistribMulActionFilter
    [Monoid Î±] [Monoid Î²] [MulDistribMulAction Î± Î²] : MulDistribMulAction Î± (Set Î²) where
  smul_mul _ _ _ := image_image2_distrib <| smul_mul' _
  smul_one _ := image_singleton.trans <| by rw [smul_one, singleton_one]

scoped[Pointwise]
  attribute [instance] Filter.distribMulActionFilter Filter.mulDistribMulActionFilter

section SMulWithZero

variable [Zero Î±] [Zero Î²] [SMulWithZero Î± Î²] {f : Filter Î±} {g : Filter Î²}

/-!
Note that we have neither `SMulWithZero Î± (Filter Î²)` nor `SMulWithZero (Filter Î±) (Filter Î²)`
because `0 * âŠ¥ â‰  0`.
-/

theorem NeBot.smul_zero_nonneg (hf : f.NeBot) : 0 â‰¤ f â€¢ (0 : Filter Î²) :=
  le_smul_iff.2 fun _ hâ‚ _ hâ‚‚ â†¦
    let âŸ¨_, haâŸ© := hf.nonempty_of_mem hâ‚
    âŸ¨_, ha, _, hâ‚‚, smul_zero _âŸ©

theorem NeBot.zero_smul_nonneg (hg : g.NeBot) : 0 â‰¤ (0 : Filter Î±) â€¢ g :=
  le_smul_iff.2 fun _ hâ‚ _ hâ‚‚ â†¦
    let âŸ¨_, hbâŸ© := hg.nonempty_of_mem hâ‚‚
    âŸ¨_, hâ‚, _, hb, zero_smul _ _âŸ©

theorem zero_smul_filter_nonpos : (0 : Î±) â€¢ g â‰¤ 0 := by
  refine fun s hs â†¦ mem_smul_filter.2 ?_
  convert @univ_mem _ g
  refine eq_univ_iff_forall.2 fun a â†¦ ?_
  rwa [mem_preimage, zero_smul]

theorem zero_smul_filter (hg : g.NeBot) : (0 : Î±) â€¢ g = 0 :=
  zero_smul_filter_nonpos.antisymm <|
    le_map_iff.2 fun s hs â†¦ by
      simp_rw [zero_smul, (hg.nonempty_of_mem hs).image_const]
      exact zero_mem_zero

end SMulWithZero

section Cancel

@[to_additive]
theorem _root_.IsUnit.smul_tendsto_smul_iff [Monoid Î³] [MulAction Î³ Î²] {m : Î± â†’ Î²} {c : Î³}
    {f : Filter Î±} {g : Filter Î²} (hc : IsUnit c) :
    Tendsto (c â€¢ m) f (c â€¢ g) â†” Tendsto m f g := by
  rcases hc.exists_left_inv with âŸ¨d, hdâŸ©
  refine âŸ¨fun H â†¦ ?_, fun H â†¦ tendsto_map.comp HâŸ©
  simpa [Function.comp_def, smul_smul, hd] using (tendsto_map (f := (d â€¢ Â·))).comp H

@[to_additive (attr := simp)]
theorem smul_tendsto_smul_iff [Group Î³] [MulAction Î³ Î²] {m : Î± â†’ Î²} {c : Î³} {f : Filter Î±}
    {g : Filter Î²} : Tendsto (c â€¢ m) f (c â€¢ g) â†” Tendsto m f g :=
  Group.isUnit _ |>.smul_tendsto_smul_iff

theorem smul_tendsto_smul_iffâ‚€ [GroupWithZero Î³] [MulAction Î³ Î²] {m : Î± â†’ Î²} {c : Î³} {f : Filter Î±}
    {g : Filter Î²} (hc : c â‰  0) : Tendsto (c â€¢ m) f (c â€¢ g) â†” Tendsto m f g :=
  hc.isUnit.smul_tendsto_smul_iff

end Cancel

end Filter
