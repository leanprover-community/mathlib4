/-
Copyright (c) 2019 Zhouhang Zhou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zhouhang Zhou, Ya√´l Dillies
-/
import Mathlib.Algebra.Group.Action.Pointwise.Set.Basic
import Mathlib.Algebra.GroupWithZero.Action.Defs
import Mathlib.Algebra.GroupWithZero.Units.Basic
import Mathlib.Algebra.Order.Group.OrderIso
import Mathlib.Algebra.Order.Monoid.Defs
import Mathlib.Algebra.Ring.Defs
import Mathlib.Order.Filter.AtTopBot.Map
import Mathlib.Order.Filter.Finite
import Mathlib.Order.Filter.NAry
import Mathlib.Order.Filter.Ultrafilter.Defs

/-!
# Pointwise operations on filters

This file defines pointwise operations on filters. This is useful because usual algebraic operations
distribute over pointwise operations. For example,
* `(f‚ÇÅ * f‚ÇÇ).map m = f‚ÇÅ.map m * f‚ÇÇ.map m`
* `ùìù (x * y) = ùìù x * ùìù y`

## Main declarations

* `0` (`Filter.instZero`): Pure filter at `0 : Œ±`, or alternatively principal filter at `0 : Set Œ±`.
* `1` (`Filter.instOne`): Pure filter at `1 : Œ±`, or alternatively principal filter at `1 : Set Œ±`.
* `f + g` (`Filter.instAdd`): Addition, filter generated by all `s + t` where `s ‚àà f` and `t ‚àà g`.
* `f * g` (`Filter.instMul`): Multiplication, filter generated by all `s * t` where `s ‚àà f` and
  `t ‚àà g`.
* `-f` (`Filter.instNeg`): Negation, filter of all `-s` where `s ‚àà f`.
* `f‚Åª¬π` (`Filter.instInv`): Inversion, filter of all `s‚Åª¬π` where `s ‚àà f`.
* `f - g` (`Filter.instSub`): Subtraction, filter generated by all `s - t` where `s ‚àà f` and
  `t ‚àà g`.
* `f / g` (`Filter.instDiv`): Division, filter generated by all `s / t` where `s ‚àà f` and `t ‚àà g`.
* `f +·µ• g` (`Filter.instVAdd`): Scalar addition, filter generated by all `s +·µ• t` where `s ‚àà f` and
  `t ‚àà g`.
* `f -·µ• g` (`Filter.instVSub`): Scalar subtraction, filter generated by all `s -·µ• t` where `s ‚àà f`
  and `t ‚àà g`.
* `f ‚Ä¢ g` (`Filter.instSMul`): Scalar multiplication, filter generated by all `s ‚Ä¢ t` where
  `s ‚àà f` and `t ‚àà g`.
* `a +·µ• f` (`Filter.instVAddFilter`): Translation, filter of all `a +·µ• s` where `s ‚àà f`.
* `a ‚Ä¢ f` (`Filter.instSMulFilter`): Scaling, filter of all `a ‚Ä¢ s` where `s ‚àà f`.

For `Œ±` a semigroup/monoid, `Filter Œ±` is a semigroup/monoid.
As an unfortunate side effect, this means that `n ‚Ä¢ f`, where `n : ‚Ñï`, is ambiguous between
pointwise scaling and repeated pointwise addition. See note [pointwise nat action].

## Implementation notes

We put all instances in the scope `Pointwise`, so that these instances are not available by
default. Note that we do not mark them as reducible (as argued by note [reducible non-instances])
since we expect the scope to be open whenever the instances are actually used (and making the
instances reducible changes the behavior of `simp`).

## Tags

filter multiplication, filter addition, pointwise addition, pointwise multiplication,
-/


open Function Set Filter Pointwise

variable {F Œ± Œ≤ Œ≥ Œ¥ Œµ : Type*}

namespace Filter

/-! ### `0`/`1` as filters -/


section One

variable [One Œ±] {f : Filter Œ±} {s : Set Œ±}

/-- `1 : Filter Œ±` is defined as the filter of sets containing `1 : Œ±` in scope `Pointwise`. -/
@[to_additive
/-- `0 : Filter Œ±` is defined as the filter of sets containing `0 : Œ±` in scope `Pointwise`. -/]
protected def instOne : One (Filter Œ±) :=
  ‚ü®pure 1‚ü©

scoped[Pointwise] attribute [instance] Filter.instOne Filter.instZero

@[to_additive (attr := simp)]
theorem mem_one : s ‚àà (1 : Filter Œ±) ‚Üî (1 : Œ±) ‚àà s :=
  mem_pure

@[to_additive]
theorem one_mem_one : (1 : Set Œ±) ‚àà (1 : Filter Œ±) :=
  mem_pure.2 Set.one_mem_one

@[to_additive (attr := simp)]
theorem pure_one : pure 1 = (1 : Filter Œ±) :=
  rfl

@[to_additive (attr := simp) zero_prod]
theorem one_prod {l : Filter Œ≤} : (1 : Filter Œ±) √óÀ¢ l = map (1, ¬∑) l := pure_prod

@[to_additive (attr := simp) prod_zero]
theorem prod_one {l : Filter Œ≤} : l √óÀ¢ (1 : Filter Œ±) = map (¬∑, 1) l := prod_pure

@[to_additive (attr := simp)]
theorem principal_one : ùìü 1 = (1 : Filter Œ±) :=
  principal_singleton _

@[to_additive]
theorem one_neBot : (1 : Filter Œ±).NeBot :=
  Filter.pure_neBot

scoped[Pointwise] attribute [instance] one_neBot zero_neBot

@[to_additive (attr := simp)]
protected theorem map_one' (f : Œ± ‚Üí Œ≤) : (1 : Filter Œ±).map f = pure (f 1) :=
  rfl

@[to_additive (attr := simp)]
theorem le_one_iff : f ‚â§ 1 ‚Üî (1 : Set Œ±) ‚àà f :=
  le_pure_iff

@[to_additive]
protected theorem NeBot.le_one_iff (h : f.NeBot) : f ‚â§ 1 ‚Üî f = 1 :=
  h.le_pure_iff

@[to_additive (attr := simp)]
theorem eventually_one {p : Œ± ‚Üí Prop} : (‚àÄ·∂† x in 1, p x) ‚Üî p 1 :=
  eventually_pure

@[to_additive (attr := simp)]
theorem tendsto_one {a : Filter Œ≤} {f : Œ≤ ‚Üí Œ±} : Tendsto f a 1 ‚Üî ‚àÄ·∂† x in a, f x = 1 :=
  tendsto_pure

@[to_additive zero_prod_zero]
theorem one_prod_one [One Œ≤] : (1 : Filter Œ±) √óÀ¢ (1 : Filter Œ≤) = 1 :=
  prod_pure_pure

/-- `pure` as a `OneHom`. -/
@[to_additive /-- `pure` as a `ZeroHom`. -/]
def pureOneHom : OneHom Œ± (Filter Œ±) where
  toFun := pure; map_one' := pure_one

@[to_additive (attr := simp)]
theorem coe_pureOneHom : (pureOneHom : Œ± ‚Üí Filter Œ±) = pure :=
  rfl

@[to_additive (attr := simp)]
theorem pureOneHom_apply (a : Œ±) : pureOneHom a = pure a :=
  rfl

variable [One Œ≤]

@[to_additive]
protected theorem map_one [FunLike F Œ± Œ≤] [OneHomClass F Œ± Œ≤] (œÜ : F) : map œÜ 1 = 1 := by
  simp

end One

/-! ### Filter negation/inversion -/


section Inv

variable [Inv Œ±] {f g : Filter Œ±} {s : Set Œ±} {a : Œ±}

/-- The inverse of a filter is the pointwise preimage under `‚Åª¬π` of its sets. -/
@[to_additive /-- The negation of a filter is the pointwise preimage under `-` of its sets. -/]
instance instInv : Inv (Filter Œ±) :=
  ‚ü®map Inv.inv‚ü©

@[to_additive (attr := simp)]
protected theorem map_inv : f.map Inv.inv = f‚Åª¬π :=
  rfl

@[to_additive]
theorem mem_inv : s ‚àà f‚Åª¬π ‚Üî Inv.inv ‚Åª¬π' s ‚àà f :=
  Iff.rfl

@[to_additive]
protected theorem inv_le_inv (hf : f ‚â§ g) : f‚Åª¬π ‚â§ g‚Åª¬π :=
  map_mono hf

@[to_additive (attr := simp)]
theorem inv_pure : (pure a : Filter Œ±)‚Åª¬π = pure a‚Åª¬π :=
  rfl

@[to_additive (attr := simp)]
theorem inv_eq_bot_iff : f‚Åª¬π = ‚ä• ‚Üî f = ‚ä• :=
  map_eq_bot_iff

@[to_additive (attr := simp)]
theorem neBot_inv_iff : f‚Åª¬π.NeBot ‚Üî NeBot f :=
  map_neBot_iff _

@[to_additive]
protected theorem NeBot.inv : f.NeBot ‚Üí f‚Åª¬π.NeBot := fun h => h.map _

@[to_additive neg.instNeBot]
lemma inv.instNeBot [NeBot f] : NeBot f‚Åª¬π := .inv ‚Äπ_‚Ä∫

scoped[Pointwise] attribute [instance] inv.instNeBot neg.instNeBot

end Inv

section InvolutiveInv

variable [InvolutiveInv Œ±] {f g : Filter Œ±} {s : Set Œ±}

@[to_additive (attr := simp)]
protected lemma comap_inv : comap Inv.inv f = f‚Åª¬π :=
  .symm <| map_eq_comap_of_inverse (inv_comp_inv _) (inv_comp_inv _)

@[to_additive]
theorem inv_mem_inv (hs : s ‚àà f) : s‚Åª¬π ‚àà f‚Åª¬π := by rwa [mem_inv, inv_preimage, inv_inv]

/-- Inversion is involutive on `Filter Œ±` if it is on `Œ±`. -/
@[to_additive /-- Negation is involutive on `Filter Œ±` if it is on `Œ±`. -/]
protected def instInvolutiveInv : InvolutiveInv (Filter Œ±) :=
  { Filter.instInv with
    inv_inv := fun f => map_map.trans <| by rw [inv_involutive.comp_self, map_id] }

scoped[Pointwise] attribute [instance] Filter.instInvolutiveInv Filter.instInvolutiveNeg

@[to_additive (attr := simp)]
protected theorem inv_le_inv_iff : f‚Åª¬π ‚â§ g‚Åª¬π ‚Üî f ‚â§ g :=
  ‚ü®fun h => inv_inv f ‚ñ∏ inv_inv g ‚ñ∏ Filter.inv_le_inv h, Filter.inv_le_inv‚ü©

@[to_additive]
theorem inv_le_iff_le_inv : f‚Åª¬π ‚â§ g ‚Üî f ‚â§ g‚Åª¬π := by rw [‚Üê Filter.inv_le_inv_iff, inv_inv]

@[to_additive (attr := simp)]
theorem inv_le_self : f‚Åª¬π ‚â§ f ‚Üî f‚Åª¬π = f :=
  ‚ü®fun h => h.antisymm <| inv_le_iff_le_inv.1 h, Eq.le‚ü©

end InvolutiveInv

@[to_additive (attr := simp)]
lemma inv_atTop {G : Type*} [CommGroup G] [PartialOrder G] [IsOrderedMonoid G] :
    (atTop : Filter G)‚Åª¬π = atBot :=
  (OrderIso.inv G).map_atTop

/-! ### Filter addition/multiplication -/

section Mul

variable [Mul Œ±] [Mul Œ≤] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ h : Filter Œ±} {s t : Set Œ±} {a b : Œ±}

/-- The filter `f * g` is generated by `{s * t | s ‚àà f, t ‚àà g}` in scope `Pointwise`. -/
@[to_additive
/-- The filter `f + g` is generated by `{s + t | s ‚àà f, t ‚àà g}` in scope `Pointwise`. -/]
protected def instMul : Mul (Filter Œ±) :=
  ‚ü®/- This is defeq to `map‚ÇÇ (¬∑ * ¬∑) f g`, but the hypothesis unfolds to `t‚ÇÅ * t‚ÇÇ ‚äÜ s` rather
  than all the way to `Set.image2 (¬∑ * ¬∑) t‚ÇÅ t‚ÇÇ ‚äÜ s`. -/
  fun f g => { map‚ÇÇ (¬∑ * ¬∑) f g with sets := { s | ‚àÉ t‚ÇÅ ‚àà f, ‚àÉ t‚ÇÇ ‚àà g, t‚ÇÅ * t‚ÇÇ ‚äÜ s } }‚ü©

scoped[Pointwise] attribute [instance] Filter.instMul Filter.instAdd

@[to_additive (attr := simp)]
theorem map‚ÇÇ_mul : map‚ÇÇ (¬∑ * ¬∑) f g = f * g :=
  rfl

@[to_additive]
theorem mem_mul : s ‚àà f * g ‚Üî ‚àÉ t‚ÇÅ ‚àà f, ‚àÉ t‚ÇÇ ‚àà g, t‚ÇÅ * t‚ÇÇ ‚äÜ s :=
  Iff.rfl

@[to_additive]
theorem mul_mem_mul : s ‚àà f ‚Üí t ‚àà g ‚Üí s * t ‚àà f * g :=
  image2_mem_map‚ÇÇ

@[to_additive (attr := simp)]
theorem bot_mul : ‚ä• * g = ‚ä• :=
  map‚ÇÇ_bot_left

@[to_additive (attr := simp)]
theorem mul_bot : f * ‚ä• = ‚ä• :=
  map‚ÇÇ_bot_right

@[to_additive (attr := simp)]
theorem mul_eq_bot_iff : f * g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• :=
  map‚ÇÇ_eq_bot_iff

@[to_additive (attr := simp)] -- TODO: make this a scoped instance in the `Pointwise` namespace
lemma mul_neBot_iff : (f * g).NeBot ‚Üî f.NeBot ‚àß g.NeBot :=
  map‚ÇÇ_neBot_iff

@[to_additive]
protected theorem NeBot.mul : NeBot f ‚Üí NeBot g ‚Üí NeBot (f * g) :=
  NeBot.map‚ÇÇ

@[to_additive]
theorem NeBot.of_mul_left : (f * g).NeBot ‚Üí f.NeBot :=
  NeBot.of_map‚ÇÇ_left

@[to_additive]
theorem NeBot.of_mul_right : (f * g).NeBot ‚Üí g.NeBot :=
  NeBot.of_map‚ÇÇ_right

@[to_additive add.instNeBot]
protected lemma mul.instNeBot [NeBot f] [NeBot g] : NeBot (f * g) := .mul ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫

scoped[Pointwise] attribute [instance] mul.instNeBot add.instNeBot

@[to_additive (attr := simp)]
theorem pure_mul : pure a * g = g.map (a * ¬∑) :=
  map‚ÇÇ_pure_left

@[to_additive (attr := simp)]
theorem mul_pure : f * pure b = f.map (¬∑ * b) :=
  map‚ÇÇ_pure_right

@[to_additive]
theorem pure_mul_pure : (pure a : Filter Œ±) * pure b = pure (a * b) := by simp

@[to_additive (attr := simp)]
theorem le_mul_iff : h ‚â§ f * g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s * t ‚àà h :=
  le_map‚ÇÇ_iff

@[to_additive]
instance mulLeftMono : MulLeftMono (Filter Œ±) :=
  ‚ü®fun _ _ _ => map‚ÇÇ_mono_left‚ü©

@[to_additive]
instance mulRightMono : MulRightMono (Filter Œ±) :=
  ‚ü®fun _ _ _ => map‚ÇÇ_mono_right‚ü©

@[to_additive]
protected theorem map_mul [FunLike F Œ± Œ≤] [MulHomClass F Œ± Œ≤] (m : F) :
    (f‚ÇÅ * f‚ÇÇ).map m = f‚ÇÅ.map m * f‚ÇÇ.map m :=
  map_map‚ÇÇ_distrib <| map_mul m

/-- `pure` operation as a `MulHom`. -/
@[to_additive /-- The singleton operation as an `AddHom`. -/]
def pureMulHom : Œ± ‚Üí‚Çô* Filter Œ± where
  toFun := pure; map_mul' _ _ := pure_mul_pure.symm

@[to_additive (attr := simp)]
theorem coe_pureMulHom : (pureMulHom : Œ± ‚Üí Filter Œ±) = pure :=
  rfl

@[to_additive (attr := simp)]
theorem pureMulHom_apply (a : Œ±) : pureMulHom a = pure a :=
  rfl

end Mul

/-! ### Filter subtraction/division -/

section Div

variable [Div Œ±] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ h : Filter Œ±} {s t : Set Œ±} {a b : Œ±}

/-- The filter `f / g` is generated by `{s / t | s ‚àà f, t ‚àà g}` in scope `Pointwise`. -/
@[to_additive
/-- The filter `f - g` is generated by `{s - t | s ‚àà f, t ‚àà g}` in scope `Pointwise`. -/]
protected def instDiv : Div (Filter Œ±) :=
  ‚ü®/- This is defeq to `map‚ÇÇ (¬∑ / ¬∑) f g`, but the hypothesis unfolds to `t‚ÇÅ / t‚ÇÇ ‚äÜ s`
  rather than all the way to `Set.image2 (¬∑ / ¬∑) t‚ÇÅ t‚ÇÇ ‚äÜ s`. -/
  fun f g => { map‚ÇÇ (¬∑ / ¬∑) f g with sets := { s | ‚àÉ t‚ÇÅ ‚àà f, ‚àÉ t‚ÇÇ ‚àà g, t‚ÇÅ / t‚ÇÇ ‚äÜ s } }‚ü©

scoped[Pointwise] attribute [instance] Filter.instDiv Filter.instSub

@[to_additive (attr := simp)]
theorem map‚ÇÇ_div : map‚ÇÇ (¬∑ / ¬∑) f g = f / g :=
  rfl

@[to_additive]
theorem mem_div : s ‚àà f / g ‚Üî ‚àÉ t‚ÇÅ ‚àà f, ‚àÉ t‚ÇÇ ‚àà g, t‚ÇÅ / t‚ÇÇ ‚äÜ s :=
  Iff.rfl

@[to_additive]
theorem div_mem_div : s ‚àà f ‚Üí t ‚àà g ‚Üí s / t ‚àà f / g :=
  image2_mem_map‚ÇÇ

@[to_additive (attr := simp)]
theorem bot_div : ‚ä• / g = ‚ä• :=
  map‚ÇÇ_bot_left

@[to_additive (attr := simp)]
theorem div_bot : f / ‚ä• = ‚ä• :=
  map‚ÇÇ_bot_right

@[to_additive (attr := simp)]
theorem div_eq_bot_iff : f / g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• :=
  map‚ÇÇ_eq_bot_iff

@[to_additive (attr := simp)]
theorem div_neBot_iff : (f / g).NeBot ‚Üî f.NeBot ‚àß g.NeBot :=
  map‚ÇÇ_neBot_iff

@[to_additive]
protected theorem NeBot.div : NeBot f ‚Üí NeBot g ‚Üí NeBot (f / g) :=
  NeBot.map‚ÇÇ

@[to_additive]
theorem NeBot.of_div_left : (f / g).NeBot ‚Üí f.NeBot :=
  NeBot.of_map‚ÇÇ_left

@[to_additive]
theorem NeBot.of_div_right : (f / g).NeBot ‚Üí g.NeBot :=
  NeBot.of_map‚ÇÇ_right

@[to_additive sub.instNeBot]
lemma div.instNeBot [NeBot f] [NeBot g] : NeBot (f / g) := .div ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫

scoped[Pointwise] attribute [instance] div.instNeBot sub.instNeBot

@[to_additive (attr := simp)]
theorem pure_div : pure a / g = g.map (a / ¬∑) :=
  map‚ÇÇ_pure_left

@[to_additive (attr := simp)]
theorem div_pure : f / pure b = f.map (¬∑ / b) :=
  map‚ÇÇ_pure_right

@[to_additive]
theorem pure_div_pure : (pure a : Filter Œ±) / pure b = pure (a / b) := by simp

@[to_additive]
protected theorem div_le_div : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f‚ÇÅ / g‚ÇÅ ‚â§ f‚ÇÇ / g‚ÇÇ :=
  map‚ÇÇ_mono

@[to_additive]
protected theorem div_le_div_left : g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f / g‚ÇÅ ‚â§ f / g‚ÇÇ :=
  map‚ÇÇ_mono_left

@[to_additive]
protected theorem div_le_div_right : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí f‚ÇÅ / g ‚â§ f‚ÇÇ / g :=
  map‚ÇÇ_mono_right

@[to_additive (attr := simp)]
protected theorem le_div_iff : h ‚â§ f / g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s / t ‚àà h :=
  le_map‚ÇÇ_iff

@[to_additive]
instance covariant_div : CovariantClass (Filter Œ±) (Filter Œ±) (¬∑ / ¬∑) (¬∑ ‚â§ ¬∑) :=
  ‚ü®fun _ _ _ => map‚ÇÇ_mono_left‚ü©

@[to_additive]
instance covariant_swap_div : CovariantClass (Filter Œ±) (Filter Œ±) (swap (¬∑ / ¬∑)) (¬∑ ‚â§ ¬∑) :=
  ‚ü®fun _ _ _ => map‚ÇÇ_mono_right‚ü©

end Div

/-- Repeated pointwise addition (not the same as pointwise repeated addition!) of a `Filter`. See
Note [pointwise nat action]. -/
protected def instNSMul [Zero Œ±] [Add Œ±] : SMul ‚Ñï (Filter Œ±) :=
  ‚ü®nsmulRec‚ü©

/-- Repeated pointwise multiplication (not the same as pointwise repeated multiplication!) of a
`Filter`. See Note [pointwise nat action]. -/
@[to_additive existing]
protected def instNPow [One Œ±] [Mul Œ±] : Pow (Filter Œ±) ‚Ñï :=
  ‚ü®fun s n => npowRec n s‚ü©

/-- Repeated pointwise addition/subtraction (not the same as pointwise repeated
addition/subtraction!) of a `Filter`. See Note [pointwise nat action]. -/
protected def instZSMul [Zero Œ±] [Add Œ±] [Neg Œ±] : SMul ‚Ñ§ (Filter Œ±) :=
  ‚ü®zsmulRec‚ü©

/-- Repeated pointwise multiplication/division (not the same as pointwise repeated
multiplication/division!) of a `Filter`. See Note [pointwise nat action]. -/
@[to_additive existing]
protected def instZPow [One Œ±] [Mul Œ±] [Inv Œ±] : Pow (Filter Œ±) ‚Ñ§ :=
  ‚ü®fun s n => zpowRec npowRec n s‚ü©

scoped[Pointwise] attribute [instance] Filter.instNSMul Filter.instNPow
  Filter.instZSMul Filter.instZPow

/-- `Filter Œ±` is a `Semigroup` under pointwise operations if `Œ±` is. -/
@[to_additive /-- `Filter Œ±` is an `AddSemigroup` under pointwise operations if `Œ±` is. -/]
protected def semigroup [Semigroup Œ±] : Semigroup (Filter Œ±) where
  mul := (¬∑ * ¬∑)
  mul_assoc _ _ _ := map‚ÇÇ_assoc mul_assoc

/-- `Filter Œ±` is a `CommSemigroup` under pointwise operations if `Œ±` is. -/
@[to_additive /-- `Filter Œ±` is an `AddCommSemigroup` under pointwise operations if `Œ±` is. -/]
protected def commSemigroup [CommSemigroup Œ±] : CommSemigroup (Filter Œ±) :=
  { Filter.semigroup with mul_comm := fun _ _ => map‚ÇÇ_comm mul_comm }

section MulOneClass

variable [MulOneClass Œ±] [MulOneClass Œ≤]

/-- `Filter Œ±` is a `MulOneClass` under pointwise operations if `Œ±` is. -/
@[to_additive /-- `Filter Œ±` is an `AddZeroClass` under pointwise operations if `Œ±` is. -/]
protected def mulOneClass : MulOneClass (Filter Œ±) where
  one := 1
  mul := (¬∑ * ¬∑)
  one_mul := map‚ÇÇ_left_identity one_mul
  mul_one := map‚ÇÇ_right_identity mul_one

scoped[Pointwise] attribute [instance] Filter.semigroup Filter.addSemigroup
  Filter.commSemigroup Filter.addCommSemigroup Filter.mulOneClass Filter.addZeroClass

variable [FunLike F Œ± Œ≤]

/-- If `œÜ : Œ± ‚Üí* Œ≤` then `mapMonoidHom œÜ` is the monoid homomorphism
`Filter Œ± ‚Üí* Filter Œ≤` induced by `map œÜ`. -/
@[to_additive /-- If `œÜ : Œ± ‚Üí+ Œ≤` then `mapAddMonoidHom œÜ` is the monoid homomorphism
`Filter Œ± ‚Üí+ Filter Œ≤` induced by `map œÜ`. -/]
def mapMonoidHom [MonoidHomClass F Œ± Œ≤] (œÜ : F) : Filter Œ± ‚Üí* Filter Œ≤ where
  toFun := map œÜ
  map_one' := Filter.map_one œÜ
  map_mul' _ _ := Filter.map_mul œÜ

-- The other direction does not hold in general
@[to_additive]
theorem comap_mul_comap_le [MulHomClass F Œ± Œ≤] (m : F) {f g : Filter Œ≤} :
    f.comap m * g.comap m ‚â§ (f * g).comap m := fun _ ‚ü®_, ‚ü®t‚ÇÅ, ht‚ÇÅ, t‚ÇÇ, ht‚ÇÇ, t‚ÇÅt‚ÇÇ‚ü©, mt‚ü© =>
  ‚ü®m ‚Åª¬π' t‚ÇÅ, ‚ü®t‚ÇÅ, ht‚ÇÅ, Subset.rfl‚ü©, m ‚Åª¬π' t‚ÇÇ, ‚ü®t‚ÇÇ, ht‚ÇÇ, Subset.rfl‚ü©,
    (preimage_mul_preimage_subset _).trans <| (preimage_mono t‚ÇÅt‚ÇÇ).trans mt‚ü©

@[to_additive]
theorem Tendsto.mul_mul [MulHomClass F Œ± Œ≤] (m : F) {f‚ÇÅ g‚ÇÅ : Filter Œ±} {f‚ÇÇ g‚ÇÇ : Filter Œ≤} :
    Tendsto m f‚ÇÅ f‚ÇÇ ‚Üí Tendsto m g‚ÇÅ g‚ÇÇ ‚Üí Tendsto m (f‚ÇÅ * g‚ÇÅ) (f‚ÇÇ * g‚ÇÇ) := fun hf hg =>
  (Filter.map_mul m).trans_le <| mul_le_mul' hf hg

/-- `pure` as a `MonoidHom`. -/
@[to_additive /-- `pure` as an `AddMonoidHom`. -/]
def pureMonoidHom : Œ± ‚Üí* Filter Œ± :=
  { pureMulHom, pureOneHom with }

@[to_additive (attr := simp)]
theorem coe_pureMonoidHom : (pureMonoidHom : Œ± ‚Üí Filter Œ±) = pure :=
  rfl

@[to_additive (attr := simp)]
theorem pureMonoidHom_apply (a : Œ±) : pureMonoidHom a = pure a :=
  rfl

end MulOneClass

section Monoid

variable [Monoid Œ±] {f g : Filter Œ±} {s : Set Œ±} {a : Œ±} {m n : ‚Ñï}

/-- `Filter Œ±` is a `Monoid` under pointwise operations if `Œ±` is. -/
@[to_additive /-- `Filter Œ±` is an `AddMonoid` under pointwise operations if `Œ±` is. -/]
protected def monoid : Monoid (Filter Œ±) :=
  { Filter.mulOneClass, Filter.semigroup, @Filter.instNPow Œ± _ _ with }

scoped[Pointwise] attribute [instance] Filter.monoid Filter.addMonoid

@[to_additive]
theorem pow_mem_pow (hs : s ‚àà f) : ‚àÄ n : ‚Ñï, s ^ n ‚àà f ^ n
  | 0 => by
    rw [pow_zero]
    exact one_mem_one
  | n + 1 => by
    rw [pow_succ]
    exact mul_mem_mul (pow_mem_pow hs n) hs

@[to_additive (attr := simp) nsmul_bot]
theorem bot_pow {n : ‚Ñï} (hn : n ‚â† 0) : (‚ä• : Filter Œ±) ^ n = ‚ä• := by
  rw [‚Üê Nat.sub_one_add_one hn, pow_succ', bot_mul]

@[to_additive]
theorem mul_top_of_one_le (hf : 1 ‚â§ f) : f * ‚ä§ = ‚ä§ := by
  refine top_le_iff.1 fun s => ?_
  simp only [mem_mul, mem_top, exists_eq_left]
  rintro ‚ü®t, ht, hs‚ü©
  rwa [mul_univ_of_one_mem (mem_one.1 <| hf ht), univ_subset_iff] at hs

@[to_additive]
theorem top_mul_of_one_le (hf : 1 ‚â§ f) : ‚ä§ * f = ‚ä§ := by
  refine top_le_iff.1 fun s => ?_
  simp only [mem_mul, mem_top, exists_eq_left]
  rintro ‚ü®t, ht, hs‚ü©
  rwa [univ_mul_of_one_mem (mem_one.1 <| hf ht), univ_subset_iff] at hs

@[to_additive (attr := simp)]
theorem top_mul_top : (‚ä§ : Filter Œ±) * ‚ä§ = ‚ä§ :=
  mul_top_of_one_le le_top

@[to_additive nsmul_top]
theorem top_pow : ‚àÄ {n : ‚Ñï}, n ‚â† 0 ‚Üí (‚ä§ : Filter Œ±) ^ n = ‚ä§
  | 0 => fun h => (h rfl).elim
  | 1 => fun _ => pow_one _
  | n + 2 => fun _ => by rw [pow_succ, top_pow n.succ_ne_zero, top_mul_top]

@[to_additive]
protected theorem _root_.IsUnit.filter : IsUnit a ‚Üí IsUnit (pure a : Filter Œ±) :=
  IsUnit.map (pureMonoidHom : Œ± ‚Üí* Filter Œ±)

end Monoid

/-- `Filter Œ±` is a `CommMonoid` under pointwise operations if `Œ±` is. -/
@[to_additive /-- `Filter Œ±` is an `AddCommMonoid` under pointwise operations if `Œ±` is. -/]
protected def commMonoid [CommMonoid Œ±] : CommMonoid (Filter Œ±) :=
  { Filter.mulOneClass, Filter.commSemigroup with }

section DivisionMonoid

variable [DivisionMonoid Œ±] {f g : Filter Œ±}

@[to_additive]
protected theorem mul_eq_one_iff : f * g = 1 ‚Üî ‚àÉ a b, f = pure a ‚àß g = pure b ‚àß a * b = 1 := by
  refine ‚ü®fun hfg => ?_, ?_‚ü©
  ¬∑ obtain ‚ü®t‚ÇÅ, h‚ÇÅ, t‚ÇÇ, h‚ÇÇ, h‚ü© : (1 : Set Œ±) ‚àà f * g := hfg.symm ‚ñ∏ one_mem_one
    have hfg : (f * g).NeBot := hfg.symm.subst one_neBot
    rw [(hfg.nonempty_of_mem <| mul_mem_mul h‚ÇÅ h‚ÇÇ).subset_one_iff, Set.mul_eq_one_iff] at h
    obtain ‚ü®a, b, rfl, rfl, h‚ü© := h
    refine ‚ü®a, b, ?_, ?_, h‚ü©
    ¬∑ rwa [‚Üê hfg.of_mul_left.le_pure_iff, le_pure_iff]
    ¬∑ rwa [‚Üê hfg.of_mul_right.le_pure_iff, le_pure_iff]
  ¬∑ rintro ‚ü®a, b, rfl, rfl, h‚ü©
    rw [pure_mul_pure, h, pure_one]

/-- `Filter Œ±` is a division monoid under pointwise operations if `Œ±` is. -/
@[to_additive /-- `Filter Œ±` is a subtraction monoid under pointwise operations if `Œ±` is. -/]
protected def divisionMonoid : DivisionMonoid (Filter Œ±) :=
  { Filter.monoid, Filter.instInvolutiveInv, Filter.instDiv, Filter.instZPow (Œ± := Œ±) with
    mul_inv_rev := fun _ _ => map_map‚ÇÇ_antidistrib mul_inv_rev
    inv_eq_of_mul := fun s t h => by
      obtain ‚ü®a, b, rfl, rfl, hab‚ü© := Filter.mul_eq_one_iff.1 h
      rw [inv_pure, inv_eq_of_mul_eq_one_right hab]
    div_eq_mul_inv := fun _ _ => map_map‚ÇÇ_distrib_right div_eq_mul_inv }

@[to_additive]
theorem isUnit_iff : IsUnit f ‚Üî ‚àÉ a, f = pure a ‚àß IsUnit a := by
  constructor
  ¬∑ rintro ‚ü®u, rfl‚ü©
    obtain ‚ü®a, b, ha, hb, h‚ü© := Filter.mul_eq_one_iff.1 u.mul_inv
    refine ‚ü®a, ha, ‚ü®a, b, h, pure_injective ?_‚ü©, rfl‚ü©
    rw [‚Üê pure_mul_pure, ‚Üê ha, ‚Üê hb]
    exact u.inv_mul
  ¬∑ rintro ‚ü®a, rfl, ha‚ü©
    exact ha.filter

end DivisionMonoid

/-- `Filter Œ±` is a commutative division monoid under pointwise operations if `Œ±` is. -/
@[to_additive subtractionCommMonoid
/-- `Filter Œ±` is a commutative subtraction monoid under pointwise operations if `Œ±` is. -/]
protected def divisionCommMonoid [DivisionCommMonoid Œ±] : DivisionCommMonoid (Filter Œ±) :=
  { Filter.divisionMonoid, Filter.commSemigroup with }

/-- `Filter Œ±` has distributive negation if `Œ±` has. -/
protected def instDistribNeg [Mul Œ±] [HasDistribNeg Œ±] : HasDistribNeg (Filter Œ±) :=
  { Filter.instInvolutiveNeg with
    neg_mul := fun _ _ => map‚ÇÇ_map_left_comm neg_mul
    mul_neg := fun _ _ => map_map‚ÇÇ_right_comm mul_neg }

scoped[Pointwise] attribute [instance] Filter.commMonoid Filter.addCommMonoid Filter.divisionMonoid
  Filter.subtractionMonoid Filter.divisionCommMonoid Filter.subtractionCommMonoid
  Filter.instDistribNeg

section Distrib

variable [Distrib Œ±] {f g h : Filter Œ±}

/-!
Note that `Filter Œ±` is not a `Distrib` because `f * g + f * h` has cross terms that `f * (g + h)`
lacks.
-/

theorem mul_add_subset : f * (g + h) ‚â§ f * g + f * h :=
  map‚ÇÇ_distrib_le_left mul_add

theorem add_mul_subset : (f + g) * h ‚â§ f * h + g * h :=
  map‚ÇÇ_distrib_le_right add_mul

end Distrib

section MulZeroClass

variable [MulZeroClass Œ±] {f g : Filter Œ±}

/-! Note that `Filter` is not a `MulZeroClass` because `0 * ‚ä• ‚â† 0`. -/

theorem NeBot.mul_zero_nonneg (hf : f.NeBot) : 0 ‚â§ f * 0 :=
  le_mul_iff.2 fun _ h‚ÇÅ _ h‚ÇÇ =>
    let ‚ü®_, ha‚ü© := hf.nonempty_of_mem h‚ÇÅ
    ‚ü®_, ha, _, h‚ÇÇ, mul_zero _‚ü©

theorem NeBot.zero_mul_nonneg (hg : g.NeBot) : 0 ‚â§ 0 * g :=
  le_mul_iff.2 fun _ h‚ÇÅ _ h‚ÇÇ =>
    let ‚ü®_, hb‚ü© := hg.nonempty_of_mem h‚ÇÇ
    ‚ü®_, h‚ÇÅ, _, hb, zero_mul _‚ü©

end MulZeroClass

section Group

variable [Group Œ±] [DivisionMonoid Œ≤] [FunLike F Œ± Œ≤] [MonoidHomClass F Œ± Œ≤]
  (m : F) {f g f‚ÇÅ g‚ÇÅ : Filter Œ±} {f‚ÇÇ g‚ÇÇ : Filter Œ≤}

/-! Note that `Filter Œ±` is not a group because `f / f ‚â† 1` in general -/

@[to_additive (attr := simp high)] -- Ensure this fires before `le_div_iff`.
protected theorem one_le_div_iff : 1 ‚â§ f / g ‚Üî ¬¨Disjoint f g := by
  refine ‚ü®fun h hfg => ?_, ?_‚ü©
  ¬∑ obtain ‚ü®s, hs, t, ht, hst‚ü© := hfg.le_bot (mem_bot : ‚àÖ ‚àà ‚ä•)
    exact Set.one_mem_div_iff.1 (h <| div_mem_div hs ht) (disjoint_iff.2 hst.symm)
  ¬∑ rintro h s ‚ü®t‚ÇÅ, h‚ÇÅ, t‚ÇÇ, h‚ÇÇ, hs‚ü©
    exact hs (Set.one_mem_div_iff.2 fun ht => h <| disjoint_of_disjoint_of_mem ht h‚ÇÅ h‚ÇÇ)

@[to_additive]
theorem not_one_le_div_iff : ¬¨1 ‚â§ f / g ‚Üî Disjoint f g :=
  Filter.one_le_div_iff.not_left

@[to_additive]
theorem NeBot.one_le_div (h : f.NeBot) : 1 ‚â§ f / f := by
  rintro s ‚ü®t‚ÇÅ, h‚ÇÅ, t‚ÇÇ, h‚ÇÇ, hs‚ü©
  obtain ‚ü®a, ha‚ÇÅ, ha‚ÇÇ‚ü© := Set.not_disjoint_iff.1 (h.not_disjoint h‚ÇÅ h‚ÇÇ)
  rw [mem_one, ‚Üê div_self' a]
  exact hs (Set.div_mem_div ha‚ÇÅ ha‚ÇÇ)

@[to_additive]
theorem isUnit_pure (a : Œ±) : IsUnit (pure a : Filter Œ±) :=
  (Group.isUnit a).filter

@[simp]
theorem isUnit_iff_singleton : IsUnit f ‚Üî ‚àÉ a, f = pure a := by
  simp only [isUnit_iff, Group.isUnit, and_true]

@[to_additive]
theorem map_inv' : f‚Åª¬π.map m = (f.map m)‚Åª¬π :=
  Semiconj.filter_map (map_inv m) f

@[to_additive]
protected theorem Tendsto.inv_inv : Tendsto m f‚ÇÅ f‚ÇÇ ‚Üí Tendsto m f‚ÇÅ‚Åª¬π f‚ÇÇ‚Åª¬π := fun hf =>
  (Filter.map_inv' m).trans_le <| Filter.inv_le_inv hf

@[to_additive]
protected theorem map_div : (f / g).map m = f.map m / g.map m :=
  map_map‚ÇÇ_distrib <| map_div m

@[to_additive]
protected theorem Tendsto.div_div (hf : Tendsto m f‚ÇÅ f‚ÇÇ) (hg : Tendsto m g‚ÇÅ g‚ÇÇ) :
    Tendsto m (f‚ÇÅ / g‚ÇÅ) (f‚ÇÇ / g‚ÇÇ) :=
  (Filter.map_div m).trans_le <| Filter.div_le_div hf hg

end Group

section GroupWithZero

variable [GroupWithZero Œ±] {f g : Filter Œ±}

theorem NeBot.div_zero_nonneg (hf : f.NeBot) : 0 ‚â§ f / 0 :=
  Filter.le_div_iff.2 fun _ h‚ÇÅ _ h‚ÇÇ =>
    let ‚ü®_, ha‚ü© := hf.nonempty_of_mem h‚ÇÅ
    ‚ü®_, ha, _, h‚ÇÇ, div_zero _‚ü©

theorem NeBot.zero_div_nonneg (hg : g.NeBot) : 0 ‚â§ 0 / g :=
  Filter.le_div_iff.2 fun _ h‚ÇÅ _ h‚ÇÇ =>
    let ‚ü®_, hb‚ü© := hg.nonempty_of_mem h‚ÇÇ
    ‚ü®_, h‚ÇÅ, _, hb, zero_div _‚ü©

end GroupWithZero

/-! ### Scalar addition/multiplication of filters -/


section SMul

variable [SMul Œ± Œ≤] {f f‚ÇÅ f‚ÇÇ : Filter Œ±} {g g‚ÇÅ g‚ÇÇ h : Filter Œ≤} {s : Set Œ±} {t : Set Œ≤} {a : Œ±}
  {b : Œ≤}

/-- The filter `f ‚Ä¢ g` is generated by `{s ‚Ä¢ t | s ‚àà f, t ‚àà g}` in scope `Pointwise`. -/
@[to_additive /-- The filter `f +·µ• g` is generated by `{s +·µ• t | s ‚àà f, t ‚àà g}` in locale
`Pointwise`. -/]
protected def instSMul : SMul (Filter Œ±) (Filter Œ≤) :=
  ‚ü®/- This is defeq to `map‚ÇÇ (¬∑ ‚Ä¢ ¬∑) f g`, but the hypothesis unfolds to `t‚ÇÅ ‚Ä¢ t‚ÇÇ ‚äÜ s`
  rather than all the way to `Set.image2 (¬∑ ‚Ä¢ ¬∑) t‚ÇÅ t‚ÇÇ ‚äÜ s`. -/
  fun f g => { map‚ÇÇ (¬∑ ‚Ä¢ ¬∑) f g with sets := { s | ‚àÉ t‚ÇÅ ‚àà f, ‚àÉ t‚ÇÇ ‚àà g, t‚ÇÅ ‚Ä¢ t‚ÇÇ ‚äÜ s } }‚ü©

scoped[Pointwise] attribute [instance] Filter.instSMul Filter.instVAdd

@[to_additive (attr := simp)]
theorem map‚ÇÇ_smul : map‚ÇÇ (¬∑ ‚Ä¢ ¬∑) f g = f ‚Ä¢ g :=
  rfl

@[to_additive]
theorem mem_smul : t ‚àà f ‚Ä¢ g ‚Üî ‚àÉ t‚ÇÅ ‚àà f, ‚àÉ t‚ÇÇ ‚àà g, t‚ÇÅ ‚Ä¢ t‚ÇÇ ‚äÜ t :=
  Iff.rfl

@[to_additive]
theorem smul_mem_smul : s ‚àà f ‚Üí t ‚àà g ‚Üí s ‚Ä¢ t ‚àà f ‚Ä¢ g :=
  image2_mem_map‚ÇÇ

@[to_additive (attr := simp)]
theorem bot_smul : (‚ä• : Filter Œ±) ‚Ä¢ g = ‚ä• :=
  map‚ÇÇ_bot_left

@[to_additive (attr := simp)]
theorem smul_bot : f ‚Ä¢ (‚ä• : Filter Œ≤) = ‚ä• :=
  map‚ÇÇ_bot_right

@[to_additive (attr := simp)]
theorem smul_eq_bot_iff : f ‚Ä¢ g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• :=
  map‚ÇÇ_eq_bot_iff

@[to_additive (attr := simp)]
theorem smul_neBot_iff : (f ‚Ä¢ g).NeBot ‚Üî f.NeBot ‚àß g.NeBot :=
  map‚ÇÇ_neBot_iff

@[to_additive]
protected theorem NeBot.smul : NeBot f ‚Üí NeBot g ‚Üí NeBot (f ‚Ä¢ g) :=
  NeBot.map‚ÇÇ

@[to_additive]
theorem NeBot.of_smul_left : (f ‚Ä¢ g).NeBot ‚Üí f.NeBot :=
  NeBot.of_map‚ÇÇ_left

@[to_additive]
theorem NeBot.of_smul_right : (f ‚Ä¢ g).NeBot ‚Üí g.NeBot :=
  NeBot.of_map‚ÇÇ_right

@[to_additive vadd.instNeBot]
lemma smul.instNeBot [NeBot f] [NeBot g] : NeBot (f ‚Ä¢ g) := .smul ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫

scoped[Pointwise] attribute [instance] smul.instNeBot vadd.instNeBot

@[to_additive (attr := simp)]
theorem pure_smul : (pure a : Filter Œ±) ‚Ä¢ g = g.map (a ‚Ä¢ ¬∑) :=
  map‚ÇÇ_pure_left

@[to_additive (attr := simp)]
theorem smul_pure : f ‚Ä¢ pure b = f.map (¬∑ ‚Ä¢ b) :=
  map‚ÇÇ_pure_right

@[to_additive]
theorem pure_smul_pure : (pure a : Filter Œ±) ‚Ä¢ (pure b : Filter Œ≤) = pure (a ‚Ä¢ b) := by simp

@[to_additive]
theorem smul_le_smul : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f‚ÇÅ ‚Ä¢ g‚ÇÅ ‚â§ f‚ÇÇ ‚Ä¢ g‚ÇÇ :=
  map‚ÇÇ_mono

@[to_additive]
theorem smul_le_smul_left : g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f ‚Ä¢ g‚ÇÅ ‚â§ f ‚Ä¢ g‚ÇÇ :=
  map‚ÇÇ_mono_left

@[to_additive]
theorem smul_le_smul_right : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí f‚ÇÅ ‚Ä¢ g ‚â§ f‚ÇÇ ‚Ä¢ g :=
  map‚ÇÇ_mono_right

@[to_additive (attr := simp)]
theorem le_smul_iff : h ‚â§ f ‚Ä¢ g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s ‚Ä¢ t ‚àà h :=
  le_map‚ÇÇ_iff

@[to_additive]
instance covariant_smul : CovariantClass (Filter Œ±) (Filter Œ≤) (¬∑ ‚Ä¢ ¬∑) (¬∑ ‚â§ ¬∑) :=
  ‚ü®fun _ _ _ => map‚ÇÇ_mono_left‚ü©

end SMul

/-! ### Scalar subtraction of filters -/


section Vsub

variable [VSub Œ± Œ≤] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ : Filter Œ≤} {h : Filter Œ±} {s t : Set Œ≤} {a b : Œ≤}

/-- The filter `f -·µ• g` is generated by `{s -·µ• t | s ‚àà f, t ‚àà g}` in scope `Pointwise`. -/
protected def instVSub : VSub (Filter Œ±) (Filter Œ≤) :=
  ‚ü®/- This is defeq to `map‚ÇÇ (-·µ•) f g`, but the hypothesis unfolds to `t‚ÇÅ -·µ• t‚ÇÇ ‚äÜ s` rather than all
  the way to `Set.image2 (-·µ•) t‚ÇÅ t‚ÇÇ ‚äÜ s`. -/
  fun f g => { map‚ÇÇ (¬∑ -·µ• ¬∑) f g with sets := { s | ‚àÉ t‚ÇÅ ‚àà f, ‚àÉ t‚ÇÇ ‚àà g, t‚ÇÅ -·µ• t‚ÇÇ ‚äÜ s } }‚ü©

scoped[Pointwise] attribute [instance] Filter.instVSub

@[simp]
theorem map‚ÇÇ_vsub : map‚ÇÇ (¬∑ -·µ• ¬∑) f g = f -·µ• g :=
  rfl

theorem mem_vsub {s : Set Œ±} : s ‚àà f -·µ• g ‚Üî ‚àÉ t‚ÇÅ ‚àà f, ‚àÉ t‚ÇÇ ‚àà g, t‚ÇÅ -·µ• t‚ÇÇ ‚äÜ s :=
  Iff.rfl

theorem vsub_mem_vsub : s ‚àà f ‚Üí t ‚àà g ‚Üí s -·µ• t ‚àà f -·µ• g :=
  image2_mem_map‚ÇÇ

@[simp]
theorem bot_vsub : (‚ä• : Filter Œ≤) -·µ• g = ‚ä• :=
  map‚ÇÇ_bot_left

@[simp]
theorem vsub_bot : f -·µ• (‚ä• : Filter Œ≤) = ‚ä• :=
  map‚ÇÇ_bot_right

@[simp]
theorem vsub_eq_bot_iff : f -·µ• g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• :=
  map‚ÇÇ_eq_bot_iff

@[simp]
theorem vsub_neBot_iff : (f -·µ• g : Filter Œ±).NeBot ‚Üî f.NeBot ‚àß g.NeBot :=
  map‚ÇÇ_neBot_iff

protected theorem NeBot.vsub : NeBot f ‚Üí NeBot g ‚Üí NeBot (f -·µ• g) :=
  NeBot.map‚ÇÇ

theorem NeBot.of_vsub_left : (f -·µ• g : Filter Œ±).NeBot ‚Üí f.NeBot :=
  NeBot.of_map‚ÇÇ_left

theorem NeBot.of_vsub_right : (f -·µ• g : Filter Œ±).NeBot ‚Üí g.NeBot :=
  NeBot.of_map‚ÇÇ_right

lemma vsub.instNeBot [NeBot f] [NeBot g] : NeBot (f -·µ• g) := .vsub ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫

scoped[Pointwise] attribute [instance] vsub.instNeBot

@[simp]
theorem pure_vsub : (pure a : Filter Œ≤) -·µ• g = g.map (a -·µ• ¬∑) :=
  map‚ÇÇ_pure_left

@[simp]
theorem vsub_pure : f -·µ• pure b = f.map (¬∑ -·µ• b) :=
  map‚ÇÇ_pure_right

theorem pure_vsub_pure : (pure a : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) := by simp

theorem vsub_le_vsub : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f‚ÇÅ -·µ• g‚ÇÅ ‚â§ f‚ÇÇ -·µ• g‚ÇÇ :=
  map‚ÇÇ_mono

theorem vsub_le_vsub_left : g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f -·µ• g‚ÇÅ ‚â§ f -·µ• g‚ÇÇ :=
  map‚ÇÇ_mono_left

theorem vsub_le_vsub_right : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí f‚ÇÅ -·µ• g ‚â§ f‚ÇÇ -·µ• g :=
  map‚ÇÇ_mono_right

@[simp]
theorem le_vsub_iff : h ‚â§ f -·µ• g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s -·µ• t ‚àà h :=
  le_map‚ÇÇ_iff

end Vsub

/-! ### Translation/scaling of filters -/


section SMul

variable [SMul Œ± Œ≤] {f f‚ÇÅ f‚ÇÇ : Filter Œ≤} {s : Set Œ≤} {a : Œ±}

/-- `a ‚Ä¢ f` is the map of `f` under `a ‚Ä¢` in scope `Pointwise`. -/
@[to_additive /-- `a +·µ• f` is the map of `f` under `a +·µ•` in scope `Pointwise`. -/]
protected def instSMulFilter : SMul Œ± (Filter Œ≤) :=
  ‚ü®fun a => map (a ‚Ä¢ ¬∑)‚ü©

scoped[Pointwise] attribute [instance] Filter.instSMulFilter Filter.instVAddFilter

@[to_additive (attr := simp)]
protected theorem map_smul : map (fun b => a ‚Ä¢ b) f = a ‚Ä¢ f :=
  rfl

@[to_additive]
theorem mem_smul_filter : s ‚àà a ‚Ä¢ f ‚Üî (a ‚Ä¢ ¬∑) ‚Åª¬π' s ‚àà f := Iff.rfl

@[to_additive]
theorem smul_set_mem_smul_filter : s ‚àà f ‚Üí a ‚Ä¢ s ‚àà a ‚Ä¢ f :=
  image_mem_map

@[to_additive (attr := simp)]
theorem smul_filter_bot : a ‚Ä¢ (‚ä• : Filter Œ≤) = ‚ä• :=
  map_bot

@[to_additive (attr := simp)]
theorem smul_filter_eq_bot_iff : a ‚Ä¢ f = ‚ä• ‚Üî f = ‚ä• :=
  map_eq_bot_iff

@[to_additive (attr := simp)]
theorem smul_filter_neBot_iff : (a ‚Ä¢ f).NeBot ‚Üî f.NeBot :=
  map_neBot_iff _

@[to_additive]
theorem NeBot.smul_filter : f.NeBot ‚Üí (a ‚Ä¢ f).NeBot := fun h => h.map _

@[to_additive]
theorem NeBot.of_smul_filter : (a ‚Ä¢ f).NeBot ‚Üí f.NeBot :=
  NeBot.of_map

@[to_additive vadd_filter.instNeBot]
lemma smul_filter.instNeBot [NeBot f] : NeBot (a ‚Ä¢ f) := .smul_filter ‚Äπ_‚Ä∫

scoped[Pointwise] attribute [instance] smul_filter.instNeBot vadd_filter.instNeBot

@[to_additive]
theorem smul_filter_le_smul_filter (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : a ‚Ä¢ f‚ÇÅ ‚â§ a ‚Ä¢ f‚ÇÇ :=
  map_mono hf

@[to_additive]
instance covariant_smul_filter : CovariantClass Œ± (Filter Œ≤) (¬∑ ‚Ä¢ ¬∑) (¬∑ ‚â§ ¬∑) :=
  ‚ü®fun _ => @map_mono Œ≤ Œ≤ _‚ü©

end SMul

@[to_additive]
instance smulCommClass_filter [SMul Œ± Œ≥] [SMul Œ≤ Œ≥] [SMulCommClass Œ± Œ≤ Œ≥] :
    SMulCommClass Œ± Œ≤ (Filter Œ≥) :=
  ‚ü®fun _ _ _ => map_comm (funext <| smul_comm _ _) _‚ü©

@[to_additive]
instance smulCommClass_filter' [SMul Œ± Œ≥] [SMul Œ≤ Œ≥] [SMulCommClass Œ± Œ≤ Œ≥] :
    SMulCommClass Œ± (Filter Œ≤) (Filter Œ≥) :=
  ‚ü®fun a _ _ => map_map‚ÇÇ_distrib_right <| smul_comm a‚ü©

@[to_additive]
instance smulCommClass_filter'' [SMul Œ± Œ≥] [SMul Œ≤ Œ≥] [SMulCommClass Œ± Œ≤ Œ≥] :
    SMulCommClass (Filter Œ±) Œ≤ (Filter Œ≥) :=
  haveI := SMulCommClass.symm Œ± Œ≤ Œ≥
  SMulCommClass.symm _ _ _

@[to_additive]
instance smulCommClass [SMul Œ± Œ≥] [SMul Œ≤ Œ≥] [SMulCommClass Œ± Œ≤ Œ≥] :
    SMulCommClass (Filter Œ±) (Filter Œ≤) (Filter Œ≥) :=
  ‚ü®fun _ _ _ => map‚ÇÇ_left_comm smul_comm‚ü©

@[to_additive]
instance isScalarTower [SMul Œ± Œ≤] [SMul Œ± Œ≥] [SMul Œ≤ Œ≥] [IsScalarTower Œ± Œ≤ Œ≥] :
    IsScalarTower Œ± Œ≤ (Filter Œ≥) :=
  ‚ü®fun a b f => by simp only [‚Üê Filter.map_smul, map_map, smul_assoc]; rfl‚ü©

@[to_additive]
instance isScalarTower' [SMul Œ± Œ≤] [SMul Œ± Œ≥] [SMul Œ≤ Œ≥] [IsScalarTower Œ± Œ≤ Œ≥] :
    IsScalarTower Œ± (Filter Œ≤) (Filter Œ≥) :=
  ‚ü®fun a f g => by
    refine (map_map‚ÇÇ_distrib_left fun _ _ => ?_).symm
    exact (smul_assoc a _ _).symm‚ü©

@[to_additive]
instance isScalarTower'' [SMul Œ± Œ≤] [SMul Œ± Œ≥] [SMul Œ≤ Œ≥] [IsScalarTower Œ± Œ≤ Œ≥] :
    IsScalarTower (Filter Œ±) (Filter Œ≤) (Filter Œ≥) :=
  ‚ü®fun _ _ _ => map‚ÇÇ_assoc smul_assoc‚ü©

@[to_additive]
instance isCentralScalar [SMul Œ± Œ≤] [SMul Œ±·µê·µí·µñ Œ≤] [IsCentralScalar Œ± Œ≤] :
    IsCentralScalar Œ± (Filter Œ≤) :=
  ‚ü®fun _ f => (congr_arg fun m => map m f) <| funext fun _ => op_smul_eq_smul _ _‚ü©

/-- A multiplicative action of a monoid `Œ±` on a type `Œ≤` gives a multiplicative action of
`Filter Œ±` on `Filter Œ≤`. -/
@[to_additive /-- An additive action of an additive monoid `Œ±` on a type `Œ≤` gives an additive
action of `Filter Œ±` on `Filter Œ≤`. -/]
protected def mulAction [Monoid Œ±] [MulAction Œ± Œ≤] : MulAction (Filter Œ±) (Filter Œ≤) where
  one_smul f := map‚ÇÇ_pure_left.trans <| by simp_rw [one_smul, map_id']
  mul_smul _ _ _ := map‚ÇÇ_assoc mul_smul

/-- A multiplicative action of a monoid on a type `Œ≤` gives a multiplicative action on `Filter Œ≤`.
-/
@[to_additive /-- An additive action of an additive monoid on a type `Œ≤` gives an additive action on
`Filter Œ≤`. -/]
protected def mulActionFilter [Monoid Œ±] [MulAction Œ± Œ≤] : MulAction Œ± (Filter Œ≤) where
  mul_smul a b f := by simp only [‚Üê Filter.map_smul, map_map, Function.comp_def, ‚Üê mul_smul]
  one_smul f := by simp only [‚Üê Filter.map_smul, one_smul, map_id']

scoped[Pointwise] attribute [instance] Filter.mulAction Filter.addAction Filter.mulActionFilter
  Filter.addActionFilter

/-- A distributive multiplicative action of a monoid on an additive monoid `Œ≤` gives a distributive
multiplicative action on `Filter Œ≤`. -/
protected def distribMulActionFilter [Monoid Œ±] [AddMonoid Œ≤] [DistribMulAction Œ± Œ≤] :
    DistribMulAction Œ± (Filter Œ≤) where
  smul_add _ _ _ := map_map‚ÇÇ_distrib <| smul_add _
  smul_zero _ := (map_pure _ _).trans <| by rw [smul_zero, pure_zero]

/-- A multiplicative action of a monoid on a monoid `Œ≤` gives a multiplicative action on `Set Œ≤`. -/
protected noncomputable def mulDistribMulActionFilter
    [Monoid Œ±] [Monoid Œ≤] [MulDistribMulAction Œ± Œ≤] : MulDistribMulAction Œ± (Set Œ≤) where
  smul_mul _ _ _ := image_image2_distrib <| smul_mul' _
  smul_one _ := image_singleton.trans <| by rw [smul_one, singleton_one]

scoped[Pointwise]
  attribute [instance] Filter.distribMulActionFilter Filter.mulDistribMulActionFilter

section SMulWithZero

variable [Zero Œ±] [Zero Œ≤] [SMulWithZero Œ± Œ≤] {f : Filter Œ±} {g : Filter Œ≤}

/-!
Note that we have neither `SMulWithZero Œ± (Filter Œ≤)` nor `SMulWithZero (Filter Œ±) (Filter Œ≤)`
because `0 * ‚ä• ‚â† 0`.
-/

theorem NeBot.smul_zero_nonneg (hf : f.NeBot) : 0 ‚â§ f ‚Ä¢ (0 : Filter Œ≤) :=
  le_smul_iff.2 fun _ h‚ÇÅ _ h‚ÇÇ =>
    let ‚ü®_, ha‚ü© := hf.nonempty_of_mem h‚ÇÅ
    ‚ü®_, ha, _, h‚ÇÇ, smul_zero _‚ü©

theorem NeBot.zero_smul_nonneg (hg : g.NeBot) : 0 ‚â§ (0 : Filter Œ±) ‚Ä¢ g :=
  le_smul_iff.2 fun _ h‚ÇÅ _ h‚ÇÇ =>
    let ‚ü®_, hb‚ü© := hg.nonempty_of_mem h‚ÇÇ
    ‚ü®_, h‚ÇÅ, _, hb, zero_smul _ _‚ü©

theorem zero_smul_filter_nonpos : (0 : Œ±) ‚Ä¢ g ‚â§ 0 := by
  refine fun s hs => mem_smul_filter.2 ?_
  convert @univ_mem _ g
  refine eq_univ_iff_forall.2 fun a => ?_
  rwa [mem_preimage, zero_smul]

theorem zero_smul_filter (hg : g.NeBot) : (0 : Œ±) ‚Ä¢ g = 0 :=
  zero_smul_filter_nonpos.antisymm <|
    le_map_iff.2 fun s hs => by
      simp_rw [zero_smul, (hg.nonempty_of_mem hs).image_const]
      exact zero_mem_zero

end SMulWithZero

section Cancel

@[to_additive]
theorem _root_.IsUnit.smul_tendsto_smul_iff [Monoid Œ≥] [MulAction Œ≥ Œ≤] {m : Œ± ‚Üí Œ≤} {c : Œ≥}
    {f : Filter Œ±} {g : Filter Œ≤} (hc : IsUnit c) :
    Tendsto (c ‚Ä¢ m) f (c ‚Ä¢ g) ‚Üî Tendsto m f g := by
  rcases hc.exists_left_inv with ‚ü®d, hd‚ü©
  refine ‚ü®fun H ‚Ü¶ ?_, fun H ‚Ü¶ tendsto_map.comp H‚ü©
  simpa [Function.comp_def, smul_smul, hd] using (tendsto_map (f := (d ‚Ä¢ ¬∑))).comp H

@[to_additive (attr := simp)]
theorem smul_tendsto_smul_iff [Group Œ≥] [MulAction Œ≥ Œ≤] {m : Œ± ‚Üí Œ≤} {c : Œ≥} {f : Filter Œ±}
    {g : Filter Œ≤} : Tendsto (c ‚Ä¢ m) f (c ‚Ä¢ g) ‚Üî Tendsto m f g :=
  Group.isUnit _ |>.smul_tendsto_smul_iff

theorem smul_tendsto_smul_iff‚ÇÄ [GroupWithZero Œ≥] [MulAction Œ≥ Œ≤] {m : Œ± ‚Üí Œ≤} {c : Œ≥} {f : Filter Œ±}
    {g : Filter Œ≤} (hc : c ‚â† 0) : Tendsto (c ‚Ä¢ m) f (c ‚Ä¢ g) ‚Üî Tendsto m f g :=
  hc.isUnit.smul_tendsto_smul_iff

end Cancel

end Filter
