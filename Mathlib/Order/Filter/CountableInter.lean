/-
Copyright (c) 2020 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov
-/
import Mathlib.Order.Filter.Curry
import Mathlib.Data.Set.Countable

/-!
# Filters with countable intersection property

In this file we define `CountableInterFilter` to be the class of filters with the following
property: for any countable collection of sets `s ‚àà l` their intersection belongs to `l` as well.

Two main examples are the `residual` filter defined in `Mathlib.Topology.GDelta` and
the `MeasureTheory.ae` filter defined in `Mathlib/MeasureTheory.OuterMeasure/AE`.

We reformulate the definition in terms of indexed intersection and in terms of `Filter.Eventually`
and provide instances for some basic constructions (`‚ä•`, `‚ä§`, `Filter.principal`, `Filter.map`,
`Filter.comap`, `Inf.inf`). We also provide a custom constructor `Filter.ofCountableInter`
that deduces two axioms of a `Filter` from the countable intersection property.

Note that there also exists a typeclass `CardinalInterFilter`, and thus an alternative spelling of
`CountableInterFilter` as `CardinalInterFilter l ‚Ñµ‚ÇÅ`. The former (defined here) is the
preferred spelling; it has the advantage of not requiring the user to import the theory of ordinals.

## Tags
filter, countable
-/


open Set Filter

open Filter

variable {Œπ : Sort*} {Œ± Œ≤ : Type*}

/-- A filter `l` has the countable intersection property if for any countable collection
of sets `s ‚àà l` their intersection belongs to `l` as well. -/
class CountableInterFilter (l : Filter Œ±) : Prop where
  /-- For a countable collection of sets `s ‚àà l`, their intersection belongs to `l` as well. -/
  countable_sInter_mem : ‚àÄ S : Set (Set Œ±), S.Countable ‚Üí (‚àÄ s ‚àà S, s ‚àà l) ‚Üí ‚ãÇ‚ÇÄ S ‚àà l

variable {l : Filter Œ±} [CountableInterFilter l]

theorem countable_sInter_mem {S : Set (Set Œ±)} (hSc : S.Countable) : ‚ãÇ‚ÇÄ S ‚àà l ‚Üî ‚àÄ s ‚àà S, s ‚àà l :=
  ‚ü®fun hS _s hs => mem_of_superset hS (sInter_subset_of_mem hs),
    CountableInterFilter.countable_sInter_mem _ hSc‚ü©

theorem countable_iInter_mem [Countable Œπ] {s : Œπ ‚Üí Set Œ±} : (‚ãÇ i, s i) ‚àà l ‚Üî ‚àÄ i, s i ‚àà l :=
  sInter_range s ‚ñ∏ (countable_sInter_mem (countable_range _)).trans forall_mem_range

theorem countable_bInter_mem {Œπ : Type*} {S : Set Œπ} (hS : S.Countable) {s : ‚àÄ i ‚àà S, Set Œ±} :
    (‚ãÇ i, ‚ãÇ hi : i ‚àà S, s i ‚Äπ_‚Ä∫) ‚àà l ‚Üî ‚àÄ i, ‚àÄ hi : i ‚àà S, s i ‚Äπ_‚Ä∫ ‚àà l := by
  rw [biInter_eq_iInter]
  haveI := hS.toEncodable
  exact countable_iInter_mem.trans Subtype.forall

theorem eventually_countable_forall [Countable Œπ] {p : Œ± ‚Üí Œπ ‚Üí Prop} :
    (‚àÄ·∂† x in l, ‚àÄ i, p x i) ‚Üî ‚àÄ i, ‚àÄ·∂† x in l, p x i := by
  simpa only [Filter.Eventually, setOf_forall] using
    @countable_iInter_mem _ _ l _ _ fun i => { x | p x i }

theorem eventually_countable_ball {Œπ : Type*} {S : Set Œπ} (hS : S.Countable)
    {p : Œ± ‚Üí ‚àÄ i ‚àà S, Prop} :
    (‚àÄ·∂† x in l, ‚àÄ i hi, p x i hi) ‚Üî ‚àÄ i hi, ‚àÄ·∂† x in l, p x i hi := by
  simpa only [Filter.Eventually, setOf_forall] using
    @countable_bInter_mem _ l _ _ _ hS fun i hi => { x | p x i hi }

theorem EventuallyLE.countable_iUnion [Countable Œπ] {s t : Œπ ‚Üí Set Œ±} (h : ‚àÄ i, s i ‚â§·∂†[l] t i) :
    ‚ãÉ i, s i ‚â§·∂†[l] ‚ãÉ i, t i :=
  (eventually_countable_forall.2 h).mono fun _ hst hs => mem_iUnion.2 <| (mem_iUnion.1 hs).imp hst

theorem EventuallyEq.countable_iUnion [Countable Œπ] {s t : Œπ ‚Üí Set Œ±} (h : ‚àÄ i, s i =·∂†[l] t i) :
    ‚ãÉ i, s i =·∂†[l] ‚ãÉ i, t i :=
  (EventuallyLE.countable_iUnion fun i => (h i).le).antisymm
    (EventuallyLE.countable_iUnion fun i => (h i).symm.le)

theorem EventuallyLE.countable_bUnion {Œπ : Type*} {S : Set Œπ} (hS : S.Countable)
    {s t : ‚àÄ i ‚àà S, Set Œ±} (h : ‚àÄ i hi, s i hi ‚â§·∂†[l] t i hi) :
    ‚ãÉ i ‚àà S, s i ‚Äπ_‚Ä∫ ‚â§·∂†[l] ‚ãÉ i ‚àà S, t i ‚Äπ_‚Ä∫ := by
  simp only [biUnion_eq_iUnion]
  haveI := hS.toEncodable
  exact EventuallyLE.countable_iUnion fun i => h i i.2

theorem EventuallyEq.countable_bUnion {Œπ : Type*} {S : Set Œπ} (hS : S.Countable)
    {s t : ‚àÄ i ‚àà S, Set Œ±} (h : ‚àÄ i hi, s i hi =·∂†[l] t i hi) :
    ‚ãÉ i ‚àà S, s i ‚Äπ_‚Ä∫ =·∂†[l] ‚ãÉ i ‚àà S, t i ‚Äπ_‚Ä∫ :=
  (EventuallyLE.countable_bUnion hS fun i hi => (h i hi).le).antisymm
    (EventuallyLE.countable_bUnion hS fun i hi => (h i hi).symm.le)

theorem EventuallyLE.countable_iInter [Countable Œπ] {s t : Œπ ‚Üí Set Œ±} (h : ‚àÄ i, s i ‚â§·∂†[l] t i) :
    ‚ãÇ i, s i ‚â§·∂†[l] ‚ãÇ i, t i :=
  (eventually_countable_forall.2 h).mono fun _ hst hs =>
    mem_iInter.2 fun i => hst _ (mem_iInter.1 hs i)

theorem EventuallyEq.countable_iInter [Countable Œπ] {s t : Œπ ‚Üí Set Œ±} (h : ‚àÄ i, s i =·∂†[l] t i) :
    ‚ãÇ i, s i =·∂†[l] ‚ãÇ i, t i :=
  (EventuallyLE.countable_iInter fun i => (h i).le).antisymm
    (EventuallyLE.countable_iInter fun i => (h i).symm.le)

theorem EventuallyLE.countable_bInter {Œπ : Type*} {S : Set Œπ} (hS : S.Countable)
    {s t : ‚àÄ i ‚àà S, Set Œ±} (h : ‚àÄ i hi, s i hi ‚â§·∂†[l] t i hi) :
    ‚ãÇ i ‚àà S, s i ‚Äπ_‚Ä∫ ‚â§·∂†[l] ‚ãÇ i ‚àà S, t i ‚Äπ_‚Ä∫ := by
  simp only [biInter_eq_iInter]
  haveI := hS.toEncodable
  exact EventuallyLE.countable_iInter fun i => h i i.2

theorem EventuallyEq.countable_bInter {Œπ : Type*} {S : Set Œπ} (hS : S.Countable)
    {s t : ‚àÄ i ‚àà S, Set Œ±} (h : ‚àÄ i hi, s i hi =·∂†[l] t i hi) :
    ‚ãÇ i ‚àà S, s i ‚Äπ_‚Ä∫ =·∂†[l] ‚ãÇ i ‚àà S, t i ‚Äπ_‚Ä∫ :=
  (EventuallyLE.countable_bInter hS fun i hi => (h i hi).le).antisymm
    (EventuallyLE.countable_bInter hS fun i hi => (h i hi).symm.le)

/-- Construct a filter with countable intersection property. This constructor deduces
`Filter.univ_sets` and `Filter.inter_sets` from the countable intersection property. -/
def Filter.ofCountableInter (l : Set (Set Œ±))
    (hl : ‚àÄ S : Set (Set Œ±), S.Countable ‚Üí S ‚äÜ l ‚Üí ‚ãÇ‚ÇÄ S ‚àà l)
    (h_mono : ‚àÄ s t, s ‚àà l ‚Üí s ‚äÜ t ‚Üí t ‚àà l) : Filter Œ± where
  sets := l
  univ_sets := @sInter_empty Œ± ‚ñ∏ hl _ countable_empty (empty_subset _)
  sets_of_superset := h_mono _ _
  inter_sets {s t} hs ht := sInter_pair s t ‚ñ∏
    hl _ ((countable_singleton _).insert _) (insert_subset_iff.2 ‚ü®hs, singleton_subset_iff.2 ht‚ü©)

instance Filter.countableInter_ofCountableInter (l : Set (Set Œ±))
    (hl : ‚àÄ S : Set (Set Œ±), S.Countable ‚Üí S ‚äÜ l ‚Üí ‚ãÇ‚ÇÄ S ‚àà l)
    (h_mono : ‚àÄ s t, s ‚àà l ‚Üí s ‚äÜ t ‚Üí t ‚àà l) :
    CountableInterFilter (Filter.ofCountableInter l hl h_mono) :=
  ‚ü®hl‚ü©

@[simp]
theorem Filter.mem_ofCountableInter {l : Set (Set Œ±)}
    (hl : ‚àÄ S : Set (Set Œ±), S.Countable ‚Üí S ‚äÜ l ‚Üí ‚ãÇ‚ÇÄ S ‚àà l) (h_mono : ‚àÄ s t, s ‚àà l ‚Üí s ‚äÜ t ‚Üí t ‚àà l)
    {s : Set Œ±} : s ‚àà Filter.ofCountableInter l hl h_mono ‚Üî s ‚àà l :=
  Iff.rfl

/-- Construct a filter with countable intersection property.
Similarly to `Filter.comk`, a set belongs to this filter if its complement satisfies the property.
Similarly to `Filter.ofCountableInter`,
this constructor deduces some properties from the countable intersection property
which becomes the countable union property because we take complements of all sets. -/
def Filter.ofCountableUnion (l : Set (Set Œ±))
    (hUnion : ‚àÄ S : Set (Set Œ±), S.Countable ‚Üí (‚àÄ s ‚àà S, s ‚àà l) ‚Üí ‚ãÉ‚ÇÄ S ‚àà l)
    (hmono : ‚àÄ t ‚àà l, ‚àÄ s ‚äÜ t, s ‚àà l) : Filter Œ± := by
  refine .ofCountableInter {s | s·∂ú ‚àà l} (fun S hSc hSp ‚Ü¶ ?_) fun s t ht hsub ‚Ü¶ ?_
  ¬∑ rw [mem_setOf_eq, compl_sInter]
    apply hUnion (compl '' S) (hSc.image _)
    intro s hs
    rw [mem_image] at hs
    rcases hs with ‚ü®t, ht, rfl‚ü©
    apply hSp ht
  ¬∑ rw [mem_setOf_eq]
    rw [‚Üê compl_subset_compl] at hsub
    exact hmono s·∂ú ht t·∂ú hsub

instance Filter.countableInter_ofCountableUnion (l : Set (Set Œ±)) (h‚ÇÅ h‚ÇÇ) :
    CountableInterFilter (Filter.ofCountableUnion l h‚ÇÅ h‚ÇÇ) :=
  countableInter_ofCountableInter ..

@[simp]
theorem Filter.mem_ofCountableUnion {l : Set (Set Œ±)} {hunion hmono s} :
    s ‚àà ofCountableUnion l hunion hmono ‚Üî l s·∂ú :=
  Iff.rfl

instance countableInterFilter_principal (s : Set Œ±) : CountableInterFilter (ùìü s) :=
  ‚ü®fun _ _ hS => subset_sInter hS‚ü©

instance countableInterFilter_bot : CountableInterFilter (‚ä• : Filter Œ±) := by
  rw [‚Üê principal_empty]
  apply countableInterFilter_principal

instance countableInterFilter_top : CountableInterFilter (‚ä§ : Filter Œ±) := by
  rw [‚Üê principal_univ]
  apply countableInterFilter_principal

instance (l : Filter Œ≤) [CountableInterFilter l] (f : Œ± ‚Üí Œ≤) :
    CountableInterFilter (comap f l) := by
  refine ‚ü®fun S hSc hS => ?_‚ü©
  choose! t htl ht using hS
  have : (‚ãÇ s ‚àà S, t s) ‚àà l := (countable_bInter_mem hSc).2 htl
  refine ‚ü®_, this, ?_‚ü©
  simpa [preimage_iInter] using iInter‚ÇÇ_mono ht

instance (l : Filter Œ±) [CountableInterFilter l] (f : Œ± ‚Üí Œ≤) : CountableInterFilter (map f l) := by
  refine ‚ü®fun S hSc hS => ?_‚ü©
  simp only [mem_map, sInter_eq_biInter, preimage_iInter‚ÇÇ] at hS ‚ä¢
  exact (countable_bInter_mem hSc).2 hS

/-- Infimum of two `CountableInterFilter`s is a `CountableInterFilter`. This is useful, e.g.,
to automatically get an instance for `residual Œ± ‚äì ùìü s`. -/
instance countableInterFilter_inf (l‚ÇÅ l‚ÇÇ : Filter Œ±) [CountableInterFilter l‚ÇÅ]
    [CountableInterFilter l‚ÇÇ] : CountableInterFilter (l‚ÇÅ ‚äì l‚ÇÇ) := by
  refine ‚ü®fun S hSc hS => ?_‚ü©
  choose s hs t ht hst using hS
  replace hs : (‚ãÇ i ‚àà S, s i ‚Äπ_‚Ä∫) ‚àà l‚ÇÅ := (countable_bInter_mem hSc).2 hs
  replace ht : (‚ãÇ i ‚àà S, t i ‚Äπ_‚Ä∫) ‚àà l‚ÇÇ := (countable_bInter_mem hSc).2 ht
  refine mem_of_superset (inter_mem_inf hs ht) (subset_sInter fun i hi => ?_)
  rw [hst i hi]
  apply inter_subset_inter <;> exact iInter_subset_of_subset i (iInter_subset _ _)

/-- Supremum of two `CountableInterFilter`s is a `CountableInterFilter`. -/
instance countableInterFilter_sup (l‚ÇÅ l‚ÇÇ : Filter Œ±) [CountableInterFilter l‚ÇÅ]
    [CountableInterFilter l‚ÇÇ] : CountableInterFilter (l‚ÇÅ ‚äî l‚ÇÇ) := by
  refine ‚ü®fun S hSc hS => ‚ü®?_, ?_‚ü©‚ü© <;> refine (countable_sInter_mem hSc).2 fun s hs => ?_
  exacts [(hS s hs).1, (hS s hs).2]

instance CountableInterFilter.curry {Œ± Œ≤ : Type*} {l : Filter Œ±} {m : Filter Œ≤}
    [CountableInterFilter l] [CountableInterFilter m] : CountableInterFilter (l.curry m) := ‚ü®by
  intro S Sct hS
  simp_rw [mem_curry_iff, mem_sInter, eventually_countable_ball (p := fun _ _ _ => (_ ,_) ‚àà _) Sct,
    eventually_countable_ball (p := fun _ _ _ => ‚àÄ·∂† (_ : Œ≤) in m, _)  Sct, ‚Üê mem_curry_iff]
  exact hS‚ü©

namespace Filter

variable (g : Set (Set Œ±))

/-- `Filter.CountableGenerateSets g` is the (sets of the)
greatest `countableInterFilter` containing `g`. -/
inductive CountableGenerateSets : Set Œ± ‚Üí Prop
  | basic {s : Set Œ±} : s ‚àà g ‚Üí CountableGenerateSets s
  | univ : CountableGenerateSets univ
  | superset {s t : Set Œ±} : CountableGenerateSets s ‚Üí s ‚äÜ t ‚Üí CountableGenerateSets t
  | sInter {S : Set (Set Œ±)} :
    S.Countable ‚Üí (‚àÄ s ‚àà S, CountableGenerateSets s) ‚Üí CountableGenerateSets (‚ãÇ‚ÇÄ S)

/-- `Filter.countableGenerate g` is the greatest `countableInterFilter` containing `g`. -/
def countableGenerate : Filter Œ± :=
  ofCountableInter (CountableGenerateSets g) (fun _ => CountableGenerateSets.sInter) fun _ _ =>
    CountableGenerateSets.superset
  --deriving CountableInterFilter

-- Porting note: could not de derived
instance : CountableInterFilter (countableGenerate g) := by
  delta countableGenerate; infer_instance

variable {g}

/-- A set is in the `countableInterFilter` generated by `g` if and only if
it contains a countable intersection of elements of `g`. -/
theorem mem_countableGenerate_iff {s : Set Œ±} :
    s ‚àà countableGenerate g ‚Üî ‚àÉ S : Set (Set Œ±), S ‚äÜ g ‚àß S.Countable ‚àß ‚ãÇ‚ÇÄ S ‚äÜ s := by
  constructor <;> intro h
  ¬∑ induction h with
    | @basic s hs => exact ‚ü®{s}, by simp [hs, subset_refl]‚ü©
    | univ => exact ‚ü®‚àÖ, by simp‚ü©
    | superset _ _ ih => refine Exists.imp (fun S => ?_) ih; tauto
    | @sInter S Sct _ ih =>
      choose T Tg Tct hT using ih
      refine ‚ü®‚ãÉ (s) (H : s ‚àà S), T s H, by simpa, Sct.biUnion Tct, ?_‚ü©
      apply subset_sInter
      intro s H
      exact subset_trans (sInter_subset_sInter (subset_iUnion‚ÇÇ s H)) (hT s H)
  rcases h with ‚ü®S, Sg, Sct, hS‚ü©
  refine mem_of_superset ((countable_sInter_mem Sct).mpr ?_) hS
  intro s H
  exact CountableGenerateSets.basic (Sg H)

theorem le_countableGenerate_iff_of_countableInterFilter {f : Filter Œ±} [CountableInterFilter f] :
    f ‚â§ countableGenerate g ‚Üî g ‚äÜ f.sets := by
  constructor <;> intro h
  ¬∑ exact subset_trans (fun s => CountableGenerateSets.basic) h
  intro s hs
  induction hs with
  | basic hs => exact h hs
  | univ => exact univ_mem
  | superset _ st ih => exact mem_of_superset ih st
  | sInter Sct _ ih => exact (countable_sInter_mem Sct).mpr ih

variable (g)

/-- `countableGenerate g` is the greatest `countableInterFilter` containing `g`. -/
theorem countableGenerate_isGreatest :
    IsGreatest { f : Filter Œ± | CountableInterFilter f ‚àß g ‚äÜ f.sets } (countableGenerate g) := by
  refine ‚ü®‚ü®inferInstance, fun s => CountableGenerateSets.basic‚ü©, ?_‚ü©
  rintro f ‚ü®fct, hf‚ü©
  rwa [@le_countableGenerate_iff_of_countableInterFilter _ _ _ fct]

end Filter
