/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Jeremy Avigad, Yury Kudryashov, Patrick Massot
-/
import Mathlib.Algebra.Order.Field.Basic
import Mathlib.Data.Finset.Preimage
import Mathlib.Data.Set.Intervals.Disjoint
import Mathlib.Data.Set.Intervals.OrderIso
import Mathlib.Order.Filter.Bases
import Mathlib.Order.ConditionallyCompleteLattice.Basic
import Mathlib.Algebra.Order.Group.MinMax
import Mathlib.Algebra.Order.Group.Instances

#align_import order.filter.at_top_bot from "leanprover-community/mathlib"@"1f0096e6caa61e9c849ec2adbd227e960e9dff58"

/-!
# `Filter.atTop` and `Filter.atBot` filters on preorded sets, monoids and groups.

In this file we define the filters

* `Filter.atTop`: corresponds to `n ‚Üí +‚àû`;
* `Filter.atBot`: corresponds to `n ‚Üí -‚àû`.

Then we prove many lemmas like ‚Äúif `f ‚Üí +‚àû`, then `f ¬± c ‚Üí +‚àû`‚Äù.
-/

set_option autoImplicit true

variable {Œπ Œπ' Œ± Œ≤ Œ≥ : Type*}

open Set

open BigOperators

namespace Filter

/-- `atTop` is the filter representing the limit `‚Üí ‚àû` on an ordered set.
  It is generated by the collection of up-sets `{b | a ‚â§ b}`.
  (The preorder need not have a top element for this to be well defined,
  and indeed is trivial when a top element exists.) -/
def atTop [Preorder Œ±] : Filter Œ± :=
  ‚®Ö a, ùìü (Ici a)
#align filter.at_top Filter.atTop

/-- `atBot` is the filter representing the limit `‚Üí -‚àû` on an ordered set.
  It is generated by the collection of down-sets `{b | b ‚â§ a}`.
  (The preorder need not have a bottom element for this to be well defined,
  and indeed is trivial when a bottom element exists.) -/
def atBot [Preorder Œ±] : Filter Œ± :=
  ‚®Ö a, ùìü (Iic a)
#align filter.at_bot Filter.atBot

theorem mem_atTop [Preorder Œ±] (a : Œ±) : { b : Œ± | a ‚â§ b } ‚àà @atTop Œ± _ :=
  mem_iInf_of_mem a <| Subset.refl _
#align filter.mem_at_top Filter.mem_atTop

theorem Ici_mem_atTop [Preorder Œ±] (a : Œ±) : Ici a ‚àà (atTop : Filter Œ±) :=
  mem_atTop a
#align filter.Ici_mem_at_top Filter.Ici_mem_atTop

theorem Ioi_mem_atTop [Preorder Œ±] [NoMaxOrder Œ±] (x : Œ±) : Ioi x ‚àà (atTop : Filter Œ±) :=
  let ‚ü®z, hz‚ü© := exists_gt x
  mem_of_superset (mem_atTop z) fun _ h => lt_of_lt_of_le hz h
#align filter.Ioi_mem_at_top Filter.Ioi_mem_atTop

theorem mem_atBot [Preorder Œ±] (a : Œ±) : { b : Œ± | b ‚â§ a } ‚àà @atBot Œ± _ :=
  mem_iInf_of_mem a <| Subset.refl _
#align filter.mem_at_bot Filter.mem_atBot

theorem Iic_mem_atBot [Preorder Œ±] (a : Œ±) : Iic a ‚àà (atBot : Filter Œ±) :=
  mem_atBot a
#align filter.Iic_mem_at_bot Filter.Iic_mem_atBot

theorem Iio_mem_atBot [Preorder Œ±] [NoMinOrder Œ±] (x : Œ±) : Iio x ‚àà (atBot : Filter Œ±) :=
  let ‚ü®z, hz‚ü© := exists_lt x
  mem_of_superset (mem_atBot z) fun _ h => lt_of_le_of_lt h hz
#align filter.Iio_mem_at_bot Filter.Iio_mem_atBot

theorem disjoint_atBot_principal_Ioi [Preorder Œ±] (x : Œ±) : Disjoint atBot (ùìü (Ioi x)) :=
  disjoint_of_disjoint_of_mem (Iic_disjoint_Ioi le_rfl) (Iic_mem_atBot x) (mem_principal_self _)
#align filter.disjoint_at_bot_principal_Ioi Filter.disjoint_atBot_principal_Ioi

theorem disjoint_atTop_principal_Iio [Preorder Œ±] (x : Œ±) : Disjoint atTop (ùìü (Iio x)) :=
  @disjoint_atBot_principal_Ioi Œ±·µí·µà _ _
#align filter.disjoint_at_top_principal_Iio Filter.disjoint_atTop_principal_Iio

theorem disjoint_atTop_principal_Iic [Preorder Œ±] [NoMaxOrder Œ±] (x : Œ±) :
    Disjoint atTop (ùìü (Iic x)) :=
  disjoint_of_disjoint_of_mem (Iic_disjoint_Ioi le_rfl).symm (Ioi_mem_atTop x)
    (mem_principal_self _)
#align filter.disjoint_at_top_principal_Iic Filter.disjoint_atTop_principal_Iic

theorem disjoint_atBot_principal_Ici [Preorder Œ±] [NoMinOrder Œ±] (x : Œ±) :
    Disjoint atBot (ùìü (Ici x)) :=
  @disjoint_atTop_principal_Iic Œ±·µí·µà _ _ _
#align filter.disjoint_at_bot_principal_Ici Filter.disjoint_atBot_principal_Ici

theorem disjoint_pure_atTop [Preorder Œ±] [NoMaxOrder Œ±] (x : Œ±) : Disjoint (pure x) atTop :=
  Disjoint.symm <| (disjoint_atTop_principal_Iic x).mono_right <| le_principal_iff.2 <|
    mem_pure.2 right_mem_Iic
#align filter.disjoint_pure_at_top Filter.disjoint_pure_atTop

theorem disjoint_pure_atBot [Preorder Œ±] [NoMinOrder Œ±] (x : Œ±) : Disjoint (pure x) atBot :=
  @disjoint_pure_atTop Œ±·µí·µà _ _ _
#align filter.disjoint_pure_at_bot Filter.disjoint_pure_atBot

theorem not_tendsto_const_atTop [Preorder Œ±] [NoMaxOrder Œ±] (x : Œ±) (l : Filter Œ≤) [l.NeBot] :
    ¬¨Tendsto (fun _ => x) l atTop :=
  tendsto_const_pure.not_tendsto (disjoint_pure_atTop x)
#align filter.not_tendsto_const_at_top Filter.not_tendsto_const_atTop

theorem not_tendsto_const_atBot [Preorder Œ±] [NoMinOrder Œ±] (x : Œ±) (l : Filter Œ≤) [l.NeBot] :
    ¬¨Tendsto (fun _ => x) l atBot :=
  tendsto_const_pure.not_tendsto (disjoint_pure_atBot x)
#align filter.not_tendsto_const_at_bot Filter.not_tendsto_const_atBot

theorem disjoint_atBot_atTop [PartialOrder Œ±] [Nontrivial Œ±] :
    Disjoint (atBot : Filter Œ±) atTop := by
  rcases exists_pair_ne Œ± with ‚ü®x, y, hne‚ü©
  by_cases hle : x ‚â§ y
  ¬∑ refine' disjoint_of_disjoint_of_mem _ (Iic_mem_atBot x) (Ici_mem_atTop y)
    exact Iic_disjoint_Ici.2 (hle.lt_of_ne hne).not_le
  ¬∑ refine' disjoint_of_disjoint_of_mem _ (Iic_mem_atBot y) (Ici_mem_atTop x)
    exact Iic_disjoint_Ici.2 hle
#align filter.disjoint_at_bot_at_top Filter.disjoint_atBot_atTop

theorem disjoint_atTop_atBot [PartialOrder Œ±] [Nontrivial Œ±] : Disjoint (atTop : Filter Œ±) atBot :=
  disjoint_atBot_atTop.symm
#align filter.disjoint_at_top_at_bot Filter.disjoint_atTop_atBot

theorem hasAntitoneBasis_atTop [Nonempty Œ±] [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â§ ¬∑)] :
    (@atTop Œ± _).HasAntitoneBasis Ici :=
  .iInf_principal fun _ _ ‚Ü¶ Ici_subset_Ici.2

theorem atTop_basis [Nonempty Œ±] [SemilatticeSup Œ±] : (@atTop Œ± _).HasBasis (fun _ => True) Ici :=
  hasAntitoneBasis_atTop.1
#align filter.at_top_basis Filter.atTop_basis

theorem atTop_eq_generate_Ici [SemilatticeSup Œ±] : atTop = generate (range (Ici (Œ± := Œ±))) := by
  rcases isEmpty_or_nonempty Œ± with hŒ±|hŒ±
  ¬∑ simp only [eq_iff_true_of_subsingleton]
  ¬∑ simp [(atTop_basis (Œ± := Œ±)).eq_generate, range]

theorem atTop_basis' [SemilatticeSup Œ±] (a : Œ±) : (@atTop Œ± _).HasBasis (fun x => a ‚â§ x) Ici :=
  ‚ü®fun _ =>
    (@atTop_basis Œ± ‚ü®a‚ü© _).mem_iff.trans
      ‚ü®fun ‚ü®x, _, hx‚ü© => ‚ü®x ‚äî a, le_sup_right, fun _y hy => hx (le_trans le_sup_left hy)‚ü©,
        fun ‚ü®x, _, hx‚ü© => ‚ü®x, trivial, hx‚ü©‚ü©‚ü©
#align filter.at_top_basis' Filter.atTop_basis'

theorem atBot_basis [Nonempty Œ±] [SemilatticeInf Œ±] : (@atBot Œ± _).HasBasis (fun _ => True) Iic :=
  @atTop_basis Œ±·µí·µà _ _
#align filter.at_bot_basis Filter.atBot_basis

theorem atBot_basis' [SemilatticeInf Œ±] (a : Œ±) : (@atBot Œ± _).HasBasis (fun x => x ‚â§ a) Iic :=
  @atTop_basis' Œ±·µí·µà _ _
#align filter.at_bot_basis' Filter.atBot_basis'

@[instance]
theorem atTop_neBot [Nonempty Œ±] [SemilatticeSup Œ±] : NeBot (atTop : Filter Œ±) :=
  atTop_basis.neBot_iff.2 fun _ => nonempty_Ici
#align filter.at_top_ne_bot Filter.atTop_neBot

@[instance]
theorem atBot_neBot [Nonempty Œ±] [SemilatticeInf Œ±] : NeBot (atBot : Filter Œ±) :=
  @atTop_neBot Œ±·µí·µà _ _
#align filter.at_bot_ne_bot Filter.atBot_neBot

@[simp]
theorem mem_atTop_sets [Nonempty Œ±] [SemilatticeSup Œ±] {s : Set Œ±} :
    s ‚àà (atTop : Filter Œ±) ‚Üî ‚àÉ a : Œ±, ‚àÄ b ‚â• a, b ‚àà s :=
  atTop_basis.mem_iff.trans <| exists_congr fun _ => true_and_iff _
#align filter.mem_at_top_sets Filter.mem_atTop_sets

@[simp]
theorem mem_atBot_sets [Nonempty Œ±] [SemilatticeInf Œ±] {s : Set Œ±} :
    s ‚àà (atBot : Filter Œ±) ‚Üî ‚àÉ a : Œ±, ‚àÄ b ‚â§ a, b ‚àà s :=
  @mem_atTop_sets Œ±·µí·µà _ _ _
#align filter.mem_at_bot_sets Filter.mem_atBot_sets

@[simp]
theorem eventually_atTop [SemilatticeSup Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop} :
    (‚àÄ·∂† x in atTop, p x) ‚Üî ‚àÉ a, ‚àÄ b ‚â• a, p b :=
  mem_atTop_sets
#align filter.eventually_at_top Filter.eventually_atTop

@[simp]
theorem eventually_atBot [SemilatticeInf Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop} :
    (‚àÄ·∂† x in atBot, p x) ‚Üî ‚àÉ a, ‚àÄ b ‚â§ a, p b :=
  mem_atBot_sets
#align filter.eventually_at_bot Filter.eventually_atBot

theorem eventually_ge_atTop [Preorder Œ±] (a : Œ±) : ‚àÄ·∂† x in atTop, a ‚â§ x :=
  mem_atTop a
#align filter.eventually_ge_at_top Filter.eventually_ge_atTop

theorem eventually_le_atBot [Preorder Œ±] (a : Œ±) : ‚àÄ·∂† x in atBot, x ‚â§ a :=
  mem_atBot a
#align filter.eventually_le_at_bot Filter.eventually_le_atBot

theorem eventually_gt_atTop [Preorder Œ±] [NoMaxOrder Œ±] (a : Œ±) : ‚àÄ·∂† x in atTop, a < x :=
  Ioi_mem_atTop a
#align filter.eventually_gt_at_top Filter.eventually_gt_atTop

theorem eventually_ne_atTop [Preorder Œ±] [NoMaxOrder Œ±] (a : Œ±) : ‚àÄ·∂† x in atTop, x ‚â† a :=
  (eventually_gt_atTop a).mono fun _ => ne_of_gt
#align filter.eventually_ne_at_top Filter.eventually_ne_atTop

protected theorem Tendsto.eventually_gt_atTop [Preorder Œ≤] [NoMaxOrder Œ≤] {f : Œ± ‚Üí Œ≤} {l : Filter Œ±}
    (hf : Tendsto f l atTop) (c : Œ≤) : ‚àÄ·∂† x in l, c < f x :=
  hf.eventually (eventually_gt_atTop c)
#align filter.tendsto.eventually_gt_at_top Filter.Tendsto.eventually_gt_atTop

protected theorem Tendsto.eventually_ge_atTop [Preorder Œ≤] {f : Œ± ‚Üí Œ≤} {l : Filter Œ±}
    (hf : Tendsto f l atTop) (c : Œ≤) : ‚àÄ·∂† x in l, c ‚â§ f x :=
  hf.eventually (eventually_ge_atTop c)
#align filter.tendsto.eventually_ge_at_top Filter.Tendsto.eventually_ge_atTop

protected theorem Tendsto.eventually_ne_atTop [Preorder Œ≤] [NoMaxOrder Œ≤] {f : Œ± ‚Üí Œ≤} {l : Filter Œ±}
    (hf : Tendsto f l atTop) (c : Œ≤) : ‚àÄ·∂† x in l, f x ‚â† c :=
  hf.eventually (eventually_ne_atTop c)
#align filter.tendsto.eventually_ne_at_top Filter.Tendsto.eventually_ne_atTop

protected theorem Tendsto.eventually_ne_atTop' [Preorder Œ≤] [NoMaxOrder Œ≤] {f : Œ± ‚Üí Œ≤}
    {l : Filter Œ±} (hf : Tendsto f l atTop) (c : Œ±) : ‚àÄ·∂† x in l, x ‚â† c :=
  (hf.eventually_ne_atTop (f c)).mono fun _ => ne_of_apply_ne f
#align filter.tendsto.eventually_ne_at_top' Filter.Tendsto.eventually_ne_atTop'

theorem eventually_lt_atBot [Preorder Œ±] [NoMinOrder Œ±] (a : Œ±) : ‚àÄ·∂† x in atBot, x < a :=
  Iio_mem_atBot a
#align filter.eventually_lt_at_bot Filter.eventually_lt_atBot

theorem eventually_ne_atBot [Preorder Œ±] [NoMinOrder Œ±] (a : Œ±) : ‚àÄ·∂† x in atBot, x ‚â† a :=
  (eventually_lt_atBot a).mono fun _ => ne_of_lt
#align filter.eventually_ne_at_bot Filter.eventually_ne_atBot

protected theorem Tendsto.eventually_lt_atBot [Preorder Œ≤] [NoMinOrder Œ≤] {f : Œ± ‚Üí Œ≤} {l : Filter Œ±}
    (hf : Tendsto f l atBot) (c : Œ≤) : ‚àÄ·∂† x in l, f x < c :=
  hf.eventually (eventually_lt_atBot c)
#align filter.tendsto.eventually_lt_at_bot Filter.Tendsto.eventually_lt_atBot

protected theorem Tendsto.eventually_le_atBot [Preorder Œ≤] {f : Œ± ‚Üí Œ≤} {l : Filter Œ±}
    (hf : Tendsto f l atBot) (c : Œ≤) : ‚àÄ·∂† x in l, f x ‚â§ c :=
  hf.eventually (eventually_le_atBot c)
#align filter.tendsto.eventually_le_at_bot Filter.Tendsto.eventually_le_atBot

protected theorem Tendsto.eventually_ne_atBot [Preorder Œ≤] [NoMinOrder Œ≤] {f : Œ± ‚Üí Œ≤} {l : Filter Œ±}
    (hf : Tendsto f l atBot) (c : Œ≤) : ‚àÄ·∂† x in l, f x ‚â† c :=
  hf.eventually (eventually_ne_atBot c)
#align filter.tendsto.eventually_ne_at_bot Filter.Tendsto.eventually_ne_atBot

theorem eventually_forall_ge_atTop [Preorder Œ±] {p : Œ± ‚Üí Prop} :
    (‚àÄ·∂† x in atTop, ‚àÄ y, x ‚â§ y ‚Üí p y) ‚Üî ‚àÄ·∂† x in atTop, p x := by
  refine ‚ü®fun h ‚Ü¶ h.mono fun x hx ‚Ü¶ hx x le_rfl, fun h ‚Ü¶ ?_‚ü©
  rcases (hasBasis_iInf_principal_finite _).eventually_iff.1 h with ‚ü®S, hSf, hS‚ü©
  refine mem_iInf_of_iInter hSf (V := fun x ‚Ü¶ Ici x.1) (fun _ ‚Ü¶ Subset.rfl) fun x hx y hy ‚Ü¶ ?_
  simp only [mem_iInter] at hS hx
  exact hS fun z hz ‚Ü¶ le_trans (hx ‚ü®z, hz‚ü©) hy

theorem eventually_forall_le_atBot [Preorder Œ±] {p : Œ± ‚Üí Prop} :
    (‚àÄ·∂† x in atBot, ‚àÄ y, y ‚â§ x ‚Üí p y) ‚Üî ‚àÄ·∂† x in atBot, p x :=
  eventually_forall_ge_atTop (Œ± := Œ±·µí·µà)

theorem Tendsto.eventually_forall_ge_atTop {Œ± Œ≤ : Type*} [Preorder Œ≤] {l : Filter Œ±}
    {p : Œ≤ ‚Üí Prop} {f : Œ± ‚Üí Œ≤} (hf : Tendsto f l atTop) (h_evtl : ‚àÄ·∂† x in atTop, p x) :
    ‚àÄ·∂† x in l, ‚àÄ y, f x ‚â§ y ‚Üí p y := by
  rw [‚Üê Filter.eventually_forall_ge_atTop] at h_evtl; exact (h_evtl.comap f).filter_mono hf.le_comap

theorem Tendsto.eventually_forall_le_atBot {Œ± Œ≤ : Type*} [Preorder Œ≤] {l : Filter Œ±}
    {p : Œ≤ ‚Üí Prop} {f : Œ± ‚Üí Œ≤} (hf : Tendsto f l atBot) (h_evtl : ‚àÄ·∂† x in atBot, p x) :
    ‚àÄ·∂† x in l, ‚àÄ y, y ‚â§ f x ‚Üí p y := by
  rw [‚Üê Filter.eventually_forall_le_atBot] at h_evtl; exact (h_evtl.comap f).filter_mono hf.le_comap

theorem atTop_basis_Ioi [Nonempty Œ±] [SemilatticeSup Œ±] [NoMaxOrder Œ±] :
    (@atTop Œ± _).HasBasis (fun _ => True) Ioi :=
  atTop_basis.to_hasBasis (fun a ha => ‚ü®a, ha, Ioi_subset_Ici_self‚ü©) fun a ha =>
    (exists_gt a).imp fun _b hb => ‚ü®ha, Ici_subset_Ioi.2 hb‚ü©
#align filter.at_top_basis_Ioi Filter.atTop_basis_Ioi

lemma atTop_basis_Ioi' [SemilatticeSup Œ±] [NoMaxOrder Œ±] (a : Œ±) : atTop.HasBasis (a < ¬∑) Ioi :=
  have : Nonempty Œ± := ‚ü®a‚ü©
  atTop_basis_Ioi.to_hasBasis (fun b _ ‚Ü¶
      let ‚ü®c, hc‚ü© := exists_gt (a ‚äî b)
      ‚ü®c, le_sup_left.trans_lt hc, Ioi_subset_Ioi <| le_sup_right.trans hc.le‚ü©) fun b _ ‚Ü¶
    ‚ü®b, trivial, Subset.rfl‚ü©

theorem atTop_countable_basis [Nonempty Œ±] [SemilatticeSup Œ±] [Countable Œ±] :
    HasCountableBasis (atTop : Filter Œ±) (fun _ => True) Ici :=
  { atTop_basis with countable := to_countable _ }
#align filter.at_top_countable_basis Filter.atTop_countable_basis

theorem atBot_countable_basis [Nonempty Œ±] [SemilatticeInf Œ±] [Countable Œ±] :
    HasCountableBasis (atBot : Filter Œ±) (fun _ => True) Iic :=
  { atBot_basis with countable := to_countable _ }
#align filter.at_bot_countable_basis Filter.atBot_countable_basis

instance (priority := 200) atTop.isCountablyGenerated [Preorder Œ±] [Countable Œ±] :
    (atTop : Filter <| Œ±).IsCountablyGenerated :=
  isCountablyGenerated_seq _
#align filter.at_top.is_countably_generated Filter.atTop.isCountablyGenerated

instance (priority := 200) atBot.isCountablyGenerated [Preorder Œ±] [Countable Œ±] :
    (atBot : Filter <| Œ±).IsCountablyGenerated :=
  isCountablyGenerated_seq _
#align filter.at_bot.is_countably_generated Filter.atBot.isCountablyGenerated

theorem OrderTop.atTop_eq (Œ±) [PartialOrder Œ±] [OrderTop Œ±] : (atTop : Filter Œ±) = pure ‚ä§ :=
  le_antisymm (le_pure_iff.2 <| (eventually_ge_atTop ‚ä§).mono fun _ => top_unique)
    (le_iInf fun _ => le_principal_iff.2 le_top)
#align filter.order_top.at_top_eq Filter.OrderTop.atTop_eq

theorem OrderBot.atBot_eq (Œ±) [PartialOrder Œ±] [OrderBot Œ±] : (atBot : Filter Œ±) = pure ‚ä• :=
  @OrderTop.atTop_eq Œ±·µí·µà _ _
#align filter.order_bot.at_bot_eq Filter.OrderBot.atBot_eq

@[nontriviality]
theorem Subsingleton.atTop_eq (Œ±) [Subsingleton Œ±] [Preorder Œ±] : (atTop : Filter Œ±) = ‚ä§ := by
  refine' top_unique fun s hs x => _
  rw [atTop, ciInf_subsingleton x, mem_principal] at hs
  exact hs left_mem_Ici
#align filter.subsingleton.at_top_eq Filter.Subsingleton.atTop_eq

@[nontriviality]
theorem Subsingleton.atBot_eq (Œ±) [Subsingleton Œ±] [Preorder Œ±] : (atBot : Filter Œ±) = ‚ä§ :=
  @Subsingleton.atTop_eq Œ±·µí·µà _ _
#align filter.subsingleton.at_bot_eq Filter.Subsingleton.atBot_eq

theorem tendsto_atTop_pure [PartialOrder Œ±] [OrderTop Œ±] (f : Œ± ‚Üí Œ≤) :
    Tendsto f atTop (pure <| f ‚ä§) :=
  (OrderTop.atTop_eq Œ±).symm ‚ñ∏ tendsto_pure_pure _ _
#align filter.tendsto_at_top_pure Filter.tendsto_atTop_pure

theorem tendsto_atBot_pure [PartialOrder Œ±] [OrderBot Œ±] (f : Œ± ‚Üí Œ≤) :
    Tendsto f atBot (pure <| f ‚ä•) :=
  @tendsto_atTop_pure Œ±·µí·µà _ _ _ _
#align filter.tendsto_at_bot_pure Filter.tendsto_atBot_pure

theorem Eventually.exists_forall_of_atTop [SemilatticeSup Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop}
    (h : ‚àÄ·∂† x in atTop, p x) : ‚àÉ a, ‚àÄ b ‚â• a, p b :=
  eventually_atTop.mp h
#align filter.eventually.exists_forall_of_at_top Filter.Eventually.exists_forall_of_atTop

theorem Eventually.exists_forall_of_atBot [SemilatticeInf Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop}
    (h : ‚àÄ·∂† x in atBot, p x) : ‚àÉ a, ‚àÄ b ‚â§ a, p b :=
  eventually_atBot.mp h
#align filter.eventually.exists_forall_of_at_bot Filter.Eventually.exists_forall_of_atBot

lemma exists_eventually_atTop [SemilatticeSup Œ±] [Nonempty Œ±] {r : Œ± ‚Üí Œ≤ ‚Üí Prop} :
    (‚àÉ b, ‚àÄ·∂† a in atTop, r a b) ‚Üî ‚àÄ·∂† a‚ÇÄ in atTop, ‚àÉ b, ‚àÄ a ‚â• a‚ÇÄ, r a b := by
  simp_rw [eventually_atTop, ‚Üê exists_swap (Œ± := Œ±)]
  exact exists_congr fun a ‚Ü¶ .symm <| forall_ge_iff <| Monotone.exists fun _ _ _ hb H n hn ‚Ü¶
    H n (hb.trans hn)

lemma exists_eventually_atBot [SemilatticeInf Œ±] [Nonempty Œ±] {r : Œ± ‚Üí Œ≤ ‚Üí Prop} :
    (‚àÉ b, ‚àÄ·∂† a in atBot, r a b) ‚Üî ‚àÄ·∂† a‚ÇÄ in atBot, ‚àÉ b, ‚àÄ a ‚â§ a‚ÇÄ, r a b := by
  simp_rw [eventually_atBot, ‚Üê exists_swap (Œ± := Œ±)]
  exact exists_congr fun a ‚Ü¶ .symm <| forall_le_iff <| Antitone.exists fun _ _ _ hb H n hn ‚Ü¶
    H n (hn.trans hb)

theorem frequently_atTop [SemilatticeSup Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop} :
    (‚àÉ·∂† x in atTop, p x) ‚Üî ‚àÄ a, ‚àÉ b ‚â• a, p b :=
  atTop_basis.frequently_iff.trans <| by simp
#align filter.frequently_at_top Filter.frequently_atTop

theorem frequently_atBot [SemilatticeInf Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop} :
    (‚àÉ·∂† x in atBot, p x) ‚Üî ‚àÄ a, ‚àÉ b ‚â§ a, p b :=
  @frequently_atTop Œ±·µí·µà _ _ _
#align filter.frequently_at_bot Filter.frequently_atBot

theorem frequently_atTop' [SemilatticeSup Œ±] [Nonempty Œ±] [NoMaxOrder Œ±] {p : Œ± ‚Üí Prop} :
    (‚àÉ·∂† x in atTop, p x) ‚Üî ‚àÄ a, ‚àÉ b > a, p b :=
  atTop_basis_Ioi.frequently_iff.trans <| by simp
#align filter.frequently_at_top' Filter.frequently_atTop'

theorem frequently_atBot' [SemilatticeInf Œ±] [Nonempty Œ±] [NoMinOrder Œ±] {p : Œ± ‚Üí Prop} :
    (‚àÉ·∂† x in atBot, p x) ‚Üî ‚àÄ a, ‚àÉ b < a, p b :=
  @frequently_atTop' Œ±·µí·µà _ _ _ _
#align filter.frequently_at_bot' Filter.frequently_atBot'

theorem Frequently.forall_exists_of_atTop [SemilatticeSup Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop}
    (h : ‚àÉ·∂† x in atTop, p x) : ‚àÄ a, ‚àÉ b ‚â• a, p b :=
  frequently_atTop.mp h
#align filter.frequently.forall_exists_of_at_top Filter.Frequently.forall_exists_of_atTop

theorem Frequently.forall_exists_of_atBot [SemilatticeInf Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop}
    (h : ‚àÉ·∂† x in atBot, p x) : ‚àÄ a, ‚àÉ b ‚â§ a, p b :=
  frequently_atBot.mp h
#align filter.frequently.forall_exists_of_at_bot Filter.Frequently.forall_exists_of_atBot

theorem map_atTop_eq [Nonempty Œ±] [SemilatticeSup Œ±] {f : Œ± ‚Üí Œ≤} :
    atTop.map f = ‚®Ö a, ùìü (f '' { a' | a ‚â§ a' }) :=
  (atTop_basis.map f).eq_iInf
#align filter.map_at_top_eq Filter.map_atTop_eq

theorem map_atBot_eq [Nonempty Œ±] [SemilatticeInf Œ±] {f : Œ± ‚Üí Œ≤} :
    atBot.map f = ‚®Ö a, ùìü (f '' { a' | a' ‚â§ a }) :=
  @map_atTop_eq Œ±·µí·µà _ _ _ _
#align filter.map_at_bot_eq Filter.map_atBot_eq

theorem tendsto_atTop [Preorder Œ≤] {m : Œ± ‚Üí Œ≤} {f : Filter Œ±} :
    Tendsto m f atTop ‚Üî ‚àÄ b, ‚àÄ·∂† a in f, b ‚â§ m a := by
  simp only [atTop, tendsto_iInf, tendsto_principal, mem_Ici]
#align filter.tendsto_at_top Filter.tendsto_atTop

theorem tendsto_atBot [Preorder Œ≤] {m : Œ± ‚Üí Œ≤} {f : Filter Œ±} :
    Tendsto m f atBot ‚Üî ‚àÄ b, ‚àÄ·∂† a in f, m a ‚â§ b :=
  @tendsto_atTop Œ± Œ≤·µí·µà _ m f
#align filter.tendsto_at_bot Filter.tendsto_atBot

theorem tendsto_atTop_mono' [Preorder Œ≤] (l : Filter Œ±) ‚¶Éf‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤‚¶Ñ (h : f‚ÇÅ ‚â§·∂†[l] f‚ÇÇ)
    (h‚ÇÅ : Tendsto f‚ÇÅ l atTop) : Tendsto f‚ÇÇ l atTop :=
  tendsto_atTop.2 fun b => by filter_upwards [tendsto_atTop.1 h‚ÇÅ b, h] with x using le_trans
#align filter.tendsto_at_top_mono' Filter.tendsto_atTop_mono'

theorem tendsto_atBot_mono' [Preorder Œ≤] (l : Filter Œ±) ‚¶Éf‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤‚¶Ñ (h : f‚ÇÅ ‚â§·∂†[l] f‚ÇÇ) :
    Tendsto f‚ÇÇ l atBot ‚Üí Tendsto f‚ÇÅ l atBot :=
  @tendsto_atTop_mono' _ Œ≤·µí·µà _ _ _ _ h
#align filter.tendsto_at_bot_mono' Filter.tendsto_atBot_mono'

theorem tendsto_atTop_mono [Preorder Œ≤] {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (h : ‚àÄ n, f n ‚â§ g n) :
    Tendsto f l atTop ‚Üí Tendsto g l atTop :=
  tendsto_atTop_mono' l <| eventually_of_forall h
#align filter.tendsto_at_top_mono Filter.tendsto_atTop_mono

theorem tendsto_atBot_mono [Preorder Œ≤] {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (h : ‚àÄ n, f n ‚â§ g n) :
    Tendsto g l atBot ‚Üí Tendsto f l atBot :=
  @tendsto_atTop_mono _ Œ≤·µí·µà _ _ _ _ h
#align filter.tendsto_at_bot_mono Filter.tendsto_atBot_mono

lemma atTop_eq_generate_of_forall_exists_le [LinearOrder Œ±] {s : Set Œ±} (hs : ‚àÄ x, ‚àÉ y ‚àà s, x ‚â§ y) :
    (atTop : Filter Œ±) = generate (Ici '' s) := by
  rw [atTop_eq_generate_Ici]
  apply le_antisymm
  ¬∑ rw [le_generate_iff]
    rintro - ‚ü®y, -, rfl‚ü©
    exact mem_generate_of_mem ‚ü®y, rfl‚ü©
  ¬∑ rw [le_generate_iff]
    rintro - ‚ü®x, -, -, rfl‚ü©
    rcases hs x with ‚ü®y, ys, hy‚ü©
    have A : Ici y ‚àà generate (Ici '' s) := mem_generate_of_mem (mem_image_of_mem _ ys)
    have B : Ici y ‚äÜ Ici x := Ici_subset_Ici.2 hy
    exact sets_of_superset (generate (Ici '' s)) A B

lemma atTop_eq_generate_of_not_bddAbove [LinearOrder Œ±] {s : Set Œ±} (hs : ¬¨ BddAbove s) :
    (atTop : Filter Œ±) = generate (Ici '' s) := by
  refine' atTop_eq_generate_of_forall_exists_le fun x ‚Ü¶ _
  obtain ‚ü®y, hy, hy'‚ü© := not_bddAbove_iff.mp hs x
  exact ‚ü®y, hy, hy'.le‚ü©

end Filter

namespace OrderIso

open Filter

variable [Preorder Œ±] [Preorder Œ≤]

@[simp]
theorem comap_atTop (e : Œ± ‚âÉo Œ≤) : comap e atTop = atTop := by
  simp [atTop, ‚Üê e.surjective.iInf_comp]
#align order_iso.comap_at_top OrderIso.comap_atTop

@[simp]
theorem comap_atBot (e : Œ± ‚âÉo Œ≤) : comap e atBot = atBot :=
  e.dual.comap_atTop
#align order_iso.comap_at_bot OrderIso.comap_atBot

@[simp]
theorem map_atTop (e : Œ± ‚âÉo Œ≤) : map (e : Œ± ‚Üí Œ≤) atTop = atTop := by
  rw [‚Üê e.comap_atTop, map_comap_of_surjective e.surjective]
#align order_iso.map_at_top OrderIso.map_atTop

@[simp]
theorem map_atBot (e : Œ± ‚âÉo Œ≤) : map (e : Œ± ‚Üí Œ≤) atBot = atBot :=
  e.dual.map_atTop
#align order_iso.map_at_bot OrderIso.map_atBot

theorem tendsto_atTop (e : Œ± ‚âÉo Œ≤) : Tendsto e atTop atTop :=
  e.map_atTop.le
#align order_iso.tendsto_at_top OrderIso.tendsto_atTop

theorem tendsto_atBot (e : Œ± ‚âÉo Œ≤) : Tendsto e atBot atBot :=
  e.map_atBot.le
#align order_iso.tendsto_at_bot OrderIso.tendsto_atBot

@[simp]
theorem tendsto_atTop_iff {l : Filter Œ≥} {f : Œ≥ ‚Üí Œ±} (e : Œ± ‚âÉo Œ≤) :
    Tendsto (fun x => e (f x)) l atTop ‚Üî Tendsto f l atTop := by
  rw [‚Üê e.comap_atTop, tendsto_comap_iff]; rfl
#align order_iso.tendsto_at_top_iff OrderIso.tendsto_atTop_iff

@[simp]
theorem tendsto_atBot_iff {l : Filter Œ≥} {f : Œ≥ ‚Üí Œ±} (e : Œ± ‚âÉo Œ≤) :
    Tendsto (fun x => e (f x)) l atBot ‚Üî Tendsto f l atBot :=
  e.dual.tendsto_atTop_iff
#align order_iso.tendsto_at_bot_iff OrderIso.tendsto_atBot_iff

end OrderIso

namespace Filter

/-!
### Sequences
-/

theorem inf_map_atTop_neBot_iff [SemilatticeSup Œ±] [Nonempty Œ±] {F : Filter Œ≤} {u : Œ± ‚Üí Œ≤} :
    NeBot (F ‚äì map u atTop) ‚Üî ‚àÄ U ‚àà F, ‚àÄ N, ‚àÉ n ‚â• N, u n ‚àà U := by
  simp_rw [inf_neBot_iff_frequently_left, frequently_map, frequently_atTop]; rfl
#align filter.inf_map_at_top_ne_bot_iff Filter.inf_map_atTop_neBot_iff

theorem inf_map_atBot_neBot_iff [SemilatticeInf Œ±] [Nonempty Œ±] {F : Filter Œ≤} {u : Œ± ‚Üí Œ≤} :
    NeBot (F ‚äì map u atBot) ‚Üî ‚àÄ U ‚àà F, ‚àÄ N, ‚àÉ n ‚â§ N, u n ‚àà U :=
  @inf_map_atTop_neBot_iff Œ±·µí·µà _ _ _ _ _
#align filter.inf_map_at_bot_ne_bot_iff Filter.inf_map_atBot_neBot_iff

theorem extraction_of_frequently_atTop' {P : ‚Ñï ‚Üí Prop} (h : ‚àÄ N, ‚àÉ n > N, P n) :
    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P (œÜ n) := by
  choose u hu hu' using h
  refine ‚ü®fun n => u^[n + 1] 0, strictMono_nat_of_lt_succ fun n => ?_, fun n => ?_‚ü©
  ¬∑ exact Trans.trans (hu _) (Function.iterate_succ_apply' _ _ _).symm
  ¬∑ simpa only [Function.iterate_succ_apply'] using hu' _
#align filter.extraction_of_frequently_at_top' Filter.extraction_of_frequently_atTop'

theorem extraction_of_frequently_atTop {P : ‚Ñï ‚Üí Prop} (h : ‚àÉ·∂† n in atTop, P n) :
    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P (œÜ n) := by
  rw [frequently_atTop'] at h
  exact extraction_of_frequently_atTop' h
#align filter.extraction_of_frequently_at_top Filter.extraction_of_frequently_atTop

theorem extraction_of_eventually_atTop {P : ‚Ñï ‚Üí Prop} (h : ‚àÄ·∂† n in atTop, P n) :
    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P (œÜ n) :=
  extraction_of_frequently_atTop h.frequently
#align filter.extraction_of_eventually_at_top Filter.extraction_of_eventually_atTop

theorem extraction_forall_of_frequently {P : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop} (h : ‚àÄ n, ‚àÉ·∂† k in atTop, P n k) :
    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P n (œÜ n) := by
  simp only [frequently_atTop'] at h
  choose u hu hu' using h
  use (fun n => Nat.recOn n (u 0 0) fun n v => u (n + 1) v : ‚Ñï ‚Üí ‚Ñï)
  constructor
  ¬∑ apply strictMono_nat_of_lt_succ
    intro n
    apply hu
  ¬∑ intro n
    cases n <;> simp [hu']
#align filter.extraction_forall_of_frequently Filter.extraction_forall_of_frequently

theorem extraction_forall_of_eventually {P : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop} (h : ‚àÄ n, ‚àÄ·∂† k in atTop, P n k) :
    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P n (œÜ n) :=
  extraction_forall_of_frequently fun n => (h n).frequently
#align filter.extraction_forall_of_eventually Filter.extraction_forall_of_eventually

theorem extraction_forall_of_eventually' {P : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop} (h : ‚àÄ n, ‚àÉ N, ‚àÄ k ‚â• N, P n k) :
    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P n (œÜ n) :=
  extraction_forall_of_eventually (by simp [eventually_atTop, h])
#align filter.extraction_forall_of_eventually' Filter.extraction_forall_of_eventually'

theorem Eventually.atTop_of_arithmetic {p : ‚Ñï ‚Üí Prop} {n : ‚Ñï} (hn : n ‚â† 0)
    (hp : ‚àÄ k < n, ‚àÄ·∂† a in atTop, p (n * a + k)) : ‚àÄ·∂† a in atTop, p a := by
  simp only [eventually_atTop] at hp ‚ä¢
  choose! N hN using hp
  refine ‚ü®(Finset.range n).sup (n * N ¬∑), fun b hb => ?_‚ü©
  rw [‚Üê Nat.div_add_mod b n]
  have hlt := Nat.mod_lt b hn.bot_lt
  refine hN _ hlt _ ?_
  rw [ge_iff_le, Nat.le_div_iff_mul_le hn.bot_lt, mul_comm]
  exact (Finset.le_sup (f := (n * N ¬∑)) (Finset.mem_range.2 hlt)).trans hb

theorem exists_le_of_tendsto_atTop [SemilatticeSup Œ±] [Preorder Œ≤] {u : Œ± ‚Üí Œ≤}
    (h : Tendsto u atTop atTop) (a : Œ±) (b : Œ≤) : ‚àÉ a' ‚â• a, b ‚â§ u a' := by
  have : Nonempty Œ± := ‚ü®a‚ü©
  have : ‚àÄ·∂† x in atTop, a ‚â§ x ‚àß b ‚â§ u x :=
    (eventually_ge_atTop a).and (h.eventually <| eventually_ge_atTop b)
  exact this.exists
#align filter.exists_le_of_tendsto_at_top Filter.exists_le_of_tendsto_atTop

-- @[nolint ge_or_gt] -- Porting note: restore attribute
theorem exists_le_of_tendsto_atBot [SemilatticeSup Œ±] [Preorder Œ≤] {u : Œ± ‚Üí Œ≤}
    (h : Tendsto u atTop atBot) : ‚àÄ a b, ‚àÉ a' ‚â• a, u a' ‚â§ b :=
  @exists_le_of_tendsto_atTop _ Œ≤·µí·µà _ _ _ h
#align filter.exists_le_of_tendsto_at_bot Filter.exists_le_of_tendsto_atBot

theorem exists_lt_of_tendsto_atTop [SemilatticeSup Œ±] [Preorder Œ≤] [NoMaxOrder Œ≤] {u : Œ± ‚Üí Œ≤}
    (h : Tendsto u atTop atTop) (a : Œ±) (b : Œ≤) : ‚àÉ a' ‚â• a, b < u a' := by
  cases' exists_gt b with b' hb'
  rcases exists_le_of_tendsto_atTop h a b' with ‚ü®a', ha', ha''‚ü©
  exact ‚ü®a', ha', lt_of_lt_of_le hb' ha''‚ü©
#align filter.exists_lt_of_tendsto_at_top Filter.exists_lt_of_tendsto_atTop

-- @[nolint ge_or_gt] -- Porting note: restore attribute
theorem exists_lt_of_tendsto_atBot [SemilatticeSup Œ±] [Preorder Œ≤] [NoMinOrder Œ≤] {u : Œ± ‚Üí Œ≤}
    (h : Tendsto u atTop atBot) : ‚àÄ a b, ‚àÉ a' ‚â• a, u a' < b :=
  @exists_lt_of_tendsto_atTop _ Œ≤·µí·µà _ _ _ _ h
#align filter.exists_lt_of_tendsto_at_bot Filter.exists_lt_of_tendsto_atBot

/-- If `u` is a sequence which is unbounded above,
then after any point, it reaches a value strictly greater than all previous values.
-/
theorem high_scores [LinearOrder Œ≤] [NoMaxOrder Œ≤] {u : ‚Ñï ‚Üí Œ≤} (hu : Tendsto u atTop atTop) :
    ‚àÄ N, ‚àÉ n ‚â• N, ‚àÄ k < n, u k < u n := by
  intro N
  obtain ‚ü®k : ‚Ñï, - : k ‚â§ N, hku : ‚àÄ l ‚â§ N, u l ‚â§ u k‚ü© : ‚àÉ k ‚â§ N, ‚àÄ l ‚â§ N, u l ‚â§ u k
  exact exists_max_image _ u (finite_le_nat N) ‚ü®N, le_refl N‚ü©
  have ex : ‚àÉ n ‚â• N, u k < u n := exists_lt_of_tendsto_atTop hu _ _
  obtain ‚ü®n : ‚Ñï, hnN : n ‚â• N, hnk : u k < u n, hn_min : ‚àÄ m, m < n ‚Üí N ‚â§ m ‚Üí u m ‚â§ u k‚ü© :
      ‚àÉ n ‚â• N, u k < u n ‚àß ‚àÄ m, m < n ‚Üí N ‚â§ m ‚Üí u m ‚â§ u k := by
    rcases Nat.findX ex with ‚ü®n, ‚ü®hnN, hnk‚ü©, hn_min‚ü©
    push_neg at hn_min
    exact ‚ü®n, hnN, hnk, hn_min‚ü©
  use n, hnN
  rintro (l : ‚Ñï) (hl : l < n)
  have hlk : u l ‚â§ u k := by
    cases' (le_total l N : l ‚â§ N ‚à® N ‚â§ l) with H H
    ¬∑ exact hku l H
    ¬∑ exact hn_min l hl H
  calc
    u l ‚â§ u k := hlk
    _ < u n := hnk
#align filter.high_scores Filter.high_scores

-- see Note [nolint_ge]
/-- If `u` is a sequence which is unbounded below,
then after any point, it reaches a value strictly smaller than all previous values.
-/
-- @[nolint ge_or_gt] Porting note: restore attribute
theorem low_scores [LinearOrder Œ≤] [NoMinOrder Œ≤] {u : ‚Ñï ‚Üí Œ≤} (hu : Tendsto u atTop atBot) :
    ‚àÄ N, ‚àÉ n ‚â• N, ‚àÄ k < n, u n < u k :=
  @high_scores Œ≤·µí·µà _ _ _ hu
#align filter.low_scores Filter.low_scores

/-- If `u` is a sequence which is unbounded above,
then it `Frequently` reaches a value strictly greater than all previous values.
-/
theorem frequently_high_scores [LinearOrder Œ≤] [NoMaxOrder Œ≤] {u : ‚Ñï ‚Üí Œ≤}
    (hu : Tendsto u atTop atTop) : ‚àÉ·∂† n in atTop, ‚àÄ k < n, u k < u n := by
  simpa [frequently_atTop] using high_scores hu
#align filter.frequently_high_scores Filter.frequently_high_scores

/-- If `u` is a sequence which is unbounded below,
then it `Frequently` reaches a value strictly smaller than all previous values.
-/
theorem frequently_low_scores [LinearOrder Œ≤] [NoMinOrder Œ≤] {u : ‚Ñï ‚Üí Œ≤}
    (hu : Tendsto u atTop atBot) : ‚àÉ·∂† n in atTop, ‚àÄ k < n, u n < u k :=
  @frequently_high_scores Œ≤·µí·µà _ _ _ hu
#align filter.frequently_low_scores Filter.frequently_low_scores

theorem strictMono_subseq_of_tendsto_atTop {Œ≤ : Type*} [LinearOrder Œ≤] [NoMaxOrder Œ≤] {u : ‚Ñï ‚Üí Œ≤}
    (hu : Tendsto u atTop atTop) : ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß StrictMono (u ‚àò œÜ) :=
  let ‚ü®œÜ, h, h'‚ü© := extraction_of_frequently_atTop (frequently_high_scores hu)
  ‚ü®œÜ, h, fun _ m hnm => h' m _ (h hnm)‚ü©
#align filter.strict_mono_subseq_of_tendsto_at_top Filter.strictMono_subseq_of_tendsto_atTop

theorem strictMono_subseq_of_id_le {u : ‚Ñï ‚Üí ‚Ñï} (hu : ‚àÄ n, n ‚â§ u n) :
    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß StrictMono (u ‚àò œÜ) :=
  strictMono_subseq_of_tendsto_atTop (tendsto_atTop_mono hu tendsto_id)
#align filter.strict_mono_subseq_of_id_le Filter.strictMono_subseq_of_id_le

theorem _root_.StrictMono.tendsto_atTop {œÜ : ‚Ñï ‚Üí ‚Ñï} (h : StrictMono œÜ) : Tendsto œÜ atTop atTop :=
  tendsto_atTop_mono h.id_le tendsto_id
#align strict_mono.tendsto_at_top StrictMono.tendsto_atTop

section OrderedAddCommMonoid

variable [OrderedAddCommMonoid Œ≤] {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤}

theorem tendsto_atTop_add_nonneg_left' (hf : ‚àÄ·∂† x in l, 0 ‚â§ f x) (hg : Tendsto g l atTop) :
    Tendsto (fun x => f x + g x) l atTop :=
  tendsto_atTop_mono' l (hf.mono fun _ => le_add_of_nonneg_left) hg
#align filter.tendsto_at_top_add_nonneg_left' Filter.tendsto_atTop_add_nonneg_left'

theorem tendsto_atBot_add_nonpos_left' (hf : ‚àÄ·∂† x in l, f x ‚â§ 0) (hg : Tendsto g l atBot) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_atTop_add_nonneg_left' _ Œ≤·µí·µà _ _ _ _ hf hg
#align filter.tendsto_at_bot_add_nonpos_left' Filter.tendsto_atBot_add_nonpos_left'

theorem tendsto_atTop_add_nonneg_left (hf : ‚àÄ x, 0 ‚â§ f x) (hg : Tendsto g l atTop) :
    Tendsto (fun x => f x + g x) l atTop :=
  tendsto_atTop_add_nonneg_left' (eventually_of_forall hf) hg
#align filter.tendsto_at_top_add_nonneg_left Filter.tendsto_atTop_add_nonneg_left

theorem tendsto_atBot_add_nonpos_left (hf : ‚àÄ x, f x ‚â§ 0) (hg : Tendsto g l atBot) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_atTop_add_nonneg_left _ Œ≤·µí·µà _ _ _ _ hf hg
#align filter.tendsto_at_bot_add_nonpos_left Filter.tendsto_atBot_add_nonpos_left

theorem tendsto_atTop_add_nonneg_right' (hf : Tendsto f l atTop) (hg : ‚àÄ·∂† x in l, 0 ‚â§ g x) :
    Tendsto (fun x => f x + g x) l atTop :=
  tendsto_atTop_mono' l (monotone_mem (fun _ => le_add_of_nonneg_right) hg) hf
#align filter.tendsto_at_top_add_nonneg_right' Filter.tendsto_atTop_add_nonneg_right'

theorem tendsto_atBot_add_nonpos_right' (hf : Tendsto f l atBot) (hg : ‚àÄ·∂† x in l, g x ‚â§ 0) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_atTop_add_nonneg_right' _ Œ≤·µí·µà _ _ _ _ hf hg
#align filter.tendsto_at_bot_add_nonpos_right' Filter.tendsto_atBot_add_nonpos_right'

theorem tendsto_atTop_add_nonneg_right (hf : Tendsto f l atTop) (hg : ‚àÄ x, 0 ‚â§ g x) :
    Tendsto (fun x => f x + g x) l atTop :=
  tendsto_atTop_add_nonneg_right' hf (eventually_of_forall hg)
#align filter.tendsto_at_top_add_nonneg_right Filter.tendsto_atTop_add_nonneg_right

theorem tendsto_atBot_add_nonpos_right (hf : Tendsto f l atBot) (hg : ‚àÄ x, g x ‚â§ 0) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_atTop_add_nonneg_right _ Œ≤·µí·µà _ _ _ _ hf hg
#align filter.tendsto_at_bot_add_nonpos_right Filter.tendsto_atBot_add_nonpos_right

theorem tendsto_atTop_add (hf : Tendsto f l atTop) (hg : Tendsto g l atTop) :
    Tendsto (fun x => f x + g x) l atTop :=
  tendsto_atTop_add_nonneg_left' (tendsto_atTop.mp hf 0) hg
#align filter.tendsto_at_top_add Filter.tendsto_atTop_add

theorem tendsto_atBot_add (hf : Tendsto f l atBot) (hg : Tendsto g l atBot) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_atTop_add _ Œ≤·µí·µà _ _ _ _ hf hg
#align filter.tendsto_at_bot_add Filter.tendsto_atBot_add

theorem Tendsto.nsmul_atTop (hf : Tendsto f l atTop) {n : ‚Ñï} (hn : 0 < n) :
    Tendsto (fun x => n ‚Ä¢ f x) l atTop :=
  tendsto_atTop.2 fun y =>
    (tendsto_atTop.1 hf y).mp <|
      (tendsto_atTop.1 hf 0).mono fun x h‚ÇÄ hy =>
        calc
          y ‚â§ f x := hy
          _ = 1 ‚Ä¢ f x := (one_nsmul _).symm
          _ ‚â§ n ‚Ä¢ f x := nsmul_le_nsmul_left h‚ÇÄ hn
#align filter.tendsto.nsmul_at_top Filter.Tendsto.nsmul_atTop

theorem Tendsto.nsmul_atBot (hf : Tendsto f l atBot) {n : ‚Ñï} (hn : 0 < n) :
    Tendsto (fun x => n ‚Ä¢ f x) l atBot :=
  @Tendsto.nsmul_atTop Œ± Œ≤·µí·µà _ l f hf n hn
#align filter.tendsto.nsmul_at_bot Filter.Tendsto.nsmul_atBot

set_option linter.deprecated false in
@[deprecated] theorem tendsto_bit0_atTop : Tendsto bit0 (atTop : Filter Œ≤) atTop :=
  tendsto_atTop_add tendsto_id tendsto_id
#align filter.tendsto_bit0_at_top Filter.tendsto_bit0_atTop

set_option linter.deprecated false in
@[deprecated] theorem tendsto_bit0_atBot : Tendsto bit0 (atBot : Filter Œ≤) atBot :=
  tendsto_atBot_add tendsto_id tendsto_id
#align filter.tendsto_bit0_at_bot Filter.tendsto_bit0_atBot

end OrderedAddCommMonoid

section OrderedCancelAddCommMonoid

variable [OrderedCancelAddCommMonoid Œ≤] {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤}

theorem tendsto_atTop_of_add_const_left (C : Œ≤) (hf : Tendsto (fun x => C + f x) l atTop) :
    Tendsto f l atTop :=
  tendsto_atTop.2 fun b => (tendsto_atTop.1 hf (C + b)).mono fun _ => le_of_add_le_add_left
#align filter.tendsto_at_top_of_add_const_left Filter.tendsto_atTop_of_add_const_left

-- porting note: the "order dual" trick timeouts
theorem tendsto_atBot_of_add_const_left (C : Œ≤) (hf : Tendsto (fun x => C + f x) l atBot) :
    Tendsto f l atBot :=
  tendsto_atBot.2 fun b => (tendsto_atBot.1 hf (C + b)).mono fun _ => le_of_add_le_add_left
#align filter.tendsto_at_bot_of_add_const_left Filter.tendsto_atBot_of_add_const_left

theorem tendsto_atTop_of_add_const_right (C : Œ≤) (hf : Tendsto (fun x => f x + C) l atTop) :
    Tendsto f l atTop :=
  tendsto_atTop.2 fun b => (tendsto_atTop.1 hf (b + C)).mono fun _ => le_of_add_le_add_right
#align filter.tendsto_at_top_of_add_const_right Filter.tendsto_atTop_of_add_const_right

-- porting note: the "order dual" trick timeouts
theorem tendsto_atBot_of_add_const_right (C : Œ≤) (hf : Tendsto (fun x => f x + C) l atBot) :
    Tendsto f l atBot :=
  tendsto_atBot.2 fun b => (tendsto_atBot.1 hf (b + C)).mono fun _ => le_of_add_le_add_right
#align filter.tendsto_at_bot_of_add_const_right Filter.tendsto_atBot_of_add_const_right

theorem tendsto_atTop_of_add_bdd_above_left' (C) (hC : ‚àÄ·∂† x in l, f x ‚â§ C)
    (h : Tendsto (fun x => f x + g x) l atTop) : Tendsto g l atTop :=
  tendsto_atTop_of_add_const_left C
    (tendsto_atTop_mono' l (hC.mono fun x hx => add_le_add_right hx (g x)) h)
#align filter.tendsto_at_top_of_add_bdd_above_left' Filter.tendsto_atTop_of_add_bdd_above_left'

-- porting note: the "order dual" trick timeouts
theorem tendsto_atBot_of_add_bdd_below_left' (C) (hC : ‚àÄ·∂† x in l, C ‚â§ f x)
    (h : Tendsto (fun x => f x + g x) l atBot) : Tendsto g l atBot :=
  tendsto_atBot_of_add_const_left C
    (tendsto_atBot_mono' l (hC.mono fun x hx => add_le_add_right hx (g x)) h)
#align filter.tendsto_at_bot_of_add_bdd_below_left' Filter.tendsto_atBot_of_add_bdd_below_left'

theorem tendsto_atTop_of_add_bdd_above_left (C) (hC : ‚àÄ x, f x ‚â§ C) :
    Tendsto (fun x => f x + g x) l atTop ‚Üí Tendsto g l atTop :=
  tendsto_atTop_of_add_bdd_above_left' C (univ_mem' hC)
#align filter.tendsto_at_top_of_add_bdd_above_left Filter.tendsto_atTop_of_add_bdd_above_left

-- porting note: the "order dual" trick timeouts
theorem tendsto_atBot_of_add_bdd_below_left (C) (hC : ‚àÄ x, C ‚â§ f x) :
    Tendsto (fun x => f x + g x) l atBot ‚Üí Tendsto g l atBot :=
  tendsto_atBot_of_add_bdd_below_left' C (univ_mem' hC)
#align filter.tendsto_at_bot_of_add_bdd_below_left Filter.tendsto_atBot_of_add_bdd_below_left

theorem tendsto_atTop_of_add_bdd_above_right' (C) (hC : ‚àÄ·∂† x in l, g x ‚â§ C)
    (h : Tendsto (fun x => f x + g x) l atTop) : Tendsto f l atTop :=
  tendsto_atTop_of_add_const_right C
    (tendsto_atTop_mono' l (hC.mono fun x hx => add_le_add_left hx (f x)) h)
#align filter.tendsto_at_top_of_add_bdd_above_right' Filter.tendsto_atTop_of_add_bdd_above_right'

-- porting note: the "order dual" trick timeouts
theorem tendsto_atBot_of_add_bdd_below_right' (C) (hC : ‚àÄ·∂† x in l, C ‚â§ g x)
    (h : Tendsto (fun x => f x + g x) l atBot) : Tendsto f l atBot :=
  tendsto_atBot_of_add_const_right C
    (tendsto_atBot_mono' l (hC.mono fun x hx => add_le_add_left hx (f x)) h)
#align filter.tendsto_at_bot_of_add_bdd_below_right' Filter.tendsto_atBot_of_add_bdd_below_right'

theorem tendsto_atTop_of_add_bdd_above_right (C) (hC : ‚àÄ x, g x ‚â§ C) :
    Tendsto (fun x => f x + g x) l atTop ‚Üí Tendsto f l atTop :=
  tendsto_atTop_of_add_bdd_above_right' C (univ_mem' hC)
#align filter.tendsto_at_top_of_add_bdd_above_right Filter.tendsto_atTop_of_add_bdd_above_right

-- porting note: the "order dual" trick timeouts
theorem tendsto_atBot_of_add_bdd_below_right (C) (hC : ‚àÄ x, C ‚â§ g x) :
    Tendsto (fun x => f x + g x) l atBot ‚Üí Tendsto f l atBot :=
  tendsto_atBot_of_add_bdd_below_right' C (univ_mem' hC)
#align filter.tendsto_at_bot_of_add_bdd_below_right Filter.tendsto_atBot_of_add_bdd_below_right

end OrderedCancelAddCommMonoid

section OrderedGroup

variable [OrderedAddCommGroup Œ≤] (l : Filter Œ±) {f g : Œ± ‚Üí Œ≤}

theorem tendsto_atTop_add_left_of_le' (C : Œ≤) (hf : ‚àÄ·∂† x in l, C ‚â§ f x) (hg : Tendsto g l atTop) :
    Tendsto (fun x => f x + g x) l atTop :=
  @tendsto_atTop_of_add_bdd_above_left' _ _ _ l (fun x => -f x) (fun x => f x + g x) (-C) (by simpa)
    (by simpa)
#align filter.tendsto_at_top_add_left_of_le' Filter.tendsto_atTop_add_left_of_le'

theorem tendsto_atBot_add_left_of_ge' (C : Œ≤) (hf : ‚àÄ·∂† x in l, f x ‚â§ C) (hg : Tendsto g l atBot) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_atTop_add_left_of_le' _ Œ≤·µí·µà _ _ _ _ C hf hg
#align filter.tendsto_at_bot_add_left_of_ge' Filter.tendsto_atBot_add_left_of_ge'

theorem tendsto_atTop_add_left_of_le (C : Œ≤) (hf : ‚àÄ x, C ‚â§ f x) (hg : Tendsto g l atTop) :
    Tendsto (fun x => f x + g x) l atTop :=
  tendsto_atTop_add_left_of_le' l C (univ_mem' hf) hg
#align filter.tendsto_at_top_add_left_of_le Filter.tendsto_atTop_add_left_of_le

theorem tendsto_atBot_add_left_of_ge (C : Œ≤) (hf : ‚àÄ x, f x ‚â§ C) (hg : Tendsto g l atBot) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_atTop_add_left_of_le _ Œ≤·µí·µà _ _ _ _ C hf hg
#align filter.tendsto_at_bot_add_left_of_ge Filter.tendsto_atBot_add_left_of_ge

theorem tendsto_atTop_add_right_of_le' (C : Œ≤) (hf : Tendsto f l atTop) (hg : ‚àÄ·∂† x in l, C ‚â§ g x) :
    Tendsto (fun x => f x + g x) l atTop :=
  @tendsto_atTop_of_add_bdd_above_right' _ _ _ l (fun x => f x + g x) (fun x => -g x) (-C)
    (by simp [hg]) (by simp [hf])
#align filter.tendsto_at_top_add_right_of_le' Filter.tendsto_atTop_add_right_of_le'

theorem tendsto_atBot_add_right_of_ge' (C : Œ≤) (hf : Tendsto f l atBot) (hg : ‚àÄ·∂† x in l, g x ‚â§ C) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_atTop_add_right_of_le' _ Œ≤·µí·µà _ _ _ _ C hf hg
#align filter.tendsto_at_bot_add_right_of_ge' Filter.tendsto_atBot_add_right_of_ge'

theorem tendsto_atTop_add_right_of_le (C : Œ≤) (hf : Tendsto f l atTop) (hg : ‚àÄ x, C ‚â§ g x) :
    Tendsto (fun x => f x + g x) l atTop :=
  tendsto_atTop_add_right_of_le' l C hf (univ_mem' hg)
#align filter.tendsto_at_top_add_right_of_le Filter.tendsto_atTop_add_right_of_le

theorem tendsto_atBot_add_right_of_ge (C : Œ≤) (hf : Tendsto f l atBot) (hg : ‚àÄ x, g x ‚â§ C) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_atTop_add_right_of_le _ Œ≤·µí·µà _ _ _ _ C hf hg
#align filter.tendsto_at_bot_add_right_of_ge Filter.tendsto_atBot_add_right_of_ge

theorem tendsto_atTop_add_const_left (C : Œ≤) (hf : Tendsto f l atTop) :
    Tendsto (fun x => C + f x) l atTop :=
  tendsto_atTop_add_left_of_le' l C (univ_mem' fun _ => le_refl C) hf
#align filter.tendsto_at_top_add_const_left Filter.tendsto_atTop_add_const_left

theorem tendsto_atBot_add_const_left (C : Œ≤) (hf : Tendsto f l atBot) :
    Tendsto (fun x => C + f x) l atBot :=
  @tendsto_atTop_add_const_left _ Œ≤·µí·µà _ _ _ C hf
#align filter.tendsto_at_bot_add_const_left Filter.tendsto_atBot_add_const_left

theorem tendsto_atTop_add_const_right (C : Œ≤) (hf : Tendsto f l atTop) :
    Tendsto (fun x => f x + C) l atTop :=
  tendsto_atTop_add_right_of_le' l C hf (univ_mem' fun _ => le_refl C)
#align filter.tendsto_at_top_add_const_right Filter.tendsto_atTop_add_const_right

theorem tendsto_atBot_add_const_right (C : Œ≤) (hf : Tendsto f l atBot) :
    Tendsto (fun x => f x + C) l atBot :=
  @tendsto_atTop_add_const_right _ Œ≤·µí·µà _ _ _ C hf
#align filter.tendsto_at_bot_add_const_right Filter.tendsto_atBot_add_const_right

theorem map_neg_atBot : map (Neg.neg : Œ≤ ‚Üí Œ≤) atBot = atTop :=
  (OrderIso.neg Œ≤).map_atBot
#align filter.map_neg_at_bot Filter.map_neg_atBot

theorem map_neg_atTop : map (Neg.neg : Œ≤ ‚Üí Œ≤) atTop = atBot :=
  (OrderIso.neg Œ≤).map_atTop
#align filter.map_neg_at_top Filter.map_neg_atTop

theorem comap_neg_atBot : comap (Neg.neg : Œ≤ ‚Üí Œ≤) atBot = atTop :=
  (OrderIso.neg Œ≤).comap_atTop
#align filter.comap_neg_at_bot Filter.comap_neg_atBot

theorem comap_neg_atTop : comap (Neg.neg : Œ≤ ‚Üí Œ≤) atTop = atBot :=
  (OrderIso.neg Œ≤).comap_atBot
#align filter.comap_neg_at_top Filter.comap_neg_atTop

theorem tendsto_neg_atTop_atBot : Tendsto (Neg.neg : Œ≤ ‚Üí Œ≤) atTop atBot :=
  (OrderIso.neg Œ≤).tendsto_atTop
#align filter.tendsto_neg_at_top_at_bot Filter.tendsto_neg_atTop_atBot

theorem tendsto_neg_atBot_atTop : Tendsto (Neg.neg : Œ≤ ‚Üí Œ≤) atBot atTop :=
  @tendsto_neg_atTop_atBot Œ≤·µí·µà _
#align filter.tendsto_neg_at_bot_at_top Filter.tendsto_neg_atBot_atTop

variable {l}

@[simp]
theorem tendsto_neg_atTop_iff : Tendsto (fun x => -f x) l atTop ‚Üî Tendsto f l atBot :=
  (OrderIso.neg Œ≤).tendsto_atBot_iff
#align filter.tendsto_neg_at_top_iff Filter.tendsto_neg_atTop_iff

@[simp]
theorem tendsto_neg_atBot_iff : Tendsto (fun x => -f x) l atBot ‚Üî Tendsto f l atTop :=
  (OrderIso.neg Œ≤).tendsto_atTop_iff
#align filter.tendsto_neg_at_bot_iff Filter.tendsto_neg_atBot_iff

end OrderedGroup

section OrderedSemiring

variable [OrderedSemiring Œ±] {l : Filter Œ≤} {f g : Œ≤ ‚Üí Œ±}

set_option linter.deprecated false in
@[deprecated] theorem tendsto_bit1_atTop : Tendsto bit1 (atTop : Filter Œ±) atTop :=
  tendsto_atTop_add_nonneg_right tendsto_bit0_atTop fun _ => zero_le_one
#align filter.tendsto_bit1_at_top Filter.tendsto_bit1_atTop

theorem Tendsto.atTop_mul_atTop (hf : Tendsto f l atTop) (hg : Tendsto g l atTop) :
    Tendsto (fun x => f x * g x) l atTop := by
  refine' tendsto_atTop_mono' _ _ hg
  filter_upwards [hg.eventually (eventually_ge_atTop 0),
    hf.eventually (eventually_ge_atTop 1)] with _ using le_mul_of_one_le_left
#align filter.tendsto.at_top_mul_at_top Filter.Tendsto.atTop_mul_atTop

theorem tendsto_mul_self_atTop : Tendsto (fun x : Œ± => x * x) atTop atTop :=
  tendsto_id.atTop_mul_atTop tendsto_id
#align filter.tendsto_mul_self_at_top Filter.tendsto_mul_self_atTop

/-- The monomial function `x^n` tends to `+‚àû` at `+‚àû` for any positive natural `n`.
A version for positive real powers exists as `tendsto_rpow_atTop`. -/
theorem tendsto_pow_atTop {n : ‚Ñï} (hn : n ‚â† 0) : Tendsto (fun x : Œ± => x ^ n) atTop atTop :=
  tendsto_atTop_mono' _ ((eventually_ge_atTop 1).mono fun _x hx => le_self_pow hx hn) tendsto_id
#align filter.tendsto_pow_at_top Filter.tendsto_pow_atTop

end OrderedSemiring

theorem zero_pow_eventuallyEq [MonoidWithZero Œ±] :
    (fun n : ‚Ñï => (0 : Œ±) ^ n) =·∂†[atTop] fun _ => 0 :=
  eventually_atTop.2 ‚ü®1, fun _n hn ‚Ü¶ zero_pow $ Nat.one_le_iff_ne_zero.1 hn‚ü©
#align filter.zero_pow_eventually_eq Filter.zero_pow_eventuallyEq

section OrderedRing

variable [OrderedRing Œ±] {l : Filter Œ≤} {f g : Œ≤ ‚Üí Œ±}

theorem Tendsto.atTop_mul_atBot (hf : Tendsto f l atTop) (hg : Tendsto g l atBot) :
    Tendsto (fun x => f x * g x) l atBot := by
  have := hf.atTop_mul_atTop <| tendsto_neg_atBot_atTop.comp hg
  simpa only [(¬∑ ‚àò ¬∑), neg_mul_eq_mul_neg, neg_neg] using tendsto_neg_atTop_atBot.comp this
#align filter.tendsto.at_top_mul_at_bot Filter.Tendsto.atTop_mul_atBot

theorem Tendsto.atBot_mul_atTop (hf : Tendsto f l atBot) (hg : Tendsto g l atTop) :
    Tendsto (fun x => f x * g x) l atBot := by
  have : Tendsto (fun x => -f x * g x) l atTop :=
    (tendsto_neg_atBot_atTop.comp hf).atTop_mul_atTop hg
  simpa only [(¬∑ ‚àò ¬∑), neg_mul_eq_neg_mul, neg_neg] using tendsto_neg_atTop_atBot.comp this
#align filter.tendsto.at_bot_mul_at_top Filter.Tendsto.atBot_mul_atTop

theorem Tendsto.atBot_mul_atBot (hf : Tendsto f l atBot) (hg : Tendsto g l atBot) :
    Tendsto (fun x => f x * g x) l atTop := by
  have : Tendsto (fun x => -f x * -g x) l atTop :=
    (tendsto_neg_atBot_atTop.comp hf).atTop_mul_atTop (tendsto_neg_atBot_atTop.comp hg)
  simpa only [neg_mul_neg] using this
#align filter.tendsto.at_bot_mul_at_bot Filter.Tendsto.atBot_mul_atBot

end OrderedRing

section LinearOrderedAddCommGroup

variable [LinearOrderedAddCommGroup Œ±]

/-- $\lim_{x\to+\infty}|x|=+\infty$ -/
theorem tendsto_abs_atTop_atTop : Tendsto (abs : Œ± ‚Üí Œ±) atTop atTop :=
  tendsto_atTop_mono le_abs_self tendsto_id
#align filter.tendsto_abs_at_top_at_top Filter.tendsto_abs_atTop_atTop

/-- $\lim_{x\to-\infty}|x|=+\infty$ -/
theorem tendsto_abs_atBot_atTop : Tendsto (abs : Œ± ‚Üí Œ±) atBot atTop :=
  tendsto_atTop_mono neg_le_abs tendsto_neg_atBot_atTop
#align filter.tendsto_abs_at_bot_at_top Filter.tendsto_abs_atBot_atTop

@[simp]
theorem comap_abs_atTop : comap (abs : Œ± ‚Üí Œ±) atTop = atBot ‚äî atTop := by
  refine'
    le_antisymm (((atTop_basis.comap _).le_basis_iff (atBot_basis.sup atTop_basis)).2 _)
      (sup_le tendsto_abs_atBot_atTop.le_comap tendsto_abs_atTop_atTop.le_comap)
  rintro ‚ü®a, b‚ü© -
  refine' ‚ü®max (-a) b, trivial, fun x hx => _‚ü©
  rw [mem_preimage, mem_Ici, le_abs', max_le_iff, ‚Üê min_neg_neg, le_min_iff, neg_neg] at hx
  exact hx.imp And.left And.right
#align filter.comap_abs_at_top Filter.comap_abs_atTop

end LinearOrderedAddCommGroup

section LinearOrderedSemiring

variable [LinearOrderedSemiring Œ±] {l : Filter Œ≤} {f : Œ≤ ‚Üí Œ±}

theorem Tendsto.atTop_of_const_mul {c : Œ±} (hc : 0 < c) (hf : Tendsto (fun x => c * f x) l atTop) :
    Tendsto f l atTop :=
  tendsto_atTop.2 fun b => (tendsto_atTop.1 hf (c * b)).mono
    fun _x hx => le_of_mul_le_mul_left hx hc
#align filter.tendsto.at_top_of_const_mul Filter.Tendsto.atTop_of_const_mul

theorem Tendsto.atTop_of_mul_const {c : Œ±} (hc : 0 < c) (hf : Tendsto (fun x => f x * c) l atTop) :
    Tendsto f l atTop :=
  tendsto_atTop.2 fun b => (tendsto_atTop.1 hf (b * c)).mono
    fun _x hx => le_of_mul_le_mul_right hx hc
#align filter.tendsto.at_top_of_mul_const Filter.Tendsto.atTop_of_mul_const

@[simp]
theorem tendsto_pow_atTop_iff {n : ‚Ñï} : Tendsto (fun x : Œ± => x ^ n) atTop atTop ‚Üî n ‚â† 0 :=
  ‚ü®fun h hn => by simp only [hn, pow_zero, not_tendsto_const_atTop] at h, tendsto_pow_atTop‚ü©
#align filter.tendsto_pow_at_top_iff Filter.tendsto_pow_atTop_iff

end LinearOrderedSemiring

-- porting note: todo: make `Odd` and `Even` available here, drop `bit1`
set_option linter.deprecated false in
theorem nonneg_of_eventually_pow_nonneg [LinearOrderedRing Œ±] {a : Œ±}
    (h : ‚àÄ·∂† n in atTop, 0 ‚â§ a ^ (n : ‚Ñï)) : 0 ‚â§ a :=
  let ‚ü®_n, hn‚ü© := (tendsto_bit1_atTop.eventually h).exists
  pow_bit1_nonneg_iff.1 hn
#align filter.nonneg_of_eventually_pow_nonneg Filter.nonneg_of_eventually_pow_nonneg

theorem not_tendsto_pow_atTop_atBot [LinearOrderedRing Œ±] :
    ‚àÄ {n : ‚Ñï}, ¬¨Tendsto (fun x : Œ± => x ^ n) atTop atBot
  | 0 => by simp [not_tendsto_const_atBot]
  | n + 1 => (tendsto_pow_atTop n.succ_ne_zero).not_tendsto disjoint_atTop_atBot
#align filter.not_tendsto_pow_at_top_at_bot Filter.not_tendsto_pow_atTop_atBot

section LinearOrderedSemifield

variable [LinearOrderedSemifield Œ±] {l : Filter Œ≤} {f : Œ≤ ‚Üí Œ±} {r c : Œ±} {n : ‚Ñï}

/-!
### Multiplication by constant: iff lemmas
-/


/-- If `r` is a positive constant, then `Œª x, r * f x` tends to infinity along a filter if and only
if `f` tends to infinity along the same filter. -/
theorem tendsto_const_mul_atTop_of_pos (hr : 0 < r) :
    Tendsto (fun x => r * f x) l atTop ‚Üî Tendsto f l atTop :=
  ‚ü®fun h => h.atTop_of_const_mul hr, fun h =>
    Tendsto.atTop_of_const_mul (inv_pos.2 hr) <| by simpa only [inv_mul_cancel_left‚ÇÄ hr.ne'] ‚ü©
#align filter.tendsto_const_mul_at_top_of_pos Filter.tendsto_const_mul_atTop_of_pos

/-- If `r` is a positive constant, then `Œª x, f x * r` tends to infinity along a filter if and only
if `f` tends to infinity along the same filter. -/
theorem tendsto_mul_const_atTop_of_pos (hr : 0 < r) :
    Tendsto (fun x => f x * r) l atTop ‚Üî Tendsto f l atTop := by
  simpa only [mul_comm] using tendsto_const_mul_atTop_of_pos hr
#align filter.tendsto_mul_const_at_top_of_pos Filter.tendsto_mul_const_atTop_of_pos

/-- If `r` is a positive constant, then `x ‚Ü¶ f x / r` tends to infinity along a filter if and only
if `f` tends to infinity along the same filter. -/
lemma tendsto_div_const_atTop_of_pos (hr : 0 < r) :
    Tendsto (Œª x ‚Ü¶ f x / r) l atTop ‚Üî Tendsto f l atTop := by
  simpa only [div_eq_mul_inv] using tendsto_mul_const_atTop_of_pos (inv_pos.2 hr)

/-- If `f` tends to infinity along a nontrivial filter `l`, then `fun x ‚Ü¶ r * f x` tends to infinity
if and only if `0 < r. `-/
theorem tendsto_const_mul_atTop_iff_pos [NeBot l] (h : Tendsto f l atTop) :
    Tendsto (fun x => r * f x) l atTop ‚Üî 0 < r := by
  refine' ‚ü®fun hrf => not_le.mp fun hr => _, fun hr => (tendsto_const_mul_atTop_of_pos hr).mpr h‚ü©
  rcases ((h.eventually_ge_atTop 0).and (hrf.eventually_gt_atTop 0)).exists with ‚ü®x, hx, hrx‚ü©
  exact (mul_nonpos_of_nonpos_of_nonneg hr hx).not_lt hrx
#align filter.tendsto_const_mul_at_top_iff_pos Filter.tendsto_const_mul_atTop_iff_pos

/-- If `f` tends to infinity along a nontrivial filter `l`, then `fun x ‚Ü¶ f x * r` tends to infinity
if and only if `0 < r. `-/
theorem tendsto_mul_const_atTop_iff_pos [NeBot l] (h : Tendsto f l atTop) :
    Tendsto (fun x => f x * r) l atTop ‚Üî 0 < r := by
  simp only [mul_comm _ r, tendsto_const_mul_atTop_iff_pos h]
#align filter.tendsto_mul_const_at_top_iff_pos Filter.tendsto_mul_const_atTop_iff_pos

/-- If `f` tends to infinity along a nontrivial filter `l`, then `x ‚Ü¶ f x * r` tends to infinity
if and only if `0 < r. `-/
lemma tendsto_div_const_atTop_iff_pos [NeBot l] (h : Tendsto f l atTop) :
    Tendsto (Œª x ‚Ü¶ f x / r) l atTop ‚Üî 0 < r := by
  simp only [div_eq_mul_inv, tendsto_mul_const_atTop_iff_pos h, inv_pos]

/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the left) also tends to infinity. For a version working in `‚Ñï` or `‚Ñ§`, use
`filter.tendsto.const_mul_atTop'` instead. -/
theorem Tendsto.const_mul_atTop (hr : 0 < r) (hf : Tendsto f l atTop) :
    Tendsto (fun x => r * f x) l atTop :=
  (tendsto_const_mul_atTop_of_pos hr).2 hf
#align filter.tendsto.const_mul_at_top Filter.Tendsto.const_mul_atTop

/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the right) also tends to infinity. For a version working in `‚Ñï` or `‚Ñ§`, use
`filter.tendsto.atTop_mul_const'` instead. -/
theorem Tendsto.atTop_mul_const (hr : 0 < r) (hf : Tendsto f l atTop) :
    Tendsto (fun x => f x * r) l atTop :=
  (tendsto_mul_const_atTop_of_pos hr).2 hf
#align filter.tendsto.at_top_mul_const Filter.Tendsto.atTop_mul_const

/-- If a function tends to infinity along a filter, then this function divided by a positive
constant also tends to infinity. -/
theorem Tendsto.atTop_div_const (hr : 0 < r) (hf : Tendsto f l atTop) :
    Tendsto (fun x => f x / r) l atTop := by
  simpa only [div_eq_mul_inv] using hf.atTop_mul_const (inv_pos.2 hr)
#align filter.tendsto.at_top_div_const Filter.Tendsto.atTop_div_const

theorem tendsto_const_mul_pow_atTop (hn : n ‚â† 0) (hc : 0 < c) :
    Tendsto (fun x => c * x ^ n) atTop atTop :=
  Tendsto.const_mul_atTop hc (tendsto_pow_atTop hn)
#align filter.tendsto_const_mul_pow_at_top Filter.tendsto_const_mul_pow_atTop

theorem tendsto_const_mul_pow_atTop_iff :
    Tendsto (fun x => c * x ^ n) atTop atTop ‚Üî n ‚â† 0 ‚àß 0 < c := by
  refine' ‚ü®fun h => ‚ü®_, _‚ü©, fun h => tendsto_const_mul_pow_atTop h.1 h.2‚ü©
  ¬∑ rintro rfl
    simp only [pow_zero, not_tendsto_const_atTop] at h
  ¬∑ rcases ((h.eventually_gt_atTop 0).and (eventually_ge_atTop 0)).exists with ‚ü®k, hck, hk‚ü©
    exact pos_of_mul_pos_left hck (pow_nonneg hk _)
#align filter.tendsto_const_mul_pow_at_top_iff Filter.tendsto_const_mul_pow_atTop_iff

lemma tendsto_zpow_atTop_atTop {n : ‚Ñ§} (hn : 0 < n) : Tendsto (fun x : Œ± ‚Ü¶ x ^ n) atTop atTop := by
  lift n to ‚Ñï+ using hn; simp
#align tendsto_zpow_at_top_at_top Filter.tendsto_zpow_atTop_atTop

end LinearOrderedSemifield

section LinearOrderedField

variable [LinearOrderedField Œ±] {l : Filter Œ≤} {f : Œ≤ ‚Üí Œ±} {r : Œ±}

/-- If `r` is a positive constant, then `Œª x, r * f x` tends to negative infinity along a filter if
and only if `f` tends to negative infinity along the same filter. -/
theorem tendsto_const_mul_atBot_of_pos (hr : 0 < r) :
    Tendsto (fun x => r * f x) l atBot ‚Üî Tendsto f l atBot := by
  simpa only [‚Üê mul_neg, ‚Üê tendsto_neg_atTop_iff] using tendsto_const_mul_atTop_of_pos hr
#align filter.tendsto_const_mul_at_bot_of_pos Filter.tendsto_const_mul_atBot_of_pos

/-- If `r` is a positive constant, then `Œª x, f x * r` tends to negative infinity along a filter if
and only if `f` tends to negative infinity along the same filter. -/
theorem tendsto_mul_const_atBot_of_pos (hr : 0 < r) :
    Tendsto (fun x => f x * r) l atBot ‚Üî Tendsto f l atBot := by
  simpa only [mul_comm] using tendsto_const_mul_atBot_of_pos hr
#align filter.tendsto_mul_const_at_bot_of_pos Filter.tendsto_mul_const_atBot_of_pos

/-- If `r` is a negative constant, then `Œª x, r * f x` tends to infinity along a filter if and only
if `f` tends to negative infinity along the same filter. -/
theorem tendsto_const_mul_atTop_of_neg (hr : r < 0) :
    Tendsto (fun x => r * f x) l atTop ‚Üî Tendsto f l atBot := by
  simpa only [neg_mul, tendsto_neg_atBot_iff] using tendsto_const_mul_atBot_of_pos (neg_pos.2 hr)
#align filter.tendsto_const_mul_at_top_of_neg Filter.tendsto_const_mul_atTop_of_neg

/-- If `r` is a negative constant, then `Œª x, f x * r` tends to infinity along a filter if and only
if `f` tends to negative infinity along the same filter. -/
theorem tendsto_mul_const_atTop_of_neg (hr : r < 0) :
    Tendsto (fun x => f x * r) l atTop ‚Üî Tendsto f l atBot := by
  simpa only [mul_comm] using tendsto_const_mul_atTop_of_neg hr
#align filter.tendsto_mul_const_at_top_of_neg Filter.tendsto_mul_const_atTop_of_neg

/-- If `r` is a negative constant, then `Œª x, r * f x` tends to negative infinity along a filter if
and only if `f` tends to infinity along the same filter. -/
theorem tendsto_const_mul_atBot_of_neg (hr : r < 0) :
    Tendsto (fun x => r * f x) l atBot ‚Üî Tendsto f l atTop := by
  simpa only [neg_mul, tendsto_neg_atTop_iff] using tendsto_const_mul_atTop_of_pos (neg_pos.2 hr)
#align filter.tendsto_const_mul_at_bot_of_neg Filter.tendsto_const_mul_atBot_of_neg

/-- If `r` is a negative constant, then `Œª x, f x * r` tends to negative infinity along a filter if
and only if `f` tends to infinity along the same filter. -/
theorem tendsto_mul_const_atBot_of_neg (hr : r < 0) :
    Tendsto (fun x => f x * r) l atBot ‚Üî Tendsto f l atTop := by
  simpa only [mul_comm] using tendsto_const_mul_atBot_of_neg hr
#align filter.tendsto_mul_const_at_bot_of_neg Filter.tendsto_mul_const_atBot_of_neg

/-- The function `Œª x, r * f x` tends to infinity along a nontrivial filter if and only if `r > 0`
and `f` tends to infinity or `r < 0` and `f` tends to negative infinity. -/
theorem tendsto_const_mul_atTop_iff [NeBot l] :
    Tendsto (fun x => r * f x) l atTop ‚Üî 0 < r ‚àß Tendsto f l atTop ‚à® r < 0 ‚àß Tendsto f l atBot := by
  rcases lt_trichotomy r 0 with (hr | rfl | hr)
  ¬∑ simp [hr, hr.not_lt, tendsto_const_mul_atTop_of_neg]
  ¬∑ simp [not_tendsto_const_atTop]
  ¬∑ simp [hr, hr.not_lt, tendsto_const_mul_atTop_of_pos]
#align filter.tendsto_const_mul_at_top_iff Filter.tendsto_const_mul_atTop_iff

/-- The function `Œª x, f x * r` tends to infinity along a nontrivial filter if and only if `r > 0`
and `f` tends to infinity or `r < 0` and `f` tends to negative infinity. -/
theorem tendsto_mul_const_atTop_iff [NeBot l] :
    Tendsto (fun x => f x * r) l atTop ‚Üî 0 < r ‚àß Tendsto f l atTop ‚à® r < 0 ‚àß Tendsto f l atBot := by
  simp only [mul_comm _ r, tendsto_const_mul_atTop_iff]
#align filter.tendsto_mul_const_at_top_iff Filter.tendsto_mul_const_atTop_iff

/-- The function `Œª x, r * f x` tends to negative infinity along a nontrivial filter if and only if
`r > 0` and `f` tends to negative infinity or `r < 0` and `f` tends to infinity. -/
theorem tendsto_const_mul_atBot_iff [NeBot l] :
    Tendsto (fun x => r * f x) l atBot ‚Üî 0 < r ‚àß Tendsto f l atBot ‚à® r < 0 ‚àß Tendsto f l atTop := by
  simp only [‚Üê tendsto_neg_atTop_iff, ‚Üê mul_neg, tendsto_const_mul_atTop_iff, neg_neg]
#align filter.tendsto_const_mul_at_bot_iff Filter.tendsto_const_mul_atBot_iff

/-- The function `Œª x, f x * r` tends to negative infinity along a nontrivial filter if and only if
`r > 0` and `f` tends to negative infinity or `r < 0` and `f` tends to infinity. -/
theorem tendsto_mul_const_atBot_iff [NeBot l] :
    Tendsto (fun x => f x * r) l atBot ‚Üî 0 < r ‚àß Tendsto f l atBot ‚à® r < 0 ‚àß Tendsto f l atTop := by
  simp only [mul_comm _ r, tendsto_const_mul_atBot_iff]
#align filter.tendsto_mul_const_at_bot_iff Filter.tendsto_mul_const_atBot_iff

/-- If `f` tends to negative infinity along a nontrivial filter `l`, then `fun x ‚Ü¶ r * f x` tends to
infinity if and only if `r < 0. `-/
theorem tendsto_const_mul_atTop_iff_neg [NeBot l] (h : Tendsto f l atBot) :
    Tendsto (fun x => r * f x) l atTop ‚Üî r < 0 := by
  simp [tendsto_const_mul_atTop_iff, h, h.not_tendsto disjoint_atBot_atTop]
#align filter.tendsto_const_mul_at_top_iff_neg Filter.tendsto_const_mul_atTop_iff_neg

/-- If `f` tends to negative infinity along a nontrivial filter `l`, then `fun x ‚Ü¶ f x * r` tends to
infinity if and only if `r < 0. `-/
theorem tendsto_mul_const_atTop_iff_neg [NeBot l] (h : Tendsto f l atBot) :
    Tendsto (fun x => f x * r) l atTop ‚Üî r < 0 := by
  simp only [mul_comm _ r, tendsto_const_mul_atTop_iff_neg h]
#align filter.tendsto_mul_const_at_top_iff_neg Filter.tendsto_mul_const_atTop_iff_neg

/-- If `f` tends to negative infinity along a nontrivial filter `l`, then `fun x ‚Ü¶ r * f x` tends to
negative infinity if and only if `0 < r. `-/
theorem tendsto_const_mul_atBot_iff_pos [NeBot l] (h : Tendsto f l atBot) :
    Tendsto (fun x => r * f x) l atBot ‚Üî 0 < r := by
  simp [tendsto_const_mul_atBot_iff, h, h.not_tendsto disjoint_atBot_atTop]
#align filter.tendsto_const_mul_at_bot_iff_pos Filter.tendsto_const_mul_atBot_iff_pos

/-- If `f` tends to negative infinity along a nontrivial filter `l`, then `fun x ‚Ü¶ f x * r` tends to
negative infinity if and only if `0 < r. `-/
theorem tendsto_mul_const_atBot_iff_pos [NeBot l] (h : Tendsto f l atBot) :
    Tendsto (fun x => f x * r) l atBot ‚Üî 0 < r := by
  simp only [mul_comm _ r, tendsto_const_mul_atBot_iff_pos h]
#align filter.tendsto_mul_const_at_bot_iff_pos Filter.tendsto_mul_const_atBot_iff_pos

/-- If `f` tends to infinity along a nontrivial filter `l`, then `fun x ‚Ü¶ r * f x` tends to negative
infinity if and only if `r < 0. `-/
theorem tendsto_const_mul_atBot_iff_neg [NeBot l] (h : Tendsto f l atTop) :
    Tendsto (fun x => r * f x) l atBot ‚Üî r < 0 := by
  simp [tendsto_const_mul_atBot_iff, h, h.not_tendsto disjoint_atTop_atBot]
#align filter.tendsto_const_mul_at_bot_iff_neg Filter.tendsto_const_mul_atBot_iff_neg

/-- If `f` tends to infinity along a nontrivial filter `l`, then `fun x ‚Ü¶ f x * r` tends to negative
infinity if and only if `r < 0. `-/
theorem tendsto_mul_const_atBot_iff_neg [NeBot l] (h : Tendsto f l atTop) :
    Tendsto (fun x => f x * r) l atBot ‚Üî r < 0 := by
  simp only [mul_comm _ r, tendsto_const_mul_atBot_iff_neg h]
#align filter.tendsto_mul_const_at_bot_iff_neg Filter.tendsto_mul_const_atBot_iff_neg

/-- If a function tends to infinity along a filter, then this function multiplied by a negative
constant (on the left) tends to negative infinity. -/
theorem Tendsto.neg_const_mul_atTop (hr : r < 0) (hf : Tendsto f l atTop) :
    Tendsto (fun x => r * f x) l atBot :=
  (tendsto_const_mul_atBot_of_neg hr).2 hf
#align filter.tendsto.neg_const_mul_at_top Filter.Tendsto.neg_const_mul_atTop

/-- If a function tends to infinity along a filter, then this function multiplied by a negative
constant (on the right) tends to negative infinity. -/
theorem Tendsto.atTop_mul_neg_const (hr : r < 0) (hf : Tendsto f l atTop) :
    Tendsto (fun x => f x * r) l atBot :=
  (tendsto_mul_const_atBot_of_neg hr).2 hf
#align filter.tendsto.at_top_mul_neg_const Filter.Tendsto.atTop_mul_neg_const

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a positive constant (on the left) also tends to negative infinity. -/
theorem Tendsto.const_mul_atBot (hr : 0 < r) (hf : Tendsto f l atBot) :
    Tendsto (fun x => r * f x) l atBot :=
  (tendsto_const_mul_atBot_of_pos hr).2 hf
#align filter.tendsto.const_mul_at_bot Filter.Tendsto.const_mul_atBot

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a positive constant (on the right) also tends to negative infinity. -/
theorem Tendsto.atBot_mul_const (hr : 0 < r) (hf : Tendsto f l atBot) :
    Tendsto (fun x => f x * r) l atBot :=
  (tendsto_mul_const_atBot_of_pos hr).2 hf
#align filter.tendsto.at_bot_mul_const Filter.Tendsto.atBot_mul_const

/-- If a function tends to negative infinity along a filter, then this function divided by
a positive constant also tends to negative infinity. -/
theorem Tendsto.atBot_div_const (hr : 0 < r) (hf : Tendsto f l atBot) :
    Tendsto (fun x => f x / r) l atBot := by
  simpa only [div_eq_mul_inv] using hf.atBot_mul_const (inv_pos.2 hr)
#align filter.tendsto.at_bot_div_const Filter.Tendsto.atBot_div_const

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a negative constant (on the left) tends to positive infinity. -/
theorem Tendsto.neg_const_mul_atBot (hr : r < 0) (hf : Tendsto f l atBot) :
    Tendsto (fun x => r * f x) l atTop :=
  (tendsto_const_mul_atTop_of_neg hr).2 hf
#align filter.tendsto.neg_const_mul_at_bot Filter.Tendsto.neg_const_mul_atBot

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a negative constant (on the right) tends to positive infinity. -/
theorem Tendsto.atBot_mul_neg_const (hr : r < 0) (hf : Tendsto f l atBot) :
    Tendsto (fun x => f x * r) l atTop :=
  (tendsto_mul_const_atTop_of_neg hr).2 hf
#align filter.tendsto.at_bot_mul_neg_const Filter.Tendsto.atBot_mul_neg_const

theorem tendsto_neg_const_mul_pow_atTop {c : Œ±} {n : ‚Ñï} (hn : n ‚â† 0) (hc : c < 0) :
    Tendsto (fun x => c * x ^ n) atTop atBot :=
  Tendsto.neg_const_mul_atTop hc (tendsto_pow_atTop hn)
#align filter.tendsto_neg_const_mul_pow_at_top Filter.tendsto_neg_const_mul_pow_atTop

theorem tendsto_const_mul_pow_atBot_iff {c : Œ±} {n : ‚Ñï} :
    Tendsto (fun x => c * x ^ n) atTop atBot ‚Üî n ‚â† 0 ‚àß c < 0 := by
  simp only [‚Üê tendsto_neg_atTop_iff, ‚Üê neg_mul, tendsto_const_mul_pow_atTop_iff, neg_pos]
#align filter.tendsto_const_mul_pow_at_bot_iff Filter.tendsto_const_mul_pow_atBot_iff

end LinearOrderedField

open Filter

theorem tendsto_atTop' [Nonempty Œ±] [SemilatticeSup Œ±] {f : Œ± ‚Üí Œ≤} {l : Filter Œ≤} :
    Tendsto f atTop l ‚Üî ‚àÄ s ‚àà l, ‚àÉ a, ‚àÄ b ‚â• a, f b ‚àà s := by
  simp only [tendsto_def, mem_atTop_sets]; rfl
#align filter.tendsto_at_top' Filter.tendsto_atTop'

theorem tendsto_atBot' [Nonempty Œ±] [SemilatticeInf Œ±] {f : Œ± ‚Üí Œ≤} {l : Filter Œ≤} :
    Tendsto f atBot l ‚Üî ‚àÄ s ‚àà l, ‚àÉ a, ‚àÄ b ‚â§ a, f b ‚àà s :=
  @tendsto_atTop' Œ±·µí·µà _ _ _ _ _
#align filter.tendsto_at_bot' Filter.tendsto_atBot'

theorem tendsto_atTop_principal [Nonempty Œ≤] [SemilatticeSup Œ≤] {f : Œ≤ ‚Üí Œ±} {s : Set Œ±} :
    Tendsto f atTop (ùìü s) ‚Üî ‚àÉ N, ‚àÄ n ‚â• N, f n ‚àà s := by
  rw [tendsto_iff_comap, comap_principal, le_principal_iff, mem_atTop_sets]; rfl
#align filter.tendsto_at_top_principal Filter.tendsto_atTop_principal

theorem tendsto_atBot_principal [Nonempty Œ≤] [SemilatticeInf Œ≤] {f : Œ≤ ‚Üí Œ±} {s : Set Œ±} :
    Tendsto f atBot (ùìü s) ‚Üî ‚àÉ N, ‚àÄ n ‚â§ N, f n ‚àà s :=
  @tendsto_atTop_principal _ Œ≤·µí·µà _ _ _ _
#align filter.tendsto_at_bot_principal Filter.tendsto_atBot_principal

/-- A function `f` grows to `+‚àû` independent of an order-preserving embedding `e`. -/
theorem tendsto_atTop_atTop [Nonempty Œ±] [SemilatticeSup Œ±] [Preorder Œ≤] {f : Œ± ‚Üí Œ≤} :
    Tendsto f atTop atTop ‚Üî ‚àÄ b : Œ≤, ‚àÉ i : Œ±, ‚àÄ a : Œ±, i ‚â§ a ‚Üí b ‚â§ f a :=
  Iff.trans tendsto_iInf <| forall_congr' fun _ => tendsto_atTop_principal
#align filter.tendsto_at_top_at_top Filter.tendsto_atTop_atTop

theorem tendsto_atTop_atBot [Nonempty Œ±] [SemilatticeSup Œ±] [Preorder Œ≤] {f : Œ± ‚Üí Œ≤} :
    Tendsto f atTop atBot ‚Üî ‚àÄ b : Œ≤, ‚àÉ i : Œ±, ‚àÄ a : Œ±, i ‚â§ a ‚Üí f a ‚â§ b :=
  @tendsto_atTop_atTop Œ± Œ≤·µí·µà _ _ _ f
#align filter.tendsto_at_top_at_bot Filter.tendsto_atTop_atBot

theorem tendsto_atBot_atTop [Nonempty Œ±] [SemilatticeInf Œ±] [Preorder Œ≤] {f : Œ± ‚Üí Œ≤} :
    Tendsto f atBot atTop ‚Üî ‚àÄ b : Œ≤, ‚àÉ i : Œ±, ‚àÄ a : Œ±, a ‚â§ i ‚Üí b ‚â§ f a :=
  @tendsto_atTop_atTop Œ±·µí·µà Œ≤ _ _ _ f
#align filter.tendsto_at_bot_at_top Filter.tendsto_atBot_atTop

theorem tendsto_atBot_atBot [Nonempty Œ±] [SemilatticeInf Œ±] [Preorder Œ≤] {f : Œ± ‚Üí Œ≤} :
    Tendsto f atBot atBot ‚Üî ‚àÄ b : Œ≤, ‚àÉ i : Œ±, ‚àÄ a : Œ±, a ‚â§ i ‚Üí f a ‚â§ b :=
  @tendsto_atTop_atTop Œ±·µí·µà Œ≤·µí·µà _ _ _ f
#align filter.tendsto_at_bot_at_bot Filter.tendsto_atBot_atBot

theorem tendsto_atTop_atTop_of_monotone [Preorder Œ±] [Preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : Monotone f)
    (h : ‚àÄ b, ‚àÉ a, b ‚â§ f a) : Tendsto f atTop atTop :=
  tendsto_iInf.2 fun b =>
    tendsto_principal.2 <|
      let ‚ü®a, ha‚ü© := h b
      mem_of_superset (mem_atTop a) fun _a' ha' => le_trans ha (hf ha')
#align filter.tendsto_at_top_at_top_of_monotone Filter.tendsto_atTop_atTop_of_monotone

theorem tendsto_atBot_atBot_of_monotone [Preorder Œ±] [Preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : Monotone f)
    (h : ‚àÄ b, ‚àÉ a, f a ‚â§ b) : Tendsto f atBot atBot :=
  tendsto_iInf.2 fun b => tendsto_principal.2 <|
    let ‚ü®a, ha‚ü© := h b; mem_of_superset (mem_atBot a) fun _a' ha' => le_trans (hf ha') ha
#align filter.tendsto_at_bot_at_bot_of_monotone Filter.tendsto_atBot_atBot_of_monotone

theorem tendsto_atTop_atTop_iff_of_monotone [Nonempty Œ±] [SemilatticeSup Œ±] [Preorder Œ≤] {f : Œ± ‚Üí Œ≤}
    (hf : Monotone f) : Tendsto f atTop atTop ‚Üî ‚àÄ b : Œ≤, ‚àÉ a : Œ±, b ‚â§ f a :=
  tendsto_atTop_atTop.trans <| forall_congr' fun _ => exists_congr fun a =>
    ‚ü®fun h => h a (le_refl a), fun h _a' ha' => le_trans h <| hf ha'‚ü©
#align filter.tendsto_at_top_at_top_iff_of_monotone Filter.tendsto_atTop_atTop_iff_of_monotone

theorem tendsto_atBot_atBot_iff_of_monotone [Nonempty Œ±] [SemilatticeInf Œ±] [Preorder Œ≤] {f : Œ± ‚Üí Œ≤}
    (hf : Monotone f) : Tendsto f atBot atBot ‚Üî ‚àÄ b : Œ≤, ‚àÉ a : Œ±, f a ‚â§ b :=
  tendsto_atBot_atBot.trans <| forall_congr' fun _ => exists_congr fun a =>
    ‚ü®fun h => h a (le_refl a), fun h _a' ha' => le_trans (hf ha') h‚ü©
#align filter.tendsto_at_bot_at_bot_iff_of_monotone Filter.tendsto_atBot_atBot_iff_of_monotone

alias _root_.Monotone.tendsto_atTop_atTop := tendsto_atTop_atTop_of_monotone
#align monotone.tendsto_at_top_at_top Monotone.tendsto_atTop_atTop

alias _root_.Monotone.tendsto_atBot_atBot := tendsto_atBot_atBot_of_monotone
#align monotone.tendsto_at_bot_at_bot Monotone.tendsto_atBot_atBot

alias _root_.Monotone.tendsto_atTop_atTop_iff := tendsto_atTop_atTop_iff_of_monotone
#align monotone.tendsto_at_top_at_top_iff Monotone.tendsto_atTop_atTop_iff

alias _root_.Monotone.tendsto_atBot_atBot_iff := tendsto_atBot_atBot_iff_of_monotone
#align monotone.tendsto_at_bot_at_bot_iff Monotone.tendsto_atBot_atBot_iff

theorem comap_embedding_atTop [Preorder Œ≤] [Preorder Œ≥] {e : Œ≤ ‚Üí Œ≥}
    (hm : ‚àÄ b‚ÇÅ b‚ÇÇ, e b‚ÇÅ ‚â§ e b‚ÇÇ ‚Üî b‚ÇÅ ‚â§ b‚ÇÇ) (hu : ‚àÄ c, ‚àÉ b, c ‚â§ e b) : comap e atTop = atTop :=
  le_antisymm
    (le_iInf fun b =>
      le_principal_iff.2 <| mem_comap.2 ‚ü®Ici (e b), mem_atTop _, fun _ => (hm _ _).1‚ü©)
    (tendsto_atTop_atTop_of_monotone (fun _ _ => (hm _ _).2) hu).le_comap
#align filter.comap_embedding_at_top Filter.comap_embedding_atTop

theorem comap_embedding_atBot [Preorder Œ≤] [Preorder Œ≥] {e : Œ≤ ‚Üí Œ≥}
    (hm : ‚àÄ b‚ÇÅ b‚ÇÇ, e b‚ÇÅ ‚â§ e b‚ÇÇ ‚Üî b‚ÇÅ ‚â§ b‚ÇÇ) (hu : ‚àÄ c, ‚àÉ b, e b ‚â§ c) : comap e atBot = atBot :=
  @comap_embedding_atTop Œ≤·µí·µà Œ≥·µí·µà _ _ e (Function.swap hm) hu
#align filter.comap_embedding_at_bot Filter.comap_embedding_atBot

theorem tendsto_atTop_embedding [Preorder Œ≤] [Preorder Œ≥] {f : Œ± ‚Üí Œ≤} {e : Œ≤ ‚Üí Œ≥} {l : Filter Œ±}
    (hm : ‚àÄ b‚ÇÅ b‚ÇÇ, e b‚ÇÅ ‚â§ e b‚ÇÇ ‚Üî b‚ÇÅ ‚â§ b‚ÇÇ) (hu : ‚àÄ c, ‚àÉ b, c ‚â§ e b) :
    Tendsto (e ‚àò f) l atTop ‚Üî Tendsto f l atTop := by
  rw [‚Üê comap_embedding_atTop hm hu, tendsto_comap_iff]
#align filter.tendsto_at_top_embedding Filter.tendsto_atTop_embedding

/-- A function `f` goes to `-‚àû` independent of an order-preserving embedding `e`. -/
theorem tendsto_atBot_embedding [Preorder Œ≤] [Preorder Œ≥] {f : Œ± ‚Üí Œ≤} {e : Œ≤ ‚Üí Œ≥} {l : Filter Œ±}
    (hm : ‚àÄ b‚ÇÅ b‚ÇÇ, e b‚ÇÅ ‚â§ e b‚ÇÇ ‚Üî b‚ÇÅ ‚â§ b‚ÇÇ) (hu : ‚àÄ c, ‚àÉ b, e b ‚â§ c) :
    Tendsto (e ‚àò f) l atBot ‚Üî Tendsto f l atBot :=
  @tendsto_atTop_embedding Œ± Œ≤·µí·µà Œ≥·µí·µà _ _ f e l (Function.swap hm) hu
#align filter.tendsto_at_bot_embedding Filter.tendsto_atBot_embedding

theorem tendsto_finset_range : Tendsto Finset.range atTop atTop :=
  Finset.range_mono.tendsto_atTop_atTop Finset.exists_nat_subset_range
#align filter.tendsto_finset_range Filter.tendsto_finset_range

theorem atTop_finset_eq_iInf : (atTop : Filter (Finset Œ±)) = ‚®Ö x : Œ±, ùìü (Ici {x}) := by
  refine' le_antisymm (le_iInf fun i => le_principal_iff.2 <| mem_atTop {i}) _
  refine'
    le_iInf fun s =>
      le_principal_iff.2 <| mem_iInf_of_iInter s.finite_toSet (fun i => mem_principal_self _) _
  simp only [subset_def, mem_iInter, SetCoe.forall, mem_Ici, Finset.le_iff_subset,
    Finset.mem_singleton, Finset.subset_iff, forall_eq]
  exact fun t => id
#align filter.at_top_finset_eq_infi Filter.atTop_finset_eq_iInf

/-- If `f` is a monotone sequence of `Finset`s and each `x` belongs to one of `f n`, then
`Tendsto f atTop atTop`. -/
theorem tendsto_atTop_finset_of_monotone [Preorder Œ≤] {f : Œ≤ ‚Üí Finset Œ±} (h : Monotone f)
    (h' : ‚àÄ x : Œ±, ‚àÉ n, x ‚àà f n) : Tendsto f atTop atTop := by
  simp only [atTop_finset_eq_iInf, tendsto_iInf, tendsto_principal]
  intro a
  rcases h' a with ‚ü®b, hb‚ü©
  exact (eventually_ge_atTop b).mono fun b' hb' => (Finset.singleton_subset_iff.2 hb).trans (h hb')
#align filter.tendsto_at_top_finset_of_monotone Filter.tendsto_atTop_finset_of_monotone

alias _root_.Monotone.tendsto_atTop_finset := tendsto_atTop_finset_of_monotone
#align monotone.tendsto_at_top_finset Monotone.tendsto_atTop_finset

-- porting note: add assumption `DecidableEq Œ≤` so that the lemma applies to any instance
theorem tendsto_finset_image_atTop_atTop [DecidableEq Œ≤] {i : Œ≤ ‚Üí Œ≥} {j : Œ≥ ‚Üí Œ≤}
    (h : Function.LeftInverse j i) : Tendsto (Finset.image j) atTop atTop :=
  (Finset.image_mono j).tendsto_atTop_finset fun a =>
    ‚ü®{i a}, by simp only [Finset.image_singleton, h a, Finset.mem_singleton]‚ü©
#align filter.tendsto_finset_image_at_top_at_top Filter.tendsto_finset_image_atTop_atTop

theorem tendsto_finset_preimage_atTop_atTop {f : Œ± ‚Üí Œ≤} (hf : Function.Injective f) :
    Tendsto (fun s : Finset Œ≤ => s.preimage f (hf.injOn _)) atTop atTop :=
  (Finset.monotone_preimage hf).tendsto_atTop_finset fun x =>
    ‚ü®{f x}, Finset.mem_preimage.2 <| Finset.mem_singleton_self _‚ü©
#align filter.tendsto_finset_preimage_at_top_at_top Filter.tendsto_finset_preimage_atTop_atTop

-- porting note: generalized from `SemilatticeSup` to `Preorder`
theorem prod_atTop_atTop_eq [Preorder Œ±] [Preorder Œ≤] :
    (atTop : Filter Œ±) √óÀ¢ (atTop : Filter Œ≤) = (atTop : Filter (Œ± √ó Œ≤)) := by
  cases isEmpty_or_nonempty Œ±; exact Subsingleton.elim _ _
  cases isEmpty_or_nonempty Œ≤; exact Subsingleton.elim _ _
  simpa [atTop, prod_iInf_left, prod_iInf_right, iInf_prod] using iInf_comm
#align filter.prod_at_top_at_top_eq Filter.prod_atTop_atTop_eq

-- porting note: generalized from `SemilatticeSup` to `Preorder`
theorem prod_atBot_atBot_eq [Preorder Œ≤‚ÇÅ] [Preorder Œ≤‚ÇÇ] :
    (atBot : Filter Œ≤‚ÇÅ) √óÀ¢ (atBot : Filter Œ≤‚ÇÇ) = (atBot : Filter (Œ≤‚ÇÅ √ó Œ≤‚ÇÇ)) :=
  @prod_atTop_atTop_eq Œ≤‚ÇÅ·µí·µà Œ≤‚ÇÇ·µí·µà _ _
#align filter.prod_at_bot_at_bot_eq Filter.prod_atBot_atBot_eq

-- porting note: generalized from `SemilatticeSup` to `Preorder`
theorem prod_map_atTop_eq {Œ±‚ÇÅ Œ±‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ : Type*} [Preorder Œ≤‚ÇÅ] [Preorder Œ≤‚ÇÇ]
    (u‚ÇÅ : Œ≤‚ÇÅ ‚Üí Œ±‚ÇÅ) (u‚ÇÇ : Œ≤‚ÇÇ ‚Üí Œ±‚ÇÇ) : map u‚ÇÅ atTop √óÀ¢ map u‚ÇÇ atTop = map (Prod.map u‚ÇÅ u‚ÇÇ) atTop := by
  rw [prod_map_map_eq, prod_atTop_atTop_eq, Prod.map_def]
#align filter.prod_map_at_top_eq Filter.prod_map_atTop_eq

-- porting note: generalized from `SemilatticeSup` to `Preorder`
theorem prod_map_atBot_eq {Œ±‚ÇÅ Œ±‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ : Type*} [Preorder Œ≤‚ÇÅ] [Preorder Œ≤‚ÇÇ]
    (u‚ÇÅ : Œ≤‚ÇÅ ‚Üí Œ±‚ÇÅ) (u‚ÇÇ : Œ≤‚ÇÇ ‚Üí Œ±‚ÇÇ) : map u‚ÇÅ atBot √óÀ¢ map u‚ÇÇ atBot = map (Prod.map u‚ÇÅ u‚ÇÇ) atBot :=
  @prod_map_atTop_eq _ _ Œ≤‚ÇÅ·µí·µà Œ≤‚ÇÇ·µí·µà _ _ _ _
#align filter.prod_map_at_bot_eq Filter.prod_map_atBot_eq

theorem Tendsto.subseq_mem {F : Filter Œ±} {V : ‚Ñï ‚Üí Set Œ±} (h : ‚àÄ n, V n ‚àà F) {u : ‚Ñï ‚Üí Œ±}
    (hu : Tendsto u atTop F) : ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, u (œÜ n) ‚àà V n :=
  extraction_forall_of_eventually'
    (fun n => tendsto_atTop'.mp hu _ (h n) : ‚àÄ n, ‚àÉ N, ‚àÄ k ‚â• N, u k ‚àà V n)
#align filter.tendsto.subseq_mem Filter.Tendsto.subseq_mem

theorem tendsto_atBot_diagonal [SemilatticeInf Œ±] : Tendsto (fun a : Œ± => (a, a)) atBot atBot := by
  rw [‚Üê prod_atBot_atBot_eq]
  exact tendsto_id.prod_mk tendsto_id
#align filter.tendsto_at_bot_diagonal Filter.tendsto_atBot_diagonal

theorem tendsto_atTop_diagonal [SemilatticeSup Œ±] : Tendsto (fun a : Œ± => (a, a)) atTop atTop := by
  rw [‚Üê prod_atTop_atTop_eq]
  exact tendsto_id.prod_mk tendsto_id
#align filter.tendsto_at_top_diagonal Filter.tendsto_atTop_diagonal

theorem Tendsto.prod_map_prod_atBot [SemilatticeInf Œ≥] {F : Filter Œ±} {G : Filter Œ≤} {f : Œ± ‚Üí Œ≥}
    {g : Œ≤ ‚Üí Œ≥} (hf : Tendsto f F atBot) (hg : Tendsto g G atBot) :
    Tendsto (Prod.map f g) (F √óÀ¢ G) atBot := by
  rw [‚Üê prod_atBot_atBot_eq]
  exact hf.prod_map hg
#align filter.tendsto.prod_map_prod_at_bot Filter.Tendsto.prod_map_prod_atBot

theorem Tendsto.prod_map_prod_atTop [SemilatticeSup Œ≥] {F : Filter Œ±} {G : Filter Œ≤} {f : Œ± ‚Üí Œ≥}
    {g : Œ≤ ‚Üí Œ≥} (hf : Tendsto f F atTop) (hg : Tendsto g G atTop) :
    Tendsto (Prod.map f g) (F √óÀ¢ G) atTop := by
  rw [‚Üê prod_atTop_atTop_eq]
  exact hf.prod_map hg
#align filter.tendsto.prod_map_prod_at_top Filter.Tendsto.prod_map_prod_atTop

theorem Tendsto.prod_atBot [SemilatticeInf Œ±] [SemilatticeInf Œ≥] {f g : Œ± ‚Üí Œ≥}
    (hf : Tendsto f atBot atBot) (hg : Tendsto g atBot atBot) :
    Tendsto (Prod.map f g) atBot atBot := by
  rw [‚Üê prod_atBot_atBot_eq]
  exact hf.prod_map_prod_atBot hg
#align filter.tendsto.prod_at_bot Filter.Tendsto.prod_atBot

theorem Tendsto.prod_atTop [SemilatticeSup Œ±] [SemilatticeSup Œ≥] {f g : Œ± ‚Üí Œ≥}
    (hf : Tendsto f atTop atTop) (hg : Tendsto g atTop atTop) :
    Tendsto (Prod.map f g) atTop atTop := by
  rw [‚Üê prod_atTop_atTop_eq]
  exact hf.prod_map_prod_atTop hg
#align filter.tendsto.prod_at_top Filter.Tendsto.prod_atTop

theorem eventually_atBot_prod_self [SemilatticeInf Œ±] [Nonempty Œ±] {p : Œ± √ó Œ± ‚Üí Prop} :
    (‚àÄ·∂† x in atBot, p x) ‚Üî ‚àÉ a, ‚àÄ k l, k ‚â§ a ‚Üí l ‚â§ a ‚Üí p (k, l) := by
  simp [‚Üê prod_atBot_atBot_eq, (@atBot_basis Œ± _ _).prod_self.eventually_iff]
#align filter.eventually_at_bot_prod_self Filter.eventually_atBot_prod_self

theorem eventually_atTop_prod_self [SemilatticeSup Œ±] [Nonempty Œ±] {p : Œ± √ó Œ± ‚Üí Prop} :
    (‚àÄ·∂† x in atTop, p x) ‚Üî ‚àÉ a, ‚àÄ k l, a ‚â§ k ‚Üí a ‚â§ l ‚Üí p (k, l) :=
  eventually_atBot_prod_self (Œ± := Œ±·µí·µà)
#align filter.eventually_at_top_prod_self Filter.eventually_atTop_prod_self

theorem eventually_atBot_prod_self' [SemilatticeInf Œ±] [Nonempty Œ±] {p : Œ± √ó Œ± ‚Üí Prop} :
    (‚àÄ·∂† x in atBot, p x) ‚Üî ‚àÉ a, ‚àÄ k ‚â§ a, ‚àÄ l ‚â§ a, p (k, l) := by
  simp only [eventually_atBot_prod_self, ball_cond_comm]
#align filter.eventually_at_bot_prod_self' Filter.eventually_atBot_prod_self'

theorem eventually_atTop_prod_self' [SemilatticeSup Œ±] [Nonempty Œ±] {p : Œ± √ó Œ± ‚Üí Prop} :
    (‚àÄ·∂† x in atTop, p x) ‚Üî ‚àÉ a, ‚àÄ k ‚â• a, ‚àÄ l ‚â• a, p (k, l) := by
  simp only [eventually_atTop_prod_self, ball_cond_comm]
#align filter.eventually_at_top_prod_self' Filter.eventually_atTop_prod_self'

theorem eventually_atTop_curry [SemilatticeSup Œ±] [SemilatticeSup Œ≤] {p : Œ± √ó Œ≤ ‚Üí Prop}
    (hp : ‚àÄ·∂† x : Œ± √ó Œ≤ in Filter.atTop, p x) : ‚àÄ·∂† k in atTop, ‚àÄ·∂† l in atTop, p (k, l) := by
  rw [‚Üê prod_atTop_atTop_eq] at hp
  exact hp.curry
#align filter.eventually_at_top_curry Filter.eventually_atTop_curry

theorem eventually_atBot_curry [SemilatticeInf Œ±] [SemilatticeInf Œ≤] {p : Œ± √ó Œ≤ ‚Üí Prop}
    (hp : ‚àÄ·∂† x : Œ± √ó Œ≤ in Filter.atBot, p x) : ‚àÄ·∂† k in atBot, ‚àÄ·∂† l in atBot, p (k, l) :=
  @eventually_atTop_curry Œ±·µí·µà Œ≤·µí·µà _ _ _ hp
#align filter.eventually_at_bot_curry Filter.eventually_atBot_curry

/-- A function `f` maps upwards closed sets (atTop sets) to upwards closed sets when it is a
Galois insertion. The Galois "insertion" and "connection" is weakened to only require it to be an
insertion and a connection above `b'`. -/
theorem map_atTop_eq_of_gc [SemilatticeSup Œ±] [SemilatticeSup Œ≤] {f : Œ± ‚Üí Œ≤} (g : Œ≤ ‚Üí Œ±) (b' : Œ≤)
    (hf : Monotone f) (gc : ‚àÄ a, ‚àÄ b ‚â• b', f a ‚â§ b ‚Üî a ‚â§ g b) (hgi : ‚àÄ b ‚â• b', b ‚â§ f (g b)) :
    map f atTop = atTop := by
  refine'
    le_antisymm
      (hf.tendsto_atTop_atTop fun b => ‚ü®g (b ‚äî b'), le_sup_left.trans <| hgi _ le_sup_right‚ü©) _
  rw [@map_atTop_eq _ _ ‚ü®g b'‚ü©]
  refine' le_iInf fun a => iInf_le_of_le (f a ‚äî b') <| principal_mono.2 fun b hb => _
  rw [mem_Ici, sup_le_iff] at hb
  exact ‚ü®g b, (gc _ _ hb.2).1 hb.1, le_antisymm ((gc _ _ hb.2).2 le_rfl) (hgi _ hb.2)‚ü©
#align filter.map_at_top_eq_of_gc Filter.map_atTop_eq_of_gc

theorem map_atBot_eq_of_gc [SemilatticeInf Œ±] [SemilatticeInf Œ≤] {f : Œ± ‚Üí Œ≤} (g : Œ≤ ‚Üí Œ±) (b' : Œ≤)
    (hf : Monotone f) (gc : ‚àÄ a, ‚àÄ b ‚â§ b', b ‚â§ f a ‚Üî g b ‚â§ a) (hgi : ‚àÄ b ‚â§ b', f (g b) ‚â§ b) :
    map f atBot = atBot :=
  @map_atTop_eq_of_gc Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ hf.dual gc hgi
#align filter.map_at_bot_eq_of_gc Filter.map_atBot_eq_of_gc

theorem map_val_atTop_of_Ici_subset [SemilatticeSup Œ±] {a : Œ±} {s : Set Œ±} (h : Ici a ‚äÜ s) :
    map ((‚Üë) : s ‚Üí Œ±) atTop = atTop := by
  haveI : Nonempty s := ‚ü®‚ü®a, h le_rfl‚ü©‚ü©
  have : Directed (¬∑ ‚â• ¬∑) fun x : s => ùìü (Ici x) := fun x y ‚Ü¶ by
    use ‚ü®x ‚äî y ‚äî a, h le_sup_right‚ü©
    simp only [principal_mono, Ici_subset_Ici, ‚Üê Subtype.coe_le_coe, Subtype.coe_mk]
    exact ‚ü®le_sup_left.trans le_sup_left, le_sup_right.trans le_sup_left‚ü©
  simp only [le_antisymm_iff, atTop, le_iInf_iff, le_principal_iff, mem_map, mem_setOf_eq,
    map_iInf_eq this, map_principal]
  constructor
  ¬∑ intro x
    refine' mem_of_superset (mem_iInf_of_mem ‚ü®x ‚äî a, h le_sup_right‚ü© (mem_principal_self _)) _
    rintro _ ‚ü®y, hy, rfl‚ü©
    exact le_trans le_sup_left (Subtype.coe_le_coe.2 hy)
  ¬∑ intro x
    filter_upwards [mem_atTop (‚Üëx ‚äî a)] with b hb
    exact ‚ü®‚ü®b, h <| le_sup_right.trans hb‚ü©, Subtype.coe_le_coe.1 (le_sup_left.trans hb), rfl‚ü©
#align filter.map_coe_at_top_of_Ici_subset Filter.map_val_atTop_of_Ici_subset

/-- The image of the filter `atTop` on `Ici a` under the coercion equals `atTop`. -/
@[simp]
theorem map_val_Ici_atTop [SemilatticeSup Œ±] (a : Œ±) : map ((‚Üë) : Ici a ‚Üí Œ±) atTop = atTop :=
  map_val_atTop_of_Ici_subset (Subset.refl _)
#align filter.map_coe_Ici_at_top Filter.map_val_Ici_atTop

/-- The image of the filter `atTop` on `Ioi a` under the coercion equals `atTop`. -/
@[simp]
theorem map_val_Ioi_atTop [SemilatticeSup Œ±] [NoMaxOrder Œ±] (a : Œ±) :
    map ((‚Üë) : Ioi a ‚Üí Œ±) atTop = atTop :=
  let ‚ü®_b, hb‚ü© := exists_gt a
  map_val_atTop_of_Ici_subset <| Ici_subset_Ioi.2 hb
#align filter.map_coe_Ioi_at_top Filter.map_val_Ioi_atTop

/-- The `atTop` filter for an open interval `Ioi a` comes from the `atTop` filter in the ambient
order. -/
theorem atTop_Ioi_eq [SemilatticeSup Œ±] (a : Œ±) : atTop = comap ((‚Üë) : Ioi a ‚Üí Œ±) atTop := by
  rcases isEmpty_or_nonempty (Ioi a) with h|‚ü®‚ü®b, hb‚ü©‚ü©
  ¬∑ exact Subsingleton.elim _ _
  ¬∑ rw [‚Üê map_val_atTop_of_Ici_subset (Ici_subset_Ioi.2 hb), comap_map Subtype.coe_injective]
#align filter.at_top_Ioi_eq Filter.atTop_Ioi_eq

/-- The `atTop` filter for an open interval `Ici a` comes from the `atTop` filter in the ambient
order. -/
theorem atTop_Ici_eq [SemilatticeSup Œ±] (a : Œ±) : atTop = comap ((‚Üë) : Ici a ‚Üí Œ±) atTop := by
  rw [‚Üê map_val_Ici_atTop a, comap_map Subtype.coe_injective]
#align filter.at_top_Ici_eq Filter.atTop_Ici_eq

/-- The `atBot` filter for an open interval `Iio a` comes from the `atBot` filter in the ambient
order. -/
@[simp]
theorem map_val_Iio_atBot [SemilatticeInf Œ±] [NoMinOrder Œ±] (a : Œ±) :
    map ((‚Üë) : Iio a ‚Üí Œ±) atBot = atBot :=
  @map_val_Ioi_atTop Œ±·µí·µà _ _ _
#align filter.map_coe_Iio_at_bot Filter.map_val_Iio_atBot

/-- The `atBot` filter for an open interval `Iio a` comes from the `atBot` filter in the ambient
order. -/
theorem atBot_Iio_eq [SemilatticeInf Œ±] (a : Œ±) : atBot = comap ((‚Üë) : Iio a ‚Üí Œ±) atBot :=
  @atTop_Ioi_eq Œ±·µí·µà _ _
#align filter.at_bot_Iio_eq Filter.atBot_Iio_eq

/-- The `atBot` filter for an open interval `Iic a` comes from the `atBot` filter in the ambient
order. -/
@[simp]
theorem map_val_Iic_atBot [SemilatticeInf Œ±] (a : Œ±) : map ((‚Üë) : Iic a ‚Üí Œ±) atBot = atBot :=
  @map_val_Ici_atTop Œ±·µí·µà _ _
#align filter.map_coe_Iic_at_bot Filter.map_val_Iic_atBot

/-- The `atBot` filter for an open interval `Iic a` comes from the `atBot` filter in the ambient
order. -/
theorem atBot_Iic_eq [SemilatticeInf Œ±] (a : Œ±) : atBot = comap ((‚Üë) : Iic a ‚Üí Œ±) atBot :=
  @atTop_Ici_eq Œ±·µí·µà _ _
#align filter.at_bot_Iic_eq Filter.atBot_Iic_eq

theorem tendsto_Ioi_atTop [SemilatticeSup Œ±] {a : Œ±} {f : Œ≤ ‚Üí Ioi a} {l : Filter Œ≤} :
    Tendsto f l atTop ‚Üî Tendsto (fun x => (f x : Œ±)) l atTop := by
  rw [atTop_Ioi_eq, tendsto_comap_iff]; rfl
#align filter.tendsto_Ioi_at_top Filter.tendsto_Ioi_atTop

theorem tendsto_Iio_atBot [SemilatticeInf Œ±] {a : Œ±} {f : Œ≤ ‚Üí Iio a} {l : Filter Œ≤} :
    Tendsto f l atBot ‚Üî Tendsto (fun x => (f x : Œ±)) l atBot := by
  rw [atBot_Iio_eq, tendsto_comap_iff]; rfl
#align filter.tendsto_Iio_at_bot Filter.tendsto_Iio_atBot

theorem tendsto_Ici_atTop [SemilatticeSup Œ±] {a : Œ±} {f : Œ≤ ‚Üí Ici a} {l : Filter Œ≤} :
    Tendsto f l atTop ‚Üî Tendsto (fun x => (f x : Œ±)) l atTop := by
  rw [atTop_Ici_eq, tendsto_comap_iff]; rfl
#align filter.tendsto_Ici_at_top Filter.tendsto_Ici_atTop

theorem tendsto_Iic_atBot [SemilatticeInf Œ±] {a : Œ±} {f : Œ≤ ‚Üí Iic a} {l : Filter Œ≤} :
    Tendsto f l atBot ‚Üî Tendsto (fun x => (f x : Œ±)) l atBot := by
  rw [atBot_Iic_eq, tendsto_comap_iff]; rfl
#align filter.tendsto_Iic_at_bot Filter.tendsto_Iic_atBot

@[simp, nolint simpNF] -- Porting note: linter claims that LHS doesn't simplify. It does.
theorem tendsto_comp_val_Ioi_atTop [SemilatticeSup Œ±] [NoMaxOrder Œ±] {a : Œ±} {f : Œ± ‚Üí Œ≤}
    {l : Filter Œ≤} : Tendsto (fun x : Ioi a => f x) atTop l ‚Üî Tendsto f atTop l := by
  rw [‚Üê map_val_Ioi_atTop a, tendsto_map'_iff]; rfl
#align filter.tendsto_comp_coe_Ioi_at_top Filter.tendsto_comp_val_Ioi_atTop

@[simp, nolint simpNF] -- Porting note: linter claims that LHS doesn't simplify. It does.
theorem tendsto_comp_val_Ici_atTop [SemilatticeSup Œ±] {a : Œ±} {f : Œ± ‚Üí Œ≤} {l : Filter Œ≤} :
    Tendsto (fun x : Ici a => f x) atTop l ‚Üî Tendsto f atTop l := by
  rw [‚Üê map_val_Ici_atTop a, tendsto_map'_iff]; rfl
#align filter.tendsto_comp_coe_Ici_at_top Filter.tendsto_comp_val_Ici_atTop

@[simp, nolint simpNF] -- Porting note: linter claims that LHS doesn't simplify. It does.
theorem tendsto_comp_val_Iio_atBot [SemilatticeInf Œ±] [NoMinOrder Œ±] {a : Œ±} {f : Œ± ‚Üí Œ≤}
    {l : Filter Œ≤} : Tendsto (fun x : Iio a => f x) atBot l ‚Üî Tendsto f atBot l := by
  rw [‚Üê map_val_Iio_atBot a, tendsto_map'_iff]; rfl
#align filter.tendsto_comp_coe_Iio_at_bot Filter.tendsto_comp_val_Iio_atBot

@[simp, nolint simpNF] -- Porting note: linter claims that LHS doesn't simplify. It does.
theorem tendsto_comp_val_Iic_atBot [SemilatticeInf Œ±] {a : Œ±} {f : Œ± ‚Üí Œ≤} {l : Filter Œ≤} :
    Tendsto (fun x : Iic a => f x) atBot l ‚Üî Tendsto f atBot l := by
  rw [‚Üê map_val_Iic_atBot a, tendsto_map'_iff]; rfl
#align filter.tendsto_comp_coe_Iic_at_bot Filter.tendsto_comp_val_Iic_atBot

theorem map_add_atTop_eq_nat (k : ‚Ñï) : map (fun a => a + k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a - k) k (fun a b h => add_le_add_right h k)
    (fun a b h => (le_tsub_iff_right h).symm) fun a h => by rw [tsub_add_cancel_of_le h]
#align filter.map_add_at_top_eq_nat Filter.map_add_atTop_eq_nat

theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
    (fun a b _ => tsub_le_iff_right) fun b _ => by rw [add_tsub_cancel_right]
#align filter.map_sub_at_top_eq_nat Filter.map_sub_atTop_eq_nat

theorem tendsto_add_atTop_nat (k : ‚Ñï) : Tendsto (fun a => a + k) atTop atTop :=
  le_of_eq (map_add_atTop_eq_nat k)
#align filter.tendsto_add_at_top_nat Filter.tendsto_add_atTop_nat

theorem tendsto_sub_atTop_nat (k : ‚Ñï) : Tendsto (fun a => a - k) atTop atTop :=
  le_of_eq (map_sub_atTop_eq_nat k)
#align filter.tendsto_sub_at_top_nat Filter.tendsto_sub_atTop_nat

theorem tendsto_add_atTop_iff_nat {f : ‚Ñï ‚Üí Œ±} {l : Filter Œ±} (k : ‚Ñï) :
    Tendsto (fun n => f (n + k)) atTop l ‚Üî Tendsto f atTop l :=
  show Tendsto (f ‚àò fun n => n + k) atTop l ‚Üî Tendsto f atTop l by
    rw [‚Üê tendsto_map'_iff, map_add_atTop_eq_nat]
#align filter.tendsto_add_at_top_iff_nat Filter.tendsto_add_atTop_iff_nat

theorem map_div_atTop_eq_nat (k : ‚Ñï) (hk : 0 < k) : map (fun a => a / k) atTop = atTop :=
  map_atTop_eq_of_gc (fun b => b * k + (k - 1)) 1 (fun a b h => Nat.div_le_div_right h)
    -- porting note: there was a parse error in `calc`, use `simp` instead
    (fun a b _ => by simp only [‚Üê Nat.lt_succ_iff, Nat.div_lt_iff_lt_mul hk, Nat.succ_eq_add_one,
      add_assoc, tsub_add_cancel_of_le (Nat.one_le_iff_ne_zero.2 hk.ne'), add_mul, one_mul])
    fun b _ =>
    calc
      b = b * k / k := by rw [Nat.mul_div_cancel b hk]
      _ ‚â§ (b * k + (k - 1)) / k := Nat.div_le_div_right <| Nat.le_add_right _ _
#align filter.map_div_at_top_eq_nat Filter.map_div_atTop_eq_nat

/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded
above, then `Tendsto u atTop atTop`. -/
theorem tendsto_atTop_atTop_of_monotone' [Preorder Œπ] [LinearOrder Œ±] {u : Œπ ‚Üí Œ±} (h : Monotone u)
    (H : ¬¨BddAbove (range u)) : Tendsto u atTop atTop := by
  apply h.tendsto_atTop_atTop
  intro b
  rcases not_bddAbove_iff.1 H b with ‚ü®_, ‚ü®N, rfl‚ü©, hN‚ü©
  exact ‚ü®N, le_of_lt hN‚ü©
#align filter.tendsto_at_top_at_top_of_monotone' Filter.tendsto_atTop_atTop_of_monotone'

/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded
below, then `Tendsto u atBot atBot`. -/
theorem tendsto_atBot_atBot_of_monotone' [Preorder Œπ] [LinearOrder Œ±] {u : Œπ ‚Üí Œ±} (h : Monotone u)
    (H : ¬¨BddBelow (range u)) : Tendsto u atBot atBot :=
  @tendsto_atTop_atTop_of_monotone' Œπ·µí·µà Œ±·µí·µà _ _ _ h.dual H
#align filter.tendsto_at_bot_at_bot_of_monotone' Filter.tendsto_atBot_atBot_of_monotone'

theorem unbounded_of_tendsto_atTop [Nonempty Œ±] [SemilatticeSup Œ±] [Preorder Œ≤] [NoMaxOrder Œ≤]
    {f : Œ± ‚Üí Œ≤} (h : Tendsto f atTop atTop) : ¬¨BddAbove (range f) := by
  rintro ‚ü®M, hM‚ü©
  cases' mem_atTop_sets.mp (h <| Ioi_mem_atTop M) with a ha
  apply lt_irrefl M
  calc
    M < f a := ha a le_rfl
    _ ‚â§ M := hM (Set.mem_range_self a)
#align filter.unbounded_of_tendsto_at_top Filter.unbounded_of_tendsto_atTop

theorem unbounded_of_tendsto_atBot [Nonempty Œ±] [SemilatticeSup Œ±] [Preorder Œ≤] [NoMinOrder Œ≤]
    {f : Œ± ‚Üí Œ≤} (h : Tendsto f atTop atBot) : ¬¨BddBelow (range f) :=
  @unbounded_of_tendsto_atTop _ Œ≤·µí·µà _ _ _ _ _ h
#align filter.unbounded_of_tendsto_at_bot Filter.unbounded_of_tendsto_atBot

theorem unbounded_of_tendsto_atTop' [Nonempty Œ±] [SemilatticeInf Œ±] [Preorder Œ≤] [NoMaxOrder Œ≤]
    {f : Œ± ‚Üí Œ≤} (h : Tendsto f atBot atTop) : ¬¨BddAbove (range f) :=
  @unbounded_of_tendsto_atTop Œ±·µí·µà _ _ _ _ _ _ h
#align filter.unbounded_of_tendsto_at_top' Filter.unbounded_of_tendsto_atTop'

theorem unbounded_of_tendsto_atBot' [Nonempty Œ±] [SemilatticeInf Œ±] [Preorder Œ≤] [NoMinOrder Œ≤]
    {f : Œ± ‚Üí Œ≤} (h : Tendsto f atBot atBot) : ¬¨BddBelow (range f) :=
  @unbounded_of_tendsto_atTop Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ h
#align filter.unbounded_of_tendsto_at_bot' Filter.unbounded_of_tendsto_atBot'

/-- If a monotone function `u : Œπ ‚Üí Œ±` tends to `atTop` along *some* non-trivial filter `l`, then
it tends to `atTop` along `atTop`. -/
theorem tendsto_atTop_of_monotone_of_filter [Preorder Œπ] [Preorder Œ±] {l : Filter Œπ} {u : Œπ ‚Üí Œ±}
    (h : Monotone u) [NeBot l] (hu : Tendsto u l atTop) : Tendsto u atTop atTop :=
  h.tendsto_atTop_atTop fun b => (hu.eventually (mem_atTop b)).exists
#align filter.tendsto_at_top_of_monotone_of_filter Filter.tendsto_atTop_of_monotone_of_filter

/-- If a monotone function `u : Œπ ‚Üí Œ±` tends to `atBot` along *some* non-trivial filter `l`, then
it tends to `atBot` along `atBot`. -/
theorem tendsto_atBot_of_monotone_of_filter [Preorder Œπ] [Preorder Œ±] {l : Filter Œπ} {u : Œπ ‚Üí Œ±}
    (h : Monotone u) [NeBot l] (hu : Tendsto u l atBot) : Tendsto u atBot atBot :=
  @tendsto_atTop_of_monotone_of_filter Œπ·µí·µà Œ±·µí·µà _ _ _ _ h.dual _ hu
#align filter.tendsto_at_bot_of_monotone_of_filter Filter.tendsto_atBot_of_monotone_of_filter

theorem tendsto_atTop_of_monotone_of_subseq [Preorder Œπ] [Preorder Œ±] {u : Œπ ‚Üí Œ±} {œÜ : Œπ' ‚Üí Œπ}
    (h : Monotone u) {l : Filter Œπ'} [NeBot l] (H : Tendsto (u ‚àò œÜ) l atTop) :
    Tendsto u atTop atTop :=
  tendsto_atTop_of_monotone_of_filter h (tendsto_map' H)
#align filter.tendsto_at_top_of_monotone_of_subseq Filter.tendsto_atTop_of_monotone_of_subseq

theorem tendsto_atBot_of_monotone_of_subseq [Preorder Œπ] [Preorder Œ±] {u : Œπ ‚Üí Œ±} {œÜ : Œπ' ‚Üí Œπ}
    (h : Monotone u) {l : Filter Œπ'} [NeBot l] (H : Tendsto (u ‚àò œÜ) l atBot) :
    Tendsto u atBot atBot :=
  tendsto_atBot_of_monotone_of_filter h (tendsto_map' H)
#align filter.tendsto_at_bot_of_monotone_of_subseq Filter.tendsto_atBot_of_monotone_of_subseq

/-- Let `f` and `g` be two maps to the same commutative monoid. This lemma gives a sufficient
condition for comparison of the filter `atTop.map (fun s ‚Ü¶ ‚àè b in s, f b)` with
`atTop.map (fun s ‚Ü¶ ‚àè b in s, g b)`. This is useful to compare the set of limit points of
`Œ† b in s, f b` as `s ‚Üí atTop` with the similar set for `g`. -/
@[to_additive "Let `f` and `g` be two maps to the same commutative additive monoid. This lemma gives
a sufficient condition for comparison of the filter `atTop.map (fun s ‚Ü¶ ‚àë b in s, f b)` with
`atTop.map (fun s ‚Ü¶ ‚àë b in s, g b)`. This is useful to compare the set of limit points of
`‚àë b in s, f b` as `s ‚Üí atTop` with the similar set for `g`."]
theorem map_atTop_finset_prod_le_of_prod_eq [CommMonoid Œ±] {f : Œ≤ ‚Üí Œ±} {g : Œ≥ ‚Üí Œ±}
    (h_eq : ‚àÄ u : Finset Œ≥,
      ‚àÉ v : Finset Œ≤, ‚àÄ v', v ‚äÜ v' ‚Üí ‚àÉ u', u ‚äÜ u' ‚àß ‚àè x in u', g x = ‚àè b in v', f b) :
    (atTop.map fun s : Finset Œ≤ => ‚àè b in s, f b) ‚â§
      atTop.map fun s : Finset Œ≥ => ‚àè x in s, g x := by
  classical
    refine' ((atTop_basis.map _).le_basis_iff (atTop_basis.map _)).2 fun b _ => _
    let ‚ü®v, hv‚ü© := h_eq b
    refine ‚ü®v, trivial, ?_‚ü©
    simpa [image_subset_iff] using hv
#align filter.map_at_top_finset_prod_le_of_prod_eq Filter.map_atTop_finset_prod_le_of_prod_eq
#align filter.map_at_top_finset_sum_le_of_sum_eq Filter.map_atTop_finset_sum_le_of_sum_eq

theorem HasAntitoneBasis.eventually_subset [Preorder Œπ] {l : Filter Œ±} {s : Œπ ‚Üí Set Œ±}
    (hl : l.HasAntitoneBasis s) {t : Set Œ±} (ht : t ‚àà l) : ‚àÄ·∂† i in atTop, s i ‚äÜ t :=
  let ‚ü®i, _, hi‚ü© := hl.1.mem_iff.1 ht
  (eventually_ge_atTop i).mono fun _j hj => (hl.antitone hj).trans hi
#align filter.has_antitone_basis.eventually_subset Filter.HasAntitoneBasis.eventually_subset

protected theorem HasAntitoneBasis.tendsto [Preorder Œπ] {l : Filter Œ±} {s : Œπ ‚Üí Set Œ±}
    (hl : l.HasAntitoneBasis s) {œÜ : Œπ ‚Üí Œ±} (h : ‚àÄ i : Œπ, œÜ i ‚àà s i) : Tendsto œÜ atTop l :=
  fun _t ht => mem_map.2 <| (hl.eventually_subset ht).mono fun i hi => hi (h i)
#align filter.has_antitone_basis.tendsto Filter.HasAntitoneBasis.tendsto

theorem HasAntitoneBasis.comp_mono [SemilatticeSup Œπ] [Nonempty Œπ] [Preorder Œπ'] {l : Filter Œ±}
    {s : Œπ' ‚Üí Set Œ±} (hs : l.HasAntitoneBasis s) {œÜ : Œπ ‚Üí Œπ'} (œÜ_mono : Monotone œÜ)
    (hœÜ : Tendsto œÜ atTop atTop) : l.HasAntitoneBasis (s ‚àò œÜ) :=
  ‚ü®hs.1.to_hasBasis
      (fun n _ => (hœÜ.eventually_ge_atTop n).exists.imp fun _m hm => ‚ü®trivial, hs.antitone hm‚ü©)
      fun n _ => ‚ü®œÜ n, trivial, Subset.rfl‚ü©,
    hs.antitone.comp_monotone œÜ_mono‚ü©
#align filter.has_antitone_basis.comp_mono Filter.HasAntitoneBasis.comp_mono

theorem HasAntitoneBasis.comp_strictMono {l : Filter Œ±} {s : ‚Ñï ‚Üí Set Œ±} (hs : l.HasAntitoneBasis s)
    {œÜ : ‚Ñï ‚Üí ‚Ñï} (hœÜ : StrictMono œÜ) : l.HasAntitoneBasis (s ‚àò œÜ) :=
  hs.comp_mono hœÜ.monotone hœÜ.tendsto_atTop
#align filter.has_antitone_basis.comp_strict_mono Filter.HasAntitoneBasis.comp_strictMono

/-- Given an antitone basis `s : ‚Ñï ‚Üí Set Œ±` of a filter, extract an antitone subbasis `s ‚àò œÜ`,
`œÜ : ‚Ñï ‚Üí ‚Ñï`, such that `m < n` implies `r (œÜ m) (œÜ n)`. This lemma can be used to extract an
antitone basis with basis sets decreasing "sufficiently fast". -/
theorem HasAntitoneBasis.subbasis_with_rel {f : Filter Œ±} {s : ‚Ñï ‚Üí Set Œ±}
    (hs : f.HasAntitoneBasis s) {r : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop} (hr : ‚àÄ m, ‚àÄ·∂† n in atTop, r m n) :
    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß (‚àÄ ‚¶Ém n‚¶Ñ, m < n ‚Üí r (œÜ m) (œÜ n)) ‚àß f.HasAntitoneBasis (s ‚àò œÜ) := by
  rsuffices ‚ü®œÜ, hœÜ, hrœÜ‚ü© : ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ m n, m < n ‚Üí r (œÜ m) (œÜ n)
  ¬∑ exact ‚ü®œÜ, hœÜ, hrœÜ, hs.comp_strictMono hœÜ‚ü©
  have : ‚àÄ t : Set ‚Ñï, t.Finite ‚Üí ‚àÄ·∂† n in atTop, ‚àÄ m ‚àà t, m < n ‚àß r m n := fun t ht =>
    (eventually_all_finite ht).2 fun m _ => (eventually_gt_atTop m).and (hr _)
  rcases seq_of_forall_finite_exists fun t ht => (this t ht).exists with ‚ü®œÜ, hœÜ‚ü©
  simp only [ball_image_iff, forall_and, mem_Iio] at hœÜ
  exact ‚ü®œÜ, forall_swap.2 hœÜ.1, forall_swap.2 hœÜ.2‚ü©
#align filter.has_antitone_basis.subbasis_with_rel Filter.HasAntitoneBasis.subbasis_with_rel

/-- If `f` is a nontrivial countably generated filter, then there exists a sequence that converges
to `f`. -/
theorem exists_seq_tendsto (f : Filter Œ±) [IsCountablyGenerated f] [NeBot f] :
    ‚àÉ x : ‚Ñï ‚Üí Œ±, Tendsto x atTop f := by
  obtain ‚ü®B, h‚ü© := f.exists_antitone_basis
  choose x hx using fun n => Filter.nonempty_of_mem (h.mem n)
  exact ‚ü®x, h.tendsto hx‚ü©
#align filter.exists_seq_tendsto Filter.exists_seq_tendsto

theorem exists_seq_monotone_tendsto_atTop_atTop (Œ± : Type*) [SemilatticeSup Œ±] [Nonempty Œ±]
    [(atTop : Filter Œ±).IsCountablyGenerated] :
    ‚àÉ xs : ‚Ñï ‚Üí Œ±, Monotone xs ‚àß Tendsto xs atTop atTop := by
  haveI h_ne_bot : (atTop : Filter Œ±).NeBot := atTop_neBot
  obtain ‚ü®ys, h‚ü© := exists_seq_tendsto (atTop : Filter Œ±)
  let xs : ‚Ñï ‚Üí Œ± := fun n => Finset.sup' (Finset.range (n + 1)) Finset.nonempty_range_succ ys
  have h_mono : Monotone xs := by
    intro i j hij
    rw [Finset.sup'_le_iff]
    intro k hk
    refine' Finset.le_sup'_of_le _ _ le_rfl
    rw [Finset.mem_range] at hk ‚ä¢
    exact hk.trans_le (add_le_add_right hij _)
  refine' ‚ü®xs, h_mono, _‚ü©
  ¬∑ refine' tendsto_atTop_atTop_of_monotone h_mono _
    have : ‚àÄ a : Œ±, ‚àÉ n : ‚Ñï, a ‚â§ ys n := by
      rw [tendsto_atTop_atTop] at h
      intro a
      obtain ‚ü®i, hi‚ü© := h a
      exact ‚ü®i, hi i le_rfl‚ü©
    intro a
    obtain ‚ü®i, hi‚ü© := this a
    refine' ‚ü®i, hi.trans _‚ü©
    refine' Finset.le_sup'_of_le _ _ le_rfl
    rw [Finset.mem_range_succ_iff]
#align exists_seq_monotone_tendsto_at_top_at_top Filter.exists_seq_monotone_tendsto_atTop_atTop

theorem exists_seq_antitone_tendsto_atTop_atBot (Œ± : Type*) [SemilatticeInf Œ±] [Nonempty Œ±]
    [h2 : (atBot : Filter Œ±).IsCountablyGenerated] :
    ‚àÉ xs : ‚Ñï ‚Üí Œ±, Antitone xs ‚àß Tendsto xs atTop atBot :=
  @exists_seq_monotone_tendsto_atTop_atTop Œ±·µí·µà _ _ h2
#align exists_seq_antitone_tendsto_at_top_at_bot Filter.exists_seq_antitone_tendsto_atTop_atBot

/-- An abstract version of continuity of sequentially continuous functions on metric spaces:
if a filter `k` is countably generated then `Tendsto f k l` iff for every sequence `u`
converging to `k`, `f ‚àò u` tends to `l`. -/
theorem tendsto_iff_seq_tendsto {f : Œ± ‚Üí Œ≤} {k : Filter Œ±} {l : Filter Œ≤} [k.IsCountablyGenerated] :
    Tendsto f k l ‚Üî ‚àÄ x : ‚Ñï ‚Üí Œ±, Tendsto x atTop k ‚Üí Tendsto (f ‚àò x) atTop l := by
  refine ‚ü®fun h x hx => h.comp hx, fun H s hs => ?_‚ü©
  contrapose! H
  have : NeBot (k ‚äì ùìü (f ‚Åª¬π' s·∂ú)) := by simpa [neBot_iff, inf_principal_eq_bot]
  rcases (k ‚äì ùìü (f ‚Åª¬π' s·∂ú)).exists_seq_tendsto with ‚ü®x, hx‚ü©
  rw [tendsto_inf, tendsto_principal] at hx
  refine' ‚ü®x, hx.1, fun h => _‚ü©
  rcases (hx.2.and (h hs)).exists with ‚ü®N, hnmem, hmem‚ü©
  exact hnmem hmem
#align filter.tendsto_iff_seq_tendsto Filter.tendsto_iff_seq_tendsto

theorem tendsto_of_seq_tendsto {f : Œ± ‚Üí Œ≤} {k : Filter Œ±} {l : Filter Œ≤} [k.IsCountablyGenerated] :
    (‚àÄ x : ‚Ñï ‚Üí Œ±, Tendsto x atTop k ‚Üí Tendsto (f ‚àò x) atTop l) ‚Üí Tendsto f k l :=
  tendsto_iff_seq_tendsto.2
#align filter.tendsto_of_seq_tendsto Filter.tendsto_of_seq_tendsto

theorem eventually_iff_seq_eventually {Œπ : Type*} {l : Filter Œπ} {p : Œπ ‚Üí Prop}
    [l.IsCountablyGenerated] :
    (‚àÄ·∂† n in l, p n) ‚Üî ‚àÄ x : ‚Ñï ‚Üí Œπ, Tendsto x atTop l ‚Üí ‚àÄ·∂† n : ‚Ñï in atTop, p (x n) := by
  simpa using tendsto_iff_seq_tendsto (f := id) (l := ùìü {x | p x})
#align filter.eventually_iff_seq_eventually Filter.eventually_iff_seq_eventually

theorem frequently_iff_seq_frequently {Œπ : Type*} {l : Filter Œπ} {p : Œπ ‚Üí Prop}
    [l.IsCountablyGenerated] :
    (‚àÉ·∂† n in l, p n) ‚Üî ‚àÉ x : ‚Ñï ‚Üí Œπ, Tendsto x atTop l ‚àß ‚àÉ·∂† n : ‚Ñï in atTop, p (x n) := by
  simp only [Filter.Frequently, eventually_iff_seq_eventually (l := l)]
  push_neg; rfl
#align filter.frequently_iff_seq_frequently Filter.frequently_iff_seq_frequently

theorem subseq_forall_of_frequently {Œπ : Type*} {x : ‚Ñï ‚Üí Œπ} {p : Œπ ‚Üí Prop} {l : Filter Œπ}
    (h_tendsto : Tendsto x atTop l) (h : ‚àÉ·∂† n in atTop, p (x n)) :
    ‚àÉ ns : ‚Ñï ‚Üí ‚Ñï, Tendsto (fun n => x (ns n)) atTop l ‚àß ‚àÄ n, p (x (ns n)) := by
  choose ns hge hns using frequently_atTop.1 h
  exact ‚ü®ns, h_tendsto.comp (tendsto_atTop_mono hge tendsto_id), hns‚ü©
#align filter.subseq_forall_of_frequently Filter.subseq_forall_of_frequently

theorem exists_seq_forall_of_frequently {Œπ : Type*} {l : Filter Œπ} {p : Œπ ‚Üí Prop}
    [l.IsCountablyGenerated] (h : ‚àÉ·∂† n in l, p n) :
    ‚àÉ ns : ‚Ñï ‚Üí Œπ, Tendsto ns atTop l ‚àß ‚àÄ n, p (ns n) := by
  rw [frequently_iff_seq_frequently] at h
  obtain ‚ü®x, hx_tendsto, hx_freq‚ü© := h
  obtain ‚ü®n_to_n, h_tendsto, h_freq‚ü© := subseq_forall_of_frequently hx_tendsto hx_freq
  exact ‚ü®x ‚àò n_to_n, h_tendsto, h_freq‚ü©
#align filter.exists_seq_forall_of_frequently Filter.exists_seq_forall_of_frequently

lemma frequently_iff_seq_forall {Œπ : Type*} {l : Filter Œπ} {p : Œπ ‚Üí Prop}
    [l.IsCountablyGenerated] :
    (‚àÉ·∂† n in l, p n) ‚Üî ‚àÉ ns : ‚Ñï ‚Üí Œπ, Tendsto ns atTop l ‚àß ‚àÄ n, p (ns n) :=
  ‚ü®exists_seq_forall_of_frequently, fun ‚ü®_ns, hnsl, hpns‚ü© ‚Ü¶
    hnsl.frequently <| frequently_of_forall hpns‚ü©

/-- A sequence converges if every subsequence has a convergent subsequence. -/
theorem tendsto_of_subseq_tendsto {Œ± Œπ : Type*} {x : Œπ ‚Üí Œ±} {f : Filter Œ±} {l : Filter Œπ}
    [l.IsCountablyGenerated]
    (hxy : ‚àÄ ns : ‚Ñï ‚Üí Œπ, Tendsto ns atTop l ‚Üí
      ‚àÉ ms : ‚Ñï ‚Üí ‚Ñï, Tendsto (fun n => x (ns <| ms n)) atTop f) :
    Tendsto x l f := by
  contrapose! hxy
  obtain ‚ü®s, hs, hfreq‚ü© : ‚àÉ s ‚àà f, ‚àÉ·∂† n in l, x n ‚àâ s := by
    rwa [not_tendsto_iff_exists_frequently_nmem] at hxy
  obtain ‚ü®y, hy_tendsto, hy_freq‚ü© := exists_seq_forall_of_frequently hfreq
  refine ‚ü®y, hy_tendsto, fun ms hms_tendsto ‚Ü¶ ?_‚ü©
  rcases (hms_tendsto.eventually_mem hs).exists with ‚ü®n, hn‚ü©
  exact absurd hn <| hy_freq _
#align filter.tendsto_of_subseq_tendsto Filter.tendsto_of_subseq_tendsto

theorem subseq_tendsto_of_neBot {f : Filter Œ±} [IsCountablyGenerated f] {u : ‚Ñï ‚Üí Œ±}
    (hx : NeBot (f ‚äì map u atTop)) : ‚àÉ Œ∏ : ‚Ñï ‚Üí ‚Ñï, StrictMono Œ∏ ‚àß Tendsto (u ‚àò Œ∏) atTop f := by
  rw [‚Üê Filter.push_pull', map_neBot_iff] at hx
  rcases exists_seq_tendsto (comap u f ‚äì atTop) with ‚ü®œÜ, hœÜ‚ü©
  rw [tendsto_inf, tendsto_comap_iff] at hœÜ
  obtain ‚ü®œà, hœà, hœàœÜ‚ü© : ‚àÉ œà : ‚Ñï ‚Üí ‚Ñï, StrictMono œà ‚àß StrictMono (œÜ ‚àò œà) :=
    strictMono_subseq_of_tendsto_atTop hœÜ.2
  exact ‚ü®œÜ ‚àò œà, hœàœÜ, hœÜ.1.comp hœà.tendsto_atTop‚ü©
#align filter.subseq_tendsto_of_ne_bot Filter.subseq_tendsto_of_neBot

end Filter

open Filter Finset

section

variable {R : Type*} [LinearOrderedSemiring R]

theorem exists_lt_mul_self (a : R) : ‚àÉ x ‚â• 0, a < x * x :=
  let ‚ü®x, hxa, hx0‚ü© :=
    ((tendsto_mul_self_atTop.eventually (eventually_gt_atTop a)).and (eventually_ge_atTop 0)).exists
  ‚ü®x, hx0, hxa‚ü©
#align exists_lt_mul_self exists_lt_mul_self

theorem exists_le_mul_self (a : R) : ‚àÉ x ‚â• 0, a ‚â§ x * x :=
  let ‚ü®x, hx0, hxa‚ü© := exists_lt_mul_self a
  ‚ü®x, hx0, hxa.le‚ü©
#align exists_le_mul_self exists_le_mul_self

end

theorem Monotone.piecewise_eventually_eq_iUnion {Œ≤ : Œ± ‚Üí Type*} [Preorder Œπ] {s : Œπ ‚Üí Set Œ±}
    [‚àÄ i, DecidablePred (¬∑ ‚àà s i)] [DecidablePred (¬∑ ‚àà ‚ãÉ i, s i)]
    (hs : Monotone s) (f g : (a : Œ±) ‚Üí Œ≤ a) (a : Œ±) :
    ‚àÄ·∂† i in atTop, (s i).piecewise f g a = (‚ãÉ i, s i).piecewise f g a := by
  rcases em (‚àÉ i, a ‚àà s i) with ‚ü®i, hi‚ü© | ha
  ¬∑ refine (eventually_ge_atTop i).mono fun j hij ‚Ü¶ ?_
    simp only [Set.piecewise_eq_of_mem, hs hij hi, subset_iUnion _ _ hi]
  ¬∑ refine eventually_of_forall fun i ‚Ü¶ ?_
    simp only [Set.piecewise_eq_of_not_mem, not_exists.1 ha i, mt mem_iUnion.1 ha,
      not_false_eq_true, exists_false]

theorem Antitone.piecewise_eventually_eq_iInter {Œ≤ : Œ± ‚Üí Type*} [Preorder Œπ] {s : Œπ ‚Üí Set Œ±}
    [‚àÄ i, DecidablePred (¬∑ ‚àà s i)] [DecidablePred (¬∑ ‚àà ‚ãÇ i, s i)]
    (hs : Antitone s) (f g : (a : Œ±) ‚Üí Œ≤ a) (a : Œ±) :
    ‚àÄ·∂† i in atTop, (s i).piecewise f g a = (‚ãÇ i, s i).piecewise f g a := by
  classical
  convert ‚Üê (compl_anti.comp hs).piecewise_eventually_eq_iUnion g f a using 3
  ¬∑ convert congr_fun (Set.piecewise_compl (s _) g f) a
  ¬∑ simp only [(¬∑ ‚àò ¬∑), ‚Üê compl_iInter, Set.piecewise_compl]

/-- Let `g : Œ≥ ‚Üí Œ≤` be an injective function and `f : Œ≤ ‚Üí Œ±` be a function from the codomain of `g`
to a commutative monoid. Suppose that `f x = 1` outside of the range of `g`. Then the filters
`atTop.map (fun s ‚Ü¶ ‚àè i in s, f (g i))` and `atTop.map (fun s ‚Ü¶ ‚àè i in s, f i)` coincide.

The additive version of this lemma is used to prove the equality `‚àë' x, f (g x) = ‚àë' y, f y` under
the same assumptions.-/
@[to_additive]
theorem Function.Injective.map_atTop_finset_prod_eq [CommMonoid Œ±] {g : Œ≥ ‚Üí Œ≤}
    (hg : Function.Injective g) {f : Œ≤ ‚Üí Œ±} (hf : ‚àÄ x, x ‚àâ Set.range g ‚Üí f x = 1) :
    map (fun s => ‚àè i in s, f (g i)) atTop = map (fun s => ‚àè i in s, f i) atTop := by
  haveI := Classical.decEq Œ≤
  apply le_antisymm <;> refine' map_atTop_finset_prod_le_of_prod_eq fun s => _
  ¬∑ refine' ‚ü®s.preimage g (hg.injOn _), fun t ht => _‚ü©
    refine' ‚ü®t.image g ‚à™ s, Finset.subset_union_right _ _, _‚ü©
    rw [‚Üê Finset.prod_image (hg.injOn _)]
    refine' (prod_subset (subset_union_left _ _) _).symm
    simp only [Finset.mem_union, Finset.mem_image]
    refine' fun y hy hyt => hf y (mt _ hyt)
    rintro ‚ü®x, rfl‚ü©
    exact ‚ü®x, ht (Finset.mem_preimage.2 <| hy.resolve_left hyt), rfl‚ü©
  ¬∑ refine' ‚ü®s.image g, fun t ht => _‚ü©
    simp only [‚Üê prod_preimage _ _ (hg.injOn _) _ fun x _ => hf x]
    exact ‚ü®_, (image_subset_iff_subset_preimage _).1 ht, rfl‚ü©
#align function.injective.map_at_top_finset_prod_eq Function.Injective.map_atTop_finset_prod_eq
#align function.injective.map_at_top_finset_sum_eq Function.Injective.map_atTop_finset_sum_eq

/-- Let `g : Œ≥ ‚Üí Œ≤` be an injective function and `f : Œ≤ ‚Üí Œ±` be a function from the codomain of `g`
to an additive commutative monoid. Suppose that `f x = 0` outside of the range of `g`. Then the
filters `atTop.map (fun s ‚Ü¶ ‚àë i in s, f (g i))` and `atTop.map (fun s ‚Ü¶ ‚àë i in s, f i)` coincide.

This lemma is used to prove the equality `‚àë' x, f (g x) = ‚àë' y, f y` under
the same assumptions.-/
add_decl_doc Function.Injective.map_atTop_finset_sum_eq
