/-
Copyright (c) 2017 Johannes HÃ¶lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes HÃ¶lzl, Jeremy Avigad, Yury Kudryashov, Patrick Massot
-/
import Mathlib.Data.Finset.Preimage
import Mathlib.Order.ConditionallyCompleteLattice.Indexed
import Mathlib.Order.Filter.Bases
import Mathlib.Order.Filter.Prod
import Mathlib.Order.Interval.Set.Disjoint
import Mathlib.Order.Interval.Set.OrderIso

/-!
# `Filter.atTop` and `Filter.atBot` filters on preorders, monoids and groups.

In this file we define the filters

* `Filter.atTop`: corresponds to `n â†’ +âˆ`;
* `Filter.atBot`: corresponds to `n â†’ -âˆ`.

Then we prove many lemmas like â€œif `f â†’ +âˆ`, then `f Â± c â†’ +âˆ`â€.
-/

variable {Î¹ Î¹' Î± Î² Î³ : Type*}

open Set

namespace Filter

/-- `atTop` is the filter representing the limit `â†’ âˆ` on an ordered set.
  It is generated by the collection of up-sets `{b | a â‰¤ b}`.
  (The preorder need not have a top element for this to be well defined,
  and indeed is trivial when a top element exists.) -/
def atTop [Preorder Î±] : Filter Î± :=
  â¨… a, ğ“Ÿ (Ici a)

/-- `atBot` is the filter representing the limit `â†’ -âˆ` on an ordered set.
  It is generated by the collection of down-sets `{b | b â‰¤ a}`.
  (The preorder need not have a bottom element for this to be well defined,
  and indeed is trivial when a bottom element exists.) -/
def atBot [Preorder Î±] : Filter Î± :=
  â¨… a, ğ“Ÿ (Iic a)

theorem mem_atTop [Preorder Î±] (a : Î±) : { b : Î± | a â‰¤ b } âˆˆ @atTop Î± _ :=
  mem_iInf_of_mem a <| Subset.refl _

theorem Ici_mem_atTop [Preorder Î±] (a : Î±) : Ici a âˆˆ (atTop : Filter Î±) :=
  mem_atTop a

theorem Ioi_mem_atTop [Preorder Î±] [NoMaxOrder Î±] (x : Î±) : Ioi x âˆˆ (atTop : Filter Î±) :=
  let âŸ¨z, hzâŸ© := exists_gt x
  mem_of_superset (mem_atTop z) fun _ h => lt_of_lt_of_le hz h

theorem mem_atBot [Preorder Î±] (a : Î±) : { b : Î± | b â‰¤ a } âˆˆ @atBot Î± _ :=
  mem_iInf_of_mem a <| Subset.refl _

theorem Iic_mem_atBot [Preorder Î±] (a : Î±) : Iic a âˆˆ (atBot : Filter Î±) :=
  mem_atBot a

theorem Iio_mem_atBot [Preorder Î±] [NoMinOrder Î±] (x : Î±) : Iio x âˆˆ (atBot : Filter Î±) :=
  let âŸ¨z, hzâŸ© := exists_lt x
  mem_of_superset (mem_atBot z) fun _ h => lt_of_le_of_lt h hz

theorem disjoint_atBot_principal_Ioi [Preorder Î±] (x : Î±) : Disjoint atBot (ğ“Ÿ (Ioi x)) :=
  disjoint_of_disjoint_of_mem (Iic_disjoint_Ioi le_rfl) (Iic_mem_atBot x) (mem_principal_self _)

theorem disjoint_atTop_principal_Iio [Preorder Î±] (x : Î±) : Disjoint atTop (ğ“Ÿ (Iio x)) :=
  @disjoint_atBot_principal_Ioi Î±áµ’áµˆ _ _

theorem disjoint_atTop_principal_Iic [Preorder Î±] [NoMaxOrder Î±] (x : Î±) :
    Disjoint atTop (ğ“Ÿ (Iic x)) :=
  disjoint_of_disjoint_of_mem (Iic_disjoint_Ioi le_rfl).symm (Ioi_mem_atTop x)
    (mem_principal_self _)

theorem disjoint_atBot_principal_Ici [Preorder Î±] [NoMinOrder Î±] (x : Î±) :
    Disjoint atBot (ğ“Ÿ (Ici x)) :=
  @disjoint_atTop_principal_Iic Î±áµ’áµˆ _ _ _

theorem disjoint_pure_atTop [Preorder Î±] [NoMaxOrder Î±] (x : Î±) : Disjoint (pure x) atTop :=
  Disjoint.symm <| (disjoint_atTop_principal_Iic x).mono_right <| le_principal_iff.2 <|
    mem_pure.2 right_mem_Iic

theorem disjoint_pure_atBot [Preorder Î±] [NoMinOrder Î±] (x : Î±) : Disjoint (pure x) atBot :=
  @disjoint_pure_atTop Î±áµ’áµˆ _ _ _

theorem not_tendsto_const_atTop [Preorder Î±] [NoMaxOrder Î±] (x : Î±) (l : Filter Î²) [l.NeBot] :
    Â¬Tendsto (fun _ => x) l atTop :=
  tendsto_const_pure.not_tendsto (disjoint_pure_atTop x)

theorem not_tendsto_const_atBot [Preorder Î±] [NoMinOrder Î±] (x : Î±) (l : Filter Î²) [l.NeBot] :
    Â¬Tendsto (fun _ => x) l atBot :=
  tendsto_const_pure.not_tendsto (disjoint_pure_atBot x)

theorem disjoint_atBot_atTop [PartialOrder Î±] [Nontrivial Î±] :
    Disjoint (atBot : Filter Î±) atTop := by
  rcases exists_pair_ne Î± with âŸ¨x, y, hneâŸ©
  by_cases hle : x â‰¤ y
  Â· refine disjoint_of_disjoint_of_mem ?_ (Iic_mem_atBot x) (Ici_mem_atTop y)
    exact Iic_disjoint_Ici.2 (hle.lt_of_ne hne).not_le
  Â· refine disjoint_of_disjoint_of_mem ?_ (Iic_mem_atBot y) (Ici_mem_atTop x)
    exact Iic_disjoint_Ici.2 hle

theorem disjoint_atTop_atBot [PartialOrder Î±] [Nontrivial Î±] : Disjoint (atTop : Filter Î±) atBot :=
  disjoint_atBot_atTop.symm

theorem eventually_ge_atTop [Preorder Î±] (a : Î±) : âˆ€á¶  x in atTop, a â‰¤ x :=
  mem_atTop a

theorem eventually_le_atBot [Preorder Î±] (a : Î±) : âˆ€á¶  x in atBot, x â‰¤ a :=
  mem_atBot a

theorem eventually_gt_atTop [Preorder Î±] [NoMaxOrder Î±] (a : Î±) : âˆ€á¶  x in atTop, a < x :=
  Ioi_mem_atTop a

theorem eventually_ne_atTop [Preorder Î±] [NoMaxOrder Î±] (a : Î±) : âˆ€á¶  x in atTop, x â‰  a :=
  (eventually_gt_atTop a).mono fun _ => ne_of_gt

protected theorem Tendsto.eventually_gt_atTop [Preorder Î²] [NoMaxOrder Î²] {f : Î± â†’ Î²} {l : Filter Î±}
    (hf : Tendsto f l atTop) (c : Î²) : âˆ€á¶  x in l, c < f x :=
  hf.eventually (eventually_gt_atTop c)

protected theorem Tendsto.eventually_ge_atTop [Preorder Î²] {f : Î± â†’ Î²} {l : Filter Î±}
    (hf : Tendsto f l atTop) (c : Î²) : âˆ€á¶  x in l, c â‰¤ f x :=
  hf.eventually (eventually_ge_atTop c)

protected theorem Tendsto.eventually_ne_atTop [Preorder Î²] [NoMaxOrder Î²] {f : Î± â†’ Î²} {l : Filter Î±}
    (hf : Tendsto f l atTop) (c : Î²) : âˆ€á¶  x in l, f x â‰  c :=
  hf.eventually (eventually_ne_atTop c)

protected theorem Tendsto.eventually_ne_atTop' [Preorder Î²] [NoMaxOrder Î²] {f : Î± â†’ Î²}
    {l : Filter Î±} (hf : Tendsto f l atTop) (c : Î±) : âˆ€á¶  x in l, x â‰  c :=
  (hf.eventually_ne_atTop (f c)).mono fun _ => ne_of_apply_ne f

theorem eventually_lt_atBot [Preorder Î±] [NoMinOrder Î±] (a : Î±) : âˆ€á¶  x in atBot, x < a :=
  Iio_mem_atBot a

theorem eventually_ne_atBot [Preorder Î±] [NoMinOrder Î±] (a : Î±) : âˆ€á¶  x in atBot, x â‰  a :=
  (eventually_lt_atBot a).mono fun _ => ne_of_lt

protected theorem Tendsto.eventually_lt_atBot [Preorder Î²] [NoMinOrder Î²] {f : Î± â†’ Î²} {l : Filter Î±}
    (hf : Tendsto f l atBot) (c : Î²) : âˆ€á¶  x in l, f x < c :=
  hf.eventually (eventually_lt_atBot c)

protected theorem Tendsto.eventually_le_atBot [Preorder Î²] {f : Î± â†’ Î²} {l : Filter Î±}
    (hf : Tendsto f l atBot) (c : Î²) : âˆ€á¶  x in l, f x â‰¤ c :=
  hf.eventually (eventually_le_atBot c)

protected theorem Tendsto.eventually_ne_atBot [Preorder Î²] [NoMinOrder Î²] {f : Î± â†’ Î²} {l : Filter Î±}
    (hf : Tendsto f l atBot) (c : Î²) : âˆ€á¶  x in l, f x â‰  c :=
  hf.eventually (eventually_ne_atBot c)

theorem eventually_forall_ge_atTop [Preorder Î±] {p : Î± â†’ Prop} :
    (âˆ€á¶  x in atTop, âˆ€ y, x â‰¤ y â†’ p y) â†” âˆ€á¶  x in atTop, p x := by
  refine âŸ¨fun h â†¦ h.mono fun x hx â†¦ hx x le_rfl, fun h â†¦ ?_âŸ©
  rcases (hasBasis_iInf_principal_finite _).eventually_iff.1 h with âŸ¨S, hSf, hSâŸ©
  refine mem_iInf_of_iInter hSf (V := fun x â†¦ Ici x.1) (fun _ â†¦ Subset.rfl) fun x hx y hy â†¦ ?_
  simp only [mem_iInter] at hS hx
  exact hS fun z hz â†¦ le_trans (hx âŸ¨z, hzâŸ©) hy

theorem eventually_forall_le_atBot [Preorder Î±] {p : Î± â†’ Prop} :
    (âˆ€á¶  x in atBot, âˆ€ y, y â‰¤ x â†’ p y) â†” âˆ€á¶  x in atBot, p x :=
  eventually_forall_ge_atTop (Î± := Î±áµ’áµˆ)

theorem Tendsto.eventually_forall_ge_atTop [Preorder Î²] {l : Filter Î±}
    {p : Î² â†’ Prop} {f : Î± â†’ Î²} (hf : Tendsto f l atTop) (h_evtl : âˆ€á¶  x in atTop, p x) :
    âˆ€á¶  x in l, âˆ€ y, f x â‰¤ y â†’ p y := by
  rw [â† Filter.eventually_forall_ge_atTop] at h_evtl; exact (h_evtl.comap f).filter_mono hf.le_comap

theorem Tendsto.eventually_forall_le_atBot [Preorder Î²] {l : Filter Î±}
    {p : Î² â†’ Prop} {f : Î± â†’ Î²} (hf : Tendsto f l atBot) (h_evtl : âˆ€á¶  x in atBot, p x) :
    âˆ€á¶  x in l, âˆ€ y, y â‰¤ f x â†’ p y := by
  rw [â† Filter.eventually_forall_le_atBot] at h_evtl; exact (h_evtl.comap f).filter_mono hf.le_comap

instance (priority := 200) atTop.isCountablyGenerated [Preorder Î±] [Countable Î±] :
    (atTop : Filter <| Î±).IsCountablyGenerated :=
  isCountablyGenerated_seq _

instance (priority := 200) atBot.isCountablyGenerated [Preorder Î±] [Countable Î±] :
    (atBot : Filter <| Î±).IsCountablyGenerated :=
  isCountablyGenerated_seq _

instance _root_.OrderDual.instIsCountablyGeneratedAtTop [Preorder Î±]
    [IsCountablyGenerated (atBot : Filter Î±)] : IsCountablyGenerated (atTop : Filter Î±áµ’áµˆ) := â€¹_â€º

instance _root_.OrderDual.instIsCountablyGeneratedAtBot [Preorder Î±]
    [IsCountablyGenerated (atTop : Filter Î±)] : IsCountablyGenerated (atBot : Filter Î±áµ’áµˆ) := â€¹_â€º

theorem _root_.IsTop.atTop_eq [Preorder Î±] {a : Î±} (ha : IsTop a) : atTop = ğ“Ÿ (Ici a) :=
  (iInf_le _ _).antisymm <| le_iInf fun b â†¦ principal_mono.2 <| Ici_subset_Ici.2 <| ha b

theorem _root_.IsBot.atBot_eq [Preorder Î±] {a : Î±} (ha : IsBot a) : atBot = ğ“Ÿ (Iic a) :=
  ha.toDual.atTop_eq

theorem OrderTop.atTop_eq (Î±) [PartialOrder Î±] [OrderTop Î±] : (atTop : Filter Î±) = pure âŠ¤ := by
  rw [isTop_top.atTop_eq, Ici_top, principal_singleton]

theorem OrderBot.atBot_eq (Î±) [PartialOrder Î±] [OrderBot Î±] : (atBot : Filter Î±) = pure âŠ¥ :=
  @OrderTop.atTop_eq Î±áµ’áµˆ _ _

@[nontriviality]
theorem Subsingleton.atTop_eq (Î±) [Subsingleton Î±] [Preorder Î±] : (atTop : Filter Î±) = âŠ¤ := by
  refine top_unique fun s hs x => ?_
  rw [atTop, ciInf_subsingleton x, mem_principal] at hs
  exact hs left_mem_Ici

@[nontriviality]
theorem Subsingleton.atBot_eq (Î±) [Subsingleton Î±] [Preorder Î±] : (atBot : Filter Î±) = âŠ¤ :=
  @Subsingleton.atTop_eq Î±áµ’áµˆ _ _

theorem tendsto_atTop_pure [PartialOrder Î±] [OrderTop Î±] (f : Î± â†’ Î²) :
    Tendsto f atTop (pure <| f âŠ¤) :=
  (OrderTop.atTop_eq Î±).symm â–¸ tendsto_pure_pure _ _

theorem tendsto_atBot_pure [PartialOrder Î±] [OrderBot Î±] (f : Î± â†’ Î²) :
    Tendsto f atBot (pure <| f âŠ¥) :=
  @tendsto_atTop_pure Î±áµ’áµˆ _ _ _ _

theorem atTop_eq_generate_Ici [Preorder Î±] : atTop = generate (range (Ici (Î± := Î±))) := by
  simp only [generate_eq_biInf, atTop, iInf_range]

theorem Frequently.forall_exists_of_atTop [Preorder Î±] {p : Î± â†’ Prop}
    (h : âˆƒá¶  x in atTop, p x) (a : Î±) : âˆƒ b â‰¥ a, p b := by
  rw [Filter.Frequently] at h
  contrapose! h
  exact (eventually_ge_atTop a).mono h

theorem Frequently.forall_exists_of_atBot [Preorder Î±] {p : Î± â†’ Prop}
    (h : âˆƒá¶  x in atBot, p x) (a : Î±) : âˆƒ b â‰¤ a, p b :=
  Frequently.forall_exists_of_atTop (Î± := Î±áµ’áµˆ) h _

section IsDirected
variable [Preorder Î±] [IsDirected Î± (Â· â‰¤ Â·)] {p : Î± â†’ Prop}

theorem hasAntitoneBasis_atTop [Nonempty Î±] : (@atTop Î± _).HasAntitoneBasis Ici :=
  .iInf_principal fun _ _ â†¦ Ici_subset_Ici.2

theorem atTop_basis [Nonempty Î±] : (@atTop Î± _).HasBasis (fun _ => True) Ici :=
  hasAntitoneBasis_atTop.1

lemma atTop_basis_Ioi [Nonempty Î±] [NoMaxOrder Î±] : (@atTop Î± _).HasBasis (fun _ => True) Ioi :=
  atTop_basis.to_hasBasis (fun a ha => âŸ¨a, ha, Ioi_subset_Ici_selfâŸ©) fun a ha =>
    (exists_gt a).imp fun _b hb => âŸ¨ha, Ici_subset_Ioi.2 hbâŸ©

lemma atTop_basis_Ioi' [NoMaxOrder Î±] (a : Î±) : atTop.HasBasis (a < Â·) Ioi := by
  have : Nonempty Î± := âŸ¨aâŸ©
  refine atTop_basis_Ioi.to_hasBasis (fun b _ â†¦ ?_) fun b _ â†¦ âŸ¨b, trivial, Subset.rflâŸ©
  obtain âŸ¨c, hac, hbcâŸ© := exists_ge_ge a b
  obtain âŸ¨d, hcdâŸ© := exists_gt c
  exact âŸ¨d, hac.trans_lt hcd, Ioi_subset_Ioi (hbc.trans hcd.le)âŸ©

theorem atTop_basis' (a : Î±) : atTop.HasBasis (a â‰¤ Â·) Ici := by
  have : Nonempty Î± := âŸ¨aâŸ©
  refine atTop_basis.to_hasBasis (fun b _ â†¦ ?_) fun b _ â†¦ âŸ¨b, trivial, Subset.rflâŸ©
  obtain âŸ¨c, hac, hbcâŸ© := exists_ge_ge a b
  exact âŸ¨c, hac, Ici_subset_Ici.2 hbcâŸ©

variable [Nonempty Î±]

@[instance]
lemma atTop_neBot : NeBot (atTop : Filter Î±) := atTop_basis.neBot_iff.2 fun _ => nonempty_Ici

theorem atTop_neBot_iff {Î± : Type*} [Preorder Î±] :
    (atTop : Filter Î±).NeBot â†” Nonempty Î± âˆ§ IsDirected Î± (Â· â‰¤ Â·) := by
  refine âŸ¨fun h â†¦ âŸ¨nonempty_of_neBot atTop, âŸ¨fun x y â†¦ ?_âŸ©âŸ©, fun âŸ¨hâ‚, hâ‚‚âŸ© â†¦ atTop_neBotâŸ©
  exact ((eventually_ge_atTop x).and (eventually_ge_atTop y)).exists

theorem atBot_neBot_iff {Î± : Type*} [Preorder Î±] :
    (atBot : Filter Î±).NeBot â†” Nonempty Î± âˆ§ IsDirected Î± (Â· â‰¥ Â·) :=
  atTop_neBot_iff (Î± := Î±áµ’áµˆ)

@[simp] lemma mem_atTop_sets {s : Set Î±} : s âˆˆ (atTop : Filter Î±) â†” âˆƒ a : Î±, âˆ€ b â‰¥ a, b âˆˆ s :=
  atTop_basis.mem_iff.trans <| exists_congr fun _ => iff_of_eq (true_and _)

@[simp] lemma eventually_atTop : (âˆ€á¶  x in atTop, p x) â†” âˆƒ a, âˆ€ b â‰¥ a, p b := mem_atTop_sets

theorem frequently_atTop : (âˆƒá¶  x in atTop, p x) â†” âˆ€ a, âˆƒ b â‰¥ a, p b :=
  atTop_basis.frequently_iff.trans <| by simp

alias âŸ¨Eventually.exists_forall_of_atTop, _âŸ© := eventually_atTop

lemma exists_eventually_atTop {r : Î± â†’ Î² â†’ Prop} :
    (âˆƒ b, âˆ€á¶  a in atTop, r a b) â†” âˆ€á¶  aâ‚€ in atTop, âˆƒ b, âˆ€ a â‰¥ aâ‚€, r a b := by
  simp_rw [eventually_atTop, â† exists_swap (Î± := Î±)]
  exact exists_congr fun a â†¦ .symm <| forall_ge_iff <| Monotone.exists fun _ _ _ hb H n hn â†¦
    H n (hb.trans hn)

theorem map_atTop_eq {f : Î± â†’ Î²} : atTop.map f = â¨… a, ğ“Ÿ (f '' { a' | a â‰¤ a' }) :=
  (atTop_basis.map f).eq_iInf

theorem frequently_atTop' [NoMaxOrder Î±] : (âˆƒá¶  x in atTop, p x) â†” âˆ€ a, âˆƒ b > a, p b :=
  atTop_basis_Ioi.frequently_iff.trans <| by simp

lemma atTop_countable_basis [Countable Î±] :
    HasCountableBasis (atTop : Filter Î±) (fun _ => True) Ici :=
  { atTop_basis with countable := to_countable _ }

end IsDirected

section IsCodirected
variable [Preorder Î±] [IsDirected Î± (Â· â‰¥ Â·)] {p : Î± â†’ Prop}

lemma atBot_basis_Iio [Nonempty Î±] [NoMinOrder Î±] : (@atBot Î± _).HasBasis (fun _ => True) Iio :=
  atTop_basis_Ioi (Î± := Î±áµ’áµˆ)

lemma atBot_basis_Iio' [NoMinOrder Î±] (a : Î±) : atBot.HasBasis (Â· < a) Iio :=
  atTop_basis_Ioi' (Î± := Î±áµ’áµˆ) a

lemma atBot_basis' (a : Î±) : (@atBot Î± _).HasBasis (fun x => x â‰¤ a) Iic := atTop_basis' (Î± := Î±áµ’áµˆ) _

variable [Nonempty Î±]

lemma atBot_basis : (@atBot Î± _).HasBasis (fun _ => True) Iic := atTop_basis (Î± := Î±áµ’áµˆ)

@[instance] lemma atBot_neBot : NeBot (atBot : Filter Î±) := atTop_neBot (Î± := Î±áµ’áµˆ)

@[simp] lemma mem_atBot_sets {s : Set Î±} : s âˆˆ (atBot : Filter Î±) â†” âˆƒ a : Î±, âˆ€ b â‰¤ a, b âˆˆ s :=
  mem_atTop_sets (Î± := Î±áµ’áµˆ)

@[simp] lemma eventually_atBot : (âˆ€á¶  x in atBot, p x) â†” âˆƒ a, âˆ€ b â‰¤ a, p b := mem_atBot_sets

theorem frequently_atBot : (âˆƒá¶  x in atBot, p x) â†” âˆ€ a, âˆƒ b â‰¤ a, p b := frequently_atTop (Î± := Î±áµ’áµˆ)

alias âŸ¨Eventually.exists_forall_of_atBot, _âŸ© := eventually_atBot

lemma exists_eventually_atBot {r : Î± â†’ Î² â†’ Prop} :
    (âˆƒ b, âˆ€á¶  a in atBot, r a b) â†” âˆ€á¶  aâ‚€ in atBot, âˆƒ b, âˆ€ a â‰¤ aâ‚€, r a b :=
  exists_eventually_atTop (Î± := Î±áµ’áµˆ)

theorem map_atBot_eq {f : Î± â†’ Î²} : atBot.map f = â¨… a, ğ“Ÿ (f '' { a' | a' â‰¤ a }) :=
  map_atTop_eq (Î± := Î±áµ’áµˆ)

theorem frequently_atBot' [NoMinOrder Î±] : (âˆƒá¶  x in atBot, p x) â†” âˆ€ a, âˆƒ b < a, p b :=
  frequently_atTop' (Î± := Î±áµ’áµˆ)

lemma atBot_countable_basis [Countable Î±] :
    HasCountableBasis (atBot : Filter Î±) (fun _ => True) Iic :=
  { atBot_basis with countable := to_countable _ }

end IsCodirected

theorem tendsto_atTop [Preorder Î²] {m : Î± â†’ Î²} {f : Filter Î±} :
    Tendsto m f atTop â†” âˆ€ b, âˆ€á¶  a in f, b â‰¤ m a := by
  simp only [atTop, tendsto_iInf, tendsto_principal, mem_Ici]

theorem tendsto_atBot [Preorder Î²] {m : Î± â†’ Î²} {f : Filter Î±} :
    Tendsto m f atBot â†” âˆ€ b, âˆ€á¶  a in f, m a â‰¤ b :=
  @tendsto_atTop Î± Î²áµ’áµˆ _ m f

theorem tendsto_atTop_mono' [Preorder Î²] (l : Filter Î±) â¦ƒfâ‚ fâ‚‚ : Î± â†’ Î²â¦„ (h : fâ‚ â‰¤á¶ [l] fâ‚‚)
    (hâ‚ : Tendsto fâ‚ l atTop) : Tendsto fâ‚‚ l atTop :=
  tendsto_atTop.2 fun b => by filter_upwards [tendsto_atTop.1 hâ‚ b, h] with x using le_trans

theorem tendsto_atBot_mono' [Preorder Î²] (l : Filter Î±) â¦ƒfâ‚ fâ‚‚ : Î± â†’ Î²â¦„ (h : fâ‚ â‰¤á¶ [l] fâ‚‚) :
    Tendsto fâ‚‚ l atBot â†’ Tendsto fâ‚ l atBot :=
  @tendsto_atTop_mono' _ Î²áµ’áµˆ _ _ _ _ h

theorem tendsto_atTop_mono [Preorder Î²] {l : Filter Î±} {f g : Î± â†’ Î²} (h : âˆ€ n, f n â‰¤ g n) :
    Tendsto f l atTop â†’ Tendsto g l atTop :=
  tendsto_atTop_mono' l <| Eventually.of_forall h

theorem tendsto_atBot_mono [Preorder Î²] {l : Filter Î±} {f g : Î± â†’ Î²} (h : âˆ€ n, f n â‰¤ g n) :
    Tendsto g l atBot â†’ Tendsto f l atBot :=
  @tendsto_atTop_mono _ Î²áµ’áµˆ _ _ _ _ h

lemma atTop_eq_generate_of_forall_exists_le [LinearOrder Î±] {s : Set Î±} (hs : âˆ€ x, âˆƒ y âˆˆ s, x â‰¤ y) :
    (atTop : Filter Î±) = generate (Ici '' s) := by
  rw [atTop_eq_generate_Ici]
  apply le_antisymm
  Â· rw [le_generate_iff]
    rintro - âŸ¨y, -, rflâŸ©
    exact mem_generate_of_mem âŸ¨y, rflâŸ©
  Â· rw [le_generate_iff]
    rintro - âŸ¨x, -, -, rflâŸ©
    rcases hs x with âŸ¨y, ys, hyâŸ©
    have A : Ici y âˆˆ generate (Ici '' s) := mem_generate_of_mem (mem_image_of_mem _ ys)
    have B : Ici y âŠ† Ici x := Ici_subset_Ici.2 hy
    exact sets_of_superset (generate (Ici '' s)) A B

lemma atTop_eq_generate_of_not_bddAbove [LinearOrder Î±] {s : Set Î±} (hs : Â¬ BddAbove s) :
    (atTop : Filter Î±) = generate (Ici '' s) := by
  refine atTop_eq_generate_of_forall_exists_le fun x â†¦ ?_
  obtain âŸ¨y, hy, hy'âŸ© := not_bddAbove_iff.mp hs x
  exact âŸ¨y, hy, hy'.leâŸ©

end Filter

namespace OrderIso

open Filter

variable [Preorder Î±] [Preorder Î²]

@[simp]
theorem comap_atTop (e : Î± â‰ƒo Î²) : comap e atTop = atTop := by
  simp [atTop, â† e.surjective.iInf_comp]

@[simp]
theorem comap_atBot (e : Î± â‰ƒo Î²) : comap e atBot = atBot :=
  e.dual.comap_atTop

@[simp]
theorem map_atTop (e : Î± â‰ƒo Î²) : map (e : Î± â†’ Î²) atTop = atTop := by
  rw [â† e.comap_atTop, map_comap_of_surjective e.surjective]

@[simp]
theorem map_atBot (e : Î± â‰ƒo Î²) : map (e : Î± â†’ Î²) atBot = atBot :=
  e.dual.map_atTop

theorem tendsto_atTop (e : Î± â‰ƒo Î²) : Tendsto e atTop atTop :=
  e.map_atTop.le

theorem tendsto_atBot (e : Î± â‰ƒo Î²) : Tendsto e atBot atBot :=
  e.map_atBot.le

@[simp]
theorem tendsto_atTop_iff {l : Filter Î³} {f : Î³ â†’ Î±} (e : Î± â‰ƒo Î²) :
    Tendsto (fun x => e (f x)) l atTop â†” Tendsto f l atTop := by
  rw [â† e.comap_atTop, tendsto_comap_iff, Function.comp_def]

@[simp]
theorem tendsto_atBot_iff {l : Filter Î³} {f : Î³ â†’ Î±} (e : Î± â‰ƒo Î²) :
    Tendsto (fun x => e (f x)) l atBot â†” Tendsto f l atBot :=
  e.dual.tendsto_atTop_iff

end OrderIso

namespace Filter

/-!
### Sequences
-/

theorem extraction_of_frequently_atTop' {P : â„• â†’ Prop} (h : âˆ€ N, âˆƒ n > N, P n) :
    âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ n, P (Ï† n) := by
  choose u hu hu' using h
  refine âŸ¨fun n => u^[n + 1] 0, strictMono_nat_of_lt_succ fun n => ?_, fun n => ?_âŸ©
  Â· exact Trans.trans (hu _) (Function.iterate_succ_apply' _ _ _).symm
  Â· simpa only [Function.iterate_succ_apply'] using hu' _

theorem extraction_of_frequently_atTop {P : â„• â†’ Prop} (h : âˆƒá¶  n in atTop, P n) :
    âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ n, P (Ï† n) := by
  rw [frequently_atTop'] at h
  exact extraction_of_frequently_atTop' h

theorem extraction_of_eventually_atTop {P : â„• â†’ Prop} (h : âˆ€á¶  n in atTop, P n) :
    âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ n, P (Ï† n) :=
  extraction_of_frequently_atTop h.frequently

theorem extraction_forall_of_frequently {P : â„• â†’ â„• â†’ Prop} (h : âˆ€ n, âˆƒá¶  k in atTop, P n k) :
    âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ n, P n (Ï† n) := by
  simp only [frequently_atTop'] at h
  choose u hu hu' using h
  use (fun n => Nat.recOn n (u 0 0) fun n v => u (n + 1) v : â„• â†’ â„•)
  constructor
  Â· apply strictMono_nat_of_lt_succ
    intro n
    apply hu
  Â· intro n
    cases n <;> simp [hu']

theorem extraction_forall_of_eventually {P : â„• â†’ â„• â†’ Prop} (h : âˆ€ n, âˆ€á¶  k in atTop, P n k) :
    âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ n, P n (Ï† n) :=
  extraction_forall_of_frequently fun n => (h n).frequently

theorem extraction_forall_of_eventually' {P : â„• â†’ â„• â†’ Prop} (h : âˆ€ n, âˆƒ N, âˆ€ k â‰¥ N, P n k) :
    âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ n, P n (Ï† n) :=
  extraction_forall_of_eventually (by simp [eventually_atTop, h])

theorem Eventually.atTop_of_arithmetic {p : â„• â†’ Prop} {n : â„•} (hn : n â‰  0)
    (hp : âˆ€ k < n, âˆ€á¶  a in atTop, p (n * a + k)) : âˆ€á¶  a in atTop, p a := by
  simp only [eventually_atTop] at hp âŠ¢
  choose! N hN using hp
  refine âŸ¨(Finset.range n).sup (n * N Â·), fun b hb => ?_âŸ©
  rw [â† Nat.div_add_mod b n]
  have hlt := Nat.mod_lt b hn.bot_lt
  refine hN _ hlt _ ?_
  rw [ge_iff_le, Nat.le_div_iff_mul_le hn.bot_lt, mul_comm]
  exact (Finset.le_sup (f := (n * N Â·)) (Finset.mem_range.2 hlt)).trans hb

section IsDirected
variable [Preorder Î±] [IsDirected Î± (Â· â‰¤ Â·)] {F : Filter Î²} {u : Î± â†’ Î²}

theorem inf_map_atTop_neBot_iff [Nonempty Î±] :
    NeBot (F âŠ“ map u atTop) â†” âˆ€ U âˆˆ F, âˆ€ N, âˆƒ n â‰¥ N, u n âˆˆ U := by
  simp_rw [inf_neBot_iff_frequently_left, frequently_map, frequently_atTop]; rfl

variable [Preorder Î²]

lemma exists_le_of_tendsto_atTop (h : Tendsto u atTop atTop) (a : Î±) (b : Î²) :
    âˆƒ a' â‰¥ a, b â‰¤ u a' := by
  have : Nonempty Î± := âŸ¨aâŸ©
  have : âˆ€á¶  x in atTop, a â‰¤ x âˆ§ b â‰¤ u x :=
    (eventually_ge_atTop a).and (h.eventually <| eventually_ge_atTop b)
  exact this.exists

-- @[nolint ge_or_gt] -- Porting note: restore attribute
theorem exists_le_of_tendsto_atBot (h : Tendsto u atTop atBot) :
    âˆ€ a b, âˆƒ a' â‰¥ a, u a' â‰¤ b := exists_le_of_tendsto_atTop (Î² := Î²áµ’áµˆ) h

theorem exists_lt_of_tendsto_atTop [NoMaxOrder Î²] (h : Tendsto u atTop atTop) (a : Î±) (b : Î²) :
    âˆƒ a' â‰¥ a, b < u a' := by
  cases' exists_gt b with b' hb'
  rcases exists_le_of_tendsto_atTop h a b' with âŸ¨a', ha', ha''âŸ©
  exact âŸ¨a', ha', lt_of_lt_of_le hb' ha''âŸ©

-- @[nolint ge_or_gt] -- Porting note: restore attribute
theorem exists_lt_of_tendsto_atBot [NoMinOrder Î²] (h : Tendsto u atTop atBot) :
    âˆ€ a b, âˆƒ a' â‰¥ a, u a' < b := exists_lt_of_tendsto_atTop (Î² := Î²áµ’áµˆ) h

end IsDirected

section IsCodirected
variable [Nonempty Î±] [Preorder Î±] [IsDirected Î± (Â· â‰¥ Â·)] {F : Filter Î²} {u : Î± â†’ Î²}

theorem inf_map_atBot_neBot_iff : NeBot (F âŠ“ map u atBot) â†” âˆ€ U âˆˆ F, âˆ€ N, âˆƒ n â‰¤ N, u n âˆˆ U :=
  inf_map_atTop_neBot_iff (Î± := Î±áµ’áµˆ)

end IsCodirected

/-- If `u` is a sequence which is unbounded above,
then after any point, it reaches a value strictly greater than all previous values.
-/
theorem high_scores [LinearOrder Î²] [NoMaxOrder Î²] {u : â„• â†’ Î²} (hu : Tendsto u atTop atTop) :
    âˆ€ N, âˆƒ n â‰¥ N, âˆ€ k < n, u k < u n := by
  intro N
  obtain âŸ¨k : â„•, - : k â‰¤ N, hku : âˆ€ l â‰¤ N, u l â‰¤ u kâŸ© : âˆƒ k â‰¤ N, âˆ€ l â‰¤ N, u l â‰¤ u k :=
    exists_max_image _ u (finite_le_nat N) âŸ¨N, le_refl NâŸ©
  have ex : âˆƒ n â‰¥ N, u k < u n := exists_lt_of_tendsto_atTop hu _ _
  obtain âŸ¨n : â„•, hnN : n â‰¥ N, hnk : u k < u n, hn_min : âˆ€ m, m < n â†’ N â‰¤ m â†’ u m â‰¤ u kâŸ© :
      âˆƒ n â‰¥ N, u k < u n âˆ§ âˆ€ m, m < n â†’ N â‰¤ m â†’ u m â‰¤ u k := by
    rcases Nat.findX ex with âŸ¨n, âŸ¨hnN, hnkâŸ©, hn_minâŸ©
    push_neg at hn_min
    exact âŸ¨n, hnN, hnk, hn_minâŸ©
  use n, hnN
  rintro (l : â„•) (hl : l < n)
  have hlk : u l â‰¤ u k := by
    cases' (le_total l N : l â‰¤ N âˆ¨ N â‰¤ l) with H H
    Â· exact hku l H
    Â· exact hn_min l hl H
  calc
    u l â‰¤ u k := hlk
    _ < u n := hnk

-- see Note [nolint_ge]
/-- If `u` is a sequence which is unbounded below,
then after any point, it reaches a value strictly smaller than all previous values.
-/
-- @[nolint ge_or_gt] Porting note: restore attribute
theorem low_scores [LinearOrder Î²] [NoMinOrder Î²] {u : â„• â†’ Î²} (hu : Tendsto u atTop atBot) :
    âˆ€ N, âˆƒ n â‰¥ N, âˆ€ k < n, u n < u k :=
  @high_scores Î²áµ’áµˆ _ _ _ hu

/-- If `u` is a sequence which is unbounded above,
then it `Frequently` reaches a value strictly greater than all previous values.
-/
theorem frequently_high_scores [LinearOrder Î²] [NoMaxOrder Î²] {u : â„• â†’ Î²}
    (hu : Tendsto u atTop atTop) : âˆƒá¶  n in atTop, âˆ€ k < n, u k < u n := by
  simpa [frequently_atTop] using high_scores hu

/-- If `u` is a sequence which is unbounded below,
then it `Frequently` reaches a value strictly smaller than all previous values.
-/
theorem frequently_low_scores [LinearOrder Î²] [NoMinOrder Î²] {u : â„• â†’ Î²}
    (hu : Tendsto u atTop atBot) : âˆƒá¶  n in atTop, âˆ€ k < n, u n < u k :=
  @frequently_high_scores Î²áµ’áµˆ _ _ _ hu

theorem strictMono_subseq_of_tendsto_atTop [LinearOrder Î²] [NoMaxOrder Î²] {u : â„• â†’ Î²}
    (hu : Tendsto u atTop atTop) : âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ StrictMono (u âˆ˜ Ï†) :=
  let âŸ¨Ï†, h, h'âŸ© := extraction_of_frequently_atTop (frequently_high_scores hu)
  âŸ¨Ï†, h, fun _ m hnm => h' m _ (h hnm)âŸ©

theorem strictMono_subseq_of_id_le {u : â„• â†’ â„•} (hu : âˆ€ n, n â‰¤ u n) :
    âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ StrictMono (u âˆ˜ Ï†) :=
  strictMono_subseq_of_tendsto_atTop (tendsto_atTop_mono hu tendsto_id)

theorem _root_.StrictMono.tendsto_atTop {Ï† : â„• â†’ â„•} (h : StrictMono Ï†) : Tendsto Ï† atTop atTop :=
  tendsto_atTop_mono h.id_le tendsto_id

theorem tendsto_atTop_atTop_of_monotone [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} (hf : Monotone f)
    (h : âˆ€ b, âˆƒ a, b â‰¤ f a) : Tendsto f atTop atTop :=
  tendsto_iInf.2 fun b =>
    tendsto_principal.2 <|
      let âŸ¨a, haâŸ© := h b
      mem_of_superset (mem_atTop a) fun _a' ha' => le_trans ha (hf ha')

theorem tendsto_atTop_atBot_of_antitone [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} (hf : Antitone f)
    (h : âˆ€ b, âˆƒ a, f a â‰¤ b) : Tendsto f atTop atBot :=
  @tendsto_atTop_atTop_of_monotone _ Î²áµ’áµˆ _ _ _ hf h

theorem tendsto_atBot_atBot_of_monotone [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} (hf : Monotone f)
    (h : âˆ€ b, âˆƒ a, f a â‰¤ b) : Tendsto f atBot atBot :=
  tendsto_iInf.2 fun b => tendsto_principal.2 <|
    let âŸ¨a, haâŸ© := h b; mem_of_superset (mem_atBot a) fun _a' ha' => le_trans (hf ha') ha

theorem tendsto_atBot_atTop_of_antitone [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} (hf : Antitone f)
    (h : âˆ€ b, âˆƒ a, b â‰¤ f a) : Tendsto f atBot atTop :=
  @tendsto_atBot_atBot_of_monotone _ Î²áµ’áµˆ _ _ _ hf h

section IsDirected
variable [Nonempty Î±] [Preorder Î±] [IsDirected Î± (Â· â‰¤ Â·)] {f : Î± â†’ Î²} {l : Filter Î²}

theorem tendsto_atTop' : Tendsto f atTop l â†” âˆ€ s âˆˆ l, âˆƒ a, âˆ€ b â‰¥ a, f b âˆˆ s := by
  simp only [tendsto_def, mem_atTop_sets, mem_preimage]

theorem tendsto_atTop_principal {s : Set Î²} : Tendsto f atTop (ğ“Ÿ s) â†” âˆƒ N, âˆ€ n â‰¥ N, f n âˆˆ s := by
  simp_rw [tendsto_iff_comap, comap_principal, le_principal_iff, mem_atTop_sets, mem_preimage]

variable [Preorder Î²]

/-- A function `f` grows to `+âˆ` independent of an order-preserving embedding `e`. -/
theorem tendsto_atTop_atTop : Tendsto f atTop atTop â†” âˆ€ b : Î², âˆƒ i : Î±, âˆ€ a : Î±, i â‰¤ a â†’ b â‰¤ f a :=
  tendsto_iInf.trans <| forall_congr' fun _ => tendsto_atTop_principal

theorem tendsto_atTop_atBot : Tendsto f atTop atBot â†” âˆ€ b : Î², âˆƒ i : Î±, âˆ€ a : Î±, i â‰¤ a â†’ f a â‰¤ b :=
  tendsto_atTop_atTop (Î² := Î²áµ’áµˆ)

theorem tendsto_atTop_atTop_iff_of_monotone (hf : Monotone f) :
    Tendsto f atTop atTop â†” âˆ€ b : Î², âˆƒ a, b â‰¤ f a :=
  tendsto_atTop_atTop.trans <| forall_congr' fun _ => exists_congr fun a =>
    âŸ¨fun h => h a (le_refl a), fun h _a' ha' => le_trans h <| hf ha'âŸ©

theorem tendsto_atTop_atBot_iff_of_antitone (hf : Antitone f) :
    Tendsto f atTop atBot â†” âˆ€ b : Î², âˆƒ a, f a â‰¤ b :=
  tendsto_atTop_atTop_iff_of_monotone (Î² := Î²áµ’áµˆ) hf

end IsDirected

section IsCodirected
variable [Nonempty Î±] [Preorder Î±] [IsDirected Î± (Â· â‰¥ Â·)] {f : Î± â†’ Î²} {l : Filter Î²}

theorem tendsto_atBot' : Tendsto f atBot l â†” âˆ€ s âˆˆ l, âˆƒ a, âˆ€ b â‰¤ a, f b âˆˆ s :=
  tendsto_atTop' (Î± := Î±áµ’áµˆ)

theorem tendsto_atBot_principal {s : Set Î²} : Tendsto f atBot (ğ“Ÿ s) â†” âˆƒ N, âˆ€ n â‰¤ N, f n âˆˆ s :=
  tendsto_atTop_principal (Î± := Î±áµ’áµˆ) (Î² := Î²áµ’áµˆ)

variable [Preorder Î²]

theorem tendsto_atBot_atTop : Tendsto f atBot atTop â†” âˆ€ b : Î², âˆƒ i : Î±, âˆ€ a : Î±, a â‰¤ i â†’ b â‰¤ f a :=
  tendsto_atTop_atTop (Î± := Î±áµ’áµˆ)

theorem tendsto_atBot_atBot : Tendsto f atBot atBot â†” âˆ€ b : Î², âˆƒ i : Î±, âˆ€ a : Î±, a â‰¤ i â†’ f a â‰¤ b :=
  tendsto_atTop_atTop (Î± := Î±áµ’áµˆ) (Î² := Î²áµ’áµˆ)

theorem tendsto_atBot_atBot_iff_of_monotone (hf : Monotone f) :
    Tendsto f atBot atBot â†” âˆ€ b : Î², âˆƒ a, f a â‰¤ b :=
  tendsto_atBot_atBot.trans <| forall_congr' fun _ => exists_congr fun a =>
    âŸ¨fun h => h a (le_refl a), fun h _a' ha' => le_trans (hf ha') hâŸ©

theorem tendsto_atBot_atTop_iff_of_antitone (hf : Antitone f) :
    Tendsto f atBot atTop â†” âˆ€ b : Î², âˆƒ a, b â‰¤ f a :=
  tendsto_atBot_atBot_iff_of_monotone (Î² := Î²áµ’áµˆ) hf

end IsCodirected

alias _root_.Monotone.tendsto_atTop_atTop := tendsto_atTop_atTop_of_monotone

alias _root_.Monotone.tendsto_atBot_atBot := tendsto_atBot_atBot_of_monotone

alias _root_.Monotone.tendsto_atTop_atTop_iff := tendsto_atTop_atTop_iff_of_monotone

alias _root_.Monotone.tendsto_atBot_atBot_iff := tendsto_atBot_atBot_iff_of_monotone

theorem comap_embedding_atTop [Preorder Î²] [Preorder Î³] {e : Î² â†’ Î³}
    (hm : âˆ€ bâ‚ bâ‚‚, e bâ‚ â‰¤ e bâ‚‚ â†” bâ‚ â‰¤ bâ‚‚) (hu : âˆ€ c, âˆƒ b, c â‰¤ e b) : comap e atTop = atTop :=
  le_antisymm
    (le_iInf fun b =>
      le_principal_iff.2 <| mem_comap.2 âŸ¨Ici (e b), mem_atTop _, fun _ => (hm _ _).1âŸ©)
    (tendsto_atTop_atTop_of_monotone (fun _ _ => (hm _ _).2) hu).le_comap

theorem comap_embedding_atBot [Preorder Î²] [Preorder Î³] {e : Î² â†’ Î³}
    (hm : âˆ€ bâ‚ bâ‚‚, e bâ‚ â‰¤ e bâ‚‚ â†” bâ‚ â‰¤ bâ‚‚) (hu : âˆ€ c, âˆƒ b, e b â‰¤ c) : comap e atBot = atBot :=
  @comap_embedding_atTop Î²áµ’áµˆ Î³áµ’áµˆ _ _ e (Function.swap hm) hu

theorem tendsto_atTop_embedding [Preorder Î²] [Preorder Î³] {f : Î± â†’ Î²} {e : Î² â†’ Î³} {l : Filter Î±}
    (hm : âˆ€ bâ‚ bâ‚‚, e bâ‚ â‰¤ e bâ‚‚ â†” bâ‚ â‰¤ bâ‚‚) (hu : âˆ€ c, âˆƒ b, c â‰¤ e b) :
    Tendsto (e âˆ˜ f) l atTop â†” Tendsto f l atTop := by
  rw [â† comap_embedding_atTop hm hu, tendsto_comap_iff]

/-- A function `f` goes to `-âˆ` independent of an order-preserving embedding `e`. -/
theorem tendsto_atBot_embedding [Preorder Î²] [Preorder Î³] {f : Î± â†’ Î²} {e : Î² â†’ Î³} {l : Filter Î±}
    (hm : âˆ€ bâ‚ bâ‚‚, e bâ‚ â‰¤ e bâ‚‚ â†” bâ‚ â‰¤ bâ‚‚) (hu : âˆ€ c, âˆƒ b, e b â‰¤ c) :
    Tendsto (e âˆ˜ f) l atBot â†” Tendsto f l atBot :=
  @tendsto_atTop_embedding Î± Î²áµ’áµˆ Î³áµ’áµˆ _ _ f e l (Function.swap hm) hu

theorem tendsto_finset_range : Tendsto Finset.range atTop atTop :=
  Finset.range_mono.tendsto_atTop_atTop Finset.exists_nat_subset_range

theorem atTop_finset_eq_iInf : (atTop : Filter (Finset Î±)) = â¨… x : Î±, ğ“Ÿ (Ici {x}) := by
  refine le_antisymm (le_iInf fun i => le_principal_iff.2 <| mem_atTop ({i} : Finset Î±)) ?_
  refine
    le_iInf fun s =>
      le_principal_iff.2 <| mem_iInf_of_iInter s.finite_toSet (fun i => mem_principal_self _) ?_
  simp only [subset_def, mem_iInter, SetCoe.forall, mem_Ici, Finset.le_iff_subset,
    Finset.mem_singleton, Finset.subset_iff, forall_eq]
  exact fun t => id

/-- If `f` is a monotone sequence of `Finset`s and each `x` belongs to one of `f n`, then
`Tendsto f atTop atTop`. -/
theorem tendsto_atTop_finset_of_monotone [Preorder Î²] {f : Î² â†’ Finset Î±} (h : Monotone f)
    (h' : âˆ€ x : Î±, âˆƒ n, x âˆˆ f n) : Tendsto f atTop atTop := by
  simp only [atTop_finset_eq_iInf, tendsto_iInf, tendsto_principal]
  intro a
  rcases h' a with âŸ¨b, hbâŸ©
  exact (eventually_ge_atTop b).mono fun b' hb' => (Finset.singleton_subset_iff.2 hb).trans (h hb')

alias _root_.Monotone.tendsto_atTop_finset := tendsto_atTop_finset_of_monotone

-- Porting note: add assumption `DecidableEq Î²` so that the lemma applies to any instance
theorem tendsto_finset_image_atTop_atTop [DecidableEq Î²] {i : Î² â†’ Î³} {j : Î³ â†’ Î²}
    (h : Function.LeftInverse j i) : Tendsto (Finset.image j) atTop atTop :=
  (Finset.image_mono j).tendsto_atTop_finset fun a =>
    âŸ¨{i a}, by simp only [Finset.image_singleton, h a, Finset.mem_singleton]âŸ©

theorem tendsto_finset_preimage_atTop_atTop {f : Î± â†’ Î²} (hf : Function.Injective f) :
    Tendsto (fun s : Finset Î² => s.preimage f (hf.injOn)) atTop atTop :=
  (Finset.monotone_preimage hf).tendsto_atTop_finset fun x =>
    âŸ¨{f x}, Finset.mem_preimage.2 <| Finset.mem_singleton_self _âŸ©

theorem prod_atTop_atTop_eq [Preorder Î±] [Preorder Î²] :
    (atTop : Filter Î±) Ã—Ë¢ (atTop : Filter Î²) = (atTop : Filter (Î± Ã— Î²)) := by
  cases isEmpty_or_nonempty Î±
  Â· subsingleton
  cases isEmpty_or_nonempty Î²
  Â· subsingleton
  simpa [atTop, prod_iInf_left, prod_iInf_right, iInf_prod] using iInf_comm

instance instIsCountablyGeneratedAtTopProd [Preorder Î±] [IsCountablyGenerated (atTop : Filter Î±)]
    [Preorder Î²] [IsCountablyGenerated (atTop : Filter Î²)] :
    IsCountablyGenerated (atTop : Filter (Î± Ã— Î²)) := by
  rw [â† prod_atTop_atTop_eq]
  infer_instance

lemma tendsto_finset_prod_atTop :
    Tendsto (fun (p : Finset Î¹ Ã— Finset Î¹') â†¦ p.1 Ã—Ë¢ p.2) atTop atTop := by
  classical
  apply Monotone.tendsto_atTop_atTop
  Â· intro p q hpq
    simpa using Finset.product_subset_product hpq.1 hpq.2
  Â· intro b
    use (Finset.image Prod.fst b, Finset.image Prod.snd b)
    exact Finset.subset_product

theorem prod_atBot_atBot_eq [Preorder Î±] [Preorder Î²] :
    (atBot : Filter Î±) Ã—Ë¢ (atBot : Filter Î²) = (atBot : Filter (Î± Ã— Î²)) :=
  @prod_atTop_atTop_eq Î±áµ’áµˆ Î²áµ’áµˆ _ _

instance instIsCountablyGeneratedAtBotProd [Preorder Î±] [IsCountablyGenerated (atBot : Filter Î±)]
    [Preorder Î²] [IsCountablyGenerated (atBot : Filter Î²)] :
    IsCountablyGenerated (atBot : Filter (Î± Ã— Î²)) := by
  rw [â† prod_atBot_atBot_eq]
  infer_instance

theorem prod_map_atTop_eq {Î±â‚ Î±â‚‚ Î²â‚ Î²â‚‚ : Type*} [Preorder Î²â‚] [Preorder Î²â‚‚]
    (uâ‚ : Î²â‚ â†’ Î±â‚) (uâ‚‚ : Î²â‚‚ â†’ Î±â‚‚) : map uâ‚ atTop Ã—Ë¢ map uâ‚‚ atTop = map (Prod.map uâ‚ uâ‚‚) atTop := by
  rw [prod_map_map_eq, prod_atTop_atTop_eq, Prod.map_def]

theorem prod_map_atBot_eq {Î±â‚ Î±â‚‚ Î²â‚ Î²â‚‚ : Type*} [Preorder Î²â‚] [Preorder Î²â‚‚]
    (uâ‚ : Î²â‚ â†’ Î±â‚) (uâ‚‚ : Î²â‚‚ â†’ Î±â‚‚) : map uâ‚ atBot Ã—Ë¢ map uâ‚‚ atBot = map (Prod.map uâ‚ uâ‚‚) atBot :=
  @prod_map_atTop_eq _ _ Î²â‚áµ’áµˆ Î²â‚‚áµ’áµˆ _ _ _ _

theorem Tendsto.subseq_mem {F : Filter Î±} {V : â„• â†’ Set Î±} (h : âˆ€ n, V n âˆˆ F) {u : â„• â†’ Î±}
    (hu : Tendsto u atTop F) : âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ n, u (Ï† n) âˆˆ V n :=
  extraction_forall_of_eventually'
    (fun n => tendsto_atTop'.mp hu _ (h n) : âˆ€ n, âˆƒ N, âˆ€ k â‰¥ N, u k âˆˆ V n)

theorem tendsto_atBot_diagonal [Preorder Î±] : Tendsto (fun a : Î± => (a, a)) atBot atBot := by
  rw [â† prod_atBot_atBot_eq]
  exact tendsto_id.prod_mk tendsto_id

theorem tendsto_atTop_diagonal [Preorder Î±] : Tendsto (fun a : Î± => (a, a)) atTop atTop := by
  rw [â† prod_atTop_atTop_eq]
  exact tendsto_id.prod_mk tendsto_id

theorem Tendsto.prod_map_prod_atBot [Preorder Î³] {F : Filter Î±} {G : Filter Î²} {f : Î± â†’ Î³}
    {g : Î² â†’ Î³} (hf : Tendsto f F atBot) (hg : Tendsto g G atBot) :
    Tendsto (Prod.map f g) (F Ã—Ë¢ G) atBot := by
  rw [â† prod_atBot_atBot_eq]
  exact hf.prod_map hg

theorem Tendsto.prod_map_prod_atTop [Preorder Î³] {F : Filter Î±} {G : Filter Î²} {f : Î± â†’ Î³}
    {g : Î² â†’ Î³} (hf : Tendsto f F atTop) (hg : Tendsto g G atTop) :
    Tendsto (Prod.map f g) (F Ã—Ë¢ G) atTop := by
  rw [â† prod_atTop_atTop_eq]
  exact hf.prod_map hg

theorem Tendsto.prod_atBot [Preorder Î±] [Preorder Î³] {f g : Î± â†’ Î³}
    (hf : Tendsto f atBot atBot) (hg : Tendsto g atBot atBot) :
    Tendsto (Prod.map f g) atBot atBot := by
  rw [â† prod_atBot_atBot_eq]
  exact hf.prod_map_prod_atBot hg

theorem Tendsto.prod_atTop [Preorder Î±] [Preorder Î³] {f g : Î± â†’ Î³}
    (hf : Tendsto f atTop atTop) (hg : Tendsto g atTop atTop) :
    Tendsto (Prod.map f g) atTop atTop := by
  rw [â† prod_atTop_atTop_eq]
  exact hf.prod_map_prod_atTop hg

theorem eventually_atBot_prod_self [Nonempty Î±] [Preorder Î±] [IsDirected Î± (Â· â‰¥ Â·)]
    {p : Î± Ã— Î± â†’ Prop} : (âˆ€á¶  x in atBot, p x) â†” âˆƒ a, âˆ€ k l, k â‰¤ a â†’ l â‰¤ a â†’ p (k, l) := by
  simp [â† prod_atBot_atBot_eq, (@atBot_basis Î± _ _).prod_self.eventually_iff]

theorem eventually_atTop_prod_self [Nonempty Î±] [Preorder Î±] [IsDirected Î± (Â· â‰¤ Â·)]
    {p : Î± Ã— Î± â†’ Prop} : (âˆ€á¶  x in atTop, p x) â†” âˆƒ a, âˆ€ k l, a â‰¤ k â†’ a â‰¤ l â†’ p (k, l) :=
  eventually_atBot_prod_self (Î± := Î±áµ’áµˆ)

theorem eventually_atBot_prod_self'  [Nonempty Î±] [Preorder Î±] [IsDirected Î± (Â· â‰¥ Â·)]
    {p : Î± Ã— Î± â†’ Prop} : (âˆ€á¶  x in atBot, p x) â†” âˆƒ a, âˆ€ k â‰¤ a, âˆ€ l â‰¤ a, p (k, l) := by
  simp only [eventually_atBot_prod_self, forall_cond_comm]

theorem eventually_atTop_prod_self' [Nonempty Î±] [Preorder Î±] [IsDirected Î± (Â· â‰¤ Â·)]
    {p : Î± Ã— Î± â†’ Prop} : (âˆ€á¶  x in atTop, p x) â†” âˆƒ a, âˆ€ k â‰¥ a, âˆ€ l â‰¥ a, p (k, l) := by
  simp only [eventually_atTop_prod_self, forall_cond_comm]

theorem eventually_atTop_curry [Preorder Î±] [Preorder Î²] {p : Î± Ã— Î² â†’ Prop}
    (hp : âˆ€á¶  x : Î± Ã— Î² in Filter.atTop, p x) : âˆ€á¶  k in atTop, âˆ€á¶  l in atTop, p (k, l) := by
  rw [â† prod_atTop_atTop_eq] at hp
  exact hp.curry

theorem eventually_atBot_curry [Preorder Î±] [Preorder Î²] {p : Î± Ã— Î² â†’ Prop}
    (hp : âˆ€á¶  x : Î± Ã— Î² in Filter.atBot, p x) : âˆ€á¶  k in atBot, âˆ€á¶  l in atBot, p (k, l) :=
  @eventually_atTop_curry Î±áµ’áµˆ Î²áµ’áµˆ _ _ _ hp

/-- A function `f` maps upwards closed sets (atTop sets) to upwards closed sets when it is a
Galois insertion. The Galois "insertion" and "connection" is weakened to only require it to be an
insertion and a connection above `b`. -/
theorem map_atTop_eq_of_gc_preorder
    [Preorder Î±] [IsDirected Î± (Â· â‰¤ Â·)] [Preorder Î²] [IsDirected Î² (Â· â‰¤ Â·)] {f : Î± â†’ Î²}
    (hf : Monotone f) (b : Î²)
    (hgi : âˆ€ c â‰¥ b, âˆƒ x, f x = c âˆ§ âˆ€ a, f a â‰¤ c â†” a â‰¤ x) : map f atTop = atTop := by
  have : Nonempty Î± := (hgi b le_rfl).nonempty
  choose! g hfg hgle using hgi
  refine le_antisymm (hf.tendsto_atTop_atTop fun c â†¦ ?_) ?_
  Â· rcases exists_ge_ge c b with âŸ¨d, hcd, hbdâŸ©
    exact âŸ¨g d, hcd.trans (hfg d hbd).geâŸ©
  Â· have : Nonempty Î± := âŸ¨g bâŸ©
    rw [(atTop_basis.map f).ge_iff]
    intro a _
    filter_upwards [eventually_ge_atTop (f a), eventually_ge_atTop b] with c hac hbc
    exact âŸ¨g c, (hgle _ hbc _).1 hac, hfg _ hbcâŸ©


/-- A function `f` maps upwards closed sets (atTop sets) to upwards closed sets when it is a
Galois insertion. The Galois "insertion" and "connection" is weakened to only require it to be an
insertion and a connection above `b`. -/
theorem map_atTop_eq_of_gc
    [Preorder Î±] [IsDirected Î± (Â· â‰¤ Â·)] [PartialOrder Î²] [IsDirected Î² (Â· â‰¤ Â·)]
    {f : Î± â†’ Î²} (g : Î² â†’ Î±) (b : Î²) (hf : Monotone f)
    (gc : âˆ€ a, âˆ€ c â‰¥ b, f a â‰¤ c â†” a â‰¤ g c) (hgi : âˆ€ c â‰¥ b, c â‰¤ f (g c)) :
    map f atTop = atTop :=
  map_atTop_eq_of_gc_preorder hf b fun c hc â†¦
    âŸ¨g c, le_antisymm ((gc _ _ hc).2 le_rfl) (hgi c hc), (gc Â· c hc)âŸ©

theorem map_atBot_eq_of_gc_preorder
    [Preorder Î±] [IsDirected Î± (Â· â‰¥ Â·)] [Preorder Î²] [IsDirected Î² (Â· â‰¥ Â·)] {f : Î± â†’ Î²}
    (hf : Monotone f) (b : Î²)
    (hgi : âˆ€ c â‰¤ b, âˆƒ x, f x = c âˆ§ âˆ€ a, c â‰¤ f a â†” x â‰¤ a) : map f atBot = atBot :=
  map_atTop_eq_of_gc_preorder (Î± := Î±áµ’áµˆ) (Î² := Î²áµ’áµˆ) hf.dual _ hgi

theorem map_atBot_eq_of_gc [Preorder Î±] [IsDirected Î± (Â· â‰¥ Â·)]
    [PartialOrder Î²] [IsDirected Î² (Â· â‰¥ Â·)] {f : Î± â†’ Î²} (g : Î² â†’ Î±) (b' : Î²)
    (hf : Monotone f) (gc : âˆ€ a, âˆ€ b â‰¤ b', b â‰¤ f a â†” g b â‰¤ a) (hgi : âˆ€ b â‰¤ b', f (g b) â‰¤ b) :
    map f atBot = atBot :=
  map_atTop_eq_of_gc (Î± := Î±áµ’áµˆ) (Î² := Î²áµ’áµˆ) _ _ hf.dual gc hgi

theorem map_val_atTop_of_Ici_subset [Preorder Î±] [IsDirected Î± (Â· â‰¤ Â·)] {a : Î±} {s : Set Î±}
    (h : Ici a âŠ† s) : map ((â†‘) : s â†’ Î±) atTop = atTop := by
  choose f hl hr using exists_ge_ge (Î± := Î±)
  have : DirectedOn (Â· â‰¤ Â·) s := fun x _ y _ â†¦
    âŸ¨f a (f x y), h <| hl _ _, (hl x y).trans (hr _ _), (hr x y).trans (hr _ _)âŸ©
  have : IsDirected s (Â· â‰¤ Â·) := by
    rw [directedOn_iff_directed] at this
    rwa [â† directed_id_iff]
  refine map_atTop_eq_of_gc_preorder (Subtype.mono_coe _) a fun c hc â†¦ ?_
  exact âŸ¨âŸ¨c, h hcâŸ©, rfl, fun _ â†¦ .rflâŸ©

@[simp]
theorem _root_.Nat.map_cast_int_atTop : map ((â†‘) : â„• â†’ â„¤) atTop = atTop := by
  refine map_atTop_eq_of_gc_preorder (fun _ _ â†¦ Int.ofNat_le.2) 0 fun n hn â†¦ ?_
  lift n to â„• using hn
  exact âŸ¨n, rfl, fun _ â†¦ Int.ofNat_leâŸ©

/-- The image of the filter `atTop` on `Ici a` under the coercion equals `atTop`. -/
@[simp]
theorem map_val_Ici_atTop [Preorder Î±] [IsDirected Î± (Â· â‰¤ Â·)] (a : Î±) :
    map ((â†‘) : Ici a â†’ Î±) atTop = atTop :=
  map_val_atTop_of_Ici_subset Subset.rfl

/-- The image of the filter `atTop` on `Ioi a` under the coercion equals `atTop`. -/
@[simp]
theorem map_val_Ioi_atTop [Preorder Î±] [IsDirected Î± (Â· â‰¤ Â·)] [NoMaxOrder Î±] (a : Î±) :
    map ((â†‘) : Ioi a â†’ Î±) atTop = atTop :=
  let âŸ¨_b, hbâŸ© := exists_gt a
  map_val_atTop_of_Ici_subset <| Ici_subset_Ioi.2 hb

/-- The `atTop` filter for an open interval `Ioi a` comes from the `atTop` filter in the ambient
order. -/
theorem atTop_Ioi_eq [Preorder Î±] [IsDirected Î± (Â· â‰¤ Â·)] (a : Î±) :
    atTop = comap ((â†‘) : Ioi a â†’ Î±) atTop := by
  rcases isEmpty_or_nonempty (Ioi a) with h|âŸ¨âŸ¨b, hbâŸ©âŸ©
  Â· subsingleton
  Â· rw [â† map_val_atTop_of_Ici_subset (Ici_subset_Ioi.2 hb), comap_map Subtype.coe_injective]

/-- The `atTop` filter for an open interval `Ici a` comes from the `atTop` filter in the ambient
order. -/
theorem atTop_Ici_eq [Preorder Î±] [IsDirected Î± (Â· â‰¤ Â·)] (a : Î±) :
    atTop = comap ((â†‘) : Ici a â†’ Î±) atTop := by
  rw [â† map_val_Ici_atTop a, comap_map Subtype.coe_injective]

/-- The `atBot` filter for an open interval `Iio a` comes from the `atBot` filter in the ambient
order. -/
@[simp]
theorem map_val_Iio_atBot [Preorder Î±] [IsDirected Î± (Â· â‰¥ Â·)] [NoMinOrder Î±] (a : Î±) :
    map ((â†‘) : Iio a â†’ Î±) atBot = atBot :=
  map_val_Ioi_atTop (OrderDual.toDual a)

/-- The `atBot` filter for an open interval `Iio a` comes from the `atBot` filter in the ambient
order. -/
theorem atBot_Iio_eq [Preorder Î±] [IsDirected Î± (Â· â‰¥ Â·)] (a : Î±) :
    atBot = comap ((â†‘) : Iio a â†’ Î±) atBot :=
  atTop_Ioi_eq (OrderDual.toDual a)

/-- The `atBot` filter for an open interval `Iic a` comes from the `atBot` filter in the ambient
order. -/
@[simp]
theorem map_val_Iic_atBot [Preorder Î±] [IsDirected Î± (Â· â‰¥ Â·)] (a : Î±) :
    map ((â†‘) : Iic a â†’ Î±) atBot = atBot :=
  map_val_Ici_atTop (OrderDual.toDual a)

/-- The `atBot` filter for an open interval `Iic a` comes from the `atBot` filter in the ambient
order. -/
theorem atBot_Iic_eq [Preorder Î±] [IsDirected Î± (Â· â‰¥ Â·)] (a : Î±) :
    atBot = comap ((â†‘) : Iic a â†’ Î±) atBot :=
  atTop_Ici_eq (OrderDual.toDual a)

theorem tendsto_Ioi_atTop [Preorder Î±] [IsDirected Î± (Â· â‰¤ Â·)]
    {a : Î±} {f : Î² â†’ Ioi a} {l : Filter Î²} :
    Tendsto f l atTop â†” Tendsto (fun x => (f x : Î±)) l atTop := by
  rw [atTop_Ioi_eq, tendsto_comap_iff, Function.comp_def]

theorem tendsto_Iio_atBot [Preorder Î±] [IsDirected Î± (Â· â‰¥ Â·)]
    {a : Î±} {f : Î² â†’ Iio a} {l : Filter Î²} :
    Tendsto f l atBot â†” Tendsto (fun x => (f x : Î±)) l atBot :=
  tendsto_Ioi_atTop (Î± := Î±áµ’áµˆ)

theorem tendsto_Ici_atTop [Preorder Î±] [IsDirected Î± (Â· â‰¤ Â·)]
    {a : Î±} {f : Î² â†’ Ici a} {l : Filter Î²} :
    Tendsto f l atTop â†” Tendsto (fun x => (f x : Î±)) l atTop := by
  rw [atTop_Ici_eq, tendsto_comap_iff, Function.comp_def]

theorem tendsto_Iic_atBot [Preorder Î±] [IsDirected Î± (Â· â‰¥ Â·)]
    {a : Î±} {f : Î² â†’ Iic a} {l : Filter Î²} :
    Tendsto f l atBot â†” Tendsto (fun x => (f x : Î±)) l atBot :=
  tendsto_Ici_atTop (Î± := Î±áµ’áµˆ)

@[simp]
theorem tendsto_comp_val_Ioi_atTop [Preorder Î±] [IsDirected Î± (Â· â‰¤ Â·)] [NoMaxOrder Î±]
    {a : Î±} {f : Î± â†’ Î²} {l : Filter Î²} :
    Tendsto (fun x : Ioi a => f x) atTop l â†” Tendsto f atTop l := by
  rw [â† map_val_Ioi_atTop a, tendsto_map'_iff, Function.comp_def]

@[simp]
theorem tendsto_comp_val_Ici_atTop [Preorder Î±] [IsDirected Î± (Â· â‰¤ Â·)]
    {a : Î±} {f : Î± â†’ Î²} {l : Filter Î²} :
    Tendsto (fun x : Ici a => f x) atTop l â†” Tendsto f atTop l := by
  rw [â† map_val_Ici_atTop a, tendsto_map'_iff, Function.comp_def]

@[simp]
theorem tendsto_comp_val_Iio_atBot [Preorder Î±] [IsDirected Î± (Â· â‰¥ Â·)] [NoMinOrder Î±]
    {a : Î±} {f : Î± â†’ Î²} {l : Filter Î²} :
    Tendsto (fun x : Iio a => f x) atBot l â†” Tendsto f atBot l :=
  tendsto_comp_val_Ioi_atTop (Î± := Î±áµ’áµˆ)

@[simp]
theorem tendsto_comp_val_Iic_atBot [Preorder Î±] [IsDirected Î± (Â· â‰¥ Â·)]
    {a : Î±} {f : Î± â†’ Î²} {l : Filter Î²} :
    Tendsto (fun x : Iic a => f x) atBot l â†” Tendsto f atBot l :=
  tendsto_comp_val_Ici_atTop (Î± := Î±áµ’áµˆ)

theorem map_add_atTop_eq_nat (k : â„•) : map (fun a => a + k) atTop = atTop :=
  map_atTop_eq_of_gc (Â· - k) k (fun _ _ h => Nat.add_le_add_right h k)
    (fun _ _ h => (Nat.le_sub_iff_add_le h).symm) fun a h => by rw [Nat.sub_add_cancel h]

theorem map_sub_atTop_eq_nat (k : â„•) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (Â· + k) 0 (fun _ _ h => Nat.sub_le_sub_right h _)
    (fun _ _ _ => Nat.sub_le_iff_le_add) fun b _ => by rw [Nat.add_sub_cancel_right]

theorem tendsto_add_atTop_nat (k : â„•) : Tendsto (fun a => a + k) atTop atTop :=
  le_of_eq (map_add_atTop_eq_nat k)

theorem tendsto_sub_atTop_nat (k : â„•) : Tendsto (fun a => a - k) atTop atTop :=
  le_of_eq (map_sub_atTop_eq_nat k)

theorem tendsto_add_atTop_iff_nat {f : â„• â†’ Î±} {l : Filter Î±} (k : â„•) :
    Tendsto (fun n => f (n + k)) atTop l â†” Tendsto f atTop l :=
  show Tendsto (f âˆ˜ fun n => n + k) atTop l â†” Tendsto f atTop l by
    rw [â† tendsto_map'_iff, map_add_atTop_eq_nat]

theorem map_div_atTop_eq_nat (k : â„•) (hk : 0 < k) : map (fun a => a / k) atTop = atTop :=
  map_atTop_eq_of_gc (fun b => k * b + (k - 1)) 1 (fun _ _ h => Nat.div_le_div_right h)
    -- Porting note: there was a parse error in `calc`, use `simp` instead
    (fun a b _ => by rw [Nat.div_le_iff_le_mul_add_pred hk])
    fun b _ => by rw [Nat.mul_add_div hk, Nat.div_eq_of_lt, add_zero]; omega

/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded
above, then `Tendsto u atTop atTop`. -/
theorem tendsto_atTop_atTop_of_monotone' [Preorder Î¹] [LinearOrder Î±] {u : Î¹ â†’ Î±} (h : Monotone u)
    (H : Â¬BddAbove (range u)) : Tendsto u atTop atTop := by
  apply h.tendsto_atTop_atTop
  intro b
  rcases not_bddAbove_iff.1 H b with âŸ¨_, âŸ¨N, rflâŸ©, hNâŸ©
  exact âŸ¨N, le_of_lt hNâŸ©

/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded
below, then `Tendsto u atBot atBot`. -/
theorem tendsto_atBot_atBot_of_monotone' [Preorder Î¹] [LinearOrder Î±] {u : Î¹ â†’ Î±} (h : Monotone u)
    (H : Â¬BddBelow (range u)) : Tendsto u atBot atBot :=
  @tendsto_atTop_atTop_of_monotone' Î¹áµ’áµˆ Î±áµ’áµˆ _ _ _ h.dual H

section IsDirected
variable [Nonempty Î±] [Preorder Î±] [IsDirected Î± (Â· â‰¤ Â·)] [Preorder Î²] {f : Î± â†’ Î²}

theorem unbounded_of_tendsto_atTop [NoMaxOrder Î²] (h : Tendsto f atTop atTop) :
    Â¬BddAbove (range f) := by
  rintro âŸ¨M, hMâŸ©
  cases' mem_atTop_sets.mp (h <| Ioi_mem_atTop M) with a ha
  apply lt_irrefl M
  calc
    M < f a := ha a le_rfl
    _ â‰¤ M := hM (Set.mem_range_self a)

theorem unbounded_of_tendsto_atBot [NoMinOrder Î²] (h : Tendsto f atTop atBot) :
    Â¬BddBelow (range f) := unbounded_of_tendsto_atTop (Î² := Î²áµ’áµˆ) h

end IsDirected

section IsCodirected
variable [Nonempty Î±] [Preorder Î±] [IsDirected Î± (Â· â‰¥ Â·)] [Preorder Î²] {f : Î± â†’ Î²}

theorem unbounded_of_tendsto_atTop' [NoMaxOrder Î²] (h : Tendsto f atBot atTop) :
    Â¬BddAbove (range f) := unbounded_of_tendsto_atTop (Î± := Î±áµ’áµˆ) h

theorem unbounded_of_tendsto_atBot' [NoMinOrder Î²] (h : Tendsto f atBot atBot) :
    Â¬BddBelow (range f) := unbounded_of_tendsto_atTop (Î± := Î±áµ’áµˆ) (Î² := Î²áµ’áµˆ) h

end IsCodirected

/-- If a monotone function `u : Î¹ â†’ Î±` tends to `atTop` along *some* non-trivial filter `l`, then
it tends to `atTop` along `atTop`. -/
theorem tendsto_atTop_of_monotone_of_filter [Preorder Î¹] [Preorder Î±] {l : Filter Î¹} {u : Î¹ â†’ Î±}
    (h : Monotone u) [NeBot l] (hu : Tendsto u l atTop) : Tendsto u atTop atTop :=
  h.tendsto_atTop_atTop fun b => (hu.eventually (mem_atTop b)).exists

/-- If a monotone function `u : Î¹ â†’ Î±` tends to `atBot` along *some* non-trivial filter `l`, then
it tends to `atBot` along `atBot`. -/
theorem tendsto_atBot_of_monotone_of_filter [Preorder Î¹] [Preorder Î±] {l : Filter Î¹} {u : Î¹ â†’ Î±}
    (h : Monotone u) [NeBot l] (hu : Tendsto u l atBot) : Tendsto u atBot atBot :=
  @tendsto_atTop_of_monotone_of_filter Î¹áµ’áµˆ Î±áµ’áµˆ _ _ _ _ h.dual _ hu

theorem tendsto_atTop_of_monotone_of_subseq [Preorder Î¹] [Preorder Î±] {u : Î¹ â†’ Î±} {Ï† : Î¹' â†’ Î¹}
    (h : Monotone u) {l : Filter Î¹'} [NeBot l] (H : Tendsto (u âˆ˜ Ï†) l atTop) :
    Tendsto u atTop atTop :=
  tendsto_atTop_of_monotone_of_filter h (tendsto_map' H)

theorem tendsto_atBot_of_monotone_of_subseq [Preorder Î¹] [Preorder Î±] {u : Î¹ â†’ Î±} {Ï† : Î¹' â†’ Î¹}
    (h : Monotone u) {l : Filter Î¹'} [NeBot l] (H : Tendsto (u âˆ˜ Ï†) l atBot) :
    Tendsto u atBot atBot :=
  tendsto_atBot_of_monotone_of_filter h (tendsto_map' H)

theorem HasAntitoneBasis.eventually_subset [Preorder Î¹] {l : Filter Î±} {s : Î¹ â†’ Set Î±}
    (hl : l.HasAntitoneBasis s) {t : Set Î±} (ht : t âˆˆ l) : âˆ€á¶  i in atTop, s i âŠ† t :=
  let âŸ¨i, _, hiâŸ© := hl.1.mem_iff.1 ht
  (eventually_ge_atTop i).mono fun _j hj => (hl.antitone hj).trans hi

protected theorem HasAntitoneBasis.tendsto [Preorder Î¹] {l : Filter Î±} {s : Î¹ â†’ Set Î±}
    (hl : l.HasAntitoneBasis s) {Ï† : Î¹ â†’ Î±} (h : âˆ€ i : Î¹, Ï† i âˆˆ s i) : Tendsto Ï† atTop l :=
  fun _t ht => mem_map.2 <| (hl.eventually_subset ht).mono fun i hi => hi (h i)

theorem HasAntitoneBasis.comp_mono [Nonempty Î¹] [Preorder Î¹] [IsDirected Î¹ (Â· â‰¤ Â·)] [Preorder Î¹']
    {l : Filter Î±}
    {s : Î¹' â†’ Set Î±} (hs : l.HasAntitoneBasis s) {Ï† : Î¹ â†’ Î¹'} (Ï†_mono : Monotone Ï†)
    (hÏ† : Tendsto Ï† atTop atTop) : l.HasAntitoneBasis (s âˆ˜ Ï†) :=
  âŸ¨hs.1.to_hasBasis
      (fun n _ => (hÏ†.eventually_ge_atTop n).exists.imp fun _m hm => âŸ¨trivial, hs.antitone hmâŸ©)
      fun n _ => âŸ¨Ï† n, trivial, Subset.rflâŸ©,
    hs.antitone.comp_monotone Ï†_monoâŸ©

theorem HasAntitoneBasis.comp_strictMono {l : Filter Î±} {s : â„• â†’ Set Î±} (hs : l.HasAntitoneBasis s)
    {Ï† : â„• â†’ â„•} (hÏ† : StrictMono Ï†) : l.HasAntitoneBasis (s âˆ˜ Ï†) :=
  hs.comp_mono hÏ†.monotone hÏ†.tendsto_atTop

/-- Given an antitone basis `s : â„• â†’ Set Î±` of a filter, extract an antitone subbasis `s âˆ˜ Ï†`,
`Ï† : â„• â†’ â„•`, such that `m < n` implies `r (Ï† m) (Ï† n)`. This lemma can be used to extract an
antitone basis with basis sets decreasing "sufficiently fast". -/
theorem HasAntitoneBasis.subbasis_with_rel {f : Filter Î±} {s : â„• â†’ Set Î±}
    (hs : f.HasAntitoneBasis s) {r : â„• â†’ â„• â†’ Prop} (hr : âˆ€ m, âˆ€á¶  n in atTop, r m n) :
    âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ (âˆ€ â¦ƒm nâ¦„, m < n â†’ r (Ï† m) (Ï† n)) âˆ§ f.HasAntitoneBasis (s âˆ˜ Ï†) := by
  rsuffices âŸ¨Ï†, hÏ†, hrÏ†âŸ© : âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ âˆ€ m n, m < n â†’ r (Ï† m) (Ï† n)
  Â· exact âŸ¨Ï†, hÏ†, hrÏ†, hs.comp_strictMono hÏ†âŸ©
  have : âˆ€ t : Set â„•, t.Finite â†’ âˆ€á¶  n in atTop, âˆ€ m âˆˆ t, m < n âˆ§ r m n := fun t ht =>
    (eventually_all_finite ht).2 fun m _ => (eventually_gt_atTop m).and (hr _)
  rcases seq_of_forall_finite_exists fun t ht => (this t ht).exists with âŸ¨Ï†, hÏ†âŸ©
  simp only [forall_mem_image, forall_and, mem_Iio] at hÏ†
  exact âŸ¨Ï†, forall_swap.2 hÏ†.1, forall_swap.2 hÏ†.2âŸ©

/-- If `f` is a nontrivial countably generated filter, then there exists a sequence that converges
to `f`. -/
theorem exists_seq_tendsto (f : Filter Î±) [IsCountablyGenerated f] [NeBot f] :
    âˆƒ x : â„• â†’ Î±, Tendsto x atTop f := by
  obtain âŸ¨B, hâŸ© := f.exists_antitone_basis
  choose x hx using fun n => Filter.nonempty_of_mem (h.mem n)
  exact âŸ¨x, h.tendsto hxâŸ©

theorem exists_seq_monotone_tendsto_atTop_atTop (Î± : Type*) [Preorder Î±] [Nonempty Î±]
    [IsDirected Î± (Â· â‰¤ Â·)] [(atTop : Filter Î±).IsCountablyGenerated] :
    âˆƒ xs : â„• â†’ Î±, Monotone xs âˆ§ Tendsto xs atTop atTop := by
  obtain âŸ¨ys, hâŸ© := exists_seq_tendsto (atTop : Filter Î±)
  choose c hleft hright using exists_ge_ge (Î± := Î±)
  set xs : â„• â†’ Î± := fun n => (List.range n).foldl (fun x n â†¦ c x (ys n)) (ys 0)
  have hsucc (n : â„•) : xs (n + 1) = c (xs n) (ys n) := by simp [xs, List.range_succ]
  refine âŸ¨xs, ?_, ?_âŸ©
  Â· refine monotone_nat_of_le_succ fun n â†¦ ?_
    rw [hsucc]
    apply hleft
  Â· refine (tendsto_add_atTop_iff_nat 1).1 <| tendsto_atTop_mono (fun n â†¦ ?_) h
    rw [hsucc]
    apply hright

theorem exists_seq_antitone_tendsto_atTop_atBot (Î± : Type*) [Preorder Î±] [Nonempty Î±]
    [IsDirected Î± (Â· â‰¥ Â·)] [(atBot : Filter Î±).IsCountablyGenerated] :
    âˆƒ xs : â„• â†’ Î±, Antitone xs âˆ§ Tendsto xs atTop atBot :=
  exists_seq_monotone_tendsto_atTop_atTop Î±áµ’áµˆ

/-- An abstract version of continuity of sequentially continuous functions on metric spaces:
if a filter `k` is countably generated then `Tendsto f k l` iff for every sequence `u`
converging to `k`, `f âˆ˜ u` tends to `l`. -/
theorem tendsto_iff_seq_tendsto {f : Î± â†’ Î²} {k : Filter Î±} {l : Filter Î²} [k.IsCountablyGenerated] :
    Tendsto f k l â†” âˆ€ x : â„• â†’ Î±, Tendsto x atTop k â†’ Tendsto (f âˆ˜ x) atTop l := by
  refine âŸ¨fun h x hx => h.comp hx, fun H s hs => ?_âŸ©
  contrapose! H
  have : NeBot (k âŠ“ ğ“Ÿ (f â»Â¹' sá¶œ)) := by simpa [neBot_iff, inf_principal_eq_bot]
  rcases (k âŠ“ ğ“Ÿ (f â»Â¹' sá¶œ)).exists_seq_tendsto with âŸ¨x, hxâŸ©
  rw [tendsto_inf, tendsto_principal] at hx
  refine âŸ¨x, hx.1, fun h => ?_âŸ©
  rcases (hx.2.and (h hs)).exists with âŸ¨N, hnmem, hmemâŸ©
  exact hnmem hmem

theorem tendsto_of_seq_tendsto {f : Î± â†’ Î²} {k : Filter Î±} {l : Filter Î²} [k.IsCountablyGenerated] :
    (âˆ€ x : â„• â†’ Î±, Tendsto x atTop k â†’ Tendsto (f âˆ˜ x) atTop l) â†’ Tendsto f k l :=
  tendsto_iff_seq_tendsto.2

theorem eventually_iff_seq_eventually {Î¹ : Type*} {l : Filter Î¹} {p : Î¹ â†’ Prop}
    [l.IsCountablyGenerated] :
    (âˆ€á¶  n in l, p n) â†” âˆ€ x : â„• â†’ Î¹, Tendsto x atTop l â†’ âˆ€á¶  n : â„• in atTop, p (x n) := by
  simpa using tendsto_iff_seq_tendsto (f := id) (l := ğ“Ÿ {x | p x})

theorem frequently_iff_seq_frequently {Î¹ : Type*} {l : Filter Î¹} {p : Î¹ â†’ Prop}
    [l.IsCountablyGenerated] :
    (âˆƒá¶  n in l, p n) â†” âˆƒ x : â„• â†’ Î¹, Tendsto x atTop l âˆ§ âˆƒá¶  n : â„• in atTop, p (x n) := by
  simp only [Filter.Frequently, eventually_iff_seq_eventually (l := l)]
  push_neg; rfl

theorem subseq_forall_of_frequently {Î¹ : Type*} {x : â„• â†’ Î¹} {p : Î¹ â†’ Prop} {l : Filter Î¹}
    (h_tendsto : Tendsto x atTop l) (h : âˆƒá¶  n in atTop, p (x n)) :
    âˆƒ ns : â„• â†’ â„•, Tendsto (fun n => x (ns n)) atTop l âˆ§ âˆ€ n, p (x (ns n)) := by
  choose ns hge hns using frequently_atTop.1 h
  exact âŸ¨ns, h_tendsto.comp (tendsto_atTop_mono hge tendsto_id), hnsâŸ©

theorem exists_seq_forall_of_frequently {Î¹ : Type*} {l : Filter Î¹} {p : Î¹ â†’ Prop}
    [l.IsCountablyGenerated] (h : âˆƒá¶  n in l, p n) :
    âˆƒ ns : â„• â†’ Î¹, Tendsto ns atTop l âˆ§ âˆ€ n, p (ns n) := by
  rw [frequently_iff_seq_frequently] at h
  obtain âŸ¨x, hx_tendsto, hx_freqâŸ© := h
  obtain âŸ¨n_to_n, h_tendsto, h_freqâŸ© := subseq_forall_of_frequently hx_tendsto hx_freq
  exact âŸ¨x âˆ˜ n_to_n, h_tendsto, h_freqâŸ©

lemma frequently_iff_seq_forall {Î¹ : Type*} {l : Filter Î¹} {p : Î¹ â†’ Prop}
    [l.IsCountablyGenerated] :
    (âˆƒá¶  n in l, p n) â†” âˆƒ ns : â„• â†’ Î¹, Tendsto ns atTop l âˆ§ âˆ€ n, p (ns n) :=
  âŸ¨exists_seq_forall_of_frequently, fun âŸ¨_ns, hnsl, hpnsâŸ© â†¦
    hnsl.frequently <| Frequently.of_forall hpnsâŸ©

/-- A sequence converges if every subsequence has a convergent subsequence. -/
theorem tendsto_of_subseq_tendsto {Î¹ : Type*} {x : Î¹ â†’ Î±} {f : Filter Î±} {l : Filter Î¹}
    [l.IsCountablyGenerated]
    (hxy : âˆ€ ns : â„• â†’ Î¹, Tendsto ns atTop l â†’
      âˆƒ ms : â„• â†’ â„•, Tendsto (fun n => x (ns <| ms n)) atTop f) :
    Tendsto x l f := by
  contrapose! hxy
  obtain âŸ¨s, hs, hfreqâŸ© : âˆƒ s âˆˆ f, âˆƒá¶  n in l, x n âˆ‰ s := by
    rwa [not_tendsto_iff_exists_frequently_nmem] at hxy
  obtain âŸ¨y, hy_tendsto, hy_freqâŸ© := exists_seq_forall_of_frequently hfreq
  refine âŸ¨y, hy_tendsto, fun ms hms_tendsto â†¦ ?_âŸ©
  rcases (hms_tendsto.eventually_mem hs).exists with âŸ¨n, hnâŸ©
  exact absurd hn <| hy_freq _

theorem subseq_tendsto_of_neBot {f : Filter Î±} [IsCountablyGenerated f] {u : â„• â†’ Î±}
    (hx : NeBot (f âŠ“ map u atTop)) : âˆƒ Î¸ : â„• â†’ â„•, StrictMono Î¸ âˆ§ Tendsto (u âˆ˜ Î¸) atTop f := by
  rw [â† Filter.push_pull', map_neBot_iff] at hx
  rcases exists_seq_tendsto (comap u f âŠ“ atTop) with âŸ¨Ï†, hÏ†âŸ©
  rw [tendsto_inf, tendsto_comap_iff] at hÏ†
  obtain âŸ¨Ïˆ, hÏˆ, hÏˆÏ†âŸ© : âˆƒ Ïˆ : â„• â†’ â„•, StrictMono Ïˆ âˆ§ StrictMono (Ï† âˆ˜ Ïˆ) :=
    strictMono_subseq_of_tendsto_atTop hÏ†.2
  exact âŸ¨Ï† âˆ˜ Ïˆ, hÏˆÏ†, hÏ†.1.comp hÏˆ.tendsto_atTopâŸ©

end Filter

open Filter Finset

theorem Monotone.piecewise_eventually_eq_iUnion {Î² : Î± â†’ Type*} [Preorder Î¹] {s : Î¹ â†’ Set Î±}
    [âˆ€ i, DecidablePred (Â· âˆˆ s i)] [DecidablePred (Â· âˆˆ â‹ƒ i, s i)]
    (hs : Monotone s) (f g : (a : Î±) â†’ Î² a) (a : Î±) :
    âˆ€á¶  i in atTop, (s i).piecewise f g a = (â‹ƒ i, s i).piecewise f g a := by
  rcases em (âˆƒ i, a âˆˆ s i) with âŸ¨i, hiâŸ© | ha
  Â· refine (eventually_ge_atTop i).mono fun j hij â†¦ ?_
    simp only [Set.piecewise_eq_of_mem, hs hij hi, subset_iUnion _ _ hi]
  Â· filter_upwards with i
    simp only [Set.piecewise_eq_of_not_mem, not_exists.1 ha i, mt mem_iUnion.1 ha,
      not_false_eq_true, exists_false]

theorem Antitone.piecewise_eventually_eq_iInter {Î² : Î± â†’ Type*} [Preorder Î¹] {s : Î¹ â†’ Set Î±}
    [âˆ€ i, DecidablePred (Â· âˆˆ s i)] [DecidablePred (Â· âˆˆ â‹‚ i, s i)]
    (hs : Antitone s) (f g : (a : Î±) â†’ Î² a) (a : Î±) :
    âˆ€á¶  i in atTop, (s i).piecewise f g a = (â‹‚ i, s i).piecewise f g a := by
  classical
  convert â† (compl_anti.comp hs).piecewise_eventually_eq_iUnion g f a using 3
  Â· convert congr_fun (Set.piecewise_compl (s _) g f) a
  Â· simp only [(Â· âˆ˜ Â·), â† compl_iInter, Set.piecewise_compl]

namespace Nat

theorem eventually_pow_lt_factorial_sub (c d : â„•) : âˆ€á¶  n in atTop, c ^ n < (n - d)! := by
  rw [eventually_atTop]
  refine âŸ¨2 * (c ^ 2 + d + 1), ?_âŸ©
  intro n hn
  obtain âŸ¨d', rflâŸ© := Nat.exists_eq_add_of_le hn
  obtain (rfl | c0) := c.eq_zero_or_pos
  Â· simp [Nat.two_mul, â† Nat.add_assoc, Nat.add_right_comm _ 1, Nat.factorial_pos]
  refine (Nat.le_mul_of_pos_right _ (Nat.pow_pos (n := d') c0)).trans_lt ?_
  convert_to (c ^ 2) ^ (c ^ 2 + d' + d + 1) < (c ^ 2 + (c ^ 2 + d' + d + 1) + 1)!
  Â· rw [â† pow_mul, â† pow_add]
    congr 1
    omega
  Â· congr 1
    omega
  refine (lt_of_lt_of_le ?_ Nat.factorial_mul_pow_le_factorial).trans_le <|
    (factorial_le (Nat.le_succ _))
  rw [â† one_mul (_ ^ _ : â„•)]
  apply Nat.mul_lt_mul_of_le_of_lt
  Â· exact Nat.one_le_of_lt (Nat.factorial_pos _)
  Â· exact Nat.pow_lt_pow_left (Nat.lt_succ_self _) (Nat.succ_ne_zero _)
  Â· exact (Nat.factorial_pos _)

theorem eventually_mul_pow_lt_factorial_sub (a c d : â„•) :
    âˆ€á¶  n in atTop, a * c ^ n < (n - d)! := by
  filter_upwards [Nat.eventually_pow_lt_factorial_sub (a * c) d, Filter.eventually_gt_atTop 0]
    with n hn hn0
  rw [mul_pow] at hn
  exact (Nat.mul_le_mul_right _ (Nat.le_self_pow hn0.ne' _)).trans_lt hn

@[deprecated eventually_pow_lt_factorial_sub (since := "2024-09-25")]
theorem exists_pow_lt_factorial (c : â„•) : âˆƒ n0 > 1, âˆ€ n â‰¥ n0, c ^ n < (n - 1)! :=
  let âŸ¨n0, hâŸ© := (eventually_pow_lt_factorial_sub c 1).exists_forall_of_atTop
  âŸ¨max n0 2, by omega, fun n hn â†¦ h n (by omega)âŸ©

@[deprecated eventually_mul_pow_lt_factorial_sub (since := "2024-09-25")]
theorem exists_mul_pow_lt_factorial (a : â„•) (c : â„•) : âˆƒ n0, âˆ€ n â‰¥ n0, a * c ^ n < (n - 1)! :=
  (eventually_mul_pow_lt_factorial_sub a c 1).exists_forall_of_atTop

end Nat
