/-
Copyright (c) 2020 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov, Johannes H√∂lzl, Mario Carneiro, Patrick Massot
-/
import Mathlib.Data.Prod.PProd
import Mathlib.Data.Set.Countable
import Mathlib.Order.Filter.Prod
import Mathlib.Order.Filter.Ker

/-!
# Filter bases

A filter basis `B : FilterBasis Œ±` on a type `Œ±` is a nonempty collection of sets of `Œ±`
such that the intersection of two elements of this collection contains some element of
the collection. Compared to filters, filter bases do not require that any set containing
an element of `B` belongs to `B`.
A filter basis `B` can be used to construct `B.filter : Filter Œ±` such that a set belongs
to `B.filter` if and only if it contains an element of `B`.

Given an indexing type `Œπ`, a predicate `p : Œπ ‚Üí Prop`, and a map `s : Œπ ‚Üí Set Œ±`,
the proposition `h : Filter.IsBasis p s` makes sure the range of `s` bounded by `p`
(ie. `s '' setOf p`) defines a filter basis `h.filterBasis`.

If one already has a filter `l` on `Œ±`, `Filter.HasBasis l p s` (where `p : Œπ ‚Üí Prop`
and `s : Œπ ‚Üí Set Œ±` as above) means that a set belongs to `l` if and
only if it contains some `s i` with `p i`. It implies `h : Filter.IsBasis p s`, and
`l = h.filterBasis.filter`. The point of this definition is that checking statements
involving elements of `l` often reduces to checking them on the basis elements.

We define a function `HasBasis.index (h : Filter.HasBasis l p s) (t) (ht : t ‚àà l)` that returns
some index `i` such that `p i` and `s i ‚äÜ t`. This function can be useful to avoid manual
destruction of `h.mem_iff.mpr ht` using `cases` or `let`.

This file also introduces more restricted classes of bases, involving monotonicity or
countability. In particular, for `l : Filter Œ±`, `l.IsCountablyGenerated` means
there is a countable set of sets which generates `s`. This is reformulated in term of bases,
and consequences are derived.

## Main statements

* `Filter.HasBasis.mem_iff`, `HasBasis.mem_of_superset`, `HasBasis.mem_of_mem` : restate `t ‚àà f` in
  terms of a basis;

* `Filter.basis_sets` : all sets of a filter form a basis;

* `Filter.HasBasis.inf`, `Filter.HasBasis.inf_principal`, `Filter.HasBasis.prod`,
  `Filter.HasBasis.prod_self`, `Filter.HasBasis.map`, `Filter.HasBasis.comap` : combinators to
  construct filters of `l ‚äì l'`, `l ‚äì ùìü t`, `l √óÀ¢ l'`, `l √óÀ¢ l`, `l.map f`, `l.comap f`
  respectively;

* `Filter.HasBasis.le_iff`, `Filter.HasBasis.ge_iff`, `Filter.HasBasis.le_basis_iff` : restate
  `l ‚â§ l'` in terms of bases.

* `Filter.HasBasis.tendsto_right_iff`, `Filter.HasBasis.tendsto_left_iff`,
  `Filter.HasBasis.tendsto_iff` : restate `Tendsto f l l'` in terms of bases.

* `isCountablyGenerated_iff_exists_antitone_basis` : proves a filter is countably generated if and
  only if it admits a basis parametrized by a decreasing sequence of sets indexed by `‚Ñï`.

* `tendsto_iff_seq_tendsto` : an abstract version of "sequentially continuous implies continuous".

## Implementation notes

As with `Set.iUnion`/`biUnion`/`Set.sUnion`, there are three different approaches to filter bases:

* `Filter.HasBasis l s`, `s : Set (Set Œ±)`;
* `Filter.HasBasis l s`, `s : Œπ ‚Üí Set Œ±`;
* `Filter.HasBasis l p s`, `p : Œπ ‚Üí Prop`, `s : Œπ ‚Üí Set Œ±`.

We use the latter one because, e.g., `ùìù x` in an `EMetricSpace` or in a `MetricSpace` has a basis
of this form. The other two can be emulated using `s = id` or `p = fun _ ‚Ü¶ True`.

With this approach sometimes one needs to `simp` the statement provided by the `Filter.HasBasis`
machinery, e.g., `simp only [true_and_iff]` or `simp only [forall_const]` can help with the case
`p = fun _ ‚Ü¶ True`.
-/

open Set Filter

section sort

variable {Œ± Œ≤ Œ≥ : Type*} {Œπ Œπ' : Sort*}

/-- A filter basis `B` on a type `Œ±` is a nonempty collection of sets of `Œ±`
such that the intersection of two elements of this collection contains some element
of the collection. -/
structure FilterBasis (Œ± : Type*) where
  /-- Sets of a filter basis. -/
  sets : Set (Set Œ±)
  /-- The set of filter basis sets is nonempty. -/
  nonempty : sets.Nonempty
  /-- The set of filter basis sets is directed downwards. -/
  inter_sets {x y} : x ‚àà sets ‚Üí y ‚àà sets ‚Üí ‚àÉ z ‚àà sets, z ‚äÜ x ‚à© y

instance FilterBasis.nonempty_sets (B : FilterBasis Œ±) : Nonempty B.sets :=
  B.nonempty.to_subtype

-- Porting note: this instance was reducible but it doesn't work the same way in Lean 4
/-- If `B` is a filter basis on `Œ±`, and `U` a subset of `Œ±` then we can write `U ‚àà B` as
on paper. -/
instance {Œ± : Type*} : Membership (Set Œ±) (FilterBasis Œ±) :=
  ‚ü®fun B U => U ‚àà B.sets‚ü©

@[simp] theorem FilterBasis.mem_sets {s : Set Œ±} {B : FilterBasis Œ±} : s ‚àà B.sets ‚Üî s ‚àà B := Iff.rfl

-- For illustration purposes, the filter basis defining `(atTop : Filter ‚Ñï)`
instance : Inhabited (FilterBasis ‚Ñï) :=
  ‚ü®{  sets := range Ici
      nonempty := ‚ü®Ici 0, mem_range_self 0‚ü©
      inter_sets := by
        rintro _ _ ‚ü®n, rfl‚ü© ‚ü®m, rfl‚ü©
        exact ‚ü®Ici (max n m), mem_range_self _, Ici_inter_Ici.symm.subset‚ü© }‚ü©

/-- View a filter as a filter basis. -/
def Filter.asBasis (f : Filter Œ±) : FilterBasis Œ± :=
  ‚ü®f.sets, ‚ü®univ, univ_mem‚ü©, fun {x y} hx hy => ‚ü®x ‚à© y, inter_mem hx hy, subset_rfl‚ü©‚ü©

-- Porting note: was `protected` in Lean 3 but `protected` didn't work; removed
/-- `is_basis p s` means the image of `s` bounded by `p` is a filter basis. -/
structure Filter.IsBasis (p : Œπ ‚Üí Prop) (s : Œπ ‚Üí Set Œ±) : Prop where
  /-- There exists at least one `i` that satisfies `p`. -/
  nonempty : ‚àÉ i, p i
  /-- `s` is directed downwards on `i` such that `p i`. -/
  inter : ‚àÄ {i j}, p i ‚Üí p j ‚Üí ‚àÉ k, p k ‚àß s k ‚äÜ s i ‚à© s j

namespace Filter

namespace IsBasis

/-- Constructs a filter basis from an indexed family of sets satisfying `IsBasis`. -/
protected def filterBasis {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ±} (h : IsBasis p s) : FilterBasis Œ± where
  sets := { t | ‚àÉ i, p i ‚àß s i = t }
  nonempty :=
    let ‚ü®i, hi‚ü© := h.nonempty
    ‚ü®s i, ‚ü®i, hi, rfl‚ü©‚ü©
  inter_sets := by
    rintro _ _ ‚ü®i, hi, rfl‚ü© ‚ü®j, hj, rfl‚ü©
    rcases h.inter hi hj with ‚ü®k, hk, hk'‚ü©
    exact ‚ü®_, ‚ü®k, hk, rfl‚ü©, hk'‚ü©

variable {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ±} (h : IsBasis p s)

theorem mem_filterBasis_iff {U : Set Œ±} : U ‚àà h.filterBasis ‚Üî ‚àÉ i, p i ‚àß s i = U :=
  Iff.rfl

end IsBasis

end Filter

namespace FilterBasis

/-- The filter associated to a filter basis. -/
protected def filter (B : FilterBasis Œ±) : Filter Œ± where
  sets := { s | ‚àÉ t ‚àà B, t ‚äÜ s }
  univ_sets := B.nonempty.imp fun s s_in => ‚ü®s_in, s.subset_univ‚ü©
  sets_of_superset := fun ‚ü®s, s_in, h‚ü© hxy => ‚ü®s, s_in, Set.Subset.trans h hxy‚ü©
  inter_sets := fun ‚ü®_s, s_in, hs‚ü© ‚ü®_t, t_in, ht‚ü© =>
    let ‚ü®u, u_in, u_sub‚ü© := B.inter_sets s_in t_in
    ‚ü®u, u_in, u_sub.trans (inter_subset_inter hs ht)‚ü©

theorem mem_filter_iff (B : FilterBasis Œ±) {U : Set Œ±} : U ‚àà B.filter ‚Üî ‚àÉ s ‚àà B, s ‚äÜ U :=
  Iff.rfl

theorem mem_filter_of_mem (B : FilterBasis Œ±) {U : Set Œ±} : U ‚àà B ‚Üí U ‚àà B.filter := fun U_in =>
  ‚ü®U, U_in, Subset.refl _‚ü©

theorem eq_iInf_principal (B : FilterBasis Œ±) : B.filter = ‚®Ö s : B.sets, ùìü s := by
  have : Directed (¬∑ ‚â• ¬∑) fun s : B.sets => ùìü (s : Set Œ±) := by
    rintro ‚ü®U, U_in‚ü© ‚ü®V, V_in‚ü©
    rcases B.inter_sets U_in V_in with ‚ü®W, W_in, W_sub‚ü©
    use ‚ü®W, W_in‚ü©
    simp only [le_principal_iff, mem_principal, Subtype.coe_mk]
    exact subset_inter_iff.mp W_sub
  ext U
  simp [mem_filter_iff, mem_iInf_of_directed this]

protected theorem generate (B : FilterBasis Œ±) : generate B.sets = B.filter := by
  apply le_antisymm
  ¬∑ intro U U_in
    rcases B.mem_filter_iff.mp U_in with ‚ü®V, V_in, h‚ü©
    exact GenerateSets.superset (GenerateSets.basic V_in) h
  ¬∑ rw [le_generate_iff]
    apply mem_filter_of_mem

end FilterBasis

namespace Filter

namespace IsBasis

variable {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ±}

/-- Constructs a filter from an indexed family of sets satisfying `IsBasis`. -/
protected def filter (h : IsBasis p s) : Filter Œ± :=
  h.filterBasis.filter

protected theorem mem_filter_iff (h : IsBasis p s) {U : Set Œ±} :
    U ‚àà h.filter ‚Üî ‚àÉ i, p i ‚àß s i ‚äÜ U := by
  simp only [IsBasis.filter, FilterBasis.mem_filter_iff, mem_filterBasis_iff,
    exists_exists_and_eq_and]

theorem filter_eq_generate (h : IsBasis p s) : h.filter = generate { U | ‚àÉ i, p i ‚àß s i = U } := by
  erw [h.filterBasis.generate]; rfl

end IsBasis

-- Porting note: was `protected` in Lean 3 but `protected` didn't work; removed
/-- We say that a filter `l` has a basis `s : Œπ ‚Üí Set Œ±` bounded by `p : Œπ ‚Üí Prop`,
if `t ‚àà l` if and only if `t` includes `s i` for some `i` such that `p i`. -/
structure HasBasis (l : Filter Œ±) (p : Œπ ‚Üí Prop) (s : Œπ ‚Üí Set Œ±) : Prop where
  /-- A set `t` belongs to a filter `l` iff it includes an element of the basis. -/
  mem_iff' : ‚àÄ t : Set Œ±, t ‚àà l ‚Üî ‚àÉ i, p i ‚àß s i ‚äÜ t

section SameType

variable {l l' : Filter Œ±} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ±} {t : Set Œ±} {i : Œπ} {p' : Œπ' ‚Üí Prop}
  {s' : Œπ' ‚Üí Set Œ±} {i' : Œπ'}

theorem hasBasis_generate (s : Set (Set Œ±)) :
    (generate s).HasBasis (fun t => Set.Finite t ‚àß t ‚äÜ s) fun t => ‚ãÇ‚ÇÄ t :=
  ‚ü®fun U => by simp only [mem_generate_iff, exists_prop, and_assoc, and_left_comm]‚ü©

/-- The smallest filter basis containing a given collection of sets. -/
def FilterBasis.ofSets (s : Set (Set Œ±)) : FilterBasis Œ± where
  sets := sInter '' { t | Set.Finite t ‚àß t ‚äÜ s }
  nonempty := ‚ü®univ, ‚àÖ, ‚ü®‚ü®finite_empty, empty_subset s‚ü©, sInter_empty‚ü©‚ü©
  inter_sets := by
    rintro _ _ ‚ü®a, ‚ü®fina, suba‚ü©, rfl‚ü© ‚ü®b, ‚ü®finb, subb‚ü©, rfl‚ü©
    exact ‚ü®‚ãÇ‚ÇÄ (a ‚à™ b), mem_image_of_mem _ ‚ü®fina.union finb, union_subset suba subb‚ü©,
        (sInter_union _ _).subset‚ü©

lemma FilterBasis.ofSets_sets (s : Set (Set Œ±)) :
    (FilterBasis.ofSets s).sets = sInter '' { t | Set.Finite t ‚àß t ‚äÜ s } :=
  rfl

-- Porting note: use `‚àÉ i, p i ‚àß _` instead of `‚àÉ i (hi : p i), _`.
/-- Definition of `HasBasis` unfolded with implicit set argument. -/
theorem HasBasis.mem_iff (hl : l.HasBasis p s) : t ‚àà l ‚Üî ‚àÉ i, p i ‚àß s i ‚äÜ t :=
  hl.mem_iff' t

theorem HasBasis.eq_of_same_basis (hl : l.HasBasis p s) (hl' : l'.HasBasis p s) : l = l' := by
  ext t
  rw [hl.mem_iff, hl'.mem_iff]

-- Porting note: use `‚àÉ i, p i ‚àß _` instead of `‚àÉ i (hi : p i), _`.
theorem hasBasis_iff : l.HasBasis p s ‚Üî ‚àÄ t, t ‚àà l ‚Üî ‚àÉ i, p i ‚àß s i ‚äÜ t :=
  ‚ü®fun ‚ü®h‚ü© => h, fun h => ‚ü®h‚ü©‚ü©

theorem HasBasis.ex_mem (h : l.HasBasis p s) : ‚àÉ i, p i :=
  (h.mem_iff.mp univ_mem).imp fun _ => And.left

protected theorem HasBasis.nonempty (h : l.HasBasis p s) : Nonempty Œπ :=
  nonempty_of_exists h.ex_mem

protected theorem IsBasis.hasBasis (h : IsBasis p s) : HasBasis h.filter p s :=
  ‚ü®fun t => by simp only [h.mem_filter_iff, exists_prop]‚ü©

protected theorem HasBasis.mem_of_superset (hl : l.HasBasis p s) (hi : p i) (ht : s i ‚äÜ t) :
    t ‚àà l :=
  hl.mem_iff.2 ‚ü®i, hi, ht‚ü©

theorem HasBasis.mem_of_mem (hl : l.HasBasis p s) (hi : p i) : s i ‚àà l :=
  hl.mem_of_superset hi Subset.rfl

/-- Index of a basis set such that `s i ‚äÜ t` as an element of `Subtype p`. -/
noncomputable def HasBasis.index (h : l.HasBasis p s) (t : Set Œ±) (ht : t ‚àà l) : { i : Œπ // p i } :=
  ‚ü®(h.mem_iff.1 ht).choose, (h.mem_iff.1 ht).choose_spec.1‚ü©

theorem HasBasis.property_index (h : l.HasBasis p s) (ht : t ‚àà l) : p (h.index t ht) :=
  (h.index t ht).2

theorem HasBasis.set_index_mem (h : l.HasBasis p s) (ht : t ‚àà l) : s (h.index t ht) ‚àà l :=
  h.mem_of_mem <| h.property_index _

theorem HasBasis.set_index_subset (h : l.HasBasis p s) (ht : t ‚àà l) : s (h.index t ht) ‚äÜ t :=
  (h.mem_iff.1 ht).choose_spec.2

theorem HasBasis.isBasis (h : l.HasBasis p s) : IsBasis p s where
  nonempty := h.ex_mem
  inter hi hj := by
    simpa only [h.mem_iff] using inter_mem (h.mem_of_mem hi) (h.mem_of_mem hj)

theorem HasBasis.filter_eq (h : l.HasBasis p s) : h.isBasis.filter = l := by
  ext U
  simp [h.mem_iff, IsBasis.mem_filter_iff]

theorem HasBasis.eq_generate (h : l.HasBasis p s) : l = generate { U | ‚àÉ i, p i ‚àß s i = U } := by
  rw [‚Üê h.isBasis.filter_eq_generate, h.filter_eq]

theorem generate_eq_generate_inter (s : Set (Set Œ±)) :
    generate s = generate (sInter '' { t | Set.Finite t ‚àß t ‚äÜ s }) := by
  rw [‚Üê FilterBasis.ofSets_sets, FilterBasis.generate, ‚Üê (hasBasis_generate s).filter_eq]; rfl

theorem ofSets_filter_eq_generate (s : Set (Set Œ±)) :
    (FilterBasis.ofSets s).filter = generate s := by
  rw [‚Üê (FilterBasis.ofSets s).generate, FilterBasis.ofSets_sets, ‚Üê generate_eq_generate_inter]

protected theorem _root_.FilterBasis.hasBasis (B : FilterBasis Œ±) :
    HasBasis B.filter (fun s : Set Œ± => s ‚àà B) id :=
  ‚ü®fun _ => B.mem_filter_iff‚ü©

theorem HasBasis.to_hasBasis' (hl : l.HasBasis p s) (h : ‚àÄ i, p i ‚Üí ‚àÉ i', p' i' ‚àß s' i' ‚äÜ s i)
    (h' : ‚àÄ i', p' i' ‚Üí s' i' ‚àà l) : l.HasBasis p' s' := by
  refine ‚ü®fun t => ‚ü®fun ht => ?_, fun ‚ü®i', hi', ht‚ü© => mem_of_superset (h' i' hi') ht‚ü©‚ü©
  rcases hl.mem_iff.1 ht with ‚ü®i, hi, ht‚ü©
  rcases h i hi with ‚ü®i', hi', hs's‚ü©
  exact ‚ü®i', hi', hs's.trans ht‚ü©

theorem HasBasis.to_hasBasis (hl : l.HasBasis p s) (h : ‚àÄ i, p i ‚Üí ‚àÉ i', p' i' ‚àß s' i' ‚äÜ s i)
    (h' : ‚àÄ i', p' i' ‚Üí ‚àÉ i, p i ‚àß s i ‚äÜ s' i') : l.HasBasis p' s' :=
  hl.to_hasBasis' h fun i' hi' =>
    let ‚ü®i, hi, hss'‚ü© := h' i' hi'
    hl.mem_iff.2 ‚ü®i, hi, hss'‚ü©

protected lemma HasBasis.congr (hl : l.HasBasis p s) {p' s'} (hp : ‚àÄ i, p i ‚Üî p' i)
    (hs : ‚àÄ i, p i ‚Üí s i = s' i) : l.HasBasis p' s' :=
  ‚ü®fun t ‚Ü¶ by simp only [hl.mem_iff, ‚Üê hp]; exact exists_congr fun i ‚Ü¶
    and_congr_right fun hi ‚Ü¶ hs i hi ‚ñ∏ Iff.rfl‚ü©

theorem HasBasis.to_subset (hl : l.HasBasis p s) {t : Œπ ‚Üí Set Œ±} (h : ‚àÄ i, p i ‚Üí t i ‚äÜ s i)
    (ht : ‚àÄ i, p i ‚Üí t i ‚àà l) : l.HasBasis p t :=
  hl.to_hasBasis' (fun i hi => ‚ü®i, hi, h i hi‚ü©) ht

theorem HasBasis.eventually_iff (hl : l.HasBasis p s) {q : Œ± ‚Üí Prop} :
    (‚àÄ·∂† x in l, q x) ‚Üî ‚àÉ i, p i ‚àß ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà s i ‚Üí q x := by simpa using hl.mem_iff

theorem HasBasis.frequently_iff (hl : l.HasBasis p s) {q : Œ± ‚Üí Prop} :
    (‚àÉ·∂† x in l, q x) ‚Üî ‚àÄ i, p i ‚Üí ‚àÉ x ‚àà s i, q x := by
  simp only [Filter.Frequently, hl.eventually_iff]; push_neg; rfl

-- Porting note: use `‚àÉ i, p i ‚àß _` instead of `‚àÉ i (hi : p i), _`.
theorem HasBasis.exists_iff (hl : l.HasBasis p s) {P : Set Œ± ‚Üí Prop}
    (mono : ‚àÄ ‚¶És t‚¶Ñ, s ‚äÜ t ‚Üí P t ‚Üí P s) : (‚àÉ s ‚àà l, P s) ‚Üî ‚àÉ i, p i ‚àß P (s i) :=
  ‚ü®fun ‚ü®_s, hs, hP‚ü© =>
    let ‚ü®i, hi, his‚ü© := hl.mem_iff.1 hs
    ‚ü®i, hi, mono his hP‚ü©,
    fun ‚ü®i, hi, hP‚ü© => ‚ü®s i, hl.mem_of_mem hi, hP‚ü©‚ü©

theorem HasBasis.forall_iff (hl : l.HasBasis p s) {P : Set Œ± ‚Üí Prop}
    (mono : ‚àÄ ‚¶És t‚¶Ñ, s ‚äÜ t ‚Üí P s ‚Üí P t) : (‚àÄ s ‚àà l, P s) ‚Üî ‚àÄ i, p i ‚Üí P (s i) :=
  ‚ü®fun H i hi => H (s i) <| hl.mem_of_mem hi, fun H _s hs =>
    let ‚ü®i, hi, his‚ü© := hl.mem_iff.1 hs
    mono his (H i hi)‚ü©

protected theorem HasBasis.neBot_iff (hl : l.HasBasis p s) :
    NeBot l ‚Üî ‚àÄ {i}, p i ‚Üí (s i).Nonempty :=
  forall_mem_nonempty_iff_neBot.symm.trans <| hl.forall_iff fun _ _ => Nonempty.mono

theorem HasBasis.eq_bot_iff (hl : l.HasBasis p s) : l = ‚ä• ‚Üî ‚àÉ i, p i ‚àß s i = ‚àÖ :=
  not_iff_not.1 <| neBot_iff.symm.trans <|
    hl.neBot_iff.trans <| by simp only [not_exists, not_and, nonempty_iff_ne_empty]

theorem generate_neBot_iff {s : Set (Set Œ±)} :
    NeBot (generate s) ‚Üî ‚àÄ t, t ‚äÜ s ‚Üí t.Finite ‚Üí (‚ãÇ‚ÇÄ t).Nonempty :=
  (hasBasis_generate s).neBot_iff.trans <| by simp only [‚Üê and_imp, and_comm]

theorem basis_sets (l : Filter Œ±) : l.HasBasis (fun s : Set Œ± => s ‚àà l) id :=
  ‚ü®fun _ => exists_mem_subset_iff.symm‚ü©

theorem asBasis_filter (f : Filter Œ±) : f.asBasis.filter = f :=
  Filter.ext fun _ => exists_mem_subset_iff

theorem hasBasis_self {l : Filter Œ±} {P : Set Œ± ‚Üí Prop} :
    HasBasis l (fun s => s ‚àà l ‚àß P s) id ‚Üî ‚àÄ t ‚àà l, ‚àÉ r ‚àà l, P r ‚àß r ‚äÜ t := by
  simp only [hasBasis_iff, id, and_assoc]
  exact forall_congr' fun s =>
    ‚ü®fun h => h.1, fun h => ‚ü®h, fun ‚ü®t, hl, _, hts‚ü© => mem_of_superset hl hts‚ü©‚ü©

theorem HasBasis.comp_surjective (h : l.HasBasis p s) {g : Œπ' ‚Üí Œπ} (hg : Function.Surjective g) :
    l.HasBasis (p ‚àò g) (s ‚àò g) :=
  ‚ü®fun _ => h.mem_iff.trans hg.exists‚ü©

theorem HasBasis.comp_equiv (h : l.HasBasis p s) (e : Œπ' ‚âÉ Œπ) : l.HasBasis (p ‚àò e) (s ‚àò e) :=
  h.comp_surjective e.surjective

theorem HasBasis.to_image_id' (h : l.HasBasis p s) : l.HasBasis (fun t ‚Ü¶ ‚àÉ i, p i ‚àß s i = t) id :=
  ‚ü®fun _ ‚Ü¶ by simp [h.mem_iff]‚ü©

theorem HasBasis.to_image_id {Œπ : Type*} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ±} (h : l.HasBasis p s) :
    l.HasBasis (¬∑ ‚àà s '' {i | p i}) id :=
  h.to_image_id'

/-- If `{s i | p i}` is a basis of a filter `l` and each `s i` includes `s j` such that
`p j ‚àß q j`, then `{s j | p j ‚àß q j}` is a basis of `l`. -/
theorem HasBasis.restrict (h : l.HasBasis p s) {q : Œπ ‚Üí Prop}
    (hq : ‚àÄ i, p i ‚Üí ‚àÉ j, p j ‚àß q j ‚àß s j ‚äÜ s i) : l.HasBasis (fun i => p i ‚àß q i) s := by
  refine ‚ü®fun t => ‚ü®fun ht => ?_, fun ‚ü®i, hpi, hti‚ü© => h.mem_iff.2 ‚ü®i, hpi.1, hti‚ü©‚ü©‚ü©
  rcases h.mem_iff.1 ht with ‚ü®i, hpi, hti‚ü©
  rcases hq i hpi with ‚ü®j, hpj, hqj, hji‚ü©
  exact ‚ü®j, ‚ü®hpj, hqj‚ü©, hji.trans hti‚ü©

/-- If `{s i | p i}` is a basis of a filter `l` and `V ‚àà l`, then `{s i | p i ‚àß s i ‚äÜ V}`
is a basis of `l`. -/
theorem HasBasis.restrict_subset (h : l.HasBasis p s) {V : Set Œ±} (hV : V ‚àà l) :
    l.HasBasis (fun i => p i ‚àß s i ‚äÜ V) s :=
  h.restrict fun _i hi => (h.mem_iff.1 (inter_mem hV (h.mem_of_mem hi))).imp fun _j hj =>
    ‚ü®hj.1, subset_inter_iff.1 hj.2‚ü©

theorem HasBasis.hasBasis_self_subset {p : Set Œ± ‚Üí Prop} (h : l.HasBasis (fun s => s ‚àà l ‚àß p s) id)
    {V : Set Œ±} (hV : V ‚àà l) : l.HasBasis (fun s => s ‚àà l ‚àß p s ‚àß s ‚äÜ V) id := by
  simpa only [and_assoc] using h.restrict_subset hV

theorem HasBasis.ge_iff (hl' : l'.HasBasis p' s') : l ‚â§ l' ‚Üî ‚àÄ i', p' i' ‚Üí s' i' ‚àà l :=
  ‚ü®fun h _i' hi' => h <| hl'.mem_of_mem hi', fun h _s hs =>
    let ‚ü®_i', hi', hs‚ü© := hl'.mem_iff.1 hs
    mem_of_superset (h _ hi') hs‚ü©

-- Porting note: use `‚àÉ i, p i ‚àß _` instead of `‚àÉ i (hi : p i), _`.
theorem HasBasis.le_iff (hl : l.HasBasis p s) : l ‚â§ l' ‚Üî ‚àÄ t ‚àà l', ‚àÉ i, p i ‚àß s i ‚äÜ t := by
  simp only [le_def, hl.mem_iff]

-- Porting note: use `‚àÉ i, p i ‚àß _` instead of `‚àÉ i (hi : p i), _`.
theorem HasBasis.le_basis_iff (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :
    l ‚â§ l' ‚Üî ‚àÄ i', p' i' ‚Üí ‚àÉ i, p i ‚àß s i ‚äÜ s' i' := by
  simp only [hl'.ge_iff, hl.mem_iff]

-- Porting note: use `‚àÉ i, p i ‚àß _` instead of `‚àÉ i (hi : p i), _`.
theorem HasBasis.ext (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s')
    (h : ‚àÄ i, p i ‚Üí ‚àÉ i', p' i' ‚àß s' i' ‚äÜ s i) (h' : ‚àÄ i', p' i' ‚Üí ‚àÉ i, p i ‚àß s i ‚äÜ s' i') :
    l = l' := by
  apply le_antisymm
  ¬∑ rw [hl.le_basis_iff hl']
    simpa using h'
  ¬∑ rw [hl'.le_basis_iff hl]
    simpa using h

theorem HasBasis.inf' (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :
    (l ‚äì l').HasBasis (fun i : PProd Œπ Œπ' => p i.1 ‚àß p' i.2) fun i => s i.1 ‚à© s' i.2 :=
  ‚ü®by
    intro t
    constructor
    ¬∑ simp only [mem_inf_iff, hl.mem_iff, hl'.mem_iff]
      rintro ‚ü®t, ‚ü®i, hi, ht‚ü©, t', ‚ü®i', hi', ht'‚ü©, rfl‚ü©
      exact ‚ü®‚ü®i, i'‚ü©, ‚ü®hi, hi'‚ü©, inter_subset_inter ht ht'‚ü©
    ¬∑ rintro ‚ü®‚ü®i, i'‚ü©, ‚ü®hi, hi'‚ü©, H‚ü©
      exact mem_inf_of_inter (hl.mem_of_mem hi) (hl'.mem_of_mem hi') H‚ü©

theorem HasBasis.inf {Œπ Œπ' : Type*} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ±} {p' : Œπ' ‚Üí Prop}
    {s' : Œπ' ‚Üí Set Œ±} (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :
    (l ‚äì l').HasBasis (fun i : Œπ √ó Œπ' => p i.1 ‚àß p' i.2) fun i => s i.1 ‚à© s' i.2 :=
  (hl.inf' hl').comp_equiv Equiv.pprodEquivProd.symm

theorem hasBasis_iInf' {Œπ : Type*} {Œπ' : Œπ ‚Üí Type*} {l : Œπ ‚Üí Filter Œ±} {p : ‚àÄ i, Œπ' i ‚Üí Prop}
    {s : ‚àÄ i, Œπ' i ‚Üí Set Œ±} (hl : ‚àÄ i, (l i).HasBasis (p i) (s i)) :
    (‚®Ö i, l i).HasBasis (fun If : Set Œπ √ó ‚àÄ i, Œπ' i => If.1.Finite ‚àß ‚àÄ i ‚àà If.1, p i (If.2 i))
      fun If : Set Œπ √ó ‚àÄ i, Œπ' i => ‚ãÇ i ‚àà If.1, s i (If.2 i) :=
  ‚ü®by
    intro t
    constructor
    ¬∑ simp only [mem_iInf', (hl _).mem_iff]
      rintro ‚ü®I, hI, V, hV, -, rfl, -‚ü©
      choose u hu using hV
      exact ‚ü®‚ü®I, u‚ü©, ‚ü®hI, fun i _ => (hu i).1‚ü©, iInter‚ÇÇ_mono fun i _ => (hu i).2‚ü©
    ¬∑ rintro ‚ü®‚ü®I, f‚ü©, ‚ü®hI‚ÇÅ, hI‚ÇÇ‚ü©, hsub‚ü©
      refine mem_of_superset ?_ hsub
      exact (biInter_mem hI‚ÇÅ).mpr fun i hi => mem_iInf_of_mem i <| (hl i).mem_of_mem <| hI‚ÇÇ _ hi‚ü©

theorem hasBasis_iInf {Œπ : Type*} {Œπ' : Œπ ‚Üí Type*} {l : Œπ ‚Üí Filter Œ±} {p : ‚àÄ i, Œπ' i ‚Üí Prop}
    {s : ‚àÄ i, Œπ' i ‚Üí Set Œ±} (hl : ‚àÄ i, (l i).HasBasis (p i) (s i)) :
    (‚®Ö i, l i).HasBasis
      (fun If : Œ£ I : Set Œπ, ‚àÄ i : I, Œπ' i => If.1.Finite ‚àß ‚àÄ i : If.1, p i (If.2 i)) fun If =>
      ‚ãÇ i : If.1, s i (If.2 i) := by
  refine ‚ü®fun t => ‚ü®fun ht => ?_, ?_‚ü©‚ü©
  ¬∑ rcases (hasBasis_iInf' hl).mem_iff.mp ht with ‚ü®‚ü®I, f‚ü©, ‚ü®hI, hf‚ü©, hsub‚ü©
    exact ‚ü®‚ü®I, fun i => f i‚ü©, ‚ü®hI, Subtype.forall.mpr hf‚ü©, trans (iInter_subtype _ _) hsub‚ü©
  ¬∑ rintro ‚ü®‚ü®I, f‚ü©, ‚ü®hI, hf‚ü©, hsub‚ü©
    refine mem_of_superset ?_ hsub
    cases hI.nonempty_fintype
    exact iInter_mem.2 fun i => mem_iInf_of_mem ‚Üëi <| (hl i).mem_of_mem <| hf _

theorem hasBasis_iInf_of_directed' {Œπ : Type*} {Œπ' : Œπ ‚Üí Sort _} [Nonempty Œπ] {l : Œπ ‚Üí Filter Œ±}
    (s : ‚àÄ i, Œπ' i ‚Üí Set Œ±) (p : ‚àÄ i, Œπ' i ‚Üí Prop) (hl : ‚àÄ i, (l i).HasBasis (p i) (s i))
    (h : Directed (¬∑ ‚â• ¬∑) l) :
    (‚®Ö i, l i).HasBasis (fun ii' : Œ£i, Œπ' i => p ii'.1 ii'.2) fun ii' => s ii'.1 ii'.2 := by
  refine ‚ü®fun t => ?_‚ü©
  rw [mem_iInf_of_directed h, Sigma.exists]
  exact exists_congr fun i => (hl i).mem_iff

theorem hasBasis_iInf_of_directed {Œπ : Type*} {Œπ' : Sort _} [Nonempty Œπ] {l : Œπ ‚Üí Filter Œ±}
    (s : Œπ ‚Üí Œπ' ‚Üí Set Œ±) (p : Œπ ‚Üí Œπ' ‚Üí Prop) (hl : ‚àÄ i, (l i).HasBasis (p i) (s i))
    (h : Directed (¬∑ ‚â• ¬∑) l) :
    (‚®Ö i, l i).HasBasis (fun ii' : Œπ √ó Œπ' => p ii'.1 ii'.2) fun ii' => s ii'.1 ii'.2 := by
  refine ‚ü®fun t => ?_‚ü©
  rw [mem_iInf_of_directed h, Prod.exists]
  exact exists_congr fun i => (hl i).mem_iff

theorem hasBasis_biInf_of_directed' {Œπ : Type*} {Œπ' : Œπ ‚Üí Sort _} {dom : Set Œπ}
    (hdom : dom.Nonempty) {l : Œπ ‚Üí Filter Œ±} (s : ‚àÄ i, Œπ' i ‚Üí Set Œ±) (p : ‚àÄ i, Œπ' i ‚Üí Prop)
    (hl : ‚àÄ i ‚àà dom, (l i).HasBasis (p i) (s i)) (h : DirectedOn (l ‚Åª¬π'o GE.ge) dom) :
    (‚®Ö i ‚àà dom, l i).HasBasis (fun ii' : Œ£i, Œπ' i => ii'.1 ‚àà dom ‚àß p ii'.1 ii'.2) fun ii' =>
      s ii'.1 ii'.2 := by
  refine ‚ü®fun t => ?_‚ü©
  rw [mem_biInf_of_directed h hdom, Sigma.exists]
  refine exists_congr fun i => ‚ü®?_, ?_‚ü©
  ¬∑ rintro ‚ü®hi, hti‚ü©
    rcases (hl i hi).mem_iff.mp hti with ‚ü®b, hb, hbt‚ü©
    exact ‚ü®b, ‚ü®hi, hb‚ü©, hbt‚ü©
  ¬∑ rintro ‚ü®b, ‚ü®hi, hb‚ü©, hibt‚ü©
    exact ‚ü®hi, (hl i hi).mem_iff.mpr ‚ü®b, hb, hibt‚ü©‚ü©

theorem hasBasis_biInf_of_directed {Œπ : Type*} {Œπ' : Sort _} {dom : Set Œπ} (hdom : dom.Nonempty)
    {l : Œπ ‚Üí Filter Œ±} (s : Œπ ‚Üí Œπ' ‚Üí Set Œ±) (p : Œπ ‚Üí Œπ' ‚Üí Prop)
    (hl : ‚àÄ i ‚àà dom, (l i).HasBasis (p i) (s i)) (h : DirectedOn (l ‚Åª¬π'o GE.ge) dom) :
    (‚®Ö i ‚àà dom, l i).HasBasis (fun ii' : Œπ √ó Œπ' => ii'.1 ‚àà dom ‚àß p ii'.1 ii'.2) fun ii' =>
      s ii'.1 ii'.2 := by
  refine ‚ü®fun t => ?_‚ü©
  rw [mem_biInf_of_directed h hdom, Prod.exists]
  refine exists_congr fun i => ‚ü®?_, ?_‚ü©
  ¬∑ rintro ‚ü®hi, hti‚ü©
    rcases (hl i hi).mem_iff.mp hti with ‚ü®b, hb, hbt‚ü©
    exact ‚ü®b, ‚ü®hi, hb‚ü©, hbt‚ü©
  ¬∑ rintro ‚ü®b, ‚ü®hi, hb‚ü©, hibt‚ü©
    exact ‚ü®hi, (hl i hi).mem_iff.mpr ‚ü®b, hb, hibt‚ü©‚ü©

theorem hasBasis_principal (t : Set Œ±) : (ùìü t).HasBasis (fun _ : Unit => True) fun _ => t :=
  ‚ü®fun U => by simp‚ü©

theorem hasBasis_pure (x : Œ±) :
    (pure x : Filter Œ±).HasBasis (fun _ : Unit => True) fun _ => {x} := by
  simp only [‚Üê principal_singleton, hasBasis_principal]

theorem HasBasis.sup' (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :
    (l ‚äî l').HasBasis (fun i : PProd Œπ Œπ' => p i.1 ‚àß p' i.2) fun i => s i.1 ‚à™ s' i.2 :=
  ‚ü®by
    intro t
    simp_rw [mem_sup, hl.mem_iff, hl'.mem_iff, PProd.exists, union_subset_iff,
       ‚Üê exists_and_right, ‚Üê exists_and_left]
    simp only [and_assoc, and_left_comm]‚ü©

theorem HasBasis.sup {Œπ Œπ' : Type*} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ±} {p' : Œπ' ‚Üí Prop}
    {s' : Œπ' ‚Üí Set Œ±} (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :
    (l ‚äî l').HasBasis (fun i : Œπ √ó Œπ' => p i.1 ‚àß p' i.2) fun i => s i.1 ‚à™ s' i.2 :=
  (hl.sup' hl').comp_equiv Equiv.pprodEquivProd.symm

theorem hasBasis_iSup {Œπ : Sort*} {Œπ' : Œπ ‚Üí Type*} {l : Œπ ‚Üí Filter Œ±} {p : ‚àÄ i, Œπ' i ‚Üí Prop}
    {s : ‚àÄ i, Œπ' i ‚Üí Set Œ±} (hl : ‚àÄ i, (l i).HasBasis (p i) (s i)) :
    (‚®Ü i, l i).HasBasis (fun f : ‚àÄ i, Œπ' i => ‚àÄ i, p i (f i)) fun f : ‚àÄ i, Œπ' i => ‚ãÉ i, s i (f i) :=
  hasBasis_iff.mpr fun t => by
    simp only [hasBasis_iff, (hl _).mem_iff, Classical.skolem, forall_and, iUnion_subset_iff,
      mem_iSup]

theorem HasBasis.sup_principal (hl : l.HasBasis p s) (t : Set Œ±) :
    (l ‚äî ùìü t).HasBasis p fun i => s i ‚à™ t :=
  ‚ü®fun u => by
    simp only [(hl.sup' (hasBasis_principal t)).mem_iff, PProd.exists, exists_prop, and_true_iff,
      Unique.exists_iff]‚ü©

theorem HasBasis.sup_pure (hl : l.HasBasis p s) (x : Œ±) :
    (l ‚äî pure x).HasBasis p fun i => s i ‚à™ {x} := by
  simp only [‚Üê principal_singleton, hl.sup_principal]

theorem HasBasis.inf_principal (hl : l.HasBasis p s) (s' : Set Œ±) :
    (l ‚äì ùìü s').HasBasis p fun i => s i ‚à© s' :=
  ‚ü®fun t => by
    simp only [mem_inf_principal, hl.mem_iff, subset_def, mem_setOf_eq, mem_inter_iff, and_imp]‚ü©

theorem HasBasis.principal_inf (hl : l.HasBasis p s) (s' : Set Œ±) :
    (ùìü s' ‚äì l).HasBasis p fun i => s' ‚à© s i := by
  simpa only [inf_comm, inter_comm] using hl.inf_principal s'

theorem HasBasis.inf_basis_neBot_iff (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :
    NeBot (l ‚äì l') ‚Üî ‚àÄ ‚¶Éi‚¶Ñ, p i ‚Üí ‚àÄ ‚¶Éi'‚¶Ñ, p' i' ‚Üí (s i ‚à© s' i').Nonempty :=
  (hl.inf' hl').neBot_iff.trans <| by simp [@forall_swap _ Œπ']

theorem HasBasis.inf_neBot_iff (hl : l.HasBasis p s) :
    NeBot (l ‚äì l') ‚Üî ‚àÄ ‚¶Éi‚¶Ñ, p i ‚Üí ‚àÄ ‚¶És'‚¶Ñ, s' ‚àà l' ‚Üí (s i ‚à© s').Nonempty :=
  hl.inf_basis_neBot_iff l'.basis_sets

theorem HasBasis.inf_principal_neBot_iff (hl : l.HasBasis p s) {t : Set Œ±} :
    NeBot (l ‚äì ùìü t) ‚Üî ‚àÄ ‚¶Éi‚¶Ñ, p i ‚Üí (s i ‚à© t).Nonempty :=
  (hl.inf_principal t).neBot_iff

-- Porting note: use `‚àÉ i, p i ‚àß _` instead of `‚àÉ i (hi : p i), _`.
theorem HasBasis.disjoint_iff (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :
    Disjoint l l' ‚Üî ‚àÉ i, p i ‚àß ‚àÉ i', p' i' ‚àß Disjoint (s i) (s' i') :=
  not_iff_not.mp <| by simp only [_root_.disjoint_iff, ‚Üê Ne.eq_def, ‚Üê neBot_iff, inf_eq_inter,
    hl.inf_basis_neBot_iff hl', not_exists, not_and, bot_eq_empty, ‚Üê nonempty_iff_ne_empty]

-- Porting note: use `‚àÉ i, p i ‚àß _` instead of `‚àÉ i (hi : p i), _`.
theorem _root_.Disjoint.exists_mem_filter_basis (h : Disjoint l l') (hl : l.HasBasis p s)
    (hl' : l'.HasBasis p' s') : ‚àÉ i, p i ‚àß ‚àÉ i', p' i' ‚àß Disjoint (s i) (s' i') :=
  (hl.disjoint_iff hl').1 h

theorem _root_.Pairwise.exists_mem_filter_basis_of_disjoint {I} [Finite I] {l : I ‚Üí Filter Œ±}
    {Œπ : I ‚Üí Sort*} {p : ‚àÄ i, Œπ i ‚Üí Prop} {s : ‚àÄ i, Œπ i ‚Üí Set Œ±} (hd : Pairwise (Disjoint on l))
    (h : ‚àÄ i, (l i).HasBasis (p i) (s i)) :
    ‚àÉ ind : ‚àÄ i, Œπ i, (‚àÄ i, p i (ind i)) ‚àß Pairwise (Disjoint on fun i => s i (ind i)) := by
  rcases hd.exists_mem_filter_of_disjoint with ‚ü®t, htl, hd‚ü©
  choose ind hp ht using fun i => (h i).mem_iff.1 (htl i)
  exact ‚ü®ind, hp, hd.mono fun i j hij => hij.mono (ht _) (ht _)‚ü©

theorem _root_.Set.PairwiseDisjoint.exists_mem_filter_basis {I : Type*} {l : I ‚Üí Filter Œ±}
    {Œπ : I ‚Üí Sort*} {p : ‚àÄ i, Œπ i ‚Üí Prop} {s : ‚àÄ i, Œπ i ‚Üí Set Œ±} {S : Set I}
    (hd : S.PairwiseDisjoint l) (hS : S.Finite) (h : ‚àÄ i, (l i).HasBasis (p i) (s i)) :
    ‚àÉ ind : ‚àÄ i, Œπ i, (‚àÄ i, p i (ind i)) ‚àß S.PairwiseDisjoint fun i => s i (ind i) := by
  rcases hd.exists_mem_filter hS with ‚ü®t, htl, hd‚ü©
  choose ind hp ht using fun i => (h i).mem_iff.1 (htl i)
  exact ‚ü®ind, hp, hd.mono ht‚ü©

theorem inf_neBot_iff :
    NeBot (l ‚äì l') ‚Üî ‚àÄ ‚¶És : Set Œ±‚¶Ñ, s ‚àà l ‚Üí ‚àÄ ‚¶És'‚¶Ñ, s' ‚àà l' ‚Üí (s ‚à© s').Nonempty :=
  l.basis_sets.inf_neBot_iff

theorem inf_principal_neBot_iff {s : Set Œ±} : NeBot (l ‚äì ùìü s) ‚Üî ‚àÄ U ‚àà l, (U ‚à© s).Nonempty :=
  l.basis_sets.inf_principal_neBot_iff

theorem mem_iff_inf_principal_compl {f : Filter Œ±} {s : Set Œ±} : s ‚àà f ‚Üî f ‚äì ùìü s·∂ú = ‚ä• := by
  refine not_iff_not.1 ((inf_principal_neBot_iff.trans ?_).symm.trans neBot_iff)
  exact
    ‚ü®fun h hs => by simpa [Set.not_nonempty_empty] using h s hs, fun hs t ht =>
      inter_compl_nonempty_iff.2 fun hts => hs <| mem_of_superset ht hts‚ü©

theorem not_mem_iff_inf_principal_compl {f : Filter Œ±} {s : Set Œ±} : s ‚àâ f ‚Üî NeBot (f ‚äì ùìü s·∂ú) :=
  (not_congr mem_iff_inf_principal_compl).trans neBot_iff.symm

@[simp]
theorem disjoint_principal_right {f : Filter Œ±} {s : Set Œ±} : Disjoint f (ùìü s) ‚Üî s·∂ú ‚àà f := by
  rw [mem_iff_inf_principal_compl, compl_compl, disjoint_iff]

@[simp]
theorem disjoint_principal_left {f : Filter Œ±} {s : Set Œ±} : Disjoint (ùìü s) f ‚Üî s·∂ú ‚àà f := by
  rw [disjoint_comm, disjoint_principal_right]

@[simp 1100] -- Porting note: higher priority for linter
theorem disjoint_principal_principal {s t : Set Œ±} : Disjoint (ùìü s) (ùìü t) ‚Üî Disjoint s t := by
  rw [‚Üê subset_compl_iff_disjoint_left, disjoint_principal_left, mem_principal]

alias ‚ü®_, _root_.Disjoint.filter_principal‚ü© := disjoint_principal_principal

@[simp]
theorem disjoint_pure_pure {x y : Œ±} : Disjoint (pure x : Filter Œ±) (pure y) ‚Üî x ‚â† y := by
  simp only [‚Üê principal_singleton, disjoint_principal_principal, disjoint_singleton]

@[simp]
theorem compl_diagonal_mem_prod {l‚ÇÅ l‚ÇÇ : Filter Œ±} : (diagonal Œ±)·∂ú ‚àà l‚ÇÅ √óÀ¢ l‚ÇÇ ‚Üî Disjoint l‚ÇÅ l‚ÇÇ := by
  simp only [mem_prod_iff, Filter.disjoint_iff, prod_subset_compl_diagonal_iff_disjoint]

-- Porting note: use `‚àÉ i, p i ‚àß _` instead of `‚àÉ i (hi : p i), _`.
theorem HasBasis.disjoint_iff_left (h : l.HasBasis p s) :
    Disjoint l l' ‚Üî ‚àÉ i, p i ‚àß (s i)·∂ú ‚àà l' := by
  simp only [h.disjoint_iff l'.basis_sets, id, ‚Üê disjoint_principal_left,
    (hasBasis_principal _).disjoint_iff l'.basis_sets, true_and, Unique.exists_iff]

-- Porting note: use `‚àÉ i, p i ‚àß _` instead of `‚àÉ i (hi : p i), _`.
theorem HasBasis.disjoint_iff_right (h : l.HasBasis p s) :
    Disjoint l' l ‚Üî ‚àÉ i, p i ‚àß (s i)·∂ú ‚àà l' :=
  disjoint_comm.trans h.disjoint_iff_left

theorem le_iff_forall_inf_principal_compl {f g : Filter Œ±} : f ‚â§ g ‚Üî ‚àÄ V ‚àà g, f ‚äì ùìü V·∂ú = ‚ä• :=
  forall‚ÇÇ_congr fun _ _ => mem_iff_inf_principal_compl

theorem inf_neBot_iff_frequently_left {f g : Filter Œ±} :
    NeBot (f ‚äì g) ‚Üî ‚àÄ {p : Œ± ‚Üí Prop}, (‚àÄ·∂† x in f, p x) ‚Üí ‚àÉ·∂† x in g, p x := by
  simp only [inf_neBot_iff, frequently_iff, and_comm]; rfl

theorem inf_neBot_iff_frequently_right {f g : Filter Œ±} :
    NeBot (f ‚äì g) ‚Üî ‚àÄ {p : Œ± ‚Üí Prop}, (‚àÄ·∂† x in g, p x) ‚Üí ‚àÉ·∂† x in f, p x := by
  rw [inf_comm]
  exact inf_neBot_iff_frequently_left

theorem HasBasis.eq_biInf (h : l.HasBasis p s) : l = ‚®Ö (i) (_ : p i), ùìü (s i) :=
  eq_biInf_of_mem_iff_exists_mem fun {_} => by simp only [h.mem_iff, mem_principal, exists_prop]

theorem HasBasis.eq_iInf (h : l.HasBasis (fun _ => True) s) : l = ‚®Ö i, ùìü (s i) := by
  simpa only [iInf_true] using h.eq_biInf

theorem hasBasis_iInf_principal {s : Œπ ‚Üí Set Œ±} (h : Directed (¬∑ ‚â• ¬∑) s) [Nonempty Œπ] :
    (‚®Ö i, ùìü (s i)).HasBasis (fun _ => True) s :=
  ‚ü®fun t => by
    simpa only [true_and] using mem_iInf_of_directed (h.mono_comp monotone_principal.dual) t‚ü©

/-- If `s : Œπ ‚Üí Set Œ±` is an indexed family of sets, then finite intersections of `s i` form a basis
of `‚®Ö i, ùìü (s i)`. -/
theorem hasBasis_iInf_principal_finite {Œπ : Type*} (s : Œπ ‚Üí Set Œ±) :
    (‚®Ö i, ùìü (s i)).HasBasis (fun t : Set Œπ => t.Finite) fun t => ‚ãÇ i ‚àà t, s i := by
  refine ‚ü®fun U => (mem_iInf_finite _).trans ?_‚ü©
  simp only [iInf_principal_finset, mem_iUnion, mem_principal, exists_prop,
    exists_finite_iff_finset, Finset.set_biInter_coe]

theorem hasBasis_biInf_principal {s : Œ≤ ‚Üí Set Œ±} {S : Set Œ≤} (h : DirectedOn (s ‚Åª¬π'o (¬∑ ‚â• ¬∑)) S)
    (ne : S.Nonempty) : (‚®Ö i ‚àà S, ùìü (s i)).HasBasis (fun i => i ‚àà S) s :=
  ‚ü®fun t => by
    refine mem_biInf_of_directed ?_ ne
    rw [directedOn_iff_directed, ‚Üê directed_comp] at h ‚ä¢
    refine h.mono_comp ?_
    exact fun _ _ => principal_mono.2‚ü©

theorem hasBasis_biInf_principal' {Œπ : Type*} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ±}
    (h : ‚àÄ i, p i ‚Üí ‚àÄ j, p j ‚Üí ‚àÉ k, p k ‚àß s k ‚äÜ s i ‚àß s k ‚äÜ s j) (ne : ‚àÉ i, p i) :
    (‚®Ö (i) (_ : p i), ùìü (s i)).HasBasis p s :=
  Filter.hasBasis_biInf_principal h ne

theorem HasBasis.map (f : Œ± ‚Üí Œ≤) (hl : l.HasBasis p s) : (l.map f).HasBasis p fun i => f '' s i :=
  ‚ü®fun t => by simp only [mem_map, image_subset_iff, hl.mem_iff, preimage]‚ü©

theorem HasBasis.comap (f : Œ≤ ‚Üí Œ±) (hl : l.HasBasis p s) :
    (l.comap f).HasBasis p fun i => f ‚Åª¬π' s i :=
  ‚ü®fun t => by
    simp only [mem_comap', hl.mem_iff]
    refine exists_congr (fun i => Iff.rfl.and ?_)
    exact ‚ü®fun h x hx => h hx rfl, fun h y hy x hx => h <| by rwa [mem_preimage, hx]‚ü©‚ü©

theorem comap_hasBasis (f : Œ± ‚Üí Œ≤) (l : Filter Œ≤) :
    HasBasis (comap f l) (fun s : Set Œ≤ => s ‚àà l) fun s => f ‚Åª¬π' s :=
  ‚ü®fun _ => mem_comap‚ü©

theorem HasBasis.forall_mem_mem (h : HasBasis l p s) {x : Œ±} :
    (‚àÄ t ‚àà l, x ‚àà t) ‚Üî ‚àÄ i, p i ‚Üí x ‚àà s i := by
  simp only [h.mem_iff, exists_imp, and_imp]
  exact ‚ü®fun h i hi => h (s i) i hi Subset.rfl, fun h t i hi ht => ht (h i hi)‚ü©

protected theorem HasBasis.biInf_mem [CompleteLattice Œ≤] {f : Set Œ± ‚Üí Œ≤} (h : HasBasis l p s)
    (hf : Monotone f) : ‚®Ö t ‚àà l, f t = ‚®Ö (i) (_ : p i), f (s i) :=
  le_antisymm (le_iInf‚ÇÇ fun i hi => iInf‚ÇÇ_le (s i) (h.mem_of_mem hi)) <|
    le_iInf‚ÇÇ fun _t ht =>
      let ‚ü®i, hpi, hi‚ü© := h.mem_iff.1 ht
      iInf‚ÇÇ_le_of_le i hpi (hf hi)

protected theorem HasBasis.biInter_mem {f : Set Œ± ‚Üí Set Œ≤} (h : HasBasis l p s) (hf : Monotone f) :
    ‚ãÇ t ‚àà l, f t = ‚ãÇ (i) (_ : p i), f (s i) :=
  h.biInf_mem hf

protected theorem HasBasis.ker (h : HasBasis l p s) : l.ker = ‚ãÇ (i) (_ : p i), s i :=
  l.ker_def.trans <| h.biInter_mem monotone_id

variable {Œπ'' : Type*} [Preorder Œπ''] (l) (s'' : Œπ'' ‚Üí Set Œ±)

/-- `IsAntitoneBasis s` means the image of `s` is a filter basis such that `s` is decreasing. -/
structure IsAntitoneBasis extends IsBasis (fun _ => True) s'' : Prop where
  /-- The sequence of sets is antitone. -/
  protected antitone : Antitone s''

/-- We say that a filter `l` has an antitone basis `s : Œπ ‚Üí Set Œ±`, if `t ‚àà l` if and only if `t`
includes `s i` for some `i`, and `s` is decreasing. -/
structure HasAntitoneBasis (l : Filter Œ±) (s : Œπ'' ‚Üí Set Œ±)
    extends HasBasis l (fun _ => True) s : Prop where
  /-- The sequence of sets is antitone. -/
  protected antitone : Antitone s

protected theorem HasAntitoneBasis.map {l : Filter Œ±} {s : Œπ'' ‚Üí Set Œ±}
    (hf : HasAntitoneBasis l s) (m : Œ± ‚Üí Œ≤) : HasAntitoneBasis (map m l) (m '' s ¬∑) :=
  ‚ü®HasBasis.map _ hf.toHasBasis, fun _ _ h => image_subset _ <| hf.2 h‚ü©

protected theorem HasAntitoneBasis.comap {l : Filter Œ±} {s : Œπ'' ‚Üí Set Œ±}
    (hf : HasAntitoneBasis l s) (m : Œ≤ ‚Üí Œ±) : HasAntitoneBasis (comap m l) (m ‚Åª¬π' s ¬∑) :=
  ‚ü®hf.1.comap _, fun _ _ h ‚Ü¶ preimage_mono (hf.2 h)‚ü©

lemma HasAntitoneBasis.iInf_principal {Œπ : Type*} [Preorder Œπ] [Nonempty Œπ] [IsDirected Œπ (¬∑ ‚â§ ¬∑)]
    {s : Œπ ‚Üí Set Œ±} (hs : Antitone s) : (‚®Ö i, ùìü (s i)).HasAntitoneBasis s :=
  ‚ü®hasBasis_iInf_principal hs.directed_ge, hs‚ü©

end SameType

section TwoTypes

variable {la : Filter Œ±} {pa : Œπ ‚Üí Prop} {sa : Œπ ‚Üí Set Œ±} {lb : Filter Œ≤} {pb : Œπ' ‚Üí Prop}
  {sb : Œπ' ‚Üí Set Œ≤} {f : Œ± ‚Üí Œ≤}

-- Porting note: use `‚àÉ i, p i ‚àß _` instead of `‚àÉ i (hi : p i), _`.
theorem HasBasis.tendsto_left_iff (hla : la.HasBasis pa sa) :
    Tendsto f la lb ‚Üî ‚àÄ t ‚àà lb, ‚àÉ i, pa i ‚àß MapsTo f (sa i) t := by
  simp only [Tendsto, (hla.map f).le_iff, image_subset_iff]
  rfl

theorem HasBasis.tendsto_right_iff (hlb : lb.HasBasis pb sb) :
    Tendsto f la lb ‚Üî ‚àÄ i, pb i ‚Üí ‚àÄ·∂† x in la, f x ‚àà sb i := by
  simp only [Tendsto, hlb.ge_iff, mem_map', Filter.Eventually]

-- Porting note: use `‚àÉ i, p i ‚àß _` instead of `‚àÉ i (hi : p i), _`.
theorem HasBasis.tendsto_iff (hla : la.HasBasis pa sa) (hlb : lb.HasBasis pb sb) :
    Tendsto f la lb ‚Üî ‚àÄ ib, pb ib ‚Üí ‚àÉ ia, pa ia ‚àß ‚àÄ x ‚àà sa ia, f x ‚àà sb ib := by
  simp [hlb.tendsto_right_iff, hla.eventually_iff]

-- Porting note: use `‚àÉ i, p i ‚àß _` instead of `‚àÉ i (hi : p i), _`.
theorem Tendsto.basis_left (H : Tendsto f la lb) (hla : la.HasBasis pa sa) :
    ‚àÄ t ‚àà lb, ‚àÉ i, pa i ‚àß MapsTo f (sa i) t :=
  hla.tendsto_left_iff.1 H

theorem Tendsto.basis_right (H : Tendsto f la lb) (hlb : lb.HasBasis pb sb) :
    ‚àÄ i, pb i ‚Üí ‚àÄ·∂† x in la, f x ‚àà sb i :=
  hlb.tendsto_right_iff.1 H

-- Porting note: use `‚àÉ i, p i ‚àß _` instead of `‚àÉ i (hi : p i), _`.
theorem Tendsto.basis_both (H : Tendsto f la lb) (hla : la.HasBasis pa sa)
    (hlb : lb.HasBasis pb sb) :
    ‚àÄ ib, pb ib ‚Üí ‚àÉ ia, pa ia ‚àß MapsTo f (sa ia) (sb ib) :=
  (hla.tendsto_iff hlb).1 H

theorem HasBasis.prod_pprod (hla : la.HasBasis pa sa) (hlb : lb.HasBasis pb sb) :
    (la √óÀ¢ lb).HasBasis (fun i : PProd Œπ Œπ' => pa i.1 ‚àß pb i.2) fun i => sa i.1 √óÀ¢ sb i.2 :=
  (hla.comap Prod.fst).inf' (hlb.comap Prod.snd)

theorem HasBasis.prod {Œπ Œπ' : Type*} {pa : Œπ ‚Üí Prop} {sa : Œπ ‚Üí Set Œ±} {pb : Œπ' ‚Üí Prop}
    {sb : Œπ' ‚Üí Set Œ≤} (hla : la.HasBasis pa sa) (hlb : lb.HasBasis pb sb) :
    (la √óÀ¢ lb).HasBasis (fun i : Œπ √ó Œπ' => pa i.1 ‚àß pb i.2) fun i => sa i.1 √óÀ¢ sb i.2 :=
  (hla.comap Prod.fst).inf (hlb.comap Prod.snd)

theorem HasBasis.prod_same_index {p : Œπ ‚Üí Prop} {sb : Œπ ‚Üí Set Œ≤} (hla : la.HasBasis p sa)
    (hlb : lb.HasBasis p sb) (h_dir : ‚àÄ {i j}, p i ‚Üí p j ‚Üí ‚àÉ k, p k ‚àß sa k ‚äÜ sa i ‚àß sb k ‚äÜ sb j) :
    (la √óÀ¢ lb).HasBasis p fun i => sa i √óÀ¢ sb i := by
  simp only [hasBasis_iff, (hla.prod_pprod hlb).mem_iff]
  refine fun t => ‚ü®?_, ?_‚ü©
  ¬∑ rintro ‚ü®‚ü®i, j‚ü©, ‚ü®hi, hj‚ü©, hsub : sa i √óÀ¢ sb j ‚äÜ t‚ü©
    rcases h_dir hi hj with ‚ü®k, hk, ki, kj‚ü©
    exact ‚ü®k, hk, (Set.prod_mono ki kj).trans hsub‚ü©
  ¬∑ rintro ‚ü®i, hi, h‚ü©
    exact ‚ü®‚ü®i, i‚ü©, ‚ü®hi, hi‚ü©, h‚ü©

theorem HasBasis.prod_same_index_mono {Œπ : Type*} [LinearOrder Œπ] {p : Œπ ‚Üí Prop} {sa : Œπ ‚Üí Set Œ±}
    {sb : Œπ ‚Üí Set Œ≤} (hla : la.HasBasis p sa) (hlb : lb.HasBasis p sb)
    (hsa : MonotoneOn sa { i | p i }) (hsb : MonotoneOn sb { i | p i }) :
    (la √óÀ¢ lb).HasBasis p fun i => sa i √óÀ¢ sb i :=
  hla.prod_same_index hlb fun {i j} hi hj =>
    have : p (min i j) := min_rec' _ hi hj
    ‚ü®min i j, this, hsa this hi <| min_le_left _ _, hsb this hj <| min_le_right _ _‚ü©

theorem HasBasis.prod_same_index_anti {Œπ : Type*} [LinearOrder Œπ] {p : Œπ ‚Üí Prop} {sa : Œπ ‚Üí Set Œ±}
    {sb : Œπ ‚Üí Set Œ≤} (hla : la.HasBasis p sa) (hlb : lb.HasBasis p sb)
    (hsa : AntitoneOn sa { i | p i }) (hsb : AntitoneOn sb { i | p i }) :
    (la √óÀ¢ lb).HasBasis p fun i => sa i √óÀ¢ sb i :=
  @HasBasis.prod_same_index_mono _ _ _ _ Œπ·µí·µà _ _ _ _ hla hlb hsa.dual_left hsb.dual_left

theorem HasBasis.prod_self (hl : la.HasBasis pa sa) :
    (la √óÀ¢ la).HasBasis pa fun i => sa i √óÀ¢ sa i :=
  hl.prod_same_index hl fun {i j} hi hj => by
    simpa only [exists_prop, subset_inter_iff] using
      hl.mem_iff.1 (inter_mem (hl.mem_of_mem hi) (hl.mem_of_mem hj))

theorem mem_prod_self_iff {s} : s ‚àà la √óÀ¢ la ‚Üî ‚àÉ t ‚àà la, t √óÀ¢ t ‚äÜ s :=
  la.basis_sets.prod_self.mem_iff

lemma eventually_prod_self_iff {r : Œ± ‚Üí Œ± ‚Üí Prop} :
    (‚àÄ·∂† x in la √óÀ¢ la, r x.1 x.2) ‚Üî ‚àÉ t ‚àà la, ‚àÄ x ‚àà t, ‚àÄ y ‚àà t, r x y :=
  mem_prod_self_iff.trans <| by simp only [prod_subset_iff, mem_setOf_eq]

theorem HasAntitoneBasis.prod {Œπ : Type*} [LinearOrder Œπ] {f : Filter Œ±} {g : Filter Œ≤}
    {s : Œπ ‚Üí Set Œ±} {t : Œπ ‚Üí Set Œ≤} (hf : HasAntitoneBasis f s) (hg : HasAntitoneBasis g t) :
    HasAntitoneBasis (f √óÀ¢ g) fun n => s n √óÀ¢ t n :=
  ‚ü®hf.1.prod_same_index_anti hg.1 (hf.2.antitoneOn _) (hg.2.antitoneOn _), hf.2.set_prod hg.2‚ü©

theorem HasBasis.coprod {Œπ Œπ' : Type*} {pa : Œπ ‚Üí Prop} {sa : Œπ ‚Üí Set Œ±} {pb : Œπ' ‚Üí Prop}
    {sb : Œπ' ‚Üí Set Œ≤} (hla : la.HasBasis pa sa) (hlb : lb.HasBasis pb sb) :
    (la.coprod lb).HasBasis (fun i : Œπ √ó Œπ' => pa i.1 ‚àß pb i.2) fun i =>
      Prod.fst ‚Åª¬π' sa i.1 ‚à™ Prod.snd ‚Åª¬π' sb i.2 :=
  (hla.comap Prod.fst).sup (hlb.comap Prod.snd)

end TwoTypes

theorem map_sigma_mk_comap {œÄ : Œ± ‚Üí Type*} {œÄ' : Œ≤ ‚Üí Type*} {f : Œ± ‚Üí Œ≤}
    (hf : Function.Injective f) (g : ‚àÄ a, œÄ a ‚Üí œÄ' (f a)) (a : Œ±) (l : Filter (œÄ' (f a))) :
    map (Sigma.mk a) (comap (g a) l) = comap (Sigma.map f g) (map (Sigma.mk (f a)) l) := by
  refine (((basis_sets _).comap _).map _).eq_of_same_basis ?_
  convert ((basis_sets l).map (Sigma.mk (f a))).comap (Sigma.map f g)
  apply image_sigmaMk_preimage_sigmaMap hf

end Filter

end sort

namespace Filter

variable {Œ± Œ≤ Œ≥ Œπ : Type*} {Œπ' : Sort*}

/-- `IsCountablyGenerated f` means `f = generate s` for some countable `s`. -/
class IsCountablyGenerated (f : Filter Œ±) : Prop where
  /-- There exists a countable set that generates the filter. -/
  out : ‚àÉ s : Set (Set Œ±), s.Countable ‚àß f = generate s

/-- `IsCountableBasis p s` means the image of `s` bounded by `p` is a countable filter basis. -/
structure IsCountableBasis (p : Œπ ‚Üí Prop) (s : Œπ ‚Üí Set Œ±) extends IsBasis p s : Prop where
  /-- The set of `i` that satisfy the predicate `p` is countable. -/
  countable : (setOf p).Countable

/-- We say that a filter `l` has a countable basis `s : Œπ ‚Üí Set Œ±` bounded by `p : Œπ ‚Üí Prop`,
if `t ‚àà l` if and only if `t` includes `s i` for some `i` such that `p i`, and the set
defined by `p` is countable. -/
structure HasCountableBasis (l : Filter Œ±) (p : Œπ ‚Üí Prop) (s : Œπ ‚Üí Set Œ±)
    extends HasBasis l p s : Prop where
  /-- The set of `i` that satisfy the predicate `p` is countable. -/
  countable : (setOf p).Countable

/-- A countable filter basis `B` on a type `Œ±` is a nonempty countable collection of sets of `Œ±`
such that the intersection of two elements of this collection contains some element
of the collection. -/
structure CountableFilterBasis (Œ± : Type*) extends FilterBasis Œ± where
  /-- The set of sets of the filter basis is countable. -/
  countable : sets.Countable

-- For illustration purposes, the countable filter basis defining `(atTop : Filter ‚Ñï)`
instance Nat.inhabitedCountableFilterBasis : Inhabited (CountableFilterBasis ‚Ñï) :=
  ‚ü®‚ü®default, countable_range fun n => Ici n‚ü©‚ü©

theorem HasCountableBasis.isCountablyGenerated {f : Filter Œ±} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ±}
    (h : f.HasCountableBasis p s) : f.IsCountablyGenerated :=
  ‚ü®‚ü®{ t | ‚àÉ i, p i ‚àß s i = t }, h.countable.image s, h.toHasBasis.eq_generate‚ü©‚ü©

theorem HasBasis.isCountablyGenerated [Countable Œπ] {f : Filter Œ±} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ±}
    (h : f.HasBasis p s) : f.IsCountablyGenerated :=
  HasCountableBasis.isCountablyGenerated ‚ü®h, to_countable _‚ü©

theorem antitone_seq_of_seq (s : ‚Ñï ‚Üí Set Œ±) :
    ‚àÉ t : ‚Ñï ‚Üí Set Œ±, Antitone t ‚àß ‚®Ö i, ùìü (s i) = ‚®Ö i, ùìü (t i) := by
  use fun n => ‚ãÇ m ‚â§ n, s m; constructor
  ¬∑ exact fun i j hij => biInter_mono (Iic_subset_Iic.2 hij) fun n _ => Subset.rfl
  apply le_antisymm <;> rw [le_iInf_iff] <;> intro i
  ¬∑ rw [le_principal_iff]
    refine (biInter_mem (finite_le_nat _)).2 fun j _ => ?_
    exact mem_iInf_of_mem j (mem_principal_self _)
  ¬∑ refine iInf_le_of_le i (principal_mono.2 <| iInter‚ÇÇ_subset i ?_)
    rfl

theorem countable_biInf_eq_iInf_seq [CompleteLattice Œ±] {B : Set Œπ} (Bcbl : B.Countable)
    (Bne : B.Nonempty) (f : Œπ ‚Üí Œ±) : ‚àÉ x : ‚Ñï ‚Üí Œπ, ‚®Ö t ‚àà B, f t = ‚®Ö i, f (x i) :=
  let ‚ü®g, hg‚ü© := Bcbl.exists_eq_range Bne
  ‚ü®g, hg.symm ‚ñ∏ iInf_range‚ü©

theorem countable_biInf_eq_iInf_seq' [CompleteLattice Œ±] {B : Set Œπ} (Bcbl : B.Countable)
    (f : Œπ ‚Üí Œ±) {i‚ÇÄ : Œπ} (h : f i‚ÇÄ = ‚ä§) : ‚àÉ x : ‚Ñï ‚Üí Œπ, ‚®Ö t ‚àà B, f t = ‚®Ö i, f (x i) := by
  rcases B.eq_empty_or_nonempty with hB | Bnonempty
  ¬∑ rw [hB, iInf_emptyset]
    use fun _ => i‚ÇÄ
    simp [h]
  ¬∑ exact countable_biInf_eq_iInf_seq Bcbl Bnonempty f

theorem countable_biInf_principal_eq_seq_iInf {B : Set (Set Œ±)} (Bcbl : B.Countable) :
    ‚àÉ x : ‚Ñï ‚Üí Set Œ±, ‚®Ö t ‚àà B, ùìü t = ‚®Ö i, ùìü (x i) :=
  countable_biInf_eq_iInf_seq' Bcbl ùìü principal_univ

section IsCountablyGenerated

protected theorem HasAntitoneBasis.mem_iff [Preorder Œπ] {l : Filter Œ±} {s : Œπ ‚Üí Set Œ±}
    (hs : l.HasAntitoneBasis s) {t : Set Œ±} : t ‚àà l ‚Üî ‚àÉ i, s i ‚äÜ t :=
  hs.toHasBasis.mem_iff.trans <| by simp only [exists_prop, true_and]

protected theorem HasAntitoneBasis.mem [Preorder Œπ] {l : Filter Œ±} {s : Œπ ‚Üí Set Œ±}
    (hs : l.HasAntitoneBasis s) (i : Œπ) : s i ‚àà l :=
  hs.toHasBasis.mem_of_mem trivial

theorem HasAntitoneBasis.hasBasis_ge [Preorder Œπ] [IsDirected Œπ (¬∑ ‚â§ ¬∑)] {l : Filter Œ±}
    {s : Œπ ‚Üí Set Œ±} (hs : l.HasAntitoneBasis s) (i : Œπ) : l.HasBasis (fun j => i ‚â§ j) s :=
  hs.1.to_hasBasis (fun j _ => (exists_ge_ge i j).imp fun _k hk => ‚ü®hk.1, hs.2 hk.2‚ü©) fun j _ =>
    ‚ü®j, trivial, Subset.rfl‚ü©

/-- If `f` is countably generated and `f.HasBasis p s`, then `f` admits a decreasing basis
enumerated by natural numbers such that all sets have the form `s i`. More precisely, there is a
sequence `i n` such that `p (i n)` for all `n` and `s (i n)` is a decreasing sequence of sets which
forms a basis of `f`-/
theorem HasBasis.exists_antitone_subbasis {f : Filter Œ±} [h : f.IsCountablyGenerated]
    {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí Set Œ±} (hs : f.HasBasis p s) :
    ‚àÉ x : ‚Ñï ‚Üí Œπ', (‚àÄ i, p (x i)) ‚àß f.HasAntitoneBasis fun i => s (x i) := by
  obtain ‚ü®x', hx'‚ü© : ‚àÉ x : ‚Ñï ‚Üí Set Œ±, f = ‚®Ö i, ùìü (x i) := by
    rcases h with ‚ü®s, hsc, rfl‚ü©
    rw [generate_eq_biInf]
    exact countable_biInf_principal_eq_seq_iInf hsc
  have : ‚àÄ i, x' i ‚àà f := fun i => hx'.symm ‚ñ∏ (iInf_le (fun i => ùìü (x' i)) i) (mem_principal_self _)
  let x : ‚Ñï ‚Üí { i : Œπ' // p i } := fun n =>
    Nat.recOn n (hs.index _ <| this 0) fun n xn =>
      hs.index _ <| inter_mem (this <| n + 1) (hs.mem_of_mem xn.2)
  have x_anti : Antitone fun i => s (x i).1 :=
    antitone_nat_of_succ_le fun i => (hs.set_index_subset _).trans inter_subset_right
  have x_subset : ‚àÄ i, s (x i).1 ‚äÜ x' i := by
    rintro (_ | i)
    exacts [hs.set_index_subset _, (hs.set_index_subset _).trans inter_subset_left]
  refine ‚ü®fun i => (x i).1, fun i => (x i).2, ?_‚ü©
  have : (‚®Ö i, ùìü (s (x i).1)).HasAntitoneBasis fun i => s (x i).1 := .iInf_principal x_anti
  convert this
  exact
    le_antisymm (le_iInf fun i => le_principal_iff.2 <| by cases i <;> apply hs.set_index_mem)
      (hx'.symm ‚ñ∏
        le_iInf fun i => le_principal_iff.2 <| this.1.mem_iff.2 ‚ü®i, trivial, x_subset i‚ü©)

/-- A countably generated filter admits a basis formed by an antitone sequence of sets. -/
theorem exists_antitone_basis (f : Filter Œ±) [f.IsCountablyGenerated] :
    ‚àÉ x : ‚Ñï ‚Üí Set Œ±, f.HasAntitoneBasis x :=
  let ‚ü®x, _, hx‚ü© := f.basis_sets.exists_antitone_subbasis
  ‚ü®x, hx‚ü©

theorem exists_antitone_seq (f : Filter Œ±) [f.IsCountablyGenerated] :
    ‚àÉ x : ‚Ñï ‚Üí Set Œ±, Antitone x ‚àß ‚àÄ {s}, s ‚àà f ‚Üî ‚àÉ i, x i ‚äÜ s :=
  let ‚ü®x, hx‚ü© := f.exists_antitone_basis
  ‚ü®x, hx.antitone, by simp [hx.1.mem_iff]‚ü©

instance Inf.isCountablyGenerated (f g : Filter Œ±) [IsCountablyGenerated f]
    [IsCountablyGenerated g] : IsCountablyGenerated (f ‚äì g) := by
  rcases f.exists_antitone_basis with ‚ü®s, hs‚ü©
  rcases g.exists_antitone_basis with ‚ü®t, ht‚ü©
  exact HasCountableBasis.isCountablyGenerated ‚ü®hs.1.inf ht.1, Set.to_countable _‚ü©

instance map.isCountablyGenerated (l : Filter Œ±) [l.IsCountablyGenerated] (f : Œ± ‚Üí Œ≤) :
    (map f l).IsCountablyGenerated :=
  let ‚ü®_x, hxl‚ü© := l.exists_antitone_basis
  (hxl.map _).isCountablyGenerated

instance comap.isCountablyGenerated (l : Filter Œ≤) [l.IsCountablyGenerated] (f : Œ± ‚Üí Œ≤) :
    (comap f l).IsCountablyGenerated :=
  let ‚ü®_x, hxl‚ü© := l.exists_antitone_basis
  (hxl.comap _).isCountablyGenerated

instance Sup.isCountablyGenerated (f g : Filter Œ±) [IsCountablyGenerated f]
    [IsCountablyGenerated g] : IsCountablyGenerated (f ‚äî g) := by
  rcases f.exists_antitone_basis with ‚ü®s, hs‚ü©
  rcases g.exists_antitone_basis with ‚ü®t, ht‚ü©
  exact HasCountableBasis.isCountablyGenerated ‚ü®hs.1.sup ht.1, Set.to_countable _‚ü©

instance prod.isCountablyGenerated (la : Filter Œ±) (lb : Filter Œ≤) [IsCountablyGenerated la]
    [IsCountablyGenerated lb] : IsCountablyGenerated (la √óÀ¢ lb) :=
  Filter.Inf.isCountablyGenerated _ _

instance coprod.isCountablyGenerated (la : Filter Œ±) (lb : Filter Œ≤) [IsCountablyGenerated la]
    [IsCountablyGenerated lb] : IsCountablyGenerated (la.coprod lb) :=
  Filter.Sup.isCountablyGenerated _ _

end IsCountablyGenerated

theorem isCountablyGenerated_seq [Countable Œπ'] (x : Œπ' ‚Üí Set Œ±) :
    IsCountablyGenerated (‚®Ö i, ùìü (x i)) := by
  use range x, countable_range x
  rw [generate_eq_biInf, iInf_range]

theorem isCountablyGenerated_of_seq {f : Filter Œ±} (h : ‚àÉ x : ‚Ñï ‚Üí Set Œ±, f = ‚®Ö i, ùìü (x i)) :
    f.IsCountablyGenerated := by
  rcases h with ‚ü®x, rfl‚ü©
  apply isCountablyGenerated_seq

theorem isCountablyGenerated_biInf_principal {B : Set (Set Œ±)} (h : B.Countable) :
    IsCountablyGenerated (‚®Ö s ‚àà B, ùìü s) :=
  isCountablyGenerated_of_seq (countable_biInf_principal_eq_seq_iInf h)

theorem isCountablyGenerated_iff_exists_antitone_basis {f : Filter Œ±} :
    IsCountablyGenerated f ‚Üî ‚àÉ x : ‚Ñï ‚Üí Set Œ±, f.HasAntitoneBasis x := by
  constructor
  ¬∑ intro h
    exact f.exists_antitone_basis
  ¬∑ rintro ‚ü®x, h‚ü©
    rw [h.1.eq_iInf]
    exact isCountablyGenerated_seq x

@[instance]
theorem isCountablyGenerated_principal (s : Set Œ±) : IsCountablyGenerated (ùìü s) :=
  isCountablyGenerated_of_seq ‚ü®fun _ => s, iInf_const.symm‚ü©

@[instance]
theorem isCountablyGenerated_pure (a : Œ±) : IsCountablyGenerated (pure a) := by
  rw [‚Üê principal_singleton]
  exact isCountablyGenerated_principal _

@[instance]
theorem isCountablyGenerated_bot : IsCountablyGenerated (‚ä• : Filter Œ±) :=
  @principal_empty Œ± ‚ñ∏ isCountablyGenerated_principal _

@[instance]
theorem isCountablyGenerated_top : IsCountablyGenerated (‚ä§ : Filter Œ±) :=
  @principal_univ Œ± ‚ñ∏ isCountablyGenerated_principal _

-- Porting note: without explicit `Sort u` and `Type v`, Lean 4 uses `Œπ : Prop`
universe u v

instance iInf.isCountablyGenerated {Œπ : Sort u} {Œ± : Type v} [Countable Œπ] (f : Œπ ‚Üí Filter Œ±)
    [‚àÄ i, IsCountablyGenerated (f i)] : IsCountablyGenerated (‚®Ö i, f i) := by
  choose s hs using fun i => exists_antitone_basis (f i)
  rw [‚Üê PLift.down_surjective.iInf_comp]
  refine HasCountableBasis.isCountablyGenerated ‚ü®hasBasis_iInf fun n => (hs _).1, ?_‚ü©
  refine (countable_range <| Sigma.map ((‚Üë) : Finset (PLift Œπ) ‚Üí Set (PLift Œπ)) fun _ => id).mono ?_
  rintro ‚ü®I, f‚ü© ‚ü®hI, -‚ü©
  lift I to Finset (PLift Œπ) using hI
  exact ‚ü®‚ü®I, f‚ü©, rfl‚ü©

end Filter
