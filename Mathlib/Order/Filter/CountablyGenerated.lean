/-
Copyright (c) 2019 Gabriel Ebner. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Gabriel Ebner, Yury Kudryashov, Patrick Massot
-/
import Mathlib.Data.Set.Countable
import Mathlib.Order.Filter.Bases.Finite

/-!
# Countably generated filters

In this file we define a typeclass `Filter.IsCountablyGenerated`
saying that a filter is generated by a countable family of sets.

We also define predicates `Filter.IsCountableBasis` and `Filter.HasCountableBasis`
saying that a specific family of sets is a countable basis.
-/

open Set

namespace Filter

variable {Î± Î² Î³ Î¹ : Type*} {Î¹' : Sort*}

/-- `IsCountablyGenerated f` means `f = generate s` for some countable `s`. -/
class IsCountablyGenerated (f : Filter Î±) : Prop where
  /-- There exists a countable set that generates the filter. -/
  out : âˆƒ s : Set (Set Î±), s.Countable âˆ§ f = generate s

/-- `IsCountableBasis p s` means the image of `s` bounded by `p` is a countable filter basis. -/
structure IsCountableBasis (p : Î¹ â†’ Prop) (s : Î¹ â†’ Set Î±) : Prop extends IsBasis p s where
  /-- The set of `i` that satisfy the predicate `p` is countable. -/
  countable : (setOf p).Countable

/-- We say that a filter `l` has a countable basis `s : Î¹ â†’ Set Î±` bounded by `p : Î¹ â†’ Prop`,
if `t âˆˆ l` if and only if `t` includes `s i` for some `i` such that `p i`, and the set
defined by `p` is countable. -/
structure HasCountableBasis (l : Filter Î±) (p : Î¹ â†’ Prop) (s : Î¹ â†’ Set Î±) : Prop
    extends HasBasis l p s where
  /-- The set of `i` that satisfy the predicate `p` is countable. -/
  countable : (setOf p).Countable

/-- A countable filter basis `B` on a type `Î±` is a nonempty countable collection of sets of `Î±`
such that the intersection of two elements of this collection contains some element
of the collection. -/
structure CountableFilterBasis (Î± : Type*) extends FilterBasis Î± where
  /-- The set of sets of the filter basis is countable. -/
  countable : sets.Countable

-- For illustration purposes, the countable filter basis defining `(atTop : Filter â„•)`
instance Nat.inhabitedCountableFilterBasis : Inhabited (CountableFilterBasis â„•) :=
  âŸ¨âŸ¨default, countable_range fun n => Ici nâŸ©âŸ©

theorem HasCountableBasis.isCountablyGenerated {f : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±}
    (h : f.HasCountableBasis p s) : f.IsCountablyGenerated :=
  âŸ¨âŸ¨{ t | âˆƒ i, p i âˆ§ s i = t }, h.countable.image s, h.toHasBasis.eq_generateâŸ©âŸ©

theorem HasBasis.isCountablyGenerated [Countable Î¹] {f : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±}
    (h : f.HasBasis p s) : f.IsCountablyGenerated :=
  HasCountableBasis.isCountablyGenerated âŸ¨h, to_countable _âŸ©

theorem antitone_seq_of_seq (s : â„• â†’ Set Î±) :
    âˆƒ t : â„• â†’ Set Î±, Antitone t âˆ§ â¨… i, ğ“Ÿ (s i) = â¨… i, ğ“Ÿ (t i) := by
  use fun n => â‹‚ m â‰¤ n, s m; constructor
  Â· exact fun i j hij => biInter_mono (Iic_subset_Iic.2 hij) fun n _ => Subset.rfl
  apply le_antisymm <;> rw [le_iInf_iff] <;> intro i
  Â· rw [le_principal_iff]
    refine (biInter_mem (finite_le_nat _)).2 fun j _ => ?_
    exact mem_iInf_of_mem j (mem_principal_self _)
  Â· refine iInf_le_of_le i (principal_mono.2 <| iInterâ‚‚_subset i ?_)
    rfl

theorem countable_biInf_eq_iInf_seq [CompleteLattice Î±] {B : Set Î¹} (Bcbl : B.Countable)
    (Bne : B.Nonempty) (f : Î¹ â†’ Î±) : âˆƒ x : â„• â†’ Î¹, â¨… t âˆˆ B, f t = â¨… i, f (x i) :=
  let âŸ¨g, hgâŸ© := Bcbl.exists_eq_range Bne
  âŸ¨g, hg.symm â–¸ iInf_rangeâŸ©

theorem countable_biInf_eq_iInf_seq' [CompleteLattice Î±] {B : Set Î¹} (Bcbl : B.Countable)
    (f : Î¹ â†’ Î±) {iâ‚€ : Î¹} (h : f iâ‚€ = âŠ¤) : âˆƒ x : â„• â†’ Î¹, â¨… t âˆˆ B, f t = â¨… i, f (x i) := by
  rcases B.eq_empty_or_nonempty with hB | Bnonempty
  Â· rw [hB, iInf_emptyset]
    use fun _ => iâ‚€
    simp [h]
  Â· exact countable_biInf_eq_iInf_seq Bcbl Bnonempty f

theorem countable_biInf_principal_eq_seq_iInf {B : Set (Set Î±)} (Bcbl : B.Countable) :
    âˆƒ x : â„• â†’ Set Î±, â¨… t âˆˆ B, ğ“Ÿ t = â¨… i, ğ“Ÿ (x i) :=
  countable_biInf_eq_iInf_seq' Bcbl ğ“Ÿ principal_univ

section IsCountablyGenerated

protected theorem HasAntitoneBasis.mem_iff [Preorder Î¹] {l : Filter Î±} {s : Î¹ â†’ Set Î±}
    (hs : l.HasAntitoneBasis s) {t : Set Î±} : t âˆˆ l â†” âˆƒ i, s i âŠ† t :=
  hs.toHasBasis.mem_iff.trans <| by simp only [exists_prop, true_and]

protected theorem HasAntitoneBasis.mem [Preorder Î¹] {l : Filter Î±} {s : Î¹ â†’ Set Î±}
    (hs : l.HasAntitoneBasis s) (i : Î¹) : s i âˆˆ l :=
  hs.toHasBasis.mem_of_mem trivial

theorem HasAntitoneBasis.hasBasis_ge [Preorder Î¹] [IsDirected Î¹ (Â· â‰¤ Â·)] {l : Filter Î±}
    {s : Î¹ â†’ Set Î±} (hs : l.HasAntitoneBasis s) (i : Î¹) : l.HasBasis (fun j => i â‰¤ j) s :=
  hs.1.to_hasBasis (fun j _ => (exists_ge_ge i j).imp fun _k hk => âŸ¨hk.1, hs.2 hk.2âŸ©) fun j _ =>
    âŸ¨j, trivial, Subset.rflâŸ©

/-- If `f` is countably generated and `f.HasBasis p s`, then `f` admits a decreasing basis
enumerated by natural numbers such that all sets have the form `s i`. More precisely, there is a
sequence `i n` such that `p (i n)` for all `n` and `s (i n)` is a decreasing sequence of sets which
forms a basis of `f`. -/
theorem HasBasis.exists_antitone_subbasis {f : Filter Î±} [h : f.IsCountablyGenerated]
    {p : Î¹' â†’ Prop} {s : Î¹' â†’ Set Î±} (hs : f.HasBasis p s) :
    âˆƒ x : â„• â†’ Î¹', (âˆ€ i, p (x i)) âˆ§ f.HasAntitoneBasis fun i => s (x i) := by
  obtain âŸ¨x', hx'âŸ© : âˆƒ x : â„• â†’ Set Î±, f = â¨… i, ğ“Ÿ (x i) := by
    rcases h with âŸ¨s, hsc, rflâŸ©
    rw [generate_eq_biInf]
    exact countable_biInf_principal_eq_seq_iInf hsc
  have : âˆ€ i, x' i âˆˆ f := fun i => hx'.symm â–¸ (iInf_le (fun i => ğ“Ÿ (x' i)) i) (mem_principal_self _)
  let x : â„• â†’ { i : Î¹' // p i } := fun n =>
    Nat.recOn n (hs.index _ <| this 0) fun n xn =>
      hs.index _ <| inter_mem (this <| n + 1) (hs.mem_of_mem xn.2)
  have x_anti : Antitone fun i => s (x i).1 :=
    antitone_nat_of_succ_le fun i => (hs.set_index_subset _).trans inter_subset_right
  have x_subset : âˆ€ i, s (x i).1 âŠ† x' i := by
    rintro (_ | i)
    exacts [hs.set_index_subset _, (hs.set_index_subset _).trans inter_subset_left]
  refine âŸ¨fun i => (x i).1, fun i => (x i).2, ?_âŸ©
  have : (â¨… i, ğ“Ÿ (s (x i).1)).HasAntitoneBasis fun i => s (x i).1 := .iInf_principal x_anti
  convert this
  exact
    le_antisymm (le_iInf fun i => le_principal_iff.2 <| by cases i <;> apply hs.set_index_mem)
      (hx'.symm â–¸
        le_iInf fun i => le_principal_iff.2 <| this.1.mem_iff.2 âŸ¨i, trivial, x_subset iâŸ©)

/-- A countably generated filter admits a basis formed by an antitone sequence of sets. -/
theorem exists_antitone_basis (f : Filter Î±) [f.IsCountablyGenerated] :
    âˆƒ x : â„• â†’ Set Î±, f.HasAntitoneBasis x :=
  let âŸ¨x, _, hxâŸ© := f.basis_sets.exists_antitone_subbasis
  âŸ¨x, hxâŸ©

theorem exists_antitone_seq (f : Filter Î±) [f.IsCountablyGenerated] :
    âˆƒ x : â„• â†’ Set Î±, Antitone x âˆ§ âˆ€ {s}, s âˆˆ f â†” âˆƒ i, x i âŠ† s :=
  let âŸ¨x, hxâŸ© := f.exists_antitone_basis
  âŸ¨x, hx.antitone, by simp [hx.1.mem_iff]âŸ©

instance Inf.isCountablyGenerated (f g : Filter Î±) [IsCountablyGenerated f]
    [IsCountablyGenerated g] : IsCountablyGenerated (f âŠ“ g) := by
  rcases f.exists_antitone_basis with âŸ¨s, hsâŸ©
  rcases g.exists_antitone_basis with âŸ¨t, htâŸ©
  exact HasCountableBasis.isCountablyGenerated âŸ¨hs.1.inf ht.1, Set.to_countable _âŸ©

instance map.isCountablyGenerated (l : Filter Î±) [l.IsCountablyGenerated] (f : Î± â†’ Î²) :
    (map f l).IsCountablyGenerated :=
  let âŸ¨_x, hxlâŸ© := l.exists_antitone_basis
  (hxl.map _).isCountablyGenerated

instance comap.isCountablyGenerated (l : Filter Î²) [l.IsCountablyGenerated] (f : Î± â†’ Î²) :
    (comap f l).IsCountablyGenerated :=
  let âŸ¨_x, hxlâŸ© := l.exists_antitone_basis
  (hxl.comap _).isCountablyGenerated

instance Sup.isCountablyGenerated (f g : Filter Î±) [IsCountablyGenerated f]
    [IsCountablyGenerated g] : IsCountablyGenerated (f âŠ” g) := by
  rcases f.exists_antitone_basis with âŸ¨s, hsâŸ©
  rcases g.exists_antitone_basis with âŸ¨t, htâŸ©
  exact HasCountableBasis.isCountablyGenerated âŸ¨hs.1.sup ht.1, Set.to_countable _âŸ©

instance prod.isCountablyGenerated (la : Filter Î±) (lb : Filter Î²) [IsCountablyGenerated la]
    [IsCountablyGenerated lb] : IsCountablyGenerated (la Ã—Ë¢ lb) :=
  Filter.Inf.isCountablyGenerated _ _

instance coprod.isCountablyGenerated (la : Filter Î±) (lb : Filter Î²) [IsCountablyGenerated la]
    [IsCountablyGenerated lb] : IsCountablyGenerated (la.coprod lb) :=
  Filter.Sup.isCountablyGenerated _ _

end IsCountablyGenerated

theorem isCountablyGenerated_seq [Countable Î¹'] (x : Î¹' â†’ Set Î±) :
    IsCountablyGenerated (â¨… i, ğ“Ÿ (x i)) := by
  use range x, countable_range x
  rw [generate_eq_biInf, iInf_range]

theorem isCountablyGenerated_of_seq {f : Filter Î±} (h : âˆƒ x : â„• â†’ Set Î±, f = â¨… i, ğ“Ÿ (x i)) :
    f.IsCountablyGenerated := by
  rcases h with âŸ¨x, rflâŸ©
  apply isCountablyGenerated_seq

theorem isCountablyGenerated_biInf_principal {B : Set (Set Î±)} (h : B.Countable) :
    IsCountablyGenerated (â¨… s âˆˆ B, ğ“Ÿ s) :=
  isCountablyGenerated_of_seq (countable_biInf_principal_eq_seq_iInf h)

theorem isCountablyGenerated_iff_exists_antitone_basis {f : Filter Î±} :
    IsCountablyGenerated f â†” âˆƒ x : â„• â†’ Set Î±, f.HasAntitoneBasis x := by
  constructor
  Â· intro h
    exact f.exists_antitone_basis
  Â· rintro âŸ¨x, hâŸ©
    rw [h.1.eq_iInf]
    exact isCountablyGenerated_seq x

@[instance]
theorem isCountablyGenerated_principal (s : Set Î±) : IsCountablyGenerated (ğ“Ÿ s) :=
  isCountablyGenerated_of_seq âŸ¨fun _ => s, iInf_const.symmâŸ©

@[instance]
theorem isCountablyGenerated_pure (a : Î±) : IsCountablyGenerated (pure a) := by
  rw [â† principal_singleton]
  exact isCountablyGenerated_principal _

@[instance]
theorem isCountablyGenerated_bot : IsCountablyGenerated (âŠ¥ : Filter Î±) :=
  @principal_empty Î± â–¸ isCountablyGenerated_principal _

@[instance]
theorem isCountablyGenerated_top : IsCountablyGenerated (âŠ¤ : Filter Î±) :=
  @principal_univ Î± â–¸ isCountablyGenerated_principal _

instance iInf.isCountablyGenerated {Î¹ : Sort*} {Î± : Type*} [Countable Î¹] (f : Î¹ â†’ Filter Î±)
    [âˆ€ i, IsCountablyGenerated (f i)] : IsCountablyGenerated (â¨… i, f i) := by
  choose s hs using fun i => exists_antitone_basis (f i)
  rw [â† PLift.down_surjective.iInf_comp]
  refine HasCountableBasis.isCountablyGenerated âŸ¨.iInf fun n => (hs _).1, ?_âŸ©
  refine (countable_range <| Sigma.map ((â†‘) : Finset (PLift Î¹) â†’ Set (PLift Î¹)) fun _ => id).mono ?_
  rintro âŸ¨I, fâŸ© âŸ¨hI, -âŸ©
  lift I to Finset (PLift Î¹) using hI
  exact âŸ¨âŸ¨I, fâŸ©, rflâŸ©

instance pi.isCountablyGenerated {Î¹ : Type*} {Î± : Î¹ â†’ Type*} [Countable Î¹]
    (f : âˆ€ i, Filter (Î± i)) [âˆ€ i, IsCountablyGenerated (f i)] : IsCountablyGenerated (pi f) :=
  iInf.isCountablyGenerated _

end Filter
