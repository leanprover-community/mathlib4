/-
Copyright (c) 2020 David WÃ¤rn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David WÃ¤rn
-/
import Mathlib.Data.Finset.Lattice.Fold
import Mathlib.Logic.Encodable.Basic
import Mathlib.Order.Atoms
import Mathlib.Order.Cofinal
import Mathlib.Order.UpperLower.Principal

/-!
# Order ideals, cofinal sets, and the Rasiowaâ€“Sikorski lemma

## Main definitions

Throughout this file, `P` is at least a preorder, but some sections require more
structure, such as a bottom element, a top element, or a join-semilattice structure.
- `Order.Ideal P`: the type of nonempty, upward directed, and downward closed subsets of `P`.
  Dual to the notion of a filter on a preorder.
- `Order.IsIdeal I`: a predicate for when a `Set P` is an ideal.
- `Order.Ideal.principal p`: the principal ideal generated by `p : P`.
- `Order.Ideal.IsProper I`: a predicate for proper ideals.
  Dual to the notion of a proper filter.
- `Order.Ideal.IsMaximal I`: a predicate for maximal ideals.
  Dual to the notion of an ultrafilter.
- `Order.Cofinal P`: the type of subsets of `P` containing arbitrarily large elements.
  Dual to the notion of 'dense set' used in forcing.
- `Order.idealOfCofinals p ğ’Ÿ`, where `p : P`, and `ğ’Ÿ` is a countable family of cofinal
  subsets of `P`: an ideal in `P` which contains `p` and intersects every set in `ğ’Ÿ`. (This a form
  of the Rasiowaâ€“Sikorski lemma.)

## References

- <https://en.wikipedia.org/wiki/Ideal_(order_theory)>
- <https://en.wikipedia.org/wiki/Cofinal_(mathematics)>
- <https://en.wikipedia.org/wiki/Rasiowa%E2%80%93Sikorski_lemma>

Note that for the Rasiowaâ€“Sikorski lemma, Wikipedia uses the opposite ordering on `P`,
in line with most presentations of forcing.

## Tags

ideal, cofinal, dense, countable, generic

-/


open Function Set

namespace Order

variable {P : Type*}

/-- An ideal on an order `P` is a subset of `P` that is
  - nonempty
  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)
  - downward closed (any element less than an element of the ideal is in the ideal). -/
structure Ideal (P) [LE P] extends LowerSet P where
  /-- The ideal is nonempty. -/
  nonempty' : carrier.Nonempty
  /-- The ideal is upward directed. -/
  directed' : DirectedOn (Â· â‰¤ Â·) carrier

-- TODO: remove this configuration and use the default configuration.
-- We keep this to be consistent with Lean 3.
initialize_simps_projections Ideal (+toLowerSet, -carrier)

/-- A subset of a preorder `P` is an ideal if it is
  - nonempty
  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)
  - downward closed (any element less than an element of the ideal is in the ideal). -/
@[mk_iff]
structure IsIdeal {P} [LE P] (I : Set P) : Prop where
  /-- The ideal is downward closed. -/
  IsLowerSet : IsLowerSet I
  /-- The ideal is nonempty. -/
  Nonempty : I.Nonempty
  /-- The ideal is upward directed. -/
  Directed : DirectedOn (Â· â‰¤ Â·) I

/-- Create an element of type `Order.Ideal` from a set satisfying the predicate
`Order.IsIdeal`. -/
def IsIdeal.toIdeal [LE P] {I : Set P} (h : IsIdeal I) : Ideal P :=
  âŸ¨âŸ¨I, h.IsLowerSetâŸ©, h.Nonempty, h.DirectedâŸ©

namespace Ideal

section LE

variable [LE P]

section

variable {I s t : Ideal P} {x : P}

theorem toLowerSet_injective : Injective (toLowerSet : Ideal P â†’ LowerSet P) := fun s t _ â†¦ by
  cases s
  cases t
  congr

instance : SetLike (Ideal P) P where
  coe s := s.carrier
  coe_injective' _ _ h := toLowerSet_injective <| SetLike.coe_injective h

@[ext]
theorem ext {s t : Ideal P} : (s : Set P) = t â†’ s = t :=
  SetLike.ext'

@[simp]
theorem carrier_eq_coe (s : Ideal P) : s.carrier = s :=
  rfl

@[simp]
theorem coe_toLowerSet (s : Ideal P) : (s.toLowerSet : Set P) = s :=
  rfl

protected theorem lower (s : Ideal P) : IsLowerSet (s : Set P) :=
  s.lower'

protected theorem nonempty (s : Ideal P) : (s : Set P).Nonempty :=
  s.nonempty'

protected theorem directed (s : Ideal P) : DirectedOn (Â· â‰¤ Â·) (s : Set P) :=
  s.directed'

protected theorem isIdeal (s : Ideal P) : IsIdeal (s : Set P) :=
  âŸ¨s.lower, s.nonempty, s.directedâŸ©

theorem mem_compl_of_ge {x y : P} : x â‰¤ y â†’ x âˆˆ (I : Set P)á¶œ â†’ y âˆˆ (I : Set P)á¶œ := fun h â†¦
  mt <| I.lower h

/-- The partial ordering by subset inclusion, inherited from `Set P`. -/
instance instPartialOrderIdeal : PartialOrder (Ideal P) :=
  PartialOrder.lift SetLike.coe SetLike.coe_injective

theorem coe_subset_coe : (s : Set P) âŠ† t â†” s â‰¤ t :=
  Iff.rfl

theorem coe_ssubset_coe : (s : Set P) âŠ‚ t â†” s < t :=
  Iff.rfl

@[trans]
theorem mem_of_mem_of_le {x : P} {I J : Ideal P} : x âˆˆ I â†’ I â‰¤ J â†’ x âˆˆ J :=
  @Set.mem_of_mem_of_subset P x I J

/-- A proper ideal is one that is not the whole set.
Note that the whole set might not be an ideal. -/
@[mk_iff]
class IsProper (I : Ideal P) : Prop where
  /-- This ideal is not the whole set. -/
  ne_univ : (I : Set P) â‰  univ

theorem isProper_of_notMem {I : Ideal P} {p : P} (notMem : p âˆ‰ I) : IsProper I :=
  âŸ¨fun hp â†¦ by
    have := mem_univ p
    rw [â† hp] at this
    exact notMem thisâŸ©

@[deprecated (since := "2025-05-23")] alias isProper_of_not_mem := isProper_of_notMem

/-- An ideal is maximal if it is maximal in the collection of proper ideals.

Note that `IsCoatom` is less general because ideals only have a top element when `P` is directed
and nonempty. -/
@[mk_iff]
class IsMaximal (I : Ideal P) : Prop extends IsProper I where
  /-- This ideal is maximal in the collection of proper ideals. -/
  maximal_proper : âˆ€ â¦ƒJ : Ideal Pâ¦„, I < J â†’ (J : Set P) = univ

theorem inter_nonempty [IsDirected P (Â· â‰¥ Â·)] (I J : Ideal P) : (I âˆ© J : Set P).Nonempty := by
  obtain âŸ¨a, haâŸ© := I.nonempty
  obtain âŸ¨b, hbâŸ© := J.nonempty
  obtain âŸ¨c, hac, hbcâŸ© := exists_le_le a b
  exact âŸ¨c, I.lower hac ha, J.lower hbc hbâŸ©

end

section Directed

variable [IsDirected P (Â· â‰¤ Â·)] [Nonempty P] {I : Ideal P}

/-- In a directed and nonempty order, the top ideal of a is `univ`. -/
instance : OrderTop (Ideal P) where
  top := âŸ¨âŠ¤, univ_nonempty, directedOn_univâŸ©
  le_top _ _ _ := LowerSet.mem_top

@[simp]
theorem top_toLowerSet : (âŠ¤ : Ideal P).toLowerSet = âŠ¤ :=
  rfl

@[simp]
theorem coe_top : ((âŠ¤ : Ideal P) : Set P) = univ :=
  rfl

theorem isProper_of_ne_top (ne_top : I â‰  âŠ¤) : IsProper I :=
  âŸ¨fun h â†¦ ne_top <| ext hâŸ©

theorem IsProper.ne_top (_ : IsProper I) : I â‰  âŠ¤ :=
  fun h â†¦ IsProper.ne_univ <| congr_arg SetLike.coe h

theorem _root_.IsCoatom.isProper (hI : IsCoatom I) : IsProper I :=
  isProper_of_ne_top hI.1

theorem isProper_iff_ne_top : IsProper I â†” I â‰  âŠ¤ :=
  âŸ¨fun h â†¦ h.ne_top, fun h â†¦ isProper_of_ne_top hâŸ©

theorem IsMaximal.isCoatom (_ : IsMaximal I) : IsCoatom I :=
  âŸ¨IsMaximal.toIsProper.ne_top, fun _ h â†¦ ext <| IsMaximal.maximal_proper hâŸ©

theorem IsMaximal.isCoatom' [IsMaximal I] : IsCoatom I :=
  IsMaximal.isCoatom â€¹_â€º

theorem _root_.IsCoatom.isMaximal (hI : IsCoatom I) : IsMaximal I :=
  { IsCoatom.isProper hI with maximal_proper := fun _ hJ â†¦ by simp [hI.2 _ hJ] }

theorem isMaximal_iff_isCoatom : IsMaximal I â†” IsCoatom I :=
  âŸ¨fun h â†¦ h.isCoatom, fun h â†¦ IsCoatom.isMaximal hâŸ©

end Directed

section OrderBot

variable [OrderBot P]

@[simp]
theorem bot_mem (s : Ideal P) : âŠ¥ âˆˆ s :=
  s.lower bot_le s.nonempty'.some_mem

end OrderBot

section OrderTop

variable [OrderTop P] {I : Ideal P}

theorem top_of_top_mem (h : âŠ¤ âˆˆ I) : I = âŠ¤ := by
  ext
  exact iff_of_true (I.lower le_top h) trivial

theorem IsProper.top_notMem (hI : IsProper I) : âŠ¤ âˆ‰ I := fun h â†¦ hI.ne_top <| top_of_top_mem h

@[deprecated (since := "2025-05-23")] alias IsProper.top_not_mem := IsProper.top_notMem

end OrderTop

end LE

section Preorder

variable [Preorder P]

section

variable {I : Ideal P} {x y : P}

/-- The smallest ideal containing a given element. -/
@[simps]
def principal (p : P) : Ideal P where
  toLowerSet := LowerSet.Iic p
  nonempty' := nonempty_Iic
  directed' _ hx _ hy := âŸ¨p, le_rfl, hx, hyâŸ©

instance [Inhabited P] : Inhabited (Ideal P) :=
  âŸ¨Ideal.principal defaultâŸ©

@[simp]
theorem principal_le_iff : principal x â‰¤ I â†” x âˆˆ I :=
  âŸ¨fun h â†¦ h le_rfl, fun hx _ hy â†¦ I.lower hy hxâŸ©

@[simp]
theorem mem_principal : x âˆˆ principal y â†” x â‰¤ y :=
  Iff.rfl

lemma mem_principal_self : x âˆˆ principal x :=
  mem_principal.2 (le_refl x)

end

section OrderBot

variable [OrderBot P]

/-- There is a bottom ideal when `P` has a bottom element. -/
instance : OrderBot (Ideal P) where
  bot := principal âŠ¥
  bot_le := by simp

@[simp]
theorem principal_bot : principal (âŠ¥ : P) = âŠ¥ :=
  rfl

end OrderBot

section OrderTop

variable [OrderTop P]

@[simp]
theorem principal_top : principal (âŠ¤ : P) = âŠ¤ :=
  toLowerSet_injective <| LowerSet.Iic_top

end OrderTop

end Preorder

section SemilatticeSup

variable [SemilatticeSup P] {x y : P} {I s : Ideal P}

/-- A specific witness of `I.directed` when `P` has joins. -/
theorem sup_mem (hx : x âˆˆ s) (hy : y âˆˆ s) : x âŠ” y âˆˆ s :=
  let âŸ¨_, hz, hx, hyâŸ© := s.directed x hx y hy
  s.lower (sup_le hx hy) hz

@[simp]
theorem sup_mem_iff : x âŠ” y âˆˆ I â†” x âˆˆ I âˆ§ y âˆˆ I :=
  âŸ¨fun h â†¦ âŸ¨I.lower le_sup_left h, I.lower le_sup_right hâŸ©, fun h â†¦ sup_mem h.1 h.2âŸ©

@[simp]
lemma finsetSup_mem_iff {P : Type*} [SemilatticeSup P] [OrderBot P]
    (t : Ideal P) {Î¹ : Type*}
    {f : Î¹ â†’ P} {s : Finset Î¹} : s.sup f âˆˆ t â†” âˆ€ i âˆˆ s, f i âˆˆ t := by
  classical
  induction s using Finset.induction_on <;> simp [*]

end SemilatticeSup

section SemilatticeSupDirected

variable [SemilatticeSup P] [IsDirected P (Â· â‰¥ Â·)] {x : P} {I J s t : Ideal P}

/-- The infimum of two ideals of a co-directed order is their intersection. -/
instance : Min (Ideal P) :=
  âŸ¨fun I J â†¦
    { toLowerSet := I.toLowerSet âŠ“ J.toLowerSet
      nonempty' := inter_nonempty I J
      directed' := fun x hx y hy â†¦ âŸ¨x âŠ” y, âŸ¨sup_mem hx.1 hy.1, sup_mem hx.2 hy.2âŸ©, by simpâŸ© }âŸ©

/-- The supremum of two ideals of a co-directed order is the union of the down sets of the pointwise
supremum of `I` and `J`. -/
instance : Max (Ideal P) :=
  âŸ¨fun I J â†¦
    { carrier := { x | âˆƒ i âˆˆ I, âˆƒ j âˆˆ J, x â‰¤ i âŠ” j }
      nonempty' := by
        obtain âŸ¨w, hâŸ© := inter_nonempty I J
        exact âŸ¨w, w, h.1, w, h.2, le_sup_leftâŸ©
      directed' := fun x âŸ¨xi, _, xj, _, _âŸ© y âŸ¨yi, _, yj, _, _âŸ© â†¦
        âŸ¨x âŠ” y, âŸ¨xi âŠ” yi, sup_mem â€¹_â€º â€¹_â€º, xj âŠ” yj, sup_mem â€¹_â€º â€¹_â€º,
            sup_le
              (calc
                x â‰¤ xi âŠ” xj := â€¹_â€º
                _ â‰¤ xi âŠ” yi âŠ” (xj âŠ” yj) := sup_le_sup le_sup_left le_sup_left)
              (calc
                y â‰¤ yi âŠ” yj := â€¹_â€º
                _ â‰¤ xi âŠ” yi âŠ” (xj âŠ” yj) := sup_le_sup le_sup_right le_sup_right)âŸ©,
          le_sup_left, le_sup_rightâŸ©
      lower' := fun _ _ h âŸ¨yi, hi, yj, hj, hxyâŸ© â†¦ âŸ¨yi, hi, yj, hj, h.trans hxyâŸ© }âŸ©

instance : Lattice (Ideal P) :=
  { Ideal.instPartialOrderIdeal with
    max := (Â· âŠ” Â·)
    le_sup_left := fun _ J i hi â†¦
      let âŸ¨w, hwâŸ© := J.nonempty
      âŸ¨i, hi, w, hw, le_sup_leftâŸ©
    le_sup_right := fun I _ j hj â†¦
      let âŸ¨w, hwâŸ© := I.nonempty
      âŸ¨w, hw, j, hj, le_sup_rightâŸ©
    sup_le := fun _ _ K hIK hJK _ âŸ¨_, hi, _, hj, haâŸ© â†¦
      K.lower ha <| sup_mem (mem_of_mem_of_le hi hIK) (mem_of_mem_of_le hj hJK)
    min := (Â· âŠ“ Â·)
    inf_le_left := fun _ _ â†¦ inter_subset_left
    inf_le_right := fun _ _ â†¦ inter_subset_right
    le_inf := fun _ _ _ â†¦ subset_inter }

@[simp]
theorem coe_sup : â†‘(s âŠ” t) = { x | âˆƒ a âˆˆ s, âˆƒ b âˆˆ t, x â‰¤ a âŠ” b } :=
  rfl

@[simp]
theorem coe_inf : (â†‘(s âŠ“ t) : Set P) = â†‘s âˆ© â†‘t :=
  rfl

@[simp]
theorem mem_inf : x âˆˆ I âŠ“ J â†” x âˆˆ I âˆ§ x âˆˆ J :=
  Iff.rfl

@[simp]
theorem mem_sup : x âˆˆ I âŠ” J â†” âˆƒ i âˆˆ I, âˆƒ j âˆˆ J, x â‰¤ i âŠ” j :=
  Iff.rfl

theorem lt_sup_principal_of_notMem (hx : x âˆ‰ I) : I < I âŠ” principal x :=
  le_sup_left.lt_of_ne fun h â†¦ hx <| by simpa only [left_eq_sup, principal_le_iff] using h

@[deprecated (since := "2025-05-23")]
alias lt_sup_principal_of_not_mem := lt_sup_principal_of_notMem

end SemilatticeSupDirected

section SemilatticeSupOrderBot

variable [SemilatticeSup P] [OrderBot P] {x : P}

instance : InfSet (Ideal P) :=
  âŸ¨fun S â†¦
    { toLowerSet := â¨… s âˆˆ S, toLowerSet s
      nonempty' :=
        âŸ¨âŠ¥, by
          rw [LowerSet.carrier_eq_coe, LowerSet.coe_iInfâ‚‚, Set.mem_iInterâ‚‚]
          exact fun s _ â†¦ s.bot_memâŸ©
      directed' := fun a ha b hb â†¦
        âŸ¨a âŠ” b,
          âŸ¨by
            rw [LowerSet.carrier_eq_coe, LowerSet.coe_iInfâ‚‚, Set.mem_iInterâ‚‚] at ha hb âŠ¢
            exact fun s hs â†¦ sup_mem (ha _ hs) (hb _ hs), le_sup_left, le_sup_rightâŸ©âŸ© }âŸ©

variable {S : Set (Ideal P)}

@[simp]
theorem coe_sInf : (â†‘(sInf S) : Set P) = â‹‚ s âˆˆ S, â†‘s :=
  LowerSet.coe_iInfâ‚‚ _

@[simp]
theorem mem_sInf : x âˆˆ sInf S â†” âˆ€ s âˆˆ S, x âˆˆ s := by
  simp_rw [â† SetLike.mem_coe, coe_sInf, mem_iInterâ‚‚]

instance : CompleteLattice (Ideal P) :=
  { (inferInstance : Lattice (Ideal P)),
    completeLatticeOfInf (Ideal P) fun S â†¦ by
      refine âŸ¨fun s hs â†¦ ?_, fun s hs â†¦ by rwa [â† coe_subset_coe, coe_sInf, subset_iInterâ‚‚_iff]âŸ©
      rw [â† coe_subset_coe, coe_sInf]
      exact biInter_subset_of_mem hs with }

end SemilatticeSupOrderBot

section DistribLattice

variable [DistribLattice P]
variable {I J : Ideal P}

theorem eq_sup_of_le_sup {x i j : P} (hi : i âˆˆ I) (hj : j âˆˆ J) (hx : x â‰¤ i âŠ” j) :
    âˆƒ i' âˆˆ I, âˆƒ j' âˆˆ J, x = i' âŠ” j' := by
  refine âŸ¨x âŠ“ i, I.lower inf_le_right hi, x âŠ“ j, J.lower inf_le_right hj, ?_âŸ©
  calc
    x = x âŠ“ (i âŠ” j) := left_eq_inf.mpr hx
    _ = x âŠ“ i âŠ” x âŠ“ j := inf_sup_left _ _ _

theorem coe_sup_eq : â†‘(I âŠ” J) = { x | âˆƒ i âˆˆ I, âˆƒ j âˆˆ J, x = i âŠ” j } :=
  Set.ext fun _ â†¦
    âŸ¨fun âŸ¨_, _, _, _, _âŸ© â†¦ eq_sup_of_le_sup â€¹_â€º â€¹_â€º â€¹_â€º, fun âŸ¨i, _, j, _, _âŸ© â†¦
      âŸ¨i, â€¹_â€º, j, â€¹_â€º, le_of_eq â€¹_â€ºâŸ©âŸ©

end DistribLattice

section BooleanAlgebra

variable [BooleanAlgebra P] {x : P} {I : Ideal P}

theorem IsProper.notMem_of_compl_mem (hI : IsProper I) (hxc : xá¶œ âˆˆ I) : x âˆ‰ I := by
  intro hx
  apply hI.top_notMem
  have ht : x âŠ” xá¶œ âˆˆ I := sup_mem â€¹_â€º â€¹_â€º
  rwa [sup_compl_eq_top] at ht

@[deprecated (since := "2025-05-23")]
alias IsProper.not_mem_of_compl_mem := IsProper.notMem_of_compl_mem

theorem IsProper.notMem_or_compl_notMem (hI : IsProper I) : x âˆ‰ I âˆ¨ xá¶œ âˆ‰ I := by
  have h : xá¶œ âˆˆ I â†’ x âˆ‰ I := hI.notMem_of_compl_mem
  tauto

@[deprecated (since := "2025-05-23")]
alias IsProper.not_mem_or_compl_not_mem := IsProper.notMem_or_compl_notMem

end BooleanAlgebra

end Ideal

/-- For a preorder `P`, `Cofinal P` is the type of subsets of `P`
  containing arbitrarily large elements. They are the dense sets in
  the topology whose open sets are terminal segments. -/
structure Cofinal (P) [Preorder P] where
  /-- The carrier of a `Cofinal` is the underlying set. -/
  carrier : Set P
  /-- The `Cofinal` contains arbitrarily large elements. -/
  isCofinal : IsCofinal carrier

namespace Cofinal

variable [Preorder P]

instance : Inhabited (Cofinal P) :=
  âŸ¨_, .univâŸ©

instance : Membership P (Cofinal P) :=
  âŸ¨fun D x â†¦ x âˆˆ D.carrierâŸ©

variable (D : Cofinal P) (x : P)

/-- A (noncomputable) element of a cofinal set lying above a given element. -/
noncomputable def above : P :=
  Classical.choose <| D.isCofinal x

theorem above_mem : D.above x âˆˆ D :=
  (Classical.choose_spec <| D.isCofinal x).1

theorem le_above : x â‰¤ D.above x :=
  (Classical.choose_spec <| D.isCofinal x).2

end Cofinal

section IdealOfCofinals

variable [Preorder P] (p : P) {Î¹ : Type*} [Encodable Î¹] (ğ’Ÿ : Î¹ â†’ Cofinal P)

/-- Given a starting point, and a countable family of cofinal sets,
  this is an increasing sequence that intersects each cofinal set. -/
noncomputable def sequenceOfCofinals : â„• â†’ P
  | 0 => p
  | n + 1 =>
    match Encodable.decode n with
    | none => sequenceOfCofinals n
    | some i => (ğ’Ÿ i).above (sequenceOfCofinals n)

theorem sequenceOfCofinals.monotone : Monotone (sequenceOfCofinals p ğ’Ÿ) := by
  apply monotone_nat_of_le_succ
  intro n
  dsimp only [sequenceOfCofinals, Nat.add]
  cases (Encodable.decode n : Option Î¹)
  Â· rfl
  Â· apply Cofinal.le_above

theorem sequenceOfCofinals.encode_mem (i : Î¹) :
    sequenceOfCofinals p ğ’Ÿ (Encodable.encode i + 1) âˆˆ ğ’Ÿ i := by
  dsimp only [sequenceOfCofinals, Nat.add]
  rw [Encodable.encodek]
  apply Cofinal.above_mem

/-- Given an element `p : P` and a family `ğ’Ÿ` of cofinal subsets of a preorder `P`,
  indexed by a countable type, `idealOfCofinals p ğ’Ÿ` is an ideal in `P` which
  - contains `p`, according to `mem_idealOfCofinals p ğ’Ÿ`, and
  - intersects every set in `ğ’Ÿ`, according to `cofinal_meets_idealOfCofinals p ğ’Ÿ`.

  This proves the Rasiowaâ€“Sikorski lemma. -/
def idealOfCofinals : Ideal P where
  carrier := { x : P | âˆƒ n, x â‰¤ sequenceOfCofinals p ğ’Ÿ n }
  lower' := fun _ _ hxy âŸ¨n, hnâŸ© â†¦ âŸ¨n, le_trans hxy hnâŸ©
  nonempty' := âŸ¨p, 0, le_rflâŸ©
  directed' := fun _ âŸ¨n, hnâŸ© _ âŸ¨m, hmâŸ© â†¦
    âŸ¨_, âŸ¨max n m, le_rflâŸ©, le_trans hn <| sequenceOfCofinals.monotone p ğ’Ÿ (le_max_left _ _),
      le_trans hm <| sequenceOfCofinals.monotone p ğ’Ÿ (le_max_right _ _)âŸ©

theorem mem_idealOfCofinals : p âˆˆ idealOfCofinals p ğ’Ÿ :=
  âŸ¨0, le_rflâŸ©

/-- `idealOfCofinals p ğ’Ÿ` is `ğ’Ÿ`-generic. -/
theorem cofinal_meets_idealOfCofinals (i : Î¹) : âˆƒ x : P, x âˆˆ ğ’Ÿ i âˆ§ x âˆˆ idealOfCofinals p ğ’Ÿ :=
  âŸ¨_, sequenceOfCofinals.encode_mem p ğ’Ÿ i, _, le_rflâŸ©

end IdealOfCofinals

section sUnion

variable [Preorder P]

/-- A non-empty directed union of ideals of sets in a preorder is an ideal. -/
lemma isIdeal_sUnion_of_directedOn {C : Set (Set P)} (hidl : âˆ€ I âˆˆ C, IsIdeal I)
    (hD : DirectedOn (Â· âŠ† Â·) C) (hNe : C.Nonempty) : IsIdeal C.sUnion := by
  refine âŸ¨isLowerSet_sUnion (fun I hI â†¦ (hidl I hI).1), Set.nonempty_sUnion.2 ?_,
    directedOn_sUnion hD (fun J hJ => (hidl J hJ).3)âŸ©
  let âŸ¨I, hIâŸ© := hNe
  exact âŸ¨I, âŸ¨hI, (hidl I hI).2âŸ©âŸ©

/-- A union of a nonempty chain of ideals of sets is an ideal. -/
lemma isIdeal_sUnion_of_isChain {C : Set (Set P)} (hidl : âˆ€ I âˆˆ C, IsIdeal I)
    (hC : IsChain (Â· âŠ† Â·) C) (hNe : C.Nonempty) : IsIdeal C.sUnion :=
  isIdeal_sUnion_of_directedOn hidl hC.directedOn hNe

end sUnion
end Order
