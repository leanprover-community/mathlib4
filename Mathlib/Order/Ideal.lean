/-
Copyright (c) 2020 David W√§rn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David W√§rn
-/
import Mathlib.Logic.Encodable.Basic
import Mathlib.Order.Atoms
import Mathlib.Order.Chain
import Mathlib.Order.UpperLower.Basic
import Mathlib.Data.Set.Subsingleton

/-!
# Order ideals, cofinal sets, and the Rasiowa‚ÄìSikorski lemma

## Main definitions

Throughout this file, `P` is at least a preorder, but some sections require more
structure, such as a bottom element, a top element, or a join-semilattice structure.
- `Order.Ideal P`: the type of nonempty, upward directed, and downward closed subsets of `P`.
  Dual to the notion of a filter on a preorder.
- `Order.IsIdeal I`: a predicate for when a `Set P` is an ideal.
- `Order.Ideal.principal p`: the principal ideal generated by `p : P`.
- `Order.Ideal.IsProper I`: a predicate for proper ideals.
  Dual to the notion of a proper filter.
- `Order.Ideal.IsMaximal I`: a predicate for maximal ideals.
  Dual to the notion of an ultrafilter.
- `Order.Cofinal P`: the type of subsets of `P` containing arbitrarily large elements.
  Dual to the notion of 'dense set' used in forcing.
- `Order.idealOfCofinals p ùíü`, where `p : P`, and `ùíü` is a countable family of cofinal
  subsets of `P`: an ideal in `P` which contains `p` and intersects every set in `ùíü`. (This a form
  of the Rasiowa‚ÄìSikorski lemma.)

## References

- <https://en.wikipedia.org/wiki/Ideal_(order_theory)>
- <https://en.wikipedia.org/wiki/Cofinal_(mathematics)>
- <https://en.wikipedia.org/wiki/Rasiowa%E2%80%93Sikorski_lemma>

Note that for the Rasiowa‚ÄìSikorski lemma, Wikipedia uses the opposite ordering on `P`,
in line with most presentations of forcing.

## Tags

ideal, cofinal, dense, countable, generic

-/


open Function Set

namespace Order

variable {P : Type*}

/-- An ideal on an order `P` is a subset of `P` that is
  - nonempty
  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)
  - downward closed (any element less than an element of the ideal is in the ideal). -/
structure Ideal (P) [LE P] extends LowerSet P where
  /-- The ideal is nonempty. -/
  nonempty' : carrier.Nonempty
  /-- The ideal is upward directed. -/
  directed' : DirectedOn (¬∑ ‚â§ ¬∑) carrier

-- Porting note (#11215): TODO: remove this configuration and use the default configuration.
-- We keep this to be consistent with Lean 3.
initialize_simps_projections Ideal (+toLowerSet, -carrier)

/-- A subset of a preorder `P` is an ideal if it is
  - nonempty
  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)
  - downward closed (any element less than an element of the ideal is in the ideal). -/
@[mk_iff]
structure IsIdeal {P} [LE P] (I : Set P) : Prop where
  /-- The ideal is downward closed. -/
  IsLowerSet : IsLowerSet I
  /-- The ideal is nonempty. -/
  Nonempty : I.Nonempty
  /-- The ideal is upward directed. -/
  Directed : DirectedOn (¬∑ ‚â§ ¬∑) I

/-- Create an element of type `Order.Ideal` from a set satisfying the predicate
`Order.IsIdeal`. -/
def IsIdeal.toIdeal [LE P] {I : Set P} (h : IsIdeal I) : Ideal P :=
  ‚ü®‚ü®I, h.IsLowerSet‚ü©, h.Nonempty, h.Directed‚ü©

namespace Ideal

section LE

variable [LE P]

section

variable {I J s t : Ideal P} {x y : P}

theorem toLowerSet_injective : Injective (toLowerSet : Ideal P ‚Üí LowerSet P) := fun s t _ ‚Ü¶ by
  cases s
  cases t
  congr

instance : SetLike (Ideal P) P where
  coe s := s.carrier
  coe_injective' _ _ h := toLowerSet_injective <| SetLike.coe_injective h

@[ext]
theorem ext {s t : Ideal P} : (s : Set P) = t ‚Üí s = t :=
  SetLike.ext'

@[simp]
theorem carrier_eq_coe (s : Ideal P) : s.carrier = s :=
  rfl

@[simp]
theorem coe_toLowerSet (s : Ideal P) : (s.toLowerSet : Set P) = s :=
  rfl

protected theorem lower (s : Ideal P) : IsLowerSet (s : Set P) :=
  s.lower'

protected theorem nonempty (s : Ideal P) : (s : Set P).Nonempty :=
  s.nonempty'

protected theorem directed (s : Ideal P) : DirectedOn (¬∑ ‚â§ ¬∑) (s : Set P) :=
  s.directed'

protected theorem isIdeal (s : Ideal P) : IsIdeal (s : Set P) :=
  ‚ü®s.lower, s.nonempty, s.directed‚ü©

theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú := fun h ‚Ü¶
  mt <| I.lower h

/-- The partial ordering by subset inclusion, inherited from `Set P`. -/
instance instPartialOrderIdeal : PartialOrder (Ideal P) :=
  PartialOrder.lift SetLike.coe SetLike.coe_injective

-- @[simp] -- Porting note (#10618): simp can prove this
theorem coe_subset_coe : (s : Set P) ‚äÜ t ‚Üî s ‚â§ t :=
  Iff.rfl

-- @[simp] -- Porting note (#10618): simp can prove this
theorem coe_ssubset_coe : (s : Set P) ‚äÇ t ‚Üî s < t :=
  Iff.rfl

@[trans]
theorem mem_of_mem_of_le {x : P} {I J : Ideal P} : x ‚àà I ‚Üí I ‚â§ J ‚Üí x ‚àà J :=
  @Set.mem_of_mem_of_subset P x I J

/-- A proper ideal is one that is not the whole set.
    Note that the whole set might not be an ideal. -/
@[mk_iff]
class IsProper (I : Ideal P) : Prop where
  /-- This ideal is not the whole set. -/
  ne_univ : (I : Set P) ‚â† univ

theorem isProper_of_not_mem {I : Ideal P} {p : P} (nmem : p ‚àâ I) : IsProper I :=
  ‚ü®fun hp ‚Ü¶ by
    have := mem_univ p
    rw [‚Üê hp] at this
    exact nmem this‚ü©

/-- An ideal is maximal if it is maximal in the collection of proper ideals.

Note that `IsCoatom` is less general because ideals only have a top element when `P` is directed
and nonempty. -/
@[mk_iff]
class IsMaximal (I : Ideal P) extends IsProper I : Prop where
  /-- This ideal is maximal in the collection of proper ideals. -/
  maximal_proper : ‚àÄ ‚¶ÉJ : Ideal P‚¶Ñ, I < J ‚Üí (J : Set P) = univ

theorem inter_nonempty [IsDirected P (¬∑ ‚â• ¬∑)] (I J : Ideal P) : (I ‚à© J : Set P).Nonempty := by
  obtain ‚ü®a, ha‚ü© := I.nonempty
  obtain ‚ü®b, hb‚ü© := J.nonempty
  obtain ‚ü®c, hac, hbc‚ü© := exists_le_le a b
  exact ‚ü®c, I.lower hac ha, J.lower hbc hb‚ü©

end

section Directed

variable [IsDirected P (¬∑ ‚â§ ¬∑)] [Nonempty P] {I : Ideal P}

/-- In a directed and nonempty order, the top ideal of a is `univ`. -/
instance : OrderTop (Ideal P) where
  top := ‚ü®‚ä§, univ_nonempty, directedOn_univ‚ü©
  le_top _ _ _ := LowerSet.mem_top

@[simp]
theorem top_toLowerSet : (‚ä§ : Ideal P).toLowerSet = ‚ä§ :=
  rfl

@[simp]
theorem coe_top : ((‚ä§ : Ideal P) : Set P) = univ :=
  rfl

theorem isProper_of_ne_top (ne_top : I ‚â† ‚ä§) : IsProper I :=
  ‚ü®fun h ‚Ü¶ ne_top <| ext h‚ü©

theorem IsProper.ne_top (_ : IsProper I) : I ‚â† ‚ä§ :=
  fun h ‚Ü¶ IsProper.ne_univ <| congr_arg SetLike.coe h

theorem _root_.IsCoatom.isProper (hI : IsCoatom I) : IsProper I :=
  isProper_of_ne_top hI.1

theorem isProper_iff_ne_top : IsProper I ‚Üî I ‚â† ‚ä§ :=
  ‚ü®fun h ‚Ü¶ h.ne_top, fun h ‚Ü¶ isProper_of_ne_top h‚ü©

theorem IsMaximal.isCoatom (_ : IsMaximal I) : IsCoatom I :=
  ‚ü®IsMaximal.toIsProper.ne_top, fun _ h ‚Ü¶ ext <| IsMaximal.maximal_proper h‚ü©

theorem IsMaximal.isCoatom' [IsMaximal I] : IsCoatom I :=
  IsMaximal.isCoatom ‚Äπ_‚Ä∫

theorem _root_.IsCoatom.isMaximal (hI : IsCoatom I) : IsMaximal I :=
  { IsCoatom.isProper hI with maximal_proper := fun _ hJ ‚Ü¶ by simp [hI.2 _ hJ] }

theorem isMaximal_iff_isCoatom : IsMaximal I ‚Üî IsCoatom I :=
  ‚ü®fun h ‚Ü¶ h.isCoatom, fun h ‚Ü¶ IsCoatom.isMaximal h‚ü©

end Directed

section OrderBot

variable [OrderBot P]

@[simp]
theorem bot_mem (s : Ideal P) : ‚ä• ‚àà s :=
  s.lower bot_le s.nonempty'.some_mem

end OrderBot

section OrderTop

variable [OrderTop P] {I : Ideal P}

theorem top_of_top_mem (h : ‚ä§ ‚àà I) : I = ‚ä§ := by
  ext
  exact iff_of_true (I.lower le_top h) trivial

theorem IsProper.top_not_mem (hI : IsProper I) : ‚ä§ ‚àâ I := fun h ‚Ü¶ hI.ne_top <| top_of_top_mem h

end OrderTop

end LE

section Preorder

variable [Preorder P]

section

variable {I J : Ideal P} {x y : P}

/-- The smallest ideal containing a given element. -/
@[simps]
def principal (p : P) : Ideal P where
  toLowerSet := LowerSet.Iic p
  nonempty' := nonempty_Iic
  directed' _ hx _ hy := ‚ü®p, le_rfl, hx, hy‚ü©

instance [Inhabited P] : Inhabited (Ideal P) :=
  ‚ü®Ideal.principal default‚ü©

@[simp]
theorem principal_le_iff : principal x ‚â§ I ‚Üî x ‚àà I :=
  ‚ü®fun h ‚Ü¶ h le_rfl, fun hx _ hy ‚Ü¶ I.lower hy hx‚ü©

@[simp]
theorem mem_principal : x ‚àà principal y ‚Üî x ‚â§ y :=
  Iff.rfl

lemma mem_principal_self : x ‚àà principal x :=
  mem_principal.2 (le_refl x)

end

section OrderBot

variable [OrderBot P]

/-- There is a bottom ideal when `P` has a bottom element. -/
instance : OrderBot (Ideal P) where
  bot := principal ‚ä•
  bot_le := by simp

@[simp]
theorem principal_bot : principal (‚ä• : P) = ‚ä• :=
  rfl

end OrderBot

section OrderTop

variable [OrderTop P]

@[simp]
theorem principal_top : principal (‚ä§ : P) = ‚ä§ :=
  toLowerSet_injective <| LowerSet.Iic_top

end OrderTop

end Preorder

section SemilatticeSup

variable [SemilatticeSup P] {x y : P} {I s : Ideal P}

/-- A specific witness of `I.directed` when `P` has joins. -/
theorem sup_mem (hx : x ‚àà s) (hy : y ‚àà s) : x ‚äî y ‚àà s :=
  let ‚ü®_, hz, hx, hy‚ü© := s.directed x hx y hy
  s.lower (sup_le hx hy) hz

@[simp]
theorem sup_mem_iff : x ‚äî y ‚àà I ‚Üî x ‚àà I ‚àß y ‚àà I :=
  ‚ü®fun h ‚Ü¶ ‚ü®I.lower le_sup_left h, I.lower le_sup_right h‚ü©, fun h ‚Ü¶ sup_mem h.1 h.2‚ü©

end SemilatticeSup

section SemilatticeSupDirected

variable [SemilatticeSup P] [IsDirected P (¬∑ ‚â• ¬∑)] {x : P} {I J K s t : Ideal P}

/-- The infimum of two ideals of a co-directed order is their intersection. -/
instance : Inf (Ideal P) :=
  ‚ü®fun I J ‚Ü¶
    { toLowerSet := I.toLowerSet ‚äì J.toLowerSet
      nonempty' := inter_nonempty I J
      directed' := fun x hx y hy ‚Ü¶ ‚ü®x ‚äî y, ‚ü®sup_mem hx.1 hy.1, sup_mem hx.2 hy.2‚ü©, by simp‚ü© }‚ü©

/-- The supremum of two ideals of a co-directed order is the union of the down sets of the pointwise
supremum of `I` and `J`. -/
instance : Sup (Ideal P) :=
  ‚ü®fun I J ‚Ü¶
    { carrier := { x | ‚àÉ i ‚àà I, ‚àÉ j ‚àà J, x ‚â§ i ‚äî j }
      nonempty' := by
        cases' inter_nonempty I J with w h
        exact ‚ü®w, w, h.1, w, h.2, le_sup_left‚ü©
      directed' := fun x ‚ü®xi, _, xj, _, _‚ü© y ‚ü®yi, _, yj, _, _‚ü© ‚Ü¶
        ‚ü®x ‚äî y, ‚ü®xi ‚äî yi, sup_mem ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫, xj ‚äî yj, sup_mem ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫,
            sup_le
              (calc
                x ‚â§ xi ‚äî xj := ‚Äπ_‚Ä∫
                _ ‚â§ xi ‚äî yi ‚äî (xj ‚äî yj) := sup_le_sup le_sup_left le_sup_left)
              (calc
                y ‚â§ yi ‚äî yj := ‚Äπ_‚Ä∫
                _ ‚â§ xi ‚äî yi ‚äî (xj ‚äî yj) := sup_le_sup le_sup_right le_sup_right)‚ü©,
          le_sup_left, le_sup_right‚ü©
      lower' := fun x y h ‚ü®yi, hi, yj, hj, hxy‚ü© ‚Ü¶ ‚ü®yi, hi, yj, hj, h.trans hxy‚ü© }‚ü©

instance : Lattice (Ideal P) :=
  { Ideal.instPartialOrderIdeal with
    sup := (¬∑ ‚äî ¬∑)
    le_sup_left := fun _ J i hi ‚Ü¶
      let ‚ü®w, hw‚ü© := J.nonempty
      ‚ü®i, hi, w, hw, le_sup_left‚ü©
    le_sup_right := fun I _ j hj ‚Ü¶
      let ‚ü®w, hw‚ü© := I.nonempty
      ‚ü®w, hw, j, hj, le_sup_right‚ü©
    sup_le := fun _ _ K hIK hJK _ ‚ü®_, hi, _, hj, ha‚ü© ‚Ü¶
      K.lower ha <| sup_mem (mem_of_mem_of_le hi hIK) (mem_of_mem_of_le hj hJK)
    inf := (¬∑ ‚äì ¬∑)
    inf_le_left := fun _ _ ‚Ü¶ inter_subset_left
    inf_le_right := fun _ _ ‚Ü¶ inter_subset_right
    le_inf := fun _ _ _ ‚Ü¶ subset_inter }

@[simp]
theorem coe_sup : ‚Üë(s ‚äî t) = { x | ‚àÉ a ‚àà s, ‚àÉ b ‚àà t, x ‚â§ a ‚äî b } :=
  rfl

-- Porting note: Modified `s ‚à© t` to `‚Üës ‚à© ‚Üët`.
@[simp]
theorem coe_inf : (‚Üë(s ‚äì t) : Set P) = ‚Üës ‚à© ‚Üët :=
  rfl

@[simp]
theorem mem_inf : x ‚àà I ‚äì J ‚Üî x ‚àà I ‚àß x ‚àà J :=
  Iff.rfl

@[simp]
theorem mem_sup : x ‚àà I ‚äî J ‚Üî ‚àÉ i ‚àà I, ‚àÉ j ‚àà J, x ‚â§ i ‚äî j :=
  Iff.rfl

theorem lt_sup_principal_of_not_mem (hx : x ‚àâ I) : I < I ‚äî principal x :=
  le_sup_left.lt_of_ne fun h ‚Ü¶ hx <| by simpa only [left_eq_sup, principal_le_iff] using h

end SemilatticeSupDirected

section SemilatticeSupOrderBot

variable [SemilatticeSup P] [OrderBot P] {x : P} {I J K : Ideal P}

instance : InfSet (Ideal P) :=
  ‚ü®fun S ‚Ü¶
    { toLowerSet := ‚®Ö s ‚àà S, toLowerSet s
      nonempty' :=
        ‚ü®‚ä•, by
          rw [LowerSet.carrier_eq_coe, LowerSet.coe_iInf‚ÇÇ, Set.mem_iInter‚ÇÇ]
          exact fun s _ ‚Ü¶ s.bot_mem‚ü©
      directed' := fun a ha b hb ‚Ü¶
        ‚ü®a ‚äî b,
          ‚ü®by
            rw [LowerSet.carrier_eq_coe, LowerSet.coe_iInf‚ÇÇ, Set.mem_iInter‚ÇÇ] at ha hb ‚ä¢
            exact fun s hs ‚Ü¶ sup_mem (ha _ hs) (hb _ hs), le_sup_left, le_sup_right‚ü©‚ü© }‚ü©

variable {S : Set (Ideal P)}

@[simp]
theorem coe_sInf : (‚Üë(sInf S) : Set P) = ‚ãÇ s ‚àà S, ‚Üës :=
  LowerSet.coe_iInf‚ÇÇ _

@[simp]
theorem mem_sInf : x ‚àà sInf S ‚Üî ‚àÄ s ‚àà S, x ‚àà s := by
  simp_rw [‚Üê SetLike.mem_coe, coe_sInf, mem_iInter‚ÇÇ]

instance : CompleteLattice (Ideal P) :=
  { (inferInstance : Lattice (Ideal P)),
    completeLatticeOfInf (Ideal P) fun S ‚Ü¶ by
      refine ‚ü®fun s hs ‚Ü¶ ?_, fun s hs ‚Ü¶ by rwa [‚Üê coe_subset_coe, coe_sInf, subset_iInter‚ÇÇ_iff]‚ü©
      rw [‚Üê coe_subset_coe, coe_sInf]
      exact biInter_subset_of_mem hs with }

end SemilatticeSupOrderBot

section DistribLattice

variable [DistribLattice P]
variable {I J : Ideal P}

theorem eq_sup_of_le_sup {x i j : P} (hi : i ‚àà I) (hj : j ‚àà J) (hx : x ‚â§ i ‚äî j) :
    ‚àÉ i' ‚àà I, ‚àÉ j' ‚àà J, x = i' ‚äî j' := by
  refine ‚ü®x ‚äì i, I.lower inf_le_right hi, x ‚äì j, J.lower inf_le_right hj, ?_‚ü©
  calc
    x = x ‚äì (i ‚äî j) := left_eq_inf.mpr hx
    _ = x ‚äì i ‚äî x ‚äì j := inf_sup_left _ _ _

theorem coe_sup_eq : ‚Üë(I ‚äî J) = { x | ‚àÉ i ‚àà I, ‚àÉ j ‚àà J, x = i ‚äî j } :=
  Set.ext fun _ ‚Ü¶
    ‚ü®fun ‚ü®_, _, _, _, _‚ü© ‚Ü¶ eq_sup_of_le_sup ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫, fun ‚ü®i, _, j, _, _‚ü© ‚Ü¶
      ‚ü®i, ‚Äπ_‚Ä∫, j, ‚Äπ_‚Ä∫, le_of_eq ‚Äπ_‚Ä∫‚ü©‚ü©

end DistribLattice

section BooleanAlgebra

variable [BooleanAlgebra P] {x : P} {I : Ideal P}

theorem IsProper.not_mem_of_compl_mem (hI : IsProper I) (hxc : x·∂ú ‚àà I) : x ‚àâ I := by
  intro hx
  apply hI.top_not_mem
  have ht : x ‚äî x·∂ú ‚àà I := sup_mem ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫
  rwa [sup_compl_eq_top] at ht

theorem IsProper.not_mem_or_compl_not_mem (hI : IsProper I) : x ‚àâ I ‚à® x·∂ú ‚àâ I := by
  have h : x·∂ú ‚àà I ‚Üí x ‚àâ I := hI.not_mem_of_compl_mem
  tauto

end BooleanAlgebra

end Ideal

/-- For a preorder `P`, `Cofinal P` is the type of subsets of `P`
  containing arbitrarily large elements. They are the dense sets in
  the topology whose open sets are terminal segments. -/
structure Cofinal (P) [Preorder P] where
  /-- The carrier of a `Cofinal` is the underlying set. -/
  carrier : Set P
  /-- The `Cofinal` contains arbitrarily large elements. -/
  mem_gt : ‚àÄ x : P, ‚àÉ y ‚àà carrier, x ‚â§ y

namespace Cofinal

variable [Preorder P]

instance : Inhabited (Cofinal P) :=
  ‚ü®{  carrier := univ
      mem_gt := fun x ‚Ü¶ ‚ü®x, trivial, le_rfl‚ü© }‚ü©

instance : Membership P (Cofinal P) :=
  ‚ü®fun D x ‚Ü¶ x ‚àà D.carrier‚ü©

variable (D : Cofinal P) (x : P)

/-- A (noncomputable) element of a cofinal set lying above a given element. -/
noncomputable def above : P :=
  Classical.choose <| D.mem_gt x

theorem above_mem : D.above x ‚àà D :=
  (Classical.choose_spec <| D.mem_gt x).1

theorem le_above : x ‚â§ D.above x :=
  (Classical.choose_spec <| D.mem_gt x).2

end Cofinal

section IdealOfCofinals

variable [Preorder P] (p : P) {Œπ : Type*} [Encodable Œπ] (ùíü : Œπ ‚Üí Cofinal P)

/-- Given a starting point, and a countable family of cofinal sets,
  this is an increasing sequence that intersects each cofinal set. -/
noncomputable def sequenceOfCofinals : ‚Ñï ‚Üí P
  | 0 => p
  | n + 1 =>
    match Encodable.decode n with
    | none => sequenceOfCofinals n
    | some i => (ùíü i).above (sequenceOfCofinals n)

theorem sequenceOfCofinals.monotone : Monotone (sequenceOfCofinals p ùíü) := by
  apply monotone_nat_of_le_succ
  intro n
  dsimp only [sequenceOfCofinals, Nat.add]
  cases (Encodable.decode n : Option Œπ)
  ¬∑ rfl
  ¬∑ apply Cofinal.le_above

theorem sequenceOfCofinals.encode_mem (i : Œπ) :
    sequenceOfCofinals p ùíü (Encodable.encode i + 1) ‚àà ùíü i := by
  dsimp only [sequenceOfCofinals, Nat.add]
  rw [Encodable.encodek]
  apply Cofinal.above_mem

/-- Given an element `p : P` and a family `ùíü` of cofinal subsets of a preorder `P`,
  indexed by a countable type, `idealOfCofinals p ùíü` is an ideal in `P` which
  - contains `p`, according to `mem_idealOfCofinals p ùíü`, and
  - intersects every set in `ùíü`, according to `cofinal_meets_idealOfCofinals p ùíü`.

  This proves the Rasiowa‚ÄìSikorski lemma. -/
def idealOfCofinals : Ideal P where
  carrier := { x : P | ‚àÉ n, x ‚â§ sequenceOfCofinals p ùíü n }
  lower' := fun _ _ hxy ‚ü®n, hn‚ü© ‚Ü¶ ‚ü®n, le_trans hxy hn‚ü©
  nonempty' := ‚ü®p, 0, le_rfl‚ü©
  directed' := fun _ ‚ü®n, hn‚ü© _ ‚ü®m, hm‚ü© ‚Ü¶
    ‚ü®_, ‚ü®max n m, le_rfl‚ü©, le_trans hn <| sequenceOfCofinals.monotone p ùíü (le_max_left _ _),
      le_trans hm <| sequenceOfCofinals.monotone p ùíü (le_max_right _ _)‚ü©

theorem mem_idealOfCofinals : p ‚àà idealOfCofinals p ùíü :=
  ‚ü®0, le_rfl‚ü©

/-- `idealOfCofinals p ùíü` is `ùíü`-generic. -/
theorem cofinal_meets_idealOfCofinals (i : Œπ) : ‚àÉ x : P, x ‚àà ùíü i ‚àß x ‚àà idealOfCofinals p ùíü :=
  ‚ü®_, sequenceOfCofinals.encode_mem p ùíü i, _, le_rfl‚ü©

end IdealOfCofinals

section sUnion

variable [Preorder P]

/-- A non-empty directed union of ideals of sets in a preorder is an ideal. -/
lemma isIdeal_sUnion_of_directedOn {C : Set (Set P)} (hidl : ‚àÄ I ‚àà C, IsIdeal I)
    (hD : DirectedOn (¬∑ ‚äÜ ¬∑) C) (hNe : C.Nonempty) : IsIdeal C.sUnion := by
  refine ‚ü®isLowerSet_sUnion (fun I hI ‚Ü¶ (hidl I hI).1), Set.nonempty_sUnion.2 ?_,
    directedOn_sUnion hD (fun J hJ => (hidl J hJ).3)‚ü©
  let ‚ü®I, hI‚ü© := hNe
  exact ‚ü®I, ‚ü®hI, (hidl I hI).2‚ü©‚ü©

/-- A union of a nonempty chain of ideals of sets is an ideal. -/
lemma isIdeal_sUnion_of_isChain {C : Set (Set P)} (hidl : ‚àÄ I ‚àà C, IsIdeal I)
    (hC : IsChain (¬∑ ‚äÜ ¬∑) C) (hNe : C.Nonempty) : IsIdeal C.sUnion :=
  isIdeal_sUnion_of_directedOn hidl hC.directedOn hNe

end sUnion
end Order
