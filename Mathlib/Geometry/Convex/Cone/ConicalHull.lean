/-
Copyright (c) 2025 Bjørn Solheim. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bjørn Solheim
-/
import Mathlib.Algebra.Module.Basic
import Mathlib.LinearAlgebra.Finsupp.LinearCombination
import Mathlib.Data.Finsupp.Basic
import Mathlib.Geometry.Convex.Cone.Pointed

/-!
# Conical combinations

A conical combination is characterized by nonnegative coefficients. This file contains
various basic results about conical combinations and their closure properties.
The conical hull is defined as the set of all conical combinations from a set of generators.
Conical combinations naturally define pointed cones (convex cones that include zero).

## Main results

'infPointedCone_eq_conicalHull' - The smallest pointed cone
containing the set s is equal to the conical hull generated by s.

## Notation

 - no special notation defined

## Implementation notes

 - This could be implemented as Fin n, Finset, and Finsup. Finsup seems to be a reasonable
  compromise between abstraction and ease of manipulation.

## References

 - https://en.wikipedia.org/wiki/Conical_combination
 - Leonard et al. - Geometry of convex sets

-/

namespace ConicalCombination

variable (R : Type*) {E : Type*}
variable [Semiring R] [PartialOrder R]
variable [AddCommMonoid E] [Module R E]

/-- Predicate stating that an element can be expressed as a conical combination using elements
 from the set s. A conical combination is characterized by nonnegative coefficients. -/
def IsConicalComb (s : Set E) (x : E) : Prop :=
  ∃ f : s →₀ R,
    (∀ v, 0 ≤ f v) ∧
      x = (Finsupp.linearCombination R (Subtype.val : s → E)) f

/-- Zero can be expressed as a conical combination -/
theorem conicalComb_zero (s : Set E) : IsConicalComb R s 0 :=
  ⟨0, fun _ => le_refl 0, by simp⟩

section ConicalCombinationSection
variable (R : Type*) [Semiring R] [PartialOrder R] [IsOrderedRing R]
variable {E : Type*} [AddCommMonoid E] [Module R E]

/-- The individual elements of a generator set are themselves trivial conical combinations. -/
theorem conicalComb_generator {s : Set E} {v : E} (h_mem : v ∈ s) :
    IsConicalComb R s v := by classical
  exact ⟨Finsupp.single ⟨v, h_mem⟩ 1,
    fun w => by
      simp only [Finsupp.single_apply]
      split_ifs <;> [exact zero_le_one; exact le_refl 0],
    by simp [Finsupp.linearCombination_single]⟩

/-- A scalar multiple of a conical combination is a conical combination. -/
theorem conicalComb_smul (s : Set E) (c : R) (h : 0 ≤ c) (v : E)
    (h_conicalcomb : IsConicalComb R s v) : IsConicalComb R s (c • v) := by
  obtain ⟨f, hf_nonneg, hf_eq⟩ := h_conicalcomb
  exact ⟨c • f, fun w => by simp [Finsupp.smul_apply, mul_nonneg h (hf_nonneg w)], by simp [hf_eq]⟩

/-- Adding two conical combinations produces a new conical combination. -/
theorem conicalComb_add (s : Set E) (x₁ x₂ : E)
    (h₁ : IsConicalComb R s x₁) (h₂ : IsConicalComb R s x₂) :
    IsConicalComb R s (x₁ + x₂) := by
  obtain ⟨f₁, hf₁_nonneg, hf₁_eq⟩ := h₁
  obtain ⟨f₂, hf₂_nonneg, hf₂_eq⟩ := h₂
  use f₁ + f₂
  constructor
  · intro v
    simp only [Finsupp.add_apply]
    exact add_nonneg (hf₁_nonneg v) (hf₂_nonneg v)
  · rw [hf₁_eq, hf₂_eq, ← map_add]

end ConicalCombinationSection
end ConicalCombination

--the following deals with conical hull and pointed cones
namespace PointedCone
open ConicalCombination

section PointedConeSection
variable (R : Type*) [Semiring R] [PartialOrder R] [IsOrderedRing R]
variable {E : Type*} [AddCommMonoid E] [Module R E]

/-- The 'conical_hull R s' is the set of all conical combinations of elements of s with scalars
 from R. It is a pointed cone. -/
def conicalHull (s : Set E) : PointedCone R E where
  carrier := {x | IsConicalComb R s x}
  zero_mem' := conicalComb_zero R s
  smul_mem' := by
    simp only [Set.mem_setOf_eq, Subtype.forall, Nonneg.mk_smul]
    intro c hc v hv
    exact conicalComb_smul R s c hc v hv
  add_mem' := by
    intro x y hx hy
    exact conicalComb_add R s x y hx hy

/-- The collection of all conical combinations over a set s (i.e., the conical hull of s)
contains the set s -/
theorem subset_conicalHull (s : Set E) :
    s ⊆ (conicalHull R s).carrier := by
  intro x hx
  exact conicalComb_generator R hx

/-- A pointed cone contains all conical combinations of elements from any given subset. -/
theorem conicalComb_mem (s : Set E) (f : s →₀ R) (h_nonneg : ∀ v, 0 ≤ f v)
    (C : PointedCone R E) (hs : s ⊆ C.carrier) :
    (Finsupp.linearCombination R (Subtype.val : s → E)) f ∈ C := by
  rw [Finsupp.linearCombination_apply]
  apply AddSubmonoid.sum_mem
  intro v hv
  exact C.smul_mem' ⟨f v, h_nonneg v⟩ (hs v.property)

/-- A conical combination from s is in the conical hull of s. -/
theorem conicalComb_mem_conicalHull (s : Set E) (f : s →₀ R) (h_nonneg : ∀ v, 0 ≤ f v) :
    (Finsupp.linearCombination R (Subtype.val : s → E)) f ∈ (conicalHull R s).carrier := by
  exact conicalComb_mem R s f h_nonneg (conicalHull R s) (subset_conicalHull R s)

/-- The conical hull of s is contained in any pointed cone containing s. -/
theorem conicalHull_minimal (s : Set E) (C : PointedCone R E) (hs : s ⊆ C.carrier) :
    (conicalHull R s).carrier ⊆ C.carrier := by
  intro x hx
  obtain ⟨f, hf_nonneg, hf_eq⟩ := hx
  rw [hf_eq]
  exact conicalComb_mem R s f hf_nonneg C hs

/-- 'IsPointedCone' - Prop valued -/
def IsPointedCone (E : Type*) [AddCommMonoid E] [Module R E]
    (C : Set E) : Prop :=
  ∃ (T : PointedCone R E), (T.carrier = C)

/-- C is a pointed cone iff C is nonempty and contains all two element conical combinations.
This characterization of pointed cones is convenient in some proofs -/
theorem pointedCone_iff_forall_nonneg (E : Type*) [AddCommMonoid E] [Module R E]
    (C : Set E) : IsPointedCone R E C ↔
      C.Nonempty ∧ ∀ (x : E), x ∈ C → ∀ (y : E), y ∈ C → ∀ (a b : R),
      0 ≤ a → 0 ≤ b → a • x + b • y ∈ C where
  mp := by -- IsPointedCone → forall_nonneg
    rintro ⟨T, rfl⟩
    constructor
    · exact ⟨0, T.zero_mem'⟩
    · rintro x hx y hy a b ha hb
      exact T.add_mem' (T.smul_mem' ⟨a, ha⟩ hx) (T.smul_mem' ⟨b, hb⟩ hy)
  mpr := by -- forall_nonneg → IsPointedCone
    rintro ⟨h1, h2⟩
    use {
      carrier := C,
      zero_mem' := by
        obtain ⟨x, hx⟩ := h1
        simpa [zero_smul, add_zero] using h2 x hx x hx 0 0 (le_refl _) (le_refl _),
      add_mem' := by
        intro x y hx hy
        simpa [one_smul] using h2 x hx y hy 1 1 zero_le_one zero_le_one,
      smul_mem' := by
        intro c x hx
        have := h2 x hx x hx (c : R) 0 c.property (le_refl 0)
        simp_all
    }

/-- 'infPointedCone' is the smallest element of the set of all pointed cone containing the set s. -/
def infPointedCone (s : Set E) : PointedCone R E :=
  sInf { C : PointedCone R E | s ⊆ C.carrier }

/-- The smallest pointed cone containing the set s is equal to the conical hull generated by s. -/
theorem infPointedCone_eq_conicalHull (s : Set E) :
    infPointedCone R s = conicalHull R s :=
  le_antisymm
    (sInf_le (subset_conicalHull R s))
    (le_sInf (conicalHull_minimal R s))

end PointedConeSection
end PointedCone
