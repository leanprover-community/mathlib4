import Mathlib.Geometry.Manifold.VectorBundle.SmoothSection
import Mathlib.Geometry.Manifold.VectorBundle.Tangent
import Mathlib.Geometry.Manifold.MFDeriv.FDeriv
import Mathlib.Geometry.Manifold.MFDeriv.SpecificFunctions

open Bundle Filter Function

open scoped Bundle Manifold ContDiff

variable {ğ•œ : Type*} [NontriviallyNormedField ğ•œ]

section

variable {E : Type*} [NormedAddCommGroup E]
  [NormedSpace ğ•œ E] {H : Type*} [TopologicalSpace H] (I : ModelWithCorners ğ•œ E H)
  {M : Type*} [TopologicalSpace M] [ChartedSpace H M] [IsManifold I 0 M]

variable (F : Type*) [NormedAddCommGroup F] [NormedSpace ğ•œ F]
  -- `F` model fiber
  (n : WithTop â„•âˆ)
  (V : M â†’ Type*) [TopologicalSpace (TotalSpace F V)]
  [âˆ€ x, AddCommGroup (V x)] [âˆ€ x, Module ğ•œ (V x)]
  [âˆ€ x : M, TopologicalSpace (V x)] [âˆ€ x, IsTopologicalAddGroup (V x)]
  [âˆ€ x, ContinuousSMul ğ•œ (V x)]
  [FiberBundle F V] [VectorBundle ğ•œ F V]
  -- `V` vector bundle

def bar (a : ğ•œ) : TangentSpace ğ“˜(ğ•œ, ğ•œ) a â‰ƒL[ğ•œ] ğ•œ where
  toFun v := v
  invFun v := v
  map_add' := by simp
  map_smul' := by simp

variable (x : M)

structure CovariantDerivative where
  toFun : (Î  x : M, TangentSpace I x) â†’ (Î  x : M, V x) â†’ (Î  x : M, V x)
  addX : âˆ€ (X X' : Î  x : M, TangentSpace I x) (Ïƒ : Î  x : M, V x),
    toFun (X + X') Ïƒ = toFun X Ïƒ + toFun X' Ïƒ
  smulX : âˆ€ (X : Î  x : M, TangentSpace I x) (Ïƒ : Î  x : M, V x) (f : M â†’ ğ•œ),
    toFun (f â€¢ X) Ïƒ = f â€¢ toFun X Ïƒ
  addÏƒ : âˆ€ (X : Î  x : M, TangentSpace I x) (Ïƒ Ïƒ' : Î  x : M, V x) (x : M),
    MDifferentiableAt I (I.prod ğ“˜(ğ•œ, F)) (fun x â†¦ TotalSpace.mk' F x (Ïƒ x)) x
    â†’ MDifferentiableAt I (I.prod ğ“˜(ğ•œ, F)) (fun x â†¦ TotalSpace.mk' F x (Ïƒ' x)) x
    â†’ toFun X (Ïƒ + Ïƒ') x = toFun X Ïƒ x + toFun X Ïƒ' x
  leibniz : âˆ€ (X : Î  x : M, TangentSpace I x) (Ïƒ : Î  x : M, V x) (f : M â†’ ğ•œ) (x : M),
    MDifferentiableAt I (I.prod ğ“˜(ğ•œ, F)) (fun x â†¦ TotalSpace.mk' F x (Ïƒ x)) x
    â†’ MDifferentiableAt I ğ“˜(ğ•œ, ğ•œ) f x
    â†’ toFun X (f â€¢ Ïƒ) x = (f â€¢ toFun X Ïƒ) x + (bar _ <| mfderiv I ğ“˜(ğ•œ, ğ•œ) f x (X x)) â€¢ Ïƒ x
  do_not_read : âˆ€ (X : Î  x : M, TangentSpace I x) {Ïƒ : Î  x : M, V x} {x : M},
    Â¬ MDifferentiableAt I (I.prod ğ“˜(ğ•œ, F)) (fun x â†¦ TotalSpace.mk' F x (Ïƒ x)) x â†’ toFun X Ïƒ x = 0

namespace CovariantDerivative

omit [IsManifold I 0 M] [âˆ€ (x : M), IsTopologicalAddGroup (V x)] [âˆ€ (x : M), ContinuousSMul ğ•œ (V x)]
  [VectorBundle ğ•œ F V] in
@[simp]
lemma zeroX (cov : CovariantDerivative I F V) (Ïƒ : Î  x : M, V x) : cov.toFun 0 Ïƒ = 0 := by
  have := cov.addX (0 : (x : M) â†’ TangentSpace I x) (0 : (x : M) â†’ TangentSpace I x) Ïƒ
  simpa using this

@[simp]
lemma zeroÏƒ (cov : CovariantDerivative I F V) (X : Î  x : M, TangentSpace I x) : cov.toFun X 0 = 0 := by
  ext x
  have : MDifferentiableAt I (I.prod ğ“˜(ğ•œ, F)) (fun x â†¦ TotalSpace.mk' F x (0 : V x)) x := by
    sorry
    -- apply mdifferentiableAt_const (I := I) (I' := I.prod ğ“˜(ğ•œ, F)) (c := (0 : V x)) (x := x) fails
  have := cov.addÏƒ X (0 : (x : M) â†’ V x) (0 : (x : M) â†’ V x) x this this
  simpa using this

lemma smul_const_Ïƒ (cov : CovariantDerivative I F V)
    (X : Î  x : M, TangentSpace I x) (Ïƒ : Î  x : M, V x) (a : ğ•œ) :
    cov.toFun X (a â€¢ Ïƒ) = a â€¢ cov.toFun X Ïƒ := by
  ext x
  by_cases hÏƒ : MDifferentiableAt I (I.prod ğ“˜(ğ•œ, F)) (fun x â†¦ TotalSpace.mk' F x (Ïƒ x)) x
  Â· simpa using cov.leibniz X Ïƒ (fun _ â†¦ a) x hÏƒ mdifferentiable_const.mdifferentiableAt
  have hÏƒâ‚‚ : cov.toFun X (a â€¢ Ïƒ) x = 0 := by
    by_cases ha: a = 0
    Â· simp [ha]
    refine cov.do_not_read X ?_
    contrapose! hÏƒ
    simp at hÏƒ
    have : MDifferentiableAt I (I.prod ğ“˜(ğ•œ, F)) (fun x â†¦ TotalSpace.mk' F x (aâ»Â¹ â€¢ a â€¢ Ïƒ x)) x := by
      sorry -- have := hÏƒ.const_smul aâ»Â¹ --(E' := H Ã— F) fails to unify
    apply this.congr_of_eventuallyEq
    filter_upwards with x
    congr
    exact (eq_inv_smul_iffâ‚€ ha).mpr rfl
  simp [cov.do_not_read X hÏƒ, hÏƒâ‚‚]

/-- A convex combination of covariant derivatives is a covariant derivative. -/
@[simps]
def convexCombination (cov cov' : CovariantDerivative I F V) (t : ğ•œ) :
    CovariantDerivative I F V where
  toFun X s := (t â€¢ (cov.toFun X s)) + (1 - t) â€¢ (cov'.toFun X s)
  addX X X' Ïƒ := by simp only [cov.addX, cov'.addX]; module
  smulX X Ïƒ f := by simp only [cov.smulX, cov'.smulX]; module
  addÏƒ X Ïƒ Ïƒ' x hÏƒ hÏƒ' := by
    simp [cov.addÏƒ X Ïƒ Ïƒ' x hÏƒ hÏƒ', cov'.addÏƒ X Ïƒ Ïƒ' x hÏƒ hÏƒ']
    module
  leibniz X Ïƒ f x hÏƒ hf := by
    simp [cov.leibniz X Ïƒ f x hÏƒ hf, cov'.leibniz X Ïƒ f x hÏƒ hf]
    module
  do_not_read X {Ïƒ} {x} hÏƒ := by simp [cov.do_not_read X hÏƒ, cov'.do_not_read X hÏƒ]

end CovariantDerivative

end

section

variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ğ•œ E]
variable {E' : Type*} [NormedAddCommGroup E'] [NormedSpace ğ•œ E']

@[simp]
theorem Bundle.Trivial.mdifferentiableAt_iff (Ïƒ : (x : E) â†’ Trivial E E' x) (e : E) :
    MDifferentiableAt ğ“˜(ğ•œ, E) (ğ“˜(ğ•œ, E).prod ğ“˜(ğ•œ, E')) (fun x â†¦ TotalSpace.mk' E' x (Ïƒ x)) e â†”
    DifferentiableAt ğ•œ Ïƒ e := by
  sorry

attribute [simp] mdifferentiableAt_iff_differentiableAt

@[simps]
noncomputable def CovariantDerivative.trivial : CovariantDerivative ğ“˜(ğ•œ, E) E'
  (Bundle.Trivial E E') where
  toFun X s := fun x â†¦ fderiv ğ•œ s x (X x)
  addX X X' Ïƒ := by ext; simp
  smulX X Ïƒ c' := by ext; simp
  addÏƒ X Ïƒ Ïƒ' e hÏƒ hÏƒ' := by
    rw [Bundle.Trivial.mdifferentiableAt_iff] at hÏƒ hÏƒ'
    rw [fderiv_add hÏƒ hÏƒ']
    rfl
  leibniz X Ïƒ f x hÏƒ hf := by
    have : fderiv ğ•œ (f â€¢ Ïƒ) x = f x â€¢ fderiv ğ•œ Ïƒ x + (fderiv ğ•œ f x).smulRight (Ïƒ x) :=
      fderiv_smul (by simp_all) (by simp_all)
    simp [this, bar]
    rfl
  do_not_read X Ïƒ x hÏƒ := by
    rw [Bundle.Trivial.mdifferentiableAt_iff] at hÏƒ
    simp [fderiv_zero_of_not_differentiableAt hÏƒ]

end
