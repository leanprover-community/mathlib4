/-
Copyright (c) 2025 Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Patrick Massot, Michael Rothgang
-/
import Mathlib.Geometry.Manifold.VectorBundle.CovariantDerivative.Basic

/-!
# Torsion of a covariant derivative

- define torsion of a covariant derivative (and its local version)
- torsion-free ness (local and global version)
- prove: torsion-freeness on `s` can be checked using a local frame on `s`

TODO: add a more complete doc-string

-/

open Bundle Filter Module Topology Set

open scoped Bundle Manifold ContDiff

variable {ùïú : Type*} [NontriviallyNormedField ùïú]
  {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] {H : Type*} [TopologicalSpace H]
  {I : ModelWithCorners ‚Ñù E H} {M : Type*} [TopologicalSpace M] [ChartedSpace H M] {x : M}
  {F : Type*} [NormedAddCommGroup F] [NormedSpace ‚Ñù F] (n : WithTop ‚Ñï‚àû) {V : M ‚Üí Type*}
  [TopologicalSpace (TotalSpace F V)] [‚àÄ x, AddCommGroup (V x)] [‚àÄ x, Module ‚Ñù (V x)]
  [‚àÄ x : M, TopologicalSpace (V x)] [FiberBundle F V]

-- TODO: where is a good namespace for this?
/-- The torsion of a covariant derivative on the tangent bundle `TM` -/
noncomputable def Bundle.torsion
    (f : (Œ† x : M, TangentSpace I x) ‚Üí (Œ† x : M, TangentSpace I x) ‚Üí (Œ† x : M, TangentSpace I x)) :
    (Œ† x : M, TangentSpace I x) ‚Üí (Œ† x : M, TangentSpace I x) ‚Üí (Œ† x : M, TangentSpace I x) :=
  fun X Y ‚Ü¶ f X Y - f Y X - VectorField.mlieBracket I X Y

variable
  {f g : (Œ† x : M, TangentSpace I x) ‚Üí (Œ† x : M, TangentSpace I x) ‚Üí (Œ† x : M, TangentSpace I x)}
  {X X' Y : Œ† x : M, TangentSpace I x}

variable (f X) in
lemma torsion_self : torsion f X X = 0 := by
  simp [torsion]

variable (X Y) in
lemma torsion_antisymm : torsion f X Y = - torsion f Y X := by
  simp only [torsion]
  rw [VectorField.mlieBracket_swap]
  module

set_option linter.style.commandStart false -- new delaborators confuse the pretty-printer

namespace IsCovariantDerivativeOn

variable [h : IsManifold I ‚àû M]
variable {U : Set M} (hf : IsCovariantDerivativeOn E f U)

variable (Y) in
lemma torsion_add_left_apply [CompleteSpace E]
    (hf : IsCovariantDerivativeOn E f U) (hx : x ‚àà U)
    (hX : MDiffAt (T% X) x) (hX' : MDiffAt (T% X') x) :
    torsion f (X + X') Y x = torsion f X Y x + torsion f X' Y x := by
  simp [torsion, hf.addX X X' (x := x)]
  rw [hf.addœÉ Y hX hX', VectorField.mlieBracket_add_left hX hX']
  module

lemma torsion_add_right_apply [CompleteSpace E] (hf : IsCovariantDerivativeOn E f U) (hx : x ‚àà U)
    (hX : MDiffAt (T% X) x)
    (hX' : MDiffAt (T% X') x) :
    torsion f Y (X + X') x = torsion f Y X x + torsion f Y X' x := by
  rw [torsion_antisymm, Pi.neg_apply,
    hf.torsion_add_left_apply _ hx hX hX', torsion_antisymm Y, torsion_antisymm Y]
  simp; abel

variable (Y) in
lemma torsion_smul_left_apply [CompleteSpace E]
    {F : ((x : M) ‚Üí TangentSpace I x) ‚Üí ((x : M) ‚Üí TangentSpace I x) ‚Üí (x : M) ‚Üí TangentSpace I x}
    (hF : IsCovariantDerivativeOn E F U) (hx : x ‚àà U)
    -- TODO: making hx an auto-param := by trivial doesn't fire at the application sites below
    {f : M ‚Üí ‚Ñù} (hf : MDiffAt f x) (hX : MDiffAt (T% X) x) :
    torsion F (f ‚Ä¢ X) Y x = f x ‚Ä¢ torsion F X Y x := by
  simp only [torsion, Pi.sub_apply, hF.smulX X Y f]
  rw [hF.leibniz Y hX hf hx, VectorField.mlieBracket_smul_left hf hX]
  simp [bar, smul_sub]
  abel

variable (X) in
lemma torsion_smul_right_apply [CompleteSpace E]
    {F : ((x : M) ‚Üí TangentSpace I x) ‚Üí ((x : M) ‚Üí TangentSpace I x) ‚Üí (x : M) ‚Üí TangentSpace I x}
    (hF : IsCovariantDerivativeOn E F U) (hx : x ‚àà U)
    {f : M ‚Üí ‚Ñù} (hf : MDiffAt f x) (hX : MDiffAt (T% Y) x) :
    torsion F X (f ‚Ä¢ Y) x = f x ‚Ä¢ torsion F X Y x := by
  rw [torsion_antisymm, Pi.neg_apply, hF.torsion_smul_left_apply X hx hf hX, torsion_antisymm X]
  simp

end IsCovariantDerivativeOn

/-- `f` is torsion-free on `U` if its torsion vanishes at each `x ‚àà U` -/
noncomputable def IsTorsionFreeOn
    (f : (Œ† x : M, TangentSpace I x) ‚Üí (Œ† x : M, TangentSpace I x) ‚Üí (Œ† x : M, TangentSpace I x))
    (U : Set M) : Prop :=
  ‚àÄ x ‚àà U, ‚àÄ X Y : Œ† x : M, TangentSpace I x, torsion f X Y x = 0

namespace IsTorsionFreeOn

section changing_set

/-! Changing set
In this changing we change `s` in `IsTorsionFreeOn F f s`.
-/

lemma mono {s t : Set M} (hf : IsTorsionFreeOn f t) (hst : s ‚äÜ t) : IsTorsionFreeOn f s :=
  fun _ hx _ _ ‚Ü¶ hf _ (hst hx) ..

lemma iUnion {Œπ : Type*} {s : Œπ ‚Üí Set M} (hf : ‚àÄ i, IsTorsionFreeOn f (s i)) :
    IsTorsionFreeOn f (‚ãÉ i, s i) := by
  rintro x ‚ü®si, ‚ü®i, hi‚ü©, hxsi‚ü© X Y
  exact hf i x (by simp [hi, hxsi]) X Y

end changing_set

/- Congruence properties -/
section

-- unused?
lemma congr {s : Set M} (h : IsTorsionFreeOn f s)
    (hfg : ‚àÄ {X Y : Œ† x : M, TangentSpace I x}, ‚àÄ {x}, x ‚àà s ‚Üí f X Y x = g X Y x) :
    IsTorsionFreeOn g s := by
  intro x hx X Y
  specialize h x hx X Y
  -- now, use torsion congruence lemma, i.e. tensoriality of sorts!
  -- TODO: generalise tensoriality to the local setting!
  sorry

end

end IsTorsionFreeOn

namespace CovariantDerivative

variable [h : IsManifold I ‚àû M]
-- The torsion tensor of a covariant derivative on the tangent bundle `TM`.
variable {cov : CovariantDerivative I E (TangentSpace I : M ‚Üí Type _)}

variable {U : Set M} (hf : IsCovariantDerivativeOn E f U)

-- TODO: prove applied versions of these, for IsCovariantDerivativeOn --- using tensoriality, later!
variable (f X) in
@[simp]
lemma torsion_zero : torsion cov 0 X = 0 := by
  ext x
  simp [torsion]

variable (X) in
@[simp]
lemma torsion_zero' : torsion cov X 0 = 0 := by rw [torsion_antisymm, torsion_zero]; simp

variable (Y) in
lemma torsion_add_left [CompleteSpace E]
    (hX : MDiff (T% X)) (hX' : MDiff (T% X')) :
    torsion cov (X + X') Y = torsion cov X Y + torsion cov X' Y := by
  ext x
  exact cov.isCovariantDerivativeOn.torsion_add_left_apply _ (by trivial) (hX x) (hX' x)

lemma torsion_add_right [CompleteSpace E]
    (hX : MDiff (T% X)) (hX' : MDiff (T% X')) :
    torsion cov Y (X + X') = torsion cov Y X + torsion cov Y X' := by
  rw [torsion_antisymm, torsion_add_left _ hX hX', torsion_antisymm X, torsion_antisymm X']; module

variable (Y) in
lemma torsion_smul_left [CompleteSpace E] {f : M ‚Üí ‚Ñù} (hf : MDiff f) (hX : MDiff (T% X)) :
    torsion cov (f ‚Ä¢ X) Y = f ‚Ä¢ torsion cov X Y := by
  ext x
  exact cov.isCovariantDerivativeOn.torsion_smul_left_apply _ (by trivial) (hf x) (hX x)

variable (X) in
lemma torsion_smul_right [CompleteSpace E] {f : M ‚Üí ‚Ñù} (hf : MDiff f) (hY : MDiff (T% Y)) :
    torsion cov X (f ‚Ä¢ Y) = f ‚Ä¢ torsion cov X Y := by
  ext x
  exact cov.isCovariantDerivativeOn.torsion_smul_right_apply _ (by trivial) (hf x) (hY x)

/-- The torsion of a covariant derivative is tensorial:
the value of `torsion cov X Y` at `x‚ÇÄ` depends only on `X x‚ÇÄ` and `Y x‚ÇÄ`. -/
def torsion_tensorial [T2Space M] [IsManifold I ‚àû M] [FiniteDimensional ‚Ñù E]
    [FiniteDimensional ‚Ñù F] [VectorBundle ‚Ñù F V] [ContMDiffVectorBundle 1 F V I]
    {X X' Y Y' : Œ† x : M, TangentSpace I x} {x‚ÇÄ : M}
    (hX : MDiffAt (T% X) x‚ÇÄ) (hX' : MDiffAt (T% X') x‚ÇÄ)
    (hY : MDiffAt (T% Y) x‚ÇÄ) (hY' : MDiffAt (T% Y') x‚ÇÄ)
    (hXX' : X x‚ÇÄ = X' x‚ÇÄ) (hYY' : Y x‚ÇÄ = Y' x‚ÇÄ) :
    (torsion cov X Y) x‚ÇÄ = (torsion cov X' Y') x‚ÇÄ := by
  apply tensoriality_criterion‚ÇÇ I E (TangentSpace I) E (TangentSpace I) hX hX' hY hY' hXX' hYY'
  ¬∑ intro f œÉ œÑ hf hœÉ
    exact cov.isCovariantDerivativeOn.torsion_smul_left_apply _ (by trivial) hf hœÉ
  ¬∑ intro œÉ œÉ' œÑ hœÉ hœÉ'
    exact cov.isCovariantDerivativeOn.torsion_add_left_apply _ (by trivial) hœÉ hœÉ'
  ¬∑ intros f œÉ œÉ' hf hœÉ'
    exact cov.isCovariantDerivativeOn.torsion_smul_right_apply _ (by trivial) hf hœÉ'
  ¬∑ intro œÉ œÑ œÑ' hœÑ hœÑ'
    exact cov.isCovariantDerivativeOn.torsion_add_right_apply (by trivial) hœÑ hœÑ'

-- TODO: define a torsion tensor of a covariant derivative,
-- and related torsion-freeness to this
-- (That will not work for torsion-freeness on a set, though.)

set_option linter.style.commandStart true

-- TODO: generalise tensoriality result above to `IsCovariantDerivativeOn`,
-- so it would apply here as well

variable (cov) in
/-- A covariant derivation is called **torsion-free** iff its torsion tensor vanishes. -/
def IsTorsionFree : Prop := torsion cov = 0

@[simp]
lemma isTorsionFreeOn_univ : IsTorsionFreeOn cov univ ‚Üî IsTorsionFree cov := by
  simp only [IsTorsionFree, IsTorsionFreeOn]
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ by simp [h]‚ü©
  ext X Y x
  simp [h x]

/-- If a covariant derivative `cov` is torsion-free on each set in an open cover,
it is torsion-free. -/
def of_isTorsionFreeOn_of_open_cover {Œπ : Type*} {s : Œπ ‚Üí Set M}
    (hf : ‚àÄ i, IsTorsionFreeOn cov (s i)) (hs : ‚ãÉ i, s i = Set.univ) :
    IsTorsionFree cov := by
  rw [‚Üê isTorsionFreeOn_univ, ‚Üê hs]
  exact IsTorsionFreeOn.iUnion hf

lemma isTorsionFree_def : IsTorsionFree cov ‚Üî torsion cov = 0 := by simp [IsTorsionFree]

-- This should be obvious; am I doing something wrong?
lemma isTorsionFree_iff : IsTorsionFree cov ‚Üî
    ‚àÄ X Y, cov X Y - cov Y X = VectorField.mlieBracket I X Y := by
  simp [IsTorsionFree]
  constructor
  ¬∑ intro h X Y
    have : torsion cov X Y = 0 := by simp [h]
    -- XXX: abel, ring, module and grind all fail here
    exact eq_of_sub_eq_zero this
  ¬∑ intro h
    ext X Y x
    specialize h X Y
    apply congr_fun
    simp_all [torsion]

variable {n} in
lemma aux1 {Œπ : Type*} [Fintype Œπ]
    {f : (Œ† x : M, TangentSpace I x) ‚Üí (Œ† x : M, TangentSpace I x) ‚Üí (Œ† x : M, TangentSpace I x)}
    {U : Set M} {s : Œπ ‚Üí (x : M) ‚Üí TangentSpace I x} (hs : IsLocalFrameOn I E n s U) (hx : x ‚àà U)
    (X Y : (x : M) ‚Üí TangentSpace I x) :
    torsion f X Y x = ‚àë i, (hs.repr i) X x ‚Ä¢ torsion f (s i) Y x :=
  have hU : U ‚àà ùìù x := sorry
  have aux := hs.repr_spec X hU
  have hX : X x = ‚àë i, (hs.repr i) X x ‚Ä¢ s i x := sorry
  calc torsion f X Y x
    _ = torsion f (fun x ‚Ü¶ ‚àë i, (hs.repr i) X x ‚Ä¢ s i x) Y x := by
      sorry -- tensoriality and [hX]
    _ = ‚àë i, (torsion f (fun x ‚Ü¶ (hs.repr i) X x ‚Ä¢ s i x) Y x) := sorry
    _ = ‚àë i, (hs.repr i) X x ‚Ä¢ (torsion f (s i) Y x) := sorry

-- Weaker hypotheses possible, e.g. local frame on U ‚àà ùìù x, while a cov. derivative on s ‚àã x
variable {n} in
lemma aux2 {Œπ : Type*} [Fintype Œπ] [CompleteSpace E]
    {f : (Œ† x : M, TangentSpace I x) ‚Üí (Œ† x : M, TangentSpace I x) ‚Üí (Œ† x : M, TangentSpace I x)}
    {U : Set M} {s : Œπ ‚Üí (x : M) ‚Üí TangentSpace I x}
    (hf : IsCovariantDerivativeOn E f U) (hs : IsLocalFrameOn I E n s U) (hx : x ‚àà U)
    (X Y : (x : M) ‚Üí TangentSpace I x) :
    torsion f X Y x = ‚àë i, (hs.repr i) Y x ‚Ä¢ torsion f X (s i) x :=
  have hU : U ‚àà ùìù x := sorry
  have aux := hs.repr_spec Y hU
  have hY : Y x = ‚àë i, (hs.repr i) Y x ‚Ä¢ s i x := hs.repr_sum_eq Y hx
  calc torsion f X Y x
    _ = torsion f X (fun x ‚Ü¶ ‚àë i, (hs.repr i) Y x ‚Ä¢ s i x) x := by
      sorry -- tensoriality and [hY]
    _ = ‚àë i, (torsion f X (fun x ‚Ü¶ (hs.repr i) Y x ‚Ä¢ s i x) x) := sorry
    _ = ‚àë i, (hs.repr i) Y x ‚Ä¢ (torsion f X (s i) x) := by
      congr with i
      have hsi : MDiffAt (hs.repr i Y) x := sorry
      have hsi' : MDiffAt (T% (s i)) x := sorry
      have := hf.torsion_smul_right_apply (X := X) (Y := s i) (f := (hs.repr i) Y) hx hsi hsi'
      rw [‚Üê this]
      congr

/-- We can test torsion-freeness on a set using a local frame. -/
lemma _root_.IsCovariantDerivativeOn.isTorsionFreeOn_iff_localFrame
    {Œπ : Type*} [Fintype Œπ] [CompleteSpace E]
    {f : (Œ† x : M, TangentSpace I x) ‚Üí (Œ† x : M, TangentSpace I x) ‚Üí (Œ† x : M, TangentSpace I x)}
    {U : Set M} {s : Œπ ‚Üí (x : M) ‚Üí TangentSpace I x}
    (hf: IsCovariantDerivativeOn E f U) (hs : IsLocalFrameOn I E n s U) :
    IsTorsionFreeOn f U ‚Üî ‚àÄ i j, ‚àÄ x ‚àà U, torsion f (s i) (s j) x = 0 := by
  rw [IsTorsionFreeOn]
  refine ‚ü®fun h i j x hx ‚Ü¶ h x hx (s i) (s j), fun h ‚Ü¶ ?_‚ü©
  intro x hx X Y
  rw [aux1 hs hx]
  calc
    _ = ‚àë i, (hs.repr i) X x ‚Ä¢ ‚àë j, (hs.repr j) Y x ‚Ä¢ torsion f (s i) (s j) x := by
      congr!
      rw [aux2 hf hs hx]
    _ = ‚àë i, (hs.repr i) X x ‚Ä¢ ‚àë j, (hs.repr j) Y x ‚Ä¢ 0 := by
      congr! with i _ j _
      exact h i j x hx
    _ = 0 := by simp

-- lemma the trivial connection on a normed space is torsion-free
-- lemma trivial.isTorsionFree : IsTorsionFree (TangentBundle ùìò(‚Ñù, E) E) := sorry

-- lemma: tangent bundle of E is trivial -> there exists a single trivialisation with baseSet univ
-- make a new abbrev Bundle.Trivial.globalFrame --- which is localFrame for the std basis of F,
--    w.r.t. to this trivialisation
-- add lemmas: globalFrame is contMDiff globally

-- proof of above lemma: write sections s and t in the global frame above
-- by linearity (proven above), suffices to consider s = s^i and t = s^j (two sections in the frame)
-- compute: their Lie bracket is zero
-- compute: the other two terms cancel, done

end CovariantDerivative
