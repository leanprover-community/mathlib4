/-
Copyright (c) 2020 Nicol√≤ Cavalleri. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Nicol√≤ Cavalleri
-/
import Mathlib.Geometry.Manifold.Algebra.Structures

/-!
# Algebraic structures over smooth functions

In this file, we define instances of algebraic structures over smooth functions.
-/


noncomputable section

open scoped Manifold

open TopologicalSpace

variable {ùïú : Type*} [NontriviallyNormedField ùïú] {E : Type*} [NormedAddCommGroup E]
  [NormedSpace ùïú E] {E' : Type*} [NormedAddCommGroup E'] [NormedSpace ùïú E'] {H : Type*}
  [TopologicalSpace H] {I : ModelWithCorners ùïú E H} {H' : Type*} [TopologicalSpace H']
  {I' : ModelWithCorners ùïú E' H'} {N : Type*} [TopologicalSpace N] [ChartedSpace H N]
  {E'' : Type*} [NormedAddCommGroup E''] [NormedSpace ùïú E''] {H'' : Type*} [TopologicalSpace H'']
  {I'' : ModelWithCorners ùïú E'' H''} {N' : Type*} [TopologicalSpace N'] [ChartedSpace H'' N']

namespace SmoothMap

@[to_additive]
protected instance instMul {G : Type*} [Mul G] [TopologicalSpace G] [ChartedSpace H' G]
    [SmoothMul I' G] : Mul C^‚àû‚üÆI, N; I', G‚üØ :=
  ‚ü®fun f g => ‚ü®f * g, f.smooth.mul g.smooth‚ü©‚ü©

@[to_additive (attr := simp)]
theorem coe_mul {G : Type*} [Mul G] [TopologicalSpace G] [ChartedSpace H' G] [SmoothMul I' G]
    (f g : C^‚àû‚üÆI, N; I', G‚üØ) : ‚áë(f * g) = f * g :=
  rfl

@[to_additive (attr := simp)]
theorem mul_comp {G : Type*} [Mul G] [TopologicalSpace G] [ChartedSpace H' G] [SmoothMul I' G]
    (f g : C^‚àû‚üÆI'', N'; I', G‚üØ) (h : C^‚àû‚üÆI, N; I'', N'‚üØ) : (f * g).comp h = f.comp h * g.comp h :=
  rfl

@[to_additive]
protected instance instOne {G : Type*} [One G] [TopologicalSpace G] [ChartedSpace H' G] :
    One C^‚àû‚üÆI, N; I', G‚üØ :=
  ‚ü®ContMDiffMap.const (1 : G)‚ü©

@[to_additive (attr := simp)]
theorem coe_one {G : Type*} [One G] [TopologicalSpace G] [ChartedSpace H' G] :
    ‚áë(1 : C^‚àû‚üÆI, N; I', G‚üØ) = 1 :=
  rfl

instance instNSMul {G : Type*} [AddMonoid G] [TopologicalSpace G] [ChartedSpace H' G]
    [SmoothAdd I' G] : SMul ‚Ñï C^‚àû‚üÆI, N; I', G‚üØ where
  smul n f := ‚ü®n ‚Ä¢ (f : N ‚Üí G), (smooth_nsmul n).comp f.smooth‚ü©

@[to_additive existing]
instance instPow {G : Type*} [Monoid G] [TopologicalSpace G] [ChartedSpace H' G] [SmoothMul I' G] :
    Pow C^‚àû‚üÆI, N; I', G‚üØ ‚Ñï where
  pow f n := ‚ü®(f : N ‚Üí G) ^ n, (smooth_pow n).comp f.smooth‚ü©

@[to_additive (attr := simp)]
theorem coe_pow {G : Type*} [Monoid G] [TopologicalSpace G] [ChartedSpace H' G] [SmoothMul I' G]
    (f : C^‚àû‚üÆI, N; I', G‚üØ) (n : ‚Ñï) :
    ‚áë(f ^ n) = (f : N ‚Üí G) ^ n :=
  rfl

section GroupStructure

/-!
### Group structure

In this section we show that smooth functions valued in a Lie group inherit a group structure
under pointwise multiplication.
-/

@[to_additive]
instance semigroup {G : Type*} [Semigroup G] [TopologicalSpace G] [ChartedSpace H' G]
    [SmoothMul I' G] : Semigroup C^‚àû‚üÆI, N; I', G‚üØ :=
  DFunLike.coe_injective.semigroup _ coe_mul

@[to_additive]
instance monoid {G : Type*} [Monoid G] [TopologicalSpace G] [ChartedSpace H' G]
    [SmoothMul I' G] : Monoid C^‚àû‚üÆI, N; I', G‚üØ :=
  DFunLike.coe_injective.monoid _ coe_one coe_mul coe_pow

/-- Coercion to a function as a `MonoidHom`. Similar to `MonoidHom.coeFn`. -/
@[to_additive (attr := simps) "Coercion to a function as an `AddMonoidHom`.
  Similar to `AddMonoidHom.coeFn`."]
def coeFnMonoidHom {G : Type*} [Monoid G] [TopologicalSpace G] [ChartedSpace H' G]
    [SmoothMul I' G] : C^‚àû‚üÆI, N; I', G‚üØ ‚Üí* N ‚Üí G where
  toFun := DFunLike.coe
  map_one' := coe_one
  map_mul' := coe_mul

variable (I N)

/-- For a manifold `N` and a smooth homomorphism `œÜ` between Lie groups `G'`, `G''`, the
'left-composition-by-`œÜ`' group homomorphism from `C^‚àû‚üÆI, N; I', G'‚üØ` to `C^‚àû‚üÆI, N; I'', G''‚üØ`. -/
@[to_additive "For a manifold `N` and a smooth homomorphism `œÜ` between additive Lie groups `G'`,
`G''`, the 'left-composition-by-`œÜ`' group homomorphism from `C^‚àû‚üÆI, N; I', G'‚üØ` to
`C^‚àû‚üÆI, N; I'', G''‚üØ`."]
def compLeftMonoidHom {G' : Type*} [Monoid G'] [TopologicalSpace G'] [ChartedSpace H' G']
    [SmoothMul I' G'] {G'' : Type*} [Monoid G''] [TopologicalSpace G''] [ChartedSpace H'' G'']
    [SmoothMul I'' G''] (œÜ : G' ‚Üí* G'') (hœÜ : Smooth I' I'' œÜ) :
    C^‚àû‚üÆI, N; I', G'‚üØ ‚Üí* C^‚àû‚üÆI, N; I'', G''‚üØ where
  toFun f := ‚ü®œÜ ‚àò f, fun x => (hœÜ.smooth _).comp x (f.contMDiff x)‚ü©
  map_one' := by ext; show œÜ 1 = 1; simp
  map_mul' f g := by ext x; show œÜ (f x * g x) = œÜ (f x) * œÜ (g x); simp

variable (I') {N}

-- Porting note (#11215): TODO: generalize to any smooth map instead of `Set.inclusion`
/-- For a Lie group `G` and open sets `U ‚äÜ V` in `N`, the 'restriction' group homomorphism from
`C^‚àû‚üÆI, V; I', G‚üØ` to `C^‚àû‚üÆI, U; I', G‚üØ`. -/
@[to_additive "For an additive Lie group `G` and open sets `U ‚äÜ V` in `N`, the 'restriction' group
homomorphism from `C^‚àû‚üÆI, V; I', G‚üØ` to `C^‚àû‚üÆI, U; I', G‚üØ`."]
def restrictMonoidHom (G : Type*) [Monoid G] [TopologicalSpace G] [ChartedSpace H' G]
    [SmoothMul I' G] {U V : Opens N} (h : U ‚â§ V) : C^‚àû‚üÆI, V; I', G‚üØ ‚Üí* C^‚àû‚üÆI, U; I', G‚üØ where
  toFun f := ‚ü®f ‚àò Set.inclusion h, f.smooth.comp (smooth_inclusion h)‚ü©
  map_one' := rfl
  map_mul' _ _ := rfl

variable {I I'}

@[to_additive]
instance commMonoid {G : Type*} [CommMonoid G] [TopologicalSpace G] [ChartedSpace H' G]
    [SmoothMul I' G] : CommMonoid C^‚àû‚üÆI, N; I', G‚üØ :=
  DFunLike.coe_injective.commMonoid _ coe_one coe_mul coe_pow

@[to_additive]
instance group {G : Type*} [Group G] [TopologicalSpace G] [ChartedSpace H' G] [LieGroup I' G] :
    Group C^‚àû‚üÆI, N; I', G‚üØ :=
  { SmoothMap.monoid with
    inv := fun f => ‚ü®fun x => (f x)‚Åª¬π, f.smooth.inv‚ü©
    inv_mul_cancel := fun a => by ext; exact inv_mul_cancel _
    div := fun f g => ‚ü®f / g, f.smooth.div g.smooth‚ü©
    div_eq_mul_inv := fun f g => by ext; exact div_eq_mul_inv _ _ }

@[to_additive (attr := simp)]
theorem coe_inv {G : Type*} [Group G] [TopologicalSpace G] [ChartedSpace H' G] [LieGroup I' G]
    (f : C^‚àû‚üÆI, N; I', G‚üØ) : ‚áëf‚Åª¬π = (‚áëf)‚Åª¬π :=
  rfl

@[to_additive (attr := simp)]
theorem coe_div {G : Type*} [Group G] [TopologicalSpace G] [ChartedSpace H' G] [LieGroup I' G]
    (f g : C^‚àû‚üÆI, N; I', G‚üØ) : ‚áë(f / g) = f / g :=
  rfl

@[to_additive]
instance commGroup {G : Type*} [CommGroup G] [TopologicalSpace G] [ChartedSpace H' G]
    [LieGroup I' G] : CommGroup C^‚àû‚üÆI, N; I', G‚üØ :=
  { SmoothMap.group, SmoothMap.commMonoid with }

end GroupStructure

section RingStructure

/-!
### Ring structure

In this section we show that smooth functions valued in a smooth ring `R` inherit a ring structure
under pointwise multiplication.
-/


instance semiring {R : Type*} [Semiring R] [TopologicalSpace R] [ChartedSpace H' R]
    [SmoothRing I' R] : Semiring C^‚àû‚üÆI, N; I', R‚üØ :=
  { SmoothMap.addCommMonoid,
    SmoothMap.monoid with
    left_distrib := fun a b c => by ext; exact left_distrib _ _ _
    right_distrib := fun a b c => by ext; exact right_distrib _ _ _
    zero_mul := fun a => by ext; exact zero_mul _
    mul_zero := fun a => by ext; exact mul_zero _ }

instance ring {R : Type*} [Ring R] [TopologicalSpace R] [ChartedSpace H' R] [SmoothRing I' R] :
    Ring C^‚àû‚üÆI, N; I', R‚üØ :=
  { SmoothMap.semiring, SmoothMap.addCommGroup with }

instance commRing {R : Type*} [CommRing R] [TopologicalSpace R] [ChartedSpace H' R]
    [SmoothRing I' R] : CommRing C^‚àû‚üÆI, N; I', R‚üØ :=
  { SmoothMap.semiring, SmoothMap.addCommGroup, SmoothMap.commMonoid with }

variable (I N)

/-- For a manifold `N` and a smooth homomorphism `œÜ` between smooth rings `R'`, `R''`, the
'left-composition-by-`œÜ`' ring homomorphism from `C^‚àû‚üÆI, N; I', R'‚üØ` to `C^‚àû‚üÆI, N; I'', R''‚üØ`. -/
def compLeftRingHom {R' : Type*} [Ring R'] [TopologicalSpace R'] [ChartedSpace H' R']
    [SmoothRing I' R'] {R'' : Type*} [Ring R''] [TopologicalSpace R''] [ChartedSpace H'' R'']
    [SmoothRing I'' R''] (œÜ : R' ‚Üí+* R'') (hœÜ : Smooth I' I'' œÜ) :
    C^‚àû‚üÆI, N; I', R'‚üØ ‚Üí+* C^‚àû‚üÆI, N; I'', R''‚üØ :=
  { SmoothMap.compLeftMonoidHom I N œÜ.toMonoidHom hœÜ,
    SmoothMap.compLeftAddMonoidHom I N œÜ.toAddMonoidHom hœÜ with
    toFun := fun f => ‚ü®œÜ ‚àò f, fun x => (hœÜ.smooth _).comp x (f.contMDiff x)‚ü© }

variable (I') {N}

/-- For a "smooth ring" `R` and open sets `U ‚äÜ V` in `N`, the "restriction" ring homomorphism from
`C^‚àû‚üÆI, V; I', R‚üØ` to `C^‚àû‚üÆI, U; I', R‚üØ`. -/
def restrictRingHom (R : Type*) [Ring R] [TopologicalSpace R] [ChartedSpace H' R] [SmoothRing I' R]
    {U V : Opens N} (h : U ‚â§ V) : C^‚àû‚üÆI, V; I', R‚üØ ‚Üí+* C^‚àû‚üÆI, U; I', R‚üØ :=
  { SmoothMap.restrictMonoidHom I I' R h, SmoothMap.restrictAddMonoidHom I I' R h with
    toFun := fun f => ‚ü®f ‚àò Set.inclusion h, f.smooth.comp (smooth_inclusion h)‚ü© }

variable {I I'}

/-- Coercion to a function as a `RingHom`. -/
@[simps]
def coeFnRingHom {R : Type*} [CommRing R] [TopologicalSpace R] [ChartedSpace H' R]
    [SmoothRing I' R] : C^‚àû‚üÆI, N; I', R‚üØ ‚Üí+* N ‚Üí R :=
  { (coeFnMonoidHom : C^‚àû‚üÆI, N; I', R‚üØ ‚Üí* _), (coeFnAddMonoidHom : C^‚àû‚üÆI, N; I', R‚üØ ‚Üí+ _) with
    toFun := (‚Üë) }

/-- `Function.eval` as a `RingHom` on the ring of smooth functions. -/
def evalRingHom {R : Type*} [CommRing R] [TopologicalSpace R] [ChartedSpace H' R] [SmoothRing I' R]
    (n : N) : C^‚àû‚üÆI, N; I', R‚üØ ‚Üí+* R :=
  (Pi.evalRingHom _ n : (N ‚Üí R) ‚Üí+* R).comp SmoothMap.coeFnRingHom

end RingStructure

section ModuleStructure

/-!
### Semimodule structure

In this section we show that smooth functions valued in a vector space `M` over a normed
field `ùïú` inherit a vector space structure.
-/


instance instSMul {V : Type*} [NormedAddCommGroup V] [NormedSpace ùïú V] :
    SMul ùïú C^‚àû‚üÆI, N; ùìò(ùïú, V), V‚üØ :=
  ‚ü®fun r f => ‚ü®r ‚Ä¢ ‚áëf, smooth_const.smul f.smooth‚ü©‚ü©

@[simp]
theorem coe_smul {V : Type*} [NormedAddCommGroup V] [NormedSpace ùïú V] (r : ùïú)
    (f : C^‚àû‚üÆI, N; ùìò(ùïú, V), V‚üØ) : ‚áë(r ‚Ä¢ f) = r ‚Ä¢ ‚áëf :=
  rfl

@[simp]
theorem smul_comp {V : Type*} [NormedAddCommGroup V] [NormedSpace ùïú V] (r : ùïú)
    (g : C^‚àû‚üÆI'', N'; ùìò(ùïú, V), V‚üØ) (h : C^‚àû‚üÆI, N; I'', N'‚üØ) : (r ‚Ä¢ g).comp h = r ‚Ä¢ g.comp h :=
  rfl

instance module {V : Type*} [NormedAddCommGroup V] [NormedSpace ùïú V] :
    Module ùïú C^‚àû‚üÆI, N; ùìò(ùïú, V), V‚üØ :=
  Function.Injective.module ùïú coeFnAddMonoidHom ContMDiffMap.coe_injective coe_smul

/-- Coercion to a function as a `LinearMap`. -/
@[simps]
def coeFnLinearMap {V : Type*} [NormedAddCommGroup V] [NormedSpace ùïú V] :
    C^‚àû‚üÆI, N; ùìò(ùïú, V), V‚üØ ‚Üí‚Çó[ùïú] N ‚Üí V :=
  { (coeFnAddMonoidHom : C^‚àû‚üÆI, N; ùìò(ùïú, V), V‚üØ ‚Üí+ _) with
    toFun := (‚Üë)
    map_smul' := coe_smul }

end ModuleStructure

section AlgebraStructure

/-!
### Algebra structure

In this section we show that smooth functions valued in a normed algebra `A` over a normed field `ùïú`
inherit an algebra structure.
-/


variable {A : Type*} [NormedRing A] [NormedAlgebra ùïú A] [SmoothRing ùìò(ùïú, A) A]

/-- Smooth constant functions as a `RingHom`. -/
def C : ùïú ‚Üí+* C^‚àû‚üÆI, N; ùìò(ùïú, A), A‚üØ where
  toFun := fun c : ùïú => ‚ü®fun _ => (algebraMap ùïú A) c, smooth_const‚ü©
  map_one' := by ext; exact (algebraMap ùïú A).map_one
  map_mul' c‚ÇÅ c‚ÇÇ := by ext; exact (algebraMap ùïú A).map_mul _ _
  map_zero' := by ext; exact (algebraMap ùïú A).map_zero
  map_add' c‚ÇÅ c‚ÇÇ := by ext; exact (algebraMap ùïú A).map_add _ _

instance algebra : Algebra ùïú C^‚àû‚üÆI, N; ùìò(ùïú, A), A‚üØ :=
  { --SmoothMap.semiring with -- Porting note: Commented this out.
    smul := fun r f => ‚ü®r ‚Ä¢ f, smooth_const.smul f.smooth‚ü©
    toRingHom := SmoothMap.C
    commutes' := fun c f => by ext x; exact Algebra.commutes' _ _
    smul_def' := fun c f => by ext x; exact Algebra.smul_def' _ _ }

/-- Coercion to a function as an `AlgHom`. -/
@[simps]
def coeFnAlgHom : C^‚àû‚üÆI, N; ùìò(ùïú, A), A‚üØ ‚Üí‚Çê[ùïú] N ‚Üí A where
  toFun := (‚Üë)
  commutes' _ := rfl
  -- `(SmoothMap.coeFnRingHom : C^‚àû‚üÆI, N; ùìò(ùïú, A), A‚üØ ‚Üí+* _) with` times out for some reason
  map_zero' := SmoothMap.coe_zero
  map_one' := SmoothMap.coe_one
  map_add' := SmoothMap.coe_add
  map_mul' := SmoothMap.coe_mul

end AlgebraStructure

section ModuleOverContinuousFunctions

/-!
### Structure as module over scalar functions

If `V` is a module over `ùïú`, then we show that the space of smooth functions from `N` to `V`
is naturally a vector space over the ring of smooth functions from `N` to `ùïú`. -/


instance instSMul' {V : Type*} [NormedAddCommGroup V] [NormedSpace ùïú V] :
    SMul C^‚àû‚üÆI, N; ùïú‚üØ C^‚àû‚üÆI, N; ùìò(ùïú, V), V‚üØ :=
  ‚ü®fun f g => ‚ü®fun x => f x ‚Ä¢ g x, Smooth.smul f.2 g.2‚ü©‚ü©

@[simp]
theorem smul_comp' {V : Type*} [NormedAddCommGroup V] [NormedSpace ùïú V] (f : C^‚àû‚üÆI'', N'; ùïú‚üØ)
    (g : C^‚àû‚üÆI'', N'; ùìò(ùïú, V), V‚üØ) (h : C^‚àû‚üÆI, N; I'', N'‚üØ) :
    (f ‚Ä¢ g).comp h = f.comp h ‚Ä¢ g.comp h :=
  rfl

instance module' {V : Type*} [NormedAddCommGroup V] [NormedSpace ùïú V] :
    Module C^‚àû‚üÆI, N; ùìò(ùïú), ùïú‚üØ C^‚àû‚üÆI, N; ùìò(ùïú, V), V‚üØ where
  smul := (¬∑ ‚Ä¢ ¬∑)
  smul_add c f g := by ext x; exact smul_add (c x) (f x) (g x)
  add_smul c‚ÇÅ c‚ÇÇ f := by ext x; exact add_smul (c‚ÇÅ x) (c‚ÇÇ x) (f x)
  mul_smul c‚ÇÅ c‚ÇÇ f := by ext x; exact mul_smul (c‚ÇÅ x) (c‚ÇÇ x) (f x)
  one_smul f := by ext x; exact one_smul ùïú (f x)
  zero_smul f := by ext x; exact zero_smul _ _
  smul_zero r := by ext x; exact smul_zero _

end ModuleOverContinuousFunctions

end SmoothMap
