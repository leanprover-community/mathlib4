/-
Copyright (c) 2019 Kim Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import Mathlib.Geometry.RingedSpace.PresheafedSpace
import Mathlib.CategoryTheory.Limits.Final
import Mathlib.Topology.Sheaves.Stalks

/-!
# Stalks for presheaved spaces

This file lifts constructions of stalks and pushforwards of stalks to work with
the category of presheafed spaces. Additionally, we prove that restriction of
presheafed spaces does not change the stalks.
-/


noncomputable section

universe v u v' u'

open Opposite CategoryTheory CategoryTheory.Category CategoryTheory.Functor CategoryTheory.Limits
  AlgebraicGeometry TopologicalSpace Topology

variable {C : Type u} [Category.{v} C] [HasColimits C]

-- Porting note: no tidy tactic
-- attribute [local tidy] tactic.auto_cases_opens
-- this could be replaced by
-- attribute [local aesop safe cases (rule_sets := [CategoryTheory])] Opens
-- but it doesn't appear to be needed here.

open TopCat.Presheaf

namespace AlgebraicGeometry.PresheafedSpace

/-- A morphism of presheafed spaces induces a morphism of stalks.
-/
def Hom.stalkMap {X Y : PresheafedSpace.{_, _, v} C} (Î± : Hom X Y) (x : X) :
    Y.presheaf.stalk (Î±.base x) âŸ¶ X.presheaf.stalk x :=
  (stalkFunctor C (Î±.base x)).map Î±.c â‰« X.presheaf.stalkPushforward C Î±.base x

@[elementwise, reassoc]
theorem stalkMap_germ {X Y : PresheafedSpace.{_, _, v} C} (Î± : X âŸ¶ Y) (U : Opens Y)
    (x : X) (hx : Î± x âˆˆ U) :
    Y.presheaf.germ U (Î± x) hx â‰« Î±.stalkMap x = Î±.c.app (op U) â‰«
      X.presheaf.germ ((Opens.map Î±.base).obj U) x hx := by
  rw [Hom.stalkMap, stalkFunctor_map_germ_assoc, stalkPushforward_germ]

section Restrict

/-- For an open embedding `f : U âŸ¶ X` and a point `x : U`, we get an isomorphism between the stalk
of `X` at `f x` and the stalk of the restriction of `X` along `f` at t `x`.
-/
def restrictStalkIso {U : TopCat} (X : PresheafedSpace.{_, _, v} C) {f : U âŸ¶ (X : TopCat.{v})}
    (h : IsOpenEmbedding f) (x : U) : (X.restrict h).presheaf.stalk x â‰… X.presheaf.stalk (f x) :=
  haveI := initial_of_adjunction (h.isOpenMap.adjunctionNhds x)
  Final.colimitIso (h.isOpenMap.functorNhds x).op ((OpenNhds.inclusion (f x)).op â‹™ X.presheaf)
  -- As a left adjoint, the functor `h.is_open_map.functor_nhds x` is initial.
  -- Typeclass resolution knows that the opposite of an initial functor is final. The result
  -- follows from the general fact that postcomposing with a final functor doesn't change colimits.

-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): removed `simp` attribute, for left hand side is not in simple normal form.
@[elementwise, reassoc]
theorem restrictStalkIso_hom_eq_germ {U : TopCat} (X : PresheafedSpace.{_, _, v} C)
    {f : U âŸ¶ (X : TopCat.{v})} (h : IsOpenEmbedding f) (V : Opens U) (x : U) (hx : x âˆˆ V) :
    (X.restrict h).presheaf.germ _ x hx â‰« (restrictStalkIso X h x).hom =
    X.presheaf.germ (h.isOpenMap.functor.obj V) (f x) âŸ¨x, hx, rflâŸ© :=
  colimit.Î¹_pre ((OpenNhds.inclusion (f x)).op â‹™ X.presheaf) (h.isOpenMap.functorNhds x).op
    (op âŸ¨V, hxâŸ©)

-- We intentionally leave `simp` off the lemmas generated by `elementwise` and `reassoc`,
-- as the simpNF linter claims they never apply.
@[simp, elementwise, reassoc]
theorem restrictStalkIso_inv_eq_germ {U : TopCat} (X : PresheafedSpace.{_, _, v} C)
    {f : U âŸ¶ (X : TopCat.{v})} (h : IsOpenEmbedding f) (V : Opens U) (x : U) (hx : x âˆˆ V) :
    X.presheaf.germ (h.isOpenMap.functor.obj V) (f x) âŸ¨x, hx, rflâŸ© â‰«
        (restrictStalkIso X h x).inv =
      (X.restrict h).presheaf.germ _ x hx := by
  rw [â† restrictStalkIso_hom_eq_germ, Category.assoc, Iso.hom_inv_id, Category.comp_id]

theorem restrictStalkIso_inv_eq_ofRestrict {U : TopCat} (X : PresheafedSpace.{_, _, v} C)
    {f : U âŸ¶ (X : TopCat.{v})} (h : IsOpenEmbedding f) (x : U) :
    (X.restrictStalkIso h x).inv = (X.ofRestrict h).stalkMap x := by
  -- We can't use `ext` here due to https://github.com/leanprover/std4/pull/159
  refine colimit.hom_ext fun V => ?_
  induction V with | op V => ?_
  let i : (h.isOpenMap.functorNhds x).obj ((OpenNhds.map f x).obj V) âŸ¶ V :=
    homOfLE (Set.image_preimage_subset f _)
  erw [Iso.comp_inv_eq, colimit.Î¹_map_assoc, colimit.Î¹_map_assoc, colimit.Î¹_pre]
  simp_rw [Category.assoc]
  erw [colimit.Î¹_pre ((OpenNhds.inclusion (f x)).op â‹™ X.presheaf)
      (h.isOpenMap.functorNhds x).op]
  erw [â† X.presheaf.map_comp_assoc]
  exact (colimit.w ((OpenNhds.inclusion (f x)).op â‹™ X.presheaf) i.op).symm

instance ofRestrict_stalkMap_isIso {U : TopCat} (X : PresheafedSpace.{_, _, v} C)
    {f : U âŸ¶ (X : TopCat.{v})} (h : IsOpenEmbedding f) (x : U) :
    IsIso ((X.ofRestrict h).stalkMap x) := by
  rw [â† restrictStalkIso_inv_eq_ofRestrict]; infer_instance

end Restrict

namespace stalkMap

@[simp]
theorem id (X : PresheafedSpace.{_, _, v} C) (x : X) :
    (ðŸ™ X : X âŸ¶ X).stalkMap x = ðŸ™ (X.presheaf.stalk x) := by
  dsimp [Hom.stalkMap]
  simp only [stalkPushforward.id]
  rw [â† map_comp]
  convert (stalkFunctor C x).map_id X.presheaf
  ext
  simp only [id_c, id_comp, Pushforward.id_hom_app]
  rfl

@[simp]
theorem comp {X Y Z : PresheafedSpace.{_, _, v} C} (Î± : X âŸ¶ Y) (Î² : Y âŸ¶ Z) (x : X) :
    (Î± â‰« Î²).stalkMap x =
      (Î².stalkMap (Î±.base x) : Z.presheaf.stalk (Î².base (Î±.base x)) âŸ¶ Y.presheaf.stalk (Î±.base x)) â‰«
        (Î±.stalkMap x : Y.presheaf.stalk (Î±.base x) âŸ¶ X.presheaf.stalk x) := by
  dsimp [Hom.stalkMap, stalkFunctor, stalkPushforward]
  -- We can't use `ext` here due to https://github.com/leanprover/std4/pull/159
  apply colimit.hom_ext
  rintro âŸ¨U, hUâŸ©
  simp

/-- If `Î± = Î²` and `x = x'`, we would like to say that `stalk_map Î± x = stalk_map Î² x'`.
Unfortunately, this equality is not well-formed, as their types are not _definitionally_ the same.
To get a proper congruence lemma, we therefore have to introduce these `eqToHom` arrows on
either side of the equality.
-/
theorem congr {X Y : PresheafedSpace.{_, _, v} C} (Î± Î² : X âŸ¶ Y)
    (hâ‚ : Î± = Î²) (x x' : X) (hâ‚‚ : x = x') :
    Î±.stalkMap x â‰« eqToHom (show X.presheaf.stalk x = X.presheaf.stalk x' by rw [hâ‚‚]) =
      eqToHom (show Y.presheaf.stalk (Î±.base x) = Y.presheaf.stalk (Î².base x') by rw [hâ‚, hâ‚‚]) â‰«
        Î².stalkMap x' := by
  ext
  substs hâ‚ hâ‚‚
  simp

theorem congr_hom {X Y : PresheafedSpace.{_, _, v} C} (Î± Î² : X âŸ¶ Y) (h : Î± = Î²) (x : X) :
    Î±.stalkMap x =
      eqToHom (show Y.presheaf.stalk (Î±.base x) =
        Y.presheaf.stalk (Î².base x) by rw [h]) â‰« Î².stalkMap x := by
  rw [â† stalkMap.congr Î± Î² h x x rfl, eqToHom_refl, Category.comp_id]

theorem congr_point {X Y : PresheafedSpace.{_, _, v} C}
    (Î± : X âŸ¶ Y) (x x' : X) (h : x = x') :
    Î±.stalkMap x â‰« eqToHom (show X.presheaf.stalk x = X.presheaf.stalk x' by rw [h]) =
      eqToHom (show Y.presheaf.stalk (Î±.base x) =
        Y.presheaf.stalk (Î±.base x') by rw [h]) â‰« Î±.stalkMap x' := by
  rw [stalkMap.congr Î± Î± rfl x x' h]

instance isIso {X Y : PresheafedSpace.{_, _, v} C} (Î± : X âŸ¶ Y) [IsIso Î±] (x : X) :
    IsIso (Î±.stalkMap x) where
  out := by
    let Î² : Y âŸ¶ X := CategoryTheory.inv Î±
    have h_eq : (Î± â‰« Î²).base x = x := by rw [IsIso.hom_inv_id Î±, id_base, TopCat.id_app]
    -- Intuitively, the inverse of the stalk map of `Î±` at `x` should just be the stalk map of `Î²`
    -- at `Î± x`. Unfortunately, we have a problem with dependent type theory here: Because `x`
    -- is not *definitionally* equal to `Î² (Î± x)`, the map `stalk_map Î² (Î± x)` has not the correct
    -- type for an inverse.
    -- To get a proper inverse, we need to compose with the `eqToHom` arrow
    -- `X.stalk x âŸ¶ X.stalk ((Î± â‰« Î²).base x)`.
    refine
      âŸ¨eqToHom (show X.presheaf.stalk x = X.presheaf.stalk ((Î± â‰« Î²).base x) by rw [h_eq]) â‰«
          (Î².stalkMap (Î±.base x) :),
        ?_, ?_âŸ©
    Â· rw [â† Category.assoc, congr_point Î± x ((Î± â‰« Î²).base x) h_eq.symm, Category.assoc]
      erw [â† stalkMap.comp Î² Î± (Î±.base x)]
      rw [congr_hom _ _ (IsIso.inv_hom_id Î±), stalkMap.id, eqToHom_trans_assoc, eqToHom_refl,
        Category.id_comp]
    Â· rw [Category.assoc, â† stalkMap.comp, congr_hom _ _ (IsIso.hom_inv_id Î±), stalkMap.id,
        eqToHom_trans_assoc, eqToHom_refl, Category.id_comp]

/-- An isomorphism between presheafed spaces induces an isomorphism of stalks.
-/
def stalkIso {X Y : PresheafedSpace.{_, _, v} C} (Î± : X â‰… Y) (x : X) :
    Y.presheaf.stalk (Î±.hom.base x) â‰… X.presheaf.stalk x :=
  asIso (Î±.hom.stalkMap x)

@[reassoc (attr := simp), elementwise (attr := simp)]
theorem stalkSpecializes_stalkMap {X Y : PresheafedSpace.{_, _, v} C}
    (f : X âŸ¶ Y) {x y : X} (h : x â¤³ y) :
    Y.presheaf.stalkSpecializes (f.base.hom.map_specializes h) â‰« f.stalkMap x =
      f.stalkMap y â‰« X.presheaf.stalkSpecializes h := by
  -- Porting note: the original one liner `dsimp [stalkMap]; simp [stalkMap]` doesn't work,
  -- I had to uglify this
  dsimp [stalkSpecializes, Hom.stalkMap, stalkFunctor, stalkPushforward]
  -- We can't use `ext` here due to https://github.com/leanprover/std4/pull/159
  refine colimit.hom_ext fun j => ?_
  induction j with | op j => ?_
  dsimp
  simp only [colimit.Î¹_desc_assoc, Î¹_colimMap_assoc, whiskerLeft_app,
    whiskerRight_app, NatTrans.id_app, colimit.Î¹_pre, assoc,
    colimit.pre_desc, colimit.map_desc, colimit.Î¹_desc, Cocones.precompose_obj_Î¹,
    Cocone.whisker_Î¹, NatTrans.comp_app]
  erw [X.presheaf.map_id, id_comp]
  rfl

end stalkMap

end AlgebraicGeometry.PresheafedSpace
