/-
Copyright (c) 2025 Amelia Livingston. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Amelia Livingston
-/
import Mathlib.RepresentationTheory.GroupCohomology.Basic
import Mathlib.RepresentationTheory.GroupCohomology.LowDegree

/-!
# Functoriality of group cohomology

Given a commutative ring `k`, a group homomorphism `f : G â†’* H`, a `k`-linear `H`-representation
`A`, a `k`-linear `G`-representation `B`, and a representation morphism `Res(f)(A) âŸ¶ B`, we get
a cochain map `inhomogeneousCochains A âŸ¶ inhomogeneousCochains B` and hence maps on
cohomology `Hâ¿(H, A) âŸ¶ Hâ¿(G, B)`.
We also provide extra API for these maps in degrees 0, 1, 2.

## Main definitions

* `groupCohomology.cochainsMap f Ï†` is the map `inhomogeneousCochains A âŸ¶ inhomogeneousCochains B`
induced by a group homomorphism `f : G â†’* H` and a representation morphism `Ï† : Res(f)(A) âŸ¶ B`.
* `groupCohomology.map f Ï† n` is the map `Hâ¿(H, A) âŸ¶ Hâ¿(G, B)` induced by a group
homomorphism `f : G â†’* H` and a representation morphism `Ï† : Res(f)(A) âŸ¶ B`.
-/

universe v u

namespace groupCohomology
open Rep CategoryTheory Representation

variable {k G H : Type u} [CommRing k] [Group G] [Group H]
  {A : Rep k H} {B : Rep k G} (f : G â†’* H) (Ï† : (Action.res _ f).obj A âŸ¶ B) (n : â„•)

/-- Given a group homomorphism `f : G â†’* H` and a representation morphism `Ï† : Res(f)(A) âŸ¶ B`,
this is the chain map sending `x : Hâ¿ â†’ A` to `(g : Gâ¿) â†¦ Ï† (x (f âˆ˜ g))`. -/
@[simps! (config := .lemmasOnly) f f_hom]
noncomputable def cochainsMap :
    inhomogeneousCochains A âŸ¶ inhomogeneousCochains B where
  f i := ModuleCat.ofHom <|
    Ï†.hom.hom.compLeft (Fin i â†’ G) âˆ˜â‚— LinearMap.funLeft k A (fun x : Fin i â†’ G => (f âˆ˜ x))
  comm' i j (hij : _ = _) := by
    subst hij
    ext
    funext
    simpa [inhomogeneousCochains.d_apply, Fin.comp_contractNth] using (hom_comm_apply Ï† _ _).symm

@[simp]
lemma cochainsMap_id :
    cochainsMap (MonoidHom.id _) (ğŸ™ A) = ğŸ™ (inhomogeneousCochains A) := by
  rfl

@[simp]
lemma cochainsMap_id_f_eq_compLeft {A B : Rep k G} (f : A âŸ¶ B) (i : â„•) :
    (cochainsMap (MonoidHom.id G) f).f i = ModuleCat.ofHom (f.hom.hom.compLeft _) := by
  ext
  rfl

lemma cochainsMap_comp {G H K : Type u} [Group G] [Group H] [Group K]
    {A : Rep k K} {B : Rep k H} {C : Rep k G} (f : H â†’* K) (g : G â†’* H)
    (Ï† : (Action.res _ f).obj A âŸ¶ B) (Ïˆ : (Action.res _ g).obj B âŸ¶ C) :
    cochainsMap (f.comp g) ((Action.res _ g).map Ï† â‰« Ïˆ) =
      cochainsMap f Ï† â‰« cochainsMap g Ïˆ := by
  rfl

lemma cochainsMap_id_comp {A B C : Rep k G} (Ï† : A âŸ¶ B) (Ïˆ : B âŸ¶ C) :
    cochainsMap (MonoidHom.id G) (Ï† â‰« Ïˆ) =
      cochainsMap (MonoidHom.id G) Ï† â‰« cochainsMap (MonoidHom.id G) Ïˆ := by
  rfl

@[simp]
lemma cochainsMap_zero : cochainsMap (A := A) (B := B) f 0 = 0 := by rfl

lemma cochainsMap_f_map_mono (hf : Function.Surjective f) [Mono Ï†] (i : â„•) :
    Mono ((cochainsMap f Ï†).f i) := by
  simpa [ModuleCat.mono_iff_injective] using
    ((Rep.mono_iff_injective Ï†).1 inferInstance).comp_left.comp <|
    LinearMap.funLeft_injective_of_surjective k A _ hf.comp_left

instance cochainsMap_id_f_map_mono {A B : Rep k G} (Ï† : A âŸ¶ B) [Mono Ï†] (i : â„•) :
    Mono ((cochainsMap (MonoidHom.id G) Ï†).f i) :=
  cochainsMap_f_map_mono (MonoidHom.id G) Ï† (fun x => âŸ¨x, rflâŸ©) i

lemma cochainsMap_f_map_epi (hf : Function.Injective f) [Epi Ï†] (i : â„•) :
    Epi ((cochainsMap f Ï†).f i) := by
  simpa [ModuleCat.epi_iff_surjective] using
    ((Rep.epi_iff_surjective Ï†).1 inferInstance).comp_left.comp <|
    LinearMap.funLeft_surjective_of_injective k A _ hf.comp_left

instance cochainsMap_id_f_map_epi {A B : Rep k G} (Ï† : A âŸ¶ B) [Epi Ï†] (i : â„•) :
    Epi ((cochainsMap (MonoidHom.id G) Ï†).f i) :=
  cochainsMap_f_map_epi (MonoidHom.id G) Ï† (fun _ _ h => h) i

/-- Given a group homomorphism `f : G â†’* H` and a representation morphism `Ï† : Res(f)(A) âŸ¶ B`,
this is the induced map `Zâ¿(H, A) âŸ¶ Zâ¿(G, B)` sending `x : Hâ¿ â†’ A` to
`(g : Gâ¿) â†¦ Ï† (x (f âˆ˜ g))`. -/
noncomputable abbrev cocyclesMap (n : â„•) :
    groupCohomology.cocycles A n âŸ¶ groupCohomology.cocycles B n :=
  HomologicalComplex.cyclesMap (cochainsMap f Ï†) n

theorem cocyclesMap_id_comp {A B C : Rep k G} (Ï† : A âŸ¶ B) (Ïˆ : B âŸ¶ C) (n : â„•) :
    cocyclesMap (MonoidHom.id G) (Ï† â‰« Ïˆ) n =
      cocyclesMap (MonoidHom.id G) Ï† n â‰« cocyclesMap (MonoidHom.id G) Ïˆ n := by
  simp [cocyclesMap, cochainsMap_id_comp, HomologicalComplex.cyclesMap_comp]

/-- Given a group homomorphism `f : G â†’* H` and a representation morphism `Ï† : Res(f)(A) âŸ¶ B`,
this is the induced map `Hâ¿(H, A) âŸ¶ Hâ¿(G, B)` sending `x : Hâ¿ â†’ A` to
`(g : Gâ¿) â†¦ Ï† (x (f âˆ˜ g))`. -/
noncomputable abbrev map (n : â„•) :
    groupCohomology A n âŸ¶ groupCohomology B n :=
  HomologicalComplex.homologyMap (cochainsMap f Ï†) n

theorem map_id_comp {A B C : Rep k G} (Ï† : A âŸ¶ B) (Ïˆ : B âŸ¶ C) (n : â„•) :
    map (MonoidHom.id G) (Ï† â‰« Ïˆ) n =
      map (MonoidHom.id G) Ï† n â‰« map (MonoidHom.id G) Ïˆ n := by
  rw [map, cochainsMap_id_comp, HomologicalComplex.homologyMap_comp]

/-- Given a group homomorphism `f : G â†’* H` and a representation morphism `Ï† : Res(f)(A) âŸ¶ B`,
this is the induced map sending `x : H â†’ A` to `(g : G) â†¦ Ï† (x (f g))`. -/
abbrev fOne : (H â†’ A) â†’â‚—[k] (G â†’ B) := Ï†.hom.hom.compLeft G âˆ˜â‚— LinearMap.funLeft k A f

/-- Given a group homomorphism `f : G â†’* H` and a representation morphism `Ï† : Res(f)(A) âŸ¶ B`,
this is the induced map sending `x : H Ã— H â†’ A` to `(gâ‚, gâ‚‚ : G Ã— G) â†¦ Ï† (x (f gâ‚, f gâ‚‚))`. -/
abbrev fTwo : (H Ã— H â†’ A) â†’â‚—[k] (G Ã— G â†’ B) :=
  Ï†.hom.hom.compLeft (G Ã— G) âˆ˜â‚— LinearMap.funLeft k A (Prod.map f f)

/-- Given a group homomorphism `f : G â†’* H` and a representation morphism `Ï† : Res(f)(A) âŸ¶ B`,
this is the induced map sending `x : H Ã— H Ã— H â†’ A` to
`(gâ‚, gâ‚‚, gâ‚ƒ : G Ã— G Ã— G) â†¦ Ï† (x (f gâ‚, f gâ‚‚, f gâ‚ƒ))`. -/
abbrev fThree : (H Ã— H Ã— H â†’ A) â†’â‚—[k] (G Ã— G Ã— G â†’ B) :=
  Ï†.hom.hom.compLeft (G Ã— G Ã— G) âˆ˜â‚— LinearMap.funLeft k A (Prod.map f (Prod.map f f))

@[reassoc]
lemma cochainsMap_f_0_comp_zeroCochainsLequiv :
    (cochainsMap f Ï†).f 0 â‰« (zeroCochainsLequiv B).toModuleIso.hom =
      (zeroCochainsLequiv A).toModuleIso.hom â‰« Ï†.hom := by
  ext x
  simp only [cochainsMap_f, Unique.eq_default (f âˆ˜ _)]
  rfl

@[reassoc]
lemma cochainsMap_f_1_comp_oneCochainsLequiv :
    (cochainsMap f Ï†).f 1 â‰« (oneCochainsLequiv B).toModuleIso.hom =
      (oneCochainsLequiv A).toModuleIso.hom â‰« ModuleCat.ofHom (fOne f Ï†) := by
  ext x
  simp only [cochainsMap_f, Unique.eq_default (f âˆ˜ _)]
  rfl

@[reassoc]
lemma cochainsMap_f_2_comp_twoCochainsLequiv :
    (cochainsMap f Ï†).f 2 â‰« (twoCochainsLequiv B).toModuleIso.hom =
      (twoCochainsLequiv A).toModuleIso.hom â‰« ModuleCat.ofHom (fTwo f Ï†) := by
  ext x g
  show Ï†.hom (x _) = Ï†.hom (x _)
  rcongr x
  fin_cases x <;> rfl

@[reassoc]
lemma cochainsMap_f_3_comp_threeCochainsLequiv :
    (cochainsMap f Ï†).f 3 â‰« (threeCochainsLequiv B).toModuleIso.hom =
      (threeCochainsLequiv A).toModuleIso.hom â‰« ModuleCat.ofHom (fThree f Ï†) := by
  ext x g
  show Ï†.hom (x _) = Ï†.hom (x _)
  rcongr x
  fin_cases x <;> rfl

end groupCohomology
