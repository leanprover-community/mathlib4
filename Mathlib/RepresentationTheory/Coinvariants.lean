/-
Copyright (c) 2025 Amelia Livingston. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Amelia Livingston
-/
import Mathlib.Algebra.Homology.ShortComplex.ModuleCat
import Mathlib.RepresentationTheory.Rep

/-!
# Coinvariants of a group representation

Given a commutative ring `k` and a monoid `G`, this file introduces the coinvariants of a
`k`-linear `G`-representation `(V, œÅ)`.

We first define `Representation.Coinvariants.ker`, the submodule of `V` generated by elements
of the form `œÅ g x - x` for `x : V`, `g : G`. Then the coinvariants of `(V, œÅ)` are the quotient of
`V` by this submodule. We show that the functor sending a representation to its coinvariants is
left adjoint to the functor equipping a module with the trivial representation.

## Main definitions

* `Representation.Coinvariants œÅ`: the coinvariants of a representation `œÅ`.
* `Representation.coinvariantsFinsuppLEquiv œÅ Œ±`: given a type `Œ±`, this is the `k`-linear
  equivalence between `(Œ± ‚Üí‚ÇÄ V)_G` and `Œ± ‚Üí‚ÇÄ V_G`.
* `Representation.coinvariantsTprodLeftRegularLEquiv œÅ`: the `k`-linear equivalence between
  `(V ‚äó k[G])_G` and `V` sending `‚ü¶v ‚äó single g r‚üß ‚Ü¶ r ‚Ä¢ œÅ(g‚Åª¬π)(v)`.
* `Rep.coinvariantsAdjunction k G`: the adjunction between the functor sending a representation to
  its coinvariants and the functor equipping a module with the trivial representation.
* `Rep.coinvariantsTensor k G`: the functor sending representations `A, B` to `(A ‚äó[k] B)_G`. This
  is naturally isomorphic to the functor sending `A, B` to `A ‚äó[k[G]] B`, where we give `A` the
  `k[G]·µê·µí·µñ`-module structure defined by `g ‚Ä¢ a := A.œÅ g‚Åª¬π a`.
* `Rep.coinvariantsTensorFreeLEquiv A Œ±`: given a representation `A` and a type `Œ±`, this is the
  `k`-linear equivalence between `(A ‚äó (Œ± ‚Üí‚ÇÄ k[G]))_G` and `Œ± ‚Üí‚ÇÄ A` sending
  `‚ü¶a ‚äó single x (single g r)‚üß ‚Ü¶ single x (r ‚Ä¢ œÅ(g‚Åª¬π)(a))`. This is useful for group homology.

-/

universe u v

namespace Representation

variable {k G V W X : Type*} [CommRing k] [Monoid G] [AddCommGroup V] [Module k V]
  [AddCommGroup W] [Module k W] [AddCommGroup X] [Module k X]
  (œÅ : Representation k G V) (œÑ : Representation k G W) (œÖ : Representation k G X)

/-- The submodule of a representation generated by elements of the form `œÅ g x - x`. -/
def Coinvariants.ker : Submodule k V :=
  Submodule.span k (Set.range fun (gv : G √ó V) => œÅ gv.1 gv.2 - gv.2)

/-- The coinvariants of a representation, `V ‚ß∏ ‚ü®{œÅ g x - x | g ‚àà G, x ‚àà V}‚ü©`. -/
def Coinvariants := V ‚ß∏ Coinvariants.ker œÅ

namespace Coinvariants

instance : AddCommGroup (Coinvariants œÅ) := inferInstanceAs <| AddCommGroup (_ ‚ß∏ _)
instance : Module k (Coinvariants œÅ) := inferInstanceAs <| Module k (_ ‚ß∏ _)

variable {œÅ}

lemma sub_mem_ker (g : G) (x : V) : œÅ g x - x ‚àà Coinvariants.ker œÅ :=
  Submodule.subset_span <| Set.mem_range_self (g, x)

lemma mem_ker_of_eq (g : G) (x : V) (a : V) (h : œÅ g x - x = a) : a ‚àà ker œÅ :=
  Submodule.subset_span ‚ü®(g, x), h‚ü©

variable (œÅ)

/-- The quotient map from a representation to its coinvariants as a linear map. -/
def mk : V ‚Üí‚Çó[k] Coinvariants œÅ := Submodule.mkQ (ker œÅ)

theorem mk_eq_iff {x y : V} :
    mk œÅ x = mk œÅ y ‚Üî x - y ‚àà Coinvariants.ker œÅ :=
  Submodule.Quotient.eq _

theorem mk_eq_zero {x : V} :
    mk œÅ x = 0 ‚Üî x ‚àà Coinvariants.ker œÅ :=
  Submodule.Quotient.mk_eq_zero _

theorem mk_surjective : Function.Surjective (mk œÅ) :=
  Submodule.Quotient.mk_surjective _

@[simp]
lemma mk_self_apply (g : G) (x : V) :
    mk œÅ (œÅ g x) = mk œÅ x :=
  (mk_eq_iff _).2 <| mem_ker_of_eq g x _ rfl

variable {œÅ} in
@[elab_as_elim]
theorem induction_on {motive : Coinvariants œÅ ‚Üí Prop} (x : Coinvariants œÅ)
    (h : ‚àÄ v : V, motive (mk œÅ v)) :
    motive x :=
  Submodule.Quotient.induction_on _ x h

/-- A `G`-invariant linear map induces a linear map out of the coinvariants of a
`G`-representation. -/
def lift (f : V ‚Üí‚Çó[k] W) (h : ‚àÄ (x : G), f ‚àò‚Çó œÅ x = f) :
    œÅ.Coinvariants ‚Üí‚Çó[k] W :=
  Submodule.liftQ _ f <| Submodule.span_le.2 fun x ‚ü®‚ü®g, y‚ü©, hy‚ü© => by
    simpa only [‚Üê hy, SetLike.mem_coe, LinearMap.mem_ker, map_sub, sub_eq_zero, LinearMap.coe_comp,
      Function.comp_apply] using LinearMap.ext_iff.1 (h g) y

@[simp]
theorem lift_comp_mk (f : V ‚Üí‚Çó[k] W) (h : ‚àÄ (x : G), f ‚àò‚Çó œÅ x = f) :
    lift œÅ f h ‚àò‚Çó mk œÅ = f := rfl

@[simp]
theorem lift_mk (f : V ‚Üí‚Çó[k] W) (h : ‚àÄ (x : G), f ‚àò‚Çó œÅ x = f) (x : V) :
    lift œÅ f h (mk _ x) = f x := rfl

variable {œÅ} in
@[ext high]
lemma hom_ext {f g : Coinvariants œÅ ‚Üí‚Çó[k] W} (H : f ‚àò‚Çó mk œÅ = g ‚àò‚Çó mk œÅ) : f = g :=
  Submodule.linearMap_qext _ H

/-- Given `G`-representations on `k`-modules `V, W`, a linear map `V ‚Üí‚Çó[k] W` commuting with
the representations induces a `k`-linear map between the coinvariants. -/
noncomputable def map (f : V ‚Üí‚Çó[k] W) (hf : ‚àÄ g, f ‚àò‚Çó œÅ g = œÑ g ‚àò‚Çó f) :
    Coinvariants œÅ ‚Üí‚Çó[k] Coinvariants œÑ :=
  lift _ (mk _ ‚àò‚Çó f) fun g => LinearMap.ext fun x => (mk_eq_iff _).2 <|
    mem_ker_of_eq g (f x) _ <| by simpa using congr($((hf g).symm) x)

variable {œÅ œÑ}

@[simp]
lemma map_comp_mk (f : V ‚Üí‚Çó[k] W) (hf : ‚àÄ g, f ‚àò‚Çó œÅ g = œÑ g ‚àò‚Çó f) :
    map œÅ œÑ f hf ‚àò‚Çó mk œÅ = mk œÑ ‚àò‚Çó f := rfl

@[simp]
lemma map_mk (f : V ‚Üí‚Çó[k] W) (hf : ‚àÄ g, f ‚àò‚Çó œÅ g = œÑ g ‚àò‚Çó f) (x : V) :
    map œÅ œÑ f hf (mk _ x) = mk _ (f x) := rfl

@[simp]
lemma map_id (œÅ : Representation k G V) :
    map œÅ œÅ LinearMap.id (by simp) = LinearMap.id := by
  ext; rfl

@[simp]
lemma map_comp (œÜ : V ‚Üí‚Çó[k] W) (œà : W ‚Üí‚Çó[k] X)
    (H : ‚àÄ g, œÜ ‚àò‚Çó œÅ g = œÑ g ‚àò‚Çó œÜ) (h : ‚àÄ g, œà ‚àò‚Çó œÑ g = œÖ g ‚àò‚Çó œà) :
    map œÑ œÖ œà h ‚àò‚Çó map œÅ œÑ œÜ H = map œÅ œÖ (œà ‚àò‚Çó œÜ) (fun g => by
      ext x; have : œÜ _ = _ := congr($(H g) x); have : œà _ = _ := congr($(h g) (œÜ x)); simp_all) :=
  hom_ext rfl

end Coinvariants
section

open Coinvariants

variable {k G V : Type*} [CommRing k] [Group G] [AddCommGroup V] [Module k V]
variable (œÅ : Representation k G V) (S : Subgroup G) [S.Normal]

lemma Coinvariants.le_comap_ker (g : G) :
    ker (œÅ.comp S.subtype) ‚â§ (ker <| œÅ.comp S.subtype).comap (œÅ g) :=
  Submodule.span_le.2 fun _ ‚ü®‚ü®s, x‚ü©, hs‚ü© => by
    simpa [‚Üê hs] using mem_ker_of_eq
      ‚ü®g * s * g‚Åª¬π, Subgroup.Normal.conj_mem ‚Äπ_‚Ä∫ s.1 s.2 g‚ü© (œÅ g x) _ <| by simp

/-- Given a normal subgroup `S ‚â§ G`, a `G`-representation `œÅ` restricts to a `G`-representation on
the kernel of the quotient map to the coinvariants of `œÅ|_S`. -/
noncomputable abbrev toCoinvariantsKer :
    Representation k G (ker <| œÅ.comp S.subtype) :=
  subrepresentation œÅ (ker <| œÅ.comp S.subtype) fun g => le_comap_ker œÅ S g

/-- Given a normal subgroup `S ‚â§ G`, a `G`-representation `œÅ` induces a `G`-representation on the
coinvariants of `œÅ|_S`. -/
noncomputable def toCoinvariants :
    Representation k G (Coinvariants <| œÅ.comp S.subtype) :=
  quotient œÅ (ker <| œÅ.comp S.subtype) fun g => le_comap_ker œÅ S g

@[simp]
lemma toCoinvariants_mk (g : G) (x : V) :
    toCoinvariants œÅ S g (Coinvariants.mk _ x) = Coinvariants.mk _ (œÅ g x) := rfl

instance : IsTrivial ((toCoinvariants œÅ S).comp S.subtype) where
  out g := by
    ext x
    exact (Coinvariants.mk_eq_iff _).2 <| mem_ker_of_eq g x _ rfl

/-- Given a normal subgroup `S ‚â§ G`, a `G`-representation `œÅ` induces a `G ‚ß∏ S`-representation on
the coinvariants of `œÅ|_S`. -/
noncomputable abbrev quotientToCoinvariants :
    Representation k (G ‚ß∏ S) (Coinvariants (œÅ.comp S.subtype)) :=
  ofQuotient (toCoinvariants œÅ S) S

end


section Finsupp

open Finsupp Coinvariants

variable {k G V : Type*} [CommRing k] [Group G] [AddCommGroup V] [Module k V]
  (œÅ : Representation k G V) (Œ± : Type*)

/-- Given a `G`-representation `(V, œÅ)` and a type `Œ±`, this is the map `(Œ± ‚Üí‚ÇÄ V)_G ‚Üí‚Çó (Œ± ‚Üí‚ÇÄ V_G)`
sending `‚ü¶single a v‚üß ‚Ü¶ single a ‚ü¶v‚üß`. -/
noncomputable def coinvariantsToFinsupp :
    Coinvariants (œÅ.finsupp Œ±) ‚Üí‚Çó[k] Œ± ‚Üí‚ÇÄ Coinvariants œÅ :=
  Coinvariants.lift _ (mapRange.linearMap (Coinvariants.mk _)) <| fun _ => by ext; simp

variable {œÅ Œ±}

@[simp]
lemma coinvariantsToFinsupp_mk_single (x : Œ±) (a : V) :
    coinvariantsToFinsupp œÅ Œ± (Coinvariants.mk _ (single x a)) =
      single x (Coinvariants.mk _ a) := by
  simp [coinvariantsToFinsupp]

variable (œÅ Œ±) in
/-- Given a `G`-representation `(V, œÅ)` and a type `Œ±`, this is the map `(Œ± ‚Üí‚ÇÄ V_G) ‚Üí‚Çó (Œ± ‚Üí‚ÇÄ V)_G`
sending `single a ‚ü¶v‚üß ‚Ü¶ ‚ü¶single a v‚üß`. -/
noncomputable def finsuppToCoinvariants :
    (Œ± ‚Üí‚ÇÄ Coinvariants œÅ) ‚Üí‚Çó[k] Coinvariants (œÅ.finsupp Œ±) :=
  lsum (R := k) k fun a => Coinvariants.lift _ (Coinvariants.mk _ ‚àò‚Çó lsingle a) fun g =>
    LinearMap.ext fun x => (mk_eq_iff _).2 <| mem_ker_of_eq g (single a x) _ <| by simp

@[simp]
lemma finsuppToCoinvariants_single_mk (a : Œ±) (x : V) :
    finsuppToCoinvariants œÅ Œ± (single a <| Coinvariants.mk _ x) =
      Coinvariants.mk _ (single a x) := by
  simp [finsuppToCoinvariants]

variable (œÅ Œ±) in
/-- Given a `G`-representation `(V, œÅ)` and a type `Œ±`, this is the linear equivalence
`(Œ± ‚Üí‚ÇÄ V)_G ‚âÉ‚Çó (Œ± ‚Üí‚ÇÄ V_G)` sending `‚ü¶single a v‚üß ‚Ü¶ single a ‚ü¶v‚üß`. -/
@[simps! symm_apply]
noncomputable def coinvariantsFinsuppLEquiv :
    Coinvariants (œÅ.finsupp Œ±) ‚âÉ‚Çó[k] Œ± ‚Üí‚ÇÄ Coinvariants œÅ :=
  LinearEquiv.ofLinear (coinvariantsToFinsupp œÅ Œ±) (finsuppToCoinvariants œÅ Œ±)
    (by ext; simp) (by ext; simp)

@[simp]
lemma coinvariantsFinsuppLEquiv_apply (x : Coinvariants (œÅ.finsupp Œ±)) :
    coinvariantsFinsuppLEquiv œÅ Œ± x = coinvariantsToFinsupp œÅ Œ± x := by rfl

end Finsupp

section TensorProduct

open TensorProduct Coinvariants Finsupp

variable {k G V W : Type*} [CommRing k] [Group G] [AddCommGroup V] [Module k V]
  [AddCommGroup W] [Module k W] (œÅ : Representation k G V) (œÑ : Representation k G W)

-- the next two lemmas eliminate inverses

@[simp]
lemma Coinvariants.mk_inv_tmul (x : V) (y : W) (g : G) :
    Coinvariants.mk (œÅ.tprod œÑ) (œÅ g‚Åª¬π x ‚äó‚Çú[k] y) = Coinvariants.mk (œÅ.tprod œÑ) (x ‚äó‚Çú[k] œÑ g y) :=
  (mk_eq_iff _).2 <| mem_ker_of_eq g‚Åª¬π (x ‚äó‚Çú[k] œÑ g y) _ <| by simp

@[simp]
lemma Coinvariants.mk_tmul_inv (x : V) (y : W) (g : G) :
    Coinvariants.mk (œÅ.tprod œÑ) (x ‚äó‚Çú[k] œÑ g‚Åª¬π y) = Coinvariants.mk (œÅ.tprod œÑ) (œÅ g x ‚äó‚Çú[k] y) :=
  (mk_eq_iff _).2 <| mem_ker_of_eq g‚Åª¬π (œÅ g x ‚äó‚Çú[k] y) _ <| by simp

/-- Given a `k`-linear `G`-representation `V, œÅ`, this is the map `(V ‚äó k[G])_G ‚Üí‚Çó[k] V` sending
`‚ü¶v ‚äó single g r‚üß ‚Ü¶ r ‚Ä¢ œÅ(g‚Åª¬π)(v)`. -/
noncomputable def ofCoinvariantsTprodLeftRegular :
    Coinvariants (œÅ.tprod (leftRegular k G)) ‚Üí‚Çó[k] V :=
  Coinvariants.lift _ (TensorProduct.lift (Finsupp.linearCombination _ fun g => œÅ g‚Åª¬π) ‚àò‚Çó
    (TensorProduct.comm _ _ _).toLinearMap) fun _ => by ext; simp

@[simp]
lemma ofCoinvariantsTprodLeftRegular_mk_tmul_single (x : V) (g : G) (r : k) :
    ofCoinvariantsTprodLeftRegular œÅ (Coinvariants.mk _ (x ‚äó‚Çú Finsupp.single g r)) = r ‚Ä¢ œÅ g‚Åª¬π x :=
  congr($(Finsupp.linearCombination_single k (v := fun g => œÅ g‚Åª¬π) r g) x)

/-- Given a `k`-linear `G`-representation `(V, œÅ)`, this is the linear equivalence
`(V ‚äó k[G])_G ‚âÉ‚Çó[k] V` sending `‚ü¶v ‚äó single g r‚üß ‚Ü¶ r ‚Ä¢ œÅ(g‚Åª¬π)(v)`. -/
@[simps! symm_apply]
noncomputable def coinvariantsTprodLeftRegularLEquiv :
    Coinvariants (œÅ.tprod (leftRegular k G)) ‚âÉ‚Çó[k] V :=
  LinearEquiv.ofLinear (ofCoinvariantsTprodLeftRegular œÅ)
    (Coinvariants.mk _ ‚àò‚Çó (TensorProduct.mk k V (G ‚Üí‚ÇÄ k)).flip (single 1 1))
    (by ext; simp) (by ext; simp)

@[simp]
lemma coinvariantsTprodLeftRegularLEquiv_apply (x : (œÅ.tprod (leftRegular k G)).Coinvariants) :
    coinvariantsTprodLeftRegularLEquiv œÅ x = ofCoinvariantsTprodLeftRegular œÅ x := by
  rfl

end TensorProduct
end Representation

namespace Rep

open CategoryTheory Representation

variable {k G : Type u} [CommRing k]

noncomputable section

variable [Group G] (A : Rep k G) (S : Subgroup G) [S.Normal]

/-- Given a normal subgroup `S ‚â§ G`, a `G`-representation `A` restricts to a `G`-representation on
the kernel of the quotient map to the `S`-coinvariants `A_S`. -/
abbrev toCoinvariantsKer : Rep k G := Rep.of (A.œÅ.toCoinvariantsKer S)

/-- Given a normal subgroup `S ‚â§ G`, a `G`-representation `A` induces a `G`-representation on
the `S`-coinvariants `A_S`. -/
abbrev toCoinvariants : Rep k G := Rep.of (A.œÅ.toCoinvariants S)

/-- Given a normal subgroup `S ‚â§ G`, a `G`-representation `œÅ` induces a `G ‚ß∏ S`-representation on
the coinvariants of `œÅ|_S`. -/
abbrev quotientToCoinvariants : Rep k (G ‚ß∏ S) := ofQuotient (toCoinvariants A S) S

/-- Given a normal subgroup `S ‚â§ G`, a `G`-representation `A` induces a short exact sequence of
`G`-representations `0 ‚ü∂ Ker(mk) ‚ü∂ A ‚ü∂ A_S ‚ü∂ 0` where `mk` is the quotient map to the
`S`-coinvariants `A_S`. -/
@[simps X‚ÇÅ X‚ÇÇ X‚ÇÉ f g]
def coinvariantsShortComplex : ShortComplex (Rep k G) where
  X‚ÇÅ := toCoinvariantsKer A S
  X‚ÇÇ := A
  X‚ÇÉ := toCoinvariants A S
  f := subtype ..
  g := mkQ ..
  zero := by ext x; exact (Submodule.Quotient.mk_eq_zero _).2 x.2

lemma coinvariantsShortComplex_shortExact : (coinvariantsShortComplex A S).ShortExact where
  exact := (forget‚ÇÇ _ (ModuleCat k)).reflects_exact_of_faithful _ <|
    (ShortComplex.moduleCat_exact_iff _).2
      fun x hx => ‚ü®(‚ü®x, (Submodule.Quotient.mk_eq_zero _).1 hx‚ü© :
      Representation.Coinvariants.ker <| A.œÅ.comp S.subtype), rfl‚ü©
  mono_f := (Rep.mono_iff_injective _).2 fun _ _ h => Subtype.ext h
  epi_g := (Rep.epi_iff_surjective _).2 <| Submodule.mkQ_surjective _

end

variable (k G) [Monoid G] (A B : Rep k G)

/-- The functor sending a representation to its coinvariants. -/
@[simps! obj_carrier map_hom]
noncomputable def coinvariantsFunctor : Rep k G ‚•§ ModuleCat k where
  obj A := ModuleCat.of k A.œÅ.Coinvariants
  map f := ModuleCat.ofHom (Representation.Coinvariants.map _ _ f.hom.hom
    fun g => ModuleCat.hom_ext_iff.1 <| f.comm g)
  map_id _ := by simp
  map_comp _ _ := by ext; simp

/-- The quotient map from a representation to its coinvariants induces a natural transformation
from the forgetful functor `Rep k G ‚•§ ModuleCat k` to the coinvariants functor. -/
@[simps! app_hom]
noncomputable def coinvariantsMk : Action.forget (ModuleCat k) G ‚ü∂ coinvariantsFunctor k G where
  app (X : Rep k G) := ModuleCat.ofHom <| Representation.Coinvariants.mk X.œÅ

instance (X : Rep k G) : Epi ((coinvariantsMk k G).app X) :=
  (ModuleCat.epi_iff_surjective _).2 <| Representation.Coinvariants.mk_surjective X.œÅ

variable {k G A B}

@[ext]
lemma coinvariantsFunctor_hom_ext {M : ModuleCat k} {f g : (coinvariantsFunctor k G).obj A ‚ü∂ M}
    (hfg : (coinvariantsMk k G).app A ‚â´ f = (coinvariantsMk k G).app A ‚â´ g) :
    f = g := (cancel_epi _).1 hfg

/-- The linear map underlying a `G`-representation morphism `A ‚ü∂ B`, where `B` has the trivial
representation, factors through `A_G`. -/
noncomputable abbrev desc [B.œÅ.IsTrivial] (f : A ‚ü∂ B) :
    (coinvariantsFunctor k G).obj A ‚ü∂ B.V :=
  ModuleCat.ofHom <| Representation.Coinvariants.lift _ f.hom.hom fun _ => by
    ext
    have := hom_comm_apply f
    simp_all

variable (k G)

instance : (coinvariantsFunctor k G).Additive where
instance : (coinvariantsFunctor k G).Linear k where

/-- The adjunction between the functor sending a representation to its coinvariants and the functor
equipping a module with the trivial representation. -/
@[simps]
noncomputable def coinvariantsAdjunction : coinvariantsFunctor k G ‚ä£ trivialFunctor k G where
  unit := { app X := {
    hom := (coinvariantsMk k G).app X
    comm _ := by ext; simp [ModuleCat.endRingEquiv, trivialFunctor] }}
  counit := { app X := desc (B := trivial k G X) (ùüô _) }

@[simp]
theorem coinvariantsAdjunction_homEquiv_apply_hom {X : Rep k G} {Y : ModuleCat k}
    (f : (coinvariantsFunctor k G).obj X ‚ü∂ Y) :
    ((coinvariantsAdjunction k G).homEquiv X Y f).hom = (coinvariantsMk k G).app X ‚â´ f := by
  rfl

@[simp]
theorem coinvariantsAdjunction_homEquiv_symm_apply_hom {X : Rep k G} {Y : ModuleCat k}
    (f : X ‚ü∂ (trivialFunctor k G).obj Y) :
    ((coinvariantsAdjunction k G).homEquiv X Y).symm f = desc f := by
  ext
  simp [coinvariantsAdjunction, Adjunction.homEquiv_symm_apply]

instance : (coinvariantsFunctor k G).PreservesZeroMorphisms where
instance : (coinvariantsFunctor k G).IsLeftAdjoint := (coinvariantsAdjunction k G).isLeftAdjoint

/-- The functor sending `A, B` to `(A ‚äó[k] B)_G`. This is naturally isomorphic to the functor
sending `A, B` to `A ‚äó[k[G]] B`, where we give `A` the `k[G]·µê·µí·µñ`-module structure defined by
`g ‚Ä¢ a := A.œÅ g‚Åª¬π a`. -/
noncomputable abbrev coinvariantsTensor : Rep k G ‚•§ Rep k G ‚•§ ModuleCat k :=
  (Functor.postcompose‚ÇÇ.obj (coinvariantsFunctor k G)).obj (MonoidalCategory.curriedTensor _)

variable {k G} (A B)

/-- The bilinear map sending `a : A, b : B` to `‚ü¶a ‚äó‚Çú b‚üß` in `(A ‚äó[k] B)_G`. -/
noncomputable abbrev coinvariantsTensorMk :
    A ‚Üí‚Çó[k] B ‚Üí‚Çó[k] ((coinvariantsTensor k G).obj A).obj B :=
  (TensorProduct.mk k A B).compr‚ÇÇ (Coinvariants.mk _)

variable {A B}

lemma coinvariantsTensorMk_apply (a : A) (b : B) :
    coinvariantsTensorMk A B a b = Coinvariants.mk _ (a ‚äó‚Çú[k] b) := rfl

@[ext]
lemma coinvariantsTensor_hom_ext {M : ModuleCat k}
    {f g : ((coinvariantsTensor k G).obj A).obj B ‚ü∂ M}
    (hfg : (coinvariantsTensorMk A B).compr‚ÇÇ f.hom = (coinvariantsTensorMk A B).compr‚ÇÇ g.hom) :
    f = g := coinvariantsFunctor_hom_ext <| ModuleCat.hom_ext <| TensorProduct.ext <| hfg

instance (A : Rep k G) : ((coinvariantsTensor k G).obj A).Additive where
instance (A : Rep k G) : ((coinvariantsTensor k G).obj A).Linear k where

section

variable (k : Type u) {G : Type u} [CommRing k] [Group G]

/-- Given a normal subgroup `S ‚â§ G`, this is the functor sending a `G`-representation `A` to the
`G ‚ß∏ S`-representation it induces on `A_S`. -/
@[simps obj_V map_hom]
noncomputable def quotientToCoinvariantsFunctor (S : Subgroup G) [S.Normal] :
    Rep k G ‚•§ Rep k (G ‚ß∏ S) where
  obj X := X.quotientToCoinvariants S
  map {X Y} f := {
    hom := (coinvariantsFunctor k S).map ((Action.res _ S.subtype).map f)
    comm g := QuotientGroup.induction_on g fun g => by
      ext; simp [ModuleCat.endRingEquiv, hom_comm_apply] }

section Finsupp

variable {k} (A : Rep k G) (Œ± : Type u) [DecidableEq Œ±]

open MonoidalCategory Finsupp ModuleCat.MonoidalCategory

/-- Given a `k`-linear `G`-representation `(A, œÅ)` and a type `Œ±`, this is the map
`(A ‚äó (Œ± ‚Üí‚ÇÄ k[G]))_G ‚Üí‚Çó[k] (Œ± ‚Üí‚ÇÄ A)` sending
`‚ü¶a ‚äó single x (single g r)‚üß ‚Ü¶ single x (r ‚Ä¢ œÅ(g‚Åª¬π)(a)).` -/
noncomputable def coinvariantsTensorFreeToFinsupp :
    (A ‚äó free k G Œ±).œÅ.Coinvariants ‚Üí‚Çó[k] (Œ± ‚Üí‚ÇÄ A) :=
  (coinvariantsFinsuppLEquiv _ Œ± ‚â™‚â´‚Çó lcongr (Equiv.refl Œ±)
    (coinvariantsTprodLeftRegularLEquiv A.œÅ)).toLinearMap ‚àò‚Çó
    ((coinvariantsFunctor k G).map (finsuppTensorRight A (leftRegular k G) Œ±).hom).hom

variable {A Œ±}

@[simp]
lemma coinvariantsTensorFreeToFinsupp_mk_tmul_single (x : A) (i : Œ±) (g : G) (r : k) :
    DFunLike.coe (F := (A.œÅ.tprod (Representation.free k G Œ±)).Coinvariants ‚Üí‚Çó[k] Œ± ‚Üí‚ÇÄ A.V)
      (coinvariantsTensorFreeToFinsupp A Œ±) (Coinvariants.mk _ (x ‚äó‚Çú single i (single g r))) =
      single i (r ‚Ä¢ A.œÅ g‚Åª¬π x) := by
  simp [tensorObj_def, ModuleCat.MonoidalCategory.tensorObj, coinvariantsTensorFreeToFinsupp,
    Coinvariants.map, finsuppTensorRight, TensorProduct.finsuppRight]

variable (A Œ±)

/-- Given a `k`-linear `G`-representation `(A, œÅ)` and a type `Œ±`, this is the map
`(Œ± ‚Üí‚ÇÄ A) ‚Üí‚Çó[k] (A ‚äó (Œ± ‚Üí‚ÇÄ k[G]))_G` sending `single x a ‚Ü¶ ‚ü¶a ‚äó‚Çú single x 1‚üß.` -/
noncomputable def finsuppToCoinvariantsTensorFree :
    (Œ± ‚Üí‚ÇÄ A) ‚Üí‚Çó[k] Coinvariants (A ‚äó (free k G Œ±)).œÅ :=
  ((coinvariantsFunctor k G).map ((finsuppTensorRight A (leftRegular k G) Œ±)).inv).hom ‚àò‚Çó
    (coinvariantsFinsuppLEquiv _ Œ± ‚â™‚â´‚Çó
    lcongr (Equiv.refl Œ±) (coinvariantsTprodLeftRegularLEquiv A.œÅ)).symm.toLinearMap

variable {A Œ±}

@[simp]
lemma finsuppToCoinvariantsTensorFree_single (i : Œ±) (x : A) :
    DFunLike.coe (F := (Œ± ‚Üí‚ÇÄ A.V) ‚Üí‚Çó[k] (A.œÅ.tprod (Representation.free k G Œ±)).Coinvariants)
      (finsuppToCoinvariantsTensorFree A Œ±) (single i x) =
      Coinvariants.mk _ (x ‚äó‚Çú single i (single (1 : G) (1 : k))) := by
  simp [finsuppToCoinvariantsTensorFree, Coinvariants.map, ModuleCat.MonoidalCategory.tensorObj,
    tensorObj_def]

variable (A Œ±)

/-- Given a `k`-linear `G`-representation `(A, œÅ)` and a type `Œ±`, this is the linear equivalence
`(A ‚äó (Œ± ‚Üí‚ÇÄ k[G]))_G ‚âÉ‚Çó[k] (Œ± ‚Üí‚ÇÄ A)` sending
`‚ü¶a ‚äó single x (single g r)‚üß ‚Ü¶ single x (r ‚Ä¢ œÅ(g‚Åª¬π)(a)).` -/
@[simps! symm_apply]
noncomputable abbrev coinvariantsTensorFreeLEquiv :
    Coinvariants (A ‚äó free k G Œ±).œÅ ‚âÉ‚Çó[k] (Œ± ‚Üí‚ÇÄ A) :=
  LinearEquiv.ofLinear (coinvariantsTensorFreeToFinsupp A Œ±) (finsuppToCoinvariantsTensorFree A Œ±)
    (lhom_ext fun i x => by
      simp [finsuppToCoinvariantsTensorFree_single i,
        coinvariantsTensorFreeToFinsupp_mk_tmul_single x]) <|
    Coinvariants.hom_ext <| TensorProduct.ext <| LinearMap.ext fun a => lhom_ext' fun i =>
      lhom_ext fun g r => by
        simp [coinvariantsTensorFreeToFinsupp_mk_tmul_single a,
          finsuppToCoinvariantsTensorFree_single (A := A) i, TensorProduct.smul_tmul]

@[simp]
lemma coinvariantsTensorFreeLEquiv_apply (x : (A ‚äó free k G Œ±).œÅ.Coinvariants) :
    DFunLike.coe (F := (A.œÅ.tprod (Representation.free k G Œ±)).Coinvariants ‚Üí‚Çó[k] Œ± ‚Üí‚ÇÄ A)
      (A.coinvariantsTensorFreeToFinsupp Œ±) x = coinvariantsTensorFreeToFinsupp A Œ± x := by
  rfl

end Finsupp

end

end Rep
