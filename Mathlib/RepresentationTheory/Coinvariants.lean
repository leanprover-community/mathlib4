/-
Copyright (c) 2025 Amelia Livingston. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Amelia Livingston
-/
import Mathlib.Algebra.Homology.ShortComplex.ModuleCat
import Mathlib.RepresentationTheory.Rep

/-!
# Coinvariants a group representation

Given a commutative ring `k` and a monoid `G`, this file introduces the coinvariants of a
`k`-linear `G`-representation `(V, Ï)`.

We first define `Representation.augmentationSubmodule`, the submodule of `V` generated by elements
of the form `Ï g x - x` for `x : V`, `g : G`. Then the coinvariants of `(V, Ï)` are the quotient of
`V` by this submodule. We show that the functor sending a representation to its coinvariants is
left adjoint to the functor equipping a module with the trivial representation.

-/

universe u v

namespace Representation

variable {k G V W : Type*} [CommRing k] [Monoid G] [AddCommGroup V] [Module k V]
  [AddCommGroup W] [Module k W] (Ï : Representation k G V) (Ï„ : Representation k G W)

/-- The submodule of a representation generated by elements of the form `Ï g x - x`. -/
def augmentationSubmodule : Submodule k V :=
  Submodule.span k (Set.range fun (x : G Ã— V) => Ï x.1 x.2 - x.2)

variable {Ï}

lemma mem_augmentationSubmodule_of_eq (g : G) (x : V) (a : V) (h : Ï g x - x = a) :
    a âˆˆ augmentationSubmodule Ï :=
  Submodule.subset_span âŸ¨(g, x), hâŸ©

variable (Ï)

/-- The coinvariants of a representation, `V â§¸ âŸ¨{Ï g x - x | g âˆˆ G, x âˆˆ V}âŸ©`. -/
def Coinvariants := V â§¸ augmentationSubmodule Ï

namespace Coinvariants

instance : AddCommGroup (Coinvariants Ï) := by unfold Coinvariants; infer_instance
instance : Module k (Coinvariants Ï) := by unfold Coinvariants; infer_instance

/-- The quotient map from a representation to its coinvariants as a linear map. -/
def mk : V â†’â‚—[k] Coinvariants Ï := Submodule.mkQ (augmentationSubmodule Ï)

theorem mk_eq_iff {x y : V} :
    mk Ï x = mk Ï y â†” x - y âˆˆ Ï.augmentationSubmodule :=
  Submodule.Quotient.eq _

@[simp]
lemma mk_Ï_apply (g : G) (x : V) :
    mk Ï (Ï g x) = mk Ï x :=
  (mk_eq_iff _).2 <| mem_augmentationSubmodule_of_eq g x _ rfl

@[elab_as_elim]
theorem induction_on {C : Coinvariants Ï â†’ Prop} (x : Coinvariants Ï) (h : âˆ€ v : V, C (mk Ï v)) :
    C x :=
  Submodule.Quotient.induction_on _ x h

/-- A `G`-invariant linear map induces a linear map out of the coinvariants of a
`G`-representation. -/
def lift (f : V â†’â‚—[k] W) (h : âˆ€ (x : G), f âˆ˜â‚— Ï x = f) :
    Ï.Coinvariants â†’â‚—[k] W :=
  Submodule.liftQ _ f <| Submodule.span_le.2 fun x âŸ¨âŸ¨g, yâŸ©, hyâŸ© => by
    simpa only [â† hy, SetLike.mem_coe, LinearMap.mem_ker, map_sub, sub_eq_zero, LinearMap.coe_comp,
      Function.comp_apply] using LinearMap.ext_iff.1 (h g) y

variable {Ï}

@[simp]
theorem lift_comp_mk (f : V â†’â‚—[k] W) (h : âˆ€ (x : G), f âˆ˜â‚— Ï x = f) :
    lift Ï f h âˆ˜â‚— mk Ï = f := rfl

@[simp]
theorem lift_mk (f : V â†’â‚—[k] W) (h : âˆ€ (x : G), f âˆ˜â‚— Ï x = f) (x : V) :
    lift Ï f h (mk _ x) = f x := rfl

@[ext]
lemma hom_ext {f g : Coinvariants Ï â†’â‚—[k] W} (H : f âˆ˜â‚— mk Ï = g âˆ˜â‚— mk Ï) : f = g :=
  Submodule.linearMap_qext _ H

variable (Ï)

/-- Given `G`-representations on `k`-modules `V, W`, a linear map `V â†’â‚—[k] W` commuting with
the representations induces a `k`-linear map between the coinvariants. -/
noncomputable def map (f : V â†’â‚—[k] W) (hf : âˆ€ g, f âˆ˜â‚— Ï g = Ï„ g âˆ˜â‚— f) :
    Coinvariants Ï â†’â‚—[k] Coinvariants Ï„ :=
  lift _ (mk _ âˆ˜â‚— f) fun g => LinearMap.ext fun x => (mk_eq_iff _).2 <|
    mem_augmentationSubmodule_of_eq (Ï := Ï„) g (f x) _ <| by simpa using congr($((hf g).symm) x)

variable {Ï Ï„}

@[simp]
lemma map_comp_mk {f : V â†’â‚—[k] W} {hf : âˆ€ g, f âˆ˜â‚— Ï g = Ï„ g âˆ˜â‚— f} :
    map Ï Ï„ f hf âˆ˜â‚— mk Ï = mk Ï„ âˆ˜â‚— f := rfl

@[simp]
lemma map_mk (f : V â†’â‚—[k] W) (hf : âˆ€ g, f âˆ˜â‚— Ï g = Ï„ g âˆ˜â‚— f) (x : V) :
    map Ï Ï„ f hf (mk _ x) = mk _ (f x) := rfl

end Coinvariants
section

variable {k G V : Type*} [CommRing k] [Group G] [AddCommGroup V] [Module k V]
variable (Ï : Representation k G V) (S : Subgroup G) [S.Normal]

lemma le_comap_augmentationSubmodule (g : G) :
    augmentationSubmodule (Ï.comp S.subtype) â‰¤
      (augmentationSubmodule <| Ï.comp S.subtype).comap (Ï g) :=
  Submodule.span_le.2 fun _ âŸ¨âŸ¨s, xâŸ©, hsâŸ© => by
    simpa [â† hs] using mem_augmentationSubmodule_of_eq
      âŸ¨g * s * gâ»Â¹, Subgroup.Normal.conj_mem â€¹_â€º s.1 s.2 gâŸ© (Ï g x) _ <| by simp

/-- Given a normal subgroup `S â‰¤ G`, a `G`-representation `Ï` restricts to a `G`-representation on
the augmentation submodule of `Ï|_S`. -/
noncomputable abbrev toAugmentationSubmodule :
    Representation k G (augmentationSubmodule <| Ï.comp S.subtype) :=
  subrepresentation Ï (augmentationSubmodule <| Ï.comp S.subtype)
    fun g => le_comap_augmentationSubmodule Ï S g

/-- Given a normal subgroup `S â‰¤ G`, a `G`-representation `Ï` induces a `G`-representation on the
coinvariants of `Ï|_S`. -/
noncomputable abbrev toCoinvariants :
    Representation k G (Coinvariants <| Ï.comp S.subtype) :=
  quotient Ï (augmentationSubmodule <| Ï.comp S.subtype)
    fun g => le_comap_augmentationSubmodule Ï S g

instance : IsTrivial ((toCoinvariants Ï S).comp S.subtype) where
  out g := by
    ext x
    exact (Coinvariants.mk_eq_iff _).2 <| mem_augmentationSubmodule_of_eq g x _ rfl

/-- Given a normal subgroup `S â‰¤ G`, a `G`-representation `Ï` induces a `G â§¸ S`-representation on
the coinvariants of `Ï|_S`. -/
noncomputable abbrev quotientToCoinvariants :
    Representation k (G â§¸ S) (Coinvariants (Ï.comp S.subtype)) :=
  ofQuotient (toCoinvariants Ï S) S

end

end Representation

namespace Rep

open CategoryTheory Representation

namespace Coinvariants

variable {k G : Type u} [CommRing k] [Monoid G] {A B C : Rep k G} {n : â„•}

/-- The linear map underlying a `G`-representation morphism `A âŸ¶ B`, where `B` has the trivial
representation, factors through `A_G`. -/
noncomputable abbrev lift [B.Ï.IsTrivial] (f : A âŸ¶ B) :
    A.Ï.Coinvariants â†’â‚—[k] B :=
  Representation.Coinvariants.lift _ f.hom.hom fun _ => by
    ext
    have := hom_comm_apply f
    simp_all

/-- A `G`-representation morphism `A âŸ¶ B` induces a linear map `A_G â†’â‚—[k] B_G`. -/
noncomputable abbrev map (f : A âŸ¶ B) :
    A.Ï.Coinvariants â†’â‚—[k] B.Ï.Coinvariants :=
  Representation.Coinvariants.map _ _ f.hom.hom fun _ => ModuleCat.hom_ext_iff.1 (f.comm _)

@[simp]
theorem map_id (A : Rep k G) :
    map (ğŸ™ A) = LinearMap.id := by
  ext; rfl

@[simp]
theorem map_comp (f : A âŸ¶ B) (g : B âŸ¶ C) :
    map (f â‰« g) = map g âˆ˜â‚— map f := by
  ext; rfl

noncomputable section

variable {k G : Type u} [CommRing k] [Group G] (A : Rep k G) (S : Subgroup G) [S.Normal]

/-- Given a normal subgroup `S â‰¤ G`, a `G`-representation `Ï` restricts to a `G`-representation on
the augmentation submodule of `Ï|_S`. -/
abbrev toAugmentationSubmodule : Rep k G := Rep.of (A.Ï.toAugmentationSubmodule S)

/-- Given a normal subgroup `S â‰¤ G`, a `G`-representation `Ï` induces a `G`-representation on the
coinvariants of `Ï|_S`. -/
abbrev toCoinvariants : Rep k G := Rep.of (A.Ï.toCoinvariants S)

/-- Given a normal subgroup `S â‰¤ G`, a `G`-representation `A` induces a short exact sequence of
`G`-representations `0 âŸ¶ I(S)A âŸ¶ A âŸ¶ A_S âŸ¶ 0` where `I(S)A` is the submodule of `A`
generated by elements of the form `Ï(s)(x) - x` for `s : S, x : A`. -/
@[simps Xâ‚ Xâ‚‚ Xâ‚ƒ f g]
def coinvariantsShortComplex : ShortComplex (Rep k G) where
  Xâ‚ := toAugmentationSubmodule A S
  Xâ‚‚ := A
  Xâ‚ƒ := toCoinvariants A S
  f := subtype ..
  g := mkQ ..
  zero := by ext x; exact (Submodule.Quotient.mk_eq_zero _).2 x.2

lemma coinvariantsShortComplex_shortExact : (coinvariantsShortComplex A S).ShortExact where
  exact := (forgetâ‚‚ _ (ModuleCat k)).reflects_exact_of_faithful _ <|
    (ShortComplex.moduleCat_exact_iff _).2
      fun x hx => âŸ¨(âŸ¨x, (Submodule.Quotient.mk_eq_zero _).1 hxâŸ© :
      Representation.augmentationSubmodule <| A.Ï.comp S.subtype), rflâŸ©
  mono_f := (Rep.mono_iff_injective _).2 fun _ _ h => Subtype.ext h
  epi_g := (Rep.epi_iff_surjective _).2 <| Submodule.mkQ_surjective _

/-- Given a normal subgroup `S â‰¤ G`, a `G`-representation `Ï` induces a `G â§¸ S`-representation on
the coinvariants of `Ï|_S`. -/
abbrev quotientToCoinvariants : Rep k (G â§¸ S) := ofQuotient (toCoinvariants A S) S

end

variable (k G)

/-- The functor sending a representation to its coinvariants. -/
@[simps obj map]
noncomputable def functor : Rep k G â¥¤ ModuleCat k where
  obj A := ModuleCat.of k (A.Ï.Coinvariants)
  map f := ModuleCat.ofHom (map f)

variable {k G} in
@[ext]
lemma functor_hom_ext {M : ModuleCat k} {f g : (functor k G).obj A âŸ¶ M}
    (hfg : f.hom âˆ˜â‚— Coinvariants.mk A.Ï = g.hom âˆ˜â‚— Coinvariants.mk A.Ï) :
    f = g := ModuleCat.hom_ext <| Coinvariants.hom_ext hfg

instance : (functor k G).Additive where
  map_add := ModuleCat.hom_ext <| LinearMap.ext fun x => Quotient.inductionOn' x (fun _ => rfl)

/-- The adjunction between the functor sending a representation to its coinvariants and the functor
equipping a module with the trivial representation. -/
noncomputable def adjunction : functor k G âŠ£ trivialFunctor G :=
  Adjunction.mkOfHomEquiv {
    homEquiv X Y := {
      toFun f := {
        hom := ModuleCat.ofHom (f.hom âˆ˜â‚— Coinvariants.mk X.Ï)
        comm g := by
          ext x
          exact congr(f.hom $((Coinvariants.mk_eq_iff X.Ï).2
            (X.Ï.mem_augmentationSubmodule_of_eq g x _ rfl))) }
      invFun f := ModuleCat.ofHom (lift f)
      left_inv _ := by ext; rfl
      right_inv _ := Action.Hom.ext <| rfl }
    homEquiv_naturality_left_symm _ _ := by ext; rfl
    homEquiv_naturality_right := by intros; rfl }

instance : (functor k G).PreservesZeroMorphisms where
  map_zero _ _ := by ext; rfl

instance : Limits.PreservesColimits (functor k G) :=
  (adjunction k G).leftAdjoint_preservesColimits

end Coinvariants
end Rep
