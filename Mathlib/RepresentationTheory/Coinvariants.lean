/-
Copyright (c) 2025 Amelia Livingston. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Amelia Livingston
-/
import Mathlib.RepresentationTheory.Rep

/-!
# Coinvariants a group representation

Given a commutative ring `k` and a monoid `G`, this file introduces the coinvariants of a
`k`-linear `G`-representation `(V, Ï)`.

We first define `Representation.Coinvariants.ker`, the submodule of `V` generated by elements
of the form `Ï g x - x` for `x : V`, `g : G`. Then the coinvariants of `(V, Ï)` are the quotient of
`V` by this submodule. We show that the functor sending a representation to its coinvariants is
left adjoint to the functor equipping a module with the trivial representation.

## Main definitions

* `Representation.Coinvariants Ï`: the coinvariants of a representation `Ï`.
* `Representation.coinvariantsFinsuppLEquiv Ï Î±`: given a type `Î±`, this is the `k`-linear
  equivalence between `(Î± â†’â‚€ V)_G` and `Î± â†’â‚€ V_G`.
* `Representation.coinvariantsTprodLeftRegularLEquiv Ï`: the `k`-linear equivalence between
  `(V âŠ— k[G])_G` and `V` sending `âŸ¦v âŠ— single g râŸ§ â†¦ r â€¢ Ï(gâ»Â¹)(v)`.
* `Rep.coinvariantsAdjunction k G`: the adjunction between the functor sending a representation to
  its coinvariants and the functor equipping a module with the trivial representation.
* `Rep.coinvariantsTensor k G`: the functor sending representations `A, B` to `(A âŠ—[k] B)_G`. This
  is naturally isomorphic to the functor sending `A, B` to `A âŠ—[k[G]] B`, where we give `A` the
  `k[G]áµáµ’áµ–`-module structure defined by `g â€¢ a := A.Ï gâ»Â¹ a`.
* `Rep.coinvariantsTensorFreeLEquiv A Î±`: given a representation `A` and a type `Î±`, this is the
  `k`-linear equivalence between `(A âŠ— (Î± â†’â‚€ k[G]))_G` and `Î± â†’â‚€ A` sending
  `âŸ¦a âŠ— single x (single g r)âŸ§ â†¦ single x (r â€¢ Ï(gâ»Â¹)(a))`. This is useful for group homology.

-/

universe u v

namespace Representation

variable {k G V W X : Type*} [CommRing k] [Monoid G] [AddCommGroup V] [Module k V]
  [AddCommGroup W] [Module k W] [AddCommGroup X] [Module k X]
  (Ï : Representation k G V) (Ï„ : Representation k G W) (Ï… : Representation k G X)

/-- The submodule of a representation generated by elements of the form `Ï g x - x`. -/
def Coinvariants.ker : Submodule k V :=
  Submodule.span k (Set.range fun (gv : G Ã— V) => Ï gv.1 gv.2 - gv.2)

/-- The coinvariants of a representation, `V â§¸ âŸ¨{Ï g x - x | g âˆˆ G, x âˆˆ V}âŸ©`. -/
def Coinvariants := V â§¸ Coinvariants.ker Ï

namespace Coinvariants

instance : AddCommGroup (Coinvariants Ï) := inferInstanceAs <| AddCommGroup (_ â§¸ _)
instance : Module k (Coinvariants Ï) := inferInstanceAs <| Module k (_ â§¸ _)

variable {Ï}

lemma sub_mem_ker (g : G) (x : V) : Ï g x - x âˆˆ Coinvariants.ker Ï :=
  Submodule.subset_span <| Set.mem_range_self (g, x)

lemma mem_ker_of_eq (g : G) (x : V) (a : V) (h : Ï g x - x = a) : a âˆˆ ker Ï :=
  Submodule.subset_span âŸ¨(g, x), hâŸ©

variable (Ï)

/-- The quotient map from a representation to its coinvariants as a linear map. -/
def mk : V â†’â‚—[k] Coinvariants Ï := Submodule.mkQ (ker Ï)

theorem mk_eq_iff {x y : V} :
    mk Ï x = mk Ï y â†” x - y âˆˆ Coinvariants.ker Ï :=
  Submodule.Quotient.eq _

theorem mk_eq_zero {x : V} :
    mk Ï x = 0 â†” x âˆˆ Coinvariants.ker Ï :=
  Submodule.Quotient.mk_eq_zero _

theorem mk_surjective : Function.Surjective (mk Ï) :=
  Submodule.Quotient.mk_surjective _

@[simp]
lemma mk_self_apply (g : G) (x : V) :
    mk Ï (Ï g x) = mk Ï x :=
  (mk_eq_iff _).2 <| mem_ker_of_eq g x _ rfl

variable {Ï} in
@[elab_as_elim]
theorem induction_on {motive : Coinvariants Ï â†’ Prop} (x : Coinvariants Ï)
    (h : âˆ€ v : V, motive (mk Ï v)) :
    motive x :=
  Submodule.Quotient.induction_on _ x h

/-- A `G`-invariant linear map induces a linear map out of the coinvariants of a
`G`-representation. -/
def lift (f : V â†’â‚—[k] W) (h : âˆ€ (x : G), f âˆ˜â‚— Ï x = f) :
    Ï.Coinvariants â†’â‚—[k] W :=
  Submodule.liftQ _ f <| Submodule.span_le.2 fun x âŸ¨âŸ¨g, yâŸ©, hyâŸ© => by
    simpa only [â† hy, SetLike.mem_coe, LinearMap.mem_ker, map_sub, sub_eq_zero, LinearMap.coe_comp,
      Function.comp_apply] using LinearMap.ext_iff.1 (h g) y

@[simp]
theorem lift_comp_mk (f : V â†’â‚—[k] W) (h : âˆ€ (x : G), f âˆ˜â‚— Ï x = f) :
    lift Ï f h âˆ˜â‚— mk Ï = f := rfl

@[simp]
theorem lift_mk (f : V â†’â‚—[k] W) (h : âˆ€ (x : G), f âˆ˜â‚— Ï x = f) (x : V) :
    lift Ï f h (mk _ x) = f x := rfl

variable {Ï} in
@[ext high]
lemma hom_ext {f g : Coinvariants Ï â†’â‚—[k] W} (H : f âˆ˜â‚— mk Ï = g âˆ˜â‚— mk Ï) : f = g :=
  Submodule.linearMap_qext _ H

/-- Given `G`-representations on `k`-modules `V, W`, a linear map `V â†’â‚—[k] W` commuting with
the representations induces a `k`-linear map between the coinvariants. -/
noncomputable def map (f : V â†’â‚—[k] W) (hf : âˆ€ g, f âˆ˜â‚— Ï g = Ï„ g âˆ˜â‚— f) :
    Coinvariants Ï â†’â‚—[k] Coinvariants Ï„ :=
  lift _ (mk _ âˆ˜â‚— f) fun g => LinearMap.ext fun x => (mk_eq_iff _).2 <|
    mem_ker_of_eq g (f x) _ <| by simpa using congr($((hf g).symm) x)

variable {Ï Ï„}

@[simp]
lemma map_comp_mk (f : V â†’â‚—[k] W) (hf : âˆ€ g, f âˆ˜â‚— Ï g = Ï„ g âˆ˜â‚— f) :
    map Ï Ï„ f hf âˆ˜â‚— mk Ï = mk Ï„ âˆ˜â‚— f := rfl

@[simp]
lemma map_mk (f : V â†’â‚—[k] W) (hf : âˆ€ g, f âˆ˜â‚— Ï g = Ï„ g âˆ˜â‚— f) (x : V) :
    map Ï Ï„ f hf (mk _ x) = mk _ (f x) := rfl

@[simp]
lemma map_id (Ï : Representation k G V) :
    map Ï Ï LinearMap.id (by simp) = LinearMap.id := by
  ext; rfl

@[simp]
lemma map_comp (Ï† : V â†’â‚—[k] W) (Ïˆ : W â†’â‚—[k] X)
    (H : âˆ€ g, Ï† âˆ˜â‚— Ï g = Ï„ g âˆ˜â‚— Ï†) (h : âˆ€ g, Ïˆ âˆ˜â‚— Ï„ g = Ï… g âˆ˜â‚— Ïˆ) :
    map Ï„ Ï… Ïˆ h âˆ˜â‚— map Ï Ï„ Ï† H = map Ï Ï… (Ïˆ âˆ˜â‚— Ï†) (fun g => by
      ext x; have : Ï† _ = _ := congr($(H g) x); have : Ïˆ _ = _ := congr($(h g) (Ï† x)); simp_all) :=
  hom_ext rfl

end Coinvariants

section Finsupp

open Finsupp Coinvariants

variable {k G V : Type*} [CommRing k] [Group G] [AddCommGroup V] [Module k V]
  (Ï : Representation k G V) (Î± : Type*)

/-- Given a `G`-representation `(V, Ï)` and a type `Î±`, this is the map `(Î± â†’â‚€ V)_G â†’â‚— (Î± â†’â‚€ V_G)`
sending `âŸ¦single a vâŸ§ â†¦ single a âŸ¦vâŸ§`. -/
noncomputable def coinvariantsToFinsupp :
    Coinvariants (Ï.finsupp Î±) â†’â‚—[k] Î± â†’â‚€ Coinvariants Ï :=
  Coinvariants.lift _ (mapRange.linearMap (Coinvariants.mk _)) <| fun _ => by ext; simp

variable {Ï Î±}

@[simp]
lemma coinvariantsToFinsupp_mk_single (x : Î±) (a : V) :
    coinvariantsToFinsupp Ï Î± (Coinvariants.mk _ (single x a)) =
      single x (Coinvariants.mk _ a) := by
  simp [coinvariantsToFinsupp]

variable (Ï Î±) in
/-- Given a `G`-representation `(V, Ï)` and a type `Î±`, this is the map `(Î± â†’â‚€ V_G) â†’â‚— (Î± â†’â‚€ V)_G`
sending `single a âŸ¦vâŸ§ â†¦ âŸ¦single a vâŸ§`. -/
noncomputable def finsuppToCoinvariants :
    (Î± â†’â‚€ Coinvariants Ï) â†’â‚—[k] Coinvariants (Ï.finsupp Î±) :=
  lsum (R := k) k fun a => Coinvariants.lift _ (Coinvariants.mk _ âˆ˜â‚— lsingle a) fun g =>
    LinearMap.ext fun x => (mk_eq_iff _).2 <| mem_ker_of_eq g (single a x) _ <| by simp

@[simp]
lemma finsuppToCoinvariants_single_mk (a : Î±) (x : V) :
    finsuppToCoinvariants Ï Î± (single a <| Coinvariants.mk _ x) =
      Coinvariants.mk _ (single a x) := by
  simp [finsuppToCoinvariants]

variable (Ï Î±) in
/-- Given a `G`-representation `(V, Ï)` and a type `Î±`, this is the linear equivalence
`(Î± â†’â‚€ V)_G â‰ƒâ‚— (Î± â†’â‚€ V_G)` sending `âŸ¦single a vâŸ§ â†¦ single a âŸ¦vâŸ§`. -/
@[simps! symm_apply]
noncomputable def coinvariantsFinsuppLEquiv :
    Coinvariants (Ï.finsupp Î±) â‰ƒâ‚—[k] Î± â†’â‚€ Coinvariants Ï :=
  LinearEquiv.ofLinear (coinvariantsToFinsupp Ï Î±) (finsuppToCoinvariants Ï Î±)
    (by ext; simp) (by ext; simp)

@[simp]
lemma coinvariantsFinsuppLEquiv_apply (x) :
    coinvariantsFinsuppLEquiv Ï Î± x = coinvariantsToFinsupp Ï Î± x := by rfl

end Finsupp

section TensorProduct

open TensorProduct Coinvariants Finsupp

variable {k G V W : Type*} [CommRing k] [Group G] [AddCommGroup V] [Module k V]
  [AddCommGroup W] [Module k W] (Ï : Representation k G V) (Ï„ : Representation k G W)

@[simp]
lemma Coinvariants.mk_inv_tmul (x : V) (y : W) (g : G) :
    Coinvariants.mk (Ï.tprod Ï„) (Ï gâ»Â¹ x âŠ—â‚œ[k] y) = Coinvariants.mk (Ï.tprod Ï„) (x âŠ—â‚œ[k] Ï„ g y) :=
  (mk_eq_iff _).2 <| mem_augmentationSubmodule_of_eq gâ»Â¹ (x âŠ—â‚œ[k] Ï„ g y) _ <| by simp

@[simp]
lemma Coinvariants.mk_tmul_inv (x : V) (y : W) (g : G) :
    Coinvariants.mk (Ï.tprod Ï„) (x âŠ—â‚œ[k] Ï„ gâ»Â¹ y) = Coinvariants.mk (Ï.tprod Ï„) (Ï g x âŠ—â‚œ[k] y) :=
  (mk_eq_iff _).2 <| mem_augmentationSubmodule_of_eq gâ»Â¹ (Ï g x âŠ—â‚œ[k] y) _ <| by simp

/-- Given a `k`-linear `G`-representation `V, Ï`, this is the map `(V âŠ— k[G])_G â†’â‚—[k] V` sending
`âŸ¦v âŠ— single g râŸ§ â†¦ r â€¢ Ï(gâ»Â¹)(v)`. -/
noncomputable def ofCoinvariantsTprodLeftRegular :
    Coinvariants (Ï.tprod (leftRegular k G)) â†’â‚—[k] V :=
  Coinvariants.lift _ (TensorProduct.lift (Finsupp.linearCombination _ fun g => Ï gâ»Â¹) âˆ˜â‚—
    (TensorProduct.comm _ _ _).toLinearMap) fun _ => by ext; simp

@[simp]
lemma ofCoinvariantsTprodLeftRegular_mk_tmul_single (x : V) (g : G) (r : k) :
    ofCoinvariantsTprodLeftRegular Ï (Coinvariants.mk _ (x âŠ—â‚œ Finsupp.single g r)) = r â€¢ Ï gâ»Â¹ x :=
  congr($(Finsupp.linearCombination_single k (v := fun g => Ï gâ»Â¹) r g) x)

/-- Given a `k`-linear `G`-representation `(V, Ï)`, this is the linear equivalence
`(V âŠ— k[G])_G â‰ƒâ‚—[k] V` sending `âŸ¦v âŠ— single g râŸ§ â†¦ r â€¢ Ï(gâ»Â¹)(v)`. -/
@[simps! symm_apply]
noncomputable def coinvariantsTprodLeftRegularLEquiv :
    Coinvariants (Ï.tprod (leftRegular k G)) â‰ƒâ‚—[k] V :=
  LinearEquiv.ofLinear (ofCoinvariantsTprodLeftRegular Ï)
    (Coinvariants.mk _ âˆ˜â‚— (TensorProduct.mk k V (G â†’â‚€ k)).flip (single 1 1)) (by ext; simp) <| by
      ext x g
      exact (mk_eq_iff _).2 <| mem_augmentationSubmodule_of_eq gâ»Â¹ (x âŠ—â‚œ single g 1) _ <| by
        simp [smul_tmul', smul_tmul]

@[simp]
lemma coinvariantsTprodLeftRegularLEquiv_apply (x) :
    coinvariantsTprodLeftRegularLEquiv Ï x = ofCoinvariantsTprodLeftRegular Ï x := by
  rfl

end TensorProduct
end
end Representation

namespace Rep

open CategoryTheory Representation

variable {k G : Type u} [CommRing k] [Monoid G] {A B C : Rep k G} {n : â„•}

variable (k G)

/-- The functor sending a representation to its coinvariants. -/
@[simps! obj_carrier map_hom]
noncomputable def coinvariantsFunctor : Rep k G â¥¤ ModuleCat k where
  obj A := ModuleCat.of k A.Ï.Coinvariants
  map f := ModuleCat.ofHom (Representation.Coinvariants.map _ _ f.hom.hom
    fun g => ModuleCat.hom_ext_iff.1 <| f.comm g)
  map_id _ := by simp
  map_comp _ _ := by ext; simp

/-- The quotient map from a representation to its coinvariants induces a natural transformation
from the forgetful functor `Rep k G â¥¤ ModuleCat k` to the coinvariants functor. -/
@[simps! app_hom]
noncomputable def coinvariantsMk : Action.forget (ModuleCat k) G âŸ¶ coinvariantsFunctor k G where
  app (X : Rep k G) := ModuleCat.ofHom <| Representation.Coinvariants.mk X.Ï

instance (X : Rep k G) : Epi ((coinvariantsMk k G).app X) :=
  (ModuleCat.epi_iff_surjective _).2 <| Representation.Coinvariants.mk_surjective X.Ï

variable {k G}

@[ext]
lemma coinvariantsFunctor_hom_ext {M : ModuleCat k} {f g : (coinvariantsFunctor k G).obj A âŸ¶ M}
    (hfg : (coinvariantsMk k G).app A â‰« f = (coinvariantsMk k G).app A â‰« g) :
    f = g := (cancel_epi _).1 hfg

/-- The linear map underlying a `G`-representation morphism `A âŸ¶ B`, where `B` has the trivial
representation, factors through `A_G`. -/
noncomputable abbrev desc [B.Ï.IsTrivial] (f : A âŸ¶ B) :
    (coinvariantsFunctor k G).obj A âŸ¶ B.V :=
  ModuleCat.ofHom <| Representation.Coinvariants.lift _ f.hom.hom fun _ => by
    ext
    have := hom_comm_apply f
    simp_all

variable (k G)

instance : (coinvariantsFunctor k G).Additive where
instance : (coinvariantsFunctor k G).Linear k where

/-- The adjunction between the functor sending a representation to its coinvariants and the functor
equipping a module with the trivial representation. -/
@[simps]
noncomputable def coinvariantsAdjunction : coinvariantsFunctor k G âŠ£ trivialFunctor k G where
  unit := { app X := {
    hom := (coinvariantsMk k G).app X
    comm _ := by ext; simp [ModuleCat.endRingEquiv, trivialFunctor] }}
  counit := { app X := desc (B := trivial k G X) (ğŸ™ _) }

@[simp]
theorem coinvariantsAdjunction_homEquiv_apply_hom {X : Rep k G} {Y : ModuleCat k}
    (f : (coinvariantsFunctor k G).obj X âŸ¶ Y) :
    ((coinvariantsAdjunction k G).homEquiv X Y f).hom = (coinvariantsMk k G).app X â‰« f := by
  rfl

@[simp]
theorem coinvariantsAdjunction_homEquiv_symm_apply_hom {X : Rep k G} {Y : ModuleCat k}
    (f : X âŸ¶ (trivialFunctor k G).obj Y) :
    ((coinvariantsAdjunction k G).homEquiv X Y).symm f = desc f := by
  ext
  simp [coinvariantsAdjunction, Adjunction.homEquiv_symm_apply]

instance : (coinvariantsFunctor k G).PreservesZeroMorphisms where
instance : (coinvariantsFunctor k G).IsLeftAdjoint := (coinvariantsAdjunction k G).isLeftAdjoint


end Coinvariants

variable (k G) in
open MonoidalCategory ModuleCat.MonoidalCategory in
/-- The functor sending `A, B` to `(A âŠ—[k] B)_G`. This is naturally isomorphic to the functor
sending `A, B` to `A âŠ—[k[G]] B`, where we give `A` the `k[G]áµáµ’áµ–`-module structure defined by
`g â€¢ a := A.Ï gâ»Â¹ a`. -/
@[simps]
noncomputable def coinvariantsTensor : Rep k G â¥¤ Rep k G â¥¤ ModuleCat k where
  obj A := MonoidalCategory.tensorLeft A â‹™ Coinvariants.functor k G
  map f := {
    app A := ModuleCat.ofHom (Coinvariants.map (f âŠ— ğŸ™ A))
    naturality _ _ _ := Coinvariants.functor_hom_ext <| TensorProduct.ext' fun _ _ => by rfl }
  map_id _ := NatTrans.ext <| funext fun _ => by simp
  map_comp _ _ := NatTrans.ext <| funext fun _ => by simp

variable (A B)

/-- The bilinear map sending `a : A, b : B` to `âŸ¦a âŠ—â‚œ bâŸ§` in `(A âŠ—[k] B)_G`. -/
noncomputable abbrev coinvariantsTensorMk :
    A â†’â‚—[k] B â†’â‚—[k] ((coinvariantsTensor k G).obj A).obj B :=
  (TensorProduct.mk k A B).comprâ‚‚ (Coinvariants.mk _)

variable {A B}

lemma coinvariantsTensorMk_apply (a : A) (b : B) :
  coinvariantsTensorMk A B a b = Coinvariants.mk _ (a âŠ—â‚œ[k] b) := rfl

@[ext]
lemma coinvariantsTensor_hom_ext {M : ModuleCat k}
    {f g : ((coinvariantsTensor k G).obj A).obj B âŸ¶ M}
    (hfg : (coinvariantsTensorMk A B).comprâ‚‚ f.hom = (coinvariantsTensorMk A B).comprâ‚‚ g.hom) :
    f = g := Coinvariants.functor_hom_ext <| TensorProduct.ext <| hfg

instance (A : Rep k G) : ((coinvariantsTensor k G).obj A).Additive := by
  unfold coinvariantsTensor
  infer_instance

section Finsupp

variable {k G : Type u} [CommRing k] [Group G] (A : Rep k G) (Î± : Type u) [DecidableEq Î±]

open MonoidalCategory Finsupp Representation

/-- Given a `k`-linear `G`-representation `(A, Ï)` and a type `Î±`, this is the map
`(A âŠ— (Î± â†’â‚€ k[G]))_G â†’â‚—[k] (Î± â†’â‚€ A)` sending
`âŸ¦a âŠ— single x (single g r)âŸ§ â†¦ single x (r â€¢ Ï(gâ»Â¹)(a)).` -/
noncomputable def coinvariantsTensorFreeToFinsupp :
    (A âŠ— free k G Î±).Ï.Coinvariants â†’â‚—[k] (Î± â†’â‚€ A) :=
  (coinvariantsFinsuppLEquiv _ Î± â‰ªâ‰«â‚— lcongr (Equiv.refl Î±)
    (coinvariantsTprodLeftRegularLEquiv A.Ï)).toLinearMap âˆ˜â‚— Coinvariants.map (finsuppTensorRight A
      (leftRegular k G) Î±).hom

variable {A Î±}

@[simp]
lemma coinvariantsTensorFreeToFinsupp_mk_tmul_single (x : A) (i : Î±) (g : G) (r : k) :
    DFunLike.coe (F := (A.Ï.tprod (Representation.free k G Î±)).Coinvariants â†’â‚—[k] Î± â†’â‚€ A.V)
      (coinvariantsTensorFreeToFinsupp A Î±) (Coinvariants.mk _ (x âŠ—â‚œ single i (single g r))) =
      single i (r â€¢ A.Ï gâ»Â¹ x) := by
  simp [ModuleCat.MonoidalCategory.instMonoidalCategoryStruct_tensorObj,
    ModuleCat.MonoidalCategory.tensorObj, coinvariantsTensorFreeToFinsupp,
    Coinvariants.map, finsuppTensorRight, TensorProduct.finsuppRight]

variable (A Î±)

/-- Given a `k`-linear `G`-representation `(A, Ï)` and a type `Î±`, this is the map
`(Î± â†’â‚€ A) â†’â‚—[k] (A âŠ— (Î± â†’â‚€ k[G]))_G` sending `single x a â†¦ âŸ¦a âŠ—â‚œ single x 1âŸ§.` -/
noncomputable def finsuppToCoinvariantsTensorFree :
    (Î± â†’â‚€ A) â†’â‚—[k] Coinvariants (A âŠ— (free k G Î±)).Ï :=
  Coinvariants.map ((finsuppTensorRight A (leftRegular k G) Î±)).inv âˆ˜â‚—
    (coinvariantsFinsuppLEquiv _ Î± â‰ªâ‰«â‚—
    lcongr (Equiv.refl Î±) (coinvariantsTprodLeftRegularLEquiv A.Ï)).symm.toLinearMap

variable {A Î±}

@[simp]
lemma finsuppToCoinvariantsTensorFree_single (i : Î±) (x : A) :
    DFunLike.coe (F := (Î± â†’â‚€ A.V) â†’â‚—[k] (A.Ï.tprod (Representation.free k G Î±)).Coinvariants)
      (finsuppToCoinvariantsTensorFree A Î±) (single i x) =
      Coinvariants.mk _ (x âŠ—â‚œ single i (single (1 : G) (1 : k))) := by
  simp [finsuppToCoinvariantsTensorFree, Coinvariants.map, ModuleCat.MonoidalCategory.tensorObj,
    ModuleCat.MonoidalCategory.instMonoidalCategoryStruct_tensorObj]

variable (A Î±)

/-- Given a `k`-linear `G`-representation `(A, Ï)` and a type `Î±`, this is the linear equivalence
`(A âŠ— (Î± â†’â‚€ k[G]))_G â‰ƒâ‚—[k] (Î± â†’â‚€ A)` sending
`âŸ¦a âŠ— single x (single g r)âŸ§ â†¦ single x (r â€¢ Ï(gâ»Â¹)(a)).` -/
@[simps! symm_apply]
noncomputable abbrev coinvariantsTensorFreeLEquiv :
    Coinvariants (A âŠ— free k G Î±).Ï â‰ƒâ‚—[k] (Î± â†’â‚€ A) :=
  LinearEquiv.ofLinear (coinvariantsTensorFreeToFinsupp A Î±) (finsuppToCoinvariantsTensorFree A Î±)
    (lhom_ext fun i x => by
      simp [finsuppToCoinvariantsTensorFree_single i x,
        coinvariantsTensorFreeToFinsupp_mk_tmul_single x i 1 1]) <|
    Coinvariants.hom_ext <| TensorProduct.ext <| LinearMap.ext fun a => lhom_ext' fun i =>
      lhom_ext fun g r => by
        simp [coinvariantsTensorFreeToFinsupp_mk_tmul_single a i g r,
          finsuppToCoinvariantsTensorFree_single (A := A) i, TensorProduct.smul_tmul]

@[simp]
lemma coinvariantsTensorFreeLEquiv_apply (x) :
    DFunLike.coe (F := (A.Ï.tprod (Representation.free k G Î±)).Coinvariants â†’â‚—[k] Î± â†’â‚€ A)
      (A.coinvariantsTensorFreeToFinsupp Î±) x = coinvariantsTensorFreeToFinsupp A Î± x := by
  rfl

end Finsupp
end Rep
