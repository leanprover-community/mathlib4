/-
Copyright (c) 2025 Amelia Livingston. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Amelia Livingston
-/
import Mathlib.Algebra.Homology.ShortComplex.ModuleCat
import Mathlib.RepresentationTheory.Rep

/-!
# Coinvariants of a group representation

Given a commutative ring `k` and a monoid `G`, this file introduces the coinvariants of a
`k`-linear `G`-representation `(V, ρ)`.

We first define `Representation.Coinvariants.ker`, the submodule of `V` generated by elements
of the form `ρ g x - x` for `x : V`, `g : G`. Then the coinvariants of `(V, ρ)` are the quotient of
`V` by this submodule. We show that the functor sending a representation to its coinvariants is
left adjoint to the functor equipping a module with the trivial representation.

-/

universe u v

namespace Representation

variable {k G V W X : Type*} [CommRing k] [Monoid G] [AddCommGroup V] [Module k V]
  [AddCommGroup W] [Module k W] [AddCommGroup X] [Module k X]
  (ρ : Representation k G V) (τ : Representation k G W) (υ : Representation k G X)

/-- The submodule of a representation generated by elements of the form `ρ g x - x`. -/
def Coinvariants.ker : Submodule k V :=
  Submodule.span k (Set.range fun (gv : G × V) => ρ gv.1 gv.2 - gv.2)

/-- The coinvariants of a representation, `V ⧸ ⟨{ρ g x - x | g ∈ G, x ∈ V}⟩`. -/
def Coinvariants := V ⧸ Coinvariants.ker ρ

namespace Coinvariants

instance : AddCommGroup (Coinvariants ρ) := inferInstanceAs <| AddCommGroup (_ ⧸ _)
instance : Module k (Coinvariants ρ) := inferInstanceAs <| Module k (_ ⧸ _)

variable {ρ}

lemma sub_mem_ker (g : G) (x : V) : ρ g x - x ∈ Coinvariants.ker ρ :=
  Submodule.subset_span <| Set.mem_range_self (g, x)

lemma mem_ker_of_eq (g : G) (x : V) (a : V) (h : ρ g x - x = a) : a ∈ ker ρ :=
  Submodule.subset_span ⟨(g, x), h⟩

variable (ρ)

/-- The quotient map from a representation to its coinvariants as a linear map. -/
def mk : V →ₗ[k] Coinvariants ρ := Submodule.mkQ (ker ρ)

theorem mk_eq_iff {x y : V} :
    mk ρ x = mk ρ y ↔ x - y ∈ Coinvariants.ker ρ :=
  Submodule.Quotient.eq _

theorem mk_eq_zero {x : V} :
    mk ρ x = 0 ↔ x ∈ Coinvariants.ker ρ :=
  Submodule.Quotient.mk_eq_zero _

theorem mk_surjective : Function.Surjective (mk ρ) :=
  Submodule.Quotient.mk_surjective _

@[simp]
lemma mk_self_apply (g : G) (x : V) :
    mk ρ (ρ g x) = mk ρ x :=
  (mk_eq_iff _).2 <| mem_ker_of_eq g x _ rfl

variable {ρ} in
@[elab_as_elim]
theorem induction_on {motive : Coinvariants ρ → Prop} (x : Coinvariants ρ)
    (h : ∀ v : V, motive (mk ρ v)) :
    motive x :=
  Submodule.Quotient.induction_on _ x h

/-- A `G`-invariant linear map induces a linear map out of the coinvariants of a
`G`-representation. -/
def lift (f : V →ₗ[k] W) (h : ∀ (x : G), f ∘ₗ ρ x = f) :
    ρ.Coinvariants →ₗ[k] W :=
  Submodule.liftQ _ f <| Submodule.span_le.2 fun x ⟨⟨g, y⟩, hy⟩ => by
    simpa only [← hy, SetLike.mem_coe, LinearMap.mem_ker, map_sub, sub_eq_zero, LinearMap.coe_comp,
      Function.comp_apply] using LinearMap.ext_iff.1 (h g) y

@[simp]
theorem lift_comp_mk (f : V →ₗ[k] W) (h : ∀ (x : G), f ∘ₗ ρ x = f) :
    lift ρ f h ∘ₗ mk ρ = f := rfl

@[simp]
theorem lift_mk (f : V →ₗ[k] W) (h : ∀ (x : G), f ∘ₗ ρ x = f) (x : V) :
    lift ρ f h (mk _ x) = f x := rfl

variable {ρ} in
@[ext high]
lemma hom_ext {f g : Coinvariants ρ →ₗ[k] W} (H : f ∘ₗ mk ρ = g ∘ₗ mk ρ) : f = g :=
  Submodule.linearMap_qext _ H

/-- Given `G`-representations on `k`-modules `V, W`, a linear map `V →ₗ[k] W` commuting with
the representations induces a `k`-linear map between the coinvariants. -/
noncomputable def map (f : V →ₗ[k] W) (hf : ∀ g, f ∘ₗ ρ g = τ g ∘ₗ f) :
    Coinvariants ρ →ₗ[k] Coinvariants τ :=
  lift _ (mk _ ∘ₗ f) fun g => LinearMap.ext fun x => (mk_eq_iff _).2 <|
    mem_ker_of_eq g (f x) _ <| by simpa using congr($((hf g).symm) x)

variable {ρ τ}

@[simp]
lemma map_comp_mk (f : V →ₗ[k] W) (hf : ∀ g, f ∘ₗ ρ g = τ g ∘ₗ f) :
    map ρ τ f hf ∘ₗ mk ρ = mk τ ∘ₗ f := rfl

@[simp]
lemma map_mk (f : V →ₗ[k] W) (hf : ∀ g, f ∘ₗ ρ g = τ g ∘ₗ f) (x : V) :
    map ρ τ f hf (mk _ x) = mk _ (f x) := rfl

@[simp]
lemma map_id (ρ : Representation k G V) :
    map ρ ρ LinearMap.id (by simp) = LinearMap.id := by
  ext; rfl

@[simp]
lemma map_comp (φ : V →ₗ[k] W) (ψ : W →ₗ[k] X)
    (H : ∀ g, φ ∘ₗ ρ g = τ g ∘ₗ φ) (h : ∀ g, ψ ∘ₗ τ g = υ g ∘ₗ ψ) :
    map τ υ ψ h ∘ₗ map ρ τ φ H = map ρ υ (ψ ∘ₗ φ) (fun g => by
      ext x; have : φ _ = _ := congr($(H g) x); have : ψ _ = _ := congr($(h g) (φ x)); simp_all) :=
  hom_ext rfl

end Coinvariants
section

open Coinvariants

variable {k G V : Type*} [CommRing k] [Group G] [AddCommGroup V] [Module k V]
variable (ρ : Representation k G V) (S : Subgroup G) [S.Normal]

lemma Coinvariants.le_comap_ker (g : G) :
    ker (ρ.comp S.subtype) ≤ (ker <| ρ.comp S.subtype).comap (ρ g) :=
  Submodule.span_le.2 fun _ ⟨⟨s, x⟩, hs⟩ => by
    simpa [← hs] using mem_ker_of_eq
      ⟨g * s * g⁻¹, Subgroup.Normal.conj_mem ‹_› s.1 s.2 g⟩ (ρ g x) _ <| by simp

/-- Given a normal subgroup `S ≤ G`, a `G`-representation `ρ` restricts to a `G`-representation on
the kernel of the quotient map to the coinvariants of `ρ|_S`. -/
noncomputable abbrev toCoinvariantsKer :
    Representation k G (ker <| ρ.comp S.subtype) :=
  subrepresentation ρ (ker <| ρ.comp S.subtype) fun g => le_comap_ker ρ S g

/-- Given a normal subgroup `S ≤ G`, a `G`-representation `ρ` induces a `G`-representation on the
coinvariants of `ρ|_S`. -/
noncomputable abbrev toCoinvariants :
    Representation k G (Coinvariants <| ρ.comp S.subtype) :=
  quotient ρ (ker <| ρ.comp S.subtype) fun g => le_comap_ker ρ S g

instance : IsTrivial ((toCoinvariants ρ S).comp S.subtype) where
  out g := by
    ext x
    exact (Coinvariants.mk_eq_iff _).2 <| mem_ker_of_eq g x _ rfl

/-- Given a normal subgroup `S ≤ G`, a `G`-representation `ρ` induces a `G ⧸ S`-representation on
the coinvariants of `ρ|_S`. -/
noncomputable abbrev quotientToCoinvariants :
    Representation k (G ⧸ S) (Coinvariants (ρ.comp S.subtype)) :=
  ofQuotient (toCoinvariants ρ S) S

end

end Representation

namespace Rep

open CategoryTheory Representation

variable {k G : Type u} [CommRing k]

noncomputable section

variable [Group G] (A : Rep k G) (S : Subgroup G) [S.Normal]

/-- Given a normal subgroup `S ≤ G`, a `G`-representation `A` restricts to a `G`-representation on
the kernel of the quotient map to the `S`-coinvariants `A_S`. -/
abbrev toCoinvariantsKer : Rep k G := Rep.of (A.ρ.toCoinvariantsKer S)

/-- Given a normal subgroup `S ≤ G`, a `G`-representation `A` induces a `G`-representation on
the `S`-coinvariants `A_S`. -/
abbrev toCoinvariants : Rep k G := Rep.of (A.ρ.toCoinvariants S)

/-- Given a normal subgroup `S ≤ G`, a `G`-representation `ρ` induces a `G ⧸ S`-representation on
the coinvariants of `ρ|_S`. -/
abbrev quotientToCoinvariants : Rep k (G ⧸ S) := ofQuotient (toCoinvariants A S) S

/-- Given a normal subgroup `S ≤ G`, a `G`-representation `A` induces a short exact sequence of
`G`-representations `0 ⟶ Ker(mk) ⟶ A ⟶ A_S ⟶ 0` where `mk` is the quotient map to the
`S`-coinvariants `A_S`. -/
@[simps X₁ X₂ X₃ f g]
def coinvariantsShortComplex : ShortComplex (Rep k G) where
  X₁ := toCoinvariantsKer A S
  X₂ := A
  X₃ := toCoinvariants A S
  f := subtype ..
  g := mkQ ..
  zero := by ext x; exact (Submodule.Quotient.mk_eq_zero _).2 x.2

lemma coinvariantsShortComplex_shortExact : (coinvariantsShortComplex A S).ShortExact where
  exact := (forget₂ _ (ModuleCat k)).reflects_exact_of_faithful _ <|
    (ShortComplex.moduleCat_exact_iff _).2
      fun x hx => ⟨(⟨x, (Submodule.Quotient.mk_eq_zero _).1 hx⟩ :
      Representation.Coinvariants.ker <| A.ρ.comp S.subtype), rfl⟩
  mono_f := (Rep.mono_iff_injective _).2 fun _ _ h => Subtype.ext h
  epi_g := (Rep.epi_iff_surjective _).2 <| Submodule.mkQ_surjective _

end

variable (k G) [Monoid G] (A B : Rep k G)

/-- The functor sending a representation to its coinvariants. -/
@[simps! obj_carrier map_hom]
noncomputable def coinvariantsFunctor : Rep k G ⥤ ModuleCat k where
  obj A := ModuleCat.of k A.ρ.Coinvariants
  map f := ModuleCat.ofHom (Representation.Coinvariants.map _ _ f.hom.hom
    fun g => ModuleCat.hom_ext_iff.1 <| f.comm g)
  map_id _ := by simp
  map_comp _ _ := by ext; simp

/-- The quotient map from a representation to its coinvariants induces a natural transformation
from the forgetful functor `Rep k G ⥤ ModuleCat k` to the coinvariants functor. -/
@[simps! app_hom]
noncomputable def coinvariantsMk : Action.forget (ModuleCat k) G ⟶ coinvariantsFunctor k G where
  app (X : Rep k G) := ModuleCat.ofHom <| Representation.Coinvariants.mk X.ρ

instance (X : Rep k G) : Epi ((coinvariantsMk k G).app X) :=
  (ModuleCat.epi_iff_surjective _).2 <| Representation.Coinvariants.mk_surjective X.ρ

variable {k G}

@[ext]
lemma coinvariantsFunctor_hom_ext {M : ModuleCat k} {f g : (coinvariantsFunctor k G).obj A ⟶ M}
    (hfg : (coinvariantsMk k G).app A ≫ f = (coinvariantsMk k G).app A ≫ g) :
    f = g := (cancel_epi _).1 hfg

variable {A B}

/-- The linear map underlying a `G`-representation morphism `A ⟶ B`, where `B` has the trivial
representation, factors through `A_G`. -/
noncomputable abbrev desc [B.ρ.IsTrivial] (f : A ⟶ B) :
    (coinvariantsFunctor k G).obj A ⟶ B.V :=
  ModuleCat.ofHom <| Representation.Coinvariants.lift _ f.hom.hom fun _ => by
    ext
    have := hom_comm_apply f
    simp_all

variable (k G)

instance : (coinvariantsFunctor k G).Additive where
instance : (coinvariantsFunctor k G).Linear k where

/-- The adjunction between the functor sending a representation to its coinvariants and the functor
equipping a module with the trivial representation. -/
@[simps]
noncomputable def coinvariantsAdjunction : coinvariantsFunctor k G ⊣ trivialFunctor k G where
  unit := { app X := {
    hom := (coinvariantsMk k G).app X
    comm _ := by ext; simp [ModuleCat.endRingEquiv, trivialFunctor] }}
  counit := { app X := desc (B := trivial k G X) (𝟙 _) }

@[simp]
theorem coinvariantsAdjunction_homEquiv_apply_hom {X : Rep k G} {Y : ModuleCat k}
    (f : (coinvariantsFunctor k G).obj X ⟶ Y) :
    ((coinvariantsAdjunction k G).homEquiv X Y f).hom = (coinvariantsMk k G).app X ≫ f := by
  rfl

@[simp]
theorem coinvariantsAdjunction_homEquiv_symm_apply_hom {X : Rep k G} {Y : ModuleCat k}
    (f : X ⟶ (trivialFunctor k G).obj Y) :
    ((coinvariantsAdjunction k G).homEquiv X Y).symm f = desc f := by
  ext
  simp [coinvariantsAdjunction, Adjunction.homEquiv_symm_apply]

instance : (coinvariantsFunctor k G).PreservesZeroMorphisms where
instance : (coinvariantsFunctor k G).IsLeftAdjoint := (coinvariantsAdjunction k G).isLeftAdjoint

end Rep
