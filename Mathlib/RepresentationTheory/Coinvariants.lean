/-
Copyright (c) 2025 Amelia Livingston. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Amelia Livingston
-/
import Mathlib.Algebra.Homology.ShortComplex.ModuleCat
import Mathlib.RepresentationTheory.Rep

/-!
# Coinvariants a group representation

Given a commutative ring `k` and a monoid `G`, this file introduces the coinvariants of a
`k`-linear `G`-representation `(V, Ï)`.

We first define `Representation.augmentationSubmodule`, the submodule of `V` generated by elements
of the form `Ï g x - x` for `x : V`, `g : G`. Then the coinvariants of `(V, Ï)` are the quotient of
`V` by this submodule.

## Main definitions

* `Representation.coinvariants Ï`: the coinvariants of a representation `Ï`.
* `Representation.coinvariantsFinsuppLEquiv Ï Î±`: given a type `Î±`, this is the `k`-linear
  equivalence between `(Î± â†’â‚€ V)_G` and `Î± â†’â‚€ V_G`.
* `Representation.coinvariantsTprodLeftRegularLEquiv Ï`: the `k`-linear equivalence between
  `(V âŠ— k[G])_G` and `V` sending `âŸ¦v âŠ— single g râŸ§ â†¦ r â€¢ Ï(gâ»Â¹)(v)`.
* `Rep.coinvariantsAdjunction k G`: the adjunction between the functor sending a representation to
  its coinvariants and the functor equipping a module with the trivial representation.
* `Rep.coinvariantsTensor k G`: the functor sending representations `A, B` to `(A âŠ—[k] B)_G`. This
  is naturally isomorphic to the functor sending `A, B` to `A âŠ—[k[G]] B`, where we give `A` the
  `k[G]áµáµ’áµ–`-module structure defined by `g â€¢ a := A.Ï gâ»Â¹ a`.
* `Rep.coinvariantsTensorFreeLEquiv A Î±`: given a representation `A` and a type `Î±`, this is the
  `k`-linear equivalence between `(A âŠ— (Î± â†’â‚€ k[G]))_G` and `Î± â†’â‚€ A` sending
  `âŸ¦a âŠ— single x (single g r)âŸ§ â†¦ single x (r â€¢ Ï(gâ»Â¹)(a))`. This is useful for group homology.

-/

universe u v

namespace Representation

section

variable {k G V W : Type*} [CommRing k] [Monoid G] [AddCommGroup V] [Module k V]
  [AddCommGroup W] [Module k W] (Ï : Representation k G V)

/-- The submodule of a representation generated by elements of the form `Ï g x - x`. -/
abbrev augmentationSubmodule : Submodule k V :=
  Submodule.span k (Set.range fun (x : G Ã— V) => Ï x.1 x.2 - x.2)

variable {Ï}

lemma mem_augmentationSubmodule_of_eq (g : G) (x : V) (a : V) (h : Ï g x - x = a) :
    a âˆˆ augmentationSubmodule Ï :=
  Submodule.subset_span âŸ¨(g, x), hâŸ©

variable (Ï)

@[simp]
theorem augmentationSubmodule_eq_bot_of_isTrivial [Ï.IsTrivial] :
    augmentationSubmodule Ï = âŠ¥ := by
  rw [Submodule.span_eq_bot]
  rintro x âŸ¨âŸ¨g, yâŸ©, rflâŸ©
  simp

/-- The coinvariants of a representation, `V â§¸ âŸ¨{Ï g x - x | g âˆˆ G, x âˆˆ V}âŸ©`. -/
abbrev coinvariants := V â§¸ augmentationSubmodule Ï

/-- The quotient map from a representation to its coinvariants as a linear map. -/
abbrev coinvariantsMkQ := Submodule.mkQ (augmentationSubmodule Ï)

/-- A `G`-invariant linear map induces a linear map out of the coinvariants of a
`G`-representation. -/
def coinvariantsLift (f : V â†’â‚—[k] W) (h : âˆ€ (x : G), f âˆ˜â‚— Ï x = f) :
    Ï.coinvariants â†’â‚—[k] W :=
  Submodule.liftQ _ f <| Submodule.span_le.2 fun x âŸ¨âŸ¨g, yâŸ©, hyâŸ© => by
    simpa only [â† hy, SetLike.mem_coe, LinearMap.mem_ker, map_sub, sub_eq_zero, LinearMap.coe_comp,
      Function.comp_apply] using LinearMap.ext_iff.1 (h g) y

@[simp]
theorem coinvariantsLift_comp_mkQ (f : V â†’â‚—[k] W) (h : âˆ€ (x : G), f âˆ˜â‚— Ï x = f) :
  coinvariantsLift Ï f h âˆ˜â‚— (augmentationSubmodule Ï).mkQ = f := rfl

@[simp]
theorem coinvariantsLift_mk (f : V â†’â‚—[k] W) (h : âˆ€ (x : G), f âˆ˜â‚— Ï x = f) (x : V) :
  coinvariantsLift Ï f h (Submodule.Quotient.mk x) = f x := rfl

section

variable {k G V : Type*} [CommRing k] [Group G] [AddCommGroup V] [Module k V]
variable (Ï : Representation k G V) (S : Subgroup G) [S.Normal]

lemma le_comap_augmentationSubmodule (g : G) :
    augmentationSubmodule (Ï.comp S.subtype) â‰¤
      (augmentationSubmodule <| Ï.comp S.subtype).comap (Ï g) :=
  Submodule.span_le.2 fun y âŸ¨âŸ¨s, xâŸ©, hsâŸ© => by
    simpa [â† hs] using mem_augmentationSubmodule_of_eq
      âŸ¨g * s * gâ»Â¹, Subgroup.Normal.conj_mem â€¹_â€º s.1 s.2 gâŸ© (Ï g x) _ <| by simp

/-- Given a normal subgroup `S â‰¤ G`, a `G`-representation `Ï` restricts to a `G`-representation on
the augmentation submodule of `Ï|_S`. -/
noncomputable abbrev toAugmentationSubmodule :=
  subrepresentation Ï (augmentationSubmodule <| Ï.comp S.subtype)
    fun g => le_comap_augmentationSubmodule Ï S g

/-- Given a normal subgroup `S â‰¤ G`, a `G`-representation `Ï` induces a `G`-representation on the
coinvariants of `Ï|_S`. -/
noncomputable abbrev toCoinvariants :=
  quotient Ï (augmentationSubmodule <| Ï.comp S.subtype)
    fun g => le_comap_augmentationSubmodule Ï S g

instance : IsTrivial ((toCoinvariants Ï S).comp S.subtype) where
  out g := Submodule.linearMap_qext _ <| by
    ext x
    simpa [Submodule.Quotient.eq] using mem_augmentationSubmodule_of_eq g x _ rfl

/-- Given a normal subgroup `S â‰¤ G`, a `G`-representation `Ï` induces a `G â§¸ S`-representation on
the coinvariants of `Ï|_S`. -/
noncomputable abbrev quotientToCoinvariants :
    Representation k (G â§¸ S) (coinvariants (Ï.comp S.subtype)) :=
  ofQuotient (toCoinvariants Ï S) S

end
section Finsupp

open Finsupp

variable {k G V : Type*} [CommRing k] [Group G] [AddCommGroup V] [Module k V]
  (Ï : Representation k G V) (Î± : Type*)

/-- Given a `G`-representation `(V, Ï)` and a type `Î±`, this is the map `(Î± â†’â‚€ V)_G â†’â‚— (Î± â†’â‚€ V_G)`
sending `âŸ¦single a vâŸ§ â†¦ single a âŸ¦vâŸ§`. -/
noncomputable def coinvariantsToFinsupp :
    coinvariants (Ï.finsupp Î±) â†’â‚—[k] Î± â†’â‚€ coinvariants Ï :=
  coinvariantsLift _ (mapRange.linearMap (Submodule.mkQ _)) <| fun g => lhom_ext fun _ x => by
    simp [mapRange.linearMap, â† (Submodule.Quotient.eq _).2
      (mem_augmentationSubmodule_of_eq g x _ rfl), finsupp]

@[simp]
lemma coinvariantsToFinsupp_mk_single (x : Î±) (a : V) :
    coinvariantsToFinsupp Ï Î± (Submodule.Quotient.mk (single x a)) =
      single x (Submodule.Quotient.mk a) := by simp [coinvariantsToFinsupp]

/-- Given a `G`-representation `(V, Ï)` and a type `Î±`, this is the map `(Î± â†’â‚€ V_G) â†’â‚— (Î± â†’â‚€ V)_G`
sending `single a âŸ¦vâŸ§ â†¦ âŸ¦single a vâŸ§`. -/
noncomputable def finsuppToCoinvariants :
    (Î± â†’â‚€ coinvariants Ï) â†’â‚—[k] coinvariants (Ï.finsupp Î±) :=
  lsum (R := k) k fun a => coinvariantsLift _ (Submodule.mkQ _ âˆ˜â‚— lsingle a) fun g =>
    LinearMap.ext fun x => (Submodule.Quotient.eq _).2 <|
    mem_augmentationSubmodule_of_eq g (single a x) _ <| by simp

@[simp]
lemma finsuppToCoinvariants_single_mk (a : Î±) (x : V) :
    finsuppToCoinvariants Ï Î± (single a <| Submodule.Quotient.mk x) =
      Submodule.Quotient.mk (single a x) := by simp [finsuppToCoinvariants]

/-- Given a `G`-representation `(V, Ï)` and a type `Î±`, this is the linear equivalence
`(Î± â†’â‚€ V)_G â‰ƒâ‚— (Î± â†’â‚€ V_G)` sending `âŸ¦single a vâŸ§ â†¦ single a âŸ¦vâŸ§`. -/
noncomputable abbrev coinvariantsFinsuppLEquiv :
    coinvariants (Ï.finsupp Î±) â‰ƒâ‚—[k] Î± â†’â‚€ coinvariants Ï :=
  LinearEquiv.ofLinear (coinvariantsToFinsupp Ï Î±) (finsuppToCoinvariants Ï Î±)
    (lhom_ext fun _ x => Quotient.inductionOn' x fun _ => by
      simp [coinvariantsToFinsupp, finsuppToCoinvariants, Submodule.Quotient.mk''_eq_mk])
    (Submodule.linearMap_qext _ <| lhom_ext fun _ _ => by
      simp [finsuppToCoinvariants, coinvariantsToFinsupp])

end Finsupp

section TensorProduct

open TensorProduct

variable {k G V W : Type*} [CommRing k] [Group G] [AddCommGroup V] [Module k V]
  [AddCommGroup W] [Module k W] (Ï : Representation k G V)

@[simp]
lemma coinvariants_mk_inv_tmul (Ï„ : Representation k G W) (x : V) (y : W) (g : G) :
    Submodule.Quotient.mk (p := (Ï.tprod Ï„).augmentationSubmodule) (Ï gâ»Â¹ x âŠ—â‚œ[k] y) =
      Submodule.Quotient.mk (p := (Ï.tprod Ï„).augmentationSubmodule) (x âŠ—â‚œ[k] Ï„ g y) :=
  (Submodule.Quotient.eq _).2 <| mem_augmentationSubmodule_of_eq gâ»Â¹ (x âŠ—â‚œ[k] Ï„ g y) _ <| by simp

@[simp]
lemma coinvariants_mk_tmul_inv (Ï„ : Representation k G W) (x : V) (y : W) (g : G) :
    Submodule.Quotient.mk (p := (Ï.tprod Ï„).augmentationSubmodule) (x âŠ—â‚œ[k] Ï„ gâ»Â¹ y) =
      Submodule.Quotient.mk (p := (Ï.tprod Ï„).augmentationSubmodule) (Ï g x âŠ—â‚œ[k] y) :=
  (Submodule.Quotient.eq _).2 <| mem_augmentationSubmodule_of_eq gâ»Â¹ (Ï g x âŠ—â‚œ[k] y) _ <| by simp

/-- Given a `k`-linear `G`-representation `V, Ï`, this is the map `(V âŠ— k[G])_G â†’â‚—[k] V` sending
`âŸ¦v âŠ— single g râŸ§ â†¦ r â€¢ Ï(gâ»Â¹)(v)`. -/
noncomputable def ofCoinvariantsTprodLeftRegular :
    coinvariants (V := V âŠ—[k] (G â†’â‚€ k)) (Ï.tprod (leftRegular k G)) â†’â‚—[k] V :=
  coinvariantsLift _ (TensorProduct.lift (Finsupp.linearCombination _ fun g => Ï gâ»Â¹) âˆ˜â‚—
    (TensorProduct.comm _ _ _).toLinearMap) fun _ => TensorProduct.ext <|
      LinearMap.ext fun _ => Finsupp.lhom_ext fun _ _ => by simp

@[simp]
lemma ofCoinvariantsTprodLeftRegular_mk_tmul_single (x : V) (g : G) (r : k) :
    ofCoinvariantsTprodLeftRegular Ï (Submodule.Quotient.mk (x âŠ—â‚œ Finsupp.single g r)) =
      r â€¢ Ï gâ»Â¹ x :=
  congr($(Finsupp.linearCombination_single k (v := fun g => Ï gâ»Â¹) r g) x)

/-- Given a `k`-linear `G`-representation `(V, Ï)`, this is the linear equivalence
`(V âŠ— k[G])_G â‰ƒâ‚—[k] V` sending `âŸ¦v âŠ— single g râŸ§ â†¦ r â€¢ Ï(gâ»Â¹)(v)`. -/
noncomputable abbrev coinvariantsTprodLeftRegularLEquiv :
    coinvariants (V := V âŠ—[k] (G â†’â‚€ k)) (Ï.tprod (leftRegular k G)) â‰ƒâ‚—[k] V :=
  LinearEquiv.ofLinear (ofCoinvariantsTprodLeftRegular Ï)
    (Submodule.mkQ _ âˆ˜â‚— (mk k V (G â†’â‚€ k)).flip (Finsupp.single 1 1)) (by ext; simp) <|
    Submodule.linearMap_qext _ <| TensorProduct.ext <| LinearMap.ext fun a =>
      Finsupp.lhom_ext fun g r => (Submodule.Quotient.eq _).2 <| by
        apply mem_augmentationSubmodule_of_eq gâ»Â¹ (a âŠ—â‚œ Finsupp.single g r)
        simp_all [TensorProduct.smul_tmul', TensorProduct.smul_tmul]

end TensorProduct

end Representation

namespace Rep

open CategoryTheory

section

variable {k G : Type u} [CommRing k] [Monoid G] {A B C : Rep k G} {n : â„•}

open Representation

/-- The linear map underlying a `G`-representation morphism `A âŸ¶ B`, where `B` has the trivial
representation, factors through `A_G`. -/
noncomputable abbrev coinvariantsLift [B.Ï.IsTrivial] (f : A âŸ¶ B) :
    coinvariants A.Ï â†’â‚—[k] B :=
  Representation.coinvariantsLift _ f.hom.hom fun _ => by
    ext
    have := hom_comm_apply f
    simp_all

/-- A `G`-representation morphism `A âŸ¶ B` induces a linear map `A_G â†’â‚—[k] B_G`. -/
noncomputable abbrev coinvariantsMap (f : A âŸ¶ B) :
    coinvariants A.Ï â†’â‚—[k] coinvariants B.Ï :=
  Representation.coinvariantsLift _ (Submodule.mkQ _ âˆ˜â‚— f.hom.hom) fun g => LinearMap.ext fun x =>
    (Submodule.Quotient.eq _).2 <| mem_augmentationSubmodule_of_eq g (f.hom x) _ <| by
      simpa using (hom_comm_apply f g x).symm

@[simp]
theorem coinvariantsMap_comp_mkQ (f : A âŸ¶ B) :
    coinvariantsMap f âˆ˜â‚— coinvariantsMkQ A.Ï = coinvariantsMkQ B.Ï âˆ˜â‚— f.hom.hom := rfl

@[simp]
theorem coinvariantsMap_mk (f : A âŸ¶ B) (x : A) :
    coinvariantsMap f (Submodule.Quotient.mk x) = Submodule.Quotient.mk (f.hom x) := rfl

@[simp]
theorem coinvariantsMap_id (A : Rep k G) :
    coinvariantsMap (ğŸ™ A) = LinearMap.id := by
  ext; rfl

@[simp]
theorem coinvariantsMap_comp (f : A âŸ¶ B) (g : B âŸ¶ C) :
    coinvariantsMap (f â‰« g) = coinvariantsMap g âˆ˜â‚— coinvariantsMap f := by
  ext; rfl

noncomputable section

variable {k G : Type u} [CommRing k] [Group G] (A : Rep k G) (S : Subgroup G) [S.Normal]

/-- Given a normal subgroup `S â‰¤ G`, a `G`-representation `Ï` restricts to a `G`-representation on
the augmentation submodule of `Ï|_S`. -/
abbrev toAugmentationSubmodule :=
  Rep.of (A.Ï.toAugmentationSubmodule S)

/-- Given a normal subgroup `S â‰¤ G`, a `G`-representation `Ï` induces a `G`-representation on the
coinvariants of `Ï|_S`. -/
abbrev toCoinvariants :=
  Rep.of (A.Ï.toCoinvariants S)

/-- Given a normal subgroup `S â‰¤ G`, a `G`-representation `A` induces a short exact sequence of
`G`-representations `0 âŸ¶ I(S)A âŸ¶ A âŸ¶ A_S âŸ¶ 0` where `I(S)A` is the submodule of `A`
generated by elements of the form `Ï(s)(x) - x` for `s : S, x : A`. -/
@[simps Xâ‚ Xâ‚‚ Xâ‚ƒ f g]
def coinvariantsShortComplex : ShortComplex (Rep k G) where
  Xâ‚ := toAugmentationSubmodule A S
  Xâ‚‚ := A
  Xâ‚ƒ := toCoinvariants A S
  f := subtype ..
  g := mkQ ..
  zero := by ext x; exact (Submodule.Quotient.mk_eq_zero _).2 x.2

lemma coinvariantsShortComplex_shortExact : (coinvariantsShortComplex A S).ShortExact where
  exact := (forgetâ‚‚ _ (ModuleCat k)).reflects_exact_of_faithful _ <|
    (ShortComplex.moduleCat_exact_iff _).2
      fun x hx => âŸ¨(âŸ¨x, (Submodule.Quotient.mk_eq_zero _).1 hxâŸ© :
      Representation.augmentationSubmodule <| A.Ï.comp S.subtype), rflâŸ©
  mono_f := (Rep.mono_iff_injective _).2 fun _ _ h => Subtype.ext h
  epi_g := (Rep.epi_iff_surjective _).2 <| Submodule.mkQ_surjective _

/-- Given a normal subgroup `S â‰¤ G`, a `G`-representation `Ï` induces a `G â§¸ S`-representation on
the coinvariants of `Ï|_S`. -/
abbrev quotientToCoinvariants :=
  ofQuotient (toCoinvariants A S) S

end

variable (k G)

/-- The functor sending a representation to its coinvariants. -/
@[simps]
noncomputable def coinvariantsFunctor : Rep k G â¥¤ ModuleCat k where
  obj A := ModuleCat.of k (A.Ï.coinvariants)
  map f := ModuleCat.ofHom (coinvariantsMap f)

instance : (coinvariantsFunctor k G).Additive where
  map_add := ModuleCat.hom_ext <| LinearMap.ext fun x => Quotient.inductionOn' x (fun _ => rfl)

/-- The adjunction between the functor sending a representation to its coinvariants and the functor
equipping a module with the trivial representation. -/
noncomputable def coinvariantsAdjunction : coinvariantsFunctor k G âŠ£ trivialFunctor G :=
  Adjunction.mkOfHomEquiv {
    homEquiv := fun X Y => {
      toFun := fun f => {
        hom := ModuleCat.ofHom (f.hom âˆ˜â‚— X.Ï.augmentationSubmodule.mkQ)
        comm := fun g => by
          ext x
          exact congr(f.hom $((Submodule.Quotient.eq <| X.Ï.augmentationSubmodule).2
            (X.Ï.mem_augmentationSubmodule_of_eq g x _ rfl))) }
      invFun := fun f => ModuleCat.ofHom (coinvariantsLift f)
      left_inv := fun _ => ModuleCat.hom_ext <| Submodule.linearMap_qext _ rfl
      right_inv := fun _ => Action.Hom.ext <| rfl }
    homEquiv_naturality_left_symm := fun _ _ => ModuleCat.hom_ext <| Submodule.linearMap_qext _ rfl
    homEquiv_naturality_right := by intros; rfl }

instance : (coinvariantsFunctor k G).PreservesZeroMorphisms where
  map_zero _ _ := ModuleCat.hom_ext <| Submodule.linearMap_qext _ rfl

instance : Limits.PreservesColimits (coinvariantsFunctor k G) :=
  (coinvariantsAdjunction k G).leftAdjoint_preservesColimits

open MonoidalCategory in
/-- The functor sending `A, B` to `(A âŠ—[k] B)_G`. This is naturally isomorphic to the functor
sending `A, B` to `A âŠ—[k[G]] B`, where we give `A` the `k[G]áµáµ’áµ–`-module structure defined by
`g â€¢ a := A.Ï gâ»Â¹ a`. -/
@[simps]
noncomputable def coinvariantsTensor : Rep k G â¥¤ Rep k G â¥¤ ModuleCat k where
  obj A := MonoidalCategory.tensorLeft A â‹™ coinvariantsFunctor k G
  map f := {
    app := fun A => ModuleCat.ofHom (coinvariantsMap (f âŠ— ğŸ™ A))
    naturality := fun _ _ _ => ModuleCat.hom_ext <| Submodule.linearMap_qext _ <|
      TensorProduct.ext' fun _ _ => by rfl }
  map_id _ := NatTrans.ext <| funext fun _ => by
    simpa only [tensorHom_id, id_whiskerRight] using (coinvariantsFunctor k G).map_id _
  map_comp _ _ := NatTrans.ext <| funext fun _ => by
    simpa only [tensorHom_id, comp_whiskerRight] using (coinvariantsFunctor k G).map_comp _ _

instance (A : Rep k G) : ((coinvariantsTensor k G).obj A).Additive := by
  unfold coinvariantsTensor
  infer_instance

end

section Finsupp

variable {k G : Type u} [CommRing k] [Group G] (A : Rep k G) (Î± : Type u) [DecidableEq Î±]

open MonoidalCategory Finsupp Representation

/-- Given a `k`-linear `G`-representation `(A, Ï)` and a type `Î±`, this is the map
`(A âŠ— (Î± â†’â‚€ k[G]))_G â†’â‚—[k] (Î± â†’â‚€ A)` sending
`âŸ¦a âŠ— single x (single g r)âŸ§ â†¦ single x (r â€¢ Ï(gâ»Â¹)(a)).` -/
noncomputable def coinvariantsTensorFreeToFinsupp :
    (A âŠ— free k G Î±).Ï.coinvariants â†’â‚—[k] (Î± â†’â‚€ A) :=
  (coinvariantsFinsuppLEquiv _ Î± â‰ªâ‰«â‚— lcongr (Equiv.refl Î±)
    (coinvariantsTprodLeftRegularLEquiv A.Ï)).toLinearMap âˆ˜â‚— coinvariantsMap (finsuppTensorRight A
      (leftRegular k G) Î±).hom

variable {A Î±}

lemma coinvariantsTensorFreeToFinsupp_mk_tmul_single (x : A) (i : Î±) (g : G) (r : k) :
    coinvariantsTensorFreeToFinsupp A Î± (Submodule.Quotient.mk (x âŠ—â‚œ single i (single g r))) =
      single i (r â€¢ A.Ï gâ»Â¹ x) := by
  simp [coinvariantsTensorFreeToFinsupp, coinvariantsMap, finsuppTensorRight,
    TensorProduct.finsuppRight, ModuleCat.MonoidalCategory.instMonoidalCategoryStruct_tensorObj,
    ModuleCat.MonoidalCategory.tensorObj]

variable (A Î±)

/-- Given a `k`-linear `G`-representation `(A, Ï)` and a type `Î±`, this is the map
`(Î± â†’â‚€ A) â†’â‚—[k] (A âŠ— (Î± â†’â‚€ k[G]))_G` sending `single x a â†¦ âŸ¦a âŠ—â‚œ single x 1âŸ§.` -/
noncomputable def finsuppToCoinvariantsTensorFree :
    (Î± â†’â‚€ A) â†’â‚—[k] coinvariants (A âŠ— (free k G Î±)).Ï :=
  coinvariantsMap ((finsuppTensorRight A (leftRegular k G) Î±)).inv âˆ˜â‚—
    (coinvariantsFinsuppLEquiv _ Î± â‰ªâ‰«â‚—
    lcongr (Equiv.refl Î±) (coinvariantsTprodLeftRegularLEquiv A.Ï)).symm.toLinearMap

variable {A Î±}

lemma finsuppToCoinvariantsTensorFree_single (i : Î±) (x : A) :
    finsuppToCoinvariantsTensorFree A Î± (single i x) =
      Submodule.Quotient.mk (x âŠ—â‚œ single i (single (1 : G) (1 : k))) := by
  simp_all [finsuppToCoinvariantsTensorFree, coinvariantsMap, ModuleCat.MonoidalCategory.tensorObj,
    ModuleCat.MonoidalCategory.instMonoidalCategoryStruct_tensorObj]

variable (A Î±)

/-- Given a `k`-linear `G`-representation `(A, Ï)` and a type `Î±`, this is the linear equivalence
`(A âŠ— (Î± â†’â‚€ k[G]))_G â‰ƒâ‚—[k] (Î± â†’â‚€ A)` sending
`âŸ¦a âŠ— single x (single g r)âŸ§ â†¦ single x (r â€¢ Ï(gâ»Â¹)(a)).` -/
noncomputable abbrev coinvariantsTensorFreeLEquiv :
    coinvariants (A âŠ— free k G Î±).Ï â‰ƒâ‚—[k] (Î± â†’â‚€ A) :=
  LinearEquiv.ofLinear (coinvariantsTensorFreeToFinsupp A Î±) (finsuppToCoinvariantsTensorFree A Î±)
    (lhom_ext fun _ _ => by
      rw [LinearMap.comp_apply, finsuppToCoinvariantsTensorFree_single,
        coinvariantsTensorFreeToFinsupp_mk_tmul_single]
      simp) <|
    Submodule.linearMap_qext _ <| TensorProduct.ext <| LinearMap.ext fun a => lhom_ext' fun i =>
      lhom_ext fun g r => by
        have := coinvariantsTensorFreeToFinsupp_mk_tmul_single a i g r
        have := finsuppToCoinvariantsTensorFree_single (A := A) i
        simp_all [Submodule.Quotient.eq, TensorProduct.smul_tmul]

end Finsupp
end Rep
