/-
Copyright (c) 2023 Amelia Livingston. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Riccardo Brasca, Amelia Livingston, Andrew Yang
-/
module

public import Mathlib.FieldTheory.Fixed
public import Mathlib.RepresentationTheory.Homological.GroupCohomology.LowDegree
public import Mathlib.RingTheory.IntegralClosure.IntegralRestrict

/-!
# Hilbert's Theorem 90

Let `L/K` be a finite extension of fields. Then this file proves Noether's generalization of
Hilbert's Theorem 90: that the 1st group cohomology $H^1(Aut_K(L), L^\times)$ is trivial. We state
it both in terms of $H^1$ and in terms of cocycles being coboundaries.

We also deduce Hilbert's original statement: if $L/K$ is Galois, and $Gal(L/K)$ is cyclic, generated
by an element `σ`, then for every `η : L` of norm `1`, there exists `ε : L` such
that `η = ε / σ ε`.

Noether's generalization also holds for infinite Galois extensions.

## Main statements

* `groupCohomology.isMulCoboundary₁_of_isMulCocycle₁_of_aut_to_units`: Noether's generalization
  of Hilbert's Theorem 90: for all $f: Aut_K(L) \to L^\times$ satisfying the 1-cocycle
  condition, there exists `β : Lˣ` such that $g(β)/β = f(g)$ for all `g : Aut_K(L)`.
* `groupCohomology.H1ofAutOnUnitsUnique`: Noether's generalization of Hilbert's Theorem 90:
$H^1(Aut_K(L), L^\times)$ is trivial.
* `NumberField.exists_eq_dvd_gen_apply_of_norm_eq_one`: the classical formulation of Hilbert's
  theorem 90: let `L/K` be a finite Galois extension of fields such that the Galois group is cyclic
  generated by `σ` and let `η : L` be an element of norm `1`. Then there exists `ε : L` such that
  `η = ε / σ ε`.

## Implementation notes

Given a commutative ring `k` and a group `G`, group cohomology is developed in terms of `k`-linear
`G`-representations on `k`-modules. Therefore stating Noether's generalization of Hilbert 90 in
terms of `H¹` requires us to turn the natural action of `Aut_K(L)` on `Lˣ` into a morphism
`Aut_K(L) →* (Additive Lˣ →ₗ[ℤ] Additive Lˣ)`. Thus we provide the non-`H¹` version too, as its
statement is clearer.

## TODO

* Develop Galois cohomology to extend Noether's result to infinite Galois extensions.
* "Additive Hilbert 90": let `L/K` be a finite Galois extension. Then $H^n(Gal(L/K), L)$ is trivial
  for all $1 ≤ n.$

-/

@[expose] public section


namespace groupCohomology
namespace Hilbert90

variable {K L : Type*} [Field K] [Field L] [Algebra K L] [FiniteDimensional K L]

/-- Given `f : Aut_K(L) → Lˣ`, the sum `∑ f(φ) • φ` for `φ ∈ Aut_K(L)`, as a function `L → L`. -/
noncomputable def aux (f : Gal(L/K) → Lˣ) : L → L :=
  Finsupp.linearCombination L (fun φ : Gal(L/K) ↦ (φ : L → L))
    (Finsupp.equivFunOnFinite.symm (fun φ => (f φ : L)))

theorem aux_ne_zero (f : Gal(L/K) → Lˣ) : aux f ≠ 0 :=
/- the set `Aut_K(L)` is linearly independent in the `L`-vector space `L → L`, by Dedekind's
linear independence of characters -/
  have : LinearIndependent L (fun (f : Gal(L/K)) => (f : L → L)) :=
    LinearIndependent.comp (ι' := Gal(L/K))
      (linearIndependent_monoidHom L L) (fun f => f)
      (fun x y h => by ext; exact DFunLike.ext_iff.1 h _)
  have h := linearIndependent_iff.1 this
    (Finsupp.equivFunOnFinite.symm (fun φ => (f φ : L)))
  fun H => Units.ne_zero (f 1) (DFunLike.ext_iff.1 (h H) 1)

end Hilbert90
section
open Hilbert90
variable {K L : Type*} [Field K] [Field L] [Algebra K L] [FiniteDimensional K L]

/-- Noether's generalization of Hilbert's Theorem 90: given a finite extension of fields and a
function `f : Aut_K(L) → Lˣ` satisfying `f(gh) = g(f(h)) * f(g)` for all `g, h : Aut_K(L)`, there
exists `β : Lˣ` such that `g(β)/β = f(g)` for all `g : Aut_K(L).` -/
theorem isMulCoboundary₁_of_isMulCocycle₁_of_aut_to_units
    (f : Gal(L/K) → Lˣ) (hf : IsMulCocycle₁ f) :
    IsMulCoboundary₁ f := by
/- Let `z : L` be such that `∑ f(h) * h(z) ≠ 0`, for `h ∈ Aut_K(L)` -/
  obtain ⟨z, hz⟩ : ∃ z, aux f z ≠ 0 :=
    not_forall.1 (fun H => aux_ne_zero f <| funext <| fun x => H x)
  have : aux f z = ∑ h, f h * h z := by simp [aux, Finsupp.linearCombination, Finsupp.sum_fintype]
/- Let `β = (∑ f(h) * h(z))⁻¹.` -/
  use (Units.mk0 (aux f z) hz)⁻¹
  intro g
/- Then the equality follows from the hypothesis that `f` is a 1-cocycle. -/
  simp only [IsMulCocycle₁, AlgEquiv.smul_units_def,
    map_inv, div_inv_eq_mul, inv_mul_eq_iff_eq_mul, Units.ext_iff, this,
    Units.val_mul, Units.coe_map, Units.val_mk0, MonoidHom.coe_coe] at hf ⊢
  simp_rw [map_sum, map_mul, Finset.sum_mul, mul_assoc, mul_comm _ (f _ : L), ← mul_assoc, ← hf g]
  exact eq_comm.1 (Fintype.sum_bijective (fun i => g * i)
    (Group.mulLeft_bijective g) _ _ (fun i => rfl))

@[deprecated (since := "2025-06-26")]
alias isMulOneCoboundary_of_isMulOneCocycle_of_aut_to_units :=
  isMulCoboundary₁_of_isMulCocycle₁_of_aut_to_units

end
variable (K L : Type) [Field K] [Field L] [Algebra K L] [FiniteDimensional K L]

/-- Noether's generalization of Hilbert's Theorem 90: given a finite extension of fields `L/K`, the
first group cohomology `H¹(Aut_K(L), Lˣ)` is trivial. -/
noncomputable instance H1ofAutOnUnitsUnique : Unique (H1 (Rep.ofAlgebraAutOnUnits K L)) where
  default := 0
  uniq := fun a => H1_induction_on a fun x => (H1π_eq_zero_iff _).2 <| by
    refine (coboundariesOfIsMulCoboundary₁ ?_).2
    rcases isMulCoboundary₁_of_isMulCocycle₁_of_aut_to_units x.1
      (isMulCocycle₁_of_mem_cocycles₁ _ x.2) with ⟨β, hβ⟩
    use β

end groupCohomology

namespace NumberField

open Nat nonZeroDivisors Finset Submodule groupCohomology Submonoid

variable {K L : Type*} [Field K] [Field L] [Algebra K L] [FiniteDimensional K L] {σ : Gal(L/K)}
  (hσ : ∀ x, x ∈ Subgroup.zpowers σ) {a b : ℕ} {η : Lˣ} (hη : Algebra.norm K η.1 = 1)

local notation3 "φ" => (finEquivZPowers (isOfFinOrder_of_finite σ)).symm

/-- The function `Gal(L/K) → Lˣ` sending `τ` to `∏ i ∈ range (φ ⟨τ, hσ τ⟩), σ ^ i η`. It is a
cocycle. -/
local notation3 "cocycle" =>
  (fun τ ↦ ∏ i ∈ range (φ ⟨τ, hσ τ⟩), Units.map (σ ^ i) η : Gal(L/K) → Lˣ)

include hσ hη in
private lemma aux1 [IsGalois K L] (h : a % orderOf σ = 0) : ∏ i ∈ range a, (σ ^ i) η = 1 := by
  obtain ⟨n, hn⟩ := dvd_iff_mod_eq_zero.2 h
  rw [hn, mul_comm, Finset.prod_range_mul]
  simp only [pow_add, pow_mul', pow_orderOf_eq_one, one_pow, one_mul]
  refine prod_eq_one (fun i hi ↦ ?_)
  have := Algebra.norm_eq_prod_automorphisms K η.1
  simp only [hη, map_one] at this
  convert this.symm
  refine prod_bij (fun n (_ : n ∈ range (orderOf σ)) ↦ σ ^ n) (by simp)
    (fun a ha b hb hab ↦ ?_) (fun τ _ ↦ ?_) (fun _ _ ↦ by rfl)
  · rwa [pow_inj_mod, mod_eq_of_lt (mem_range.1 ha),
      mod_eq_of_lt (mem_range.1 hb)] at hab
  · refine ⟨(finEquivZPowers (isOfFinOrder_of_finite σ)).symm ⟨τ, hσ τ⟩, by simp, ?_⟩
    have := Equiv.symm_apply_apply (finEquivZPowers (isOfFinOrder_of_finite σ)).symm ⟨τ, hσ τ⟩
    simp only [Equiv.symm_symm, ← Subtype.coe_inj] at this ⊢
    rw [← this, Equiv.symm_apply_apply, finEquivZPowers_apply]

include hσ hη in
private lemma aux2 [IsGalois K L] (h : a % orderOf σ = b % orderOf σ) :
    ∏ i ∈ range a, (σ ^ i) η = ∏ i ∈ range b, (σ ^ i) η := by
  wlog hab : b ≤ a generalizing a b
  · exact (this h.symm (not_le.1 hab).le).symm
  obtain ⟨c, hc⟩ := dvd_iff_mod_eq_zero.2 (sub_mod_eq_zero_of_mod_eq h)
  rw [Nat.sub_eq_iff_eq_add hab] at hc
  rw [hc, prod_range_add, aux1 hσ hη (mul_mod_right (orderOf σ) c), one_mul]
  simp [pow_add, pow_mul, pow_orderOf_eq_one]

private lemma cocycle_gen (hone : orderOf σ ≠ 1) : cocycle σ = η := by
  have horder := finEquivZPowers_symm_apply (isOfFinOrder_of_finite σ) 1
  simp only [pow_one, one_mod_eq_one.mpr hone] at horder
  simp only [horder, range_one, prod_singleton, pow_zero, AlgEquiv.aut_one]
  rfl

include hη in
private lemma cocycle_mul [IsGalois K L] (α β : Gal(L/K)) :
    cocycle (α * β) = α (cocycle β) * cocycle α := by
  have hσmon : ∀ x, x ∈ powers σ := by simpa [← mem_powers_iff_mem_zpowers] using hσ
  obtain ⟨a, ha⟩ := (mem_powers_iff _ _).1 (hσmon α)
  obtain ⟨b, hb⟩ := (mem_powers_iff _ _).1 (hσmon β)
  rw [← ha, ← hb, ← pow_add]
  have Hab := finEquivZPowers_symm_apply (isOfFinOrder_of_finite σ) (a + b)
  have Ha := finEquivZPowers_symm_apply (isOfFinOrder_of_finite σ) a
  have Hb := finEquivZPowers_symm_apply (isOfFinOrder_of_finite σ) b
  simp only [Units.coe_prod, Units.coe_map, MonoidHom.coe_coe, map_prod] at Hab Ha Hb ⊢
  rw [Hab, Ha, Hb, mul_comm]
  have H : ∀ n, σ ^ (a + n) = σ ^ (a % orderOf σ + n) := fun n ↦ by simp [pow_inj_mod]
  conv =>
    enter [2, 2, 2, x]
    rw [← AlgEquiv.mul_apply, ← pow_add, H]
  rw [← prod_range_add (fun (n : ℕ) ↦ (σ ^ n) η) (a % orderOf σ) (b % orderOf σ)]
  simpa using aux2 hσ hη (by simp)

include hη in
private lemma isMulCocycle₁_cocycle [IsGalois K L] : IsMulCocycle₁ cocycle := by
  intro α β
  simp [← Units.val_inj, cocycle_mul hσ hη α β]

include hη hσ in
/-- The classical formulation of Hilbert's theorem 90: let `L/K` be a finite Galois extension of
fields such that the Galois group is cyclic generated by `σ` and let `η : L` be an element of norm
`1`. Then there exists `ε : L` such that `η = ε / σ ε`. -/
lemma exists_eq_dvd_gen_apply_of_norm_eq_one [IsGalois K L] : ∃ ε : L, η = ε / σ ε := by
  by_cases hone : orderOf σ = 1
  · suffices Module.finrank K L = 1 by
      obtain ⟨a, ha⟩ := mem_span_singleton.1 <| (eq_top_iff'.1 <|
        (finrank_eq_one_iff_of_nonzero _ one_ne_zero).1 this) η
      rw [← Algebra.algebraMap_eq_smul_one] at ha
      rw [← ha, Algebra.norm_algebraMap, this, pow_one] at hη
      exact ⟨1, by simp [← ha, hη]⟩
    rw [← IsGalois.card_aut_eq_finrank, card_eq_fintype_card, Fintype.card_eq_one_iff]
    refine ⟨σ, fun τ ↦ ?_⟩
    simp only [orderOf_eq_one_iff.1 hone, Subgroup.zpowers_one_eq_bot, Subgroup.mem_bot] at hσ
    rw [orderOf_eq_one_iff.1 hone, hσ τ]
  obtain ⟨ε, hε⟩ := isMulCoboundary₁_of_isMulCocycle₁_of_aut_to_units _
    (isMulCocycle₁_cocycle hσ hη)
  use ε⁻¹
  simp only [map_inv₀, div_inv_eq_mul]
  specialize hε σ
  nth_rewrite 2 [← inv_inv ε] at hε
  rw [div_inv_eq_mul, cocycle_gen hσ hone, mul_inv_eq_iff_eq_mul, mul_comm,
    ← Units.val_inj] at hε
  simp only [AlgEquiv.smul_units_def, Units.coe_map, MonoidHom.coe_coe, Units.val_mul] at hε
  rw [hε, inv_mul_cancel_left₀ ε.ne_zero]

variable {A B : Type*} [CommRing A] [CommRing B] [Algebra A B] [Algebra A L] [Algebra A K]
variable [Algebra B L] [IsScalarTower A B L] [IsScalarTower A K L] [IsFractionRing A K] [IsDomain A]
variable [IsIntegralClosure B A L]

include hσ in
/-- The integral version of the classical formulation of Hilbert's theorem 90:  in the `ABKL`
setting, sauppose that `L/K` is finite Galois extension such that the Galois group is cyclic
generated by `σ` and let `η : B` be an element of norm `1` (when viewed as an element of `L`).
Then there exists `ε : B` such that `ε ≠ 0` and `η = ε / σ ε`. -/
lemma exists_eq_dvd_gen_apply_of_norm_eq_one_integral [IsGalois K L] {η : B}
  (hη : Algebra.norm K (algebraMap B L η) = 1) :
    ∃ ε : B, ε ≠ 0 ∧ η * galRestrict A K L B σ ε = ε := by
  have : NoZeroSMulDivisors A L := by
    rw [NoZeroSMulDivisors.iff_algebraMap_injective, IsScalarTower.algebraMap_eq A K L]
    exact (algebraMap K L).injective.comp (IsFractionRing.injective A K)
  have : IsLocalization (Algebra.algebraMapSubmonoid B A⁰) L :=
    IsIntegralClosure.isLocalization A K L B
  let η' : Lˣ := Units.mk0 (algebraMap B L η) (fun h ↦ by simp [h] at hη)
  replace hη : Algebra.norm K η'.1 = 1 := hη
  obtain ⟨ε, hε⟩ := exists_eq_dvd_gen_apply_of_norm_eq_one hσ hη
  obtain ⟨x, y, rfl⟩ := IsLocalization.exists_mk'_eq (Algebra.algebraMapSubmonoid B A⁰) ε
  obtain ⟨t, ht, ht'⟩ := y.prop
  have : t • IsLocalization.mk' L x y = algebraMap _ _ x := by
    rw [Algebra.smul_def, IsScalarTower.algebraMap_apply A B L, ht', IsLocalization.mk'_spec']
  refine ⟨x, ?_, ?_⟩
  · rintro rfl
    simp only [IsLocalization.mk'_zero, _root_.map_zero, div_zero] at hε
    rw [hε, Algebra.norm_zero] at hη
    exact zero_ne_one hη
  · rw [eq_div_iff_mul_eq] at hε
    · replace hε := congr_arg (t • ·) hε
      simp only at hε
      rw [Algebra.smul_def, mul_left_comm, ← Algebra.smul_def t] at hε
      change (algebraMap B L) η * t • σ.toAlgHom _ = _ at hε
      rw [← AlgHom.map_smul_of_tower, this] at hε
      apply IsIntegralClosure.algebraMap_injective B A L
      rw [map_mul, ← hε]
      congr 1
      · exact algebraMap_galRestrictHom_apply A K L B σ x
    · intro e
      rw [(map_eq_zero _).mp e, zero_div] at hε
      rw [hε, Algebra.norm_zero] at hη
      exact zero_ne_one hη

end NumberField
