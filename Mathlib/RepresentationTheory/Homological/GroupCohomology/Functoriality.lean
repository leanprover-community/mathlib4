/-
Copyright (c) 2023 Amelia Livingston. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Amelia Livingston
-/
import Mathlib.Algebra.Homology.HomologicalComplexAbelian
import Mathlib.RepresentationTheory.Homological.GroupCohomology.Basic
import Mathlib.RepresentationTheory.Homological.GroupCohomology.LowDegree

/-!
# Functoriality of group cohomology
Given a commutative ring `k`, a group homomorphism `f : G â†’* H`, a `k`-linear `H`-representation
`A`, a `k`-linear `G`-representation `B`, and a representation morphism `Res(f)(A) âŸ¶ B`, we get
a cochain map `inhomogeneousCochains A âŸ¶ inhomogeneousCochains B` and hence maps on
cohomology `Hâ¿(H, A) âŸ¶ Hâ¿(G, B)`. We use this to show a short exact sequence of representations
induces a short exact sequence of complexes of inhomogeneous cochains, allowing us to specialize
API for long exact sequences to group cohomology.
We also provide extra API for these functoriality maps in degrees 0, 1, 2.
## Main definitions
* `groupCohomology.cochainsMap f Ï†` is the map
`inhomogeneousCochains A âŸ¶ inhomogeneousCochains B`
induced by a group homomorphism `f : G â†’* H` and a representation morphism `Ï† : Res(f)(A) âŸ¶ B`.
* `groupCohomology.map f Ï† n` is the map `Hâ¿(H, A) âŸ¶ Hâ¿(G, B)` induced by a group
homomorphism `f : G â†’* H` and a representation morphism `Ï† : Res(f)(A) âŸ¶ B`.
-/

universe v u
variable (n : â„•)

open CategoryTheory

lemma Fin.comp_contractNth {G H : Type*} [MulOneClass G] [MulOneClass H] (f : G â†’* H)
    (j : Fin (n + 1)) (g : Fin (n + 1) â†’ G) :
    f âˆ˜ Fin.contractNth j (Â· * Â·) g = Fin.contractNth j (Â· * Â·) (f âˆ˜ g) := by
  ext x
  rcases lt_trichotomy (x : â„•) j with (h|h|h)
  Â· simp only [Function.comp_apply, Fin.contractNth_apply_of_lt, h]
  Â· simp only [Function.comp_apply, Fin.contractNth_apply_of_eq, h, f.map_mul]
  Â· simp only [Function.comp_apply, Fin.contractNth_apply_of_gt, h]

namespace LinearMap

lemma ker_compLeft
    {R M N : Type*} [Semiring R] [AddCommMonoid M] [AddCommMonoid N]
    [Module R M] [Module R N] (f : M â†’â‚—[R] N) (I : Type*) :
    LinearMap.ker (f.compLeft I) = Submodule.pi (Set.univ : Set I) (fun _ => LinearMap.ker f) :=
  Submodule.ext fun _ => âŸ¨fun (hx : _ = _) i _ => congr_fun hx i,
    fun hx => funext fun i => hx i trivialâŸ©

lemma range_compLeft
    {R M N : Type*} [Semiring R] [AddCommMonoid M] [AddCommMonoid N]
    [Module R M] [Module R N] (f : M â†’â‚—[R] N) (I : Type*) :
    LinearMap.range (f.compLeft I) = Submodule.pi (Set.univ : Set I) (fun _ => LinearMap.range f) :=
  Submodule.ext fun _ => âŸ¨fun âŸ¨y, hyâŸ© i _ => âŸ¨y i, congr_fun hy iâŸ©, fun hx => by
    choose y hy using hx
    exact âŸ¨fun i => y i trivial, funext fun i => hy i trivialâŸ©âŸ©

end LinearMap
namespace ModuleCat

variable (R : Type u) [Ring R]

end ModuleCat

namespace groupCohomology
open Rep

variable {k G H : Type u} [CommRing k] [Group G] [Group H]
  {A : Rep k H} {B : Rep k G} (f : G â†’* H) (Ï† : (Action.res _ f).obj A âŸ¶ B) (n : â„•)

open Representation

/-- Given a group homomorphism `f : G â†’* H` and a representation morphism `Ï† : Res(f)(A) âŸ¶ B`,
this is the chain map sending `x : (Fin n â†’ H) â†’ A)` to `(g : Fin n â†’ G) â†¦ Ï† (x (f âˆ˜ g))`. -/
@[simps! (config := .lemmasOnly) f f_hom]
noncomputable def cochainsMap :
    inhomogeneousCochains A âŸ¶ inhomogeneousCochains B where
  f i := ModuleCat.ofHom <|
    Ï†.hom.hom.compLeft (Fin i â†’ G) âˆ˜â‚— LinearMap.funLeft k A (fun x : Fin i â†’ G => (f âˆ˜ x))
  comm' i j (hij : _ = _) := by
    subst hij
    ext
    funext
    simpa [inhomogeneousCochains.d_apply, Fin.comp_contractNth] using (hom_comm_apply Ï† _ _).symm

@[simp]
lemma cochainsMap_id :
    cochainsMap (MonoidHom.id _) (ğŸ™ A) = ğŸ™ (inhomogeneousCochains A) := by
  rfl

@[simp]
lemma cochainsMap_id_eq_compLeft {A B : Rep k G} (f : A âŸ¶ B) (i : â„•) :
    (cochainsMap (MonoidHom.id G) f).f i = ModuleCat.ofHom (f.hom.hom.compLeft _) := by
  ext
  rfl

@[simp]
lemma cochainsMap_comp {G H K : Type u} [Group G] [Group H] [Group K]
    {A : Rep k K} {B : Rep k H} {C : Rep k G} (f : H â†’* K) (g : G â†’* H)
    (Ï† : (Action.res _ f).obj A âŸ¶ B) (Ïˆ : (Action.res _ g).obj B âŸ¶ C) :
    cochainsMap (f.comp g) ((Action.res _ g).map Ï† â‰« Ïˆ) =
      cochainsMap f Ï† â‰« cochainsMap g Ïˆ := by
  rfl

@[simp]
lemma cochainsMap_id_comp {A B C : Rep k G} (Ï† : A âŸ¶ B) (Ïˆ : B âŸ¶ C) :
    cochainsMap (MonoidHom.id G) (Ï† â‰« Ïˆ) =
      cochainsMap (MonoidHom.id G) Ï† â‰« cochainsMap (MonoidHom.id G) Ïˆ := by
  rfl

@[simp]
lemma cochainsMap_zero : cochainsMap (A := A) (B := B) f 0 = 0 := by rfl

lemma cochainsMap_f_map_mono (hf : Function.Surjective f) [Mono Ï†] (i : â„•) :
    Mono ((cochainsMap f Ï†).f i) := by
  simpa [ModuleCat.mono_iff_injective] using
    ((Rep.mono_iff_injective Ï†).1 inferInstance).comp_left.comp <|
    LinearMap.funLeft_injective_of_surjective k A _ hf.comp_left

instance cochainsMap_id_f_map_mono {A B : Rep k G} (Ï† : A âŸ¶ B) [Mono Ï†] (i : â„•) :
    Mono ((cochainsMap (MonoidHom.id G) Ï†).f i) :=
  cochainsMap_f_map_mono (MonoidHom.id G) Ï† (fun x => âŸ¨x, rflâŸ©) i

lemma cochainsMap_f_map_epi (hf : Function.Injective f) [Epi Ï†] (i : â„•) :
    Epi ((cochainsMap f Ï†).f i) := by
  simpa [ModuleCat.epi_iff_surjective] using
    ((Rep.epi_iff_surjective Ï†).1 inferInstance).comp_left.comp <|
    LinearMap.funLeft_surjective_of_injective k A _ hf.comp_left

instance cochainsMap_id_f_map_epi {A B : Rep k G} (Ï† : A âŸ¶ B) [Epi Ï†] (i : â„•) :
    Epi ((cochainsMap (MonoidHom.id G) Ï†).f i) :=
  cochainsMap_f_map_epi (MonoidHom.id G) Ï† (fun _ _ h => h) i

/-- Given a group homomorphism `f : G â†’* H` and a representation morphism `Ï† : Res(f)(A) âŸ¶ B`,
this is the induced map `Zâ¿(H, A) âŸ¶ Zâ¿(G, B)` sending `x : (Fin n â†’ H) â†’ A)` to
`(g : Fin n â†’ G) â†¦ Ï† (x (f âˆ˜ g))`. -/
noncomputable abbrev cocyclesMap (n : â„•) :
    groupCohomology.cocycles A n âŸ¶ groupCohomology.cocycles B n :=
  HomologicalComplex.cyclesMap (cochainsMap f Ï†) n

@[simp]
theorem cocyclesMap_id_comp {A B C : Rep k G} (Ï† : A âŸ¶ B) (Ïˆ : B âŸ¶ C) (n : â„•) :
    cocyclesMap (MonoidHom.id G) (Ï† â‰« Ïˆ) n =
      cocyclesMap (MonoidHom.id G) Ï† n â‰« cocyclesMap (MonoidHom.id G) Ïˆ n := by
  simp [cocyclesMap, cochainsMap_id_comp, HomologicalComplex.cyclesMap_comp]

/-- Given a group homomorphism `f : G â†’* H` and a representation morphism `Ï† : Res(f)(A) âŸ¶ B`,
this is the induced map `Hâ¿(H, A) âŸ¶ Hâ¿(G, B)` sending `x : (Fin n â†’ H) â†’ A)` to
`(g : Fin n â†’ G) â†¦ Ï† (x (f âˆ˜ g))`. -/
noncomputable abbrev map (n : â„•) :
    groupCohomology A n âŸ¶ groupCohomology B n :=
  HomologicalComplex.homologyMap (cochainsMap f Ï†) n

@[simp]
theorem map_id_comp {A B C : Rep k G} (Ï† : A âŸ¶ B) (Ïˆ : B âŸ¶ C) (n : â„•) :
    map (MonoidHom.id G) (Ï† â‰« Ïˆ) n =
      map (MonoidHom.id G) Ï† n â‰« map (MonoidHom.id G) Ïˆ n := by
  rw [map, cochainsMap_id_comp, HomologicalComplex.homologyMap_comp]

/-- Given a group homomorphism `f : G â†’* H` and a representation morphism `Ï† : Res(f)(A) âŸ¶ B`,
this is the induced map sending `x : H â†’ A` to `(g : G) â†¦ Ï† (x (f g))`. -/
abbrev fOne := Ï†.hom.hom.compLeft G âˆ˜â‚— LinearMap.funLeft k A f

/-- Given a group homomorphism `f : G â†’* H` and a representation morphism `Ï† : Res(f)(A) âŸ¶ B`,
this is the induced map sending `x : H Ã— H â†’ A` to `(gâ‚, gâ‚‚ : G Ã— G) â†¦ Ï† (x (f gâ‚, f gâ‚‚))`. -/
abbrev fTwo := Ï†.hom.hom.compLeft (G Ã— G) âˆ˜â‚— LinearMap.funLeft k A (Prod.map f f)

/-- Given a group homomorphism `f : G â†’* H` and a representation morphism `Ï† : Res(f)(A) âŸ¶ B`,
this is the induced map sending `x : H Ã— H Ã— H â†’ A` to
`(gâ‚, gâ‚‚, gâ‚ƒ : G Ã— G Ã— G) â†¦ Ï† (x (f gâ‚, f gâ‚‚, f gâ‚ƒ))`. -/
abbrev fThree := Ï†.hom.hom.compLeft (G Ã— G Ã— G) âˆ˜â‚— LinearMap.funLeft k A (Prod.map f (Prod.map f f))

@[reassoc (attr := simp)]
lemma cochainsMap_f_0_comp_zeroCochainsLequiv :
    (cochainsMap f Ï†).f 0 â‰« (zeroCochainsLequiv B).toModuleIso.hom =
      (zeroCochainsLequiv A).toModuleIso.hom â‰« Ï†.hom := by
  ext x
  simp only [cochainsMap_f, Unique.eq_default (f âˆ˜ _)]
  rfl

@[reassoc (attr := simp)]
lemma cochainsMap_f_1_comp_oneCochainsLequiv :
    (cochainsMap f Ï†).f 1 â‰« (oneCochainsLequiv B).toModuleIso.hom =
      (oneCochainsLequiv A).toModuleIso.hom â‰« ModuleCat.ofHom (fOne f Ï†) := by
  ext x
  simp only [cochainsMap_f, Unique.eq_default (f âˆ˜ _)]
  rfl

@[reassoc (attr := simp)]
lemma cochainsMap_f_2_comp_twoCochainsLequiv :
    (cochainsMap f Ï†).f 2 â‰« (twoCochainsLequiv B).toModuleIso.hom =
      (twoCochainsLequiv A).toModuleIso.hom â‰« ModuleCat.ofHom (fTwo f Ï†) := by
  ext x g
  show Ï†.hom (x _) = Ï†.hom (x _)
  rcongr x
  fin_cases x <;> rfl

@[reassoc (attr := simp)]
lemma cochainsMap_f_3_comp_threeCochainsLequiv :
    (cochainsMap f Ï†).f 3 â‰« (threeCochainsLequiv B).toModuleIso.hom =
      (threeCochainsLequiv A).toModuleIso.hom â‰« ModuleCat.ofHom (fThree f Ï†) := by
  ext x g
  show Ï†.hom (x _) = Ï†.hom (x _)
  rcongr x
  fin_cases x <;> rfl

end groupCohomology
