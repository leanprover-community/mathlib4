/-
Copyright (c) 2025 Amelia Livingston. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Amelia Livingston
-/
import Mathlib.Algebra.Homology.AlternatingConst
import Mathlib.Algebra.Homology.ShortComplex.ModuleCat
import Mathlib.CategoryTheory.Preadditive.Projective.Resolution
import Mathlib.GroupTheory.OrderOfElement
import Mathlib.RepresentationTheory.Coinvariants

/-!
# Projective resolution of `k` as a trivial `k`-linear representation of a finite cyclic group

Let `k` be a commutative ring and `G` a finite commutative group. Given `g : G` and `A : Rep k G`,
we can define a periodic chain complex in `Rep k G` given by
`... ‚ü∂ A --N--> A --(œÅ(g) - ùüô)--> A --N--> A --(œÅ(g) - ùüô)--> A ‚ü∂ 0`
where `N` is the norm map sending `a : A` to `‚àë œÅ(g)(a)` for all `g` in `G`.

When `G` is generated by `g` and `A` is the left regular representation `k[G]`, this chain complex
is a projective resolution of `k` as a trivial representation, which we prove here.

In the file `RepresentationTheory/HomologicalComplex/GroupHomology/FiniteCyclic.lean`, we use
this resolution to compute the group homology of representations of finite cyclic groups.

## Main definitions

* `Rep.FiniteCyclicGroup.resolution k g hg`: given a finite cyclic group `G` generated by `g : G`,
  this is the projective resolution of `k` as a trivial `k`-linear `G`-representation given by
  periodic complex
  `... ‚ü∂ k[G] --N--> k[G] --(œÅ(g) - ùüô)--> k[G] --N--> k[G] --(œÅ(g) - ùüô)--> k[G] ‚ü∂ 0` where `œÅ` is
  the left regular representation and `N` is the norm map.

## TODO

* Use this to analyse the group cohomology of representations of finite cyclic groups.

-/

universe v u

open CategoryTheory Finsupp

namespace Representation.FiniteCyclicGroup

variable {k G V : Type*} [CommRing k] [Group G] [Fintype G] {V : Type*} [AddCommGroup V]
  [Module k V] (œÅ : Representation k G V) (g : G)

lemma coinvariantsKer_eq_range (hg : ‚àÄ x, x ‚àà Subgroup.zpowers g) :
    Coinvariants.ker œÅ = LinearMap.range (œÅ g - LinearMap.id) := by
  refine le_antisymm (Submodule.span_le.2 ?_) ?_
  ¬∑ rintro a ‚ü®‚ü®Œ≥, Œ±‚ü©, rfl‚ü©
    rcases mem_powers_iff_mem_zpowers.2 (hg Œ≥) with ‚ü®i, rfl‚ü©
    induction i with | zero => exact ‚ü®0, by simp‚ü© | succ n _ =>
    use (Fin.partialSum (fun (j : Fin (n + 1)) => œÅ (g ^ (j : ‚Ñï)) Œ±) (Fin.last _))
    simpa using œÅ.apply_sub_id_partialSum_eq _ _ _
  ¬∑ rintro x ‚ü®y, rfl‚ü©
    simpa using Coinvariants.sub_mem_ker g y

/-- Given a finite cyclic group `G` generated by `g` and a `G` representation `(V, œÅ)`, `V_G` is
isomorphic to `V ‚ß∏ Im(œÅ(g - 1))`. -/
noncomputable def coinvariantsEquiv (hg : ‚àÄ x, x ‚àà Subgroup.zpowers g) :
    œÅ.Coinvariants ‚âÉ‚Çó[k] (_ ‚ß∏ LinearMap.range (œÅ g - LinearMap.id)) :=
  Submodule.quotEquivOfEq _ _ (coinvariantsKer_eq_range œÅ g hg)

lemma coinvariantsKer_leftRegular_eq_ker :
    Coinvariants.ker (Representation.leftRegular k G) =
      LinearMap.ker (linearCombination k (fun _ => (1 : k))) := by
  refine le_antisymm (Submodule.span_le.2 ?_) fun x hx => ?_
  ¬∑ rintro x ‚ü®‚ü®g, y‚ü©, rfl‚ü©
    simpa [linearCombination, sub_eq_zero, sum_fintype]
      using Finset.sum_bijective _ (Group.mulLeft_bijective g‚Åª¬π) (by aesop) (by aesop)
  ¬∑ have : x = x.sum (fun g r => single g r - single 1 r) := by
      ext g
      by_cases hg : g = 1
      ¬∑ simp_all [linearCombination, sum_apply']
      ¬∑ simp_all [sum_apply']
    rw [this]
    exact Submodule.finsuppSum_mem _ _ _ _ fun g _ =>
      Coinvariants.mem_ker_of_eq g (single 1 (x g)) _ (by simp)

end Representation.FiniteCyclicGroup

namespace Rep.FiniteCyclicGroup

variable (k : Type u) {G : Type u} [CommRing k] [CommGroup G] [Fintype G] (A : Rep k G) (g : G)

namespace leftRegular

open Finsupp IsCyclic Representation

lemma range_norm_eq_ker_applyAsHom_sub (hg : ‚àÄ x, x ‚àà Subgroup.zpowers g) :
    LinearMap.range (leftRegular k G).norm.hom.hom =
      LinearMap.ker (applyAsHom (leftRegular k G) g - ùüô _).hom.hom :=
  le_antisymm (fun _ ‚ü®_, h‚ü© => by simp_all [‚Üê h]) fun x hx => ‚ü®single 1 (x g), by
    ext j; simpa [Representation.norm] using (apply_eq_of_leftRegular_eq_of_generator g hg _
      (by simpa [sub_eq_zero] using hx) j).symm‚ü©

lemma range_applyAsHom_sub_eq_ker_linearCombination (hg : ‚àÄ x, x ‚àà Subgroup.zpowers g) :
    LinearMap.range (applyAsHom (leftRegular k G) g - ùüô _).hom.hom =
      LinearMap.ker (linearCombination k (fun _ => (1 : k))) := by
  simp [‚Üê FiniteCyclicGroup.coinvariantsKer_eq_range _ _ hg,
    ‚Üê FiniteCyclicGroup.coinvariantsKer_leftRegular_eq_ker]

lemma range_applyAsHom_sub_eq_ker_norm (hg : ‚àÄ x, x ‚àà Subgroup.zpowers g) :
    LinearMap.range (applyAsHom (leftRegular k G) g - ùüô _).hom.hom =
      LinearMap.ker (leftRegular k G).norm.hom.hom := by
  simp [ker_leftRegular_norm_eq, ‚Üê range_applyAsHom_sub_eq_ker_linearCombination k g hg]

end leftRegular

/-- Given a finite group `G` and `g : G`, this is the functor `Rep k G ‚•§ ChainComplex (Rep k G) ‚Ñï`
sending `A : Rep k G` to the periodic chain complex in `Rep k G` given by
`... ‚ü∂ A --N--> A --(œÅ(g) - ùüô)--> A --N--> A --(œÅ(g) - ùüô)--> A ‚ü∂ 0`
where `N` is the norm map. When `G` is generated by `g` and `A` is the left regular representation
`k[G]`, it is a projective resolution of `k` as a trivial representation.

It sends a morphism `f : A ‚ü∂ B` to the chain morphism defined by `f` in every degree. -/
@[simps]
noncomputable def chainComplexFunctor : Rep k G ‚•§ ChainComplex (Rep k G) ‚Ñï where
  obj A := HomologicalComplex.alternatingConst A (œÜ := A.norm) (œà := applyAsHom A g - ùüô A)
    (by ext; simp) (by ext; simp) fun _ _ => ComplexShape.down_nat_odd_add
  map f := {
    f i := f
    comm' := by
      rintro i j ‚ü®rfl‚ü©
      by_cases hj : Even (j + 1)
      ¬∑ simp [if_pos hj, norm_comm]
      ¬∑ simp [if_neg hj, applyAsHom_comm] }
  map_id _ := rfl
  map_comp _ _ := rfl

variable {k}

/-- Given a finite cyclic group `G` generated by `g : G` and a `k`-linear `G`-representation `A`,
this is the short complex in `ModuleCat k` given by `A --N--> A --(œÅ(g) - ùüô)--> A`
where `N` is the norm map. Its homology is `H‚Å±(G, A)` for even `i` and `H·µ¢(G, A)` for odd `i`. -/
noncomputable abbrev normHomCompSub : ShortComplex (ModuleCat k) :=
  ShortComplex.mk A.norm.hom (applyAsHom A g - ùüô A).hom (by ext; simp)

/-- Given a finite cyclic group `G` generated by `g : G` and a `k`-linear `G`-representation `A`,
this is the short complex in `ModuleCat k` given by `A --N--> A --(œÅ(g) - ùüô)--> A`
where `N` is the norm map. Its homology is `H‚Å±(G, A)` for even `i` and `H·µ¢(G, A)` for odd `i`. -/
noncomputable abbrev subCompNormHom : ShortComplex (ModuleCat k) :=
  ShortComplex.mk (applyAsHom A g - ùüô A).hom A.norm.hom (by ext; simp)

/-- Given a finite cyclic group `G` generated by `g : G` and a `k`-linear `G`-representation `A`,
this is the periodic chain complex in `ModuleCat k` given by
`... ‚ü∂ A --N--> A --(œÅ(g) - ùüô)--> A --N--> A --(œÅ(g) - ùüô)--> A ‚ü∂ 0` where `N` is the norm map.
Its homology is the group homology of `A`. -/
noncomputable abbrev moduleCatChainComplex : ChainComplex (ModuleCat k) ‚Ñï :=
  HomologicalComplex.alternatingConst A.V (œÜ := A.norm.hom) (œà := (applyAsHom A g - ùüô A).hom)
    (by ext; simp) (by ext; simp) fun _ _ => ComplexShape.down_nat_odd_add

/-- Given a finite cyclic group `G` generated by `g : G` and a `k`-linear `G`-representation `A`,
this is the periodic chain complex in `Rep k G` given by
`0 ‚ü∂ A --(œÅ(g) - ùüô)--> A --N--> A --(œÅ(g) - ùüô)--> A --N--> A ‚ü∂ ...` where `N` is the norm map.
Its cohomology is the group cohomology of `A`. -/
noncomputable abbrev moduleCatCochainComplex : CochainComplex (ModuleCat k) ‚Ñï :=
  HomologicalComplex.alternatingConst A.V (œÜ := (applyAsHom A g - ùüô A).hom) (œà := A.norm.hom)
    (by ext; simp) (by ext; simp) fun _ _ => ComplexShape.up_nat_odd_add

variable (k)

/-- Given a finite cyclic group `G` generated by `g : G`, let `P` denote the periodic chain complex
of `k`-linear `G`-representations given by
`... ‚ü∂ k[G] --N--> k[G] --(œÅ(g) - ùüô)--> k[G] --N--> k[G] --(œÅ(g) - ùüô)--> k[G] ‚ü∂ 0` where `œÅ` is
the left regular representation and `N` is the norm map. This is the chain morphism from `P` to
the chain complex concentrated at 0 by the trivial representation `k` used to show `P` is a
projective resolution of `k`. It sends `x : k[G]` to the sum of its coefficients. -/
@[simps!]
noncomputable def resolution.œÄ (g : G) :
    (chainComplexFunctor k g).obj (leftRegular k G) ‚ü∂
      (ChainComplex.single‚ÇÄ (Rep k G)).obj (trivial k G k) :=
  (((chainComplexFunctor k g).obj (leftRegular k G)).toSingle‚ÇÄEquiv _).symm
    ‚ü®leftRegularHom _ 1, (leftRegularHomEquiv _).injective <| by simp [leftRegularHomEquiv]‚ü©

lemma resolution_quasiIso (g : G) (hg : ‚àÄ x, x ‚àà Subgroup.zpowers g) :
    QuasiIso (resolution.œÄ k g) where
  quasiIsoAt m := by
    induction m with
    | zero =>
      simp only [resolution.œÄ]
      rw [ChainComplex.quasiIsoAt‚ÇÄ_iff, ShortComplex.quasiIso_iff_of_zeros' _ rfl rfl rfl]
      constructor
      ¬∑ apply (Action.forget (ModuleCat k) _).reflects_exact_of_faithful
        simpa [ShortComplex.moduleCat_exact_iff_range_eq_ker,
          HomologicalComplex.alternatingConst, ChainComplex.toSingle‚ÇÄEquiv] using
          leftRegular.range_applyAsHom_sub_eq_ker_linearCombination k g hg
      ¬∑ rw [Rep.epi_iff_surjective]
        intro x
        use single 1 x
        simp [ChainComplex.toSingle‚ÇÄEquiv]
    | succ m _ =>
      rw [quasiIsoAt_iff_exactAt' (hL := ChainComplex.exactAt_succ_single_obj ..),
          HomologicalComplex.exactAt_iff' _ (m + 2) (m + 1) m (by simp) (by simp)]
      apply (Action.forget (ModuleCat k) _).reflects_exact_of_faithful
      rw [ShortComplex.moduleCat_exact_iff_range_eq_ker]
      by_cases hm : Odd (m + 1)
      ¬∑ simpa [if_pos (Nat.even_add_one.2 (Nat.not_even_iff_odd.2 hm)),
          if_neg (Nat.not_even_iff_odd.2 hm)]
          using leftRegular.range_norm_eq_ker_applyAsHom_sub k g hg
      ¬∑ simpa [ShortComplex.moduleCat_exact_iff_range_eq_ker, if_pos (Nat.not_odd_iff_even.1 hm),
          if_neg (Nat.not_even_iff_odd.2 <| Nat.odd_add_one.2 hm)]
        using leftRegular.range_applyAsHom_sub_eq_ker_norm k g hg

/-- Given a finite cyclic group `G` generated by `g : G`, this is the projective resolution of `k`
as a trivial `k`-linear `G`-representation given by periodic complex
`... ‚ü∂ k[G] --N--> k[G] --(œÅ(g) - ùüô)--> k[G] --N--> k[G] --(œÅ(g) - ùüô)--> k[G] ‚ü∂ 0` where `œÅ` is
the left regular representation and `N` is the norm map. -/
@[simps]
noncomputable def resolution (g : G) (hg : ‚àÄ x, x ‚àà Subgroup.zpowers g) :
    ProjectiveResolution (trivial k G k) where
  complex := (FiniteCyclicGroup.chainComplexFunctor k g).obj (leftRegular k G)
  projective _ := inferInstanceAs <| Projective (leftRegular k G)
  œÄ := FiniteCyclicGroup.resolution.œÄ k g
  quasiIso := resolution_quasiIso k g hg

end Rep.FiniteCyclicGroup
