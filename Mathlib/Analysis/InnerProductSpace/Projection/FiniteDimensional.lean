/-
Copyright (c) 2019 Zhouhang Zhou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zhouhang Zhou, FrÃ©dÃ©ric Dupuis, Heather Macbeth
-/
import Mathlib.Analysis.InnerProductSpace.Projection.Basic
import Mathlib.Analysis.InnerProductSpace.Projection.Reflection
import Mathlib.Analysis.InnerProductSpace.Projection.Submodule
import Mathlib.Algebra.DirectSum.Decomposition
import Mathlib.Analysis.NormedSpace.RCLike

/-!
# Orthogonal projections in finite-dimensional spaces

This file contains results about orthogonal projections in finite-dimensional spaces.

## Main results

* `Submodule.det_reflection`: The determinant of `K.reflection` is `(-1) ^ finrank ğ•œ Ká—®`.
* `LinearIsometryEquiv.reflections_generate`: The orthogonal group of `F` is
generated by reflections.

## Results that do not use finite dimensionality:

* `OrthogonalFamily.isInternal_iff_of_isComplete`
* `OrthogonalFamily.sum_projection_of_mem_iSup`
* `OrthogonalFamily.projection_directSum_coeAddHom`
* `OrthogonalFamily.decomposition`
* `maximal_orthonormal_iff_orthogonalComplement_eq_bot`
-/

variable {ğ•œ E F : Type*} [RCLike ğ•œ]
variable [NormedAddCommGroup E] [NormedAddCommGroup F]
variable [InnerProductSpace ğ•œ E] [InnerProductSpace â„ F]

local notation "âŸª" x ", " y "âŸ«" => inner ğ•œ x y
local notation "absR" => @abs â„ _ _

open Topology Finsupp Submodule RCLike Real Filter InnerProductSpace
open LinearMap (ker range)

variable (K : Submodule ğ•œ E)

namespace Submodule

section FiniteDimensional

open Module

variable [FiniteDimensional ğ•œ K]

@[simp]
theorem topologicalClosure_eq_self : K.topologicalClosure = K :=
  K.closed_of_finiteDimensional.submodule_topologicalClosure_eq

@[simp]
theorem det_reflection : LinearMap.det K.reflection.toLinearMap = (-1) ^ finrank ğ•œ Ká—® := by
  by_cases hK : FiniteDimensional ğ•œ Ká—®
  swap
  Â· rw [finrank_of_infinite_dimensional hK, pow_zero, LinearMap.det_eq_one_of_finrank_eq_zero]
    exact finrank_of_infinite_dimensional fun h â†¦ hK (h.finiteDimensional_submodule _)
  let e := K.prodEquivOfIsCompl _ K.isCompl_orthogonal_of_hasOrthogonalProjection
  let b := (finBasis ğ•œ K).prod (finBasis ğ•œ Ká—®)
  have : LinearMap.toMatrix b b (e.symm âˆ˜â‚— K.reflection.toLinearMap âˆ˜â‚— e.symm.symm) =
      Matrix.fromBlocks 1 0 0 (-1) := by
    ext (_ | _) (_ | _) <;>
    simp [LinearMap.toMatrix_apply, b, Matrix.one_apply, Finsupp.single_apply, e, eq_comm,
      reflection_mem_subspace_eq_self, reflection_mem_subspace_orthogonalComplement_eq_neg]
  rw [â† LinearMap.det_conj _ e.symm, â† LinearMap.det_toMatrix b, this, Matrix.det_fromBlocks_zeroâ‚‚â‚,
    Matrix.det_one, one_mul, Matrix.det_neg, Fintype.card_fin, Matrix.det_one, mul_one]

@[simp]
theorem linearEquiv_det_reflection : K.reflection.det = (-1) ^ finrank ğ•œ Ká—® := by
  ext
  rw [LinearEquiv.coe_det, Units.val_pow_eq_pow_val]
  exact K.det_reflection

end FiniteDimensional

variable {K}

open Module

/-- Given a finite-dimensional subspace `Kâ‚‚`, and a subspace `Kâ‚`
contained in it, the dimensions of `Kâ‚` and the intersection of its
orthogonal subspace with `Kâ‚‚` add to that of `Kâ‚‚`. -/
theorem finrank_add_inf_finrank_orthogonal {Kâ‚ Kâ‚‚ : Submodule ğ•œ E}
    [FiniteDimensional ğ•œ Kâ‚‚] (h : Kâ‚ â‰¤ Kâ‚‚) :
    finrank ğ•œ Kâ‚ + finrank ğ•œ (Kâ‚á—® âŠ“ Kâ‚‚ : Submodule ğ•œ E) = finrank ğ•œ Kâ‚‚ := by
  haveI : FiniteDimensional ğ•œ Kâ‚ := Submodule.finiteDimensional_of_le h
  haveI := FiniteDimensional.proper_rclike ğ•œ Kâ‚
  have hd := Submodule.finrank_sup_add_finrank_inf_eq Kâ‚ (Kâ‚á—® âŠ“ Kâ‚‚)
  rw [â† inf_assoc, (Submodule.orthogonal_disjoint Kâ‚).eq_bot, bot_inf_eq, finrank_bot,
    Submodule.sup_orthogonal_inf_of_hasOrthogonalProjection h] at hd
  rw [add_zero] at hd
  exact hd.symm

/-- Given a finite-dimensional subspace `Kâ‚‚`, and a subspace `Kâ‚`
contained in it, the dimensions of `Kâ‚` and the intersection of its
orthogonal subspace with `Kâ‚‚` add to that of `Kâ‚‚`. -/
theorem finrank_add_inf_finrank_orthogonal' {Kâ‚ Kâ‚‚ : Submodule ğ•œ E}
    [FiniteDimensional ğ•œ Kâ‚‚] (h : Kâ‚ â‰¤ Kâ‚‚) {n : â„•} (h_dim : finrank ğ•œ Kâ‚ + n = finrank ğ•œ Kâ‚‚) :
    finrank ğ•œ (Kâ‚á—® âŠ“ Kâ‚‚ : Submodule ğ•œ E) = n := by
  rw [â† add_right_inj (finrank ğ•œ Kâ‚)]
  simp [Submodule.finrank_add_inf_finrank_orthogonal h, h_dim]

/-- Given a finite-dimensional space `E` and subspace `K`, the dimensions of `K` and `Ká—®` add to
that of `E`. -/
theorem finrank_add_finrank_orthogonal [FiniteDimensional ğ•œ E] (K : Submodule ğ•œ E) :
    finrank ğ•œ K + finrank ğ•œ Ká—® = finrank ğ•œ E := by
  convert Submodule.finrank_add_inf_finrank_orthogonal (le_top : K â‰¤ âŠ¤) using 1
  Â· rw [inf_top_eq]
  Â· simp

/-- Given a finite-dimensional space `E` and subspace `K`, the dimensions of `K` and `Ká—®` add to
that of `E`. -/
theorem finrank_add_finrank_orthogonal' [FiniteDimensional ğ•œ E] {K : Submodule ğ•œ E}
    {n : â„•} (h_dim : finrank ğ•œ K + n = finrank ğ•œ E) : finrank ğ•œ Ká—® = n := by
  rw [â† add_right_inj (finrank ğ•œ K)]
  simp [Submodule.finrank_add_finrank_orthogonal, h_dim]

/-- In a finite-dimensional inner product space, the dimension of the orthogonal complement of the
span of a nonzero vector is one less than the dimension of the space. -/
theorem finrank_orthogonal_span_singleton {n : â„•} [_i : Fact (finrank ğ•œ E = n + 1)] {v : E}
    (hv : v â‰  0) : finrank ğ•œ (ğ•œ âˆ™ v)á—® = n := by
  haveI : FiniteDimensional ğ•œ E := .of_fact_finrank_eq_succ n
  exact finrank_add_finrank_orthogonal' <| by
    simp [finrank_span_singleton hv, _i.elim, add_comm]

end Submodule

open Module Submodule

/-- An element `Ï†` of the orthogonal group of `F` can be factored as a product of reflections, and
specifically at most as many reflections as the dimension of the complement of the fixed subspace
of `Ï†`. -/
theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional â„ F] {n : â„•}
    (Ï† : F â‰ƒâ‚—áµ¢[â„] F) (hn : finrank â„ (ker (ContinuousLinearMap.id â„ F - Ï†))á—® â‰¤ n) :
    âˆƒ l : List F, l.length â‰¤ n âˆ§ Ï† = (l.map fun v => (â„ âˆ™ v)á—®.reflection).prod := by
  -- We prove this by strong induction on `n`, the dimension of the orthogonal complement of the
  -- fixed subspace of the endomorphism `Ï†`
  induction' n with n IH generalizing Ï†
  Â· -- Base case: `n = 0`, the fixed subspace is the whole space, so `Ï† = id`
    refine âŸ¨[], rfl.le, show Ï† = 1 from ?_âŸ©
    have : ker (ContinuousLinearMap.id â„ F - Ï†) = âŠ¤ := by
      rwa [le_zero_iff, finrank_eq_zero, orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  Â· -- Inductive step.  Let `W` be the fixed subspace of `Ï†`.  We suppose its complement to have
    -- dimension at most n + 1.
    let W := ker (ContinuousLinearMap.id â„ F - Ï†)
    have hW : âˆ€ w âˆˆ W, Ï† w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank â„ Wá—® â‰¤ n
    Â· obtain âŸ¨V, hVâ‚, hVâ‚‚âŸ© := IH Ï† hn'
      exact âŸ¨V, hVâ‚.trans n.le_succ, hVâ‚‚âŸ©
    -- Take a nonzero element `v` of the orthogonal complement of `W`.
    haveI : Nontrivial Wá—® := nontrivial_of_finrank_pos (by omega : 0 < finrank â„ Wá—®)
    obtain âŸ¨v, hvâŸ© := exists_ne (0 : Wá—®)
    have hÏ†v : Ï† v âˆˆ Wá—® := by
      intro w hw
      rw [â† hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) âˆ‰ W := by
      intro h
      exact hv ((mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    -- Let `Ï` be the reflection in `v - Ï† v`; this is designed to swap `v` and `Ï† v`
    let x : F := v - Ï† v
    let Ï := (â„ âˆ™ x)á—®.reflection
    -- Notation: Let `V` be the fixed subspace of `Ï†.trans Ï`
    let V := ker (ContinuousLinearMap.id â„ F - Ï†.trans Ï)
    have hV : âˆ€ w, Ï (Ï† w) = w â†’ w âˆˆ V := by
      intro w hw
      change w - Ï (Ï† w) = 0
      rw [sub_eq_zero, hw]
    -- Everything fixed by `Ï†` is fixed by `Ï†.trans Ï`
    have Hâ‚‚V : W â‰¤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hÏ†v _ hw
    -- `v` is also fixed by `Ï†.trans Ï`
    have Hâ‚V : (v : F) âˆˆ V := by
      apply hV
      have : Ï v = Ï† v := reflection_sub (Ï†.norm_map v).symm
      rw [â† this]
      exact reflection_reflection _ _
    -- By dimension-counting, the complement of the fixed subspace of `Ï†.trans Ï` has dimension at
    -- most `n`
    have : finrank â„ Vá—® â‰¤ n := by
      change finrank â„ Wá—® â‰¤ n + 1 at hn
      have : finrank â„ W + 1 â‰¤ finrank â„ V :=
        finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 âŸ¨Hâ‚‚V, v, Hâ‚V, hv'âŸ©)
      have : finrank â„ V + finrank â„ Vá—® = finrank â„ F := V.finrank_add_finrank_orthogonal
      have : finrank â„ W + finrank â„ Wá—® = finrank â„ F := W.finrank_add_finrank_orthogonal
      omega
    -- So apply the inductive hypothesis to `Ï†.trans Ï`
    obtain âŸ¨l, hl, hÏ†lâŸ© := IH (Ï * Ï†) this
    -- Prepend `Ï` to the factorization into reflections obtained for `Ï†.trans Ï`; this gives a
    -- factorization into reflections for `Ï†`.
    refine âŸ¨x::l, Nat.succ_le_succ hl, ?_âŸ©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (Ï * Â·) hÏ†l
    dsimp only at this
    rwa [â† mul_assoc, reflection_mul_reflection, one_mul] at this

/-- The orthogonal group of `F` is generated by reflections; specifically each element `Ï†` of the
orthogonal group is a product of at most as many reflections as the dimension of `F`.

Special case of the **Cartanâ€“DieudonnÃ© theorem**. -/
theorem LinearIsometryEquiv.reflections_generate_dim [FiniteDimensional â„ F] (Ï† : F â‰ƒâ‚—áµ¢[â„] F) :
    âˆƒ l : List F, l.length â‰¤ finrank â„ F âˆ§ Ï† = (l.map fun v => reflection (â„ âˆ™ v)á—®).prod :=
  let âŸ¨l, hlâ‚, hlâ‚‚âŸ© := Ï†.reflections_generate_dim_aux le_rfl
  âŸ¨l, hlâ‚.trans (finrank_le _), hlâ‚‚âŸ©

/-- The orthogonal group of `F` is generated by reflections. -/
theorem LinearIsometryEquiv.reflections_generate [FiniteDimensional â„ F] :
    Subgroup.closure (Set.range fun v : F => reflection (â„ âˆ™ v)á—®) = âŠ¤ := by
  rw [Subgroup.eq_top_iff']
  intro Ï†
  rcases Ï†.reflections_generate_dim with âŸ¨l, _, rflâŸ©
  apply (Subgroup.closure _).list_prod_mem
  intro x hx
  rcases List.mem_map.mp hx with âŸ¨a, _, haxâŸ©
  exact Subgroup.subset_closure âŸ¨a, haxâŸ©

section OrthogonalFamily

open Submodule

variable {Î¹ : Type*}

/-- An orthogonal family of subspaces of `E` satisfies `DirectSum.IsInternal` (that is,
they provide an internal direct sum decomposition of `E`) if and only if their span has trivial
orthogonal complement. -/
theorem OrthogonalFamily.isInternal_iff_of_isComplete [DecidableEq Î¹] {V : Î¹ â†’ Submodule ğ•œ E}
    (hV : OrthogonalFamily ğ•œ (fun i => V i) fun i => (V i).subtypeâ‚—áµ¢)
    (hc : IsComplete (â†‘(iSup V) : Set E)) : DirectSum.IsInternal V â†” (iSup V)á—® = âŠ¥ := by
  haveI : CompleteSpace (â†¥(iSup V)) := hc.completeSpace_coe
  simp only [DirectSum.isInternal_submodule_iff_iSupIndep_and_iSup_eq_top, hV.independent,
    true_and, orthogonal_eq_bot_iff]

/-- An orthogonal family of subspaces of `E` satisfies `DirectSum.IsInternal` (that is,
they provide an internal direct sum decomposition of `E`) if and only if their span has trivial
orthogonal complement. -/
theorem OrthogonalFamily.isInternal_iff [DecidableEq Î¹] [FiniteDimensional ğ•œ E]
    {V : Î¹ â†’ Submodule ğ•œ E} (hV : OrthogonalFamily ğ•œ (fun i => V i) fun i => (V i).subtypeâ‚—áµ¢) :
    DirectSum.IsInternal V â†” (iSup V)á—® = âŠ¥ :=
  haveI := FiniteDimensional.proper_rclike ğ•œ (â†¥(iSup V))
  hV.isInternal_iff_of_isComplete (completeSpace_coe_iff_isComplete.mp inferInstance)

open DirectSum

/-- If `x` lies within an orthogonal family `v`, it can be expressed as a sum of projections. -/
theorem OrthogonalFamily.sum_projection_of_mem_iSup [Fintype Î¹] {V : Î¹ â†’ Submodule ğ•œ E}
    [âˆ€ i, CompleteSpace (V i)] (hV : OrthogonalFamily ğ•œ (fun i => V i) fun i => (V i).subtypeâ‚—áµ¢)
    (x : E) (hx : x âˆˆ iSup V) : (âˆ‘ i, (V i).starProjection x) = x := by
  induction hx using iSup_induction' with
  | mem i x hx =>
    refine
      (Finset.sum_eq_single_of_mem i (Finset.mem_univ _) fun j _ hij => ?_).trans
        (starProjection_eq_self_iff.mpr hx)
    rw [starProjection_apply, orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero,
      Submodule.coe_zero]
    exact hV.isOrtho hij.symm hx
  | zero =>
    simp_rw [map_zero, Finset.sum_const_zero]
  | add x y _ _ hx hy =>
    simp_rw [map_add, Finset.sum_add_distrib]
    exact congr_argâ‚‚ (Â· + Â·) hx hy

/-- If a family of submodules is orthogonal, then the `orthogonalProjection` on a direct sum
is just the coefficient of that direct sum. -/
theorem OrthogonalFamily.projection_directSum_coeAddHom [DecidableEq Î¹] {V : Î¹ â†’ Submodule ğ•œ E}
    (hV : OrthogonalFamily ğ•œ (fun i => V i) fun i => (V i).subtypeâ‚—áµ¢) (x : â¨ i, V i) (i : Î¹)
    [CompleteSpace (V i)] :
    (V i).orthogonalProjection (DirectSum.coeAddMonoidHom V x) = x i := by
  induction x using DirectSum.induction_on with
  | zero => simp
  | of j x =>
    simp_rw [DirectSum.coeAddMonoidHom_of, DirectSum.of]
    -- Porting note: was in the previous `simp_rw`, no longer works
    -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644
    erw [DFinsupp.singleAddHom_apply]
    obtain rfl | hij := Decidable.eq_or_ne i j
    Â· rw [orthogonalProjection_mem_subspace_eq_self, DFinsupp.single_eq_same]
    Â· rw [orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero,
        DFinsupp.single_eq_of_ne hij.symm]
      exact hV.isOrtho hij.symm x.prop
  | add x y hx hy =>
    simp_rw [map_add]
    exact congr_argâ‚‚ (Â· + Â·) hx hy

/-- If a family of submodules is orthogonal and they span the whole space, then the orthogonal
projection provides a means to decompose the space into its submodules.

The projection function is `decompose V x i = (V i).orthogonalProjection x`.

See note [reducible non-instances]. -/
noncomputable abbrev OrthogonalFamily.decomposition
    [DecidableEq Î¹] [Fintype Î¹] {V : Î¹ â†’ Submodule ğ•œ E}
    [âˆ€ i, CompleteSpace (V i)] (hV : OrthogonalFamily ğ•œ (fun i => V i) fun i => (V i).subtypeâ‚—áµ¢)
    (h : iSup V = âŠ¤) : DirectSum.Decomposition V where
  decompose' x := DFinsupp.equivFunOnFintype.symm fun i => (V i).orthogonalProjection x
  left_inv x := by
    dsimp only
    letI := fun i => Classical.decEq (V i)
    rw [DirectSum.coeAddMonoidHom, DirectSum.toAddMonoid, DFinsupp.liftAddHom_apply]
    -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644
    erw [DFinsupp.sumAddHom_apply]; rw [DFinsupp.sum_eq_sum_fintype]
    Â· simp_rw [Equiv.apply_symm_apply, AddSubmonoidClass.coe_subtype]
      exact hV.sum_projection_of_mem_iSup _ ((h.ge :) Submodule.mem_top)
    Â· intro i
      exact map_zero _
  right_inv x := by
    dsimp only
    simp_rw [hV.projection_directSum_coeAddHom, DFinsupp.equivFunOnFintype_symm_coe]

end OrthogonalFamily

section OrthonormalBasis

variable {v : Set E}

open Module Submodule Set

/-- An orthonormal set in an `InnerProductSpace` is maximal, if and only if the orthogonal
complement of its span is empty. -/
theorem maximal_orthonormal_iff_orthogonalComplement_eq_bot (hv : Orthonormal ğ•œ ((â†‘) : v â†’ E)) :
    (âˆ€ u âŠ‡ v, Orthonormal ğ•œ ((â†‘) : u â†’ E) â†’ u = v) â†” (span ğ•œ v)á—® = âŠ¥ := by
  rw [Submodule.eq_bot_iff]
  constructor
  Â· contrapose!
    -- ** direction 1: nonempty orthogonal complement implies nonmaximal
    rintro âŸ¨x, hx', hxâŸ©
    -- take a nonzero vector and normalize it
    let e := (â€–xâ€–â»Â¹ : ğ•œ) â€¢ x
    have he : â€–eâ€– = 1 := by simp [e, norm_smul_inv_norm hx]
    have he' : e âˆˆ (span ğ•œ v)á—® := smul_mem' _ _ hx'
    have he'' : e âˆ‰ v := by
      intro hev
      have : e = 0 := by
        have : e âˆˆ span ğ•œ v âŠ“ (span ğ•œ v)á—® := âŸ¨subset_span hev, he'âŸ©
        simpa [(span ğ•œ v).inf_orthogonal_eq_bot] using this
      have : e â‰  0 := hv.ne_zero âŸ¨e, hevâŸ©
      contradiction
    -- put this together with `v` to provide a candidate orthonormal basis for the whole space
    refine âŸ¨insert e v, v.subset_insert e, âŸ¨?_, ?_âŸ©, (ne_insert_of_notMem v he'').symmâŸ©
    Â· -- show that the elements of `insert e v` have unit length
      rintro âŸ¨a, ha'âŸ©
      rcases eq_or_mem_of_mem_insert ha' with ha | ha
      Â· simp [ha, he]
      Â· exact hv.1 âŸ¨a, haâŸ©
    Â· -- show that the elements of `insert e v` are orthogonal
      have h_end : âˆ€ a âˆˆ v, âŸªa, eâŸ« = 0 := by
        intro a ha
        exact he' a (Submodule.subset_span ha)
      rintro âŸ¨a, ha'âŸ©
      rcases eq_or_mem_of_mem_insert ha' with ha | ha
      Â· rintro âŸ¨b, hb'âŸ© hab'
        have hb : b âˆˆ v := by grind
        rw [inner_eq_zero_symm]
        simpa [ha] using h_end b hb
      rintro âŸ¨b, hb'âŸ© hab'
      rcases eq_or_mem_of_mem_insert hb' with hb | hb
      Â· simpa [hb] using h_end a ha
      have : (âŸ¨a, haâŸ© : v) â‰  âŸ¨b, hbâŸ© := by
        intro hab''
        apply hab'
        simpa using hab''
      exact hv.2 this
  Â· -- ** direction 2: empty orthogonal complement implies maximal
    simp only [Subset.antisymm_iff]
    rintro h u (huv : v âŠ† u) hu
    refine âŸ¨?_, huvâŸ©
    intro x hxu
    refine ((mt (h x)) (hu.ne_zero âŸ¨x, hxuâŸ©)).imp_symm ?_
    intro hxv y hy
    have hxv' : (âŸ¨x, hxuâŸ© : u) âˆ‰ ((â†‘) â»Â¹' v : Set u) := by simp [hxv]
    obtain âŸ¨l, hl, rflâŸ© :
      âˆƒ l âˆˆ supported ğ•œ ğ•œ ((â†‘) â»Â¹' v : Set u), (linearCombination ğ•œ ((â†‘) : u â†’ E)) l = y := by
      rw [â† Finsupp.mem_span_image_iff_linearCombination]
      simp [huv, inter_eq_self_of_subset_right, hy]
    exact hu.inner_finsupp_eq_zero hxv' hl

variable [FiniteDimensional ğ•œ E]

/-- An orthonormal set in a finite-dimensional `InnerProductSpace` is maximal, if and only if it
is a basis. -/
theorem maximal_orthonormal_iff_basis_of_finiteDimensional (hv : Orthonormal ğ•œ ((â†‘) : v â†’ E)) :
    (âˆ€ u âŠ‡ v, Orthonormal ğ•œ ((â†‘) : u â†’ E) â†’ u = v) â†” âˆƒ b : Basis v ğ•œ E, â‡‘b = ((â†‘) : v â†’ E) := by
  haveI := FiniteDimensional.proper_rclike ğ•œ (span ğ•œ v)
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hv]
  rw [Submodule.orthogonal_eq_bot_iff]
  have hv_coe : range ((â†‘) : v â†’ E) = v := by simp
  constructor
  Â· refine fun h => âŸ¨Basis.mk hv.linearIndependent _, Basis.coe_mk _ ?_âŸ©
    convert h.ge
  Â· rintro âŸ¨h, coe_hâŸ©
    rw [â† h.span_eq, coe_h, hv_coe]

end OrthonormalBasis
