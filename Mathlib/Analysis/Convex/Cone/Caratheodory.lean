/-
Copyright (c) 2023 Apurva Nakade. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Apurva Nakade
-/
import Mathlib.Analysis.Convex.Cone.Pointed
import Mathlib.Analysis.Convex.Caratheodory

/-!
# CarathÃ©odory's convexity theorem for convex cones

In this file we prove CarathÃ©odory's convexity theorem for convex cones. CarathÃ©odory's theorem
states that if `x` is in the convex cone generated by a set `s`, then `x` is a convex combination
of linearly independent elements of `s`. This is the replacement of the usual statement of vector
spaces having bases for the setting of convex cones.

The proof follows the proof of CarathÃ©odory's theorem for convex hulls closely.


## Main results

- `toPointedCone_eq_union`: CarathÃ©odory's convexity theorem for convex cones.
- `mem_toPointedCone_iff_eq_pos_convex_span`: A more explicit version of `toPointedCone_eq_union`.

-/


universe u

open Set Finset BigOperators

variable {ğ•œ : Type*} {E : Type u} [LinearOrderedField ğ•œ] [AddCommGroup E] [Module ğ•œ E]
local notation3 "ğ•œâ‰¥0" => {c : ğ•œ // 0 â‰¤ c}

namespace Caratheodory

/-- If `x` is in the cone of some finset `t` whose elements are not linearly-independent,
then it is in the cone of a strict subset of `t`. -/
theorem mem_toPointedCone_erase [DecidableEq E] {t : Finset E}
    (h : Â¬LinearIndependent ğ•œ ((â†‘) : t â†’ E)) {x : E} (hx : x âˆˆ Set.toPointedCone ğ•œ t) :
    âˆƒ y : (â†‘t : Set E), x âˆˆ (â†‘(t.erase y) : Set E).toPointedCone ğ•œ := by
  -- `relationâ‚: âˆ‘ i in t, f i â€¢ i = x`
  replace âŸ¨f, relationâ‚âŸ© := mem_span_finset.1 hx
  simp only [toPointedCone, mem_span_finset, mem_span_finset, coe_sort_coe, coe_mem,
    not_true_eq_false, Subtype.exists, exists_prop]
  by_cases hf : âˆƒ iâ‚€, iâ‚€ âˆˆ t âˆ§ f iâ‚€ = 0
  Â· -- Easy case: some `f iâ‚€ = 0`.
    -- In this case, we can erase `iâ‚€`.
    replace âŸ¨iâ‚€, hiâ‚€t, hfâŸ© := hf
    use iâ‚€, hiâ‚€t, f
    rwa [sum_erase_eq_sub, hf, zero_smul, sub_zero, relationâ‚]
  Â· -- Case: `âˆ€ i, f i â‰  0`
    have _ : âˆ€ i âˆˆ t, 0 < f i := by
      intro i hi
      push_neg at hf
      exact zero_lt_iff.mpr (hf i hi)
    -- `relationâ‚‚: âˆ‘ i : t, g i â€¢ â†‘i = 0`
    -- `hnzero: g c â‰  0`
    replace âŸ¨g, relationâ‚‚, c, hnzeroâŸ© := Fintype.not_linearIndependent_iff.1 h
    -- extend `g` to all of `E`
    let g' := Function.extend Subtype.val g 0
    -- For any `Î»`, `âˆ‘ i in t, (f i + Î» * g i) â€¢ i = x`.
    -- We choose a `Î»` that make one of the coefficient `f i + Î» * g i` while leaving all the other
    -- coefficients non-negative. The choice of `Î»` depends on the signs of the coeffs `g i`.
    obtain (hneg | hpos) := Ne.lt_or_lt hnzero
    Â· -- Case: there is a negative coefficient `g c` in `relationâ‚‚`.
      -- Look at all the negative coefficients in `relationâ‚‚`.
      let s := @Finset.filter _ (fun z => g' z < 0) (fun _ => LinearOrder.decidableLT _ _) t
      -- Choose `Î» = - max (f/g)` where the max is taken over all negative coefficients.
      obtain âŸ¨d, hdâ‚, hdâ‚‚âŸ© := s.exists_max_image (fun z => f z / g' z) <| âŸ¨c, by {
        simpa only [filter_congr_decidable, Subtype.exists, exists_prop, exists_eq_right, not_lt,
          mem_filter, coe_mem, exists_apply_eq_apply, not_true_eq_false, true_and,
          Function.Injective.extend_apply Subtype.val_injective] }âŸ©
      rw [mem_filter] at hdâ‚
      use d, hdâ‚.1
      Â· -- Define new coefficients `k = f + Î» g`
        let k : E â†’ ğ•œâ‰¥0 := fun z => âŸ¨f z - f d / g' d * g' z, by {
        -- First we show that all `k i â‰¥ 0`
        rw [sub_nonneg]
        by_cases hzt : z âˆˆ t
        Â· by_cases hzs : z âˆˆ s
          Â· specialize hdâ‚‚ z hzs
            rw [mem_filter] at hzs
            rwa [â† div_le_iff_of_neg hzs.2]
          Â· rw [mem_filter] at hzs
            push_neg at hzs
            exact le_trans (mul_nonpos_of_nonpos_of_nonneg
              (div_nonpos_of_nonneg_of_nonpos (zero_le <| f d)
                <| le_of_lt hdâ‚.2) (hzs hzt)) <| zero_le (f z)
        Â· have : g' z = 0 := by aesop
          rw [this, mul_zero]
          exact zero_le (f z) }âŸ©
        use k
        rw [sum_erase]
        Â· -- Proof of `âˆ‘ x in t, k x â€¢ x = x`
          simp only [Subtype.exists, exists_prop, exists_eq_right, Nonneg.mk_smul, sub_smul,
            Nonneg.coe_smul, Subtype.exists, exists_prop, exists_eq_right, sum_sub_distrib,
            relationâ‚, Subtype.exists, exists_prop, exists_eq_right, sub_eq_self, mul_smul,
            â† Finset.smul_sum]
          convert smul_zero (f d / g' d)
          rw [â† relationâ‚‚]
          conv_lhs => rw [â† Finset.sum_coe_sort]
          apply Finset.sum_congr rfl ?_
          rintro _ -
          rw [Function.Injective.extend_apply]
          exact Subtype.val_injective
        Â· -- At least one coefficient is 0.
          have : k d = 0 := by
            rw [Nonneg.mk_eq_zero, div_mul_cancel, sub_self]
            exact ne_of_lt hdâ‚.2
          rw [this, zero_smul]
    Â· -- Case: there is a positive coefficient `g c` in `relationâ‚‚`.
      -- Look at all the positive coefficients in `relationâ‚‚`.
      let s := @Finset.filter _ (fun z => 0 < g' z) (fun _ => LinearOrder.decidableLT _ _) t
      -- Choose `Î» = - min (f/g)` where the min is taken over all positive coefficients.
      obtain âŸ¨d, hdâ‚, hdâ‚‚âŸ© := s.exists_min_image (fun z => f z / g' z) <| âŸ¨c, by {
        simpa only [filter_congr_decidable, Subtype.exists, exists_prop, exists_eq_right, not_lt,
          mem_filter, coe_mem, exists_apply_eq_apply, not_true_eq_false, true_and,
          Function.Injective.extend_apply Subtype.val_injective] }âŸ©
      rw [mem_filter] at hdâ‚
      use d, hdâ‚.1
      Â· -- Define new coefficients `k = f + Î» g`
        let k : E â†’ ğ•œâ‰¥0 := fun z => âŸ¨f z - f d / g' d * g' z, by {
        -- First we show that all `k i â‰¥ 0`
        rw [sub_nonneg]
        by_cases hzt : z âˆˆ t
        Â· by_cases hzs : z âˆˆ s
          Â· specialize hdâ‚‚ z hzs
            rw [mem_filter] at hzs
            rwa [â† le_div_iff hzs.2]
          Â· rw [mem_filter] at hzs
            push_neg at hzs
            exact le_trans (mul_nonpos_of_nonneg_of_nonpos
              (div_nonneg (zero_le (f d)) (le_of_lt hdâ‚.2)) (hzs hzt)) <| zero_le (f z)
        Â· have : g' z = 0 := by aesop
          rw [this, mul_zero]
          exact zero_le (f z) }âŸ©
        use k
        rw [sum_erase]
        Â· -- Proof of `âˆ‘ x in t, k x â€¢ x = x`
          simp only [Subtype.exists, exists_prop, exists_eq_right, Nonneg.mk_smul, sub_smul,
            Nonneg.coe_smul, Subtype.exists, exists_prop, exists_eq_right, sum_sub_distrib,
            relationâ‚, Subtype.exists, exists_prop, exists_eq_right, sub_eq_self, mul_smul,
            â† Finset.smul_sum]
          convert smul_zero (f d / g' d)
          rw [â† relationâ‚‚]
          conv_lhs => rw [â† Finset.sum_coe_sort]
          apply Finset.sum_congr rfl ?_
          rintro _ -
          rw [Function.Injective.extend_apply]
          exact Subtype.val_injective
        Â· -- At least one coefficient is 0.
          have : k d = 0 := by
            rw [Nonneg.mk_eq_zero, div_mul_cancel, sub_self]
            exact (ne_of_lt hdâ‚.2).symm
          rw [this, zero_smul]

variable {s : Set E} {x : E} (hx : x âˆˆ toPointedCone ğ•œ s)

/-- Given a point `x` in the convex cone of a set `s`, this is a finite subset of `s` of minimum
cardinality, whose convex cone contains `x`. -/
noncomputable def minCardFinsetOfMemtoPointedCone (hx : x âˆˆ s.toPointedCone ğ•œ) : Finset E :=
  Function.argminOn Finset.card Nat.lt_wfRel.2 { t | â†‘t âŠ† s âˆ§ x âˆˆ (t : Set E).toPointedCone ğ•œ }
    <| by exact Submodule.mem_span_finite_of_mem_span hx

theorem minCardFinsetOftoPointedCone_subseteq : â†‘(minCardFinsetOfMemtoPointedCone hx) âŠ† s :=
  (Function.argminOn_mem _ _ { t : Finset E | â†‘t âŠ† s âˆ§ x âˆˆ (t : Set E).toPointedCone ğ•œ } _).1

theorem mem_minCardFinsetOfMemtoPointedCone :
    x âˆˆ (minCardFinsetOfMemtoPointedCone hx : Set E).toPointedCone ğ•œ  := by
  have hs : Set.Nonempty {(t : Finset E) | (t : Set E) âŠ† s âˆ§ x âˆˆ toPointedCone ğ•œ â†‘t} := by
    exact Submodule.mem_span_finite_of_mem_span hx
  have h := (Function.argminOn_mem Finset.card Nat.lt_wfRel.2
    { t : Finset E | â†‘t âŠ† s âˆ§ x âˆˆ (t : Set E).toPointedCone ğ•œ } hs).2
  -- deterministic timeout if we use `exact` directly instead of the intermediate `have`
  exact h

theorem minCardFinsetOfMemtoPointedCone_card_le_card {t : Finset E} (htâ‚ : â†‘t âŠ† s)
    (htâ‚‚ : x âˆˆ (t : Set E).toPointedCone ğ•œ) : (minCardFinsetOfMemtoPointedCone hx).card â‰¤ t.card :=
  Function.argminOn_le _ _ _ (by exact âŸ¨htâ‚, htâ‚‚âŸ©)

theorem linearIndependent_minCardFinsetOfMemtoPointedCone :
    LinearIndependent ğ•œ ((â†‘) : minCardFinsetOfMemtoPointedCone hx â†’ E) := by
  by_cases h : minCardFinsetOfMemtoPointedCone hx = âˆ…
  Â· rw [h]
    exact linearIndependent_empty_type
  Â· have : 0 < (minCardFinsetOfMemtoPointedCone hx).card := by
      rw [card_pos]
      exact nonempty_of_ne_empty h
    set k := (minCardFinsetOfMemtoPointedCone hx).card - 1 with hk
    have hk : (minCardFinsetOfMemtoPointedCone hx).card = k + 1 := by
      rwa [hk, â† Nat.succ_eq_add_one, â† Nat.pred_eq_sub_one, Nat.succ_pred_eq_of_pos]
    classical
    by_contra h
    obtain âŸ¨p, hpâŸ© := mem_toPointedCone_erase h (mem_minCardFinsetOfMemtoPointedCone hx)
    have contra := minCardFinsetOfMemtoPointedCone_card_le_card hx (Set.Subset.trans
      (Finset.erase_subset (p : E) (minCardFinsetOfMemtoPointedCone hx))
      (minCardFinsetOftoPointedCone_subseteq hx)) hp
    rw [â† not_lt] at contra
    apply contra
    erw [card_erase_of_mem p.2, hk]
    exact lt_add_one _

end Caratheodory

variable {s : Set E}

/-- **CarathÃ©odory's convexity theorem for convex cones** -/

theorem toPointedCone_eq_union : (s.toPointedCone ğ•œ : Set E) =
    â‹ƒ (t : Finset E) (_ : â†‘t âŠ† s) (_ : LinearIndependent ğ•œ ((â†‘) : t â†’ E)),
      (SetLike.coe <| toPointedCone ğ•œ t) := by
  apply Set.Subset.antisymm
  Â· intro x hx
    simp only [exists_prop, Set.mem_iUnion]
    exact âŸ¨Caratheodory.minCardFinsetOfMemtoPointedCone hx,
      Caratheodory.minCardFinsetOftoPointedCone_subseteq hx,
      Caratheodory.linearIndependent_minCardFinsetOfMemtoPointedCone hx,
      Caratheodory.mem_minCardFinsetOfMemtoPointedCone hxâŸ©
  Â· iterate 3 convert Set.iUnion_subset _; intro
    exact Submodule.span_mono â€¹_â€º

/-- A more explicit version of `toPointedCone_eq_union`. -/
theorem mem_toPointedCone_iff_eq_pos_convex_span {x : E} : (x âˆˆ s.toPointedCone ğ•œ) â†”
    âˆƒ (Î¹ : Sort (u + 1)) (_ : Fintype Î¹),
      âˆƒ (z : Î¹ â†’ E) (w : Î¹ â†’ ğ•œ) (_ : Set.range z âŠ† s) (_ : LinearIndependent ğ•œ z)
        (_ : âˆ€ i, 0 < w i), âˆ‘ i, w i â€¢ z i = x := by
  constructor
  Â· rintro hx
    rw [â† SetLike.mem_coe, toPointedCone_eq_union] at hx
    simp only [exists_prop, Set.mem_iUnion] at hx
    obtain âŸ¨t, htâ‚, htâ‚‚, htâ‚ƒâŸ© := hx
    simp_rw [toPointedCone, SetLike.mem_coe, mem_span_finset] at htâ‚ƒ
    replace âŸ¨f, hfâŸ© := htâ‚ƒ
    simp only [exists_prop, exists_and_left]
    let t' := t.filter fun i => f i â‰  0
    refine' âŸ¨t', t'.fintypeCoeSort, Subtype.val, âŸ¨_, _, (fun x => f x), _, _âŸ©âŸ©
    Â· rw [Subtype.range_coe_subtype]
      exact Subset.trans (Finset.filter_subset _ t) htâ‚
    Â· exact @LinearIndependent.mono ğ•œ E _ _ _ t' t (t.filter_subset _) htâ‚‚
    Â· rintro âŸ¨i, hiâŸ©
      rw [mem_filter] at hi
      refine' lt_of_le_of_ne _ _
      Â· exact zero_le (f i)
      Â· symm
        convert hi.2
        exact eq_iff_eq_of_cmp_eq_cmp rfl
    Â· have := @Finset.sum_subset E _ t' t (fun i => (f i) â€¢ i) _ (by aesop) (by aesop)
      conv_rhs => rw [â† hf, â† this, â† Finset.sum_coe_sort]
  Â· rintro âŸ¨Î¹, _, f, c, _, -, hc, sumâŸ©
    rw [mem_span_set']
    let eq := (@Fintype.equivFin Î¹).symm
    lift f to (Î¹ â†’ s)
    Â· aesop
    use (Fintype.card Î¹), fun x => âŸ¨(c âˆ˜ eq) x, le_of_lt <| hc _âŸ©, f âˆ˜ eq
    convert sum
    exact @Equiv.sum_comp (Fin (Fintype.card Î¹)) Î¹ E _ _ _ eq (fun x => c x â€¢ f x)
