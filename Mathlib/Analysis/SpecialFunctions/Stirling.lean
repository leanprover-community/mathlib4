/-
Copyright (c) 2022 Moritz Firsching. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Moritz Firsching, Fabian Kruse, Nikolas Kuhn
-/
import Mathlib.Analysis.PSeries
import Mathlib.Data.Real.Pi.Wallis

#align_import analysis.special_functions.stirling from "leanprover-community/mathlib"@"2c1d8ca2812b64f88992a5294ea3dba144755cd1"

/-!
# Stirling's formula

This file proves Stirling's formula for the factorial.
It states that $n!$ grows asymptotically like $\sqrt{2\pi n}(\frac{n}{e})^n$.

## Proof outline

The proof follows: <https://proofwiki.org/wiki/Stirling%27s_Formula>.

We proceed in two parts.

**Part 1**: We consider the sequence $a_n$ of fractions $\frac{n!}{\sqrt{2n}(\frac{n}{e})^n}$
and prove that this sequence converges to a real, positive number $a$. For this the two main
ingredients are
 - taking the logarithm of the sequence and
 - using the series expansion of $\log(1 + x)$.

**Part 2**: We use the fact that the series defined in part 1 converges against a real number $a$
and prove that $a = \sqrt{\pi}$. Here the main ingredient is the convergence of Wallis' product
formula for `œÄ`.
-/


open scoped Topology Real BigOperators Nat Asymptotics

open Finset Filter Nat Real

namespace Stirling

/-!
 ### Part 1
 https://proofwiki.org/wiki/Stirling%27s_Formula#Part_1
-/


/-- Define `stirlingSeq n` as $\frac{n!}{\sqrt{2n}(\frac{n}{e})^n}$.
Stirling's formula states that this sequence has limit $\sqrt(œÄ)$.
-/
noncomputable def stirlingSeq (n : ‚Ñï) : ‚Ñù :=
  n ! / (Real.sqrt (2 * n) * (n / exp 1) ^ n)
#align stirling.stirling_seq Stirling.stirlingSeq

@[simp]
theorem stirlingSeq_zero : stirlingSeq 0 = 0 := by
  rw [stirlingSeq, cast_zero, mul_zero, Real.sqrt_zero, zero_mul, div_zero]
#align stirling.stirling_seq_zero Stirling.stirlingSeq_zero

@[simp]
theorem stirlingSeq_one : stirlingSeq 1 = exp 1 / Real.sqrt 2 := by
  rw [stirlingSeq, pow_one, factorial_one, cast_one, mul_one, mul_one_div, one_div_div]
#align stirling.stirling_seq_one Stirling.stirlingSeq_one

theorem log_stirlingSeq_formula (n : ‚Ñï) :
    log (stirlingSeq n) = Real.log n ! - 1 / 2 * Real.log (2 * n) - n * log (n / exp 1) := by
  cases n
  ¬∑ simp
  ¬∑ rw [stirlingSeq, log_div, log_mul, sqrt_eq_rpow, log_rpow, Real.log_pow, tsub_tsub]
      <;> positivity
-- Porting note: generalized from `n.succ` to `n`
#align stirling.log_stirling_seq_formula Stirling.log_stirlingSeq_formula‚Çì

/-- The sequence `log (stirlingSeq (m + 1)) - log (stirlingSeq (m + 2))` has the series expansion
   `‚àë 1 / (2 * (k + 1) + 1) * (1 / 2 * (m + 1) + 1)^(2 * (k + 1))`
-/
theorem log_stirlingSeq_diff_hasSum (m : ‚Ñï) :
    HasSum (fun k : ‚Ñï => ‚Üë1 / (‚Üë2 * ‚Üë(k + 1) + ‚Üë1) * (((1:‚Ñù)/(‚Üë2 * ‚Üë(m + 1) + ‚Üë1)) ^ 2) ^ ‚Üë(k + 1))
      (log (stirlingSeq (m + 1)) - log (stirlingSeq (m + 2))) := by
  change HasSum
    ((fun b : ‚Ñï => (1:‚Ñù) / ((2:‚Ñù) * b + (1:‚Ñù)) * (((1:‚Ñù) / (2 * (m + 1 :) + 1)) ^ 2) ^ b) ‚àò succ) _
  refine' (hasSum_nat_add_iff (g := _ - _) -- Porting note: must give implicit arguments
    (f := (fun b : ‚Ñï => ‚Üë1 / (‚Üë2 * b + ‚Üë1) * (((1:‚Ñù) / (2 * ‚Üë(m + 1) + 1)) ^ 2) ^ b)) 1).mpr _
  convert (hasSum_log_one_add_inv <|
    cast_pos.mpr (succ_pos m)).mul_left ((‚Üë(m + 1) : ‚Ñù) + 1 / 2) using 1
  ¬∑ ext k
    rw [‚Üê pow_mul, pow_add]
    push_cast
    field_simp
    ring
  ¬∑ have h : ‚àÄ x ‚â† (0 : ‚Ñù), 1 + x‚Åª¬π = (x + 1) / x := fun x hx ‚Ü¶ by field_simp [hx]
    simp (disch := positivity) only [log_stirlingSeq_formula, log_div, log_mul, log_exp,
      factorial_succ, cast_mul, cast_succ, cast_zero, range_one, sum_singleton, h]
    ring
#align stirling.log_stirling_seq_diff_has_sum Stirling.log_stirlingSeq_diff_hasSum

/-- The sequence `log ‚àò stirlingSeq ‚àò succ` is monotone decreasing -/
theorem log_stirlingSeq'_antitone : Antitone (Real.log ‚àò stirlingSeq ‚àò succ) :=
  antitone_nat_of_succ_le fun n =>
    sub_nonneg.mp <| (log_stirlingSeq_diff_hasSum n).nonneg fun m => by positivity
#align stirling.log_stirling_seq'_antitone Stirling.log_stirlingSeq'_antitone

/-- We have a bound for successive elements in the sequence `log (stirlingSeq k)`.
-/
theorem log_stirlingSeq_diff_le_geo_sum (n : ‚Ñï) :
    log (stirlingSeq (n + 1)) - log (stirlingSeq (n + 2)) ‚â§
      ((1:‚Ñù) / (2 * ‚Üë(n + 1) + 1)) ^ 2 / (‚Üë1 - ((1:‚Ñù) / (2 * ‚Üë(n + 1) + 1)) ^ 2) := by
  have h_nonneg : (0 : ‚Ñù) ‚â§ ((1:‚Ñù) / (2 * ‚Üë(n + 1) + 1)) ^ 2 := sq_nonneg _
  have g : HasSum (fun k : ‚Ñï => (((1:‚Ñù) / (2 * ‚Üë(n + 1) + 1)) ^ 2) ^ ‚Üë(k + 1))
      (((1:‚Ñù) / (2 * ‚Üë(n + 1) + 1)) ^ 2 / (‚Üë1 - ((1:‚Ñù) / (2 * ‚Üë(n + 1) + 1)) ^ 2)) := by
    have := (hasSum_geometric_of_lt_one h_nonneg ?_).mul_left (((1:‚Ñù) / (2 * ‚Üë(n + 1) + 1)) ^ 2)
    ¬∑ simp_rw [‚Üê _root_.pow_succ'] at this
      exact this
    rw [one_div, inv_pow]
    exact inv_lt_one (one_lt_pow ((lt_add_iff_pos_left 1).mpr <| by positivity) two_ne_zero)
  have hab : ‚àÄ k : ‚Ñï, (1:‚Ñù) / (‚Üë2 * ‚Üë(k + 1) + ‚Üë1) * (((1:‚Ñù) / (2 * ‚Üë(n + 1) + 1)) ^ 2) ^ ‚Üë(k + 1) ‚â§
      (((1:‚Ñù) / (2 * ‚Üë(n + 1) + 1)) ^ 2) ^ ‚Üë(k + 1) := by
    refine' fun k => mul_le_of_le_one_left (pow_nonneg h_nonneg ‚Üë(k + 1)) _
    rw [one_div]
    exact inv_le_one (le_add_of_nonneg_left <| by positivity)
  exact hasSum_le hab (log_stirlingSeq_diff_hasSum n) g
#align stirling.log_stirling_seq_diff_le_geo_sum Stirling.log_stirlingSeq_diff_le_geo_sum

-- Adaptation note: after v4.7.0-rc1, there is a performance problem in `field_simp`.
-- (Part of the code was ignoring the `maxDischargeDepth` setting: now that we have to increase it,
-- other paths becomes slow.)
set_option maxHeartbeats 400000 in
/-- We have the bound `log (stirlingSeq n) - log (stirlingSeq (n+1))` ‚â§ 1/(4 n^2)
-/
theorem log_stirlingSeq_sub_log_stirlingSeq_succ (n : ‚Ñï) :
    log (stirlingSeq (n + 1)) - log (stirlingSeq (n + 2)) ‚â§ 1 / (4 * (‚Üë(n + 1):‚Ñù) ^ 2) := by
  have h‚ÇÅ : (0 : ‚Ñù) < ‚Üë4 * ((n:‚Ñù) + 1) ^ 2 := by positivity
  have h‚ÇÉ : (0 : ‚Ñù) < (2 * ((n:‚Ñù) + 1) + 1) ^ 2 := by positivity
  have h‚ÇÇ : (0 : ‚Ñù) < ‚Üë1 - (1 / (2 * ((n:‚Ñù) + 1) + 1)) ^ 2 := by
    rw [‚Üê mul_lt_mul_right h‚ÇÉ]
    have H : ‚Üë0 < (2 * ((n:‚Ñù) + 1) + 1) ^ 2 - 1 := by nlinarith [@cast_nonneg ‚Ñù _ n]
    convert H using 1 <;> field_simp [h‚ÇÉ.ne']
  refine' (log_stirlingSeq_diff_le_geo_sum n).trans _
  push_cast
  rw [div_le_div_iff h‚ÇÇ h‚ÇÅ]
  field_simp [h‚ÇÉ.ne']
  rw [div_le_div_right h‚ÇÉ]
  ring_nf
  norm_cast
  omega
#align stirling.log_stirling_seq_sub_log_stirling_seq_succ Stirling.log_stirlingSeq_sub_log_stirlingSeq_succ

/-- For any `n`, we have `log_stirlingSeq 1 - log_stirlingSeq n ‚â§ 1/4 * ‚àë' 1/k^2`  -/
theorem log_stirlingSeq_bounded_aux :
    ‚àÉ c : ‚Ñù, ‚àÄ n : ‚Ñï, log (stirlingSeq 1) - log (stirlingSeq (n + 1)) ‚â§ c := by
  let d : ‚Ñù := ‚àë' k : ‚Ñï, (1 : ‚Ñù) / (‚Üë(k + 1) : ‚Ñù) ^ 2
  use 1 / 4 * d
  let log_stirlingSeq' : ‚Ñï ‚Üí ‚Ñù := fun k => log (stirlingSeq (k + 1))
  intro n
  have h‚ÇÅ : ‚àÄ k, log_stirlingSeq' k - log_stirlingSeq' (k + 1) ‚â§
      ‚Üë1 / ‚Üë4 * (‚Üë1 / (‚Üë(k + 1):‚Ñù) ^ 2) := by
    intro k; convert log_stirlingSeq_sub_log_stirlingSeq_succ k using 1; field_simp
  have h‚ÇÇ : (‚àë k : ‚Ñï in range n, ‚Üë1 / (‚Üë(k + 1):‚Ñù) ^ 2) ‚â§ d := by
    have := (summable_nat_add_iff 1).mpr <| Real.summable_one_div_nat_pow.mpr one_lt_two
    simp only [rpow_nat_cast] at this
    exact sum_le_tsum (range n) (fun k _ => by positivity) this
  calc
    log (stirlingSeq 1) - log (stirlingSeq (n + 1)) = log_stirlingSeq' 0 - log_stirlingSeq' n :=
      rfl
    _ = ‚àë k in range n, (log_stirlingSeq' k - log_stirlingSeq' (k + 1)) := by
      rw [‚Üê sum_range_sub' log_stirlingSeq' n]
    _ ‚â§ ‚àë k in range n, ‚Üë1 / ‚Üë4 * (‚Üë1 / ‚Üë((k + 1)) ^ 2) := (sum_le_sum fun k _ => h‚ÇÅ k)
    _ = ‚Üë1 / ‚Üë4 * ‚àë k in range n, ‚Üë1 / ‚Üë((k + 1)) ^ 2 := by rw [mul_sum]
    _ ‚â§ 1 / 4 * d := by gcongr
#align stirling.log_stirling_seq_bounded_aux Stirling.log_stirlingSeq_bounded_aux

/-- The sequence `log_stirlingSeq` is bounded below for `n ‚â• 1`. -/
theorem log_stirlingSeq_bounded_by_constant : ‚àÉ c, ‚àÄ n : ‚Ñï, c ‚â§ log (stirlingSeq (n + 1)) := by
  obtain ‚ü®d, h‚ü© := log_stirlingSeq_bounded_aux
  exact ‚ü®log (stirlingSeq 1) - d, fun n => sub_le_comm.mp (h n)‚ü©
#align stirling.log_stirling_seq_bounded_by_constant Stirling.log_stirlingSeq_bounded_by_constant

/-- The sequence `stirlingSeq` is positive for `n > 0`  -/
theorem stirlingSeq'_pos (n : ‚Ñï) : 0 < stirlingSeq (n + 1) := by unfold stirlingSeq; positivity
#align stirling.stirling_seq'_pos Stirling.stirlingSeq'_pos

/-- The sequence `stirlingSeq` has a positive lower bound.
-/
theorem stirlingSeq'_bounded_by_pos_constant : ‚àÉ a, 0 < a ‚àß ‚àÄ n : ‚Ñï, a ‚â§ stirlingSeq (n + 1) := by
  cases' log_stirlingSeq_bounded_by_constant with c h
  refine' ‚ü®exp c, exp_pos _, fun n => _‚ü©
  rw [‚Üê le_log_iff_exp_le (stirlingSeq'_pos n)]
  exact h n
#align stirling.stirling_seq'_bounded_by_pos_constant Stirling.stirlingSeq'_bounded_by_pos_constant

/-- The sequence `stirlingSeq ‚àò succ` is monotone decreasing -/
theorem stirlingSeq'_antitone : Antitone (stirlingSeq ‚àò succ) := fun n m h =>
  (log_le_log_iff (stirlingSeq'_pos m) (stirlingSeq'_pos n)).mp (log_stirlingSeq'_antitone h)
#align stirling.stirling_seq'_antitone Stirling.stirlingSeq'_antitone

/-- The limit `a` of the sequence `stirlingSeq` satisfies `0 < a` -/
theorem stirlingSeq_has_pos_limit_a : ‚àÉ a : ‚Ñù, 0 < a ‚àß Tendsto stirlingSeq atTop (ùìù a) := by
  obtain ‚ü®x, x_pos, hx‚ü© := stirlingSeq'_bounded_by_pos_constant
  have hx' : x ‚àà lowerBounds (Set.range (stirlingSeq ‚àò succ)) := by simpa [lowerBounds] using hx
  refine' ‚ü®_, lt_of_lt_of_le x_pos (le_csInf (Set.range_nonempty _) hx'), _‚ü©
  rw [‚Üê Filter.tendsto_add_atTop_iff_nat 1]
  exact tendsto_atTop_ciInf stirlingSeq'_antitone ‚ü®x, hx'‚ü©
#align stirling.stirling_seq_has_pos_limit_a Stirling.stirlingSeq_has_pos_limit_a

/-!
 ### Part 2
 https://proofwiki.org/wiki/Stirling%27s_Formula#Part_2
-/


/-- The sequence `n / (2 * n + 1)` tends to `1/2` -/
theorem tendsto_self_div_two_mul_self_add_one :
    Tendsto (fun n : ‚Ñï => (n : ‚Ñù) / (2 * n + 1)) atTop (ùìù (1 / 2)) := by
  conv =>
    congr
    ¬∑ skip
    ¬∑ skip
    rw [one_div, ‚Üê add_zero (2 : ‚Ñù)]
  refine' (((tendsto_const_div_atTop_nhds_zero_nat 1).const_add (2 : ‚Ñù)).inv‚ÇÄ
    ((add_zero (2 : ‚Ñù)).symm ‚ñ∏ two_ne_zero)).congr' (eventually_atTop.mpr ‚ü®1, fun n hn => _‚ü©)
  rw [add_div' (1 : ‚Ñù) 2 n (cast_ne_zero.mpr (one_le_iff_ne_zero.mp hn)), inv_div]
#align stirling.tendsto_self_div_two_mul_self_add_one Stirling.tendsto_self_div_two_mul_self_add_one

/-- For any `n ‚â† 0`, we have the identity
`(stirlingSeq n)^4 / (stirlingSeq (2*n))^2 * (n / (2 * n + 1)) = W n`, where `W n` is the
`n`-th partial product of Wallis' formula for `œÄ / 2`. -/
theorem stirlingSeq_pow_four_div_stirlingSeq_pow_two_eq (n : ‚Ñï) (hn : n ‚â† 0) :
    stirlingSeq n ^ 4 / stirlingSeq (2 * n) ^ 2 * (n / (2 * n + 1)) = Wallis.W n := by
  have : 4 = 2 * 2 := by rfl
  rw [stirlingSeq, this, pow_mul, stirlingSeq, Wallis.W_eq_factorial_ratio]
  simp_rw [div_pow, mul_pow]
  rw [sq_sqrt, sq_sqrt]
  any_goals positivity
  field_simp [‚Üê exp_nsmul]
  ring_nf
#align stirling.stirling_seq_pow_four_div_stirling_seq_pow_two_eq Stirling.stirlingSeq_pow_four_div_stirlingSeq_pow_two_eq

/-- Suppose the sequence `stirlingSeq` (defined above) has the limit `a ‚â† 0`.
Then the Wallis sequence `W n` has limit `a^2 / 2`.
-/
theorem second_wallis_limit (a : ‚Ñù) (hane : a ‚â† 0) (ha : Tendsto stirlingSeq atTop (ùìù a)) :
    Tendsto Wallis.W atTop (ùìù (a ^ 2 / 2)) := by
  refine' Tendsto.congr' (eventually_atTop.mpr ‚ü®1, fun n hn =>
    stirlingSeq_pow_four_div_stirlingSeq_pow_two_eq n (one_le_iff_ne_zero.mp hn)‚ü©) _
  have h : a ^ 2 / ‚Üë2 = a ^ 4 / a ^ 2 * (1 / 2) := by
    rw [mul_one_div, ‚Üê mul_one_div (a ^ 4) (a ^ 2), one_div, ‚Üê pow_sub_of_lt a]
    norm_num
  rw [h]
  exact ((ha.pow 4).div ((ha.comp (tendsto_id.const_mul_atTop' two_pos)).pow 2)
    (pow_ne_zero 2 hane)).mul tendsto_self_div_two_mul_self_add_one
#align stirling.second_wallis_limit Stirling.second_wallis_limit

/-- **Stirling's Formula** -/
theorem tendsto_stirlingSeq_sqrt_pi : Tendsto (fun n : ‚Ñï => stirlingSeq n) atTop (ùìù (sqrt œÄ)) := by
  obtain ‚ü®a, hapos, halimit‚ü© := stirlingSeq_has_pos_limit_a
  have hœÄ : œÄ / 2 = a ^ 2 / 2 :=
    tendsto_nhds_unique Wallis.tendsto_W_nhds_pi_div_two (second_wallis_limit a hapos.ne' halimit)
  rwa [(div_left_inj' (two_ne_zero' ‚Ñù)).mp hœÄ, sqrt_sq hapos.le]
#align stirling.tendsto_stirling_seq_sqrt_pi Stirling.tendsto_stirlingSeq_sqrt_pi

/-- **Stirling's Formula**, formulated in terms of `Asymptotics.IsEquivalent`. -/
lemma factorial_isEquivalent_stirling :
    (fun n ‚Ü¶ n ! : ‚Ñï ‚Üí ‚Ñù) ~[atTop] fun n ‚Ü¶ Real.sqrt (2 * n * œÄ) * (n / exp 1) ^ n := by
  refine Asymptotics.isEquivalent_of_tendsto_one ?_ ?_
  ¬∑ filter_upwards [eventually_ne_atTop 0] with n hn h
    exact absurd h (by positivity)
  ¬∑ have : sqrt œÄ ‚â† 0 := by positivity
    nth_rewrite 2 [‚Üê div_self this]
    convert tendsto_stirlingSeq_sqrt_pi.div tendsto_const_nhds this using 1
    ext n
    field_simp [stirlingSeq, mul_right_comm]

end Stirling
