/-
Copyright (c) 2024 Geoffrey Irving. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Geoffrey Irving
-/
import Mathlib.Analysis.Analytic.Composition
import Mathlib.Analysis.Analytic.Constructions
import Mathlib.Analysis.Complex.CauchyIntegral
import Mathlib.Analysis.SpecialFunctions.Complex.LogDeriv

/-!
# Various complex special functions are analytic

`log`, and `cpow` are analytic, since they are differentiable.
-/

open Complex Set
open scoped Topology

variable {E : Type} [NormedAddCommGroup E] [NormedSpace ‚ÑÇ E]
variable {f g : E ‚Üí ‚ÑÇ} {z : ‚ÑÇ} {x : E} {s : Set E}

/-- `log` is analytic away from nonpositive reals -/
theorem analyticAt_clog (m : z ‚àà slitPlane) : AnalyticAt ‚ÑÇ log z := by
  rw [analyticAt_iff_eventually_differentiableAt]
  filter_upwards [isOpen_slitPlane.eventually_mem m]
  intro z m
  exact differentiableAt_id.clog m

/-- `log` is analytic away from nonpositive reals -/
theorem AnalyticAt.clog (fa : AnalyticAt ‚ÑÇ f x) (m : f x ‚àà slitPlane) :
    AnalyticAt ‚ÑÇ (fun z ‚Ü¶ log (f z)) x :=
  (analyticAt_clog m).comp fa

theorem AnalyticWithinAt.clog (fa : AnalyticWithinAt ‚ÑÇ f s x) (m : f x ‚àà slitPlane) :
    AnalyticWithinAt ‚ÑÇ (fun z ‚Ü¶ log (f z)) s x :=
  (analyticAt_clog m).comp_analyticWithinAt fa

/-- `log` is analytic away from nonpositive reals -/
theorem AnalyticOnNhd.clog (fs : AnalyticOnNhd ‚ÑÇ f s) (m : ‚àÄ z ‚àà s, f z ‚àà slitPlane) :
    AnalyticOnNhd ‚ÑÇ (fun z ‚Ü¶ log (f z)) s :=
  fun z n ‚Ü¶ (analyticAt_clog (m z n)).comp (fs z n)

theorem AnalyticOn.clog (fs : AnalyticOn ‚ÑÇ f s) (m : ‚àÄ z ‚àà s, f z ‚àà slitPlane) :
    AnalyticOn ‚ÑÇ (fun z ‚Ü¶ log (f z)) s :=
  fun z n ‚Ü¶ (analyticAt_clog (m z n)).analyticWithinAt.comp (fs z n) m

/-- `f z ^ g z` is analytic if `f z` is not a nonpositive real -/
theorem AnalyticWithinAt.cpow (fa : AnalyticWithinAt ‚ÑÇ f s x) (ga : AnalyticWithinAt ‚ÑÇ g s x)
    (m : f x ‚àà slitPlane) : AnalyticWithinAt ‚ÑÇ (fun z ‚Ü¶ f z ^ g z) s x := by
  have e : (fun z ‚Ü¶ f z ^ g z) =·∂†[ùìù[insert x s] x] fun z ‚Ü¶ exp (log (f z) * g z) := by
    filter_upwards [(fa.continuousWithinAt_insert.eventually_ne (slitPlane_ne_zero m))]
    intro z fz
    simp only [fz, cpow_def, if_false]
  apply AnalyticWithinAt.congr_of_eventuallyEq_insert _ e
  exact ((fa.clog m).mul ga).cexp

/-- `f z ^ g z` is analytic if `f z` is not a nonpositive real -/
theorem AnalyticAt.cpow (fa : AnalyticAt ‚ÑÇ f x) (ga : AnalyticAt ‚ÑÇ g x)
    (m : f x ‚àà slitPlane) : AnalyticAt ‚ÑÇ (fun z ‚Ü¶ f z ^ g z) x := by
  rw [‚Üê analyticWithinAt_univ] at fa ga ‚ä¢
  exact fa.cpow ga m

/-- `f z ^ g z` is analytic if `f z` avoids nonpositive reals -/
theorem AnalyticOn.cpow (fs : AnalyticOn ‚ÑÇ f s) (gs : AnalyticOn ‚ÑÇ g s)
    (m : ‚àÄ z ‚àà s, f z ‚àà slitPlane) : AnalyticOn ‚ÑÇ (fun z ‚Ü¶ f z ^ g z) s :=
  fun z n ‚Ü¶ (fs z n).cpow (gs z n) (m z n)

/-- `f z ^ g z` is analytic if `f z` avoids nonpositive reals -/
theorem AnalyticOnNhd.cpow (fs : AnalyticOnNhd ‚ÑÇ f s) (gs : AnalyticOnNhd ‚ÑÇ g s)
    (m : ‚àÄ z ‚àà s, f z ‚àà slitPlane) : AnalyticOnNhd ‚ÑÇ (fun z ‚Ü¶ f z ^ g z) s :=
  fun z n ‚Ü¶ (fs z n).cpow (gs z n) (m z n)
