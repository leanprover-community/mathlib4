/-
Copyright (c) 2024 Jireh Loreaux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jireh Loreaux
-/
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Isometric
import Mathlib.Analysis.CStarAlgebra.SpecialFunctions.PosPart
import Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.Rpow
import Mathlib.Topology.ApproximateUnit

/-! # Nonnegative contractions in a C‚ãÜ-algebra form an approximate unit

This file shows that the collection of positive contractions (of norm strictly less than one)
in a possibly non-unital C‚ãÜ-algebra form a directed set. The key step uses the continuous functional
calculus applied with the functions `fun x : ‚Ñù‚â•0, 1 - (1 + x)‚Åª¬π` and `fun x : ‚Ñù‚â•0, x * (1 - x)‚Åª¬π`,
which are inverses on the interval `{x : ‚Ñù‚â•0 | x < 1}`.

In addition, this file defines `IsIncreasingApproximateUnit` to be a filter `l` that is an
approximate unit contained in the closed unit ball of nonnegative elements. Every C‚ãÜ-algebra has
a filter generated by the sections `{x | a ‚â§ x} ‚à© closedBall 0 1` for `0 ‚â§ a` and `‚Äña‚Äñ < 1`, and
moreover, this filter is an increasing approximate unit.

## Main declarations

+ `CFC.monotoneOn_one_sub_one_add_inv`: the function `f := fun x : ‚Ñù‚â•0, 1 - (1 + x)‚Åª¬π` is
  *operator monotone* on `Set.Ici (0 : A)` (i.e., `cfc‚Çô f` is monotone on `{x : A | 0 ‚â§ x}`).
+ `Set.InvOn.one_sub_one_add_inv`: the functions `f := fun x : ‚Ñù‚â•0, 1 - (1 + x)‚Åª¬π` and
  `g := fun x : ‚Ñù‚â•0, x * (1 - x)‚Åª¬π` are inverses on `{x : ‚Ñù‚â•0 | x < 1}`.
+ `CStarAlgebra.directedOn_nonneg_ball`: the set `{x : A | 0 ‚â§ x} ‚à© Metric.ball 0 1` is directed.
+ `Filter.IsIncreasingApproximateUnit`: a filter `l` is an *increasing approximate unit* if it is an
  approximate unit contained in the closed unit ball of nonnegative elements.
+ `CStarAlgebra.approximateUnit`: the filter generated by the sections
  `{x | a ‚â§ x} ‚à© closedBall 0 1` for `0 ‚â§ a` with `‚Äña‚Äñ < 1`.
+ `CStarAlgebra.increasingApproximateUnit`: the filter `CStarAlgebra.approximateUnit` is an
  increasing approximate unit.

-/

variable {A : Type*} [NonUnitalCStarAlgebra A]

local notation "œÉ‚Çô" => quasispectrum
local notation "œÉ" => spectrum

open Unitization NNReal CStarAlgebra

variable [PartialOrder A] [StarOrderedRing A]

lemma CFC.monotoneOn_one_sub_one_add_inv :
    MonotoneOn (cfc‚Çô (fun x : ‚Ñù‚â•0 ‚Ü¶ 1 - (1 + x)‚Åª¬π)) (Set.Ici (0 : A)) := by
  intro a ha b hb hab
  simp only [Set.mem_Ici] at ha hb
  rw [‚Üê inr_le_iff .., nnreal_cfc‚Çô_eq_cfc_inr a _, nnreal_cfc‚Çô_eq_cfc_inr b _]
  rw [‚Üê inr_le_iff a b (.of_nonneg ha) (.of_nonneg hb)] at hab
  rw [‚Üê inr_nonneg_iff] at ha hb
  have h_cfc_one_sub (c : A‚Å∫¬π) (hc : 0 ‚â§ c := by cfc_tac) :
      cfc (fun x : ‚Ñù‚â•0 ‚Ü¶ 1 - (1 + x)‚Åª¬π) c = 1 - cfc (¬∑‚Åª¬π : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0) (1 + c) := by
    rw [cfc_tsub _ _ _ (fun x _ ‚Ü¶ by simp) (hg := by fun_prop (disch := intro _ _; positivity)),
      cfc_const_one ‚Ñù‚â•0 c, cfc_comp' (¬∑‚Åª¬π) (1 + ¬∑) c ?_, cfc_add .., cfc_const_one ‚Ñù‚â•0 c,
      cfc_id' ‚Ñù‚â•0 c]
    exact continuousOn_id.inv‚ÇÄ (Set.forall_mem_image.mpr fun x _ ‚Ü¶ by dsimp only [id]; positivity)
  rw [h_cfc_one_sub (a : A‚Å∫¬π), h_cfc_one_sub (b : A‚Å∫¬π)]
  gcongr
  rw [‚Üê CFC.rpow_neg_one_eq_cfc_inv, ‚Üê CFC.rpow_neg_one_eq_cfc_inv]
  exact rpow_neg_one_le_rpow_neg_one (add_nonneg zero_le_one ha) (by gcongr) <|
    isUnit_of_le isUnit_one zero_le_one <| le_add_of_nonneg_right ha

lemma Set.InvOn.one_sub_one_add_inv : Set.InvOn (fun x ‚Ü¶ 1 - (1 + x)‚Åª¬π) (fun x ‚Ü¶ x * (1 - x)‚Åª¬π)
    {x : ‚Ñù‚â•0 | x < 1} {x : ‚Ñù‚â•0 | x < 1} := by
  have : (fun x : ‚Ñù‚â•0 ‚Ü¶ x * (1 + x)‚Åª¬π) = fun x ‚Ü¶ 1 - (1 + x)‚Åª¬π := by
    ext x : 1
    field_simp
    simp [tsub_mul, inv_mul_cancel‚ÇÄ]
  rw [‚Üê this]
  constructor <;> intro x (hx : x < 1)
  ¬∑ have : 0 < 1 - x := tsub_pos_of_lt hx
    field_simp [tsub_add_cancel_of_le hx.le, tsub_tsub_cancel_of_le hx.le]
  ¬∑ field_simp [mul_tsub]

lemma norm_cfc‚Çô_one_sub_one_add_inv_lt_one (a : A) :
    ‚Äñcfc‚Çô (fun x : ‚Ñù‚â•0 ‚Ü¶ 1 - (1 + x)‚Åª¬π) a‚Äñ < 1 :=
  nnnorm_cfc‚Çô_nnreal_lt fun x _ ‚Ü¶ tsub_lt_self zero_lt_one (by positivity)

-- the calls to `fun_prop` with a discharger set off the linter
set_option linter.style.multiGoal false in
lemma CStarAlgebra.directedOn_nonneg_ball :
    DirectedOn (¬∑ ‚â§ ¬∑) ({x : A | 0 ‚â§ x} ‚à© Metric.ball 0 1) := by
  let f : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0 := fun x => 1 - (1 + x)‚Åª¬π
  let g : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0 := fun x => x * (1 - x)‚Åª¬π
  suffices ‚àÄ a b : A, 0 ‚â§ a ‚Üí 0 ‚â§ b ‚Üí ‚Äña‚Äñ < 1 ‚Üí ‚Äñb‚Äñ < 1 ‚Üí
      a ‚â§ cfc‚Çô f (cfc‚Çô g a + cfc‚Çô g b) by
    rintro a ‚ü®(ha‚ÇÅ : 0 ‚â§ a), ha‚ÇÇ‚ü© b ‚ü®(hb‚ÇÅ : 0 ‚â§ b), hb‚ÇÇ‚ü©
    simp only [Metric.mem_ball, dist_zero_right] at ha‚ÇÇ hb‚ÇÇ
    refine ‚ü®cfc‚Çô f (cfc‚Çô g a + cfc‚Çô g b), ‚ü®by simp, ?_‚ü©, ?_, ?_‚ü©
    ¬∑ simpa only [Metric.mem_ball, dist_zero_right] using norm_cfc‚Çô_one_sub_one_add_inv_lt_one _
    ¬∑ exact this a b ha‚ÇÅ hb‚ÇÅ ha‚ÇÇ hb‚ÇÇ
    ¬∑ exact add_comm (cfc‚Çô g a) (cfc‚Çô g b) ‚ñ∏ this b a hb‚ÇÅ ha‚ÇÅ hb‚ÇÇ ha‚ÇÇ
  rintro a b ha‚ÇÅ - ha‚ÇÇ -
  calc
    a = cfc‚Çô (f ‚àò g) a := by
      conv_lhs => rw [‚Üê cfc‚Çô_id ‚Ñù‚â•0 a]
      refine cfc‚Çô_congr (Set.InvOn.one_sub_one_add_inv.1.eqOn.symm.mono fun x hx ‚Ü¶ ?_)
      exact lt_of_le_of_lt (le_nnnorm_of_mem_quasispectrum hx) ha‚ÇÇ
    _ = cfc‚Çô f (cfc‚Çô g a) := by
      rw [cfc‚Çô_comp f g a ?_ (by simp [f, tsub_self]) ?_ (by simp [g]) ha‚ÇÅ]
      ¬∑ fun_prop (disch := intro _ _; positivity)
      ¬∑ have (x) (hx : x ‚àà œÉ‚Çô ‚Ñù‚â•0 a) :  1 - x ‚â† 0 := by
          refine tsub_pos_of_lt ?_ |>.ne'
          exact lt_of_le_of_lt (le_nnnorm_of_mem_quasispectrum hx) ha‚ÇÇ
        fun_prop (disch := assumption)
    _ ‚â§ cfc‚Çô f (cfc‚Çô g a + cfc‚Çô g b) := by
      have hab' : cfc‚Çô g a ‚â§ cfc‚Çô g a + cfc‚Çô g b := le_add_of_nonneg_right cfc‚Çô_nonneg_of_predicate
      exact CFC.monotoneOn_one_sub_one_add_inv cfc‚Çô_nonneg_of_predicate
        (cfc‚Çô_nonneg_of_predicate.trans hab') hab'

section ApproximateUnit

open Metric Filter Topology

/-- An *increasing approximate unit* in a C‚ãÜ-algebra is an approximate unit contained in the
closed unit ball of nonnegative elements. -/
structure Filter.IsIncreasingApproximateUnit (l : Filter A) extends l.IsApproximateUnit : Prop where
  eventually_nonneg : ‚àÄ·∂† x in l, 0 ‚â§ x
  eventually_norm : ‚àÄ·∂† x in l, ‚Äñx‚Äñ ‚â§ 1

namespace Filter.IsIncreasingApproximateUnit

omit [StarOrderedRing A] in
lemma eventually_nnnorm {l : Filter A} (hl : l.IsIncreasingApproximateUnit) :
    ‚àÄ·∂† x in l, ‚Äñx‚Äñ‚Çä ‚â§ 1 :=
  hl.eventually_norm

lemma eventually_isSelfAdjoint {l : Filter A} (hl : l.IsIncreasingApproximateUnit) :
    ‚àÄ·∂† x in l, IsSelfAdjoint x :=
  hl.eventually_nonneg.mp <| .of_forall fun _ ‚Ü¶ IsSelfAdjoint.of_nonneg

lemma eventually_star_eq {l : Filter A} (hl : l.IsIncreasingApproximateUnit) :
    ‚àÄ·∂† x in l, star x = x :=
  hl.eventually_isSelfAdjoint.mp <| .of_forall fun _ ‚Ü¶ IsSelfAdjoint.star_eq

end Filter.IsIncreasingApproximateUnit

namespace CStarAlgebra

open Submodule in
/-- To show that `l` is a one-sided approximate unit for `A`, it suffices to verify it only for
`m : A` with `0 ‚â§ m` and `‚Äñm‚Äñ < 1`. -/
lemma tendsto_mul_right_of_forall_nonneg_tendsto {l : Filter A}
    (h : ‚àÄ m, 0 ‚â§ m ‚Üí ‚Äñm‚Äñ < 1 ‚Üí Tendsto (¬∑ * m) l (ùìù m)) (m : A) :
    Tendsto (¬∑ * m) l (ùìù m) := by
  obtain ‚ü®n, c, x, rfl‚ü© := mem_span_set'.mp <| by
    show m ‚àà span ‚ÑÇ ({x | 0 ‚â§ x} ‚à© ball 0 1)
    simp [span_nonneg_inter_unitBall]
  simp_rw [Finset.mul_sum]
  refine tendsto_finset_sum _ fun i _ ‚Ü¶ ?_
  simp_rw [mul_smul_comm]
  exact tendsto_const_nhds.smul <| h (x i) (x i).2.1 <| by simpa using (x i).2.2

omit [PartialOrder A] in
/-- Multiplication on the left by `m` tends to `ùìù m` if and only if multiplication on the right
does, provided the elements are eventually selfadjoint along the filter `l`. -/
lemma tendsto_mul_left_iff_tendsto_mul_right {l : Filter A} (hl : ‚àÄ·∂† x in l, IsSelfAdjoint x) :
    (‚àÄ m, Tendsto (m * ¬∑) l (ùìù m)) ‚Üî (‚àÄ m, Tendsto (¬∑ * m) l (ùìù m)) := by
  refine ‚ü®fun h m ‚Ü¶ ?_, fun h m ‚Ü¶ ?_‚ü©
  all_goals
    apply (star_star m ‚ñ∏ (continuous_star.tendsto _ |>.comp <| h (star m))).congr'
    filter_upwards [hl] with x hx
    simp [hx.star_eq]

variable (A)

/-- The sections of positive strict contractions form a filter basis. -/
lemma isBasis_nonneg_sections :
    IsBasis (fun x : A ‚Ü¶ 0 ‚â§ x ‚àß ‚Äñx‚Äñ < 1) ({x | ¬∑ ‚â§ x}) where
  nonempty := ‚ü®0, by simp‚ü©
  inter {x y} hx hy := by
    peel directedOn_nonneg_ball x (by simpa) y (by simpa) with z hz
    exact ‚ü®by simpa using hz.1, fun a ha ‚Ü¶ ‚ü®hz.2.1.trans ha, hz.2.2.trans ha‚ü©‚ü©

/-- The canonical approximate unit in a C‚ãÜ-algebra generated by the basis of sets
`{x | a ‚â§ x} ‚à© closedBall 0 1` for `0 ‚â§ a`. See also `CStarAlgebra.hasBasis_approximateUnit`. -/
def approximateUnit : Filter A :=
  (isBasis_nonneg_sections A).filter ‚äì ùìü (closedBall 0 1)

/-- The canonical approximate unit in a C‚ãÜ-algebra has a basis of sets
`{x | a ‚â§ x} ‚à© closedBall 0 1` for `0 ‚â§ a`. -/
lemma hasBasis_approximateUnit :
    (approximateUnit A).HasBasis (fun x : A ‚Ü¶ 0 ‚â§ x ‚àß ‚Äñx‚Äñ < 1) ({x | ¬∑ ‚â§ x} ‚à© closedBall 0 1) :=
  isBasis_nonneg_sections A |>.hasBasis.inf_principal (closedBall 0 1)

/-- This is a common reasoning sequence in C‚ãÜ-algebra theory. If `0 ‚â§ x ‚â§ y ‚â§ 1`, then the norm
of `z - y * z` is controled by the norm of `star z * (1 - x) * z`, which is advantageous because the
latter is nonnegative. This is a key step in establishing the existence of an increasing approximate
unit in general C‚ãÜ-algebras. -/
lemma nnnorm_sub_mul_self_le {A : Type*} [CStarAlgebra A] [PartialOrder A] [StarOrderedRing A]
    {x y : A} (z : A) (hx‚ÇÄ : 0 ‚â§ x) (hy : y ‚àà Set.Icc x 1) {c : ‚Ñù‚â•0}
    (h : ‚Äñstar z * (1 - x) * z‚Äñ‚Çä ‚â§ c ^ 2) :
    ‚Äñz - y * z‚Äñ‚Çä ‚â§ c := by
  nth_rw 1 [‚Üê one_mul z]
  rw [‚Üê sqrt_sq c, le_sqrt_iff_sq_le, ‚Üê sub_mul, sq, ‚Üê CStarRing.nnnorm_star_mul_self]
  simp only [star_mul, star_sub, star_one]
  have hy‚ÇÄ : y ‚àà Set.Icc 0 1 := ‚ü®hx‚ÇÄ.trans hy.1, hy.2‚ü©
  have hy' : 1 - y ‚àà Set.Icc 0 1 := Set.sub_mem_Icc_zero_iff_right.mpr hy‚ÇÄ
  rw [hy‚ÇÄ.1.star_eq, ‚Üê mul_assoc, mul_assoc (star _), ‚Üê sq]
  refine nnnorm_le_nnnorm_of_nonneg_of_le (conjugate_nonneg (pow_nonneg hy'.1 2) _) ?_ |>.trans h
  refine conjugate_le_conjugate ?_ _
  trans (1 - y)
  ¬∑ simpa using pow_antitone hy'.1 hy'.2 one_le_two
  ¬∑ gcongr
    exact hy.1

/-- A variant of `nnnorm_sub_mul_self_le` which uses `‚Äñ¬∑‚Äñ` instead of `‚Äñ¬∑‚Äñ‚Çä`. -/
lemma norm_sub_mul_self_le {A : Type*} [CStarAlgebra A] [PartialOrder A] [StarOrderedRing A]
    {x y : A} (z : A) (hx‚ÇÄ : 0 ‚â§ x) (hy : y ‚àà Set.Icc x 1)
    {c : ‚Ñù} (hc : 0 ‚â§ c) (h : ‚Äñstar z * (1 - x) * z‚Äñ ‚â§ c ^ 2) :
    ‚Äñz - y * z‚Äñ ‚â§ c :=
  nnnorm_sub_mul_self_le z hx‚ÇÄ hy h (c := ‚ü®c, hc‚ü©)

variable {A} in
/-- A variant of `norm_sub_mul_self_le` for non-unital algebras that passes to the unitization. -/
lemma norm_sub_mul_self_le_of_inr {x y : A} (z : A) (hx‚ÇÄ : 0 ‚â§ x) (hxy : x ‚â§ y) (hy‚ÇÅ : ‚Äñy‚Äñ ‚â§ 1)
    {c : ‚Ñù} (hc : 0 ‚â§ c) (h : ‚Äñstar (z : A‚Å∫¬π) * (1 - x) * z‚Äñ ‚â§ c ^ 2) :
    ‚Äñz - y * z‚Äñ ‚â§ c := by
  rw [‚Üê norm_inr (ùïú := ‚ÑÇ), inr_sub, inr_mul]
  refine norm_sub_mul_self_le _ ?_ ?_ hc h
  ¬∑ rwa [inr_nonneg_iff]
  ¬∑ have hy := hx‚ÇÄ.trans hxy
    rw [Set.mem_Icc, inr_le_iff _ _ hx‚ÇÄ.isSelfAdjoint hy.isSelfAdjoint,
      ‚Üê norm_le_one_iff_of_nonneg _, norm_inr]
    exact ‚ü®hxy, hy‚ÇÅ‚ü©

variable {A} in
/-- This shows `CStarAlgebra.approximateUnit` is a one-sided approximate unit, but this is marked
`private` because it is only used to prove `CStarAlgebra.increasingApproximateUnit`. -/
private lemma tendsto_mul_right_approximateUnit (m : A) :
    Tendsto (¬∑ * m) (approximateUnit A) (ùìù m) := by
  refine tendsto_mul_right_of_forall_nonneg_tendsto (fun m hm‚ÇÅ hm‚ÇÇ ‚Ü¶ ?_) m
  rw [(hasBasis_approximateUnit A).tendsto_iff nhds_basis_closedBall]
  intro Œµ hŒµ
  lift Œµ to ‚Ñù‚â•0 using hŒµ.le
  rw [coe_pos] at hŒµ
  refine ‚ü®cfc‚Çô (fun y : ‚Ñù‚â•0 ‚Ü¶ 1 - (1 + y)‚Åª¬π) (Œµ‚Åª¬π ^ 2 ‚Ä¢ m),
    ‚ü®cfc‚Çô_nonneg_of_predicate, norm_cfc‚Çô_one_sub_one_add_inv_lt_one (Œµ‚Åª¬π ^ 2 ‚Ä¢ m)‚ü©, ?_‚ü©
  rintro x ‚ü®(hx‚ÇÅ : _ ‚â§ x), hx‚ÇÇ‚ü©
  simp only [mem_closedBall, dist_eq_norm', zero_sub, norm_neg] at hx‚ÇÇ ‚ä¢
  rw [‚Üê coe_nnnorm, coe_le_coe]
  have hx‚ÇÄ : 0 ‚â§ x := cfc‚Çô_nonneg_of_predicate.trans hx‚ÇÅ
  rw [‚Üê inr_le_iff _ _ (.of_nonneg cfc‚Çô_nonneg_of_predicate) (.of_nonneg hx‚ÇÄ),
    nnreal_cfc‚Çô_eq_cfc_inr _ _ (by simp [tsub_self]), inr_smul] at hx‚ÇÅ
  rw [‚Üê norm_inr (ùïú := ‚ÑÇ)] at hm‚ÇÇ hx‚ÇÇ
  rw [‚Üê inr_nonneg_iff] at hx‚ÇÄ hm‚ÇÅ
  rw [‚Üê nnnorm_inr (ùïú := ‚ÑÇ), inr_sub, inr_mul]
  generalize (x : A‚Å∫¬π) = x, (m : A‚Å∫¬π) = m at *
  set g : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0 := fun y ‚Ü¶ 1 - (1 + y)‚Åª¬π
  have hg : Continuous g := by
    rw [continuous_iff_continuousOn_univ]
    fun_prop (disch := intro _ _; positivity)
  have hg' : ContinuousOn (fun y ‚Ü¶ (1 + Œµ‚Åª¬π ^ 2 ‚Ä¢ y)‚Åª¬π) (spectrum ‚Ñù‚â•0 m) :=
    ContinuousOn.inv‚ÇÄ (by fun_prop) fun _ _ ‚Ü¶ by positivity
  have hx : x ‚àà Set.Icc 0 1 := mem_Icc_iff_norm_le_one.mpr ‚ü®hx‚ÇÄ, hx‚ÇÇ‚ü©
  have hx' : x ‚àà Set.Icc _ 1 := ‚ü®hx‚ÇÅ, hx.2‚ü©
  refine nnnorm_sub_mul_self_le m cfc_nonneg_of_predicate hx' ?_
  suffices star m * (1 - cfc g (Œµ‚Åª¬π ^ 2 ‚Ä¢ m)) * m =
      cfc (fun y : ‚Ñù‚â•0 ‚Ü¶ y * (1 + Œµ‚Åª¬π ^ 2 ‚Ä¢ y)‚Åª¬π * y) m by
    rw [this]
    refine nnnorm_cfc_nnreal_le fun y hy ‚Ü¶ ?_
    field_simp
    calc
      y * Œµ ^ 2 * y / (Œµ ^ 2 + y) ‚â§ Œµ ^ 2 * 1 := by
        rw [mul_div_assoc]
        gcongr
        ¬∑ refine mul_le_of_le_one_left (zero_le _) ?_
          have hm' := hm‚ÇÇ.le
          rw [norm_le_one_iff_of_nonneg m hm‚ÇÅ, ‚Üê cfc_id' ‚Ñù‚â•0 m, ‚Üê cfc_one (R := ‚Ñù‚â•0) m,
            cfc_nnreal_le_iff _ _ _ (QuasispectrumRestricts.nnreal_of_nonneg hm‚ÇÅ)] at hm'
          exact hm' y hy
        ¬∑ exact div_le_one (by positivity) |>.mpr le_add_self
      _ = Œµ ^ 2 := mul_one _
  rw [cfc_mul _ _ m (continuousOn_id' _ |>.mul hg') (continuousOn_id' _),
    cfc_mul _ _ m (continuousOn_id' _) hg', cfc_id' .., hm‚ÇÅ.star_eq]
  congr
  rw [‚Üê cfc_one (R := ‚Ñù‚â•0) m, ‚Üê cfc_comp_smul _ _ _ hg.continuousOn hm‚ÇÅ,
    ‚Üê cfc_tsub _ _ m (by simp [g]) hm‚ÇÅ (by fun_prop) (Continuous.continuousOn <| by fun_prop)]
  refine cfc_congr (fun y _ ‚Ü¶ ?_)
  simp [g, tsub_tsub_cancel_of_le]

/-- The filter `CStarAlgebra.approximateUnit` generated by the sections
`{x | a ‚â§ x} ‚à© closedBall 0 1` for `0 ‚â§ a` forms an increasing approximate unit. -/
lemma increasingApproximateUnit :
    IsIncreasingApproximateUnit (approximateUnit A) where
  tendsto_mul_left := by
    rw [tendsto_mul_left_iff_tendsto_mul_right]
    ¬∑ exact tendsto_mul_right_approximateUnit
    ¬∑ rw [(hasBasis_approximateUnit A).eventually_iff]
      peel (hasBasis_approximateUnit A).ex_mem with x hx
      exact ‚ü®hx, fun y hy ‚Ü¶ (hx.1.trans hy.1).isSelfAdjoint‚ü©
  tendsto_mul_right := tendsto_mul_right_approximateUnit
  eventually_nonneg := .filter_mono inf_le_left <|
    (isBasis_nonneg_sections A).hasBasis.eventually_iff.mpr ‚ü®0, by simp‚ü©
  eventually_norm := .filter_mono inf_le_right <| by simp
  neBot := hasBasis_approximateUnit A |>.neBot_iff.mpr
    fun hx ‚Ü¶ ‚ü®_, ‚ü®le_rfl, by simpa using hx.2.le‚ü©‚ü©

end CStarAlgebra

end ApproximateUnit
