/-
Copyright (c) 2024 Jireh Loreaux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jireh Loreaux
-/
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Isometric
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.PosPart
import Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.Rpow
import Mathlib.Topology.ApproximateUnit

/-! # Nonnegative contractions in a C‚ãÜ-algebra form an approximate unit

This file will shows that the collection of positive contractions (of norm strictly less than one)
in a possibly non-unital C‚ãÜ-algebra form a directed set. The key step uses the continuous functional
calculus applied with the functions `fun x : ‚Ñù‚â•0, 1 - (1 + x)‚Åª¬π` and `fun x : ‚Ñù‚â•0, x * (1 - x)‚Åª¬π`,
which are inverses on the interval `{x : ‚Ñù‚â•0 | x < 1}`.

In addition, this file defines `IsIncreasingApproximateUnit` to be a filter `l` that is an
approximate unit contained in the closed unit ball of nonnegative elements. Every C‚ãÜ-algebra has
a filter generated by the sections `{x | a ‚â§ x} ‚à© closedBall 0 1` for `0 ‚â§ a` and `‚Äña‚Äñ < 1`, and
moreover, this filter is an increasing approximate unit.

## Main declarations

+ `CFC.monotoneOn_one_sub_one_add_inv`: the function `f := fun x : ‚Ñù‚â•0, 1 - (1 + x)‚Åª¬π` is
  *operator monotone* on `Set.Ici (0 : A)` (i.e., `cfc‚Çô f` is monotone on `{x : A | 0 ‚â§ x}`).
+ `Set.InvOn.one_sub_one_add_inv`: the functions `f := fun x : ‚Ñù‚â•0, 1 - (1 + x)‚Åª¬π` and
  `g := fun x : ‚Ñù‚â•0, x * (1 - x)‚Åª¬π` are inverses on `{x : ‚Ñù‚â•0 | x < 1}`.
+ `CStarAlgebra.directedOn_nonneg_ball`: the set `{x : A | 0 ‚â§ x} ‚à© Metric.ball 0 1` is directed.
+ `Filter.IsIncreasingApproximateUnit`: a filter `l` is an *increasing approximate unit* if it is an
  approximate unit contained in the closed unit ball of nonnegative elements.
+ `CStarAlgebra.approximateUnit`: the filter generated by the sections
  `{x | a ‚â§ x} ‚à© closedBall 0 1` for `0 ‚â§ a` with `‚Äña‚Äñ < 1`.
+ `CStarAlgebra.increasingApproximateUnit`: the filter `CStarAlgebra.approximateUnit` is an
  increasing approximate unit.

-/

variable {A : Type*} [NonUnitalCStarAlgebra A]

local notation "œÉ‚Çô" => quasispectrum
local notation "œÉ" => spectrum

open Unitization NNReal CStarAlgebra

variable [PartialOrder A] [StarOrderedRing A]

lemma CFC.monotoneOn_one_sub_one_add_inv :
    MonotoneOn (cfc‚Çô (fun x : ‚Ñù‚â•0 ‚Ü¶ 1 - (1 + x)‚Åª¬π)) (Set.Ici (0 : A)) := by
  intro a ha b hb hab
  simp only [Set.mem_Ici] at ha hb
  rw [‚Üê inr_le_iff .., nnreal_cfc‚Çô_eq_cfc_inr a _, nnreal_cfc‚Çô_eq_cfc_inr b _]
  rw [‚Üê inr_le_iff a b (.of_nonneg ha) (.of_nonneg hb)] at hab
  rw [‚Üê inr_nonneg_iff] at ha hb
  have h_cfc_one_sub (c : A‚Å∫¬π) (hc : 0 ‚â§ c := by cfc_tac) :
      cfc (fun x : ‚Ñù‚â•0 ‚Ü¶ 1 - (1 + x)‚Åª¬π) c = 1 - cfc (¬∑‚Åª¬π : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0) (1 + c) := by
    rw [cfc_tsub _ _ _ (fun x _ ‚Ü¶ by simp) (hg := by fun_prop (disch := intro _ _; positivity)),
      cfc_const_one ‚Ñù‚â•0 c, cfc_comp' (¬∑‚Åª¬π) (1 + ¬∑) c ?_, cfc_add .., cfc_const_one ‚Ñù‚â•0 c,
      cfc_id' ‚Ñù‚â•0 c]
    exact continuousOn_id.inv‚ÇÄ (Set.forall_mem_image.mpr fun x _ ‚Ü¶ by dsimp only [id]; positivity)
  rw [h_cfc_one_sub (a : A‚Å∫¬π), h_cfc_one_sub (b : A‚Å∫¬π)]
  gcongr
  rw [‚Üê CFC.rpow_neg_one_eq_cfc_inv, ‚Üê CFC.rpow_neg_one_eq_cfc_inv]
  exact rpow_neg_one_le_rpow_neg_one (add_nonneg zero_le_one ha) (by gcongr) <|
    isUnit_of_le isUnit_one zero_le_one <| le_add_of_nonneg_right ha

lemma Set.InvOn.one_sub_one_add_inv : Set.InvOn (fun x ‚Ü¶ 1 - (1 + x)‚Åª¬π) (fun x ‚Ü¶ x * (1 - x)‚Åª¬π)
    {x : ‚Ñù‚â•0 | x < 1} {x : ‚Ñù‚â•0 | x < 1} := by
  have : (fun x : ‚Ñù‚â•0 ‚Ü¶ x * (1 + x)‚Åª¬π) = fun x ‚Ü¶ 1 - (1 + x)‚Åª¬π := by
    ext x : 1
    field_simp
    simp [tsub_mul, inv_mul_cancel‚ÇÄ]
  rw [‚Üê this]
  constructor <;> intro x (hx : x < 1)
  ¬∑ have : 0 < 1 - x := tsub_pos_of_lt hx
    field_simp [tsub_add_cancel_of_le hx.le, tsub_tsub_cancel_of_le hx.le]
  ¬∑ field_simp [mul_tsub]

lemma norm_cfc‚Çô_one_sub_one_add_inv_lt_one (a : A) :
    ‚Äñcfc‚Çô (fun x : ‚Ñù‚â•0 ‚Ü¶ 1 - (1 + x)‚Åª¬π) a‚Äñ < 1 :=
  nnnorm_cfc‚Çô_nnreal_lt fun x _ ‚Ü¶ tsub_lt_self zero_lt_one (by positivity)

-- the calls to `fun_prop` with a discharger set off the linter
set_option linter.style.multiGoal false in
lemma CStarAlgebra.directedOn_nonneg_ball :
    DirectedOn (¬∑ ‚â§ ¬∑) ({x : A | 0 ‚â§ x} ‚à© Metric.ball 0 1) := by
  let f : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0 := fun x => 1 - (1 + x)‚Åª¬π
  let g : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0 := fun x => x * (1 - x)‚Åª¬π
  suffices ‚àÄ a b : A, 0 ‚â§ a ‚Üí 0 ‚â§ b ‚Üí ‚Äña‚Äñ < 1 ‚Üí ‚Äñb‚Äñ < 1 ‚Üí
      a ‚â§ cfc‚Çô f (cfc‚Çô g a + cfc‚Çô g b) by
    rintro a ‚ü®(ha‚ÇÅ : 0 ‚â§ a), ha‚ÇÇ‚ü© b ‚ü®(hb‚ÇÅ : 0 ‚â§ b), hb‚ÇÇ‚ü©
    simp only [Metric.mem_ball, dist_zero_right] at ha‚ÇÇ hb‚ÇÇ
    refine ‚ü®cfc‚Çô f (cfc‚Çô g a + cfc‚Çô g b), ‚ü®by simp, ?_‚ü©, ?_, ?_‚ü©
    ¬∑ simpa only [Metric.mem_ball, dist_zero_right] using norm_cfc‚Çô_one_sub_one_add_inv_lt_one _
    ¬∑ exact this a b ha‚ÇÅ hb‚ÇÅ ha‚ÇÇ hb‚ÇÇ
    ¬∑ exact add_comm (cfc‚Çô g a) (cfc‚Çô g b) ‚ñ∏ this b a hb‚ÇÅ ha‚ÇÅ hb‚ÇÇ ha‚ÇÇ
  rintro a b ha‚ÇÅ - ha‚ÇÇ -
  calc
    a = cfc‚Çô (f ‚àò g) a := by
      conv_lhs => rw [‚Üê cfc‚Çô_id ‚Ñù‚â•0 a]
      refine cfc‚Çô_congr (Set.InvOn.one_sub_one_add_inv.1.eqOn.symm.mono fun x hx ‚Ü¶ ?_)
      exact lt_of_le_of_lt (le_nnnorm_of_mem_quasispectrum hx) ha‚ÇÇ
    _ = cfc‚Çô f (cfc‚Çô g a) := by
      rw [cfc‚Çô_comp f g a ?_ (by simp [f, tsub_self]) ?_ (by simp [g]) ha‚ÇÅ]
      ¬∑ fun_prop (disch := intro _ _; positivity)
      ¬∑ have (x) (hx : x ‚àà œÉ‚Çô ‚Ñù‚â•0 a) :  1 - x ‚â† 0 := by
          refine tsub_pos_of_lt ?_ |>.ne'
          exact lt_of_le_of_lt (le_nnnorm_of_mem_quasispectrum hx) ha‚ÇÇ
        fun_prop (disch := assumption)
    _ ‚â§ cfc‚Çô f (cfc‚Çô g a + cfc‚Çô g b) := by
      have hab' : cfc‚Çô g a ‚â§ cfc‚Çô g a + cfc‚Çô g b := le_add_of_nonneg_right cfc‚Çô_nonneg_of_predicate
      exact CFC.monotoneOn_one_sub_one_add_inv cfc‚Çô_nonneg_of_predicate
        (cfc‚Çô_nonneg_of_predicate.trans hab') hab'

section SpanNonneg

open Submodule

/-- A C‚ãÜ-algebra is spanned by nonnegative elements of norm at most `r` -/
lemma CStarAlgebra.span_nonneg_inter_closedBall {r : ‚Ñù} (hr : 0 < r) :
    span ‚ÑÇ ({x : A | 0 ‚â§ x} ‚à© Metric.closedBall 0 r) = ‚ä§ := by
  rw [eq_top_iff, ‚Üê span_nonneg, span_le]
  intro x hx
  obtain (rfl | hx_pos) := eq_zero_or_norm_pos x
  ¬∑ exact zero_mem _
  ¬∑ suffices (r * ‚Äñx‚Äñ‚Åª¬π : ‚ÑÇ)‚Åª¬π ‚Ä¢ ((r * ‚Äñx‚Äñ‚Åª¬π : ‚ÑÇ) ‚Ä¢ x) = x by
      rw [‚Üê this]
      refine smul_mem _ _ (subset_span <| Set.mem_inter ?_ ?_)
      ¬∑ norm_cast
        exact smul_nonneg (by positivity) hx
      ¬∑ simp [mul_smul, norm_smul, abs_of_pos hr, inv_mul_cancel‚ÇÄ hx_pos.ne']
    apply inv_smul_smul‚ÇÄ
    norm_cast
    positivity

/-- A C‚ãÜ-algebra is spanned by nonnegative elements of norm less than `r`. -/
lemma CStarAlgebra.span_nonneg_inter_ball {r : ‚Ñù} (hr : 0 < r) :
    span ‚ÑÇ ({x : A | 0 ‚â§ x} ‚à© Metric.ball 0 r) = ‚ä§ := by
  rw [eq_top_iff, ‚Üê span_nonneg_inter_closedBall (half_pos hr)]
  gcongr
  exact Metric.closedBall_subset_ball <| half_lt_self hr

/-- A C‚ãÜ-algebra is spanned by nonnegative contractions. -/
lemma CStarAlgebra.span_nonneg_inter_unitClosedBall :
    span ‚ÑÇ ({x : A | 0 ‚â§ x} ‚à© Metric.closedBall 0 1) = ‚ä§ :=
  CStarAlgebra.span_nonneg_inter_closedBall zero_lt_one

/-- A C‚ãÜ-algebra is spanned by nonnegative strict contractions. -/
lemma CStarAlgebra.span_nonneg_inter_unitBall :
    span ‚ÑÇ ({x : A | 0 ‚â§ x} ‚à© Metric.ball 0 1) = ‚ä§ :=
  CStarAlgebra.span_nonneg_inter_ball zero_lt_one

end SpanNonneg

section ApproximateUnit

open Metric Filter Topology

/-- An *increasing approximate unit* in a C‚ãÜ-algebra is an approximate unit contained in the
closed unit ball of nonnegative elements. -/
structure Filter.IsIncreasingApproximateUnit (l : Filter A) extends l.IsApproximateUnit : Prop where
  eventually_mem_Icc : ‚àÄ·∂† x in l, 0 ‚â§ x
  eventually_norm : ‚àÄ·∂† x in l, ‚Äñx‚Äñ ‚â§ 1
  disjoint_cobounded := Filter.disjoint_of_disjoint_of_mem subset_rfl.disjoint_compl_right
    (by simpa [Filter.eventually_iff, closedBall] using eventually_norm)
    (Metric.isBounded_closedBall (x := 0) (r := 1)).compl

namespace CStarAlgebra

open Submodule in
/-- To show that `l` is a one-sided approximate unit for `A`, it suffices to verify it only for
`m : A` with `0 ‚â§ m` and `‚Äñm‚Äñ < 1`. -/
lemma tendsto_mul_right_of_forall_nonneg_tendsto {l : Filter A}
    (h : ‚àÄ m, 0 ‚â§ m ‚Üí ‚Äñm‚Äñ < 1 ‚Üí Tendsto (¬∑ * m) l (ùìù m)) (m : A) :
    Tendsto (¬∑ * m) l (ùìù m) := by
  obtain ‚ü®n, c, x, rfl‚ü© := mem_span_set'.mp <| by
    show m ‚àà span ‚ÑÇ ({x | 0 ‚â§ x} ‚à© ball 0 1)
    simp [span_nonneg_inter_unitBall]
  simp_rw [Finset.mul_sum]
  refine tendsto_finset_sum _ fun i _ ‚Ü¶ ?_
  simp_rw [mul_smul_comm]
  exact tendsto_const_nhds.smul <| h (x i) (x i).2.1 <| by simpa using (x i).2.2

omit [PartialOrder A] in
/-- Multiplication on the left by `m` tends to `ùìù m` if and only if multiplication on the right
does, provided the elements are eventually selfadjoint along the filter `l`. -/
lemma tendsto_mul_left_iff_tendsto_mul_right {l : Filter A} (hl : ‚àÄ·∂† x in l, IsSelfAdjoint x) :
    (‚àÄ m, Tendsto (m * ¬∑) l (ùìù m)) ‚Üî (‚àÄ m, Tendsto (¬∑ * m) l (ùìù m)) := by
  refine ‚ü®fun h m ‚Ü¶ ?_, fun h m ‚Ü¶ ?_‚ü©
  all_goals
    apply (star_star m ‚ñ∏ (continuous_star.tendsto _ |>.comp <| h (star m))).congr'
    filter_upwards [hl] with x hx
    simp [hx.star_eq]

variable (A)

/-- The sections of positive strict contractions form a filter basis. -/
lemma isBasis_nonneg_sections :
    IsBasis (fun x : A ‚Ü¶ 0 ‚â§ x ‚àß ‚Äñx‚Äñ < 1) ({x | ¬∑ ‚â§ x}) where
  nonempty := ‚ü®0, by simp‚ü©
  inter {x y} hx hy := by
    peel directedOn_nonneg_ball x (by simpa) y (by simpa) with z hz
    exact ‚ü®by simpa using hz.1, fun a ha ‚Ü¶ ‚ü®hz.2.1.trans ha, hz.2.2.trans ha‚ü©‚ü©

/-- The canonical approximate unit in a C‚ãÜ-algebra generated by the basis of sets
`{x | a ‚â§ x} ‚à© closedBall 0 1` for `0 ‚â§ a`. See also `CStarAlgebra.hasBasis_approximateUnit`. -/
def approximateUnit : Filter A :=
  (isBasis_nonneg_sections A).filter ‚äì ùìü (closedBall 0 1)

/-- The canonical approximate unit in a C‚ãÜ-algebra has a basis of sets
`{x | a ‚â§ x} ‚à© closedBall 0 1` for `0 ‚â§ a`. -/
lemma hasBasis_approximateUnit :
    (approximateUnit A).HasBasis (fun x : A ‚Ü¶ 0 ‚â§ x ‚àß ‚Äñx‚Äñ < 1) ({x | ¬∑ ‚â§ x} ‚à© closedBall 0 1) :=
  isBasis_nonneg_sections A |>.hasBasis.inf_principal (closedBall 0 1)

/-- This is the key norm computation in the proof that `CStarAlgebra.approximateUnit` is
an approximate unit. -/
private theorem tendsto_mul_right_approximateUnit_aux {A : Type*} [CStarAlgebra A]
    [PartialOrder A] [StarOrderedRing A] {Œµ : ‚Ñù‚â•0} (hŒµ : 0 < Œµ) {m x : A} (hm : m ‚àà Set.Icc 0 1)
    (hx : x ‚àà Set.Icc 0 1) (hmx : cfc (fun y : ‚Ñù‚â•0 ‚Ü¶ 1 - (1 + y)‚Åª¬π) (Œµ‚Åª¬π ^ 2 ‚Ä¢ m) ‚â§ x) :
    ‚Äñm - x * m‚Äñ‚Çä ^ 2 ‚â§ Œµ ^ 2 := by
  have hx' := Set.sub_mem_Icc_zero_iff_right.mpr hx
  set g : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0 := fun y ‚Ü¶ 1 - (1 + y)‚Åª¬π
  have hg : Continuous g := by
    rw [continuous_iff_continuousOn_univ]
    fun_prop (disch := intro _ _; positivity)
  have hg' : ContinuousOn (fun y ‚Ü¶ (1 + Œµ‚Åª¬π ^ 2 ‚Ä¢ y)‚Åª¬π) (spectrum ‚Ñù‚â•0 m) :=
    ContinuousOn.inv‚ÇÄ (by fun_prop) fun _ _ ‚Ü¶ by positivity
  calc
    ‚Äñm - x * m‚Äñ‚Çä ^ 2 = ‚Äñstar m * ((1 - x) ^ 2) * m‚Äñ‚Çä := by
      rw [sq, ‚Üê CStarRing.nnnorm_star_mul_self]
      simp [sq, sub_mul, mul_sub, IsSelfAdjoint.star_eq (.of_nonneg hx.1), mul_assoc]
    _ ‚â§ ‚Äñstar m * (1 - cfc g (Œµ‚Åª¬π ^ 2 ‚Ä¢ m)) * m‚Äñ‚Çä := by
      refine nnnorm_le_nnnorm_of_nonneg_of_le (conjugate_nonneg (pow_nonneg hx'.1 2) _) ?_
      refine conjugate_le_conjugate ?_ _
      refine pow_antitone hx'.1 hx'.2 one_le_two |>.trans ?_
      simp only [pow_one]
      gcongr
    _ = ‚Äñcfc (fun y : ‚Ñù‚â•0 ‚Ü¶ y * (1 + Œµ‚Åª¬π ^ 2 ‚Ä¢ y)‚Åª¬π * y) m‚Äñ‚Çä := by
      rw [cfc_mul _ _ m (continuousOn_id' _ |>.mul hg') (continuousOn_id' _),
        cfc_mul _ _ m (continuousOn_id' _) hg', cfc_id' .., IsSelfAdjoint.star_eq (.of_nonneg hm.1)]
      congr
      rw [‚Üê cfc_one (R := ‚Ñù‚â•0) m, ‚Üê cfc_comp_smul _ _ _ hg.continuousOn hm.1,
        ‚Üê cfc_tsub _ _ m (by simp [g]) hm.1 (by fun_prop) (Continuous.continuousOn <| by fun_prop)]
      refine cfc_congr (fun y _ ‚Ü¶ ?_)
      simp [g, tsub_tsub_cancel_of_le]
    _ ‚â§ Œµ ^ 2 := by
      refine nnnorm_cfc_nnreal_le fun y hy ‚Ü¶ ?_
      field_simp
      calc
        y * Œµ ^ 2 * y / (Œµ ^ 2 + y) ‚â§ Œµ ^ 2 * 1 := by
          rw [mul_div_assoc]
          gcongr
          ¬∑ refine mul_le_of_le_one_left (zero_le _) ?_
            have hm' := hm.2
            rw [‚Üê cfc_id' ‚Ñù‚â•0 m, ‚Üê cfc_one (R := ‚Ñù‚â•0) m,
              cfc_nnreal_le_iff _ _ _ (QuasispectrumRestricts.nnreal_of_nonneg hm.1)] at hm'
            exact hm' y hy
          ¬∑ exact div_le_one (by positivity) |>.mpr le_add_self
        _ = Œµ ^ 2 := mul_one _

variable {A} in
/-- This shows `CStarAlgebra.approximateUnit` is a one-sided approximate unit, but this is marked
`private` because it is only used to prove `CStarAlgebra.increasingApproximateUnit`. -/
private lemma tendsto_mul_right_approximateUnit (m : A) :
    Tendsto (¬∑ * m) (approximateUnit A) (ùìù m) := by
  refine tendsto_mul_right_of_forall_nonneg_tendsto (fun m hm‚ÇÅ hm‚ÇÇ ‚Ü¶ ?_) m
  rw [isometry_inr (ùïú := ‚ÑÇ) |>.isClosedEmbedding.tendsto_nhds_iff]
  simp only [Function.comp_def, inr_mul]
  refine tendsto_map'_iff (f := (¬∑ * (m : A‚Å∫¬π))) |>.mp ?_
  rw [(hasBasis_approximateUnit A).map inr |>.tendsto_iff nhds_basis_closedBall]
  intro Œµ hŒµ
  refine ‚ü®cfc‚Çô (fun y : ‚Ñù‚â•0 ‚Ü¶ 1 - (1 + y)‚Åª¬π) (Œµ‚Åª¬π ^ 2 ‚Ä¢ m),
    ‚ü®cfc‚Çô_nonneg_of_predicate, norm_cfc‚Çô_one_sub_one_add_inv_lt_one (Œµ‚Åª¬π ^ 2 ‚Ä¢ m)‚ü©, ?_‚ü©
  rintro - ‚ü®x, ‚ü®(hx‚ÇÅ : _ ‚â§ x), hx‚ÇÇ‚ü©, rfl‚ü©
  simp only [mem_closedBall, dist_eq_norm', zero_sub, norm_neg] at hx‚ÇÇ ‚ä¢
  have hx‚ÇÄ : 0 ‚â§ x := cfc‚Çô_nonneg_of_predicate.trans hx‚ÇÅ
  lift Œµ to ‚Ñù‚â•0 using hŒµ.le
  rw [coe_pos] at hŒµ
  rw [‚Üê NNReal.coe_inv, ‚Üê coe_pow, ‚Üê smul_def, ‚Üê inr_le_iff _ _, nnreal_cfc‚Çô_eq_cfc_inr _ _,
    inr_smul] at hx‚ÇÅ
  rw [‚Üê coe_nnnorm, coe_le_coe, ‚Üê sqrt_sq Œµ, ‚Üê sqrt_sq ‚Äñ_‚Äñ‚Çä, sqrt_le_sqrt]
  rw [‚Üê norm_inr (ùïú := ‚ÑÇ)] at hm‚ÇÇ hx‚ÇÇ
  rw [‚Üê inr_nonneg_iff] at hx‚ÇÄ hm‚ÇÅ
  exact tendsto_mul_right_approximateUnit_aux hŒµ
    ‚ü®hm‚ÇÅ, norm_le_one_iff_of_nonneg (m : A‚Å∫¬π) hm‚ÇÅ |>.mp hm‚ÇÇ.le‚ü©
    ‚ü®hx‚ÇÄ, norm_le_one_iff_of_nonneg (x : A‚Å∫¬π) hx‚ÇÄ |>.mp hx‚ÇÇ‚ü© hx‚ÇÅ

/-- The filter `CStarAlgebra.approximateUnit` generated by the sections
`{x | a ‚â§ x} ‚à© closedBall 0 1` for `0 ‚â§ a` forms an increasing approximate unit. -/
lemma increasingApproximateUnit :
    IsIncreasingApproximateUnit (approximateUnit A) where
  tendsto_mul_left := by
    rw [tendsto_mul_left_iff_tendsto_mul_right]
    ¬∑ exact tendsto_mul_right_approximateUnit
    ¬∑ rw [(hasBasis_approximateUnit A).eventually_iff]
      peel (hasBasis_approximateUnit A).ex_mem with x hx
      exact ‚ü®hx, fun y hy ‚Ü¶ .of_nonneg (hx.1.trans hy.1)‚ü©
  tendsto_mul_right := tendsto_mul_right_approximateUnit
  eventually_mem_Icc := .filter_mono inf_le_left <|
    (isBasis_nonneg_sections A).hasBasis.eventually_iff.mpr ‚ü®0, by simp‚ü©
  eventually_norm := .filter_mono inf_le_right <| by simp
  neBot := hasBasis_approximateUnit A |>.neBot_iff.mpr
    fun hx ‚Ü¶ ‚ü®_, ‚ü®le_rfl, by simpa using hx.2.le‚ü©‚ü©

end CStarAlgebra

end ApproximateUnit
