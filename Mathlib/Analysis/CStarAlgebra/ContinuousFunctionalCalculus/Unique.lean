/-
Copyright (c) 2024 Jireh Loreaux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jireh Loreaux
-/
import Mathlib.Analysis.Complex.Basic
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.NonUnital
import Mathlib.Topology.ContinuousMap.StoneWeierstrass

/-!
# Uniqueness of the continuous functional calculus

Let `s : Set ğ•œ` be compact where `ğ•œ` is either `â„` or `â„‚`. By the Stone-Weierstrass theorem, the
(star) subalgebra generated by polynomial functions on `s` is dense in `C(s, ğ•œ)`. Moreover, this
star subalgebra is generated by `X : ğ•œ[X]` (i.e., `ContinuousMap.restrict s (.id ğ•œ)`) alone.
Consequently, any continuous star `ğ•œ`-algebra homomorphism with domain `C(s, ğ•œ)`, is uniquely
determined by its value on `X : ğ•œ[X]`.

The same is true for `ğ•œ := â„â‰¥0`, so long as the algebra `A` is an `â„`-algebra, which we establish
by upgrading a map `C((s : Set â„â‰¥0), â„â‰¥0) â†’â‹†â‚[â„â‰¥0] A` to `C(((â†‘) '' s : Set â„), â„) â†’â‹†â‚[â„] A` in
the natural way, and then applying the uniqueness for `â„`-algebra homomorphisms.

This is the reason the `ContinuousMap.UniqueHom` class exists in the first place, as
opposed to simply appealing directly to Stone-Weierstrass to prove `StarAlgHom.ext_continuousMap`.
-/

open Topology

section UniqueUnital

section RCLike

variable {ğ•œ A : Type*} [RCLike ğ•œ]

instance (priority := 100) RCLike.instContinuousMapUniqueHom [TopologicalSpace A]
    [T2Space A] [Ring A] [StarRing A] [Algebra ğ•œ A] :
    ContinuousMap.UniqueHom ğ•œ A where
  eq_of_continuous_of_map_id s _ Ï† Ïˆ hÏ† hÏˆ h :=
    ContinuousMap.starAlgHom_ext_map_X hÏ† hÏˆ <| by
      convert h using 1
      all_goals exact congr_arg _ (by ext; simp)

instance Real.instContinuousMapUniqueHom [TopologicalSpace A]
    [T2Space A] [Ring A] [StarRing A] [Algebra â„ A] :
    ContinuousMap.UniqueHom â„ A :=
  inferInstance

instance Complex.instContinuousMapUniqueHom [TopologicalSpace A]
    [T2Space A] [Ring A] [StarRing A] [Algebra â„‚ A] :
    ContinuousMap.UniqueHom â„‚ A :=
  inferInstance

end RCLike

section NNReal
open NNReal

variable {X : Type*} [TopologicalSpace X]

namespace ContinuousMap

/-- This map sends `f : C(X, â„)` to `Real.toNNReal âˆ˜ f`, bundled as a continuous map `C(X, â„â‰¥0)`. -/
noncomputable def toNNReal (f : C(X, â„)) : C(X, â„â‰¥0) := .realToNNReal |>.comp f

@[fun_prop]
lemma continuous_toNNReal : Continuous (toNNReal (X := X)) := continuous_postcomp _

@[simp]
lemma toNNReal_apply (f : C(X, â„)) (x : X) : f.toNNReal x = (f x).toNNReal := rfl

lemma toNNReal_add_add_neg_add_neg_eq (f g : C(X, â„)) :
    (f + g).toNNReal + (-f).toNNReal + (-g).toNNReal =
      (-(f + g)).toNNReal + f.toNNReal + g.toNNReal := by
  ext x
  simp [max_neg_zero, -neg_add_rev]
  abel

lemma toNNReal_mul_add_neg_mul_add_mul_neg_eq (f g : C(X, â„)) :
    (f * g).toNNReal + (-f).toNNReal * g.toNNReal + f.toNNReal * (-g).toNNReal =
      (-(f * g)).toNNReal + f.toNNReal * g.toNNReal + (-f).toNNReal * (-g).toNNReal := by
  ext x
  simp [max_neg_zero, add_mul, mul_add]
  abel

@[simp]
lemma toNNReal_algebraMap (r : â„â‰¥0) :
    (algebraMap â„ C(X, â„) r).toNNReal = algebraMap â„â‰¥0 C(X, â„â‰¥0) r := by
  ext; simp

@[simp]
lemma toNNReal_neg_algebraMap (r : â„â‰¥0) : (- algebraMap â„ C(X, â„) r).toNNReal = 0 := by
  ext; simp

@[simp]
lemma toNNReal_one : (1 : C(X, â„)).toNNReal = 1 := toNNReal_algebraMap 1

@[simp]
lemma toNNReal_neg_one : (-1 : C(X, â„)).toNNReal = 0 := toNNReal_neg_algebraMap 1

end ContinuousMap

variable {A : Type*} [Ring A] [StarRing A] [Algebra â„ A]

namespace StarAlgHom

section IsTopologicalRing

variable [TopologicalSpace A] [IsTopologicalRing A]

/-- Given a star `â„â‰¥0`-algebra homomorphism `Ï†` from `C(X, â„â‰¥0)` into an `â„`-algebra `A`, this is
the unique extension of `Ï†` from `C(X, â„)` to `A` as a star `â„`-algebra homomorphism. -/
@[simps]
noncomputable def realContinuousMapOfNNReal (Ï† : C(X, â„â‰¥0) â†’â‹†â‚[â„â‰¥0] A) :
    C(X, â„) â†’â‹†â‚[â„] A where
  toFun f := Ï† f.toNNReal - Ï† (-f).toNNReal
  map_one' := by simp
  map_zero' := by simp
  map_mul' f g := by
    have := congr(Ï† $(f.toNNReal_mul_add_neg_mul_add_mul_neg_eq g))
    simp only [map_add, map_mul, sub_mul, mul_sub] at this âŠ¢
    rw [â† sub_eq_zero] at this âŠ¢
    convert this using 1
    abel
  map_add' f g := by
    have := congr(Ï† $(f.toNNReal_add_add_neg_add_neg_eq g))
    simp only [map_add] at this âŠ¢
    rw [â† sub_eq_zero] at this âŠ¢
    convert this using 1
    abel
  commutes' r := by
    obtain (hr | hr) := le_total 0 r
    Â· lift r to â„â‰¥0 using hr
      simpa only [ContinuousMap.toNNReal_algebraMap, ContinuousMap.toNNReal_neg_algebraMap,
        map_zero, sub_zero] using AlgHomClass.commutes Ï† r
    Â· rw [â† neg_neg r, â† map_neg, neg_neg (-r)]
      rw [â† neg_nonneg] at hr
      lift -r to â„â‰¥0 using hr with r
      simpa only [map_neg, ContinuousMap.toNNReal_neg_algebraMap, map_zero,
        ContinuousMap.toNNReal_algebraMap, zero_sub, neg_inj] using AlgHomClass.commutes Ï† r
  map_star' f := by simp only [star_trivial, star_sub, â† map_star]

@[fun_prop]
lemma continuous_realContinuousMapOfNNReal (Ï† : C(X, â„â‰¥0) â†’â‹†â‚[â„â‰¥0] A)
    (hÏ† : Continuous Ï†) : Continuous Ï†.realContinuousMapOfNNReal := by
  simp [realContinuousMapOfNNReal]
  fun_prop

end IsTopologicalRing

@[simp high]
lemma realContinuousMapOfNNReal_apply_comp_toReal (Ï† : C(X, â„â‰¥0) â†’â‹†â‚[â„â‰¥0] A)
    (f : C(X, â„â‰¥0)) :
    Ï†.realContinuousMapOfNNReal ((ContinuousMap.mk toReal continuous_coe).comp f) = Ï† f := by
  simp only [realContinuousMapOfNNReal_apply]
  convert_to Ï† f - Ï† 0 = Ï† f using 2
  on_goal -1 => rw [map_zero, sub_zero]
  all_goals
    congr
    ext x
    simp

lemma realContinuousMapOfNNReal_injective :
    Function.Injective (realContinuousMapOfNNReal (X := X) (A := A)) := by
  intro Ï† Ïˆ h
  ext f
  simpa using congr($(h) ((ContinuousMap.mk toReal continuous_coe).comp f))

end StarAlgHom

variable [TopologicalSpace A] [IsTopologicalRing A]

instance NNReal.instContinuousMap.UniqueHom [T2Space A] :
    ContinuousMap.UniqueHom â„â‰¥0 A where
  eq_of_continuous_of_map_id s hs Ï† Ïˆ hÏ† hÏˆ h := by
    let s' : Set â„ := (â†‘) '' s
    let e : s â‰ƒâ‚œ s' :=
      { toFun := Subtype.map (â†‘) (by simp [s'])
        invFun := Subtype.map Real.toNNReal (by simp [s'])
        left_inv := fun _ â†¦ by ext; simp
        right_inv := fun x â†¦ by
          ext
          obtain âŸ¨y, -, hyâŸ© := x.2
          simpa using hy â–¸ NNReal.coe_nonneg y
        continuous_toFun := continuous_coe.subtype_map (by simp [s'])
        continuous_invFun := continuous_real_toNNReal.subtype_map (by simp [s']) }
    have (Î¾ : C(s, â„â‰¥0) â†’â‹†â‚[â„â‰¥0] A) (hÎ¾ : Continuous Î¾) :
        (let Î¾' := Î¾.realContinuousMapOfNNReal.comp <| ContinuousMap.compStarAlgHom' â„ â„ e
        Continuous Î¾' âˆ§ Î¾' (.restrict s' <| .id â„) = Î¾ (.restrict s <| .id â„â‰¥0)) := by
      intro Î¾'
      refine âŸ¨Î¾.continuous_realContinuousMapOfNNReal hÎ¾ |>.comp <|
        ContinuousMap.continuous_precomp _, ?_âŸ©
      exact Î¾.realContinuousMapOfNNReal_apply_comp_toReal (.restrict s <| .id â„â‰¥0)
    obtain âŸ¨hÏ†', hÏ†_idâŸ© := this Ï† hÏ†
    obtain âŸ¨hÏˆ', hÏˆ_idâŸ© := this Ïˆ hÏˆ
    have hs' : CompactSpace s' := e.compactSpace
    have h' := ContinuousMap.UniqueHom.eq_of_continuous_of_map_id s' _ _ hÏ†' hÏˆ'
      (hÏ†_id â–¸ hÏˆ_id â–¸ h)
    have h'' := congr($(h').comp <| ContinuousMap.compStarAlgHom' â„ â„ (e.symm : C(s', s)))
    have : (ContinuousMap.compStarAlgHom' â„ â„ (e : C(s, s'))).comp
        (ContinuousMap.compStarAlgHom' â„ â„ (e.symm : C(s', s))) = StarAlgHom.id _ _ := by
      ext1; simp
    simp only [StarAlgHom.comp_assoc, this, StarAlgHom.comp_id] at h''
    exact StarAlgHom.realContinuousMapOfNNReal_injective h''

end NNReal

end UniqueUnital

section UniqueNonUnital

section RCLike

variable {ğ•œ A : Type*} [RCLike ğ•œ]

open NonUnitalStarAlgebra in
instance RCLike.uniqueNonUnitalContinuousFunctionalCalculus
    [TopologicalSpace A] [T2Space A] [NonUnitalRing A] [StarRing A] [Module ğ•œ A]
    [IsScalarTower ğ•œ A A] [SMulCommClass ğ•œ A A] :
    ContinuousMapZero.UniqueHom ğ•œ A where
  eq_of_continuous_of_map_id s hs h0 Ï† Ïˆ hÏ† hÏˆ h := by
    rw [DFunLike.ext'_iff, â† Set.eqOn_univ, â† (ContinuousMapZero.adjoin_id_dense _).closure_eq]
    refine Set.EqOn.closure (fun f hf â†¦ ?_) hÏ† hÏˆ
    rw [â† NonUnitalStarAlgHom.mem_equalizer]
    apply adjoin_le ?_ hf
    rw [Set.singleton_subset_iff]
    exact h

end RCLike

section NNReal
open NNReal

variable {X : Type*} [TopologicalSpace X] [Zero X]

namespace ContinuousMapZero

/-- This map sends `f : C(X, â„)` to `Real.toNNReal âˆ˜ f`, bundled as a continuous map `C(X, â„â‰¥0)`. -/
noncomputable def toNNReal (f : C(X, â„)â‚€) : C(X, â„â‰¥0)â‚€ := âŸ¨.realToNNReal |>.comp f, by simpâŸ©

@[simp]
lemma toNNReal_apply (f : C(X, â„)â‚€) (x : X) : f.toNNReal x = Real.toNNReal (f x) := rfl

@[fun_prop]
lemma continuous_toNNReal : Continuous (toNNReal (X := X)) := by
  rw [continuous_induced_rng]
  convert_to Continuous (ContinuousMap.toNNReal âˆ˜ ((â†‘) : C(X, â„)â‚€ â†’ C(X, â„))) using 1
  exact ContinuousMap.continuous_postcomp _ |>.comp continuous_induced_dom

lemma toContinuousMapHom_toNNReal (f : C(X, â„)â‚€) :
    (toContinuousMapHom (X := X) (R := â„) f).toNNReal =
      toContinuousMapHom (X := X) (R := â„â‰¥0) f.toNNReal :=
  rfl

@[simp]
lemma toNNReal_smul (r : â„â‰¥0) (f : C(X, â„)â‚€) : (r â€¢ f).toNNReal = r â€¢ f.toNNReal := by
  ext x
  by_cases h : 0 â‰¤ f x
  Â· simpa [max_eq_left h, NNReal.smul_def] using mul_nonneg r.coe_nonneg h
  Â· push_neg at h
    simpa [max_eq_right h.le, NNReal.smul_def]
      using mul_nonpos_of_nonneg_of_nonpos r.coe_nonneg h.le

@[simp]
lemma toNNReal_neg_smul (r : â„â‰¥0) (f : C(X, â„)â‚€) : (-(r â€¢ f)).toNNReal = r â€¢ (-f).toNNReal := by
  rw [NNReal.smul_def, â† smul_neg, â† NNReal.smul_def, toNNReal_smul]

lemma toNNReal_mul_add_neg_mul_add_mul_neg_eq (f g : C(X, â„)â‚€) :
    ((f * g).toNNReal + (-f).toNNReal * g.toNNReal + f.toNNReal * (-g).toNNReal) =
    ((-(f * g)).toNNReal + f.toNNReal * g.toNNReal + (-f).toNNReal * (-g).toNNReal) := by
  apply toContinuousMap_injective
  simpa only [â† toContinuousMapHom_apply, map_add, map_mul, map_neg, toContinuousMapHom_toNNReal]
    using (f : C(X, â„)).toNNReal_mul_add_neg_mul_add_mul_neg_eq g

lemma toNNReal_add_add_neg_add_neg_eq (f g : C(X, â„)â‚€) :
    ((f + g).toNNReal + (-f).toNNReal + (-g).toNNReal) =
      ((-(f + g)).toNNReal + f.toNNReal + g.toNNReal) := by
  apply toContinuousMap_injective
  simpa only [â† toContinuousMapHom_apply, map_add, map_mul, map_neg, toContinuousMapHom_toNNReal]
    using (f : C(X, â„)).toNNReal_add_add_neg_add_neg_eq g

end ContinuousMapZero

variable {A : Type*} [NonUnitalRing A] [StarRing A] [Module â„ A]

namespace NonUnitalStarAlgHom

open ContinuousMapZero

section IsTopologicalRing

variable [TopologicalSpace A] [IsTopologicalRing A]

/-- Given a non-unital star `â„â‰¥0`-algebra homomorphism `Ï†` from `C(X, â„â‰¥0)â‚€` into a non-unital
`â„`-algebra `A`, this is the unique extension of `Ï†` from `C(X, â„)â‚€` to `A` as a non-unital
star `â„`-algebra homomorphism. -/
@[simps]
noncomputable def realContinuousMapZeroOfNNReal (Ï† : C(X, â„â‰¥0)â‚€ â†’â‹†â‚™â‚[â„â‰¥0] A) :
    C(X, â„)â‚€ â†’â‹†â‚™â‚[â„] A where
  toFun f := Ï† f.toNNReal - Ï† (-f).toNNReal
  map_zero' := by simp
  map_mul' f g := by
    have := congr(Ï† $(f.toNNReal_mul_add_neg_mul_add_mul_neg_eq g))
    simp only [map_add, map_mul, sub_mul, mul_sub] at this âŠ¢
    rw [â† sub_eq_zero] at this âŠ¢
    rw [â† this]
    abel
  map_add' f g := by
    have := congr(Ï† $(f.toNNReal_add_add_neg_add_neg_eq g))
    simp only [map_add] at this âŠ¢
    rw [â† sub_eq_zero] at this âŠ¢
    rw [â† this]
    abel
  map_smul' r f := by
    simp only [MonoidHom.id_apply]
    by_cases hr : 0 â‰¤ r
    Â· lift r to â„â‰¥0 using hr
      simp only [â† smul_def, toNNReal_smul, map_smul, toNNReal_neg_smul, smul_sub]
    Â· rw [not_le, â† neg_pos] at hr
      rw [â† neg_smul]
      nth_rw 1 [â† neg_neg r]
      nth_rw 3 [â† neg_neg r]
      lift -r to â„â‰¥0 using hr.le with r
      simp only [neg_smul, â† smul_def, toNNReal_neg_smul, map_smul, toNNReal_smul, smul_sub,
        sub_neg_eq_add]
      rw [sub_eq_add_neg, add_comm]
  map_star' f := by simp only [star_trivial, star_sub, â† map_star]

@[fun_prop]
lemma continuous_realContinuousMapZeroOfNNReal (Ï† : C(X, â„â‰¥0)â‚€ â†’â‹†â‚™â‚[â„â‰¥0] A)
    (hÏ† : Continuous Ï†) : Continuous Ï†.realContinuousMapZeroOfNNReal := by
  simp [realContinuousMapZeroOfNNReal]
  fun_prop

end IsTopologicalRing

@[simp high]
lemma realContinuousMapZeroOfNNReal_apply_comp_toReal (Ï† : C(X, â„â‰¥0)â‚€ â†’â‹†â‚™â‚[â„â‰¥0] A)
    (f : C(X, â„â‰¥0)â‚€) :
    Ï†.realContinuousMapZeroOfNNReal ((ContinuousMapZero.mk âŸ¨toReal, continuous_coeâŸ© rfl).comp f) =
      Ï† f := by
  simp only [realContinuousMapZeroOfNNReal_apply]
  convert_to Ï† f - Ï† 0 = Ï† f using 2
  on_goal -1 => rw [map_zero, sub_zero]
  all_goals
    congr
    ext x
    simp

lemma realContinuousMapZeroOfNNReal_injective :
    Function.Injective (realContinuousMapZeroOfNNReal (X := X) (A := A)) := by
  intro Ï† Ïˆ h
  ext f
  simpa using congr($(h) ((ContinuousMapZero.mk âŸ¨toReal, continuous_coeâŸ© rfl).comp f))

end NonUnitalStarAlgHom

open ContinuousMapZero

instance NNReal.instContinuousMapZero.UniqueHom
    [TopologicalSpace A] [IsTopologicalRing A] [IsScalarTower â„ A A] [SMulCommClass â„ A A]
    [T2Space A] :
    ContinuousMapZero.UniqueHom â„â‰¥0 A where
  eq_of_continuous_of_map_id s hs h0 Ï† Ïˆ hÏ† hÏˆ h := by
    let s' : Set â„ := (â†‘) '' s
    let e : s â‰ƒâ‚œ s' :=
      { toFun := Subtype.map (â†‘) (by simp [s'])
        invFun := Subtype.map Real.toNNReal (by simp [s'])
        left_inv := fun _ â†¦ by ext; simp
        right_inv := fun x â†¦ by
          ext
          obtain âŸ¨y, -, hyâŸ© := x.2
          simpa using hy â–¸ NNReal.coe_nonneg y
        continuous_toFun := continuous_coe.subtype_map (by simp [s'])
        continuous_invFun := continuous_real_toNNReal.subtype_map (by simp [s']) }
    have : Fact (0 âˆˆ s') := âŸ¨0, Fact.out, coe_zeroâŸ©
    have e0 : e 0 = 0 := by ext; simp [e]; rfl
    have e0' : e.symm 0 = 0 := by
      simpa only [Homeomorph.symm_apply_apply] using congr(e.symm $(e0)).symm
    have (Î¾ : C(s, â„â‰¥0)â‚€ â†’â‹†â‚™â‚[â„â‰¥0] A) (hÎ¾ : Continuous Î¾) :
        (let Î¾' := Î¾.realContinuousMapZeroOfNNReal.comp <|
          ContinuousMapZero.nonUnitalStarAlgHom_precomp â„ âŸ¨e, e0âŸ©;
          Continuous Î¾' âˆ§ Î¾' (.id s') = Î¾ (.id s)) := by
      intro Î¾'
      refine âŸ¨Î¾.continuous_realContinuousMapZeroOfNNReal hÎ¾ |>.comp <| ?_, ?_âŸ©
      Â· rw [continuous_induced_rng]
        exact ContinuousMap.continuous_precomp _ |>.comp continuous_induced_dom
      Â· exact Î¾.realContinuousMapZeroOfNNReal_apply_comp_toReal (.id _)
    obtain âŸ¨hÏ†', hÏ†_idâŸ© := this Ï† hÏ†
    obtain âŸ¨hÏˆ', hÏˆ_idâŸ© := this Ïˆ hÏˆ
    have hs' : CompactSpace s' := e.compactSpace
    have : ContinuousMapZero.UniqueHom â„ A := inferInstance
    have h' := ContinuousMapZero.UniqueHom.eq_of_continuous_of_map_id
      s' _ _ hÏ†' hÏˆ' (hÏ†_id â–¸ hÏˆ_id â–¸ h)
    have h'' := congr($(h').comp <|
      ContinuousMapZero.nonUnitalStarAlgHom_precomp â„ âŸ¨(e.symm : C(s', s)), e0'âŸ©)
    have : (ContinuousMapZero.nonUnitalStarAlgHom_precomp â„ âŸ¨(e : C(s, s')), e0âŸ©).comp
        (ContinuousMapZero.nonUnitalStarAlgHom_precomp â„ âŸ¨(e.symm : C(s', s)), e0'âŸ©) =
        NonUnitalStarAlgHom.id _ _ := by
      ext; simp
    simp only [NonUnitalStarAlgHom.comp_assoc, this, NonUnitalStarAlgHom.comp_id] at h''
    exact NonUnitalStarAlgHom.realContinuousMapZeroOfNNReal_injective h''

end NNReal

end UniqueNonUnital

section NonUnitalStarAlgHom

open scoped ContinuousMapZero NonUnitalContinuousFunctionalCalculus

variable {F R S A B : Type*} {p : A â†’ Prop} {q : B â†’ Prop}
  [CommSemiring R] [Nontrivial R] [StarRing R] [MetricSpace R] [IsTopologicalSemiring R]
  [ContinuousStar R] [CommRing S] [Algebra R S]
  [NonUnitalRing A] [StarRing A] [TopologicalSpace A] [Module R A]
  [IsScalarTower R A A] [SMulCommClass R A A]
  [NonUnitalRing B] [StarRing B] [TopologicalSpace B] [Module R B]
  [IsScalarTower R B B] [SMulCommClass R B B]
  [Module S A] [Module S B] [IsScalarTower R S A] [IsScalarTower R S B]
  [NonUnitalContinuousFunctionalCalculus R A p] [NonUnitalContinuousFunctionalCalculus R B q]
  [ContinuousMapZero.UniqueHom R B] [FunLike F A B] [NonUnitalAlgHomClass F S A B]
  [StarHomClass F A B]

include S in
/-- Non-unital star algebra homomorphisms commute with the non-unital continuous functional
calculus. -/
lemma NonUnitalStarAlgHomClass.map_cfcâ‚™ (Ï† : F) (f : R â†’ R) (a : A)
    (hf : ContinuousOn f (quasispectrum R a) := by cfc_cont_tac)
    (hfâ‚€ : f 0 = 0 := by cfc_zero_tac) (hÏ† : Continuous Ï† := by fun_prop) (ha : p a := by cfc_tac)
    (hÏ†a : q (Ï† a) := by cfc_tac) : Ï† (cfcâ‚™ f a) = cfcâ‚™ f (Ï† a) := by
  let Ïˆ : A â†’â‹†â‚™â‚[R] B := (Ï† : A â†’â‹†â‚™â‚[S] B).restrictScalars R
  have : Continuous Ïˆ := hÏ†
  have h_spec := NonUnitalAlgHom.quasispectrum_apply_subset' (R := R) S Ï† a
  have hÏˆa : q (Ïˆ a) := hÏ†a
  let Î¹ : C(quasispectrum R (Ïˆ a), quasispectrum R a)â‚€ :=
    âŸ¨âŸ¨Set.inclusion h_spec, continuous_id.subtype_map h_specâŸ©, rflâŸ©
  suffices Ïˆ.comp (cfcâ‚™Hom ha) =
      (cfcâ‚™Hom hÏˆa).comp (ContinuousMapZero.nonUnitalStarAlgHom_precomp R Î¹) by
    have hf' : ContinuousOn f (quasispectrum R (Ïˆ a)) := hf.mono h_spec
    rw [cfcâ‚™_apply .., cfcâ‚™_apply ..]
    exact DFunLike.congr_fun this _
  refine ContinuousMapZero.UniqueHom.eq_of_continuous_of_map_id _ _ _ ?_ ?_ ?apply_id
  case apply_id =>
    trans cfcâ‚™Hom hÏˆa (.id (quasispectrum R (Ïˆ a)))
    Â· simp [cfcâ‚™Hom_id]
    Â· congr
  all_goals
    simp [ContinuousMapZero.nonUnitalStarAlgHom_precomp]
    fun_prop

/-- Non-unital star algebra homomorphisms commute with the non-unital continuous functional
calculus.  This version is specialized to `A â†’â‹†â‚™â‚[S] B` to allow for dot notation. -/
lemma NonUnitalStarAlgHom.map_cfcâ‚™ (Ï† : A â†’â‹†â‚™â‚[S] B) (f : R â†’ R) (a : A)
    (hf : ContinuousOn f (quasispectrum R a) := by cfc_cont_tac)
    (hfâ‚€ : f 0 = 0 := by cfc_zero_tac) (hÏ† : Continuous Ï† := by fun_prop) (ha : p a := by cfc_tac)
    (hÏ†a : q (Ï† a) := by cfc_tac) : Ï† (cfcâ‚™ f a) = cfcâ‚™ f (Ï† a) :=
  NonUnitalStarAlgHomClass.map_cfcâ‚™ Ï† f a

end NonUnitalStarAlgHom

section StarAlgHom

open scoped ContinuousFunctionalCalculus

variable {F R S A B : Type*} {p : A â†’ Prop} {q : B â†’ Prop}
  [CommSemiring R] [StarRing R] [MetricSpace R] [IsTopologicalSemiring R] [ContinuousStar R]
  [Ring A] [StarRing A] [TopologicalSpace A] [Algebra R A]
  [Ring B] [StarRing B] [TopologicalSpace B] [Algebra R B]
  [CommSemiring S] [Algebra R S] [Algebra S A] [Algebra S B] [IsScalarTower R S A]
  [IsScalarTower R S B] [ContinuousFunctionalCalculus R A p] [ContinuousFunctionalCalculus R B q]
  [ContinuousMap.UniqueHom R B] [FunLike F A B] [AlgHomClass F S A B]
  [StarHomClass F A B]

include S in
/-- Star algebra homomorphisms commute with the continuous functional calculus. -/
lemma StarAlgHomClass.map_cfc (Ï† : F) (f : R â†’ R) (a : A)
    (hf : ContinuousOn f (spectrum R a) := by cfc_cont_tac)
    (hÏ† : Continuous Ï† := by fun_prop) (ha : p a := by cfc_tac) (hÏ†a : q (Ï† a) := by cfc_tac) :
    Ï† (cfc f a) = cfc f (Ï† a) := by
  let Ïˆ : A â†’â‹†â‚[R] B := (Ï† : A â†’â‹†â‚[S] B).restrictScalars R
  have : Continuous Ïˆ := hÏ†
  have h_spec := AlgHom.spectrum_apply_subset Ïˆ a
  have hÏˆa : q (Ïˆ a) := hÏ†a
  let Î¹ : C(spectrum R (Ïˆ a), spectrum R a) :=
    âŸ¨Set.inclusion h_spec, continuous_id.subtype_map h_specâŸ©
  suffices Ïˆ.comp (cfcHom ha) = (cfcHom hÏˆa).comp (ContinuousMap.compStarAlgHom' R R Î¹) by
    have hf' : ContinuousOn f (spectrum R (Ïˆ a)) := hf.mono h_spec
    rw [cfc_apply .., cfc_apply ..]
    congrm($(this) âŸ¨_, hf.restrictâŸ©)
  refine ContinuousMap.UniqueHom.eq_of_continuous_of_map_id _ _ _ ?_ ?_ ?apply_id
  case apply_id =>
    trans cfcHom hÏˆa (.restrict (spectrum R (Ïˆ a)) (.id R))
    Â· simp [cfcHom_id]
    Â· congr
  all_goals
    simp [ContinuousMap.compStarAlgHom']
    fun_prop

/-- Star algebra homomorphisms commute with the continuous functional calculus.
This version is specialized to `A â†’â‹†â‚[S] B` to allow for dot notation. -/
lemma StarAlgHom.map_cfc (Ï† : A â†’â‹†â‚[S] B) (f : R â†’ R) (a : A)
    (hf : ContinuousOn f (spectrum R a) := by cfc_cont_tac) (hÏ† : Continuous Ï† := by fun_prop)
    (ha : p a := by cfc_tac) (hÏ†a : q (Ï† a) := by cfc_tac) :
    Ï† (cfc f a) = cfc f (Ï† a) :=
  StarAlgHomClass.map_cfc Ï† f a

end StarAlgHom
