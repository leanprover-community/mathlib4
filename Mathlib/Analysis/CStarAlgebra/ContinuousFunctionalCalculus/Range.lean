/-
Copyright (c) 2025 Jireh Loreaux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jireh Loreaux
-/
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Instances
import Mathlib.Topology.ContinuousMap.ContinuousSqrt

/-! # Range of the continuous functional calculus

This file contains results about the range of the continuous functional calculus, and
consequences thereof.

# Main results

* `range_cfcHom` and `range_cfcâ‚™Hom`: for `RCLike` scalar rings, the range of the continuous
  functional calculus homomorphism is the elemental subalgebra generated by the given element.
* `range_cfc_nnreal` and `range_cfcâ‚™_nnreal`: over the scalar semiring `â„â‰¥0`, the range of the
  continuous functional calculus consists of the nonnegative elements in the elemental `â„`-algebra
  generated by the given element.
* `Commute.cfc` and `Commute.cfcâ‚™`: an element commutes with `cfc f a` or `cfcâ‚™ f a` if it
  commutes with both `a` and `star a`. Specialized versions for `â„` and `â„â‰¥0` or for
  `IsSelfAdjoint a` which do not require the user to show the element commutes with `star a` are
  provided for convenience.

-/

open Topology

open scoped CStarAlgebra

section Commute

section Unital

section RCLike

variable {ğ•œ A : Type*} {p : A â†’ Prop} [RCLike ğ•œ] [Ring A] [StarRing A] [Algebra ğ•œ A]
variable [TopologicalSpace A] [ContinuousFunctionalCalculus ğ•œ A p] [IsTopologicalRing A] [T2Space A]

open StarAlgebra.elemental in
protected theorem Commute.cfcHom {a b : A} (ha : p a) (hbâ‚ : Commute a b)
    (hbâ‚‚ : Commute (star a) b) (f : C(spectrum ğ•œ a, ğ•œ)) :
    Commute (cfcHom ha f) b := by
  open scoped ContinuousFunctionalCalculus in
  induction f using ContinuousMap.induction_on_of_compact with
  | const r =>
    conv =>
      enter [1, 2]
      equals algebraMap ğ•œ _ r => rfl
    rw [AlgHomClass.commutes]
    exact Algebra.commute_algebraMap_left r b
  | id => rwa [cfcHom_id ha]
  | star_id => rwa [map_star, cfcHom_id]
  | add f g hf hg => rw [map_add]; exact hf.add_left hg
  | mul f g hf hg => rw [map_mul]; exact mul_left hf hg
  | frequently f hf =>
    change cfcHom ha f âˆˆ { x | x * b = b * x}
    rw [â† (isClosed_eq (by fun_prop) (by fun_prop)).closure_eq]
    apply mem_closure_of_frequently_of_tendsto hf
    exact cfcHom_continuous ha |>.tendsto _

protected theorem IsSelfAdjoint.commute_cfcHom {a b : A} (ha : p a)
    (ha' : IsSelfAdjoint a) (hb : Commute a b) (f : C(spectrum ğ•œ a, ğ•œ)) :
    Commute (cfcHom ha f) b :=
  hb.cfcHom ha (ha'.star_eq.symm â–¸ hb) f

/-- An element commutes with `cfc f a` if it commutes with both `a` and `star a`.

If the base ring is `â„` or `â„â‰¥0`, see `Commute.cfc_real` or `Commute.cfc_nnreal` which don't require
the `Commute (star a) b` hypothesis. -/
@[grind â†]
protected theorem Commute.cfc {a b : A} (hbâ‚ : Commute a b)
    (hbâ‚‚ : Commute (star a) b) (f : ğ•œ â†’ ğ•œ) :
    Commute (cfc f a) b :=
  cfc_cases (fun x â†¦ Commute x b) a f (Commute.zero_left _)
    fun hf ha â†¦ hbâ‚.cfcHom ha hbâ‚‚ âŸ¨_, hf.restrictâŸ©

/-- For `a` selfadjoint, an element commutes with `cfc f a` if it commutes with `a`.

If the base ring is `â„` or `â„â‰¥0`, see `Commute.cfc_real` or `Commute.cfc_nnreal` which don't require
the `IsSelfAdjoint` hypothesis on `a` (due to the junk value `cfc f a = 0`). -/
protected theorem IsSelfAdjoint.commute_cfc {a b : A}
    (ha : IsSelfAdjoint a) (hbâ‚ : Commute a b) (f : ğ•œ â†’ ğ•œ) :
    Commute (cfc f a) b :=
  hbâ‚.cfc (ha.star_eq.symm â–¸ hbâ‚) f

end RCLike

section NNReal

open scoped NNReal
variable {A : Type*} [Ring A] [StarRing A] [Algebra â„ A] [TopologicalSpace A]
variable [ContinuousFunctionalCalculus â„ A IsSelfAdjoint] [IsTopologicalRing A] [T2Space A]

/-- A version of `Commute.cfc` or `IsSelfAdjoint.commute_cfc` which does not require any interaction
with `star` when the base ring is `â„`. -/
@[grind â†]
protected theorem Commute.cfc_real {a b : A} (hb : Commute a b) (f : â„ â†’ â„) :
    Commute (cfc f a) b :=
  cfc_cases (fun x â†¦ Commute x b) a f (Commute.zero_left _) fun hf ha â†¦ by
    rw [â† cfc_apply ..]
    exact hb.cfc (ha.star_eq.symm â–¸ hb) _

variable [PartialOrder A] [NonnegSpectrumClass â„ A] [StarOrderedRing A]

/-- A version of `Commute.cfc` or `IsSelfAdjoint.commute_cfc` which does not require any interaction
with `star` when the base ring is `â„â‰¥0`. -/
@[grind â†]
protected theorem Commute.cfc_nnreal {a b : A} (hb : Commute a b) (f : â„â‰¥0 â†’ â„â‰¥0) :
    Commute (cfc f a) b := by
  by_cases ha : 0 â‰¤ a
  Â· rw [cfc_nnreal_eq_real ..]
    exact hb.cfc_real _
  Â· simp [cfc_apply_of_not_predicate a ha]

end NNReal

end Unital

section NonUnital

section RCLike

variable {ğ•œ A : Type*} {p : A â†’ Prop} [RCLike ğ•œ] [NonUnitalRing A] [StarRing A]
variable [Module ğ•œ A] [IsScalarTower ğ•œ A A] [SMulCommClass ğ•œ A A] [TopologicalSpace A]
variable [NonUnitalContinuousFunctionalCalculus ğ•œ A p] [IsTopologicalRing A] [T2Space A]

open ContinuousMapZero

open NonUnitalStarAlgebra.elemental in
protected theorem Commute.cfcâ‚™Hom {a b : A} (ha : p a) (hbâ‚ : Commute a b)
    (hbâ‚‚ : Commute (star a) b) (f : C(quasispectrum ğ•œ a, ğ•œ)â‚€) :
    Commute (cfcâ‚™Hom ha f) b := by
  open scoped NonUnitalContinuousFunctionalCalculus in
  induction f using ContinuousMapZero.induction_on_of_compact with
  | zero => simp
  | smul  r f hf => rw [map_smul]; exact hf.smul_left r
  | id => rwa [cfcâ‚™Hom_id ha]
  | star_id => rwa [map_star, cfcâ‚™Hom_id]
  | add f g hf hg => rw [map_add]; exact hf.add_left hg
  | mul f g hf hg => rw [map_mul]; exact mul_left hf hg
  | frequently f hf =>
    change cfcâ‚™Hom ha f âˆˆ { x | x * b = b * x}
    rw [â† (isClosed_eq (by fun_prop) (by fun_prop)).closure_eq]
    apply mem_closure_of_frequently_of_tendsto hf
    exact cfcâ‚™Hom_continuous ha |>.tendsto _

protected theorem IsSelfAdjoint.commute_cfcâ‚™Hom {a b : A} (ha : p a)
    (ha' : IsSelfAdjoint a) (hb : Commute a b) (f : C(quasispectrum ğ•œ a, ğ•œ)â‚€) :
    Commute (cfcâ‚™Hom ha f) b :=
  hb.cfcâ‚™Hom ha (ha'.star_eq.symm â–¸ hb) f

/-- An element commutes with `cfcâ‚™ f a` if it commutes with both `a` and `star a`.

If the base ring is `â„` or `â„â‰¥0`, see `Commute.cfcâ‚™_real` or `Commute.cfcâ‚™_nnreal` which don't
require the `Commute (star a) b` hypothesis. -/
@[grind â†]
protected theorem Commute.cfcâ‚™ {a b : A} (hbâ‚ : Commute a b)
    (hbâ‚‚ : Commute (star a) b) (f : ğ•œ â†’ ğ•œ) :
    Commute (cfcâ‚™ f a) b :=
  cfcâ‚™_cases (fun x â†¦ Commute x b) a f (Commute.zero_left _)
    fun hf hfâ‚€ ha â†¦ hbâ‚.cfcâ‚™Hom ha hbâ‚‚ âŸ¨âŸ¨_, hf.restrictâŸ©, hfâ‚€âŸ©

/-- For `a` selfadjoint, an element commutes with `cfcâ‚™ f a` if it commutes with `a`.

If the base ring is `â„` or `â„â‰¥0`, see `Commute.cfcâ‚™_real` or `Commute.cfcâ‚™_nnreal` which don't
require the `IsSelfAdjoint` hypothesis on `a` (due to the junk value `cfcâ‚™ f a = 0`). -/
protected theorem IsSelfAdjoint.commute_cfcâ‚™ {a b : A}
    (ha : IsSelfAdjoint a) (hbâ‚ : Commute a b) (f : ğ•œ â†’ ğ•œ) :
    Commute (cfcâ‚™ f a) b :=
  hbâ‚.cfcâ‚™ (ha.star_eq.symm â–¸ hbâ‚) f

end RCLike

section NNReal

open scoped NNReal
variable {A : Type*} [NonUnitalRing A] [StarRing A] [Module â„ A] [IsScalarTower â„ A A]
variable [SMulCommClass â„ A A] [TopologicalSpace A]
variable [NonUnitalContinuousFunctionalCalculus â„ A IsSelfAdjoint] [IsTopologicalRing A] [T2Space A]

/-- A version of `Commute.cfcâ‚™` or `IsSelfAdjoint.commute_cfcâ‚™` which does not require any
interaction with `star` when the base ring is `â„`. -/
@[grind â†]
protected theorem Commute.cfcâ‚™_real {a b : A} (hb : Commute a b) (f : â„ â†’ â„) :
    Commute (cfcâ‚™ f a) b :=
  cfcâ‚™_cases (fun x â†¦ Commute x b) a f (Commute.zero_left _)
    fun hf hf0 ha â†¦ by
      rw [â† cfcâ‚™_apply ..]
      exact hb.cfcâ‚™ (ha.star_eq.symm â–¸ hb) _

variable [PartialOrder A] [NonnegSpectrumClass â„ A] [StarOrderedRing A]

/-- A version of `Commute.cfcâ‚™` or `IsSelfAdjoint.commute_cfcâ‚™` which does not require any
interaction with `star` when the base ring is `â„â‰¥0`. -/
@[grind â†]
protected theorem Commute.cfcâ‚™_nnreal {a b : A} (hb : Commute a b) (f : â„â‰¥0 â†’ â„â‰¥0) :
    Commute (cfcâ‚™ f a) b := by
  by_cases ha : 0 â‰¤ a
  Â· rw [cfcâ‚™_nnreal_eq_real ..]
    exact hb.cfcâ‚™_real _
  Â· simp [cfcâ‚™_apply_of_not_predicate a ha]

end NNReal

end NonUnital

end Commute

section CFCRange

section Unital

theorem range_cfc (R : Type*) {A : Type*} {p : A â†’ Prop} [CommSemiring R] [StarRing R]
    [MetricSpace R] [IsTopologicalSemiring R] [ContinuousStar R] [Ring A] [StarRing A]
    [Algebra R A] [TopologicalSpace A] [StarModule R A] [ContinuousFunctionalCalculus R A p]
    {a : A} (ha : p a) : Set.range (cfc (R := R) Â· a) = (cfcHom ha (R := R)).range := by
  ext
  constructor
  all_goals rintro âŸ¨f, rflâŸ©
  Â· exact cfc_cases _ a f (zero_mem _) fun hf ha â†¦ âŸ¨_, rflâŸ©
  Â· exact âŸ¨Subtype.val.extend f 0, cfcHom_eq_cfc_extend _ ha _ |>.symmâŸ©

section RCLike

variable (ğ•œ : Type*) {A : Type*} {p : A â†’ Prop} [RCLike ğ•œ] [Ring A] [StarRing A] [Algebra ğ•œ A]
variable [TopologicalSpace A] [StarModule ğ•œ A] [ContinuousFunctionalCalculus ğ•œ A p]
variable [IsTopologicalRing A] [ContinuousStar A]

open StarAlgebra

open scoped ContinuousFunctionalCalculus in
theorem range_cfcHom {a : A} (ha : p a) :
    (cfcHom ha (R := ğ•œ)).range = elemental ğ•œ a := by
  rw [StarAlgHom.range_eq_map_top, â† ContinuousMap.elemental_id_eq_top, StarAlgebra.elemental,
    â† StarSubalgebra.topologicalClosure_map _ _ (cfcHom_isClosedEmbedding ha (R := ğ•œ)).isClosedMap
      (cfcHom_continuous ha), StarAlgHom.map_adjoin]
  congr
  simpa using cfcHom_id ha

variable {ğ•œ}

theorem cfcHom_apply_mem_elemental {a : A} (ha : p a) (f : C(spectrum ğ•œ a, ğ•œ)) :
    cfcHom ha f âˆˆ elemental ğ•œ a :=
  range_cfcHom ğ•œ ha â–¸ âŸ¨f, rflâŸ©

@[simp, grind â†]
theorem cfc_apply_mem_elemental (f : ğ•œ â†’ ğ•œ) (a : A) :
    cfc f a âˆˆ elemental ğ•œ a :=
  cfc_cases _ a f (zero_mem _) fun hf ha â†¦
    cfcHom_apply_mem_elemental ha âŸ¨_, hf.restrictâŸ©

end RCLike

open scoped NNReal
variable {A : Type*} [Ring A] [StarRing A] [Algebra â„ A] [TopologicalSpace A]
variable [ContinuousFunctionalCalculus â„ A IsSelfAdjoint] [IsTopologicalRing A] [T2Space A]
variable [PartialOrder A] [NonnegSpectrumClass â„ A] [StarOrderedRing A]

lemma range_cfc_nnreal_eq_image_cfc_real (a : A) (ha : 0 â‰¤ a) :
    Set.range (cfc (R := â„â‰¥0) Â· a) = (cfc Â· a) '' {f | âˆ€ x âˆˆ spectrum â„ a, 0 â‰¤ f x} := by
  ext
  constructor
  Â· rintro âŸ¨f, rflâŸ©
    simp only [cfc_nnreal_eq_real f a ha]
    exact âŸ¨_, fun _ _ â†¦ by positivity, rflâŸ©
  Â· rintro âŸ¨f, hf, rflâŸ©
    simp only [cfc_real_eq_nnreal a hf]
    exact âŸ¨_, rflâŸ©

variable [ContinuousStar A] [StarModule â„ A]

lemma range_cfc_nnreal (a : A) (ha : 0 â‰¤ a) :
    Set.range (cfc (R := â„â‰¥0) Â· a) = {x | x âˆˆ StarAlgebra.elemental â„ a âˆ§ 0 â‰¤ x} := by
  rw [range_cfc_nnreal_eq_image_cfc_real a ha, Set.setOf_and, SetLike.setOf_mem_eq,
    â† range_cfcHom _ ha.isSelfAdjoint, â† range_cfc, Set.inter_comm,
    â† Set.image_preimage_eq_inter_range]
  refine Set.Subset.antisymm (Set.image_mono (fun _ â†¦ cfc_nonneg)) ?_
  rintro _ âŸ¨f, hf, rflâŸ©
  simp only [Set.preimage_setOf_eq, Set.mem_setOf_eq, Set.mem_image] at hf âŠ¢
  obtain (âŸ¨hâ‚, hâ‚‚âŸ© | h | h) := by
    simpa only [not_and_or] using em (ContinuousOn f (spectrum â„ a) âˆ§ IsSelfAdjoint a)
  Â· refine âŸ¨f, ?_, rflâŸ©
    rwa [cfc_nonneg_iff f a] at hf
  Â· exact âŸ¨0, by simp, by simp [cfc_apply_of_not_continuousOn a h]âŸ©
  Â· exact âŸ¨0, by simp, by simp [cfc_apply_of_not_predicate a h]âŸ©

end Unital

section NonUnital

theorem range_cfcâ‚™ (R : Type*) {A : Type*} {p : A â†’ Prop} [CommSemiring R] [StarRing R]
    [MetricSpace R] [IsTopologicalSemiring R] [ContinuousStar R] [Nontrivial R] [NonUnitalRing A]
    [StarRing A] [Module R A] [IsScalarTower R A A] [SMulCommClass R A A] [TopologicalSpace A]
    [NonUnitalContinuousFunctionalCalculus R A p] {a : A} (ha : p a) :
    Set.range (cfcâ‚™ (R := R) Â· a) = NonUnitalStarAlgHom.range (cfcâ‚™Hom ha (R := R)) := by
  ext
  constructor
  all_goals rintro âŸ¨f, rflâŸ©
  Â· exact cfcâ‚™_cases _ a f (zero_mem _) fun hf hfâ‚€ ha â†¦ âŸ¨_, rflâŸ©
  Â· exact âŸ¨Subtype.val.extend f 0, cfcâ‚™Hom_eq_cfcâ‚™_extend _ ha _ |>.symmâŸ©

section RCLike

variable (ğ•œ : Type*) {A : Type*} {p : A â†’ Prop} [RCLike ğ•œ] [NonUnitalRing A] [StarRing A]
variable [Module ğ•œ A] [IsScalarTower ğ•œ A A] [SMulCommClass ğ•œ A A]
variable [TopologicalSpace A] [NonUnitalContinuousFunctionalCalculus ğ•œ A p]
variable [ContinuousConstSMul ğ•œ A] [StarModule ğ•œ A] [IsTopologicalRing A] [ContinuousStar A]

open NonUnitalStarAlgebra

open scoped NonUnitalContinuousFunctionalCalculus in
theorem range_cfcâ‚™Hom {a : A} (ha : p a) :
    NonUnitalStarAlgHom.range (cfcâ‚™Hom ha (R := ğ•œ)) = elemental ğ•œ a := by
  rw [â† NonUnitalStarAlgebra.map_top, â† ContinuousMapZero.elemental_eq_top,
    NonUnitalStarAlgebra.elemental, â† NonUnitalStarSubalgebra.topologicalClosure_map _
    (cfcâ‚™Hom_isClosedEmbedding ha (R := ğ•œ)).isClosedMap (cfcâ‚™Hom_continuous ha),
    NonUnitalStarAlgHom.map_adjoin]
  congr
  simpa using cfcâ‚™Hom_id ha

variable {ğ•œ}

open scoped ContinuousMapZero

theorem cfcâ‚™Hom_apply_mem_elemental {a : A} (ha : p a) (f : C(quasispectrum ğ•œ a, ğ•œ)â‚€) :
    cfcâ‚™Hom ha f âˆˆ elemental ğ•œ a :=
  range_cfcâ‚™Hom ğ•œ ha â–¸ âŸ¨f, rflâŸ©

@[simp, grind â†]
theorem cfcâ‚™_apply_mem_elemental (f : ğ•œ â†’ ğ•œ) (a : A) :
    cfcâ‚™ f a âˆˆ elemental ğ•œ a :=
  cfcâ‚™_cases _ a f (zero_mem _) fun hf hfâ‚€ ha â†¦
    cfcâ‚™Hom_apply_mem_elemental ha âŸ¨âŸ¨_, hf.restrictâŸ©, hfâ‚€âŸ©

end RCLike

open scoped NNReal
variable {A : Type*} [NonUnitalRing A] [StarRing A] [Module â„ A] [IsScalarTower â„ A A]
variable [SMulCommClass â„ A A] [TopologicalSpace A]
variable [NonUnitalContinuousFunctionalCalculus â„ A IsSelfAdjoint] [IsTopologicalRing A] [T2Space A]
variable [PartialOrder A] [NonnegSpectrumClass â„ A] [StarOrderedRing A]

lemma range_cfcâ‚™_nnreal_eq_image_cfcâ‚™_real (a : A) (ha : 0 â‰¤ a) :
    Set.range (cfcâ‚™ (R := â„â‰¥0) Â· a) = (cfcâ‚™ Â· a) '' {f | âˆ€ x âˆˆ quasispectrum â„ a, 0 â‰¤ f x} := by
  ext
  constructor
  Â· rintro âŸ¨f, rflâŸ©
    simp only [cfcâ‚™_nnreal_eq_real f a]
    exact âŸ¨_, fun _ _ â†¦ by positivity, rflâŸ©
  Â· rintro âŸ¨f, hf, rflâŸ©
    simp only [cfcâ‚™_real_eq_nnreal a hf]
    exact âŸ¨_, rflâŸ©

variable [StarModule â„ A] [ContinuousStar A] [ContinuousConstSMul â„ A]

lemma range_cfcâ‚™_nnreal (a : A) (ha : 0 â‰¤ a) :
    Set.range (cfcâ‚™ (R := â„â‰¥0) Â· a) = {x | x âˆˆ NonUnitalStarAlgebra.elemental â„ a âˆ§ 0 â‰¤ x} := by
  rw [range_cfcâ‚™_nnreal_eq_image_cfcâ‚™_real a ha, Set.setOf_and, SetLike.setOf_mem_eq,
    â† range_cfcâ‚™Hom _ ha.isSelfAdjoint, â† range_cfcâ‚™, Set.inter_comm,
    â† Set.image_preimage_eq_inter_range]
  refine Set.Subset.antisymm (Set.image_mono (fun _ â†¦ cfcâ‚™_nonneg)) ?_
  rintro _ âŸ¨f, hf, rflâŸ©
  simp only [Set.preimage_setOf_eq, Set.mem_setOf_eq, Set.mem_image] at hf âŠ¢
  obtain (âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© | h | h | h) := by
    simpa only [not_and_or] using
      em (ContinuousOn f (quasispectrum â„ a) âˆ§ f 0 = 0 âˆ§ IsSelfAdjoint a)
  Â· refine âŸ¨f, ?_, rflâŸ©
    rwa [cfcâ‚™_nonneg_iff f a] at hf
  Â· exact âŸ¨0, by simp, by simp [cfcâ‚™_apply_of_not_continuousOn a h]âŸ©
  Â· exact âŸ¨0, by simp, by simp [cfcâ‚™_apply_of_not_map_zero a h]âŸ©
  Â· exact âŸ¨0, by simp, by simp [cfcâ‚™_apply_of_not_predicate a h]âŸ©

end NonUnital

end CFCRange
