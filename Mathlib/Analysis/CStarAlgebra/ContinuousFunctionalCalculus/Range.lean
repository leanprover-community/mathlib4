/-
Copyright (c) 2025 Jireh Loreaux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jireh Loreaux
-/
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Instances
import Mathlib.Topology.ContinuousMap.ContinuousSqrt

/-! # Range of the continuous functional calculus

This file contains results about the range of the continuous functional calculus, and
consequences thereof.

# Main results

* `range_cfcHom` and `range_cfc‚ÇôHom`: for `RCLike` scalar rings, the range of the continuous
  functional calculus homomorphism is the elemental subalgebra generated by the given element.
* `range_cfc_nnreal` and `range_cfc‚Çô_nnreal`: over the scalar semiring `‚Ñù‚â•0`, the range of the
  continuous functional calculus consists of the nonnegative elements in the elemental `‚Ñù`-algebra
  generated by the given element.
* `Commute.cfc` and `Commute.cfc‚Çô`: an element commutes with `cfc f a` or `cfc‚Çô f a` if it
  commutes with both `a` and `star a`. Specialized versions for `‚Ñù` and `‚Ñù‚â•0` or for
  `IsSelfAdjoint a` which do not require the user to show the element commutes with `star a` are
  provided for convenience.

-/

open Topology

open scoped CStarAlgebra

section CFCRangeCommute

theorem range_cfc (R : Type*) {A : Type*} {p : A ‚Üí Prop} [CommSemiring R] [StarRing R]
    [MetricSpace R] [IsTopologicalSemiring R] [ContinuousStar R] [Ring A] [StarRing A]
    [Algebra R A] [TopologicalSpace A] [StarModule R A] [ContinuousFunctionalCalculus R A p]
    {a : A} (ha : p a) : Set.range (cfc (R := R) ¬∑ a) = (cfcHom ha (R := R)).range := by
  ext
  constructor
  all_goals rintro ‚ü®f, rfl‚ü©
  ¬∑ exact cfc_cases _ a f (zero_mem _) fun hf ha ‚Ü¶ ‚ü®_, rfl‚ü©
  ¬∑ exact ‚ü®Subtype.val.extend f 0, cfcHom_eq_cfc_extend _ ha _ |>.symm‚ü©

section RCLike

variable (ùïú : Type*) {A : Type*} {p : A ‚Üí Prop} [RCLike ùïú] [Ring A] [StarRing A] [Algebra ùïú A]
variable [TopologicalSpace A] [StarModule ùïú A] [ContinuousFunctionalCalculus ùïú A p]
variable [IsTopologicalRing A] [ContinuousStar A]

open StarAlgebra

open scoped ContinuousFunctionalCalculus in
theorem range_cfcHom {a : A} (ha : p a) :
    (cfcHom ha (R := ùïú)).range = elemental ùïú a := by
  rw [StarAlgHom.range_eq_map_top, ‚Üê ContinuousMap.elemental_id_eq_top, StarAlgebra.elemental,
    ‚Üê StarSubalgebra.topologicalClosure_map _ _ (cfcHom_isClosedEmbedding ha (R := ùïú)).isClosedMap
      (cfcHom_continuous ha), StarAlgHom.map_adjoin]
  congr
  simpa using cfcHom_id ha

variable {ùïú}

theorem cfcHom_apply_mem_elemental {a : A} (ha : p a) (f : C(spectrum ùïú a, ùïú)) :
    cfcHom ha f ‚àà elemental ùïú a :=
  range_cfcHom ùïú ha ‚ñ∏ ‚ü®f, rfl‚ü©

@[simp, grind ‚Üê]
theorem cfc_apply_mem_elemental (f : ùïú ‚Üí ùïú) (a : A) :
    cfc f a ‚àà elemental ùïú a :=
  cfc_cases _ a f (zero_mem _) fun hf ha ‚Ü¶
    cfcHom_apply_mem_elemental ha ‚ü®_, hf.restrict‚ü©

variable [T2Space A]

open StarSubalgebra elemental in
protected theorem Commute.cfcHom {a b : A} (ha : p a) (hb‚ÇÅ : Commute a b)
    (hb‚ÇÇ : Commute (star a) b) (f : C(spectrum ùïú a, ùïú)) :
    Commute (cfcHom ha f) b :=
  have hb : b ‚àà centralizer ùïú {a} := by simpa [mem_centralizer_iff] using ‚ü®hb‚ÇÅ.eq, hb‚ÇÇ.eq‚ü©
  le_centralizer_centralizer ùïú a (cfcHom_apply_mem_elemental ha f) b (.inl hb) |>.symm

protected theorem IsSelfAdjoint.commute_cfcHom {a b : A} (ha : p a)
    (ha' : IsSelfAdjoint a) (hb : Commute a b) (f : C(spectrum ùïú a, ùïú)) :
    Commute (cfcHom ha f) b :=
  hb.cfcHom ha (ha'.star_eq.symm ‚ñ∏ hb) f

/-- An element commutes with `cfc f a` if it commutes with both `a` and `star a`.

If the base ring is `‚Ñù` or `‚Ñù‚â•0`, see `Commute.cfc_real` or `Commute.cfc_nnreal` which don't require
the `Commute (star a) b` hypothesis. -/
@[grind ‚Üê]
protected theorem Commute.cfc {a b : A} (hb‚ÇÅ : Commute a b)
    (hb‚ÇÇ : Commute (star a) b) (f : ùïú ‚Üí ùïú) :
    Commute (cfc f a) b :=
  cfc_cases (fun x ‚Ü¶ Commute x b) a f (Commute.zero_left _)
    fun hf ha ‚Ü¶ hb‚ÇÅ.cfcHom ha hb‚ÇÇ ‚ü®_, hf.restrict‚ü©

/-- For `a` selfadjoint, an element commutes with `cfc f a` if it commutes with `a`.

If the base ring is `‚Ñù` or `‚Ñù‚â•0`, see `Commute.cfc_real` or `Commute.cfc_nnreal` which don't require
the `IsSelfAdjoint` hypothesis on `a` (due to the junk value `cfc f a = 0`). -/
protected theorem IsSelfAdjoint.commute_cfc {a b : A}
    (ha : IsSelfAdjoint a) (hb‚ÇÅ : Commute a b) (f : ùïú ‚Üí ùïú) :
    Commute (cfc f a) b :=
  hb‚ÇÅ.cfc (ha.star_eq.symm ‚ñ∏ hb‚ÇÅ) f

end RCLike

open scoped NNReal
variable {A : Type*} [Ring A] [StarRing A] [Algebra ‚Ñù A]
variable [TopologicalSpace A] [StarModule ‚Ñù A] [ContinuousFunctionalCalculus ‚Ñù A IsSelfAdjoint]
variable [ContinuousStar A] [IsTopologicalRing A] [T2Space A]

/-- A version of `Commute.cfc` or `IsSelfAdjoint.commute_cfc` which does not require any interaction
with `star` when the base ring is `‚Ñù`. -/
@[grind ‚Üê]
protected theorem Commute.cfc_real {a b : A} (hb : Commute a b) (f : ‚Ñù ‚Üí ‚Ñù) :
    Commute (cfc f a) b :=
  cfc_cases (fun x ‚Ü¶ Commute x b) a f (Commute.zero_left _) fun hf ha ‚Ü¶ by
    rw [‚Üê cfc_apply ..]
    exact hb.cfc (ha.star_eq.symm ‚ñ∏ hb) _

variable [PartialOrder A] [NonnegSpectrumClass ‚Ñù A] [StarOrderedRing A]

/-- A version of `Commute.cfc` or `IsSelfAdjoint.commute_cfc` which does not require any interaction
with `star` when the base ring is `‚Ñù‚â•0`. -/
@[grind ‚Üê]
protected theorem Commute.cfc_nnreal {a b : A} (hb : Commute a b) (f : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0) :
    Commute (cfc f a) b := by
  by_cases ha : 0 ‚â§ a
  ¬∑ rw [cfc_nnreal_eq_real ..]
    exact hb.cfc_real _
  ¬∑ simp [cfc_apply_of_not_predicate a ha]

omit [StarModule ‚Ñù A] [ContinuousStar A] in
lemma range_cfc_nnreal_eq_image_cfc_real (a : A) (ha : 0 ‚â§ a) :
    Set.range (cfc (R := ‚Ñù‚â•0) ¬∑ a) = (cfc ¬∑ a) '' {f | ‚àÄ x ‚àà spectrum ‚Ñù a, 0 ‚â§ f x} := by
  ext
  constructor
  ¬∑ rintro ‚ü®f, rfl‚ü©
    simp only [cfc_nnreal_eq_real f a ha]
    exact ‚ü®_, fun _ _ ‚Ü¶ by positivity, rfl‚ü©
  ¬∑ rintro ‚ü®f, hf, rfl‚ü©
    simp only [cfc_real_eq_nnreal a hf]
    exact ‚ü®_, rfl‚ü©

lemma range_cfc_nnreal (a : A) (ha : 0 ‚â§ a) :
    Set.range (cfc (R := ‚Ñù‚â•0) ¬∑ a) = {x | x ‚àà StarAlgebra.elemental ‚Ñù a ‚àß 0 ‚â§ x} := by
  rw [range_cfc_nnreal_eq_image_cfc_real a ha, Set.setOf_and, SetLike.setOf_mem_eq,
    ‚Üê range_cfcHom _ ha.isSelfAdjoint, ‚Üê range_cfc, Set.inter_comm,
    ‚Üê Set.image_preimage_eq_inter_range]
  refine Set.Subset.antisymm (Set.image_mono (fun _ ‚Ü¶ cfc_nonneg)) ?_
  rintro _ ‚ü®f, hf, rfl‚ü©
  simp only [Set.preimage_setOf_eq, Set.mem_setOf_eq, Set.mem_image] at hf ‚ä¢
  obtain (‚ü®h‚ÇÅ, h‚ÇÇ‚ü© | h | h) := by
    simpa only [not_and_or] using em (ContinuousOn f (spectrum ‚Ñù a) ‚àß IsSelfAdjoint a)
  ¬∑ refine ‚ü®f, ?_, rfl‚ü©
    rwa [cfc_nonneg_iff f a] at hf
  ¬∑ exact ‚ü®0, by simp, by simp [cfc_apply_of_not_continuousOn a h]‚ü©
  ¬∑ exact ‚ü®0, by simp, by simp [cfc_apply_of_not_predicate a h]‚ü©

end CFCRangeCommute

section NonUnital

theorem range_cfc‚Çô (R : Type*) {A : Type*} {p : A ‚Üí Prop} [CommSemiring R] [StarRing R]
    [MetricSpace R] [IsTopologicalSemiring R] [ContinuousStar R] [Nontrivial R] [NonUnitalRing A]
    [StarRing A] [Module R A] [IsScalarTower R A A] [SMulCommClass R A A] [TopologicalSpace A]
    [NonUnitalContinuousFunctionalCalculus R A p] {a : A} (ha : p a) :
    Set.range (cfc‚Çô (R := R) ¬∑ a) = NonUnitalStarAlgHom.range (cfc‚ÇôHom ha (R := R)) := by
  ext
  constructor
  all_goals rintro ‚ü®f, rfl‚ü©
  ¬∑ exact cfc‚Çô_cases _ a f (zero_mem _) fun hf hf‚ÇÄ ha ‚Ü¶ ‚ü®_, rfl‚ü©
  ¬∑ exact ‚ü®Subtype.val.extend f 0, cfc‚ÇôHom_eq_cfc‚Çô_extend _ ha _ |>.symm‚ü©

section RCLike

variable (ùïú : Type*) {A : Type*} {p : A ‚Üí Prop} [RCLike ùïú] [NonUnitalRing A] [StarRing A]
variable [Module ùïú A] [IsScalarTower ùïú A A] [SMulCommClass ùïú A A]
variable [TopologicalSpace A] [NonUnitalContinuousFunctionalCalculus ùïú A p]
variable [ContinuousConstSMul ùïú A] [StarModule ùïú A] [IsTopologicalRing A] [ContinuousStar A]

open NonUnitalStarAlgebra

open scoped NonUnitalContinuousFunctionalCalculus in
theorem range_cfc‚ÇôHom {a : A} (ha : p a) :
    NonUnitalStarAlgHom.range (cfc‚ÇôHom ha (R := ùïú)) = elemental ùïú a := by
  rw [‚Üê NonUnitalStarAlgebra.map_top, ‚Üê ContinuousMapZero.elemental_eq_top,
    NonUnitalStarAlgebra.elemental, ‚Üê NonUnitalStarSubalgebra.topologicalClosure_map _
    (cfc‚ÇôHom_isClosedEmbedding ha (R := ùïú)).isClosedMap (cfc‚ÇôHom_continuous ha),
    NonUnitalStarAlgHom.map_adjoin]
  congr
  simpa using cfc‚ÇôHom_id ha

variable {ùïú}

open scoped ContinuousMapZero

theorem cfc‚ÇôHom_apply_mem_elemental {a : A} (ha : p a) (f : C(quasispectrum ùïú a, ùïú)‚ÇÄ) :
    cfc‚ÇôHom ha f ‚àà elemental ùïú a :=
  range_cfc‚ÇôHom ùïú ha ‚ñ∏ ‚ü®f, rfl‚ü©

@[simp, grind ‚Üê]
theorem cfc‚Çô_apply_mem_elemental (f : ùïú ‚Üí ùïú) (a : A) :
    cfc‚Çô f a ‚àà elemental ùïú a :=
  cfc‚Çô_cases _ a f (zero_mem _) fun hf hf‚ÇÄ ha ‚Ü¶
    cfc‚ÇôHom_apply_mem_elemental ha ‚ü®‚ü®_, hf.restrict‚ü©, hf‚ÇÄ‚ü©

variable [T2Space A]

open NonUnitalStarSubalgebra elemental in
protected theorem Commute.cfc‚ÇôHom {a b : A} (ha : p a) (hb‚ÇÅ : Commute a b)
    (hb‚ÇÇ : Commute (star a) b) (f : C(quasispectrum ùïú a, ùïú)‚ÇÄ) :
    Commute (cfc‚ÇôHom ha f) b :=
  have hb : b ‚àà centralizer ùïú {a} := by simpa [mem_centralizer_iff] using ‚ü®hb‚ÇÅ.eq, hb‚ÇÇ.eq‚ü©
  le_centralizer_centralizer ùïú a (cfc‚ÇôHom_apply_mem_elemental ha f) b (.inl hb) |>.symm

protected theorem IsSelfAdjoint.commute_cfc‚ÇôHom {a b : A} (ha : p a)
    (ha' : IsSelfAdjoint a) (hb : Commute a b) (f : C(quasispectrum ùïú a, ùïú)‚ÇÄ) :
    Commute (cfc‚ÇôHom ha f) b :=
  hb.cfc‚ÇôHom ha (ha'.star_eq.symm ‚ñ∏ hb) f

/-- An element commutes with `cfc‚Çô f a` if it commutes with both `a` and `star a`.

If the base ring is `‚Ñù` or `‚Ñù‚â•0`, see `Commute.cfc‚Çô_real` or `Commute.cfc‚Çô_nnreal` which don't
require the `Commute (star a) b` hypothesis. -/
@[grind ‚Üê]
protected theorem Commute.cfc‚Çô {a b : A} (hb‚ÇÅ : Commute a b)
    (hb‚ÇÇ : Commute (star a) b) (f : ùïú ‚Üí ùïú) :
    Commute (cfc‚Çô f a) b :=
  cfc‚Çô_cases (fun x ‚Ü¶ Commute x b) a f (Commute.zero_left _)
    fun hf hf‚ÇÄ ha ‚Ü¶ hb‚ÇÅ.cfc‚ÇôHom ha hb‚ÇÇ ‚ü®‚ü®_, hf.restrict‚ü©, hf‚ÇÄ‚ü©

/-- For `a` selfadjoint, an element commutes with `cfc‚Çô f a` if it commutes with `a`.

If the base ring is `‚Ñù` or `‚Ñù‚â•0`, see `Commute.cfc‚Çô_real` or `Commute.cfc‚Çô_nnreal` which don't
require the `IsSelfAdjoint` hypothesis on `a` (due to the junk value `cfc‚Çô f a = 0`). -/
protected theorem IsSelfAdjoint.commute_cfc‚Çô {a b : A}
    (ha : IsSelfAdjoint a) (hb‚ÇÅ : Commute a b) (f : ùïú ‚Üí ùïú) :
    Commute (cfc‚Çô f a) b :=
  hb‚ÇÅ.cfc‚Çô (ha.star_eq.symm ‚ñ∏ hb‚ÇÅ) f

end RCLike

open scoped NNReal
variable {A : Type*} [NonUnitalRing A] [StarRing A] [Module ‚Ñù A] [IsScalarTower ‚Ñù A A]
  [SMulCommClass ‚Ñù A A] [TopologicalSpace A] [StarModule ‚Ñù A]
  [NonUnitalContinuousFunctionalCalculus ‚Ñù A IsSelfAdjoint] [ContinuousStar A]
  [IsTopologicalRing A] [T2Space A] [ContinuousConstSMul ‚Ñù A]

/-- A version of `Commute.cfc‚Çô` or `IsSelfAdjoint.commute_cfc‚Çô` which does not require any
interaction with `star` when the base ring is `‚Ñù`. -/
@[grind ‚Üê]
protected theorem Commute.cfc‚Çô_real {a b : A} (hb : Commute a b) (f : ‚Ñù ‚Üí ‚Ñù) :
    Commute (cfc‚Çô f a) b :=
  cfc‚Çô_cases (fun x ‚Ü¶ Commute x b) a f (Commute.zero_left _)
    fun hf hf0 ha ‚Ü¶ by
      rw [‚Üê cfc‚Çô_apply ..]
      exact hb.cfc‚Çô (ha.star_eq.symm ‚ñ∏ hb) _

variable [PartialOrder A] [NonnegSpectrumClass ‚Ñù A] [StarOrderedRing A]

/-- A version of `Commute.cfc‚Çô` or `IsSelfAdjoint.commute_cfc‚Çô` which does not require any
interaction with `star` when the base ring is `‚Ñù‚â•0`. -/
@[grind ‚Üê]
protected theorem Commute.cfc‚Çô_nnreal {a b : A} (hb : Commute a b) (f : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0) :
    Commute (cfc‚Çô f a) b := by
  by_cases ha : 0 ‚â§ a
  ¬∑ rw [cfc‚Çô_nnreal_eq_real ..]
    exact hb.cfc‚Çô_real _
  ¬∑ simp [cfc‚Çô_apply_of_not_predicate a ha]

omit [StarModule ‚Ñù A] [ContinuousStar A] [ContinuousConstSMul ‚Ñù A] in
lemma range_cfc‚Çô_nnreal_eq_image_cfc‚Çô_real (a : A) (ha : 0 ‚â§ a) :
    Set.range (cfc‚Çô (R := ‚Ñù‚â•0) ¬∑ a) = (cfc‚Çô ¬∑ a) '' {f | ‚àÄ x ‚àà quasispectrum ‚Ñù a, 0 ‚â§ f x} := by
  ext
  constructor
  ¬∑ rintro ‚ü®f, rfl‚ü©
    simp only [cfc‚Çô_nnreal_eq_real f a]
    exact ‚ü®_, fun _ _ ‚Ü¶ by positivity, rfl‚ü©
  ¬∑ rintro ‚ü®f, hf, rfl‚ü©
    simp only [cfc‚Çô_real_eq_nnreal a hf]
    exact ‚ü®_, rfl‚ü©

lemma range_cfc‚Çô_nnreal (a : A) (ha : 0 ‚â§ a) :
    Set.range (cfc‚Çô (R := ‚Ñù‚â•0) ¬∑ a) = {x | x ‚àà NonUnitalStarAlgebra.elemental ‚Ñù a ‚àß 0 ‚â§ x} := by
  rw [range_cfc‚Çô_nnreal_eq_image_cfc‚Çô_real a ha, Set.setOf_and, SetLike.setOf_mem_eq,
    ‚Üê range_cfc‚ÇôHom _ ha.isSelfAdjoint, ‚Üê range_cfc‚Çô, Set.inter_comm,
    ‚Üê Set.image_preimage_eq_inter_range]
  refine Set.Subset.antisymm (Set.image_mono (fun _ ‚Ü¶ cfc‚Çô_nonneg)) ?_
  rintro _ ‚ü®f, hf, rfl‚ü©
  simp only [Set.preimage_setOf_eq, Set.mem_setOf_eq, Set.mem_image] at hf ‚ä¢
  obtain (‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© | h | h | h) := by
    simpa only [not_and_or] using
      em (ContinuousOn f (quasispectrum ‚Ñù a) ‚àß f 0 = 0 ‚àß IsSelfAdjoint a)
  ¬∑ refine ‚ü®f, ?_, rfl‚ü©
    rwa [cfc‚Çô_nonneg_iff f a] at hf
  ¬∑ exact ‚ü®0, by simp, by simp [cfc‚Çô_apply_of_not_continuousOn a h]‚ü©
  ¬∑ exact ‚ü®0, by simp, by simp [cfc‚Çô_apply_of_not_map_zero a h]‚ü©
  ¬∑ exact ‚ü®0, by simp, by simp [cfc‚Çô_apply_of_not_predicate a h]‚ü©

end NonUnital
