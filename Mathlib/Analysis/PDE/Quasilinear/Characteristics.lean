import Mathlib.Analysis.Calculus.PDE.LinearFirstOrder.Defs
import Mathlib.Analysis.Calculus.TangentCone
import Mathlib.Analysis.ODE.Gronwall
import Mathlib.Topology.ContinuousOn
import Mathlib.Topology.MetricSpace.Pseudo.Defs

/-! # The Methods of Characteristics for first order quasilinear PDEs

This file develops some basic theory of first order quasilinear PDEs and
their characteristic curves.

## Main results
- `solution_constant_characteristic`: if `u` is a solution to quasilinear PDE
  `E : a‚ÇÅ ‚àÇ‚ÇÅu + ... + a‚Çô ‚àÇ‚Çôu = c` and `Œ≥ = (X, U)` is a characteristic curve of `E` then
  the composite `u ‚àò X` satisfies `d/dt (u ‚àò X) = U`


## TODO
- Local existence of characteristics

-/

open Set

open scoped Topology

section MainTheorem

open FirstOrderQuasiLinearPDE

/-

In this section, we prove the following key result: if `(X, U)` is a parametrisation of a characteristic curve of
`E` and `u` is a solution to `E` then we have `u ‚àò X(t) = U(t)` for all reasonable times `t`.

The proof goes roughly as follows:
- Consider the function `Œî(t) = |u ‚àò X(t) - U(t)|^2`. This is differentiable and so on.
- Show that for `|Œî'(t)| ‚â§ C|Œî(t)|` for small times `t`.
- By a consequence of Gronwall's inequality (already formalised in other file), this implies that `Œî = 0` for small times `t`
- This gives the result locally. The global version follows easily from this.

-/

/-
TODO(Paul-Lez):
- Harmonise usage of `fderiv` vs `HasFDeriv` and so on.
- Split/tidy proofs
-/

variable {ùïú V : Type*}

variable {Œ≥ : ‚Ñù ‚Üí V √ó ‚Ñù} {s : Set ‚Ñù} {u : V ‚Üí ‚Ñù}

variable (Œ≥ u) in
abbrev Œî : ‚Ñù ‚Üí ‚Ñù := (fun (t : ‚Ñù) ‚Ü¶ |u (Œ≥ t).fst - (Œ≥ t).snd|^2)

lemma Œî_eq_zero_iff {t} : Œî Œ≥ u t = 0 ‚Üî u (Œ≥ t).fst = (Œ≥ t).snd := by
  rw [Œî, sq_eq_zero_iff, abs_eq_zero, sub_eq_zero]

section Continuous

variable [TopologicalSpace V] (hŒ≥ : Continuous Œ≥)  (hu' : Continuous u)

include hŒ≥ hu'

lemma Œî_cts' : Continuous (Œî Œ≥ u) := by fun_prop

lemma Œî_cts : ContinuousOn (Œî Œ≥ u) s :=
  (Œî_cts' hŒ≥ hu').continuousOn

section sSups_and_sInfs

/--
Let `t‚ÇÄ` be a time such that `u(X(t‚ÇÄ)) = U(t‚ÇÄ)`. Then for any `t ‚â• t‚ÇÄ`, the
supremum of the set `{œÑ : ‚Ñù | œÑ ‚àà s ‚àß œÑ ‚â§ t ‚àß Œî Œ≥ u œÑ = 0}` lies in the set
-/
theorem csSup_zero_set (hs' : IsConnected s) {t‚ÇÄ t : ‚Ñù} (ht‚ÇÄ : t‚ÇÄ ‚àà s) (hŒ≥‚ÇÅ : (Œ≥ t‚ÇÄ).snd = u (Œ≥ t‚ÇÄ).fst)
    (ht : t ‚àà s) (ht‚ÇÄ' : t‚ÇÄ ‚â§ t) :
    --we can strengthen this quite easily if needed
    sSup {œÑ : ‚Ñù | œÑ ‚àà s ‚àß œÑ ‚â§ t ‚àß Œî Œ≥ u œÑ = 0} ‚àà {œÑ : ‚Ñù | œÑ ‚àà s ‚àß œÑ ‚â§ t ‚àß Œî Œ≥ u œÑ = 0} := by
  let Œµ := sSup {œÑ : ‚Ñù | œÑ ‚àà s ‚àß œÑ ‚â§ t ‚àß Œî Œ≥ u œÑ = 0}
  have t‚ÇÄ_mem : t‚ÇÄ ‚àà {œÑ : ‚Ñù | œÑ ‚àà s ‚àß œÑ ‚â§ t ‚àß Œî Œ≥ u œÑ = 0} :=
    ‚ü®ht‚ÇÄ, ht‚ÇÄ', Œî_eq_zero_iff.mpr hŒ≥‚ÇÅ.symm‚ü©
  have bdd_above : BddAbove {œÑ : ‚Ñù | œÑ ‚àà s ‚àß œÑ ‚â§ t ‚àß Œî Œ≥ u œÑ = 0} := by
    use t
    intro v hv
    exact hv.right.left
  have Œî_Œµ : Œî Œ≥ u Œµ = 0 := by
    --We should be able to weaken the continuity requirements on `u` and `Œ≥` here
    apply ContinousWithinAt.eq_const_of_mem_closure (Continuous.continuousWithinAt _) (csSup_mem_closure (nonempty_of_mem t‚ÇÄ_mem) bdd_above)
    ¬∑ intro y hy
      exact hy.right.right
    ¬∑ apply Œî_cts' hŒ≥ hu'
  suffices Œµ ‚àà Set.Icc t‚ÇÄ t by
    refine ‚ü®(IsConnected.Icc_subset hs' ht‚ÇÄ ht) this, (Set.mem_Icc.mp this).right, Œî_Œµ‚ü©
  rw [Set.mem_Icc]
  refine ‚ü®le_csSup bdd_above t‚ÇÄ_mem , csSup_le (nonempty_of_mem t‚ÇÄ_mem) fun v hv => hv.right.left‚ü©


/--
Let `t‚ÇÄ` be a time such that `u(X(t‚ÇÄ)) = U(t‚ÇÄ)`. Then for any `t ‚â§ t‚ÇÄ`, the
infimum of the set `{œÑ : ‚Ñù | œÑ ‚àà s ‚àß t ‚â§ œÑ ‚àß Œî Œ≥ u œÑ = 0}` lies in the set
-/
theorem csInf_zero_set (hs' : IsConnected s) {t‚ÇÄ t : ‚Ñù} (ht‚ÇÄ : t‚ÇÄ ‚àà s) (hŒ≥‚ÇÅ : (Œ≥ t‚ÇÄ).snd = u (Œ≥ t‚ÇÄ).fst)
    (ht : t ‚àà s) (ht‚ÇÄ' : t ‚â§ t‚ÇÄ) :
    sInf {œÑ : ‚Ñù | œÑ ‚àà s ‚àß t ‚â§ œÑ ‚àß Œî Œ≥ u œÑ = 0} ‚àà {œÑ : ‚Ñù | œÑ ‚àà s ‚àß t ‚â§ œÑ ‚àß Œî Œ≥ u œÑ = 0} := by
  let Œµ := sInf {œÑ : ‚Ñù | œÑ ‚àà s ‚àß t ‚â§ œÑ ‚àß Œî Œ≥ u œÑ = 0}
  have t‚ÇÄ_mem : t‚ÇÄ ‚àà {œÑ : ‚Ñù | œÑ ‚àà s ‚àß t ‚â§ œÑ ‚àß Œî Œ≥ u œÑ = 0} :=
    ‚ü®ht‚ÇÄ, ht‚ÇÄ', Œî_eq_zero_iff.mpr hŒ≥‚ÇÅ.symm‚ü©
  have bdd_below : BddBelow {œÑ : ‚Ñù | œÑ ‚àà s ‚àß t ‚â§ œÑ ‚àß Œî Œ≥ u œÑ = 0} := by
    use t
    intro v hv
    exact hv.right.left
  have Œî_Œµ : Œî Œ≥ u Œµ = 0 := by
    --We should be able to weaken the continuity requirements on `u` and `Œ≥` here
    apply ContinousWithinAt.eq_const_of_mem_closure (Continuous.continuousWithinAt _) (csInf_mem_closure (nonempty_of_mem t‚ÇÄ_mem) bdd_below)
    ¬∑ intro y hy
      exact hy.right.right
    ¬∑ apply Œî_cts' hŒ≥ hu'
  suffices Œµ ‚àà Set.Icc t t‚ÇÄ by
    refine ‚ü®(IsConnected.Icc_subset hs' ht ht‚ÇÄ) this, (Set.mem_Icc.mp this).left, Œî_Œµ‚ü©
  rw [Set.mem_Icc]
  refine ‚ü®le_csInf (nonempty_of_mem t‚ÇÄ_mem) fun v hv => hv.right.left, csInf_le bdd_below t‚ÇÄ_mem ‚ü©

end sSups_and_sInfs

end Continuous

variable [NormedAddCommGroup V] [NormedSpace ‚Ñù V]

variable {E : FirstOrderQuasiLinearPDE ‚Ñù V} (hŒ≥‚ÇÇ : ‚àÄ t ‚àà s, E.HasCharacteristicAt Œ≥ t)
variable (hu : ‚àÄ t ‚àà s, E.HasSolutionAt u (Œ≥ t).fst)

include hu
include hŒ≥‚ÇÇ

/--
`Œî` is differentiable.
-/
lemma Œî_diff {t : ‚Ñù} (ht : t ‚àà s) : DifferentiableAt ‚Ñù (Œî Œ≥ u) t := by
  have : Œî Œ≥ u = fun t => (u (Œ≥ t).fst - (Œ≥ t).snd)^2 := by ext; simp [Œî]
  rw [this]
  apply DifferentiableAt.pow
  apply DifferentiableAt.sub _ (hŒ≥‚ÇÇ t ht).differentiableAt.snd
  apply DifferentiableAt.comp
  apply differentiableAt_of_hasSolutionAt (hu t ht)
  apply (hŒ≥‚ÇÇ t ht).differentiableAt.fst

/--
`Œî'(t) = 2(u(X(t)) - U(t)) (‚àáu(X(t)) ‚Ä¢ X'(t) - U'(t)) = 2(u(X(t)) - U(t)) (‚àáu(X(t)) ‚Ä¢ a(X(t), U(t)) - c(X(t), U(t)))`
-/
lemma hasDerivAt_Œî_step‚ÇÅ (t : ‚Ñù) (ht : t ‚àà s) :
    HasDerivAt (Œî Œ≥ u) (2*(u (Œ≥ t).fst - (Œ≥ t).snd) * (fderiv ‚Ñù u ((Œ≥ t).fst) (a[E] (Œ≥ t)) - (c[E] (Œ≥ t)))) t := by
  have deriv_lem‚ÇÅ : HasDerivAt (fun t => u (Œ≥ t).fst - (Œ≥ t).snd) (fderiv ‚Ñù u ((Œ≥ t).fst) (a[E] (Œ≥ t)) - (c[E] (Œ≥ t))) t := by
    have : HasDerivAt (fun t => u (Œ≥ t).fst) (fderiv ‚Ñù u ((Œ≥ t).fst) (a[E] (Œ≥ t))) t := by
      have := (DifferentiableAt.hasFDerivAt (differentiableAt_of_hasSolutionAt (hu t ht))).comp_hasDerivAt _ (hŒ≥‚ÇÇ t ht).fst
      exact this
    have : HasDerivAt (fun t => (Œ≥ t).snd) (c[E] (Œ≥ t)) t := (hŒ≥‚ÇÇ t ht).snd
    apply HasDerivAt.sub ((DifferentiableAt.hasFDerivAt (differentiableAt_of_hasSolutionAt (hu t ht))).comp_hasDerivAt _ (hŒ≥‚ÇÇ t ht).fst) (hŒ≥‚ÇÇ t ht).snd
  have : Œî Œ≥ u = fun t ‚Ü¶ (u (Œ≥ t).fst - (Œ≥ t).snd)^2 := by ext; simp [Œî]
  simpa [this] using deriv_lem‚ÇÅ.pow 2

/--
`Œî'(t) = 2(u(X(t)) - U(t)) (‚àáu(X(t)) ‚Ä¢ (a(X(t), U(t)) - a(X(t), (u ‚àò X)(t)) - (c(X(t), U(t)) - c(X(t), (u ‚àò X)(t)))`
-/
lemma hasDerivAt_Œî_step‚ÇÇ (t : ‚Ñù) (ht : t ‚àà s) :
    HasDerivAt (Œî Œ≥ u) (2*(u (Œ≥ t).fst - (Œ≥ t).snd) * (fderiv ‚Ñù u ((Œ≥ t).fst) ((a[E] (Œ≥ t)) - (a[E] ((Œ≥ t).fst, u (Œ≥ t).fst))) - ((c[E]) (Œ≥ t) - (c[E]) ((Œ≥ t).fst, u (Œ≥ t).fst)))) t := by
  suffices (2*(u (Œ≥ t).fst - (Œ≥ t).snd) * (fderiv ‚Ñù u ((Œ≥ t).fst) (a[E] (Œ≥ t)) - (c[E]) (Œ≥ t))) = (2*(u (Œ≥ t).fst - (Œ≥ t).snd) *(fderiv ‚Ñù u ((Œ≥ t).fst)  ((a[E] (Œ≥ t)) - (a[E] ((Œ≥ t).fst, u (Œ≥ t).fst)) : V) - ((c[E]) (Œ≥ t) - (c[E]) ((Œ≥ t).fst, u (Œ≥ t).fst)))) by
    have lem := hasDerivAt_Œî_step‚ÇÅ hŒ≥‚ÇÇ hu t ht
    rwa [this] at lem
  congr 1
  have : fderiv ‚Ñù u ((Œ≥ t).fst) (a[E] (Œ≥ t)) - fderiv ‚Ñù u ((Œ≥ t).fst) (a[E] ((Œ≥ t).1, u (Œ≥ t).1)) - (E.const (Œ≥ t) - E.const ((Œ≥ t).1, u (Œ≥ t).1))
      = fderiv ‚Ñù u ((Œ≥ t).fst) (a[E] (Œ≥ t)) - E.const (Œ≥ t) - (fderiv ‚Ñù u ((Œ≥ t).fst) (a[E] ((Œ≥ t).1, u (Œ≥ t).1)) - E.const ((Œ≥ t).1, u (Œ≥ t).1)) := by
    abel
  rw [map_sub, this]
  have : fderiv ‚Ñù u ((Œ≥ t).fst) (a[E] ((Œ≥ t).1, u (Œ≥ t).1)) - E.const ((Œ≥ t).1, u (Œ≥ t).1) = 0 := by
    simpa only [sub_eq_zero, FirstOrderQuasiLinearPDE.HasSolutionAt, FirstOrderQuasiLinearPDE.HasSolutionAt] using fderiv_apply_of_hasSolutionAt (hu t ht)
  rw [this, sub_zero]


/--
`|Œî'(t)| ‚â§ 2|u(X(t)) - U(t)| * (||‚àáu(X(t))|| * ||a(X(t), U(t)) - a(X(t), (u ‚àò X)(t))|| + ||c(X(t), U(t)) - c(X(t), (u ‚àò X)(t))||`
-/
lemma hasDerivAt_Œî_bound (t : ‚Ñù) (ht : t ‚àà s) :
    ‚Äñderiv (Œî Œ≥ u) t‚Äñ ‚â§ 2*|(u (Œ≥ t).fst - (Œ≥ t).snd)| * (‚Äñ((a[E] (Œ≥ t)) - (a[E] ((Œ≥ t).fst, u (Œ≥ t).fst)) : V)‚Äñ * ‚Äñfderiv ‚Ñù u ((Œ≥ t).fst)‚Äñ +
      |(c[E]) (Œ≥ t) - (c[E]) ((Œ≥ t).fst, u (Œ≥ t).fst)|) := by
  have := hasDerivAt_Œî_step‚ÇÇ hŒ≥‚ÇÇ hu t ht
  rw [this.deriv]
  have step‚ÇÅ : ‚Äñ2 * (u (Œ≥ t).1 - (Œ≥ t).2) * (fderiv ‚Ñù u ((Œ≥ t).fst) ((a[E] (Œ≥ t)) - a[E] (((Œ≥ t).1, u (Œ≥ t).1))) -
      (E.const (Œ≥ t) - E.const ((Œ≥ t).1, u (Œ≥ t).1)))‚Äñ  = 2 * |(u (Œ≥ t).1 - (Œ≥ t).2)| *
        ‚Äñfderiv ‚Ñù u ((Œ≥ t).fst) ((a[E] (Œ≥ t)) - a[E] (((Œ≥ t).1, u (Œ≥ t).1))) -
        (c[E] (Œ≥ t) - c[E] ((Œ≥ t).1, u (Œ≥ t).1))‚Äñ := by
    rw [Real.norm_eq_abs, abs_mul, abs_mul, abs_two]
    congr
  have step‚ÇÇ : 2 * |(u (Œ≥ t).1 - (Œ≥ t).2)| *
        ‚Äñfderiv ‚Ñù u ((Œ≥ t).fst) ((a[E] (Œ≥ t)) - a[E] (((Œ≥ t).1, u (Œ≥ t).1))) -
        (c[E] (Œ≥ t) - c[E] ((Œ≥ t).1, u (Œ≥ t).1))‚Äñ ‚â§ 2 * |(u (Œ≥ t).1 - (Œ≥ t).2)| * (|fderiv ‚Ñù u ((Œ≥ t).fst) ((a[E] (Œ≥ t)) - a[E] (((Œ≥ t).1, u (Œ≥ t).1)))|
        + |c[E] (Œ≥ t) - c[E] ((Œ≥ t).1, u (Œ≥ t).1)|) := by
    apply mul_le_mul_of_nonneg_left
    ¬∑ apply abs_sub
    ¬∑ apply mul_nonneg zero_le_two (abs_nonneg _)
  have step‚ÇÉ : 2 * |(u (Œ≥ t).1 - (Œ≥ t).2)| * (|fderiv ‚Ñù u ((Œ≥ t).fst) ((a[E] (Œ≥ t)) - a[E] (((Œ≥ t).1, u (Œ≥ t).1)))|
        + |c[E] (Œ≥ t) - c[E] ((Œ≥ t).1, u (Œ≥ t).1)|)
    ‚â§ 2 * |(u (Œ≥ t).1 - (Œ≥ t).2)| * (‚Äñ((a[E] (Œ≥ t)) - (a[E] (((Œ≥ t).1, u (Œ≥ t).1)) : V) : V)‚Äñ * ‚Äñ
          fderiv ‚Ñù u ((Œ≥ t).fst)‚Äñ  + |c[E] (Œ≥ t) - c[E] ((Œ≥ t).1, u (Œ≥ t).1)|) := by
    apply mul_le_mul_of_nonneg_left
    apply add_le_add_right
    ¬∑ rw [mul_comm]
      apply (fderiv ‚Ñù u ((Œ≥ t).fst)).le_opNorm
    ¬∑ apply mul_nonneg zero_le_two (abs_nonneg _)
  rw [step‚ÇÅ]
  apply le_trans step‚ÇÇ step‚ÇÉ

--TODO: Add results like `ContDiff.smul_const` and that seem to be missing!

variable (hŒ≥ : Continuous Œ≥)  (hu' : Continuous u) (hs : IsOpen s) (hE : E.RegularBy (ContDiff ‚Ñù 1))

include hŒ≥ hu' hs hE

/--
If `u` is a solution to quasilinear PDE `E : a‚ÇÅ ‚àÇ‚ÇÅu + ... + a‚Çô ‚àÇ‚Çôu = c` and `Œ≥ = (X, U)`
is a characteristic curve of `E` such that `U(t‚ÇÄ) = u(X(t‚ÇÄ))` then for `t` near `t‚ÇÄ` we have
`|d/dt Œî(t)| ‚â§ C|Œî(t)|` for some absolute constant `C`.
-/
lemma Œî_deriv_norm_le (huGrad : ContinuousOn (fderiv ‚Ñù u) ((Prod.fst ‚àò Œ≥) '' s)) (t : ‚Ñù) (ht : t ‚àà s) (ht' : (Œ≥ t).snd = u (Œ≥ t).fst) :
    ‚àÉ r > 0, Set.Icc (t - r) (t + r) ‚äÜ s ‚àß ‚àÉ C, ‚àÄ t' ‚àà Set.Icc (t - r) (t + r),  ‚Äñderiv (Œî Œ≥ u) t'‚Äñ ‚â§ C * ‚ÄñŒî Œ≥ u t'‚Äñ := by
  have ha : LocallyLipschitz (fun x => (a[E] x : V)) := by
    apply ContDiff.locallyLipschitz hE.reg.fst
  have hc : LocallyLipschitz (fun x => (c[E] x : ‚Ñù)) := by
    apply ContDiff.locallyLipschitz hE.reg.snd
  obtain ‚ü®Ka, S‚ÇÅ, hKaS‚ÇÅ‚ü© := ha (Œ≥ t)
  obtain ‚ü®Kc, S‚ÇÇ, hKcS‚ÇÇ‚ü© := hc (Œ≥ t)
  obtain ‚ü®U‚ÇÅ, hU‚ÇÅ‚ü© := mem_nhds_iff.mp hKaS‚ÇÅ.left
  obtain ‚ü®U‚ÇÇ, hU‚ÇÇ‚ü© := mem_nhds_iff.mp hKcS‚ÇÇ.left
  set Œ©' : Set ‚Ñù := connectedComponentIn (Œ≥‚Åª¬π' (U‚ÇÅ ‚à© U‚ÇÇ) ‚à© ((fun t => ((Œ≥ t).fst, u (Œ≥ t).fst))‚Åª¬π' (U‚ÇÅ ‚à© U‚ÇÇ)) ‚à© s) t with hŒ©'
  have t_mem : t ‚àà (Œ≥‚Åª¬π' (U‚ÇÅ ‚à© U‚ÇÇ) ‚à© ((fun t => ((Œ≥ t).fst, u (Œ≥ t).fst))‚Åª¬π' (U‚ÇÅ ‚à© U‚ÇÇ)) ‚à© s) := by
    rw [Set.mem_inter_iff]
    refine ‚ü®?_, ht‚ü©
    simpa [preimage_inter, mem_inter_iff, mem_preimage, ‚Üêht'] using ‚ü®hU‚ÇÅ.right.right, hU‚ÇÇ.right.right‚ü©
  have Œ©'_subset_s : Œ©' ‚äÜ s := by rw [hŒ©'] ; apply subset_trans (connectedComponentIn_subset _ _) Set.inter_subset_right
  have Œ©'_open : IsOpen Œ©' := by
    apply IsOpen.connectedComponentIn
    apply IsOpen.inter (IsOpen.inter ?_ ?_) ?_
    ¬∑ apply Continuous.isOpen_preimage hŒ≥
      ¬∑ apply IsOpen.inter hU‚ÇÅ.right.left hU‚ÇÇ.right.left
    ¬∑ apply Continuous.isOpen_preimage
      ¬∑ rw [continuous_prod_mk]
        refine  ‚ü®hŒ≥.fst, Continuous.comp hu' hŒ≥.fst‚ü©
      ¬∑ apply IsOpen.inter hU‚ÇÅ.right.left hU‚ÇÇ.right.left
    ¬∑ exact hs
  rw [Metric.isOpen_iff'] at Œ©'_open
  obtain ‚ü®r, hr, hr'‚ü© := Œ©'_open t (mem_connectedComponentIn t_mem)
  use r, hr
  rw [‚ÜêReal.closedBall_eq_Icc]
  refine ‚ü®subset_trans hr' <| subset_trans (connectedComponentIn_subset _ _) Set.inter_subset_right, ?_‚ü©
  ¬∑ obtain ‚ü®M, hM‚ü© : ‚àÉ M, ‚àÄ s ‚àà Metric.closedBall t r, ‚Äñfderiv ‚Ñù u ((Œ≥ s).fst)‚Äñ ‚â§ M := by
      set M := ((fun (t : ‚Ñù) ‚Ü¶ ‚Äñfderiv ‚Ñù u ((Œ≥ t).fst)‚Äñ) : ‚Ñù ‚Üí ‚Ñù) '' (Set.Icc (t-r) (t+r)) with hM
      use sSup M
      intro s hs
      rw [hM]
      apply  ContinuousOn.le_sSup_image_Icc (f := (fun (t : ‚Ñù) ‚Ü¶ ‚Äñfderiv ‚Ñù u ((Œ≥ t).fst)‚Äñ))
      ¬∑ --`‚Äñu (Œ≥ t).fst‚Äñ` is continuous
        apply Continuous.comp_continuousOn continuous_norm
        ¬∑ apply ContinuousOn.comp huGrad
          apply hŒ≥.fst.continuousOn
          --the interval `[t-r,t+r]` maps into `Œ≥ '' s`.
          intro v hv
          rw [Set.mem_image]
          use v
          refine ‚ü®?_, rfl‚ü©
          apply subset_trans ?_ Œ©'_subset_s hv
          rw [‚ÜêReal.closedBall_eq_Icc]
          exact hr'
      ¬∑ rwa [‚ÜêReal.closedBall_eq_Icc]
    use (2 * (Ka * M + Kc))
    intro t ht
    have gamma_t_mem : Œ≥ t ‚àà S‚ÇÅ := by
      rw [‚ÜêSet.mem_preimage]
      apply preimage_mono (subset_trans inter_subset_left hU‚ÇÅ.left)
      apply inter_subset_left
      apply inter_subset_left
      apply connectedComponentIn_subset
      apply hr' ht
    have gamma_t_first_prod_mem : ((Œ≥ t).fst, u (Œ≥ t).fst) ‚àà S‚ÇÅ := by
      rw [‚ÜêSet.mem_preimage (f:= (fun t ‚Ü¶ ((Œ≥ t).1, u (Œ≥ t).1)))]
      apply preimage_mono (subset_trans (inter_subset_left ) hU‚ÇÅ.left)
      apply inter_subset_right
      apply inter_subset_left
      apply connectedComponentIn_subset
      apply hr' ht
    have gamma_t_mem‚ÇÇ : Œ≥ t ‚àà S‚ÇÇ := by
      rw [‚ÜêSet.mem_preimage]
      apply preimage_mono (subset_trans inter_subset_right hU‚ÇÇ.left)
      apply inter_subset_left
      apply inter_subset_left
      apply connectedComponentIn_subset
      apply hr' ht
    have gamma_t_first_prod_mem‚ÇÇ : ((Œ≥ t).fst, u (Œ≥ t).fst) ‚àà S‚ÇÇ := by
      rw [‚ÜêSet.mem_preimage (f:= (fun t ‚Ü¶ ((Œ≥ t).1, u (Œ≥ t).1)))]
      apply preimage_mono (subset_trans (inter_subset_right ) hU‚ÇÇ.left)
      apply inter_subset_right
      apply inter_subset_left
      apply connectedComponentIn_subset
      apply hr' ht
    have step‚ÇÅ : ‚Äñderiv (Œî Œ≥ u) t‚Äñ  ‚â§ 2*|(u (Œ≥ t).fst - (Œ≥ t).snd)| * (‚Äñ((a[E] (Œ≥ t)) - (a[E] ((Œ≥ t).fst, u (Œ≥ t).fst)) : V)‚Äñ * ‚Äñfderiv ‚Ñù u ((Œ≥ t).fst)‚Äñ +
            |(c[E]) (Œ≥ t) - (c[E]) ((Œ≥ t).fst, u (Œ≥ t).fst)|) := by
      apply hasDerivAt_Œî_bound hŒ≥‚ÇÇ hu t
      apply subset_trans (hr') (subset_trans (connectedComponentIn_subset _ _) Set.inter_subset_right) ht
    have step‚ÇÇ : 2*|(u (Œ≥ t).fst - (Œ≥ t).snd)| * (‚Äñ((a[E] (Œ≥ t)) - (a[E] ((Œ≥ t).fst, u (Œ≥ t).fst)) : V)‚Äñ * ‚Äñfderiv ‚Ñù u ((Œ≥ t).fst)‚Äñ +
            |(c[E]) (Œ≥ t) - (c[E]) ((Œ≥ t).fst, u (Œ≥ t).fst)|) ‚â§ 2*|(u (Œ≥ t).fst - (Œ≥ t).snd)| * (Ka * ‚Äñ Œ≥ t - ((Œ≥ t).fst, u (Œ≥ t).fst)‚Äñ * ‚Äñfderiv ‚Ñù u ((Œ≥ t).fst)‚Äñ + Kc * ‚Äñ Œ≥ t - ((Œ≥ t).fst, u (Œ≥ t).fst)‚Äñ) := by
      apply mul_le_mul_of_nonneg_left ?_ (mul_nonneg zero_le_two (abs_nonneg _))
      ¬∑ apply add_le_add
        ¬∑ apply mul_le_mul_of_nonneg_right
          rw [‚Üêdist_eq_norm, ‚Üêdist_eq_norm]
          exact hKaS‚ÇÅ.right.dist_le_mul _ gamma_t_mem _ gamma_t_first_prod_mem
          ¬∑ exact norm_nonneg (fderiv ‚Ñù u ((Œ≥ t).fst))
        ¬∑ rw [‚Üêdist_eq_norm, ‚ÜêReal.dist_eq]
          exact hKcS‚ÇÇ.right.dist_le_mul _ gamma_t_mem‚ÇÇ _ gamma_t_first_prod_mem‚ÇÇ
    have step‚ÇÉ : 2*|(u (Œ≥ t).fst - (Œ≥ t).snd)| * (Ka * ‚Äñ Œ≥ t - ((Œ≥ t).fst, u (Œ≥ t).fst)‚Äñ * ‚Äñfderiv ‚Ñù u ((Œ≥ t).fst)‚Äñ + Kc * ‚Äñ Œ≥ t - ((Œ≥ t).fst, u (Œ≥ t).fst)‚Äñ)
      ‚â§ 2*|(u (Œ≥ t).fst - (Œ≥ t).snd)| * (Ka * ‚Äñ Œ≥ t - ((Œ≥ t).fst, u (Œ≥ t).fst)‚Äñ * M + Kc * ‚Äñ Œ≥ t - ((Œ≥ t).fst, u (Œ≥ t).fst)‚Äñ) := by
      apply mul_le_mul_of_nonneg_left ?_ (mul_nonneg zero_le_two (abs_nonneg _))
      rw [add_le_add_iff_right]
      apply mul_le_mul_of_nonneg_left
      apply hM t ht
      apply mul_nonneg (NNReal.coe_nonneg _) (norm_nonneg _)
    have step‚ÇÑ : 2*|(u (Œ≥ t).fst - (Œ≥ t).snd)| * (Ka * ‚Äñ Œ≥ t - ((Œ≥ t).fst, u (Œ≥ t).fst)‚Äñ * M + Kc * ‚Äñ Œ≥ t - ((Œ≥ t).fst, u (Œ≥ t).fst)‚Äñ)
      = 2*|(u (Œ≥ t).fst - (Œ≥ t).snd)| * (Ka * M + Kc) * ‚ÄñŒ≥ t - ((Œ≥ t).fst, u (Œ≥ t).fst)‚Äñ := by ring
    have step‚ÇÖ : 2*|(u (Œ≥ t).fst - (Œ≥ t).snd)| * (Ka * M + Kc) * ‚ÄñŒ≥ t - ((Œ≥ t).fst, u (Œ≥ t).fst)‚Äñ
      = 2*|(u (Œ≥ t).fst - (Œ≥ t).snd)| * (Ka * M + Kc) * ‚Äñ(Œ≥ t).snd - u (Œ≥ t).fst‚Äñ := by
      congr
      nth_rewrite 1 [‚ÜêProd.mk.eta (p:= Œ≥ t)]
      rw [Prod.mk_sub_mk, sub_self]
      simp
    have step‚ÇÜ : 2*|(u (Œ≥ t).fst - (Œ≥ t).snd)| * (Ka * M + Kc) * ‚Äñ(Œ≥ t).snd - u (Œ≥ t).fst‚Äñ
      = (2 * (Ka * M + Kc)) * |(u (Œ≥ t).fst - (Œ≥ t).snd)|^2 := by
      rw [Real.norm_eq_abs,  abs_sub_comm (Œ≥ t).2]
      ring
    have step‚Çá : (2 * (Ka * M + Kc)) * |(u (Œ≥ t).fst - (Œ≥ t).snd)|^2 = (2 * (Ka * M + Kc)) * ‚Äñ(Œî Œ≥ u) t‚Äñ := by
      rw [Œî, Real.norm_eq_abs, abs_of_nonneg (sq_nonneg |u (Œ≥ t).1 - (Œ≥ t).2|)]
    rw [‚Üêstep‚Çá, ‚Üêstep‚ÇÜ, ‚Üêstep‚ÇÖ, ‚Üêstep‚ÇÑ]
    apply le_trans step‚ÇÅ (le_trans step‚ÇÇ step‚ÇÉ)

/--
If `u` is a solution to quasilinear PDE `E : a‚ÇÅ ‚àÇ‚ÇÅu + ... + a‚Çô ‚àÇ‚Çôu = c` and `Œ≥ = (X, U)`
is a characteristic curve of `E` such that `U(t‚ÇÄ) = u(X(t‚ÇÄ))` then the composite `u ‚àò X` satisfies `d/dt (u ‚àò X) = U`
for `t‚ÇÄ ‚â§ t`
-/
theorem solution_constant_characteristic_aux_t‚ÇÄ_le (hs' : IsConnected s) (t‚ÇÄ : ‚Ñù) (ht‚ÇÄ : t‚ÇÄ ‚àà s)
    (huGrad : ContinuousOn (fderiv ‚Ñù u) ((Prod.fst ‚àò Œ≥)''s))
    (hŒ≥‚ÇÅ : (Œ≥ t‚ÇÄ).snd = u (Œ≥ t‚ÇÄ).fst)
    (t : ‚Ñù) (ht : t ‚àà s) (ht‚ÇÄ' : t‚ÇÄ ‚â§ t) :
    u (Œ≥ t).fst = (Œ≥ t).snd := by
  by_contra! Ht
  let Œµ := sSup {œÑ : ‚Ñù | œÑ ‚àà s ‚àß œÑ ‚â§ t ‚àß Œî Œ≥ u œÑ = 0}
  let ‚ü®Œµ_mem, Œµ_le, Œî_Œµ‚ü© := csSup_zero_set hŒ≥ hu' hs' ht‚ÇÄ hŒ≥‚ÇÅ ht ht‚ÇÄ'
  obtain ‚ü®r, hr, hr', ‚ü®C, hC‚ü©‚ü© := Œî_deriv_norm_le hŒ≥‚ÇÇ hu hŒ≥ hu' hs hE huGrad Œµ Œµ_mem (Œî_eq_zero_iff.mp Œî_Œµ).symm
  obtain ‚ü®œÑ, hœÑ, hœÑ', hœÑ''‚ü© : ‚àÉ œÑ, œÑ ‚àà s ‚àß Œµ < œÑ ‚àß
    ‚àÄ t ‚àà Set.Icc Œµ œÑ, Œî Œ≥ u t = 0 := by
    use (Œµ + r)
    have h‚ÇÅ : Œµ < Œµ + r := by linarith
    have h‚ÇÇ : Set.Icc Œµ (Œµ + r) ‚äÜ s := by
      apply subset_trans (Set.Icc_subset_Icc_left (by linarith)) hr'
    refine ‚ü®h‚ÇÇ (Set.right_mem_Icc.mpr <| le_of_lt <| h‚ÇÅ), h‚ÇÅ, ?_‚ü©
    intro v hv
    apply eq_zero_of_abs_deriv_le_mul_abs_self_of_eq_zero_left (K:=C) (¬´a¬ª := Œµ) (b := Œµ+r) ?_ (fun x hx => DifferentiableWithinAt.hasDerivWithinAt ?_) Œî_Œµ
    ¬∑ intro x hx
      rw [DifferentiableAt.derivWithin (Œî_diff hŒ≥‚ÇÇ hu _) (uniqueDiffWithinAt_Ici _)]
      apply hC x <|  Set.Icc_subset_Icc_left (by linarith) (Set.Ico_subset_Icc_self hx)
      apply h‚ÇÇ (Set.Ico_subset_Icc_self hx)
    ¬∑ apply hv
    ¬∑ apply (Œî_cts hŒ≥ hu').mono h‚ÇÇ
    ¬∑ apply DifferentiableAt.differentiableWithinAt
      apply Œî_diff hŒ≥‚ÇÇ hu (h‚ÇÇ (Set.Ico_subset_Icc_self hx))
  by_cases hœÑ''' : œÑ < t
  ¬∑ apply (lt_iff_not_le.mp hœÑ')
    refine le_csSup ?_ ‚ü®hœÑ, le_of_lt hœÑ''', hœÑ'' œÑ (Set.right_mem_Icc.mpr <| le_of_lt hœÑ')‚ü©
    use t
    intro v hv
    exact hv.right.left
  ¬∑ apply Ht
    rw [‚ÜêŒî_eq_zero_iff]
    apply hœÑ''
    rw [Set.mem_Icc]
    refine ‚ü®Œµ_le, le_of_not_lt hœÑ'''‚ü©

/--
If `u` is a solution to quasilinear PDE `E : a‚ÇÅ ‚àÇ‚ÇÅu + ... + a‚Çô ‚àÇ‚Çôu = c` and `Œ≥ = (X, U)`
is a characteristic curve of `E` such that `U(t‚ÇÄ) = u(X(t‚ÇÄ))` then the composite `u ‚àò X` satisfies `d/dt (u ‚àò X) = U`
for `t‚ÇÄ ‚â• t`
-/
theorem solution_constant_characteristic_aux_t‚ÇÄ_ge (hs' : IsConnected s) (t‚ÇÄ : ‚Ñù) (ht‚ÇÄ : t‚ÇÄ ‚àà s)
    (huGrad : ContinuousOn (fderiv ‚Ñù u) ((Prod.fst ‚àò Œ≥)''s))
    (hŒ≥‚ÇÅ : (Œ≥ t‚ÇÄ).snd = u (Œ≥ t‚ÇÄ).fst)
    (t : ‚Ñù) (ht : t ‚àà s) (ht‚ÇÄ' : t ‚â§ t‚ÇÄ) :
    u (Œ≥ t).fst = (Œ≥ t).snd := by
  by_contra! Ht
  let Œµ := sInf {œÑ : ‚Ñù | œÑ ‚àà s ‚àß t ‚â§ œÑ ‚àß Œî Œ≥ u œÑ = 0}
  let ‚ü®Œµ_mem, Œµ_ge, Œî_Œµ‚ü© := csInf_zero_set hŒ≥ hu' hs' ht‚ÇÄ hŒ≥‚ÇÅ ht ht‚ÇÄ'
  obtain ‚ü®r, hr, hr', ‚ü®C, hC‚ü©‚ü© := Œî_deriv_norm_le hŒ≥‚ÇÇ hu hŒ≥ hu' hs hE huGrad Œµ Œµ_mem (Œî_eq_zero_iff.mp Œî_Œµ).symm
  obtain ‚ü®œÑ, hœÑ, hœÑ', hœÑ''‚ü© : ‚àÉ œÑ, œÑ ‚àà s ‚àß œÑ < Œµ ‚àß
    ‚àÄ t ‚àà Set.Icc œÑ Œµ, Œî Œ≥ u t = 0 := by
    use (Œµ - r)
    have h‚ÇÅ : Œµ - r < Œµ := by linarith
    have h‚ÇÇ : Set.Icc (Œµ-r) Œµ ‚äÜ s := by
      apply subset_trans (Set.Icc_subset_Icc_right (by linarith)) hr'
    refine ‚ü®h‚ÇÇ (Set.left_mem_Icc.mpr <| le_of_lt <| h‚ÇÅ), h‚ÇÅ, ?_‚ü©
    intro v hv
    apply eq_zero_of_abs_deriv_le_mul_abs_self_of_eq_zero_right (K:=C) (¬´a¬ª := Œµ-r) (b := Œµ) ?_ (fun x hx => DifferentiableWithinAt.hasDerivWithinAt ?_) Œî_Œµ
    ¬∑ intro x hx
      rw [DifferentiableAt.derivWithin (Œî_diff hŒ≥‚ÇÇ hu _) (uniqueDiffWithinAt_Iic _)]
      apply hC x <|  Set.Icc_subset_Icc_right (by linarith) (Set.Ioc_subset_Icc_self hx)
      apply h‚ÇÇ (Set.Ioc_subset_Icc_self hx)
    ¬∑ apply hv
    ¬∑ apply (Œî_cts hŒ≥ hu').mono h‚ÇÇ
    ¬∑ apply DifferentiableAt.differentiableWithinAt
      apply Œî_diff hŒ≥‚ÇÇ hu (h‚ÇÇ (Set.Ioc_subset_Icc_self hx))
  by_cases hœÑ''' : t < œÑ
  ¬∑ apply (lt_iff_not_le.mp hœÑ')
    refine csInf_le ?_ ‚ü®hœÑ, le_of_lt hœÑ''', hœÑ'' œÑ (Set.left_mem_Icc.mpr <| le_of_lt hœÑ')‚ü©
    use t
    intro v hv
    exact hv.right.left
  ¬∑ apply Ht
    rw [‚ÜêŒî_eq_zero_iff]
    apply hœÑ''
    rw [Set.mem_Icc]
    refine ‚ü®le_of_not_lt hœÑ''', Œµ_ge‚ü©

/--
If `u` is a solution to quasilinear PDE `E : a‚ÇÅ ‚àÇ‚ÇÅu + ... + a‚Çô ‚àÇ‚Çôu = c` and `Œ≥ = (X, U)`
is a characteristic curve of `E` such that `U(t‚ÇÄ) = u(X(t‚ÇÄ))` then the composite `u ‚àò X` satisfies `d/dt (u ‚àò X) = U`
for `t`
-/
theorem solution_constant_characteristic (hs' : IsConnected s) (t‚ÇÄ : ‚Ñù) (ht‚ÇÄ : t‚ÇÄ ‚àà s)
    (huGrad : ContinuousOn (fderiv ‚Ñù u) ((Prod.fst ‚àò Œ≥)''s))
    (hŒ≥‚ÇÅ : (Œ≥ t‚ÇÄ).snd = u (Œ≥ t‚ÇÄ).fst)
    (t : ‚Ñù) (ht : t ‚àà s) : u (Œ≥ t).fst = (Œ≥ t).snd := by
  rcases le_total t t‚ÇÄ with ht‚ÇÄ' | ht‚ÇÄ'
  ¬∑ apply solution_constant_characteristic_aux_t‚ÇÄ_ge hŒ≥‚ÇÇ hu hŒ≥ hu' hs hE hs' t‚ÇÄ ht‚ÇÄ huGrad hŒ≥‚ÇÅ t ht ht‚ÇÄ'
  ¬∑ apply solution_constant_characteristic_aux_t‚ÇÄ_le hŒ≥‚ÇÇ hu hŒ≥ hu' hs hE hs' t‚ÇÄ ht‚ÇÄ huGrad hŒ≥‚ÇÅ t ht ht‚ÇÄ'

end MainTheorem


variable {ùïú V : Type*} [NormedAddCommGroup V] [NormedSpace ‚Ñù V]
variable {Œ≥ : ‚Ñù ‚Üí V √ó ‚Ñù} {u : V ‚Üí ‚Ñù}  {E : FirstOrderQuasiLinearPDE ‚Ñù V}

theorem solution_constant_characteristic_univ
    (hŒ≥‚ÇÇ : ‚àÄ t, E.HasCharacteristicAt Œ≥ t) (hu : ‚àÄ t, E.HasSolutionAt u (Œ≥ t).1) (hŒ≥ : Continuous Œ≥)
    (hu' : Continuous u) (hE : E.RegularBy (ContDiff ‚Ñù 1)) (t‚ÇÄ : ‚Ñù)
    (huGrad : ContinuousOn (fderiv ‚Ñù u) (Prod.fst ‚àò Œ≥ '' Set.univ)) (hŒ≥‚ÇÅ : (Œ≥ t‚ÇÄ).2 = u (Œ≥ t‚ÇÄ).1) (t : ‚Ñù) :
    u (Œ≥ t).1 = (Œ≥ t).2 :=
  solution_constant_characteristic (fun t _ => hŒ≥‚ÇÇ t) (fun t _ => hu t)
    hŒ≥ hu' isOpen_univ hE isConnected_univ t‚ÇÄ (Set.mem_univ _) huGrad hŒ≥‚ÇÅ t (Set.mem_univ _)
