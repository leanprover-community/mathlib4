/-
Copyright (c) 2022 Jireh Loreaux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jireh Loreaux

! This file was ported from Lean 3 source module analysis.normed_space.star.gelfand_duality
! leanprover-community/mathlib commit e65771194f9e923a70dfb49b6ca7be6e400d8b6f
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathlib.Analysis.NormedSpace.Star.Spectrum
import Mathlib.Analysis.Normed.Group.Quotient
import Mathlib.Analysis.NormedSpace.Algebra
import Mathlib.Topology.ContinuousFunction.Units
import Mathlib.Topology.ContinuousFunction.Compact
import Mathlib.Topology.Algebra.Algebra
import Mathlib.Topology.ContinuousFunction.StoneWeierstrass

/-!
# Gelfand Duality

The `gelfandTransform` is an algebra homomorphism from a topological `ùïú`-algebra `A` to
`C(character_space ùïú A, ùïú)`. In the case where `A` is a commutative complex Banach algebra, then
the Gelfand transform is actually spectrum-preserving (`spectrum.gelfandTransform_eq`). Moreover,
when `A` is a commutative C‚ãÜ-algebra over `‚ÑÇ`, then the Gelfand transform is a surjective isometry,
and even an equivalence between C‚ãÜ-algebras.

## Main definitions

* `Ideal.toCharacterSpace` : constructs an element of the character space from a maximal ideal in
  a commutative complex Banach algebra
* `WeakDual.CharacterSpace.compContinuousMap`: The functorial map taking `œà : A ‚Üí‚ãÜ‚Çê[‚ÑÇ] B` to a
  continuous function `characterSpace ‚ÑÇ B ‚Üí characterSpace ‚ÑÇ A` given by pre-composition with `œà`.

## Main statements

* `spectrum.gelfandTransform_eq` : the Gelfand transform is spectrum-preserving when the algebra is
  a commutative complex Banach algebra.
* `gelfandTransform_isometry` : the Gelfand transform is an isometry when the algebra is a
  commutative (unital) C‚ãÜ-algebra over `‚ÑÇ`.
* `gelfandTransform_bijective` : the Gelfand transform is bijective when the algebra is a
  commutative (unital) C‚ãÜ-algebra over `‚ÑÇ`.

## TODO

* After `StarAlgEquiv` is defined, realize `gelfandTransform` as a `StarAlgEquiv`.
* Prove that if `A` is the unital C‚ãÜ-algebra over `‚ÑÇ` generated by a fixed normal element `x` in
  a larger C‚ãÜ-algebra `B`, then `characterSpace ‚ÑÇ A` is homeomorphic to `spectrum ‚ÑÇ x`.
* From the previous result, construct the **continuous functional calculus**.
* Show that if `X` is a compact Hausdorff space, then `X` is (canonically) homeomorphic to
  `characterSpace ‚ÑÇ C(X, ‚ÑÇ)`.
* Conclude using the previous fact that the functors `C(‚¨ù, ‚ÑÇ)` and `characterSpace ‚ÑÇ ‚¨ù` along with
  the canonical homeomorphisms described above constitute a natural contravariant equivalence of
  the categories of compact Hausdorff spaces (with continuous maps) and commutative unital
  C‚ãÜ-algebras (with unital ‚ãÜ-algebra homomorphisms); this is known as **Gelfand duality**.

## Tags

Gelfand transform, character space, C‚ãÜ-algebra
-/


open WeakDual

open scoped NNReal

section ComplexBanachAlgebra

open Ideal

variable {A : Type _} [NormedCommRing A] [NormedAlgebra ‚ÑÇ A] [CompleteSpace A] (I : Ideal A)
  [Ideal.IsMaximal I]

/-- Every maximal ideal in a commutative complex Banach algebra gives rise to a character on that
algebra. In particular, the character, which may be identified as an algebra homomorphism due to
`WeakDual.CharacterSpace.equivAlgHom`, is given by the composition of the quotient map and
the Gelfand-Mazur isomorphism `NormedRing.algEquivComplexOfComplete`. -/
noncomputable def Ideal.toCharacterSpace : characterSpace ‚ÑÇ A :=
  CharacterSpace.equivAlgHom.symm <|
    ((NormedRing.algEquivComplexOfComplete
      (letI := Quotient.field I; isUnit_iff_ne_zero (G‚ÇÄ := A ‚ß∏ I))).symm : A ‚ß∏ I ‚Üí‚Çê[‚ÑÇ] ‚ÑÇ).comp <|
    Quotient.mk‚Çê ‚ÑÇ I
#align ideal.to_character_space Ideal.toCharacterSpace

theorem Ideal.toCharacterSpace_apply_eq_zero_of_mem {a : A} (ha : a ‚àà I) :
    I.toCharacterSpace a = 0 := by
  unfold Ideal.toCharacterSpace
  simp only [CharacterSpace.equivAlgHom_symm_coe, AlgHom.coe_comp, AlgHom.coe_coe,
    Quotient.mk‚Çê_eq_mk, Function.comp_apply, NormedRing.algEquivComplexOfComplete_symm_apply]
  simp_rw [Quotient.eq_zero_iff_mem.mpr ha, spectrum.zero_eq]
  exact Set.eq_of_mem_singleton (Set.singleton_nonempty (0 : ‚ÑÇ)).some_mem
#align ideal.to_character_space_apply_eq_zero_of_mem Ideal.toCharacterSpace_apply_eq_zero_of_mem

/-- If `a : A` is not a unit, then some character takes the value zero at `a`. This is equivalent
to `gelfandTransform ‚ÑÇ A a` takes the value zero at some character. -/
theorem WeakDual.CharacterSpace.exists_apply_eq_zero {a : A} (ha : ¬¨IsUnit a) :
    ‚àÉ f : characterSpace ‚ÑÇ A, f a = 0 := by
  obtain ‚ü®M, hM, haM‚ü© := (span {a}).exists_le_maximal (span_singleton_ne_top ha)
  exact
    ‚ü®M.toCharacterSpace,
      M.toCharacterSpace_apply_eq_zero_of_mem
        (haM (mem_span_singleton.mpr ‚ü®1, (mul_one a).symm‚ü©))‚ü©
#align weak_dual.character_space.exists_apply_eq_zero WeakDual.CharacterSpace.exists_apply_eq_zero

theorem WeakDual.CharacterSpace.mem_spectrum_iff_exists {a : A} {z : ‚ÑÇ} :
    z ‚àà spectrum ‚ÑÇ a ‚Üî ‚àÉ f : characterSpace ‚ÑÇ A, f a = z := by
  refine' ‚ü®fun hz => _, _‚ü©
  ¬∑ obtain ‚ü®f, hf‚ü© := WeakDual.CharacterSpace.exists_apply_eq_zero hz
    simp only [map_sub, sub_eq_zero, AlgHomClass.commutes, Algebra.id.map_eq_id,
      RingHom.id_apply] at hf
    refine ‚ü®f, ?_‚ü©
    rw [AlgHomClass.commutes, Algebra.id.map_eq_id, RingHom.id_apply] at hf
    exact hf.symm
  ¬∑ rintro ‚ü®f, rfl‚ü©
    exact AlgHom.apply_mem_spectrum f a
#align weak_dual.character_space.mem_spectrum_iff_exists WeakDual.CharacterSpace.mem_spectrum_iff_exists

/-- The Gelfand transform is spectrum-preserving. -/
theorem spectrum.gelfandTransform_eq (a : A) :
    spectrum ‚ÑÇ (gelfandTransform ‚ÑÇ A a) = spectrum ‚ÑÇ a := by
  ext z
  rw [ContinuousMap.spectrum_eq_range, WeakDual.CharacterSpace.mem_spectrum_iff_exists]
  exact Iff.rfl
#align spectrum.gelfand_transform_eq spectrum.gelfandTransform_eq

instance [Nontrivial A] : Nonempty (characterSpace ‚ÑÇ A) :=
  ‚ü®Classical.choose <|
      WeakDual.CharacterSpace.exists_apply_eq_zero <| zero_mem_nonunits.2 zero_ne_one‚ü©

end ComplexBanachAlgebra

section ComplexCstarAlgebra

variable {A : Type _} [NormedCommRing A] [NormedAlgebra ‚ÑÇ A] [CompleteSpace A]

variable [StarRing A] [CstarRing A] [StarModule ‚ÑÇ A]

theorem gelfandTransform_map_star (a : A) :
    gelfandTransform ‚ÑÇ A (star a) = star (gelfandTransform ‚ÑÇ A a) :=
  ContinuousMap.ext fun œÜ => map_star œÜ a
#align gelfand_transform_map_star gelfandTransform_map_star

variable (A)

/-- The Gelfand transform is an isometry when the algebra is a C‚ãÜ-algebra over `‚ÑÇ`. -/
theorem gelfandTransform_isometry : Isometry (gelfandTransform ‚ÑÇ A) := by
  nontriviality A
  refine' AddMonoidHomClass.isometry_of_norm (gelfandTransform ‚ÑÇ A) fun a => _
  /- By `spectrum.gelfandTransform_eq`, the spectra of `star a * a` and its
    `gelfandTransform` coincide. Therefore, so do their spectral radii, and since they are
    self-adjoint, so also do their norms. Applying the C‚ãÜ-property of the norm and taking square
    roots shows that the norm is preserved. -/
  have : spectralRadius ‚ÑÇ (gelfandTransform ‚ÑÇ A (star a * a)) = spectralRadius ‚ÑÇ (star a * a) := by
    unfold spectralRadius; rw [spectrum.gelfandTransform_eq]
  rw [map_mul, (IsSelfAdjoint.star_mul_self _).spectralRadius_eq_nnnorm, gelfandTransform_map_star,
    (IsSelfAdjoint.star_mul_self (gelfandTransform ‚ÑÇ A a)).spectralRadius_eq_nnnorm] at this
  simp only [ENNReal.coe_eq_coe, CstarRing.nnnorm_star_mul_self, ‚Üê sq] at this
  simpa only [Function.comp_apply, NNReal.sqrt_sq] using
    congr_arg (((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù) ‚àò ‚áëNNReal.sqrt) this
#align gelfand_transform_isometry gelfandTransform_isometry

/-- The Gelfand transform is bijective when the algebra is a C‚ãÜ-algebra over `‚ÑÇ`. -/
theorem gelfandTransform_bijective : Function.Bijective (gelfandTransform ‚ÑÇ A) := by
  refine' ‚ü®(gelfandTransform_isometry A).injective, _‚ü©
  suffices (gelfandTransform ‚ÑÇ A).range = ‚ä§ by
    exact fun x => ((gelfandTransform ‚ÑÇ A).mem_range).mp (this.symm ‚ñ∏ Algebra.mem_top)
  /- Because the `gelfandTransform ‚ÑÇ A` is an isometry, it has closed range, and so by the
    Stone-Weierstrass theorem, it suffices to show that the image of the Gelfand transform separates
    points in `C(characterSpace ‚ÑÇ A, ‚ÑÇ)` and is closed under `star`. -/
  have h : (gelfandTransform ‚ÑÇ A).range.topologicalClosure = (gelfandTransform ‚ÑÇ A).range :=
    le_antisymm
      (Subalgebra.topologicalClosure_minimal _ le_rfl
        (gelfandTransform_isometry A).closedEmbedding.closed_range)
      (Subalgebra.le_topologicalClosure _)
  refine' h ‚ñ∏ ContinuousMap.subalgebra_isROrC_topologicalClosure_eq_top_of_separatesPoints
    _ (fun _ _ => _) fun f hf => _
  /- Separating points just means that elements of the `characterSpace` which agree at all points
    of `A` are the same functional, which is just extensionality. -/
  ¬∑ contrapose!
    exact fun h => Subtype.ext (ContinuousLinearMap.ext fun a =>
      h (gelfandTransform ‚ÑÇ A a) ‚ü®gelfandTransform ‚ÑÇ A a, ‚ü®a, rfl‚ü©, rfl‚ü©)
  /- If `f = gelfandTransform ‚ÑÇ A a`, then `star f` is also in the range of `gelfandTransform ‚ÑÇ A`
    using the argument `star a`. The key lemma below may be hard to spot; it's `map_star` coming
    from `WeakDual.Complex.instStarHomClass`, which is a nontrivial result. -/
  ¬∑ obtain ‚ü®f, ‚ü®a, rfl‚ü©, rfl‚ü© := Subalgebra.mem_map.mp hf
    refine' ‚ü®star a, ContinuousMap.ext fun œà => _‚ü©
    simp only [AlgHom.toRingHom_eq_coe, RingHom.coe_coe, gelfandTransform_apply_apply,
      AlgEquiv.toAlgHom_eq_coe, AlgHom.compLeftContinuous_apply_apply, AlgHom.coe_coe,
      IsROrC.conjAe_coe, map_star, starRingEnd_apply]
#align gelfand_transform_bijective gelfandTransform_bijective

/-- The Gelfand transform as a `StarAlgEquiv` between a commutative unital C‚ãÜ-algebra over `‚ÑÇ`
and the continuous functions on its `characterSpace`. -/
@[simps!]
noncomputable def gelfandStarTransform : A ‚âÉ‚ãÜ‚Çê[‚ÑÇ] C(characterSpace ‚ÑÇ A, ‚ÑÇ) :=
  StarAlgEquiv.ofBijective
    (show A ‚Üí‚ãÜ‚Çê[‚ÑÇ] C(characterSpace ‚ÑÇ A, ‚ÑÇ) from
      { gelfandTransform ‚ÑÇ A with map_star' := fun x => gelfandTransform_map_star x })
    (gelfandTransform_bijective A)
#align gelfand_star_transform gelfandStarTransform

end ComplexCstarAlgebra

section Functoriality

namespace WeakDual

namespace CharacterSpace

variable {A B C : Type _}

variable [NormedRing A] [NormedAlgebra ‚ÑÇ A] [CompleteSpace A] [StarRing A]

variable [NormedRing B] [NormedAlgebra ‚ÑÇ B] [CompleteSpace B] [StarRing B]

variable [NormedRing C] [NormedAlgebra ‚ÑÇ C] [CompleteSpace C] [StarRing C]

/-- The functorial map taking `œà : A ‚Üí‚ãÜ‚Çê[‚ÑÇ] B` to a continuous function
`characterSpace ‚ÑÇ B ‚Üí characterSpace ‚ÑÇ A` obtained by pre-composition with `œà`. -/
@[simps]
noncomputable def compContinuousMap (œà : A ‚Üí‚ãÜ‚Çê[‚ÑÇ] B) : C(characterSpace ‚ÑÇ B, characterSpace ‚ÑÇ A)
    where
  toFun œÜ := equivAlgHom.symm ((equivAlgHom œÜ).comp œà.toAlgHom)
  continuous_toFun :=
    Continuous.subtype_mk
      (continuous_of_continuous_eval fun a => map_continuous <| gelfandTransform ‚ÑÇ B (œà a)) _
#align weak_dual.character_space.comp_continuous_map WeakDual.CharacterSpace.compContinuousMap

variable (A)

/-- `WeakDual.CharacterSpace.compContinuousMap` sends the identity to the identity. -/
@[simp]
theorem compContinuousMap_id :
    compContinuousMap (StarAlgHom.id ‚ÑÇ A) = ContinuousMap.id (characterSpace ‚ÑÇ A) :=
  ContinuousMap.ext fun _a => ext fun _x => rfl
#align weak_dual.character_space.comp_continuous_map_id WeakDual.CharacterSpace.compContinuousMap_id

variable {A}

/-- `WeakDual.CharacterSpace.compContinuousMap` is functorial. -/
@[simp]
theorem compContinuousMap_comp (œà‚ÇÇ : B ‚Üí‚ãÜ‚Çê[‚ÑÇ] C) (œà‚ÇÅ : A ‚Üí‚ãÜ‚Çê[‚ÑÇ] B) :
    compContinuousMap (œà‚ÇÇ.comp œà‚ÇÅ) = (compContinuousMap œà‚ÇÅ).comp (compContinuousMap œà‚ÇÇ) :=
  ContinuousMap.ext fun _a => ext fun _x => rfl
#align weak_dual.character_space.comp_continuous_map_comp WeakDual.CharacterSpace.compContinuousMap_comp

end CharacterSpace

end WeakDual

end Functoriality
