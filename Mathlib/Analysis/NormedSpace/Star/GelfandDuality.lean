/-
Copyright (c) 2022 Jireh Loreaux. All rights reserved.
Reeased under Apache 2.0 license as described in the file LICENSE.
Authors: Jireh Loreaux

! This file was ported from Lean 3 source module analysis.normed_space.star.gelfand_duality
! leanprover-community/mathlib commit e65771194f9e923a70dfb49b6ca7be6e400d8b6f
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.NormedSpace.Star.Spectrum
import Mathbin.Analysis.Normed.Group.Quotient
import Mathbin.Analysis.NormedSpace.Algebra
import Mathbin.Topology.ContinuousFunction.Units
import Mathbin.Topology.ContinuousFunction.Compact
import Mathbin.Topology.Algebra.Algebra
import Mathbin.Topology.ContinuousFunction.StoneWeierstrass

/-!
# Gelfand Duality

The `gelfand_transform` is an algebra homomorphism from a topological `ùïú`-algebra `A` to
`C(character_space ùïú A, ùïú)`. In the case where `A` is a commutative complex Banach algebra, then
the Gelfand transform is actually spectrum-preserving (`spectrum.gelfand_transform_eq`). Moreover,
when `A` is a commutative C‚ãÜ-algebra over `‚ÑÇ`, then the Gelfand transform is a surjective isometry,
and even an equivalence between C‚ãÜ-algebras.

## Main definitions

* `ideal.to_character_space` : constructs an element of the character space from a maximal ideal in
  a commutative complex Banach algebra
* `weak_dual.character_space.comp_continuous_map`: The functorial map taking `œà : A ‚Üí‚ãÜ‚Çê[‚ÑÇ] B` to a
  continuous function `character_space ‚ÑÇ B ‚Üí character_space ‚ÑÇ A` given by pre-composition with `œà`.

## Main statements

* `spectrum.gelfand_transform_eq` : the Gelfand transform is spectrum-preserving when the algebra is
  a commutative complex Banach algebra.
* `gelfand_transform_isometry` : the Gelfand transform is an isometry when the algebra is a
  commutative (unital) C‚ãÜ-algebra over `‚ÑÇ`.
* `gelfand_transform_bijective` : the Gelfand transform is bijective when the algebra is a
  commutative (unital) C‚ãÜ-algebra over `‚ÑÇ`.

## TODO

* After `star_alg_equiv` is defined, realize `gelfand_transform` as a `star_alg_equiv`.
* Prove that if `A` is the unital C‚ãÜ-algebra over `‚ÑÇ` generated by a fixed normal element `x` in
  a larger C‚ãÜ-algebra `B`, then `character_space ‚ÑÇ A` is homeomorphic to `spectrum ‚ÑÇ x`.
* From the previous result, construct the **continuous functional calculus**.
* Show that if `X` is a compact Hausdorff space, then `X` is (canonically) homeomorphic to
  `character_space ‚ÑÇ C(X, ‚ÑÇ)`.
* Conclude using the previous fact that the functors `C(‚¨ù, ‚ÑÇ)` and `character_space ‚ÑÇ ‚¨ù` along with
  the canonical homeomorphisms described above constitute a natural contravariant equivalence of
  the categories of compact Hausdorff spaces (with continuous maps) and commutative unital
  C‚ãÜ-algebras (with unital ‚ãÜ-algebra homomoprhisms); this is known as **Gelfand duality**.

## Tags

Gelfand transform, character space, C‚ãÜ-algebra
-/


open WeakDual

open scoped NNReal

section ComplexBanachAlgebra

open Ideal

variable {A : Type _} [NormedCommRing A] [NormedAlgebra ‚ÑÇ A] [CompleteSpace A] (I : Ideal A)
  [Ideal.IsMaximal I]

/-- Every maximal ideal in a commutative complex Banach algebra gives rise to a character on that
algebra. In particular, the character, which may be identified as an algebra homomorphism due to
`weak_dual.character_space.equiv_alg_hom`, is given by the composition of the quotient map and
the Gelfand-Mazur isomorphism `normed_ring.alg_equiv_complex_of_complete`. -/
noncomputable def Ideal.toCharacterSpace : characterSpace ‚ÑÇ A :=
  characterSpace.equivAlgHom.symm <|
    ((@NormedRing.algEquivComplexOfComplete (A ‚ß∏ I) _ _
              (letI := quotient.field I
              @isUnit_iff_ne_zero (A ‚ß∏ I) _)
              _).symm :
          A ‚ß∏ I ‚Üí‚Çê[‚ÑÇ] ‚ÑÇ).comp
      (Quotient.mk‚Çê ‚ÑÇ I)
#align ideal.to_character_space Ideal.toCharacterSpace

theorem Ideal.toCharacterSpace_apply_eq_zero_of_mem {a : A} (ha : a ‚àà I) :
    I.toCharacterSpace a = 0 := by
  unfold Ideal.toCharacterSpace
  simpa only [character_space.equiv_alg_hom_symm_coe, AlgHom.coe_comp, AlgEquiv.coe_algHom,
    quotient.mk‚Çê_eq_mk, Function.comp_apply, quotient.eq_zero_iff_mem.mpr ha, spectrum.zero_eq,
    NormedRing.algEquivComplexOfComplete_symm_apply] using
    Set.eq_of_mem_singleton (Set.singleton_nonempty (0 : ‚ÑÇ)).some_mem
#align ideal.to_character_space_apply_eq_zero_of_mem Ideal.toCharacterSpace_apply_eq_zero_of_mem

/-- If `a : A` is not a unit, then some character takes the value zero at `a`. This is equivlaent
to `gelfand_transform ‚ÑÇ A a` takes the value zero at some character. -/
theorem WeakDual.characterSpace.exists_apply_eq_zero {a : A} (ha : ¬¨IsUnit a) :
    ‚àÉ f : characterSpace ‚ÑÇ A, f a = 0 :=
  by
  obtain ‚ü®M, hM, haM‚ü© := (span {a}).exists_le_maximal (span_singleton_ne_top ha)
  exact
    ‚ü®M.to_character_space,
      M.to_character_space_apply_eq_zero_of_mem
        (haM (mem_span_singleton.mpr ‚ü®1, (mul_one a).symm‚ü©))‚ü©
#align weak_dual.character_space.exists_apply_eq_zero WeakDual.characterSpace.exists_apply_eq_zero

theorem WeakDual.characterSpace.mem_spectrum_iff_exists {a : A} {z : ‚ÑÇ} :
    z ‚àà spectrum ‚ÑÇ a ‚Üî ‚àÉ f : characterSpace ‚ÑÇ A, f a = z :=
  by
  refine' ‚ü®fun hz => _, _‚ü©
  ¬∑ obtain ‚ü®f, hf‚ü© := WeakDual.characterSpace.exists_apply_eq_zero hz
    simp only [map_sub, sub_eq_zero, AlgHomClass.commutes, Algebra.id.map_eq_id,
      RingHom.id_apply] at hf 
    exact (ContinuousMap.spectrum_eq_range (gelfand_transform ‚ÑÇ A a)).symm ‚ñ∏ ‚ü®f, hf.symm‚ü©
  ¬∑ rintro ‚ü®f, rfl‚ü©
    exact AlgHom.apply_mem_spectrum f a
#align weak_dual.character_space.mem_spectrum_iff_exists WeakDual.characterSpace.mem_spectrum_iff_exists

/-- The Gelfand transform is spectrum-preserving. -/
theorem spectrum.gelfandTransform_eq (a : A) : spectrum ‚ÑÇ (gelfandTransform ‚ÑÇ A a) = spectrum ‚ÑÇ a :=
  by
  ext z
  rw [ContinuousMap.spectrum_eq_range, WeakDual.characterSpace.mem_spectrum_iff_exists]
  exact Iff.rfl
#align spectrum.gelfand_transform_eq spectrum.gelfandTransform_eq

instance [Nontrivial A] : Nonempty (characterSpace ‚ÑÇ A) :=
  ‚ü®Classical.choose <|
      WeakDual.characterSpace.exists_apply_eq_zero <| zero_mem_nonunits.2 zero_ne_one‚ü©

end ComplexBanachAlgebra

section ComplexCstarAlgebra

variable {A : Type _} [NormedCommRing A] [NormedAlgebra ‚ÑÇ A] [CompleteSpace A]

variable [StarRing A] [CstarRing A] [StarModule ‚ÑÇ A]

theorem gelfandTransform_map_star (a : A) :
    gelfandTransform ‚ÑÇ A (star a) = star (gelfandTransform ‚ÑÇ A a) :=
  ContinuousMap.ext fun œÜ => map_star œÜ a
#align gelfand_transform_map_star gelfandTransform_map_star

variable (A)

/-- The Gelfand transform is an isometry when the algebra is a C‚ãÜ-algebra over `‚ÑÇ`. -/
theorem gelfandTransform_isometry : Isometry (gelfandTransform ‚ÑÇ A) :=
  by
  nontriviality A
  refine' AddMonoidHomClass.isometry_of_norm (gelfand_transform ‚ÑÇ A) fun a => _
  /- By `spectrum.gelfand_transform_eq`, the spectra of `star a * a` and its
    `gelfand_transform` coincide. Therefore, so do their spectral radii, and since they are
    self-adjoint, so also do their norms. Applying the C‚ãÜ-property of the norm and taking square
    roots shows that the norm is preserved. -/
  have : spectralRadius ‚ÑÇ (gelfand_transform ‚ÑÇ A (star a * a)) = spectralRadius ‚ÑÇ (star a * a) := by
    unfold spectralRadius; rw [spectrum.gelfandTransform_eq]
  simp only [map_mul, (IsSelfAdjoint.star_mul_self _).spectralRadius_eq_nnnorm,
    gelfandTransform_map_star a, ENNReal.coe_eq_coe, CstarRing.nnnorm_star_mul_self, ‚Üê sq] at this 
  simpa only [Function.comp_apply, NNReal.sqrt_sq] using
    congr_arg ((coe : ‚Ñù‚â•0 ‚Üí ‚Ñù) ‚àò ‚áëNNReal.sqrt) this
#align gelfand_transform_isometry gelfandTransform_isometry

/-- The Gelfand transform is bijective when the algebra is a C‚ãÜ-algebra over `‚ÑÇ`. -/
theorem gelfandTransform_bijective : Function.Bijective (gelfandTransform ‚ÑÇ A) :=
  by
  refine' ‚ü®(gelfandTransform_isometry A).Injective, _‚ü©
  suffices (gelfand_transform ‚ÑÇ A).range = ‚ä§ by
    exact fun x => this.symm ‚ñ∏ (gelfand_transform ‚ÑÇ A).mem_range.mp (this.symm ‚ñ∏ Algebra.mem_top)
  /- Because the `gelfand_transform ‚ÑÇ A` is an isometry, it has closed range, and so by the
    Stone-Weierstrass theorem, it suffices to show that the image of the Gelfand transform separates
    points in `C(character_space ‚ÑÇ A, ‚ÑÇ)` and is closed under `star`. -/
  have h : (gelfand_transform ‚ÑÇ A).range.topologicalClosure = (gelfand_transform ‚ÑÇ A).range :=
    le_antisymm
      (Subalgebra.topologicalClosure_minimal _ le_rfl
        (gelfandTransform_isometry A).ClosedEmbedding.closed_range)
      (Subalgebra.le_topologicalClosure _)
  refine'
    h ‚ñ∏
      ContinuousMap.subalgebra_isROrC_topologicalClosure_eq_top_of_separatesPoints _ (fun _ _ => _)
        fun f hf => _
  /- Separating points just means that elements of the `character_space` which agree at all points
    of `A` are the same functional, which is just extensionality. -/
  ¬∑ contrapose!
    exact fun h =>
      Subtype.ext
        (ContinuousLinearMap.ext fun a =>
          h (gelfand_transform ‚ÑÇ A a) ‚ü®gelfand_transform ‚ÑÇ A a, ‚ü®a, rfl‚ü©, rfl‚ü©)
  /- If `f = gelfand_transform ‚ÑÇ A a`, then `star f` is also in the range of `gelfand_transform ‚ÑÇ A`
    using the argument `star a`. The key lemma below may be hard to spot; it's `map_star` coming from
    `weak_dual.star_hom_class`, which is a nontrivial result. -/
  ¬∑ obtain ‚ü®f, ‚ü®a, rfl‚ü©, rfl‚ü© := subalgebra.mem_map.mp hf
    refine' ‚ü®star a, ContinuousMap.ext fun œà => _‚ü©
    simpa only [gelfandTransform_map_star a, AlgHom.toRingHom_eq_coe, AlgHom.coe_toRingHom]
#align gelfand_transform_bijective gelfandTransform_bijective

/-- The Gelfand transform as a `star_alg_equiv` between a commutative unital C‚ãÜ-algebra over `‚ÑÇ`
and the continuous functions on its `character_space`. -/
@[simps]
noncomputable def gelfandStarTransform : A ‚âÉ‚ãÜ‚Çê[‚ÑÇ] C(characterSpace ‚ÑÇ A, ‚ÑÇ) :=
  StarAlgEquiv.ofBijective
    (show A ‚Üí‚ãÜ‚Çê[‚ÑÇ] C(characterSpace ‚ÑÇ A, ‚ÑÇ) from
      { gelfandTransform ‚ÑÇ A with map_star' := fun x => gelfandTransform_map_star x })
    (gelfandTransform_bijective A)
#align gelfand_star_transform gelfandStarTransform

end ComplexCstarAlgebra

section Functoriality

namespace WeakDual

namespace CharacterSpace

variable {A B C : Type _}

variable [NormedRing A] [NormedAlgebra ‚ÑÇ A] [CompleteSpace A] [StarRing A]

variable [NormedRing B] [NormedAlgebra ‚ÑÇ B] [CompleteSpace B] [StarRing B]

variable [NormedRing C] [NormedAlgebra ‚ÑÇ C] [CompleteSpace C] [StarRing C]

/-- The functorial map taking `œà : A ‚Üí‚ãÜ‚Çê[‚ÑÇ] B` to a continuous function
`character_space ‚ÑÇ B ‚Üí character_space ‚ÑÇ A` obtained by pre-composition with `œà`. -/
@[simps]
noncomputable def compContinuousMap (œà : A ‚Üí‚ãÜ‚Çê[‚ÑÇ] B) : C(characterSpace ‚ÑÇ B, characterSpace ‚ÑÇ A)
    where
  toFun œÜ := equivAlgHom.symm ((equivAlgHom œÜ).comp œà.toAlgHom)
  continuous_toFun :=
    Continuous.subtype_mk
      (continuous_of_continuous_eval fun a => map_continuous <| gelfandTransform ‚ÑÇ B (œà a)) _
#align weak_dual.character_space.comp_continuous_map WeakDual.characterSpace.compContinuousMap

variable (A)

/-- `weak_dual.character_space.comp_continuous_map` sends the identity to the identity. -/
@[simp]
theorem compContinuousMap_id :
    compContinuousMap (StarAlgHom.id ‚ÑÇ A) = ContinuousMap.id (characterSpace ‚ÑÇ A) :=
  ContinuousMap.ext fun a => ext fun x => rfl
#align weak_dual.character_space.comp_continuous_map_id WeakDual.characterSpace.compContinuousMap_id

variable {A}

/-- `weak_dual.character_space.comp_continuous_map` is functorial. -/
@[simp]
theorem compContinuousMap_comp (œà‚ÇÇ : B ‚Üí‚ãÜ‚Çê[‚ÑÇ] C) (œà‚ÇÅ : A ‚Üí‚ãÜ‚Çê[‚ÑÇ] B) :
    compContinuousMap (œà‚ÇÇ.comp œà‚ÇÅ) = (compContinuousMap œà‚ÇÅ).comp (compContinuousMap œà‚ÇÇ) :=
  ContinuousMap.ext fun a => ext fun x => rfl
#align weak_dual.character_space.comp_continuous_map_comp WeakDual.characterSpace.compContinuousMap_comp

end CharacterSpace

end WeakDual

end Functoriality

