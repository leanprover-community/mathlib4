/-
Copyright (c) 2021 Oliver Nash. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Oliver Nash
-/
import Mathlib.Analysis.NormedSpace.AffineIsometry
import Mathlib.Topology.Algebra.ContinuousAffineMap
import Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace

#align_import analysis.normed_space.continuous_affine_map from "leanprover-community/mathlib"@"17ef379e997badd73e5eabb4d38f11919ab3c4b3"

/-!
# Continuous affine maps between normed spaces.

This file develops the theory of continuous affine maps between affine spaces modelled on normed
spaces.

In the particular case that the affine spaces are just normed vector spaces `V`, `W`, we define a
norm on the space of continuous affine maps by defining the norm of `f : V ‚ÜíA[ùïú] W` to be
`‚Äñf‚Äñ = max ‚Äñf 0‚Äñ ‚Äñf.cont_linear‚Äñ`. This is chosen so that we have a linear isometry:
`(V ‚ÜíA[ùïú] W) ‚âÉ‚Çó·µ¢[ùïú] W √ó (V ‚ÜíL[ùïú] W)`.

The abstract picture is that for an affine space `P` modelled on a vector space `V`, together with
a vector space `W`, there is an exact sequence of `ùïú`-modules: `0 ‚Üí C ‚Üí A ‚Üí L ‚Üí 0` where `C`, `A`
are the spaces of constant and affine maps `P ‚Üí W` and `L` is the space of linear maps `V ‚Üí W`.

Any choice of a base point in `P` corresponds to a splitting of this sequence so in particular if we
take `P = V`, using `0 : V` as the base point provides a splitting, and we prove this is an
isometric decomposition.

On the other hand, choosing a base point breaks the affine invariance so the norm fails to be
submultiplicative: for a composition of maps, we have only `‚Äñf.comp g‚Äñ ‚â§ ‚Äñf‚Äñ * ‚Äñg‚Äñ + ‚Äñf 0‚Äñ`.

## Main definitions:

 * `ContinuousAffineMap.contLinear`
 * `ContinuousAffineMap.hasNorm`
 * `ContinuousAffineMap.norm_comp_le`
 * `ContinuousAffineMap.toConstProdContinuousLinearMap`

-/


namespace ContinuousAffineMap

variable {ùïú R V W W‚ÇÇ P Q Q‚ÇÇ : Type*}
variable [NormedAddCommGroup V] [MetricSpace P] [NormedAddTorsor V P]
variable [NormedAddCommGroup W] [MetricSpace Q] [NormedAddTorsor W Q]
variable [NormedAddCommGroup W‚ÇÇ] [MetricSpace Q‚ÇÇ] [NormedAddTorsor W‚ÇÇ Q‚ÇÇ]
variable [NormedField R] [NormedSpace R V] [NormedSpace R W] [NormedSpace R W‚ÇÇ]
variable [NontriviallyNormedField ùïú] [NormedSpace ùïú V] [NormedSpace ùïú W] [NormedSpace ùïú W‚ÇÇ]

/-- The linear map underlying a continuous affine map is continuous. -/
def contLinear (f : P ‚ÜíA[R] Q) : V ‚ÜíL[R] W :=
  { f.linear with
    toFun := f.linear
    cont := by rw [AffineMap.continuous_linear_iff]; exact f.cont }
#align continuous_affine_map.cont_linear ContinuousAffineMap.contLinear

@[simp]
theorem coe_contLinear (f : P ‚ÜíA[R] Q) : (f.contLinear : V ‚Üí W) = f.linear :=
  rfl
#align continuous_affine_map.coe_cont_linear ContinuousAffineMap.coe_contLinear

@[simp]
theorem coe_contLinear_eq_linear (f : P ‚ÜíA[R] Q) :
    (f.contLinear : V ‚Üí‚Çó[R] W) = (f : P ‚Üí·µÉ[R] Q).linear := by ext; rfl
#align continuous_affine_map.coe_cont_linear_eq_linear ContinuousAffineMap.coe_contLinear_eq_linear

@[simp]
theorem coe_mk_const_linear_eq_linear (f : P ‚Üí·µÉ[R] Q) (h) :
    ((‚ü®f, h‚ü© : P ‚ÜíA[R] Q).contLinear : V ‚Üí W) = f.linear :=
  rfl
#align continuous_affine_map.coe_mk_const_linear_eq_linear ContinuousAffineMap.coe_mk_const_linear_eq_linear

theorem coe_linear_eq_coe_contLinear (f : P ‚ÜíA[R] Q) :
    ((f : P ‚Üí·µÉ[R] Q).linear : V ‚Üí W) = (‚áëf.contLinear : V ‚Üí W) :=
  rfl
#align continuous_affine_map.coe_linear_eq_coe_cont_linear ContinuousAffineMap.coe_linear_eq_coe_contLinear

@[simp]
theorem comp_contLinear (f : P ‚ÜíA[R] Q) (g : Q ‚ÜíA[R] Q‚ÇÇ) :
    (g.comp f).contLinear = g.contLinear.comp f.contLinear :=
  rfl
#align continuous_affine_map.comp_cont_linear ContinuousAffineMap.comp_contLinear

@[simp]
theorem map_vadd (f : P ‚ÜíA[R] Q) (p : P) (v : V) : f (v +·µ• p) = f.contLinear v +·µ• f p :=
  f.map_vadd' p v
#align continuous_affine_map.map_vadd ContinuousAffineMap.map_vadd

@[simp]
theorem contLinear_map_vsub (f : P ‚ÜíA[R] Q) (p‚ÇÅ p‚ÇÇ : P) : f.contLinear (p‚ÇÅ -·µ• p‚ÇÇ) = f p‚ÇÅ -·µ• f p‚ÇÇ :=
  f.toAffineMap.linearMap_vsub p‚ÇÅ p‚ÇÇ
#align continuous_affine_map.cont_linear_map_vsub ContinuousAffineMap.contLinear_map_vsub

@[simp]
theorem const_contLinear (q : Q) : (const R P q).contLinear = 0 :=
  rfl
#align continuous_affine_map.const_cont_linear ContinuousAffineMap.const_contLinear

theorem contLinear_eq_zero_iff_exists_const (f : P ‚ÜíA[R] Q) :
    f.contLinear = 0 ‚Üî ‚àÉ q, f = const R P q := by
  have h‚ÇÅ : f.contLinear = 0 ‚Üî (f : P ‚Üí·µÉ[R] Q).linear = 0 := by
    refine' ‚ü®fun h => _, fun h => _‚ü© <;> ext
    ¬∑ rw [‚Üê coe_contLinear_eq_linear, h]; rfl
    ¬∑ rw [‚Üê coe_linear_eq_coe_contLinear, h]; rfl
  have h‚ÇÇ : ‚àÄ q : Q, f = const R P q ‚Üî (f : P ‚Üí·µÉ[R] Q) = AffineMap.const R P q := by
    intro q
    refine' ‚ü®fun h => _, fun h => _‚ü© <;> ext
    ¬∑ rw [h]; rfl
    ¬∑ rw [‚Üê coe_to_affineMap, h]; rfl
  simp_rw [h‚ÇÅ, h‚ÇÇ]
  exact (f : P ‚Üí·µÉ[R] Q).linear_eq_zero_iff_exists_const
#align continuous_affine_map.cont_linear_eq_zero_iff_exists_const ContinuousAffineMap.contLinear_eq_zero_iff_exists_const

@[simp]
theorem to_affine_map_contLinear (f : V ‚ÜíL[R] W) : f.toContinuousAffineMap.contLinear = f := by
  ext
  rfl
#align continuous_affine_map.to_affine_map_cont_linear ContinuousAffineMap.to_affine_map_contLinear

@[simp]
theorem zero_contLinear : (0 : P ‚ÜíA[R] W).contLinear = 0 :=
  rfl
#align continuous_affine_map.zero_cont_linear ContinuousAffineMap.zero_contLinear

@[simp]
theorem add_contLinear (f g : P ‚ÜíA[R] W) : (f + g).contLinear = f.contLinear + g.contLinear :=
  rfl
#align continuous_affine_map.add_cont_linear ContinuousAffineMap.add_contLinear

@[simp]
theorem sub_contLinear (f g : P ‚ÜíA[R] W) : (f - g).contLinear = f.contLinear - g.contLinear :=
  rfl
#align continuous_affine_map.sub_cont_linear ContinuousAffineMap.sub_contLinear

@[simp]
theorem neg_contLinear (f : P ‚ÜíA[R] W) : (-f).contLinear = -f.contLinear :=
  rfl
#align continuous_affine_map.neg_cont_linear ContinuousAffineMap.neg_contLinear

@[simp]
theorem smul_contLinear (t : R) (f : P ‚ÜíA[R] W) : (t ‚Ä¢ f).contLinear = t ‚Ä¢ f.contLinear :=
  rfl
#align continuous_affine_map.smul_cont_linear ContinuousAffineMap.smul_contLinear

theorem decomp (f : V ‚ÜíA[R] W) : (f : V ‚Üí W) = f.contLinear + Function.const V (f 0) := by
  rcases f with ‚ü®f, h‚ü©
  rw [coe_mk_const_linear_eq_linear, coe_mk, f.decomp, Pi.add_apply, LinearMap.map_zero, zero_add,
    ‚Üê Function.const_def]
#align continuous_affine_map.decomp ContinuousAffineMap.decomp

section NormedSpaceStructure

variable (f : V ‚ÜíA[ùïú] W)

/-- Note that unlike the operator norm for linear maps, this norm is _not_ submultiplicative:
we do _not_ necessarily have `‚Äñf.comp g‚Äñ ‚â§ ‚Äñf‚Äñ * ‚Äñg‚Äñ`. See `norm_comp_le` for what we can say. -/
noncomputable instance hasNorm : Norm (V ‚ÜíA[ùïú] W) :=
  ‚ü®fun f => max ‚Äñf 0‚Äñ ‚Äñf.contLinear‚Äñ‚ü©
#align continuous_affine_map.has_norm ContinuousAffineMap.hasNorm

theorem norm_def : ‚Äñf‚Äñ = max ‚Äñf 0‚Äñ ‚Äñf.contLinear‚Äñ :=
  rfl
#align continuous_affine_map.norm_def ContinuousAffineMap.norm_def

theorem norm_contLinear_le : ‚Äñf.contLinear‚Äñ ‚â§ ‚Äñf‚Äñ :=
  le_max_right _ _
#align continuous_affine_map.norm_cont_linear_le ContinuousAffineMap.norm_contLinear_le

theorem norm_image_zero_le : ‚Äñf 0‚Äñ ‚â§ ‚Äñf‚Äñ :=
  le_max_left _ _
#align continuous_affine_map.norm_image_zero_le ContinuousAffineMap.norm_image_zero_le

@[simp]
theorem norm_eq (h : f 0 = 0) : ‚Äñf‚Äñ = ‚Äñf.contLinear‚Äñ :=
  calc
    ‚Äñf‚Äñ = max ‚Äñf 0‚Äñ ‚Äñf.contLinear‚Äñ := by rw [norm_def]
    _ = max 0 ‚Äñf.contLinear‚Äñ := by rw [h, norm_zero]
    _ = ‚Äñf.contLinear‚Äñ := max_eq_right (norm_nonneg _)

#align continuous_affine_map.norm_eq ContinuousAffineMap.norm_eq

noncomputable instance : NormedAddCommGroup (V ‚ÜíA[ùïú] W) :=
  AddGroupNorm.toNormedAddCommGroup
    { toFun := fun f => max ‚Äñf 0‚Äñ ‚Äñf.contLinear‚Äñ
      map_zero' := by simp [(ContinuousAffineMap.zero_apply)]
      neg' := fun f => by
        simp [(ContinuousAffineMap.neg_apply)]
      add_le' := fun f g => by
        simp only [coe_add, max_le_iff]
        -- Porting note: previously `Pi.add_apply, add_contLinear, ` in the previous `simp only`
        -- suffices, but now they don't fire.
        rw [add_contLinear]
        exact
          ‚ü®(norm_add_le _ _).trans (add_le_add (le_max_left _ _) (le_max_left _ _)),
            (norm_add_le _ _).trans (add_le_add (le_max_right _ _) (le_max_right _ _))‚ü©
      eq_zero_of_map_eq_zero' := fun f h‚ÇÄ => by
        rcases max_eq_iff.mp h‚ÇÄ with (‚ü®h‚ÇÅ, h‚ÇÇ‚ü© | ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©) <;> rw [h‚ÇÅ] at h‚ÇÇ
        ¬∑ rw [norm_le_zero_iff, contLinear_eq_zero_iff_exists_const] at h‚ÇÇ
          obtain ‚ü®q, rfl‚ü© := h‚ÇÇ
          simp only [norm_eq_zero] at h‚ÇÅ
          -- Porting note: prevously `coe_const, Function.const_apply` were in the previous
          -- `simp only`, but now they don't fire.
          rw [coe_const, Function.const_apply] at h‚ÇÅ
          rw [h‚ÇÅ]
          rfl
        ¬∑ rw [norm_eq_zero', contLinear_eq_zero_iff_exists_const] at h‚ÇÅ
          obtain ‚ü®q, rfl‚ü© := h‚ÇÅ
          simp only [norm_le_zero_iff] at h‚ÇÇ
          -- Porting note: prevously `coe_const, Function.const_apply` were in the previous
          -- `simp only`, but now they don't fire.
          rw [coe_const, Function.const_apply] at h‚ÇÇ
          rw [h‚ÇÇ]
          rfl }

instance : NormedSpace ùïú (V ‚ÜíA[ùïú] W) where
  norm_smul_le t f := by
    simp only [SMul.smul, norm_def, (smul_contLinear), norm_smul]
    -- Porting note: previously all these rewrites were in the `simp only`,
    -- but now they don't fire.
    -- (in fact, `norm_smul` fires, but only once rather than twice!)
    have : NormedAddCommGroup (V ‚ÜíA[ùïú] W) := inferInstance -- this is necessary for `norm_smul`
    rw [coe_smul, Pi.smul_apply, norm_smul, norm_smul _ (f.contLinear),
      ‚Üê mul_max_of_nonneg _ _ (norm_nonneg t)]


theorem norm_comp_le (g : W‚ÇÇ ‚ÜíA[ùïú] V) : ‚Äñf.comp g‚Äñ ‚â§ ‚Äñf‚Äñ * ‚Äñg‚Äñ + ‚Äñf 0‚Äñ := by
  rw [norm_def, max_le_iff]
  constructor
  ¬∑ calc
      ‚Äñf.comp g 0‚Äñ = ‚Äñf (g 0)‚Äñ := by simp
      _ = ‚Äñf.contLinear (g 0) + f 0‚Äñ := by rw [f.decomp]; simp
      _ ‚â§ ‚Äñf.contLinear‚Äñ * ‚Äñg 0‚Äñ + ‚Äñf 0‚Äñ :=
        ((norm_add_le _ _).trans (add_le_add_right (f.contLinear.le_opNorm _) _))
      _ ‚â§ ‚Äñf‚Äñ * ‚Äñg‚Äñ + ‚Äñf 0‚Äñ :=
        add_le_add_right
          (mul_le_mul f.norm_contLinear_le g.norm_image_zero_le (norm_nonneg _) (norm_nonneg _)) _
  ¬∑ calc
      ‚Äñ(f.comp g).contLinear‚Äñ ‚â§ ‚Äñf.contLinear‚Äñ * ‚Äñg.contLinear‚Äñ :=
        (g.comp_contLinear f).symm ‚ñ∏ f.contLinear.opNorm_comp_le _
      _ ‚â§ ‚Äñf‚Äñ * ‚Äñg‚Äñ :=
        (mul_le_mul f.norm_contLinear_le g.norm_contLinear_le (norm_nonneg _) (norm_nonneg _))
      _ ‚â§ ‚Äñf‚Äñ * ‚Äñg‚Äñ + ‚Äñf 0‚Äñ := by rw [le_add_iff_nonneg_right]; apply norm_nonneg

#align continuous_affine_map.norm_comp_le ContinuousAffineMap.norm_comp_le

variable (ùïú V W)

/-- The space of affine maps between two normed spaces is linearly isometric to the product of the
codomain with the space of linear maps, by taking the value of the affine map at `(0 : V)` and the
linear part. -/
def toConstProdContinuousLinearMap : (V ‚ÜíA[ùïú] W) ‚âÉ‚Çó·µ¢[ùïú] W √ó (V ‚ÜíL[ùïú] W) where
  toFun f := ‚ü®f 0, f.contLinear‚ü©
  invFun p := p.2.toContinuousAffineMap + const ùïú V p.1
  left_inv f := by
    ext
    rw [f.decomp]
    simp only [coe_add, ContinuousLinearMap.coe_toContinuousAffineMap, Pi.add_apply, coe_const]
  right_inv := by rintro ‚ü®v, f‚ü©; ext <;> simp
  map_add' _ _ := rfl
  map_smul' _ _ := rfl
  norm_map' f := rfl
#align continuous_affine_map.to_const_prod_continuous_linear_map ContinuousAffineMap.toConstProdContinuousLinearMap

@[simp]
theorem toConstProdContinuousLinearMap_fst (f : V ‚ÜíA[ùïú] W) :
    (toConstProdContinuousLinearMap ùïú V W f).fst = f 0 :=
  rfl
#align continuous_affine_map.to_const_prod_continuous_linear_map_fst ContinuousAffineMap.toConstProdContinuousLinearMap_fst

@[simp]
theorem toConstProdContinuousLinearMap_snd (f : V ‚ÜíA[ùïú] W) :
    (toConstProdContinuousLinearMap ùïú V W f).snd = f.contLinear :=
  rfl
#align continuous_affine_map.to_const_prod_continuous_linear_map_snd ContinuousAffineMap.toConstProdContinuousLinearMap_snd

end NormedSpaceStructure

end ContinuousAffineMap
