/-
Copyright (c) 2022 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta, Ya√´l Dillies
-/
import Mathlib.Analysis.Convex.Cone.Extension
import Mathlib.Analysis.Convex.Gauge
import Mathlib.Analysis.Normed.Order.Lattice
import Mathlib.Analysis.NormedSpace.Extend
import Mathlib.Analysis.RCLike.Lemmas

/-!
# Separation Hahn-Banach theorem

In this file we prove the geometric Hahn-Banach theorem. For any two disjoint convex sets, there
exists a continuous linear functional separating them, geometrically meaning that we can intercalate
a plane between them.

We provide many variations to stricten the result under more assumptions on the convex sets:
* `geometric_hahn_banach_open`: One set is open. Weak separation.
* `geometric_hahn_banach_open_point`, `geometric_hahn_banach_point_open`: One set is open, the
  other is a singleton. Weak separation.
* `geometric_hahn_banach_open_open`: Both sets are open. Semistrict separation.
* `geometric_hahn_banach_compact_closed`, `geometric_hahn_banach_closed_compact`: One set is closed,
  the other one is compact. Strict separation.
* `geometric_hahn_banach_point_closed`, `geometric_hahn_banach_closed_point`: One set is closed, the
  other one is a singleton. Strict separation.
* `geometric_hahn_banach_point_point`: Both sets are singletons. Strict separation.

## TODO

* Eidelheit's theorem
* `Convex ‚Ñù s ‚Üí interior (closure s) ‚äÜ s`
-/


open Set

open Pointwise

variable {ùïú E : Type*}

/-- Given a set `s` which is a convex neighbourhood of `0` and a point `x‚ÇÄ` outside of it, there is
a continuous linear functional `f` separating `x‚ÇÄ` and `s`, in the sense that it sends `x‚ÇÄ` to 1 and
all of `s` to values strictly below `1`. -/
theorem separate_convex_open_set [TopologicalSpace E] [AddCommGroup E] [IsTopologicalAddGroup E]
    [Module ‚Ñù E] [ContinuousSMul ‚Ñù E] {s : Set E} (hs‚ÇÄ : (0 : E) ‚àà s) (hs‚ÇÅ : Convex ‚Ñù s)
    (hs‚ÇÇ : IsOpen s) {x‚ÇÄ : E} (hx‚ÇÄ : x‚ÇÄ ‚àâ s) :
    ‚àÉ f : StrongDual ‚Ñù E, f x‚ÇÄ = 1 ‚àß ‚àÄ x ‚àà s, f x < 1 := by
  let f : E ‚Üí‚Çó.[‚Ñù] ‚Ñù := LinearPMap.mkSpanSingleton x‚ÇÄ 1 (ne_of_mem_of_not_mem hs‚ÇÄ hx‚ÇÄ).symm
  have := exists_extension_of_le_sublinear f (gauge s) (fun c hc => gauge_smul_of_nonneg hc.le)
    (gauge_add_le hs‚ÇÅ <| absorbent_nhds_zero <| hs‚ÇÇ.mem_nhds hs‚ÇÄ) ?_
  ¬∑ obtain ‚ü®œÜ, hœÜ‚ÇÅ, hœÜ‚ÇÇ‚ü© := this
    have hœÜ‚ÇÉ : œÜ x‚ÇÄ = 1 := by
      rw [‚Üê f.domain.coe_mk x‚ÇÄ (Submodule.mem_span_singleton_self _), hœÜ‚ÇÅ,
        LinearPMap.mkSpanSingleton'_apply_self]
    have hœÜ‚ÇÑ : ‚àÄ x ‚àà s, œÜ x < 1 := fun x hx =>
      (hœÜ‚ÇÇ x).trans_lt (gauge_lt_one_of_mem_of_isOpen hs‚ÇÇ hx)
    refine ‚ü®‚ü®œÜ, ?_‚ü©, hœÜ‚ÇÉ, hœÜ‚ÇÑ‚ü©
    refine
      œÜ.continuous_of_nonzero_on_open _ (hs‚ÇÇ.vadd (-x‚ÇÄ)) (Nonempty.vadd_set ‚ü®0, hs‚ÇÄ‚ü©)
        (vadd_set_subset_iff.mpr fun x hx => ?_)
    change œÜ (-x‚ÇÄ + x) ‚â† 0
    rw [map_add, map_neg]
    specialize hœÜ‚ÇÑ x hx
    linarith
  rintro ‚ü®x, hx‚ü©
  obtain ‚ü®y, rfl‚ü© := Submodule.mem_span_singleton.1 hx
  rw [LinearPMap.mkSpanSingleton'_apply]
  simp only [mul_one, Algebra.id.smul_eq_mul]
  obtain h | h := le_or_gt y 0
  ¬∑ exact h.trans (gauge_nonneg _)
  ¬∑ rw [gauge_smul_of_nonneg h.le, smul_eq_mul, le_mul_iff_one_le_right h]
    exact
      one_le_gauge_of_notMem (hs‚ÇÅ.starConvex hs‚ÇÄ)
        (absorbent_nhds_zero <| hs‚ÇÇ.mem_nhds hs‚ÇÄ).absorbs hx‚ÇÄ

variable [TopologicalSpace E] [AddCommGroup E] [Module ‚Ñù E]
  {s t : Set E} {x y : E}
section

variable [IsTopologicalAddGroup E] [ContinuousSMul ‚Ñù E]

/-- A version of the **Hahn-Banach theorem**: given disjoint convex sets `s`, `t` where `s` is open,
there is a continuous linear functional which separates them. -/
theorem geometric_hahn_banach_open (hs‚ÇÅ : Convex ‚Ñù s) (hs‚ÇÇ : IsOpen s) (ht : Convex ‚Ñù t)
    (disj : Disjoint s t) :
    ‚àÉ (f : StrongDual ‚Ñù E) (u : ‚Ñù), (‚àÄ a ‚àà s, f a < u) ‚àß ‚àÄ b ‚àà t, u ‚â§ f b := by
  obtain rfl | ‚ü®a‚ÇÄ, ha‚ÇÄ‚ü© := s.eq_empty_or_nonempty
  ¬∑ exact ‚ü®0, 0, by simp, fun b _hb => le_rfl‚ü©
  obtain rfl | ‚ü®b‚ÇÄ, hb‚ÇÄ‚ü© := t.eq_empty_or_nonempty
  ¬∑ exact ‚ü®0, 1, fun a _ha => zero_lt_one, by simp‚ü©
  let x‚ÇÄ := b‚ÇÄ - a‚ÇÄ
  let C := x‚ÇÄ +·µ• (s - t)
  have : (0 : E) ‚àà C :=
    ‚ü®a‚ÇÄ - b‚ÇÄ, sub_mem_sub ha‚ÇÄ hb‚ÇÄ, by simp_rw [x‚ÇÄ, vadd_eq_add, sub_add_sub_cancel', sub_self]‚ü©
  have : Convex ‚Ñù C := (hs‚ÇÅ.sub ht).vadd _
  have : x‚ÇÄ ‚àâ C := by
    intro hx‚ÇÄ
    rw [‚Üê add_zero x‚ÇÄ] at hx‚ÇÄ
    exact disj.zero_notMem_sub_set (vadd_mem_vadd_set_iff.1 hx‚ÇÄ)
  obtain ‚ü®f, hf‚ÇÅ, hf‚ÇÇ‚ü© := separate_convex_open_set ‚Äπ0 ‚àà C‚Ä∫ ‚Äπ_‚Ä∫ (hs‚ÇÇ.sub_right.vadd _) ‚Äπx‚ÇÄ ‚àâ C‚Ä∫
  have : f b‚ÇÄ = f a‚ÇÄ + 1 := by simp [x‚ÇÄ, ‚Üê hf‚ÇÅ]
  have forall_le : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a ‚â§ f b := by
    intro a ha b hb
    have := hf‚ÇÇ (x‚ÇÄ + (a - b)) (vadd_mem_vadd_set <| sub_mem_sub ha hb)
    simp only [f.map_add, f.map_sub, hf‚ÇÅ] at this
    linarith
  refine ‚ü®f, sInf (f '' t), image_subset_iff.1 (?_ : f '' s ‚äÜ Iio (sInf (f '' t))), fun b hb => ?_‚ü©
  ¬∑ rw [‚Üê interior_Iic]
    refine interior_maximal (image_subset_iff.2 fun a ha => ?_) (f.isOpenMap_of_ne_zero ?_ _ hs‚ÇÇ)
    ¬∑ exact le_csInf (Nonempty.image _ ‚ü®_, hb‚ÇÄ‚ü©) (forall_mem_image.2 <| forall_le _ ha)
    ¬∑ rintro rfl
      simp at hf‚ÇÅ
  ¬∑ exact csInf_le ‚ü®f a‚ÇÄ, forall_mem_image.2 <| forall_le _ ha‚ÇÄ‚ü© (mem_image_of_mem _ hb)

theorem geometric_hahn_banach_open_point (hs‚ÇÅ : Convex ‚Ñù s) (hs‚ÇÇ : IsOpen s) (disj : x ‚àâ s) :
    ‚àÉ f : StrongDual ‚Ñù E, ‚àÄ a ‚àà s, f a < f x :=
  let ‚ü®f, _s, hs, hx‚ü© :=
    geometric_hahn_banach_open hs‚ÇÅ hs‚ÇÇ (convex_singleton x) (disjoint_singleton_right.2 disj)
  ‚ü®f, fun a ha => lt_of_lt_of_le (hs a ha) (hx x (mem_singleton _))‚ü©

theorem geometric_hahn_banach_point_open (ht‚ÇÅ : Convex ‚Ñù t) (ht‚ÇÇ : IsOpen t) (disj : x ‚àâ t) :
    ‚àÉ f : StrongDual ‚Ñù E, ‚àÄ b ‚àà t, f x < f b :=
  let ‚ü®f, hf‚ü© := geometric_hahn_banach_open_point ht‚ÇÅ ht‚ÇÇ disj
  ‚ü®-f, by simpa‚ü©

theorem geometric_hahn_banach_open_open (hs‚ÇÅ : Convex ‚Ñù s) (hs‚ÇÇ : IsOpen s) (ht‚ÇÅ : Convex ‚Ñù t)
    (ht‚ÇÉ : IsOpen t) (disj : Disjoint s t) :
    ‚àÉ (f : StrongDual ‚Ñù E) (u : ‚Ñù), (‚àÄ a ‚àà s, f a < u) ‚àß ‚àÄ b ‚àà t, u < f b := by
  obtain rfl | ‚ü®a‚ÇÄ, ha‚ÇÄ‚ü© := s.eq_empty_or_nonempty
  ¬∑ exact ‚ü®0, -1, by simp, fun b _hb => by simp‚ü©
  obtain rfl | ‚ü®b‚ÇÄ, hb‚ÇÄ‚ü© := t.eq_empty_or_nonempty
  ¬∑ exact ‚ü®0, 1, fun a _ha => by simp, by simp‚ü©
  obtain ‚ü®f, s, hf‚ÇÅ, hf‚ÇÇ‚ü© := geometric_hahn_banach_open hs‚ÇÅ hs‚ÇÇ ht‚ÇÅ disj
  have hf : IsOpenMap f := by
    refine f.isOpenMap_of_ne_zero ?_
    rintro rfl
    simp_rw [ContinuousLinearMap.zero_apply] at hf‚ÇÅ hf‚ÇÇ
    exact (hf‚ÇÅ _ ha‚ÇÄ).not_ge (hf‚ÇÇ _ hb‚ÇÄ)
  refine ‚ü®f, s, hf‚ÇÅ, image_subset_iff.1 (?_ : f '' t ‚äÜ Ioi s)‚ü©
  rw [‚Üê interior_Ici]
  refine interior_maximal (image_subset_iff.2 hf‚ÇÇ) (f.isOpenMap_of_ne_zero ?_ _ ht‚ÇÉ)
  rintro rfl
  simp_rw [ContinuousLinearMap.zero_apply] at hf‚ÇÅ hf‚ÇÇ
  exact (hf‚ÇÅ _ ha‚ÇÄ).not_ge (hf‚ÇÇ _ hb‚ÇÄ)

variable [LocallyConvexSpace ‚Ñù E]

/-- A version of the **Hahn-Banach theorem**: given disjoint convex sets `s`, `t` where `s` is
compact and `t` is closed, there is a continuous linear functional which strongly separates them. -/
theorem geometric_hahn_banach_compact_closed (hs‚ÇÅ : Convex ‚Ñù s) (hs‚ÇÇ : IsCompact s)
    (ht‚ÇÅ : Convex ‚Ñù t) (ht‚ÇÇ : IsClosed t) (disj : Disjoint s t) :
    ‚àÉ (f : StrongDual ‚Ñù E) (u v : ‚Ñù), (‚àÄ a ‚àà s, f a < u) ‚àß u < v ‚àß ‚àÄ b ‚àà t, v < f b := by
  obtain rfl | hs := s.eq_empty_or_nonempty
  ¬∑ exact ‚ü®0, -2, -1, by simp‚ü©
  obtain rfl | _ht := t.eq_empty_or_nonempty
  ¬∑ exact ‚ü®0, 1, 2, by simp‚ü©
  obtain ‚ü®U, V, hU, hV, hU‚ÇÅ, hV‚ÇÅ, sU, tV, disj'‚ü© := disj.exists_open_convexes hs‚ÇÅ hs‚ÇÇ ht‚ÇÅ ht‚ÇÇ
  obtain ‚ü®f, u, hf‚ÇÅ, hf‚ÇÇ‚ü© := geometric_hahn_banach_open_open hU‚ÇÅ hU hV‚ÇÅ hV disj'
  obtain ‚ü®x, hx‚ÇÅ, hx‚ÇÇ‚ü© := hs‚ÇÇ.exists_isMaxOn hs f.continuous.continuousOn
  have : f x < u := hf‚ÇÅ x (sU hx‚ÇÅ)
  exact
    ‚ü®f, (f x + u) / 2, u,
      fun a ha => by have := hx‚ÇÇ ha; dsimp at this; linarith,
      by linarith,
      fun b hb => hf‚ÇÇ b (tV hb)‚ü©

/-- A version of the **Hahn-Banach theorem**: given disjoint convex sets `s`, `t` where `s` is
closed, and `t` is compact, there is a continuous linear functional which strongly separates them.
-/
theorem geometric_hahn_banach_closed_compact (hs‚ÇÅ : Convex ‚Ñù s) (hs‚ÇÇ : IsClosed s)
    (ht‚ÇÅ : Convex ‚Ñù t) (ht‚ÇÇ : IsCompact t) (disj : Disjoint s t) :
    ‚àÉ (f : StrongDual ‚Ñù E) (u v : ‚Ñù), (‚àÄ a ‚àà s, f a < u) ‚àß u < v ‚àß ‚àÄ b ‚àà t, v < f b :=
  let ‚ü®f, s, t, hs, st, ht‚ü© := geometric_hahn_banach_compact_closed ht‚ÇÅ ht‚ÇÇ hs‚ÇÅ hs‚ÇÇ disj.symm
  ‚ü®-f, -t, -s, by simpa using ht, by simpa using st, by simpa using hs‚ü©

theorem geometric_hahn_banach_point_closed (ht‚ÇÅ : Convex ‚Ñù t) (ht‚ÇÇ : IsClosed t) (disj : x ‚àâ t) :
    ‚àÉ (f : StrongDual ‚Ñù E) (u : ‚Ñù), f x < u ‚àß ‚àÄ b ‚àà t, u < f b :=
  let ‚ü®f, _u, v, ha, hst, hb‚ü© :=
    geometric_hahn_banach_compact_closed (convex_singleton x) isCompact_singleton ht‚ÇÅ ht‚ÇÇ
      (disjoint_singleton_left.2 disj)
  ‚ü®f, v, hst.trans' <| ha x <| mem_singleton _, hb‚ü©

theorem geometric_hahn_banach_closed_point (hs‚ÇÅ : Convex ‚Ñù s) (hs‚ÇÇ : IsClosed s) (disj : x ‚àâ s) :
    ‚àÉ (f : StrongDual ‚Ñù E) (u : ‚Ñù), (‚àÄ a ‚àà s, f a < u) ‚àß u < f x :=
  let ‚ü®f, s, _t, ha, hst, hb‚ü© :=
    geometric_hahn_banach_closed_compact hs‚ÇÅ hs‚ÇÇ (convex_singleton x) isCompact_singleton
      (disjoint_singleton_right.2 disj)
  ‚ü®f, s, ha, hst.trans <| hb x <| mem_singleton _‚ü©

/-- See also `NormedSpace.eq_iff_forall_dual_eq`. -/
theorem geometric_hahn_banach_point_point [T1Space E] (hxy : x ‚â† y) :
    ‚àÉ f : StrongDual ‚Ñù E, f x < f y := by
  obtain ‚ü®f, s, t, hs, st, ht‚ü© :=
    geometric_hahn_banach_compact_closed (convex_singleton x) isCompact_singleton
      (convex_singleton y) isClosed_singleton (disjoint_singleton.2 hxy)
  exact ‚ü®f, by linarith [hs x rfl, ht y rfl]‚ü©

/-- A closed convex set is the intersection of the half-spaces containing it. -/
theorem iInter_halfSpaces_eq (hs‚ÇÅ : Convex ‚Ñù s) (hs‚ÇÇ : IsClosed s) :
    ‚ãÇ l : StrongDual ‚Ñù E, { x | ‚àÉ y ‚àà s, l x ‚â§ l y } = s := by
  rw [Set.iInter_setOf]
  refine Set.Subset.antisymm (fun x hx => ?_) fun x hx l => ‚ü®x, hx, le_rfl‚ü©
  by_contra h
  obtain ‚ü®l, s, hlA, hl‚ü© := geometric_hahn_banach_closed_point hs‚ÇÅ hs‚ÇÇ h
  obtain ‚ü®y, hy, hxy‚ü© := hx l
  exact ((hxy.trans_lt (hlA y hy)).trans hl).not_ge le_rfl
end

namespace RCLike

variable [RCLike ùïú] [Module ùïú E] [IsScalarTower ‚Ñù ùïú E]

/-- Real linear extension of continuous extension of `LinearMap.extendToùïú'` -/
noncomputable def extendToùïú'‚Çó [ContinuousConstSMul ùïú E] : StrongDual ‚Ñù E ‚Üí‚Çó[‚Ñù] StrongDual ùïú E :=
  letI toùïú (fr : StrongDual ‚Ñù E) : StrongDual ùïú E :=
    { toLinearMap := LinearMap.extendToùïú' fr
      cont := show Continuous fun x ‚Ü¶ (fr x : ùïú) - (I : ùïú) * (fr ((I : ùïú) ‚Ä¢ x) : ùïú) by fun_prop }
  have h fr x : toùïú fr x = ((fr x : ùïú) - (I : ùïú) * (fr ((I : ùïú) ‚Ä¢ x) : ùïú)) := rfl
  { toFun := toùïú
    map_add' := by intros; ext; simp [h]; ring
    map_smul' := by intros; ext; simp [h, real_smul_eq_coe_mul]; ring }

@[simp]
lemma re_extendToùïú'‚Çó [ContinuousConstSMul ùïú E] (g : StrongDual ‚Ñù E) (x : E) :
    re ((extendToùïú'‚Çó g) x : ùïú) = g x := by
  have h g (x : E) : extendToùïú'‚Çó g x = ((g x : ùïú) - (I : ùïú) * (g ((I : ùïú) ‚Ä¢ x) : ùïú)) := rfl
  simp only [h, map_sub, ofReal_re, mul_re, I_re, zero_mul, ofReal_im, mul_zero,
    sub_self, sub_zero]

variable [IsTopologicalAddGroup E] [ContinuousSMul ùïú E]

theorem separate_convex_open_set {s : Set E}
    (hs‚ÇÄ : (0 : E) ‚àà s) (hs‚ÇÅ : Convex ‚Ñù s) (hs‚ÇÇ : IsOpen s) {x‚ÇÄ : E} (hx‚ÇÄ : x‚ÇÄ ‚àâ s) :
    ‚àÉ f : StrongDual ùïú E, re (f x‚ÇÄ) = 1 ‚àß ‚àÄ x ‚àà s, re (f x) < 1 := by
  have := IsScalarTower.continuousSMul (M := ‚Ñù) (Œ± := E) ùïú
  obtain ‚ü®g, hg‚ü© := _root_.separate_convex_open_set hs‚ÇÄ hs‚ÇÅ hs‚ÇÇ hx‚ÇÄ
  use extendToùïú'‚Çó g
  simp only [re_extendToùïú'‚Çó]
  exact hg

/-- Following [Rudin, *Functional Analysis* (Theorem 3.4 (a))][rudin1991] -/
theorem geometric_hahn_banach_open (hs‚ÇÅ : Convex ‚Ñù s) (hs‚ÇÇ : IsOpen s) (ht : Convex ‚Ñù t)
    (disj : Disjoint s t) : ‚àÉ (f : StrongDual ùïú E) (u : ‚Ñù), (‚àÄ a ‚àà s, re (f a) < u) ‚àß
    ‚àÄ b ‚àà t, u ‚â§ re (f b) := by
  have := IsScalarTower.continuousSMul (M := ‚Ñù) (Œ± := E) ùïú
  obtain ‚ü®f, u, h‚ü© := _root_.geometric_hahn_banach_open hs‚ÇÅ hs‚ÇÇ ht disj
  use extendToùïú'‚Çó f
  simp only [re_extendToùïú'‚Çó]
  exact Exists.intro u h

theorem geometric_hahn_banach_open_point (hs‚ÇÅ : Convex ‚Ñù s) (hs‚ÇÇ : IsOpen s) (disj : x ‚àâ s) :
    ‚àÉ f : StrongDual ùïú E, ‚àÄ a ‚àà s, re (f a) < re (f x) := by
  have := IsScalarTower.continuousSMul (M := ‚Ñù) (Œ± := E) ùïú
  obtain ‚ü®f, h‚ü© := _root_.geometric_hahn_banach_open_point hs‚ÇÅ hs‚ÇÇ disj
  use extendToùïú'‚Çó f
  simp only [re_extendToùïú'‚Çó]
  exact fun a a_1 ‚Ü¶ h a a_1

theorem geometric_hahn_banach_point_open (ht‚ÇÅ : Convex ‚Ñù t) (ht‚ÇÇ : IsOpen t) (disj : x ‚àâ t) :
    ‚àÉ f : StrongDual ùïú E, ‚àÄ b ‚àà t, re (f x) < re (f b) :=
  let ‚ü®f, hf‚ü© := geometric_hahn_banach_open_point ht‚ÇÅ ht‚ÇÇ disj
  ‚ü®-f, by simpa‚ü©

theorem geometric_hahn_banach_open_open (hs‚ÇÅ : Convex ‚Ñù s) (hs‚ÇÇ : IsOpen s)
    (ht‚ÇÅ : Convex ‚Ñù t) (ht‚ÇÉ : IsOpen t) (disj : Disjoint s t) :
    ‚àÉ (f : StrongDual ùïú E) (u : ‚Ñù), (‚àÄ a ‚àà s, re (f a) < u) ‚àß ‚àÄ b ‚àà t, u < re (f b) := by
  have := IsScalarTower.continuousSMul (M := ‚Ñù) (Œ± := E) ùïú
  obtain ‚ü®f, u, h‚ü© := _root_.geometric_hahn_banach_open_open hs‚ÇÅ hs‚ÇÇ ht‚ÇÅ ht‚ÇÉ disj
  use extendToùïú'‚Çó f
  simp only [re_extendToùïú'‚Çó]
  exact Exists.intro u h

variable [LocallyConvexSpace ‚Ñù E]

/-- Following [Rudin, *Functional Analysis* (Theorem 3.4 (b))][rudin1991] -/
theorem geometric_hahn_banach_compact_closed (hs‚ÇÅ : Convex ‚Ñù s) (hs‚ÇÇ : IsCompact s)
    (ht‚ÇÅ : Convex ‚Ñù t) (ht‚ÇÇ : IsClosed t) (disj : Disjoint s t) :
    ‚àÉ (f : StrongDual ùïú E) (u v : ‚Ñù), (‚àÄ a ‚àà s, re (f a) < u) ‚àß u < v ‚àß ‚àÄ b ‚àà t, v < re (f b) := by
  have := IsScalarTower.continuousSMul (M := ‚Ñù) (Œ± := E) ùïú
  obtain ‚ü®g, u, v, h1‚ü© := _root_.geometric_hahn_banach_compact_closed hs‚ÇÅ hs‚ÇÇ ht‚ÇÅ ht‚ÇÇ disj
  use extendToùïú'‚Çó g
  simp only [re_extendToùïú'‚Çó, exists_and_left]
  exact ‚ü®u, h1.1, v, h1.2‚ü©

theorem geometric_hahn_banach_closed_compact (hs‚ÇÅ : Convex ‚Ñù s) (hs‚ÇÇ : IsClosed s)
    (ht‚ÇÅ : Convex ‚Ñù t) (ht‚ÇÇ : IsCompact t) (disj : Disjoint s t) :
    ‚àÉ (f : StrongDual ùïú E) (u v : ‚Ñù), (‚àÄ a ‚àà s, re (f a) < u) ‚àß u < v ‚àß ‚àÄ b ‚àà t, v < re (f b) :=
  let ‚ü®f, s, t, hs, st, ht‚ü© := geometric_hahn_banach_compact_closed ht‚ÇÅ ht‚ÇÇ hs‚ÇÅ hs‚ÇÇ disj.symm
  ‚ü®-f, -t, -s, by simpa using ht, by simpa using st, by simpa using hs‚ü©

theorem geometric_hahn_banach_point_closed (ht‚ÇÅ : Convex ‚Ñù t) (ht‚ÇÇ : IsClosed t)
    (disj : x ‚àâ t) : ‚àÉ (f : StrongDual ùïú E) (u : ‚Ñù), re (f x) < u ‚àß ‚àÄ b ‚àà t, u < re (f b) :=
  let ‚ü®f, _u, v, ha, hst, hb‚ü© :=
    geometric_hahn_banach_compact_closed (convex_singleton x) isCompact_singleton ht‚ÇÅ ht‚ÇÇ
      (disjoint_singleton_left.2 disj)
  ‚ü®f, v, hst.trans' <| ha x <| mem_singleton _, hb‚ü©

theorem geometric_hahn_banach_closed_point (hs‚ÇÅ : Convex ‚Ñù s) (hs‚ÇÇ : IsClosed s)
    (disj : x ‚àâ s) : ‚àÉ (f : StrongDual ùïú E) (u : ‚Ñù), (‚àÄ a ‚àà s, re (f a) < u) ‚àß u < re (f x) :=
  let ‚ü®f, s, _t, ha, hst, hb‚ü© :=
    geometric_hahn_banach_closed_compact hs‚ÇÅ hs‚ÇÇ (convex_singleton x) isCompact_singleton
      (disjoint_singleton_right.2 disj)
  ‚ü®f, s, ha, hst.trans <| hb x <| mem_singleton _‚ü©

theorem geometric_hahn_banach_point_point [T1Space E] (hxy : x ‚â† y) :
    ‚àÉ f : StrongDual ùïú E, re (f x) < re (f y) := by
  obtain ‚ü®f, s, t, hs, st, ht‚ü© :=
    geometric_hahn_banach_compact_closed (ùïú := ùïú) (convex_singleton x) isCompact_singleton
      (convex_singleton y) isClosed_singleton (disjoint_singleton.2 hxy)
  exact ‚ü®f, by linarith [hs x rfl, ht y rfl]‚ü©

theorem iInter_halfSpaces_eq (hs‚ÇÅ : Convex ‚Ñù s) (hs‚ÇÇ : IsClosed s) :
    ‚ãÇ l : StrongDual ùïú E, { x | ‚àÉ y ‚àà s, re (l x) ‚â§ re (l y) } = s := by
  rw [Set.iInter_setOf]
  refine Set.Subset.antisymm (fun x hx => ?_) fun x hx l => ‚ü®x, hx, le_rfl‚ü©
  by_contra h
  obtain ‚ü®l, s, hlA, hl‚ü© := geometric_hahn_banach_closed_point (ùïú := ùïú) hs‚ÇÅ hs‚ÇÇ h
  obtain ‚ü®y, hy, hxy‚ü© := hx l
  exact ((hxy.trans_lt (hlA y hy)).trans hl).false

lemma mem_norm_le_of_balanced {ùïú : Type*} [RCLike ùïú] {K : Set ùïú} (Balanced_K : Balanced ùïú K)
    {x : ùïú} (hx : x ‚àà K) (h0 : ‚Äñx‚Äñ > 0) : ‚àÄ z : ùïú, 0 ‚â§ ‚Äñz‚Äñ ‚àß ‚Äñz‚Äñ ‚â§ ‚Äñx‚Äñ ‚Üí z ‚àà K :=
    fun z ‚ü®t1, t2‚ü© ‚Ü¶ by
  have : ‚Äñz / x‚Äñ ‚â§ 1 := by calc
    _ = ‚Äñz‚Äñ / ‚Äñx‚Äñ := by rw [norm_div]
    _ ‚â§ _ := (div_le_one‚ÇÄ h0).mpr t2
  have ne : x ‚â† 0 := fun nh ‚Ü¶ by simp [nh] at h0
  simpa [ne] using balanced_iff_smul_mem.mp Balanced_K this hx

theorem closed_balanced_sep {ùïú : Type*} [RCLike ùïú] {r : ‚Ñù} {K : Set ùïú} (compact_K : IsCompact K)
    (zero_in : 0 ‚àà K) (norm_lt_r : ‚àÄ x ‚àà K, ‚Äñx‚Äñ < r) :
    ‚àÉ s, 0 < s ‚àß s < r ‚àß (‚àÄ z ‚àà K, ‚Äñz‚Äñ < s) := by
  set g : ùïú ‚Üí ‚Ñù := fun x ‚Ü¶ ‚Äñx‚Äñ with hg
  obtain ‚ü®x, xin, eq‚ü© : sSup (g '' K) ‚àà g '' K :=
    IsCompact.sSup_mem (IsCompact.image compact_K continuous_norm) ‚ü®0, 0, zero_in, norm_zero‚ü©
  have g_le : ‚àÄ z ‚àà K, g z ‚â§ g x := fun z hz ‚Ü¶ by
    rw [eq]
    refine le_csSup ?_ (Set.mem_image_of_mem g hz)
    exact ‚ü®r, fun y ‚ü®x, hx, _‚ü© ‚Ü¶ by linarith [norm_lt_r x hx]‚ü©
  obtain ‚ü®s, hs‚ÇÅ, hs‚ÇÇ‚ü© : ‚àÉ s, g x < s ‚àß s < r := exists_between (by simp only [norm_lt_r x xin, g])
  exact ‚ü®s, by linarith [norm_nonneg x], hs‚ÇÇ, fun z hz ‚Ü¶ by linarith [norm_lt_r x xin, g_le z hz]‚ü©

/-- Following [Rudin, *Functional Analysis* (Theorem 3.7)][rudin1991]
-/
theorem geometric_hahn_banach {B : Set E} (hs‚ÇÅ : Convex ‚Ñù B) (hs‚ÇÇ : IsClosed B)
    (hs‚ÇÉ : Balanced ùïú B) (hs‚ÇÑ : B.Nonempty) {x‚ÇÄ : E} (hx : x‚ÇÄ ‚àâ B) :
    ‚àÉ (f : StrongDual ùïú E) (s : ‚Ñù), 0 < s ‚àß s < ‚Äñ(f x‚ÇÄ)‚Äñ ‚àß ‚àÄ b ‚àà B, ‚Äñf b‚Äñ < s := by
  obtain ‚ü®f, u, v, h1, h2, h3‚ü© : ‚àÉ (f : StrongDual ùïú E) (u v : ‚Ñù),
      (‚àÄ a ‚àà ({x‚ÇÄ} : Set E), re (f a) < u) ‚àß u < v ‚àß ‚àÄ b ‚àà B, v < re (f b) :=
    RCLike.geometric_hahn_banach_compact_closed (convex_singleton x‚ÇÄ) isCompact_singleton hs‚ÇÅ hs‚ÇÇ
      (Set.disjoint_singleton_left.mpr hx)
  have h3 : ‚àÄ z ‚àà f '' B, v < re z := fun z ‚ü®y, ‚ü®hy, eq‚ü©‚ü© ‚Ü¶ by
    rw [‚Üê eq]
    exact h3 y hy
  set K := closure (‚áëf '' B)
  have notin : f x‚ÇÄ ‚àâ K := fun h ‚Ü¶ by
    have : v ‚â§ re (f x‚ÇÄ) := le_on_closure_of_lt (by grind) continuous_re.continuousOn h
    linarith [h1 x‚ÇÄ rfl]
  have Balanced_K : Balanced ùïú K := by
    refine Balanced.closure (fun a ha _ ‚ü®_, ‚ü®‚ü®t, ht, _‚ü©, _‚ü©‚ü© ‚Ü¶ ?_)
    exact ‚ü®a ‚Ä¢ t, Balanced.smul_mem hs‚ÇÉ ha ht, by simp_all‚ü©
  have zero_in : 0 ‚àà K := subset_closure ‚ü®0, by simpa using Balanced.zero_mem hs‚ÇÉ hs‚ÇÑ‚ü©
  set r := ‚Äñf x‚ÇÄ‚Äñ with hr
  have r_pos : r > 0 := by simpa [hr] using fun nh ‚Ü¶ by simp [nh, zero_in] at notin
  have norm_lt_r : ‚àÄ x ‚àà K, ‚Äñx‚Äñ < r := fun x hx ‚Ü¶ by
    by_contra! nh
    have := mem_norm_le_of_balanced Balanced_K hx (by linarith) (f x‚ÇÄ) ‚ü®norm_nonneg (f x‚ÇÄ), nh‚ü©
    contradiction
  have compact_K : IsCompact K := by
    refine Metric.isCompact_of_isClosed_isBounded isClosed_closure ?_
    refine (Metric.isBounded_iff_subset_ball 0 (s := K)).mpr ?_
    exact ‚ü®r, fun x hx ‚Ü¶ mem_ball_zero_iff.mpr (norm_lt_r x hx)‚ü©
  obtain ‚ü®s, s_pos, s_lt, hs‚ü© : ‚àÉ s, 0 < s ‚àß s < r ‚àß (‚àÄ z ‚àà K, ‚Äñz‚Äñ < s) :=
    closed_balanced_sep compact_K zero_in norm_lt_r
  use f, s
  simpa [‚Üê hr, s_lt, s_pos] using fun b hb ‚Ü¶ hs (f b) (subset_closure (mem_image_of_mem (‚áëf) hb))

theorem geometric_hahn_banach' {B : Set E} (hs‚ÇÅ : Convex ‚Ñù B) (hs‚ÇÇ : IsClosed B)
    (hs‚ÇÉ : Balanced ùïú B) (hs‚ÇÑ : B.Nonempty) (x‚ÇÄ : E) (hx : x‚ÇÄ ‚àâ B) :
    ‚àÉ (f : StrongDual ùïú E), (‚Äñ(f x‚ÇÄ)‚Äñ > 1) ‚àß ‚àÄ b ‚àà B, ‚Äñf b‚Äñ < 1 := by
  obtain ‚ü®f, s, h1, h2, h3‚ü© := geometric_hahn_banach hs‚ÇÅ hs‚ÇÇ hs‚ÇÉ hs‚ÇÑ hx
  use (‚Äñf x‚ÇÄ‚Äñ / (s * (f x‚ÇÄ))) ‚Ä¢ f
  have (x : E): ‚Äñ((‚Äñf x‚ÇÄ‚Äñ / (s * f x‚ÇÄ)) ‚Ä¢ f) x‚Äñ = ‚Äñf x‚Äñ / s := by
    have : ‚Äñf x‚ÇÄ‚Äñ > 0 := by linarith
    simp [abs_of_pos h1, field]
  constructor
  ¬∑ rw [this]
    exact (one_lt_div‚ÇÄ h1).mpr h2
  ¬∑ intro b hb
    rw [this, div_lt_one‚ÇÄ h1]
    exact h3 b hb

end RCLike
