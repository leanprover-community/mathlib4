/-
Copyright (c) 2024 Geoffrey Irving. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Geoffrey Irving
-/
import Mathlib.Analysis.Calculus.FDeriv.Analytic

/-!
# Properties of analyticity restricted to a set

From `Mathlib.Analysis.Analytic.Basic`, we have the definitions

1. `AnalyticWithinAt ùïú f s x` means a power series at `x` converges to `f` on `ùìù[insert x s] x`.
2. `AnalyticWithinOn ùïú f s t` means `‚àÄ x ‚àà t, AnalyticWithinAt ùïú f s x`.

This means there exists an extension of `f` which is analytic and agrees with `f` on `s ‚à™ {x}`, but
`f` is allowed to be arbitrary elsewhere.  Requiring `ContinuousWithinAt` is essential if `x ‚àâ s`:
it is required for composition and smoothness to follow without extra hypotheses (we could
alternately require convergence at `x` even if `x ‚àâ s`).

Here we prove basic properties of these definitions. Where convenient we assume completeness of the
ambient space, which allows us to related `AnalyticWithinAt` to analyticity of a local extension.
-/

noncomputable section

open Topology Filter ENNReal

open Set Filter

variable {ùïú : Type*} [NontriviallyNormedField ùïú]

variable {E F G H : Type*} [NormedAddCommGroup E] [NormedSpace ùïú E] [NormedAddCommGroup F]
  [NormedSpace ùïú F] [NormedAddCommGroup G] [NormedSpace ùïú G] [NormedAddCommGroup H]
  [NormedSpace ùïú H]

/-!
### Basic properties
-/

/-- `AnalyticWithinAt` is trivial if `{x} ‚àà ùìù[s] x` -/
lemma analyticWithinAt_of_singleton_mem {f : E ‚Üí F} {s : Set E} {x : E} (h : {x} ‚àà ùìù[s] x) :
    AnalyticWithinAt ùïú f s x := by
  rcases mem_nhdsWithin.mp h with ‚ü®t, ot, xt, st‚ü©
  rcases Metric.mem_nhds_iff.mp (ot.mem_nhds xt) with ‚ü®r, r0, rt‚ü©
  exact ‚ü®constFormalMultilinearSeries ùïú E (f x), .ofReal r, {
    r_le := by simp only [FormalMultilinearSeries.constFormalMultilinearSeries_radius, le_top]
    r_pos := by positivity
    hasSum := by
      intro y ys yr
      simp only [subset_singleton_iff, mem_inter_iff, and_imp] at st
      simp only [mem_insert_iff, add_right_eq_self] at ys
      have : x + y = x := by
        rcases ys with rfl | ys
        ¬∑ simp
        ¬∑ exact st (x + y) (rt (by simpa using yr)) ys
      simp only [this]
      apply (hasFPowerSeriesOnBall_const (e := 0)).hasSum
      simp only [Metric.emetric_ball_top, mem_univ] }‚ü©

lemma AnalyticWithinOn.continuousOn {f : E ‚Üí F} {s : Set E} (h : AnalyticWithinOn ùïú f s) :
    ContinuousOn f s :=
  fun x m ‚Ü¶ (h x m).continuousWithinAt

/-- If `f` is `AnalyticWithinOn` near each point in a set, it is `AnalyticWithinOn` the set -/
lemma analyticWithinOn_of_locally_analyticWithinOn {f : E ‚Üí F} {s : Set E}
    (h : ‚àÄ x ‚àà s, ‚àÉ u, IsOpen u ‚àß x ‚àà u ‚àß AnalyticWithinOn ùïú f (s ‚à© u)) :
    AnalyticWithinOn ùïú f s := by
  intro x m
  rcases h x m with ‚ü®u, ou, xu, fu‚ü©
  rcases Metric.mem_nhds_iff.mp (ou.mem_nhds xu) with ‚ü®r, r0, ru‚ü©
  rcases fu x ‚ü®m, xu‚ü© with ‚ü®p, t, fp‚ü©
  exact ‚ü®p, min (.ofReal r) t, {
    r_pos := lt_min (by positivity) fp.r_pos
    r_le := min_le_of_right_le fp.r_le
    hasSum := by
        intro y ys yr
        simp only [EMetric.mem_ball, lt_min_iff, edist_lt_ofReal, dist_zero_right] at yr
        apply fp.hasSum
        ¬∑ simp only [mem_insert_iff, add_right_eq_self] at ys
          rcases ys with rfl | ys
          ¬∑ simp
          ¬∑ simp only [mem_insert_iff, add_right_eq_self, mem_inter_iff, ys, true_and]
            apply Or.inr (ru ?_)
            simp only [Metric.mem_ball, dist_self_add_left, yr]
        ¬∑ simp only [EMetric.mem_ball, yr] }‚ü©

/-- On open sets, `AnalyticOn` and `AnalyticWithinOn` coincide -/
lemma IsOpen.analyticWithinOn_iff_analyticOn {f : E ‚Üí F} {s : Set E} (hs : IsOpen s) :
    AnalyticWithinOn ùïú f s ‚Üî AnalyticOn ùïú f s := by
  refine ‚ü®?_, AnalyticOn.analyticWithinOn‚ü©
  intro hf x m
  rcases Metric.mem_nhds_iff.mp (hs.mem_nhds m) with ‚ü®r, r0, rs‚ü©
  rcases hf x m with ‚ü®p, t, fp‚ü©
  exact ‚ü®p, min (.ofReal r) t, {
    r_pos := lt_min (by positivity) fp.r_pos
    r_le := min_le_of_right_le fp.r_le
    hasSum := by
      intro y ym
      simp only [EMetric.mem_ball, lt_min_iff, edist_lt_ofReal, dist_zero_right] at ym
      refine fp.hasSum ?_ ym.2
      apply mem_insert_of_mem
      apply rs
      simp only [Metric.mem_ball, dist_self_add_left, ym.1] }‚ü©


/-!
### Equivalence to analyticity of a local extension

We show that `HasFPowerSeriesWithinOnBall`, `HasFPowerSeriesWithinAt`, and `AnalyticWithinAt` are
equivalent to the existence of a local extension with full analyticity.  We do not yet show a
result for `AnalyticWithinOn`, as this requires a bit more work to show that local extensions can
be stitched together.
-/

/-- `f` has power series `p` at `x` iff some local extension of `f` has that series -/
lemma hasFPowerSeriesWithinOnBall_iff_exists_hasFPowerSeriesOnBall [CompleteSpace F] {f : E ‚Üí F}
    {p : FormalMultilinearSeries ùïú E F} {s : Set E} {x : E} {r : ‚Ñù‚â•0‚àû} :
    HasFPowerSeriesWithinOnBall f p s x r ‚Üî
      ‚àÉ g, EqOn f g (insert x s ‚à© EMetric.ball x r) ‚àß
        HasFPowerSeriesOnBall g p x r := by
  constructor
  ¬∑ intro h
    refine ‚ü®fun y ‚Ü¶ p.sum (y - x), ?_, ?_‚ü©
    ¬∑ intro y ‚ü®ys,yb‚ü©
      simp only [EMetric.mem_ball, edist_eq_coe_nnnorm_sub] at yb
      have e0 := p.hasSum (x := y - x) ?_
      have e1 := (h.hasSum (y := y - x) ?_ ?_)
      ¬∑ simp only [add_sub_cancel] at e1
        exact e1.unique e0
      ¬∑ simpa only [add_sub_cancel]
      ¬∑ simpa only [EMetric.mem_ball, edist_eq_coe_nnnorm]
      ¬∑ simp only [EMetric.mem_ball, edist_eq_coe_nnnorm]
        exact lt_of_lt_of_le yb h.r_le
    ¬∑ refine ‚ü®h.r_le, h.r_pos, ?_‚ü©
      intro y lt
      simp only [add_sub_cancel_left]
      apply p.hasSum
      simp only [EMetric.mem_ball] at lt ‚ä¢
      exact lt_of_lt_of_le lt h.r_le
  ¬∑ intro ‚ü®g, hfg, hg‚ü©
    refine ‚ü®hg.r_le, hg.r_pos, ?_‚ü©
    intro y ys lt
    rw [hfg]
    ¬∑ exact hg.hasSum lt
    ¬∑ refine ‚ü®ys, ?_‚ü©
      simpa only [EMetric.mem_ball, edist_eq_coe_nnnorm_sub, add_sub_cancel_left, sub_zero] using lt

/-- `f` has power series `p` at `x` iff some local extension of `f` has that series -/
lemma hasFPowerSeriesWithinAt_iff_exists_hasFPowerSeriesAt [CompleteSpace F] {f : E ‚Üí F}
    {p : FormalMultilinearSeries ùïú E F} {s : Set E} {x : E} :
    HasFPowerSeriesWithinAt f p s x ‚Üî
      ‚àÉ g, f =·∂†[ùìù[insert x s] x] g ‚àß HasFPowerSeriesAt g p x := by
  constructor
  ¬∑ intro ‚ü®r, h‚ü©
    rcases hasFPowerSeriesWithinOnBall_iff_exists_hasFPowerSeriesOnBall.mp h with ‚ü®g, e, h‚ü©
    refine ‚ü®g, ?_, ‚ü®r, h‚ü©‚ü©
    refine Filter.eventuallyEq_iff_exists_mem.mpr ‚ü®_, ?_, e‚ü©
    exact inter_mem_nhdsWithin _ (EMetric.ball_mem_nhds _ h.r_pos)
  ¬∑ intro ‚ü®g, hfg, ‚ü®r, hg‚ü©‚ü©
    simp only [eventuallyEq_nhdsWithin_iff, Metric.eventually_nhds_iff] at hfg
    rcases hfg with ‚ü®e, e0, hfg‚ü©
    refine ‚ü®min r (.ofReal e), ?_‚ü©
    refine hasFPowerSeriesWithinOnBall_iff_exists_hasFPowerSeriesOnBall.mpr ‚ü®g, ?_, ?_‚ü©
    ¬∑ intro y ‚ü®ys, xy‚ü©
      refine hfg ?_ ys
      simp only [EMetric.mem_ball, lt_min_iff, edist_lt_ofReal] at xy
      exact xy.2
    ¬∑ exact hg.mono (lt_min hg.r_pos (by positivity)) (min_le_left _ _)

/-- `f` is analytic within `s` at `x` iff some local extension of `f` is analytic at `x` -/
lemma analyticWithinAt_iff_exists_analyticAt [CompleteSpace F] {f : E ‚Üí F} {s : Set E} {x : E} :
    AnalyticWithinAt ùïú f s x ‚Üî
      ‚àÉ g, f =·∂†[ùìù[insert x s] x] g ‚àß AnalyticAt ùïú g x := by
  simp only [AnalyticWithinAt, AnalyticAt, hasFPowerSeriesWithinAt_iff_exists_hasFPowerSeriesAt]
  tauto

/-- `f` is analytic within `s` at `x` iff some local extension of `f` is analytic at `x`. In this
version, we make sure that the extension coincides with `f` on all of `insert x s`. -/
lemma analyticWithinAt_iff_exists_analyticAt' [CompleteSpace F] {f : E ‚Üí F} {s : Set E} {x : E} :
    AnalyticWithinAt ùïú f s x ‚Üî
      ‚àÉ g, f x = g x ‚àß EqOn f g (insert x s) ‚àß AnalyticAt ùïú g x := by
  classical
  simp only [analyticWithinAt_iff_exists_analyticAt]
  refine ‚ü®?_, ?_‚ü©
  ¬∑ rintro ‚ü®g, hf, hg‚ü©
    rcases mem_nhdsWithin.1 hf with ‚ü®u, u_open, xu, hu‚ü©
    let g' := Set.piecewise u g f
    refine ‚ü®g', ?_, ?_, ?_‚ü©
    ¬∑ have : x ‚àà u ‚à© insert x s := ‚ü®xu, by simp‚ü©
      simpa [g', xu, this] using hu this
    ¬∑ intro y hy
      by_cases h'y : y ‚àà u
      ¬∑ have : y ‚àà u ‚à© insert x s := ‚ü®h'y, hy‚ü©
        simpa [g', h'y, this] using hu this
      ¬∑ simp [g', h'y]
    ¬∑ apply hg.congr
      filter_upwards [u_open.mem_nhds xu] with y hy using by simp [g', hy]
  ¬∑ rintro ‚ü®g, -, hf, hg‚ü©
    exact ‚ü®g, by filter_upwards [self_mem_nhdsWithin] using hf, hg‚ü©

alias ‚ü®AnalyticWithinAt.exists_analyticAt, _‚ü© := analyticWithinAt_iff_exists_analyticAt'

/-!
### Congruence

-/


lemma HasFPowerSeriesWithinOnBall.congr {f g : E ‚Üí F} {p : FormalMultilinearSeries ùïú E F}
    {s : Set E} {x : E} {r : ‚Ñù‚â•0‚àû} (h : HasFPowerSeriesWithinOnBall f p s x r)
    (h' : EqOn g f (s ‚à© EMetric.ball x r)) (h'' : g x = f x) :
    HasFPowerSeriesWithinOnBall g p s x r := by
  refine ‚ü®h.r_le, h.r_pos, ?_‚ü©
  ¬∑ intro y hy h'y
    convert h.hasSum hy h'y using 1
    simp only [mem_insert_iff, add_right_eq_self] at hy
    rcases hy with rfl | hy
    ¬∑ simpa using h''
    ¬∑ apply h'
      refine ‚ü®hy, ?_‚ü©
      simpa [edist_eq_coe_nnnorm_sub] using h'y

lemma HasFPowerSeriesWithinAt.congr {f g : E ‚Üí F} {p : FormalMultilinearSeries ùïú E F} {s : Set E}
    {x : E} (h : HasFPowerSeriesWithinAt f p s x) (h' : g =·∂†[ùìù[s] x] f) (h'' : g x = f x) :
    HasFPowerSeriesWithinAt g p s x := by
  rcases h with ‚ü®r, hr‚ü©
  obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ > 0, EMetric.ball x Œµ ‚à© s ‚äÜ {y | g y = f y} :=
    EMetric.mem_nhdsWithin_iff.1 h'
  let r' := min r Œµ
  refine ‚ü®r', ?_‚ü©
  have := hr.of_le (r' := r') (by simp [r', Œµpos, hr.r_pos]) (min_le_left _ _)
  apply this.congr _ h''
  intro z hz
  exact hŒµ ‚ü®EMetric.ball_subset_ball (min_le_right _ _) hz.2, hz.1‚ü©


lemma AnalyticWithinAt.congr_of_eventuallyEq {f g : E ‚Üí F} {s : Set E} {x : E}
    (hf : AnalyticWithinAt ùïú f s x) (hs : g =·∂†[ùìù[s] x] f) (hx : g x = f x) :
    AnalyticWithinAt ùïú g s x := by
  rcases hf with ‚ü®p, hp‚ü©
  exact ‚ü®p, hp.congr hs hx‚ü©

lemma AnalyticWithinAt.congr {f g : E ‚Üí F} {s : Set E} {x : E}
    (hf : AnalyticWithinAt ùïú f s x) (hs : EqOn g f s) (hx : g x = f x) :
    AnalyticWithinAt ùïú g s x :=
  hf.congr_of_eventuallyEq hs.eventuallyEq_nhdsWithin hx

lemma AnalyticWithinOn.congr {f g : E ‚Üí F} {s : Set E}
    (hf : AnalyticWithinOn ùïú f s) (hs : EqOn g f s) :
    AnalyticWithinOn ùïú g s :=
  fun x m ‚Ü¶ (hf x m).congr hs (hs m)

/-!
### Monotonicity w.r.t. the set we're analytic within
-/

lemma AnalyticWithinOn.mono {f : E ‚Üí F} {s t : Set E} (h : AnalyticWithinOn ùïú f t)
    (hs : s ‚äÜ t) : AnalyticWithinOn ùïú f s :=
  fun _ m ‚Ü¶ (h _ (hs m)).mono hs

/-!
### Analyticity within implies smoothness
-/

lemma AnalyticWithinAt.contDiffWithinAt [CompleteSpace F] {f : E ‚Üí F} {s : Set E} {x : E}
    (h : AnalyticWithinAt ùïú f s x) {n : ‚Ñï‚àû} : ContDiffWithinAt ùïú n f s x := by
  rcases h.exists_analyticAt with ‚ü®g, fx, fg, hg‚ü©
  exact hg.contDiffAt.contDiffWithinAt.congr (fg.mono (subset_insert _ _)) fx

lemma AnalyticWithinOn.contDiffOn [CompleteSpace F] {f : E ‚Üí F} {s : Set E}
    (h : AnalyticWithinOn ùïú f s) {n : ‚Ñï‚àû} : ContDiffOn ùïú n f s :=
  fun x m ‚Ü¶ (h x m).contDiffWithinAt
