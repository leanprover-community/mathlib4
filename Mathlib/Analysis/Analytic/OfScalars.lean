/-
Copyright (c) 2024 Edward Watine. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Edward Watine
-/
import Mathlib.Analysis.Analytic.ConvergenceRadius

/-!
# Scalar series

This file contains API for analytic functions `âˆ‘ cáµ¢ â€¢ xâ±` defined in terms of scalars
`câ‚€, câ‚, câ‚‚, â€¦`.
## Main definitions / results:
* `FormalMultilinearSeries.ofScalars`: the formal power series `âˆ‘ cáµ¢ â€¢ xâ±`.
* `FormalMultilinearSeries.ofScalarsSum`: the sum of such a power series, if it exists, and zero
  otherwise.
* `FormalMultilinearSeries.ofScalars_radius_eq_(zero/inv/top)_of_tendsto`:
  the ratio test for an analytic function defined in terms of a formal power series `âˆ‘ cáµ¢ â€¢ xâ±`.
* `FormalMultilinearSeries.ofScalars_radius_eq_inv_of_tendsto_ENNReal`:
  the ratio test for an analytic function using `ENNReal` division for all values `â„â‰¥0âˆ`.
-/

namespace FormalMultilinearSeries

section Field

open ContinuousMultilinearMap

variable {ğ•œ : Type*} (E : Type*) [Field ğ•œ] [Ring E] [Algebra ğ•œ E] [TopologicalSpace E]
  [IsTopologicalRing E] {c : â„• â†’ ğ•œ}

/-- Formal power series of `âˆ‘ cáµ¢ â€¢ xâ±` for some scalar field `ğ•œ` and ring algebra `E` -/
def ofScalars (c : â„• â†’ ğ•œ) : FormalMultilinearSeries ğ•œ E E :=
  fun n â†¦ c n â€¢ ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ n E

@[simp]
theorem ofScalars_eq_zero [Nontrivial E] (n : â„•) : ofScalars E c n = 0 â†” c n = 0 := by
  rw [ofScalars, smul_eq_zero (c := c n) (x := ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ n E)]
  refine or_iff_left (ContinuousMultilinearMap.ext_iff.1.mt <| not_forall_of_exists_not ?_)
  use fun _ â†¦ 1
  simp

@[simp]
theorem ofScalars_eq_zero_of_scalar_zero {n : â„•} (hc : c n = 0) : ofScalars E c n = 0 := by
  rw [ofScalars, hc, zero_smul ğ•œ (ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ n E)]

@[simp]
theorem ofScalars_series_eq_zero [Nontrivial E] : ofScalars E c = 0 â†” c = 0 := by
  simp [FormalMultilinearSeries.ext_iff, funext_iff]

variable (ğ•œ) in
@[simp]
theorem ofScalars_series_eq_zero_of_scalar_zero : ofScalars E (0 : â„• â†’ ğ•œ) = 0 := by
  simp [FormalMultilinearSeries.ext_iff]

@[simp]
theorem ofScalars_series_of_subsingleton [Subsingleton E] : ofScalars E c = 0 := by
  simp_rw [FormalMultilinearSeries.ext_iff, ofScalars, ContinuousMultilinearMap.ext_iff]
  exact fun _ _ â†¦ Subsingleton.allEq _ _

variable (ğ•œ) in
theorem ofScalars_series_injective [Nontrivial E] : Function.Injective (ofScalars E (ğ•œ := ğ•œ)) := by
  intro _ _
  refine Function.mtr fun h â†¦ ?_
  simp_rw [FormalMultilinearSeries.ext_iff, ofScalars, ContinuousMultilinearMap.ext_iff,
    ContinuousMultilinearMap.smul_apply]
  push_neg
  obtain âŸ¨n, hnâŸ© := Function.ne_iff.1 h
  refine âŸ¨n, fun _ â†¦ 1, ?_âŸ©
  simp only [mkPiAlgebraFin_apply, List.ofFn_const, List.prod_replicate, one_pow, ne_eq]
  exact (smul_left_injective ğ•œ one_ne_zero).ne hn

variable (c)

@[simp]
theorem ofScalars_series_eq_iff [Nontrivial E] (c' : â„• â†’ ğ•œ) :
    ofScalars E c = ofScalars E c' â†” c = c' :=
  âŸ¨fun e => ofScalars_series_injective ğ•œ E e, _root_.congrArg _âŸ©

theorem ofScalars_apply_zero (n : â„•) :
    ofScalars E c n (fun _ => 0) = Pi.single (M := fun _ => E) 0 (c 0 â€¢ 1) n := by
  rw [ofScalars]
  cases n <;> simp

@[simp]
lemma coeff_ofScalars {ğ•œ : Type*} [NontriviallyNormedField ğ•œ] {p : â„• â†’ ğ•œ} {n : â„•} :
    (FormalMultilinearSeries.ofScalars ğ•œ p).coeff n = p n := by
  simp [FormalMultilinearSeries.coeff, FormalMultilinearSeries.ofScalars, List.prod_ofFn]

theorem ofScalars_add (c' : â„• â†’ ğ•œ) : ofScalars E (c + c') = ofScalars E c + ofScalars E c' := by
  unfold ofScalars
  simp_rw [Pi.add_apply, Pi.add_def _ _]
  exact funext fun n â†¦ Module.add_smul (c n) (c' n) (ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ n E)

theorem ofScalars_smul (x : ğ•œ) : ofScalars E (x â€¢ c) = x â€¢ ofScalars E c := by
  unfold ofScalars
  simp [Pi.smul_def x _, smul_smul]

theorem ofScalars_comp_neg_id :
    (ofScalars E c).compContinuousLinearMap (-ContinuousLinearMap.id _ _) =
    (ofScalars E (fun k â†¦ (-1) ^ k * c k)) := by
  ext n
  rcases n.even_or_odd with (h | h) <;>
  simp [ofScalars, show ((-ContinuousLinearMap.id ğ•œ E : _) : E â†’ E) = Neg.neg by rfl,
    â† List.map_ofFn, h.neg_one_pow]

theorem ofScalars_comp_neg (f : E â†’L[ğ•œ] E) :
    (ofScalars E c).compContinuousLinearMap (-f) =
    (ofScalars E (fun k â†¦ (-1) ^ k * c k)).compContinuousLinearMap f := by
  conv => lhs; rw [â† ContinuousLinearMap.id_comp f, â† ContinuousLinearMap.neg_comp]
  rw [â† FormalMultilinearSeries.compContinuousLinearMap_comp, ofScalars_comp_neg_id]

variable (ğ•œ) in
/-- The submodule generated by scalar series on `FormalMultilinearSeries ğ•œ E E`. -/
def ofScalarsSubmodule : Submodule ğ•œ (FormalMultilinearSeries ğ•œ E E) where
  carrier := {ofScalars E f | f}
  add_mem' := fun âŸ¨c, hcâŸ© âŸ¨c', hc'âŸ© â†¦ âŸ¨c + c', hc' â–¸ hc â–¸ ofScalars_add E c c'âŸ©
  zero_mem' := âŸ¨0, ofScalars_series_eq_zero_of_scalar_zero ğ•œ EâŸ©
  smul_mem' := fun x _ âŸ¨c, hcâŸ© â†¦ âŸ¨x â€¢ c, hc â–¸ ofScalars_smul E c xâŸ©

variable {E}

theorem ofScalars_apply_eq (x : E) (n : â„•) :
    ofScalars E c n (fun _ â†¦ x) = c n â€¢ x ^ n := by
  simp [ofScalars]

/-- This naming follows the convention of `NormedSpace.expSeries_apply_eq'`. -/
theorem ofScalars_apply_eq' (x : E) :
    (fun n â†¦ ofScalars E c n (fun _ â†¦ x)) = fun n â†¦ c n â€¢ x ^ n := by
  simp [ofScalars]

/-- The sum of the formal power series. Takes the value `0` outside the radius of convergence. -/
noncomputable def ofScalarsSum := (ofScalars E c).sum

theorem ofScalars_sum_eq (x : E) : ofScalarsSum c x =
    âˆ‘' n, c n â€¢ x ^ n := tsum_congr fun n => ofScalars_apply_eq c x n

theorem ofScalarsSum_eq_tsum : ofScalarsSum c =
    fun (x : E) => âˆ‘' n : â„•, c n â€¢ x ^ n := funext (ofScalars_sum_eq c)

@[simp]
theorem ofScalarsSum_zero : ofScalarsSum c (0 : E) = c 0 â€¢ 1 := by
  simp [ofScalarsSum_eq_tsum, â† ofScalars_apply_eq, ofScalars_apply_zero]

@[simp]
theorem ofScalarsSum_of_subsingleton [Subsingleton E] {x : E} : ofScalarsSum c x = 0 := by
  simp [Subsingleton.eq_zero x, Subsingleton.eq_zero (1 : E)]

@[simp]
theorem ofScalarsSum_op [T2Space E] (x : E) :
    ofScalarsSum c (MulOpposite.op x) = MulOpposite.op (ofScalarsSum c x) := by
  simp [ofScalars_sum_eq, â† MulOpposite.op_pow, â† MulOpposite.op_smul, tsum_op]

@[simp]
theorem ofScalarsSum_unop [T2Space E] (x : Eáµáµ’áµ–) :
    ofScalarsSum c (MulOpposite.unop x) = MulOpposite.unop (ofScalarsSum c x) := by
  simp [ofScalars_sum_eq, â† MulOpposite.unop_pow, â† MulOpposite.unop_smul, tsum_unop]

end Field

section Seminormed

open Filter ENNReal
open scoped Topology NNReal

variable {ğ•œ : Type*} (E : Type*) [NontriviallyNormedField ğ•œ] [SeminormedRing E]
    [NormedAlgebra ğ•œ E] (c : â„• â†’ ğ•œ) (n : â„•)

theorem ofScalars_norm_eq_mul :
    â€–ofScalars E c nâ€– = â€–c nâ€– * â€–ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ n Eâ€– := by
  rw [ofScalars, norm_smul]

theorem ofScalars_norm_le (hn : n > 0) : â€–ofScalars E c nâ€– â‰¤ â€–c nâ€– := by
  simp only [ofScalars_norm_eq_mul]
  exact (mul_le_of_le_one_right (norm_nonneg _)
    (ContinuousMultilinearMap.norm_mkPiAlgebraFin_le_of_pos hn))

@[simp]
theorem ofScalars_norm [NormOneClass E] : â€–ofScalars E c nâ€– = â€–c nâ€– := by
  simp [ofScalars_norm_eq_mul]

end Seminormed

section Normed

open Filter ENNReal
open scoped Topology NNReal

variable {ğ•œ : Type*} (E : Type*) [NontriviallyNormedField ğ•œ] [NormedRing E]
    [NormedAlgebra ğ•œ E] (c : â„• â†’ ğ•œ) (n : â„•)

private theorem tendsto_succ_norm_div_norm {r r' : â„â‰¥0} (hr' : r' â‰  0)
    (hc : Tendsto (fun n â†¦ â€–c n.succâ€– / â€–c nâ€–) atTop (ğ“ r)) :
      Tendsto (fun n â†¦ â€–â€–c (n + 1)â€– * r' ^ (n + 1)â€– /
        â€–â€–c nâ€– * r' ^ nâ€–) atTop (ğ“ â†‘(r' * r)) := by
  simp_rw [norm_mul, norm_norm, mul_div_mul_comm, â† norm_div, pow_succ, mul_div_right_comm,
    div_self (pow_ne_zero _ (NNReal.coe_ne_zero.mpr hr')), one_mul, norm_div, NNReal.norm_eq]
  exact mul_comm r' r â–¸ hc.mul tendsto_const_nhds

theorem ofScalars_radius_ge_inv_of_tendsto {r : â„â‰¥0} (hr : r â‰  0)
    (hc : Tendsto (fun n â†¦ â€–c n.succâ€– / â€–c nâ€–) atTop (ğ“ r)) :
      (ofScalars E c).radius â‰¥ ofNNReal râ»Â¹ := by
  refine le_of_forall_nnreal_lt (fun r' hr' â†¦ ?_)
  rw [coe_lt_coe, NNReal.lt_inv_iff_mul_lt hr] at hr'
  by_cases hrz : r' = 0
  Â· simp [hrz]
  apply FormalMultilinearSeries.le_radius_of_summable_norm
  refine Summable.of_norm_bounded_eventually (g := fun n â†¦ â€–â€–c nâ€– * r' ^ nâ€–) ?_ ?_
  Â· refine summable_of_ratio_test_tendsto_lt_one hr' ?_ ?_
    Â· refine (hc.eventually_ne (NNReal.coe_ne_zero.mpr hr)).mp (Eventually.of_forall ?_)
      simp_all
    Â· simp_rw [norm_norm]
      exact tendsto_succ_norm_div_norm c hrz hc
  Â· filter_upwards [eventually_cofinite_ne 0] with n hn
    simp only [norm_mul, norm_norm, norm_pow, NNReal.norm_eq]
    gcongr
    exact ofScalars_norm_le E c n (Nat.pos_iff_ne_zero.mpr hn)

/-- The radius of convergence of a scalar series is the inverse of the non-zero limit
`fun n â†¦ â€–c n.succâ€– / â€–c nâ€–`. -/
theorem ofScalars_radius_eq_inv_of_tendsto [NormOneClass E] {r : â„â‰¥0} (hr : r â‰  0)
    (hc : Tendsto (fun n â†¦ â€–c n.succâ€– / â€–c nâ€–) atTop (ğ“ r)) :
      (ofScalars E c).radius = ofNNReal râ»Â¹ := by
  refine le_antisymm ?_ (ofScalars_radius_ge_inv_of_tendsto E c hr hc)
  refine le_of_forall_nnreal_lt (fun r' hr' â†¦ ?_)
  rw [coe_le_coe, NNReal.le_inv_iff_mul_le hr]
  have := FormalMultilinearSeries.summable_norm_mul_pow _ hr'
  contrapose! this
  apply not_summable_of_ratio_test_tendsto_gt_one this
  simp_rw [ofScalars_norm]
  exact tendsto_succ_norm_div_norm c (by aesop) hc

/-- A convenience lemma restating the result of `ofScalars_radius_eq_inv_of_tendsto` under
the inverse ratio. -/
theorem ofScalars_radius_eq_of_tendsto [NormOneClass E] {r : NNReal} (hr : r â‰  0)
    (hc : Tendsto (fun n â†¦ â€–c nâ€– / â€–c n.succâ€–) atTop (ğ“ r)) :
      (ofScalars E c).radius = ofNNReal r := by
  suffices Tendsto (fun n â†¦ â€–c n.succâ€– / â€–c nâ€–) atTop (ğ“ râ»Â¹) by
    convert ofScalars_radius_eq_inv_of_tendsto E c (inv_ne_zero hr) this
    simp
  convert hc.invâ‚€ (NNReal.coe_ne_zero.mpr hr) using 1
  simp

/-- The ratio test stating that if `â€–c n.succâ€– / â€–c nâ€–` tends to zero, the radius is unbounded.
This requires that the coefficients are eventually non-zero as
`â€–c n.succâ€– / 0 = 0` by convention. -/
theorem ofScalars_radius_eq_top_of_tendsto (hc : âˆ€á¶  n in atTop, c n â‰  0)
    (hc' : Tendsto (fun n â†¦ â€–c n.succâ€– / â€–c nâ€–) atTop (ğ“ 0)) : (ofScalars E c).radius = âŠ¤ := by
  refine radius_eq_top_of_summable_norm _ fun r' â†¦ ?_
  by_cases hrz : r' = 0
  Â· apply Summable.comp_nat_add (k := 1)
    simpa [hrz] using (summable_const_iff 0).mpr rfl
  Â· refine Summable.of_norm_bounded_eventually (g := fun n â†¦ â€–â€–c nâ€– * r' ^ nâ€–) ?_ ?_
    Â· apply summable_of_ratio_test_tendsto_lt_one zero_lt_one (hc.mp (Eventually.of_forall ?_))
      Â· simp only [norm_norm]
        exact mul_zero (_ : â„) â–¸ tendsto_succ_norm_div_norm _ hrz (NNReal.coe_zero â–¸ hc')
      Â· simp_all
    Â· filter_upwards [eventually_cofinite_ne 0] with n hn
      simp only [norm_mul, norm_norm, norm_pow, NNReal.norm_eq]
      gcongr
      exact ofScalars_norm_le E c n (Nat.pos_iff_ne_zero.mpr hn)

/-- If `â€–c n.succâ€– / â€–c nâ€–` is unbounded, then the radius of convergence is zero. -/
theorem ofScalars_radius_eq_zero_of_tendsto [NormOneClass E]
    (hc : Tendsto (fun n â†¦ â€–c n.succâ€– / â€–c nâ€–) atTop atTop) : (ofScalars E c).radius = 0 := by
  suffices (ofScalars E c).radius â‰¤ 0 by simp_all
  refine le_of_forall_nnreal_lt (fun r hr â†¦ ?_)
  rw [â† coe_zero, coe_le_coe]
  have := FormalMultilinearSeries.summable_norm_mul_pow _ hr
  contrapose! this
  apply not_summable_of_ratio_norm_eventually_ge ENNReal.one_lt_two
  Â· contrapose! hc
    apply not_tendsto_atTop_of_tendsto_nhds (a:=0)
    rw [not_frequently] at hc
    apply Tendsto.congr' ?_ tendsto_const_nhds
    filter_upwards [hc] with n hc'
    rw [ofScalars_norm, norm_mul, norm_norm, not_ne_iff, mul_eq_zero] at hc'
    cases hc' <;> aesop
  Â· filter_upwards [hc.eventually_ge_atTop (2*râ»Â¹), eventually_ne_atTop 0] with n hc hn
    simp only [ofScalars_norm, norm_mul, norm_norm, norm_pow, NNReal.norm_eq]
    rw [mul_comm â€–c nâ€–, â† mul_assoc, â† div_le_div_iffâ‚€, mul_div_assoc]
    Â· convert hc
      rw [pow_succ, div_mul_cancel_leftâ‚€, NNReal.coe_inv]
      aesop
    Â· simp_all
    Â· refine Ne.lt_of_le (fun hr' â†¦ Not.elim ?_ hc) (norm_nonneg _)
      rw [â† hr']
      simp [this]

/-- This theorem combines the results of the special cases above, using `ENNReal` division to remove
the requirement that the ratio is eventually non-zero. -/
theorem ofScalars_radius_eq_inv_of_tendsto_ENNReal [NormOneClass E] {r : â„â‰¥0âˆ}
    (hc' : Tendsto (fun n â†¦ ENNReal.ofReal â€–c n.succâ€– / ENNReal.ofReal â€–c nâ€–) atTop (ğ“ r)) :
      (ofScalars E c).radius = râ»Â¹ := by
  rcases ENNReal.trichotomy r with (hr | hr | hr)
  Â· simp_rw [hr, inv_zero] at hc' âŠ¢
    by_cases h : (âˆ€á¶  (n : â„•) in atTop, c n â‰  0)
    Â· apply ofScalars_radius_eq_top_of_tendsto E c h ?_
      refine Tendsto.congr' ?_ <| (tendsto_toReal zero_ne_top).comp hc'
      filter_upwards [h]
      simp
    Â· apply (ofScalars E c).radius_eq_top_of_eventually_eq_zero
      simp only [eventually_atTop, not_exists, not_forall, not_not] at h âŠ¢
      obtain âŸ¨ti, htiâŸ© := eventually_atTop.mp (hc'.eventually_ne zero_ne_top)
      obtain âŸ¨zi, hzi, zâŸ© := h ti
      refine âŸ¨zi, Nat.le_induction (ofScalars_eq_zero_of_scalar_zero E z) fun n hmn a â†¦ ?_âŸ©
      nontriviality E
      simp only [ofScalars_eq_zero] at a âŠ¢
      contrapose! hti
      exact âŸ¨n, hzi.trans hmn, ENNReal.div_eq_top.mpr (by simp [a, hti])âŸ©
  Â· simp_rw [hr, inv_top] at hc' âŠ¢
    apply ofScalars_radius_eq_zero_of_tendsto E c ((tendsto_add_atTop_iff_nat 1).mp ?_)
    refine tendsto_ofReal_nhds_top.mp (Tendsto.congr' ?_ ((tendsto_add_atTop_iff_nat 1).mpr hc'))
    filter_upwards [hc'.eventually_ne top_ne_zero] with n hn
    apply (ofReal_div_of_pos (Ne.lt_of_le (Ne.symm ?_) (norm_nonneg _))).symm
    simp_all
  Â· have hr' := toReal_ne_zero.mp hr.ne.symm
    have hr'' := toNNReal_ne_zero.mpr hr' -- this result could go in ENNReal
    convert ofScalars_radius_eq_inv_of_tendsto E c hr'' ?_
    Â· simp [ENNReal.coe_inv hr'', ENNReal.coe_toNNReal (toReal_ne_zero.mp hr.ne.symm).2]
    Â· simp_rw [ENNReal.coe_toNNReal_eq_toReal]
      refine Tendsto.congr' ?_ <| (tendsto_toReal hr'.2).comp hc'
      filter_upwards [hc'.eventually_ne hr'.1, hc'.eventually_ne hr'.2]
      simp

end Normed

end FormalMultilinearSeries
