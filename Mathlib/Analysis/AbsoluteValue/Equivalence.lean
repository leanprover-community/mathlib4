/-
Copyright (c) 2025 Michael Stoll. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Michael Stoll
-/
import Mathlib.Analysis.SpecialFunctions.Pow.Real
import Mathlib.Analysis.Normed.Ring.WithAbs

/-!
# Equivalence of real-valued absolute values

Two absolute values `v‚ÇÅ, v‚ÇÇ : AbsoluteValue R ‚Ñù` are *equivalent* if there exists a
positive real number `c` such that `v‚ÇÅ x ^ c = v‚ÇÇ x` for all `x : R`.
-/

namespace AbsoluteValue

section OrderedSemiring

variable {R : Type*} [Semiring R] {S : Type*} [Semiring S] [PartialOrder S]
  (v w : AbsoluteValue R S)

/-- Two absolute values `v` and `w` are *equivalent* if `v x ‚â§ v y` precisely when
`w x ‚â§ w y`.

Note that for real absolute values this condition is equivalent to the existence of a positive
real number `c` such that `v x ^ c = w x` for all `x`. See
`AbsoluteValue.isEquiv_iff_exists_rpow_eq`. -/
def IsEquiv : Prop := ‚àÄ x y, v x ‚â§ v y ‚Üî w x ‚â§ w y

theorem IsEquiv.refl : v.IsEquiv v := fun _ _ ‚Ü¶ .rfl

variable {v w}

theorem IsEquiv.rfl : v.IsEquiv v := fun _ _ ‚Ü¶ .rfl

theorem IsEquiv.symm (h : v.IsEquiv w) : w.IsEquiv v := fun _ _ ‚Ü¶ (h _ _).symm

theorem IsEquiv.trans {u : AbsoluteValue R S} (h‚ÇÅ : v.IsEquiv w)
    (h‚ÇÇ : w.IsEquiv u) : v.IsEquiv u := fun _ _ ‚Ü¶ (h‚ÇÅ _ _).trans (h‚ÇÇ _ _)

@[deprecated (since := "2025-09-10")] alias isEquiv_refl := IsEquiv.refl
@[deprecated (since := "2025-09-10")] alias isEquiv_symm := IsEquiv.symm
@[deprecated (since := "2025-09-10")] alias isEquiv_trans := IsEquiv.trans

instance : Setoid (AbsoluteValue R S) where
  r := IsEquiv
  iseqv := {
    refl := .refl
    symm := .symm
    trans := .trans
  }

theorem IsEquiv.lt_iff_lt (h : v.IsEquiv w) {x y : R} : v x < v y ‚Üî w x < w y :=
  lt_iff_lt_of_le_iff_le' (h y x) (h x y)

theorem IsEquiv.eq_iff_eq (h : v.IsEquiv w) {x y : R} : v x = v y ‚Üî w x = w y := by
  simp [le_antisymm_iff, h x y, h y x]

variable [IsDomain S] [Nontrivial R]

theorem IsEquiv.lt_one_iff (h : v.IsEquiv w) {x : R} :
    v x < 1 ‚Üî w x < 1 := by
  simpa only [map_one] using h.lt_iff_lt (y := 1)

theorem IsEquiv.one_lt_iff (h : v.IsEquiv w) {x : R} :
    1 < v x ‚Üî 1 < w x := by
  simpa only [map_one] using h.lt_iff_lt (x := 1)

theorem IsEquiv.le_one_iff (h : v.IsEquiv w) {x : R} :
    v x ‚â§ 1 ‚Üî w x ‚â§ 1 := by
  simpa only [map_one] using h x 1

theorem IsEquiv.one_le_iff (h : v.IsEquiv w) {x : R} :
    1 ‚â§ v x ‚Üî 1 ‚â§ w x := by
  simpa only [map_one] using h 1 x

theorem IsEquiv.eq_one_iff (h : v.IsEquiv w) {x : R} : v x = 1 ‚Üî w x = 1 := by
  simpa only [map_one] using h.eq_iff_eq (x := x) (y := 1)

theorem IsEquiv.isNontrivial_iff {w : AbsoluteValue R S} (h : v.IsEquiv w) :
    v.IsNontrivial ‚Üî w.IsNontrivial :=
  not_iff_not.1 <| by aesop (add simp [not_isNontrivial_iff, h.eq_one_iff])
alias ‚ü®IsEquiv.isNontrivial, _‚ü© := IsEquiv.isNontrivial_iff

end OrderedSemiring

section LinearOrderedSemifield

variable {R S : Type*} [Field R] [Semifield S] [LinearOrder S] {v w : AbsoluteValue R S}

/-- An absolute value is equivalent to the trivial iff it is trivial itself. -/
@[simp]
lemma isEquiv_trivial_iff_eq_trivial [DecidablePred fun x : R ‚Ü¶ x = 0] [NoZeroDivisors R]
    [IsStrictOrderedRing S] {f : AbsoluteValue R S} :
    f.IsEquiv .trivial ‚Üî f = .trivial :=
  ‚ü®fun h ‚Ü¶ by aesop (add simp [h.eq_one_iff, AbsoluteValue.trivial]), fun h ‚Ü¶ h ‚ñ∏ .rfl‚ü©

@[deprecated (since := "2025-09-10")]
alias eq_trivial_of_isEquiv_trivial := isEquiv_trivial_iff_eq_trivial

variable [IsStrictOrderedRing S]

theorem isEquiv_iff_lt_one_iff :
    v.IsEquiv w ‚Üî ‚àÄ x, v x < 1 ‚Üî w x < 1 := by
  refine ‚ü®fun h _ ‚Ü¶ h.lt_one_iff, fun h x y ‚Ü¶ ?_‚ü©
  rcases eq_or_ne (v x) 0 with (_ | hy‚ÇÄ) <;> simp_all
  rw [le_iff_le_iff_lt_iff_lt, ‚Üê one_mul (v x), ‚Üê mul_inv_lt_iff‚ÇÄ (by simp_all), ‚Üê one_mul (w x),
    ‚Üê mul_inv_lt_iff‚ÇÄ (by simp_all), ‚Üê map_inv‚ÇÄ, ‚Üê map_mul, ‚Üê map_inv‚ÇÄ, ‚Üê map_mul]
  exact h _

variable [Archimedean S] [ExistsAddOfLE S]

theorem isEquiv_of_lt_one_imp (hv : v.IsNontrivial) (h : ‚àÄ x, v x < 1 ‚Üí w x < 1) : v.IsEquiv w := by
  refine isEquiv_iff_lt_one_iff.2 fun a ‚Ü¶ ?_
  rcases eq_or_ne a 0 with (rfl | ha‚ÇÄ) <;> try simp
  refine ‚ü®h a, fun hw ‚Ü¶ ?_‚ü©
  let ‚ü®x‚ÇÄ, hx‚ÇÄ‚ü© := hv.exists_abv_lt_one
  have hpow (n : ‚Ñï) (hv : 1 ‚â§ v a) : w x‚ÇÄ < w a ^ n := by
    rw [‚Üê one_mul (_ ^ _), ‚Üê mul_inv_lt_iff‚ÇÄ (pow_pos (by simp_all) _),
      ‚Üê map_pow, ‚Üê map_inv‚ÇÄ, ‚Üê map_mul]
    apply h
    rw [map_mul, map_inv‚ÇÄ, map_pow, mul_inv_lt_iff‚ÇÄ (pow_pos (by simp [ha‚ÇÄ]) _), one_mul]
    exact lt_of_lt_of_le hx‚ÇÄ.2 <| one_le_pow‚ÇÄ hv
  obtain ‚ü®n, hn‚ü© := exists_pow_lt_of_lt_one (w.pos hx‚ÇÄ.1) hw
  exact not_le.1 <| mt (hpow n) <| not_lt.2 hn.le

/--
If `v` and `w` are inequivalent absolute values and `v` is non-trivial, then we can find an `a : R`
such that `v a < 1` while `1 ‚â§ w a`.
-/
theorem exists_lt_one_one_le_of_not_isEquiv {v w : AbsoluteValue R S} (hv : v.IsNontrivial)
    (h : ¬¨v.IsEquiv w) : ‚àÉ a : R, v a < 1 ‚àß 1 ‚â§ w a := by
  contrapose! h
  exact isEquiv_of_lt_one_imp hv h

/--
If `v` and `w` are two non-trivial and inequivalent absolute values then we can find an `a : R`
such that `1 < v a` while `w a < 1`.
-/
theorem exists_one_lt_lt_one_of_not_isEquiv {v w : AbsoluteValue R S} (hv : v.IsNontrivial)
    (hw : w.IsNontrivial) (h : ¬¨v.IsEquiv w) :
    ‚àÉ a : R, 1 < v a ‚àß w a < 1 := by
  let ‚ü®a, hva, hwa‚ü© := exists_lt_one_one_le_of_not_isEquiv hv h
  let ‚ü®b, hwb, hvb‚ü© := exists_lt_one_one_le_of_not_isEquiv hw (mt .symm h)
  exact ‚ü®b / a, by simp [w.pos_iff.1 (lt_of_lt_of_le zero_lt_one hwa), one_lt_div, div_lt_one,
    lt_of_le_of_lt' hvb hva, lt_of_le_of_lt' hwa hwb]‚ü©

end LinearOrderedSemifield

section Real

variable {F : Type*} [Field F] {v w : AbsoluteValue F ‚Ñù}

open Real in
theorem IsEquiv.log_div_log_pos (h : v.IsEquiv w) {a : F} (ha‚ÇÄ : a ‚â† 0) (ha‚ÇÅ : w a ‚â† 1) :
    0 < (w a).log / (v a).log := by
  rcases ha‚ÇÅ.lt_or_gt with hwa | hwa
  ¬∑ simpa using div_pos (neg_pos_of_neg <| log_neg (w.pos ha‚ÇÄ) (hwa))
      (neg_pos_of_neg <| log_neg (v.pos ha‚ÇÄ) (h.lt_one_iff.2 hwa))
  ¬∑ exact div_pos (log_pos <| hwa) (log_pos (h.one_lt_iff.2 hwa))

open Real in
/--
If $v$ and $w$ are two real absolute values on a field $F$, equivalent in the sense that
$v(x) \leq v(y)$ if and only if $w(x) \leq w(y)$, then $\frac{\log (v(a))}{\log (w(a))}$ is
constant for all $0 \neq a\in F$ with $v(a) \neq 1$.
-/
theorem IsEquiv.log_div_log_eq_log_div_log (h : v.IsEquiv w)
    {a : F} (ha‚ÇÄ : a ‚â† 0) (ha‚ÇÅ : v a ‚â† 1) {b : F} (hb‚ÇÄ : b ‚â† 0) (hb‚ÇÅ : v b ‚â† 1) :
    (v b).log / (w b).log = (v a).log / (w a).log := by
  by_contra! h_ne
  wlog ha : 1 < v a generalizing a b
  ¬∑ apply this (inv_ne_zero ha‚ÇÄ) (by simpa) hb‚ÇÄ hb‚ÇÅ (by simpa)
    simpa using one_lt_inv_iff‚ÇÄ.2 ‚ü®v.pos ha‚ÇÄ, ha‚ÇÅ.lt_of_le (not_lt.1 ha)‚ü©
  wlog hb : 1 < v b generalizing a b
  ¬∑ apply this ha‚ÇÄ ha‚ÇÅ (inv_ne_zero hb‚ÇÄ) (by simpa) (by simpa) ha
    simpa using one_lt_inv_iff‚ÇÄ.2 ‚ü®v.pos hb‚ÇÄ, hb‚ÇÅ.lt_of_le (not_lt.1 hb)‚ü©
  wlog h_lt : (v b).log / (w b).log < (v a).log / (w a).log generalizing a b
  ¬∑ exact this hb‚ÇÄ hb‚ÇÅ ha‚ÇÄ ha‚ÇÅ h_ne.symm hb ha <| lt_of_le_of_ne (not_lt.1 h_lt) h_ne.symm
  have hwa := h.one_lt_iff.1 ha
  have hwb := h.one_lt_iff.1 hb
  rw [div_lt_div_iff‚ÇÄ (log_pos hwb) (log_pos hwa), mul_comm (v a).log,
    ‚Üê div_lt_div_iff‚ÇÄ (log_pos ha) (log_pos hwa)] at h_lt
  let ‚ü®q, ‚ü®hq‚ÇÅ, hq‚ÇÇ‚ü©‚ü© := exists_rat_btwn h_lt
  rw [‚Üê Rat.num_div_den q, Rat.cast_div, Rat.cast_intCast, Rat.cast_natCast] at hq‚ÇÅ hq‚ÇÇ
  rw [div_lt_div_iff‚ÇÄ (log_pos ha) (by simp [q.den_pos]), mul_comm, ‚Üê log_pow, ‚Üê log_zpow,
    log_lt_log_iff (pow_pos (by linarith) _) (zpow_pos (by linarith) _),
    ‚Üê div_lt_one (zpow_pos (by linarith) _), ‚Üê map_pow, ‚Üê map_zpow‚ÇÄ, ‚Üê map_div‚ÇÄ] at hq‚ÇÅ
  rw [div_lt_div_iff‚ÇÄ (by simp [q.den_pos]) (log_pos hwa), mul_comm (w _).log,
    ‚Üê log_pow, ‚Üê log_zpow, log_lt_log_iff (zpow_pos (by linarith) _) (pow_pos (by linarith) _),
    ‚Üê one_lt_div (zpow_pos (by linarith) _), ‚Üê map_pow, ‚Üê map_zpow‚ÇÄ, ‚Üê map_div‚ÇÄ] at hq‚ÇÇ
  exact not_lt_of_gt (h.lt_one_iff.1 hq‚ÇÅ) hq‚ÇÇ

open Real in
/--
If `v` and `w` are two real absolute values on a field `F`, then `v` and `w` are equivalent if
and only if there exists a positive real constant `c` such that for all `x : R`, `(f x)^c = g x`.
-/
theorem isEquiv_iff_exists_rpow_eq {v w : AbsoluteValue F ‚Ñù} :
    v.IsEquiv w ‚Üî ‚àÉ c : ‚Ñù, 0 < c ‚àß (v ¬∑ ^ c) = w := by
  refine ‚ü®fun h ‚Ü¶ ?_, fun ‚ü®t, ht, h‚ü© ‚Ü¶ isEquiv_iff_lt_one_iff.2
    fun x ‚Ü¶ h ‚ñ∏ (rpow_lt_one_iff' (v.nonneg x) ht).symm‚ü©
  by_cases hw : w.IsNontrivial
  ¬∑ let ‚ü®a, ha‚ÇÄ, ha‚ÇÅ‚ü© := hw
    refine ‚ü®(w a).log / (v a).log, h.log_div_log_pos ha‚ÇÄ ha‚ÇÅ, funext fun b ‚Ü¶ ?_‚ü©
    rcases eq_or_ne b 0 with rfl | hb‚ÇÄ; ¬∑ simp [zero_rpow (by linarith [h.log_div_log_pos ha‚ÇÄ ha‚ÇÅ])]
    rcases eq_or_ne (w b) 1 with hb‚ÇÅ | hb‚ÇÅ; ¬∑ simp [hb‚ÇÅ, h.eq_one_iff.2 hb‚ÇÅ]
    rw [‚Üê h.symm.log_div_log_eq_log_div_log ha‚ÇÄ ha‚ÇÅ hb‚ÇÄ hb‚ÇÅ, div_eq_inv_mul, rpow_mul (v.nonneg _),
      rpow_inv_log (v.pos hb‚ÇÄ) (h.eq_one_iff.not.2 hb‚ÇÅ), exp_one_rpow, exp_log (w.pos hb‚ÇÄ)]
  ¬∑ exact ‚ü®1, zero_lt_one, funext fun x ‚Ü¶ by rcases eq_or_ne x 0 with rfl | h‚ÇÄ <;>
      aesop (add simp [h.isNontrivial_iff])‚ü©

end Real

/--
The limit $v\left(\frac{1}{1 + a ^ n}\right)\to 1$, for an absolute value $v$ on a field
$F$ if $v(a) < 1$.
-/
theorem tendsto_div_one_add_pow_nhds_one {v : AbsoluteValue F ‚Ñù} {a : F} (ha : v a < 1) :
    Filter.Tendsto (fun (n : ‚Ñï) => v (1 / (1 + a ^ n))) Filter.atTop (ùìù 1) := by
  simp_rw [v.isAbsoluteValue.abv_div, v.map_one]
  nth_rw 2 [show (1 : ‚Ñù) = 1 / 1 by norm_num]
  apply Tendsto.div tendsto_const_nhds _ one_ne_zero
  have h_add := Tendsto.const_add 1 <| tendsto_pow_atTop_nhds_zero_of_lt_one (v.nonneg _) ha
  have h_sub := Tendsto.const_sub 1 <| tendsto_pow_atTop_nhds_zero_of_lt_one (v.nonneg _) ha
  simp only [add_zero, sub_zero] at h_add h_sub
  exact tendsto_of_tendsto_of_tendsto_of_le_of_le h_sub h_add
    (fun n ‚Ü¶ le_trans (by rw [map_one, map_pow]) (v.le_add _ _))
    (fun n ‚Ü¶ le_trans (v.add_le _ _) (by rw [map_one, map_pow]))

/--
The limit $v \left(\frac{1}{1 + a ^ n}\right)\to 0$, for an absolute value $v$ on a field
$F$ if $1 < v(a)$.
-/
theorem tendsto_pow_div_one_add_pow_zero {v : AbsoluteValue F ‚Ñù} {a : F} (ha : 1 < v a) :
    Filter.Tendsto (fun (n : ‚Ñï) => v (1 / (1 + a ^ n))) Filter.atTop (ùìù 0) := by
  simp_rw [div_eq_mul_inv, one_mul, map_inv‚ÇÄ, fun n => add_comm 1 (a ^ n)]
  apply Filter.Tendsto.inv_tendsto_atTop
  apply Filter.tendsto_atTop_mono (fun n => v.le_add _ _)
  simp_rw [map_one, map_pow v]
  apply Filter.tendsto_atTop_add_right_of_le _ _ _ (fun _ => le_rfl)
  refine tendsto_atTop_of_geom_le (by simp only [pow_zero, zero_lt_one]) ha fun n => ?_
  rw [‚Üê map_pow, ‚Üê map_pow, ‚Üê map_mul, pow_succ']

open Filter in
/--
- $F$: field;
- $a, b\in F$;
- $v_1, ..., v_k, w$: absolute values on $F$;
- $1 < v_i(a)$ and $1 < v_i(b)$;
- $v_j(a) < 1$ for $j \neq i$;
- $w(a) = 1$ and $w(b) < 1$.

There is a sequence of values that tends to $\infty$
under $v_i$, tends to $0$ under $v_j$, and is always $< 1$ under $w$.
An example sequence is given by $a ^ n \cdot b$.
-/
theorem exists_tendsto_zero_tendsto_atTop_tendsto_const
    {Œπ : Type*} {v : Œπ ‚Üí AbsoluteValue F ‚Ñù} {w : AbsoluteValue F ‚Ñù} {a b : F} {i : Œπ}
    (ha : 1 < v i a) (haj : ‚àÄ j ‚â† i, v j a < 1) (haw : w a = 1) (hb : 1 < v i b) (hbw : w b < 1) :
    ‚àÉ c : ‚Ñï ‚Üí F,
      Tendsto (fun n => (v i) (c n)) atTop atTop ‚àß
        (‚àÄ j ‚â† i, Tendsto (fun n => (v j) (c n)) atTop (ùìù 0)) ‚àß
          (‚àÄ n, w (c n) < 1) := by
  refine ‚ü®fun n => a ^ n * b, ?_‚ü©; simp_rw [map_mul, map_pow, haw, one_pow, one_mul]
  refine ‚ü®Tendsto.atTop_mul_const (by linarith) (tendsto_pow_atTop_atTop_of_one_lt ha),
    fun j hj => ?_, fun _ => hbw‚ü©
  rw [‚Üê zero_mul <| v j b]
  exact Tendsto.mul_const _ <| tendsto_pow_atTop_nhds_zero_of_lt_one ((v j).nonneg _) (haj j hj)

open scoped Classical in
/--
- $F$: field;
- $a, b\in F$;
- $v_1, ..., v_k, w$: absolute values on $F$;
- $1 < v_i(a)$ and $1 < v_i(b)$;
- $v_j(a) < 1$ for $j \neq i$;
- $w(a) = 1$ and $w(b) < 1$.

There is a $k\in F$ such that $1 < v_i(k)$ while $v_j(k) < 1$ for all
$j \neq i$ and $w(k) < 1$.
This is given by taking large enough values of a witness sequence to
`exists_tendsto_zero_tendsto_atTop_tendsto_const` (for example $a ^ n \cdot b$ works).
-/
theorem exists_one_lt_lt_one_lt_one_of_eq_one
    {Œπ : Type*} [Fintype Œπ] {v : Œπ ‚Üí AbsoluteValue F ‚Ñù} {w : AbsoluteValue F ‚Ñù} {a b : F} {i : Œπ}
    (ha : 1 < v i a) (haj : ‚àÄ j ‚â† i, v j a < 1) (haw : w a = 1) (hb : 1 < v i b) (hbw : w b < 1) :
    ‚àÉ k : F, 1 < v i k ‚àß (‚àÄ j ‚â† i, v j k < 1) ‚àß w k < 1 := by
  let ‚ü®c, hc‚ü© := exists_tendsto_zero_tendsto_atTop_tendsto_const ha haj haw hb hbw
  simp_rw [Metric.tendsto_nhds, Filter.tendsto_atTop_atTop, Filter.eventually_atTop,
    dist_zero_right, ‚Üê WithAbs.norm_eq_abv, norm_norm] at hc
  choose r‚ÇÅ hr‚ÇÅ using hc.1 2
  choose r‚Çô hr‚Çô using fun j hj => hc.2.1 j hj 1 (by linarith)
  let r := Finset.univ.sup fun j => if h : j = i then r‚ÇÅ else r‚Çô j h
  refine ‚ü®c r, lt_of_lt_of_le (by linarith) (hr‚ÇÅ r ?_), fun j hj => ?_, hc.2.2 r‚ü©
  ¬∑ exact Finset.le_sup_dite_pos (p := fun j => j = i) (f := fun _ _ => r‚ÇÅ) (Finset.mem_univ _) rfl
  ¬∑ convert hr‚Çô j hj _ <| Finset.le_sup_dite_neg (fun j => j = i) (Finset.mem_univ j) _

open Filter in
/--
- $F$: field;
- $a, b\in F$;
- $v_1, ..., v_k, w$: absolute values on $F$;
- $1 < v_i(a)$;
- $v_j(a) < 1$ for $j \neq i$;
- $1 < w(a)$.

There is a sequence of elements in $F$ that tendsto $v_i b$ under $v_i$, tends to $0$ under
$v_j$ for $j ‚â† i$, and tends to $w b$ under $w$.
Such a sequence is given by $\frac{1}{1 + a ^ {- n}}$.
-/
theorem exists_tendsto_const_tendsto_zero_tendsto_const
    {Œπ : Type*} {v : Œπ ‚Üí AbsoluteValue F ‚Ñù} {w : AbsoluteValue F ‚Ñù} {a : F} {i : Œπ}
    (b : F) (ha : 1 < v i a) (haj : ‚àÄ j ‚â† i, v j a < 1) (haw : 1 < w a) :
    ‚àÉ c : ‚Ñï ‚Üí F,
      Tendsto (fun n => (v i) (c n)) atTop (ùìù ((v i) b)) ‚àß
        (‚àÄ j ‚â† i, Tendsto (fun n => v j (c n)) atTop (ùìù 0)) ‚àß
          Tendsto (fun n => w (c n)) atTop (ùìù (w b)) := by
  refine ‚ü®fun n => (1 / (1 + a‚Åª¬π ^ n) * b), ?_‚ü©; simp_rw [map_mul]
  nth_rw 2 [‚Üê one_mul (v i b), ‚Üê one_mul (w b)]
  let hai := map_inv‚ÇÄ (v i) _ ‚ñ∏ inv_lt_one_of_one_lt‚ÇÄ ha
  replace haw := (map_inv‚ÇÄ w _ ‚ñ∏ inv_lt_one_of_one_lt‚ÇÄ haw)
  refine ‚ü®Tendsto.mul_const _ (tendsto_div_one_add_pow_nhds_one hai), fun j hj => ?_,
      Tendsto.mul_const _ (tendsto_div_one_add_pow_nhds_one haw)‚ü©
  replace haj := map_inv‚ÇÄ (v j) _ ‚ñ∏
    (one_lt_inv‚ÇÄ (pos_of_abv_pos (v j) (by linarith))).2 (haj j hj)
  exact zero_mul (v j b) ‚ñ∏ Tendsto.mul_const _ (tendsto_pow_div_one_add_pow_zero haj)

open scoped Classical in
/--
- $F$: field;
- $a, b\in F$;
- $v_1, ..., v_k, w$: absolute values on $F$;
- $1 < v_i(a)$;
- $v_j(a) < 1$ for $j \neq i$;
- $1 < w(a)$.

There is a $k ‚àà F$ such that $1 < v_i(k)$ while $v_j(k) < 1$ for all
$j ‚â† i$ and $w(k) < 1$. This is given by taking large enough values of a witness sequence to
`exists_tendsto_const_tendsto_zero_tendsto_const` (for example $\frac{1}{1 + a ^ {- n}}$ works).

Note that this is the result `exists_one_lt_lt_one_lt_one_of_eq_one` replacing the condition
that $w(a) = 1$ with $1 < w(a)$ and removing the condition on $w(b)$.
-/
theorem exists_one_lt_lt_one_lt_one_of_one_lt
    {Œπ : Type*} [Fintype Œπ] {v : Œπ ‚Üí AbsoluteValue F ‚Ñù} {w : AbsoluteValue F ‚Ñù} {a b : F} {i : Œπ}
    (ha : 1 < v i a) (haj : ‚àÄ j ‚â† i, v j a < 1) (haw : 1 < w a) (hb : 1 < v i b) (hbw : w b < 1) :
    ‚àÉ k : F, 1 < v i k ‚àß (‚àÄ j ‚â† i, v j k < 1) ‚àß w k < 1 := by
  let ‚ü®c, hc‚ü© := exists_tendsto_const_tendsto_zero_tendsto_const b ha haj haw
  have h‚Çô := fun j hj => Metric.tendsto_nhds.1 <| hc.2.1 j hj
  simp_rw [Filter.eventually_atTop, dist_zero_right] at h‚Çô
  choose r‚ÇÅ hr‚ÇÅ using Filter.eventually_atTop.1 <| Filter.Tendsto.eventually_const_lt hb hc.1
  choose r‚Çô hr‚Çô using fun j hj => h‚Çô j hj 1 (by linarith)
  choose rN hrN using Filter.eventually_atTop.1 <| Filter.Tendsto.eventually_lt_const hbw hc.2.2
  let r := max (Finset.univ.sup fun j => if h : j = i then r‚ÇÅ else r‚Çô j h) rN
  refine ‚ü®c r, hr‚ÇÅ r ?_, fun j hj => ?_, ?_‚ü©
  ¬∑ exact le_max_iff.2 <| Or.inl <|
      Finset.le_sup_dite_pos (p := fun j => j = i) (f := fun _ _ => r‚ÇÅ) (Finset.mem_univ _) rfl
  ¬∑ simp only [‚Üê WithAbs.norm_eq_abv, norm_norm] at hr‚Çô
    exact hr‚Çô j hj _ <| le_max_iff.2 <| Or.inl <|
      Finset.le_sup_dite_neg (fun j => j = i) (Finset.mem_univ j) _
  ¬∑ exact hrN _ <| le_max_iff.2 (Or.inr le_rfl)

/--
Let $v_1, ..., v_k$ be a collection of at least two non-trivial and pairwise inequivalent
absolute values on a field $F$. There is an $a ‚àà F$ such that $1 < v_1(a)$ while
$v_j(a) < 1$ for all other $j ‚â† 1$.
-/
theorem exists_one_lt_lt_one {n : ‚Ñï} {v : Fin (n + 2) ‚Üí AbsoluteValue F ‚Ñù}
    (h : ‚àÄ i, (v i).IsNontrivial)
    (hv : Pairwise fun i j => ¬¨(v i).IsEquiv (v j)) :
    ‚àÉ (a : F), 1 < v 0 a ‚àß ‚àÄ j ‚â† 0, v j a < 1 := by
  induction n using Nat.case_strong_induction_on with
  | hz =>
    let ‚ü®a, ha‚ü© := (v 0).exists_abv_one_lt_abv_lt_one_of_not_isEquiv (h 0) (h 1)
      (hv zero_ne_one.symm)
    exact ‚ü®a, ha.1, by simp [Fin.forall_fin_two]; exact ha.2‚ü©
  | hi n ih =>
    -- Assume the result is true for all smaller collections of absolute values
    -- Let `a : K` be the value from the collection with the last absolute value removed
    let ‚ü®a, ha‚ü© := ih n le_rfl (fun _ => h _) (hv.comp_of_injective <| Fin.castSucc_injective _)
    -- Let `b : K` be the value using the first and last absolute value
    have : ![0, Fin.last (n + 2)].Injective := by simp [Function.Injective, Fin.forall_fin_two]
    let ‚ü®b, hb‚ü© := ih 0 (by linarith) (fun _ => h _) <| hv.comp_of_injective this
    simp [Fin.forall_fin_two] at hb
    -- If `v last < 1` then `a` works.
    by_cases ha‚ÇÄ : v (Fin.last _) a < 1
    ¬∑ refine ‚ü®a, ha.1, fun j hj => ?_‚ü©
      by_cases hj' : j = Fin.last (n + 2)
      ¬∑ exact hj' ‚ñ∏ ha‚ÇÄ
      ¬∑ exact ha.2 (Fin.castPred _ (ne_eq _ _ ‚ñ∏  hj')) <| Fin.castPred_ne_zero _ hj
    -- If `v last = 1` then this is given by `exists_one_lt_lt_one_lt_one_of_eq_one` with
    -- `w = v last`.
    ¬∑ by_cases ha‚ÇÅ : v (Fin.last _) a = 1
      ¬∑ let ‚ü®k, hk‚ü© := exists_one_lt_lt_one_lt_one_of_eq_one
          (v := fun i : Fin (n + 2) => v i.castSucc) ha.1 ha.2 ha‚ÇÅ hb.1 hb.2
        refine ‚ü®k, hk.1, fun j hj => ?_‚ü©
        by_cases h : j ‚â† Fin.last (n + 2)
        ¬∑ exact ne_eq _ _ ‚ñ∏ hk.2.1 (j.castPred h) <| Fin.castPred_ne_zero _ hj
        ¬∑ exact not_ne_iff.1 h ‚ñ∏ hk.2.2
      -- The last cast `1 < v last` is given by `exists_one_lt_lt_one_lt_one_of_one_lt` with
      -- `w = v last`.
      ¬∑ let ‚ü®k, hk‚ü© := exists_one_lt_lt_one_lt_one_of_one_lt
          (v := fun i : Fin (n + 2) => v i.castSucc) ha.1 ha.2
            (lt_of_le_of_ne (not_lt.1 ha‚ÇÄ) (ne_eq _ _ ‚ñ∏ ha‚ÇÅ).symm) hb.1 hb.2
        refine ‚ü®k, hk.1, fun j hj => ?_‚ü©
        by_cases h : j ‚â† Fin.last _
        ¬∑ apply ne_eq _ _ ‚ñ∏ hk.2.1 (j.castPred h)
          rwa [‚Üê Fin.castPred_zero, Fin.castPred_inj]
        ¬∑ exact not_ne_iff.1 h ‚ñ∏ hk.2.2

end AbsoluteValue
