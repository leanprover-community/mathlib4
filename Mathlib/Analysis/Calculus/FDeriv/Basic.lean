/-
Copyright (c) 2019 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Avigad, S√©bastien Gou√´zel, Yury Kudryashov
-/
import Mathlib.Analysis.Asymptotics.Lemmas
import Mathlib.Analysis.Calculus.FDeriv.Defs
import Mathlib.Analysis.Calculus.TangentCone
import Mathlib.Analysis.NormedSpace.OperatorNorm.Asymptotics

/-!
# The Fr√©chet derivative: basic properties

Let `E` and `F` be normed spaces, `f : E ‚Üí F`, and `f' : E ‚ÜíL[ùïú] F` a
continuous ùïú-linear map, where `ùïú` is a non-discrete normed field. Then

  `HasFDerivWithinAt f f' s x`

says that `f` has derivative `f'` at `x`, where the domain of interest
is restricted to `s`. We also have

  `HasFDerivAt f f' x := HasFDerivWithinAt f f' x univ`

Finally,

  `HasStrictFDerivAt f f' x`

means that `f : E ‚Üí F` has derivative `f' : E ‚ÜíL[ùïú] F` in the sense of strict differentiability,
i.e., `f y - f z - f'(y - z) = o(y - z)` as `y, z ‚Üí x`. This notion is used in the inverse
function theorem, and is defined here only to avoid proving theorems like
`IsBoundedBilinearMap.hasFDerivAt` twice: first for `HasFDerivAt`, then for
`HasStrictFDerivAt`.

## Main results

This file builds on the bare-bones definition given in `Defs.lean` by establishing a variety of
relatively straightforward properties of the derivative.

Deeper properties are defined in other files in the folder `Analysis/Calculus/FDeriv/`, which
contain the usual formulas (and existence assertions) for the derivative of
* constants (`Const.lean`)
* bounded linear maps (`Linear.lean`)
* bounded bilinear maps (`Bilinear.lean`)
* sum of two functions (`Add.lean`)
* sum of finitely many functions (`Add.lean`)
* multiplication of a function by a scalar constant (`Add.lean`)
* negative of a function (`Add.lean`)
* subtraction of two functions (`Add.lean`)
* multiplication of a function by a scalar function (`Mul.lean`)
* multiplication of two scalar functions (`Mul.lean`)
* composition of functions (the chain rule) (`Comp.lean`)
* inverse function (`Mul.lean`)
  (assuming that it exists; the inverse function theorem is in `../Inverse.lean`)

For most binary operations we also define `const_op` and `op_const` theorems for the cases when
the first or second argument is a constant. This makes writing chains of `HasDerivAt`'s easier,
and they more frequently lead to the desired result.

One can also interpret the derivative of a function `f : ùïú ‚Üí E` as an element of `E` (by identifying
a linear function from `ùïú` to `E` with its value at `1`). Results on the Fr√©chet derivative are
translated to this more elementary point of view on the derivative in the file `Deriv.lean`. The
derivative of polynomials is handled there, as it is naturally one-dimensional.

The simplifier is set up to prove automatically that some functions are differentiable, or
differentiable at a point (but not differentiable on a set or within a set at a point, as checking
automatically that the good domains are mapped one to the other when using composition is not
something the simplifier can easily do). This means that one can write
`example (x : ‚Ñù) : Differentiable ‚Ñù (fun x ‚Ü¶ sin (exp (3 + x^2)) - 5 * cos x) := by simp`.
If there are divisions, one needs to supply to the simplifier proofs that the denominators do
not vanish, as in
```lean
example (x : ‚Ñù) (h : 1 + sin x ‚â† 0) : DifferentiableAt ‚Ñù (fun x ‚Ü¶ exp x / (1 + sin x)) x := by
  simp [h]
```
Of course, these examples only work once `exp`, `cos` and `sin` have been shown to be
differentiable, in `Mathlib/Analysis/SpecialFunctions/Trigonometric/Deriv.lean`.

The simplifier is not set up to compute the Fr√©chet derivative of maps (as these are in general
complicated multidimensional linear maps), but it will compute one-dimensional derivatives,
see `Deriv.lean`.

## Implementation details

For a discussion of the definitions and their rationale, see the file docstring of
`Mathlib.Analysis.Calculus.FDeriv.Defs`.

To make sure that the simplifier can prove automatically that functions are differentiable, we tag
many lemmas with the `simp` attribute, for instance those saying that the sum of differentiable
functions is differentiable, as well as their product, their cartesian product, and so on. A notable
exception is the chain rule: we do not mark as a simp lemma the fact that, if `f` and `g` are
differentiable, then their composition also is: `simp` would always be able to match this lemma,
by taking `f` or `g` to be the identity. Instead, for every reasonable function (say, `exp`),
we add a lemma that if `f` is differentiable then so is `(fun x ‚Ü¶ exp (f x))`. This means adding
some boilerplate lemmas, but these can also be useful in their own right.

Tests for this ability of the simplifier (with more examples) are provided in
`Tests/Differentiable.lean`.

## TODO

Generalize more results to topological vector spaces.

## Tags

derivative, differentiable, Fr√©chet, calculus

-/

open Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal

noncomputable section

section
variable {ùïú : Type*} [NontriviallyNormedField ùïú]
variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ùïú E]
variable {F : Type*} [NormedAddCommGroup F] [NormedSpace ùïú F]

variable {f f‚ÇÄ f‚ÇÅ g : E ‚Üí F}
variable {f' f‚ÇÄ' f‚ÇÅ' g' : E ‚ÜíL[ùïú] F}
variable {x : E}
variable {s t : Set E}
variable {L L‚ÇÅ L‚ÇÇ : Filter E}

section DerivativeUniqueness

/- In this section, we discuss the uniqueness of the derivative.
We prove that the definitions `UniqueDiffWithinAt` and `UniqueDiffOn` indeed imply the
uniqueness of the derivative. -/
/-- If a function f has a derivative f' at x, a rescaled version of f around x converges to f',
i.e., `n (f (x + (1/n) v) - f x)` converges to `f' v`. More generally, if `c n` tends to infinity
and `c n * d n` tends to `v`, then `c n * (f (x + d n) - f x)` tends to `f' v`. This lemma expresses
this fact, for functions having a derivative within a set. Its specific formulation is useful for
tangent cone related discussions. -/
theorem HasFDerivWithinAt.lim (h : HasFDerivWithinAt f f' s x) {Œ± : Type*} (l : Filter Œ±)
    {c : Œ± ‚Üí ùïú} {d : Œ± ‚Üí E} {v : E} (dtop : ‚àÄ·∂† n in l, x + d n ‚àà s)
    (clim : Tendsto (fun n => ‚Äñc n‚Äñ) l atTop) (cdlim : Tendsto (fun n => c n ‚Ä¢ d n) l (ùìù v)) :
    Tendsto (fun n => c n ‚Ä¢ (f (x + d n) - f x)) l (ùìù (f' v)) := by
  have tendsto_arg : Tendsto (fun n => x + d n) l (ùìù[s] x) := by
    conv in ùìù[s] x => rw [‚Üê add_zero x]
    rw [nhdsWithin, tendsto_inf]
    constructor
    ¬∑ apply tendsto_const_nhds.add (tangentConeAt.lim_zero l clim cdlim)
    ¬∑ rwa [tendsto_principal]
  have : (fun y => f y - f x - f' (y - x)) =o[ùìù[s] x] fun y => y - x := h.isLittleO
  have : (fun n => f (x + d n) - f x - f' (x + d n - x)) =o[l] fun n => x + d n - x :=
    this.comp_tendsto tendsto_arg
  have : (fun n => f (x + d n) - f x - f' (d n)) =o[l] d := by simpa only [add_sub_cancel_left]
  have : (fun n => c n ‚Ä¢ (f (x + d n) - f x - f' (d n))) =o[l] fun n => c n ‚Ä¢ d n :=
    (isBigO_refl c l).smul_isLittleO this
  have : (fun n => c n ‚Ä¢ (f (x + d n) - f x - f' (d n))) =o[l] fun _ => (1 : ‚Ñù) :=
    this.trans_isBigO (cdlim.isBigO_one ‚Ñù)
  have L1 : Tendsto (fun n => c n ‚Ä¢ (f (x + d n) - f x - f' (d n))) l (ùìù 0) :=
    (isLittleO_one_iff ‚Ñù).1 this
  have L2 : Tendsto (fun n => f' (c n ‚Ä¢ d n)) l (ùìù (f' v)) :=
    Tendsto.comp f'.cont.continuousAt cdlim
  have L3 :
    Tendsto (fun n => c n ‚Ä¢ (f (x + d n) - f x - f' (d n)) + f' (c n ‚Ä¢ d n)) l (ùìù (0 + f' v)) :=
    L1.add L2
  have :
    (fun n => c n ‚Ä¢ (f (x + d n) - f x - f' (d n)) + f' (c n ‚Ä¢ d n)) = fun n =>
      c n ‚Ä¢ (f (x + d n) - f x) := by
    ext n
    simp [smul_add, smul_sub]
  rwa [this, zero_add] at L3

/-- If `f'` and `f‚ÇÅ'` are two derivatives of `f` within `s` at `x`, then they are equal on the
tangent cone to `s` at `x` -/
theorem HasFDerivWithinAt.unique_on (hf : HasFDerivWithinAt f f' s x)
    (hg : HasFDerivWithinAt f f‚ÇÅ' s x) : EqOn f' f‚ÇÅ' (tangentConeAt ùïú s x) :=
  fun _ ‚ü®_, _, dtop, clim, cdlim‚ü© =>
  tendsto_nhds_unique (hf.lim atTop dtop clim cdlim) (hg.lim atTop dtop clim cdlim)

/-- `UniqueDiffWithinAt` achieves its goal: it implies the uniqueness of the derivative. -/
theorem UniqueDiffWithinAt.eq (H : UniqueDiffWithinAt ùïú s x) (hf : HasFDerivWithinAt f f' s x)
    (hg : HasFDerivWithinAt f f‚ÇÅ' s x) : f' = f‚ÇÅ' :=
  ContinuousLinearMap.ext_on H.1 (hf.unique_on hg)

theorem UniqueDiffOn.eq (H : UniqueDiffOn ùïú s) (hx : x ‚àà s) (h : HasFDerivWithinAt f f' s x)
    (h‚ÇÅ : HasFDerivWithinAt f f‚ÇÅ' s x) : f' = f‚ÇÅ' :=
  (H x hx).eq h h‚ÇÅ

end DerivativeUniqueness

section FDerivProperties

/-! ### Basic properties of the derivative -/


theorem hasFDerivAtFilter_iff_tendsto :
    HasFDerivAtFilter f f' x L ‚Üî
      Tendsto (fun x' => ‚Äñx' - x‚Äñ‚Åª¬π * ‚Äñf x' - f x - f' (x' - x)‚Äñ) L (ùìù 0) := by
  have h : ‚àÄ x', ‚Äñx' - x‚Äñ = 0 ‚Üí ‚Äñf x' - f x - f' (x' - x)‚Äñ = 0 := fun x' hx' => by
    rw [sub_eq_zero.1 (norm_eq_zero.1 hx')]
    simp
  rw [hasFDerivAtFilter_iff_isLittleO, ‚Üê isLittleO_norm_left, ‚Üê isLittleO_norm_right,
    isLittleO_iff_tendsto h]
  exact tendsto_congr fun _ => div_eq_inv_mul _ _

theorem hasFDerivWithinAt_iff_tendsto :
    HasFDerivWithinAt f f' s x ‚Üî
      Tendsto (fun x' => ‚Äñx' - x‚Äñ‚Åª¬π * ‚Äñf x' - f x - f' (x' - x)‚Äñ) (ùìù[s] x) (ùìù 0) :=
  hasFDerivAtFilter_iff_tendsto

theorem hasFDerivAt_iff_tendsto :
    HasFDerivAt f f' x ‚Üî Tendsto (fun x' => ‚Äñx' - x‚Äñ‚Åª¬π * ‚Äñf x' - f x - f' (x' - x)‚Äñ) (ùìù x) (ùìù 0) :=
  hasFDerivAtFilter_iff_tendsto

theorem hasFDerivAt_iff_isLittleO_nhds_zero :
    HasFDerivAt f f' x ‚Üî (fun h : E => f (x + h) - f x - f' h) =o[ùìù 0] fun h => h := by
  rw [HasFDerivAt, hasFDerivAtFilter_iff_isLittleO, ‚Üê map_add_left_nhds_zero x, isLittleO_map]
  simp [Function.comp_def]

nonrec theorem HasFDerivAtFilter.mono (h : HasFDerivAtFilter f f' x L‚ÇÇ) (hst : L‚ÇÅ ‚â§ L‚ÇÇ) :
    HasFDerivAtFilter f f' x L‚ÇÅ :=
  .of_isLittleOTVS <| h.isLittleOTVS.mono hst

theorem HasFDerivWithinAt.mono_of_mem_nhdsWithin
    (h : HasFDerivWithinAt f f' t x) (hst : t ‚àà ùìù[s] x) :
    HasFDerivWithinAt f f' s x :=
  h.mono <| nhdsWithin_le_iff.mpr hst

@[deprecated (since := "2024-10-31")]
alias HasFDerivWithinAt.mono_of_mem := HasFDerivWithinAt.mono_of_mem_nhdsWithin

nonrec theorem HasFDerivWithinAt.mono (h : HasFDerivWithinAt f f' t x) (hst : s ‚äÜ t) :
    HasFDerivWithinAt f f' s x :=
  h.mono <| nhdsWithin_mono _ hst

theorem HasFDerivAt.hasFDerivAtFilter (h : HasFDerivAt f f' x) (hL : L ‚â§ ùìù x) :
    HasFDerivAtFilter f f' x L :=
  h.mono hL

@[fun_prop]
theorem HasFDerivAt.hasFDerivWithinAt (h : HasFDerivAt f f' x) : HasFDerivWithinAt f f' s x :=
  h.hasFDerivAtFilter inf_le_left

@[fun_prop]
theorem HasFDerivWithinAt.differentiableWithinAt (h : HasFDerivWithinAt f f' s x) :
    DifferentiableWithinAt ùïú f s x :=
  ‚ü®f', h‚ü©

@[fun_prop]
theorem HasFDerivAt.differentiableAt (h : HasFDerivAt f f' x) : DifferentiableAt ùïú f x :=
  ‚ü®f', h‚ü©

@[simp]
theorem hasFDerivWithinAt_univ : HasFDerivWithinAt f f' univ x ‚Üî HasFDerivAt f f' x := by
  simp only [HasFDerivWithinAt, nhdsWithin_univ, HasFDerivAt]

alias ‚ü®HasFDerivWithinAt.hasFDerivAt_of_univ, _‚ü© := hasFDerivWithinAt_univ

theorem differentiableWithinAt_univ :
    DifferentiableWithinAt ùïú f univ x ‚Üî DifferentiableAt ùïú f x := by
  simp only [DifferentiableWithinAt, hasFDerivWithinAt_univ, DifferentiableAt]

theorem fderiv_zero_of_not_differentiableAt (h : ¬¨DifferentiableAt ùïú f x) : fderiv ùïú f x = 0 := by
  rw [fderiv, fderivWithin_zero_of_not_differentiableWithinAt]
  rwa [differentiableWithinAt_univ]

theorem hasFDerivWithinAt_of_mem_nhds (h : s ‚àà ùìù x) :
    HasFDerivWithinAt f f' s x ‚Üî HasFDerivAt f f' x := by
  rw [HasFDerivAt, HasFDerivWithinAt, nhdsWithin_eq_nhds.mpr h]

lemma hasFDerivWithinAt_of_isOpen (h : IsOpen s) (hx : x ‚àà s) :
    HasFDerivWithinAt f f' s x ‚Üî HasFDerivAt f f' x :=
  hasFDerivWithinAt_of_mem_nhds (h.mem_nhds hx)

@[simp]
theorem hasFDerivWithinAt_insert {y : E} :
    HasFDerivWithinAt f f' (insert y s) x ‚Üî HasFDerivWithinAt f f' s x := by
  rcases eq_or_ne x y with (rfl | h)
  ¬∑ simp_rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleOTVS]
    apply isLittleOTVS_insert
    simp only [sub_self, map_zero]
  refine ‚ü®fun h => h.mono <| subset_insert y s, fun hf => hf.mono_of_mem_nhdsWithin ?_‚ü©
  simp_rw [nhdsWithin_insert_of_ne h, self_mem_nhdsWithin]

alias ‚ü®HasFDerivWithinAt.of_insert, HasFDerivWithinAt.insert'‚ü© := hasFDerivWithinAt_insert

protected theorem HasFDerivWithinAt.insert (h : HasFDerivWithinAt g g' s x) :
    HasFDerivWithinAt g g' (insert x s) x :=
  h.insert'

@[simp]
theorem hasFDerivWithinAt_diff_singleton (y : E) :
    HasFDerivWithinAt f f' (s \ {y}) x ‚Üî HasFDerivWithinAt f f' s x := by
  rw [‚Üê hasFDerivWithinAt_insert, insert_diff_singleton, hasFDerivWithinAt_insert]

@[simp]
protected theorem HasFDerivWithinAt.empty : HasFDerivWithinAt f f' ‚àÖ x := by
  simp [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleOTVS]

@[simp]
protected theorem DifferentiableWithinAt.empty : DifferentiableWithinAt ùïú f ‚àÖ x :=
  ‚ü®0, .empty‚ü©

theorem HasFDerivWithinAt.of_finite (h : s.Finite) : HasFDerivWithinAt f f' s x := by
  induction s, h using Set.Finite.induction_on with
  | empty => exact .empty
  | insert _ _ ih => exact ih.insert'

theorem DifferentiableWithinAt.of_finite (h : s.Finite) : DifferentiableWithinAt ùïú f s x :=
  ‚ü®0, .of_finite h‚ü©

@[simp]
protected theorem HasFDerivWithinAt.singleton {y} : HasFDerivWithinAt f f' {x} y :=
  .of_finite <| finite_singleton _

@[simp]
protected theorem DifferentiableWithinAt.singleton {y} : DifferentiableWithinAt ùïú f {x} y :=
  ‚ü®0, .singleton‚ü©

theorem HasFDerivWithinAt.of_subsingleton (h : s.Subsingleton) : HasFDerivWithinAt f f' s x :=
  .of_finite h.finite

theorem DifferentiableWithinAt.of_subsingleton (h : s.Subsingleton) :
    DifferentiableWithinAt ùïú f s x :=
  .of_finite h.finite

theorem HasStrictFDerivAt.isBigO_sub (hf : HasStrictFDerivAt f f' x) :
    (fun p : E √ó E => f p.1 - f p.2) =O[ùìù (x, x)] fun p : E √ó E => p.1 - p.2 :=
  hf.isLittleO.isBigO.congr_of_sub.2 (f'.isBigO_comp _ _)

theorem HasFDerivAtFilter.isBigO_sub (h : HasFDerivAtFilter f f' x L) :
    (fun x' => f x' - f x) =O[L] fun x' => x' - x :=
  h.isLittleO.isBigO.congr_of_sub.2 (f'.isBigO_sub _ _)

@[fun_prop]
protected theorem HasStrictFDerivAt.hasFDerivAt (hf : HasStrictFDerivAt f f' x) :
    HasFDerivAt f f' x :=
  .of_isLittleOTVS <| by
    simpa only using hf.isLittleOTVS.comp_tendsto (tendsto_id.prodMk_nhds tendsto_const_nhds)

protected theorem HasStrictFDerivAt.differentiableAt (hf : HasStrictFDerivAt f f' x) :
    DifferentiableAt ùïú f x :=
  hf.hasFDerivAt.differentiableAt

/-- If `f` is strictly differentiable at `x` with derivative `f'` and `K > ‚Äñf'‚Äñ‚Çä`, then `f` is
`K`-Lipschitz in a neighborhood of `x`. -/
theorem HasStrictFDerivAt.exists_lipschitzOnWith_of_nnnorm_lt (hf : HasStrictFDerivAt f f' x)
    (K : ‚Ñù‚â•0) (hK : ‚Äñf'‚Äñ‚Çä < K) : ‚àÉ s ‚àà ùìù x, LipschitzOnWith K f s := by
  have := hf.isLittleO.add_isBigOWith (f'.isBigOWith_comp _ _) hK
  simp only [sub_add_cancel, IsBigOWith] at this
  rcases exists_nhds_square this with ‚ü®U, Uo, xU, hU‚ü©
  exact
    ‚ü®U, Uo.mem_nhds xU, lipschitzOnWith_iff_norm_sub_le.2 fun x hx y hy => hU (mk_mem_prod hx hy)‚ü©

/-- If `f` is strictly differentiable at `x` with derivative `f'`, then `f` is Lipschitz in a
neighborhood of `x`. See also `HasStrictFDerivAt.exists_lipschitzOnWith_of_nnnorm_lt` for a
more precise statement. -/
theorem HasStrictFDerivAt.exists_lipschitzOnWith (hf : HasStrictFDerivAt f f' x) :
    ‚àÉ K, ‚àÉ s ‚àà ùìù x, LipschitzOnWith K f s :=
  (exists_gt _).imp hf.exists_lipschitzOnWith_of_nnnorm_lt

/-- Directional derivative agrees with `HasFDeriv`. -/
theorem HasFDerivAt.lim (hf : HasFDerivAt f f' x) (v : E) {Œ± : Type*} {c : Œ± ‚Üí ùïú} {l : Filter Œ±}
    (hc : Tendsto (fun n => ‚Äñc n‚Äñ) l atTop) :
    Tendsto (fun n => c n ‚Ä¢ (f (x + (c n)‚Åª¬π ‚Ä¢ v) - f x)) l (ùìù (f' v)) := by
  refine (hasFDerivWithinAt_univ.2 hf).lim _ univ_mem hc ?_
  intro U hU
  refine (eventually_ne_of_tendsto_norm_atTop hc (0 : ùïú)).mono fun y hy => ?_
  convert mem_of_mem_nhds hU
  dsimp only
  rw [‚Üê mul_smul, mul_inv_cancel‚ÇÄ hy, one_smul]

theorem HasFDerivAt.unique (h‚ÇÄ : HasFDerivAt f f‚ÇÄ' x) (h‚ÇÅ : HasFDerivAt f f‚ÇÅ' x) : f‚ÇÄ' = f‚ÇÅ' := by
  rw [‚Üê hasFDerivWithinAt_univ] at h‚ÇÄ h‚ÇÅ
  exact uniqueDiffWithinAt_univ.eq h‚ÇÄ h‚ÇÅ

theorem hasFDerivWithinAt_inter' (h : t ‚àà ùìù[s] x) :
    HasFDerivWithinAt f f' (s ‚à© t) x ‚Üî HasFDerivWithinAt f f' s x := by
  simp [HasFDerivWithinAt, nhdsWithin_restrict'' s h]

theorem hasFDerivWithinAt_inter (h : t ‚àà ùìù x) :
    HasFDerivWithinAt f f' (s ‚à© t) x ‚Üî HasFDerivWithinAt f f' s x := by
  simp [HasFDerivWithinAt, nhdsWithin_restrict' s h]

theorem HasFDerivWithinAt.union (hs : HasFDerivWithinAt f f' s x)
    (ht : HasFDerivWithinAt f f' t x) : HasFDerivWithinAt f f' (s ‚à™ t) x := by
  simp only [HasFDerivWithinAt, nhdsWithin_union]
  exact .of_isLittleOTVS <| hs.isLittleOTVS.sup ht.isLittleOTVS

theorem HasFDerivWithinAt.hasFDerivAt (h : HasFDerivWithinAt f f' s x) (hs : s ‚àà ùìù x) :
    HasFDerivAt f f' x := by
  rwa [‚Üê univ_inter s, hasFDerivWithinAt_inter hs, hasFDerivWithinAt_univ] at h

theorem DifferentiableWithinAt.differentiableAt (h : DifferentiableWithinAt ùïú f s x)
    (hs : s ‚àà ùìù x) : DifferentiableAt ùïú f x :=
  h.imp fun _ hf' => hf'.hasFDerivAt hs

/-- If `x` is isolated in `s`, then `f` has any derivative at `x` within `s`,
as this statement is empty. -/
theorem HasFDerivWithinAt.of_not_accPt (h : ¬¨AccPt x (ùìü s)) : HasFDerivWithinAt f f' s x := by
  rw [accPt_principal_iff_nhdsWithin, not_neBot] at h
  rw [‚Üê hasFDerivWithinAt_diff_singleton x, HasFDerivWithinAt, h,
    hasFDerivAtFilter_iff_isLittleOTVS]
  exact .bot

/-- If `x` is isolated in `s`, then `f` has any derivative at `x` within `s`,
as this statement is empty. -/
@[deprecated HasFDerivWithinAt.of_not_accPt (since := "2025-04-20")]
theorem HasFDerivWithinAt.of_nhdsWithin_eq_bot (h : ùìù[s \ {x}] x = ‚ä•) :
    HasFDerivWithinAt f f' s x :=
  .of_not_accPt <| by rwa [accPt_principal_iff_nhdsWithin, not_neBot]

/-- If `x` is not in the closure of `s`, then `f` has any derivative at `x` within `s`,
as this statement is empty. -/
theorem HasFDerivWithinAt.of_notMem_closure (h : x ‚àâ closure s) : HasFDerivWithinAt f f' s x :=
  .of_not_accPt (h ¬∑.clusterPt.mem_closure)

@[deprecated (since := "2025-05-23")]
alias HasFDerivWithinAt.of_not_mem_closure := HasFDerivWithinAt.of_notMem_closure

@[deprecated (since := "2025-04-20")]
alias hasFDerivWithinAt_of_nmem_closure := HasFDerivWithinAt.of_not_mem_closure

theorem fderivWithin_zero_of_not_accPt (h : ¬¨AccPt x (ùìü s)) : fderivWithin ùïú f s x = 0 := by
  rw [fderivWithin, if_pos (.of_not_accPt h)]

set_option linter.deprecated false in
@[deprecated fderivWithin_zero_of_not_accPt (since := "2025-04-20")]
theorem fderivWithin_zero_of_isolated (h : ùìù[s \ {x}] x = ‚ä•) : fderivWithin ùïú f s x = 0 := by
  rw [fderivWithin, if_pos (.of_nhdsWithin_eq_bot h)]

theorem fderivWithin_zero_of_notMem_closure (h : x ‚àâ closure s) : fderivWithin ùïú f s x = 0 :=
  fderivWithin_zero_of_not_accPt (h ¬∑.clusterPt.mem_closure)

@[deprecated (since := "2025-05-24")]
alias fderivWithin_zero_of_nmem_closure := fderivWithin_zero_of_notMem_closure

theorem DifferentiableWithinAt.hasFDerivWithinAt (h : DifferentiableWithinAt ùïú f s x) :
    HasFDerivWithinAt f (fderivWithin ùïú f s x) s x := by
  simp only [fderivWithin, dif_pos h]
  split_ifs with h‚ÇÄ
  exacts [h‚ÇÄ, Classical.choose_spec h]

theorem DifferentiableAt.hasFDerivAt (h : DifferentiableAt ùïú f x) :
    HasFDerivAt f (fderiv ùïú f x) x := by
  rw [fderiv, ‚Üê hasFDerivWithinAt_univ]
  rw [‚Üê differentiableWithinAt_univ] at h
  exact h.hasFDerivWithinAt

theorem DifferentiableOn.hasFDerivAt (h : DifferentiableOn ùïú f s) (hs : s ‚àà ùìù x) :
    HasFDerivAt f (fderiv ùïú f x) x :=
  ((h x (mem_of_mem_nhds hs)).differentiableAt hs).hasFDerivAt

theorem DifferentiableOn.differentiableAt (h : DifferentiableOn ùïú f s) (hs : s ‚àà ùìù x) :
    DifferentiableAt ùïú f x :=
  (h.hasFDerivAt hs).differentiableAt

theorem DifferentiableOn.eventually_differentiableAt (h : DifferentiableOn ùïú f s) (hs : s ‚àà ùìù x) :
    ‚àÄ·∂† y in ùìù x, DifferentiableAt ùïú f y :=
  (eventually_eventually_nhds.2 hs).mono fun _ => h.differentiableAt

protected theorem HasFDerivAt.fderiv (h : HasFDerivAt f f' x) : fderiv ùïú f x = f' := by
  ext
  rw [h.unique h.differentiableAt.hasFDerivAt]

theorem fderiv_eq {f' : E ‚Üí E ‚ÜíL[ùïú] F} (h : ‚àÄ x, HasFDerivAt f (f' x) x) : fderiv ùïú f = f' :=
  funext fun x => (h x).fderiv

protected theorem HasFDerivWithinAt.fderivWithin (h : HasFDerivWithinAt f f' s x)
    (hxs : UniqueDiffWithinAt ùïú s x) : fderivWithin ùïú f s x = f' :=
  (hxs.eq h h.differentiableWithinAt.hasFDerivWithinAt).symm

theorem DifferentiableWithinAt.mono (h : DifferentiableWithinAt ùïú f t x) (st : s ‚äÜ t) :
    DifferentiableWithinAt ùïú f s x := by
  rcases h with ‚ü®f', hf'‚ü©
  exact ‚ü®f', hf'.mono st‚ü©

theorem DifferentiableWithinAt.mono_of_mem_nhdsWithin
    (h : DifferentiableWithinAt ùïú f s x) {t : Set E} (hst : s ‚àà ùìù[t] x) :
    DifferentiableWithinAt ùïú f t x :=
  (h.hasFDerivWithinAt.mono_of_mem_nhdsWithin hst).differentiableWithinAt

@[deprecated (since := "2024-10-31")]
alias DifferentiableWithinAt.mono_of_mem := DifferentiableWithinAt.mono_of_mem_nhdsWithin

theorem DifferentiableWithinAt.congr_nhds (h : DifferentiableWithinAt ùïú f s x) {t : Set E}
    (hst : ùìù[s] x = ùìù[t] x) : DifferentiableWithinAt ùïú f t x :=
  h.mono_of_mem_nhdsWithin <| hst ‚ñ∏ self_mem_nhdsWithin

theorem differentiableWithinAt_congr_nhds {t : Set E} (hst : ùìù[s] x = ùìù[t] x) :
    DifferentiableWithinAt ùïú f s x ‚Üî DifferentiableWithinAt ùïú f t x :=
  ‚ü®fun h => h.congr_nhds hst, fun h => h.congr_nhds hst.symm‚ü©

theorem differentiableWithinAt_inter (ht : t ‚àà ùìù x) :
    DifferentiableWithinAt ùïú f (s ‚à© t) x ‚Üî DifferentiableWithinAt ùïú f s x := by
  simp only [DifferentiableWithinAt, hasFDerivWithinAt_inter ht]

theorem differentiableWithinAt_inter' (ht : t ‚àà ùìù[s] x) :
    DifferentiableWithinAt ùïú f (s ‚à© t) x ‚Üî DifferentiableWithinAt ùïú f s x := by
  simp only [DifferentiableWithinAt, hasFDerivWithinAt_inter' ht]

theorem differentiableWithinAt_insert_self :
    DifferentiableWithinAt ùïú f (insert x s) x ‚Üî DifferentiableWithinAt ùïú f s x :=
  ‚ü®fun h ‚Ü¶ h.mono (subset_insert x s), fun h ‚Ü¶ h.hasFDerivWithinAt.insert.differentiableWithinAt‚ü©

theorem differentiableWithinAt_insert {y : E} :
    DifferentiableWithinAt ùïú f (insert y s) x ‚Üî DifferentiableWithinAt ùïú f s x := by
  rcases eq_or_ne x y with (rfl | h)
  ¬∑ exact differentiableWithinAt_insert_self
  apply differentiableWithinAt_congr_nhds
  exact nhdsWithin_insert_of_ne h

alias ‚ü®DifferentiableWithinAt.of_insert, DifferentiableWithinAt.insert'‚ü© :=
differentiableWithinAt_insert

protected theorem DifferentiableWithinAt.insert (h : DifferentiableWithinAt ùïú f s x) :
    DifferentiableWithinAt ùïú f (insert x s) x :=
  h.insert'

theorem DifferentiableAt.differentiableWithinAt (h : DifferentiableAt ùïú f x) :
    DifferentiableWithinAt ùïú f s x :=
  (differentiableWithinAt_univ.2 h).mono (subset_univ _)

@[fun_prop]
theorem Differentiable.differentiableAt (h : Differentiable ùïú f) : DifferentiableAt ùïú f x :=
  h x

protected theorem DifferentiableAt.fderivWithin (h : DifferentiableAt ùïú f x)
    (hxs : UniqueDiffWithinAt ùïú s x) : fderivWithin ùïú f s x = fderiv ùïú f x :=
  h.hasFDerivAt.hasFDerivWithinAt.fderivWithin hxs

theorem DifferentiableOn.mono (h : DifferentiableOn ùïú f t) (st : s ‚äÜ t) : DifferentiableOn ùïú f s :=
  fun x hx => (h x (st hx)).mono st

theorem differentiableOn_univ : DifferentiableOn ùïú f univ ‚Üî Differentiable ùïú f := by
  simp only [DifferentiableOn, Differentiable, differentiableWithinAt_univ, mem_univ,
    forall_true_left]

@[fun_prop]
theorem Differentiable.differentiableOn (h : Differentiable ùïú f) : DifferentiableOn ùïú f s :=
  (differentiableOn_univ.2 h).mono (subset_univ _)

theorem differentiableOn_of_locally_differentiableOn
    (h : ‚àÄ x ‚àà s, ‚àÉ u, IsOpen u ‚àß x ‚àà u ‚àß DifferentiableOn ùïú f (s ‚à© u)) :
    DifferentiableOn ùïú f s := by
  intro x xs
  rcases h x xs with ‚ü®t, t_open, xt, ht‚ü©
  exact (differentiableWithinAt_inter (IsOpen.mem_nhds t_open xt)).1 (ht x ‚ü®xs, xt‚ü©)

theorem fderivWithin_of_mem_nhdsWithin (st : t ‚àà ùìù[s] x) (ht : UniqueDiffWithinAt ùïú s x)
    (h : DifferentiableWithinAt ùïú f t x) : fderivWithin ùïú f s x = fderivWithin ùïú f t x :=
  ((DifferentiableWithinAt.hasFDerivWithinAt h).mono_of_mem_nhdsWithin st).fderivWithin ht

@[deprecated (since := "2024-10-31")]
alias fderivWithin_of_mem := fderivWithin_of_mem_nhdsWithin

theorem fderivWithin_subset (st : s ‚äÜ t) (ht : UniqueDiffWithinAt ùïú s x)
    (h : DifferentiableWithinAt ùïú f t x) : fderivWithin ùïú f s x = fderivWithin ùïú f t x :=
  fderivWithin_of_mem_nhdsWithin (nhdsWithin_mono _ st self_mem_nhdsWithin) ht h

theorem fderivWithin_inter (ht : t ‚àà ùìù x) : fderivWithin ùïú f (s ‚à© t) x = fderivWithin ùïú f s x := by
  classical
  simp [fderivWithin, hasFDerivWithinAt_inter ht, DifferentiableWithinAt]

theorem fderivWithin_of_mem_nhds (h : s ‚àà ùìù x) : fderivWithin ùïú f s x = fderiv ùïú f x := by
  rw [‚Üê fderivWithin_univ, ‚Üê univ_inter s, fderivWithin_inter h]

theorem fderivWithin_of_isOpen (hs : IsOpen s) (hx : x ‚àà s) : fderivWithin ùïú f s x = fderiv ùïú f x :=
  fderivWithin_of_mem_nhds (hs.mem_nhds hx)

theorem fderivWithin_eq_fderiv (hs : UniqueDiffWithinAt ùïú s x) (h : DifferentiableAt ùïú f x) :
    fderivWithin ùïú f s x = fderiv ùïú f x := by
  rw [‚Üê fderivWithin_univ]
  exact fderivWithin_subset (subset_univ _) hs h.differentiableWithinAt

theorem fderiv_mem_iff {f : E ‚Üí F} {s : Set (E ‚ÜíL[ùïú] F)} {x : E} : fderiv ùïú f x ‚àà s ‚Üî
    DifferentiableAt ùïú f x ‚àß fderiv ùïú f x ‚àà s ‚à® ¬¨DifferentiableAt ùïú f x ‚àß (0 : E ‚ÜíL[ùïú] F) ‚àà s := by
  by_cases hx : DifferentiableAt ùïú f x <;> simp [fderiv_zero_of_not_differentiableAt, *]

theorem fderivWithin_mem_iff {f : E ‚Üí F} {t : Set E} {s : Set (E ‚ÜíL[ùïú] F)} {x : E} :
    fderivWithin ùïú f t x ‚àà s ‚Üî
      DifferentiableWithinAt ùïú f t x ‚àß fderivWithin ùïú f t x ‚àà s ‚à®
        ¬¨DifferentiableWithinAt ùïú f t x ‚àß (0 : E ‚ÜíL[ùïú] F) ‚àà s := by
  by_cases hx : DifferentiableWithinAt ùïú f t x <;>
    simp [fderivWithin_zero_of_not_differentiableWithinAt, *]

theorem Asymptotics.IsBigO.hasFDerivWithinAt {s : Set E} {x‚ÇÄ : E} {n : ‚Ñï}
    (h : f =O[ùìù[s] x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hx‚ÇÄ : x‚ÇÄ ‚àà s) (hn : 1 < n) :
    HasFDerivWithinAt f (0 : E ‚ÜíL[ùïú] F) s x‚ÇÄ := by
  simp_rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO,
    h.eq_zero_of_norm_pow_within hx‚ÇÄ hn.ne_bot, zero_apply, sub_zero,
    h.trans_isLittleO ((isLittleO_pow_sub_sub x‚ÇÄ hn).mono nhdsWithin_le_nhds)]

theorem Asymptotics.IsBigO.hasFDerivAt {x‚ÇÄ : E} {n : ‚Ñï} (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n)
    (hn : 1 < n) : HasFDerivAt f (0 : E ‚ÜíL[ùïú] F) x‚ÇÄ := by
  rw [‚Üê nhdsWithin_univ] at h
  exact (h.hasFDerivWithinAt (mem_univ _) hn).hasFDerivAt_of_univ

nonrec theorem HasFDerivWithinAt.isBigO_sub {f : E ‚Üí F} {s : Set E} {x‚ÇÄ : E} {f' : E ‚ÜíL[ùïú] F}
    (h : HasFDerivWithinAt f f' s x‚ÇÄ) : (f ¬∑ - f x‚ÇÄ) =O[ùìù[s] x‚ÇÄ] (¬∑ - x‚ÇÄ) :=
  h.isBigO_sub

lemma DifferentiableWithinAt.isBigO_sub {f : E ‚Üí F} {s : Set E} {x‚ÇÄ : E}
    (h : DifferentiableWithinAt ùïú f s x‚ÇÄ) : (f ¬∑ - f x‚ÇÄ) =O[ùìù[s] x‚ÇÄ] (¬∑ - x‚ÇÄ) :=
  h.hasFDerivWithinAt.isBigO_sub

nonrec theorem HasFDerivAt.isBigO_sub {f : E ‚Üí F} {x‚ÇÄ : E} {f' : E ‚ÜíL[ùïú] F}
    (h : HasFDerivAt f f' x‚ÇÄ) : (f ¬∑ - f x‚ÇÄ) =O[ùìù x‚ÇÄ] (¬∑ - x‚ÇÄ) :=
  h.isBigO_sub

nonrec theorem DifferentiableAt.isBigO_sub {f : E ‚Üí F} {x‚ÇÄ : E} (h : DifferentiableAt ùïú f x‚ÇÄ) :
    (f ¬∑ - f x‚ÇÄ) =O[ùìù x‚ÇÄ] (¬∑ - x‚ÇÄ) :=
  h.hasFDerivAt.isBigO_sub

end FDerivProperties

section Continuous

/-! ### Deducing continuity from differentiability -/


theorem HasFDerivAtFilter.tendsto_nhds (hL : L ‚â§ ùìù x) (h : HasFDerivAtFilter f f' x L) :
    Tendsto f L (ùìù (f x)) := by
  have : Tendsto (fun x' => f x' - f x) L (ùìù 0) := by
    refine h.isBigO_sub.trans_tendsto (Tendsto.mono_left ?_ hL)
    rw [‚Üê sub_self x]
    exact tendsto_id.sub tendsto_const_nhds
  have := this.add (tendsto_const_nhds (x := f x))
  rw [zero_add (f x)] at this
  exact this.congr (by simp only [sub_add_cancel, eq_self_iff_true, forall_const])

theorem HasFDerivWithinAt.continuousWithinAt (h : HasFDerivWithinAt f f' s x) :
    ContinuousWithinAt f s x :=
  HasFDerivAtFilter.tendsto_nhds inf_le_left h

theorem HasFDerivAt.continuousAt (h : HasFDerivAt f f' x) : ContinuousAt f x :=
  HasFDerivAtFilter.tendsto_nhds le_rfl h

@[fun_prop]
theorem DifferentiableWithinAt.continuousWithinAt (h : DifferentiableWithinAt ùïú f s x) :
    ContinuousWithinAt f s x :=
  let ‚ü®_, hf'‚ü© := h
  hf'.continuousWithinAt

@[fun_prop]
theorem DifferentiableAt.continuousAt (h : DifferentiableAt ùïú f x) : ContinuousAt f x :=
  let ‚ü®_, hf'‚ü© := h
  hf'.continuousAt

@[fun_prop]
theorem DifferentiableOn.continuousOn (h : DifferentiableOn ùïú f s) : ContinuousOn f s := fun x hx =>
  (h x hx).continuousWithinAt

@[fun_prop]
theorem Differentiable.continuous (h : Differentiable ùïú f) : Continuous f :=
  continuous_iff_continuousAt.2 fun x => (h x).continuousAt

protected theorem HasStrictFDerivAt.continuousAt (hf : HasStrictFDerivAt f f' x) :
    ContinuousAt f x :=
  hf.hasFDerivAt.continuousAt

theorem HasStrictFDerivAt.isBigO_sub_rev {f' : E ‚âÉL[ùïú] F}
    (hf : HasStrictFDerivAt f (f' : E ‚ÜíL[ùïú] F) x) :
    (fun p : E √ó E => p.1 - p.2) =O[ùìù (x, x)] fun p : E √ó E => f p.1 - f p.2 :=
  ((f'.isBigO_comp_rev _ _).trans
      (hf.isLittleO.trans_isBigO (f'.isBigO_comp_rev _ _)).right_isBigO_add).congr
    (fun _ => rfl) fun _ => sub_add_cancel _ _

theorem HasFDerivAtFilter.isBigO_sub_rev (hf : HasFDerivAtFilter f f' x L) {C}
    (hf' : AntilipschitzWith C f') : (fun x' => x' - x) =O[L] fun x' => f x' - f x :=
  have : (fun x' => x' - x) =O[L] fun x' => f' (x' - x) :=
    isBigO_iff.2 ‚ü®C, Eventually.of_forall fun _ => ZeroHomClass.bound_of_antilipschitz f' hf' _‚ü©
  (this.trans (hf.isLittleO.trans_isBigO this).right_isBigO_add).congr (fun _ => rfl) fun _ =>
    sub_add_cancel _ _

end Continuous

section id

/-! ### Derivative of the identity -/

@[fun_prop]
theorem hasStrictFDerivAt_id (x : E) : HasStrictFDerivAt id (id ùïú E) x :=
  .of_isLittleOTVS <| (IsLittleOTVS.zero _ _).congr_left <| by simp

theorem hasFDerivAtFilter_id (x : E) (L : Filter E) : HasFDerivAtFilter id (id ùïú E) x L :=
  .of_isLittleOTVS <| (IsLittleOTVS.zero _ _).congr_left <| by simp

@[fun_prop]
theorem hasFDerivWithinAt_id (x : E) (s : Set E) : HasFDerivWithinAt id (id ùïú E) s x :=
  hasFDerivAtFilter_id _ _

@[fun_prop]
theorem hasFDerivAt_id (x : E) : HasFDerivAt id (id ùïú E) x :=
  hasFDerivAtFilter_id _ _

@[simp, fun_prop]
theorem differentiableAt_id : DifferentiableAt ùïú id x :=
  (hasFDerivAt_id x).differentiableAt

/-- Variant with `fun x => x` rather than `id` -/
@[simp]
theorem differentiableAt_id' : DifferentiableAt ùïú (fun x => x) x :=
  (hasFDerivAt_id x).differentiableAt

@[fun_prop]
theorem differentiableWithinAt_id : DifferentiableWithinAt ùïú id s x :=
  differentiableAt_id.differentiableWithinAt

/-- Variant with `fun x => x` rather than `id` -/
@[fun_prop]
theorem differentiableWithinAt_id' : DifferentiableWithinAt ùïú (fun x => x) s x :=
  differentiableWithinAt_id

@[simp, fun_prop]
theorem differentiable_id : Differentiable ùïú (id : E ‚Üí E) := fun _ => differentiableAt_id

/-- Variant with `fun x => x` rather than `id` -/
@[simp]
theorem differentiable_id' : Differentiable ùïú fun x : E => x := fun _ => differentiableAt_id

@[fun_prop]
theorem differentiableOn_id : DifferentiableOn ùïú id s :=
  differentiable_id.differentiableOn

@[simp]
theorem fderiv_id : fderiv ùïú id x = id ùïú E :=
  HasFDerivAt.fderiv (hasFDerivAt_id x)

@[simp]
theorem fderiv_id' : fderiv ùïú (fun x : E => x) x = ContinuousLinearMap.id ùïú E :=
  fderiv_id

theorem fderivWithin_id (hxs : UniqueDiffWithinAt ùïú s x) : fderivWithin ùïú id s x = id ùïú E := by
  rw [DifferentiableAt.fderivWithin differentiableAt_id hxs]
  exact fderiv_id

theorem fderivWithin_id' (hxs : UniqueDiffWithinAt ùïú s x) :
    fderivWithin ùïú (fun x : E => x) s x = ContinuousLinearMap.id ùïú E :=
  fderivWithin_id hxs

end id

section MeanValue

/-- Converse to the mean value inequality: if `f` is differentiable at `x‚ÇÄ` and `C`-lipschitz
on a neighborhood of `x‚ÇÄ` then its derivative at `x‚ÇÄ` has norm bounded by `C`. This version
only assumes that `‚Äñf x - f x‚ÇÄ‚Äñ ‚â§ C * ‚Äñx - x‚ÇÄ‚Äñ` in a neighborhood of `x`. -/
theorem HasFDerivAt.le_of_lip' {f : E ‚Üí F} {f' : E ‚ÜíL[ùïú] F} {x‚ÇÄ : E} (hf : HasFDerivAt f f' x‚ÇÄ)
    {C : ‚Ñù} (hC‚ÇÄ : 0 ‚â§ C) (hlip : ‚àÄ·∂† x in ùìù x‚ÇÄ, ‚Äñf x - f x‚ÇÄ‚Äñ ‚â§ C * ‚Äñx - x‚ÇÄ‚Äñ) : ‚Äñf'‚Äñ ‚â§ C := by
  refine le_of_forall_pos_le_add fun Œµ Œµ0 => opNorm_le_of_nhds_zero ?_ ?_
  ¬∑ exact add_nonneg hC‚ÇÄ Œµ0.le
  rw [‚Üê map_add_left_nhds_zero x‚ÇÄ, eventually_map] at hlip
  filter_upwards [isLittleO_iff.1 (hasFDerivAt_iff_isLittleO_nhds_zero.1 hf) Œµ0, hlip] with y hy hyC
  rw [add_sub_cancel_left] at hyC
  calc
    ‚Äñf' y‚Äñ ‚â§ ‚Äñf (x‚ÇÄ + y) - f x‚ÇÄ‚Äñ + ‚Äñf (x‚ÇÄ + y) - f x‚ÇÄ - f' y‚Äñ := norm_le_insert _ _
    _ ‚â§ C * ‚Äñy‚Äñ + Œµ * ‚Äñy‚Äñ := add_le_add hyC hy
    _ = (C + Œµ) * ‚Äñy‚Äñ := (add_mul _ _ _).symm

/-- Converse to the mean value inequality: if `f` is differentiable at `x‚ÇÄ` and `C`-lipschitz
on a neighborhood of `x‚ÇÄ` then its derivative at `x‚ÇÄ` has norm bounded by `C`. -/
theorem HasFDerivAt.le_of_lipschitzOn
    {f : E ‚Üí F} {f' : E ‚ÜíL[ùïú] F} {x‚ÇÄ : E} (hf : HasFDerivAt f f' x‚ÇÄ)
    {s : Set E} (hs : s ‚àà ùìù x‚ÇÄ) {C : ‚Ñù‚â•0} (hlip : LipschitzOnWith C f s) : ‚Äñf'‚Äñ ‚â§ C := by
  refine hf.le_of_lip' C.coe_nonneg ?_
  filter_upwards [hs] with x hx using hlip.norm_sub_le hx (mem_of_mem_nhds hs)

/-- Converse to the mean value inequality: if `f` is differentiable at `x‚ÇÄ` and `C`-lipschitz
then its derivative at `x‚ÇÄ` has norm bounded by `C`. -/
theorem HasFDerivAt.le_of_lipschitz {f : E ‚Üí F} {f' : E ‚ÜíL[ùïú] F} {x‚ÇÄ : E} (hf : HasFDerivAt f f' x‚ÇÄ)
    {C : ‚Ñù‚â•0} (hlip : LipschitzWith C f) : ‚Äñf'‚Äñ ‚â§ C :=
  hf.le_of_lipschitzOn univ_mem (lipschitzOnWith_univ.2 hlip)

variable (ùïú)

/-- Converse to the mean value inequality: if `f` is `C`-lipschitz
on a neighborhood of `x‚ÇÄ` then its derivative at `x‚ÇÄ` has norm bounded by `C`. This version
only assumes that `‚Äñf x - f x‚ÇÄ‚Äñ ‚â§ C * ‚Äñx - x‚ÇÄ‚Äñ` in a neighborhood of `x`. -/
theorem norm_fderiv_le_of_lip' {f : E ‚Üí F} {x‚ÇÄ : E}
    {C : ‚Ñù} (hC‚ÇÄ : 0 ‚â§ C) (hlip : ‚àÄ·∂† x in ùìù x‚ÇÄ, ‚Äñf x - f x‚ÇÄ‚Äñ ‚â§ C * ‚Äñx - x‚ÇÄ‚Äñ) :
    ‚Äñfderiv ùïú f x‚ÇÄ‚Äñ ‚â§ C := by
  by_cases hf : DifferentiableAt ùïú f x‚ÇÄ
  ¬∑ exact hf.hasFDerivAt.le_of_lip' hC‚ÇÄ hlip
  ¬∑ rw [fderiv_zero_of_not_differentiableAt hf]
    simp [hC‚ÇÄ]

/-- Converse to the mean value inequality: if `f` is `C`-lipschitz
on a neighborhood of `x‚ÇÄ` then its derivative at `x‚ÇÄ` has norm bounded by `C`.
Version using `fderiv`. -/
theorem norm_fderiv_le_of_lipschitzOn {f : E ‚Üí F} {x‚ÇÄ : E} {s : Set E} (hs : s ‚àà ùìù x‚ÇÄ)
    {C : ‚Ñù‚â•0} (hlip : LipschitzOnWith C f s) : ‚Äñfderiv ùïú f x‚ÇÄ‚Äñ ‚â§ C := by
  refine norm_fderiv_le_of_lip' ùïú C.coe_nonneg ?_
  filter_upwards [hs] with x hx using hlip.norm_sub_le hx (mem_of_mem_nhds hs)

/-- Converse to the mean value inequality: if `f` is `C`-lipschitz then
its derivative at `x‚ÇÄ` has norm bounded by `C`.
Version using `fderiv`. -/
theorem norm_fderiv_le_of_lipschitz {f : E ‚Üí F} {x‚ÇÄ : E}
    {C : ‚Ñù‚â•0} (hlip : LipschitzWith C f) : ‚Äñfderiv ùïú f x‚ÇÄ‚Äñ ‚â§ C :=
  norm_fderiv_le_of_lipschitzOn ùïú univ_mem (lipschitzOnWith_univ.2 hlip)

end MeanValue

end

section Semilinear
/-!
## Results involving semilinear maps
-/
variable {ùïú V V' W W' : Type*} [NontriviallyNormedField ùïú] {œÉ œÉ' : RingHom ùïú ùïú}
  [NormedAddCommGroup V] [NormedSpace ùïú V] [NormedAddCommGroup V'] [NormedSpace ùïú V']
  [NormedAddCommGroup W] [NormedSpace ùïú W] [NormedAddCommGroup W'] [NormedSpace ùïú W']
  [RingHomIsometric œÉ] [RingHomInvPair œÉ œÉ'] (L : W ‚ÜíSL[œÉ] W') (R : V' ‚ÜíSL[œÉ'] V)

/-- If `L` and `R` are semilinear maps whose composite is linear, and `f` has Fr√©chet derivative
`f'` at `R z`, then `L ‚àò f ‚àò R` has Fr√©chet derivative `L ‚àò f' ‚àò R` at `z`. -/
lemma HasFDerivAt.comp_semilinear {f : V ‚Üí W} {z : V'} {f' : V ‚ÜíL[ùïú] W}
    (hf : HasFDerivAt f f' (R z)) : HasFDerivAt (L ‚àò f ‚àò R) (L.comp (f'.comp R)) z := by
  have : RingHomIsometric œÉ' := .inv œÉ
  rw [hasFDerivAt_iff_isLittleO_nhds_zero] at ‚ä¢ hf
  have := hf.comp_tendsto (R.map_zero ‚ñ∏ R.continuous.continuousAt.tendsto)
  simpa using ((L.isBigO_comp _ _).trans_isLittleO this).trans_isBigO (R.isBigO_id _)

/-- If `L` and `R` are semilinear maps whose composite is linear, and `f` is differentiable at
`R z`, then `L ‚àò f ‚àò R` is differentiable at `z`. -/
lemma DifferentiableAt.comp_semilinear‚ÇÇ {f : V ‚Üí W} {z : V'} (hf : DifferentiableAt ùïú f (R z)) :
    DifferentiableAt ùïú (L ‚àò f ‚àò R) z := by
  simpa using (hf.hasFDerivAt.comp_semilinear L R).differentiableAt

end Semilinear
