/-
Copyright (c) 2021 S√©bastien Gou√´zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: S√©bastien Gou√´zel
-/
import Mathlib.Analysis.Calculus.Deriv.Pow
import Mathlib.Analysis.Calculus.MeanValue
import Mathlib.Analysis.Calculus.ContDiff.Basic

/-!
# Symmetry of the second derivative

We show that, over the reals, the second derivative is symmetric.

The most precise result is `Convex.second_derivative_within_at_symmetric`. It asserts that,
if a function is differentiable inside a convex set `s` with nonempty interior, and has a second
derivative within `s` at a point `x`, then this second derivative at `x` is symmetric. Note that
this result does not require continuity of the first derivative.

The following particular cases of this statement are especially relevant:

`second_derivative_symmetric_of_eventually` asserts that, if a function is differentiable on a
neighborhood of `x`, and has a second derivative at `x`, then this second derivative is symmetric.

`second_derivative_symmetric` asserts that, if a function is differentiable, and has a second
derivative at `x`, then this second derivative is symmetric.

There statements are given over `‚Ñù` or `‚ÑÇ`, the general version being deduced from the real
version. We also give statements in terms of `fderiv` and `fderivWithin`, called respectively
`ContDiffAt.isSymmSndFDerivAt` and `ContDiffWithinAt.isSymmSndFDerivWithinAt` (the latter
requiring that the point under consideration is accumulated by points in the interior of the set).
These are written using ad hoc predicates `IsSymmSndFDerivAt` and `IsSymmSndFDerivWithinAt`, which
increase readability of statements in differential geometry where they show up a lot.

## Implementation note

For the proof, we obtain an asymptotic expansion to order two of `f (x + v + w) - f (x + v)`, by
using the mean value inequality applied to a suitable function along the
segment `[x + v, x + v + w]`. This expansion involves `f'' ‚¨ù w` as we move along a segment directed
by `w` (see `Convex.taylor_approx_two_segment`).

Consider the alternate sum `f (x + v + w) + f x - f (x + v) - f (x + w)`, corresponding to the
values of `f` along a rectangle based at `x` with sides `v` and `w`. One can write it using the two
sides directed by `w`, as `(f (x + v + w) - f (x + v)) - (f (x + w) - f x)`. Together with the
previous asymptotic expansion, one deduces that it equals `f'' v w + o(1)` when `v, w` tends to `0`.
Exchanging the roles of `v` and `w`, one instead gets an asymptotic expansion `f'' w v`, from which
the equality `f'' v w = f'' w v` follows.

In our most general statement, we only assume that `f` is differentiable inside a convex set `s`, so
a few modifications have to be made. Since we don't assume continuity of `f` at `x`, we consider
instead the rectangle based at `x + v + w` with sides `v` and `w`,
in `Convex.isLittleO_alternate_sum_square`, but the argument is essentially the same. It only works
when `v` and `w` both point towards the interior of `s`, to make sure that all the sides of the
rectangle are contained in `s` by convexity. The general case follows by linearity, though.
-/


open Asymptotics Set Filter

open scoped Topology

section General

variable {ùïú : Type*} [NontriviallyNormedField ùïú]
  {E F : Type*} [NormedAddCommGroup E] [NormedSpace ùïú E] [NormedAddCommGroup F]
  [NormedSpace ùïú F] {s t : Set E} {f : E ‚Üí F} {x : E}

variable (ùïú) in
/-- Definition recording that a function has a symmetric second derivative within a set at
a point. This is automatic in most cases of interest (open sets over real or complex vector fields,
or general case for analytic functions), but we can express theorems of calculus using this
as a general assumption, and then specialize to these situations. -/
def IsSymmSndFDerivWithinAt (f : E ‚Üí F) (s : Set E) (x : E) : Prop :=
  ‚àÄ v w, fderivWithin ùïú (fderivWithin ùïú f s) s x v w = fderivWithin ùïú (fderivWithin ùïú f s) s x w v

variable (ùïú) in
/-- Definition recording that a function has a symmetric second derivative at
a point. This is automatic in most cases of interest (open sets over real or complex vector fields,
or general case for analytic functions), but we can express theorems of calculus using this
as a general assumption, and then specialize to these situations. -/
def IsSymmSndFDerivAt (f : E ‚Üí F) (x : E) : Prop :=
  ‚àÄ v w, fderiv ùïú (fderiv ùïú f) x v w = fderiv ùïú (fderiv ùïú f) x w v

protected lemma IsSymmSndFDerivWithinAt.eq (h : IsSymmSndFDerivWithinAt ùïú f s x) (v w : E) :
    fderivWithin ùïú (fderivWithin ùïú f s) s x v w = fderivWithin ùïú (fderivWithin ùïú f s) s x w v :=
  h v w

protected lemma IsSymmSndFDerivAt.eq
    (h : IsSymmSndFDerivAt ùïú f x) (v w : E) :
    fderiv ùïú (fderiv ùïú f) x v w = fderiv ùïú (fderiv ùïú f) x w v :=
  h v w

lemma fderivWithin_fderivWithin_eq_of_mem_nhdsWithin (h : t ‚àà ùìù[s] x)
    (hf : ContDiffWithinAt ùïú 2 f t x) (hs : UniqueDiffOn ùïú s) (ht : UniqueDiffOn ùïú t) (hx : x ‚àà s) :
    fderivWithin ùïú (fderivWithin ùïú f s) s x = fderivWithin ùïú (fderivWithin ùïú f t) t x := by
  have A : ‚àÄ·∂† y in ùìù[s] x, fderivWithin ùïú f s y = fderivWithin ùïú f t y := by
    have : ‚àÄ·∂† y in ùìù[s] x, ContDiffWithinAt ùïú 2 f t y :=
      nhdsWithin_le_iff.2 h (nhdsWithin_mono _ (subset_insert x t) (hf.eventually (by simp)))
    filter_upwards [self_mem_nhdsWithin, this, eventually_eventually_nhdsWithin.2 h]
      with y hy h'y h''y
    exact fderivWithin_of_mem_nhdsWithin h''y (hs y hy) (h'y.differentiableWithinAt one_le_two)
  have : fderivWithin ùïú (fderivWithin ùïú f s) s x = fderivWithin ùïú (fderivWithin ùïú f t) s x := by
    apply Filter.EventuallyEq.fderivWithin_eq A
    exact fderivWithin_of_mem_nhdsWithin h (hs x hx) (hf.differentiableWithinAt one_le_two)
  rw [this]
  apply fderivWithin_of_mem_nhdsWithin h (hs x hx)
  exact (hf.fderivWithin_right (m := 1) ht le_rfl
    (mem_of_mem_nhdsWithin hx h)).differentiableWithinAt le_rfl

lemma fderivWithin_fderivWithin_eq_of_eventuallyEq (h : s =·∂†[ùìù x] t) :
    fderivWithin ùïú (fderivWithin ùïú f s) s x = fderivWithin ùïú (fderivWithin ùïú f t) t x := calc
  fderivWithin ùïú (fderivWithin ùïú f s) s x
    = fderivWithin ùïú (fderivWithin ùïú f t) s x :=
      (fderivWithin_eventually_congr_set h).fderivWithin_eq_nhds
  _ = fderivWithin ùïú (fderivWithin ùïú f t) t x := fderivWithin_congr_set h

lemma fderivWithin_fderivWithin_eq_of_mem_nhds {f : E ‚Üí F} {x : E} {s : Set E}
    (h : s ‚àà ùìù x) :
    fderivWithin ùïú (fderivWithin ùïú f s) s x = fderiv ùïú (fderiv ùïú f) x := by
  simp only [‚Üê fderivWithin_univ]
  apply fderivWithin_fderivWithin_eq_of_eventuallyEq
  simp [h]

@[simp] lemma isSymmSndFDerivWithinAt_univ :
    IsSymmSndFDerivWithinAt ùïú f univ x ‚Üî IsSymmSndFDerivAt ùïú f x := by
  simp [IsSymmSndFDerivWithinAt, IsSymmSndFDerivAt]

theorem IsSymmSndFDerivWithinAt.mono_of_mem_nhdsWithin (h : IsSymmSndFDerivWithinAt ùïú f t x)
    (hst : t ‚àà ùìù[s] x) (hf : ContDiffWithinAt ùïú 2 f t x)
    (hs : UniqueDiffOn ùïú s) (ht : UniqueDiffOn ùïú t) (hx : x ‚àà s) :
    IsSymmSndFDerivWithinAt ùïú f s x := by
  intro v w
  rw [fderivWithin_fderivWithin_eq_of_mem_nhdsWithin hst hf hs ht hx]
  exact h v w

theorem IsSymmSndFDerivWithinAt.congr_set (h : IsSymmSndFDerivWithinAt ùïú f s x)
    (hst : s =·∂†[ùìù x] t) : IsSymmSndFDerivWithinAt ùïú f t x := by
  intro v w
  rw [fderivWithin_fderivWithin_eq_of_eventuallyEq hst.symm]
  exact h v w

theorem isSymmSndFDerivWithinAt_congr_set (hst : s =·∂†[ùìù x] t) :
    IsSymmSndFDerivWithinAt ùïú f s x ‚Üî IsSymmSndFDerivWithinAt ùïú f t x :=
  ‚ü®fun h ‚Ü¶ h.congr_set hst, fun h ‚Ü¶ h.congr_set hst.symm‚ü©

theorem IsSymmSndFDerivAt.isSymmSndFDerivWithinAt (h : IsSymmSndFDerivAt ùïú f x)
    (hf : ContDiffAt ùïú 2 f x) (hs : UniqueDiffOn ùïú s) (hx : x ‚àà s) :
    IsSymmSndFDerivWithinAt ùïú f s x := by
  simp only [‚Üê isSymmSndFDerivWithinAt_univ, ‚Üê contDiffWithinAt_univ] at h hf
  exact h.mono_of_mem_nhdsWithin univ_mem hf hs uniqueDiffOn_univ hx

end General

section Real

variable {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [NormedAddCommGroup F]
  [NormedSpace ‚Ñù F] {s : Set E} (s_conv : Convex ‚Ñù s) {f : E ‚Üí F} {f' : E ‚Üí E ‚ÜíL[‚Ñù] F}
  {f'' : E ‚ÜíL[‚Ñù] E ‚ÜíL[‚Ñù] F} (hf : ‚àÄ x ‚àà interior s, HasFDerivAt f (f' x) x) {x : E} (xs : x ‚àà s)
  (hx : HasFDerivWithinAt f' f'' (interior s) x)

section
include s_conv hf xs hx

/-- Assume that `f` is differentiable inside a convex set `s`, and that its derivative `f'` is
differentiable at a point `x`. Then, given two vectors `v` and `w` pointing inside `s`, one can
Taylor-expand to order two the function `f` on the segment `[x + h v, x + h (v + w)]`, giving a
bilinear estimate for `f (x + hv + hw) - f (x + hv)` in terms of `f' w` and of `f'' ‚¨ù w`, up to
`o(h^2)`.

This is a technical statement used to show that the second derivative is symmetric. -/
theorem Convex.taylor_approx_two_segment {v w : E} (hv : x + v ‚àà interior s)
    (hw : x + v + w ‚àà interior s) :
    (fun h : ‚Ñù => f (x + h ‚Ä¢ v + h ‚Ä¢ w)
        - f (x + h ‚Ä¢ v) - h ‚Ä¢ f' x w - h ^ 2 ‚Ä¢ f'' v w - (h ^ 2 / 2) ‚Ä¢ f'' w w) =o[ùìù[>] 0]
      fun h => h ^ 2 := by
  -- it suffices to check that the expression is bounded by `Œµ * ((‚Äñv‚Äñ + ‚Äñw‚Äñ) * ‚Äñw‚Äñ) * h^2` for
  -- small enough `h`, for any positive `Œµ`.
  refine IsLittleO.trans_isBigO
    (isLittleO_iff.2 fun Œµ Œµpos => ?_) (isBigO_const_mul_self ((‚Äñv‚Äñ + ‚Äñw‚Äñ) * ‚Äñw‚Äñ) _ _)
  -- consider a ball of radius `Œ¥` around `x` in which the Taylor approximation for `f''` is
  -- good up to `Œ¥`.
  rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, isLittleO_iff] at hx
  rcases Metric.mem_nhdsWithin_iff.1 (hx Œµpos) with ‚ü®Œ¥, Œ¥pos, sŒ¥‚ü©
  have E1 : ‚àÄ·∂† h in ùìù[>] (0 : ‚Ñù), h * (‚Äñv‚Äñ + ‚Äñw‚Äñ) < Œ¥ := by
    have : Filter.Tendsto (fun h => h * (‚Äñv‚Äñ + ‚Äñw‚Äñ)) (ùìù[>] (0 : ‚Ñù)) (ùìù (0 * (‚Äñv‚Äñ + ‚Äñw‚Äñ))) :=
      (continuous_id.mul continuous_const).continuousWithinAt
    apply (tendsto_order.1 this).2 Œ¥
    simpa only [zero_mul] using Œ¥pos
  have E2 : ‚àÄ·∂† h in ùìù[>] (0 : ‚Ñù), (h : ‚Ñù) < 1 :=
    mem_nhdsWithin_Ioi_iff_exists_Ioo_subset.2
      ‚ü®(1 : ‚Ñù), by simp only [mem_Ioi, zero_lt_one], fun x hx => hx.2‚ü©
  filter_upwards [E1, E2, self_mem_nhdsWithin] with h hŒ¥ h_lt_1 hpos
  -- we consider `h` small enough that all points under consideration belong to this ball,
  -- and also with `0 < h < 1`.
  replace hpos : 0 < h := hpos
  have xt_mem : ‚àÄ t ‚àà Icc (0 : ‚Ñù) 1, x + h ‚Ä¢ v + (t * h) ‚Ä¢ w ‚àà interior s := by
    intro t ht
    have : x + h ‚Ä¢ v ‚àà interior s := s_conv.add_smul_mem_interior xs hv ‚ü®hpos, h_lt_1.le‚ü©
    rw [‚Üê smul_smul]
    apply s_conv.interior.add_smul_mem this _ ht
    rw [add_assoc] at hw
    convert s_conv.add_smul_mem_interior xs hw ‚ü®hpos, h_lt_1.le‚ü© using 1
    module
  -- define a function `g` on `[0,1]` (identified with `[v, v + w]`) such that `g 1 - g 0` is the
  -- quantity to be estimated. We will check that its derivative is given by an explicit
  -- expression `g'`, that we can bound. Then the desired bound for `g 1 - g 0` follows from the
  -- mean value inequality.
  let g t :=
    f (x + h ‚Ä¢ v + (t * h) ‚Ä¢ w) - (t * h) ‚Ä¢ f' x w - (t * h ^ 2) ‚Ä¢ f'' v w -
      ((t * h) ^ 2 / 2) ‚Ä¢ f'' w w
  set g' := fun t =>
    f' (x + h ‚Ä¢ v + (t * h) ‚Ä¢ w) (h ‚Ä¢ w) - h ‚Ä¢ f' x w - h ^ 2 ‚Ä¢ f'' v w - (t * h ^ 2) ‚Ä¢ f'' w w
    with hg'
  -- check that `g'` is the derivative of `g`, by a straightforward computation
  have g_deriv : ‚àÄ t ‚àà Icc (0 : ‚Ñù) 1, HasDerivWithinAt g (g' t) (Icc 0 1) t := by
    intro t ht
    apply_rules [HasDerivWithinAt.sub, HasDerivWithinAt.add]
    ¬∑ refine (hf _ ?_).comp_hasDerivWithinAt _ ?_
      ¬∑ exact xt_mem t ht
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.const_add, HasDerivAt.smul_const,
        hasDerivAt_mul_const]
    ¬∑ apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    ¬∑ apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    ¬∑ suffices H : HasDerivWithinAt (fun u => ((u * h) ^ 2 / 2) ‚Ä¢ f'' w w)
          ((((2 : ‚Ñï) : ‚Ñù) * (t * h) ^ (2 - 1) * (1 * h) / 2) ‚Ä¢ f'' w w) (Icc 0 1) t by
        convert H using 2
        ring
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_id',
        HasDerivAt.pow, HasDerivAt.mul_const]
  -- check that `g'` is uniformly bounded, with a suitable bound `Œµ * ((‚Äñv‚Äñ + ‚Äñw‚Äñ) * ‚Äñw‚Äñ) * h^2`.
  have g'_bound : ‚àÄ t ‚àà Ico (0 : ‚Ñù) 1, ‚Äñg' t‚Äñ ‚â§ Œµ * ((‚Äñv‚Äñ + ‚Äñw‚Äñ) * ‚Äñw‚Äñ) * h ^ 2 := by
    intro t ht
    have I : ‚Äñh ‚Ä¢ v + (t * h) ‚Ä¢ w‚Äñ ‚â§ h * (‚Äñv‚Äñ + ‚Äñw‚Äñ) :=
      calc
        ‚Äñh ‚Ä¢ v + (t * h) ‚Ä¢ w‚Äñ ‚â§ ‚Äñh ‚Ä¢ v‚Äñ + ‚Äñ(t * h) ‚Ä¢ w‚Äñ := norm_add_le _ _
        _ = h * ‚Äñv‚Äñ + t * (h * ‚Äñw‚Äñ) := by
          simp only [norm_smul, Real.norm_eq_abs, hpos.le, abs_of_nonneg, abs_mul, ht.left,
            mul_assoc]
        _ ‚â§ h * ‚Äñv‚Äñ + 1 * (h * ‚Äñw‚Äñ) := by gcongr; exact ht.2.le
        _ = h * (‚Äñv‚Äñ + ‚Äñw‚Äñ) := by ring
    calc
      ‚Äñg' t‚Äñ = ‚Äñ(f' (x + h ‚Ä¢ v + (t * h) ‚Ä¢ w) - f' x - f'' (h ‚Ä¢ v + (t * h) ‚Ä¢ w)) (h ‚Ä¢ w)‚Äñ := by
        rw [hg']
        congrm ‚Äñ?_‚Äñ
        simp only [ContinuousLinearMap.sub_apply, ContinuousLinearMap.add_apply,
          ContinuousLinearMap.smul_apply, map_add, map_smul]
        module
      _ ‚â§ ‚Äñf' (x + h ‚Ä¢ v + (t * h) ‚Ä¢ w) - f' x - f'' (h ‚Ä¢ v + (t * h) ‚Ä¢ w)‚Äñ * ‚Äñh ‚Ä¢ w‚Äñ :=
        (ContinuousLinearMap.le_opNorm _ _)
      _ ‚â§ Œµ * ‚Äñh ‚Ä¢ v + (t * h) ‚Ä¢ w‚Äñ * ‚Äñh ‚Ä¢ w‚Äñ := by
        gcongr
        have H : x + h ‚Ä¢ v + (t * h) ‚Ä¢ w ‚àà Metric.ball x Œ¥ ‚à© interior s := by
          refine ‚ü®?_, xt_mem t ‚ü®ht.1, ht.2.le‚ü©‚ü©
          rw [add_assoc, add_mem_ball_iff_norm]
          exact I.trans_lt hŒ¥
        simpa only [mem_setOf_eq, add_assoc x, add_sub_cancel_left] using sŒ¥ H
      _ ‚â§ Œµ * (‚Äñh ‚Ä¢ v‚Äñ + ‚Äñh ‚Ä¢ w‚Äñ) * ‚Äñh ‚Ä¢ w‚Äñ := by
        gcongr
        apply (norm_add_le _ _).trans
        gcongr
        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, ht.1, hpos.le, mul_assoc]
        exact mul_le_of_le_one_left (by positivity) ht.2.le
      _ = Œµ * ((‚Äñv‚Äñ + ‚Äñw‚Äñ) * ‚Äñw‚Äñ) * h ^ 2 := by
        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, hpos.le]; ring
  -- conclude using the mean value inequality
  have I : ‚Äñg 1 - g 0‚Äñ ‚â§ Œµ * ((‚Äñv‚Äñ + ‚Äñw‚Äñ) * ‚Äñw‚Äñ) * h ^ 2 := by
    simpa only [mul_one, sub_zero] using
      norm_image_sub_le_of_norm_deriv_le_segment' g_deriv g'_bound 1 (right_mem_Icc.2 zero_le_one)
  convert I using 1
  ¬∑ congr 1
    simp only [g, Nat.one_ne_zero, add_zero, one_mul, zero_div, zero_mul, sub_zero,
      zero_smul, Ne, not_false_iff, zero_pow, reduceCtorEq]
    abel
  ¬∑ simp (discharger := positivity) only [Real.norm_eq_abs, abs_mul, abs_of_nonneg, abs_pow]
    ring

/-- One can get `f'' v w` as the limit of `h ^ (-2)` times the alternate sum of the values of `f`
along the vertices of a quadrilateral with sides `h v` and `h w` based at `x`.
In a setting where `f` is not guaranteed to be continuous at `f`, we can still
get this if we use a quadrilateral based at `h v + h w`. -/
theorem Convex.isLittleO_alternate_sum_square {v w : E} (h4v : x + (4 : ‚Ñù) ‚Ä¢ v ‚àà interior s)
    (h4w : x + (4 : ‚Ñù) ‚Ä¢ w ‚àà interior s) :
    (fun h : ‚Ñù => f (x + h ‚Ä¢ (2 ‚Ä¢ v + 2 ‚Ä¢ w)) + f (x + h ‚Ä¢ (v + w))
        - f (x + h ‚Ä¢ (2 ‚Ä¢ v + w)) - f (x + h ‚Ä¢ (v + 2 ‚Ä¢ w)) - h ^ 2 ‚Ä¢ f'' v w) =o[ùìù[>] 0]
      fun h => h ^ 2 := by
  have A : (1 : ‚Ñù) / 2 ‚àà Ioc (0 : ‚Ñù) 1 := ‚ü®by norm_num, by norm_num‚ü©
  have B : (1 : ‚Ñù) / 2 ‚àà Icc (0 : ‚Ñù) 1 := ‚ü®by norm_num, by norm_num‚ü©
  have h2v2w : x + (2 : ‚Ñù) ‚Ä¢ v + (2 : ‚Ñù) ‚Ä¢ w ‚àà interior s := by
    convert s_conv.interior.add_smul_sub_mem h4v h4w B using 1
    module
  have h2vww : x + (2 ‚Ä¢ v + w) + w ‚àà interior s := by
    convert h2v2w using 1
    module
  have h2v : x + (2 : ‚Ñù) ‚Ä¢ v ‚àà interior s := by
    convert s_conv.add_smul_sub_mem_interior xs h4v A using 1
    module
  have h2w : x + (2 : ‚Ñù) ‚Ä¢ w ‚àà interior s := by
    convert s_conv.add_smul_sub_mem_interior xs h4w A using 1
    module
  have hvw : x + (v + w) ‚àà interior s := by
    convert s_conv.add_smul_sub_mem_interior xs h2v2w A using 1
    module
  have h2vw : x + (2 ‚Ä¢ v + w) ‚àà interior s := by
    convert s_conv.interior.add_smul_sub_mem h2v h2v2w B using 1
    module
  have hvww : x + (v + w) + w ‚àà interior s := by
    convert s_conv.interior.add_smul_sub_mem h2w h2v2w B using 1
    module
  have TA1 := s_conv.taylor_approx_two_segment hf xs hx h2vw h2vww
  have TA2 := s_conv.taylor_approx_two_segment hf xs hx hvw hvww
  convert TA1.sub TA2 using 1
  ext h
  simp only [two_smul, smul_add, ‚Üê add_assoc, ContinuousLinearMap.map_add,
    ContinuousLinearMap.add_apply, Pi.smul_apply, ContinuousLinearMap.coe_smul',
    ContinuousLinearMap.map_smul]
  abel

/-- Assume that `f` is differentiable inside a convex set `s`, and that its derivative `f'` is
differentiable at a point `x`. Then, given two vectors `v` and `w` pointing inside `s`, one
has `f'' v w = f'' w v`. Superseded by `Convex.second_derivative_within_at_symmetric`, which
removes the assumption that `v` and `w` point inside `s`. -/
theorem Convex.second_derivative_within_at_symmetric_of_mem_interior {v w : E}
    (h4v : x + (4 : ‚Ñù) ‚Ä¢ v ‚àà interior s) (h4w : x + (4 : ‚Ñù) ‚Ä¢ w ‚àà interior s) :
    f'' w v = f'' v w := by
  have A : (fun h : ‚Ñù => h ^ 2 ‚Ä¢ (f'' w v - f'' v w)) =o[ùìù[>] 0] fun h => h ^ 2 := by
    convert (s_conv.isLittleO_alternate_sum_square hf xs hx h4v h4w).sub
      (s_conv.isLittleO_alternate_sum_square hf xs hx h4w h4v) using 1
    ext h
    simp only [add_comm, smul_add, smul_sub]
    abel
  have B : (fun _ : ‚Ñù => f'' w v - f'' v w) =o[ùìù[>] 0] fun _ => (1 : ‚Ñù) := by
    have : (fun h : ‚Ñù => 1 / h ^ 2) =O[ùìù[>] 0] fun h => 1 / h ^ 2 := isBigO_refl _ _
    have C := this.smul_isLittleO A
    apply C.congr' _ _
    ¬∑ filter_upwards [self_mem_nhdsWithin]
      intro h (hpos : 0 < h)
      match_scalars <;> field_simp
    ¬∑ filter_upwards [self_mem_nhdsWithin] with h (hpos : 0 < h)
      field_simp
  simpa only [sub_eq_zero] using isLittleO_const_const_iff.1 B

end

/-- If a function is differentiable inside a convex set with nonempty interior, and has a second
derivative at a point of this convex set, then this second derivative is symmetric. -/
theorem Convex.second_derivative_within_at_symmetric {s : Set E} (s_conv : Convex ‚Ñù s)
    (hne : (interior s).Nonempty) {f : E ‚Üí F} {f' : E ‚Üí E ‚ÜíL[‚Ñù] F} {f'' : E ‚ÜíL[‚Ñù] E ‚ÜíL[‚Ñù] F}
    (hf : ‚àÄ x ‚àà interior s, HasFDerivAt f (f' x) x) {x : E} (xs : x ‚àà s)
    (hx : HasFDerivWithinAt f' f'' (interior s) x) (v w : E) : f'' v w = f'' w v := by
  /- we work around a point `x + 4 z` in the interior of `s`. For any vector `m`,
    then `x + 4 (z + t m)` also belongs to the interior of `s` for small enough `t`. This means that
    we will be able to apply `second_derivative_within_at_symmetric_of_mem_interior` to show
    that `f''` is symmetric, after cancelling all the contributions due to `z`. -/
  rcases hne with ‚ü®y, hy‚ü©
  obtain ‚ü®z, hz‚ü© : ‚àÉ z, z = ((1 : ‚Ñù) / 4) ‚Ä¢ (y - x) := ‚ü®((1 : ‚Ñù) / 4) ‚Ä¢ (y - x), rfl‚ü©
  have A : ‚àÄ m : E, Filter.Tendsto (fun t : ‚Ñù => x + (4 : ‚Ñù) ‚Ä¢ (z + t ‚Ä¢ m)) (ùìù 0) (ùìù y) := by
    intro m
    have : x + (4 : ‚Ñù) ‚Ä¢ (z + (0 : ‚Ñù) ‚Ä¢ m) = y := by simp [hz]
    rw [‚Üê this]
    refine tendsto_const_nhds.add <| tendsto_const_nhds.smul <| tendsto_const_nhds.add ?_
    exact continuousAt_id.smul continuousAt_const
  have B : ‚àÄ m : E, ‚àÄ·∂† t in ùìù[>] (0 : ‚Ñù), x + (4 : ‚Ñù) ‚Ä¢ (z + t ‚Ä¢ m) ‚àà interior s := by
    intro m
    apply nhdsWithin_le_nhds
    apply A m
    rw [mem_interior_iff_mem_nhds] at hy
    exact interior_mem_nhds.2 hy
  -- we choose `t m > 0` such that `x + 4 (z + (t m) m)` belongs to the interior of `s`, for any
  -- vector `m`.
  choose t ts tpos using fun m => ((B m).and self_mem_nhdsWithin).exists
  -- applying `second_derivative_within_at_symmetric_of_mem_interior` to the vectors `z`
  -- and `z + (t m) m`, we deduce that `f'' m z = f'' z m` for all `m`.
  have C : ‚àÄ m : E, f'' m z = f'' z m := by
    intro m
    have : f'' (z + t m ‚Ä¢ m) (z + t 0 ‚Ä¢ (0 : E)) = f'' (z + t 0 ‚Ä¢ (0 : E)) (z + t m ‚Ä¢ m) :=
      s_conv.second_derivative_within_at_symmetric_of_mem_interior hf xs hx (ts 0) (ts m)
    simp only [ContinuousLinearMap.map_add, ContinuousLinearMap.map_smul, add_right_inj,
      ContinuousLinearMap.add_apply, Pi.smul_apply, ContinuousLinearMap.coe_smul', add_zero,
      ContinuousLinearMap.zero_apply, smul_zero, ContinuousLinearMap.map_zero] at this
    exact smul_right_injective F (tpos m).ne' this
  -- applying `second_derivative_within_at_symmetric_of_mem_interior` to the vectors `z + (t v) v`
  -- and `z + (t w) w`, we deduce that `f'' v w = f'' w v`. Cross terms involving `z` can be
  -- eliminated thanks to the fact proved above that `f'' m z = f'' z m`.
  have : f'' (z + t v ‚Ä¢ v) (z + t w ‚Ä¢ w) = f'' (z + t w ‚Ä¢ w) (z + t v ‚Ä¢ v) :=
    s_conv.second_derivative_within_at_symmetric_of_mem_interior hf xs hx (ts w) (ts v)
  simp only [ContinuousLinearMap.map_add, ContinuousLinearMap.map_smul, smul_add, smul_smul,
    ContinuousLinearMap.add_apply, Pi.smul_apply, ContinuousLinearMap.coe_smul', C] at this
  have : (t v * t w) ‚Ä¢ (f'' v) w = (t v * t w) ‚Ä¢ (f'' w) v := by
    linear_combination (norm := module) this
  apply smul_right_injective F _ this
  simp [(tpos v).ne', (tpos w).ne']

/-- If a function is differentiable around `x`, and has two derivatives at `x`, then the second
derivative is symmetric. Version over `‚Ñù`. See `second_derivative_symmetric_of_eventually` for a
version over `‚Ñù` or `‚ÑÇ`. -/
theorem second_derivative_symmetric_of_eventually_of_real {f : E ‚Üí F} {f' : E ‚Üí E ‚ÜíL[‚Ñù] F}
    {f'' : E ‚ÜíL[‚Ñù] E ‚ÜíL[‚Ñù] F} (hf : ‚àÄ·∂† y in ùìù x, HasFDerivAt f (f' y) y) (hx : HasFDerivAt f' f'' x)
    (v w : E) : f'' v w = f'' w v := by
  rcases Metric.mem_nhds_iff.1 hf with ‚ü®Œµ, Œµpos, hŒµ‚ü©
  have A : (interior (Metric.ball x Œµ)).Nonempty := by
    rwa [Metric.isOpen_ball.interior_eq, Metric.nonempty_ball]
  exact
    Convex.second_derivative_within_at_symmetric (convex_ball x Œµ) A
      (fun y hy => hŒµ (interior_subset hy)) (Metric.mem_ball_self Œµpos) hx.hasFDerivWithinAt v w

end Real

section IsRCLikeNormedField

variable {ùïú : Type*} [NontriviallyNormedField ùïú] [IsRCLikeNormedField ùïú]
  {E F : Type*} [NormedAddCommGroup E] [NormedSpace ùïú E] [NormedAddCommGroup F]
  [NormedSpace ùïú F] {s : Set E} {f : E ‚Üí F} {x : E}

theorem second_derivative_symmetric_of_eventually {f' : E ‚Üí E ‚ÜíL[ùïú] F} {x : E}
    {f'' : E ‚ÜíL[ùïú] E ‚ÜíL[ùïú] F} (hf : ‚àÄ·∂† y in ùìù x, HasFDerivAt f (f' y) y)
    (hx : HasFDerivAt f' f'' x) (v w : E) : f'' v w = f'' w v := by
  let _ := IsRCLikeNormedField.rclike ùïú
  let _ : NormedSpace ‚Ñù E := NormedSpace.restrictScalars ‚Ñù ùïú E
  let _ : NormedSpace ‚Ñù F := NormedSpace.restrictScalars ‚Ñù ùïú F
  let _ : LinearMap.CompatibleSMul E F ‚Ñù ùïú := LinearMap.IsScalarTower.compatibleSMul
  let _ : LinearMap.CompatibleSMul E (E ‚ÜíL[ùïú] F) ‚Ñù ùïú := LinearMap.IsScalarTower.compatibleSMul
  let f'R : E ‚Üí E ‚ÜíL[‚Ñù] F := fun x ‚Ü¶ (f' x).restrictScalars ‚Ñù
  have hfR : ‚àÄ·∂† y in ùìù x, HasFDerivAt f (f'R y) y := by
    filter_upwards [hf] with y hy using HasFDerivAt.restrictScalars ‚Ñù hy
  let f''Rl : E ‚Üí‚Çó[‚Ñù] E ‚Üí‚Çó[‚Ñù] F :=
  { toFun := fun x ‚Ü¶
      { toFun := fun y ‚Ü¶ f'' x y
        map_add' := by simp
        map_smul' := by simp }
    map_add' := by intros; ext; simp
    map_smul' := by intros; ext; simp }
  let f''R : E ‚ÜíL[‚Ñù] E ‚ÜíL[‚Ñù] F := by
    refine LinearMap.mkContinuous‚ÇÇ f''Rl (‚Äñf''‚Äñ) (fun x y ‚Ü¶ ?_)
    simp only [LinearMap.coe_mk, AddHom.coe_mk, f''Rl]
    exact ContinuousLinearMap.le_opNorm‚ÇÇ f'' x y
  have : HasFDerivAt f'R f''R x := by
    simp only [hasFDerivAt_iff_tendsto] at hx ‚ä¢
    exact hx
  change f''R v w = f''R w v
  exact second_derivative_symmetric_of_eventually_of_real hfR this v w

/-- If a function is differentiable, and has two derivatives at `x`, then the second
derivative is symmetric. -/
theorem second_derivative_symmetric {f' : E ‚Üí E ‚ÜíL[ùïú] F} {f'' : E ‚ÜíL[ùïú] E ‚ÜíL[ùïú] F} {x : E}
    (hf : ‚àÄ y, HasFDerivAt f (f' y) y) (hx : HasFDerivAt f' f'' x) (v w : E) : f'' v w = f'' w v :=
  second_derivative_symmetric_of_eventually (Filter.Eventually.of_forall hf) hx v w

/-- If a function is `C^2` at a point, then its second derivative there is symmetric. -/
theorem ContDiffAt.isSymmSndFDerivAt {n : WithTop ‚Ñï‚àû} (hf : ContDiffAt ùïú n f x) (hn : 2 ‚â§ n) :
    IsSymmSndFDerivAt ùïú f x := by
  intro v w
  apply second_derivative_symmetric_of_eventually (f := f) (f' := fderiv ùïú f) (x := x)
  ¬∑ obtain ‚ü®u, hu, h'u‚ü© : ‚àÉ u ‚àà ùìù x, ContDiffOn ùïú 2 f u :=
      (hf.of_le hn).contDiffOn (m := 2) le_rfl (by simp)
    rcases mem_nhds_iff.1 hu with ‚ü®v, vu, v_open, xv‚ü©
    filter_upwards [v_open.mem_nhds xv] with y hy
    have : DifferentiableAt ùïú f y := by
      have := (h'u.mono vu y hy).contDiffAt (v_open.mem_nhds hy)
      exact this.differentiableAt one_le_two
    exact DifferentiableAt.hasFDerivAt this
  ¬∑ have : DifferentiableAt ùïú (fderiv ùïú f) x := by
      apply ContDiffAt.differentiableAt _ le_rfl
      exact hf.fderiv_right hn
    exact DifferentiableAt.hasFDerivAt this

/-- If a function is `C^2` within a set at a point, and accumulated by points in the interior
of the set, then its second derivative there is symmetric. -/
theorem ContDiffWithinAt.isSymmSndFDerivWithinAt {n : WithTop ‚Ñï‚àû} (hf : ContDiffWithinAt ùïú n f s x)
    (hn : 2 ‚â§ n) (hs : UniqueDiffOn ùïú s) (hx : x ‚àà closure (interior s)) (h'x : x ‚àà s) :
    IsSymmSndFDerivWithinAt ùïú f s x := by
  /- We argue that, at interior points, the second derivative is symmetric, and moreover by
  continuity it converges to the second derivative at `x`. Therefore, the latter is also
  symmetric. -/
  rcases (hf.of_le hn).contDiffOn' le_rfl (by simp) with ‚ü®u, u_open, xu, hu‚ü©
  simp only [insert_eq_of_mem h'x] at hu
  have h'u : UniqueDiffOn ùïú (s ‚à© u) := hs.inter u_open
  obtain ‚ü®y, hy, y_lim‚ü© : ‚àÉ y, (‚àÄ (n : ‚Ñï), y n ‚àà interior s) ‚àß Tendsto y atTop (ùìù x) :=
    mem_closure_iff_seq_limit.1 hx
  have L : ‚àÄ·∂† k in atTop, y k ‚àà u := y_lim (u_open.mem_nhds xu)
  have I : ‚àÄ·∂† k in atTop, IsSymmSndFDerivWithinAt ùïú f s (y k) := by
    filter_upwards [L] with k hk
    have s_mem : s ‚àà ùìù (y k) := by
      apply mem_of_superset (isOpen_interior.mem_nhds (hy k))
      exact interior_subset
    have : IsSymmSndFDerivAt ùïú f (y k) := by
      apply ContDiffAt.isSymmSndFDerivAt _ le_rfl
      apply (hu (y k) ‚ü®(interior_subset (hy k)), hk‚ü©).contDiffAt
      exact inter_mem s_mem (u_open.mem_nhds hk)
    intro v w
    rw [fderivWithin_fderivWithin_eq_of_mem_nhds s_mem]
    exact this v w
  have A : ContinuousOn (fderivWithin ùïú (fderivWithin ùïú f s) s) (s ‚à© u) := by
    have : ContinuousOn (fderivWithin ùïú (fderivWithin ùïú f (s ‚à© u)) (s ‚à© u)) (s ‚à© u) :=
      ((hu.fderivWithin h'u (m := 1) le_rfl).fderivWithin h'u (m := 0) le_rfl).continuousOn
    apply this.congr
    intro y hy
    apply fderivWithin_fderivWithin_eq_of_eventuallyEq
    filter_upwards [u_open.mem_nhds hy.2] with z hz
    change (z ‚àà s) = (z ‚àà s ‚à© u)
    aesop
  have B : Tendsto (fun k ‚Ü¶ fderivWithin ùïú (fderivWithin ùïú f s) s (y k)) atTop
      (ùìù (fderivWithin ùïú (fderivWithin ùïú f s) s x)) := by
    have : Tendsto y atTop (ùìù[s ‚à© u] x) := by
      apply tendsto_nhdsWithin_iff.2 ‚ü®y_lim, ?_‚ü©
      filter_upwards [L] with k hk using ‚ü®interior_subset (hy k), hk‚ü©
    exact (A x ‚ü®h'x, xu‚ü© ).tendsto.comp this
  have C (v w : E) : Tendsto (fun k ‚Ü¶ fderivWithin ùïú (fderivWithin ùïú f s) s (y k) v w) atTop
      (ùìù (fderivWithin ùïú (fderivWithin ùïú f s) s x v w)) := by
    have : Continuous (fun (A : E ‚ÜíL[ùïú] E ‚ÜíL[ùïú] F) ‚Ü¶ A v w) := by fun_prop
    exact (this.tendsto _).comp B
  have C' (v w : E) : Tendsto (fun k ‚Ü¶ fderivWithin ùïú (fderivWithin ùïú f s) s (y k) w v) atTop
      (ùìù (fderivWithin ùïú (fderivWithin ùïú f s) s x v w)) := by
    apply (C v w).congr'
    filter_upwards [I] with k hk using hk v w
  intro v w
  exact tendsto_nhds_unique (C v w) (C' w v)

end IsRCLikeNormedField
