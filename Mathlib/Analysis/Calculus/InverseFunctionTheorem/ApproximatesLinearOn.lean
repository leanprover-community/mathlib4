/-
Copyright (c) 2020 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov, S√©bastien Gou√´zel
-/
import Mathlib.Analysis.NormedSpace.Banach
import Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace
import Mathlib.Topology.PartialHomeomorph

#align_import analysis.calculus.inverse from "leanprover-community/mathlib"@"2c1d8ca2812b64f88992a5294ea3dba144755cd1"
/-!
# Non-linear maps close to affine maps

In this file we study a map `f` such that `‚Äñf x - f y - f' (x - y)‚Äñ ‚â§ c * ‚Äñx - y‚Äñ` on an open set
`s`, where `f' : E ‚ÜíL[ùïú] F` is a continuous linear map and `c` is suitably small. Maps of this type
behave like `f a + f' (x - a)` near each `a ‚àà s`.

When `f'` is onto, we show that `f` is locally onto.

When `f'` is a continuous linear equiv, we show that `f` is a homeomorphism
between `s` and `f '' s`. More precisely, we define `ApproximatesLinearOn.toPartialHomeomorph` to
be a `PartialHomeomorph` with `toFun = f`, `source = s`, and `target = f '' s`.
between `s` and `f '' s`. More precisely, we define `ApproximatesLinearOn.toPartialHomeomorph` to
be a `PartialHomeomorph` with `toFun = f`, `source = s`, and `target = f '' s`.

Maps of this type naturally appear in the proof of the inverse function theorem (see next section),
and `ApproximatesLinearOn.toPartialHomeomorph` will imply that the locally inverse function
and `ApproximatesLinearOn.toPartialHomeomorph` will imply that the locally inverse function
exists.

We define this auxiliary notion to split the proof of the inverse function theorem into small
lemmas. This approach makes it possible

- to prove a lower estimate on the size of the domain of the inverse function;

- to reuse parts of the proofs in the case if a function is not strictly differentiable. E.g., for a
  function `f : E √ó F ‚Üí G` with estimates on `f x y‚ÇÅ - f x y‚ÇÇ` but not on `f x‚ÇÅ y - f x‚ÇÇ y`.

## Notations

We introduce some `local notation` to make formulas shorter:

* by `N` we denote `‚Äñf'‚Åª¬π‚Äñ`;
* by `g` we denote the auxiliary contracting map `x ‚Ü¶ x + f'.symm (y - f x)` used to prove that
  `{x | f x = y}` is nonempty.
-/

open Function Set Filter Metric

open scoped Topology Classical NNReal

noncomputable section

variable {ùïú : Type*} [NontriviallyNormedField ùïú]
variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ùïú E]
variable {F : Type*} [NormedAddCommGroup F] [NormedSpace ùïú F]
variable {G : Type*} [NormedAddCommGroup G] [NormedSpace ùïú G]
variable {G' : Type*} [NormedAddCommGroup G'] [NormedSpace ùïú G']
variable {Œµ : ‚Ñù}

open Filter Metric Set

open ContinuousLinearMap (id)

/-- We say that `f` approximates a continuous linear map `f'` on `s` with constant `c`,
if `‚Äñf x - f y - f' (x - y)‚Äñ ‚â§ c * ‚Äñx - y‚Äñ` whenever `x, y ‚àà s`.

This predicate is defined to facilitate the splitting of the inverse function theorem into small
lemmas. Some of these lemmas can be useful, e.g., to prove that the inverse function is defined
on a specific set. -/
def ApproximatesLinearOn (f : E ‚Üí F) (f' : E ‚ÜíL[ùïú] F) (s : Set E) (c : ‚Ñù‚â•0) : Prop :=
  ‚àÄ x ‚àà s, ‚àÄ y ‚àà s, ‚Äñf x - f y - f' (x - y)‚Äñ ‚â§ c * ‚Äñx - y‚Äñ
#align approximates_linear_on ApproximatesLinearOn

@[simp]
theorem approximatesLinearOn_empty (f : E ‚Üí F) (f' : E ‚ÜíL[ùïú] F) (c : ‚Ñù‚â•0) :
    ApproximatesLinearOn f f' ‚àÖ c := by simp [ApproximatesLinearOn]
#align approximates_linear_on_empty approximatesLinearOn_empty

namespace ApproximatesLinearOn

variable [CompleteSpace E] {f : E ‚Üí F}

/-! First we prove some properties of a function that `ApproximatesLinearOn` a (not necessarily
invertible) continuous linear map. -/


section

variable {f' : E ‚ÜíL[ùïú] F} {s t : Set E} {c c' : ‚Ñù‚â•0}

theorem mono_num (hc : c ‚â§ c') (hf : ApproximatesLinearOn f f' s c) :
    ApproximatesLinearOn f f' s c' := fun x hx y hy =>
  le_trans (hf x hx y hy) (mul_le_mul_of_nonneg_right hc <| norm_nonneg _)
#align approximates_linear_on.mono_num ApproximatesLinearOn.mono_num

theorem mono_set (hst : s ‚äÜ t) (hf : ApproximatesLinearOn f f' t c) :
    ApproximatesLinearOn f f' s c := fun x hx y hy => hf x (hst hx) y (hst hy)
#align approximates_linear_on.mono_set ApproximatesLinearOn.mono_set

theorem approximatesLinearOn_iff_lipschitzOnWith {f : E ‚Üí F} {f' : E ‚ÜíL[ùïú] F} {s : Set E}
    {c : ‚Ñù‚â•0} : ApproximatesLinearOn f f' s c ‚Üî LipschitzOnWith c (f - ‚áëf') s := by
  have : ‚àÄ x y, f x - f y - f' (x - y) = (f - f') x - (f - f') y := fun x y ‚Ü¶ by
    simp only [map_sub, Pi.sub_apply]; abel
  simp only [this, lipschitzOnWith_iff_norm_sub_le, ApproximatesLinearOn]
#align approximates_linear_on.approximates_linear_on_iff_lipschitz_on_with ApproximatesLinearOn.approximatesLinearOn_iff_lipschitzOnWith

alias ‚ü®lipschitzOnWith, _root_.LipschitzOnWith.approximatesLinearOn‚ü© :=
  approximatesLinearOn_iff_lipschitzOnWith
#align approximates_linear_on.lipschitz_on_with ApproximatesLinearOn.lipschitzOnWith
#align lipschitz_on_with.approximates_linear_on LipschitzOnWith.approximatesLinearOn

theorem lipschitz_sub (hf : ApproximatesLinearOn f f' s c) :
    LipschitzWith c fun x : s => f x - f' x :=
  hf.lipschitzOnWith.to_restrict
#align approximates_linear_on.lipschitz_sub ApproximatesLinearOn.lipschitz_sub

protected theorem lipschitz (hf : ApproximatesLinearOn f f' s c) :
    LipschitzWith (‚Äñf'‚Äñ‚Çä + c) (s.restrict f) := by
  simpa only [restrict_apply, add_sub_cancel] using
    (f'.lipschitz.restrict s).add hf.lipschitz_sub
#align approximates_linear_on.lipschitz ApproximatesLinearOn.lipschitz

protected theorem continuous (hf : ApproximatesLinearOn f f' s c) : Continuous (s.restrict f) :=
  hf.lipschitz.continuous
#align approximates_linear_on.continuous ApproximatesLinearOn.continuous

protected theorem continuousOn (hf : ApproximatesLinearOn f f' s c) : ContinuousOn f s :=
  continuousOn_iff_continuous_restrict.2 hf.continuous
#align approximates_linear_on.continuous_on ApproximatesLinearOn.continuousOn

end

section LocallyOnto

/-!
We prove that a function which is linearly approximated by a continuous linear map with a nonlinear
right inverse is locally onto. This will apply to the case where the approximating map is a linear
equivalence, for the local inverse theorem, but also whenever the approximating map is onto,
by Banach's open mapping theorem. -/


variable {s : Set E} {c : ‚Ñù‚â•0} {f' : E ‚ÜíL[ùïú] F}

/-- If a function is linearly approximated by a continuous linear map with a (possibly nonlinear)
right inverse, then it is locally onto: a ball of an explicit radius is included in the image
of the map. -/
theorem surjOn_closedBall_of_nonlinearRightInverse (hf : ApproximatesLinearOn f f' s c)
    (f'symm : f'.NonlinearRightInverse) {Œµ : ‚Ñù} {b : E} (Œµ0 : 0 ‚â§ Œµ) (hŒµ : closedBall b Œµ ‚äÜ s) :
    SurjOn f (closedBall b Œµ) (closedBall (f b) (((f'symm.nnnorm : ‚Ñù)‚Åª¬π - c) * Œµ)) := by
  intro y hy
  rcases le_or_lt (f'symm.nnnorm : ‚Ñù)‚Åª¬π c with hc | hc
  ¬∑ refine' ‚ü®b, by simp [Œµ0], _‚ü©
    have : dist y (f b) ‚â§ 0 :=
      (mem_closedBall.1 hy).trans (mul_nonpos_of_nonpos_of_nonneg (by linarith) Œµ0)
    simp only [dist_le_zero] at this
    rw [this]
  have If' : (0 : ‚Ñù) < f'symm.nnnorm := by rw [‚Üê inv_pos]; exact (NNReal.coe_nonneg _).trans_lt hc
  have Icf' : (c : ‚Ñù) * f'symm.nnnorm < 1 := by rwa [inv_eq_one_div, lt_div_iff If'] at hc
  have Jf' : (f'symm.nnnorm : ‚Ñù) ‚â† 0 := ne_of_gt If'
  have Jcf' : (1 : ‚Ñù) - c * f'symm.nnnorm ‚â† 0 := by apply ne_of_gt; linarith
  /- We have to show that `y` can be written as `f x` for some `x ‚àà closedBall b Œµ`.
    The idea of the proof is to apply the Banach contraction principle to the map
    `g : x ‚Ü¶ x + f'symm (y - f x)`, as a fixed point of this map satisfies `f x = y`.
    When `f'symm` is a genuine linear inverse, `g` is a contracting map. In our case, since `f'symm`
    is nonlinear, this map is not contracting (it is not even continuous), but still the proof of
    the contraction theorem holds: `u‚Çô = g‚Åø b` is a Cauchy sequence, converging exponentially fast
    to the desired point `x`. Instead of appealing to general results, we check this by hand.

    The main point is that `f (u n)` becomes exponentially close to `y`, and therefore
    `dist (u (n+1)) (u n)` becomes exponentally small, making it possible to get an inductive
    bound on `dist (u n) b`, from which one checks that `u n` stays in the ball on which one has a
    control. Therefore, the bound can be checked at the next step, and so on inductively.
    -/
  set g := fun x => x + f'symm (y - f x) with hg
  set u := fun n : ‚Ñï => g^[n] b with hu
  have usucc : ‚àÄ n, u (n + 1) = g (u n) := by simp [hu, ‚Üê iterate_succ_apply' g _ b]
  -- First bound: if `f z` is close to `y`, then `g z` is close to `z` (i.e., almost a fixed point).
  have A : ‚àÄ z, dist (g z) z ‚â§ f'symm.nnnorm * dist (f z) y := by
    intro z
    rw [dist_eq_norm, hg, add_sub_cancel_left, dist_eq_norm']
    exact f'symm.bound _
  -- Second bound: if `z` and `g z` are in the set with good control, then `f (g z)` becomes closer
  -- to `y` than `f z` was (this uses the linear approximation property, and is the reason for the
  -- choice of the formula for `g`).
  have B :
    ‚àÄ z ‚àà closedBall b Œµ,
      g z ‚àà closedBall b Œµ ‚Üí dist (f (g z)) y ‚â§ c * f'symm.nnnorm * dist (f z) y := by
    intro z hz hgz
    set v := f'symm (y - f z)
    calc
      dist (f (g z)) y = ‚Äñf (z + v) - y‚Äñ := by rw [dist_eq_norm]
      _ = ‚Äñf (z + v) - f z - f' v + f' v - (y - f z)‚Äñ := by congr 1; abel
      _ = ‚Äñf (z + v) - f z - f' (z + v - z)‚Äñ := by
        simp only [v, ContinuousLinearMap.NonlinearRightInverse.right_inv, add_sub_cancel_left,
          sub_add_cancel]
      _ ‚â§ c * ‚Äñz + v - z‚Äñ := hf _ (hŒµ hgz) _ (hŒµ hz)
      _ ‚â§ c * (f'symm.nnnorm * dist (f z) y) := by
        gcongr
        simpa [dist_eq_norm'] using f'symm.bound (y - f z)
      _ = c * f'symm.nnnorm * dist (f z) y := by ring
  -- Third bound: a complicated bound on `dist w b` (that will show up in the induction) is enough
  -- to check that `w` is in the ball on which one has controls. Will be used to check that `u n`
  -- belongs to this ball for all `n`.
  have C : ‚àÄ (n : ‚Ñï) (w : E), dist w b ‚â§ f'symm.nnnorm * (1 - ((c : ‚Ñù) * f'symm.nnnorm) ^ n) /
      (1 - c * f'symm.nnnorm) * dist (f b) y ‚Üí w ‚àà closedBall b Œµ := fun n w hw ‚Ü¶ by
    apply hw.trans
    rw [div_mul_eq_mul_div, div_le_iff]; swap; ¬∑ linarith
    calc
      (f'symm.nnnorm : ‚Ñù) * (1 - ((c : ‚Ñù) * f'symm.nnnorm) ^ n) * dist (f b) y =
          f'symm.nnnorm * dist (f b) y * (1 - ((c : ‚Ñù) * f'symm.nnnorm) ^ n) :=
        by ring
      _ ‚â§ f'symm.nnnorm * dist (f b) y * 1 := by
        gcongr
        rw [sub_le_self_iff]
        positivity
      _ ‚â§ f'symm.nnnorm * (((f'symm.nnnorm : ‚Ñù)‚Åª¬π - c) * Œµ) := by
        rw [mul_one]
        gcongr
        exact mem_closedBall'.1 hy
      _ = Œµ * (1 - c * f'symm.nnnorm) := by field_simp; ring

  /- Main inductive control: `f (u n)` becomes exponentially close to `y`, and therefore
    `dist (u (n+1)) (u n)` becomes exponentally small, making it possible to get an inductive
    bound on `dist (u n) b`, from which one checks that `u n` remains in the ball on which we
    have estimates. -/
  have D : ‚àÄ n : ‚Ñï, dist (f (u n)) y ‚â§ ((c : ‚Ñù) * f'symm.nnnorm) ^ n * dist (f b) y ‚àß
      dist (u n) b ‚â§ f'symm.nnnorm * (1 - ((c : ‚Ñù) * f'symm.nnnorm) ^ n) /
        (1 - (c : ‚Ñù) * f'symm.nnnorm) * dist (f b) y := fun n ‚Ü¶ by
    induction' n with n IH; ¬∑ simp [hu, le_refl]
    rw [usucc]
    have Ign : dist (g (u n)) b ‚â§ f'symm.nnnorm * (1 - ((c : ‚Ñù) * f'symm.nnnorm) ^ n.succ) /
        (1 - c * f'symm.nnnorm) * dist (f b) y :=
      calc
        dist (g (u n)) b ‚â§ dist (g (u n)) (u n) + dist (u n) b := dist_triangle _ _ _
        _ ‚â§ f'symm.nnnorm * dist (f (u n)) y + dist (u n) b := add_le_add (A _) le_rfl
        _ ‚â§ f'symm.nnnorm * (((c : ‚Ñù) * f'symm.nnnorm) ^ n * dist (f b) y) +
              f'symm.nnnorm * (1 - ((c : ‚Ñù) * f'symm.nnnorm) ^ n) / (1 - c * f'symm.nnnorm) *
                dist (f b) y := by
                  gcongr
                  ¬∑ exact IH.1
                  ¬∑ exact IH.2
        _ = f'symm.nnnorm * (1 - ((c : ‚Ñù) * f'symm.nnnorm) ^ n.succ) /
              (1 - (c : ‚Ñù) * f'symm.nnnorm) * dist (f b) y := by
          field_simp [Jcf', pow_succ]; ring
    refine' ‚ü®_, Ign‚ü©
    calc
      dist (f (g (u n))) y ‚â§ c * f'symm.nnnorm * dist (f (u n)) y :=
        B _ (C n _ IH.2) (C n.succ _ Ign)
      _ ‚â§ (c : ‚Ñù) * f'symm.nnnorm * (((c : ‚Ñù) * f'symm.nnnorm) ^ n * dist (f b) y) := by
        gcongr
        apply IH.1
      _ = ((c : ‚Ñù) * f'symm.nnnorm) ^ n.succ * dist (f b) y := by simp only [pow_succ']; ring
  -- Deduce from the inductive bound that `u‚Çô` is a Cauchy sequence, therefore converging.
  have : CauchySeq u := by
    refine cauchySeq_of_le_geometric _ (‚Üëf'symm.nnnorm * dist (f b) y) Icf' fun n ‚Ü¶ ?_
    calc
      dist (u n) (u (n + 1)) = dist (g (u n)) (u n) := by rw [usucc, dist_comm]
      _ ‚â§ f'symm.nnnorm * dist (f (u n)) y := A _
      _ ‚â§ f'symm.nnnorm * (((c : ‚Ñù) * f'symm.nnnorm) ^ n * dist (f b) y) := by
        gcongr
        exact (D n).1
      _ = f'symm.nnnorm * dist (f b) y * ((c : ‚Ñù) * f'symm.nnnorm) ^ n := by ring
  obtain ‚ü®x, hx‚ü© : ‚àÉ x, Tendsto u atTop (ùìù x) := cauchySeq_tendsto_of_complete this
  -- As all the `u‚Çô` belong to the ball `closedBall b Œµ`, so does their limit `x`.
  have xmem : x ‚àà closedBall b Œµ :=
    isClosed_ball.mem_of_tendsto hx (eventually_of_forall fun n => C n _ (D n).2)
  refine' ‚ü®x, xmem, _‚ü©
  -- It remains to check that `f x = y`. This follows from continuity of `f` on `closedBall b Œµ`
  -- and from the fact that `f u‚Çô` is converging to `y` by construction.
  have hx' : Tendsto u atTop (ùìù[closedBall b Œµ] x) := by
    simp only [nhdsWithin, tendsto_inf, hx, true_and_iff, ge_iff_le, tendsto_principal]
    exact eventually_of_forall fun n => C n _ (D n).2
  have T1 : Tendsto (f ‚àò u) atTop (ùìù (f x)) :=
    (hf.continuousOn.mono hŒµ x xmem).tendsto.comp hx'
  have T2 : Tendsto (f ‚àò u) atTop (ùìù y) := by
    rw [tendsto_iff_dist_tendsto_zero]
    refine' squeeze_zero (fun _ => dist_nonneg) (fun n => (D n).1) _
    simpa using (tendsto_pow_atTop_nhds_zero_of_lt_one (by positivity) Icf').mul tendsto_const_nhds
  exact tendsto_nhds_unique T1 T2
#align approximates_linear_on.surj_on_closed_ball_of_nonlinear_right_inverse ApproximatesLinearOn.surjOn_closedBall_of_nonlinearRightInverse

theorem open_image (hf : ApproximatesLinearOn f f' s c) (f'symm : f'.NonlinearRightInverse)
    (hs : IsOpen s) (hc : Subsingleton F ‚à® c < f'symm.nnnorm‚Åª¬π) : IsOpen (f '' s) := by
  cases' hc with hE hc
  ¬∑ exact isOpen_discrete _
  simp only [isOpen_iff_mem_nhds, nhds_basis_closedBall.mem_iff, forall_mem_image] at hs ‚ä¢
  intro x hx
  rcases hs x hx with ‚ü®Œµ, Œµ0, hŒµ‚ü©
  refine' ‚ü®(f'symm.nnnorm‚Åª¬π - c) * Œµ, mul_pos (sub_pos.2 hc) Œµ0, _‚ü©
  exact (hf.surjOn_closedBall_of_nonlinearRightInverse f'symm (le_of_lt Œµ0) hŒµ).mono hŒµ Subset.rfl
#align approximates_linear_on.open_image ApproximatesLinearOn.open_image

theorem image_mem_nhds (hf : ApproximatesLinearOn f f' s c) (f'symm : f'.NonlinearRightInverse)
    {x : E} (hs : s ‚àà ùìù x) (hc : Subsingleton F ‚à® c < f'symm.nnnorm‚Åª¬π) : f '' s ‚àà ùìù (f x) := by
  obtain ‚ü®t, hts, ht, xt‚ü© : ‚àÉ t, t ‚äÜ s ‚àß IsOpen t ‚àß x ‚àà t := _root_.mem_nhds_iff.1 hs
  have := IsOpen.mem_nhds ((hf.mono_set hts).open_image f'symm ht hc) (mem_image_of_mem _ xt)
  exact mem_of_superset this (image_subset _ hts)
#align approximates_linear_on.image_mem_nhds ApproximatesLinearOn.image_mem_nhds

theorem map_nhds_eq (hf : ApproximatesLinearOn f f' s c) (f'symm : f'.NonlinearRightInverse) {x : E}
    (hs : s ‚àà ùìù x) (hc : Subsingleton F ‚à® c < f'symm.nnnorm‚Åª¬π) : map f (ùìù x) = ùìù (f x) := by
  refine'
    le_antisymm ((hf.continuousOn x (mem_of_mem_nhds hs)).continuousAt hs) (le_map fun t ht => _)
  have : f '' (s ‚à© t) ‚àà ùìù (f x) :=
    (hf.mono_set (inter_subset_left s t)).image_mem_nhds f'symm (inter_mem hs ht) hc
  exact mem_of_superset this (image_subset _ (inter_subset_right _ _))
#align approximates_linear_on.map_nhds_eq ApproximatesLinearOn.map_nhds_eq

end LocallyOnto

/-!
From now on we assume that `f` approximates an invertible continuous linear map `f : E ‚âÉL[ùïú] F`.

We also assume that either `E = {0}`, or `c < ‚Äñf'‚Åª¬π‚Äñ‚Åª¬π`. We use `N` as an abbreviation for `‚Äñf'‚Åª¬π‚Äñ`.
-/


variable {f' : E ‚âÉL[ùïú] F} {s : Set E} {c : ‚Ñù‚â•0}

local notation "N" => ‚Äñ(f'.symm : F ‚ÜíL[ùïú] E)‚Äñ‚Çä

protected theorem antilipschitz (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) s c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) : AntilipschitzWith (N‚Åª¬π - c)‚Åª¬π (s.restrict f) := by
  cases' hc with hE hc
  ¬∑ exact AntilipschitzWith.of_subsingleton
  convert (f'.antilipschitz.restrict s).add_lipschitzWith hf.lipschitz_sub hc
  simp [restrict]
#align approximates_linear_on.antilipschitz ApproximatesLinearOn.antilipschitz

protected theorem injective (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) s c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) : Injective (s.restrict f) :=
  (hf.antilipschitz hc).injective
#align approximates_linear_on.injective ApproximatesLinearOn.injective

protected theorem injOn (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) s c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) : InjOn f s :=
  injOn_iff_injective.2 <| hf.injective hc
#align approximates_linear_on.inj_on ApproximatesLinearOn.injOn

protected theorem surjective [CompleteSpace E] (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) univ c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) : Surjective f := by
  cases' hc with hE hc
  ¬∑ haveI : Subsingleton F := (Equiv.subsingleton_congr f'.toEquiv).1 hE
    exact surjective_to_subsingleton _
  ¬∑ apply forall_of_forall_mem_closedBall (fun y : F => ‚àÉ a, f a = y) (f 0) _
    have hc' : (0 : ‚Ñù) < N‚Åª¬π - c := by rw [sub_pos]; exact hc
    let p : ‚Ñù ‚Üí Prop := fun R => closedBall (f 0) R ‚äÜ Set.range f
    have hp : ‚àÄ·∂† r : ‚Ñù in atTop, p ((N‚Åª¬π - c) * r) := by
      have hr : ‚àÄ·∂† r : ‚Ñù in atTop, 0 ‚â§ r := eventually_ge_atTop 0
      refine' hr.mono fun r hr => Subset.trans _ (image_subset_range f (closedBall 0 r))
      refine' hf.surjOn_closedBall_of_nonlinearRightInverse f'.toNonlinearRightInverse hr _
      exact subset_univ _
    refine' ((tendsto_id.const_mul_atTop hc').frequently hp.frequently).mono _
    exact fun R h y hy => h hy
#align approximates_linear_on.surjective ApproximatesLinearOn.surjective

/-- A map approximating a linear equivalence on a set defines a partial equivalence on this set.
Should not be used outside of this file, because it is superseded by `toPartialHomeomorph` below.

This is a first step towards the inverse function. -/
def toPartialEquiv (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) s c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) : PartialEquiv E F :=
  (hf.injOn hc).toPartialEquiv _ _
#align approximates_linear_on.to_local_equiv ApproximatesLinearOn.toPartialEquiv

/-- The inverse function is continuous on `f '' s`.
Use properties of `PartialHomeomorph` instead. -/
theorem inverse_continuousOn (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) s c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) : ContinuousOn (hf.toPartialEquiv hc).symm (f '' s) := by
  apply continuousOn_iff_continuous_restrict.2
  refine' ((hf.antilipschitz hc).to_rightInvOn' _ (hf.toPartialEquiv hc).right_inv').continuous
  exact fun x hx => (hf.toPartialEquiv hc).map_target hx
#align approximates_linear_on.inverse_continuous_on ApproximatesLinearOn.inverse_continuousOn

/-- The inverse function is approximated linearly on `f '' s` by `f'.symm`. -/
theorem to_inv (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) s c) (hc : Subsingleton E ‚à® c < N‚Åª¬π) :
    ApproximatesLinearOn (hf.toPartialEquiv hc).symm (f'.symm : F ‚ÜíL[ùïú] E) (f '' s)
      (N * (N‚Åª¬π - c)‚Åª¬π * c) := fun x hx y hy ‚Ü¶ by
  set A := hf.toPartialEquiv hc
  have Af : ‚àÄ z, A z = f z := fun z => rfl
  rcases (mem_image _ _ _).1 hx with ‚ü®x', x's, rfl‚ü©
  rcases (mem_image _ _ _).1 hy with ‚ü®y', y's, rfl‚ü©
  rw [‚Üê Af x', ‚Üê Af y', A.left_inv x's, A.left_inv y's]
  calc
    ‚Äñx' - y' - f'.symm (A x' - A y')‚Äñ ‚â§ N * ‚Äñf' (x' - y' - f'.symm (A x' - A y'))‚Äñ :=
      (f' : E ‚ÜíL[ùïú] F).bound_of_antilipschitz f'.antilipschitz _
    _ = N * ‚ÄñA y' - A x' - f' (y' - x')‚Äñ := by
      congr 2
      simp only [ContinuousLinearEquiv.apply_symm_apply, ContinuousLinearEquiv.map_sub]
      abel
    _ ‚â§ N * (c * ‚Äñy' - x'‚Äñ) := mul_le_mul_of_nonneg_left (hf _ y's _ x's) (NNReal.coe_nonneg _)
    _ ‚â§ N * (c * (((N‚Åª¬π - c)‚Åª¬π : ‚Ñù‚â•0) * ‚ÄñA y' - A x'‚Äñ)) := by
      gcongr
      rw [‚Üê dist_eq_norm, ‚Üê dist_eq_norm]
      exact (hf.antilipschitz hc).le_mul_dist ‚ü®y', y's‚ü© ‚ü®x', x's‚ü©
    _ = (N * (N‚Åª¬π - c)‚Åª¬π * c : ‚Ñù‚â•0) * ‚ÄñA x' - A y'‚Äñ := by
      simp only [norm_sub_rev, NNReal.coe_mul]; ring
#align approximates_linear_on.to_inv ApproximatesLinearOn.to_inv

section

variable (f s)

/-- Given a function `f` that approximates a linear equivalence on an open set `s`,
returns a partial homeomorphism with `toFun = f` and `source = s`. -/
def toPartialHomeomorph (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) s c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) (hs : IsOpen s) : PartialHomeomorph E F where
  toPartialEquiv := hf.toPartialEquiv hc
  open_source := hs
  open_target := hf.open_image f'.toNonlinearRightInverse hs <| by
    rwa [f'.toEquiv.subsingleton_congr] at hc
  continuousOn_toFun := hf.continuousOn
  continuousOn_invFun := hf.inverse_continuousOn hc
#align approximates_linear_on.to_local_homeomorph ApproximatesLinearOn.toPartialHomeomorph

@[simp]
theorem toPartialHomeomorph_coe (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) s c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) (hs : IsOpen s) :
    (hf.toPartialHomeomorph f s hc hs : E ‚Üí F) = f :=
  rfl
#align approximates_linear_on.to_local_homeomorph_coe ApproximatesLinearOn.toPartialHomeomorph_coe

@[simp]
theorem toPartialHomeomorph_source (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) s c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) (hs : IsOpen s) :
    (hf.toPartialHomeomorph f s hc hs).source = s :=
  rfl
#align approximates_linear_on.to_local_homeomorph_source ApproximatesLinearOn.toPartialHomeomorph_source

@[simp]
theorem toPartialHomeomorph_target (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) s c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) (hs : IsOpen s) :
    (hf.toPartialHomeomorph f s hc hs).target = f '' s :=
  rfl
#align approximates_linear_on.to_local_homeomorph_target ApproximatesLinearOn.toPartialHomeomorph_target

/-- A function `f` that approximates a linear equivalence on the whole space is a homeomorphism. -/
def toHomeomorph (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) univ c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) : E ‚âÉ‚Çú F := by
  refine' (hf.toPartialHomeomorph _ _ hc isOpen_univ).toHomeomorphOfSourceEqUnivTargetEqUniv rfl _
  rw [toPartialHomeomorph_target, image_univ, range_iff_surjective]
  exact hf.surjective hc
#align approximates_linear_on.to_homeomorph ApproximatesLinearOn.toHomeomorph

end

theorem closedBall_subset_target (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) s c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) (hs : IsOpen s) {b : E} (Œµ0 : 0 ‚â§ Œµ) (hŒµ : closedBall b Œµ ‚äÜ s) :
    closedBall (f b) ((N‚Åª¬π - c) * Œµ) ‚äÜ (hf.toPartialHomeomorph f s hc hs).target :=
  (hf.surjOn_closedBall_of_nonlinearRightInverse f'.toNonlinearRightInverse Œµ0 hŒµ).mono hŒµ
    Subset.rfl
#align approximates_linear_on.closed_ball_subset_target ApproximatesLinearOn.closedBall_subset_target

end ApproximatesLinearOn
