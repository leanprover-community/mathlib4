/-
Copyright (c) 2019 Chris Hughes. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Chris Hughes, YaÃ«l Dillies
-/
import Mathlib.Algebra.Module.BigOperators
import Mathlib.Data.Finset.NoncommProd
import Mathlib.Data.Fintype.Perm
import Mathlib.Data.Int.ModEq
import Mathlib.GroupTheory.Perm.List
import Mathlib.GroupTheory.Perm.Sign
import Mathlib.Logic.Equiv.Fintype

#align_import group_theory.perm.cycle.basic from "leanprover-community/mathlib"@"e8638a0fcaf73e4500469f368ef9494e495099b3"

/-!
# Cyclic permutations

This file develops the theory of cycles in permutations.

## Main definitions

In the following, `f : Equiv.Perm Î²`.

* `Equiv.Perm.SameCycle`: `f.SameCycle x y` when `x` and `y` are in the same cycle of `f`.
* `Equiv.Perm.IsCycle`: `f` is a cycle if any two nonfixed points of `f` are related by repeated
  applications of `f`, and `f` is not the identity.
* `Equiv.Perm.IsCycleOn`: `f` is a cycle on a set `s` when any two points of `s` are related by
  repeated applications of `f`.

The following two definitions require that `Î²` is a `Fintype`:

* `Equiv.Perm.cycleOf`: `f.cycleOf x` is the cycle of `f` that `x` belongs to.
* `Equiv.Perm.cycleFactors`: `f.cycleFactors` is a list of disjoint cyclic permutations that
  multiply to `f`.

## Main results

* This file contains several closure results:
  - `closure_is_cycle` : The symmetric group is generated by cycles
  - `closure_cycle_adjacent_swap` : The symmetric group is generated by
    a cycle and an adjacent transposition
  - `closure_cycle_coprime_swap` : The symmetric group is generated by
    a cycle and a coprime transposition
  - `closure_prime_cycle_swap` : The symmetric group is generated by
    a prime cycle and a transposition

## Notes

`Equiv.Perm.is_cycle` and `Equiv.Perm.IsCycleOn` are different in three ways:
* `is_cycle` is about the entire type while `IsCycleOn` is restricted to a set.
* `is_cycle` forbids the identity while `IsCycleOn` allows it (if `s` is a subsingleton).
* `IsCycleOn` forbids fixed points on `s` (if `s` is nontrivial), while `is_cycle` allows them.
-/


open Equiv Function Finset

open BigOperators

variable {Î¹ Î± Î² : Type*}

namespace Equiv.Perm

/-! ### `SameCycle` -/


section SameCycle

variable {f g : Perm Î±} {p : Î± â†’ Prop} {x y z : Î±}

/-- The equivalence relation indicating that two points are in the same cycle of a permutation. -/
def SameCycle (f : Perm Î±) (x y : Î±) : Prop :=
  âˆƒ i : â„¤, (f ^ i) x = y
#align equiv.perm.same_cycle Equiv.Perm.SameCycle

@[refl]
theorem SameCycle.refl (f : Perm Î±) (x : Î±) : SameCycle f x x :=
  âŸ¨0, rflâŸ©
#align equiv.perm.same_cycle.refl Equiv.Perm.SameCycle.refl

theorem SameCycle.rfl : SameCycle f x x :=
  SameCycle.refl _ _
#align equiv.perm.same_cycle.rfl Equiv.Perm.SameCycle.rfl

protected theorem _root_.Eq.sameCycle (h : x = y) (f : Perm Î±) : f.SameCycle x y := by rw [h]
                                                                                       -- ğŸ‰ no goals
#align eq.same_cycle Eq.sameCycle

@[symm]
theorem SameCycle.symm : SameCycle f x y â†’ SameCycle f y x := fun âŸ¨i, hiâŸ© =>
  âŸ¨-i, by rw [zpow_neg, â† hi, inv_apply_self]âŸ©
          -- ğŸ‰ no goals
#align equiv.perm.same_cycle.symm Equiv.Perm.SameCycle.symm

theorem sameCycle_comm : SameCycle f x y â†” SameCycle f y x :=
  âŸ¨SameCycle.symm, SameCycle.symmâŸ©
#align equiv.perm.same_cycle_comm Equiv.Perm.sameCycle_comm

@[trans]
theorem SameCycle.trans : SameCycle f x y â†’ SameCycle f y z â†’ SameCycle f x z :=
  fun âŸ¨i, hiâŸ© âŸ¨j, hjâŸ© => âŸ¨j + i, by rw [zpow_add, mul_apply, hi, hj]âŸ©
                                    -- ğŸ‰ no goals
#align equiv.perm.same_cycle.trans Equiv.Perm.SameCycle.trans

@[simp]
theorem sameCycle_one : SameCycle 1 x y â†” x = y := by simp [SameCycle]
                                                      -- ğŸ‰ no goals
#align equiv.perm.same_cycle_one Equiv.Perm.sameCycle_one

@[simp]
theorem sameCycle_inv : SameCycle fâ»Â¹ x y â†” SameCycle f x y :=
  (Equiv.neg _).exists_congr_left.trans <| by simp [SameCycle]
                                              -- ğŸ‰ no goals
#align equiv.perm.same_cycle_inv Equiv.Perm.sameCycle_inv

alias âŸ¨SameCycle.of_inv, SameCycle.invâŸ© := sameCycle_inv
#align equiv.perm.same_cycle.of_inv Equiv.Perm.SameCycle.of_inv
#align equiv.perm.same_cycle.inv Equiv.Perm.SameCycle.inv

@[simp]
theorem sameCycle_conj : SameCycle (g * f * gâ»Â¹) x y â†” SameCycle f (gâ»Â¹ x) (gâ»Â¹ y) :=
  exists_congr fun i => by simp [conj_zpow, eq_inv_iff_eq]
                           -- ğŸ‰ no goals
#align equiv.perm.same_cycle_conj Equiv.Perm.sameCycle_conj

theorem SameCycle.conj : SameCycle f x y â†’ SameCycle (g * f * gâ»Â¹) (g x) (g y) := by
  simp [sameCycle_conj]
  -- ğŸ‰ no goals
#align equiv.perm.same_cycle.conj Equiv.Perm.SameCycle.conj

theorem SameCycle.apply_eq_self_iff : SameCycle f x y â†’ (f x = x â†” f y = y) := fun âŸ¨i, hiâŸ© => by
  rw [â† hi, â† mul_apply, â† zpow_one_add, add_comm, zpow_add_one, mul_apply,
    (f ^ i).injective.eq_iff]
#align equiv.perm.same_cycle.apply_eq_self_iff Equiv.Perm.SameCycle.apply_eq_self_iff

theorem SameCycle.eq_of_left (h : SameCycle f x y) (hx : IsFixedPt f x) : x = y :=
  let âŸ¨_, hnâŸ© := h
  (hx.perm_zpow _).eq.symm.trans hn
#align equiv.perm.same_cycle.eq_of_left Equiv.Perm.SameCycle.eq_of_left

theorem SameCycle.eq_of_right (h : SameCycle f x y) (hy : IsFixedPt f y) : x = y :=
  h.eq_of_left <| h.apply_eq_self_iff.2 hy
#align equiv.perm.same_cycle.eq_of_right Equiv.Perm.SameCycle.eq_of_right

@[simp]
theorem sameCycle_apply_left : SameCycle f (f x) y â†” SameCycle f x y :=
  (Equiv.addRight 1).exists_congr_left.trans <| by
    simp [zpow_sub, SameCycle, Int.add_neg_one, Function.comp]
    -- ğŸ‰ no goals
#align equiv.perm.same_cycle_apply_left Equiv.Perm.sameCycle_apply_left

@[simp]
theorem sameCycle_apply_right : SameCycle f x (f y) â†” SameCycle f x y := by
  rw [sameCycle_comm, sameCycle_apply_left, sameCycle_comm]
  -- ğŸ‰ no goals
#align equiv.perm.same_cycle_apply_right Equiv.Perm.sameCycle_apply_right

@[simp]
theorem sameCycle_inv_apply_left : SameCycle f (fâ»Â¹ x) y â†” SameCycle f x y := by
  rw [â† sameCycle_apply_left, apply_inv_self]
  -- ğŸ‰ no goals
#align equiv.perm.same_cycle_inv_apply_left Equiv.Perm.sameCycle_inv_apply_left

@[simp]
theorem sameCycle_inv_apply_right : SameCycle f x (fâ»Â¹ y) â†” SameCycle f x y := by
  rw [â† sameCycle_apply_right, apply_inv_self]
  -- ğŸ‰ no goals
#align equiv.perm.same_cycle_inv_apply_right Equiv.Perm.sameCycle_inv_apply_right

@[simp]
theorem sameCycle_zpow_left {n : â„¤} : SameCycle f ((f ^ n) x) y â†” SameCycle f x y :=
  (Equiv.addRight (n : â„¤)).exists_congr_left.trans <| by simp [SameCycle, zpow_add]
                                                         -- ğŸ‰ no goals
#align equiv.perm.same_cycle_zpow_left Equiv.Perm.sameCycle_zpow_left

@[simp]
theorem sameCycle_zpow_right {n : â„¤} : SameCycle f x ((f ^ n) y) â†” SameCycle f x y := by
  rw [sameCycle_comm, sameCycle_zpow_left, sameCycle_comm]
  -- ğŸ‰ no goals
#align equiv.perm.same_cycle_zpow_right Equiv.Perm.sameCycle_zpow_right

@[simp]
theorem sameCycle_pow_left {n : â„•} : SameCycle f ((f ^ n) x) y â†” SameCycle f x y := by
  rw [â† zpow_ofNat, sameCycle_zpow_left]
  -- ğŸ‰ no goals
#align equiv.perm.same_cycle_pow_left Equiv.Perm.sameCycle_pow_left

@[simp]
theorem sameCycle_pow_right {n : â„•} : SameCycle f x ((f ^ n) y) â†” SameCycle f x y := by
  rw [â† zpow_ofNat, sameCycle_zpow_right]
  -- ğŸ‰ no goals
#align equiv.perm.same_cycle_pow_right Equiv.Perm.sameCycle_pow_right

alias âŸ¨SameCycle.of_apply_left, SameCycle.apply_leftâŸ© := sameCycle_apply_left
#align equiv.perm.same_cycle.of_apply_left Equiv.Perm.SameCycle.of_apply_left
#align equiv.perm.same_cycle.apply_left Equiv.Perm.SameCycle.apply_left

alias âŸ¨SameCycle.of_apply_right, SameCycle.apply_rightâŸ© := sameCycle_apply_right
#align equiv.perm.same_cycle.of_apply_right Equiv.Perm.SameCycle.of_apply_right
#align equiv.perm.same_cycle.apply_right Equiv.Perm.SameCycle.apply_right

alias âŸ¨SameCycle.of_inv_apply_left, SameCycle.inv_apply_leftâŸ© := sameCycle_inv_apply_left
#align equiv.perm.same_cycle.of_inv_apply_left Equiv.Perm.SameCycle.of_inv_apply_left
#align equiv.perm.same_cycle.inv_apply_left Equiv.Perm.SameCycle.inv_apply_left

alias âŸ¨SameCycle.of_inv_apply_right, SameCycle.inv_apply_rightâŸ© := sameCycle_inv_apply_right
#align equiv.perm.same_cycle.of_inv_apply_right Equiv.Perm.SameCycle.of_inv_apply_right
#align equiv.perm.same_cycle.inv_apply_right Equiv.Perm.SameCycle.inv_apply_right

alias âŸ¨SameCycle.of_pow_left, SameCycle.pow_leftâŸ© := sameCycle_pow_left
#align equiv.perm.same_cycle.of_pow_left Equiv.Perm.SameCycle.of_pow_left
#align equiv.perm.same_cycle.pow_left Equiv.Perm.SameCycle.pow_left

alias âŸ¨SameCycle.of_pow_right, SameCycle.pow_rightâŸ© := sameCycle_pow_right
#align equiv.perm.same_cycle.of_pow_right Equiv.Perm.SameCycle.of_pow_right
#align equiv.perm.same_cycle.pow_right Equiv.Perm.SameCycle.pow_right

alias âŸ¨SameCycle.of_zpow_left, SameCycle.zpow_leftâŸ© := sameCycle_zpow_left
#align equiv.perm.same_cycle.of_zpow_left Equiv.Perm.SameCycle.of_zpow_left
#align equiv.perm.same_cycle.zpow_left Equiv.Perm.SameCycle.zpow_left

alias âŸ¨SameCycle.of_zpow_right, SameCycle.zpow_rightâŸ© := sameCycle_zpow_right
#align equiv.perm.same_cycle.of_zpow_right Equiv.Perm.SameCycle.of_zpow_right
#align equiv.perm.same_cycle.zpow_right Equiv.Perm.SameCycle.zpow_right

theorem SameCycle.of_pow {n : â„•} : SameCycle (f ^ n) x y â†’ SameCycle f x y := fun âŸ¨m, hâŸ© =>
  âŸ¨n * m, by simp [zpow_mul, h]âŸ©
             -- ğŸ‰ no goals
#align equiv.perm.same_cycle.of_pow Equiv.Perm.SameCycle.of_pow

theorem SameCycle.of_zpow {n : â„¤} : SameCycle (f ^ n) x y â†’ SameCycle f x y := fun âŸ¨m, hâŸ© =>
  âŸ¨n * m, by simp [zpow_mul, h]âŸ©
             -- ğŸ‰ no goals
#align equiv.perm.same_cycle.of_zpow Equiv.Perm.SameCycle.of_zpow

@[simp]
theorem sameCycle_subtypePerm {h} {x y : { x // p x }} :
    (f.subtypePerm h).SameCycle x y â†” f.SameCycle x y :=
  exists_congr fun n => by simp [Subtype.ext_iff]
                           -- ğŸ‰ no goals
#align equiv.perm.same_cycle_subtype_perm Equiv.Perm.sameCycle_subtypePerm

alias âŸ¨_, SameCycle.subtypePermâŸ© := sameCycle_subtypePerm
#align equiv.perm.same_cycle.subtype_perm Equiv.Perm.SameCycle.subtypePerm

@[simp]
theorem sameCycle_extendDomain {p : Î² â†’ Prop} [DecidablePred p] {f : Î± â‰ƒ Subtype p} :
    SameCycle (g.extendDomain f) (f x) (f y) â†” g.SameCycle x y :=
  exists_congr fun n => by
    rw [â† extendDomain_zpow, extendDomain_apply_image, Subtype.coe_inj, f.injective.eq_iff]
    -- ğŸ‰ no goals
#align equiv.perm.same_cycle_extend_domain Equiv.Perm.sameCycle_extendDomain

alias âŸ¨_, SameCycle.extendDomainâŸ© := sameCycle_extendDomain
#align equiv.perm.same_cycle.extend_domain Equiv.Perm.SameCycle.extendDomain

theorem SameCycle.exists_pow_eq' [Finite Î±] : SameCycle f x y â†’ âˆƒ i < orderOf f, (f ^ i) x = y := by
  classical
    rintro âŸ¨k, rflâŸ©
    use (k % orderOf f).natAbs
    have hâ‚€ := Int.coe_nat_pos.mpr (orderOf_pos f)
    have hâ‚ := Int.emod_nonneg k hâ‚€.ne'
    rw [â† zpow_ofNat, Int.natAbs_of_nonneg hâ‚, â† zpow_eq_mod_orderOf]
    refine' âŸ¨_, by rflâŸ©
    rw [â† Int.ofNat_lt, Int.natAbs_of_nonneg hâ‚]
    exact Int.emod_lt_of_pos _ hâ‚€
#align equiv.perm.same_cycle.exists_pow_eq' Equiv.Perm.SameCycle.exists_pow_eq'

theorem SameCycle.exists_pow_eq'' [Finite Î±] (h : SameCycle f x y) :
    âˆƒ (i : â„•) (_ : 0 < i) (_ : i â‰¤ orderOf f), (f ^ i) x = y := by
  classical
    obtain âŸ¨_ | i, hi, rflâŸ© := h.exists_pow_eq'
    Â· refine' âŸ¨orderOf f, orderOf_pos f, le_rfl, _âŸ©
      rw [pow_orderOf_eq_one, pow_zero]
    Â· exact âŸ¨i.succ, i.zero_lt_succ, hi.le, by rflâŸ©
#align equiv.perm.same_cycle.exists_pow_eq'' Equiv.Perm.SameCycle.exists_pow_eq''

instance [Fintype Î±] [DecidableEq Î±] (f : Perm Î±) : DecidableRel (SameCycle f) := fun x y =>
  decidable_of_iff (âˆƒ n âˆˆ List.range (Fintype.card (Perm Î±)), (f ^ n) x = y)
    âŸ¨fun âŸ¨n, _, hnâŸ© => âŸ¨n, hnâŸ©, fun âŸ¨i, hiâŸ© => âŸ¨(i % orderOf f).natAbs,
      List.mem_range.2 (Int.ofNat_lt.1 <| by
        rw [Int.natAbs_of_nonneg (Int.emod_nonneg _ <| Int.coe_nat_ne_zero.2 (orderOf_pos _).ne')]
        -- âŠ¢ i % â†‘(orderOf f) < â†‘(Fintype.card (Perm Î±))
        Â· refine' (Int.emod_lt _ <| Int.coe_nat_ne_zero_iff_pos.2 <| orderOf_pos _).trans_le _
          -- âŠ¢ |â†‘(orderOf f)| â‰¤ â†‘(Fintype.card (Perm Î±))
          simp [orderOf_le_card_univ]),
          -- ğŸ‰ no goals
      by
        rw [â† zpow_ofNat, Int.natAbs_of_nonneg (Int.emod_nonneg _ <|
          Int.coe_nat_ne_zero_iff_pos.2 <| orderOf_pos _), â† zpow_eq_mod_orderOf, hi]âŸ©âŸ©

end SameCycle

/-!
### `IsCycle`
-/


section IsCycle

variable {f g : Perm Î±} {x y : Î±}

/-- A cycle is a non identity permutation where any two nonfixed points of the permutation are
related by repeated application of the permutation. -/
def IsCycle (f : Perm Î±) : Prop :=
  âˆƒ x, f x â‰  x âˆ§ âˆ€ â¦ƒyâ¦„, f y â‰  y â†’ SameCycle f x y
#align equiv.perm.is_cycle Equiv.Perm.IsCycle

theorem IsCycle.ne_one (h : IsCycle f) : f â‰  1 := fun hf => by simp [hf, IsCycle] at h
                                                               -- ğŸ‰ no goals
#align equiv.perm.is_cycle.ne_one Equiv.Perm.IsCycle.ne_one

@[simp]
theorem not_isCycle_one : Â¬(1 : Perm Î±).IsCycle := fun H => H.ne_one rfl
#align equiv.perm.not_is_cycle_one Equiv.Perm.not_isCycle_one

protected theorem IsCycle.sameCycle (hf : IsCycle f) (hx : f x â‰  x) (hy : f y â‰  y) :
    SameCycle f x y :=
  let âŸ¨g, hgâŸ© := hf
  let âŸ¨a, haâŸ© := hg.2 hx
  let âŸ¨b, hbâŸ© := hg.2 hy
  âŸ¨b - a, by rw [â† ha, â† mul_apply, â† zpow_add, sub_add_cancel, hb]âŸ©
             -- ğŸ‰ no goals
#align equiv.perm.is_cycle.same_cycle Equiv.Perm.IsCycle.sameCycle

theorem IsCycle.exists_zpow_eq : IsCycle f â†’ f x â‰  x â†’ f y â‰  y â†’ âˆƒ i : â„¤, (f ^ i) x = y :=
  IsCycle.sameCycle
#align equiv.perm.is_cycle.exists_zpow_eq Equiv.Perm.IsCycle.exists_zpow_eq

theorem IsCycle.inv (hf : IsCycle f) : IsCycle fâ»Â¹ :=
  hf.imp fun _ âŸ¨hx, hâŸ© =>
    âŸ¨inv_eq_iff_eq.not.2 hx.symm, fun _ hy => (h <| inv_eq_iff_eq.not.2 hy.symm).invâŸ©
#align equiv.perm.is_cycle.inv Equiv.Perm.IsCycle.inv

@[simp]
theorem isCycle_inv : IsCycle fâ»Â¹ â†” IsCycle f :=
  âŸ¨fun h => h.inv, IsCycle.invâŸ©
#align equiv.perm.is_cycle_inv Equiv.Perm.isCycle_inv

theorem IsCycle.conj : IsCycle f â†’ IsCycle (g * f * gâ»Â¹) := by
  rintro âŸ¨x, hx, hâŸ©
  -- âŠ¢ IsCycle (g * f * gâ»Â¹)
  refine' âŸ¨g x, by simp [coe_mul, inv_apply_self, hx], fun y hy => _âŸ©
  -- âŠ¢ SameCycle (g * f * gâ»Â¹) (â†‘g x) y
  rw [â† apply_inv_self g y]
  -- âŠ¢ SameCycle (g * f * gâ»Â¹) (â†‘g x) (â†‘g (â†‘gâ»Â¹ y))
  exact (h <| eq_inv_iff_eq.not.2 hy).conj
  -- ğŸ‰ no goals
#align equiv.perm.is_cycle.conj Equiv.Perm.IsCycle.conj

protected theorem IsCycle.extendDomain {p : Î² â†’ Prop} [DecidablePred p] (f : Î± â‰ƒ Subtype p) :
    IsCycle g â†’ IsCycle (g.extendDomain f) := by
  rintro âŸ¨a, ha, ha'âŸ©
  -- âŠ¢ IsCycle (extendDomain g f)
  refine' âŸ¨f a, _, fun b hb => _âŸ©
  -- âŠ¢ â†‘(extendDomain g f) â†‘(â†‘f a) â‰  â†‘(â†‘f a)
  Â· rw [extendDomain_apply_image]
    -- âŠ¢ â†‘(â†‘f (â†‘g a)) â‰  â†‘(â†‘f a)
    exact Subtype.coe_injective.ne (f.injective.ne ha)
    -- ğŸ‰ no goals
  have h : b = f (f.symm âŸ¨b, of_not_not <| hb âˆ˜ extendDomain_apply_not_subtype _ _âŸ©) := by
    rw [apply_symm_apply, Subtype.coe_mk]
  rw [h] at hb âŠ¢
  -- âŠ¢ SameCycle (extendDomain g f) â†‘(â†‘f a) â†‘(â†‘f (â†‘f.symm { val := b, property := ( â€¦
  simp only [extendDomain_apply_image, Subtype.coe_injective.ne_iff, f.injective.ne_iff] at hb
  -- âŠ¢ SameCycle (extendDomain g f) â†‘(â†‘f a) â†‘(â†‘f (â†‘f.symm { val := b, property := ( â€¦
  exact (ha' hb).extendDomain
  -- ğŸ‰ no goals
#align equiv.perm.is_cycle.extend_domain Equiv.Perm.IsCycle.extendDomain

theorem isCycle_iff_sameCycle (hx : f x â‰  x) : IsCycle f â†” âˆ€ {y}, SameCycle f x y â†” f y â‰  y :=
  âŸ¨fun hf y =>
    âŸ¨fun âŸ¨i, hiâŸ© hy =>
      hx <| by
        rw [â† zpow_apply_eq_self_of_apply_eq_self hy i, (f ^ i).injective.eq_iff] at hi
        -- âŠ¢ â†‘f x = x
        rw [hi, hy],
        -- ğŸ‰ no goals
      hf.exists_zpow_eq hxâŸ©,
    fun h => âŸ¨x, hx, fun y hy => h.2 hyâŸ©âŸ©
#align equiv.perm.is_cycle_iff_same_cycle Equiv.Perm.isCycle_iff_sameCycle

section Finite

variable [Finite Î±]

theorem IsCycle.exists_pow_eq (hf : IsCycle f) (hx : f x â‰  x) (hy : f y â‰  y) :
    âˆƒ i : â„•, (f ^ i) x = y := by
  let âŸ¨n, hnâŸ© := hf.exists_zpow_eq hx hy
  -- âŠ¢ âˆƒ i, â†‘(f ^ i) x = y
  classical exact
      âŸ¨(n % orderOf f).toNat, by
        {have := n.emod_nonneg (Int.coe_nat_ne_zero.mpr (ne_of_gt (orderOf_pos f)))
         rwa [â† zpow_ofNat, Int.toNat_of_nonneg this, â† zpow_eq_mod_orderOf]}âŸ©
#align equiv.perm.is_cycle.exists_pow_eq Equiv.Perm.IsCycle.exists_pow_eq

end Finite

variable [DecidableEq Î±]

theorem isCycle_swap (hxy : x â‰  y) : IsCycle (swap x y) :=
  âŸ¨y, by rwa [swap_apply_right], fun a (ha : ite (a = x) y (ite (a = y) x a) â‰  a) =>
         -- ğŸ‰ no goals
    if hya : y = a then âŸ¨0, hyaâŸ©
    else
      âŸ¨1, by
        rw [zpow_one, swap_apply_def]
        -- âŠ¢ (if y = x then y else if y = y then x else y) = a
        split_ifs at * <;> tautoâŸ©âŸ©
                           -- ğŸ‰ no goals
                           -- ğŸ‰ no goals
                           -- ğŸ‰ no goals
                           -- ğŸ‰ no goals
                           -- ğŸ‰ no goals
                           -- ğŸ‰ no goals
                           -- ğŸ‰ no goals
                           -- ğŸ‰ no goals
                           -- ğŸ‰ no goals
#align equiv.perm.is_cycle_swap Equiv.Perm.isCycle_swap

protected theorem IsSwap.isCycle : IsSwap f â†’ IsCycle f := by
  rintro âŸ¨x, y, hxy, rflâŸ©
  -- âŠ¢ IsCycle (swap x y)
  exact isCycle_swap hxy
  -- ğŸ‰ no goals
#align equiv.perm.is_swap.is_cycle Equiv.Perm.IsSwap.isCycle

variable [Fintype Î±]

theorem IsCycle.two_le_card_support (h : IsCycle f) : 2 â‰¤ f.support.card :=
  two_le_card_support_of_ne_one h.ne_one
#align equiv.perm.is_cycle.two_le_card_support Equiv.Perm.IsCycle.two_le_card_support

theorem IsCycle.exists_pow_eq_one [Finite Î²] {f : Perm Î²} (hf : IsCycle f) :
    âˆƒ (k : â„•) (_ : 1 < k), f ^ k = 1 := by
  classical
    have : IsOfFinOrder f := by exact _root_.exists_pow_eq_one f
    rw [isOfFinOrder_iff_pow_eq_one] at this
    obtain âŸ¨x, hx, _âŸ© := hf
    obtain âŸ¨_ | _ | k, hk, hk'âŸ© := this
    Â· exact absurd hk (lt_asymm hk)
    Â· rw [pow_one] at hk'
      simp [hk'] at hx
    Â· exact âŸ¨k + 2, by simp, hk'âŸ©
#align equiv.perm.is_cycle.exists_pow_eq_one Equiv.Perm.IsCycle.exists_pow_eq_one

/-- The subgroup generated by a cycle is in bijection with its support -/
noncomputable def IsCycle.zpowersEquivSupport {Ïƒ : Perm Î±} (hÏƒ : IsCycle Ïƒ) :
    (Subgroup.zpowers Ïƒ) â‰ƒ Ïƒ.support :=
  Equiv.ofBijective
    (fun (Ï„ : â†¥ ((Subgroup.zpowers Ïƒ) : Set (Perm Î±))) =>
      âŸ¨(Ï„ : Perm Î±) (Classical.choose hÏƒ), by
        obtain âŸ¨Ï„, n, rflâŸ© := Ï„
        -- âŠ¢ â†‘â†‘{ val := (fun x x_1 => x ^ x_1) Ïƒ n, property := (_ : âˆƒ y, (fun x x_1 => x â€¦
        erw [Finset.mem_coe, Subtype.coe_mk, zpow_apply_mem_support, mem_support]
        -- âŠ¢ â†‘Ïƒ (Classical.choose hÏƒ) â‰  Classical.choose hÏƒ
        exact (Classical.choose_spec hÏƒ).1âŸ©)
        -- ğŸ‰ no goals
    (by
      constructor
      -- âŠ¢ Injective fun Ï„ => { val := â†‘â†‘Ï„ (Classical.choose hÏƒ), property := (_ : â†‘â†‘Ï„  â€¦
      Â· rintro âŸ¨a, m, rflâŸ© âŸ¨b, n, rflâŸ© h
        -- âŠ¢ { val := (fun x x_1 => x ^ x_1) Ïƒ m, property := (_ : âˆƒ y, (fun x x_1 => x ^ â€¦
        ext y
        -- âŠ¢ â†‘â†‘{ val := (fun x x_1 => x ^ x_1) Ïƒ m, property := (_ : âˆƒ y, (fun x x_1 => x â€¦
        by_cases hy : Ïƒ y = y
        -- âŠ¢ â†‘â†‘{ val := (fun x x_1 => x ^ x_1) Ïƒ m, property := (_ : âˆƒ y, (fun x x_1 => x â€¦
        Â· simp_rw [zpow_apply_eq_self_of_apply_eq_self hy]
          -- ğŸ‰ no goals
        Â· obtain âŸ¨i, rflâŸ© := (Classical.choose_spec hÏƒ).2 hy
          -- âŠ¢ â†‘â†‘{ val := (fun x x_1 => x ^ x_1) Ïƒ m, property := (_ : âˆƒ y, (fun x x_1 => x â€¦
          rw [Subtype.coe_mk, Subtype.coe_mk, zpow_apply_comm Ïƒ m i, zpow_apply_comm Ïƒ n i]
          -- âŠ¢ â†‘(Ïƒ ^ i) (â†‘(Ïƒ ^ m) (Classical.choose hÏƒ)) = â†‘(Ïƒ ^ i) (â†‘(Ïƒ ^ n) (Classical.ch â€¦
          exact congr_arg _ (Subtype.ext_iff.mp h)
          -- ğŸ‰ no goals
      Â· rintro âŸ¨y, hyâŸ©
        -- âŠ¢ âˆƒ a, (fun Ï„ => { val := â†‘â†‘Ï„ (Classical.choose hÏƒ), property := (_ : â†‘â†‘Ï„ (Cla â€¦
        erw [Finset.mem_coe, mem_support] at hy
        -- âŠ¢ âˆƒ a, (fun Ï„ => { val := â†‘â†‘Ï„ (Classical.choose hÏƒ), property := (_ : â†‘â†‘Ï„ (Cla â€¦
        obtain âŸ¨n, rflâŸ© := (Classical.choose_spec hÏƒ).2 hy
        -- âŠ¢ âˆƒ a, (fun Ï„ => { val := â†‘â†‘Ï„ (Classical.choose hÏƒ), property := (_ : â†‘â†‘Ï„ (Cla â€¦
        exact âŸ¨âŸ¨Ïƒ ^ n, n, rflâŸ©, rflâŸ©)
        -- ğŸ‰ no goals
#align equiv.perm.is_cycle.zpowers_equiv_support Equiv.Perm.IsCycle.zpowersEquivSupport

@[simp]
theorem IsCycle.zpowersEquivSupport_apply {Ïƒ : Perm Î±} (hÏƒ : IsCycle Ïƒ) {n : â„•} :
    hÏƒ.zpowersEquivSupport âŸ¨Ïƒ ^ n, n, rflâŸ© =
      âŸ¨(Ïƒ ^ n) (Classical.choose hÏƒ),
        pow_apply_mem_support.2 (mem_support.2 (Classical.choose_spec hÏƒ).1)âŸ© :=
  rfl
#align equiv.perm.is_cycle.zpowers_equiv_support_apply Equiv.Perm.IsCycle.zpowersEquivSupport_apply

@[simp]
theorem IsCycle.zpowersEquivSupport_symm_apply {Ïƒ : Perm Î±} (hÏƒ : IsCycle Ïƒ) (n : â„•) :
    hÏƒ.zpowersEquivSupport.symm
        âŸ¨(Ïƒ ^ n) (Classical.choose hÏƒ),
          pow_apply_mem_support.2 (mem_support.2 (Classical.choose_spec hÏƒ).1)âŸ© =
      âŸ¨Ïƒ ^ n, n, rflâŸ© :=
  (Equiv.symm_apply_eq _).2 hÏƒ.zpowersEquivSupport_apply
#align equiv.perm.is_cycle.zpowers_equiv_support_symm_apply Equiv.Perm.IsCycle.zpowersEquivSupport_symm_apply

protected theorem IsCycle.orderOf (hf : IsCycle f) : orderOf f = f.support.card := by
  rw [orderOf_eq_card_zpowers, â† Fintype.card_coe]
  -- âŠ¢ Fintype.card { x // x âˆˆ Subgroup.zpowers f } = Fintype.card { x // x âˆˆ suppo â€¦
  convert Fintype.card_congr (IsCycle.zpowersEquivSupport hf)
  -- ğŸ‰ no goals
#align equiv.perm.is_cycle.order_of Equiv.Perm.IsCycle.orderOf

theorem isCycle_swap_mul_auxâ‚ {Î± : Type*} [DecidableEq Î±] :
    âˆ€ (n : â„•) {b x : Î±} {f : Perm Î±} (_ : (swap x (f x) * f) b â‰  b) (_ : (f ^ n) (f x) = b),
      âˆƒ i : â„¤, ((swap x (f x) * f) ^ i) (f x) = b := by
  intro n
  -- âŠ¢ âˆ€ {b x : Î±} {f : Perm Î±}, â†‘(swap x (â†‘f x) * f) b â‰  b â†’ â†‘(f ^ n) (â†‘f x) = b â†’ â€¦
  induction' n with n hn
  -- âŠ¢ âˆ€ {b x : Î±} {f : Perm Î±}, â†‘(swap x (â†‘f x) * f) b â‰  b â†’ â†‘(f ^ Nat.zero) (â†‘f x â€¦
  Â· exact fun _ h => âŸ¨0, hâŸ©
    -- ğŸ‰ no goals
  Â· intro b x f hb h
    -- âŠ¢ âˆƒ i, â†‘((swap x (â†‘f x) * f) ^ i) (â†‘f x) = b
    exact if hfbx : f x = b then âŸ¨0, hfbxâŸ©
      else
        have : f b â‰  b âˆ§ b â‰  x := ne_and_ne_of_swap_mul_apply_ne_self hb
        have hb' : (swap x (f x) * f) (fâ»Â¹ b) â‰  fâ»Â¹ b := by
          rw [mul_apply, apply_inv_self, swap_apply_of_ne_of_ne this.2 (Ne.symm hfbx), Ne.def, â†
            f.injective.eq_iff, apply_inv_self]
          exact this.1
        let âŸ¨i, hiâŸ© := hn hb' (f.injective <| by
          rw [apply_inv_self]; rwa [pow_succ, mul_apply] at h)
        âŸ¨i + 1, by
          rw [add_comm, zpow_add, mul_apply, hi, zpow_one, mul_apply, apply_inv_self,
            swap_apply_of_ne_of_ne (ne_and_ne_of_swap_mul_apply_ne_self hb).2 (Ne.symm hfbx)]âŸ©
#align equiv.perm.is_cycle_swap_mul_auxâ‚ Equiv.Perm.isCycle_swap_mul_auxâ‚

theorem isCycle_swap_mul_auxâ‚‚ {Î± : Type*} [DecidableEq Î±] :
    âˆ€ (n : â„¤) {b x : Î±} {f : Perm Î±} (_ : (swap x (f x) * f) b â‰  b) (_ : (f ^ n) (f x) = b),
      âˆƒ i : â„¤, ((swap x (f x) * f) ^ i) (f x) = b := by
  intro n
  -- âŠ¢ âˆ€ {b x : Î±} {f : Perm Î±}, â†‘(swap x (â†‘f x) * f) b â‰  b â†’ â†‘(f ^ n) (â†‘f x) = b â†’ â€¦
  induction' n with n n
  -- âŠ¢ âˆ€ {b x : Î±} {f : Perm Î±}, â†‘(swap x (â†‘f x) * f) b â‰  b â†’ â†‘(f ^ Int.ofNat n) (â†‘ â€¦
  Â· exact isCycle_swap_mul_auxâ‚ n
    -- ğŸ‰ no goals
  Â· intro b x f hb h
    -- âŠ¢ âˆƒ i, â†‘((swap x (â†‘f x) * f) ^ i) (â†‘f x) = b
    exact if hfbx' : f x = b then âŸ¨0, hfbx'âŸ©
      else
        have : f b â‰  b âˆ§ b â‰  x := ne_and_ne_of_swap_mul_apply_ne_self hb
        have hb : (swap x (fâ»Â¹ x) * fâ»Â¹) (fâ»Â¹ b) â‰  fâ»Â¹ b := by
          rw [mul_apply, swap_apply_def]
          split_ifs <;>
              simp only [inv_eq_iff_eq, Perm.mul_apply, zpow_negSucc,
                Ne.def, Perm.apply_inv_self] at
                * <;> tauto
        let âŸ¨i, hiâŸ© :=
          isCycle_swap_mul_auxâ‚ n hb
            (show (fâ»Â¹ ^ n) (fâ»Â¹ x) = fâ»Â¹ b by
              rw [â† zpow_ofNat, â† h, â† mul_apply, â† mul_apply, â† mul_apply, zpow_negSucc, â† inv_pow,
                pow_succ', mul_assoc, mul_assoc, inv_mul_self, mul_one, zpow_ofNat, â† pow_succ', â†
                pow_succ])
        have h : (swap x (fâ»Â¹ x) * fâ»Â¹) (f x) = fâ»Â¹ x := by
          rw [mul_apply, inv_apply_self, swap_apply_left]
        âŸ¨-i, by
          rw [â† add_sub_cancel i 1, neg_sub, sub_eq_add_neg, zpow_add, zpow_one, zpow_neg,
            â† inv_zpow, mul_inv_rev, swap_inv, mul_swap_eq_swap_mul, inv_apply_self, swap_comm _ x,
            zpow_add, zpow_one, mul_apply, mul_apply (_ ^ i), h, hi, mul_apply, apply_inv_self,
            swap_apply_of_ne_of_ne this.2 (Ne.symm hfbx')]âŸ©
#align equiv.perm.is_cycle_swap_mul_auxâ‚‚ Equiv.Perm.isCycle_swap_mul_auxâ‚‚

theorem IsCycle.eq_swap_of_apply_apply_eq_self {Î± : Type*} [DecidableEq Î±] {f : Perm Î±}
    (hf : IsCycle f) {x : Î±} (hfx : f x â‰  x) (hffx : f (f x) = x) : f = swap x (f x) :=
  Equiv.ext fun y =>
    let âŸ¨z, hzâŸ© := hf
    let âŸ¨i, hiâŸ© := hz.2 hfx
    if hyx : y = x then by simp [hyx]
                           -- ğŸ‰ no goals
    else
      if hfyx : y = f x then by simp [hfyx, hffx]
                                -- ğŸ‰ no goals
      else by
        rw [swap_apply_of_ne_of_ne hyx hfyx]
        -- âŠ¢ â†‘f y = y
        refine' by_contradiction fun hy => _
        -- âŠ¢ False
        cases' hz.2 hy with j hj
        -- âŠ¢ False
        rw [â† sub_add_cancel j i, zpow_add, mul_apply, hi] at hj
        -- âŠ¢ False
        cases' zpow_apply_eq_of_apply_apply_eq_self hffx (j - i) with hji hji
        -- âŠ¢ False
        Â· rw [â† hj, hji] at hyx
          -- âŠ¢ False
          tauto
          -- ğŸ‰ no goals
        Â· rw [â† hj, hji] at hfyx
          -- âŠ¢ False
          tauto
          -- ğŸ‰ no goals
#align equiv.perm.is_cycle.eq_swap_of_apply_apply_eq_self Equiv.Perm.IsCycle.eq_swap_of_apply_apply_eq_self

theorem IsCycle.swap_mul {Î± : Type*} [DecidableEq Î±] {f : Perm Î±} (hf : IsCycle f) {x : Î±}
    (hx : f x â‰  x) (hffx : f (f x) â‰  x) : IsCycle (swap x (f x) * f) :=
  âŸ¨f x, by simp [swap_apply_def, mul_apply, if_neg hffx, f.injective.eq_iff, if_neg hx, hx],
           -- ğŸ‰ no goals
    fun y hy =>
    let âŸ¨i, hiâŸ© := hf.exists_zpow_eq hx (ne_and_ne_of_swap_mul_apply_ne_self hy).1
    -- Porting note: Needed to add Perm Î± typehint, otherwise does not know how to coerce to fun
    have hi : (f ^ (i - 1) : Perm Î±) (f x) = y :=
      calc
        (f ^ (i - 1) : Perm Î±) (f x) = (f ^ (i - 1) * f ^ (1 : â„¤) : Perm Î±) x := by simp
                                                                                    -- ğŸ‰ no goals
        _ = y := by rwa [â† zpow_add, sub_add_cancel]
                    -- ğŸ‰ no goals

    isCycle_swap_mul_auxâ‚‚ (i - 1) hy hiâŸ©
#align equiv.perm.is_cycle.swap_mul Equiv.Perm.IsCycle.swap_mul

theorem IsCycle.sign {f : Perm Î±} (hf : IsCycle f) : sign f = -(-1) ^ f.support.card :=
  let âŸ¨x, hxâŸ© := hf
  calc
    Perm.sign f = Perm.sign (swap x (f x) * (swap x (f x) * f)) := by
      {rw [â† mul_assoc, mul_def, mul_def, swap_swap, trans_refl]}
      -- ğŸ‰ no goals
    _ = -(-1) ^ f.support.card :=
      if h1 : f (f x) = x then by
        have h : swap x (f x) * f = 1 := by
          simp only [mul_def, one_def]
          rw [hf.eq_swap_of_apply_apply_eq_self hx.1 h1, swap_apply_left, swap_swap]
        dsimp only
        -- âŠ¢ â†‘Perm.sign (swap x (â†‘f x) * (swap x (â†‘f x) * f)) = -(-1) ^ card (support f)
        rw [sign_mul, sign_swap hx.1.symm, h, sign_one,
          hf.eq_swap_of_apply_apply_eq_self hx.1 h1, card_support_swap hx.1.symm]
        rfl
        -- ğŸ‰ no goals
      else by
        have h : card (support (swap x (f x) * f)) + 1 = card (support f) := by
          rw [â† insert_erase (mem_support.2 hx.1), support_swap_mul_eq _ _ h1,
            card_insert_of_not_mem (not_mem_erase _ _), sdiff_singleton_eq_erase]
        have : card (support (swap x (f x) * f)) < card (support f) :=
          card_support_swap_mul hx.1
        dsimp only
        -- âŠ¢ â†‘Perm.sign (swap x (â†‘f x) * (swap x (â†‘f x) * f)) = -(-1) ^ card (support f)
        rw [sign_mul, sign_swap hx.1.symm, (hf.swap_mul hx.1 h1).sign, â† h]
        -- âŠ¢ -1 * -(-1) ^ card (support (swap x (â†‘f x) * f)) = -(-1) ^ (card (support (sw â€¦
        simp only [mul_neg, neg_mul, one_mul, neg_neg, pow_add, pow_one, mul_one]
        -- ğŸ‰ no goals
termination_by _ => f.support.card
#align equiv.perm.is_cycle.sign Equiv.Perm.IsCycle.sign

theorem IsCycle.of_pow {n : â„•} (h1 : IsCycle (f ^ n)) (h2 : f.support âŠ† (f ^ n).support) :
    IsCycle f := by
  have key : âˆ€ x : Î±, (f ^ n) x â‰  x â†” f x â‰  x := by
    simp_rw [â† mem_support, â† Finset.ext_iff]
    exact (support_pow_le _ n).antisymm h2
  obtain âŸ¨x, hx1, hx2âŸ© := h1
  -- âŠ¢ IsCycle f
  refine' âŸ¨x, (key x).mp hx1, fun y hy => _âŸ©
  -- âŠ¢ SameCycle f x y
  cases' hx2 ((key y).mpr hy) with i _
  -- âŠ¢ SameCycle f x y
  exact âŸ¨n * i, by rwa [zpow_mul]âŸ©
  -- ğŸ‰ no goals
#align equiv.perm.is_cycle.of_pow Equiv.Perm.IsCycle.of_pow

-- The lemma `support_zpow_le` is relevant. It means that `h2` is equivalent to
-- `Ïƒ.support = (Ïƒ ^ n).support`, as well as to `Ïƒ.support.card â‰¤ (Ïƒ ^ n).support.card`.
theorem IsCycle.of_zpow {n : â„¤} (h1 : IsCycle (f ^ n)) (h2 : f.support âŠ† (f ^ n).support) :
    IsCycle f := by
  cases n
  -- âŠ¢ IsCycle f
  Â· exact h1.of_pow h2
    -- ğŸ‰ no goals
  Â· simp only [le_eq_subset, zpow_negSucc, Perm.support_inv] at h1 h2
    -- âŠ¢ IsCycle f
    exact (inv_inv (f ^ _) â–¸ h1.inv).of_pow h2
    -- ğŸ‰ no goals
#align equiv.perm.is_cycle.of_zpow Equiv.Perm.IsCycle.of_zpow

theorem nodup_of_pairwise_disjoint_cycles {l : List (Perm Î²)} (h1 : âˆ€ f âˆˆ l, IsCycle f)
    (h2 : l.Pairwise Disjoint) : l.Nodup :=
  nodup_of_pairwise_disjoint (fun h => (h1 1 h).ne_one rfl) h2
#align equiv.perm.nodup_of_pairwise_disjoint_cycles Equiv.Perm.nodup_of_pairwise_disjoint_cycles

/-- Unlike `support_congr`, which assumes that `âˆ€ (x âˆˆ g.support), f x = g x)`, here
we have the weaker assumption that `âˆ€ (x âˆˆ f.support), f x = g x`. -/
theorem IsCycle.support_congr (hf : IsCycle f) (hg : IsCycle g) (h : f.support âŠ† g.support)
    (h' : âˆ€ x âˆˆ f.support, f x = g x) : f = g := by
  have : f.support = g.support := by
    refine' le_antisymm h _
    intro z hz
    obtain âŸ¨x, hx, _âŸ© := id hf
    have hx' : g x â‰  x := by rwa [â† h' x (mem_support.mpr hx)]
    obtain âŸ¨m, hmâŸ© := hg.exists_pow_eq hx' (mem_support.mp hz)
    have h'' : âˆ€ x âˆˆ f.support âˆ© g.support, f x = g x := by
      intro x hx
      exact h' x (mem_of_mem_inter_left hx)
    rwa [â† hm, â†
      pow_eq_on_of_mem_support h'' _ x
        (mem_inter_of_mem (mem_support.mpr hx) (mem_support.mpr hx')),
      pow_apply_mem_support, mem_support]
  refine' Equiv.Perm.support_congr h _
  -- âŠ¢ âˆ€ (x : Î±), x âˆˆ support g â†’ â†‘f x = â†‘g x
  simpa [â† this] using h'
  -- ğŸ‰ no goals
#align equiv.perm.is_cycle.support_congr Equiv.Perm.IsCycle.support_congr

/-- If two cyclic permutations agree on all terms in their intersection,
and that intersection is not empty, then the two cyclic permutations must be equal. -/
theorem IsCycle.eq_on_support_inter_nonempty_congr (hf : IsCycle f) (hg : IsCycle g)
    (h : âˆ€ x âˆˆ f.support âˆ© g.support, f x = g x)
    (hx : f x = g x) (hx' : x âˆˆ f.support) : f = g := by
  have hx'' : x âˆˆ g.support := by rwa [mem_support, â† hx, â† mem_support]
  -- âŠ¢ f = g
  have : f.support âŠ† g.support := by
    intro y hy
    obtain âŸ¨k, rflâŸ© := hf.exists_pow_eq (mem_support.mp hx') (mem_support.mp hy)
    rwa [pow_eq_on_of_mem_support h _ _ (mem_inter_of_mem hx' hx''), pow_apply_mem_support]
  rw [(inter_eq_left_iff_subset _ _).mpr this] at h
  -- âŠ¢ f = g
  exact hf.support_congr hg this h
  -- ğŸ‰ no goals
#align equiv.perm.is_cycle.eq_on_support_inter_nonempty_congr Equiv.Perm.IsCycle.eq_on_support_inter_nonempty_congr

theorem IsCycle.support_pow_eq_iff (hf : IsCycle f) {n : â„•} :
    support (f ^ n) = support f â†” Â¬orderOf f âˆ£ n := by
  rw [orderOf_dvd_iff_pow_eq_one]
  -- âŠ¢ support (f ^ n) = support f â†” Â¬f ^ n = 1
  constructor
  -- âŠ¢ support (f ^ n) = support f â†’ Â¬f ^ n = 1
  Â· intro h H
    -- âŠ¢ False
    refine' hf.ne_one _
    -- âŠ¢ f = 1
    rw [â† support_eq_empty_iff, â† h, H, support_one]
    -- ğŸ‰ no goals
  Â· intro H
    -- âŠ¢ support (f ^ n) = support f
    apply le_antisymm (support_pow_le _ n) _
    -- âŠ¢ support f â‰¤ support (f ^ n)
    intro x hx
    -- âŠ¢ x âˆˆ support (f ^ n)
    contrapose! H
    -- âŠ¢ f ^ n = 1
    ext z
    -- âŠ¢ â†‘(f ^ n) z = â†‘1 z
    by_cases hz : f z = z
    -- âŠ¢ â†‘(f ^ n) z = â†‘1 z
    Â· rw [pow_apply_eq_self_of_apply_eq_self hz, one_apply]
      -- ğŸ‰ no goals
    Â· obtain âŸ¨k, rflâŸ© := hf.exists_pow_eq hz (mem_support.mp hx)
      -- âŠ¢ â†‘(f ^ n) z = â†‘1 z
      apply (f ^ k).injective
      -- âŠ¢ â†‘(f ^ k) (â†‘(f ^ n) z) = â†‘(f ^ k) (â†‘1 z)
      rw [â† mul_apply, (Commute.pow_pow_self _ _ _).eq, mul_apply]
      -- âŠ¢ â†‘(f ^ n) (â†‘(f ^ k) z) = â†‘(f ^ k) (â†‘1 z)
      simpa using H
      -- ğŸ‰ no goals
#align equiv.perm.is_cycle.support_pow_eq_iff Equiv.Perm.IsCycle.support_pow_eq_iff

theorem IsCycle.support_pow_of_pos_of_lt_orderOf (hf : IsCycle f) {n : â„•} (npos : 0 < n)
    (hn : n < orderOf f) : (f ^ n).support = f.support :=
  hf.support_pow_eq_iff.2 <| Nat.not_dvd_of_pos_of_lt npos hn
#align equiv.perm.is_cycle.support_pow_of_pos_of_lt_order_of Equiv.Perm.IsCycle.support_pow_of_pos_of_lt_orderOf

theorem IsCycle.pow_iff [Finite Î²] {f : Perm Î²} (hf : IsCycle f) {n : â„•} :
    IsCycle (f ^ n) â†” n.coprime (orderOf f) := by
  classical
    cases nonempty_fintype Î²
    constructor
    Â· intro h
      have hr : support (f ^ n) = support f := by
        rw [hf.support_pow_eq_iff]
        rintro âŸ¨k, rflâŸ©
        refine' h.ne_one _
        simp [pow_mul, pow_orderOf_eq_one]
      have : orderOf (f ^ n) = orderOf f := by rw [h.orderOf, hr, hf.orderOf]
      rw [orderOf_pow, Nat.div_eq_self] at this
      cases' this with h
      Â· exact absurd h (orderOf_pos _).ne'
      Â· rwa [Nat.coprime_iff_gcd_eq_one, Nat.gcd_comm]
    Â· intro h
      obtain âŸ¨m, hmâŸ© := exists_pow_eq_self_of_coprime h
      have hf' : IsCycle ((f ^ n) ^ m) := by rwa [hm]
      refine' hf'.of_pow fun x hx => _
      rw [hm]
      exact support_pow_le _ n hx
#align equiv.perm.is_cycle.pow_iff Equiv.Perm.IsCycle.pow_iff

-- TODO: Define a `Set`-valued support to get rid of the `Finite Î²` assumption
theorem IsCycle.pow_eq_one_iff [Finite Î²] {f : Perm Î²} (hf : IsCycle f) {n : â„•} :
    f ^ n = 1 â†” âˆƒ x, f x â‰  x âˆ§ (f ^ n) x = x := by
  classical
    cases nonempty_fintype Î²
    constructor
    Â· intro h
      obtain âŸ¨x, hx, -âŸ© := id hf
      exact âŸ¨x, hx, by simp [h]âŸ©
    Â· rintro âŸ¨x, hx, hx'âŸ©
      by_cases h : support (f ^ n) = support f
      Â· rw [â† mem_support, â† h, mem_support] at hx
        contradiction
      Â· rw [hf.support_pow_eq_iff, Classical.not_not] at h
        obtain âŸ¨k, rflâŸ© := h
        rw [pow_mul, pow_orderOf_eq_one, one_pow]
#align equiv.perm.is_cycle.pow_eq_one_iff Equiv.Perm.IsCycle.pow_eq_one_iff

-- TODO: Define a `Set`-valued support to get rid of the `Finite Î²` assumption
theorem IsCycle.pow_eq_one_iff' [Finite Î²] {f : Perm Î²} (hf : IsCycle f) {n : â„•} {x : Î²}
    (hx : f x â‰  x) : f ^ n = 1 â†” (f ^ n) x = x :=
  âŸ¨fun h => FunLike.congr_fun h x, fun h => hf.pow_eq_one_iff.2 âŸ¨x, hx, hâŸ©âŸ©
#align equiv.perm.is_cycle.pow_eq_one_iff' Equiv.Perm.IsCycle.pow_eq_one_iff'

-- TODO: Define a `Set`-valued support to get rid of the `Finite Î²` assumption
theorem IsCycle.pow_eq_one_iff'' [Finite Î²] {f : Perm Î²} (hf : IsCycle f) {n : â„•} :
    f ^ n = 1 â†” âˆ€ x, f x â‰  x â†’ (f ^ n) x = x :=
  âŸ¨fun h _ hx => (hf.pow_eq_one_iff' hx).1 h, fun h =>
    let âŸ¨_, hx, _âŸ© := id hf
    (hf.pow_eq_one_iff' hx).2 (h _ hx)âŸ©
#align equiv.perm.is_cycle.pow_eq_one_iff'' Equiv.Perm.IsCycle.pow_eq_one_iff''

-- TODO: Define a `Set`-valued support to get rid of the `Finite Î²` assumption
theorem IsCycle.pow_eq_pow_iff [Finite Î²] {f : Perm Î²} (hf : IsCycle f) {a b : â„•} :
    f ^ a = f ^ b â†” âˆƒ x, f x â‰  x âˆ§ (f ^ a) x = (f ^ b) x := by
  classical
    cases nonempty_fintype Î²
    constructor
    Â· intro h
      obtain âŸ¨x, hx, -âŸ© := id hf
      exact âŸ¨x, hx, by simp [h]âŸ©
    Â· rintro âŸ¨x, hx, hx'âŸ©
      wlog hab : a â‰¤ b generalizing a b
      Â· exact (this hx'.symm (le_of_not_le hab)).symm
      suffices f ^ (b - a) = 1 by
        rw [pow_sub _ hab, mul_inv_eq_one] at this
        rw [this]
      rw [hf.pow_eq_one_iff]
      by_cases hfa : (f ^ a) x âˆˆ f.support
      Â· refine' âŸ¨(f ^ a) x, mem_support.mp hfa, _âŸ©
        simp only [pow_sub _ hab, Equiv.Perm.coe_mul, Function.comp_apply, inv_apply_self, â† hx']
      Â· have h := @Equiv.Perm.zpow_apply_comm _ f 1 a x
        simp only [zpow_one, zpow_ofNat] at h
        rw [not_mem_support, h, Function.Injective.eq_iff (f ^ a).injective] at hfa
        contradiction
#align equiv.perm.is_cycle.pow_eq_pow_iff Equiv.Perm.IsCycle.pow_eq_pow_iff

theorem IsCycle.isCycle_pow_pos_of_lt_prime_order [Finite Î²] {f : Perm Î²} (hf : IsCycle f)
    (hf' : (orderOf f).Prime) (n : â„•) (hn : 0 < n) (hn' : n < orderOf f) : IsCycle (f ^ n) := by
  classical
    cases nonempty_fintype Î²
    have : n.coprime (orderOf f) := by
      refine' Nat.coprime.symm _
      rw [Nat.Prime.coprime_iff_not_dvd hf']
      exact Nat.not_dvd_of_pos_of_lt hn hn'
    obtain âŸ¨m, hmâŸ© := exists_pow_eq_self_of_coprime this
    have hf'' := hf
    rw [â† hm] at hf''
    refine' hf''.of_pow _
    rw [hm]
    exact support_pow_le f n
#align equiv.perm.is_cycle.is_cycle_pow_pos_of_lt_prime_order Equiv.Perm.IsCycle.isCycle_pow_pos_of_lt_prime_order

end IsCycle

/-! ### `IsCycleOn` -/


section IsCycleOn

variable {f g : Perm Î±} {s t : Set Î±} {a b x y : Î±}

/-- A permutation is a cycle on `s` when any two points of `s` are related by repeated application
of the permutation. Note that this means the identity is a cycle of subsingleton sets. -/
def IsCycleOn (f : Perm Î±) (s : Set Î±) : Prop :=
  Set.BijOn f s s âˆ§ âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ âˆ€ â¦ƒyâ¦„, y âˆˆ s â†’ f.SameCycle x y
#align equiv.perm.is_cycle_on Equiv.Perm.IsCycleOn

@[simp]
theorem isCycleOn_empty : f.IsCycleOn âˆ… := by simp [IsCycleOn, Set.bijOn_empty]
                                              -- ğŸ‰ no goals
#align equiv.perm.is_cycle_on_empty Equiv.Perm.isCycleOn_empty

@[simp]
theorem isCycleOn_one : (1 : Perm Î±).IsCycleOn s â†” s.Subsingleton := by
  simp [IsCycleOn, Set.bijOn_id, Set.Subsingleton]
  -- ğŸ‰ no goals
#align equiv.perm.is_cycle_on_one Equiv.Perm.isCycleOn_one

alias âŸ¨IsCycleOn.subsingleton, _root_.Set.Subsingleton.isCycleOn_oneâŸ© := isCycleOn_one
#align equiv.perm.is_cycle_on.subsingleton Equiv.Perm.IsCycleOn.subsingleton
#align set.subsingleton.is_cycle_on_one Set.Subsingleton.isCycleOn_one

@[simp]
theorem isCycleOn_singleton : f.IsCycleOn {a} â†” f a = a := by simp [IsCycleOn, SameCycle.rfl]
                                                              -- ğŸ‰ no goals
#align equiv.perm.is_cycle_on_singleton Equiv.Perm.isCycleOn_singleton

theorem isCycleOn_of_subsingleton [Subsingleton Î±] (f : Perm Î±) (s : Set Î±) : f.IsCycleOn s :=
  âŸ¨s.bijOn_of_subsingleton _, fun x _ y _ => (Subsingleton.elim x y).sameCycle _âŸ©
#align equiv.perm.is_cycle_on_of_subsingleton Equiv.Perm.isCycleOn_of_subsingleton

@[simp]
theorem isCycleOn_inv : fâ»Â¹.IsCycleOn s â†” f.IsCycleOn s := by
  simp only [IsCycleOn, sameCycle_inv, and_congr_left_iff]
  -- âŠ¢ (âˆ€ â¦ƒx : Î±â¦„, x âˆˆ s â†’ âˆ€ â¦ƒy : Î±â¦„, y âˆˆ s â†’ SameCycle f x y) â†’ (Set.BijOn (â†‘fâ»Â¹)  â€¦
  exact fun _ â†¦ âŸ¨fun h â†¦ Set.BijOn.perm_inv h, fun h â†¦ Set.BijOn.perm_inv hâŸ©
  -- ğŸ‰ no goals
#align equiv.perm.is_cycle_on_inv Equiv.Perm.isCycleOn_inv

alias âŸ¨IsCycleOn.of_inv, IsCycleOn.invâŸ© := isCycleOn_inv
#align equiv.perm.is_cycle_on.of_inv Equiv.Perm.IsCycleOn.of_inv
#align equiv.perm.is_cycle_on.inv Equiv.Perm.IsCycleOn.inv

theorem IsCycleOn.conj (h : f.IsCycleOn s) : (g * f * gâ»Â¹).IsCycleOn ((g : Perm Î±) '' s) :=
  âŸ¨(g.bijOn_image.comp h.1).comp g.bijOn_symm_image, fun x hx y hy => by
    rw [â† preimage_inv] at hx hy
    -- âŠ¢ SameCycle (g * f * gâ»Â¹) x y
    convert Equiv.Perm.SameCycle.conj (h.2 hx hy) (g := g) <;> rw [apply_inv_self]âŸ©
    -- âŠ¢ x = â†‘g (â†‘gâ»Â¹ x)
                                                               -- ğŸ‰ no goals
                                                               -- ğŸ‰ no goals
#align equiv.perm.is_cycle_on.conj Equiv.Perm.IsCycleOn.conj

theorem isCycleOn_swap [DecidableEq Î±] (hab : a â‰  b) : (swap a b).IsCycleOn {a, b} :=
  âŸ¨bijOn_swap (by simp) (by simp), fun x hx y hy => by
                  -- ğŸ‰ no goals
                            -- ğŸ‰ no goals
    rw [Set.mem_insert_iff, Set.mem_singleton_iff] at hx hy
    -- âŠ¢ SameCycle (swap a b) x y
    obtain rfl | rfl := hx <;> obtain rfl | rfl := hy
    -- âŠ¢ SameCycle (swap x b) x y
                               -- âŠ¢ SameCycle (swap y b) y y
                               -- âŠ¢ SameCycle (swap y x) x y
    Â· exact âŸ¨0, by rw [zpow_zero, coe_one, id.def]âŸ©
      -- ğŸ‰ no goals
    Â· exact âŸ¨1, by rw [zpow_one, swap_apply_left]âŸ©
      -- ğŸ‰ no goals
    Â· exact âŸ¨1, by rw [zpow_one, swap_apply_right]âŸ©
      -- ğŸ‰ no goals
    Â· exact âŸ¨0, by rw [zpow_zero, coe_one, id.def]âŸ©âŸ©
      -- ğŸ‰ no goals
#align equiv.perm.is_cycle_on_swap Equiv.Perm.isCycleOn_swap

protected theorem IsCycleOn.apply_ne (hf : f.IsCycleOn s) (hs : s.Nontrivial) (ha : a âˆˆ s) :
    f a â‰  a := by
  obtain âŸ¨b, hb, hbaâŸ© := hs.exists_ne a
  -- âŠ¢ â†‘f a â‰  a
  obtain âŸ¨n, rflâŸ© := hf.2 ha hb
  -- âŠ¢ â†‘f a â‰  a
  exact fun h => hba (IsFixedPt.perm_zpow h n)
  -- ğŸ‰ no goals
#align equiv.perm.is_cycle_on.apply_ne Equiv.Perm.IsCycleOn.apply_ne

protected theorem IsCycle.isCycleOn (hf : f.IsCycle) : f.IsCycleOn { x | f x â‰  x } :=
  âŸ¨f.bijOn fun _ => f.apply_eq_iff_eq.not, fun _ ha _ => hf.sameCycle haâŸ©
#align equiv.perm.is_cycle.is_cycle_on Equiv.Perm.IsCycle.isCycleOn

/-- This lemma demonstrates the relation between `Equiv.Perm.IsCycle` and `Equiv.Perm.IsCycleOn`
in non-degenerate cases. -/
theorem isCycle_iff_exists_isCycleOn :
    f.IsCycle â†” âˆƒ s : Set Î±, s.Nontrivial âˆ§ f.IsCycleOn s âˆ§ âˆ€ â¦ƒxâ¦„, Â¬IsFixedPt f x â†’ x âˆˆ s := by
  refine' âŸ¨fun hf => âŸ¨{ x | f x â‰  x }, _, hf.isCycleOn, fun _ => idâŸ©, _âŸ©
  -- âŠ¢ Set.Nontrivial {x | â†‘f x â‰  x}
  Â· obtain âŸ¨a, haâŸ© := hf
    -- âŠ¢ Set.Nontrivial {x | â†‘f x â‰  x}
    exact âŸ¨f a, f.injective.ne ha.1, a, ha.1, ha.1âŸ©
    -- ğŸ‰ no goals
  Â· rintro âŸ¨s, hs, hf, hsfâŸ©
    -- âŠ¢ IsCycle f
    obtain âŸ¨a, haâŸ© := hs.nonempty
    -- âŠ¢ IsCycle f
    exact âŸ¨a, hf.apply_ne hs ha, fun b hb => hf.2 ha <| hsf hbâŸ©
    -- ğŸ‰ no goals
#align equiv.perm.is_cycle_iff_exists_is_cycle_on Equiv.Perm.isCycle_iff_exists_isCycleOn

theorem IsCycleOn.apply_mem_iff (hf : f.IsCycleOn s) : f x âˆˆ s â†” x âˆˆ s :=
  âŸ¨fun hx => by
    convert hf.1.perm_inv.1 hx
    -- âŠ¢ x = â†‘fâ»Â¹ (â†‘f x)
    rw [inv_apply_self], fun hx => hf.1.mapsTo hxâŸ©
    -- ğŸ‰ no goals
#align equiv.perm.is_cycle_on.apply_mem_iff Equiv.Perm.IsCycleOn.apply_mem_iff

/-- Note that the identity satisfies `IsCycleOn` for any subsingleton set, but not `IsCycle`. -/
theorem IsCycleOn.isCycle_subtypePerm (hf : f.IsCycleOn s) (hs : s.Nontrivial) :
    (f.subtypePerm fun _ => hf.apply_mem_iff.symm : Perm s).IsCycle := by
  obtain âŸ¨a, haâŸ© := hs.nonempty
  -- âŠ¢ IsCycle (subtypePerm f (_ : âˆ€ (x : Î±), x âˆˆ s â†” â†‘f x âˆˆ s))
  exact
    âŸ¨âŸ¨a, haâŸ©, ne_of_apply_ne ((â†‘) : s â†’ Î±) (hf.apply_ne hs ha), fun b _ =>
      (hf.2 (âŸ¨a, haâŸ© : s).2 b.2).subtypePermâŸ©
#align equiv.perm.is_cycle_on.is_cycle_subtype_perm Equiv.Perm.IsCycleOn.isCycle_subtypePerm

/-- Note that the identity is a cycle on any subsingleton set, but not a cycle. -/
protected theorem IsCycleOn.subtypePerm (hf : f.IsCycleOn s) :
    (f.subtypePerm fun _ => hf.apply_mem_iff.symm : Perm s).IsCycleOn _root_.Set.univ := by
  obtain hs | hs := s.subsingleton_or_nontrivial
  -- âŠ¢ IsCycleOn (subtypePerm f (_ : âˆ€ (x : Î±), x âˆˆ s â†” â†‘f x âˆˆ s)) _root_.Set.univ
  Â· haveI := hs.coe_sort
    -- âŠ¢ IsCycleOn (subtypePerm f (_ : âˆ€ (x : Î±), x âˆˆ s â†” â†‘f x âˆˆ s)) _root_.Set.univ
    exact isCycleOn_of_subsingleton _ _
    -- ğŸ‰ no goals
  convert (hf.isCycle_subtypePerm hs).isCycleOn
  -- âŠ¢ _root_.Set.univ = {x | â†‘(subtypePerm f (_ : âˆ€ (x : Î±), x âˆˆ s â†” â†‘f x âˆˆ s)) x  â€¦
  rw [eq_comm, Set.eq_univ_iff_forall]
  -- âŠ¢ âˆ€ (x : { x // x âˆˆ s }), x âˆˆ {x | â†‘(subtypePerm f (_ : âˆ€ (x : Î±), x âˆˆ s â†” â†‘f  â€¦
  exact fun x => ne_of_apply_ne ((â†‘) : s â†’ Î±) (hf.apply_ne hs x.2)
  -- ğŸ‰ no goals
#align equiv.perm.is_cycle_on.subtype_perm Equiv.Perm.IsCycleOn.subtypePerm

-- TODO: Theory of order of an element under an action
theorem IsCycleOn.pow_apply_eq {s : Finset Î±} (hf : f.IsCycleOn s) (ha : a âˆˆ s) {n : â„•} :
    (f ^ n) a = a â†” s.card âˆ£ n := by
  obtain rfl | hs := Finset.eq_singleton_or_nontrivial ha
  -- âŠ¢ â†‘(f ^ n) a = a â†” card {a} âˆ£ n
  Â· rw [coe_singleton, isCycleOn_singleton] at hf
    -- âŠ¢ â†‘(f ^ n) a = a â†” card {a} âˆ£ n
    simpa using IsFixedPt.iterate hf n
    -- ğŸ‰ no goals
  classical
    have h : âˆ€ x âˆˆ s.attach, Â¬f â†‘x = â†‘x := fun x _ => hf.apply_ne hs x.2
    have := (hf.isCycle_subtypePerm hs).orderOf
    simp only [coe_sort_coe, support_subtype_perm, ne_eq, decide_not, Bool.not_eq_true',
      decide_eq_false_iff_not, mem_attach, forall_true_left, Subtype.forall, filter_true_of_mem h,
      card_attach] at this
    rw [â† this, orderOf_dvd_iff_pow_eq_one,
      (hf.isCycle_subtypePerm hs).pow_eq_one_iff'
        (ne_of_apply_ne ((â†‘) : s â†’ Î±) <| hf.apply_ne hs (âŸ¨a, haâŸ© : s).2)]
    simp
#align equiv.perm.is_cycle_on.pow_apply_eq Equiv.Perm.IsCycleOn.pow_apply_eq

theorem IsCycleOn.zpow_apply_eq {s : Finset Î±} (hf : f.IsCycleOn s) (ha : a âˆˆ s) :
    âˆ€ {n : â„¤}, (f ^ n) a = a â†” (s.card : â„¤) âˆ£ n
  | Int.ofNat n => (hf.pow_apply_eq ha).trans Int.coe_nat_dvd.symm
  | Int.negSucc n => by
    rw [zpow_negSucc, â† inv_pow]
    -- âŠ¢ â†‘(fâ»Â¹ ^ (n + 1)) a = a â†” â†‘(card s) âˆ£ Int.negSucc n
    exact (hf.inv.pow_apply_eq ha).trans (dvd_neg.trans Int.coe_nat_dvd).symm
    -- ğŸ‰ no goals
#align equiv.perm.is_cycle_on.zpow_apply_eq Equiv.Perm.IsCycleOn.zpow_apply_eq

theorem IsCycleOn.pow_apply_eq_pow_apply {s : Finset Î±} (hf : f.IsCycleOn s) (ha : a âˆˆ s)
    {m n : â„•} : (f ^ m) a = (f ^ n) a â†” m â‰¡ n [MOD s.card] := by
  rw [Nat.modEq_iff_dvd, â† hf.zpow_apply_eq ha]
  -- âŠ¢ â†‘(f ^ m) a = â†‘(f ^ n) a â†” â†‘(f ^ (â†‘n - â†‘m)) a = a
  simp [sub_eq_neg_add, zpow_add, eq_inv_iff_eq, eq_comm]
  -- ğŸ‰ no goals
#align equiv.perm.is_cycle_on.pow_apply_eq_pow_apply Equiv.Perm.IsCycleOn.pow_apply_eq_pow_apply

theorem IsCycleOn.zpow_apply_eq_zpow_apply {s : Finset Î±} (hf : f.IsCycleOn s) (ha : a âˆˆ s)
    {m n : â„¤} : (f ^ m) a = (f ^ n) a â†” m â‰¡ n [ZMOD s.card] := by
  rw [Int.modEq_iff_dvd, â† hf.zpow_apply_eq ha]
  -- âŠ¢ â†‘(f ^ m) a = â†‘(f ^ n) a â†” â†‘(f ^ (n - m)) a = a
  simp [sub_eq_neg_add, zpow_add, eq_inv_iff_eq, eq_comm]
  -- ğŸ‰ no goals
#align equiv.perm.is_cycle_on.zpow_apply_eq_zpow_apply Equiv.Perm.IsCycleOn.zpow_apply_eq_zpow_apply

theorem IsCycleOn.pow_card_apply {s : Finset Î±} (hf : f.IsCycleOn s) (ha : a âˆˆ s) :
    (f ^ s.card) a = a :=
  (hf.pow_apply_eq ha).2 dvd_rfl
#align equiv.perm.is_cycle_on.pow_card_apply Equiv.Perm.IsCycleOn.pow_card_apply

theorem IsCycleOn.exists_pow_eq {s : Finset Î±} (hf : f.IsCycleOn s) (ha : a âˆˆ s) (hb : b âˆˆ s) :
    âˆƒ n < s.card, (f ^ n) a = b := by
  classical
    obtain âŸ¨n, rflâŸ© := hf.2 ha hb
    obtain âŸ¨k, hkâŸ© := (Int.mod_modEq n s.card).symm.dvd
    refine' âŸ¨n.natMod s.card, Int.natMod_lt (Nonempty.card_pos âŸ¨a, haâŸ©).ne', _âŸ©
    rw [â† zpow_ofNat, Int.natMod,
      Int.toNat_of_nonneg (Int.emod_nonneg _ <| Nat.cast_ne_zero.2
        (Nonempty.card_pos âŸ¨a, haâŸ©).ne'), sub_eq_iff_eq_add'.1 hk, zpow_add, zpow_mul]
    simp only [zpow_coe_nat, coe_mul, comp_apply, EmbeddingLike.apply_eq_iff_eq]
    exact IsFixedPt.perm_zpow (hf.pow_card_apply ha) _
#align equiv.perm.is_cycle_on.exists_pow_eq Equiv.Perm.IsCycleOn.exists_pow_eq

theorem IsCycleOn.exists_pow_eq' (hs : s.Finite) (hf : f.IsCycleOn s) (ha : a âˆˆ s) (hb : b âˆˆ s) :
    âˆƒ n : â„•, (f ^ n) a = b := by
  lift s to Finset Î± using id hs
  -- âŠ¢ âˆƒ n, â†‘(f ^ n) a = b
  obtain âŸ¨n, -, hnâŸ© := hf.exists_pow_eq ha hb
  -- âŠ¢ âˆƒ n, â†‘(f ^ n) a = b
  exact âŸ¨n, hnâŸ©
  -- ğŸ‰ no goals
#align equiv.perm.is_cycle_on.exists_pow_eq' Equiv.Perm.IsCycleOn.exists_pow_eq'

theorem IsCycleOn.range_pow (hs : s.Finite) (h : f.IsCycleOn s) (ha : a âˆˆ s) :
    Set.range (fun n => (f ^ n) a : â„• â†’ Î±) = s :=
  Set.Subset.antisymm (Set.range_subset_iff.2 fun _ => h.1.mapsTo.perm_pow _ ha) fun _ =>
    h.exists_pow_eq' hs ha
#align equiv.perm.is_cycle_on.range_pow Equiv.Perm.IsCycleOn.range_pow

theorem IsCycleOn.range_zpow (h : f.IsCycleOn s) (ha : a âˆˆ s) :
    Set.range (fun n => (f ^ n) a : â„¤ â†’ Î±) = s :=
  Set.Subset.antisymm (Set.range_subset_iff.2 fun _ => (h.1.perm_zpow _).mapsTo ha) <| h.2 ha
#align equiv.perm.is_cycle_on.range_zpow Equiv.Perm.IsCycleOn.range_zpow

theorem IsCycleOn.of_pow {n : â„•} (hf : (f ^ n).IsCycleOn s) (h : Set.BijOn f s s) : f.IsCycleOn s :=
  âŸ¨h, fun _ hx _ hy => (hf.2 hx hy).of_powâŸ©
#align equiv.perm.is_cycle_on.of_pow Equiv.Perm.IsCycleOn.of_pow

theorem IsCycleOn.of_zpow {n : â„¤} (hf : (f ^ n).IsCycleOn s) (h : Set.BijOn f s s) :
    f.IsCycleOn s :=
  âŸ¨h, fun _ hx _ hy => (hf.2 hx hy).of_zpowâŸ©
#align equiv.perm.is_cycle_on.of_zpow Equiv.Perm.IsCycleOn.of_zpow

theorem IsCycleOn.extendDomain {p : Î² â†’ Prop} [DecidablePred p] (f : Î± â‰ƒ Subtype p)
    (h : g.IsCycleOn s) : (g.extendDomain f).IsCycleOn ((â†‘) âˆ˜ f '' s) :=
  âŸ¨h.1.extendDomain, by
    rintro _ âŸ¨a, ha, rflâŸ© _ âŸ¨b, hb, rflâŸ©
    -- âŠ¢ SameCycle (Perm.extendDomain g f) ((Subtype.val âˆ˜ â†‘f) a) ((Subtype.val âˆ˜ â†‘f) â€¦
    exact (h.2 ha hb).extendDomainâŸ©
    -- ğŸ‰ no goals
#align equiv.perm.is_cycle_on.extend_domain Equiv.Perm.IsCycleOn.extendDomain

protected theorem IsCycleOn.countable (hs : f.IsCycleOn s) : s.Countable := by
  obtain rfl | âŸ¨a, haâŸ© := s.eq_empty_or_nonempty
  -- âŠ¢ Set.Countable âˆ…
  Â· exact Set.countable_empty
    -- ğŸ‰ no goals
  Â· exact (Set.countable_range fun n : â„¤ => (â‡‘(f ^ n) : Î± â†’ Î±) a).mono (hs.2 ha)
    -- ğŸ‰ no goals
#align equiv.perm.is_cycle_on.countable Equiv.Perm.IsCycleOn.countable

end IsCycleOn

/-!
### `cycleOf`
-/


section CycleOf

variable [DecidableEq Î±] [Fintype Î±] {f g : Perm Î±} {x y : Î±}

/-- `f.cycleOf x` is the cycle of the permutation `f` to which `x` belongs. -/
def cycleOf (f : Perm Î±) (x : Î±) : Perm Î± :=
  ofSubtype (subtypePerm f fun _ => sameCycle_apply_right.symm : Perm { y // SameCycle f x y })
#align equiv.perm.cycle_of Equiv.Perm.cycleOf

theorem cycleOf_apply (f : Perm Î±) (x y : Î±) :
    cycleOf f x y = if SameCycle f x y then f y else y := by
  dsimp only [cycleOf]
  -- âŠ¢ â†‘(â†‘ofSubtype (subtypePerm f (_ : âˆ€ (x_1 : Î±), SameCycle f x x_1 â†” SameCycle  â€¦
  split_ifs with h
  -- âŠ¢ â†‘(â†‘ofSubtype (subtypePerm f (_ : âˆ€ (x_1 : Î±), SameCycle f x x_1 â†” SameCycle  â€¦
  Â· apply ofSubtype_apply_of_mem
    -- âŠ¢ SameCycle f x y
    exact h
    -- ğŸ‰ no goals
  Â· apply ofSubtype_apply_of_not_mem
    -- âŠ¢ Â¬SameCycle f x y
    exact h
    -- ğŸ‰ no goals
#align equiv.perm.cycle_of_apply Equiv.Perm.cycleOf_apply

theorem cycleOf_inv (f : Perm Î±) (x : Î±) : (cycleOf f x)â»Â¹ = cycleOf fâ»Â¹ x :=
  Equiv.ext fun y => by
    rw [inv_eq_iff_eq, cycleOf_apply, cycleOf_apply]
    -- âŠ¢ y = if SameCycle f x (if SameCycle fâ»Â¹ x y then â†‘fâ»Â¹ y else y) then â†‘f (if S â€¦
    split_ifs <;> simp_all [sameCycle_inv, sameCycle_inv_apply_right]
                  -- ğŸ‰ no goals
                  -- ğŸ‰ no goals
                  -- ğŸ‰ no goals
                  -- ğŸ‰ no goals
#align equiv.perm.cycle_of_inv Equiv.Perm.cycleOf_inv

@[simp]
theorem cycleOf_pow_apply_self (f : Perm Î±) (x : Î±) : âˆ€ n : â„•, (cycleOf f x ^ n) x = (f ^ n) x := by
  intro n
  -- âŠ¢ â†‘(cycleOf f x ^ n) x = â†‘(f ^ n) x
  induction' n with n hn
  -- âŠ¢ â†‘(cycleOf f x ^ Nat.zero) x = â†‘(f ^ Nat.zero) x
  Â· rfl
    -- ğŸ‰ no goals
  Â· rw [pow_succ, mul_apply, cycleOf_apply, hn, if_pos, pow_succ, mul_apply]
    -- âŠ¢ SameCycle f x (â†‘(f ^ n) x)
    simpa [SameCycle] using âŸ¨n,rflâŸ©
    -- ğŸ‰ no goals
#align equiv.perm.cycle_of_pow_apply_self Equiv.Perm.cycleOf_pow_apply_self

@[simp]
theorem cycleOf_zpow_apply_self (f : Perm Î±) (x : Î±) :
    âˆ€ n : â„¤, (cycleOf f x ^ n) x = (f ^ n) x := by
  intro z
  -- âŠ¢ â†‘(cycleOf f x ^ z) x = â†‘(f ^ z) x
  induction' z with z hz
  -- âŠ¢ â†‘(cycleOf f x ^ Int.ofNat z) x = â†‘(f ^ Int.ofNat z) x
  Â· exact cycleOf_pow_apply_self f x z
    -- ğŸ‰ no goals
  Â· rw [zpow_negSucc, â† inv_pow, cycleOf_inv, zpow_negSucc, â† inv_pow, cycleOf_pow_apply_self]
    -- ğŸ‰ no goals
#align equiv.perm.cycle_of_zpow_apply_self Equiv.Perm.cycleOf_zpow_apply_self

theorem SameCycle.cycleOf_apply : SameCycle f x y â†’ cycleOf f x y = f y :=
  ofSubtype_apply_of_mem _
#align equiv.perm.same_cycle.cycle_of_apply Equiv.Perm.SameCycle.cycleOf_apply

theorem cycleOf_apply_of_not_sameCycle : Â¬SameCycle f x y â†’ cycleOf f x y = y :=
  ofSubtype_apply_of_not_mem _
#align equiv.perm.cycle_of_apply_of_not_same_cycle Equiv.Perm.cycleOf_apply_of_not_sameCycle

theorem SameCycle.cycleOf_eq (h : SameCycle f x y) : cycleOf f x = cycleOf f y := by
  ext z
  -- âŠ¢ â†‘(cycleOf f x) z = â†‘(cycleOf f y) z
  rw [Equiv.Perm.cycleOf_apply]
  -- âŠ¢ (if SameCycle f x z then â†‘f z else z) = â†‘(cycleOf f y) z
  split_ifs with hz
  -- âŠ¢ â†‘f z = â†‘(cycleOf f y) z
  Â· exact (h.symm.trans hz).cycleOf_apply.symm
    -- ğŸ‰ no goals
  Â· exact (cycleOf_apply_of_not_sameCycle (mt h.trans hz)).symm
    -- ğŸ‰ no goals
#align equiv.perm.same_cycle.cycle_of_eq Equiv.Perm.SameCycle.cycleOf_eq

@[simp]
theorem cycleOf_apply_apply_zpow_self (f : Perm Î±) (x : Î±) (k : â„¤) :
    cycleOf f x ((f ^ k) x) = (f ^ (k + 1) : Perm Î±) x := by
  rw [SameCycle.cycleOf_apply]
  -- âŠ¢ â†‘f (â†‘(f ^ k) x) = â†‘(f ^ (k + 1)) x
  Â· rw [add_comm, zpow_add, zpow_one, mul_apply]
    -- ğŸ‰ no goals
  Â· exact âŸ¨k, rflâŸ©
    -- ğŸ‰ no goals
#align equiv.perm.cycle_of_apply_apply_zpow_self Equiv.Perm.cycleOf_apply_apply_zpow_self

@[simp]
theorem cycleOf_apply_apply_pow_self (f : Perm Î±) (x : Î±) (k : â„•) :
    cycleOf f x ((f ^ k) x) = (f ^ (k + 1) : Perm Î±) x := by
  convert cycleOf_apply_apply_zpow_self f x k using 1
  -- ğŸ‰ no goals
#align equiv.perm.cycle_of_apply_apply_pow_self Equiv.Perm.cycleOf_apply_apply_pow_self

@[simp]
theorem cycleOf_apply_apply_self (f : Perm Î±) (x : Î±) : cycleOf f x (f x) = f (f x) := by
  convert cycleOf_apply_apply_pow_self f x 1 using 1
  -- ğŸ‰ no goals
#align equiv.perm.cycle_of_apply_apply_self Equiv.Perm.cycleOf_apply_apply_self

@[simp]
theorem cycleOf_apply_self (f : Perm Î±) (x : Î±) : cycleOf f x x = f x :=
  SameCycle.rfl.cycleOf_apply
#align equiv.perm.cycle_of_apply_self Equiv.Perm.cycleOf_apply_self

theorem IsCycle.cycleOf_eq (hf : IsCycle f) (hx : f x â‰  x) : cycleOf f x = f :=
  Equiv.ext fun y =>
    if h : SameCycle f x y then by rw [h.cycleOf_apply]
                                   -- ğŸ‰ no goals
    else by
      rw [cycleOf_apply_of_not_sameCycle h,
        Classical.not_not.1 (mt ((isCycle_iff_sameCycle hx).1 hf).2 h)]
#align equiv.perm.is_cycle.cycle_of_eq Equiv.Perm.IsCycle.cycleOf_eq

@[simp]
theorem cycleOf_eq_one_iff (f : Perm Î±) : cycleOf f x = 1 â†” f x = x := by
  simp_rw [ext_iff, cycleOf_apply, one_apply]
  -- âŠ¢ (âˆ€ (x_1 : Î±), (if SameCycle f x x_1 then â†‘f x_1 else x_1) = x_1) â†” â†‘f x = x
  refine' âŸ¨fun h => (if_pos (SameCycle.refl f x)).symm.trans (h x), fun h y => _âŸ©
  -- âŠ¢ (if SameCycle f x y then â†‘f y else y) = y
  by_cases hy : f y = y
  -- âŠ¢ (if SameCycle f x y then â†‘f y else y) = y
  Â· rw [hy, ite_self]
    -- ğŸ‰ no goals
  Â· exact if_neg (mt SameCycle.apply_eq_self_iff (by tauto))
    -- ğŸ‰ no goals
#align equiv.perm.cycle_of_eq_one_iff Equiv.Perm.cycleOf_eq_one_iff

@[simp]
theorem cycleOf_self_apply (f : Perm Î±) (x : Î±) : cycleOf f (f x) = cycleOf f x :=
  (sameCycle_apply_right.2 SameCycle.rfl).symm.cycleOf_eq
#align equiv.perm.cycle_of_self_apply Equiv.Perm.cycleOf_self_apply

@[simp]
theorem cycleOf_self_apply_pow (f : Perm Î±) (n : â„•) (x : Î±) : cycleOf f ((f ^ n) x) = cycleOf f x :=
  SameCycle.rfl.pow_left.cycleOf_eq
#align equiv.perm.cycle_of_self_apply_pow Equiv.Perm.cycleOf_self_apply_pow

@[simp]
theorem cycleOf_self_apply_zpow (f : Perm Î±) (n : â„¤) (x : Î±) :
    cycleOf f ((f ^ n) x) = cycleOf f x :=
  SameCycle.rfl.zpow_left.cycleOf_eq
#align equiv.perm.cycle_of_self_apply_zpow Equiv.Perm.cycleOf_self_apply_zpow

protected theorem IsCycle.cycleOf (hf : IsCycle f) : cycleOf f x = if f x = x then 1 else f := by
  by_cases hx : f x = x
  -- âŠ¢ cycleOf f x = if â†‘f x = x then 1 else f
  Â· rwa [if_pos hx, cycleOf_eq_one_iff]
    -- ğŸ‰ no goals
  Â· rwa [if_neg hx, hf.cycleOf_eq]
    -- ğŸ‰ no goals
#align equiv.perm.is_cycle.cycle_of Equiv.Perm.IsCycle.cycleOf

theorem cycleOf_one (x : Î±) : cycleOf 1 x = 1 :=
  (cycleOf_eq_one_iff 1).mpr rfl
#align equiv.perm.cycle_of_one Equiv.Perm.cycleOf_one

theorem isCycle_cycleOf (f : Perm Î±) (hx : f x â‰  x) : IsCycle (cycleOf f x) :=
  have : cycleOf f x x â‰  x := by rwa [SameCycle.rfl.cycleOf_apply]
                                 -- ğŸ‰ no goals
  (isCycle_iff_sameCycle this).2 @fun y =>
    âŸ¨fun h => mt h.apply_eq_self_iff.2 this, fun h =>
      if hxy : SameCycle f x y then
        let âŸ¨i, hiâŸ© := hxy
        âŸ¨i, by rw [cycleOf_zpow_apply_self, hi]âŸ©
               -- ğŸ‰ no goals
      else by
        rw [cycleOf_apply_of_not_sameCycle hxy] at h
        -- âŠ¢ SameCycle (cycleOf f x) x y
        exact (h rfl).elimâŸ©
        -- ğŸ‰ no goals
#align equiv.perm.is_cycle_cycle_of Equiv.Perm.isCycle_cycleOf

@[simp]
theorem two_le_card_support_cycleOf_iff : 2 â‰¤ card (cycleOf f x).support â†” f x â‰  x := by
  refine' âŸ¨fun h => _, fun h => by simpa using (isCycle_cycleOf _ h).two_le_card_supportâŸ©
  -- âŠ¢ â†‘f x â‰  x
  contrapose! h
  -- âŠ¢ card (support (cycleOf f x)) < 2
  rw [â† cycleOf_eq_one_iff] at h
  -- âŠ¢ card (support (cycleOf f x)) < 2
  simp [h]
  -- ğŸ‰ no goals
#align equiv.perm.two_le_card_support_cycle_of_iff Equiv.Perm.two_le_card_support_cycleOf_iff

@[simp]
theorem card_support_cycleOf_pos_iff : 0 < card (cycleOf f x).support â†” f x â‰  x := by
  rw [â† two_le_card_support_cycleOf_iff, â† Nat.succ_le_iff]
  -- âŠ¢ Nat.succ 0 â‰¤ card (support (cycleOf f x)) â†” 2 â‰¤ card (support (cycleOf f x))
  exact âŸ¨fun h => Or.resolve_left h.eq_or_lt (card_support_ne_one _).symm, zero_lt_two.trans_leâŸ©
  -- ğŸ‰ no goals
#align equiv.perm.card_support_cycle_of_pos_iff Equiv.Perm.card_support_cycleOf_pos_iff

theorem pow_apply_eq_pow_mod_orderOf_cycleOf_apply (f : Perm Î±) (n : â„•) (x : Î±) :
    (f ^ n) x = (f ^ (n % orderOf (cycleOf f x))) x := by
  rw [â† cycleOf_pow_apply_self f, â† cycleOf_pow_apply_self f, pow_eq_mod_orderOf]
  -- ğŸ‰ no goals
#align equiv.perm.pow_apply_eq_pow_mod_order_of_cycle_of_apply Equiv.Perm.pow_apply_eq_pow_mod_orderOf_cycleOf_apply

theorem cycleOf_mul_of_apply_right_eq_self (h : Commute f g) (x : Î±) (hx : g x = x) :
    (f * g).cycleOf x = f.cycleOf x := by
  ext y
  -- âŠ¢ â†‘(cycleOf (f * g) x) y = â†‘(cycleOf f x) y
  by_cases hxy : (f * g).SameCycle x y
  -- âŠ¢ â†‘(cycleOf (f * g) x) y = â†‘(cycleOf f x) y
  Â· obtain âŸ¨z, rflâŸ© := hxy
    -- âŠ¢ â†‘(cycleOf (f * g) x) (â†‘((f * g) ^ z) x) = â†‘(cycleOf f x) (â†‘((f * g) ^ z) x)
    rw [cycleOf_apply_apply_zpow_self]
    -- âŠ¢ â†‘((f * g) ^ (z + 1)) x = â†‘(cycleOf f x) (â†‘((f * g) ^ z) x)
    simp [h.mul_zpow, zpow_apply_eq_self_of_apply_eq_self hx]
    -- ğŸ‰ no goals
  Â· rw [cycleOf_apply_of_not_sameCycle hxy, cycleOf_apply_of_not_sameCycle]
    -- âŠ¢ Â¬SameCycle f x y
    contrapose! hxy
    -- âŠ¢ SameCycle (f * g) x y
    obtain âŸ¨z, rflâŸ© := hxy
    -- âŠ¢ SameCycle (f * g) x (â†‘(f ^ z) x)
    refine' âŸ¨z, _âŸ©
    -- âŠ¢ â†‘((f * g) ^ z) x = â†‘(f ^ z) x
    simp [h.mul_zpow, zpow_apply_eq_self_of_apply_eq_self hx]
    -- ğŸ‰ no goals
#align equiv.perm.cycle_of_mul_of_apply_right_eq_self Equiv.Perm.cycleOf_mul_of_apply_right_eq_self

theorem Disjoint.cycleOf_mul_distrib (h : f.Disjoint g) (x : Î±) :
    (f * g).cycleOf x = f.cycleOf x * g.cycleOf x := by
  cases' (disjoint_iff_eq_or_eq.mp h) x with hfx hgx
  -- âŠ¢ cycleOf (f * g) x = cycleOf f x * cycleOf g x
  Â· simp [h.commute.eq, cycleOf_mul_of_apply_right_eq_self h.symm.commute, hfx]
    -- ğŸ‰ no goals
  Â· simp [cycleOf_mul_of_apply_right_eq_self h.commute, hgx]
    -- ğŸ‰ no goals
#align equiv.perm.disjoint.cycle_of_mul_distrib Equiv.Perm.Disjoint.cycleOf_mul_distrib

theorem support_cycleOf_eq_nil_iff : (f.cycleOf x).support = âˆ… â†” x âˆ‰ f.support := by simp
                                                                                     -- ğŸ‰ no goals
#align equiv.perm.support_cycle_of_eq_nil_iff Equiv.Perm.support_cycleOf_eq_nil_iff

theorem support_cycleOf_le (f : Perm Î±) (x : Î±) : support (f.cycleOf x) â‰¤ support f := by
  intro y hy
  -- âŠ¢ y âˆˆ support f
  rw [mem_support, cycleOf_apply] at hy
  -- âŠ¢ y âˆˆ support f
  split_ifs at hy
  -- âŠ¢ y âˆˆ support f
  Â· exact mem_support.mpr hy
    -- ğŸ‰ no goals
  Â· exact absurd rfl hy
    -- ğŸ‰ no goals
#align equiv.perm.support_cycle_of_le Equiv.Perm.support_cycleOf_le

theorem mem_support_cycleOf_iff : y âˆˆ support (f.cycleOf x) â†” SameCycle f x y âˆ§ x âˆˆ support f := by
  by_cases hx : f x = x
  -- âŠ¢ y âˆˆ support (cycleOf f x) â†” SameCycle f x y âˆ§ x âˆˆ support f
  Â· rw [(cycleOf_eq_one_iff _).mpr hx]
    -- âŠ¢ y âˆˆ support 1 â†” SameCycle f x y âˆ§ x âˆˆ support f
    simp [hx]
    -- ğŸ‰ no goals
  Â· rw [mem_support, cycleOf_apply]
    -- âŠ¢ (if SameCycle f x y then â†‘f y else y) â‰  y â†” SameCycle f x y âˆ§ x âˆˆ support f
    split_ifs with hy
    -- âŠ¢ â†‘f y â‰  y â†” SameCycle f x y âˆ§ x âˆˆ support f
    Â· simp only [hx, hy, iff_true_iff, Ne.def, not_false_iff, and_self_iff, mem_support]
      -- âŠ¢ Â¬â†‘f y = y
      rcases hy with âŸ¨k, rflâŸ©
      -- âŠ¢ Â¬â†‘f (â†‘(f ^ k) x) = â†‘(f ^ k) x
      rw [â† not_mem_support]
      -- âŠ¢ Â¬Â¬â†‘(f ^ k) x âˆˆ support f
      simpa using hx
      -- ğŸ‰ no goals
    Â· simpa [hx] using hy
      -- ğŸ‰ no goals
#align equiv.perm.mem_support_cycle_of_iff Equiv.Perm.mem_support_cycleOf_iff

theorem mem_support_cycleOf_iff' (hx : f x â‰  x) : y âˆˆ support (f.cycleOf x) â†” SameCycle f x y := by
  rw [mem_support_cycleOf_iff, and_iff_left (mem_support.2 hx)]
  -- ğŸ‰ no goals
#align equiv.perm.mem_support_cycle_of_iff' Equiv.Perm.mem_support_cycleOf_iff'

theorem SameCycle.mem_support_iff (h : SameCycle f x y) : x âˆˆ support f â†” y âˆˆ support f :=
  âŸ¨fun hx => support_cycleOf_le f x (mem_support_cycleOf_iff.mpr âŸ¨h, hxâŸ©), fun hy =>
    support_cycleOf_le f y (mem_support_cycleOf_iff.mpr âŸ¨h.symm, hyâŸ©)âŸ©
#align equiv.perm.same_cycle.mem_support_iff Equiv.Perm.SameCycle.mem_support_iff

theorem pow_mod_card_support_cycleOf_self_apply (f : Perm Î±) (n : â„•) (x : Î±) :
    (f ^ (n % (f.cycleOf x).support.card)) x = (f ^ n) x := by
  by_cases hx : f x = x
  -- âŠ¢ â†‘(f ^ (n % card (support (cycleOf f x)))) x = â†‘(f ^ n) x
  Â· rw [pow_apply_eq_self_of_apply_eq_self hx, pow_apply_eq_self_of_apply_eq_self hx]
    -- ğŸ‰ no goals
  Â· rw [â† cycleOf_pow_apply_self, â† cycleOf_pow_apply_self f, â† (isCycle_cycleOf f hx).orderOf,
      â† pow_eq_mod_orderOf]
#align equiv.perm.pow_mod_card_support_cycle_of_self_apply Equiv.Perm.pow_mod_card_support_cycleOf_self_apply

/-- `x` is in the support of `f` iff `Equiv.Perm.cycle_of f x` is a cycle. -/
theorem isCycle_cycleOf_iff (f : Perm Î±) : IsCycle (cycleOf f x) â†” f x â‰  x := by
  refine' âŸ¨fun hx => _, f.isCycle_cycleOfâŸ©
  -- âŠ¢ â†‘f x â‰  x
  rw [Ne.def, â† cycleOf_eq_one_iff f]
  -- âŠ¢ Â¬cycleOf f x = 1
  exact hx.ne_one
  -- ğŸ‰ no goals
#align equiv.perm.is_cycle_cycle_of_iff Equiv.Perm.isCycle_cycleOf_iff

theorem isCycleOn_support_cycleOf (f : Perm Î±) (x : Î±) : f.IsCycleOn (f.cycleOf x).support :=
  âŸ¨f.bijOn <| by
    refine fun _ â†¦ âŸ¨fun h â†¦ mem_support_cycleOf_iff.2 ?_, fun h â†¦ mem_support_cycleOf_iff.2 ?_âŸ©
    -- âŠ¢ SameCycle f x xâœ âˆ§ x âˆˆ support f
    Â· exact âŸ¨sameCycle_apply_right.1 (mem_support_cycleOf_iff.1 h).1,
      (mem_support_cycleOf_iff.1 h).2âŸ©
    Â· exact âŸ¨sameCycle_apply_right.2 (mem_support_cycleOf_iff.1 h).1,
      (mem_support_cycleOf_iff.1 h).2âŸ©
    , fun a ha b hb =>
      by
        rw [mem_coe, mem_support_cycleOf_iff] at ha hb
        -- âŠ¢ SameCycle f a b
        exact ha.1.symm.trans hb.1âŸ©
        -- ğŸ‰ no goals
#align equiv.perm.is_cycle_on_support_cycle_of Equiv.Perm.isCycleOn_support_cycleOf

theorem SameCycle.exists_pow_eq_of_mem_support (h : SameCycle f x y) (hx : x âˆˆ f.support) :
    âˆƒ (i : â„•) (_ : i < (f.cycleOf x).support.card), (f ^ i) x = y := by
  rw [mem_support] at hx
  -- âŠ¢ âˆƒ i x_1, â†‘(f ^ i) x = y
  have := Equiv.Perm.IsCycleOn.exists_pow_eq (b := y) (f.isCycleOn_support_cycleOf x)
    (by rw [mem_support_cycleOf_iff' hx]) (by rwa [mem_support_cycleOf_iff' hx])
  simp_rw [â† exists_prop] at this
  -- âŠ¢ âˆƒ i x_1, â†‘(f ^ i) x = y
  exact this
  -- ğŸ‰ no goals
#align equiv.perm.same_cycle.exists_pow_eq_of_mem_support Equiv.Perm.SameCycle.exists_pow_eq_of_mem_support

theorem SameCycle.exists_pow_eq (f : Perm Î±) (h : SameCycle f x y) :
    âˆƒ (i : â„•) (_ : 0 < i) (_ : i â‰¤ (f.cycleOf x).support.card + 1), (f ^ i) x = y := by
  by_cases hx : x âˆˆ f.support
  -- âŠ¢ âˆƒ i x_1 x_2, â†‘(f ^ i) x = y
  Â· obtain âŸ¨k, hk, hk'âŸ© := h.exists_pow_eq_of_mem_support hx
    -- âŠ¢ âˆƒ i x_1 x_2, â†‘(f ^ i) x = y
    cases' k with k
    -- âŠ¢ âˆƒ i x_1 x_2, â†‘(f ^ i) x = y
    Â· refine' âŸ¨(f.cycleOf x).support.card, _, self_le_add_right _ _, _âŸ©
      -- âŠ¢ 0 < card (support (cycleOf f x))
      Â· refine' zero_lt_one.trans (one_lt_card_support_of_ne_one _)
        -- âŠ¢ cycleOf f x â‰  1
        simpa using hx
        -- ğŸ‰ no goals
      Â· simp only [Nat.zero_eq, pow_zero, coe_one, id_eq] at hk'
        -- âŠ¢ â†‘(f ^ card (support (cycleOf f x))) x = y
        subst hk'
        -- âŠ¢ â†‘(f ^ card (support (cycleOf f x))) x = x
        rw [â† (isCycle_cycleOf _ <| mem_support.1 hx).orderOf, â† cycleOf_pow_apply_self,
          pow_orderOf_eq_one, one_apply]
    Â· exact âŸ¨k + 1, by simp, Nat.le_succ_of_le hk.le, hk'âŸ©
      -- ğŸ‰ no goals
  Â· refine' âŸ¨1, zero_lt_one, by simp, _âŸ©
    -- âŠ¢ â†‘(f ^ 1) x = y
    obtain âŸ¨k, rflâŸ© := h
    -- âŠ¢ â†‘(f ^ 1) x = â†‘(f ^ k) x
    rw [not_mem_support] at hx
    -- âŠ¢ â†‘(f ^ 1) x = â†‘(f ^ k) x
    rw [pow_apply_eq_self_of_apply_eq_self hx, zpow_apply_eq_self_of_apply_eq_self hx]
    -- ğŸ‰ no goals
#align equiv.perm.same_cycle.exists_pow_eq Equiv.Perm.SameCycle.exists_pow_eq

end CycleOf

/-!
### `cycleFactors`
-/


variable [DecidableEq Î±]

/-- Given a list `l : List Î±` and a permutation `f : perm Î±` whose nonfixed points are all in `l`,
  recursively factors `f` into cycles. -/
def cycleFactorsAux [Fintype Î±] :
    âˆ€ (l : List Î±) (f : Perm Î±),
      (âˆ€ {x}, f x â‰  x â†’ x âˆˆ l) â†’
        { l : List (Perm Î±) // l.prod = f âˆ§ (âˆ€ g âˆˆ l, IsCycle g) âˆ§ l.Pairwise Disjoint } := by
  intro l f h
  -- âŠ¢ { l // List.prod l = f âˆ§ (âˆ€ (g : Perm Î±), g âˆˆ l â†’ IsCycle g) âˆ§ List.Pairwise â€¦
  exact match l with
  | [] => âŸ¨[], by
      { simp only [imp_false, List.Pairwise.nil, List.not_mem_nil, forall_const, and_true_iff,
          forall_prop_of_false, Classical.not_not, not_false_iff, List.prod_nil] at *
        ext
        simp [*]}âŸ©
  | x::l =>
    if hx : f x = x then cycleFactorsAux l f (by
        intro y hy; exact List.mem_of_ne_of_mem (fun h => hy (by rwa [h])) (h hy))
    else
      let âŸ¨m, hmâ‚, hmâ‚‚, hmâ‚ƒâŸ© :=
        cycleFactorsAux l ((cycleOf f x)â»Â¹ * f) (by
        intro y hy
        exact List.mem_of_ne_of_mem
            (fun h : y = x => by
              rw [h, mul_apply, Ne.def, inv_eq_iff_eq, cycleOf_apply_self] at hy
              exact hy rfl)
            (h fun h : f y = y => by
              rw [mul_apply, h, Ne.def, inv_eq_iff_eq, cycleOf_apply] at hy
              split_ifs at hy <;> tauto))
      âŸ¨cycleOf f x::m, by
        rw [List.prod_cons, hmâ‚]
        simp,
        fun g hg â†¦ ((List.mem_cons).1 hg).elim (fun hg => hg.symm â–¸ isCycle_cycleOf _ hx) (hmâ‚‚ g),
        List.pairwise_cons.2
          âŸ¨fun g hg y =>
            or_iff_not_imp_left.2 fun hfy =>
              have hxy : SameCycle f x y :=
                Classical.not_not.1 (mt cycleOf_apply_of_not_sameCycle hfy)
              have hgm : (g::m.erase g) ~ m :=
                List.cons_perm_iff_perm_erase.2 âŸ¨hg, List.Perm.refl _âŸ©
              have : âˆ€ h âˆˆ m.erase g, Disjoint g h :=
                (List.pairwise_cons.1
                    ((hgm.pairwise_iff fun a b (h : Disjoint a b) => h.symm).2 hmâ‚ƒ)).1
              by_cases id fun hgy : g y â‰  y =>
                (disjoint_prod_right _ this y).resolve_right <| by
                  have hsc : SameCycle fâ»Â¹ x (f y) := by
                    rwa [sameCycle_inv, sameCycle_apply_right]
                  rw [disjoint_prod_perm hmâ‚ƒ hgm.symm, List.prod_cons,
                      â† eq_inv_mul_iff_mul_eq] at hmâ‚
                  rwa [hmâ‚, mul_apply, mul_apply, cycleOf_inv, hsc.cycleOf_apply, inv_apply_self,
                    inv_eq_iff_eq, eq_comm],
            hmâ‚ƒâŸ©âŸ©
#align equiv.perm.cycle_factors_aux Equiv.Perm.cycleFactorsAux

theorem mem_list_cycles_iff {Î± : Type*} [Finite Î±] {l : List (Perm Î±)}
    (h1 : âˆ€ Ïƒ : Perm Î±, Ïƒ âˆˆ l â†’ Ïƒ.IsCycle) (h2 : l.Pairwise Disjoint) {Ïƒ : Perm Î±} :
    Ïƒ âˆˆ l â†” Ïƒ.IsCycle âˆ§ âˆ€ (a : Î±) (_ : Ïƒ a â‰  a), Ïƒ a = l.prod a := by
  suffices Ïƒ.IsCycle â†’ (Ïƒ âˆˆ l â†” âˆ€ (a : Î±) (_ : Ïƒ a â‰  a), Ïƒ a = l.prod a) by
    exact âŸ¨fun hÏƒ => âŸ¨h1 Ïƒ hÏƒ, (this (h1 Ïƒ hÏƒ)).mp hÏƒâŸ©, fun hÏƒ => (this hÏƒ.1).mpr hÏƒ.2âŸ©
  intro h3
  -- âŠ¢ Ïƒ âˆˆ l â†” âˆ€ (a : Î±), â†‘Ïƒ a â‰  a â†’ â†‘Ïƒ a = â†‘(List.prod l) a
  classical
    cases nonempty_fintype Î±
    constructor
    Â· intro h a ha
      exact eq_on_support_mem_disjoint h h2 _ (mem_support.mpr ha)
    Â· intro h
      have hÏƒl : Ïƒ.support âŠ† l.prod.support := by
        intro x hx
        rw [mem_support] at hx
        rwa [mem_support, â† h _ hx]
      obtain âŸ¨a, ha, -âŸ© := id h3
      rw [â† mem_support] at ha
      obtain âŸ¨Ï„, hÏ„, hÏ„aâŸ© := exists_mem_support_of_mem_support_prod (hÏƒl ha)
      have hÏ„l : âˆ€ x âˆˆ Ï„.support, Ï„ x = l.prod x := eq_on_support_mem_disjoint hÏ„ h2
      have key : âˆ€ x âˆˆ Ïƒ.support âˆ© Ï„.support, Ïƒ x = Ï„ x := by
        intro x hx
        rw [h x (mem_support.mp (mem_of_mem_inter_left hx)), hÏ„l x (mem_of_mem_inter_right hx)]
      convert hÏ„
      refine' h3.eq_on_support_inter_nonempty_congr (h1 _ hÏ„) key _ ha
      exact key a (mem_inter_of_mem ha hÏ„a)
#align equiv.perm.mem_list_cycles_iff Equiv.Perm.mem_list_cycles_iff

theorem list_cycles_perm_list_cycles {Î± : Type*} [Finite Î±] {lâ‚ lâ‚‚ : List (Perm Î±)}
    (hâ‚€ : lâ‚.prod = lâ‚‚.prod) (hâ‚lâ‚ : âˆ€ Ïƒ : Perm Î±, Ïƒ âˆˆ lâ‚ â†’ Ïƒ.IsCycle)
    (hâ‚lâ‚‚ : âˆ€ Ïƒ : Perm Î±, Ïƒ âˆˆ lâ‚‚ â†’ Ïƒ.IsCycle) (hâ‚‚lâ‚ : lâ‚.Pairwise Disjoint)
    (hâ‚‚lâ‚‚ : lâ‚‚.Pairwise Disjoint) : lâ‚ ~ lâ‚‚ := by
  classical
    refine'
      (List.perm_ext (nodup_of_pairwise_disjoint_cycles hâ‚lâ‚ hâ‚‚lâ‚)
            (nodup_of_pairwise_disjoint_cycles hâ‚lâ‚‚ hâ‚‚lâ‚‚)).mpr
        fun Ïƒ => _
    by_cases hÏƒ : Ïƒ.IsCycle
    Â· obtain _ := not_forall.mp (mt ext hÏƒ.ne_one)
      rw [mem_list_cycles_iff hâ‚lâ‚ hâ‚‚lâ‚, mem_list_cycles_iff hâ‚lâ‚‚ hâ‚‚lâ‚‚, hâ‚€]
    Â· exact iff_of_false (mt (hâ‚lâ‚ Ïƒ) hÏƒ) (mt (hâ‚lâ‚‚ Ïƒ) hÏƒ)
#align equiv.perm.list_cycles_perm_list_cycles Equiv.Perm.list_cycles_perm_list_cycles

/-- Factors a permutation `f` into a list of disjoint cyclic permutations that multiply to `f`. -/
def cycleFactors [Fintype Î±] [LinearOrder Î±] (f : Perm Î±) :
    { l : List (Perm Î±) // l.prod = f âˆ§ (âˆ€ g âˆˆ l, IsCycle g) âˆ§ l.Pairwise Disjoint } :=
  cycleFactorsAux (sort (Î± := Î±) (Â· â‰¤ Â·) univ) f (fun {_ _} â†¦ (mem_sort _).2 (mem_univ _))
#align equiv.perm.cycle_factors Equiv.Perm.cycleFactors

/-- Factors a permutation `f` into a list of disjoint cyclic permutations that multiply to `f`,
  without a linear order. -/
def truncCycleFactors [Fintype Î±] (f : Perm Î±) :
    Trunc { l : List (Perm Î±) // l.prod = f âˆ§ (âˆ€ g âˆˆ l, IsCycle g) âˆ§ l.Pairwise Disjoint } :=
  Quotient.recOnSubsingleton (@univ Î± _).1 (fun l h => Trunc.mk (cycleFactorsAux l f (h _)))
    (show âˆ€ x, f x â‰  x â†’ x âˆˆ (@univ Î± _).1 from fun _ _ => mem_univ _)
#align equiv.perm.trunc_cycle_factors Equiv.Perm.truncCycleFactors

section CycleFactorsFinset

variable [Fintype Î±] (f : Perm Î±)

/-- Factors a permutation `f` into a `Finset` of disjoint cyclic permutations that multiply to `f`.
-/
def cycleFactorsFinset : Finset (Perm Î±) :=
  (truncCycleFactors f).lift
    (fun l : { l : List (Perm Î±) // l.prod = f âˆ§ (âˆ€ g âˆˆ l, IsCycle g) âˆ§ l.Pairwise Disjoint } =>
      l.val.toFinset)
    fun âŸ¨_, hlâŸ© âŸ¨_, hl'âŸ© =>
    List.toFinset_eq_of_perm _ _
      (list_cycles_perm_list_cycles (hl'.left.symm â–¸ hl.left) hl.right.left hl'.right.left
        hl.right.right hl'.right.right)
#align equiv.perm.cycle_factors_finset Equiv.Perm.cycleFactorsFinset

theorem cycleFactorsFinset_eq_list_toFinset {Ïƒ : Perm Î±} {l : List (Perm Î±)} (hn : l.Nodup) :
    Ïƒ.cycleFactorsFinset = l.toFinset â†”
      (âˆ€ f : Perm Î±, f âˆˆ l â†’ f.IsCycle) âˆ§ l.Pairwise Disjoint âˆ§ l.prod = Ïƒ := by
  obtain âŸ¨âŸ¨l', hp', hc', hd'âŸ©, hlâŸ© := Trunc.exists_rep Ïƒ.truncCycleFactors
  -- âŠ¢ cycleFactorsFinset Ïƒ = List.toFinset l â†” (âˆ€ (f : Perm Î±), f âˆˆ l â†’ IsCycle f) â€¦
  have ht : cycleFactorsFinset Ïƒ = l'.toFinset := by
    rw [cycleFactorsFinset, â† hl, Trunc.lift_mk]
  rw [ht]
  -- âŠ¢ List.toFinset l' = List.toFinset l â†” (âˆ€ (f : Perm Î±), f âˆˆ l â†’ IsCycle f) âˆ§ L â€¦
  constructor
  -- âŠ¢ List.toFinset l' = List.toFinset l â†’ (âˆ€ (f : Perm Î±), f âˆˆ l â†’ IsCycle f) âˆ§ L â€¦
  Â· intro h
    -- âŠ¢ (âˆ€ (f : Perm Î±), f âˆˆ l â†’ IsCycle f) âˆ§ List.Pairwise Disjoint l âˆ§ List.prod l â€¦
    have hn' : l'.Nodup := nodup_of_pairwise_disjoint_cycles hc' hd'
    -- âŠ¢ (âˆ€ (f : Perm Î±), f âˆˆ l â†’ IsCycle f) âˆ§ List.Pairwise Disjoint l âˆ§ List.prod l â€¦
    have hperm : l ~ l' := List.perm_of_nodup_nodup_toFinset_eq hn hn' h.symm
    -- âŠ¢ (âˆ€ (f : Perm Î±), f âˆˆ l â†’ IsCycle f) âˆ§ List.Pairwise Disjoint l âˆ§ List.prod l â€¦
    refine' âŸ¨_, _, _âŸ©
    Â· exact fun _ h => hc' _ (hperm.subset h)
      -- ğŸ‰ no goals
    Â· rwa [List.Perm.pairwise_iff Disjoint.symmetric hperm]
      -- ğŸ‰ no goals
    Â· rw [â† hp', hperm.symm.prod_eq']
      -- âŠ¢ List.Pairwise Commute l'
      refine' hd'.imp _
      -- âŠ¢ âˆ€ {a b : Perm Î±}, Disjoint a b â†’ Commute a b
      exact Disjoint.commute
      -- ğŸ‰ no goals
  Â· rintro âŸ¨hc, hd, hpâŸ©
    -- âŠ¢ List.toFinset l' = List.toFinset l
    refine' List.toFinset_eq_of_perm _ _ _
    -- âŠ¢ l' ~ l
    refine' list_cycles_perm_list_cycles _ hc' hc hd' hd
    -- âŠ¢ List.prod l' = List.prod l
    rw [hp, hp']
    -- ğŸ‰ no goals
#align equiv.perm.cycle_factors_finset_eq_list_to_finset Equiv.Perm.cycleFactorsFinset_eq_list_toFinset

theorem cycleFactorsFinset_eq_finset {Ïƒ : Perm Î±} {s : Finset (Perm Î±)} :
    Ïƒ.cycleFactorsFinset = s â†”
      (âˆ€ f : Perm Î±, f âˆˆ s â†’ f.IsCycle) âˆ§
        âˆƒ h : (s : Set (Perm Î±)).Pairwise Disjoint,
          s.noncommProd id (h.mono' fun _ _ => Disjoint.commute) = Ïƒ := by
  obtain âŸ¨l, hl, rflâŸ© := s.exists_list_nodup_eq
  -- âŠ¢ cycleFactorsFinset Ïƒ = List.toFinset l â†” (âˆ€ (f : Perm Î±), f âˆˆ List.toFinset  â€¦
  simp [cycleFactorsFinset_eq_list_toFinset, hl]
  -- ğŸ‰ no goals
#align equiv.perm.cycle_factors_finset_eq_finset Equiv.Perm.cycleFactorsFinset_eq_finset

theorem cycleFactorsFinset_pairwise_disjoint :
    (cycleFactorsFinset f : Set (Perm Î±)).Pairwise Disjoint :=
  (cycleFactorsFinset_eq_finset.mp rfl).2.choose
#align equiv.perm.cycle_factors_finset_pairwise_disjoint Equiv.Perm.cycleFactorsFinset_pairwise_disjoint

theorem cycleFactorsFinset_mem_commute : (cycleFactorsFinset f : Set (Perm Î±)).Pairwise Commute :=
  (cycleFactorsFinset_pairwise_disjoint _).mono' fun _ _ => Disjoint.commute
#align equiv.perm.cycle_factors_finset_mem_commute Equiv.Perm.cycleFactorsFinset_mem_commute

/-- The product of cycle factors is equal to the original `f : perm Î±`. -/
theorem cycleFactorsFinset_noncommProd
    (comm : (cycleFactorsFinset f : Set (Perm Î±)).Pairwise Commute :=
      cycleFactorsFinset_mem_commute f) :
    f.cycleFactorsFinset.noncommProd id comm = f :=
  (cycleFactorsFinset_eq_finset.mp rfl).2.choose_spec
#align equiv.perm.cycle_factors_finset_noncomm_prod Equiv.Perm.cycleFactorsFinset_noncommProd

theorem mem_cycleFactorsFinset_iff {f p : Perm Î±} :
    p âˆˆ cycleFactorsFinset f â†” p.IsCycle âˆ§ âˆ€ a âˆˆ p.support, p a = f a := by
  obtain âŸ¨l, hl, hl'âŸ© := f.cycleFactorsFinset.exists_list_nodup_eq
  -- âŠ¢ p âˆˆ cycleFactorsFinset f â†” IsCycle p âˆ§ âˆ€ (a : Î±), a âˆˆ support p â†’ â†‘p a = â†‘f a
  rw [â† hl']
  -- âŠ¢ p âˆˆ List.toFinset l â†” IsCycle p âˆ§ âˆ€ (a : Î±), a âˆˆ support p â†’ â†‘p a = â†‘f a
  rw [eq_comm, cycleFactorsFinset_eq_list_toFinset hl] at hl'
  -- âŠ¢ p âˆˆ List.toFinset l â†” IsCycle p âˆ§ âˆ€ (a : Î±), a âˆˆ support p â†’ â†‘p a = â†‘f a
  simpa [List.mem_toFinset, Ne.def, â† hl'.right.right] using
    mem_list_cycles_iff hl'.left hl'.right.left
#align equiv.perm.mem_cycle_factors_finset_iff Equiv.Perm.mem_cycleFactorsFinset_iff

theorem cycleOf_mem_cycleFactorsFinset_iff {f : Perm Î±} {x : Î±} :
    cycleOf f x âˆˆ cycleFactorsFinset f â†” x âˆˆ f.support := by
  rw [mem_cycleFactorsFinset_iff]
  -- âŠ¢ (IsCycle (cycleOf f x) âˆ§ âˆ€ (a : Î±), a âˆˆ support (cycleOf f x) â†’ â†‘(cycleOf f  â€¦
  constructor
  -- âŠ¢ (IsCycle (cycleOf f x) âˆ§ âˆ€ (a : Î±), a âˆˆ support (cycleOf f x) â†’ â†‘(cycleOf f  â€¦
  Â· rintro âŸ¨hc, _âŸ©
    -- âŠ¢ x âˆˆ support f
    contrapose! hc
    -- âŠ¢ Â¬IsCycle (cycleOf f x)
    rw [not_mem_support, â† cycleOf_eq_one_iff] at hc
    -- âŠ¢ Â¬IsCycle (cycleOf f x)
    simp [hc]
    -- ğŸ‰ no goals
  Â· intro hx
    -- âŠ¢ IsCycle (cycleOf f x) âˆ§ âˆ€ (a : Î±), a âˆˆ support (cycleOf f x) â†’ â†‘(cycleOf f x â€¦
    refine' âŸ¨isCycle_cycleOf _ (mem_support.mp hx), _âŸ©
    -- âŠ¢ âˆ€ (a : Î±), a âˆˆ support (cycleOf f x) â†’ â†‘(cycleOf f x) a = â†‘f a
    intro y hy
    -- âŠ¢ â†‘(cycleOf f x) y = â†‘f y
    rw [mem_support] at hy
    -- âŠ¢ â†‘(cycleOf f x) y = â†‘f y
    rw [cycleOf_apply]
    -- âŠ¢ (if SameCycle f x y then â†‘f y else y) = â†‘f y
    split_ifs with H
    -- âŠ¢ â†‘f y = â†‘f y
    Â· rfl
      -- ğŸ‰ no goals
    Â· rw [cycleOf_apply_of_not_sameCycle H] at hy
      -- âŠ¢ y = â†‘f y
      contradiction
      -- ğŸ‰ no goals
#align equiv.perm.cycle_of_mem_cycle_factors_finset_iff Equiv.Perm.cycleOf_mem_cycleFactorsFinset_iff

theorem mem_cycleFactorsFinset_support_le {p f : Perm Î±} (h : p âˆˆ cycleFactorsFinset f) :
    p.support â‰¤ f.support := by
  rw [mem_cycleFactorsFinset_iff] at h
  -- âŠ¢ support p â‰¤ support f
  intro x hx
  -- âŠ¢ x âˆˆ support f
  rwa [mem_support, â† h.right x hx, â† mem_support]
  -- ğŸ‰ no goals
#align equiv.perm.mem_cycle_factors_finset_support_le Equiv.Perm.mem_cycleFactorsFinset_support_le

theorem cycleFactorsFinset_eq_empty_iff {f : Perm Î±} : cycleFactorsFinset f = âˆ… â†” f = 1 := by
  simpa [cycleFactorsFinset_eq_finset] using eq_comm
  -- ğŸ‰ no goals
#align equiv.perm.cycle_factors_finset_eq_empty_iff Equiv.Perm.cycleFactorsFinset_eq_empty_iff

@[simp]
theorem cycleFactorsFinset_one : cycleFactorsFinset (1 : Perm Î±) = âˆ… := by
  simp [cycleFactorsFinset_eq_empty_iff]
  -- ğŸ‰ no goals
#align equiv.perm.cycle_factors_finset_one Equiv.Perm.cycleFactorsFinset_one

@[simp]
theorem cycleFactorsFinset_eq_singleton_self_iff {f : Perm Î±} :
    f.cycleFactorsFinset = {f} â†” f.IsCycle := by simp [cycleFactorsFinset_eq_finset]
                                                 -- ğŸ‰ no goals
#align equiv.perm.cycle_factors_finset_eq_singleton_self_iff Equiv.Perm.cycleFactorsFinset_eq_singleton_self_iff

theorem IsCycle.cycleFactorsFinset_eq_singleton {f : Perm Î±} (hf : IsCycle f) :
    f.cycleFactorsFinset = {f} :=
  cycleFactorsFinset_eq_singleton_self_iff.mpr hf
#align equiv.perm.is_cycle.cycle_factors_finset_eq_singleton Equiv.Perm.IsCycle.cycleFactorsFinset_eq_singleton

theorem cycleFactorsFinset_eq_singleton_iff {f g : Perm Î±} :
    f.cycleFactorsFinset = {g} â†” f.IsCycle âˆ§ f = g := by
  suffices f = g â†’ (g.IsCycle â†” f.IsCycle) by
    rw [cycleFactorsFinset_eq_finset]
    simpa [eq_comm]
  rintro rfl
  -- âŠ¢ IsCycle f â†” IsCycle f
  exact Iff.rfl
  -- ğŸ‰ no goals
#align equiv.perm.cycle_factors_finset_eq_singleton_iff Equiv.Perm.cycleFactorsFinset_eq_singleton_iff

/-- Two permutations `f g : perm Î±` have the same cycle factors iff they are the same. -/
theorem cycleFactorsFinset_injective : Function.Injective (@cycleFactorsFinset Î± _ _) := by
  intro f g h
  -- âŠ¢ f = g
  rw [â† cycleFactorsFinset_noncommProd f]
  -- âŠ¢ noncommProd (cycleFactorsFinset f) id (_ : Set.Pairwise (â†‘(cycleFactorsFinse â€¦
  simpa [h] using cycleFactorsFinset_noncommProd g
  -- ğŸ‰ no goals
#align equiv.perm.cycle_factors_finset_injective Equiv.Perm.cycleFactorsFinset_injective

theorem Disjoint.disjoint_cycleFactorsFinset {f g : Perm Î±} (h : Disjoint f g) :
    _root_.Disjoint (cycleFactorsFinset f) (cycleFactorsFinset g) := by
  rw [disjoint_iff_disjoint_support] at h
  -- âŠ¢ _root_.Disjoint (cycleFactorsFinset f) (cycleFactorsFinset g)
  rw [Finset.disjoint_left]
  -- âŠ¢ âˆ€ â¦ƒa : Perm Î±â¦„, a âˆˆ cycleFactorsFinset f â†’ Â¬a âˆˆ cycleFactorsFinset g
  intro x hx hy
  -- âŠ¢ False
  simp only [mem_cycleFactorsFinset_iff, mem_support] at hx hy
  -- âŠ¢ False
  obtain âŸ¨âŸ¨âŸ¨a, ha, -âŸ©, hfâŸ©, -, hgâŸ© := hx, hy
  -- âŠ¢ False
  have := h.le_bot (by simp [ha, â† hf a ha, â† hg a ha] : a âˆˆ f.support âˆ© g.support)
  -- âŠ¢ False
  tauto
  -- ğŸ‰ no goals
#align equiv.perm.disjoint.disjoint_cycle_factors_finset Equiv.Perm.Disjoint.disjoint_cycleFactorsFinset

theorem Disjoint.cycleFactorsFinset_mul_eq_union {f g : Perm Î±} (h : Disjoint f g) :
    cycleFactorsFinset (f * g) = cycleFactorsFinset f âˆª cycleFactorsFinset g := by
  rw [cycleFactorsFinset_eq_finset]
  -- âŠ¢ (âˆ€ (f_1 : Perm Î±), f_1 âˆˆ cycleFactorsFinset f âˆª cycleFactorsFinset g â†’ IsCyc â€¦
  refine' âŸ¨_, _, _âŸ©
  Â· simp [or_imp, mem_cycleFactorsFinset_iff, forall_swap]
    -- ğŸ‰ no goals
  Â· rw [coe_union, Set.pairwise_union_of_symmetric Disjoint.symmetric]
    -- âŠ¢ Set.Pairwise (â†‘(cycleFactorsFinset f)) Disjoint âˆ§ Set.Pairwise (â†‘(cycleFacto â€¦
    exact
      âŸ¨cycleFactorsFinset_pairwise_disjoint _, cycleFactorsFinset_pairwise_disjoint _,
        fun x hx y hy _ =>
        h.mono (mem_cycleFactorsFinset_support_le hx) (mem_cycleFactorsFinset_support_le hy)âŸ©
  Â· rw [noncommProd_union_of_disjoint h.disjoint_cycleFactorsFinset]
    -- âŠ¢ noncommProd (cycleFactorsFinset f) id (_ : Set.Pairwise â†‘(cycleFactorsFinset â€¦
    rw [cycleFactorsFinset_noncommProd, cycleFactorsFinset_noncommProd]
    -- ğŸ‰ no goals
#align equiv.perm.disjoint.cycle_factors_finset_mul_eq_union Equiv.Perm.Disjoint.cycleFactorsFinset_mul_eq_union

theorem disjoint_mul_inv_of_mem_cycleFactorsFinset {f g : Perm Î±} (h : f âˆˆ cycleFactorsFinset g) :
    Disjoint (g * fâ»Â¹) f := by
  rw [mem_cycleFactorsFinset_iff] at h
  -- âŠ¢ Disjoint (g * fâ»Â¹) f
  intro x
  -- âŠ¢ â†‘(g * fâ»Â¹) x = x âˆ¨ â†‘f x = x
  by_cases hx : f x = x
  -- âŠ¢ â†‘(g * fâ»Â¹) x = x âˆ¨ â†‘f x = x
  Â· exact Or.inr hx
    -- ğŸ‰ no goals
  Â· refine' Or.inl _
    -- âŠ¢ â†‘(g * fâ»Â¹) x = x
    rw [mul_apply, â† h.right, apply_inv_self]
    -- âŠ¢ â†‘fâ»Â¹ x âˆˆ support f
    rwa [â† support_inv, apply_mem_support, support_inv, mem_support]
    -- ğŸ‰ no goals
#align equiv.perm.disjoint_mul_inv_of_mem_cycle_factors_finset Equiv.Perm.disjoint_mul_inv_of_mem_cycleFactorsFinset

/-- If c is a cycle, a âˆˆ c.support and c is a cycle of f, then `c = f.cycleOf a` -/
theorem cycle_is_cycleOf {f c : Equiv.Perm Î±} {a : Î±} (ha : a âˆˆ c.support)
    (hc : c âˆˆ f.cycleFactorsFinset) : c = f.cycleOf a := by
  suffices f.cycleOf a = c.cycleOf a by
    rw [this]
    apply symm
    exact
      Equiv.Perm.IsCycle.cycleOf_eq (Equiv.Perm.mem_cycleFactorsFinset_iff.mp hc).left
        (Equiv.Perm.mem_support.mp ha)
  let hfc := (Equiv.Perm.disjoint_mul_inv_of_mem_cycleFactorsFinset hc).symm
  -- âŠ¢ cycleOf f a = cycleOf c a
  let hfc2 := Perm.Disjoint.commute hfc
  -- âŠ¢ cycleOf f a = cycleOf c a
  rw [â† Equiv.Perm.cycleOf_mul_of_apply_right_eq_self hfc2]
  -- âŠ¢ cycleOf f a = cycleOf (c * (f * câ»Â¹)) a
  simp only [hfc2.eq, inv_mul_cancel_right]
  -- âŠ¢ â†‘(f * câ»Â¹) a = a
  -- a est dans le support de c, donc pas dans celui de g câ»Â¹
  exact
    Equiv.Perm.not_mem_support.mp
      (Finset.disjoint_left.mp (Equiv.Perm.Disjoint.disjoint_support hfc) ha)
#align equiv.perm.cycle_is_cycle_of Equiv.Perm.cycle_is_cycleOf

end CycleFactorsFinset

@[elab_as_elim]
theorem cycle_induction_on [Finite Î²] (P : Perm Î² â†’ Prop) (Ïƒ : Perm Î²) (base_one : P 1)
    (base_cycles : âˆ€ Ïƒ : Perm Î², Ïƒ.IsCycle â†’ P Ïƒ)
    (induction_disjoint : âˆ€ Ïƒ Ï„ : Perm Î²,
      Disjoint Ïƒ Ï„ â†’ IsCycle Ïƒ â†’ P Ïƒ â†’ P Ï„ â†’ P (Ïƒ * Ï„)) : P Ïƒ := by
  cases nonempty_fintype Î²
  -- âŠ¢ P Ïƒ
  suffices âˆ€ l : List (Perm Î²),
      (âˆ€ Ï„ : Perm Î², Ï„ âˆˆ l â†’ Ï„.IsCycle) â†’ l.Pairwise Disjoint â†’ P l.prod by
    classical
      let x := Ïƒ.truncCycleFactors.out
      exact (congr_arg P x.2.1).mp (this x.1 x.2.2.1 x.2.2.2)
  intro l
  -- âŠ¢ (âˆ€ (Ï„ : Perm Î²), Ï„ âˆˆ l â†’ IsCycle Ï„) â†’ List.Pairwise Disjoint l â†’ P (List.pro â€¦
  induction' l with Ïƒ l ih
  -- âŠ¢ (âˆ€ (Ï„ : Perm Î²), Ï„ âˆˆ [] â†’ IsCycle Ï„) â†’ List.Pairwise Disjoint [] â†’ P (List.p â€¦
  Â· exact fun _ _ => base_one
    -- ğŸ‰ no goals
  Â· intro h1 h2
    -- âŠ¢ P (List.prod (Ïƒ :: l))
    rw [List.prod_cons]
    -- âŠ¢ P (Ïƒ * List.prod l)
    exact
      induction_disjoint Ïƒ l.prod (disjoint_prod_right _ (List.pairwise_cons.mp h2).1)
        (h1 _ (List.mem_cons_self _ _)) (base_cycles Ïƒ (h1 Ïƒ (l.mem_cons_self Ïƒ)))
        (ih (fun Ï„ hÏ„ => h1 Ï„ (List.mem_cons_of_mem Ïƒ hÏ„)) h2.of_cons)
#align equiv.perm.cycle_induction_on Equiv.Perm.cycle_induction_on

theorem cycleFactorsFinset_mul_inv_mem_eq_sdiff [Fintype Î±] {f g : Perm Î±}
    (h : f âˆˆ cycleFactorsFinset g) : cycleFactorsFinset (g * fâ»Â¹) = cycleFactorsFinset g \ {f} := by
  revert f
  -- âŠ¢ âˆ€ {f : Perm Î±}, f âˆˆ cycleFactorsFinset g â†’ cycleFactorsFinset (g * fâ»Â¹) = cy â€¦
  refine'
    cycle_induction_on (P := fun {g : Perm Î±} â†¦
      âˆ€ {f}, (f âˆˆ cycleFactorsFinset g)
        â†’ cycleFactorsFinset (g * fâ»Â¹) = cycleFactorsFinset g \ {f}) _ _ _ _
  Â· simp
    -- ğŸ‰ no goals
  Â· intro Ïƒ hÏƒ f hf
    -- âŠ¢ cycleFactorsFinset (Ïƒ * fâ»Â¹) = cycleFactorsFinset Ïƒ \ {f}
    simp only [cycleFactorsFinset_eq_singleton_self_iff.mpr hÏƒ, mem_singleton] at hf âŠ¢
    -- âŠ¢ cycleFactorsFinset (Ïƒ * fâ»Â¹) = {Ïƒ} \ {f}
    simp [hf]
    -- ğŸ‰ no goals
  Â· intro Ïƒ Ï„ hd _ hÏƒ hÏ„ f
    -- âŠ¢ f âˆˆ cycleFactorsFinset (Ïƒ * Ï„) â†’ cycleFactorsFinset (Ïƒ * Ï„ * fâ»Â¹) = cycleFac â€¦
    simp_rw [hd.cycleFactorsFinset_mul_eq_union, mem_union]
    -- âŠ¢ f âˆˆ cycleFactorsFinset Ïƒ âˆ¨ f âˆˆ cycleFactorsFinset Ï„ â†’ cycleFactorsFinset (Ïƒ  â€¦
    -- if only `wlog` could work here...
    rintro (hf | hf)
    -- âŠ¢ cycleFactorsFinset (Ïƒ * Ï„ * fâ»Â¹) = (cycleFactorsFinset Ïƒ âˆª cycleFactorsFinse â€¦
    Â· rw [hd.commute.eq, union_comm, union_sdiff_distrib, sdiff_singleton_eq_erase,
        erase_eq_of_not_mem, mul_assoc, Disjoint.cycleFactorsFinset_mul_eq_union, hÏƒ hf]
      Â· rw [mem_cycleFactorsFinset_iff] at hf
        -- âŠ¢ Disjoint Ï„ (Ïƒ * fâ»Â¹)
        intro x
        -- âŠ¢ â†‘Ï„ x = x âˆ¨ â†‘(Ïƒ * fâ»Â¹) x = x
        cases' hd.symm x with hx hx
        -- âŠ¢ â†‘Ï„ x = x âˆ¨ â†‘(Ïƒ * fâ»Â¹) x = x
        Â· exact Or.inl hx
          -- ğŸ‰ no goals
        Â· refine' Or.inr _
          -- âŠ¢ â†‘(Ïƒ * fâ»Â¹) x = x
          by_cases hfx : f x = x
          -- âŠ¢ â†‘(Ïƒ * fâ»Â¹) x = x
          Â· rw [â† hfx]
            -- âŠ¢ â†‘(Ïƒ * fâ»Â¹) (â†‘f x) = â†‘f x
            simpa [hx] using hfx.symm
            -- ğŸ‰ no goals
          Â· rw [mul_apply]
            -- âŠ¢ â†‘Ïƒ (â†‘fâ»Â¹ x) = x
            rw [â† hf.right _ (mem_support.mpr hfx)] at hx
            -- âŠ¢ â†‘Ïƒ (â†‘fâ»Â¹ x) = x
            contradiction
            -- ğŸ‰ no goals
      Â· exact fun H =>
        not_mem_empty _ (hd.disjoint_cycleFactorsFinset.le_bot (mem_inter_of_mem hf H))
    Â· rw [union_sdiff_distrib, sdiff_singleton_eq_erase, erase_eq_of_not_mem, mul_assoc,
        Disjoint.cycleFactorsFinset_mul_eq_union, hÏ„ hf]
      Â· rw [mem_cycleFactorsFinset_iff] at hf
        -- âŠ¢ Disjoint Ïƒ (Ï„ * fâ»Â¹)
        intro x
        -- âŠ¢ â†‘Ïƒ x = x âˆ¨ â†‘(Ï„ * fâ»Â¹) x = x
        cases' hd x with hx hx
        -- âŠ¢ â†‘Ïƒ x = x âˆ¨ â†‘(Ï„ * fâ»Â¹) x = x
        Â· exact Or.inl hx
          -- ğŸ‰ no goals
        Â· refine' Or.inr _
          -- âŠ¢ â†‘(Ï„ * fâ»Â¹) x = x
          by_cases hfx : f x = x
          -- âŠ¢ â†‘(Ï„ * fâ»Â¹) x = x
          Â· rw [â† hfx]
            -- âŠ¢ â†‘(Ï„ * fâ»Â¹) (â†‘f x) = â†‘f x
            simpa [hx] using hfx.symm
            -- ğŸ‰ no goals
          Â· rw [mul_apply]
            -- âŠ¢ â†‘Ï„ (â†‘fâ»Â¹ x) = x
            rw [â† hf.right _ (mem_support.mpr hfx)] at hx
            -- âŠ¢ â†‘Ï„ (â†‘fâ»Â¹ x) = x
            contradiction
            -- ğŸ‰ no goals
      Â· exact fun H =>
        not_mem_empty _ (hd.disjoint_cycleFactorsFinset.le_bot (mem_inter_of_mem H hf))
#align equiv.perm.cycle_factors_finset_mul_inv_mem_eq_sdiff Equiv.Perm.cycleFactorsFinset_mul_inv_mem_eq_sdiff

section Generation

variable [Finite Î²]

open Subgroup

theorem closure_isCycle : closure { Ïƒ : Perm Î² | IsCycle Ïƒ } = âŠ¤ := by
  classical
    cases nonempty_fintype Î²
    exact
      top_le_iff.mp (le_trans (ge_of_eq closure_isSwap) (closure_mono fun _ => IsSwap.isCycle))
#align equiv.perm.closure_is_cycle Equiv.Perm.closure_isCycle

variable [Fintype Î±]

theorem closure_cycle_adjacent_swap {Ïƒ : Perm Î±} (h1 : IsCycle Ïƒ) (h2 : Ïƒ.support = âŠ¤) (x : Î±) :
    closure ({Ïƒ, swap x (Ïƒ x)} : Set (Perm Î±)) = âŠ¤ := by
  let H := closure ({Ïƒ, swap x (Ïƒ x)} : Set (Perm Î±))
  -- âŠ¢ closure {Ïƒ, swap x (â†‘Ïƒ x)} = âŠ¤
  have h3 : Ïƒ âˆˆ H := subset_closure (Set.mem_insert Ïƒ _)
  -- âŠ¢ closure {Ïƒ, swap x (â†‘Ïƒ x)} = âŠ¤
  have h4 : swap x (Ïƒ x) âˆˆ H := subset_closure (Set.mem_insert_of_mem _ (Set.mem_singleton _))
  -- âŠ¢ closure {Ïƒ, swap x (â†‘Ïƒ x)} = âŠ¤
  have step1 : âˆ€ n : â„•, swap ((Ïƒ ^ n) x) ((Ïƒ ^ (n + 1) : Perm Î±) x) âˆˆ H := by
    intro n
    induction' n with n ih
    Â· exact subset_closure (Set.mem_insert_of_mem _ (Set.mem_singleton _))
    Â· convert H.mul_mem (H.mul_mem h3 ih) (H.inv_mem h3)
      simp_rw [mul_swap_eq_swap_mul, mul_inv_cancel_right, pow_succ]
      rfl
  have step2 : âˆ€ n : â„•, swap x ((Ïƒ ^ n) x) âˆˆ H := by
    intro n
    induction' n with n ih
    Â· simp only [Nat.zero_eq, pow_zero, coe_one, id_eq, swap_self, Set.mem_singleton_iff]
      convert H.one_mem
    Â· by_cases h5 : x = (Ïƒ ^ n) x
      Â· rw [pow_succ, mul_apply, â† h5]
        exact h4
      by_cases h6 : x = (Ïƒ ^ (n + 1) : Perm Î±) x
      Â· rw [â† h6, swap_self]
        exact H.one_mem
      rw [swap_comm, â† swap_mul_swap_mul_swap h5 h6]
      exact H.mul_mem (H.mul_mem (step1 n) ih) (step1 n)
  have step3 : âˆ€ y : Î±, swap x y âˆˆ H := by
    intro y
    have hx : x âˆˆ (âŠ¤ : Finset Î±) := Finset.mem_univ x
    rw [â† h2, mem_support] at hx
    have hy : y âˆˆ (âŠ¤ : Finset Î±) := Finset.mem_univ y
    rw [â† h2, mem_support] at hy
    cases' IsCycle.exists_pow_eq h1 hx hy with n hn
    rw [â† hn]
    exact step2 n
  have step4 : âˆ€ y z : Î±, swap y z âˆˆ H := by
    intro y z
    by_cases h5 : z = x
    Â· rw [h5, swap_comm]
      exact step3 y
    by_cases h6 : z = y
    Â· rw [h6, swap_self]
      exact H.one_mem
    rw [â† swap_mul_swap_mul_swap h5 h6, swap_comm z x]
    exact H.mul_mem (H.mul_mem (step3 y) (step3 z)) (step3 y)
  rw [eq_top_iff, â† closure_isSwap, closure_le]
  -- âŠ¢ {Ïƒ | IsSwap Ïƒ} âŠ† â†‘(closure {Ïƒ, swap x (â†‘Ïƒ x)})
  rintro Ï„ âŸ¨y, z, _, h6âŸ©
  -- âŠ¢ Ï„ âˆˆ â†‘(closure {Ïƒ, swap x (â†‘Ïƒ x)})
  rw [h6]
  -- âŠ¢ swap y z âˆˆ â†‘(closure {Ïƒ, swap x (â†‘Ïƒ x)})
  exact step4 y z
  -- ğŸ‰ no goals
#align equiv.perm.closure_cycle_adjacent_swap Equiv.Perm.closure_cycle_adjacent_swap

theorem closure_cycle_coprime_swap {n : â„•} {Ïƒ : Perm Î±} (h0 : Nat.coprime n (Fintype.card Î±))
    (h1 : IsCycle Ïƒ) (h2 : Ïƒ.support = Finset.univ) (x : Î±) :
    closure ({Ïƒ, swap x ((Ïƒ ^ n) x)} : Set (Perm Î±)) = âŠ¤ := by
  rw [â† Finset.card_univ, â† h2, â† h1.orderOf] at h0
  -- âŠ¢ closure {Ïƒ, swap x (â†‘(Ïƒ ^ n) x)} = âŠ¤
  cases' exists_pow_eq_self_of_coprime h0 with m hm
  -- âŠ¢ closure {Ïƒ, swap x (â†‘(Ïƒ ^ n) x)} = âŠ¤
  have h2' : (Ïƒ ^ n).support = âŠ¤ := Eq.trans (support_pow_coprime h0) h2
  -- âŠ¢ closure {Ïƒ, swap x (â†‘(Ïƒ ^ n) x)} = âŠ¤
  have h1' : IsCycle ((Ïƒ ^ n) ^ (m : â„¤)) := by rwa [â† hm] at h1
  -- âŠ¢ closure {Ïƒ, swap x (â†‘(Ïƒ ^ n) x)} = âŠ¤
  replace h1' : IsCycle (Ïƒ ^ n) :=
    h1'.of_pow (le_trans (support_pow_le Ïƒ n) (ge_of_eq (congr_arg support hm)))
  rw [eq_top_iff, â† closure_cycle_adjacent_swap h1' h2' x, closure_le, Set.insert_subset_iff]
  -- âŠ¢ Ïƒ ^ n âˆˆ â†‘(closure {Ïƒ, swap x (â†‘(Ïƒ ^ n) x)}) âˆ§ {swap x (â†‘(Ïƒ ^ n) x)} âŠ† â†‘(clos â€¦
  exact
    âŸ¨Subgroup.pow_mem (closure _) (subset_closure (Set.mem_insert Ïƒ _)) n,
      Set.singleton_subset_iff.mpr (subset_closure (Set.mem_insert_of_mem _ (Set.mem_singleton _)))âŸ©
#align equiv.perm.closure_cycle_coprime_swap Equiv.Perm.closure_cycle_coprime_swap

theorem closure_prime_cycle_swap {Ïƒ Ï„ : Perm Î±} (h0 : (Fintype.card Î±).Prime) (h1 : IsCycle Ïƒ)
    (h2 : Ïƒ.support = Finset.univ) (h3 : IsSwap Ï„) : closure ({Ïƒ, Ï„} : Set (Perm Î±)) = âŠ¤ := by
  obtain âŸ¨x, y, h4, h5âŸ© := h3
  -- âŠ¢ closure {Ïƒ, Ï„} = âŠ¤
  obtain âŸ¨i, hiâŸ© :=
    h1.exists_pow_eq (mem_support.mp ((Finset.ext_iff.mp h2 x).mpr (Finset.mem_univ x)))
      (mem_support.mp ((Finset.ext_iff.mp h2 y).mpr (Finset.mem_univ y)))
  rw [h5, â† hi]
  -- âŠ¢ closure {Ïƒ, swap x (â†‘(Ïƒ ^ i) x)} = âŠ¤
  refine'
    closure_cycle_coprime_swap (Nat.coprime.symm (h0.coprime_iff_not_dvd.mpr fun h => h4 _)) h1 h2 x
  cases' h with m hm
  -- âŠ¢ x = y
  rwa [hm, pow_mul, â† Finset.card_univ, â† h2, â† h1.orderOf, pow_orderOf_eq_one, one_pow,
    one_apply] at hi
#align equiv.perm.closure_prime_cycle_swap Equiv.Perm.closure_prime_cycle_swap

end Generation

section

variable [Fintype Î±] {Ïƒ Ï„ : Perm Î±}

noncomputable section

theorem isConj_of_support_equiv
    (f : { x // x âˆˆ (Ïƒ.support : Set Î±) } â‰ƒ { x // x âˆˆ (Ï„.support : Set Î±) })
    (hf :
      âˆ€ (x : Î±) (hx : x âˆˆ (Ïƒ.support : Set Î±)),
        (f âŸ¨Ïƒ x, apply_mem_support.2 hxâŸ© : Î±) = Ï„ â†‘(f âŸ¨x, hxâŸ©)) :
    IsConj Ïƒ Ï„ := by
  refine' isConj_iff.2 âŸ¨Equiv.extendSubtype f, _âŸ©
  -- âŠ¢ extendSubtype f * Ïƒ * (extendSubtype f)â»Â¹ = Ï„
  rw [mul_inv_eq_iff_eq_mul]
  -- âŠ¢ extendSubtype f * Ïƒ = Ï„ * extendSubtype f
  ext x
  -- âŠ¢ â†‘(extendSubtype f * Ïƒ) x = â†‘(Ï„ * extendSubtype f) x
  simp only [Perm.mul_apply]
  -- âŠ¢ â†‘(extendSubtype f) (â†‘Ïƒ x) = â†‘Ï„ (â†‘(extendSubtype f) x)
  by_cases hx : x âˆˆ Ïƒ.support
  -- âŠ¢ â†‘(extendSubtype f) (â†‘Ïƒ x) = â†‘Ï„ (â†‘(extendSubtype f) x)
  Â· rw [Equiv.extendSubtype_apply_of_mem, Equiv.extendSubtype_apply_of_mem]
    Â· exact hf x (Finset.mem_coe.2 hx)
      -- ğŸ‰ no goals
  Â· rwa [Classical.not_not.1 ((not_congr mem_support).1 (Equiv.extendSubtype_not_mem f _ _)),
      Classical.not_not.1 ((not_congr mem_support).mp hx)]
#align equiv.perm.is_conj_of_support_equiv Equiv.Perm.isConj_of_support_equiv

theorem IsCycle.isConj (hÏƒ : IsCycle Ïƒ) (hÏ„ : IsCycle Ï„) (h : Ïƒ.support.card = Ï„.support.card) :
    IsConj Ïƒ Ï„ := by
  refine'
    isConj_of_support_equiv
      (hÏƒ.zpowersEquivSupport.symm.trans <|
        (zpowersEquivZpowers <| by rw [hÏƒ.orderOf, h, hÏ„.orderOf]).trans hÏ„.zpowersEquivSupport)
      _
  intro x hx
  -- âŠ¢ â†‘(â†‘((zpowersEquivSupport hÏƒ).symm.trans ((zpowersEquivZpowers (_ : orderOf Ïƒ â€¦
  simp only [Perm.mul_apply, Equiv.trans_apply, Equiv.sumCongr_apply]
  -- âŠ¢ â†‘(â†‘(zpowersEquivSupport hÏ„) (â†‘(zpowersEquivZpowers (_ : orderOf Ïƒ = orderOf  â€¦
  obtain âŸ¨n, rflâŸ© := hÏƒ.exists_pow_eq (Classical.choose_spec hÏƒ).1 (mem_support.1 hx)
  -- âŠ¢ â†‘(â†‘(zpowersEquivSupport hÏ„) (â†‘(zpowersEquivZpowers (_ : orderOf Ïƒ = orderOf  â€¦
  apply
    Eq.trans _
      (congr rfl (congr rfl (congr rfl (congr rfl (hÏƒ.zpowersEquivSupport_symm_apply n).symm))))
  apply (congr rfl (congr rfl (congr rfl (hÏƒ.zpowersEquivSupport_symm_apply (n + 1))))).trans _
  -- âŠ¢ â†‘(â†‘(zpowersEquivSupport hÏ„) (â†‘(zpowersEquivZpowers (_ : orderOf Ïƒ = orderOf  â€¦
  simp only [Ne.def, IsCycle.zpowersEquivSupport_apply, Subtype.coe_mk,
    zpowersEquivZpowers_apply]
  dsimp
  -- âŠ¢ â†‘(Ï„ ^ (n + 1)) (Classical.choose hÏ„) = â†‘Ï„ (â†‘(Ï„ ^ n) (Classical.choose hÏ„))
  rw [pow_succ, Perm.mul_apply]
  -- ğŸ‰ no goals
#align equiv.perm.is_cycle.is_conj Equiv.Perm.IsCycle.isConj

theorem IsCycle.isConj_iff (hÏƒ : IsCycle Ïƒ) (hÏ„ : IsCycle Ï„) :
    IsConj Ïƒ Ï„ â†” Ïƒ.support.card = Ï„.support.card :=
  âŸ¨by
    intro h
    -- âŠ¢ card (support Ïƒ) = card (support Ï„)
    obtain âŸ¨Ï€, rflâŸ© := (_root_.isConj_iff).1 h
    -- âŠ¢ card (support Ïƒ) = card (support (Ï€ * Ïƒ * Ï€â»Â¹))
    refine' Finset.card_congr (fun a _ => Ï€ a) (fun _ ha => _) (fun _ _ _ _ ab => Ï€.injective ab)
        fun b hb => _
    Â· simp [mem_support.1 ha]
      -- ğŸ‰ no goals
    Â· refine' âŸ¨Ï€â»Â¹ b, âŸ¨_, Ï€.apply_inv_self bâŸ©âŸ©
      -- âŠ¢ â†‘Ï€â»Â¹ b âˆˆ support Ïƒ
      contrapose! hb
      -- âŠ¢ Â¬b âˆˆ support (Ï€ * Ïƒ * Ï€â»Â¹)
      rw [mem_support, Classical.not_not] at hb
      -- âŠ¢ Â¬b âˆˆ support (Ï€ * Ïƒ * Ï€â»Â¹)
      rw [mem_support, Classical.not_not, Perm.mul_apply, Perm.mul_apply, hb, Perm.apply_inv_self],
      -- ğŸ‰ no goals
    hÏƒ.isConj hÏ„âŸ©
#align equiv.perm.is_cycle.is_conj_iff Equiv.Perm.IsCycle.isConj_iff

@[simp]
theorem support_conj : (Ïƒ * Ï„ * Ïƒâ»Â¹).support = Ï„.support.map Ïƒ.toEmbedding := by
  ext
  -- âŠ¢ aâœ âˆˆ support (Ïƒ * Ï„ * Ïƒâ»Â¹) â†” aâœ âˆˆ map (Equiv.toEmbedding Ïƒ) (support Ï„)
  simp only [mem_map_equiv, Perm.coe_mul, Function.comp_apply, Ne.def, Perm.mem_support,
    Equiv.eq_symm_apply]
  rfl
  -- ğŸ‰ no goals
#align equiv.perm.support_conj Equiv.Perm.support_conj

theorem card_support_conj : (Ïƒ * Ï„ * Ïƒâ»Â¹).support.card = Ï„.support.card := by simp
                                                                              -- ğŸ‰ no goals
#align equiv.perm.card_support_conj Equiv.Perm.card_support_conj

end

theorem Disjoint.isConj_mul {Î± : Type*} [Finite Î±] {Ïƒ Ï„ Ï€ Ï : Perm Î±} (hc1 : IsConj Ïƒ Ï€)
    (hc2 : IsConj Ï„ Ï) (hd1 : Disjoint Ïƒ Ï„) (hd2 : Disjoint Ï€ Ï) : IsConj (Ïƒ * Ï„) (Ï€ * Ï) := by
  classical
    cases nonempty_fintype Î±
    obtain âŸ¨f, rflâŸ© := isConj_iff.1 hc1
    obtain âŸ¨g, rflâŸ© := isConj_iff.1 hc2
    have hd1' := coe_inj.2 hd1.support_mul
    have hd2' := coe_inj.2 hd2.support_mul
    rw [coe_union] at *
    have hd1'' := disjoint_coe.2 (disjoint_iff_disjoint_support.1 hd1)
    have hd2'' := disjoint_coe.2 (disjoint_iff_disjoint_support.1 hd2)
    refine' isConj_of_support_equiv _ _
    Â· refine'
          ((Equiv.Set.ofEq hd1').trans (Equiv.Set.union hd1''.le_bot)).trans
            ((Equiv.sumCongr (subtypeEquiv f fun a => _) (subtypeEquiv g fun a => _)).trans
              ((Equiv.Set.ofEq hd2').trans (Equiv.Set.union hd2''.le_bot)).symm) <;>
      Â· simp only [Set.mem_image, toEmbedding_apply, exists_eq_right, support_conj, coe_map,
          apply_eq_iff_eq]
    Â· intro x hx
      simp only [trans_apply, symm_trans_apply, Equiv.Set.ofEq_apply, Equiv.Set.ofEq_symm_apply,
        Equiv.sumCongr_apply]
      rw [hd1', Set.mem_union] at hx
      cases' hx with hxÏƒ hxÏ„
      Â· rw [mem_coe, mem_support] at hxÏƒ
        rw [Set.union_apply_left hd1''.le_bot _, Set.union_apply_left hd1''.le_bot _]
        simp only [subtypeEquiv_apply, Perm.coe_mul, Sum.map_inl, comp_apply,
          Set.union_symm_apply_left, Subtype.coe_mk, apply_eq_iff_eq]
        Â· have h := (hd2 (f x)).resolve_left ?_
          Â· rw [mul_apply, mul_apply] at h
            rw [h, inv_apply_self, (hd1 x).resolve_left hxÏƒ]
          Â· rwa [mul_apply, mul_apply, inv_apply_self, apply_eq_iff_eq]
        Â· rwa [Subtype.coe_mk, Perm.mul_apply, (hd1 x).resolve_left hxÏƒ, mem_coe,
            apply_mem_support, mem_support]
        Â· rwa [Subtype.coe_mk, mem_coe, mem_support]
      Â· rw [mem_coe, â† apply_mem_support, mem_support] at hxÏ„
        rw [Set.union_apply_right hd1''.le_bot _, Set.union_apply_right hd1''.le_bot _]
        simp only [subtypeEquiv_apply, Perm.coe_mul, Sum.map_inr, comp_apply,
          Set.union_symm_apply_right, Subtype.coe_mk, apply_eq_iff_eq]
        Â· have h := (hd2 (g (Ï„ x))).resolve_right ?_
          Â· rw [mul_apply, mul_apply] at h
            rw [inv_apply_self, h, (hd1 (Ï„ x)).resolve_right hxÏ„]
          Â· rwa [mul_apply, mul_apply, inv_apply_self, apply_eq_iff_eq]
        Â· rwa [Subtype.coe_mk, Perm.mul_apply, (hd1 (Ï„ x)).resolve_right hxÏ„,
            mem_coe, mem_support]
        Â· rwa [Subtype.coe_mk, mem_coe, â† apply_mem_support, mem_support]
#align equiv.perm.disjoint.is_conj_mul Equiv.Perm.Disjoint.isConj_mul

section FixedPoints

/-!
### Fixed points
-/


theorem fixed_point_card_lt_of_ne_one [Fintype Î±] {Ïƒ : Perm Î±} (h : Ïƒ â‰  1) :
    (filter (fun x => Ïƒ x = x) univ).card < Fintype.card Î± - 1 := by
  rw [lt_tsub_iff_left, â† lt_tsub_iff_right, â† Finset.card_compl, Finset.compl_filter]
  -- âŠ¢ 1 < card (filter (fun x => Â¬â†‘Ïƒ x = x) univ)
  exact one_lt_card_support_of_ne_one h
  -- ğŸ‰ no goals
#align equiv.perm.fixed_point_card_lt_of_ne_one Equiv.Perm.fixed_point_card_lt_of_ne_one

end FixedPoints

end

open Equiv

namespace List

variable [DecidableEq Î±] {l : List Î±}

set_option linter.deprecated false in -- nthLe
theorem _root_.List.Nodup.isCycleOn_formPerm (h : l.Nodup) :
    l.formPerm.IsCycleOn { a | a âˆˆ l } := by
  refine' âŸ¨l.formPerm.bijOn fun _ => List.formPerm_mem_iff_mem, fun a ha b hb => _âŸ©
  -- âŠ¢ SameCycle (List.formPerm l) a b
  rw [Set.mem_setOf, â† List.indexOf_lt_length] at ha hb
  -- âŠ¢ SameCycle (List.formPerm l) a b
  rw [â† List.indexOf_get ha, â† List.indexOf_get hb]
  -- âŠ¢ SameCycle (List.formPerm l) (List.get l { val := List.indexOf a l, isLt := h â€¦
  refine' âŸ¨l.indexOf b - l.indexOf a, _âŸ©
  -- âŠ¢ â†‘(List.formPerm l ^ (â†‘(List.indexOf b l) - â†‘(List.indexOf a l))) (List.get l â€¦
  simp only [sub_eq_neg_add, zpow_add, zpow_neg, Equiv.Perm.inv_eq_iff_eq, zpow_ofNat,
    Equiv.Perm.coe_mul, â† List.nthLe_eq, List.formPerm_pow_apply_nthLe _ h, Function.comp]
  rw [add_comm]
  -- ğŸ‰ no goals
#align list.nodup.is_cycle_on_form_perm List.Nodup.isCycleOn_formPerm

end List

namespace Int

open Equiv

theorem _root_.Int.addLeft_one_isCycle : (Equiv.addLeft 1 : Perm â„¤).IsCycle :=
  âŸ¨0, one_ne_zero, fun n _ => âŸ¨n, by simpâŸ©âŸ©
                                     -- ğŸ‰ no goals
#align int.add_left_one_is_cycle Int.addLeft_one_isCycle

theorem _root_.Int.addRight_one_isCycle : (Equiv.addRight 1 : Perm â„¤).IsCycle :=
  âŸ¨0, one_ne_zero, fun n _ => âŸ¨n, by simpâŸ©âŸ©
                                     -- ğŸ‰ no goals
#align int.add_right_one_is_cycle Int.addRight_one_isCycle

end Int

namespace Finset

variable [DecidableEq Î±] [Fintype Î±]

theorem _root_.Finset.exists_cycleOn (s : Finset Î±) :
    âˆƒ f : Perm Î±, f.IsCycleOn s âˆ§ f.support âŠ† s := by
  refine'
    âŸ¨s.toList.formPerm, _, fun x hx => by
      simpa using List.mem_of_formPerm_apply_ne _ _ (Perm.mem_support.1 hx)âŸ©
  convert s.nodup_toList.isCycleOn_formPerm
  -- âŠ¢ â†‘s = {a | a âˆˆ toList s}
  simp
  -- ğŸ‰ no goals
#align finset.exists_cycle_on Finset.exists_cycleOn

end Finset

namespace Set

variable {f : Perm Î±} {s : Set Î±}

theorem _root_.Set.Countable.exists_cycleOn (hs : s.Countable) :
    âˆƒ f : Perm Î±, f.IsCycleOn s âˆ§ { x | f x â‰  x } âŠ† s := by
  classical
    obtain hs' | hs' := s.finite_or_infinite
    Â· refine'
        âŸ¨hs'.toFinset.toList.formPerm, _, fun x hx => by
          simpa using List.mem_of_formPerm_apply_ne _ _ hxâŸ©
      convert hs'.toFinset.nodup_toList.isCycleOn_formPerm
      simp
    haveI := hs.to_subtype
    haveI := hs'.to_subtype
    obtain âŸ¨fâŸ© : Nonempty (â„¤ â‰ƒ s) := inferInstance
    refine'
      âŸ¨(Equiv.addRight 1).extendDomain f, _, fun x hx =>
        of_not_not fun h => hx <| Perm.extendDomain_apply_not_subtype _ _ hâŸ©
    convert Int.addRight_one_isCycle.isCycleOn.extendDomain f
    rw [Set.image_comp, Equiv.image_eq_preimage]
    ext
    simp
#align set.countable.exists_cycle_on Set.Countable.exists_cycleOn

theorem _root_.Set.prod_self_eq_iUnion_perm (hf : f.IsCycleOn s) :
    s Ã—Ë¢ s = â‹ƒ n : â„¤, (fun a => (a, (f ^ n) a)) '' s := by
  ext âŸ¨a, bâŸ©
  -- âŠ¢ (a, b) âˆˆ s Ã—Ë¢ s â†” (a, b) âˆˆ â‹ƒ (n : â„¤), (fun a => (a, â†‘(f ^ n) a)) '' s
  simp only [Set.mem_prod, Set.mem_iUnion, Set.mem_image]
  -- âŠ¢ a âˆˆ s âˆ§ b âˆˆ s â†” âˆƒ i x, x âˆˆ s âˆ§ (x, â†‘(f ^ i) x) = (a, b)
  refine' âŸ¨fun hx => _, _âŸ©
  -- âŠ¢ âˆƒ i x, x âˆˆ s âˆ§ (x, â†‘(f ^ i) x) = (a, b)
  Â· obtain âŸ¨n, rflâŸ© := hf.2 hx.1 hx.2
    -- âŠ¢ âˆƒ i x, x âˆˆ s âˆ§ (x, â†‘(f ^ i) x) = (a, â†‘(f ^ n) a)
    exact âŸ¨_, _, hx.1, rflâŸ©
    -- ğŸ‰ no goals
  Â· rintro âŸ¨n, a, ha, âŸ¨âŸ©âŸ©
    -- âŠ¢ a âˆˆ s âˆ§ â†‘(f ^ n) a âˆˆ s
    exact âŸ¨ha, (hf.1.perm_zpow _).mapsTo haâŸ©
    -- ğŸ‰ no goals
#align set.prod_self_eq_Union_perm Set.prod_self_eq_iUnion_perm

end Set

namespace Finset

variable {f : Perm Î±} {s : Finset Î±}

theorem _root_.Finset.product_self_eq_disj_Union_perm_aux (hf : f.IsCycleOn s) :
    (range s.card : Set â„•).PairwiseDisjoint fun k =>
      s.map âŸ¨fun i => (i, (f ^ k) i), fun i j => congr_arg Prod.fstâŸ© := by
  obtain hs | _ := (s : Set Î±).subsingleton_or_nontrivial
  -- âŠ¢ Set.PairwiseDisjoint â†‘(range (card s)) fun k => map { toFun := fun i => (i,  â€¦
  Â· refine' Set.Subsingleton.pairwise _ _
    -- âŠ¢ Set.Subsingleton â†‘(range (card s))
    simp_rw [Set.Subsingleton, mem_coe, â† card_le_one] at hs âŠ¢
    -- âŠ¢ card (range (card s)) â‰¤ 1
    rwa [card_range]
    -- ğŸ‰ no goals
  classical
    rintro m hm n hn hmn
    simp only [disjoint_left, Function.onFun, mem_map, Function.Embedding.coeFn_mk, exists_prop,
      not_exists, not_and, forall_exists_index, and_imp, Prod.forall, Prod.mk.inj_iff]
    rintro _ _ _ - rfl rfl a ha rfl h
    rw [hf.pow_apply_eq_pow_apply ha] at h
    rw [mem_coe, mem_range] at hm hn
    exact hmn.symm (h.eq_of_lt_of_lt hn hm)
#align finset.product_self_eq_disj_Union_perm_aux Finset.product_self_eq_disj_Union_perm_aux

/-- We can partition the square `s Ã—Ë¢ s` into shifted diagonals as such:
```
01234
40123
34012
23401
12340
```

The diagonals are given by the cycle `f`.
-/
theorem _root_.Finset.product_self_eq_disjUnion_perm (hf : f.IsCycleOn s) :
    s Ã—Ë¢ s =
      (range s.card).disjiUnion
        (fun k => s.map âŸ¨fun i => (i, (f ^ k) i), fun i j => congr_arg Prod.fstâŸ©)
        (product_self_eq_disj_Union_perm_aux hf) := by
  ext âŸ¨a, bâŸ©
  -- âŠ¢ (a, b) âˆˆ s Ã—Ë¢ s â†” (a, b) âˆˆ disjiUnion (range (card s)) (fun k => map { toFun â€¦
  simp only [mem_product, Equiv.Perm.coe_pow, mem_disjiUnion, mem_range, mem_map,
    Function.Embedding.coeFn_mk, Prod.mk.inj_iff, exists_prop]
  refine' âŸ¨fun hx => _, _âŸ©
  -- âŠ¢ âˆƒ a_1, a_1 < card s âˆ§ âˆƒ a_2, a_2 âˆˆ s âˆ§ a_2 = a âˆ§ (â†‘f)^[a_1] a_2 = b
  Â· obtain âŸ¨n, hn, rflâŸ© := hf.exists_pow_eq hx.1 hx.2
    -- âŠ¢ âˆƒ a_1, a_1 < card s âˆ§ âˆƒ a_2, a_2 âˆˆ s âˆ§ a_2 = a âˆ§ (â†‘f)^[a_1] a_2 = â†‘(f ^ n) a
    exact âŸ¨n, hn, a, hx.1, rfl, by rw [f.iterate_eq_pow]âŸ©
    -- ğŸ‰ no goals
  Â· rintro âŸ¨n, -, a, ha, rfl, rflâŸ©
    -- âŠ¢ a âˆˆ s âˆ§ (â†‘f)^[n] a âˆˆ s
    exact âŸ¨ha, (hf.1.iterate _).mapsTo haâŸ©
    -- ğŸ‰ no goals
#align finset.product_self_eq_disj_Union_perm Finset.product_self_eq_disjUnionâ‚“_perm

end Finset

namespace Finset

variable [Semiring Î±] [AddCommMonoid Î²] [Module Î± Î²] {s : Finset Î¹} {Ïƒ : Perm Î¹}

theorem _root_.Finset.sum_smul_sum_eq_sum_perm (hÏƒ : Ïƒ.IsCycleOn s) (f : Î¹ â†’ Î±) (g : Î¹ â†’ Î²) :
    ((âˆ‘ i in s, f i) â€¢ âˆ‘ i in s, g i) = âˆ‘ k in range s.card, âˆ‘ i in s, f i â€¢ g ((Ïƒ ^ k) i) := by
  simp_rw [sum_smul_sum, product_self_eq_disjUnion_perm hÏƒ, sum_disjiUnion, sum_map]
  -- âŠ¢ âˆ‘ x in range (card s), âˆ‘ x_1 in s, f (â†‘{ toFun := fun i => (i, â†‘(Ïƒ ^ x) i),  â€¦
  rfl
  -- ğŸ‰ no goals
#align finset.sum_smul_sum_eq_sum_perm Finset.sum_smul_sum_eq_sum_perm

theorem _root_.Finset.sum_mul_sum_eq_sum_perm (hÏƒ : Ïƒ.IsCycleOn s) (f g : Î¹ â†’ Î±) :
    ((âˆ‘ i in s, f i) * âˆ‘ i in s, g i) = âˆ‘ k in range s.card, âˆ‘ i in s, f i * g ((Ïƒ ^ k) i) :=
  sum_smul_sum_eq_sum_perm hÏƒ f g
#align finset.sum_mul_sum_eq_sum_perm Finset.sum_mul_sum_eq_sum_perm

end Finset
