/-
Copyright (c) 2026 Boyang Hu. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Boyang Hu
-/
module

public import Mathlib.GroupTheory.Sylow
public import Mathlib.GroupTheory.Transfer

/-!
# Focal Subgroup Theorem

This file defines the focal subgroup and proves the Focal Subgroup Theorem.

## Main Theorem

* `inf_commutator_eq_focalSubgroup`: The Focal Subgroup Theorem.
  It states that for a Sylow p-subgroup `P`, `P ∩ G' = P*`, where `P*` is the focal subgroup.

## References

* [D. Gorenstein, *Finite Groups*][gorenstein1968]
-/

@[expose] public section

noncomputable section

open Function Subgroup Sylow

section Definitions

variable {G : Type*} [Group G] (H : Subgroup G)

namespace Subgroup

/--
The **Focal Subgroup** of a subgroup `H` (denoted `H*` or `foc(H)`).
It is generated by elements of the form `x⁻¹ * (u * x * u⁻¹)` where both `x` and `x^u` are in `H`.
-/
def focalSubgroup : Subgroup G :=
  closure { g | ∃ x ∈ H, ∃ u : G, u * x * u⁻¹ ∈ H ∧ g = x⁻¹ * (u * x * u⁻¹) }

/--
The focal subgroup considered as a subgroup of `H`.
Note that `focalSubgroup H` is always contained in `H`.
-/
def focalSubgroupOf {G : Type*} [Group G] (H : Subgroup G) : Subgroup H :=
  (focalSubgroup H).subgroupOf H

end Subgroup

/-- Lemma: The focal subgroup is indeed a subgroup of H. -/
lemma focalSubgroup_le_h : focalSubgroup H ≤ H := by
  rw [focalSubgroup, closure_le]
  rintro _ ⟨x, hxP, _, huxuP, rfl⟩
  exact H.mul_mem (H.inv_mem hxP) huxuP

/-- Lemma: H* is a normal subgroup of H. -/
instance : Normal (focalSubgroupOf H) := by
  unfold focalSubgroupOf
  rw [normal_subgroupOf_iff (focalSubgroup_le_h H)]
  intro n g hn hg
  unfold focalSubgroup at hn ⊢
  induction hn using closure_induction with
  | mem z hz =>
    obtain ⟨x, hxP, u, huxuP, rfl⟩ := hz
    exact subset_closure ⟨g * x * g⁻¹, H.mul_mem (H.mul_mem hg hxP) (H.inv_mem hg), g * u * g⁻¹,
      by convert H.mul_mem (H.mul_mem hg huxuP) (H.inv_mem hg) using 1;group, by group⟩
  | one => simp
  | mul _ _ _ _ IHa IHb => convert mul_mem IHa IHb using 1; group
  | inv _ _ IH => convert inv_mem IH using 1; group

/-- Lemma: The focal subgroup is contained in the commutator subgroup G'. -/
lemma focalSubgroup_le_commutator : focalSubgroup H ≤ commutator G := by
  rw [focalSubgroup,closure_le]
  intro g hg
  obtain ⟨x, hxP, u, huP, hg_eq⟩ := hg
  have h : x⁻¹ * (u * x * u⁻¹) = ⁅x⁻¹, u⁆ := by group
  rw [hg_eq, h, commutator_eq_closure]
  exact mem_closure.mpr fun K a ↦ a (commutator_mem_commutatorSet x⁻¹ u)

lemma quotient_focalSubgroup_comm : ∀ (x y : H ⧸ (focalSubgroupOf H)), x * y = y * x := by
  have h_comm_in_focal : ∀ (a b : H),
      (⁅(a : G), (b : G)⁆ : G) ∈ focalSubgroup H := fun a b =>
    subset_closure ⟨a⁻¹, H.inv_mem a.2, b,
      H.1.mul_mem (H.mul_mem b.2 (H.inv_mem a.2)) (H.inv_mem b.2), by simp; group⟩
  have h_commutator_le : commutator H ≤ (focalSubgroupOf H) := by
    rw [commutator_eq_closure, closure_le]
    rintro _ ⟨a, b, rfl⟩
    simpa [mem_subgroupOf] using h_comm_in_focal a b
  exact (Normal.quotient_commutative_iff_commutator_le.mpr h_commutator_le).comm

instance focalSubgroup_quotient_commGroup : CommGroup (H ⧸ (focalSubgroupOf H)) :=
  @CommGroup.ofIsMulCommutative _ _ ⟨⟨quotient_focalSubgroup_comm H⟩⟩

namespace Sylow

/--
The Transfer homomorphism `V : G → H/H*`.
Defined using the abelian quotient H/H*.
-/
def transferFocal [H.FiniteIndex] :
    G →* H ⧸ (focalSubgroupOf H) :=
  MonoidHom.transfer (QuotientGroup.mk' (focalSubgroupOf H))

end Sylow

end Definitions

section TransferLemmas

variable {G : Type*} [Group G] (H : Subgroup G)

/--
The conjugate element `g⁻¹ * x^n * g` is equivalent to `x^n` modulo `H*` when both are in `H`.
This is because their difference lies in the focal subgroup by definition.
-/
lemma focalSubgroup_conj_pow_eq (x : H)
    (q : Quotient (MulAction.orbitRel (zpowers (x : G)) (G ⧸ H))) :
    (QuotientGroup.mk' (focalSubgroupOf H))
    ⟨q.out.out⁻¹ * (x : G) ^ (minimalPeriod ((x : G) • ·) q.out) * q.out.out,
       QuotientGroup.out_conj_pow_minimalPeriod_mem H x q.out⟩ =
    (QuotientGroup.mk' (focalSubgroupOf H))
    ⟨(x : G) ^ (minimalPeriod ((x : G) • ·) q.out), H.pow_mem x.2 _⟩ := by
  apply QuotientGroup.eq.mpr
  unfold focalSubgroupOf
  rw [mem_subgroupOf]
  refine closure_mono le_rfl ?_
  rw [mem_closure]
  intro K hK
  have h_focal : ((x : G) ^ minimalPeriod ((x : G) • ·) q.out)⁻¹ *
      (q.out.out⁻¹ * (x : G) ^ minimalPeriod ((x : G) • ·) q.out * q.out.out) ∈ K := by
    refine hK ⟨(x : G) ^ minimalPeriod ((x : G) • ·) q.out, H.pow_mem x.2 _, q.out.out⁻¹,
      ?_, by simp⟩
    simpa using QuotientGroup.out_conj_pow_minimalPeriod_mem H x q.out
  simpa [mul_inv_rev] using K.inv_mem h_focal

/--
The product of powers in an abelian quotient equals the power of the sum of exponents.
-/
lemma focalSubgroup_prod_pow_eq_pow_sum (x : H)
    [Fintype (Quotient (MulAction.orbitRel (zpowers (x : G)) (G ⧸ H)))] :
    ∏ q : Quotient (MulAction.orbitRel (zpowers (x : G)) (G ⧸ H)),
      (QuotientGroup.mk' (focalSubgroupOf H))
      ⟨(x : G) ^ (minimalPeriod ((x : G) • ·) q.out), H.pow_mem x.2 _⟩ =
    (QuotientGroup.mk' (focalSubgroupOf H)) x ^
    (∑ q : Quotient (MulAction.orbitRel (zpowers (x : G)) (G ⧸ H)),
      minimalPeriod ((x : G) • ·) q.out) := by
  rw [← Finset.prod_pow_eq_pow_sum]
  exact Finset.prod_congr rfl fun _ _ => rfl

/--
The sum of minimal periods over all orbits equals the index `[G:H]`.
This follows from the orbit-counting formula.
-/
lemma sum_minimalPeriod_eq_index (x : H) [Finite (G ⧸ H)]
    [Fintype (Quotient (MulAction.orbitRel (zpowers (x : G)) (G ⧸ H)))] :
    ∑ q : Quotient (MulAction.orbitRel (zpowers (x : G)) (G ⧸ H)),
      minimalPeriod ((x : G) • ·) q.out = H.index := by
  haveI : Fintype (G ⧸ H) := Fintype.ofFinite _
  let Q := Quotient (MulAction.orbitRel (zpowers (x : G)) (G ⧸ H))
  haveI : ∀ q : Q, Fintype (MulAction.orbit (zpowers (x : G)) q.out) := fun q =>
    Fintype.ofFinite _
  have h_card : Fintype.card (G ⧸ H) =
      ∑ q : Q, Fintype.card (MulAction.orbit (zpowers (x : G)) q.out) := by
    rw [← Fintype.card_sigma]
    exact Fintype.card_congr (MulAction.selfEquivSigmaOrbits (zpowers (x : G)) (G ⧸ H))
  have h_period_eq_card : ∀ q : Q, minimalPeriod ((x : G) • ·) q.out =
        Fintype.card (MulAction.orbit (zpowers (x : G)) q.out) := fun q =>
    MulAction.minimalPeriod_eq_card (x : G) q.out
  simp only [h_period_eq_card, index_eq_card, Nat.card_eq_fintype_card]
  rw [h_card]

/--
Key Lemma: The restriction of the Transfer map to `H` acts like the power map `x ↦ x^n` mod `H*`,
where `n = [G:H]`.
-/
theorem transfer_restricted_to_p_eq_pow [Finite G] (x : H) :
    MonoidHom.transfer (QuotientGroup.mk' (focalSubgroupOf H)) x =
    (QuotientGroup.mk' (focalSubgroupOf H) x) ^ H.index := by
  let φ := QuotientGroup.mk' (focalSubgroupOf H)
  haveI : Fintype (G ⧸ H) := Fintype.ofFinite (G ⧸ H)
  haveI : Fintype (Quotient (MulAction.orbitRel (zpowers (x : G)) (G ⧸ H))) :=
    Fintype.ofFinite _
  rw [MonoidHom.transfer_eq_prod_quotient_orbitRel_zpowers_quot φ x]
  rw [Finset.prod_congr rfl (fun q _ => focalSubgroup_conj_pow_eq H x q)]
  rw [focalSubgroup_prod_pow_eq_pow_sum H x]
  rw [sum_minimalPeriod_eq_index H x]

end TransferLemmas

section FocalSubgroupTheorem

variable {G : Type*} [Group G] [Finite G] {p : ℕ} [Fact (Nat.Prime p)] (P : Sylow p G)

/-- Lemma: The power map `y ↦ y^n` is surjective on `P/P*` because `gcd(n, p) = 1`. -/
lemma pow_n_surjective_on_p_quotient :
    Surjective (fun (y : P.toSubgroup ⧸ focalSubgroupOf P.toSubgroup) =>
    y ^ (index P.toSubgroup)) := by
  have hn : p.Coprime (index P.toSubgroup) :=
    (Nat.Prime.coprime_iff_not_dvd Fact.out).mpr (Sylow.not_dvd_index P)
  have hQ : IsPGroup p (P.toSubgroup ⧸ focalSubgroupOf P.toSubgroup) :=
    IsPGroup.to_quotient P.2 (focalSubgroupOf P.toSubgroup)
  intro g
  exact ⟨(hQ.powEquiv hn).symm g, (hQ.powEquiv hn).apply_symm_apply g⟩

/-- Lemma: The Transfer homomorphism is surjective from `G` to `P/P*`. -/
lemma transfer_restrict_surjective :
    Surjective (transferFocal P.toSubgroup) := by
  intro z
  obtain ⟨y, hy⟩ := pow_n_surjective_on_p_quotient P z
  obtain ⟨x, hx⟩ := QuotientGroup.mk'_surjective _ y
  exact ⟨x, by simp only [transferFocal, transfer_restricted_to_p_eq_pow, ← hy, ← hx]⟩

/-- Isomorphism theorem: `G / ker(V) ≅ P / P*`. -/
theorem quotient_ker_iso_quotient_focal :
    Nonempty ((G ⧸ (transferFocal P.toSubgroup).ker) ≃*
    (P.toSubgroup ⧸ focalSubgroupOf P.toSubgroup)) := by
  letI : P.toSubgroup.FiniteIndex := finiteIndex_of_finite_quotient
  let τ := transferFocal P.toSubgroup
  have hsurj : Function.Surjective τ := transfer_restrict_surjective P
  exact ⟨QuotientGroup.quotientKerEquivOfSurjective τ hsurj⟩

omit [Fact (Nat.Prime p)] in
lemma inf_commutator_le_inf_ker_transferFocal :
    P.toSubgroup ⊓ commutator G ≤ P.toSubgroup ⊓ (transferFocal P.toSubgroup).ker := by
  haveI : P.toSubgroup.FiniteIndex := Subgroup.finiteIndex_of_finite_quotient
  apply inf_le_inf_left
  rw [commutator_eq_closure, Subgroup.closure_le]
  rintro _ ⟨a, b, rfl⟩
  simp only [SetLike.mem_coe, MonoidHom.mem_ker, map_commutatorElement]
  rw [commutatorElement_def]
  rw [mul_comm ((transferFocal P.toSubgroup) a) ((transferFocal P.toSubgroup) b)]
  group

lemma inf_ker_transferFocal_eq_focalSubgroup :
    P.toSubgroup ⊓ (transferFocal P.toSubgroup).ker = focalSubgroup P := by
  have hn : p.Coprime P.index :=
    (Nat.Prime.coprime_iff_not_dvd Fact.out).mpr (Sylow.not_dvd_index P)
  let F := focalSubgroupOf P.toSubgroup
  have hQ : IsPGroup p (P.toSubgroup ⧸ F ) := IsPGroup.to_quotient P.2 _
  have hker : F = (QuotientGroup.mk' F).ker := (QuotientGroup.ker_mk' F).symm
  apply le_antisymm
  · intro x ⟨hxP, hx_ker⟩
    simp only [mem_toSubmonoid, SetLike.mem_coe, MonoidHom.mem_ker] at hx_ker
    simp only [transferFocal, transfer_restricted_to_p_eq_pow P ⟨x, hxP⟩] at hx_ker
    have h_mem : (⟨x, hxP⟩ : P.toSubgroup) ∈ F := by
      rw [hker, MonoidHom.mem_ker]
      have h1 : (hQ.powEquiv hn) (QuotientGroup.mk' _ ⟨x, hxP⟩) = 1 := by
        rw [hQ.powEquiv_apply, hx_ker]
      have h2 : (hQ.powEquiv hn) 1 = 1 := by simp [hQ.powEquiv_apply]
      exact (hQ.powEquiv hn).injective (h1.trans h2.symm)
    simpa [mem_subgroupOf] using h_mem
  · intro x hx
    have hxP := focalSubgroup_le_h P.toSubgroup hx
    refine ⟨hxP, ?_⟩
    simp only [mem_toSubmonoid, SetLike.mem_coe, MonoidHom.mem_ker, transferFocal]
    rw [transfer_restricted_to_p_eq_pow P ⟨x, hxP⟩]
    have h_mem : (⟨x, hxP⟩ : P.toSubgroup) ∈ F := by
      unfold F focalSubgroupOf
      simp [mem_subgroupOf, hx]
    rw [hker, MonoidHom.mem_ker] at h_mem
    unfold F at h_mem
    simp [h_mem]

/--
**The Focal Subgroup Theorem**

For a Sylow p-subgroup P of a finite group G, `P ∩ G' = P*`,
where `P*` is the focal subgroup of `P`.
-/
theorem inf_commutator_eq_focalSubgroup :
    P.toSubgroup ⊓ commutator G = focalSubgroup P := by
  have h_le := inf_commutator_le_inf_ker_transferFocal P
  have h_eq := inf_ker_transferFocal_eq_focalSubgroup P
  have h_ge := le_inf (focalSubgroup_le_h P.toSubgroup) (focalSubgroup_le_commutator P.toSubgroup)
  exact le_antisymm (h_le.trans_eq h_eq) h_ge

end FocalSubgroupTheorem
end
