/-
Copyright (c) 2018 Kevin Buzzard, Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kevin Buzzard, Patrick Massot

This file is to a certain extent based on `quotient_module.lean` by Johannes H√∂lzl.
-/
import Mathlib.GroupTheory.Congruence
import Mathlib.GroupTheory.Coset
import Mathlib.GroupTheory.Subgroup.Finite
import Mathlib.GroupTheory.Subgroup.Pointwise

#align_import group_theory.quotient_group from "leanprover-community/mathlib"@"59694bd07f0a39c5beccba34bd9f413a160782bf"

/-!
# Quotients of groups by normal subgroups

This files develops the basic theory of quotients of groups by normal subgroups. In particular it
proves Noether's first and second isomorphism theorems.

## Main definitions

* `mk'`: the canonical group homomorphism `G ‚Üí* G/N` given a normal subgroup `N` of `G`.
* `lift œÜ`: the group homomorphism `G/N ‚Üí* H` given a group homomorphism `œÜ : G ‚Üí* H` such that
  `N ‚äÜ ker œÜ`.
* `map f`: the group homomorphism `G/N ‚Üí* H/M` given a group homomorphism `f : G ‚Üí* H` such that
  `N ‚äÜ f‚Åª¬π(M)`.

## Main statements

* `QuotientGroup.quotientKerEquivRange`: Noether's first isomorphism theorem, an explicit
  isomorphism `G/ker œÜ ‚Üí range œÜ` for every group homomorphism `œÜ : G ‚Üí* H`.
* `QuotientGroup.quotientInfEquivProdNormalQuotient`: Noether's second isomorphism theorem, an
  explicit isomorphism between `H/(H ‚à© N)` and `(HN)/N` given a subgroup `H` and a normal subgroup
  `N` of a group `G`.
* `QuotientGroup.quotientQuotientEquivQuotient`: Noether's third isomorphism theorem,
  the canonical isomorphism between `(G / N) / (M / N)` and `G / M`, where `N ‚â§ M`.

## Tags

isomorphism theorems, quotient groups
-/


open Function

universe u v w x

namespace QuotientGroup

variable {G : Type u} [Group G] (N : Subgroup G) [nN : N.Normal] {H : Type v} [Group H]
  {M : Type x} [Monoid M]

/-- The congruence relation generated by a normal subgroup. -/
@[to_additive "The additive congruence relation generated by a normal additive subgroup."]
protected def con : Con G where
  toSetoid := leftRel N
  mul' := @fun a b c d hab hcd => by
    rw [leftRel_eq] at hab hcd ‚ä¢
    -- ‚ä¢ (fun x y => x‚Åª¬π * y ‚àà N) (a * c) (b * d)
    dsimp only
    -- ‚ä¢ (a * c)‚Åª¬π * (b * d) ‚àà N
    calc
      (a * c)‚Åª¬π * (b * d) = c‚Åª¬π * (a‚Åª¬π * b) * c‚Åª¬π‚Åª¬π * (c‚Åª¬π * d) :=
        by simp only [mul_inv_rev, mul_assoc, inv_mul_cancel_left]
      _ ‚àà N := N.mul_mem (nN.conj_mem _ hab _) hcd
#align quotient_group.con QuotientGroup.con
#align quotient_add_group.con QuotientAddGroup.con

@[to_additive]
instance Quotient.group : Group (G ‚ß∏ N) :=
  (QuotientGroup.con N).group
#align quotient_group.quotient.group QuotientGroup.Quotient.group
#align quotient_add_group.quotient.add_group QuotientAddGroup.Quotient.addGroup

/-- The group homomorphism from `G` to `G/N`. -/
@[to_additive "The additive group homomorphism from `G` to `G/N`."]
def mk' : G ‚Üí* G ‚ß∏ N :=
  MonoidHom.mk' QuotientGroup.mk fun _ _ => rfl
#align quotient_group.mk' QuotientGroup.mk'
#align quotient_add_group.mk' QuotientAddGroup.mk'

@[to_additive (attr := simp)]
theorem coe_mk' : (mk' N : G ‚Üí G ‚ß∏ N) = mk :=
  rfl
#align quotient_group.coe_mk' QuotientGroup.coe_mk'
#align quotient_add_group.coe_mk' QuotientAddGroup.coe_mk'

@[to_additive (attr := simp)]
theorem mk'_apply (x : G) : mk' N x = x :=
  rfl
#align quotient_group.mk'_apply QuotientGroup.mk'_apply
#align quotient_add_group.mk'_apply QuotientAddGroup.mk'_apply

@[to_additive]
theorem mk'_surjective : Surjective <| mk' N :=
  @mk_surjective _ _ N
#align quotient_group.mk'_surjective QuotientGroup.mk'_surjective
#align quotient_add_group.mk'_surjective QuotientAddGroup.mk'_surjective

@[to_additive]
theorem mk'_eq_mk' {x y : G} : mk' N x = mk' N y ‚Üî ‚àÉ z ‚àà N, x * z = y :=
  QuotientGroup.eq'.trans <| by
    simp only [‚Üê _root_.eq_inv_mul_iff_mul_eq, exists_prop, exists_eq_right]
    -- üéâ no goals
#align quotient_group.mk'_eq_mk' QuotientGroup.mk'_eq_mk'
#align quotient_add_group.mk'_eq_mk' QuotientAddGroup.mk'_eq_mk'

/-- Two `MonoidHom`s from a quotient group are equal if their compositions with
`QuotientGroup.mk'` are equal.

See note [partially-applied ext lemmas]. -/
@[to_additive (attr := ext 1100) "Two `AddMonoidHom`s from an additive quotient group are equal if
 their compositions with `AddQuotientGroup.mk'` are equal.

 See note [partially-applied ext lemmas]. "]
theorem monoidHom_ext ‚¶Éf g : G ‚ß∏ N ‚Üí* M‚¶Ñ (h : f.comp (mk' N) = g.comp (mk' N)) : f = g :=
  MonoidHom.ext fun x => QuotientGroup.induction_on x <| (FunLike.congr_fun h : _)
#align quotient_group.monoid_hom_ext QuotientGroup.monoidHom_ext
#align quotient_add_group.add_monoid_hom_ext QuotientAddGroup.addMonoidHom_ext

@[to_additive (attr := simp)]
theorem eq_one_iff {N : Subgroup G} [nN : N.Normal] (x : G) : (x : G ‚ß∏ N) = 1 ‚Üî x ‚àà N := by
  refine' QuotientGroup.eq.trans _
  -- ‚ä¢ x‚Åª¬π * 1 ‚àà N ‚Üî x ‚àà N
  rw [mul_one, Subgroup.inv_mem_iff]
  -- üéâ no goals
#align quotient_group.eq_one_iff QuotientGroup.eq_one_iff
#align quotient_add_group.eq_zero_iff QuotientAddGroup.eq_zero_iff

@[to_additive]
theorem ker_le_range_iff {I : Type w} [Group I] (f : G ‚Üí* H) [f.range.Normal] (g : H ‚Üí* I) :
    g.ker ‚â§ f.range ‚Üî (mk' f.range).comp g.ker.subtype = 1 :=
  ‚ü®fun h => MonoidHom.ext fun ‚ü®_, hx‚ü© => (eq_one_iff _).mpr <| h hx,
    fun h x hx => (eq_one_iff _).mp <| by exact FunLike.congr_fun h ‚ü®x, hx‚ü©‚ü©
                                          -- üéâ no goals

@[to_additive (attr := simp)]
theorem ker_mk' : MonoidHom.ker (QuotientGroup.mk' N : G ‚Üí* G ‚ß∏ N) = N :=
  Subgroup.ext eq_one_iff
#align quotient_group.ker_mk QuotientGroup.ker_mk'
#align quotient_add_group.ker_mk QuotientAddGroup.ker_mk'
-- porting note: I think this is misnamed without the prime

@[to_additive]
theorem eq_iff_div_mem {N : Subgroup G} [nN : N.Normal] {x y : G} :
    (x : G ‚ß∏ N) = y ‚Üî x / y ‚àà N := by
  refine' eq_comm.trans (QuotientGroup.eq.trans _)
  -- ‚ä¢ y‚Åª¬π * x ‚àà N ‚Üî x / y ‚àà N
  rw [nN.mem_comm_iff, div_eq_mul_inv]
  -- üéâ no goals
#align quotient_group.eq_iff_div_mem QuotientGroup.eq_iff_div_mem
#align quotient_add_group.eq_iff_sub_mem QuotientAddGroup.eq_iff_sub_mem

-- for commutative groups we don't need normality assumption

@[to_additive]
instance Quotient.commGroup {G : Type*} [CommGroup G] (N : Subgroup G) : CommGroup (G ‚ß∏ N) :=
  { toGroup := @QuotientGroup.Quotient.group _ _ N N.normal_of_comm
    mul_comm := fun a b => Quotient.inductionOn‚ÇÇ' a b fun a b => congr_arg mk (mul_comm a b) }
#align quotient_group.quotient.comm_group QuotientGroup.Quotient.commGroup
#align quotient_add_group.quotient.add_comm_group QuotientAddGroup.Quotient.addCommGroup

local notation " Q " => G ‚ß∏ N

@[to_additive (attr := simp)]
theorem mk_one : ((1 : G) : Q ) = 1 :=
  rfl
#align quotient_group.coe_one QuotientGroup.mk_one
#align quotient_add_group.coe_zero QuotientAddGroup.mk_zero

@[to_additive (attr := simp)]
theorem mk_mul (a b : G) : ((a * b : G) : Q ) = a * b :=
  rfl
#align quotient_group.coe_mul QuotientGroup.mk_mul
#align quotient_add_group.coe_add QuotientAddGroup.mk_add

@[to_additive (attr := simp)]
theorem mk_inv (a : G) : ((a‚Åª¬π : G) : Q ) = (a : Q)‚Åª¬π :=
  rfl
#align quotient_group.coe_inv QuotientGroup.mk_inv
#align quotient_add_group.coe_neg QuotientAddGroup.mk_neg

@[to_additive (attr := simp)]
theorem mk_div (a b : G) : ((a / b : G) : Q ) = a / b :=
  rfl
#align quotient_group.coe_div QuotientGroup.mk_div
#align quotient_add_group.coe_sub QuotientAddGroup.mk_sub

@[to_additive (attr := simp)]
theorem mk_pow (a : G) (n : ‚Ñï) : ((a ^ n : G) : Q ) = (a : Q) ^ n :=
  rfl
#align quotient_group.coe_pow QuotientGroup.mk_pow
#align quotient_add_group.coe_nsmul QuotientAddGroup.mk_nsmul

@[to_additive (attr := simp)]
theorem mk_zpow (a : G) (n : ‚Ñ§) : ((a ^ n : G) : Q ) = (a : Q) ^ n :=
  rfl
#align quotient_group.coe_zpow QuotientGroup.mk_zpow
#align quotient_add_group.coe_zsmul QuotientAddGroup.mk_zsmul

/-- A group homomorphism `œÜ : G ‚Üí* M` with `N ‚äÜ ker(œÜ)` descends (i.e. `lift`s) to a
group homomorphism `G/N ‚Üí* M`. -/
@[to_additive "An `AddGroup` homomorphism `œÜ : G ‚Üí+ M` with `N ‚äÜ ker(œÜ)` descends (i.e. `lift`s)
 to a group homomorphism `G/N ‚Üí* M`."]
def lift (œÜ : G ‚Üí* M) (HN : ‚àÄ x ‚àà N, œÜ x = 1) : Q ‚Üí* M :=
  (QuotientGroup.con N).lift œÜ fun x y h => by
    simp only [QuotientGroup.con, leftRel_apply, Con.rel_mk] at h
    -- ‚ä¢ ‚Üë(Con.ker œÜ) x y
    rw [Con.ker_rel]
    -- ‚ä¢ ‚ÜëœÜ x = ‚ÜëœÜ y
    calc
      œÜ x = œÜ (y * (x‚Åª¬π * y)‚Åª¬π) := by rw [mul_inv_rev, inv_inv, mul_inv_cancel_left]
      _ = œÜ y := by rw [œÜ.map_mul, HN _ (N.inv_mem h), mul_one]
#align quotient_group.lift QuotientGroup.lift
#align quotient_add_group.lift QuotientAddGroup.lift

@[to_additive (attr := simp)]
theorem lift_mk {œÜ : G ‚Üí* M} (HN : ‚àÄ x ‚àà N, œÜ x = 1) (g : G) : lift N œÜ HN (g : Q ) = œÜ g :=
  rfl
#align quotient_group.lift_mk QuotientGroup.lift_mk
#align quotient_add_group.lift_mk QuotientAddGroup.lift_mk

@[to_additive (attr := simp)]
theorem lift_mk' {œÜ : G ‚Üí* M} (HN : ‚àÄ x ‚àà N, œÜ x = 1) (g : G) : lift N œÜ HN (mk g : Q ) = œÜ g :=
  rfl
-- TODO: replace `mk` with `mk'`)
#align quotient_group.lift_mk' QuotientGroup.lift_mk'
#align quotient_add_group.lift_mk' QuotientAddGroup.lift_mk'

@[to_additive (attr := simp)]
theorem lift_quot_mk {œÜ : G ‚Üí* M} (HN : ‚àÄ x ‚àà N, œÜ x = 1) (g : G) :
    lift N œÜ HN (Quot.mk _ g : Q ) = œÜ g :=
  rfl
#align quotient_group.lift_quot_mk QuotientGroup.lift_quot_mk
#align quotient_add_group.lift_quot_mk QuotientAddGroup.lift_quot_mk

/-- A group homomorphism `f : G ‚Üí* H` induces a map `G/N ‚Üí* H/M` if `N ‚äÜ f‚Åª¬π(M)`. -/
@[to_additive
      "An `AddGroup` homomorphism `f : G ‚Üí+ H` induces a map `G/N ‚Üí+ H/M` if `N ‚äÜ f‚Åª¬π(M)`."]
def map (M : Subgroup H) [M.Normal] (f : G ‚Üí* H) (h : N ‚â§ M.comap f) : G ‚ß∏ N ‚Üí* H ‚ß∏ M := by
  refine' QuotientGroup.lift N ((mk' M).comp f) _
  -- ‚ä¢ ‚àÄ (x : G), x ‚àà N ‚Üí ‚Üë(MonoidHom.comp (mk' M) f) x = 1
  intro x hx
  -- ‚ä¢ ‚Üë(MonoidHom.comp (mk' M) f) x = 1
  refine' QuotientGroup.eq.2 _
  -- ‚ä¢ (‚Üëf x)‚Åª¬π * 1 ‚àà M
  rw [mul_one, Subgroup.inv_mem_iff]
  -- ‚ä¢ ‚Üëf x ‚àà M
  exact h hx
  -- üéâ no goals
#align quotient_group.map QuotientGroup.map
#align quotient_add_group.map QuotientAddGroup.map

@[to_additive (attr := simp)]
theorem map_mk (M : Subgroup H) [M.Normal] (f : G ‚Üí* H) (h : N ‚â§ M.comap f) (x : G) :
    map N M f h ‚Üëx = ‚Üë(f x) :=
  rfl
#align quotient_group.map_coe QuotientGroup.map_mk
#align quotient_add_group.map_coe QuotientAddGroup.map_mk

@[to_additive]
theorem map_mk' (M : Subgroup H) [M.Normal] (f : G ‚Üí* H) (h : N ‚â§ M.comap f) (x : G) :
    map N M f h (mk' _ x) = ‚Üë(f x) :=
  rfl
#align quotient_group.map_mk' QuotientGroup.map_mk'
#align quotient_add_group.map_mk' QuotientAddGroup.map_mk'

@[to_additive]
theorem map_id_apply (h : N ‚â§ Subgroup.comap (MonoidHom.id _) N := (Subgroup.comap_id N).le) (x) :
    map N N (MonoidHom.id _) h x = x :=
  induction_on' x fun _x => rfl
#align quotient_group.map_id_apply QuotientGroup.map_id_apply
#align quotient_add_group.map_id_apply QuotientAddGroup.map_id_apply

@[to_additive (attr := simp)]
theorem map_id (h : N ‚â§ Subgroup.comap (MonoidHom.id _) N := (Subgroup.comap_id N).le) :
    map N N (MonoidHom.id _) h = MonoidHom.id _ :=
  MonoidHom.ext (map_id_apply N h)
#align quotient_group.map_id QuotientGroup.map_id
#align quotient_add_group.map_id QuotientAddGroup.map_id

@[to_additive (attr := simp)]
theorem map_map {I : Type*} [Group I] (M : Subgroup H) (O : Subgroup I) [M.Normal] [O.Normal]
    (f : G ‚Üí* H) (g : H ‚Üí* I) (hf : N ‚â§ Subgroup.comap f M) (hg : M ‚â§ Subgroup.comap g O)
    (hgf : N ‚â§ Subgroup.comap (g.comp f) O :=
      hf.trans ((Subgroup.comap_mono hg).trans_eq (Subgroup.comap_comap _ _ _)))
    (x : G ‚ß∏ N) : map M O g hg (map N M f hf x) = map N O (g.comp f) hgf x := by
  refine' induction_on' x fun x => _
  -- ‚ä¢ ‚Üë(map M O g hg) (‚Üë(map N M f hf) ‚Üëx) = ‚Üë(map N O (MonoidHom.comp g f) hgf) ‚Üëx
  simp only [map_mk, MonoidHom.comp_apply]
  -- üéâ no goals
#align quotient_group.map_map QuotientGroup.map_map
#align quotient_add_group.map_map QuotientAddGroup.map_map

@[to_additive (attr := simp)]
theorem map_comp_map {I : Type*} [Group I] (M : Subgroup H) (O : Subgroup I) [M.Normal] [O.Normal]
    (f : G ‚Üí* H) (g : H ‚Üí* I) (hf : N ‚â§ Subgroup.comap f M) (hg : M ‚â§ Subgroup.comap g O)
    (hgf : N ‚â§ Subgroup.comap (g.comp f) O :=
      hf.trans ((Subgroup.comap_mono hg).trans_eq (Subgroup.comap_comap _ _ _))) :
    (map M O g hg).comp (map N M f hf) = map N O (g.comp f) hgf :=
  MonoidHom.ext (map_map N M O f g hf hg hgf)
#align quotient_group.map_comp_map QuotientGroup.map_comp_map
#align quotient_add_group.map_comp_map QuotientAddGroup.map_comp_map

section congr

variable (G' : Subgroup G) (H' : Subgroup H) [Subgroup.Normal G'] [Subgroup.Normal H']

/-- `QuotientGroup.congr` lifts the isomorphism `e : G ‚âÉ H` to `G ‚ß∏ G' ‚âÉ H ‚ß∏ H'`,
given that `e` maps `G` to `H`. -/
@[to_additive "`QuotientAddGroup.congr` lifts the isomorphism `e : G ‚âÉ H` to `G ‚ß∏ G' ‚âÉ H ‚ß∏ H'`,
 given that `e` maps `G` to `H`."]
def congr (e : G ‚âÉ* H) (he : G'.map e = H') : G ‚ß∏ G' ‚âÉ* H ‚ß∏ H' :=
  { map G' H' e (he ‚ñ∏ G'.le_comap_map (e : G ‚Üí* H)) with
    toFun := map G' H' e (he ‚ñ∏ G'.le_comap_map (e : G ‚Üí* H))
    invFun := map H' G' e.symm (he ‚ñ∏ (G'.map_equiv_eq_comap_symm e).le)
    left_inv := fun x => by
      rw [map_map G' H' G' e e.symm (he ‚ñ∏ G'.le_comap_map (e : G ‚Üí* H))
        (he ‚ñ∏ (G'.map_equiv_eq_comap_symm e).le)]
      simp only [map_map, ‚Üê MulEquiv.coe_monoidHom_trans, MulEquiv.self_trans_symm,
        MulEquiv.coe_monoidHom_refl, map_id_apply]
    right_inv := fun x => by
      rw [map_map H' G' H' e.symm e (he ‚ñ∏ (G'.map_equiv_eq_comap_symm e).le)
        (he ‚ñ∏ G'.le_comap_map (e : G ‚Üí* H)) ]
      simp only [‚Üê MulEquiv.coe_monoidHom_trans, MulEquiv.symm_trans_self,
        MulEquiv.coe_monoidHom_refl, map_id_apply] }
#align quotient_group.congr QuotientGroup.congr
#align quotient_add_group.congr QuotientAddGroup.congr

@[simp]
theorem congr_mk (e : G ‚âÉ* H) (he : G'.map ‚Üëe = H') (x) : congr G' H' e he (mk x) = e x :=
  rfl
#align quotient_group.congr_mk QuotientGroup.congr_mk

theorem congr_mk' (e : G ‚âÉ* H) (he : G'.map ‚Üëe = H') (x) :
    congr G' H' e he (mk' G' x) = mk' H' (e x) :=
  rfl
#align quotient_group.congr_mk' QuotientGroup.congr_mk'

@[simp]
theorem congr_apply (e : G ‚âÉ* H) (he : G'.map ‚Üëe = H') (x : G) :
    congr G' H' e he x = mk' H' (e x) :=
  rfl
#align quotient_group.congr_apply QuotientGroup.congr_apply

@[simp]
theorem congr_refl (he : G'.map (MulEquiv.refl G : G ‚Üí* G) = G' := Subgroup.map_id G') :
    congr G' G' (MulEquiv.refl G) he = MulEquiv.refl (G ‚ß∏ G') := by
  ext ‚ü®x‚ü©
  -- ‚ä¢ ‚Üë(congr G' G' (MulEquiv.refl G) he) (Quot.mk Setoid.r x) = ‚Üë(MulEquiv.refl ( ‚Ä¶
  rfl
  -- üéâ no goals
#align quotient_group.congr_refl QuotientGroup.congr_refl

@[simp]
theorem congr_symm (e : G ‚âÉ* H) (he : G'.map ‚Üëe = H') :
    (congr G' H' e he).symm = congr H' G' e.symm ((Subgroup.map_symm_eq_iff_map_eq _).mpr he) :=
  rfl
#align quotient_group.congr_symm QuotientGroup.congr_symm

end congr

variable (œÜ : G ‚Üí* H)

open MonoidHom

/-- The induced map from the quotient by the kernel to the codomain. -/
@[to_additive "The induced map from the quotient by the kernel to the codomain."]
def kerLift : G ‚ß∏ ker œÜ ‚Üí* H :=
  lift _ œÜ fun _g => œÜ.mem_ker.mp
#align quotient_group.ker_lift QuotientGroup.kerLift
#align quotient_add_group.ker_lift QuotientAddGroup.kerLift

@[to_additive (attr := simp)]
theorem kerLift_mk (g : G) : (kerLift œÜ) g = œÜ g :=
  lift_mk _ _ _
#align quotient_group.ker_lift_mk QuotientGroup.kerLift_mk
#align quotient_add_group.ker_lift_mk QuotientAddGroup.kerLift_mk

@[to_additive (attr := simp)]
theorem kerLift_mk' (g : G) : (kerLift œÜ) (mk g) = œÜ g :=
  lift_mk' _ _ _
#align quotient_group.ker_lift_mk' QuotientGroup.kerLift_mk'
#align quotient_add_group.ker_lift_mk' QuotientAddGroup.kerLift_mk'

@[to_additive]
theorem kerLift_injective : Injective (kerLift œÜ) := fun a b =>
  Quotient.inductionOn‚ÇÇ' a b fun a b (h : œÜ a = œÜ b) =>
    Quotient.sound' <| by rw [leftRel_apply, mem_ker, œÜ.map_mul, ‚Üê h, œÜ.map_inv, inv_mul_self]
                          -- üéâ no goals
#align quotient_group.ker_lift_injective QuotientGroup.kerLift_injective
#align quotient_add_group.ker_lift_injective QuotientAddGroup.kerLift_injective

-- Note that `ker œÜ` isn't definitionally `ker (œÜ.rangeRestrict)`
-- so there is a bit of annoying code duplication here
/-- The induced map from the quotient by the kernel to the range. -/
@[to_additive "The induced map from the quotient by the kernel to the range."]
def rangeKerLift : G ‚ß∏ ker œÜ ‚Üí* œÜ.range :=
  lift _ œÜ.rangeRestrict fun g hg => (mem_ker _).mp <| by rwa [ker_rangeRestrict]
                                                          -- üéâ no goals
#align quotient_group.range_ker_lift QuotientGroup.rangeKerLift
#align quotient_add_group.range_ker_lift QuotientAddGroup.rangeKerLift

@[to_additive]
theorem rangeKerLift_injective : Injective (rangeKerLift œÜ) := fun a b =>
  Quotient.inductionOn‚ÇÇ' a b fun a b (h : œÜ.rangeRestrict a = œÜ.rangeRestrict b) =>
    Quotient.sound' <| by
      rw [leftRel_apply, ‚Üê ker_rangeRestrict, mem_ker, œÜ.rangeRestrict.map_mul, ‚Üê h,
        œÜ.rangeRestrict.map_inv, inv_mul_self]
#align quotient_group.range_ker_lift_injective QuotientGroup.rangeKerLift_injective
#align quotient_add_group.range_ker_lift_injective QuotientAddGroup.rangeKerLift_injective

@[to_additive]
theorem rangeKerLift_surjective : Surjective (rangeKerLift œÜ) := by
  rintro ‚ü®_, g, rfl‚ü©
  -- ‚ä¢ ‚àÉ a, ‚Üë(rangeKerLift œÜ) a = { val := ‚ÜëœÜ g, property := (_ : ‚àÉ y, ‚ÜëœÜ y = ‚ÜëœÜ g) }
  use mk g
  -- ‚ä¢ ‚Üë(rangeKerLift œÜ) ‚Üëg = { val := ‚ÜëœÜ g, property := (_ : ‚àÉ y, ‚ÜëœÜ y = ‚ÜëœÜ g) }
  rfl
  -- üéâ no goals
#align quotient_group.range_ker_lift_surjective QuotientGroup.rangeKerLift_surjective
#align quotient_add_group.range_ker_lift_surjective QuotientAddGroup.rangeKerLift_surjective

/-- **Noether's first isomorphism theorem** (a definition): the canonical isomorphism between
`G/(ker œÜ)` to `range œÜ`. -/
@[to_additive "The first isomorphism theorem (a definition): the canonical isomorphism between
`G/(ker œÜ)` to `range œÜ`."]
noncomputable def quotientKerEquivRange : G ‚ß∏ ker œÜ ‚âÉ* range œÜ :=
  MulEquiv.ofBijective (rangeKerLift œÜ) ‚ü®rangeKerLift_injective œÜ, rangeKerLift_surjective œÜ‚ü©
#align quotient_group.quotient_ker_equiv_range QuotientGroup.quotientKerEquivRange
#align quotient_add_group.quotient_ker_equiv_range QuotientAddGroup.quotientKerEquivRange

/-- The canonical isomorphism `G/(ker œÜ) ‚âÉ* H` induced by a homomorphism `œÜ : G ‚Üí* H`
with a right inverse `œà : H ‚Üí G`. -/
@[to_additive (attr := simps) "The canonical isomorphism `G/(ker œÜ) ‚âÉ+ H` induced by a homomorphism
`œÜ : G ‚Üí+ H` with a right inverse `œà : H ‚Üí G`."]
def quotientKerEquivOfRightInverse (œà : H ‚Üí G) (hœÜ : RightInverse œà œÜ) : G ‚ß∏ ker œÜ ‚âÉ* H :=
  { kerLift œÜ with
    toFun := kerLift œÜ
    invFun := mk ‚àò œà
    left_inv := fun x => kerLift_injective œÜ (by rw [Function.comp_apply, kerLift_mk', hœÜ])
                                                 -- üéâ no goals
    right_inv := hœÜ }
#align quotient_group.quotient_ker_equiv_of_right_inverse QuotientGroup.quotientKerEquivOfRightInverse
#align quotient_add_group.quotient_ker_equiv_of_right_inverse QuotientAddGroup.quotientKerEquivOfRightInverse

/-- The canonical isomorphism `G/‚ä• ‚âÉ* G`. -/
@[to_additive (attr := simps!) "The canonical isomorphism `G/‚ä• ‚âÉ+ G`."]
def quotientBot : G ‚ß∏ (‚ä• : Subgroup G) ‚âÉ* G :=
  quotientKerEquivOfRightInverse (MonoidHom.id G) id fun _x => rfl
#align quotient_group.quotient_bot QuotientGroup.quotientBot
#align quotient_add_group.quotient_bot QuotientAddGroup.quotientBot

/-- The canonical isomorphism `G/(ker œÜ) ‚âÉ* H` induced by a surjection `œÜ : G ‚Üí* H`.

For a `computable` version, see `QuotientGroup.quotientKerEquivOfRightInverse`.
-/
@[to_additive "The canonical isomorphism `G/(ker œÜ) ‚âÉ+ H` induced by a surjection `œÜ : G ‚Üí+ H`.
For a `computable` version, see `QuotientAddGroup.quotientKerEquivOfRightInverse`."]
noncomputable def quotientKerEquivOfSurjective (hœÜ : Surjective œÜ) : G ‚ß∏ ker œÜ ‚âÉ* H :=
  quotientKerEquivOfRightInverse œÜ _ hœÜ.hasRightInverse.choose_spec
#align quotient_group.quotient_ker_equiv_of_surjective QuotientGroup.quotientKerEquivOfSurjective
#align quotient_add_group.quotient_ker_equiv_of_surjective QuotientAddGroup.quotientKerEquivOfSurjective

/-- If two normal subgroups `M` and `N` of `G` are the same, their quotient groups are
isomorphic. -/
@[to_additive "If two normal subgroups `M` and `N` of `G` are the same, their quotient groups are
isomorphic."]
def quotientMulEquivOfEq {M N : Subgroup G} [M.Normal] [N.Normal] (h : M = N) : G ‚ß∏ M ‚âÉ* G ‚ß∏ N :=
  { Subgroup.quotientEquivOfEq h with
    map_mul' := fun q r => Quotient.inductionOn‚ÇÇ' q r fun _g _h => rfl }
#align quotient_group.quotient_mul_equiv_of_eq QuotientGroup.quotientMulEquivOfEq
#align quotient_add_group.quotient_add_equiv_of_eq QuotientAddGroup.quotientAddEquivOfEq

@[to_additive (attr := simp)]
theorem quotientMulEquivOfEq_mk {M N : Subgroup G} [M.Normal] [N.Normal] (h : M = N) (x : G) :
    QuotientGroup.quotientMulEquivOfEq h (QuotientGroup.mk x) = QuotientGroup.mk x :=
  rfl
#align quotient_group.quotient_mul_equiv_of_eq_mk QuotientGroup.quotientMulEquivOfEq_mk
#align quotient_add_group.quotient_add_equiv_of_eq_mk QuotientAddGroup.quotientAddEquivOfEq_mk

/-- Let `A', A, B', B` be subgroups of `G`. If `A' ‚â§ B'` and `A ‚â§ B`,
then there is a map `A / (A' ‚äì A) ‚Üí* B / (B' ‚äì B)` induced by the inclusions. -/
@[to_additive "Let `A', A, B', B` be subgroups of `G`. If `A' ‚â§ B'` and `A ‚â§ B`, then there is a map
`A / (A' ‚äì A) ‚Üí+ B / (B' ‚äì B)` induced by the inclusions."]
def quotientMapSubgroupOfOfLe {A' A B' B : Subgroup G} [_hAN : (A'.subgroupOf A).Normal]
    [_hBN : (B'.subgroupOf B).Normal] (h' : A' ‚â§ B') (h : A ‚â§ B) :
    A ‚ß∏ A'.subgroupOf A ‚Üí* B ‚ß∏ B'.subgroupOf B :=
  map _ _ (Subgroup.inclusion h) <| Subgroup.comap_mono h'
#align quotient_group.quotient_map_subgroup_of_of_le QuotientGroup.quotientMapSubgroupOfOfLe
#align quotient_add_group.quotient_map_add_subgroup_of_of_le QuotientAddGroup.quotientMapAddSubgroupOfOfLe

@[to_additive (attr := simp)]
theorem quotientMapSubgroupOfOfLe_mk {A' A B' B : Subgroup G} [_hAN : (A'.subgroupOf A).Normal]
    [_hBN : (B'.subgroupOf B).Normal] (h' : A' ‚â§ B') (h : A ‚â§ B) (x : A) :
    quotientMapSubgroupOfOfLe h' h x = ‚Üë(Subgroup.inclusion h x : B) :=
  rfl
#align quotient_group.quotient_map_subgroup_of_of_le_coe QuotientGroup.quotientMapSubgroupOfOfLe_mk
#align quotient_add_group.quotient_map_add_subgroup_of_of_le_coe QuotientAddGroup.quotientMapAddSubgroupOfOfLe_mk

/-- Let `A', A, B', B` be subgroups of `G`.
If `A' = B'` and `A = B`, then the quotients `A / (A' ‚äì A)` and `B / (B' ‚äì B)` are isomorphic.

Applying this equiv is nicer than rewriting along the equalities, since the type of
`(A'.subgroupOf A : Subgroup A)` depends on `A`.
-/
@[to_additive "Let `A', A, B', B` be subgroups of `G`. If `A' = B'` and `A = B`, then the quotients
`A / (A' ‚äì A)` and `B / (B' ‚äì B)` are isomorphic. Applying this equiv is nicer than rewriting along
the equalities, since the type of `(A'.addSubgroupOf A : AddSubgroup A)` depends on on `A`. "]
def equivQuotientSubgroupOfOfEq {A' A B' B : Subgroup G} [hAN : (A'.subgroupOf A).Normal]
    [hBN : (B'.subgroupOf B).Normal] (h' : A' = B') (h : A = B) :
    A ‚ß∏ A'.subgroupOf A ‚âÉ* B ‚ß∏ B'.subgroupOf B :=
  MonoidHom.toMulEquiv (quotientMapSubgroupOfOfLe h'.le h.le) (quotientMapSubgroupOfOfLe h'.ge h.ge)
    (by ext ‚ü®x, hx‚ü©; rfl)
        -- ‚ä¢ ‚Üë(MonoidHom.comp (MonoidHom.comp (quotientMapSubgroupOfOfLe (_ : B' ‚â§ A') (_ ‚Ä¶
                     -- üéâ no goals
    (by ext ‚ü®x, hx‚ü©; rfl)
        -- ‚ä¢ ‚Üë(MonoidHom.comp (MonoidHom.comp (quotientMapSubgroupOfOfLe (_ : A' ‚â§ B') (_ ‚Ä¶
                     -- üéâ no goals
#align quotient_group.equiv_quotient_subgroup_of_of_eq QuotientGroup.equivQuotientSubgroupOfOfEq
#align quotient_add_group.equiv_quotient_add_subgroup_of_of_eq QuotientAddGroup.equivQuotientAddSubgroupOfOfEq

section ZPow

variable {A B C : Type u} [CommGroup A] [CommGroup B] [CommGroup C]

variable (f : A ‚Üí* B) (g : B ‚Üí* A) (e : A ‚âÉ* B) (d : B ‚âÉ* C) (n : ‚Ñ§)

/-- The map of quotients by powers of an integer induced by a group homomorphism. -/
@[to_additive "The map of quotients by multiples of an integer induced by an additive group
homomorphism."]
def homQuotientZPowOfHom :
    A ‚ß∏ (zpowGroupHom n : A ‚Üí* A).range ‚Üí* B ‚ß∏ (zpowGroupHom n : B ‚Üí* B).range :=
  lift _ ((mk' _).comp f) fun g ‚ü®h, (hg : h ^ n = g)‚ü© =>
    (eq_one_iff _).mpr ‚ü®f h, by
      simp only [‚Üê hg, map_zpow, zpowGroupHom_apply]‚ü©
      -- üéâ no goals
#align quotient_group.hom_quotient_zpow_of_hom QuotientGroup.homQuotientZPowOfHom
#align quotient_add_group.hom_quotient_zsmul_of_hom QuotientAddGroup.homQuotientZSMulOfHom

@[to_additive (attr := simp)]
theorem homQuotientZPowOfHom_id : homQuotientZPowOfHom (MonoidHom.id A) n = MonoidHom.id _ :=
  monoidHom_ext _ rfl
#align quotient_group.hom_quotient_zpow_of_hom_id QuotientGroup.homQuotientZPowOfHom_id
#align quotient_add_group.hom_quotient_zsmul_of_hom_id QuotientAddGroup.homQuotientZSMulOfHom_id

@[to_additive (attr := simp)]
theorem homQuotientZPowOfHom_comp :
    homQuotientZPowOfHom (f.comp g) n =
      (homQuotientZPowOfHom f n).comp (homQuotientZPowOfHom g n) :=
  monoidHom_ext _ rfl
#align quotient_group.hom_quotient_zpow_of_hom_comp QuotientGroup.homQuotientZPowOfHom_comp
#align quotient_add_group.hom_quotient_zsmul_of_hom_comp QuotientAddGroup.homQuotientZSMulOfHom_comp

@[to_additive (attr := simp)]
theorem homQuotientZPowOfHom_comp_of_rightInverse (i : Function.RightInverse g f) :
    (homQuotientZPowOfHom f n).comp (homQuotientZPowOfHom g n) = MonoidHom.id _ :=
  monoidHom_ext _ <| MonoidHom.ext fun x => congrArg _ <| i x
#align quotient_group.hom_quotient_zpow_of_hom_comp_of_right_inverse QuotientGroup.homQuotientZPowOfHom_comp_of_rightInverse
#align quotient_add_group.hom_quotient_zsmul_of_hom_comp_of_right_inverse QuotientAddGroup.homQuotientZSMulOfHom_comp_of_rightInverse

/-- The equivalence of quotients by powers of an integer induced by a group isomorphism. -/
@[to_additive "The equivalence of quotients by multiples of an integer induced by an additive group
isomorphism."]
def equivQuotientZPowOfEquiv :
    A ‚ß∏ (zpowGroupHom n : A ‚Üí* A).range ‚âÉ* B ‚ß∏ (zpowGroupHom n : B ‚Üí* B).range :=
  MonoidHom.toMulEquiv _ _
    (homQuotientZPowOfHom_comp_of_rightInverse (e.symm : B ‚Üí* A) (e : A ‚Üí* B) n e.left_inv)
    (homQuotientZPowOfHom_comp_of_rightInverse (e : A ‚Üí* B) (e.symm : B ‚Üí* A) n e.right_inv)
    -- porting note: had to explicitly coerce the `MulEquiv`s to `MonoidHom`s
#align quotient_group.equiv_quotient_zpow_of_equiv QuotientGroup.equivQuotientZPowOfEquiv
#align quotient_add_group.equiv_quotient_zsmul_of_equiv QuotientAddGroup.equivQuotientZSMulOfEquiv

@[to_additive (attr := simp)]
theorem equivQuotientZPowOfEquiv_refl :
    MulEquiv.refl (A ‚ß∏ (zpowGroupHom n : A ‚Üí* A).range) =
      equivQuotientZPowOfEquiv (MulEquiv.refl A) n := by
  ext x
  -- ‚ä¢ ‚Üë(MulEquiv.refl (A ‚ß∏ range (zpowGroupHom n))) x = ‚Üë(equivQuotientZPowOfEquiv ‚Ä¶
  rw [‚Üê Quotient.out_eq' x]
  -- ‚ä¢ ‚Üë(MulEquiv.refl (A ‚ß∏ range (zpowGroupHom n))) (Quotient.mk'' (Quotient.out'  ‚Ä¶
  rfl
  -- üéâ no goals
#align quotient_group.equiv_quotient_zpow_of_equiv_refl QuotientGroup.equivQuotientZPowOfEquiv_refl
#align quotient_add_group.equiv_quotient_zsmul_of_equiv_refl QuotientAddGroup.equivQuotientZSMulOfEquiv_refl

@[to_additive (attr := simp)]
theorem equivQuotientZPowOfEquiv_symm :
    (equivQuotientZPowOfEquiv e n).symm = equivQuotientZPowOfEquiv e.symm n :=
  rfl
#align quotient_group.equiv_quotient_zpow_of_equiv_symm QuotientGroup.equivQuotientZPowOfEquiv_symm
#align quotient_add_group.equiv_quotient_zsmul_of_equiv_symm QuotientAddGroup.equivQuotientZSMulOfEquiv_symm

@[to_additive (attr := simp)]
theorem equivQuotientZPowOfEquiv_trans :
    (equivQuotientZPowOfEquiv e n).trans (equivQuotientZPowOfEquiv d n) =
      equivQuotientZPowOfEquiv (e.trans d) n := by
  ext x
  -- ‚ä¢ ‚Üë(MulEquiv.trans (equivQuotientZPowOfEquiv e n) (equivQuotientZPowOfEquiv d  ‚Ä¶
  rw [‚Üê Quotient.out_eq' x]
  -- ‚ä¢ ‚Üë(MulEquiv.trans (equivQuotientZPowOfEquiv e n) (equivQuotientZPowOfEquiv d  ‚Ä¶
  rfl
  -- üéâ no goals
#align quotient_group.equiv_quotient_zpow_of_equiv_trans QuotientGroup.equivQuotientZPowOfEquiv_trans
#align quotient_add_group.equiv_quotient_zsmul_of_equiv_trans QuotientAddGroup.equivQuotientZSMulOfEquiv_trans

end ZPow

section SndIsomorphismThm

open Subgroup

/-- **Noether's second isomorphism theorem**: given two subgroups `H` and `N` of a group `G`, where
`N` is normal, defines an isomorphism between `H/(H ‚à© N)` and `(HN)/N`. -/
@[to_additive "The second isomorphism theorem: given two subgroups `H` and `N` of a group `G`, where
`N` is normal, defines an isomorphism between `H/(H ‚à© N)` and `(H + N)/N`"]
noncomputable def quotientInfEquivProdNormalQuotient (H N : Subgroup G) [N.Normal] :
    H ‚ß∏ N.subgroupOf H ‚âÉ* _ ‚ß∏ N.subgroupOf (H ‚äî N) :=
  let
    œÜ :-- œÜ is the natural homomorphism H ‚Üí* (HN)/N.
      H ‚Üí*
      _ ‚ß∏ N.subgroupOf (H ‚äî N) :=
    (mk' <| N.subgroupOf (H ‚äî N)).comp (inclusion le_sup_left)
  have œÜ_surjective : Surjective œÜ := fun x =>
    x.inductionOn' <| by
      rintro ‚ü®y, hy : y ‚àà (H ‚äî N)‚ü©;
      -- ‚ä¢ ‚àÉ a, ‚ÜëœÜ a = Quotient.mk'' { val := y, property := hy }
      rw [‚ÜêSetLike.mem_coe] at hy
      -- ‚ä¢ ‚àÉ a, ‚ÜëœÜ a = Quotient.mk'' { val := y, property := hy‚úù }
      rw [mul_normal H N] at hy
      -- ‚ä¢ ‚àÉ a, ‚ÜëœÜ a = Quotient.mk'' { val := y, property := hy‚úù }
      rcases hy with ‚ü®h, n, hh, hn, rfl‚ü©
      -- ‚ä¢ ‚àÉ a, ‚ÜëœÜ a = Quotient.mk'' { val := (fun x x_1 => x * x_1) h n, property := h ‚Ä¶
      use ‚ü®h, hh‚ü©
      -- ‚ä¢ ‚ÜëœÜ { val := h, property := hh } = Quotient.mk'' { val := (fun x x_1 => x * x ‚Ä¶
      let _ : Setoid ‚Üë(H ‚äî N) :=
        (@leftRel ‚Üë(H ‚äî N) (H ‚äî N : Subgroup G).toGroup (N.subgroupOf (H ‚äî N)))
      -- porting note: Lean couldn't find this automatically
      refine Quotient.eq.mpr ?_
      -- ‚ä¢ ‚Üë(inclusion (_ : H ‚â§ H ‚äî N)) { val := h, property := hh } ‚âà { val := (fun x  ‚Ä¶
      change Setoid.r _ _
      -- ‚ä¢ Setoid.r (‚Üë(inclusion (_ : H ‚â§ H ‚äî N)) { val := h, property := hh }) { val : ‚Ä¶
      rw [leftRel_apply]
      -- ‚ä¢ (‚Üë(inclusion (_ : H ‚â§ H ‚äî N)) { val := h, property := hh })‚Åª¬π * { val := (fu ‚Ä¶
      change h‚Åª¬π * (h * n) ‚àà N
      -- ‚ä¢ h‚Åª¬π * (h * n) ‚àà N
      rwa [‚Üê mul_assoc, inv_mul_self, one_mul]
      -- üéâ no goals
  (quotientMulEquivOfEq (by simp [‚Üê comap_ker])).trans (quotientKerEquivOfSurjective œÜ œÜ_surjective)
                            -- üéâ no goals
#align quotient_group.quotient_inf_equiv_prod_normal_quotient QuotientGroup.quotientInfEquivProdNormalQuotient
#align quotient_add_group.quotient_inf_equiv_sum_normal_quotient QuotientAddGroup.quotientInfEquivSumNormalQuotient

end SndIsomorphismThm

section ThirdIsoThm

variable (M : Subgroup G) [nM : M.Normal]

@[to_additive]
instance map_normal : (M.map (QuotientGroup.mk' N)).Normal :=
  nM.map _ mk_surjective
#align quotient_group.map_normal QuotientGroup.map_normal
#align quotient_add_group.map_normal QuotientAddGroup.map_normal

variable (h : N ‚â§ M)

/-- The map from the third isomorphism theorem for groups: `(G / N) / (M / N) ‚Üí G / M`. -/
@[to_additive "The map from the third isomorphism theorem for additive groups:
`(A / N) / (M / N) ‚Üí A / M`."]
def quotientQuotientEquivQuotientAux : (G ‚ß∏ N) ‚ß∏ M.map (mk' N) ‚Üí* G ‚ß∏ M :=
  lift (M.map (mk' N)) (map N M (MonoidHom.id G) h)
    (by
      rintro _ ‚ü®x, hx, rfl‚ü©
      -- ‚ä¢ ‚Üë(map N M (MonoidHom.id G) h) (‚Üë(mk' N) x) = 1
      rw [map_mk' N M _ _ x]
      -- ‚ä¢ ‚Üë(‚Üë(MonoidHom.id G) x) = 1
      exact (QuotientGroup.eq_one_iff _).mpr hx)
      -- üéâ no goals
#align quotient_group.quotient_quotient_equiv_quotient_aux QuotientGroup.quotientQuotientEquivQuotientAux
#align quotient_add_group.quotient_quotient_equiv_quotient_aux QuotientAddGroup.quotientQuotientEquivQuotientAux

@[to_additive (attr := simp)]
theorem quotientQuotientEquivQuotientAux_mk (x : G ‚ß∏ N) :
    quotientQuotientEquivQuotientAux N M h x = QuotientGroup.map N M (MonoidHom.id G) h x :=
  QuotientGroup.lift_mk' _ _ x
#align quotient_group.quotient_quotient_equiv_quotient_aux_coe QuotientGroup.quotientQuotientEquivQuotientAux_mk
#align quotient_add_group.quotient_quotient_equiv_quotient_aux_coe QuotientAddGroup.quotientQuotientEquivQuotientAux_mk

@[to_additive]
theorem quotientQuotientEquivQuotientAux_mk_mk (x : G) :
    quotientQuotientEquivQuotientAux N M h (x : G ‚ß∏ N) = x :=
  QuotientGroup.lift_mk' (M.map (mk' N)) _ x
#align quotient_group.quotient_quotient_equiv_quotient_aux_coe_coe QuotientGroup.quotientQuotientEquivQuotientAux_mk_mk
#align quotient_add_group.quotient_quotient_equiv_quotient_aux_coe_coe QuotientAddGroup.quotientQuotientEquivQuotientAux_mk_mk

/-- **Noether's third isomorphism theorem** for groups: `(G / N) / (M / N) ‚âÉ* G / M`. -/
@[to_additive
      "**Noether's third isomorphism theorem** for additive groups: `(A / N) / (M / N) ‚âÉ+ A / M`."]
def quotientQuotientEquivQuotient : (G ‚ß∏ N) ‚ß∏ M.map (QuotientGroup.mk' N) ‚âÉ* G ‚ß∏ M :=
  MonoidHom.toMulEquiv (quotientQuotientEquivQuotientAux N M h)
    (QuotientGroup.map _ _ (QuotientGroup.mk' N) (Subgroup.le_comap_map _ _))
    (by ext; simp)
        -- ‚ä¢ ‚Üë(MonoidHom.comp (MonoidHom.comp (MonoidHom.comp (map M (Subgroup.map (mk' N ‚Ä¶
             -- üéâ no goals
    (by ext; simp)
        -- ‚ä¢ ‚Üë(MonoidHom.comp (MonoidHom.comp (quotientQuotientEquivQuotientAux N M h) (m ‚Ä¶
             -- üéâ no goals
#align quotient_group.quotient_quotient_equiv_quotient QuotientGroup.quotientQuotientEquivQuotient
#align quotient_add_group.quotient_quotient_equiv_quotient QuotientAddGroup.quotientQuotientEquivQuotient

end ThirdIsoThm

section trivial

@[to_additive]
theorem subsingleton_quotient_top : Subsingleton (G ‚ß∏ (‚ä§ : Subgroup G)) := by
  dsimp [HasQuotient.Quotient, QuotientGroup.instHasQuotientSubgroup, Quotient]
  -- ‚ä¢ Subsingleton (Quot Setoid.r)
  rw [leftRel_eq]
  -- ‚ä¢ Subsingleton (Quot fun x y => x‚Åª¬π * y ‚àà ‚ä§)
  exact Trunc.instSubsingletonTrunc
  -- üéâ no goals
#align quotient_group.subsingleton_quotient_top QuotientGroup.subsingleton_quotient_top
#align quotient_add_group.subsingleton_quotient_top QuotientAddGroup.subsingleton_quotient_top

/-- If the quotient by a subgroup gives a singleton then the subgroup is the whole group. -/
@[to_additive "If the quotient by an additive subgroup gives a singleton then the additive subgroup
is the whole additive group."]
theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    -- ‚ä¢ x ‚àà H
    rwa [inv_one, one_mul] at this
    -- üéâ no goals
#align quotient_group.subgroup_eq_top_of_subsingleton QuotientGroup.subgroup_eq_top_of_subsingleton
#align quotient_add_group.add_subgroup_eq_top_of_subsingleton QuotientAddGroup.addSubgroup_eq_top_of_subsingleton

end trivial

@[to_additive]
theorem comap_comap_center {H‚ÇÅ : Subgroup G} [H‚ÇÅ.Normal] {H‚ÇÇ : Subgroup (G ‚ß∏ H‚ÇÅ)} [H‚ÇÇ.Normal] :
    ((Subgroup.center ((G ‚ß∏ H‚ÇÅ) ‚ß∏ H‚ÇÇ)).comap (mk' H‚ÇÇ)).comap (mk' H‚ÇÅ) =
      (Subgroup.center (G ‚ß∏ H‚ÇÇ.comap (mk' H‚ÇÅ))).comap (mk' (H‚ÇÇ.comap (mk' H‚ÇÅ))) := by
  ext x
  -- ‚ä¢ x ‚àà Subgroup.comap (mk' H‚ÇÅ) (Subgroup.comap (mk' H‚ÇÇ) (Subgroup.center ((G ‚ß∏  ‚Ä¶
  simp only [mk'_apply, Subgroup.mem_comap, Subgroup.mem_center_iff, forall_mk, ‚Üê mk_mul,
    eq_iff_div_mem, mk_div]
#align quotient_group.comap_comap_center QuotientGroup.comap_comap_center
#align quotient_add_group.comap_comap_center QuotientAddGroup.comap_comap_center

end QuotientGroup

namespace Group

open Classical

open QuotientGroup Subgroup

variable {F G H : Type u} [Group F] [Group G] [Group H] [Fintype F] [Fintype H]

variable (f : F ‚Üí* G) (g : G ‚Üí* H)

/-- If `F` and `H` are finite such that `ker(G ‚Üí* H) ‚â§ im(F ‚Üí* G)`, then `G` is finite. -/
@[to_additive "If `F` and `H` are finite such that `ker(G ‚Üí+ H) ‚â§ im(F ‚Üí+ G)`, then `G` is finite."]
noncomputable def fintypeOfKerLeRange (h : g.ker ‚â§ f.range) : Fintype G :=
  @Fintype.ofEquiv _ _
    (@instFintypeProd _ _ (Fintype.ofInjective _ <| kerLift_injective g) <|
      Fintype.ofInjective _ <| inclusion_injective h)
    groupEquivQuotientProdSubgroup.symm
#align group.fintype_of_ker_le_range Group.fintypeOfKerLeRange
#align add_group.fintype_of_ker_le_range AddGroup.fintypeOfKerLeRange

/-- If `F` and `H` are finite such that `ker(G ‚Üí* H) = im(F ‚Üí* G)`, then `G` is finite. -/
@[to_additive "If `F` and `H` are finite such that `ker(G ‚Üí+ H) = im(F ‚Üí+ G)`, then `G` is finite."]
noncomputable def fintypeOfKerEqRange (h : g.ker = f.range) : Fintype G :=
  fintypeOfKerLeRange _ _ h.le
#align group.fintype_of_ker_eq_range Group.fintypeOfKerEqRange
#align add_group.fintype_of_ker_eq_range AddGroup.fintypeOfKerEqRange

/-- If `ker(G ‚Üí* H)` and `H` are finite, then `G` is finite. -/
@[to_additive "If `ker(G ‚Üí+ H)` and `H` are finite, then `G` is finite."]
noncomputable def fintypeOfKerOfCodom [Fintype g.ker] : Fintype G :=
  fintypeOfKerLeRange ((topEquiv : _ ‚âÉ* G).toMonoidHom.comp <| inclusion le_top) g fun x hx =>
    ‚ü®‚ü®x, hx‚ü©, rfl‚ü©
#align group.fintype_of_ker_of_codom Group.fintypeOfKerOfCodom
#align add_group.fintype_of_ker_of_codom AddGroup.fintypeOfKerOfCodom

/-- If `F` and `coker(F ‚Üí* G)` are finite, then `G` is finite. -/
@[to_additive "If `F` and `coker(F ‚Üí+ G)` are finite, then `G` is finite."]
noncomputable def fintypeOfDomOfCoker [Normal f.range] [Fintype <| G ‚ß∏ f.range] : Fintype G :=
  fintypeOfKerLeRange _ (mk' f.range) fun x => (eq_one_iff x).mp
#align group.fintype_of_dom_of_coker Group.fintypeOfDomOfCoker
#align add_group.fintype_of_dom_of_coker AddGroup.fintypeOfDomOfCoker

end Group
