/-
Copyright (c) 2025 Christian Krause. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Christian Krause
-/

import Mathlib.GroupTheory.FreeGroup.Reduce
import Mathlib.GroupTheory.GroupAction.Basic
/-!
This file introduces the orbit of a point under the action of a set `s`.
The orbit is defined as the set of all points `g • x` for `g ∈ s`.

For any `w : α × bool`, `FreeGroup.startsWith w` is the set of all elemenents of `FreeGroup α` that
start with `w`.

The main theorem `Orbit.duplicate` proves that applying `w⁻¹` to the Orbit of `x` under the action
of `FreeGroup.startsWith w` yields the orbit of `x` under the action of `FreeGroup.startsWith v`
for every `v ≠ w⁻¹` (and the point `x`).
-/

variable {α X: Type*} [DecidableEq α]

namespace FreeGroup


/--
All elements of the free Group that start with a certain letter.
-/
def startsWith (w : α × Bool) := {g : FreeGroup α | (FreeGroup.toWord g)[0]? = some w}


/--
The neutral element is not contained in one of the startsWith sets.
-/
theorem startsWith.ne_one {w : α × Bool} (g : FreeGroup α) (h : g ∈ FreeGroup.startsWith w) :
    g ≠ 1 := fun h1 ↦ by simp [h1, startsWith, FreeGroup.toWord_one] at h

theorem not_startsWith_of_ne {w w' : α × Bool} (hw : w ≠ w')
    (g : FreeGroup α) (h : g ∈ FreeGroup.startsWith w) : ¬ g ∈ FreeGroup.startsWith w' := by
  grind [startsWith]

theorem startsWith_mk_mul {w : α × Bool} (g : FreeGroup α)
    (h : ¬ g ∈ FreeGroup.startsWith (w.1, !w.2)) : mk [w] * g ∈ FreeGroup.startsWith w := by
  by_cases hC : 0 < g.toWord.length
  · simp only [startsWith, Set.mem_setOf_eq, getElem?_pos, Option.some.injEq,
    Prod.eq_iff_fst_eq_snd_eq, not_and, Bool.not_eq_not, toWord_mul, toWord_mk, reduce.cons,
    reduce_nil, List.cons_append, List.nil_append, reduce_toWord, hC] at *
    rw [show g.toWord = g.toWord.head (by grind) :: g.toWord.tail by grind]
    grind
  · simp_all [startsWith]

variable [MulAction (FreeGroup α) X]

def orbit_of_set (s : Set (FreeGroup α)) (x : X) : Set X := ⋃ g ∈ s, MulAction.orbit g x

/--
Applying `w⁻¹` to the orbit generated by all elements of a free group that start with `w` yields
the orbit generated by all the words that start with every letter execpt `w⁻¹`
(and the original point).
-/
theorem Orbit.duplicate (x : X) (w : α × Bool) :
    {(mk [w])⁻¹ • y | y ∈ (fun g ↦ MulAction.orbit g x) '' (startsWith w)} =
      (⋃ v ∈ {z : α × Bool | z ≠ (w.1, !w.2)}, MulAction.orbit (startsWith v) x) ∪ {x} := by
  ext i
  constructor
  · rintro ⟨-, ⟨g, hg, rfl⟩, rfl⟩
    set l := g.toWord with hl
    match l with
    | [] => simp [← hl, startsWith] at hg
    | [a] =>
      rw [← g.mk_toWord, ← hl, show a = w by simpa [← hl, startsWith] using hg, inv_smul_smul]
      exact Or.inr rfl
    | a :: b :: l =>
      have ha : a = w := by simpa [← hl, startsWith] using hg
      have h := isReduced_cons_cons.mp (hl ▸ isReduced_toWord)
      refine Or.inl (Set.mem_biUnion (x := b) (by grind) ?_)
      rw [← g.mk_toWord, ← hl, ha, ← List.singleton_append (l := b :: l), ← mul_mk,
        mul_smul, inv_smul_smul]
      refine ⟨mk (b :: l), ?_, rfl⟩
      simp [startsWith, h.2.reduce_eq]
  · rintro (⟨-, ⟨w', rfl⟩, -, ⟨hw, rfl⟩, g, hg, rfl⟩ | rfl)
    · exact ⟨mk [w] • g • x, ⟨mk [w] * g, startsWith_mk_mul g (not_startsWith_of_ne hw g hg),
        mul_smul (mk [w]) g x⟩, inv_smul_smul (mk [w]) (g • x)⟩
    · exact ⟨mk [w] • i, ⟨mk [w], rfl, rfl⟩, inv_smul_smul (mk [w]) i⟩

end FreeGroup
