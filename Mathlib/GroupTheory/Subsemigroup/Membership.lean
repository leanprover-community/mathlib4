/-
Copyright (c) 2022 Jireh Loreaux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jireh Loreaux
-/
import Mathlib.GroupTheory.Subsemigroup.Basic

#align_import group_theory.subsemigroup.membership from "leanprover-community/mathlib"@"6cb77a8eaff0ddd100e87b1591c6d3ad319514ff"

/-!
# Subsemigroups: membership criteria

In this file we prove various facts about membership in a subsemigroup.
The intent is to mimic `GroupTheory/Submonoid/Membership`, but currently this file is mostly a
stub and only provides rudimentary support.

* `mem_iSup_of_directed`, `coe_iSup_of_directed`, `mem_sSup_of_directed_on`,
  `coe_sSup_of_directed_on`: the supremum of a directed collection of subsemigroup is their union.

## TODO

* Define the `FreeSemigroup` generated by a set. This might require some rather substantial
  additions to low-level API. For example, developing the subtype of nonempty lists, then defining
  a product on nonempty lists, powers where the exponent is a positive natural, et cetera.
  Another option would be to define the `FreeSemigroup` as the subsemigroup (pushed to be a
  semigroup) of the `FreeMonoid` consisting of non-identity elements.

## Tags
subsemigroup
-/

variable {Î¹ : Sort*} {M A B : Type*}

section NonAssoc

variable [Mul M]

open Set

namespace Subsemigroup

-- TODO: this section can be generalized to `[MulMemClass B M] [CompleteLattice B]`
-- such that `complete_lattice.le` coincides with `set_like.le`
@[to_additive]
theorem mem_iSup_of_directed {S : Î¹ â†’ Subsemigroup M} (hS : Directed (Â· â‰¤ Â·) S) {x : M} :
    (x âˆˆ â¨† i, S i) â†” âˆƒ i, x âˆˆ S i := by
  refine' âŸ¨_, fun âŸ¨i, hiâŸ© => (SetLike.le_def.1 <| le_iSup S i) hiâŸ©
  -- âŠ¢ x âˆˆ â¨† (i : Î¹), S i â†’ âˆƒ i, x âˆˆ S i
  suffices x âˆˆ closure (â‹ƒ i, (S i : Set M)) â†’ âˆƒ i, x âˆˆ S i by
    simpa only [closure_iUnion, closure_eq (S _)] using this
  refine' fun hx => closure_induction hx (fun y hy => mem_iUnion.mp hy) _
  -- âŠ¢ âˆ€ (x y : M), (âˆƒ i, x âˆˆ S i) â†’ (âˆƒ i, y âˆˆ S i) â†’ âˆƒ i, x * y âˆˆ S i
  Â· rintro x y âŸ¨i, hiâŸ© âŸ¨j, hjâŸ©
    -- âŠ¢ âˆƒ i, x * y âˆˆ S i
    rcases hS i j with âŸ¨k, hki, hkjâŸ©
    -- âŠ¢ âˆƒ i, x * y âˆˆ S i
    exact âŸ¨k, (S k).mul_mem (hki hi) (hkj hj)âŸ©
    -- ğŸ‰ no goals
#align subsemigroup.mem_supr_of_directed Subsemigroup.mem_iSup_of_directed
#align add_subsemigroup.mem_supr_of_directed AddSubsemigroup.mem_iSup_of_directed

@[to_additive]
theorem coe_iSup_of_directed {S : Î¹ â†’ Subsemigroup M} (hS : Directed (Â· â‰¤ Â·) S) :
    ((â¨† i, S i : Subsemigroup M) : Set M) = â‹ƒ i, â†‘(S i) :=
  Set.ext fun x => by simp [mem_iSup_of_directed hS]
                      -- ğŸ‰ no goals
#align subsemigroup.coe_supr_of_directed Subsemigroup.coe_iSup_of_directed
#align add_subsemigroup.coe_supr_of_directed AddSubsemigroup.coe_iSup_of_directed

@[to_additive]
theorem mem_sSup_of_directed_on {S : Set (Subsemigroup M)} (hS : DirectedOn (Â· â‰¤ Â·) S) {x : M} :
    x âˆˆ sSup S â†” âˆƒ s âˆˆ S, x âˆˆ s := by
  simp only [sSup_eq_iSup', mem_iSup_of_directed hS.directed_val, SetCoe.exists, Subtype.coe_mk,
    exists_prop]
#align subsemigroup.mem_Sup_of_directed_on Subsemigroup.mem_sSup_of_directed_on
#align add_subsemigroup.mem_Sup_of_directed_on AddSubsemigroup.mem_sSup_of_directed_on

@[to_additive]
theorem coe_sSup_of_directed_on {S : Set (Subsemigroup M)} (hS : DirectedOn (Â· â‰¤ Â·) S) :
    (â†‘(sSup S) : Set M) = â‹ƒ s âˆˆ S, â†‘s :=
  Set.ext fun x => by simp [mem_sSup_of_directed_on hS]
                      -- ğŸ‰ no goals
#align subsemigroup.coe_Sup_of_directed_on Subsemigroup.coe_sSup_of_directed_on
#align add_subsemigroup.coe_Sup_of_directed_on AddSubsemigroup.coe_sSup_of_directed_on

@[to_additive]
theorem mem_sup_left {S T : Subsemigroup M} : âˆ€ {x : M}, x âˆˆ S â†’ x âˆˆ S âŠ” T := by
  have : S â‰¤ S âŠ” T := le_sup_left
  -- âŠ¢ âˆ€ {x : M}, x âˆˆ S â†’ x âˆˆ S âŠ” T
  tauto
  -- ğŸ‰ no goals
#align subsemigroup.mem_sup_left Subsemigroup.mem_sup_left
#align add_subsemigroup.mem_sup_left AddSubsemigroup.mem_sup_left

@[to_additive]
theorem mem_sup_right {S T : Subsemigroup M} : âˆ€ {x : M}, x âˆˆ T â†’ x âˆˆ S âŠ” T := by
  have : T â‰¤ S âŠ” T := le_sup_right
  -- âŠ¢ âˆ€ {x : M}, x âˆˆ T â†’ x âˆˆ S âŠ” T
  tauto
  -- ğŸ‰ no goals
#align subsemigroup.mem_sup_right Subsemigroup.mem_sup_right
#align add_subsemigroup.mem_sup_right AddSubsemigroup.mem_sup_right

@[to_additive]
theorem mul_mem_sup {S T : Subsemigroup M} {x y : M} (hx : x âˆˆ S) (hy : y âˆˆ T) : x * y âˆˆ S âŠ” T :=
  mul_mem (mem_sup_left hx) (mem_sup_right hy)
#align subsemigroup.mul_mem_sup Subsemigroup.mul_mem_sup
#align add_subsemigroup.add_mem_sup AddSubsemigroup.add_mem_sup

@[to_additive]
theorem mem_iSup_of_mem {S : Î¹ â†’ Subsemigroup M} (i : Î¹) : âˆ€ {x : M}, x âˆˆ S i â†’ x âˆˆ iSup S := by
  have : S i â‰¤ iSup S := le_iSup _ _
  -- âŠ¢ âˆ€ {x : M}, x âˆˆ S i â†’ x âˆˆ iSup S
  tauto
  -- ğŸ‰ no goals
#align subsemigroup.mem_supr_of_mem Subsemigroup.mem_iSup_of_mem
#align add_subsemigroup.mem_supr_of_mem AddSubsemigroup.mem_iSup_of_mem

@[to_additive]
theorem mem_sSup_of_mem {S : Set (Subsemigroup M)} {s : Subsemigroup M} (hs : s âˆˆ S) :
    âˆ€ {x : M}, x âˆˆ s â†’ x âˆˆ sSup S := by
  have : s â‰¤ sSup S := le_sSup hs
  -- âŠ¢ âˆ€ {x : M}, x âˆˆ s â†’ x âˆˆ sSup S
  tauto
  -- ğŸ‰ no goals
#align subsemigroup.mem_Sup_of_mem Subsemigroup.mem_sSup_of_mem
#align add_subsemigroup.mem_Sup_of_mem AddSubsemigroup.mem_sSup_of_mem

/-- An induction principle for elements of `â¨† i, S i`.
If `C` holds all elements of `S i` for all `i`, and is preserved under multiplication,
then it holds for all elements of the supremum of `S`. -/
@[to_additive (attr := elab_as_elim)
"An induction principle for elements of `â¨† i, S i`. If `C` holds all
elements of `S i` for all `i`, and is preserved under addition, then it holds for all elements of
the supremum of `S`."]
theorem iSup_induction (S : Î¹ â†’ Subsemigroup M) {C : M â†’ Prop} {xâ‚ : M} (hxâ‚ : xâ‚ âˆˆ â¨† i, S i)
    (hp : âˆ€ (i) (xâ‚‚ : M) (_hxS : xâ‚‚ âˆˆ S i), C xâ‚‚) (hmul : âˆ€ x y, C x â†’ C y â†’ C (x * y)) : C xâ‚ := by
  rw [iSup_eq_closure] at hxâ‚
  -- âŠ¢ C xâ‚
  refine' closure_induction hxâ‚ (fun xâ‚‚ hxâ‚‚ => _) hmul
  -- âŠ¢ C xâ‚‚
  obtain âŸ¨i, hiâŸ© := Set.mem_iUnion.mp hxâ‚‚
  -- âŠ¢ C xâ‚‚
  exact hp _ _ hi
  -- ğŸ‰ no goals
#align subsemigroup.supr_induction Subsemigroup.iSup_induction
#align add_subsemigroup.supr_induction AddSubsemigroup.iSup_induction

/-- A dependent version of `Subsemigroup.iSup_induction`. -/
@[to_additive (attr := elab_as_elim)
"A dependent version of `AddSubsemigroup.iSup_induction`."]
theorem iSup_induction' (S : Î¹ â†’ Subsemigroup M) {C : âˆ€ x, (x âˆˆ â¨† i, S i) â†’ Prop}
    (hp : âˆ€ (i) (x) (hxS : x âˆˆ S i), C x (mem_iSup_of_mem i â€¹_â€º))
    (hmul : âˆ€ x y hx hy, C x hx â†’ C y hy â†’ C (x * y) (mul_mem â€¹_â€º â€¹_â€º)) {xâ‚ : M}
    (hxâ‚ : xâ‚ âˆˆ â¨† i, S i) : C xâ‚ hxâ‚ := by
  refine Exists.elim ?_ fun (hxâ‚' : xâ‚ âˆˆ â¨† i, S i) (hc : C xâ‚ hxâ‚') => hc
  -- âŠ¢ âˆƒ x, C xâ‚ x
  refine @iSup_induction _ _ _ S (fun x' => âˆƒ hx'', C x' hx'') _ hxâ‚
      (fun i xâ‚‚ hxâ‚‚ => ?_) fun xâ‚ƒ y => ?_
  Â· exact âŸ¨_, hp _ _ hxâ‚‚âŸ©
    -- ğŸ‰ no goals
  Â· rintro âŸ¨_, CxâŸ© âŸ¨_, CyâŸ©
    -- âŠ¢ âˆƒ hx'', C (xâ‚ƒ * y) hx''
    exact âŸ¨_, hmul _ _ _ _ Cx CyâŸ©
    -- ğŸ‰ no goals
#align subsemigroup.supr_induction' Subsemigroup.iSup_induction'
#align add_subsemigroup.supr_induction' AddSubsemigroup.iSup_induction'

end Subsemigroup

end NonAssoc
