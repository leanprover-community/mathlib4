/-
Copyright (c) 2021 Jordan Brown, Thomas Browning, Patrick Lutz. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jordan Brown, Thomas Browning, Patrick Lutz
-/
import Mathlib.Algebra.Group.Commutator
import Mathlib.Data.Bracket
import Mathlib.GroupTheory.Subgroup.Finite
import Mathlib.Tactic.Group

#align_import group_theory.commutator from "leanprover-community/mathlib"@"4be589053caf347b899a494da75410deb55fb3ef"

/-!
# Commutators of Subgroups

If `G` is a group and `Hâ‚ Hâ‚‚ : Subgroup G` then the commutator `â…Hâ‚, Hâ‚‚â† : Subgroup G`
is the subgroup of `G` generated by the commutators `hâ‚ * hâ‚‚ * hâ‚â»Â¹ * hâ‚‚â»Â¹`.

## Main definitions

* `â…gâ‚, gâ‚‚â†` : the commutator of the elements `gâ‚` and `gâ‚‚`
    (defined by `commutatorElement` elsewhere).
* `â…Hâ‚, Hâ‚‚â†` : the commutator of the subgroups `Hâ‚` and `Hâ‚‚`.
-/


variable {G G' F : Type*} [Group G] [Group G'] [MonoidHomClass F G G'] (f : F) {gâ‚ gâ‚‚ gâ‚ƒ g : G}

theorem commutatorElement_eq_one_iff_mul_comm : â…gâ‚, gâ‚‚â† = 1 â†” gâ‚ * gâ‚‚ = gâ‚‚ * gâ‚ := by
  rw [commutatorElement_def, mul_inv_eq_one, mul_inv_eq_iff_eq_mul]
  -- ğŸ‰ no goals
#align commutator_element_eq_one_iff_mul_comm commutatorElement_eq_one_iff_mul_comm

theorem commutatorElement_eq_one_iff_commute : â…gâ‚, gâ‚‚â† = 1 â†” Commute gâ‚ gâ‚‚ :=
  commutatorElement_eq_one_iff_mul_comm
#align commutator_element_eq_one_iff_commute commutatorElement_eq_one_iff_commute

theorem Commute.commutator_eq (h : Commute gâ‚ gâ‚‚) : â…gâ‚, gâ‚‚â† = 1 :=
  commutatorElement_eq_one_iff_commute.mpr h
#align commute.commutator_eq Commute.commutator_eq

variable (gâ‚ gâ‚‚ gâ‚ƒ g)

@[simp]
theorem commutatorElement_one_right : â…g, (1 : G)â† = 1 :=
  (Commute.one_right g).commutator_eq
#align commutator_element_one_right commutatorElement_one_right

@[simp]
theorem commutatorElement_one_left : â…(1 : G), gâ† = 1 :=
  (Commute.one_left g).commutator_eq
#align commutator_element_one_left commutatorElement_one_left

@[simp]
theorem commutatorElement_self : â…g, gâ† = 1 :=
  (Commute.refl g).commutator_eq
#align commutator_element_self commutatorElement_self

@[simp]
theorem commutatorElement_inv : â…gâ‚, gâ‚‚â†â»Â¹ = â…gâ‚‚, gâ‚â† := by
  simp_rw [commutatorElement_def, mul_inv_rev, inv_inv, mul_assoc]
  -- ğŸ‰ no goals
#align commutator_element_inv commutatorElement_inv

theorem map_commutatorElement : (f â…gâ‚, gâ‚‚â† : G') = â…f gâ‚, f gâ‚‚â† := by
  simp_rw [commutatorElement_def, map_mul f, map_inv f]
  -- ğŸ‰ no goals
#align map_commutator_element map_commutatorElement

theorem conjugate_commutatorElement : gâ‚ƒ * â…gâ‚, gâ‚‚â† * gâ‚ƒâ»Â¹ = â…gâ‚ƒ * gâ‚ * gâ‚ƒâ»Â¹, gâ‚ƒ * gâ‚‚ * gâ‚ƒâ»Â¹â† :=
  map_commutatorElement (MulAut.conj gâ‚ƒ).toMonoidHom gâ‚ gâ‚‚
#align conjugate_commutator_element conjugate_commutatorElement

namespace Subgroup

/-- The commutator of two subgroups `Hâ‚` and `Hâ‚‚`. -/
instance commutator : Bracket (Subgroup G) (Subgroup G) :=
  âŸ¨fun Hâ‚ Hâ‚‚ => closure { g | âˆƒ gâ‚ âˆˆ Hâ‚, âˆƒ gâ‚‚ âˆˆ Hâ‚‚, â…gâ‚, gâ‚‚â† = g }âŸ©
#align subgroup.commutator Subgroup.commutator

theorem commutator_def (Hâ‚ Hâ‚‚ : Subgroup G) :
    â…Hâ‚, Hâ‚‚â† = closure { g | âˆƒ gâ‚ âˆˆ Hâ‚, âˆƒ gâ‚‚ âˆˆ Hâ‚‚, â…gâ‚, gâ‚‚â† = g } :=
  rfl
#align subgroup.commutator_def Subgroup.commutator_def

variable {gâ‚ gâ‚‚ gâ‚ƒ} {Hâ‚ Hâ‚‚ Hâ‚ƒ Kâ‚ Kâ‚‚ : Subgroup G}

theorem commutator_mem_commutator (hâ‚ : gâ‚ âˆˆ Hâ‚) (hâ‚‚ : gâ‚‚ âˆˆ Hâ‚‚) : â…gâ‚, gâ‚‚â† âˆˆ â…Hâ‚, Hâ‚‚â† :=
  subset_closure âŸ¨gâ‚, hâ‚, gâ‚‚, hâ‚‚, rflâŸ©
#align subgroup.commutator_mem_commutator Subgroup.commutator_mem_commutator

theorem commutator_le : â…Hâ‚, Hâ‚‚â† â‰¤ Hâ‚ƒ â†” âˆ€ gâ‚ âˆˆ Hâ‚, âˆ€ gâ‚‚ âˆˆ Hâ‚‚, â…gâ‚, gâ‚‚â† âˆˆ Hâ‚ƒ :=
  Hâ‚ƒ.closure_le.trans
    âŸ¨fun h a b c d => h âŸ¨a, b, c, d, rflâŸ©, fun h _g âŸ¨a, b, c, d, h_eqâŸ© => h_eq â–¸ h a b c dâŸ©
#align subgroup.commutator_le Subgroup.commutator_le

theorem commutator_mono (hâ‚ : Hâ‚ â‰¤ Kâ‚) (hâ‚‚ : Hâ‚‚ â‰¤ Kâ‚‚) : â…Hâ‚, Hâ‚‚â† â‰¤ â…Kâ‚, Kâ‚‚â† :=
  commutator_le.mpr fun _gâ‚ hgâ‚ _gâ‚‚ hgâ‚‚ => commutator_mem_commutator (hâ‚ hgâ‚) (hâ‚‚ hgâ‚‚)
#align subgroup.commutator_mono Subgroup.commutator_mono

theorem commutator_eq_bot_iff_le_centralizer : â…Hâ‚, Hâ‚‚â† = âŠ¥ â†” Hâ‚ â‰¤ centralizer Hâ‚‚ := by
  rw [eq_bot_iff, commutator_le]
  -- âŠ¢ (âˆ€ (gâ‚ : G), gâ‚ âˆˆ Hâ‚ â†’ âˆ€ (gâ‚‚ : G), gâ‚‚ âˆˆ Hâ‚‚ â†’ â…gâ‚, gâ‚‚â† âˆˆ âŠ¥) â†” Hâ‚ â‰¤ centralize â€¦
  refine'
    forall_congr' fun p => forall_congr' fun _hp => forall_congr' fun q => forall_congr' fun hq => _
  rw [mem_bot, commutatorElement_eq_one_iff_mul_comm, eq_comm]
  -- ğŸ‰ no goals
#align subgroup.commutator_eq_bot_iff_le_centralizer Subgroup.commutator_eq_bot_iff_le_centralizer

/-- **The Three Subgroups Lemma** (via the Hall-Witt identity) -/
theorem commutator_commutator_eq_bot_of_rotate (h1 : â…â…Hâ‚‚, Hâ‚ƒâ†, Hâ‚â† = âŠ¥) (h2 : â…â…Hâ‚ƒ, Hâ‚â†, Hâ‚‚â† = âŠ¥) :
    â…â…Hâ‚, Hâ‚‚â†, Hâ‚ƒâ† = âŠ¥ := by
  simp_rw [commutator_eq_bot_iff_le_centralizer, commutator_le,
    mem_centralizer_iff_commutator_eq_one, â† commutatorElement_def] at h1 h2 âŠ¢
  intro x hx y hy z hz
  -- âŠ¢ â…z, â…x, yâ†â† = 1
  trans x * z * â…y, â…zâ»Â¹, xâ»Â¹â†â†â»Â¹ * zâ»Â¹ * y * â…xâ»Â¹, â…yâ»Â¹, zâ†â†â»Â¹ * yâ»Â¹ * xâ»Â¹
  -- âŠ¢ â…z, â…x, yâ†â† = x * z * â…y, â…zâ»Â¹, xâ»Â¹â†â†â»Â¹ * zâ»Â¹ * y * â…xâ»Â¹, â…yâ»Â¹, zâ†â†â»Â¹ * yâ»Â¹  â€¦
  Â· group
    -- ğŸ‰ no goals
  Â· rw [h1 _ (Hâ‚‚.inv_mem hy) _ hz _ (Hâ‚.inv_mem hx), h2 _ (Hâ‚ƒ.inv_mem hz) _ (Hâ‚.inv_mem hx) _ hy]
    -- âŠ¢ x * z * 1â»Â¹ * zâ»Â¹ * y * 1â»Â¹ * yâ»Â¹ * xâ»Â¹ = 1
    group
    -- ğŸ‰ no goals
#align subgroup.commutator_commutator_eq_bot_of_rotate Subgroup.commutator_commutator_eq_bot_of_rotate

variable (Hâ‚ Hâ‚‚)

theorem commutator_comm_le : â…Hâ‚, Hâ‚‚â† â‰¤ â…Hâ‚‚, Hâ‚â† :=
  commutator_le.mpr fun gâ‚ hâ‚ gâ‚‚ hâ‚‚ =>
    commutatorElement_inv gâ‚‚ gâ‚ â–¸ â…Hâ‚‚, Hâ‚â†.inv_mem_iff.mpr (commutator_mem_commutator hâ‚‚ hâ‚)
#align subgroup.commutator_comm_le Subgroup.commutator_comm_le

theorem commutator_comm : â…Hâ‚, Hâ‚‚â† = â…Hâ‚‚, Hâ‚â† :=
  le_antisymm (commutator_comm_le Hâ‚ Hâ‚‚) (commutator_comm_le Hâ‚‚ Hâ‚)
#align subgroup.commutator_comm Subgroup.commutator_comm

section Normal

instance commutator_normal [hâ‚ : Hâ‚.Normal] [hâ‚‚ : Hâ‚‚.Normal] : Normal â…Hâ‚, Hâ‚‚â† := by
  let base : Set G := { x | âˆƒ gâ‚ âˆˆ Hâ‚, âˆƒ gâ‚‚ âˆˆ Hâ‚‚, â…gâ‚, gâ‚‚â† = x }
  -- âŠ¢ Normal â…Hâ‚, Hâ‚‚â†
  change (closure base).Normal
  -- âŠ¢ Normal (closure base)
  suffices h_base : base = Group.conjugatesOfSet base
  -- âŠ¢ Normal (closure base)
  Â· rw [h_base]
    -- âŠ¢ Normal (closure (Group.conjugatesOfSet base))
    exact Subgroup.normalClosure_normal
    -- ğŸ‰ no goals
  refine' Set.Subset.antisymm Group.subset_conjugatesOfSet fun a h => _
  -- âŠ¢ a âˆˆ base
  simp_rw [Group.mem_conjugatesOfSet_iff, isConj_iff] at h
  -- âŠ¢ a âˆˆ base
  rcases h with âŸ¨b, âŸ¨c, hc, e, he, rflâŸ©, d, rflâŸ©
  -- âŠ¢ d * â…c, eâ† * dâ»Â¹ âˆˆ base
  exact âŸ¨_, hâ‚.conj_mem c hc d, _, hâ‚‚.conj_mem e he d, (conjugate_commutatorElement c e d).symmâŸ©
  -- ğŸ‰ no goals
#align subgroup.commutator_normal Subgroup.commutator_normal

theorem commutator_def' [Hâ‚.Normal] [Hâ‚‚.Normal] :
    â…Hâ‚, Hâ‚‚â† = normalClosure { g | âˆƒ gâ‚ âˆˆ Hâ‚, âˆƒ gâ‚‚ âˆˆ Hâ‚‚, â…gâ‚, gâ‚‚â† = g } :=
  le_antisymm closure_le_normalClosure (normalClosure_le_normal subset_closure)
#align subgroup.commutator_def' Subgroup.commutator_def'

theorem commutator_le_right [h : Hâ‚‚.Normal] : â…Hâ‚, Hâ‚‚â† â‰¤ Hâ‚‚ :=
  commutator_le.mpr fun gâ‚ _hâ‚ gâ‚‚ hâ‚‚ => Hâ‚‚.mul_mem (h.conj_mem gâ‚‚ hâ‚‚ gâ‚) (Hâ‚‚.inv_mem hâ‚‚)
#align subgroup.commutator_le_right Subgroup.commutator_le_right

theorem commutator_le_left [Hâ‚.Normal] : â…Hâ‚, Hâ‚‚â† â‰¤ Hâ‚ :=
  commutator_comm Hâ‚‚ Hâ‚ â–¸ commutator_le_right Hâ‚‚ Hâ‚
#align subgroup.commutator_le_left Subgroup.commutator_le_left

@[simp]
theorem commutator_bot_left : â…(âŠ¥ : Subgroup G), Hâ‚â† = âŠ¥ :=
  le_bot_iff.mp (commutator_le_left âŠ¥ Hâ‚)
#align subgroup.commutator_bot_left Subgroup.commutator_bot_left

@[simp]
theorem commutator_bot_right : â…Hâ‚, âŠ¥â† = (âŠ¥ : Subgroup G) :=
  le_bot_iff.mp (commutator_le_right Hâ‚ âŠ¥)
#align subgroup.commutator_bot_right Subgroup.commutator_bot_right

theorem commutator_le_inf [Normal Hâ‚] [Normal Hâ‚‚] : â…Hâ‚, Hâ‚‚â† â‰¤ Hâ‚ âŠ“ Hâ‚‚ :=
  le_inf (commutator_le_left Hâ‚ Hâ‚‚) (commutator_le_right Hâ‚ Hâ‚‚)
#align subgroup.commutator_le_inf Subgroup.commutator_le_inf

end Normal

theorem map_commutator (f : G â†’* G') : map f â…Hâ‚, Hâ‚‚â† = â…map f Hâ‚, map f Hâ‚‚â† := by
  simp_rw [le_antisymm_iff, map_le_iff_le_comap, commutator_le, mem_comap, map_commutatorElement]
  -- âŠ¢ (âˆ€ (gâ‚ : G), gâ‚ âˆˆ Hâ‚ â†’ âˆ€ (gâ‚‚ : G), gâ‚‚ âˆˆ Hâ‚‚ â†’ â…â†‘f gâ‚, â†‘f gâ‚‚â† âˆˆ â…map f Hâ‚, map â€¦
  constructor
  -- âŠ¢ âˆ€ (gâ‚ : G), gâ‚ âˆˆ Hâ‚ â†’ âˆ€ (gâ‚‚ : G), gâ‚‚ âˆˆ Hâ‚‚ â†’ â…â†‘f gâ‚, â†‘f gâ‚‚â† âˆˆ â…map f Hâ‚, map  â€¦
  Â· intro p hp q hq
    -- âŠ¢ â…â†‘f p, â†‘f qâ† âˆˆ â…map f Hâ‚, map f Hâ‚‚â†
    exact commutator_mem_commutator (mem_map_of_mem _ hp) (mem_map_of_mem _ hq)
    -- ğŸ‰ no goals
  Â· rintro _ âŸ¨p, hp, rflâŸ© _ âŸ¨q, hq, rflâŸ©
    -- âŠ¢ â…â†‘f p, â†‘f qâ† âˆˆ map f â…Hâ‚, Hâ‚‚â†
    rw [â† map_commutatorElement]
    -- âŠ¢ â†‘f â…p, qâ† âˆˆ map f â…Hâ‚, Hâ‚‚â†
    exact mem_map_of_mem _ (commutator_mem_commutator hp hq)
    -- ğŸ‰ no goals
#align subgroup.map_commutator Subgroup.map_commutator

variable {Hâ‚ Hâ‚‚}

theorem commutator_le_map_commutator {f : G â†’* G'} {Kâ‚ Kâ‚‚ : Subgroup G'} (hâ‚ : Kâ‚ â‰¤ Hâ‚.map f)
    (hâ‚‚ : Kâ‚‚ â‰¤ Hâ‚‚.map f) : â…Kâ‚, Kâ‚‚â† â‰¤ â…Hâ‚, Hâ‚‚â†.map f :=
  (commutator_mono hâ‚ hâ‚‚).trans (ge_of_eq (map_commutator Hâ‚ Hâ‚‚ f))
#align subgroup.commutator_le_map_commutator Subgroup.commutator_le_map_commutator

variable (Hâ‚ Hâ‚‚)

instance commutator_characteristic [hâ‚ : Characteristic Hâ‚] [hâ‚‚ : Characteristic Hâ‚‚] :
    Characteristic â…Hâ‚, Hâ‚‚â† :=
  characteristic_iff_le_map.mpr fun Ï• =>
    commutator_le_map_commutator (characteristic_iff_le_map.mp hâ‚ Ï•)
      (characteristic_iff_le_map.mp hâ‚‚ Ï•)
#align subgroup.commutator_characteristic Subgroup.commutator_characteristic

theorem commutator_prod_prod (Kâ‚ Kâ‚‚ : Subgroup G') :
    â…Hâ‚.prod Kâ‚, Hâ‚‚.prod Kâ‚‚â† = â…Hâ‚, Hâ‚‚â†.prod â…Kâ‚, Kâ‚‚â† := by
  apply le_antisymm
  -- âŠ¢ â…prod Hâ‚ Kâ‚, prod Hâ‚‚ Kâ‚‚â† â‰¤ prod â…Hâ‚, Hâ‚‚â† â…Kâ‚, Kâ‚‚â†
  Â· rw [commutator_le]
    -- âŠ¢ âˆ€ (gâ‚ : G Ã— G'), gâ‚ âˆˆ prod Hâ‚ Kâ‚ â†’ âˆ€ (gâ‚‚ : G Ã— G'), gâ‚‚ âˆˆ prod Hâ‚‚ Kâ‚‚ â†’ â…gâ‚, g â€¦
    rintro âŸ¨pâ‚, pâ‚‚âŸ© âŸ¨hpâ‚, hpâ‚‚âŸ© âŸ¨qâ‚, qâ‚‚âŸ© âŸ¨hqâ‚, hqâ‚‚âŸ©
    -- âŠ¢ â…(pâ‚, pâ‚‚), (qâ‚, qâ‚‚)â† âˆˆ prod â…Hâ‚, Hâ‚‚â† â…Kâ‚, Kâ‚‚â†
    exact âŸ¨commutator_mem_commutator hpâ‚ hqâ‚, commutator_mem_commutator hpâ‚‚ hqâ‚‚âŸ©
    -- ğŸ‰ no goals
  Â· rw [prod_le_iff]
    -- âŠ¢ map (MonoidHom.inl G G') â…Hâ‚, Hâ‚‚â† â‰¤ â…prod Hâ‚ Kâ‚, prod Hâ‚‚ Kâ‚‚â† âˆ§ map (MonoidHo â€¦
    constructor <;>
    -- âŠ¢ map (MonoidHom.inl G G') â…Hâ‚, Hâ‚‚â† â‰¤ â…prod Hâ‚ Kâ‚, prod Hâ‚‚ Kâ‚‚â†
      Â· rw [map_commutator]
        -- âŠ¢ â…map (MonoidHom.inl G G') Hâ‚, map (MonoidHom.inl G G') Hâ‚‚â† â‰¤ â…prod Hâ‚ Kâ‚, pr â€¦
        -- âŠ¢ â…map (MonoidHom.inr G G') Kâ‚, map (MonoidHom.inr G G') Kâ‚‚â† â‰¤ â…prod Hâ‚ Kâ‚, pr â€¦
        -- âŠ¢ map (MonoidHom.inl G G') Hâ‚ â‰¤ prod Hâ‚ Kâ‚
        apply commutator_mono <;>
        -- âŠ¢ map (MonoidHom.inr G G') Kâ‚ â‰¤ prod Hâ‚ Kâ‚
          simp [le_prod_iff, map_map, MonoidHom.fst_comp_inl, MonoidHom.snd_comp_inl,
            MonoidHom.fst_comp_inr, MonoidHom.snd_comp_inr]
#align subgroup.commutator_prod_prod Subgroup.commutator_prod_prod

/-- The commutator of direct product is contained in the direct product of the commutators.

See `commutator_pi_pi_of_finite` for equality given `Fintype Î·`.
-/
theorem commutator_pi_pi_le {Î· : Type*} {Gs : Î· â†’ Type*} [âˆ€ i, Group (Gs i)]
    (H K : âˆ€ i, Subgroup (Gs i)) :
    â…Subgroup.pi Set.univ H, Subgroup.pi Set.univ Kâ† â‰¤ Subgroup.pi Set.univ fun i => â…H i, K iâ† :=
  commutator_le.mpr fun _p hp _q hq i hi => commutator_mem_commutator (hp i hi) (hq i hi)
#align subgroup.commutator_pi_pi_le Subgroup.commutator_pi_pi_le

/-- The commutator of a finite direct product is contained in the direct product of the commutators.
-/
theorem commutator_pi_pi_of_finite {Î· : Type*} [Finite Î·] {Gs : Î· â†’ Type*} [âˆ€ i, Group (Gs i)]
    (H K : âˆ€ i, Subgroup (Gs i)) : â…Subgroup.pi Set.univ H, Subgroup.pi Set.univ Kâ† =
    Subgroup.pi Set.univ fun i => â…H i, K iâ† := by
  classical
    apply le_antisymm (commutator_pi_pi_le H K)
    Â· rw [pi_le_iff]
      intro i hi
      rw [map_commutator]
      apply commutator_mono <;>
        Â· rw [le_pi_iff]
          intro j _hj
          rintro _ âŸ¨_, âŸ¨x, hx, rflâŸ©, rflâŸ©
          by_cases h : j = i
          Â· subst h
            simpa using hx
          Â· simp [h, one_mem]
#align subgroup.commutator_pi_pi_of_finite Subgroup.commutator_pi_pi_of_finite

end Subgroup

variable (G)

/-- The set of commutator elements `â…gâ‚, gâ‚‚â†` in `G`. -/
def commutatorSet : Set G :=
  { g | âˆƒ gâ‚ gâ‚‚ : G, â…gâ‚, gâ‚‚â† = g }
#align commutator_set commutatorSet

theorem commutatorSet_def : commutatorSet G = { g | âˆƒ gâ‚ gâ‚‚ : G, â…gâ‚, gâ‚‚â† = g } :=
  rfl
#align commutator_set_def commutatorSet_def

theorem one_mem_commutatorSet : (1 : G) âˆˆ commutatorSet G :=
  âŸ¨1, 1, commutatorElement_self 1âŸ©
#align one_mem_commutator_set one_mem_commutatorSet

instance : Nonempty (commutatorSet G) :=
  âŸ¨âŸ¨1, one_mem_commutatorSet GâŸ©âŸ©

variable {G g}

theorem mem_commutatorSet_iff : g âˆˆ commutatorSet G â†” âˆƒ gâ‚ gâ‚‚ : G, â…gâ‚, gâ‚‚â† = g :=
  Iff.rfl
#align mem_commutator_set_iff mem_commutatorSet_iff

theorem commutator_mem_commutatorSet : â…gâ‚, gâ‚‚â† âˆˆ commutatorSet G :=
  âŸ¨gâ‚, gâ‚‚, rflâŸ©
#align commutator_mem_commutator_set commutator_mem_commutatorSet
