/-
Copyright (c) 2020 Kexing Ying. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kexing Ying
-/
import Mathlib.Algebra.Group.Conj
import Mathlib.Algebra.Module.Basic
import Mathlib.Algebra.Order.Group.InjSurj
import Mathlib.Data.Countable.Basic
import Mathlib.GroupTheory.Submonoid.Centralizer
import Mathlib.Logic.Encodable.Basic
import Mathlib.Order.Atoms
import Mathlib.Tactic.ApplyFun

#align_import group_theory.subgroup.basic from "leanprover-community/mathlib"@"4be589053caf347b899a494da75410deb55fb3ef"

/-!
# Subgroups

This file defines multiplicative and additive subgroups as an extension of submonoids, in a bundled
form (unbundled subgroups are in `Deprecated/Subgroups.lean`).

We prove subgroups of a group form a complete lattice, and results about images and preimages of
subgroups under group homomorphisms. The bundled subgroups use bundled monoid homomorphisms.

There are also theorems about the subgroups generated by an element or a subset of a group,
defined both inductively and as the infimum of the set of subgroups containing a given
element/subset.

Special thanks goes to Amelia Livingston and Yury Kudryashov for their help and inspiration.

## Main definitions

Notation used here:

- `G N` are `Group`s

- `A` is an `AddGroup`

- `H K` are `Subgroup`s of `G` or `AddSubgroup`s of `A`

- `x` is an element of type `G` or type `A`

- `f g : N ‚Üí* G` are group homomorphisms

- `s k` are sets of elements of type `G`

Definitions in the file:

* `Subgroup G` : the type of subgroups of a group `G`

* `AddSubgroup A` : the type of subgroups of an additive group `A`

* `CompleteLattice (Subgroup G)` : the subgroups of `G` form a complete lattice

* `Subgroup.closure k` : the minimal subgroup that includes the set `k`

* `Subgroup.subtype` : the natural group homomorphism from a subgroup of group `G` to `G`

* `Subgroup.gi` : `closure` forms a Galois insertion with the coercion to set

* `Subgroup.comap H f` : the preimage of a subgroup `H` along the group homomorphism `f` is also a
  subgroup

* `Subgroup.map f H` : the image of a subgroup `H` along the group homomorphism `f` is also a
  subgroup

* `Subgroup.prod H K` : the product of subgroups `H`, `K` of groups `G`, `N` respectively, `H √ó K`
  is a subgroup of `G √ó N`

* `MonoidHom.range f` : the range of the group homomorphism `f` is a subgroup

* `MonoidHom.ker f` : the kernel of a group homomorphism `f` is the subgroup of elements `x : G`
  such that `f x = 1`

* `MonoidHom.eq_locus f g` : given group homomorphisms `f`, `g`, the elements of `G` such that
  `f x = g x` form a subgroup of `G`

## Implementation notes

Subgroup inclusion is denoted `‚â§` rather than `‚äÜ`, although `‚àà` is defined as
membership of a subgroup's underlying set.

## Tags
subgroup, subgroups
-/


open Function
open Int

variable {G G' G'' : Type*} [Group G] [Group G'] [Group G'']

variable {A : Type*} [AddGroup A]

section SubgroupClass

/-- `InvMemClass S G` states `S` is a type of subsets `s ‚äÜ G` closed under inverses. -/
class InvMemClass (S G : Type*) [Inv G] [SetLike S G] : Prop where
  /-- `s` is closed under inverses -/
  inv_mem : ‚àÄ {s : S} {x}, x ‚àà s ‚Üí x‚Åª¬π ‚àà s
#align inv_mem_class InvMemClass

export InvMemClass (inv_mem)

/-- `NegMemClass S G` states `S` is a type of subsets `s ‚äÜ G` closed under negation. -/
class NegMemClass (S G : Type*) [Neg G] [SetLike S G] : Prop where
  /-- `s` is closed under negation -/
  neg_mem : ‚àÄ {s : S} {x}, x ‚àà s ‚Üí -x ‚àà s
#align neg_mem_class NegMemClass

export NegMemClass (neg_mem)

/-- `SubgroupClass S G` states `S` is a type of subsets `s ‚äÜ G` that are subgroups of `G`. -/
class SubgroupClass (S G : Type*) [DivInvMonoid G] [SetLike S G] extends SubmonoidClass S G,
  InvMemClass S G : Prop
#align subgroup_class SubgroupClass

/-- `AddSubgroupClass S G` states `S` is a type of subsets `s ‚äÜ G` that are
additive subgroups of `G`. -/
class AddSubgroupClass (S G : Type*) [SubNegMonoid G] [SetLike S G] extends AddSubmonoidClass S G,
  NegMemClass S G : Prop
#align add_subgroup_class AddSubgroupClass

attribute [to_additive] InvMemClass SubgroupClass

@[to_additive (attr := simp)]
theorem inv_mem_iff {S G} [InvolutiveInv G] {_ : SetLike S G} [InvMemClass S G] {H : S}
    {x : G} : x‚Åª¬π ‚àà H ‚Üî x ‚àà H :=
  ‚ü®fun h => inv_inv x ‚ñ∏ inv_mem h, inv_mem‚ü©
#align inv_mem_iff inv_mem_iff
#align neg_mem_iff neg_mem_iff

@[simp] theorem abs_mem_iff {S G} [InvolutiveNeg G] [LinearOrder G] {_ : SetLike S G}
    [NegMemClass S G] {H : S} {x : G} : |x| ‚àà H ‚Üî x ‚àà H := by
  cases abs_choice x <;> simp [*]
  -- ‚ä¢ |x| ‚àà H ‚Üî x ‚àà H
                         -- üéâ no goals
                         -- üéâ no goals

variable {M S : Type*} [DivInvMonoid M] [SetLike S M] [hSM : SubgroupClass S M] {H K : S}

/-- A subgroup is closed under division. -/
@[to_additive "An additive subgroup is closed under subtraction."]
theorem div_mem {x y : M} (hx : x ‚àà H) (hy : y ‚àà H) : x / y ‚àà H := by
  rw [div_eq_mul_inv]; exact mul_mem hx (inv_mem hy)
  -- ‚ä¢ x * y‚Åª¬π ‚àà H
                       -- üéâ no goals
#align div_mem div_mem
#align sub_mem sub_mem

@[to_additive]
theorem zpow_mem {x : M} (hx : x ‚àà K) : ‚àÄ n : ‚Ñ§, x ^ n ‚àà K
  | (n : ‚Ñï) => by
    rw [zpow_ofNat]
    -- ‚ä¢ x ^ n ‚àà K
    exact pow_mem hx n
    -- üéâ no goals
  | -[n+1] => by
    rw [zpow_negSucc]
    -- ‚ä¢ (x ^ (n + 1))‚Åª¬π ‚àà K
    exact inv_mem (pow_mem hx n.succ)
    -- üéâ no goals
#align zpow_mem zpow_mem
#align zsmul_mem zsmul_mem

variable [SetLike S G] [SubgroupClass S G]

@[to_additive]
theorem div_mem_comm_iff {a b : G} : a / b ‚àà H ‚Üî b / a ‚àà H :=
  inv_div b a ‚ñ∏ inv_mem_iff
#align div_mem_comm_iff div_mem_comm_iff
#align sub_mem_comm_iff sub_mem_comm_iff

@[to_additive /-(attr := simp)-/] -- porting note: `simp` cannot simplify LHS
theorem exists_inv_mem_iff_exists_mem {P : G ‚Üí Prop} :
    (‚àÉ x : G, x ‚àà H ‚àß P x‚Åª¬π) ‚Üî ‚àÉ x ‚àà H, P x := by
  constructor <;>
  -- ‚ä¢ (‚àÉ x, x ‚àà H ‚àß P x‚Åª¬π) ‚Üí ‚àÉ x, x ‚àà H ‚àß P x
    ¬∑ rintro ‚ü®x, x_in, hx‚ü©
      -- ‚ä¢ ‚àÉ x, x ‚àà H ‚àß P x
      -- ‚ä¢ ‚àÉ x, x ‚àà H ‚àß P x‚Åª¬π
      -- üéâ no goals
      exact ‚ü®x‚Åª¬π, inv_mem x_in, by simp [hx]‚ü©
      -- üéâ no goals
#align exists_inv_mem_iff_exists_mem exists_inv_mem_iff_exists_mem
#align exists_neg_mem_iff_exists_mem exists_neg_mem_iff_exists_mem



@[to_additive]
theorem mul_mem_cancel_right {x y : G} (h : x ‚àà H) : y * x ‚àà H ‚Üî y ‚àà H :=
  -- Porting note: whut? why do we need this?
  haveI : SubmonoidClass S G := SubgroupClass.toSubmonoidClass
  ‚ü®fun hba => by simpa using mul_mem hba (inv_mem h), fun hb => mul_mem hb h‚ü©
                 -- üéâ no goals
#align mul_mem_cancel_right mul_mem_cancel_right
#align add_mem_cancel_right add_mem_cancel_right

@[to_additive]
theorem mul_mem_cancel_left {x y : G} (h : x ‚àà H) : x * y ‚àà H ‚Üî y ‚àà H :=
  -- Porting note: whut? why do we need this?
  have : SubmonoidClass S G := SubgroupClass.toSubmonoidClass
  ‚ü®fun hab => by simpa using mul_mem (inv_mem h) hab, mul_mem h‚ü©
                 -- üéâ no goals
#align mul_mem_cancel_left mul_mem_cancel_left
#align add_mem_cancel_left add_mem_cancel_left

namespace SubgroupClass

/-- A subgroup of a group inherits an inverse. -/
@[to_additive "An additive subgroup of an `AddGroup` inherits an inverse."]
instance inv {G : Type u_1} {S : Type u_2} [DivInvMonoid G] [SetLike S G]
  [SubgroupClass S G] {H : S} : Inv H :=
  ‚ü®fun a => ‚ü®a‚Åª¬π, inv_mem a.2‚ü©‚ü©
#align subgroup_class.has_inv SubgroupClass.inv
#align add_subgroup_class.has_neg AddSubgroupClass.neg

/-- A subgroup of a group inherits a division -/
@[to_additive "An additive subgroup of an `AddGroup` inherits a subtraction."]
instance div {G : Type u_1} {S : Type u_2} [DivInvMonoid G] [SetLike S G]
  [SubgroupClass S G] {H : S} : Div H :=
  ‚ü®fun a b => ‚ü®a / b, div_mem a.2 b.2‚ü©‚ü©
#align subgroup_class.has_div SubgroupClass.div
#align add_subgroup_class.has_sub AddSubgroupClass.sub

/-- An additive subgroup of an `AddGroup` inherits an integer scaling. -/
instance _root_.AddSubgroupClass.zsmul {M S} [SubNegMonoid M] [SetLike S M]
    [AddSubgroupClass S M] {H : S} : SMul ‚Ñ§ H :=
  ‚ü®fun n a => ‚ü®n ‚Ä¢ a.1, zsmul_mem a.2 n‚ü©‚ü©
#align add_subgroup_class.has_zsmul AddSubgroupClass.zsmul

/-- A subgroup of a group inherits an integer power. -/
@[to_additive existing]
instance zpow {M S} [DivInvMonoid M] [SetLike S M] [SubgroupClass S M] {H : S} : Pow H ‚Ñ§ :=
  ‚ü®fun a n => ‚ü®a.1 ^ n, zpow_mem a.2 n‚ü©‚ü©
#align subgroup_class.has_zpow SubgroupClass.zpow
-- Porting note: additive align statement is given above

@[to_additive (attr := simp, norm_cast)]
theorem coe_inv (x : H) : (x‚Åª¬π).1 = x.1‚Åª¬π :=
  rfl
#align subgroup_class.coe_inv SubgroupClass.coe_inv
#align add_subgroup_class.coe_neg AddSubgroupClass.coe_neg

@[to_additive (attr := simp, norm_cast)]
theorem coe_div (x y : H) : (x / y).1 = x.1 / y.1 :=
  rfl
#align subgroup_class.coe_div SubgroupClass.coe_div
#align add_subgroup_class.coe_sub AddSubgroupClass.coe_sub

variable (H)

-- Prefer subclasses of `Group` over subclasses of `SubgroupClass`.
/-- A subgroup of a group inherits a group structure. -/
@[to_additive "An additive subgroup of an `AddGroup` inherits an `AddGroup` structure."]
instance (priority := 75) toGroup : Group H :=
  Subtype.coe_injective.group _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)
    (fun _ _ => rfl) fun _ _ => rfl
#align subgroup_class.to_group SubgroupClass.toGroup
#align add_subgroup_class.to_add_group AddSubgroupClass.toAddGroup

-- Prefer subclasses of `CommGroup` over subclasses of `SubgroupClass`.
/-- A subgroup of a `CommGroup` is a `CommGroup`. -/
@[to_additive "An additive subgroup of an `AddCommGroup` is an `AddCommGroup`."]
instance (priority := 75) toCommGroup {G : Type*} [CommGroup G] [SetLike S G] [SubgroupClass S G] :
    CommGroup H :=
  Subtype.coe_injective.commGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)
    (fun _ _ => rfl) fun _ _ => rfl
#align subgroup_class.to_comm_group SubgroupClass.toCommGroup
#align add_subgroup_class.to_add_comm_group AddSubgroupClass.toAddCommGroup

-- Prefer subclasses of `Group` over subclasses of `SubgroupClass`.
/-- A subgroup of an `OrderedCommGroup` is an `OrderedCommGroup`. -/
@[to_additive "An additive subgroup of an `AddOrderedCommGroup` is an `AddOrderedCommGroup`."]
instance (priority := 75) toOrderedCommGroup {G : Type*} [OrderedCommGroup G] [SetLike S G]
    [SubgroupClass S G] : OrderedCommGroup H :=
  Subtype.coe_injective.orderedCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)
    (fun _ _ => rfl) fun _ _ => rfl
#align subgroup_class.to_ordered_comm_group SubgroupClass.toOrderedCommGroup
#align add_subgroup_class.to_ordered_add_comm_group AddSubgroupClass.toOrderedAddCommGroup

-- Prefer subclasses of `Group` over subclasses of `SubgroupClass`.
/-- A subgroup of a `LinearOrderedCommGroup` is a `LinearOrderedCommGroup`. -/
@[to_additive
      "An additive subgroup of a `LinearOrderedAddCommGroup` is a
        `LinearOrderedAddCommGroup`."]
instance (priority := 75) toLinearOrderedCommGroup {G : Type*} [LinearOrderedCommGroup G]
    [SetLike S G] [SubgroupClass S G] : LinearOrderedCommGroup H :=
  Subtype.coe_injective.linearOrderedCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl)
    (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) fun _ _ => rfl
#align subgroup_class.to_linear_ordered_comm_group SubgroupClass.toLinearOrderedCommGroup
#align add_subgroup_class.to_linear_ordered_add_comm_group AddSubgroupClass.toLinearOrderedAddCommGroup

/-- The natural group hom from a subgroup of group `G` to `G`. -/
@[to_additive (attr := coe)
  "The natural group hom from an additive subgroup of `AddGroup` `G` to `G`."]
protected def subtype : H ‚Üí* G :=
  ‚ü®‚ü®((‚Üë) : H ‚Üí G), rfl‚ü©, fun _ _ => rfl‚ü©
#align subgroup_class.subtype SubgroupClass.subtype
#align add_subgroup_class.subtype AddSubgroupClass.subtype

@[to_additive (attr := simp)]
theorem coeSubtype : (SubgroupClass.subtype H : H ‚Üí G) = ((‚Üë) : H ‚Üí G) := by
  rfl
  -- üéâ no goals
#align subgroup_class.coe_subtype SubgroupClass.coeSubtype
#align add_subgroup_class.coe_subtype AddSubgroupClass.coeSubtype

variable {H}

@[to_additive (attr := simp, norm_cast)]
theorem coe_pow (x : H) (n : ‚Ñï) : ((x ^ n : H) : G) = (x : G) ^ n :=
  rfl
#align subgroup_class.coe_pow SubgroupClass.coe_pow
#align add_subgroup_class.coe_smul AddSubgroupClass.coe_nsmul

@[to_additive (attr := simp, norm_cast)]
theorem coe_zpow (x : H) (n : ‚Ñ§) : ((x ^ n : H) : G) = (x : G) ^ n :=
  rfl
#align subgroup_class.coe_zpow SubgroupClass.coe_zpow
#align add_subgroup_class.coe_zsmul AddSubgroupClass.coe_zsmul

/-- The inclusion homomorphism from a subgroup `H` contained in `K` to `K`. -/
@[to_additive "The inclusion homomorphism from an additive subgroup `H` contained in `K` to `K`."]
def inclusion {H K : S} (h : H ‚â§ K) : H ‚Üí* K :=
  MonoidHom.mk' (fun x => ‚ü®x, h x.prop‚ü©) fun _ _=> rfl
#align subgroup_class.inclusion SubgroupClass.inclusion
#align add_subgroup_class.inclusion AddSubgroupClass.inclusion

@[to_additive (attr := simp)]
theorem inclusion_self (x : H) : inclusion le_rfl x = x := by
  cases x
  -- ‚ä¢ ‚Üë(inclusion (_ : H ‚â§ H)) { val := val‚úù, property := property‚úù } = { val := v ‚Ä¶
  rfl
  -- üéâ no goals
#align subgroup_class.inclusion_self SubgroupClass.inclusion_self
#align add_subgroup_class.inclusion_self AddSubgroupClass.inclusion_self

@[to_additive (attr := simp)]
theorem inclusion_mk {h : H ‚â§ K} (x : G) (hx : x ‚àà H) : inclusion h ‚ü®x, hx‚ü© = ‚ü®x, h hx‚ü© :=
  rfl
#align subgroup_class.inclusion_mk SubgroupClass.inclusion_mk
#align add_subgroup_class.inclusion_mk AddSubgroupClass.inclusion_mk

@[to_additive]
theorem inclusion_right (h : H ‚â§ K) (x : K) (hx : (x : G) ‚àà H) : inclusion h ‚ü®x, hx‚ü© = x := by
  cases x
  -- ‚ä¢ ‚Üë(inclusion h) { val := ‚Üë{ val := val‚úù, property := property‚úù }, property := ‚Ä¶
  rfl
  -- üéâ no goals
#align subgroup_class.inclusion_right SubgroupClass.inclusion_right
#align add_subgroup_class.inclusion_right AddSubgroupClass.inclusion_right

@[simp]
theorem inclusion_inclusion {L : S} (hHK : H ‚â§ K) (hKL : K ‚â§ L) (x : H) :
    inclusion hKL (inclusion hHK x) = inclusion (hHK.trans hKL) x := by
  cases x
  -- ‚ä¢ ‚Üë(inclusion hKL) (‚Üë(inclusion hHK) { val := val‚úù, property := property‚úù }) = ‚Ä¶
  rfl
  -- üéâ no goals
#align subgroup_class.inclusion_inclusion SubgroupClass.inclusion_inclusion

@[to_additive (attr := simp)]
theorem coe_inclusion {H K : S} {h : H ‚â§ K} (a : H) : (inclusion h a : G) = a := by
  cases a
  -- ‚ä¢ ‚Üë(‚Üë(inclusion h) { val := val‚úù, property := property‚úù }) = ‚Üë{ val := val‚úù, p ‚Ä¶
  simp only [inclusion, MonoidHom.mk'_apply]
  -- üéâ no goals
#align subgroup_class.coe_inclusion SubgroupClass.coe_inclusion
#align add_subgroup_class.coe_inclusion AddSubgroupClass.coe_inclusion

@[to_additive (attr := simp)]
theorem subtype_comp_inclusion {H K : S} (hH : H ‚â§ K) :
    (SubgroupClass.subtype K).comp (inclusion hH) = SubgroupClass.subtype H := by
  ext
  -- ‚ä¢ ‚Üë(MonoidHom.comp (‚ÜëK) (inclusion hH)) x‚úù = ‚Üë‚ÜëH x‚úù
  simp only [MonoidHom.comp_apply, coeSubtype, coe_inclusion]
  -- üéâ no goals
#align subgroup_class.subtype_comp_inclusion SubgroupClass.subtype_comp_inclusion
#align add_subgroup_class.subtype_comp_inclusion AddSubgroupClass.subtype_comp_inclusion

end SubgroupClass

end SubgroupClass

/-- A subgroup of a group `G` is a subset containing 1, closed under multiplication
and closed under multiplicative inverse. -/
structure Subgroup (G : Type*) [Group G] extends Submonoid G where
  /-- `G` is closed under inverses -/
  inv_mem' {x} : x ‚àà carrier ‚Üí x‚Åª¬π ‚àà carrier
#align subgroup Subgroup

/-- An additive subgroup of an additive group `G` is a subset containing 0, closed
under addition and additive inverse. -/
structure AddSubgroup (G : Type*) [AddGroup G] extends AddSubmonoid G where
  /-- `G` is closed under negation -/
  neg_mem' {x} : x ‚àà carrier ‚Üí -x ‚àà carrier
#align add_subgroup AddSubgroup

attribute [to_additive] Subgroup

-- Porting note: Removed, translation already exists
-- attribute [to_additive AddSubgroup.toAddSubmonoid] Subgroup.toSubmonoid

/-- Reinterpret a `Subgroup` as a `Submonoid`. -/
add_decl_doc Subgroup.toSubmonoid
#align subgroup.to_submonoid Subgroup.toSubmonoid

/-- Reinterpret an `AddSubgroup` as an `AddSubmonoid`. -/
add_decl_doc AddSubgroup.toAddSubmonoid
#align add_subgroup.to_add_submonoid AddSubgroup.toAddSubmonoid

namespace Subgroup

@[to_additive]
instance : SetLike (Subgroup G) G where
  coe s := s.carrier
  coe_injective' p q h := by
    obtain ‚ü®‚ü®‚ü®hp,_‚ü©,_‚ü©,_‚ü© := p
    -- ‚ä¢ { toSubmonoid := { toSubsemigroup := { carrier := hp, mul_mem' := mul_mem'‚úù  ‚Ä¶
    obtain ‚ü®‚ü®‚ü®hq,_‚ü©,_‚ü©,_‚ü© := q
    -- ‚ä¢ { toSubmonoid := { toSubsemigroup := { carrier := hp, mul_mem' := mul_mem'‚úù¬π ‚Ä¶
    congr
    -- üéâ no goals

-- Porting note: Below can probably be written more uniformly
@[to_additive]
instance : SubgroupClass (Subgroup G) G where
  inv_mem := Subgroup.inv_mem' _
  one_mem _ := (Subgroup.toSubmonoid _).one_mem'
  mul_mem := (Subgroup.toSubmonoid _).mul_mem'

@[to_additive (attr := simp, nolint simpNF)] -- Porting note: dsimp can not prove this
theorem mem_carrier {s : Subgroup G} {x : G} : x ‚àà s.carrier ‚Üî x ‚àà s :=
  Iff.rfl
#align subgroup.mem_carrier Subgroup.mem_carrier
#align add_subgroup.mem_carrier AddSubgroup.mem_carrier

@[to_additive (attr := simp)]
theorem mem_mk {s : Set G} {x : G} (h_one) (h_mul) (h_inv) :
    x ‚àà mk ‚ü®‚ü®s, h_one‚ü©, h_mul‚ü© h_inv ‚Üî x ‚àà s :=
  Iff.rfl
#align subgroup.mem_mk Subgroup.mem_mk
#align add_subgroup.mem_mk AddSubgroup.mem_mk

@[to_additive (attr := simp)]
theorem coe_set_mk {s : Set G} (h_one) (h_mul) (h_inv) :
    (mk ‚ü®‚ü®s, h_one‚ü©, h_mul‚ü© h_inv : Set G) = s :=
  rfl
#align subgroup.coe_set_mk Subgroup.coe_set_mk
#align add_subgroup.coe_set_mk AddSubgroup.coe_set_mk

@[to_additive (attr := simp)]
theorem mk_le_mk {s t : Set G} (h_one) (h_mul) (h_inv) (h_one') (h_mul') (h_inv') :
    mk ‚ü®‚ü®s, h_one‚ü©, h_mul‚ü© h_inv ‚â§ mk ‚ü®‚ü®t, h_one'‚ü©, h_mul'‚ü© h_inv' ‚Üî s ‚äÜ t :=
  Iff.rfl
#align subgroup.mk_le_mk Subgroup.mk_le_mk
#align add_subgroup.mk_le_mk AddSubgroup.mk_le_mk

initialize_simps_projections Subgroup (carrier ‚Üí coe)
initialize_simps_projections AddSubgroup (carrier ‚Üí coe)

@[to_additive (attr := simp)]
theorem coe_toSubmonoid (K : Subgroup G) : (K.toSubmonoid : Set G) = K :=
  rfl
#align subgroup.coe_to_submonoid Subgroup.coe_toSubmonoid
#align add_subgroup.coe_to_add_submonoid AddSubgroup.coe_toAddSubmonoid

@[to_additive (attr := simp)]
theorem mem_toSubmonoid (K : Subgroup G) (x : G) : x ‚àà K.toSubmonoid ‚Üî x ‚àà K :=
  Iff.rfl
#align subgroup.mem_to_submonoid Subgroup.mem_toSubmonoid
#align add_subgroup.mem_to_add_submonoid AddSubgroup.mem_toAddSubmonoid

@[to_additive]
theorem toSubmonoid_injective : Function.Injective (toSubmonoid : Subgroup G ‚Üí Submonoid G) :=
  -- fun p q h => SetLike.ext'_iff.2 (show _ from SetLike.ext'_iff.1 h)
  fun p q h => by
    have := SetLike.ext'_iff.1 h
    -- ‚ä¢ p = q
    rw [coe_toSubmonoid, coe_toSubmonoid] at this
    -- ‚ä¢ p = q
    exact SetLike.ext'_iff.2 this
    -- üéâ no goals
#align subgroup.to_submonoid_injective Subgroup.toSubmonoid_injective
#align add_subgroup.to_add_submonoid_injective AddSubgroup.toAddSubmonoid_injective

@[to_additive (attr := simp)]
theorem toSubmonoid_eq {p q : Subgroup G} : p.toSubmonoid = q.toSubmonoid ‚Üî p = q :=
  toSubmonoid_injective.eq_iff
#align subgroup.to_submonoid_eq Subgroup.toSubmonoid_eq
#align add_subgroup.to_add_submonoid_eq AddSubgroup.toAddSubmonoid_eq

@[to_additive (attr := mono)]
theorem toSubmonoid_strictMono : StrictMono (toSubmonoid : Subgroup G ‚Üí Submonoid G) := fun _ _ =>
  id
#align subgroup.to_submonoid_strict_mono Subgroup.toSubmonoid_strictMono
#align add_subgroup.to_add_submonoid_strict_mono AddSubgroup.toAddSubmonoid_strictMono

@[to_additive (attr := mono)]
theorem toSubmonoid_mono : Monotone (toSubmonoid : Subgroup G ‚Üí Submonoid G) :=
  toSubmonoid_strictMono.monotone
#align subgroup.to_submonoid_mono Subgroup.toSubmonoid_mono
#align add_subgroup.to_add_submonoid_mono AddSubgroup.toAddSubmonoid_mono

@[to_additive (attr := simp)]
theorem toSubmonoid_le {p q : Subgroup G} : p.toSubmonoid ‚â§ q.toSubmonoid ‚Üî p ‚â§ q :=
  Iff.rfl
#align subgroup.to_submonoid_le Subgroup.toSubmonoid_le
#align add_subgroup.to_add_submonoid_le AddSubgroup.toAddSubmonoid_le

end Subgroup

/-!
### Conversion to/from `Additive`/`Multiplicative`
-/


section mul_add

/-- Subgroups of a group `G` are isomorphic to additive subgroups of `Additive G`. -/
@[simps!]
def Subgroup.toAddSubgroup : Subgroup G ‚âÉo AddSubgroup (Additive G) where
  toFun S := { Submonoid.toAddSubmonoid S.toSubmonoid with neg_mem' := S.inv_mem' }
  invFun S := { AddSubmonoid.toSubmonoid S.toAddSubmonoid with inv_mem' := S.neg_mem' }
  left_inv x := by cases x; rfl
                   -- ‚ä¢ (fun S =>
                            -- üéâ no goals
  right_inv x := by cases x; rfl
                    -- ‚ä¢ (fun S =>
                             -- üéâ no goals
  map_rel_iff' := Iff.rfl
#align subgroup.to_add_subgroup Subgroup.toAddSubgroup
#align subgroup.to_add_subgroup_symm_apply_coe Subgroup.toAddSubgroup_symm_apply_coe
#align subgroup.to_add_subgroup_apply_coe Subgroup.toAddSubgroup_apply_coe

/-- Additive subgroup of an additive group `Additive G` are isomorphic to subgroup of `G`. -/
abbrev AddSubgroup.toSubgroup' : AddSubgroup (Additive G) ‚âÉo Subgroup G :=
  Subgroup.toAddSubgroup.symm
#align add_subgroup.to_subgroup' AddSubgroup.toSubgroup'

/-- Additive supgroups of an additive group `A` are isomorphic to subgroups of `Multiplicative A`.
-/
@[simps!]
def AddSubgroup.toSubgroup : AddSubgroup A ‚âÉo Subgroup (Multiplicative A) where
  toFun S := { AddSubmonoid.toSubmonoid S.toAddSubmonoid with inv_mem' := S.neg_mem' }
  invFun S := { Submonoid.toAddSubmonoid S.toSubmonoid with neg_mem' := S.inv_mem' }
  left_inv x := by cases x; rfl
                   -- ‚ä¢ (fun S =>
                            -- üéâ no goals
  right_inv x := by cases x; rfl
                    -- ‚ä¢ (fun S =>
                             -- üéâ no goals
  map_rel_iff' := Iff.rfl
#align add_subgroup.to_subgroup AddSubgroup.toSubgroup
#align add_subgroup.to_subgroup_apply_coe AddSubgroup.toSubgroup_apply_coe
#align add_subgroup.to_subgroup_symm_apply_coe AddSubgroup.toSubgroup_symm_apply_coe

/-- Subgroups of an additive group `Multiplicative A` are isomorphic to additive subgroups of `A`.
-/
abbrev Subgroup.toAddSubgroup' : Subgroup (Multiplicative A) ‚âÉo AddSubgroup A :=
  AddSubgroup.toSubgroup.symm
#align subgroup.to_add_subgroup' Subgroup.toAddSubgroup'

end mul_add

namespace Subgroup

variable (H K : Subgroup G)

/-- Copy of a subgroup with a new `carrier` equal to the old one. Useful to fix definitional
equalities.-/
@[to_additive
      "Copy of an additive subgroup with a new `carrier` equal to the old one.
      Useful to fix definitional equalities"]
protected def copy (K : Subgroup G) (s : Set G) (hs : s = K) : Subgroup G where
  carrier := s
  one_mem' := hs.symm ‚ñ∏ K.one_mem'
  mul_mem' := hs.symm ‚ñ∏ K.mul_mem'
  inv_mem' hx := by simpa [hs] using hx -- porting note: `‚ñ∏` didn't work here
                    -- üéâ no goals
#align subgroup.copy Subgroup.copy
#align add_subgroup.copy AddSubgroup.copy

@[to_additive (attr := simp)]
theorem coe_copy (K : Subgroup G) (s : Set G) (hs : s = ‚ÜëK) : (K.copy s hs : Set G) = s :=
  rfl
#align subgroup.coe_copy Subgroup.coe_copy
#align add_subgroup.coe_copy AddSubgroup.coe_copy

@[to_additive]
theorem copy_eq (K : Subgroup G) (s : Set G) (hs : s = ‚ÜëK) : K.copy s hs = K :=
  SetLike.coe_injective hs
#align subgroup.copy_eq Subgroup.copy_eq
#align add_subgroup.copy_eq AddSubgroup.copy_eq

/-- Two subgroups are equal if they have the same elements. -/
@[to_additive (attr := ext) "Two `AddSubgroup`s are equal if they have the same elements."]
theorem ext {H K : Subgroup G} (h : ‚àÄ x, x ‚àà H ‚Üî x ‚àà K) : H = K :=
  SetLike.ext h
#align subgroup.ext Subgroup.ext
#align add_subgroup.ext AddSubgroup.ext

/-- A subgroup contains the group's 1. -/
@[to_additive "An `AddSubgroup` contains the group's 0."]
protected theorem one_mem : (1 : G) ‚àà H :=
  one_mem _
#align subgroup.one_mem Subgroup.one_mem
#align add_subgroup.zero_mem AddSubgroup.zero_mem

/-- A subgroup is closed under multiplication. -/
@[to_additive "An `AddSubgroup` is closed under addition."]
protected theorem mul_mem {x y : G} : x ‚àà H ‚Üí y ‚àà H ‚Üí x * y ‚àà H :=
  mul_mem
#align subgroup.mul_mem Subgroup.mul_mem
#align add_subgroup.add_mem AddSubgroup.add_mem

/-- A subgroup is closed under inverse. -/
@[to_additive "An `AddSubgroup` is closed under inverse."]
protected theorem inv_mem {x : G} : x ‚àà H ‚Üí x‚Åª¬π ‚àà H :=
  inv_mem
#align subgroup.inv_mem Subgroup.inv_mem
#align add_subgroup.neg_mem AddSubgroup.neg_mem

/-- A subgroup is closed under division. -/
@[to_additive "An `AddSubgroup` is closed under subtraction."]
protected theorem div_mem {x y : G} (hx : x ‚àà H) (hy : y ‚àà H) : x / y ‚àà H :=
  div_mem hx hy
#align subgroup.div_mem Subgroup.div_mem
#align add_subgroup.sub_mem AddSubgroup.sub_mem

@[to_additive]
protected theorem inv_mem_iff {x : G} : x‚Åª¬π ‚àà H ‚Üî x ‚àà H :=
  inv_mem_iff
#align subgroup.inv_mem_iff Subgroup.inv_mem_iff
#align add_subgroup.neg_mem_iff AddSubgroup.neg_mem_iff

@[to_additive]
protected theorem div_mem_comm_iff {a b : G} : a / b ‚àà H ‚Üî b / a ‚àà H :=
  div_mem_comm_iff
#align subgroup.div_mem_comm_iff Subgroup.div_mem_comm_iff
#align add_subgroup.sub_mem_comm_iff AddSubgroup.sub_mem_comm_iff

@[to_additive]
protected theorem exists_inv_mem_iff_exists_mem (K : Subgroup G) {P : G ‚Üí Prop} :
    (‚àÉ x : G, x ‚àà K ‚àß P x‚Åª¬π) ‚Üî ‚àÉ x ‚àà K, P x :=
  exists_inv_mem_iff_exists_mem
#align subgroup.exists_inv_mem_iff_exists_mem Subgroup.exists_inv_mem_iff_exists_mem
#align add_subgroup.exists_neg_mem_iff_exists_mem AddSubgroup.exists_neg_mem_iff_exists_mem

@[to_additive]
protected theorem mul_mem_cancel_right {x y : G} (h : x ‚àà H) : y * x ‚àà H ‚Üî y ‚àà H :=
  mul_mem_cancel_right h
#align subgroup.mul_mem_cancel_right Subgroup.mul_mem_cancel_right
#align add_subgroup.add_mem_cancel_right AddSubgroup.add_mem_cancel_right

@[to_additive]
protected theorem mul_mem_cancel_left {x y : G} (h : x ‚àà H) : x * y ‚àà H ‚Üî y ‚àà H :=
  mul_mem_cancel_left h
#align subgroup.mul_mem_cancel_left Subgroup.mul_mem_cancel_left
#align add_subgroup.add_mem_cancel_left AddSubgroup.add_mem_cancel_left

@[to_additive]
protected theorem pow_mem {x : G} (hx : x ‚àà K) : ‚àÄ n : ‚Ñï, x ^ n ‚àà K :=
  pow_mem hx
#align subgroup.pow_mem Subgroup.pow_mem
#align add_subgroup.nsmul_mem AddSubgroup.nsmul_mem

@[to_additive]
protected theorem zpow_mem {x : G} (hx : x ‚àà K) : ‚àÄ n : ‚Ñ§, x ^ n ‚àà K :=
  zpow_mem hx
#align subgroup.zpow_mem Subgroup.zpow_mem
#align add_subgroup.zsmul_mem AddSubgroup.zsmul_mem

/-- Construct a subgroup from a nonempty set that is closed under division. -/
@[to_additive "Construct a subgroup from a nonempty set that is closed under subtraction"]
def ofDiv (s : Set G) (hsn : s.Nonempty) (hs : ‚àÄ (x) (_ : x ‚àà s) (y) (_ : y ‚àà s), x * y‚Åª¬π ‚àà s) :
    Subgroup G :=
  have one_mem : (1 : G) ‚àà s := by
    let ‚ü®x, hx‚ü© := hsn
    -- ‚ä¢ 1 ‚àà s
    simpa using hs x hx x hx
    -- üéâ no goals
  have inv_mem : ‚àÄ x, x ‚àà s ‚Üí x‚Åª¬π ‚àà s := fun x hx => by simpa using hs 1 one_mem x hx
                                                        -- üéâ no goals
  { carrier := s
    one_mem' := one_mem
    inv_mem' := inv_mem _
    mul_mem' := fun hx hy => by simpa using hs _ hx _ (inv_mem _ hy) }
                                -- üéâ no goals
#align subgroup.of_div Subgroup.ofDiv
#align add_subgroup.of_sub AddSubgroup.ofSub

/-- A subgroup of a group inherits a multiplication. -/
@[to_additive "An `AddSubgroup` of an `AddGroup` inherits an addition."]
instance mul : Mul H :=
  H.toSubmonoid.mul
#align subgroup.has_mul Subgroup.mul
#align add_subgroup.has_add AddSubgroup.add

/-- A subgroup of a group inherits a 1. -/
@[to_additive "An `AddSubgroup` of an `AddGroup` inherits a zero."]
instance one : One H :=
  H.toSubmonoid.one
#align subgroup.has_one Subgroup.one
#align add_subgroup.has_zero AddSubgroup.zero

/-- A subgroup of a group inherits an inverse. -/
@[to_additive "An `AddSubgroup` of an `AddGroup` inherits an inverse."]
instance inv : Inv H :=
  ‚ü®fun a => ‚ü®a‚Åª¬π, H.inv_mem a.2‚ü©‚ü©
#align subgroup.has_inv Subgroup.inv
#align add_subgroup.has_neg AddSubgroup.neg

/-- A subgroup of a group inherits a division -/
@[to_additive "An `AddSubgroup` of an `AddGroup` inherits a subtraction."]
instance div : Div H :=
  ‚ü®fun a b => ‚ü®a / b, H.div_mem a.2 b.2‚ü©‚ü©
#align subgroup.has_div Subgroup.div
#align add_subgroup.has_sub AddSubgroup.sub

/-- An `AddSubgroup` of an `AddGroup` inherits a natural scaling. -/
instance _root_.AddSubgroup.nsmul {G} [AddGroup G] {H : AddSubgroup G} : SMul ‚Ñï H :=
  ‚ü®fun n a => ‚ü®n ‚Ä¢ a, H.nsmul_mem a.2 n‚ü©‚ü©
#align add_subgroup.has_nsmul AddSubgroup.nsmul

/-- A subgroup of a group inherits a natural power -/
@[to_additive existing]
protected instance npow : Pow H ‚Ñï :=
  ‚ü®fun a n => ‚ü®a ^ n, H.pow_mem a.2 n‚ü©‚ü©
#align subgroup.has_npow Subgroup.npow

/-- An `AddSubgroup` of an `AddGroup` inherits an integer scaling. -/
instance _root_.AddSubgroup.zsmul {G} [AddGroup G] {H : AddSubgroup G} : SMul ‚Ñ§ H :=
  ‚ü®fun n a => ‚ü®n ‚Ä¢ a, H.zsmul_mem a.2 n‚ü©‚ü©
#align add_subgroup.has_zsmul AddSubgroup.zsmul

/-- A subgroup of a group inherits an integer power -/
@[to_additive existing]
instance zpow : Pow H ‚Ñ§ :=
  ‚ü®fun a n => ‚ü®a ^ n, H.zpow_mem a.2 n‚ü©‚ü©
#align subgroup.has_zpow Subgroup.zpow

@[to_additive (attr := simp, norm_cast)]
theorem coe_mul (x y : H) : (‚Üë(x * y) : G) = ‚Üëx * ‚Üëy :=
  rfl
#align subgroup.coe_mul Subgroup.coe_mul
#align add_subgroup.coe_add AddSubgroup.coe_add

@[to_additive (attr := simp, norm_cast)]
theorem coe_one : ((1 : H) : G) = 1 :=
  rfl
#align subgroup.coe_one Subgroup.coe_one
#align add_subgroup.coe_zero AddSubgroup.coe_zero

@[to_additive (attr := simp, norm_cast)]
theorem coe_inv (x : H) : ‚Üë(x‚Åª¬π : H) = (x‚Åª¬π : G) :=
  rfl
#align subgroup.coe_inv Subgroup.coe_inv
#align add_subgroup.coe_neg AddSubgroup.coe_neg

@[to_additive (attr := simp, norm_cast)]
theorem coe_div (x y : H) : (‚Üë(x / y) : G) = ‚Üëx / ‚Üëy :=
  rfl
#align subgroup.coe_div Subgroup.coe_div
#align add_subgroup.coe_sub AddSubgroup.coe_sub

-- Porting note: removed simp, theorem has variable as head symbol
@[to_additive (attr := norm_cast)]
theorem coe_mk (x : G) (hx : x ‚àà H) : ((‚ü®x, hx‚ü© : H) : G) = x :=
  rfl
#align subgroup.coe_mk Subgroup.coe_mk
#align add_subgroup.coe_mk AddSubgroup.coe_mk

@[to_additive (attr := simp, norm_cast)]
theorem coe_pow (x : H) (n : ‚Ñï) : ((x ^ n : H) : G) = (x : G) ^ n :=
  rfl
#align subgroup.coe_pow Subgroup.coe_pow
#align add_subgroup.coe_nsmul AddSubgroup.coe_nsmul

@[to_additive (attr := norm_cast)] -- Porting note: dsimp can prove this
theorem coe_zpow (x : H) (n : ‚Ñ§) : ((x ^ n : H) : G) = (x : G) ^ n :=
  rfl
#align subgroup.coe_zpow Subgroup.coe_zpow
#align add_subgroup.coe_zsmul AddSubgroup.coe_zsmul

@[to_additive (attr := simp)]
theorem mk_eq_one_iff {g : G} {h} : (‚ü®g, h‚ü© : H) = 1 ‚Üî g = 1 :=
  show (‚ü®g, h‚ü© : H) = (‚ü®1, H.one_mem‚ü© : H) ‚Üî g = 1 by simp
                                                      -- üéâ no goals
#align subgroup.mk_eq_one_iff Subgroup.mk_eq_one_iff
#align add_subgroup.mk_eq_zero_iff AddSubgroup.mk_eq_zero_iff

/-- A subgroup of a group inherits a group structure. -/
@[to_additive "An `AddSubgroup` of an `AddGroup` inherits an `AddGroup` structure."]
instance toGroup {G : Type*} [Group G] (H : Subgroup G) : Group H :=
  Subtype.coe_injective.group _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)
    (fun _ _ => rfl) fun _ _ => rfl
#align subgroup.to_group Subgroup.toGroup
#align add_subgroup.to_add_group AddSubgroup.toAddGroup

/-- A subgroup of a `CommGroup` is a `CommGroup`. -/
@[to_additive "An `AddSubgroup` of an `AddCommGroup` is an `AddCommGroup`."]
instance toCommGroup {G : Type*} [CommGroup G] (H : Subgroup G) : CommGroup H :=
  Subtype.coe_injective.commGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)
    (fun _ _ => rfl) fun _ _ => rfl
#align subgroup.to_comm_group Subgroup.toCommGroup
#align add_subgroup.to_add_comm_group AddSubgroup.toAddCommGroup

/-- A subgroup of an `OrderedCommGroup` is an `OrderedCommGroup`. -/
@[to_additive "An `AddSubgroup` of an `AddOrderedCommGroup` is an `AddOrderedCommGroup`."]
instance toOrderedCommGroup {G : Type*} [OrderedCommGroup G] (H : Subgroup G) :
    OrderedCommGroup H :=
  Subtype.coe_injective.orderedCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)
    (fun _ _ => rfl) fun _ _ => rfl
#align subgroup.to_ordered_comm_group Subgroup.toOrderedCommGroup
#align add_subgroup.to_ordered_add_comm_group AddSubgroup.toOrderedAddCommGroup

/-- A subgroup of a `LinearOrderedCommGroup` is a `LinearOrderedCommGroup`. -/
@[to_additive
      "An `AddSubgroup` of a `LinearOrderedAddCommGroup` is a
        `LinearOrderedAddCommGroup`."]
instance toLinearOrderedCommGroup {G : Type*} [LinearOrderedCommGroup G] (H : Subgroup G) :
    LinearOrderedCommGroup H :=
  Subtype.coe_injective.linearOrderedCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl)
    (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) fun _ _ => rfl
#align subgroup.to_linear_ordered_comm_group Subgroup.toLinearOrderedCommGroup
#align add_subgroup.to_linear_ordered_add_comm_group AddSubgroup.toLinearOrderedAddCommGroup

/-- The natural group hom from a subgroup of group `G` to `G`. -/
@[to_additive "The natural group hom from an `AddSubgroup` of `AddGroup` `G` to `G`."]
protected def subtype : H ‚Üí* G :=
  ‚ü®‚ü®((‚Üë) : H ‚Üí G), rfl‚ü©, fun _ _ => rfl‚ü©
#align subgroup.subtype Subgroup.subtype
#align add_subgroup.subtype AddSubgroup.subtype

@[to_additive (attr := simp)]
theorem coeSubtype : ‚áë H.subtype = ((‚Üë) : H ‚Üí G) :=
  rfl
#align subgroup.coe_subtype Subgroup.coeSubtype
#align add_subgroup.coe_subtype AddSubgroup.coeSubtype

@[to_additive]
theorem subtype_injective : Function.Injective (Subgroup.subtype H) :=
  Subtype.coe_injective
#align subgroup.subtype_injective Subgroup.subtype_injective
#align add_subgroup.subtype_injective AddSubgroup.subtype_injective

/-- The inclusion homomorphism from a subgroup `H` contained in `K` to `K`. -/
@[to_additive "The inclusion homomorphism from an additive subgroup `H` contained in `K` to `K`."]
def inclusion {H K : Subgroup G} (h : H ‚â§ K) : H ‚Üí* K :=
  MonoidHom.mk' (fun x => ‚ü®x, h x.2‚ü©) fun _ _ => rfl
#align subgroup.inclusion Subgroup.inclusion
#align add_subgroup.inclusion AddSubgroup.inclusion

@[to_additive (attr := simp)]
theorem coe_inclusion {H K : Subgroup G} {h : H ‚â§ K} (a : H) : (inclusion h a : G) = a := by
  cases a
  -- ‚ä¢ ‚Üë(‚Üë(inclusion h) { val := val‚úù, property := property‚úù }) = ‚Üë{ val := val‚úù, p ‚Ä¶
  simp only [inclusion, coe_mk, MonoidHom.mk'_apply]
  -- üéâ no goals
#align subgroup.coe_inclusion Subgroup.coe_inclusion
#align add_subgroup.coe_inclusion AddSubgroup.coe_inclusion

@[to_additive]
theorem inclusion_injective {H K : Subgroup G} (h : H ‚â§ K) : Function.Injective <| inclusion h :=
  Set.inclusion_injective h
#align subgroup.inclusion_injective Subgroup.inclusion_injective
#align add_subgroup.inclusion_injective AddSubgroup.inclusion_injective

@[to_additive (attr := simp)]
theorem subtype_comp_inclusion {H K : Subgroup G} (hH : H ‚â§ K) :
    K.subtype.comp (inclusion hH) = H.subtype :=
  rfl
#align subgroup.subtype_comp_inclusion Subgroup.subtype_comp_inclusion
#align add_subgroup.subtype_comp_inclusion AddSubgroup.subtype_comp_inclusion

/-- The subgroup `G` of the group `G`. -/
@[to_additive "The `AddSubgroup G` of the `AddGroup G`."]
instance : Top (Subgroup G) :=
  ‚ü®{ (‚ä§ : Submonoid G) with inv_mem' := fun _ => Set.mem_univ _ }‚ü©

/-- The top subgroup is isomorphic to the group.

This is the group version of `Submonoid.topEquiv`. -/
@[to_additive (attr := simps!)
      "The top additive subgroup is isomorphic to the additive group.

      This is the additive group version of `AddSubmonoid.topEquiv`."]
def topEquiv : (‚ä§ : Subgroup G) ‚âÉ* G :=
  Submonoid.topEquiv
#align subgroup.top_equiv Subgroup.topEquiv
#align add_subgroup.top_equiv AddSubgroup.topEquiv
#align subgroup.top_equiv_symm_apply_coe Subgroup.topEquiv_symm_apply_coe
#align add_subgroup.top_equiv_symm_apply_coe AddSubgroup.topEquiv_symm_apply_coe
#align add_subgroup.top_equiv_apply AddSubgroup.topEquiv_apply

/-- The trivial subgroup `{1}` of a group `G`. -/
@[to_additive "The trivial `AddSubgroup` `{0}` of an `AddGroup` `G`."]
instance : Bot (Subgroup G) :=
  ‚ü®{ (‚ä• : Submonoid G) with inv_mem' := by simp}‚ü©
                                           -- üéâ no goals

@[to_additive]
instance : Inhabited (Subgroup G) :=
  ‚ü®‚ä•‚ü©

@[to_additive (attr := simp)]
theorem mem_bot {x : G} : x ‚àà (‚ä• : Subgroup G) ‚Üî x = 1 :=
  Iff.rfl
#align subgroup.mem_bot Subgroup.mem_bot
#align add_subgroup.mem_bot AddSubgroup.mem_bot

@[to_additive (attr := simp)]
theorem mem_top (x : G) : x ‚àà (‚ä§ : Subgroup G) :=
  Set.mem_univ x
#align subgroup.mem_top Subgroup.mem_top
#align add_subgroup.mem_top AddSubgroup.mem_top

@[to_additive (attr := simp)]
theorem coe_top : ((‚ä§ : Subgroup G) : Set G) = Set.univ :=
  rfl
#align subgroup.coe_top Subgroup.coe_top
#align add_subgroup.coe_top AddSubgroup.coe_top

@[to_additive (attr := simp)]
theorem coe_bot : ((‚ä• : Subgroup G) : Set G) = {1} :=
  rfl
#align subgroup.coe_bot Subgroup.coe_bot
#align add_subgroup.coe_bot AddSubgroup.coe_bot

@[to_additive]
instance : Unique (‚ä• : Subgroup G) :=
  ‚ü®‚ü®1‚ü©, fun g => Subtype.ext g.2‚ü©

@[to_additive (attr := simp)]
theorem top_toSubmonoid : (‚ä§ : Subgroup G).toSubmonoid = ‚ä§ :=
  rfl
#align subgroup.top_to_submonoid Subgroup.top_toSubmonoid
#align add_subgroup.top_to_add_submonoid AddSubgroup.top_toAddSubmonoid

@[to_additive (attr := simp)]
theorem bot_toSubmonoid : (‚ä• : Subgroup G).toSubmonoid = ‚ä• :=
  rfl
#align subgroup.bot_to_submonoid Subgroup.bot_toSubmonoid
#align add_subgroup.bot_to_add_submonoid AddSubgroup.bot_toAddSubmonoid

@[to_additive]
theorem eq_bot_iff_forall : H = ‚ä• ‚Üî ‚àÄ x ‚àà H, x = (1 : G) :=
  toSubmonoid_injective.eq_iff.symm.trans <| Submonoid.eq_bot_iff_forall _
#align subgroup.eq_bot_iff_forall Subgroup.eq_bot_iff_forall
#align add_subgroup.eq_bot_iff_forall AddSubgroup.eq_bot_iff_forall

@[to_additive]
theorem eq_bot_of_subsingleton [Subsingleton H] : H = ‚ä• := by
  rw [Subgroup.eq_bot_iff_forall]
  -- ‚ä¢ ‚àÄ (x : G), x ‚àà H ‚Üí x = 1
  intro y hy
  -- ‚ä¢ y = 1
  rw [‚Üê Subgroup.coe_mk H y hy, Subsingleton.elim (‚ü®y, hy‚ü© : H) 1, Subgroup.coe_one]
  -- üéâ no goals
#align subgroup.eq_bot_of_subsingleton Subgroup.eq_bot_of_subsingleton
#align add_subgroup.eq_bot_of_subsingleton AddSubgroup.eq_bot_of_subsingleton

@[to_additive]
theorem coe_eq_univ {H : Subgroup G} : (H : Set G) = Set.univ ‚Üî H = ‚ä§ :=
  (SetLike.ext'_iff.trans (by rfl)).symm
                              -- üéâ no goals
#align subgroup.coe_eq_univ Subgroup.coe_eq_univ
#align add_subgroup.coe_eq_univ AddSubgroup.coe_eq_univ

@[to_additive]
theorem coe_eq_singleton {H : Subgroup G} : (‚àÉ g : G, (H : Set G) = {g}) ‚Üî H = ‚ä• :=
  ‚ü®fun ‚ü®g, hg‚ü© =>
    haveI : Subsingleton (H : Set G) := by
      rw [hg]
      -- ‚ä¢ Subsingleton ‚Üë{g}
      infer_instance
      -- üéâ no goals
    H.eq_bot_of_subsingleton,
    fun h => ‚ü®1, SetLike.ext'_iff.mp h‚ü©‚ü©
#align subgroup.coe_eq_singleton Subgroup.coe_eq_singleton
#align add_subgroup.coe_eq_singleton AddSubgroup.coe_eq_singleton

@[to_additive]
theorem nontrivial_iff_exists_ne_one (H : Subgroup G) : Nontrivial H ‚Üî ‚àÉ x ‚àà H, x ‚â† (1 : G) := by
  rw [Subtype.nontrivial_iff_exists_ne (fun x => x ‚àà H) (1 : H)]
  -- ‚ä¢ (‚àÉ y x, y ‚â† ‚Üë1) ‚Üî ‚àÉ x, x ‚àà H ‚àß x ‚â† 1
  simp
  -- üéâ no goals
#align subgroup.nontrivial_iff_exists_ne_one Subgroup.nontrivial_iff_exists_ne_one
#align add_subgroup.nontrivial_iff_exists_ne_zero AddSubgroup.nontrivial_iff_exists_ne_zero

/-- A subgroup is either the trivial subgroup or nontrivial. -/
@[to_additive "A subgroup is either the trivial subgroup or nontrivial."]
theorem bot_or_nontrivial (H : Subgroup G) : H = ‚ä• ‚à® Nontrivial H := by
  classical
    by_cases h : ‚àÄ x ‚àà H, x = (1 : G)
    ¬∑ left
      exact H.eq_bot_iff_forall.mpr h
    ¬∑ right
      simp only [not_forall] at h
      simpa [nontrivial_iff_exists_ne_one] using h
#align subgroup.bot_or_nontrivial Subgroup.bot_or_nontrivial
#align add_subgroup.bot_or_nontrivial AddSubgroup.bot_or_nontrivial

/-- A subgroup is either the trivial subgroup or contains a non-identity element. -/
@[to_additive "A subgroup is either the trivial subgroup or contains a nonzero element."]
theorem bot_or_exists_ne_one (H : Subgroup G) : H = ‚ä• ‚à® ‚àÉ x ‚àà H, x ‚â† (1 : G) := by
  convert H.bot_or_nontrivial
  -- ‚ä¢ (‚àÉ x, x ‚àà H ‚àß x ‚â† 1) ‚Üî Nontrivial { x // x ‚àà H }
  rw [nontrivial_iff_exists_ne_one]
  -- üéâ no goals
#align subgroup.bot_or_exists_ne_one Subgroup.bot_or_exists_ne_one
#align add_subgroup.bot_or_exists_ne_zero AddSubgroup.bot_or_exists_ne_zero

/-- The inf of two subgroups is their intersection. -/
@[to_additive "The inf of two `AddSubgroup`s is their intersection."]
instance : Inf (Subgroup G) :=
  ‚ü®fun H‚ÇÅ H‚ÇÇ =>
    { H‚ÇÅ.toSubmonoid ‚äì H‚ÇÇ.toSubmonoid with
      inv_mem' := fun ‚ü®hx, hx'‚ü© => ‚ü®H‚ÇÅ.inv_mem hx, H‚ÇÇ.inv_mem hx'‚ü© }‚ü©

@[to_additive (attr := simp)]
theorem coe_inf (p p' : Subgroup G) : ((p ‚äì p' : Subgroup G) : Set G) = (p : Set G) ‚à© p' :=
  rfl
#align subgroup.coe_inf Subgroup.coe_inf
#align add_subgroup.coe_inf AddSubgroup.coe_inf

@[to_additive (attr := simp)]
theorem mem_inf {p p' : Subgroup G} {x : G} : x ‚àà p ‚äì p' ‚Üî x ‚àà p ‚àß x ‚àà p' :=
  Iff.rfl
#align subgroup.mem_inf Subgroup.mem_inf
#align add_subgroup.mem_inf AddSubgroup.mem_inf

@[to_additive]
instance : InfSet (Subgroup G) :=
  ‚ü®fun s =>
    { (‚®Ö S ‚àà s, Subgroup.toSubmonoid S).copy (‚ãÇ S ‚àà s, ‚ÜëS) (by simp) with
                                                               -- üéâ no goals
      inv_mem' := fun {x} hx =>
        Set.mem_biInter fun i h => i.inv_mem (by apply Set.mem_iInter‚ÇÇ.1 hx i h) }‚ü©
                                                 -- üéâ no goals

@[to_additive (attr := simp, norm_cast)]
theorem coe_sInf (H : Set (Subgroup G)) : ((sInf H : Subgroup G) : Set G) = ‚ãÇ s ‚àà H, ‚Üës :=
  rfl
#align subgroup.coe_Inf Subgroup.coe_sInf
#align add_subgroup.coe_Inf AddSubgroup.coe_sInf

@[to_additive (attr := simp)]
theorem mem_sInf {S : Set (Subgroup G)} {x : G} : x ‚àà sInf S ‚Üî ‚àÄ p ‚àà S, x ‚àà p :=
  Set.mem_iInter‚ÇÇ
#align subgroup.mem_Inf Subgroup.mem_sInf
#align add_subgroup.mem_Inf AddSubgroup.mem_sInf

@[to_additive]
theorem mem_iInf {Œπ : Sort*} {S : Œπ ‚Üí Subgroup G} {x : G} : (x ‚àà ‚®Ö i, S i) ‚Üî ‚àÄ i, x ‚àà S i := by
  simp only [iInf, mem_sInf, Set.forall_range_iff]
  -- üéâ no goals
#align subgroup.mem_infi Subgroup.mem_iInf
#align add_subgroup.mem_infi AddSubgroup.mem_iInf

@[to_additive (attr := simp, norm_cast)]
theorem coe_iInf {Œπ : Sort*} {S : Œπ ‚Üí Subgroup G} : (‚Üë(‚®Ö i, S i) : Set G) = ‚ãÇ i, S i := by
  simp only [iInf, coe_sInf, Set.biInter_range]
  -- üéâ no goals
#align subgroup.coe_infi Subgroup.coe_iInf
#align add_subgroup.coe_infi AddSubgroup.coe_iInf

/-- Subgroups of a group form a complete lattice. -/
@[to_additive "The `AddSubgroup`s of an `AddGroup` form a complete lattice."]
instance : CompleteLattice (Subgroup G) :=
  { completeLatticeOfInf (Subgroup G) fun _s =>
      IsGLB.of_image SetLike.coe_subset_coe isGLB_biInf with
    bot := ‚ä•
    bot_le := fun S _x hx => (mem_bot.1 hx).symm ‚ñ∏ S.one_mem
    top := ‚ä§
    le_top := fun _S x _hx => mem_top x
    inf := (¬∑ ‚äì ¬∑)
    le_inf := fun _a _b _c ha hb _x hx => ‚ü®ha hx, hb hx‚ü©
    inf_le_left := fun _a _b _x => And.left
    inf_le_right := fun _a _b _x => And.right }

@[to_additive]
theorem mem_sup_left {S T : Subgroup G} : ‚àÄ {x : G}, x ‚àà S ‚Üí x ‚àà S ‚äî T :=
  have : S ‚â§ S ‚äî T := le_sup_left; fun h ‚Ü¶ this h
#align subgroup.mem_sup_left Subgroup.mem_sup_left
#align add_subgroup.mem_sup_left AddSubgroup.mem_sup_left

@[to_additive]
theorem mem_sup_right {S T : Subgroup G} : ‚àÄ {x : G}, x ‚àà T ‚Üí x ‚àà S ‚äî T :=
  have : T ‚â§ S ‚äî T := le_sup_right; fun h ‚Ü¶ this h
#align subgroup.mem_sup_right Subgroup.mem_sup_right
#align add_subgroup.mem_sup_right AddSubgroup.mem_sup_right

@[to_additive]
theorem mul_mem_sup {S T : Subgroup G} {x y : G} (hx : x ‚àà S) (hy : y ‚àà T) : x * y ‚àà S ‚äî T :=
  (S ‚äî T).mul_mem (mem_sup_left hx) (mem_sup_right hy)
#align subgroup.mul_mem_sup Subgroup.mul_mem_sup
#align add_subgroup.add_mem_sup AddSubgroup.add_mem_sup

@[to_additive]
theorem mem_iSup_of_mem {Œπ : Sort*} {S : Œπ ‚Üí Subgroup G} (i : Œπ) :
    ‚àÄ {x : G}, x ‚àà S i ‚Üí x ‚àà iSup S :=
  have : S i ‚â§ iSup S := le_iSup _ _; fun h ‚Ü¶ this h
#align subgroup.mem_supr_of_mem Subgroup.mem_iSup_of_mem
#align add_subgroup.mem_supr_of_mem AddSubgroup.mem_iSup_of_mem

@[to_additive]
theorem mem_sSup_of_mem {S : Set (Subgroup G)} {s : Subgroup G} (hs : s ‚àà S) :
    ‚àÄ {x : G}, x ‚àà s ‚Üí x ‚àà sSup S :=
  have : s ‚â§ sSup S := le_sSup hs; fun h ‚Ü¶ this h
#align subgroup.mem_Sup_of_mem Subgroup.mem_sSup_of_mem
#align add_subgroup.mem_Sup_of_mem AddSubgroup.mem_sSup_of_mem

@[to_additive (attr := simp)]
theorem subsingleton_iff : Subsingleton (Subgroup G) ‚Üî Subsingleton G :=
  ‚ü®fun h =>
    ‚ü®fun x y =>
      have : ‚àÄ i : G, i = 1 := fun i =>
        mem_bot.mp <| Subsingleton.elim (‚ä§ : Subgroup G) ‚ä• ‚ñ∏ mem_top i
      (this x).trans (this y).symm‚ü©,
    fun h => ‚ü®fun x y => Subgroup.ext fun i => Subsingleton.elim 1 i ‚ñ∏ by simp [Subgroup.one_mem]‚ü©‚ü©
                                                                          -- üéâ no goals
#align subgroup.subsingleton_iff Subgroup.subsingleton_iff
#align add_subgroup.subsingleton_iff AddSubgroup.subsingleton_iff

@[to_additive (attr := simp)]
theorem nontrivial_iff : Nontrivial (Subgroup G) ‚Üî Nontrivial G :=
  not_iff_not.mp
    ((not_nontrivial_iff_subsingleton.trans subsingleton_iff).trans
      not_nontrivial_iff_subsingleton.symm)
#align subgroup.nontrivial_iff Subgroup.nontrivial_iff
#align add_subgroup.nontrivial_iff AddSubgroup.nontrivial_iff

@[to_additive]
instance [Subsingleton G] : Unique (Subgroup G) :=
  ‚ü®‚ü®‚ä•‚ü©, fun a => @Subsingleton.elim _ (subsingleton_iff.mpr ‚Äπ_‚Ä∫) a _‚ü©

@[to_additive]
instance [Nontrivial G] : Nontrivial (Subgroup G) :=
  nontrivial_iff.mpr ‚Äπ_‚Ä∫

@[to_additive]
theorem eq_top_iff' : H = ‚ä§ ‚Üî ‚àÄ x : G, x ‚àà H :=
  eq_top_iff.trans ‚ü®fun h m => h <| mem_top m, fun h m _ => h m‚ü©
#align subgroup.eq_top_iff' Subgroup.eq_top_iff'
#align add_subgroup.eq_top_iff' AddSubgroup.eq_top_iff'

/-- The `Subgroup` generated by a set. -/
@[to_additive "The `AddSubgroup` generated by a set"]
def closure (k : Set G) : Subgroup G :=
  sInf { K | k ‚äÜ K }
#align subgroup.closure Subgroup.closure
#align add_subgroup.closure AddSubgroup.closure

variable {k : Set G}

@[to_additive]
theorem mem_closure {x : G} : x ‚àà closure k ‚Üî ‚àÄ K : Subgroup G, k ‚äÜ K ‚Üí x ‚àà K :=
  mem_sInf
#align subgroup.mem_closure Subgroup.mem_closure
#align add_subgroup.mem_closure AddSubgroup.mem_closure

/-- The subgroup generated by a set includes the set. -/
@[to_additive (attr := simp) "The `AddSubgroup` generated by a set includes the set."]
theorem subset_closure : k ‚äÜ closure k := fun _ hx => mem_closure.2 fun _ hK => hK hx
#align subgroup.subset_closure Subgroup.subset_closure
#align add_subgroup.subset_closure AddSubgroup.subset_closure

@[to_additive]
theorem not_mem_of_not_mem_closure {P : G} (hP : P ‚àâ closure k) : P ‚àâ k := fun h =>
  hP (subset_closure h)
#align subgroup.not_mem_of_not_mem_closure Subgroup.not_mem_of_not_mem_closure
#align add_subgroup.not_mem_of_not_mem_closure AddSubgroup.not_mem_of_not_mem_closure

open Set

/-- A subgroup `K` includes `closure k` if and only if it includes `k`. -/
@[to_additive (attr := simp)
  "An additive subgroup `K` includes `closure k` if and only if it includes `k`"]
theorem closure_le : closure k ‚â§ K ‚Üî k ‚äÜ K :=
  ‚ü®Subset.trans subset_closure, fun h => sInf_le h‚ü©
#align subgroup.closure_le Subgroup.closure_le
#align add_subgroup.closure_le AddSubgroup.closure_le

@[to_additive]
theorem closure_eq_of_le (h‚ÇÅ : k ‚äÜ K) (h‚ÇÇ : K ‚â§ closure k) : closure k = K :=
  le_antisymm ((closure_le <| K).2 h‚ÇÅ) h‚ÇÇ
#align subgroup.closure_eq_of_le Subgroup.closure_eq_of_le
#align add_subgroup.closure_eq_of_le AddSubgroup.closure_eq_of_le

/-- An induction principle for closure membership. If `p` holds for `1` and all elements of `k`, and
is preserved under multiplication and inverse, then `p` holds for all elements of the closure
of `k`. -/
@[to_additive (attr := elab_as_elim)
      "An induction principle for additive closure membership. If `p`
      holds for `0` and all elements of `k`, and is preserved under addition and inverses, then `p`
      holds for all elements of the additive closure of `k`."]
theorem closure_induction {p : G ‚Üí Prop} {x} (h : x ‚àà closure k) (Hk : ‚àÄ x ‚àà k, p x) (H1 : p 1)
    (Hmul : ‚àÄ x y, p x ‚Üí p y ‚Üí p (x * y)) (Hinv : ‚àÄ x, p x ‚Üí p x‚Åª¬π) : p x :=
  (@closure_le _ _ ‚ü®‚ü®‚ü®setOf p, fun {x y} ‚Ü¶ Hmul x y‚ü©, H1‚ü©, fun {x} ‚Ü¶ Hinv x‚ü© k).2 Hk h
#align subgroup.closure_induction Subgroup.closure_induction
#align add_subgroup.closure_induction AddSubgroup.closure_induction

/-- A dependent version of `Subgroup.closure_induction`.  -/
@[to_additive (attr := elab_as_elim) "A dependent version of `AddSubgroup.closure_induction`. "]
theorem closure_induction' {p : ‚àÄ x, x ‚àà closure k ‚Üí Prop}
    (Hs : ‚àÄ (x) (h : x ‚àà k), p x (subset_closure h)) (H1 : p 1 (one_mem _))
    (Hmul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy))
    (Hinv : ‚àÄ x hx, p x hx ‚Üí p x‚Åª¬π (inv_mem hx)) {x} (hx : x ‚àà closure k) : p x hx := by
  refine' Exists.elim _ fun (hx : x ‚àà closure k) (hc : p x hx) => hc
  -- ‚ä¢ ‚àÉ x_1, p x x_1
  exact
    closure_induction hx (fun x hx => ‚ü®_, Hs x hx‚ü©) ‚ü®_, H1‚ü©
      (fun x y ‚ü®hx', hx‚ü© ‚ü®hy', hy‚ü© => ‚ü®_, Hmul _ _ _ _ hx hy‚ü©) fun x ‚ü®hx', hx‚ü© => ‚ü®_, Hinv _ _ hx‚ü©
#align subgroup.closure_induction' Subgroup.closure_induction'
#align add_subgroup.closure_induction' AddSubgroup.closure_induction'

/-- An induction principle for closure membership for predicates with two arguments. -/
@[to_additive (attr := elab_as_elim)
      "An induction principle for additive closure membership, for
      predicates with two arguments."]
theorem closure_induction‚ÇÇ {p : G ‚Üí G ‚Üí Prop} {x} {y : G} (hx : x ‚àà closure k) (hy : y ‚àà closure k)
    (Hk : ‚àÄ x ‚àà k, ‚àÄ y ‚àà k, p x y) (H1_left : ‚àÄ x, p 1 x) (H1_right : ‚àÄ x, p x 1)
    (Hmul_left : ‚àÄ x‚ÇÅ x‚ÇÇ y, p x‚ÇÅ y ‚Üí p x‚ÇÇ y ‚Üí p (x‚ÇÅ * x‚ÇÇ) y)
    (Hmul_right : ‚àÄ x y‚ÇÅ y‚ÇÇ, p x y‚ÇÅ ‚Üí p x y‚ÇÇ ‚Üí p x (y‚ÇÅ * y‚ÇÇ)) (Hinv_left : ‚àÄ x y, p x y ‚Üí p x‚Åª¬π y)
    (Hinv_right : ‚àÄ x y, p x y ‚Üí p x y‚Åª¬π) : p x y :=
  closure_induction hx
    (fun x xk => closure_induction hy (Hk x xk) (H1_right x) (Hmul_right x) (Hinv_right x))
    (H1_left y) (fun z z' => Hmul_left z z' y) fun z => Hinv_left z y
#align subgroup.closure_induction‚ÇÇ Subgroup.closure_induction‚ÇÇ
#align add_subgroup.closure_induction‚ÇÇ AddSubgroup.closure_induction‚ÇÇ

@[to_additive (attr := simp)]
theorem closure_closure_coe_preimage {k : Set G} : closure (((‚Üë) : closure k ‚Üí G) ‚Åª¬π' k) = ‚ä§ :=
  eq_top_iff.2 fun x =>
    Subtype.recOn x fun x hx _ => by
      refine' closure_induction' (fun g hg => _) _ (fun g‚ÇÅ g‚ÇÇ hg‚ÇÅ hg‚ÇÇ => _) (fun g hg => _) hx
      ¬∑ exact subset_closure hg
        -- üéâ no goals
      ¬∑ exact one_mem _
        -- üéâ no goals
      ¬∑ exact mul_mem
        -- üéâ no goals
      ¬∑ exact inv_mem
        -- üéâ no goals
#align subgroup.closure_closure_coe_preimage Subgroup.closure_closure_coe_preimage
#align add_subgroup.closure_closure_coe_preimage AddSubgroup.closure_closure_coe_preimage

/-- If all the elements of a set `s` commute, then `closure s` is a commutative group. -/
@[to_additive
      "If all the elements of a set `s` commute, then `closure s` is an additive
      commutative group."]
def closureCommGroupOfComm {k : Set G} (hcomm : ‚àÄ x ‚àà k, ‚àÄ y ‚àà k, x * y = y * x) :
    CommGroup (closure k) :=
  { (closure k).toGroup with
    mul_comm := fun x y => by
      ext
      -- ‚ä¢ ‚Üë(x * y) = ‚Üë(y * x)
      simp only [Subgroup.coe_mul]
      -- ‚ä¢ ‚Üëx * ‚Üëy = ‚Üëy * ‚Üëx
      refine'
        closure_induction‚ÇÇ x.prop y.prop hcomm (fun x => by simp only [mul_one, one_mul])
          (fun x => by simp only [mul_one, one_mul])
          (fun x y z h‚ÇÅ h‚ÇÇ => by rw [mul_assoc, h‚ÇÇ, ‚Üê mul_assoc, h‚ÇÅ, mul_assoc])
          (fun x y z h‚ÇÅ h‚ÇÇ => by rw [‚Üê mul_assoc, h‚ÇÅ, mul_assoc, h‚ÇÇ, ‚Üê mul_assoc])
          (fun x y h => by
            rw [inv_mul_eq_iff_eq_mul, ‚Üê mul_assoc, h, mul_assoc, mul_inv_self, mul_one])
          fun x y h => by
          rw [mul_inv_eq_iff_eq_mul, mul_assoc, h, ‚Üê mul_assoc, inv_mul_self, one_mul] }
#align subgroup.closure_comm_group_of_comm Subgroup.closureCommGroupOfComm
#align add_subgroup.closure_add_comm_group_of_comm AddSubgroup.closureAddCommGroupOfComm

variable (G)

/-- `closure` forms a Galois insertion with the coercion to set. -/
@[to_additive "`closure` forms a Galois insertion with the coercion to set."]
protected def gi : GaloisInsertion (@closure G _) (‚Üë)
    where
  choice s _ := closure s
  gc s t := @closure_le _ _ t s
  le_l_u _s := subset_closure
  choice_eq _s _h := rfl
#align subgroup.gi Subgroup.gi
#align add_subgroup.gi AddSubgroup.gi

variable {G}

/-- Subgroup closure of a set is monotone in its argument: if `h ‚äÜ k`,
then `closure h ‚â§ closure k`. -/
@[to_additive
      "Additive subgroup closure of a set is monotone in its argument: if `h ‚äÜ k`,
      then `closure h ‚â§ closure k`"]
theorem closure_mono ‚¶Éh k : Set G‚¶Ñ (h' : h ‚äÜ k) : closure h ‚â§ closure k :=
  (Subgroup.gi G).gc.monotone_l h'
#align subgroup.closure_mono Subgroup.closure_mono
#align add_subgroup.closure_mono AddSubgroup.closure_mono

/-- Closure of a subgroup `K` equals `K`. -/
@[to_additive (attr := simp) "Additive closure of an additive subgroup `K` equals `K`"]
theorem closure_eq : closure (K : Set G) = K :=
  (Subgroup.gi G).l_u_eq K
#align subgroup.closure_eq Subgroup.closure_eq
#align add_subgroup.closure_eq AddSubgroup.closure_eq

@[to_additive (attr := simp)]
theorem closure_empty : closure (‚àÖ : Set G) = ‚ä• :=
  (Subgroup.gi G).gc.l_bot
#align subgroup.closure_empty Subgroup.closure_empty
#align add_subgroup.closure_empty AddSubgroup.closure_empty

@[to_additive (attr := simp)]
theorem closure_univ : closure (univ : Set G) = ‚ä§ :=
  @coe_top G _ ‚ñ∏ closure_eq ‚ä§
#align subgroup.closure_univ Subgroup.closure_univ
#align add_subgroup.closure_univ AddSubgroup.closure_univ

@[to_additive]
theorem closure_union (s t : Set G) : closure (s ‚à™ t) = closure s ‚äî closure t :=
  (Subgroup.gi G).gc.l_sup
#align subgroup.closure_union Subgroup.closure_union
#align add_subgroup.closure_union AddSubgroup.closure_union

@[to_additive]
theorem closure_iUnion {Œπ} (s : Œπ ‚Üí Set G) : closure (‚ãÉ i, s i) = ‚®Ü i, closure (s i) :=
  (Subgroup.gi G).gc.l_iSup
#align subgroup.closure_Union Subgroup.closure_iUnion
#align add_subgroup.closure_Union AddSubgroup.closure_iUnion

@[to_additive]
theorem closure_eq_bot_iff (G : Type*) [Group G] (S : Set G) : closure S = ‚ä• ‚Üî S ‚äÜ {1} := by
  rw [‚Üê le_bot_iff]
  -- ‚ä¢ closure S ‚â§ ‚ä• ‚Üî S ‚äÜ {1}
  exact closure_le _
  -- üéâ no goals
#align subgroup.closure_eq_bot_iff Subgroup.closure_eq_bot_iff
#align add_subgroup.closure_eq_bot_iff AddSubgroup.closure_eq_bot_iff

@[to_additive]
theorem iSup_eq_closure {Œπ : Sort*} (p : Œπ ‚Üí Subgroup G) :
    ‚®Ü i, p i = closure (‚ãÉ i, (p i : Set G)) := by simp_rw [closure_iUnion, closure_eq]
                                                  -- üéâ no goals
#align subgroup.supr_eq_closure Subgroup.iSup_eq_closure
#align add_subgroup.supr_eq_closure AddSubgroup.iSup_eq_closure

/-- The subgroup generated by an element of a group equals the set of integer number powers of
    the element. -/
@[to_additive
      "The `AddSubgroup` generated by an element of an `AddGroup` equals the set of
      natural number multiples of the element."]
theorem mem_closure_singleton {x y : G} : y ‚àà closure ({x} : Set G) ‚Üî ‚àÉ n : ‚Ñ§, x ^ n = y := by
  refine'
    ‚ü®fun hy => closure_induction hy _ _ _ _, fun ‚ü®n, hn‚ü© =>
      hn ‚ñ∏ zpow_mem (subset_closure <| mem_singleton x) n‚ü©
  ¬∑ intro y hy
    -- ‚ä¢ ‚àÉ n, x ^ n = y
    rw [eq_of_mem_singleton hy]
    -- ‚ä¢ ‚àÉ n, x ^ n = x
    exact ‚ü®1, zpow_one x‚ü©
    -- üéâ no goals
  ¬∑ exact ‚ü®0, zpow_zero x‚ü©
    -- üéâ no goals
  ¬∑ rintro _ _ ‚ü®n, rfl‚ü© ‚ü®m, rfl‚ü©
    -- ‚ä¢ ‚àÉ n_1, x ^ n_1 = x ^ n * x ^ m
    exact ‚ü®n + m, zpow_add x n m‚ü©
    -- üéâ no goals
  rintro _ ‚ü®n, rfl‚ü©
  -- ‚ä¢ ‚àÉ n_1, x ^ n_1 = (x ^ n)‚Åª¬π
  exact ‚ü®-n, zpow_neg x n‚ü©
  -- üéâ no goals
#align subgroup.mem_closure_singleton Subgroup.mem_closure_singleton
#align add_subgroup.mem_closure_singleton AddSubgroup.mem_closure_singleton

@[to_additive]
theorem closure_singleton_one : closure ({1} : Set G) = ‚ä• := by
  simp [eq_bot_iff_forall, mem_closure_singleton]
  -- üéâ no goals
#align subgroup.closure_singleton_one Subgroup.closure_singleton_one
#align add_subgroup.closure_singleton_zero AddSubgroup.closure_singleton_zero

@[to_additive]
theorem le_closure_toSubmonoid (S : Set G) : Submonoid.closure S ‚â§ (closure S).toSubmonoid :=
  Submonoid.closure_le.2 subset_closure
#align subgroup.le_closure_to_submonoid Subgroup.le_closure_toSubmonoid
#align add_subgroup.le_closure_to_add_submonoid AddSubgroup.le_closure_toAddSubmonoid

@[to_additive]
theorem closure_eq_top_of_mclosure_eq_top {S : Set G} (h : Submonoid.closure S = ‚ä§) :
    closure S = ‚ä§ :=
  (eq_top_iff' _).2 fun _ => le_closure_toSubmonoid _ <| h.symm ‚ñ∏ trivial
#align subgroup.closure_eq_top_of_mclosure_eq_top Subgroup.closure_eq_top_of_mclosure_eq_top
#align add_subgroup.closure_eq_top_of_mclosure_eq_top AddSubgroup.closure_eq_top_of_mclosure_eq_top

@[to_additive]
theorem mem_iSup_of_directed {Œπ} [hŒπ : Nonempty Œπ] {K : Œπ ‚Üí Subgroup G} (hK : Directed (¬∑ ‚â§ ¬∑) K)
    {x : G} : x ‚àà (iSup K : Subgroup G) ‚Üî ‚àÉ i, x ‚àà K i := by
  refine' ‚ü®_, fun ‚ü®i, hi‚ü© => (SetLike.le_def.1 <| le_iSup K i) hi‚ü©
  -- ‚ä¢ x ‚àà iSup K ‚Üí ‚àÉ i, x ‚àà K i
  suffices x ‚àà closure (‚ãÉ i, (K i : Set G)) ‚Üí ‚àÉ i, x ‚àà K i by
    simpa only [closure_iUnion, closure_eq (K _)] using this
  refine' fun hx => closure_induction hx (fun _ => mem_iUnion.1) _ _ _
  ¬∑ exact hŒπ.elim fun i => ‚ü®i, (K i).one_mem‚ü©
    -- üéâ no goals
  ¬∑ rintro x y ‚ü®i, hi‚ü© ‚ü®j, hj‚ü©
    -- ‚ä¢ ‚àÉ i, x * y ‚àà K i
    rcases hK i j with ‚ü®k, hki, hkj‚ü©
    -- ‚ä¢ ‚àÉ i, x * y ‚àà K i
    exact ‚ü®k, mul_mem (hki hi) (hkj hj)‚ü©
    -- üéâ no goals
  rintro _ ‚ü®i, hi‚ü©
  -- ‚ä¢ ‚àÉ i, x‚úù‚Åª¬π ‚àà K i
  exact ‚ü®i, inv_mem hi‚ü©
  -- üéâ no goals
#align subgroup.mem_supr_of_directed Subgroup.mem_iSup_of_directed
#align add_subgroup.mem_supr_of_directed AddSubgroup.mem_iSup_of_directed

@[to_additive]
theorem coe_iSup_of_directed {Œπ} [Nonempty Œπ] {S : Œπ ‚Üí Subgroup G} (hS : Directed (¬∑ ‚â§ ¬∑) S) :
    ((‚®Ü i, S i : Subgroup G) : Set G) = ‚ãÉ i, ‚Üë(S i) :=
  Set.ext fun x => by simp [mem_iSup_of_directed hS]
                      -- üéâ no goals
#align subgroup.coe_supr_of_directed Subgroup.coe_iSup_of_directed
#align add_subgroup.coe_supr_of_directed AddSubgroup.coe_iSup_of_directed

@[to_additive]
theorem mem_sSup_of_directedOn {K : Set (Subgroup G)} (Kne : K.Nonempty) (hK : DirectedOn (¬∑ ‚â§ ¬∑) K)
    {x : G} : x ‚àà sSup K ‚Üî ‚àÉ s ‚àà K, x ‚àà s := by
  haveI : Nonempty K := Kne.to_subtype
  -- ‚ä¢ x ‚àà sSup K ‚Üî ‚àÉ s, s ‚àà K ‚àß x ‚àà s
  simp only [sSup_eq_iSup', mem_iSup_of_directed hK.directed_val, SetCoe.exists, Subtype.coe_mk,
    exists_prop]
#align subgroup.mem_Sup_of_directed_on Subgroup.mem_sSup_of_directedOn
#align add_subgroup.mem_Sup_of_directed_on AddSubgroup.mem_sSup_of_directedOn

variable {N : Type*} [Group N] {P : Type*} [Group P]

/-- The preimage of a subgroup along a monoid homomorphism is a subgroup. -/
@[to_additive
      "The preimage of an `AddSubgroup` along an `AddMonoid` homomorphism
      is an `AddSubgroup`."]
def comap {N : Type*} [Group N] (f : G ‚Üí* N) (H : Subgroup N) : Subgroup G :=
  { H.toSubmonoid.comap f with
    carrier := f ‚Åª¬π' H
    inv_mem' := fun {a} ha => show f a‚Åª¬π ‚àà H by rw [f.map_inv]; exact H.inv_mem ha }
                                                -- ‚ä¢ (‚Üëf a)‚Åª¬π ‚àà H
                                                                -- üéâ no goals
#align subgroup.comap Subgroup.comap
#align add_subgroup.comap AddSubgroup.comap

@[to_additive (attr := simp)]
theorem coe_comap (K : Subgroup N) (f : G ‚Üí* N) : (K.comap f : Set G) = f ‚Åª¬π' K :=
  rfl
#align subgroup.coe_comap Subgroup.coe_comap
#align add_subgroup.coe_comap AddSubgroup.coe_comap

@[to_additive (attr := simp)]
theorem mem_comap {K : Subgroup N} {f : G ‚Üí* N} {x : G} : x ‚àà K.comap f ‚Üî f x ‚àà K :=
  Iff.rfl
#align subgroup.mem_comap Subgroup.mem_comap
#align add_subgroup.mem_comap AddSubgroup.mem_comap

@[to_additive]
theorem comap_mono {f : G ‚Üí* N} {K K' : Subgroup N} : K ‚â§ K' ‚Üí comap f K ‚â§ comap f K' :=
  preimage_mono
#align subgroup.comap_mono Subgroup.comap_mono
#align add_subgroup.comap_mono AddSubgroup.comap_mono

@[to_additive]
theorem comap_comap (K : Subgroup P) (g : N ‚Üí* P) (f : G ‚Üí* N) :
    (K.comap g).comap f = K.comap (g.comp f) :=
  rfl
#align subgroup.comap_comap Subgroup.comap_comap
#align add_subgroup.comap_comap AddSubgroup.comap_comap

@[to_additive (attr := simp)]
theorem comap_id (K : Subgroup N) : K.comap (MonoidHom.id _) = K := by
  ext
  -- ‚ä¢ x‚úù ‚àà comap (MonoidHom.id N) K ‚Üî x‚úù ‚àà K
  rfl
  -- üéâ no goals
#align subgroup.comap_id Subgroup.comap_id
#align add_subgroup.comap_id AddSubgroup.comap_id

/-- The image of a subgroup along a monoid homomorphism is a subgroup. -/
@[to_additive
      "The image of an `AddSubgroup` along an `AddMonoid` homomorphism
      is an `AddSubgroup`."]
def map (f : G ‚Üí* N) (H : Subgroup G) : Subgroup N :=
  { H.toSubmonoid.map f with
    carrier := f '' H
    inv_mem' := by
      rintro _ ‚ü®x, hx, rfl‚ü©
      -- ‚ä¢ (‚Üëf x)‚Åª¬π ‚àà { toSubsemigroup := { carrier := ‚Üëf '' ‚ÜëH, mul_mem' := (_ : ‚àÄ {a  ‚Ä¶
      exact ‚ü®x‚Åª¬π, H.inv_mem hx, f.map_inv x‚ü© }
      -- üéâ no goals
#align subgroup.map Subgroup.map
#align add_subgroup.map AddSubgroup.map

@[to_additive (attr := simp)]
theorem coe_map (f : G ‚Üí* N) (K : Subgroup G) : (K.map f : Set N) = f '' K :=
  rfl
#align subgroup.coe_map Subgroup.coe_map
#align add_subgroup.coe_map AddSubgroup.coe_map

@[to_additive (attr := simp)]
theorem mem_map {f : G ‚Üí* N} {K : Subgroup G} {y : N} : y ‚àà K.map f ‚Üî ‚àÉ x ‚àà K, f x = y := by
  erw [mem_image_iff_bex]; simp
  -- ‚ä¢ (‚àÉ x x_1, ‚Üëf x = y) ‚Üî ‚àÉ x, x ‚àà K ‚àß ‚Üëf x = y
                           -- üéâ no goals
#align subgroup.mem_map Subgroup.mem_map
#align add_subgroup.mem_map AddSubgroup.mem_map

@[to_additive]
theorem mem_map_of_mem (f : G ‚Üí* N) {K : Subgroup G} {x : G} (hx : x ‚àà K) : f x ‚àà K.map f :=
  mem_image_of_mem f hx
#align subgroup.mem_map_of_mem Subgroup.mem_map_of_mem
#align add_subgroup.mem_map_of_mem AddSubgroup.mem_map_of_mem

@[to_additive]
theorem apply_coe_mem_map (f : G ‚Üí* N) (K : Subgroup G) (x : K) : f x ‚àà K.map f :=
  mem_map_of_mem f x.prop
#align subgroup.apply_coe_mem_map Subgroup.apply_coe_mem_map
#align add_subgroup.apply_coe_mem_map AddSubgroup.apply_coe_mem_map

@[to_additive]
theorem map_mono {f : G ‚Üí* N} {K K' : Subgroup G} : K ‚â§ K' ‚Üí map f K ‚â§ map f K' :=
  image_subset _
#align subgroup.map_mono Subgroup.map_mono
#align add_subgroup.map_mono AddSubgroup.map_mono

@[to_additive (attr := simp)]
theorem map_id : K.map (MonoidHom.id G) = K :=
  SetLike.coe_injective <| image_id _
#align subgroup.map_id Subgroup.map_id
#align add_subgroup.map_id AddSubgroup.map_id

@[to_additive]
theorem map_map (g : N ‚Üí* P) (f : G ‚Üí* N) : (K.map f).map g = K.map (g.comp f) :=
  SetLike.coe_injective <| image_image _ _ _
#align subgroup.map_map Subgroup.map_map
#align add_subgroup.map_map AddSubgroup.map_map

@[to_additive (attr := simp)]
theorem map_one_eq_bot : K.map (1 : G ‚Üí* N) = ‚ä• :=
  eq_bot_iff.mpr <| by
    rintro x ‚ü®y, _, rfl‚ü©
    -- ‚ä¢ ‚Üë1 y ‚àà ‚ä•
    simp
    -- üéâ no goals
#align subgroup.map_one_eq_bot Subgroup.map_one_eq_bot
#align add_subgroup.map_zero_eq_bot AddSubgroup.map_zero_eq_bot

@[to_additive]
theorem mem_map_equiv {f : G ‚âÉ* N} {K : Subgroup G} {x : N} :
    x ‚àà K.map f.toMonoidHom ‚Üî f.symm x ‚àà K := by
  erw [@Set.mem_image_equiv _ _ (‚ÜëK) f.toEquiv x]; rfl
  -- ‚ä¢ ‚Üëf.symm x ‚àà ‚ÜëK ‚Üî ‚Üë(MulEquiv.symm f) x ‚àà K
                                                   -- üéâ no goals
#align subgroup.mem_map_equiv Subgroup.mem_map_equiv
#align add_subgroup.mem_map_equiv AddSubgroup.mem_map_equiv

-- The simpNF linter says that the LHS can be simplified via `Subgroup.mem_map`.
-- However this is a higher priority lemma.
-- https://github.com/leanprover/std4/issues/207
@[to_additive (attr := simp 1100, nolint simpNF)]
theorem mem_map_iff_mem {f : G ‚Üí* N} (hf : Function.Injective f) {K : Subgroup G} {x : G} :
    f x ‚àà K.map f ‚Üî x ‚àà K :=
  hf.mem_set_image
#align subgroup.mem_map_iff_mem Subgroup.mem_map_iff_mem
#align add_subgroup.mem_map_iff_mem AddSubgroup.mem_map_iff_mem

@[to_additive]
theorem map_equiv_eq_comap_symm (f : G ‚âÉ* N) (K : Subgroup G) :
    K.map f.toMonoidHom = K.comap f.symm.toMonoidHom :=
  SetLike.coe_injective (f.toEquiv.image_eq_preimage K)
#align subgroup.map_equiv_eq_comap_symm Subgroup.map_equiv_eq_comap_symm
#align add_subgroup.map_equiv_eq_comap_symm AddSubgroup.map_equiv_eq_comap_symm

@[to_additive]
theorem comap_equiv_eq_map_symm (f : N ‚âÉ* G) (K : Subgroup G) :
    K.comap f.toMonoidHom = K.map f.symm.toMonoidHom :=
  (map_equiv_eq_comap_symm f.symm K).symm
#align subgroup.comap_equiv_eq_map_symm Subgroup.comap_equiv_eq_map_symm
#align add_subgroup.comap_equiv_eq_map_symm AddSubgroup.comap_equiv_eq_map_symm

@[to_additive]
theorem map_symm_eq_iff_map_eq {H : Subgroup N} {e : G ‚âÉ* N} :
    H.map ‚Üëe.symm = K ‚Üî K.map ‚Üëe = H := by
  constructor <;> rintro rfl
  -- ‚ä¢ map (‚Üë(MulEquiv.symm e)) H = K ‚Üí map (‚Üëe) K = H
                  -- ‚ä¢ map (‚Üëe) (map (‚Üë(MulEquiv.symm e)) H) = H
                  -- ‚ä¢ map (‚Üë(MulEquiv.symm e)) (map (‚Üëe) K) = K
  ¬∑ rw [map_map, ‚Üê MulEquiv.coe_monoidHom_trans, MulEquiv.symm_trans_self,
      MulEquiv.coe_monoidHom_refl, map_id]
  ¬∑ rw [map_map, ‚Üê MulEquiv.coe_monoidHom_trans, MulEquiv.self_trans_symm,
      MulEquiv.coe_monoidHom_refl, map_id]
#align subgroup.map_symm_eq_iff_map_eq Subgroup.map_symm_eq_iff_map_eq
#align add_subgroup.map_symm_eq_iff_map_eq AddSubgroup.map_symm_eq_iff_map_eq

@[to_additive]
theorem map_le_iff_le_comap {f : G ‚Üí* N} {K : Subgroup G} {H : Subgroup N} :
    K.map f ‚â§ H ‚Üî K ‚â§ H.comap f :=
  image_subset_iff
#align subgroup.map_le_iff_le_comap Subgroup.map_le_iff_le_comap
#align add_subgroup.map_le_iff_le_comap AddSubgroup.map_le_iff_le_comap

@[to_additive]
theorem gc_map_comap (f : G ‚Üí* N) : GaloisConnection (map f) (comap f) := fun _ _ =>
  map_le_iff_le_comap
#align subgroup.gc_map_comap Subgroup.gc_map_comap
#align add_subgroup.gc_map_comap AddSubgroup.gc_map_comap

@[to_additive]
theorem map_sup (H K : Subgroup G) (f : G ‚Üí* N) : (H ‚äî K).map f = H.map f ‚äî K.map f :=
  (gc_map_comap f).l_sup
#align subgroup.map_sup Subgroup.map_sup
#align add_subgroup.map_sup AddSubgroup.map_sup

@[to_additive]
theorem map_iSup {Œπ : Sort*} (f : G ‚Üí* N) (s : Œπ ‚Üí Subgroup G) :
    (iSup s).map f = ‚®Ü i, (s i).map f :=
  (gc_map_comap f).l_iSup
#align subgroup.map_supr Subgroup.map_iSup
#align add_subgroup.map_supr AddSubgroup.map_iSup

@[to_additive]
theorem comap_sup_comap_le (H K : Subgroup N) (f : G ‚Üí* N) :
    comap f H ‚äî comap f K ‚â§ comap f (H ‚äî K) :=
  Monotone.le_map_sup (fun _ _ => comap_mono) H K
#align subgroup.comap_sup_comap_le Subgroup.comap_sup_comap_le
#align add_subgroup.comap_sup_comap_le AddSubgroup.comap_sup_comap_le

@[to_additive]
theorem iSup_comap_le {Œπ : Sort*} (f : G ‚Üí* N) (s : Œπ ‚Üí Subgroup N) :
    ‚®Ü i, (s i).comap f ‚â§ (iSup s).comap f :=
  Monotone.le_map_iSup fun _ _ => comap_mono
#align subgroup.supr_comap_le Subgroup.iSup_comap_le
#align add_subgroup.supr_comap_le AddSubgroup.iSup_comap_le

@[to_additive]
theorem comap_inf (H K : Subgroup N) (f : G ‚Üí* N) : (H ‚äì K).comap f = H.comap f ‚äì K.comap f :=
  (gc_map_comap f).u_inf
#align subgroup.comap_inf Subgroup.comap_inf
#align add_subgroup.comap_inf AddSubgroup.comap_inf

@[to_additive]
theorem comap_iInf {Œπ : Sort*} (f : G ‚Üí* N) (s : Œπ ‚Üí Subgroup N) :
    (iInf s).comap f = ‚®Ö i, (s i).comap f :=
  (gc_map_comap f).u_iInf
#align subgroup.comap_infi Subgroup.comap_iInf
#align add_subgroup.comap_infi AddSubgroup.comap_iInf

@[to_additive]
theorem map_inf_le (H K : Subgroup G) (f : G ‚Üí* N) : map f (H ‚äì K) ‚â§ map f H ‚äì map f K :=
  le_inf (map_mono inf_le_left) (map_mono inf_le_right)
#align subgroup.map_inf_le Subgroup.map_inf_le
#align add_subgroup.map_inf_le AddSubgroup.map_inf_le

@[to_additive]
theorem map_inf_eq (H K : Subgroup G) (f : G ‚Üí* N) (hf : Function.Injective f) :
    map f (H ‚äì K) = map f H ‚äì map f K := by
  rw [‚Üê SetLike.coe_set_eq]
  -- ‚ä¢ ‚Üë(map f (H ‚äì K)) = ‚Üë(map f H ‚äì map f K)
  simp [Set.image_inter hf]
  -- üéâ no goals
#align subgroup.map_inf_eq Subgroup.map_inf_eq
#align add_subgroup.map_inf_eq AddSubgroup.map_inf_eq

@[to_additive (attr := simp)]
theorem map_bot (f : G ‚Üí* N) : (‚ä• : Subgroup G).map f = ‚ä• :=
  (gc_map_comap f).l_bot
#align subgroup.map_bot Subgroup.map_bot
#align add_subgroup.map_bot AddSubgroup.map_bot

@[to_additive (attr := simp)]
theorem map_top_of_surjective (f : G ‚Üí* N) (h : Function.Surjective f) : Subgroup.map f ‚ä§ = ‚ä§ := by
  rw [eq_top_iff]
  -- ‚ä¢ ‚ä§ ‚â§ map f ‚ä§
  intro x _
  -- ‚ä¢ x ‚àà map f ‚ä§
  obtain ‚ü®y, hy‚ü© := h x
  -- ‚ä¢ x ‚àà map f ‚ä§
  exact ‚ü®y, trivial, hy‚ü©
  -- üéâ no goals
#align subgroup.map_top_of_surjective Subgroup.map_top_of_surjective
#align add_subgroup.map_top_of_surjective AddSubgroup.map_top_of_surjective

@[to_additive (attr := simp)]
theorem comap_top (f : G ‚Üí* N) : (‚ä§ : Subgroup N).comap f = ‚ä§ :=
  (gc_map_comap f).u_top
#align subgroup.comap_top Subgroup.comap_top
#align add_subgroup.comap_top AddSubgroup.comap_top

/-- For any subgroups `H` and `K`, view `H ‚äì K` as a subgroup of `K`. -/
@[to_additive "For any subgroups `H` and `K`, view `H ‚äì K` as a subgroup of `K`."]
def subgroupOf (H K : Subgroup G) : Subgroup K :=
  H.comap K.subtype
#align subgroup.subgroup_of Subgroup.subgroupOf
#align add_subgroup.add_subgroup_of AddSubgroup.addSubgroupOf

/-- If `H ‚â§ K`, then `H` as a subgroup of `K` is isomorphic to `H`. -/
@[to_additive (attr := simps) "If `H ‚â§ K`, then `H` as a subgroup of `K` is isomorphic to `H`."]
def subgroupOfEquivOfLe {G : Type*} [Group G] {H K : Subgroup G} (h : H ‚â§ K) :
    H.subgroupOf K ‚âÉ* H where
  toFun g := ‚ü®g.1, g.2‚ü©
  invFun g := ‚ü®‚ü®g.1, h g.2‚ü©, g.2‚ü©
  left_inv _g := Subtype.ext (Subtype.ext rfl)
  right_inv _g := Subtype.ext rfl
  map_mul' _g _h := rfl
#align subgroup.subgroup_of_equiv_of_le Subgroup.subgroupOfEquivOfLe
#align add_subgroup.add_subgroup_of_equiv_of_le AddSubgroup.addSubgroupOfEquivOfLe
#align subgroup.subgroup_of_equiv_of_le_symm_apply_coe_coe Subgroup.subgroupOfEquivOfLe_symm_apply_coe_coe
#align add_subgroup.subgroup_of_equiv_of_le_symm_apply_coe_coe AddSubgroup.addSubgroupOfEquivOfLe_symm_apply_coe_coe
#align subgroup.subgroup_of_equiv_of_le_apply_coe Subgroup.subgroupOfEquivOfLe_apply_coe
#align add_subgroup.subgroup_of_equiv_of_le_apply_coe AddSubgroup.addSubgroupOfEquivOfLe_apply_coe

@[to_additive (attr := simp)]
theorem comap_subtype (H K : Subgroup G) : H.comap K.subtype = H.subgroupOf K :=
  rfl
#align subgroup.comap_subtype Subgroup.comap_subtype
#align add_subgroup.comap_subtype AddSubgroup.comap_subtype

@[to_additive (attr := simp)]
theorem comap_inclusion_subgroupOf {K‚ÇÅ K‚ÇÇ : Subgroup G} (h : K‚ÇÅ ‚â§ K‚ÇÇ) (H : Subgroup G) :
    (H.subgroupOf K‚ÇÇ).comap (inclusion h) = H.subgroupOf K‚ÇÅ :=
  rfl
#align subgroup.comap_inclusion_subgroup_of Subgroup.comap_inclusion_subgroupOf
#align add_subgroup.comap_inclusion_add_subgroup_of AddSubgroup.comap_inclusion_addSubgroupOf

@[to_additive]
theorem coe_subgroupOf (H K : Subgroup G) : (H.subgroupOf K : Set K) = K.subtype ‚Åª¬π' H :=
  rfl
#align subgroup.coe_subgroup_of Subgroup.coe_subgroupOf
#align add_subgroup.coe_add_subgroup_of AddSubgroup.coe_addSubgroupOf

@[to_additive]
theorem mem_subgroupOf {H K : Subgroup G} {h : K} : h ‚àà H.subgroupOf K ‚Üî (h : G) ‚àà H :=
  Iff.rfl
#align subgroup.mem_subgroup_of Subgroup.mem_subgroupOf
#align add_subgroup.mem_add_subgroup_of AddSubgroup.mem_addSubgroupOf

@[to_additive (attr := simp)]
theorem subgroupOf_map_subtype (H K : Subgroup G) : (H.subgroupOf K).map K.subtype = H ‚äì K :=
  SetLike.ext' <| Subtype.image_preimage_coe _ _
#align subgroup.subgroup_of_map_subtype Subgroup.subgroupOf_map_subtype
#align add_subgroup.add_subgroup_of_map_subtype AddSubgroup.addSubgroupOf_map_subtype

@[to_additive (attr := simp)]
theorem bot_subgroupOf : (‚ä• : Subgroup G).subgroupOf H = ‚ä• :=
  Eq.symm (Subgroup.ext fun _g => Subtype.ext_iff)
#align subgroup.bot_subgroup_of Subgroup.bot_subgroupOf
#align add_subgroup.bot_add_subgroup_of AddSubgroup.bot_addSubgroupOf

@[to_additive (attr := simp)]
theorem top_subgroupOf : (‚ä§ : Subgroup G).subgroupOf H = ‚ä§ :=
  rfl
#align subgroup.top_subgroup_of Subgroup.top_subgroupOf
#align add_subgroup.top_add_subgroup_of AddSubgroup.top_addSubgroupOf

@[to_additive]
theorem subgroupOf_bot_eq_bot : H.subgroupOf ‚ä• = ‚ä• :=
  Subsingleton.elim _ _
#align subgroup.subgroup_of_bot_eq_bot Subgroup.subgroupOf_bot_eq_bot
#align add_subgroup.add_subgroup_of_bot_eq_bot AddSubgroup.addSubgroupOf_bot_eq_bot

@[to_additive]
theorem subgroupOf_bot_eq_top : H.subgroupOf ‚ä• = ‚ä§ :=
  Subsingleton.elim _ _
#align subgroup.subgroup_of_bot_eq_top Subgroup.subgroupOf_bot_eq_top
#align add_subgroup.add_subgroup_of_bot_eq_top AddSubgroup.addSubgroupOf_bot_eq_top

@[to_additive (attr := simp)]
theorem subgroupOf_self : H.subgroupOf H = ‚ä§ :=
  top_unique fun g _hg => g.2
#align subgroup.subgroup_of_self Subgroup.subgroupOf_self
#align add_subgroup.add_subgroup_of_self AddSubgroup.addSubgroupOf_self

@[to_additive (attr := simp)]
theorem subgroupOf_inj {H‚ÇÅ H‚ÇÇ K : Subgroup G} :
    H‚ÇÅ.subgroupOf K = H‚ÇÇ.subgroupOf K ‚Üî H‚ÇÅ ‚äì K = H‚ÇÇ ‚äì K := by
  simpa only [SetLike.ext_iff, mem_inf, mem_subgroupOf, and_congr_left_iff] using Subtype.forall
  -- üéâ no goals
#align subgroup.subgroup_of_inj Subgroup.subgroupOf_inj
#align add_subgroup.add_subgroup_of_inj AddSubgroup.addSubgroupOf_inj

@[to_additive (attr := simp)]
theorem inf_subgroupOf_right (H K : Subgroup G) : (H ‚äì K).subgroupOf K = H.subgroupOf K :=
  subgroupOf_inj.2 inf_right_idem
#align subgroup.inf_subgroup_of_right Subgroup.inf_subgroupOf_right
#align add_subgroup.inf_add_subgroup_of_right AddSubgroup.inf_addSubgroupOf_right

@[to_additive (attr := simp)]
theorem inf_subgroupOf_left (H K : Subgroup G) : (K ‚äì H).subgroupOf K = H.subgroupOf K := by
  rw [inf_comm, inf_subgroupOf_right]
  -- üéâ no goals
#align subgroup.inf_subgroup_of_left Subgroup.inf_subgroupOf_left
#align add_subgroup.inf_add_subgroup_of_left AddSubgroup.inf_addSubgroupOf_left

@[to_additive (attr := simp)]
theorem subgroupOf_eq_bot {H K : Subgroup G} : H.subgroupOf K = ‚ä• ‚Üî Disjoint H K := by
  rw [disjoint_iff, ‚Üê bot_subgroupOf, subgroupOf_inj, bot_inf_eq]
  -- üéâ no goals
#align subgroup.subgroup_of_eq_bot Subgroup.subgroupOf_eq_bot
#align add_subgroup.add_subgroup_of_eq_bot AddSubgroup.addSubgroupOf_eq_bot

@[to_additive (attr := simp)]
theorem subgroupOf_eq_top {H K : Subgroup G} : H.subgroupOf K = ‚ä§ ‚Üî K ‚â§ H := by
  rw [‚Üê top_subgroupOf, subgroupOf_inj, top_inf_eq, inf_eq_right]
  -- üéâ no goals
#align subgroup.subgroup_of_eq_top Subgroup.subgroupOf_eq_top
#align add_subgroup.add_subgroup_of_eq_top AddSubgroup.addSubgroupOf_eq_top

/-- Given `Subgroup`s `H`, `K` of groups `G`, `N` respectively, `H √ó K` as a subgroup of `G √ó N`. -/
@[to_additive prod
      "Given `AddSubgroup`s `H`, `K` of `AddGroup`s `A`, `B` respectively, `H √ó K`
      as an `AddSubgroup` of `A √ó B`."]
def prod (H : Subgroup G) (K : Subgroup N) : Subgroup (G √ó N) :=
  { Submonoid.prod H.toSubmonoid K.toSubmonoid with
    inv_mem' := fun hx => ‚ü®H.inv_mem' hx.1, K.inv_mem' hx.2‚ü© }
#align subgroup.prod Subgroup.prod
#align add_subgroup.prod AddSubgroup.prod

@[to_additive coe_prod]
theorem coe_prod (H : Subgroup G) (K : Subgroup N) :
    (H.prod K : Set (G √ó N)) = (H : Set G) √óÀ¢ (K : Set N) :=
  rfl
#align subgroup.coe_prod Subgroup.coe_prod
#align add_subgroup.coe_prod AddSubgroup.coe_prod

@[to_additive mem_prod]
theorem mem_prod {H : Subgroup G} {K : Subgroup N} {p : G √ó N} : p ‚àà H.prod K ‚Üî p.1 ‚àà H ‚àß p.2 ‚àà K :=
  Iff.rfl
#align subgroup.mem_prod Subgroup.mem_prod
#align add_subgroup.mem_prod AddSubgroup.mem_prod

@[to_additive prod_mono]
theorem prod_mono : ((¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑)) (@prod G _ N _) (@prod G _ N _) :=
  fun _s _s' hs _t _t' ht => Set.prod_mono hs ht
#align subgroup.prod_mono Subgroup.prod_mono
#align add_subgroup.prod_mono AddSubgroup.prod_mono

@[to_additive prod_mono_right]
theorem prod_mono_right (K : Subgroup G) : Monotone fun t : Subgroup N => K.prod t :=
  prod_mono (le_refl K)
#align subgroup.prod_mono_right Subgroup.prod_mono_right
#align add_subgroup.prod_mono_right AddSubgroup.prod_mono_right

@[to_additive prod_mono_left]
theorem prod_mono_left (H : Subgroup N) : Monotone fun K : Subgroup G => K.prod H := fun _ _ hs =>
  prod_mono hs (le_refl H)
#align subgroup.prod_mono_left Subgroup.prod_mono_left
#align add_subgroup.prod_mono_left AddSubgroup.prod_mono_left

@[to_additive prod_top]
theorem prod_top (K : Subgroup G) : K.prod (‚ä§ : Subgroup N) = K.comap (MonoidHom.fst G N) :=
  ext fun x => by simp [mem_prod, MonoidHom.coe_fst]
                  -- üéâ no goals
#align subgroup.prod_top Subgroup.prod_top
#align add_subgroup.prod_top AddSubgroup.prod_top

@[to_additive top_prod]
theorem top_prod (H : Subgroup N) : (‚ä§ : Subgroup G).prod H = H.comap (MonoidHom.snd G N) :=
  ext fun x => by simp [mem_prod, MonoidHom.coe_snd]
                  -- üéâ no goals
#align subgroup.top_prod Subgroup.top_prod
#align add_subgroup.top_prod AddSubgroup.top_prod

@[to_additive (attr := simp) top_prod_top]
theorem top_prod_top : (‚ä§ : Subgroup G).prod (‚ä§ : Subgroup N) = ‚ä§ :=
  (top_prod _).trans <| comap_top _
#align subgroup.top_prod_top Subgroup.top_prod_top
#align add_subgroup.top_prod_top AddSubgroup.top_prod_top

@[to_additive]
theorem bot_prod_bot : (‚ä• : Subgroup G).prod (‚ä• : Subgroup N) = ‚ä• :=
  SetLike.coe_injective <| by simp [coe_prod, Prod.one_eq_mk]
                              -- üéâ no goals
#align subgroup.bot_prod_bot Subgroup.bot_prod_bot
#align add_subgroup.bot_sum_bot AddSubgroup.bot_sum_bot

@[to_additive le_prod_iff]
theorem le_prod_iff {H : Subgroup G} {K : Subgroup N} {J : Subgroup (G √ó N)} :
    J ‚â§ H.prod K ‚Üî map (MonoidHom.fst G N) J ‚â§ H ‚àß map (MonoidHom.snd G N) J ‚â§ K := by
  simpa only [‚Üê Subgroup.toSubmonoid_le] using Submonoid.le_prod_iff
  -- üéâ no goals
#align subgroup.le_prod_iff Subgroup.le_prod_iff
#align add_subgroup.le_prod_iff AddSubgroup.le_prod_iff

@[to_additive prod_le_iff]
theorem prod_le_iff {H : Subgroup G} {K : Subgroup N} {J : Subgroup (G √ó N)} :
    H.prod K ‚â§ J ‚Üî map (MonoidHom.inl G N) H ‚â§ J ‚àß map (MonoidHom.inr G N) K ‚â§ J := by
  simpa only [‚Üê Subgroup.toSubmonoid_le] using Submonoid.prod_le_iff
  -- üéâ no goals
#align subgroup.prod_le_iff Subgroup.prod_le_iff
#align add_subgroup.prod_le_iff AddSubgroup.prod_le_iff

@[to_additive (attr := simp) prod_eq_bot_iff]
theorem prod_eq_bot_iff {H : Subgroup G} {K : Subgroup N} : H.prod K = ‚ä• ‚Üî H = ‚ä• ‚àß K = ‚ä• := by
  simpa only [‚Üê Subgroup.toSubmonoid_eq] using Submonoid.prod_eq_bot_iff
  -- üéâ no goals
#align subgroup.prod_eq_bot_iff Subgroup.prod_eq_bot_iff
#align add_subgroup.prod_eq_bot_iff AddSubgroup.prod_eq_bot_iff

/-- Product of subgroups is isomorphic to their product as groups. -/
@[to_additive prodEquiv
      "Product of additive subgroups is isomorphic to their product
      as additive groups"]
def prodEquiv (H : Subgroup G) (K : Subgroup N) : H.prod K ‚âÉ* H √ó K :=
  { Equiv.Set.prod (H : Set G) (K : Set N) with map_mul' := fun _ _ => rfl }
#align subgroup.prod_equiv Subgroup.prodEquiv
#align add_subgroup.prod_equiv AddSubgroup.prodEquiv

section Pi

variable {Œ∑ : Type*} {f : Œ∑ ‚Üí Type*}

-- defined here and not in GroupTheory.Submonoid.Operations to have access to Algebra.Group.Pi
/-- A version of `Set.pi` for submonoids. Given an index set `I` and a family of submodules
`s : Œ† i, Submonoid f i`, `pi I s` is the submonoid of dependent functions `f : Œ† i, f i` such that
`f i` belongs to `Pi I s` whenever `i ‚àà I`. -/
@[to_additive " A version of `Set.pi` for `AddSubmonoid`s. Given an index set `I` and a family
  of submodules `s : Œ† i, AddSubmonoid f i`, `pi I s` is the `AddSubmonoid` of dependent functions
  `f : Œ† i, f i` such that `f i` belongs to `pi I s` whenever `i ‚àà I`. -/ "]
def _root_.Submonoid.pi [‚àÄ i, MulOneClass (f i)] (I : Set Œ∑) (s : ‚àÄ i, Submonoid (f i)) :
    Submonoid (‚àÄ i, f i) where
  carrier := I.pi fun i => (s i).carrier
  one_mem' i _ := (s i).one_mem
  mul_mem' hp hq i hI := (s i).mul_mem (hp i hI) (hq i hI)
#align submonoid.pi Submonoid.pi
#align add_submonoid.pi AddSubmonoid.pi

variable [‚àÄ i, Group (f i)]

/-- A version of `Set.pi` for subgroups. Given an index set `I` and a family of submodules
`s : Œ† i, Subgroup f i`, `pi I s` is the subgroup of dependent functions `f : Œ† i, f i` such that
`f i` belongs to `pi I s` whenever `i ‚àà I`. -/
@[to_additive
      " A version of `Set.pi` for `AddSubgroup`s. Given an index set `I` and a family
      of submodules `s : Œ† i, AddSubgroup f i`, `pi I s` is the `AddSubgroup` of dependent functions
      `f : Œ† i, f i` such that `f i` belongs to `pi I s` whenever `i ‚àà I`. -/ "]
def pi (I : Set Œ∑) (H : ‚àÄ i, Subgroup (f i)) : Subgroup (‚àÄ i, f i) :=
  { Submonoid.pi I fun i => (H i).toSubmonoid with
    inv_mem' := fun hp i hI => (H i).inv_mem (hp i hI) }
#align subgroup.pi Subgroup.pi
#align add_subgroup.pi AddSubgroup.pi

@[to_additive]
theorem coe_pi (I : Set Œ∑) (H : ‚àÄ i, Subgroup (f i)) :
    (pi I H : Set (‚àÄ i, f i)) = Set.pi I fun i => (H i : Set (f i)) :=
  rfl
#align subgroup.coe_pi Subgroup.coe_pi
#align add_subgroup.coe_pi AddSubgroup.coe_pi

@[to_additive]
theorem mem_pi (I : Set Œ∑) {H : ‚àÄ i, Subgroup (f i)} {p : ‚àÄ i, f i} :
    p ‚àà pi I H ‚Üî ‚àÄ i : Œ∑, i ‚àà I ‚Üí p i ‚àà H i :=
  Iff.rfl
#align subgroup.mem_pi Subgroup.mem_pi
#align add_subgroup.mem_pi AddSubgroup.mem_pi

@[to_additive]
theorem pi_top (I : Set Œ∑) : (pi I fun i => (‚ä§ : Subgroup (f i))) = ‚ä§ :=
  ext fun x => by simp [mem_pi]
                  -- üéâ no goals
#align subgroup.pi_top Subgroup.pi_top
#align add_subgroup.pi_top AddSubgroup.pi_top

@[to_additive]
theorem pi_empty (H : ‚àÄ i, Subgroup (f i)) : pi ‚àÖ H = ‚ä§ :=
  ext fun x => by simp [mem_pi]
                  -- üéâ no goals
#align subgroup.pi_empty Subgroup.pi_empty
#align add_subgroup.pi_empty AddSubgroup.pi_empty

@[to_additive]
theorem pi_bot : (pi Set.univ fun i => (‚ä• : Subgroup (f i))) = ‚ä• :=
  (eq_bot_iff_forall _).mpr fun p hp => by
    simp only [mem_pi, mem_bot] at *
    -- ‚ä¢ p = 1
    ext j
    -- ‚ä¢ p j = OfNat.ofNat 1 j
    exact hp j trivial
    -- üéâ no goals
#align subgroup.pi_bot Subgroup.pi_bot
#align add_subgroup.pi_bot AddSubgroup.pi_bot

@[to_additive]
theorem le_pi_iff {I : Set Œ∑} {H : ‚àÄ i, Subgroup (f i)} {J : Subgroup (‚àÄ i, f i)} :
    J ‚â§ pi I H ‚Üî ‚àÄ i : Œ∑, i ‚àà I ‚Üí map (Pi.evalMonoidHom f i) J ‚â§ H i := by
  constructor
  -- ‚ä¢ J ‚â§ pi I H ‚Üí ‚àÄ (i : Œ∑), i ‚àà I ‚Üí map (Pi.evalMonoidHom f i) J ‚â§ H i
  ¬∑ intro h i hi
    -- ‚ä¢ map (Pi.evalMonoidHom f i) J ‚â§ H i
    rintro _ ‚ü®x, hx, rfl‚ü©
    -- ‚ä¢ ‚Üë(Pi.evalMonoidHom f i) x ‚àà H i
    exact (h hx) _ hi
    -- üéâ no goals
  ¬∑ intro h x hx i hi
    -- ‚ä¢ x i ‚àà (fun i => ((fun i => (H i).toSubmonoid) i).carrier) i
    refine' h i hi ‚ü®_, hx, rfl‚ü©
    -- üéâ no goals
#align subgroup.le_pi_iff Subgroup.le_pi_iff
#align add_subgroup.le_pi_iff AddSubgroup.le_pi_iff

@[to_additive (attr := simp)]
theorem mulSingle_mem_pi [DecidableEq Œ∑] {I : Set Œ∑} {H : ‚àÄ i, Subgroup (f i)} (i : Œ∑) (x : f i) :
    Pi.mulSingle i x ‚àà pi I H ‚Üî i ‚àà I ‚Üí x ‚àà H i := by
  constructor
  -- ‚ä¢ Pi.mulSingle i x ‚àà pi I H ‚Üí i ‚àà I ‚Üí x ‚àà H i
  ¬∑ intro h hi
    -- ‚ä¢ x ‚àà H i
    simpa using h i hi
    -- üéâ no goals
  ¬∑ intro h j hj
    -- ‚ä¢ Pi.mulSingle i x j ‚àà (fun i => ((fun i => (H i).toSubmonoid) i).carrier) j
    by_cases heq : j = i
    -- ‚ä¢ Pi.mulSingle i x j ‚àà (fun i => ((fun i => (H i).toSubmonoid) i).carrier) j
    ¬∑ subst heq
      -- ‚ä¢ Pi.mulSingle j x j ‚àà (fun i => ((fun i => (H i).toSubmonoid) i).carrier) j
      simpa using h hj
      -- üéâ no goals
    ¬∑ simp [heq, one_mem]
      -- üéâ no goals
#align subgroup.mul_single_mem_pi Subgroup.mulSingle_mem_pi
#align add_subgroup.single_mem_pi AddSubgroup.single_mem_pi

@[to_additive]
theorem pi_eq_bot_iff (H : ‚àÄ i, Subgroup (f i)) : pi Set.univ H = ‚ä• ‚Üî ‚àÄ i, H i = ‚ä• := by
  classical
    simp only [eq_bot_iff_forall]
    constructor
    ¬∑ intro h i x hx
      have : MonoidHom.single f i x = 1 :=
        h (MonoidHom.single f i x) ((mulSingle_mem_pi i x).mpr fun _ => hx)
      simpa using congr_fun this i
    ¬∑ exact fun h x hx => funext fun i => h _ _ (hx i trivial)
#align subgroup.pi_eq_bot_iff Subgroup.pi_eq_bot_iff
#align add_subgroup.pi_eq_bot_iff AddSubgroup.pi_eq_bot_iff

end Pi

/-- A subgroup is normal if whenever `n ‚àà H`, then `g * n * g‚Åª¬π ‚àà H` for every `g : G` -/
structure Normal : Prop where
  /-- `N` is closed under conjugation -/
  conj_mem : ‚àÄ n, n ‚àà H ‚Üí ‚àÄ g : G, g * n * g‚Åª¬π ‚àà H
#align subgroup.normal Subgroup.Normal

attribute [class] Normal

end Subgroup

namespace AddSubgroup

/-- An AddSubgroup is normal if whenever `n ‚àà H`, then `g + n - g ‚àà H` for every `g : G` -/
structure Normal (H : AddSubgroup A) : Prop where
  /-- `N` is closed under additive conjugation -/
  conj_mem : ‚àÄ n, n ‚àà H ‚Üí ‚àÄ g : A, g + n + -g ‚àà H
#align add_subgroup.normal AddSubgroup.Normal

attribute [to_additive] Subgroup.Normal

attribute [class] Normal

end AddSubgroup

namespace Subgroup

variable {H K : Subgroup G}

@[to_additive]
instance (priority := 100) normal_of_comm {G : Type*} [CommGroup G] (H : Subgroup G) : H.Normal :=
  ‚ü®by simp [mul_comm, mul_left_comm]‚ü©
      -- üéâ no goals
#align subgroup.normal_of_comm Subgroup.normal_of_comm
#align add_subgroup.normal_of_comm AddSubgroup.normal_of_comm

namespace Normal

variable (nH : H.Normal)

@[to_additive]
theorem mem_comm {a b : G} (h : a * b ‚àà H) : b * a ‚àà H := by
  have : a‚Åª¬π * (a * b) * a‚Åª¬π‚Åª¬π ‚àà H := nH.conj_mem (a * b) h a‚Åª¬π
  -- ‚ä¢ b * a ‚àà H
  -- Porting note: Previous code was:
  -- simpa
  simp_all only [inv_mul_cancel_left, inv_inv]
  -- üéâ no goals
#align subgroup.normal.mem_comm Subgroup.Normal.mem_comm
#align add_subgroup.normal.mem_comm AddSubgroup.Normal.mem_comm

@[to_additive]
theorem mem_comm_iff {a b : G} : a * b ‚àà H ‚Üî b * a ‚àà H :=
  ‚ü®nH.mem_comm, nH.mem_comm‚ü©
#align subgroup.normal.mem_comm_iff Subgroup.Normal.mem_comm_iff
#align add_subgroup.normal.mem_comm_iff AddSubgroup.Normal.mem_comm_iff

end Normal

variable (H)

/-- A subgroup is characteristic if it is fixed by all automorphisms.
  Several equivalent conditions are provided by lemmas of the form `Characteristic.iff...` -/
structure Characteristic : Prop where
  /-- `H` is fixed by all automorphisms -/
  fixed : ‚àÄ œï : G ‚âÉ* G, H.comap œï.toMonoidHom = H
#align subgroup.characteristic Subgroup.Characteristic

attribute [class] Characteristic

instance (priority := 100) normal_of_characteristic [h : H.Characteristic] : H.Normal :=
  ‚ü®fun a ha b => (SetLike.ext_iff.mp (h.fixed (MulAut.conj b)) a).mpr ha‚ü©
#align subgroup.normal_of_characteristic Subgroup.normal_of_characteristic

end Subgroup

namespace AddSubgroup

variable (H : AddSubgroup A)

/-- An `AddSubgroup` is characteristic if it is fixed by all automorphisms.
  Several equivalent conditions are provided by lemmas of the form `Characteristic.iff...` -/
structure Characteristic : Prop where
  /-- `H` is fixed by all automorphisms -/
  fixed : ‚àÄ œï : A ‚âÉ+ A, H.comap œï.toAddMonoidHom = H
#align add_subgroup.characteristic AddSubgroup.Characteristic

attribute [to_additive] Subgroup.Characteristic

attribute [class] Characteristic

instance (priority := 100) normal_of_characteristic [h : H.Characteristic] : H.Normal :=
  ‚ü®fun a ha b => (SetLike.ext_iff.mp (h.fixed (AddAut.conj b)) a).mpr ha‚ü©
#align add_subgroup.normal_of_characteristic AddSubgroup.normal_of_characteristic

end AddSubgroup

namespace Subgroup

variable {H K : Subgroup G}

@[to_additive]
theorem characteristic_iff_comap_eq : H.Characteristic ‚Üî ‚àÄ œï : G ‚âÉ* G, H.comap œï.toMonoidHom = H :=
  ‚ü®Characteristic.fixed, Characteristic.mk‚ü©
#align subgroup.characteristic_iff_comap_eq Subgroup.characteristic_iff_comap_eq
#align add_subgroup.characteristic_iff_comap_eq AddSubgroup.characteristic_iff_comap_eq

@[to_additive]
theorem characteristic_iff_comap_le : H.Characteristic ‚Üî ‚àÄ œï : G ‚âÉ* G, H.comap œï.toMonoidHom ‚â§ H :=
  characteristic_iff_comap_eq.trans
    ‚ü®fun h œï => le_of_eq (h œï), fun h œï =>
      le_antisymm (h œï) fun g hg => h œï.symm ((congr_arg (¬∑ ‚àà H) (œï.symm_apply_apply g)).mpr hg)‚ü©
#align subgroup.characteristic_iff_comap_le Subgroup.characteristic_iff_comap_le
#align add_subgroup.characteristic_iff_comap_le AddSubgroup.characteristic_iff_comap_le

@[to_additive]
theorem characteristic_iff_le_comap : H.Characteristic ‚Üî ‚àÄ œï : G ‚âÉ* G, H ‚â§ H.comap œï.toMonoidHom :=
  characteristic_iff_comap_eq.trans
    ‚ü®fun h œï => ge_of_eq (h œï), fun h œï =>
      le_antisymm (fun g hg => (congr_arg (¬∑ ‚àà H) (œï.symm_apply_apply g)).mp (h œï.symm hg)) (h œï)‚ü©
#align subgroup.characteristic_iff_le_comap Subgroup.characteristic_iff_le_comap
#align add_subgroup.characteristic_iff_le_comap AddSubgroup.characteristic_iff_le_comap

@[to_additive]
theorem characteristic_iff_map_eq : H.Characteristic ‚Üî ‚àÄ œï : G ‚âÉ* G, H.map œï.toMonoidHom = H := by
  simp_rw [map_equiv_eq_comap_symm]
  -- ‚ä¢ Characteristic H ‚Üî ‚àÄ (œï : G ‚âÉ* G), comap (MulEquiv.toMonoidHom (MulEquiv.sym ‚Ä¶
  exact characteristic_iff_comap_eq.trans ‚ü®fun h œï => h œï.symm, fun h œï => h œï.symm‚ü©
  -- üéâ no goals
#align subgroup.characteristic_iff_map_eq Subgroup.characteristic_iff_map_eq
#align add_subgroup.characteristic_iff_map_eq AddSubgroup.characteristic_iff_map_eq

@[to_additive]
theorem characteristic_iff_map_le : H.Characteristic ‚Üî ‚àÄ œï : G ‚âÉ* G, H.map œï.toMonoidHom ‚â§ H := by
  simp_rw [map_equiv_eq_comap_symm]
  -- ‚ä¢ Characteristic H ‚Üî ‚àÄ (œï : G ‚âÉ* G), comap (MulEquiv.toMonoidHom (MulEquiv.sym ‚Ä¶
  exact characteristic_iff_comap_le.trans ‚ü®fun h œï => h œï.symm, fun h œï => h œï.symm‚ü©
  -- üéâ no goals
#align subgroup.characteristic_iff_map_le Subgroup.characteristic_iff_map_le
#align add_subgroup.characteristic_iff_map_le AddSubgroup.characteristic_iff_map_le

@[to_additive]
theorem characteristic_iff_le_map : H.Characteristic ‚Üî ‚àÄ œï : G ‚âÉ* G, H ‚â§ H.map œï.toMonoidHom := by
  simp_rw [map_equiv_eq_comap_symm]
  -- ‚ä¢ Characteristic H ‚Üî ‚àÄ (œï : G ‚âÉ* G), H ‚â§ comap (MulEquiv.toMonoidHom (MulEquiv ‚Ä¶
  exact characteristic_iff_le_comap.trans ‚ü®fun h œï => h œï.symm, fun h œï => h œï.symm‚ü©
  -- üéâ no goals
#align subgroup.characteristic_iff_le_map Subgroup.characteristic_iff_le_map
#align add_subgroup.characteristic_iff_le_map AddSubgroup.characteristic_iff_le_map

@[to_additive]
instance botCharacteristic : Characteristic (‚ä• : Subgroup G) :=
  characteristic_iff_le_map.mpr fun _œï => bot_le
#align subgroup.bot_characteristic Subgroup.botCharacteristic
#align add_subgroup.bot_characteristic AddSubgroup.botCharacteristic

@[to_additive]
instance topCharacteristic : Characteristic (‚ä§ : Subgroup G) :=
  characteristic_iff_map_le.mpr fun _œï => le_top
#align subgroup.top_characteristic Subgroup.topCharacteristic
#align add_subgroup.top_characteristic AddSubgroup.topCharacteristic

variable (G)

/-- The center of a group `G` is the set of elements that commute with everything in `G` -/
@[to_additive
      "The center of an additive group `G` is the set of elements that commute with
      everything in `G`"]
def center : Subgroup G :=
  { Submonoid.center G with
    carrier := Set.center G
    inv_mem' := Set.inv_mem_center }
#align subgroup.center Subgroup.center
#align add_subgroup.center AddSubgroup.center

@[to_additive]
theorem coe_center : ‚Üë(center G) = Set.center G :=
  rfl
#align subgroup.coe_center Subgroup.coe_center
#align add_subgroup.coe_center AddSubgroup.coe_center

@[to_additive (attr := simp)]
theorem center_toSubmonoid : (center G).toSubmonoid = Submonoid.center G :=
  rfl
#align subgroup.center_to_submonoid Subgroup.center_toSubmonoid
#align add_subgroup.center_to_add_submonoid AddSubgroup.center_toAddSubmonoid

/-- For a group with zero, the center of the units is the same as the units of the center. -/
@[simps! apply_val_coe symm_apply_coe_val]
def centerUnitsEquivUnitsCenter (G‚ÇÄ : Type*) [GroupWithZero G‚ÇÄ] :
    Subgroup.center (G‚ÇÄÀ£) ‚âÉ* (Submonoid.center G‚ÇÄ)À£ where
  toFun := MonoidHom.toHomUnits <|
    { toFun := fun u ‚Ü¶ ‚ü®(u : G‚ÇÄÀ£), fun r ‚Ü¶ by
        rcases eq_or_ne r 0 with (rfl | hr)
        -- ‚ä¢ 0 * ‚Üë‚Üëu = ‚Üë‚Üëu * 0
        ¬∑ rw [mul_zero, zero_mul]
          -- üéâ no goals
        exact congrArg Units.val <| u.2 <| Units.mk0 r hr‚ü©
        -- üéâ no goals
      map_one' := rfl
      map_mul' := fun _ _ ‚Ü¶ rfl }
  invFun u := unitsCenterToCenterUnits G‚ÇÄ u
  left_inv _ := by ext; rfl
                   -- ‚ä¢ ‚Üë‚Üë((fun u => ‚Üë(unitsCenterToCenterUnits G‚ÇÄ) u) (‚Üë(MonoidHom.toHomUnits { toO ‚Ä¶
                        -- üéâ no goals
  right_inv _ := by ext; rfl
                    -- ‚ä¢ ‚Üë‚Üë(‚Üë(MonoidHom.toHomUnits { toOneHom := { toFun := fun u => { val := ‚Üë‚Üëu, pr ‚Ä¶
                         -- üéâ no goals
  map_mul' := map_mul _

variable {G}

@[to_additive]
theorem mem_center_iff {z : G} : z ‚àà center G ‚Üî ‚àÄ g, g * z = z * g :=
  Iff.rfl
#align subgroup.mem_center_iff Subgroup.mem_center_iff
#align add_subgroup.mem_center_iff AddSubgroup.mem_center_iff

instance decidableMemCenter (z : G) [Decidable (‚àÄ g, g * z = z * g)] : Decidable (z ‚àà center G) :=
  decidable_of_iff' _ mem_center_iff
#align subgroup.decidable_mem_center Subgroup.decidableMemCenter

@[to_additive]
instance centerCharacteristic : (center G).Characteristic := by
  refine' characteristic_iff_comap_le.mpr fun œï g hg h => _
  -- ‚ä¢ h * g = g * h
  rw [‚Üê œï.injective.eq_iff, œï.map_mul, œï.map_mul]
  -- ‚ä¢ ‚Üëœï h * ‚Üëœï g = ‚Üëœï g * ‚Üëœï h
  exact hg (œï h)
  -- üéâ no goals
#align subgroup.center_characteristic Subgroup.centerCharacteristic
#align add_subgroup.center_characteristic AddSubgroup.centerCharacteristic

theorem _root_.CommGroup.center_eq_top {G : Type*} [CommGroup G] : center G = ‚ä§ := by
  rw [eq_top_iff']
  -- ‚ä¢ ‚àÄ (x : G), x ‚àà center G
  intro x y
  -- ‚ä¢ y * x = x * y
  exact mul_comm y x
  -- üéâ no goals
#align comm_group.center_eq_top CommGroup.center_eq_top

/-- A group is commutative if the center is the whole group -/
def _root_.Group.commGroupOfCenterEqTop (h : center G = ‚ä§) : CommGroup G :=
  { (_ : Group G) with
    mul_comm := by
      rw [eq_top_iff'] at h
      -- ‚ä¢ ‚àÄ (a b : G), a * b = b * a
      intro x y
      -- ‚ä¢ x * y = y * x
      exact h y x }
      -- üéâ no goals
#align group.comm_group_of_center_eq_top Group.commGroupOfCenterEqTop

variable (H)

section Normalizer

/-- The `normalizer` of `H` is the largest subgroup of `G` inside which `H` is normal. -/
@[to_additive "The `normalizer` of `H` is the largest subgroup of `G` inside which `H` is normal."]
def normalizer : Subgroup G where
  carrier := { g : G | ‚àÄ n, n ‚àà H ‚Üî g * n * g‚Åª¬π ‚àà H }
  one_mem' := by simp
                 -- üéâ no goals
  mul_mem' {a b} (ha : ‚àÄ n, n ‚àà H ‚Üî a * n * a‚Åª¬π ‚àà H) (hb : ‚àÄ n, n ‚àà H ‚Üî b * n * b‚Åª¬π ‚àà H) n := by
    -- ‚ä¢ a * (b * n * b‚Åª¬π) * a‚Åª¬π ‚àà H ‚Üî a * b * n * (a * b)‚Åª¬π ‚àà H
    rw [hb, ha]
    -- üéâ no goals
    simp only [mul_assoc, mul_inv_rev]
  inv_mem' {a} (ha : ‚àÄ n, n ‚àà H ‚Üî a * n * a‚Åª¬π ‚àà H) n := by
    rw [ha (a‚Åª¬π * n * a‚Åª¬π‚Åª¬π)]
    -- ‚ä¢ n ‚àà H ‚Üî a * (a‚Åª¬π * n * a‚Åª¬π‚Åª¬π) * a‚Åª¬π ‚àà H
    simp only [inv_inv, mul_assoc, mul_inv_cancel_left, mul_right_inv, mul_one]
    -- üéâ no goals
#align subgroup.normalizer Subgroup.normalizer
#align add_subgroup.normalizer AddSubgroup.normalizer

-- variant for sets.
-- TODO should this replace `normalizer`?
/-- The `setNormalizer` of `S` is the subgroup of `G` whose elements satisfy `g*S*g‚Åª¬π=S` -/
@[to_additive
      "The `setNormalizer` of `S` is the subgroup of `G` whose elements satisfy
      `g+S-g=S`."]
def setNormalizer (S : Set G) : Subgroup G where
  carrier := { g : G | ‚àÄ n, n ‚àà S ‚Üî g * n * g‚Åª¬π ‚àà S }
  one_mem' := by simp
                 -- üéâ no goals
  mul_mem' {a b} (ha : ‚àÄ n, n ‚àà S ‚Üî a * n * a‚Åª¬π ‚àà S) (hb : ‚àÄ n, n ‚àà S ‚Üî b * n * b‚Åª¬π ‚àà S) n := by
    -- ‚ä¢ a * (b * n * b‚Åª¬π) * a‚Åª¬π ‚àà S ‚Üî a * b * n * (a * b)‚Åª¬π ‚àà S
    rw [hb, ha]
    -- üéâ no goals
    simp only [mul_assoc, mul_inv_rev]
  inv_mem' {a} (ha : ‚àÄ n, n ‚àà S ‚Üî a * n * a‚Åª¬π ‚àà S) n := by
    rw [ha (a‚Åª¬π * n * a‚Åª¬π‚Åª¬π)]
    -- ‚ä¢ n ‚àà S ‚Üî a * (a‚Åª¬π * n * a‚Åª¬π‚Åª¬π) * a‚Åª¬π ‚àà S
    simp only [inv_inv, mul_assoc, mul_inv_cancel_left, mul_right_inv, mul_one]
    -- üéâ no goals
#align subgroup.set_normalizer Subgroup.setNormalizer
#align add_subgroup.set_normalizer AddSubgroup.setNormalizer

variable {H}

@[to_additive]
theorem mem_normalizer_iff {g : G} : g ‚àà H.normalizer ‚Üî ‚àÄ h, h ‚àà H ‚Üî g * h * g‚Åª¬π ‚àà H :=
  Iff.rfl
#align subgroup.mem_normalizer_iff Subgroup.mem_normalizer_iff
#align add_subgroup.mem_normalizer_iff AddSubgroup.mem_normalizer_iff

@[to_additive]
theorem mem_normalizer_iff'' {g : G} : g ‚àà H.normalizer ‚Üî ‚àÄ h : G, h ‚àà H ‚Üî g‚Åª¬π * h * g ‚àà H := by
  rw [‚Üê inv_mem_iff (x := g), mem_normalizer_iff, inv_inv]
  -- üéâ no goals
#align subgroup.mem_normalizer_iff'' Subgroup.mem_normalizer_iff''
#align add_subgroup.mem_normalizer_iff'' AddSubgroup.mem_normalizer_iff''

@[to_additive]
theorem mem_normalizer_iff' {g : G} : g ‚àà H.normalizer ‚Üî ‚àÄ n, n * g ‚àà H ‚Üî g * n ‚àà H :=
  ‚ü®fun h n => by rw [h, mul_assoc, mul_inv_cancel_right], fun h n => by
                 -- üéâ no goals
    rw [mul_assoc, ‚Üê h, inv_mul_cancel_right]‚ü©
    -- üéâ no goals
#align subgroup.mem_normalizer_iff' Subgroup.mem_normalizer_iff'
#align add_subgroup.mem_normalizer_iff' AddSubgroup.mem_normalizer_iff'

@[to_additive]
theorem le_normalizer : H ‚â§ normalizer H := fun x xH n => by
  rw [H.mul_mem_cancel_right (H.inv_mem xH), H.mul_mem_cancel_left xH]
  -- üéâ no goals
#align subgroup.le_normalizer Subgroup.le_normalizer
#align add_subgroup.le_normalizer AddSubgroup.le_normalizer

@[to_additive]
instance (priority := 100) normal_in_normalizer : (H.subgroupOf H.normalizer).Normal :=
  ‚ü®fun x xH g => by simpa only [mem_subgroupOf] using (g.2 x.1).1 xH‚ü©
                    -- üéâ no goals
#align subgroup.normal_in_normalizer Subgroup.normal_in_normalizer
#align add_subgroup.normal_in_normalizer AddSubgroup.normal_in_normalizer

@[to_additive]
theorem normalizer_eq_top : H.normalizer = ‚ä§ ‚Üî H.Normal :=
  eq_top_iff.trans
    ‚ü®fun h => ‚ü®fun a ha b => (h (mem_top b) a).mp ha‚ü©, fun h a _ha b =>
      ‚ü®fun hb => h.conj_mem b hb a, fun hb => by rwa [h.mem_comm_iff, inv_mul_cancel_left] at hb‚ü©‚ü©
                                                 -- üéâ no goals
#align subgroup.normalizer_eq_top Subgroup.normalizer_eq_top
#align add_subgroup.normalizer_eq_top AddSubgroup.normalizer_eq_top

@[to_additive]
theorem center_le_normalizer : center G ‚â§ H.normalizer := fun x hx y => by
  simp [‚Üê mem_center_iff.mp hx y, mul_assoc]
  -- üéâ no goals
#align subgroup.center_le_normalizer Subgroup.center_le_normalizer
#align add_subgroup.center_le_normalizer AddSubgroup.center_le_normalizer

open Classical

@[to_additive]
theorem le_normalizer_of_normal [hK : (H.subgroupOf K).Normal] (HK : H ‚â§ K) : K ‚â§ H.normalizer :=
  fun x hx y =>
  ‚ü®fun yH => hK.conj_mem ‚ü®y, HK yH‚ü© yH ‚ü®x, hx‚ü©, fun yH => by
    simpa [mem_subgroupOf, mul_assoc] using
      hK.conj_mem ‚ü®x * y * x‚Åª¬π, HK yH‚ü© yH ‚ü®x‚Åª¬π, K.inv_mem hx‚ü©‚ü©
#align subgroup.le_normalizer_of_normal Subgroup.le_normalizer_of_normal
#align add_subgroup.le_normalizer_of_normal AddSubgroup.le_normalizer_of_normal

variable {N : Type*} [Group N]

/-- The preimage of the normalizer is contained in the normalizer of the preimage. -/
@[to_additive "The preimage of the normalizer is contained in the normalizer of the preimage."]
theorem le_normalizer_comap (f : N ‚Üí* G) :
    H.normalizer.comap f ‚â§ (H.comap f).normalizer := fun x => by
  simp only [mem_normalizer_iff, mem_comap]
  -- ‚ä¢ (‚àÄ (h : G), h ‚àà H ‚Üî ‚Üëf x * h * (‚Üëf x)‚Åª¬π ‚àà H) ‚Üí ‚àÄ (h : N), ‚Üëf h ‚àà H ‚Üî ‚Üëf (x * ‚Ä¶
  intro h n
  -- ‚ä¢ ‚Üëf n ‚àà H ‚Üî ‚Üëf (x * n * x‚Åª¬π) ‚àà H
  simp [h (f n)]
  -- üéâ no goals
#align subgroup.le_normalizer_comap Subgroup.le_normalizer_comap
#align add_subgroup.le_normalizer_comap AddSubgroup.le_normalizer_comap

/-- The image of the normalizer is contained in the normalizer of the image. -/
@[to_additive "The image of the normalizer is contained in the normalizer of the image."]
theorem le_normalizer_map (f : G ‚Üí* N) : H.normalizer.map f ‚â§ (H.map f).normalizer := fun _ => by
  simp only [and_imp, exists_prop, mem_map, exists_imp, mem_normalizer_iff]
  -- ‚ä¢ ‚àÄ (x : G), (‚àÄ (h : G), h ‚àà H ‚Üî x * h * x‚Åª¬π ‚àà H) ‚Üí ‚Üëf x = x‚úù ‚Üí ‚àÄ (h : N), (‚àÉ  ‚Ä¶
  rintro x hx rfl n
  -- ‚ä¢ (‚àÉ x, x ‚àà H ‚àß ‚Üëf x = n) ‚Üî ‚àÉ x_1, x_1 ‚àà H ‚àß ‚Üëf x_1 = ‚Üëf x * n * (‚Üëf x)‚Åª¬π
  constructor
  -- ‚ä¢ (‚àÉ x, x ‚àà H ‚àß ‚Üëf x = n) ‚Üí ‚àÉ x_1, x_1 ‚àà H ‚àß ‚Üëf x_1 = ‚Üëf x * n * (‚Üëf x)‚Åª¬π
  ¬∑ rintro ‚ü®y, hy, rfl‚ü©
    -- ‚ä¢ ‚àÉ x_1, x_1 ‚àà H ‚àß ‚Üëf x_1 = ‚Üëf x * ‚Üëf y * (‚Üëf x)‚Åª¬π
    use x * y * x‚Åª¬π, (hx y).1 hy
    -- ‚ä¢ ‚Üëf (x * y * x‚Åª¬π) = ‚Üëf x * ‚Üëf y * (‚Üëf x)‚Åª¬π
    simp
    -- üéâ no goals
  ¬∑ rintro ‚ü®y, hyH, hy‚ü©
    -- ‚ä¢ ‚àÉ x, x ‚àà H ‚àß ‚Üëf x = n
    use x‚Åª¬π * y * x
    -- ‚ä¢ x‚Åª¬π * y * x ‚àà H ‚àß ‚Üëf (x‚Åª¬π * y * x) = n
    rw [hx]
    -- ‚ä¢ x * (x‚Åª¬π * y * x) * x‚Åª¬π ‚àà H ‚àß ‚Üëf (x‚Åª¬π * y * x) = n
    simp [hy, hyH, mul_assoc]
    -- üéâ no goals
#align subgroup.le_normalizer_map Subgroup.le_normalizer_map
#align add_subgroup.le_normalizer_map AddSubgroup.le_normalizer_map

variable (G)

/-- Every proper subgroup `H` of `G` is a proper normal subgroup of the normalizer of `H` in `G`. -/
def _root_.NormalizerCondition :=
  ‚àÄ H : Subgroup G, H < ‚ä§ ‚Üí H < normalizer H
#align normalizer_condition NormalizerCondition

variable {G}

/-- Alternative phrasing of the normalizer condition: Only the full group is self-normalizing.
This may be easier to work with, as it avoids inequalities and negations.  -/
theorem _root_.normalizerCondition_iff_only_full_group_self_normalizing :
    NormalizerCondition G ‚Üî ‚àÄ H : Subgroup G, H.normalizer = H ‚Üí H = ‚ä§ := by
  apply forall_congr'; intro H
  -- ‚ä¢ ‚àÄ (a : Subgroup G), a < ‚ä§ ‚Üí a < normalizer a ‚Üî normalizer a = a ‚Üí a = ‚ä§
                       -- ‚ä¢ H < ‚ä§ ‚Üí H < normalizer H ‚Üî normalizer H = H ‚Üí H = ‚ä§
  simp only [lt_iff_le_and_ne, le_normalizer, true_and_iff, le_top, Ne.def]
  -- ‚ä¢ ¬¨H = ‚ä§ ‚Üí ¬¨H = normalizer H ‚Üî normalizer H = H ‚Üí H = ‚ä§
  tauto
  -- üéâ no goals
#align normalizer_condition_iff_only_full_group_self_normalizing normalizerCondition_iff_only_full_group_self_normalizing

variable (H)

/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/
theorem NormalizerCondition.normal_of_coatom (hnc : NormalizerCondition G) (hmax : IsCoatom H) :
    H.Normal :=
  normalizer_eq_top.mp (hmax.2 _ (hnc H (lt_top_iff_ne_top.mpr hmax.1)))
#align subgroup.normalizer_condition.normal_of_coatom Subgroup.NormalizerCondition.normal_of_coatom

end Normalizer

section Centralizer

variable {H}

/-- The `centralizer` of `H` is the subgroup of `g : G` commuting with every `h : H`. -/
@[to_additive
      "The `centralizer` of `H` is the additive subgroup of `g : G` commuting with\nevery `h : H`."]
def centralizer (s : Set G) : Subgroup G :=
  { Submonoid.centralizer s with
    carrier := Set.centralizer s
    inv_mem' := Set.inv_mem_centralizer }
#align subgroup.centralizer Subgroup.centralizer
#align add_subgroup.centralizer AddSubgroup.centralizer

@[to_additive]
theorem mem_centralizer_iff {g : G} {s : Set G} : g ‚àà centralizer s ‚Üî ‚àÄ h ‚àà s, h * g = g * h :=
  Iff.rfl
#align subgroup.mem_centralizer_iff Subgroup.mem_centralizer_iff
#align add_subgroup.mem_centralizer_iff AddSubgroup.mem_centralizer_iff

@[to_additive]
theorem mem_centralizer_iff_commutator_eq_one {g : G} {s : Set G} :
    g ‚àà centralizer s ‚Üî ‚àÄ h ‚àà s, h * g * h‚Åª¬π * g‚Åª¬π = 1 := by
  simp only [mem_centralizer_iff, mul_inv_eq_iff_eq_mul, one_mul]
  -- üéâ no goals
#align subgroup.mem_centralizer_iff_commutator_eq_one Subgroup.mem_centralizer_iff_commutator_eq_one
#align add_subgroup.mem_centralizer_iff_commutator_eq_zero AddSubgroup.mem_centralizer_iff_commutator_eq_zero

@[to_additive]
theorem centralizer_univ : centralizer Set.univ = center G :=
  SetLike.ext' (Set.centralizer_univ G)
#align subgroup.centralizer_univ Subgroup.centralizer_univ
#align add_subgroup.centralizer_univ AddSubgroup.centralizer_univ

@[to_additive]
theorem le_centralizer_iff : H ‚â§ centralizer K ‚Üî K ‚â§ centralizer H :=
  ‚ü®fun h x hx _y hy => (h hy x hx).symm, fun h x hx _y hy => (h hy x hx).symm‚ü©
#align subgroup.le_centralizer_iff Subgroup.le_centralizer_iff
#align add_subgroup.le_centralizer_iff AddSubgroup.le_centralizer_iff

@[to_additive]
theorem center_le_centralizer (s) : center G ‚â§ centralizer s :=
  Set.center_subset_centralizer s
#align subgroup.center_le_centralizer Subgroup.center_le_centralizer
#align add_subgroup.center_le_centralizer AddSubgroup.center_le_centralizer

@[to_additive]
theorem centralizer_le {s t : Set G} (h : s ‚äÜ t) : centralizer t ‚â§ centralizer s :=
  Submonoid.centralizer_le h
#align subgroup.centralizer_le Subgroup.centralizer_le
#align add_subgroup.centralizer_le AddSubgroup.centralizer_le

@[to_additive (attr := simp)]
theorem centralizer_eq_top_iff_subset {s : Set G} : centralizer s = ‚ä§ ‚Üî s ‚äÜ center G :=
  SetLike.ext'_iff.trans Set.centralizer_eq_top_iff_subset
#align subgroup.centralizer_eq_top_iff_subset Subgroup.centralizer_eq_top_iff_subset
#align add_subgroup.centralizer_eq_top_iff_subset AddSubgroup.centralizer_eq_top_iff_subset

@[to_additive]
instance Centralizer.characteristic [hH : H.Characteristic] :
    (centralizer (H : Set G)).Characteristic := by
  refine' Subgroup.characteristic_iff_comap_le.mpr fun œï g hg h hh => œï.injective _
  -- ‚ä¢ ‚Üëœï (h * g) = ‚Üëœï (g * h)
  rw [map_mul, map_mul]
  -- ‚ä¢ ‚Üëœï h * ‚Üëœï g = ‚Üëœï g * ‚Üëœï h
  exact hg (œï h) (Subgroup.characteristic_iff_le_comap.mp hH œï hh)
  -- üéâ no goals
#align subgroup.subgroup.centralizer.characteristic Subgroup.Centralizer.characteristic
#align add_subgroup.subgroup.centralizer.characteristic AddSubgroup.Centralizer.characteristic

end Centralizer

/-- Commutativity of a subgroup -/
structure IsCommutative : Prop where
  /-- `*` is commutative on `H` -/
  is_comm : IsCommutative H (¬∑ * ¬∑)
#align subgroup.is_commutative Subgroup.IsCommutative

attribute [class] IsCommutative

/-- Commutativity of an additive subgroup -/
structure _root_.AddSubgroup.IsCommutative (H : AddSubgroup A) : Prop where
  /-- `+` is commutative on `H` -/
  is_comm : _root_.IsCommutative H (¬∑ + ¬∑)
#align add_subgroup.is_commutative AddSubgroup.IsCommutative

attribute [to_additive] Subgroup.IsCommutative

attribute [class] AddSubgroup.IsCommutative

/-- A commutative subgroup is commutative. -/
@[to_additive "A commutative subgroup is commutative."]
instance IsCommutative.commGroup [h : H.IsCommutative] : CommGroup H :=
  { H.toGroup with mul_comm := h.is_comm.comm }
#align subgroup.is_commutative.comm_group Subgroup.IsCommutative.commGroup
#align add_subgroup.is_commutative.add_comm_group AddSubgroup.IsCommutative.addCommGroup

instance center.isCommutative : (center G).IsCommutative :=
  ‚ü®‚ü®fun a b => Subtype.ext (b.2 a)‚ü©‚ü©
#align subgroup.center.is_commutative Subgroup.center.isCommutative

@[to_additive]
instance map_isCommutative (f : G ‚Üí* G') [H.IsCommutative] : (H.map f).IsCommutative :=
  ‚ü®‚ü®by
      rintro ‚ü®-, a, ha, rfl‚ü© ‚ü®-, b, hb, rfl‚ü©
      -- ‚ä¢ { val := ‚Üëf a, property := (_ : ‚àÉ a_1, a_1 ‚àà ‚ÜëH ‚àß ‚Üëf a_1 = ‚Üëf a) } * { val : ‚Ä¶
      rw [Subtype.ext_iff, coe_mul, coe_mul, Subtype.coe_mk, Subtype.coe_mk, ‚Üê map_mul, ‚Üê map_mul]
      -- ‚ä¢ ‚Üëf (a * b) = ‚Üëf (b * a)
      exact congr_arg f (Subtype.ext_iff.mp (mul_comm (‚ü®a, ha‚ü© : H) ‚ü®b, hb‚ü©))‚ü©‚ü©
      -- üéâ no goals
#align subgroup.map_is_commutative Subgroup.map_isCommutative
#align add_subgroup.map_is_commutative AddSubgroup.map_isCommutative

@[to_additive]
theorem comap_injective_isCommutative {f : G' ‚Üí* G} (hf : Injective f) [H.IsCommutative] :
    (H.comap f).IsCommutative :=
  ‚ü®‚ü®fun a b =>
      Subtype.ext
        (by
          have := mul_comm (‚ü®f a, a.2‚ü© : H) (‚ü®f b, b.2‚ü© : H)
          -- ‚ä¢ ‚Üë(a * b) = ‚Üë(b * a)
          rwa [Subtype.ext_iff, coe_mul, coe_mul, coe_mk, coe_mk, ‚Üê map_mul, ‚Üê map_mul,
            hf.eq_iff] at this)‚ü©‚ü©
#align subgroup.comap_injective_is_commutative Subgroup.comap_injective_isCommutative
#align add_subgroup.comap_injective_is_commutative AddSubgroup.comap_injective_isCommutative

@[to_additive]
instance subgroupOf_isCommutative [H.IsCommutative] : (H.subgroupOf K).IsCommutative :=
  H.comap_injective_isCommutative Subtype.coe_injective
#align subgroup.subgroup_of_is_commutative Subgroup.subgroupOf_isCommutative
#align add_subgroup.add_subgroup_of_is_commutative AddSubgroup.addSubgroupOf_isCommutative

@[to_additive]
theorem le_centralizer_iff_isCommutative : K ‚â§ centralizer K ‚Üî K.IsCommutative :=
  ‚ü®fun h => ‚ü®‚ü®fun x y => Subtype.ext (h y.2 x x.2)‚ü©‚ü©,
    fun h x hx y hy => congr_arg Subtype.val (h.1.1 ‚ü®y, hy‚ü© ‚ü®x, hx‚ü©)‚ü©
#align subgroup.le_centralizer_iff_is_commutative Subgroup.le_centralizer_iff_isCommutative
#align add_subgroup.le_centralizer_iff_is_commutative AddSubgroup.le_centralizer_iff_isCommutative

@[to_additive]
theorem le_centralizer [h : H.IsCommutative] : H ‚â§ centralizer H :=
  le_centralizer_iff_isCommutative.mpr h
#align subgroup.le_centralizer Subgroup.le_centralizer
#align add_subgroup.le_centralizer AddSubgroup.le_centralizer

end Subgroup

namespace Group

variable {s : Set G}

/-- Given a set `s`, `conjugatesOfSet s` is the set of all conjugates of
the elements of `s`. -/
def conjugatesOfSet (s : Set G) : Set G :=
  ‚ãÉ a ‚àà s, conjugatesOf a
#align group.conjugates_of_set Group.conjugatesOfSet

theorem mem_conjugatesOfSet_iff {x : G} : x ‚àà conjugatesOfSet s ‚Üî ‚àÉ a ‚àà s, IsConj a x := by
  erw [Set.mem_iUnion‚ÇÇ]; simp only [conjugatesOf, isConj_iff, Set.mem_setOf_eq, exists_prop]
  -- ‚ä¢ (‚àÉ i j, x ‚àà conjugatesOf i) ‚Üî ‚àÉ a, a ‚àà s ‚àß IsConj a x
                         -- üéâ no goals
#align group.mem_conjugates_of_set_iff Group.mem_conjugatesOfSet_iff

theorem subset_conjugatesOfSet : s ‚äÜ conjugatesOfSet s := fun (x : G) (h : x ‚àà s) =>
  mem_conjugatesOfSet_iff.2 ‚ü®x, h, IsConj.refl _‚ü©
#align group.subset_conjugates_of_set Group.subset_conjugatesOfSet

theorem conjugatesOfSet_mono {s t : Set G} (h : s ‚äÜ t) : conjugatesOfSet s ‚äÜ conjugatesOfSet t :=
  Set.biUnion_subset_biUnion_left h
#align group.conjugates_of_set_mono Group.conjugatesOfSet_mono

theorem conjugates_subset_normal {N : Subgroup G} [tn : N.Normal] {a : G} (h : a ‚àà N) :
    conjugatesOf a ‚äÜ N := by
  rintro a hc
  -- ‚ä¢ a ‚àà ‚ÜëN
  obtain ‚ü®c, rfl‚ü© := isConj_iff.1 hc
  -- ‚ä¢ c * a * c‚Åª¬π ‚àà ‚ÜëN
  exact tn.conj_mem a h c
  -- üéâ no goals
#align group.conjugates_subset_normal Group.conjugates_subset_normal

theorem conjugatesOfSet_subset {s : Set G} {N : Subgroup G} [N.Normal] (h : s ‚äÜ N) :
    conjugatesOfSet s ‚äÜ N :=
  Set.iUnion‚ÇÇ_subset fun _x H => conjugates_subset_normal (h H)
#align group.conjugates_of_set_subset Group.conjugatesOfSet_subset

/-- The set of conjugates of `s` is closed under conjugation. -/
theorem conj_mem_conjugatesOfSet {x c : G} :
    x ‚àà conjugatesOfSet s ‚Üí c * x * c‚Åª¬π ‚àà conjugatesOfSet s := fun H => by
  rcases mem_conjugatesOfSet_iff.1 H with ‚ü®a, h‚ÇÅ, h‚ÇÇ‚ü©
  -- ‚ä¢ c * x * c‚Åª¬π ‚àà conjugatesOfSet s
  exact mem_conjugatesOfSet_iff.2 ‚ü®a, h‚ÇÅ, h‚ÇÇ.trans (isConj_iff.2 ‚ü®c, rfl‚ü©)‚ü©
  -- üéâ no goals
#align group.conj_mem_conjugates_of_set Group.conj_mem_conjugatesOfSet

end Group

namespace Subgroup

open Group

variable {s : Set G}

/-- The normal closure of a set `s` is the subgroup closure of all the conjugates of
elements of `s`. It is the smallest normal subgroup containing `s`. -/
def normalClosure (s : Set G) : Subgroup G :=
  closure (conjugatesOfSet s)
#align subgroup.normal_closure Subgroup.normalClosure

theorem conjugatesOfSet_subset_normalClosure : conjugatesOfSet s ‚äÜ normalClosure s :=
  subset_closure
#align subgroup.conjugates_of_set_subset_normal_closure Subgroup.conjugatesOfSet_subset_normalClosure

theorem subset_normalClosure : s ‚äÜ normalClosure s :=
  Set.Subset.trans subset_conjugatesOfSet conjugatesOfSet_subset_normalClosure
#align subgroup.subset_normal_closure Subgroup.subset_normalClosure

theorem le_normalClosure {H : Subgroup G} : H ‚â§ normalClosure ‚ÜëH := fun _ h =>
  subset_normalClosure h
#align subgroup.le_normal_closure Subgroup.le_normalClosure

/-- The normal closure of `s` is a normal subgroup. -/
instance normalClosure_normal : (normalClosure s).Normal :=
  ‚ü®fun n h g => by
    refine' Subgroup.closure_induction h (fun x hx => _) _ (fun x y ihx ihy => _) fun x ihx => _
    ¬∑ exact conjugatesOfSet_subset_normalClosure (conj_mem_conjugatesOfSet hx)
      -- üéâ no goals
    ¬∑ simpa using (normalClosure s).one_mem
      -- üéâ no goals
    ¬∑ rw [‚Üê conj_mul]
      -- ‚ä¢ g * x * g‚Åª¬π * (g * y * g‚Åª¬π) ‚àà normalClosure s
      exact mul_mem ihx ihy
      -- üéâ no goals
    ¬∑ rw [‚Üê conj_inv]
      -- ‚ä¢ (g * x * g‚Åª¬π)‚Åª¬π ‚àà normalClosure s
      exact inv_mem ihx‚ü©
      -- üéâ no goals
#align subgroup.normal_closure_normal Subgroup.normalClosure_normal

/-- The normal closure of `s` is the smallest normal subgroup containing `s`. -/
theorem normalClosure_le_normal {N : Subgroup G} [N.Normal] (h : s ‚äÜ N) : normalClosure s ‚â§ N := by
  intro a w
  -- ‚ä¢ a ‚àà N
  refine' closure_induction w (fun x hx => _) _ (fun x y ihx ihy => _) fun x ihx => _
  ¬∑ exact conjugatesOfSet_subset h hx
    -- üéâ no goals
  ¬∑ exact one_mem _
    -- üéâ no goals
  ¬∑ exact mul_mem ihx ihy
    -- üéâ no goals
  ¬∑ exact inv_mem ihx
    -- üéâ no goals
#align subgroup.normal_closure_le_normal Subgroup.normalClosure_le_normal

theorem normalClosure_subset_iff {N : Subgroup G} [N.Normal] : s ‚äÜ N ‚Üî normalClosure s ‚â§ N :=
  ‚ü®normalClosure_le_normal, Set.Subset.trans subset_normalClosure‚ü©
#align subgroup.normal_closure_subset_iff Subgroup.normalClosure_subset_iff

theorem normalClosure_mono {s t : Set G} (h : s ‚äÜ t) : normalClosure s ‚â§ normalClosure t :=
  normalClosure_le_normal (Set.Subset.trans h subset_normalClosure)
#align subgroup.normal_closure_mono Subgroup.normalClosure_mono

-- Porting note: the elaborator trips up on using underscores for names in `‚®Ö`
theorem normalClosure_eq_iInf :
    normalClosure s = ‚®Ö (N : Subgroup G) (_ : Normal N) (_ : s ‚äÜ N), N :=
  le_antisymm (le_iInf fun N => le_iInf fun hN => le_iInf normalClosure_le_normal)
    (iInf_le_of_le (normalClosure s)
      (iInf_le_of_le (by infer_instance) (iInf_le_of_le subset_normalClosure le_rfl)))
                         -- üéâ no goals
#align subgroup.normal_closure_eq_infi Subgroup.normalClosure_eq_iInf

@[simp]
theorem normalClosure_eq_self (H : Subgroup G) [H.Normal] : normalClosure ‚ÜëH = H :=
  le_antisymm (normalClosure_le_normal rfl.subset) le_normalClosure
#align subgroup.normal_closure_eq_self Subgroup.normalClosure_eq_self

-- @[simp] -- Porting note: simp can prove this
theorem normalClosure_idempotent : normalClosure ‚Üë(normalClosure s) = normalClosure s :=
  normalClosure_eq_self _
#align subgroup.normal_closure_idempotent Subgroup.normalClosure_idempotent

theorem closure_le_normalClosure {s : Set G} : closure s ‚â§ normalClosure s := by
  simp only [subset_normalClosure, closure_le]
  -- üéâ no goals
#align subgroup.closure_le_normal_closure Subgroup.closure_le_normalClosure

@[simp]
theorem normalClosure_closure_eq_normalClosure {s : Set G} :
    normalClosure ‚Üë(closure s) = normalClosure s :=
  le_antisymm (normalClosure_le_normal closure_le_normalClosure) (normalClosure_mono subset_closure)
#align subgroup.normal_closure_closure_eq_normal_closure Subgroup.normalClosure_closure_eq_normalClosure

/-- The normal core of a subgroup `H` is the largest normal subgroup of `G` contained in `H`,
as shown by `Subgroup.normalCore_eq_iSup`. -/
def normalCore (H : Subgroup G) : Subgroup G where
  carrier := { a : G | ‚àÄ b : G, b * a * b‚Åª¬π ‚àà H }
  one_mem' a := by rw [mul_one, mul_inv_self]; exact H.one_mem
                   -- ‚ä¢ 1 ‚àà H
                                               -- üéâ no goals
  inv_mem' {a} h b := (congr_arg (¬∑ ‚àà H) conj_inv).mp (H.inv_mem (h b))
  mul_mem' {a b} ha hb c := (congr_arg (¬∑ ‚àà H) conj_mul).mp (H.mul_mem (ha c) (hb c))
#align subgroup.normal_core Subgroup.normalCore

theorem normalCore_le (H : Subgroup G) : H.normalCore ‚â§ H := fun a h => by
  rw [‚Üê mul_one a, ‚Üê inv_one, ‚Üê one_mul a]
  -- ‚ä¢ 1 * a * 1‚Åª¬π ‚àà H
  exact h 1
  -- üéâ no goals
#align subgroup.normal_core_le Subgroup.normalCore_le

instance normalCore_normal (H : Subgroup G) : H.normalCore.Normal :=
  ‚ü®fun a h b c => by
    rw [mul_assoc, mul_assoc, ‚Üê mul_inv_rev, ‚Üê mul_assoc, ‚Üê mul_assoc]; exact h (c * b)‚ü©
    -- ‚ä¢ c * b * a * (c * b)‚Åª¬π ‚àà H
                                                                        -- üéâ no goals
#align subgroup.normal_core_normal Subgroup.normalCore_normal

theorem normal_le_normalCore {H : Subgroup G} {N : Subgroup G} [hN : N.Normal] :
    N ‚â§ H.normalCore ‚Üî N ‚â§ H :=
  ‚ü®ge_trans H.normalCore_le, fun h_le n hn g => h_le (hN.conj_mem n hn g)‚ü©
#align subgroup.normal_le_normal_core Subgroup.normal_le_normalCore

theorem normalCore_mono {H K : Subgroup G} (h : H ‚â§ K) : H.normalCore ‚â§ K.normalCore :=
  normal_le_normalCore.mpr (H.normalCore_le.trans h)
#align subgroup.normal_core_mono Subgroup.normalCore_mono

theorem normalCore_eq_iSup (H : Subgroup G) :
    H.normalCore = ‚®Ü (N : Subgroup G) (_ : Normal N) (_ : N ‚â§ H), N :=
  le_antisymm
    (le_iSup_of_le H.normalCore
      (le_iSup_of_le H.normalCore_normal (le_iSup_of_le H.normalCore_le le_rfl)))
    (iSup_le fun _ => iSup_le fun _ => iSup_le normal_le_normalCore.mpr)
#align subgroup.normal_core_eq_supr Subgroup.normalCore_eq_iSup

@[simp]
theorem normalCore_eq_self (H : Subgroup G) [H.Normal] : H.normalCore = H :=
  le_antisymm H.normalCore_le (normal_le_normalCore.mpr le_rfl)
#align subgroup.normal_core_eq_self Subgroup.normalCore_eq_self

-- @[simp] -- Porting note: simp can prove this
theorem normalCore_idempotent (H : Subgroup G) : H.normalCore.normalCore = H.normalCore :=
  H.normalCore.normalCore_eq_self
#align subgroup.normal_core_idempotent Subgroup.normalCore_idempotent

end Subgroup

namespace MonoidHom

variable {N : Type*} {P : Type*} [Group N] [Group P] (K : Subgroup G)

open Subgroup

/-- The range of a monoid homomorphism from a group is a subgroup. -/
@[to_additive "The range of an `AddMonoidHom` from an `AddGroup` is an `AddSubgroup`."]
def range (f : G ‚Üí* N) : Subgroup N :=
  Subgroup.copy ((‚ä§ : Subgroup G).map f) (Set.range f) (by simp [Set.ext_iff])
                                                           -- üéâ no goals
#align monoid_hom.range MonoidHom.range
#align add_monoid_hom.range AddMonoidHom.range

@[to_additive (attr := simp)]
theorem coe_range (f : G ‚Üí* N) : (f.range : Set N) = Set.range f :=
  rfl
#align monoid_hom.coe_range MonoidHom.coe_range
#align add_monoid_hom.coe_range AddMonoidHom.coe_range

@[to_additive (attr := simp)]
theorem mem_range {f : G ‚Üí* N} {y : N} : y ‚àà f.range ‚Üî ‚àÉ x, f x = y :=
  Iff.rfl
#align monoid_hom.mem_range MonoidHom.mem_range
#align add_monoid_hom.mem_range AddMonoidHom.mem_range

@[to_additive]
theorem range_eq_map (f : G ‚Üí* N) : f.range = (‚ä§ : Subgroup G).map f := by ext; simp
                                                                           -- ‚ä¢ x‚úù ‚àà range f ‚Üî x‚úù ‚àà map f ‚ä§
                                                                                -- üéâ no goals
#align monoid_hom.range_eq_map MonoidHom.range_eq_map
#align add_monoid_hom.range_eq_map AddMonoidHom.range_eq_map

@[to_additive (attr := simp)]
theorem restrict_range (f : G ‚Üí* N) : (f.restrict K).range = K.map f := by
  simp_rw [SetLike.ext_iff, mem_range, mem_map, restrict_apply, SetLike.exists,
    exists_prop, forall_const]
#align monoid_hom.restrict_range MonoidHom.restrict_range
#align add_monoid_hom.restrict_range AddMonoidHom.restrict_range

/-- The canonical surjective group homomorphism `G ‚Üí* f(G)` induced by a group
homomorphism `G ‚Üí* N`. -/
@[to_additive
      "The canonical surjective `AddGroup` homomorphism `G ‚Üí+ f(G)` induced by a group
      homomorphism `G ‚Üí+ N`."]
def rangeRestrict (f : G ‚Üí* N) : G ‚Üí* f.range :=
  codRestrict f _ fun x => ‚ü®x, rfl‚ü©
#align monoid_hom.range_restrict MonoidHom.rangeRestrict
#align add_monoid_hom.range_restrict AddMonoidHom.rangeRestrict

@[to_additive (attr := simp)]
theorem coe_rangeRestrict (f : G ‚Üí* N) (g : G) : (f.rangeRestrict g : N) = f g :=
  rfl
#align monoid_hom.coe_range_restrict MonoidHom.coe_rangeRestrict
#align add_monoid_hom.coe_range_restrict AddMonoidHom.coe_rangeRestrict

@[to_additive]
theorem coe_comp_rangeRestrict (f : G ‚Üí* N) :
    ((‚Üë) : f.range ‚Üí N) ‚àò (‚áëf.rangeRestrict : G ‚Üí f.range) = f :=
  rfl
#align monoid_hom.coe_comp_range_restrict MonoidHom.coe_comp_rangeRestrict
#align add_monoid_hom.coe_comp_range_restrict AddMonoidHom.coe_comp_rangeRestrict

@[to_additive]
theorem subtype_comp_rangeRestrict (f : G ‚Üí* N) : f.range.subtype.comp f.rangeRestrict = f :=
  ext <| f.coe_rangeRestrict
#align monoid_hom.subtype_comp_range_restrict MonoidHom.subtype_comp_rangeRestrict
#align add_monoid_hom.subtype_comp_range_restrict AddMonoidHom.subtype_comp_rangeRestrict

@[to_additive]
theorem rangeRestrict_surjective (f : G ‚Üí* N) : Function.Surjective f.rangeRestrict :=
  fun ‚ü®_, g, rfl‚ü© => ‚ü®g, rfl‚ü©
#align monoid_hom.range_restrict_surjective MonoidHom.rangeRestrict_surjective
#align add_monoid_hom.range_restrict_surjective AddMonoidHom.rangeRestrict_surjective

@[to_additive (attr := simp)]
lemma rangeRestrict_injective_iff {f : G ‚Üí* N} : Injective f.rangeRestrict ‚Üî Injective f := by
  convert Set.injective_codRestrict _
  -- üéâ no goals

@[to_additive]
theorem map_range (g : N ‚Üí* P) (f : G ‚Üí* N) : f.range.map g = (g.comp f).range := by
  rw [range_eq_map, range_eq_map]; exact (‚ä§ : Subgroup G).map_map g f
  -- ‚ä¢ map g (map f ‚ä§) = map (comp g f) ‚ä§
                                   -- üéâ no goals
#align monoid_hom.map_range MonoidHom.map_range
#align add_monoid_hom.map_range AddMonoidHom.map_range

@[to_additive]
theorem range_top_iff_surjective {N} [Group N] {f : G ‚Üí* N} :
    f.range = (‚ä§ : Subgroup N) ‚Üî Function.Surjective f :=
  SetLike.ext'_iff.trans <| Iff.trans (by rw [coe_range, coe_top]) Set.range_iff_surjective
                                          -- üéâ no goals
#align monoid_hom.range_top_iff_surjective MonoidHom.range_top_iff_surjective
#align add_monoid_hom.range_top_iff_surjective AddMonoidHom.range_top_iff_surjective

/-- The range of a surjective monoid homomorphism is the whole of the codomain. -/
@[to_additive (attr := simp)
  "The range of a surjective `AddMonoid` homomorphism is the whole of the codomain."]
theorem range_top_of_surjective {N} [Group N] (f : G ‚Üí* N) (hf : Function.Surjective f) :
    f.range = (‚ä§ : Subgroup N) :=
  range_top_iff_surjective.2 hf
#align monoid_hom.range_top_of_surjective MonoidHom.range_top_of_surjective
#align add_monoid_hom.range_top_of_surjective AddMonoidHom.range_top_of_surjective

@[to_additive (attr := simp)]
theorem range_one : (1 : G ‚Üí* N).range = ‚ä• :=
  SetLike.ext fun x => by simpa using @comm _ (¬∑ = ¬∑) _ 1 x
                          -- üéâ no goals
#align monoid_hom.range_one MonoidHom.range_one
#align add_monoid_hom.range_zero AddMonoidHom.range_zero

@[to_additive (attr := simp)]
theorem _root_.Subgroup.subtype_range (H : Subgroup G) : H.subtype.range = H := by
  rw [range_eq_map, ‚Üê SetLike.coe_set_eq, coe_map, Subgroup.coeSubtype]
  -- ‚ä¢ Subtype.val '' ‚Üë‚ä§ = ‚ÜëH
  ext
  -- ‚ä¢ x‚úù ‚àà Subtype.val '' ‚Üë‚ä§ ‚Üî x‚úù ‚àà ‚ÜëH
  simp
  -- üéâ no goals
#align subgroup.subtype_range Subgroup.subtype_range
#align add_subgroup.subtype_range AddSubgroup.subtype_range

@[to_additive (attr := simp)]
theorem _root_.Subgroup.inclusion_range {H K : Subgroup G} (h_le : H ‚â§ K) :
    (inclusion h_le).range = H.subgroupOf K :=
  Subgroup.ext fun g => Set.ext_iff.mp (Set.range_inclusion h_le) g
#align subgroup.inclusion_range Subgroup.inclusion_range
#align add_subgroup.inclusion_range AddSubgroup.inclusion_range

@[to_additive]
theorem subgroupOf_range_eq_of_le {G‚ÇÅ G‚ÇÇ : Type*} [Group G‚ÇÅ] [Group G‚ÇÇ] {K : Subgroup G‚ÇÇ}
    (f : G‚ÇÅ ‚Üí* G‚ÇÇ) (h : f.range ‚â§ K) :
    f.range.subgroupOf K = (f.codRestrict K fun x => h ‚ü®x, rfl‚ü©).range := by
  ext k
  -- ‚ä¢ k ‚àà subgroupOf (range f) K ‚Üî k ‚àà range (codRestrict f K (_ : ‚àÄ (x : G‚ÇÅ), ‚Üëf  ‚Ä¶
  refine' exists_congr _
  -- ‚ä¢ ‚àÄ (a : G‚ÇÅ), ‚Üëf a = ‚Üë(Subgroup.subtype K) k ‚Üî ‚Üë(codRestrict f K (_ : ‚àÄ (x : G ‚Ä¶
  simp [Subtype.ext_iff]
  -- üéâ no goals
#align monoid_hom.subgroup_of_range_eq_of_le MonoidHom.subgroupOf_range_eq_of_le
#align add_monoid_hom.add_subgroup_of_range_eq_of_le AddMonoidHom.addSubgroupOf_range_eq_of_le

/-- Computable alternative to `MonoidHom.ofInjective`. -/
@[to_additive "Computable alternative to `AddMonoidHom.ofInjective`."]
def ofLeftInverse {f : G ‚Üí* N} {g : N ‚Üí* G} (h : Function.LeftInverse g f) : G ‚âÉ* f.range :=
  { f.rangeRestrict with
    toFun := f.rangeRestrict
    invFun := g ‚àò f.range.subtype
    left_inv := h
    right_inv := by
      rintro ‚ü®x, y, rfl‚ü©
      -- ‚ä¢ ‚Üë(rangeRestrict f) ((‚Üëg ‚àò ‚Üë(Subgroup.subtype (range f))) { val := ‚Üëf y, prop ‚Ä¶
      apply Subtype.ext
      -- ‚ä¢ ‚Üë(‚Üë(rangeRestrict f) ((‚Üëg ‚àò ‚Üë(Subgroup.subtype (range f))) { val := ‚Üëf y, pr ‚Ä¶
      rw [coe_rangeRestrict, Function.comp_apply, Subgroup.coeSubtype, Subtype.coe_mk, h] }
      -- üéâ no goals
#align monoid_hom.of_left_inverse MonoidHom.ofLeftInverse
#align add_monoid_hom.of_left_inverse AddMonoidHom.ofLeftInverse

@[to_additive (attr := simp)]
theorem ofLeftInverse_apply {f : G ‚Üí* N} {g : N ‚Üí* G} (h : Function.LeftInverse g f) (x : G) :
    ‚Üë(ofLeftInverse h x) = f x :=
  rfl
#align monoid_hom.of_left_inverse_apply MonoidHom.ofLeftInverse_apply
#align add_monoid_hom.of_left_inverse_apply AddMonoidHom.ofLeftInverse_apply

@[to_additive (attr := simp)]
theorem ofLeftInverse_symm_apply {f : G ‚Üí* N} {g : N ‚Üí* G} (h : Function.LeftInverse g f)
    (x : f.range) : (ofLeftInverse h).symm x = g x :=
  rfl
#align monoid_hom.of_left_inverse_symm_apply MonoidHom.ofLeftInverse_symm_apply
#align add_monoid_hom.of_left_inverse_symm_apply AddMonoidHom.ofLeftInverse_symm_apply

/-- The range of an injective group homomorphism is isomorphic to its domain. -/
@[to_additive "The range of an injective additive group homomorphism is isomorphic to its
domain."]
noncomputable def ofInjective {f : G ‚Üí* N} (hf : Function.Injective f) : G ‚âÉ* f.range :=
  MulEquiv.ofBijective (f.codRestrict f.range fun x => ‚ü®x, rfl‚ü©)
    ‚ü®fun x y h => hf (Subtype.ext_iff.mp h), by
      rintro ‚ü®x, y, rfl‚ü©
      -- ‚ä¢ ‚àÉ a, ‚Üë(codRestrict f (range f) (_ : ‚àÄ (x : G), ‚àÉ y, ‚Üëf y = ‚Üëf x)) a = { val  ‚Ä¶
      exact ‚ü®y, rfl‚ü©‚ü©
      -- üéâ no goals
#align monoid_hom.of_injective MonoidHom.ofInjective
#align add_monoid_hom.of_injective AddMonoidHom.ofInjective

@[to_additive]
theorem ofInjective_apply {f : G ‚Üí* N} (hf : Function.Injective f) {x : G} :
    ‚Üë(ofInjective hf x) = f x :=
  rfl
#align monoid_hom.of_injective_apply MonoidHom.ofInjective_apply
#align add_monoid_hom.of_injective_apply AddMonoidHom.ofInjective_apply

section Ker

variable {M : Type*} [MulOneClass M]

/-- The multiplicative kernel of a monoid homomorphism is the subgroup of elements `x : G` such that
`f x = 1` -/
@[to_additive
      "The additive kernel of an `AddMonoid` homomorphism is the `AddSubgroup` of elements
      such that `f x = 0`"]
def ker (f : G ‚Üí* M) : Subgroup G :=
  { MonoidHom.mker f with
    inv_mem' := fun {x} (hx : f x = 1) =>
      calc
        f x‚Åª¬π = f x * f x‚Åª¬π := by rw [hx, one_mul]
                                  -- üéâ no goals
        _ = 1 := by rw [‚Üê map_mul, mul_inv_self, map_one] }
                    -- üéâ no goals
#align monoid_hom.ker MonoidHom.ker
#align add_monoid_hom.ker AddMonoidHom.ker

@[to_additive]
theorem mem_ker (f : G ‚Üí* M) {x : G} : x ‚àà f.ker ‚Üî f x = 1 :=
  Iff.rfl
#align monoid_hom.mem_ker MonoidHom.mem_ker
#align add_monoid_hom.mem_ker AddMonoidHom.mem_ker

@[to_additive]
theorem coe_ker (f : G ‚Üí* M) : (f.ker : Set G) = (f : G ‚Üí M) ‚Åª¬π' {1} :=
  rfl
#align monoid_hom.coe_ker MonoidHom.coe_ker
#align add_monoid_hom.coe_ker AddMonoidHom.coe_ker

@[to_additive (attr := simp)]
theorem ker_toHomUnits {M} [Monoid M] (f : G ‚Üí* M) : f.toHomUnits.ker = f.ker := by
  ext x
  -- ‚ä¢ x ‚àà ker (toHomUnits f) ‚Üî x ‚àà ker f
  simp [mem_ker, Units.ext_iff]
  -- üéâ no goals
#align monoid_hom.ker_to_hom_units MonoidHom.ker_toHomUnits
#align add_monoid_hom.ker_to_hom_add_units AddMonoidHom.ker_toHomAddUnits

@[to_additive]
theorem eq_iff (f : G ‚Üí* M) {x y : G} : f x = f y ‚Üî y‚Åª¬π * x ‚àà f.ker := by
  constructor <;> intro h
  -- ‚ä¢ ‚Üëf x = ‚Üëf y ‚Üí y‚Åª¬π * x ‚àà ker f
                  -- ‚ä¢ y‚Åª¬π * x ‚àà ker f
                  -- ‚ä¢ ‚Üëf x = ‚Üëf y
  ¬∑ rw [mem_ker, map_mul, h, ‚Üê map_mul, inv_mul_self, map_one]
    -- üéâ no goals
  ¬∑ rw [‚Üê one_mul x, ‚Üê mul_inv_self y, mul_assoc, map_mul, f.mem_ker.1 h, mul_one]
    -- üéâ no goals
#align monoid_hom.eq_iff MonoidHom.eq_iff
#align add_monoid_hom.eq_iff AddMonoidHom.eq_iff

@[to_additive]
instance decidableMemKer [DecidableEq M] (f : G ‚Üí* M) : DecidablePred (¬∑ ‚àà f.ker) := fun x =>
  decidable_of_iff (f x = 1) f.mem_ker
#align monoid_hom.decidable_mem_ker MonoidHom.decidableMemKer
#align add_monoid_hom.decidable_mem_ker AddMonoidHom.decidableMemKer

@[to_additive]
theorem comap_ker (g : N ‚Üí* P) (f : G ‚Üí* N) : g.ker.comap f = (g.comp f).ker :=
  rfl
#align monoid_hom.comap_ker MonoidHom.comap_ker
#align add_monoid_hom.comap_ker AddMonoidHom.comap_ker

@[to_additive (attr := simp)]
theorem comap_bot (f : G ‚Üí* N) : (‚ä• : Subgroup N).comap f = f.ker :=
  rfl
#align monoid_hom.comap_bot MonoidHom.comap_bot
#align add_monoid_hom.comap_bot AddMonoidHom.comap_bot

@[to_additive (attr := simp)]
theorem ker_restrict (f : G ‚Üí* N) : (f.restrict K).ker = f.ker.subgroupOf K :=
  rfl
#align monoid_hom.ker_restrict MonoidHom.ker_restrict
#align add_monoid_hom.ker_restrict AddMonoidHom.ker_restrict

@[to_additive (attr := simp)]
theorem ker_codRestrict {S} [SetLike S N] [SubmonoidClass S N] (f : G ‚Üí* N) (s : S)
    (h : ‚àÄ x, f x ‚àà s) : (f.codRestrict s h).ker = f.ker :=
  SetLike.ext fun _x => Subtype.ext_iff
#align monoid_hom.ker_cod_restrict MonoidHom.ker_codRestrict
#align add_monoid_hom.ker_cod_restrict AddMonoidHom.ker_codRestrict

@[to_additive (attr := simp)]
theorem ker_rangeRestrict (f : G ‚Üí* N) : ker (rangeRestrict f) = ker f :=
  ker_codRestrict _ _ _
#align monoid_hom.ker_range_restrict MonoidHom.ker_rangeRestrict
#align add_monoid_hom.ker_range_restrict AddMonoidHom.ker_rangeRestrict

@[to_additive (attr := simp)]
theorem ker_one : (1 : G ‚Üí* M).ker = ‚ä§ :=
  SetLike.ext fun _x => eq_self_iff_true _
#align monoid_hom.ker_one MonoidHom.ker_one
#align add_monoid_hom.ker_zero AddMonoidHom.ker_zero

@[to_additive (attr := simp)]
theorem ker_id : (MonoidHom.id G).ker = ‚ä• :=
  rfl
#align monoid_hom.ker_id MonoidHom.ker_id
#align add_monoid_hom.ker_id AddMonoidHom.ker_id

@[to_additive]
theorem ker_eq_bot_iff (f : G ‚Üí* M) : f.ker = ‚ä• ‚Üî Function.Injective f :=
  ‚ü®fun h x y hxy => by rwa [eq_iff, h, mem_bot, inv_mul_eq_one, eq_comm] at hxy, fun h =>
                       -- üéâ no goals
    bot_unique fun x hx => h (hx.trans f.map_one.symm)‚ü©
#align monoid_hom.ker_eq_bot_iff MonoidHom.ker_eq_bot_iff
#align add_monoid_hom.ker_eq_bot_iff AddMonoidHom.ker_eq_bot_iff

@[to_additive (attr := simp)]
theorem _root_.Subgroup.ker_subtype (H : Subgroup G) : H.subtype.ker = ‚ä• :=
  H.subtype.ker_eq_bot_iff.mpr Subtype.coe_injective
#align subgroup.ker_subtype Subgroup.ker_subtype
#align add_subgroup.ker_subtype AddSubgroup.ker_subtype

@[to_additive (attr := simp)]
theorem _root_.Subgroup.ker_inclusion {H K : Subgroup G} (h : H ‚â§ K) : (inclusion h).ker = ‚ä• :=
  (inclusion h).ker_eq_bot_iff.mpr (Set.inclusion_injective h)
#align subgroup.ker_inclusion Subgroup.ker_inclusion
#align add_subgroup.ker_inclusion AddSubgroup.ker_inclusion

@[to_additive]
theorem prodMap_comap_prod {G' : Type*} {N' : Type*} [Group G'] [Group N'] (f : G ‚Üí* N)
    (g : G' ‚Üí* N') (S : Subgroup N) (S' : Subgroup N') :
    (S.prod S').comap (prodMap f g) = (S.comap f).prod (S'.comap g) :=
  SetLike.coe_injective <| Set.preimage_prod_map_prod f g _ _
#align monoid_hom.prod_map_comap_prod MonoidHom.prodMap_comap_prod
#align add_monoid_hom.sum_map_comap_sum AddMonoidHom.sumMap_comap_sum

@[to_additive]
theorem ker_prodMap {G' : Type*} {N' : Type*} [Group G'] [Group N'] (f : G ‚Üí* N) (g : G' ‚Üí* N') :
    (prodMap f g).ker = f.ker.prod g.ker := by
  rw [‚Üê comap_bot, ‚Üê comap_bot, ‚Üê comap_bot, ‚Üê prodMap_comap_prod, bot_prod_bot]
  -- üéâ no goals
#align monoid_hom.ker_prod_map MonoidHom.ker_prodMap
#align add_monoid_hom.ker_sum_map AddMonoidHom.ker_sumMap

@[to_additive]
theorem range_le_ker_iff (f : G ‚Üí* G') (g : G' ‚Üí* G'') : f.range ‚â§ g.ker ‚Üî g.comp f = 1 :=
  ‚ü®fun h => ext fun x => h ‚ü®x, rfl‚ü©, by rintro h _ ‚ü®y, rfl‚ü©; exact FunLike.congr_fun h y‚ü©
                                        -- ‚ä¢ ‚Üëf y ‚àà ker g
                                                             -- üéâ no goals

@[to_additive]
instance (priority := 100) normal_ker (f : G ‚Üí* M) : f.ker.Normal :=
  ‚ü®fun x hx y => by
    rw [mem_ker, map_mul, map_mul, f.mem_ker.1 hx, mul_one, map_mul_eq_one f (mul_inv_self y)]‚ü©
    -- üéâ no goals
#align monoid_hom.normal_ker MonoidHom.normal_ker
#align add_monoid_hom.normal_ker AddMonoidHom.normal_ker

@[to_additive (attr := simp)]
lemma ker_fst : ker (fst G G') = .prod ‚ä• ‚ä§ := SetLike.ext fun _ => (and_true_iff _).symm

@[to_additive (attr := simp)]
lemma ker_snd : ker (snd G G') = .prod ‚ä§ ‚ä• := SetLike.ext fun _ => (true_and_iff _).symm

end Ker

section EqLocus

variable {M : Type*} [Monoid M]

/-- The subgroup of elements `x : G` such that `f x = g x` -/
@[to_additive "The additive subgroup of elements `x : G` such that `f x = g x`"]
def eqLocus (f g : G ‚Üí* M) : Subgroup G :=
  { eqLocusM f g with inv_mem' := eq_on_inv f g }
#align monoid_hom.eq_locus MonoidHom.eqLocus
#align add_monoid_hom.eq_locus AddMonoidHom.eqLocus

@[to_additive (attr := simp)]
theorem eqLocus_same (f : G ‚Üí* N) : f.eqLocus f = ‚ä§ :=
  SetLike.ext fun _ => eq_self_iff_true _
#align monoid_hom.eq_locus_same MonoidHom.eqLocus_same
#align add_monoid_hom.eq_locus_same AddMonoidHom.eqLocus_same

/-- If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. -/
@[to_additive
      "If two monoid homomorphisms are equal on a set, then they are equal on its subgroup
      closure."]
theorem eqOn_closure {f g : G ‚Üí* M} {s : Set G} (h : Set.EqOn f g s) : Set.EqOn f g (closure s) :=
  show closure s ‚â§ f.eqLocus g from (closure_le _).2 h
#align monoid_hom.eq_on_closure MonoidHom.eqOn_closure
#align add_monoid_hom.eq_on_closure AddMonoidHom.eqOn_closure

@[to_additive]
theorem eq_of_eqOn_top {f g : G ‚Üí* M} (h : Set.EqOn f g (‚ä§ : Subgroup G)) : f = g :=
  ext fun _x => h trivial
#align monoid_hom.eq_of_eq_on_top MonoidHom.eq_of_eqOn_top
#align add_monoid_hom.eq_of_eq_on_top AddMonoidHom.eq_of_eqOn_top

@[to_additive]
theorem eq_of_eqOn_dense {s : Set G} (hs : closure s = ‚ä§) {f g : G ‚Üí* M} (h : s.EqOn f g) : f = g :=
  eq_of_eqOn_top <| hs ‚ñ∏ eqOn_closure h
#align monoid_hom.eq_of_eq_on_dense MonoidHom.eq_of_eqOn_dense
#align add_monoid_hom.eq_of_eq_on_dense AddMonoidHom.eq_of_eqOn_dense

end EqLocus

@[to_additive]
theorem closure_preimage_le (f : G ‚Üí* N) (s : Set N) : closure (f ‚Åª¬π' s) ‚â§ (closure s).comap f :=
  (closure_le _).2 fun x hx => by rw [SetLike.mem_coe, mem_comap]; exact subset_closure hx
                                  -- ‚ä¢ ‚Üëf x ‚àà closure s
                                                                   -- üéâ no goals
#align monoid_hom.closure_preimage_le MonoidHom.closure_preimage_le
#align add_monoid_hom.closure_preimage_le AddMonoidHom.closure_preimage_le

/-- The image under a monoid homomorphism of the subgroup generated by a set equals the subgroup
generated by the image of the set. -/
@[to_additive
      "The image under an `AddMonoid` hom of the `AddSubgroup` generated by a set equals
      the `AddSubgroup` generated by the image of the set."]
theorem map_closure (f : G ‚Üí* N) (s : Set G) : (closure s).map f = closure (f '' s) :=
  Set.image_preimage.l_comm_of_u_comm (Subgroup.gc_map_comap f) (Subgroup.gi N).gc
    (Subgroup.gi G).gc fun _t => rfl
#align monoid_hom.map_closure MonoidHom.map_closure
#align add_monoid_hom.map_closure AddMonoidHom.map_closure

end MonoidHom

namespace Subgroup

variable {N : Type*} [Group N] (H : Subgroup G)

@[to_additive]
theorem Normal.map {H : Subgroup G} (h : H.Normal) (f : G ‚Üí* N) (hf : Function.Surjective f) :
    (H.map f).Normal := by
  rw [‚Üê normalizer_eq_top, ‚Üê top_le_iff, ‚Üê f.range_top_of_surjective hf, f.range_eq_map, ‚Üê
    normalizer_eq_top.2 h]
  exact le_normalizer_map _
  -- üéâ no goals
#align subgroup.normal.map Subgroup.Normal.map
#align add_subgroup.normal.map AddSubgroup.Normal.map

@[to_additive]
theorem map_eq_bot_iff {f : G ‚Üí* N} : H.map f = ‚ä• ‚Üî H ‚â§ f.ker :=
  (gc_map_comap f).l_eq_bot
#align subgroup.map_eq_bot_iff Subgroup.map_eq_bot_iff
#align add_subgroup.map_eq_bot_iff AddSubgroup.map_eq_bot_iff

@[to_additive]
theorem map_eq_bot_iff_of_injective {f : G ‚Üí* N} (hf : Function.Injective f) :
    H.map f = ‚ä• ‚Üî H = ‚ä• := by rw [map_eq_bot_iff, f.ker_eq_bot_iff.mpr hf, le_bot_iff]
                              -- üéâ no goals
#align subgroup.map_eq_bot_iff_of_injective Subgroup.map_eq_bot_iff_of_injective
#align add_subgroup.map_eq_bot_iff_of_injective AddSubgroup.map_eq_bot_iff_of_injective

end Subgroup

namespace Subgroup

open MonoidHom

variable {N : Type*} [Group N] (f : G ‚Üí* N)

@[to_additive]
theorem map_le_range (H : Subgroup G) : map f H ‚â§ f.range :=
  (range_eq_map f).symm ‚ñ∏ map_mono le_top
#align subgroup.map_le_range Subgroup.map_le_range
#align add_subgroup.map_le_range AddSubgroup.map_le_range

@[to_additive]
theorem map_subtype_le {H : Subgroup G} (K : Subgroup H) : K.map H.subtype ‚â§ H :=
  (K.map_le_range H.subtype).trans (le_of_eq H.subtype_range)
#align subgroup.map_subtype_le Subgroup.map_subtype_le
#align add_subgroup.map_subtype_le AddSubgroup.map_subtype_le

@[to_additive]
theorem ker_le_comap (H : Subgroup N) : f.ker ‚â§ comap f H :=
  comap_bot f ‚ñ∏ comap_mono bot_le
#align subgroup.ker_le_comap Subgroup.ker_le_comap
#align add_subgroup.ker_le_comap AddSubgroup.ker_le_comap

@[to_additive]
theorem map_comap_le (H : Subgroup N) : map f (comap f H) ‚â§ H :=
  (gc_map_comap f).l_u_le _
#align subgroup.map_comap_le Subgroup.map_comap_le
#align add_subgroup.map_comap_le AddSubgroup.map_comap_le

@[to_additive]
theorem le_comap_map (H : Subgroup G) : H ‚â§ comap f (map f H) :=
  (gc_map_comap f).le_u_l _
#align subgroup.le_comap_map Subgroup.le_comap_map
#align add_subgroup.le_comap_map AddSubgroup.le_comap_map

@[to_additive]
theorem map_comap_eq (H : Subgroup N) : map f (comap f H) = f.range ‚äì H :=
  SetLike.ext' <| by
    rw [coe_map, coe_comap, Set.image_preimage_eq_inter_range, coe_inf, coe_range, Set.inter_comm]
    -- üéâ no goals
#align subgroup.map_comap_eq Subgroup.map_comap_eq
#align add_subgroup.map_comap_eq AddSubgroup.map_comap_eq

@[to_additive]
theorem comap_map_eq (H : Subgroup G) : comap f (map f H) = H ‚äî f.ker := by
  refine' le_antisymm _ (sup_le (le_comap_map _ _) (ker_le_comap _ _))
  -- ‚ä¢ comap f (map f H) ‚â§ H ‚äî ker f
  intro x hx; simp only [exists_prop, mem_map, mem_comap] at hx
  -- ‚ä¢ x ‚àà H ‚äî ker f
              -- ‚ä¢ x ‚àà H ‚äî ker f
  rcases hx with ‚ü®y, hy, hy'‚ü©
  -- ‚ä¢ x ‚àà H ‚äî ker f
  rw [‚Üê mul_inv_cancel_left y x]
  -- ‚ä¢ y * (y‚Åª¬π * x) ‚àà H ‚äî ker f
  exact mul_mem_sup hy (by simp [mem_ker, hy'])
  -- üéâ no goals
#align subgroup.comap_map_eq Subgroup.comap_map_eq
#align add_subgroup.comap_map_eq AddSubgroup.comap_map_eq

@[to_additive]
theorem map_comap_eq_self {f : G ‚Üí* N} {H : Subgroup N} (h : H ‚â§ f.range) : map f (comap f H) = H :=
  by rwa [map_comap_eq, inf_eq_right]
     -- üéâ no goals
#align subgroup.map_comap_eq_self Subgroup.map_comap_eq_self
#align add_subgroup.map_comap_eq_self AddSubgroup.map_comap_eq_self

@[to_additive]
theorem map_comap_eq_self_of_surjective {f : G ‚Üí* N} (h : Function.Surjective f) (H : Subgroup N) :
    map f (comap f H) = H :=
  map_comap_eq_self ((range_top_of_surjective _ h).symm ‚ñ∏ le_top)
#align subgroup.map_comap_eq_self_of_surjective Subgroup.map_comap_eq_self_of_surjective
#align add_subgroup.map_comap_eq_self_of_surjective AddSubgroup.map_comap_eq_self_of_surjective

@[to_additive]
theorem comap_le_comap_of_le_range {f : G ‚Üí* N} {K L : Subgroup N} (hf : K ‚â§ f.range) :
    K.comap f ‚â§ L.comap f ‚Üî K ‚â§ L :=
  ‚ü®(map_comap_eq_self hf).ge.trans ‚àò map_le_iff_le_comap.mpr, comap_mono‚ü©
#align subgroup.comap_le_comap_of_le_range Subgroup.comap_le_comap_of_le_range
#align add_subgroup.comap_le_comap_of_le_range AddSubgroup.comap_le_comap_of_le_range

@[to_additive]
theorem comap_le_comap_of_surjective {f : G ‚Üí* N} {K L : Subgroup N} (hf : Function.Surjective f) :
    K.comap f ‚â§ L.comap f ‚Üî K ‚â§ L :=
  comap_le_comap_of_le_range (le_top.trans (f.range_top_of_surjective hf).ge)
#align subgroup.comap_le_comap_of_surjective Subgroup.comap_le_comap_of_surjective
#align add_subgroup.comap_le_comap_of_surjective AddSubgroup.comap_le_comap_of_surjective

@[to_additive]
theorem comap_lt_comap_of_surjective {f : G ‚Üí* N} {K L : Subgroup N} (hf : Function.Surjective f) :
    K.comap f < L.comap f ‚Üî K < L := by simp_rw [lt_iff_le_not_le, comap_le_comap_of_surjective hf]
                                        -- üéâ no goals
#align subgroup.comap_lt_comap_of_surjective Subgroup.comap_lt_comap_of_surjective
#align add_subgroup.comap_lt_comap_of_surjective AddSubgroup.comap_lt_comap_of_surjective

@[to_additive]
theorem comap_injective {f : G ‚Üí* N} (h : Function.Surjective f) : Function.Injective (comap f) :=
  fun K L => by simp only [le_antisymm_iff, comap_le_comap_of_surjective h, imp_self]
                -- üéâ no goals
#align subgroup.comap_injective Subgroup.comap_injective
#align add_subgroup.comap_injective AddSubgroup.comap_injective

@[to_additive]
theorem comap_map_eq_self {f : G ‚Üí* N} {H : Subgroup G} (h : f.ker ‚â§ H) : comap f (map f H) = H :=
  by rwa [comap_map_eq, sup_eq_left]
     -- üéâ no goals
#align subgroup.comap_map_eq_self Subgroup.comap_map_eq_self
#align add_subgroup.comap_map_eq_self AddSubgroup.comap_map_eq_self

@[to_additive]
theorem comap_map_eq_self_of_injective {f : G ‚Üí* N} (h : Function.Injective f) (H : Subgroup G) :
    comap f (map f H) = H :=
  comap_map_eq_self (((ker_eq_bot_iff _).mpr h).symm ‚ñ∏ bot_le)
#align subgroup.comap_map_eq_self_of_injective Subgroup.comap_map_eq_self_of_injective
#align add_subgroup.comap_map_eq_self_of_injective AddSubgroup.comap_map_eq_self_of_injective

@[to_additive]
theorem map_le_map_iff {f : G ‚Üí* N} {H K : Subgroup G} : H.map f ‚â§ K.map f ‚Üî H ‚â§ K ‚äî f.ker := by
  rw [map_le_iff_le_comap, comap_map_eq]
  -- üéâ no goals
#align subgroup.map_le_map_iff Subgroup.map_le_map_iff
#align add_subgroup.map_le_map_iff AddSubgroup.map_le_map_iff

@[to_additive]
theorem map_le_map_iff' {f : G ‚Üí* N} {H K : Subgroup G} :
    H.map f ‚â§ K.map f ‚Üî H ‚äî f.ker ‚â§ K ‚äî f.ker := by
  simp only [map_le_map_iff, sup_le_iff, le_sup_right, and_true_iff]
  -- üéâ no goals
#align subgroup.map_le_map_iff' Subgroup.map_le_map_iff'
#align add_subgroup.map_le_map_iff' AddSubgroup.map_le_map_iff'

@[to_additive]
theorem map_eq_map_iff {f : G ‚Üí* N} {H K : Subgroup G} :
    H.map f = K.map f ‚Üî H ‚äî f.ker = K ‚äî f.ker := by simp only [le_antisymm_iff, map_le_map_iff']
                                                    -- üéâ no goals
#align subgroup.map_eq_map_iff Subgroup.map_eq_map_iff
#align add_subgroup.map_eq_map_iff AddSubgroup.map_eq_map_iff

@[to_additive]
theorem map_eq_range_iff {f : G ‚Üí* N} {H : Subgroup G} : H.map f = f.range ‚Üî Codisjoint H f.ker :=
  by rw [f.range_eq_map, map_eq_map_iff, codisjoint_iff, top_sup_eq]
     -- üéâ no goals
#align subgroup.map_eq_range_iff Subgroup.map_eq_range_iff
#align add_subgroup.map_eq_range_iff AddSubgroup.map_eq_range_iff

@[to_additive]
theorem map_le_map_iff_of_injective {f : G ‚Üí* N} (hf : Function.Injective f) {H K : Subgroup G} :
    H.map f ‚â§ K.map f ‚Üî H ‚â§ K := by rw [map_le_iff_le_comap, comap_map_eq_self_of_injective hf]
                                    -- üéâ no goals
#align subgroup.map_le_map_iff_of_injective Subgroup.map_le_map_iff_of_injective
#align add_subgroup.map_le_map_iff_of_injective AddSubgroup.map_le_map_iff_of_injective

@[to_additive (attr := simp)]
theorem map_subtype_le_map_subtype {G' : Subgroup G} {H K : Subgroup G'} :
    H.map G'.subtype ‚â§ K.map G'.subtype ‚Üî H ‚â§ K :=
  map_le_map_iff_of_injective $ by apply Subtype.coe_injective
                                   -- üéâ no goals
#align subgroup.map_subtype_le_map_subtype Subgroup.map_subtype_le_map_subtype
#align add_subgroup.map_subtype_le_map_subtype AddSubgroup.map_subtype_le_map_subtype

@[to_additive]
theorem map_injective {f : G ‚Üí* N} (h : Function.Injective f) : Function.Injective (map f) :=
  Function.LeftInverse.injective <| comap_map_eq_self_of_injective h
#align subgroup.map_injective Subgroup.map_injective
#align add_subgroup.map_injective AddSubgroup.map_injective

@[to_additive]
theorem map_eq_comap_of_inverse {f : G ‚Üí* N} {g : N ‚Üí* G} (hl : Function.LeftInverse g f)
    (hr : Function.RightInverse g f) (H : Subgroup G) : map f H = comap g H :=
  SetLike.ext' <| by rw [coe_map, coe_comap, Set.image_eq_preimage_of_inverse hl hr]
                     -- üéâ no goals
#align subgroup.map_eq_comap_of_inverse Subgroup.map_eq_comap_of_inverse
#align add_subgroup.map_eq_comap_of_inverse AddSubgroup.map_eq_comap_of_inverse

/-- Given `f(A) = f(B)`, `ker f ‚â§ A`, and `ker f ‚â§ B`, deduce that `A = B`. -/
@[to_additive "Given `f(A) = f(B)`, `ker f ‚â§ A`, and `ker f ‚â§ B`, deduce that `A = B`."]
theorem map_injective_of_ker_le {H K : Subgroup G} (hH : f.ker ‚â§ H) (hK : f.ker ‚â§ K)
    (hf : map f H = map f K) : H = K := by
  apply_fun comap f at hf
  -- ‚ä¢ H = K
  rwa [comap_map_eq, comap_map_eq, sup_of_le_left hH, sup_of_le_left hK] at hf
  -- üéâ no goals
#align subgroup.map_injective_of_ker_le Subgroup.map_injective_of_ker_le
#align add_subgroup.map_injective_of_ker_le AddSubgroup.map_injective_of_ker_le

@[to_additive]
theorem closure_preimage_eq_top (s : Set G) : closure ((closure s).subtype ‚Åª¬π' s) = ‚ä§ := by
  apply map_injective (closure s).subtype_injective
  -- ‚ä¢ map (Subgroup.subtype (closure s)) (closure (‚Üë(Subgroup.subtype (closure s)) ‚Ä¶
  rw [MonoidHom.map_closure, ‚Üê MonoidHom.range_eq_map, subtype_range,
    Set.image_preimage_eq_of_subset]
  rw [coeSubtype, Subtype.range_coe_subtype]
  -- ‚ä¢ s ‚äÜ {x | x ‚àà ‚Üë(closure s)}
  exact subset_closure
  -- üéâ no goals
#align subgroup.closure_preimage_eq_top Subgroup.closure_preimage_eq_top
#align add_subgroup.closure_preimage_eq_top AddSubgroup.closure_preimage_eq_top

@[to_additive]
theorem comap_sup_eq_of_le_range {H K : Subgroup N} (hH : H ‚â§ f.range) (hK : K ‚â§ f.range) :
    comap f H ‚äî comap f K = comap f (H ‚äî K) :=
  map_injective_of_ker_le f ((ker_le_comap f H).trans le_sup_left) (ker_le_comap f (H ‚äî K))
    (by
      rw [map_comap_eq, map_sup, map_comap_eq, map_comap_eq, inf_eq_right.mpr hH,
        inf_eq_right.mpr hK, inf_eq_right.mpr (sup_le hH hK)])
#align subgroup.comap_sup_eq_of_le_range Subgroup.comap_sup_eq_of_le_range
#align add_subgroup.comap_sup_eq_of_le_range AddSubgroup.comap_sup_eq_of_le_range

@[to_additive]
theorem comap_sup_eq (H K : Subgroup N) (hf : Function.Surjective f) :
    comap f H ‚äî comap f K = comap f (H ‚äî K) :=
  comap_sup_eq_of_le_range f (le_top.trans (ge_of_eq (f.range_top_of_surjective hf)))
    (le_top.trans (ge_of_eq (f.range_top_of_surjective hf)))
#align subgroup.comap_sup_eq Subgroup.comap_sup_eq
#align add_subgroup.comap_sup_eq AddSubgroup.comap_sup_eq

@[to_additive]
theorem sup_subgroupOf_eq {H K L : Subgroup G} (hH : H ‚â§ L) (hK : K ‚â§ L) :
    H.subgroupOf L ‚äî K.subgroupOf L = (H ‚äî K).subgroupOf L :=
  comap_sup_eq_of_le_range L.subtype (hH.trans L.subtype_range.ge) (hK.trans L.subtype_range.ge)
#align subgroup.sup_subgroup_of_eq Subgroup.sup_subgroupOf_eq
#align add_subgroup.sup_add_subgroup_of_eq AddSubgroup.sup_addSubgroupOf_eq

@[to_additive]
theorem codisjoint_subgroupOf_sup (H K : Subgroup G) :
    Codisjoint (H.subgroupOf (H ‚äî K)) (K.subgroupOf (H ‚äî K)) := by
  rw [codisjoint_iff, sup_subgroupOf_eq, subgroupOf_self]
  -- ‚ä¢ H ‚â§ H ‚äî K
  exacts [le_sup_left, le_sup_right]
  -- üéâ no goals
#align subgroup.codisjoint_subgroup_of_sup Subgroup.codisjoint_subgroupOf_sup
#align add_subgroup.codisjoint_add_subgroup_of_sup AddSubgroup.codisjoint_addSubgroupOf_sup

/-- A subgroup is isomorphic to its image under an injective function. If you have an isomorphism,
use `MulEquiv.subgroupMap` for better definitional equalities. -/
@[to_additive
      "An additive subgroup is isomorphic to its image under an injective function. If you
      have an isomorphism, use `AddEquiv.addSubgroupMap` for better definitional equalities."]
noncomputable def equivMapOfInjective (H : Subgroup G) (f : G ‚Üí* N) (hf : Function.Injective f) :
    H ‚âÉ* H.map f :=
  { Equiv.Set.image f H hf with map_mul' := fun _ _ => Subtype.ext (f.map_mul _ _) }
#align subgroup.equiv_map_of_injective Subgroup.equivMapOfInjective
#align add_subgroup.equiv_map_of_injective AddSubgroup.equivMapOfInjective

@[to_additive (attr := simp)]
theorem coe_equivMapOfInjective_apply (H : Subgroup G) (f : G ‚Üí* N) (hf : Function.Injective f)
    (h : H) : (equivMapOfInjective H f hf h : N) = f h :=
  rfl
#align subgroup.coe_equiv_map_of_injective_apply Subgroup.coe_equivMapOfInjective_apply
#align add_subgroup.coe_equiv_map_of_injective_apply AddSubgroup.coe_equivMapOfInjective_apply

/-- The preimage of the normalizer is equal to the normalizer of the preimage of a surjective
  function. -/
@[to_additive
      "The preimage of the normalizer is equal to the normalizer of the preimage of
      a surjective function."]
theorem comap_normalizer_eq_of_surjective (H : Subgroup G) {f : N ‚Üí* G}
    (hf : Function.Surjective f) : H.normalizer.comap f = (H.comap f).normalizer :=
  le_antisymm (le_normalizer_comap f)
    (by
      intro x hx
      -- ‚ä¢ x ‚àà comap f (normalizer H)
      simp only [mem_comap, mem_normalizer_iff] at *
      -- ‚ä¢ ‚àÄ (h : G), h ‚àà H ‚Üî ‚Üëf x * h * (‚Üëf x)‚Åª¬π ‚àà H
      intro n
      -- ‚ä¢ n ‚àà H ‚Üî ‚Üëf x * n * (‚Üëf x)‚Åª¬π ‚àà H
      rcases hf n with ‚ü®y, rfl‚ü©
      -- ‚ä¢ ‚Üëf y ‚àà H ‚Üî ‚Üëf x * ‚Üëf y * (‚Üëf x)‚Åª¬π ‚àà H
      simp [hx y])
      -- üéâ no goals
#align subgroup.comap_normalizer_eq_of_surjective Subgroup.comap_normalizer_eq_of_surjective
#align add_subgroup.comap_normalizer_eq_of_surjective AddSubgroup.comap_normalizer_eq_of_surjective

@[to_additive]
theorem comap_normalizer_eq_of_injective_of_le_range {N : Type*} [Group N] (H : Subgroup G)
    {f : N ‚Üí* G} (hf : Function.Injective f) (h : H.normalizer ‚â§ f.range) :
    comap f H.normalizer = (comap f H).normalizer := by
  apply Subgroup.map_injective hf
  -- ‚ä¢ map f (comap f (normalizer H)) = map f (normalizer (comap f H))
  rw [map_comap_eq_self h]
  -- ‚ä¢ normalizer H = map f (normalizer (comap f H))
  apply le_antisymm
  -- ‚ä¢ normalizer H ‚â§ map f (normalizer (comap f H))
  ¬∑ refine' le_trans (le_of_eq _) (map_mono (le_normalizer_comap _))
    -- ‚ä¢ normalizer H = map f (comap f (normalizer H))
    rw [map_comap_eq_self h]
    -- üéâ no goals
  ¬∑ refine' le_trans (le_normalizer_map f) (le_of_eq _)
    -- ‚ä¢ normalizer (map f (comap f H)) = normalizer H
    rw [map_comap_eq_self (le_trans le_normalizer h)]
    -- üéâ no goals
#align subgroup.comap_normalizer_eq_of_injective_of_le_range Subgroup.comap_normalizer_eq_of_injective_of_le_range
#align add_subgroup.comap_normalizer_eq_of_injective_of_le_range AddSubgroup.comap_normalizer_eq_of_injective_of_le_range

@[to_additive]
theorem subgroupOf_normalizer_eq {H N : Subgroup G} (h : H.normalizer ‚â§ N) :
    H.normalizer.subgroupOf N = (H.subgroupOf N).normalizer := by
  apply comap_normalizer_eq_of_injective_of_le_range
  -- ‚ä¢ Injective ‚Üë(Subgroup.subtype N)
  exact Subtype.coe_injective
  -- ‚ä¢ normalizer H ‚â§ range (Subgroup.subtype N)
  simpa
  -- üéâ no goals
#align subgroup.subgroup_of_normalizer_eq Subgroup.subgroupOf_normalizer_eq
#align add_subgroup.add_subgroup_of_normalizer_eq AddSubgroup.addSubgroupOf_normalizer_eq

/-- The image of the normalizer is equal to the normalizer of the image of an isomorphism. -/
@[to_additive
      "The image of the normalizer is equal to the normalizer of the image of an
      isomorphism."]
theorem map_equiv_normalizer_eq (H : Subgroup G) (f : G ‚âÉ* N) :
    H.normalizer.map f.toMonoidHom = (H.map f.toMonoidHom).normalizer := by
  ext x
  -- ‚ä¢ x ‚àà map (MulEquiv.toMonoidHom f) (normalizer H) ‚Üî x ‚àà normalizer (map (MulEq ‚Ä¶
  simp only [mem_normalizer_iff, mem_map_equiv]
  -- ‚ä¢ (‚àÄ (h : G), h ‚àà H ‚Üî ‚Üë(MulEquiv.symm f) x * h * (‚Üë(MulEquiv.symm f) x)‚Åª¬π ‚àà H) ‚Ä¶
  rw [f.toEquiv.forall_congr]
  -- ‚ä¢ ‚àÄ {x_1 : G}, (x_1 ‚àà H ‚Üî ‚Üë(MulEquiv.symm f) x * x_1 * (‚Üë(MulEquiv.symm f) x)‚Åª ‚Ä¶
  intro
  -- ‚ä¢ (x‚úù ‚àà H ‚Üî ‚Üë(MulEquiv.symm f) x * x‚úù * (‚Üë(MulEquiv.symm f) x)‚Åª¬π ‚àà H) ‚Üî (‚Üë(Mul ‚Ä¶
  erw [f.toEquiv.symm_apply_apply]
  -- ‚ä¢ (x‚úù ‚àà H ‚Üî ‚Üë(MulEquiv.symm f) x * x‚úù * (‚Üë(MulEquiv.symm f) x)‚Åª¬π ‚àà H) ‚Üî (x‚úù ‚àà  ‚Ä¶
  simp only [map_mul, map_inv]
  -- ‚ä¢ (x‚úù ‚àà H ‚Üî ‚Üë(MulEquiv.symm f) x * x‚úù * (‚Üë(MulEquiv.symm f) x)‚Åª¬π ‚àà H) ‚Üî (x‚úù ‚àà  ‚Ä¶
  erw [f.toEquiv.symm_apply_apply]
  -- üéâ no goals
#align subgroup.map_equiv_normalizer_eq Subgroup.map_equiv_normalizer_eq
#align add_subgroup.map_equiv_normalizer_eq AddSubgroup.map_equiv_normalizer_eq

/-- The image of the normalizer is equal to the normalizer of the image of a bijective
  function. -/
@[to_additive
      "The image of the normalizer is equal to the normalizer of the image of a bijective
        function."]
theorem map_normalizer_eq_of_bijective (H : Subgroup G) {f : G ‚Üí* N} (hf : Function.Bijective f) :
    H.normalizer.map f = (H.map f).normalizer :=
  map_equiv_normalizer_eq H (MulEquiv.ofBijective f hf)
#align subgroup.map_normalizer_eq_of_bijective Subgroup.map_normalizer_eq_of_bijective
#align add_subgroup.map_normalizer_eq_of_bijective AddSubgroup.map_normalizer_eq_of_bijective

end Subgroup

namespace MonoidHom

variable {G‚ÇÅ G‚ÇÇ G‚ÇÉ : Type*} [Group G‚ÇÅ] [Group G‚ÇÇ] [Group G‚ÇÉ]

variable (f : G‚ÇÅ ‚Üí* G‚ÇÇ) (f_inv : G‚ÇÇ ‚Üí G‚ÇÅ)

/-- Auxiliary definition used to define `liftOfRightInverse` -/
@[to_additive "Auxiliary definition used to define `liftOfRightInverse`"]
def liftOfRightInverseAux (hf : Function.RightInverse f_inv f) (g : G‚ÇÅ ‚Üí* G‚ÇÉ) (hg : f.ker ‚â§ g.ker) :
    G‚ÇÇ ‚Üí* G‚ÇÉ where
  toFun b := g (f_inv b)
  map_one' := hg (hf 1)
  map_mul' := by
    intro x y
    -- ‚ä¢ OneHom.toFun { toFun := fun b => ‚Üëg (f_inv b), map_one' := (_ : f_inv 1 ‚àà ke ‚Ä¶
    rw [‚Üê g.map_mul, ‚Üê mul_inv_eq_one, ‚Üê g.map_inv, ‚Üê g.map_mul, ‚Üê g.mem_ker]
    -- ‚ä¢ f_inv (x * y) * (f_inv x * f_inv y)‚Åª¬π ‚àà ker g
    apply hg
    -- ‚ä¢ f_inv (x * y) * (f_inv x * f_inv y)‚Åª¬π ‚àà ker f
    rw [f.mem_ker, f.map_mul, f.map_inv, mul_inv_eq_one, f.map_mul]
    -- ‚ä¢ ‚Üëf (f_inv (x * y)) = ‚Üëf (f_inv x) * ‚Üëf (f_inv y)
    simp only [hf _]
    -- üéâ no goals
#align monoid_hom.lift_of_right_inverse_aux MonoidHom.liftOfRightInverseAux
#align add_monoid_hom.lift_of_right_inverse_aux AddMonoidHom.liftOfRightInverseAux

@[to_additive (attr := simp)]
theorem liftOfRightInverseAux_comp_apply (hf : Function.RightInverse f_inv f) (g : G‚ÇÅ ‚Üí* G‚ÇÉ)
    (hg : f.ker ‚â§ g.ker) (x : G‚ÇÅ) : (f.liftOfRightInverseAux f_inv hf g hg) (f x) = g x := by
  dsimp [liftOfRightInverseAux]
  -- ‚ä¢ ‚Üëg (f_inv (‚Üëf x)) = ‚Üëg x
  rw [‚Üê mul_inv_eq_one, ‚Üê g.map_inv, ‚Üê g.map_mul, ‚Üê g.mem_ker]
  -- ‚ä¢ f_inv (‚Üëf x) * x‚Åª¬π ‚àà ker g
  apply hg
  -- ‚ä¢ f_inv (‚Üëf x) * x‚Åª¬π ‚àà ker f
  rw [f.mem_ker, f.map_mul, f.map_inv, mul_inv_eq_one]
  -- ‚ä¢ ‚Üëf (f_inv (‚Üëf x)) = ‚Üëf x
  simp only [hf _]
  -- üéâ no goals
#align monoid_hom.lift_of_right_inverse_aux_comp_apply MonoidHom.liftOfRightInverseAux_comp_apply
#align add_monoid_hom.lift_of_right_inverse_aux_comp_apply AddMonoidHom.liftOfRightInverseAux_comp_apply

/-- `liftOfRightInverse f hf g hg` is the unique group homomorphism `œÜ`

* such that `œÜ.comp f = g` (`MonoidHom.liftOfRightInverse_comp`),
* where `f : G‚ÇÅ ‚Üí+* G‚ÇÇ` has a RightInverse `f_inv` (`hf`),
* and `g : G‚ÇÇ ‚Üí+* G‚ÇÉ` satisfies `hg : f.ker ‚â§ g.ker`.

See `MonoidHom.eq_liftOfRightInverse` for the uniqueness lemma.

```
   G‚ÇÅ.
   |  \
 f |   \ g
   |    \
   v     \‚åü
   G‚ÇÇ----> G‚ÇÉ
      ‚àÉ!œÜ
```
 -/
@[to_additive
      "`liftOfRightInverse f f_inv hf g hg` is the unique additive group homomorphism `œÜ`
      * such that `œÜ.comp f = g` (`AddMonoidHom.liftOfRightInverse_comp`),
      * where `f : G‚ÇÅ ‚Üí+ G‚ÇÇ` has a RightInverse `f_inv` (`hf`),
      * and `g : G‚ÇÇ ‚Üí+ G‚ÇÉ` satisfies `hg : f.ker ‚â§ g.ker`.
      See `AddMonoidHom.eq_liftOfRightInverse` for the uniqueness lemma.
      ```
         G‚ÇÅ.
         |  \\
       f |   \\ g
         |    \\
         v     \\‚åü
         G‚ÇÇ----> G‚ÇÉ
            ‚àÉ!œÜ
      ```"]
def liftOfRightInverse (hf : Function.RightInverse f_inv f) :
    { g : G‚ÇÅ ‚Üí* G‚ÇÉ // f.ker ‚â§ g.ker } ‚âÉ (G‚ÇÇ ‚Üí* G‚ÇÉ)
    where
  toFun g := f.liftOfRightInverseAux f_inv hf g.1 g.2
  invFun œÜ := ‚ü®œÜ.comp f, fun x hx => (mem_ker _).mpr <| by simp [(mem_ker _).mp hx]‚ü©
                                                           -- üéâ no goals
  left_inv g := by
    ext
    -- ‚ä¢ ‚Üë‚Üë((fun œÜ => { val := comp œÜ f, property := (_ : ‚àÄ (x : G‚ÇÅ), x ‚àà ker f ‚Üí x ‚àà ‚Ä¶
    simp only [comp_apply, liftOfRightInverseAux_comp_apply, Subtype.coe_mk]
    -- üéâ no goals
  right_inv œÜ := by
    ext b
    -- ‚ä¢ ‚Üë((fun g => liftOfRightInverseAux f f_inv hf ‚Üëg (_ : ker f ‚â§ ker ‚Üëg)) ((fun  ‚Ä¶
    simp [liftOfRightInverseAux, hf b]
    -- üéâ no goals
#align monoid_hom.lift_of_right_inverse MonoidHom.liftOfRightInverse
#align add_monoid_hom.lift_of_right_inverse AddMonoidHom.liftOfRightInverse

/-- A non-computable version of `MonoidHom.liftOfRightInverse` for when no computable right
inverse is available, that uses `Function.surjInv`. -/
@[to_additive (attr := simp)
      "A non-computable version of `AddMonoidHom.liftOfRightInverse` for when no
      computable right inverse is available."]
noncomputable abbrev liftOfSurjective (hf : Function.Surjective f) :
    { g : G‚ÇÅ ‚Üí* G‚ÇÉ // f.ker ‚â§ g.ker } ‚âÉ (G‚ÇÇ ‚Üí* G‚ÇÉ) :=
  f.liftOfRightInverse (Function.surjInv hf) (Function.rightInverse_surjInv hf)
#align monoid_hom.lift_of_surjective MonoidHom.liftOfSurjective
#align add_monoid_hom.lift_of_surjective AddMonoidHom.liftOfSurjective

@[to_additive (attr := simp)]
theorem liftOfRightInverse_comp_apply (hf : Function.RightInverse f_inv f)
    (g : { g : G‚ÇÅ ‚Üí* G‚ÇÉ // f.ker ‚â§ g.ker }) (x : G‚ÇÅ) :
    (f.liftOfRightInverse f_inv hf g) (f x) = g.1 x :=
  f.liftOfRightInverseAux_comp_apply f_inv hf g.1 g.2 x
#align monoid_hom.lift_of_right_inverse_comp_apply MonoidHom.liftOfRightInverse_comp_apply
#align add_monoid_hom.lift_of_right_inverse_comp_apply AddMonoidHom.liftOfRightInverse_comp_apply

@[to_additive (attr := simp)]
theorem liftOfRightInverse_comp (hf : Function.RightInverse f_inv f)
    (g : { g : G‚ÇÅ ‚Üí* G‚ÇÉ // f.ker ‚â§ g.ker }) : (f.liftOfRightInverse f_inv hf g).comp f = g :=
  MonoidHom.ext <| f.liftOfRightInverse_comp_apply f_inv hf g
#align monoid_hom.lift_of_right_inverse_comp MonoidHom.liftOfRightInverse_comp
#align add_monoid_hom.lift_of_right_inverse_comp AddMonoidHom.liftOfRightInverse_comp

@[to_additive]
theorem eq_liftOfRightInverse (hf : Function.RightInverse f_inv f) (g : G‚ÇÅ ‚Üí* G‚ÇÉ)
    (hg : f.ker ‚â§ g.ker) (h : G‚ÇÇ ‚Üí* G‚ÇÉ) (hh : h.comp f = g) :
    h = f.liftOfRightInverse f_inv hf ‚ü®g, hg‚ü© := by
  simp_rw [‚Üê hh]
  -- ‚ä¢ h = ‚Üë(liftOfRightInverse f f_inv hf) { val := comp h f, property := (_ : (fu ‚Ä¶
  exact ((f.liftOfRightInverse f_inv hf).apply_symm_apply _).symm
  -- üéâ no goals
#align monoid_hom.eq_lift_of_right_inverse MonoidHom.eq_liftOfRightInverse
#align add_monoid_hom.eq_lift_of_right_inverse AddMonoidHom.eq_liftOfRightInverse

end MonoidHom

variable {N : Type*} [Group N]

-- Here `H.Normal` is an explicit argument so we can use dot notation with `comap`.
@[to_additive]
theorem Subgroup.Normal.comap {H : Subgroup N} (hH : H.Normal) (f : G ‚Üí* N) : (H.comap f).Normal :=
  ‚ü®fun _ => by simp (config := { contextual := true }) [Subgroup.mem_comap, hH.conj_mem]‚ü©
               -- üéâ no goals
#align subgroup.normal.comap Subgroup.Normal.comap
#align add_subgroup.normal.comap AddSubgroup.Normal.comap

@[to_additive]
instance (priority := 100) Subgroup.normal_comap {H : Subgroup N} [nH : H.Normal] (f : G ‚Üí* N) :
    (H.comap f).Normal :=
  nH.comap _
#align subgroup.normal_comap Subgroup.normal_comap
#align add_subgroup.normal_comap AddSubgroup.normal_comap

-- Here `H.Normal` is an explicit argument so we can use dot notation with `subgroupOf`.
@[to_additive]
theorem Subgroup.Normal.subgroupOf {H : Subgroup G} (hH : H.Normal) (K : Subgroup G) :
    (H.subgroupOf K).Normal :=
  hH.comap _
#align subgroup.normal.subgroup_of Subgroup.Normal.subgroupOf
#align add_subgroup.normal.add_subgroup_of AddSubgroup.Normal.addSubgroupOf

@[to_additive]
instance (priority := 100) Subgroup.normal_subgroupOf {H N : Subgroup G} [N.Normal] :
    (N.subgroupOf H).Normal :=
  Subgroup.normal_comap _
#align subgroup.normal_subgroup_of Subgroup.normal_subgroupOf
#align add_subgroup.normal_add_subgroup_of AddSubgroup.normal_addSubgroupOf

namespace MonoidHom

/-- The `MonoidHom` from the preimage of a subgroup to itself. -/
@[to_additive (attr := simps!) "the `AddMonoidHom` from the preimage of an
additive subgroup to itself."]
def subgroupComap (f : G ‚Üí* G') (H' : Subgroup G') : H'.comap f ‚Üí* H' :=
  f.submonoidComap H'.toSubmonoid
#align monoid_hom.subgroup_comap MonoidHom.subgroupComap
#align add_monoid_hom.add_subgroup_comap AddMonoidHom.addSubgroupComap
#align add_monoid_hom.add_subgroup_comap_apply_coe AddMonoidHom.addSubgroupComap_apply_coe
#align monoid_hom.subgroup_comap_apply_coe MonoidHom.subgroupComap_apply_coe

/-- The `MonoidHom` from a subgroup to its image. -/
@[to_additive (attr := simps!) "the `AddMonoidHom` from an additive subgroup to its image"]
def subgroupMap (f : G ‚Üí* G') (H : Subgroup G) : H ‚Üí* H.map f :=
  f.submonoidMap H.toSubmonoid
#align monoid_hom.subgroup_map MonoidHom.subgroupMap
#align add_monoid_hom.add_subgroup_map AddMonoidHom.addSubgroupMap
#align add_monoid_hom.add_subgroup_map_apply_coe AddMonoidHom.addSubgroupMap_apply_coe
#align monoid_hom.subgroup_map_apply_coe MonoidHom.subgroupMap_apply_coe

@[to_additive]
theorem subgroupMap_surjective (f : G ‚Üí* G') (H : Subgroup G) :
    Function.Surjective (f.subgroupMap H) :=
  f.submonoidMap_surjective H.toSubmonoid
#align monoid_hom.subgroup_map_surjective MonoidHom.subgroupMap_surjective
#align add_monoid_hom.add_subgroup_map_surjective AddMonoidHom.addSubgroupMap_surjective

end MonoidHom

namespace MulEquiv

variable {H K : Subgroup G}

/-- Makes the identity isomorphism from a proof two subgroups of a multiplicative
    group are equal. -/
@[to_additive
      "Makes the identity additive isomorphism from a proof
      two subgroups of an additive group are equal."]
def subgroupCongr (h : H = K) : H ‚âÉ* K :=
  { Equiv.setCongr <| congr_arg _ h with map_mul' := fun _ _ => rfl }
#align mul_equiv.subgroup_congr MulEquiv.subgroupCongr
#align add_equiv.add_subgroup_congr AddEquiv.addSubgroupCongr

/-- A subgroup is isomorphic to its image under an isomorphism. If you only have an injective map,
use `Subgroup.equiv_map_of_injective`. -/
@[to_additive
      "An additive subgroup is isomorphic to its image under an isomorphism. If you only
      have an injective map, use `AddSubgroup.equiv_map_of_injective`."]
def subgroupMap (e : G ‚âÉ* G') (H : Subgroup G) : H ‚âÉ* H.map (e : G ‚Üí* G') :=
  MulEquiv.submonoidMap (e : G ‚âÉ* G') H.toSubmonoid
#align mul_equiv.subgroup_map MulEquiv.subgroupMap
#align add_equiv.add_subgroup_map AddEquiv.addSubgroupMap

@[to_additive (attr := simp)]
theorem coe_subgroupMap_apply (e : G ‚âÉ* G') (H : Subgroup G) (g : H) :
    ((subgroupMap e H g : H.map (e : G ‚Üí* G')) : G') = e g :=
  rfl
#align mul_equiv.coe_subgroup_map_apply MulEquiv.coe_subgroupMap_apply
#align add_equiv.coe_add_subgroup_map_apply AddEquiv.coe_addSubgroupMap_apply

@[to_additive (attr := simp)]
theorem subgroupMap_symm_apply (e : G ‚âÉ* G') (H : Subgroup G) (g : H.map (e : G ‚Üí* G')) :
    (e.subgroupMap H).symm g = ‚ü®e.symm g, SetLike.mem_coe.1 <| Set.mem_image_equiv.1 g.2‚ü© :=
  rfl
#align mul_equiv.subgroup_map_symm_apply MulEquiv.subgroupMap_symm_apply
#align add_equiv.add_subgroup_map_symm_apply AddEquiv.addSubgroupMap_symm_apply

end MulEquiv

namespace Subgroup

@[to_additive (attr := simp)]
theorem equivMapOfInjective_coe_mulEquiv (H : Subgroup G) (e : G ‚âÉ* G') :
    H.equivMapOfInjective (e : G ‚Üí* G') (EquivLike.injective e) = e.subgroupMap H := by
  ext
  -- ‚ä¢ ‚Üë(‚Üë(equivMapOfInjective H ‚Üëe (_ : Injective ‚Üëe)) x‚úù) = ‚Üë(‚Üë(MulEquiv.subgroup ‚Ä¶
  rfl
  -- üéâ no goals
#align subgroup.equiv_map_of_injective_coe_mul_equiv Subgroup.equivMapOfInjective_coe_mulEquiv
#align add_subgroup.equiv_map_of_injective_coe_add_equiv AddSubgroup.equivMapOfInjective_coe_addEquiv

variable {C : Type*} [CommGroup C] {s t : Subgroup C} {x : C}

@[to_additive]
theorem mem_sup : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z = x :=
  ‚ü®fun h => by
    rw [‚Üê closure_eq s, ‚Üê closure_eq t, ‚Üê closure_union] at h
    -- ‚ä¢ ‚àÉ y, y ‚àà s ‚àß ‚àÉ z, z ‚àà t ‚àß y * z = x
    refine Subgroup.closure_induction h ?_ ?_ ?_ ?_
    ¬∑ rintro y (h | h)
      -- ‚ä¢ ‚àÉ y_1, y_1 ‚àà s ‚àß ‚àÉ z, z ‚àà t ‚àß y_1 * z = y
      ¬∑ exact ‚ü®y, h, 1, t.one_mem, by simp‚ü©
        -- üéâ no goals
      ¬∑ exact ‚ü®1, s.one_mem, y, h, by simp‚ü©
        -- üéâ no goals
    ¬∑ exact ‚ü®1, s.one_mem, 1, ‚ü®t.one_mem, mul_one 1‚ü©‚ü©
      -- üéâ no goals
    ¬∑ rintro _ _ ‚ü®y‚ÇÅ, hy‚ÇÅ, z‚ÇÅ, hz‚ÇÅ, rfl‚ü© ‚ü®y‚ÇÇ, hy‚ÇÇ, z‚ÇÇ, hz‚ÇÇ, rfl‚ü©
      -- ‚ä¢ ‚àÉ y, y ‚àà s ‚àß ‚àÉ z, z ‚àà t ‚àß y * z = y‚ÇÅ * z‚ÇÅ * (y‚ÇÇ * z‚ÇÇ)
      exact ‚ü®_, mul_mem hy‚ÇÅ hy‚ÇÇ, _, mul_mem hz‚ÇÅ hz‚ÇÇ, by simp [mul_assoc, mul_left_comm]‚ü©
      -- üéâ no goals
    ¬∑ rintro _ ‚ü®y, hy, z, hz, rfl‚ü©
      -- ‚ä¢ ‚àÉ y_1, y_1 ‚àà s ‚àß ‚àÉ z_1, z_1 ‚àà t ‚àß y_1 * z_1 = (y * z)‚Åª¬π
      exact ‚ü®_, inv_mem hy, _, inv_mem hz, mul_comm z y ‚ñ∏ (mul_inv_rev z y).symm‚ü©, by
      -- üéâ no goals
    rintro ‚ü®y, hy, z, hz, rfl‚ü©; exact mul_mem_sup hy hz‚ü©
    -- ‚ä¢ y * z ‚àà s ‚äî t
                                -- üéâ no goals
#align subgroup.mem_sup Subgroup.mem_sup
#align add_subgroup.mem_sup AddSubgroup.mem_sup

@[to_additive]
theorem mem_sup' : x ‚àà s ‚äî t ‚Üî ‚àÉ (y : s) (z : t), (y : C) * z = x :=
  mem_sup.trans <| by simp only [SetLike.exists, coe_mk, exists_prop]
                      -- üéâ no goals
#align subgroup.mem_sup' Subgroup.mem_sup'
#align add_subgroup.mem_sup' AddSubgroup.mem_sup'

@[to_additive]
theorem mem_closure_pair {x y z : C} :
    z ‚àà closure ({x, y} : Set C) ‚Üî ‚àÉ m n : ‚Ñ§, x ^ m * y ^ n = z := by
  rw [‚Üê Set.singleton_union, Subgroup.closure_union, mem_sup]
  -- ‚ä¢ (‚àÉ y_1, y_1 ‚àà closure {x} ‚àß ‚àÉ z_1, z_1 ‚àà closure {y} ‚àß y_1 * z_1 = z) ‚Üî ‚àÉ m  ‚Ä¶
  simp_rw [mem_closure_singleton, exists_exists_eq_and]
  -- üéâ no goals
#align subgroup.mem_closure_pair Subgroup.mem_closure_pair
#align add_subgroup.mem_closure_pair AddSubgroup.mem_closure_pair

@[to_additive]
instance : IsModularLattice (Subgroup C) :=
  ‚ü®fun {x} y z xz a ha => by
    rw [mem_inf, mem_sup] at ha
    -- ‚ä¢ a ‚àà x ‚äî y ‚äì z
    rcases ha with ‚ü®‚ü®b, hb, c, hc, rfl‚ü©, haz‚ü©
    -- ‚ä¢ b * c ‚àà x ‚äî y ‚äì z
    rw [mem_sup]
    -- ‚ä¢ ‚àÉ y_1, y_1 ‚àà x ‚àß ‚àÉ z_1, z_1 ‚àà y ‚äì z ‚àß y_1 * z_1 = b * c
    exact ‚ü®b, hb, c, mem_inf.2 ‚ü®hc, (mul_mem_cancel_left (xz hb)).1 haz‚ü©, rfl‚ü©‚ü©
    -- üéâ no goals

end Subgroup

namespace Subgroup

section SubgroupNormal

@[to_additive]
theorem normal_subgroupOf_iff {H K : Subgroup G} (hHK : H ‚â§ K) :
    (H.subgroupOf K).Normal ‚Üî ‚àÄ h k, h ‚àà H ‚Üí k ‚àà K ‚Üí k * h * k‚Åª¬π ‚àà H :=
  ‚ü®fun hN h k hH hK => hN.conj_mem ‚ü®h, hHK hH‚ü© hH ‚ü®k, hK‚ü©, fun hN =>
    { conj_mem := fun h hm k => hN h.1 k.1 hm k.2 }‚ü©
#align subgroup.normal_subgroup_of_iff Subgroup.normal_subgroupOf_iff
#align add_subgroup.normal_add_subgroup_of_iff AddSubgroup.normal_addSubgroupOf_iff

@[to_additive]
instance prod_subgroupOf_prod_normal {H‚ÇÅ K‚ÇÅ : Subgroup G} {H‚ÇÇ K‚ÇÇ : Subgroup N}
    [h‚ÇÅ : (H‚ÇÅ.subgroupOf K‚ÇÅ).Normal] [h‚ÇÇ : (H‚ÇÇ.subgroupOf K‚ÇÇ).Normal] :
    ((H‚ÇÅ.prod H‚ÇÇ).subgroupOf (K‚ÇÅ.prod K‚ÇÇ)).Normal where
  conj_mem n hgHK g :=
    ‚ü®h‚ÇÅ.conj_mem ‚ü®(n : G √ó N).fst, (mem_prod.mp n.2).1‚ü© hgHK.1
        ‚ü®(g : G √ó N).fst, (mem_prod.mp g.2).1‚ü©,
      h‚ÇÇ.conj_mem ‚ü®(n : G √ó N).snd, (mem_prod.mp n.2).2‚ü© hgHK.2
        ‚ü®(g : G √ó N).snd, (mem_prod.mp g.2).2‚ü©‚ü©
#align subgroup.prod_subgroup_of_prod_normal Subgroup.prod_subgroupOf_prod_normal
#align add_subgroup.sum_add_subgroup_of_sum_normal AddSubgroup.sum_addSubgroupOf_sum_normal

@[to_additive]
instance prod_normal (H : Subgroup G) (K : Subgroup N) [hH : H.Normal] [hK : K.Normal] :
    (H.prod K).Normal
    where conj_mem n hg g :=
    ‚ü®hH.conj_mem n.fst (Subgroup.mem_prod.mp hg).1 g.fst,
      hK.conj_mem n.snd (Subgroup.mem_prod.mp hg).2 g.snd‚ü©
#align subgroup.prod_normal Subgroup.prod_normal
#align add_subgroup.sum_normal AddSubgroup.sum_normal

@[to_additive]
theorem inf_subgroupOf_inf_normal_of_right (A B' B : Subgroup G) (hB : B' ‚â§ B)
    [hN : (B'.subgroupOf B).Normal] : ((A ‚äì B').subgroupOf (A ‚äì B)).Normal :=
  { conj_mem := fun {n} hn g =>
      ‚ü®mul_mem (mul_mem (mem_inf.1 g.2).1 (mem_inf.1 n.2).1) $
        show ‚Üëg‚Åª¬π ‚àà A from (inv_mem (mem_inf.1 g.2).1),
        (normal_subgroupOf_iff hB).mp hN n g hn.2 (mem_inf.mp g.2).2‚ü© }
#align subgroup.inf_subgroup_of_inf_normal_of_right Subgroup.inf_subgroupOf_inf_normal_of_right
#align add_subgroup.inf_add_subgroup_of_inf_normal_of_right AddSubgroup.inf_addSubgroupOf_inf_normal_of_right

@[to_additive]
theorem inf_subgroupOf_inf_normal_of_left {A' A : Subgroup G} (B : Subgroup G) (hA : A' ‚â§ A)
    [hN : (A'.subgroupOf A).Normal] : ((A' ‚äì B).subgroupOf (A ‚äì B)).Normal :=
  { conj_mem := fun n hn g =>
      ‚ü®(normal_subgroupOf_iff hA).mp hN n g hn.1 (mem_inf.mp g.2).1,
        mul_mem (mul_mem (mem_inf.1 g.2).2 (mem_inf.1 n.2).2) $
        show ‚Üëg‚Åª¬π ‚àà B from (inv_mem (mem_inf.1 g.2).2)‚ü© }
#align subgroup.inf_subgroup_of_inf_normal_of_left Subgroup.inf_subgroupOf_inf_normal_of_left
#align add_subgroup.inf_add_subgroup_of_inf_normal_of_left AddSubgroup.inf_addSubgroupOf_inf_normal_of_left

@[to_additive]
instance normal_inf_normal (H K : Subgroup G) [hH : H.Normal] [hK : K.Normal] : (H ‚äì K).Normal :=
  ‚ü®fun n hmem g => ‚ü®hH.conj_mem n hmem.1 g, hK.conj_mem n hmem.2 g‚ü©‚ü©
#align subgroup.normal_inf_normal Subgroup.normal_inf_normal
#align add_subgroup.normal_inf_normal AddSubgroup.normal_inf_normal

@[to_additive]
theorem subgroupOf_sup (A A' B : Subgroup G) (hA : A ‚â§ B) (hA' : A' ‚â§ B) :
    (A ‚äî A').subgroupOf B = A.subgroupOf B ‚äî A'.subgroupOf B := by
  refine'
    map_injective_of_ker_le B.subtype (ker_le_comap _ _)
      (le_trans (ker_le_comap B.subtype _) le_sup_left) _
  ¬∑ simp only [subgroupOf, map_comap_eq, map_sup, subtype_range]
    -- ‚ä¢ B ‚äì (A ‚äî A') = B ‚äì A ‚äî B ‚äì A'
    rw [inf_of_le_right (sup_le hA hA'), inf_of_le_right hA', inf_of_le_right hA]
    -- üéâ no goals
#align subgroup.subgroup_of_sup Subgroup.subgroupOf_sup
#align add_subgroup.add_subgroup_of_sup AddSubgroup.addSubgroupOf_sup

@[to_additive]
theorem SubgroupNormal.mem_comm {H K : Subgroup G} (hK : H ‚â§ K) [hN : (H.subgroupOf K).Normal]
    {a b : G} (hb : b ‚àà K) (h : a * b ‚àà H) : b * a ‚àà H := by
  have := (normal_subgroupOf_iff hK).mp hN (a * b) b h hb
  -- ‚ä¢ b * a ‚àà H
  rwa [mul_assoc, mul_assoc, mul_right_inv, mul_one] at this
  -- üéâ no goals
#align subgroup.subgroup_normal.mem_comm Subgroup.SubgroupNormal.mem_comm
#align add_subgroup.subgroup_normal.mem_comm AddSubgroup.SubgroupNormal.mem_comm

/-- Elements of disjoint, normal subgroups commute. -/
@[to_additive "Elements of disjoint, normal subgroups commute."]
theorem commute_of_normal_of_disjoint (H‚ÇÅ H‚ÇÇ : Subgroup G) (hH‚ÇÅ : H‚ÇÅ.Normal) (hH‚ÇÇ : H‚ÇÇ.Normal)
    -- Porting note: Goal was `Commute x y`. Removed ambiguity.
    (hdis : Disjoint H‚ÇÅ H‚ÇÇ) (x y : G) (hx : x ‚àà H‚ÇÅ) (hy : y ‚àà H‚ÇÇ) : Commute x y := by
  suffices x * y * x‚Åª¬π * y‚Åª¬π = 1 by
    show x * y = y * x
    ¬∑ rw [mul_assoc, mul_eq_one_iff_eq_inv] at this
      -- Porting note: Previous code was:
      -- simpa
      simp only [this, mul_inv_rev, inv_inv]
  apply hdis.le_bot
  -- ‚ä¢ x * y * x‚Åª¬π * y‚Åª¬π ‚àà H‚ÇÅ ‚äì H‚ÇÇ
  constructor
  -- ‚ä¢ x * y * x‚Åª¬π * y‚Åª¬π ‚àà ‚ÜëH‚ÇÅ.toSubmonoid
  ¬∑ suffices x * (y * x‚Åª¬π * y‚Åª¬π) ‚àà H‚ÇÅ by simpa [mul_assoc]
    -- ‚ä¢ x * (y * x‚Åª¬π * y‚Åª¬π) ‚àà H‚ÇÅ
    exact H‚ÇÅ.mul_mem hx (hH‚ÇÅ.conj_mem _ (H‚ÇÅ.inv_mem hx) _)
    -- üéâ no goals
  ¬∑ show x * y * x‚Åª¬π * y‚Åª¬π ‚àà H‚ÇÇ
    -- ‚ä¢ x * y * x‚Åª¬π * y‚Åª¬π ‚àà H‚ÇÇ
    apply H‚ÇÇ.mul_mem _ (H‚ÇÇ.inv_mem hy)
    -- ‚ä¢ x * y * x‚Åª¬π ‚àà H‚ÇÇ
    apply hH‚ÇÇ.conj_mem _ hy
    -- üéâ no goals
#align subgroup.commute_of_normal_of_disjoint Subgroup.commute_of_normal_of_disjoint
#align add_subgroup.commute_of_normal_of_disjoint AddSubgroup.commute_of_normal_of_disjoint

end SubgroupNormal

@[to_additive]
theorem disjoint_def {H‚ÇÅ H‚ÇÇ : Subgroup G} : Disjoint H‚ÇÅ H‚ÇÇ ‚Üî ‚àÄ {x : G}, x ‚àà H‚ÇÅ ‚Üí x ‚àà H‚ÇÇ ‚Üí x = 1 :=
  disjoint_iff_inf_le.trans <| by simp only [Disjoint, SetLike.le_def, mem_inf, mem_bot, and_imp]
                                  -- üéâ no goals
#align subgroup.disjoint_def Subgroup.disjoint_def
#align add_subgroup.disjoint_def AddSubgroup.disjoint_def

@[to_additive]
theorem disjoint_def' {H‚ÇÅ H‚ÇÇ : Subgroup G} :
    Disjoint H‚ÇÅ H‚ÇÇ ‚Üî ‚àÄ {x y : G}, x ‚àà H‚ÇÅ ‚Üí y ‚àà H‚ÇÇ ‚Üí x = y ‚Üí x = 1 :=
  disjoint_def.trans ‚ü®fun h _x _y hx hy hxy ‚Ü¶ h hx <| hxy.symm ‚ñ∏ hy, fun h _x hx hx' ‚Ü¶ h hx hx' rfl‚ü©
#align subgroup.disjoint_def' Subgroup.disjoint_def'
#align add_subgroup.disjoint_def' AddSubgroup.disjoint_def'

@[to_additive]
theorem disjoint_iff_mul_eq_one {H‚ÇÅ H‚ÇÇ : Subgroup G} :
    Disjoint H‚ÇÅ H‚ÇÇ ‚Üî ‚àÄ {x y : G}, x ‚àà H‚ÇÅ ‚Üí y ‚àà H‚ÇÇ ‚Üí x * y = 1 ‚Üí x = 1 ‚àß y = 1 :=
  disjoint_def'.trans
    ‚ü®fun h x y hx hy hxy =>
      let hx1 : x = 1 := h hx (H‚ÇÇ.inv_mem hy) (eq_inv_iff_mul_eq_one.mpr hxy)
      ‚ü®hx1, by simpa [hx1] using hxy‚ü©,
               -- üéâ no goals
      fun h x y hx hy hxy => (h hx (H‚ÇÇ.inv_mem hy) (mul_inv_eq_one.mpr hxy)).1‚ü©
#align subgroup.disjoint_iff_mul_eq_one Subgroup.disjoint_iff_mul_eq_one
#align add_subgroup.disjoint_iff_add_eq_zero AddSubgroup.disjoint_iff_add_eq_zero

@[to_additive]
theorem mul_injective_of_disjoint {H‚ÇÅ H‚ÇÇ : Subgroup G} (h : Disjoint H‚ÇÅ H‚ÇÇ) :
    Function.Injective (fun g => g.1 * g.2 : H‚ÇÅ √ó H‚ÇÇ ‚Üí G) := by
  intro x y hxy
  -- ‚ä¢ x = y
  rw [‚Üê inv_mul_eq_iff_eq_mul, ‚Üê mul_assoc, ‚Üê mul_inv_eq_one, mul_assoc] at hxy
  -- ‚ä¢ x = y
  replace hxy := disjoint_iff_mul_eq_one.mp h (y.1‚Åª¬π * x.1).prop (x.2 * y.2‚Åª¬π).prop hxy
  -- ‚ä¢ x = y
  rwa [coe_mul, coe_mul, coe_inv, coe_inv, inv_mul_eq_one, mul_inv_eq_one, ‚Üê Subtype.ext_iff, ‚Üê
    Subtype.ext_iff, eq_comm, ‚Üê Prod.ext_iff] at hxy
#align subgroup.mul_injective_of_disjoint Subgroup.mul_injective_of_disjoint
#align add_subgroup.add_injective_of_disjoint AddSubgroup.add_injective_of_disjoint

end Subgroup

namespace IsConj

open Subgroup

theorem normalClosure_eq_top_of {N : Subgroup G} [hn : N.Normal] {g g' : G} {hg : g ‚àà N}
    {hg' : g' ‚àà N} (hc : IsConj g g') (ht : normalClosure ({‚ü®g, hg‚ü©} : Set N) = ‚ä§) :
    normalClosure ({‚ü®g', hg'‚ü©} : Set N) = ‚ä§ := by
  obtain ‚ü®c, rfl‚ü© := isConj_iff.1 hc
  -- ‚ä¢ normalClosure {{ val := c * g * c‚Åª¬π, property := hg' }} = ‚ä§
  have h : ‚àÄ x : N, (MulAut.conj c) x ‚àà N := by
    rintro ‚ü®x, hx‚ü©
    exact hn.conj_mem _ hx c
  have hs : Function.Surjective (((MulAut.conj c).toMonoidHom.restrict N).codRestrict _ h) := by
    rintro ‚ü®x, hx‚ü©
    refine' ‚ü®‚ü®c‚Åª¬π * x * c, _‚ü©, _‚ü©
    ¬∑ have h := hn.conj_mem _ hx c‚Åª¬π
      rwa [inv_inv] at h
    simp only [MonoidHom.codRestrict_apply, MulEquiv.coe_toMonoidHom, MulAut.conj_apply, coe_mk,
      MonoidHom.restrict_apply, Subtype.mk_eq_mk, ‚Üê mul_assoc, mul_inv_self, one_mul]
    rw [mul_assoc, mul_inv_self, mul_one]
  rw [eq_top_iff, ‚Üê MonoidHom.range_top_of_surjective _ hs, MonoidHom.range_eq_map]
  -- ‚ä¢ map (MonoidHom.codRestrict (MonoidHom.restrict (MulEquiv.toMonoidHom (‚ÜëMulAu ‚Ä¶
  refine' le_trans (map_mono (eq_top_iff.1 ht)) (map_le_iff_le_comap.2 (normalClosure_le_normal _))
  -- ‚ä¢ {{ val := g, property := hg }} ‚äÜ ‚Üë(comap (MonoidHom.codRestrict (MonoidHom.r ‚Ä¶
  rw [Set.singleton_subset_iff, SetLike.mem_coe]
  -- ‚ä¢ { val := g, property := hg } ‚àà comap (MonoidHom.codRestrict (MonoidHom.restr ‚Ä¶
  simp only [MonoidHom.codRestrict_apply, MulEquiv.coe_toMonoidHom, MulAut.conj_apply, coe_mk,
    MonoidHom.restrict_apply, mem_comap]
  exact subset_normalClosure (Set.mem_singleton _)
  -- üéâ no goals
#align is_conj.normal_closure_eq_top_of IsConj.normalClosure_eq_top_of

variable {M : Type*} [Monoid M]

theorem eq_of_left_mem_center {g h : M} (H : IsConj g h) (Hg : g ‚àà Set.center M) : g = h := by
  rcases H with ‚ü®u, hu‚ü©; rwa [‚Üê u.mul_left_inj, ‚Üê Hg u]
  -- ‚ä¢ g = h
                         -- üéâ no goals
#align is_conj.eq_of_left_mem_center IsConj.eq_of_left_mem_center

theorem eq_of_right_mem_center {g h : M} (H : IsConj g h) (Hh : h ‚àà Set.center M) : g = h :=
  (H.symm.eq_of_left_mem_center Hh).symm
#align is_conj.eq_of_right_mem_center IsConj.eq_of_right_mem_center

end IsConj

namespace ConjClasses

/-- The conjugacy classes that are not trivial. -/
def noncenter (G : Type _) [Monoid G] : Set (ConjClasses G) :=
  {x | x.carrier.Nontrivial}

@[simp] lemma mem_noncenter [Monoid G] (g : ConjClasses G) :
  g ‚àà noncenter G ‚Üî g.carrier.Nontrivial := Iff.rfl

theorem mk_bijOn (G : Type _) [Group G] :
    Set.BijOn ConjClasses.mk (‚Üë(Subgroup.center G)) (noncenter G)·∂ú := by
  refine ‚ü®fun g hg ‚Ü¶ ?_, fun x hx y _ H ‚Ü¶ ?_, ?_‚ü©
  ¬∑ simp only [mem_noncenter, Set.compl_def, Set.mem_setOf, Set.not_nontrivial_iff]
    -- ‚ä¢ Set.Subsingleton (carrier (ConjClasses.mk g))
    intro x hx y hy
    -- ‚ä¢ x = y
    simp only [mem_carrier_iff_mk_eq, mk_eq_mk_iff_isConj] at hx hy
    -- ‚ä¢ x = y
    rw [hx.eq_of_right_mem_center hg, hy.eq_of_right_mem_center hg]
    -- üéâ no goals
  ¬∑ rw [mk_eq_mk_iff_isConj] at H
    -- ‚ä¢ x = y
    exact H.eq_of_left_mem_center hx
    -- üéâ no goals
  ¬∑ rintro ‚ü®g‚ü© hg
    -- ‚ä¢ Quot.mk Setoid.r g ‚àà ConjClasses.mk '' ‚Üë(Subgroup.center G)
    refine ‚ü®g, ?_, rfl‚ü©
    -- ‚ä¢ g ‚àà ‚Üë(Subgroup.center G)
    simp only [mem_noncenter, Set.compl_def, Set.mem_setOf, Set.not_nontrivial_iff] at hg
    -- ‚ä¢ g ‚àà ‚Üë(Subgroup.center G)
    intro h
    -- ‚ä¢ h * g = g * h
    rw [‚Üê mul_inv_eq_iff_eq_mul]
    -- ‚ä¢ h * g * h‚Åª¬π = g
    refine hg ?_ mem_carrier_mk
    -- ‚ä¢ h * g * h‚Åª¬π ‚àà carrier (Quot.mk Setoid.r g)
    rw [mem_carrier_iff_mk_eq]
    -- ‚ä¢ ConjClasses.mk (h * g * h‚Åª¬π) = Quot.mk Setoid.r g
    apply mk_eq_mk_iff_isConj.mpr
    -- ‚ä¢ IsConj (h * g * h‚Åª¬π) g
    rw [isConj_comm, isConj_iff]
    -- ‚ä¢ ‚àÉ c, c * g * c‚Åª¬π = h * g * h‚Åª¬π
    exact ‚ü®h, rfl‚ü©
    -- üéâ no goals

end ConjClasses

assert_not_exists Multiset
