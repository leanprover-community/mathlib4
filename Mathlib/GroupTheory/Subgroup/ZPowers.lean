/-
Copyright (c) 2020 Chris Hughes. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Chris Hughes
-/
import Mathlib.GroupTheory.Subgroup.Basic

#align_import group_theory.subgroup.zpowers from "leanprover-community/mathlib"@"4be589053caf347b899a494da75410deb55fb3ef"

/-!
# Subgroups generated by an element

## Tags
subgroup, subgroups

-/


variable {G : Type*} [Group G]

variable {A : Type*} [AddGroup A]

variable {N : Type*} [Group N]

namespace Subgroup

/-- The subgroup generated by an element. -/
def zpowers (g : G) : Subgroup G :=
  Subgroup.copy (zpowersHom G g).range (Set.range ((Â· ^ Â·) g : â„¤ â†’ G)) rfl
#align subgroup.zpowers Subgroup.zpowers

theorem mem_zpowers (g : G) : g âˆˆ zpowers g :=
  âŸ¨1, zpow_one _âŸ©
#align subgroup.mem_zpowers Subgroup.mem_zpowers

theorem coe_zpowers (g : G) : â†‘(zpowers g) = Set.range (g ^ Â· : â„¤ â†’ G) :=
  rfl
#align subgroup.coe_zpowers Subgroup.coe_zpowers

theorem zpowers_eq_closure (g : G) : zpowers g = closure {g} := by
  ext
  -- âŠ¢ xâœ âˆˆ zpowers g â†” xâœ âˆˆ closure {g}
  exact mem_closure_singleton.symm
  -- ğŸ‰ no goals
#align subgroup.zpowers_eq_closure Subgroup.zpowers_eq_closure

theorem range_zpowersHom (g : G) : (zpowersHom G g).range = zpowers g :=
  rfl
#align subgroup.range_zpowers_hom Subgroup.range_zpowersHom

theorem mem_zpowers_iff {g h : G} : h âˆˆ zpowers g â†” âˆƒ k : â„¤, g ^ k = h :=
  Iff.rfl
#align subgroup.mem_zpowers_iff Subgroup.mem_zpowers_iff

theorem zpow_mem_zpowers (g : G) (k : â„¤) : g ^ k âˆˆ zpowers g :=
  mem_zpowers_iff.mpr âŸ¨k, rflâŸ©
#align subgroup.zpow_mem_zpowers Subgroup.zpow_mem_zpowers

theorem npow_mem_zpowers (g : G) (k : â„•) : g ^ k âˆˆ zpowers g :=
  zpow_ofNat g k â–¸ zpow_mem_zpowers g k
#align subgroup.npow_mem_zpowers Subgroup.npow_mem_zpowers

theorem forall_zpowers {x : G} {p : zpowers x â†’ Prop} : (âˆ€ g, p g) â†” âˆ€ m : â„¤, p âŸ¨x ^ m, m, rflâŸ© :=
  Set.forall_subtype_range_iff
#align subgroup.forall_zpowers Subgroup.forall_zpowers

theorem exists_zpowers {x : G} {p : zpowers x â†’ Prop} : (âˆƒ g, p g) â†” âˆƒ m : â„¤, p âŸ¨x ^ m, m, rflâŸ© :=
  Set.exists_subtype_range_iff
#align subgroup.exists_zpowers Subgroup.exists_zpowers

theorem forall_mem_zpowers {x : G} {p : G â†’ Prop} : (âˆ€ g âˆˆ zpowers x, p g) â†” âˆ€ m : â„¤, p (x ^ m) :=
  Set.forall_range_iff
#align subgroup.forall_mem_zpowers Subgroup.forall_mem_zpowers

theorem exists_mem_zpowers {x : G} {p : G â†’ Prop} : (âˆƒ g âˆˆ zpowers x, p g) â†” âˆƒ m : â„¤, p (x ^ m) :=
  Set.exists_range_iff
#align subgroup.exists_mem_zpowers Subgroup.exists_mem_zpowers

instance (a : G) : Countable (zpowers a) :=
  ((zpowersHom G a).rangeRestrict_surjective.comp Multiplicative.ofAdd.surjective).countable

end Subgroup

namespace AddSubgroup

/-- The subgroup generated by an element. -/
def zmultiples (a : A) : AddSubgroup A :=
  AddSubgroup.copy (zmultiplesHom A a).range (Set.range ((Â· â€¢ a) : â„¤ â†’ A)) rfl
#align add_subgroup.zmultiples AddSubgroup.zmultiples

@[simp]
theorem range_zmultiplesHom (a : A) : (zmultiplesHom A a).range = zmultiples a :=
  rfl
#align add_subgroup.range_zmultiples_hom AddSubgroup.range_zmultiplesHom

attribute [to_additive existing AddSubgroup.zmultiples] Subgroup.zpowers

attribute [to_additive (attr := simp) AddSubgroup.mem_zmultiples] Subgroup.mem_zpowers
#align add_subgroup.mem_zmultiples AddSubgroup.mem_zmultiples

attribute [to_additive (attr := norm_cast) AddSubgroup.coe_zmultiples] Subgroup.coe_zpowers

attribute [to_additive AddSubgroup.zmultiples_eq_closure] Subgroup.zpowers_eq_closure
#align add_subgroup.zmultiples_eq_closure AddSubgroup.zmultiples_eq_closure

attribute [to_additive existing (attr := simp) AddSubgroup.range_zmultiplesHom]
  Subgroup.range_zpowersHom

attribute [to_additive AddSubgroup.mem_zmultiples_iff] Subgroup.mem_zpowers_iff
#align add_subgroup.mem_zmultiples_iff AddSubgroup.mem_zmultiples_iff

attribute [to_additive (attr := simp) AddSubgroup.zsmul_mem_zmultiples] Subgroup.zpow_mem_zpowers
#align add_subgroup.zsmul_mem_zmultiples AddSubgroup.zsmul_mem_zmultiples

attribute [to_additive (attr := simp) AddSubgroup.nsmul_mem_zmultiples] Subgroup.npow_mem_zpowers
#align add_subgroup.nsmul_mem_zmultiples AddSubgroup.nsmul_mem_zmultiples

--Porting note: increasing simp priority. Better lemma than `Subtype.forall`
attribute [to_additive (attr := simp 1100) AddSubgroup.forall_zmultiples] Subgroup.forall_zpowers
#align add_subgroup.forall_zmultiples AddSubgroup.forall_zmultiples

attribute [to_additive AddSubgroup.forall_mem_zmultiples] Subgroup.forall_mem_zpowers
#align add_subgroup.forall_mem_zmultiples AddSubgroup.forall_mem_zmultiples

--Porting note: increasing simp priority. Better lemma than `Subtype.exists`
attribute [to_additive (attr := simp 1100) AddSubgroup.exists_zmultiples] Subgroup.exists_zpowers
#align add_subgroup.exists_zmultiples AddSubgroup.exists_zmultiples

attribute [to_additive AddSubgroup.exists_mem_zmultiples] Subgroup.exists_mem_zpowers
#align add_subgroup.exists_mem_zmultiples AddSubgroup.exists_mem_zmultiples

instance (a : A) : Countable (zmultiples a) :=
  (zmultiplesHom A a).rangeRestrict_surjective.countable

section Ring

variable {R : Type*} [Ring R] (r : R) (k : â„¤)

@[simp]
theorem int_cast_mul_mem_zmultiples : â†‘(k : â„¤) * r âˆˆ zmultiples r := by
  simpa only [â† zsmul_eq_mul] using zsmul_mem_zmultiples r k
  -- ğŸ‰ no goals
#align add_subgroup.int_cast_mul_mem_zmultiples AddSubgroup.int_cast_mul_mem_zmultiples

@[simp]
theorem int_cast_mem_zmultiples_one : â†‘(k : â„¤) âˆˆ zmultiples (1 : R) :=
  mem_zmultiples_iff.mp âŸ¨k, by simpâŸ©
                               -- ğŸ‰ no goals
#align add_subgroup.int_cast_mem_zmultiples_one AddSubgroup.int_cast_mem_zmultiples_one

end Ring

end AddSubgroup

@[simp] lemma Int.range_castAddHom {A : Type*} [AddGroupWithOne A] :
    (Int.castAddHom A).range = AddSubgroup.zmultiples 1 := by
  ext a
  -- âŠ¢ a âˆˆ AddMonoidHom.range (castAddHom A) â†” a âˆˆ AddSubgroup.zmultiples 1
  simp_rw [AddMonoidHom.mem_range, Int.coe_castAddHom, AddSubgroup.mem_zmultiples_iff, zsmul_one]
  -- ğŸ‰ no goals

@[to_additive (attr := simp) map_zmultiples]
theorem MonoidHom.map_zpowers (f : G â†’* N) (x : G) :
    (Subgroup.zpowers x).map f = Subgroup.zpowers (f x) := by
  rw [Subgroup.zpowers_eq_closure, Subgroup.zpowers_eq_closure, f.map_closure, Set.image_singleton]
  -- ğŸ‰ no goals
#align monoid_hom.map_zpowers MonoidHom.map_zpowers
#align add_monoid_hom.map_zmultiples AddMonoidHom.map_zmultiples

theorem Int.mem_zmultiples_iff {a b : â„¤} : b âˆˆ AddSubgroup.zmultiples a â†” a âˆ£ b :=
  exists_congr fun k => by rw [mul_comm, eq_comm, â† smul_eq_mul]
                           -- ğŸ‰ no goals
#align int.mem_zmultiples_iff Int.mem_zmultiples_iff

theorem ofMul_image_zpowers_eq_zmultiples_ofMul {x : G} :
    Additive.ofMul '' (Subgroup.zpowers x : Set G) = AddSubgroup.zmultiples (Additive.ofMul x) := by
  ext y
  -- âŠ¢ y âˆˆ â†‘Additive.ofMul '' â†‘(Subgroup.zpowers x) â†” y âˆˆ â†‘(AddSubgroup.zmultiples  â€¦
  constructor
  -- âŠ¢ y âˆˆ â†‘Additive.ofMul '' â†‘(Subgroup.zpowers x) â†’ y âˆˆ â†‘(AddSubgroup.zmultiples  â€¦
  Â· rintro âŸ¨z, âŸ¨m, hmâŸ©, hz2âŸ©
    -- âŠ¢ y âˆˆ â†‘(AddSubgroup.zmultiples (â†‘Additive.ofMul x))
    use m
    -- âŠ¢ (fun x_1 => x_1 â€¢ â†‘Additive.ofMul x) m = y
    simp only at *
    -- âŠ¢ m â€¢ â†‘Additive.ofMul x = y
    rwa [â† ofMul_zpow, hm]
    -- ğŸ‰ no goals
  Â· rintro âŸ¨n, hnâŸ©
    -- âŠ¢ y âˆˆ â†‘Additive.ofMul '' â†‘(Subgroup.zpowers x)
    refine' âŸ¨x ^ n, âŸ¨n, rflâŸ©, _âŸ©
    -- âŠ¢ â†‘Additive.ofMul (x ^ n) = y
    rwa [ofMul_zpow]
    -- ğŸ‰ no goals
#align of_mul_image_zpowers_eq_zmultiples_of_mul ofMul_image_zpowers_eq_zmultiples_ofMul

theorem ofAdd_image_zmultiples_eq_zpowers_ofAdd {x : A} :
    Multiplicative.ofAdd '' (AddSubgroup.zmultiples x : Set A) =
      Subgroup.zpowers (Multiplicative.ofAdd x) := by
  symm
  -- âŠ¢ â†‘(Subgroup.zpowers (â†‘Multiplicative.ofAdd x)) = â†‘Multiplicative.ofAdd '' â†‘(A â€¦
  rw [Equiv.eq_image_iff_symm_image_eq]
  -- âŠ¢ â†‘Multiplicative.ofAdd.symm '' â†‘(Subgroup.zpowers (â†‘Multiplicative.ofAdd x))  â€¦
  exact ofMul_image_zpowers_eq_zmultiples_ofMul
  -- ğŸ‰ no goals
#align of_add_image_zmultiples_eq_zpowers_of_add ofAdd_image_zmultiples_eq_zpowers_ofAdd

namespace Subgroup

variable {s : Set G} {g : G}

@[to_additive zmultiples_isCommutative]
instance zpowers_isCommutative (g : G) : (zpowers g).IsCommutative :=
  âŸ¨âŸ¨fun âŸ¨_, _, hâ‚âŸ© âŸ¨_, _, hâ‚‚âŸ© => by
      rw [Subtype.ext_iff, coe_mul, coe_mul, Subtype.coe_mk, Subtype.coe_mk, â† hâ‚, â† hâ‚‚,
        zpow_mul_comm]âŸ©âŸ©
#align subgroup.zpowers_is_commutative Subgroup.zpowers_isCommutative
#align add_subgroup.zmultiples_is_commutative AddSubgroup.zmultiples_isCommutative

@[to_additive (attr := simp) zmultiples_le]
theorem zpowers_le {g : G} {H : Subgroup G} : zpowers g â‰¤ H â†” g âˆˆ H := by
  rw [zpowers_eq_closure, closure_le, Set.singleton_subset_iff, SetLike.mem_coe]
  -- ğŸ‰ no goals
#align subgroup.zpowers_le Subgroup.zpowers_le
#align add_subgroup.zmultiples_le AddSubgroup.zmultiples_le

alias âŸ¨_, zpowers_le_of_memâŸ© := zpowers_le
#align subgroup.zpowers_le_of_mem Subgroup.zpowers_le_of_mem

alias âŸ¨_, _root_.AddSubgroup.zmultiples_le_of_memâŸ© := AddSubgroup.zmultiples_le
#align add_subgroup.zmultiples_le_of_mem AddSubgroup.zmultiples_le_of_mem

attribute [to_additive existing zmultiples_le_of_mem] zpowers_le_of_mem

@[to_additive (attr := simp) zmultiples_eq_bot]
theorem zpowers_eq_bot {g : G} : zpowers g = âŠ¥ â†” g = 1 := by rw [eq_bot_iff, zpowers_le, mem_bot]
                                                             -- ğŸ‰ no goals
#align subgroup.zpowers_eq_bot Subgroup.zpowers_eq_bot
#align add_subgroup.zmultiples_eq_bot AddSubgroup.zmultiples_eq_bot

@[to_additive zmultiples_ne_bot]
theorem zpowers_ne_bot : zpowers g â‰  âŠ¥ â†” g â‰  1 :=
  zpowers_eq_bot.not
#align subgroup.zpowers_ne_bot Subgroup.zpowers_ne_bot
#align add_subgroup.zmultiples_ne_bot AddSubgroup.zmultiples_ne_bot

@[to_additive (attr := simp) zmultiples_zero_eq_bot]
theorem zpowers_one_eq_bot : Subgroup.zpowers (1 : G) = âŠ¥ :=
  Subgroup.zpowers_eq_bot.mpr rfl
#align subgroup.zpowers_one_eq_bot Subgroup.zpowers_one_eq_bot
#align add_subgroup.zmultiples_zero_eq_bot AddSubgroup.zmultiples_zero_eq_bot

@[to_additive]
theorem centralizer_closure (S : Set G) :
    centralizer (closure S : Set G) = â¨… g âˆˆ S, centralizer (zpowers g : Set G) :=
  le_antisymm
      (le_iInf fun _ => le_iInf fun hg => centralizer_le <| zpowers_le.2 <| subset_closure hg) <|
    le_centralizer_iff.1 <|
      (closure_le _).2 fun g =>
        SetLike.mem_coe.2 âˆ˜ zpowers_le.1 âˆ˜ le_centralizer_iff.1 âˆ˜ iInf_le_of_le g âˆ˜ iInf_le _
#align subgroup.centralizer_closure Subgroup.centralizer_closure
#align add_subgroup.centralizer_closure AddSubgroup.centralizer_closure

@[to_additive]
theorem center_eq_iInf (S : Set G) (hS : closure S = âŠ¤) :
    center G = â¨… g âˆˆ S, centralizer (zpowers g) := by
  rw [â† centralizer_univ, â† coe_top, â† hS, centralizer_closure]
  -- ğŸ‰ no goals
#align subgroup.center_eq_infi Subgroup.center_eq_iInf
#align add_subgroup.center_eq_infi AddSubgroup.center_eq_iInf

@[to_additive]
theorem center_eq_infi' (S : Set G) (hS : closure S = âŠ¤) :
    center G = â¨… g : S, centralizer (zpowers (g : G)) :=
  by rw [center_eq_iInf S hS, â† iInf_subtype'']
     -- ğŸ‰ no goals
#align subgroup.center_eq_infi' Subgroup.center_eq_infi'
#align add_subgroup.center_eq_infi' AddSubgroup.center_eq_infi'

end Subgroup
