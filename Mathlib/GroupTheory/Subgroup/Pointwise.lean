/-
Copyright (c) 2021 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser
-/
import Mathlib.GroupTheory.Subgroup.MulOpposite
import Mathlib.GroupTheory.Submonoid.Pointwise
import Mathlib.GroupTheory.GroupAction.ConjAct

#align_import group_theory.subgroup.pointwise from "leanprover-community/mathlib"@"e655e4ea5c6d02854696f97494997ba4c31be802"

/-! # Pointwise instances on `Subgroup` and `AddSubgroup`s

This file provides the actions

* `Subgroup.pointwiseMulAction`
* `AddSubgroup.pointwiseMulAction`

which matches the action of `Set.mulActionSet`.

These actions are available in the `Pointwise` locale.

## Implementation notes

The pointwise section of this file is almost identical to `GroupTheory/Submonoid/Pointwise.lean`.
Where possible, try to keep them in sync.
-/


open Set

open Pointwise

variable {Œ± G A S : Type*}

@[to_additive (attr := simp)]
theorem inv_coe_set [InvolutiveInv G] [SetLike S G] [InvMemClass S G] {H : S} : (H : Set G)‚Åª¬π = H :=
  Set.ext fun _ => inv_mem_iff
#align inv_coe_set inv_coe_set
#align neg_coe_set neg_coe_set

variable [Group G] [AddGroup A] {s : Set G}

namespace Subgroup

@[to_additive (attr := simp)]
theorem inv_subset_closure (S : Set G) : S‚Åª¬π ‚äÜ closure S := fun s hs => by
  rw [SetLike.mem_coe, ‚Üê Subgroup.inv_mem_iff]
  -- ‚ä¢ s‚Åª¬π ‚àà closure S
  exact subset_closure (mem_inv.mp hs)
  -- üéâ no goals
#align subgroup.inv_subset_closure Subgroup.inv_subset_closure
#align add_subgroup.neg_subset_closure AddSubgroup.neg_subset_closure

@[to_additive]
theorem closure_toSubmonoid (S : Set G) :
    (closure S).toSubmonoid = Submonoid.closure (S ‚à™ S‚Åª¬π) := by
  refine le_antisymm (fun x hx => ?_) (Submonoid.closure_le.2 ?_)
  -- ‚ä¢ x ‚àà Submonoid.closure (S ‚à™ S‚Åª¬π)
  ¬∑ refine'
      closure_induction hx
        (fun x hx => Submonoid.closure_mono (subset_union_left S S‚Åª¬π) (Submonoid.subset_closure hx))
        (Submonoid.one_mem _) (fun x y hx hy => Submonoid.mul_mem _ hx hy) fun x hx => _
    rwa [‚Üê Submonoid.mem_closure_inv, Set.union_inv, inv_inv, Set.union_comm]
    -- üéâ no goals
  ¬∑ simp only [true_and_iff, coe_toSubmonoid, union_subset_iff, subset_closure, inv_subset_closure]
    -- üéâ no goals
#align subgroup.closure_to_submonoid Subgroup.closure_toSubmonoid
#align add_subgroup.closure_to_add_submonoid AddSubgroup.closure_toAddSubmonoid

/-- For subgroups generated by a single element, see the simpler `zpow_induction_left`. -/
@[to_additive "For additive subgroups generated by a single element, see the simpler
`zsmul_induction_left`."]
theorem closure_induction_left {p : G ‚Üí Prop} {x : G} (h : x ‚àà closure s) (H1 : p 1)
    (Hmul : ‚àÄ x ‚àà s, ‚àÄ (y), p y ‚Üí p (x * y)) (Hinv : ‚àÄ x ‚àà s, ‚àÄ (y), p y ‚Üí p (x‚Åª¬π * y)) : p x :=
  let key := (closure_toSubmonoid s).le
  Submonoid.closure_induction_left (key h) H1 fun x hx => hx.elim (Hmul x) fun hx y hy =>
    inv_inv x ‚ñ∏ Hinv x‚Åª¬π hx y hy
#align subgroup.closure_induction_left Subgroup.closure_induction_left
#align add_subgroup.closure_induction_left AddSubgroup.closure_induction_left

/-- For subgroups generated by a single element, see the simpler `zpow_induction_right`. -/
@[to_additive "For additive subgroups generated by a single element, see the simpler
`zsmul_induction_right`."]
theorem closure_induction_right {p : G ‚Üí Prop} {x : G} (h : x ‚àà closure s) (H1 : p 1)
    (Hmul : ‚àÄ (x), ‚àÄ y ‚àà s, p x ‚Üí p (x * y)) (Hinv : ‚àÄ (x), ‚àÄ y ‚àà s, p x ‚Üí p (x * y‚Åª¬π)) : p x :=
  let key := (closure_toSubmonoid s).le
  Submonoid.closure_induction_right (key h) H1 fun x y hy => hy.elim (Hmul x y) fun hy hx =>
    inv_inv y ‚ñ∏ Hinv x y‚Åª¬π hy hx
#align subgroup.closure_induction_right Subgroup.closure_induction_right
#align add_subgroup.closure_induction_right AddSubgroup.closure_induction_right

@[to_additive (attr := simp)]
theorem closure_inv (s : Set G) : closure s‚Åª¬π = closure s := by
  simp only [‚Üê toSubmonoid_eq, closure_toSubmonoid, inv_inv, union_comm]
  -- üéâ no goals
#align subgroup.closure_inv Subgroup.closure_inv
#align add_subgroup.closure_neg AddSubgroup.closure_neg

/-- An induction principle for closure membership. If `p` holds for `1` and all elements of
`k` and their inverse, and is preserved under multiplication, then `p` holds for all elements of
the closure of `k`. -/
@[to_additive "An induction principle for additive closure membership. If `p` holds for `0` and all
elements of `k` and their negation, and is preserved under addition, then `p` holds for all
elements of the additive closure of `k`."]
theorem closure_induction'' {p : G ‚Üí Prop} {x} (h : x ‚àà closure s) (Hk : ‚àÄ x ‚àà s, p x)
    (Hk_inv : ‚àÄ x ‚àà s, p x‚Åª¬π) (H1 : p 1) (Hmul : ‚àÄ x y, p x ‚Üí p y ‚Üí p (x * y)) : p x :=
  closure_induction_left h H1 (fun x hx y hy => Hmul x y (Hk x hx) hy) fun x hx y =>
    Hmul x‚Åª¬π y <| Hk_inv x hx
#align subgroup.closure_induction'' Subgroup.closure_induction''
#align add_subgroup.closure_induction'' AddSubgroup.closure_induction''

/-- An induction principle for elements of `‚®Ü i, S i`.
If `C` holds for `1` and all elements of `S i` for all `i`, and is preserved under multiplication,
then it holds for all elements of the supremum of `S`. -/
@[to_additive (attr := elab_as_elim) " An induction principle for elements of `‚®Ü i, S i`.
If `C` holds for `0` and all elements of `S i` for all `i`, and is preserved under addition,
then it holds for all elements of the supremum of `S`. "]
theorem iSup_induction {Œπ : Sort*} (S : Œπ ‚Üí Subgroup G) {C : G ‚Üí Prop} {x : G} (hx : x ‚àà ‚®Ü i, S i)
    (hp : ‚àÄ (i), ‚àÄ x ‚àà S i, C x) (h1 : C 1) (hmul : ‚àÄ x y, C x ‚Üí C y ‚Üí C (x * y)) : C x := by
  rw [iSup_eq_closure] at hx
  -- ‚ä¢ C x
  refine' closure_induction'' hx (fun x hx => _) (fun x hx => _) h1 hmul
  -- ‚ä¢ C x
  ¬∑ obtain ‚ü®i, hi‚ü© := Set.mem_iUnion.mp hx
    -- ‚ä¢ C x
    exact hp _ _ hi
    -- üéâ no goals
  ¬∑ obtain ‚ü®i, hi‚ü© := Set.mem_iUnion.mp hx
    -- ‚ä¢ C x‚Åª¬π
    exact hp _ _ (inv_mem hi)
    -- üéâ no goals
#align subgroup.supr_induction Subgroup.iSup_induction
#align add_subgroup.supr_induction AddSubgroup.iSup_induction

/-- A dependent version of `Subgroup.iSup_induction`. -/
@[to_additive (attr := elab_as_elim) "A dependent version of `AddSubgroup.iSup_induction`. "]
theorem iSup_induction' {Œπ : Sort*} (S : Œπ ‚Üí Subgroup G) {C : ‚àÄ x, (x ‚àà ‚®Ü i, S i) ‚Üí Prop}
    (hp : ‚àÄ (i), ‚àÄ x (hx : x ‚àà S i), C x (mem_iSup_of_mem i hx)) (h1 : C 1 (one_mem _))
    (hmul : ‚àÄ x y hx hy, C x hx ‚Üí C y hy ‚Üí C (x * y) (mul_mem ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫)) {x : G}
    (hx : x ‚àà ‚®Ü i, S i) : C x hx := by
  suffices : ‚àÉ h, C x h; exact this.snd
  -- ‚ä¢ C x hx
                         -- ‚ä¢ ‚àÉ h, C x h
  refine' iSup_induction S (C := fun x => ‚àÉ h, C x h) hx (fun i x hx => _) _ fun x y => _
  ¬∑ exact ‚ü®_, hp i _ hx‚ü©
    -- üéâ no goals
  ¬∑ exact ‚ü®_, h1‚ü©
    -- üéâ no goals
  ¬∑ rintro ‚ü®_, Cx‚ü© ‚ü®_, Cy‚ü©
    -- ‚ä¢ ‚àÉ h, C (x * y) h
    refine' ‚ü®_, hmul _ _ _ _ Cx Cy‚ü©
    -- üéâ no goals
#align subgroup.supr_induction' Subgroup.iSup_induction'
#align add_subgroup.supr_induction' AddSubgroup.iSup_induction'

@[to_additive]
theorem closure_mul_le (S T : Set G) : closure (S * T) ‚â§ closure S ‚äî closure T :=
  sInf_le fun _x ‚ü®_s, _t, hs, ht, hx‚ü© => hx ‚ñ∏
    (closure S ‚äî closure T).mul_mem (SetLike.le_def.mp le_sup_left <| subset_closure hs)
      (SetLike.le_def.mp le_sup_right <| subset_closure ht)
#align subgroup.closure_mul_le Subgroup.closure_mul_le
#align add_subgroup.closure_add_le AddSubgroup.closure_add_le

@[to_additive]
theorem sup_eq_closure (H K : Subgroup G) : H ‚äî K = closure ((H : Set G) * (K : Set G)) :=
  le_antisymm
    (sup_le (fun h hh => subset_closure ‚ü®h, 1, hh, K.one_mem, mul_one h‚ü©) fun k hk =>
      subset_closure ‚ü®1, k, H.one_mem, hk, one_mul k‚ü©)
    ((closure_mul_le _ _).trans <| by rw [closure_eq, closure_eq])
                                      -- üéâ no goals
#align subgroup.sup_eq_closure Subgroup.sup_eq_closure
#align add_subgroup.sup_eq_closure AddSubgroup.sup_eq_closure

@[to_additive]
theorem set_mul_normal_comm (s : Set G) (N : Subgroup G) [hN : N.Normal] :
    s * (N : Set G) = (N : Set G) * s := by
  ext x
  -- ‚ä¢ x ‚àà s * ‚ÜëN ‚Üî x ‚àà ‚ÜëN * s
  refine (exists_congr fun y => ?_).trans exists_swap
  -- ‚ä¢ (‚àÉ b, y ‚àà s ‚àß b ‚àà ‚ÜëN ‚àß (fun x x_1 => x * x_1) y b = x) ‚Üî ‚àÉ y_1, y_1 ‚àà ‚ÜëN ‚àß y ‚Ä¶
  simp only [exists_and_left, @and_left_comm _ (y ‚àà s), ‚Üê eq_inv_mul_iff_mul_eq (b := y),
    ‚Üê eq_mul_inv_iff_mul_eq (c := y), exists_eq_right, SetLike.mem_coe, hN.mem_comm_iff]

/-- The carrier of `H ‚äî N` is just `‚ÜëH * ‚ÜëN` (pointwise set product) when `N` is normal. -/
@[to_additive "The carrier of `H ‚äî N` is just `‚ÜëH + ‚ÜëN` (pointwise set addition)
when `N` is normal."]
theorem mul_normal (H N : Subgroup G) [hN : N.Normal] : (‚Üë(H ‚äî N) : Set G) = H * N := by
  rw [sup_eq_closure]
  -- ‚ä¢ ‚Üë(closure (‚ÜëH * ‚ÜëN)) = ‚ÜëH * ‚ÜëN
  refine Set.Subset.antisymm (fun x hx => ?_) subset_closure
  -- ‚ä¢ x ‚àà ‚ÜëH * ‚ÜëN
  refine closure_induction'' (p := fun x => x ‚àà (H : Set G) * (N : Set G)) hx ?_ ?_ ?_ ?_
  ¬∑ rintro _ ‚ü®x, y, hx, hy, rfl‚ü©
    -- ‚ä¢ (fun x x_1 => x * x_1) x y ‚àà ‚ÜëH * ‚ÜëN
    exact mul_mem_mul hx hy
    -- üéâ no goals
  ¬∑ rintro _ ‚ü®x, y, hx, hy, rfl‚ü©
    -- ‚ä¢ ((fun x x_1 => x * x_1) x y)‚Åª¬π ‚àà ‚ÜëH * ‚ÜëN
    simpa only [mul_inv_rev, mul_assoc, inv_inv, inv_mul_cancel_left]
      using mul_mem_mul (inv_mem hx) (hN.conj_mem _ (inv_mem hy) x)
  ¬∑ exact ‚ü®1, 1, one_mem _, one_mem _, mul_one 1‚ü©
    -- üéâ no goals
  ¬∑ rintro _ _ ‚ü®x, y, hx, hy, rfl‚ü© ‚ü®x', y', hx', hy', rfl‚ü©
    -- ‚ä¢ (fun x x_1 => x * x_1) x y * (fun x x_1 => x * x_1) x' y' ‚àà ‚ÜëH * ‚ÜëN
    refine ‚ü®x * x', x'‚Åª¬π * y * x' * y', mul_mem hx hx', mul_mem ?_ hy', ?_‚ü©
    -- ‚ä¢ x'‚Åª¬π * y * x' ‚àà N
    ¬∑ simpa using hN.conj_mem _ hy x'‚Åª¬π
      -- üéâ no goals
    ¬∑ simp only [mul_assoc, mul_inv_cancel_left]
      -- üéâ no goals
#align subgroup.mul_normal Subgroup.mul_normal
#align add_subgroup.add_normal AddSubgroup.add_normal

/-- The carrier of `N ‚äî H` is just `‚ÜëN * ‚ÜëH` (pointwise set product) when `N` is normal. -/
@[to_additive "The carrier of `N ‚äî H` is just `‚ÜëN + ‚ÜëH` (pointwise set addition)
when `N` is normal."]
theorem normal_mul (N H : Subgroup G) [N.Normal] : (‚Üë(N ‚äî H) : Set G) = N * H := by
  rw [‚Üê set_mul_normal_comm, sup_comm, mul_normal]
  -- üéâ no goals
#align subgroup.normal_mul Subgroup.normal_mul
#align add_subgroup.normal_add AddSubgroup.normal_add

-- porting note: todo: use `‚à©` in the RHS
@[to_additive]
theorem mul_inf_assoc (A B C : Subgroup G) (h : A ‚â§ C) :
    (A : Set G) * ‚Üë(B ‚äì C) = (A : Set G) * (B : Set G) ‚äì C := by
  ext
  -- ‚ä¢ x‚úù ‚àà ‚ÜëA * ‚Üë(B ‚äì C) ‚Üî x‚úù ‚àà ‚ÜëA * ‚ÜëB ‚äì ‚ÜëC
  simp only [coe_inf, Set.inf_eq_inter, Set.mem_mul, Set.mem_inter_iff]
  -- ‚ä¢ (‚àÉ x y, x ‚àà ‚ÜëA ‚àß (y ‚àà ‚ÜëB ‚àß y ‚àà ‚ÜëC) ‚àß x * y = x‚úù) ‚Üî (‚àÉ x y, x ‚àà ‚ÜëA ‚àß y ‚àà ‚ÜëB ‚àß ‚Ä¶
  constructor
  -- ‚ä¢ (‚àÉ x y, x ‚àà ‚ÜëA ‚àß (y ‚àà ‚ÜëB ‚àß y ‚àà ‚ÜëC) ‚àß x * y = x‚úù) ‚Üí (‚àÉ x y, x ‚àà ‚ÜëA ‚àß y ‚àà ‚ÜëB ‚àß ‚Ä¶
  ¬∑ rintro ‚ü®y, z, hy, ‚ü®hzB, hzC‚ü©, rfl‚ü©
    -- ‚ä¢ (‚àÉ x y_1, x ‚àà ‚ÜëA ‚àß y_1 ‚àà ‚ÜëB ‚àß x * y_1 = y * z) ‚àß y * z ‚àà ‚ÜëC
    refine' ‚ü®_, mul_mem (h hy) hzC‚ü©
    -- ‚ä¢ ‚àÉ x y_1, x ‚àà ‚ÜëA ‚àß y_1 ‚àà ‚ÜëB ‚àß x * y_1 = y * z
    exact ‚ü®y, z, hy, hzB, rfl‚ü©
    -- üéâ no goals
  rintro ‚ü®‚ü®y, z, hy, hz, rfl‚ü©, hyz‚ü©
  -- ‚ä¢ ‚àÉ x y_1, x ‚àà ‚ÜëA ‚àß (y_1 ‚àà ‚ÜëB ‚àß y_1 ‚àà ‚ÜëC) ‚àß x * y_1 = y * z
  refine' ‚ü®y, z, hy, ‚ü®hz, _‚ü©, rfl‚ü©
  -- ‚ä¢ z ‚àà ‚ÜëC
  suffices y‚Åª¬π * (y * z) ‚àà C by simpa
  -- ‚ä¢ y‚Åª¬π * (y * z) ‚àà C
  exact mul_mem (inv_mem (h hy)) hyz
  -- üéâ no goals
#align subgroup.mul_inf_assoc Subgroup.mul_inf_assoc
#align add_subgroup.add_inf_assoc AddSubgroup.add_inf_assoc

-- porting note: todo: use `‚à©` in the RHS
@[to_additive]
theorem inf_mul_assoc (A B C : Subgroup G) (h : C ‚â§ A) :
    ((A ‚äì B : Subgroup G) : Set G) * C = (A : Set G) ‚äì ‚ÜëB * ‚ÜëC := by
  ext
  -- ‚ä¢ x‚úù ‚àà ‚Üë(A ‚äì B) * ‚ÜëC ‚Üî x‚úù ‚àà ‚ÜëA ‚äì ‚ÜëB * ‚ÜëC
  simp only [coe_inf, Set.inf_eq_inter, Set.mem_mul, Set.mem_inter_iff]
  -- ‚ä¢ (‚àÉ x y, (x ‚àà ‚ÜëA ‚àß x ‚àà ‚ÜëB) ‚àß y ‚àà ‚ÜëC ‚àß x * y = x‚úù) ‚Üî x‚úù ‚àà ‚ÜëA ‚àß ‚àÉ x y, x ‚àà ‚ÜëB ‚àß ‚Ä¶
  constructor
  -- ‚ä¢ (‚àÉ x y, (x ‚àà ‚ÜëA ‚àß x ‚àà ‚ÜëB) ‚àß y ‚àà ‚ÜëC ‚àß x * y = x‚úù) ‚Üí x‚úù ‚àà ‚ÜëA ‚àß ‚àÉ x y, x ‚àà ‚ÜëB ‚àß ‚Ä¶
  ¬∑ rintro ‚ü®y, z, ‚ü®hyA, hyB‚ü©, hz, rfl‚ü©
    -- ‚ä¢ y * z ‚àà ‚ÜëA ‚àß ‚àÉ x y_1, x ‚àà ‚ÜëB ‚àß y_1 ‚àà ‚ÜëC ‚àß x * y_1 = y * z
    refine' ‚ü®A.mul_mem hyA (h hz), _‚ü©
    -- ‚ä¢ ‚àÉ x y_1, x ‚àà ‚ÜëB ‚àß y_1 ‚àà ‚ÜëC ‚àß x * y_1 = y * z
    exact ‚ü®y, z, hyB, hz, rfl‚ü©
    -- üéâ no goals
  rintro ‚ü®hyz, y, z, hy, hz, rfl‚ü©
  -- ‚ä¢ ‚àÉ x y_1, (x ‚àà ‚ÜëA ‚àß x ‚àà ‚ÜëB) ‚àß y_1 ‚àà ‚ÜëC ‚àß x * y_1 = y * z
  refine' ‚ü®y, z, ‚ü®_, hy‚ü©, hz, rfl‚ü©
  -- ‚ä¢ y ‚àà ‚ÜëA
  suffices y * z * z‚Åª¬π ‚àà A by simpa
  -- ‚ä¢ y * z * z‚Åª¬π ‚àà A
  exact mul_mem hyz (inv_mem (h hz))
  -- üéâ no goals
#align subgroup.inf_mul_assoc Subgroup.inf_mul_assoc
#align add_subgroup.inf_add_assoc AddSubgroup.inf_add_assoc

@[to_additive]
instance sup_normal (H K : Subgroup G) [hH : H.Normal] [hK : K.Normal] : (H ‚äî K).Normal where
  conj_mem n hmem g := by
    rw [‚Üê SetLike.mem_coe, normal_mul] at hmem ‚ä¢
    -- ‚ä¢ g * n * g‚Åª¬π ‚àà ‚ÜëH * ‚ÜëK
    rcases hmem with ‚ü®h, k, hh, hk, rfl‚ü©
    -- ‚ä¢ g * (fun x x_1 => x * x_1) h k * g‚Åª¬π ‚àà ‚ÜëH * ‚ÜëK
    refine ‚ü®g * h * g‚Åª¬π, g * k * g‚Åª¬π, hH.conj_mem h hh g, hK.conj_mem k hk g, ?_‚ü©
    -- ‚ä¢ (fun x x_1 => x * x_1) (g * h * g‚Åª¬π) (g * k * g‚Åª¬π) = g * (fun x x_1 => x * x ‚Ä¶
    simp only [mul_assoc, inv_mul_cancel_left]
    -- üéâ no goals
#align subgroup.sup_normal Subgroup.sup_normal

-- porting note: new lemma
@[to_additive]
theorem smul_opposite_image_mul_preimage' (g : G) (h : G·µê·µí·µñ) (s : Set G) :
    (fun y => h ‚Ä¢ y) '' ((g * ¬∑) ‚Åª¬π' s) = (g * ¬∑) ‚Åª¬π' ((fun y => h ‚Ä¢ y) '' s) := by
  simp [preimage_preimage, mul_assoc]
  -- üéâ no goals

-- porting note: deprecate?
@[to_additive]
theorem smul_opposite_image_mul_preimage {H : Subgroup G} (g : G) (h : opposite H) (s : Set G) :
    (fun y => h ‚Ä¢ y) '' ((g * ¬∑) ‚Åª¬π' s) = (g * ¬∑) ‚Åª¬π' ((fun y => h ‚Ä¢ y) '' s) :=
  smul_opposite_image_mul_preimage' g h s
#align subgroup.smul_opposite_image_mul_preimage Subgroup.smul_opposite_image_mul_preimage
#align add_subgroup.vadd_opposite_image_add_preimage AddSubgroup.vadd_opposite_image_add_preimage

/-! ### Pointwise action -/


section Monoid

variable [Monoid Œ±] [MulDistribMulAction Œ± G]

/-- The action on a subgroup corresponding to applying the action to every element.

This is available as an instance in the `Pointwise` locale. -/
protected def pointwiseMulAction : MulAction Œ± (Subgroup G) where
  smul a S := S.map (MulDistribMulAction.toMonoidEnd _ _ a)
  one_smul S := by
    change S.map _ = S
    -- ‚ä¢ map (‚Üë(MulDistribMulAction.toMonoidEnd Œ± G) 1) S = S
    simpa only [map_one] using S.map_id
    -- üéâ no goals
  mul_smul a‚ÇÅ a‚ÇÇ S :=
    (congr_arg (fun f : Monoid.End G => S.map f) (MonoidHom.map_mul _ _ _)).trans
      (S.map_map _ _).symm
#align subgroup.pointwise_mul_action Subgroup.pointwiseMulAction

scoped[Pointwise] attribute [instance] Subgroup.pointwiseMulAction

theorem pointwise_smul_def {a : Œ±} (S : Subgroup G) :
    a ‚Ä¢ S = S.map (MulDistribMulAction.toMonoidEnd _ _ a) :=
  rfl
#align subgroup.pointwise_smul_def Subgroup.pointwise_smul_def

@[simp]
theorem coe_pointwise_smul (a : Œ±) (S : Subgroup G) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set G) :=
  rfl
#align subgroup.coe_pointwise_smul Subgroup.coe_pointwise_smul

@[simp]
theorem pointwise_smul_toSubmonoid (a : Œ±) (S : Subgroup G) :
    (a ‚Ä¢ S).toSubmonoid = a ‚Ä¢ S.toSubmonoid :=
  rfl
#align subgroup.pointwise_smul_to_submonoid Subgroup.pointwise_smul_toSubmonoid

theorem smul_mem_pointwise_smul (m : G) (a : Œ±) (S : Subgroup G) : m ‚àà S ‚Üí a ‚Ä¢ m ‚àà a ‚Ä¢ S :=
  (Set.smul_mem_smul_set : _ ‚Üí _ ‚àà a ‚Ä¢ (S : Set G))
#align subgroup.smul_mem_pointwise_smul Subgroup.smul_mem_pointwise_smul

theorem mem_smul_pointwise_iff_exists (m : G) (a : Œ±) (S : Subgroup G) :
    m ‚àà a ‚Ä¢ S ‚Üî ‚àÉ s : G, s ‚àà S ‚àß a ‚Ä¢ s = m :=
  (Set.mem_smul_set : m ‚àà a ‚Ä¢ (S : Set G) ‚Üî _)
#align subgroup.mem_smul_pointwise_iff_exists Subgroup.mem_smul_pointwise_iff_exists

@[simp]
theorem smul_bot (a : Œ±) : a ‚Ä¢ (‚ä• : Subgroup G) = ‚ä• :=
  map_bot _
#align subgroup.smul_bot Subgroup.smul_bot

theorem smul_sup (a : Œ±) (S T : Subgroup G) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=
  map_sup _ _ _
#align subgroup.smul_sup Subgroup.smul_sup

theorem smul_closure (a : Œ±) (s : Set G) : a ‚Ä¢ closure s = closure (a ‚Ä¢ s) :=
  MonoidHom.map_closure _ _
#align subgroup.smul_closure Subgroup.smul_closure

instance pointwise_isCentralScalar [MulDistribMulAction Œ±·µê·µí·µñ G] [IsCentralScalar Œ± G] :
    IsCentralScalar Œ± (Subgroup G) :=
  ‚ü®fun _ S => (congr_arg fun f => S.map f) <| MonoidHom.ext <| op_smul_eq_smul _‚ü©
#align subgroup.pointwise_central_scalar Subgroup.pointwise_isCentralScalar

theorem conj_smul_le_of_le {P H : Subgroup G} (hP : P ‚â§ H) (h : H) :
    MulAut.conj (h : G) ‚Ä¢ P ‚â§ H := by
  rintro - ‚ü®g, hg, rfl‚ü©
  -- ‚ä¢ ‚Üë(‚Üë(MulDistribMulAction.toMonoidEnd ((fun x => MulAut G) ‚Üëh) G) (‚ÜëMulAut.con ‚Ä¶
  exact H.mul_mem (H.mul_mem h.2 (hP hg)) (H.inv_mem h.2)
  -- üéâ no goals
#align subgroup.conj_smul_le_of_le Subgroup.conj_smul_le_of_le

theorem conj_smul_subgroupOf {P H : Subgroup G} (hP : P ‚â§ H) (h : H) :
    MulAut.conj h ‚Ä¢ P.subgroupOf H = (MulAut.conj (h : G) ‚Ä¢ P).subgroupOf H := by
  refine' le_antisymm _ _
  -- ‚ä¢ ‚ÜëMulAut.conj h ‚Ä¢ subgroupOf P H ‚â§ subgroupOf (‚ÜëMulAut.conj ‚Üëh ‚Ä¢ P) H
  ¬∑ rintro - ‚ü®g, hg, rfl‚ü©
    -- ‚ä¢ ‚Üë(‚Üë(MulDistribMulAction.toMonoidEnd ((fun x => MulAut { x // x ‚àà H }) h) { x ‚Ä¶
    exact ‚ü®g, hg, rfl‚ü©
    -- üéâ no goals
  ¬∑ rintro p ‚ü®g, hg, hp‚ü©
    -- ‚ä¢ p ‚àà ‚ÜëMulAut.conj h ‚Ä¢ subgroupOf P H
    exact ‚ü®‚ü®g, hP hg‚ü©, hg, Subtype.ext hp‚ü©
    -- üéâ no goals
#align subgroup.conj_smul_subgroup_of Subgroup.conj_smul_subgroupOf

end Monoid

section Group

variable [Group Œ±] [MulDistribMulAction Œ± G]

@[simp]
theorem smul_mem_pointwise_smul_iff {a : Œ±} {S : Subgroup G} {x : G} : a ‚Ä¢ x ‚àà a ‚Ä¢ S ‚Üî x ‚àà S :=
  smul_mem_smul_set_iff
#align subgroup.smul_mem_pointwise_smul_iff Subgroup.smul_mem_pointwise_smul_iff

theorem mem_pointwise_smul_iff_inv_smul_mem {a : Œ±} {S : Subgroup G} {x : G} :
    x ‚àà a ‚Ä¢ S ‚Üî a‚Åª¬π ‚Ä¢ x ‚àà S :=
  mem_smul_set_iff_inv_smul_mem
#align subgroup.mem_pointwise_smul_iff_inv_smul_mem Subgroup.mem_pointwise_smul_iff_inv_smul_mem

theorem mem_inv_pointwise_smul_iff {a : Œ±} {S : Subgroup G} {x : G} : x ‚àà a‚Åª¬π ‚Ä¢ S ‚Üî a ‚Ä¢ x ‚àà S :=
  mem_inv_smul_set_iff
#align subgroup.mem_inv_pointwise_smul_iff Subgroup.mem_inv_pointwise_smul_iff

@[simp]
theorem pointwise_smul_le_pointwise_smul_iff {a : Œ±} {S T : Subgroup G} : a ‚Ä¢ S ‚â§ a ‚Ä¢ T ‚Üî S ‚â§ T :=
  set_smul_subset_set_smul_iff
#align subgroup.pointwise_smul_le_pointwise_smul_iff Subgroup.pointwise_smul_le_pointwise_smul_iff

theorem pointwise_smul_subset_iff {a : Œ±} {S T : Subgroup G} : a ‚Ä¢ S ‚â§ T ‚Üî S ‚â§ a‚Åª¬π ‚Ä¢ T :=
  set_smul_subset_iff
#align subgroup.pointwise_smul_subset_iff Subgroup.pointwise_smul_subset_iff

theorem subset_pointwise_smul_iff {a : Œ±} {S T : Subgroup G} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=
  subset_set_smul_iff
#align subgroup.subset_pointwise_smul_iff Subgroup.subset_pointwise_smul_iff

@[simp]
theorem smul_inf (a : Œ±) (S T : Subgroup G) : a ‚Ä¢ (S ‚äì T) = a ‚Ä¢ S ‚äì a ‚Ä¢ T := by
  simp [SetLike.ext_iff, mem_pointwise_smul_iff_inv_smul_mem]
  -- üéâ no goals
#align subgroup.smul_inf Subgroup.smul_inf

/-- Applying a `MulDistribMulAction` results in an isomorphic subgroup -/
@[simps!]
def equivSMul (a : Œ±) (H : Subgroup G) : H ‚âÉ* (a ‚Ä¢ H : Subgroup G) :=
  (MulDistribMulAction.toMulEquiv G a).subgroupMap H
#align subgroup.equiv_smul Subgroup.equivSMul

theorem subgroup_mul_singleton {H : Subgroup G} {h : G} (hh : h ‚àà H) : (H : Set G) * {h} = H :=
  suffices { x : G | x ‚àà H } = ‚ÜëH by simpa [preimage, mul_mem_cancel_right (inv_mem hh)]
                                     -- üéâ no goals
  rfl
#align subgroup.subgroup_mul_singleton Subgroup.subgroup_mul_singleton

theorem singleton_mul_subgroup {H : Subgroup G} {h : G} (hh : h ‚àà H) : {h} * (H : Set G) = H :=
  suffices { x : G | x ‚àà H } = ‚ÜëH by simpa [preimage, mul_mem_cancel_left (inv_mem hh)]
                                     -- üéâ no goals
  rfl
#align subgroup.singleton_mul_subgroup Subgroup.singleton_mul_subgroup

theorem Normal.conjAct {G : Type*} [Group G] {H : Subgroup G} (hH : H.Normal) (g : ConjAct G) :
    g ‚Ä¢ H = H :=
  have : ‚àÄ g : ConjAct G, g ‚Ä¢ H ‚â§ H :=
    fun _ => map_le_iff_le_comap.2 fun _ h => hH.conj_mem _ h _
  (this g).antisymm <| (smul_inv_smul g H).symm.trans_le (map_mono <| this _)
#align subgroup.normal.conj_act Subgroup.Normal.conjAct

@[simp]
theorem smul_normal (g : G) (H : Subgroup G) [h : Normal H] : MulAut.conj g ‚Ä¢ H = H :=
  h.conjAct g
#align subgroup.smul_normal Subgroup.smul_normal

end Group

section GroupWithZero

variable [GroupWithZero Œ±] [MulDistribMulAction Œ± G]

@[simp]
theorem smul_mem_pointwise_smul_iff‚ÇÄ {a : Œ±} (ha : a ‚â† 0) (S : Subgroup G) (x : G) :
    a ‚Ä¢ x ‚àà a ‚Ä¢ S ‚Üî x ‚àà S :=
  smul_mem_smul_set_iff‚ÇÄ ha (S : Set G) x
#align subgroup.smul_mem_pointwise_smul_iff‚ÇÄ Subgroup.smul_mem_pointwise_smul_iff‚ÇÄ

theorem mem_pointwise_smul_iff_inv_smul_mem‚ÇÄ {a : Œ±} (ha : a ‚â† 0) (S : Subgroup G) (x : G) :
    x ‚àà a ‚Ä¢ S ‚Üî a‚Åª¬π ‚Ä¢ x ‚àà S :=
  mem_smul_set_iff_inv_smul_mem‚ÇÄ ha (S : Set G) x
#align subgroup.mem_pointwise_smul_iff_inv_smul_mem‚ÇÄ Subgroup.mem_pointwise_smul_iff_inv_smul_mem‚ÇÄ

theorem mem_inv_pointwise_smul_iff‚ÇÄ {a : Œ±} (ha : a ‚â† 0) (S : Subgroup G) (x : G) :
    x ‚àà a‚Åª¬π ‚Ä¢ S ‚Üî a ‚Ä¢ x ‚àà S :=
  mem_inv_smul_set_iff‚ÇÄ ha (S : Set G) x
#align subgroup.mem_inv_pointwise_smul_iff‚ÇÄ Subgroup.mem_inv_pointwise_smul_iff‚ÇÄ

@[simp]
theorem pointwise_smul_le_pointwise_smul_iff‚ÇÄ {a : Œ±} (ha : a ‚â† 0) {S T : Subgroup G} :
    a ‚Ä¢ S ‚â§ a ‚Ä¢ T ‚Üî S ‚â§ T :=
  set_smul_subset_set_smul_iff‚ÇÄ ha
#align subgroup.pointwise_smul_le_pointwise_smul_iff‚ÇÄ Subgroup.pointwise_smul_le_pointwise_smul_iff‚ÇÄ

theorem pointwise_smul_le_iff‚ÇÄ {a : Œ±} (ha : a ‚â† 0) {S T : Subgroup G} : a ‚Ä¢ S ‚â§ T ‚Üî S ‚â§ a‚Åª¬π ‚Ä¢ T :=
  set_smul_subset_iff‚ÇÄ ha
#align subgroup.pointwise_smul_le_iff‚ÇÄ Subgroup.pointwise_smul_le_iff‚ÇÄ

theorem le_pointwise_smul_iff‚ÇÄ {a : Œ±} (ha : a ‚â† 0) {S T : Subgroup G} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=
  subset_set_smul_iff‚ÇÄ ha
#align subgroup.le_pointwise_smul_iff‚ÇÄ Subgroup.le_pointwise_smul_iff‚ÇÄ

end GroupWithZero

end Subgroup

namespace AddSubgroup

section Monoid

variable [Monoid Œ±] [DistribMulAction Œ± A]

/-- The action on an additive subgroup corresponding to applying the action to every element.

This is available as an instance in the `Pointwise` locale. -/
protected def pointwiseMulAction : MulAction Œ± (AddSubgroup A) where
  smul a S := S.map (DistribMulAction.toAddMonoidEnd _ _ a)
  one_smul S := by
    change S.map _ = S
    -- ‚ä¢ map (‚Üë(DistribMulAction.toAddMonoidEnd Œ± A) 1) S = S
    simpa only [map_one] using S.map_id
    -- üéâ no goals
  mul_smul _ _ S :=
    (congr_arg (fun f : AddMonoid.End A => S.map f) (MonoidHom.map_mul _ _ _)).trans
      (S.map_map _ _).symm
#align add_subgroup.pointwise_mul_action AddSubgroup.pointwiseMulAction

scoped[Pointwise] attribute [instance] AddSubgroup.pointwiseMulAction

@[simp]
theorem coe_pointwise_smul (a : Œ±) (S : AddSubgroup A) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set A) :=
  rfl
#align add_subgroup.coe_pointwise_smul AddSubgroup.coe_pointwise_smul

@[simp]
theorem pointwise_smul_toAddSubmonoid (a : Œ±) (S : AddSubgroup A) :
    (a ‚Ä¢ S).toAddSubmonoid = a ‚Ä¢ S.toAddSubmonoid :=
  rfl
#align add_subgroup.pointwise_smul_to_add_submonoid AddSubgroup.pointwise_smul_toAddSubmonoid

theorem smul_mem_pointwise_smul (m : A) (a : Œ±) (S : AddSubgroup A) : m ‚àà S ‚Üí a ‚Ä¢ m ‚àà a ‚Ä¢ S :=
  (Set.smul_mem_smul_set : _ ‚Üí _ ‚àà a ‚Ä¢ (S : Set A))
#align add_subgroup.smul_mem_pointwise_smul AddSubgroup.smul_mem_pointwise_smul

theorem mem_smul_pointwise_iff_exists (m : A) (a : Œ±) (S : AddSubgroup A) :
    m ‚àà a ‚Ä¢ S ‚Üî ‚àÉ s : A, s ‚àà S ‚àß a ‚Ä¢ s = m :=
  (Set.mem_smul_set : m ‚àà a ‚Ä¢ (S : Set A) ‚Üî _)
#align add_subgroup.mem_smul_pointwise_iff_exists AddSubgroup.mem_smul_pointwise_iff_exists

instance pointwise_isCentralScalar [DistribMulAction Œ±·µê·µí·µñ A] [IsCentralScalar Œ± A] :
    IsCentralScalar Œ± (AddSubgroup A) :=
  ‚ü®fun _ S => (congr_arg fun f => S.map f) <| AddMonoidHom.ext <| op_smul_eq_smul _‚ü©
#align add_subgroup.pointwise_central_scalar AddSubgroup.pointwise_isCentralScalar

end Monoid

section Group

variable [Group Œ±] [DistribMulAction Œ± A]

open Pointwise

@[simp]
theorem smul_mem_pointwise_smul_iff {a : Œ±} {S : AddSubgroup A} {x : A} : a ‚Ä¢ x ‚àà a ‚Ä¢ S ‚Üî x ‚àà S :=
  smul_mem_smul_set_iff
#align add_subgroup.smul_mem_pointwise_smul_iff AddSubgroup.smul_mem_pointwise_smul_iff

theorem mem_pointwise_smul_iff_inv_smul_mem {a : Œ±} {S : AddSubgroup A} {x : A} :
    x ‚àà a ‚Ä¢ S ‚Üî a‚Åª¬π ‚Ä¢ x ‚àà S :=
  mem_smul_set_iff_inv_smul_mem
#align add_subgroup.mem_pointwise_smul_iff_inv_smul_mem AddSubgroup.mem_pointwise_smul_iff_inv_smul_mem

theorem mem_inv_pointwise_smul_iff {a : Œ±} {S : AddSubgroup A} {x : A} : x ‚àà a‚Åª¬π ‚Ä¢ S ‚Üî a ‚Ä¢ x ‚àà S :=
  mem_inv_smul_set_iff
#align add_subgroup.mem_inv_pointwise_smul_iff AddSubgroup.mem_inv_pointwise_smul_iff

@[simp]
theorem pointwise_smul_le_pointwise_smul_iff {a : Œ±} {S T : AddSubgroup A} :
    a ‚Ä¢ S ‚â§ a ‚Ä¢ T ‚Üî S ‚â§ T :=
  set_smul_subset_set_smul_iff
#align add_subgroup.pointwise_smul_le_pointwise_smul_iff AddSubgroup.pointwise_smul_le_pointwise_smul_iff

theorem pointwise_smul_le_iff {a : Œ±} {S T : AddSubgroup A} : a ‚Ä¢ S ‚â§ T ‚Üî S ‚â§ a‚Åª¬π ‚Ä¢ T :=
  set_smul_subset_iff
#align add_subgroup.pointwise_smul_le_iff AddSubgroup.pointwise_smul_le_iff

theorem le_pointwise_smul_iff {a : Œ±} {S T : AddSubgroup A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=
  subset_set_smul_iff
#align add_subgroup.le_pointwise_smul_iff AddSubgroup.le_pointwise_smul_iff

end Group

section GroupWithZero

variable [GroupWithZero Œ±] [DistribMulAction Œ± A]

open Pointwise

@[simp]
theorem smul_mem_pointwise_smul_iff‚ÇÄ {a : Œ±} (ha : a ‚â† 0) (S : AddSubgroup A) (x : A) :
    a ‚Ä¢ x ‚àà a ‚Ä¢ S ‚Üî x ‚àà S :=
  smul_mem_smul_set_iff‚ÇÄ ha (S : Set A) x
#align add_subgroup.smul_mem_pointwise_smul_iff‚ÇÄ AddSubgroup.smul_mem_pointwise_smul_iff‚ÇÄ

theorem mem_pointwise_smul_iff_inv_smul_mem‚ÇÄ {a : Œ±} (ha : a ‚â† 0) (S : AddSubgroup A) (x : A) :
    x ‚àà a ‚Ä¢ S ‚Üî a‚Åª¬π ‚Ä¢ x ‚àà S :=
  mem_smul_set_iff_inv_smul_mem‚ÇÄ ha (S : Set A) x
#align add_subgroup.mem_pointwise_smul_iff_inv_smul_mem‚ÇÄ AddSubgroup.mem_pointwise_smul_iff_inv_smul_mem‚ÇÄ

theorem mem_inv_pointwise_smul_iff‚ÇÄ {a : Œ±} (ha : a ‚â† 0) (S : AddSubgroup A) (x : A) :
    x ‚àà a‚Åª¬π ‚Ä¢ S ‚Üî a ‚Ä¢ x ‚àà S :=
  mem_inv_smul_set_iff‚ÇÄ ha (S : Set A) x
#align add_subgroup.mem_inv_pointwise_smul_iff‚ÇÄ AddSubgroup.mem_inv_pointwise_smul_iff‚ÇÄ

@[simp]
theorem pointwise_smul_le_pointwise_smul_iff‚ÇÄ {a : Œ±} (ha : a ‚â† 0) {S T : AddSubgroup A} :
    a ‚Ä¢ S ‚â§ a ‚Ä¢ T ‚Üî S ‚â§ T :=
  set_smul_subset_set_smul_iff‚ÇÄ ha
#align add_subgroup.pointwise_smul_le_pointwise_smul_iff‚ÇÄ AddSubgroup.pointwise_smul_le_pointwise_smul_iff‚ÇÄ

theorem pointwise_smul_le_iff‚ÇÄ {a : Œ±} (ha : a ‚â† 0) {S T : AddSubgroup A} :
    a ‚Ä¢ S ‚â§ T ‚Üî S ‚â§ a‚Åª¬π ‚Ä¢ T :=
  set_smul_subset_iff‚ÇÄ ha
#align add_subgroup.pointwise_smul_le_iff‚ÇÄ AddSubgroup.pointwise_smul_le_iff‚ÇÄ

theorem le_pointwise_smul_iff‚ÇÄ {a : Œ±} (ha : a ‚â† 0) {S T : AddSubgroup A} :
    S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=
  subset_set_smul_iff‚ÇÄ ha
#align add_subgroup.le_pointwise_smul_iff‚ÇÄ AddSubgroup.le_pointwise_smul_iff‚ÇÄ

end GroupWithZero

end AddSubgroup
