/-
Copyright (c) 2018 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau, Michael Howes
-/
import Mathlib.Data.Finite.Card
import Mathlib.GroupTheory.Commutator
import Mathlib.GroupTheory.Finiteness

#align_import group_theory.abelianization from "leanprover-community/mathlib"@"4be589053caf347b899a494da75410deb55fb3ef"

/-!
# The abelianization of a group

This file defines the commutator and the abelianization of a group. It furthermore prepares for the
result that the abelianization is left adjoint to the forgetful functor from abelian groups to
groups, which can be found in `Algebra/Category/Group/Adjunctions`.

## Main definitions

* `commutator`: defines the commutator of a group `G` as a subgroup of `G`.
* `Abelianization`: defines the abelianization of a group `G` as the quotient of a group by its
  commutator subgroup.
* `Abelianization.map`: lifts a group homomorphism to a homomorphism between the abelianizations
* `MulEquiv.abelianizationCongr`: Equivalent groups have equivalent abelianizations

-/


universe u v w

-- Let G be a group.
variable (G : Type u) [Group G]

open Subgroup (centralizer)

/-- The commutator subgroup of a group G is the normal subgroup
  generated by the commutators [p,q]=`p*q*pâ»Â¹*qâ»Â¹`. -/
def commutator : Subgroup G := â…(âŠ¤ : Subgroup G), âŠ¤â†
#align commutator commutator

-- Porting note: this instance should come from `deriving Subgroup.Normal`
instance : Subgroup.Normal (commutator G) := Subgroup.commutator_normal âŠ¤ âŠ¤

theorem commutator_def : commutator G = â…(âŠ¤ : Subgroup G), âŠ¤â† :=
  rfl
#align commutator_def commutator_def

theorem commutator_eq_closure : commutator G = Subgroup.closure (commutatorSet G) := by
  simp [commutator, Subgroup.commutator_def, commutatorSet]
  -- ğŸ‰ no goals
#align commutator_eq_closure commutator_eq_closure

theorem commutator_eq_normalClosure : commutator G = Subgroup.normalClosure (commutatorSet G) := by
  simp [commutator, Subgroup.commutator_def', commutatorSet]
  -- ğŸ‰ no goals
#align commutator_eq_normal_closure commutator_eq_normalClosure

instance commutator_characteristic : (commutator G).Characteristic :=
  Subgroup.commutator_characteristic âŠ¤ âŠ¤
#align commutator_characteristic commutator_characteristic

instance [Finite (commutatorSet G)] : Group.FG (commutator G) := by
  rw [commutator_eq_closure]
  -- âŠ¢ Group.FG { x // x âˆˆ Subgroup.closure (commutatorSet G) }
  apply Group.closure_finite_fg
  -- ğŸ‰ no goals

theorem rank_commutator_le_card [Finite (commutatorSet G)] :
    Group.rank (commutator G) â‰¤ Nat.card (commutatorSet G) := by
  rw [Subgroup.rank_congr (commutator_eq_closure G)]
  -- âŠ¢ Group.rank { x // x âˆˆ Subgroup.closure (commutatorSet G) } â‰¤ Nat.card â†‘(comm â€¦
  apply Subgroup.rank_closure_finite_le_nat_card
  -- ğŸ‰ no goals
#align rank_commutator_le_card rank_commutator_le_card

theorem commutator_centralizer_commutator_le_center :
    â…centralizer (commutator G : Set G), centralizer (commutator G)â† â‰¤ Subgroup.center G := by
  rw [â† Subgroup.centralizer_univ, â† Subgroup.coe_top, â†
    Subgroup.commutator_eq_bot_iff_le_centralizer]
  suffices â…â…âŠ¤, centralizer (commutator G : Set G)â†, centralizer (commutator G : Set G)â† = âŠ¥ by
    refine' Subgroup.commutator_commutator_eq_bot_of_rotate _ this
    rwa [Subgroup.commutator_comm (centralizer (commutator G : Set G))]
  rw [Subgroup.commutator_comm, Subgroup.commutator_eq_bot_iff_le_centralizer]
  -- âŠ¢ centralizer â†‘(commutator G) â‰¤ centralizer â†‘â…âŠ¤, centralizer â†‘(commutator G)â†
  exact Set.centralizer_subset (Subgroup.commutator_mono le_top le_top)
  -- ğŸ‰ no goals
#align commutator_centralizer_commutator_le_center commutator_centralizer_commutator_le_center

/-- The abelianization of G is the quotient of G by its commutator subgroup. -/
def Abelianization : Type u :=
  G â§¸ commutator G
#align abelianization Abelianization

namespace Abelianization

attribute [local instance] QuotientGroup.leftRel

instance commGroup : CommGroup (Abelianization G) :=
  { QuotientGroup.Quotient.group _ with
    mul_comm := fun x y =>
      Quotient.inductionOnâ‚‚' x y fun a b =>
        Quotient.sound' <|
          QuotientGroup.leftRel_apply.mpr <|
            Subgroup.subset_closure
              âŸ¨bâ»Â¹, Subgroup.mem_top bâ»Â¹, aâ»Â¹, Subgroup.mem_top aâ»Â¹, by groupâŸ© }
                                                                        -- ğŸ‰ no goals

instance : Inhabited (Abelianization G) :=
  âŸ¨1âŸ©

instance [Fintype G] [DecidablePred (Â· âˆˆ commutator G)] : Fintype (Abelianization G) :=
  QuotientGroup.fintype (commutator G)

instance [Finite G] : Finite (Abelianization G) :=
  Quotient.finite _

variable {G}

/-- `of` is the canonical projection from G to its abelianization. -/
def of : G â†’* Abelianization G where
  toFun := QuotientGroup.mk
  map_one' := rfl
  map_mul' _ _ := rfl
#align abelianization.of Abelianization.of

@[simp]
theorem mk_eq_of (a : G) : Quot.mk _ a = of a :=
  rfl
#align abelianization.mk_eq_of Abelianization.mk_eq_of

section lift

-- So far we have built Gáµƒáµ‡ and proved it's an abelian group.
-- Furthermore we defined the canonical projection `of : G â†’ Gáµƒáµ‡`
-- Let `A` be an abelian group and let `f` be a group homomorphism from `G` to `A`.
variable {A : Type v} [CommGroup A] (f : G â†’* A)

theorem commutator_subset_ker : commutator G â‰¤ f.ker := by
  rw [commutator_eq_closure, Subgroup.closure_le]
  -- âŠ¢ commutatorSet G âŠ† â†‘(MonoidHom.ker f)
  rintro x âŸ¨p, q, rflâŸ©
  -- âŠ¢ â…p, qâ† âˆˆ â†‘(MonoidHom.ker f)
  simp [MonoidHom.mem_ker, mul_right_comm (f p) (f q), commutatorElement_def]
  -- ğŸ‰ no goals
#align abelianization.commutator_subset_ker Abelianization.commutator_subset_ker

/-- If `f : G â†’ A` is a group homomorphism to an abelian group, then `lift f` is the unique map
  from the abelianization of a `G` to `A` that factors through `f`. -/
def lift : (G â†’* A) â‰ƒ (Abelianization G â†’* A) where
  toFun f := QuotientGroup.lift _ f fun _ h => f.mem_ker.2 <| commutator_subset_ker _ h
  invFun F := F.comp of
  left_inv _ := MonoidHom.ext fun _ => rfl
  right_inv _ := MonoidHom.ext fun x => QuotientGroup.induction_on x fun _ => rfl
#align abelianization.lift Abelianization.lift

@[simp]
theorem lift.of (x : G) : lift f (of x) = f x :=
  rfl
#align abelianization.lift.of Abelianization.lift.of

theorem lift.unique (Ï† : Abelianization G â†’* A)
    -- hÏ† : Ï† agrees with f on the image of G in Gáµƒáµ‡
    (hÏ† : âˆ€ x : G, Ï† (Abelianization.of x) = f x)
    {x : Abelianization G} : Ï† x = lift f x :=
  QuotientGroup.induction_on x hÏ†
#align abelianization.lift.unique Abelianization.lift.unique

@[simp]
theorem lift_of : lift of = MonoidHom.id (Abelianization G) :=
  lift.apply_symm_apply <| MonoidHom.id _
#align abelianization.lift_of Abelianization.lift_of

end lift

variable {A : Type v} [Monoid A]

/-- See note [partially-applied ext lemmas]. -/
@[ext]
theorem hom_ext (Ï† Ïˆ : Abelianization G â†’* A) (h : Ï†.comp of = Ïˆ.comp of) : Ï† = Ïˆ :=
  MonoidHom.ext fun x => QuotientGroup.induction_on x <| FunLike.congr_fun h
#align abelianization.hom_ext Abelianization.hom_ext

section Map

variable {H : Type v} [Group H] (f : G â†’* H)

/-- The map operation of the `Abelianization` functor -/
def map : Abelianization G â†’* Abelianization H :=
  lift (of.comp f)
#align abelianization.map Abelianization.map

@[simp]
theorem map_of (x : G) : map f (of x) = of (f x) :=
  rfl
#align abelianization.map_of Abelianization.map_of

@[simp]
theorem map_id : map (MonoidHom.id G) = MonoidHom.id (Abelianization G) :=
  hom_ext _ _ rfl
#align abelianization.map_id Abelianization.map_id

@[simp]
theorem map_comp {I : Type w} [Group I] (g : H â†’* I) : (map g).comp (map f) = map (g.comp f) :=
  hom_ext _ _ rfl
#align abelianization.map_comp Abelianization.map_comp

@[simp]
theorem map_map_apply {I : Type w} [Group I] {g : H â†’* I} {x : Abelianization G} :
    map g (map f x) = map (g.comp f) x :=
  FunLike.congr_fun (map_comp _ _) x
#align abelianization.map_map_apply Abelianization.map_map_apply

end Map

end Abelianization

section AbelianizationCongr

-- Porting note: `[Group G]` should not be necessary here
variable {G} [Group G] {H : Type v} [Group H] (e : G â‰ƒ* H)

/-- Equivalent groups have equivalent abelianizations -/
def MulEquiv.abelianizationCongr : Abelianization G â‰ƒ* Abelianization H where
  toFun := Abelianization.map e.toMonoidHom
  invFun := Abelianization.map e.symm.toMonoidHom
  left_inv := by
    rintro âŸ¨aâŸ©
    -- âŠ¢ â†‘(Abelianization.map (toMonoidHom (symm e))) (â†‘(Abelianization.map (toMonoid â€¦
    simp
    -- ğŸ‰ no goals
  right_inv := by
    rintro âŸ¨aâŸ©
    -- âŠ¢ â†‘(Abelianization.map (toMonoidHom e)) (â†‘(Abelianization.map (toMonoidHom (sy â€¦
    simp
    -- ğŸ‰ no goals
  map_mul' := MonoidHom.map_mul _
#align mul_equiv.abelianization_congr MulEquiv.abelianizationCongr

@[simp]
theorem abelianizationCongr_of (x : G) :
    e.abelianizationCongr (Abelianization.of x) = Abelianization.of (e x) :=
  rfl
#align abelianization_congr_of abelianizationCongr_of

@[simp]
theorem abelianizationCongr_refl :
    (MulEquiv.refl G).abelianizationCongr = MulEquiv.refl (Abelianization G) :=
  MulEquiv.toMonoidHom_injective Abelianization.lift_of
#align abelianization_congr_refl abelianizationCongr_refl

@[simp]
theorem abelianizationCongr_symm : e.abelianizationCongr.symm = e.symm.abelianizationCongr :=
  rfl
#align abelianization_congr_symm abelianizationCongr_symm

@[simp]
theorem abelianizationCongr_trans {I : Type v} [Group I] (eâ‚‚ : H â‰ƒ* I) :
    e.abelianizationCongr.trans eâ‚‚.abelianizationCongr = (e.trans eâ‚‚).abelianizationCongr :=
  MulEquiv.toMonoidHom_injective (Abelianization.hom_ext _ _ rfl)
#align abelianization_congr_trans abelianizationCongr_trans

end AbelianizationCongr

/-- An Abelian group is equivalent to its own abelianization. -/
@[simps]
def Abelianization.equivOfComm {H : Type*} [CommGroup H] : H â‰ƒ* Abelianization H :=
  { Abelianization.of with
    toFun := Abelianization.of
    invFun := Abelianization.lift (MonoidHom.id H)
    left_inv := fun a => rfl
    right_inv := by
      rintro âŸ¨aâŸ©
      -- âŠ¢ â†‘of (â†‘(â†‘lift (MonoidHom.id H)) (Quot.mk Setoid.r a)) = Quot.mk Setoid.r a
      rfl }
      -- ğŸ‰ no goals
#align abelianization.equiv_of_comm Abelianization.equivOfComm

section commutatorRepresentatives

open Subgroup

/-- Representatives `(gâ‚, gâ‚‚) : G Ã— G` of commutators `â…gâ‚, gâ‚‚â† âˆˆ G`. -/
def commutatorRepresentatives : Set (G Ã— G) :=
  Set.range fun g : commutatorSet G => (g.2.choose, g.2.choose_spec.choose)
#align commutator_representatives commutatorRepresentatives

instance [Finite (commutatorSet G)] : Finite (commutatorRepresentatives G) :=
  Set.finite_coe_iff.mpr (Set.finite_range _)

/-- Subgroup generated by representatives `gâ‚ gâ‚‚ : G` of commutators `â…gâ‚, gâ‚‚â† âˆˆ G`. -/
def closureCommutatorRepresentatives : Subgroup G :=
  closure (Prod.fst '' commutatorRepresentatives G âˆª Prod.snd '' commutatorRepresentatives G)
#align closure_commutator_representatives closureCommutatorRepresentatives

instance closureCommutatorRepresentatives_fg [Finite (commutatorSet G)] :
    Group.FG (closureCommutatorRepresentatives G) :=
  Group.closure_finite_fg _
#align closure_commutator_representatives_fg closureCommutatorRepresentatives_fg

theorem rank_closureCommutatorRepresentatives_le [Finite (commutatorSet G)] :
    Group.rank (closureCommutatorRepresentatives G) â‰¤ 2 * Nat.card (commutatorSet G) := by
  rw [two_mul]
  -- âŠ¢ Group.rank { x // x âˆˆ closureCommutatorRepresentatives G } â‰¤ Nat.card â†‘(comm â€¦
  exact
    (Subgroup.rank_closure_finite_le_nat_card _).trans
      ((Set.card_union_le _ _).trans
        (add_le_add ((Finite.card_image_le _).trans (Finite.card_range_le _))
          ((Finite.card_image_le _).trans (Finite.card_range_le _))))
#align rank_closure_commutator_representations_le rank_closureCommutatorRepresentatives_le

theorem image_commutatorSet_closureCommutatorRepresentatives :
    (closureCommutatorRepresentatives G).subtype ''
        commutatorSet (closureCommutatorRepresentatives G) =
      commutatorSet G := by
  apply Set.Subset.antisymm
  -- âŠ¢ â†‘(Subgroup.subtype (closureCommutatorRepresentatives G)) '' commutatorSet {  â€¦
  Â· rintro - âŸ¨-, âŸ¨gâ‚, gâ‚‚, rflâŸ©, rflâŸ©
    -- âŠ¢ â†‘(Subgroup.subtype (closureCommutatorRepresentatives G)) â…gâ‚, gâ‚‚â† âˆˆ commutat â€¦
    exact âŸ¨gâ‚, gâ‚‚, rflâŸ©
    -- ğŸ‰ no goals
  Â· exact fun g hg =>
      âŸ¨_,
        âŸ¨âŸ¨_, subset_closure (Or.inl âŸ¨_, âŸ¨âŸ¨g, hgâŸ©, rflâŸ©, rflâŸ©)âŸ©,
          âŸ¨_, subset_closure (Or.inr âŸ¨_, âŸ¨âŸ¨g, hgâŸ©, rflâŸ©, rflâŸ©)âŸ©, rflâŸ©,
        hg.choose_spec.choose_specâŸ©
#align image_commutator_set_closure_commutator_representatives image_commutatorSet_closureCommutatorRepresentatives

theorem card_commutatorSet_closureCommutatorRepresentatives :
    Nat.card (commutatorSet (closureCommutatorRepresentatives G)) = Nat.card (commutatorSet G) := by
  rw [â† image_commutatorSet_closureCommutatorRepresentatives G]
  -- âŠ¢ Nat.card â†‘(commutatorSet { x // x âˆˆ closureCommutatorRepresentatives G }) =  â€¦
  exact Nat.card_congr (Equiv.Set.image _ _ (subtype_injective _))
  -- ğŸ‰ no goals
#align card_commutator_set_closure_commutator_representatives card_commutatorSet_closureCommutatorRepresentatives

theorem card_commutator_closureCommutatorRepresentatives :
    Nat.card (commutator (closureCommutatorRepresentatives G)) = Nat.card (commutator G) := by
  rw [commutator_eq_closure G, â† image_commutatorSet_closureCommutatorRepresentatives, â†
    MonoidHom.map_closure, â† commutator_eq_closure]
  exact Nat.card_congr (Equiv.Set.image _ _ (subtype_injective _))
  -- ğŸ‰ no goals
#align card_commutator_closure_commutator_representatives card_commutator_closureCommutatorRepresentatives

instance [Finite (commutatorSet G)] :
    Finite (commutatorSet (closureCommutatorRepresentatives G)) := by
  apply Nat.finite_of_card_ne_zero
  -- âŠ¢ Nat.card â†‘(commutatorSet { x // x âˆˆ closureCommutatorRepresentatives G }) â‰  0
  rw [card_commutatorSet_closureCommutatorRepresentatives]
  -- âŠ¢ Nat.card â†‘(commutatorSet G) â‰  0
  exact Finite.card_pos.ne'
  -- ğŸ‰ no goals

end commutatorRepresentatives
