/-
Copyright (c) 2025 Dexin Zhang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Dexin Zhang
-/
module

public import Mathlib.Data.Set.Finite.Basic
public import Mathlib.Data.Set.Lattice
public import Mathlib.GroupTheory.GroupAction.SubMulAction

/-!
# Closure and finiteness of `SubMulAction` and `SubAddAction`
-/

@[expose] public section

namespace SubMulAction

/-- The `SubMulAction` generated by a set `s`. -/
@[to_additive /-- The `SubAddAction` generated by a set `s`. -/]
def closure (R : Type*) {M : Type*} [SMul R M] (s : Set M) : SubMulAction R M :=
  sInf { p | s ⊆ (p : Set M) }

variable {R M : Type*} [SMul R M] {s t : Set M} {x : M}

@[to_additive]
theorem mem_closure : x ∈ closure R s ↔ ∀ p : SubMulAction R M, s ⊆ p → x ∈ p :=
  Set.mem_iInter₂

@[to_additive]
theorem subset_closure : s ⊆ closure R s := fun _ h => mem_closure.2 fun _ hp => hp h

@[to_additive]
theorem mem_closure_of_mem (hx : x ∈ s) : x ∈ closure R s := subset_closure hx

@[to_additive]
theorem closure_le {p} : closure R s ≤ p ↔ s ⊆ p :=
  ⟨subset_closure.trans, fun ss _ h => mem_closure.1 h _ ss⟩

@[to_additive (attr := gcongr)]
theorem closure_mono (h : s ⊆ t) : closure R s ≤ closure R t :=
  closure_le.2 <| h.trans subset_closure

/-- A `SubMulAction` is finitely generated if it is the closure of a finite set. -/
@[to_additive /-- A `SubAddAction` is finitely generated if it is the closure of a finite set. -/]
def FG (p : SubMulAction R M) :=
  ∃ (s : Set M), s.Finite ∧ p = closure R s

@[to_additive]
theorem fg_iff {p : SubMulAction R M} : p.FG ↔ ∃ (s : Finset M), p = closure R s :=
  Set.exists_finite_iff_finset

end SubMulAction
