/-
Copyright (c) 2020 Chris Hughes. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Chris Hughes
-/
import Mathlib.Algebra.Hom.Aut
import Mathlib.Logic.Function.Basic
import Mathlib.GroupTheory.Subgroup.Basic

#align_import group_theory.semidirect_product from "leanprover-community/mathlib"@"f7fc89d5d5ff1db2d1242c7bb0e9062ce47ef47c"

/-!
# Semidirect product

This file defines semidirect products of groups, and the canonical maps in and out of the
semidirect product. The semidirect product of `N` and `G` given a hom `Ï†` from
`G` to the automorphism group of `N` is the product of sets with the group
`âŸ¨nâ‚, gâ‚âŸ© * âŸ¨nâ‚‚, gâ‚‚âŸ© = âŸ¨nâ‚ * Ï† gâ‚ nâ‚‚, gâ‚ * gâ‚‚âŸ©`

## Key definitions

There are two homs into the semidirect product `inl : N â†’* N â‹Š[Ï†] G` and
`inr : G â†’* N â‹Š[Ï†] G`, and `lift` can be used to define maps `N â‹Š[Ï†] G â†’* H`
out of the semidirect product given maps `fâ‚ : N â†’* H` and `fâ‚‚ : G â†’* H` that satisfy the
condition `âˆ€ n g, fâ‚ (Ï† g n) = fâ‚‚ g * fâ‚ n * fâ‚‚ gâ»Â¹`

## Notation

This file introduces the global notation `N â‹Š[Ï†] G` for `SemidirectProduct N G Ï†`

## Tags
group, semidirect product
-/


variable (N : Type*) (G : Type*) {H : Type*} [Group N] [Group G] [Group H]

/-- The semidirect product of groups `N` and `G`, given a map `Ï†` from `G` to the automorphism
  group of `N`. It the product of sets with the group operation
  `âŸ¨nâ‚, gâ‚âŸ© * âŸ¨nâ‚‚, gâ‚‚âŸ© = âŸ¨nâ‚ * Ï† gâ‚ nâ‚‚, gâ‚ * gâ‚‚âŸ©` -/
@[ext]
structure SemidirectProduct (Ï† : G â†’* MulAut N) where
  /-- The element of N -/
  left : N
  /-- The element of G -/
  right : G
  deriving DecidableEq
#align semidirect_product SemidirectProduct

-- Porting note: these lemmas are autogenerated by the inductive definition and are not
-- in simple form due to the existence of mk_eq_inl_mul_inr
attribute [nolint simpNF] SemidirectProduct.mk.injEq
attribute [nolint simpNF] SemidirectProduct.mk.sizeOf_spec

-- Porting note: unknown attribute
-- attribute [pp_using_anonymous_constructor] SemidirectProduct

@[inherit_doc]
notation:35 N " â‹Š[" Ï†:35 "] " G:35 => SemidirectProduct N G Ï†

namespace SemidirectProduct

variable {N G}
variable {Ï† : G â†’* MulAut N}

instance : Mul (SemidirectProduct N G Ï†) where
  mul a b := âŸ¨a.1 * Ï† a.2 b.1, a.2 * b.2âŸ©

lemma mul_def (a b : SemidirectProduct N G Ï†) :
  a * b = âŸ¨a.1 * Ï† a.2 b.1, a.2 * b.2âŸ© := rfl

@[simp]
theorem mul_left (a b : N â‹Š[Ï†] G) : (a * b).left = a.left * Ï† a.right b.left := rfl
#align semidirect_product.mul_left SemidirectProduct.mul_left

@[simp]
theorem mul_right (a b : N â‹Š[Ï†] G) : (a * b).right = a.right * b.right := rfl
#align semidirect_product.mul_right SemidirectProduct.mul_right

instance : One (SemidirectProduct N G Ï†) where one := âŸ¨1, 1âŸ©

@[simp]
theorem one_left : (1 : N â‹Š[Ï†] G).left = 1 := rfl
#align semidirect_product.one_left SemidirectProduct.one_left

@[simp]
theorem one_right : (1 : N â‹Š[Ï†] G).right = 1 := rfl
#align semidirect_product.one_right SemidirectProduct.one_right

instance : Inv (SemidirectProduct N G Ï†) where
  inv x := âŸ¨Ï† x.2â»Â¹ x.1â»Â¹, x.2â»Â¹âŸ©

@[simp]
theorem inv_left (a : N â‹Š[Ï†] G) : aâ»Â¹.left = Ï† a.rightâ»Â¹ a.leftâ»Â¹ := rfl
#align semidirect_product.inv_left SemidirectProduct.inv_left

@[simp]
theorem inv_right (a : N â‹Š[Ï†] G) : aâ»Â¹.right = a.rightâ»Â¹ := rfl
#align semidirect_product.inv_right SemidirectProduct.inv_right

instance : Group (N â‹Š[Ï†] G) where
  mul_assoc a b c := SemidirectProduct.ext _ _ (by simp [mul_assoc]) (by simp [mul_assoc])
                                                   -- ğŸ‰ no goals
                                                                         -- ğŸ‰ no goals
  one_mul a := SemidirectProduct.ext _ _ (by simp) (one_mul a.2)
                                             -- ğŸ‰ no goals
  mul_one a := SemidirectProduct.ext _ _ (by simp) (mul_one _)
                                             -- ğŸ‰ no goals
  mul_left_inv a := SemidirectProduct.ext _ _ (by simp) (by simp)
                                                  -- ğŸ‰ no goals
                                                            -- ğŸ‰ no goals

instance : Inhabited (N â‹Š[Ï†] G) := âŸ¨1âŸ©

/-- The canonical map `N â†’* N â‹Š[Ï†] G` sending `n` to `âŸ¨n, 1âŸ©` -/
def inl : N â†’* N â‹Š[Ï†] G where
  toFun n := âŸ¨n, 1âŸ©
  map_one' := rfl
  map_mul' := by intros; ext <;>
                 -- âŠ¢ OneHom.toFun { toFun := fun n => { left := n, right := 1 }, map_one' := (_ : â€¦
                         -- âŠ¢ (OneHom.toFun { toFun := fun n => { left := n, right := 1 }, map_one' := (_  â€¦
    simp only [mul_left, map_one, MulAut.one_apply, mul_right, mul_one]
    -- ğŸ‰ no goals
    -- ğŸ‰ no goals
#align semidirect_product.inl SemidirectProduct.inl

@[simp]
theorem left_inl (n : N) : (inl n : N â‹Š[Ï†] G).left = n := rfl
#align semidirect_product.left_inl SemidirectProduct.left_inl

@[simp]
theorem right_inl (n : N) : (inl n : N â‹Š[Ï†] G).right = 1 := rfl
#align semidirect_product.right_inl SemidirectProduct.right_inl

theorem inl_injective : Function.Injective (inl : N â†’ N â‹Š[Ï†] G) :=
  Function.injective_iff_hasLeftInverse.2 âŸ¨left, left_inlâŸ©
#align semidirect_product.inl_injective SemidirectProduct.inl_injective

@[simp]
theorem inl_inj {nâ‚ nâ‚‚ : N} : (inl nâ‚ : N â‹Š[Ï†] G) = inl nâ‚‚ â†” nâ‚ = nâ‚‚ :=
  inl_injective.eq_iff
#align semidirect_product.inl_inj SemidirectProduct.inl_inj

/-- The canonical map `G â†’* N â‹Š[Ï†] G` sending `g` to `âŸ¨1, gâŸ©` -/
def inr : G â†’* N â‹Š[Ï†] G where
  toFun g := âŸ¨1, gâŸ©
  map_one' := rfl
  map_mul' := by intros; ext <;> simp
                 -- âŠ¢ OneHom.toFun { toFun := fun g => { left := 1, right := g }, map_one' := (_ : â€¦
                         -- âŠ¢ (OneHom.toFun { toFun := fun g => { left := 1, right := g }, map_one' := (_  â€¦
                                 -- ğŸ‰ no goals
                                 -- ğŸ‰ no goals
#align semidirect_product.inr SemidirectProduct.inr

@[simp]
theorem left_inr (g : G) : (inr g : N â‹Š[Ï†] G).left = 1 := rfl
#align semidirect_product.left_inr SemidirectProduct.left_inr

@[simp]
theorem right_inr (g : G) : (inr g : N â‹Š[Ï†] G).right = g := rfl
#align semidirect_product.right_inr SemidirectProduct.right_inr

theorem inr_injective : Function.Injective (inr : G â†’ N â‹Š[Ï†] G) :=
  Function.injective_iff_hasLeftInverse.2 âŸ¨right, right_inrâŸ©
#align semidirect_product.inr_injective SemidirectProduct.inr_injective

@[simp]
theorem inr_inj {gâ‚ gâ‚‚ : G} : (inr gâ‚ : N â‹Š[Ï†] G) = inr gâ‚‚ â†” gâ‚ = gâ‚‚ :=
  inr_injective.eq_iff
#align semidirect_product.inr_inj SemidirectProduct.inr_inj

theorem inl_aut (g : G) (n : N) : (inl (Ï† g n) : N â‹Š[Ï†] G) = inr g * inl n * inr gâ»Â¹ := by
  ext <;> simp
  -- âŠ¢ (â†‘inl (â†‘(â†‘Ï† g) n)).left = (â†‘inr g * â†‘inl n * â†‘inr gâ»Â¹).left
          -- ğŸ‰ no goals
          -- ğŸ‰ no goals
#align semidirect_product.inl_aut SemidirectProduct.inl_aut

theorem inl_aut_inv (g : G) (n : N) : (inl ((Ï† g)â»Â¹ n) : N â‹Š[Ï†] G) = inr gâ»Â¹ * inl n * inr g := by
  rw [â† MonoidHom.map_inv, inl_aut, inv_inv]
  -- ğŸ‰ no goals
#align semidirect_product.inl_aut_inv SemidirectProduct.inl_aut_inv

@[simp]
theorem mk_eq_inl_mul_inr (g : G) (n : N) : (âŸ¨n, gâŸ© : N â‹Š[Ï†] G) = inl n * inr g := by ext <;> simp
                                                                                      -- âŠ¢ { left := n, right := g }.left = (â†‘inl n * â†‘inr g).left
                                                                                              -- ğŸ‰ no goals
                                                                                              -- ğŸ‰ no goals
#align semidirect_product.mk_eq_inl_mul_inr SemidirectProduct.mk_eq_inl_mul_inr

@[simp]
theorem inl_left_mul_inr_right (x : N â‹Š[Ï†] G) : inl x.left * inr x.right = x := by ext <;> simp
                                                                                   -- âŠ¢ (â†‘inl x.left * â†‘inr x.right).left = x.left
                                                                                           -- ğŸ‰ no goals
                                                                                           -- ğŸ‰ no goals
#align semidirect_product.inl_left_mul_inr_right SemidirectProduct.inl_left_mul_inr_right

/-- The canonical projection map `N â‹Š[Ï†] G â†’* G`, as a group hom. -/
def rightHom : N â‹Š[Ï†] G â†’* G where
  toFun := SemidirectProduct.right
  map_one' := rfl
  map_mul' _ _ := rfl
#align semidirect_product.right_hom SemidirectProduct.rightHom

@[simp]
theorem rightHom_eq_right : (rightHom : N â‹Š[Ï†] G â†’ G) = right := rfl
#align semidirect_product.right_hom_eq_right SemidirectProduct.rightHom_eq_right

@[simp]
theorem rightHom_comp_inl : (rightHom : N â‹Š[Ï†] G â†’* G).comp inl = 1 := by ext; simp [rightHom]
                                                                          -- âŠ¢ â†‘(MonoidHom.comp rightHom inl) xâœ = â†‘1 xâœ
                                                                               -- ğŸ‰ no goals
#align semidirect_product.right_hom_comp_inl SemidirectProduct.rightHom_comp_inl

@[simp]
theorem rightHom_comp_inr : (rightHom : N â‹Š[Ï†] G â†’* G).comp inr = MonoidHom.id _ := by
  ext; simp [rightHom]
  -- âŠ¢ â†‘(MonoidHom.comp rightHom inr) xâœ = â†‘(MonoidHom.id G) xâœ
       -- ğŸ‰ no goals
#align semidirect_product.right_hom_comp_inr SemidirectProduct.rightHom_comp_inr

@[simp]
theorem rightHom_inl (n : N) : rightHom (inl n : N â‹Š[Ï†] G) = 1 := by simp [rightHom]
                                                                     -- ğŸ‰ no goals
#align semidirect_product.right_hom_inl SemidirectProduct.rightHom_inl

@[simp]
theorem rightHom_inr (g : G) : rightHom (inr g : N â‹Š[Ï†] G) = g := by simp [rightHom]
                                                                     -- ğŸ‰ no goals
#align semidirect_product.right_hom_inr SemidirectProduct.rightHom_inr

theorem rightHom_surjective : Function.Surjective (rightHom : N â‹Š[Ï†] G â†’ G) :=
  Function.surjective_iff_hasRightInverse.2 âŸ¨inr, rightHom_inrâŸ©
#align semidirect_product.right_hom_surjective SemidirectProduct.rightHom_surjective

theorem range_inl_eq_ker_rightHom : (inl : N â†’* N â‹Š[Ï†] G).range = rightHom.ker :=
  le_antisymm (fun _ â†¦ by simp (config := { contextual := true }) [MonoidHom.mem_ker, eq_comm])
                          -- ğŸ‰ no goals
    fun x hx â†¦ âŸ¨x.left, by ext <;> simp_all [MonoidHom.mem_ker]âŸ©
                           -- âŠ¢ (â†‘inl x.left).left = x.left
                                   -- ğŸ‰ no goals
                                   -- ğŸ‰ no goals
#align semidirect_product.range_inl_eq_ker_right_hom SemidirectProduct.range_inl_eq_ker_rightHom

section lift

variable (fâ‚ : N â†’* H) (fâ‚‚ : G â†’* H)
  (h : âˆ€ g, fâ‚.comp (Ï† g).toMonoidHom = (MulAut.conj (fâ‚‚ g)).toMonoidHom.comp fâ‚)

/-- Define a group hom `N â‹Š[Ï†] G â†’* H`, by defining maps `N â†’* H` and `G â†’* H`  -/
def lift (fâ‚ : N â†’* H) (fâ‚‚ : G â†’* H)
    (h : âˆ€ g, fâ‚.comp (Ï† g).toMonoidHom = (MulAut.conj (fâ‚‚ g)).toMonoidHom.comp fâ‚) : N â‹Š[Ï†] G â†’* H
    where
  toFun a := fâ‚ a.1 * fâ‚‚ a.2
  map_one' := by simp
                 -- ğŸ‰ no goals
  map_mul' a b := by
    have := fun n g â†¦ FunLike.ext_iff.1 (h n) g
    -- âŠ¢ OneHom.toFun { toFun := fun a => â†‘fâ‚ a.left * â†‘fâ‚‚ a.right, map_one' := (_ :  â€¦
    simp only [MulAut.conj_apply, MonoidHom.comp_apply, MulEquiv.coe_toMonoidHom] at this
    -- âŠ¢ OneHom.toFun { toFun := fun a => â†‘fâ‚ a.left * â†‘fâ‚‚ a.right, map_one' := (_ :  â€¦
    simp only [mul_left, mul_right, map_mul, this, mul_assoc, inv_mul_cancel_left]
    -- ğŸ‰ no goals
#align semidirect_product.lift SemidirectProduct.lift

@[simp]
theorem lift_inl (n : N) : lift fâ‚ fâ‚‚ h (inl n) = fâ‚ n := by simp [lift]
                                                             -- ğŸ‰ no goals
#align semidirect_product.lift_inl SemidirectProduct.lift_inl

@[simp]
theorem lift_comp_inl : (lift fâ‚ fâ‚‚ h).comp inl = fâ‚ := by ext; simp
                                                           -- âŠ¢ â†‘(MonoidHom.comp (lift fâ‚ fâ‚‚ h) inl) xâœ = â†‘fâ‚ xâœ
                                                                -- ğŸ‰ no goals
#align semidirect_product.lift_comp_inl SemidirectProduct.lift_comp_inl

@[simp]
theorem lift_inr (g : G) : lift fâ‚ fâ‚‚ h (inr g) = fâ‚‚ g := by simp [lift]
                                                             -- ğŸ‰ no goals
#align semidirect_product.lift_inr SemidirectProduct.lift_inr

@[simp]
theorem lift_comp_inr : (lift fâ‚ fâ‚‚ h).comp inr = fâ‚‚ := by ext; simp
                                                           -- âŠ¢ â†‘(MonoidHom.comp (lift fâ‚ fâ‚‚ h) inr) xâœ = â†‘fâ‚‚ xâœ
                                                                -- ğŸ‰ no goals
#align semidirect_product.lift_comp_inr SemidirectProduct.lift_comp_inr

theorem lift_unique (F : N â‹Š[Ï†] G â†’* H) :
    F = lift (F.comp inl) (F.comp inr) fun _ â†¦ by ext; simp [inl_aut] := by
                                                  -- âŠ¢ â†‘(MonoidHom.comp (MonoidHom.comp F inl) (MulEquiv.toMonoidHom (â†‘Ï† xâœÂ¹))) xâœ  â€¦
                                                       -- ğŸ‰ no goals
  rw [FunLike.ext_iff]
  -- âŠ¢ âˆ€ (x : N â‹Š[Ï†] G), â†‘F x = â†‘(lift (MonoidHom.comp F inl) (MonoidHom.comp F inr â€¦
  simp only [lift, MonoidHom.comp_apply, MonoidHom.coe_mk, OneHom.coe_mk, â† map_mul,
    inl_left_mul_inr_right, forall_const]
#align semidirect_product.lift_unique SemidirectProduct.lift_unique

/-- Two maps out of the semidirect product are equal if they're equal after composition
  with both `inl` and `inr` -/
theorem hom_ext {f g : N â‹Š[Ï†] G â†’* H} (hl : f.comp inl = g.comp inl)
    (hr : f.comp inr = g.comp inr) : f = g := by
  rw [lift_unique f, lift_unique g]
  -- âŠ¢ lift (MonoidHom.comp f inl) (MonoidHom.comp f inr) (_ : âˆ€ (x : G), MonoidHom â€¦
  simp only [*]
  -- ğŸ‰ no goals
#align semidirect_product.hom_ext SemidirectProduct.hom_ext

end lift

section Map

variable {Nâ‚ : Type*} {Gâ‚ : Type*} [Group Nâ‚] [Group Gâ‚] {Ï†â‚ : Gâ‚ â†’* MulAut Nâ‚}

/-- Define a map from `N â‹Š[Ï†] G` to `Nâ‚ â‹Š[Ï†â‚] Gâ‚` given maps `N â†’* Nâ‚` and `G â†’* Gâ‚` that
  satisfy a commutativity condition `âˆ€ n g, fâ‚ (Ï† g n) = Ï†â‚ (fâ‚‚ g) (fâ‚ n)`.  -/
def map (fâ‚ : N â†’* Nâ‚) (fâ‚‚ : G â†’* Gâ‚)
    (h : âˆ€ g : G, fâ‚.comp (Ï† g).toMonoidHom = (Ï†â‚ (fâ‚‚ g)).toMonoidHom.comp fâ‚) :
    N â‹Š[Ï†] G â†’* Nâ‚ â‹Š[Ï†â‚] Gâ‚ where
  toFun x := âŸ¨fâ‚ x.1, fâ‚‚ x.2âŸ©
  map_one' := by simp
                 -- ğŸ‰ no goals
  map_mul' x y := by
    replace h := FunLike.ext_iff.1 (h x.right) y.left
    -- âŠ¢ OneHom.toFun { toFun := fun x => { left := â†‘fâ‚ x.left, right := â†‘fâ‚‚ x.right  â€¦
    ext <;> simp_all
    -- âŠ¢ (OneHom.toFun { toFun := fun x => { left := â†‘fâ‚ x.left, right := â†‘fâ‚‚ x.right â€¦
            -- ğŸ‰ no goals
            -- ğŸ‰ no goals
#align semidirect_product.map SemidirectProduct.map

variable (fâ‚ : N â†’* Nâ‚) (fâ‚‚ : G â†’* Gâ‚)
  (h : âˆ€ g : G, fâ‚.comp (Ï† g).toMonoidHom = (Ï†â‚ (fâ‚‚ g)).toMonoidHom.comp fâ‚)

@[simp]
theorem map_left (g : N â‹Š[Ï†] G) : (map fâ‚ fâ‚‚ h g).left = fâ‚ g.left := rfl
#align semidirect_product.map_left SemidirectProduct.map_left

@[simp]
theorem map_right (g : N â‹Š[Ï†] G) : (map fâ‚ fâ‚‚ h g).right = fâ‚‚ g.right := rfl
#align semidirect_product.map_right SemidirectProduct.map_right

@[simp]
theorem rightHom_comp_map : rightHom.comp (map fâ‚ fâ‚‚ h) = fâ‚‚.comp rightHom := rfl
#align semidirect_product.right_hom_comp_map SemidirectProduct.rightHom_comp_map

@[simp]
theorem map_inl (n : N) : map fâ‚ fâ‚‚ h (inl n) = inl (fâ‚ n) := by simp [map]
                                                                 -- ğŸ‰ no goals
#align semidirect_product.map_inl SemidirectProduct.map_inl

@[simp]
theorem map_comp_inl : (map fâ‚ fâ‚‚ h).comp inl = inl.comp fâ‚ := by ext <;> simp
                                                                  -- âŠ¢ (â†‘(MonoidHom.comp (map fâ‚ fâ‚‚ h) inl) xâœ).left = (â†‘(MonoidHom.comp inl fâ‚) xâœ â€¦
                                                                          -- ğŸ‰ no goals
                                                                          -- ğŸ‰ no goals
#align semidirect_product.map_comp_inl SemidirectProduct.map_comp_inl

@[simp]
theorem map_inr (g : G) : map fâ‚ fâ‚‚ h (inr g) = inr (fâ‚‚ g) := by simp [map]
                                                                 -- ğŸ‰ no goals
#align semidirect_product.map_inr SemidirectProduct.map_inr

@[simp]
theorem map_comp_inr : (map fâ‚ fâ‚‚ h).comp inr = inr.comp fâ‚‚ := by ext <;> simp [map]
                                                                  -- âŠ¢ (â†‘(MonoidHom.comp (map fâ‚ fâ‚‚ h) inr) xâœ).left = (â†‘(MonoidHom.comp inr fâ‚‚) xâœ â€¦
                                                                          -- ğŸ‰ no goals
                                                                          -- ğŸ‰ no goals
#align semidirect_product.map_comp_inr SemidirectProduct.map_comp_inr

end Map

end SemidirectProduct
