/-
Copyright (c) 2025 Hang Lu Su. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Riccardo Brasca, Fabrizio Barroero, Stefano Francaviglia,
  Francesco Milizia, Valerio Proietti, Hang Lu Su, Lawrence Wu
-/
module

public import Mathlib.Algebra.Group.PUnit
public import Mathlib.Data.Finite.Card
public import Mathlib.GroupTheory.Finiteness
public import Mathlib.GroupTheory.PresentedGroup
public import Mathlib.GroupTheory.QuotientGroup.Basic

/-!
# Finitely Presented Groups

This file defines finitely-presented groups.

A group is finitely presented when it is isomorphic to the quotient of a free group
on finitely many generators, by a normal subgroup generated by finitely many relations.

## Main definitions
* `IsPresented`: defines when a group has an isomorphism to a presented group.
* `IsNormalClosureFG`: defines when a subgroup is finitely generated in the normal closure.
* `IsFinitelyPresented`: defines when a group has an isomorphism to a finitely presented group.
* `IsOneRelator`: defines when a group is isomorphic to a one-relator group.

## Main results
* `IsNormalClosureFG.invariant_surj_hom`: being finitely generated in the normal closure is closed
  under surjective homomorphism.
* `isFP_isFG`: a finitely presented group is finitely generated.
* `isFP_isPresented`: a finitely presented group is a presented group.
* `IsFinitelyPresented.iff_hom_surj_finite`: a finitely presented group is finitely presented if
  and only if it admits a surjective homomorphism from `FreeGroup α` where `α: Type` and
  `(_: Finite α)` such that the kernel is finitely generated in the normal closure.
* `IsFinitelyPresented.iff_hom_surj_fintype` same as above but for `Fintype α`.
* `IsFinitelyPresented.iff_hom_surj_fin_n` same as above but for `Fin n`.
* `IsFinitelyPresented.if_hom_surj_finite` same as above but for if direction with `α: Type*`.
* `IsFinitelyPresented.iff_hom_surj_set_G` same as above but for `S: Set G` and the surjection being
  the canonical inclusion map.
* `IsFinitelyPresented.iff_hom_surj_finset_G` same as above but for `S: Finset G` and the surjection
  being the canonical inclusion map.
* `IsFinitelyPresented.of_mulEquiv`: being finitely presented is invariant under isomorphism.
* The trivial group and ℤ are instances of finitely presented groups.

## Tags
finitely presented group, finitely generated normal closure
-/

@[expose] public section

-- Start of suggested additions to #Monoid.ker
-- TODO not sure if this is the right abstraction / right namespace for this.
/-- The kernel of a homomorphism composed with an isomorphism is equal to the kernel of
the homomorphism mapped by the inverse isomorphism. -/
@[simp]
lemma MonoidHom.ker_comp_mulEquiv {G H K : Type*} [Group G] [Group H] [Group K]
  (f : H →* K) (iso : G ≃* H) : (f.comp iso).ker = (Subgroup.map (iso.symm.toMonoidHom) f.ker) := by
  rw [← MonoidHom.comap_ker, Subgroup.comap_equiv_eq_map_symm]
  rfl
-- End of suggested additions to #Monoid.ker

-- Start of suggested additions to #FreeGroup

/-- We define that the free group on no generators as isomorphic to the trivial group. -/
def FreeGroup.freeGroupEmptyMulEquivUnit : FreeGroup Empty ≃* Unit :=
{ toEquiv := FreeGroup.freeGroupEmptyEquivUnit
  map_mul' _ _ := rfl }

/-- We define that the free group on one element as isomorphic to ℤ. -/
def FreeGroup.freeGroupUnitMulEquivInt :
    FreeGroup Unit ≃* Multiplicative ℤ where
    toFun := fun x ↦ Multiplicative.ofAdd (FreeGroup.freeGroupUnitEquivInt x)
    invFun := fun z ↦ FreeGroup.freeGroupUnitEquivInt.symm z.toAdd
    left_inv _ := by simp
    right_inv _ := by simp
    map_mul' _ _  := by
      ext
      simp [FreeGroup.freeGroupUnitEquivInt]

/-- If `α` and `β` are arbitrary types and there is a surjection between them, then the induced
FreeGroup.map is also surjective. -/
theorem FreeGroup.map_surjective {α β : Type*} (f : α → β) (hf : Function.Surjective f) :
  Function.Surjective (FreeGroup.map f) := by
  intro x
  induction x using FreeGroup.induction_on with
  | C1 =>
      use 1
      rfl
  | of b =>
      rcases hf b with ⟨a, ha⟩
      refine ⟨FreeGroup.of a, ?_⟩
      simp [ha]
  | inv_of b hb =>
      rcases hb with ⟨a, ha⟩
      refine ⟨a⁻¹, ?_⟩
      simp [ha]
  | mul b c hb hc =>
      rcases hb with ⟨a, ha⟩
      rcases hc with ⟨d, hd⟩
      refine ⟨a * d, ?_⟩
      simp [ha, hd]
-- end of addition to #FreeGroup

-- Start of suggested additions to #Subgroup

/-- The normal closure of an empty set is the trivial subgroup. -/
lemma normalClosure_empty {G : Type*} [Group G] :
    Subgroup.normalClosure (∅ : Set G) = (⊥ : Subgroup G) := by
  apply le_antisymm
  · exact Subgroup.normalClosure_le_normal (N := (⊥ : Subgroup G)) (by simp)
  · exact bot_le
-- end of suggested additions to #Subgroup

-- Start of suggested additions to #Group.FG

/-- A group if finitely generated if and only if there exists a surjective homomorphism from a
free group on a finite type to the group. -/
theorem Group.fg_iff_exists_freeGroup_hom_surjective_finite {G : Type*} [Group G] :
    Group.FG G ↔ ∃ (α : Type) (_ : Finite α) (φ : FreeGroup α →* G), Function.Surjective φ := by
    constructor
    · rw [Group.fg_iff_exists_freeGroup_hom_surjective]
      intro ⟨S, hS, φ⟩
      let n := hS.toFinset.card
      let α := Fin n
      use α, inferInstance
      haveI := hS.fintype
      have hn : Fintype.card S = n := by
        simp [n]
      let e : S ≃ α := Fintype.equivFinOfCardEq hn
      rcases φ with ⟨φ, hφ⟩
      refine ⟨φ.comp (FreeGroup.map e.symm), ?_⟩
      exact hφ.comp (FreeGroup.map_surjective _ e.symm.surjective)
    · intro ⟨α, _, φ, hφ⟩
      haveI := Fintype.ofFinite α
      let S : Set G := Set.image (fun a : α ↦ φ (FreeGroup.of a)) (Set.univ : Set α)
      have hS : S.Finite := by
        simpa [S] using (Set.Finite.image (s := (Set.univ : Set α))
          (f := fun a : α ↦ φ (FreeGroup.of a)) (Set.finite_univ))
      -- This is copied from Group.FG.
      have hS' : S = φ '' Set.range (FreeGroup.of : α → FreeGroup α) := by
        ext g; constructor
        · rintro ⟨a, -, rfl⟩
          exact ⟨FreeGroup.of a, ⟨a, rfl⟩, rfl⟩
        · rintro ⟨x, ⟨a, rfl⟩, rfl⟩
          exact ⟨a, by simp, rfl⟩
      have hSgen : Subgroup.closure S = ⊤ := by
        simpa [hS'] using
          (by
            simp [← MonoidHom.map_closure, hφ, FreeGroup.closure_range_of,
              ← MonoidHom.range_eq_map] :
            Subgroup.closure (φ '' Set.range (FreeGroup.of : α → FreeGroup α)) = ⊤)
      -- end of copy.
      refine (Group.fg_iff).2 ?_
      use S
-- end of suggested additions to #Group.FG

-- Start of suggestion additions to #PresentedGroup

/-- A group is presented if it admits an isomorphism to a presented group. -/
class IsPresented (G : Type*) [Group G] : Prop where
 out: ∃ (α : Type*) (rels : Set (FreeGroup α)), Nonempty (G ≃* PresentedGroup rels)

-- End of suggested additions to #PresentedGroup

-- Start of NormalClosureFG statements
open Subgroup

/-- Definition of subgroup that is given by the normal closure of finitely many elements. -/
def IsNormalClosureFG {G : Type*} [Group G] (H : Subgroup G) : Prop :=
  ∃ S : Set G, S.Finite ∧ Subgroup.normalClosure S = H

/-- `IsNormalClosureFG` is invariant under surjective homomorphism. -/
theorem IsNormalClosureFG.invariant_surj_hom {G H : Type*} [Group G] [Group H]
  (f : G →* H) (hf : Function.Surjective f) (K : Subgroup G) (hK : IsNormalClosureFG K)
  : IsNormalClosureFG (K.map f) := by
  obtain ⟨ S, hSfinite, hSclosure ⟩ := hK
  use f '' S
  constructor
  · exact hSfinite.image _
  · rw [ ← hSclosure, Subgroup.map_normalClosure _ _ hf]
-- End of NormalClosureFG statements

/-- A group is finitely presented if it admits an isomorphism to a finitely presented group. -/
class IsFinitelyPresented (G : Type*) [Group G] : Prop where
  out: ∃ (α : Type) (_: Finite α) (rels : Set (FreeGroup α)) (_ : rels.Finite),
  Nonempty (G ≃* (PresentedGroup rels))

/-- A group is one relator if it admits an isomorphism to a presented group such that the number
of relations is one. -/
class IsOneRelator (G : Type*) [Group G] : Prop where
  out : ∃ (α : Type*) (rels : Set (FreeGroup α)) (hrels : rels.Finite),
      Nonempty (G ≃* PresentedGroup rels) ∧
      hrels.toFinset.card = 1

-- TODO calls to IsNormalClosureFG.map could be simplified? Like maybe using the iso functions.
  -- seems like we apply a lot of `MonoidHom.ker_comp_mulEquiv + IsNormalClosureFG.map`.

/-- Every finitely presented group is finitely generated. -/
instance isFP_isFG {G : Type*} [Group G] [h : IsFinitelyPresented G] : Group.FG G := by
  rw [Group.fg_iff_exists_freeGroup_hom_surjective_finite]
  obtain ⟨α, hα, rels, hrels, ⟨iso⟩⟩ := h
  unfold PresentedGroup at iso
  use α, hα
  -- TODO probably a nicer way to do this.
  let iso' := iso.symm.toMonoidHom.comp (QuotientGroup.mk' (Subgroup.normalClosure rels))
  use iso'
  simpa [iso'] using
    (Function.Surjective.comp
    iso.symm.surjective (QuotientGroup.mk'_surjective (Subgroup.normalClosure rels)))

/-- Every finitely presented group is a presented group. -/
instance isFP_isPresented {G : Type*} [Group G] [h : IsFinitelyPresented G] : IsPresented G := by
  obtain ⟨α, hα, rels, hrels, ⟨iso⟩⟩ := h
  use ULift α, Set.image (FreeGroup.map ULift.up) rels
  let e : ULift α ≃ α := Equiv.ulift
  refine ⟨iso.trans (PresentedGroup.equivPresentedGroup rels e.symm)⟩

-- TODO? every group is isomorphic to a `PresentedGroup`

namespace IsFinitelyPresented

/-- A group is finitely presented if and only if there exists a surjective homomorphism from
a free group on a `Finite` type such that the kernel is finitely generated as a normal subgroup. -/
theorem iff_hom_surj_finite {G : Type*} [Group G] :
IsFinitelyPresented G ↔ ∃ (α : Type) (_ : Finite α) (f : (FreeGroup α) →* G),
  Function.Surjective f ∧ IsNormalClosureFG (MonoidHom.ker f)  := by
  constructor
  · intro ⟨α, hα, rels, hrels, ⟨iso⟩⟩
    unfold PresentedGroup at iso
    let f : FreeGroup α →* G :=
      iso.symm.toMonoidHom.comp (QuotientGroup.mk' (Subgroup.normalClosure rels))
    have hfsurj : Function.Surjective f := by
      simpa [f] using
      (iso.symm.surjective.comp (QuotientGroup.mk'_surjective (Subgroup.normalClosure rels)))
    have hfker : IsNormalClosureFG f.ker := by
      use rels, hrels
      ext x
      simp [f]
    exact ⟨α, hα, f, hfsurj, hfker⟩
  · intro ⟨α, hα, f, hfsurj, hfker⟩
    obtain ⟨S, hSfinite, hSnormalClosure⟩ := hfker
    use α, hα, S, hSfinite
    refine ⟨?_⟩
    unfold PresentedGroup
    let iso1 : FreeGroup α ⧸ f.ker ≃* G :=
      QuotientGroup.quotientKerEquivOfSurjective (φ := f) hfsurj
    have iso2 : FreeGroup α ⧸ normalClosure S ≃* FreeGroup α ⧸ f.ker :=
      QuotientGroup.quotientMulEquivOfEq hSnormalClosure
    exact iso1.symm.trans iso2.symm

/-- A group is finitely presented if and only if there exists a surjective homomorphism from
a free group on a `Fintype` type such that the kernel is finitely generated as a normal subgroup. -/
theorem iff_hom_surj_fintype {G : Type*} [Group G] :
IsFinitelyPresented G ↔ ∃ (α : Type) (_ : Fintype α) (f : (FreeGroup α) →* G),
  Function.Surjective f ∧ IsNormalClosureFG (MonoidHom.ker f)  := by
  rw [iff_hom_surj_finite]
  constructor
  · intro ⟨α, _, f, hfsurj, hfker⟩
    let x : Fintype α := Fintype.ofFinite α
    use α, x, f
  · intro ⟨α, _, f, hfsurj, hfker⟩
    use α, inferInstance, f

/-- A group is finitely presented if and only if there exists a surjective homomorphism from
a free group on `Fin n` such that the kernel is finitely generated as a normal subgroup. -/
theorem iff_hom_surj_fin_n {G : Type*} [Group G] :
IsFinitelyPresented G ↔ ∃ (n : ℕ) (f : (FreeGroup (Fin n)) →* G),
  Function.Surjective f ∧ IsNormalClosureFG f.ker  := by
  rw [iff_hom_surj_finite]
  constructor
  · intro ⟨α, hα, f, hfsurj, hfker⟩
    let n := Nat.card α
    let iso : FreeGroup (Fin n) ≃* FreeGroup α :=
    FreeGroup.freeGroupCongr (Finite.equivFin α).symm
    let f' : FreeGroup (Fin n) →* G := f.comp iso
    let hf'surj := hfsurj.comp iso.surjective
    have hf'ker : IsNormalClosureFG f'.ker := by
      unfold f'
      simp only [MonoidHom.ker_comp_mulEquiv]
      exact
      IsNormalClosureFG.invariant_surj_hom iso.symm.toMonoidHom iso.symm.surjective f.ker hfker
    exact ⟨n, f', hf'surj, hf'ker⟩
  · intro ⟨n, f, hfsurj, hfker⟩
    let α := Fin n
    use α, inferInstance, f

-- TODO this statement can actually be upgraded to an if and only if but it makes usage difficult
-- due to universe inference.

/-- A group is finitely presented if there exists a surjective homomorphism from
a free group on an arbitrary `Finite type` such that the kernel is finitely generated as
a normal subgroup. -/
theorem if_hom_surj_finite {G : Type*} [Group G] :
(∃ (α : Type*) (_ : Finite α) (f : (FreeGroup α) →* G),
  Function.Surjective f ∧ IsNormalClosureFG (MonoidHom.ker f)) → IsFinitelyPresented G := by
  rintro ⟨α, hα, f, hfsurj, hfker⟩
  rw [iff_hom_surj_fin_n]
  -- TODO considering refactoring this since it seems used for the second time.
  let n := Nat.card α
  let iso : FreeGroup (Fin n) ≃* FreeGroup α :=
    FreeGroup.freeGroupCongr (Finite.equivFin α).symm
  let f' : FreeGroup (Fin n) →* G := f.comp iso
  let hf'surj := hfsurj.comp iso.surjective
  have hf'ker : IsNormalClosureFG f'.ker := by
    unfold f'
    simp only [MonoidHom.ker_comp_mulEquiv]
    exact
    IsNormalClosureFG.invariant_surj_hom iso.symm.toMonoidHom iso.symm.surjective f.ker hfker
  exact ⟨n, f', hf'surj, hf'ker⟩

/-- A group is finitely presented if there exists a `Set G` such that the canonical inclusion map
is surjective and the kernel is finitely generated as a normal subgroup. -/
theorem iff_hom_surj_set_G {G : Type*} [Group G] :
  IsFinitelyPresented G ↔
    ∃ (S : Set G) (_ : S.Finite),
      Function.Surjective (FreeGroup.lift (fun s : S ↦ (s : G))) ∧
      IsNormalClosureFG (FreeGroup.lift (fun s : S ↦ (s : G))).ker := by
  constructor
  · intro ⟨α, hα, rels, hrels, ⟨iso⟩⟩
    simp [PresentedGroup] at iso
    let _ : Fintype α := Fintype.ofFinite α
    let h : FreeGroup α →* G :=
      iso.symm.toMonoidHom.comp (QuotientGroup.mk' (Subgroup.normalClosure rels))
    have hhsurj : Function.Surjective h := by
      simpa [h] using
      (Function.Surjective.comp iso.symm.surjective
      (QuotientGroup.mk'_surjective (Subgroup.normalClosure rels)))
    let S : Set G := Set.range (fun a : α ↦ h (FreeGroup.of a))
    have hS : S.Finite := by
      simpa [S] using (Set.finite_range (fun a : α ↦ h (FreeGroup.of a)))
    use S, hS
    set f : FreeGroup S →* G := FreeGroup.lift (fun s ↦ (s : G))
    let g : α → S := fun a ↦ ⟨h (FreeGroup.of a), ⟨a, rfl⟩⟩
    have hgsurj : Function.Surjective g := by
      intro s
      rcases s with ⟨y, ⟨a, rfl⟩⟩
      exact ⟨a, rfl⟩
    have hh_fcompg : f.comp (FreeGroup.map g) = h := by
      ext a
      simp [f, h, g]
    have hfsurj : Function.Surjective f := by
      intro y
      obtain ⟨x, rfl⟩ := hhsurj y
      refine ⟨FreeGroup.map g x, ?_⟩
      simpa [MonoidHom.comp_apply] using congrArg (fun m ↦ m x) hh_fcompg
    use hfsurj
    let g' : FreeGroup α →* FreeGroup S := FreeGroup.map g
    have hg'_surj : Function.Surjective g' := FreeGroup.map_surjective g hgsurj
    have hhker : h.ker = Subgroup.normalClosure rels := by
      ext x
      simp [h]
    have hhker' : IsNormalClosureFG h.ker := by
      rw [hhker]
      use rels
    have hfker : f.ker = Subgroup.map g' (Subgroup.normalClosure rels) := by
      have hhker'' : h.ker = (f.ker).comap g' := by
        simpa [g'] using congrArg MonoidHom.ker hh_fcompg.symm
      have hmap : Subgroup.map g' (h.ker) = f.ker := by
        simpa [hhker''] using
          (Subgroup.map_comap_eq_self_of_surjective (f := g') (H := f.ker) hg'_surj)
      simpa [hhker] using hmap.symm
    convert IsNormalClosureFG.invariant_surj_hom g' hg'_surj h.ker hhker'
    rw [hhker]
    exact hfker
  · intro ⟨S, hS, hfsurj, hfker⟩
    set f : FreeGroup S →* G := FreeGroup.lift (fun s ↦ (s : G))
    let α := S
    let _ : Finite α := hS
    apply if_hom_surj_finite -- this is a good justification for using Type* in general.
    use α, inferInstance, f

/-- A group is finitely presented if there exists a `Finset G` such that the canonical inclusion map
is surjective and the kernel is finitely generated as a normal subgroup. -/
theorem iff_hom_surj_finset_G {G : Type*} [Group G] :
  IsFinitelyPresented G ↔
      ∃ (S : Finset G),
      Function.Surjective (FreeGroup.lift (fun s : S ↦ (s : G))) ∧
      IsNormalClosureFG (FreeGroup.lift (fun s : S ↦ (s : G))).ker := by
    rw [iff_hom_surj_set_G]
    constructor
    · intro ⟨S, hS, hfsurj, hfker⟩
      set f : FreeGroup S →* G := FreeGroup.lift (fun s ↦ (s : G))
      let S' : Finset G := hS.toFinset
      let e : S ≃ S'
        := hS.subtypeEquivToFinset
      let iso : FreeGroup S' ≃* FreeGroup S
        := FreeGroup.freeGroupCongr e.symm
      let f' : FreeGroup S' →* G := f.comp iso
      let hf'surj := hfsurj.comp iso.surjective
      have hf'ker : IsNormalClosureFG f'.ker := by
        unfold f'
        simp only [MonoidHom.ker_comp_mulEquiv]
        exact
          IsNormalClosureFG.invariant_surj_hom iso.symm.toMonoidHom iso.symm.surjective f.ker hfker
      use S'
      have hf'canon : f' = FreeGroup.lift (fun s' : S' ↦ (s' : G)) := by
        -- TODO prettify this.
        simp_all only [MonoidHom.ker_comp_mulEquiv, FreeGroup.freeGroupCongr_symm, Equiv.symm_symm,
          MulEquiv.toMonoidHom_eq_coe, f, S', f', iso, e]
        ext a : 1
        simp_all only
        [MonoidHom.coe_comp, MonoidHom.coe_coe, Function.comp_apply, FreeGroup.freeGroupCongr_apply,
          FreeGroup.map.of, FreeGroup.lift_apply_of, Set.Finite.subtypeEquivToFinset_symm_apply_coe]
      rw [← hf'canon]
      use hf'surj
    · intro ⟨S, hfsurj, hfker⟩
      refine ⟨(S : Set G), S.finite_toSet, ?_, ?_⟩
      · simpa using hfsurj
      · simpa using hfker

/-- FP groups are closed under isomorphism -/
theorem of_mulEquiv {G H : Type*} [Group G] [Group H]
(iso : G ≃* H) (h : IsFinitelyPresented G) :
    IsFinitelyPresented H := by
    obtain ⟨α, hα, rels, hrels, ⟨iso'⟩⟩ := h
    exact ⟨α, hα, rels, hrels, ⟨ iso.symm.trans iso' ⟩⟩

/-- If you FreeGroup α by an empty set, you get the original group. -/
def quotient_normalClosure_empty_mulEquiv (α : Type*) :
    FreeGroup α ⧸ Subgroup.normalClosure (∅ : Set (FreeGroup α)) ≃* FreeGroup α := by
  have hbot :
      Subgroup.normalClosure (∅ : Set (FreeGroup α)) = (⊥ : Subgroup (FreeGroup α)) := by
    simpa using (normalClosure_empty (G := FreeGroup α))
  exact (QuotientGroup.quotientMulEquivOfEq hbot).trans
    (QuotientGroup.quotientBot (G := FreeGroup α))
-- TODO I think this needs to work for any presented group.

/-- Trivial group is finitely presented -/
instance : IsFinitelyPresented (Unit) := by
  let α := Empty
  let rels := (∅ : Set (FreeGroup Empty))
  have hrels : rels.Finite := by
    simp [rels]
  use α, inferInstance, rels, hrels
  let iso := FreeGroup.freeGroupEmptyMulEquivUnit
  unfold PresentedGroup
  refine ⟨?_⟩
  have qiso : FreeGroup α ⧸ Subgroup.normalClosure rels ≃* FreeGroup α := by
    simpa [rels] using quotient_normalClosure_empty_mulEquiv (α := α)
  unfold α at qiso
  exact iso.symm.trans qiso.symm

/-- ℤ is finitely presented -/
instance : IsFinitelyPresented (Multiplicative ℤ) := by
  let α := Unit
  let rels := (∅ : Set (FreeGroup α))
  have hrels : rels.Finite := by
    simp [rels]
  use α, inferInstance, rels, hrels
  unfold PresentedGroup
  refine ⟨?_⟩
  have qiso : FreeGroup α ⧸ Subgroup.normalClosure rels ≃* FreeGroup α := by
    simpa [rels] using quotient_normalClosure_empty_mulEquiv (α := α)
  let iso := FreeGroup.freeGroupUnitMulEquivInt
  unfold α at qiso
  exact iso.symm.trans qiso.symm

variable {G H : Type*} [Group G] [Group H]

end IsFinitelyPresented

-- #min_imports
