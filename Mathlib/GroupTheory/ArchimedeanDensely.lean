/-
Copyright (c) 2024 Yakov Pechersky. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yakov Pechersky
-/
import Mathlib.GroupTheory.Archimedean
import Mathlib.Algebra.Group.Subgroup.Pointwise
import Mathlib.Algebra.Order.Hom.Monoid

/-!
# Archimedean groups are either discrete or densely ordere

This file proves a few additional facts about linearly ordered additive groups which satisfy the
  `Archimedean` property --
  they are either order-isomorphic and additvely isomorphic to the integers,
  or they are densely ordered.

They are placed here in a separate file (rather than incorporated as a continuation of
`GroupTheory.Archimedean`) because they rely on some imports from pointwise lemmas.
-/

open Set

-- no earlier file imports the necessary requirements for the next two

/-- The subgroup generated by an element of a group equals the set of
integer powers of the element, such that each power is a unique element.
This is the stronger version of `Subgroup.mem_closure_singleton`. -/
@[to_additive "The additive subgroup generated by an element of an additive group equals the set of
integer multiples of the element, such that each multiple is a unique element.
This is the stronger version of `AddSubgroup.mem_closure_singleton`."]
lemma Subgroup.mem_closure_singleton_iff_existsUnique_zpow {G : Type*}
    [LinearOrderedCommGroup G] {a b : G} (ha : a ≠ 1) :
    b ∈ closure {a} ↔ ∃! k : ℤ, a ^ k = b := by
  constructor <;> intro h
  · wlog ha : 1 < a generalizing a b
    · simp only [not_lt] at ha
      rcases ha.eq_or_lt with rfl|ha
      · contradiction
      specialize @this a⁻¹ b (by simpa) (by simpa) (by simpa)
      simp only [inv_zpow'] at this
      obtain ⟨k, rfl, hk'⟩ := this
      refine ⟨-k, rfl, ?_⟩
      intro y hy
      rw [← neg_eq_iff_eq_neg]
      exact hk' _ (by simpa using hy)
    · rw [mem_closure_singleton] at h
      obtain ⟨k, hk⟩ := h
      refine ⟨k, hk, ?_⟩
      rintro l rfl
      rwa [← zpow_right_inj ha, eq_comm]
  · rw [mem_closure_singleton]
    exact h.exists

open Subgroup in
/-- In two linearly ordered groups, the closure of an element of one group
is isomorphic (and order-isomorphic) to the closure of an element in the other group. -/
@[to_additive "In two linearly ordered additive groups, the closure of an element of one group
is isomorphic (and order-isomorphic) to the closure of an element in the other group."]
noncomputable def LinearOrderedCommGroup.closure_equiv_closure {G G' : Type*}
    [LinearOrderedCommGroup G] [LinearOrderedCommGroup G'] (x : G) (y : G') (hxy : x = 1 ↔ y = 1) :
    closure ({x} : Set G) ≃*o closure ({y} : Set G') :=
  if hx : x = 1 then by
    refine ⟨⟨⟨fun _ ↦ ⟨1, by simp [hxy.mp hx]⟩, fun _ ↦ ⟨1, by simp [hx]⟩, ?_, ?_⟩, ?_⟩, ?_⟩
    · intro ⟨a, ha⟩
      simpa [hx, closure_singleton_one, eq_comm] using ha
    · intro ⟨a, ha⟩
      simpa [hxy.mp hx, closure_singleton_one, eq_comm] using ha
    · intros
      simp
    · intro ⟨a, ha⟩ ⟨b, hb⟩
      simp only [hx, closure_singleton_one, mem_bot] at ha hb
      simp [ha, hb]
  else by
    set x' := max x x⁻¹ with hx'
    have xpos : 1 < x' := by
      simp [hx', eq_comm, hx]
    set y' := max y y⁻¹ with hy'
    have ypos : 1 < y' := by
      simp [hy', eq_comm, ← hxy, hx]
    have hxc : closure {x} = closure {x'} := by
      rcases max_cases x x⁻¹ with H|H <;>
      simp [hx', H.left]
    have hyc : closure {y} = closure {y'} := by
      rcases max_cases y y⁻¹ with H|H <;>
      simp [hy', H.left]
    refine ⟨⟨⟨
      fun a ↦ ⟨y' ^ ((mem_closure_singleton).mp
        (by simpa [hxc] using a.prop)).choose, ?_⟩,
      fun a ↦ ⟨x' ^ ((mem_closure_singleton).mp
        (by simpa [hyc] using a.prop)).choose, ?_⟩,
        ?_, ?_⟩, ?_⟩, ?_⟩
    · rw [hyc, mem_closure_singleton]
      exact ⟨_, rfl⟩
    · rw [hxc, mem_closure_singleton]
      exact ⟨_, rfl⟩
    · intro a
      generalize_proofs A B C D
      rw [Subtype.ext_iff, ← (C a).choose_spec, zpow_right_inj xpos,
          ← zpow_right_inj ypos, (A ⟨_, D a⟩).choose_spec]
    · intro a
      generalize_proofs A B C D
      rw [Subtype.ext_iff, ← (C a).choose_spec, zpow_right_inj ypos,
          ← zpow_right_inj xpos, (A ⟨_, D a⟩).choose_spec]
    · intro a b
      generalize_proofs A B C D E F
      simp only [Submonoid.coe_mul, coe_toSubmonoid, Submonoid.mk_mul_mk, Subtype.mk.injEq,
                 coe_mul, MulMemClass.mk_mul_mk, Subtype.ext_iff]
      rw [← zpow_add, zpow_right_inj ypos, ← zpow_right_inj xpos, zpow_add,
          (A a).choose_spec, (A b).choose_spec, (A (a * b)).choose_spec]
      simp
    · intro a b
      simp only [MulEquiv.coe_mk, Equiv.coe_fn_mk, Subtype.mk_le_mk]
      generalize_proofs A B C D
      simp [zpow_le_zpow_iff ypos, ← zpow_le_zpow_iff xpos, A.choose_spec, B.choose_spec]

variable {G : Type*} [LinearOrderedAddCommGroup G] [Archimedean G]

lemma AddSubgroup.isLeast_closure_iff_eq_abs {a b : G} :
    IsLeast {y : G | y ∈ closure ({a} : Set G) ∧ 0 < y} b ↔ b = |a| ∧ 0 < b := by
  constructor <;> intro h
  · have := cyclic_of_min h
    have ha : a ∈ closure ({b} : Set G) := by
      simp [← this]
    rw [mem_closure_singleton] at ha
    obtain ⟨n, rfl⟩ := ha
    have := h.left
    simp only [mem_closure_singleton, mem_setOf_eq, ← mul_zsmul] at this
    obtain ⟨m, hm⟩ := this.left
    have key : m * n = 1 := by
      rw [← zsmul_left_inj this.right, hm, one_zsmul]
    rw [Int.mul_eq_one_iff_eq_one_or_neg_one] at key
    rw [eq_comm]
    rcases key with ⟨rfl, rfl⟩|⟨rfl, rfl⟩ <;>
    simp [this.right.le, this.right]
  · wlog ha : 0 ≤ a generalizing a
    · convert @this (-a) ?_ (by simpa using le_of_not_le ha) using 4
      · simp
      · simpa using h
    rw [abs_eq_self.mpr ha] at h
    rcases h with ⟨rfl, h⟩
    refine ⟨?_, ?_⟩
    · simp [h]
    · intro x
      simp only [mem_closure_singleton, mem_setOf_eq, and_imp, forall_exists_index]
      rintro k rfl hk
      rw [← one_zsmul b, ← mul_zsmul, mul_one, zsmul_le_zsmul_iff h, ← zero_add 1,
          ← Int.lt_iff_add_one_le]
      contrapose! hk
      rw [← Left.nonneg_neg_iff, ← neg_zsmul]
      exact zsmul_nonneg ha (by simp [hk])

/-- If an element of a linearly ordered archimedean additive group is the least positive element,
then the whole group is isomorphic (and order-isomorphic) to the integers. -/
noncomputable def LinearOrderedAddCommGroup.int_orderAddMonoidIso_of_isLeast_pos {x : G}
    (h : IsLeast {y : G | 0 < y} x) : G ≃+o ℤ := by
  have : IsLeast {y : G | y ∈ (⊤ : AddSubgroup G) ∧ 0 < y} x := by simpa using h
  replace this := AddSubgroup.cyclic_of_min this
  let e : G ≃+o (⊤ : AddSubgroup G) := ⟨AddSubsemigroup.topEquiv.symm,
    (AddEquiv.strictMono_symm AddSubsemigroup.strictMono_topEquiv).le_iff_le⟩
  let e' : (⊤ : AddSubgroup G) ≃+o AddSubgroup.closure {x} :=
    ⟨AddEquiv.subsemigroupCongr (by simp [this]),
     (AddEquiv.strictMono_subsemigroupCongr _).le_iff_le⟩
  let g : (⊤ : AddSubgroup ℤ) ≃+o ℤ := ⟨AddSubsemigroup.topEquiv,
    (AddSubsemigroup.strictMono_topEquiv).le_iff_le⟩
  let g' : AddSubgroup.closure ({1} : Set ℤ) ≃+o (⊤ : AddSubgroup ℤ) :=
    ⟨(.subsemigroupCongr (by simp [AddSubgroup.closure_singleton_int_one_eq_top])),
     (AddEquiv.strictMono_subsemigroupCongr _).le_iff_le⟩
  let f := closure_equiv_closure x (1 : ℤ) (by simp [h.left.ne'])
  exact ((((e.trans e').trans f).trans g').trans g : G ≃+o ℤ)

variable (G) in
/-- Any linearly ordered archimedean additive group is either isomorphic (and order-isomorphic)
to the integers, or is densely ordered. -/
lemma LinearOrderedAddCommGroup.discrete_or_denselyOrdered :
    Nonempty (G ≃+o ℤ) ∨ DenselyOrdered G := by
  by_cases H : ∃ x, IsLeast {y : G | 0 < y} x
  · obtain ⟨x, hx⟩ := H
    exact Or.inl ⟨(int_orderAddMonoidIso_of_isLeast_pos hx)⟩
  · push_neg at H
    refine Or.inr ⟨?_⟩
    intro x y hxy
    specialize H (y - x)
    obtain ⟨z, hz⟩ : ∃ z : G, 0 < z ∧ z < y - x := by
      contrapose! H
      refine ⟨by simp [hxy], fun _ ↦ H _⟩
    refine ⟨x + z, ?_, ?_⟩
    · simp [hz.left]
    · simpa [lt_sub_iff_add_lt'] using hz.right
