/-
Copyright (c) 2020 Heather Macbeth, Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Heather Macbeth, Patrick Massot
-/
import Mathlib.Algebra.Order.Archimedean
import Mathlib.GroupTheory.Subgroup.Basic

#align_import group_theory.archimedean from "leanprover-community/mathlib"@"f93c11933efbc3c2f0299e47b8ff83e9b539cbf6"

/-!
# Archimedean groups

This file proves a few facts about ordered groups which satisfy the `Archimedean` property, that is:
`class Archimedean (Œ±) [OrderedAddCommMonoid Œ±] : Prop :=`
`(arch : ‚àÄ (x : Œ±) {y}, 0 < y ‚Üí ‚àÉ n : ‚Ñï, x ‚â§ n ‚Ä¢ y)`

They are placed here in a separate file (rather than incorporated as a continuation of
`Algebra.Order.Archimedean`) because they rely on some imports from `GroupTheory` -- bundled
subgroups in particular.

The main result is `AddSubgroup.cyclic_of_min`:  a subgroup of a decidable archimedean abelian
group is cyclic, if its set of positive elements has a minimal element.

This result is used in this file to deduce `Int.subgroup_cyclic`, proving that every subgroup of `‚Ñ§`
is cyclic.  (There are several other methods one could use to prove this fact, including more purely
algebraic methods, but none seem to exist in mathlib as of writing.  The closest is
`Subgroup.is_cyclic`, but that has not been transferred to `AddSubgroup`.)

The result is also used in `Topology.Instances.Real` as an ingredient in the classification of
subgroups of `‚Ñù`.
-/

open Set
variable {G : Type*} [LinearOrderedAddCommGroup G] [Archimedean G]

/-- Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there
exists a minimal element `a` of `H ‚à© G_{>0}` then `H` is generated by `a`. -/
theorem AddSubgroup.cyclic_of_min {H : AddSubgroup G} {a : G}
    (ha : IsLeast { g : G | g ‚àà H ‚àß 0 < g } a) : H = AddSubgroup.closure {a} := by
  obtain ‚ü®‚ü®a_in, a_pos‚ü©, a_min‚ü© := ha
  -- ‚ä¢ H = closure {a}
  refine' le_antisymm _ (H.closure_le.mpr <| by simp [a_in])
  -- ‚ä¢ H ‚â§ closure {a}
  intro g g_in
  -- ‚ä¢ g ‚àà closure {a}
  obtain ‚ü®k, ‚ü®nonneg, lt‚ü©, _‚ü© := existsUnique_zsmul_near_of_pos' a_pos g
  -- ‚ä¢ g ‚àà closure {a}
  have h_zero : g - k ‚Ä¢ a = 0 := by
    by_contra h
    have h : a ‚â§ g - k ‚Ä¢ a := by
      refine' a_min ‚ü®_, _‚ü©
      ¬∑ exact AddSubgroup.sub_mem H g_in (AddSubgroup.zsmul_mem H a_in k)
      ¬∑ exact lt_of_le_of_ne nonneg (Ne.symm h)
    have h' : ¬¨a ‚â§ g - k ‚Ä¢ a := not_le.mpr lt
    contradiction
  simp [sub_eq_zero.mp h_zero, AddSubgroup.mem_closure_singleton]
  -- üéâ no goals
#align add_subgroup.cyclic_of_min AddSubgroup.cyclic_of_min

/-- If a nontrivial additive subgroup of a linear ordered additive commutative group is disjoint
with the interval `Set.Ioo 0 a` for some positive `a`, then the set of positive elements of this
group admits the least element. -/
theorem AddSubgroup.exists_isLeast_pos {H : AddSubgroup G} (hbot : H ‚â† ‚ä•) {a : G} (h‚ÇÄ : 0 < a)
    (hd : Disjoint (H : Set G) (Ioo 0 a)) : ‚àÉ b, IsLeast { g : G | g ‚àà H ‚àß 0 < g } b := by
  -- todo: move to a lemma?
  have hex : ‚àÄ g > 0, ‚àÉ n : ‚Ñï, g ‚àà Ioc (n ‚Ä¢ a) ((n + 1) ‚Ä¢ a) := fun g hg => by
    rcases existsUnique_add_zsmul_mem_Ico h‚ÇÄ 0 (g - a) with ‚ü®m, ‚ü®hm, hm'‚ü©, -‚ü©
    simp only [zero_add, sub_le_iff_le_add, sub_add_cancel, ‚Üê add_one_zsmul] at hm hm'
    lift m to ‚Ñï
    ¬∑ rw [‚Üê Int.lt_add_one_iff, ‚Üê zsmul_lt_zsmul_iff h‚ÇÄ, zero_zsmul]
      exact hg.trans_le hm
    ¬∑ simp only [‚Üê Nat.cast_succ, coe_nat_zsmul] at hm hm'
      exact ‚ü®m, hm', hm‚ü©
  have : ‚àÉ n : ‚Ñï, Set.Nonempty (H ‚à© Ioc (n ‚Ä¢ a) ((n + 1) ‚Ä¢ a))
  -- ‚ä¢ ‚àÉ n, Set.Nonempty (‚ÜëH ‚à© Ioc (n ‚Ä¢ a) ((n + 1) ‚Ä¢ a))
  ¬∑ rcases (bot_or_exists_ne_zero H).resolve_left hbot with ‚ü®g, hgH, hg‚ÇÄ‚ü©
    -- ‚ä¢ ‚àÉ n, Set.Nonempty (‚ÜëH ‚à© Ioc (n ‚Ä¢ a) ((n + 1) ‚Ä¢ a))
    rcases hex |g| (abs_pos.2 hg‚ÇÄ) with ‚ü®n, hn‚ü©
    -- ‚ä¢ ‚àÉ n, Set.Nonempty (‚ÜëH ‚à© Ioc (n ‚Ä¢ a) ((n + 1) ‚Ä¢ a))
    exact ‚ü®n, _, (@abs_mem_iff (AddSubgroup G) G _ _).2 hgH, hn‚ü©
    -- üéâ no goals
  classical rcases Nat.findX this with ‚ü®n, ‚ü®x, hxH, hnx, hxn‚ü©, hmin‚ü©
  -- ‚ä¢ ‚àÉ b, IsLeast {g | g ‚àà H ‚àß 0 < g} b
  by_contra hxmin
  -- ‚ä¢ False
  simp only [IsLeast, not_and, mem_setOf_eq, mem_lowerBounds, not_exists, not_forall,
    not_le] at hxmin
  rcases hxmin x ‚ü®hxH, (nsmul_nonneg h‚ÇÄ.le _).trans_lt hnx‚ü© with ‚ü®y, ‚ü®hyH, hy‚ÇÄ‚ü©, hxy‚ü©
  -- ‚ä¢ False
  rcases hex y hy‚ÇÄ with ‚ü®m, hm‚ü©
  -- ‚ä¢ False
  cases' lt_or_le m n with hmn hnm
  -- ‚ä¢ False
  ¬∑ exact hmin m hmn ‚ü®y, hyH, hm‚ü©
    -- üéâ no goals
  ¬∑ refine disjoint_left.1 hd (sub_mem hxH hyH) ‚ü®sub_pos.2 hxy, sub_lt_iff_lt_add'.2 ?_‚ü©
    -- ‚ä¢ x < y + a
    calc x ‚â§ (n + 1) ‚Ä¢ a := hxn
    _ ‚â§ (m + 1) ‚Ä¢ a := nsmul_le_nsmul h‚ÇÄ.le (add_le_add_right hnm _)
    _ = m ‚Ä¢ a + a := succ_nsmul' _ _
    _ < y + a := add_lt_add_right hm.1 _

/-- If an additive subgroup of a linear ordered additive commutative group is disjoint with the
interval `Set.Ioo 0 a` for some positive `a`, then this is a cyclic subgroup. -/
theorem AddSubgroup.cyclic_of_isolated_zero {H : AddSubgroup G} {a : G} (h‚ÇÄ : 0 < a)
    (hd : Disjoint (H : Set G) (Ioo 0 a)) : ‚àÉ b, H = closure {b} := by
  rcases eq_or_ne H ‚ä• with rfl | hbot
  -- ‚ä¢ ‚àÉ b, ‚ä• = closure {b}
  ¬∑ exact ‚ü®0, closure_singleton_zero.symm‚ü©
    -- üéâ no goals
  ¬∑ exact (exists_isLeast_pos hbot h‚ÇÄ hd).imp fun _ => cyclic_of_min
    -- üéâ no goals

/-- Every subgroup of `‚Ñ§` is cyclic. -/
theorem Int.subgroup_cyclic (H : AddSubgroup ‚Ñ§) : ‚àÉ a, H = AddSubgroup.closure {a} :=
  have : Ioo (0 : ‚Ñ§) 1 = ‚àÖ := eq_empty_of_forall_not_mem fun m hm =>
    hm.1.not_le (lt_add_one_iff.1 hm.2)
  AddSubgroup.cyclic_of_isolated_zero one_pos <| by simp [this]
                                                    -- üéâ no goals
#align int.subgroup_cyclic Int.subgroup_cyclic
