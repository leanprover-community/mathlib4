/-
Copyright (c) 2021 Aaron Anderson. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Aaron Anderson
-/
import Mathlib.Algebra.Group.ConjFinite
import Mathlib.GroupTheory.Perm.Fin
import Mathlib.GroupTheory.Subgroup.Simple
import Mathlib.Tactic.IntervalCases

#align_import group_theory.specific_groups.alternating from "leanprover-community/mathlib"@"0f6670b8af2dff699de1c0b4b49039b31bc13c46"

/-!
# Alternating Groups

The alternating group on a finite type `Œ±` is the subgroup of the permutation group `Perm Œ±`
consisting of the even permutations.

## Main definitions

* `alternatingGroup Œ±` is the alternating group on `Œ±`, defined as a `Subgroup (Perm Œ±)`.

## Main results
* `two_mul_card_alternatingGroup` shows that the alternating group is half as large as
  the permutation group it is a subgroup of.

* `closure_three_cycles_eq_alternating` shows that the alternating group is
  generated by 3-cycles.

* `alternatingGroup.isSimpleGroup_five` shows that the alternating group on `Fin 5` is simple.
  The proof shows that the normal closure of any non-identity element of this group contains a
  3-cycle.

## Tags
alternating group permutation


## TODO
* Show that `alternatingGroup Œ±` is simple if and only if `Fintype.card Œ± ‚â† 4`.

-/


open Equiv Equiv.Perm Subgroup Fintype

variable (Œ± : Type*) [Fintype Œ±] [DecidableEq Œ±]

/-- The alternating group on a finite type, realized as a subgroup of `Equiv.Perm`.
  For $A_n$, use `alternatingGroup (Fin n)`. -/
def alternatingGroup : Subgroup (Perm Œ±) :=
  sign.ker
#align alternating_group alternatingGroup

-- Porting note: manually added instance
instance fta : Fintype (alternatingGroup Œ±) :=
  @Subtype.fintype _ _ sign.decidableMemKer _

instance [Subsingleton Œ±] : Unique (alternatingGroup Œ±) :=
  ‚ü®‚ü®1‚ü©, fun ‚ü®p, _‚ü© => Subtype.eq (Subsingleton.elim p _)‚ü©

variable {Œ±}

theorem alternatingGroup_eq_sign_ker : alternatingGroup Œ± = sign.ker :=
  rfl
#align alternating_group_eq_sign_ker alternatingGroup_eq_sign_ker

namespace Equiv.Perm

@[simp]
theorem mem_alternatingGroup {f : Perm Œ±} : f ‚àà alternatingGroup Œ± ‚Üî sign f = 1 :=
  sign.mem_ker
#align equiv.perm.mem_alternating_group Equiv.Perm.mem_alternatingGroup

theorem prod_list_swap_mem_alternatingGroup_iff_even_length {l : List (Perm Œ±)}
    (hl : ‚àÄ g ‚àà l, IsSwap g) : l.prod ‚àà alternatingGroup Œ± ‚Üî Even l.length := by
  rw [mem_alternatingGroup, sign_prod_list_swap hl, ‚Üê Units.val_eq_one, Units.val_pow_eq_pow_val,
    Units.coe_neg_one, neg_one_pow_eq_one_iff_even]
  decide
  -- üéâ no goals
#align equiv.perm.prod_list_swap_mem_alternating_group_iff_even_length Equiv.Perm.prod_list_swap_mem_alternatingGroup_iff_even_length

theorem IsThreeCycle.mem_alternatingGroup {f : Perm Œ±} (h : IsThreeCycle f) :
    f ‚àà alternatingGroup Œ± :=
  mem_alternatingGroup.mpr h.sign
#align equiv.perm.is_three_cycle.mem_alternating_group Equiv.Perm.IsThreeCycle.mem_alternatingGroup

set_option linter.deprecated false in
theorem finRotate_bit1_mem_alternatingGroup {n : ‚Ñï} :
    finRotate (bit1 n) ‚àà alternatingGroup (Fin (bit1 n)) := by
  rw [mem_alternatingGroup, bit1, sign_finRotate, pow_bit0', Int.units_mul_self, one_pow]
  -- üéâ no goals
#align equiv.perm.fin_rotate_bit1_mem_alternating_group Equiv.Perm.finRotate_bit1_mem_alternatingGroup

end Equiv.Perm

theorem two_mul_card_alternatingGroup [Nontrivial Œ±] :
    2 * card (alternatingGroup Œ±) = card (Perm Œ±) := by
  let this := (QuotientGroup.quotientKerEquivOfSurjective _ (sign_surjective Œ±)).toEquiv
  -- ‚ä¢ 2 * card { x // x ‚àà alternatingGroup Œ± } = card (Perm Œ±)
  rw [‚Üê Fintype.card_units_int, ‚Üê Fintype.card_congr this]
  -- ‚ä¢ card (Perm Œ± ‚ß∏ MonoidHom.ker sign) * card { x // x ‚àà alternatingGroup Œ± } =  ‚Ä¶
  apply (Subgroup.card_eq_card_quotient_mul_card_subgroup _).symm
  -- üéâ no goals
#align two_mul_card_alternating_group two_mul_card_alternatingGroup

namespace alternatingGroup

open Equiv.Perm

instance normal : (alternatingGroup Œ±).Normal :=
  sign.normal_ker
#align alternating_group.normal alternatingGroup.normal

theorem isConj_of {œÉ œÑ : alternatingGroup Œ±} (hc : IsConj (œÉ : Perm Œ±) (œÑ : Perm Œ±))
    (hœÉ : (œÉ : Perm Œ±).support.card + 2 ‚â§ Fintype.card Œ±) : IsConj œÉ œÑ := by
  obtain ‚ü®œÉ, hœÉ‚ü© := œÉ
  -- ‚ä¢ IsConj { val := œÉ, property := hœÉ‚úù } œÑ
  obtain ‚ü®œÑ, hœÑ‚ü© := œÑ
  -- ‚ä¢ IsConj { val := œÉ, property := hœÉ‚úù } { val := œÑ, property := hœÑ }
  obtain ‚ü®œÄ, hœÄ‚ü© := isConj_iff.1 hc
  -- ‚ä¢ IsConj { val := œÉ, property := hœÉ‚úù } { val := œÑ, property := hœÑ }
  rw [Subtype.coe_mk, Subtype.coe_mk] at hœÄ
  -- ‚ä¢ IsConj { val := œÉ, property := hœÉ‚úù } { val := œÑ, property := hœÑ }
  cases' Int.units_eq_one_or (Perm.sign œÄ) with h h
  -- ‚ä¢ IsConj { val := œÉ, property := hœÉ‚úù } { val := œÑ, property := hœÑ }
  ¬∑ rw [isConj_iff]
    -- ‚ä¢ ‚àÉ c, c * { val := œÉ, property := hœÉ‚úù } * c‚Åª¬π = { val := œÑ, property := hœÑ }
    refine' ‚ü®‚ü®œÄ, mem_alternatingGroup.mp h‚ü©, Subtype.val_injective _‚ü©
    -- ‚ä¢ ‚Üë({ val := œÄ, property := (_ : ‚Üësign œÄ = 1) } * { val := œÉ, property := hœÉ‚úù  ‚Ä¶
    simpa only [Subtype.val, Subgroup.coe_mul, coe_inv, coe_mk] using hœÄ
    -- üéâ no goals
  ¬∑ have h2 : 2 ‚â§ œÉ.support·∂ú.card := by
      rw [Finset.card_compl, le_tsub_iff_left œÉ.support.card_le_univ]
      exact hœÉ
    obtain ‚ü®a, ha, b, hb, ab‚ü© := Finset.one_lt_card.1 h2
    -- ‚ä¢ IsConj { val := œÉ, property := hœÉ‚úù } { val := œÑ, property := hœÑ }
    refine' isConj_iff.2 ‚ü®‚ü®œÄ * swap a b, _‚ü©, Subtype.val_injective _‚ü©
    -- ‚ä¢ œÄ * swap a b ‚àà alternatingGroup Œ±
    ¬∑ rw [mem_alternatingGroup, MonoidHom.map_mul, h, sign_swap ab, Int.units_mul_self]
      -- üéâ no goals
    ¬∑ simp only [‚Üê hœÄ, coe_mk, Subgroup.coe_mul, Subtype.val]
      -- ‚ä¢ œÄ * swap a b * œÉ * ‚Üë{ val := œÄ * swap a b, property := (_ : œÄ * swap a b ‚àà a ‚Ä¶
      have hd : Disjoint (swap a b) œÉ := by
        rw [disjoint_iff_disjoint_support, support_swap ab, Finset.disjoint_insert_left,
          Finset.disjoint_singleton_left]
        exact ‚ü®Finset.mem_compl.1 ha, Finset.mem_compl.1 hb‚ü©
      rw [mul_assoc œÄ _ œÉ, hd.commute.eq, coe_inv, coe_mk]
      -- ‚ä¢ œÄ * (œÉ * swap a b) * (œÄ * swap a b)‚Åª¬π = œÄ * œÉ * œÄ‚Åª¬π
      simp [mul_assoc]
      -- üéâ no goals
#align alternating_group.is_conj_of alternatingGroup.isConj_of

theorem isThreeCycle_isConj (h5 : 5 ‚â§ Fintype.card Œ±) {œÉ œÑ : alternatingGroup Œ±}
    (hœÉ : IsThreeCycle (œÉ : Perm Œ±)) (hœÑ : IsThreeCycle (œÑ : Perm Œ±)) : IsConj œÉ œÑ :=
  alternatingGroup.isConj_of (isConj_iff_cycleType_eq.2 (hœÉ.trans hœÑ.symm))
    (by rwa [hœÉ.card_support])
        -- üéâ no goals
#align alternating_group.is_three_cycle_is_conj alternatingGroup.isThreeCycle_isConj

end alternatingGroup

namespace Equiv.Perm

open alternatingGroup

@[simp]
theorem closure_three_cycles_eq_alternating :
    closure { œÉ : Perm Œ± | IsThreeCycle œÉ } = alternatingGroup Œ± :=
  closure_eq_of_le _ (fun œÉ hœÉ => mem_alternatingGroup.2 hœÉ.sign) fun œÉ hœÉ => by
    suffices hind :
      ‚àÄ (n : ‚Ñï) (l : List (Perm Œ±)) (_ : ‚àÄ g, g ‚àà l ‚Üí IsSwap g) (_ : l.length = 2 * n),
        l.prod ‚àà closure { œÉ : Perm Œ± | IsThreeCycle œÉ }
    ¬∑ obtain ‚ü®l, rfl, hl‚ü© := truncSwapFactors œÉ
      -- ‚ä¢ List.prod l ‚àà closure {œÉ | IsThreeCycle œÉ}
      obtain ‚ü®n, hn‚ü© := (prod_list_swap_mem_alternatingGroup_iff_even_length hl).1 hœÉ
      -- ‚ä¢ List.prod l ‚àà closure {œÉ | IsThreeCycle œÉ}
      rw [‚Üê two_mul] at hn
      -- ‚ä¢ List.prod l ‚àà closure {œÉ | IsThreeCycle œÉ}
      exact hind n l hl hn
      -- üéâ no goals
    intro n
    -- ‚ä¢ ‚àÄ (l : List (Perm Œ±)), (‚àÄ (g : Perm Œ±), g ‚àà l ‚Üí IsSwap g) ‚Üí List.length l =  ‚Ä¶
    induction' n with n ih <;> intro l hl hn
    -- ‚ä¢ ‚àÄ (l : List (Perm Œ±)), (‚àÄ (g : Perm Œ±), g ‚àà l ‚Üí IsSwap g) ‚Üí List.length l =  ‚Ä¶
                               -- ‚ä¢ List.prod l ‚àà closure {œÉ | IsThreeCycle œÉ}
                               -- ‚ä¢ List.prod l ‚àà closure {œÉ | IsThreeCycle œÉ}
    ¬∑ simp [List.length_eq_zero.1 hn, one_mem]
      -- üéâ no goals
    rw [Nat.mul_succ] at hn
    -- ‚ä¢ List.prod l ‚àà closure {œÉ | IsThreeCycle œÉ}
    obtain ‚ü®a, l, rfl‚ü© := l.exists_of_length_succ hn
    -- ‚ä¢ List.prod (a :: l) ‚àà closure {œÉ | IsThreeCycle œÉ}
    rw [List.length_cons, Nat.succ_inj'] at hn
    -- ‚ä¢ List.prod (a :: l) ‚àà closure {œÉ | IsThreeCycle œÉ}
    obtain ‚ü®b, l, rfl‚ü© := l.exists_of_length_succ hn
    -- ‚ä¢ List.prod (a :: b :: l) ‚àà closure {œÉ | IsThreeCycle œÉ}
    rw [List.prod_cons, List.prod_cons, ‚Üê mul_assoc]
    -- ‚ä¢ a * b * List.prod l ‚àà closure {œÉ | IsThreeCycle œÉ}
    rw [List.length_cons, Nat.succ_inj'] at hn
    -- ‚ä¢ a * b * List.prod l ‚àà closure {œÉ | IsThreeCycle œÉ}
    exact
      mul_mem
        (IsSwap.mul_mem_closure_three_cycles (hl a (List.mem_cons_self a _))
          (hl b (List.mem_cons_of_mem a (l.mem_cons_self b))))
        (ih _ (fun g hg => hl g (List.mem_cons_of_mem _ (List.mem_cons_of_mem _ hg))) hn)
#align equiv.perm.closure_three_cycles_eq_alternating Equiv.Perm.closure_three_cycles_eq_alternating

/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on
  at least 5 elements is the entire alternating group if it contains a 3-cycle. -/
theorem IsThreeCycle.alternating_normalClosure (h5 : 5 ‚â§ Fintype.card Œ±) {f : Perm Œ±}
    (hf : IsThreeCycle f) :
    normalClosure ({‚ü®f, hf.mem_alternatingGroup‚ü©} : Set (alternatingGroup Œ±)) = ‚ä§ :=
  eq_top_iff.2
    (by
      have hi : Function.Injective (alternatingGroup Œ±).subtype := Subtype.coe_injective
      -- ‚ä¢ ‚ä§ ‚â§ normalClosure {{ val := f, property := (_ : f ‚àà alternatingGroup Œ±) }}
      refine' eq_top_iff.1 (map_injective hi (le_antisymm (map_mono le_top) _))
      -- ‚ä¢ map (Subgroup.subtype (alternatingGroup Œ±)) ‚ä§ ‚â§ map (Subgroup.subtype (alter ‚Ä¶
      rw [‚Üê MonoidHom.range_eq_map, subtype_range, normalClosure, MonoidHom.map_closure]
      -- ‚ä¢ alternatingGroup Œ± ‚â§ closure (‚Üë(Subgroup.subtype (alternatingGroup Œ±)) '' Gr ‚Ä¶
      refine' (le_of_eq closure_three_cycles_eq_alternating.symm).trans (closure_mono _)
      -- ‚ä¢ {œÉ | IsThreeCycle œÉ} ‚äÜ ‚Üë(Subgroup.subtype (alternatingGroup Œ±)) '' Group.con ‚Ä¶
      intro g h
      -- ‚ä¢ g ‚àà ‚Üë(Subgroup.subtype (alternatingGroup Œ±)) '' Group.conjugatesOfSet {{ val ‚Ä¶
      obtain ‚ü®c, rfl‚ü© := isConj_iff.1 (isConj_iff_cycleType_eq.2 (hf.trans h.symm))
      -- ‚ä¢ c * f * c‚Åª¬π ‚àà ‚Üë(Subgroup.subtype (alternatingGroup Œ±)) '' Group.conjugatesOf ‚Ä¶
      refine' ‚ü®‚ü®c * f * c‚Åª¬π, h.mem_alternatingGroup‚ü©, _, rfl‚ü©
      -- ‚ä¢ { val := c * f * c‚Åª¬π, property := (_ : c * f * c‚Åª¬π ‚àà alternatingGroup Œ±) } ‚àà ‚Ä¶
      rw [Group.mem_conjugatesOfSet_iff]
      -- ‚ä¢ ‚àÉ a, a ‚àà {{ val := f, property := (_ : f ‚àà alternatingGroup Œ±) }} ‚àß IsConj a ‚Ä¶
      exact ‚ü®‚ü®f, hf.mem_alternatingGroup‚ü©, Set.mem_singleton _, isThreeCycle_isConj h5 hf h‚ü©)
      -- üéâ no goals
#align equiv.perm.is_three_cycle.alternating_normal_closure Equiv.Perm.IsThreeCycle.alternating_normalClosure

/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in
  its cycle decomposition is a 3-cycle, so the normal closure of the original element must be
  $A_5$. -/
theorem isThreeCycle_sq_of_three_mem_cycleType_five {g : Perm (Fin 5)} (h : 3 ‚àà cycleType g) :
    IsThreeCycle (g * g) := by
  obtain ‚ü®c, g', rfl, hd, _, h3‚ü© := mem_cycleType_iff.1 h
  -- ‚ä¢ IsThreeCycle (c * g' * (c * g'))
  simp only [mul_assoc]
  -- ‚ä¢ IsThreeCycle (c * (g' * (c * g')))
  rw [hd.commute.eq, ‚Üê mul_assoc g']
  -- ‚ä¢ IsThreeCycle (c * (g' * g' * c))
  suffices hg' : orderOf g' ‚à£ 2
  -- ‚ä¢ IsThreeCycle (c * (g' * g' * c))
  ¬∑ rw [‚Üê pow_two, orderOf_dvd_iff_pow_eq_one.1 hg', one_mul]
    -- ‚ä¢ IsThreeCycle (c * c)
    exact (card_support_eq_three_iff.1 h3).isThreeCycle_sq
    -- üéâ no goals
  rw [‚Üê lcm_cycleType, Multiset.lcm_dvd]
  -- ‚ä¢ ‚àÄ (b : ‚Ñï), b ‚àà cycleType g' ‚Üí b ‚à£ 2
  intro n hn
  -- ‚ä¢ n ‚à£ 2
  rw [le_antisymm (two_le_of_mem_cycleType hn) (le_trans (le_card_support_of_mem_cycleType hn) _)]
  -- ‚ä¢ Finset.card (support g') ‚â§ 2
  apply le_of_add_le_add_left
  -- ‚ä¢ ?a + Finset.card (support g') ‚â§ ?a + 2
  rw [‚Üê hd.card_support_mul, h3]
  -- ‚ä¢ Finset.card (support (c * g')) ‚â§ 3 + 2
  exact (c * g').support.card_le_univ
  -- üéâ no goals
#align equiv.perm.is_three_cycle_sq_of_three_mem_cycle_type_five Equiv.Perm.isThreeCycle_sq_of_three_mem_cycleType_five

end Equiv.Perm

namespace alternatingGroup

open Equiv.Perm

theorem nontrivial_of_three_le_card (h3 : 3 ‚â§ card Œ±) : Nontrivial (alternatingGroup Œ±) := by
  haveI := Fintype.one_lt_card_iff_nontrivial.1 (lt_trans (by decide) h3)
  -- ‚ä¢ Nontrivial { x // x ‚àà alternatingGroup Œ± }
  rw [‚Üê Fintype.one_lt_card_iff_nontrivial]
  -- ‚ä¢ 1 < card { x // x ‚àà alternatingGroup Œ± }
  refine' lt_of_mul_lt_mul_left _ (le_of_lt Nat.prime_two.pos)
  -- ‚ä¢ 2 * 1 < 2 * card { x // x ‚àà alternatingGroup Œ± }
  rw [two_mul_card_alternatingGroup, card_perm, ‚Üê Nat.succ_le_iff]
  -- ‚ä¢ Nat.succ (2 * 1) ‚â§ Nat.factorial (card Œ±)
  exact le_trans h3 (card Œ±).self_le_factorial
  -- üéâ no goals
#align alternating_group.nontrivial_of_three_le_card alternatingGroup.nontrivial_of_three_le_card

instance {n : ‚Ñï} : Nontrivial (alternatingGroup (Fin (n + 3))) :=
  nontrivial_of_three_le_card
    (by
      rw [card_fin]
      -- ‚ä¢ 3 ‚â§ n + 3
      exact le_add_left (le_refl 3))
      -- üéâ no goals

/-- The normal closure of the 5-cycle `finRotate 5` within $A_5$ is the whole group. This will be
  used to show that the normal closure of any 5-cycle within $A_5$ is the whole group. -/
theorem normalClosure_finRotate_five : normalClosure ({‚ü®finRotate 5,
    finRotate_bit1_mem_alternatingGroup (n := 2)‚ü©} : Set (alternatingGroup (Fin 5))) = ‚ä§ :=
  eq_top_iff.2
    (by
      have h3 :
        IsThreeCycle (Fin.cycleRange 2 * finRotate 5 * (Fin.cycleRange 2)‚Åª¬π * (finRotate 5)‚Åª¬π) :=
        card_support_eq_three_iff.1 (by decide)
      rw [‚Üê h3.alternating_normalClosure (by rw [card_fin])]
      -- ‚ä¢ normalClosure {{ val := Fin.cycleRange 2 * finRotate 5 * (Fin.cycleRange 2)‚Åª ‚Ä¶
      refine' normalClosure_le_normal _
      -- ‚ä¢ {{ val := Fin.cycleRange 2 * finRotate 5 * (Fin.cycleRange 2)‚Åª¬π * (finRotate ‚Ä¶
      rw [Set.singleton_subset_iff, SetLike.mem_coe]
      -- ‚ä¢ { val := Fin.cycleRange 2 * finRotate 5 * (Fin.cycleRange 2)‚Åª¬π * (finRotate  ‚Ä¶
      have h :
        (‚ü®finRotate 5, finRotate_bit1_mem_alternatingGroup (n := 2)‚ü© : alternatingGroup (Fin 5)) ‚àà
          normalClosure _ :=
        SetLike.mem_coe.1 (subset_normalClosure (Set.mem_singleton _))
      exact (mul_mem (Subgroup.normalClosure_normal.conj_mem _ h
          ‚ü®Fin.cycleRange 2, Fin.isThreeCycle_cycleRange_two.mem_alternatingGroup‚ü©) (inv_mem h)
      --Porting note : added `: _`
          : _))
#align alternating_group.normal_closure_fin_rotate_five alternatingGroup.normalClosure_finRotate_five

/-- The normal closure of $(04)(13)$ within $A_5$ is the whole group. This will be
  used to show that the normal closure of any permutation of cycle type $(2,2)$ is the whole group.
  -/
theorem normalClosure_swap_mul_swap_five :
    normalClosure
        ({‚ü®swap 0 4 * swap 1 3, mem_alternatingGroup.2 (by decide)‚ü©} :
                                                           -- üéâ no goals
          Set (alternatingGroup (Fin 5))) =
      ‚ä§ := by
  let g1 := (‚ü®swap 0 2 * swap 0 1, mem_alternatingGroup.2 (by decide)‚ü© : alternatingGroup (Fin 5))
  -- ‚ä¢ normalClosure {{ val := swap 0 4 * swap 1 3, property := (_ : swap 0 4 * swa ‚Ä¶
  let g2 := (‚ü®swap 0 4 * swap 1 3, mem_alternatingGroup.2 (by decide)‚ü© : alternatingGroup (Fin 5))
  -- ‚ä¢ normalClosure {{ val := swap 0 4 * swap 1 3, property := (_ : swap 0 4 * swa ‚Ä¶
  have h5 : g1 * g2 * g1‚Åª¬π * g2‚Åª¬π =
      ‚ü®finRotate 5, finRotate_bit1_mem_alternatingGroup (n := 2)‚ü© := by
    rw [Subtype.ext_iff]
    simp only [Fin.val_mk, Subgroup.coe_mul, Subgroup.coe_inv, Fin.val_mk]
  rw [eq_top_iff, ‚Üê normalClosure_finRotate_five]
  -- ‚ä¢ normalClosure {{ val := finRotate 5, property := (_ : finRotate (bit1 2) ‚àà a ‚Ä¶
  refine' normalClosure_le_normal _
  -- ‚ä¢ {{ val := finRotate 5, property := (_ : finRotate (bit1 2) ‚àà alternatingGrou ‚Ä¶
  rw [Set.singleton_subset_iff, SetLike.mem_coe, ‚Üê h5]
  -- ‚ä¢ g1 * g2 * g1‚Åª¬π * g2‚Åª¬π ‚àà normalClosure {{ val := swap 0 4 * swap 1 3, propert ‚Ä¶
  have h : g2 ‚àà normalClosure {g2} :=
    SetLike.mem_coe.1 (subset_normalClosure (Set.mem_singleton _))
  exact mul_mem (Subgroup.normalClosure_normal.conj_mem _ h g1) (inv_mem h)
  -- üéâ no goals
#align alternating_group.normal_closure_swap_mul_swap_five alternatingGroup.normalClosure_swap_mul_swap_five

/-- Shows that any non-identity element of $A_5$ whose cycle decomposition consists only of swaps
  is conjugate to $(04)(13)$. This is used to show that the normal closure of such a permutation
  in $A_5$ is $A_5$. -/
theorem isConj_swap_mul_swap_of_cycleType_two {g : Perm (Fin 5)} (ha : g ‚àà alternatingGroup (Fin 5))
    (h1 : g ‚â† 1) (h2 : ‚àÄ n, n ‚àà cycleType (g : Perm (Fin 5)) ‚Üí n = 2) :
    IsConj (swap 0 4 * swap 1 3) g := by
  have h := g.support.card_le_univ
  -- ‚ä¢ IsConj (swap 0 4 * swap 1 3) g
  rw [‚Üê Multiset.eq_replicate_card] at h2
  -- ‚ä¢ IsConj (swap 0 4 * swap 1 3) g
  rw [‚Üê sum_cycleType, h2, Multiset.sum_replicate, smul_eq_mul] at h
  -- ‚ä¢ IsConj (swap 0 4 * swap 1 3) g
  have h : Multiset.card g.cycleType ‚â§ 3 :=
    le_of_mul_le_mul_right (le_trans h (by simp only [card_fin]; ring_nf)) (by simp)
  rw [mem_alternatingGroup, sign_of_cycleType, h2] at ha
  -- ‚ä¢ IsConj (swap 0 4 * swap 1 3) g
  norm_num at ha
  -- ‚ä¢ IsConj (swap 0 4 * swap 1 3) g
  rw [pow_add, pow_mul, Int.units_pow_two, one_mul, Units.ext_iff, Units.val_one,
    Units.val_pow_eq_pow_val, Units.coe_neg_one, neg_one_pow_eq_one_iff_even _] at ha
  swap; ¬∑ decide
  -- ‚ä¢ -1 ‚â† 1
          -- üéâ no goals
  rw [isConj_iff_cycleType_eq, h2]
  -- ‚ä¢ cycleType (swap 0 4 * swap 1 3) = Multiset.replicate (‚ÜëMultiset.card (cycleT ‚Ä¶
  interval_cases h_1 : Multiset.card g.cycleType
  ¬∑ exact (h1 (card_cycleType_eq_zero.1 h_1)).elim
    -- üéâ no goals
  ¬∑ contrapose! ha
    -- ‚ä¢ ¬¨Even 1
    simp [h_1]
    -- üéâ no goals
  ¬∑ have h04 : (0 : Fin 5) ‚â† 4 := by decide
    -- ‚ä¢ cycleType (swap 0 4 * swap 1 3) = Multiset.replicate 2 2
    have h13 : (1 : Fin 5) ‚â† 3 := by decide
    -- ‚ä¢ cycleType (swap 0 4 * swap 1 3) = Multiset.replicate 2 2
    rw [Disjoint.cycleType, (isCycle_swap h04).cycleType, (isCycle_swap h13).cycleType,
      card_support_swap h04, card_support_swap h13]
    ¬∑ rfl
      -- üéâ no goals
    ¬∑ rw [disjoint_iff_disjoint_support, support_swap h04, support_swap h13]
      -- ‚ä¢ _root_.Disjoint {0, 4} {1, 3}
      decide
      -- üéâ no goals
  ¬∑ contrapose! ha
    -- ‚ä¢ ¬¨Even 3
    simp [h_1]
    -- üéâ no goals
#align alternating_group.is_conj_swap_mul_swap_of_cycle_type_two alternatingGroup.isConj_swap_mul_swap_of_cycleType_two

/-- Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework
  on its cycle type that its normal closure is all of $A_5$. -/
instance isSimpleGroup_five : IsSimpleGroup (alternatingGroup (Fin 5)) :=
  ‚ü®fun H => by
    intro Hn
    -- ‚ä¢ H = ‚ä• ‚à® H = ‚ä§
    refine' or_not.imp id fun Hb => _
    -- ‚ä¢ H = ‚ä§
    rw [eq_bot_iff_forall] at Hb
    -- ‚ä¢ H = ‚ä§
    push_neg at Hb
    -- ‚ä¢ H = ‚ä§
    obtain ‚ü®‚ü®g, gA‚ü©, gH, g1‚ü© : ‚àÉ x : ‚Ü•(alternatingGroup (Fin 5)), x ‚àà H ‚àß x ‚â† 1 := Hb
    -- ‚ä¢ H = ‚ä§
    -- `g` is a non-identity alternating permutation in a normal subgroup `H` of $A_5$.
    rw [‚Üê SetLike.mem_coe, ‚Üê Set.singleton_subset_iff] at gH
    -- ‚ä¢ H = ‚ä§
    refine' eq_top_iff.2 (le_trans (ge_of_eq _) (normalClosure_le_normal gH))
    -- ‚ä¢ normalClosure {{ val := g, property := gA }} = ‚ä§
    -- It suffices to show that the normal closure of `g` in $A_5$ is $A_5$.
    by_cases h2 : ‚àÄ n ‚àà g.cycleType, n = 2
    -- ‚ä¢ normalClosure {{ val := g, property := gA }} = ‚ä§
    -- If the cycle decomposition of `g` consists entirely of swaps, then the cycle type is $(2,2)$.
    -- This means that it is conjugate to $(04)(13)$, whose normal closure is $A_5$.
    ¬∑ rw [Ne.def, Subtype.ext_iff] at g1
      -- ‚ä¢ normalClosure {{ val := g, property := gA }} = ‚ä§
      exact
        (isConj_swap_mul_swap_of_cycleType_two gA g1 h2).normalClosure_eq_top_of
          normalClosure_swap_mul_swap_five
    push_neg at h2
    -- ‚ä¢ normalClosure {{ val := g, property := gA }} = ‚ä§
    obtain ‚ü®n, ng, n2‚ü© : ‚àÉ n : ‚Ñï, n ‚àà g.cycleType ‚àß n ‚â† 2 := h2
    -- ‚ä¢ normalClosure {{ val := g, property := gA }} = ‚ä§
    -- `n` is the size of a non-swap cycle in the decomposition of `g`.
    have n2' : 2 < n := lt_of_le_of_ne (two_le_of_mem_cycleType ng) n2.symm
    -- ‚ä¢ normalClosure {{ val := g, property := gA }} = ‚ä§
    have n5 : n ‚â§ 5 := le_trans ?_ g.support.card_le_univ
    -- ‚ä¢ normalClosure {{ val := g, property := gA }} = ‚ä§
    -- We check that `2 < n ‚â§ 5`, so that `interval_cases` has a precise range to check.
    swap
    -- ‚ä¢ n ‚â§ Finset.card (support g)
    ¬∑ obtain ‚ü®m, hm‚ü© := Multiset.exists_cons_of_mem ng
      -- ‚ä¢ n ‚â§ Finset.card (support g)
      rw [‚Üê sum_cycleType, hm, Multiset.sum_cons]
      -- ‚ä¢ n ‚â§ n + Multiset.sum m
      exact le_add_right le_rfl
      -- üéâ no goals
    interval_cases n
    -- This breaks into cases `n = 3`, `n = 4`, `n = 5`.
    -- If `n = 3`, then `g` has a 3-cycle in its decomposition, so `g^2` is a 3-cycle.
    -- `g^2` is in the normal closure of `g`, so that normal closure must be $A_5$.
    ¬∑ rw [eq_top_iff, ‚Üê (isThreeCycle_sq_of_three_mem_cycleType_five ng).alternating_normalClosure
        (by rw [card_fin])]
      refine' normalClosure_le_normal _
      -- ‚ä¢ {{ val := g * g, property := (_ : g * g ‚àà alternatingGroup (Fin 5)) }} ‚äÜ ‚Üë(n ‚Ä¶
      rw [Set.singleton_subset_iff, SetLike.mem_coe]
      -- ‚ä¢ { val := g * g, property := (_ : g * g ‚àà alternatingGroup (Fin 5)) } ‚àà norma ‚Ä¶
      have h := SetLike.mem_coe.1 (subset_normalClosure
        (G := alternatingGroup (Fin 5)) (Set.mem_singleton ‚ü®g, gA‚ü©))
      exact mul_mem h h
      -- üéâ no goals
    ¬∑ -- The case `n = 4` leads to contradiction, as no element of $A_5$ includes a 4-cycle.
      have con := mem_alternatingGroup.1 gA
      -- ‚ä¢ normalClosure {{ val := g, property := gA }} = ‚ä§
      contrapose! con
      -- ‚ä¢ ‚Üësign g ‚â† 1
      rw [sign_of_cycleType, cycleType_of_card_le_mem_cycleType_add_two (by decide) ng]
      -- ‚ä¢ (-1) ^ (Multiset.sum {4} + ‚ÜëMultiset.card {4}) ‚â† 1
      dsimp only
      -- ‚ä¢ (-1) ^ (Multiset.sum {4} + ‚ÜëMultiset.card {4}) ‚â† 1
      decide
      -- üéâ no goals
    ¬∑ -- If `n = 5`, then `g` is itself a 5-cycle, conjugate to `finRotate 5`.
      refine' (isConj_iff_cycleType_eq.2 _).normalClosure_eq_top_of normalClosure_finRotate_five
      -- ‚ä¢ cycleType (finRotate 5) = cycleType g
      rw [cycleType_of_card_le_mem_cycleType_add_two (by decide) ng, cycleType_finRotate]‚ü©
      -- üéâ no goals
#align alternating_group.is_simple_group_five alternatingGroup.isSimpleGroup_five

end alternatingGroup
