/-
Copyright (c) 2018 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl
-/
import Mathlib.Algebra.BigOperators.Order
import Mathlib.Data.Nat.Totient
import Mathlib.GroupTheory.OrderOfElement
import Mathlib.GroupTheory.Subgroup.Simple
import Mathlib.Tactic.Group
import Mathlib.GroupTheory.Exponent

#align_import group_theory.specific_groups.cyclic from "leanprover-community/mathlib"@"0f6670b8af2dff699de1c0b4b49039b31bc13c46"

/-!
# Cyclic groups

A group `G` is called cyclic if there exists an element `g : G` such that every element of `G` is of
the form `g ^ n` for some `n : ‚Ñï`. This file only deals with the predicate on a group to be cyclic.
For the concrete cyclic group of order `n`, see `Data.ZMod.Basic`.

## Main definitions

* `IsCyclic` is a predicate on a group stating that the group is cyclic.

## Main statements

* `isCyclic_of_prime_card` proves that a finite group of prime order is cyclic.
* `isSimpleGroup_of_prime_card`, `IsSimpleGroup.isCyclic`,
  and `IsSimpleGroup.prime_card` classify finite simple abelian groups.
* `IsCyclic.exponent_eq_card`: For a finite cyclic group `G`, the exponent is equal to
  the group's cardinality.
* `IsCyclic.exponent_eq_zero_of_infinite`: Infinite cyclic groups have exponent zero.
* `IsCyclic.iff_exponent_eq_card`: A finite commutative group is cyclic iff its exponent
  is equal to its cardinality.

## Tags

cyclic group
-/


universe u

variable {Œ± : Type u} {a : Œ±}

section Cyclic

open BigOperators

attribute [local instance] setFintype

open Subgroup

/-- A group is called *cyclic* if it is generated by a single element. -/
class IsAddCyclic (Œ± : Type u) [AddGroup Œ±] : Prop where
  exists_generator : ‚àÉ g : Œ±, ‚àÄ x, x ‚àà AddSubgroup.zmultiples g
#align is_add_cyclic IsAddCyclic

/-- A group is called *cyclic* if it is generated by a single element. -/
@[to_additive IsAddCyclic]
class IsCyclic (Œ± : Type u) [Group Œ±] : Prop where
  exists_generator : ‚àÉ g : Œ±, ‚àÄ x, x ‚àà zpowers g
#align is_cyclic IsCyclic

@[to_additive isAddCyclic_of_subsingleton]
instance (priority := 100) isCyclic_of_subsingleton [Group Œ±] [Subsingleton Œ±] : IsCyclic Œ± :=
  ‚ü®‚ü®1, fun x => by
      rw [Subsingleton.elim x 1]
      -- ‚ä¢ 1 ‚àà zpowers 1
      exact mem_zpowers 1‚ü©‚ü©
      -- üéâ no goals
#align is_cyclic_of_subsingleton isCyclic_of_subsingleton
#align is_add_cyclic_of_subsingleton isAddCyclic_of_subsingleton

/-- A cyclic group is always commutative. This is not an `instance` because often we have a better
proof of `CommGroup`. -/
@[to_additive
      "A cyclic group is always commutative. This is not an `instance` because often we have
      a better proof of `AddCommGroup`."]
def IsCyclic.commGroup [hg : Group Œ±] [IsCyclic Œ±] : CommGroup Œ± :=
  { hg with
    mul_comm := fun x y =>
      let ‚ü®_, hg‚ü© := IsCyclic.exists_generator (Œ± := Œ±)
      let ‚ü®_, hn‚ü© := hg x
      let ‚ü®_, hm‚ü© := hg y
      hm ‚ñ∏ hn ‚ñ∏ zpow_mul_comm _ _ _ }
#align is_cyclic.comm_group IsCyclic.commGroup
#align is_add_cyclic.add_comm_group IsAddCyclic.addCommGroup

variable [Group Œ±]

@[to_additive MonoidAddHom.map_add_cyclic]
theorem MonoidHom.map_cyclic {G : Type*} [Group G] [h : IsCyclic G] (œÉ : G ‚Üí* G) :
    ‚àÉ m : ‚Ñ§, ‚àÄ g : G, œÉ g = g ^ m := by
  obtain ‚ü®h, hG‚ü© := IsCyclic.exists_generator (Œ± := G)
  -- ‚ä¢ ‚àÉ m, ‚àÄ (g : G), ‚ÜëœÉ g = g ^ m
  obtain ‚ü®m, hm‚ü© := hG (œÉ h)
  -- ‚ä¢ ‚àÉ m, ‚àÄ (g : G), ‚ÜëœÉ g = g ^ m
  refine' ‚ü®m, fun g => _‚ü©
  -- ‚ä¢ ‚ÜëœÉ g = g ^ m
  obtain ‚ü®n, rfl‚ü© := hG g
  -- ‚ä¢ ‚ÜëœÉ ((fun x x_1 => x ^ x_1) h n) = (fun x x_1 => x ^ x_1) h n ^ m
  rw [MonoidHom.map_zpow, ‚Üê hm, ‚Üê zpow_mul, ‚Üê zpow_mul']
  -- üéâ no goals
#align monoid_hom.map_cyclic MonoidHom.map_cyclic
#align monoid_add_hom.map_add_cyclic MonoidAddHom.map_add_cyclic

@[to_additive isAddCyclic_of_orderOf_eq_card]
theorem isCyclic_of_orderOf_eq_card [Fintype Œ±] (x : Œ±) (hx : orderOf x = Fintype.card Œ±) :
    IsCyclic Œ± := by
  classical
    use x
    simp_rw [‚Üê SetLike.mem_coe, ‚Üê Set.eq_univ_iff_forall]
    rw [‚Üê Fintype.card_congr (Equiv.Set.univ Œ±), orderOf_eq_card_zpowers] at hx
    exact Set.eq_of_subset_of_card_le (Set.subset_univ _) (ge_of_eq hx)
#align is_cyclic_of_order_of_eq_card isCyclic_of_orderOf_eq_card
#align is_add_cyclic_of_order_of_eq_card isAddCyclic_of_orderOf_eq_card

/-- A finite group of prime order is cyclic. -/
@[to_additive isAddCyclic_of_prime_card "A finite group of prime order is cyclic."]
theorem isCyclic_of_prime_card {Œ± : Type u} [Group Œ±] [Fintype Œ±] {p : ‚Ñï} [hp : Fact p.Prime]
    (h : Fintype.card Œ± = p) : IsCyclic Œ± :=
  ‚ü®by
    obtain ‚ü®g, hg‚ü© : ‚àÉ g : Œ±, g ‚â† 1 := Fintype.exists_ne_of_one_lt_card (h.symm ‚ñ∏ hp.1.one_lt) 1
    -- ‚ä¢ ‚àÉ g, ‚àÄ (x : Œ±), x ‚àà zpowers g
    classical
      -- for Fintype (Subgroup.zpowers g)
      have : Fintype.card (Subgroup.zpowers g) ‚à£ p := by
        rw [‚Üê h]
        apply card_subgroup_dvd_card
      rw [Nat.dvd_prime hp.1] at this
      cases' this with that that
      ¬∑ rw [Fintype.card_eq_one_iff] at that
        cases' that with t ht
        suffices g = 1 by contradiction
        have hgt :=
          ht
            ‚ü®g, by
              change g ‚àà Subgroup.zpowers g
              exact Subgroup.mem_zpowers g‚ü©
        rw [‚Üê ht 1] at hgt
        change (‚ü®_, _‚ü© : Subgroup.zpowers g) = ‚ü®_, _‚ü© at hgt
        simpa using hgt
      ¬∑ use g
        intro x
        rw [‚Üê h] at that
        rw [Subgroup.eq_top_of_card_eq _ that]
        exact Subgroup.mem_top _‚ü©
#align is_cyclic_of_prime_card isCyclic_of_prime_card
#align is_add_cyclic_of_prime_card isAddCyclic_of_prime_card

@[to_additive addOrderOf_eq_card_of_forall_mem_zmultiples]
theorem orderOf_eq_card_of_forall_mem_zpowers [Fintype Œ±] {g : Œ±} (hx : ‚àÄ x, x ‚àà zpowers g) :
    orderOf g = Fintype.card Œ± := by
  classical
    rw [orderOf_eq_card_zpowers]
    apply Fintype.card_of_finset'
    simpa using hx
#align order_of_eq_card_of_forall_mem_zpowers orderOf_eq_card_of_forall_mem_zpowers
#align add_order_of_eq_card_of_forall_mem_zmultiples addOrderOf_eq_card_of_forall_mem_zmultiples

@[to_additive Infinite.addOrderOf_eq_zero_of_forall_mem_zmultiples]
theorem Infinite.orderOf_eq_zero_of_forall_mem_zpowers [Infinite Œ±] {g : Œ±}
    (h : ‚àÄ x, x ‚àà zpowers g) : orderOf g = 0 := by
  classical
    rw [orderOf_eq_zero_iff']
    refine' fun n hn hgn => _
    have ho := orderOf_pos' ((isOfFinOrder_iff_pow_eq_one g).mpr ‚ü®n, hn, hgn‚ü©)
    obtain ‚ü®x, hx‚ü© :=
      Infinite.exists_not_mem_finset
        (Finset.image (fun x => g ^ x) <| Finset.range <| orderOf g)
    apply hx
    rw [‚Üê mem_powers_iff_mem_range_order_of' (x := g) (y := x) ho, Submonoid.mem_powers_iff]
    obtain ‚ü®k, hk‚ü© := h x
    dsimp at hk
    obtain ‚ü®k, rfl | rfl‚ü© := k.eq_nat_or_neg
    ¬∑ exact ‚ü®k, by exact_mod_cast hk‚ü©
    rw [zpow_eq_mod_orderOf] at hk
    have : 0 ‚â§ (-k % orderOf g : ‚Ñ§) := Int.emod_nonneg (-k) (by exact_mod_cast ho.ne')
    refine' ‚ü®(-k % orderOf g : ‚Ñ§).toNat, _‚ü©
    rwa [‚Üê zpow_ofNat, Int.toNat_of_nonneg this]
#align infinite.order_of_eq_zero_of_forall_mem_zpowers Infinite.orderOf_eq_zero_of_forall_mem_zpowers
#align infinite.add_order_of_eq_zero_of_forall_mem_zmultiples Infinite.addOrderOf_eq_zero_of_forall_mem_zmultiples

@[to_additive Bot.isAddCyclic]
instance Bot.isCyclic {Œ± : Type u} [Group Œ±] : IsCyclic (‚ä• : Subgroup Œ±) :=
  ‚ü®‚ü®1, fun x => ‚ü®0, Subtype.eq <| (zpow_zero (1 : Œ±)).trans <| Eq.symm (Subgroup.mem_bot.1 x.2)‚ü©‚ü©‚ü©
#align bot.is_cyclic Bot.isCyclic
#align bot.is_add_cyclic Bot.isAddCyclic

@[to_additive AddSubgroup.isAddCyclic]
instance Subgroup.isCyclic {Œ± : Type u} [Group Œ±] [IsCyclic Œ±] (H : Subgroup Œ±) : IsCyclic H :=
  haveI := Classical.propDecidable
  let ‚ü®g, hg‚ü© := IsCyclic.exists_generator (Œ± := Œ±)
  if hx : ‚àÉ x : Œ±, x ‚àà H ‚àß x ‚â† (1 : Œ±) then
    let ‚ü®x, hx‚ÇÅ, hx‚ÇÇ‚ü© := hx
    let ‚ü®k, hk‚ü© := hg x
    have hk : g ^ k = x := hk
    have hex : ‚àÉ n : ‚Ñï, 0 < n ‚àß g ^ n ‚àà H :=
      ‚ü®k.natAbs,
        Nat.pos_of_ne_zero fun h => hx‚ÇÇ <| by
          rw [‚Üê hk, Int.natAbs_eq_zero.mp h, zpow_zero], by
          -- üéâ no goals
            cases' k with k k
            -- ‚ä¢ g ^ Int.natAbs (Int.ofNat k) ‚àà H
            ¬∑ rw [Int.ofNat_eq_coe, Int.natAbs_cast k, ‚Üê zpow_ofNat, ‚ÜêInt.ofNat_eq_coe, hk]
              -- ‚ä¢ x ‚àà H
              exact hx‚ÇÅ
              -- üéâ no goals
            ¬∑ rw [Int.natAbs_negSucc, ‚Üê Subgroup.inv_mem_iff H]; simp_all‚ü©
              -- ‚ä¢ (g ^ Nat.succ k)‚Åª¬π ‚àà H
                                                                 -- üéâ no goals
    ‚ü®‚ü®‚ü®g ^ Nat.find hex, (Nat.find_spec hex).2‚ü©, fun ‚ü®x, hx‚ü© =>
        let ‚ü®k, hk‚ü© := hg x
        have hk : g ^ k = x := hk
        have hk‚ÇÇ : g ^ ((Nat.find hex : ‚Ñ§) * (k / Nat.find hex : ‚Ñ§)) ‚àà H := by
          rw [zpow_mul]
          -- ‚ä¢ (g ^ ‚Üë(Nat.find hex)) ^ (k / ‚Üë(Nat.find hex)) ‚àà H
          apply H.zpow_mem
          -- ‚ä¢ g ^ ‚Üë(Nat.find hex) ‚àà H
          exact_mod_cast (Nat.find_spec hex).2
          -- üéâ no goals
        have hk‚ÇÉ : g ^ (k % Nat.find hex : ‚Ñ§) ‚àà H :=
          (Subgroup.mul_mem_cancel_right H hk‚ÇÇ).1 <| by
            rw [‚Üê zpow_add, Int.emod_add_ediv, hk]; exact hx
            -- ‚ä¢ x ‚àà H
                                                    -- üéâ no goals
        have hk‚ÇÑ : k % Nat.find hex = (k % Nat.find hex).natAbs := by
          rw [Int.natAbs_of_nonneg
              (Int.emod_nonneg _ (Int.coe_nat_ne_zero_iff_pos.2 (Nat.find_spec hex).1))]
        have hk‚ÇÖ : g ^ (k % Nat.find hex).natAbs ‚àà H := by rwa [‚Üê zpow_ofNat, ‚Üê hk‚ÇÑ]
                                                           -- üéâ no goals
        have hk‚ÇÜ : (k % (Nat.find hex : ‚Ñ§)).natAbs = 0 :=
          by_contradiction fun h =>
            Nat.find_min hex
              (Int.ofNat_lt.1 <| by
                rw [‚Üê hk‚ÇÑ]; exact Int.emod_lt_of_pos _ (Int.coe_nat_pos.2 (Nat.find_spec hex).1))
                -- ‚ä¢ k % ‚Üë(Nat.find hex) < ‚Üë(Nat.find hex)
                            -- üéâ no goals
              ‚ü®Nat.pos_of_ne_zero h, hk‚ÇÖ‚ü©
        ‚ü®k / (Nat.find hex : ‚Ñ§),
          Subtype.ext_iff_val.2
            (by
              suffices g ^ ((Nat.find hex : ‚Ñ§) * (k / Nat.find hex : ‚Ñ§)) = x by simpa [zpow_mul]
              -- ‚ä¢ g ^ (‚Üë(Nat.find hex) * (k / ‚Üë(Nat.find hex))) = x
              rw [Int.mul_ediv_cancel'
                  (Int.dvd_of_emod_eq_zero (Int.natAbs_eq_zero.mp hk‚ÇÜ)),
                hk])‚ü©‚ü©‚ü©
  else by
    have : H = (‚ä• : Subgroup Œ±) :=
      Subgroup.ext fun x =>
        ‚ü®fun h => by simp at *; tauto, fun h => by rw [Subgroup.mem_bot.1 h]; exact H.one_mem‚ü©
    subst this; infer_instance
    -- ‚ä¢ IsCyclic { x // x ‚àà ‚ä• }
                -- üéâ no goals
#align subgroup.is_cyclic Subgroup.isCyclic
#align add_subgroup.is_add_cyclic AddSubgroup.isAddCyclic

open Finset Nat

section Classical

open Classical

@[to_additive IsAddCyclic.card_pow_eq_one_le]
theorem IsCyclic.card_pow_eq_one_le [DecidableEq Œ±] [Fintype Œ±] [IsCyclic Œ±] {n : ‚Ñï} (hn0 : 0 < n) :
    (univ.filter fun a : Œ± => a ^ n = 1).card ‚â§ n :=
  let ‚ü®g, hg‚ü© := IsCyclic.exists_generator (Œ± := Œ±)
  calc
    (univ.filter fun a : Œ± => a ^ n = 1).card ‚â§
        (zpowers (g ^ (Fintype.card Œ± / Nat.gcd n (Fintype.card Œ±))) : Set Œ±).toFinset.card :=
      card_le_of_subset fun x hx =>
        let ‚ü®m, hm‚ü© := show x ‚àà Submonoid.powers g from mem_powers_iff_mem_zpowers.2 <| hg x
        Set.mem_toFinset.2
          ‚ü®(m / (Fintype.card Œ± / Nat.gcd n (Fintype.card Œ±)) : ‚Ñï), by
            dsimp at hm
            -- ‚ä¢ (fun x x_1 => x ^ x_1) (g ^ (Fintype.card Œ± / Nat.gcd n (Fintype.card Œ±))) ‚Üë ‚Ä¶
            have hgmn : g ^ (m * Nat.gcd n (Fintype.card Œ±)) = 1 := by
              rw [pow_mul, hm, ‚Üê pow_gcd_card_eq_one_iff]; exact (mem_filter.1 hx).2
            dsimp only
            -- ‚ä¢ (g ^ (Fintype.card Œ± / Nat.gcd n (Fintype.card Œ±))) ^ ‚Üë(m / (Fintype.card Œ±  ‚Ä¶
            rw [zpow_ofNat, ‚Üê pow_mul, Nat.mul_div_cancel_left', hm]
            -- ‚ä¢ Fintype.card Œ± / Nat.gcd n (Fintype.card Œ±) ‚à£ m
            refine' Nat.dvd_of_mul_dvd_mul_right (gcd_pos_of_pos_left (Fintype.card Œ±) hn0) _
            -- ‚ä¢ Fintype.card Œ± / Nat.gcd n (Fintype.card Œ±) * Nat.gcd n (Fintype.card Œ±) ‚à£ m ‚Ä¶
            conv_lhs =>
              rw [Nat.div_mul_cancel (Nat.gcd_dvd_right _ _), ‚Üê
                orderOf_eq_card_of_forall_mem_zpowers hg]
            exact orderOf_dvd_of_pow_eq_one hgmn‚ü©
            -- üéâ no goals
    _ ‚â§ n := by
      let ‚ü®m, hm‚ü© := Nat.gcd_dvd_right n (Fintype.card Œ±)
      -- ‚ä¢ card (Set.toFinset ‚Üë(zpowers (g ^ (Fintype.card Œ± / Nat.gcd n (Fintype.card  ‚Ä¶
      have hm0 : 0 < m :=
        Nat.pos_of_ne_zero fun hm0 => by
          rw [hm0, mul_zero, Fintype.card_eq_zero_iff] at hm
          exact hm.elim' 1
      simp only [Set.toFinset_card, SetLike.coe_sort_coe]
      -- ‚ä¢ Fintype.card { x // x ‚àà zpowers (g ^ (Fintype.card Œ± / Nat.gcd n (Fintype.ca ‚Ä¶
      rw [‚Üê orderOf_eq_card_zpowers, orderOf_pow g, orderOf_eq_card_of_forall_mem_zpowers hg]
      -- ‚ä¢ Fintype.card Œ± / Nat.gcd (Fintype.card Œ±) (Fintype.card Œ± / Nat.gcd n (Finty ‚Ä¶
      nth_rw 2 [hm]; nth_rw 3 [hm]
      -- ‚ä¢ Fintype.card Œ± / Nat.gcd (Nat.gcd n (Fintype.card Œ±) * m) (Fintype.card Œ± /  ‚Ä¶
                     -- ‚ä¢ Fintype.card Œ± / Nat.gcd (Nat.gcd n (Fintype.card Œ±) * m) (Nat.gcd n (Fintyp ‚Ä¶
      rw [Nat.mul_div_cancel_left _ (gcd_pos_of_pos_left _ hn0), gcd_mul_left_left, hm,
        Nat.mul_div_cancel _ hm0]
      exact le_of_dvd hn0 (Nat.gcd_dvd_left _ _)
      -- üéâ no goals
#align is_cyclic.card_pow_eq_one_le IsCyclic.card_pow_eq_one_le
#align is_add_cyclic.card_pow_eq_one_le IsAddCyclic.card_pow_eq_one_le

end Classical

@[to_additive]
theorem IsCyclic.exists_monoid_generator [Finite Œ±] [IsCyclic Œ±] :
    ‚àÉ x : Œ±, ‚àÄ y : Œ±, y ‚àà Submonoid.powers x := by
  simp_rw [mem_powers_iff_mem_zpowers]
  -- ‚ä¢ ‚àÉ x, ‚àÄ (y : Œ±), y ‚àà zpowers x
  exact IsCyclic.exists_generator
  -- üéâ no goals
#align is_cyclic.exists_monoid_generator IsCyclic.exists_monoid_generator
#align is_add_cyclic.exists_add_monoid_generator IsAddCyclic.exists_addMonoid_generator

section

variable [DecidableEq Œ±] [Fintype Œ±]

@[to_additive]
theorem IsCyclic.image_range_orderOf (ha : ‚àÄ x : Œ±, x ‚àà zpowers a) :
    Finset.image (fun i => a ^ i) (range (orderOf a)) = univ := by
  simp_rw [‚Üê SetLike.mem_coe] at ha
  -- ‚ä¢ image (fun i => a ^ i) (range (orderOf a)) = univ
  simp only [_root_.image_range_orderOf, Set.eq_univ_iff_forall.mpr ha, Set.toFinset_univ]
  -- üéâ no goals
#align is_cyclic.image_range_order_of IsCyclic.image_range_orderOf
#align is_add_cyclic.image_range_order_of IsAddCyclic.image_range_addOrderOf

@[to_additive]
theorem IsCyclic.image_range_card (ha : ‚àÄ x : Œ±, x ‚àà zpowers a) :
    Finset.image (fun i => a ^ i) (range (Fintype.card Œ±)) = univ := by
  rw [‚Üê orderOf_eq_card_of_forall_mem_zpowers ha, IsCyclic.image_range_orderOf ha]
  -- üéâ no goals
#align is_cyclic.image_range_card IsCyclic.image_range_card
#align is_add_cyclic.image_range_card IsAddCyclic.image_range_card

end

section Totient

variable [DecidableEq Œ±] [Fintype Œ±]
  (hn : ‚àÄ n : ‚Ñï, 0 < n ‚Üí (univ.filter fun a : Œ± => a ^ n = 1).card ‚â§ n)

private theorem card_pow_eq_one_eq_orderOf_aux (a : Œ±) :
    (Finset.univ.filter fun b : Œ± => b ^ orderOf a = 1).card = orderOf a :=
  le_antisymm (hn _ (orderOf_pos a))
    (calc
      orderOf a = @Fintype.card (zpowers a) (id _) := orderOf_eq_card_zpowers
      _ ‚â§
          @Fintype.card (‚Üë(univ.filter fun b : Œ± => b ^ orderOf a = 1) : Set Œ±)
            (Fintype.ofFinset _ fun _ => Iff.rfl) :=
        (@Fintype.card_le_of_injective (zpowers a)
          (‚Üë(univ.filter fun b : Œ± => b ^ orderOf a = 1) : Set Œ±) (id _) (id _)
          (fun b =>
            ‚ü®b.1,
              mem_filter.2
                ‚ü®mem_univ _, by
                  let ‚ü®i, hi‚ü© := b.2
                  -- ‚ä¢ ‚Üëb ^ orderOf a = 1
                  rw [‚Üê hi, ‚Üê zpow_ofNat, ‚Üê zpow_mul, mul_comm, zpow_mul, zpow_ofNat,
                    pow_orderOf_eq_one, one_zpow]‚ü©‚ü©)
          fun _ _ h => Subtype.eq (Subtype.mk.inj h))
      _ = (univ.filter fun b : Œ± => b ^ orderOf a = 1).card := Fintype.card_ofFinset _ _
      )

-- Use œÜ for `Nat.totient`
open Nat
private theorem card_orderOf_eq_totient_aux‚ÇÅ :
    ‚àÄ {d : ‚Ñï},
      d ‚à£ Fintype.card Œ± ‚Üí
        0 < (univ.filter fun a : Œ± => orderOf a = d).card ‚Üí
          (univ.filter fun a : Œ± => orderOf a = d).card = œÜ d := by
  intro d hd hpos
  -- ‚ä¢ card (filter (fun a => orderOf a = d) univ) = œÜ d
  induction' d using Nat.strongRec' with d IH
  -- ‚ä¢ card (filter (fun a => orderOf a = d) univ) = œÜ d
  rcases Decidable.eq_or_ne d 0 with (rfl | hd0)
  -- ‚ä¢ card (filter (fun a => orderOf a = 0) univ) = œÜ 0
  ¬∑ cases Fintype.card_ne_zero (eq_zero_of_zero_dvd hd)
    -- üéâ no goals
  rcases card_pos.1 hpos with ‚ü®a, ha'‚ü©
  -- ‚ä¢ card (filter (fun a => orderOf a = d) univ) = œÜ d
  have ha : orderOf a = d := (mem_filter.1 ha').2
  -- ‚ä¢ card (filter (fun a => orderOf a = d) univ) = œÜ d
  have h1 :
    (‚àë m in d.properDivisors, (univ.filter fun a : Œ± => orderOf a = m).card) =
      ‚àë m in d.properDivisors, œÜ m := by
    refine' Finset.sum_congr rfl fun m hm => _
    simp only [mem_filter, mem_range, mem_properDivisors] at hm
    refine' IH m hm.2 (hm.1.trans hd) (Finset.card_pos.2 ‚ü®a ^ (d / m), _‚ü©)
    simp only [mem_filter, mem_univ, orderOf_pow a, ha, true_and_iff,
      Nat.gcd_eq_right (div_dvd_of_dvd hm.1), Nat.div_div_self hm.1 hd0]
  have h2 :
    (‚àë m in d.divisors, (univ.filter fun a : Œ± => orderOf a = m).card) =
      ‚àë m in d.divisors, œÜ m := by
    rw [‚Üê filter_dvd_eq_divisors hd0, sum_card_orderOf_eq_card_pow_eq_one hd0,
      filter_dvd_eq_divisors hd0, sum_totient, ‚Üê ha, card_pow_eq_one_eq_orderOf_aux hn a]
  simpa [‚Üê cons_self_properDivisors hd0, ‚Üê h1] using h2
  -- üéâ no goals

theorem card_orderOf_eq_totient_aux‚ÇÇ {d : ‚Ñï} (hd : d ‚à£ Fintype.card Œ±) :
    (univ.filter fun a : Œ± => orderOf a = d).card = œÜ d := by
  let c := Fintype.card Œ±
  -- ‚ä¢ card (filter (fun a => orderOf a = d) univ) = œÜ d
  have hc0 : 0 < c := Fintype.card_pos_iff.2 ‚ü®1‚ü©
  -- ‚ä¢ card (filter (fun a => orderOf a = d) univ) = œÜ d
  apply card_orderOf_eq_totient_aux‚ÇÅ hn hd
  -- ‚ä¢ 0 < card (filter (fun a => orderOf a = d) univ)
  by_contra h0
  -- ‚ä¢ False
  simp only [not_lt, _root_.le_zero_iff, card_eq_zero] at h0
  -- ‚ä¢ False
  apply lt_irrefl c
  -- ‚ä¢ c < c
  calc
    c = ‚àë m in c.divisors, (univ.filter fun a : Œ± => orderOf a = m).card := by
      simp only [‚Üê filter_dvd_eq_divisors hc0.ne', sum_card_orderOf_eq_card_pow_eq_one hc0.ne']
      apply congr_arg card
      simp
    _ = ‚àë m in c.divisors.erase d, (univ.filter fun a : Œ± => orderOf a = m).card := by
      rw [eq_comm]
      refine' sum_subset (erase_subset _ _) fun m hm‚ÇÅ hm‚ÇÇ => _
      have : m = d := by
        contrapose! hm‚ÇÇ
        exact mem_erase_of_ne_of_mem hm‚ÇÇ hm‚ÇÅ
      simp [this, h0]
    _ ‚â§ ‚àë m in c.divisors.erase d, œÜ m := by
      refine' sum_le_sum fun m hm => _
      have hmc : m ‚à£ c := by
        simp only [mem_erase, mem_divisors] at hm
        tauto
      rcases (filter (fun a : Œ± => orderOf a = m) univ).card.eq_zero_or_pos with (h1 | h1)
      ¬∑ simp [h1]
      ¬∑ simp [card_orderOf_eq_totient_aux‚ÇÅ hn hmc h1]
    _ < ‚àë m in c.divisors, œÜ m :=
      (sum_erase_lt_of_pos (mem_divisors.2 ‚ü®hd, hc0.ne'‚ü©) (totient_pos (pos_of_dvd_of_pos hd hc0)))
    _ = c := sum_totient _
#align card_order_of_eq_totient_aux‚ÇÇ card_orderOf_eq_totient_aux‚ÇÇ

theorem isCyclic_of_card_pow_eq_one_le : IsCyclic Œ± :=
  have : (univ.filter fun a : Œ± => orderOf a = Fintype.card Œ±).Nonempty :=
    card_pos.1 <| by
      rw [card_orderOf_eq_totient_aux‚ÇÇ hn dvd_rfl];
      -- ‚ä¢ 0 < œÜ (Fintype.card Œ±)
        exact totient_pos (Fintype.card_pos_iff.2 ‚ü®1‚ü©)
        -- üéâ no goals
  let ‚ü®x, hx‚ü© := this
  isCyclic_of_orderOf_eq_card x (Finset.mem_filter.1 hx).2
#align is_cyclic_of_card_pow_eq_one_le isCyclic_of_card_pow_eq_one_le

theorem isAddCyclic_of_card_pow_eq_one_le {Œ±} [AddGroup Œ±] [DecidableEq Œ±] [Fintype Œ±]
    (hn : ‚àÄ n : ‚Ñï, 0 < n ‚Üí (univ.filter fun a : Œ± => n ‚Ä¢ a = 0).card ‚â§ n) : IsAddCyclic Œ± := by
  obtain ‚ü®g, hg‚ü© := (@isCyclic_of_card_pow_eq_one_le (Multiplicative Œ±) _ _ (_) hn)
  -- ‚ä¢ IsAddCyclic Œ±
  exact ‚ü®‚ü®g, hg‚ü©‚ü©
  -- üéâ no goals
#align is_add_cyclic_of_card_pow_eq_one_le isAddCyclic_of_card_pow_eq_one_le

attribute [to_additive existing isCyclic_of_card_pow_eq_one_le] isAddCyclic_of_card_pow_eq_one_le

end Totient

theorem IsCyclic.card_orderOf_eq_totient [IsCyclic Œ±] [Fintype Œ±] {d : ‚Ñï}
    (hd : d ‚à£ Fintype.card Œ±) : (univ.filter fun a : Œ± => orderOf a = d).card = totient d := by
  classical apply card_orderOf_eq_totient_aux‚ÇÇ (fun n => IsCyclic.card_pow_eq_one_le) hd
  -- üéâ no goals
#align is_cyclic.card_order_of_eq_totient IsCyclic.card_orderOf_eq_totient

theorem IsAddCyclic.card_orderOf_eq_totient {Œ± : Type*} [AddGroup Œ±] [IsAddCyclic Œ±]
    [Fintype Œ±] {d : ‚Ñï} (hd : d ‚à£ Fintype.card Œ±) :
    (univ.filter fun a : Œ± => addOrderOf a = d).card = totient d := by
  obtain ‚ü®g, hg‚ü© := id ‚ÄπIsAddCyclic Œ±‚Ä∫
  -- ‚ä¢ card (filter (fun a => addOrderOf a = d) univ) = œÜ d
  apply @IsCyclic.card_orderOf_eq_totient (Multiplicative Œ±) _ ‚ü®‚ü®g, hg‚ü©‚ü© (_) _ hd
  -- üéâ no goals
#align is_add_cyclic.card_order_of_eq_totient IsAddCyclic.card_orderOf_eq_totient

attribute [to_additive existing IsCyclic.card_orderOf_eq_totient]
  IsAddCyclic.card_orderOf_eq_totient

/-- A finite group of prime order is simple. -/
@[to_additive "A finite group of prime order is simple."]
theorem isSimpleGroup_of_prime_card {Œ± : Type u} [Group Œ±] [Fintype Œ±] {p : ‚Ñï} [hp : Fact p.Prime]
    (h : Fintype.card Œ± = p) : IsSimpleGroup Œ± :=
  have : Nontrivial Œ± := by
    have h' := Nat.Prime.one_lt (Fact.out (p := p.Prime))
    -- ‚ä¢ Nontrivial Œ±
    rw [‚Üê h] at h'
    -- ‚ä¢ Nontrivial Œ±
    exact Fintype.one_lt_card_iff_nontrivial.1 h'
    -- üéâ no goals
  ‚ü®fun H _ => by
    classical
      have hcard := card_subgroup_dvd_card H
      rw [h, dvd_prime (Fact.out (p := p.Prime))] at hcard
      refine' hcard.imp (fun h1 => _) fun hp => _
      ¬∑ haveI := Fintype.card_le_one_iff_subsingleton.1 (le_of_eq h1)
        apply eq_bot_of_subsingleton
      ¬∑ exact eq_top_of_card_eq _ (hp.trans h.symm)‚ü©
#align is_simple_group_of_prime_card isSimpleGroup_of_prime_card
#align is_simple_add_group_of_prime_card isSimpleAddGroup_of_prime_card

end Cyclic

section QuotientCenter

open Subgroup

variable {G : Type*} {H : Type*} [Group G] [Group H]

/-- A group is commutative if the quotient by the center is cyclic.
  Also see `commGroup_of_cycle_center_quotient` for the `CommGroup` instance. -/
@[to_additive commutative_of_add_cyclic_center_quotient
      "A group is commutative if the quotient by the center is cyclic.
      Also see `addCommGroup_of_cycle_center_quotient` for the `AddCommGroup` instance."]
theorem commutative_of_cyclic_center_quotient [IsCyclic H] (f : G ‚Üí* H) (hf : f.ker ‚â§ center G)
    (a b : G) : a * b = b * a :=
  let ‚ü®‚ü®x, y, (hxy : f y = x)‚ü©, (hx : ‚àÄ a : f.range, a ‚àà zpowers _)‚ü© :=
    IsCyclic.exists_generator (Œ± := f.range)
  let ‚ü®m, hm‚ü© := hx ‚ü®f a, a, rfl‚ü©
  let ‚ü®n, hn‚ü© := hx ‚ü®f b, b, rfl‚ü©
  have hm : x ^ m = f a := by simpa [Subtype.ext_iff] using hm
                              -- üéâ no goals
  have hn : x ^ n = f b := by simpa [Subtype.ext_iff] using hn
                              -- üéâ no goals
  have ha : y ^ (-m) * a ‚àà center G :=
    hf (by rw [f.mem_ker, f.map_mul, f.map_zpow, hxy, zpow_neg x m, hm, inv_mul_self])
           -- üéâ no goals
  have hb : y ^ (-n) * b ‚àà center G :=
    hf (by rw [f.mem_ker, f.map_mul, f.map_zpow, hxy, zpow_neg x n, hn, inv_mul_self])
           -- üéâ no goals
  calc
    a * b = y ^ m * (y ^ (-m) * a * y ^ n) * (y ^ (-n) * b) := by simp [mul_assoc]
                                                                  -- üéâ no goals
    _ = y ^ m * (y ^ n * (y ^ (-m) * a)) * (y ^ (-n) * b) := by rw [mem_center_iff.1 ha]
                                                                -- üéâ no goals
    _ = y ^ m * y ^ n * y ^ (-m) * (a * (y ^ (-n) * b)) := by simp [mul_assoc]
                                                              -- üéâ no goals
    _ = y ^ m * y ^ n * y ^ (-m) * (y ^ (-n) * b * a) := by rw [mem_center_iff.1 hb]
                                                            -- üéâ no goals
    _ = b * a := by group
                    -- üéâ no goals
#align commutative_of_cyclic_center_quotient commutative_of_cyclic_center_quotient
#align commutative_of_add_cyclic_center_quotient commutative_of_add_cyclic_center_quotient

/-- A group is commutative if the quotient by the center is cyclic. -/
@[to_additive commutativeOfAddCycleCenterQuotient
      "A group is commutative if the quotient by the center is cyclic."]
def commGroupOfCycleCenterQuotient [IsCyclic H] (f : G ‚Üí* H) (hf : f.ker ‚â§ center G) :
    CommGroup G :=
  { show Group G by infer_instance with mul_comm := commutative_of_cyclic_center_quotient f hf }
                    -- üéâ no goals
#align comm_group_of_cycle_center_quotient commGroupOfCycleCenterQuotient
#align commutative_of_add_cycle_center_quotient commutativeOfAddCycleCenterQuotient

end QuotientCenter

namespace IsSimpleGroup

section CommGroup

variable [CommGroup Œ±] [IsSimpleGroup Œ±]

@[to_additive IsSimpleAddGroup.isAddCyclic]
instance (priority := 100) isCyclic : IsCyclic Œ± := by
  cases' subsingleton_or_nontrivial Œ± with hi hi <;> haveI := hi
  -- ‚ä¢ IsCyclic Œ±
                                                     -- ‚ä¢ IsCyclic Œ±
                                                     -- ‚ä¢ IsCyclic Œ±
  ¬∑ apply isCyclic_of_subsingleton
    -- üéâ no goals
  ¬∑ obtain ‚ü®g, hg‚ü© := exists_ne (1 : Œ±)
    -- ‚ä¢ IsCyclic Œ±
    refine' ‚ü®‚ü®g, fun x => _‚ü©‚ü©
    -- ‚ä¢ x ‚àà Subgroup.zpowers g
    cases' IsSimpleOrder.eq_bot_or_eq_top (Subgroup.zpowers g) with hb ht
    -- ‚ä¢ x ‚àà Subgroup.zpowers g
    ¬∑ exfalso
      -- ‚ä¢ False
      apply hg
      -- ‚ä¢ g = 1
      rw [‚Üê Subgroup.mem_bot, ‚Üê hb]
      -- ‚ä¢ g ‚àà Subgroup.zpowers g
      apply Subgroup.mem_zpowers
      -- üéâ no goals
    ¬∑ rw [ht]
      -- ‚ä¢ x ‚àà ‚ä§
      apply Subgroup.mem_top
      -- üéâ no goals
#align is_simple_group.is_cyclic IsSimpleGroup.isCyclic
#align is_simple_add_group.is_add_cyclic IsSimpleAddGroup.isAddCyclic

@[to_additive]
theorem prime_card [Fintype Œ±] : (Fintype.card Œ±).Prime := by
  have h0 : 0 < Fintype.card Œ± := Fintype.card_pos_iff.2 (by infer_instance)
  -- ‚ä¢ Nat.Prime (Fintype.card Œ±)
  obtain ‚ü®g, hg‚ü© := IsCyclic.exists_generator (Œ± := Œ±)
  -- ‚ä¢ Nat.Prime (Fintype.card Œ±)
  rw [Nat.prime_def_lt'']
  -- ‚ä¢ 2 ‚â§ Fintype.card Œ± ‚àß ‚àÄ (m : ‚Ñï), m ‚à£ Fintype.card Œ± ‚Üí m = 1 ‚à® m = Fintype.car ‚Ä¶
  refine' ‚ü®Fintype.one_lt_card_iff_nontrivial.2 inferInstance, fun n hn => _‚ü©
  -- ‚ä¢ n = 1 ‚à® n = Fintype.card Œ±
  refine' (IsSimpleOrder.eq_bot_or_eq_top (Subgroup.zpowers (g ^ n))).symm.imp _ _
  -- ‚ä¢ Subgroup.zpowers (g ^ n) = ‚ä§ ‚Üí n = 1
  ¬∑ intro h
    -- ‚ä¢ n = 1
    have hgo := orderOf_pow (n := n) g
    -- ‚ä¢ n = 1
    rw [orderOf_eq_card_of_forall_mem_zpowers hg, Nat.gcd_eq_right_iff_dvd.1 hn,
      orderOf_eq_card_of_forall_mem_zpowers, eq_comm,
      Nat.div_eq_iff_eq_mul_left (Nat.pos_of_dvd_of_pos hn h0) hn] at hgo
    ¬∑ exact (mul_left_cancel‚ÇÄ (ne_of_gt h0) ((mul_one (Fintype.card Œ±)).trans hgo)).symm
      -- üéâ no goals
    ¬∑ intro x
      -- ‚ä¢ x ‚àà Subgroup.zpowers (g ^ n)
      rw [h]
      -- ‚ä¢ x ‚àà ‚ä§
      exact Subgroup.mem_top _
      -- üéâ no goals
  ¬∑ intro h
    -- ‚ä¢ n = Fintype.card Œ±
    apply le_antisymm (Nat.le_of_dvd h0 hn)
    -- ‚ä¢ Fintype.card Œ± ‚â§ n
    rw [‚Üê orderOf_eq_card_of_forall_mem_zpowers hg]
    -- ‚ä¢ orderOf g ‚â§ n
    apply orderOf_le_of_pow_eq_one (Nat.pos_of_dvd_of_pos hn h0)
    -- ‚ä¢ g ^ n = 1
    rw [‚Üê Subgroup.mem_bot, ‚Üê h]
    -- ‚ä¢ g ^ n ‚àà Subgroup.zpowers (g ^ n)
    exact Subgroup.mem_zpowers _
    -- üéâ no goals
#align is_simple_group.prime_card IsSimpleGroup.prime_card
#align is_simple_add_group.prime_card IsSimpleAddGroup.prime_card

end CommGroup

end IsSimpleGroup

@[to_additive AddCommGroup.is_simple_iff_isAddCyclic_and_prime_card]
theorem CommGroup.is_simple_iff_isCyclic_and_prime_card [Fintype Œ±] [CommGroup Œ±] :
    IsSimpleGroup Œ± ‚Üî IsCyclic Œ± ‚àß (Fintype.card Œ±).Prime := by
  constructor
  -- ‚ä¢ IsSimpleGroup Œ± ‚Üí IsCyclic Œ± ‚àß Nat.Prime (Fintype.card Œ±)
  ¬∑ intro h
    -- ‚ä¢ IsCyclic Œ± ‚àß Nat.Prime (Fintype.card Œ±)
    exact ‚ü®IsSimpleGroup.isCyclic, IsSimpleGroup.prime_card‚ü©
    -- üéâ no goals
  ¬∑ rintro ‚ü®_, hp‚ü©
    -- ‚ä¢ IsSimpleGroup Œ±
    haveI : Fact (Fintype.card Œ±).Prime := ‚ü®hp‚ü©
    -- ‚ä¢ IsSimpleGroup Œ±
    exact isSimpleGroup_of_prime_card rfl
    -- üéâ no goals
#align comm_group.is_simple_iff_is_cyclic_and_prime_card CommGroup.is_simple_iff_isCyclic_and_prime_card
#align add_comm_group.is_simple_iff_is_add_cyclic_and_prime_card AddCommGroup.is_simple_iff_isAddCyclic_and_prime_card

section Exponent

open Monoid

@[to_additive]
theorem IsCyclic.exponent_eq_card [Group Œ±] [IsCyclic Œ±] [Fintype Œ±] :
    exponent Œ± = Fintype.card Œ± := by
  obtain ‚ü®g, hg‚ü© := IsCyclic.exists_generator (Œ± := Œ±)
  -- ‚ä¢ exponent Œ± = Fintype.card Œ±
  apply Nat.dvd_antisymm
  -- ‚ä¢ exponent Œ± ‚à£ Fintype.card Œ±
  ¬∑ rw [‚Üê lcm_order_eq_exponent, Finset.lcm_dvd_iff]
    -- ‚ä¢ ‚àÄ (b : Œ±), b ‚àà Finset.univ ‚Üí orderOf b ‚à£ Fintype.card Œ±
    exact fun b _ => orderOf_dvd_card_univ
    -- üéâ no goals
  rw [‚Üê orderOf_eq_card_of_forall_mem_zpowers hg]
  -- ‚ä¢ orderOf g ‚à£ exponent Œ±
  exact order_dvd_exponent _
  -- üéâ no goals
#align is_cyclic.exponent_eq_card IsCyclic.exponent_eq_card
#align is_add_cyclic.exponent_eq_card IsAddCyclic.exponent_eq_card

@[to_additive]
theorem IsCyclic.of_exponent_eq_card [CommGroup Œ±] [Fintype Œ±] (h : exponent Œ± = Fintype.card Œ±) :
    IsCyclic Œ± :=
  let ‚ü®g, _, hg‚ü© := Finset.mem_image.mp (Finset.max'_mem _ _)
  isCyclic_of_orderOf_eq_card g <| hg.trans <| exponent_eq_max'_orderOf.symm.trans h
#align is_cyclic.of_exponent_eq_card IsCyclic.of_exponent_eq_card
#align is_add_cyclic.of_exponent_eq_card IsAddCyclic.of_exponent_eq_card

@[to_additive]
theorem IsCyclic.iff_exponent_eq_card [CommGroup Œ±] [Fintype Œ±] :
    IsCyclic Œ± ‚Üî exponent Œ± = Fintype.card Œ± :=
  ‚ü®fun _ => IsCyclic.exponent_eq_card, IsCyclic.of_exponent_eq_card‚ü©
#align is_cyclic.iff_exponent_eq_card IsCyclic.iff_exponent_eq_card
#align is_add_cyclic.iff_exponent_eq_card IsAddCyclic.iff_exponent_eq_card

@[to_additive]
theorem IsCyclic.exponent_eq_zero_of_infinite [Group Œ±] [IsCyclic Œ±] [Infinite Œ±] :
    exponent Œ± = 0 :=
  let ‚ü®_, hg‚ü© := IsCyclic.exists_generator (Œ± := Œ±)
  exponent_eq_zero_of_order_zero <| Infinite.orderOf_eq_zero_of_forall_mem_zpowers hg
#align is_cyclic.exponent_eq_zero_of_infinite IsCyclic.exponent_eq_zero_of_infinite
#align is_add_cyclic.exponent_eq_zero_of_infinite IsAddCyclic.exponent_eq_zero_of_infinite

end Exponent
