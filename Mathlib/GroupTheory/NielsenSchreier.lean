/-
Copyright (c) 2021 David WÃ¤rn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David WÃ¤rn
-/
import Mathlib.CategoryTheory.Action
import Mathlib.Combinatorics.Quiver.Arborescence
import Mathlib.Combinatorics.Quiver.ConnectedComponent
import Mathlib.GroupTheory.IsFreeGroup

#align_import group_theory.nielsen_schreier from "leanprover-community/mathlib"@"1bda4fc53de6ade5ab9da36f2192e24e2084a2ce"

/-!
# The Nielsen-Schreier theorem

This file proves that a subgroup of a free group is itself free.

## Main result

- `subgroupIsFreeOfIsFree H`: an instance saying that a subgroup of a free group is free.

## Proof overview

The proof is analogous to the proof using covering spaces and fundamental groups of graphs,
but we work directly with groupoids instead of topological spaces. Under this analogy,

- `IsFreeGroupoid G` corresponds to saying that a space is a graph.
- `endMulEquivSubgroup H` plays the role of replacing 'subgroup of fundamental group' with
  'fundamental group of covering space'.
- `actionGroupoidIsFree G A` corresponds to the fact that a covering of a (single-vertex)
  graph is a graph.
- `endIsFree T` corresponds to the fact that, given a spanning tree `T` of a
  graph, its fundamental group is free (generated by loops from the complement of the tree).

## Implementation notes

Our definition of `IsFreeGroupoid` is nonstandard. Normally one would require that functors
`G â¥¤ X` to any _groupoid_ `X` are given by graph homomorphisms from the generators, but we only
consider _groups_ `X`. This simplifies the argument since functor equality is complicated in
general, but simple for functors to single object categories.

## References

https://ncatlab.org/nlab/show/Nielsen-Schreier+theorem

## Tags

free group, free groupoid, Nielsen-Schreier

-/


noncomputable section

open Classical

universe v u

/- Porting note: ./././Mathport/Syntax/Translate/Command.lean:229:11:unsupported:
unusual advanced open style -/
open CategoryTheory CategoryTheory.ActionCategory CategoryTheory.SingleObj Quiver FreeGroup

/-- `IsFreeGroupoid.Generators G` is a type synonym for `G`. We think of this as
the vertices of the generating quiver of `G` when `G` is free. We can't use `G` directly,
since `G` already has a quiver instance from being a groupoid. -/
-- Porting note: @[nolint has_nonempty_instance]
@[nolint unusedArguments]
def IsFreeGroupoid.Generators (G) [Groupoid G] :=
  G
#align is_free_groupoid.generators IsFreeGroupoid.Generators

/-- A groupoid `G` is free when we have the following data:
 - a quiver on `IsFreeGroupoid.Generators G` (a type synonym for `G`)
 - a function `of` taking a generating arrow to a morphism in `G`
 - such that a functor from `G` to any group `X` is uniquely determined
   by assigning labels in `X` to the generating arrows.

   This definition is nonstandard. Normally one would require that functors `G â¥¤ X`
   to any _groupoid_ `X` are given by graph homomorphisms from `generators`. -/
class IsFreeGroupoid (G) [Groupoid.{v} G] where
  quiverGenerators : Quiver.{v + 1} (IsFreeGroupoid.Generators G)
  of : âˆ€ {a b : IsFreeGroupoid.Generators G}, (a âŸ¶ b) â†’ ((show G from a) âŸ¶ b)
  unique_lift :
    âˆ€ {X : Type v} [Group X] (f : Labelling (IsFreeGroupoid.Generators G) X),
      âˆƒ! F : G â¥¤ CategoryTheory.SingleObj X, âˆ€ (a b) (g : a âŸ¶ b), F.map (of g) = f g
#align is_free_groupoid IsFreeGroupoid

attribute [nolint docBlame] IsFreeGroupoid.of IsFreeGroupoid.unique_lift

namespace IsFreeGroupoid

attribute [instance] quiverGenerators

/-- Two functors from a free groupoid to a group are equal when they agree on the generating
quiver. -/
@[ext]
theorem ext_functor {G} [Groupoid.{v} G] [IsFreeGroupoid G] {X : Type v} [Group X]
    (f g : G â¥¤ CategoryTheory.SingleObj X) (h : âˆ€ (a b) (e : a âŸ¶ b), f.map (of e) = g.map (of e)) :
    f = g :=
  let âŸ¨_, _, uâŸ© := @unique_lift G _ _ X _ fun (a b : Generators G) (e : a âŸ¶ b) => g.map (of e)
  _root_.trans (u _ h) (u _ fun _ _ _ => rfl).symm
#align is_free_groupoid.ext_functor IsFreeGroupoid.ext_functor

/-- An action groupoid over a free group is free. More generally, one could show that the groupoid
of elements over a free groupoid is free, but this version is easier to prove and suffices for our
purposes.

Analogous to the fact that a covering space of a graph is a graph. (A free groupoid is like a graph,
and a groupoid of elements is like a covering space.) -/
instance actionGroupoidIsFree {G A : Type u} [Group G] [IsFreeGroup G] [MulAction G A] :
    IsFreeGroupoid (ActionCategory G A) where
  quiverGenerators :=
    âŸ¨fun a b => { e : IsFreeGroup.Generators G // IsFreeGroup.of e â€¢ a.back = b.back }âŸ©
  of := fun (e : { e // _}) => âŸ¨IsFreeGroup.of e, e.propertyâŸ©
  unique_lift := by
    intro X _ f
    -- âŠ¢ âˆƒ! F, âˆ€ (a b : Generators (ActionCategory G A)) (g : a âŸ¶ b), F.map ((fun {a  â€¦
    let f' : IsFreeGroup.Generators G â†’ (A â†’ X) â‹Š[mulAutArrow] G := fun e =>
      âŸ¨fun b => @f âŸ¨(), _âŸ© âŸ¨(), bâŸ© âŸ¨e, smul_inv_smul _ bâŸ©, IsFreeGroup.of eâŸ©
    rcases IsFreeGroup.unique_lift f' with âŸ¨F', hF', uF'âŸ©
    -- âŠ¢ âˆƒ! F, âˆ€ (a b : Generators (ActionCategory G A)) (g : a âŸ¶ b), F.map ((fun {a  â€¦
    refine' âŸ¨uncurry F' _, _, _âŸ©
    Â· suffices SemidirectProduct.rightHom.comp F' = MonoidHom.id _ by
        -- Porting note: `MonoidHom.ext_iff` has been deprecated.
        exact FunLike.ext_iff.mp this
      ext
      -- âŠ¢ â†‘(MonoidHom.comp SemidirectProduct.rightHom F') (IsFreeGroup.of aâœ) = â†‘(Mono â€¦
      rw [MonoidHom.comp_apply, hF']
      -- âŠ¢ â†‘SemidirectProduct.rightHom (f' aâœ) = â†‘(MonoidHom.id G) (IsFreeGroup.of aâœ)
      rfl
      -- ğŸ‰ no goals
    Â· rintro âŸ¨âŸ¨âŸ©, a : AâŸ© âŸ¨âŸ¨âŸ©, bâŸ© âŸ¨e, h : IsFreeGroup.of e â€¢ a = bâŸ©
      -- âŠ¢ (ActionCategory.uncurry F' (_ : âˆ€ (x : G), â†‘(MonoidHom.comp SemidirectProduc â€¦
      change (F' (IsFreeGroup.of _)).left _ = _
      -- âŠ¢ SemidirectProduct.left (â†‘F' (IsFreeGroup.of â†‘{ val := e, property := h })) ( â€¦
      rw [hF']
      -- âŠ¢ SemidirectProduct.left (f' â†‘{ val := e, property := h }) (ActionCategory.bac â€¦
      cases inv_smul_eq_iff.mpr h.symm
      -- âŠ¢ SemidirectProduct.left (f' â†‘{ val := e, property := h }) (ActionCategory.bac â€¦
      rfl
      -- ğŸ‰ no goals
    Â· intro E hE
      -- âŠ¢ E = ActionCategory.uncurry F' (_ : âˆ€ (x : G), â†‘(MonoidHom.comp SemidirectPro â€¦
      have : curry E = F' := by
        apply uF'
        intro e
        ext
        Â· convert hE _ _ _
          rfl
        Â· rfl
      apply Functor.hext
      -- âŠ¢ âˆ€ (X_1 : ActionCategory G A), E.obj X_1 = (ActionCategory.uncurry F' (_ : âˆ€  â€¦
      Â· intro
        -- âŠ¢ E.obj Xâœ = (ActionCategory.uncurry F' (_ : âˆ€ (x : G), â†‘(MonoidHom.comp Semid â€¦
        apply Unit.ext
        -- ğŸ‰ no goals
      Â· refine' ActionCategory.cases _
        -- âŠ¢ âˆ€ (t : A) (g : G), HEq (E.map (homOfPair t g)) ((ActionCategory.uncurry F' ( â€¦
        intros
        -- âŠ¢ HEq (E.map (homOfPair tâœ gâœ)) ((ActionCategory.uncurry F' (_ : âˆ€ (x : G), â†‘( â€¦
        simp only [â† this, uncurry_map, curry_apply_left, coe_back, homOfPair.val]
        -- âŠ¢ HEq (E.map (homOfPair tâœ gâœ)) (E.map (homOfPair tâœ gâœ))
        rfl
        -- ğŸ‰ no goals
#align is_free_groupoid.action_groupoid_is_free IsFreeGroupoid.actionGroupoidIsFree

namespace SpanningTree

/- In this section, we suppose we have a free groupoid with a spanning tree for its generating
quiver. The goal is to prove that the vertex group at the root is free. A picture to have in mind
is that we are 'pulling' the endpoints of all the edges of the quiver along the spanning tree to
the root. -/
variable {G : Type u} [Groupoid.{u} G] [IsFreeGroupoid G]
  (T : WideSubquiver (Symmetrify <| Generators G)) [Arborescence T]

/-- The root of `T`, except its type is `G` instead of the type synonym `T`. -/
private def root' : G :=
  show T from root T
-- #align is_free_groupoid.spanning_tree.root' IsFreeGroupoid.SpanningTree.root'

-- this has to be marked noncomputable, see issue #451.
-- It might be nicer to define this in terms of `composePath`
/-- A path in the tree gives a hom, by composition. -/
-- Porting note: removed noncomputable. This is already declared at the beginning of the section.
def homOfPath : âˆ€ {a : G}, Path (root T) a â†’ (root' T âŸ¶ a)
  | _, Path.nil => ğŸ™ _
  | _, Path.cons p f => homOfPath p â‰« Sum.recOn f.val (fun e => of e) fun e => inv (of e)
#align is_free_groupoid.spanning_tree.hom_of_path IsFreeGroupoid.SpanningTree.homOfPath

/-- For every vertex `a`, there is a canonical hom from the root, given by the path in the tree. -/
def treeHom (a : G) : root' T âŸ¶ a :=
  homOfPath T default
#align is_free_groupoid.spanning_tree.tree_hom IsFreeGroupoid.SpanningTree.treeHom

/-- Any path to `a` gives `treeHom T a`, since paths in the tree are unique. -/
theorem treeHom_eq {a : G} (p : Path (root T) a) : treeHom T a = homOfPath T p := by
  rw [treeHom, Unique.default_eq]
  -- ğŸ‰ no goals
#align is_free_groupoid.spanning_tree.tree_hom_eq IsFreeGroupoid.SpanningTree.treeHom_eq

@[simp]
theorem treeHom_root : treeHom T (root' T) = ğŸ™ _ :=
  -- this should just be `treeHom_eq T Path.nil`, but Lean treats `homOfPath` with suspicion.
    _root_.trans
    (treeHom_eq T Path.nil) rfl
#align is_free_groupoid.spanning_tree.tree_hom_root IsFreeGroupoid.SpanningTree.treeHom_root

/-- Any hom in `G` can be made into a loop, by conjugating with `treeHom`s. -/
def loopOfHom {a b : G} (p : a âŸ¶ b) : End (root' T) :=
  treeHom T a â‰« p â‰« inv (treeHom T b)
#align is_free_groupoid.spanning_tree.loop_of_hom IsFreeGroupoid.SpanningTree.loopOfHom

/-- Turning an edge in the spanning tree into a loop gives the identity loop. -/
theorem loopOfHom_eq_id {a b : Generators G} (e) (H : e âˆˆ wideSubquiverSymmetrify T a b) :
    loopOfHom T (of e) = ğŸ™ (root' T) := by
  rw [loopOfHom, â† Category.assoc, IsIso.comp_inv_eq, Category.id_comp]
  -- âŠ¢ treeHom T
  cases' H with H H
  Â· rw [treeHom_eq T (Path.cons default âŸ¨Sum.inl e, HâŸ©), homOfPath]
    -- âŠ¢ treeHom T
    rfl
    -- ğŸ‰ no goals
  Â· rw [treeHom_eq T (Path.cons default âŸ¨Sum.inr e, HâŸ©), homOfPath]
    -- âŠ¢ (homOfPath T default â‰« Sum.recOn (â†‘{ val := Sum.inr e, property := H }) (fun â€¦
    simp only [IsIso.inv_hom_id, Category.comp_id, Category.assoc, treeHom]
    -- ğŸ‰ no goals
#align is_free_groupoid.spanning_tree.loop_of_hom_eq_id IsFreeGroupoid.SpanningTree.loopOfHom_eq_id

/-- Since a hom gives a loop, any homomorphism from the vertex group at the root
    extends to a functor on the whole groupoid. -/
@[simps]
def functorOfMonoidHom {X} [Monoid X] (f : End (root' T) â†’* X) : G â¥¤ CategoryTheory.SingleObj X
    where
  obj _ := ()
  map p := f (loopOfHom T p)
  map_id := by
    intro a
    -- âŠ¢ { obj := fun x => (), map := fun {X_1 Y} p => â†‘f (loopOfHom T p) }.map (ğŸ™ a) â€¦
    dsimp only [loopOfHom]
    -- âŠ¢ â†‘f (treeHom T a â‰« ğŸ™ a â‰« inv (treeHom T a)) = ğŸ™ ()
    rw [Category.id_comp, IsIso.hom_inv_id, â† End.one_def, f.map_one, id_as_one]
    -- ğŸ‰ no goals
  map_comp := by
    intros
    -- âŠ¢ { obj := fun x => (), map := fun {X_1 Y} p => â†‘f (loopOfHom T p) }.map (fâœ â‰« â€¦
    rw [comp_as_mul, â† f.map_mul]
    -- âŠ¢ { obj := fun x => (), map := fun {X_1 Y} p => â†‘f (loopOfHom T p) }.map (fâœ â‰« â€¦
    simp only [IsIso.inv_hom_id_assoc, loopOfHom, End.mul_def, Category.assoc]
    -- ğŸ‰ no goals
#align is_free_groupoid.spanning_tree.functor_of_monoid_hom IsFreeGroupoid.SpanningTree.functorOfMonoidHom

/-- Given a free groupoid and an arborescence of its generating quiver, the vertex
    group at the root is freely generated by loops coming from generating arrows
    in the complement of the tree. -/
def endIsFree : IsFreeGroup (End (root' T)) :=
  IsFreeGroup.ofUniqueLift ((wideSubquiverEquivSetTotal <| wideSubquiverSymmetrify T)á¶œ : Set _)
    (fun e => loopOfHom T (of e.val.hom))
    (by
      intro X _ f
      -- âŠ¢ âˆƒ! F, âˆ€ (a : â†‘(â†‘wideSubquiverEquivSetTotal (wideSubquiverSymmetrify T))á¶œ), â†‘ â€¦
      let f' : Labelling (Generators G) X := fun a b e =>
        if h : e âˆˆ wideSubquiverSymmetrify T a b then 1 else f âŸ¨âŸ¨a, b, eâŸ©, hâŸ©
      rcases unique_lift f' with âŸ¨F', hF', uF'âŸ©
      -- âŠ¢ âˆƒ! F, âˆ€ (a : â†‘(â†‘wideSubquiverEquivSetTotal (wideSubquiverSymmetrify T))á¶œ), â†‘ â€¦
      refine' âŸ¨F'.mapEnd _, _, _âŸ©
      -- âŠ¢ (fun F => âˆ€ (a : â†‘(â†‘wideSubquiverEquivSetTotal (wideSubquiverSymmetrify T))á¶œ â€¦
      Â· suffices âˆ€ {x y} (q : x âŸ¶ y), F'.map (loopOfHom T q) = (F'.map q : X) by
          rintro âŸ¨âŸ¨a, b, eâŸ©, hâŸ©
          erw [Functor.mapEnd_apply, this, hF']
          exact dif_neg h
        intros x y q
        -- âŠ¢ F'.map (loopOfHom T q) = F'.map q
        suffices âˆ€ {a} (p : Path (root T) a), F'.map (homOfPath T p) = 1 by
          simp only [this, treeHom, comp_as_mul, inv_as_inv, loopOfHom, inv_one, mul_one,
            one_mul, Functor.map_inv, Functor.map_comp]
        intro a p
        -- âŠ¢ F'.map (homOfPath T p) = 1
        induction' p with b c p e ih
        -- âŠ¢ F'.map (homOfPath T Path.nil) = 1
        Â· rw [homOfPath, F'.map_id, id_as_one]
          -- ğŸ‰ no goals
        rw [homOfPath, F'.map_comp, comp_as_mul, ih, mul_one]
        -- âŠ¢ F'.map (Sum.recOn (â†‘e) (fun e => of e) fun e => inv (of e)) = 1
        rcases e with âŸ¨e | e, eTâŸ©
        -- âŠ¢ F'.map (Sum.recOn (â†‘{ val := Sum.inl e, property := eT }) (fun e => of e) fu â€¦
        Â· rw [hF']
          -- âŠ¢ f' e = 1
          exact dif_pos (Or.inl eT)
          -- ğŸ‰ no goals
        Â· rw [F'.map_inv, inv_as_inv, inv_eq_one, hF']
          -- âŠ¢ f' e = 1
          exact dif_pos (Or.inr eT)
          -- ğŸ‰ no goals
      Â· intro E hE
        -- âŠ¢ E = Functor.mapEnd (IsFreeGroupoid.SpanningTree.root' T) F'
        ext x
        -- âŠ¢ â†‘E x = â†‘(Functor.mapEnd (IsFreeGroupoid.SpanningTree.root' T) F') x
        suffices (functorOfMonoidHom T E).map x = F'.map x by
          simpa only [loopOfHom, functorOfMonoidHom, IsIso.inv_id, treeHom_root,
            Category.id_comp, Category.comp_id] using this
        congr
        -- âŠ¢ functorOfMonoidHom T E = F'
        apply uF'
        -- âŠ¢ âˆ€ (a b : Generators G) (g : a âŸ¶ b), (functorOfMonoidHom T E).map (of g) = f' g
        intro a b e
        -- âŠ¢ (functorOfMonoidHom T E).map (of e) = f' e
        change E (loopOfHom T _) = dite _ _ _
        -- âŠ¢ â†‘E (loopOfHom T (of e)) = if h : e âˆˆ wideSubquiverSymmetrify T a b then 1 el â€¦
        split_ifs with h
        -- âŠ¢ â†‘E (loopOfHom T (of e)) = 1
        Â· rw [loopOfHom_eq_id T e h, â† End.one_def, E.map_one]
          -- ğŸ‰ no goals
        Â· exact hE âŸ¨âŸ¨a, b, eâŸ©, hâŸ©)
          -- ğŸ‰ no goals
#align is_free_groupoid.spanning_tree.End_is_free IsFreeGroupoid.SpanningTree.endIsFree

end SpanningTree

/-- Another name for the identity function `G â†’ G`, to help type checking. -/
private def symgen {G : Type u} [Groupoid.{v} G] [IsFreeGroupoid G] :
    G â†’ Symmetrify (Generators G) :=
  id
-- #align is_free_groupoid.symgen IsFreeGroupoid.symgen

/-- If there exists a morphism `a â†’ b` in a free groupoid, then there also exists a zigzag
from `a` to `b` in the generating quiver. -/
theorem path_nonempty_of_hom {G} [Groupoid.{u, u} G] [IsFreeGroupoid G] {a b : G} :
    Nonempty (a âŸ¶ b) â†’ Nonempty (Path (symgen a) (symgen b)) := by
  rintro âŸ¨pâŸ©
  -- âŠ¢ Nonempty (Path (IsFreeGroupoid.symgen a) (IsFreeGroupoid.symgen b))
  rw [â† @WeaklyConnectedComponent.eq (Generators G), eq_comm, â† FreeGroup.of_injective.eq_iff, â†
    mul_inv_eq_one]
  let X := FreeGroup (WeaklyConnectedComponent <| Generators G)
  -- âŠ¢ FreeGroup.of (WeaklyConnectedComponent.mk (IsFreeGroupoid.symgen b)) * (Free â€¦
  let f : G â†’ X := fun g => FreeGroup.of (WeaklyConnectedComponent.mk g)
  -- âŠ¢ FreeGroup.of (WeaklyConnectedComponent.mk (IsFreeGroupoid.symgen b)) * (Free â€¦
  let F : G â¥¤ CategoryTheory.SingleObj.{u} (X : Type u) := SingleObj.differenceFunctor f
  -- âŠ¢ FreeGroup.of (WeaklyConnectedComponent.mk (IsFreeGroupoid.symgen b)) * (Free â€¦
  change (F.map p) = ((@CategoryTheory.Functor.const G _ _ (SingleObj.category X)).obj ()).map p
  -- âŠ¢ F.map p = ((Functor.const G).obj ()).map p
  congr; ext
  -- âŠ¢ F = (Functor.const G).obj ()
         -- âŠ¢ F.map (of eâœ) = ((Functor.const G).obj ()).map (of eâœ)
  rw [Functor.const_obj_map, id_as_one, differenceFunctor_map, @mul_inv_eq_one _ _ (f _)]
  -- âŠ¢ f bâœ =
  apply congr_arg FreeGroup.of
  -- âŠ¢ WeaklyConnectedComponent.mk bâœ =
  apply (WeaklyConnectedComponent.eq _ _).mpr
  -- âŠ¢ Nonempty
  exact âŸ¨Hom.toPath (Sum.inr (by assumption))âŸ©
  -- ğŸ‰ no goals
#align is_free_groupoid.path_nonempty_of_hom IsFreeGroupoid.path_nonempty_of_hom

/-- Given a connected free groupoid, its generating quiver is rooted-connected. -/
instance generators_connected (G) [Groupoid.{u, u} G] [IsConnected G] [IsFreeGroupoid G] (r : G) :
    RootedConnected (symgen r) :=
  âŸ¨fun b => path_nonempty_of_hom (CategoryTheory.nonempty_hom_of_connected_groupoid r b)âŸ©
#align is_free_groupoid.generators_connected IsFreeGroupoid.generators_connected

/-- A vertex group in a free connected groupoid is free. With some work one could drop the
connectedness assumption, by looking at connected components. -/
instance endIsFreeOfConnectedFree {G} [Groupoid G] [IsConnected G] [IsFreeGroupoid G] (r : G) :
    IsFreeGroup (End r) :=
  SpanningTree.endIsFree <| geodesicSubtree (symgen r)
#align is_free_groupoid.End_is_free_of_connected_free IsFreeGroupoid.endIsFreeOfConnectedFree

end IsFreeGroupoid

/-- The Nielsen-Schreier theorem: a subgroup of a free group is free. -/
instance subgroupIsFreeOfIsFree {G : Type u} [Group G] [IsFreeGroup G] (H : Subgroup G) :
    IsFreeGroup H :=
  IsFreeGroup.ofMulEquiv (endMulEquivSubgroup H)
#align subgroup_is_free_of_is_free subgroupIsFreeOfIsFree
