diff --git a/Mathlib/CategoryTheory/Closed/PowerObjects.lean b/Mathlib/CategoryTheory/Closed/PowerObjects.lean
index f256701817..21cb5732e6 100644
--- a/Mathlib/CategoryTheory/Closed/PowerObjects.lean
+++ b/Mathlib/CategoryTheory/Closed/PowerObjects.lean
@@ -25,35 +25,43 @@ variable {â„° : Type u} [Category.{v} â„°]
 
 namespace LeftRepresentable
 
-variable {F : â„°áµ’áµ– Ã— â„°áµ’áµ– â¥¤ Type (max u v)}
+variable (F : (â„° Ã— â„°)áµ’áµ– â¥¤ Type (max u v))
 
-variable {B PB : â„°} (hPB : ((curryObj F).obj (op B)).RepresentableBy PB)
-  {C PC : â„°} (hPC : ((curryObj F).obj (op C)).RepresentableBy PC)
+def curryObj' : â„°áµ’áµ– â¥¤ â„°áµ’áµ– â¥¤ Type (max u v) := curryObj ((prodOpEquiv â„°).inverse â‹™ F)
+
+variable {F} {B PB : â„°} (hPB : ((curryObj' F).obj (op B)).RepresentableBy PB)
+  {C PC : â„°} (hPC : ((curryObj' F).obj (op C)).RepresentableBy PC)
 
 /-- The morphism induced by a morphism between the base objects. -/
-def map (h : B âŸ¶ C) : PC âŸ¶ PB :=
-  hPB.homEquiv.symm (F.map (h.op Ã—â‚˜ ğŸ™ (op PC)) (hPC.homEquiv (ğŸ™ PC)))
+def Pmap (h : B âŸ¶ C) : PC âŸ¶ PB :=
+  hPB.homEquiv.symm (F.map (h Ã—â‚˜ ğŸ™ PC).op (hPC.homEquiv (ğŸ™ PC)))
 
 lemma map_universal (h : B âŸ¶ C) :
-  F.map (ğŸ™ (op B) Ã—â‚˜ (map hPB hPC h).op) (hPB.homEquiv (ğŸ™ PB))
-    = F.map (h.op Ã—â‚˜ ğŸ™ (op PC)) (hPC.homEquiv (ğŸ™ PC)) := by
+  F.map (ğŸ™ B Ã—â‚˜ (Pmap hPB hPC h)).op (hPB.homEquiv (ğŸ™ PB))
+    = F.map (h Ã—â‚˜ ğŸ™ PC).op (hPC.homEquiv (ğŸ™ PC)) := by
   calc
-    _ = ((curryObj F).obj (op B)).map (map hPB hPC h).op (hPB.homEquiv (ğŸ™ PB)) := by rfl
-    _ = F.map (h.op Ã—â‚˜ ğŸ™ (op PC)) (hPC.homEquiv (ğŸ™ PC)) := by
-      rw [â† hPB.homEquiv_eq, map, hPB.homEquiv.apply_symm_apply]
+    _ = ((curryObj' F).obj (op B)).map (Pmap hPB hPC h).op (hPB.homEquiv (ğŸ™ PB)) := by rfl
+    _ = F.map (h Ã—â‚˜ ğŸ™ PC).op (hPC.homEquiv (ğŸ™ PC)) := by
+      rw [â† hPB.homEquiv_eq, Pmap, hPB.homEquiv.apply_symm_apply]
+
+variable {D PD : â„°} (hPD : ((curryObj' F).obj (op D)).RepresentableBy PD)
 
-variable {D PD : â„°} (hPD : ((curryObj F).obj (op D)).RepresentableBy PD)
+lemma comm {PB PC : â„°} (f : B âŸ¶ C) (Pf : PC âŸ¶ PB) :
+    (f Ã—â‚˜ ğŸ™ PB).op â‰« (ğŸ™ B Ã—â‚˜ Pf).op = (ğŸ™ C Ã—â‚˜ Pf).op â‰« (f Ã—â‚˜ ğŸ™ PC).op :=
+  congrArg Quiver.Hom.op (by simp)
 
 lemma compose (h : B âŸ¶ C) (h' : C âŸ¶ D) :
-    map hPB hPD (h â‰« h') = map hPC hPD h' â‰« map hPB hPC h := by
-  let Ph := map hPB hPC h
-  let Ph' := map hPC hPD h'
+    Pmap hPB hPD (h â‰« h') = Pmap hPC hPD h' â‰« Pmap hPB hPC h := by
+  let F' := (prodOpEquiv â„°).inverse â‹™ F
+  let Ph := Pmap hPB hPC h
+  let Ph' := Pmap hPC hPD h'
   apply hPB.homEquiv.injective
   calc
-    _ = F.map ((h'.op Ã—â‚˜ ğŸ™ _) â‰« (h.op Ã—â‚˜ ğŸ™ _)) (hPD.homEquiv (ğŸ™ PD)) := by unfold map; simp
-    _ = F.map ((ğŸ™ _ Ã—â‚˜ Ph'.op) â‰« (h.op Ã—â‚˜ ğŸ™ _)) (hPC.homEquiv (ğŸ™ PC)) := by
+    _ = F.map ((h Ã—â‚˜ ğŸ™ _) â‰« (h' Ã—â‚˜ ğŸ™ _)).op (hPD.homEquiv (ğŸ™ PD)) := by unfold Pmap; simp
+    _ = F.map ((h' Ã—â‚˜ ğŸ™ _).op â‰« (h Ã—â‚˜ ğŸ™ _).op) (hPD.homEquiv (ğŸ™ PD)) := by rw[op_comp]
+    _ = F.map ((ğŸ™ _ Ã—â‚˜ Ph').op â‰« (h Ã—â‚˜ ğŸ™ _).op) (hPC.homEquiv (ğŸ™ PC)) := by
       rw[FunctorToTypes.map_comp_apply, â† map_universal, â† FunctorToTypes.map_comp_apply]
-    _ = F.map ((h.op Ã—â‚˜ ğŸ™ _) â‰« (ğŸ™ _ Ã—â‚˜ Ph'.op)) (hPC.homEquiv (ğŸ™ PC)) := by simp
+    _ = F.map ((h Ã—â‚˜ ğŸ™ _).op â‰« (ğŸ™ _ Ã—â‚˜ Ph').op) (hPC.homEquiv (ğŸ™ PC)) := by simp
     _ = F.map ((ğŸ™ _ Ã—â‚˜ Ph.op) â‰« (ğŸ™ _ Ã—â‚˜ Ph'.op)) (hPB.homEquiv (ğŸ™ PB)) := by
       rw[FunctorToTypes.map_comp_apply, â† map_universal, â† FunctorToTypes.map_comp_apply]
     _ = (F.curryObj.obj _).map (Ph' â‰« Ph).op (hPB.homEquiv (ğŸ™ PB)) := by
