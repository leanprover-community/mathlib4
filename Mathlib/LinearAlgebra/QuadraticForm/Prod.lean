/-
Copyright (c) 2021 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser
-/
import Mathlib.LinearAlgebra.QuadraticForm.IsometryEquiv

#align_import linear_algebra.quadratic_form.prod from "leanprover-community/mathlib"@"9b2755b951bc323c962bd072cd447b375cf58101"

/-! # Quadratic form on product and pi types

## Main definitions

* `QuadraticForm.prod Qâ‚ Qâ‚‚`: the quadratic form constructed elementwise on a product
* `QuadraticForm.pi Q`: the quadratic form constructed elementwise on a pi type

## Main results

* `QuadraticForm.Equivalent.prod`, `QuadraticForm.Equivalent.pi`: quadratic forms are equivalent
  if their components are equivalent
* `QuadraticForm.nonneg_prod_iff`, `QuadraticForm.nonneg_pi_iff`: quadratic forms are positive-
  semidefinite if and only if their components are positive-semidefinite.
* `QuadraticForm.posDef_prod_iff`, `QuadraticForm.posDef_pi_iff`: quadratic forms are positive-
  definite if and only if their components are positive-definite.

## Implementation notes

Many of the lemmas in this file could be generalized into results about sums of positive and
non-negative elements, and would generalize to any map `Q` where `Q 0 = 0`, not just quadratic
forms specifically.

-/


universe u v w

variable {Î¹ : Type*} {R : Type*} {Mâ‚ Mâ‚‚ Nâ‚ Nâ‚‚ : Type*} {Máµ¢ Náµ¢ : Î¹ â†’ Type*}

variable [Semiring R]

variable [AddCommMonoid Mâ‚] [AddCommMonoid Mâ‚‚] [AddCommMonoid Nâ‚] [AddCommMonoid Nâ‚‚]

variable [Module R Mâ‚] [Module R Mâ‚‚] [Module R Nâ‚] [Module R Nâ‚‚]

variable [âˆ€ i, AddCommMonoid (Máµ¢ i)] [âˆ€ i, AddCommMonoid (Náµ¢ i)]

variable [âˆ€ i, Module R (Máµ¢ i)] [âˆ€ i, Module R (Náµ¢ i)]

namespace QuadraticForm

/-- Construct a quadratic form on a product of two modules from the quadratic form on each module.
-/
@[simps!]
def prod (Qâ‚ : QuadraticForm R Mâ‚) (Qâ‚‚ : QuadraticForm R Mâ‚‚) : QuadraticForm R (Mâ‚ Ã— Mâ‚‚) :=
  Qâ‚.comp (LinearMap.fst _ _ _) + Qâ‚‚.comp (LinearMap.snd _ _ _)
#align quadratic_form.prod QuadraticForm.prod

/-- An isometry between quadratic forms generated by `QuadraticForm.prod` can be constructed
from a pair of isometries between the left and right parts. -/
@[simps toLinearEquiv]
def IsometryEquiv.prod
    {Qâ‚ : QuadraticForm R Mâ‚} {Qâ‚‚ : QuadraticForm R Mâ‚‚}
    {Qâ‚' : QuadraticForm R Nâ‚} {Qâ‚‚' : QuadraticForm R Nâ‚‚}
    (eâ‚ : Qâ‚.IsometryEquiv Qâ‚') (eâ‚‚ : Qâ‚‚.IsometryEquiv Qâ‚‚') :
    (Qâ‚.prod Qâ‚‚).IsometryEquiv (Qâ‚'.prod Qâ‚‚') where
  map_app' x := congr_argâ‚‚ (Â· + Â·) (eâ‚.map_app x.1) (eâ‚‚.map_app x.2)
  toLinearEquiv := LinearEquiv.prod eâ‚.toLinearEquiv eâ‚‚.toLinearEquiv
#align quadratic_form.isometry.prod QuadraticForm.IsometryEquiv.prod

theorem Equivalent.prod {Qâ‚ : QuadraticForm R Mâ‚} {Qâ‚‚ : QuadraticForm R Mâ‚‚}
    {Qâ‚' : QuadraticForm R Nâ‚} {Qâ‚‚' : QuadraticForm R Nâ‚‚} (eâ‚ : Qâ‚.Equivalent Qâ‚')
    (eâ‚‚ : Qâ‚‚.Equivalent Qâ‚‚') : (Qâ‚.prod Qâ‚‚).Equivalent (Qâ‚'.prod Qâ‚‚') :=
  Nonempty.map2 IsometryEquiv.prod eâ‚ eâ‚‚
#align quadratic_form.equivalent.prod QuadraticForm.Equivalent.prod

/-- If a product is anisotropic then its components must be. The converse is not true. -/
theorem anisotropic_of_prod {R} [OrderedRing R] [Module R Mâ‚] [Module R Mâ‚‚]
    {Qâ‚ : QuadraticForm R Mâ‚} {Qâ‚‚ : QuadraticForm R Mâ‚‚} (h : (Qâ‚.prod Qâ‚‚).Anisotropic) :
    Qâ‚.Anisotropic âˆ§ Qâ‚‚.Anisotropic := by
  simp_rw [Anisotropic, prod_apply, Prod.forall, Prod.mk_eq_zero] at h
  -- âŠ¢ Anisotropic Qâ‚ âˆ§ Anisotropic Qâ‚‚
  constructor
  -- âŠ¢ Anisotropic Qâ‚
  Â· intro x hx
    -- âŠ¢ x = 0
    refine' (h x 0 _).1
    -- âŠ¢ â†‘Qâ‚ x + â†‘Qâ‚‚ 0 = 0
    rw [hx, zero_add, map_zero]
    -- ðŸŽ‰ no goals
  Â· intro x hx
    -- âŠ¢ x = 0
    refine' (h 0 x _).2
    -- âŠ¢ â†‘Qâ‚ 0 + â†‘Qâ‚‚ x = 0
    rw [hx, add_zero, map_zero]
    -- ðŸŽ‰ no goals
#align quadratic_form.anisotropic_of_prod QuadraticForm.anisotropic_of_prod

theorem nonneg_prod_iff {R} [OrderedRing R] [Module R Mâ‚] [Module R Mâ‚‚] {Qâ‚ : QuadraticForm R Mâ‚}
    {Qâ‚‚ : QuadraticForm R Mâ‚‚} : (âˆ€ x, 0 â‰¤ (Qâ‚.prod Qâ‚‚) x) â†” (âˆ€ x, 0 â‰¤ Qâ‚ x) âˆ§ âˆ€ x, 0 â‰¤ Qâ‚‚ x := by
  simp_rw [Prod.forall, prod_apply]
  -- âŠ¢ (âˆ€ (a : Mâ‚) (b : Mâ‚‚), 0 â‰¤ â†‘Qâ‚ a + â†‘Qâ‚‚ b) â†” (âˆ€ (x : Mâ‚), 0 â‰¤ â†‘Qâ‚ x) âˆ§ âˆ€ (x :  â€¦
  constructor
  -- âŠ¢ (âˆ€ (a : Mâ‚) (b : Mâ‚‚), 0 â‰¤ â†‘Qâ‚ a + â†‘Qâ‚‚ b) â†’ (âˆ€ (x : Mâ‚), 0 â‰¤ â†‘Qâ‚ x) âˆ§ âˆ€ (x :  â€¦
  Â· intro h
    -- âŠ¢ (âˆ€ (x : Mâ‚), 0 â‰¤ â†‘Qâ‚ x) âˆ§ âˆ€ (x : Mâ‚‚), 0 â‰¤ â†‘Qâ‚‚ x
    constructor
    -- âŠ¢ âˆ€ (x : Mâ‚), 0 â‰¤ â†‘Qâ‚ x
    Â· intro x; simpa only [add_zero, map_zero] using h x 0
      -- âŠ¢ 0 â‰¤ â†‘Qâ‚ x
               -- ðŸŽ‰ no goals
    Â· intro x; simpa only [zero_add, map_zero] using h 0 x
      -- âŠ¢ 0 â‰¤ â†‘Qâ‚‚ x
               -- ðŸŽ‰ no goals
  Â· rintro âŸ¨hâ‚, hâ‚‚âŸ© xâ‚ xâ‚‚
    -- âŠ¢ 0 â‰¤ â†‘Qâ‚ xâ‚ + â†‘Qâ‚‚ xâ‚‚
    exact add_nonneg (hâ‚ xâ‚) (hâ‚‚ xâ‚‚)
    -- ðŸŽ‰ no goals
#align quadratic_form.nonneg_prod_iff QuadraticForm.nonneg_prod_iff

theorem posDef_prod_iff {R} [OrderedRing R] [Module R Mâ‚] [Module R Mâ‚‚] {Qâ‚ : QuadraticForm R Mâ‚}
    {Qâ‚‚ : QuadraticForm R Mâ‚‚} : (Qâ‚.prod Qâ‚‚).PosDef â†” Qâ‚.PosDef âˆ§ Qâ‚‚.PosDef := by
  simp_rw [posDef_iff_nonneg, nonneg_prod_iff]
  -- âŠ¢ ((âˆ€ (x : Mâ‚), 0 â‰¤ â†‘Qâ‚ x) âˆ§ âˆ€ (x : Mâ‚‚), 0 â‰¤ â†‘Qâ‚‚ x) âˆ§ Anisotropic (prod Qâ‚ Qâ‚‚) â€¦
  constructor
  -- âŠ¢ ((âˆ€ (x : Mâ‚), 0 â‰¤ â†‘Qâ‚ x) âˆ§ âˆ€ (x : Mâ‚‚), 0 â‰¤ â†‘Qâ‚‚ x) âˆ§ Anisotropic (prod Qâ‚ Qâ‚‚) â€¦
  Â· rintro âŸ¨âŸ¨hleâ‚, hleâ‚‚âŸ©, haâŸ©
    -- âŠ¢ ((âˆ€ (x : Mâ‚), 0 â‰¤ â†‘Qâ‚ x) âˆ§ Anisotropic Qâ‚) âˆ§ (âˆ€ (x : Mâ‚‚), 0 â‰¤ â†‘Qâ‚‚ x) âˆ§ Aniso â€¦
    obtain âŸ¨haâ‚, haâ‚‚âŸ© := anisotropic_of_prod ha
    -- âŠ¢ ((âˆ€ (x : Mâ‚), 0 â‰¤ â†‘Qâ‚ x) âˆ§ Anisotropic Qâ‚) âˆ§ (âˆ€ (x : Mâ‚‚), 0 â‰¤ â†‘Qâ‚‚ x) âˆ§ Aniso â€¦
    refine' âŸ¨âŸ¨hleâ‚, haâ‚âŸ©, âŸ¨hleâ‚‚, haâ‚‚âŸ©âŸ©
    -- ðŸŽ‰ no goals
  Â· rintro âŸ¨âŸ¨hleâ‚, haâ‚âŸ©, âŸ¨hleâ‚‚, haâ‚‚âŸ©âŸ©
    -- âŠ¢ ((âˆ€ (x : Mâ‚), 0 â‰¤ â†‘Qâ‚ x) âˆ§ âˆ€ (x : Mâ‚‚), 0 â‰¤ â†‘Qâ‚‚ x) âˆ§ Anisotropic (prod Qâ‚ Qâ‚‚)
    refine' âŸ¨âŸ¨hleâ‚, hleâ‚‚âŸ©, _âŸ©
    -- âŠ¢ Anisotropic (prod Qâ‚ Qâ‚‚)
    rintro âŸ¨xâ‚, xâ‚‚âŸ© (hx : Qâ‚ xâ‚ + Qâ‚‚ xâ‚‚ = 0)
    -- âŠ¢ (xâ‚, xâ‚‚) = 0
    rw [add_eq_zero_iff' (hleâ‚ xâ‚) (hleâ‚‚ xâ‚‚), haâ‚.eq_zero_iff, haâ‚‚.eq_zero_iff] at hx
    -- âŠ¢ (xâ‚, xâ‚‚) = 0
    rwa [Prod.mk_eq_zero]
    -- ðŸŽ‰ no goals
#align quadratic_form.pos_def_prod_iff QuadraticForm.posDef_prod_iff

theorem PosDef.prod {R} [OrderedRing R] [Module R Mâ‚] [Module R Mâ‚‚] {Qâ‚ : QuadraticForm R Mâ‚}
    {Qâ‚‚ : QuadraticForm R Mâ‚‚} (hâ‚ : Qâ‚.PosDef) (hâ‚‚ : Qâ‚‚.PosDef) : (Qâ‚.prod Qâ‚‚).PosDef :=
  posDef_prod_iff.mpr âŸ¨hâ‚, hâ‚‚âŸ©
#align quadratic_form.pos_def.prod QuadraticForm.PosDef.prod

open scoped BigOperators

/-- Construct a quadratic form on a family of modules from the quadratic form on each module. -/
def pi [Fintype Î¹] (Q : âˆ€ i, QuadraticForm R (Máµ¢ i)) : QuadraticForm R (âˆ€ i, Máµ¢ i) :=
  âˆ‘ i, (Q i).comp (LinearMap.proj i : _ â†’â‚—[R] Máµ¢ i)
#align quadratic_form.pi QuadraticForm.pi

@[simp]
theorem pi_apply [Fintype Î¹] (Q : âˆ€ i, QuadraticForm R (Máµ¢ i)) (x : âˆ€ i, Máµ¢ i) :
    pi Q x = âˆ‘ i, Q i (x i) :=
  sum_apply _ _ _
#align quadratic_form.pi_apply QuadraticForm.pi_apply

/-- An isometry between quadratic forms generated by `QuadraticForm.pi` can be constructed
from a pair of isometries between the left and right parts. -/
@[simps toLinearEquiv]
def IsometryEquiv.pi [Fintype Î¹]
    {Q : âˆ€ i, QuadraticForm R (Máµ¢ i)} {Q' : âˆ€ i, QuadraticForm R (Náµ¢ i)}
    (e : âˆ€ i, (Q i).IsometryEquiv (Q' i)) : (pi Q).IsometryEquiv (pi Q') where
  map_app' x := by
    simp only [pi_apply, LinearEquiv.piCongrRight, LinearEquiv.toFun_eq_coe,
      IsometryEquiv.coe_toLinearEquiv, IsometryEquiv.map_app]
  toLinearEquiv := LinearEquiv.piCongrRight fun i => (e i : Máµ¢ i â‰ƒâ‚—[R] Náµ¢ i)
#align quadratic_form.isometry.pi QuadraticForm.IsometryEquiv.pi

theorem Equivalent.pi [Fintype Î¹] {Q : âˆ€ i, QuadraticForm R (Máµ¢ i)}
    {Q' : âˆ€ i, QuadraticForm R (Náµ¢ i)} (e : âˆ€ i, (Q i).Equivalent (Q' i)) :
    (pi Q).Equivalent (pi Q') :=
  âŸ¨IsometryEquiv.pi fun i => Classical.choice (e i)âŸ©
#align quadratic_form.equivalent.pi QuadraticForm.Equivalent.pi

/-- If a family is anisotropic then its components must be. The converse is not true. -/
theorem anisotropic_of_pi [Fintype Î¹] {R} [OrderedRing R] [âˆ€ i, Module R (Máµ¢ i)]
    {Q : âˆ€ i, QuadraticForm R (Máµ¢ i)} (h : (pi Q).Anisotropic) : âˆ€ i, (Q i).Anisotropic := by
  simp_rw [Anisotropic, pi_apply, Function.funext_iff, Pi.zero_apply] at h
  -- âŠ¢ âˆ€ (i : Î¹), Anisotropic (Q i)
  intro i x hx
  -- âŠ¢ x = 0
  classical
  have := h (Pi.single i x) ?_ i
  Â· rw [Pi.single_eq_same] at this
    exact this
  apply Finset.sum_eq_zero
  intro j _
  by_cases hji : j = i
  Â· subst hji; rw [Pi.single_eq_same, hx]
  Â· rw [Pi.single_eq_of_ne hji, map_zero]
#align quadratic_form.anisotropic_of_pi QuadraticForm.anisotropic_of_pi

theorem nonneg_pi_iff [Fintype Î¹] {R} [OrderedRing R] [âˆ€ i, Module R (Máµ¢ i)]
    {Q : âˆ€ i, QuadraticForm R (Máµ¢ i)} : (âˆ€ x, 0 â‰¤ pi Q x) â†” âˆ€ i x, 0 â‰¤ Q i x := by
  simp_rw [pi, sum_apply, comp_apply, LinearMap.proj_apply]
  -- âŠ¢ (âˆ€ (x : (i : Î¹) â†’ Máµ¢ i), 0 â‰¤ âˆ‘ x_1 : Î¹, â†‘(Q x_1) (x x_1)) â†” âˆ€ (i : Î¹) (x : M â€¦
  constructor
  -- âŠ¢ (âˆ€ (x : (i : Î¹) â†’ Máµ¢ i), 0 â‰¤ âˆ‘ x_1 : Î¹, â†‘(Q x_1) (x x_1)) â†’ âˆ€ (i : Î¹) (x : M â€¦
  -- TODO: does this generalize to a useful lemma independent of `QuadraticForm`?
  Â· intro h i x
    -- âŠ¢ 0 â‰¤ â†‘(Q i) x
    classical
    convert h (Pi.single i x) using 1
    rw [Finset.sum_eq_single_of_mem i (Finset.mem_univ _) fun j _ hji => ?_, Pi.single_eq_same]
    rw [Pi.single_eq_of_ne hji, map_zero]
  Â· rintro h x
    -- âŠ¢ 0 â‰¤ âˆ‘ x_1 : Î¹, â†‘(Q x_1) (x x_1)
    exact Finset.sum_nonneg fun i _ => h i (x i)
    -- ðŸŽ‰ no goals
#align quadratic_form.nonneg_pi_iff QuadraticForm.nonneg_pi_iff

theorem posDef_pi_iff [Fintype Î¹] {R} [OrderedRing R] [âˆ€ i, Module R (Máµ¢ i)]
    {Q : âˆ€ i, QuadraticForm R (Máµ¢ i)} : (pi Q).PosDef â†” âˆ€ i, (Q i).PosDef := by
  simp_rw [posDef_iff_nonneg, nonneg_pi_iff]
  -- âŠ¢ (âˆ€ (i : Î¹) (x : Máµ¢ i), 0 â‰¤ â†‘(Q i) x) âˆ§ Anisotropic (pi Q) â†” âˆ€ (i : Î¹), (âˆ€ (x â€¦
  constructor
  -- âŠ¢ (âˆ€ (i : Î¹) (x : Máµ¢ i), 0 â‰¤ â†‘(Q i) x) âˆ§ Anisotropic (pi Q) â†’ âˆ€ (i : Î¹), (âˆ€ (x â€¦
  Â· rintro âŸ¨hle, haâŸ©
    -- âŠ¢ âˆ€ (i : Î¹), (âˆ€ (x : Máµ¢ i), 0 â‰¤ â†‘(Q i) x) âˆ§ Anisotropic (Q i)
    intro i
    -- âŠ¢ (âˆ€ (x : Máµ¢ i), 0 â‰¤ â†‘(Q i) x) âˆ§ Anisotropic (Q i)
    exact âŸ¨hle i, anisotropic_of_pi ha iâŸ©
    -- ðŸŽ‰ no goals
  Â· intro h
    -- âŠ¢ (âˆ€ (i : Î¹) (x : Máµ¢ i), 0 â‰¤ â†‘(Q i) x) âˆ§ Anisotropic (pi Q)
    refine' âŸ¨fun i => (h i).1, fun x hx => funext fun i => (h i).2 _ _âŸ©
    -- âŠ¢ â†‘(Q i) (x i) = 0
    rw [pi_apply, Finset.sum_eq_zero_iff_of_nonneg fun j _ => ?_] at hx
    -- âŠ¢ â†‘(Q i) (x i) = 0
    Â· exact hx _ (Finset.mem_univ _)
      -- ðŸŽ‰ no goals
    exact (h j).1 _
    -- ðŸŽ‰ no goals
#align quadratic_form.pos_def_pi_iff QuadraticForm.posDef_pi_iff

end QuadraticForm
