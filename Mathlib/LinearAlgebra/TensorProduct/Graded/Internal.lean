/-
Copyright (c) 2023 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser
-/
import Mathlib.LinearAlgebra.TensorProduct.Graded.External
import Mathlib.RingTheory.GradedAlgebra.Basic
import Mathlib.GroupTheory.GroupAction.Ring

/-!
# Graded tensor products over graded algebras

The graded tensor product $A \hat\otimes_R B$ is imbued with a multiplication defined on homogeneous
tensors by:

$$(a \otimes b) \cdot (a' \otimes b') = (-1)^{\deg a' \deg b} (a \cdot a') \otimes (b \cdot b')$$

where $A$ and $B$ are algebras graded by `РёЋ`, `Рёц`, or `╬╣` (or more generally, any index
that satisfies `Module ╬╣ (Additive Рёц╦Б)`).

## Main results

* `GradedTensorProduct R ­Юњю Рёг`: for families of submodules of `A` and `B` that form a graded algebra,
  this is a type alias for `A РіЌ[R] B` with the appropriate multiplication.
* `GradedTensorProduct.instAlgebra`: the ring structure induced by this multiplication.
* `GradedTensorProduct.liftEquiv`: a universal property for graded tensor products

## Notation

* `­Юњю рхЇРіЌ[R] Рёг` is notation for `GradedTensorProduct R ­Юњю Рёг`.
* `a рхЇРіЌРѓю b` is notation for `GradedTensorProduct.tmul _ a b`.

## References

* https://math.stackexchange.com/q/202718/1896
* [*Algebra I*, Bourbaki : Chapter III, ┬Д4.7, example (2)][bourbaki1989]

## Implementation notes

We cannot put the multiplication on `A РіЌ[R] B` directly as it would conflict with the existing
multiplication defined without the $(-1)^{\deg a' \deg b}$ term. Furthermore, the ring `A` may not
have a unique graduation, and so we need the chosen graduation `­Юњю` to appear explicitly in the
type.

## TODO

* Show that the tensor product of graded algebras is itself a graded algebra.
* Determine if replacing the synonym with a single-field structure improves performance.
-/

suppress_compilation

open scoped TensorProduct

variable {R ╬╣ A B : Type*}
variable [CommSemiring ╬╣] [Module ╬╣ (Additive Рёц╦Б)] [DecidableEq ╬╣]
variable [CommRing R] [Ring A] [Ring B] [Algebra R A] [Algebra R B]
variable (­Юњю : ╬╣ Рєњ Submodule R A) (Рёг : ╬╣ Рєњ Submodule R B)
variable [GradedAlgebra ­Юњю] [GradedAlgebra Рёг]

open DirectSum


variable (R) in
/-- A Type synonym for `A РіЌ[R] B`, but with multiplication as `TensorProduct.gradedMul`.

This has notation `­Юњю рхЇРіЌ[R] Рёг`. -/
@[nolint unusedArguments]
def GradedTensorProduct
    (­Юњю : ╬╣ Рєњ Submodule R A) (Рёг : ╬╣ Рєњ Submodule R B)
    [GradedAlgebra ­Юњю] [GradedAlgebra Рёг] :
    Type _ :=
  A РіЌ[R] B

namespace GradedTensorProduct

open TensorProduct

@[inherit_doc GradedTensorProduct]
scoped[TensorProduct] notation:100 ­Юњю " рхЇРіЌ[" R "] " Рёг:100 => GradedTensorProduct R ­Юњю Рёг

instance instAddCommGroupWithOne : AddCommGroupWithOne (­Юњю рхЇРіЌ[R] Рёг) :=
  Algebra.TensorProduct.instAddCommGroupWithOne
instance : Module R (­Юњю рхЇРіЌ[R] Рёг) := TensorProduct.leftModule

variable (R) in
/-- The casting equivalence to move between regular and graded tensor products. -/
def of : A РіЌ[R] B РЅЃРѓЌ[R] ­Юњю рхЇРіЌ[R] Рёг := LinearEquiv.refl _ _

@[simp]
theorem of_one : of R ­Юњю Рёг 1 = 1 := rfl

@[simp]
theorem of_symm_one : (of R ­Юњю Рёг).symm 1 = 1 := rfl

-- for dsimp
@[simp, nolint simpNF]
theorem of_symm_of (x : A РіЌ[R] B) : (of R ­Юњю Рёг).symm (of R ­Юњю Рёг x) = x := rfl

-- for dsimp
@[simp, nolint simpNF]
theorem symm_of_of (x : ­Юњю рхЇРіЌ[R] Рёг) : of R ­Юњю Рёг ((of R ­Юњю Рёг).symm x) = x := rfl

/-- Two linear maps from the graded tensor product agree if they agree on the underlying tensor
product. -/
@[ext]
theorem hom_ext {M} [AddCommMonoid M] [Module R M] РдЃf g : ­Юњю рхЇРіЌ[R] Рёг РєњРѓЌ[R] MРдё
    (h : f РѕўРѓЌ of R ­Юњю Рёг = (g РѕўРѓЌ of R ­Юњю Рёг : A РіЌ[R] B РєњРѓЌ[R] M)) :
    f = g :=
  h

variable (R) {­Юњю Рёг} in
/-- The graded tensor product of two elements of graded rings. -/
abbrev tmul (a : A) (b : B) : ­Юњю рхЇРіЌ[R] Рёг := of R ­Юњю Рёг (a РіЌРѓю b)

@[inherit_doc]
notation:100 x " рхЇРіЌРѓю" y:100 => tmul _ x y

@[inherit_doc]
notation:100 x " рхЇРіЌРѓю[" R "] " y:100 => tmul R x y

variable (R) in
/-- An auxiliary construction to move between the graded tensor product of internally-graded objects
and the tensor product of direct sums. -/
noncomputable def auxEquiv : (­Юњю рхЇРіЌ[R] Рёг) РЅЃРѓЌ[R] (РеЂ i, ­Юњю i) РіЌ[R] (РеЂ i, Рёг i) :=
  let fA := (decomposeAlgEquiv ­Юњю).toLinearEquiv
  let fB := (decomposeAlgEquiv Рёг).toLinearEquiv
  (of R ­Юњю Рёг).symm.trans (TensorProduct.congr fA fB)

theorem auxEquiv_tmul (a : A) (b : B) :
    auxEquiv R ­Юњю Рёг (a рхЇРіЌРѓю b) = decompose ­Юњю a РіЌРѓю decompose Рёг b := rfl

theorem auxEquiv_one : auxEquiv R ­Юњю Рёг 1 = 1 := by
  rw [Рєљ of_one, Algebra.TensorProduct.one_def, auxEquiv_tmul ­Юњю Рёг, DirectSum.decompose_one,
    DirectSum.decompose_one, Algebra.TensorProduct.one_def]

theorem auxEquiv_symm_one : (auxEquiv R ­Юњю Рёг).symm 1 = 1 :=
  (LinearEquiv.symm_apply_eq _).mpr (auxEquiv_one _ _).symm

/-- Auxiliary construction used to build the `Mul` instance and get distributivity of `+` and
`\smul`. -/
noncomputable def mulHom : (­Юњю рхЇРіЌ[R] Рёг) РєњРѓЌ[R] (­Юњю рхЇРіЌ[R] Рёг) РєњРѓЌ[R] (­Юњю рхЇРіЌ[R] Рёг) := by
  letI fAB1 := auxEquiv R ­Юњю Рёг
  have := ((gradedMul R (­Юњю ┬и) (Рёг ┬и)).complРѓЂРѓѓ fAB1.toLinearMap fAB1.toLinearMap).comprРѓѓ
    fAB1.symm.toLinearMap
  exact this

theorem mulHom_apply (x y : ­Юњю рхЇРіЌ[R] Рёг) :
    mulHom ­Юњю Рёг x y
      = (auxEquiv R ­Юњю Рёг).symm (gradedMul R (­Юњю ┬и) (Рёг ┬и) (auxEquiv R ­Юњю Рёг x) (auxEquiv R ­Юњю Рёг y)) :=
  rfl

/-- The multipication on the graded tensor product.

See `GradedTensorProduct.coe_mul_coe` for a characterization on pure tensors. -/
instance : Mul (­Юњю рхЇРіЌ[R] Рёг) where mul x y := mulHom ­Юњю Рёг x y

theorem mul_def (x y : ­Юњю рхЇРіЌ[R] Рёг) : x * y = mulHom ­Юњю Рёг x y := rfl

-- Before #8386 this was `@[simp]` but it times out when we try to apply it.
theorem auxEquiv_mul (x y : ­Юњю рхЇРіЌ[R] Рёг) :
    auxEquiv R ­Юњю Рёг (x * y) = gradedMul R (­Юњю ┬и) (Рёг ┬и) (auxEquiv R ­Юњю Рёг x) (auxEquiv R ­Юњю Рёг y) :=
  LinearEquiv.eq_symm_apply _ |>.mp rfl

instance instMonoid : Monoid (­Юњю рхЇРіЌ[R] Рёг) where
  mul_one x := by
    rw [mul_def, mulHom_apply, auxEquiv_one, gradedMul_one, LinearEquiv.symm_apply_apply]
  one_mul x := by
    rw [mul_def, mulHom_apply, auxEquiv_one, one_gradedMul, LinearEquiv.symm_apply_apply]
  mul_assoc x y z := by
    simp_rw [mul_def, mulHom_apply, LinearEquiv.apply_symm_apply]
    rw [gradedMul_assoc]

instance instRing : Ring (­Юњю рхЇРіЌ[R] Рёг) where
  __ := instAddCommGroupWithOne ­Юњю Рёг
  __ := instMonoid ­Юњю Рёг
  right_distrib x y z := by simp_rw [mul_def, LinearMap.map_addРѓѓ]
  left_distrib x y z := by simp_rw [mul_def, map_add]
  mul_zero x := by simp_rw [mul_def, map_zero]
  zero_mul x := by simp_rw [mul_def, LinearMap.map_zeroРѓѓ]

/-- The characterization of this multiplication on partially homogenous elements. -/
theorem tmul_coe_mul_coe_tmul {jРѓЂ iРѓѓ : ╬╣} (aРѓЂ : A) (bРѓЂ : Рёг jРѓЂ) (aРѓѓ : ­Юњю iРѓѓ) (bРѓѓ : B) :
    (aРѓЂ рхЇРіЌРѓю[R] (bРѓЂ : B) * (aРѓѓ : A) рхЇРіЌРѓю[R] bРѓѓ : ­Юњю рхЇРіЌ[R] Рёг) =
      (-1 : Рёц╦Б)^(jРѓЂ * iРѓѓ) Рђб ((aРѓЂ * aРѓѓ : A) рхЇРіЌРѓю (bРѓЂ * bРѓѓ : B)) := by
  dsimp only [mul_def, mulHom_apply, of_symm_of]
  dsimp [auxEquiv, tmul]
  erw [decompose_coe, decompose_coe]
  simp_rw [Рєљ lof_eq_of R]
  rw [tmul_of_gradedMul_of_tmul]
  simp_rw [lof_eq_of R]
  rw [LinearEquiv.symm_symm]
  -- Note: #8386 had to specialize `map_smul` to `LinearEquiv.map_smul`
  rw [@Units.smul_def _ _ (_) (_), zsmul_eq_smul_cast R, LinearEquiv.map_smul, map_smul,
    Рєљ zsmul_eq_smul_cast R, Рєљ @Units.smul_def _ _ (_) (_)]
  rw [congr_symm_tmul]
  dsimp
  simp_rw [decompose_symm_mul, decompose_symm_of, Equiv.symm_apply_apply]

/-- A special case for when `bРѓЂ` has grade 0. -/
theorem tmul_zero_coe_mul_coe_tmul {iРѓѓ : ╬╣} (aРѓЂ : A) (bРѓЂ : Рёг 0) (aРѓѓ : ­Юњю iРѓѓ) (bРѓѓ : B) :
    (aРѓЂ рхЇРіЌРѓю[R] (bРѓЂ : B) * (aРѓѓ : A) рхЇРіЌРѓю[R] bРѓѓ : ­Юњю рхЇРіЌ[R] Рёг) =
      ((aРѓЂ * aРѓѓ : A) рхЇРіЌРѓю (bРѓЂ * bРѓѓ : B)) := by
  rw [tmul_coe_mul_coe_tmul, zero_mul, uzpow_zero, one_smul]

/-- A special case for when `aРѓѓ` has grade 0. -/
theorem tmul_coe_mul_zero_coe_tmul {jРѓЂ : ╬╣} (aРѓЂ : A) (bРѓЂ : Рёг jРѓЂ) (aРѓѓ : ­Юњю 0) (bРѓѓ : B) :
    (aРѓЂ рхЇРіЌРѓю[R] (bРѓЂ : B) * (aРѓѓ : A) рхЇРіЌРѓю[R] bРѓѓ : ­Юњю рхЇРіЌ[R] Рёг) =
      ((aРѓЂ * aРѓѓ : A) рхЇРіЌРѓю (bРѓЂ * bРѓѓ : B)) := by
  rw [tmul_coe_mul_coe_tmul, mul_zero, uzpow_zero, one_smul]

theorem tmul_one_mul_coe_tmul {iРѓѓ : ╬╣} (aРѓЂ : A) (aРѓѓ : ­Юњю iРѓѓ) (bРѓѓ : B) :
    (aРѓЂ рхЇРіЌРѓю[R] (1 : B) * (aРѓѓ : A) рхЇРіЌРѓю[R] bРѓѓ : ­Юњю рхЇРіЌ[R] Рёг) = (aРѓЂ * aРѓѓ : A) рхЇРіЌРѓю (bРѓѓ : B) := by
  convert tmul_zero_coe_mul_coe_tmul ­Юњю Рёг aРѓЂ (@GradedMonoid.GOne.one _ (Рёг ┬и) _ _) aРѓѓ bРѓѓ
  rw [SetLike.coe_gOne, one_mul]

theorem tmul_coe_mul_one_tmul {jРѓЂ : ╬╣} (aРѓЂ : A) (bРѓЂ : Рёг jРѓЂ) (bРѓѓ : B) :
    (aРѓЂ рхЇРіЌРѓю[R] (bРѓЂ : B) * (1 : A) рхЇРіЌРѓю[R] bРѓѓ : ­Юњю рхЇРіЌ[R] Рёг) = (aРѓЂ : A) рхЇРіЌРѓю (bРѓЂ * bРѓѓ : B) := by
  convert tmul_coe_mul_zero_coe_tmul ­Юњю Рёг aРѓЂ bРѓЂ (@GradedMonoid.GOne.one _ (­Юњю ┬и) _ _) bРѓѓ
  rw [SetLike.coe_gOne, mul_one]

theorem tmul_one_mul_one_tmul (aРѓЂ : A) (bРѓѓ : B) :
    (aРѓЂ рхЇРіЌРѓю[R] (1 : B) * (1 : A) рхЇРіЌРѓю[R] bРѓѓ : ­Юњю рхЇРіЌ[R] Рёг) = (aРѓЂ : A) рхЇРіЌРѓю (bРѓѓ : B) := by
  convert tmul_coe_mul_zero_coe_tmul ­Юњю Рёг
    aРѓЂ (@GradedMonoid.GOne.one _ (Рёг ┬и) _ _) (@GradedMonoid.GOne.one _ (­Юњю ┬и) _ _) bРѓѓ
  ┬и rw [SetLike.coe_gOne, mul_one]
  ┬и rw [SetLike.coe_gOne, one_mul]

/-- The ring morphism `A Рєњ+* A РіЌ[R] B` sending `a` to `a РіЌРѓю 1`. -/
@[simps]
def includeLeftRingHom : A Рєњ+* ­Юњю рхЇРіЌ[R] Рёг where
  toFun a := a рхЇРіЌРѓю 1
  map_zero' := by simp
  map_add' := by simp [tmul, TensorProduct.add_tmul]
  map_one' := rfl
  map_mul' aРѓЂ aРѓѓ := by
    dsimp
    classical
    rw [Рєљ DirectSum.sum_support_decompose ­Юњю aРѓѓ, Finset.mul_sum]
    simp_rw [tmul, sum_tmul, map_sum, Finset.mul_sum]
    congr
    ext i
    rw [Рєљ SetLike.coe_gOne Рёг, tmul_coe_mul_coe_tmul, zero_mul, uzpow_zero, one_smul,
      SetLike.coe_gOne, one_mul]

instance instAlgebra : Algebra R (­Юњю рхЇРіЌ[R] Рёг) where
  toRingHom := (includeLeftRingHom ­Юњю Рёг).comp (algebraMap R A)
  commutes' r x := by
    dsimp [mul_def, mulHom_apply, auxEquiv_tmul]
    simp_rw [DirectSum.decompose_algebraMap, DirectSum.decompose_one, algebraMap_gradedMul,
      gradedMul_algebraMap]
  smul_def' r x := by
    dsimp [mul_def, mulHom_apply, auxEquiv_tmul]
    simp_rw [DirectSum.decompose_algebraMap, DirectSum.decompose_one, algebraMap_gradedMul]
    -- Qualified `map_smul` to avoid a TC timeout #8386
    erw [LinearMap.map_smul]
    erw [LinearEquiv.symm_apply_apply]

lemma algebraMap_def (r : R) : algebraMap R (­Юњю рхЇРіЌ[R] Рёг) r = algebraMap R A r рхЇРіЌРѓю[R] 1 := rfl

theorem tmul_algebraMap_mul_coe_tmul {iРѓѓ : ╬╣} (aРѓЂ : A) (r : R) (aРѓѓ : ­Юњю iРѓѓ) (bРѓѓ : B) :
    (aРѓЂ рхЇРіЌРѓю[R] algebraMap R B r * (aРѓѓ : A) рхЇРіЌРѓю[R] bРѓѓ : ­Юњю рхЇРіЌ[R] Рёг)
      = (aРѓЂ * aРѓѓ : A) рхЇРіЌРѓю (algebraMap R B r * bРѓѓ : B) :=
  tmul_zero_coe_mul_coe_tmul ­Юњю Рёг aРѓЂ (GAlgebra.toFun (A := (Рёг ┬и)) r) aРѓѓ bРѓѓ

theorem tmul_coe_mul_algebraMap_tmul {jРѓЂ : ╬╣} (aРѓЂ : A) (bРѓЂ : Рёг jРѓЂ) (r : R) (bРѓѓ : B) :
    (aРѓЂ рхЇРіЌРѓю[R] (bРѓЂ : B) * algebraMap R A r рхЇРіЌРѓю[R] bРѓѓ : ­Юњю рхЇРіЌ[R] Рёг)
      = (aРѓЂ * algebraMap R A r : A) рхЇРіЌРѓю (bРѓЂ * bРѓѓ : B) :=
  tmul_coe_mul_zero_coe_tmul ­Юњю Рёг aРѓЂ bРѓЂ (GAlgebra.toFun (A := (­Юњю ┬и)) r) bРѓѓ

/-- The algebra morphism `A РєњРѓљ[R] A РіЌ[R] B` sending `a` to `a РіЌРѓю 1`. -/
@[simps!]
def includeLeft : A РєњРѓљ[R] ­Юњю рхЇРіЌ[R] Рёг where
  toRingHom := includeLeftRingHom ­Юњю Рёг
  commutes' _ := rfl

/-- The algebra morphism `B РєњРѓљ[R] A РіЌ[R] B` sending `b` to `1 РіЌРѓю b`. -/
@[simps!]
def includeRight : B РєњРѓљ[R] (­Юњю рхЇРіЌ[R] Рёг) :=
  AlgHom.ofLinearMap (R := R) (A := B) (B := ­Юњю рхЇРіЌ[R] Рёг)
    (f := {
       toFun := fun b => 1 рхЇРіЌРѓю b
       map_add' := by simp [tmul, TensorProduct.tmul_add]
       map_smul' := by simp [tmul, TensorProduct.tmul_smul] })
    (map_one := rfl)
    (map_mul := by
      rw [LinearMap.map_mul_iff]
      refine DirectSum.decompose_lhom_ext Рёг fun iРѓЂ => ?_
      ext bРѓЂ bРѓѓ : 2
      dsimp
      rw [tmul_coe_mul_one_tmul])

lemma algebraMap_def' (r : R) : algebraMap R (­Юњю рхЇРіЌ[R] Рёг) r = 1 рхЇРіЌРѓю[R] algebraMap R B r :=
  (includeRight ­Юњю Рёг).commutes r |>.symm

variable {C} [Ring C] [Algebra R C]

/-- The forwards direction of the universal property; an algebra morphism out of the graded tensor
product can be assembed from maps on each component that (anti)commute on pure elements of the
corresponding graded algebras. -/
def lift (f : A РєњРѓљ[R] C) (g : B РєњРѓљ[R] C)
    (h_anti_commutes : Рѕђ РдЃi jРдё (a : ­Юњю i) (b : Рёг j), f a * g b = (-1 : Рёц╦Б)^(j * i) Рђб (g b * f a)) :
    (­Юњю рхЇРіЌ[R] Рёг) РєњРѓљ[R] C :=
  AlgHom.ofLinearMap
    (LinearMap.mul' R C
      РѕўРѓЌ (TensorProduct.map f.toLinearMap g.toLinearMap)
      РѕўРѓЌ ((of R ­Юњю Рёг).symm : ­Юњю рхЇРіЌ[R] Рёг РєњРѓЌ[R] A РіЌ[R] B))
    (by dsimp [Algebra.TensorProduct.one_def]; simp only [_root_.map_one, mul_one])
    (by
      rw [LinearMap.map_mul_iff]
      ext aРѓЂ : 3
      refine DirectSum.decompose_lhom_ext Рёг fun jРѓЂ => ?_
      ext bРѓЂ : 3
      refine DirectSum.decompose_lhom_ext ­Юњю fun iРѓѓ => ?_
      ext aРѓѓ bРѓѓ : 2
      dsimp
      rw [tmul_coe_mul_coe_tmul]
      rw [@Units.smul_def _ _ (_) (_), zsmul_eq_smul_cast R, map_smul, map_smul, map_smul]
      rw [Рєљ zsmul_eq_smul_cast R, Рєљ @Units.smul_def _ _ (_) (_)]
      rw [of_symm_of, map_tmul, LinearMap.mul'_apply]
      simp_rw [AlgHom.toLinearMap_apply, _root_.map_mul]
      simp_rw [mul_assoc (f aРѓЂ), Рєљ mul_assoc _ _ (g bРѓѓ), h_anti_commutes, mul_smul_comm,
        smul_mul_assoc, smul_smul, Int.units_mul_self, one_smul])

@[simp]
theorem lift_tmul (f : A РєњРѓљ[R] C) (g : B РєњРѓљ[R] C)
    (h_anti_commutes : Рѕђ РдЃi jРдё (a : ­Юњю i) (b : Рёг j), f a * g b = (-1 : Рёц╦Б)^(j * i) Рђб (g b * f a))
    (a : A) (b : B) :
    lift ­Юњю Рёг f g h_anti_commutes (a рхЇРіЌРѓю b) = f a * g b :=
  rfl

/-- The universal property of the graded tensor product; every algebra morphism uniquely factors
as a pair of algebra morphisms that anticommute with respect to the grading. -/
def liftEquiv :
    { fg : (A РєњРѓљ[R] C) ├Ќ (B РєњРѓљ[R] C) //
        Рѕђ РдЃi jРдё (a : ­Юњю i) (b : Рёг j), fg.1 a * fg.2 b = (-1 : Рёц╦Б)^(j * i) Рђб (fg.2 b * fg.1 a)} РЅЃ
      ((­Юњю рхЇРіЌ[R] Рёг) РєњРѓљ[R] C) where
  toFun fg := lift ­Юњю Рёг _ _ fg.prop
  invFun F := РЪе(F.comp (includeLeft ­Юњю Рёг), F.comp (includeRight ­Юњю Рёг)), fun i j a b => by
    dsimp
    rw [Рєљ F.map_mul, Рєљ F.map_mul, tmul_coe_mul_coe_tmul, one_mul, mul_one, AlgHom.map_smul_of_tower,
      tmul_one_mul_one_tmul, smul_smul, Int.units_mul_self, one_smul]РЪЕ
  left_inv fg := by ext <;> (dsimp; simp only [_root_.map_one, mul_one, one_mul])
  right_inv F := by
    apply AlgHom.toLinearMap_injective
    ext
    dsimp
    rw [Рєљ F.map_mul, tmul_one_mul_one_tmul]

/-- Two algebra morphism from the graded tensor product agree if their compositions with the left
and right inclusions agree. -/
@[ext]
lemma algHom_ext РдЃf g : (­Юњю рхЇРіЌ[R] Рёг) РєњРѓљ[R] CРдё
    (ha : f.comp (includeLeft ­Юњю Рёг) = g.comp (includeLeft ­Юњю Рёг))
    (hb : f.comp (includeRight ­Юњю Рёг) = g.comp (includeRight ­Юњю Рёг)) : f = g :=
  (liftEquiv ­Юњю Рёг).symm.injective <| Subtype.ext <| Prod.ext ha hb

/-- The non-trivial symmetric braiding, sending $a \otimes b$ to
$(-1)^{\deg a' \deg b} (b \otimes a)$. -/
def comm : (­Юњю рхЇРіЌ[R] Рёг) РЅЃРѓљ[R] (Рёг рхЇРіЌ[R] ­Юњю) :=
  AlgEquiv.ofLinearEquiv
    (auxEquiv R ­Юњю Рёг РЅфРЅФРѓЌ gradedComm R _ _ РЅфРЅФРѓЌ (auxEquiv R Рёг ­Юњю).symm)
    (by
      dsimp
      simp_rw [auxEquiv_one, gradedComm_one, auxEquiv_symm_one])
    (fun x y => by
      dsimp
      simp_rw [auxEquiv_mul, gradedComm_gradedMul, LinearEquiv.symm_apply_eq,
        Рєљ gradedComm_gradedMul, auxEquiv_mul, LinearEquiv.apply_symm_apply, gradedComm_gradedMul])

lemma auxEquiv_comm (x : ­Юњю рхЇРіЌ[R] Рёг) :
    auxEquiv R Рёг ­Юњю (comm ­Юњю Рёг x) = gradedComm R (­Юњю ┬и) (Рёг ┬и) (auxEquiv R ­Юњю Рёг x) :=
  LinearEquiv.eq_symm_apply _ |>.mp rfl

@[simp] lemma comm_coe_tmul_coe {i j : ╬╣} (a : ­Юњю i) (b : Рёг j) :
    comm ­Юњю Рёг (a рхЇРіЌРѓю b) = (-1 : Рёц╦Б)^(j * i) Рђб (b рхЇРіЌРѓю a : Рёг рхЇРіЌ[R] ­Юњю) :=
  (auxEquiv R Рёг ­Юњю).injective <| by
    simp_rw [auxEquiv_comm, auxEquiv_tmul, decompose_coe, Рєљ lof_eq_of R, gradedComm_of_tmul_of,
      @Units.smul_def _ _ (_) (_), zsmul_eq_smul_cast R]
    -- Qualified `map_smul` to avoid a TC timeout #8386
    erw [LinearMap.map_smul, auxEquiv_tmul]
    simp_rw [decompose_coe, lof_eq_of]

end GradedTensorProduct
