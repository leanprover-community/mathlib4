/-
Copyright (c) 2025 Raphael Douglas Giles. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Raphael Douglas Giles
-/
import Mathlib.LinearAlgebra.TensorAlgebra.Basic
import Mathlib.Algebra.MvPolynomial.Basic
import Mathlib.LinearAlgebra.FreeModule.Basic
import Mathlib.RingTheory.Finiteness.Defs
import Mathlib.Algebra.Algebra.Hom
import Mathlib.Algebra.Lie.Basic
import Mathlib.Algebra.Lie.OfAssociative
import Mathlib.Algebra.Polynomial.Basic
import Mathlib.LinearAlgebra.Dimension.Finrank
import Mathlib.LinearAlgebra.Dimension.Free
import Mathlib.RingTheory.TensorProduct.Basic
import Mathlib.LinearAlgebra.FreeModule.StrongRankCondition
import Aesop

/-!
# Symmetric Algebras

Given a commutative ring `R`, and an `R`-module `L`, we construct the symmetric algebra of `L`.
This is the free commutative `R`-algebra generated (`R`-linearly) by the module `L`.

## Notation

1. `SymmetricAlgebra R L` is a concrete construction of the symmetric algebra defined as a
   quotient of the tensor algebra. It is endowed with an R-algebra structure and a commutative
   ring structure.
2. `SymmetricAlgebra.iota R` is the canonical R-linear map `L â†’ TensorAlgebra R L`.
3. Given a morphism `iota : L â†’â‚—[R] RL`, `IsSymmetricAlgebra iota` is a proposition saying whether
   RL satisfies the universal property of the symmetric algebra over L with iota as the canonical
   inclusion morphism.
3. Given a linear map `f : M â†’ A` to an commutative R-algebra `A`, and a morphism
   `iota : L â†’â‚—[R] RL` with `p : IsSymmetricAlgebra iota`, `IsSymmetricAlgebra.lift R p f`
   is the lift of `f` to an `R`-algebra morphism `RL â†’â‚[R] A`.

## Theorems

1. `SymmetricAlgebra.isSymmetricAlgebra R L` states that the concrete construction of the symmetric
   algebra satisfies the univeral property codified in `IsSymmetricAlgebra`.
2. Given a proof `hl` that `L` is subsingleton (meaning as a module it must be the zero module)
   `IsSymmetricAlgebra.baseRingOfZeroModule hl` states that `R` viewed as an `R` algebra satisfies
   the universal property of the symmetric algebra of `L`.
3. `IsSymmetricAlgebra.isomorphismOfSymmetricAlgebraOfSymmetricAlgebra` states that any two algebras
   `RM` and `RM'` both satisfying the universal property of the symmetric algebra over a module `M`
   must be isorphic as `R`-algebras.
4. `IsSymmetricAlgebra.mvPolynomial` states that given a basis of `L` indexed by type `I`, the
   multivariate polynomial ring generated by monomials `X_i` for all `i : I` satisfies the
   universal property of the symmetric algebra over `L`.

-/

open MvPolynomial RingQuot

noncomputable section
universe u
variable (R L : Type u) {RL : Type u} [CommRing R]
         [AddCommMonoid L] [Module R L]
         [CommRing RL] [Algebra R RL]

         {L' : Type u} [CommRing L'] [Algebra R L']
local notation "Î¹" => TensorAlgebra.Î¹ R

/--
Relation on the tensor algebra which will yield the symmetric algebra when
quotiented out by
-/
inductive SymRel : (TensorAlgebra R L) â†’ (TensorAlgebra R L) â†’ Prop where
  | mul_comm (x y : L) : SymRel (Î¹ x * Î¹ y) (Î¹ y * Î¹ x)

/--
Concrete construction of the symmetric algebra of L by quotienting out
the tensor algebra by the commutativity relation
-/
abbrev SymmetricAlgebra := RingQuot (SymRel R L)


variable {R} {L} in
/--
Given a morphism iota : L â†’â‚—[R] RL, where RL is some commutative algebra over R,
IsSymmetricAlgebra iota means that RL satisfies the universal property of the
symmetric algebra of L, i.e. it means that for any morphism Ï† : L â†’â‚—[R] A into a
commutative algebra A, there exists a unique Ï†' : RL â†’â‚[R] A such that Ï† = Ï†' âˆ˜ iota.
-/
structure IsSymmetricAlgebra (iota : L â†’â‚—[R] RL) : Prop where
  ex_map {A : Type u} [CommRing A] [Algebra R A] (Ï† : L â†’â‚—[R] A)
    : âˆƒ! Ï†' : RL â†’â‚[R] A, Ï† = Ï†'.toLinearMap âˆ˜â‚— iota



local notation "ð”–" => SymmetricAlgebra


namespace SymmetricAlgebra
instance : CommRing (ð”– R L) where
  mul_comm a b := match a, b with
    | âŸ¨aâŸ©, âŸ¨bâŸ© => by
      apply Quot.ind _ a; apply Quot.ind _ b; intro a b;
      rw [mul_quot, mul_quot]
      suffices h : âˆ€ (x : TensorAlgebra R L),
      (âŸ¨Quot.mk (RingQuot.Rel (SymRel R L)) (x * a)âŸ© : (RingQuot (SymRel R L))) =
       âŸ¨Quot.mk (RingQuot.Rel (SymRel R L)) (a * x)âŸ© by
        exact (h b)
      let P : TensorAlgebra R L â†’ TensorAlgebra R L â†’ Prop :=
       fun x y â†¦ (âŸ¨Quot.mk (RingQuot.Rel (SymRel R L)) (x * y)âŸ© : (RingQuot (SymRel R L))) =
        âŸ¨Quot.mk (RingQuot.Rel (SymRel R L)) (y * x)âŸ©
      have P_smul (r : R) (x : TensorAlgebra R L) : P x (algebraMap R (TensorAlgebra R L) r) := by
        unfold P; rw [Algebra.commutes]
      have P_mul (x y z : TensorAlgebra R L) (h1 : P z x) (h2 : P z y) : P z (x * y) := by
        unfold P at h1 h2 âŠ¢
        rw [â† mul_quot, â† mul_quot, â† mul_quot, â† mul_quot,
            â† mul_assoc, mul_quot, h1, â† mul_quot, mul_assoc, mul_quot, h2, â† mul_quot, mul_assoc]
      have P_add (x y z : TensorAlgebra R L) (h1 : P z x) (h2 : P z y) : P z (x + y) := by
        unfold P at h1 h2 âŠ¢
        rw [mul_add, add_mul, â† add_quot, â† add_quot, h1, h2]
      have P_symm {x y : TensorAlgebra R L} (h : P x y) : P y x := h.symm
      have P_base (x y : L) : P (Î¹ x) (Î¹ y) := by
        unfold P
        rw [Quot.sound (Rel.of (SymRel.mul_comm x y))]
      apply TensorAlgebra.induction (C := fun y â†¦ âˆ€ (x : TensorAlgebra R L), P x y) _ _ _ _ a
      Â· intro r; exact P_smul r
      Â· intro x; apply TensorAlgebra.induction
        Â· intro r; exact P_symm (P_smul r (Î¹ x))
        Â· intro y; exact P_base y x
        Â· intro a1 a2 h1 h2; exact P_symm (P_mul a1 a2 (Î¹ x) (P_symm h1) (P_symm h2))
        Â· intro a1 a2 h1 h2; exact P_symm (P_add a1 a2 (Î¹ x) (P_symm h1) (P_symm h2))
      Â· intro a1 a2 h1 h2 x; exact P_mul a1 a2 x (h1 x) (h2 x)
      Â· intro a1 a2 h1 h2 x; exact P_add a1 a2 x (h1 x) (h2 x)

/--
Algebra homomorphism from the tensor algebra over L to the symmetric algebra over L.
-/
abbrev algHom : TensorAlgebra R L â†’â‚[R] ð”– R L := RingQuot.mkAlgHom R (SymRel R L)

/--
Canonical inclusion of `L` into the symmetric algebra `ð”– R L`.
-/
def iota : L â†’â‚—[R] ð”– R L := (algHom R L).toLinearMap.comp (TensorAlgebra.Î¹ R (M := L))

end SymmetricAlgebra

namespace IsSymmetricAlgebra
/--
The zero module over base ring R has R as its symmetric algebra
-/
theorem baseRingOfZeroModule (hm : Subsingleton L) :
   IsSymmetricAlgebra (R := R) (L := L) (RL := R) 0 where
    ex_map := by
      intro a b c Ï†
      have hÏ† : Ï† = 0 := by exact Subsingleton.eq_zero Ï†
      let Ï†' : R â†’â‚[R] a := Algebra.ofId R a
      use Ï†'
      constructor
      Â· rw [hÏ†]
        ext x
        simp only [LinearMap.zero_apply, LinearMap.comp_zero]
      Â·  intro Ïˆ hÏˆ
         exact Algebra.ext_id_iff.mpr trivial

open SymmetricAlgebra in
/--
The concrete construction of the symmetric algebra as a quotient of the tensor algebra
satisfies the universal property of the symmetric algebra
-/
theorem SymmetricAlgebra.isSymmetricAlgebra : IsSymmetricAlgebra (iota R L) where
  ex_map := by
    intro alg com halg Ï†
    let tensorphi : TensorAlgebra R L â†’â‚[R] alg := TensorAlgebra.lift R Ï†

    let res : âˆ€ â¦ƒx y : TensorAlgebra R Lâ¦„, SymRel R L x y â†’ tensorphi x = tensorphi y := by
        intro x y h
        induction h
        case mul_comm x y =>
          simp only [map_mul]
          rw [@NonUnitalCommSemiring.mul_comm]

    use (RingQuot.liftAlgHom (S := R) (s := SymRel R L) (B := alg)) âŸ¨TensorAlgebra.lift R Ï†, resâŸ©
    constructor
    Â· unfold iota
      ext a
      simp
    Â· intro a b
      apply RingQuot.liftAlgHom_unique
      exact
        (TensorAlgebra.lift_unique Ï† (a.comp (RingQuot.mkAlgHom R (SymRel R L)))).mp
          (id (Eq.symm b))


variable {L}

/--
Given a morphism `phi : L â†’â‚—[R] L'`, lift this to a morphism of type `RL â†’â‚[R] L'` (where `RL`
satisfies the universal property of the symmetric algebra of `L`)
-/
def lift {iM : L â†’â‚—[R] RL} (salg : IsSymmetricAlgebra iM) (phi : L â†’â‚—[R] L') : RL â†’â‚[R] L' :=
  (salg.ex_map phi).choose

/--
The lift `Ï†' : RL â†’â‚[R] L'` of a morhpism `Ï† : L â†’â‚—[R] L'` satisfies `Ï† = Ï†' âˆ˜ Î¹`
-/
theorem lift_spec {iM : L â†’â‚—[R] RL} (salg : IsSymmetricAlgebra iM) (phi : L â†’â‚—[R] L') :
         phi = (lift R salg phi).toLinearMap âˆ˜â‚— iM := (salg.ex_map phi).choose_spec.1

theorem comp_spec {M : Type u} [AddCommMonoid M] [Module R M]
         {RM RM' : Type u}
         [CommRing RM] [Algebra R RM] [CommRing RM'] [Algebra R RM']
         {iM : M â†’â‚—[R] RM} {iM' : M â†’â‚—[R] RM'}
         (salg : IsSymmetricAlgebra iM) (salg' : IsSymmetricAlgebra iM') :
  iM = ((AlgHom.comp (lift _ salg' iM) (lift _ salg iM')).toLinearMap) âˆ˜â‚— iM := by
  rw [AlgHom.comp_toLinearMap]
  rw [LinearMap.comp_assoc]
  rw [â† lift_spec _ salg iM']
  exact lift_spec _ salg' iM

/--
Two algebras RM and RM' satisfying the universal property for the symmetric algebra of M over R
must be isomorphic
-/
def isomorphismOfSymmetricAlgebraOfSymmetricAlgebra {M : Type u} [AddCommMonoid M] [Module R M]
         {RM RM' : Type u}
         [CommRing RM] [Algebra R RM] [CommRing RM'] [Algebra R RM']
         {iM : M â†’â‚—[R] RM} {iM' : M â†’â‚—[R] RM'}
         (salg : IsSymmetricAlgebra iM) (salg' : IsSymmetricAlgebra iM')
         : RM â‰ƒâ‚[R] RM' where
    toFun : RM â†’â‚[R] RM' := lift R salg iM'
    invFun : RM' â†’â‚[R] RM := lift R salg' iM

    left_inv := by
      rw [@Function.leftInverse_iff_comp]
      let Ï† := lift R salg iM'
      let Ïˆ := lift R salg' iM

      have h1 : iM' = Ï† âˆ˜â‚— iM := (salg.ex_map iM').choose_spec.1
      have h2 : iM = Ïˆ âˆ˜â‚— iM' := (salg'.ex_map iM).choose_spec.1
      have h3 : ((AlgHom.comp Ïˆ Ï†).toLinearMap) âˆ˜ iM = (AlgHom.id R RM).toLinearMap âˆ˜â‚— iM := by
        nth_rw 2 [h2]
        rw [h1]
        simp only [AlgHom.comp_toLinearMap, LinearMap.coe_comp, AlgHom.toLinearMap_id,
          LinearMap.id_comp, LieHom.coe_toLinearMap, AlgHom.coe_toLieHom]
        exact rfl

      have comp_spec := comp_spec _ salg salg'

      have prop1 : iM = (AlgHom.comp Ïˆ Ï†).toLinearMap âˆ˜â‚— iM := by exact comp_spec
      have prop2 : iM = (AlgHom.id R RM).toLinearMap âˆ˜â‚— iM := by exact rfl



      have h_unique := (salg.ex_map iM).unique prop1 prop2

      have eq: (AlgHom.comp Ïˆ Ï†) = (AlgHom.id R RM) := by exact h_unique
      unfold Ï† Ïˆ at eq
      have : (AlgHom.id R RM) = (id : RM â†’ RM) := by rfl
      have this1 : â‡‘(lift R salg' iM) âˆ˜ â‡‘(lift R salg iM') = (AlgHom.comp Ïˆ Ï†) := by rfl
      rw [â†this, this1, eq]

    right_inv := by
      rw [@Function.rightInverse_iff_comp]
      let Ï† := lift R salg iM'
      let Ïˆ := lift R salg' iM
      have h1 : iM' = Ï† âˆ˜â‚— iM := (salg.ex_map iM').choose_spec.1
      have h2 : iM = Ïˆ âˆ˜â‚— iM' := (salg'.ex_map iM).choose_spec.1
      have h3 : ((AlgHom.comp Ï† Ïˆ).toLinearMap) âˆ˜ iM' = (AlgHom.id R RM').toLinearMap âˆ˜â‚— iM' := by
        nth_rw 2 [h1]
        rw [h2]
        simp only [AlgHom.comp_toLinearMap, LinearMap.coe_comp, AlgHom.toLinearMap_id,
          LinearMap.id_comp, LieHom.coe_toLinearMap, AlgHom.coe_toLieHom]
        rfl

      have comp_spec := comp_spec _ salg' salg

      have prop1 : iM' = (AlgHom.comp Ï† Ïˆ).toLinearMap âˆ˜â‚— iM' := by exact comp_spec
      have prop2 : iM' = (AlgHom.id R RM').toLinearMap âˆ˜â‚— iM' := by exact rfl


      have h_unique := (salg'.ex_map iM').unique prop1 prop2

      have eq: (AlgHom.comp Ï† Ïˆ) = (AlgHom.id R RM') := by exact h_unique
      unfold Ï† Ïˆ at eq
      have : (AlgHom.id R RM') = (id : RM' â†’ RM') := by rfl
      have this1 : â‡‘(lift R salg iM') âˆ˜ â‡‘(lift R salg' iM) = (AlgHom.comp Ï† Ïˆ) := by rfl
      rw [â†this, this1, eq]
    map_mul' := by simp only [map_mul, implies_true]
    map_add' := by simp only [map_add, implies_true]
    commutes' := by simp only [AlgHom.commutes, implies_true]


variable (I : Type u) (basis_I : Basis I R L)

/--
Given a basis I of an R-module L, the polynomial ring with variables generated by the elements
of I satisfies the universal property of a symmetric algebra of L
-/
theorem mvPolynomial :
  IsSymmetricAlgebra (Basis.constr basis_I R (fun i â†¦ MvPolynomial.X i) : L â†’â‚—[R] MvPolynomial I R)
  where
  ex_map := by
    intro alg b c Ï†

    use MvPolynomial.aeval (R := R) (fun i => Ï† (basis_I i))
    constructor
    Â· apply Basis.ext basis_I
      intro i
      simp
    Â· intro f hf
      apply MvPolynomial.algHom_ext
      intro i
      simp only [aeval_X]
      rw [hf]
      simp only [LinearMap.coe_comp, LieHom.coe_toLinearMap, AlgHom.coe_toLieHom,
        Function.comp_apply, Basis.constr_basis, AlgHom.toLinearMap_apply]
