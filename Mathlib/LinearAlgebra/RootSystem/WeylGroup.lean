/-
Copyright (c) 2024 Scott Carnahan. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Carnahan
-/
import Mathlib.LinearAlgebra.RootSystem.Hom
import Mathlib.RepresentationTheory.Basic

/-!
# The Weyl group of a root pairing
This file defines the Weyl group of a root pairing as the subgroup of automorphisms generated by
reflection automorphisms. This deviates from the existing literature, which typically defines the
Weyl group as the subgroup of linear transformations of the weight space generated by linear
reflections. However, the automorphism group of a root pairing comes with a permutation
representation on the set indexing roots and faithful linear representations on the weight space and
coweight space.  Thus, our formalism gives us an isomorphism to the traditional Weyl group together
with the natural dual representation generated by coreflections and the permutation representation
on roots.
## Main definitions
* `RootPairing.weylGroup` : The group of automorphisms generated by reflections.
* `RootPairing.weylGroupToPerm` : The permutation representation of the Weyl group on roots.
## Results
* `RootPairing.range_weylGroup_weightHom` : The image of the weight space representation is equal
  to the subgroup generated by linear reflections.
* `RootPairing.range_weylGroup_coweightHom` : The image of the coweight space representation is
  equal to the subgroup generated by linear coreflections.
* `RootPairing.range_weylGroupToPerm` : The image of the permutation representation is equal to the
  subgroup generated by reflection permutations.
## TODO
* faithfulness of `weylGroupToPerm` when multiplication by 2 is injective on the weight space.
-/

open Set Function

variable {ι R M N : Type*}

noncomputable section

namespace RootPairing

variable [CommRing R] [AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N]
  (P : RootPairing ι R M N) (i : ι)

/-- The `Weyl group` of a root pairing is the group of automorphisms of the root pairing generated
by reflections. -/
def weylGroup : Subgroup (Aut P) :=
  Subgroup.closure (range (Equiv.reflection P))

lemma reflection_mem_weylGroup : Equiv.reflection P i ∈ P.weylGroup :=
  Subgroup.subset_closure <| mem_range_self i

/-- The `ith` reflection as a term of the Weyl group. -/
def weylGroup.ofIdx (i : ι) : P.weylGroup := ⟨_, P.reflection_mem_weylGroup i⟩

@[simp] lemma weylGroup.ofIdx_smul (i : ι) (m : M) :
    weylGroup.ofIdx P i • m = Equiv.reflection P i • m :=
  rfl

/-- Usually `RootPairing.weylGroup.induction` will be more useful than this lemma. -/
lemma weylGroup_toSubmonoid :
    P.weylGroup.toSubmonoid = Submonoid.closure (range (Equiv.reflection P)) := by
  suffices range (Equiv.reflection P) = (range (Equiv.reflection P))⁻¹ by
    rw [weylGroup, Subgroup.closure_toSubmonoid, ← this, union_self]
  ext; simp [← inv_eq_iff_eq_inv]

@[elab_as_elim]
lemma weylGroup.induction {pred : (g : Aut P) → g ∈ P.weylGroup → Prop}
    (mem : ∀ i, pred (Equiv.reflection P i) (P.reflection_mem_weylGroup i))
    (one : pred 1 (one_mem _))
    (mul : ∀ x y hx hy, pred x hx → pred y hy → pred (x * y) (mul_mem hx hy))
    {x} (hx : x ∈ P.weylGroup) :
    pred x hx := by
  let pred' : (g : Aut P) → g ∈ Submonoid.closure (range (Equiv.reflection P)) → Prop :=
    fun g hg ↦ pred g <| by change g ∈ P.weylGroup.toSubmonoid; rwa [weylGroup_toSubmonoid]
  have hx' : x ∈ Submonoid.closure (range (Equiv.reflection P)) := by rwa [← weylGroup_toSubmonoid]
  suffices pred' x hx' from this
  apply Submonoid.closure_induction
  · rintro - ⟨i, rfl⟩
    exact mem i
  · exact one
  · intro x y hx hy hx' hy'
    rw [← weylGroup_toSubmonoid] at hx hy
    exact mul x y hx hy hx' hy'

@[elab_as_elim]
lemma weylGroup.induction' [Nonempty ι] {pred : (g : Aut P) → g ∈ P.weylGroup → Prop}
    (mem : ∀ i, pred (Equiv.reflection P i) (P.reflection_mem_weylGroup i))
    (mul : ∀ x y hx hy, pred x hx → pred y hy → pred (x * y) (mul_mem hx hy))
    {x} (hx : x ∈ P.weylGroup) :
    pred x hx := by
  refine weylGroup.induction P mem ?_ mul hx
  obtain ⟨i⟩ : Nonempty ι := inferInstance
  have : (Equiv.reflection P i) ^ 2 = 1 := by
    rw [sq, mul_eq_one_iff_inv_eq, Equiv.reflection_inv P i]
  simpa [sq, ← this] using mul _ _ _ _ (mem i) (mem i)

lemma range_weylGroup_weightHom :
    MonoidHom.range ((Equiv.weightHom P).restrict P.weylGroup) =
      Subgroup.closure (range P.reflection) := by
  refine (Subgroup.closure_eq_of_le _ ?_ ?_).symm
  · rintro - ⟨i, rfl⟩
    simp only [MonoidHom.restrict_range, Subgroup.coe_map, Equiv.weightHom_apply, mem_image,
      SetLike.mem_coe]
    use Equiv.reflection P i
    exact ⟨reflection_mem_weylGroup P i, Equiv.reflection_weightEquiv P i⟩
  · rintro fg ⟨⟨w, hw⟩, rfl⟩
    induction hw using Subgroup.closure_induction'' with
    | one =>
      change ((Equiv.weightHom P).restrict P.weylGroup) 1 ∈ _
      simp only [map_one, one_mem]
    | mem w' hw' =>
      obtain ⟨i, rfl⟩ := hw'
      simp only [MonoidHom.restrict_apply, Equiv.weightHom_apply, Equiv.reflection_weightEquiv]
      simpa only [reflection_mem_weylGroup] using Subgroup.subset_closure (mem_range_self i)
    | inv_mem w' hw' =>
      obtain ⟨i, rfl⟩ := hw'
      simp only [Equiv.reflection_inv, MonoidHom.restrict_apply, Equiv.weightHom_apply,
        Equiv.reflection_weightEquiv]
      simpa only [reflection_mem_weylGroup] using Subgroup.subset_closure (mem_range_self i)
    | mul w₁ w₂ hw₁ hw₂ h₁ h₂ =>
      simpa only [← Submonoid.mk_mul_mk _ w₁ w₂ hw₁ hw₂, map_mul] using Subgroup.mul_mem _ h₁ h₂

lemma range_weylGroup_coweightHom :
    MonoidHom.range ((Equiv.coweightHom P).restrict P.weylGroup) =
      Subgroup.closure (range (MulOpposite.op ∘ P.coreflection)) := by
  refine (Subgroup.closure_eq_of_le _ ?_ ?_).symm
  · rintro - ⟨i, rfl⟩
    simp only [MonoidHom.restrict_range, Subgroup.coe_map, mem_image,
      SetLike.mem_coe]
    use Equiv.reflection P i
    refine ⟨reflection_mem_weylGroup P i, by simp⟩
  · rintro fg ⟨⟨w, hw⟩, rfl⟩
    induction hw using Subgroup.closure_induction'' with
    | one =>
      change ((Equiv.coweightHom P).restrict P.weylGroup) 1 ∈ _
      simp only [map_one, one_mem]
    | mem w' hw' =>
      obtain ⟨i, rfl⟩ := hw'
      simp only [MonoidHom.restrict_apply, Equiv.coweightHom_apply, Equiv.reflection_coweightEquiv]
      simpa only [reflection_mem_weylGroup] using Subgroup.subset_closure (mem_range_self i)
    | inv_mem w' hw' =>
      obtain ⟨i, rfl⟩ := hw'
      simp only [Equiv.reflection_inv, MonoidHom.restrict_apply, Equiv.coweightHom_apply,
        Equiv.reflection_coweightEquiv]
      simpa only [reflection_mem_weylGroup] using Subgroup.subset_closure (mem_range_self i)
    | mul w₁ w₂ hw₁ hw₂ h₁ h₂ =>
      simpa only [← Submonoid.mk_mul_mk _ w₁ w₂ hw₁ hw₂, map_mul] using Subgroup.mul_mem _ h₁ h₂

/-- The permutation representation of the Weyl group induced by `reflectionPerm`. -/
abbrev weylGroupToPerm := (Equiv.indexHom P).restrict P.weylGroup

lemma range_weylGroupToPerm :
    P.weylGroupToPerm.range = Subgroup.closure (range P.reflectionPerm) := by
  refine (Subgroup.closure_eq_of_le _ ?_ ?_).symm
  · rintro - ⟨i, rfl⟩
    simp only [MonoidHom.restrict_range, Subgroup.coe_map, mem_image,
      SetLike.mem_coe]
    use Equiv.reflection P i
    refine ⟨reflection_mem_weylGroup P i, by simp⟩
  · rintro fg ⟨⟨w, hw⟩, rfl⟩
    induction hw using Subgroup.closure_induction'' with
    | one =>
      change ((Equiv.indexHom P).restrict P.weylGroup) 1 ∈ _
      simp only [map_one, one_mem]
    | mem w' hw' =>
      obtain ⟨i, rfl⟩ := hw'
      simp only [MonoidHom.restrict_apply, Equiv.indexHom_apply, Equiv.reflection_indexEquiv]
      simpa only [reflection_mem_weylGroup] using Subgroup.subset_closure (mem_range_self i)
    | inv_mem w' hw' =>
      obtain ⟨i, rfl⟩ := hw'
      simp only [Equiv.reflection_inv, MonoidHom.restrict_apply, Equiv.indexHom_apply,
        Equiv.reflection_indexEquiv]
      simpa only [reflection_mem_weylGroup] using Subgroup.subset_closure (mem_range_self i)
    | mul w₁ w₂ hw₁ hw₂ h₁ h₂ =>
      simpa only [← Submonoid.mk_mul_mk _ w₁ w₂ hw₁ hw₂, map_mul] using Subgroup.mul_mem _ h₁ h₂

/-- The natural representation of the Weyl group on the root space. -/
def weylGroupRootRep : Representation R P.weylGroup M :=
  Representation.ofDistribMulAction R P.weylGroup M

/-- The natural representation of the Weyl group on the coroot space. -/
def weylGroupCorootRep : Representation R P.weylGroup.op N :=
  Representation.ofDistribMulAction R P.weylGroup.op N

lemma weylGroup_apply_root (g : P.weylGroup) (i : ι) :
    g • P.root i = P.root (P.weylGroupToPerm g i) :=
  Hom.root_weightMap_apply _ _ _ _

end RootPairing
