/-
Copyright (c) 2024 Scott Carnahan. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Carnahan
-/
import Mathlib.LinearAlgebra.RootSystem.Hom

/-!
# The Weyl group of a root pairing
This file defines the Weyl group of a root pairing as the subgroup of automorphisms generated by
reflection automorphisms. This deviates from the existing literature, which typically defines the
Weyl group as the subgroup of linear transformations of the weight space generated by linear
reflections. However, the automorphism group of a root pairing comes with a permutation
representation on the set indexing roots and faithful linear representations on the weight space and
coweight space.  Thus, our formalism gives us an isomorphism to the traditional Weyl group together
with the natural dual representation generated by coreflections and the permutation representation
on roots.
## Main definitions
 * `RootPairing.weylGroup` : The group of automorphisms generated by reflections.
 * `RootPairing.weylGroupToPerm` : The permutation representation of the Weyl group on roots.
## Results
 * `RootPairing.range_weylGroup_weightHom` : The image of the weight space representation is equal
   to the subgroup generated by linear reflections.
 * `RootPairing.range_weylGroup_coweightHom` : The image of the coweight space representation is
   equal to the subgroup generated by linear coreflections.
 * `RootPairing.range_weylGroupToPerm` : The image of the permutation representation is equal to the
   subgroup generated by reflection permutations.
## TODO
 * faithfulness of `weylGroupToPerm` when multiplication by 2 is injective on the weight space.
-/

open Set Function

variable {ι R M N : Type*}

noncomputable section

namespace RootPairing

variable  [CommRing R] [AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N]
  (P : RootPairing ι R M N) (i : ι)

/-- The `Weyl group` of a root pairing is the group of automorphisms of the root pairing generated
by reflections. -/
def weylGroup : Subgroup (Aut P) :=
  Subgroup.closure (range (Equiv.reflection P))

lemma reflection_mem_weylGroup : Equiv.reflection P i ∈ P.weylGroup :=
  Subgroup.subset_closure <| mem_range_self i

lemma range_weylGroup_weightHom :
    MonoidHom.range ((Equiv.weightHom P).restrict P.weylGroup) =
      Subgroup.closure (range P.reflection) := by
  refine (Subgroup.closure_eq_of_le _ ?_ ?_).symm
  · rintro - ⟨i, rfl⟩
    simp only [MonoidHom.restrict_range, Subgroup.coe_map, Equiv.weightHom_apply, mem_image,
      SetLike.mem_coe]
    use Equiv.reflection P i
    exact ⟨reflection_mem_weylGroup P i, Equiv.reflection_weightEquiv P i⟩
  · rintro fg ⟨⟨w, hw⟩, rfl⟩
    induction hw using Subgroup.closure_induction'' with
    | one =>
      change ((Equiv.weightHom P).restrict P.weylGroup) 1 ∈ _
      simpa only [map_one] using Subgroup.one_mem _
    | mem w' hw' =>
      obtain ⟨i, rfl⟩ := hw'
      simp only [MonoidHom.restrict_apply, Equiv.weightHom_apply, Equiv.reflection_weightEquiv]
      simpa only [reflection_mem_weylGroup] using Subgroup.subset_closure (mem_range_self i)
    | inv_mem w' hw' =>
      obtain ⟨i, rfl⟩ := hw'
      simp only [Equiv.reflection_inv, MonoidHom.restrict_apply, Equiv.weightHom_apply,
        Equiv.reflection_weightEquiv]
      simpa only [reflection_mem_weylGroup] using Subgroup.subset_closure (mem_range_self i)
    | mul w₁ w₂ hw₁ hw₂ h₁ h₂ =>
      simpa only [← Submonoid.mk_mul_mk _ w₁ w₂ hw₁ hw₂, map_mul] using Subgroup.mul_mem _ h₁ h₂

lemma range_weylGroup_coweightHom :
    MonoidHom.range ((Equiv.coweightHom P).restrict P.weylGroup) =
      Subgroup.closure (range (MulOpposite.op ∘ P.coreflection)) := by
  refine (Subgroup.closure_eq_of_le _ ?_ ?_).symm
  · rintro - ⟨i, rfl⟩
    simp only [MonoidHom.restrict_range, Subgroup.coe_map, Equiv.weightHom_apply, mem_image,
      SetLike.mem_coe]
    use Equiv.reflection P i
    refine ⟨reflection_mem_weylGroup P i, by simp⟩
  · rintro fg ⟨⟨w, hw⟩, rfl⟩
    induction hw using Subgroup.closure_induction'' with
    | one =>
      change ((Equiv.coweightHom P).restrict P.weylGroup) 1 ∈ _
      simpa only [map_one] using Subgroup.one_mem _
    | mem w' hw' =>
      obtain ⟨i, rfl⟩ := hw'
      simp only [MonoidHom.restrict_apply, Equiv.coweightHom_apply, Equiv.reflection_coweightEquiv]
      simpa only [reflection_mem_weylGroup] using Subgroup.subset_closure (mem_range_self i)
    | inv_mem w' hw' =>
      obtain ⟨i, rfl⟩ := hw'
      simp only [Equiv.reflection_inv, MonoidHom.restrict_apply, Equiv.coweightHom_apply,
        Equiv.reflection_coweightEquiv]
      simpa only [reflection_mem_weylGroup] using Subgroup.subset_closure (mem_range_self i)
    | mul w₁ w₂ hw₁ hw₂ h₁ h₂ =>
      simpa only [← Submonoid.mk_mul_mk _ w₁ w₂ hw₁ hw₂, map_mul] using Subgroup.mul_mem _ h₁ h₂

/-- The permutation representation of the Weyl group induced by `reflection_perm`. -/
abbrev weylGroupToPerm := (Equiv.indexHom P).restrict P.weylGroup

lemma range_weylGroupToPerm :
    P.weylGroupToPerm.range = Subgroup.closure (range P.reflection_perm) := by
  refine (Subgroup.closure_eq_of_le _ ?_ ?_).symm
  · rintro - ⟨i, rfl⟩
    simp only [MonoidHom.restrict_range, Subgroup.coe_map, Equiv.weightHom_apply, mem_image,
      SetLike.mem_coe]
    use Equiv.reflection P i
    refine ⟨reflection_mem_weylGroup P i, by simp⟩
  · rintro fg ⟨⟨w, hw⟩, rfl⟩
    induction hw using Subgroup.closure_induction'' with
    | one =>
      change ((Equiv.indexHom P).restrict P.weylGroup) 1 ∈ _
      simpa only [map_one] using Subgroup.one_mem _
    | mem w' hw' =>
      obtain ⟨i, rfl⟩ := hw'
      simp only [MonoidHom.restrict_apply, Equiv.indexHom_apply, Equiv.reflection_indexEquiv]
      simpa only [reflection_mem_weylGroup] using Subgroup.subset_closure (mem_range_self i)
    | inv_mem w' hw' =>
      obtain ⟨i, rfl⟩ := hw'
      simp only [Equiv.reflection_inv, MonoidHom.restrict_apply, Equiv.indexHom_apply,
        Equiv.reflection_indexEquiv]
      simpa only [reflection_mem_weylGroup] using Subgroup.subset_closure (mem_range_self i)
    | mul w₁ w₂ hw₁ hw₂ h₁ h₂ =>
      simpa only [← Submonoid.mk_mul_mk _ w₁ w₂ hw₁ hw₂, map_mul] using Subgroup.mul_mem _ h₁ h₂

end RootPairing
