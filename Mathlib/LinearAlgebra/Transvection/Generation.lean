/-
Copyright (c) 2025 Antoine Chambert-Loir. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Antoine Chambert-Loir
-/

module

public import Mathlib.LinearAlgebra.Center
public import Mathlib.LinearAlgebra.Transvection.Basic

/-!
# Dilatransvections generate the special linear group

We prove the theorem of [Dieudonné-1955][J. Dieudonné, “Sur les générateurs
des groupes classiques”].

Let `K` be a division ring and `V` be a finite dimensional `K`-vector space.

* `LinearEquiv.mem_transvections_pow_mul_dilatransvections_of_fixedReduce_eq_one`:
  If `e.fixedReduce = 1`, then `e` can be written as the product
  of `finrank K (V ⧸ e.fixedSubmodule) - 1` transvections
  and one dilatransvection.
  This is the first part of the non-exceptional case in Dieudonné's theorem.
  (This statement is not interesting when `e = 1`.)

* `LinearEquiv.mem_transvections_pow_mul_dilatransvections_of_fixedReduce_ne_smul_id`:
  If `e.fixedReduce` is not a homothety, then `e` can be written as the product
  of `finrank K (V ⧸ e.fixedSubmodule) - 1` transvections and one dilatransvection.
  This is the second part of the non-exceptional case in Dieudonné's theorem.

* `LinearEquiv.IsExceptional`:
  A linear equivalence `e : V ≃ₗ[K] V` is exceptional if `1 < finrank K (V ⧸ e.fixedSubmodule)`
  and if `e.fixedReduce` is a nontrivial homothety.

* `LinearEquiv.mem_dilatransvections_pow_of_not_isExceptional`:
  This is the non-exceptional case in Dieudonné's theorem,
  as a combination of the two preceding statements.

* `LinearEquiv.IsExceptional.mem_mul_transvections_pow_mul_dilatransvections':
  If a linear equivalence `e : V ≃ₗ[K] V] is exceptional,
  then it is the product of `finrank K (V ⧸ e.fixedSubmodule)`
  transvections and one dilatransvection.

* `LinearEquiv.subgroup_closure_dilatransvections_eq_top`:
  The group of linear equivalences is generated by dilatransvections.

## TODO

* Prove the third in Dieudonné's theorem that concerns the case where `e` is exceptional:
  `e` cannot be written as the product of `finrank K (V ⧸ e.fixedSubmodule) - 1`
  transvections and one dilatransvection.

* Prove that the general linear group is generated by dilatransvections.

* Prove that the special linear group is generated by transvections
  (with a bound on the minimal number of transvections needed).

* In the statements above, the dilatransvection is at the right of the product;
  show that it can be inserted anywhere.
  (The point is that transvections normalize dilatransvections.)

-/

@[expose] public section

namespace LinearEquiv

open Module.End Module MulAction Submodule LinearMap

open scoped Pointwise

variable {K : Type*} [DivisionRing K]
    {V : Type*} [AddCommGroup V] [Module K V] [Module.Finite K V]

variable (e f : V ≃ₗ[K] V)

theorem finrank_fixedSubmodule_add_le :
    finrank K e.fixedSubmodule + finrank K f.fixedSubmodule ≤
      finrank K ↥(e.fixedSubmodule ⊔ f.fixedSubmodule) +
        finrank K (e * f).fixedSubmodule := by
  have := finrank_mono (inf_fixedSubmodule_le_fixedSubmodule_mul e f)
  rwa [← Nat.add_le_add_iff_left, finrank_sup_add_finrank_inf_eq] at this

theorem finrank_le_one_add_finrank_fixedSubmodule_dilatransvection
    (he : e ∈ dilatransvections K V) :
    finrank K V ≤ 1 + finrank K e.fixedSubmodule := by
  rw [fixedSubmodule_eq_ker, add_comm, ← Nat.add_le_add_iff_left,
    ← add_assoc,finrank_range_add_finrank_ker, add_comm]
  simpa [← mem_dilatransvections_iff_finrank]

theorem le_one_add_finrank_fixedSubmodule_dilatransvection_mul (hf : f ∈ dilatransvections K V) :
    finrank K e.fixedSubmodule ≤ 1 + finrank K (f * e).fixedSubmodule := by
  have := finrank_fixedSubmodule_add_le f e
  have := finrank_le_one_add_finrank_fixedSubmodule_dilatransvection f hf
  have : finrank K ↥(f.fixedSubmodule ⊔ e.fixedSubmodule) ≤ finrank K V :=
    finrank_le _
  linarith

theorem finrank_fixedSubmodule_dilatransvection_mul_le (hf : f ∈ dilatransvections K V) :
     finrank K (f * e).fixedSubmodule ≤ 1 + finrank K e.fixedSubmodule := by
  conv_rhs => rw [show e = f⁻¹ * (f * e) from by aesop]
  rw [← inv_mem_dilatransvections_iff] at hf
  exact le_one_add_finrank_fixedSubmodule_dilatransvection_mul (f * e) f⁻¹ hf

theorem le_one_add_finrank_fixedSubmodule_mul_dilatransvection (hf : f ∈ dilatransvections K V) :
    finrank K e.fixedSubmodule ≤ 1 + finrank K (e * f).fixedSubmodule := by
  have := finrank_fixedSubmodule_add_le e f
  have := finrank_le_one_add_finrank_fixedSubmodule_dilatransvection f hf
  have : finrank K ↥(e.fixedSubmodule ⊔ f.fixedSubmodule) ≤ finrank K V :=
    finrank_le _
  linarith

theorem finrank_fixedSubmodule_mul_dilatransvection_le (hf : f ∈ dilatransvections K V) :
    finrank K (e * f).fixedSubmodule ≤ 1 + finrank K e.fixedSubmodule := by
  conv_rhs => rw [show e = (e * f) * f⁻¹ from by aesop]
  rw [← inv_mem_dilatransvections_iff] at hf
  exact le_one_add_finrank_fixedSubmodule_mul_dilatransvection (e * f) f⁻¹ hf



theorem fixedSubmodule_transvection_mul
    {f : Dual K V} {v : V} {e : V ≃ₗ[K] V}
    (hv : v ∉ e.fixedSubmodule) (hf : e.fixedSubmodule.map f = ⊥)
    (hfv : f (v - e v) = 0) (hfv' : f (e v) = 1) :
    (transvection hfv * e).fixedSubmodule = e.fixedSubmodule ⊔ (Submodule.span K {v}) := by
  symm
  suffices _ by
    apply Submodule.eq_of_le_of_finrank_le this
    rw [finrank_sup_span_singleton hv, add_comm]
    apply finrank_fixedSubmodule_dilatransvection_mul_le
    exact transvection_mem_dilatransvections hfv
  simp only [sup_le_iff, Submodule.span_singleton_le_iff_mem]
  have ht : e.fixedSubmodule ≤ (transvection hfv).fixedSubmodule := fun x hx ↦ by
    rw [mem_fixedSubmodule_transvection_iff, smul_eq_zero]
    left
    rw [← Submodule.mem_bot K, ← hf]
    exact mem_map_of_mem hx
  constructor
  · -- e.fixedSubmodule ≤ e'.fixedSubmodule
    intro x hx
    simp only [mem_fixedSubmodule_iff, LinearEquiv.mul_apply]
    suffices transvection hfv x = x by
      simp only [mem_fixedSubmodule_iff] at hx
      simp only [hx, this]
    rw [← mem_fixedSubmodule_iff]
    exact ht hx
  · -- u ∈ e.fixedSubmodule
    simp only [mem_fixedSubmodule_iff, LinearEquiv.mul_apply,
      transvection.apply]
    simp [hfv']


/-- A linear equivalence `u : V ≃ₗ[K] V` is exceptional if
it is a nontrivial homothety modulo `u.fixedSubmodule`. -/
abbrev IsExceptional (e : V ≃ₗ[K] V) : Prop :=
  1 < finrank K (V ⧸ e.fixedSubmodule) ∧
    e.fixedReduce ≠ 1 ∧ ∃ a : K, ∀ x, fixedReduce e x = a • x

/-- If `e : V ≃ₗ[K] V` is such that `e.fixedReduce = 1` and `e ≠ 1`,
then `e` is the product of at most `finrank K (V ⧸ e.fixedSubmodule) - 1` transvections
and one dilatransvection.

This is the first non-exceptional case in Dieudonné's theorem. -/
theorem mem_transvections_pow_mul_dilatransvections_of_fixedReduce_eq_one
    {e : V ≃ₗ[K] V} (he : e.fixedReduce = 1) :
    e ∈ transvections K V ^ (finrank K (V ⧸ e.fixedSubmodule) - 1)  * dilatransvections K V := by
  induction h : finrank K (V ⧸ e.fixedSubmodule) generalizing e he with
  | zero =>
    simp only [zero_tsub, pow_zero, one_mul]
    suffices e = 1 by
      rw [this]; exact one_mem_dilatransvections
    rw [← fixedSubmodule_eq_top_iff]
    apply Submodule.eq_top_of_finrank_eq
    rw [← Nat.add_right_inj (n := 0), ← h, Submodule.finrank_quotient_add_finrank,h, zero_add]
  | succ n hind =>
    match n with
    | 0 => simp [mem_dilatransvections_iff_finrank_quotient, h]
    | n + 1 =>
      simp only [add_assoc, Nat.reduceAdd] at h
      simp only [add_tsub_cancel_right]
      have : ∃ u : V, u ∉ e.fixedSubmodule := by
        by_contra! he
        rw [← Submodule.eq_top_iff'] at he
        rw [he, ← Nat.add_left_inj, Submodule.finrank_quotient_add_finrank, finrank_top] at h
        simp at h
      obtain ⟨u, hu⟩ := this
      obtain ⟨f, hfu, hf⟩ := Submodule.exists_dual_map_eq_bot_of_notMem hu inferInstance
      let v := (f u)⁻¹ • u
      have hv_notMem : v ∉ e.fixedSubmodule := by
        simpa only [v, Submodule.smul_mem_iff _ (inv_ne_zero hfu)]
      have hv : f v = 1 := by simp [v, inv_mul_cancel₀ hfu]
      have hv' : e v - v ∈ e.fixedSubmodule := by
        rw [← e.fixedSubmodule.ker_mkQ, LinearMap.mem_ker,
          map_sub, sub_eq_zero]
        simp [← fixedReduce_mk, he]
      have hv'' : v - e v ≠ 0 := by
        rwa [ne_eq, sub_eq_zero, eq_comm, ← mem_fixedSubmodule_iff]
      have hfv : f (v - e v) = 0 := by
        rw [← LinearMap.le_ker_iff_map] at hf
        rw [← LinearMap.mem_ker, ← neg_mem_iff, neg_sub]
        exact hf hv'
      set t := LinearEquiv.transvection hfv with ht
      have ht_fixed : e.fixedSubmodule ≤ t.fixedSubmodule := fun x hx ↦ by
        simp only [mem_fixedSubmodule_iff, ht, transvection.apply, add_eq_left, smul_eq_zero]
        rw [← LinearMap.le_ker_iff_map] at hf
        exact Or.inl (hf hx)
      rw [pow_succ', mul_assoc, Set.mem_mul]
      refine ⟨t⁻¹, ?_, t * e, ?_, by simp⟩
      · rw [inv_mem_transvections_iff, ht]
        exact mem_transvections hfv
      set e' := t * e with he'
      have he'_rank : finrank K (e.fixedSubmodule ⊔ Submodule.span K {v} : Submodule K V) =
          finrank K e.fixedSubmodule + 1 :=
        finrank_sup_span_singleton hv_notMem
      have he'_fixed : e'.fixedSubmodule = e.fixedSubmodule ⊔ Submodule.span K {v} := by
        simp only [e', ht]
        apply fixedSubmodule_transvection_mul hv_notMem hf hfv
        rw [← hv, eq_comm, ← sub_eq_zero, ← map_sub, hfv]
      simp only [add_tsub_cancel_right] at hind
      apply hind
      · simp only [one_eq_refl, fixedReduce_eq_one, he'_fixed] at he ⊢
        intro v
        simp only [he', ht, LinearEquiv.mul_apply, transvection.apply, add_sub_right_comm]
        apply Submodule.mem_sup_left
        apply Submodule.add_mem _ (he v)
        apply Submodule.smul_mem
        rwa [← Submodule.neg_mem_iff, neg_sub]
      · rw [← Nat.add_left_inj (n := 1), add_assoc]
        simp only [Nat.reduceAdd]
        rw [add_comm _ 1]
        rw [← Nat.add_left_inj, add_assoc, Submodule.finrank_quotient_add_finrank, he'_fixed]
        rw [he'_rank, ← h, ← add_assoc]
        rw [Submodule.finrank_quotient_add_finrank, add_comm]

/-- If an element `e : V ≃ₗ[K] V` is such that `e.fixedReduce`
is not a homothety, then `e` is the product of at
most `finrank K (V ⧸ e.fixedSubmodule) - 1` transvections
and one dilatransvection.

This is the second non-exceptional case in Dieudonné's theorem. -/
theorem mem_transvections_pow_mul_dilatransvections_of_fixedReduce_ne_smul_id
    {e : V ≃ₗ[K] V}
    (he : ∀ a : K, ∃ x, e.fixedReduce x ≠ a • x) :
    e ∈ transvections K V ^ (finrank K (V ⧸ e.fixedSubmodule) - 1) * dilatransvections K V := by
  induction h : finrank K (V ⧸ e.fixedSubmodule) generalizing e he with
  | zero =>
    -- this part is identical, makes a lemma ?
    simp only [zero_tsub, pow_zero, one_mul]
    suffices e = 1 by
      rw [this]; exact one_mem_dilatransvections
    rw [← fixedSubmodule_eq_top_iff]
    apply Submodule.eq_top_of_finrank_eq
    rw [← Nat.add_right_inj (n := 0), ← h, Submodule.finrank_quotient_add_finrank,h, zero_add]
  | succ n hind =>
    match n with
    | 0 => simp [mem_dilatransvections_iff_finrank_quotient, h]
    | n + 1 =>
      simp only [ne_eq, add_tsub_cancel_right] at hind ⊢
      simp only [add_assoc, Nat.reduceAdd] at h
      have : ∃ v, LinearIndependent K ![v, e.fixedReduce v] := by
        contrapose! he
        obtain ⟨a, ha, he⟩ :=
          LinearMap.exists_mem_center_apply_eq_smul_of_forall_notLinearIndependent
          (by simp [h]) he
        exact ⟨a, he⟩
      obtain ⟨v, hu⟩ := this
      have hu_spare := id hu
      obtain ⟨u, rfl⟩ := e.fixedSubmodule.mkQ_surjective v
      let t {f : Dual K V} {u : V} (hf : e.fixedSubmodule ⊔ K ∙ (e u - u) ≤ LinearMap.ker f) :
        V ≃ₗ[K] V :=
        transvection (f := f) (v := u - e u) (by
          simp only [← LinearMap.mem_ker]
          apply hf
          apply Submodule.mem_sup_right
          rw [mem_span_singleton]
          exact ⟨-1, by simp⟩)
      have ht_fixed {f : Dual K V} {u : V}
          (hf : e.fixedSubmodule ⊔ K ∙ (e u - u) ≤ LinearMap.ker f) :
          e.fixedSubmodule ≤ (t hf).fixedSubmodule := fun x hx ↦ by
        simp only [mem_fixedSubmodule_iff, t, transvection.apply, add_eq_left, smul_eq_zero]
        left
        rw [← LinearMap.mem_ker]
        apply hf
        apply Submodule.mem_sup_left hx
      have he'_fixed {f : Dual K V} {u : V}
        (hf : e.fixedSubmodule ⊔ K ∙ (e u - u) ≤ LinearMap.ker f)
        (hfu : f u = 1) :
        (t hf * e).fixedSubmodule = e.fixedSubmodule ⊔ Submodule.span K {u} := by
        apply fixedSubmodule_transvection_mul
        · intro hu'
          replace hu' := hf (mem_sup_left hu')
          rw [mem_ker] at hu'
          simp [hu'] at hfu
        · rw [eq_bot_iff]
          rw [Submodule.gc_map_comap, Submodule.comap_bot]
          exact le_trans le_sup_left hf
        rw [← hfu, ← sub_eq_zero, ← map_sub, ← mem_ker]
        refine hf (Submodule.mem_sup_right ?_)
        simp
      have hu' : e u ∉ e.fixedSubmodule ⊔ Submodule.span K {e u - u} := fun hu' ↦ by
        rw [Submodule.mem_sup] at hu'
        obtain ⟨y, hy, z, hz, hu'⟩ := hu'
        rw [Submodule.mem_span_singleton] at hz
        obtain ⟨a, rfl⟩ := hz
        simp only [LinearIndependent.pair_iff] at hu
        specialize hu a (1 - a) ?_
        · simp only [← LinearMap.map_smul, ← LinearEquiv.map_smul]
          simp only [Submodule.mkQ_apply, fixedReduce_mk]
          simp only [← Submodule.mkQ_apply, ← map_add, ← mem_ker,
           Submodule.ker_mkQ]
          convert hy
          rw [eq_comm, ← sub_eq_iff_eq_add, eq_comm] at hu'
          simp only [hu', smul_sub, sub_smul, one_smul, map_sub, map_smul]
          abel
        · aesop
      obtain ⟨f, hfu, hf⟩ := Submodule.exists_dual_map_eq_bot_of_notMem hu' inferInstance
      set v := (f u)⁻¹ • u with v_def
      replace hfu : f u ≠ 0 := by
        contrapose hfu
        rw [← hfu, ← sub_eq_zero, ← map_sub, ← Submodule.mem_bot K, ← hf]
        apply mem_map_of_mem
        apply mem_sup_right
        simp
      rw [← LinearIndependent.pair_smul_smul_iff
        (Ne.isUnit hfu).inv (Ne.isUnit hfu).inv] at hu
      simp only [← LinearMap.map_smul, ← LinearEquiv.map_smul, ← v_def] at hu
      have hfv : f v = 1 := by
        simp only [_root_.map_smul, smul_eq_mul, v]
        rw [inv_mul_cancel₀ hfu]
      have hfev : f (e v) = 1 := by
        rw [← hfv, ← sub_eq_zero, ← map_sub, ← Submodule.mem_bot K, ← hf]
        apply mem_map_of_mem
        apply mem_sup_right
        simp only [v, map_smul, ← smul_sub]
        apply smul_mem
        simp
      have he'_rank :
        finrank K (e.fixedSubmodule ⊔ Submodule.span K {v} : Submodule K V) =
          finrank K e.fixedSubmodule + 1 := by
        apply finrank_sup_span_singleton
        contrapose! hu'
        suffices e u = u by simp [this]
        simp only [mem_fixedSubmodule_iff, _root_.map_smul, v] at hu'
        rwa [IsUnit.smul_left_cancel ?_] at hu'
        simp [hfu]
      have he'_rank' :
        finrank K (V ⧸ (e.fixedSubmodule ⊔ Submodule.span K {v})) = n + 1 := by
        rw [← Nat.add_left_inj (n := 1), add_assoc]
        simp only [Nat.reduceAdd]
        rw [add_comm _ 1]
        rw [← Nat.add_left_inj, add_assoc, Submodule.finrank_quotient_add_finrank, he'_rank]
        rw [← h, ← add_assoc]
        rw [Submodule.finrank_quotient_add_finrank, add_comm]
      replace hf : map f (e.fixedSubmodule ⊔ K ∙ (e v - v)) = ⊥ := by
        suffices K ∙ (e v - v) = K ∙ (e u - u) by rwa [this]
        simp only [Submodule.span_singleton_eq_span_singleton]
        use (Ne.isUnit hfu).unit
        simp only [v_def, _root_.map_smul, Units.smul_isUnit]
        simp only [smul_sub, ← mul_smul, mul_inv_cancel₀ hfu, one_smul]
      rw [← le_ker_iff_map] at hf
      set e' := t hf * e with e'_def
      have e_def : e = (t hf)⁻¹ * e' := by simp [e'_def]
      by_cases he' : e' ∈ transvections K V ^ n * dilatransvections K V
      · -- this is the easy case where one knows that `e'` is
        -- the product of at most `n + 1` transvections
        rw [← inv_mul_eq_iff_eq_mul] at e'_def
        rw [← e'_def, pow_succ', mul_assoc, Set.mem_mul]
        refine ⟨(t hf)⁻¹, ?_, e', he', rfl⟩
        rw [inv_mem_transvections_iff]
        apply mem_transvections
      -- in the remaining case, the case `n = 0` is easy
      rcases Nat.eq_zero_or_pos n with hn0 | hn_pos
      · simp only [hn0, zero_add, pow_one, e_def]
        apply Set.mul_mem_mul
        · rw [inv_mem_transvections_iff]
          apply mem_transvections
        · rw [mem_dilatransvections_iff_finrank_quotient, e'_def,
            he'_fixed hf hfv, he'_rank', hn0, zero_add]
      -- and we will need to modify `e'` by changing `f`.
      -- the induction hypothesis implies that `e'.reduce` is a homothety
      have : ∃ a : K, ∀ x, e'.fixedReduce x = a • x := by
        contrapose! he'
        apply hind he'
        rw [he'_fixed hf hfv, he'_rank']
      obtain ⟨a, ha⟩ := this
      have hne_top : (e.fixedSubmodule ⊔ K ∙ (e v - v) ⊔ K ∙ v : Submodule K V) < ⊤ := by
        rw [lt_top_iff_ne_top]
        intro h
        suffices n + 1 ≤ 1 by
          apply Nat.pos_iff_ne_zero.mp hn_pos
          simpa using this
        rw [sup_right_comm] at h
        rw [← he'_rank', ← Nat.add_le_add_iff_right, finrank_quotient_add_finrank,
          ← finrank_top K V, ← h, add_comm]
        apply le_trans (Submodule.finrank_add_le_finrank_add_finrank _ _)
        simp only [add_le_add_iff_left]
        apply le_trans (finrank_span_le_card {e v - v})
        simp
      obtain ⟨g : Dual K V, hg1 : g ≠ 0, hg2⟩ :=
        Submodule.exists_dual_map_eq_bot_of_lt_top hne_top inferInstance
      have hg : e.fixedSubmodule ⊔ K ∙ (e v - v) ≤ LinearMap.ker (f + g) := fun x hx ↦ by
        rw [← le_ker_iff_map] at hg2
        suffices f x = 0 ∧ g x = 0 by simp [this.1, this.2]
        constructor
        · simpa using hf hx
        · simpa using hg2 (mem_sup_left hx)
      have hgv : g v = 0 := by
        rw [← Submodule.mem_bot K, ← hg2]
        apply mem_map_of_mem
        rw [sup_assoc]
        apply mem_sup_right
        apply mem_sup_right
        simp
      have hgev : g (e v) = 0 := by
        rw [← hgv, ← sub_eq_zero, ← map_sub, ← Submodule.mem_bot K, ← hg2]
        apply mem_map_of_mem
        apply mem_sup_left
        apply mem_sup_right
        simp
      have hfgv : (f + g) v = 1 := by
        simp [hfv, hgv]
      set e'' := t hg * e with e''_def
      -- TODO : do a lemma
      suffices e'' ∈ transvections K V ^ n * dilatransvections K V by
        rw [← inv_mul_eq_iff_eq_mul] at e''_def
        rw [← e''_def, pow_succ', mul_assoc, Set.mem_mul]
        refine ⟨(t hg)⁻¹, ?_, e'', this, rfl⟩
        rw [inv_mem_transvections_iff]
        apply mem_transvections
      apply hind
      · intro b
        by_contra! hb
        replace ha (x) : e' x - a • x ∈ e'.fixedSubmodule := by
          rw [← e'.fixedSubmodule.ker_mkQ, mem_ker, LinearMap.map_sub,
            LinearMap.map_smul, mkQ_apply, mkQ_apply, sub_eq_zero,
            ← fixedReduce_mk, ha]
        replace hb (x) : e'' x - b • x ∈ e''.fixedSubmodule := by
          rw [← e''.fixedSubmodule.ker_mkQ, mem_ker, LinearMap.map_sub,
            LinearMap.map_smul, mkQ_apply, mkQ_apply, sub_eq_zero,
            ← fixedReduce_mk, hb]
        have (x : V) : g (e x) • (v - e v) - (b - a) • x ∈ e.fixedSubmodule ⊔ K ∙ v := by
          specialize ha x
          specialize hb x
          simp only [e', he'_fixed hf hfv] at ha
          simp only [e'', he'_fixed hg hfgv] at hb
          simp only [LinearEquiv.mul_apply, transvection.apply, t] at ha hb
          rw [LinearMap.add_apply, add_smul, ← add_assoc] at hb
          convert Submodule.sub_mem _ hb ha using 1
          simp only [add_comm _ (g (e x) • _), ← add_assoc]
          rw [sub_eq_add_neg]
          simp only [add_sub_assoc, add_assoc]
          simp only [add_right_inj]
          simp only [sub_smul, smul_sub]
          abel
        exfalso
        set c := b - a
        by_cases hc : c = 0
        · simp only [hc, zero_smul, sub_zero] at this
          suffices ∃ x, g (e x) = 1 by
            obtain ⟨x, hx⟩ := this
            specialize this x
            simp only [hx, one_smul, mem_sup, mem_span_singleton, exists_exists_eq_and] at this ⊢
            obtain ⟨y, hy, k, this⟩ := this
            apply one_ne_zero (α := K)
            rw [LinearIndependent.pair_iff] at hu
            refine (hu (k - 1) 1 ?_).right
            -- refine (hu ((k - 1) * (f u)⁻¹) (f u)⁻¹ ?_).right
            simp only [Submodule.mkQ_apply, fixedReduce_mk]
            simp only [← e.fixedSubmodule.mkQ_apply, ← LinearMap.map_smul, ← map_add,
              ← LinearMap.mem_ker, Submodule.ker_mkQ]
            rw [← Submodule.neg_mem_iff] at hy
            convert hy using 1
            rw [eq_comm, ← sub_eq_iff_eq_add] at this
            rw [← this]
            simp only [sub_smul, one_smul]
            abel
          suffices ∃ w, g w ≠ 0 by
            obtain ⟨w, hw⟩ := this
            use (1 / g w) • e⁻¹ w
            simp [hw]
          contrapose! hg1
          rwa [LinearMap.ext_iff]
        · rw [lt_top_iff_ne_top] at hne_top
          apply hne_top
          rw [eq_top_iff]
          intro x _
          rw [sup_right_comm, Submodule.mem_sup]
          simp only [Submodule.mem_span_singleton, exists_exists_eq_and]
          specialize this x
          set z := g (e x) • (v - e v) - c • x with hz
          suffices that : - (1 / c) • z + (- 1/c * g (e x)) • (e v - v) = x by
            refine ⟨_, ?_, _, that⟩
            exact smul_mem (e.fixedSubmodule ⊔ K ∙ v) (-(1 / c)) this
          rw [← IsUnit.smul_left_cancel (a := c)]
          · simp only [one_div, neg_smul, smul_add, smul_neg, hz, ← mul_smul]
            simp only [← mul_assoc c, neg_div, mul_neg, one_div]
            simp only [mul_inv_cancel₀ hc, one_smul, neg_one_mul]
            rw [neg_sub, neg_smul, ← sub_eq_add_neg, sub_sub,
              ← smul_add]
            simp
          · rwa [isUnit_iff_ne_zero]
      · rw [he'_fixed hg, he'_rank']
        · simp only [LinearMap.add_apply, hfv, add_eq_left]
          rw [← Submodule.mem_bot K, ← hg2]
          apply Submodule.mem_map_of_mem
          rw [sup_assoc]
          apply Submodule.mem_sup_right
          simp only [mem_sup, mem_span_singleton, exists_exists_eq_and]
          use 0, 1 , by simp

/-- If an element `e : V ≃ₗ[K] V` is not exceptional,
then it is the product of at most `finrank K (V ⧸ e.fixedSubmodule)` dilatransvections.

This is the non-exceptional case in Dieudonné's theorem. -/
theorem mem_transvections_pow_mul_dilatransvections_of_notIsExceptional
    {e : V ≃ₗ[K] V} (he : ¬ IsExceptional e) :
    e ∈ transvections K V ^ (finrank K (V ⧸ e.fixedSubmodule) - 1) * dilatransvections K V := by
  simp only [not_and_or] at he
  push_neg at he
  rcases he with he | he | he
  · simpa [Nat.sub_eq_zero_of_le he, mem_dilatransvections_iff_finrank_quotient] using he
  · exact mem_transvections_pow_mul_dilatransvections_of_fixedReduce_eq_one he
  · exact mem_transvections_pow_mul_dilatransvections_of_fixedReduce_ne_smul_id he

/-- Any element of `V ≃ₗ[K] V`, is the product of `finrank K (V ⧸ e.fixedSubmodule)`
transvections and one dilatransvection. (Fourth part of Dieudonné's theorem). -/
theorem mem_transvections_pow_mul_dilatransvections :
    e ∈ transvections K V ^ (finrank K (V ⧸ e.fixedSubmodule)) * dilatransvections K V := by
  wlog he : IsExceptional e
  · obtain ⟨x, hx, y, hy, he⟩ := mem_transvections_pow_mul_dilatransvections_of_notIsExceptional he
    exact ⟨x, transvections_pow_mono (Nat.sub_le _ _) hx, y, hy, he⟩
  wlog finrank_le_add : 2 ≤ finrank K (V ⧸ e.fixedSubmodule)
  · rw [← one_mul e]
    apply Set.mul_mem_mul
    · apply transvections_pow_mono (zero_le _)
      simp
    rw [mem_dilatransvections_iff_finrank_quotient]
    simp only [not_le] at finrank_le_add
    exact Nat.le_of_succ_le_succ finrank_le_add
  have finrank_sup_span (x : V) : finrank K (e.fixedSubmodule ⊔ K ∙ x : Submodule K V) ≤
    finrank K e.fixedSubmodule + 1 := by
      rw [← Nat.add_le_add_iff_right, finrank_sup_add_finrank_inf_eq,
        add_assoc, add_le_add_iff_left]
      exact le_trans (finrank_span_le_card _) (by simp)
  have corank_eq_add_one : finrank K (V ⧸ e.fixedSubmodule) =
      (finrank K (V ⧸ e.fixedSubmodule) - 1) + 1 :=  by
    refine (Nat.sub_eq_iff_eq_add ?_).mp rfl
    exact le_trans (by norm_num) finrank_le_add
  rw [← Nat.add_le_add_iff_right, finrank_quotient_add_finrank] at finrank_le_add
  have (x : V) : e.fixedSubmodule ⊔ K ∙ x < ⊤ := by
    rw [lt_top_iff_ne_top]
    intro htop
    specialize finrank_sup_span x
    rw [htop, finrank_top, ← not_lt, ← Nat.succ_le_iff, Nat.succ_eq_add_one] at finrank_sup_span
    apply finrank_sup_span
    rw [add_assoc, add_comm]
    exact finrank_le_add
  obtain ⟨v, hv : v ∉ e.fixedSubmodule⟩ := by
    apply SetLike.exists_not_mem_of_ne_top e.fixedSubmodule
    intro h
    rw [h, finrank_top] at finrank_le_add
    simp at finrank_le_add
  obtain ⟨f, hf, hfker⟩ := Submodule.exists_dual_map_eq_bot_of_lt_top (this (e v)) inferInstance
  have hfv : f (e v) = 0 := by
    rw [← Submodule.mem_bot K, ← hfker]
    apply mem_map_of_mem (mem_sup_right _)
    simp
  set e' := (transvection hfv)⁻¹ * e with e'_def
  have he' : e = (transvection hfv) * e' := by simp [e']
  rw [corank_eq_add_one, he', pow_succ', mul_assoc]
  apply Set.mul_mem_mul (mem_transvections hfv)
  have he'_apply (x : V) : e' x = e x - f (e x) • e v := by
    rw [e'_def, LinearEquiv.mul_apply, coe_inv,
      transvection.symm_eq' hfv (by simp [hfv]), transvection.apply]
    simp [sub_eq_add_neg]
  have he_fixed : e.fixedSubmodule ≤ e'.fixedSubmodule := by
    intro x hx
    rw [mem_fixedSubmodule_iff, he'_apply]
    suffices f x = 0 by simp [mem_fixedSubmodule_iff.mp hx, this]
    rw [← Submodule.mem_bot K, ← hfker]
    exact mem_map_of_mem (mem_sup_left hx)
  obtain ⟨a, hea⟩ := he.2.2
  have ha1 : a ≠ 1 := fun h ↦ he.2.1 <| by
    ext x; simp [hea, h]
  rw [fixedReduce_eq_smul_iff] at hea
  have ha0 : a ≠ 0 := fun ha0 ↦ by
    apply hv
    suffices v = e (e⁻¹ v) by
      rw [this]
      simp only [ha0, zero_smul, sub_zero] at hea
      apply hea
    simp
  have hev : e v ∈ e.fixedSubmodule ⊔ K ∙ (e v) := by
    apply mem_sup_right
    simp
  have hv' : v ∈ e.fixedSubmodule ⊔ K ∙ (e v) := by
    rw [← smul_mem_iff _ ha0, ← sub_sub_cancel (e v) (a • v)]
    exact sub_mem hev (mem_sup_left (hea v))
  have he'_fixed : e'.fixedSubmodule = e.fixedSubmodule := by
    apply le_antisymm _ he_fixed
    intro x hx'
    simp only [mem_fixedSubmodule_iff, he'_apply] at hx'
    suffices f (e x) = 0 by simpa [this] using hx'
    rw [← Submodule.mem_bot K, ← hfker]
    apply mem_map_of_mem
    rw [ne_eq, ← sub_eq_zero, ← ne_eq] at ha1
    rw [← smul_mem_iff _ ha1]
    suffices (a - 1) • e x = a • f (e x) • e v - (e x - a • x) by
      rw [this]
      apply sub_mem _ (mem_sup_left (hea x))
      apply smul_mem
      apply smul_mem
      exact hev
    rw [sub_smul, one_smul]
    rw [sub_eq_iff_eq_add, add_comm, ← sub_eq_iff_eq_add] at hx'
    rw [← hx']
    simp only [smul_sub]
    abel
  rw [← he', ← he'_fixed]
  apply mem_transvections_pow_mul_dilatransvections_of_notIsExceptional
  rintro ⟨_, he'1, b, he'b⟩
  apply hv
  simp only [fixedReduce_eq_smul_iff, he'_apply] at he'b
  simp only [he'_fixed] at he'b
  have : ∀ x, (a - b) • x - f (e x) • e v ∈ e.fixedSubmodule := fun x ↦ by
    suffices (a - b) • x - f (e x) • e v =
      - (e x - a • x) + (e x - f (e x) • e v - b • x) by
      rw [this]
      exact add_mem (neg_mem_iff.mpr (hea x)) (he'b x)
    simp only [sub_smul]; abel
  have that : a = b := by
    rw [← sub_eq_zero]
    contrapose hv
    rw [← smul_mem_iff _ hv]
    simpa only [hfv, zero_smul, sub_zero] using this v
  simp only [that, sub_self, zero_smul, zero_sub, neg_mem_iff] at this
  replace this : e v ∈ e.fixedSubmodule := by
    have : ∃ x, f x ≠ 0 := by
      contrapose! hf
      exact LinearMap.ext hf
    obtain ⟨x, hx⟩ := this
    rw [← smul_mem_iff _ hx]
    simpa using this (e⁻¹ x)
  rw [← smul_mem_iff _ ha0, ← sub_add_cancel (a • v) (e v)]
  apply add_mem _ this
  rw [← neg_mem_iff]
  simpa using hea v

open Subgroup in
@[to_additive]
lemma closure_pow_le {G : Type*} [Group G] {s : Set G} :
    ∀ {n}, closure (s ^ n) ≤ closure s
  | 0 => by
    intro x hx
    simp only [pow_zero] at hx
    suffices x = 1 by simp [this]
    simpa [Subgroup.closure_eq_bot_iff.mpr ?_] using hx
  | n + 1 =>
    calc
      closure (s ^ (n + 1))
      _ = closure (s ^ n * s) := by rw [pow_succ]
      _ ≤ closure (s ^ n) ⊔ closure s := closure_mul_le ..
      _ ≤ closure s ⊔ closure s := by gcongr ?_ ⊔ _; exact closure_pow_le
      _ = closure s := sup_idem _

/-- The group of linear equivalences is generated by dilatransvections. -/
theorem subgroup_closure_dilatransvections_eq_top :
    Subgroup.closure (dilatransvections K V) = ⊤ := by
  rw [eq_top_iff]
  intro e _
  obtain ⟨x, hx, y, hy, rfl⟩ := mem_transvections_pow_mul_dilatransvections e
  apply mul_mem _ (Subgroup.mem_closure_of_mem hy)
  apply Subgroup.closure_mono transvections_subset_dilatransvections
  exact closure_pow_le (Subgroup.mem_closure_of_mem hx)

end LinearEquiv

end
