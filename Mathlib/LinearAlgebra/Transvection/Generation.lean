/-
Copyright (c) 2025 Antoine Chambert-Loir. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Antoine Chambert-Loir
-/

module

public import Mathlib.LinearAlgebra.Center
public import Mathlib.LinearAlgebra.Transvection.Basic
public import Mathlib.RingTheory.Finiteness.Prod
public import Mathlib.Algebra.BigOperators.Group.List.Basic

/-!
# Dilatransvections generate the special linear group

We prove the theorem of [Dieudonné-1955][J. Dieudonné, “Sur les générateurs
des groupes classiques”].

Let `K` be a division ring and `V` be a finite dimensional `K`-vector space.

* `LinearEquiv.mem_transvections_pow_mul_dilatransvections_of_fixedReduce_eq_one`:
  If `e.fixedReduce = 1`, then `e` can be written as the product
  of `finrank K (V ⧸ e.fixedSubmodule) - 1` transvections
  and one dilatransvection.
  This is the first part of the non-exceptional case in Dieudonné's theorem.
  (This statement is not interesting when `e = 1`.)

* `LinearEquiv.mem_transvections_pow_mul_dilatransvections_of_fixedReduce_ne_smul_id`:
  If `e.fixedReduce` is not a homothety, then `e` can be written as the product
  of `finrank K (V ⧸ e.fixedSubmodule) - 1` transvections and one dilatransvection.
  This is the second part of the non-exceptional case in Dieudonné's theorem.

* `LinearEquiv.IsExceptional`:
  A linear equivalence `e : V ≃ₗ[K] V` is exceptional if `1 < finrank K (V ⧸ e.fixedSubmodule)`
  and if `e.fixedReduce` is a nontrivial homothety.

* `LinearEquiv.mem_dilatransvections_pow_of_not_isExceptional`:
  This is the non-exceptional case in Dieudonné's theorem,
  as a combination of the two preceding statements.

* `LinearEquiv.IsExceptional.mem_mul_transvections_pow_mul_dilatransvections':
  If a linear equivalence `e : V ≃ₗ[K] V] is exceptional,
  then it is the product of `finrank K (V ⧸ e.fixedSubmodule)`
  transvections and one dilatransvection.

* `LinearEquiv.notIsExceptional_of_mem_transvections_mul_dilatransvections_pow`:
  if `e : V ≃ₗ[K] V` is a product of a transvection and of
  `finrank K (V ⧸ e.fixedSubmodule) - 1` dilatransvections,
  then it is not exceptional.

* `LinearEquiv.notIsExceptional_of_mem_transvections_pow_mul_dilatransvections`:
  if `e : V ≃ₗ[K] V` is a product of `finrank K (V ⧸ e.fixedSubmodule) - 1` transvections
  and one dilatransvection, then it is not exceptional.
  This is the third part in Dieudonné's theorem (and actually weaker than
  `LinearEquiv.notIsExceptional_of_mem_transvections_mul_dilatransvections_pow`).

* `LinearEquiv.mem_dilatransvections_pow`:
  a linear equivalence `e` is the product of `V ⧸ e.fixedSubmodule` dilatransvections.
  It follows from `LinearEquiv.finrank_quotient_fixedSubmodule_of_mem_dilatransvections_pow`
  that less than such many dilatransvections do not suffice.

* Prove that the general linear group is generated by dilatransvections.

* Prove that the special linear group is generated by transvections
  (with a bound on the minimal number of transvections needed).

* In the statements above, the dilatransvection is at the right of the product;
  show that it can be inserted anywhere.
  (The point is that transvections normalize dilatransvections.)

* `LinearEquiv.subgroup_closure_dilatransvections_eq_top`:
  The group of linear equivalences is generated by dilatransvections.

-/

@[expose] public section

namespace LinearEquiv

open Module.End Module MulAction Submodule LinearMap

open scoped Pointwise

section

open Subgroup in
@[to_additive]
lemma closure_pow_le {G : Type*} [Group G] {s : Set G} :
    ∀ {n}, closure (s ^ n) ≤ closure s
  | 0 => by
    intro x hx
    simp only [pow_zero] at hx
    suffices x = 1 by simp [this]
    simpa [Subgroup.closure_eq_bot_iff.mpr ?_] using hx
  | n + 1 =>
    calc
      closure (s ^ (n + 1))
      _ = closure (s ^ n * s) := by rw [pow_succ]
      _ ≤ closure (s ^ n) ⊔ closure s := closure_mul_le ..
      _ ≤ closure s ⊔ closure s := by gcongr ?_ ⊔ _; exact closure_pow_le
      _ = closure s := sup_idem _

theorem Finset.iInf_univ {R : Type*} [Semiring R]
    {V : Type*} [AddCommMonoid V] [Module R V]
    {ι : Type*} [Fintype ι] {p : ι → Submodule R V} :
    ⨅ i ∈ Finset.univ, p i = ⨅ i, p i := by
  simp only [Finset.mem_univ, iInf_pos]

open List in
theorem iInf_fixedSubmodule_le_fixedSubmodule_prod
    {R : Type*} [Semiring R]
    {V : Type*} [AddCommMonoid V] [Module R V]
    {n : ℕ} (f : Fin n → V ≃ₗ[R] V) :
    iInf (fun i ↦ (f i).fixedSubmodule) ≤
      ((List.finRange n).map f).prod.fixedSubmodule := by
  induction n with
  | zero => intro; simp
  | succ n hind =>
    intro x hx
    simp only [mem_iInf] at hx
    simp only [finRange_succ, map_cons, map_map, prod_cons]
    apply inf_fixedSubmodule_le_fixedSubmodule_mul
    simp only [mem_inf, hx 0, true_and]
    apply hind
    simp_all

theorem finrank_quotient_inf_le_finrank_quotient_add_finrank_quotient'
    {R : Type*} [Ring R] [StrongRankCondition R]
    {V : Type*} [AddCommGroup V] [Module R V] {P Q : Submodule R V}
    [Module.Finite R (V ⧸ P)] [Module.Free R (V ⧸ P)]
    [Module.Free R (V ⧸ Q)] [Module.Finite R (V ⧸ Q)] :
    finrank R (V ⧸ P ⊓ Q) ≤ finrank R (V ⧸ P) + finrank R (V ⧸ Q) := by
  suffices Function.Injective
    ((factor inf_le_left).prod (factor inf_le_right) : V ⧸ P ⊓ Q →ₗ[R] _) by
    convert finrank_le_finrank_of_injective this
    rw [Module.finrank_prod]
  rw [← LinearMap.ker_eq_bot, eq_bot_iff]
  intro x
  obtain ⟨x, rfl⟩ := Submodule.mkQ_surjective _ x
  simp [mem_ker, mem_bot]

variable {K : Type*} [DivisionRing K]
    {V : Type*} [AddCommGroup V] [Module K V] [Module.Finite K V]

theorem finrank_quotient_inf_le_finrank_quotient_add_finrank_quotient
    {P Q : Submodule K V} :
    finrank K (V ⧸ P ⊓ Q) ≤ finrank K (V ⧸ P) + finrank K (V ⧸ Q) := by
  rw [← Nat.add_le_add_iff_right, finrank_quotient_add_finrank]
  rw [← finrank_quotient_add_finrank P, add_assoc, add_le_add_iff_left]
  rw [add_comm, ← Nat.add_le_add_iff_right, add_assoc, finrank_quotient_add_finrank]
  rw [← finrank_sup_add_finrank_inf_eq, add_comm]
  simp only [add_le_add_iff_left, finrank_le]

theorem finrank_quotient_iInf_le_sum_finrank_quotient
    {ι : Type*} (s : Finset ι) (f : ι → Submodule K V) :
    finrank K (V ⧸ ⨅ i ∈ s, f i) ≤ ∑ i ∈ s , finrank K (V ⧸ f i) := by
  classical
  induction s using Finset.induction with
  | empty =>
    rw [iInf_eq_top.mpr (by simp), ← Nat.add_le_add_iff_right, finrank_quotient_add_finrank]
    simp
  | insert i s his hs =>
    rw [Finset.iInf_insert]
    apply le_trans finrank_quotient_inf_le_finrank_quotient_add_finrank_quotient
    simp [hs, Finset.sum_insert his]

end

variable {K : Type*} [DivisionRing K]
    {V : Type*} [AddCommGroup V] [Module K V] [Module.Finite K V]

variable (e f : V ≃ₗ[K] V)

/- ## General results on the behavior of `fixedSubmodule` and thir ranks under products -/

theorem finrank_fixedSubmodule_add_le :
    finrank K e.fixedSubmodule + finrank K f.fixedSubmodule ≤
      finrank K ↥(e.fixedSubmodule ⊔ f.fixedSubmodule) +
        finrank K (e * f).fixedSubmodule := by
  have := finrank_mono (inf_fixedSubmodule_le_fixedSubmodule_mul e f)
  rwa [← Nat.add_le_add_iff_left, finrank_sup_add_finrank_inf_eq] at this

theorem finrank_le_one_add_finrank_fixedSubmodule_dilatransvection
    (he : e ∈ dilatransvections K V) :
    finrank K V ≤ 1 + finrank K e.fixedSubmodule := by
  rw [fixedSubmodule_eq_ker, add_comm, ← Nat.add_le_add_iff_left,
    ← add_assoc,finrank_range_add_finrank_ker, add_comm]
  simpa [← mem_dilatransvections_iff_finrank]

theorem le_one_add_finrank_fixedSubmodule_dilatransvection_mul (hf : f ∈ dilatransvections K V) :
    finrank K e.fixedSubmodule ≤ 1 + finrank K (f * e).fixedSubmodule := by
  have := finrank_fixedSubmodule_add_le f e
  have := finrank_le_one_add_finrank_fixedSubmodule_dilatransvection f hf
  have : finrank K ↥(f.fixedSubmodule ⊔ e.fixedSubmodule) ≤ finrank K V :=
    finrank_le _
  linarith

theorem le_one_add_finrank_fixedSubmodule_dilatransvection_mul' (hf : f ∈ dilatransvections K V) :
    finrank K e.fixedSubmodule ≤ 1 + finrank K (e * f).fixedSubmodule := by
  have := finrank_fixedSubmodule_add_le e f
  have := finrank_le_one_add_finrank_fixedSubmodule_dilatransvection f hf
  have : finrank K ↥(e.fixedSubmodule ⊔ f.fixedSubmodule) ≤ finrank K V :=
    finrank_le _
  linarith

theorem finrank_fixedSubmodule_dilatransvection_mul_le (hf : f ∈ dilatransvections K V) :
     finrank K (f * e).fixedSubmodule ≤ 1 + finrank K e.fixedSubmodule := by
  conv_rhs => rw [show e = f⁻¹ * (f * e) from by aesop]
  rw [← inv_mem_dilatransvections_iff] at hf
  exact le_one_add_finrank_fixedSubmodule_dilatransvection_mul (f * e) f⁻¹ hf

theorem le_one_add_finrank_fixedSubmodule_mul_dilatransvection (hf : f ∈ dilatransvections K V) :
    finrank K e.fixedSubmodule ≤ 1 + finrank K (e * f).fixedSubmodule := by
  have := finrank_fixedSubmodule_add_le e f
  have := finrank_le_one_add_finrank_fixedSubmodule_dilatransvection f hf
  have : finrank K ↥(e.fixedSubmodule ⊔ f.fixedSubmodule) ≤ finrank K V :=
    finrank_le _
  linarith

theorem finrank_fixedSubmodule_mul_dilatransvection_le (hf : f ∈ dilatransvections K V) :
    finrank K (e * f).fixedSubmodule ≤ 1 + finrank K e.fixedSubmodule := by
  conv_rhs => rw [show e = (e * f) * f⁻¹ from by aesop]
  rw [← inv_mem_dilatransvections_iff] at hf
  exact le_one_add_finrank_fixedSubmodule_mul_dilatransvection (e * f) f⁻¹ hf

theorem finrank_quotient_fixedSubmodule_of_mem_dilatransvections_pow
    {n : ℕ} (he : e ∈ dilatransvections K V ^ n) :
    finrank K (V ⧸ e.fixedSubmodule) ≤ n := by
  induction n generalizing e with
  | zero =>
    simp only [pow_zero, Set.mem_one, ← fixedSubmodule_eq_top_iff] at he
    rw [← Nat.add_le_add_iff_right, finrank_quotient_add_finrank, zero_add]
    rw [he, finrank_top]
  | succ n hind =>
    rw [pow_succ] at he
    obtain ⟨f, hf, g, hg, rfl⟩ := he
    specialize hind f hf
    rw [← Nat.add_le_add_iff_right, finrank_quotient_add_finrank] at hind
    simp only
    rw [← Nat.add_le_add_iff_right, finrank_quotient_add_finrank]
    apply le_trans hind
    simp only [add_assoc, add_le_add_iff_left]
    exact le_one_add_finrank_fixedSubmodule_dilatransvection_mul' f g hg

theorem fixedSubmodule_transvection_mul
    {f : Dual K V} {v : V} {e : V ≃ₗ[K] V}
    (hv : v ∉ e.fixedSubmodule) (hf : e.fixedSubmodule.map f = ⊥)
    (hfv : f (v - e v) = 0) (hfv' : f (e v) = 1) :
    (transvection hfv * e).fixedSubmodule = e.fixedSubmodule ⊔ (Submodule.span K {v}) := by
  symm
  suffices _ by
    apply Submodule.eq_of_le_of_finrank_le this
    rw [finrank_sup_span_singleton hv, add_comm]
    apply finrank_fixedSubmodule_dilatransvection_mul_le
    exact transvection_mem_dilatransvections hfv
  simp only [sup_le_iff, Submodule.span_singleton_le_iff_mem]
  have ht : e.fixedSubmodule ≤ (transvection hfv).fixedSubmodule := fun x hx ↦ by
    rw [mem_fixedSubmodule_transvection_iff, smul_eq_zero]
    left
    rw [← Submodule.mem_bot K, ← hf]
    exact mem_map_of_mem hx
  constructor
  · -- e.fixedSubmodule ≤ e'.fixedSubmodule
    intro x hx
    simp only [mem_fixedSubmodule_iff, LinearEquiv.mul_apply]
    suffices transvection hfv x = x by
      simp only [mem_fixedSubmodule_iff] at hx
      simp only [hx, this]
    rw [← mem_fixedSubmodule_iff]
    exact ht hx
  · -- u ∈ e.fixedSubmodule
    simp only [mem_fixedSubmodule_iff, LinearEquiv.mul_apply,
      transvection.apply]
    simp [hfv']

/- ## Generation of non-exceptional linear equivalences. -/

/-- A linear equivalence `u : V ≃ₗ[K] V` is exceptional if
it is a nontrivial homothety modulo `u.fixedSubmodule`. -/
abbrev IsExceptional (e : V ≃ₗ[K] V) : Prop :=
  1 < finrank K (V ⧸ e.fixedSubmodule) ∧
    e.fixedReduce ≠ 1 ∧ ∃ a : K, ∀ x, fixedReduce e x = a • x

/-- If `e : V ≃ₗ[K] V` is such that `e.fixedReduce = 1` and `e ≠ 1`,
then `e` is the product of at most `finrank K (V ⧸ e.fixedSubmodule) - 1` transvections
and one dilatransvection.

This is the first non-exceptional case in Dieudonné's theorem. -/
theorem mem_transvections_pow_mul_dilatransvections_of_fixedReduce_eq_one
    {e : V ≃ₗ[K] V} (he : e.fixedReduce = 1) :
    e ∈ transvections K V ^ (finrank K (V ⧸ e.fixedSubmodule) - 1)  * dilatransvections K V := by
  induction h : finrank K (V ⧸ e.fixedSubmodule) generalizing e he with
  | zero =>
    simp only [zero_tsub, pow_zero, one_mul]
    suffices e = 1 by
      rw [this]; exact one_mem_dilatransvections
    rw [← fixedSubmodule_eq_top_iff]
    apply Submodule.eq_top_of_finrank_eq
    rw [← Nat.add_right_inj (n := 0), ← h, Submodule.finrank_quotient_add_finrank,h, zero_add]
  | succ n hind =>
    match n with
    | 0 => simp [mem_dilatransvections_iff_finrank_quotient, h]
    | n + 1 =>
      simp only [add_assoc, Nat.reduceAdd] at h
      simp only [add_tsub_cancel_right]
      have : ∃ u : V, u ∉ e.fixedSubmodule := by
        by_contra! he
        rw [← Submodule.eq_top_iff'] at he
        rw [he, ← Nat.add_left_inj, Submodule.finrank_quotient_add_finrank, finrank_top] at h
        simp at h
      obtain ⟨u, hu⟩ := this
      rw [pow_succ', mul_assoc, Set.mem_mul]
      --
      obtain ⟨f, hfu, hf⟩ := Submodule.exists_dual_map_eq_bot_of_notMem hu inferInstance
      let v := (f u)⁻¹ • u
      have hv_notMem : v ∉ e.fixedSubmodule := by
        simpa only [v, Submodule.smul_mem_iff _ (inv_ne_zero hfu)]
      have hv : f v = 1 := by simp [v, inv_mul_cancel₀ hfu]
      have hv' : e v - v ∈ e.fixedSubmodule := by
        rw [← e.fixedSubmodule.ker_mkQ, LinearMap.mem_ker,
          map_sub, sub_eq_zero]
        simp [← fixedReduce_mk, he]
      have hv'' : v - e v ≠ 0 := by
        rwa [ne_eq, sub_eq_zero, eq_comm, ← mem_fixedSubmodule_iff]
      have hfv : f (v - e v) = 0 := by
        rw [← LinearMap.le_ker_iff_map] at hf
        rw [← LinearMap.mem_ker, ← neg_mem_iff, neg_sub]
        exact hf hv'
      set t := LinearEquiv.transvection hfv with ht
      have ht_fixed : e.fixedSubmodule ≤ t.fixedSubmodule := fun x hx ↦ by
        simp only [mem_fixedSubmodule_iff, ht, transvection.apply, add_eq_left, smul_eq_zero]
        rw [← LinearMap.le_ker_iff_map] at hf
        exact Or.inl (hf hx)
      set e' := t * e with he'
      have he'_rank : finrank K (e.fixedSubmodule ⊔ Submodule.span K {v} : Submodule K V) =
          finrank K e.fixedSubmodule + 1 :=
        finrank_sup_span_singleton hv_notMem
      have he'_fixed : e'.fixedSubmodule = e.fixedSubmodule ⊔ Submodule.span K {v} := by
        simp only [e', ht]
        apply fixedSubmodule_transvection_mul hv_notMem hf hfv
        rw [← hv, eq_comm, ← sub_eq_zero, ← map_sub, hfv]
      refine ⟨t⁻¹, ?_, t * e, ?_, by simp⟩
      · rw [inv_mem_transvections_iff, ht]
        exact mem_transvections hfv
      simp only [add_tsub_cancel_right] at hind
      apply hind
      · simp only [one_eq_refl, fixedReduce_eq_one, ← he', he'_fixed] at he ⊢
        intro x
        simp only [he', ht, LinearEquiv.mul_apply, transvection.apply, add_sub_right_comm]
        apply Submodule.mem_sup_left
        apply Submodule.add_mem _ (he x)
        apply Submodule.smul_mem
        rwa [← Submodule.neg_mem_iff, neg_sub]
      · rw [← Nat.add_left_inj (n := 1), add_assoc]
        simp only [Nat.reduceAdd]
        rw [add_comm _ 1]
        rw [← Nat.add_left_inj, add_assoc, Submodule.finrank_quotient_add_finrank, he'_fixed]
        rw [he'_rank, ← h, ← add_assoc]
        rw [Submodule.finrank_quotient_add_finrank, add_comm]

/-- If an element `e : V ≃ₗ[K] V` is such that `e.fixedReduce`
is not a homothety, then `e` is the product of at
most `finrank K (V ⧸ e.fixedSubmodule) - 1` transvections
and one dilatransvection.

This is the second non-exceptional case in Dieudonné's theorem. -/
theorem mem_transvections_pow_mul_dilatransvections_of_fixedReduce_ne_smul_id
    {e : V ≃ₗ[K] V}
    (he : ∀ a : K, ∃ x, e.fixedReduce x ≠ a • x) :
    e ∈ transvections K V ^ (finrank K (V ⧸ e.fixedSubmodule) - 1) * dilatransvections K V := by
  induction h : finrank K (V ⧸ e.fixedSubmodule) generalizing e he with
  | zero =>
    -- this part is identical, makes a lemma ?
    simp only [zero_tsub, pow_zero, one_mul]
    suffices e = 1 by
      rw [this]; exact one_mem_dilatransvections
    rw [← fixedSubmodule_eq_top_iff]
    apply Submodule.eq_top_of_finrank_eq
    rw [← Nat.add_right_inj (n := 0), ← h, Submodule.finrank_quotient_add_finrank,h, zero_add]
  | succ n hind =>
    match n with
    | 0 => simp [mem_dilatransvections_iff_finrank_quotient, h]
    | n + 1 =>
      simp only [ne_eq, add_tsub_cancel_right] at hind ⊢
      simp only [add_assoc, Nat.reduceAdd] at h
      have : ∃ v, LinearIndependent K ![v, e.fixedReduce v] := by
        contrapose! he
        obtain ⟨a, ha, he⟩ :=
          LinearMap.exists_mem_center_apply_eq_smul_of_forall_notLinearIndependent
          (by simp [h]) he
        exact ⟨a, he⟩
      obtain ⟨v, hu⟩ := this
      have hu_spare := id hu
      obtain ⟨u, rfl⟩ := e.fixedSubmodule.mkQ_surjective v
      let t {f : Dual K V} {u : V} (hf : e.fixedSubmodule ⊔ K ∙ (e u - u) ≤ LinearMap.ker f) :
        V ≃ₗ[K] V :=
        transvection (f := f) (v := u - e u) (by
          simp only [← LinearMap.mem_ker]
          apply hf
          apply Submodule.mem_sup_right
          rw [mem_span_singleton]
          exact ⟨-1, by simp⟩)
      have ht_fixed {f : Dual K V} {u : V}
          (hf : e.fixedSubmodule ⊔ K ∙ (e u - u) ≤ LinearMap.ker f) :
          e.fixedSubmodule ≤ (t hf).fixedSubmodule := fun x hx ↦ by
        simp only [mem_fixedSubmodule_iff, t, transvection.apply, add_eq_left, smul_eq_zero]
        left
        rw [← LinearMap.mem_ker]
        apply hf
        apply Submodule.mem_sup_left hx
      have he'_fixed {f : Dual K V} {u : V}
        (hf : e.fixedSubmodule ⊔ K ∙ (e u - u) ≤ LinearMap.ker f)
        (hfu : f u = 1) :
        (t hf * e).fixedSubmodule = e.fixedSubmodule ⊔ Submodule.span K {u} := by
        apply fixedSubmodule_transvection_mul
        · intro hu'
          replace hu' := hf (mem_sup_left hu')
          rw [mem_ker] at hu'
          simp [hu'] at hfu
        · rw [eq_bot_iff]
          rw [Submodule.gc_map_comap, Submodule.comap_bot]
          exact le_trans le_sup_left hf
        rw [← hfu, ← sub_eq_zero, ← map_sub, ← mem_ker]
        refine hf (Submodule.mem_sup_right ?_)
        simp
      have hu' : e u ∉ e.fixedSubmodule ⊔ Submodule.span K {e u - u} := fun hu' ↦ by
        rw [Submodule.mem_sup] at hu'
        obtain ⟨y, hy, z, hz, hu'⟩ := hu'
        rw [Submodule.mem_span_singleton] at hz
        obtain ⟨a, rfl⟩ := hz
        simp only [LinearIndependent.pair_iff] at hu
        specialize hu a (1 - a) ?_
        · simp only [← LinearMap.map_smul, ← LinearEquiv.map_smul]
          simp only [Submodule.mkQ_apply, fixedReduce_mk]
          simp only [← Submodule.mkQ_apply, ← map_add, ← mem_ker,
           Submodule.ker_mkQ]
          convert hy
          rw [← add_left_inj, hu', map_smul]
          match_scalars <;> simp
        · aesop
      obtain ⟨f, hfu, hf⟩ := Submodule.exists_dual_map_eq_bot_of_notMem hu' inferInstance
      set v := (f u)⁻¹ • u with v_def
      replace hfu : f u ≠ 0 := by
        contrapose hfu
        rw [← hfu, ← sub_eq_zero, ← map_sub, ← Submodule.mem_bot K, ← hf]
        apply mem_map_of_mem
        apply mem_sup_right
        simp
      rw [← LinearIndependent.pair_smul_smul_iff
        (Ne.isUnit hfu).inv (Ne.isUnit hfu).inv] at hu
      simp only [← LinearMap.map_smul, ← LinearEquiv.map_smul, ← v_def] at hu
      have hfv : f v = 1 := by
        simp only [_root_.map_smul, smul_eq_mul, v]
        rw [inv_mul_cancel₀ hfu]
      have hfev : f (e v) = 1 := by
        rw [← hfv, ← sub_eq_zero, ← map_sub, ← Submodule.mem_bot K, ← hf]
        apply mem_map_of_mem
        apply mem_sup_right
        simp only [v, map_smul, ← smul_sub]
        apply smul_mem
        simp
      have he'_rank :
        finrank K (e.fixedSubmodule ⊔ Submodule.span K {v} : Submodule K V) =
          finrank K e.fixedSubmodule + 1 := by
        apply finrank_sup_span_singleton
        contrapose! hu'
        suffices e u = u by simp [this]
        simp only [mem_fixedSubmodule_iff, _root_.map_smul, v] at hu'
        rwa [IsUnit.smul_left_cancel ?_] at hu'
        simp [hfu]
      have he'_rank' :
        finrank K (V ⧸ (e.fixedSubmodule ⊔ Submodule.span K {v})) = n + 1 := by
        rw [← Nat.add_left_inj (n := 1), add_assoc]
        simp only [Nat.reduceAdd]
        rw [add_comm _ 1]
        rw [← Nat.add_left_inj, add_assoc, Submodule.finrank_quotient_add_finrank, he'_rank]
        rw [← h, ← add_assoc]
        rw [Submodule.finrank_quotient_add_finrank, add_comm]
      replace hf : map f (e.fixedSubmodule ⊔ K ∙ (e v - v)) = ⊥ := by
        suffices K ∙ (e v - v) = K ∙ (e u - u) by rwa [this]
        simp only [Submodule.span_singleton_eq_span_singleton]
        use (Ne.isUnit hfu).unit
        simp only [v_def, _root_.map_smul, Units.smul_isUnit]
        simp only [smul_sub, ← mul_smul, mul_inv_cancel₀ hfu, one_smul]
      rw [← le_ker_iff_map] at hf
      set e' := t hf * e with e'_def
      have e_def : e = (t hf)⁻¹ * e' := by simp [e'_def]
      by_cases he' : e' ∈ transvections K V ^ n * dilatransvections K V
      · -- this is the easy case where one knows that `e'` is
        -- the product of `n` transvections and one `dilatransvection`
        rw [← inv_mul_eq_iff_eq_mul] at e'_def
        rw [← e'_def, pow_succ', mul_assoc, Set.mem_mul]
        refine ⟨(t hf)⁻¹, ?_, e', he', rfl⟩
        rw [inv_mem_transvections_iff]
        apply mem_transvections
      -- in the remaining case, the case `n = 0` is easy
      rcases Nat.eq_zero_or_pos n with hn0 | hn_pos
      · simp only [hn0, zero_add, pow_one, e_def]
        apply Set.mul_mem_mul
        · rw [inv_mem_transvections_iff]
          apply mem_transvections
        · rw [mem_dilatransvections_iff_finrank_quotient, e'_def,
            he'_fixed hf hfv, he'_rank', hn0, zero_add]
      -- and we will need to modify `e'` by changing `f`.
      -- the induction hypothesis implies that `e'.reduce` is a homothety
      have : ∃ a : K, ∀ x, e'.fixedReduce x = a • x := by
        contrapose! he'
        apply hind he'
        rw [he'_fixed hf hfv, he'_rank']
      obtain ⟨a, ha⟩ := this
      have hne_top : (e.fixedSubmodule ⊔ K ∙ (e v - v) ⊔ K ∙ v : Submodule K V) < ⊤ := by
        rw [lt_top_iff_ne_top]
        intro h
        suffices n + 1 ≤ 1 by
          apply Nat.pos_iff_ne_zero.mp hn_pos
          simpa using this
        rw [sup_right_comm] at h
        rw [← he'_rank', ← Nat.add_le_add_iff_right, finrank_quotient_add_finrank,
          ← finrank_top K V, ← h, add_comm]
        apply le_trans (Submodule.finrank_add_le_finrank_add_finrank _ _)
        simp only [add_le_add_iff_left]
        apply le_trans (finrank_span_le_card {e v - v})
        simp
      obtain ⟨g : Dual K V, hg1 : g ≠ 0, hg2⟩ :=
        Submodule.exists_dual_map_eq_bot_of_lt_top hne_top inferInstance
      have hg : e.fixedSubmodule ⊔ K ∙ (e v - v) ≤ LinearMap.ker (f + g) := fun x hx ↦ by
        rw [← le_ker_iff_map] at hg2
        suffices f x = 0 ∧ g x = 0 by simp [this.1, this.2]
        constructor
        · simpa using hf hx
        · simpa using hg2 (mem_sup_left hx)
      have hgv : g v = 0 := by
        rw [← Submodule.mem_bot K, ← hg2]
        apply mem_map_of_mem
        rw [sup_assoc]
        apply mem_sup_right
        apply mem_sup_right
        simp
      have hgev : g (e v) = 0 := by
        rw [← hgv, ← sub_eq_zero, ← map_sub, ← Submodule.mem_bot K, ← hg2]
        apply mem_map_of_mem
        apply mem_sup_left
        apply mem_sup_right
        simp
      have hfgv : (f + g) v = 1 := by
        simp [hfv, hgv]
      set e'' := t hg * e with e''_def
      -- TODO : do a lemma?
      suffices e'' ∈ transvections K V ^ n * dilatransvections K V by
        rw [← inv_mul_eq_iff_eq_mul] at e''_def
        rw [← e''_def, pow_succ', mul_assoc, Set.mem_mul]
        refine ⟨(t hg)⁻¹, ?_, e'', this, rfl⟩
        rw [inv_mem_transvections_iff]
        apply mem_transvections
      apply hind
      · intro b
        by_contra! hb
        replace ha (x) : e' x - a • x ∈ e'.fixedSubmodule := by
          rw [← e'.fixedSubmodule.ker_mkQ, mem_ker, LinearMap.map_sub,
            LinearMap.map_smul, mkQ_apply, mkQ_apply, sub_eq_zero,
            ← fixedReduce_mk, ha]
        replace hb (x) : e'' x - b • x ∈ e''.fixedSubmodule := by
          rw [← e''.fixedSubmodule.ker_mkQ, mem_ker, LinearMap.map_sub,
            LinearMap.map_smul, mkQ_apply, mkQ_apply, sub_eq_zero,
            ← fixedReduce_mk, hb]
        have (x : V) : g (e x) • (v - e v) - (b - a) • x ∈ e.fixedSubmodule ⊔ K ∙ v := by
          specialize ha x
          specialize hb x
          simp only [e', he'_fixed hf hfv] at ha
          simp only [e'', he'_fixed hg hfgv] at hb
          simp only [LinearEquiv.mul_apply, transvection.apply, t] at ha hb
          rw [LinearMap.add_apply, add_smul, ← add_assoc] at hb
          convert Submodule.sub_mem _ hb ha using 1
          match_scalars <;> simp [sub_eq_neg_add a b]
        exfalso
        set c := b - a
        by_cases hc : c = 0
        · simp only [hc, zero_smul, sub_zero] at this
          suffices ∃ x, g (e x) = 1 by
            obtain ⟨x, hx⟩ := this
            specialize this x
            simp only [hx, one_smul, mem_sup, mem_span_singleton, exists_exists_eq_and] at this ⊢
            obtain ⟨y, hy, k, this⟩ := this
            apply one_ne_zero (α := K)
            rw [LinearIndependent.pair_iff] at hu
            refine (hu (k - 1) 1 ?_).right
            -- refine (hu ((k - 1) * (f u)⁻¹) (f u)⁻¹ ?_).right
            simp only [Submodule.mkQ_apply, fixedReduce_mk]
            simp only [← e.fixedSubmodule.mkQ_apply, ← LinearMap.map_smul, ← map_add,
              ← LinearMap.mem_ker, Submodule.ker_mkQ]
            rw [← Submodule.neg_mem_iff] at hy
            convert hy using 1
            rw [eq_comm, ← sub_eq_iff_eq_add] at this
            rw [← this]
            match_scalars <;> simp [sub_mul]
          suffices ∃ w, g w ≠ 0 by
            obtain ⟨w, hw⟩ := this
            use (1 / g w) • e⁻¹ w
            simp [hw]
          contrapose! hg1
          rwa [LinearMap.ext_iff]
        · rw [lt_top_iff_ne_top] at hne_top
          apply hne_top
          rw [eq_top_iff]
          intro x _
          rw [sup_right_comm, Submodule.mem_sup]
          simp only [Submodule.mem_span_singleton, exists_exists_eq_and]
          specialize this x
          set z := g (e x) • (v - e v) - c • x with hz
          suffices that : - (1 / c) • z + (- 1/c * g (e x)) • (e v - v) = x by
            refine ⟨_, ?_, _, that⟩
            exact smul_mem (e.fixedSubmodule ⊔ K ∙ v) (-(1 / c)) this
          rw [← IsUnit.smul_left_cancel (a := c)]
          · simp only [one_div, neg_smul, smul_add, smul_neg, hz, ← mul_smul]
            simp only [← mul_assoc c, neg_div, mul_neg, one_div]
            simp only [mul_inv_cancel₀ hc, one_smul, neg_one_mul]
            rw [neg_sub, neg_smul, ← sub_eq_add_neg, sub_sub,
              ← smul_add]
            simp
          · rwa [isUnit_iff_ne_zero]
      · rw [he'_fixed hg, he'_rank']
        · simp only [LinearMap.add_apply, hfv, add_eq_left]
          rw [← Submodule.mem_bot K, ← hg2]
          apply Submodule.mem_map_of_mem
          rw [sup_assoc]
          apply Submodule.mem_sup_right
          simp only [mem_sup, mem_span_singleton, exists_exists_eq_and]
          use 0, 1 , by simp

/-- If an element `e : V ≃ₗ[K] V` is not exceptional,
then it is the product of at most `finrank K (V ⧸ e.fixedSubmodule)` dilatransvections.

This is the non-exceptional case in Dieudonné's theorem. -/
theorem mem_transvections_pow_mul_dilatransvections_of_notIsExceptional
    {e : V ≃ₗ[K] V} (he : ¬ IsExceptional e) :
    e ∈ transvections K V ^ (finrank K (V ⧸ e.fixedSubmodule) - 1) * dilatransvections K V := by
  simp only [not_and_or] at he
  push_neg at he
  rcases he with he | he | he
  · simpa [Nat.sub_eq_zero_of_le he, mem_dilatransvections_iff_finrank_quotient] using he
  · exact mem_transvections_pow_mul_dilatransvections_of_fixedReduce_eq_one he
  · exact mem_transvections_pow_mul_dilatransvections_of_fixedReduce_ne_smul_id he

/- ## Generation of exceptional linear equivalences -/

/-- If an element of `V ≃ₗ[K] V` is exceptional, then it is the product
of `finrank K (V ⧸ e.fixedSubmodule)` transvections and one dilatransvection.
(Fourth part of Dieudonné's theorem). -/
theorem mem_transvections_pow_mul_dilatransvections :
    e ∈ transvections K V ^ (finrank K (V ⧸ e.fixedSubmodule)) * dilatransvections K V := by
  by_cases he : IsExceptional e; swap
  · have := mem_transvections_pow_mul_dilatransvections_of_notIsExceptional he
    rw [Set.mem_mul] at this ⊢
    obtain ⟨x, hx, y, hy, he⟩ := this
    refine ⟨x, ?_, y, hy, he⟩
    exact transvections_pow_mono (Nat.sub_le _ 1) hx
  wlog finrank_le_add : 2 ≤ finrank K (V ⧸ e.fixedSubmodule)
  · rw [← one_mul e]
    apply Set.mul_mem_mul
    · apply transvections_pow_mono (zero_le _)
      simp
    rw [mem_dilatransvections_iff_finrank_quotient]
    simp only [not_le] at finrank_le_add
    exact Nat.le_of_succ_le_succ finrank_le_add
  have finrank_sup_span (x : V) : finrank K (e.fixedSubmodule ⊔ K ∙ x : Submodule K V) ≤
    finrank K e.fixedSubmodule + 1 := by
      rw [← Nat.add_le_add_iff_right, finrank_sup_add_finrank_inf_eq,
        add_assoc, add_le_add_iff_left]
      exact le_trans (finrank_span_le_card _) (by simp)
  have corank_eq_add_one : finrank K (V ⧸ e.fixedSubmodule) =
      (finrank K (V ⧸ e.fixedSubmodule) - 1) + 1 :=  by
    refine (Nat.sub_eq_iff_eq_add ?_).mp rfl
    exact le_trans (by norm_num) finrank_le_add
  rw [← Nat.add_le_add_iff_right, finrank_quotient_add_finrank] at finrank_le_add
  have (x : V) : e.fixedSubmodule ⊔ K ∙ x < ⊤ := by
    rw [lt_top_iff_ne_top]
    intro htop
    specialize finrank_sup_span x
    rw [htop, finrank_top, ← not_lt, ← Nat.succ_le_iff, Nat.succ_eq_add_one] at finrank_sup_span
    apply finrank_sup_span
    rw [add_assoc, add_comm]
    exact finrank_le_add
  obtain ⟨v, hv : v ∉ e.fixedSubmodule⟩ := by
    apply SetLike.exists_not_mem_of_ne_top e.fixedSubmodule
    intro h
    rw [h, finrank_top] at finrank_le_add
    simp at finrank_le_add
  obtain ⟨f, hf, hfker⟩ := Submodule.exists_dual_map_eq_bot_of_lt_top (this (e v)) inferInstance
  have hfv : f (e v) = 0 := by
    rw [← Submodule.mem_bot K, ← hfker]
    apply mem_map_of_mem (mem_sup_right _)
    simp
  set e' := (transvection hfv)⁻¹ * e with e'_def
  have he' : e = (transvection hfv) * e' := by simp [e']
  rw [corank_eq_add_one, he', pow_succ', mul_assoc]
  apply Set.mul_mem_mul (mem_transvections hfv)
  have he'_apply (x : V) : e' x = e x - f (e x) • e v := by
    rw [e'_def, LinearEquiv.mul_apply, coe_inv,
      transvection.symm_eq' hfv (by simp [hfv]), transvection.apply]
    simp [sub_eq_add_neg]
  have he_fixed : e.fixedSubmodule ≤ e'.fixedSubmodule := by
    intro x hx
    rw [mem_fixedSubmodule_iff, he'_apply]
    suffices f x = 0 by simp [mem_fixedSubmodule_iff.mp hx, this]
    rw [← Submodule.mem_bot K, ← hfker]
    exact mem_map_of_mem (mem_sup_left hx)
  obtain ⟨a, hea⟩ := he.2.2
  have ha1 : a ≠ 1 := fun h ↦ he.2.1 <| by
    ext x; simp [hea, h]
  rw [fixedReduce_eq_smul_iff] at hea
  have ha0 : a ≠ 0 := fun ha0 ↦ by
    apply hv
    suffices v = e (e⁻¹ v) by
      rw [this]
      simp only [ha0, zero_smul, sub_zero] at hea
      apply hea
    simp
  have hev : e v ∈ e.fixedSubmodule ⊔ K ∙ (e v) := by
    apply mem_sup_right
    simp
  have hv' : v ∈ e.fixedSubmodule ⊔ K ∙ (e v) := by
    rw [← smul_mem_iff _ ha0, ← sub_sub_cancel (e v) (a • v)]
    exact sub_mem hev (mem_sup_left (hea v))
  have he'_fixed : e'.fixedSubmodule = e.fixedSubmodule := by
    apply le_antisymm _ he_fixed
    intro x hx'
    simp only [mem_fixedSubmodule_iff, he'_apply] at hx'
    suffices f (e x) = 0 by simpa [this] using hx'
    rw [← Submodule.mem_bot K, ← hfker]
    apply mem_map_of_mem
    rw [ne_eq, ← sub_eq_zero, ← ne_eq] at ha1
    rw [← smul_mem_iff _ ha1]
    suffices (a - 1) • e x = a • f (e x) • e v - (e x - a • x) by
      rw [this]
      apply sub_mem _ (mem_sup_left (hea x))
      apply smul_mem
      apply smul_mem
      exact hev
    nth_rewrite 4 [← hx']
    match_scalars <;> simp
  rw [← he', ← he'_fixed]
  apply mem_transvections_pow_mul_dilatransvections_of_notIsExceptional
  rintro ⟨_, he'1, b, he'b⟩
  apply hv
  simp only [fixedReduce_eq_smul_iff, he'_apply] at he'b
  simp only [he'_fixed] at he'b
  have : ∀ x, (a - b) • x - f (e x) • e v ∈ e.fixedSubmodule := fun x ↦ by
    suffices (a - b) • x - f (e x) • e v =
      - (e x - a • x) + (e x - f (e x) • e v - b • x) by
      rw [this]
      exact add_mem (neg_mem_iff.mpr (hea x)) (he'b x)
    match_scalars <;> simp [sub_eq_add_neg]
  have that : a = b := by
    rw [← sub_eq_zero]
    contrapose hv
    rw [← smul_mem_iff _ hv]
    simpa [hfv] using this v
  simp only [that, sub_self, zero_smul, zero_sub, neg_mem_iff] at this
  replace this : e v ∈ e.fixedSubmodule := by
    have : ∃ x, f x ≠ 0 := by
      contrapose! hf
      exact LinearMap.ext hf
    obtain ⟨x, hx⟩ := this
    rw [← smul_mem_iff _ hx]
    simpa using this (e⁻¹ x)
  rw [← smul_mem_iff _ ha0, ← sub_add_cancel (a • v) (e v)]
  apply add_mem _ this
  rw [← neg_mem_iff]
  simpa using hea v

omit [Module.Finite K V] in
theorem reduce_mem_transvections {W : Submodule K V}
    (hW : W ≤ e.fixedSubmodule) (he_mem : e ∈ transvections K V) :
    reduce W ⟨e, mem_stabilizer_submodule_of_le_fixedSubmodule hW⟩ ∈ transvections K (V ⧸ W) := by
  obtain ⟨f, v, hfv, he⟩ := he_mem
  by_cases he1: e = 1
  · convert one_mem_transvections
    ext x
    obtain ⟨x, rfl⟩ := W.mkQ_surjective x
    simp [he1]
  have hf : W ≤ ker f := fun x hx ↦ by
    replace hx := hW hx
    simp only [he, mem_fixedSubmodule_iff, transvection.coe_apply, LinearMap.transvection.apply,
      add_eq_left, smul_eq_zero, ← mem_ker] at hx
    apply Or.resolve_right hx
    contrapose he1
    simp [he, he1, one_eq_refl]
  use W.liftQ f hf, W.mkQ v, by simp [hfv]
  ext x
  obtain ⟨x, rfl⟩ := W.mkQ_surjective x
  simp [he, LinearMap.transvection.apply]

theorem reduce_mem_dilatransvections {W : Submodule K V}
    (hW : W ≤ e.fixedSubmodule) (he_mem : e ∈ dilatransvections K V) :
    reduce W ⟨e, mem_stabilizer_submodule_of_le_fixedSubmodule hW⟩ ∈
      dilatransvections K (V ⧸ W) := by
  rw [mem_dilatransvections_iff_finrank, finrank_le_one_iff] at ⊢ he_mem
  obtain ⟨⟨v, ⟨x, hx⟩⟩, hv⟩ := he_mem
  use ⟨W.mkQ v, ?_⟩
  · rintro ⟨_, ⟨y, rfl⟩⟩
    obtain ⟨z, rfl⟩ := W.mkQ_surjective y
    obtain ⟨c, hc⟩ := hv ⟨e z - z, ⟨z, by simp⟩⟩
    use c
    rw [← (Submodule.subtype_injective _).eq_iff, LinearMap.map_smul, subtype_apply] at hc
    rw [← (Submodule.subtype_injective _).eq_iff]
    simp [← Submodule.Quotient.mk_smul, hc]
  · use W.mkQ x
    simp [← hx]

theorem fixedReduce_mem_dilatransvections_pow
    (he : e ∈ dilatransvections K V ^ (finrank K (V ⧸ e.fixedSubmodule))) :
    e.fixedReduce ∈
      dilatransvections K (V ⧸ e.fixedSubmodule) ^ (finrank K (V ⧸ e.fixedSubmodule)) := by
  rw [Set.mem_pow] at he
  obtain ⟨l, hl⟩ := he
  have iInf_eq : iInf (fun i ↦ (l i).val.fixedSubmodule) = e.fixedSubmodule := by
    apply Submodule.eq_of_le_of_finrank_le
    · simp_rw [← hl, List.ofFn_eq_map]
      apply le_of_le_of_eq (iInf_fixedSubmodule_le_fixedSubmodule_prod _)
      simp
    · rw [← Nat.add_le_add_iff_left, finrank_quotient_add_finrank]
      rw [← finrank_quotient_add_finrank, Nat.add_le_add_iff_right, ← Finset.iInf_univ]
      apply le_trans (finrank_quotient_iInf_le_sum_finrank_quotient
        Finset.univ (f := fun i ↦ (l i).val.fixedSubmodule))
      apply le_trans (Finset.sum_le_card_nsmul _ _ (n := 1) ?_)
      · simp
      intro i _
      rw [← mem_dilatransvections_iff_finrank_quotient]
      exact (l i).prop
  have hl' (i) : (l i).val ∈ stabilizer (V ≃ₗ[K] V) e.fixedSubmodule :=
   by
     apply mem_stabilizer_submodule_of_le_fixedSubmodule
     simp only [← iInf_eq, iInf_le]
  suffices e.fixedReduce = (List.ofFn (reduce e.fixedSubmodule ∘ fun i ↦ ⟨l i, hl' i⟩)).prod by
    rw [this,  Set.mem_pow]
    use fun i ↦ ⟨reduce e.fixedSubmodule ⟨l i, hl' i⟩, by
      apply reduce_mem_dilatransvections _ (by simp only [← iInf_eq, iInf_le])
      exact (l i).prop⟩
    congr
  simp only [fixedReduce, ← hl, List.ofFn_eq_map]
  rw [List.prod_map_hom]
  apply congr_arg
  aesop

theorem fixedReduce_mem_transvections_pow_mul_dilatransvections
    (hV : 1 ≤ finrank K (V ⧸ e.fixedSubmodule))
    (he : e ∈ transvections K V ^ (finrank K (V ⧸ e.fixedSubmodule) - 1) * dilatransvections K V) :
    e.fixedReduce ∈
      transvections K (V ⧸ e.fixedSubmodule) ^ (finrank K (V ⧸ e.fixedSubmodule) - 1) *
        dilatransvections K (V ⧸ e.fixedSubmodule) := by
  rw [Set.mem_mul] at he
  obtain ⟨f, hf, g, hg, hfg⟩ := he
  rw [Set.mem_pow] at hf
  obtain ⟨l, hf⟩ := hf
  have iInf_eq : iInf (fun i ↦ (l i).val.fixedSubmodule) ⊓ g.fixedSubmodule = e.fixedSubmodule := by
    apply Submodule.eq_of_le_of_finrank_le
    · simp_rw [← hfg, ← hf, List.ofFn_eq_map]
      apply le_trans (inf_le_inf_right _ _)
        (inf_fixedSubmodule_le_fixedSubmodule_mul _ _)
      apply iInf_fixedSubmodule_le_fixedSubmodule_prod
    · rw [← Nat.add_le_add_iff_left, finrank_quotient_add_finrank]
      rw [← finrank_quotient_add_finrank, Nat.add_le_add_iff_right]
      apply le_trans finrank_quotient_inf_le_finrank_quotient_add_finrank_quotient
      rw [mem_dilatransvections_iff_finrank_quotient] at hg
      apply le_trans (add_le_add_right hg _)
      rw [← le_tsub_iff_right hV, ← Finset.iInf_univ]
      have := finrank_quotient_iInf_le_sum_finrank_quotient
        Finset.univ (f := fun i ↦ (l i).val.fixedSubmodule)
      apply le_trans this
      apply le_trans (Finset.sum_le_card_nsmul _ _ (n := 1) ?_)
      · simp
      intro i _
      rw [← mem_dilatransvections_iff_finrank_quotient]
      apply transvections_subset_dilatransvections
      exact (l i).prop
  have hg_mem_stabilizer : g ∈ stabilizer (V ≃ₗ[K] V) e.fixedSubmodule := by
    apply mem_stabilizer_submodule_of_le_fixedSubmodule
    simp only [← iInf_eq, inf_le_right]
  have hl_mem_stabilizer (i) : (l i).val ∈ stabilizer (V ≃ₗ[K] V) e.fixedSubmodule := by
    apply mem_stabilizer_submodule_of_le_fixedSubmodule
    simp only [← iInf_eq]
    exact le_trans inf_le_left (iInf_le _ _)
  suffices e.fixedReduce =
    (List.ofFn (reduce e.fixedSubmodule ∘ fun i ↦ ⟨l i, hl_mem_stabilizer i⟩)).prod *
      reduce e.fixedSubmodule ⟨g, hg_mem_stabilizer⟩ by
    rw [this, Set.mem_mul]
    refine ⟨_, ?_, _, ?_, rfl⟩
    · rw [Set.mem_pow]
      refine ⟨fun i ↦ ⟨reduce e.fixedSubmodule ⟨l i, hl_mem_stabilizer i⟩, ?_⟩, by congr⟩
      apply reduce_mem_transvections _ _ (l i).prop
      simp only [← iInf_eq]
      exact le_trans inf_le_left (iInf_le _ _)
    · apply reduce_mem_dilatransvections _ _ hg
      simp only [← iInf_eq, inf_le_right]
  simp only [fixedReduce, ← hfg, ← hf, List.ofFn_eq_map, List.prod_map_hom, ← map_mul]
  apply congr_arg
  rw [← Subtype.coe_inj]
  aesop

theorem fixedReduce_mem_transvections_mul_dilatransvections_pow
    (hV : 1 ≤ finrank K (V ⧸ e.fixedSubmodule))
    (he : e ∈ transvections K V * dilatransvections K V ^ (finrank K (V ⧸ e.fixedSubmodule) - 1)) :
    e.fixedReduce ∈
      transvections K (V ⧸ e.fixedSubmodule) *
        dilatransvections K (V ⧸ e.fixedSubmodule) ^ (finrank K (V ⧸ e.fixedSubmodule) - 1) := by
  rw [Set.mem_mul] at he
  obtain ⟨f, hf, g, hg, hfg⟩ := he
  rw [Set.mem_pow] at hg
  obtain ⟨l, hg⟩ := hg
  have iInf_eq : f.fixedSubmodule ⊓ iInf (fun i ↦ (l i).val.fixedSubmodule) = e.fixedSubmodule := by
    apply Submodule.eq_of_le_of_finrank_le
    · simp_rw [← hfg, ← hg, List.ofFn_eq_map]
      apply le_trans (inf_le_inf_left _ _)
        (inf_fixedSubmodule_le_fixedSubmodule_mul _ _)
      apply iInf_fixedSubmodule_le_fixedSubmodule_prod
    · rw [← Nat.add_le_add_iff_left, finrank_quotient_add_finrank]
      rw [← finrank_quotient_add_finrank, Nat.add_le_add_iff_right]
      apply le_trans finrank_quotient_inf_le_finrank_quotient_add_finrank_quotient
      have hf' := transvections_subset_dilatransvections hf
      rw [mem_dilatransvections_iff_finrank_quotient] at hf'
      apply le_trans (add_le_add_left hf' _)
      rw [← le_tsub_iff_left hV, ← Finset.iInf_univ]
      have := finrank_quotient_iInf_le_sum_finrank_quotient
        Finset.univ (f := fun i ↦ (l i).val.fixedSubmodule)
      apply le_trans this
      apply le_trans (Finset.sum_le_card_nsmul _ _ (n := 1) ?_)
      · simp
      intro i _
      rw [← mem_dilatransvections_iff_finrank_quotient]
      exact (l i).prop
  have hf_mem_stabilizer : f ∈ stabilizer (V ≃ₗ[K] V) e.fixedSubmodule := by
    apply mem_stabilizer_submodule_of_le_fixedSubmodule
    simp only [← iInf_eq, inf_le_left]
  have hl_mem_stabilizer (i) : (l i).val ∈ stabilizer (V ≃ₗ[K] V) e.fixedSubmodule := by
    apply mem_stabilizer_submodule_of_le_fixedSubmodule
    simp only [← iInf_eq]
    exact le_trans inf_le_right (iInf_le _ _)
  suffices e.fixedReduce =
    reduce e.fixedSubmodule ⟨f, hf_mem_stabilizer⟩ *
      (List.ofFn (reduce e.fixedSubmodule ∘ fun i ↦ ⟨l i, hl_mem_stabilizer i⟩)).prod by
    rw [this, Set.mem_mul]
    refine ⟨_, ?_, _, ?_, rfl⟩
    · apply reduce_mem_transvections _ _ hf
      simp only [← iInf_eq, inf_le_left]
    · rw [Set.mem_pow]
      refine ⟨fun i ↦ ⟨reduce e.fixedSubmodule ⟨l i, hl_mem_stabilizer i⟩, ?_⟩, by congr⟩
      apply reduce_mem_dilatransvections _ _ (l i).prop
      simp only [← iInf_eq]
      exact le_trans inf_le_right (iInf_le _ _)
  simp only [fixedReduce, ← hfg, ← hg, List.ofFn_eq_map, List.prod_map_hom, ← map_mul]
  apply congr_arg
  rw [← Subtype.coe_inj]
  aesop

theorem notMem_transvections_mul_dilatransvections_pow
  (hV : 1 ≤ finrank K V) (a : K) (ha : a ≠ 1) (hea : ∀ x, e x = a • x) :
    e ∉ transvections K V * dilatransvections K V ^ (finrank K V - 1) := by
  rw [Set.mem_mul]
  rintro ⟨f, hf, g, hg, he⟩
  have : g.fixedSubmodule ≠ ⊥ := by
    rw [ne_eq, ← Submodule.finrank_eq_zero, ← Nat.lt_one_iff, not_lt]
    rw [← Nat.add_le_add_iff_left, finrank_quotient_add_finrank, Nat.add_one_le_iff]
    apply lt_of_le_of_lt (finrank_quotient_fixedSubmodule_of_mem_dilatransvections_pow g hg)
    exact Nat.sub_one_lt_of_lt hV
  apply this
  rw [eq_bot_iff]
  intro x hx
  simp only [mem_bot]
  simp only [mem_fixedSubmodule_iff] at hx
  obtain ⟨l, v, hlv, hf⟩ := hf
  rw [← eq_inv_mul_iff_mul_eq, LinearEquiv.ext_iff] at he
  specialize he x
  replace he : g x = a • x - a • l x • v := by
    simp [he, hf, mul_apply, hea, ← smul_sub]
  rw [← sub_ne_zero] at ha
  rw [← IsUnit.smul_eq_zero (Ne.isUnit ha), sub_smul, one_smul, sub_eq_zero, eq_comm]
  suffices x ∈ K ∙ v by
    simp only [mem_span_singleton] at this
    obtain ⟨c, hc⟩ := this
    nth_rewrite 3 [← hc] at he
    simpa [hx, hlv] using he
  suffices a • x - x = a • l x • v by
    rw [← Submodule.smul_mem_iff _ ha, sub_smul, one_smul, this,
      ← mul_smul]
    simp [mem_span_singleton]
  rw [eq_sub_iff_add_eq, hx] at he
  rwa [sub_eq_iff_eq_add, add_comm, eq_comm]

/-- If an element of `SpecialLinearGroup K V` is a product of
one transvection and `finrank K (V ⧸ e.fixedSubmodule) - 1` dilatransvections,
then it is not exceptional.

(This is a generalization of the third part in Dieudonné's theorem) -/
theorem notIsExceptional_of_mem_transvections_mul_dilatransvections_pow
    (he : e ∈ transvections K V * dilatransvections K V ^ (finrank K (V ⧸ e.fixedSubmodule) - 1)) :
    ¬ IsExceptional e := by
  rintro ⟨hrank, he_reduce, c, hec⟩
  by_cases he1 : e = 1
  · apply he_reduce
    simp [LinearEquiv.one_eq_refl, fixedReduce_eq_one, he1]
  have hV1 : 1 ≤ finrank K (V ⧸ e.fixedSubmodule) :=
    Nat.one_le_of_lt hrank
  refine notMem_transvections_mul_dilatransvections_pow _ hV1 (a := c) ?_ hec
    (fixedReduce_mem_transvections_mul_dilatransvections_pow _ hV1 he)
  contrapose he_reduce
  ext; simp [hec, he_reduce]

/-- If an element of `V ≃ₗ[K] V` is a product of
exactly `finrank K (V ⧸ e.fixedSubmodule) - 1` transvections
and one dilatransvection, then it is not exceptional.

(This is the third part in Dieudonné's theorem) -/
theorem notIsExceptional_of_mem_transvections_pow_mul_dilatransvections
    (he : e ∈ transvections K V ^ (finrank K (V ⧸ e.fixedSubmodule) - 1) * dilatransvections K V) :
    ¬ IsExceptional e := by
  intro hexc
  set n := finrank K (V ⧸ e.fixedSubmodule) - 2 with hn
  have hn2 : finrank K (V ⧸ e.fixedSubmodule) = n + 2 := by
    rw [hn, ← Nat.sub_eq_iff_eq_add hexc.1]
  have hn1 : finrank K (V ⧸ e.fixedSubmodule) - 1 = n + 1 := by
    rwa [Nat.pred_eq_succ_iff]
  rw [hn1] at he
  apply e.notIsExceptional_of_mem_transvections_mul_dilatransvections_pow _ hexc
  suffices ∃ l : Fin (n + 2) → V ≃ₗ[K] V, l 0 ∈ transvections K V ∧
      (∀ i, Fin.tail l i ∈ dilatransvections K V) ∧ (List.ofFn l).prod = e by
    obtain ⟨l, hl0, hltail, hlprod⟩ := this
    rw [Set.mem_mul]
    use l 0, hl0
    use (List.ofFn (Fin.tail l)).prod, ?_, ?_
    · rw [hn1, Set.mem_pow]
      use fun i ↦ ⟨Fin.tail l i, hltail i⟩
    · rw [← hlprod]
      simp only [List.ofFn_eq_map]
      conv_rhs => rw [List.finRange_succ]
      simp only [List.map_cons, List.map_map, List.prod_cons, mul_right_inj]
      congr
  rw [Set.mem_mul] at he
  obtain ⟨f, hf, g, hg, he⟩ := he
  rw [Set.mem_pow] at hf
  obtain ⟨m, hf⟩ := hf
  refine ⟨Fin.snoc (fun i ↦ m i) g, by simp, fun i ↦ ?_, ?_⟩
  · by_cases hi : i = Fin.last n
    · simpa [hi, Fin.tail]
    · apply transvections_subset_dilatransvections
      obtain ⟨j, rfl⟩ := Fin.eq_castSucc_of_ne_last hi
      rw [Fin.tail, Fin.succ_castSucc, Fin.snoc_castSucc]
      simp
  · rw [← he, ← hf, List.ofFn_eq_map, List.ofFn_eq_map, List.finRange_succ_last]
    rw [List.finRange_succ]
    suffices (Fin.snoc (fun i ↦ ↑(m i)) g ∘ Fin.castSucc ∘ Fin.succ) =
      ((fun i ↦ ↑(m i)) ∘ Fin.succ) by
      simp [mul_assoc, this]
    ext1 i
    simp only [Function.comp_apply, Fin.snoc_castSucc]

/- ## Generation by dilatransvections -/

theorem mem_dilatransvections_pow :
    e ∈ dilatransvections K V ^ (finrank K (V ⧸ e.fixedSubmodule)) := by
  induction hn : finrank K (V ⧸ e.fixedSubmodule) generalizing e with
  | zero =>
    suffices e = 1 by simp [this]
    rw [← fixedSubmodule_eq_top_iff]
    apply eq_top_of_finrank_eq
    rw [← finrank_quotient_add_finrank e.fixedSubmodule]
    simpa only [Nat.right_eq_add]
  | succ n hind =>
    have : e.fixedSubmodule ≠ ⊤ := fun he ↦ by
      rw [← Nat.add_left_inj, finrank_quotient_add_finrank, he] at hn
      simp [finrank_top] at hn
    obtain ⟨v, hv⟩ := SetLike.exists_not_mem_of_ne_top e.fixedSubmodule this rfl
    suffices ∃ f ∈ dilatransvections K V, e.fixedSubmodule ≤ f.fixedSubmodule ∧ f (e v) = v by
      obtain ⟨f, hf, hf_fixed, hef⟩ := this
      rw [pow_succ', Set.mem_mul]
      use f⁻¹, by simpa [inv_mem_dilatransvections_iff], f * e, ?_, by simp
      apply hind
      rw [← Nat.add_left_inj, finrank_quotient_add_finrank,
        ← finrank_quotient_add_finrank e.fixedSubmodule, hn,
        add_assoc, Nat.add_left_cancel_iff]
      apply le_antisymm _ (finrank_fixedSubmodule_dilatransvection_mul_le e f hf)
      rw [add_comm]
      apply Submodule.finrank_strictMono
      rw [lt_iff_le_not_ge]
      constructor
      · intro x hx
        suffices x ∈ f.fixedSubmodule by simp_all
        exact hf_fixed hx
      contrapose hv
      apply hv
      simpa using hef
    by_cases hv' : e v ∈ e.fixedSubmodule ⊔ K ∙ v
    · simp only [mem_sup] at hv'
      obtain ⟨x, hx, z, hz, hxcv⟩ := hv'
      simp only [mem_span_singleton] at hz
      obtain ⟨c, rfl⟩ := hz
      have hc : c ≠ 0 := by
        contrapose hv
        simp only [hv, zero_smul, add_zero] at hxcv
        simp only [mem_fixedSubmodule_iff] at hx ⊢
        apply e.injective
        rwa [← hxcv]
      obtain ⟨l, hlv, hle⟩ := Submodule.exists_dual_map_eq_bot_of_notMem hv inferInstance
      replace hle (x : V) (hx : x ∈ e.fixedSubmodule) : l x = 0 := by
        rw [← Submodule.mem_bot K, ← hle]
        exact mem_map_of_mem hx
      let y := (c * l v)⁻¹ • (-x + (1 - c) • v)
      have hy : y ∈ e.fixedSubmodule ⊔ K ∙ v := by
        simp only [y]
        apply smul_mem
        rw [mem_sup]
        exact ⟨-x, by simp_all, (1 - c) • v, by simp [smul_mem], rfl⟩
      suffices IsUnit (1 + l y) by
        use LinearEquiv.dilatransvection this
        refine ⟨dilatransvection_mem_dilatransvections, ?_, ?_⟩
        · intro x hx
          simp [dilatransvection.apply, hle x hx]
        · rw [← hxcv, dilatransvection.apply, map_add, hle x hx, zero_add, LinearMap.map_smul]
          simp only [y, smul_eq_mul, ← mul_smul]
          rw [mul_inv_cancel₀ (by simp_all), one_smul]
          match_scalars <;> simp
      simp only [isUnit_iff_ne_zero, y, LinearMap.map_smul,
        LinearMap.map_add, map_neg, smul_add, hle x hx, neg_zero, smul_zero, zero_add]
      simp only [sub_smul, one_smul, ne_eq]
      rw [← IsUnit.mul_right_inj (a := c * l v) (Ne.isUnit (by simp_all))]
      rw [mul_add, mul_one, mul_zero, smul_eq_mul, ← mul_assoc,
        mul_inv_cancel₀ (by simp_all), one_mul]
      simp_all
    · suffices ∃ l : Dual K V, e.fixedSubmodule.map l = ⊥ ∧ l (v - e v) = 0 ∧ l (e v) ≠ 0 by
        obtain ⟨l, hle, hlv, hlev⟩ := this
        set w := (l (e v))⁻¹ • (v - e v) with hw
        have hlw : l w = 0 := by simp [w, hlv]
        refine ⟨LinearEquiv.transvection hlw, ?_, fun x hx ↦ ?_, ?_⟩
        · exact transvection_mem_dilatransvections hlw
        · rw [mem_fixedSubmodule_iff, transvection.apply, add_eq_left]
          convert zero_smul K _
          rw [← Submodule.mem_bot K, ← hle]
          exact mem_map_of_mem hx
        · rw [transvection.apply]
          rw [add_comm, ← eq_sub_iff_add_eq, hw, ← mul_smul, mul_inv_cancel₀ hlev, one_smul]
      have : e v ∉ e.fixedSubmodule ⊔ K ∙ (v - e v) := by
        contrapose hv'
        rw [mem_sup] at hv'
        obtain ⟨y, hy, z, hz, hyz⟩ := hv'
        rw [mem_span_singleton] at hz
        obtain ⟨a, hz⟩ := hz
        have ha : a ≠ -1 := by
          contrapose hv
          rw [← hz, hv] at hyz
          rw [neg_smul, one_smul, neg_sub] at hyz
          rw [← eq_sub_iff_add_eq, sub_sub_cancel] at hyz
          rwa [← hyz]
        rw [ne_eq, eq_neg_iff_add_eq_zero] at ha
        have : y + a • v = (a  + 1) • e v := by
          rw [← add_right_inj z, ← add_assoc, add_comm z, hyz, ← hz, add_smul, smul_sub, one_smul]
          abel
        rw [← smul_mem_iff _ ha, ← this]
        rw [mem_sup]
        exact ⟨y, hy, a • v, smul_mem _ a (mem_span_singleton_self v), rfl⟩
      obtain ⟨f, hfv, hf⟩ := Submodule.exists_dual_map_eq_bot_of_notMem this inferInstance
      refine ⟨f, ?_, ?_, hfv⟩
      · rw [eq_bot_iff, ← hf]
        exact map_mono le_sup_left
      · rw [← mem_bot K, ← hf]
        exact mem_map_of_mem (mem_sup_right (mem_span_singleton_self (v - e v)))

/-- The group of linear equivalences is generated by dilatransvections. -/
theorem subgroup_closure_dilatransvections_eq_top :
    Subgroup.closure (dilatransvections K V) = ⊤ := by
  rw [eq_top_iff]
  intro e _
  exact closure_pow_le <| Subgroup.mem_closure_of_mem <| mem_dilatransvections_pow e

end LinearEquiv

end
