/-
Copyright (c) 2026 Antoine Chambert-Loir. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Antoine Chambert-Loir
-/

module

public import Mathlib.LinearAlgebra.SpecialLinearGroup
public import Mathlib.LinearAlgebra.Transvection.Basic
public import Mathlib.LinearAlgebra.Transvection.Generation
public import Mathlib.FieldTheory.Finiteness
public import Mathlib.Data.Nat.Prime.Basic

/-!
# Transvections in the special linear group

The basic definitions work over any commutative ring.

* `SpecialLinearGroup.transvection` : transvection in the special linear group.

Over a field `K`, transvections generate the special linear group.

* `SpecialLinearGroup.mem_transvections_pow_of_not_isExceptional`:
  If `e.toLinearEquiv` is not exceptional, then `e` is a product
  of `finrank K (V ⧸ e.toLinearEquiv.fixedSubmodule)` transvections.
*  `SpecialLinearGroup.mem_transvections_pow`:
  any element `e` of `SpecialLinearGroup K V` is a product
  of `finrank K (V ⧸ e.toLinearEquiv.fixedSubmodule) + 1` transvections.

* `SpecialLinearGroup.closure_transvections_eq_top`:
  transvections generate the special linear group.

## TODO

* Over a division ring,one can *define* the special linear group
  as the subgroup generated by the transvections.
  It is then the kernel of the Dieudonné determinant, which is valued in the abelianization of `Kˣ`.
  [Dieudonné-1943][J. Dieudonné, « Les déterminants sur un corps non commutatif »,
  *Bulletin de la Soc. math. France*, tome 71, 1943, p. 27–45]

* This can even be generalized to *local*, possibly noncommutative rings by
  [Klingenberg-1962][W. Klingenberg, « Die Struktur der linearen Gruppe über einem
  nichtkommutativen lokalen Ring », *Archiv der Math.* _13_, 1962, p. 73–81]

* The generation property still holds over euclidean domains.

* It does not hold over arbitrary rings, even over arbitrary
  principal ideal domains. A counterexample can be found in
  [Cohn-1966][P. M. Cohn, “On the structure of the GL 2 of a ring”,
  *Publ. Math. IHÉS* _30_, 1966, p. 5–53]

-/

@[expose] public section

open Module LinearMap LinearEquiv

namespace SpecialLinearGroup

section CommRing

variable {R V : Type*} [CommRing R] [AddCommGroup V] [Module R V]

/-- Transvections in the special linear group. -/
def transvection {f : Module.Dual R V} {v : V} (hfv : f v = 0) :
    SpecialLinearGroup R V :=
  ⟨LinearEquiv.transvection hfv, transvection.det_eq_one hfv⟩

@[simp]
theorem transvection.coe_toLinearEquiv {f : Module.Dual R V} {v : V} {hfv : f v = 0} :
    (SpecialLinearGroup.transvection hfv : V ≃ₗ[R] V) = LinearEquiv.transvection hfv :=
  rfl

variable (R V) in
/-- The set of transvections in the special linear group. -/
def transvections : Set (SpecialLinearGroup R V) :=
  { e | ∃ (f : Dual R V) (v : V) (hfv : f v = 0), e = transvection hfv }

theorem mem_transvections_iff {e : SpecialLinearGroup R V} :
    e ∈ transvections R V ↔
      ∃ (f : Dual R V) (v : V) (hfv : f v = 0), e = transvection hfv :=
  Iff.rfl

theorem mem_transvections_iff_coe {e : SpecialLinearGroup R V} :
    e ∈ transvections R V ↔ (e : V ≃ₗ[R] V) ∈ LinearEquiv.transvections R V := by
  refine ⟨fun ⟨_, _, _, he⟩ ↦ by simp [he],
    fun ⟨f, v, hfv, he⟩ ↦ ⟨f, v, hfv, by simp [← Subtype.coe_inj, he]⟩⟩

@[simp] theorem mem_transvections {f : Dual R V} {v : V} (hfv : f v = 0) :
    transvection hfv ∈ transvections R V :=
  ⟨f, v, hfv, rfl⟩

@[simp] theorem one_mem_transvections :
    1 ∈ transvections R V :=
  ⟨0, 0, by simp, by simp [← Subtype.coe_inj, one_eq_refl]⟩

@[simp]
theorem inv_mem_transvections_iff {e : SpecialLinearGroup R V} :
    e⁻¹ ∈ transvections R V ↔ e ∈ transvections R V := by
  simp [mem_transvections_iff_coe]

open Pointwise in
theorem transvections_pow_mono :
    Monotone (fun n : ℕ ↦ (transvections R V) ^ n) :=
  Set.pow_right_monotone one_mem_transvections

end CommRing

section Field

variable {K V : Type*} [Field K] [AddCommGroup V] [Module K V] [Module.Finite K V]

theorem _root_.LinearEquiv.det_fixedReduce (e : V ≃ₗ[K] V) :
    (e.fixedReduce).det = e.det := by
  simp only [← Units.val_inj, LinearEquiv.coe_det]
  rw [← one_mul (LinearMap.det _),
    LinearMap.det_eq_det_mul_det e.fixedSubmodule e (fun x hx ↦ by simpa using hx)]
  apply congr_arg₂ _ _ (by aesop)
  convert LinearMap.det_id.symm
  aesop

/-- The element of `SpecialLinearGroup K (V ⧸ e.fixedSubmodule)`
deduced from `e : SpecialLinearGroup K V`
by passing to the quotient by `e.fixedSubmodule`. -/
def fixedReduce [Module.Finite K V] (e : SpecialLinearGroup K V) :
    SpecialLinearGroup K (V ⧸ e.toLinearEquiv.fixedSubmodule) :=
  ⟨e.toLinearEquiv.fixedReduce, by
    rw [LinearEquiv.det_fixedReduce]
    exact e.prop⟩

open Pointwise

theorem mem_transvections_pow_of_toLinearEquiv {e : SpecialLinearGroup K V} {n : ℕ}
    (he : ↑e ∈ LinearEquiv.transvections K V ^ n * dilatransvections K V) :
    e ∈ transvections K V ^ (n + 1) := by
  rw [Set.mem_mul] at he
  obtain ⟨x, hx, y, hy, he⟩ := he
  have hxdet : x.det = 1 := by
    rw [Set.mem_pow] at hx
    obtain ⟨l, hx⟩ := hx
    rw [← hx, List.ofFn_eq_map, ← List.prod_map_hom]
    apply List.prod_eq_one
    intro a ha
    simp only [List.mem_map, List.mem_finRange, Function.comp_apply, true_and] at ha
    obtain ⟨i, rfl⟩ := ha
    obtain ⟨f, v, hfv, hi⟩ := (l i).prop
    rw [hi, transvection.det_eq_one]
  have hydet : LinearEquiv.det y = 1 := by
    rw [← e.prop, ← he, map_mul, hxdet, one_mul]
  rw [pow_succ, Set.mem_mul]
  refine ⟨⟨x, hxdet⟩, ?_, ⟨y, hydet⟩, ?_, by simpa [← Subtype.coe_inj]⟩
  · rw [Set.mem_pow] at hx ⊢
    obtain ⟨l, hx⟩ := hx
    use fun i ↦ ⟨⟨(l i), ?_⟩, ?_⟩
    · apply toLinearEquiv_injective
      simp only [List.ofFn_eq_map, ← hx, ← List.prod_map_hom]
      congr 1
    · obtain ⟨f, v, hfv, hli⟩ := (l i).prop
      simp [hli, transvection.det_eq_one]
    · simp [mem_transvections_iff_coe]
  · obtain ⟨f, v, hy⟩ := hy
    simp only [mem_transvections_iff_coe]
    refine ⟨f, v, ?_, ?_⟩
    · rw [← add_right_inj (a := 1), add_zero, ← transvection.det f v,
      ← hy, ← LinearEquiv.coe_det, hydet, Units.val_one]
    · simp [← toLinearMap_inj, hy]

theorem mem_transvections_pow_of_notIsExceptional
    {e : SpecialLinearGroup K V} (he : ¬ IsExceptional e.toLinearEquiv) :
    e ∈ transvections K V ^ (finrank K (V ⧸ e.toLinearEquiv.fixedSubmodule)) := by
  by_cases hV : finrank K (V ⧸ e.toLinearEquiv.fixedSubmodule) = 0
  · suffices e = 1 by
      rw [this]
      apply transvections_pow_mono (zero_le _)
      simp
    rw [← Subtype.coe_inj, coe_one, ← fixedSubmodule_eq_top_iff]
    apply Submodule.eq_top_of_finrank_eq
    rwa [← Nat.add_left_inj, Submodule.finrank_quotient_add_finrank, zero_add, eq_comm] at hV
  rw [← ne_eq, ← Nat.one_le_iff_ne_zero] at hV
  rw [(Nat.sub_eq_iff_eq_add hV).mp rfl]
  apply mem_transvections_pow_of_toLinearEquiv <|
    mem_transvections_pow_mul_dilatransvections_of_notIsExceptional he

theorem mem_transvections_pow (e : SpecialLinearGroup K V) :
    e ∈ transvections K V ^ (finrank K (V ⧸ e.toLinearEquiv.fixedSubmodule) + 1) :=
  mem_transvections_pow_of_toLinearEquiv <|
    mem_transvections_pow_mul_dilatransvections (toLinearEquiv e)

theorem IsExceptional.notMem_transvections_pow {e : SpecialLinearGroup K V}
    (he : IsExceptional e.toLinearEquiv) :
    e ∉ transvections K V ^ (finrank K (V ⧸ e.toLinearEquiv.fixedSubmodule)) := fun he' ↦ by
  apply notIsExceptional_of_mem_transvections_mul_dilatransvections_pow (e.toLinearEquiv) _ he
  rw [(Nat.sub_eq_iff_eq_add he.1.le).mp rfl, pow_succ', Set.mem_mul] at he'
  obtain ⟨x, hx, y, hy, he'⟩ := he'
  rw [Set.mem_mul]
  refine ⟨↑x, ?_, y.toLinearEquiv, ?_, ?_⟩
  · rwa [← mem_transvections_iff_coe]
  · rw [Set.mem_pow] at hy ⊢
    obtain ⟨f, hfy⟩ := hy
    use fun i ↦ ⟨f i, by
      apply transvections_subset_dilatransvections
      simp [← mem_transvections_iff_coe]⟩
    simp only [← hfy, List.ofFn_eq_map, ← List.prod_map_hom]
    rfl
  · simp [← he']

/-- The special linear group is generated by transvections. -/
theorem subgroup_closure_transvections_eq_top :
    Subgroup.closure (transvections K V) = ⊤ := by
  rw [eq_top_iff]
  intro e _
  exact closure_pow_le <| Subgroup.mem_closure_of_mem <| mem_transvections_pow e

theorem _root_.Module.Basis.nonempty_ofFin {n : ℕ} (hn : n = finrank K V) :
    Nonempty (Basis (Fin n) K V) :=
  let b := Module.Basis.ofVectorSpace K V
  ⟨b.reindex (Fintype.equivFinOfCardEq (by rw [hn, Module.finrank_eq_card_basis b]))⟩

-- This was essentially done in `Transvection.Basic`.
theorem _root_.LinearEquiv.transvection.existsBasis
    {n : ℕ} (hV : finrank K V = n + 2) {e : V ≃ₗ[K] V}
    (he : e ∈ LinearEquiv.transvections K V) (he1 : e ≠ 1) :
    ∃ (b : Basis (Fin (n + 2)) K V),
      e = LinearEquiv.transvection (f := b.coord 0) (v := b 1) (by simp) := by
  obtain ⟨f, v, hfv, hg⟩ := he
  have hf : f ≠ 0 := by contrapose he1; aesop
  have hv : v ≠ 0 := by contrapose he1; aesop
  let v' : ker f := ⟨v, by simp [hfv]⟩
  have hv' : v' ≠ 0 := by simpa [v'] using hv
  obtain ⟨w, hw⟩ := (surjective_iff_ne_zero.mpr hf) 1
  obtain ⟨p, hp⟩ := Submodule.exists_isCompl (K ∙ v')
  -- We start from a basis of `p`
  have := Module.Basis.nonempty_ofFin (K := K) (V := p) (n := n) (by
    rw [← Nat.add_right_inj, Submodule.finrank_quotient_add_finrank,
      ← Nat.add_left_inj, f.finrank_ker_add_one_of_ne_zero hf,
      hV, Nat.add_right_cancel_iff, add_comm n, Nat.add_right_cancel_iff,
      ← Nat.add_left_inj, Submodule.finrank_quotient_add_finrank,
      ← Submodule.finrank_add_eq_of_isCompl hp,
      Nat.add_right_cancel_iff, finrank_span_singleton hv'])
  let ⟨b⟩ := this
  -- Adding `v'`, we get a basis of `ker f`.
  let b' := b.mkFinCons v' (fun a x hx hax ↦ by
    suffices x = 0 by simpa [this, hv'] using hax
    rw [← Submodule.mem_bot K, ← hp.inf_eq_bot, Submodule.mem_inf]
    refine ⟨?_, hx⟩
    rw [add_comm, add_eq_zero_iff_eq_neg] at hax
    rw [hax, neg_mem_iff]
    exact Submodule.smul_mem _ _ (Submodule.mem_span_singleton_self v')) (fun x ↦ by
    have hx : x ∈ p ⊔ K ∙ v' := by simp [hp.symm.sup_eq_top]
    rw [Submodule.mem_sup] at hx
    obtain ⟨y, hu, z, hz, rfl⟩ := hx
    rw [Submodule.mem_span_singleton] at hz
    obtain ⟨a, rfl⟩ := hz
    exact ⟨-a, by simpa using hu⟩)
  -- Adding `w`, we get a basis of `V`.
  let β := b'.mkFinCons w (fun a x hx hawx ↦ by
    simp only [mem_ker] at hx
    simpa [hw, hx] using congr(f $hawx)) (fun x ↦
    ⟨- f x, by simp [hw, mem_ker]⟩)
  have β0 : β 0 = w := by simp [β]
  have β1 : β 1 = v := by simp [β, b', v']
  use β
  rw [hg]
  simp only [← LinearEquiv.toLinearMap_inj, transvection.coe_toLinearMap]
  refine congr_arg₂ _ ?_ β1.symm
  apply β.ext (fun i ↦ ?_)
  by_cases hi : i = 0
  · rw [hi, β0]
    rw [Basis.apply_eq_iff] at β0
    simp [β0, hw]
  · obtain ⟨j, rfl⟩ := Fin.eq_succ_of_ne_zero hi
    simp [β, Basis.mkFinCons_repr_apply_zero_ofMem]

/-- Transvections are conjugate in `V ≃ₗ[K] V`. -/
theorem _root_.LinearEquiv.isConj_of_mem_transvections {g g' : V ≃ₗ[K] V}
    (hg1 : g ≠ 1) (hg : g ∈ LinearEquiv.transvections K V)
    (hg'1 : g' ≠ 1) (hg' : g' ∈ LinearEquiv.transvections K V) :
    IsConj g g' := by
  by_cases hV : finrank K V ≤ 1
  · exfalso
    apply hg1
    obtain ⟨f, v, hfv, rfl⟩ := hg
    rw [← LinearEquiv.toLinearMap_inj]
    exact transvection.eq_id_of_finrank_le_one hfv hV
  replace hV : 2 ≤ finrank K V := Nat.succ_le_of_lt (not_le.mp hV)
  have hV' := (Nat.sub_eq_iff_eq_add hV).mp rfl
  obtain ⟨b, hbg⟩ := transvection.existsBasis hV' hg hg1
  obtain ⟨b', hbg'⟩ := transvection.existsBasis hV' hg' hg'1
  let e := b.repr.trans b'.repr.symm
  have he : b.repr = e.trans b'.repr := by
    simp [e, symm_trans_cancel_right]
  simp only [isConj_iff]
  use e
  simp only [hbg, hbg', mul_eq_trans]
  rw [← trans_assoc]
  convert LinearEquiv.transvection.congr _ e
  · ext; simp [e]
  · simp [e]

omit [Module.Finite K V] in
theorem _root_.LinearMap.transvection.commute
    {f : Dual K V} (hf0 : f ≠ 0) {v : V} (hv0 : v ≠ 0)
    (e : V →ₗ[K] V) :
    e * LinearMap.transvection f v = LinearMap.transvection f v * e ↔
      ∃ a : K, e v = a • v ∧ ∀ x, f (e x) = f x * a := by
  refine ⟨fun h ↦ ?_, fun ⟨a, hav, haf⟩ ↦ ?_⟩
  · simp only [LinearMap.ext_iff, End.mul_apply, LinearMap.transvection.apply, map_add,
    _root_.map_smul, add_right_inj] at h
    obtain ⟨w, hw⟩ := (surjective_iff_ne_zero.mpr hf0) 1
    have hw' := h w
    simp only [hw, one_smul] at hw'
    refine ⟨f (e w), hw', ?_⟩
    intro x
    apply smul_left_injective K hv0
    simp [← h, mul_smul, hw]
  · ext x
    simp [LinearMap.transvection.apply, hav, haf, mul_smul]

omit [Module.Finite K V] in
theorem LinearEquiv.transvection.commute
    {f : Dual K V} (hf0 : f ≠ 0) {v : V} (hv0 : v ≠ 0) (hfv : f v = 0)
    (e : V ≃ₗ[K] V) :
    e * LinearEquiv.transvection hfv * e.symm = LinearEquiv.transvection hfv ↔
      ∃ a : K, e v = a • v ∧ ∀ x, f (e x) = f x * a := by
  rw [← LinearEquiv.coe_coe, ← LinearMap.transvection.commute hf0 hv0 ↑e]
  simp only [← LinearEquiv.toLinearMap_inj, coe_toLinearMap_mul, transvection.coe_toLinearMap]
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · conv_rhs => rw [← h, mul_assoc]
    rw [← @coe_toLinearMap_mul, mul_eq_trans, self_trans_symm, refl_toLinearMap]
    -- missing lemmas!
    -- * = comp
    -- LinearMap.id = 1
    rfl
  · rw [h]; aesop

lemma three_le_finrank_of_ne_one_of_ne_two
    {g : SpecialLinearGroup K V} (hg1 : g ≠ 1) (hg : g ∈ transvections K V) (hV : finrank K V ≠ 2) :
    3 ≤ finrank K V := by
  contrapose hg1
  obtain ⟨f, v, hfv, rfl⟩ := hg
  rw [← Subtype.coe_inj, ← LinearEquiv.toLinearMap_inj]
  refine transvection.eq_id_of_finrank_le_one hfv ?_
  grind

/-- Unless `finrank K V = 2`, transvections are conjugate in `SpecialLinearGroup K V`.

The result does not hold if `finrank K V = 2`. -/
theorem isConj_of_mem_transvections {g g' : SpecialLinearGroup K V}
    (hV2 : finrank K V ≠ 2)
    (hg1 : g ≠ 1) (hg : g ∈ transvections K V)
    (hg'1 : g' ≠ 1) (hg' : g' ∈ transvections K V) :
    IsConj g g' := by
  have hV3 : 3 ≤ finrank K V := three_le_finrank_of_ne_one_of_ne_two hg1 hg hV2
  rw [mem_transvections_iff_coe] at hg hg'
  rw [ne_eq, ← Subtype.coe_inj] at hg1 hg'1
  rw [isConj_iff]
  obtain ⟨e, he⟩ := isConj_iff.mp (LinearEquiv.isConj_of_mem_transvections hg1 hg hg'1 hg')
  suffices ∃ e' : V ≃ₗ[K] V, e' ≪≫ₗg' ≪≫ₗe'.symm = g' ∧ e'.det = e.det by
    obtain ⟨e', he'g', he'⟩ := this
    use ⟨e'⁻¹ * e, by simp [he']⟩
    rw [← Subtype.coe_inj]
    simp only [← LinearEquiv.mul_eq_trans] at he'g'
    simp only [coe_mul, coe_inv, mul_inv_rev, inv_inv]
    rw [← he'g', ← he]
    simp only [← mul_assoc]
    congr
  obtain ⟨f, v, hfv, hg'⟩ := hg'
  have hf0 : f ≠ 0 := by contrapose hg'1; aesop
  have hv0 : v ≠ 0 := by contrapose hg'1; aesop
  obtain ⟨s, b, i, j, hij, hv, hf⟩ :=
    LinearMap.transvection.exists_basis_of_pairing_eq_zero hfv hf0 hv0
  have : ∃ k, k ≠ i ∧ k ≠ j := by
    contrapose hV3
    have : Fintype s := by exact FiniteDimensional.fintypeBasisIndex b
    suffices s ⊆ {i.val, j.val} by
      rw [Module.finrank_eq_card_basis b, ← Nat.card_eq_fintype_card, not_le]
      apply lt_of_le_of_lt (Nat.card_mono ?_ this) <;> aesop
    intro x hx
    simp only [ne_eq, Subtype.exists, not_exists, not_and_or, not_not] at hV3
    simpa [← Subtype.coe_inj] using hV3 x hx
  obtain ⟨k, hki, hkj⟩ := this
  set e' := dilatransvection (f := b.coord k) (v := (e.det.val - 1) • b k) (by
    apply Ne.isUnit
    suffices LinearMap.det e.toLinearMap ≠ 0 by simpa
    simp [← LinearEquiv.coe_det]) with he'
  refine ⟨e', ?_, by
    simp [← Units.val_inj, e', LinearMap.transvection.det]⟩
  simp only [← LinearEquiv.mul_eq_trans, ← mul_assoc]
  nth_rewrite 2 [← e'.symm_symm]
  rw [hg', LinearEquiv.transvection.commute hf0 hv0 hfv]
  use 1
  constructor
  · rw [symm_apply_eq, he', ← LinearEquiv.coe_coe]
    simp [hv, LinearMap.transvection.apply, Finsupp.single_eq_of_ne hki]
  · suffices f ∘ₗ ↑e' = f by
      intro x
      nth_rewrite 1 [← this]
      simp
    apply b.ext
    intro x
    by_cases hx : x = k
    · simp [he', hf, LinearMap.transvection.apply,
        hx, Finsupp.single_eq_of_ne (Ne.symm hkj)]
    · simp [he', hf, LinearMap.transvection.apply, Finsupp.single_eq_of_ne (Ne.symm hx)]

theorem IsConj.div_memCommutatorSet
    {G : Type*} [Group G] {x y : G} (h : IsConj x y) :
    x * y⁻¹ ∈ commutatorSet G := by
  obtain ⟨g, hg⟩ := isConj_iff.mp h.symm
  rw [mem_commutatorSet_iff, ← hg]
  exact exists_apply_eq_apply2

-- DivisionRing
omit [Module.Finite K V] in
theorem _root_.LinearEquiv.transvection.eq_one_iff {f : Dual K V} {v : V} {hfv : f v = 0} :
    LinearEquiv.transvection hfv = 1 ↔ f = 0 ∨ v = 0 := by
  refine ⟨fun h ↦ ?_, fun h ↦ by rcases h <;> aesop⟩
  by_contra! h'
  apply h'.2
  have : ∃ x, f x ≠ 0 := by
    by_contra! hf; apply h'.1; ext; simp [hf]
  obtain ⟨x, hx⟩ := this
  rw [LinearEquiv.ext_iff] at h
  specialize h x
  simpa [LinearMap.transvection.apply, hx] using h

omit [Module.Finite K V] in
theorem transvection.eq_one_iff {f : Dual K V} {v : V} {hfv : f v = 0} :
    transvection hfv = 1 ↔ f = 0 ∨ v = 0 := by
  rw [← Subtype.coe_inj, transvection.coe_toLinearEquiv,
    coe_one, LinearEquiv.transvection.eq_one_iff]

/-- Unless `finrank K V = 2` or `K` has at least 4 elements,
any transvection is a commutator of two elements in the special linear group. -/
theorem transvections_subset_commutatorSet (hV : finrank K V ≠ 2) :
    transvections K V ⊆ commutatorSet (SpecialLinearGroup K V) := fun g hg ↦ by
  by_cases hg1 : g = 1
  · simp [hg1, one_mem_commutatorSet _]
  have hV3 : 3 ≤ finrank K V := three_le_finrank_of_ne_one_of_ne_two hg1 hg hV
  obtain ⟨f, v, hfv, hg⟩ := hg
  rw [hg, transvection.eq_one_iff, not_or] at hg1
  suffices ∃ w ∈ LinearMap.ker f, w ≠ 0 ∧ v + w ≠ 0 by
    obtain ⟨w, hfw, hw, hvw⟩ := this
    have hfv1 : f (v + w) = 0 := by simp_all
    have hfv2 : f w = 0 := by simp_all
    suffices g = transvection hfv1 * (transvection hfv2)⁻¹ by
      rw [this]
      apply IsConj.div_memCommutatorSet
      apply isConj_of_mem_transvections hV ?_ (mem_transvections hfv1)
        ?_ (mem_transvections hfv2) <;>
      simp_all [ne_eq, transvection.eq_one_iff]
    simp only [← Subtype.coe_inj, hg, transvection.coe_toLinearEquiv, coe_mul,
      transvection.coe_toLinearEquiv, eq_mul_inv_iff_mul_eq]
    rw [LinearEquiv.mul_eq_trans, transvection.trans_of_left_eq _ _ _]
  suffices Nat.card (ker f) ≠ 2 by
    contrapose! this
    rw [Nat.card_eq_two_iff]
    refine ⟨⟨-v, by simp [hfv]⟩, 0, ?_, ?_⟩
    · simp [ne_eq, ← Subtype.coe_inj, hg1.2]
    · ext ⟨x, hx⟩
      suffices v + x = 0 ∨ x = 0 by simpa [← add_eq_zero_iff_eq_neg']
      rw [or_iff_not_imp_right]
      exact this x hx
  by_cases hV' : Module.Finite K (ker f)
  · rw [Module.natCard_eq_pow_finrank (K := K)]
    rw [ne_eq, Nat.prime_two.pow_eq_iff]
    intro _
    simp_all [← f.finrank_ker_add_one_of_ne_zero]
  · contrapose hV'
    exact FiniteDimensional.finiteDimensional_submodule (ker f)

/-- Unless `finrank K V = 2` and `K` has at most 3 elements,
the subgroup of commutators of `SpecialLinearGroup K V` is `⊤`. -/
theorem commutator_eq_top (hV : finrank K V ≠ 2 ∨ Nat.card K ≠ 2 ∧ Nat.card K ≠ 3) :
    commutator (SpecialLinearGroup K V) = ⊤ := by
  rw [eq_top_iff, ← subgroup_closure_transvections_eq_top,
    Subgroup.closure_le, commutator_eq_closure]
  by_cases hV' : finrank K V = 2
  · suffices ∃ t : SpecialLinearGroup K V, t ∈ commutatorSet _ ∧ t ∈ transvections K V ∧ t ≠ 1 by
      obtain ⟨t, htcomm, httrans, ht1⟩ := this
      intro s hs
      by_cases hs1 : s = 1
      · simp [hs1]
      simp only [SetLike.mem_coe]
      simp only [ne_eq, ← Subtype.coe_inj] at ht1 hs1
      simp only [mem_transvections_iff_coe] at httrans hs
      obtain ⟨e, he⟩ := isConj_iff.mp (LinearEquiv.isConj_of_mem_transvections ht1 httrans hs1 hs)
      apply Subgroup.subset_closure
      obtain ⟨u, v, ht⟩ := htcomm
      let u' : SpecialLinearGroup K V := ⟨e * u * e⁻¹, by simp⟩
      let v' : SpecialLinearGroup K V := ⟨e * v * e⁻¹, by simp⟩
      refine ⟨u', v', ?_⟩
      apply toLinearEquiv_injective
      rw [map_commutatorElement]
      simp only [coe_toLinearEquiv, ← conjugate_commutatorElement, ← he, ← ht, mul_left_inj,
        mul_right_inj, u', v']
      rw [← coe_toLinearEquiv, map_commutatorElement]
    have : ∃ a : K, a ≠ 0 ∧ a ^ 2 ≠ 1 := by
      by_contra! h
      replace hV : Nat.card K ≠ 2 ∧ Nat.card K ≠ 3 := by grind
      have : (Set.univ : Set K) = {0, 1, -1} := by
        apply subset_antisymm _ (Set.subset_univ _)
        intro x _
        simp only [Set.mem_insert_iff, Set.mem_singleton_iff]
        by_cases hx : x = 0
        · left; exact hx
        · right; simpa using h x hx
      rw [← Set.ncard_univ, this] at hV
      by_cases h1 : (1 : K) = -1
      · apply hV.1
        simp [← h1]
      · apply hV.2
        aesop
    obtain ⟨a, ha0, ha1⟩ := this
    let b : Basis (Fin 2) K V := Module.finBasisOfFinrankEq K V hV'
    have : ∃ e : SpecialLinearGroup K V, e (b 0) = a⁻¹ • (b 0) ∧ e (b 1) = a • (b 1) := sorry
    obtain ⟨e, he0, he1⟩ := this
    let f := transvection (f := b.coord 0) (v := b 1) (by simp)
    set t := ⁅e, f⁆ with ht
--    rw [commutatorElement_def] at ht
    suffices t = transvection (f := b.coord 0) (v := (a ^ 2 - 1) • b 1) (by simp) by
      refine ⟨t, commutator_mem_commutatorSet e f, ?_, ?_⟩
      · rw [this]; apply mem_transvections
      rw [this, ne_eq, transvection.eq_one_iff, smul_eq_zero, sub_eq_zero]
      suffices ¬ (b.coord 0) = 0 by simpa [ha1, b.ne_zero]
      intro h
      simpa using congr($h (b 0))
    apply toLinearEquiv_injective
    simp only [ht, commutatorElement_def, coe_toLinearEquiv,
      coe_mul, coe_inv, transvection.coe_toLinearEquiv]
    rw [mul_inv_eq_iff_eq_mul]
    simp only [f, transvection.coe_toLinearEquiv, mul_assoc]
    -- simp only [Fin.isValue, mul_eq_trans]
    rw [← toLinearMap_inj]
    simp only [coe_toLinearMap_mul, transvection.coe_toLinearMap]
    simp only [End.mul_eq_comp]
    -- e⁻¹ = e.symm
    erw [LinearMap.transvection.congr ]
    --
    rw [transvection.comp_of_left_eq (by simp)]
    have : b.coord 0 ∘ₗ e.toLinearEquiv.symm = a • b.coord 0 := by
      suffices b.coord 0 = a • b.coord 0 ∘ₗ e.toLinearEquiv by
        sorry
      apply b.ext
      suffices 1 = a * a⁻¹ by simpa [he0, he1]
      rw [CommGroupWithZero.mul_inv_cancel a ha0]
    simp only [coe_toLinearEquiv] at this
    simp_rw [this, he1]
    apply b.ext
    suffices a • a • b 1 = (a ^ 2 - 1) • b 1 + b 1 by
      simpa [LinearMap.transvection.apply]
    module
  exact subset_trans (transvections_subset_commutatorSet hV') Subgroup.subset_closure

end Field

end SpecialLinearGroup

end
