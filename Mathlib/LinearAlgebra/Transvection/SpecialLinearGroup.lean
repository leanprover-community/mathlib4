/-
Copyright (c) 2026 Antoine Chambert-Loir. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Antoine Chambert-Loir
-/

module

public import Mathlib.LinearAlgebra.SpecialLinearGroup
public import Mathlib.LinearAlgebra.Transvection.Basic
public import Mathlib.LinearAlgebra.Transvection.Generation

/-!
# Transvections in the special linear group

The basic definitions work over any commutative ring.

* `SpecialLinearGroup.transvection` : transvection in the special linear group.

Over a field `K`, transvections generate the special linear group.

* `SpecialLinearGroup.mem_transvections_pow_of_not_isExceptional`:
  If `e.toLinearEquiv` is not exceptional, then `e` is a product
  of `finrank K (V ⧸ e.toLinearEquiv.fixedSubmodule)` transvections.
*  `SpecialLinearGroup.mem_transvections_pow`:
  any element `e` of `SpecialLinearGroup K V` is a product
  of `finrank K (V ⧸ e.toLinearEquiv.fixedSubmodule) + 1` transvections.

* `SpecialLinearGroup.closure_transvections_eq_top`:
  transvections generate the special linear group.

## TODO

* Over a division ring,one can *define* the special linear group
  as the subgroup generated by the transvections.
  It is then the kernel of the Dieudonné determinant, which is valued in the abelianization of `Kˣ`.
  [Dieudonné-1943][J. Dieudonné, « Les déterminants sur un corps non commutatif »,
  *Bulletin de la Soc. math. France*, tome 71, 1943, p. 27–45]

* This can even be generalized to *local*, possibly noncommutative rings by
  [Klingenberg-1962][W. Klingenberg, « Die Struktur der linearen Gruppe über einem
  nichtkommutativen lokalen Ring », *Archiv der Math.* _13_, 1962, p. 73–81]

* The generation property still holds over euclidean domains.

* It does not hold over arbitrary rings, even over arbitrary
  principal ideal domains. A counterexample can be found in
  [Cohn-1966][P. M. Cohn, “On the structure of the GL 2 of a ring”,
  *Publ. Math. IHÉS* _30_, 1966, p. 5–53]

-/

@[expose] public section

open Module LinearMap LinearEquiv

namespace SpecialLinearGroup

section CommRing

variable {R V : Type*} [CommRing R] [AddCommGroup V] [Module R V]

/-- Transvections in the special linear group. -/
def transvection {f : Module.Dual R V} {v : V} (hfv : f v = 0) :
    SpecialLinearGroup R V :=
  ⟨LinearEquiv.transvection hfv, transvection.det_eq_one hfv⟩

@[simp]
theorem transvection.coe_toLinearEquiv {f : Module.Dual R V} {v : V} {hfv : f v = 0} :
    (SpecialLinearGroup.transvection hfv : V ≃ₗ[R] V) = LinearEquiv.transvection hfv :=
  rfl

variable (R V) in
/-- The set of transvections in the special linear group. -/
def transvections : Set (SpecialLinearGroup R V) :=
  { e | ∃ (f : Dual R V) (v : V) (hfv : f v = 0), e = transvection hfv }

theorem mem_transvections_iff {e : SpecialLinearGroup R V} :
    e ∈ transvections R V ↔
      ∃ (f : Dual R V) (v : V) (hfv : f v = 0), e = transvection hfv :=
  Iff.rfl

theorem mem_transvections_iff_coe {e : SpecialLinearGroup R V} :
    e ∈ transvections R V ↔ (e : V ≃ₗ[R] V) ∈ LinearEquiv.transvections R V := by
  refine ⟨fun ⟨_, _, _, he⟩ ↦ by simp [he],
    fun ⟨f, v, hfv, he⟩ ↦ ⟨f, v, hfv, by simp [← Subtype.coe_inj, he]⟩⟩

@[simp] theorem mem_transvections {f : Dual R V} {v : V} (hfv : f v = 0) :
    transvection hfv ∈ transvections R V :=
  ⟨f, v, hfv, rfl⟩

@[simp] theorem one_mem_transvections :
    1 ∈ transvections R V :=
  ⟨0, 0, by simp, by simp [← Subtype.coe_inj, one_eq_refl]⟩

@[simp]
theorem inv_mem_transvections_iff {e : SpecialLinearGroup R V} :
    e⁻¹ ∈ transvections R V ↔ e ∈ transvections R V := by
  simp [mem_transvections_iff_coe]

open Pointwise in
theorem transvections_pow_mono :
    Monotone (fun n : ℕ ↦ (transvections R V) ^ n) :=
  Set.pow_right_monotone one_mem_transvections

end CommRing

section Field

variable {K V : Type*} [Field K] [AddCommGroup V] [Module K V] [Module.Finite K V]

theorem _root_.LinearEquiv.det_fixedReduce (e : V ≃ₗ[K] V) :
    (e.fixedReduce).det = e.det := by
  simp only [← Units.val_inj, LinearEquiv.coe_det]
  rw [← one_mul (LinearMap.det _),
    LinearMap.det_eq_det_mul_det e.fixedSubmodule e (fun x hx ↦ by simpa using hx)]
  apply congr_arg₂ _ _ (by aesop)
  convert LinearMap.det_id.symm
  aesop

/-- The element of `SpecialLinearGroup K (V ⧸ e.fixedSubmodule)`
deduced from `e : SpecialLinearGroup K V`
by passing to the quotient by `e.fixedSubmodule`. -/
def fixedReduce [Module.Finite K V] (e : SpecialLinearGroup K V) :
    SpecialLinearGroup K (V ⧸ e.toLinearEquiv.fixedSubmodule) :=
  ⟨e.toLinearEquiv.fixedReduce, by
    rw [LinearEquiv.det_fixedReduce]
    exact e.prop⟩

open Pointwise

theorem mem_transvections_pow_of_toLinearEquiv {e : SpecialLinearGroup K V} {n : ℕ}
    (he : e.toLinearEquiv ∈ LinearEquiv.transvections K V ^ n * dilatransvections K V) :
    e ∈ transvections K V ^ (n + 1) := by
  rw [Set.mem_mul] at he
  obtain ⟨x, hx, y, hy, he⟩ := he
  have hxdet : x.det = 1 := by
    rw [Set.mem_pow] at hx
    obtain ⟨l, hx⟩ := hx
    rw [← hx, List.ofFn_eq_map, ← List.prod_map_hom]
    apply List.prod_eq_one
    intro a ha
    simp only [List.mem_map, List.mem_finRange, Function.comp_apply, true_and] at ha
    obtain ⟨i, rfl⟩ := ha
    obtain ⟨f, v, hfv, hi⟩ := (l i).prop
    rw [hi, LinearEquiv.transvection.det_eq_one]
  have hydet : LinearEquiv.det y = 1 := by
    rw [← e.prop]
    change _ = LinearEquiv.det e.toLinearEquiv
    rw [← he, map_mul, hxdet, one_mul]
  rw [pow_succ, Set.mem_mul]
  refine ⟨⟨x, hxdet⟩, ?_, ⟨y, hydet⟩, ?_, by simpa [← Subtype.coe_inj]⟩
  · rw [Set.mem_pow] at hx ⊢
    obtain ⟨l, hx⟩ := hx
    use fun i ↦ ⟨⟨(l i), ?_⟩, ?_⟩
    · apply toLinearEquiv_injective
      simp only [List.ofFn_eq_map, ← hx, ← List.prod_map_hom]
      congr 1
    · obtain ⟨f, v, hfv, hli⟩ := (l i).prop
      simp [hli, transvection.det_eq_one]
    · simp [mem_transvections_iff_coe]
  · obtain ⟨f, v, hy⟩ := hy
    simp only [mem_transvections_iff_coe]
    refine ⟨f, v, ?_, ?_⟩
    · rw [← add_right_inj (a := 1), add_zero, ← transvection.det f v,
      ← hy, ← LinearEquiv.coe_det, hydet, Units.val_one]
    · simp [← LinearEquiv.toLinearMap_inj, hy]

theorem mem_transvections_pow_of_notIsExceptional
    {e : SpecialLinearGroup K V} (he : ¬ IsExceptional e.toLinearEquiv) :
    e ∈ transvections K V ^ (finrank K (V ⧸ e.toLinearEquiv.fixedSubmodule)) := by
  by_cases hV : finrank K (V ⧸ e.toLinearEquiv.fixedSubmodule) = 0
  · suffices e = 1 by
      rw [this]
      apply transvections_pow_mono (zero_le _)
      simp
    rw [← Subtype.coe_inj, coe_one, ← fixedSubmodule_eq_top_iff]
    apply Submodule.eq_top_of_finrank_eq
    rwa [← Nat.add_left_inj, Submodule.finrank_quotient_add_finrank, zero_add, eq_comm] at hV
  rw [← ne_eq, ← Nat.one_le_iff_ne_zero] at hV
  rw [(Nat.sub_eq_iff_eq_add hV).mp rfl]
  apply mem_transvections_pow_of_toLinearEquiv <|
    mem_transvections_pow_mul_dilatransvections_of_notIsExceptional he

theorem mem_transvections_pow (e : SpecialLinearGroup K V) :
    e ∈ transvections K V ^ (finrank K (V ⧸ e.toLinearEquiv.fixedSubmodule) + 1) :=
  mem_transvections_pow_of_toLinearEquiv <|
    mem_transvections_pow_mul_dilatransvections (toLinearEquiv e)

theorem IsExceptional.notMem_transvections_pow {e : SpecialLinearGroup K V}
    (he : IsExceptional e.toLinearEquiv) :
    e ∉ transvections K V ^ (finrank K (V ⧸ e.toLinearEquiv.fixedSubmodule)) := fun he' ↦ by
  apply notIsExceptional_of_mem_transvections_mul_dilatransvections_pow (e.toLinearEquiv) _ he
  rw [(Nat.sub_eq_iff_eq_add he.1.le).mp rfl, pow_succ', Set.mem_mul] at he'
  obtain ⟨x, hx, y, hy, he'⟩ := he'
  rw [Set.mem_mul]
  refine ⟨↑x, ?_, y.toLinearEquiv, ?_, ?_⟩
  · rwa [← mem_transvections_iff_coe]
  · rw [Set.mem_pow] at hy ⊢
    obtain ⟨f, hfy⟩ := hy
    use fun i ↦ ⟨f i, by
      apply transvections_subset_dilatransvections
      simp [← mem_transvections_iff_coe]⟩
    simp only [← hfy, List.ofFn_eq_map, ← List.prod_map_hom]
    rfl
  · simp [← he']
    rfl

/-- The special linear group is generated by transvections. -/
theorem subgroup_closure_dilatransvections_eq_top :
    Subgroup.closure (transvections K V) = ⊤ := by
  rw [eq_top_iff]
  intro e _
  exact closure_pow_le <| Subgroup.mem_closure_of_mem <| mem_transvections_pow e

end Field

end SpecialLinearGroup

end
