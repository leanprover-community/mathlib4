/-
Copyright (c) 2026 Antoine Chambert-Loir. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Antoine Chambert-Loir
-/

module

public import Mathlib.GroupTheory.GroupAction.Iwasawa
public import Mathlib.LinearAlgebra.Center
public import Mathlib.LinearAlgebra.Projectivization.Action
public import Mathlib.LinearAlgebra.Transvection.SpecialLinearGroup

/-!
# The special linear group is simple (modulo its center)

Let `K` be a field and `V` be a `K`-vector space.

* `SpecialLinearGroup.isQuasiSimpleGroup`:
  if `finrank K V` is at least 3, or if `finrank K V = 2` and `K` has at least 4 elements,
  then `SpecialLinearGroup K V` is quasi-simple, namely, the quotient group
  `SpecialLinearGroup K V ⧸ Subgroup.center (SpecialLinearGroup K V)`
  is simple.

## TODO

* Make the connection with the matrix groups, especially `Matrix.ProjectiveSpecialLinearGroup`.

* Give an explicit description of the remaining cases,
showing that they are not simple:

  - If `finrank K V ≤ 1`, then `SpecialLinearGroup K V` is trivial.

  - If `finrank K V = 2` and `K` has two elements,
  then `SpecialLinearGroup K V` has 6 elements,
  its center is trivial and it is not simple.
  (By its action on `ℙ K V`, it is isomorphic to `Equiv.Perm (Fin 3)`.).

  - If `finrank K V = 2` and `K` has three elements,
  then `SpecialLinearGroup K V` has 24 elements, its center has order 2,
  and, by its action on `ℙ K V`, the quotient is isomorphic
  to `alternatingGroup (Fin 4)`, so is not simple neither.

* Treat the case of division rings, defining the special linear
  group as the group generated by transvections.

* Treat the case of local rings.

-/

@[expose] public section

namespace SpecialLinearGroup

open MulAction Module Projectivization Pointwise

open scoped LinearAlgebra.Projectivization

variable {K V : Type*} [Field K] [AddCommGroup V] [Module K V]

/-- The group of transvections with axis `D : ℙ K V`. -/
def iwasawaT (D : ℙ K V) :
    Subgroup (SpecialLinearGroup K V) where
  carrier := {e | ∃ (f : Dual K V) (h : f (D.rep) = 0), e = transvection h }
  mul_mem' {x y} hx hy := by
    obtain ⟨f, hfx, ⟨hx, rfl⟩⟩ := hx
    obtain ⟨g, hgy, ⟨hy, rfl⟩⟩ := hy
    simp only [Set.mem_setOf_eq]
    refine ⟨f + g, by simp [hfx, hgy], ?_⟩
    simp [← Subtype.coe_inj, ← LinearEquiv.toLinearMap_inj,
      End.mul_eq_comp, LinearMap.transvection.comp_of_right_eq hfx]
  one_mem' := ⟨0, by simp, by aesop⟩
  inv_mem' {g} hg := by
    obtain ⟨f, hf, ⟨hg, rfl⟩⟩ := hg
    refine ⟨(-f : Dual K V), by aesop, by
      simp only [← Subtype.coe_inj, coe_inv, transvection.coe_toLinearEquiv]
      exact LinearEquiv.transvection.symm_eq' hf ?_⟩

/-- The Iwasawa structure for `SpecialLinearGroup K V` acting on `ℙ K V`. -/
def iwasawa [Module.Finite K V] :
    IwasawaStructure (SpecialLinearGroup K V) (ℙ K V) where
  T := iwasawaT
  is_comm D := {
    is_comm := {
      comm x y := by
        obtain ⟨f, hfx, hx⟩ := x.prop
        obtain ⟨g, hgy, hy⟩ := y.prop
        simp [← Subtype.coe_inj, hx, hy, ← LinearEquiv.toLinearMap_inj,
          End.mul_eq_comp, LinearMap.transvection.comp_of_right_eq hgy,
          LinearMap.transvection.comp_of_right_eq hfx, add_comm] } }
  is_conj g D := by
    suffices ∀ g D, MulAut.conj g • iwasawaT D ≤ iwasawaT (g • D) by
      apply le_antisymm _ (this g D)
      intro x hx
      rw [Subgroup.mem_pointwise_smul_iff_inv_smul_mem]
      rw [show D = g⁻¹ • g • D from by simp]
      apply this g⁻¹ (g • D)
      rw [← Subgroup.mem_pointwise_smul_iff_inv_smul_mem]
      simpa
    intro g D x hx
    rw [Subgroup.mem_pointwise_smul_iff_inv_smul_mem] at hx
    obtain ⟨f, hfx, hx⟩ := hx
    rw [inv_smul_eq_iff] at hx
    have : ∃ a : Kˣ, a • g • D.rep = (g • D).rep := by
      rw [← mk_eq_mk_iff K (g • D).rep (g • D.rep)
        (g • D).rep_nonzero ((smul_ne_zero_iff_ne g).mpr D.rep_nonzero)]
      simp [mk_rep, ← eq_inv_smul_iff]
    obtain ⟨a, ha⟩ := this
    use a⁻¹ • f ∘ₗ g⁻¹.toLinearEquiv
    refine ⟨by simp [← ha, ← hfx, SpecialLinearGroup.smul_def], ?_⟩
    -- the rest of the proof is ugly,
    -- one needs a better congr lemma for transvections
    rw [hx]
    simp only [MulAut.smul_def, MulAut.conj_apply, coe_toLinearEquiv, coe_inv, ← Subtype.coe_inj,
      coe_mul, transvection.coe_toLinearEquiv, ← LinearEquiv.toLinearMap_inj,
      LinearEquiv.coe_toLinearMap_mul, LinearEquiv.transvection.coe_toLinearMap]
    have := LinearEquiv.transvection.congr hfx g.toLinearEquiv
    simp only [coe_toLinearEquiv, ← LinearEquiv.mul_eq_trans, ← LinearEquiv.toLinearMap_inj,
      LinearEquiv.coe_toLinearMap_mul, LinearEquiv.transvection.coe_toLinearMap] at this
    erw [this]
    ext v
    simp only [LinearMap.transvection.apply, ← ha, add_right_inj]
    simp only [SpecialLinearGroup.smul_def, Units.smul_def,
      LinearEquiv.smul_def, coe_toLinearEquiv]
    match_scalars
    simp [mul_comm a.val⁻¹]
  is_generator := by
    rw [eq_top_iff, ← SpecialLinearGroup.subgroup_closure_transvections_eq_top, Subgroup.closure_le]
    rintro _ ⟨f, v, hfv, rfl⟩
    by_cases hv : v = 0
    · suffices transvection hfv = 1 by simp [this]
      simp [← Subtype.coe_inj, hv, ← LinearEquiv.toLinearMap_inj]
    obtain ⟨a, ha⟩ := exists_smul_eq_mk_rep K v hv
    apply Subgroup.mem_iSup_of_mem (mk K v hv)
    refine ⟨a⁻¹ • f, ?_, ?_⟩
    · simp [LinearMap.smul_apply, Units.smul_def, ← ha, hfv]
    -- this is slightly less ugly, but not so much
    ext x
    rw [← smul_left_cancel_iff a]
    suffices a • f x • v = f x • a • v by
      simpa [LinearMap.transvection.apply, ← ha]
    simp [Units.smul_def, smul_comm (f x)]

theorem notLE_center [Module.Finite K V]
    (hV : finrank K V ≠ 2 ∨ Nat.card K ≠ 2 ∧ Nat.card K ≠ 3)
    {N : Subgroup (SpecialLinearGroup K V)} [N.Normal]
    (hN : ¬ N ≤ Subgroup.center (SpecialLinearGroup K V)) :
    N = ⊤ := by
  rw [eq_top_iff, ← SpecialLinearGroup.commutator_eq_top hV]
  apply iwasawa.commutator_le
  contrapose hN
  intro n hn
  have := LinearMap.exists_eq_smul_id_of_forall_notLinearIndependent
    (f := n.toLinearEquiv.toLinearMap) (fun v hv ↦ by
      rw [LinearIndependent.pair_iff] at hv
      by_cases hv0 : v = 0
      · simpa [hv0] using hv 1 1
      · let D := mk K v hv0
        have hD : mk K v hv0 ∈ fixedPoints N (ℙ K V) := by simp only [hN, Set.mem_univ]
        simp only [mem_fixedPoints] at hD
        specialize hD ⟨n, hn⟩
        simp only [smul_mk, Subgroup.mk_smul, mk_eq_mk_iff] at hD
        obtain ⟨a, ha⟩ := hD
        apply one_ne_zero (α := K)
        refine (hv (- a.val) (1 : K) ?_).2
        simp [neg_smul, ← Units.smul_def, ha, add_comm, smul_def])
  obtain ⟨a, ha⟩ := this
  rw [Subgroup.mem_center_iff]
  intro g
  ext x
  simp only [coe_toLinearEquiv] at ha
  simp only [coe_mul, LinearEquiv.mul_apply, ← LinearEquiv.coe_coe, ha]
  simp

/-- The special linear group is simple modulo its center. -/
theorem isQuasiSimpleGroup [Module.Finite K V]
    (hV : 3 ≤ finrank K V ∨ (finrank K V = 2 ∧ Nat.card K ≠ 2 ∧ Nat.card K ≠ 3)) :
    IsSimpleGroup (SpecialLinearGroup K V ⧸ Subgroup.center _) where
  exists_pair_ne := by
    suffices ∃ x, x ∉ Subgroup.center (SpecialLinearGroup K V) by
      obtain ⟨x, hx⟩ := this
      use QuotientGroup.mk' _ x, 1
      simpa
    let b := Module.Basis.ofVectorSpace K V
    have : Fintype (Basis.ofVectorSpaceIndex K V) :=
      FiniteDimensional.instFintypeElemOfVectorSpaceIndex
    have : Nontrivial (Basis.ofVectorSpaceIndex K V) := by
      rw [← Fintype.one_lt_card_iff_nontrivial]
      rw [← finrank_eq_card_basis b]
      rcases hV with hV | hV
      · exact Nat.le_of_succ_le hV
      · aesop
    obtain ⟨i, j, hij⟩ := this
    use transvection (f := b.coord i) (v := b j) (by simp [Finsupp.single_eq_of_ne hij])
    rw [Subgroup.mem_center_iff, not_forall]
    use transvection (f := b.coord j) (v := b i) (by simp [Finsupp.single_eq_of_ne (Ne.symm hij)])
    rw [← Subtype.coe_inj, LinearEquiv.ext_iff, not_forall]
    use b i
    simp [LinearMap.transvection.apply, Finsupp.single_eq_of_ne (Ne.symm hij), b.ne_zero]
  eq_bot_or_eq_top_of_normal H nH := by
    rw [or_iff_not_imp_left]
    intro hH
    let N : Subgroup (SpecialLinearGroup K V) := H.comap (QuotientGroup.mk' _)
    have hN_eq := notLE_center (N := N) (by aesop)
    have hN : H = N.map (QuotientGroup.mk' _) := by
      rw [Subgroup.map_comap_eq_self _]
      simp
    suffices N = ⊤ by
      rw [hN, this, Subgroup.map_top_of_surjective _ (QuotientGroup.mk'_surjective _)]
    apply hN_eq
    have centerLE: Subgroup.center (SpecialLinearGroup K V) ≤ N :=
      QuotientGroup.le_comap_mk' _ H
    contrapose hH
    rw [hN]
    rw [eq_bot_iff]
    rw [Subgroup.gc_map_comap]
    simpa

end SpecialLinearGroup

end
