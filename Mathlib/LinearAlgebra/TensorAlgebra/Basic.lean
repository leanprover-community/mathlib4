/-
Copyright (c) 2020 Adam Topaz. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Adam Topaz
-/
import Mathlib.Algebra.FreeAlgebra
import Mathlib.Algebra.RingQuot
import Mathlib.Algebra.TrivSqZeroExt
import Mathlib.Algebra.Algebra.Operations
import Mathlib.LinearAlgebra.Multilinear.Basic

#align_import linear_algebra.tensor_algebra.basic from "leanprover-community/mathlib"@"b8d2eaa69d69ce8f03179a5cda774fc0cde984e4"

/-!
# Tensor Algebras

Given a commutative semiring `R`, and an `R`-module `M`, we construct the tensor algebra of `M`.
This is the free `R`-algebra generated (`R`-linearly) by the module `M`.

## Notation

1. `TensorAlgebra R M` is the tensor algebra itself. It is endowed with an R-algebra structure.
2. `TensorAlgebra.Î¹ R` is the canonical R-linear map `M â†’ TensorAlgebra R M`.
3. Given a linear map `f : M â†’ A` to an R-algebra `A`, `lift R f` is the lift of `f` to an
  `R`-algebra morphism `TensorAlgebra R M â†’ A`.

## Theorems

1. `Î¹_comp_lift` states that the composition `(lift R f) âˆ˜ (Î¹ R)` is identical to `f`.
2. `lift_unique` states that whenever an R-algebra morphism `g : TensorAlgebra R M â†’ A` is
  given whose composition with `Î¹ R` is `f`, then one has `g = lift R f`.
3. `hom_ext` is a variant of `lift_unique` in the form of an extensionality theorem.
4. `lift_comp_Î¹` is a combination of `Î¹_comp_lift` and `lift_unique`. It states that the lift
  of the composition of an algebra morphism with `Î¹` is the algebra morphism itself.

## Implementation details

As noted above, the tensor algebra of `M` is constructed as the free `R`-algebra generated by `M`,
modulo the additional relations making the inclusion of `M` into an `R`-linear map.
-/


variable (R : Type*) [CommSemiring R]

variable (M : Type*) [AddCommMonoid M] [Module R M]

namespace TensorAlgebra

/-- An inductively defined relation on `Pre R M` used to force the initial algebra structure on
the associated quotient.
-/
inductive Rel : FreeAlgebra R M â†’ FreeAlgebra R M â†’ Prop
  -- force `Î¹` to be linear
  | add {a b : M} : Rel (FreeAlgebra.Î¹ R (a + b)) (FreeAlgebra.Î¹ R a + FreeAlgebra.Î¹ R b)
  | smul {r : R} {a : M} :
    Rel (FreeAlgebra.Î¹ R (r â€¢ a)) (algebraMap R (FreeAlgebra R M) r * FreeAlgebra.Î¹ R a)
#align tensor_algebra.rel TensorAlgebra.Rel

end TensorAlgebra

/-- The tensor algebra of the module `M` over the commutative semiring `R`.
-/
def TensorAlgebra :=
  RingQuot (TensorAlgebra.Rel R M)
#align tensor_algebra TensorAlgebra

-- Porting note: Expanded `deriving Inhabited, Semiring, Algebra`
instance : Inhabited (TensorAlgebra R M) := RingQuot.instInhabitedRingQuot _
instance : Semiring (TensorAlgebra R M) := RingQuot.instSemiring _

-- `IsScalarTower` is not needed, but the instance isn't really canonical without it.
@[nolint unusedArguments]
instance instAlgebra {R A M} [CommSemiring R] [AddCommMonoid M] [CommSemiring A]
    [Algebra R A] [Module R M] [Module A M]
    [IsScalarTower R A M] :
    Algebra R (TensorAlgebra A M) :=
  RingQuot.instAlgebraRingQuot _

-- verify there is no diamond
example : (algebraNat : Algebra â„• (TensorAlgebra R M)) = instAlgebra := rfl

instance {R S A M} [CommSemiring R] [CommSemiring S] [AddCommMonoid M] [CommSemiring A]
    [Algebra R A] [Algebra S A] [Module R M] [Module S M] [Module A M]
    [IsScalarTower R A M] [IsScalarTower S A M] [SMulCommClass R S A] :
    SMulCommClass R S (TensorAlgebra A M) :=
  RingQuot.instSMulCommClassRingQuot _

instance {R S A M} [CommSemiring R] [CommSemiring S] [AddCommMonoid M] [CommSemiring A]
    [SMul R S] [Algebra R A] [Algebra S A] [Module R M] [Module S M] [Module A M]
    [IsScalarTower R A M] [IsScalarTower S A M] [IsScalarTower R S A] :
    IsScalarTower R S (TensorAlgebra A M) :=
  RingQuot.instIsScalarTowerRingQuot _

namespace TensorAlgebra

instance {S : Type*} [CommRing S] [Module S M] : Ring (TensorAlgebra S M) :=
  RingQuot.instRing (Rel S M)

-- verify there is no diamond
variable (S M : Type) [CommRing S] [AddCommGroup M] [Module S M] in
example : (algebraInt _ : Algebra â„¤ (TensorAlgebra S M)) = instAlgebra := rfl

variable {M}

/-- The canonical linear map `M â†’â‚—[R] TensorAlgebra R M`.
-/
irreducible_def Î¹ : M â†’â‚—[R] TensorAlgebra R M :=
  { toFun := fun m => RingQuot.mkAlgHom R _ (FreeAlgebra.Î¹ R m)
    map_add' := fun x y => by
      rw [â† AlgHom.map_add]
      -- âŠ¢ (fun m => â†‘(RingQuot.mkAlgHom R (Rel R M)) (FreeAlgebra.Î¹ R m)) (x + y) = â†‘( â€¦
      exact RingQuot.mkAlgHom_rel R Rel.add
      -- ğŸ‰ no goals
    map_smul' := fun r x => by
      rw [â† AlgHom.map_smul]
      -- âŠ¢ AddHom.toFun { toFun := fun m => â†‘(RingQuot.mkAlgHom R (Rel R M)) (FreeAlgeb â€¦
      exact RingQuot.mkAlgHom_rel R Rel.smul }
      -- ğŸ‰ no goals
#align tensor_algebra.Î¹ TensorAlgebra.Î¹

theorem ringQuot_mkAlgHom_freeAlgebra_Î¹_eq_Î¹ (m : M) :
    RingQuot.mkAlgHom R (Rel R M) (FreeAlgebra.Î¹ R m) = Î¹ R m := by
  rw [Î¹]
  -- âŠ¢ â†‘(RingQuot.mkAlgHom R (Rel R M)) (FreeAlgebra.Î¹ R m) = â†‘{ toAddHom := { toFu â€¦
  rfl
  -- ğŸ‰ no goals
#align tensor_algebra.ring_quot_mk_alg_hom_free_algebra_Î¹_eq_Î¹ TensorAlgebra.ringQuot_mkAlgHom_freeAlgebra_Î¹_eq_Î¹

-- Porting note: Changed `irreducible_def` to `def` to get `@[simps symm_apply]` to work
/-- Given a linear map `f : M â†’ A` where `A` is an `R`-algebra, `lift R f` is the unique lift
of `f` to a morphism of `R`-algebras `TensorAlgebra R M â†’ A`.
-/
@[simps symm_apply]
def lift {A : Type*} [Semiring A] [Algebra R A] : (M â†’â‚—[R] A) â‰ƒ (TensorAlgebra R M â†’â‚[R] A) :=
  { toFun :=
      RingQuot.liftAlgHom R âˆ˜ fun f =>
        âŸ¨FreeAlgebra.lift R (â‡‘f), fun x y (h : Rel R M x y) => by
          induction h <;>
          -- âŠ¢ â†‘(â†‘(FreeAlgebra.lift R) â†‘f) (FreeAlgebra.Î¹ R (aâœ + bâœ)) = â†‘(â†‘(FreeAlgebra.li â€¦
            simp only [Algebra.smul_def, FreeAlgebra.lift_Î¹_apply, LinearMap.map_smulâ‚›â‚—,
              RingHom.id_apply, map_mul, AlgHom.commutes, map_add]âŸ©
    invFun := fun F => F.toLinearMap.comp (Î¹ R)
    left_inv := fun f => by
      rw [Î¹]
      -- âŠ¢ (fun F => LinearMap.comp (AlgHom.toLinearMap F) { toAddHom := { toFun := fun â€¦
      ext1 x
      -- âŠ¢ â†‘((fun F => LinearMap.comp (AlgHom.toLinearMap F) { toAddHom := { toFun := f â€¦
      exact (RingQuot.liftAlgHom_mkAlgHom_apply _ _ _ _).trans (FreeAlgebra.lift_Î¹_apply f x)
      -- ğŸ‰ no goals
    right_inv := fun F =>
      RingQuot.ringQuot_ext' _ _ _ <|
        FreeAlgebra.hom_ext <|
          funext fun x => by
            rw [Î¹]
            -- âŠ¢ (â†‘(AlgHom.comp ((â†‘(RingQuot.liftAlgHom R) âˆ˜ fun f => { val := â†‘(FreeAlgebra. â€¦
            exact
              (RingQuot.liftAlgHom_mkAlgHom_apply _ _ _ _).trans (FreeAlgebra.lift_Î¹_apply _ _) }
#align tensor_algebra.lift TensorAlgebra.lift

variable {R}

@[simp]
theorem Î¹_comp_lift {A : Type*} [Semiring A] [Algebra R A] (f : M â†’â‚—[R] A) :
    (lift R f).toLinearMap.comp (Î¹ R) = f := by
  convert (lift R).symm_apply_apply f
  -- ğŸ‰ no goals
#align tensor_algebra.Î¹_comp_lift TensorAlgebra.Î¹_comp_lift

@[simp]
theorem lift_Î¹_apply {A : Type*} [Semiring A] [Algebra R A] (f : M â†’â‚—[R] A) (x) :
    lift R f (Î¹ R x) = f x := by
  conv_rhs => rw [â† Î¹_comp_lift f]
  -- ğŸ‰ no goals
#align tensor_algebra.lift_Î¹_apply TensorAlgebra.lift_Î¹_apply

@[simp]
theorem lift_unique {A : Type*} [Semiring A] [Algebra R A] (f : M â†’â‚—[R] A)
    (g : TensorAlgebra R M â†’â‚[R] A) : g.toLinearMap.comp (Î¹ R) = f â†” g = lift R f := by
  rw [â† (lift R).symm_apply_eq]
  -- âŠ¢ LinearMap.comp (AlgHom.toLinearMap g) (Î¹ R) = f â†” â†‘(lift R).symm g = f
  simp only [lift, Equiv.coe_fn_symm_mk]
  -- ğŸ‰ no goals
#align tensor_algebra.lift_unique TensorAlgebra.lift_unique

-- Marking `TensorAlgebra` irreducible makes `Ring` instances inaccessible on quotients.
-- https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/algebra.2Esemiring_to_ring.20breaks.20semimodule.20typeclass.20lookup/near/212580241
-- For now, we avoid this by not marking it irreducible.
@[simp]
theorem lift_comp_Î¹ {A : Type*} [Semiring A] [Algebra R A] (g : TensorAlgebra R M â†’â‚[R] A) :
    lift R (g.toLinearMap.comp (Î¹ R)) = g := by
  rw [â† lift_symm_apply]
  -- âŠ¢ â†‘(lift R) (â†‘(lift R).symm g) = g
  exact (lift R).apply_symm_apply g
  -- ğŸ‰ no goals
#align tensor_algebra.lift_comp_Î¹ TensorAlgebra.lift_comp_Î¹

/-- See note [partially-applied ext lemmas]. -/
@[ext]
theorem hom_ext {A : Type*} [Semiring A] [Algebra R A] {f g : TensorAlgebra R M â†’â‚[R] A}
    (w : f.toLinearMap.comp (Î¹ R) = g.toLinearMap.comp (Î¹ R)) : f = g := by
  rw [â† lift_symm_apply, â† lift_symm_apply] at w
  -- âŠ¢ f = g
  exact (lift R).symm.injective w
  -- ğŸ‰ no goals
#align tensor_algebra.hom_ext TensorAlgebra.hom_ext

-- This proof closely follows `FreeAlgebra.induction`
/-- If `C` holds for the `algebraMap` of `r : R` into `TensorAlgebra R M`, the `Î¹` of `x : M`,
and is preserved under addition and muliplication, then it holds for all of `TensorAlgebra R M`.
-/
@[elab_as_elim]
theorem induction {C : TensorAlgebra R M â†’ Prop}
    (h_grade0 : âˆ€ r, C (algebraMap R (TensorAlgebra R M) r)) (h_grade1 : âˆ€ x, C (Î¹ R x))
    (h_mul : âˆ€ a b, C a â†’ C b â†’ C (a * b)) (h_add : âˆ€ a b, C a â†’ C b â†’ C (a + b))
    (a : TensorAlgebra R M) : C a := by
  -- the arguments are enough to construct a subalgebra, and a mapping into it from M
  let s : Subalgebra R (TensorAlgebra R M) :=
    { carrier := C
      mul_mem' := @h_mul
      add_mem' := @h_add
      algebraMap_mem' := h_grade0 }
  -- porting note: Added `h`. `h` is needed for `of`.
  let h : AddCommMonoid s := inferInstanceAs (AddCommMonoid (Subalgebra.toSubmodule s))
  -- âŠ¢ C a
  let of : M â†’â‚—[R] s := (Î¹ R).codRestrict (Subalgebra.toSubmodule s) h_grade1
  -- âŠ¢ C a
  -- the mapping through the subalgebra is the identity
  have of_id : AlgHom.id R (TensorAlgebra R M) = s.val.comp (lift R of) := by
    ext
    simp
    erw [LinearMap.codRestrict_apply]
  -- finding a proof is finding an element of the subalgebra
  rw [â† AlgHom.id_apply (R := R) a, of_id]
  -- âŠ¢ C (â†‘(AlgHom.comp (Subalgebra.val s) (â†‘(lift R) of)) a)
  exact Subtype.prop (lift R of a)
  -- ğŸ‰ no goals
#align tensor_algebra.induction TensorAlgebra.induction

/-- The left-inverse of `algebraMap`. -/
def algebraMapInv : TensorAlgebra R M â†’â‚[R] R :=
  lift R (0 : M â†’â‚—[R] R)
#align tensor_algebra.algebra_map_inv TensorAlgebra.algebraMapInv

variable (M)

theorem algebraMap_leftInverse :
    Function.LeftInverse algebraMapInv (algebraMap R <| TensorAlgebra R M) := fun x => by
  simp [algebraMapInv]
  -- ğŸ‰ no goals
#align tensor_algebra.algebra_map_left_inverse TensorAlgebra.algebraMap_leftInverse

@[simp]
theorem algebraMap_inj (x y : R) :
    algebraMap R (TensorAlgebra R M) x = algebraMap R (TensorAlgebra R M) y â†” x = y :=
  (algebraMap_leftInverse M).injective.eq_iff
#align tensor_algebra.algebra_map_inj TensorAlgebra.algebraMap_inj

@[simp]
theorem algebraMap_eq_zero_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 0 â†” x = 0 :=
  map_eq_zero_iff (algebraMap _ _) (algebraMap_leftInverse _).injective
#align tensor_algebra.algebra_map_eq_zero_iff TensorAlgebra.algebraMap_eq_zero_iff

@[simp]
theorem algebraMap_eq_one_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 1 â†” x = 1 :=
  map_eq_one_iff (algebraMap _ _) (algebraMap_leftInverse _).injective
#align tensor_algebra.algebra_map_eq_one_iff TensorAlgebra.algebraMap_eq_one_iff

variable {M}

/-- The canonical map from `TensorAlgebra R M` into `TrivSqZeroExt R M` that sends
`TensorAlgebra.Î¹` to `TrivSqZeroExt.inr`. -/
def toTrivSqZeroExt [Module Ráµáµ’áµ– M] [IsCentralScalar R M] :
    TensorAlgebra R M â†’â‚[R] TrivSqZeroExt R M :=
  lift R (TrivSqZeroExt.inrHom R M)
#align tensor_algebra.to_triv_sq_zero_ext TensorAlgebra.toTrivSqZeroExt

@[simp]
theorem toTrivSqZeroExt_Î¹ (x : M) [Module Ráµáµ’áµ– M] [IsCentralScalar R M] :
    toTrivSqZeroExt (Î¹ R x) = TrivSqZeroExt.inr x :=
  lift_Î¹_apply _ _
#align tensor_algebra.to_triv_sq_zero_ext_Î¹ TensorAlgebra.toTrivSqZeroExt_Î¹

/-- The left-inverse of `Î¹`.

As an implementation detail, we implement this using `TrivSqZeroExt` which has a suitable
algebra structure. -/
def Î¹Inv : TensorAlgebra R M â†’â‚—[R] M := by
  letI : Module Ráµáµ’áµ– M := Module.compHom _ ((RingHom.id R).fromOpposite mul_comm)
  -- âŠ¢ TensorAlgebra R M â†’â‚—[R] M
  haveI : IsCentralScalar R M := âŸ¨fun r m => rflâŸ©
  -- âŠ¢ TensorAlgebra R M â†’â‚—[R] M
  exact (TrivSqZeroExt.sndHom R M).comp toTrivSqZeroExt.toLinearMap
  -- ğŸ‰ no goals
#align tensor_algebra.Î¹_inv TensorAlgebra.Î¹Inv

theorem Î¹_leftInverse : Function.LeftInverse Î¹Inv (Î¹ R : M â†’ TensorAlgebra R M) := fun x => by
  -- porting note: needs the last two `simp` lemmas explicitly in order to use them
  simp [Î¹Inv, (AlgHom.toLinearMap_apply), toTrivSqZeroExt_Î¹ _]
  -- ğŸ‰ no goals
#align tensor_algebra.Î¹_left_inverse TensorAlgebra.Î¹_leftInverse

variable (R)

@[simp]
theorem Î¹_inj (x y : M) : Î¹ R x = Î¹ R y â†” x = y :=
  Î¹_leftInverse.injective.eq_iff
#align tensor_algebra.Î¹_inj TensorAlgebra.Î¹_inj

@[simp]
theorem Î¹_eq_zero_iff (x : M) : Î¹ R x = 0 â†” x = 0 := by rw [â† Î¹_inj R x 0, LinearMap.map_zero]
                                                        -- ğŸ‰ no goals
#align tensor_algebra.Î¹_eq_zero_iff TensorAlgebra.Î¹_eq_zero_iff

variable {R}

@[simp]
theorem Î¹_eq_algebraMap_iff (x : M) (r : R) : Î¹ R x = algebraMap R _ r â†” x = 0 âˆ§ r = 0 := by
  refine' âŸ¨fun h => _, _âŸ©
  -- âŠ¢ x = 0 âˆ§ r = 0
  Â· letI : Module Ráµáµ’áµ– M := Module.compHom _ ((RingHom.id R).fromOpposite mul_comm)
    -- âŠ¢ x = 0 âˆ§ r = 0
    haveI : IsCentralScalar R M := âŸ¨fun r m => rflâŸ©
    -- âŠ¢ x = 0 âˆ§ r = 0
    have hf0 : toTrivSqZeroExt (Î¹ R x) = (0, x) := lift_Î¹_apply _ _
    -- âŠ¢ x = 0 âˆ§ r = 0
    rw [h, AlgHom.commutes] at hf0
    -- âŠ¢ x = 0 âˆ§ r = 0
    have : r = 0 âˆ§ 0 = x := Prod.ext_iff.1 hf0
    -- âŠ¢ x = 0 âˆ§ r = 0
    exact this.symm.imp_left Eq.symm
    -- ğŸ‰ no goals
  Â· rintro âŸ¨rfl, rflâŸ©
    -- âŠ¢ â†‘(Î¹ R) 0 = â†‘(algebraMap R (TensorAlgebra R M)) 0
    rw [LinearMap.map_zero, RingHom.map_zero]
    -- ğŸ‰ no goals
#align tensor_algebra.Î¹_eq_algebra_map_iff TensorAlgebra.Î¹_eq_algebraMap_iff

@[simp]
theorem Î¹_ne_one [Nontrivial R] (x : M) : Î¹ R x â‰  1 := by
  rw [â† (algebraMap R (TensorAlgebra R M)).map_one, Ne.def, Î¹_eq_algebraMap_iff]
  -- âŠ¢ Â¬(x = 0 âˆ§ 1 = 0)
  exact one_ne_zero âˆ˜ And.right
  -- ğŸ‰ no goals
#align tensor_algebra.Î¹_ne_one TensorAlgebra.Î¹_ne_one

/-- The generators of the tensor algebra are disjoint from its scalars. -/
theorem Î¹_range_disjoint_one :
    Disjoint (LinearMap.range (Î¹ R : M â†’â‚—[R] TensorAlgebra R M))
      (1 : Submodule R (TensorAlgebra R M)) := by
  rw [Submodule.disjoint_def]
  -- âŠ¢ âˆ€ (x : TensorAlgebra R M), x âˆˆ LinearMap.range (Î¹ R) â†’ x âˆˆ 1 â†’ x = 0
  rintro _ âŸ¨x, hxâŸ© âŸ¨r, rflâŸ©
  -- âŠ¢ â†‘(Algebra.linearMap R (TensorAlgebra R M)) r = 0
  rw [Algebra.linearMap_apply, Î¹_eq_algebraMap_iff] at hx
  -- âŠ¢ â†‘(Algebra.linearMap R (TensorAlgebra R M)) r = 0
  rw [hx.2, map_zero]
  -- ğŸ‰ no goals
#align tensor_algebra.Î¹_range_disjoint_one TensorAlgebra.Î¹_range_disjoint_one

variable (R M)

/-- Construct a product of `n` elements of the module within the tensor algebra.

See also `PiTensorProduct.tprod`. -/
def tprod (n : â„•) : MultilinearMap R (fun _ : Fin n => M) (TensorAlgebra R M) :=
  (MultilinearMap.mkPiAlgebraFin R n (TensorAlgebra R M)).compLinearMap fun _ => Î¹ R
#align tensor_algebra.tprod TensorAlgebra.tprod

@[simp]
theorem tprod_apply {n : â„•} (x : Fin n â†’ M) : tprod R M n x = (List.ofFn fun i => Î¹ R (x i)).prod :=
  rfl
#align tensor_algebra.tprod_apply TensorAlgebra.tprod_apply

variable {R M}

end TensorAlgebra

namespace FreeAlgebra

variable {R M}

/-- The canonical image of the `FreeAlgebra` in the `TensorAlgebra`, which maps
`FreeAlgebra.Î¹ R x` to `TensorAlgebra.Î¹ R x`. -/
def toTensor : FreeAlgebra R M â†’â‚[R] TensorAlgebra R M :=
  FreeAlgebra.lift R (TensorAlgebra.Î¹ R)
#align free_algebra.to_tensor FreeAlgebra.toTensor

@[simp]
theorem toTensor_Î¹ (m : M) : FreeAlgebra.toTensor (FreeAlgebra.Î¹ R m) = TensorAlgebra.Î¹ R m := by
  simp [toTensor]
  -- ğŸ‰ no goals
#align free_algebra.to_tensor_Î¹ FreeAlgebra.toTensor_Î¹

end FreeAlgebra
