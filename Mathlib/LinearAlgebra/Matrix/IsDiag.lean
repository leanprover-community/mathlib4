/-
Copyright (c) 2021 Lu-Ming Zhang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Lu-Ming Zhang
-/
import Mathlib.LinearAlgebra.Matrix.Symmetric
import Mathlib.LinearAlgebra.Matrix.Orthogonal
import Mathlib.Data.Matrix.Kronecker

#align_import linear_algebra.matrix.is_diag from "leanprover-community/mathlib"@"55e2dfde0cff928ce5c70926a3f2c7dee3e2dd99"

/-!
# Diagonal matrices

This file contains the definition and basic results about diagonal matrices.

## Main results

- `Matrix.IsDiag`: a proposition that states a given square matrix `A` is diagonal.

## Tags

diag, diagonal, matrix
-/


namespace Matrix

variable {Î± Î² R n m : Type*}

open Function

open Matrix Kronecker

/-- `A.IsDiag` means square matrix `A` is a diagonal matrix. -/
def IsDiag [Zero Î±] (A : Matrix n n Î±) : Prop :=
  âˆ€ â¦ƒi jâ¦„, i â‰  j â†’ A i j = 0
#align matrix.is_diag Matrix.IsDiag

@[simp]
theorem isDiag_diagonal [Zero Î±] [DecidableEq n] (d : n â†’ Î±) : (diagonal d).IsDiag := fun _ _ =>
  Matrix.diagonal_apply_ne _
#align matrix.is_diag_diagonal Matrix.isDiag_diagonal

/-- Diagonal matrices are generated by the `Matrix.diagonal` of their `Matrix.diag`. -/
theorem IsDiag.diagonal_diag [Zero Î±] [DecidableEq n] {A : Matrix n n Î±} (h : A.IsDiag) :
    diagonal (diag A) = A :=
  ext fun i j => by
    obtain rfl | hij := Decidable.eq_or_ne i j
    -- âŠ¢ diagonal (diag A) i i = A i i
    Â· rw [diagonal_apply_eq, diag]
      -- ğŸ‰ no goals
    Â· rw [diagonal_apply_ne _ hij, h hij]
      -- ğŸ‰ no goals
#align matrix.is_diag.diagonal_diag Matrix.IsDiag.diagonal_diag

/-- `Matrix.IsDiag.diagonal_diag` as an iff. -/
theorem isDiag_iff_diagonal_diag [Zero Î±] [DecidableEq n] (A : Matrix n n Î±) :
    A.IsDiag â†” diagonal (diag A) = A :=
  âŸ¨IsDiag.diagonal_diag, fun hd => hd â–¸ isDiag_diagonal (diag A)âŸ©
#align matrix.is_diag_iff_diagonal_diag Matrix.isDiag_iff_diagonal_diag

/-- Every matrix indexed by a subsingleton is diagonal. -/
theorem isDiag_of_subsingleton [Zero Î±] [Subsingleton n] (A : Matrix n n Î±) : A.IsDiag :=
  fun i j h => (h <| Subsingleton.elim i j).elim
#align matrix.is_diag_of_subsingleton Matrix.isDiag_of_subsingleton

/-- Every zero matrix is diagonal. -/
@[simp]
theorem isDiag_zero [Zero Î±] : (0 : Matrix n n Î±).IsDiag := fun _ _ _ => rfl
#align matrix.is_diag_zero Matrix.isDiag_zero

/-- Every identity matrix is diagonal. -/
@[simp]
theorem isDiag_one [DecidableEq n] [Zero Î±] [One Î±] : (1 : Matrix n n Î±).IsDiag := fun _ _ =>
  one_apply_ne
#align matrix.is_diag_one Matrix.isDiag_one

theorem IsDiag.map [Zero Î±] [Zero Î²] {A : Matrix n n Î±} (ha : A.IsDiag) {f : Î± â†’ Î²} (hf : f 0 = 0) :
    (A.map f).IsDiag := by
  intro i j h
  -- âŠ¢ Matrix.map A f i j = 0
  simp [ha h, hf]
  -- ğŸ‰ no goals
#align matrix.is_diag.map Matrix.IsDiag.map

theorem IsDiag.neg [AddGroup Î±] {A : Matrix n n Î±} (ha : A.IsDiag) : (-A).IsDiag := by
  intro i j h
  -- âŠ¢ (-A) i j = 0
  simp [ha h]
  -- ğŸ‰ no goals
#align matrix.is_diag.neg Matrix.IsDiag.neg

@[simp]
theorem isDiag_neg_iff [AddGroup Î±] {A : Matrix n n Î±} : (-A).IsDiag â†” A.IsDiag :=
  âŸ¨fun ha _ _ h => neg_eq_zero.1 (ha h), IsDiag.negâŸ©
#align matrix.is_diag_neg_iff Matrix.isDiag_neg_iff

theorem IsDiag.add [AddZeroClass Î±] {A B : Matrix n n Î±} (ha : A.IsDiag) (hb : B.IsDiag) :
    (A + B).IsDiag := by
  intro i j h
  -- âŠ¢ (A + B) i j = 0
  simp [ha h, hb h]
  -- ğŸ‰ no goals
#align matrix.is_diag.add Matrix.IsDiag.add

theorem IsDiag.sub [AddGroup Î±] {A B : Matrix n n Î±} (ha : A.IsDiag) (hb : B.IsDiag) :
    (A - B).IsDiag := by
  intro i j h
  -- âŠ¢ (A - B) i j = 0
  simp [ha h, hb h]
  -- ğŸ‰ no goals
#align matrix.is_diag.sub Matrix.IsDiag.sub

theorem IsDiag.smul [Monoid R] [AddMonoid Î±] [DistribMulAction R Î±] (k : R) {A : Matrix n n Î±}
    (ha : A.IsDiag) : (k â€¢ A).IsDiag := by
  intro i j h
  -- âŠ¢ (k â€¢ A) i j = 0
  simp [ha h]
  -- ğŸ‰ no goals
#align matrix.is_diag.smul Matrix.IsDiag.smul

@[simp]
theorem isDiag_smul_one (n) [Semiring Î±] [DecidableEq n] (k : Î±) :
    (k â€¢ (1 : Matrix n n Î±)).IsDiag :=
  isDiag_one.smul k
#align matrix.is_diag_smul_one Matrix.isDiag_smul_one

theorem IsDiag.transpose [Zero Î±] {A : Matrix n n Î±} (ha : A.IsDiag) : Aáµ€.IsDiag := fun _ _ h =>
  ha h.symm
#align matrix.is_diag.transpose Matrix.IsDiag.transpose

@[simp]
theorem isDiag_transpose_iff [Zero Î±] {A : Matrix n n Î±} : Aáµ€.IsDiag â†” A.IsDiag :=
  âŸ¨IsDiag.transpose, IsDiag.transposeâŸ©
#align matrix.is_diag_transpose_iff Matrix.isDiag_transpose_iff

theorem IsDiag.conjTranspose [Semiring Î±] [StarRing Î±] {A : Matrix n n Î±} (ha : A.IsDiag) :
    Aá´´.IsDiag :=
  ha.transpose.map (star_zero _)
#align matrix.is_diag.conj_transpose Matrix.IsDiag.conjTranspose

@[simp]
theorem isDiag_conjTranspose_iff [Semiring Î±] [StarRing Î±] {A : Matrix n n Î±} :
    Aá´´.IsDiag â†” A.IsDiag :=
  âŸ¨fun ha => by
    convert ha.conjTranspose
    -- âŠ¢ A = Aá´´á´´
    simp, IsDiag.conjTransposeâŸ©
    -- ğŸ‰ no goals
#align matrix.is_diag_conj_transpose_iff Matrix.isDiag_conjTranspose_iff

theorem IsDiag.submatrix [Zero Î±] {A : Matrix n n Î±} (ha : A.IsDiag) {f : m â†’ n}
    (hf : Injective f) : (A.submatrix f f).IsDiag := fun _ _ h => ha (hf.ne h)
#align matrix.is_diag.submatrix Matrix.IsDiag.submatrix

/-- `(A âŠ— B).IsDiag` if both `A` and `B` are diagonal. -/
theorem IsDiag.kronecker [MulZeroClass Î±] {A : Matrix m m Î±} {B : Matrix n n Î±} (hA : A.IsDiag)
    (hB : B.IsDiag) : (A âŠ—â‚– B).IsDiag := by
  rintro âŸ¨a, bâŸ© âŸ¨c, dâŸ© h
  -- âŠ¢ kroneckerMap (fun x x_1 => x * x_1) A B (a, b) (c, d) = 0
  simp only [Prod.mk.inj_iff, Ne.def, not_and_or] at h
  -- âŠ¢ kroneckerMap (fun x x_1 => x * x_1) A B (a, b) (c, d) = 0
  cases' h with hac hbd
  -- âŠ¢ kroneckerMap (fun x x_1 => x * x_1) A B (a, b) (c, d) = 0
  Â· simp [hA hac]
    -- ğŸ‰ no goals
  Â· simp [hB hbd]
    -- ğŸ‰ no goals
#align matrix.is_diag.kronecker Matrix.IsDiag.kronecker

theorem IsDiag.isSymm [Zero Î±] {A : Matrix n n Î±} (h : A.IsDiag) : A.IsSymm := by
  ext i j
  -- âŠ¢ Aáµ€ i j = A i j
  by_cases g : i = j; Â· rw [g, transpose_apply]
  -- âŠ¢ Aáµ€ i j = A i j
                        -- ğŸ‰ no goals
  simp [h g, h (Ne.symm g)]
  -- ğŸ‰ no goals
#align matrix.is_diag.is_symm Matrix.IsDiag.isSymm

/-- The block matrix `A.fromBlocks 0 0 D` is diagonal if `A` and `D` are diagonal. -/
theorem IsDiag.fromBlocks [Zero Î±] {A : Matrix m m Î±} {D : Matrix n n Î±} (ha : A.IsDiag)
    (hd : D.IsDiag) : (A.fromBlocks 0 0 D).IsDiag := by
  rintro (i | i) (j | j) hij
  Â· exact ha (ne_of_apply_ne _ hij)
    -- ğŸ‰ no goals
  Â· rfl
    -- ğŸ‰ no goals
  Â· rfl
    -- ğŸ‰ no goals
  Â· exact hd (ne_of_apply_ne _ hij)
    -- ğŸ‰ no goals
#align matrix.is_diag.from_blocks Matrix.IsDiag.fromBlocks

/-- This is the `iff` version of `Matrix.IsDiag.fromBlocks`. -/
theorem isDiag_fromBlocks_iff [Zero Î±] {A : Matrix m m Î±} {B : Matrix m n Î±} {C : Matrix n m Î±}
    {D : Matrix n n Î±} : (A.fromBlocks B C D).IsDiag â†” A.IsDiag âˆ§ B = 0 âˆ§ C = 0 âˆ§ D.IsDiag := by
  constructor
  -- âŠ¢ IsDiag (fromBlocks A B C D) â†’ IsDiag A âˆ§ B = 0 âˆ§ C = 0 âˆ§ IsDiag D
  Â· intro h
    -- âŠ¢ IsDiag A âˆ§ B = 0 âˆ§ C = 0 âˆ§ IsDiag D
    refine' âŸ¨fun i j hij => _, ext fun i j => _, ext fun i j => _, fun i j hij => _âŸ©
    Â· exact h (Sum.inl_injective.ne hij)
      -- ğŸ‰ no goals
    Â· exact h Sum.inl_ne_inr
      -- ğŸ‰ no goals
    Â· exact h Sum.inr_ne_inl
      -- ğŸ‰ no goals
    Â· exact h (Sum.inr_injective.ne hij)
      -- ğŸ‰ no goals
  Â· rintro âŸ¨ha, hb, hc, hdâŸ©
    -- âŠ¢ IsDiag (fromBlocks A B C D)
    convert IsDiag.fromBlocks ha hd
    -- ğŸ‰ no goals
#align matrix.is_diag_from_blocks_iff Matrix.isDiag_fromBlocks_iff

/-- A symmetric block matrix `A.fromBlocks B C D` is diagonal
    if `A` and `D` are diagonal and `B` is `0`. -/
theorem IsDiag.fromBlocks_of_isSymm [Zero Î±] {A : Matrix m m Î±} {C : Matrix n m Î±}
    {D : Matrix n n Î±} (h : (A.fromBlocks 0 C D).IsSymm) (ha : A.IsDiag) (hd : D.IsDiag) :
    (A.fromBlocks 0 C D).IsDiag := by
  rw [â† (isSymm_fromBlocks_iff.1 h).2.1]
  -- âŠ¢ IsDiag (Matrix.fromBlocks A 0 0áµ€ D)
  exact ha.fromBlocks hd
  -- ğŸ‰ no goals
#align matrix.is_diag.from_blocks_of_is_symm Matrix.IsDiag.fromBlocks_of_isSymm

theorem mul_transpose_self_isDiag_iff_hasOrthogonalRows [Fintype n] [Mul Î±] [AddCommMonoid Î±]
    {A : Matrix m n Î±} : (A * Aáµ€).IsDiag â†” A.HasOrthogonalRows :=
  Iff.rfl
#align matrix.mul_transpose_self_is_diag_iff_has_orthogonal_rows Matrix.mul_transpose_self_isDiag_iff_hasOrthogonalRows

theorem transpose_mul_self_isDiag_iff_hasOrthogonalCols [Fintype m] [Mul Î±] [AddCommMonoid Î±]
    {A : Matrix m n Î±} : (Aáµ€ * A).IsDiag â†” A.HasOrthogonalCols :=
  Iff.rfl
#align matrix.transpose_mul_self_is_diag_iff_has_orthogonal_cols Matrix.transpose_mul_self_isDiag_iff_hasOrthogonalCols

end Matrix
