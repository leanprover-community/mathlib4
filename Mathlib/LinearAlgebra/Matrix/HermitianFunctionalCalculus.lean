/-
Copyright (c) 2024 Jon Bannon. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jon Bannon, Jireh Loreaux
-/

import Mathlib.LinearAlgebra.Matrix.Spectrum
import Mathlib.Analysis.NormedSpace.Star.ContinuousFunctionalCalculus
import Mathlib.Topology.ContinuousFunction.UniqueCFC
import Mathlib.Analysis.NormedSpace.Star.Matrix
import Mathlib.Algebra.Star.Unitary

/-!
# Continuous Functional Calculus for Hermitian Matrices

This file defines an instance of the continuous functional calculus for Hermitian matrices over an
RCLike field ùïú.

## Main Results

- definition of œÜ : the real StarAlgHom from C(spectrum ‚Ñù A, ‚Ñù) to (Matrix n n ùïú) appearing in the
                    instance.
- instContinuousFunctionalCalculus : Instance of the Continuous functional Calculus for a hermitian
                                     matrix A over ùïú.

## Tags

spectral theorem, diagonalization theorem, continuous functional calculus
-/

section SpectrumDiagonal

variable {R : Type*} [Field R] {n : Type*} [DecidableEq n][Fintype n]

open Module.End

/--  Standard basis vectors are eigenvectors of any associated diagonal linear operator. -/
lemma Matrix.hasEigenvector_toLin'_diagonal (d : n ‚Üí R) (i : n) :
    Module.End.HasEigenvector (Matrix.toLin' (diagonal d)) (d i) (Pi.basisFun R n i) := by
  constructor
  ¬∑ rw [mem_eigenspace_iff]
    ext j
    simp only [diagonal, Pi.basisFun_apply, toLin'_apply, mulVec_stdBasis_apply, transpose_apply,
      of_apply, Pi.smul_apply, LinearMap.stdBasis_apply', smul_eq_mul, mul_ite, mul_one, mul_zero]
    split_ifs
    all_goals simp_all
  ¬∑ rw [Function.ne_iff]; simp

/-- Eigenvalues of a diagonal linear operator are the diagonal entries. -/
lemma Matrix.hasEigenvalue_toLin'_diagonal_iff (d : n ‚Üí R) {Œº : R} :
    HasEigenvalue (toLin' (diagonal d)) Œº ‚Üî ‚àÉ i, d i = Œº := by
  have (i : n) : HasEigenvalue (toLin' (diagonal d)) (d i) := by
    exact hasEigenvalue_of_hasEigenvector <| hasEigenvector_toLin'_diagonal d i
  constructor
  ¬∑ contrapose!
    intro hŒº h_eig
    have h_iSup : ‚®Ü Œº ‚àà Set.range d, eigenspace (toLin' (diagonal d)) Œº = ‚ä§ := by
      rw [eq_top_iff, ‚Üê (Pi.basisFun R n).span_eq, Submodule.span_le]
      rintro - ‚ü®i, rfl‚ü©
      simp only [SetLike.mem_coe]
      apply Submodule.mem_iSup_of_mem (d i)
      apply Submodule.mem_iSup_of_mem ‚ü®i, rfl‚ü©
      rw [mem_eigenspace_iff]
      exact (hasEigenvector_toLin'_diagonal d i).apply_eq_smul
    have hŒº_not_mem : Œº ‚àâ Set.range d := by simpa using fun i ‚Ü¶ (hŒº i)
    have := eigenspaces_independent (toLin' (diagonal d)) |>.disjoint_biSup hŒº_not_mem
    rw [h_iSup, disjoint_top] at this
    exact h_eig this
  ¬∑ rintro ‚ü®i, rfl‚ü©
    exact this i

/-- The spectrum of the diagonal operator is the range of the diagonal viewed as a function. -/
lemma Matrix.spectrum_diagonal (d : n ‚Üí R) :
    spectrum R (diagonal d) = Set.range d := by
  ext Œº
  rw [‚Üê AlgEquiv.spectrum_eq (Matrix.toLinAlgEquiv <| Pi.basisFun R n),
    ‚Üê hasEigenvalue_iff_mem_spectrum, Set.mem_range]
  exact Matrix.hasEigenvalue_toLin'_diagonal_iff d

end SpectrumDiagonal
namespace Matrix

variable {n ùïú : Type*} [RCLike ùïú] [Fintype n] [DecidableEq n] {A : Matrix n n ùïú}

lemma finite_real_spectrum : (spectrum ‚Ñù A).Finite := by
  rw [‚Üê spectrum.preimage_algebraMap ùïú]
  exact A.finite_spectrum.preimage (NoZeroSMulDivisors.algebraMap_injective ‚Ñù ùïú).injOn

instance : Finite (spectrum ‚Ñù A) := A.finite_real_spectrum

namespace IsHermitian

variable (hA : IsHermitian A)

/-- The ‚Ñù-spectrum of a Hermitian Matrix over RCLike field is the range of the eigenvalue function-/
theorem eigenvalues_eq_spectrum {a : Matrix n n ùïú} (ha : IsHermitian a) :
    (spectrum ‚Ñù a) = Set.range (ha.eigenvalues) := by
  ext x
  conv_lhs => rw [ha.spectral_theorem, unitary.spectrum.unitary_conjugate,
  ‚Üê spectrum.algebraMap_mem_iff ùïú, spectrum_diagonal, RCLike.algebraMap_eq_ofReal]
  simp

/--Eigenvalues of a Hermitian Matrix, coerced, belong to the spectrum of the assoc.toEuclideanLin -/
theorem ofReal_eigenvalue_mem_spectrum_toEuclideanLin (i : n) :
    (RCLike.ofReal ‚àò hA.eigenvalues) i ‚àà spectrum ùïú (toEuclideanLin A) :=
  LinearMap.IsSymmetric.hasEigenvalue_eigenvalues _ _ _ |>.mem_spectrum

/-- Algebra equivalence between the linear maps and continuous linear maps on a finite-dim module.
Compare with `LinearMap.toContinuousLinearMap`, the linear equivalence version of this result.-/
def Module.End.toContinuousLinearMap.{v} (E : Type v) [NormedAddCommGroup E]
    [NormedSpace ùïú E][FiniteDimensional ùïú E] : (E ‚Üí‚Çó[ùïú] E) ‚âÉ‚Çê[ùïú] (E ‚ÜíL[ùïú] E) :=
    {LinearMap.toContinuousLinearMap with
    map_mul' := fun _ _ ‚Ü¶ rfl
    commutes' := fun _ ‚Ü¶ rfl}

/--Spectrum of a Hermitian matrix equals the spectrum as a EuclideanLin. -/
theorem spec_toEuclideanLin_eq_spec : spectrum ùïú (toEuclideanLin A) = spectrum ùïú A :=
  AlgEquiv.spectrum_eq ((AlgEquiv.trans ((toEuclideanCLM : Matrix n n ùïú ‚âÉ‚ãÜ‚Çê[ùïú]
  EuclideanSpace ùïú n ‚ÜíL[ùïú] EuclideanSpace ùïú n) : Matrix n n ùïú ‚âÉ‚Çê[ùïú]
  EuclideanSpace ùïú n ‚ÜíL[ùïú] EuclideanSpace ùïú n))
  (Module.End.toContinuousLinearMap (EuclideanSpace ùïú n)).symm) _

/--Definition of the StarAlgHom for the functional calculus of a Hermitian matrix. -/
@[simps]
noncomputable def cfc : StarAlgHom ‚Ñù C(spectrum ‚Ñù A, ‚Ñù) (Matrix n n ùïú) where
  toFun := fun g => (eigenvectorUnitary hA : Matrix n n ùïú) *
    diagonal (RCLike.ofReal ‚àò g ‚àò (fun i ‚Ü¶ ‚ü®hA.eigenvalues i, hA.eigenvalues_mem_spectrum_real i‚ü©))
    * star (eigenvectorUnitary hA : Matrix n n ùïú)
  map_one' := by simp [Pi.one_def (f := fun _ : n ‚Ü¶ ùïú)]
  map_mul' f g := by
    have {a b c d e f : Matrix n n ùïú} : (a * b * c) * (d * e * f) = a * (b * (c * d) * e) * f := by
      simp only [mul_assoc]
    simp only [this, ContinuousMap.coe_mul, SetLike.coe_mem, unitary.star_mul_self_of_mem, mul_one,
      diagonal_mul_diagonal, Function.comp_apply]
    congr! with i
    simp
  map_zero' := by simp [Pi.zero_def (f := fun _ : n ‚Ü¶ ùïú)]
  map_add' f g := by
    simp only [ContinuousMap.coe_add, ‚Üê add_mul, ‚Üê mul_add, diagonal_add, Function.comp_apply]
    congr! with i
    simp
  commutes' r := by
    simp only [Function.comp, algebraMap_apply, smul_eq_mul, mul_one]
    rw [‚Üê mul_one (algebraMap _ _ _), ‚Üê unitary.coe_mul_star_self hA.eigenvectorUnitary,
      ‚Üê Algebra.left_comm, unitary.coe_star, mul_assoc]
    congr!
  map_star' f := by
    simp only [star_trivial, StarMul.star_mul, star_star, star_eq_conjTranspose (diagonal _),
      diagonal_conjTranspose, mul_assoc]
    congr!
    ext
    simp
#exit
/-- Instance of the Continuous Functional Calculus for a Hermitian Matrix over an RCLike field.-/
instance instContinuousFunctionalCalculus :
    ContinuousFunctionalCalculus ‚Ñù (IsHermitian : Matrix n n ùïú ‚Üí Prop) where
  exists_cfc_of_predicate a ha := by
    refine ‚ü®cfc ha, ?closedEmbedding, ?mapId, ?map_spec, ?hermitian‚ü©
    case closedEmbedding =>
      have h0 : FiniteDimensional ‚Ñù C(spectrum ‚Ñù a, ‚Ñù) := by
        apply FiniteDimensional.of_injective (ContinuousMap.coeFnLinearMap ‚Ñù (M := ‚Ñù))
        exact DFunLike.coe_injective
      have hcfc : LinearMap.ker ha.cfc = ‚ä• := by
        refine LinearMap.ker_eq_bot'.mpr ?_
        intro f hf
        have h2 : diagonal
             (RCLike.ofReal ‚àò ‚áëf ‚àò fun i ‚Ü¶ ‚ü®ha.eigenvalues i, ha.eigenvalues_mem_spectrum_real i‚ü©)
             = (0 : Matrix n n ùïú) := by
           rw [cfc_apply] at hf
           have hlr : (star ha.eigenvectorUnitary : Matrix n n ùïú) *
              ((eigenvectorUnitary ha : Matrix n n ùïú) * diagonal (RCLike.ofReal ‚àò f ‚àò
                (fun i ‚Ü¶ ‚ü®ha.eigenvalues i, ha.eigenvalues_mem_spectrum_real i‚ü©)) *
                star (eigenvectorUnitary ha : Matrix n n ùïú)) *
                (ha.eigenvectorUnitary : Matrix n n ùïú) =
                (star ha.eigenvectorUnitary : Matrix n n ùïú) *
                (0 : Matrix n n ùïú) * (ha.eigenvectorUnitary : Matrix n n ùïú) := by congr
           simp only [‚Üê mul_assoc, SetLike.coe_mem, unitary.star_mul_self_of_mem, one_mul,
                    mul_zero, zero_mul] at hlr
           simp only [mul_assoc, SetLike.coe_mem, unitary.star_mul_self_of_mem, mul_one] at hlr
           exact hlr
        ext x
        simp only [ContinuousMap.zero_apply]
        obtain ‚ü®x, hx‚ü© := x
        obtain ‚ü®i, rfl‚ü© := ha.eigenvalues_eq_spectrum ‚ñ∏ hx
        rw [‚Üê diagonal_zero] at h2
        have := (diagonal_eq_diagonal_iff).mp h2
        exact RCLike.ofReal_eq_zero.mp (this i)
      apply LinearMap.closedEmbedding_of_injective (ùïú := ‚Ñù) (E := C(spectrum ‚Ñù a, ‚Ñù))
        (F := Matrix n n ùïú) (f := ha.cfc) hcfc
    case mapId =>
      conv_rhs => rw [ha.spectral_theorem]
      congr!
    case map_spec =>
      intro f
      apply Set.eq_of_subset_of_subset
      ¬∑ rw [‚Üê ContinuousMap.spectrum_eq_range f]
        apply AlgHom.spectrum_apply_subset
      ¬∑ rw [cfc_apply, unitary.spectrum.unitary_conjugate]
        rintro - ‚ü®x , rfl‚ü©
        apply spectrum.of_algebraMap_mem (R := ‚Ñù) (S := ùïú)
        simp only [spectrum_diagonal (R := ùïú)
            (RCLike.ofReal ‚àò f ‚àò (fun i ‚Ü¶ ‚ü®ha.eigenvalues i, ha.eigenvalues_mem_spectrum_real i‚ü©))
            , Function.comp_apply, Set.mem_range]
        obtain ‚ü®x, hx‚ü© := x
        obtain ‚ü®i, rfl‚ü© := ha.eigenvalues_eq_spectrum ‚ñ∏ hx
        exact ‚ü®i, rfl‚ü©
    case hermitian =>
      intro f
      simp only [cfc_apply, mul_assoc, IsHermitian, ‚Üê star_eq_conjTranspose, star_mul, star_star]
      congr!
      rw [star_eq_conjTranspose, diagonal_conjTranspose]
      congr!
      simp only [Pi.star_def, Function.comp_apply, RCLike.star_def, RCLike.conj_ofReal]
      rfl
end IsHermitian
end Matrix
