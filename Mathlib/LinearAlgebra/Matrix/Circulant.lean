/-
Copyright (c) 2021 Lu-Ming Zhang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Lu-Ming Zhang
-/
import Mathlib.LinearAlgebra.Matrix.Symmetric

#align_import linear_algebra.matrix.circulant from "leanprover-community/mathlib"@"3e068ece210655b7b9a9477c3aff38a492400aa1"

/-!
# Circulant matrices

This file contains the definition and basic results about circulant matrices.
Given a vector `v : n â†’ Î±` indexed by a type that is endowed with subtraction,
`Matrix.circulant v` is the matrix whose `(i, j)`th entry is `v (i - j)`.

## Main results

- `Matrix.circulant`: the circulant matrix generated by a given vector `v : n â†’ Î±`.
- `Matrix.circulant_mul`: the product of two circulant matrices `circulant v` and `circulant w` is
                          the circulant matrix generated by `mulVec (circulant v) w`.
- `Matrix.circulant_mul_comm`: multiplication of circulant matrices commutes when the elements do.

## Implementation notes

`Matrix.Fin.foo` is the `Fin n` version of `Matrix.foo`.
Namely, the index type of the circulant matrices in discussion is `Fin n`.

## Tags

circulant, matrix
-/


variable {Î± Î² m n R : Type*}

namespace Matrix

open Function

open Matrix BigOperators

/-- Given the condition `[Sub n]` and a vector `v : n â†’ Î±`,
    we define `circulant v` to be the circulant matrix generated by `v` of type `Matrix n n Î±`.
    The `(i,j)`th entry is defined to be `v (i - j)`. -/
def circulant [Sub n] (v : n â†’ Î±) : Matrix n n Î± :=
  of fun i j => v (i - j)
#align matrix.circulant Matrix.circulant

-- TODO: set as an equation lemma for `circulant`, see mathlib4#3024
@[simp]
theorem circulant_apply [Sub n] (v : n â†’ Î±) (i j) : circulant v i j = v (i - j) := rfl
#align matrix.circulant_apply Matrix.circulant_apply

theorem circulant_col_zero_eq [AddGroup n] (v : n â†’ Î±) (i : n) : circulant v i 0 = v i :=
  congr_arg v (sub_zero _)
#align matrix.circulant_col_zero_eq Matrix.circulant_col_zero_eq

theorem circulant_injective [AddGroup n] : Injective (circulant : (n â†’ Î±) â†’ Matrix n n Î±) := by
  intro v w h
  -- âŠ¢ v = w
  ext k
  -- âŠ¢ v k = w k
  rw [â† circulant_col_zero_eq v, â† circulant_col_zero_eq w, h]
  -- ðŸŽ‰ no goals
#align matrix.circulant_injective Matrix.circulant_injective

theorem Fin.circulant_injective : âˆ€ n, Injective fun v : Fin n â†’ Î± => circulant v
  | 0 => by simp [Injective]
            -- ðŸŽ‰ no goals
  | n + 1 => Matrix.circulant_injective
#align matrix.fin.circulant_injective Matrix.Fin.circulant_injective

@[simp]
theorem circulant_inj [AddGroup n] {v w : n â†’ Î±} : circulant v = circulant w â†” v = w :=
  circulant_injective.eq_iff
#align matrix.circulant_inj Matrix.circulant_inj

@[simp]
theorem Fin.circulant_inj {n} {v w : Fin n â†’ Î±} : circulant v = circulant w â†” v = w :=
  (Fin.circulant_injective n).eq_iff
#align matrix.fin.circulant_inj Matrix.Fin.circulant_inj

theorem transpose_circulant [AddGroup n] (v : n â†’ Î±) :
    (circulant v)áµ€ = circulant fun i => v (-i) := by ext; simp
                                                     -- âŠ¢ (circulant v)áµ€ iâœ xâœ = circulant (fun i => v (-i)) iâœ xâœ
                                                          -- ðŸŽ‰ no goals
#align matrix.transpose_circulant Matrix.transpose_circulant

theorem conjTranspose_circulant [Star Î±] [AddGroup n] (v : n â†’ Î±) :
    (circulant v)á´´ = circulant (star fun i => v (-i)) := by ext; simp
                                                            -- âŠ¢ (circulant v)á´´ iâœ xâœ = circulant (star fun i => v (-i)) iâœ xâœ
                                                                 -- ðŸŽ‰ no goals
#align matrix.conj_transpose_circulant Matrix.conjTranspose_circulant

theorem Fin.transpose_circulant : âˆ€ {n} (v : Fin n â†’ Î±), (circulant v)áµ€ = circulant fun i => v (-i)
  | 0 => by simp [Injective]
            -- ðŸŽ‰ no goals
  | n + 1 => Matrix.transpose_circulant
#align matrix.fin.transpose_circulant Matrix.Fin.transpose_circulant

theorem Fin.conjTranspose_circulant [Star Î±] :
    âˆ€ {n} (v : Fin n â†’ Î±), (circulant v)á´´ = circulant (star fun i => v (-i))
  | 0 => by simp [Injective]
            -- ðŸŽ‰ no goals
  | n + 1 => Matrix.conjTranspose_circulant
#align matrix.fin.conj_transpose_circulant Matrix.Fin.conjTranspose_circulant

theorem map_circulant [Sub n] (v : n â†’ Î±) (f : Î± â†’ Î²) :
    (circulant v).map f = circulant fun i => f (v i) :=
  ext fun _ _ => rfl
#align matrix.map_circulant Matrix.map_circulant

theorem circulant_neg [Neg Î±] [Sub n] (v : n â†’ Î±) : circulant (-v) = -circulant v :=
  ext fun _ _ => rfl
#align matrix.circulant_neg Matrix.circulant_neg

@[simp]
theorem circulant_zero (Î± n) [Zero Î±] [Sub n] : circulant 0 = (0 : Matrix n n Î±) :=
  ext fun _ _ => rfl
#align matrix.circulant_zero Matrix.circulant_zero

theorem circulant_add [Add Î±] [Sub n] (v w : n â†’ Î±) :
    circulant (v + w) = circulant v + circulant w :=
  ext fun _ _ => rfl
#align matrix.circulant_add Matrix.circulant_add

theorem circulant_sub [Sub Î±] [Sub n] (v w : n â†’ Î±) :
    circulant (v - w) = circulant v - circulant w :=
  ext fun _ _ => rfl
#align matrix.circulant_sub Matrix.circulant_sub

/-- The product of two circulant matrices `circulant v` and `circulant w` is
    the circulant matrix generated by `mulVec (circulant v) w`. -/
theorem circulant_mul [Semiring Î±] [Fintype n] [AddGroup n] (v w : n â†’ Î±) :
    circulant v * circulant w = circulant (mulVec (circulant v) w) := by
  ext i j
  -- âŠ¢ (circulant v * circulant w) i j = circulant (mulVec (circulant v) w) i j
  simp only [mul_apply, mulVec, circulant_apply, dotProduct]
  -- âŠ¢ âˆ‘ x : n, v (i - x) * w (x - j) = âˆ‘ x : n, v (i - j - x) * w x
  refine' Fintype.sum_equiv (Equiv.subRight j) _ _ _
  -- âŠ¢ âˆ€ (x : n), v (i - x) * w (x - j) = v (i - j - â†‘(Equiv.subRight j) x) * w (â†‘( â€¦
  intro x
  -- âŠ¢ v (i - x) * w (x - j) = v (i - j - â†‘(Equiv.subRight j) x) * w (â†‘(Equiv.subRi â€¦
  simp only [Equiv.subRight_apply, sub_sub_sub_cancel_right]
  -- ðŸŽ‰ no goals
#align matrix.circulant_mul Matrix.circulant_mul

theorem Fin.circulant_mul [Semiring Î±] :
    âˆ€ {n} (v w : Fin n â†’ Î±), circulant v * circulant w = circulant (mulVec (circulant v) w)
  | 0 => by simp [Injective]
            -- ðŸŽ‰ no goals
  | n + 1 => Matrix.circulant_mul
#align matrix.fin.circulant_mul Matrix.Fin.circulant_mul

/-- Multiplication of circulant matrices commutes when the elements do. -/
theorem circulant_mul_comm [CommSemigroup Î±] [AddCommMonoid Î±] [Fintype n] [AddCommGroup n]
    (v w : n â†’ Î±) : circulant v * circulant w = circulant w * circulant v := by
  ext i j
  -- âŠ¢ (circulant v * circulant w) i j = (circulant w * circulant v) i j
  simp only [mul_apply, circulant_apply, mul_comm]
  -- âŠ¢ âˆ‘ x : n, v (i - x) * w (x - j) = âˆ‘ x : n, w (i - x) * v (x - j)
  refine' Fintype.sum_equiv ((Equiv.subLeft i).trans (Equiv.addRight j)) _ _ _
  -- âŠ¢ âˆ€ (x : n), v (i - x) * w (x - j) = w (i - â†‘((Equiv.subLeft i).trans (Equiv.a â€¦
  intro x
  -- âŠ¢ v (i - x) * w (x - j) = w (i - â†‘((Equiv.subLeft i).trans (Equiv.addRight j)) â€¦
  simp [mul_comm]
  -- âŠ¢ v (i - x) * w (x - j) = v (i - x) * w (i - (i - x + j))
  congr 2
  -- âŠ¢ x - j = i - (i - x + j)
  abel
  -- ðŸŽ‰ no goals
  -- ðŸŽ‰ no goals
#align matrix.circulant_mul_comm Matrix.circulant_mul_comm

theorem Fin.circulant_mul_comm [CommSemigroup Î±] [AddCommMonoid Î±] :
    âˆ€ {n} (v w : Fin n â†’ Î±), circulant v * circulant w = circulant w * circulant v
  | 0 => by simp [Injective]
            -- ðŸŽ‰ no goals
  | n + 1 => Matrix.circulant_mul_comm
#align matrix.fin.circulant_mul_comm Matrix.Fin.circulant_mul_comm

/-- `k â€¢ circulant v` is another circulant matrix `circulant (k â€¢ v)`. -/
theorem circulant_smul [Sub n] [SMul R Î±] (k : R) (v : n â†’ Î±) :
    circulant (k â€¢ v) = k â€¢ circulant v := rfl
#align matrix.circulant_smul Matrix.circulant_smul

@[simp]
theorem circulant_single_one (Î± n) [Zero Î±] [One Î±] [DecidableEq n] [AddGroup n] :
    circulant (Pi.single 0 1 : n â†’ Î±) = (1 : Matrix n n Î±) := by
  ext i j
  -- âŠ¢ circulant (Pi.single 0 1) i j = OfNat.ofNat 1 i j
  simp [one_apply, Pi.single_apply, sub_eq_zero]
  -- ðŸŽ‰ no goals
#align matrix.circulant_single_one Matrix.circulant_single_one

@[simp]
theorem circulant_single (n) [Semiring Î±] [DecidableEq n] [AddGroup n] [Fintype n] (a : Î±) :
    circulant (Pi.single 0 a : n â†’ Î±) = scalar n a := by
  ext i j
  -- âŠ¢ circulant (Pi.single 0 a) i j = â†‘(scalar n) a i j
  simp [Pi.single_apply, one_apply, sub_eq_zero]
  -- ðŸŽ‰ no goals
#align matrix.circulant_single Matrix.circulant_single

/-- Note we use `â†‘i = 0` instead of `i = 0` as `Fin 0` has no `0`.
This means that we cannot state this with `Pi.single` as we did with `Matrix.circulant_single`. -/
theorem Fin.circulant_ite (Î±) [Zero Î±] [One Î±] :
    âˆ€ n, circulant (fun i => ite (i.1 = 0) 1 0 : Fin n â†’ Î±) = 1
  | 0 => by simp [Injective]
            -- ðŸŽ‰ no goals
  | n + 1 => by
    rw [â† circulant_single_one]
    -- âŠ¢ (circulant fun i => if â†‘i = 0 then 1 else 0) = circulant (Pi.single 0 1)
    congr with j
    -- âŠ¢ circulant (fun i => if â†‘i = 0 then 1 else 0) j xâœ = circulant (Pi.single 0 1 â€¦
    simp [Pi.single_apply, Fin.ext_iff]
    -- ðŸŽ‰ no goals
#align matrix.fin.circulant_ite Matrix.Fin.circulant_ite

/-- A circulant of `v` is symmetric iff `v` equals its reverse. -/
theorem circulant_isSymm_iff [AddGroup n] {v : n â†’ Î±} :
    (circulant v).IsSymm â†” âˆ€ i, v (-i) = v i := by
  rw [IsSymm, transpose_circulant, circulant_inj, funext_iff]
  -- ðŸŽ‰ no goals
#align matrix.circulant_is_symm_iff Matrix.circulant_isSymm_iff

theorem Fin.circulant_isSymm_iff : âˆ€ {n} {v : Fin n â†’ Î±}, (circulant v).IsSymm â†” âˆ€ i, v (-i) = v i
  | 0 => by simp [IsSymm.ext_iff, IsEmpty.forall_iff]
            -- ðŸŽ‰ no goals
  | n + 1 => Matrix.circulant_isSymm_iff
#align matrix.fin.circulant_is_symm_iff Matrix.Fin.circulant_isSymm_iff

/-- If `circulant v` is symmetric, `âˆ€ i j : I, v (- i) = v i`. -/
theorem circulant_isSymm_apply [AddGroup n] {v : n â†’ Î±} (h : (circulant v).IsSymm) (i : n) :
    v (-i) = v i :=
  circulant_isSymm_iff.1 h i
#align matrix.circulant_is_symm_apply Matrix.circulant_isSymm_apply

theorem Fin.circulant_isSymm_apply {n} {v : Fin n â†’ Î±} (h : (circulant v).IsSymm) (i : Fin n) :
    v (-i) = v i :=
  Fin.circulant_isSymm_iff.1 h i
#align matrix.fin.circulant_is_symm_apply Matrix.Fin.circulant_isSymm_apply

end Matrix
