/-
Copyright (c) 2025 Peter Pfaffelhuber. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author: Peter Pfaffelhuber
-/

import Mathlib.LinearAlgebra.Matrix.PosDef
import Mathlib.MeasureTheory.Function.L2Space
import Mathlib.MeasureTheory.Measure.Lebesgue.Basic

/-! # Gram Matrices

This file defines Gram matrices and proves their positive semi-definiteness.
Results require `RCLike ùïú`.

## Main definition

* `Matrix.Gram` : the `Matrix n n ùïú` with `‚ü™v i, v j‚ü´` at `i j : n`, where `v : n ‚Üí Œ±` for an
`InnerProductSpace ùïú Œ±`.
* `Matrix.L2Gram` : special case of `Matrix.Gram` where the `InnerProductSpace ùïú Œ±`
  is an `L2`-space.

## Main results

* `Matrix.Gram.PosSemidef` Gram matrices are positive semi-definite.
-/

open RCLike Real Matrix MeasureTheory

open scoped InnerProductSpace

variable {E n : Type*}
variable {Œ± : Type*} [MeasurableSpace Œ±] {Œº : Measure Œ±}
variable {ùïú : Type*} [RCLike ùïú]
variable [NormedAddCommGroup E] [InnerProductSpace ùïú E]

namespace Matrix

/-- The entries of a Gram matrix are inner products of vectors in an inner product space. -/
def Gram (ùïú : Type*) [RCLike ùïú] [NormedAddCommGroup E] [InnerProductSpace ùïú E]
    (v : n ‚Üí E) : Matrix n n ùïú  := fun i j ‚Ü¶ inner (v i) (v j)

local notation "‚ü™" x ", " y "‚ü´" => @inner ùïú  _ _ x y

def IsGram (M : Matrix n n ùïú) (v : n ‚Üí E) : Prop := (M = Gram ùïú v)

namespace IsGram

lemma of_Gram (v : n ‚Üí E) : IsGram (Gram ùïú v) v := by
  rfl

/-- For `M : Matrix n n ùïú` with `IsGram M v`, the entry at `i j : n` equals `‚ü™v i, v j‚ü´`. -/
lemma entry {M : Matrix n n ùïú} {v : n ‚Üí E} (hM : IsGram M v) (i j : n) : M i j = ‚ü™v i, v j‚ü´ := by
  rw [hM, Gram]

/-- A Gram matrix is Hermitian. -/
lemma IsHermitian {M : Matrix n n ùïú} {v : n ‚Üí E} (hM : IsGram M v) : M.IsHermitian := by
  refine IsHermitian.ext_iff.mpr ?_
  intro i j
  rw [hM, Gram, Gram]
  simp only [RCLike.star_def, inner_conj_symm]

/-- A Gram matrix is positive semidefinite. -/
theorem PosSemidef [Fintype n] {M : Matrix n n ùïú} {v : n ‚Üí E} (hM : IsGram M v) :
    @PosSemidef _ _ _ _ toPartialOrder _ M := by
  refine ‚ü®hM.IsHermitian, fun x ‚Ü¶ ?_‚ü©
  let y := ‚àë (i : n), x i ‚Ä¢ v i
  have h : ‚ü™y, y‚ü´ = star x ‚¨ù·µ• M *·µ• x := by
    simp [y]
    calc
      ‚ü™y, y‚ü´ = (‚àë (i : n), ‚àë (j : n), (starRingEnd ùïú) (x i) * (x j) * ‚ü™v i, v j‚ü´) := by
          simp_rw [y, sum_inner, inner_sum, inner_smul_left, inner_smul_right, mul_assoc]
        _ = (‚àë (i : n), ‚àë (j : n), (starRingEnd ùïú) (x i) * (x j) * (M i j)) := by
          simp_rw [hM.entry]
        _ = star x ‚¨ù·µ• M *·µ• x := by
          simp_rw [dotProduct, mul_assoc, ‚Üê Finset.mul_sum, mulVec, dotProduct,
            mul_comm, ‚Üê star_def]
          rfl
  rw [‚Üê h, le_iff_re_im]
  refine ‚ü®?_, ?_‚ü©
  ¬∑ simp only [map_zero]
    exact inner_self_nonneg
  ¬∑ simp only [map_zero, inner_self_im, y]

end IsGram

end Matrix

section L2

open L2 ENNReal

local notation "‚ü™" x ", " y "‚ü´" => @inner ‚Ñù _ _ x y

/-- Special case of a Gram matrix where the underlying inner product space is an L2-space. -/
noncomputable def Matrix.L2Gram (v : n ‚Üí (Œ± ‚Üí‚ÇÇ[Œº] ùïú)) :
  Matrix n n ùïú := Gram ùïú v

lemma Matrix.IsGram.of_L2Gram (v : n ‚Üí  (Œ± ‚Üí‚ÇÇ[Œº] ùïú)) : IsGram (L2Gram v) v := by
  rfl

lemma innerProduct_eq_inter (v w : (Set Œ±)) (hv‚ÇÅ : MeasurableSet v)
  (hw‚ÇÅ : MeasurableSet w) (hv‚ÇÇ : Œº v ‚â† ‚ä§) (hw‚ÇÇ : Œº w ‚â† ‚ä§) :
  ‚ü™((indicatorConstLp 2 hv‚ÇÅ hv‚ÇÇ (1 : ‚Ñù))), (indicatorConstLp 2 hw‚ÇÅ hw‚ÇÇ (1 : ‚Ñù)) ‚ü´ =
    (Œº (v ‚à© w)).toReal := by
  rw [inner_indicatorConstLp_one]
  have h : ((indicatorConstLp 2 hw‚ÇÅ hw‚ÇÇ (1 : ‚Ñù)) : Œ± ‚Üí ‚Ñù) =·∂†[ae Œº] w.indicator fun x ‚Ü¶ (1 : ‚Ñù) :=
    indicatorConstLp_coeFn (hs := hw‚ÇÅ) (hŒºs := hw‚ÇÇ)
  have g : ‚àÄ·µê (x : Œ±) ‚àÇŒº, x ‚àà v ‚Üí ((indicatorConstLp 2 hw‚ÇÅ hw‚ÇÇ (1 : ‚Ñù)) : Œ± ‚Üí ‚Ñù) x =
      w.indicator (fun x ‚Ü¶ (1 : ‚Ñù)) x := Filter.Eventually.mono h fun x a a_1 ‚Ü¶ a
  rw [setIntegral_congr_ae hv‚ÇÅ g, setIntegral_indicator hw‚ÇÅ]
  simp

/-- A matrix with entry `Œº (v i ‚à© v j)` at index `i j : n`. -/
def interMatrix (Œº : Measure Œ±) (v : n ‚Üí (Set Œ±)) : Matrix n n ‚Ñù := fun i j ‚Ü¶ (Œº (v i ‚à© v j)).toReal

theorem posSemidef_interMatrix [Fintype n] (Œº : Measure Œ±) (v : n ‚Üí (Set Œ±))
    (hv‚ÇÅ : ‚àÄ j, MeasurableSet (v j)) (hv‚ÇÇ : ‚àÄ j, Œº (v j) ‚â† ‚ä§) :
      PosSemidef (interMatrix Œº v) := by
  let M : Matrix n n ‚Ñù := Matrix.L2Gram fun i ‚Ü¶ (indicatorConstLp 2 (hv‚ÇÅ i) (hv‚ÇÇ i) (1 : ‚Ñù))
  obtain hg := Matrix.IsGram.of_L2Gram fun i ‚Ü¶ (indicatorConstLp 2 (hv‚ÇÅ i) (hv‚ÇÇ i) (1 : ‚Ñù))
  have hf : (fun i j ‚Ü¶ (Œº (v i ‚à© v j)).toReal) =
    (fun i j ‚Ü¶ ‚ü™(indicatorConstLp 2 (hv‚ÇÅ i) (hv‚ÇÇ i) (1 : ‚Ñù)),
    (indicatorConstLp 2 (hv‚ÇÅ j) (hv‚ÇÇ j) (1 : ‚Ñù))‚ü´) := by
    ext i j
    exact Eq.symm (innerProduct_eq_inter (v i) (v j) (hv‚ÇÅ i) (hv‚ÇÅ j) (hv‚ÇÇ i) (hv‚ÇÇ j))
  change PosSemidef fun i j ‚Ü¶ (Œº (v i ‚à© v j)).toReal
  rw [hf]
  exact IsGram.PosSemidef hg

end L2







section covariance

variable {E n : Type*}
variable {Œ± : Type*} [MeasurableSpace Œ±] {Œº : Measure Œ±}
variable [NormedAddCommGroup E] [InnerProductSpace ‚Ñù E]

open MeasureTheory L2 NNReal ENNReal
/-- This is the covariance matrix of Brownian Motion. -/
def covMatrix (t : n ‚Üí ‚Ñù‚â•0) : Matrix n n ‚Ñù := fun i j ‚Ü¶ ((t i) ‚äì (t j)).toReal

theorem posSemidef_covMatrix [Fintype n] (t : n ‚Üí ‚Ñù‚â•0) :
    PosSemidef (covMatrix t) := by
  let v : n ‚Üí (Set ‚Ñù) := fun i ‚Ü¶ Set.Icc 0 (t i)
  have h : covMatrix t = interMatrix volume (fun i ‚Ü¶ Set.Icc 0 (t i).toReal) := by
    ext i j
    rw [covMatrix, interMatrix, Set.Icc_inter_Icc]
    simp
  apply h ‚ñ∏ posSemidef_interMatrix _ v  (fun j ‚Ü¶ measurableSet_Icc)
    (fun j ‚Ü¶ IsCompact.measure_ne_top isCompact_Icc)

end covariance






variable {M : Type*} [MulZeroClass M]

omit [MeasurableSpace Œ±] in
lemma Set.indicator_mul_eq_inter (s t : Set Œ±) (f g : Œ± ‚Üí M) (x : Œ±) :
  (Set.indicator s f x) * (Set.indicator t g x) =
    Set.indicator (s ‚à© t) (f * g) x := by
  by_cases h : x ‚àà s ‚à© t
  ¬∑ rw [Set.indicator_of_mem h (f * g), Set.indicator_of_mem (mem_of_mem_inter_left h) f,
      Set.indicator_of_mem (mem_of_mem_inter_right h) g]
    simp only [Pi.mul_apply]
  ¬∑ have g : x ‚àâ s ‚à® x ‚àâ t := Classical.not_and_iff_not_or_not.mp h
    rcases g with (g1 | g2)
    ¬∑ rw [Set.indicator_of_not_mem g1 f, Set.indicator_of_not_mem h (f * g), MulZeroClass.zero_mul]
    ¬∑ rw [Set.indicator_of_not_mem g2 g, Set.indicator_of_not_mem h (f * g), mul_zero]
