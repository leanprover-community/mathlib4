/-
Copyright (c) 2020 Simon Hudon. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Simon Hudon
-/
import Mathlib.Data.List.Sigma
import Mathlib.Data.Int.Range
import Mathlib.Data.Finsupp.Defs
import Mathlib.Data.Finsupp.ToDFinsupp
import Mathlib.Data.LazyList
import Mathlib.Testing.SlimCheck.Sampleable
import Mathlib.Testing.SlimCheck.Testable

#align_import testing.slim_check.functions from "leanprover-community/mathlib"@"f9c300047a57aeda7c2fe15a3ac2455eb05ec225"

/-!
## `slim_check`: generators for functions

This file defines `Sampleable` instances for `Œ± ‚Üí Œ≤` functions and
`‚Ñ§ ‚Üí ‚Ñ§` injective functions.

Functions are generated by creating a list of pairs and one more value
using the list as a lookup table and resorting to the additional value
when a value is not found in the table.

Injective functions are generated by creating a list of numbers and
a permutation of that list. The permutation insures that every input
is mapped to a unique output. When an input is not found in the list
the input itself is used as an output.

Injective functions `f : Œ± ‚Üí Œ±` could be generated easily instead of
`‚Ñ§ ‚Üí ‚Ñ§` by generating a `List Œ±`, removing duplicates and creating a
permutation. One has to be careful when generating the domain to make
it vast enough that, when generating arguments to apply `f` to,
they argument should be likely to lie in the domain of `f`. This is
the reason that injective functions `f : ‚Ñ§ ‚Üí ‚Ñ§` are generated by
fixing the domain to the range `[-2*size .. -2*size]`, with `size`
the size parameter of the `gen` monad.

Much of the machinery provided in this file is applicable to generate
injective functions of type `Œ± ‚Üí Œ±` and new instances should be easy
to define.

Other classes of functions such as monotone functions can generated using
similar techniques. For monotone functions, generating two lists, sorting them
and matching them should suffice, with appropriate default values.
Some care must be taken for shrinking such functions to make sure
their defining property is invariant through shrinking. Injective
functions are an example of how complicated it can get.
-/


universe u v w

variable {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Sort w}

namespace SlimCheck

/-- Data structure specifying a total function using a list of pairs
and a default value returned when the input is not in the domain of
the partial function.

`with_default f y` encodes `x ‚Ü¶ f x` when `x ‚àà f` and `x ‚Ü¶ y`
otherwise.

We use `Œ£` to encode mappings instead of `√ó` because we
rely on the association list API defined in `data.list.sigma`.
 -/
inductive TotalFunction (Œ± : Type u) (Œ≤ : Type v) : Type max u v
  | withDefault : List (Œ£ _ : Œ±, Œ≤) ‚Üí Œ≤ ‚Üí TotalFunction Œ± Œ≤
#align slim_check.total_function SlimCheck.TotalFunction
#align slim_check.total_function.with_default SlimCheck.TotalFunction.withDefault

instance TotalFunction.inhabited [Inhabited Œ≤] : Inhabited (TotalFunction Œ± Œ≤) :=
  ‚ü®TotalFunction.withDefault ‚àÖ default‚ü©
#align slim_check.total_function.inhabited SlimCheck.TotalFunction.inhabited

namespace TotalFunction

-- porting note: new
/-- Compose a total function with a regular function on the left -/
def comp {Œ≥ : Type w} (f : Œ≤ ‚Üí Œ≥) : TotalFunction Œ± Œ≤ ‚Üí TotalFunction Œ± Œ≥
  | TotalFunction.withDefault m y => TotalFunction.withDefault
    (m.map <| Sigma.map id <| fun _ => f) (f y)

/-- Apply a total function to an argument. -/
def apply [DecidableEq Œ±] : TotalFunction Œ± Œ≤ ‚Üí Œ± ‚Üí Œ≤
  | TotalFunction.withDefault m y, x => (m.dlookup x).getD y
#align slim_check.total_function.apply SlimCheck.TotalFunction.apply

/-- Implementation of `has_repr (total_function Œ± Œ≤)`.

Creates a string for a given `finmap` and output, `x‚ÇÄ ‚Ü¶ y‚ÇÄ, .. x‚Çô ‚Ü¶ y‚Çô`
for each of the entries. The brackets are provided by the calling function.
-/
def reprAux [Repr Œ±] [Repr Œ≤] (m : List (Œ£ _ : Œ±, Œ≤)) : String :=
  String.join <|
    -- Porting note: No `List.qsort`, so convert back and forth to an `Array`.
    Array.toList <| Array.qsort (lt := fun x y => x < y)
      (m.map fun x => s!"{(repr <| Sigma.fst x)} ‚Ü¶ {repr <| Sigma.snd x}, ").toArray
#align slim_check.total_function.repr_aux SlimCheck.TotalFunction.reprAux

/-- Produce a string for a given `TotalFunction`.
The output is of the form `[x‚ÇÄ ‚Ü¶ f x‚ÇÄ, .. x‚Çô ‚Ü¶ f x‚Çô, _ ‚Ü¶ y]`.
-/
protected def repr [Repr Œ±] [Repr Œ≤] : TotalFunction Œ± Œ≤ ‚Üí String
  | TotalFunction.withDefault m y => s!"[{(reprAux m)}_ ‚Ü¶ {repr y}]"
#align slim_check.total_function.repr SlimCheck.TotalFunction.repr

instance (Œ± : Type u) (Œ≤ : Type v) [Repr Œ±] [Repr Œ≤] : Repr (TotalFunction Œ± Œ≤) where
  reprPrec f _ := TotalFunction.repr f

/-- Create a `finmap` from a list of pairs. -/
def List.toFinmap' (xs : List (Œ± √ó Œ≤)) : List (Œ£ _ : Œ±, Œ≤) :=
  xs.map Prod.toSigma
#align slim_check.total_function.list.to_finmap' SlimCheck.TotalFunction.List.toFinmap'

section

universe ua ub
variable [SampleableExt.{_,u} Œ±] [SampleableExt.{_,ub} Œ≤]

-- porting note: removed, there is no `sizeof` in the new `Sampleable`

-- /-- Redefine `sizeof` to follow the structure of `sampleable` instances. -/
-- def Total.sizeof : TotalFunction Œ± Œ≤ ‚Üí ‚Ñï
--   | ‚ü®m, x‚ü© => 1 + @SizeOf.sizeOf _ Sampleable.wf m + SizeOf.sizeOf x
#noalign slim_check.total_function.total.sizeof

-- instance (priority := 2000) : SizeOf (TotalFunction Œ± Œ≤) :=
--   ‚ü®Total.sizeof‚ü©
#noalign slim_check.total_function.has_sizeof

variable [DecidableEq Œ±]

/-- Shrink a total function by shrinking the lists that represent it. -/
def shrink {Œ± Œ≤} [DecidableEq Œ±] [Shrinkable Œ±] [Shrinkable Œ≤] :
    TotalFunction Œ± Œ≤ ‚Üí List (TotalFunction Œ± Œ≤)
  | ‚ü®m, x‚ü© => (Shrinkable.shrink (m, x)).map fun ‚ü®m', x'‚ü© => ‚ü®List.dedupKeys m', x'‚ü©
#align slim_check.total_function.shrink SlimCheck.TotalFunction.shrink

variable [Repr Œ±]

instance Pi.sampleableExt : SampleableExt (Œ± ‚Üí Œ≤) where
  proxy := TotalFunction Œ± (SampleableExt.proxy Œ≤)
  interp f := SampleableExt.interp ‚àò f.apply
  sample := do
    let xs : List (_ √ó _) ‚Üê (SampleableExt.sample (Œ± := List (Œ± √ó Œ≤)))
    let ‚ü®x‚ü© ‚Üê (ULiftable.up <|
      SampleableExt.sample : Gen (ULift.{max u ub} (SampleableExt.proxy Œ≤)))
    pure <| TotalFunction.withDefault (List.toFinmap' <| xs.map <|
      Prod.map SampleableExt.interp id) x
  -- note: no way of shrinking the domain without an inverse to `interp`
  shrink := { shrink := letI : Shrinkable Œ± := {}; TotalFunction.shrink }
#align slim_check.total_function.pi.sampleable_ext SlimCheck.TotalFunction.Pi.sampleableExt

end

section Finsupp

variable [Zero Œ≤]

/-- Map a total_function to one whose default value is zero so that it represents a finsupp. -/
@[simp]
def zeroDefault : TotalFunction Œ± Œ≤ ‚Üí TotalFunction Œ± Œ≤
  | withDefault A _ => withDefault A 0
#align slim_check.total_function.zero_default SlimCheck.TotalFunction.zeroDefault

variable [DecidableEq Œ±] [DecidableEq Œ≤]

/-- The support of a zero default `total_function`. -/
@[simp]
def zeroDefaultSupp : TotalFunction Œ± Œ≤ ‚Üí Finset Œ±
  | withDefault A _ =>
    List.toFinset <| (A.dedupKeys.filter fun ab => Sigma.snd ab ‚â† 0).map Sigma.fst
#align slim_check.total_function.zero_default_supp SlimCheck.TotalFunction.zeroDefaultSupp

/-- Create a finitely supported function from a total function by taking the default value to
zero. -/
def applyFinsupp (tf : TotalFunction Œ± Œ≤) : Œ± ‚Üí‚ÇÄ Œ≤ where
  support := zeroDefaultSupp tf
  toFun := tf.zeroDefault.apply
  mem_support_toFun := by
    intro a
    -- ‚ä¢ a ‚àà zeroDefaultSupp tf ‚Üî apply (zeroDefault tf) a ‚â† 0
    rcases tf with ‚ü®A, y‚ü©
    -- ‚ä¢ a ‚àà zeroDefaultSupp (withDefault A y) ‚Üî apply (zeroDefault (withDefault A y) ‚Ä¶
    simp only [apply, zeroDefaultSupp, List.mem_map, List.mem_filter, exists_and_right,
      List.mem_toFinset, exists_eq_right, Sigma.exists, Ne.def, zeroDefault]
    constructor
    -- ‚ä¢ (‚àÉ x, { fst := a, snd := x } ‚àà List.dedupKeys A ‚àß (decide ¬¨x = 0) = true) ‚Üí  ‚Ä¶
    ¬∑ rintro ‚ü®od, hval, hod‚ü©
      -- ‚ä¢ ¬¨Option.getD (List.dlookup a A) 0 = 0
      have := List.mem_dlookup (List.nodupKeys_dedupKeys A) hval
      -- ‚ä¢ ¬¨Option.getD (List.dlookup a A) 0 = 0
      rw [(_ : List.dlookup a A = od)]
      -- ‚ä¢ ¬¨Option.getD (some od) 0 = 0
      ¬∑ simpa using hod
        -- üéâ no goals
      ¬∑ simpa [List.dlookup_dedupKeys, WithTop.some_eq_coe]
        -- üéâ no goals
    ¬∑ intro h
      -- ‚ä¢ ‚àÉ x, { fst := a, snd := x } ‚àà List.dedupKeys A ‚àß (decide ¬¨x = 0) = true
      use (A.dlookup a).getD (0 : Œ≤)
      -- ‚ä¢ { fst := a, snd := Option.getD (List.dlookup a A) 0 } ‚àà List.dedupKeys A ‚àß ( ‚Ä¶
      rw [‚Üê List.dlookup_dedupKeys] at h ‚ä¢
      -- ‚ä¢ { fst := a, snd := Option.getD (List.dlookup a (List.dedupKeys A)) 0 } ‚àà Lis ‚Ä¶
      simp only [h, ‚Üê List.mem_dlookup_iff A.nodupKeys_dedupKeys, and_true_iff, not_false_iff,
        Option.mem_def]
      cases haA : List.dlookup a A.dedupKeys
      -- ‚ä¢ none = some (Option.getD none 0)
      ¬∑ simp [haA] at h
        -- üéâ no goals
      ¬∑ simp
        -- üéâ no goals
#align slim_check.total_function.apply_finsupp SlimCheck.TotalFunction.applyFinsupp

variable [SampleableExt Œ±] [SampleableExt Œ≤] [Repr Œ±]

instance Finsupp.sampleableExt : SampleableExt (Œ± ‚Üí‚ÇÄ Œ≤) where
  proxy := TotalFunction Œ± (SampleableExt.proxy Œ≤)
  interp := fun f => (f.comp SampleableExt.interp).applyFinsupp
  sample := SampleableExt.sample (Œ± := Œ± ‚Üí Œ≤)
  -- note: no way of shrinking the domain without an inverse to `interp`
  shrink := { shrink := letI : Shrinkable Œ± := {}; TotalFunction.shrink }
#align slim_check.total_function.finsupp.sampleable_ext SlimCheck.TotalFunction.Finsupp.sampleableExt

-- TODO: support a non-constant codomain type
instance DFinsupp.sampleableExt : SampleableExt (Œ†‚ÇÄ _ : Œ±, Œ≤) where
  proxy := TotalFunction Œ± (SampleableExt.proxy Œ≤)
  interp := fun f => (f.comp SampleableExt.interp).applyFinsupp.toDFinsupp
  sample := SampleableExt.sample (Œ± := Œ± ‚Üí Œ≤)
  -- note: no way of shrinking the domain without an inverse to `interp`
  shrink := { shrink := letI : Shrinkable Œ± := {}; TotalFunction.shrink }
#align slim_check.total_function.dfinsupp.sampleable_ext SlimCheck.TotalFunction.DFinsupp.sampleableExt

end Finsupp

section SampleableExt

open SampleableExt

instance (priority := 2000) PiPred.sampleableExt [SampleableExt (Œ± ‚Üí Bool)] :
    SampleableExt.{u + 1} (Œ± ‚Üí Prop) where
  proxy := proxy (Œ± ‚Üí Bool)
  interp m x := interp m x
  sample := sample
  shrink := SampleableExt.shrink
#align slim_check.total_function.pi_pred.sampleable_ext SlimCheck.TotalFunction.PiPred.sampleableExt

instance (priority := 2000) PiUncurry.sampleableExt [SampleableExt (Œ± √ó Œ≤ ‚Üí Œ≥)] :
    SampleableExt.{imax (u + 1) (v + 1) w} (Œ± ‚Üí Œ≤ ‚Üí Œ≥) where
  proxy := proxy (Œ± √ó Œ≤ ‚Üí Œ≥)
  interp m x y := interp m (x, y)
  sample := sample
  shrink := SampleableExt.shrink
#align slim_check.total_function.pi_uncurry.sampleable_ext SlimCheck.TotalFunction.PiUncurry.sampleableExt

end SampleableExt

end TotalFunction

/-- Data structure specifying a total function using a list of pairs
and a default value returned when the input is not in the domain of
the partial function.

`map_to_self f` encodes `x ‚Ü¶ f x` when `x ‚àà f` and `x ‚Ü¶ x`,
i.e. `x` to itself, otherwise.

We use `Œ£` to encode mappings instead of `√ó` because we
rely on the association list API defined in `data.list.sigma`.
-/
inductive InjectiveFunction (Œ± : Type u) : Type u
  | mapToSelf (xs : List (Œ£ _ : Œ±, Œ±)) :
      xs.map Sigma.fst ~ xs.map Sigma.snd ‚Üí List.Nodup (xs.map Sigma.snd) ‚Üí InjectiveFunction Œ±
#align slim_check.injective_function SlimCheck.InjectiveFunction
#align slim_check.injective_function.map_to_self SlimCheck.InjectiveFunction.mapToSelf

instance : Inhabited (InjectiveFunction Œ±) :=
  ‚ü®‚ü®[], List.Perm.nil, List.nodup_nil‚ü©‚ü©

namespace InjectiveFunction

/-- Apply a total function to an argument. -/
def apply [DecidableEq Œ±] : InjectiveFunction Œ± ‚Üí Œ± ‚Üí Œ±
  | InjectiveFunction.mapToSelf m _ _, x => (m.dlookup x).getD x
#align slim_check.injective_function.apply SlimCheck.InjectiveFunction.apply

/-- Produce a string for a given `total_function`.
The output is of the form `[x‚ÇÄ ‚Ü¶ f x‚ÇÄ, .. x‚Çô ‚Ü¶ f x‚Çô, x ‚Ü¶ x]`.
Unlike for `total_function`, the default value is not a constant
but the identity function.
-/
protected def repr [Repr Œ±] : InjectiveFunction Œ± ‚Üí String
  | InjectiveFunction.mapToSelf m _ _ => s! "[{TotalFunction.reprAux m}x ‚Ü¶ x]"
#align slim_check.injective_function.repr SlimCheck.InjectiveFunction.repr

instance (Œ± : Type u) [Repr Œ±] : Repr (InjectiveFunction Œ±) where
  reprPrec f _p := InjectiveFunction.repr f

/-- Interpret a list of pairs as a total function, defaulting to
the identity function when no entries are found for a given function -/
def List.applyId [DecidableEq Œ±] (xs : List (Œ± √ó Œ±)) (x : Œ±) : Œ± :=
  ((xs.map Prod.toSigma).dlookup x).getD x
#align slim_check.injective_function.list.apply_id SlimCheck.InjectiveFunction.List.applyId

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
@[simp]
theorem List.applyId_cons [DecidableEq Œ±] (xs : List (Œ± √ó Œ±)) (x y z : Œ±) :
    List.applyId ((y, z)::xs) x = if y = x then z else List.applyId xs x := by
  simp only [List.applyId, List.dlookup, eq_rec_constant, Prod.toSigma, List.map]
  -- ‚ä¢ Option.getD (if h : y = x then some z else List.dlookup x (List.map (fun p = ‚Ä¶
  split_ifs <;> rfl
  -- ‚ä¢ Option.getD (some z) x = z
                -- üéâ no goals
                -- üéâ no goals
#align slim_check.injective_function.list.apply_id_cons SlimCheck.InjectiveFunction.List.applyId_cons

open Function
open List

open Nat

theorem List.applyId_zip_eq [DecidableEq Œ±] {xs ys : List Œ±} (h‚ÇÄ : List.Nodup xs)
    (h‚ÇÅ : xs.length = ys.length) (x y : Œ±) (i : ‚Ñï) (h‚ÇÇ : xs.get? i = some x) :
    List.applyId.{u} (xs.zip ys) x = y ‚Üî ys.get? i = some y := by
  induction xs generalizing ys i
  -- ‚ä¢ applyId (List.zip [] ys) x = y ‚Üî List.get? ys i = some y
  case nil => cases h‚ÇÇ
  -- ‚ä¢ applyId (List.zip (head‚úù :: tail‚úù) ys) x = y ‚Üî List.get? ys i = some y
  -- üéâ no goals
  case cons x' xs xs_ih =>
    cases i
    ¬∑ injection h‚ÇÇ with h‚ÇÄ; subst h‚ÇÄ
      cases ys
      ¬∑ cases h‚ÇÅ
      ¬∑ -- porting note: `open List` no longer makes `zip_cons_cons` visible
        simp only [List.applyId, Prod.toSigma, Option.getD_some, List.get?, List.dlookup_cons_eq,
          List.zip_cons_cons, List.map, Option.some_inj]
    ¬∑ cases ys
      ¬∑ cases h‚ÇÅ
      ¬∑ cases' h‚ÇÄ with _ _ h‚ÇÄ h‚ÇÅ
        -- porting note: `open List` no longer makes `zip_cons_cons` visible
        simp only [List.get?, List.zip_cons_cons, List.applyId_cons] at h‚ÇÇ ‚ä¢
        rw [if_neg]
        ¬∑ apply xs_ih <;> solve_by_elim [Nat.succ.inj]
        ¬∑ apply h‚ÇÄ; apply List.get?_mem h‚ÇÇ
#align slim_check.injective_function.list.apply_id_zip_eq SlimCheck.InjectiveFunction.List.applyId_zip_eq

theorem applyId_mem_iff [DecidableEq Œ±] {xs ys : List Œ±} (h‚ÇÄ : List.Nodup xs) (h‚ÇÅ : xs ~ ys)
    (x : Œ±) : List.applyId.{u} (xs.zip ys) x ‚àà ys ‚Üî x ‚àà xs := by
  simp only [List.applyId]
  -- ‚ä¢ Option.getD (List.dlookup x (List.map Prod.toSigma (List.zip xs ys))) x ‚àà ys ‚Ä¶
  cases h‚ÇÉ : List.dlookup x (List.map Prod.toSigma (xs.zip ys)) with
  | none =>
    dsimp [Option.getD]
    rw [h‚ÇÅ.mem_iff]
  | some val =>
    have h‚ÇÇ : ys.Nodup := h‚ÇÅ.nodup_iff.1 h‚ÇÄ
    replace h‚ÇÅ : xs.length = ys.length := h‚ÇÅ.length_eq
    dsimp
    induction xs generalizing ys with
    | nil => contradiction
    | cons x' xs xs_ih =>
      cases' ys with y ys
      ¬∑ cases h‚ÇÉ
      dsimp [List.dlookup] at h‚ÇÉ; split_ifs at h‚ÇÉ with h
      ¬∑ rw [Option.some_inj] at h‚ÇÉ
        subst x'; subst val
        simp only [List.mem_cons, true_or_iff, eq_self_iff_true]
      ¬∑ cases' h‚ÇÄ with _ _ h‚ÇÄ h‚ÇÖ
        cases' h‚ÇÇ with _ _ h‚ÇÇ h‚ÇÑ
        have h‚ÇÜ := Nat.succ.inj h‚ÇÅ
        specialize xs_ih h‚ÇÖ h‚ÇÉ h‚ÇÑ h‚ÇÜ
        simp only [Ne.symm h, xs_ih, List.mem_cons, false_or_iff]
        suffices : val ‚àà ys; tauto
        erw [‚Üê Option.mem_def, List.mem_dlookup_iff] at h‚ÇÉ
        simp only [Prod.toSigma, List.mem_map, heq_iff_eq, Prod.exists] at h‚ÇÉ
        rcases h‚ÇÉ with ‚ü®a, b, h‚ÇÉ, h‚ÇÑ, h‚ÇÖ‚ü©
        apply (List.mem_zip h‚ÇÉ).2
        simp only [List.NodupKeys, List.keys, comp, Prod.fst_toSigma, List.map_map]
        rwa [List.map_fst_zip _ _ (le_of_eq h‚ÇÜ)]
#align slim_check.injective_function.apply_id_mem_iff SlimCheck.InjectiveFunction.applyId_mem_iff

theorem List.applyId_eq_self [DecidableEq Œ±] {xs ys : List Œ±} (x : Œ±) :
    x ‚àâ xs ‚Üí List.applyId.{u} (xs.zip ys) x = x := by
  intro h
  -- ‚ä¢ applyId (List.zip xs ys) x = x
  dsimp [List.applyId]
  -- ‚ä¢ Option.getD (List.dlookup x (List.map Prod.toSigma (List.zip xs ys))) x = x
  rw [List.dlookup_eq_none.2]; rfl
  -- ‚ä¢ Option.getD none x = x
                               -- ‚ä¢ ¬¨x ‚àà List.keys (List.map Prod.toSigma (List.zip xs ys))
  simp only [List.keys, not_exists, Prod.toSigma, exists_and_right, exists_eq_right, List.mem_map,
    Function.comp_apply, List.map_map, Prod.exists]
  intro y hy
  -- ‚ä¢ False
  exact h (List.mem_zip hy).1
  -- üéâ no goals
#align slim_check.injective_function.list.apply_id_eq_self SlimCheck.InjectiveFunction.List.applyId_eq_self

theorem applyId_injective [DecidableEq Œ±] {xs ys : List Œ±} (h‚ÇÄ : List.Nodup xs) (h‚ÇÅ : xs ~ ys) :
    Injective.{u + 1, u + 1} (List.applyId (xs.zip ys)) := by
  intro x y h
  -- ‚ä¢ x = y
  by_cases hx : x ‚àà xs <;> by_cases hy : y ‚àà xs
  -- ‚ä¢ x = y
                           -- ‚ä¢ x = y
                           -- ‚ä¢ x = y
  ¬∑ rw [List.mem_iff_get?] at hx hy
    -- ‚ä¢ x = y
    cases' hx with i hx
    -- ‚ä¢ x = y
    cases' hy with j hy
    -- ‚ä¢ x = y
    suffices some x = some y by injection this
    -- ‚ä¢ some x = some y
    have h‚ÇÇ := h‚ÇÅ.length_eq
    -- ‚ä¢ some x = some y
    rw [List.applyId_zip_eq h‚ÇÄ h‚ÇÇ _ _ _ hx] at h
    -- ‚ä¢ some x = some y
    rw [‚Üê hx, ‚Üê hy]; congr
    -- ‚ä¢ List.get? xs i = List.get? xs j
                     -- ‚ä¢ i = j
    apply List.get?_injective _ (h‚ÇÅ.nodup_iff.1 h‚ÇÄ)
    -- ‚ä¢ List.get? ys i = List.get? ys j
    ¬∑ symm; rw [h]
      -- ‚ä¢ List.get? ys j = List.get? ys i
            -- ‚ä¢ List.get? ys j = some (applyId (List.zip xs ys) y)
      rw [‚Üê List.applyId_zip_eq] <;> assumption
                                     -- üéâ no goals
                                     -- üéâ no goals
                                     -- üéâ no goals
    ¬∑ rw [‚Üê h‚ÇÅ.length_eq]
      -- ‚ä¢ i < List.length xs
      rw [List.get?_eq_some] at hx
      -- ‚ä¢ i < List.length xs
      cases' hx with hx hx'
      -- ‚ä¢ i < List.length xs
      exact hx
      -- üéâ no goals
  ¬∑ rw [‚Üê applyId_mem_iff h‚ÇÄ h‚ÇÅ] at hx hy
    -- ‚ä¢ x = y
    rw [h] at hx
    -- ‚ä¢ x = y
    contradiction
    -- üéâ no goals
  ¬∑ rw [‚Üê applyId_mem_iff h‚ÇÄ h‚ÇÅ] at hx hy
    -- ‚ä¢ x = y
    rw [h] at hx
    -- ‚ä¢ x = y
    contradiction
    -- üéâ no goals
  ¬∑ rwa [List.applyId_eq_self, List.applyId_eq_self] at h <;> assumption
    -- ‚ä¢ ¬¨y ‚àà xs
                                                              -- üéâ no goals
                                                              -- üéâ no goals
#align slim_check.injective_function.apply_id_injective SlimCheck.InjectiveFunction.applyId_injective

open TotalFunction (List.toFinmap')

open SampleableExt

/-- Remove a slice of length `m` at index `n` in a list and a permutation, maintaining the property
that it is a permutation.
-/
def Perm.slice [DecidableEq Œ±] (n m : ‚Ñï) :
    (Œ£' xs ys : List Œ±, xs ~ ys ‚àß ys.Nodup) ‚Üí Œ£' xs ys : List Œ±, xs ~ ys ‚àß ys.Nodup
  | ‚ü®xs, ys, h, h'‚ü© =>
    let xs' := List.dropSlice n m xs
    have h‚ÇÄ : xs' ~ ys.inter xs' := List.Perm.dropSlice_inter _ _ h h'
    ‚ü®xs', ys.inter xs', h‚ÇÄ, h'.inter _‚ü©
#align slim_check.injective_function.perm.slice SlimCheck.InjectiveFunction.Perm.slice

/-- A lazy list, in decreasing order, of sizes that should be
sliced off a list of length `n`
-/
def sliceSizes : ‚Ñï ‚Üí LazyList ‚Ñï+
  | n =>
    if h : 0 < n then
      have : n / 2 < n := Nat.div_lt_self h (by decide : 1 < 2)
                                                -- üéâ no goals
      LazyList.cons ‚ü®_, h‚ü© (sliceSizes <| n / 2)
    else LazyList.nil
#align slim_check.injective_function.slice_sizes SlimCheck.InjectiveFunction.sliceSizes

/-- Shrink a permutation of a list, slicing a segment in the middle.

The sizes of the slice being removed start at `n` (with `n` the length
of the list) and then `n / 2`, then `n / 4`, etc down to 1. The slices
will be taken at index `0`, `n / k`, `2n / k`, `3n / k`, etc.
-/
protected def shrinkPerm {Œ± : Type} [DecidableEq Œ±] :
    (Œ£' xs ys : List Œ±, xs ~ ys ‚àß ys.Nodup) ‚Üí List (Œ£' xs ys : List Œ±, xs ~ ys ‚àß ys.Nodup)
  | xs => do
    let k := xs.1.length
    let n ‚Üê (sliceSizes k).toList
    let i ‚Üê List.finRange <| k / n
    pure <| Perm.slice (i * n) n xs
#align slim_check.injective_function.shrink_perm SlimCheck.InjectiveFunction.shrinkPerm


-- porting note: removed, there is no `sizeof` in the new `Sampleable`
-- instance [SizeOf Œ±] : SizeOf (InjectiveFunction Œ±) :=
--   ‚ü®fun ‚ü®xs, _, _‚ü© => SizeOf.sizeOf (xs.map Sigma.fst)‚ü©
#noalign slim_check.injective_function.has_sizeof

/-- Shrink an injective function slicing a segment in the middle of the domain and removing
the corresponding elements in the codomain, hence maintaining the property that
one is a permutation of the other.
-/
protected def shrink {Œ± : Type} [DecidableEq Œ±] :
    InjectiveFunction Œ± ‚Üí List (InjectiveFunction Œ±)
  | ‚ü®xs, h‚ÇÄ, h‚ÇÅ‚ü© => do
    let ‚ü®xs', ys', h‚ÇÄ, h‚ÇÅ‚ü© ‚Üê InjectiveFunction.shrinkPerm ‚ü®_, _, h‚ÇÄ, h‚ÇÅ‚ü©
    have h‚ÇÉ : xs'.length ‚â§ ys'.length := le_of_eq (List.Perm.length_eq h‚ÇÄ)
    have h‚ÇÑ : ys'.length ‚â§ xs'.length := le_of_eq (List.Perm.length_eq h‚ÇÄ.symm)
    pure
      ‚ü®(List.zip xs' ys').map Prod.toSigma,
        by simp only [comp, List.map_fst_zip, List.map_snd_zip, *, Prod.fst_toSigma,
          Prod.snd_toSigma, List.map_map],
        by simp only [comp, List.map_snd_zip, *, Prod.snd_toSigma, List.map_map]‚ü©
           -- üéâ no goals
#align slim_check.injective_function.shrink SlimCheck.InjectiveFunction.shrink

/-- Create an injective function from one list and a permutation of that list. -/
protected def mk (xs ys : List Œ±) (h : xs ~ ys) (h' : ys.Nodup) : InjectiveFunction Œ± :=
  have h‚ÇÄ : xs.length ‚â§ ys.length := le_of_eq h.length_eq
  have h‚ÇÅ : ys.length ‚â§ xs.length := le_of_eq h.length_eq.symm
  InjectiveFunction.mapToSelf (List.toFinmap' (xs.zip ys))
    (by
      simp only [List.toFinmap', comp, List.map_fst_zip, List.map_snd_zip, *, Prod.fst_toSigma,
        Prod.snd_toSigma, List.map_map])
    (by simp only [List.toFinmap', comp, List.map_snd_zip, *, Prod.snd_toSigma, List.map_map])
        -- üéâ no goals
#align slim_check.injective_function.mk SlimCheck.InjectiveFunction.mk

protected theorem injective [DecidableEq Œ±] (f : InjectiveFunction Œ±) : Injective (apply f) := by
  cases' f with xs hperm hnodup
  -- ‚ä¢ Injective (apply (mapToSelf xs hperm hnodup))
  generalize h‚ÇÄ : List.map Sigma.fst xs = xs‚ÇÄ
  -- ‚ä¢ Injective (apply (mapToSelf xs hperm hnodup))
  generalize h‚ÇÅ : xs.map (@id ((Œ£ _ : Œ±, Œ±) ‚Üí Œ±) <| @Sigma.snd Œ± fun _ : Œ± => Œ±) = xs‚ÇÅ
  -- ‚ä¢ Injective (apply (mapToSelf xs hperm hnodup))
  dsimp [id] at h‚ÇÅ
  -- ‚ä¢ Injective (apply (mapToSelf xs hperm hnodup))
  have hxs : xs = TotalFunction.List.toFinmap' (xs‚ÇÄ.zip xs‚ÇÅ) := by
    rw [‚Üê h‚ÇÄ, ‚Üê h‚ÇÅ, List.toFinmap']; clear h‚ÇÄ h‚ÇÅ xs‚ÇÄ xs‚ÇÅ hperm hnodup
    induction xs
    case nil => simp only [List.zip_nil_right, List.map_nil]
    case cons xs_hd xs_tl
      xs_ih =>
      simp only [true_and_iff, Prod.toSigma, eq_self_iff_true, Sigma.eta, List.zip_cons_cons,
        List.map, List.cons_inj]
      exact xs_ih
  revert hperm hnodup
  -- ‚ä¢ ‚àÄ (hperm : List.map Sigma.fst xs ~ List.map Sigma.snd xs) (hnodup : List.Nod ‚Ä¶
  rw [hxs]; intros hperm hnodup
  -- ‚ä¢ ‚àÄ (hperm : List.map Sigma.fst (List.toFinmap' (List.zip xs‚ÇÄ xs‚ÇÅ)) ~ List.map ‚Ä¶
            -- ‚ä¢ Injective (apply (mapToSelf (List.toFinmap' (List.zip xs‚ÇÄ xs‚ÇÅ)) hperm hnodup))
  apply InjectiveFunction.applyId_injective
  -- ‚ä¢ List.Nodup xs‚ÇÄ
  ¬∑ rwa [‚Üê h‚ÇÄ, hxs, hperm.nodup_iff]
    -- üéâ no goals
  ¬∑ rwa [‚Üê hxs, h‚ÇÄ, h‚ÇÅ] at hperm
    -- üéâ no goals
#align slim_check.injective_function.injective SlimCheck.InjectiveFunction.injective

instance PiInjective.sampleableExt : SampleableExt { f : ‚Ñ§ ‚Üí ‚Ñ§ // Function.Injective f } where
  proxy := InjectiveFunction ‚Ñ§
  interp f := ‚ü®apply f, f.injective‚ü©
  sample := do
    let ‚ü®sz‚ü© ‚Üê ULiftable.up Gen.getSize
    let xs' := Int.range (-(2 * sz + 2)) (2 * sz + 2)
    let ys ‚Üê Gen.permutationOf xs'
    have Hinj : Injective fun r : ‚Ñï => -(2 * sz + 2 : ‚Ñ§) + ‚Üër := fun _x _y h =>
        Int.ofNat.inj (add_right_injective _ h)
    let r : InjectiveFunction ‚Ñ§ :=
      InjectiveFunction.mk.{0} xs' ys.1 ys.2 (ys.2.nodup_iff.1 <| (List.nodup_range _).map Hinj)
    pure r
  shrink := {shrink := @InjectiveFunction.shrink ‚Ñ§ _ }
#align slim_check.injective_function.pi_injective.sampleable_ext SlimCheck.InjectiveFunction.PiInjective.sampleableExt

end InjectiveFunction

open Function

instance Injective.testable (f : Œ± ‚Üí Œ≤)
    [I : Testable (NamedBinder "x" <|
      ‚àÄ x : Œ±, NamedBinder "y" <| ‚àÄ y : Œ±, NamedBinder "H" <| f x = f y ‚Üí x = y)] :
    Testable (Injective f) :=
  I
#align slim_check.injective.testable SlimCheck.Injective.testable

instance Monotone.testable [Preorder Œ±] [Preorder Œ≤] (f : Œ± ‚Üí Œ≤)
    [I : Testable (NamedBinder "x" <|
      ‚àÄ x : Œ±, NamedBinder "y" <| ‚àÄ y : Œ±, NamedBinder "H" <| x ‚â§ y ‚Üí f x ‚â§ f y)] :
    Testable (Monotone f) :=
  I
#align slim_check.monotone.testable SlimCheck.Monotone.testable

instance Antitone.testable [Preorder Œ±] [Preorder Œ≤] (f : Œ± ‚Üí Œ≤)
    [I : Testable (NamedBinder "x" <|
      ‚àÄ x : Œ±, NamedBinder "y" <| ‚àÄ y : Œ±, NamedBinder "H" <| x ‚â§ y ‚Üí f y ‚â§ f x)] :
    Testable (Antitone f) :=
  I
#align slim_check.antitone.testable SlimCheck.Antitone.testable

end SlimCheck
