/-
Copyright (c) 2020 Yury G. Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury G. Kudryashov, Patrick Massot, S√©bastien Gou√´zel
-/
import Mathlib.Data.Set.Intervals.Disjoint
import Mathlib.MeasureTheory.Integral.SetIntegral
import Mathlib.MeasureTheory.Measure.Lebesgue.Basic

#align_import measure_theory.integral.interval_integral from "leanprover-community/mathlib"@"fd5edc43dc4f10b85abfe544b88f82cf13c5f844"

/-!
# Integral over an interval

In this file we define `‚à´ x in a..b, f x ‚àÇŒº` to be `‚à´ x in Ioc a b, f x ‚àÇŒº` if `a ‚â§ b` and
`-‚à´ x in Ioc b a, f x ‚àÇŒº` if `b ‚â§ a`.

## Implementation notes

### Avoiding `if`, `min`, and `max`

In order to avoid `if`s in the definition, we define `IntervalIntegrable f Œº a b` as
`integrable_on f (Ioc a b) Œº ‚àß integrable_on f (Ioc b a) Œº`. For any `a`, `b` one of these
intervals is empty and the other coincides with `Set.uIoc a b = Set.Ioc (min a b) (max a b)`.

Similarly, we define `‚à´ x in a..b, f x ‚àÇŒº` to be `‚à´ x in Ioc a b, f x ‚àÇŒº - ‚à´ x in Ioc b a, f x ‚àÇŒº`.
Again, for any `a`, `b` one of these integrals is zero, and the other gives the expected result.

This way some properties can be translated from integrals over sets without dealing with
the cases `a ‚â§ b` and `b ‚â§ a` separately.

### Choice of the interval

We use integral over `Set.uIoc a b = Set.Ioc (min a b) (max a b)` instead of one of the other
three possible intervals with the same endpoints for two reasons:

* this way `‚à´ x in a..b, f x ‚àÇŒº + ‚à´ x in b..c, f x ‚àÇŒº = ‚à´ x in a..c, f x ‚àÇŒº` holds whenever
  `f` is integrable on each interval; in particular, it works even if the measure `Œº` has an atom
  at `b`; this rules out `Set.Ioo` and `Set.Icc` intervals;
* with this definition for a probability measure `Œº`, the integral `‚à´ x in a..b, 1 ‚àÇŒº` equals
  the difference $F_Œº(b)-F_Œº(a)$, where $F_Œº(a)=Œº(-‚àû, a]$ is the
  [cumulative distribution function](https://en.wikipedia.org/wiki/Cumulative_distribution_function)
  of `Œº`.

## Tags

integral
-/


noncomputable section

open MeasureTheory Set Classical Filter Function

open scoped Classical Topology Filter ENNReal BigOperators Interval NNReal

variable {Œπ ùïú E F A : Type*} [NormedAddCommGroup E]

/-!
### Integrability on an interval
-/


/-- A function `f` is called *interval integrable* with respect to a measure `Œº` on an unordered
interval `a..b` if it is integrable on both intervals `(a, b]` and `(b, a]`. One of these
intervals is always empty, so this property is equivalent to `f` being integrable on
`(min a b, max a b]`. -/
def IntervalIntegrable (f : ‚Ñù ‚Üí E) (Œº : Measure ‚Ñù) (a b : ‚Ñù) : Prop :=
  IntegrableOn f (Ioc a b) Œº ‚àß IntegrableOn f (Ioc b a) Œº
#align interval_integrable IntervalIntegrable

section

variable {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} {Œº : Measure ‚Ñù}

/-- A function is interval integrable with respect to a given measure `Œº` on `a..b` if and
  only if it is integrable on `uIoc a b` with respect to `Œº`. This is an equivalent
  definition of `IntervalIntegrable`. -/
theorem intervalIntegrable_iff : IntervalIntegrable f Œº a b ‚Üî IntegrableOn f (Œô a b) Œº := by
  rw [uIoc_eq_union, integrableOn_union, IntervalIntegrable]
#align interval_integrable_iff intervalIntegrable_iff

/-- If a function is interval integrable with respect to a given measure `Œº` on `a..b` then
  it is integrable on `uIoc a b` with respect to `Œº`. -/
theorem IntervalIntegrable.def (h : IntervalIntegrable f Œº a b) : IntegrableOn f (Œô a b) Œº :=
  intervalIntegrable_iff.mp h
#align interval_integrable.def IntervalIntegrable.def

theorem intervalIntegrable_iff_integrableOn_Ioc_of_le (hab : a ‚â§ b) :
    IntervalIntegrable f Œº a b ‚Üî IntegrableOn f (Ioc a b) Œº := by
  rw [intervalIntegrable_iff, uIoc_of_le hab]
#align interval_integrable_iff_integrable_Ioc_of_le intervalIntegrable_iff_integrableOn_Ioc_of_le

theorem intervalIntegrable_iff' [NoAtoms Œº] :
    IntervalIntegrable f Œº a b ‚Üî IntegrableOn f (uIcc a b) Œº := by
  rw [intervalIntegrable_iff, ‚Üê Icc_min_max, uIoc, integrableOn_Icc_iff_integrableOn_Ioc]
#align interval_integrable_iff' intervalIntegrable_iff'

theorem intervalIntegrable_iff_integrableOn_Icc_of_le {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} (hab : a ‚â§ b)
    {Œº : Measure ‚Ñù} [NoAtoms Œº] : IntervalIntegrable f Œº a b ‚Üî IntegrableOn f (Icc a b) Œº := by
  rw [intervalIntegrable_iff_integrableOn_Ioc_of_le hab, integrableOn_Icc_iff_integrableOn_Ioc]
#align interval_integrable_iff_integrable_Icc_of_le intervalIntegrable_iff_integrableOn_Icc_of_le

theorem intervalIntegrable_iff_integrableOn_Ico_of_le [NoAtoms Œº] (hab : a ‚â§ b) :
    IntervalIntegrable f Œº a b ‚Üî IntegrableOn f (Ico a b) Œº := by
  rw [intervalIntegrable_iff_integrableOn_Icc_of_le hab, integrableOn_Icc_iff_integrableOn_Ico]

theorem intervalIntegrable_iff_integrableOn_Ioo_of_le [NoAtoms Œº] (hab : a ‚â§ b) :
    IntervalIntegrable f Œº a b ‚Üî IntegrableOn f (Ioo a b) Œº := by
  rw [intervalIntegrable_iff_integrableOn_Icc_of_le hab, integrableOn_Icc_iff_integrableOn_Ioo]

/-- If a function is integrable with respect to a given measure `Œº` then it is interval integrable
  with respect to `Œº` on `uIcc a b`. -/
theorem MeasureTheory.Integrable.intervalIntegrable (hf : Integrable f Œº) :
    IntervalIntegrable f Œº a b :=
  ‚ü®hf.integrableOn, hf.integrableOn‚ü©
#align measure_theory.integrable.interval_integrable MeasureTheory.Integrable.intervalIntegrable

theorem MeasureTheory.IntegrableOn.intervalIntegrable (hf : IntegrableOn f [[a, b]] Œº) :
    IntervalIntegrable f Œº a b :=
  ‚ü®MeasureTheory.IntegrableOn.mono_set hf (Ioc_subset_Icc_self.trans Icc_subset_uIcc),
    MeasureTheory.IntegrableOn.mono_set hf (Ioc_subset_Icc_self.trans Icc_subset_uIcc')‚ü©
#align measure_theory.integrable_on.interval_integrable MeasureTheory.IntegrableOn.intervalIntegrable

theorem intervalIntegrable_const_iff {c : E} :
    IntervalIntegrable (fun _ => c) Œº a b ‚Üî c = 0 ‚à® Œº (Œô a b) < ‚àû := by
  simp only [intervalIntegrable_iff, integrableOn_const]
#align interval_integrable_const_iff intervalIntegrable_const_iff

@[simp]
theorem intervalIntegrable_const [IsLocallyFiniteMeasure Œº] {c : E} :
    IntervalIntegrable (fun _ => c) Œº a b :=
  intervalIntegrable_const_iff.2 <| Or.inr measure_Ioc_lt_top
#align interval_integrable_const intervalIntegrable_const

end

namespace IntervalIntegrable

section

variable {f : ‚Ñù ‚Üí E} {a b c d : ‚Ñù} {Œº ŒΩ : Measure ‚Ñù}

@[symm]
nonrec theorem symm (h : IntervalIntegrable f Œº a b) : IntervalIntegrable f Œº b a :=
  h.symm
#align interval_integrable.symm IntervalIntegrable.symm

@[refl, simp] -- porting note: added `simp`
theorem refl : IntervalIntegrable f Œº a a := by constructor <;> simp
#align interval_integrable.refl IntervalIntegrable.refl

@[trans]
theorem trans {a b c : ‚Ñù} (hab : IntervalIntegrable f Œº a b) (hbc : IntervalIntegrable f Œº b c) :
    IntervalIntegrable f Œº a c :=
  ‚ü®(hab.1.union hbc.1).mono_set Ioc_subset_Ioc_union_Ioc,
    (hbc.2.union hab.2).mono_set Ioc_subset_Ioc_union_Ioc‚ü©
#align interval_integrable.trans IntervalIntegrable.trans

theorem trans_iterate_Ico {a : ‚Ñï ‚Üí ‚Ñù} {m n : ‚Ñï} (hmn : m ‚â§ n)
    (hint : ‚àÄ k ‚àà Ico m n, IntervalIntegrable f Œº (a k) (a <| k + 1)) :
    IntervalIntegrable f Œº (a m) (a n) := by
  revert hint
  refine' Nat.le_induction _ _ n hmn
  ¬∑ simp
  ¬∑ intro p hp IH h
    exact (IH fun k hk => h k (Ico_subset_Ico_right p.le_succ hk)).trans (h p (by simp [hp]))
#align interval_integrable.trans_iterate_Ico IntervalIntegrable.trans_iterate_Ico

theorem trans_iterate {a : ‚Ñï ‚Üí ‚Ñù} {n : ‚Ñï}
    (hint : ‚àÄ k < n, IntervalIntegrable f Œº (a k) (a <| k + 1)) :
    IntervalIntegrable f Œº (a 0) (a n) :=
  trans_iterate_Ico bot_le fun k hk => hint k hk.2
#align interval_integrable.trans_iterate IntervalIntegrable.trans_iterate

theorem neg (h : IntervalIntegrable f Œº a b) : IntervalIntegrable (-f) Œº a b :=
  ‚ü®h.1.neg, h.2.neg‚ü©
#align interval_integrable.neg IntervalIntegrable.neg

theorem norm (h : IntervalIntegrable f Œº a b) : IntervalIntegrable (fun x => ‚Äñf x‚Äñ) Œº a b :=
  ‚ü®h.1.norm, h.2.norm‚ü©
#align interval_integrable.norm IntervalIntegrable.norm

theorem intervalIntegrable_norm_iff {f : ‚Ñù ‚Üí E} {Œº : Measure ‚Ñù} {a b : ‚Ñù}
    (hf : AEStronglyMeasurable f (Œº.restrict (Œô a b))) :
    IntervalIntegrable (fun t => ‚Äñf t‚Äñ) Œº a b ‚Üî IntervalIntegrable f Œº a b := by
  simp_rw [intervalIntegrable_iff, IntegrableOn]; exact integrable_norm_iff hf
#align interval_integrable.interval_integrable_norm_iff IntervalIntegrable.intervalIntegrable_norm_iff

theorem abs {f : ‚Ñù ‚Üí ‚Ñù} (h : IntervalIntegrable f Œº a b) :
    IntervalIntegrable (fun x => |f x|) Œº a b :=
  h.norm
#align interval_integrable.abs IntervalIntegrable.abs

theorem mono (hf : IntervalIntegrable f ŒΩ a b) (h1 : [[c, d]] ‚äÜ [[a, b]]) (h2 : Œº ‚â§ ŒΩ) :
    IntervalIntegrable f Œº c d :=
  intervalIntegrable_iff.mpr <| hf.def.mono (uIoc_subset_uIoc_of_uIcc_subset_uIcc h1) h2
#align interval_integrable.mono IntervalIntegrable.mono

theorem mono_measure (hf : IntervalIntegrable f ŒΩ a b) (h : Œº ‚â§ ŒΩ) : IntervalIntegrable f Œº a b :=
  hf.mono Subset.rfl h
#align interval_integrable.mono_measure IntervalIntegrable.mono_measure

theorem mono_set (hf : IntervalIntegrable f Œº a b) (h : [[c, d]] ‚äÜ [[a, b]]) :
    IntervalIntegrable f Œº c d :=
  hf.mono h le_rfl
#align interval_integrable.mono_set IntervalIntegrable.mono_set

theorem mono_set_ae (hf : IntervalIntegrable f Œº a b) (h : Œô c d ‚â§·µê[Œº] Œô a b) :
    IntervalIntegrable f Œº c d :=
  intervalIntegrable_iff.mpr <| hf.def.mono_set_ae h
#align interval_integrable.mono_set_ae IntervalIntegrable.mono_set_ae

theorem mono_set' (hf : IntervalIntegrable f Œº a b) (hsub : Œô c d ‚äÜ Œô a b) :
    IntervalIntegrable f Œº c d :=
  hf.mono_set_ae <| eventually_of_forall hsub
#align interval_integrable.mono_set' IntervalIntegrable.mono_set'

theorem mono_fun [NormedAddCommGroup F] {g : ‚Ñù ‚Üí F} (hf : IntervalIntegrable f Œº a b)
    (hgm : AEStronglyMeasurable g (Œº.restrict (Œô a b)))
    (hle : (fun x => ‚Äñg x‚Äñ) ‚â§·µê[Œº.restrict (Œô a b)] fun x => ‚Äñf x‚Äñ) : IntervalIntegrable g Œº a b :=
  intervalIntegrable_iff.2 <| hf.def.integrable.mono hgm hle
#align interval_integrable.mono_fun IntervalIntegrable.mono_fun

theorem mono_fun' {g : ‚Ñù ‚Üí ‚Ñù} (hg : IntervalIntegrable g Œº a b)
    (hfm : AEStronglyMeasurable f (Œº.restrict (Œô a b)))
    (hle : (fun x => ‚Äñf x‚Äñ) ‚â§·µê[Œº.restrict (Œô a b)] g) : IntervalIntegrable f Œº a b :=
  intervalIntegrable_iff.2 <| hg.def.integrable.mono' hfm hle
#align interval_integrable.mono_fun' IntervalIntegrable.mono_fun'

protected theorem aestronglyMeasurable (h : IntervalIntegrable f Œº a b) :
    AEStronglyMeasurable f (Œº.restrict (Ioc a b)) :=
  h.1.aestronglyMeasurable
#align interval_integrable.ae_strongly_measurable IntervalIntegrable.aestronglyMeasurable

protected theorem aestronglyMeasurable' (h : IntervalIntegrable f Œº a b) :
    AEStronglyMeasurable f (Œº.restrict (Ioc b a)) :=
  h.2.aestronglyMeasurable
#align interval_integrable.ae_strongly_measurable' IntervalIntegrable.aestronglyMeasurable'

end

variable [NormedRing A] {f g : ‚Ñù ‚Üí E} {a b : ‚Ñù} {Œº : Measure ‚Ñù}

theorem smul [NormedField ùïú] [NormedSpace ùïú E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} {Œº : Measure ‚Ñù}
    (h : IntervalIntegrable f Œº a b) (r : ùïú) : IntervalIntegrable (r ‚Ä¢ f) Œº a b :=
  ‚ü®h.1.smul r, h.2.smul r‚ü©
#align interval_integrable.smul IntervalIntegrable.smul

@[simp]
theorem add (hf : IntervalIntegrable f Œº a b) (hg : IntervalIntegrable g Œº a b) :
    IntervalIntegrable (fun x => f x + g x) Œº a b :=
  ‚ü®hf.1.add hg.1, hf.2.add hg.2‚ü©
#align interval_integrable.add IntervalIntegrable.add

@[simp]
theorem sub (hf : IntervalIntegrable f Œº a b) (hg : IntervalIntegrable g Œº a b) :
    IntervalIntegrable (fun x => f x - g x) Œº a b :=
  ‚ü®hf.1.sub hg.1, hf.2.sub hg.2‚ü©
#align interval_integrable.sub IntervalIntegrable.sub

theorem sum (s : Finset Œπ) {f : Œπ ‚Üí ‚Ñù ‚Üí E} (h : ‚àÄ i ‚àà s, IntervalIntegrable (f i) Œº a b) :
    IntervalIntegrable (‚àë i in s, f i) Œº a b :=
  ‚ü®integrable_finset_sum' s fun i hi => (h i hi).1, integrable_finset_sum' s fun i hi => (h i hi).2‚ü©
#align interval_integrable.sum IntervalIntegrable.sum

theorem mul_continuousOn {f g : ‚Ñù ‚Üí A} (hf : IntervalIntegrable f Œº a b)
    (hg : ContinuousOn g [[a, b]]) : IntervalIntegrable (fun x => f x * g x) Œº a b := by
  rw [intervalIntegrable_iff] at hf ‚ä¢
  exact hf.mul_continuousOn_of_subset hg measurableSet_Ioc isCompact_uIcc Ioc_subset_Icc_self
#align interval_integrable.mul_continuous_on IntervalIntegrable.mul_continuousOn

theorem continuousOn_mul {f g : ‚Ñù ‚Üí A} (hf : IntervalIntegrable f Œº a b)
    (hg : ContinuousOn g [[a, b]]) : IntervalIntegrable (fun x => g x * f x) Œº a b := by
  rw [intervalIntegrable_iff] at hf ‚ä¢
  exact hf.continuousOn_mul_of_subset hg isCompact_uIcc measurableSet_Ioc Ioc_subset_Icc_self
#align interval_integrable.continuous_on_mul IntervalIntegrable.continuousOn_mul

@[simp]
theorem const_mul {f : ‚Ñù ‚Üí A} (hf : IntervalIntegrable f Œº a b) (c : A) :
    IntervalIntegrable (fun x => c * f x) Œº a b :=
  hf.continuousOn_mul continuousOn_const
#align interval_integrable.const_mul IntervalIntegrable.const_mul

@[simp]
theorem mul_const {f : ‚Ñù ‚Üí A} (hf : IntervalIntegrable f Œº a b) (c : A) :
    IntervalIntegrable (fun x => f x * c) Œº a b :=
  hf.mul_continuousOn continuousOn_const
#align interval_integrable.mul_const IntervalIntegrable.mul_const

@[simp]
theorem div_const {ùïú : Type*} {f : ‚Ñù ‚Üí ùïú} [NormedField ùïú] (h : IntervalIntegrable f Œº a b)
    (c : ùïú) : IntervalIntegrable (fun x => f x / c) Œº a b := by
  simpa only [div_eq_mul_inv] using mul_const h c‚Åª¬π
#align interval_integrable.div_const IntervalIntegrable.div_const

theorem comp_mul_left (hf : IntervalIntegrable f volume a b) (c : ‚Ñù) :
    IntervalIntegrable (fun x => f (c * x)) volume (a / c) (b / c) := by
  rcases eq_or_ne c 0 with (hc | hc); ¬∑ rw [hc]; simp
  rw [intervalIntegrable_iff'] at hf ‚ä¢
  have A : MeasurableEmbedding fun x => x * c‚Åª¬π :=
    (Homeomorph.mulRight‚ÇÄ _ (inv_ne_zero hc)).closedEmbedding.measurableEmbedding
  rw [‚Üê Real.smul_map_volume_mul_right (inv_ne_zero hc), IntegrableOn, Measure.restrict_smul,
    integrable_smul_measure (by simpa : ENNReal.ofReal |c‚Åª¬π| ‚â† 0) ENNReal.ofReal_ne_top,
    ‚Üê IntegrableOn, MeasurableEmbedding.integrableOn_map_iff A]
  convert hf using 1
  ¬∑ ext; simp only [comp_apply]; congr 1; field_simp; ring
  ¬∑ rw [preimage_mul_const_uIcc (inv_ne_zero hc)]; field_simp [hc]
#align interval_integrable.comp_mul_left IntervalIntegrable.comp_mul_left

-- porting note: new lemma
theorem comp_mul_left_iff {c : ‚Ñù} (hc : c ‚â† 0) :
    IntervalIntegrable (fun x ‚Ü¶ f (c * x)) volume (a / c) (b / c) ‚Üî
      IntervalIntegrable f volume a b :=
  ‚ü®fun h ‚Ü¶ by simpa [hc] using h.comp_mul_left c‚Åª¬π, (comp_mul_left ¬∑ c)‚ü©

theorem comp_mul_right (hf : IntervalIntegrable f volume a b) (c : ‚Ñù) :
    IntervalIntegrable (fun x => f (x * c)) volume (a / c) (b / c) := by
  simpa only [mul_comm] using comp_mul_left hf c
#align interval_integrable.comp_mul_right IntervalIntegrable.comp_mul_right

theorem comp_add_right (hf : IntervalIntegrable f volume a b) (c : ‚Ñù) :
    IntervalIntegrable (fun x => f (x + c)) volume (a - c) (b - c) := by
  wlog h : a ‚â§ b generalizing a b
  ¬∑ exact IntervalIntegrable.symm (this hf.symm (le_of_not_le h))
  rw [intervalIntegrable_iff'] at hf ‚ä¢
  have A : MeasurableEmbedding fun x => x + c :=
    (Homeomorph.addRight c).closedEmbedding.measurableEmbedding
  rw [‚Üê map_add_right_eq_self volume c] at hf
  convert (MeasurableEmbedding.integrableOn_map_iff A).mp hf using 1
  rw [preimage_add_const_uIcc]
#align interval_integrable.comp_add_right IntervalIntegrable.comp_add_right

theorem comp_add_left (hf : IntervalIntegrable f volume a b) (c : ‚Ñù) :
    IntervalIntegrable (fun x => f (c + x)) volume (a - c) (b - c) := by
  simpa only [add_comm] using IntervalIntegrable.comp_add_right hf c
#align interval_integrable.comp_add_left IntervalIntegrable.comp_add_left

theorem comp_sub_right (hf : IntervalIntegrable f volume a b) (c : ‚Ñù) :
    IntervalIntegrable (fun x => f (x - c)) volume (a + c) (b + c) := by
  simpa only [sub_neg_eq_add] using IntervalIntegrable.comp_add_right hf (-c)
#align interval_integrable.comp_sub_right IntervalIntegrable.comp_sub_right

theorem iff_comp_neg :
    IntervalIntegrable f volume a b ‚Üî IntervalIntegrable (fun x => f (-x)) volume (-a) (-b) := by
  rw [‚Üê comp_mul_left_iff (neg_ne_zero.2 one_ne_zero)]; simp [div_neg]
#align interval_integrable.iff_comp_neg IntervalIntegrable.iff_comp_neg

theorem comp_sub_left (hf : IntervalIntegrable f volume a b) (c : ‚Ñù) :
    IntervalIntegrable (fun x => f (c - x)) volume (c - a) (c - b) := by
  simpa only [neg_sub, ‚Üê sub_eq_add_neg] using iff_comp_neg.mp (hf.comp_add_left c)
#align interval_integrable.comp_sub_left IntervalIntegrable.comp_sub_left

end IntervalIntegrable

section

variable {Œº : Measure ‚Ñù} [IsLocallyFiniteMeasure Œº]

theorem ContinuousOn.intervalIntegrable {u : ‚Ñù ‚Üí E} {a b : ‚Ñù} (hu : ContinuousOn u (uIcc a b)) :
    IntervalIntegrable u Œº a b :=
  (ContinuousOn.integrableOn_Icc hu).intervalIntegrable
#align continuous_on.interval_integrable ContinuousOn.intervalIntegrable

theorem ContinuousOn.intervalIntegrable_of_Icc {u : ‚Ñù ‚Üí E} {a b : ‚Ñù} (h : a ‚â§ b)
    (hu : ContinuousOn u (Icc a b)) : IntervalIntegrable u Œº a b :=
  ContinuousOn.intervalIntegrable ((uIcc_of_le h).symm ‚ñ∏ hu)
#align continuous_on.interval_integrable_of_Icc ContinuousOn.intervalIntegrable_of_Icc

/-- A continuous function on `‚Ñù` is `IntervalIntegrable` with respect to any locally finite measure
`ŒΩ` on ‚Ñù. -/
theorem Continuous.intervalIntegrable {u : ‚Ñù ‚Üí E} (hu : Continuous u) (a b : ‚Ñù) :
    IntervalIntegrable u Œº a b :=
  hu.continuousOn.intervalIntegrable
#align continuous.interval_integrable Continuous.intervalIntegrable

end

section

variable {Œº : Measure ‚Ñù} [IsLocallyFiniteMeasure Œº] [ConditionallyCompleteLinearOrder E]
  [OrderTopology E] [SecondCountableTopology E]

theorem MonotoneOn.intervalIntegrable {u : ‚Ñù ‚Üí E} {a b : ‚Ñù} (hu : MonotoneOn u (uIcc a b)) :
    IntervalIntegrable u Œº a b := by
  rw [intervalIntegrable_iff]
  exact (hu.integrableOn_isCompact isCompact_uIcc).mono_set Ioc_subset_Icc_self
#align monotone_on.interval_integrable MonotoneOn.intervalIntegrable

theorem AntitoneOn.intervalIntegrable {u : ‚Ñù ‚Üí E} {a b : ‚Ñù} (hu : AntitoneOn u (uIcc a b)) :
    IntervalIntegrable u Œº a b :=
  hu.dual_right.intervalIntegrable
#align antitone_on.interval_integrable AntitoneOn.intervalIntegrable

theorem Monotone.intervalIntegrable {u : ‚Ñù ‚Üí E} {a b : ‚Ñù} (hu : Monotone u) :
    IntervalIntegrable u Œº a b :=
  (hu.monotoneOn _).intervalIntegrable
#align monotone.interval_integrable Monotone.intervalIntegrable

theorem Antitone.intervalIntegrable {u : ‚Ñù ‚Üí E} {a b : ‚Ñù} (hu : Antitone u) :
    IntervalIntegrable u Œº a b :=
  (hu.antitoneOn _).intervalIntegrable
#align antitone.interval_integrable Antitone.intervalIntegrable

end

/-- Let `l'` be a measurably generated filter; let `l` be a of filter such that each `s ‚àà l'`
eventually includes `Ioc u v` as both `u` and `v` tend to `l`. Let `Œº` be a measure finite at `l'`.

Suppose that `f : ‚Ñù ‚Üí E` has a finite limit at `l' ‚äì Œº.ae`. Then `f` is interval integrable on
`u..v` provided that both `u` and `v` tend to `l`.

Typeclass instances allow Lean to find `l'` based on `l` but not vice versa, so
`apply Tendsto.eventually_intervalIntegrable_ae` will generate goals `Filter ‚Ñù` and
`TendstoIxxClass Ioc ?m_1 l'`. -/
theorem Filter.Tendsto.eventually_intervalIntegrable_ae {f : ‚Ñù ‚Üí E} {Œº : Measure ‚Ñù}
    {l l' : Filter ‚Ñù} (hfm : StronglyMeasurableAtFilter f l' Œº) [TendstoIxxClass Ioc l l']
    [IsMeasurablyGenerated l'] (hŒº : Œº.FiniteAtFilter l') {c : E} (hf : Tendsto f (l' ‚äì Œº.ae) (ùìù c))
    {u v : Œπ ‚Üí ‚Ñù} {lt : Filter Œπ} (hu : Tendsto u lt l) (hv : Tendsto v lt l) :
    ‚àÄ·∂† t in lt, IntervalIntegrable f Œº (u t) (v t) :=
  have := (hf.integrableAtFilter_ae hfm hŒº).eventually
  ((hu.Ioc hv).eventually this).and <| (hv.Ioc hu).eventually this
#align filter.tendsto.eventually_interval_integrable_ae Filter.Tendsto.eventually_intervalIntegrable_ae

/-- Let `l'` be a measurably generated filter; let `l` be a of filter such that each `s ‚àà l'`
eventually includes `Ioc u v` as both `u` and `v` tend to `l`. Let `Œº` be a measure finite at `l'`.

Suppose that `f : ‚Ñù ‚Üí E` has a finite limit at `l`. Then `f` is interval integrable on `u..v`
provided that both `u` and `v` tend to `l`.

Typeclass instances allow Lean to find `l'` based on `l` but not vice versa, so
`apply Tendsto.eventually_intervalIntegrable` will generate goals `Filter ‚Ñù` and
`TendstoIxxClass Ioc ?m_1 l'`. -/
theorem Filter.Tendsto.eventually_intervalIntegrable {f : ‚Ñù ‚Üí E} {Œº : Measure ‚Ñù} {l l' : Filter ‚Ñù}
    (hfm : StronglyMeasurableAtFilter f l' Œº) [TendstoIxxClass Ioc l l'] [IsMeasurablyGenerated l']
    (hŒº : Œº.FiniteAtFilter l') {c : E} (hf : Tendsto f l' (ùìù c)) {u v : Œπ ‚Üí ‚Ñù} {lt : Filter Œπ}
    (hu : Tendsto u lt l) (hv : Tendsto v lt l) : ‚àÄ·∂† t in lt, IntervalIntegrable f Œº (u t) (v t) :=
  (hf.mono_left inf_le_left).eventually_intervalIntegrable_ae hfm hŒº hu hv
#align filter.tendsto.eventually_interval_integrable Filter.Tendsto.eventually_intervalIntegrable

/-!
### Interval integral: definition and basic properties

In this section we define `‚à´ x in a..b, f x ‚àÇŒº` as `‚à´ x in Ioc a b, f x ‚àÇŒº - ‚à´ x in Ioc b a, f x ‚àÇŒº`
and prove some basic properties.
-/

variable [CompleteSpace E] [NormedSpace ‚Ñù E]

/-- The interval integral `‚à´ x in a..b, f x ‚àÇŒº` is defined
as `‚à´ x in Ioc a b, f x ‚àÇŒº - ‚à´ x in Ioc b a, f x ‚àÇŒº`. If `a ‚â§ b`, then it equals
`‚à´ x in Ioc a b, f x ‚àÇŒº`, otherwise it equals `-‚à´ x in Ioc b a, f x ‚àÇŒº`. -/
def intervalIntegral (f : ‚Ñù ‚Üí E) (a b : ‚Ñù) (Œº : Measure ‚Ñù) : E :=
  (‚à´ x in Ioc a b, f x ‚àÇŒº) - ‚à´ x in Ioc b a, f x ‚àÇŒº
#align interval_integral intervalIntegral

notation3"‚à´ "(...)" in "a".."b", "r:60:(scoped f => f)" ‚àÇ"Œº:70 => intervalIntegral r a b Œº

notation3"‚à´ "(...)" in "a".."b", "r:60:(scoped f => intervalIntegral f a b volume) => r

namespace intervalIntegral

section Basic

variable {a b : ‚Ñù} {f g : ‚Ñù ‚Üí E} {Œº : Measure ‚Ñù}

@[simp]
theorem integral_zero : (‚à´ _ in a..b, (0 : E) ‚àÇŒº) = 0 := by simp [intervalIntegral]
#align interval_integral.integral_zero intervalIntegral.integral_zero

theorem integral_of_le (h : a ‚â§ b) : ‚à´ x in a..b, f x ‚àÇŒº = ‚à´ x in Ioc a b, f x ‚àÇŒº := by
  simp [intervalIntegral, h]
#align interval_integral.integral_of_le intervalIntegral.integral_of_le

@[simp]
theorem integral_same : ‚à´ x in a..a, f x ‚àÇŒº = 0 :=
  sub_self _
#align interval_integral.integral_same intervalIntegral.integral_same

theorem integral_symm (a b) : ‚à´ x in b..a, f x ‚àÇŒº = -‚à´ x in a..b, f x ‚àÇŒº := by
  simp only [intervalIntegral, neg_sub]
#align interval_integral.integral_symm intervalIntegral.integral_symm

theorem integral_of_ge (h : b ‚â§ a) : ‚à´ x in a..b, f x ‚àÇŒº = -‚à´ x in Ioc b a, f x ‚àÇŒº := by
  simp only [integral_symm b, integral_of_le h]
#align interval_integral.integral_of_ge intervalIntegral.integral_of_ge

theorem intervalIntegral_eq_integral_uIoc (f : ‚Ñù ‚Üí E) (a b : ‚Ñù) (Œº : Measure ‚Ñù) :
    ‚à´ x in a..b, f x ‚àÇŒº = (if a ‚â§ b then 1 else -1 : ‚Ñù) ‚Ä¢ ‚à´ x in Œô a b, f x ‚àÇŒº := by
  split_ifs with h
  ¬∑ simp only [integral_of_le h, uIoc_of_le h, one_smul]
  ¬∑ simp only [integral_of_ge (not_le.1 h).le, uIoc_of_lt (not_le.1 h), neg_one_smul]
#align interval_integral.interval_integral_eq_integral_uIoc intervalIntegral.intervalIntegral_eq_integral_uIoc

theorem norm_intervalIntegral_eq (f : ‚Ñù ‚Üí E) (a b : ‚Ñù) (Œº : Measure ‚Ñù) :
    ‚Äñ‚à´ x in a..b, f x ‚àÇŒº‚Äñ = ‚Äñ‚à´ x in Œô a b, f x ‚àÇŒº‚Äñ := by
  simp_rw [intervalIntegral_eq_integral_uIoc, norm_smul]
  split_ifs <;> simp only [norm_neg, norm_one, one_mul]
#align interval_integral.norm_interval_integral_eq intervalIntegral.norm_intervalIntegral_eq

theorem abs_intervalIntegral_eq (f : ‚Ñù ‚Üí ‚Ñù) (a b : ‚Ñù) (Œº : Measure ‚Ñù) :
    |‚à´ x in a..b, f x ‚àÇŒº| = |‚à´ x in Œô a b, f x ‚àÇŒº| :=
  norm_intervalIntegral_eq f a b Œº
#align interval_integral.abs_interval_integral_eq intervalIntegral.abs_intervalIntegral_eq

theorem integral_cases (f : ‚Ñù ‚Üí E) (a b) :
    (‚à´ x in a..b, f x ‚àÇŒº) ‚àà ({‚à´ x in Œô a b, f x ‚àÇŒº, -‚à´ x in Œô a b, f x ‚àÇŒº} : Set E) := by
  rw [intervalIntegral_eq_integral_uIoc]; split_ifs <;> simp
#align interval_integral.integral_cases intervalIntegral.integral_cases

nonrec theorem integral_undef (h : ¬¨IntervalIntegrable f Œº a b) : ‚à´ x in a..b, f x ‚àÇŒº = 0 := by
  rw [intervalIntegrable_iff] at h
  rw [intervalIntegral_eq_integral_uIoc, integral_undef h, smul_zero]
#align interval_integral.integral_undef intervalIntegral.integral_undef

theorem intervalIntegrable_of_integral_ne_zero {a b : ‚Ñù} {f : ‚Ñù ‚Üí E} {Œº : Measure ‚Ñù}
    (h : (‚à´ x in a..b, f x ‚àÇŒº) ‚â† 0) : IntervalIntegrable f Œº a b :=
  not_imp_comm.1 integral_undef h
#align interval_integral.interval_integrable_of_integral_ne_zero intervalIntegral.intervalIntegrable_of_integral_ne_zero

nonrec theorem integral_non_aestronglyMeasurable
    (hf : ¬¨AEStronglyMeasurable f (Œº.restrict (Œô a b))) :
    ‚à´ x in a..b, f x ‚àÇŒº = 0 := by
  rw [intervalIntegral_eq_integral_uIoc, integral_non_aestronglyMeasurable hf, smul_zero]
#align interval_integral.integral_non_ae_strongly_measurable intervalIntegral.integral_non_aestronglyMeasurable

theorem integral_non_aestronglyMeasurable_of_le (h : a ‚â§ b)
    (hf : ¬¨AEStronglyMeasurable f (Œº.restrict (Ioc a b))) : ‚à´ x in a..b, f x ‚àÇŒº = 0 :=
  integral_non_aestronglyMeasurable <| by rwa [uIoc_of_le h]
#align interval_integral.integral_non_ae_strongly_measurable_of_le intervalIntegral.integral_non_aestronglyMeasurable_of_le

theorem norm_integral_min_max (f : ‚Ñù ‚Üí E) :
    ‚Äñ‚à´ x in min a b..max a b, f x ‚àÇŒº‚Äñ = ‚Äñ‚à´ x in a..b, f x ‚àÇŒº‚Äñ := by
  cases le_total a b <;> simp [*, integral_symm a b]
#align interval_integral.norm_integral_min_max intervalIntegral.norm_integral_min_max

theorem norm_integral_eq_norm_integral_Ioc (f : ‚Ñù ‚Üí E) :
    ‚Äñ‚à´ x in a..b, f x ‚àÇŒº‚Äñ = ‚Äñ‚à´ x in Œô a b, f x ‚àÇŒº‚Äñ := by
  rw [‚Üê norm_integral_min_max, integral_of_le min_le_max, uIoc]
#align interval_integral.norm_integral_eq_norm_integral_Ioc intervalIntegral.norm_integral_eq_norm_integral_Ioc

theorem abs_integral_eq_abs_integral_uIoc (f : ‚Ñù ‚Üí ‚Ñù) :
    |‚à´ x in a..b, f x ‚àÇŒº| = |‚à´ x in Œô a b, f x ‚àÇŒº| :=
  norm_integral_eq_norm_integral_Ioc f
#align interval_integral.abs_integral_eq_abs_integral_uIoc intervalIntegral.abs_integral_eq_abs_integral_uIoc

theorem norm_integral_le_integral_norm_Ioc : ‚Äñ‚à´ x in a..b, f x ‚àÇŒº‚Äñ ‚â§ ‚à´ x in Œô a b, ‚Äñf x‚Äñ ‚àÇŒº :=
  calc
    ‚Äñ‚à´ x in a..b, f x ‚àÇŒº‚Äñ = ‚Äñ‚à´ x in Œô a b, f x ‚àÇŒº‚Äñ := norm_integral_eq_norm_integral_Ioc f
    _ ‚â§ ‚à´ x in Œô a b, ‚Äñf x‚Äñ ‚àÇŒº := norm_integral_le_integral_norm f
#align interval_integral.norm_integral_le_integral_norm_Ioc intervalIntegral.norm_integral_le_integral_norm_Ioc

theorem norm_integral_le_abs_integral_norm : ‚Äñ‚à´ x in a..b, f x ‚àÇŒº‚Äñ ‚â§ |‚à´ x in a..b, ‚Äñf x‚Äñ ‚àÇŒº| := by
  simp only [‚Üê Real.norm_eq_abs, norm_integral_eq_norm_integral_Ioc]
  exact le_trans (norm_integral_le_integral_norm _) (le_abs_self _)
#align interval_integral.norm_integral_le_abs_integral_norm intervalIntegral.norm_integral_le_abs_integral_norm

theorem norm_integral_le_integral_norm (h : a ‚â§ b) :
    ‚Äñ‚à´ x in a..b, f x ‚àÇŒº‚Äñ ‚â§ ‚à´ x in a..b, ‚Äñf x‚Äñ ‚àÇŒº :=
  norm_integral_le_integral_norm_Ioc.trans_eq <| by rw [uIoc_of_le h, integral_of_le h]
#align interval_integral.norm_integral_le_integral_norm intervalIntegral.norm_integral_le_integral_norm

nonrec theorem norm_integral_le_of_norm_le {g : ‚Ñù ‚Üí ‚Ñù} (h : ‚àÄ·µê t ‚àÇŒº.restrict <| Œô a b, ‚Äñf t‚Äñ ‚â§ g t)
    (hbound : IntervalIntegrable g Œº a b) : ‚Äñ‚à´ t in a..b, f t ‚àÇŒº‚Äñ ‚â§ |‚à´ t in a..b, g t ‚àÇŒº| := by
  simp_rw [norm_intervalIntegral_eq, abs_intervalIntegral_eq,
    abs_eq_self.mpr (integral_nonneg_of_ae <| h.mono fun _t ht => (norm_nonneg _).trans ht),
    norm_integral_le_of_norm_le hbound.def h]
#align interval_integral.norm_integral_le_of_norm_le intervalIntegral.norm_integral_le_of_norm_le

theorem norm_integral_le_of_norm_le_const_ae {a b C : ‚Ñù} {f : ‚Ñù ‚Üí E}
    (h : ‚àÄ·µê x, x ‚àà Œô a b ‚Üí ‚Äñf x‚Äñ ‚â§ C) : ‚Äñ‚à´ x in a..b, f x‚Äñ ‚â§ C * |b - a| := by
  rw [norm_integral_eq_norm_integral_Ioc]
  convert norm_set_integral_le_of_norm_le_const_ae'' _ measurableSet_Ioc h using 1
  ¬∑ rw [Real.volume_Ioc, max_sub_min_eq_abs, ENNReal.toReal_ofReal (abs_nonneg _)]
  ¬∑ simp only [Real.volume_Ioc, ENNReal.ofReal_lt_top]
#align interval_integral.norm_integral_le_of_norm_le_const_ae intervalIntegral.norm_integral_le_of_norm_le_const_ae

theorem norm_integral_le_of_norm_le_const {a b C : ‚Ñù} {f : ‚Ñù ‚Üí E} (h : ‚àÄ x ‚àà Œô a b, ‚Äñf x‚Äñ ‚â§ C) :
    ‚Äñ‚à´ x in a..b, f x‚Äñ ‚â§ C * |b - a| :=
  norm_integral_le_of_norm_le_const_ae <| eventually_of_forall h
#align interval_integral.norm_integral_le_of_norm_le_const intervalIntegral.norm_integral_le_of_norm_le_const

@[simp]
nonrec theorem integral_add (hf : IntervalIntegrable f Œº a b) (hg : IntervalIntegrable g Œº a b) :
    ‚à´ x in a..b, f x + g x ‚àÇŒº = (‚à´ x in a..b, f x ‚àÇŒº) + ‚à´ x in a..b, g x ‚àÇŒº := by
  simp only [intervalIntegral_eq_integral_uIoc, integral_add hf.def hg.def, smul_add]
#align interval_integral.integral_add intervalIntegral.integral_add

nonrec theorem integral_finset_sum {Œπ} {s : Finset Œπ} {f : Œπ ‚Üí ‚Ñù ‚Üí E}
    (h : ‚àÄ i ‚àà s, IntervalIntegrable (f i) Œº a b) :
    ‚à´ x in a..b, ‚àë i in s, f i x ‚àÇŒº = ‚àë i in s, ‚à´ x in a..b, f i x ‚àÇŒº := by
  simp only [intervalIntegral_eq_integral_uIoc, integral_finset_sum s fun i hi => (h i hi).def,
    Finset.smul_sum]
#align interval_integral.integral_finset_sum intervalIntegral.integral_finset_sum

@[simp]
nonrec theorem integral_neg : ‚à´ x in a..b, -f x ‚àÇŒº = -‚à´ x in a..b, f x ‚àÇŒº := by
  simp only [intervalIntegral, integral_neg]; abel
#align interval_integral.integral_neg intervalIntegral.integral_neg

@[simp]
theorem integral_sub (hf : IntervalIntegrable f Œº a b) (hg : IntervalIntegrable g Œº a b) :
    ‚à´ x in a..b, f x - g x ‚àÇŒº = (‚à´ x in a..b, f x ‚àÇŒº) - ‚à´ x in a..b, g x ‚àÇŒº := by
  simpa only [sub_eq_add_neg] using (integral_add hf hg.neg).trans (congr_arg _ integral_neg)
#align interval_integral.integral_sub intervalIntegral.integral_sub

@[simp]
nonrec theorem integral_smul {ùïú : Type*} [NontriviallyNormedField ùïú] [NormedSpace ùïú E]
    [SMulCommClass ‚Ñù ùïú E] (r : ùïú) (f : ‚Ñù ‚Üí E) :
    ‚à´ x in a..b, r ‚Ä¢ f x ‚àÇŒº = r ‚Ä¢ ‚à´ x in a..b, f x ‚àÇŒº := by
  simp only [intervalIntegral, integral_smul, smul_sub]
#align interval_integral.integral_smul intervalIntegral.integral_smul

@[simp]
nonrec theorem integral_smul_const {ùïú : Type*} [IsROrC ùïú] [NormedSpace ùïú E] (f : ‚Ñù ‚Üí ùïú) (c : E) :
    ‚à´ x in a..b, f x ‚Ä¢ c ‚àÇŒº = (‚à´ x in a..b, f x ‚àÇŒº) ‚Ä¢ c := by
  simp only [intervalIntegral_eq_integral_uIoc, integral_smul_const, smul_assoc]
#align interval_integral.integral_smul_const intervalIntegral.integral_smul_const

@[simp]
theorem integral_const_mul {ùïú : Type*} [IsROrC ùïú] (r : ùïú) (f : ‚Ñù ‚Üí ùïú) :
    ‚à´ x in a..b, r * f x ‚àÇŒº = r * ‚à´ x in a..b, f x ‚àÇŒº :=
  integral_smul r f
#align interval_integral.integral_const_mul intervalIntegral.integral_const_mul

@[simp]
theorem integral_mul_const {ùïú : Type*} [IsROrC ùïú] (r : ùïú) (f : ‚Ñù ‚Üí ùïú) :
    ‚à´ x in a..b, f x * r ‚àÇŒº = (‚à´ x in a..b, f x ‚àÇŒº) * r := by
  simpa only [mul_comm r] using integral_const_mul r f
#align interval_integral.integral_mul_const intervalIntegral.integral_mul_const

@[simp]
theorem integral_div {ùïú : Type*} [IsROrC ùïú] (r : ùïú) (f : ‚Ñù ‚Üí ùïú) :
    ‚à´ x in a..b, f x / r ‚àÇŒº = (‚à´ x in a..b, f x ‚àÇŒº) / r := by
  simpa only [div_eq_mul_inv] using integral_mul_const r‚Åª¬π f
#align interval_integral.integral_div intervalIntegral.integral_div

theorem integral_const' (c : E) :
    ‚à´ _ in a..b, c ‚àÇŒº = ((Œº <| Ioc a b).toReal - (Œº <| Ioc b a).toReal) ‚Ä¢ c := by
  simp only [intervalIntegral, set_integral_const, sub_smul]
#align interval_integral.integral_const' intervalIntegral.integral_const'

@[simp]
theorem integral_const (c : E) : ‚à´ _ in a..b, c = (b - a) ‚Ä¢ c := by
  simp only [integral_const', Real.volume_Ioc, ENNReal.toReal_ofReal', ‚Üê neg_sub b,
    max_zero_sub_eq_self]
#align interval_integral.integral_const intervalIntegral.integral_const

nonrec theorem integral_smul_measure (c : ‚Ñù‚â•0‚àû) :
    ‚à´ x in a..b, f x ‚àÇc ‚Ä¢ Œº = c.toReal ‚Ä¢ ‚à´ x in a..b, f x ‚àÇŒº := by
  simp only [intervalIntegral, Measure.restrict_smul, integral_smul_measure, smul_sub]
#align interval_integral.integral_smul_measure intervalIntegral.integral_smul_measure

end Basic

-- porting note: TODO: add `Complex.ofReal` version of `_root_.integral_ofReal`
nonrec theorem _root_.IsROrC.interval_integral_ofReal {ùïú : Type*} [IsROrC ùïú] {a b : ‚Ñù}
    {Œº : Measure ‚Ñù} {f : ‚Ñù ‚Üí ‚Ñù} : (‚à´ x in a..b, (f x : ùïú) ‚àÇŒº) = ‚Üë(‚à´ x in a..b, f x ‚àÇŒº) := by
  simp only [intervalIntegral, integral_ofReal, IsROrC.ofReal_sub]

nonrec theorem integral_ofReal {a b : ‚Ñù} {Œº : Measure ‚Ñù} {f : ‚Ñù ‚Üí ‚Ñù} :
    (‚à´ x in a..b, (f x : ‚ÑÇ) ‚àÇŒº) = ‚Üë(‚à´ x in a..b, f x ‚àÇŒº) :=
  IsROrC.interval_integral_ofReal
#align interval_integral.integral_of_real intervalIntegral.integral_ofReal

section ContinuousLinearMap

variable {a b : ‚Ñù} {Œº : Measure ‚Ñù} {f : ‚Ñù ‚Üí E}

variable [IsROrC ùïú] [NormedSpace ùïú E] [NormedAddCommGroup F] [NormedSpace ùïú F]

open ContinuousLinearMap

theorem _root_.ContinuousLinearMap.intervalIntegral_apply {a b : ‚Ñù} {œÜ : ‚Ñù ‚Üí F ‚ÜíL[ùïú] E}
    (hœÜ : IntervalIntegrable œÜ Œº a b) (v : F) :
    (‚à´ x in a..b, œÜ x ‚àÇŒº) v = ‚à´ x in a..b, œÜ x v ‚àÇŒº := by
  simp_rw [intervalIntegral_eq_integral_uIoc, ‚Üê integral_apply hœÜ.def v, coe_smul', Pi.smul_apply]
#align continuous_linear_map.interval_integral_apply ContinuousLinearMap.intervalIntegral_apply

variable [NormedSpace ‚Ñù F] [CompleteSpace F]

theorem _root_.ContinuousLinearMap.intervalIntegral_comp_comm (L : E ‚ÜíL[ùïú] F)
    (hf : IntervalIntegrable f Œº a b) : (‚à´ x in a..b, L (f x) ‚àÇŒº) = L (‚à´ x in a..b, f x ‚àÇŒº) := by
  simp_rw [intervalIntegral, L.integral_comp_comm hf.1, L.integral_comp_comm hf.2, L.map_sub]
#align continuous_linear_map.interval_integral_comp_comm ContinuousLinearMap.intervalIntegral_comp_comm

end ContinuousLinearMap

section Comp

variable {a b c d : ‚Ñù} (f : ‚Ñù ‚Üí E)

/-!
Porting note: some `@[simp]` attributes in this section were removed to make the `simpNF` linter
happy. TODO: find out if these lemmas are actually good or bad `simp` lemmas.
-/

-- porting note: was @[simp]
theorem integral_comp_mul_right (hc : c ‚â† 0) :
    (‚à´ x in a..b, f (x * c)) = c‚Åª¬π ‚Ä¢ ‚à´ x in a * c..b * c, f x := by
  have A : MeasurableEmbedding fun x => x * c :=
    (Homeomorph.mulRight‚ÇÄ c hc).closedEmbedding.measurableEmbedding
  conv_rhs => rw [‚Üê Real.smul_map_volume_mul_right hc]
  simp_rw [integral_smul_measure, intervalIntegral, A.set_integral_map,
    ENNReal.toReal_ofReal (abs_nonneg c)]
  cases' hc.lt_or_lt with h h
  ¬∑ simp [h, mul_div_cancel, hc, abs_of_neg,
      Measure.restrict_congr_set (Œ± := ‚Ñù) (Œº := volume) Ico_ae_eq_Ioc]
  ¬∑ simp [h, mul_div_cancel, hc, abs_of_pos]
#align interval_integral.integral_comp_mul_right intervalIntegral.integral_comp_mul_right

-- porting note: was @[simp]
theorem smul_integral_comp_mul_right (c) :
    (c ‚Ä¢ ‚à´ x in a..b, f (x * c)) = ‚à´ x in a * c..b * c, f x := by
  by_cases hc : c = 0 <;> simp [hc, integral_comp_mul_right]
#align interval_integral.smul_integral_comp_mul_right intervalIntegral.smul_integral_comp_mul_right

-- porting note: was @[simp]
theorem integral_comp_mul_left (hc : c ‚â† 0) :
    (‚à´ x in a..b, f (c * x)) = c‚Åª¬π ‚Ä¢ ‚à´ x in c * a..c * b, f x := by
  simpa only [mul_comm c] using integral_comp_mul_right f hc
#align interval_integral.integral_comp_mul_left intervalIntegral.integral_comp_mul_left

-- porting note: was @[simp]
theorem smul_integral_comp_mul_left (c) : (c ‚Ä¢ ‚à´ x in a..b, f (c * x)) = ‚à´ x in c * a..c * b, f x :=
  by by_cases hc : c = 0 <;> simp [hc, integral_comp_mul_left]
#align interval_integral.smul_integral_comp_mul_left intervalIntegral.smul_integral_comp_mul_left

-- porting note: was @[simp]
theorem integral_comp_div (hc : c ‚â† 0) : (‚à´ x in a..b, f (x / c)) = c ‚Ä¢ ‚à´ x in a / c..b / c, f x :=
  by simpa only [inv_inv] using integral_comp_mul_right f (inv_ne_zero hc)
#align interval_integral.integral_comp_div intervalIntegral.integral_comp_div

-- porting note: was @[simp]
theorem inv_smul_integral_comp_div (c) :
    (c‚Åª¬π ‚Ä¢ ‚à´ x in a..b, f (x / c)) = ‚à´ x in a / c..b / c, f x := by
  by_cases hc : c = 0 <;> simp [hc, integral_comp_div]
#align interval_integral.inv_smul_integral_comp_div intervalIntegral.inv_smul_integral_comp_div

-- porting note: was @[simp]
theorem integral_comp_add_right (d) : (‚à´ x in a..b, f (x + d)) = ‚à´ x in a + d..b + d, f x :=
  have A : MeasurableEmbedding fun x => x + d :=
    (Homeomorph.addRight d).closedEmbedding.measurableEmbedding
  calc
    (‚à´ x in a..b, f (x + d)) = ‚à´ x in a + d..b + d, f x ‚àÇMeasure.map (fun x => x + d) volume := by
      simp [intervalIntegral, A.set_integral_map]
    _ = ‚à´ x in a + d..b + d, f x := by rw [map_add_right_eq_self]
#align interval_integral.integral_comp_add_right intervalIntegral.integral_comp_add_right

-- porting note: was @[simp]
nonrec theorem integral_comp_add_left (d) :
    (‚à´ x in a..b, f (d + x)) = ‚à´ x in d + a..d + b, f x := by
  simpa only [add_comm d] using integral_comp_add_right f d
#align interval_integral.integral_comp_add_left intervalIntegral.integral_comp_add_left

-- porting note: was @[simp]
theorem integral_comp_mul_add (hc : c ‚â† 0) (d) :
    (‚à´ x in a..b, f (c * x + d)) = c‚Åª¬π ‚Ä¢ ‚à´ x in c * a + d..c * b + d, f x := by
  rw [‚Üê integral_comp_add_right, ‚Üê integral_comp_mul_left _ hc]
#align interval_integral.integral_comp_mul_add intervalIntegral.integral_comp_mul_add

-- porting note: was @[simp]
theorem smul_integral_comp_mul_add (c d) :
    (c ‚Ä¢ ‚à´ x in a..b, f (c * x + d)) = ‚à´ x in c * a + d..c * b + d, f x := by
  by_cases hc : c = 0 <;> simp [hc, integral_comp_mul_add]
#align interval_integral.smul_integral_comp_mul_add intervalIntegral.smul_integral_comp_mul_add

-- porting note: was @[simp]
theorem integral_comp_add_mul (hc : c ‚â† 0) (d) :
    (‚à´ x in a..b, f (d + c * x)) = c‚Åª¬π ‚Ä¢ ‚à´ x in d + c * a..d + c * b, f x := by
  rw [‚Üê integral_comp_add_left, ‚Üê integral_comp_mul_left _ hc]
#align interval_integral.integral_comp_add_mul intervalIntegral.integral_comp_add_mul

-- porting note: was @[simp]
theorem smul_integral_comp_add_mul (c d) :
    (c ‚Ä¢ ‚à´ x in a..b, f (d + c * x)) = ‚à´ x in d + c * a..d + c * b, f x := by
  by_cases hc : c = 0 <;> simp [hc, integral_comp_add_mul]
#align interval_integral.smul_integral_comp_add_mul intervalIntegral.smul_integral_comp_add_mul

-- porting note: was @[simp]
theorem integral_comp_div_add (hc : c ‚â† 0) (d) :
    (‚à´ x in a..b, f (x / c + d)) = c ‚Ä¢ ‚à´ x in a / c + d..b / c + d, f x := by
  simpa only [div_eq_inv_mul, inv_inv] using integral_comp_mul_add f (inv_ne_zero hc) d
#align interval_integral.integral_comp_div_add intervalIntegral.integral_comp_div_add

-- porting note: was @[simp]
theorem inv_smul_integral_comp_div_add (c d) :
    (c‚Åª¬π ‚Ä¢ ‚à´ x in a..b, f (x / c + d)) = ‚à´ x in a / c + d..b / c + d, f x := by
  by_cases hc : c = 0 <;> simp [hc, integral_comp_div_add]
#align interval_integral.inv_smul_integral_comp_div_add intervalIntegral.inv_smul_integral_comp_div_add

-- porting note: was @[simp]
theorem integral_comp_add_div (hc : c ‚â† 0) (d) :
    (‚à´ x in a..b, f (d + x / c)) = c ‚Ä¢ ‚à´ x in d + a / c..d + b / c, f x := by
  simpa only [div_eq_inv_mul, inv_inv] using integral_comp_add_mul f (inv_ne_zero hc) d
#align interval_integral.integral_comp_add_div intervalIntegral.integral_comp_add_div

-- porting note: was @[simp]
theorem inv_smul_integral_comp_add_div (c d) :
    (c‚Åª¬π ‚Ä¢ ‚à´ x in a..b, f (d + x / c)) = ‚à´ x in d + a / c..d + b / c, f x := by
  by_cases hc : c = 0 <;> simp [hc, integral_comp_add_div]
#align interval_integral.inv_smul_integral_comp_add_div intervalIntegral.inv_smul_integral_comp_add_div

-- porting note: was @[simp]
theorem integral_comp_mul_sub (hc : c ‚â† 0) (d) :
    (‚à´ x in a..b, f (c * x - d)) = c‚Åª¬π ‚Ä¢ ‚à´ x in c * a - d..c * b - d, f x := by
  simpa only [sub_eq_add_neg] using integral_comp_mul_add f hc (-d)
#align interval_integral.integral_comp_mul_sub intervalIntegral.integral_comp_mul_sub

-- porting note: was @[simp]
theorem smul_integral_comp_mul_sub (c d) :
    (c ‚Ä¢ ‚à´ x in a..b, f (c * x - d)) = ‚à´ x in c * a - d..c * b - d, f x := by
  by_cases hc : c = 0 <;> simp [hc, integral_comp_mul_sub]
#align interval_integral.smul_integral_comp_mul_sub intervalIntegral.smul_integral_comp_mul_sub

-- porting note: was @[simp]
theorem integral_comp_sub_mul (hc : c ‚â† 0) (d) :
    (‚à´ x in a..b, f (d - c * x)) = c‚Åª¬π ‚Ä¢ ‚à´ x in d - c * b..d - c * a, f x := by
  simp only [sub_eq_add_neg, neg_mul_eq_neg_mul]
  rw [integral_comp_add_mul f (neg_ne_zero.mpr hc) d, integral_symm]
  simp only [inv_neg, smul_neg, neg_neg, neg_smul]
#align interval_integral.integral_comp_sub_mul intervalIntegral.integral_comp_sub_mul

-- porting note: was @[simp]
theorem smul_integral_comp_sub_mul (c d) :
    (c ‚Ä¢ ‚à´ x in a..b, f (d - c * x)) = ‚à´ x in d - c * b..d - c * a, f x := by
  by_cases hc : c = 0 <;> simp [hc, integral_comp_sub_mul]
#align interval_integral.smul_integral_comp_sub_mul intervalIntegral.smul_integral_comp_sub_mul

-- porting note: was @[simp]
theorem integral_comp_div_sub (hc : c ‚â† 0) (d) :
    (‚à´ x in a..b, f (x / c - d)) = c ‚Ä¢ ‚à´ x in a / c - d..b / c - d, f x := by
  simpa only [div_eq_inv_mul, inv_inv] using integral_comp_mul_sub f (inv_ne_zero hc) d
#align interval_integral.integral_comp_div_sub intervalIntegral.integral_comp_div_sub

-- porting note: was @[simp]
theorem inv_smul_integral_comp_div_sub (c d) :
    (c‚Åª¬π ‚Ä¢ ‚à´ x in a..b, f (x / c - d)) = ‚à´ x in a / c - d..b / c - d, f x := by
  by_cases hc : c = 0 <;> simp [hc, integral_comp_div_sub]
#align interval_integral.inv_smul_integral_comp_div_sub intervalIntegral.inv_smul_integral_comp_div_sub

-- porting note: was @[simp]
theorem integral_comp_sub_div (hc : c ‚â† 0) (d) :
    (‚à´ x in a..b, f (d - x / c)) = c ‚Ä¢ ‚à´ x in d - b / c..d - a / c, f x := by
  simpa only [div_eq_inv_mul, inv_inv] using integral_comp_sub_mul f (inv_ne_zero hc) d
#align interval_integral.integral_comp_sub_div intervalIntegral.integral_comp_sub_div

-- porting note: was @[simp]
theorem inv_smul_integral_comp_sub_div (c d) :
    (c‚Åª¬π ‚Ä¢ ‚à´ x in a..b, f (d - x / c)) = ‚à´ x in d - b / c..d - a / c, f x := by
  by_cases hc : c = 0 <;> simp [hc, integral_comp_sub_div]
#align interval_integral.inv_smul_integral_comp_sub_div intervalIntegral.inv_smul_integral_comp_sub_div

-- porting note: was @[simp]
theorem integral_comp_sub_right (d) : (‚à´ x in a..b, f (x - d)) = ‚à´ x in a - d..b - d, f x := by
  simpa only [sub_eq_add_neg] using integral_comp_add_right f (-d)
#align interval_integral.integral_comp_sub_right intervalIntegral.integral_comp_sub_right

-- porting note: was @[simp]
theorem integral_comp_sub_left (d) : (‚à´ x in a..b, f (d - x)) = ‚à´ x in d - b..d - a, f x := by
  simpa only [one_mul, one_smul, inv_one] using integral_comp_sub_mul f one_ne_zero d
#align interval_integral.integral_comp_sub_left intervalIntegral.integral_comp_sub_left

-- porting note: was @[simp]
theorem integral_comp_neg : (‚à´ x in a..b, f (-x)) = ‚à´ x in -b..-a, f x := by
  simpa only [zero_sub] using integral_comp_sub_left f 0
#align interval_integral.integral_comp_neg intervalIntegral.integral_comp_neg

end Comp

/-!
### Integral is an additive function of the interval

In this section we prove that `‚à´ x in a..b, f x ‚àÇŒº + ‚à´ x in b..c, f x ‚àÇŒº = ‚à´ x in a..c, f x ‚àÇŒº`
as well as a few other identities trivially equivalent to this one. We also prove that
`‚à´ x in a..b, f x ‚àÇŒº = ‚à´ x, f x ‚àÇŒº` provided that `support f ‚äÜ Ioc a b`.
-/


section OrderClosedTopology

variable {a b c d : ‚Ñù} {f g : ‚Ñù ‚Üí E} {Œº : Measure ‚Ñù}

/-- If two functions are equal in the relevant interval, their interval integrals are also equal. -/
theorem integral_congr {a b : ‚Ñù} (h : EqOn f g [[a, b]]) :
    ‚à´ x in a..b, f x ‚àÇŒº = ‚à´ x in a..b, g x ‚àÇŒº := by
  rcases le_total a b with hab | hab <;>
    simpa [hab, integral_of_le, integral_of_ge] using
      set_integral_congr measurableSet_Ioc (h.mono Ioc_subset_Icc_self)
#align interval_integral.integral_congr intervalIntegral.integral_congr

theorem integral_add_adjacent_intervals_cancel (hab : IntervalIntegrable f Œº a b)
    (hbc : IntervalIntegrable f Œº b c) :
    (((‚à´ x in a..b, f x ‚àÇŒº) + ‚à´ x in b..c, f x ‚àÇŒº) + ‚à´ x in c..a, f x ‚àÇŒº) = 0 := by
  have hac := hab.trans hbc
  simp only [intervalIntegral, sub_add_sub_comm, sub_eq_zero]
  iterate 4 rw [‚Üê integral_union]
  ¬∑ suffices Ioc a b ‚à™ Ioc b c ‚à™ Ioc c a = Ioc b a ‚à™ Ioc c b ‚à™ Ioc a c by rw [this]
    rw [Ioc_union_Ioc_union_Ioc_cycle, union_right_comm, Ioc_union_Ioc_union_Ioc_cycle,
      min_left_comm, max_left_comm]
  all_goals
    simp [*, MeasurableSet.union, measurableSet_Ioc, Ioc_disjoint_Ioc_same,
      Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
#align interval_integral.integral_add_adjacent_intervals_cancel intervalIntegral.integral_add_adjacent_intervals_cancel

theorem integral_add_adjacent_intervals (hab : IntervalIntegrable f Œº a b)
    (hbc : IntervalIntegrable f Œº b c) :
    ((‚à´ x in a..b, f x ‚àÇŒº) + ‚à´ x in b..c, f x ‚àÇŒº) = ‚à´ x in a..c, f x ‚àÇŒº := by
  rw [‚Üê add_neg_eq_zero, ‚Üê integral_symm, integral_add_adjacent_intervals_cancel hab hbc]
#align interval_integral.integral_add_adjacent_intervals intervalIntegral.integral_add_adjacent_intervals

theorem sum_integral_adjacent_intervals_Ico {a : ‚Ñï ‚Üí ‚Ñù} {m n : ‚Ñï} (hmn : m ‚â§ n)
    (hint : ‚àÄ k ‚àà Ico m n, IntervalIntegrable f Œº (a k) (a <| k + 1)) :
    ‚àë k : ‚Ñï in Finset.Ico m n, ‚à´ x in a k..a <| k + 1, f x ‚àÇŒº = ‚à´ x in a m..a n, f x ‚àÇŒº := by
  revert hint
  refine' Nat.le_induction _ _ n hmn
  ¬∑ simp
  ¬∑ intro p hmp IH h
    rw [Finset.sum_Ico_succ_top hmp, IH, integral_add_adjacent_intervals]
    ¬∑ refine IntervalIntegrable.trans_iterate_Ico hmp fun k hk => h k ?_
      exact (Ico_subset_Ico le_rfl (Nat.le_succ _)) hk
    ¬∑ apply h
      simp [hmp]
    ¬∑ intro k hk
      exact h _ (Ico_subset_Ico_right p.le_succ hk)
#align interval_integral.sum_integral_adjacent_intervals_Ico intervalIntegral.sum_integral_adjacent_intervals_Ico

theorem sum_integral_adjacent_intervals {a : ‚Ñï ‚Üí ‚Ñù} {n : ‚Ñï}
    (hint : ‚àÄ k < n, IntervalIntegrable f Œº (a k) (a <| k + 1)) :
    ‚àë k : ‚Ñï in Finset.range n, ‚à´ x in a k..a <| k + 1, f x ‚àÇŒº = ‚à´ x in (a 0)..(a n), f x ‚àÇŒº := by
  rw [‚Üê Nat.Ico_zero_eq_range]
  exact sum_integral_adjacent_intervals_Ico (zero_le n) fun k hk => hint k hk.2
#align interval_integral.sum_integral_adjacent_intervals intervalIntegral.sum_integral_adjacent_intervals

theorem integral_interval_sub_left (hab : IntervalIntegrable f Œº a b)
    (hac : IntervalIntegrable f Œº a c) :
    ((‚à´ x in a..b, f x ‚àÇŒº) - ‚à´ x in a..c, f x ‚àÇŒº) = ‚à´ x in c..b, f x ‚àÇŒº :=
  sub_eq_of_eq_add' <| Eq.symm <| integral_add_adjacent_intervals hac (hac.symm.trans hab)
#align interval_integral.integral_interval_sub_left intervalIntegral.integral_interval_sub_left

theorem integral_interval_add_interval_comm (hab : IntervalIntegrable f Œº a b)
    (hcd : IntervalIntegrable f Œº c d) (hac : IntervalIntegrable f Œº a c) :
    ((‚à´ x in a..b, f x ‚àÇŒº) + ‚à´ x in c..d, f x ‚àÇŒº) =
      (‚à´ x in a..d, f x ‚àÇŒº) + ‚à´ x in c..b, f x ‚àÇŒº := by
  rw [‚Üê integral_add_adjacent_intervals hac hcd, add_assoc, add_left_comm,
    integral_add_adjacent_intervals hac (hac.symm.trans hab), add_comm]
#align interval_integral.integral_interval_add_interval_comm intervalIntegral.integral_interval_add_interval_comm

theorem integral_interval_sub_interval_comm (hab : IntervalIntegrable f Œº a b)
    (hcd : IntervalIntegrable f Œº c d) (hac : IntervalIntegrable f Œº a c) :
    ((‚à´ x in a..b, f x ‚àÇŒº) - ‚à´ x in c..d, f x ‚àÇŒº) =
      (‚à´ x in a..c, f x ‚àÇŒº) - ‚à´ x in b..d, f x ‚àÇŒº := by
  simp only [sub_eq_add_neg, ‚Üê integral_symm,
    integral_interval_add_interval_comm hab hcd.symm (hac.trans hcd)]
#align interval_integral.integral_interval_sub_interval_comm intervalIntegral.integral_interval_sub_interval_comm

theorem integral_interval_sub_interval_comm' (hab : IntervalIntegrable f Œº a b)
    (hcd : IntervalIntegrable f Œº c d) (hac : IntervalIntegrable f Œº a c) :
    ((‚à´ x in a..b, f x ‚àÇŒº) - ‚à´ x in c..d, f x ‚àÇŒº) =
      (‚à´ x in d..b, f x ‚àÇŒº) - ‚à´ x in c..a, f x ‚àÇŒº := by
  rw [integral_interval_sub_interval_comm hab hcd hac, integral_symm b d, integral_symm a c,
    sub_neg_eq_add, sub_eq_neg_add]
#align interval_integral.integral_interval_sub_interval_comm' intervalIntegral.integral_interval_sub_interval_comm'

theorem integral_Iic_sub_Iic (ha : IntegrableOn f (Iic a) Œº) (hb : IntegrableOn f (Iic b) Œº) :
    ((‚à´ x in Iic b, f x ‚àÇŒº) - ‚à´ x in Iic a, f x ‚àÇŒº) = ‚à´ x in a..b, f x ‚àÇŒº := by
  wlog hab : a ‚â§ b generalizing a b
  ¬∑ rw [integral_symm, ‚Üê this hb ha (le_of_not_le hab), neg_sub]
  rw [sub_eq_iff_eq_add', integral_of_le hab, ‚Üê integral_union (Iic_disjoint_Ioc le_rfl),
    Iic_union_Ioc_eq_Iic hab]
  exacts [measurableSet_Ioc, ha, hb.mono_set fun _ => And.right]
#align interval_integral.integral_Iic_sub_Iic intervalIntegral.integral_Iic_sub_Iic

theorem integral_Iic_add_Ioi (h_left : IntegrableOn f (Iic b) Œº)
    (h_right : IntegrableOn f (Ioi b) Œº) :
    (‚à´ x in Iic b, f x ‚àÇŒº) + (‚à´ x in Ioi b, f x ‚àÇŒº) = ‚à´ (x : ‚Ñù), f x ‚àÇŒº := by
  convert (integral_union (Iic_disjoint_Ioi <| Eq.le rfl) measurableSet_Ioi h_left h_right).symm
  rw [Iic_union_Ioi, Measure.restrict_univ]

theorem integral_Iio_add_Ici (h_left : IntegrableOn f (Iio b) Œº)
    (h_right : IntegrableOn f (Ici b) Œº) :
    (‚à´ x in Iio b, f x ‚àÇŒº) + (‚à´ x in Ici b, f x ‚àÇŒº) = ‚à´ (x : ‚Ñù), f x ‚àÇŒº := by
  convert (integral_union (Iio_disjoint_Ici <| Eq.le rfl) measurableSet_Ici h_left h_right).symm
  rw [Iio_union_Ici, Measure.restrict_univ]

/-- If `Œº` is a finite measure then `‚à´ x in a..b, c ‚àÇŒº = (Œº (Iic b) - Œº (Iic a)) ‚Ä¢ c`. -/
theorem integral_const_of_cdf [IsFiniteMeasure Œº] (c : E) :
    ‚à´ _ in a..b, c ‚àÇŒº = ((Œº (Iic b)).toReal - (Œº (Iic a)).toReal) ‚Ä¢ c := by
  simp only [sub_smul, ‚Üê set_integral_const]
  refine' (integral_Iic_sub_Iic _ _).symm <;>
    simp only [integrableOn_const, measure_lt_top, or_true_iff]
#align interval_integral.integral_const_of_cdf intervalIntegral.integral_const_of_cdf

theorem integral_eq_integral_of_support_subset {a b} (h : support f ‚äÜ Ioc a b) :
    ‚à´ x in a..b, f x ‚àÇŒº = ‚à´ x, f x ‚àÇŒº := by
  rcases le_total a b with hab | hab
  ¬∑ rw [integral_of_le hab, ‚Üê integral_indicator measurableSet_Ioc, indicator_eq_self.2 h]
  ¬∑ rw [Ioc_eq_empty hab.not_lt, subset_empty_iff, support_eq_empty_iff] at h
    simp [h]
#align interval_integral.integral_eq_integral_of_support_subset intervalIntegral.integral_eq_integral_of_support_subset

theorem integral_congr_ae' (h : ‚àÄ·µê x ‚àÇŒº, x ‚àà Ioc a b ‚Üí f x = g x)
    (h' : ‚àÄ·µê x ‚àÇŒº, x ‚àà Ioc b a ‚Üí f x = g x) : ‚à´ x in a..b, f x ‚àÇŒº = ‚à´ x in a..b, g x ‚àÇŒº := by
  simp only [intervalIntegral, set_integral_congr_ae measurableSet_Ioc h,
    set_integral_congr_ae measurableSet_Ioc h']
#align interval_integral.integral_congr_ae' intervalIntegral.integral_congr_ae'

theorem integral_congr_ae (h : ‚àÄ·µê x ‚àÇŒº, x ‚àà Œô a b ‚Üí f x = g x) :
    ‚à´ x in a..b, f x ‚àÇŒº = ‚à´ x in a..b, g x ‚àÇŒº :=
  integral_congr_ae' (ae_uIoc_iff.mp h).1 (ae_uIoc_iff.mp h).2
#align interval_integral.integral_congr_ae intervalIntegral.integral_congr_ae

theorem integral_zero_ae (h : ‚àÄ·µê x ‚àÇŒº, x ‚àà Œô a b ‚Üí f x = 0) : ‚à´ x in a..b, f x ‚àÇŒº = 0 :=
  calc
    ‚à´ x in a..b, f x ‚àÇŒº = ‚à´ _ in a..b, 0 ‚àÇŒº := integral_congr_ae h
    _ = 0 := integral_zero
#align interval_integral.integral_zero_ae intervalIntegral.integral_zero_ae

nonrec theorem integral_indicator {a‚ÇÅ a‚ÇÇ a‚ÇÉ : ‚Ñù} (h : a‚ÇÇ ‚àà Icc a‚ÇÅ a‚ÇÉ) :
    ‚à´ x in a‚ÇÅ..a‚ÇÉ, indicator {x | x ‚â§ a‚ÇÇ} f x ‚àÇŒº = ‚à´ x in a‚ÇÅ..a‚ÇÇ, f x ‚àÇŒº := by
  have : {x | x ‚â§ a‚ÇÇ} ‚à© Ioc a‚ÇÅ a‚ÇÉ = Ioc a‚ÇÅ a‚ÇÇ := Iic_inter_Ioc_of_le h.2
  rw [integral_of_le h.1, integral_of_le (h.1.trans h.2), integral_indicator,
    Measure.restrict_restrict, this]
  exact measurableSet_Iic
  all_goals apply measurableSet_Iic
#align interval_integral.integral_indicator intervalIntegral.integral_indicator

/-- Lebesgue dominated convergence theorem for filters with a countable basis -/
nonrec theorem tendsto_integral_filter_of_dominated_convergence {Œπ} {l : Filter Œπ}
    [l.IsCountablyGenerated] {F : Œπ ‚Üí ‚Ñù ‚Üí E} (bound : ‚Ñù ‚Üí ‚Ñù)
    (hF_meas : ‚àÄ·∂† n in l, AEStronglyMeasurable (F n) (Œº.restrict (Œô a b)))
    (h_bound : ‚àÄ·∂† n in l, ‚àÄ·µê x ‚àÇŒº, x ‚àà Œô a b ‚Üí ‚ÄñF n x‚Äñ ‚â§ bound x)
    (bound_integrable : IntervalIntegrable bound Œº a b)
    (h_lim : ‚àÄ·µê x ‚àÇŒº, x ‚àà Œô a b ‚Üí Tendsto (fun n => F n x) l (ùìù (f x))) :
    Tendsto (fun n => ‚à´ x in a..b, F n x ‚àÇŒº) l (ùìù <| ‚à´ x in a..b, f x ‚àÇŒº) := by
  simp only [intervalIntegrable_iff, intervalIntegral_eq_integral_uIoc,
    ‚Üê ae_restrict_iff' (Œ± := ‚Ñù) (Œº := Œº) measurableSet_uIoc] at *
  exact tendsto_const_nhds.smul <|
    tendsto_integral_filter_of_dominated_convergence bound hF_meas h_bound bound_integrable h_lim
#align interval_integral.tendsto_integral_filter_of_dominated_convergence intervalIntegral.tendsto_integral_filter_of_dominated_convergence

/-- Lebesgue dominated convergence theorem for series. -/
nonrec theorem hasSum_integral_of_dominated_convergence {Œπ} [Countable Œπ] {F : Œπ ‚Üí ‚Ñù ‚Üí E}
    (bound : Œπ ‚Üí ‚Ñù ‚Üí ‚Ñù) (hF_meas : ‚àÄ n, AEStronglyMeasurable (F n) (Œº.restrict (Œô a b)))
    (h_bound : ‚àÄ n, ‚àÄ·µê t ‚àÇŒº, t ‚àà Œô a b ‚Üí ‚ÄñF n t‚Äñ ‚â§ bound n t)
    (bound_summable : ‚àÄ·µê t ‚àÇŒº, t ‚àà Œô a b ‚Üí Summable fun n => bound n t)
    (bound_integrable : IntervalIntegrable (fun t => ‚àë' n, bound n t) Œº a b)
    (h_lim : ‚àÄ·µê t ‚àÇŒº, t ‚àà Œô a b ‚Üí HasSum (fun n => F n t) (f t)) :
    HasSum (fun n => ‚à´ t in a..b, F n t ‚àÇŒº) (‚à´ t in a..b, f t ‚àÇŒº) := by
  simp only [intervalIntegrable_iff, intervalIntegral_eq_integral_uIoc, ‚Üê
    ae_restrict_iff' (Œ± := ‚Ñù) (Œº := Œº) measurableSet_uIoc] at *
  exact
    (hasSum_integral_of_dominated_convergence bound hF_meas h_bound bound_summable bound_integrable
          h_lim).const_smul
      _
#align interval_integral.has_sum_integral_of_dominated_convergence intervalIntegral.hasSum_integral_of_dominated_convergence

open TopologicalSpace

/-- Interval integrals commute with countable sums, when the supremum norms are summable (a
special case of the dominated convergence theorem). -/
theorem hasSum_intervalIntegral_of_summable_norm [Countable Œπ] {f : Œπ ‚Üí C(‚Ñù, E)}
    (hf_sum : Summable fun i : Œπ => ‚Äñ(f i).restrict (‚ü®uIcc a b, isCompact_uIcc‚ü© : Compacts ‚Ñù)‚Äñ) :
    HasSum (fun i : Œπ => ‚à´ x in a..b, f i x) (‚à´ x in a..b, ‚àë' i : Œπ, f i x) := by
  apply hasSum_integral_of_dominated_convergence
    (fun i (x : ‚Ñù) => ‚Äñ(f i).restrict ‚Üë(‚ü®uIcc a b, isCompact_uIcc‚ü© : Compacts ‚Ñù)‚Äñ)
    (fun i => (map_continuous <| f i).aestronglyMeasurable)
  ¬∑ refine fun i => ae_of_all _ fun x hx => ?_
    apply ContinuousMap.norm_coe_le_norm ((f i).restrict _) ‚ü®x, _‚ü©
    exact ‚ü®hx.1.le, hx.2‚ü©
  ¬∑ exact ae_of_all _ fun x _ => hf_sum
  ¬∑ exact intervalIntegrable_const
  ¬∑ refine ae_of_all _ fun x hx => Summable.hasSum ?_
    let x : (‚ü®uIcc a b, isCompact_uIcc‚ü© : Compacts ‚Ñù) := ‚ü®x, ?_‚ü©; swap; exact ‚ü®hx.1.le, hx.2‚ü©
    have := hf_sum.of_norm
    simpa only [Compacts.coe_mk, ContinuousMap.restrict_apply]
      using ContinuousMap.summable_apply this x
#align interval_integral.has_sum_interval_integral_of_summable_norm intervalIntegral.hasSum_intervalIntegral_of_summable_norm

theorem tsum_intervalIntegral_eq_of_summable_norm [Countable Œπ] {f : Œπ ‚Üí C(‚Ñù, E)}
    (hf_sum : Summable fun i : Œπ => ‚Äñ(f i).restrict (‚ü®uIcc a b, isCompact_uIcc‚ü© : Compacts ‚Ñù)‚Äñ) :
    ‚àë' i : Œπ, ‚à´ x in a..b, f i x = ‚à´ x in a..b, ‚àë' i : Œπ, f i x :=
  (hasSum_intervalIntegral_of_summable_norm hf_sum).tsum_eq
#align interval_integral.tsum_interval_integral_eq_of_summable_norm intervalIntegral.tsum_intervalIntegral_eq_of_summable_norm

variable {X : Type*} [TopologicalSpace X] [FirstCountableTopology X]

/-- Continuity of interval integral with respect to a parameter, at a point within a set.
  Given `F : X ‚Üí ‚Ñù ‚Üí E`, assume `F x` is ae-measurable on `[a, b]` for `x` in a
  neighborhood of `x‚ÇÄ`¬†within `s` and at `x‚ÇÄ`, and assume it is bounded by a function integrable
  on `[a, b]` independent of `x` in a neighborhood of `x‚ÇÄ`¬†within `s`. If `(fun x ‚Ü¶ F x t)`
  is continuous at `x‚ÇÄ` within `s` for almost every `t` in `[a, b]`
  then the same holds for `(fun x ‚Ü¶ ‚à´ t in a..b, F x t ‚àÇŒº) s x‚ÇÄ`. -/
theorem continuousWithinAt_of_dominated_interval {F : X ‚Üí ‚Ñù ‚Üí E} {x‚ÇÄ : X} {bound : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù}
    {s : Set X} (hF_meas : ‚àÄ·∂† x in ùìù[s] x‚ÇÄ, AEStronglyMeasurable (F x) (Œº.restrict <| Œô a b))
    (h_bound : ‚àÄ·∂† x in ùìù[s] x‚ÇÄ, ‚àÄ·µê t ‚àÇŒº, t ‚àà Œô a b ‚Üí ‚ÄñF x t‚Äñ ‚â§ bound t)
    (bound_integrable : IntervalIntegrable bound Œº a b)
    (h_cont : ‚àÄ·µê t ‚àÇŒº, t ‚àà Œô a b ‚Üí ContinuousWithinAt (fun x => F x t) s x‚ÇÄ) :
    ContinuousWithinAt (fun x => ‚à´ t in a..b, F x t ‚àÇŒº) s x‚ÇÄ :=
  tendsto_integral_filter_of_dominated_convergence bound hF_meas h_bound bound_integrable h_cont
#align interval_integral.continuous_within_at_of_dominated_interval intervalIntegral.continuousWithinAt_of_dominated_interval

/-- Continuity of interval integral with respect to a parameter at a point.
  Given `F : X ‚Üí ‚Ñù ‚Üí E`, assume `F x` is ae-measurable on `[a, b]` for `x` in a
  neighborhood of `x‚ÇÄ`, and assume it is bounded by a function integrable on
  `[a, b]` independent of `x` in a neighborhood of `x‚ÇÄ`. If `(fun x ‚Ü¶ F x t)`
  is continuous at `x‚ÇÄ` for almost every `t` in `[a, b]`
  then the same holds for `(fun x ‚Ü¶ ‚à´ t in a..b, F x t ‚àÇŒº) s x‚ÇÄ`. -/
theorem continuousAt_of_dominated_interval {F : X ‚Üí ‚Ñù ‚Üí E} {x‚ÇÄ : X} {bound : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù}
    (hF_meas : ‚àÄ·∂† x in ùìù x‚ÇÄ, AEStronglyMeasurable (F x) (Œº.restrict <| Œô a b))
    (h_bound : ‚àÄ·∂† x in ùìù x‚ÇÄ, ‚àÄ·µê t ‚àÇŒº, t ‚àà Œô a b ‚Üí ‚ÄñF x t‚Äñ ‚â§ bound t)
    (bound_integrable : IntervalIntegrable bound Œº a b)
    (h_cont : ‚àÄ·µê t ‚àÇŒº, t ‚àà Œô a b ‚Üí ContinuousAt (fun x => F x t) x‚ÇÄ) :
    ContinuousAt (fun x => ‚à´ t in a..b, F x t ‚àÇŒº) x‚ÇÄ :=
  tendsto_integral_filter_of_dominated_convergence bound hF_meas h_bound bound_integrable h_cont
#align interval_integral.continuous_at_of_dominated_interval intervalIntegral.continuousAt_of_dominated_interval

/-- Continuity of interval integral with respect to a parameter.
  Given `F : X ‚Üí ‚Ñù ‚Üí E`, assume each `F x` is ae-measurable on `[a, b]`,
  and assume it is bounded by a function integrable on `[a, b]` independent of `x`.
  If `(fun x ‚Ü¶ F x t)` is continuous for almost every `t` in `[a, b]`
  then the same holds for `(fun x ‚Ü¶ ‚à´ t in a..b, F x t ‚àÇŒº) s x‚ÇÄ`. -/
theorem continuous_of_dominated_interval {F : X ‚Üí ‚Ñù ‚Üí E} {bound : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù}
    (hF_meas : ‚àÄ x, AEStronglyMeasurable (F x) <| Œº.restrict <| Œô a b)
    (h_bound : ‚àÄ x, ‚àÄ·µê t ‚àÇŒº, t ‚àà Œô a b ‚Üí ‚ÄñF x t‚Äñ ‚â§ bound t)
    (bound_integrable : IntervalIntegrable bound Œº a b)
    (h_cont : ‚àÄ·µê t ‚àÇŒº, t ‚àà Œô a b ‚Üí Continuous fun x => F x t) :
    Continuous fun x => ‚à´ t in a..b, F x t ‚àÇŒº :=
  continuous_iff_continuousAt.mpr fun _ =>
    continuousAt_of_dominated_interval (eventually_of_forall hF_meas) (eventually_of_forall h_bound)
        bound_integrable <|
      h_cont.mono fun _ himp hx => (himp hx).continuousAt
#align interval_integral.continuous_of_dominated_interval intervalIntegral.continuous_of_dominated_interval

end OrderClosedTopology

section ContinuousPrimitive

open TopologicalSpace

variable {a b b‚ÇÄ b‚ÇÅ b‚ÇÇ : ‚Ñù} {Œº : Measure ‚Ñù} {f g : ‚Ñù ‚Üí E}

theorem continuousWithinAt_primitive (hb‚ÇÄ : Œº {b‚ÇÄ} = 0)
    (h_int : IntervalIntegrable f Œº (min a b‚ÇÅ) (max a b‚ÇÇ)) :
    ContinuousWithinAt (fun b => ‚à´ x in a..b, f x ‚àÇŒº) (Icc b‚ÇÅ b‚ÇÇ) b‚ÇÄ := by
  by_cases h‚ÇÄ : b‚ÇÄ ‚àà Icc b‚ÇÅ b‚ÇÇ
  ¬∑ have h‚ÇÅ‚ÇÇ : b‚ÇÅ ‚â§ b‚ÇÇ := h‚ÇÄ.1.trans h‚ÇÄ.2
    have min‚ÇÅ‚ÇÇ : min b‚ÇÅ b‚ÇÇ = b‚ÇÅ := min_eq_left h‚ÇÅ‚ÇÇ
    have h_int' : ‚àÄ {x}, x ‚àà Icc b‚ÇÅ b‚ÇÇ ‚Üí IntervalIntegrable f Œº b‚ÇÅ x := by
      rintro x ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
      apply h_int.mono_set
      apply uIcc_subset_uIcc
      ¬∑ exact ‚ü®min_le_of_left_le (min_le_right a b‚ÇÅ),
          h‚ÇÅ.trans (h‚ÇÇ.trans <| le_max_of_le_right <| le_max_right _ _)‚ü©
      ¬∑ exact ‚ü®min_le_of_left_le <| (min_le_right _ _).trans h‚ÇÅ,
          le_max_of_le_right <| h‚ÇÇ.trans <| le_max_right _ _‚ü©
    have : ‚àÄ b ‚àà Icc b‚ÇÅ b‚ÇÇ,
        ‚à´ x in a..b, f x ‚àÇŒº = (‚à´ x in a..b‚ÇÅ, f x ‚àÇŒº) + ‚à´ x in b‚ÇÅ..b, f x ‚àÇŒº := by
      rintro b ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
      rw [‚Üê integral_add_adjacent_intervals _ (h_int' ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©)]
      apply h_int.mono_set
      apply uIcc_subset_uIcc
      ¬∑ exact ‚ü®min_le_of_left_le (min_le_left a b‚ÇÅ), le_max_of_le_right (le_max_left _ _)‚ü©
      ¬∑ exact ‚ü®min_le_of_left_le (min_le_right _ _),
          le_max_of_le_right (h‚ÇÅ.trans <| h‚ÇÇ.trans (le_max_right a b‚ÇÇ))‚ü©
    apply ContinuousWithinAt.congr _ this (this _ h‚ÇÄ); clear this
    refine' continuousWithinAt_const.add _
    have :
      (fun b => ‚à´ x in b‚ÇÅ..b, f x ‚àÇŒº) =·∂†[ùìù[Icc b‚ÇÅ b‚ÇÇ] b‚ÇÄ] fun b =>
        ‚à´ x in b‚ÇÅ..b‚ÇÇ, indicator {x | x ‚â§ b} f x ‚àÇŒº := by
      apply eventuallyEq_of_mem self_mem_nhdsWithin
      exact fun b b_in => (integral_indicator b_in).symm
    apply ContinuousWithinAt.congr_of_eventuallyEq _ this (integral_indicator h‚ÇÄ).symm
    have : IntervalIntegrable (fun x => ‚Äñf x‚Äñ) Œº b‚ÇÅ b‚ÇÇ :=
      IntervalIntegrable.norm (h_int' <| right_mem_Icc.mpr h‚ÇÅ‚ÇÇ)
    refine' continuousWithinAt_of_dominated_interval _ _ this _ <;> clear this
    ¬∑ apply Eventually.mono self_mem_nhdsWithin
      intro x hx
      erw [aestronglyMeasurable_indicator_iff, Measure.restrict_restrict, Iic_inter_Ioc_of_le]
      ¬∑ rw [min‚ÇÅ‚ÇÇ]
        exact (h_int' hx).1.aestronglyMeasurable
      ¬∑ exact le_max_of_le_right hx.2
      exacts [measurableSet_Iic, measurableSet_Iic]
    ¬∑ refine' eventually_of_forall fun x => eventually_of_forall fun t => _
      dsimp [indicator]
      split_ifs <;> simp
    ¬∑ have : ‚àÄ·µê t ‚àÇŒº, t < b‚ÇÄ ‚à® b‚ÇÄ < t := by
        apply Eventually.mono (compl_mem_ae_iff.mpr hb‚ÇÄ)
        intro x hx
        exact Ne.lt_or_lt hx
      apply this.mono
      rintro x‚ÇÄ (hx‚ÇÄ | hx‚ÇÄ) -
      ¬∑ have : ‚àÄ·∂† x in ùìù[Icc b‚ÇÅ b‚ÇÇ] b‚ÇÄ, {t : ‚Ñù | t ‚â§ x}.indicator f x‚ÇÄ = f x‚ÇÄ := by
          apply mem_nhdsWithin_of_mem_nhds
          apply Eventually.mono (Ioi_mem_nhds hx‚ÇÄ)
          intro x hx
          simp [hx.le]
        apply continuousWithinAt_const.congr_of_eventuallyEq this
        simp [hx‚ÇÄ.le]
      ¬∑ have : ‚àÄ·∂† x in ùìù[Icc b‚ÇÅ b‚ÇÇ] b‚ÇÄ, {t : ‚Ñù | t ‚â§ x}.indicator f x‚ÇÄ = 0 := by
          apply mem_nhdsWithin_of_mem_nhds
          apply Eventually.mono (Iio_mem_nhds hx‚ÇÄ)
          intro x hx
          simp [hx]
        apply continuousWithinAt_const.congr_of_eventuallyEq this
        simp [hx‚ÇÄ]
  ¬∑ apply continuousWithinAt_of_not_mem_closure
    rwa [closure_Icc]
#align interval_integral.continuous_within_at_primitive intervalIntegral.continuousWithinAt_primitive

theorem continuousOn_primitive [NoAtoms Œº] (h_int : IntegrableOn f (Icc a b) Œº) :
    ContinuousOn (fun x => ‚à´ t in Ioc a x, f t ‚àÇŒº) (Icc a b) := by
  by_cases h : a ‚â§ b
  ¬∑ have : ‚àÄ x ‚àà Icc a b, ‚à´ t in Ioc a x, f t ‚àÇŒº = ‚à´ t in a..x, f t ‚àÇŒº := by
      intro x x_in
      simp_rw [integral_of_le x_in.1]
    rw [continuousOn_congr this]
    intro x‚ÇÄ _
    refine' continuousWithinAt_primitive (measure_singleton x‚ÇÄ) _
    simp only [intervalIntegrable_iff_integrableOn_Ioc_of_le, min_eq_left, max_eq_right, h,
      min_self]
    exact h_int.mono Ioc_subset_Icc_self le_rfl
  ¬∑ rw [Icc_eq_empty h]
    exact continuousOn_empty _
#align interval_integral.continuous_on_primitive intervalIntegral.continuousOn_primitive

theorem continuousOn_primitive_Icc [NoAtoms Œº] (h_int : IntegrableOn f (Icc a b) Œº) :
    ContinuousOn (fun x => ‚à´ t in Icc a x, f t ‚àÇŒº) (Icc a b) := by
  have aux : (fun x => ‚à´ t in Icc a x, f t ‚àÇŒº) = fun x => ‚à´ t in Ioc a x, f t ‚àÇŒº := by
    ext x
    exact integral_Icc_eq_integral_Ioc
  rw [aux]
  exact continuousOn_primitive h_int
#align interval_integral.continuous_on_primitive_Icc intervalIntegral.continuousOn_primitive_Icc

/-- Note: this assumes that `f` is `IntervalIntegrable`, in contrast to some other lemmas here. -/
theorem continuousOn_primitive_interval' [NoAtoms Œº] (h_int : IntervalIntegrable f Œº b‚ÇÅ b‚ÇÇ)
    (ha : a ‚àà [[b‚ÇÅ, b‚ÇÇ]]) : ContinuousOn (fun b => ‚à´ x in a..b, f x ‚àÇŒº) [[b‚ÇÅ, b‚ÇÇ]] := fun _ _ ‚Ü¶ by
  refine continuousWithinAt_primitive (measure_singleton _) ?_
  rw [min_eq_right ha.1, max_eq_right ha.2]
  simpa [intervalIntegrable_iff, uIoc] using h_int
#align interval_integral.continuous_on_primitive_interval' intervalIntegral.continuousOn_primitive_interval'

theorem continuousOn_primitive_interval [NoAtoms Œº] (h_int : IntegrableOn f (uIcc a b) Œº) :
    ContinuousOn (fun x => ‚à´ t in a..x, f t ‚àÇŒº) (uIcc a b) :=
  continuousOn_primitive_interval' h_int.intervalIntegrable left_mem_uIcc
#align interval_integral.continuous_on_primitive_interval intervalIntegral.continuousOn_primitive_interval

theorem continuousOn_primitive_interval_left [NoAtoms Œº] (h_int : IntegrableOn f (uIcc a b) Œº) :
    ContinuousOn (fun x => ‚à´ t in x..b, f t ‚àÇŒº) (uIcc a b) := by
  rw [uIcc_comm a b] at h_int ‚ä¢
  simp only [integral_symm b]
  exact (continuousOn_primitive_interval h_int).neg
#align interval_integral.continuous_on_primitive_interval_left intervalIntegral.continuousOn_primitive_interval_left

variable [NoAtoms Œº]

theorem continuous_primitive (h_int : ‚àÄ a b, IntervalIntegrable f Œº a b) (a : ‚Ñù) :
    Continuous fun b => ‚à´ x in a..b, f x ‚àÇŒº := by
  rw [continuous_iff_continuousAt]
  intro b‚ÇÄ
  cases' exists_lt b‚ÇÄ with b‚ÇÅ hb‚ÇÅ
  cases' exists_gt b‚ÇÄ with b‚ÇÇ hb‚ÇÇ
  apply ContinuousWithinAt.continuousAt _ (Icc_mem_nhds hb‚ÇÅ hb‚ÇÇ)
  exact continuousWithinAt_primitive (measure_singleton b‚ÇÄ) (h_int _ _)
#align interval_integral.continuous_primitive intervalIntegral.continuous_primitive

nonrec theorem _root_.MeasureTheory.Integrable.continuous_primitive (h_int : Integrable f Œº)
    (a : ‚Ñù) : Continuous fun b => ‚à´ x in a..b, f x ‚àÇŒº :=
  continuous_primitive (fun _ _ => h_int.intervalIntegrable) a
#align measure_theory.integrable.continuous_primitive MeasureTheory.Integrable.continuous_primitive

end ContinuousPrimitive

section

variable {f g : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} {Œº : Measure ‚Ñù}

theorem integral_eq_zero_iff_of_le_of_nonneg_ae (hab : a ‚â§ b) (hf : 0 ‚â§·µê[Œº.restrict (Ioc a b)] f)
    (hfi : IntervalIntegrable f Œº a b) : ‚à´ x in a..b, f x ‚àÇŒº = 0 ‚Üî f =·µê[Œº.restrict (Ioc a b)] 0 :=
  by rw [integral_of_le hab, integral_eq_zero_iff_of_nonneg_ae hf hfi.1]
#align interval_integral.integral_eq_zero_iff_of_le_of_nonneg_ae intervalIntegral.integral_eq_zero_iff_of_le_of_nonneg_ae

theorem integral_eq_zero_iff_of_nonneg_ae (hf : 0 ‚â§·µê[Œº.restrict (Ioc a b ‚à™ Ioc b a)] f)
    (hfi : IntervalIntegrable f Œº a b) :
    ‚à´ x in a..b, f x ‚àÇŒº = 0 ‚Üî f =·µê[Œº.restrict (Ioc a b ‚à™ Ioc b a)] 0 := by
  rcases le_total a b with hab | hab <;>
    simp only [Ioc_eq_empty hab.not_lt, empty_union, union_empty] at hf ‚ä¢
  ¬∑ exact integral_eq_zero_iff_of_le_of_nonneg_ae hab hf hfi
  ¬∑ rw [integral_symm, neg_eq_zero, integral_eq_zero_iff_of_le_of_nonneg_ae hab hf hfi.symm]
#align interval_integral.integral_eq_zero_iff_of_nonneg_ae intervalIntegral.integral_eq_zero_iff_of_nonneg_ae

/-- If `f` is nonnegative and integrable on the unordered interval `Set.uIoc a b`, then its
integral over `a..b` is positive if and only if `a < b` and the measure of
`Function.support f ‚à© Set.Ioc a b` is positive. -/
theorem integral_pos_iff_support_of_nonneg_ae' (hf : 0 ‚â§·µê[Œº.restrict (Œô a b)] f)
    (hfi : IntervalIntegrable f Œº a b) :
    (0 < ‚à´ x in a..b, f x ‚àÇŒº) ‚Üî a < b ‚àß 0 < Œº (support f ‚à© Ioc a b) := by
  cases' lt_or_le a b with hab hba
  ¬∑ rw [uIoc_of_le hab.le] at hf
    simp only [hab, true_and_iff, integral_of_le hab.le,
      set_integral_pos_iff_support_of_nonneg_ae hf hfi.1]
  ¬∑ suffices (‚à´ x in a..b, f x ‚àÇŒº) ‚â§ 0 by simp only [this.not_lt, hba.not_lt, false_and_iff]
    rw [integral_of_ge hba, neg_nonpos]
    rw [uIoc_comm, uIoc_of_le hba] at hf
    exact integral_nonneg_of_ae hf
#align interval_integral.integral_pos_iff_support_of_nonneg_ae' intervalIntegral.integral_pos_iff_support_of_nonneg_ae'

/-- If `f` is nonnegative a.e.-everywhere and it is integrable on the unordered interval
`Set.uIoc a b`, then its integral over `a..b` is positive if and only if `a < b` and the
measure of `Function.support f ‚à© Set.Ioc a b` is positive. -/
theorem integral_pos_iff_support_of_nonneg_ae (hf : 0 ‚â§·µê[Œº] f) (hfi : IntervalIntegrable f Œº a b) :
    (0 < ‚à´ x in a..b, f x ‚àÇŒº) ‚Üî a < b ‚àß 0 < Œº (support f ‚à© Ioc a b) :=
  integral_pos_iff_support_of_nonneg_ae' (ae_mono Measure.restrict_le_self hf) hfi
#align interval_integral.integral_pos_iff_support_of_nonneg_ae intervalIntegral.integral_pos_iff_support_of_nonneg_ae

/-- If `f : ‚Ñù ‚Üí ‚Ñù` is integrable on `(a, b]` for real numbers `a < b`, and positive on the interior
of the interval, then its integral over `a..b` is strictly positive. -/
theorem intervalIntegral_pos_of_pos_on {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} (hfi : IntervalIntegrable f volume a b)
    (hpos : ‚àÄ x : ‚Ñù, x ‚àà Ioo a b ‚Üí 0 < f x) (hab : a < b) : 0 < ‚à´ x : ‚Ñù in a..b, f x := by
  have hsupp : Ioo a b ‚äÜ support f ‚à© Ioc a b := fun x hx =>
    ‚ü®mem_support.mpr (hpos x hx).ne', Ioo_subset_Ioc_self hx‚ü©
  have h‚ÇÄ : 0 ‚â§·µê[volume.restrict (uIoc a b)] f := by
    rw [EventuallyLE, uIoc_of_le hab.le]
    refine' ae_restrict_of_ae_eq_of_ae_restrict Ioo_ae_eq_Ioc _
    exact (ae_restrict_iff' measurableSet_Ioo).mpr (ae_of_all _ fun x hx => (hpos x hx).le)
  rw [integral_pos_iff_support_of_nonneg_ae' h‚ÇÄ hfi]
  exact ‚ü®hab, ((Measure.measure_Ioo_pos _).mpr hab).trans_le (measure_mono hsupp)‚ü©
#align interval_integral.interval_integral_pos_of_pos_on intervalIntegral.intervalIntegral_pos_of_pos_on

/-- If `f : ‚Ñù ‚Üí ‚Ñù` is strictly positive everywhere, and integrable on `(a, b]` for real numbers
`a < b`, then its integral over `a..b` is strictly positive. (See `interval_integral_pos_of_pos_on`
for a version only assuming positivity of `f` on `(a, b)` rather than everywhere.) -/
theorem intervalIntegral_pos_of_pos {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù}
    (hfi : IntervalIntegrable f MeasureSpace.volume a b) (hpos : ‚àÄ x, 0 < f x) (hab : a < b) :
    0 < ‚à´ x in a..b, f x :=
  intervalIntegral_pos_of_pos_on hfi (fun x _ => hpos x) hab
#align interval_integral.interval_integral_pos_of_pos intervalIntegral.intervalIntegral_pos_of_pos

/-- If `f` and `g` are two functions that are interval integrable on `a..b`, `a ‚â§ b`,
`f x ‚â§ g x` for a.e. `x ‚àà Set.Ioc a b`, and `f x < g x` on a subset of `Set.Ioc a b`
of nonzero measure, then `‚à´ x in a..b, f x ‚àÇŒº < ‚à´ x in a..b, g x ‚àÇŒº`. -/
theorem integral_lt_integral_of_ae_le_of_measure_setOf_lt_ne_zero (hab : a ‚â§ b)
    (hfi : IntervalIntegrable f Œº a b) (hgi : IntervalIntegrable g Œº a b)
    (hle : f ‚â§·µê[Œº.restrict (Ioc a b)] g) (hlt : Œº.restrict (Ioc a b) {x | f x < g x} ‚â† 0) :
    (‚à´ x in a..b, f x ‚àÇŒº) < ‚à´ x in a..b, g x ‚àÇŒº := by
  rw [‚Üê sub_pos, ‚Üê integral_sub hgi hfi, integral_of_le hab,
    MeasureTheory.integral_pos_iff_support_of_nonneg_ae]
  ¬∑ refine' pos_iff_ne_zero.2 (mt (measure_mono_null _) hlt)
    exact fun x hx => (sub_pos.2 hx.out).ne'
  exacts [hle.mono fun x => sub_nonneg.2, hgi.1.sub hfi.1]
#align interval_integral.integral_lt_integral_of_ae_le_of_measure_set_of_lt_ne_zero intervalIntegral.integral_lt_integral_of_ae_le_of_measure_setOf_lt_ne_zero

/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x ‚â§ g x` on this interval, and
`f c < g c` at some point `c ‚àà [a, b]`, then `‚à´ x in a..b, f x < ‚à´ x in a..b, g x`. -/
theorem integral_lt_integral_of_continuousOn_of_le_of_exists_lt {f g : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù}
    (hab : a < b) (hfc : ContinuousOn f (Icc a b)) (hgc : ContinuousOn g (Icc a b))
    (hle : ‚àÄ x ‚àà Ioc a b, f x ‚â§ g x) (hlt : ‚àÉ c ‚àà Icc a b, f c < g c) :
    (‚à´ x in a..b, f x) < ‚à´ x in a..b, g x := by
  apply integral_lt_integral_of_ae_le_of_measure_setOf_lt_ne_zero hab.le
    (hfc.intervalIntegrable_of_Icc hab.le) (hgc.intervalIntegrable_of_Icc hab.le)
  ¬∑ simpa only [gt_iff_lt, not_lt, ge_iff_le, measurableSet_Ioc, ae_restrict_eq, le_principal_iff]
      using (ae_restrict_mem measurableSet_Ioc).mono hle
  contrapose! hlt
  have h_eq : f =·µê[volume.restrict (Ioc a b)] g := by
    simp only [‚Üê not_le, ‚Üê ae_iff] at hlt
    exact EventuallyLE.antisymm ((ae_restrict_iff' measurableSet_Ioc).2 <|
      eventually_of_forall hle) hlt
  rw [Measure.restrict_congr_set Ioc_ae_eq_Icc] at h_eq
  exact fun c hc ‚Ü¶ (Measure.eqOn_Icc_of_ae_eq volume hab.ne h_eq hfc hgc hc).ge
#align interval_integral.integral_lt_integral_of_continuous_on_of_le_of_exists_lt intervalIntegral.integral_lt_integral_of_continuousOn_of_le_of_exists_lt

theorem integral_nonneg_of_ae_restrict (hab : a ‚â§ b) (hf : 0 ‚â§·µê[Œº.restrict (Icc a b)] f) :
    0 ‚â§ ‚à´ u in a..b, f u ‚àÇŒº := by
  let H := ae_restrict_of_ae_restrict_of_subset Ioc_subset_Icc_self hf
  simpa only [integral_of_le hab] using set_integral_nonneg_of_ae_restrict H
#align interval_integral.integral_nonneg_of_ae_restrict intervalIntegral.integral_nonneg_of_ae_restrict

theorem integral_nonneg_of_ae (hab : a ‚â§ b) (hf : 0 ‚â§·µê[Œº] f) : 0 ‚â§ ‚à´ u in a..b, f u ‚àÇŒº :=
  integral_nonneg_of_ae_restrict hab <| ae_restrict_of_ae hf
#align interval_integral.integral_nonneg_of_ae intervalIntegral.integral_nonneg_of_ae

theorem integral_nonneg_of_forall (hab : a ‚â§ b) (hf : ‚àÄ u, 0 ‚â§ f u) : 0 ‚â§ ‚à´ u in a..b, f u ‚àÇŒº :=
  integral_nonneg_of_ae hab <| eventually_of_forall hf
#align interval_integral.integral_nonneg_of_forall intervalIntegral.integral_nonneg_of_forall

theorem integral_nonneg (hab : a ‚â§ b) (hf : ‚àÄ u, u ‚àà Icc a b ‚Üí 0 ‚â§ f u) : 0 ‚â§ ‚à´ u in a..b, f u ‚àÇŒº :=
  integral_nonneg_of_ae_restrict hab <| (ae_restrict_iff' measurableSet_Icc).mpr <| ae_of_all Œº hf
#align interval_integral.integral_nonneg intervalIntegral.integral_nonneg

theorem abs_integral_le_integral_abs (hab : a ‚â§ b) :
    |‚à´ x in a..b, f x ‚àÇŒº| ‚â§ ‚à´ x in a..b, |f x| ‚àÇŒº := by
  simpa only [‚Üê Real.norm_eq_abs] using norm_integral_le_integral_norm hab
#align interval_integral.abs_integral_le_integral_abs intervalIntegral.abs_integral_le_integral_abs

section Mono

variable (hab : a ‚â§ b) (hf : IntervalIntegrable f Œº a b) (hg : IntervalIntegrable g Œº a b)

theorem integral_mono_ae_restrict (h : f ‚â§·µê[Œº.restrict (Icc a b)] g) :
    (‚à´ u in a..b, f u ‚àÇŒº) ‚â§ ‚à´ u in a..b, g u ‚àÇŒº := by
  let H := h.filter_mono <| ae_mono <| Measure.restrict_mono Ioc_subset_Icc_self <| le_refl Œº
  simpa only [integral_of_le hab] using set_integral_mono_ae_restrict hf.1 hg.1 H
#align interval_integral.integral_mono_ae_restrict intervalIntegral.integral_mono_ae_restrict

theorem integral_mono_ae (h : f ‚â§·µê[Œº] g) : (‚à´ u in a..b, f u ‚àÇŒº) ‚â§ ‚à´ u in a..b, g u ‚àÇŒº := by
  simpa only [integral_of_le hab] using set_integral_mono_ae hf.1 hg.1 h
#align interval_integral.integral_mono_ae intervalIntegral.integral_mono_ae

theorem integral_mono_on (h : ‚àÄ x ‚àà Icc a b, f x ‚â§ g x) :
    (‚à´ u in a..b, f u ‚àÇŒº) ‚â§ ‚à´ u in a..b, g u ‚àÇŒº := by
  let H x hx := h x <| Ioc_subset_Icc_self hx
  simpa only [integral_of_le hab] using set_integral_mono_on hf.1 hg.1 measurableSet_Ioc H
#align interval_integral.integral_mono_on intervalIntegral.integral_mono_on

theorem integral_mono (h : f ‚â§ g) : (‚à´ u in a..b, f u ‚àÇŒº) ‚â§ ‚à´ u in a..b, g u ‚àÇŒº :=
  integral_mono_ae hab hf hg <| ae_of_all _ h
#align interval_integral.integral_mono intervalIntegral.integral_mono

theorem integral_mono_interval {c d} (hca : c ‚â§ a) (hab : a ‚â§ b) (hbd : b ‚â§ d)
    (hf : 0 ‚â§·µê[Œº.restrict (Ioc c d)] f) (hfi : IntervalIntegrable f Œº c d) :
    (‚à´ x in a..b, f x ‚àÇŒº) ‚â§ ‚à´ x in c..d, f x ‚àÇŒº := by
  rw [integral_of_le hab, integral_of_le (hca.trans (hab.trans hbd))]
  exact set_integral_mono_set hfi.1 hf (Ioc_subset_Ioc hca hbd).eventuallyLE
#align interval_integral.integral_mono_interval intervalIntegral.integral_mono_interval

theorem abs_integral_mono_interval {c d} (h : Œô a b ‚äÜ Œô c d) (hf : 0 ‚â§·µê[Œº.restrict (Œô c d)] f)
    (hfi : IntervalIntegrable f Œº c d) : |‚à´ x in a..b, f x ‚àÇŒº| ‚â§ |‚à´ x in c..d, f x ‚àÇŒº| :=
  have hf' : 0 ‚â§·µê[Œº.restrict (Œô a b)] f := ae_mono (Measure.restrict_mono h le_rfl) hf
  calc
    |‚à´ x in a..b, f x ‚àÇŒº| = |‚à´ x in Œô a b, f x ‚àÇŒº| := abs_integral_eq_abs_integral_uIoc f
    _ = ‚à´ x in Œô a b, f x ‚àÇŒº := (abs_of_nonneg (MeasureTheory.integral_nonneg_of_ae hf'))
    _ ‚â§ ‚à´ x in Œô c d, f x ‚àÇŒº := (set_integral_mono_set hfi.def hf h.eventuallyLE)
    _ ‚â§ |‚à´ x in Œô c d, f x ‚àÇŒº| := (le_abs_self _)
    _ = |‚à´ x in c..d, f x ‚àÇŒº| := (abs_integral_eq_abs_integral_uIoc f).symm
#align interval_integral.abs_integral_mono_interval intervalIntegral.abs_integral_mono_interval

end Mono

end

section HasSum

variable {Œº : Measure ‚Ñù} {f : ‚Ñù ‚Üí E}

theorem _root_.MeasureTheory.Integrable.hasSum_intervalIntegral (hfi : Integrable f Œº) (y : ‚Ñù) :
    HasSum (fun n : ‚Ñ§ => ‚à´ x in y + n..y + n + 1, f x ‚àÇŒº) (‚à´ x, f x ‚àÇŒº) := by
  simp_rw [integral_of_le (le_add_of_nonneg_right zero_le_one)]
  rw [‚Üê integral_univ, ‚Üê iUnion_Ioc_add_int_cast y]
  exact
    hasSum_integral_iUnion (fun i => measurableSet_Ioc) (pairwise_disjoint_Ioc_add_int_cast y)
      hfi.integrableOn
#align measure_theory.integrable.has_sum_interval_integral MeasureTheory.Integrable.hasSum_intervalIntegral

theorem _root_.MeasureTheory.Integrable.hasSum_intervalIntegral_comp_add_int (hfi : Integrable f) :
    HasSum (fun n : ‚Ñ§ => ‚à´ x in (0:‚Ñù)..(1:‚Ñù), f (x + n)) (‚à´ x, f x) := by
  simpa only [integral_comp_add_right, zero_add, add_comm (1:‚Ñù)] using hfi.hasSum_intervalIntegral 0
#align measure_theory.integrable.has_sum_interval_integral_comp_add_int MeasureTheory.Integrable.hasSum_intervalIntegral_comp_add_int

end HasSum

end intervalIntegral
