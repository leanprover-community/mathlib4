/-
Copyright (c) 2023 Kalle Kyt√∂l√§. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kalle Kyt√∂l√§
-/
import Mathlib.MeasureTheory.Integral.Bochner.Basic
import Mathlib.Topology.ContinuousMap.Bounded.Normed
import Mathlib.Topology.Algebra.Order.LiminfLimsup
import Mathlib.Analysis.InnerProductSpace.Basic
import Mathlib.MeasureTheory.Integral.Bochner.ContinuousLinearMap


/-!
# Integration of bounded continuous functions

In this file, some results are collected about integrals of bounded continuous functions. They are
mostly specializations of results in general integration theory, but they are used directly in this
specialized form in some other files, in particular in those related to the topology of weak
convergence of probability measures and finite measures.
-/

open MeasureTheory Filter
open scoped ENNReal NNReal BoundedContinuousFunction Topology

namespace BoundedContinuousFunction

section NNRealValued

lemma apply_le_nndist_zero {X : Type*} [TopologicalSpace X] (f : X ‚Üí·µá ‚Ñù‚â•0) (x : X) :
    f x ‚â§ nndist 0 f := by
  convert nndist_coe_le_nndist x
  simp only [coe_zero, Pi.zero_apply, NNReal.nndist_zero_eq_val]

variable {X : Type*} [MeasurableSpace X] [TopologicalSpace X]

lemma lintegral_le_edist_mul (f : X ‚Üí·µá ‚Ñù‚â•0) (Œº : Measure X) :
    (‚à´‚Åª x, f x ‚àÇŒº) ‚â§ edist 0 f * (Œº Set.univ) :=
  le_trans (lintegral_mono (fun x ‚Ü¶ ENNReal.coe_le_coe.mpr (f.apply_le_nndist_zero x))) (by simp)

theorem measurable_coe_ennreal_comp [OpensMeasurableSpace X] (f : X ‚Üí·µá ‚Ñù‚â•0) :
    Measurable fun x ‚Ü¶ (f x : ‚Ñù‚â•0‚àû) :=
  measurable_coe_nnreal_ennreal.comp f.continuous.measurable

variable (Œº : Measure X) [IsFiniteMeasure Œº]

theorem lintegral_lt_top_of_nnreal (f : X ‚Üí·µá ‚Ñù‚â•0) : ‚à´‚Åª x, f x ‚àÇŒº < ‚àû := by
  apply IsFiniteMeasure.lintegral_lt_top_of_bounded_to_ennreal
  refine ‚ü®nndist f 0, fun x ‚Ü¶ ?_‚ü©
  have key := BoundedContinuousFunction.NNReal.upper_bound f x
  rwa [ENNReal.coe_le_coe]

theorem integrable_of_nnreal [OpensMeasurableSpace X] (f : X ‚Üí·µá ‚Ñù‚â•0) :
    Integrable (((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù) ‚àò ‚áëf) Œº := by
  refine ‚ü®(NNReal.continuous_coe.comp f.continuous).measurable.aestronglyMeasurable, ?_‚ü©
  simp only [hasFiniteIntegral_iff_enorm, Function.comp_apply, NNReal.enorm_eq]
  exact lintegral_lt_top_of_nnreal _ f

theorem integral_eq_integral_nnrealPart_sub [OpensMeasurableSpace X] (f : X ‚Üí·µá ‚Ñù) :
    ‚à´ x, f x ‚àÇŒº = (‚à´ x, (f.nnrealPart x : ‚Ñù) ‚àÇŒº) - ‚à´ x, ((-f).nnrealPart x : ‚Ñù) ‚àÇŒº := by
  simp only [f.self_eq_nnrealPart_sub_nnrealPart_neg, Pi.sub_apply, integral_sub,
             integrable_of_nnreal]
  simp only [Function.comp_apply]

theorem lintegral_of_real_lt_top (f : X ‚Üí·µá ‚Ñù) :
    ‚à´‚Åª x, ENNReal.ofReal (f x) ‚àÇŒº < ‚àû := lintegral_lt_top_of_nnreal _ f.nnrealPart

theorem toReal_lintegral_coe_eq_integral [OpensMeasurableSpace X] (f : X ‚Üí·µá ‚Ñù‚â•0) (Œº : Measure X) :
    (‚à´‚Åª x, (f x : ‚Ñù‚â•0‚àû) ‚àÇŒº).toReal = ‚à´ x, (f x : ‚Ñù) ‚àÇŒº := by
  rw [integral_eq_lintegral_of_nonneg_ae _ (by simpa [Function.comp_apply] using
        (NNReal.continuous_coe.comp f.continuous).measurable.aestronglyMeasurable)]
  ¬∑ simp only [ENNReal.ofReal_coe_nnreal]
  ¬∑ exact Eventually.of_forall (by simp only [Pi.zero_apply, NNReal.zero_le_coe, imp_true_iff])

end NNRealValued

section BochnerIntegral

variable {X : Type*} [MeasurableSpace X] [TopologicalSpace X]
variable (Œº : Measure X)
variable {E : Type*} [NormedAddCommGroup E]

lemma lintegral_nnnorm_le (f : X ‚Üí·µá E) :
    ‚à´‚Åª x, ‚Äñf x‚Äñ‚Çä ‚àÇŒº ‚â§ ‚Äñf‚Äñ‚Çä * (Œº Set.univ) := by
  calc  ‚à´‚Åª x, ‚Äñf x‚Äñ‚Çä ‚àÇŒº
    _ ‚â§ ‚à´‚Åª _, ‚Äñf‚Äñ‚Çä ‚àÇŒº         := by gcongr; apply nnnorm_coe_le_nnnorm
    _ = ‚Äñf‚Äñ‚Çä * (Œº Set.univ)   := by rw [lintegral_const]

variable [OpensMeasurableSpace X] [SecondCountableTopology E] [MeasurableSpace E] [BorelSpace E]

lemma integrable [IsFiniteMeasure Œº] (f : X ‚Üí·µá E) :
    Integrable f Œº := by
  refine ‚ü®f.continuous.measurable.aestronglyMeasurable, (hasFiniteIntegral_def _ _).mp ?_‚ü©
  calc  ‚à´‚Åª x, ‚Äñf x‚Äñ‚Çä ‚àÇŒº
    _ ‚â§ ‚Äñf‚Äñ‚Çä * (Œº Set.univ)   := f.lintegral_nnnorm_le Œº
    _ < ‚àû                     := ENNReal.mul_lt_top ENNReal.coe_lt_top (measure_lt_top Œº Set.univ)

variable [NormedSpace ‚Ñù E]

lemma norm_integral_le_mul_norm [IsFiniteMeasure Œº] (f : X ‚Üí·µá E) :
    ‚Äñ‚à´ x, f x ‚àÇŒº‚Äñ ‚â§ Œº.real Set.univ * ‚Äñf‚Äñ := by
  calc  ‚Äñ‚à´ x, f x ‚àÇŒº‚Äñ
    _ ‚â§ ‚à´ x, ‚Äñf x‚Äñ ‚àÇŒº := norm_integral_le_integral_norm _
    _ ‚â§ ‚à´ _, ‚Äñf‚Äñ ‚àÇŒº := ?_
    _ = Œº.real Set.univ ‚Ä¢ ‚Äñf‚Äñ := by rw [integral_const]
  apply integral_mono _ (integrable_const ‚Äñf‚Äñ) (fun x ‚Ü¶ f.norm_coe_le_norm x) -- NOTE: `gcongr`?
  exact (integrable_norm_iff f.continuous.measurable.aestronglyMeasurable).mpr (f.integrable Œº)

lemma norm_integral_le_norm [IsProbabilityMeasure Œº] (f : X ‚Üí·µá E) :
    ‚Äñ‚à´ x, f x ‚àÇŒº‚Äñ ‚â§ ‚Äñf‚Äñ := by
  convert f.norm_integral_le_mul_norm Œº
  simp

lemma isBounded_range_integral
    {Œπ : Type*} (Œºs : Œπ ‚Üí Measure X) [‚àÄ i, IsProbabilityMeasure (Œºs i)] (f : X ‚Üí·µá E) :
    Bornology.IsBounded (Set.range (fun i ‚Ü¶ ‚à´ x, f x ‚àÇ (Œºs i))) := by
  apply isBounded_iff_forall_norm_le.mpr ‚ü®‚Äñf‚Äñ, fun v hv ‚Ü¶ ?_‚ü©
  obtain ‚ü®i, hi‚ü© := hv
  rw [‚Üê hi]
  apply f.norm_integral_le_norm (Œºs i)

variable {ùïú : Type*} [NormedField ùïú] [Module ùïú E] [NormSMulClass ùïú E]
variable [LocallyCompactSpace X] [T2Space X] [SecondCountableTopology X]

open TopologicalSpace LocallyIntegrableOn

omit [SecondCountableTopology E] [MeasurableSpace E] [BorelSpace E] [NormedSpace ‚Ñù E] in
theorem integrable_smul_LocallyIntegrable {f : X ‚Üí E} (hf : LocallyIntegrable f Œº)
  (K : Compacts X) (œÜ : X ‚Üí·µá ùïú) :
    Integrable (fun x ‚Ü¶ (œÜ x) ‚Ä¢ (f x)) (Œº.restrict K) := by
  refine integrableOn_isCompact ?_ K.isCompact
  exact LocallyIntegrableOn.continuousOn_smul K.isCompact.isClosed.isLocallyClosed
    (hf.locallyIntegrableOn K) œÜ.continuous.continuousOn

variable [SMulCommClass ‚Ñù ùïú E]

variable (ùïú) {Œº}
noncomputable def testAgainstLocallyIntegrable‚Çó {f : X ‚Üí E} (hf : LocallyIntegrable f Œº)
  (K : Compacts X) :
    (X ‚Üí·µá ùïú) ‚Üí‚Çó[ùïú] E where
  toFun := fun œÜ : (X ‚Üí·µá ùïú) ‚Ü¶ ‚à´ (x : X), œÜ x ‚Ä¢ f x ‚àÇ(Œº.restrict K)
  map_add' := by
    intro œÜ Œ¶
    simp_rw [add_apply, add_smul, integral_add (integrable_smul_LocallyIntegrable Œº hf K œÜ)
      (integrable_smul_LocallyIntegrable Œº hf K Œ¶)]
  map_smul' := by
    intro c œÜ
    simp_rw [coe_smul, RingHom.id_apply, ‚Üê integral_smul c (fun (x : X) ‚Ü¶  œÜ x ‚Ä¢ f x), smul_assoc]

noncomputable def testAgainstLocallyIntegrableCLM {f : X ‚Üí E} (hf : LocallyIntegrable f Œº)
  (K : Compacts X) :
    (X ‚Üí·µá ùïú) ‚ÜíL[ùïú] E :=
  (testAgainstLocallyIntegrable‚Çó ùïú hf K).mkContinuous (‚à´ x, ‚Äñf x‚Äñ ‚àÇ(Œº.restrict K))
  (by
    intro œÜ
    have hf' : Integrable f (Œº.restrict K) :=
      integrableOn_isCompact (hf.locallyIntegrableOn K) K.isCompact
    set g := fun x ‚Ü¶ ‚ÄñœÜ‚Äñ * ‚Äñf x‚Äñ with g_def
    have hg : Integrable g (Œº.restrict K) := (Integrable.norm hf').const_mul _
    have h : ‚àÄ·µê (x : X) ‚àÇ(Œº.restrict K), ‚Äñ(fun a ‚Ü¶ (œÜ a) ‚Ä¢ f a) x‚Äñ ‚â§ g x := by
      apply ae_of_all
      intro x
      simp only [g, norm_smul]
      bound [œÜ.norm_coe_le_norm x]
    apply le_trans (norm_integral_le_of_norm_le hg h)
    rw [mul_comm, integral_const_mul_of_integrable hf'.norm]
  )


end BochnerIntegral

section RealValued

variable {X : Type*} [TopologicalSpace X]
variable [MeasurableSpace X] [OpensMeasurableSpace X] {Œº : Measure X} [IsFiniteMeasure Œº]

lemma integral_add_const (f : X ‚Üí·µá ‚Ñù) (c : ‚Ñù) :
    ‚à´ x, (f + const X c) x ‚àÇŒº = ‚à´ x, f x ‚àÇŒº + Œº.real Set.univ ‚Ä¢ c := by
  simp [integral_add (f.integrable _) (integrable_const c)]

lemma integral_const_sub (f : X ‚Üí·µá ‚Ñù) (c : ‚Ñù) :
    ‚à´ x, (const X c - f) x ‚àÇŒº = Œº.real Set.univ ‚Ä¢ c - ‚à´ x, f x ‚àÇŒº := by
  simp [integral_sub (integrable_const c) (f.integrable _)]

end RealValued

section tendsto_integral

variable {X : Type*} [TopologicalSpace X] [MeasurableSpace X] [OpensMeasurableSpace X]

lemma tendsto_integral_of_forall_limsup_integral_le_integral {Œπ : Type*} {L : Filter Œπ}
    {Œº : Measure X} [IsProbabilityMeasure Œº] {Œºs : Œπ ‚Üí Measure X} [‚àÄ i, IsProbabilityMeasure (Œºs i)]
    (h : ‚àÄ f : X ‚Üí·µá ‚Ñù, 0 ‚â§ f ‚Üí L.limsup (fun i ‚Ü¶ ‚à´ x, f x ‚àÇ (Œºs i)) ‚â§ ‚à´ x, f x ‚àÇŒº)
    (f : X ‚Üí·µá ‚Ñù) :
    Tendsto (fun i ‚Ü¶ ‚à´ x, f x ‚àÇ (Œºs i)) L (ùìù (‚à´ x, f x ‚àÇŒº)) := by
  rcases eq_or_neBot L with rfl | hL
  ¬∑ simp only [tendsto_bot]
  have obs := BoundedContinuousFunction.isBounded_range_integral Œºs f
  have bdd_above := BddAbove.isBoundedUnder L.univ_mem (by simpa using obs.bddAbove)
  have bdd_below := BddBelow.isBoundedUnder L.univ_mem (by simpa using obs.bddBelow)
  apply tendsto_of_le_liminf_of_limsup_le _ _ bdd_above bdd_below
  ¬∑ have key := h _ (f.norm_sub_nonneg)
    simp_rw [f.integral_const_sub ‚Äñf‚Äñ] at key
    simp only [measureReal_univ_eq_one, smul_eq_mul, one_mul] at key
    have := limsup_const_sub L (fun i ‚Ü¶ ‚à´ x, f x ‚àÇ (Œºs i)) ‚Äñf‚Äñ bdd_above.isCobounded_ge bdd_below
    rwa [this, _root_.sub_le_sub_iff_left ‚Äñf‚Äñ] at key
  ¬∑ have key := h _ (f.add_norm_nonneg)
    simp_rw [f.integral_add_const ‚Äñf‚Äñ] at key
    simp only [measureReal_univ_eq_one, smul_eq_mul, one_mul] at key
    have := limsup_add_const L (fun i ‚Ü¶ ‚à´ x, f x ‚àÇ (Œºs i)) ‚Äñf‚Äñ bdd_above bdd_below.isCobounded_le
    rwa [this, add_le_add_iff_right] at key

lemma tendsto_integral_of_forall_integral_le_liminf_integral {Œπ : Type*} {L : Filter Œπ}
    {Œº : Measure X} [IsProbabilityMeasure Œº] {Œºs : Œπ ‚Üí Measure X} [‚àÄ i, IsProbabilityMeasure (Œºs i)]
    (h : ‚àÄ f : X ‚Üí·µá ‚Ñù, 0 ‚â§ f ‚Üí ‚à´ x, f x ‚àÇŒº ‚â§ L.liminf (fun i ‚Ü¶ ‚à´ x, f x ‚àÇ (Œºs i)))
    (f : X ‚Üí·µá ‚Ñù) :
    Tendsto (fun i ‚Ü¶ ‚à´ x, f x ‚àÇ (Œºs i)) L (ùìù (‚à´ x, f x ‚àÇŒº)) := by
  rcases eq_or_neBot L with rfl | hL
  ¬∑ simp only [tendsto_bot]
  have obs := BoundedContinuousFunction.isBounded_range_integral Œºs f
  have bdd_above := BddAbove.isBoundedUnder L.univ_mem (by simpa using obs.bddAbove)
  have bdd_below := BddBelow.isBoundedUnder L.univ_mem (by simpa using obs.bddBelow)
  apply @tendsto_of_le_liminf_of_limsup_le ‚Ñù Œπ _ _ _ L (fun i ‚Ü¶ ‚à´ x, f x ‚àÇ (Œºs i)) (‚à´ x, f x ‚àÇŒº)
  ¬∑ have key := h _ (f.add_norm_nonneg)
    simp_rw [f.integral_add_const ‚Äñf‚Äñ] at key
    simp only [measureReal_univ_eq_one, smul_eq_mul, one_mul] at key
    have := liminf_add_const L (fun i ‚Ü¶ ‚à´ x, f x ‚àÇ (Œºs i)) ‚Äñf‚Äñ bdd_above.isCobounded_ge bdd_below
    rwa [this, add_le_add_iff_right] at key
  ¬∑ have key := h _ (f.norm_sub_nonneg)
    simp_rw [f.integral_const_sub ‚Äñf‚Äñ] at key
    simp only [measureReal_univ_eq_one, smul_eq_mul, one_mul] at key
    have := liminf_const_sub L (fun i ‚Ü¶ ‚à´ x, f x ‚àÇ (Œºs i)) ‚Äñf‚Äñ bdd_above bdd_below.isCobounded_le
    rwa [this, sub_le_sub_iff_left] at key
  ¬∑ exact bdd_above
  ¬∑ exact bdd_below

end tendsto_integral --section

end BoundedContinuousFunction
