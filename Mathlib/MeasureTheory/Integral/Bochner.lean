/-
Copyright (c) 2019 Zhouhang Zhou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zhouhang Zhou, Yury Kudryashov, S√©bastien Gou√´zel, R√©my Degenne
-/
import Mathlib.MeasureTheory.Integral.SetToL1

#align_import measure_theory.integral.bochner from "leanprover-community/mathlib"@"48fb5b5280e7c81672afc9524185ae994553ebf4"

/-!
# Bochner integral

The Bochner integral extends the definition of the Lebesgue integral to functions that map from a
measure space into a Banach space (complete normed vector space). It is constructed here by
extending the integral on simple functions.

## Main definitions

The Bochner integral is defined through the extension process described in the file `SetToL1`,
which follows these steps:

1. Define the integral of the indicator of a set. This is `weightedSMul Œº s x = (Œº s).toReal * x`.
  `weightedSMul Œº` is shown to be linear in the value `x` and `DominatedFinMeasAdditive`
  (defined in the file `SetToL1`) with respect to the set `s`.

2. Define the integral on simple functions of the type `SimpleFunc Œ± E` (notation : `Œ± ‚Üí‚Çõ E`)
  where `E` is a real normed space. (See `SimpleFunc.integral` for details.)

3. Transfer this definition to define the integral on `L1.simpleFunc Œ± E` (notation :
  `Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E`), see `L1.simpleFunc.integral`. Show that this integral is a continuous linear
  map from `Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E` to `E`.

4. Define the Bochner integral on L1 functions by extending the integral on integrable simple
  functions `Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E` using `ContinuousLinearMap.extend` and the fact that the embedding of
  `Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E` into `Œ± ‚Üí‚ÇÅ[Œº] E` is dense.

5. Define the Bochner integral on functions as the Bochner integral of its equivalence class in L1
  space, if it is in L1, and 0 otherwise.

The result of that construction is `‚à´ a, f a ‚àÇŒº`, which is definitionally equal to
`setToFun (dominatedFinMeasAdditive_weightedSMul Œº) f`. Some basic properties of the integral
(like linearity) are particular cases of the properties of `setToFun` (which are described in the
file `SetToL1`).

## Main statements

1. Basic properties of the Bochner integral on functions of type `Œ± ‚Üí E`, where `Œ±` is a measure
   space and `E` is a real normed space.

  * `integral_zero`                  : `‚à´ 0 ‚àÇŒº = 0`
  * `integral_add`                   : `‚à´ x, f x + g x ‚àÇŒº = ‚à´ x, f ‚àÇŒº + ‚à´ x, g x ‚àÇŒº`
  * `integral_neg`                   : `‚à´ x, - f x ‚àÇŒº = - ‚à´ x, f x ‚àÇŒº`
  * `integral_sub`                   : `‚à´ x, f x - g x ‚àÇŒº = ‚à´ x, f x ‚àÇŒº - ‚à´ x, g x ‚àÇŒº`
  * `integral_smul`                  : `‚à´ x, r ‚Ä¢ f x ‚àÇŒº = r ‚Ä¢ ‚à´ x, f x ‚àÇŒº`
  * `integral_congr_ae`              : `f =·µê[Œº] g ‚Üí ‚à´ x, f x ‚àÇŒº = ‚à´ x, g x ‚àÇŒº`
  * `norm_integral_le_integral_norm` : `‚Äñ‚à´ x, f x ‚àÇŒº‚Äñ ‚â§ ‚à´ x, ‚Äñf x‚Äñ ‚àÇŒº`

2. Basic properties of the Bochner integral on functions of type `Œ± ‚Üí ‚Ñù`, where `Œ±` is a measure
  space.

  * `integral_nonneg_of_ae` : `0 ‚â§·µê[Œº] f ‚Üí 0 ‚â§ ‚à´ x, f x ‚àÇŒº`
  * `integral_nonpos_of_ae` : `f ‚â§·µê[Œº] 0 ‚Üí ‚à´ x, f x ‚àÇŒº ‚â§ 0`
  * `integral_mono_ae`      : `f ‚â§·µê[Œº] g ‚Üí ‚à´ x, f x ‚àÇŒº ‚â§ ‚à´ x, g x ‚àÇŒº`
  * `integral_nonneg`       : `0 ‚â§ f ‚Üí 0 ‚â§ ‚à´ x, f x ‚àÇŒº`
  * `integral_nonpos`       : `f ‚â§ 0 ‚Üí ‚à´ x, f x ‚àÇŒº ‚â§ 0`
  * `integral_mono`         : `f ‚â§·µê[Œº] g ‚Üí ‚à´ x, f x ‚àÇŒº ‚â§ ‚à´ x, g x ‚àÇŒº`

3. Propositions connecting the Bochner integral with the integral on `‚Ñù‚â•0‚àû`-valued functions,
   which is called `lintegral` and has the notation `‚à´‚Åª`.

  * `integral_eq_lintegral_pos_part_sub_lintegral_neg_part` :
    `‚à´ x, f x ‚àÇŒº = ‚à´‚Åª x, f‚Å∫ x ‚àÇŒº - ‚à´‚Åª x, f‚Åª x ‚àÇŒº`,
    where `f‚Å∫` is the positive part of `f` and `f‚Åª` is the negative part of `f`.
  * `integral_eq_lintegral_of_nonneg_ae`          : `0 ‚â§·µê[Œº] f ‚Üí ‚à´ x, f x ‚àÇŒº = ‚à´‚Åª x, f x ‚àÇŒº`

4. `tendsto_integral_of_dominated_convergence` : the Lebesgue dominated convergence theorem

5. (In the file `SetIntegral`) integration commutes with continuous linear maps.

  * `ContinuousLinearMap.integral_comp_comm`
  * `LinearIsometry.integral_comp_comm`


## Notes

Some tips on how to prove a proposition if the API for the Bochner integral is not enough so that
you need to unfold the definition of the Bochner integral and go back to simple functions.

One method is to use the theorem `Integrable.induction` in the file `SimpleFuncDenseLp` (or one
of the related results, like `Lp.induction` for functions in `Lp`), which allows you to prove
something for an arbitrary integrable function.

Another method is using the following steps.
See `integral_eq_lintegral_pos_part_sub_lintegral_neg_part` for a complicated example, which proves
that `‚à´ f = ‚à´‚Åª f‚Å∫ - ‚à´‚Åª f‚Åª`, with the first integral sign being the Bochner integral of a real-valued
function `f : Œ± ‚Üí ‚Ñù`, and second and third integral sign being the integral on `‚Ñù‚â•0‚àû`-valued
functions (called `lintegral`). The proof of `integral_eq_lintegral_pos_part_sub_lintegral_neg_part`
is scattered in sections with the name `posPart`.

Here are the usual steps of proving that a property `p`, say `‚à´ f = ‚à´‚Åª f‚Å∫ - ‚à´‚Åª f‚Åª`, holds for all
functions :

1. First go to the `L¬π` space.

   For example, if you see `ENNReal.toReal (‚à´‚Åª a, ENNReal.ofReal $ ‚Äñf a‚Äñ)`, that is the norm of
   `f` in `L¬π` space. Rewrite using `L1.norm_of_fun_eq_lintegral_norm`.

2. Show that the set `{f ‚àà L¬π | ‚à´ f = ‚à´‚Åª f‚Å∫ - ‚à´‚Åª f‚Åª}` is closed in `L¬π` using `isClosed_eq`.

3. Show that the property holds for all simple functions `s` in `L¬π` space.

   Typically, you need to convert various notions to their `SimpleFunc` counterpart, using lemmas
   like `L1.integral_coe_eq_integral`.

4. Since simple functions are dense in `L¬π`,
```
univ = closure {s simple}
     = closure {s simple | ‚à´ s = ‚à´‚Åª s‚Å∫ - ‚à´‚Åª s‚Åª} : the property holds for all simple functions
     ‚äÜ closure {f | ‚à´ f = ‚à´‚Åª f‚Å∫ - ‚à´‚Åª f‚Åª}
     = {f | ‚à´ f = ‚à´‚Åª f‚Å∫ - ‚à´‚Åª f‚Åª} : closure of a closed set is itself
```
Use `isClosed_property` or `DenseRange.induction_on` for this argument.

## Notations

* `Œ± ‚Üí‚Çõ E`  : simple functions (defined in `MeasureTheory/Integration`)
* `Œ± ‚Üí‚ÇÅ[Œº] E` : functions in L1 space, i.e., equivalence classes of integrable functions (defined in
                `MeasureTheory/LpSpace`)
* `Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E` : simple functions in L1 space, i.e., equivalence classes of integrable simple
                 functions (defined in `MeasureTheory/SimpleFuncDense`)
* `‚à´ a, f a ‚àÇŒº` : integral of `f` with respect to a measure `Œº`
* `‚à´ a, f a` : integral of `f` with respect to `volume`, the default measure on the ambient type

We also define notations for integral on a set, which are described in the file
`MeasureTheory/SetIntegral`.

Note : `‚Çõ` is typed using `\_s`. Sometimes it shows as a box if the font is missing.

## Tags

Bochner integral, simple function, function space, Lebesgue dominated convergence theorem

-/


assert_not_exists Differentiable

noncomputable section

open scoped Topology BigOperators NNReal ENNReal MeasureTheory

open Set Filter TopologicalSpace ENNReal EMetric

namespace MeasureTheory

variable {Œ± E F ùïú : Type*}

section WeightedSmul

open ContinuousLinearMap

variable [NormedAddCommGroup F] [NormedSpace ‚Ñù F] {m : MeasurableSpace Œ±} {Œº : Measure Œ±}

/-- Given a set `s`, return the continuous linear map `fun x => (Œº s).toReal ‚Ä¢ x`. The extension
of that set function through `setToL1` gives the Bochner integral of L1 functions. -/
def weightedSMul {_ : MeasurableSpace Œ±} (Œº : Measure Œ±) (s : Set Œ±) : F ‚ÜíL[‚Ñù] F :=
  (Œº s).toReal ‚Ä¢ ContinuousLinearMap.id ‚Ñù F
#align measure_theory.weighted_smul MeasureTheory.weightedSMul

theorem weightedSMul_apply {m : MeasurableSpace Œ±} (Œº : Measure Œ±) (s : Set Œ±) (x : F) :
    weightedSMul Œº s x = (Œº s).toReal ‚Ä¢ x := by simp [weightedSMul]
#align measure_theory.weighted_smul_apply MeasureTheory.weightedSMul_apply

@[simp]
theorem weightedSMul_zero_measure {m : MeasurableSpace Œ±} :
    weightedSMul (0 : Measure Œ±) = (0 : Set Œ± ‚Üí F ‚ÜíL[‚Ñù] F) := by ext1; simp [weightedSMul]
#align measure_theory.weighted_smul_zero_measure MeasureTheory.weightedSMul_zero_measure

@[simp]
theorem weightedSMul_empty {m : MeasurableSpace Œ±} (Œº : Measure Œ±) :
    weightedSMul Œº ‚àÖ = (0 : F ‚ÜíL[‚Ñù] F) := by ext1 x; rw [weightedSMul_apply]; simp
#align measure_theory.weighted_smul_empty MeasureTheory.weightedSMul_empty

theorem weightedSMul_add_measure {m : MeasurableSpace Œ±} (Œº ŒΩ : Measure Œ±) {s : Set Œ±}
    (hŒºs : Œº s ‚â† ‚àû) (hŒΩs : ŒΩ s ‚â† ‚àû) :
    (weightedSMul (Œº + ŒΩ) s : F ‚ÜíL[‚Ñù] F) = weightedSMul Œº s + weightedSMul ŒΩ s := by
  ext1 x
  push_cast
  simp_rw [Pi.add_apply, weightedSMul_apply]
  push_cast
  rw [Pi.add_apply, ENNReal.toReal_add hŒºs hŒΩs, add_smul]
#align measure_theory.weighted_smul_add_measure MeasureTheory.weightedSMul_add_measure

theorem weightedSMul_smul_measure {m : MeasurableSpace Œ±} (Œº : Measure Œ±) (c : ‚Ñù‚â•0‚àû) {s : Set Œ±} :
    (weightedSMul (c ‚Ä¢ Œº) s : F ‚ÜíL[‚Ñù] F) = c.toReal ‚Ä¢ weightedSMul Œº s := by
  ext1 x
  push_cast
  simp_rw [Pi.smul_apply, weightedSMul_apply]
  push_cast
  simp_rw [Pi.smul_apply, smul_eq_mul, toReal_mul, smul_smul]
#align measure_theory.weighted_smul_smul_measure MeasureTheory.weightedSMul_smul_measure

theorem weightedSMul_congr (s t : Set Œ±) (hst : Œº s = Œº t) :
    (weightedSMul Œº s : F ‚ÜíL[‚Ñù] F) = weightedSMul Œº t := by
  ext1 x; simp_rw [weightedSMul_apply]; congr 2
#align measure_theory.weighted_smul_congr MeasureTheory.weightedSMul_congr

theorem weightedSMul_null {s : Set Œ±} (h_zero : Œº s = 0) : (weightedSMul Œº s : F ‚ÜíL[‚Ñù] F) = 0 := by
  ext1 x; rw [weightedSMul_apply, h_zero]; simp
#align measure_theory.weighted_smul_null MeasureTheory.weightedSMul_null

theorem weightedSMul_union' (s t : Set Œ±) (ht : MeasurableSet t) (hs_finite : Œº s ‚â† ‚àû)
    (ht_finite : Œº t ‚â† ‚àû) (h_inter : s ‚à© t = ‚àÖ) :
    (weightedSMul Œº (s ‚à™ t) : F ‚ÜíL[‚Ñù] F) = weightedSMul Œº s + weightedSMul Œº t := by
  ext1 x
  simp_rw [add_apply, weightedSMul_apply,
    measure_union (Set.disjoint_iff_inter_eq_empty.mpr h_inter) ht,
    ENNReal.toReal_add hs_finite ht_finite, add_smul]
#align measure_theory.weighted_smul_union' MeasureTheory.weightedSMul_union'

@[nolint unusedArguments]
theorem weightedSMul_union (s t : Set Œ±) (_hs : MeasurableSet s) (ht : MeasurableSet t)
    (hs_finite : Œº s ‚â† ‚àû) (ht_finite : Œº t ‚â† ‚àû) (h_inter : s ‚à© t = ‚àÖ) :
    (weightedSMul Œº (s ‚à™ t) : F ‚ÜíL[‚Ñù] F) = weightedSMul Œº s + weightedSMul Œº t :=
  weightedSMul_union' s t ht hs_finite ht_finite h_inter
#align measure_theory.weighted_smul_union MeasureTheory.weightedSMul_union

theorem weightedSMul_smul [NormedField ùïú] [NormedSpace ùïú F] [SMulCommClass ‚Ñù ùïú F] (c : ùïú)
    (s : Set Œ±) (x : F) : weightedSMul Œº s (c ‚Ä¢ x) = c ‚Ä¢ weightedSMul Œº s x := by
  simp_rw [weightedSMul_apply, smul_comm]
#align measure_theory.weighted_smul_smul MeasureTheory.weightedSMul_smul

theorem norm_weightedSMul_le (s : Set Œ±) : ‚Äñ(weightedSMul Œº s : F ‚ÜíL[‚Ñù] F)‚Äñ ‚â§ (Œº s).toReal :=
  calc
    ‚Äñ(weightedSMul Œº s : F ‚ÜíL[‚Ñù] F)‚Äñ = ‚Äñ(Œº s).toReal‚Äñ * ‚ÄñContinuousLinearMap.id ‚Ñù F‚Äñ :=
      norm_smul _ _
    _ ‚â§ ‚Äñ(Œº s).toReal‚Äñ :=
      ((mul_le_mul_of_nonneg_left norm_id_le (norm_nonneg _)).trans (mul_one _).le)
    _ = abs (Œº s).toReal := Real.norm_eq_abs _
    _ = (Œº s).toReal := abs_eq_self.mpr ENNReal.toReal_nonneg
#align measure_theory.norm_weighted_smul_le MeasureTheory.norm_weightedSMul_le

theorem dominatedFinMeasAdditive_weightedSMul {_ : MeasurableSpace Œ±} (Œº : Measure Œ±) :
    DominatedFinMeasAdditive Œº (weightedSMul Œº : Set Œ± ‚Üí F ‚ÜíL[‚Ñù] F) 1 :=
  ‚ü®weightedSMul_union, fun s _ _ => (norm_weightedSMul_le s).trans (one_mul _).symm.le‚ü©
#align measure_theory.dominated_fin_meas_additive_weighted_smul MeasureTheory.dominatedFinMeasAdditive_weightedSMul

theorem weightedSMul_nonneg (s : Set Œ±) (x : ‚Ñù) (hx : 0 ‚â§ x) : 0 ‚â§ weightedSMul Œº s x := by
  simp only [weightedSMul, Algebra.id.smul_eq_mul, coe_smul', id.def, coe_id', Pi.smul_apply]
  exact mul_nonneg toReal_nonneg hx
#align measure_theory.weighted_smul_nonneg MeasureTheory.weightedSMul_nonneg

end WeightedSmul

-- mathport name: ¬´expr ‚Üí‚Çõ ¬ª
local infixr:25 " ‚Üí‚Çõ " => SimpleFunc

namespace SimpleFunc

section PosPart

variable [LinearOrder E] [Zero E] [MeasurableSpace Œ±]

/-- Positive part of a simple function. -/
def posPart (f : Œ± ‚Üí‚Çõ E) : Œ± ‚Üí‚Çõ E :=
  f.map fun b => max b 0
#align measure_theory.simple_func.pos_part MeasureTheory.SimpleFunc.posPart

/-- Negative part of a simple function. -/
def negPart [Neg E] (f : Œ± ‚Üí‚Çõ E) : Œ± ‚Üí‚Çõ E :=
  posPart (-f)
#align measure_theory.simple_func.neg_part MeasureTheory.SimpleFunc.negPart

theorem posPart_map_norm (f : Œ± ‚Üí‚Çõ ‚Ñù) : (posPart f).map norm = posPart f := by
  ext; rw [map_apply, Real.norm_eq_abs, abs_of_nonneg]; exact le_max_right _ _
#align measure_theory.simple_func.pos_part_map_norm MeasureTheory.SimpleFunc.posPart_map_norm

theorem negPart_map_norm (f : Œ± ‚Üí‚Çõ ‚Ñù) : (negPart f).map norm = negPart f := by
  rw [negPart]; exact posPart_map_norm _
#align measure_theory.simple_func.neg_part_map_norm MeasureTheory.SimpleFunc.negPart_map_norm

theorem posPart_sub_negPart (f : Œ± ‚Üí‚Çõ ‚Ñù) : f.posPart - f.negPart = f := by
  simp only [posPart, negPart]
  ext a
  rw [coe_sub]
  exact max_zero_sub_eq_self (f a)
#align measure_theory.simple_func.pos_part_sub_neg_part MeasureTheory.SimpleFunc.posPart_sub_negPart

end PosPart

section Integral

/-!
### The Bochner integral of simple functions

Define the Bochner integral of simple functions of the type `Œ± ‚Üí‚Çõ Œ≤` where `Œ≤` is a normed group,
and prove basic property of this integral.
-/


open Finset

variable [NormedAddCommGroup E] [NormedAddCommGroup F] [NormedSpace ‚Ñù F] {p : ‚Ñù‚â•0‚àû} {G F' : Type*}
  [NormedAddCommGroup G] [NormedAddCommGroup F'] [NormedSpace ‚Ñù F'] {m : MeasurableSpace Œ±}
  {Œº : Measure Œ±}

/-- Bochner integral of simple functions whose codomain is a real `NormedSpace`.
This is equal to `‚àë x in f.range, (Œº (f ‚Åª¬π' {x})).toReal ‚Ä¢ x` (see `integral_eq`). -/
def integral {_ : MeasurableSpace Œ±} (Œº : Measure Œ±) (f : Œ± ‚Üí‚Çõ F) : F :=
  f.setToSimpleFunc (weightedSMul Œº)
#align measure_theory.simple_func.integral MeasureTheory.SimpleFunc.integral

theorem integral_def {_ : MeasurableSpace Œ±} (Œº : Measure Œ±) (f : Œ± ‚Üí‚Çõ F) :
    f.integral Œº = f.setToSimpleFunc (weightedSMul Œº) := rfl
#align measure_theory.simple_func.integral_def MeasureTheory.SimpleFunc.integral_def

theorem integral_eq {m : MeasurableSpace Œ±} (Œº : Measure Œ±) (f : Œ± ‚Üí‚Çõ F) :
    f.integral Œº = ‚àë x in f.range, (Œº (f ‚Åª¬π' {x})).toReal ‚Ä¢ x := by
  simp [integral, setToSimpleFunc, weightedSMul_apply]
#align measure_theory.simple_func.integral_eq MeasureTheory.SimpleFunc.integral_eq

theorem integral_eq_sum_filter [DecidablePred fun x : F => x ‚â† 0] {m : MeasurableSpace Œ±}
    (f : Œ± ‚Üí‚Çõ F) (Œº : Measure Œ±) :
    f.integral Œº = ‚àë x in f.range.filter fun x => x ‚â† 0, (Œº (f ‚Åª¬π' {x})).toReal ‚Ä¢ x := by
  rw [integral_def, setToSimpleFunc_eq_sum_filter]; simp_rw [weightedSMul_apply]; congr
#align measure_theory.simple_func.integral_eq_sum_filter MeasureTheory.SimpleFunc.integral_eq_sum_filter

/-- The Bochner integral is equal to a sum over any set that includes `f.range` (except `0`). -/
theorem integral_eq_sum_of_subset [DecidablePred fun x : F => x ‚â† 0] {f : Œ± ‚Üí‚Çõ F} {s : Finset F}
    (hs : (f.range.filter fun x => x ‚â† 0) ‚äÜ s) :
    f.integral Œº = ‚àë x in s, (Œº (f ‚Åª¬π' {x})).toReal ‚Ä¢ x := by
  rw [SimpleFunc.integral_eq_sum_filter, Finset.sum_subset hs]
  rintro x - hx; rw [Finset.mem_filter, not_and_or, Ne.def, Classical.not_not] at hx
  -- Porting note: reordered for clarity
  rcases hx.symm with (rfl | hx)
  ¬∑ simp
  rw [SimpleFunc.mem_range] at hx
  -- Porting note: added
  simp only [Set.mem_range, not_exists] at hx
  rw [preimage_eq_empty] <;> simp [Set.disjoint_singleton_left, hx]
#align measure_theory.simple_func.integral_eq_sum_of_subset MeasureTheory.SimpleFunc.integral_eq_sum_of_subset

@[simp]
theorem integral_const {m : MeasurableSpace Œ±} (Œº : Measure Œ±) (y : F) :
    (const Œ± y).integral Œº = (Œº univ).toReal ‚Ä¢ y := by
  classical
  calc
    (const Œ± y).integral Œº = ‚àë z in {y}, (Œº (const Œ± y ‚Åª¬π' {z})).toReal ‚Ä¢ z :=
      integral_eq_sum_of_subset <| (filter_subset _ _).trans (range_const_subset _ _)
    _ = (Œº univ).toReal ‚Ä¢ y := by simp [Set.preimage] -- Porting note: added `Set.preimage`
#align measure_theory.simple_func.integral_const MeasureTheory.SimpleFunc.integral_const

@[simp]
theorem integral_piecewise_zero {m : MeasurableSpace Œ±} (f : Œ± ‚Üí‚Çõ F) (Œº : Measure Œ±) {s : Set Œ±}
    (hs : MeasurableSet s) : (piecewise s hs f 0).integral Œº = f.integral (Œº.restrict s) := by
  classical
  refine' (integral_eq_sum_of_subset _).trans
      ((sum_congr rfl fun y hy => _).trans (integral_eq_sum_filter _ _).symm)
  ¬∑ intro y hy
    simp only [mem_filter, mem_range, coe_piecewise, coe_zero, piecewise_eq_indicator,
      mem_range_indicator] at *
    rcases hy with ‚ü®‚ü®rfl, -‚ü© | ‚ü®x, -, rfl‚ü©, h‚ÇÄ‚ü©
    exacts [(h‚ÇÄ rfl).elim, ‚ü®Set.mem_range_self _, h‚ÇÄ‚ü©]
  ¬∑ dsimp
    rw [Set.piecewise_eq_indicator, indicator_preimage_of_not_mem,
      Measure.restrict_apply (f.measurableSet_preimage _)]
    exact fun h‚ÇÄ => (mem_filter.1 hy).2 (Eq.symm h‚ÇÄ)
#align measure_theory.simple_func.integral_piecewise_zero MeasureTheory.SimpleFunc.integral_piecewise_zero

/-- Calculate the integral of `g ‚àò f : Œ± ‚Üí‚Çõ F`, where `f` is an integrable function from `Œ±` to `E`
    and `g` is a function from `E` to `F`. We require `g 0 = 0` so that `g ‚àò f` is integrable. -/
theorem map_integral (f : Œ± ‚Üí‚Çõ E) (g : E ‚Üí F) (hf : Integrable f Œº) (hg : g 0 = 0) :
    (f.map g).integral Œº = ‚àë x in f.range, ENNReal.toReal (Œº (f ‚Åª¬π' {x})) ‚Ä¢ g x :=
  map_setToSimpleFunc _ weightedSMul_union hf hg
#align measure_theory.simple_func.map_integral MeasureTheory.SimpleFunc.map_integral

/-- `SimpleFunc.integral` and `SimpleFunc.lintegral` agree when the integrand has type
    `Œ± ‚Üí‚Çõ ‚Ñù‚â•0‚àû`. But since `‚Ñù‚â•0‚àû` is not a `NormedSpace`, we need some form of coercion.
    See `integral_eq_lintegral` for a simpler version. -/
theorem integral_eq_lintegral' {f : Œ± ‚Üí‚Çõ E} {g : E ‚Üí ‚Ñù‚â•0‚àû} (hf : Integrable f Œº) (hg0 : g 0 = 0)
    (ht : ‚àÄ b, g b ‚â† ‚àû) :
    (f.map (ENNReal.toReal ‚àò g)).integral Œº = ENNReal.toReal (‚à´‚Åª a, g (f a) ‚àÇŒº) := by
  have hf' : f.FinMeasSupp Œº := integrable_iff_finMeasSupp.1 hf
  simp only [‚Üê map_apply g f, lintegral_eq_lintegral]
  rw [map_integral f _ hf, map_lintegral, ENNReal.toReal_sum]
  ¬∑ refine' Finset.sum_congr rfl fun b _ => _
    -- Porting note: added `Function.comp_apply`
    rw [smul_eq_mul, toReal_mul, mul_comm, Function.comp_apply]
  ¬∑ rintro a -
    by_cases a0 : a = 0
    ¬∑ rw [a0, hg0, zero_mul]; exact WithTop.zero_ne_top
    ¬∑ apply mul_ne_top (ht a) (hf'.meas_preimage_singleton_ne_zero a0).ne
  ¬∑ simp [hg0]
#align measure_theory.simple_func.integral_eq_lintegral' MeasureTheory.SimpleFunc.integral_eq_lintegral'

variable [NormedField ùïú] [NormedSpace ùïú E] [NormedSpace ‚Ñù E] [SMulCommClass ‚Ñù ùïú E]

theorem integral_congr {f g : Œ± ‚Üí‚Çõ E} (hf : Integrable f Œº) (h : f =·µê[Œº] g) :
    f.integral Œº = g.integral Œº :=
  setToSimpleFunc_congr (weightedSMul Œº) (fun _ _ => weightedSMul_null) weightedSMul_union hf h
#align measure_theory.simple_func.integral_congr MeasureTheory.SimpleFunc.integral_congr

/-- `SimpleFunc.bintegral` and `SimpleFunc.integral` agree when the integrand has type
    `Œ± ‚Üí‚Çõ ‚Ñù‚â•0‚àû`. But since `‚Ñù‚â•0‚àû` is not a `NormedSpace`, we need some form of coercion. -/
theorem integral_eq_lintegral {f : Œ± ‚Üí‚Çõ ‚Ñù} (hf : Integrable f Œº) (h_pos : 0 ‚â§·µê[Œº] f) :
    f.integral Œº = ENNReal.toReal (‚à´‚Åª a, ENNReal.ofReal (f a) ‚àÇŒº) := by
  have : f =·µê[Œº] f.map (ENNReal.toReal ‚àò ENNReal.ofReal) :=
    h_pos.mono fun a h => (ENNReal.toReal_ofReal h).symm
  rw [‚Üê integral_eq_lintegral' hf]
  exacts [integral_congr hf this, ENNReal.ofReal_zero, fun b => ENNReal.ofReal_ne_top]
#align measure_theory.simple_func.integral_eq_lintegral MeasureTheory.SimpleFunc.integral_eq_lintegral

theorem integral_add {f g : Œ± ‚Üí‚Çõ E} (hf : Integrable f Œº) (hg : Integrable g Œº) :
    integral Œº (f + g) = integral Œº f + integral Œº g :=
  setToSimpleFunc_add _ weightedSMul_union hf hg
#align measure_theory.simple_func.integral_add MeasureTheory.SimpleFunc.integral_add

theorem integral_neg {f : Œ± ‚Üí‚Çõ E} (hf : Integrable f Œº) : integral Œº (-f) = -integral Œº f :=
  setToSimpleFunc_neg _ weightedSMul_union hf
#align measure_theory.simple_func.integral_neg MeasureTheory.SimpleFunc.integral_neg

theorem integral_sub {f g : Œ± ‚Üí‚Çõ E} (hf : Integrable f Œº) (hg : Integrable g Œº) :
    integral Œº (f - g) = integral Œº f - integral Œº g :=
  setToSimpleFunc_sub _ weightedSMul_union hf hg
#align measure_theory.simple_func.integral_sub MeasureTheory.SimpleFunc.integral_sub

theorem integral_smul (c : ùïú) {f : Œ± ‚Üí‚Çõ E} (hf : Integrable f Œº) :
    integral Œº (c ‚Ä¢ f) = c ‚Ä¢ integral Œº f :=
  setToSimpleFunc_smul _ weightedSMul_union weightedSMul_smul c hf
#align measure_theory.simple_func.integral_smul MeasureTheory.SimpleFunc.integral_smul

theorem norm_setToSimpleFunc_le_integral_norm (T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) {C : ‚Ñù}
    (hT_norm : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ‚ÄñT s‚Äñ ‚â§ C * (Œº s).toReal) {f : Œ± ‚Üí‚Çõ E}
    (hf : Integrable f Œº) : ‚Äñf.setToSimpleFunc T‚Äñ ‚â§ C * (f.map norm).integral Œº :=
  calc
    ‚Äñf.setToSimpleFunc T‚Äñ ‚â§ C * ‚àë x in f.range, ENNReal.toReal (Œº (f ‚Åª¬π' {x})) * ‚Äñx‚Äñ :=
      norm_setToSimpleFunc_le_sum_mul_norm_of_integrable T hT_norm f hf
    _ = C * (f.map norm).integral Œº := by
      rw [map_integral f norm hf norm_zero]; simp_rw [smul_eq_mul]
#align measure_theory.simple_func.norm_set_to_simple_func_le_integral_norm MeasureTheory.SimpleFunc.norm_setToSimpleFunc_le_integral_norm

theorem norm_integral_le_integral_norm (f : Œ± ‚Üí‚Çõ E) (hf : Integrable f Œº) :
    ‚Äñf.integral Œº‚Äñ ‚â§ (f.map norm).integral Œº := by
  refine' (norm_setToSimpleFunc_le_integral_norm _ (fun s _ _ => _) hf).trans (one_mul _).le
  exact (norm_weightedSMul_le s).trans (one_mul _).symm.le
#align measure_theory.simple_func.norm_integral_le_integral_norm MeasureTheory.SimpleFunc.norm_integral_le_integral_norm

theorem integral_add_measure {ŒΩ} (f : Œ± ‚Üí‚Çõ E) (hf : Integrable f (Œº + ŒΩ)) :
    f.integral (Œº + ŒΩ) = f.integral Œº + f.integral ŒΩ := by
  simp_rw [integral_def]
  refine' setToSimpleFunc_add_left'
    (weightedSMul Œº) (weightedSMul ŒΩ) (weightedSMul (Œº + ŒΩ)) (fun s _ hŒºŒΩs => _) hf
  rw [lt_top_iff_ne_top, Measure.coe_add, Pi.add_apply, ENNReal.add_ne_top] at hŒºŒΩs
  rw [weightedSMul_add_measure _ _ hŒºŒΩs.1 hŒºŒΩs.2]
#align measure_theory.simple_func.integral_add_measure MeasureTheory.SimpleFunc.integral_add_measure

end Integral

end SimpleFunc

namespace L1
set_option linter.uppercaseLean3 false -- `L1`

open AEEqFun Lp.simpleFunc Lp

variable [NormedAddCommGroup E] [NormedAddCommGroup F] {m : MeasurableSpace Œ±} {Œº : Measure Œ±}

namespace SimpleFunc

theorem norm_eq_integral (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) : ‚Äñf‚Äñ = ((toSimpleFunc f).map norm).integral Œº := by
  rw [norm_eq_sum_mul f, (toSimpleFunc f).map_integral norm (SimpleFunc.integrable f) norm_zero]
  simp_rw [smul_eq_mul]
#align measure_theory.L1.simple_func.norm_eq_integral MeasureTheory.L1.SimpleFunc.norm_eq_integral

section PosPart

/-- Positive part of a simple function in L1 space.  -/
nonrec def posPart (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] ‚Ñù) : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] ‚Ñù :=
  ‚ü®Lp.posPart (f : Œ± ‚Üí‚ÇÅ[Œº] ‚Ñù), by
    rcases f with ‚ü®f, s, hsf‚ü©
    use s.posPart
    simp only [Subtype.coe_mk, Lp.coe_posPart, ‚Üê hsf, AEEqFun.posPart_mk,
      SimpleFunc.coe_map, mk_eq_mk]
    -- Porting note: added
    simp [SimpleFunc.posPart, Function.comp, EventuallyEq.rfl] ‚ü©
#align measure_theory.L1.simple_func.pos_part MeasureTheory.L1.SimpleFunc.posPart

/-- Negative part of a simple function in L1 space. -/
def negPart (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] ‚Ñù) : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] ‚Ñù :=
  posPart (-f)
#align measure_theory.L1.simple_func.neg_part MeasureTheory.L1.SimpleFunc.negPart

@[norm_cast]
theorem coe_posPart (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] ‚Ñù) : (posPart f : Œ± ‚Üí‚ÇÅ[Œº] ‚Ñù) = Lp.posPart (f : Œ± ‚Üí‚ÇÅ[Œº] ‚Ñù) := rfl
#align measure_theory.L1.simple_func.coe_pos_part MeasureTheory.L1.SimpleFunc.coe_posPart

@[norm_cast]
theorem coe_negPart (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] ‚Ñù) : (negPart f : Œ± ‚Üí‚ÇÅ[Œº] ‚Ñù) = Lp.negPart (f : Œ± ‚Üí‚ÇÅ[Œº] ‚Ñù) := rfl
#align measure_theory.L1.simple_func.coe_neg_part MeasureTheory.L1.SimpleFunc.coe_negPart

end PosPart

section SimpleFuncIntegral

/-!
### The Bochner integral of `L1`

Define the Bochner integral on `Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E` by extension from the simple functions `Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E`,
and prove basic properties of this integral. -/


variable [NormedField ùïú] [NormedSpace ùïú E] [NormedSpace ‚Ñù E] [SMulCommClass ‚Ñù ùïú E] {F' : Type*}
  [NormedAddCommGroup F'] [NormedSpace ‚Ñù F']

attribute [local instance] simpleFunc.normedSpace

/-- The Bochner integral over simple functions in L1 space. -/
def integral (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) : E :=
  (toSimpleFunc f).integral Œº
#align measure_theory.L1.simple_func.integral MeasureTheory.L1.SimpleFunc.integral

theorem integral_eq_integral (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) : integral f = (toSimpleFunc f).integral Œº := rfl
#align measure_theory.L1.simple_func.integral_eq_integral MeasureTheory.L1.SimpleFunc.integral_eq_integral

nonrec theorem integral_eq_lintegral {f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] ‚Ñù} (h_pos : 0 ‚â§·µê[Œº] toSimpleFunc f) :
    integral f = ENNReal.toReal (‚à´‚Åª a, ENNReal.ofReal ((toSimpleFunc f) a) ‚àÇŒº) := by
  rw [integral, SimpleFunc.integral_eq_lintegral (SimpleFunc.integrable f) h_pos]
#align measure_theory.L1.simple_func.integral_eq_lintegral MeasureTheory.L1.SimpleFunc.integral_eq_lintegral

theorem integral_eq_setToL1S (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) : integral f = setToL1S (weightedSMul Œº) f := rfl
#align measure_theory.L1.simple_func.integral_eq_set_to_L1s MeasureTheory.L1.SimpleFunc.integral_eq_setToL1S

nonrec theorem integral_congr {f g : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E} (h : toSimpleFunc f =·µê[Œº] toSimpleFunc g) :
    integral f = integral g :=
  SimpleFunc.integral_congr (SimpleFunc.integrable f) h
#align measure_theory.L1.simple_func.integral_congr MeasureTheory.L1.SimpleFunc.integral_congr

theorem integral_add (f g : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) : integral (f + g) = integral f + integral g :=
  setToL1S_add _ (fun _ _ => weightedSMul_null) weightedSMul_union _ _
#align measure_theory.L1.simple_func.integral_add MeasureTheory.L1.SimpleFunc.integral_add

theorem integral_smul (c : ùïú) (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) : integral (c ‚Ä¢ f) = c ‚Ä¢ integral f :=
  setToL1S_smul _ (fun _ _ => weightedSMul_null) weightedSMul_union weightedSMul_smul c f
#align measure_theory.L1.simple_func.integral_smul MeasureTheory.L1.SimpleFunc.integral_smul

theorem norm_integral_le_norm (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) : ‚Äñintegral f‚Äñ ‚â§ ‚Äñf‚Äñ := by
  rw [integral, norm_eq_integral]
  exact (toSimpleFunc f).norm_integral_le_integral_norm (SimpleFunc.integrable f)
#align measure_theory.L1.simple_func.norm_integral_le_norm MeasureTheory.L1.SimpleFunc.norm_integral_le_norm

variable {E' : Type*} [NormedAddCommGroup E'] [NormedSpace ‚Ñù E'] [NormedSpace ùïú E']

variable (Œ± E Œº ùïú)

/-- The Bochner integral over simple functions in L1 space as a continuous linear map. -/
def integralCLM' : (Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) ‚ÜíL[ùïú] E :=
  LinearMap.mkContinuous ‚ü®‚ü®integral, integral_add‚ü©, integral_smul‚ü© 1 fun f =>
    le_trans (norm_integral_le_norm _) <| by rw [one_mul]
#align measure_theory.L1.simple_func.integral_clm' MeasureTheory.L1.SimpleFunc.integralCLM'

/-- The Bochner integral over simple functions in L1 space as a continuous linear map over ‚Ñù. -/
def integralCLM : (Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) ‚ÜíL[‚Ñù] E :=
  integralCLM' Œ± E ‚Ñù Œº
#align measure_theory.L1.simple_func.integral_clm MeasureTheory.L1.SimpleFunc.integralCLM

variable {Œ± E Œº ùïú}

-- mathport name: simple_func.integral_clm
local notation "Integral" => integralCLM Œ± E Œº

open ContinuousLinearMap

theorem norm_Integral_le_one : ‚ÄñIntegral‚Äñ ‚â§ 1 :=
  -- Porting note: Old proof was `LinearMap.mkContinuous_norm_le _ zero_le_one _`
  LinearMap.mkContinuous_norm_le _ zero_le_one (fun f => by
    rw [one_mul]
    exact norm_integral_le_norm f)
#align measure_theory.L1.simple_func.norm_Integral_le_one MeasureTheory.L1.SimpleFunc.norm_Integral_le_one

section PosPart

theorem posPart_toSimpleFunc (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] ‚Ñù) :
    toSimpleFunc (posPart f) =·µê[Œº] (toSimpleFunc f).posPart := by
  have eq : ‚àÄ a, (toSimpleFunc f).posPart a = max ((toSimpleFunc f) a) 0 := fun a => rfl
  have ae_eq : ‚àÄ·µê a ‚àÇŒº, toSimpleFunc (posPart f) a = max ((toSimpleFunc f) a) 0 := by
    filter_upwards [toSimpleFunc_eq_toFun (posPart f), Lp.coeFn_posPart (f : Œ± ‚Üí‚ÇÅ[Œº] ‚Ñù),
      toSimpleFunc_eq_toFun f] with _ _ h‚ÇÇ h‚ÇÉ
    convert h‚ÇÇ using 1
    -- Porting note: added
    rw [h‚ÇÉ]
  refine' ae_eq.mono fun a h => _
  rw [h, eq]
#align measure_theory.L1.simple_func.pos_part_to_simple_func MeasureTheory.L1.SimpleFunc.posPart_toSimpleFunc

theorem negPart_toSimpleFunc (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] ‚Ñù) :
    toSimpleFunc (negPart f) =·µê[Œº] (toSimpleFunc f).negPart := by
  rw [SimpleFunc.negPart, MeasureTheory.SimpleFunc.negPart]
  filter_upwards [posPart_toSimpleFunc (-f), neg_toSimpleFunc f]
  intro a h‚ÇÅ h‚ÇÇ
  rw [h‚ÇÅ]
  show max _ _ = max _ _
  rw [h‚ÇÇ]
  rfl
#align measure_theory.L1.simple_func.neg_part_to_simple_func MeasureTheory.L1.SimpleFunc.negPart_toSimpleFunc

theorem integral_eq_norm_posPart_sub (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] ‚Ñù) : integral f = ‚ÄñposPart f‚Äñ - ‚ÄñnegPart f‚Äñ := by
  -- Convert things in `L¬π` to their `SimpleFunc` counterpart
  have ae_eq‚ÇÅ : (toSimpleFunc f).posPart =·µê[Œº] (toSimpleFunc (posPart f)).map norm := by
    filter_upwards [posPart_toSimpleFunc f] with _ h
    rw [SimpleFunc.map_apply, h]
    conv_lhs => rw [‚Üê SimpleFunc.posPart_map_norm, SimpleFunc.map_apply]
  -- Convert things in `L¬π` to their `SimpleFunc` counterpart
  have ae_eq‚ÇÇ : (toSimpleFunc f).negPart =·µê[Œº] (toSimpleFunc (negPart f)).map norm := by
    filter_upwards [negPart_toSimpleFunc f] with _ h
    rw [SimpleFunc.map_apply, h]
    conv_lhs => rw [‚Üê SimpleFunc.negPart_map_norm, SimpleFunc.map_apply]
  rw [integral, norm_eq_integral, norm_eq_integral, ‚Üê SimpleFunc.integral_sub]
  ¬∑ show (toSimpleFunc f).integral Œº =
      ((toSimpleFunc (posPart f)).map norm - (toSimpleFunc (negPart f)).map norm).integral Œº
    apply MeasureTheory.SimpleFunc.integral_congr (SimpleFunc.integrable f)
    filter_upwards [ae_eq‚ÇÅ, ae_eq‚ÇÇ] with _ h‚ÇÅ h‚ÇÇ
    show _ = _ - _
    rw [‚Üê h‚ÇÅ, ‚Üê h‚ÇÇ]
    have := (toSimpleFunc f).posPart_sub_negPart
    conv_lhs => rw [‚Üê this]
  ¬∑ exact (SimpleFunc.integrable f).pos_part.congr ae_eq‚ÇÅ
  ¬∑ exact (SimpleFunc.integrable f).neg_part.congr ae_eq‚ÇÇ
#align measure_theory.L1.simple_func.integral_eq_norm_pos_part_sub MeasureTheory.L1.SimpleFunc.integral_eq_norm_posPart_sub

end PosPart

end SimpleFuncIntegral

end SimpleFunc

open SimpleFunc

local notation "Integral" => @integralCLM Œ± E _ _ _ _ _ Œº _

variable [NormedSpace ‚Ñù E] [NontriviallyNormedField ùïú] [NormedSpace ùïú E] [SMulCommClass ‚Ñù ùïú E]
  [NormedSpace ‚Ñù F] [CompleteSpace E]

section IntegrationInL1

attribute [local instance] simpleFunc.normedSpace

open ContinuousLinearMap

variable (ùïú)

/-- The Bochner integral in L1 space as a continuous linear map. -/
nonrec def integralCLM' : (Œ± ‚Üí‚ÇÅ[Œº] E) ‚ÜíL[ùïú] E :=
  (integralCLM' Œ± E ùïú Œº).extend (coeToLp Œ± E ùïú) (simpleFunc.denseRange one_ne_top)
    simpleFunc.uniformInducing
#align measure_theory.L1.integral_clm' MeasureTheory.L1.integralCLM'

variable {ùïú}

/-- The Bochner integral in L1 space as a continuous linear map over ‚Ñù. -/
def integralCLM : (Œ± ‚Üí‚ÇÅ[Œº] E) ‚ÜíL[‚Ñù] E :=
  integralCLM' ‚Ñù
#align measure_theory.L1.integral_clm MeasureTheory.L1.integralCLM

-- Porting note: added `(E := E)` in several places below.
/-- The Bochner integral in L1 space -/
irreducible_def integral (f : Œ± ‚Üí‚ÇÅ[Œº] E) : E :=
  integralCLM (E := E) f
#align measure_theory.L1.integral MeasureTheory.L1.integral

theorem integral_eq (f : Œ± ‚Üí‚ÇÅ[Œº] E) : integral f = integralCLM (E := E) f := by
  simp only [integral]
#align measure_theory.L1.integral_eq MeasureTheory.L1.integral_eq

theorem integral_eq_setToL1 (f : Œ± ‚Üí‚ÇÅ[Œº] E) :
    integral f = setToL1 (E := E) (dominatedFinMeasAdditive_weightedSMul Œº) f := by
  simp only [integral]; rfl
#align measure_theory.L1.integral_eq_set_to_L1 MeasureTheory.L1.integral_eq_setToL1

@[norm_cast]
theorem SimpleFunc.integral_L1_eq_integral (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) :
    L1.integral (f : Œ± ‚Üí‚ÇÅ[Œº] E) = SimpleFunc.integral f := by
  simp only [integral, L1.integral]
  exact setToL1_eq_setToL1SCLM (dominatedFinMeasAdditive_weightedSMul Œº) f
#align measure_theory.L1.simple_func.integral_L1_eq_integral MeasureTheory.L1.SimpleFunc.integral_L1_eq_integral

variable (Œ± E)

@[simp]
theorem integral_zero : integral (0 : Œ± ‚Üí‚ÇÅ[Œº] E) = 0 := by
  simp only [integral]
  exact map_zero integralCLM
#align measure_theory.L1.integral_zero MeasureTheory.L1.integral_zero

variable {Œ± E}

@[integral_simps]
theorem integral_add (f g : Œ± ‚Üí‚ÇÅ[Œº] E) : integral (f + g) = integral f + integral g := by
  simp only [integral]
  exact map_add integralCLM f g
#align measure_theory.L1.integral_add MeasureTheory.L1.integral_add

@[integral_simps]
theorem integral_neg (f : Œ± ‚Üí‚ÇÅ[Œº] E) : integral (-f) = -integral f := by
  simp only [integral]
  exact map_neg integralCLM f
#align measure_theory.L1.integral_neg MeasureTheory.L1.integral_neg

@[integral_simps]
theorem integral_sub (f g : Œ± ‚Üí‚ÇÅ[Œº] E) : integral (f - g) = integral f - integral g := by
  simp only [integral]
  exact map_sub integralCLM f g
#align measure_theory.L1.integral_sub MeasureTheory.L1.integral_sub

@[integral_simps]
theorem integral_smul (c : ùïú) (f : Œ± ‚Üí‚ÇÅ[Œº] E) : integral (c ‚Ä¢ f) = c ‚Ä¢ integral f := by
  simp only [integral]
  show (integralCLM' (E := E) ùïú) (c ‚Ä¢ f) = c ‚Ä¢ (integralCLM' (E := E) ùïú) f
  exact map_smul (integralCLM' (E := E) ùïú) c f
#align measure_theory.L1.integral_smul MeasureTheory.L1.integral_smul

-- mathport name: integral_clm
local notation "Integral" => @integralCLM Œ± E _ _ Œº _ _

-- mathport name: simple_func.integral_clm'
local notation "sIntegral" => @SimpleFunc.integralCLM Œ± E _ _ Œº _

theorem norm_Integral_le_one : ‚ÄñintegralCLM (Œ± := Œ±) (E := E) (Œº := Œº)‚Äñ ‚â§ 1 :=
  norm_setToL1_le (dominatedFinMeasAdditive_weightedSMul Œº) zero_le_one
#align measure_theory.L1.norm_Integral_le_one MeasureTheory.L1.norm_Integral_le_one

theorem nnnorm_Integral_le_one : ‚ÄñintegralCLM (Œ± := Œ±) (E := E) (Œº := Œº)‚Äñ‚Çä ‚â§ 1 :=
  norm_Integral_le_one

theorem norm_integral_le (f : Œ± ‚Üí‚ÇÅ[Œº] E) : ‚Äñintegral f‚Äñ ‚â§ ‚Äñf‚Äñ :=
  calc
    ‚Äñintegral f‚Äñ = ‚ÄñintegralCLM (E := E) f‚Äñ := by simp only [integral]
    _ ‚â§ ‚ÄñintegralCLM (Œ± := Œ±) (E := E) (Œº := Œº)‚Äñ * ‚Äñf‚Äñ := (le_op_norm _ _)
    _ ‚â§ 1 * ‚Äñf‚Äñ := (mul_le_mul_of_nonneg_right norm_Integral_le_one <| norm_nonneg _)
    _ = ‚Äñf‚Äñ := one_mul _
#align measure_theory.L1.norm_integral_le MeasureTheory.L1.norm_integral_le

theorem nnnorm_integral_le (f : Œ± ‚Üí‚ÇÅ[Œº] E) : ‚Äñintegral f‚Äñ‚Çä ‚â§ ‚Äñf‚Äñ‚Çä :=
  norm_integral_le f

@[continuity]
theorem continuous_integral : Continuous fun f : Œ± ‚Üí‚ÇÅ[Œº] E => integral f := by
  simp only [integral]
  exact L1.integralCLM.continuous
#align measure_theory.L1.continuous_integral MeasureTheory.L1.continuous_integral

section PosPart

theorem integral_eq_norm_posPart_sub (f : Œ± ‚Üí‚ÇÅ[Œº] ‚Ñù) :
    integral f = ‚ÄñLp.posPart f‚Äñ - ‚ÄñLp.negPart f‚Äñ := by
  -- Use `isClosed_property` and `isClosed_eq`
  refine' @isClosed_property _ _ _ ((‚Üë) : (Œ± ‚Üí‚ÇÅ‚Çõ[Œº] ‚Ñù) ‚Üí Œ± ‚Üí‚ÇÅ[Œº] ‚Ñù)
      (fun f : Œ± ‚Üí‚ÇÅ[Œº] ‚Ñù => integral f = ‚ÄñLp.posPart f‚Äñ - ‚ÄñLp.negPart f‚Äñ)
      (simpleFunc.denseRange one_ne_top) (isClosed_eq _ _) _ f
  ¬∑ simp only [integral]
    exact cont _
  ¬∑ refine' Continuous.sub (continuous_norm.comp Lp.continuous_posPart)
      (continuous_norm.comp Lp.continuous_negPart)
  -- Show that the property holds for all simple functions in the `L¬π` space.
  ¬∑ intro s
    norm_cast
    exact SimpleFunc.integral_eq_norm_posPart_sub _
#align measure_theory.L1.integral_eq_norm_pos_part_sub MeasureTheory.L1.integral_eq_norm_posPart_sub

end PosPart

end IntegrationInL1

end L1

/-!
## The Bochner integral on functions

Define the Bochner integral on functions generally to be the `L1` Bochner integral, for integrable
functions, and 0 otherwise; prove its basic properties.
-/

variable [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [hE : CompleteSpace E] [NontriviallyNormedField ùïú]
  [NormedSpace ùïú E] [SMulCommClass ‚Ñù ùïú E] [NormedAddCommGroup F] [NormedSpace ‚Ñù F] [CompleteSpace F]
  {G : Type*} [NormedAddCommGroup G] [NormedSpace ‚Ñù G]

section

open scoped Classical

/-- The Bochner integral -/
irreducible_def integral {_ : MeasurableSpace Œ±} (Œº : Measure Œ±) (f : Œ± ‚Üí G) : G :=
  if _ : CompleteSpace G then
    if hf : Integrable f Œº then L1.integral (hf.toL1 f) else 0
  else 0
#align measure_theory.integral MeasureTheory.integral

end

/-! In the notation for integrals, an expression like `‚à´ x, g ‚Äñx‚Äñ ‚àÇŒº` will not be parsed correctly,
  and needs parentheses. We do not set the binding power of `r` to `0`, because then
  `‚à´ x, f x = 0` will be parsed incorrectly. -/

@[inherit_doc MeasureTheory.integral]
notation3 "‚à´ "(...)", "r:60:(scoped f => f)" ‚àÇ"Œº:70 => integral Œº r

@[inherit_doc MeasureTheory.integral]
notation3 "‚à´ "(...)", "r:60:(scoped f => integral volume f) => r

@[inherit_doc MeasureTheory.integral]
notation3 "‚à´ "(...)" in "s", "r:60:(scoped f => f)" ‚àÇ"Œº:70 => integral (Measure.restrict Œº s) r

@[inherit_doc MeasureTheory.integral]
notation3 "‚à´ "(...)" in "s", "r:60:(scoped f => integral (Measure.restrict volume s) f) => r

section Properties

open ContinuousLinearMap MeasureTheory.SimpleFunc

variable {f g : Œ± ‚Üí E} {m : MeasurableSpace Œ±} {Œº : Measure Œ±}

theorem integral_eq (f : Œ± ‚Üí E) (hf : Integrable f Œº) : ‚à´ a, f a ‚àÇŒº = L1.integral (hf.toL1 f) := by
  simp [integral, hE, hf]
#align measure_theory.integral_eq MeasureTheory.integral_eq

theorem integral_eq_setToFun (f : Œ± ‚Üí E) :
    ‚à´ a, f a ‚àÇŒº = setToFun Œº (weightedSMul Œº) (dominatedFinMeasAdditive_weightedSMul Œº) f := by
  simp only [integral, hE, L1.integral]; rfl
#align measure_theory.integral_eq_set_to_fun MeasureTheory.integral_eq_setToFun

theorem L1.integral_eq_integral (f : Œ± ‚Üí‚ÇÅ[Œº] E) : L1.integral f = ‚à´ a, f a ‚àÇŒº := by
  simp only [integral, L1.integral, integral_eq_setToFun]
  exact (L1.setToFun_eq_setToL1 (dominatedFinMeasAdditive_weightedSMul Œº) f).symm
set_option linter.uppercaseLean3 false in
#align measure_theory.L1.integral_eq_integral MeasureTheory.L1.integral_eq_integral

theorem integral_undef {f : Œ± ‚Üí G} (h : ¬¨Integrable f Œº) : ‚à´ a, f a ‚àÇŒº = 0 := by
  by_cases hG : CompleteSpace G
  ¬∑ simp [integral, hG, h]
  ¬∑ simp [integral, hG]
#align measure_theory.integral_undef MeasureTheory.integral_undef

theorem integral_non_aestronglyMeasurable {f : Œ± ‚Üí G} (h : ¬¨AEStronglyMeasurable f Œº) :
    ‚à´ a, f a ‚àÇŒº = 0 :=
  integral_undef <| not_and_of_not_left _ h
#align measure_theory.integral_non_ae_strongly_measurable MeasureTheory.integral_non_aestronglyMeasurable

variable (Œ± G)

@[simp]
theorem integral_zero : ‚à´ _ : Œ±, (0 : G) ‚àÇŒº = 0 := by
  by_cases hG : CompleteSpace G
  ¬∑ simp only [integral, hG, L1.integral]
    exact setToFun_zero (dominatedFinMeasAdditive_weightedSMul Œº)
  ¬∑ simp [integral, hG]
#align measure_theory.integral_zero MeasureTheory.integral_zero

@[simp]
theorem integral_zero' : integral Œº (0 : Œ± ‚Üí G) = 0 :=
  integral_zero Œ± G
#align measure_theory.integral_zero' MeasureTheory.integral_zero'

variable {Œ± G}

theorem integrable_of_integral_eq_one {f : Œ± ‚Üí ‚Ñù} (h : ‚à´ x, f x ‚àÇŒº = 1) : Integrable f Œº := by
  contrapose h; rw [integral_undef h]; exact zero_ne_one
#align measure_theory.integrable_of_integral_eq_one MeasureTheory.integrable_of_integral_eq_one

theorem integral_add {f g : Œ± ‚Üí G} (hf : Integrable f Œº) (hg : Integrable g Œº) :
    ‚à´ a, f a + g a ‚àÇŒº = ‚à´ a, f a ‚àÇŒº + ‚à´ a, g a ‚àÇŒº := by
  by_cases hG : CompleteSpace G
  ¬∑ simp only [integral, hG, L1.integral]
    exact setToFun_add (dominatedFinMeasAdditive_weightedSMul Œº) hf hg
  ¬∑ simp [integral, hG]
#align measure_theory.integral_add MeasureTheory.integral_add

theorem integral_add' {f g : Œ± ‚Üí G} (hf : Integrable f Œº) (hg : Integrable g Œº) :
    ‚à´ a, (f + g) a ‚àÇŒº = ‚à´ a, f a ‚àÇŒº + ‚à´ a, g a ‚àÇŒº :=
  integral_add hf hg
#align measure_theory.integral_add' MeasureTheory.integral_add'

theorem integral_finset_sum {Œπ} (s : Finset Œπ) {f : Œπ ‚Üí Œ± ‚Üí G} (hf : ‚àÄ i ‚àà s, Integrable (f i) Œº) :
    ‚à´ a, ‚àë i in s, f i a ‚àÇŒº = ‚àë i in s, ‚à´ a, f i a ‚àÇŒº := by
  by_cases hG : CompleteSpace G
  ¬∑ simp only [integral, hG, L1.integral]
    exact setToFun_finset_sum (dominatedFinMeasAdditive_weightedSMul _) s hf
  ¬∑ simp [integral, hG]
#align measure_theory.integral_finset_sum MeasureTheory.integral_finset_sum

@[integral_simps]
theorem integral_neg (f : Œ± ‚Üí G) : ‚à´ a, -f a ‚àÇŒº = -‚à´ a, f a ‚àÇŒº := by
  by_cases hG : CompleteSpace G
  ¬∑ simp only [integral, hG, L1.integral]
    exact setToFun_neg (dominatedFinMeasAdditive_weightedSMul Œº) f
  ¬∑ simp [integral, hG]
#align measure_theory.integral_neg MeasureTheory.integral_neg

theorem integral_neg' (f : Œ± ‚Üí G) : ‚à´ a, (-f) a ‚àÇŒº = -‚à´ a, f a ‚àÇŒº :=
  integral_neg f
#align measure_theory.integral_neg' MeasureTheory.integral_neg'

theorem integral_sub {f g : Œ± ‚Üí G} (hf : Integrable f Œº) (hg : Integrable g Œº) :
    ‚à´ a, f a - g a ‚àÇŒº = ‚à´ a, f a ‚àÇŒº - ‚à´ a, g a ‚àÇŒº := by
  by_cases hG : CompleteSpace G
  ¬∑ simp only [integral, hG, L1.integral]
    exact setToFun_sub (dominatedFinMeasAdditive_weightedSMul Œº) hf hg
  ¬∑ simp [integral, hG]
#align measure_theory.integral_sub MeasureTheory.integral_sub

theorem integral_sub' {f g : Œ± ‚Üí G} (hf : Integrable f Œº) (hg : Integrable g Œº) :
    ‚à´ a, (f - g) a ‚àÇŒº = ‚à´ a, f a ‚àÇŒº - ‚à´ a, g a ‚àÇŒº :=
  integral_sub hf hg
#align measure_theory.integral_sub' MeasureTheory.integral_sub'

@[integral_simps]
theorem integral_smul [NormedSpace ùïú G] [SMulCommClass ‚Ñù ùïú G] (c : ùïú) (f : Œ± ‚Üí G) :
    ‚à´ a, c ‚Ä¢ f a ‚àÇŒº = c ‚Ä¢ ‚à´ a, f a ‚àÇŒº := by
  by_cases hG : CompleteSpace G
  ¬∑ simp only [integral, hG, L1.integral]
    exact setToFun_smul (dominatedFinMeasAdditive_weightedSMul Œº) weightedSMul_smul c f
  ¬∑ simp [integral, hG]
#align measure_theory.integral_smul MeasureTheory.integral_smul

theorem integral_mul_left {L : Type*} [IsROrC L] (r : L) (f : Œ± ‚Üí L) :
    ‚à´ a, r * f a ‚àÇŒº = r * ‚à´ a, f a ‚àÇŒº :=
  integral_smul r f
#align measure_theory.integral_mul_left MeasureTheory.integral_mul_left

theorem integral_mul_right {L : Type*} [IsROrC L] (r : L) (f : Œ± ‚Üí L) :
    ‚à´ a, f a * r ‚àÇŒº = (‚à´ a, f a ‚àÇŒº) * r := by
  simp only [mul_comm]; exact integral_mul_left r f
#align measure_theory.integral_mul_right MeasureTheory.integral_mul_right

theorem integral_div {L : Type*} [IsROrC L] (r : L) (f : Œ± ‚Üí L) :
    ‚à´ a, f a / r ‚àÇŒº = (‚à´ a, f a ‚àÇŒº) / r := by
  simpa only [‚Üê div_eq_mul_inv] using integral_mul_right r‚Åª¬π f
#align measure_theory.integral_div MeasureTheory.integral_div

theorem integral_congr_ae {f g : Œ± ‚Üí G} (h : f =·µê[Œº] g) : ‚à´ a, f a ‚àÇŒº = ‚à´ a, g a ‚àÇŒº := by
  by_cases hG : CompleteSpace G
  ¬∑ simp only [integral, hG, L1.integral]
    exact setToFun_congr_ae (dominatedFinMeasAdditive_weightedSMul Œº) h
  ¬∑ simp [integral, hG]
#align measure_theory.integral_congr_ae MeasureTheory.integral_congr_ae

-- Porting note: `nolint simpNF` added because simplify fails on left-hand side
@[simp, nolint simpNF]
theorem L1.integral_of_fun_eq_integral {f : Œ± ‚Üí G} (hf : Integrable f Œº) :
    ‚à´ a, (hf.toL1 f) a ‚àÇŒº = ‚à´ a, f a ‚àÇŒº := by
  by_cases hG : CompleteSpace G
  ¬∑ simp only [MeasureTheory.integral, hG, L1.integral]
    exact setToFun_toL1 (dominatedFinMeasAdditive_weightedSMul Œº) hf
  ¬∑ simp [MeasureTheory.integral, hG]
set_option linter.uppercaseLean3 false in
#align measure_theory.L1.integral_of_fun_eq_integral MeasureTheory.L1.integral_of_fun_eq_integral

@[continuity]
theorem continuous_integral : Continuous fun f : Œ± ‚Üí‚ÇÅ[Œº] G => ‚à´ a, f a ‚àÇŒº := by
  by_cases hG : CompleteSpace G
  ¬∑ simp only [integral, hG, L1.integral]
    exact continuous_setToFun (dominatedFinMeasAdditive_weightedSMul Œº)
  ¬∑ simp [integral, hG, continuous_const]
#align measure_theory.continuous_integral MeasureTheory.continuous_integral

theorem norm_integral_le_lintegral_norm (f : Œ± ‚Üí G) :
    ‚Äñ‚à´ a, f a ‚àÇŒº‚Äñ ‚â§ ENNReal.toReal (‚à´‚Åª a, ENNReal.ofReal ‚Äñf a‚Äñ ‚àÇŒº) := by
  by_cases hG : CompleteSpace G
  ¬∑ by_cases hf : Integrable f Œº
    ¬∑ rw [integral_eq f hf, ‚Üê Integrable.norm_toL1_eq_lintegral_norm f hf]
      exact L1.norm_integral_le _
    ¬∑ rw [integral_undef hf, norm_zero]; exact toReal_nonneg
  ¬∑ simp [integral, hG]
#align measure_theory.norm_integral_le_lintegral_norm MeasureTheory.norm_integral_le_lintegral_norm

theorem ennnorm_integral_le_lintegral_ennnorm (f : Œ± ‚Üí G) :
    (‚Äñ‚à´ a, f a ‚àÇŒº‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ‚â§ ‚à´‚Åª a, ‚Äñf a‚Äñ‚Çä ‚àÇŒº := by
  simp_rw [‚Üê ofReal_norm_eq_coe_nnnorm]
  apply ENNReal.ofReal_le_of_le_toReal
  exact norm_integral_le_lintegral_norm f
#align measure_theory.ennnorm_integral_le_lintegral_ennnorm MeasureTheory.ennnorm_integral_le_lintegral_ennnorm

theorem integral_eq_zero_of_ae {f : Œ± ‚Üí G} (hf : f =·µê[Œº] 0) : ‚à´ a, f a ‚àÇŒº = 0 := by
  simp [integral_congr_ae hf, integral_zero]
#align measure_theory.integral_eq_zero_of_ae MeasureTheory.integral_eq_zero_of_ae

/-- If `f` has finite integral, then `‚à´ x in s, f x ‚àÇŒº` is absolutely continuous in `s`: it tends
to zero as `Œº s` tends to zero. -/
theorem HasFiniteIntegral.tendsto_set_integral_nhds_zero {Œπ} {f : Œ± ‚Üí G}
    (hf : HasFiniteIntegral f Œº) {l : Filter Œπ} {s : Œπ ‚Üí Set Œ±} (hs : Tendsto (Œº ‚àò s) l (ùìù 0)) :
    Tendsto (fun i => ‚à´ x in s i, f x ‚àÇŒº) l (ùìù 0) := by
  rw [tendsto_zero_iff_norm_tendsto_zero]
  simp_rw [‚Üê coe_nnnorm, ‚Üê NNReal.coe_zero, NNReal.tendsto_coe, ‚Üê ENNReal.tendsto_coe,
    ENNReal.coe_zero]
  exact tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds
    (tendsto_set_lintegral_zero (ne_of_lt hf) hs) (fun i => zero_le _)
    fun i => ennnorm_integral_le_lintegral_ennnorm _
#align measure_theory.has_finite_integral.tendsto_set_integral_nhds_zero MeasureTheory.HasFiniteIntegral.tendsto_set_integral_nhds_zero

/-- If `f` is integrable, then `‚à´ x in s, f x ‚àÇŒº` is absolutely continuous in `s`: it tends
to zero as `Œº s` tends to zero. -/
theorem Integrable.tendsto_set_integral_nhds_zero {Œπ} {f : Œ± ‚Üí G} (hf : Integrable f Œº)
    {l : Filter Œπ} {s : Œπ ‚Üí Set Œ±} (hs : Tendsto (Œº ‚àò s) l (ùìù 0)) :
    Tendsto (fun i => ‚à´ x in s i, f x ‚àÇŒº) l (ùìù 0) :=
  hf.2.tendsto_set_integral_nhds_zero hs
#align measure_theory.integrable.tendsto_set_integral_nhds_zero MeasureTheory.Integrable.tendsto_set_integral_nhds_zero

/-- If `F i ‚Üí f` in `L1`, then `‚à´ x, F i x ‚àÇŒº ‚Üí ‚à´ x, f x ‚àÇŒº`. -/
theorem tendsto_integral_of_L1 {Œπ} (f : Œ± ‚Üí G) (hfi : Integrable f Œº) {F : Œπ ‚Üí Œ± ‚Üí G} {l : Filter Œπ}
    (hFi : ‚àÄ·∂† i in l, Integrable (F i) Œº)
    (hF : Tendsto (fun i => ‚à´‚Åª x, ‚ÄñF i x - f x‚Äñ‚Çä ‚àÇŒº) l (ùìù 0)) :
    Tendsto (fun i => ‚à´ x, F i x ‚àÇŒº) l (ùìù <| ‚à´ x, f x ‚àÇŒº) := by
  by_cases hG : CompleteSpace G
  ¬∑ simp only [integral, hG, L1.integral]
    exact tendsto_setToFun_of_L1 (dominatedFinMeasAdditive_weightedSMul Œº) f hfi hFi hF
  ¬∑ simp [integral, hG, tendsto_const_nhds]
set_option linter.uppercaseLean3 false in
#align measure_theory.tendsto_integral_of_L1 MeasureTheory.tendsto_integral_of_L1

/-- **Lebesgue dominated convergence theorem** provides sufficient conditions under which almost
  everywhere convergence of a sequence of functions implies the convergence of their integrals.
  We could weaken the condition `bound_integrable` to require `HasFiniteIntegral bound Œº` instead
  (i.e. not requiring that `bound` is measurable), but in all applications proving integrability
  is easier. -/
theorem tendsto_integral_of_dominated_convergence {F : ‚Ñï ‚Üí Œ± ‚Üí G} {f : Œ± ‚Üí G} (bound : Œ± ‚Üí ‚Ñù)
    (F_measurable : ‚àÄ n, AEStronglyMeasurable (F n) Œº) (bound_integrable : Integrable bound Œº)
    (h_bound : ‚àÄ n, ‚àÄ·µê a ‚àÇŒº, ‚ÄñF n a‚Äñ ‚â§ bound a)
    (h_lim : ‚àÄ·µê a ‚àÇŒº, Tendsto (fun n => F n a) atTop (ùìù (f a))) :
    Tendsto (fun n => ‚à´ a, F n a ‚àÇŒº) atTop (ùìù <| ‚à´ a, f a ‚àÇŒº) := by
  by_cases hG : CompleteSpace G
  ¬∑ simp only [integral, hG, L1.integral]
    exact tendsto_setToFun_of_dominated_convergence (dominatedFinMeasAdditive_weightedSMul Œº)
      bound F_measurable bound_integrable h_bound h_lim
  ¬∑ simp [integral, hG]
#align measure_theory.tendsto_integral_of_dominated_convergence MeasureTheory.tendsto_integral_of_dominated_convergence

/-- Lebesgue dominated convergence theorem for filters with a countable basis -/
theorem tendsto_integral_filter_of_dominated_convergence {Œπ} {l : Filter Œπ} [l.IsCountablyGenerated]
    {F : Œπ ‚Üí Œ± ‚Üí G} {f : Œ± ‚Üí G} (bound : Œ± ‚Üí ‚Ñù) (hF_meas : ‚àÄ·∂† n in l, AEStronglyMeasurable (F n) Œº)
    (h_bound : ‚àÄ·∂† n in l, ‚àÄ·µê a ‚àÇŒº, ‚ÄñF n a‚Äñ ‚â§ bound a) (bound_integrable : Integrable bound Œº)
    (h_lim : ‚àÄ·µê a ‚àÇŒº, Tendsto (fun n => F n a) l (ùìù (f a))) :
    Tendsto (fun n => ‚à´ a, F n a ‚àÇŒº) l (ùìù <| ‚à´ a, f a ‚àÇŒº) := by
  by_cases hG : CompleteSpace G
  ¬∑ simp only [integral, hG, L1.integral]
    exact tendsto_setToFun_filter_of_dominated_convergence (dominatedFinMeasAdditive_weightedSMul Œº)
      bound hF_meas h_bound bound_integrable h_lim
  ¬∑ simp [integral, hG, tendsto_const_nhds]
#align measure_theory.tendsto_integral_filter_of_dominated_convergence MeasureTheory.tendsto_integral_filter_of_dominated_convergence

/-- Lebesgue dominated convergence theorem for series. -/
theorem hasSum_integral_of_dominated_convergence {Œπ} [Countable Œπ] {F : Œπ ‚Üí Œ± ‚Üí G} {f : Œ± ‚Üí G}
    (bound : Œπ ‚Üí Œ± ‚Üí ‚Ñù) (hF_meas : ‚àÄ n, AEStronglyMeasurable (F n) Œº)
    (h_bound : ‚àÄ n, ‚àÄ·µê a ‚àÇŒº, ‚ÄñF n a‚Äñ ‚â§ bound n a)
    (bound_summable : ‚àÄ·µê a ‚àÇŒº, Summable fun n => bound n a)
    (bound_integrable : Integrable (fun a => ‚àë' n, bound n a) Œº)
    (h_lim : ‚àÄ·µê a ‚àÇŒº, HasSum (fun n => F n a) (f a)) :
    HasSum (fun n => ‚à´ a, F n a ‚àÇŒº) (‚à´ a, f a ‚àÇŒº) := by
  have hb_nonneg : ‚àÄ·µê a ‚àÇŒº, ‚àÄ n, 0 ‚â§ bound n a :=
    eventually_countable_forall.2 fun n => (h_bound n).mono fun a => (norm_nonneg _).trans
  have hb_le_tsum : ‚àÄ n, bound n ‚â§·µê[Œº] fun a => ‚àë' n, bound n a := by
    intro n
    filter_upwards [hb_nonneg, bound_summable]
      with _ ha0 ha_sum using le_tsum ha_sum _ fun i _ => ha0 i
  have hF_integrable : ‚àÄ n, Integrable (F n) Œº := by
    refine' fun n => bound_integrable.mono' (hF_meas n) _
    exact EventuallyLE.trans (h_bound n) (hb_le_tsum n)
  simp only [HasSum, ‚Üê integral_finset_sum _ fun n _ => hF_integrable n]
  refine' tendsto_integral_filter_of_dominated_convergence
      (fun a => ‚àë' n, bound n a) _ _ bound_integrable h_lim
  ¬∑ exact eventually_of_forall fun s => s.aestronglyMeasurable_sum fun n _ => hF_meas n
  ¬∑ refine' eventually_of_forall fun s => _
    filter_upwards [eventually_countable_forall.2 h_bound, hb_nonneg, bound_summable]
      with a hFa ha0 has
    calc
      ‚Äñ‚àë n in s, F n a‚Äñ ‚â§ ‚àë n in s, bound n a := norm_sum_le_of_le _ fun n _ => hFa n
      _ ‚â§ ‚àë' n, bound n a := sum_le_tsum _ (fun n _ => ha0 n) has
#align measure_theory.has_sum_integral_of_dominated_convergence MeasureTheory.hasSum_integral_of_dominated_convergence

variable {X : Type*} [TopologicalSpace X] [FirstCountableTopology X]

theorem continuousWithinAt_of_dominated {F : X ‚Üí Œ± ‚Üí G} {x‚ÇÄ : X} {bound : Œ± ‚Üí ‚Ñù} {s : Set X}
    (hF_meas : ‚àÄ·∂† x in ùìù[s] x‚ÇÄ, AEStronglyMeasurable (F x) Œº)
    (h_bound : ‚àÄ·∂† x in ùìù[s] x‚ÇÄ, ‚àÄ·µê a ‚àÇŒº, ‚ÄñF x a‚Äñ ‚â§ bound a) (bound_integrable : Integrable bound Œº)
    (h_cont : ‚àÄ·µê a ‚àÇŒº, ContinuousWithinAt (fun x => F x a) s x‚ÇÄ) :
    ContinuousWithinAt (fun x => ‚à´ a, F x a ‚àÇŒº) s x‚ÇÄ := by
  by_cases hG : CompleteSpace G
  ¬∑ simp only [integral, hG, L1.integral]
    exact continuousWithinAt_setToFun_of_dominated (dominatedFinMeasAdditive_weightedSMul Œº)
      hF_meas h_bound bound_integrable h_cont
  ¬∑ simp [integral, hG, continuousWithinAt_const]
#align measure_theory.continuous_within_at_of_dominated MeasureTheory.continuousWithinAt_of_dominated

theorem continuousAt_of_dominated {F : X ‚Üí Œ± ‚Üí G} {x‚ÇÄ : X} {bound : Œ± ‚Üí ‚Ñù}
    (hF_meas : ‚àÄ·∂† x in ùìù x‚ÇÄ, AEStronglyMeasurable (F x) Œº)
    (h_bound : ‚àÄ·∂† x in ùìù x‚ÇÄ, ‚àÄ·µê a ‚àÇŒº, ‚ÄñF x a‚Äñ ‚â§ bound a) (bound_integrable : Integrable bound Œº)
    (h_cont : ‚àÄ·µê a ‚àÇŒº, ContinuousAt (fun x => F x a) x‚ÇÄ) :
    ContinuousAt (fun x => ‚à´ a, F x a ‚àÇŒº) x‚ÇÄ := by
  by_cases hG : CompleteSpace G
  ¬∑ simp only [integral, hG, L1.integral]
    exact continuousAt_setToFun_of_dominated (dominatedFinMeasAdditive_weightedSMul Œº)
      hF_meas h_bound bound_integrable h_cont
  ¬∑ simp [integral, hG, continuousAt_const]
#align measure_theory.continuous_at_of_dominated MeasureTheory.continuousAt_of_dominated

theorem continuousOn_of_dominated {F : X ‚Üí Œ± ‚Üí G} {bound : Œ± ‚Üí ‚Ñù} {s : Set X}
    (hF_meas : ‚àÄ x ‚àà s, AEStronglyMeasurable (F x) Œº)
    (h_bound : ‚àÄ x ‚àà s, ‚àÄ·µê a ‚àÇŒº, ‚ÄñF x a‚Äñ ‚â§ bound a) (bound_integrable : Integrable bound Œº)
    (h_cont : ‚àÄ·µê a ‚àÇŒº, ContinuousOn (fun x => F x a) s) :
    ContinuousOn (fun x => ‚à´ a, F x a ‚àÇŒº) s := by
  by_cases hG : CompleteSpace G
  ¬∑ simp only [integral, hG, L1.integral]
    exact continuousOn_setToFun_of_dominated (dominatedFinMeasAdditive_weightedSMul Œº)
      hF_meas h_bound bound_integrable h_cont
  ¬∑ simp [integral, hG, continuousOn_const]
#align measure_theory.continuous_on_of_dominated MeasureTheory.continuousOn_of_dominated

theorem continuous_of_dominated {F : X ‚Üí Œ± ‚Üí G} {bound : Œ± ‚Üí ‚Ñù}
    (hF_meas : ‚àÄ x, AEStronglyMeasurable (F x) Œº) (h_bound : ‚àÄ x, ‚àÄ·µê a ‚àÇŒº, ‚ÄñF x a‚Äñ ‚â§ bound a)
    (bound_integrable : Integrable bound Œº) (h_cont : ‚àÄ·µê a ‚àÇŒº, Continuous fun x => F x a) :
    Continuous fun x => ‚à´ a, F x a ‚àÇŒº := by
  by_cases hG : CompleteSpace G
  ¬∑ simp only [integral, hG, L1.integral]
    exact continuous_setToFun_of_dominated (dominatedFinMeasAdditive_weightedSMul Œº)
      hF_meas h_bound bound_integrable h_cont
  ¬∑ simp [integral, hG, continuous_const]
#align measure_theory.continuous_of_dominated MeasureTheory.continuous_of_dominated

/-- The Bochner integral of a real-valued function `f : Œ± ‚Üí ‚Ñù` is the difference between the
  integral of the positive part of `f` and the integral of the negative part of `f`.  -/
theorem integral_eq_lintegral_pos_part_sub_lintegral_neg_part {f : Œ± ‚Üí ‚Ñù} (hf : Integrable f Œº) :
    ‚à´ a, f a ‚àÇŒº =
      ENNReal.toReal (‚à´‚Åª a, .ofReal (f a) ‚àÇŒº) - ENNReal.toReal (‚à´‚Åª a, .ofReal (-f a) ‚àÇŒº) := by
  let f‚ÇÅ := hf.toL1 f
  -- Go to the `L¬π` space
  have eq‚ÇÅ : ENNReal.toReal (‚à´‚Åª a, ENNReal.ofReal (f a) ‚àÇŒº) = ‚ÄñLp.posPart f‚ÇÅ‚Äñ := by
    rw [L1.norm_def]
    congr 1
    apply lintegral_congr_ae
    filter_upwards [Lp.coeFn_posPart f‚ÇÅ, hf.coeFn_toL1] with _ h‚ÇÅ h‚ÇÇ
    rw [h‚ÇÅ, h‚ÇÇ, ENNReal.ofReal]
    congr 1
    apply NNReal.eq
    rw [Real.nnnorm_of_nonneg (le_max_right _ _)]
    rw [Real.coe_toNNReal', NNReal.coe_mk]
  -- Go to the `L¬π` space
  have eq‚ÇÇ : ENNReal.toReal (‚à´‚Åª a, ENNReal.ofReal (-f a) ‚àÇŒº) = ‚ÄñLp.negPart f‚ÇÅ‚Äñ := by
    rw [L1.norm_def]
    congr 1
    apply lintegral_congr_ae
    filter_upwards [Lp.coeFn_negPart f‚ÇÅ, hf.coeFn_toL1] with _ h‚ÇÅ h‚ÇÇ
    rw [h‚ÇÅ, h‚ÇÇ, ENNReal.ofReal]
    congr 1
    apply NNReal.eq
    simp only [Real.coe_toNNReal', coe_nnnorm, nnnorm_neg]
    rw [Real.norm_of_nonpos (min_le_right _ _), ‚Üê max_neg_neg, neg_zero]
  rw [eq‚ÇÅ, eq‚ÇÇ, integral, dif_pos, dif_pos]
  exact L1.integral_eq_norm_posPart_sub _
#align measure_theory.integral_eq_lintegral_pos_part_sub_lintegral_neg_part MeasureTheory.integral_eq_lintegral_pos_part_sub_lintegral_neg_part

theorem integral_eq_lintegral_of_nonneg_ae {f : Œ± ‚Üí ‚Ñù} (hf : 0 ‚â§·µê[Œº] f)
    (hfm : AEStronglyMeasurable f Œº) :
    ‚à´ a, f a ‚àÇŒº = ENNReal.toReal (‚à´‚Åª a, ENNReal.ofReal (f a) ‚àÇŒº) := by
  by_cases hfi : Integrable f Œº
  ¬∑ rw [integral_eq_lintegral_pos_part_sub_lintegral_neg_part hfi]
    have h_min : ‚à´‚Åª a, ENNReal.ofReal (-f a) ‚àÇŒº = 0 := by
      rw [lintegral_eq_zero_iff']
      ¬∑ refine' hf.mono _
        simp only [Pi.zero_apply]
        intro a h
        simp only [h, neg_nonpos, ofReal_eq_zero]
      ¬∑ exact measurable_ofReal.comp_aemeasurable hfm.aemeasurable.neg
    rw [h_min, zero_toReal, _root_.sub_zero]
  ¬∑ rw [integral_undef hfi]
    simp_rw [Integrable, hfm, hasFiniteIntegral_iff_norm, lt_top_iff_ne_top, Ne.def, true_and_iff,
      Classical.not_not] at hfi
    have : ‚à´‚Åª a : Œ±, ENNReal.ofReal (f a) ‚àÇŒº = ‚à´‚Åª a, ENNReal.ofReal ‚Äñf a‚Äñ ‚àÇŒº := by
      refine' lintegral_congr_ae (hf.mono fun a h => _)
      dsimp only
      rw [Real.norm_eq_abs, abs_of_nonneg h]
    rw [this, hfi]; rfl
#align measure_theory.integral_eq_lintegral_of_nonneg_ae MeasureTheory.integral_eq_lintegral_of_nonneg_ae

theorem integral_norm_eq_lintegral_nnnorm {P : Type*} [NormedAddCommGroup P] {f : Œ± ‚Üí P}
    (hf : AEStronglyMeasurable f Œº) : ‚à´ x, ‚Äñf x‚Äñ ‚àÇŒº = ENNReal.toReal (‚à´‚Åª x, ‚Äñf x‚Äñ‚Çä ‚àÇŒº) := by
  rw [integral_eq_lintegral_of_nonneg_ae _ hf.norm]
  ¬∑ simp_rw [ofReal_norm_eq_coe_nnnorm]
  ¬∑ refine' ae_of_all _ _; simp_rw [Pi.zero_apply, norm_nonneg, imp_true_iff]
#align measure_theory.integral_norm_eq_lintegral_nnnorm MeasureTheory.integral_norm_eq_lintegral_nnnorm

theorem ofReal_integral_norm_eq_lintegral_nnnorm {P : Type*} [NormedAddCommGroup P] {f : Œ± ‚Üí P}
    (hf : Integrable f Œº) : ENNReal.ofReal (‚à´ x, ‚Äñf x‚Äñ ‚àÇŒº) = ‚à´‚Åª x, ‚Äñf x‚Äñ‚Çä ‚àÇŒº := by
  rw [integral_norm_eq_lintegral_nnnorm hf.aestronglyMeasurable,
    ENNReal.ofReal_toReal (lt_top_iff_ne_top.mp hf.2)]
#align measure_theory.of_real_integral_norm_eq_lintegral_nnnorm MeasureTheory.ofReal_integral_norm_eq_lintegral_nnnorm

theorem integral_eq_integral_pos_part_sub_integral_neg_part {f : Œ± ‚Üí ‚Ñù} (hf : Integrable f Œº) :
    ‚à´ a, f a ‚àÇŒº = ‚à´ a, (Real.toNNReal (f a) : ‚Ñù) ‚àÇŒº - ‚à´ a, (Real.toNNReal (-f a) : ‚Ñù) ‚àÇŒº := by
  rw [‚Üê integral_sub hf.real_toNNReal]
  ¬∑ simp
  ¬∑ exact hf.neg.real_toNNReal
#align measure_theory.integral_eq_integral_pos_part_sub_integral_neg_part MeasureTheory.integral_eq_integral_pos_part_sub_integral_neg_part

theorem integral_nonneg_of_ae {f : Œ± ‚Üí ‚Ñù} (hf : 0 ‚â§·µê[Œº] f) : 0 ‚â§ ‚à´ a, f a ‚àÇŒº := by
  have A : CompleteSpace ‚Ñù := by infer_instance
  simp only [integral_def, A, L1.integral_def, dite_true, ge_iff_le]
  exact setToFun_nonneg (dominatedFinMeasAdditive_weightedSMul Œº)
    (fun s _ _ => weightedSMul_nonneg s) hf
#align measure_theory.integral_nonneg_of_ae MeasureTheory.integral_nonneg_of_ae

theorem lintegral_coe_eq_integral (f : Œ± ‚Üí ‚Ñù‚â•0) (hfi : Integrable (fun x => (f x : ‚Ñù)) Œº) :
    ‚à´‚Åª a, f a ‚àÇŒº = ENNReal.ofReal (‚à´ a, f a ‚àÇŒº) := by
  simp_rw [integral_eq_lintegral_of_nonneg_ae (eventually_of_forall fun x => (f x).coe_nonneg)
      hfi.aestronglyMeasurable, ‚Üê ENNReal.coe_nnreal_eq]
  rw [ENNReal.ofReal_toReal]
  rw [‚Üê lt_top_iff_ne_top]
  convert hfi.hasFiniteIntegral
  -- Porting note: `convert` no longer unfolds `HasFiniteIntegral`
  simp_rw [HasFiniteIntegral, NNReal.nnnorm_eq]
#align measure_theory.lintegral_coe_eq_integral MeasureTheory.lintegral_coe_eq_integral

theorem ofReal_integral_eq_lintegral_ofReal {f : Œ± ‚Üí ‚Ñù} (hfi : Integrable f Œº) (f_nn : 0 ‚â§·µê[Œº] f) :
    ENNReal.ofReal (‚à´ x, f x ‚àÇŒº) = ‚à´‚Åª x, ENNReal.ofReal (f x) ‚àÇŒº := by
  simp_rw [integral_congr_ae (show f =·µê[Œº] fun x => ‚Äñf x‚Äñ by
      filter_upwards [f_nn] with x hx
      rw [Real.norm_eq_abs, abs_eq_self.mpr hx]),
    ofReal_integral_norm_eq_lintegral_nnnorm hfi, ‚Üê ofReal_norm_eq_coe_nnnorm]
  apply lintegral_congr_ae
  filter_upwards [f_nn] with x hx
  exact congr_arg ENNReal.ofReal (by rw [Real.norm_eq_abs, abs_eq_self.mpr hx])
#align measure_theory.of_real_integral_eq_lintegral_of_real MeasureTheory.ofReal_integral_eq_lintegral_ofReal

theorem integral_toReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hfm : AEMeasurable f Œº) (hf : ‚àÄ·µê x ‚àÇŒº, f x < ‚àû) :
    ‚à´ a, (f a).toReal ‚àÇŒº = (‚à´‚Åª a, f a ‚àÇŒº).toReal := by
  rw [integral_eq_lintegral_of_nonneg_ae _ hfm.ennreal_toReal.aestronglyMeasurable]
  ¬∑ rw [lintegral_congr_ae]; refine' hf.mp (eventually_of_forall _)
    intro x hx; rw [lt_top_iff_ne_top] at hx; simp [hx]
  ¬∑ exact eventually_of_forall fun x => ENNReal.toReal_nonneg
#align measure_theory.integral_to_real MeasureTheory.integral_toReal

theorem lintegral_coe_le_coe_iff_integral_le {f : Œ± ‚Üí ‚Ñù‚â•0} (hfi : Integrable (fun x => (f x : ‚Ñù)) Œº)
    {b : ‚Ñù‚â•0} : ‚à´‚Åª a, f a ‚àÇŒº ‚â§ b ‚Üî ‚à´ a, (f a : ‚Ñù) ‚àÇŒº ‚â§ b := by
  rw [lintegral_coe_eq_integral f hfi, ENNReal.ofReal, ENNReal.coe_le_coe,
    Real.toNNReal_le_iff_le_coe]
#align measure_theory.lintegral_coe_le_coe_iff_integral_le MeasureTheory.lintegral_coe_le_coe_iff_integral_le

theorem integral_coe_le_of_lintegral_coe_le {f : Œ± ‚Üí ‚Ñù‚â•0} {b : ‚Ñù‚â•0} (h : ‚à´‚Åª a, f a ‚àÇŒº ‚â§ b) :
    ‚à´ a, (f a : ‚Ñù) ‚àÇŒº ‚â§ b := by
  by_cases hf : Integrable (fun a => (f a : ‚Ñù)) Œº
  ¬∑ exact (lintegral_coe_le_coe_iff_integral_le hf).1 h
  ¬∑ rw [integral_undef hf]; exact b.2
#align measure_theory.integral_coe_le_of_lintegral_coe_le MeasureTheory.integral_coe_le_of_lintegral_coe_le

theorem integral_nonneg {f : Œ± ‚Üí ‚Ñù} (hf : 0 ‚â§ f) : 0 ‚â§ ‚à´ a, f a ‚àÇŒº :=
  integral_nonneg_of_ae <| eventually_of_forall hf
#align measure_theory.integral_nonneg MeasureTheory.integral_nonneg

theorem integral_nonpos_of_ae {f : Œ± ‚Üí ‚Ñù} (hf : f ‚â§·µê[Œº] 0) : ‚à´ a, f a ‚àÇŒº ‚â§ 0 := by
  have hf : 0 ‚â§·µê[Œº] -f := hf.mono fun a h => by rwa [Pi.neg_apply, Pi.zero_apply, neg_nonneg]
  have : 0 ‚â§ ‚à´ a, -f a ‚àÇŒº := integral_nonneg_of_ae hf
  rwa [integral_neg, neg_nonneg] at this
#align measure_theory.integral_nonpos_of_ae MeasureTheory.integral_nonpos_of_ae

theorem integral_nonpos {f : Œ± ‚Üí ‚Ñù} (hf : f ‚â§ 0) : ‚à´ a, f a ‚àÇŒº ‚â§ 0 :=
  integral_nonpos_of_ae <| eventually_of_forall hf
#align measure_theory.integral_nonpos MeasureTheory.integral_nonpos

theorem integral_eq_zero_iff_of_nonneg_ae {f : Œ± ‚Üí ‚Ñù} (hf : 0 ‚â§·µê[Œº] f) (hfi : Integrable f Œº) :
    ‚à´ x, f x ‚àÇŒº = 0 ‚Üî f =·µê[Œº] 0 := by
  simp_rw [integral_eq_lintegral_of_nonneg_ae hf hfi.1, ENNReal.toReal_eq_zero_iff,
    ‚Üê ENNReal.not_lt_top, ‚Üê hasFiniteIntegral_iff_ofReal hf, hfi.2, not_true_eq_false, or_false_iff]
  -- Porting note: split into parts, to make `rw` and `simp` work
  rw [lintegral_eq_zero_iff']
  ¬∑ rw [‚Üê hf.le_iff_eq, Filter.EventuallyEq, Filter.EventuallyLE]
    simp only [Pi.zero_apply, ofReal_eq_zero]
  ¬∑ exact (ENNReal.measurable_ofReal.comp_aemeasurable hfi.1.aemeasurable)

#align measure_theory.integral_eq_zero_iff_of_nonneg_ae MeasureTheory.integral_eq_zero_iff_of_nonneg_ae

theorem integral_eq_zero_iff_of_nonneg {f : Œ± ‚Üí ‚Ñù} (hf : 0 ‚â§ f) (hfi : Integrable f Œº) :
    ‚à´ x, f x ‚àÇŒº = 0 ‚Üî f =·µê[Œº] 0 :=
  integral_eq_zero_iff_of_nonneg_ae (eventually_of_forall hf) hfi
#align measure_theory.integral_eq_zero_iff_of_nonneg MeasureTheory.integral_eq_zero_iff_of_nonneg

theorem integral_pos_iff_support_of_nonneg_ae {f : Œ± ‚Üí ‚Ñù} (hf : 0 ‚â§·µê[Œº] f) (hfi : Integrable f Œº) :
    (0 < ‚à´ x, f x ‚àÇŒº) ‚Üî 0 < Œº (Function.support f) := by
  simp_rw [(integral_nonneg_of_ae hf).lt_iff_ne, pos_iff_ne_zero, Ne.def, @eq_comm ‚Ñù 0,
    integral_eq_zero_iff_of_nonneg_ae hf hfi, Filter.EventuallyEq, ae_iff, Pi.zero_apply,
    Function.support]
#align measure_theory.integral_pos_iff_support_of_nonneg_ae MeasureTheory.integral_pos_iff_support_of_nonneg_ae

theorem integral_pos_iff_support_of_nonneg {f : Œ± ‚Üí ‚Ñù} (hf : 0 ‚â§ f) (hfi : Integrable f Œº) :
    (0 < ‚à´ x, f x ‚àÇŒº) ‚Üî 0 < Œº (Function.support f) :=
  integral_pos_iff_support_of_nonneg_ae (eventually_of_forall hf) hfi
#align measure_theory.integral_pos_iff_support_of_nonneg MeasureTheory.integral_pos_iff_support_of_nonneg

lemma integral_exp_pos {Œº : Measure Œ±} {f : Œ± ‚Üí ‚Ñù} [hŒº : NeZero Œº]
    (hf : Integrable (fun x ‚Ü¶ Real.exp (f x)) Œº) :
    0 < ‚à´ x, Real.exp (f x) ‚àÇŒº := by
  rw [integral_pos_iff_support_of_nonneg (fun x ‚Ü¶ (Real.exp_pos _).le) hf]
  suffices (Function.support fun x ‚Ü¶ Real.exp (f x)) = Set.univ by simp [this, hŒº.out]
  ext1 x
  simp only [Function.mem_support, ne_eq, (Real.exp_pos _).ne', not_false_eq_true, Set.mem_univ]

section NormedAddCommGroup

variable {H : Type*} [NormedAddCommGroup H]

theorem L1.norm_eq_integral_norm (f : Œ± ‚Üí‚ÇÅ[Œº] H) : ‚Äñf‚Äñ = ‚à´ a, ‚Äñf a‚Äñ ‚àÇŒº := by
  simp only [snorm, snorm', ENNReal.one_toReal, ENNReal.rpow_one, Lp.norm_def, if_false,
    ENNReal.one_ne_top, one_ne_zero, _root_.div_one]
  rw [integral_eq_lintegral_of_nonneg_ae (eventually_of_forall (by simp [norm_nonneg]))
      (Lp.aestronglyMeasurable f).norm]
  simp [ofReal_norm_eq_coe_nnnorm]
set_option linter.uppercaseLean3 false in
#align measure_theory.L1.norm_eq_integral_norm MeasureTheory.L1.norm_eq_integral_norm

theorem L1.dist_eq_integral_dist (f g : Œ± ‚Üí‚ÇÅ[Œº] H) : dist f g = ‚à´ a, dist (f a) (g a) ‚àÇŒº := by
  simp only [dist_eq_norm, L1.norm_eq_integral_norm]
  exact integral_congr_ae <| (Lp.coeFn_sub _ _).fun_comp norm

theorem L1.norm_of_fun_eq_integral_norm {f : Œ± ‚Üí H} (hf : Integrable f Œº) :
    ‚Äñhf.toL1 f‚Äñ = ‚à´ a, ‚Äñf a‚Äñ ‚àÇŒº := by
  rw [L1.norm_eq_integral_norm]
  refine' integral_congr_ae _
  apply hf.coeFn_toL1.mono
  intro a ha
  simp_rw [ha]
set_option linter.uppercaseLean3 false in
#align measure_theory.L1.norm_of_fun_eq_integral_norm MeasureTheory.L1.norm_of_fun_eq_integral_norm

theorem Mem‚Ñíp.snorm_eq_integral_rpow_norm {f : Œ± ‚Üí H} {p : ‚Ñù‚â•0‚àû} (hp1 : p ‚â† 0) (hp2 : p ‚â† ‚àû)
    (hf : Mem‚Ñíp f p Œº) :
    snorm f p Œº = ENNReal.ofReal ((‚à´ a, ‚Äñf a‚Äñ ^ p.toReal ‚àÇŒº) ^ p.toReal‚Åª¬π) := by
  have A : ‚à´‚Åª a : Œ±, ENNReal.ofReal (‚Äñf a‚Äñ ^ p.toReal) ‚àÇŒº = ‚à´‚Åª a : Œ±, ‚Äñf a‚Äñ‚Çä ^ p.toReal ‚àÇŒº := by
    apply lintegral_congr
    intro x
    rw [‚Üê ofReal_rpow_of_nonneg (norm_nonneg _) toReal_nonneg, ofReal_norm_eq_coe_nnnorm]
  simp only [snorm_eq_lintegral_rpow_nnnorm hp1 hp2, one_div]
  rw [integral_eq_lintegral_of_nonneg_ae]; rotate_left
  ¬∑ exact eventually_of_forall fun x => Real.rpow_nonneg_of_nonneg (norm_nonneg _) _
  ¬∑ exact (hf.aestronglyMeasurable.norm.aemeasurable.pow_const _).aestronglyMeasurable
  rw [A, ‚Üê ofReal_rpow_of_nonneg toReal_nonneg (inv_nonneg.2 toReal_nonneg), ofReal_toReal]
  exact (lintegral_rpow_nnnorm_lt_top_of_snorm_lt_top hp1 hp2 hf.2).ne
#align measure_theory.mem_‚Ñíp.snorm_eq_integral_rpow_norm MeasureTheory.Mem‚Ñíp.snorm_eq_integral_rpow_norm

end NormedAddCommGroup

theorem integral_mono_ae {f g : Œ± ‚Üí ‚Ñù} (hf : Integrable f Œº) (hg : Integrable g Œº) (h : f ‚â§·µê[Œº] g) :
    ‚à´ a, f a ‚àÇŒº ‚â§ ‚à´ a, g a ‚àÇŒº := by
  have A : CompleteSpace ‚Ñù := by infer_instance
  simp only [integral, A, L1.integral]
  exact setToFun_mono (dominatedFinMeasAdditive_weightedSMul Œº)
    (fun s _ _ => weightedSMul_nonneg s) hf hg h
#align measure_theory.integral_mono_ae MeasureTheory.integral_mono_ae

@[mono]
theorem integral_mono {f g : Œ± ‚Üí ‚Ñù} (hf : Integrable f Œº) (hg : Integrable g Œº) (h : f ‚â§ g) :
    ‚à´ a, f a ‚àÇŒº ‚â§ ‚à´ a, g a ‚àÇŒº :=
  integral_mono_ae hf hg <| eventually_of_forall h
#align measure_theory.integral_mono MeasureTheory.integral_mono

theorem integral_mono_of_nonneg {f g : Œ± ‚Üí ‚Ñù} (hf : 0 ‚â§·µê[Œº] f) (hgi : Integrable g Œº)
    (h : f ‚â§·µê[Œº] g) : ‚à´ a, f a ‚àÇŒº ‚â§ ‚à´ a, g a ‚àÇŒº := by
  by_cases hfm : AEStronglyMeasurable f Œº
  ¬∑ refine' integral_mono_ae ‚ü®hfm, _‚ü© hgi h
    refine' hgi.hasFiniteIntegral.mono <| h.mp <| hf.mono fun x hf hfg => _
    simpa [abs_of_nonneg hf, abs_of_nonneg (le_trans hf hfg)]
  ¬∑ rw [integral_non_aestronglyMeasurable hfm]
    exact integral_nonneg_of_ae (hf.trans h)
#align measure_theory.integral_mono_of_nonneg MeasureTheory.integral_mono_of_nonneg

theorem integral_mono_measure {f : Œ± ‚Üí ‚Ñù} {ŒΩ} (hle : Œº ‚â§ ŒΩ) (hf : 0 ‚â§·µê[ŒΩ] f)
    (hfi : Integrable f ŒΩ) : ‚à´ a, f a ‚àÇŒº ‚â§ ‚à´ a, f a ‚àÇŒΩ := by
  have hfi' : Integrable f Œº := hfi.mono_measure hle
  have hf' : 0 ‚â§·µê[Œº] f := hle.absolutelyContinuous hf
  rw [integral_eq_lintegral_of_nonneg_ae hf' hfi'.1, integral_eq_lintegral_of_nonneg_ae hf hfi.1,
    ENNReal.toReal_le_toReal]
  exacts [lintegral_mono' hle le_rfl, ((hasFiniteIntegral_iff_ofReal hf').1 hfi'.2).ne,
    ((hasFiniteIntegral_iff_ofReal hf).1 hfi.2).ne]
#align measure_theory.integral_mono_measure MeasureTheory.integral_mono_measure

theorem norm_integral_le_integral_norm (f : Œ± ‚Üí G) : ‚Äñ‚à´ a, f a ‚àÇŒº‚Äñ ‚â§ ‚à´ a, ‚Äñf a‚Äñ ‚àÇŒº :=
  have le_ae : ‚àÄ·µê a ‚àÇŒº, 0 ‚â§ ‚Äñf a‚Äñ := eventually_of_forall fun a => norm_nonneg _
  by_cases
    (fun h : AEStronglyMeasurable f Œº =>
      calc
        ‚Äñ‚à´ a, f a ‚àÇŒº‚Äñ ‚â§ ENNReal.toReal (‚à´‚Åª a, ENNReal.ofReal ‚Äñf a‚Äñ ‚àÇŒº) :=
          norm_integral_le_lintegral_norm _
        _ = ‚à´ a, ‚Äñf a‚Äñ ‚àÇŒº := (integral_eq_lintegral_of_nonneg_ae le_ae <| h.norm).symm)
    fun h : ¬¨AEStronglyMeasurable f Œº => by
      rw [integral_non_aestronglyMeasurable h, norm_zero]
      exact integral_nonneg_of_ae le_ae
#align measure_theory.norm_integral_le_integral_norm MeasureTheory.norm_integral_le_integral_norm

theorem norm_integral_le_of_norm_le {f : Œ± ‚Üí G} {g : Œ± ‚Üí ‚Ñù} (hg : Integrable g Œº)
    (h : ‚àÄ·µê x ‚àÇŒº, ‚Äñf x‚Äñ ‚â§ g x) : ‚Äñ‚à´ x, f x ‚àÇŒº‚Äñ ‚â§ ‚à´ x, g x ‚àÇŒº :=
  calc
    ‚Äñ‚à´ x, f x ‚àÇŒº‚Äñ ‚â§ ‚à´ x, ‚Äñf x‚Äñ ‚àÇŒº := norm_integral_le_integral_norm f
    _ ‚â§ ‚à´ x, g x ‚àÇŒº := integral_mono_of_nonneg (eventually_of_forall fun _ => norm_nonneg _) hg h
#align measure_theory.norm_integral_le_of_norm_le MeasureTheory.norm_integral_le_of_norm_le

theorem SimpleFunc.integral_eq_integral (f : Œ± ‚Üí‚Çõ E) (hfi : Integrable f Œº) :
    f.integral Œº = ‚à´ x, f x ‚àÇŒº := by
  rw [MeasureTheory.integral_eq f hfi, ‚Üê L1.SimpleFunc.toLp_one_eq_toL1,
    L1.SimpleFunc.integral_L1_eq_integral, L1.SimpleFunc.integral_eq_integral]
  exact SimpleFunc.integral_congr hfi (Lp.simpleFunc.toSimpleFunc_toLp _ _).symm
#align measure_theory.simple_func.integral_eq_integral MeasureTheory.SimpleFunc.integral_eq_integral

theorem SimpleFunc.integral_eq_sum (f : Œ± ‚Üí‚Çõ E) (hfi : Integrable f Œº) :
    ‚à´ x, f x ‚àÇŒº = ‚àë x in f.range, ENNReal.toReal (Œº (f ‚Åª¬π' {x})) ‚Ä¢ x := by
  rw [‚Üê f.integral_eq_integral hfi, SimpleFunc.integral, ‚Üê SimpleFunc.integral_eq]; rfl
#align measure_theory.simple_func.integral_eq_sum MeasureTheory.SimpleFunc.integral_eq_sum

@[simp]
theorem integral_const (c : E) : ‚à´ _ : Œ±, c ‚àÇŒº = (Œº univ).toReal ‚Ä¢ c := by
  cases' (@le_top _ _ _ (Œº univ)).lt_or_eq with hŒº hŒº
  ¬∑ haveI : IsFiniteMeasure Œº := ‚ü®hŒº‚ü©
    simp only [integral, hE, L1.integral]
    exact setToFun_const (dominatedFinMeasAdditive_weightedSMul _) _
  ¬∑ by_cases hc : c = 0
    ¬∑ simp [hc, integral_zero]
    ¬∑ have : ¬¨Integrable (fun _ : Œ± => c) Œº := by
        simp only [integrable_const_iff, not_or]
        exact ‚ü®hc, hŒº.not_lt‚ü©
      simp [integral_undef, *]
#align measure_theory.integral_const MeasureTheory.integral_const

theorem norm_integral_le_of_norm_le_const [IsFiniteMeasure Œº] {f : Œ± ‚Üí G} {C : ‚Ñù}
    (h : ‚àÄ·µê x ‚àÇŒº, ‚Äñf x‚Äñ ‚â§ C) : ‚Äñ‚à´ x, f x ‚àÇŒº‚Äñ ‚â§ C * (Œº univ).toReal :=
  calc
    ‚Äñ‚à´ x, f x ‚àÇŒº‚Äñ ‚â§ ‚à´ _, C ‚àÇŒº := norm_integral_le_of_norm_le (integrable_const C) h
    _ = C * (Œº univ).toReal := by rw [integral_const, smul_eq_mul, mul_comm]
#align measure_theory.norm_integral_le_of_norm_le_const MeasureTheory.norm_integral_le_of_norm_le_const

theorem tendsto_integral_approxOn_of_measurable [MeasurableSpace E] [BorelSpace E] {f : Œ± ‚Üí E}
    {s : Set E} [SeparableSpace s] (hfi : Integrable f Œº) (hfm : Measurable f)
    (hs : ‚àÄ·µê x ‚àÇŒº, f x ‚àà closure s) {y‚ÇÄ : E} (h‚ÇÄ : y‚ÇÄ ‚àà s) (h‚ÇÄi : Integrable (fun _ => y‚ÇÄ) Œº) :
    Tendsto (fun n => (SimpleFunc.approxOn f hfm s y‚ÇÄ h‚ÇÄ n).integral Œº)
      atTop (ùìù <| ‚à´ x, f x ‚àÇŒº) := by
  have hfi' := SimpleFunc.integrable_approxOn hfm hfi h‚ÇÄ h‚ÇÄi
  simp only [SimpleFunc.integral_eq_integral _ (hfi' _), integral, hE, L1.integral]
  exact tendsto_setToFun_approxOn_of_measurable (dominatedFinMeasAdditive_weightedSMul Œº)
    hfi hfm hs h‚ÇÄ h‚ÇÄi
#align measure_theory.tendsto_integral_approx_on_of_measurable MeasureTheory.tendsto_integral_approxOn_of_measurable

theorem tendsto_integral_approxOn_of_measurable_of_range_subset [MeasurableSpace E] [BorelSpace E]
    {f : Œ± ‚Üí E} (fmeas : Measurable f) (hf : Integrable f Œº) (s : Set E) [SeparableSpace s]
    (hs : range f ‚à™ {0} ‚äÜ s) :
    Tendsto (fun n => (SimpleFunc.approxOn f fmeas s 0 (hs <| by simp) n).integral Œº) atTop
      (ùìù <| ‚à´ x, f x ‚àÇŒº) := by
  apply tendsto_integral_approxOn_of_measurable hf fmeas _ _ (integrable_zero _ _ _)
  exact eventually_of_forall fun x => subset_closure (hs (Set.mem_union_left _ (mem_range_self _)))
#align measure_theory.tendsto_integral_approx_on_of_measurable_of_range_subset MeasureTheory.tendsto_integral_approxOn_of_measurable_of_range_subset

theorem tendsto_integral_norm_approxOn_sub [MeasurableSpace E] [BorelSpace E] {f : Œ± ‚Üí E}
    (fmeas : Measurable f) (hf : Integrable f Œº) [SeparableSpace (range f ‚à™ {0} : Set E)] :
    Tendsto (fun n ‚Ü¶ ‚à´ x, ‚ÄñSimpleFunc.approxOn f fmeas (range f ‚à™ {0}) 0 (by simp) n x - f x‚Äñ ‚àÇŒº)
      atTop (ùìù 0) := by
  convert (tendsto_toReal zero_ne_top).comp (tendsto_approxOn_range_L1_nnnorm fmeas hf) with n
  rw [integral_norm_eq_lintegral_nnnorm]
  ¬∑ simp
  ¬∑ apply (SimpleFunc.aestronglyMeasurable _).sub
    apply (stronglyMeasurable_iff_measurable_separable.2 ‚ü®fmeas, ?_‚ü© ).aestronglyMeasurable
    exact (isSeparable_of_separableSpace_subtype (range f ‚à™ {0})).mono (subset_union_left _ _)

variable {ŒΩ : Measure Œ±}

theorem integral_add_measure {f : Œ± ‚Üí G} (hŒº : Integrable f Œº) (hŒΩ : Integrable f ŒΩ) :
    ‚à´ x, f x ‚àÇ(Œº + ŒΩ) = ‚à´ x, f x ‚àÇŒº + ‚à´ x, f x ‚àÇŒΩ := by
  by_cases hG : CompleteSpace G; swap
  ¬∑ simp [integral, hG]
  have hfi := hŒº.add_measure hŒΩ
  simp_rw [integral_eq_setToFun]
  have hŒº_dfma : DominatedFinMeasAdditive (Œº + ŒΩ) (weightedSMul Œº : Set Œ± ‚Üí G ‚ÜíL[‚Ñù] G) 1 :=
    DominatedFinMeasAdditive.add_measure_right Œº ŒΩ (dominatedFinMeasAdditive_weightedSMul Œº)
      zero_le_one
  have hŒΩ_dfma : DominatedFinMeasAdditive (Œº + ŒΩ) (weightedSMul ŒΩ : Set Œ± ‚Üí G ‚ÜíL[‚Ñù] G) 1 :=
    DominatedFinMeasAdditive.add_measure_left Œº ŒΩ (dominatedFinMeasAdditive_weightedSMul ŒΩ)
      zero_le_one
  rw [‚Üê setToFun_congr_measure_of_add_right hŒº_dfma
        (dominatedFinMeasAdditive_weightedSMul Œº) f hfi,
    ‚Üê setToFun_congr_measure_of_add_left hŒΩ_dfma (dominatedFinMeasAdditive_weightedSMul ŒΩ) f hfi]
  refine' setToFun_add_left' _ _ _ (fun s _ hŒºŒΩs => _) f
  rw [Measure.coe_add, Pi.add_apply, add_lt_top] at hŒºŒΩs
  rw [weightedSMul, weightedSMul, weightedSMul, ‚Üê add_smul, Measure.coe_add, Pi.add_apply,
  toReal_add hŒºŒΩs.1.ne hŒºŒΩs.2.ne]
#align measure_theory.integral_add_measure MeasureTheory.integral_add_measure

@[simp]
theorem integral_zero_measure {m : MeasurableSpace Œ±} (f : Œ± ‚Üí G) :
    (‚à´ x, f x ‚àÇ(0 : Measure Œ±)) = 0 := by
  by_cases hG : CompleteSpace G
  ¬∑ simp only [integral, hG, L1.integral]
    exact setToFun_measure_zero (dominatedFinMeasAdditive_weightedSMul _) rfl
  ¬∑ simp [integral, hG]
#align measure_theory.integral_zero_measure MeasureTheory.integral_zero_measure

theorem integral_finset_sum_measure {Œπ} {m : MeasurableSpace Œ±} {f : Œ± ‚Üí G} {Œº : Œπ ‚Üí Measure Œ±}
    {s : Finset Œπ} (hf : ‚àÄ i ‚àà s, Integrable f (Œº i)) :
    ‚à´ a, f a ‚àÇ(‚àë i in s, Œº i) = ‚àë i in s, ‚à´ a, f a ‚àÇŒº i := by
  induction s using Finset.cons_induction_on with
  | h‚ÇÅ => simp
  | h‚ÇÇ h ih =>
    rw [Finset.forall_mem_cons] at hf
    rw [Finset.sum_cons, Finset.sum_cons, ‚Üê ih hf.2]
    exact integral_add_measure hf.1 (integrable_finset_sum_measure.2 hf.2)
#align measure_theory.integral_finset_sum_measure MeasureTheory.integral_finset_sum_measure

theorem nndist_integral_add_measure_le_lintegral
    {f : Œ± ‚Üí G} (h‚ÇÅ : Integrable f Œº) (h‚ÇÇ : Integrable f ŒΩ) :
    (nndist (‚à´ x, f x ‚àÇŒº) (‚à´ x, f x ‚àÇ(Œº + ŒΩ)) : ‚Ñù‚â•0‚àû) ‚â§ ‚à´‚Åª x, ‚Äñf x‚Äñ‚Çä ‚àÇŒΩ := by
  rw [integral_add_measure h‚ÇÅ h‚ÇÇ, nndist_comm, nndist_eq_nnnorm, add_sub_cancel']
  exact ennnorm_integral_le_lintegral_ennnorm _
#align measure_theory.nndist_integral_add_measure_le_lintegral MeasureTheory.nndist_integral_add_measure_le_lintegral

theorem hasSum_integral_measure {Œπ} {m : MeasurableSpace Œ±} {f : Œ± ‚Üí G} {Œº : Œπ ‚Üí Measure Œ±}
    (hf : Integrable f (Measure.sum Œº)) :
    HasSum (fun i => ‚à´ a, f a ‚àÇŒº i) (‚à´ a, f a ‚àÇMeasure.sum Œº) := by
  have hfi : ‚àÄ i, Integrable f (Œº i) := fun i => hf.mono_measure (Measure.le_sum _ _)
  simp only [HasSum, ‚Üê integral_finset_sum_measure fun i _ => hfi i]
  refine' Metric.nhds_basis_ball.tendsto_right_iff.mpr fun Œµ Œµ0 => _
  lift Œµ to ‚Ñù‚â•0 using Œµ0.le
  have hf_lt : (‚à´‚Åª x, ‚Äñf x‚Äñ‚Çä ‚àÇMeasure.sum Œº) < ‚àû := hf.2
  have hmem : ‚àÄ·∂† y in ùìù (‚à´‚Åª x, ‚Äñf x‚Äñ‚Çä ‚àÇMeasure.sum Œº), (‚à´‚Åª x, ‚Äñf x‚Äñ‚Çä ‚àÇMeasure.sum Œº) < y + Œµ := by
    refine' tendsto_id.add tendsto_const_nhds (lt_mem_nhds (Œ± := ‚Ñù‚â•0‚àû) <| ENNReal.lt_add_right _ _)
    exacts [hf_lt.ne, ENNReal.coe_ne_zero.2 (NNReal.coe_ne_zero.1 Œµ0.ne')]
  refine' ((hasSum_lintegral_measure (fun x => ‚Äñf x‚Äñ‚Çä) Œº).eventually hmem).mono fun s hs => _
  obtain ‚ü®ŒΩ, hŒΩ‚ü© : ‚àÉ ŒΩ, (‚àë i in s, Œº i) + ŒΩ = Measure.sum Œº := by
    refine' ‚ü®Measure.sum fun i : ‚Ü•(s·∂ú : Set Œπ) => Œº i, _‚ü©
    simpa only [‚Üê Measure.sum_coe_finset] using Measure.sum_add_sum_compl (s : Set Œπ) Œº
  rw [Metric.mem_ball, ‚Üê coe_nndist, NNReal.coe_lt_coe, ‚Üê ENNReal.coe_lt_coe, ‚Üê hŒΩ]
  rw [‚Üê hŒΩ, integrable_add_measure] at hf
  refine' (nndist_integral_add_measure_le_lintegral hf.1 hf.2).trans_lt _
  rw [‚Üê hŒΩ, lintegral_add_measure, lintegral_finset_sum_measure] at hs
  exact lt_of_add_lt_add_left hs
#align measure_theory.has_sum_integral_measure MeasureTheory.hasSum_integral_measure

theorem integral_sum_measure {Œπ} {_ : MeasurableSpace Œ±} {f : Œ± ‚Üí G} {Œº : Œπ ‚Üí Measure Œ±}
    (hf : Integrable f (Measure.sum Œº)) : ‚à´ a, f a ‚àÇMeasure.sum Œº = ‚àë' i, ‚à´ a, f a ‚àÇŒº i :=
  (hasSum_integral_measure hf).tsum_eq.symm
#align measure_theory.integral_sum_measure MeasureTheory.integral_sum_measure

theorem integral_tsum {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí G} (hf : ‚àÄ i, AEStronglyMeasurable (f i) Œº)
    (hf' : ‚àë' i, ‚à´‚Åª a : Œ±, ‚Äñf i a‚Äñ‚Çä ‚àÇŒº ‚â† ‚àû) :
    ‚à´ a : Œ±, ‚àë' i, f i a ‚àÇŒº = ‚àë' i, ‚à´ a : Œ±, f i a ‚àÇŒº := by
  by_cases hG : CompleteSpace G; swap
  ¬∑ simp [integral, hG]
  have hf'' : ‚àÄ i, AEMeasurable (fun x => (‚Äñf i x‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) Œº := fun i => (hf i).ennnorm
  have hhh : ‚àÄ·µê a : Œ± ‚àÇŒº, Summable fun n => (‚Äñf n a‚Äñ‚Çä : ‚Ñù) := by
    rw [‚Üê lintegral_tsum hf''] at hf'
    refine' (ae_lt_top' (AEMeasurable.ennreal_tsum hf'') hf').mono _
    intro x hx
    rw [‚Üê ENNReal.tsum_coe_ne_top_iff_summable_coe]
    exact hx.ne
  convert (MeasureTheory.hasSum_integral_of_dominated_convergence (fun i a => ‚Äñf i a‚Äñ‚Çä) hf _ hhh
          ‚ü®_, _‚ü© _).tsum_eq.symm
  ¬∑ intro n
    filter_upwards with x
    rfl
  ¬∑ simp_rw [‚Üê NNReal.coe_tsum]
    rw [aestronglyMeasurable_iff_aemeasurable]
    apply AEMeasurable.coe_nnreal_real
    apply AEMeasurable.nnreal_tsum
    exact fun i => (hf i).nnnorm.aemeasurable
  ¬∑ dsimp [HasFiniteIntegral]
    have : ‚à´‚Åª a, ‚àë' n, ‚Äñf n a‚Äñ‚Çä ‚àÇŒº < ‚ä§ := by rwa [lintegral_tsum hf'', lt_top_iff_ne_top]
    convert this using 1
    apply lintegral_congr_ae
    simp_rw [‚Üê coe_nnnorm, ‚Üê NNReal.coe_tsum, NNReal.nnnorm_eq]
    filter_upwards [hhh] with a ha
    exact ENNReal.coe_tsum (NNReal.summable_coe.mp ha)
  ¬∑ filter_upwards [hhh] with x hx
    exact hx.of_norm.hasSum
#align measure_theory.integral_tsum MeasureTheory.integral_tsum

@[simp]
theorem integral_smul_measure (f : Œ± ‚Üí G) (c : ‚Ñù‚â•0‚àû) :
    ‚à´ x, f x ‚àÇc ‚Ä¢ Œº = c.toReal ‚Ä¢ ‚à´ x, f x ‚àÇŒº := by
  by_cases hG : CompleteSpace G; swap
  ¬∑ simp [integral, hG]
  -- First we consider the ‚Äúdegenerate‚Äù case `c = ‚àû`
  rcases eq_or_ne c ‚àû with (rfl | hc)
  ¬∑ rw [ENNReal.top_toReal, zero_smul, integral_eq_setToFun, setToFun_top_smul_measure]
  -- Main case: `c ‚â† ‚àû`
  simp_rw [integral_eq_setToFun, ‚Üê setToFun_smul_left]
  have hdfma : DominatedFinMeasAdditive Œº (weightedSMul (c ‚Ä¢ Œº) : Set Œ± ‚Üí G ‚ÜíL[‚Ñù] G) c.toReal :=
    mul_one c.toReal ‚ñ∏ (dominatedFinMeasAdditive_weightedSMul (c ‚Ä¢ Œº)).of_smul_measure c hc
  have hdfma_smul := dominatedFinMeasAdditive_weightedSMul (F := G) (c ‚Ä¢ Œº)
  rw [‚Üê setToFun_congr_smul_measure c hc hdfma hdfma_smul f]
  exact setToFun_congr_left' _ _ (fun s _ _ => weightedSMul_smul_measure Œº c) f
#align measure_theory.integral_smul_measure MeasureTheory.integral_smul_measure

@[simp]
theorem integral_smul_nnreal_measure (f : Œ± ‚Üí G) (c : ‚Ñù‚â•0) :
    ‚à´ x, f x ‚àÇ(c ‚Ä¢ Œº) = c ‚Ä¢ ‚à´ x, f x ‚àÇŒº :=
  integral_smul_measure f (c : ‚Ñù‚â•0‚àû)

theorem integral_map_of_stronglyMeasurable {Œ≤} [MeasurableSpace Œ≤] {œÜ : Œ± ‚Üí Œ≤} (hœÜ : Measurable œÜ)
    {f : Œ≤ ‚Üí G} (hfm : StronglyMeasurable f) : ‚à´ y, f y ‚àÇMeasure.map œÜ Œº = ‚à´ x, f (œÜ x) ‚àÇŒº := by
  by_cases hG : CompleteSpace G; swap
  ¬∑ simp [integral, hG]
  by_cases hfi : Integrable f (Measure.map œÜ Œº); swap
  ¬∑ rw [integral_undef hfi, integral_undef]
    exact fun hfœÜ => hfi ((integrable_map_measure hfm.aestronglyMeasurable hœÜ.aemeasurable).2 hfœÜ)
  borelize G
  have : SeparableSpace (range f ‚à™ {0} : Set G) := hfm.separableSpace_range_union_singleton
  refine' tendsto_nhds_unique
    (tendsto_integral_approxOn_of_measurable_of_range_subset hfm.measurable hfi _ Subset.rfl) _
  convert tendsto_integral_approxOn_of_measurable_of_range_subset (hfm.measurable.comp hœÜ)
    ((integrable_map_measure hfm.aestronglyMeasurable hœÜ.aemeasurable).1 hfi) (range f ‚à™ {0})
    (by simp [insert_subset_insert, Set.range_comp_subset_range]) using 1
  ext1 i
  simp only [SimpleFunc.approxOn_comp, SimpleFunc.integral_eq, Measure.map_apply, hœÜ,
    SimpleFunc.measurableSet_preimage, ‚Üê preimage_comp, SimpleFunc.coe_comp]
  refine' (Finset.sum_subset (SimpleFunc.range_comp_subset_range _ hœÜ) fun y _ hy => _).symm
  rw [SimpleFunc.mem_range, ‚Üê Set.preimage_singleton_eq_empty, SimpleFunc.coe_comp] at hy
  rw [hy]
  simp
#align measure_theory.integral_map_of_strongly_measurable MeasureTheory.integral_map_of_stronglyMeasurable

theorem integral_map {Œ≤} [MeasurableSpace Œ≤] {œÜ : Œ± ‚Üí Œ≤} (hœÜ : AEMeasurable œÜ Œº) {f : Œ≤ ‚Üí G}
    (hfm : AEStronglyMeasurable f (Measure.map œÜ Œº)) :
    ‚à´ y, f y ‚àÇMeasure.map œÜ Œº = ‚à´ x, f (œÜ x) ‚àÇŒº :=
  let g := hfm.mk f
  calc
    ‚à´ y, f y ‚àÇMeasure.map œÜ Œº = ‚à´ y, g y ‚àÇMeasure.map œÜ Œº := integral_congr_ae hfm.ae_eq_mk
    _ = ‚à´ y, g y ‚àÇMeasure.map (hœÜ.mk œÜ) Œº := by congr 1; exact Measure.map_congr hœÜ.ae_eq_mk
    _ = ‚à´ x, g (hœÜ.mk œÜ x) ‚àÇŒº :=
      (integral_map_of_stronglyMeasurable hœÜ.measurable_mk hfm.stronglyMeasurable_mk)
    _ = ‚à´ x, g (œÜ x) ‚àÇŒº := (integral_congr_ae (hœÜ.ae_eq_mk.symm.fun_comp _))
    _ = ‚à´ x, f (œÜ x) ‚àÇŒº := integral_congr_ae <| ae_eq_comp hœÜ hfm.ae_eq_mk.symm
#align measure_theory.integral_map MeasureTheory.integral_map

theorem _root_.MeasurableEmbedding.integral_map {Œ≤} {_ : MeasurableSpace Œ≤} {f : Œ± ‚Üí Œ≤}
    (hf : MeasurableEmbedding f) (g : Œ≤ ‚Üí G) : ‚à´ y, g y ‚àÇMeasure.map f Œº = ‚à´ x, g (f x) ‚àÇŒº := by
  by_cases hgm : AEStronglyMeasurable g (Measure.map f Œº)
  ¬∑ exact MeasureTheory.integral_map hf.measurable.aemeasurable hgm
  ¬∑ rw [integral_non_aestronglyMeasurable hgm, integral_non_aestronglyMeasurable]
    refine' fun hgf => hgm (hf.aestronglyMeasurable_map_iff.2 hgf)
#align measurable_embedding.integral_map MeasurableEmbedding.integral_map

theorem _root_.ClosedEmbedding.integral_map {Œ≤} [TopologicalSpace Œ±] [BorelSpace Œ±]
    [TopologicalSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤] {œÜ : Œ± ‚Üí Œ≤} (hœÜ : ClosedEmbedding œÜ)
    (f : Œ≤ ‚Üí G) : ‚à´ y, f y ‚àÇMeasure.map œÜ Œº = ‚à´ x, f (œÜ x) ‚àÇŒº :=
  hœÜ.measurableEmbedding.integral_map _
#align closed_embedding.integral_map ClosedEmbedding.integral_map

theorem integral_map_equiv {Œ≤} [MeasurableSpace Œ≤] (e : Œ± ‚âÉ·µê Œ≤) (f : Œ≤ ‚Üí G) :
    ‚à´ y, f y ‚àÇMeasure.map e Œº = ‚à´ x, f (e x) ‚àÇŒº :=
  e.measurableEmbedding.integral_map f
#align measure_theory.integral_map_equiv MeasureTheory.integral_map_equiv

theorem MeasurePreserving.integral_comp {Œ≤} {_ : MeasurableSpace Œ≤} {f : Œ± ‚Üí Œ≤} {ŒΩ}
    (h‚ÇÅ : MeasurePreserving f Œº ŒΩ) (h‚ÇÇ : MeasurableEmbedding f) (g : Œ≤ ‚Üí G) :
    ‚à´ x, g (f x) ‚àÇŒº = ‚à´ y, g y ‚àÇŒΩ :=
  h‚ÇÅ.map_eq ‚ñ∏ (h‚ÇÇ.integral_map g).symm
#align measure_theory.measure_preserving.integral_comp MeasureTheory.MeasurePreserving.integral_comp

theorem MeasurePreserving.integral_comp' {Œ≤} [MeasurableSpace Œ≤] {ŒΩ} {f : Œ± ‚âÉ·µê Œ≤}
    (h : MeasurePreserving f Œº ŒΩ) (g : Œ≤ ‚Üí G) :
    ‚à´ x, g (f x) ‚àÇŒº = ‚à´ y, g y ‚àÇŒΩ := MeasurePreserving.integral_comp h f.measurableEmbedding _

theorem integral_subtype_comap {Œ±} [MeasurableSpace Œ±] {Œº : Measure Œ±} {s : Set Œ±}
    (hs : MeasurableSet s) (f : Œ± ‚Üí G) :
    ‚à´ x : s, f (x : Œ±) ‚àÇ(Measure.comap Subtype.val Œº) = ‚à´ x in s, f x ‚àÇŒº := by
  rw [‚Üê map_comap_subtype_coe hs]
  exact ((MeasurableEmbedding.subtype_coe hs).integral_map _).symm

attribute [local instance] Measure.Subtype.measureSpace in
theorem integral_subtype {Œ±} [MeasureSpace Œ±] {s : Set Œ±} (hs : MeasurableSet s) (f : Œ± ‚Üí G) :
    ‚à´ x : s, f x = ‚à´ x in s, f x := integral_subtype_comap hs f
#align measure_theory.set_integral_eq_subtype MeasureTheory.integral_subtype

@[simp]
theorem integral_dirac' [MeasurableSpace Œ±] (f : Œ± ‚Üí E) (a : Œ±) (hfm : StronglyMeasurable f) :
    ‚à´ x, f x ‚àÇMeasure.dirac a = f a := by
  borelize E
  calc
    ‚à´ x, f x ‚àÇMeasure.dirac a = ‚à´ _, f a ‚àÇMeasure.dirac a :=
      integral_congr_ae <| ae_eq_dirac' hfm.measurable
    _ = f a := by simp [Measure.dirac_apply_of_mem]
#align measure_theory.integral_dirac' MeasureTheory.integral_dirac'

@[simp]
theorem integral_dirac [MeasurableSpace Œ±] [MeasurableSingletonClass Œ±] (f : Œ± ‚Üí E) (a : Œ±) :
    ‚à´ x, f x ‚àÇMeasure.dirac a = f a :=
  calc
    ‚à´ x, f x ‚àÇMeasure.dirac a = ‚à´ _, f a ‚àÇMeasure.dirac a := integral_congr_ae <| ae_eq_dirac f
    _ = f a := by simp [Measure.dirac_apply_of_mem]
#align measure_theory.integral_dirac MeasureTheory.integral_dirac

theorem set_integral_dirac' {mŒ± : MeasurableSpace Œ±} {f : Œ± ‚Üí E} (hf : StronglyMeasurable f) (a : Œ±)
    {s : Set Œ±} (hs : MeasurableSet s) [Decidable (a ‚àà s)] :
    ‚à´ x in s, f x ‚àÇMeasure.dirac a = if a ‚àà s then f a else 0 := by
  rw [restrict_dirac' hs]
  split_ifs
  ¬∑ exact integral_dirac' _ _ hf
  ¬∑ exact integral_zero_measure _
#align measure_theory.set_integral_dirac' MeasureTheory.set_integral_dirac'

theorem set_integral_dirac [MeasurableSpace Œ±] [MeasurableSingletonClass Œ±] (f : Œ± ‚Üí E) (a : Œ±)
    (s : Set Œ±) [Decidable (a ‚àà s)] :
    ‚à´ x in s, f x ‚àÇMeasure.dirac a = if a ‚àà s then f a else 0 := by
  rw [restrict_dirac]
  split_ifs
  ¬∑ exact integral_dirac _ _
  ¬∑ exact integral_zero_measure _
#align measure_theory.set_integral_dirac MeasureTheory.set_integral_dirac

/-- **Markov's inequality** also known as **Chebyshev's first inequality**. -/
theorem mul_meas_ge_le_integral_of_nonneg {f : Œ± ‚Üí ‚Ñù} (hf_nonneg : 0 ‚â§·µê[Œº] f)
    (hf_int : Integrable f Œº) (Œµ : ‚Ñù) : Œµ * (Œº { x | Œµ ‚â§ f x }).toReal ‚â§ ‚à´ x, f x ‚àÇŒº := by
  cases' eq_top_or_lt_top (Œº {x | Œµ ‚â§ f x}) with hŒº hŒº
  ¬∑ simpa [hŒº] using integral_nonneg_of_ae hf_nonneg
  ¬∑ have := Fact.mk hŒº
    calc
      Œµ * (Œº { x | Œµ ‚â§ f x }).toReal = ‚à´ _ in {x | Œµ ‚â§ f x}, Œµ ‚àÇŒº := by simp [mul_comm]
      _ ‚â§ ‚à´ x in {x | Œµ ‚â§ f x}, f x ‚àÇŒº :=
        integral_mono_ae (integrable_const _) (hf_int.mono_measure Œº.restrict_le_self) <|
          ae_restrict_mem‚ÇÄ <| hf_int.aemeasurable.nullMeasurable measurableSet_Ici
      _ ‚â§ _ := integral_mono_measure Œº.restrict_le_self hf_nonneg hf_int
#align measure_theory.mul_meas_ge_le_integral_of_nonneg MeasureTheory.mul_meas_ge_le_integral_of_nonneg

/-- H√∂lder's inequality for the integral of a product of norms. The integral of the product of two
norms of functions is bounded by the product of their `‚Ñíp` and `‚Ñíq` seminorms when `p` and `q` are
conjugate exponents. -/
theorem integral_mul_norm_le_Lp_mul_Lq {E} [NormedAddCommGroup E] {f g : Œ± ‚Üí E} {p q : ‚Ñù}
    (hpq : p.IsConjugateExponent q) (hf : Mem‚Ñíp f (ENNReal.ofReal p) Œº)
    (hg : Mem‚Ñíp g (ENNReal.ofReal q) Œº) :
    ‚à´ a, ‚Äñf a‚Äñ * ‚Äñg a‚Äñ ‚àÇŒº ‚â§ (‚à´ a, ‚Äñf a‚Äñ ^ p ‚àÇŒº) ^ (1 / p) * (‚à´ a, ‚Äñg a‚Äñ ^ q ‚àÇŒº) ^ (1 / q) := by
  -- translate the Bochner integrals into Lebesgue integrals.
  rw [integral_eq_lintegral_of_nonneg_ae, integral_eq_lintegral_of_nonneg_ae,
    integral_eq_lintegral_of_nonneg_ae]
  rotate_left
  ¬∑ exact eventually_of_forall fun x => Real.rpow_nonneg_of_nonneg (norm_nonneg _) _
  ¬∑ exact (hg.1.norm.aemeasurable.pow aemeasurable_const).aestronglyMeasurable
  ¬∑ exact eventually_of_forall fun x => Real.rpow_nonneg_of_nonneg (norm_nonneg _) _
  ¬∑ exact (hf.1.norm.aemeasurable.pow aemeasurable_const).aestronglyMeasurable
  ¬∑ exact eventually_of_forall fun x => mul_nonneg (norm_nonneg _) (norm_nonneg _)
  ¬∑ exact hf.1.norm.mul hg.1.norm
  rw [ENNReal.toReal_rpow, ENNReal.toReal_rpow, ‚Üê ENNReal.toReal_mul]
  -- replace norms by nnnorm
  have h_left : ‚à´‚Åª a, ENNReal.ofReal (‚Äñf a‚Äñ * ‚Äñg a‚Äñ) ‚àÇŒº =
      ‚à´‚Åª a, ((fun x => (‚Äñf x‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) * fun x => (‚Äñg x‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) a ‚àÇŒº := by
    simp_rw [Pi.mul_apply, ‚Üê ofReal_norm_eq_coe_nnnorm, ENNReal.ofReal_mul (norm_nonneg _)]
  have h_right_f : ‚à´‚Åª a, ENNReal.ofReal (‚Äñf a‚Äñ ^ p) ‚àÇŒº = ‚à´‚Åª a, (‚Äñf a‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ p ‚àÇŒº := by
    refine' lintegral_congr fun x => _
    rw [‚Üê ofReal_norm_eq_coe_nnnorm, ENNReal.ofReal_rpow_of_nonneg (norm_nonneg _) hpq.nonneg]
  have h_right_g : ‚à´‚Åª a, ENNReal.ofReal (‚Äñg a‚Äñ ^ q) ‚àÇŒº = ‚à´‚Åª a, (‚Äñg a‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ q ‚àÇŒº := by
    refine' lintegral_congr fun x => _
    rw [‚Üê ofReal_norm_eq_coe_nnnorm, ENNReal.ofReal_rpow_of_nonneg (norm_nonneg _) hpq.symm.nonneg]
  rw [h_left, h_right_f, h_right_g]
  -- we can now apply `ENNReal.lintegral_mul_le_Lp_mul_Lq` (up to the `toReal` application)
  refine' ENNReal.toReal_mono _ _
  ¬∑ refine' ENNReal.mul_ne_top _ _
    ¬∑ convert hf.snorm_ne_top
      rw [snorm_eq_lintegral_rpow_nnnorm]
      ¬∑ rw [ENNReal.toReal_ofReal hpq.nonneg]
      ¬∑ rw [Ne.def, ENNReal.ofReal_eq_zero, not_le]
        exact hpq.pos
      ¬∑ exact ENNReal.coe_ne_top
    ¬∑ convert hg.snorm_ne_top
      rw [snorm_eq_lintegral_rpow_nnnorm]
      ¬∑ rw [ENNReal.toReal_ofReal hpq.symm.nonneg]
      ¬∑ rw [Ne.def, ENNReal.ofReal_eq_zero, not_le]
        exact hpq.symm.pos
      ¬∑ exact ENNReal.coe_ne_top
  ¬∑ exact ENNReal.lintegral_mul_le_Lp_mul_Lq Œº hpq hf.1.nnnorm.aemeasurable.coe_nnreal_ennreal
      hg.1.nnnorm.aemeasurable.coe_nnreal_ennreal
set_option linter.uppercaseLean3 false in
#align measure_theory.integral_mul_norm_le_Lp_mul_Lq MeasureTheory.integral_mul_norm_le_Lp_mul_Lq

/-- H√∂lder's inequality for functions `Œ± ‚Üí ‚Ñù`. The integral of the product of two nonnegative
functions is bounded by the product of their `‚Ñíp` and `‚Ñíq` seminorms when `p` and `q` are conjugate
exponents. -/
theorem integral_mul_le_Lp_mul_Lq_of_nonneg {p q : ‚Ñù} (hpq : p.IsConjugateExponent q) {f g : Œ± ‚Üí ‚Ñù}
    (hf_nonneg : 0 ‚â§·µê[Œº] f) (hg_nonneg : 0 ‚â§·µê[Œº] g) (hf : Mem‚Ñíp f (ENNReal.ofReal p) Œº)
    (hg : Mem‚Ñíp g (ENNReal.ofReal q) Œº) :
    ‚à´ a, f a * g a ‚àÇŒº ‚â§ (‚à´ a, f a ^ p ‚àÇŒº) ^ (1 / p) * (‚à´ a, g a ^ q ‚àÇŒº) ^ (1 / q) := by
  have h_left : ‚à´ a, f a * g a ‚àÇŒº = ‚à´ a, ‚Äñf a‚Äñ * ‚Äñg a‚Äñ ‚àÇŒº := by
    refine' integral_congr_ae _
    filter_upwards [hf_nonneg, hg_nonneg] with x hxf hxg
    rw [Real.norm_of_nonneg hxf, Real.norm_of_nonneg hxg]
  have h_right_f : ‚à´ a, f a ^ p ‚àÇŒº = ‚à´ a, ‚Äñf a‚Äñ ^ p ‚àÇŒº := by
    refine' integral_congr_ae _
    filter_upwards [hf_nonneg] with x hxf
    rw [Real.norm_of_nonneg hxf]
  have h_right_g : ‚à´ a, g a ^ q ‚àÇŒº = ‚à´ a, ‚Äñg a‚Äñ ^ q ‚àÇŒº := by
    refine' integral_congr_ae _
    filter_upwards [hg_nonneg] with x hxg
    rw [Real.norm_of_nonneg hxg]
  rw [h_left, h_right_f, h_right_g]
  exact integral_mul_norm_le_Lp_mul_Lq hpq hf hg
set_option linter.uppercaseLean3 false in
#align measure_theory.integral_mul_le_Lp_mul_Lq_of_nonneg MeasureTheory.integral_mul_le_Lp_mul_Lq_of_nonneg

theorem integral_countable' [Countable Œ±] [MeasurableSingletonClass Œ±] {Œº : Measure Œ±}
    {f : Œ± ‚Üí E} (hf : Integrable f Œº) :
    ‚à´ a, f a ‚àÇŒº = ‚àë' a, (Œº {a}).toReal ‚Ä¢ f a := by
  rw [‚Üê Measure.sum_smul_dirac Œº] at hf
  rw [‚Üê Measure.sum_smul_dirac Œº, integral_sum_measure hf]
  congr 1 with a : 1
  rw [integral_smul_measure, integral_dirac, Measure.sum_smul_dirac]

theorem integral_singleton' {Œº : Measure Œ±} {f : Œ± ‚Üí E} (hf : StronglyMeasurable f) (a : Œ±) :
    ‚à´ a in {a}, f a ‚àÇŒº = (Œº {a}).toReal ‚Ä¢ f a := by
  simp only [Measure.restrict_singleton, integral_smul_measure, integral_dirac' f a hf, smul_eq_mul,
    mul_comm]

theorem integral_singleton [MeasurableSingletonClass Œ±] {Œº : Measure Œ±} (f : Œ± ‚Üí E) (a : Œ±) :
    ‚à´ a in {a}, f a ‚àÇŒº = (Œº {a}).toReal ‚Ä¢ f a := by
  simp only [Measure.restrict_singleton, integral_smul_measure, integral_dirac, smul_eq_mul,
    mul_comm]

theorem integral_countable [MeasurableSingletonClass Œ±] (f : Œ± ‚Üí E) {s : Set Œ±} (hs : s.Countable)
    (hf : Integrable f (Œº.restrict s)) :
    ‚à´ a in s, f a ‚àÇŒº = ‚àë' a : s, (Œº {(a : Œ±)}).toReal ‚Ä¢ f a := by
  have hi : Countable { x // x ‚àà s } := Iff.mpr countable_coe_iff hs
  have hf' : Integrable (fun (x : s) => f x) (Measure.comap Subtype.val Œº) := by
    rw [‚Üê map_comap_subtype_coe, integrable_map_measure] at hf
    apply hf
    ¬∑ exact Integrable.aestronglyMeasurable hf
    ¬∑ exact Measurable.aemeasurable measurable_subtype_coe
    ¬∑ exact Countable.measurableSet hs
  rw [‚Üê integral_subtype_comap hs.measurableSet, integral_countable' hf']
  congr 1 with a : 1
  rw [Measure.comap_apply Subtype.val Subtype.coe_injective
    (fun s' hs' => MeasurableSet.subtype_image (Countable.measurableSet hs) hs') _
    (MeasurableSet.singleton a)]
  simp

theorem integral_finset [MeasurableSingletonClass Œ±] (s : Finset Œ±) (f : Œ± ‚Üí E)
    (hf : Integrable f (Œº.restrict s)) :
    ‚à´ x in s, f x ‚àÇŒº = ‚àë x in s, (Œº {x}).toReal ‚Ä¢ f x := by
  rw [integral_countable _ s.countable_toSet hf, ‚Üê Finset.tsum_subtype']

theorem integral_fintype [MeasurableSingletonClass Œ±] [Fintype Œ±] (f : Œ± ‚Üí E)
    (hf : Integrable f Œº) :
    ‚à´ x, f x ‚àÇŒº = ‚àë x, (Œº {x}).toReal ‚Ä¢ f x := by
  -- NB: Integrable f does not follow from Fintype, because the measure itself could be non-finite
  rw [‚Üê integral_finset .univ , Finset.coe_univ, Measure.restrict_univ]
  simp only [Finset.coe_univ, Measure.restrict_univ, hf]

theorem integral_unique [Unique Œ±] (f : Œ± ‚Üí E) : ‚à´ x, f x ‚àÇŒº = (Œº univ).toReal ‚Ä¢ f default :=
  calc
    ‚à´ x, f x ‚àÇŒº = ‚à´ _, f default ‚àÇŒº := by congr with x; congr; exact Unique.uniq _ x
    _ = (Œº univ).toReal ‚Ä¢ f default := by rw [integral_const]

end Properties

section IntegralTrim

variable {H Œ≤ Œ≥ : Type*} [NormedAddCommGroup H] {m m0 : MeasurableSpace Œ≤} {Œº : Measure Œ≤}

/-- Simple function seen as simple function of a larger `MeasurableSpace`. -/
def SimpleFunc.toLargerSpace (hm : m ‚â§ m0) (f : @SimpleFunc Œ≤ m Œ≥) : SimpleFunc Œ≤ Œ≥ :=
  ‚ü®@SimpleFunc.toFun Œ≤ m Œ≥ f, fun x => hm _ (@SimpleFunc.measurableSet_fiber Œ≤ Œ≥ m f x),
    @SimpleFunc.finite_range Œ≤ Œ≥ m f‚ü©
#align measure_theory.simple_func.to_larger_space MeasureTheory.SimpleFunc.toLargerSpace

theorem SimpleFunc.coe_toLargerSpace_eq (hm : m ‚â§ m0) (f : @SimpleFunc Œ≤ m Œ≥) :
    ‚áë(f.toLargerSpace hm) = f := rfl
#align measure_theory.simple_func.coe_to_larger_space_eq MeasureTheory.SimpleFunc.coe_toLargerSpace_eq

theorem integral_simpleFunc_larger_space (hm : m ‚â§ m0) (f : @SimpleFunc Œ≤ m F)
    (hf_int : Integrable f Œº) :
    ‚à´ x, f x ‚àÇŒº = ‚àë x in @SimpleFunc.range Œ≤ F m f, ENNReal.toReal (Œº (f ‚Åª¬π' {x})) ‚Ä¢ x := by
  simp_rw [‚Üê f.coe_toLargerSpace_eq hm]
  have hf_int : Integrable (f.toLargerSpace hm) Œº := by rwa [SimpleFunc.coe_toLargerSpace_eq]
  rw [SimpleFunc.integral_eq_sum _ hf_int]
  congr 1
#align measure_theory.integral_simple_func_larger_space MeasureTheory.integral_simpleFunc_larger_space

theorem integral_trim_simpleFunc (hm : m ‚â§ m0) (f : @SimpleFunc Œ≤ m F) (hf_int : Integrable f Œº) :
    ‚à´ x, f x ‚àÇŒº = ‚à´ x, f x ‚àÇŒº.trim hm := by
  have hf : StronglyMeasurable[m] f := @SimpleFunc.stronglyMeasurable Œ≤ F m _ f
  have hf_int_m := hf_int.trim hm hf
  rw [integral_simpleFunc_larger_space (le_refl m) f hf_int_m,
    integral_simpleFunc_larger_space hm f hf_int]
  congr with x
  congr 2
  exact (trim_measurableSet_eq hm (@SimpleFunc.measurableSet_fiber Œ≤ F m f x)).symm
#align measure_theory.integral_trim_simple_func MeasureTheory.integral_trim_simpleFunc

theorem integral_trim (hm : m ‚â§ m0) {f : Œ≤ ‚Üí G} (hf : StronglyMeasurable[m] f) :
    ‚à´ x, f x ‚àÇŒº = ‚à´ x, f x ‚àÇŒº.trim hm := by
  by_cases hG : CompleteSpace G; swap
  ¬∑ simp [integral, hG]
  borelize G
  by_cases hf_int : Integrable f Œº
  swap
  ¬∑ have hf_int_m : ¬¨Integrable f (Œº.trim hm) := fun hf_int_m =>
      hf_int (integrable_of_integrable_trim hm hf_int_m)
    rw [integral_undef hf_int, integral_undef hf_int_m]
  haveI : SeparableSpace (range f ‚à™ {0} : Set G) := hf.separableSpace_range_union_singleton
  let f_seq := @SimpleFunc.approxOn G Œ≤ _ _ _ m _ hf.measurable (range f ‚à™ {0}) 0 (by simp) _
  have hf_seq_meas : ‚àÄ n, StronglyMeasurable[m] (f_seq n) := fun n =>
    @SimpleFunc.stronglyMeasurable Œ≤ G m _ (f_seq n)
  have hf_seq_int : ‚àÄ n, Integrable (f_seq n) Œº :=
    SimpleFunc.integrable_approxOn_range (hf.mono hm).measurable hf_int
  have hf_seq_int_m : ‚àÄ n, Integrable (f_seq n) (Œº.trim hm) := fun n =>
    (hf_seq_int n).trim hm (hf_seq_meas n)
  have hf_seq_eq : ‚àÄ n, ‚à´ x, f_seq n x ‚àÇŒº = ‚à´ x, f_seq n x ‚àÇŒº.trim hm := fun n =>
    integral_trim_simpleFunc hm (f_seq n) (hf_seq_int n)
  have h_lim_1 : atTop.Tendsto (fun n => ‚à´ x, f_seq n x ‚àÇŒº) (ùìù (‚à´ x, f x ‚àÇŒº)) := by
    refine' tendsto_integral_of_L1 f hf_int (eventually_of_forall hf_seq_int) _
    exact SimpleFunc.tendsto_approxOn_range_L1_nnnorm (hf.mono hm).measurable hf_int
  have h_lim_2 : atTop.Tendsto (fun n => ‚à´ x, f_seq n x ‚àÇŒº) (ùìù (‚à´ x, f x ‚àÇŒº.trim hm)) := by
    simp_rw [hf_seq_eq]
    refine' @tendsto_integral_of_L1 Œ≤ G _ _ m (Œº.trim hm) _ f (hf_int.trim hm hf) _ _
      (eventually_of_forall hf_seq_int_m) _
    exact @SimpleFunc.tendsto_approxOn_range_L1_nnnorm Œ≤ G m _ _ _ f _ _ hf.measurable
      (hf_int.trim hm hf)
  exact tendsto_nhds_unique h_lim_1 h_lim_2
#align measure_theory.integral_trim MeasureTheory.integral_trim

theorem integral_trim_ae (hm : m ‚â§ m0) {f : Œ≤ ‚Üí G} (hf : AEStronglyMeasurable f (Œº.trim hm)) :
    ‚à´ x, f x ‚àÇŒº = ‚à´ x, f x ‚àÇŒº.trim hm := by
  rw [integral_congr_ae (ae_eq_of_ae_eq_trim hf.ae_eq_mk), integral_congr_ae hf.ae_eq_mk]
  exact integral_trim hm hf.stronglyMeasurable_mk
#align measure_theory.integral_trim_ae MeasureTheory.integral_trim_ae

theorem ae_eq_trim_of_stronglyMeasurable [TopologicalSpace Œ≥] [MetrizableSpace Œ≥] (hm : m ‚â§ m0)
    {f g : Œ≤ ‚Üí Œ≥} (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g)
    (hfg : f =·µê[Œº] g) : f =·µê[Œº.trim hm] g := by
  rwa [EventuallyEq, @ae_iff _ m, trim_measurableSet_eq hm _]
  exact (hf.measurableSet_eq_fun hg).compl
#align measure_theory.ae_eq_trim_of_strongly_measurable MeasureTheory.ae_eq_trim_of_stronglyMeasurable

theorem ae_eq_trim_iff [TopologicalSpace Œ≥] [MetrizableSpace Œ≥] (hm : m ‚â§ m0) {f g : Œ≤ ‚Üí Œ≥}
    (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g) :
    f =·µê[Œº.trim hm] g ‚Üî f =·µê[Œº] g :=
  ‚ü®ae_eq_of_ae_eq_trim, ae_eq_trim_of_stronglyMeasurable hm hf hg‚ü©
#align measure_theory.ae_eq_trim_iff MeasureTheory.ae_eq_trim_iff

theorem ae_le_trim_of_stronglyMeasurable [LinearOrder Œ≥] [TopologicalSpace Œ≥]
    [OrderClosedTopology Œ≥] [PseudoMetrizableSpace Œ≥] (hm : m ‚â§ m0) {f g : Œ≤ ‚Üí Œ≥}
    (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g) (hfg : f ‚â§·µê[Œº] g) :
    f ‚â§·µê[Œº.trim hm] g := by
  rwa [EventuallyLE, @ae_iff _ m, trim_measurableSet_eq hm _]
  exact (hf.measurableSet_le hg).compl
#align measure_theory.ae_le_trim_of_strongly_measurable MeasureTheory.ae_le_trim_of_stronglyMeasurable

theorem ae_le_trim_iff [LinearOrder Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥]
    [PseudoMetrizableSpace Œ≥] (hm : m ‚â§ m0) {f g : Œ≤ ‚Üí Œ≥} (hf : StronglyMeasurable[m] f)
    (hg : StronglyMeasurable[m] g) : f ‚â§·µê[Œº.trim hm] g ‚Üî f ‚â§·µê[Œº] g :=
  ‚ü®ae_le_of_ae_le_trim, ae_le_trim_of_stronglyMeasurable hm hf hg‚ü©
#align measure_theory.ae_le_trim_iff MeasureTheory.ae_le_trim_iff

end IntegralTrim

section SnormBound

variable {m0 : MeasurableSpace Œ±} {Œº : Measure Œ±}

theorem snorm_one_le_of_le {r : ‚Ñù‚â•0} {f : Œ± ‚Üí ‚Ñù} (hfint : Integrable f Œº) (hfint' : 0 ‚â§ ‚à´ x, f x ‚àÇŒº)
    (hf : ‚àÄ·µê œâ ‚àÇŒº, f œâ ‚â§ r) : snorm f 1 Œº ‚â§ 2 * Œº Set.univ * r := by
  by_cases hr : r = 0
  ¬∑ suffices f =·µê[Œº] 0 by
      rw [snorm_congr_ae this, snorm_zero, hr, ENNReal.coe_zero, mul_zero]
    rw [hr] at hf
    norm_cast at hf
    -- Porting note: two lines above were
    --rw [hr, Nonneg.coe_zero] at hf
    have hnegf : ‚à´ x, -f x ‚àÇŒº = 0 := by
      rw [integral_neg, neg_eq_zero]
      exact le_antisymm (integral_nonpos_of_ae hf) hfint'
    have := (integral_eq_zero_iff_of_nonneg_ae ?_ hfint.neg).1 hnegf
    ¬∑ filter_upwards [this] with œâ hœâ
      rwa [Pi.neg_apply, Pi.zero_apply, neg_eq_zero] at hœâ
    ¬∑ filter_upwards [hf] with œâ hœâ
      rwa [Pi.zero_apply, Pi.neg_apply, Right.nonneg_neg_iff]
  by_cases hŒº : IsFiniteMeasure Œº
  swap
  ¬∑ have : Œº Set.univ = ‚àû := by
      by_contra hŒº'
      exact hŒº (IsFiniteMeasure.mk <| lt_top_iff_ne_top.2 hŒº')
    rw [this, ENNReal.mul_top', if_neg, ENNReal.top_mul', if_neg]
    ¬∑ exact le_top
    ¬∑ simp [hr]
    ¬∑ norm_num
  haveI := hŒº
  rw [integral_eq_integral_pos_part_sub_integral_neg_part hfint, sub_nonneg] at hfint'
  have hposbdd : ‚à´ œâ, max (f œâ) 0 ‚àÇŒº ‚â§ (Œº Set.univ).toReal ‚Ä¢ (r : ‚Ñù) := by
    rw [‚Üê integral_const]
    refine' integral_mono_ae hfint.real_toNNReal (integrable_const (r : ‚Ñù)) _
    filter_upwards [hf] with œâ hœâ using Real.toNNReal_le_iff_le_coe.2 hœâ
  rw [Mem‚Ñíp.snorm_eq_integral_rpow_norm one_ne_zero ENNReal.one_ne_top
      (mem‚Ñíp_one_iff_integrable.2 hfint),
    ENNReal.ofReal_le_iff_le_toReal
      (ENNReal.mul_ne_top (ENNReal.mul_ne_top ENNReal.two_ne_top <| @measure_ne_top _ _ _ hŒº _)
        ENNReal.coe_ne_top)]
  simp_rw [ENNReal.one_toReal, _root_.inv_one, Real.rpow_one, Real.norm_eq_abs, ‚Üê
    max_zero_add_max_neg_zero_eq_abs_self, ‚Üê Real.coe_toNNReal']
  rw [integral_add hfint.real_toNNReal]
  ¬∑ simp only [Real.coe_toNNReal', ENNReal.toReal_mul, ENNReal.one_toReal, ENNReal.coe_toReal,
      ge_iff_le, Left.nonneg_neg_iff, Left.neg_nonpos_iff, toReal_ofNat] at hfint' ‚ä¢
    refine' (add_le_add_left hfint' _).trans _
    rwa [‚Üê two_mul, mul_assoc, mul_le_mul_left (two_pos : (0 : ‚Ñù) < 2)]
  ¬∑ exact hfint.neg.sup (integrable_zero _ _ Œº)
#align measure_theory.snorm_one_le_of_le MeasureTheory.snorm_one_le_of_le

theorem snorm_one_le_of_le' {r : ‚Ñù} {f : Œ± ‚Üí ‚Ñù} (hfint : Integrable f Œº) (hfint' : 0 ‚â§ ‚à´ x, f x ‚àÇŒº)
    (hf : ‚àÄ·µê œâ ‚àÇŒº, f œâ ‚â§ r) : snorm f 1 Œº ‚â§ 2 * Œº Set.univ * ENNReal.ofReal r := by
  refine' snorm_one_le_of_le hfint hfint' _
  simp only [Real.coe_toNNReal', le_max_iff]
  filter_upwards [hf] with œâ hœâ using Or.inl hœâ
#align measure_theory.snorm_one_le_of_le' MeasureTheory.snorm_one_le_of_le'

end SnormBound

end MeasureTheory
