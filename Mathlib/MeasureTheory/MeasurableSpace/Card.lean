/-
Copyright (c) 2022 SÃ©bastien GouÃ«zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: SÃ©bastien GouÃ«zel, Violeta HernÃ¡ndez Palacios
-/
import Mathlib.MeasureTheory.MeasurableSpace.Basic
import Mathlib.SetTheory.Cardinal.Cofinality
import Mathlib.SetTheory.Cardinal.Continuum

/-!
# Cardinal of sigma-algebras

If a sigma-algebra is generated by a set of sets `s`, then the cardinality of the sigma-algebra is
bounded by `(max #s 2) ^ â„µâ‚€`. This is stated in `MeasurableSpace.cardinal_generate_measurable_le`
and `MeasurableSpace.cardinalMeasurableSet_le`.

In particular, if `#s â‰¤ ğ” `, then the generated sigma-algebra has cardinality at most `ğ” `, see
`MeasurableSpace.cardinal_measurableSet_le_continuum`.

For the proof, we rely on an explicit inductive construction of the sigma-algebra generated by
`s` (instead of the inductive predicate `GenerateMeasurable`). This transfinite inductive
construction is parameterized by an ordinal `< Ï‰â‚`, and the cardinality bound is preserved along
each step of the construction. We show in `MeasurableSpace.generateMeasurable_eq_rec` that this
indeed generates this sigma-algebra.
-/


universe u v

variable {Î± : Type u}

open Cardinal Set MeasureTheory

local notation "Ï‰â‚" => Cardinal.ord (aleph 1)

private theorem omegaâ‚_pos : 0 < Ï‰â‚ := by
  rw [â† ord_zero, ord_lt_ord]
  exact aleph_pos 1

namespace MeasurableSpace

/-- Transfinite induction construction of the sigma-algebra generated by a set of sets `s`. At each
step, we add all elements of `s`, the empty set, the complements of already constructed sets, and
countable unions of already constructed sets.

We index this construction by an arbitrary ordinal for simplicity, but by `Ï‰â‚` we will have
generated all the sets in the sigma-algebra.

This construction is very similar to that of the Borel hierarchy. -/
def generateMeasurableRec (s : Set (Set Î±)) (i : Ordinal) : Set (Set Î±) :=
  let S := â‹ƒ j < i, generateMeasurableRec s j
  s âˆª {âˆ…} âˆª compl '' S âˆª Set.range fun f : â„• â†’ S => â‹ƒ n, (f n).1
termination_by i

theorem self_subset_generateMeasurableRec (s : Set (Set Î±)) (i : Ordinal) :
    s âŠ† generateMeasurableRec s i := by
  unfold generateMeasurableRec
  apply_rules [subset_union_of_subset_left]
  exact subset_rfl

theorem empty_mem_generateMeasurableRec (s : Set (Set Î±)) (i : Ordinal) :
    âˆ… âˆˆ generateMeasurableRec s i := by
  unfold generateMeasurableRec
  exact mem_union_left _ (mem_union_left _ (mem_union_right _ (mem_singleton âˆ…)))

theorem compl_mem_generateMeasurableRec {s : Set (Set Î±)} {i j : Ordinal} (h : j < i) {t : Set Î±}
    (ht : t âˆˆ generateMeasurableRec s j) : tá¶œ âˆˆ generateMeasurableRec s i := by
  unfold generateMeasurableRec
  exact mem_union_left _ (mem_union_right _ âŸ¨t, mem_iUnionâ‚‚.2 âŸ¨j, h, htâŸ©, rflâŸ©)

theorem iUnion_mem_generateMeasurableRec {s : Set (Set Î±)} {i : Ordinal} {f : â„• â†’ Set Î±}
    (hf : âˆ€ n, âˆƒ j < i, f n âˆˆ generateMeasurableRec s j) :
    â‹ƒ n, f n âˆˆ generateMeasurableRec s i := by
  unfold generateMeasurableRec
  exact mem_union_right _ âŸ¨fun n => âŸ¨f n, let âŸ¨j, hj, hfâŸ© := hf n; mem_iUnionâ‚‚.2 âŸ¨j, hj, hfâŸ©âŸ©, rflâŸ©

theorem generateMeasurableRec_mono (s : Set (Set Î±)) : Monotone (generateMeasurableRec s) := by
  intro i j h x hx
  rcases h.eq_or_lt with (rfl | h)
  Â· exact hx
  Â· convert iUnion_mem_generateMeasurableRec fun _ => âŸ¨i, h, hxâŸ©
    exact (iUnion_const x).symm

@[deprecated generateMeasurableRec_mono (since := "2024-08-29")]
theorem generateMeasurableRec_subset (s : Set (Set Î±)) {i j : Ordinal} (h : i â‰¤ j) :
    generateMeasurableRec s i âŠ† generateMeasurableRec s j :=
  generateMeasurableRec_mono s h

@[elab_as_elim]
theorem generateMeasurableRec_induction {s : Set (Set Î±)} {i : Ordinal} {t : Set Î±}
    {p : Set Î± â†’ Prop} (hs : âˆ€ t âˆˆ s, p t) (h0 : p âˆ…)
    (hc : âˆ€ u, p u â†’ (âˆƒ j < i, u âˆˆ generateMeasurableRec s j) â†’ p uá¶œ)
    (hn : âˆ€ f : â„• â†’ Set Î±,
      (âˆ€ n, p (f n) âˆ§ âˆƒ j < i, f n âˆˆ generateMeasurableRec s j) â†’ p (â‹ƒ n, f n)) :
    t âˆˆ generateMeasurableRec s i â†’ p t := by
  suffices H : âˆ€ k â‰¤ i, âˆ€ t âˆˆ generateMeasurableRec s k, p t from H i le_rfl t
  intro k
  apply WellFoundedLT.induction k
  intro k IH hk t
  replace IH := fun j hj => IH j hj (hj.le.trans hk)
  unfold generateMeasurableRec
  rintro (((ht | rfl) | ht) | âŸ¨f, rflâŸ©)
  Â· exact hs t ht
  Â· exact h0
  Â· simp_rw [mem_image, mem_iUnionâ‚‚] at ht
    obtain âŸ¨u, âŸ¨âŸ¨j, hj, hj'âŸ©, rflâŸ©âŸ© := ht
    exact hc u (IH j hj u hj') âŸ¨j, hj.trans_le hk, hj'âŸ©
  Â· apply hn
    intro n
    obtain âŸ¨j, hj, hj'âŸ© := mem_iUnionâ‚‚.1 (f n).2
    use IH j hj _ hj', j, hj.trans_le hk

theorem generateMeasurableRec_omegaâ‚ (s : Set (Set Î±)) :
    generateMeasurableRec s (Ï‰â‚ : Ordinal.{v}) =
      â‹ƒ i < (Ï‰â‚ : Ordinal.{v}), generateMeasurableRec s i := by
  apply (iUnionâ‚‚_subset fun i h => generateMeasurableRec_mono s h.le).antisymm'
  intro t ht
  rw [mem_iUnionâ‚‚]
  refine generateMeasurableRec_induction ?_ ?_ ?_ ?_ ht
  Â· intro t ht
    exact âŸ¨0, omegaâ‚_pos, self_subset_generateMeasurableRec s 0 htâŸ©
  Â· exact âŸ¨0, omegaâ‚_pos, empty_mem_generateMeasurableRec s 0âŸ©
  Â· rintro u - âŸ¨j, hj, hj'âŸ©
    exact âŸ¨_, (ord_aleph_isLimit 1).succ_lt hj,
      compl_mem_generateMeasurableRec (Order.lt_succ j) hj'âŸ©
  Â· intro f H
    choose I hI using fun n => (H n).1
    simp_rw [exists_prop] at hI
    refine âŸ¨_, Ordinal.lsub_lt_ord_lift ?_ fun n => (hI n).1,
      iUnion_mem_generateMeasurableRec fun n => âŸ¨_, Ordinal.lt_lsub I n, (hI n).2âŸ©âŸ©
    rw [mk_nat, lift_aleph0, isRegular_aleph_one.cof_eq]
    exact aleph0_lt_aleph_one

theorem generateMeasurableRec_subset_rec (s : Set (Set Î±)) (i : Ordinal) :
    generateMeasurableRec s i âŠ† { t | GenerateMeasurable s t } := by
  apply WellFoundedLT.induction i
  exact fun i IH t ht => generateMeasurableRec_induction .basic .empty
    (fun u _ âŸ¨j, hj, hj'âŸ© => .compl _ (IH j hj hj')) (fun f H => .iUnion _ fun n => (H n).1) ht

/-- `generateMeasurableRec s Ï‰â‚` generates precisely the smallest sigma-algebra containing `s`. -/
theorem generateMeasurable_eq_rec (s : Set (Set Î±)) :
    { t | GenerateMeasurable s t } = generateMeasurableRec s Ï‰â‚ := by
  apply (generateMeasurableRec_subset_rec s _).antisymm'
  intro t ht
  induction' ht with u hu u _ IH f _ IH
  Â· exact self_subset_generateMeasurableRec s _ hu
  Â· exact empty_mem_generateMeasurableRec s _
  Â· rw [generateMeasurableRec_omegaâ‚, mem_iUnionâ‚‚] at IH
    obtain âŸ¨i, hi, hi'âŸ© := IH
    exact generateMeasurableRec_mono _ ((ord_aleph_isLimit 1).succ_lt hi).le
      (compl_mem_generateMeasurableRec (Order.lt_succ i) hi')
  Â· simp_rw [generateMeasurableRec_omegaâ‚, mem_iUnionâ‚‚, exists_prop] at IH
    exact iUnion_mem_generateMeasurableRec IH

theorem generateMeasurable_of_ge_omegaâ‚ (s : Set (Set Î±)) {i : Ordinal.{v}} (hi : Ï‰â‚ â‰¤ i) :
    generateMeasurableRec s i = generateMeasurableRec s (Ï‰â‚ : Ordinal.{v}) := by
  apply (generateMeasurableRec_mono s hi).antisymm'
  rw [â† generateMeasurable_eq_rec]
  exact generateMeasurableRec_subset_rec s i

/-- At each step of the inductive construction, the cardinality bound `â‰¤ #s ^ â„µâ‚€` holds. -/
theorem cardinal_generateMeasurableRec_le {s : Set (Set Î±)} (hs : 2 â‰¤ #s) (i : Ordinal.{v}) :
    #(generateMeasurableRec s i) â‰¤ #s ^ â„µâ‚€ := by
  have : âˆ€ i < Ï‰â‚, #(generateMeasurableRec s i) â‰¤ max #s 2 ^ â„µâ‚€ := by
    intro i
    apply WellFoundedLT.induction i
    intro i IH hi
    have A := aleph0_le_aleph 1
    have B : aleph 1 â‰¤ max #s 2 ^ â„µâ‚€ :=
      aleph_one_le_continuum.trans (power_le_power_right (le_max_right _ _))
    have C : â„µâ‚€ â‰¤ max #s 2 ^ â„µâ‚€ := A.trans B
    have J : #(â‹ƒ j < i, generateMeasurableRec s j) â‰¤ max #s 2 ^ â„µâ‚€ := by
      change #(â‹ƒ j âˆˆ Iio i, generateMeasurableRec s j) â‰¤ _
      rw [â† Cardinal.lift_le.{v + 1}]
      refine (mk_biUnion_le_lift _ _).trans (lift_le.{v + 1}.2 <| max_le B le_rfl)
      rw [mk_ordinal_iio, lift_lift]
      rw [mul_eq_max A C]
      have D : â¨† j : Iio i, lift.{v + 1} #(generateMeasurableRec s j) â‰¤ _ :=
        ciSup_le' fun âŸ¨j, hjâŸ© => IH j hj
      apply (mul_le_mul' ((mk_subtype_le _).trans (aleph 1).mk_ord_toType.le) D).trans
      rw [mul_eq_max A C]
      exact max_le B le_rfl
    rw [generateMeasurableRec]
    apply_rules [(mk_union_le _ _).trans, add_le_of_le C, mk_image_le.trans]
    Â· exact (le_max_left _ _).trans (self_le_power _ one_lt_aleph0.le)
    Â· rw [mk_singleton]
      exact one_lt_aleph0.le.trans C
    Â· apply mk_range_le.trans
      simp only [mk_pi, prod_const, lift_uzero, mk_denumerable, lift_aleph0]
      have := @power_le_power_right _ _ â„µâ‚€ J
      rwa [â† power_mul, aleph0_mul_aleph0] at this

theorem cardinal_generateMeasurableRec_le' (s : Set (Set Î±)) (i : Ordinal.{v}) :
    #(generateMeasurableRec s i) â‰¤ max (#s ^ â„µâ‚€) 4 := by
  obtain hs | hs := le_or_lt #s 1
  Â· apply (mk_le_mk_of_subset (generateMeasurableRec_subset_rec s i)).trans (le_max_of_le_right _)
    rw [mk_le_one_iff_set_subsingleton] at hs
    change #{t | MeasurableSet[generateFrom _] t} â‰¤ _
    obtain rfl | âŸ¨x, rflâŸ© := hs.eq_empty_or_singleton
    Â· simp_rw [generateFrom_empty, measurableSet_bot_iff, â† mem_singleton_iff (b := Set.univ)]
      apply mk_insert_le.trans
      rw [mk_singleton]
      norm_num
    Â· simp_rw [generateFrom_singleton]
  Â· rw [â† Order.succ_le_iff, succ_one] at hs
    exact le_max_of_le_left (cardinal_generateMeasurableRec_le hs i)

/-- If a sigma-algebra is generated by a set of sets `s`, then the sigma-algebra has cardinality at
most `(max #s 2) ^ â„µâ‚€`. -/
theorem cardinal_generateMeasurable_le (s : Set (Set Î±)) :
    #{ t | GenerateMeasurable s t } â‰¤ max #s 2 ^ â„µâ‚€ := by
  rw [generateMeasurable_eq_rec.{u, 0}]
  exact cardinal_generateMeasurableRec_le s _
  /-apply (mk_iUnion_le _).trans
  rw [(aleph 1).mk_ord_toType]
  refine le_trans (mul_le_mul' aleph_one_le_continuum
      (ciSup_le' fun i => cardinal_generateMeasurableRec_le s i)) ?_
  refine (mul_le_max_of_aleph0_le_left aleph0_le_continuum).trans (max_le ?_ le_rfl)
  exact power_le_power_right (le_max_right _ _)-/

/-- If a sigma-algebra is generated by a set of sets `s`, then the sigma
algebra has cardinality at most `(max #s 2) ^ â„µâ‚€`. -/
theorem cardinalMeasurableSet_le (s : Set (Set Î±)) :
    #{ t | @MeasurableSet Î± (generateFrom s) t } â‰¤ max #s 2 ^ â„µâ‚€ :=
  cardinal_generateMeasurable_le s

/-- If a sigma-algebra is generated by a set of sets `s` with cardinality at most the continuum,
then the sigma algebra has the same cardinality bound. -/
theorem cardinal_generateMeasurable_le_continuum {s : Set (Set Î±)} (hs : #s â‰¤ ğ” ) :
    #{ t | GenerateMeasurable s t } â‰¤ ğ”  :=
  (cardinal_generateMeasurable_le s).trans
    (by
      rw [â† continuum_power_aleph0]
      exact mod_cast power_le_power_right (max_le hs (nat_lt_continuum 2).le))

/-- If a sigma-algebra is generated by a set of sets `s` with cardinality at most the continuum,
then the sigma algebra has the same cardinality bound. -/
theorem cardinal_measurableSet_le_continuum {s : Set (Set Î±)} :
    #s â‰¤ ğ”  â†’ #{ t | @MeasurableSet Î± (generateFrom s) t } â‰¤ ğ”  :=
  cardinal_generateMeasurable_le_continuum

end MeasurableSpace
