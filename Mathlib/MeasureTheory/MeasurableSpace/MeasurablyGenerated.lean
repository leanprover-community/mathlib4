/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro
-/
import Mathlib.MeasureTheory.MeasurableSpace.Constructions
import Mathlib.Order.Filter.AtTopBot.CompleteLattice
import Mathlib.Order.Filter.AtTopBot.CountablyGenerated
import Mathlib.Order.Filter.SmallSets
import Mathlib.Order.LiminfLimsup
import Mathlib.Tactic.FinCases

/-!
# Measurably generated filters

We say that a filter `f` is measurably generated if every set `s ‚àà f` includes a measurable
set `t ‚àà f`. This property is useful, e.g., to extract a measurable witness of `Filter.Eventually`.
-/

open Set Filter

universe uŒπ

variable {Œ± Œ≤ Œ≥ Œ¥ : Type*} {Œπ : Sort uŒπ}

namespace MeasurableSpace

/-- The sigma-algebra generated by a single set `s` is `{‚àÖ, s, s·∂ú, univ}`. -/
@[simp] theorem generateFrom_singleton (s : Set Œ±) :
    generateFrom {s} = MeasurableSpace.comap (¬∑ ‚àà s) ‚ä§ := by
  classical
  letI : MeasurableSpace Œ± := generateFrom {s}
  refine le_antisymm (generateFrom_le fun t ht => ‚ü®{True}, trivial, by simp [ht.symm]‚ü©) ?_
  rintro _ ‚ü®u, -, rfl‚ü©
  exact (show MeasurableSet s from GenerateMeasurable.basic _ <| mem_singleton s).mem trivial

lemma generateFrom_singleton_le {m : MeasurableSpace Œ±} {s : Set Œ±} (hs : MeasurableSet s) :
    MeasurableSpace.generateFrom {s} ‚â§ m :=
  generateFrom_le (fun _ ht ‚Ü¶ mem_singleton_iff.1 ht ‚ñ∏ hs)

end MeasurableSpace

namespace MeasureTheory

theorem measurableSet_generateFrom_singleton_iff {s t : Set Œ±} :
    MeasurableSet[MeasurableSpace.generateFrom {s}] t ‚Üî t = ‚àÖ ‚à® t = s ‚à® t = s·∂ú ‚à® t = univ := by
  simp_rw [MeasurableSpace.generateFrom_singleton]
  change t ‚àà {t | _} ‚Üî _
  simp_rw [MeasurableSpace.measurableSet_top, true_and, mem_setOf_eq]
  constructor
  ¬∑ rintro ‚ü®x, rfl‚ü©
    by_cases hT : True ‚àà x
    ¬∑ by_cases hF : False ‚àà x
      ¬∑ refine Or.inr <| Or.inr <| Or.inr <| subset_antisymm (subset_univ _) ?_
        suffices x = univ by simp only [this, preimage_univ, subset_refl]
        refine subset_antisymm (subset_univ _) ?_
        rw [univ_eq_true_false]
        rintro - (rfl | rfl)
        ¬∑ assumption
        ¬∑ assumption
      ¬∑ have hx : x = {True} := by
          ext p
          refine ‚ü®fun hp ‚Ü¶ mem_singleton_iff.2 ?_, fun hp ‚Ü¶ hp ‚ñ∏ hT‚ü©
          by_contra hpneg
          rw [eq_iff_iff, iff_true, ‚Üê false_iff] at hpneg
          exact hF (by convert hp)
        simp [hx]
    ¬∑ by_cases hF : False ‚àà x
      ¬∑ have hx : x = {False} := by
          ext p
          refine ‚ü®fun hp ‚Ü¶ mem_singleton_iff.2 ?_, fun hp ‚Ü¶ hp ‚ñ∏ hF‚ü©
          by_contra hpneg
          simp only [eq_iff_iff, iff_false, not_not] at hpneg
          refine hT ?_
          convert hp
          simpa
        refine Or.inr <| Or.inr <| Or.inl <| ?_
        simp [hx]
        rfl
      ¬∑ refine Or.inl <| subset_antisymm ?_ <| empty_subset _
        suffices x ‚äÜ ‚àÖ by
          rw [subset_empty_iff] at this
          simp only [this, preimage_empty, subset_refl]
        intro p hp
        fin_cases p
        ¬∑ contradiction
        ¬∑ contradiction
  ¬∑ rintro (rfl | rfl | rfl | rfl)
    on_goal 1 => use ‚àÖ
    on_goal 2 => use {True}
    on_goal 3 => use {False}
    on_goal 4 => use Set.univ
    all_goals
      simp [compl_def]

end MeasureTheory

namespace Filter

variable [MeasurableSpace Œ±]

/-- A filter `f` is measurably generates if each `s ‚àà f` includes a measurable `t ‚àà f`. -/
class IsMeasurablyGenerated (f : Filter Œ±) : Prop where
  exists_measurable_subset : ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÉ t ‚àà f, MeasurableSet t ‚àß t ‚äÜ s

instance isMeasurablyGenerated_bot : IsMeasurablyGenerated (‚ä• : Filter Œ±) :=
  ‚ü®fun _ _ => ‚ü®‚àÖ, mem_bot, MeasurableSet.empty, empty_subset _‚ü©‚ü©

instance isMeasurablyGenerated_top : IsMeasurablyGenerated (‚ä§ : Filter Œ±) :=
  ‚ü®fun _s hs => ‚ü®univ, univ_mem, MeasurableSet.univ, fun x _ => hs x‚ü©‚ü©

theorem Eventually.exists_measurable_mem {f : Filter Œ±} [IsMeasurablyGenerated f] {p : Œ± ‚Üí Prop}
    (h : ‚àÄ·∂† x in f, p x) : ‚àÉ s ‚àà f, MeasurableSet s ‚àß ‚àÄ x ‚àà s, p x :=
  IsMeasurablyGenerated.exists_measurable_subset h

theorem Eventually.exists_measurable_mem_of_smallSets {f : Filter Œ±} [IsMeasurablyGenerated f]
    {p : Set Œ± ‚Üí Prop} (h : ‚àÄ·∂† s in f.smallSets, p s) : ‚àÉ s ‚àà f, MeasurableSet s ‚àß p s :=
  let ‚ü®_s, hsf, hs‚ü© := eventually_smallSets.1 h
  let ‚ü®t, htf, htm, hts‚ü© := IsMeasurablyGenerated.exists_measurable_subset hsf
  ‚ü®t, htf, htm, hs t hts‚ü©

instance inf_isMeasurablyGenerated (f g : Filter Œ±) [IsMeasurablyGenerated f]
    [IsMeasurablyGenerated g] : IsMeasurablyGenerated (f ‚äì g) := by
  constructor
  rintro t ‚ü®sf, hsf, sg, hsg, rfl‚ü©
  rcases IsMeasurablyGenerated.exists_measurable_subset hsf with ‚ü®s'f, hs'f, hmf, hs'sf‚ü©
  rcases IsMeasurablyGenerated.exists_measurable_subset hsg with ‚ü®s'g, hs'g, hmg, hs'sg‚ü©
  refine ‚ü®s'f ‚à© s'g, inter_mem_inf hs'f hs'g, hmf.inter hmg, ?_‚ü©
  exact inter_subset_inter hs'sf hs'sg

theorem principal_isMeasurablyGenerated_iff {s : Set Œ±} :
    IsMeasurablyGenerated (ùìü s) ‚Üî MeasurableSet s := by
  refine ‚ü®?_, fun hs => ‚ü®fun t ht => ‚ü®s, mem_principal_self s, hs, ht‚ü©‚ü©‚ü©
  rintro ‚ü®hs‚ü©
  rcases hs (mem_principal_self s) with ‚ü®t, ht, htm, hts‚ü©
  have : t = s := hts.antisymm ht
  rwa [‚Üê this]

alias ‚ü®_, _root_.MeasurableSet.principal_isMeasurablyGenerated‚ü© :=
  principal_isMeasurablyGenerated_iff

instance iInf_isMeasurablyGenerated {f : Œπ ‚Üí Filter Œ±} [‚àÄ i, IsMeasurablyGenerated (f i)] :
    IsMeasurablyGenerated (‚®Ö i, f i) := by
  refine ‚ü®fun s hs => ?_‚ü©
  rw [‚Üê Equiv.plift.surjective.iInf_comp, mem_iInf] at hs
  rcases hs with ‚ü®t, ht, ‚ü®V, hVf, rfl‚ü©‚ü©
  choose U hUf hU using fun i => IsMeasurablyGenerated.exists_measurable_subset (hVf i)
  refine ‚ü®‚ãÇ i : t, U i, ?_, ?_, ?_‚ü©
  ¬∑ rw [‚Üê Equiv.plift.surjective.iInf_comp, mem_iInf]
    exact ‚ü®t, ht, U, hUf, rfl‚ü©
  ¬∑ haveI := ht.countable.toEncodable.countable
    exact MeasurableSet.iInter fun i => (hU i).1
  ¬∑ exact iInter_mono fun i => (hU i).2

end Filter

/-- The set of points for which a sequence of measurable functions converges to a given value
is measurable. -/
@[measurability]
lemma measurableSet_tendsto {_ : MeasurableSpace Œ≤} [MeasurableSpace Œ≥]
    [Countable Œ¥] {l : Filter Œ¥} [l.IsCountablyGenerated]
    (l' : Filter Œ≥) [l'.IsCountablyGenerated] [hl' : l'.IsMeasurablyGenerated]
    {f : Œ¥ ‚Üí Œ≤ ‚Üí Œ≥} (hf : ‚àÄ i, Measurable (f i)) :
    MeasurableSet { x | Tendsto (fun n ‚Ü¶ f n x) l l' } := by
  rcases l.exists_antitone_basis with ‚ü®u, hu‚ü©
  rcases (Filter.hasBasis_self.mpr hl'.exists_measurable_subset).exists_antitone_subbasis with
    ‚ü®v, v_meas, hv‚ü©
  simp only [hu.tendsto_iff hv.toHasBasis, true_imp_iff, true_and, setOf_forall, setOf_exists]
  exact .iInter fun n ‚Ü¶ .iUnion fun _ ‚Ü¶ .biInter (to_countable _) fun i _ ‚Ü¶
    (v_meas n).2.preimage (hf i)

namespace MeasurableSet

variable [MeasurableSpace Œ±]

protected theorem iUnion_of_monotone_of_frequently
    {Œπ : Type*} [Preorder Œπ] [(atTop : Filter Œπ).IsCountablyGenerated] {s : Œπ ‚Üí Set Œ±}
    (hsm : Monotone s) (hs : ‚àÉ·∂† i in atTop, MeasurableSet (s i)) : MeasurableSet (‚ãÉ i, s i) := by
  rcases exists_seq_forall_of_frequently hs with ‚ü®x, hx, hxm‚ü©
  rw [‚Üê hsm.iUnion_comp_tendsto_atTop hx]
  exact .iUnion hxm

protected theorem iInter_of_antitone_of_frequently
    {Œπ : Type*} [Preorder Œπ] [(atTop : Filter Œπ).IsCountablyGenerated] {s : Œπ ‚Üí Set Œ±}
    (hsm : Antitone s) (hs : ‚àÉ·∂† i in atTop, MeasurableSet (s i)) : MeasurableSet (‚ãÇ i, s i) := by
  rw [‚Üê compl_iff, compl_iInter]
  exact .iUnion_of_monotone_of_frequently (compl_anti.comp hsm) <| hs.mono fun _ ‚Ü¶ .compl

protected theorem iUnion_of_monotone {Œπ : Type*} [Preorder Œπ] [IsDirected Œπ (¬∑ ‚â§ ¬∑)]
    [(atTop : Filter Œπ).IsCountablyGenerated] {s : Œπ ‚Üí Set Œ±}
    (hsm : Monotone s) (hs : ‚àÄ i, MeasurableSet (s i)) : MeasurableSet (‚ãÉ i, s i) := by
  cases isEmpty_or_nonempty Œπ with
  | inl _ => simp
  | inr _ => exact .iUnion_of_monotone_of_frequently hsm <| .of_forall hs

protected theorem iInter_of_antitone {Œπ : Type*} [Preorder Œπ] [IsDirected Œπ (¬∑ ‚â§ ¬∑)]
    [(atTop : Filter Œπ).IsCountablyGenerated] {s : Œπ ‚Üí Set Œ±}
    (hsm : Antitone s) (hs : ‚àÄ i, MeasurableSet (s i)) : MeasurableSet (‚ãÇ i, s i) := by
  rw [‚Üê compl_iff, compl_iInter]
  exact .iUnion_of_monotone (compl_anti.comp hsm) fun i ‚Ü¶ (hs i).compl

/-!
### Typeclasses on `Subtype MeasurableSet`
-/

instance Subtype.instMembership : Membership Œ± (Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) :=
  ‚ü®fun s a => a ‚àà (s : Set Œ±)‚ü©

@[simp]
theorem mem_coe (a : Œ±) (s : Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) : a ‚àà (s : Set Œ±) ‚Üî a ‚àà s :=
  Iff.rfl

instance Subtype.instEmptyCollection : EmptyCollection (Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) :=
  ‚ü®‚ü®‚àÖ, MeasurableSet.empty‚ü©‚ü©

@[simp]
theorem coe_empty : ‚Üë(‚àÖ : Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) = (‚àÖ : Set Œ±) :=
  rfl

instance Subtype.instInsert [MeasurableSingletonClass Œ±] :
    Insert Œ± (Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) :=
  ‚ü®fun a s => ‚ü®insert a (s : Set Œ±), s.prop.insert a‚ü©‚ü©

@[simp]
theorem coe_insert [MeasurableSingletonClass Œ±] (a : Œ±)
    (s : Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) :
    ‚Üë(Insert.insert a s) = (Insert.insert a s : Set Œ±) :=
  rfl

instance Subtype.instSingleton [MeasurableSingletonClass Œ±] :
    Singleton Œ± (Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) :=
  ‚ü®fun a => ‚ü®{a}, .singleton _‚ü©‚ü©

@[simp] theorem coe_singleton [MeasurableSingletonClass Œ±] (a : Œ±) :
    ‚Üë({a} : Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) = ({a} : Set Œ±) :=
  rfl

instance Subtype.instLawfulSingleton [MeasurableSingletonClass Œ±] :
    LawfulSingleton Œ± (Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) :=
  ‚ü®fun _ => Subtype.eq <| insert_empty_eq _‚ü©

instance Subtype.instHasCompl : HasCompl (Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) :=
  ‚ü®fun x => ‚ü®x·∂ú, x.prop.compl‚ü©‚ü©

@[simp]
theorem coe_compl (s : Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) : ‚Üës·∂ú = (s·∂ú : Set Œ±) :=
  rfl

instance Subtype.instUnion : Union (Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) :=
  ‚ü®fun x y => ‚ü®(x : Set Œ±) ‚à™ y, x.prop.union y.prop‚ü©‚ü©

@[simp]
theorem coe_union (s t : Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) : ‚Üë(s ‚à™ t) = (s ‚à™ t : Set Œ±) :=
  rfl

instance Subtype.instSup : Max (Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) :=
  ‚ü®fun x y => x ‚à™ y‚ü©

@[simp]
protected theorem sup_eq_union (s t : {s : Set Œ± // MeasurableSet s}) : s ‚äî t = s ‚à™ t := rfl

instance Subtype.instInter : Inter (Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) :=
  ‚ü®fun x y => ‚ü®x ‚à© y, x.prop.inter y.prop‚ü©‚ü©

@[simp]
theorem coe_inter (s t : Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) : ‚Üë(s ‚à© t) = (s ‚à© t : Set Œ±) :=
  rfl

instance Subtype.instInf : Min (Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) :=
  ‚ü®fun x y => x ‚à© y‚ü©

@[simp]
protected theorem inf_eq_inter (s t : {s : Set Œ± // MeasurableSet s}) : s ‚äì t = s ‚à© t := rfl

instance Subtype.instSDiff : SDiff (Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) :=
  ‚ü®fun x y => ‚ü®x \ y, x.prop.diff y.prop‚ü©‚ü©

-- TODO: Why does it complain that `x ‚á® y` is noncomputable?
noncomputable instance Subtype.instHImp : HImp (Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) where
  himp x y := ‚ü®x ‚á® y, x.prop.himp y.prop‚ü©

@[simp]
theorem coe_sdiff (s t : Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) : ‚Üë(s \ t) = (s : Set Œ±) \ t :=
  rfl

@[simp]
lemma coe_himp (s t : Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) : ‚Üë(s ‚á® t) = (s ‚á® t : Set Œ±) := rfl

instance Subtype.instBot : Bot (Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) := ‚ü®‚àÖ‚ü©

@[simp]
theorem coe_bot : ‚Üë(‚ä• : Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) = (‚ä• : Set Œ±) :=
  rfl

instance Subtype.instTop : Top (Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) :=
  ‚ü®‚ü®Set.univ, MeasurableSet.univ‚ü©‚ü©

@[simp]
theorem coe_top : ‚Üë(‚ä§ : Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) = (‚ä§ : Set Œ±) :=
  rfl

noncomputable instance Subtype.instBooleanAlgebra :
    BooleanAlgebra (Subtype (MeasurableSet : Set Œ± ‚Üí Prop)) :=
  Subtype.coe_injective.booleanAlgebra _ coe_union coe_inter coe_top coe_bot coe_compl coe_sdiff
    coe_himp

@[measurability]
theorem measurableSet_blimsup {s : ‚Ñï ‚Üí Set Œ±} {p : ‚Ñï ‚Üí Prop} (h : ‚àÄ n, p n ‚Üí MeasurableSet (s n)) :
    MeasurableSet <| blimsup s atTop p := by
  simp only [blimsup_eq_iInf_biSup_of_nat, iSup_eq_iUnion, iInf_eq_iInter]
  exact .iInter fun _ => .iUnion fun m => .iUnion fun hm => h m hm.1

@[measurability]
theorem measurableSet_bliminf {s : ‚Ñï ‚Üí Set Œ±} {p : ‚Ñï ‚Üí Prop} (h : ‚àÄ n, p n ‚Üí MeasurableSet (s n)) :
    MeasurableSet <| Filter.bliminf s Filter.atTop p := by
  simp only [Filter.bliminf_eq_iSup_biInf_of_nat, iInf_eq_iInter, iSup_eq_iUnion]
  exact .iUnion fun n => .iInter fun m => .iInter fun hm => h m hm.1

@[measurability]
theorem measurableSet_limsup {s : ‚Ñï ‚Üí Set Œ±} (hs : ‚àÄ n, MeasurableSet <| s n) :
    MeasurableSet <| Filter.limsup s Filter.atTop := by
  simpa only [‚Üê blimsup_true] using measurableSet_blimsup fun n _ => hs n

@[measurability]
theorem measurableSet_liminf {s : ‚Ñï ‚Üí Set Œ±} (hs : ‚àÄ n, MeasurableSet <| s n) :
    MeasurableSet <| Filter.liminf s Filter.atTop := by
  simpa only [‚Üê bliminf_true] using measurableSet_bliminf fun n _ => hs n

end MeasurableSet
