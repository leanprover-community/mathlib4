/-
Copyright (c) 2017 Johannes HÃ¶lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes HÃ¶lzl, Mario Carneiro
-/
import Mathlib.MeasureTheory.MeasurableSpace.Constructions
import Mathlib.Order.Filter.AtTopBot.CompleteLattice
import Mathlib.Order.Filter.AtTopBot.CountablyGenerated
import Mathlib.Order.Filter.SmallSets
import Mathlib.Order.LiminfLimsup
import Mathlib.Tactic.FinCases

/-!
# Measurably generated filters

We say that a filter `f` is measurably generated if every set `s âˆˆ f` includes a measurable
set `t âˆˆ f`. This property is useful, e.g., to extract a measurable witness of `Filter.Eventually`.
-/

open Set Filter

universe uÎ¹

variable {Î± Î² Î³ Î´ : Type*} {Î¹ : Sort uÎ¹}

namespace MeasurableSpace

/-- The sigma-algebra generated by a single set `s` is `{âˆ…, s, sá¶œ, univ}`. -/
@[simp] theorem generateFrom_singleton (s : Set Î±) :
    generateFrom {s} = MeasurableSpace.comap (Â· âˆˆ s) âŠ¤ := by
  classical
  letI : MeasurableSpace Î± := generateFrom {s}
  refine le_antisymm (generateFrom_le fun t ht => âŸ¨{True}, trivial, by simp [ht.symm]âŸ©) ?_
  rintro _ âŸ¨u, -, rflâŸ©
  exact (show MeasurableSet s from GenerateMeasurable.basic _ <| mem_singleton s).mem trivial

lemma generateFrom_singleton_le {m : MeasurableSpace Î±} {s : Set Î±} (hs : MeasurableSet s) :
    MeasurableSpace.generateFrom {s} â‰¤ m :=
  generateFrom_le (fun _ ht â†¦ mem_singleton_iff.1 ht â–¸ hs)

end MeasurableSpace

namespace MeasureTheory

theorem measurableSet_generateFrom_singleton_iff {s t : Set Î±} :
    MeasurableSet[MeasurableSpace.generateFrom {s}] t â†” t = âˆ… âˆ¨ t = s âˆ¨ t = sá¶œ âˆ¨ t = univ := by
  simp_rw [MeasurableSpace.generateFrom_singleton]
  unfold MeasurableSet MeasurableSpace.MeasurableSet' MeasurableSpace.comap
  simp_rw [MeasurableSpace.measurableSet_top, true_and]
  constructor
  Â· rintro âŸ¨x, rflâŸ©
    by_cases hT : True âˆˆ x
    Â· by_cases hF : False âˆˆ x
      Â· refine Or.inr <| Or.inr <| Or.inr <| subset_antisymm (subset_univ _) ?_
        suffices x = univ by simp only [this, preimage_univ, subset_refl]
        refine subset_antisymm (subset_univ _) ?_
        rw [univ_eq_true_false]
        rintro - (rfl | rfl)
        Â· assumption
        Â· assumption
      Â· have hx : x = {True} := by
          ext p
          refine âŸ¨fun hp â†¦ mem_singleton_iff.2 ?_, fun hp â†¦ hp â–¸ hTâŸ©
          by_contra hpneg
          rw [eq_iff_iff, iff_true, â† false_iff] at hpneg
          exact hF (by convert hp)
        simp [hx]
    Â· by_cases hF : False âˆˆ x
      Â· have hx : x = {False} := by
          ext p
          refine âŸ¨fun hp â†¦ mem_singleton_iff.2 ?_, fun hp â†¦ hp â–¸ hFâŸ©
          grind
        refine Or.inr <| Or.inr <| Or.inl <| ?_
        simp [hx, compl_def]
      Â· refine Or.inl <| subset_antisymm ?_ <| empty_subset _
        suffices x âŠ† âˆ… by
          rw [subset_empty_iff] at this
          simp only [this, preimage_empty, subset_refl]
        intro p hp
        fin_cases p
        Â· contradiction
        Â· contradiction
  Â· rintro (rfl | rfl | rfl | rfl)
    on_goal 1 => use âˆ…
    on_goal 2 => use {True}
    on_goal 3 => use {False}
    on_goal 4 => use Set.univ
    all_goals
      simp [compl_def]

end MeasureTheory

namespace Filter

variable [MeasurableSpace Î±]

/-- A filter `f` is measurably generates if each `s âˆˆ f` includes a measurable `t âˆˆ f`. -/
class IsMeasurablyGenerated (f : Filter Î±) : Prop where
  exists_measurable_subset : âˆ€ â¦ƒsâ¦„, s âˆˆ f â†’ âˆƒ t âˆˆ f, MeasurableSet t âˆ§ t âŠ† s

instance isMeasurablyGenerated_bot : IsMeasurablyGenerated (âŠ¥ : Filter Î±) :=
  âŸ¨fun _ _ => âŸ¨âˆ…, mem_bot, MeasurableSet.empty, empty_subset _âŸ©âŸ©

instance isMeasurablyGenerated_top : IsMeasurablyGenerated (âŠ¤ : Filter Î±) :=
  âŸ¨fun _s hs => âŸ¨univ, univ_mem, MeasurableSet.univ, fun x _ => hs xâŸ©âŸ©

theorem Eventually.exists_measurable_mem {f : Filter Î±} [IsMeasurablyGenerated f] {p : Î± â†’ Prop}
    (h : âˆ€á¶  x in f, p x) : âˆƒ s âˆˆ f, MeasurableSet s âˆ§ âˆ€ x âˆˆ s, p x :=
  IsMeasurablyGenerated.exists_measurable_subset h

theorem Eventually.exists_measurable_mem_of_smallSets {f : Filter Î±} [IsMeasurablyGenerated f]
    {p : Set Î± â†’ Prop} (h : âˆ€á¶  s in f.smallSets, p s) : âˆƒ s âˆˆ f, MeasurableSet s âˆ§ p s :=
  let âŸ¨_s, hsf, hsâŸ© := eventually_smallSets.1 h
  let âŸ¨t, htf, htm, htsâŸ© := IsMeasurablyGenerated.exists_measurable_subset hsf
  âŸ¨t, htf, htm, hs t htsâŸ©

instance inf_isMeasurablyGenerated (f g : Filter Î±) [IsMeasurablyGenerated f]
    [IsMeasurablyGenerated g] : IsMeasurablyGenerated (f âŠ“ g) := by
  constructor
  rintro t âŸ¨sf, hsf, sg, hsg, rflâŸ©
  rcases IsMeasurablyGenerated.exists_measurable_subset hsf with âŸ¨s'f, hs'f, hmf, hs'sfâŸ©
  rcases IsMeasurablyGenerated.exists_measurable_subset hsg with âŸ¨s'g, hs'g, hmg, hs'sgâŸ©
  refine âŸ¨s'f âˆ© s'g, inter_mem_inf hs'f hs'g, hmf.inter hmg, ?_âŸ©
  exact inter_subset_inter hs'sf hs'sg

theorem principal_isMeasurablyGenerated_iff {s : Set Î±} :
    IsMeasurablyGenerated (ğ“Ÿ s) â†” MeasurableSet s := by
  refine âŸ¨?_, fun hs => âŸ¨fun t ht => âŸ¨s, mem_principal_self s, hs, htâŸ©âŸ©âŸ©
  rintro âŸ¨hsâŸ©
  rcases hs (mem_principal_self s) with âŸ¨t, ht, htm, htsâŸ©
  have : t = s := hts.antisymm ht
  rwa [â† this]

alias âŸ¨_, _root_.MeasurableSet.principal_isMeasurablyGeneratedâŸ© :=
  principal_isMeasurablyGenerated_iff

instance iInf_isMeasurablyGenerated {f : Î¹ â†’ Filter Î±} [âˆ€ i, IsMeasurablyGenerated (f i)] :
    IsMeasurablyGenerated (â¨… i, f i) := by
  refine âŸ¨fun s hs => ?_âŸ©
  rw [â† Equiv.plift.surjective.iInf_comp, mem_iInf] at hs
  rcases hs with âŸ¨t, ht, âŸ¨V, hVf, rflâŸ©âŸ©
  choose U hUf hU using fun i => IsMeasurablyGenerated.exists_measurable_subset (hVf i)
  refine âŸ¨â‹‚ i : t, U i, ?_, ?_, ?_âŸ©
  Â· rw [â† Equiv.plift.surjective.iInf_comp, mem_iInf]
    exact âŸ¨t, ht, U, hUf, rflâŸ©
  Â· haveI := ht.countable.toEncodable.countable
    exact MeasurableSet.iInter fun i => (hU i).1
  Â· exact iInter_mono fun i => (hU i).2

end Filter

/-- The set of points for which a sequence of measurable functions converges to a given value
is measurable. -/
@[measurability]
lemma measurableSet_tendsto {_ : MeasurableSpace Î²} [MeasurableSpace Î³]
    [Countable Î´] {l : Filter Î´} [l.IsCountablyGenerated]
    (l' : Filter Î³) [l'.IsCountablyGenerated] [hl' : l'.IsMeasurablyGenerated]
    {f : Î´ â†’ Î² â†’ Î³} (hf : âˆ€ i, Measurable (f i)) :
    MeasurableSet { x | Tendsto (fun n â†¦ f n x) l l' } := by
  rcases l.exists_antitone_basis with âŸ¨u, huâŸ©
  rcases (Filter.hasBasis_self.mpr hl'.exists_measurable_subset).exists_antitone_subbasis with
    âŸ¨v, v_meas, hvâŸ©
  simp only [hu.tendsto_iff hv.toHasBasis, true_imp_iff, true_and, setOf_forall, setOf_exists]
  exact .iInter fun n â†¦ .iUnion fun _ â†¦ .biInter (to_countable _) fun i _ â†¦
    (v_meas n).2.preimage (hf i)

namespace MeasurableSet

variable [MeasurableSpace Î±]

protected theorem iUnion_of_monotone_of_frequently
    {Î¹ : Type*} [Preorder Î¹] [(atTop : Filter Î¹).IsCountablyGenerated] {s : Î¹ â†’ Set Î±}
    (hsm : Monotone s) (hs : âˆƒá¶  i in atTop, MeasurableSet (s i)) : MeasurableSet (â‹ƒ i, s i) := by
  rcases exists_seq_forall_of_frequently hs with âŸ¨x, hx, hxmâŸ©
  rw [â† hsm.iUnion_comp_tendsto_atTop hx]
  exact .iUnion hxm

protected theorem iInter_of_antitone_of_frequently
    {Î¹ : Type*} [Preorder Î¹] [(atTop : Filter Î¹).IsCountablyGenerated] {s : Î¹ â†’ Set Î±}
    (hsm : Antitone s) (hs : âˆƒá¶  i in atTop, MeasurableSet (s i)) : MeasurableSet (â‹‚ i, s i) := by
  rw [â† compl_iff, compl_iInter]
  exact .iUnion_of_monotone_of_frequently (compl_anti.comp hsm) <| hs.mono fun _ â†¦ .compl

protected theorem iUnion_of_monotone {Î¹ : Type*} [Preorder Î¹] [IsDirected Î¹ (Â· â‰¤ Â·)]
    [(atTop : Filter Î¹).IsCountablyGenerated] {s : Î¹ â†’ Set Î±}
    (hsm : Monotone s) (hs : âˆ€ i, MeasurableSet (s i)) : MeasurableSet (â‹ƒ i, s i) := by
  cases isEmpty_or_nonempty Î¹ with
  | inl _ => simp
  | inr _ => exact .iUnion_of_monotone_of_frequently hsm <| .of_forall hs

protected theorem iInter_of_antitone {Î¹ : Type*} [Preorder Î¹] [IsDirected Î¹ (Â· â‰¤ Â·)]
    [(atTop : Filter Î¹).IsCountablyGenerated] {s : Î¹ â†’ Set Î±}
    (hsm : Antitone s) (hs : âˆ€ i, MeasurableSet (s i)) : MeasurableSet (â‹‚ i, s i) := by
  rw [â† compl_iff, compl_iInter]
  exact .iUnion_of_monotone (compl_anti.comp hsm) fun i â†¦ (hs i).compl

/-!
### Typeclasses on `Subtype MeasurableSet`
-/

instance Subtype.instMembership : Membership Î± (Subtype (MeasurableSet : Set Î± â†’ Prop)) :=
  âŸ¨fun s a => a âˆˆ (s : Set Î±)âŸ©

@[simp]
theorem mem_coe (a : Î±) (s : Subtype (MeasurableSet : Set Î± â†’ Prop)) : a âˆˆ (s : Set Î±) â†” a âˆˆ s :=
  Iff.rfl

instance Subtype.instEmptyCollection : EmptyCollection (Subtype (MeasurableSet : Set Î± â†’ Prop)) :=
  âŸ¨âŸ¨âˆ…, MeasurableSet.emptyâŸ©âŸ©

@[simp]
theorem coe_empty : â†‘(âˆ… : Subtype (MeasurableSet : Set Î± â†’ Prop)) = (âˆ… : Set Î±) :=
  rfl

instance Subtype.instInsert [MeasurableSingletonClass Î±] :
    Insert Î± (Subtype (MeasurableSet : Set Î± â†’ Prop)) :=
  âŸ¨fun a s => âŸ¨insert a (s : Set Î±), s.prop.insert aâŸ©âŸ©

@[simp]
theorem coe_insert [MeasurableSingletonClass Î±] (a : Î±)
    (s : Subtype (MeasurableSet : Set Î± â†’ Prop)) :
    â†‘(Insert.insert a s) = (Insert.insert a s : Set Î±) :=
  rfl

instance Subtype.instSingleton [MeasurableSingletonClass Î±] :
    Singleton Î± (Subtype (MeasurableSet : Set Î± â†’ Prop)) :=
  âŸ¨fun a => âŸ¨{a}, .singleton _âŸ©âŸ©

@[simp] theorem coe_singleton [MeasurableSingletonClass Î±] (a : Î±) :
    â†‘({a} : Subtype (MeasurableSet : Set Î± â†’ Prop)) = ({a} : Set Î±) :=
  rfl

instance Subtype.instLawfulSingleton [MeasurableSingletonClass Î±] :
    LawfulSingleton Î± (Subtype (MeasurableSet : Set Î± â†’ Prop)) :=
  âŸ¨fun _ => Subtype.ext <| insert_empty_eq _âŸ©

instance Subtype.instHasCompl : HasCompl (Subtype (MeasurableSet : Set Î± â†’ Prop)) :=
  âŸ¨fun x => âŸ¨xá¶œ, x.prop.complâŸ©âŸ©

@[simp]
theorem coe_compl (s : Subtype (MeasurableSet : Set Î± â†’ Prop)) : â†‘sá¶œ = (sá¶œ : Set Î±) :=
  rfl

instance Subtype.instUnion : Union (Subtype (MeasurableSet : Set Î± â†’ Prop)) :=
  âŸ¨fun x y => âŸ¨(x : Set Î±) âˆª y, x.prop.union y.propâŸ©âŸ©

@[simp]
theorem coe_union (s t : Subtype (MeasurableSet : Set Î± â†’ Prop)) : â†‘(s âˆª t) = (s âˆª t : Set Î±) :=
  rfl

instance Subtype.instSup : Max (Subtype (MeasurableSet : Set Î± â†’ Prop)) :=
  âŸ¨fun x y => x âˆª yâŸ©

@[simp]
protected theorem sup_eq_union (s t : {s : Set Î± // MeasurableSet s}) : s âŠ” t = s âˆª t := rfl

instance Subtype.instInter : Inter (Subtype (MeasurableSet : Set Î± â†’ Prop)) :=
  âŸ¨fun x y => âŸ¨x âˆ© y, x.prop.inter y.propâŸ©âŸ©

@[simp]
theorem coe_inter (s t : Subtype (MeasurableSet : Set Î± â†’ Prop)) : â†‘(s âˆ© t) = (s âˆ© t : Set Î±) :=
  rfl

instance Subtype.instInf : Min (Subtype (MeasurableSet : Set Î± â†’ Prop)) :=
  âŸ¨fun x y => x âˆ© yâŸ©

@[simp]
protected theorem inf_eq_inter (s t : {s : Set Î± // MeasurableSet s}) : s âŠ“ t = s âˆ© t := rfl

instance Subtype.instSDiff : SDiff (Subtype (MeasurableSet : Set Î± â†’ Prop)) :=
  âŸ¨fun x y => âŸ¨x \ y, x.prop.diff y.propâŸ©âŸ©

-- TODO: Why does it complain that `x â‡¨ y` is noncomputable?
noncomputable instance Subtype.instHImp : HImp (Subtype (MeasurableSet : Set Î± â†’ Prop)) where
  himp x y := âŸ¨x â‡¨ y, x.prop.himp y.propâŸ©

@[simp]
theorem coe_sdiff (s t : Subtype (MeasurableSet : Set Î± â†’ Prop)) : â†‘(s \ t) = (s : Set Î±) \ t :=
  rfl

@[simp]
lemma coe_himp (s t : Subtype (MeasurableSet : Set Î± â†’ Prop)) : â†‘(s â‡¨ t) = (s â‡¨ t : Set Î±) := rfl

instance Subtype.instBot : Bot (Subtype (MeasurableSet : Set Î± â†’ Prop)) := âŸ¨âˆ…âŸ©

@[simp]
theorem coe_bot : â†‘(âŠ¥ : Subtype (MeasurableSet : Set Î± â†’ Prop)) = (âŠ¥ : Set Î±) :=
  rfl

instance Subtype.instTop : Top (Subtype (MeasurableSet : Set Î± â†’ Prop)) :=
  âŸ¨âŸ¨Set.univ, MeasurableSet.univâŸ©âŸ©

@[simp]
theorem coe_top : â†‘(âŠ¤ : Subtype (MeasurableSet : Set Î± â†’ Prop)) = (âŠ¤ : Set Î±) :=
  rfl

noncomputable instance Subtype.instBooleanAlgebra :
    BooleanAlgebra (Subtype (MeasurableSet : Set Î± â†’ Prop)) :=
  Subtype.coe_injective.booleanAlgebra _ coe_union coe_inter coe_top coe_bot coe_compl coe_sdiff
    coe_himp

@[measurability]
theorem measurableSet_blimsup {s : â„• â†’ Set Î±} {p : â„• â†’ Prop} (h : âˆ€ n, p n â†’ MeasurableSet (s n)) :
    MeasurableSet <| blimsup s atTop p := by
  simp only [blimsup_eq_iInf_biSup_of_nat, iSup_eq_iUnion, iInf_eq_iInter]
  exact .iInter fun _ => .iUnion fun m => .iUnion fun hm => h m hm.1

@[measurability]
theorem measurableSet_bliminf {s : â„• â†’ Set Î±} {p : â„• â†’ Prop} (h : âˆ€ n, p n â†’ MeasurableSet (s n)) :
    MeasurableSet <| Filter.bliminf s Filter.atTop p := by
  simp only [Filter.bliminf_eq_iSup_biInf_of_nat, iInf_eq_iInter, iSup_eq_iUnion]
  exact .iUnion fun n => .iInter fun m => .iInter fun hm => h m hm.1

@[measurability]
theorem measurableSet_limsup {s : â„• â†’ Set Î±} (hs : âˆ€ n, MeasurableSet <| s n) :
    MeasurableSet <| Filter.limsup s Filter.atTop := by
  simpa only [â† blimsup_true] using measurableSet_blimsup fun n _ => hs n

@[measurability]
theorem measurableSet_liminf {s : â„• â†’ Set Î±} (hs : âˆ€ n, MeasurableSet <| s n) :
    MeasurableSet <| Filter.liminf s Filter.atTop := by
  simpa only [â† bliminf_true] using measurableSet_bliminf fun n _ => hs n

end MeasurableSet
