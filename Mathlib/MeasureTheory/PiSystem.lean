/-
Copyright (c) 2021 Martin Zinkevich. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes HÃ¶lzl, Martin Zinkevich, RÃ©my Degenne
-/
import Mathlib.Logic.Encodable.Lattice
import Mathlib.MeasureTheory.MeasurableSpaceDef

#align_import measure_theory.pi_system from "leanprover-community/mathlib"@"98e83c3d541c77cdb7da20d79611a780ff8e7d90"

/-!
# Induction principles for measurable sets, related to Ï€-systems and Î»-systems.

## Main statements

* The main theorem of this file is Dynkin's Ï€-Î» theorem, which appears
  here as an induction principle `induction_on_inter`. Suppose `s` is a
  collection of subsets of `Î±` such that the intersection of two members
  of `s` belongs to `s` whenever it is nonempty. Let `m` be the Ïƒ-algebra
  generated by `s`. In order to check that a predicate `C` holds on every
  member of `m`, it suffices to check that `C` holds on the members of `s` and
  that `C` is preserved by complementation and *disjoint* countable
  unions.

* The proof of this theorem relies on the notion of `IsPiSystem`, i.e., a collection of sets
  which is closed under binary non-empty intersections. Note that this is a small variation around
  the usual notion in the literature, which often requires that a Ï€-system is non-empty, and closed
  also under disjoint intersections. This variation turns out to be convenient for the
  formalization.

* The proof of Dynkin's Ï€-Î» theorem also requires the notion of `DynkinSystem`, i.e., a collection
  of sets which contains the empty set, is closed under complementation and under countable union
  of pairwise disjoint sets. The disjointness condition is the only difference with `Ïƒ`-algebras.

* `generatePiSystem g` gives the minimal Ï€-system containing `g`.
  This can be considered a Galois insertion into both measurable spaces and sets.

* `generateFrom_generatePiSystem_eq` proves that if you start from a collection of sets `g`,
  take the generated Ï€-system, and then the generated Ïƒ-algebra, you get the same result as
  the Ïƒ-algebra generated from `g`. This is useful because there are connections between
  independent sets that are Ï€-systems and the generated independent spaces.

* `mem_generatePiSystem_iUnion_elim` and `mem_generatePiSystem_iUnion_elim'` show that any
  element of the Ï€-system generated from the union of a set of Ï€-systems can be
  represented as the intersection of a finite number of elements from these sets.

* `piiUnionInter` defines a new Ï€-system from a family of Ï€-systems `Ï€ : Î¹ â†’ Set (Set Î±)` and a
  set of indices `S : Set Î¹`. `piiUnionInter Ï€ S` is the set of sets that can be written
  as `â‹‚ x âˆˆ t, f x` for some finset `t âˆˆ S` and sets `f x âˆˆ Ï€ x`.

## Implementation details

* `IsPiSystem` is a predicate, not a type. Thus, we don't explicitly define the galois
  insertion, nor do we define a complete lattice. In theory, we could define a complete
  lattice and galois insertion on the subtype corresponding to `IsPiSystem`.
-/


open MeasurableSpace Set

open Classical MeasureTheory

/-- A Ï€-system is a collection of subsets of `Î±` that is closed under binary intersection of
  non-disjoint sets. Usually it is also required that the collection is nonempty, but we don't do
  that here. -/
def IsPiSystem {Î±} (C : Set (Set Î±)) : Prop :=
  âˆ€áµ‰ (s âˆˆ C) (t âˆˆ C), (s âˆ© t : Set Î±).Nonempty â†’ s âˆ© t âˆˆ C
#align is_pi_system IsPiSystem

namespace MeasurableSpace

theorem isPiSystem_measurableSet {Î± : Type*} [MeasurableSpace Î±] :
    IsPiSystem { s : Set Î± | MeasurableSet s } := fun _ hs _ ht _ => hs.inter ht
#align measurable_space.is_pi_system_measurable_set MeasurableSpace.isPiSystem_measurableSet

end MeasurableSpace

theorem IsPiSystem.singleton {Î±} (S : Set Î±) : IsPiSystem ({S} : Set (Set Î±)) := by
  intro s h_s t h_t _
  -- âŠ¢ s âˆ© t âˆˆ {S}
  rw [Set.mem_singleton_iff.1 h_s, Set.mem_singleton_iff.1 h_t, Set.inter_self,
    Set.mem_singleton_iff]
#align is_pi_system.singleton IsPiSystem.singleton

theorem IsPiSystem.insert_empty {Î±} {S : Set (Set Î±)} (h_pi : IsPiSystem S) :
    IsPiSystem (insert âˆ… S) := by
  intro s hs t ht hst
  -- âŠ¢ s âˆ© t âˆˆ insert âˆ… S
  cases' hs with hs hs
  -- âŠ¢ s âˆ© t âˆˆ insert âˆ… S
  Â· simp [hs]
    -- ğŸ‰ no goals
  Â· cases' ht with ht ht
    -- âŠ¢ s âˆ© t âˆˆ insert âˆ… S
    Â· simp [ht]
      -- ğŸ‰ no goals
    Â· exact Set.mem_insert_of_mem _ (h_pi s hs t ht hst)
      -- ğŸ‰ no goals
#align is_pi_system.insert_empty IsPiSystem.insert_empty

theorem IsPiSystem.insert_univ {Î±} {S : Set (Set Î±)} (h_pi : IsPiSystem S) :
    IsPiSystem (insert Set.univ S) := by
  intro s hs t ht hst
  -- âŠ¢ s âˆ© t âˆˆ insert univ S
  cases' hs with hs hs
  -- âŠ¢ s âˆ© t âˆˆ insert univ S
  Â· cases' ht with ht ht <;> simp [hs, ht]
    -- âŠ¢ s âˆ© t âˆˆ insert univ S
                             -- ğŸ‰ no goals
                             -- ğŸ‰ no goals
  Â· cases' ht with ht ht
    -- âŠ¢ s âˆ© t âˆˆ insert univ S
    Â· simp [hs, ht]
      -- ğŸ‰ no goals
    Â· exact Set.mem_insert_of_mem _ (h_pi s hs t ht hst)
      -- ğŸ‰ no goals
#align is_pi_system.insert_univ IsPiSystem.insert_univ

theorem IsPiSystem.comap {Î± Î²} {S : Set (Set Î²)} (h_pi : IsPiSystem S) (f : Î± â†’ Î²) :
    IsPiSystem { s : Set Î± | âˆƒ t âˆˆ S, f â»Â¹' t = s } := by
  rintro _ âŸ¨s, hs_mem, rflâŸ© _ âŸ¨t, ht_mem, rflâŸ© hst
  -- âŠ¢ f â»Â¹' s âˆ© f â»Â¹' t âˆˆ {s | âˆƒ t, t âˆˆ S âˆ§ f â»Â¹' t = s}
  rw [â† Set.preimage_inter] at hst âŠ¢
  -- âŠ¢ f â»Â¹' (s âˆ© t) âˆˆ {s | âˆƒ t, t âˆˆ S âˆ§ f â»Â¹' t = s}
  refine' âŸ¨s âˆ© t, h_pi s hs_mem t ht_mem _, rflâŸ©
  -- âŠ¢ Set.Nonempty (s âˆ© t)
  by_contra h
  -- âŠ¢ False
  rw [Set.not_nonempty_iff_eq_empty] at h
  -- âŠ¢ False
  rw [h] at hst
  -- âŠ¢ False
  simp at hst
  -- ğŸ‰ no goals
#align is_pi_system.comap IsPiSystem.comap

theorem isPiSystem_iUnion_of_directed_le {Î± Î¹} (p : Î¹ â†’ Set (Set Î±))
    (hp_pi : âˆ€ n, IsPiSystem (p n)) (hp_directed : Directed (Â· â‰¤ Â·) p) :
    IsPiSystem (â‹ƒ n, p n) := by
  intro t1 ht1 t2 ht2 h
  -- âŠ¢ t1 âˆ© t2 âˆˆ â‹ƒ (n : Î¹), p n
  rw [Set.mem_iUnion] at ht1 ht2 âŠ¢
  -- âŠ¢ âˆƒ i, t1 âˆ© t2 âˆˆ p i
  cases' ht1 with n ht1
  -- âŠ¢ âˆƒ i, t1 âˆ© t2 âˆˆ p i
  cases' ht2 with m ht2
  -- âŠ¢ âˆƒ i, t1 âˆ© t2 âˆˆ p i
  obtain âŸ¨k, hpnk, hpmkâŸ© : âˆƒ k, p n â‰¤ p k âˆ§ p m â‰¤ p k := hp_directed n m
  -- âŠ¢ âˆƒ i, t1 âˆ© t2 âˆˆ p i
  exact âŸ¨k, hp_pi k t1 (hpnk ht1) t2 (hpmk ht2) hâŸ©
  -- ğŸ‰ no goals
#align is_pi_system_Union_of_directed_le isPiSystem_iUnion_of_directed_le

theorem isPiSystem_iUnion_of_monotone {Î± Î¹} [SemilatticeSup Î¹] (p : Î¹ â†’ Set (Set Î±))
    (hp_pi : âˆ€ n, IsPiSystem (p n)) (hp_mono : Monotone p) : IsPiSystem (â‹ƒ n, p n) :=
  isPiSystem_iUnion_of_directed_le p hp_pi (Monotone.directed_le hp_mono)
#align is_pi_system_Union_of_monotone isPiSystem_iUnion_of_monotone

section Order

variable {Î± : Type*} {Î¹ Î¹' : Sort*} [LinearOrder Î±]

theorem isPiSystem_image_Iio (s : Set Î±) : IsPiSystem (Iio '' s) := by
  rintro _ âŸ¨a, ha, rflâŸ© _ âŸ¨b, hb, rflâŸ© -
  -- âŠ¢ Iio a âˆ© Iio b âˆˆ Iio '' s
  exact âŸ¨a âŠ“ b, inf_ind a b ha hb, Iio_inter_Iio.symmâŸ©
  -- ğŸ‰ no goals
#align is_pi_system_image_Iio isPiSystem_image_Iio

theorem isPiSystem_Iio : IsPiSystem (range Iio : Set (Set Î±)) :=
  @image_univ Î± _ Iio â–¸ isPiSystem_image_Iio univ
#align is_pi_system_Iio isPiSystem_Iio

theorem isPiSystem_image_Ioi (s : Set Î±) : IsPiSystem (Ioi '' s) :=
  @isPiSystem_image_Iio Î±áµ’áµˆ _ s
#align is_pi_system_image_Ioi isPiSystem_image_Ioi

theorem isPiSystem_Ioi : IsPiSystem (range Ioi : Set (Set Î±)) :=
  @image_univ Î± _ Ioi â–¸ isPiSystem_image_Ioi univ
#align is_pi_system_Ioi isPiSystem_Ioi

theorem isPiSystem_image_Iic (s : Set Î±) : IsPiSystem (Iic '' s) := by
  rintro _ âŸ¨a, ha, rflâŸ© _ âŸ¨b, hb, rflâŸ© -
  -- âŠ¢ Iic a âˆ© Iic b âˆˆ Iic '' s
  exact âŸ¨a âŠ“ b, inf_ind a b ha hb, Iic_inter_Iic.symmâŸ©
  -- ğŸ‰ no goals

theorem isPiSystem_Iic : IsPiSystem (range Iic : Set (Set Î±)) :=
  @image_univ Î± _ Iic â–¸ isPiSystem_image_Iic univ
#align is_pi_system_Iic isPiSystem_Iic

theorem isPiSystem_image_Ici (s : Set Î±) : IsPiSystem (Ici '' s) :=
  @isPiSystem_image_Iic Î±áµ’áµˆ _ s

theorem isPiSystem_Ici : IsPiSystem (range Ici : Set (Set Î±)) :=
  @image_univ Î± _ Ici â–¸ isPiSystem_image_Ici univ
#align is_pi_system_Ici isPiSystem_Ici

-- porting note: change `âˆƒ (_ : p l u), _` to `_ âˆ§ _`
theorem isPiSystem_Ixx_mem {Ixx : Î± â†’ Î± â†’ Set Î±} {p : Î± â†’ Î± â†’ Prop}
    (Hne : âˆ€ {a b}, (Ixx a b).Nonempty â†’ p a b)
    (Hi : âˆ€ {aâ‚ bâ‚ aâ‚‚ bâ‚‚}, Ixx aâ‚ bâ‚ âˆ© Ixx aâ‚‚ bâ‚‚ = Ixx (max aâ‚ aâ‚‚) (min bâ‚ bâ‚‚)) (s t : Set Î±) :
    IsPiSystem { S | âˆƒáµ‰ (l âˆˆ s) (u âˆˆ t), p l u âˆ§ Ixx l u = S } := by
  rintro _ âŸ¨lâ‚, hlsâ‚, uâ‚, hutâ‚, _, rflâŸ© _ âŸ¨lâ‚‚, hlsâ‚‚, uâ‚‚, hutâ‚‚, _, rflâŸ©
  -- âŠ¢ Set.Nonempty (Ixx lâ‚ uâ‚ âˆ© Ixx lâ‚‚ uâ‚‚) â†’ Ixx lâ‚ uâ‚ âˆ© Ixx lâ‚‚ uâ‚‚ âˆˆ {S | âˆƒ l, l âˆˆ â€¦
  simp only [Hi]
  -- âŠ¢ Set.Nonempty (Ixx (max lâ‚ lâ‚‚) (min uâ‚ uâ‚‚)) â†’ Ixx (max lâ‚ lâ‚‚) (min uâ‚ uâ‚‚) âˆˆ { â€¦
  exact fun H => âŸ¨lâ‚ âŠ” lâ‚‚, sup_ind lâ‚ lâ‚‚ hlsâ‚ hlsâ‚‚, uâ‚ âŠ“ uâ‚‚, inf_ind uâ‚ uâ‚‚ hutâ‚ hutâ‚‚, Hne H, rflâŸ©
  -- ğŸ‰ no goals
#align is_pi_system_Ixx_mem isPiSystem_Ixx_mem

-- porting note: change `âˆƒ (_ : p l u), _` to `_ âˆ§ _`
theorem isPiSystem_Ixx {Ixx : Î± â†’ Î± â†’ Set Î±} {p : Î± â†’ Î± â†’ Prop}
    (Hne : âˆ€ {a b}, (Ixx a b).Nonempty â†’ p a b)
    (Hi : âˆ€ {aâ‚ bâ‚ aâ‚‚ bâ‚‚}, Ixx aâ‚ bâ‚ âˆ© Ixx aâ‚‚ bâ‚‚ = Ixx (max aâ‚ aâ‚‚) (min bâ‚ bâ‚‚)) (f : Î¹ â†’ Î±)
    (g : Î¹' â†’ Î±) : @IsPiSystem Î± { S | âˆƒ i j, p (f i) (g j) âˆ§ Ixx (f i) (g j) = S } := by
  simpa only [exists_range_iff] using isPiSystem_Ixx_mem (@Hne) (@Hi) (range f) (range g)
  -- ğŸ‰ no goals
#align is_pi_system_Ixx isPiSystem_Ixx

-- porting note: change `âˆƒ (_ : p l u), _` to `_ âˆ§ _`
theorem isPiSystem_Ioo_mem (s t : Set Î±) :
    IsPiSystem { S | âˆƒáµ‰ (l âˆˆ s) (u âˆˆ t), l < u âˆ§ Ioo l u = S } :=
  isPiSystem_Ixx_mem (Ixx := Ioo) (fun âŸ¨_, hax, hxbâŸ© => hax.trans hxb) Ioo_inter_Ioo s t
#align is_pi_system_Ioo_mem isPiSystem_Ioo_mem

-- porting note: change `âˆƒ (_ : p l u), _` to `_ âˆ§ _`
theorem isPiSystem_Ioo (f : Î¹ â†’ Î±) (g : Î¹' â†’ Î±) :
    @IsPiSystem Î± { S | âˆƒ l u, f l < g u âˆ§ Ioo (f l) (g u) = S } :=
  isPiSystem_Ixx (Ixx := Ioo) (fun âŸ¨_, hax, hxbâŸ© => hax.trans hxb) Ioo_inter_Ioo f g
#align is_pi_system_Ioo isPiSystem_Ioo

-- porting note: change `âˆƒ (_ : p l u), _` to `_ âˆ§ _`
theorem isPiSystem_Ioc_mem (s t : Set Î±) :
    IsPiSystem { S | âˆƒáµ‰ (l âˆˆ s) (u âˆˆ t), l < u âˆ§ Ioc l u = S } :=
  isPiSystem_Ixx_mem (Ixx := Ioc) (fun âŸ¨_, hax, hxbâŸ© => hax.trans_le hxb) Ioc_inter_Ioc s t
#align is_pi_system_Ioc_mem isPiSystem_Ioc_mem

-- porting note: change `âˆƒ (_ : p l u), _` to `_ âˆ§ _`
theorem isPiSystem_Ioc (f : Î¹ â†’ Î±) (g : Î¹' â†’ Î±) :
    @IsPiSystem Î± { S | âˆƒ i j, f i < g j âˆ§ Ioc (f i) (g j) = S } :=
  isPiSystem_Ixx (Ixx := Ioc) (fun âŸ¨_, hax, hxbâŸ© => hax.trans_le hxb) Ioc_inter_Ioc f g
#align is_pi_system_Ioc isPiSystem_Ioc

-- porting note: change `âˆƒ (_ : p l u), _` to `_ âˆ§ _`
theorem isPiSystem_Ico_mem (s t : Set Î±) :
    IsPiSystem { S | âˆƒáµ‰ (l âˆˆ s) (u âˆˆ t), l < u âˆ§ Ico l u = S } :=
  isPiSystem_Ixx_mem (Ixx := Ico) (fun âŸ¨_, hax, hxbâŸ© => hax.trans_lt hxb) Ico_inter_Ico s t
#align is_pi_system_Ico_mem isPiSystem_Ico_mem

-- porting note: change `âˆƒ (_ : p l u), _` to `_ âˆ§ _`
theorem isPiSystem_Ico (f : Î¹ â†’ Î±) (g : Î¹' â†’ Î±) :
    @IsPiSystem Î± { S | âˆƒ i j, f i < g j âˆ§ Ico (f i) (g j) = S } :=
  isPiSystem_Ixx (Ixx := Ico) (fun âŸ¨_, hax, hxbâŸ© => hax.trans_lt hxb) Ico_inter_Ico f g
#align is_pi_system_Ico isPiSystem_Ico

-- porting note: change `âˆƒ (_ : p l u), _` to `_ âˆ§ _`
theorem isPiSystem_Icc_mem (s t : Set Î±) :
    IsPiSystem { S | âˆƒáµ‰ (l âˆˆ s) (u âˆˆ t), l â‰¤ u âˆ§ Icc l u = S } :=
  isPiSystem_Ixx_mem (Ixx := Icc) nonempty_Icc.1 (by exact Icc_inter_Icc) s t
                                                     -- ğŸ‰ no goals
#align is_pi_system_Icc_mem isPiSystem_Icc_mem

-- porting note: change `âˆƒ (_ : p l u), _` to `_ âˆ§ _`
theorem isPiSystem_Icc (f : Î¹ â†’ Î±) (g : Î¹' â†’ Î±) :
    @IsPiSystem Î± { S | âˆƒ i j, f i â‰¤ g j âˆ§ Icc (f i) (g j) = S } :=
  isPiSystem_Ixx (Ixx := Icc) nonempty_Icc.1 (by exact Icc_inter_Icc) f g
                                                 -- ğŸ‰ no goals
#align is_pi_system_Icc isPiSystem_Icc

end Order

/-- Given a collection `S` of subsets of `Î±`, then `generatePiSystem S` is the smallest
Ï€-system containing `S`. -/
inductive generatePiSystem {Î±} (S : Set (Set Î±)) : Set (Set Î±)
  | base {s : Set Î±} (h_s : s âˆˆ S) : generatePiSystem S s
  | inter {s t : Set Î±} (h_s : generatePiSystem S s) (h_t : generatePiSystem S t)
    (h_nonempty : (s âˆ© t).Nonempty) : generatePiSystem S (s âˆ© t)
#align generate_pi_system generatePiSystem

theorem isPiSystem_generatePiSystem {Î±} (S : Set (Set Î±)) : IsPiSystem (generatePiSystem S) :=
  fun _ h_s _ h_t h_nonempty => generatePiSystem.inter h_s h_t h_nonempty
#align is_pi_system_generate_pi_system isPiSystem_generatePiSystem

theorem subset_generatePiSystem_self {Î±} (S : Set (Set Î±)) : S âŠ† generatePiSystem S := fun _ =>
  generatePiSystem.base
#align subset_generate_pi_system_self subset_generatePiSystem_self

theorem generatePiSystem_subset_self {Î±} {S : Set (Set Î±)} (h_S : IsPiSystem S) :
    generatePiSystem S âŠ† S := fun x h => by
  induction' h with _ h_s s u _ _ h_nonempty h_s h_u
  -- âŠ¢ sâœ âˆˆ S
  Â· exact h_s
    -- ğŸ‰ no goals
  Â· exact h_S _ h_s _ h_u h_nonempty
    -- ğŸ‰ no goals
#align generate_pi_system_subset_self generatePiSystem_subset_self

theorem generatePiSystem_eq {Î±} {S : Set (Set Î±)} (h_pi : IsPiSystem S) : generatePiSystem S = S :=
  Set.Subset.antisymm (generatePiSystem_subset_self h_pi) (subset_generatePiSystem_self S)
#align generate_pi_system_eq generatePiSystem_eq

theorem generatePiSystem_mono {Î±} {S T : Set (Set Î±)} (hST : S âŠ† T) :
    generatePiSystem S âŠ† generatePiSystem T := fun t ht => by
  induction' ht with s h_s s u _ _ h_nonempty h_s h_u
  -- âŠ¢ s âˆˆ generatePiSystem T
  Â· exact generatePiSystem.base (Set.mem_of_subset_of_mem hST h_s)
    -- ğŸ‰ no goals
  Â· exact isPiSystem_generatePiSystem T _ h_s _ h_u h_nonempty
    -- ğŸ‰ no goals
#align generate_pi_system_mono generatePiSystem_mono

theorem generatePiSystem_measurableSet {Î±} [M : MeasurableSpace Î±] {S : Set (Set Î±)}
    (h_meas_S : âˆ€ s âˆˆ S, MeasurableSet s) (t : Set Î±) (h_in_pi : t âˆˆ generatePiSystem S) :
    MeasurableSet t := by
  induction' h_in_pi with s h_s s u _ _ _ h_s h_u
  -- âŠ¢ MeasurableSet s
  Â· apply h_meas_S _ h_s
    -- ğŸ‰ no goals
  Â· apply MeasurableSet.inter h_s h_u
    -- ğŸ‰ no goals
#align generate_pi_system_measurable_set generatePiSystem_measurableSet

theorem generateFrom_measurableSet_of_generatePiSystem {Î±} {g : Set (Set Î±)} (t : Set Î±)
    (ht : t âˆˆ generatePiSystem g) : MeasurableSet[generateFrom g] t :=
  @generatePiSystem_measurableSet Î± (generateFrom g) g
    (fun _ h_s_in_g => measurableSet_generateFrom h_s_in_g) t ht
#align generate_from_measurable_set_of_generate_pi_system generateFrom_measurableSet_of_generatePiSystem

theorem generateFrom_generatePiSystem_eq {Î±} {g : Set (Set Î±)} :
    generateFrom (generatePiSystem g) = generateFrom g := by
  apply le_antisymm <;> apply generateFrom_le
  -- âŠ¢ generateFrom (generatePiSystem g) â‰¤ generateFrom g
                        -- âŠ¢ âˆ€ (t : Set Î±), t âˆˆ generatePiSystem g â†’ MeasurableSet t
                        -- âŠ¢ âˆ€ (t : Set Î±), t âˆˆ g â†’ MeasurableSet t
  Â· exact fun t h_t => generateFrom_measurableSet_of_generatePiSystem t h_t
    -- ğŸ‰ no goals
  Â· exact fun t h_t => measurableSet_generateFrom (generatePiSystem.base h_t)
    -- ğŸ‰ no goals
#align generate_from_generate_pi_system_eq generateFrom_generatePiSystem_eq

/- Every element of the Ï€-system generated by the union of a family of Ï€-systems
is a finite intersection of elements from the Ï€-systems.
For an indexed union version, see `mem_generatePiSystem_iUnion_elim'`. -/
theorem mem_generatePiSystem_iUnion_elim {Î± Î²} {g : Î² â†’ Set (Set Î±)} (h_pi : âˆ€ b, IsPiSystem (g b))
    (t : Set Î±) (h_t : t âˆˆ generatePiSystem (â‹ƒ b, g b)) :
    âˆƒ (T : Finset Î²) (f : Î² â†’ Set Î±), (t = â‹‚ b âˆˆ T, f b) âˆ§ âˆ€ b âˆˆ T, f b âˆˆ g b := by
  induction' h_t with s h_s s t' h_gen_s h_gen_t' h_nonempty h_s h_t'
  -- âŠ¢ âˆƒ T f, s = â‹‚ (b : Î²) (_ : b âˆˆ T), f b âˆ§ âˆ€ (b : Î²), b âˆˆ T â†’ f b âˆˆ g b
  Â· rcases h_s with âŸ¨t', âŸ¨âŸ¨b, rflâŸ©, h_s_in_t'âŸ©âŸ©
    -- âŠ¢ âˆƒ T f, s = â‹‚ (b : Î²) (_ : b âˆˆ T), f b âˆ§ âˆ€ (b : Î²), b âˆˆ T â†’ f b âˆˆ g b
    refine' âŸ¨{b}, fun _ => s, _âŸ©
    -- âŠ¢ s = â‹‚ (b_1 : Î²) (_ : b_1 âˆˆ {b}), (fun x => s) b_1 âˆ§ âˆ€ (b_1 : Î²), b_1 âˆˆ {b} â†’ â€¦
    simpa using h_s_in_t'
    -- ğŸ‰ no goals
  Â· rcases h_t' with âŸ¨T_t', âŸ¨f_t', âŸ¨rfl, h_t'âŸ©âŸ©âŸ©
    -- âŠ¢ âˆƒ T f, s âˆ© â‹‚ (b : Î²) (_ : b âˆˆ T_t'), f_t' b = â‹‚ (b : Î²) (_ : b âˆˆ T), f b âˆ§ âˆ€ â€¦
    rcases h_s with âŸ¨T_s, âŸ¨f_s, âŸ¨rfl, h_sâŸ©âŸ©âŸ©
    -- âŠ¢ âˆƒ T f, (â‹‚ (b : Î²) (_ : b âˆˆ T_s), f_s b) âˆ© â‹‚ (b : Î²) (_ : b âˆˆ T_t'), f_t' b = â€¦
    use T_s âˆª T_t', fun b : Î² =>
      if b âˆˆ T_s then if b âˆˆ T_t' then f_s b âˆ© f_t' b else f_s b
      else if b âˆˆ T_t' then f_t' b else (âˆ… : Set Î±)
    constructor
    -- âŠ¢ (â‹‚ (b : Î²) (_ : b âˆˆ T_s), f_s b) âˆ© â‹‚ (b : Î²) (_ : b âˆˆ T_t'), f_t' b = â‹‚ (b : â€¦
    Â· ext a
      -- âŠ¢ a âˆˆ (â‹‚ (b : Î²) (_ : b âˆˆ T_s), f_s b) âˆ© â‹‚ (b : Î²) (_ : b âˆˆ T_t'), f_t' b â†” a  â€¦
      simp_rw [Set.mem_inter_iff, Set.mem_iInter, Finset.mem_union, or_imp]
      -- âŠ¢ ((âˆ€ (i : Î²), i âˆˆ T_s â†’ a âˆˆ f_s i) âˆ§ âˆ€ (i : Î²), i âˆˆ T_t' â†’ a âˆˆ f_t' i) â†” âˆ€ (i â€¦
      rw [â† forall_and]
      -- âŠ¢ (âˆ€ (x : Î²), (x âˆˆ T_s â†’ a âˆˆ f_s x) âˆ§ (x âˆˆ T_t' â†’ a âˆˆ f_t' x)) â†” âˆ€ (i : Î²), (i â€¦
      constructor <;> intro h1 b <;> by_cases hbs : b âˆˆ T_s <;> by_cases hbt : b âˆˆ T_t' <;>
      -- âŠ¢ (âˆ€ (x : Î²), (x âˆˆ T_s â†’ a âˆˆ f_s x) âˆ§ (x âˆˆ T_t' â†’ a âˆˆ f_t' x)) â†’ âˆ€ (i : Î²), (i â€¦
                      -- âŠ¢ (b âˆˆ T_s â†’ a âˆˆ if b âˆˆ T_s then if b âˆˆ T_t' then f_s b âˆ© f_t' b else f_s b el â€¦
                      -- âŠ¢ (b âˆˆ T_s â†’ a âˆˆ f_s b) âˆ§ (b âˆˆ T_t' â†’ a âˆˆ f_t' b)
                                     -- âŠ¢ (b âˆˆ T_s â†’ a âˆˆ if b âˆˆ T_s then if b âˆˆ T_t' then f_s b âˆ© f_t' b else f_s b el â€¦
                                     -- âŠ¢ (b âˆˆ T_s â†’ a âˆˆ f_s b) âˆ§ (b âˆˆ T_t' â†’ a âˆˆ f_t' b)
                                                                -- âŠ¢ (b âˆˆ T_s â†’ a âˆˆ if b âˆˆ T_s then if b âˆˆ T_t' then f_s b âˆ© f_t' b else f_s b el â€¦
                                                                -- âŠ¢ (b âˆˆ T_s â†’ a âˆˆ if b âˆˆ T_s then if b âˆˆ T_t' then f_s b âˆ© f_t' b else f_s b el â€¦
                                                                -- âŠ¢ (b âˆˆ T_s â†’ a âˆˆ f_s b) âˆ§ (b âˆˆ T_t' â†’ a âˆˆ f_t' b)
                                                                -- âŠ¢ (b âˆˆ T_s â†’ a âˆˆ f_s b) âˆ§ (b âˆˆ T_t' â†’ a âˆˆ f_t' b)
          specialize h1 b <;>
          -- âŠ¢ (b âˆˆ T_s â†’ a âˆˆ if b âˆˆ T_s then if b âˆˆ T_t' then f_s b âˆ© f_t' b else f_s b el â€¦
          -- âŠ¢ (b âˆˆ T_s â†’ a âˆˆ if b âˆˆ T_s then if b âˆˆ T_t' then f_s b âˆ© f_t' b else f_s b el â€¦
          -- âŠ¢ (b âˆˆ T_s â†’ a âˆˆ if b âˆˆ T_s then if b âˆˆ T_t' then f_s b âˆ© f_t' b else f_s b el â€¦
          -- âŠ¢ (b âˆˆ T_s â†’ a âˆˆ if b âˆˆ T_s then if b âˆˆ T_t' then f_s b âˆ© f_t' b else f_s b el â€¦
          -- âŠ¢ (b âˆˆ T_s â†’ a âˆˆ f_s b) âˆ§ (b âˆˆ T_t' â†’ a âˆˆ f_t' b)
          -- âŠ¢ (b âˆˆ T_s â†’ a âˆˆ f_s b) âˆ§ (b âˆˆ T_t' â†’ a âˆˆ f_t' b)
          -- âŠ¢ (b âˆˆ T_s â†’ a âˆˆ f_s b) âˆ§ (b âˆˆ T_t' â†’ a âˆˆ f_t' b)
          -- âŠ¢ (b âˆˆ T_s â†’ a âˆˆ f_s b) âˆ§ (b âˆˆ T_t' â†’ a âˆˆ f_t' b)
        simp only [hbs, hbt, if_true, if_false, true_imp_iff, and_self_iff, false_imp_iff,
          and_true_iff, true_and_iff] at h1 âŠ¢
      all_goals exact h1
      -- ğŸ‰ no goals
    intro b h_b
    -- âŠ¢ (if b âˆˆ T_s then if b âˆˆ T_t' then f_s b âˆ© f_t' b else f_s b else if b âˆˆ T_t' â€¦
    split_ifs with hbs hbt hbt
    Â· refine' h_pi b (f_s b) (h_s b hbs) (f_t' b) (h_t' b hbt) (Set.Nonempty.mono _ h_nonempty)
      -- âŠ¢ (â‹‚ (b : Î²) (_ : b âˆˆ T_s), f_s b) âˆ© â‹‚ (b : Î²) (_ : b âˆˆ T_t'), f_t' b âŠ† f_s b  â€¦
      exact Set.inter_subset_inter (Set.biInter_subset_of_mem hbs) (Set.biInter_subset_of_mem hbt)
      -- ğŸ‰ no goals
    Â· exact h_s b hbs
      -- ğŸ‰ no goals
    Â· exact h_t' b hbt
      -- ğŸ‰ no goals
    Â· rw [Finset.mem_union] at h_b
      -- âŠ¢ âˆ… âˆˆ g b
      apply False.elim (h_b.elim hbs hbt)
      -- ğŸ‰ no goals
#align mem_generate_pi_system_Union_elim mem_generatePiSystem_iUnion_elim

/- Every element of the Ï€-system generated by an indexed union of a family of Ï€-systems
is a finite intersection of elements from the Ï€-systems.
For a total union version, see `mem_generatePiSystem_iUnion_elim`. -/
theorem mem_generatePiSystem_iUnion_elim' {Î± Î²} {g : Î² â†’ Set (Set Î±)} {s : Set Î²}
    (h_pi : âˆ€ b âˆˆ s, IsPiSystem (g b)) (t : Set Î±) (h_t : t âˆˆ generatePiSystem (â‹ƒ b âˆˆ s, g b)) :
    âˆƒ (T : Finset Î²) (f : Î² â†’ Set Î±), â†‘T âŠ† s âˆ§ (t = â‹‚ b âˆˆ T, f b) âˆ§ âˆ€ b âˆˆ T, f b âˆˆ g b := by
  have : t âˆˆ generatePiSystem (â‹ƒ b : Subtype s, (g âˆ˜ Subtype.val) b) := by
    suffices h1 : â‹ƒ b : Subtype s, (g âˆ˜ Subtype.val) b = â‹ƒ b âˆˆ s, g b
    Â· rwa [h1]
    ext x
    simp only [exists_prop, Set.mem_iUnion, Function.comp_apply, Subtype.exists, Subtype.coe_mk]
    rfl
  rcases @mem_generatePiSystem_iUnion_elim Î± (Subtype s) (g âˆ˜ Subtype.val)
      (fun b => h_pi b.val b.property) t this with
    âŸ¨T, âŸ¨f, âŸ¨rfl, h_t'âŸ©âŸ©âŸ©
  refine'
    âŸ¨T.image (fun x : s => (x : Î²)),
      Function.extend (fun x : s => (x : Î²)) f fun _ : Î² => (âˆ… : Set Î±), by simp, _, _âŸ©
  Â· ext a
    -- âŠ¢ a âˆˆ â‹‚ (b : Subtype s) (_ : b âˆˆ T), f b â†” a âˆˆ â‹‚ (b : Î²) (_ : b âˆˆ Finset.image â€¦
    constructor <;>
    -- âŠ¢ a âˆˆ â‹‚ (b : Subtype s) (_ : b âˆˆ T), f b â†’ a âˆˆ â‹‚ (b : Î²) (_ : b âˆˆ Finset.image â€¦
      Â· simp (config := { proj := false }) only
          [Set.mem_iInter, Subtype.forall, Finset.set_biInter_finset_image]
        intro h1 b h_b h_b_in_T
        -- âŠ¢ a âˆˆ Function.extend (fun x => â†‘x) f (fun x => âˆ…) â†‘{ val := b, property := h_ â€¦
        -- âŠ¢ a âˆˆ f { val := b, property := h_b }
        -- âŠ¢ a âˆˆ Function.extend (fun x => â†‘x) f (fun x => âˆ…) â†‘{ val := b, property := h_ â€¦
        have h2 := h1 b h_b h_b_in_T
        -- âŠ¢ a âˆˆ f { val := b, property := h_b } â†’ a âˆˆ Function.extend (fun x => â†‘x) f (f â€¦
        -- âŠ¢ a âˆˆ f { val := b, property := h_b }
        -- âŠ¢ a âˆˆ f { val := b, property := h_b } â†’ a âˆˆ f { val := b, property := h_b }
        revert h2
        -- ğŸ‰ no goals
        -- âŠ¢ a âˆˆ Function.extend (fun x => â†‘x) f (fun x => âˆ…) â†‘{ val := b, property := h_ â€¦
        rw [Subtype.val_injective.extend_apply]
        -- âŠ¢ a âˆˆ f { val := b, property := h_b } â†’ a âˆˆ f { val := b, property := h_b }
        apply id
        -- ğŸ‰ no goals
  Â· intros b h_b
    -- âŠ¢ Function.extend (fun x => â†‘x) f (fun x => âˆ…) b âˆˆ g b
    simp_rw [Finset.mem_image, Subtype.exists, exists_and_right, exists_eq_right]
      at h_b
    cases' h_b with h_b_w h_b_h
    -- âŠ¢ Function.extend (fun x => â†‘x) f (fun x => âˆ…) b âˆˆ g b
    have h_b_alt : b = (Subtype.mk b h_b_w).val := rfl
    -- âŠ¢ Function.extend (fun x => â†‘x) f (fun x => âˆ…) b âˆˆ g b
    rw [h_b_alt, Subtype.val_injective.extend_apply]
    -- âŠ¢ f { val := b, property := h_b_w } âˆˆ g â†‘{ val := b, property := h_b_w }
    apply h_t'
    -- âŠ¢ { val := b, property := h_b_w } âˆˆ T
    apply h_b_h
    -- ğŸ‰ no goals
#align mem_generate_pi_system_Union_elim' mem_generatePiSystem_iUnion_elim'

section UnionInter

variable {Î± Î¹ : Type*}

/-! ### Ï€-system generated by finite intersections of sets of a Ï€-system family -/


/-- From a set of indices `S : Set Î¹` and a family of sets of sets `Ï€ : Î¹ â†’ Set (Set Î±)`,
define the set of sets that can be written as `â‹‚ x âˆˆ t, f x` for some finset `t âŠ† S` and sets
`f x âˆˆ Ï€ x`. If `Ï€` is a family of Ï€-systems, then it is a Ï€-system. -/
def piiUnionInter (Ï€ : Î¹ â†’ Set (Set Î±)) (S : Set Î¹) : Set (Set Î±) :=
  { s : Set Î± |
    âˆƒ (t : Finset Î¹) (_ : â†‘t âŠ† S) (f : Î¹ â†’ Set Î±) (_ : âˆ€ x, x âˆˆ t â†’ f x âˆˆ Ï€ x), s = â‹‚ x âˆˆ t, f x }
#align pi_Union_Inter piiUnionInter

theorem piiUnionInter_singleton (Ï€ : Î¹ â†’ Set (Set Î±)) (i : Î¹) :
    piiUnionInter Ï€ {i} = Ï€ i âˆª {univ} := by
  ext1 s
  -- âŠ¢ s âˆˆ piiUnionInter Ï€ {i} â†” s âˆˆ Ï€ i âˆª {univ}
  simp only [piiUnionInter, exists_prop, mem_union]
  -- âŠ¢ s âˆˆ {s | âˆƒ t, â†‘t âŠ† {i} âˆ§ âˆƒ f, (âˆ€ (x : Î¹), x âˆˆ t â†’ f x âˆˆ Ï€ x) âˆ§ s = â‹‚ (x : Î¹) â€¦
  refine' âŸ¨_, fun h => _âŸ©
  -- âŠ¢ s âˆˆ {s | âˆƒ t, â†‘t âŠ† {i} âˆ§ âˆƒ f, (âˆ€ (x : Î¹), x âˆˆ t â†’ f x âˆˆ Ï€ x) âˆ§ s = â‹‚ (x : Î¹) â€¦
  Â· rintro âŸ¨t, hti, f, hfÏ€, rflâŸ©
    -- âŠ¢ â‹‚ (x : Î¹) (_ : x âˆˆ t), f x âˆˆ Ï€ i âˆ¨ â‹‚ (x : Î¹) (_ : x âˆˆ t), f x âˆˆ {univ}
    simp only [subset_singleton_iff, Finset.mem_coe] at hti
    -- âŠ¢ â‹‚ (x : Î¹) (_ : x âˆˆ t), f x âˆˆ Ï€ i âˆ¨ â‹‚ (x : Î¹) (_ : x âˆˆ t), f x âˆˆ {univ}
    by_cases hi : i âˆˆ t
    -- âŠ¢ â‹‚ (x : Î¹) (_ : x âˆˆ t), f x âˆˆ Ï€ i âˆ¨ â‹‚ (x : Î¹) (_ : x âˆˆ t), f x âˆˆ {univ}
    Â· have ht_eq_i : t = {i} := by
        ext1 x
        rw [Finset.mem_singleton]
        exact âŸ¨fun h => hti x h, fun h => h.symm â–¸ hiâŸ©
      simp only [ht_eq_i, Finset.mem_singleton, iInter_iInter_eq_left]
      -- âŠ¢ f i âˆˆ Ï€ i âˆ¨ f i âˆˆ {univ}
      exact Or.inl (hfÏ€ i hi)
      -- ğŸ‰ no goals
    Â· have ht_empty : t = âˆ… := by
        ext1 x
        simp only [Finset.not_mem_empty, iff_false_iff]
        exact fun hx => hi (hti x hx â–¸ hx)
      -- Porting note: `Finset.not_mem_empty` required
      simp [ht_empty, Finset.not_mem_empty, iInter_false, iInter_univ, Set.mem_singleton univ,
        or_true_iff]
  Â· cases' h with hs hs
    -- âŠ¢ s âˆˆ {s | âˆƒ t, â†‘t âŠ† {i} âˆ§ âˆƒ f, (âˆ€ (x : Î¹), x âˆˆ t â†’ f x âˆˆ Ï€ x) âˆ§ s = â‹‚ (x : Î¹) â€¦
    Â· refine' âŸ¨{i}, _, fun _ => s, âŸ¨fun x hx => _, _âŸ©âŸ©
      Â· rw [Finset.coe_singleton]
        -- ğŸ‰ no goals
      Â· rw [Finset.mem_singleton] at hx
        -- âŠ¢ (fun x => s) x âˆˆ Ï€ x
        rwa [hx]
        -- ğŸ‰ no goals
      Â· simp only [Finset.mem_singleton, iInter_iInter_eq_left]
        -- ğŸ‰ no goals
    Â· refine' âŸ¨âˆ…, _âŸ©
      -- âŠ¢ â†‘âˆ… âŠ† {i} âˆ§ âˆƒ f, (âˆ€ (x : Î¹), x âˆˆ âˆ… â†’ f x âˆˆ Ï€ x) âˆ§ s = â‹‚ (x : Î¹) (_ : x âˆˆ âˆ…),  â€¦
      simpa only [Finset.coe_empty, subset_singleton_iff, mem_empty_iff_false, IsEmpty.forall_iff,
        imp_true_iff, Finset.not_mem_empty, iInter_false, iInter_univ, true_and_iff,
        exists_const] using hs
#align pi_Union_Inter_singleton piiUnionInter_singleton

theorem piiUnionInter_singleton_left (s : Î¹ â†’ Set Î±) (S : Set Î¹) :
    piiUnionInter (fun i => ({s i} : Set (Set Î±))) S =
      { s' : Set Î± | âˆƒ (t : Finset Î¹) (_ : â†‘t âŠ† S), s' = â‹‚ i âˆˆ t, s i } := by
  ext1 s'
  -- âŠ¢ s' âˆˆ piiUnionInter (fun i => {s i}) S â†” s' âˆˆ {s' | âˆƒ t x, s' = â‹‚ (i : Î¹) (_  â€¦
  simp_rw [piiUnionInter, Set.mem_singleton_iff, exists_prop, Set.mem_setOf_eq]
  -- âŠ¢ (âˆƒ t, â†‘t âŠ† S âˆ§ âˆƒ f, (âˆ€ (x : Î¹), x âˆˆ t â†’ f x = s x) âˆ§ s' = â‹‚ (x : Î¹) (_ : x âˆˆ â€¦
  refine' âŸ¨fun h => _, fun âŸ¨t, htS, h_eqâŸ© => âŸ¨t, htS, s, fun _ _ => rfl, h_eqâŸ©âŸ©
  -- âŠ¢ âˆƒ t, â†‘t âŠ† S âˆ§ s' = â‹‚ (i : Î¹) (_ : i âˆˆ t), s i
  obtain âŸ¨t, htS, f, hft_eq, rflâŸ© := h
  -- âŠ¢ âˆƒ t_1, â†‘t_1 âŠ† S âˆ§ â‹‚ (x : Î¹) (_ : x âˆˆ t), f x = â‹‚ (i : Î¹) (_ : i âˆˆ t_1), s i
  refine' âŸ¨t, htS, _âŸ©
  -- âŠ¢ â‹‚ (x : Î¹) (_ : x âˆˆ t), f x = â‹‚ (i : Î¹) (_ : i âˆˆ t), s i
  congr! 3
  -- âŠ¢ f xâœÂ¹ = s xâœÂ¹
  apply hft_eq
  -- âŠ¢ xâœÂ¹ âˆˆ t
  assumption
  -- ğŸ‰ no goals
#align pi_Union_Inter_singleton_left piiUnionInter_singleton_left

theorem generateFrom_piiUnionInter_singleton_left (s : Î¹ â†’ Set Î±) (S : Set Î¹) :
    generateFrom (piiUnionInter (fun k => {s k}) S) = generateFrom { t | âˆƒ k âˆˆ S, s k = t } := by
  refine' le_antisymm (generateFrom_le _) (generateFrom_mono _)
  -- âŠ¢ âˆ€ (t : Set Î±), t âˆˆ piiUnionInter (fun k => {s k}) S â†’ MeasurableSet t
  Â· rintro _ âŸ¨I, hI, f, hf, rflâŸ©
    -- âŠ¢ MeasurableSet (â‹‚ (x : Î¹) (_ : x âˆˆ I), f x)
    refine' Finset.measurableSet_biInter _ fun m hm => measurableSet_generateFrom _
    -- âŠ¢ f m âˆˆ {t | âˆƒ k, k âˆˆ S âˆ§ s k = t}
    exact âŸ¨m, hI hm, (hf m hm).symmâŸ©
    -- ğŸ‰ no goals
  Â· rintro _ âŸ¨k, hk, rflâŸ©
    -- âŠ¢ s k âˆˆ piiUnionInter (fun k => {s k}) S
    refine' âŸ¨{k}, fun m hm => _, s, fun i _ => _, _âŸ©
    Â· rw [Finset.mem_coe, Finset.mem_singleton] at hm
      -- âŠ¢ m âˆˆ S
      rwa [hm]
      -- ğŸ‰ no goals
    Â· exact Set.mem_singleton _
      -- ğŸ‰ no goals
    Â· simp only [Finset.mem_singleton, Set.iInter_iInter_eq_left]
      -- ğŸ‰ no goals
#align generate_from_pi_Union_Inter_singleton_left generateFrom_piiUnionInter_singleton_left

/-- If `Ï€` is a family of Ï€-systems, then `piiUnionInter Ï€ S` is a Ï€-system. -/
theorem isPiSystem_piiUnionInter (Ï€ : Î¹ â†’ Set (Set Î±)) (hpi : âˆ€ x, IsPiSystem (Ï€ x)) (S : Set Î¹) :
    IsPiSystem (piiUnionInter Ï€ S) := by
  rintro t1 âŸ¨p1, hp1S, f1, hf1m, ht1_eqâŸ© t2 âŸ¨p2, hp2S, f2, hf2m, ht2_eqâŸ© h_nonempty
  -- âŠ¢ t1 âˆ© t2 âˆˆ piiUnionInter Ï€ S
  simp_rw [piiUnionInter, Set.mem_setOf_eq]
  -- âŠ¢ âˆƒ t x f x, t1 âˆ© t2 = â‹‚ (x : Î¹) (_ : x âˆˆ t), f x
  let g n := ite (n âˆˆ p1) (f1 n) Set.univ âˆ© ite (n âˆˆ p2) (f2 n) Set.univ
  -- âŠ¢ âˆƒ t x f x, t1 âˆ© t2 = â‹‚ (x : Î¹) (_ : x âˆˆ t), f x
  have hp_union_ss : â†‘(p1 âˆª p2) âŠ† S := by
    simp only [hp1S, hp2S, Finset.coe_union, union_subset_iff, and_self_iff]
  use p1 âˆª p2, hp_union_ss, g
  -- âŠ¢ âˆƒ x, t1 âˆ© t2 = â‹‚ (x : Î¹) (_ : x âˆˆ p1 âˆª p2), g x
  have h_inter_eq : t1 âˆ© t2 = â‹‚ i âˆˆ p1 âˆª p2, g i := by
    rw [ht1_eq, ht2_eq]
    simp_rw [â† Set.inf_eq_inter]
    ext1 x
    simp only [inf_eq_inter, mem_inter_iff, mem_iInter, Finset.mem_union]
    refine' âŸ¨fun h i _ => _, fun h => âŸ¨fun i hi1 => _, fun i hi2 => _âŸ©âŸ©
    Â· split_ifs with h_1 h_2 h_2
      exacts [âŸ¨h.1 i h_1, h.2 i h_2âŸ©, âŸ¨h.1 i h_1, Set.mem_univ _âŸ©, âŸ¨Set.mem_univ _, h.2 i h_2âŸ©,
        âŸ¨Set.mem_univ _, Set.mem_univ _âŸ©]
    Â· specialize h i (Or.inl hi1)
      rw [if_pos hi1] at h
      exact h.1
    Â· specialize h i (Or.inr hi2)
      rw [if_pos hi2] at h
      exact h.2
  refine' âŸ¨fun n hn => _, h_inter_eqâŸ©
  -- âŠ¢ g n âˆˆ Ï€ n
  simp only []
  -- âŠ¢ ((if n âˆˆ p1 then f1 n else univ) âˆ© if n âˆˆ p2 then f2 n else univ) âˆˆ Ï€ n
  split_ifs with hn1 hn2 h
  Â· refine' hpi n (f1 n) (hf1m n hn1) (f2 n) (hf2m n hn2) (Set.nonempty_iff_ne_empty.2 fun h => _)
    -- âŠ¢ False
    rw [h_inter_eq] at h_nonempty
    -- âŠ¢ False
    suffices h_empty : â‹‚ i âˆˆ p1 âˆª p2, g i = âˆ…
    -- âŠ¢ False
    exact (Set.not_nonempty_iff_eq_empty.mpr h_empty) h_nonempty
    -- âŠ¢ â‹‚ (i : Î¹) (_ : i âˆˆ p1 âˆª p2), g i = âˆ…
    refine' le_antisymm (Set.iInter_subset_of_subset n _) (Set.empty_subset _)
    -- âŠ¢ â‹‚ (_ : n âˆˆ p1 âˆª p2), g n âŠ† âˆ…
    refine' Set.iInter_subset_of_subset hn _
    -- âŠ¢ g n âŠ† âˆ…
    simp_rw [if_pos hn1, if_pos hn2]
    -- âŠ¢ f1 n âˆ© f2 n âŠ† âˆ…
    exact h.subset
    -- ğŸ‰ no goals
  Â· simp [hf1m n hn1]
    -- ğŸ‰ no goals
  Â· simp [hf2m n h]
    -- ğŸ‰ no goals
  Â· exact absurd hn (by simp [hn1, h])
    -- ğŸ‰ no goals
#align is_pi_system_pi_Union_Inter isPiSystem_piiUnionInter

theorem piiUnionInter_mono_left {Ï€ Ï€' : Î¹ â†’ Set (Set Î±)} (h_le : âˆ€ i, Ï€ i âŠ† Ï€' i) (S : Set Î¹) :
    piiUnionInter Ï€ S âŠ† piiUnionInter Ï€' S := fun _ âŸ¨t, ht_mem, ft, hft_mem_pi, h_eqâŸ© =>
  âŸ¨t, ht_mem, ft, fun x hxt => h_le x (hft_mem_pi x hxt), h_eqâŸ©
#align pi_Union_Inter_mono_left piiUnionInter_mono_left

theorem piiUnionInter_mono_right {Ï€ : Î¹ â†’ Set (Set Î±)} {S T : Set Î¹} (hST : S âŠ† T) :
    piiUnionInter Ï€ S âŠ† piiUnionInter Ï€ T := fun _ âŸ¨t, ht_mem, ft, hft_mem_pi, h_eqâŸ© =>
  âŸ¨t, ht_mem.trans hST, ft, hft_mem_pi, h_eqâŸ©
#align pi_Union_Inter_mono_right piiUnionInter_mono_right

theorem generateFrom_piiUnionInter_le {m : MeasurableSpace Î±} (Ï€ : Î¹ â†’ Set (Set Î±))
    (h : âˆ€ n, generateFrom (Ï€ n) â‰¤ m) (S : Set Î¹) : generateFrom (piiUnionInter Ï€ S) â‰¤ m := by
  refine' generateFrom_le _
  -- âŠ¢ âˆ€ (t : Set Î±), t âˆˆ piiUnionInter Ï€ S â†’ MeasurableSet t
  rintro t âŸ¨ht_p, _, ft, hft_mem_pi, rflâŸ©
  -- âŠ¢ MeasurableSet (â‹‚ (x : Î¹) (_ : x âˆˆ ht_p), ft x)
  refine' Finset.measurableSet_biInter _ fun x hx_mem => (h x) _ _
  -- âŠ¢ MeasurableSet (ft x)
  exact measurableSet_generateFrom (hft_mem_pi x hx_mem)
  -- ğŸ‰ no goals
#align generate_from_pi_Union_Inter_le generateFrom_piiUnionInter_le

theorem subset_piiUnionInter {Ï€ : Î¹ â†’ Set (Set Î±)} {S : Set Î¹} {i : Î¹} (his : i âˆˆ S) :
    Ï€ i âŠ† piiUnionInter Ï€ S := by
  have h_ss : {i} âŠ† S := by
    intro j hj
    rw [mem_singleton_iff] at hj
    rwa [hj]
  refine' Subset.trans _ (piiUnionInter_mono_right h_ss)
  -- âŠ¢ Ï€ i âŠ† piiUnionInter Ï€ {i}
  rw [piiUnionInter_singleton]
  -- âŠ¢ Ï€ i âŠ† Ï€ i âˆª {univ}
  exact subset_union_left _ _
  -- ğŸ‰ no goals
#align subset_pi_Union_Inter subset_piiUnionInter

theorem mem_piiUnionInter_of_measurableSet (m : Î¹ â†’ MeasurableSpace Î±) {S : Set Î¹} {i : Î¹}
    (hiS : i âˆˆ S) (s : Set Î±) (hs : MeasurableSet[m i] s) :
    s âˆˆ piiUnionInter (fun n => { s | MeasurableSet[m n] s }) S :=
  subset_piiUnionInter hiS hs
#align mem_pi_Union_Inter_of_measurable_set mem_piiUnionInter_of_measurableSet

theorem le_generateFrom_piiUnionInter {Ï€ : Î¹ â†’ Set (Set Î±)} (S : Set Î¹) {x : Î¹} (hxS : x âˆˆ S) :
    generateFrom (Ï€ x) â‰¤ generateFrom (piiUnionInter Ï€ S) :=
  generateFrom_mono (subset_piiUnionInter hxS)
#align le_generate_from_pi_Union_Inter le_generateFrom_piiUnionInter

theorem measurableSet_iSup_of_mem_piiUnionInter (m : Î¹ â†’ MeasurableSpace Î±) (S : Set Î¹) (t : Set Î±)
    (ht : t âˆˆ piiUnionInter (fun n => { s | MeasurableSet[m n] s }) S) :
    MeasurableSet[â¨† i âˆˆ S, m i] t := by
  rcases ht with âŸ¨pt, hpt, ft, ht_m, rflâŸ©
  -- âŠ¢ MeasurableSet (â‹‚ (x : Î¹) (_ : x âˆˆ pt), ft x)
  refine' pt.measurableSet_biInter fun i hi => _
  -- âŠ¢ MeasurableSet (ft i)
  suffices h_le : m i â‰¤ â¨† i âˆˆ S, m i; exact h_le (ft i) (ht_m i hi)
  -- âŠ¢ MeasurableSet (ft i)
                                      -- âŠ¢ m i â‰¤ â¨† (i : Î¹) (_ : i âˆˆ S), m i
  have hi' : i âˆˆ S := hpt hi
  -- âŠ¢ m i â‰¤ â¨† (i : Î¹) (_ : i âˆˆ S), m i
  exact le_iSupâ‚‚ (f := fun i (_ : i âˆˆ S) => m i) i hi'
  -- ğŸ‰ no goals
#align measurable_set_supr_of_mem_pi_Union_Inter measurableSet_iSup_of_mem_piiUnionInter

theorem generateFrom_piiUnionInter_measurableSet (m : Î¹ â†’ MeasurableSpace Î±) (S : Set Î¹) :
    generateFrom (piiUnionInter (fun n => { s | MeasurableSet[m n] s }) S) = â¨† i âˆˆ S, m i := by
  refine' le_antisymm _ _
  -- âŠ¢ generateFrom (piiUnionInter (fun n => {s | MeasurableSet s}) S) â‰¤ â¨† (i : Î¹)  â€¦
  Â· rw [â† @generateFrom_measurableSet Î± (â¨† i âˆˆ S, m i)]
    -- âŠ¢ generateFrom (piiUnionInter (fun n => {s | MeasurableSet s}) S) â‰¤ generateFr â€¦
    exact generateFrom_mono (measurableSet_iSup_of_mem_piiUnionInter m S)
    -- ğŸ‰ no goals
  Â· refine' iSupâ‚‚_le fun i hi => _
    -- âŠ¢ m i â‰¤ generateFrom (piiUnionInter (fun n => {s | MeasurableSet s}) S)
    rw [â† @generateFrom_measurableSet Î± (m i)]
    -- âŠ¢ generateFrom {s | MeasurableSet s} â‰¤ generateFrom (piiUnionInter (fun n => { â€¦
    exact generateFrom_mono (mem_piiUnionInter_of_measurableSet m hi)
    -- ğŸ‰ no goals
#align generate_from_pi_Union_Inter_measurable_set generateFrom_piiUnionInter_measurableSet

end UnionInter

namespace MeasurableSpace

variable {Î± : Type*}

/-! ## Dynkin systems and Î -Î» theorem -/


/-- A Dynkin system is a collection of subsets of a type `Î±` that contains the empty set,
  is closed under complementation and under countable union of pairwise disjoint sets.
  The disjointness condition is the only difference with `Ïƒ`-algebras.

  The main purpose of Dynkin systems is to provide a powerful induction rule for Ïƒ-algebras
  generated by a collection of sets which is stable under intersection.

  A Dynkin system is also known as a "Î»-system" or a "d-system".
-/
structure DynkinSystem (Î± : Type*) where
  /-- Predicate saying that a given set is contained in the Dynkin system. -/
  Has : Set Î± â†’ Prop
  /-- A Dynkin system contains the empty set. -/
  has_empty : Has âˆ…
  /-- A Dynkin system is closed under complementation. -/
  has_compl : âˆ€ {a}, Has a â†’ Has aá¶œ
  /-- A Dynkin system is closed under countable union of pairwise disjoint sets. Use a more general
  `MeasurableSpace.DynkinSystem.has_iUnion` instead.-/
  has_iUnion_nat : âˆ€ {f : â„• â†’ Set Î±}, Pairwise (Disjoint on f) â†’ (âˆ€ i, Has (f i)) â†’ Has (â‹ƒ i, f i)
#align measurable_space.dynkin_system MeasurableSpace.DynkinSystem

namespace DynkinSystem

@[ext]
theorem ext : âˆ€ {dâ‚ dâ‚‚ : DynkinSystem Î±}, (âˆ€ s : Set Î±, dâ‚.Has s â†” dâ‚‚.Has s) â†’ dâ‚ = dâ‚‚
  | âŸ¨sâ‚, _, _, _âŸ©, âŸ¨sâ‚‚, _, _, _âŸ©, h => by
    have : sâ‚ = sâ‚‚ := funext fun x => propext <| h x
    -- âŠ¢ { Has := sâ‚, has_empty := has_emptyâœÂ¹, has_compl := has_complâœÂ¹, has_iUnion_ â€¦
    subst this
    -- âŠ¢ { Has := sâ‚, has_empty := has_emptyâœÂ¹, has_compl := has_complâœÂ¹, has_iUnion_ â€¦
    rfl
    -- ğŸ‰ no goals
#align measurable_space.dynkin_system.ext MeasurableSpace.DynkinSystem.ext

variable (d : DynkinSystem Î±)

theorem has_compl_iff {a} : d.Has aá¶œ â†” d.Has a :=
  âŸ¨fun h => by simpa using d.has_compl h, fun h => d.has_compl hâŸ©
               -- ğŸ‰ no goals
#align measurable_space.dynkin_system.has_compl_iff MeasurableSpace.DynkinSystem.has_compl_iff

theorem has_univ : d.Has univ := by simpa using d.has_compl d.has_empty
                                    -- ğŸ‰ no goals
#align measurable_space.dynkin_system.has_univ MeasurableSpace.DynkinSystem.has_univ

theorem has_iUnion {Î²} [Countable Î²] {f : Î² â†’ Set Î±} (hd : Pairwise (Disjoint on f))
    (h : âˆ€ i, d.Has (f i)) : d.Has (â‹ƒ i, f i) := by
  cases nonempty_encodable Î²
  -- âŠ¢ Has d (â‹ƒ (i : Î²), f i)
  rw [â† Encodable.iUnion_decodeâ‚‚]
  -- âŠ¢ Has d (â‹ƒ (i : â„•) (b : Î²) (_ : b âˆˆ Encodable.decodeâ‚‚ Î² i), f b)
  exact
    d.has_iUnion_nat (Encodable.iUnion_decodeâ‚‚_disjoint_on hd) fun n =>
      Encodable.iUnion_decodeâ‚‚_cases d.has_empty h
#align measurable_space.dynkin_system.has_Union MeasurableSpace.DynkinSystem.has_iUnion

theorem has_union {sâ‚ sâ‚‚ : Set Î±} (hâ‚ : d.Has sâ‚) (hâ‚‚ : d.Has sâ‚‚) (h : Disjoint sâ‚ sâ‚‚) :
    d.Has (sâ‚ âˆª sâ‚‚) := by
  rw [union_eq_iUnion]
  -- âŠ¢ Has d (â‹ƒ (b : Bool), bif b then sâ‚ else sâ‚‚)
  exact d.has_iUnion (pairwise_disjoint_on_bool.2 h) (Bool.forall_bool.2 âŸ¨hâ‚‚, hâ‚âŸ©)
  -- ğŸ‰ no goals
#align measurable_space.dynkin_system.has_union MeasurableSpace.DynkinSystem.has_union

theorem has_diff {sâ‚ sâ‚‚ : Set Î±} (hâ‚ : d.Has sâ‚) (hâ‚‚ : d.Has sâ‚‚) (h : sâ‚‚ âŠ† sâ‚) :
    d.Has (sâ‚ \ sâ‚‚) := by
  apply d.has_compl_iff.1
  -- âŠ¢ Has d (sâ‚ \ sâ‚‚)á¶œ
  simp [diff_eq, compl_inter]
  -- âŠ¢ Has d (sâ‚á¶œ âˆª sâ‚‚)
  exact d.has_union (d.has_compl hâ‚) hâ‚‚ (disjoint_compl_left.mono_right h)
  -- ğŸ‰ no goals
#align measurable_space.dynkin_system.has_diff MeasurableSpace.DynkinSystem.has_diff

instance instLEDynkinSystem : LE (DynkinSystem Î±) where le mâ‚ mâ‚‚ := mâ‚.Has â‰¤ mâ‚‚.Has

theorem le_def {Î±} {a b : DynkinSystem Î±} : a â‰¤ b â†” a.Has â‰¤ b.Has :=
  Iff.rfl
#align measurable_space.dynkin_system.le_def MeasurableSpace.DynkinSystem.le_def

instance : PartialOrder (DynkinSystem Î±) :=
  { DynkinSystem.instLEDynkinSystem with
    le_refl := fun a b => le_rfl
    le_trans := fun a b c hab hbc => le_def.mpr (le_trans hab hbc)
    le_antisymm := fun a b hâ‚ hâ‚‚ => ext fun s => âŸ¨hâ‚ s, hâ‚‚ sâŸ© }

/-- Every measurable space (Ïƒ-algebra) forms a Dynkin system -/
def ofMeasurableSpace (m : MeasurableSpace Î±) : DynkinSystem Î±
    where
  Has := m.MeasurableSet'
  has_empty := m.measurableSet_empty
  has_compl {a} := m.measurableSet_compl a
  has_iUnion_nat {f} _ hf := m.measurableSet_iUnion f hf
#align measurable_space.dynkin_system.of_measurable_space MeasurableSpace.DynkinSystem.ofMeasurableSpace

theorem ofMeasurableSpace_le_ofMeasurableSpace_iff {mâ‚ mâ‚‚ : MeasurableSpace Î±} :
    ofMeasurableSpace mâ‚ â‰¤ ofMeasurableSpace mâ‚‚ â†” mâ‚ â‰¤ mâ‚‚ :=
  Iff.rfl
#align measurable_space.dynkin_system.of_measurable_space_le_of_measurable_space_iff MeasurableSpace.DynkinSystem.ofMeasurableSpace_le_ofMeasurableSpace_iff

/-- The least Dynkin system containing a collection of basic sets.
  This inductive type gives the underlying collection of sets. -/
inductive GenerateHas (s : Set (Set Î±)) : Set Î± â†’ Prop
  | basic : âˆ€ t âˆˆ s, GenerateHas s t
  | empty : GenerateHas s âˆ…
  | compl : âˆ€ {a}, GenerateHas s a â†’ GenerateHas s aá¶œ
  | iUnion : âˆ€ {f : â„• â†’ Set Î±},
    Pairwise (Disjoint on f) â†’ (âˆ€ i, GenerateHas s (f i)) â†’ GenerateHas s (â‹ƒ i, f i)
#align measurable_space.dynkin_system.generate_has MeasurableSpace.DynkinSystem.GenerateHas

theorem generateHas_compl {C : Set (Set Î±)} {s : Set Î±} : GenerateHas C sá¶œ â†” GenerateHas C s := by
  refine' âŸ¨_, GenerateHas.complâŸ©
  -- âŠ¢ GenerateHas C sá¶œ â†’ GenerateHas C s
  intro h
  -- âŠ¢ GenerateHas C s
  convert GenerateHas.compl h
  -- âŠ¢ s = sá¶œá¶œ
  simp
  -- ğŸ‰ no goals
#align measurable_space.dynkin_system.generate_has_compl MeasurableSpace.DynkinSystem.generateHas_compl

/-- The least Dynkin system containing a collection of basic sets. -/
def generate (s : Set (Set Î±)) : DynkinSystem Î±
    where
  Has := GenerateHas s
  has_empty := GenerateHas.empty
  has_compl {_} := GenerateHas.compl
  has_iUnion_nat {_} := GenerateHas.iUnion
#align measurable_space.dynkin_system.generate MeasurableSpace.DynkinSystem.generate

theorem generateHas_def {C : Set (Set Î±)} : (generate C).Has = GenerateHas C :=
  rfl
#align measurable_space.dynkin_system.generate_has_def MeasurableSpace.DynkinSystem.generateHas_def

instance : Inhabited (DynkinSystem Î±) :=
  âŸ¨generate univâŸ©

/-- If a Dynkin system is closed under binary intersection, then it forms a `Ïƒ`-algebra. -/
def toMeasurableSpace (h_inter : âˆ€ sâ‚ sâ‚‚, d.Has sâ‚ â†’ d.Has sâ‚‚ â†’ d.Has (sâ‚ âˆ© sâ‚‚)) :
    MeasurableSpace Î± where
  MeasurableSet' := d.Has
  measurableSet_empty := d.has_empty
  measurableSet_compl s h := d.has_compl h
  measurableSet_iUnion f hf := by
    rw [â† iUnion_disjointed]
    -- âŠ¢ Has d (â‹ƒ (n : â„•), disjointed (fun i => f i) n)
    exact
      d.has_iUnion (disjoint_disjointed _) fun n =>
        disjointedRec (fun (t : Set Î±) i h => h_inter _ _ h <| d.has_compl <| hf i) (hf n)
#align measurable_space.dynkin_system.to_measurable_space MeasurableSpace.DynkinSystem.toMeasurableSpace

theorem ofMeasurableSpace_toMeasurableSpace
    (h_inter : âˆ€ sâ‚ sâ‚‚, d.Has sâ‚ â†’ d.Has sâ‚‚ â†’ d.Has (sâ‚ âˆ© sâ‚‚)) :
    ofMeasurableSpace (d.toMeasurableSpace h_inter) = d :=
  ext fun _ => Iff.rfl
#align measurable_space.dynkin_system.of_measurable_space_to_measurable_space MeasurableSpace.DynkinSystem.ofMeasurableSpace_toMeasurableSpace

/-- If `s` is in a Dynkin system `d`, we can form the new Dynkin system `{s âˆ© t | t âˆˆ d}`. -/
def restrictOn {s : Set Î±} (h : d.Has s) : DynkinSystem Î± where
  -- Porting note: `simp only []` required for a beta reduction
  Has t := d.Has (t âˆ© s)
  has_empty := by simp [d.has_empty]
                  -- ğŸ‰ no goals
  has_compl {t} hts := by
    simp only []
    -- âŠ¢ Has d (tá¶œ âˆ© s)
    have : tá¶œ âˆ© s = (t âˆ© s)á¶œ \ sá¶œ := Set.ext fun x => by by_cases h : x âˆˆ s <;> simp [h]
    -- âŠ¢ Has d (tá¶œ âˆ© s)
    rw [this]
    -- âŠ¢ Has d ((t âˆ© s)á¶œ \ sá¶œ)
    exact
      d.has_diff (d.has_compl hts) (d.has_compl h)
        (compl_subset_compl.mpr <| inter_subset_right _ _)
  has_iUnion_nat {f} hd hf := by
    simp only []
    -- âŠ¢ Has d ((â‹ƒ (i : â„•), f i) âˆ© s)
    rw [iUnion_inter]
    -- âŠ¢ Has d (â‹ƒ (i : â„•), f i âˆ© s)
    refine' d.has_iUnion_nat _ hf
    -- âŠ¢ Pairwise (Disjoint on fun i => f i âˆ© s)
    exact hd.mono fun i j => Disjoint.mono (inter_subset_left _ _) (inter_subset_left _ _)
    -- ğŸ‰ no goals
#align measurable_space.dynkin_system.restrict_on MeasurableSpace.DynkinSystem.restrictOn

theorem generate_le {s : Set (Set Î±)} (h : âˆ€ t âˆˆ s, d.Has t) : generate s â‰¤ d := fun _ ht =>
  ht.recOn h d.has_empty (fun {_} _ h => d.has_compl h) fun {_} hd _ hf => d.has_iUnion hd hf
#align measurable_space.dynkin_system.generate_le MeasurableSpace.DynkinSystem.generate_le

theorem generate_has_subset_generate_measurable {C : Set (Set Î±)} {s : Set Î±}
    (hs : (generate C).Has s) : MeasurableSet[generateFrom C] s :=
  generate_le (ofMeasurableSpace (generateFrom C)) (fun _ => measurableSet_generateFrom) s hs
#align measurable_space.dynkin_system.generate_has_subset_generate_measurable MeasurableSpace.DynkinSystem.generate_has_subset_generate_measurable

theorem generate_inter {s : Set (Set Î±)} (hs : IsPiSystem s) {tâ‚ tâ‚‚ : Set Î±}
    (htâ‚ : (generate s).Has tâ‚) (htâ‚‚ : (generate s).Has tâ‚‚) : (generate s).Has (tâ‚ âˆ© tâ‚‚) :=
  have : generate s â‰¤ (generate s).restrictOn htâ‚‚ :=
    generate_le _ fun sâ‚ hsâ‚ =>
      have : (generate s).Has sâ‚ := GenerateHas.basic sâ‚ hsâ‚
      have : generate s â‰¤ (generate s).restrictOn this :=
        generate_le _ fun sâ‚‚ hsâ‚‚ =>
          show (generate s).Has (sâ‚‚ âˆ© sâ‚) from
            (sâ‚‚ âˆ© sâ‚).eq_empty_or_nonempty.elim (fun h => h.symm â–¸ GenerateHas.empty) fun h =>
              GenerateHas.basic _ <| hs _ hsâ‚‚ _ hsâ‚ h
      have : (generate s).Has (tâ‚‚ âˆ© sâ‚) := this _ htâ‚‚
      show (generate s).Has (sâ‚ âˆ© tâ‚‚) by rwa [inter_comm]
                                         -- ğŸ‰ no goals
  this _ htâ‚
#align measurable_space.dynkin_system.generate_inter MeasurableSpace.DynkinSystem.generate_inter

/-- **Dynkin's Ï€-Î» theorem**:
  Given a collection of sets closed under binary intersections, then the Dynkin system it
  generates is equal to the Ïƒ-algebra it generates.
  This result is known as the Ï€-Î» theorem.
  A collection of sets closed under binary intersection is called a Ï€-system (often requiring
  additionally that it is non-empty, but we drop this condition in the formalization).
-/
theorem generateFrom_eq {s : Set (Set Î±)} (hs : IsPiSystem s) :
    generateFrom s = (generate s).toMeasurableSpace fun tâ‚ tâ‚‚ => generate_inter hs :=
  le_antisymm (generateFrom_le fun t ht => GenerateHas.basic t ht)
    (ofMeasurableSpace_le_ofMeasurableSpace_iff.mp <| by
      rw [ofMeasurableSpace_toMeasurableSpace]
      -- âŠ¢ generate s â‰¤ ofMeasurableSpace (generateFrom s)
      exact generate_le _ fun t ht => measurableSet_generateFrom ht)
      -- ğŸ‰ no goals
#align measurable_space.dynkin_system.generate_from_eq MeasurableSpace.DynkinSystem.generateFrom_eq

end DynkinSystem

theorem induction_on_inter {C : Set Î± â†’ Prop} {s : Set (Set Î±)} [m : MeasurableSpace Î±]
    (h_eq : m = generateFrom s) (h_inter : IsPiSystem s) (h_empty : C âˆ…) (h_basic : âˆ€ t âˆˆ s, C t)
    (h_compl : âˆ€ t, MeasurableSet t â†’ C t â†’ C tá¶œ)
    (h_union :
      âˆ€ f : â„• â†’ Set Î±,
        Pairwise (Disjoint on f) â†’ (âˆ€ i, MeasurableSet (f i)) â†’ (âˆ€ i, C (f i)) â†’ C (â‹ƒ i, f i)) :
    âˆ€ â¦ƒtâ¦„, MeasurableSet t â†’ C t :=
  have eq : MeasurableSet = DynkinSystem.GenerateHas s := by
    rw [h_eq, DynkinSystem.generateFrom_eq h_inter]
    -- âŠ¢ MeasurableSet = DynkinSystem.GenerateHas s
    rfl
    -- ğŸ‰ no goals
  fun t ht =>
  have : DynkinSystem.GenerateHas s t := by rwa [eq] at ht
                                            -- ğŸ‰ no goals
  this.recOn h_basic h_empty
    (fun {t} ht =>
      h_compl t <| by
        rw [eq]
        -- âŠ¢ DynkinSystem.GenerateHas s t
        exact ht)
        -- ğŸ‰ no goals
    fun {f} hf ht =>
    h_union f hf fun i => by
      rw [eq]
      -- âŠ¢ DynkinSystem.GenerateHas s (f i)
      exact ht _
      -- ğŸ‰ no goals
#align measurable_space.induction_on_inter MeasurableSpace.induction_on_inter

end MeasurableSpace
