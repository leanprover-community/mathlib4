/-
Copyright (c) 2022 Oliver Nash. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Oliver Nash
-/
import Mathlib.MeasureTheory.Integral.Periodic
import Mathlib.Data.ZMod.Quotient

#align_import measure_theory.group.add_circle from "leanprover-community/mathlib"@"f2ce6086713c78a7f880485f7917ea547a215982"

/-!
# Measure-theoretic results about the additive circle

The file is a place to collect measure-theoretic results about the additive circle.

## Main definitions:

 * `AddCircle.closedBall_ae_eq_ball`: open and closed balls in the additive circle are almost
   equal
 * `AddCircle.isAddFundamentalDomain_of_ae_ball`: a ball is a fundamental domain for rational
   angle rotation in the additive circle

-/


open Set Function Filter MeasureTheory MeasureTheory.Measure Metric

open scoped MeasureTheory Pointwise BigOperators Topology ENNReal

namespace AddCircle

variable {T : â„} [hT : Fact (0 < T)]

theorem closedBall_ae_eq_ball {x : AddCircle T} {Îµ : â„} : closedBall x Îµ =áµ[volume] ball x Îµ := by
  cases' le_or_lt Îµ 0 with hÎµ hÎµ
  -- âŠ¢ closedBall x Îµ =á¶ [ae volume] ball x Îµ
  Â· rw [ball_eq_empty.mpr hÎµ, ae_eq_empty, volume_closedBall,
      min_eq_right (by linarith [hT.out] : 2 * Îµ â‰¤ T), ENNReal.ofReal_eq_zero]
    exact mul_nonpos_of_nonneg_of_nonpos zero_le_two hÎµ
    -- ğŸ‰ no goals
  Â· suffices volume (closedBall x Îµ) â‰¤ volume (ball x Îµ) by
      exact (ae_eq_of_subset_of_measure_ge ball_subset_closedBall this measurableSet_ball
        (measure_ne_top _ _)).symm
    have : Tendsto (fun Î´ => volume (closedBall x Î´)) (ğ“[<] Îµ) (ğ“ <| volume (closedBall x Îµ)) := by
      simp_rw [volume_closedBall]
      refine' ENNReal.tendsto_ofReal (Tendsto.min tendsto_const_nhds <| Tendsto.const_mul _ _)
      convert (@monotone_id â„ _).tendsto_nhdsWithin_Iio Îµ
      simp
    refine' le_of_tendsto this (mem_nhdsWithin_Iio_iff_exists_Ioo_subset.mpr âŸ¨0, hÎµ, fun r hr => _âŸ©)
    -- âŠ¢ r âˆˆ {x_1 | (fun c => â†‘â†‘volume (closedBall x c) â‰¤ â†‘â†‘volume (ball x Îµ)) x_1}
    exact measure_mono (closedBall_subset_ball hr.2)
    -- ğŸ‰ no goals
#align add_circle.closed_ball_ae_eq_ball AddCircle.closedBall_ae_eq_ball

/-- Let `G` be the subgroup of `AddCircle T` generated by a point `u` of finite order `n : â„•`. Then
any set `I` that is almost equal to a ball of radius `T / 2n` is a fundamental domain for the action
of `G` on `AddCircle T` by left addition. -/
theorem isAddFundamentalDomain_of_ae_ball (I : Set <| AddCircle T) (u x : AddCircle T)
    (hu : IsOfFinAddOrder u) (hI : I =áµ[volume] ball x (T / (2 * addOrderOf u))) :
    IsAddFundamentalDomain (AddSubgroup.zmultiples u) I := by
  set G := AddSubgroup.zmultiples u
  -- âŠ¢ IsAddFundamentalDomain { x // x âˆˆ G } I
  set n := addOrderOf u
  -- âŠ¢ IsAddFundamentalDomain { x // x âˆˆ G } I
  set B := ball x (T / (2 * n))
  -- âŠ¢ IsAddFundamentalDomain { x // x âˆˆ G } I
  have hn : 1 â‰¤ (n : â„) := by norm_cast; linarith [addOrderOf_pos' hu]
  -- âŠ¢ IsAddFundamentalDomain { x // x âˆˆ G } I
  refine' IsAddFundamentalDomain.mk_of_measure_univ_le _ _ _ _
  Â· -- `NullMeasurableSet I volume`
    exact measurableSet_ball.nullMeasurableSet.congr hI.symm
    -- ğŸ‰ no goals
  Â· -- `âˆ€ (g : G), g â‰  0 â†’ AEDisjoint volume (g +áµ¥ I) I`
    rintro âŸ¨g, hgâŸ© hg'
    -- âŠ¢ AEDisjoint volume ({ val := g, property := hg } +áµ¥ I) I
    replace hg' : g â‰  0; Â· simpa only [Ne.def, AddSubgroup.mk_eq_zero_iff] using hg'
    -- âŠ¢ g â‰  0
                           -- ğŸ‰ no goals
    change AEDisjoint volume (g +áµ¥ I) I
    -- âŠ¢ AEDisjoint volume (g +áµ¥ I) I
    refine' AEDisjoint.congr (Disjoint.aedisjoint _)
      ((quasiMeasurePreserving_add_left volume (-g)).vadd_ae_eq_of_ae_eq g hI) hI
    have hBg : g +áµ¥ B = ball (g + x) (T / (2 * n)) := by
      rw [add_comm g x, â† singleton_add_ball _ x g, add_ball, thickening_singleton]
    rw [hBg]
    -- âŠ¢ Disjoint (ball (g + x) (T / (2 * â†‘n))) B
    apply ball_disjoint_ball
    -- âŠ¢ T / (2 * â†‘n) + T / (2 * â†‘n) â‰¤ dist (g + x) x
    rw [dist_eq_norm, add_sub_cancel, div_mul_eq_div_div, â† add_div, â† add_div, add_self_div_two,
      div_le_iff' (by positivity : 0 < (n : â„)), â† nsmul_eq_mul]
    refine' (le_add_order_smul_norm_of_isOfFinAddOrder (hu.of_mem_zmultiples hg) hg').trans
      (nsmul_le_nsmul (norm_nonneg g) _)
    exact Nat.le_of_dvd (addOrderOf_pos_iff.mpr hu) (addOrderOf_dvd_of_mem_zmultiples hg)
    -- ğŸ‰ no goals
  Â· -- `âˆ€ (g : G), QuasiMeasurePreserving (VAdd.vadd g) volume volume`
    exact fun g => quasiMeasurePreserving_add_left (G := AddCircle T) volume g
    -- ğŸ‰ no goals
  Â· -- `volume univ â‰¤ âˆ‘' (g : G), volume (g +áµ¥ I)`
    replace hI := hI.trans closedBall_ae_eq_ball.symm
    -- âŠ¢ â†‘â†‘volume univ â‰¤ âˆ‘' (g : { x // x âˆˆ G }), â†‘â†‘volume (g +áµ¥ I)
    haveI : Fintype G := @Fintype.ofFinite _ hu.finite_zmultiples
    -- âŠ¢ â†‘â†‘volume univ â‰¤ âˆ‘' (g : { x // x âˆˆ G }), â†‘â†‘volume (g +áµ¥ I)
    have hG_card : (Finset.univ : Finset G).card = n := by
      show _ = addOrderOf u
      rw [add_order_eq_card_zmultiples', Nat.card_eq_fintype_card]; rfl
    simp_rw [measure_vadd]
    -- âŠ¢ â†‘â†‘volume univ â‰¤ âˆ‘' (g : { x // x âˆˆ AddSubgroup.zmultiples u }), â†‘â†‘volume I
    rw [AddCircle.measure_univ, tsum_fintype, Finset.sum_const, measure_congr hI,
      volume_closedBall, â† ENNReal.ofReal_nsmul, mul_div, mul_div_mul_comm,
      div_self, one_mul, min_eq_right (div_le_self hT.out.le hn), hG_card,
      nsmul_eq_mul, mul_div_cancel' T (lt_of_lt_of_le zero_lt_one hn).ne.symm]
    exact two_ne_zero
    -- ğŸ‰ no goals
#align add_circle.is_add_fundamental_domain_of_ae_ball AddCircle.isAddFundamentalDomain_of_ae_ball

theorem volume_of_add_preimage_eq (s I : Set <| AddCircle T) (u x : AddCircle T)
    (hu : IsOfFinAddOrder u) (hs : (u +áµ¥ s : Set <| AddCircle T) =áµ[volume] s)
    (hI : I =áµ[volume] ball x (T / (2 * addOrderOf u))) :
    volume s = addOrderOf u â€¢ volume (s âˆ© I) := by
  let G := AddSubgroup.zmultiples u
  -- âŠ¢ â†‘â†‘volume s = addOrderOf u â€¢ â†‘â†‘volume (s âˆ© I)
  haveI : Fintype G := @Fintype.ofFinite _ hu.finite_zmultiples
  -- âŠ¢ â†‘â†‘volume s = addOrderOf u â€¢ â†‘â†‘volume (s âˆ© I)
  have hsG : âˆ€ g : G, (g +áµ¥ s : Set <| AddCircle T) =áµ[volume] s := by
    rintro âŸ¨y, hyâŸ©; exact (vadd_ae_eq_self_of_mem_zmultiples hs hy : _)
  rw [(isAddFundamentalDomain_of_ae_ball I u x hu hI).measure_eq_card_smul_of_vadd_ae_eq_self s hsG,
    add_order_eq_card_zmultiples' u, Nat.card_eq_fintype_card]
#align add_circle.volume_of_add_preimage_eq AddCircle.volume_of_add_preimage_eq

end AddCircle
