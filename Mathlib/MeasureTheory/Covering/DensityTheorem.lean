/-
Copyright (c) 2022 Oliver Nash. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Oliver Nash

! This file was ported from Lean 3 source module measure_theory.covering.density_theorem
! leanprover-community/mathlib commit 5f6e827d81dfbeb6151d7016586ceeb0099b9655
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.MeasureTheory.Measure.Doubling
import Mathbin.MeasureTheory.Covering.Vitali
import Mathbin.MeasureTheory.Covering.Differentiation

/-!
# Uniformly locally doubling measures and Lebesgue's density theorem

Lebesgue's density theorem states that given a set `S` in a sigma compact metric space with
locally-finite uniformly locally doubling measure `Œº` then for almost all points `x` in `S`, for any
sequence of closed balls `B‚ÇÄ, B‚ÇÅ, B‚ÇÇ, ...` containing `x`, the limit `Œº (S ‚à© B‚±º) / Œº (B‚±º) ‚Üí 1` as
`j ‚Üí ‚àû`.

In this file we combine general results about existence of Vitali families for uniformly locally
doubling measures with results about differentiation along a Vitali family to obtain an explicit
form of Lebesgue's density theorem.

## Main results
  * `is_unif_loc_doubling_measure.ae_tendsto_measure_inter_div`: a version of Lebesgue's density
  theorem for sequences of balls converging on a point but whose centres are not required to be
  fixed.

-/


noncomputable section

open Set Filter Metric MeasureTheory TopologicalSpace

open scoped NNReal Topology

namespace IsUnifLocDoublingMeasure

variable {Œ± : Type _} [MetricSpace Œ±] [MeasurableSpace Œ±] (Œº : Measure Œ±)
  [IsUnifLocDoublingMeasure Œº]

section

variable [SecondCountableTopology Œ±] [BorelSpace Œ±] [IsLocallyFiniteMeasure Œº]

open scoped Topology

/-- A Vitali family in a space with a uniformly locally doubling measure, designed so that the sets
at `x` contain all `closed_ball y r` when `dist x y ‚â§ K * r`. -/
irreducible_def vitaliFamily (K : ‚Ñù) : VitaliFamily Œº :=
  by
  /- the Vitali covering theorem gives a family that works well at small scales, thanks to the
    doubling property. We enlarge this family to add large sets, to make sure that all balls and not
    only small ones belong to the family, for convenience. -/
  let R := scaling_scale_of Œº (max (4 * K + 3) 3)
  have Rpos : 0 < R := scaling_scale_of_pos _ _
  have A :
    ‚àÄ x : Œ±,
      ‚àÉ·∂† r in ùìù[>] (0 : ‚Ñù),
        Œº (closed_ball x (3 * r)) ‚â§
          scaling_constant_of Œº (max (4 * K + 3) 3) * Œº (closed_ball x r) :=
    by
    intro x
    apply frequently_iff.2 fun U hU => _
    obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© := mem_nhdsWithin_Ioi_iff_exists_Ioc_subset.1 hU
    refine' ‚ü®min Œµ R, hŒµ ‚ü®lt_min Œµpos Rpos, min_le_left _ _‚ü©, _‚ü©
    exact
      measure_mul_le_scaling_constant_of_mul Œº ‚ü®zero_lt_three, le_max_right _ _‚ü© (min_le_right _ _)
  exact
    (Vitali.vitaliFamily Œº (scaling_constant_of Œº (max (4 * K + 3) 3)) A).enlarge (R / 4)
      (by linarith)
#align is_unif_loc_doubling_measure.vitali_family IsUnifLocDoublingMeasure.vitaliFamily

/-- In the Vitali family `is_unif_loc_doubling_measure.vitali_family K`, the sets based at `x`
contain all balls `closed_ball y r` when `dist x y ‚â§ K * r`. -/
theorem closedBall_mem_vitaliFamily_of_dist_le_mul {K : ‚Ñù} {x y : Œ±} {r : ‚Ñù} (h : dist x y ‚â§ K * r)
    (rpos : 0 < r) : closedBall y r ‚àà (vitaliFamily Œº K).setsAt x :=
  by
  let R := scaling_scale_of Œº (max (4 * K + 3) 3)
  simp only [VitaliFamily, VitaliFamily.enlarge, Vitali.vitaliFamily, mem_union, mem_set_of_eq,
    is_closed_ball, true_and_iff, (nonempty_ball.2 rpos).mono ball_subset_interior_closed_ball,
    measurableSet_closedBall]
  /- The measure is doubling on scales smaller than `R`. Therefore, we treat differently small
    and large balls. For large balls, this follows directly from the enlargement we used in the
    definition. -/
  by_cases H : closed_ball y r ‚äÜ closed_ball x (R / 4)
  swap; ¬∑ exact Or.inr H
  left
  /- For small balls, there is the difficulty that `r` could be large but still the ball could be
    small, if the annulus `{y | Œµ ‚â§ dist y x ‚â§ R/4}` is empty. We split between the cases `r ‚â§ R`
    and `r < R`, and use the doubling for the former and rough estimates for the latter. -/
  rcases le_or_lt r R with (hr | hr)
  ¬∑ refine' ‚ü®(K + 1) * r, _‚ü©
    constructor
    ¬∑ apply closed_ball_subset_closed_ball'
      rw [dist_comm]
      linarith
    ¬∑ have I1 : closed_ball x (3 * ((K + 1) * r)) ‚äÜ closed_ball y ((4 * K + 3) * r) :=
        by
        apply closed_ball_subset_closed_ball'
        linarith
      have I2 : closed_ball y ((4 * K + 3) * r) ‚äÜ closed_ball y (max (4 * K + 3) 3 * r) :=
        by
        apply closed_ball_subset_closed_ball
        exact mul_le_mul_of_nonneg_right (le_max_left _ _) rpos.le
      apply (measure_mono (I1.trans I2)).trans
      exact
        measure_mul_le_scaling_constant_of_mul _ ‚ü®zero_lt_three.trans_le (le_max_right _ _), le_rfl‚ü©
          hr
  ¬∑ refine' ‚ü®R / 4, H, _‚ü©
    have : closed_ball x (3 * (R / 4)) ‚äÜ closed_ball y r :=
      by
      apply closed_ball_subset_closed_ball'
      have A : y ‚àà closed_ball y r := mem_closed_ball_self rpos.le
      have B := mem_closed_ball'.1 (H A)
      linarith
    apply (measure_mono this).trans _
    refine' le_mul_of_one_le_left (zero_le _) _
    exact ENNReal.one_le_coe_iff.2 (le_max_right _ _)
#align is_unif_loc_doubling_measure.closed_ball_mem_vitali_family_of_dist_le_mul IsUnifLocDoublingMeasure.closedBall_mem_vitaliFamily_of_dist_le_mul

theorem tendsto_closedBall_filterAt {K : ‚Ñù} {x : Œ±} {Œπ : Type _} {l : Filter Œπ} (w : Œπ ‚Üí Œ±)
    (Œ¥ : Œπ ‚Üí ‚Ñù) (Œ¥lim : Tendsto Œ¥ l (ùìù[>] 0)) (xmem : ‚àÄ·∂† j in l, x ‚àà closedBall (w j) (K * Œ¥ j)) :
    Tendsto (fun j => closedBall (w j) (Œ¥ j)) l ((vitaliFamily Œº K).filterAt x) :=
  by
  refine' (VitaliFamily Œº K).tendsto_filterAt_iff.mpr ‚ü®_, fun Œµ hŒµ => _‚ü©
  ¬∑ filter_upwards [xmem, Œ¥lim self_mem_nhdsWithin] with j hj h'j
    exact closed_ball_mem_vitali_family_of_dist_le_mul Œº hj h'j
  ¬∑ by_cases l.ne_bot
    swap; ¬∑ simp [not_ne_bot.1 h]
    have hK : 0 ‚â§ K := by
      skip
      rcases(xmem.and (Œ¥lim self_mem_nhdsWithin)).exists with ‚ü®j, hj, h'j‚ü©
      have : 0 ‚â§ K * Œ¥ j := nonempty_closed_ball.1 ‚ü®x, hj‚ü©
      exact (mul_nonneg_iff_left_nonneg_of_pos (mem_Ioi.1 h'j)).1 this
    have Œ¥pos := eventually_mem_of_tendsto_nhdsWithin Œ¥lim
    replace Œ¥lim := tendsto_nhds_of_tendsto_nhdsWithin Œ¥lim
    replace hK : 0 < K + 1; ¬∑ linarith
    apply (((metric.tendsto_nhds.mp Œ¥lim _ (div_pos hŒµ hK)).And Œ¥pos).And xmem).mono
    rintro j ‚ü®‚ü®hjŒµ, hj‚ÇÄ : 0 < Œ¥ j‚ü©, hx‚ü© y hy
    replace hjŒµ : (K + 1) * Œ¥ j < Œµ := by
      simpa [abs_eq_self.mpr hj‚ÇÄ.le] using (lt_div_iff' hK).mp hjŒµ
    simp only [mem_closed_ball] at hx hy ‚ä¢
    linarith [dist_triangle_right y x (w j)]
#align is_unif_loc_doubling_measure.tendsto_closed_ball_filter_at IsUnifLocDoublingMeasure.tendsto_closedBall_filterAt

end

section Applications

variable [SecondCountableTopology Œ±] [BorelSpace Œ±] [IsLocallyFiniteMeasure Œº] {E : Type _}
  [NormedAddCommGroup E]

/-- A version of *Lebesgue's density theorem* for a sequence of closed balls whose centers are
not required to be fixed.

See also `besicovitch.ae_tendsto_measure_inter_div`. -/
theorem ae_tendsto_measure_inter_div (S : Set Œ±) (K : ‚Ñù) :
    ‚àÄ·µê x ‚àÇŒº.restrict S,
      ‚àÄ {Œπ : Type _} {l : Filter Œπ} (w : Œπ ‚Üí Œ±) (Œ¥ : Œπ ‚Üí ‚Ñù) (Œ¥lim : Tendsto Œ¥ l (ùìù[>] 0))
        (xmem : ‚àÄ·∂† j in l, x ‚àà closedBall (w j) (K * Œ¥ j)),
        Tendsto (fun j => Œº (S ‚à© closedBall (w j) (Œ¥ j)) / Œº (closedBall (w j) (Œ¥ j))) l (ùìù 1) :=
  by
  filter_upwards [(VitaliFamily Œº K).ae_tendsto_measure_inter_div S] with x hx Œπ l w Œ¥ Œ¥lim
    xmem using hx.comp (tendsto_closed_ball_filter_at Œº _ _ Œ¥lim xmem)
#align is_unif_loc_doubling_measure.ae_tendsto_measure_inter_div IsUnifLocDoublingMeasure.ae_tendsto_measure_inter_div

/-- A version of *Lebesgue differentiation theorem* for a sequence of closed balls whose
centers are not required to be fixed. -/
theorem ae_tendsto_average_norm_sub {f : Œ± ‚Üí E} (hf : Integrable f Œº) (K : ‚Ñù) :
    ‚àÄ·µê x ‚àÇŒº,
      ‚àÄ {Œπ : Type _} {l : Filter Œπ} (w : Œπ ‚Üí Œ±) (Œ¥ : Œπ ‚Üí ‚Ñù) (Œ¥lim : Tendsto Œ¥ l (ùìù[>] 0))
        (xmem : ‚àÄ·∂† j in l, x ‚àà closedBall (w j) (K * Œ¥ j)),
        Tendsto (fun j => ‚®ç y in closedBall (w j) (Œ¥ j), ‚Äñf y - f x‚Äñ ‚àÇŒº) l (ùìù 0) :=
  by
  filter_upwards [(VitaliFamily Œº K).ae_tendsto_average_norm_sub hf] with x hx Œπ l w Œ¥ Œ¥lim
    xmem using hx.comp (tendsto_closed_ball_filter_at Œº _ _ Œ¥lim xmem)
#align is_unif_loc_doubling_measure.ae_tendsto_average_norm_sub IsUnifLocDoublingMeasure.ae_tendsto_average_norm_sub

/-- A version of *Lebesgue differentiation theorem* for a sequence of closed balls whose
centers are not required to be fixed. -/
theorem ae_tendsto_average [NormedSpace ‚Ñù E] [CompleteSpace E] {f : Œ± ‚Üí E} (hf : Integrable f Œº)
    (K : ‚Ñù) :
    ‚àÄ·µê x ‚àÇŒº,
      ‚àÄ {Œπ : Type _} {l : Filter Œπ} (w : Œπ ‚Üí Œ±) (Œ¥ : Œπ ‚Üí ‚Ñù) (Œ¥lim : Tendsto Œ¥ l (ùìù[>] 0))
        (xmem : ‚àÄ·∂† j in l, x ‚àà closedBall (w j) (K * Œ¥ j)),
        Tendsto (fun j => ‚®ç y in closedBall (w j) (Œ¥ j), f y ‚àÇŒº) l (ùìù (f x)) :=
  by
  filter_upwards [(VitaliFamily Œº K).ae_tendsto_average hf] with x hx Œπ l w Œ¥ Œ¥lim xmem using
    hx.comp (tendsto_closed_ball_filter_at Œº _ _ Œ¥lim xmem)
#align is_unif_loc_doubling_measure.ae_tendsto_average IsUnifLocDoublingMeasure.ae_tendsto_average

end Applications

end IsUnifLocDoublingMeasure

