/-
Copyright (c) 2020 Floris van Doorn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Floris van Doorn

! This file was ported from Lean 3 source module measure_theory.constructions.prod.basic
! leanprover-community/mathlib commit 3b88f4005dc2e28d42f974cc1ce838f0dafb39b8
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.MeasureTheory.Measure.GiryMonad
import Mathbin.Dynamics.Ergodic.MeasurePreserving
import Mathbin.MeasureTheory.Integral.Lebesgue
import Mathbin.MeasureTheory.Measure.OpenPos

/-!
# The product measure

In this file we define and prove properties about the binary product measure. If `α` and `β` have
σ-finite measures `μ` resp. `ν` then `α × β` can be equipped with a σ-finite measure `μ.prod ν` that
satisfies `(μ.prod ν) s = ∫⁻ x, ν {y | (x, y) ∈ s} ∂μ`.
We also have `(μ.prod ν) (s ×ˢ t) = μ s * ν t`, i.e. the measure of a rectangle is the product of
the measures of the sides.

We also prove Tonelli's theorem.

## Main definition

* `measure_theory.measure.prod`: The product of two measures.

## Main results

* `measure_theory.measure.prod_apply` states `μ.prod ν s = ∫⁻ x, ν {y | (x, y) ∈ s} ∂μ`
  for measurable `s`. `measure_theory.measure.prod_apply_symm` is the reversed version.
* `measure_theory.measure.prod_prod` states `μ.prod ν (s ×ˢ t) = μ s * ν t` for measurable sets
  `s` and `t`.
* `measure_theory.lintegral_prod`: Tonelli's theorem. It states that for a measurable function
  `α × β → ℝ≥0∞` we have `∫⁻ z, f z ∂(μ.prod ν) = ∫⁻ x, ∫⁻ y, f (x, y) ∂ν ∂μ`. The version
  for functions `α → β → ℝ≥0∞` is reversed, and called `lintegral_lintegral`. Both versions have
  a variant with `_symm` appended, where the order of integration is reversed.
  The lemma `measurable.lintegral_prod_right'` states that the inner integral of the right-hand side
  is measurable.

## Implementation Notes

Many results are proven twice, once for functions in curried form (`α → β → γ`) and one for
functions in uncurried form (`α × β → γ`). The former often has an assumption
`measurable (uncurry f)`, which could be inconvenient to discharge, but for the latter it is more
common that the function has to be given explicitly, since Lean cannot synthesize the function by
itself. We name the lemmas about the uncurried form with a prime.
Tonelli's theorem has a different naming scheme, since the version for the uncurried version is
reversed.

## Tags

product measure, Tonelli's theorem, Fubini-Tonelli theorem
-/


noncomputable section

open scoped Classical Topology ENNReal MeasureTheory

open Set Function Real ENNReal

open MeasureTheory MeasurableSpace MeasureTheory.Measure

open TopologicalSpace hiding generateFrom

open Filter hiding prod_eq map

variable {α α' β β' γ E : Type _}

/- ./././Mathport/Syntax/Translate/Expr.lean:228:8: unsupported: ambiguous notation -/
/-- Rectangles formed by π-systems form a π-system. -/
theorem IsPiSystem.prod {C : Set (Set α)} {D : Set (Set β)} (hC : IsPiSystem C)
    (hD : IsPiSystem D) : IsPiSystem (image2 (· ×ˢ ·) C D) :=
  by
  rintro _ ⟨s₁, t₁, hs₁, ht₁, rfl⟩ _ ⟨s₂, t₂, hs₂, ht₂, rfl⟩ hst
  rw [prod_inter_prod] at hst⊢; rw [prod_nonempty_iff] at hst
  exact mem_image2_of_mem (hC _ hs₁ _ hs₂ hst.1) (hD _ ht₁ _ ht₂ hst.2)
#align is_pi_system.prod IsPiSystem.prod

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:228:8: unsupported: ambiguous notation -/
/-- Rectangles of countably spanning sets are countably spanning. -/
theorem IsCountablySpanning.prod {C : Set (Set α)} {D : Set (Set β)} (hC : IsCountablySpanning C)
    (hD : IsCountablySpanning D) : IsCountablySpanning (image2 (· ×ˢ ·) C D) :=
  by
  rcases hC, hD with ⟨⟨s, h1s, h2s⟩, t, h1t, h2t⟩
  refine' ⟨fun n => s n.unpair.1 ×ˢ t n.unpair.2, fun n => mem_image2_of_mem (h1s _) (h1t _), _⟩
  rw [Union_unpair_prod, h2s, h2t, univ_prod_univ]
#align is_countably_spanning.prod IsCountablySpanning.prod

variable [MeasurableSpace α] [MeasurableSpace α'] [MeasurableSpace β] [MeasurableSpace β']

variable [MeasurableSpace γ]

variable {μ μ' : Measure α} {ν ν' : Measure β} {τ : Measure γ}

variable [NormedAddCommGroup E]

/-! ### Measurability

Before we define the product measure, we can talk about the measurability of operations on binary
functions. We show that if `f` is a binary measurable function, then the function that integrates
along one of the variables (using either the Lebesgue or Bochner integral) is measurable.
-/


/- ./././Mathport/Syntax/Translate/Expr.lean:228:8: unsupported: ambiguous notation -/
/-- The product of generated σ-algebras is the one generated by rectangles, if both generating sets
  are countably spanning. -/
theorem generateFrom_prod_eq {α β} {C : Set (Set α)} {D : Set (Set β)} (hC : IsCountablySpanning C)
    (hD : IsCountablySpanning D) :
    @Prod.instMeasurableSpace _ _ (generateFrom C) (generateFrom D) =
      generateFrom (image2 (· ×ˢ ·) C D) :=
  by
  apply le_antisymm
  · refine' sup_le _ _ <;> rw [comap_generate_from] <;> apply generate_from_le <;>
      rintro _ ⟨s, hs, rfl⟩
    · rcases hD with ⟨t, h1t, h2t⟩
      rw [← prod_univ, ← h2t, prod_Union]
      apply MeasurableSet.iUnion
      intro n; apply measurable_set_generate_from
      exact ⟨s, t n, hs, h1t n, rfl⟩
    · rcases hC with ⟨t, h1t, h2t⟩
      rw [← univ_prod, ← h2t, Union_prod_const]
      apply MeasurableSet.iUnion
      rintro n; apply measurable_set_generate_from
      exact mem_image2_of_mem (h1t n) hs
  · apply generate_from_le; rintro _ ⟨s, t, hs, ht, rfl⟩; rw [prod_eq]
    apply (measurable_fst _).inter (measurable_snd _)
    · exact measurable_set_generate_from hs
    · exact measurable_set_generate_from ht
#align generate_from_prod_eq generateFrom_prod_eq

/- ./././Mathport/Syntax/Translate/Expr.lean:228:8: unsupported: ambiguous notation -/
/-- If `C` and `D` generate the σ-algebras on `α` resp. `β`, then rectangles formed by `C` and `D`
  generate the σ-algebra on `α × β`. -/
theorem generateFrom_eq_prod {C : Set (Set α)} {D : Set (Set β)} (hC : generateFrom C = ‹_›)
    (hD : generateFrom D = ‹_›) (h2C : IsCountablySpanning C) (h2D : IsCountablySpanning D) :
    generateFrom (image2 (· ×ˢ ·) C D) = Prod.instMeasurableSpace := by
  rw [← hC, ← hD, generateFrom_prod_eq h2C h2D]
#align generate_from_eq_prod generateFrom_eq_prod

/- ./././Mathport/Syntax/Translate/Expr.lean:228:8: unsupported: ambiguous notation -/
/-- The product σ-algebra is generated from boxes, i.e. `s ×ˢ t` for sets `s : set α` and
  `t : set β`. -/
theorem generateFrom_prod :
    generateFrom (image2 (· ×ˢ ·) { s : Set α | MeasurableSet s } { t : Set β | MeasurableSet t }) =
      Prod.instMeasurableSpace :=
  generateFrom_eq_prod generateFrom_measurableSet generateFrom_measurableSet
    isCountablySpanning_measurableSet isCountablySpanning_measurableSet
#align generate_from_prod generateFrom_prod

/- ./././Mathport/Syntax/Translate/Expr.lean:228:8: unsupported: ambiguous notation -/
/-- Rectangles form a π-system. -/
theorem isPiSystem_prod :
    IsPiSystem (image2 (· ×ˢ ·) { s : Set α | MeasurableSet s } { t : Set β | MeasurableSet t }) :=
  isPiSystem_measurableSet.Prod isPiSystem_measurableSet
#align is_pi_system_prod isPiSystem_prod

/-- If `ν` is a finite measure, and `s ⊆ α × β` is measurable, then `x ↦ ν { y | (x, y) ∈ s }` is
  a measurable function. `measurable_measure_prod_mk_left` is strictly more general. -/
theorem measurable_measure_prod_mk_left_finite [FiniteMeasure ν] {s : Set (α × β)}
    (hs : MeasurableSet s) : Measurable fun x => ν (Prod.mk x ⁻¹' s) :=
  by
  refine' induction_on_inter generate_from_prod.symm isPiSystem_prod _ _ _ _ hs
  · simp [measurable_zero, const_def]
  · rintro _ ⟨s, t, hs, ht, rfl⟩; simp only [mk_preimage_prod_right_eq_if, measure_if]
    exact measurable_const.indicator hs
  · intro t ht h2t
    simp_rw [preimage_compl, measure_compl (measurable_prod_mk_left ht) (measure_ne_top ν _)]
    exact h2t.const_sub _
  · intro f h1f h2f h3f; simp_rw [preimage_Union]
    have : ∀ b, ν (⋃ i, Prod.mk b ⁻¹' f i) = ∑' i, ν (Prod.mk b ⁻¹' f i) := fun b =>
      measure_Union (fun i j hij => Disjoint.preimage _ (h1f hij)) fun i =>
        measurable_prod_mk_left (h2f i)
    simp_rw [this]; apply Measurable.ennreal_tsum h3f
#align measurable_measure_prod_mk_left_finite measurable_measure_prod_mk_left_finite

/-- If `ν` is a σ-finite measure, and `s ⊆ α × β` is measurable, then `x ↦ ν { y | (x, y) ∈ s }` is
  a measurable function. -/
theorem measurable_measure_prod_mk_left [SigmaFinite ν] {s : Set (α × β)} (hs : MeasurableSet s) :
    Measurable fun x => ν (Prod.mk x ⁻¹' s) :=
  by
  have : ∀ x, MeasurableSet (Prod.mk x ⁻¹' s) := fun x => measurable_prod_mk_left hs
  simp only [← @supr_restrict_spanning_sets _ _ ν, this]
  apply measurable_iSup; intro i
  haveI := Fact.mk (measure_spanning_sets_lt_top ν i)
  exact measurable_measure_prod_mk_left_finite hs
#align measurable_measure_prod_mk_left measurable_measure_prod_mk_left

/-- If `μ` is a σ-finite measure, and `s ⊆ α × β` is measurable, then `y ↦ μ { x | (x, y) ∈ s }` is
  a measurable function. -/
theorem measurable_measure_prod_mk_right {μ : Measure α} [SigmaFinite μ] {s : Set (α × β)}
    (hs : MeasurableSet s) : Measurable fun y => μ ((fun x => (x, y)) ⁻¹' s) :=
  measurable_measure_prod_mk_left (measurableSet_swap_iff.mpr hs)
#align measurable_measure_prod_mk_right measurable_measure_prod_mk_right

theorem Measurable.map_prod_mk_left [SigmaFinite ν] : Measurable fun x : α => map (Prod.mk x) ν :=
  by
  apply measurable_of_measurable_coe; intro s hs
  simp_rw [map_apply measurable_prod_mk_left hs]
  exact measurable_measure_prod_mk_left hs
#align measurable.map_prod_mk_left Measurable.map_prod_mk_left

theorem Measurable.map_prod_mk_right {μ : Measure α} [SigmaFinite μ] :
    Measurable fun y : β => map (fun x : α => (x, y)) μ :=
  by
  apply measurable_of_measurable_coe; intro s hs
  simp_rw [map_apply measurable_prod_mk_right hs]
  exact measurable_measure_prod_mk_right hs
#align measurable.map_prod_mk_right Measurable.map_prod_mk_right

theorem MeasurableEmbedding.prod_mk {α β γ δ : Type _} {mα : MeasurableSpace α}
    {mβ : MeasurableSpace β} {mγ : MeasurableSpace γ} {mδ : MeasurableSpace δ} {f : α → β}
    {g : γ → δ} (hg : MeasurableEmbedding g) (hf : MeasurableEmbedding f) :
    MeasurableEmbedding fun x : γ × α => (g x.1, f x.2) :=
  by
  have h_inj : Function.Injective fun x : γ × α => (g x.fst, f x.snd) :=
    by
    intro x y hxy
    rw [← @Prod.mk.eta _ _ x, ← @Prod.mk.eta _ _ y]
    simp only [Prod.mk.inj_iff] at hxy⊢
    exact ⟨hg.injective hxy.1, hf.injective hxy.2⟩
  refine' ⟨h_inj, _, _⟩
  · exact (hg.measurable.comp measurable_fst).prod_mk (hf.measurable.comp measurable_snd)
  · -- Induction using the π-system of rectangles
    refine' fun s hs =>
      @MeasurableSpace.induction_on_inter _
        (fun s => MeasurableSet ((fun x : γ × α => (g x.fst, f x.snd)) '' s)) _ _
        generate_from_prod.symm isPiSystem_prod _ _ _ _ _ hs
    · simp only [Set.image_empty, MeasurableSet.empty]
    · rintro t ⟨t₁, t₂, ht₁, ht₂, rfl⟩
      rw [← Set.prod_image_image_eq]
      exact (hg.measurable_set_image.mpr ht₁).Prod (hf.measurable_set_image.mpr ht₂)
    · intro t ht ht_m
      rw [← Set.range_diff_image h_inj, ← Set.prod_range_range_eq]
      exact
        MeasurableSet.diff (MeasurableSet.prod hg.measurable_set_range hf.measurable_set_range) ht_m
    · intro g hg_disj hg_meas hg
      simp_rw [Set.image_iUnion]
      exact MeasurableSet.iUnion hg
#align measurable_embedding.prod_mk MeasurableEmbedding.prod_mk

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  Tonelli's theorem is measurable. -/
theorem Measurable.lintegral_prod_right' [SigmaFinite ν] :
    ∀ {f : α × β → ℝ≥0∞} (hf : Measurable f), Measurable fun x => ∫⁻ y, f (x, y) ∂ν :=
  by
  have m := @measurable_prod_mk_left
  refine' Measurable.ennreal_induction _ _ _
  · intro c s hs; simp only [← indicator_comp_right]
    suffices Measurable fun x => c * ν (Prod.mk x ⁻¹' s) by simpa [lintegral_indicator _ (m hs)]
    exact (measurable_measure_prod_mk_left hs).const_mul _
  · rintro f g - hf hg h2f h2g; simp_rw [Pi.add_apply, lintegral_add_left (hf.comp m)]
    exact h2f.add h2g
  · intro f hf h2f h3f
    have := measurable_iSup h3f
    have : ∀ x, Monotone fun n y => f n (x, y) := fun x i j hij y => h2f hij (x, y)
    simpa [lintegral_supr fun n => (hf n).comp m, this]
#align measurable.lintegral_prod_right' Measurable.lintegral_prod_right'

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  Tonelli's theorem is measurable.
  This version has the argument `f` in curried form. -/
theorem Measurable.lintegral_prod_right [SigmaFinite ν] {f : α → β → ℝ≥0∞}
    (hf : Measurable (uncurry f)) : Measurable fun x => ∫⁻ y, f x y ∂ν :=
  hf.lintegral_prod_right'
#align measurable.lintegral_prod_right Measurable.lintegral_prod_right

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  the symmetric version of Tonelli's theorem is measurable. -/
theorem Measurable.lintegral_prod_left' [SigmaFinite μ] {f : α × β → ℝ≥0∞} (hf : Measurable f) :
    Measurable fun y => ∫⁻ x, f (x, y) ∂μ :=
  (measurable_swap_iff.mpr hf).lintegral_prod_right'
#align measurable.lintegral_prod_left' Measurable.lintegral_prod_left'

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  the symmetric version of Tonelli's theorem is measurable.
  This version has the argument `f` in curried form. -/
theorem Measurable.lintegral_prod_left [SigmaFinite μ] {f : α → β → ℝ≥0∞}
    (hf : Measurable (uncurry f)) : Measurable fun y => ∫⁻ x, f x y ∂μ :=
  hf.lintegral_prod_left'
#align measurable.lintegral_prod_left Measurable.lintegral_prod_left

/-! ### The product measure -/


namespace MeasureTheory

namespace Measure

/-- The binary product of measures. They are defined for arbitrary measures, but we basically
  prove all properties under the assumption that at least one of them is σ-finite. -/
protected irreducible_def prod (μ : Measure α) (ν : Measure β) : Measure (α × β) :=
  bind μ fun x : α => map (Prod.mk x) ν
#align measure_theory.measure.prod MeasureTheory.Measure.prod

instance prod.measureSpace {α β} [MeasureSpace α] [MeasureSpace β] : MeasureSpace (α × β)
    where volume := volume.Prod volume
#align measure_theory.measure.prod.measure_space MeasureTheory.Measure.prod.measureSpace

variable [SigmaFinite ν]

theorem volume_eq_prod (α β) [MeasureSpace α] [MeasureSpace β] :
    (volume : Measure (α × β)) = (volume : Measure α).Prod (volume : Measure β) :=
  rfl
#align measure_theory.measure.volume_eq_prod MeasureTheory.Measure.volume_eq_prod

theorem prod_apply {s : Set (α × β)} (hs : MeasurableSet s) :
    μ.Prod ν s = ∫⁻ x, ν (Prod.mk x ⁻¹' s) ∂μ := by
  simp_rw [measure.prod, bind_apply hs Measurable.map_prod_mk_left,
    map_apply measurable_prod_mk_left hs]
#align measure_theory.measure.prod_apply MeasureTheory.Measure.prod_apply

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/-- The product measure of the product of two sets is the product of their measures. Note that we
do not need the sets to be measurable. -/
@[simp]
theorem prod_prod (s : Set α) (t : Set β) : μ.Prod ν (s ×ˢ t) = μ s * ν t :=
  by
  apply le_antisymm
  · set ST := to_measurable μ s ×ˢ to_measurable ν t
    have hSTm : MeasurableSet ST :=
      (measurable_set_to_measurable _ _).Prod (measurable_set_to_measurable _ _)
    calc
      μ.prod ν (s ×ˢ t) ≤ μ.prod ν ST :=
        measure_mono <| Set.prod_mono (subset_to_measurable _ _) (subset_to_measurable _ _)
      _ = μ (to_measurable μ s) * ν (to_measurable ν t) := by
        simp_rw [prod_apply hSTm, mk_preimage_prod_right_eq_if, measure_if,
          lintegral_indicator _ (measurable_set_to_measurable _ _), lintegral_const,
          restrict_apply_univ, mul_comm]
      _ = μ s * ν t := by rw [measure_to_measurable, measure_to_measurable]
      
  · -- Formalization is based on https://mathoverflow.net/a/254134/136589
    set ST := to_measurable (μ.prod ν) (s ×ˢ t)
    have hSTm : MeasurableSet ST := measurable_set_to_measurable _ _
    have hST : s ×ˢ t ⊆ ST := subset_to_measurable _ _
    set f : α → ℝ≥0∞ := fun x => ν (Prod.mk x ⁻¹' ST)
    have hfm : Measurable f := measurable_measure_prod_mk_left hSTm
    set s' : Set α := { x | ν t ≤ f x }
    have hss' : s ⊆ s' := fun x hx => measure_mono fun y hy => hST <| mk_mem_prod hx hy
    calc
      μ s * ν t ≤ μ s' * ν t := mul_le_mul_right' (measure_mono hss') _
      _ = ∫⁻ x in s', ν t ∂μ := by rw [set_lintegral_const, mul_comm]
      _ ≤ ∫⁻ x in s', f x ∂μ := (set_lintegral_mono measurable_const hfm fun x => id)
      _ ≤ ∫⁻ x, f x ∂μ := (lintegral_mono' restrict_le_self le_rfl)
      _ = μ.prod ν ST := (prod_apply hSTm).symm
      _ = μ.prod ν (s ×ˢ t) := measure_to_measurable _
      
#align measure_theory.measure.prod_prod MeasureTheory.Measure.prod_prod

instance {X Y : Type _} [TopologicalSpace X] [TopologicalSpace Y] {m : MeasurableSpace X}
    {μ : Measure X} [OpenPosMeasure μ] {m' : MeasurableSpace Y} {ν : Measure Y} [OpenPosMeasure ν]
    [SigmaFinite ν] : OpenPosMeasure (μ.Prod ν) :=
  by
  constructor
  rintro U U_open ⟨⟨x, y⟩, hxy⟩
  rcases isOpen_prod_iff.1 U_open x y hxy with ⟨u, v, u_open, v_open, xu, yv, huv⟩
  refine' ne_of_gt (lt_of_lt_of_le _ (measure_mono huv))
  simp only [prod_prod, CanonicallyOrderedCommSemiring.mul_pos]
  constructor
  · exact u_open.measure_pos μ ⟨x, xu⟩
  · exact v_open.measure_pos ν ⟨y, yv⟩

instance {α β : Type _} {mα : MeasurableSpace α} {mβ : MeasurableSpace β} (μ : Measure α)
    (ν : Measure β) [FiniteMeasure μ] [FiniteMeasure ν] : FiniteMeasure (μ.Prod ν) :=
  by
  constructor
  rw [← univ_prod_univ, prod_prod]
  exact mul_lt_top (measure_lt_top _ _).Ne (measure_lt_top _ _).Ne

instance {α β : Type _} {mα : MeasurableSpace α} {mβ : MeasurableSpace β} (μ : Measure α)
    (ν : Measure β) [ProbabilityMeasure μ] [ProbabilityMeasure ν] : ProbabilityMeasure (μ.Prod ν) :=
  ⟨by rw [← univ_prod_univ, prod_prod, measure_univ, measure_univ, mul_one]⟩

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
instance {α β : Type _} [TopologicalSpace α] [TopologicalSpace β] {mα : MeasurableSpace α}
    {mβ : MeasurableSpace β} (μ : Measure α) (ν : Measure β) [FiniteMeasureOnCompacts μ]
    [FiniteMeasureOnCompacts ν] [SigmaFinite ν] : FiniteMeasureOnCompacts (μ.Prod ν) :=
  by
  refine' ⟨fun K hK => _⟩
  set L := (Prod.fst '' K) ×ˢ (Prod.snd '' K) with hL
  have : K ⊆ L := by
    rintro ⟨x, y⟩ hxy
    simp only [prod_mk_mem_set_prod_eq, mem_image, Prod.exists, exists_and_right, exists_eq_right]
    exact ⟨⟨y, hxy⟩, ⟨x, hxy⟩⟩
  apply lt_of_le_of_lt (measure_mono this)
  rw [hL, prod_prod]
  exact
    mul_lt_top (IsCompact.measure_lt_top (hK.image continuous_fst)).Ne
      (IsCompact.measure_lt_top (hK.image continuous_snd)).Ne

theorem ae_measure_lt_top {s : Set (α × β)} (hs : MeasurableSet s) (h2s : (μ.Prod ν) s ≠ ∞) :
    ∀ᵐ x ∂μ, ν (Prod.mk x ⁻¹' s) < ∞ := by simp_rw [prod_apply hs] at h2s;
  refine' ae_lt_top (measurable_measure_prod_mk_left hs) h2s
#align measure_theory.measure.ae_measure_lt_top MeasureTheory.Measure.ae_measure_lt_top

/-- Note: the assumption `hs` cannot be dropped. For a counterexample, see
  Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/
theorem measure_prod_null {s : Set (α × β)} (hs : MeasurableSet s) :
    μ.Prod ν s = 0 ↔ (fun x => ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by
  simp_rw [prod_apply hs, lintegral_eq_zero_iff (measurable_measure_prod_mk_left hs)]
#align measure_theory.measure.measure_prod_null MeasureTheory.Measure.measure_prod_null

/-- Note: the converse is not true without assuming that `s` is measurable. For a counterexample,
  see Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/
theorem measure_ae_null_of_prod_null {s : Set (α × β)} (h : μ.Prod ν s = 0) :
    (fun x => ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 :=
  by
  obtain ⟨t, hst, mt, ht⟩ := exists_measurable_superset_of_null h
  simp_rw [measure_prod_null mt] at ht
  rw [eventually_le_antisymm_iff]
  exact
    ⟨eventually_le.trans_eq (eventually_of_forall fun x => (measure_mono (preimage_mono hst) : _))
        ht,
      eventually_of_forall fun x => zero_le _⟩
#align measure_theory.measure.measure_ae_null_of_prod_null MeasureTheory.Measure.measure_ae_null_of_prod_null

theorem AbsolutelyContinuous.prod [SigmaFinite ν'] (h1 : μ ≪ μ') (h2 : ν ≪ ν') :
    μ.Prod ν ≪ μ'.Prod ν' :=
  by
  refine' absolutely_continuous.mk fun s hs h2s => _
  simp_rw [measure_prod_null hs] at h2s⊢
  exact (h2s.filter_mono h1.ae_le).mono fun _ h => h2 h
#align measure_theory.measure.absolutely_continuous.prod MeasureTheory.Measure.AbsolutelyContinuous.prod

/-- Note: the converse is not true. For a counterexample, see
  Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/
theorem ae_ae_of_ae_prod {p : α × β → Prop} (h : ∀ᵐ z ∂μ.Prod ν, p z) :
    ∀ᵐ x ∂μ, ∀ᵐ y ∂ν, p (x, y) :=
  measure_ae_null_of_prod_null h
#align measure_theory.measure.ae_ae_of_ae_prod MeasureTheory.Measure.ae_ae_of_ae_prod

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:228:8: unsupported: ambiguous notation -/
/-- `μ.prod ν` has finite spanning sets in rectangles of finite spanning sets. -/
noncomputable def FiniteSpanningSetsIn.prod {ν : Measure β} {C : Set (Set α)} {D : Set (Set β)}
    (hμ : μ.FiniteSpanningSetsIn C) (hν : ν.FiniteSpanningSetsIn D) :
    (μ.Prod ν).FiniteSpanningSetsIn (image2 (· ×ˢ ·) C D) :=
  by
  haveI := hν.sigma_finite
  refine'
    ⟨fun n => hμ.set n.unpair.1 ×ˢ hν.set n.unpair.2, fun n =>
      mem_image2_of_mem (hμ.set_mem _) (hν.set_mem _), fun n => _, _⟩
  · rw [prod_prod]
    exact mul_lt_top (hμ.finite _).Ne (hν.finite _).Ne
  · simp_rw [Union_unpair_prod, hμ.spanning, hν.spanning, univ_prod_univ]
#align measure_theory.measure.finite_spanning_sets_in.prod MeasureTheory.Measure.FiniteSpanningSetsIn.prod

theorem quasiMeasurePreserving_fst : QuasiMeasurePreserving Prod.fst (μ.Prod ν) μ :=
  by
  refine' ⟨measurable_fst, absolutely_continuous.mk fun s hs h2s => _⟩
  rw [map_apply measurable_fst hs, ← prod_univ, prod_prod, h2s, MulZeroClass.zero_mul]
#align measure_theory.measure.quasi_measure_preserving_fst MeasureTheory.Measure.quasiMeasurePreserving_fst

theorem quasiMeasurePreserving_snd : QuasiMeasurePreserving Prod.snd (μ.Prod ν) ν :=
  by
  refine' ⟨measurable_snd, absolutely_continuous.mk fun s hs h2s => _⟩
  rw [map_apply measurable_snd hs, ← univ_prod, prod_prod, h2s, MulZeroClass.mul_zero]
#align measure_theory.measure.quasi_measure_preserving_snd MeasureTheory.Measure.quasiMeasurePreserving_snd

variable [SigmaFinite μ]

instance prod.sigmaFinite : SigmaFinite (μ.Prod ν) :=
  (μ.toFiniteSpanningSetsIn.Prod ν.toFiniteSpanningSetsIn).SigmaFinite
#align measure_theory.measure.prod.sigma_finite MeasureTheory.Measure.prod.sigmaFinite

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/-- A measure on a product space equals the product measure if they are equal on rectangles
  with as sides sets that generate the corresponding σ-algebras. -/
theorem prod_eq_generateFrom {μ : Measure α} {ν : Measure β} {C : Set (Set α)} {D : Set (Set β)}
    (hC : generateFrom C = ‹_›) (hD : generateFrom D = ‹_›) (h2C : IsPiSystem C)
    (h2D : IsPiSystem D) (h3C : μ.FiniteSpanningSetsIn C) (h3D : ν.FiniteSpanningSetsIn D)
    {μν : Measure (α × β)} (h₁ : ∀ s ∈ C, ∀ t ∈ D, μν (s ×ˢ t) = μ s * ν t) : μ.Prod ν = μν :=
  by
  refine'
    (h3C.prod h3D).ext
      (generateFrom_eq_prod hC hD h3C.is_countably_spanning h3D.is_countably_spanning).symm
      (h2C.prod h2D) _
  · rintro _ ⟨s, t, hs, ht, rfl⟩; haveI := h3D.sigma_finite
    rw [h₁ s hs t ht, prod_prod]
#align measure_theory.measure.prod_eq_generate_from MeasureTheory.Measure.prod_eq_generateFrom

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/-- A measure on a product space equals the product measure if they are equal on rectangles. -/
theorem prod_eq {μν : Measure (α × β)}
    (h : ∀ s t, MeasurableSet s → MeasurableSet t → μν (s ×ˢ t) = μ s * ν t) : μ.Prod ν = μν :=
  prod_eq_generateFrom generateFrom_measurableSet generateFrom_measurableSet
    isPiSystem_measurableSet isPiSystem_measurableSet μ.toFiniteSpanningSetsIn
    ν.toFiniteSpanningSetsIn fun s hs t ht => h s t hs ht
#align measure_theory.measure.prod_eq MeasureTheory.Measure.prod_eq

theorem prod_swap : map Prod.swap (μ.Prod ν) = ν.Prod μ :=
  by
  refine' (prod_eq _).symm
  intro s t hs ht
  simp_rw [map_apply measurable_swap (hs.prod ht), preimage_swap_prod, prod_prod, mul_comm]
#align measure_theory.measure.prod_swap MeasureTheory.Measure.prod_swap

theorem measurePreserving_swap : MeasurePreserving Prod.swap (μ.Prod ν) (ν.Prod μ) :=
  ⟨measurable_swap, prod_swap⟩
#align measure_theory.measure.measure_preserving_swap MeasureTheory.Measure.measurePreserving_swap

theorem prod_apply_symm {s : Set (α × β)} (hs : MeasurableSet s) :
    μ.Prod ν s = ∫⁻ y, μ ((fun x => (x, y)) ⁻¹' s) ∂ν :=
  by
  rw [← prod_swap, map_apply measurable_swap hs]
  simp only [prod_apply (measurable_swap hs)]; rfl
#align measure_theory.measure.prod_apply_symm MeasureTheory.Measure.prod_apply_symm

theorem prodAssoc_prod [SigmaFinite τ] :
    map MeasurableEquiv.prodAssoc ((μ.Prod ν).Prod τ) = μ.Prod (ν.Prod τ) :=
  by
  refine'
    (prod_eq_generateFrom generate_from_measurable_set generateFrom_prod is_pi_system_measurable_set
        isPiSystem_prod μ.to_finite_spanning_sets_in
        (ν.to_finite_spanning_sets_in.prod τ.to_finite_spanning_sets_in) _).symm
  rintro s hs _ ⟨t, u, ht, hu, rfl⟩; rw [mem_set_of_eq] at hs ht hu
  simp_rw [map_apply (MeasurableEquiv.measurable _) (hs.prod (ht.prod hu)),
    MeasurableEquiv.prodAssoc, MeasurableEquiv.coe_mk, Equiv.prod_assoc_preimage, prod_prod,
    mul_assoc]
#align measure_theory.measure.prod_assoc_prod MeasureTheory.Measure.prodAssoc_prod

/-! ### The product of specific measures -/


/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem prod_restrict (s : Set α) (t : Set β) :
    (μ.restrict s).Prod (ν.restrict t) = (μ.Prod ν).restrict (s ×ˢ t) :=
  by
  refine' prod_eq fun s' t' hs' ht' => _
  rw [restrict_apply (hs'.prod ht'), prod_inter_prod, prod_prod, restrict_apply hs',
    restrict_apply ht']
#align measure_theory.measure.prod_restrict MeasureTheory.Measure.prod_restrict

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem restrict_prod_eq_prod_univ (s : Set α) :
    (μ.restrict s).Prod ν = (μ.Prod ν).restrict (s ×ˢ (univ : Set β)) :=
  by
  have : ν = ν.restrict Set.univ := measure.restrict_univ.symm
  rwa [this, measure.prod_restrict, ← this]
#align measure_theory.measure.restrict_prod_eq_prod_univ MeasureTheory.Measure.restrict_prod_eq_prod_univ

theorem prod_dirac (y : β) : μ.Prod (dirac y) = map (fun x => (x, y)) μ :=
  by
  refine' prod_eq fun s t hs ht => _
  simp_rw [map_apply measurable_prod_mk_right (hs.prod ht), mk_preimage_prod_left_eq_if, measure_if,
    dirac_apply' _ ht, ← indicator_mul_right _ fun x => μ s, Pi.one_apply, mul_one]
#align measure_theory.measure.prod_dirac MeasureTheory.Measure.prod_dirac

theorem dirac_prod (x : α) : (dirac x).Prod ν = map (Prod.mk x) ν :=
  by
  refine' prod_eq fun s t hs ht => _
  simp_rw [map_apply measurable_prod_mk_left (hs.prod ht), mk_preimage_prod_right_eq_if, measure_if,
    dirac_apply' _ hs, ← indicator_mul_left _ _ fun x => ν t, Pi.one_apply, one_mul]
#align measure_theory.measure.dirac_prod MeasureTheory.Measure.dirac_prod

theorem dirac_prod_dirac {x : α} {y : β} : (dirac x).Prod (dirac y) = dirac (x, y) := by
  rw [prod_dirac, map_dirac measurable_prod_mk_right]
#align measure_theory.measure.dirac_prod_dirac MeasureTheory.Measure.dirac_prod_dirac

theorem prod_sum {ι : Type _} [Finite ι] (ν : ι → Measure β) [∀ i, SigmaFinite (ν i)] :
    μ.Prod (sum ν) = sum fun i => μ.Prod (ν i) :=
  by
  refine' prod_eq fun s t hs ht => _
  simp_rw [sum_apply _ (hs.prod ht), sum_apply _ ht, prod_prod, ENNReal.tsum_mul_left]
#align measure_theory.measure.prod_sum MeasureTheory.Measure.prod_sum

theorem sum_prod {ι : Type _} [Finite ι] (μ : ι → Measure α) [∀ i, SigmaFinite (μ i)] :
    (sum μ).Prod ν = sum fun i => (μ i).Prod ν :=
  by
  refine' prod_eq fun s t hs ht => _
  simp_rw [sum_apply _ (hs.prod ht), sum_apply _ hs, prod_prod, ENNReal.tsum_mul_right]
#align measure_theory.measure.sum_prod MeasureTheory.Measure.sum_prod

theorem prod_add (ν' : Measure β) [SigmaFinite ν'] : μ.Prod (ν + ν') = μ.Prod ν + μ.Prod ν' := by
  refine' prod_eq fun s t hs ht => _; simp_rw [add_apply, prod_prod, left_distrib]
#align measure_theory.measure.prod_add MeasureTheory.Measure.prod_add

theorem add_prod (μ' : Measure α) [SigmaFinite μ'] : (μ + μ').Prod ν = μ.Prod ν + μ'.Prod ν := by
  refine' prod_eq fun s t hs ht => _; simp_rw [add_apply, prod_prod, right_distrib]
#align measure_theory.measure.add_prod MeasureTheory.Measure.add_prod

@[simp]
theorem zero_prod (ν : Measure β) : (0 : Measure α).Prod ν = 0 := by rw [measure.prod];
  exact bind_zero_left _
#align measure_theory.measure.zero_prod MeasureTheory.Measure.zero_prod

@[simp]
theorem prod_zero (μ : Measure α) : μ.Prod (0 : Measure β) = 0 := by simp [measure.prod]
#align measure_theory.measure.prod_zero MeasureTheory.Measure.prod_zero

theorem map_prod_map {δ} [MeasurableSpace δ] {f : α → β} {g : γ → δ} {μa : Measure α}
    {μc : Measure γ} (hfa : SigmaFinite (map f μa)) (hgc : SigmaFinite (map g μc))
    (hf : Measurable f) (hg : Measurable g) :
    (map f μa).Prod (map g μc) = map (Prod.map f g) (μa.Prod μc) :=
  by
  haveI := hgc.of_map μc hg.ae_measurable
  refine' prod_eq fun s t hs ht => _
  rw [map_apply (hf.prod_map hg) (hs.prod ht), map_apply hf hs, map_apply hg ht]
  exact prod_prod (f ⁻¹' s) (g ⁻¹' t)
#align measure_theory.measure.map_prod_map MeasureTheory.Measure.map_prod_map

end Measure

open Measure

namespace MeasurePreserving

variable {δ : Type _} [MeasurableSpace δ] {μa : Measure α} {μb : Measure β} {μc : Measure γ}
  {μd : Measure δ}

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem skew_product [SigmaFinite μb] [SigmaFinite μd] {f : α → β} (hf : MeasurePreserving f μa μb)
    {g : α → γ → δ} (hgm : Measurable (uncurry g)) (hg : ∀ᵐ x ∂μa, map (g x) μc = μd) :
    MeasurePreserving (fun p : α × γ => (f p.1, g p.1 p.2)) (μa.Prod μc) (μb.Prod μd) := by
  classical
    have : Measurable fun p : α × γ => (f p.1, g p.1 p.2) := (hf.1.comp measurable_fst).prod_mk hgm
    /- if `μa = 0`, then the lemma is trivial, otherwise we can use `hg`
      to deduce `sigma_finite μc`. -/
    rcases eq_or_ne μa 0 with (rfl | ha)
    · rw [← hf.map_eq, zero_prod, measure.map_zero, zero_prod]
      exact ⟨this, by simp only [measure.map_zero]⟩
    have : sigma_finite μc :=
      by
      rcases(ae_ne_bot.2 ha).nonempty_of_mem hg with ⟨x, hx : map (g x) μc = μd⟩
      exact sigma_finite.of_map _ hgm.of_uncurry_left.ae_measurable (by rwa [hx])
    -- Thus we can apply `measure.prod_eq` to prove equality of measures.
    refine' ⟨this, (prod_eq fun s t hs ht => _).symm⟩
    rw [map_apply this (hs.prod ht)]
    refine' (prod_apply (this <| hs.prod ht)).trans _
    have :
      ∀ᵐ x ∂μa, μc ((fun y => (f x, g x y)) ⁻¹' s ×ˢ t) = indicator (f ⁻¹' s) (fun y => μd t) x :=
      by
      refine' hg.mono fun x hx => _; subst hx
      simp only [mk_preimage_prod_right_fn_eq_if, indicator_apply, mem_preimage]
      split_ifs
      exacts[(map_apply hgm.of_uncurry_left ht).symm, measure_empty]
    simp only [preimage_preimage]
    rw [lintegral_congr_ae this, lintegral_indicator _ (hf.1 hs), set_lintegral_const,
      hf.measure_preimage hs, mul_comm]
#align measure_theory.measure_preserving.skew_product MeasureTheory.MeasurePreserving.skew_product

/-- If `f : α → β` sends the measure `μa` to `μb` and `g : γ → δ` sends the measure `μc` to `μd`,
then `prod.map f g` sends `μa.prod μc` to `μb.prod μd`. -/
protected theorem prod [SigmaFinite μb] [SigmaFinite μd] {f : α → β} {g : γ → δ}
    (hf : MeasurePreserving f μa μb) (hg : MeasurePreserving g μc μd) :
    MeasurePreserving (Prod.map f g) (μa.Prod μc) (μb.Prod μd) :=
  have : Measurable (uncurry fun _ : α => g) := hg.1.comp measurable_snd
  hf.skew_product this <| Filter.eventually_of_forall fun _ => hg.map_eq
#align measure_theory.measure_preserving.prod MeasureTheory.MeasurePreserving.prod

end MeasurePreserving

namespace QuasiMeasurePreserving

theorem prod_of_right {f : α × β → γ} {μ : Measure α} {ν : Measure β} {τ : Measure γ}
    (hf : Measurable f) [SigmaFinite ν]
    (h2f : ∀ᵐ x ∂μ, QuasiMeasurePreserving (fun y => f (x, y)) ν τ) :
    QuasiMeasurePreserving f (μ.Prod ν) τ :=
  by
  refine' ⟨hf, _⟩
  refine' absolutely_continuous.mk fun s hs h2s => _
  simp_rw [map_apply hf hs, prod_apply (hf hs), preimage_preimage,
    lintegral_congr_ae (h2f.mono fun x hx => hx.preimage_null h2s), lintegral_zero]
#align measure_theory.quasi_measure_preserving.prod_of_right MeasureTheory.QuasiMeasurePreserving.prod_of_right

theorem prod_of_left {α β γ} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]
    {f : α × β → γ} {μ : Measure α} {ν : Measure β} {τ : Measure γ} (hf : Measurable f)
    [SigmaFinite μ] [SigmaFinite ν]
    (h2f : ∀ᵐ y ∂ν, QuasiMeasurePreserving (fun x => f (x, y)) μ τ) :
    QuasiMeasurePreserving f (μ.Prod ν) τ :=
  by
  rw [← prod_swap]
  convert(quasi_measure_preserving.prod_of_right (hf.comp measurable_swap) h2f).comp
      ((measurable_swap.measure_preserving (ν.prod μ)).symm
          MeasurableEquiv.prodComm).QuasiMeasurePreserving
  ext ⟨x, y⟩; rfl
#align measure_theory.quasi_measure_preserving.prod_of_left MeasureTheory.QuasiMeasurePreserving.prod_of_left

end QuasiMeasurePreserving

end MeasureTheory

open MeasureTheory.Measure

section

theorem AEMeasurable.prod_swap [SigmaFinite μ] [SigmaFinite ν] {f : β × α → γ}
    (hf : AEMeasurable f (ν.Prod μ)) : AEMeasurable (fun z : α × β => f z.symm) (μ.Prod ν) := by
  rw [← prod_swap] at hf; exact hf.comp_measurable measurable_swap
#align ae_measurable.prod_swap AEMeasurable.prod_swap

theorem AEMeasurable.fst [SigmaFinite ν] {f : α → γ} (hf : AEMeasurable f μ) :
    AEMeasurable (fun z : α × β => f z.1) (μ.Prod ν) :=
  hf.comp_quasiMeasurePreserving quasiMeasurePreserving_fst
#align ae_measurable.fst AEMeasurable.fst

theorem AEMeasurable.snd [SigmaFinite ν] {f : β → γ} (hf : AEMeasurable f ν) :
    AEMeasurable (fun z : α × β => f z.2) (μ.Prod ν) :=
  hf.comp_quasiMeasurePreserving quasiMeasurePreserving_snd
#align ae_measurable.snd AEMeasurable.snd

end

namespace MeasureTheory

/-! ### The Lebesgue integral on a product -/


variable [SigmaFinite ν]

theorem lintegral_prod_swap [SigmaFinite μ] (f : α × β → ℝ≥0∞) (hf : AEMeasurable f (μ.Prod ν)) :
    (∫⁻ z, f z.symm ∂ν.Prod μ) = ∫⁻ z, f z ∂μ.Prod ν := by rw [← prod_swap] at hf;
  rw [← lintegral_map' hf measurable_swap.ae_measurable, prod_swap]
#align measure_theory.lintegral_prod_swap MeasureTheory.lintegral_prod_swap

/-- **Tonelli's Theorem**: For `ℝ≥0∞`-valued measurable functions on `α × β`,
  the integral of `f` is equal to the iterated integral. -/
theorem lintegral_prod_of_measurable :
    ∀ (f : α × β → ℝ≥0∞) (hf : Measurable f), (∫⁻ z, f z ∂μ.Prod ν) = ∫⁻ x, ∫⁻ y, f (x, y) ∂ν ∂μ :=
  by
  have m := @measurable_prod_mk_left
  refine' Measurable.ennreal_induction _ _ _
  · intro c s hs; simp only [← indicator_comp_right]
    simp [lintegral_indicator, m hs, hs, lintegral_const_mul, measurable_measure_prod_mk_left hs,
      prod_apply]
  · rintro f g - hf hg h2f h2g
    simp [lintegral_add_left, Measurable.lintegral_prod_right', hf.comp m, hf, h2f, h2g]
  · intro f hf h2f h3f
    have kf : ∀ x n, Measurable fun y => f n (x, y) := fun x n => (hf n).comp m
    have k2f : ∀ x, Monotone fun n y => f n (x, y) := fun x i j hij y => h2f hij (x, y)
    have lf : ∀ n, Measurable fun x => ∫⁻ y, f n (x, y) ∂ν := fun n => (hf n).lintegral_prod_right'
    have l2f : Monotone fun n x => ∫⁻ y, f n (x, y) ∂ν := fun i j hij x =>
      lintegral_mono (k2f x hij)
    simp only [lintegral_supr hf h2f, lintegral_supr (kf _), k2f, lintegral_supr lf l2f, h3f]
#align measure_theory.lintegral_prod_of_measurable MeasureTheory.lintegral_prod_of_measurable

/-- **Tonelli's Theorem**: For `ℝ≥0∞`-valued almost everywhere measurable functions on `α × β`,
  the integral of `f` is equal to the iterated integral. -/
theorem lintegral_prod (f : α × β → ℝ≥0∞) (hf : AEMeasurable f (μ.Prod ν)) :
    (∫⁻ z, f z ∂μ.Prod ν) = ∫⁻ x, ∫⁻ y, f (x, y) ∂ν ∂μ :=
  by
  have A : (∫⁻ z, f z ∂μ.prod ν) = ∫⁻ z, hf.mk f z ∂μ.prod ν := lintegral_congr_ae hf.ae_eq_mk
  have B : (∫⁻ x, ∫⁻ y, f (x, y) ∂ν ∂μ) = ∫⁻ x, ∫⁻ y, hf.mk f (x, y) ∂ν ∂μ :=
    by
    apply lintegral_congr_ae
    filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk]with _ ha using lintegral_congr_ae ha
  rw [A, B, lintegral_prod_of_measurable _ hf.measurable_mk]
  infer_instance
#align measure_theory.lintegral_prod MeasureTheory.lintegral_prod

/-- The symmetric verion of Tonelli's Theorem: For `ℝ≥0∞`-valued almost everywhere measurable
functions on `α × β`,  the integral of `f` is equal to the iterated integral, in reverse order. -/
theorem lintegral_prod_symm [SigmaFinite μ] (f : α × β → ℝ≥0∞) (hf : AEMeasurable f (μ.Prod ν)) :
    (∫⁻ z, f z ∂μ.Prod ν) = ∫⁻ y, ∫⁻ x, f (x, y) ∂μ ∂ν := by simp_rw [← lintegral_prod_swap f hf];
  exact lintegral_prod _ hf.prod_swap
#align measure_theory.lintegral_prod_symm MeasureTheory.lintegral_prod_symm

/-- The symmetric verion of Tonelli's Theorem: For `ℝ≥0∞`-valued measurable
functions on `α × β`,  the integral of `f` is equal to the iterated integral, in reverse order. -/
theorem lintegral_prod_symm' [SigmaFinite μ] (f : α × β → ℝ≥0∞) (hf : Measurable f) :
    (∫⁻ z, f z ∂μ.Prod ν) = ∫⁻ y, ∫⁻ x, f (x, y) ∂μ ∂ν :=
  lintegral_prod_symm f hf.AEMeasurable
#align measure_theory.lintegral_prod_symm' MeasureTheory.lintegral_prod_symm'

/-- The reversed version of **Tonelli's Theorem**. In this version `f` is in curried form, which
makes it easier for the elaborator to figure out `f` automatically. -/
theorem lintegral_lintegral ⦃f : α → β → ℝ≥0∞⦄ (hf : AEMeasurable (uncurry f) (μ.Prod ν)) :
    (∫⁻ x, ∫⁻ y, f x y ∂ν ∂μ) = ∫⁻ z, f z.1 z.2 ∂μ.Prod ν :=
  (lintegral_prod _ hf).symm
#align measure_theory.lintegral_lintegral MeasureTheory.lintegral_lintegral

/-- The reversed version of **Tonelli's Theorem** (symmetric version). In this version `f` is in
curried form, which makes it easier for the elaborator to figure out `f` automatically. -/
theorem lintegral_lintegral_symm [SigmaFinite μ] ⦃f : α → β → ℝ≥0∞⦄
    (hf : AEMeasurable (uncurry f) (μ.Prod ν)) :
    (∫⁻ x, ∫⁻ y, f x y ∂ν ∂μ) = ∫⁻ z, f z.2 z.1 ∂ν.Prod μ :=
  (lintegral_prod_symm _ hf.prod_swap).symm
#align measure_theory.lintegral_lintegral_symm MeasureTheory.lintegral_lintegral_symm

/-- Change the order of Lebesgue integration. -/
theorem lintegral_lintegral_swap [SigmaFinite μ] ⦃f : α → β → ℝ≥0∞⦄
    (hf : AEMeasurable (uncurry f) (μ.Prod ν)) :
    (∫⁻ x, ∫⁻ y, f x y ∂ν ∂μ) = ∫⁻ y, ∫⁻ x, f x y ∂μ ∂ν :=
  (lintegral_lintegral hf).trans (lintegral_prod_symm _ hf)
#align measure_theory.lintegral_lintegral_swap MeasureTheory.lintegral_lintegral_swap

theorem lintegral_prod_mul {f : α → ℝ≥0∞} {g : β → ℝ≥0∞} (hf : AEMeasurable f μ)
    (hg : AEMeasurable g ν) : (∫⁻ z, f z.1 * g z.2 ∂μ.Prod ν) = (∫⁻ x, f x ∂μ) * ∫⁻ y, g y ∂ν := by
  simp [lintegral_prod _ (hf.fst.mul hg.snd), lintegral_lintegral_mul hf hg]
#align measure_theory.lintegral_prod_mul MeasureTheory.lintegral_prod_mul

/-! ### Marginals of a measure defined on a product -/


namespace Measure

variable {ρ : Measure (α × β)}

/-- Marginal measure on `α` obtained from a measure `ρ` on `α × β`, defined by `ρ.map prod.fst`. -/
noncomputable def fst (ρ : Measure (α × β)) : Measure α :=
  ρ.map Prod.fst
#align measure_theory.measure.fst MeasureTheory.Measure.fst

theorem fst_apply {s : Set α} (hs : MeasurableSet s) : ρ.fst s = ρ (Prod.fst ⁻¹' s) := by
  rw [fst, measure.map_apply measurable_fst hs]
#align measure_theory.measure.fst_apply MeasureTheory.Measure.fst_apply

theorem fst_univ : ρ.fst univ = ρ univ := by rw [fst_apply MeasurableSet.univ, preimage_univ]
#align measure_theory.measure.fst_univ MeasureTheory.Measure.fst_univ

instance [FiniteMeasure ρ] : FiniteMeasure ρ.fst := by rw [fst]; infer_instance

instance [ProbabilityMeasure ρ] : ProbabilityMeasure ρ.fst
    where measure_univ := by rw [fst_univ]; exact measure_univ

/-- Marginal measure on `β` obtained from a measure on `ρ` `α × β`, defined by `ρ.map prod.snd`. -/
noncomputable def snd (ρ : Measure (α × β)) : Measure β :=
  ρ.map Prod.snd
#align measure_theory.measure.snd MeasureTheory.Measure.snd

theorem snd_apply {s : Set β} (hs : MeasurableSet s) : ρ.snd s = ρ (Prod.snd ⁻¹' s) := by
  rw [snd, measure.map_apply measurable_snd hs]
#align measure_theory.measure.snd_apply MeasureTheory.Measure.snd_apply

theorem snd_univ : ρ.snd univ = ρ univ := by rw [snd_apply MeasurableSet.univ, preimage_univ]
#align measure_theory.measure.snd_univ MeasureTheory.Measure.snd_univ

instance [FiniteMeasure ρ] : FiniteMeasure ρ.snd := by rw [snd]; infer_instance

instance [ProbabilityMeasure ρ] : ProbabilityMeasure ρ.snd
    where measure_univ := by rw [snd_univ]; exact measure_univ

end Measure

end MeasureTheory

