/-
Copyright (c) 2020 Floris van Doorn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Floris van Doorn
-/
import Mathlib.MeasureTheory.Measure.GiryMonad
import Mathlib.Dynamics.Ergodic.MeasurePreserving
import Mathlib.MeasureTheory.Integral.Lebesgue
import Mathlib.MeasureTheory.Measure.OpenPos

#align_import measure_theory.constructions.prod.basic from "leanprover-community/mathlib"@"00abe0695d8767201e6d008afa22393978bb324d"

/-!
# The product measure

In this file we define and prove properties about the binary product measure. If `Î±` and `Î²` have
Ïƒ-finite measures `Î¼` resp. `Î½` then `Î± Ã— Î²` can be equipped with a Ïƒ-finite measure `Î¼.prod Î½` that
satisfies `(Î¼.prod Î½) s = âˆ«â» x, Î½ {y | (x, y) âˆˆ s} âˆ‚Î¼`.
We also have `(Î¼.prod Î½) (s Ã—Ë¢ t) = Î¼ s * Î½ t`, i.e. the measure of a rectangle is the product of
the measures of the sides.

We also prove Tonelli's theorem.

## Main definition

* `MeasureTheory.Measure.prod`: The product of two measures.

## Main results

* `MeasureTheory.Measure.prod_apply` states `Î¼.prod Î½ s = âˆ«â» x, Î½ {y | (x, y) âˆˆ s} âˆ‚Î¼`
  for measurable `s`. `MeasureTheory.Measure.prod_apply_symm` is the reversed version.
* `MeasureTheory.Measure.prod_prod` states `Î¼.prod Î½ (s Ã—Ë¢ t) = Î¼ s * Î½ t` for measurable sets
  `s` and `t`.
* `MeasureTheory.lintegral_prod`: Tonelli's theorem. It states that for a measurable function
  `Î± Ã— Î² â†’ â„â‰¥0âˆ` we have `âˆ«â» z, f z âˆ‚(Î¼.prod Î½) = âˆ«â» x, âˆ«â» y, f (x, y) âˆ‚Î½ âˆ‚Î¼`. The version
  for functions `Î± â†’ Î² â†’ â„â‰¥0âˆ` is reversed, and called `lintegral_lintegral`. Both versions have
  a variant with `_symm` appended, where the order of integration is reversed.
  The lemma `Measurable.lintegral_prod_right'` states that the inner integral of the right-hand side
  is measurable.

## Implementation Notes

Many results are proven twice, once for functions in curried form (`Î± â†’ Î² â†’ Î³`) and one for
functions in uncurried form (`Î± Ã— Î² â†’ Î³`). The former often has an assumption
`Measurable (uncurry f)`, which could be inconvenient to discharge, but for the latter it is more
common that the function has to be given explicitly, since Lean cannot synthesize the function by
itself. We name the lemmas about the uncurried form with a prime.
Tonelli's theorem has a different naming scheme, since the version for the uncurried version is
reversed.

## Tags

product measure, Tonelli's theorem, Fubini-Tonelli theorem
-/


noncomputable section

open Classical Topology ENNReal MeasureTheory

open Set Function Real ENNReal

open MeasureTheory MeasurableSpace MeasureTheory.Measure

open TopologicalSpace hiding generateFrom

open Filter hiding prod_eq map

variable {Î± Î±' Î² Î²' Î³ E : Type*}

/-- Rectangles formed by Ï€-systems form a Ï€-system. -/
theorem IsPiSystem.prod {C : Set (Set Î±)} {D : Set (Set Î²)} (hC : IsPiSystem C)
    (hD : IsPiSystem D) : IsPiSystem (image2 (Â· Ã—Ë¢ Â·) C D) := by
  rintro _ âŸ¨sâ‚, tâ‚, hsâ‚, htâ‚, rflâŸ© _ âŸ¨sâ‚‚, tâ‚‚, hsâ‚‚, htâ‚‚, rflâŸ© hst
  -- âŠ¢ (fun x x_1 => x Ã—Ë¢ x_1) sâ‚ tâ‚ âˆ© (fun x x_1 => x Ã—Ë¢ x_1) sâ‚‚ tâ‚‚ âˆˆ image2 (fun  â€¦
  rw [prod_inter_prod] at hst âŠ¢; rw [prod_nonempty_iff] at hst
  -- âŠ¢ (sâ‚ âˆ© sâ‚‚) Ã—Ë¢ (tâ‚ âˆ© tâ‚‚) âˆˆ image2 (fun x x_1 => x Ã—Ë¢ x_1) C D
                                 -- âŠ¢ (sâ‚ âˆ© sâ‚‚) Ã—Ë¢ (tâ‚ âˆ© tâ‚‚) âˆˆ image2 (fun x x_1 => x Ã—Ë¢ x_1) C D
  exact mem_image2_of_mem (hC _ hsâ‚ _ hsâ‚‚ hst.1) (hD _ htâ‚ _ htâ‚‚ hst.2)
  -- ğŸ‰ no goals
#align is_pi_system.prod IsPiSystem.prod

/-- Rectangles of countably spanning sets are countably spanning. -/
theorem IsCountablySpanning.prod {C : Set (Set Î±)} {D : Set (Set Î²)} (hC : IsCountablySpanning C)
    (hD : IsCountablySpanning D) : IsCountablySpanning (image2 (Â· Ã—Ë¢ Â·) C D) := by
  rcases hC, hD with âŸ¨âŸ¨s, h1s, h2sâŸ©, t, h1t, h2tâŸ©
  -- âŠ¢ IsCountablySpanning (image2 (fun x x_1 => x Ã—Ë¢ x_1) C D)
  refine' âŸ¨fun n => s n.unpair.1 Ã—Ë¢ t n.unpair.2, fun n => mem_image2_of_mem (h1s _) (h1t _), _âŸ©
  -- âŠ¢ â‹ƒ (n : â„•), (fun n => s (Nat.unpair n).fst Ã—Ë¢ t (Nat.unpair n).snd) n = univ
  rw [iUnion_unpair_prod, h2s, h2t, univ_prod_univ]
  -- ğŸ‰ no goals
#align is_countably_spanning.prod IsCountablySpanning.prod

variable [MeasurableSpace Î±] [MeasurableSpace Î±'] [MeasurableSpace Î²] [MeasurableSpace Î²']

variable [MeasurableSpace Î³]

variable {Î¼ Î¼' : Measure Î±} {Î½ Î½' : Measure Î²} {Ï„ : Measure Î³}

variable [NormedAddCommGroup E]

/-! ### Measurability

Before we define the product measure, we can talk about the measurability of operations on binary
functions. We show that if `f` is a binary measurable function, then the function that integrates
along one of the variables (using either the Lebesgue or Bochner integral) is measurable.
-/


/-- The product of generated Ïƒ-algebras is the one generated by rectangles, if both generating sets
  are countably spanning. -/
theorem generateFrom_prod_eq {Î± Î²} {C : Set (Set Î±)} {D : Set (Set Î²)} (hC : IsCountablySpanning C)
    (hD : IsCountablySpanning D) :
    @Prod.instMeasurableSpace _ _ (generateFrom C) (generateFrom D) =
      generateFrom (image2 (Â· Ã—Ë¢ Â·) C D) := by
  apply le_antisymm
  -- âŠ¢ Prod.instMeasurableSpace â‰¤ generateFrom (image2 (fun x x_1 => x Ã—Ë¢ x_1) C D)
  Â· refine' sup_le _ _ <;> rw [comap_generateFrom] <;> apply generateFrom_le <;>
    -- âŠ¢ MeasurableSpace.comap Prod.fst (generateFrom C) â‰¤ generateFrom (image2 (fun  â€¦
                           -- âŠ¢ generateFrom (preimage Prod.fst '' C) â‰¤ generateFrom (image2 (fun x x_1 => x â€¦
                           -- âŠ¢ generateFrom (preimage Prod.snd '' D) â‰¤ generateFrom (image2 (fun x x_1 => x â€¦
                                                       -- âŠ¢ âˆ€ (t : Set (Î± Ã— Î²)), t âˆˆ preimage Prod.fst '' C â†’ MeasurableSet t
                                                       -- âŠ¢ âˆ€ (t : Set (Î± Ã— Î²)), t âˆˆ preimage Prod.snd '' D â†’ MeasurableSet t
      rintro _ âŸ¨s, hs, rflâŸ©
      -- âŠ¢ MeasurableSet (Prod.fst â»Â¹' s)
      -- âŠ¢ MeasurableSet (Prod.snd â»Â¹' s)
    Â· rcases hD with âŸ¨t, h1t, h2tâŸ©
      -- âŠ¢ MeasurableSet (Prod.fst â»Â¹' s)
      rw [â† prod_univ, â† h2t, prod_iUnion]
      -- âŠ¢ MeasurableSet (â‹ƒ (i : â„•), s Ã—Ë¢ t i)
      apply MeasurableSet.iUnion
      -- âŠ¢ âˆ€ (b : â„•), MeasurableSet (s Ã—Ë¢ t b)
      intro n
      -- âŠ¢ MeasurableSet (s Ã—Ë¢ t n)
      apply measurableSet_generateFrom
      -- âŠ¢ s Ã—Ë¢ t n âˆˆ image2 (fun x x_1 => x Ã—Ë¢ x_1) C D
      exact âŸ¨s, t n, hs, h1t n, rflâŸ©
      -- ğŸ‰ no goals
    Â· rcases hC with âŸ¨t, h1t, h2tâŸ©
      -- âŠ¢ MeasurableSet (Prod.snd â»Â¹' s)
      rw [â† univ_prod, â† h2t, iUnion_prod_const]
      -- âŠ¢ MeasurableSet (â‹ƒ (i : â„•), t i Ã—Ë¢ s)
      apply MeasurableSet.iUnion
      -- âŠ¢ âˆ€ (b : â„•), MeasurableSet (t b Ã—Ë¢ s)
      rintro n
      -- âŠ¢ MeasurableSet (t n Ã—Ë¢ s)
      apply measurableSet_generateFrom
      -- âŠ¢ t n Ã—Ë¢ s âˆˆ image2 (fun x x_1 => x Ã—Ë¢ x_1) C D
      exact mem_image2_of_mem (h1t n) hs
      -- ğŸ‰ no goals
  Â· apply generateFrom_le
    -- âŠ¢ âˆ€ (t : Set (Î± Ã— Î²)), t âˆˆ image2 (fun x x_1 => x Ã—Ë¢ x_1) C D â†’ MeasurableSet t
    rintro _ âŸ¨s, t, hs, ht, rflâŸ©
    -- âŠ¢ MeasurableSet ((fun x x_1 => x Ã—Ë¢ x_1) s t)
    dsimp only
    -- âŠ¢ MeasurableSet (s Ã—Ë¢ t)
    rw [prod_eq]
    -- âŠ¢ MeasurableSet (Prod.fst â»Â¹' s âˆ© Prod.snd â»Â¹' t)
    apply (measurable_fst _).inter (measurable_snd _)
    -- âŠ¢ MeasurableSet s
    Â· exact measurableSet_generateFrom hs
      -- ğŸ‰ no goals
    Â· exact measurableSet_generateFrom ht
      -- ğŸ‰ no goals
#align generate_from_prod_eq generateFrom_prod_eq

/-- If `C` and `D` generate the Ïƒ-algebras on `Î±` resp. `Î²`, then rectangles formed by `C` and `D`
  generate the Ïƒ-algebra on `Î± Ã— Î²`. -/
theorem generateFrom_eq_prod {C : Set (Set Î±)} {D : Set (Set Î²)} (hC : generateFrom C = â€¹_â€º)
    (hD : generateFrom D = â€¹_â€º) (h2C : IsCountablySpanning C) (h2D : IsCountablySpanning D) :
    generateFrom (image2 (Â· Ã—Ë¢ Â·) C D) = Prod.instMeasurableSpace := by
  rw [â† hC, â† hD, generateFrom_prod_eq h2C h2D]
  -- ğŸ‰ no goals
#align generate_from_eq_prod generateFrom_eq_prod

/-- The product Ïƒ-algebra is generated from boxes, i.e. `s Ã—Ë¢ t` for sets `s : Set Î±` and
  `t : Set Î²`. -/
theorem generateFrom_prod :
    generateFrom (image2 (Â· Ã—Ë¢ Â·) { s : Set Î± | MeasurableSet s } { t : Set Î² | MeasurableSet t }) =
      Prod.instMeasurableSpace :=
  generateFrom_eq_prod generateFrom_measurableSet generateFrom_measurableSet
    isCountablySpanning_measurableSet isCountablySpanning_measurableSet
#align generate_from_prod generateFrom_prod

/-- Rectangles form a Ï€-system. -/
theorem isPiSystem_prod :
    IsPiSystem (image2 (Â· Ã—Ë¢ Â·) { s : Set Î± | MeasurableSet s } { t : Set Î² | MeasurableSet t }) :=
  isPiSystem_measurableSet.prod isPiSystem_measurableSet
#align is_pi_system_prod isPiSystem_prod

/-- If `Î½` is a finite measure, and `s âŠ† Î± Ã— Î²` is measurable, then `x â†¦ Î½ { y | (x, y) âˆˆ s }` is
  a measurable function. `measurable_measure_prod_mk_left` is strictly more general. -/
theorem measurable_measure_prod_mk_left_finite [IsFiniteMeasure Î½] {s : Set (Î± Ã— Î²)}
    (hs : MeasurableSet s) : Measurable fun x => Î½ (Prod.mk x â»Â¹' s) := by
  refine' induction_on_inter (C := fun s => Measurable fun x => Î½ (Prod.mk x â»Â¹' s))
    generateFrom_prod.symm isPiSystem_prod _ _ _ _ hs
  Â· simp [measurable_zero, const_def]
    -- ğŸ‰ no goals
  Â· rintro _ âŸ¨s, t, hs, _, rflâŸ©
    -- âŠ¢ Measurable fun x => â†‘â†‘Î½ (Prod.mk x â»Â¹' (fun x x_1 => x Ã—Ë¢ x_1) s t)
    simp only [mk_preimage_prod_right_eq_if, measure_if]
    -- âŠ¢ Measurable fun x => indicator s (fun x => â†‘â†‘Î½ t) x
    exact measurable_const.indicator hs
    -- ğŸ‰ no goals
  Â· intro t ht h2t
    -- âŠ¢ Measurable fun x => â†‘â†‘Î½ (Prod.mk x â»Â¹' tá¶œ)
    simp_rw [preimage_compl, measure_compl (measurable_prod_mk_left ht) (measure_ne_top Î½ _)]
    -- âŠ¢ Measurable fun x => â†‘â†‘Î½ univ - â†‘â†‘Î½ (Prod.mk x â»Â¹' t)
    exact h2t.const_sub _
    -- ğŸ‰ no goals
  Â· intro f h1f h2f h3f
    -- âŠ¢ Measurable fun x => â†‘â†‘Î½ (Prod.mk x â»Â¹' â‹ƒ (i : â„•), f i)
    simp_rw [preimage_iUnion]
    -- âŠ¢ Measurable fun x => â†‘â†‘Î½ (â‹ƒ (i : â„•), Prod.mk x â»Â¹' f i)
    have : âˆ€ b, Î½ (â‹ƒ i, Prod.mk b â»Â¹' f i) = âˆ‘' i, Î½ (Prod.mk b â»Â¹' f i) := fun b =>
      measure_iUnion (fun i j hij => Disjoint.preimage _ (h1f hij)) fun i =>
        measurable_prod_mk_left (h2f i)
    simp_rw [this]
    -- âŠ¢ Measurable fun x => âˆ‘' (i : â„•), â†‘â†‘Î½ (Prod.mk x â»Â¹' f i)
    apply Measurable.ennreal_tsum h3f
    -- ğŸ‰ no goals
#align measurable_measure_prod_mk_left_finite measurable_measure_prod_mk_left_finite

/-- If `Î½` is a Ïƒ-finite measure, and `s âŠ† Î± Ã— Î²` is measurable, then `x â†¦ Î½ { y | (x, y) âˆˆ s }` is
  a measurable function. -/
theorem measurable_measure_prod_mk_left [SigmaFinite Î½] {s : Set (Î± Ã— Î²)} (hs : MeasurableSet s) :
    Measurable fun x => Î½ (Prod.mk x â»Â¹' s) := by
  have : âˆ€ x, MeasurableSet (Prod.mk x â»Â¹' s) := fun x => measurable_prod_mk_left hs
  -- âŠ¢ Measurable fun x => â†‘â†‘Î½ (Prod.mk x â»Â¹' s)
  simp only [â† @iSup_restrict_spanningSets _ _ Î½, this]
  -- âŠ¢ Measurable fun x => â¨† (i : â„•), â†‘â†‘(Measure.restrict Î½ (spanningSets Î½ i)) (Pr â€¦
  apply measurable_iSup; intro i
  -- âŠ¢ âˆ€ (i : â„•), Measurable fun b => â†‘â†‘(Measure.restrict Î½ (spanningSets Î½ i)) (Pr â€¦
                         -- âŠ¢ Measurable fun b => â†‘â†‘(Measure.restrict Î½ (spanningSets Î½ i)) (Prod.mk b â»Â¹' â€¦
  haveI := Fact.mk (measure_spanningSets_lt_top Î½ i)
  -- âŠ¢ Measurable fun b => â†‘â†‘(Measure.restrict Î½ (spanningSets Î½ i)) (Prod.mk b â»Â¹' â€¦
  exact measurable_measure_prod_mk_left_finite hs
  -- ğŸ‰ no goals
#align measurable_measure_prod_mk_left measurable_measure_prod_mk_left

/-- If `Î¼` is a Ïƒ-finite measure, and `s âŠ† Î± Ã— Î²` is measurable, then `y â†¦ Î¼ { x | (x, y) âˆˆ s }` is
  a measurable function. -/
theorem measurable_measure_prod_mk_right {Î¼ : Measure Î±} [SigmaFinite Î¼] {s : Set (Î± Ã— Î²)}
    (hs : MeasurableSet s) : Measurable fun y => Î¼ ((fun x => (x, y)) â»Â¹' s) :=
  measurable_measure_prod_mk_left (measurableSet_swap_iff.mpr hs)
#align measurable_measure_prod_mk_right measurable_measure_prod_mk_right

theorem Measurable.map_prod_mk_left [SigmaFinite Î½] :
    Measurable fun x : Î± => map (Prod.mk x) Î½ := by
  apply measurable_of_measurable_coe; intro s hs
  -- âŠ¢ âˆ€ (s : Set (Î± Ã— Î²)), MeasurableSet s â†’ Measurable fun b => â†‘â†‘(map (Prod.mk b â€¦
                                      -- âŠ¢ Measurable fun b => â†‘â†‘(map (Prod.mk b) Î½) s
  simp_rw [map_apply measurable_prod_mk_left hs]
  -- âŠ¢ Measurable fun b => â†‘â†‘Î½ (Prod.mk b â»Â¹' s)
  exact measurable_measure_prod_mk_left hs
  -- ğŸ‰ no goals
#align measurable.map_prod_mk_left Measurable.map_prod_mk_left

theorem Measurable.map_prod_mk_right {Î¼ : Measure Î±} [SigmaFinite Î¼] :
    Measurable fun y : Î² => map (fun x : Î± => (x, y)) Î¼ := by
  apply measurable_of_measurable_coe; intro s hs
  -- âŠ¢ âˆ€ (s : Set (Î± Ã— Î²)), MeasurableSet s â†’ Measurable fun b => â†‘â†‘(map (fun x =>  â€¦
                                      -- âŠ¢ Measurable fun b => â†‘â†‘(map (fun x => (x, b)) Î¼) s
  simp_rw [map_apply measurable_prod_mk_right hs]
  -- âŠ¢ Measurable fun b => â†‘â†‘Î¼ ((fun x => (x, b)) â»Â¹' s)
  exact measurable_measure_prod_mk_right hs
  -- ğŸ‰ no goals
#align measurable.map_prod_mk_right Measurable.map_prod_mk_right

theorem MeasurableEmbedding.prod_mk {Î± Î² Î³ Î´ : Type*} {mÎ± : MeasurableSpace Î±}
    {mÎ² : MeasurableSpace Î²} {mÎ³ : MeasurableSpace Î³} {mÎ´ : MeasurableSpace Î´} {f : Î± â†’ Î²}
    {g : Î³ â†’ Î´} (hg : MeasurableEmbedding g) (hf : MeasurableEmbedding f) :
    MeasurableEmbedding fun x : Î³ Ã— Î± => (g x.1, f x.2) := by
  have h_inj : Function.Injective fun x : Î³ Ã— Î± => (g x.fst, f x.snd) := by
    intro x y hxy
    rw [â† @Prod.mk.eta _ _ x, â† @Prod.mk.eta _ _ y]
    simp only [Prod.mk.inj_iff] at hxy âŠ¢
    exact âŸ¨hg.injective hxy.1, hf.injective hxy.2âŸ©
  refine' âŸ¨h_inj, _, _âŸ©
  -- âŠ¢ Measurable fun x => (g x.fst, f x.snd)
  Â· exact (hg.measurable.comp measurable_fst).prod_mk (hf.measurable.comp measurable_snd)
    -- ğŸ‰ no goals
  Â· -- Induction using the Ï€-system of rectangles
    refine' fun s hs =>
      @MeasurableSpace.induction_on_inter _
        (fun s => MeasurableSet ((fun x : Î³ Ã— Î± => (g x.fst, f x.snd)) '' s)) _ _
        generateFrom_prod.symm isPiSystem_prod _ _ _ _ _ hs
    Â· simp only [Set.image_empty, MeasurableSet.empty]
      -- ğŸ‰ no goals
    Â· rintro t âŸ¨tâ‚, tâ‚‚, htâ‚, htâ‚‚, rflâŸ©
      -- âŠ¢ MeasurableSet ((fun x => (g x.fst, f x.snd)) '' (fun x x_1 => x Ã—Ë¢ x_1) tâ‚ tâ‚‚)
      rw [â† Set.prod_image_image_eq]
      -- âŠ¢ MeasurableSet ((g '' tâ‚) Ã—Ë¢ (f '' tâ‚‚))
      exact (hg.measurableSet_image.mpr htâ‚).prod (hf.measurableSet_image.mpr htâ‚‚)
      -- ğŸ‰ no goals
    Â· intro t _ ht_m
      -- âŠ¢ MeasurableSet ((fun x => (g x.fst, f x.snd)) '' tá¶œ)
      rw [â† Set.range_diff_image h_inj, â† Set.prod_range_range_eq]
      -- âŠ¢ MeasurableSet (range g Ã—Ë¢ range f \ (fun x => (g x.fst, f x.snd)) '' t)
      exact
        MeasurableSet.diff (MeasurableSet.prod hg.measurableSet_range hf.measurableSet_range) ht_m
    Â· intro g _ _ hg
      -- âŠ¢ MeasurableSet ((fun x => (gâœ x.fst, f x.snd)) '' â‹ƒ (i : â„•), g i)
      simp_rw [Set.image_iUnion]
      -- âŠ¢ MeasurableSet (â‹ƒ (i : â„•), (fun x => (gâœ x.fst, f x.snd)) '' g i)
      exact MeasurableSet.iUnion hg
      -- ğŸ‰ no goals
#align measurable_embedding.prod_mk MeasurableEmbedding.prod_mk

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  Tonelli's theorem is measurable. -/
theorem Measurable.lintegral_prod_right' [SigmaFinite Î½] :
    âˆ€ {f : Î± Ã— Î² â†’ â„â‰¥0âˆ}, Measurable f â†’ Measurable fun x => âˆ«â» y, f (x, y) âˆ‚Î½ := by
  have m := @measurable_prod_mk_left
  -- âŠ¢ âˆ€ {f : Î± Ã— Î² â†’ â„â‰¥0âˆ}, Measurable f â†’ Measurable fun x => âˆ«â» (y : Î²), f (x, y â€¦
  refine' Measurable.ennreal_induction (P := fun f => Measurable fun (x : Î±) => âˆ«â» y, f (x, y) âˆ‚Î½)
    _ _ _
  Â· intro c s hs
    -- âŠ¢ Measurable fun x => âˆ«â» (y : Î²), Set.indicator s (fun x => c) (x, y) âˆ‚Î½
    simp only [â† indicator_comp_right]
    -- âŠ¢ Measurable fun x => âˆ«â» (y : Î²), Set.indicator (Prod.mk x â»Â¹' s) ((fun x => c â€¦
    suffices Measurable fun x => c * Î½ (Prod.mk x â»Â¹' s) by simpa [lintegral_indicator _ (m hs)]
    -- âŠ¢ Measurable fun x => c * â†‘â†‘Î½ (Prod.mk x â»Â¹' s)
    exact (measurable_measure_prod_mk_left hs).const_mul _
    -- ğŸ‰ no goals
  Â· rintro f g - hf - h2f h2g
    -- âŠ¢ Measurable fun x => âˆ«â» (y : Î²), (f + g) (x, y) âˆ‚Î½
    simp only [Pi.add_apply]
    -- âŠ¢ Measurable fun x => âˆ«â» (y : Î²), f (x, y) + g (x, y) âˆ‚Î½
    conv => enter [1, x]; erw [lintegral_add_left (hf.comp m)]
    -- âŠ¢ Measurable fun x => âˆ«â» (a : Î²), (f âˆ˜ Prod.mk x) a âˆ‚Î½ + âˆ«â» (a : Î²), g (x, a) âˆ‚Î½
    exact h2f.add h2g
    -- ğŸ‰ no goals
  Â· intro f hf h2f h3f
    -- âŠ¢ Measurable fun x => âˆ«â» (y : Î²), (fun x => â¨† (n : â„•), f n x) (x, y) âˆ‚Î½
    have := measurable_iSup h3f
    -- âŠ¢ Measurable fun x => âˆ«â» (y : Î²), (fun x => â¨† (n : â„•), f n x) (x, y) âˆ‚Î½
    have : âˆ€ x, Monotone fun n y => f n (x, y) := fun x i j hij y => h2f hij (x, y)
    -- âŠ¢ Measurable fun x => âˆ«â» (y : Î²), (fun x => â¨† (n : â„•), f n x) (x, y) âˆ‚Î½
    conv => enter [1, x]; erw [lintegral_iSup (fun n => (hf n).comp m) (this x)]
    -- âŠ¢ Measurable fun x => â¨† (n : â„•), âˆ«â» (a : Î²), (f n âˆ˜ Prod.mk x) a âˆ‚Î½
    assumption
    -- ğŸ‰ no goals
#align measurable.lintegral_prod_right' Measurable.lintegral_prod_right'

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  Tonelli's theorem is measurable.
  This version has the argument `f` in curried form. -/
theorem Measurable.lintegral_prod_right [SigmaFinite Î½] {f : Î± â†’ Î² â†’ â„â‰¥0âˆ}
    (hf : Measurable (uncurry f)) : Measurable fun x => âˆ«â» y, f x y âˆ‚Î½ :=
  hf.lintegral_prod_right'
#align measurable.lintegral_prod_right Measurable.lintegral_prod_right

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  the symmetric version of Tonelli's theorem is measurable. -/
theorem Measurable.lintegral_prod_left' [SigmaFinite Î¼] {f : Î± Ã— Î² â†’ â„â‰¥0âˆ} (hf : Measurable f) :
    Measurable fun y => âˆ«â» x, f (x, y) âˆ‚Î¼ :=
  (measurable_swap_iff.mpr hf).lintegral_prod_right'
#align measurable.lintegral_prod_left' Measurable.lintegral_prod_left'

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  the symmetric version of Tonelli's theorem is measurable.
  This version has the argument `f` in curried form. -/
theorem Measurable.lintegral_prod_left [SigmaFinite Î¼] {f : Î± â†’ Î² â†’ â„â‰¥0âˆ}
    (hf : Measurable (uncurry f)) : Measurable fun y => âˆ«â» x, f x y âˆ‚Î¼ :=
  hf.lintegral_prod_left'
#align measurable.lintegral_prod_left Measurable.lintegral_prod_left

/-! ### The product measure -/


namespace MeasureTheory

namespace Measure

/-- The binary product of measures. They are defined for arbitrary measures, but we basically
  prove all properties under the assumption that at least one of them is Ïƒ-finite. -/
protected irreducible_def prod (Î¼ : Measure Î±) (Î½ : Measure Î²) : Measure (Î± Ã— Î²) :=
  bind Î¼ fun x : Î± => map (Prod.mk x) Î½
#align measure_theory.measure.prod MeasureTheory.Measure.prod

instance prod.measureSpace {Î± Î²} [MeasureSpace Î±] [MeasureSpace Î²] : MeasureSpace (Î± Ã— Î²)
    where volume := volume.prod volume
#align measure_theory.measure.prod.measure_space MeasureTheory.Measure.prod.measureSpace

variable [SigmaFinite Î½]

theorem volume_eq_prod (Î± Î²) [MeasureSpace Î±] [MeasureSpace Î²] :
    (volume : Measure (Î± Ã— Î²)) = (volume : Measure Î±).prod (volume : Measure Î²) :=
  rfl
#align measure_theory.measure.volume_eq_prod MeasureTheory.Measure.volume_eq_prod

theorem prod_apply {s : Set (Î± Ã— Î²)} (hs : MeasurableSet s) :
    Î¼.prod Î½ s = âˆ«â» x, Î½ (Prod.mk x â»Â¹' s) âˆ‚Î¼ := by
  simp_rw [Measure.prod, bind_apply hs (Measurable.map_prod_mk_left (Î½ := Î½)),
    map_apply measurable_prod_mk_left hs]
#align measure_theory.measure.prod_apply MeasureTheory.Measure.prod_apply

/-- The product measure of the product of two sets is the product of their measures. Note that we
do not need the sets to be measurable. -/
@[simp]
theorem prod_prod (s : Set Î±) (t : Set Î²) : Î¼.prod Î½ (s Ã—Ë¢ t) = Î¼ s * Î½ t := by
  apply le_antisymm
  -- âŠ¢ â†‘â†‘(Measure.prod Î¼ Î½) (s Ã—Ë¢ t) â‰¤ â†‘â†‘Î¼ s * â†‘â†‘Î½ t
  Â· set ST := toMeasurable Î¼ s Ã—Ë¢ toMeasurable Î½ t
    -- âŠ¢ â†‘â†‘(Measure.prod Î¼ Î½) (s Ã—Ë¢ t) â‰¤ â†‘â†‘Î¼ s * â†‘â†‘Î½ t
    have hSTm : MeasurableSet ST :=
      (measurableSet_toMeasurable _ _).prod (measurableSet_toMeasurable _ _)
    calc
      Î¼.prod Î½ (s Ã—Ë¢ t) â‰¤ Î¼.prod Î½ ST :=
        measure_mono <| Set.prod_mono (subset_toMeasurable _ _) (subset_toMeasurable _ _)
      _ = Î¼ (toMeasurable Î¼ s) * Î½ (toMeasurable Î½ t) := by
        rw [prod_apply hSTm]
        simp_rw [mk_preimage_prod_right_eq_if, measure_if,
          lintegral_indicator _ (measurableSet_toMeasurable _ _), lintegral_const,
          restrict_apply_univ, mul_comm]
      _ = Î¼ s * Î½ t := by rw [measure_toMeasurable, measure_toMeasurable]
  Â· -- Formalization is based on https://mathoverflow.net/a/254134/136589
    set ST := toMeasurable (Î¼.prod Î½) (s Ã—Ë¢ t)
    -- âŠ¢ â†‘â†‘Î¼ s * â†‘â†‘Î½ t â‰¤ â†‘â†‘(Measure.prod Î¼ Î½) (s Ã—Ë¢ t)
    have hSTm : MeasurableSet ST := measurableSet_toMeasurable _ _
    -- âŠ¢ â†‘â†‘Î¼ s * â†‘â†‘Î½ t â‰¤ â†‘â†‘(Measure.prod Î¼ Î½) (s Ã—Ë¢ t)
    have hST : s Ã—Ë¢ t âŠ† ST := subset_toMeasurable _ _
    -- âŠ¢ â†‘â†‘Î¼ s * â†‘â†‘Î½ t â‰¤ â†‘â†‘(Measure.prod Î¼ Î½) (s Ã—Ë¢ t)
    set f : Î± â†’ â„â‰¥0âˆ := fun x => Î½ (Prod.mk x â»Â¹' ST)
    -- âŠ¢ â†‘â†‘Î¼ s * â†‘â†‘Î½ t â‰¤ â†‘â†‘(Measure.prod Î¼ Î½) (s Ã—Ë¢ t)
    have hfm : Measurable f := measurable_measure_prod_mk_left hSTm
    -- âŠ¢ â†‘â†‘Î¼ s * â†‘â†‘Î½ t â‰¤ â†‘â†‘(Measure.prod Î¼ Î½) (s Ã—Ë¢ t)
    set s' : Set Î± := { x | Î½ t â‰¤ f x }
    -- âŠ¢ â†‘â†‘Î¼ s * â†‘â†‘Î½ t â‰¤ â†‘â†‘(Measure.prod Î¼ Î½) (s Ã—Ë¢ t)
    have hss' : s âŠ† s' := fun x hx => measure_mono fun y hy => hST <| mk_mem_prod hx hy
    -- âŠ¢ â†‘â†‘Î¼ s * â†‘â†‘Î½ t â‰¤ â†‘â†‘(Measure.prod Î¼ Î½) (s Ã—Ë¢ t)
    calc
      Î¼ s * Î½ t â‰¤ Î¼ s' * Î½ t := mul_le_mul_right' (measure_mono hss') _
      _ = âˆ«â» _ in s', Î½ t âˆ‚Î¼ := by rw [set_lintegral_const, mul_comm]
      _ â‰¤ âˆ«â» x in s', f x âˆ‚Î¼ := (set_lintegral_mono measurable_const hfm fun x => id)
      _ â‰¤ âˆ«â» x, f x âˆ‚Î¼ := (lintegral_mono' restrict_le_self le_rfl)
      _ = Î¼.prod Î½ ST := (prod_apply hSTm).symm
      _ = Î¼.prod Î½ (s Ã—Ë¢ t) := measure_toMeasurable _
#align measure_theory.measure.prod_prod MeasureTheory.Measure.prod_prod

instance prod.instIsOpenPosMeasure {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]
    {m : MeasurableSpace X} {Î¼ : Measure X} [IsOpenPosMeasure Î¼] {m' : MeasurableSpace Y}
    {Î½ : Measure Y} [IsOpenPosMeasure Î½] [SigmaFinite Î½] : IsOpenPosMeasure (Î¼.prod Î½) := by
  constructor
  -- âŠ¢ âˆ€ (U : Set (X Ã— Y)), IsOpen U â†’ Set.Nonempty U â†’ â†‘â†‘(Measure.prod Î¼ Î½) U â‰  0
  rintro U U_open âŸ¨âŸ¨x, yâŸ©, hxyâŸ©
  -- âŠ¢ â†‘â†‘(Measure.prod Î¼ Î½) U â‰  0
  rcases isOpen_prod_iff.1 U_open x y hxy with âŸ¨u, v, u_open, v_open, xu, yv, huvâŸ©
  -- âŠ¢ â†‘â†‘(Measure.prod Î¼ Î½) U â‰  0
  refine' ne_of_gt (lt_of_lt_of_le _ (measure_mono huv))
  -- âŠ¢ 0 < â†‘â†‘(Measure.prod Î¼ Î½) (u Ã—Ë¢ v)
  simp only [prod_prod, CanonicallyOrderedCommSemiring.mul_pos]
  -- âŠ¢ 0 < â†‘â†‘Î¼ u âˆ§ 0 < â†‘â†‘Î½ v
  constructor
  -- âŠ¢ 0 < â†‘â†‘Î¼ u
  Â· exact u_open.measure_pos Î¼ âŸ¨x, xuâŸ©
    -- ğŸ‰ no goals
  Â· exact v_open.measure_pos Î½ âŸ¨y, yvâŸ©
    -- ğŸ‰ no goals
#align measure_theory.measure.prod.is_open_pos_measure MeasureTheory.Measure.prod.instIsOpenPosMeasure

instance {X Y : Type*}
    [TopologicalSpace X] [MeasureSpace X] [IsOpenPosMeasure (volume : Measure X)]
    [TopologicalSpace Y] [MeasureSpace Y] [IsOpenPosMeasure (volume : Measure Y)]
    [SigmaFinite (volume : Measure Y)] : IsOpenPosMeasure (volume : Measure (X Ã— Y)) :=
  prod.instIsOpenPosMeasure

instance prod.instIsFiniteMeasure {Î± Î² : Type*} {mÎ± : MeasurableSpace Î±} {mÎ² : MeasurableSpace Î²}
    (Î¼ : Measure Î±) (Î½ : Measure Î²) [IsFiniteMeasure Î¼] [IsFiniteMeasure Î½] :
    IsFiniteMeasure (Î¼.prod Î½) := by
  constructor
  -- âŠ¢ â†‘â†‘(Measure.prod Î¼ Î½) univ < âŠ¤
  rw [â† univ_prod_univ, prod_prod]
  -- âŠ¢ â†‘â†‘Î¼ univ * â†‘â†‘Î½ univ < âŠ¤
  exact mul_lt_top (measure_lt_top _ _).ne (measure_lt_top _ _).ne
  -- ğŸ‰ no goals
#align measure_theory.measure.prod.measure_theory.is_finite_measure MeasureTheory.Measure.prod.instIsFiniteMeasure

instance {Î± Î² : Type*} [MeasureSpace Î±] [MeasureSpace Î²] [IsFiniteMeasure (volume : Measure Î±)]
    [IsFiniteMeasure (volume : Measure Î²)] : IsFiniteMeasure (volume : Measure (Î± Ã— Î²)) :=
  prod.instIsFiniteMeasure _ _

instance prod.instIsProbabilityMeasure {Î± Î² : Type*} {mÎ± : MeasurableSpace Î±}
    {mÎ² : MeasurableSpace Î²} (Î¼ : Measure Î±) (Î½ : Measure Î²) [IsProbabilityMeasure Î¼]
    [IsProbabilityMeasure Î½] : IsProbabilityMeasure (Î¼.prod Î½) :=
  âŸ¨by rw [â† univ_prod_univ, prod_prod, measure_univ, measure_univ, mul_one]âŸ©
      -- ğŸ‰ no goals
#align measure_theory.measure.prod.measure_theory.is_probability_measure MeasureTheory.Measure.prod.instIsProbabilityMeasure

instance {Î± Î² : Type*} [MeasureSpace Î±] [MeasureSpace Î²]
    [IsProbabilityMeasure (volume : Measure Î±)] [IsProbabilityMeasure (volume : Measure Î²)] :
    IsProbabilityMeasure (volume : Measure (Î± Ã— Î²)) :=
  prod.instIsProbabilityMeasure _ _

instance prod.instIsFiniteMeasureOnCompacts {Î± Î² : Type*} [TopologicalSpace Î±] [TopologicalSpace Î²]
    {mÎ± : MeasurableSpace Î±} {mÎ² : MeasurableSpace Î²} (Î¼ : Measure Î±) (Î½ : Measure Î²)
    [IsFiniteMeasureOnCompacts Î¼] [IsFiniteMeasureOnCompacts Î½] [SigmaFinite Î½] :
    IsFiniteMeasureOnCompacts (Î¼.prod Î½) := by
  refine' âŸ¨fun K hK => _âŸ©
  -- âŠ¢ â†‘â†‘(Measure.prod Î¼ Î½) K < âŠ¤
  set L := (Prod.fst '' K) Ã—Ë¢ (Prod.snd '' K) with hL
  -- âŠ¢ â†‘â†‘(Measure.prod Î¼ Î½) K < âŠ¤
  have : K âŠ† L := by
    rintro âŸ¨x, yâŸ© hxy
    simp only [prod_mk_mem_set_prod_eq, mem_image, Prod.exists, exists_and_right, exists_eq_right]
    exact âŸ¨âŸ¨y, hxyâŸ©, âŸ¨x, hxyâŸ©âŸ©
  apply lt_of_le_of_lt (measure_mono this)
  -- âŠ¢ â†‘â†‘(Measure.prod Î¼ Î½) L < âŠ¤
  rw [hL, prod_prod]
  -- âŠ¢ â†‘â†‘Î¼ (Prod.fst '' K) * â†‘â†‘Î½ (Prod.snd '' K) < âŠ¤
  exact
    mul_lt_top (IsCompact.measure_lt_top (hK.image continuous_fst)).ne
      (IsCompact.measure_lt_top (hK.image continuous_snd)).ne
#align measure_theory.measure.prod.measure_theory.is_finite_measure_on_compacts MeasureTheory.Measure.prod.instIsFiniteMeasureOnCompacts

instance {X Y : Type*}
    [TopologicalSpace X] [MeasureSpace X] [IsFiniteMeasureOnCompacts (volume : Measure X)]
    [TopologicalSpace Y] [MeasureSpace Y] [IsFiniteMeasureOnCompacts (volume : Measure Y)]
    [SigmaFinite (volume : Measure Y)] : IsFiniteMeasureOnCompacts (volume : Measure (X Ã— Y)) :=
  prod.instIsFiniteMeasureOnCompacts _ _

theorem ae_measure_lt_top {s : Set (Î± Ã— Î²)} (hs : MeasurableSet s) (h2s : (Î¼.prod Î½) s â‰  âˆ) :
    âˆ€áµ x âˆ‚Î¼, Î½ (Prod.mk x â»Â¹' s) < âˆ := by
  rw [prod_apply hs] at h2s
  -- âŠ¢ âˆ€áµ (x : Î±) âˆ‚Î¼, â†‘â†‘Î½ (Prod.mk x â»Â¹' s) < âŠ¤
  refine' ae_lt_top (measurable_measure_prod_mk_left hs) h2s
  -- ğŸ‰ no goals
#align measure_theory.measure.ae_measure_lt_top MeasureTheory.Measure.ae_measure_lt_top

/-- Note: the assumption `hs` cannot be dropped. For a counterexample, see
  Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/
theorem measure_prod_null {s : Set (Î± Ã— Î²)} (hs : MeasurableSet s) :
    Î¼.prod Î½ s = 0 â†” (fun x => Î½ (Prod.mk x â»Â¹' s)) =áµ[Î¼] 0 := by
  rw [prod_apply hs, lintegral_eq_zero_iff (measurable_measure_prod_mk_left hs)]
  -- ğŸ‰ no goals
#align measure_theory.measure.measure_prod_null MeasureTheory.Measure.measure_prod_null

/-- Note: the converse is not true without assuming that `s` is measurable. For a counterexample,
  see Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/
theorem measure_ae_null_of_prod_null {s : Set (Î± Ã— Î²)} (h : Î¼.prod Î½ s = 0) :
    (fun x => Î½ (Prod.mk x â»Â¹' s)) =áµ[Î¼] 0 := by
  obtain âŸ¨t, hst, mt, htâŸ© := exists_measurable_superset_of_null h
  -- âŠ¢ (fun x => â†‘â†‘Î½ (Prod.mk x â»Â¹' s)) =á¶ [ae Î¼] 0
  rw [measure_prod_null mt] at ht
  -- âŠ¢ (fun x => â†‘â†‘Î½ (Prod.mk x â»Â¹' s)) =á¶ [ae Î¼] 0
  rw [eventuallyLE_antisymm_iff]
  -- âŠ¢ (fun x => â†‘â†‘Î½ (Prod.mk x â»Â¹' s)) â‰¤á¶ [ae Î¼] 0 âˆ§ 0 â‰¤á¶ [ae Î¼] fun x => â†‘â†‘Î½ (Prod. â€¦
  exact
    âŸ¨EventuallyLE.trans_eq (eventually_of_forall fun x => (measure_mono (preimage_mono hst) : _))
        ht,
      eventually_of_forall fun x => zero_le _âŸ©
#align measure_theory.measure.measure_ae_null_of_prod_null MeasureTheory.Measure.measure_ae_null_of_prod_null

theorem AbsolutelyContinuous.prod [SigmaFinite Î½'] (h1 : Î¼ â‰ª Î¼') (h2 : Î½ â‰ª Î½') :
    Î¼.prod Î½ â‰ª Î¼'.prod Î½' := by
  refine' AbsolutelyContinuous.mk fun s hs h2s => _
  -- âŠ¢ â†‘â†‘(Measure.prod Î¼ Î½) s = 0
  rw [measure_prod_null hs] at h2s âŠ¢
  -- âŠ¢ (fun x => â†‘â†‘Î½ (Prod.mk x â»Â¹' s)) =á¶ [ae Î¼] 0
  exact (h2s.filter_mono h1.ae_le).mono fun _ h => h2 h
  -- ğŸ‰ no goals
#align measure_theory.measure.absolutely_continuous.prod MeasureTheory.Measure.AbsolutelyContinuous.prod

/-- Note: the converse is not true. For a counterexample, see
  Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/
theorem ae_ae_of_ae_prod {p : Î± Ã— Î² â†’ Prop} (h : âˆ€áµ z âˆ‚Î¼.prod Î½, p z) :
    âˆ€áµ x âˆ‚Î¼, âˆ€áµ y âˆ‚Î½, p (x, y) :=
  measure_ae_null_of_prod_null h
#align measure_theory.measure.ae_ae_of_ae_prod MeasureTheory.Measure.ae_ae_of_ae_prod
/-- `Î¼.prod Î½` has finite spanning sets in rectangles of finite spanning sets. -/
noncomputable def FiniteSpanningSetsIn.prod {Î½ : Measure Î²} {C : Set (Set Î±)} {D : Set (Set Î²)}
    (hÎ¼ : Î¼.FiniteSpanningSetsIn C) (hÎ½ : Î½.FiniteSpanningSetsIn D) :
    (Î¼.prod Î½).FiniteSpanningSetsIn (image2 (Â· Ã—Ë¢ Â·) C D) := by
  haveI := hÎ½.sigmaFinite
  -- âŠ¢ FiniteSpanningSetsIn (Measure.prod Î¼ Î½) (image2 (fun x x_1 => x Ã—Ë¢ x_1) C D)
  refine'
    âŸ¨fun n => hÎ¼.set n.unpair.1 Ã—Ë¢ hÎ½.set n.unpair.2, fun n =>
      mem_image2_of_mem (hÎ¼.set_mem _) (hÎ½.set_mem _), fun n => _, _âŸ©
  Â· rw [prod_prod]
    -- âŠ¢ â†‘â†‘Î¼ (FiniteSpanningSetsIn.set hÎ¼ (Nat.unpair n).fst) * â†‘â†‘Î½ (FiniteSpanningSe â€¦
    exact mul_lt_top (hÎ¼.finite _).ne (hÎ½.finite _).ne
    -- ğŸ‰ no goals
  Â· simp_rw [iUnion_unpair_prod, hÎ¼.spanning, hÎ½.spanning, univ_prod_univ]
    -- ğŸ‰ no goals
#align measure_theory.measure.finite_spanning_sets_in.prod MeasureTheory.Measure.FiniteSpanningSetsIn.prod

theorem quasiMeasurePreserving_fst : QuasiMeasurePreserving Prod.fst (Î¼.prod Î½) Î¼ := by
  refine' âŸ¨measurable_fst, AbsolutelyContinuous.mk fun s hs h2s => _âŸ©
  -- âŠ¢ â†‘â†‘(map Prod.fst (Measure.prod Î¼ Î½)) s = 0
  rw [map_apply measurable_fst hs, â† prod_univ, prod_prod, h2s, zero_mul]
  -- ğŸ‰ no goals
#align measure_theory.measure.quasi_measure_preserving_fst MeasureTheory.Measure.quasiMeasurePreserving_fst

theorem quasiMeasurePreserving_snd : QuasiMeasurePreserving Prod.snd (Î¼.prod Î½) Î½ := by
  refine' âŸ¨measurable_snd, AbsolutelyContinuous.mk fun s hs h2s => _âŸ©
  -- âŠ¢ â†‘â†‘(map Prod.snd (Measure.prod Î¼ Î½)) s = 0
  rw [map_apply measurable_snd hs, â† univ_prod, prod_prod, h2s, mul_zero]
  -- ğŸ‰ no goals
#align measure_theory.measure.quasi_measure_preserving_snd MeasureTheory.Measure.quasiMeasurePreserving_snd

variable [SigmaFinite Î¼]

instance prod.instSigmaFinite : SigmaFinite (Î¼.prod Î½) :=
  (Î¼.toFiniteSpanningSetsIn.prod Î½.toFiniteSpanningSetsIn).sigmaFinite
#align measure_theory.measure.prod.sigma_finite MeasureTheory.Measure.prod.instSigmaFinite

instance {Î± Î²} [MeasureSpace Î±] [SigmaFinite (volume : Measure Î±)]
    [MeasureSpace Î²] [SigmaFinite (volume : Measure Î²)] : SigmaFinite (volume : Measure (Î± Ã— Î²)) :=
  prod.instSigmaFinite

/-- A measure on a product space equals the product measure if they are equal on rectangles
  with as sides sets that generate the corresponding Ïƒ-algebras. -/
theorem prod_eq_generateFrom {Î¼ : Measure Î±} {Î½ : Measure Î²} {C : Set (Set Î±)} {D : Set (Set Î²)}
    (hC : generateFrom C = â€¹_â€º) (hD : generateFrom D = â€¹_â€º) (h2C : IsPiSystem C)
    (h2D : IsPiSystem D) (h3C : Î¼.FiniteSpanningSetsIn C) (h3D : Î½.FiniteSpanningSetsIn D)
    {Î¼Î½ : Measure (Î± Ã— Î²)} (hâ‚ : âˆ€ s âˆˆ C, âˆ€ t âˆˆ D, Î¼Î½ (s Ã—Ë¢ t) = Î¼ s * Î½ t) : Î¼.prod Î½ = Î¼Î½ := by
  refine'
    (h3C.prod h3D).ext
      (generateFrom_eq_prod hC hD h3C.isCountablySpanning h3D.isCountablySpanning).symm
      (h2C.prod h2D) _
  Â· rintro _ âŸ¨s, t, hs, ht, rflâŸ©
    -- âŠ¢ â†‘â†‘(Measure.prod Î¼ Î½) ((fun x x_1 => x Ã—Ë¢ x_1) s t) = â†‘â†‘Î¼Î½ ((fun x x_1 => x Ã— â€¦
    haveI := h3D.sigmaFinite
    -- âŠ¢ â†‘â†‘(Measure.prod Î¼ Î½) ((fun x x_1 => x Ã—Ë¢ x_1) s t) = â†‘â†‘Î¼Î½ ((fun x x_1 => x Ã— â€¦
    rw [hâ‚ s hs t ht, prod_prod]
    -- ğŸ‰ no goals
#align measure_theory.measure.prod_eq_generate_from MeasureTheory.Measure.prod_eq_generateFrom

/-- A measure on a product space equals the product measure if they are equal on rectangles. -/
theorem prod_eq {Î¼Î½ : Measure (Î± Ã— Î²)}
    (h : âˆ€ s t, MeasurableSet s â†’ MeasurableSet t â†’ Î¼Î½ (s Ã—Ë¢ t) = Î¼ s * Î½ t) : Î¼.prod Î½ = Î¼Î½ :=
  prod_eq_generateFrom generateFrom_measurableSet generateFrom_measurableSet
    isPiSystem_measurableSet isPiSystem_measurableSet Î¼.toFiniteSpanningSetsIn
    Î½.toFiniteSpanningSetsIn fun s hs t ht => h s t hs ht
#align measure_theory.measure.prod_eq MeasureTheory.Measure.prod_eq

theorem prod_swap : map Prod.swap (Î¼.prod Î½) = Î½.prod Î¼ := by
  refine' (prod_eq _).symm
  -- âŠ¢ âˆ€ (s : Set Î²) (t : Set Î±), MeasurableSet s â†’ MeasurableSet t â†’ â†‘â†‘(map Prod.s â€¦
  intro s t hs ht
  -- âŠ¢ â†‘â†‘(map Prod.swap (Measure.prod Î¼ Î½)) (s Ã—Ë¢ t) = â†‘â†‘Î½ s * â†‘â†‘Î¼ t
  simp_rw [map_apply measurable_swap (hs.prod ht), preimage_swap_prod, prod_prod, mul_comm]
  -- ğŸ‰ no goals
#align measure_theory.measure.prod_swap MeasureTheory.Measure.prod_swap

theorem measurePreserving_swap : MeasurePreserving Prod.swap (Î¼.prod Î½) (Î½.prod Î¼) :=
  âŸ¨measurable_swap, prod_swapâŸ©
#align measure_theory.measure.measure_preserving_swap MeasureTheory.Measure.measurePreserving_swap

theorem prod_apply_symm {s : Set (Î± Ã— Î²)} (hs : MeasurableSet s) :
    Î¼.prod Î½ s = âˆ«â» y, Î¼ ((fun x => (x, y)) â»Â¹' s) âˆ‚Î½ := by
  rw [â† prod_swap, map_apply measurable_swap hs, prod_apply (measurable_swap hs)]
  -- âŠ¢ âˆ«â» (x : Î²), â†‘â†‘Î¼ (Prod.mk x â»Â¹' (Prod.swap â»Â¹' s)) âˆ‚Î½ = âˆ«â» (y : Î²), â†‘â†‘Î¼ ((fun â€¦
  rfl
  -- ğŸ‰ no goals
#align measure_theory.measure.prod_apply_symm MeasureTheory.Measure.prod_apply_symm

theorem prodAssoc_prod [SigmaFinite Ï„] :
    map MeasurableEquiv.prodAssoc ((Î¼.prod Î½).prod Ï„) = Î¼.prod (Î½.prod Ï„) := by
  refine'
    (prod_eq_generateFrom generateFrom_measurableSet generateFrom_prod isPiSystem_measurableSet
        isPiSystem_prod Î¼.toFiniteSpanningSetsIn
        (Î½.toFiniteSpanningSetsIn.prod Ï„.toFiniteSpanningSetsIn) _).symm
  rintro s hs _ âŸ¨t, u, ht, hu, rflâŸ©; rw [mem_setOf_eq] at hs ht hu
  -- âŠ¢ â†‘â†‘(map (â†‘MeasurableEquiv.prodAssoc) (Measure.prod (Measure.prod Î¼ Î½) Ï„)) (s  â€¦
                                     -- âŠ¢ â†‘â†‘(map (â†‘MeasurableEquiv.prodAssoc) (Measure.prod (Measure.prod Î¼ Î½) Ï„)) (s  â€¦
  simp_rw [map_apply (MeasurableEquiv.measurable _) (hs.prod (ht.prod hu)),
    MeasurableEquiv.prodAssoc, MeasurableEquiv.coe_mk, Equiv.prod_assoc_preimage, prod_prod,
    mul_assoc]
#align measure_theory.measure.prod_assoc_prod MeasureTheory.Measure.prodAssoc_prod

/-! ### The product of specific measures -/


theorem prod_restrict (s : Set Î±) (t : Set Î²) :
    (Î¼.restrict s).prod (Î½.restrict t) = (Î¼.prod Î½).restrict (s Ã—Ë¢ t) := by
  refine' prod_eq fun s' t' hs' ht' => _
  -- âŠ¢ â†‘â†‘(restrict (Measure.prod Î¼ Î½) (s Ã—Ë¢ t)) (s' Ã—Ë¢ t') = â†‘â†‘(restrict Î¼ s) s' *  â€¦
  rw [restrict_apply (hs'.prod ht'), prod_inter_prod, prod_prod, restrict_apply hs',
    restrict_apply ht']
#align measure_theory.measure.prod_restrict MeasureTheory.Measure.prod_restrict

theorem restrict_prod_eq_prod_univ (s : Set Î±) :
    (Î¼.restrict s).prod Î½ = (Î¼.prod Î½).restrict (s Ã—Ë¢ univ) := by
  have : Î½ = Î½.restrict Set.univ := Measure.restrict_univ.symm
  -- âŠ¢ Measure.prod (restrict Î¼ s) Î½ = restrict (Measure.prod Î¼ Î½) (s Ã—Ë¢ univ)
  rw [this, Measure.prod_restrict, â† this]
  -- ğŸ‰ no goals
#align measure_theory.measure.restrict_prod_eq_prod_univ MeasureTheory.Measure.restrict_prod_eq_prod_univ

theorem prod_dirac (y : Î²) : Î¼.prod (dirac y) = map (fun x => (x, y)) Î¼ := by
  refine' prod_eq fun s t hs ht => _
  -- âŠ¢ â†‘â†‘(map (fun x => (x, y)) Î¼) (s Ã—Ë¢ t) = â†‘â†‘Î¼ s * â†‘â†‘(dirac y) t
  simp_rw [map_apply measurable_prod_mk_right (hs.prod ht), mk_preimage_prod_left_eq_if, measure_if,
    dirac_apply' _ ht, â† indicator_mul_right _ fun _ => Î¼ s, Pi.one_apply, mul_one]
#align measure_theory.measure.prod_dirac MeasureTheory.Measure.prod_dirac

theorem dirac_prod (x : Î±) : (dirac x).prod Î½ = map (Prod.mk x) Î½ := by
  refine' prod_eq fun s t hs ht => _
  -- âŠ¢ â†‘â†‘(map (Prod.mk x) Î½) (s Ã—Ë¢ t) = â†‘â†‘(dirac x) s * â†‘â†‘Î½ t
  simp_rw [map_apply measurable_prod_mk_left (hs.prod ht), mk_preimage_prod_right_eq_if, measure_if,
    dirac_apply' _ hs, â† indicator_mul_left _ _ fun _ => Î½ t, Pi.one_apply, one_mul]
#align measure_theory.measure.dirac_prod MeasureTheory.Measure.dirac_prod

theorem dirac_prod_dirac {x : Î±} {y : Î²} : (dirac x).prod (dirac y) = dirac (x, y) := by
  rw [prod_dirac, map_dirac measurable_prod_mk_right]
  -- ğŸ‰ no goals
#align measure_theory.measure.dirac_prod_dirac MeasureTheory.Measure.dirac_prod_dirac

theorem prod_sum {Î¹ : Type*} [Finite Î¹] (Î½ : Î¹ â†’ Measure Î²) [âˆ€ i, SigmaFinite (Î½ i)] :
    Î¼.prod (sum Î½) = sum fun i => Î¼.prod (Î½ i) := by
  refine' prod_eq fun s t hs ht => _
  -- âŠ¢ â†‘â†‘(sum fun i => Measure.prod Î¼ (Î½ i)) (s Ã—Ë¢ t) = â†‘â†‘Î¼ s * â†‘â†‘(sum Î½) t
  simp_rw [sum_apply _ (hs.prod ht), sum_apply _ ht, prod_prod, ENNReal.tsum_mul_left]
  -- ğŸ‰ no goals
#align measure_theory.measure.prod_sum MeasureTheory.Measure.prod_sum

theorem sum_prod {Î¹ : Type*} [Finite Î¹] (Î¼ : Î¹ â†’ Measure Î±) [âˆ€ i, SigmaFinite (Î¼ i)] :
    (sum Î¼).prod Î½ = sum fun i => (Î¼ i).prod Î½ := by
  refine' prod_eq fun s t hs ht => _
  -- âŠ¢ â†‘â†‘(sum fun i => Measure.prod (Î¼ i) Î½) (s Ã—Ë¢ t) = â†‘â†‘(sum Î¼) s * â†‘â†‘Î½ t
  simp_rw [sum_apply _ (hs.prod ht), sum_apply _ hs, prod_prod, ENNReal.tsum_mul_right]
  -- ğŸ‰ no goals
#align measure_theory.measure.sum_prod MeasureTheory.Measure.sum_prod

theorem prod_add (Î½' : Measure Î²) [SigmaFinite Î½'] : Î¼.prod (Î½ + Î½') = Î¼.prod Î½ + Î¼.prod Î½' := by
  refine' prod_eq fun s t _ _ => _
  -- âŠ¢ â†‘â†‘(Measure.prod Î¼ Î½ + Measure.prod Î¼ Î½') (s Ã—Ë¢ t) = â†‘â†‘Î¼ s * â†‘â†‘(Î½ + Î½') t
  simp_rw [add_apply, prod_prod, left_distrib]
  -- ğŸ‰ no goals
#align measure_theory.measure.prod_add MeasureTheory.Measure.prod_add

theorem add_prod (Î¼' : Measure Î±) [SigmaFinite Î¼'] : (Î¼ + Î¼').prod Î½ = Î¼.prod Î½ + Î¼'.prod Î½ := by
  refine' prod_eq fun s t _ _ => _
  -- âŠ¢ â†‘â†‘(Measure.prod Î¼ Î½ + Measure.prod Î¼' Î½) (s Ã—Ë¢ t) = â†‘â†‘(Î¼ + Î¼') s * â†‘â†‘Î½ t
  simp_rw [add_apply, prod_prod, right_distrib]
  -- ğŸ‰ no goals
#align measure_theory.measure.add_prod MeasureTheory.Measure.add_prod

@[simp]
theorem zero_prod (Î½ : Measure Î²) : (0 : Measure Î±).prod Î½ = 0 := by
  rw [Measure.prod]
  -- âŠ¢ (bind 0 fun x => map (Prod.mk x) Î½) = 0
  exact bind_zero_left _
  -- ğŸ‰ no goals
#align measure_theory.measure.zero_prod MeasureTheory.Measure.zero_prod

@[simp]
theorem prod_zero (Î¼ : Measure Î±) : Î¼.prod (0 : Measure Î²) = 0 := by simp [Measure.prod]
                                                                     -- ğŸ‰ no goals
#align measure_theory.measure.prod_zero MeasureTheory.Measure.prod_zero

theorem map_prod_map {Î´} [MeasurableSpace Î´] {f : Î± â†’ Î²} {g : Î³ â†’ Î´} {Î¼a : Measure Î±}
    {Î¼c : Measure Î³} (hfa : SigmaFinite (map f Î¼a)) (hgc : SigmaFinite (map g Î¼c))
    (hf : Measurable f) (hg : Measurable g) :
    (map f Î¼a).prod (map g Î¼c) = map (Prod.map f g) (Î¼a.prod Î¼c) := by
  haveI := hgc.of_map Î¼c hg.aemeasurable
  -- âŠ¢ Measure.prod (map f Î¼a) (map g Î¼c) = map (Prod.map f g) (Measure.prod Î¼a Î¼c)
  refine' prod_eq fun s t hs ht => _
  -- âŠ¢ â†‘â†‘(map (Prod.map f g) (Measure.prod Î¼a Î¼c)) (s Ã—Ë¢ t) = â†‘â†‘(map f Î¼a) s * â†‘â†‘(m â€¦
  rw [map_apply (hf.prod_map hg) (hs.prod ht), map_apply hf hs, map_apply hg ht]
  -- âŠ¢ â†‘â†‘(Measure.prod Î¼a Î¼c) (Prod.map f g â»Â¹' s Ã—Ë¢ t) = â†‘â†‘Î¼a (f â»Â¹' s) * â†‘â†‘Î¼c (g  â€¦
  exact prod_prod (f â»Â¹' s) (g â»Â¹' t)
  -- ğŸ‰ no goals
#align measure_theory.measure.map_prod_map MeasureTheory.Measure.map_prod_map

end Measure

open Measure

namespace MeasurePreserving

variable {Î´ : Type*} [MeasurableSpace Î´] {Î¼a : Measure Î±} {Î¼b : Measure Î²} {Î¼c : Measure Î³}
  {Î¼d : Measure Î´}

theorem skew_product [SigmaFinite Î¼b] [SigmaFinite Î¼d] {f : Î± â†’ Î²} (hf : MeasurePreserving f Î¼a Î¼b)
    {g : Î± â†’ Î³ â†’ Î´} (hgm : Measurable (uncurry g)) (hg : âˆ€áµ x âˆ‚Î¼a, map (g x) Î¼c = Î¼d) :
    MeasurePreserving (fun p : Î± Ã— Î³ => (f p.1, g p.1 p.2)) (Î¼a.prod Î¼c) (Î¼b.prod Î¼d) := by
  classical
    have : Measurable fun p : Î± Ã— Î³ => (f p.1, g p.1 p.2) := (hf.1.comp measurable_fst).prod_mk hgm
    /- if `Î¼a = 0`, then the lemma is trivial, otherwise we can use `hg`
      to deduce `SigmaFinite Î¼c`. -/
    rcases eq_or_ne Î¼a 0 with (rfl | ha)
    Â· rw [â† hf.map_eq, zero_prod, Measure.map_zero, zero_prod]
      exact âŸ¨this, by simp only [Measure.map_zero]âŸ©
    have sf : SigmaFinite Î¼c := by
      rcases (ae_neBot.2 ha).nonempty_of_mem hg with âŸ¨x, hx : map (g x) Î¼c = Î¼dâŸ©
      exact SigmaFinite.of_map _ hgm.of_uncurry_left.aemeasurable (by rwa [hx])
    -- Thus we can apply `Measure.prod_eq` to prove equality of measures.
    refine' âŸ¨this, (prod_eq fun s t hs ht => _).symmâŸ©
    rw [map_apply this (hs.prod ht)]
    refine' (prod_apply (this <| hs.prod ht)).trans _
    have : âˆ€áµ x âˆ‚Î¼a,
        Î¼c ((fun y => (f x, g x y)) â»Â¹' s Ã—Ë¢ t) = indicator (f â»Â¹' s) (fun _ => Î¼d t) x := by
      refine' hg.mono fun x hx => _
      subst hx
      simp only [mk_preimage_prod_right_fn_eq_if, indicator_apply, mem_preimage]
      split_ifs
      exacts [(map_apply hgm.of_uncurry_left ht).symm, measure_empty]
    simp only [preimage_preimage]
    rw [lintegral_congr_ae this, lintegral_indicator _ (hf.1 hs), set_lintegral_const,
      hf.measure_preimage hs, mul_comm]
#align measure_theory.measure_preserving.skew_product MeasureTheory.MeasurePreserving.skew_product

/-- If `f : Î± â†’ Î²` sends the measure `Î¼a` to `Î¼b` and `g : Î³ â†’ Î´` sends the measure `Î¼c` to `Î¼d`,
then `Prod.map f g` sends `Î¼a.prod Î¼c` to `Î¼b.prod Î¼d`. -/
protected theorem prod [SigmaFinite Î¼b] [SigmaFinite Î¼d] {f : Î± â†’ Î²} {g : Î³ â†’ Î´}
    (hf : MeasurePreserving f Î¼a Î¼b) (hg : MeasurePreserving g Î¼c Î¼d) :
    MeasurePreserving (Prod.map f g) (Î¼a.prod Î¼c) (Î¼b.prod Î¼d) :=
  have : Measurable (uncurry fun _ : Î± => g) := hg.1.comp measurable_snd
  hf.skew_product this <| Filter.eventually_of_forall fun _ => hg.map_eq
#align measure_theory.measure_preserving.prod MeasureTheory.MeasurePreserving.prod

end MeasurePreserving

namespace QuasiMeasurePreserving

theorem prod_of_right {f : Î± Ã— Î² â†’ Î³} {Î¼ : Measure Î±} {Î½ : Measure Î²} {Ï„ : Measure Î³}
    (hf : Measurable f) [SigmaFinite Î½]
    (h2f : âˆ€áµ x âˆ‚Î¼, QuasiMeasurePreserving (fun y => f (x, y)) Î½ Ï„) :
    QuasiMeasurePreserving f (Î¼.prod Î½) Ï„ := by
  refine' âŸ¨hf, _âŸ©
  -- âŠ¢ map f (Measure.prod Î¼ Î½) â‰ª Ï„
  refine' AbsolutelyContinuous.mk fun s hs h2s => _
  -- âŠ¢ â†‘â†‘(map f (Measure.prod Î¼ Î½)) s = 0
  rw [map_apply hf hs, prod_apply (hf hs)]; simp_rw [preimage_preimage]
  -- âŠ¢ âˆ«â» (x : Î±), â†‘â†‘Î½ (Prod.mk x â»Â¹' (f â»Â¹' s)) âˆ‚Î¼ = 0
                                            -- âŠ¢ âˆ«â» (x : Î±), â†‘â†‘Î½ ((fun x_1 => f (x, x_1)) â»Â¹' s) âˆ‚Î¼ = 0
  rw [lintegral_congr_ae (h2f.mono fun x hx => hx.preimage_null h2s), lintegral_zero]
  -- ğŸ‰ no goals
#align measure_theory.quasi_measure_preserving.prod_of_right MeasureTheory.QuasiMeasurePreserving.prod_of_right

theorem prod_of_left {Î± Î² Î³} [MeasurableSpace Î±] [MeasurableSpace Î²] [MeasurableSpace Î³]
    {f : Î± Ã— Î² â†’ Î³} {Î¼ : Measure Î±} {Î½ : Measure Î²} {Ï„ : Measure Î³} (hf : Measurable f)
    [SigmaFinite Î¼] [SigmaFinite Î½]
    (h2f : âˆ€áµ y âˆ‚Î½, QuasiMeasurePreserving (fun x => f (x, y)) Î¼ Ï„) :
    QuasiMeasurePreserving f (Î¼.prod Î½) Ï„ := by
  rw [â† prod_swap]
  -- âŠ¢ QuasiMeasurePreserving f
  convert (QuasiMeasurePreserving.prod_of_right (hf.comp measurable_swap) h2f).comp
      ((measurable_swap.measurePreserving (Î½.prod Î¼)).symm
          MeasurableEquiv.prodComm).quasiMeasurePreserving
#align measure_theory.quasi_measure_preserving.prod_of_left MeasureTheory.QuasiMeasurePreserving.prod_of_left

end QuasiMeasurePreserving

end MeasureTheory

open MeasureTheory.Measure

section

theorem AEMeasurable.prod_swap [SigmaFinite Î¼] [SigmaFinite Î½] {f : Î² Ã— Î± â†’ Î³}
    (hf : AEMeasurable f (Î½.prod Î¼)) : AEMeasurable (fun z : Î± Ã— Î² => f z.swap) (Î¼.prod Î½) := by
  rw [â† Measure.prod_swap] at hf
  -- âŠ¢ AEMeasurable fun z => f (Prod.swap z)
  exact hf.comp_measurable measurable_swap
  -- ğŸ‰ no goals
#align ae_measurable.prod_swap AEMeasurable.prod_swap

theorem AEMeasurable.fst [SigmaFinite Î½] {f : Î± â†’ Î³} (hf : AEMeasurable f Î¼) :
    AEMeasurable (fun z : Î± Ã— Î² => f z.1) (Î¼.prod Î½) :=
  hf.comp_quasiMeasurePreserving quasiMeasurePreserving_fst
#align ae_measurable.fst AEMeasurable.fst

theorem AEMeasurable.snd [SigmaFinite Î½] {f : Î² â†’ Î³} (hf : AEMeasurable f Î½) :
    AEMeasurable (fun z : Î± Ã— Î² => f z.2) (Î¼.prod Î½) :=
  hf.comp_quasiMeasurePreserving quasiMeasurePreserving_snd
#align ae_measurable.snd AEMeasurable.snd

end

namespace MeasureTheory

/-! ### The Lebesgue integral on a product -/


variable [SigmaFinite Î½]

theorem lintegral_prod_swap [SigmaFinite Î¼] (f : Î± Ã— Î² â†’ â„â‰¥0âˆ) (hf : AEMeasurable f (Î¼.prod Î½)) :
    âˆ«â» z, f z.swap âˆ‚Î½.prod Î¼ = âˆ«â» z, f z âˆ‚Î¼.prod Î½ := by
  rw [â† prod_swap] at hf
  -- âŠ¢ âˆ«â» (z : Î² Ã— Î±), f (Prod.swap z) âˆ‚Measure.prod Î½ Î¼ = âˆ«â» (z : Î± Ã— Î²), f z âˆ‚Mea â€¦
  rw [â† lintegral_map' hf measurable_swap.aemeasurable, prod_swap]
  -- ğŸ‰ no goals
#align measure_theory.lintegral_prod_swap MeasureTheory.lintegral_prod_swap

/-- **Tonelli's Theorem**: For `â„â‰¥0âˆ`-valued measurable functions on `Î± Ã— Î²`,
  the integral of `f` is equal to the iterated integral. -/
theorem lintegral_prod_of_measurable :
    âˆ€ (f : Î± Ã— Î² â†’ â„â‰¥0âˆ), Measurable f â†’ âˆ«â» z, f z âˆ‚Î¼.prod Î½ = âˆ«â» x, âˆ«â» y, f (x, y) âˆ‚Î½ âˆ‚Î¼ := by
  have m := @measurable_prod_mk_left
  -- âŠ¢ âˆ€ (f : Î± Ã— Î² â†’ â„â‰¥0âˆ), Measurable f â†’ âˆ«â» (z : Î± Ã— Î²), f z âˆ‚Measure.prod Î¼ Î½ = â€¦
  refine' Measurable.ennreal_induction
    (P := fun f => âˆ«â» z, f z âˆ‚Î¼.prod Î½ = âˆ«â» x, âˆ«â» y, f (x, y) âˆ‚Î½ âˆ‚Î¼) _ _ _
  Â· intro c s hs
    -- âŠ¢ âˆ«â» (z : Î± Ã— Î²), indicator s (fun x => c) z âˆ‚Measure.prod Î¼ Î½ = âˆ«â» (x : Î±), âˆ« â€¦
    conv_rhs =>
      enter [2, x, 2, y]
      rw [â† indicator_comp_right, const_def, const_comp, â† const_def]
    conv_rhs =>
      enter [2, x]
      rw [lintegral_indicator _ (m (x := x) hs), lintegral_const,
        Measure.restrict_apply MeasurableSet.univ, univ_inter]
    simp [hs, lintegral_const_mul, measurable_measure_prod_mk_left (Î½ := Î½) hs, prod_apply]
    -- ğŸ‰ no goals
  Â· rintro f g - hf _ h2f h2g
    -- âŠ¢ âˆ«â» (z : Î± Ã— Î²), (f + g) z âˆ‚Measure.prod Î¼ Î½ = âˆ«â» (x : Î±), âˆ«â» (y : Î²), (f + g â€¦
    simp only [Pi.add_apply]
    -- âŠ¢ âˆ«â» (z : Î± Ã— Î²), f z + g z âˆ‚Measure.prod Î¼ Î½ = âˆ«â» (x : Î±), âˆ«â» (y : Î²), f (x,  â€¦
    conv_lhs => rw [lintegral_add_left hf]
    -- âŠ¢ âˆ«â» (a : Î± Ã— Î²), f a âˆ‚Measure.prod Î¼ Î½ + âˆ«â» (a : Î± Ã— Î²), g a âˆ‚Measure.prod Î¼  â€¦
    conv_rhs => enter [2, x]; erw [lintegral_add_left (hf.comp (m (x := x)))]
    -- âŠ¢ âˆ«â» (a : Î± Ã— Î²), f a âˆ‚Measure.prod Î¼ Î½ + âˆ«â» (a : Î± Ã— Î²), g a âˆ‚Measure.prod Î¼  â€¦
    simp [lintegral_add_left, Measurable.lintegral_prod_right', hf, h2f, h2g]
    -- ğŸ‰ no goals
  Â· intro f hf h2f h3f
    -- âŠ¢ âˆ«â» (z : Î± Ã— Î²), (fun x => â¨† (n : â„•), f n x) z âˆ‚Measure.prod Î¼ Î½ = âˆ«â» (x : Î±) â€¦
    have kf : âˆ€ x n, Measurable fun y => f n (x, y) := fun x n => (hf n).comp m
    -- âŠ¢ âˆ«â» (z : Î± Ã— Î²), (fun x => â¨† (n : â„•), f n x) z âˆ‚Measure.prod Î¼ Î½ = âˆ«â» (x : Î±) â€¦
    have k2f : âˆ€ x, Monotone fun n y => f n (x, y) := fun x i j hij y => h2f hij (x, y)
    -- âŠ¢ âˆ«â» (z : Î± Ã— Î²), (fun x => â¨† (n : â„•), f n x) z âˆ‚Measure.prod Î¼ Î½ = âˆ«â» (x : Î±) â€¦
    have lf : âˆ€ n, Measurable fun x => âˆ«â» y, f n (x, y) âˆ‚Î½ := fun n => (hf n).lintegral_prod_right'
    -- âŠ¢ âˆ«â» (z : Î± Ã— Î²), (fun x => â¨† (n : â„•), f n x) z âˆ‚Measure.prod Î¼ Î½ = âˆ«â» (x : Î±) â€¦
    have l2f : Monotone fun n x => âˆ«â» y, f n (x, y) âˆ‚Î½ := fun i j hij x =>
      lintegral_mono (k2f x hij)
    simp only [lintegral_iSup hf h2f, lintegral_iSup (kf _), k2f, lintegral_iSup lf l2f, h3f]
    -- ğŸ‰ no goals
#align measure_theory.lintegral_prod_of_measurable MeasureTheory.lintegral_prod_of_measurable

/-- **Tonelli's Theorem**: For `â„â‰¥0âˆ`-valued almost everywhere measurable functions on `Î± Ã— Î²`,
  the integral of `f` is equal to the iterated integral. -/
theorem lintegral_prod (f : Î± Ã— Î² â†’ â„â‰¥0âˆ) (hf : AEMeasurable f (Î¼.prod Î½)) :
    âˆ«â» z, f z âˆ‚Î¼.prod Î½ = âˆ«â» x, âˆ«â» y, f (x, y) âˆ‚Î½ âˆ‚Î¼ := by
  have A : âˆ«â» z, f z âˆ‚Î¼.prod Î½ = âˆ«â» z, hf.mk f z âˆ‚Î¼.prod Î½ := lintegral_congr_ae hf.ae_eq_mk
  -- âŠ¢ âˆ«â» (z : Î± Ã— Î²), f z âˆ‚Measure.prod Î¼ Î½ = âˆ«â» (x : Î±), âˆ«â» (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼
  have B : (âˆ«â» x, âˆ«â» y, f (x, y) âˆ‚Î½ âˆ‚Î¼) = âˆ«â» x, âˆ«â» y, hf.mk f (x, y) âˆ‚Î½ âˆ‚Î¼ := by
    apply lintegral_congr_ae
    filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk]with _ ha using lintegral_congr_ae ha
  rw [A, B, lintegral_prod_of_measurable _ hf.measurable_mk]
  -- ğŸ‰ no goals
#align measure_theory.lintegral_prod MeasureTheory.lintegral_prod

/-- The symmetric version of Tonelli's Theorem: For `â„â‰¥0âˆ`-valued almost everywhere measurable
functions on `Î± Ã— Î²`, the integral of `f` is equal to the iterated integral, in reverse order. -/
theorem lintegral_prod_symm [SigmaFinite Î¼] (f : Î± Ã— Î² â†’ â„â‰¥0âˆ) (hf : AEMeasurable f (Î¼.prod Î½)) :
    âˆ«â» z, f z âˆ‚Î¼.prod Î½ = âˆ«â» y, âˆ«â» x, f (x, y) âˆ‚Î¼ âˆ‚Î½ := by
  simp_rw [â† lintegral_prod_swap f hf]
  -- âŠ¢ âˆ«â» (z : Î² Ã— Î±), f (Prod.swap z) âˆ‚Measure.prod Î½ Î¼ = âˆ«â» (y : Î²), âˆ«â» (x : Î±),  â€¦
  exact lintegral_prod _ hf.prod_swap
  -- ğŸ‰ no goals
#align measure_theory.lintegral_prod_symm MeasureTheory.lintegral_prod_symm

/-- The symmetric version of Tonelli's Theorem: For `â„â‰¥0âˆ`-valued measurable
functions on `Î± Ã— Î²`, the integral of `f` is equal to the iterated integral, in reverse order. -/
theorem lintegral_prod_symm' [SigmaFinite Î¼] (f : Î± Ã— Î² â†’ â„â‰¥0âˆ) (hf : Measurable f) :
    âˆ«â» z, f z âˆ‚Î¼.prod Î½ = âˆ«â» y, âˆ«â» x, f (x, y) âˆ‚Î¼ âˆ‚Î½ :=
  lintegral_prod_symm f hf.aemeasurable
#align measure_theory.lintegral_prod_symm' MeasureTheory.lintegral_prod_symm'

/-- The reversed version of **Tonelli's Theorem**. In this version `f` is in curried form, which
makes it easier for the elaborator to figure out `f` automatically. -/
theorem lintegral_lintegral â¦ƒf : Î± â†’ Î² â†’ â„â‰¥0âˆâ¦„ (hf : AEMeasurable (uncurry f) (Î¼.prod Î½)) :
    âˆ«â» x, âˆ«â» y, f x y âˆ‚Î½ âˆ‚Î¼ = âˆ«â» z, f z.1 z.2 âˆ‚Î¼.prod Î½ :=
  (lintegral_prod _ hf).symm
#align measure_theory.lintegral_lintegral MeasureTheory.lintegral_lintegral

/-- The reversed version of **Tonelli's Theorem** (symmetric version). In this version `f` is in
curried form, which makes it easier for the elaborator to figure out `f` automatically. -/
theorem lintegral_lintegral_symm [SigmaFinite Î¼] â¦ƒf : Î± â†’ Î² â†’ â„â‰¥0âˆâ¦„
    (hf : AEMeasurable (uncurry f) (Î¼.prod Î½)) :
    âˆ«â» x, âˆ«â» y, f x y âˆ‚Î½ âˆ‚Î¼ = âˆ«â» z, f z.2 z.1 âˆ‚Î½.prod Î¼ :=
  (lintegral_prod_symm _ hf.prod_swap).symm
#align measure_theory.lintegral_lintegral_symm MeasureTheory.lintegral_lintegral_symm

/-- Change the order of Lebesgue integration. -/
theorem lintegral_lintegral_swap [SigmaFinite Î¼] â¦ƒf : Î± â†’ Î² â†’ â„â‰¥0âˆâ¦„
    (hf : AEMeasurable (uncurry f) (Î¼.prod Î½)) :
    âˆ«â» x, âˆ«â» y, f x y âˆ‚Î½ âˆ‚Î¼ = âˆ«â» y, âˆ«â» x, f x y âˆ‚Î¼ âˆ‚Î½ :=
  (lintegral_lintegral hf).trans (lintegral_prod_symm _ hf)
#align measure_theory.lintegral_lintegral_swap MeasureTheory.lintegral_lintegral_swap

theorem lintegral_prod_mul {f : Î± â†’ â„â‰¥0âˆ} {g : Î² â†’ â„â‰¥0âˆ} (hf : AEMeasurable f Î¼)
    (hg : AEMeasurable g Î½) : âˆ«â» z, f z.1 * g z.2 âˆ‚Î¼.prod Î½ = (âˆ«â» x, f x âˆ‚Î¼) * âˆ«â» y, g y âˆ‚Î½ := by
  simp [lintegral_prod _ (hf.fst.mul hg.snd), lintegral_lintegral_mul hf hg]
  -- ğŸ‰ no goals
#align measure_theory.lintegral_prod_mul MeasureTheory.lintegral_prod_mul

/-! ### Marginals of a measure defined on a product -/


namespace Measure

variable {Ï : Measure (Î± Ã— Î²)}

/-- Marginal measure on `Î±` obtained from a measure `Ï` on `Î± Ã— Î²`, defined by `Ï.map Prod.fst`. -/
noncomputable def fst (Ï : Measure (Î± Ã— Î²)) : Measure Î± :=
  Ï.map Prod.fst
#align measure_theory.measure.fst MeasureTheory.Measure.fst

theorem fst_apply {s : Set Î±} (hs : MeasurableSet s) : Ï.fst s = Ï (Prod.fst â»Â¹' s) := by
  rw [fst, Measure.map_apply measurable_fst hs]
  -- ğŸ‰ no goals
#align measure_theory.measure.fst_apply MeasureTheory.Measure.fst_apply

theorem fst_univ : Ï.fst univ = Ï univ := by rw [fst_apply MeasurableSet.univ, preimage_univ]
                                             -- ğŸ‰ no goals
#align measure_theory.measure.fst_univ MeasureTheory.Measure.fst_univ

@[simp] theorem fst_zero : fst (0 : Measure (Î± Ã— Î²)) = 0 := by simp [fst]
                                                               -- ğŸ‰ no goals

instance fst.instIsFiniteMeasure [IsFiniteMeasure Ï] : IsFiniteMeasure Ï.fst := by
  rw [fst]
  -- âŠ¢ IsFiniteMeasure (map Prod.fst Ï)
  infer_instance
  -- ğŸ‰ no goals
#align measure_theory.measure.fst.measure_theory.is_finite_measure MeasureTheory.Measure.fst.instIsFiniteMeasure

instance fst.instIsProbabilityMeasure [IsProbabilityMeasure Ï] : IsProbabilityMeasure Ï.fst where
  measure_univ := by
    rw [fst_univ]
    -- âŠ¢ â†‘â†‘Ï univ = 1
    exact measure_univ
    -- ğŸ‰ no goals
#align measure_theory.measure.fst.measure_theory.is_probability_measure MeasureTheory.Measure.fst.instIsProbabilityMeasure

@[simp]
lemma fst_prod [IsProbabilityMeasure Î½] : (Î¼.prod Î½).fst = Î¼ := by
  ext1 s hs
  -- âŠ¢ â†‘â†‘(fst (Measure.prod Î¼ Î½)) s = â†‘â†‘Î¼ s
  rw [fst_apply hs, â† prod_univ, prod_prod, measure_univ, mul_one]
  -- ğŸ‰ no goals

theorem fst_map_prod_mkâ‚€ {X : Î± â†’ Î²} {Y : Î± â†’ Î³} {Î¼ : Measure Î±}
    (hY : AEMeasurable Y Î¼) : (Î¼.map fun a => (X a, Y a)).fst = Î¼.map X := by
  by_cases hX : AEMeasurable X Î¼
  -- âŠ¢ fst (map (fun a => (X a, Y a)) Î¼) = map X Î¼
  Â· ext1 s hs
    -- âŠ¢ â†‘â†‘(fst (map (fun a => (X a, Y a)) Î¼)) s = â†‘â†‘(map X Î¼) s
    rw [Measure.fst_apply hs, Measure.map_apply_of_aemeasurable (hX.prod_mk hY) (measurable_fst hs),
      Measure.map_apply_of_aemeasurable hX hs, â† prod_univ, mk_preimage_prod, preimage_univ,
      inter_univ]
  Â· have : Â¬AEMeasurable (fun x â†¦ (X x, Y x)) Î¼ := by
      contrapose! hX; exact measurable_fst.comp_aemeasurable hX
    simp [map_of_not_aemeasurable, hX, this]
    -- ğŸ‰ no goals
#align measure_theory.measure.fst_map_prod_mkâ‚€ MeasureTheory.Measure.fst_map_prod_mkâ‚€

theorem fst_map_prod_mk {X : Î± â†’ Î²} {Y : Î± â†’ Î³} {Î¼ : Measure Î±}
    (hY : Measurable Y) : (Î¼.map fun a => (X a, Y a)).fst = Î¼.map X :=
  fst_map_prod_mkâ‚€ hY.aemeasurable
#align measure_theory.measure.fst_map_prod_mk MeasureTheory.Measure.fst_map_prod_mk

/-- Marginal measure on `Î²` obtained from a measure on `Ï` `Î± Ã— Î²`, defined by `Ï.map Prod.snd`. -/
noncomputable def snd (Ï : Measure (Î± Ã— Î²)) : Measure Î² :=
  Ï.map Prod.snd
#align measure_theory.measure.snd MeasureTheory.Measure.snd

theorem snd_apply {s : Set Î²} (hs : MeasurableSet s) : Ï.snd s = Ï (Prod.snd â»Â¹' s) := by
  rw [snd, Measure.map_apply measurable_snd hs]
  -- ğŸ‰ no goals
#align measure_theory.measure.snd_apply MeasureTheory.Measure.snd_apply

theorem snd_univ : Ï.snd univ = Ï univ := by rw [snd_apply MeasurableSet.univ, preimage_univ]
                                             -- ğŸ‰ no goals
#align measure_theory.measure.snd_univ MeasureTheory.Measure.snd_univ

@[simp] theorem snd_zero : snd (0 : Measure (Î± Ã— Î²)) = 0 := by simp [snd]
                                                               -- ğŸ‰ no goals

instance snd.instIsFiniteMeasure [IsFiniteMeasure Ï] : IsFiniteMeasure Ï.snd := by
  rw [snd]
  -- âŠ¢ IsFiniteMeasure (map Prod.snd Ï)
  infer_instance
  -- ğŸ‰ no goals
#align measure_theory.measure.snd.measure_theory.is_finite_measure MeasureTheory.Measure.snd.instIsFiniteMeasure

instance snd.instIsProbabilityMeasure [IsProbabilityMeasure Ï] : IsProbabilityMeasure Ï.snd where
  measure_univ := by
    rw [snd_univ]
    -- âŠ¢ â†‘â†‘Ï univ = 1
    exact measure_univ
    -- ğŸ‰ no goals
#align measure_theory.measure.snd.measure_theory.is_probability_measure MeasureTheory.Measure.snd.instIsProbabilityMeasure

@[simp]
lemma snd_prod [IsProbabilityMeasure Î¼] : (Î¼.prod Î½).snd = Î½ := by
  ext1 s hs
  -- âŠ¢ â†‘â†‘(snd (Measure.prod Î¼ Î½)) s = â†‘â†‘Î½ s
  rw [snd_apply hs, â† univ_prod, prod_prod, measure_univ, one_mul]
  -- ğŸ‰ no goals

theorem snd_map_prod_mkâ‚€ {X : Î± â†’ Î²} {Y : Î± â†’ Î³} {Î¼ : Measure Î±} (hX : AEMeasurable X Î¼) :
    (Î¼.map fun a => (X a, Y a)).snd = Î¼.map Y := by
  by_cases hY : AEMeasurable Y Î¼
  -- âŠ¢ snd (map (fun a => (X a, Y a)) Î¼) = map Y Î¼
  Â· ext1 s hs
    -- âŠ¢ â†‘â†‘(snd (map (fun a => (X a, Y a)) Î¼)) s = â†‘â†‘(map Y Î¼) s
    rw [Measure.snd_apply hs, Measure.map_apply_of_aemeasurable (hX.prod_mk hY) (measurable_snd hs),
      Measure.map_apply_of_aemeasurable hY hs, â† univ_prod, mk_preimage_prod, preimage_univ,
      univ_inter]
  Â· have : Â¬AEMeasurable (fun x â†¦ (X x, Y x)) Î¼ := by
      contrapose! hY; exact measurable_snd.comp_aemeasurable hY
    simp [map_of_not_aemeasurable, hY, this]
    -- ğŸ‰ no goals

#align measure_theory.measure.snd_map_prod_mkâ‚€ MeasureTheory.Measure.snd_map_prod_mkâ‚€

theorem snd_map_prod_mk {X : Î± â†’ Î²} {Y : Î± â†’ Î³} {Î¼ : Measure Î±} (hX : Measurable X) :
    (Î¼.map fun a => (X a, Y a)).snd = Î¼.map Y :=
  snd_map_prod_mkâ‚€ hX.aemeasurable
#align measure_theory.measure.snd_map_prod_mk MeasureTheory.Measure.snd_map_prod_mk

end Measure

end MeasureTheory
