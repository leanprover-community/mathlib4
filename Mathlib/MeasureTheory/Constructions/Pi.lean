/-
Copyright (c) 2020 Floris van Doorn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Floris van Doorn
-/
import Mathlib.MeasureTheory.Constructions.Prod.Basic
import Mathlib.MeasureTheory.Group.Measure
import Mathlib.Topology.Constructions

#align_import measure_theory.constructions.pi from "leanprover-community/mathlib"@"fd5edc43dc4f10b85abfe544b88f82cf13c5f844"

/-!
# Product measures

In this file we define and prove properties about finite products of measures
(and at some point, countable products of measures).

## Main definition

* `MeasureTheory.Measure.pi`: The product of finitely many Ïƒ-finite measures.
  Given `Î¼ : (i : Î¹) â†’ Measure (Î± i)` for `[Fintype Î¹]` it has type `Measure ((i : Î¹) â†’ Î± i)`.

To apply Fubini along some subset of the variables, use
`MeasureTheory.measurePreserving_piEquivPiSubtypeProd` to reduce to the situation of a product
of two measures: this lemma states that the bijection
`MeasurableEquiv.piEquivPiSubtypeProd Î± p` between `(âˆ€ i : Î¹, Î± i)` and
`((i : {i // p i}) â†’ Î± i) Ã— ((i : {i // Â¬ p i}) â†’ Î± i)` maps a product measure to a direct product
of product measures, to which one can apply the usual Fubini for direct product of measures.

## Implementation Notes

We define `MeasureTheory.OuterMeasure.pi`, the product of finitely many outer measures, as the
maximal outer measure `n` with the property that `n (pi univ s) â‰¤ âˆ i, m i (s i)`,
where `pi univ s` is the product of the sets `{s i | i : Î¹}`.

We then show that this induces a product of measures, called `MeasureTheory.Measure.pi`.
For a collection of Ïƒ-finite measures `Î¼` and a collection of measurable sets `s` we show that
`Measure.pi Î¼ (pi univ s) = âˆ i, m i (s i)`. To do this, we follow the following steps:
* We know that there is some ordering on `Î¹`, given by an element of `[Countable Î¹]`.
* Using this, we have an equivalence `MeasurableEquiv.piMeasurableEquivTProd` between
  `âˆ€ Î¹, Î± i` and an iterated product of `Î± i`, called `List.tprod Î± l` for some list `l`.
* On this iterated product we can easily define a product measure `MeasureTheory.Measure.tprod`
  by iterating `MeasureTheory.Measure.prod`
* Using the previous two steps we construct `MeasureTheory.Measure.pi'` on `(i : Î¹) â†’ Î± i` for
  countable `Î¹`.
* We know that `MeasureTheory.Measure.pi'` sends products of sets to products of measures, and
  since `MeasureTheory.Measure.pi` is the maximal such measure (or at least, it comes from an outer
  measure which is the maximal such outer measure), we get the same rule for
  `MeasureTheory.Measure.pi`.

## Tags

finitary product measure

-/


noncomputable section

open Function Set MeasureTheory.OuterMeasure Filter MeasurableSpace Encodable

open scoped Classical BigOperators Topology ENNReal

universe u v

variable {Î¹ Î¹' : Type*} {Î± : Î¹ â†’ Type*}

/-! We start with some measurability properties -/


/-- Boxes formed by Ï€-systems form a Ï€-system. -/
theorem IsPiSystem.pi {C : âˆ€ i, Set (Set (Î± i))} (hC : âˆ€ i, IsPiSystem (C i)) :
    IsPiSystem (pi univ '' pi univ C) := by
  rintro _ âŸ¨sâ‚, hsâ‚, rflâŸ© _ âŸ¨sâ‚‚, hsâ‚‚, rflâŸ© hst
  -- âŠ¢ Set.pi univ sâ‚ âˆ© Set.pi univ sâ‚‚ âˆˆ Set.pi univ '' Set.pi univ C
  rw [â† pi_inter_distrib] at hst âŠ¢; rw [univ_pi_nonempty_iff] at hst
  -- âŠ¢ (Set.pi univ fun i => sâ‚ i âˆ© sâ‚‚ i) âˆˆ Set.pi univ '' Set.pi univ C
                                    -- âŠ¢ (Set.pi univ fun i => sâ‚ i âˆ© sâ‚‚ i) âˆˆ Set.pi univ '' Set.pi univ C
  exact mem_image_of_mem _ fun i _ => hC i _ (hsâ‚ i (mem_univ i)) _ (hsâ‚‚ i (mem_univ i)) (hst i)
  -- ğŸ‰ no goals
#align is_pi_system.pi IsPiSystem.pi

/-- Boxes form a Ï€-system. -/
theorem isPiSystem_pi [âˆ€ i, MeasurableSpace (Î± i)] :
    IsPiSystem (pi univ '' pi univ fun i => { s : Set (Î± i) | MeasurableSet s }) :=
  IsPiSystem.pi fun _ => isPiSystem_measurableSet
#align is_pi_system_pi isPiSystem_pi

section Finite

variable [Finite Î¹] [Finite Î¹']

/-- Boxes of countably spanning sets are countably spanning. -/
theorem IsCountablySpanning.pi {C : âˆ€ i, Set (Set (Î± i))} (hC : âˆ€ i, IsCountablySpanning (C i)) :
    IsCountablySpanning (pi univ '' pi univ C) := by
  choose s h1s h2s using hC
  -- âŠ¢ IsCountablySpanning (Set.pi univ '' Set.pi univ C)
  cases nonempty_encodable (Î¹ â†’ â„•)
  -- âŠ¢ IsCountablySpanning (Set.pi univ '' Set.pi univ C)
  let e : â„• â†’ Î¹ â†’ â„• := fun n => (@decode (Î¹ â†’ â„•) _ n).iget
  -- âŠ¢ IsCountablySpanning (Set.pi univ '' Set.pi univ C)
  refine' âŸ¨fun n => Set.pi univ fun i => s i (e n i), fun n =>
    mem_image_of_mem _ fun i _ => h1s i _, _âŸ©
  simp_rw [(surjective_decode_iget (Î¹ â†’ â„•)).iUnion_comp fun x => Set.pi univ fun i => s i (x i),
    iUnion_univ_pi s, h2s, pi_univ]
#align is_countably_spanning.pi IsCountablySpanning.pi

/-- The product of generated Ïƒ-algebras is the one generated by boxes, if both generating sets
  are countably spanning. -/
theorem generateFrom_pi_eq {C : âˆ€ i, Set (Set (Î± i))} (hC : âˆ€ i, IsCountablySpanning (C i)) :
    (@MeasurableSpace.pi _ _ fun i => generateFrom (C i)) =
    generateFrom (pi univ '' pi univ C) := by
  cases nonempty_encodable Î¹
  -- âŠ¢ MeasurableSpace.pi = generateFrom (Set.pi univ '' Set.pi univ C)
  apply le_antisymm
  -- âŠ¢ MeasurableSpace.pi â‰¤ generateFrom (Set.pi univ '' Set.pi univ C)
  Â· refine' iSup_le _; intro i; rw [comap_generateFrom]
    -- âŠ¢ âˆ€ (i : Î¹), MeasurableSpace.comap (fun b => b i) ((fun i => generateFrom (C i â€¦
                       -- âŠ¢ MeasurableSpace.comap (fun b => b i) ((fun i => generateFrom (C i)) i) â‰¤ gen â€¦
                                -- âŠ¢ generateFrom ((preimage fun b => b i) '' C i) â‰¤ generateFrom (Set.pi univ '' â€¦
    apply generateFrom_le; rintro _ âŸ¨s, hs, rflâŸ©; dsimp
    -- âŠ¢ âˆ€ (t : Set ((a : Î¹) â†’ (fun i => Î± i) a)), t âˆˆ (preimage fun b => b i) '' C i â€¦
                           -- âŠ¢ MeasurableSet ((fun b => b i) â»Â¹' s)
                                                  -- âŠ¢ MeasurableSet ((fun b => b i) â»Â¹' s)
    choose t h1t h2t using hC
    -- âŠ¢ MeasurableSet ((fun b => b i) â»Â¹' s)
    simp_rw [eval_preimage, â† h2t]
    -- âŠ¢ MeasurableSet (Set.pi univ (update (fun i => â‹ƒ (n : â„•), t i n) i s))
    rw [â† @iUnion_const _ â„• _ s]
    -- âŠ¢ MeasurableSet (Set.pi univ (update (fun i => â‹ƒ (n : â„•), t i n) i (â‹ƒ (x : â„•), â€¦
    have : Set.pi univ (update (fun i' : Î¹ => iUnion (t i')) i (â‹ƒ _ : â„•, s)) =
        Set.pi univ fun k => â‹ƒ j : â„•,
        @update Î¹ (fun i' => Set (Î± i')) _ (fun i' => t i' j) i s k := by
      ext; simp_rw [mem_univ_pi]; apply forall_congr'; intro i'
      by_cases h : i' = i
      Â· subst h; simp
      Â· rw [â† Ne.def] at h; simp [h]
    rw [this, â† iUnion_univ_pi]
    -- âŠ¢ MeasurableSet (â‹ƒ (x : Î¹ â†’ â„•), Set.pi univ fun i_1 => update (fun i' => t i'  â€¦
    apply MeasurableSet.iUnion
    -- âŠ¢ âˆ€ (b : Î¹ â†’ â„•), MeasurableSet (Set.pi univ fun i_1 => update (fun i' => t i'  â€¦
    intro n; apply measurableSet_generateFrom
    -- âŠ¢ MeasurableSet (Set.pi univ fun i_1 => update (fun i' => t i' (n i_1)) i s i_1)
             -- âŠ¢ (Set.pi univ fun i_1 => update (fun i' => t i' (n i_1)) i s i_1) âˆˆ Set.pi un â€¦
    apply mem_image_of_mem; intro j _; dsimp only
    -- âŠ¢ (fun i_1 => update (fun i' => t i' (n i_1)) i s i_1) âˆˆ Set.pi univ C
                            -- âŠ¢ (fun i_1 => update (fun i' => t i' (n i_1)) i s i_1) j âˆˆ C j
                                       -- âŠ¢ update (fun i' => t i' (n j)) i s j âˆˆ C j
    by_cases h : j = i; subst h; rwa [update_same]; rw [update_noteq h]; apply h1t
    -- âŠ¢ update (fun i' => t i' (n j)) i s j âˆˆ C j
                        -- âŠ¢ update (fun i' => t i' (n j)) j s j âˆˆ C j
                                 -- âŠ¢ update (fun i' => t i' (n j)) i s j âˆˆ C j
                                                    -- âŠ¢ t j (n j) âˆˆ C j
                                                                         -- ğŸ‰ no goals
  Â· apply generateFrom_le; rintro _ âŸ¨s, hs, rflâŸ©
    -- âŠ¢ âˆ€ (t : Set ((i : Î¹) â†’ Î± i)), t âˆˆ Set.pi univ '' Set.pi univ C â†’ MeasurableSe â€¦
                           -- âŠ¢ MeasurableSet (Set.pi univ s)
    rw [univ_pi_eq_iInter]; apply MeasurableSet.iInter; intro i
    -- âŠ¢ MeasurableSet (â‹‚ (i : Î¹), eval i â»Â¹' s i)
                            -- âŠ¢ âˆ€ (b : Î¹), MeasurableSet (eval b â»Â¹' s b)
                                                        -- âŠ¢ MeasurableSet (eval i â»Â¹' s i)
    apply @measurable_pi_apply _ _ (fun i => generateFrom (C i))
    -- âŠ¢ MeasurableSet (s i)
    exact measurableSet_generateFrom (hs i (mem_univ i))
    -- ğŸ‰ no goals
#align generate_from_pi_eq generateFrom_pi_eq

/-- If `C` and `D` generate the Ïƒ-algebras on `Î±` resp. `Î²`, then rectangles formed by `C` and `D`
  generate the Ïƒ-algebra on `Î± Ã— Î²`. -/
theorem generateFrom_eq_pi [h : âˆ€ i, MeasurableSpace (Î± i)] {C : âˆ€ i, Set (Set (Î± i))}
    (hC : âˆ€ i, generateFrom (C i) = h i) (h2C : âˆ€ i, IsCountablySpanning (C i)) :
    generateFrom (pi univ '' pi univ C) = MeasurableSpace.pi := by
  rw [â† funext hC, generateFrom_pi_eq h2C]
  -- ğŸ‰ no goals
#align generate_from_eq_pi generateFrom_eq_pi

/-- The product Ïƒ-algebra is generated from boxes, i.e. `s Ã—Ë¢ t` for sets `s : set Î±` and
  `t : set Î²`. -/
theorem generateFrom_pi [âˆ€ i, MeasurableSpace (Î± i)] :
    generateFrom (pi univ '' pi univ fun i => { s : Set (Î± i) | MeasurableSet s }) =
      MeasurableSpace.pi :=
  generateFrom_eq_pi (fun _ => generateFrom_measurableSet) fun _ =>
    isCountablySpanning_measurableSet
#align generate_from_pi generateFrom_pi

end Finite

namespace MeasureTheory

variable [Fintype Î¹] {m : âˆ€ i, OuterMeasure (Î± i)}

/-- An upper bound for the measure in a finite product space.
  It is defined to by taking the image of the set under all projections, and taking the product
  of the measures of these images.
  For measurable boxes it is equal to the correct measure. -/
@[simp]
def piPremeasure (m : âˆ€ i, OuterMeasure (Î± i)) (s : Set (âˆ€ i, Î± i)) : â„â‰¥0âˆ :=
  âˆ i, m i (eval i '' s)
#align measure_theory.pi_premeasure MeasureTheory.piPremeasure

theorem piPremeasure_pi {s : âˆ€ i, Set (Î± i)} (hs : (pi univ s).Nonempty) :
    piPremeasure m (pi univ s) = âˆ i, m i (s i) := by simp [hs, piPremeasure]
                                                      -- ğŸ‰ no goals
#align measure_theory.pi_premeasure_pi MeasureTheory.piPremeasure_pi

theorem piPremeasure_pi' {s : âˆ€ i, Set (Î± i)} : piPremeasure m (pi univ s) = âˆ i, m i (s i) := by
  cases isEmpty_or_nonempty Î¹
  -- âŠ¢ piPremeasure m (Set.pi univ s) = âˆ i : Î¹, â†‘(m i) (s i)
  Â· simp [piPremeasure]
    -- ğŸ‰ no goals
  cases' (pi univ s).eq_empty_or_nonempty with h h
  -- âŠ¢ piPremeasure m (Set.pi univ s) = âˆ i : Î¹, â†‘(m i) (s i)
  Â· rcases univ_pi_eq_empty_iff.mp h with âŸ¨i, hiâŸ©
    -- âŠ¢ piPremeasure m (Set.pi univ s) = âˆ i : Î¹, â†‘(m i) (s i)
    have : âˆƒ i, m i (s i) = 0 := âŸ¨i, by simp [hi]âŸ©
    -- âŠ¢ piPremeasure m (Set.pi univ s) = âˆ i : Î¹, â†‘(m i) (s i)
    simpa [h, Finset.card_univ, zero_pow (Fintype.card_pos_iff.mpr â€¹_â€º), @eq_comm _ (0 : â„â‰¥0âˆ),
      Finset.prod_eq_zero_iff, piPremeasure]
  Â· simp [h, piPremeasure]
    -- ğŸ‰ no goals
#align measure_theory.pi_premeasure_pi' MeasureTheory.piPremeasure_pi'

theorem piPremeasure_pi_mono {s t : Set (âˆ€ i, Î± i)} (h : s âŠ† t) :
    piPremeasure m s â‰¤ piPremeasure m t :=
  Finset.prod_le_prod' fun i _ => (m i).mono' (image_subset _ h)
#align measure_theory.pi_premeasure_pi_mono MeasureTheory.piPremeasure_pi_mono

theorem piPremeasure_pi_eval {s : Set (âˆ€ i, Î± i)} :
    piPremeasure m (pi univ fun i => eval i '' s) = piPremeasure m s := by
  simp only [eval, piPremeasure_pi']; rfl
  -- âŠ¢ âˆ i : Î¹, â†‘(m i) ((fun a => a i) '' s) = piPremeasure m s
                                      -- ğŸ‰ no goals
#align measure_theory.pi_premeasure_pi_eval MeasureTheory.piPremeasure_pi_eval

namespace OuterMeasure

/-- `OuterMeasure.pi m` is the finite product of the outer measures `{m i | i : Î¹}`.
  It is defined to be the maximal outer measure `n` with the property that
  `n (pi univ s) â‰¤ âˆ i, m i (s i)`, where `pi univ s` is the product of the sets
  `{s i | i : Î¹}`. -/
protected def pi (m : âˆ€ i, OuterMeasure (Î± i)) : OuterMeasure (âˆ€ i, Î± i) :=
  boundedBy (piPremeasure m)
#align measure_theory.outer_measure.pi MeasureTheory.OuterMeasure.pi

theorem pi_pi_le (m : âˆ€ i, OuterMeasure (Î± i)) (s : âˆ€ i, Set (Î± i)) :
    OuterMeasure.pi m (pi univ s) â‰¤ âˆ i, m i (s i) := by
  cases' (pi univ s).eq_empty_or_nonempty with h h; simp [h]
  -- âŠ¢ â†‘(OuterMeasure.pi m) (Set.pi univ s) â‰¤ âˆ i : Î¹, â†‘(m i) (s i)
                                                    -- âŠ¢ â†‘(OuterMeasure.pi m) (Set.pi univ s) â‰¤ âˆ i : Î¹, â†‘(m i) (s i)
  exact (boundedBy_le _).trans_eq (piPremeasure_pi h)
  -- ğŸ‰ no goals
#align measure_theory.outer_measure.pi_pi_le MeasureTheory.OuterMeasure.pi_pi_le

theorem le_pi {m : âˆ€ i, OuterMeasure (Î± i)} {n : OuterMeasure (âˆ€ i, Î± i)} :
    n â‰¤ OuterMeasure.pi m â†”
      âˆ€ s : âˆ€ i, Set (Î± i), (pi univ s).Nonempty â†’ n (pi univ s) â‰¤ âˆ i, m i (s i) := by
  rw [OuterMeasure.pi, le_boundedBy']; constructor
  -- âŠ¢ (âˆ€ (s : Set ((i : Î¹) â†’ Î± i)), Set.Nonempty s â†’ â†‘n s â‰¤ piPremeasure m s) â†” âˆ€  â€¦
                                       -- âŠ¢ (âˆ€ (s : Set ((i : Î¹) â†’ Î± i)), Set.Nonempty s â†’ â†‘n s â‰¤ piPremeasure m s) â†’ âˆ€  â€¦
  Â· intro h s hs; refine' (h _ hs).trans_eq (piPremeasure_pi hs)
    -- âŠ¢ â†‘n (Set.pi univ s) â‰¤ âˆ i : Î¹, â†‘(m i) (s i)
                  -- ğŸ‰ no goals
  Â· intro h s hs; refine' le_trans (n.mono <| subset_pi_eval_image univ s) (h _ _)
    -- âŠ¢ â†‘n s â‰¤ piPremeasure m s
                  -- âŠ¢ Set.Nonempty (Set.pi univ fun i => eval i '' s)
    simp [univ_pi_nonempty_iff, hs]
    -- ğŸ‰ no goals
#align measure_theory.outer_measure.le_pi MeasureTheory.OuterMeasure.le_pi

end OuterMeasure

namespace Measure

variable [âˆ€ i, MeasurableSpace (Î± i)] (Î¼ : âˆ€ i, Measure (Î± i))

section Tprod

open List

variable {Î´ : Type*} {Ï€ : Î´ â†’ Type*} [âˆ€ x, MeasurableSpace (Ï€ x)]

-- for some reason the equation compiler doesn't like this definition
/-- A product of measures in `tprod Î± l`. -/
protected def tprod (l : List Î´) (Î¼ : âˆ€ i, Measure (Ï€ i)) : Measure (TProd Ï€ l) := by
  induction' l with i l ih
  -- âŠ¢ Measure (TProd Ï€ [])
  Â· exact dirac PUnit.unit
    -- ğŸ‰ no goals
  Â· have := (Î¼ i).prod (Î± := Ï€ i) ih
    -- âŠ¢ Measure (TProd Ï€ (i :: l))
    exact this
    -- ğŸ‰ no goals
#align measure_theory.measure.tprod MeasureTheory.Measure.tprod

@[simp]
theorem tprod_nil (Î¼ : âˆ€ i, Measure (Ï€ i)) : Measure.tprod [] Î¼ = dirac PUnit.unit :=
  rfl
#align measure_theory.measure.tprod_nil MeasureTheory.Measure.tprod_nil

@[simp]
theorem tprod_cons (i : Î´) (l : List Î´) (Î¼ : âˆ€ i, Measure (Ï€ i)) :
    Measure.tprod (i :: l) Î¼ = (Î¼ i).prod (Measure.tprod l Î¼) :=
  rfl
#align measure_theory.measure.tprod_cons MeasureTheory.Measure.tprod_cons

instance sigmaFinite_tprod (l : List Î´) (Î¼ : âˆ€ i, Measure (Ï€ i)) [âˆ€ i, SigmaFinite (Î¼ i)] :
    SigmaFinite (Measure.tprod l Î¼) := by
  induction l with
  | nil => rw [tprod_nil]; infer_instance
  | cons i l ih => rw [tprod_cons]; exact @prod.instSigmaFinite _ _ _ _ _ _ ih _
#align measure_theory.measure.sigma_finite_tprod MeasureTheory.Measure.sigmaFinite_tprod

theorem tprod_tprod (l : List Î´) (Î¼ : âˆ€ i, Measure (Ï€ i)) [âˆ€ i, SigmaFinite (Î¼ i)]
    (s : âˆ€ i, Set (Ï€ i)) :
    Measure.tprod l Î¼ (Set.tprod l s) = (l.map fun i => (Î¼ i) (s i)).prod := by
  induction' l with i l ih; Â· simp
  -- âŠ¢ â†‘â†‘(Measure.tprod [] Î¼) (Set.tprod [] s) = List.prod (List.map (fun i => â†‘â†‘(Î¼ â€¦
                              -- ğŸ‰ no goals
  rw [tprod_cons, Set.tprod, prod_prod, map_cons, prod_cons, ih]
  -- ğŸ‰ no goals
#align measure_theory.measure.tprod_tprod MeasureTheory.Measure.tprod_tprod

end Tprod

section Encodable

open List MeasurableEquiv

variable [Encodable Î¹]

/-- The product measure on an encodable finite type, defined by mapping `Measure.tprod` along the
  equivalence `MeasurableEquiv.piMeasurableEquivTProd`.
  The definition `MeasureTheory.Measure.pi` should be used instead of this one. -/
def pi' : Measure (âˆ€ i, Î± i) :=
  Measure.map (TProd.elim' mem_sortedUniv) (Measure.tprod (sortedUniv Î¹) Î¼)
#align measure_theory.measure.pi' MeasureTheory.Measure.pi'

theorem pi'_pi [âˆ€ i, SigmaFinite (Î¼ i)] (s : âˆ€ i, Set (Î± i)) :
    pi' Î¼ (pi univ s) = âˆ i, Î¼ i (s i) := by
  rw [pi']
  -- âŠ¢ â†‘â†‘(map (TProd.elim' (_ : âˆ€ (x : Î¹), x âˆˆ sortedUniv Î¹)) (Measure.tprod (sorte â€¦
  simp only [TProd.elim'] -- Porting note: new step
  -- âŠ¢ â†‘â†‘(map (fun v i => TProd.elim v (_ : i âˆˆ sortedUniv Î¹)) (Measure.tprod (sort â€¦
  erw [â† MeasurableEquiv.piMeasurableEquivTProd_symm_apply, MeasurableEquiv.map_apply,
    MeasurableEquiv.piMeasurableEquivTProd_symm_apply, elim_preimage_pi, tprod_tprod _ Î¼, â†
    List.prod_toFinset, sortedUniv_toFinset] <;>
  exact sortedUniv_nodup Î¹
  -- ğŸ‰ no goals
  -- ğŸ‰ no goals
  -- ğŸ‰ no goals
#align measure_theory.measure.pi'_pi MeasureTheory.Measure.pi'_pi

end Encodable

theorem pi_caratheodory :
    MeasurableSpace.pi â‰¤ (OuterMeasure.pi fun i => (Î¼ i).toOuterMeasure).caratheodory := by
  refine' iSup_le _
  -- âŠ¢ âˆ€ (i : Î¹), MeasurableSpace.comap (fun b => b i) ((fun a => instâœ a) i) â‰¤ Out â€¦
  intro i s hs
  -- âŠ¢ MeasurableSet s
  rw [MeasurableSpace.comap] at hs
  -- âŠ¢ MeasurableSet s
  rcases hs with âŸ¨s, hs, rflâŸ©
  -- âŠ¢ MeasurableSet ((fun b => b i) â»Â¹' s)
  apply boundedBy_caratheodory
  -- âŠ¢ âˆ€ (t : Set ((a : Î¹) â†’ Î± a)), piPremeasure (fun i => â†‘(Î¼ i)) (t âˆ© (fun b => b â€¦
  intro t
  -- âŠ¢ piPremeasure (fun i => â†‘(Î¼ i)) (t âˆ© (fun b => b i) â»Â¹' s) + piPremeasure (fu â€¦
  simp_rw [piPremeasure]
  -- âŠ¢ âˆ x : Î¹, â†‘â†‘(Î¼ x) (eval x '' (t âˆ© (fun b => b i) â»Â¹' s)) + âˆ x : Î¹, â†‘â†‘(Î¼ x) ( â€¦
  refine' Finset.prod_add_prod_le' (Finset.mem_univ i) _ _ _
  Â· simp [image_inter_preimage, image_diff_preimage, measure_inter_add_diff _ hs, le_refl]
    -- ğŸ‰ no goals
  Â· rintro j - _; apply mono'; apply image_subset; apply inter_subset_left
    -- âŠ¢ â†‘â†‘(Î¼ j) (eval j '' (t âˆ© (fun b => b i) â»Â¹' s)) â‰¤ â†‘â†‘(Î¼ j) (eval j '' t)
                  -- âŠ¢ eval j '' (t âˆ© (fun b => b i) â»Â¹' s) âŠ† eval j '' t
                               -- âŠ¢ t âˆ© (fun b => b i) â»Â¹' s âŠ† t
                                                   -- ğŸ‰ no goals
  Â· rintro j - _; apply mono'; apply image_subset; apply diff_subset
    -- âŠ¢ â†‘â†‘(Î¼ j) (eval j '' (t \ (fun b => b i) â»Â¹' s)) â‰¤ â†‘â†‘(Î¼ j) (eval j '' t)
                  -- âŠ¢ eval j '' (t \ (fun b => b i) â»Â¹' s) âŠ† eval j '' t
                               -- âŠ¢ t \ (fun b => b i) â»Â¹' s âŠ† t
                                                   -- ğŸ‰ no goals
#align measure_theory.measure.pi_caratheodory MeasureTheory.Measure.pi_caratheodory

/-- `Measure.pi Î¼` is the finite product of the measures `{Î¼ i | i : Î¹}`.
  It is defined to be measure corresponding to `MeasureTheory.OuterMeasure.pi`. -/
protected irreducible_def pi : Measure (âˆ€ i, Î± i) :=
  toMeasure (OuterMeasure.pi fun i => (Î¼ i).toOuterMeasure) (pi_caratheodory Î¼)
#align measure_theory.measure.pi MeasureTheory.Measure.pi

-- porting note: moved from below so that instances about `Measure.pi` and `MeasureSpace.pi`
-- go together
instance _root_.MeasureTheory.MeasureSpace.pi {Î± : Î¹ â†’ Type*} [âˆ€ i, MeasureSpace (Î± i)] :
    MeasureSpace (âˆ€ i, Î± i) :=
  âŸ¨Measure.pi fun _ => volumeâŸ©
#align measure_theory.measure_space.pi MeasureTheory.MeasureSpace.pi

theorem pi_pi_aux [âˆ€ i, SigmaFinite (Î¼ i)] (s : âˆ€ i, Set (Î± i)) (hs : âˆ€ i, MeasurableSet (s i)) :
    Measure.pi Î¼ (pi univ s) = âˆ i, Î¼ i (s i) := by
  refine' le_antisymm _ _
  -- âŠ¢ â†‘â†‘(Measure.pi Î¼) (Set.pi univ s) â‰¤ âˆ i : Î¹, â†‘â†‘(Î¼ i) (s i)
  Â· rw [Measure.pi, toMeasure_apply _ _ (MeasurableSet.pi countable_univ fun i _ => hs i)]
    -- âŠ¢ â†‘(OuterMeasure.pi fun i => â†‘(Î¼ i)) (Set.pi univ fun i => s i) â‰¤ âˆ i : Î¹, â†‘â†‘( â€¦
    apply OuterMeasure.pi_pi_le
    -- ğŸ‰ no goals
  Â· haveI : Encodable Î¹ := Fintype.toEncodable Î¹
    -- âŠ¢ âˆ i : Î¹, â†‘â†‘(Î¼ i) (s i) â‰¤ â†‘â†‘(Measure.pi Î¼) (Set.pi univ s)
    simp_rw [â† pi'_pi Î¼ s, Measure.pi,
      toMeasure_apply _ _ (MeasurableSet.pi countable_univ fun i _ => hs i)]
    suffices (pi' Î¼).toOuterMeasure â‰¤ OuterMeasure.pi fun i => (Î¼ i).toOuterMeasure by exact this _
    -- âŠ¢ â†‘(pi' Î¼) â‰¤ OuterMeasure.pi fun i => â†‘(Î¼ i)
    clear hs s
    -- âŠ¢ â†‘(pi' Î¼) â‰¤ OuterMeasure.pi fun i => â†‘(Î¼ i)
    rw [OuterMeasure.le_pi]
    -- âŠ¢ âˆ€ (s : (i : Î¹) â†’ Set (Î± i)), Set.Nonempty (Set.pi univ s) â†’ â†‘â†‘(pi' Î¼) (Set.p â€¦
    intro s _
    -- âŠ¢ â†‘â†‘(pi' Î¼) (Set.pi univ s) â‰¤ âˆ i : Î¹, â†‘â†‘(Î¼ i) (s i)
    exact (pi'_pi Î¼ s).le
    -- ğŸ‰ no goals
#align measure_theory.measure.pi_pi_aux MeasureTheory.Measure.pi_pi_aux

variable {Î¼}

/-- `Measure.pi Î¼` has finite spanning sets in rectangles of finite spanning sets. -/
def FiniteSpanningSetsIn.pi {C : âˆ€ i, Set (Set (Î± i))}
    (hÎ¼ : âˆ€ i, (Î¼ i).FiniteSpanningSetsIn (C i)) :
    (Measure.pi Î¼).FiniteSpanningSetsIn (pi univ '' pi univ C) := by
  haveI := fun i => (hÎ¼ i).sigmaFinite
  -- âŠ¢ FiniteSpanningSetsIn (Measure.pi Î¼) (Set.pi univ '' Set.pi univ C)
  haveI := Fintype.toEncodable Î¹
  -- âŠ¢ FiniteSpanningSetsIn (Measure.pi Î¼) (Set.pi univ '' Set.pi univ C)
  refine' âŸ¨fun n => Set.pi univ fun i => (hÎ¼ i).set ((@decode (Î¹ â†’ â„•) _ n).iget i),
    fun n => _, fun n => _, _âŸ© <;>
  -- TODO (kmill) If this let comes before the refine, while the noncomputability checker
  -- correctly sees this definition is computable, the Lean VM fails to see the binding is
  -- computationally irrelevant. The `noncomputable section` doesn't help because all it does
  -- is insert `noncomputable` for you when necessary.
  let e : â„• â†’ Î¹ â†’ â„• := fun n => (@decode (Î¹ â†’ â„•) _ n).iget
  -- âŠ¢ (fun n => Set.pi univ fun i => FiniteSpanningSetsIn.set (hÎ¼ i) (Option.iget  â€¦
  -- âŠ¢ â†‘â†‘(Measure.pi Î¼) ((fun n => Set.pi univ fun i => FiniteSpanningSetsIn.set (h â€¦
  -- âŠ¢ â‹ƒ (i : â„•), (fun n => Set.pi univ fun i => FiniteSpanningSetsIn.set (hÎ¼ i) (O â€¦
  Â· refine' mem_image_of_mem _ fun i _ => (hÎ¼ i).set_mem _
    -- ğŸ‰ no goals
  Â· calc
      Measure.pi Î¼ (Set.pi univ fun i => (hÎ¼ i).set (e n i)) â‰¤
          Measure.pi Î¼ (Set.pi univ fun i => toMeasurable (Î¼ i) ((hÎ¼ i).set (e n i))) :=
        measure_mono (pi_mono fun i _ => subset_toMeasurable _ _)
      _ = âˆ i, Î¼ i (toMeasurable (Î¼ i) ((hÎ¼ i).set (e n i))) :=
        (pi_pi_aux Î¼ _ fun i => measurableSet_toMeasurable _ _)
      _ = âˆ i, Î¼ i ((hÎ¼ i).set (e n i)) := by simp only [measure_toMeasurable]
      _ < âˆ := ENNReal.prod_lt_top fun i _ => ((hÎ¼ i).finite _).ne
  Â· simp_rw [(surjective_decode_iget (Î¹ â†’ â„•)).iUnion_comp fun x =>
        Set.pi univ fun i => (hÎ¼ i).set (x i),
      iUnion_univ_pi fun i => (hÎ¼ i).set, (hÎ¼ _).spanning, Set.pi_univ]
#align measure_theory.measure.finite_spanning_sets_in.pi MeasureTheory.Measure.FiniteSpanningSetsIn.pi

/-- A measure on a finite product space equals the product measure if they are equal on rectangles
  with as sides sets that generate the corresponding Ïƒ-algebras. -/
theorem pi_eq_generateFrom {C : âˆ€ i, Set (Set (Î± i))}
    (hC : âˆ€ i, generateFrom (C i) = by apply_assumption) (h2C : âˆ€ i, IsPiSystem (C i))
                                       -- ğŸ‰ no goals
    (h3C : âˆ€ i, (Î¼ i).FiniteSpanningSetsIn (C i)) {Î¼Î½ : Measure (âˆ€ i, Î± i)}
    (hâ‚ : âˆ€ s : âˆ€ i, Set (Î± i), (âˆ€ i, s i âˆˆ C i) â†’ Î¼Î½ (pi univ s) = âˆ i, Î¼ i (s i)) :
    Measure.pi Î¼ = Î¼Î½ := by
  have h4C : âˆ€ (i) (s : Set (Î± i)), s âˆˆ C i â†’ MeasurableSet s := by
    intro i s hs; rw [â† hC]; exact measurableSet_generateFrom hs
  refine'
    (FiniteSpanningSetsIn.pi h3C).ext
      (generateFrom_eq_pi hC fun i => (h3C i).isCountablySpanning).symm (IsPiSystem.pi h2C) _
  rintro _ âŸ¨s, hs, rflâŸ©
  -- âŠ¢ â†‘â†‘(Measure.pi Î¼) (Set.pi univ s) = â†‘â†‘Î¼Î½ (Set.pi univ s)
  rw [mem_univ_pi] at hs
  -- âŠ¢ â†‘â†‘(Measure.pi Î¼) (Set.pi univ s) = â†‘â†‘Î¼Î½ (Set.pi univ s)
  haveI := fun i => (h3C i).sigmaFinite
  -- âŠ¢ â†‘â†‘(Measure.pi Î¼) (Set.pi univ s) = â†‘â†‘Î¼Î½ (Set.pi univ s)
  simp_rw [hâ‚ s hs, pi_pi_aux Î¼ s fun i => h4C i _ (hs i)]
  -- ğŸ‰ no goals
#align measure_theory.measure.pi_eq_generate_from MeasureTheory.Measure.pi_eq_generateFrom

variable [âˆ€ i, SigmaFinite (Î¼ i)]

/-- A measure on a finite product space equals the product measure if they are equal on
  rectangles. -/
theorem pi_eq {Î¼' : Measure (âˆ€ i, Î± i)}
    (h : âˆ€ s : âˆ€ i, Set (Î± i), (âˆ€ i, MeasurableSet (s i)) â†’ Î¼' (pi univ s) = âˆ i, Î¼ i (s i)) :
    Measure.pi Î¼ = Î¼' :=
  pi_eq_generateFrom (fun _ => generateFrom_measurableSet) (fun _ => isPiSystem_measurableSet)
    (fun i => (Î¼ i).toFiniteSpanningSetsIn) h
#align measure_theory.measure.pi_eq MeasureTheory.Measure.pi_eq

variable (Î¼)

theorem pi'_eq_pi [Encodable Î¹] : pi' Î¼ = Measure.pi Î¼ :=
  Eq.symm <| pi_eq fun s _ => pi'_pi Î¼ s
#align measure_theory.measure.pi'_eq_pi MeasureTheory.Measure.pi'_eq_pi

@[simp]
theorem pi_pi (s : âˆ€ i, Set (Î± i)) : Measure.pi Î¼ (pi univ s) = âˆ i, Î¼ i (s i) := by
  haveI : Encodable Î¹ := Fintype.toEncodable Î¹
  -- âŠ¢ â†‘â†‘(Measure.pi Î¼) (Set.pi univ s) = âˆ i : Î¹, â†‘â†‘(Î¼ i) (s i)
  rw [â† pi'_eq_pi, pi'_pi]
  -- ğŸ‰ no goals
#align measure_theory.measure.pi_pi MeasureTheory.Measure.pi_pi

nonrec theorem pi_univ : Measure.pi Î¼ univ = âˆ i, Î¼ i univ := by rw [â† pi_univ, pi_pi Î¼]
                                                                 -- ğŸ‰ no goals
#align measure_theory.measure.pi_univ MeasureTheory.Measure.pi_univ

theorem pi_ball [âˆ€ i, MetricSpace (Î± i)] (x : âˆ€ i, Î± i) {r : â„} (hr : 0 < r) :
    Measure.pi Î¼ (Metric.ball x r) = âˆ i, Î¼ i (Metric.ball (x i) r) := by rw [ball_pi _ hr, pi_pi]
                                                                          -- ğŸ‰ no goals
#align measure_theory.measure.pi_ball MeasureTheory.Measure.pi_ball

theorem pi_closedBall [âˆ€ i, MetricSpace (Î± i)] (x : âˆ€ i, Î± i) {r : â„} (hr : 0 â‰¤ r) :
    Measure.pi Î¼ (Metric.closedBall x r) = âˆ i, Î¼ i (Metric.closedBall (x i) r) := by
  rw [closedBall_pi _ hr, pi_pi]
  -- ğŸ‰ no goals
#align measure_theory.measure.pi_closed_ball MeasureTheory.Measure.pi_closedBall

instance pi.sigmaFinite : SigmaFinite (Measure.pi Î¼) :=
  (FiniteSpanningSetsIn.pi fun i => (Î¼ i).toFiniteSpanningSetsIn).sigmaFinite
#align measure_theory.measure.pi.sigma_finite MeasureTheory.Measure.pi.sigmaFinite

instance {Î± : Î¹ â†’ Type*} [âˆ€ i, MeasureSpace (Î± i)] [âˆ€ i, SigmaFinite (volume : Measure (Î± i))] :
    SigmaFinite (volume : Measure (âˆ€ i, Î± i)) :=
  pi.sigmaFinite _

theorem pi_of_empty {Î± : Type*} [IsEmpty Î±] {Î² : Î± â†’ Type*} {m : âˆ€ a, MeasurableSpace (Î² a)}
    (Î¼ : âˆ€ a : Î±, Measure (Î² a)) (x : âˆ€ a, Î² a := isEmptyElim) : Measure.pi Î¼ = dirac x := by
  haveI : âˆ€ a, SigmaFinite (Î¼ a) := isEmptyElim
  -- âŠ¢ Measure.pi Î¼ = dirac x
  refine' pi_eq fun s _ => _
  -- âŠ¢ â†‘â†‘(dirac x) (Set.pi univ s) = âˆ i : Î±, â†‘â†‘(Î¼ i) (s i)
  rw [Fintype.prod_empty, dirac_apply_of_mem]
  -- âŠ¢ x âˆˆ Set.pi univ s
  exact isEmptyElim (Î± := Î±)
  -- ğŸ‰ no goals
#align measure_theory.measure.pi_of_empty MeasureTheory.Measure.pi_of_empty

theorem pi_eval_preimage_null {i : Î¹} {s : Set (Î± i)} (hs : Î¼ i s = 0) :
    Measure.pi Î¼ (eval i â»Â¹' s) = 0 := by
  -- WLOG, `s` is measurable
  rcases exists_measurable_superset_of_null hs with âŸ¨t, hst, _, hÎ¼tâŸ©
  -- âŠ¢ â†‘â†‘(Measure.pi Î¼) (eval i â»Â¹' s) = 0
  suffices : Measure.pi Î¼ (eval i â»Â¹' t) = 0
  -- âŠ¢ â†‘â†‘(Measure.pi Î¼) (eval i â»Â¹' s) = 0
  exact measure_mono_null (preimage_mono hst) this
  -- âŠ¢ â†‘â†‘(Measure.pi Î¼) (eval i â»Â¹' t) = 0
  clear! s
  -- âŠ¢ â†‘â†‘(Measure.pi Î¼) (eval i â»Â¹' t) = 0
  -- Now rewrite it as `Set.pi`, and apply `pi_pi`
  rw [â† univ_pi_update_univ, pi_pi]
  -- âŠ¢ âˆ i_1 : Î¹, â†‘â†‘(Î¼ i_1) (update (fun j => univ) i t i_1) = 0
  apply Finset.prod_eq_zero (Finset.mem_univ i)
  -- âŠ¢ â†‘â†‘(Î¼ i) (update (fun j => univ) i t i) = 0
  simp [hÎ¼t]
  -- ğŸ‰ no goals
#align measure_theory.measure.pi_eval_preimage_null MeasureTheory.Measure.pi_eval_preimage_null

theorem pi_hyperplane (i : Î¹) [NoAtoms (Î¼ i)] (x : Î± i) :
    Measure.pi Î¼ { f : âˆ€ i, Î± i | f i = x } = 0 :=
  show Measure.pi Î¼ (eval i â»Â¹' {x}) = 0 from pi_eval_preimage_null _ (measure_singleton x)
#align measure_theory.measure.pi_hyperplane MeasureTheory.Measure.pi_hyperplane

theorem ae_eval_ne (i : Î¹) [NoAtoms (Î¼ i)] (x : Î± i) : âˆ€áµ y : âˆ€ i, Î± i âˆ‚Measure.pi Î¼, y i â‰  x :=
  compl_mem_ae_iff.2 (pi_hyperplane Î¼ i x)
#align measure_theory.measure.ae_eval_ne MeasureTheory.Measure.ae_eval_ne

variable {Î¼}

theorem tendsto_eval_ae_ae {i : Î¹} : Tendsto (eval i) (Measure.pi Î¼).ae (Î¼ i).ae := fun _ hs =>
  pi_eval_preimage_null Î¼ hs
#align measure_theory.measure.tendsto_eval_ae_ae MeasureTheory.Measure.tendsto_eval_ae_ae

theorem ae_pi_le_pi : (Measure.pi Î¼).ae â‰¤ Filter.pi fun i => (Î¼ i).ae :=
  le_iInf fun _ => tendsto_eval_ae_ae.le_comap
#align measure_theory.measure.ae_pi_le_pi MeasureTheory.Measure.ae_pi_le_pi

theorem ae_eq_pi {Î² : Î¹ â†’ Type*} {f f' : âˆ€ i, Î± i â†’ Î² i} (h : âˆ€ i, f i =áµ[Î¼ i] f' i) :
    (fun (x : âˆ€ i, Î± i) i => f i (x i)) =áµ[Measure.pi Î¼] fun x i => f' i (x i) :=
  (eventually_all.2 fun i => tendsto_eval_ae_ae.eventually (h i)).mono fun _ hx => funext hx
#align measure_theory.measure.ae_eq_pi MeasureTheory.Measure.ae_eq_pi

theorem ae_le_pi {Î² : Î¹ â†’ Type*} [âˆ€ i, Preorder (Î² i)] {f f' : âˆ€ i, Î± i â†’ Î² i}
    (h : âˆ€ i, f i â‰¤áµ[Î¼ i] f' i) :
    (fun (x : âˆ€ i, Î± i) i => f i (x i)) â‰¤áµ[Measure.pi Î¼] fun x i => f' i (x i) :=
  (eventually_all.2 fun i => tendsto_eval_ae_ae.eventually (h i)).mono fun _ hx => hx
#align measure_theory.measure.ae_le_pi MeasureTheory.Measure.ae_le_pi

theorem ae_le_set_pi {I : Set Î¹} {s t : âˆ€ i, Set (Î± i)} (h : âˆ€ i âˆˆ I, s i â‰¤áµ[Î¼ i] t i) :
    Set.pi I s â‰¤áµ[Measure.pi Î¼] Set.pi I t :=
  ((eventually_all_finite I.toFinite).2 fun i hi => tendsto_eval_ae_ae.eventually (h i hi)).mono
    fun _ hst hx i hi => hst i hi <| hx i hi
#align measure_theory.measure.ae_le_set_pi MeasureTheory.Measure.ae_le_set_pi

theorem ae_eq_set_pi {I : Set Î¹} {s t : âˆ€ i, Set (Î± i)} (h : âˆ€ i âˆˆ I, s i =áµ[Î¼ i] t i) :
    Set.pi I s =áµ[Measure.pi Î¼] Set.pi I t :=
  (ae_le_set_pi fun i hi => (h i hi).le).antisymm (ae_le_set_pi fun i hi => (h i hi).symm.le)
#align measure_theory.measure.ae_eq_set_pi MeasureTheory.Measure.ae_eq_set_pi

section Intervals

variable [âˆ€ i, PartialOrder (Î± i)] [âˆ€ i, NoAtoms (Î¼ i)]

theorem pi_Iio_ae_eq_pi_Iic {s : Set Î¹} {f : âˆ€ i, Î± i} :
    (pi s fun i => Iio (f i)) =áµ[Measure.pi Î¼] pi s fun i => Iic (f i) :=
  ae_eq_set_pi fun _ _ => Iio_ae_eq_Iic
#align measure_theory.measure.pi_Iio_ae_eq_pi_Iic MeasureTheory.Measure.pi_Iio_ae_eq_pi_Iic

theorem pi_Ioi_ae_eq_pi_Ici {s : Set Î¹} {f : âˆ€ i, Î± i} :
    (pi s fun i => Ioi (f i)) =áµ[Measure.pi Î¼] pi s fun i => Ici (f i) :=
  ae_eq_set_pi fun _ _ => Ioi_ae_eq_Ici
#align measure_theory.measure.pi_Ioi_ae_eq_pi_Ici MeasureTheory.Measure.pi_Ioi_ae_eq_pi_Ici

theorem univ_pi_Iio_ae_eq_Iic {f : âˆ€ i, Î± i} :
    (pi univ fun i => Iio (f i)) =áµ[Measure.pi Î¼] Iic f := by
  rw [â† pi_univ_Iic]; exact pi_Iio_ae_eq_pi_Iic
  -- âŠ¢ (Set.pi univ fun i => Iio (f i)) =á¶ [ae (Measure.pi Î¼)] Set.pi univ fun i =>  â€¦
                      -- ğŸ‰ no goals
#align measure_theory.measure.univ_pi_Iio_ae_eq_Iic MeasureTheory.Measure.univ_pi_Iio_ae_eq_Iic

theorem univ_pi_Ioi_ae_eq_Ici {f : âˆ€ i, Î± i} :
    (pi univ fun i => Ioi (f i)) =áµ[Measure.pi Î¼] Ici f := by
  rw [â† pi_univ_Ici]; exact pi_Ioi_ae_eq_pi_Ici
  -- âŠ¢ (Set.pi univ fun i => Ioi (f i)) =á¶ [ae (Measure.pi Î¼)] Set.pi univ fun i =>  â€¦
                      -- ğŸ‰ no goals
#align measure_theory.measure.univ_pi_Ioi_ae_eq_Ici MeasureTheory.Measure.univ_pi_Ioi_ae_eq_Ici

theorem pi_Ioo_ae_eq_pi_Icc {s : Set Î¹} {f g : âˆ€ i, Î± i} :
    (pi s fun i => Ioo (f i) (g i)) =áµ[Measure.pi Î¼] pi s fun i => Icc (f i) (g i) :=
  ae_eq_set_pi fun _ _ => Ioo_ae_eq_Icc
#align measure_theory.measure.pi_Ioo_ae_eq_pi_Icc MeasureTheory.Measure.pi_Ioo_ae_eq_pi_Icc

theorem pi_Ioo_ae_eq_pi_Ioc {s : Set Î¹} {f g : âˆ€ i, Î± i} :
    (pi s fun i => Ioo (f i) (g i)) =áµ[Measure.pi Î¼] pi s fun i => Ioc (f i) (g i) :=
  ae_eq_set_pi fun _ _ => Ioo_ae_eq_Ioc
#align measure_theory.measure.pi_Ioo_ae_eq_pi_Ioc MeasureTheory.Measure.pi_Ioo_ae_eq_pi_Ioc

theorem univ_pi_Ioo_ae_eq_Icc {f g : âˆ€ i, Î± i} :
    (pi univ fun i => Ioo (f i) (g i)) =áµ[Measure.pi Î¼] Icc f g := by
  rw [â† pi_univ_Icc]; exact pi_Ioo_ae_eq_pi_Icc
  -- âŠ¢ (Set.pi univ fun i => Ioo (f i) (g i)) =á¶ [ae (Measure.pi Î¼)] Set.pi univ fun â€¦
                      -- ğŸ‰ no goals
#align measure_theory.measure.univ_pi_Ioo_ae_eq_Icc MeasureTheory.Measure.univ_pi_Ioo_ae_eq_Icc

theorem pi_Ioc_ae_eq_pi_Icc {s : Set Î¹} {f g : âˆ€ i, Î± i} :
    (pi s fun i => Ioc (f i) (g i)) =áµ[Measure.pi Î¼] pi s fun i => Icc (f i) (g i) :=
  ae_eq_set_pi fun _ _ => Ioc_ae_eq_Icc
#align measure_theory.measure.pi_Ioc_ae_eq_pi_Icc MeasureTheory.Measure.pi_Ioc_ae_eq_pi_Icc

theorem univ_pi_Ioc_ae_eq_Icc {f g : âˆ€ i, Î± i} :
    (pi univ fun i => Ioc (f i) (g i)) =áµ[Measure.pi Î¼] Icc f g := by
  rw [â† pi_univ_Icc]; exact pi_Ioc_ae_eq_pi_Icc
  -- âŠ¢ (Set.pi univ fun i => Ioc (f i) (g i)) =á¶ [ae (Measure.pi Î¼)] Set.pi univ fun â€¦
                      -- ğŸ‰ no goals
#align measure_theory.measure.univ_pi_Ioc_ae_eq_Icc MeasureTheory.Measure.univ_pi_Ioc_ae_eq_Icc

theorem pi_Ico_ae_eq_pi_Icc {s : Set Î¹} {f g : âˆ€ i, Î± i} :
    (pi s fun i => Ico (f i) (g i)) =áµ[Measure.pi Î¼] pi s fun i => Icc (f i) (g i) :=
  ae_eq_set_pi fun _ _ => Ico_ae_eq_Icc
#align measure_theory.measure.pi_Ico_ae_eq_pi_Icc MeasureTheory.Measure.pi_Ico_ae_eq_pi_Icc

theorem univ_pi_Ico_ae_eq_Icc {f g : âˆ€ i, Î± i} :
    (pi univ fun i => Ico (f i) (g i)) =áµ[Measure.pi Î¼] Icc f g := by
  rw [â† pi_univ_Icc]; exact pi_Ico_ae_eq_pi_Icc
  -- âŠ¢ (Set.pi univ fun i => Ico (f i) (g i)) =á¶ [ae (Measure.pi Î¼)] Set.pi univ fun â€¦
                      -- ğŸ‰ no goals
#align measure_theory.measure.univ_pi_Ico_ae_eq_Icc MeasureTheory.Measure.univ_pi_Ico_ae_eq_Icc

end Intervals

/-- If one of the measures `Î¼ i` has no atoms, them `Measure.pi Âµ`
has no atoms. The instance below assumes that all `Î¼ i` have no atoms. -/
theorem pi_noAtoms (i : Î¹) [NoAtoms (Î¼ i)] : NoAtoms (Measure.pi Î¼) :=
  âŸ¨fun x => flip measure_mono_null (pi_hyperplane Î¼ i (x i)) (singleton_subset_iff.2 rfl)âŸ©
#align measure_theory.measure.pi_has_no_atoms MeasureTheory.Measure.pi_noAtoms

instance pi_noAtoms' [h : Nonempty Î¹] [âˆ€ i, NoAtoms (Î¼ i)] : NoAtoms (Measure.pi Î¼) :=
  h.elim fun i => pi_noAtoms i

instance {Î± : Î¹ â†’ Type*} [Nonempty Î¹] [âˆ€ i, MeasureSpace (Î± i)]
    [âˆ€ i, SigmaFinite (volume : Measure (Î± i))] [âˆ€ i, NoAtoms (volume : Measure (Î± i))] :
    NoAtoms (volume : Measure (âˆ€ i, Î± i)) :=
  pi_noAtoms'

instance pi.isLocallyFiniteMeasure
    [âˆ€ i, TopologicalSpace (Î± i)] [âˆ€ i, IsLocallyFiniteMeasure (Î¼ i)] :
    IsLocallyFiniteMeasure (Measure.pi Î¼) := by
  refine' âŸ¨fun x => _âŸ©
  -- âŠ¢ FiniteAtFilter (Measure.pi Î¼) (ğ“ x)
  choose s hxs ho hÎ¼ using fun i => (Î¼ i).exists_isOpen_measure_lt_top (x i)
  -- âŠ¢ FiniteAtFilter (Measure.pi Î¼) (ğ“ x)
  refine' âŸ¨pi univ s, set_pi_mem_nhds finite_univ fun i _ => IsOpen.mem_nhds (ho i) (hxs i), _âŸ©
  -- âŠ¢ â†‘â†‘(Measure.pi Î¼) (Set.pi univ s) < âŠ¤
  rw [pi_pi]
  -- âŠ¢ âˆ i : Î¹, â†‘â†‘(Î¼ i) (s i) < âŠ¤
  exact ENNReal.prod_lt_top fun i _ => (hÎ¼ i).ne
  -- ğŸ‰ no goals

instance {X : Î¹ â†’ Type*} [âˆ€ i, TopologicalSpace (X i)] [âˆ€ i, MeasureSpace (X i)]
    [âˆ€ i, SigmaFinite (volume : Measure (X i))]
    [âˆ€ i, IsLocallyFiniteMeasure (volume : Measure (X i))] :
    IsLocallyFiniteMeasure (volume : Measure (âˆ€ i, X i)) :=
  pi.isLocallyFiniteMeasure

variable (Î¼)

@[to_additive]
instance pi.isMulLeftInvariant [âˆ€ i, Group (Î± i)] [âˆ€ i, MeasurableMul (Î± i)]
    [âˆ€ i, IsMulLeftInvariant (Î¼ i)] : IsMulLeftInvariant (Measure.pi Î¼) := by
  refine' âŸ¨fun v => (pi_eq fun s hs => _).symmâŸ©
  -- âŠ¢ â†‘â†‘(map (fun x => v * x) (Measure.pi Î¼)) (Set.pi univ s) = âˆ i : Î¹, â†‘â†‘(Î¼ i) ( â€¦
  rw [map_apply (measurable_const_mul _) (MeasurableSet.univ_pi hs),
    show (Â· * Â·) v â»Â¹' univ.pi s = univ.pi fun i => (Â· * Â·) (v i) â»Â¹' s i by rfl, pi_pi]
  simp_rw [measure_preimage_mul]
  -- ğŸ‰ no goals
#align measure_theory.measure.pi.is_mul_left_invariant MeasureTheory.Measure.pi.isMulLeftInvariant
#align measure_theory.measure.pi.is_add_left_invariant MeasureTheory.Measure.pi.isAddLeftInvariant

@[to_additive]
instance {G : Î¹ â†’ Type*} [âˆ€ i, Group (G i)] [âˆ€ i, MeasureSpace (G i)] [âˆ€ i, MeasurableMul (G i)]
    [âˆ€ i, SigmaFinite (volume : Measure (G i))] [âˆ€ i, IsMulLeftInvariant (volume : Measure (G i))] :
    IsMulLeftInvariant (volume : Measure (âˆ€ i, G i)) :=
  pi.isMulLeftInvariant _

@[to_additive]
instance pi.isMulRightInvariant [âˆ€ i, Group (Î± i)] [âˆ€ i, MeasurableMul (Î± i)]
    [âˆ€ i, IsMulRightInvariant (Î¼ i)] : IsMulRightInvariant (Measure.pi Î¼) := by
  refine' âŸ¨fun v => (pi_eq fun s hs => _).symmâŸ©
  -- âŠ¢ â†‘â†‘(map (fun x => x * v) (Measure.pi Î¼)) (Set.pi univ s) = âˆ i : Î¹, â†‘â†‘(Î¼ i) ( â€¦
  rw [map_apply (measurable_mul_const _) (MeasurableSet.univ_pi hs),
    show (Â· * v) â»Â¹' univ.pi s = univ.pi fun i => (Â· * v i) â»Â¹' s i by rfl, pi_pi]
  simp_rw [measure_preimage_mul_right]
  -- ğŸ‰ no goals
#align measure_theory.measure.pi.is_mul_right_invariant MeasureTheory.Measure.pi.isMulRightInvariant
#align measure_theory.measure.pi.is_add_right_invariant MeasureTheory.Measure.pi.isAddRightInvariant

@[to_additive]
instance {G : Î¹ â†’ Type*} [âˆ€ i, Group (G i)] [âˆ€ i, MeasureSpace (G i)] [âˆ€ i, MeasurableMul (G i)]
    [âˆ€ i, SigmaFinite (volume : Measure (G i))]
    [âˆ€ i, IsMulRightInvariant (volume : Measure (G i))] :
    IsMulRightInvariant (volume : Measure (âˆ€ i, G i)) :=
  pi.isMulRightInvariant _

@[to_additive]
instance pi.isInvInvariant [âˆ€ i, Group (Î± i)] [âˆ€ i, MeasurableInv (Î± i)]
    [âˆ€ i, IsInvInvariant (Î¼ i)] : IsInvInvariant (Measure.pi Î¼) := by
  refine' âŸ¨(Measure.pi_eq fun s hs => _).symmâŸ©
  -- âŠ¢ â†‘â†‘(Measure.inv (Measure.pi Î¼)) (Set.pi univ s) = âˆ i : Î¹, â†‘â†‘(Î¼ i) (s i)
  have A : Inv.inv â»Â¹' pi univ s = Set.pi univ fun i => Inv.inv â»Â¹' s i := by ext; simp
  -- âŠ¢ â†‘â†‘(Measure.inv (Measure.pi Î¼)) (Set.pi univ s) = âˆ i : Î¹, â†‘â†‘(Î¼ i) (s i)
  simp_rw [Measure.inv, Measure.map_apply measurable_inv (MeasurableSet.univ_pi hs), A, pi_pi,
    measure_preimage_inv]
#align measure_theory.measure.pi.is_inv_invariant MeasureTheory.Measure.pi.isInvInvariant
#align measure_theory.measure.pi.is_neg_invariant MeasureTheory.Measure.pi.isNegInvariant

@[to_additive]
instance {G : Î¹ â†’ Type*} [âˆ€ i, Group (G i)] [âˆ€ i, MeasureSpace (G i)] [âˆ€ i, MeasurableInv (G i)]
    [âˆ€ i, SigmaFinite (volume : Measure (G i))] [âˆ€ i, IsInvInvariant (volume : Measure (G i))] :
    IsInvInvariant (volume : Measure (âˆ€ i, G i)) :=
  pi.isInvInvariant _

instance pi.isOpenPosMeasure [âˆ€ i, TopologicalSpace (Î± i)] [âˆ€ i, IsOpenPosMeasure (Î¼ i)] :
    IsOpenPosMeasure (MeasureTheory.Measure.pi Î¼) := by
  constructor
  -- âŠ¢ âˆ€ (U : Set ((i : Î¹) â†’ Î± i)), IsOpen U â†’ Set.Nonempty U â†’ â†‘â†‘(Measure.pi Î¼) U  â€¦
  rintro U U_open âŸ¨a, haâŸ©
  -- âŠ¢ â†‘â†‘(Measure.pi Î¼) U â‰  0
  obtain âŸ¨s, âŸ¨hs, hsUâŸ©âŸ© := isOpen_pi_iff'.1 U_open a ha
  -- âŠ¢ â†‘â†‘(Measure.pi Î¼) U â‰  0
  refine' ne_of_gt (lt_of_lt_of_le _ (measure_mono hsU))
  -- âŠ¢ 0 < â†‘â†‘(Measure.pi Î¼) (Set.pi univ s)
  simp only [pi_pi]
  -- âŠ¢ 0 < âˆ i : Î¹, â†‘â†‘(Î¼ i) (s i)
  rw [CanonicallyOrderedCommSemiring.prod_pos]
  -- âŠ¢ âˆ€ (i : Î¹), i âˆˆ Finset.univ â†’ 0 < â†‘â†‘(Î¼ i) (s i)
  intro i _
  -- âŠ¢ 0 < â†‘â†‘(Î¼ i) (s i)
  apply (hs i).1.measure_pos (Î¼ i) âŸ¨a i, (hs i).2âŸ©
  -- ğŸ‰ no goals
#align measure_theory.measure.pi.is_open_pos_measure MeasureTheory.Measure.pi.isOpenPosMeasure

instance {X : Î¹ â†’ Type*} [âˆ€ i, TopologicalSpace (X i)] [âˆ€ i, MeasureSpace (X i)]
    [âˆ€ i, IsOpenPosMeasure (volume : Measure (X i))] [âˆ€ i, SigmaFinite (volume : Measure (X i))] :
    IsOpenPosMeasure (volume : Measure (âˆ€ i, X i)) :=
  pi.isOpenPosMeasure _

instance pi.isFiniteMeasureOnCompacts [âˆ€ i, TopologicalSpace (Î± i)]
    [âˆ€ i, IsFiniteMeasureOnCompacts (Î¼ i)] :
    IsFiniteMeasureOnCompacts (MeasureTheory.Measure.pi Î¼) := by
  constructor
  -- âŠ¢ âˆ€ â¦ƒK : Set ((i : Î¹) â†’ Î± i)â¦„, IsCompact K â†’ â†‘â†‘(Measure.pi Î¼) K < âŠ¤
  intro K hK
  -- âŠ¢ â†‘â†‘(Measure.pi Î¼) K < âŠ¤
  suffices Measure.pi Î¼ (Set.univ.pi fun j => Function.eval j '' K) < âŠ¤ by
    exact lt_of_le_of_lt (measure_mono (univ.subset_pi_eval_image K)) this
  rw [Measure.pi_pi]
  -- âŠ¢ âˆ i : Î¹, â†‘â†‘(Î¼ i) (eval i '' K) < âŠ¤
  refine' WithTop.prod_lt_top _
  -- âŠ¢ âˆ€ (i : Î¹), i âˆˆ Finset.univ â†’ â†‘â†‘(Î¼ i) (eval i '' K) â‰  âŠ¤
  exact fun i _ => ne_of_lt (IsCompact.measure_lt_top (IsCompact.image hK (continuous_apply i)))
  -- ğŸ‰ no goals
#align measure_theory.measure.pi.is_finite_measure_on_compacts MeasureTheory.Measure.pi.isFiniteMeasureOnCompacts

instance {X : Î¹ â†’ Type*} [âˆ€ i, MeasureSpace (X i)] [âˆ€ i, TopologicalSpace (X i)]
    [âˆ€ i, SigmaFinite (volume : Measure (X i))]
    [âˆ€ i, IsFiniteMeasureOnCompacts (volume : Measure (X i))] :
    IsFiniteMeasureOnCompacts (volume : Measure (âˆ€ i, X i)) :=
  pi.isFiniteMeasureOnCompacts _

@[to_additive]
instance pi.isHaarMeasure [âˆ€ i, Group (Î± i)] [âˆ€ i, TopologicalSpace (Î± i)]
    [âˆ€ i, IsHaarMeasure (Î¼ i)] [âˆ€ i, MeasurableMul (Î± i)] : IsHaarMeasure (Measure.pi Î¼) where
#align measure_theory.measure.pi.is_haar_measure MeasureTheory.Measure.pi.isHaarMeasure
#align measure_theory.measure.pi.is_add_haar_measure MeasureTheory.Measure.pi.isAddHaarMeasure

@[to_additive]
instance {G : Î¹ â†’ Type*} [âˆ€ i, Group (G i)] [âˆ€ i, MeasureSpace (G i)] [âˆ€ i, MeasurableMul (G i)]
    [âˆ€ i, TopologicalSpace (G i)] [âˆ€ i, SigmaFinite (volume : Measure (G i))]
    [âˆ€ i, IsHaarMeasure (volume : Measure (G i))] : IsHaarMeasure (volume : Measure (âˆ€ i, G i)) :=
  pi.isHaarMeasure _

end Measure

theorem volume_pi [âˆ€ i, MeasureSpace (Î± i)] :
    (volume : Measure (âˆ€ i, Î± i)) = Measure.pi fun _ => volume :=
  rfl
#align measure_theory.volume_pi MeasureTheory.volume_pi

theorem volume_pi_pi [âˆ€ i, MeasureSpace (Î± i)] [âˆ€ i, SigmaFinite (volume : Measure (Î± i))]
    (s : âˆ€ i, Set (Î± i)) : volume (pi univ s) = âˆ i, volume (s i) :=
  Measure.pi_pi (fun _ => volume) s
#align measure_theory.volume_pi_pi MeasureTheory.volume_pi_pi

theorem volume_pi_ball [âˆ€ i, MeasureSpace (Î± i)] [âˆ€ i, SigmaFinite (volume : Measure (Î± i))]
    [âˆ€ i, MetricSpace (Î± i)] (x : âˆ€ i, Î± i) {r : â„} (hr : 0 < r) :
    volume (Metric.ball x r) = âˆ i, volume (Metric.ball (x i) r) :=
  Measure.pi_ball _ _ hr
#align measure_theory.volume_pi_ball MeasureTheory.volume_pi_ball

theorem volume_pi_closedBall [âˆ€ i, MeasureSpace (Î± i)] [âˆ€ i, SigmaFinite (volume : Measure (Î± i))]
    [âˆ€ i, MetricSpace (Î± i)] (x : âˆ€ i, Î± i) {r : â„} (hr : 0 â‰¤ r) :
    volume (Metric.closedBall x r) = âˆ i, volume (Metric.closedBall (x i) r) :=
  Measure.pi_closedBall _ _ hr
#align measure_theory.volume_pi_closed_ball MeasureTheory.volume_pi_closedBall

open Measure

/-- We intentionally restrict this only to the nondependent function space, since type-class
inference cannot find an instance for `Î¹ â†’ â„` when this is stated for dependent function spaces. -/
@[to_additive "We intentionally restrict this only to the nondependent function space, since
type-class inference cannot find an instance for `Î¹ â†’ â„` when this is stated for dependent function
spaces."]
instance Pi.isMulLeftInvariant_volume {Î±} [Group Î±] [MeasureSpace Î±]
    [SigmaFinite (volume : Measure Î±)] [MeasurableMul Î±] [IsMulLeftInvariant (volume : Measure Î±)] :
    IsMulLeftInvariant (volume : Measure (Î¹ â†’ Î±)) :=
  pi.isMulLeftInvariant _
#align measure_theory.pi.is_mul_left_invariant_volume MeasureTheory.Pi.isMulLeftInvariant_volume
#align measure_theory.pi.is_add_left_invariant_volume MeasureTheory.Pi.isAddLeftInvariant_volume

/-- We intentionally restrict this only to the nondependent function space, since type-class
inference cannot find an instance for `Î¹ â†’ â„` when this is stated for dependent function spaces. -/
@[to_additive "We intentionally restrict this only to the nondependent function space, since
type-class inference cannot find an instance for `Î¹ â†’ â„` when this is stated for dependent function
spaces."]
instance Pi.isInvInvariant_volume {Î±} [Group Î±] [MeasureSpace Î±] [SigmaFinite (volume : Measure Î±)]
    [MeasurableInv Î±] [IsInvInvariant (volume : Measure Î±)] :
    IsInvInvariant (volume : Measure (Î¹ â†’ Î±)) :=
  pi.isInvInvariant _
#align measure_theory.pi.is_inv_invariant_volume MeasureTheory.Pi.isInvInvariant_volume
#align measure_theory.pi.is_neg_invariant_volume MeasureTheory.Pi.isNegInvariant_volume

/-!
### Measure preserving equivalences

In this section we prove that some measurable equivalences (e.g., between `Fin 1 â†’ Î±` and `Î±` or
between `Fin 2 â†’ Î±` and `Î± Ã— Î±`) preserve measure or volume. These lemmas can be used to prove that
measures of corresponding sets (images or preimages) have equal measures and functions `f âˆ˜ e` and
`f` have equal integrals, see lemmas in the `MeasureTheory.measurePreserving` prefix.
-/


section MeasurePreserving

theorem measurePreserving_piEquivPiSubtypeProd {Î¹ : Type u} {Î± : Î¹ â†’ Type v} [Fintype Î¹]
    {m : âˆ€ i, MeasurableSpace (Î± i)} (Î¼ : âˆ€ i, Measure (Î± i)) [âˆ€ i, SigmaFinite (Î¼ i)]
    (p : Î¹ â†’ Prop) [DecidablePred p] :
    MeasurePreserving (MeasurableEquiv.piEquivPiSubtypeProd Î± p) (Measure.pi Î¼)
      ((Measure.pi fun i : Subtype p => Î¼ i).prod (Measure.pi fun i => Î¼ i)) := by
  set e := (MeasurableEquiv.piEquivPiSubtypeProd Î± p).symm
  -- âŠ¢ MeasurePreserving â†‘(MeasurableEquiv.piEquivPiSubtypeProd Î± p)
  refine' MeasurePreserving.symm e _
  -- âŠ¢ MeasurePreserving â†‘e
  refine' âŸ¨e.measurable, (pi_eq fun s _ => _).symmâŸ©
  -- âŠ¢ â†‘â†‘(Measure.map (â†‘e) (Measure.prod (Measure.pi fun i => Î¼ â†‘i) (Measure.pi fun â€¦
  have : e â»Â¹' pi univ s =
      (pi univ fun i : { i // p i } => s i) Ã—Ë¢ pi univ fun i : { i // Â¬p i } => s i :=
    Equiv.preimage_piEquivPiSubtypeProd_symm_pi p s
  rw [e.map_apply, this, prod_prod, pi_pi, pi_pi]
  -- âŠ¢ (âˆ i : Subtype p, â†‘â†‘(Î¼ â†‘i) (s â†‘i)) * âˆ i : { i // Â¬p i }, â†‘â†‘(Î¼ â†‘i) (s â†‘i) =  â€¦
  exact Fintype.prod_subtype_mul_prod_subtype p fun i => Î¼ i (s i)
  -- ğŸ‰ no goals
#align measure_theory.measure_preserving_pi_equiv_pi_subtype_prod MeasureTheory.measurePreserving_piEquivPiSubtypeProd

theorem volume_preserving_piEquivPiSubtypeProd {Î¹ : Type*} (Î± : Î¹ â†’ Type*) [Fintype Î¹]
    [âˆ€ i, MeasureSpace (Î± i)] [âˆ€ i, SigmaFinite (volume : Measure (Î± i))] (p : Î¹ â†’ Prop)
    [DecidablePred p] : MeasurePreserving (MeasurableEquiv.piEquivPiSubtypeProd Î± p) :=
  measurePreserving_piEquivPiSubtypeProd (fun _ => volume) p
#align measure_theory.volume_preserving_pi_equiv_pi_subtype_prod MeasureTheory.volume_preserving_piEquivPiSubtypeProd

theorem measurePreserving_piFinSuccAboveEquiv {n : â„•} {Î± : Fin (n + 1) â†’ Type u}
    {m : âˆ€ i, MeasurableSpace (Î± i)} (Î¼ : âˆ€ i, Measure (Î± i)) [âˆ€ i, SigmaFinite (Î¼ i)]
    (i : Fin (n + 1)) :
    MeasurePreserving (MeasurableEquiv.piFinSuccAboveEquiv Î± i) (Measure.pi Î¼)
      ((Î¼ i).prod <| Measure.pi fun j => Î¼ (i.succAbove j)) := by
  set e := (MeasurableEquiv.piFinSuccAboveEquiv Î± i).symm
  -- âŠ¢ MeasurePreserving â†‘(MeasurableEquiv.piFinSuccAboveEquiv Î± i)
  refine' MeasurePreserving.symm e _
  -- âŠ¢ MeasurePreserving â†‘e
  refine' âŸ¨e.measurable, (pi_eq fun s _ => _).symmâŸ©
  -- âŠ¢ â†‘â†‘(Measure.map (â†‘e) (Measure.prod (Î¼ i) (Measure.pi fun j => Î¼ (Fin.succAbov â€¦
  rw [e.map_apply, i.prod_univ_succAbove _, â† pi_pi, â† prod_prod]
  -- âŠ¢ â†‘â†‘(Measure.prod (Î¼ i) (Measure.pi fun j => Î¼ (Fin.succAbove i j))) (â†‘e â»Â¹' S â€¦
  congr 1 with âŸ¨x, fâŸ©
  -- âŠ¢ (x, f) âˆˆ â†‘e â»Â¹' Set.pi univ s â†” (x, f) âˆˆ s i Ã—Ë¢ Set.pi univ fun i_1 => s (Fi â€¦
  simp [i.forall_iff_succAbove]
  -- ğŸ‰ no goals
#align measure_theory.measure_preserving_pi_fin_succ_above_equiv MeasureTheory.measurePreserving_piFinSuccAboveEquiv

theorem volume_preserving_piFinSuccAboveEquiv {n : â„•} (Î± : Fin (n + 1) â†’ Type u)
    [âˆ€ i, MeasureSpace (Î± i)] [âˆ€ i, SigmaFinite (volume : Measure (Î± i))] (i : Fin (n + 1)) :
    MeasurePreserving (MeasurableEquiv.piFinSuccAboveEquiv Î± i) :=
  measurePreserving_piFinSuccAboveEquiv (fun _ => volume) i
#align measure_theory.volume_preserving_pi_fin_succ_above_equiv MeasureTheory.volume_preserving_piFinSuccAboveEquiv

theorem measurePreserving_funUnique {Î² : Type u} {m : MeasurableSpace Î²} (Î¼ : Measure Î²)
    (Î± : Type v) [Unique Î±] :
    MeasurePreserving (MeasurableEquiv.funUnique Î± Î²) (Measure.pi fun _ : Î± => Î¼) Î¼ := by
  set e := MeasurableEquiv.funUnique Î± Î²
  -- âŠ¢ MeasurePreserving â†‘e
  have : (piPremeasure fun _ : Î± => Î¼.toOuterMeasure) = Measure.map e.symm Î¼ := by
    ext1 s
    rw [piPremeasure, Fintype.prod_unique, e.symm.map_apply]
    congr 1; exact e.toEquiv.image_eq_preimage s
  simp only [Measure.pi, OuterMeasure.pi, this, boundedBy_measure, toOuterMeasure_toMeasure]
  -- âŠ¢ MeasurePreserving â†‘(MeasurableEquiv.funUnique Î± Î²)
  exact (e.symm.measurable.measurePreserving _).symm e.symm
  -- ğŸ‰ no goals
#align measure_theory.measure_preserving_fun_unique MeasureTheory.measurePreserving_funUnique

theorem volume_preserving_funUnique (Î± : Type u) (Î² : Type v) [Unique Î±] [MeasureSpace Î²] :
    MeasurePreserving (MeasurableEquiv.funUnique Î± Î²) volume volume :=
  measurePreserving_funUnique volume Î±
#align measure_theory.volume_preserving_fun_unique MeasureTheory.volume_preserving_funUnique

theorem measurePreserving_piFinTwo {Î± : Fin 2 â†’ Type u} {m : âˆ€ i, MeasurableSpace (Î± i)}
    (Î¼ : âˆ€ i, Measure (Î± i)) [âˆ€ i, SigmaFinite (Î¼ i)] :
    MeasurePreserving (MeasurableEquiv.piFinTwo Î±) (Measure.pi Î¼) ((Î¼ 0).prod (Î¼ 1)) := by
  refine' âŸ¨MeasurableEquiv.measurable _, (Measure.prod_eq fun s t _ _ => _).symmâŸ©
  -- âŠ¢ â†‘â†‘(Measure.map (â†‘(MeasurableEquiv.piFinTwo Î±)) (Measure.pi Î¼)) (s Ã—Ë¢ t) = â†‘â†‘ â€¦
  rw [MeasurableEquiv.map_apply, MeasurableEquiv.piFinTwo_apply, Fin.preimage_apply_01_prod,
    Measure.pi_pi, Fin.prod_univ_two]
  rfl
  -- ğŸ‰ no goals
#align measure_theory.measure_preserving_pi_fin_two MeasureTheory.measurePreserving_piFinTwo

theorem volume_preserving_piFinTwo (Î± : Fin 2 â†’ Type u) [âˆ€ i, MeasureSpace (Î± i)]
    [âˆ€ i, SigmaFinite (volume : Measure (Î± i))] :
    MeasurePreserving (MeasurableEquiv.piFinTwo Î±) volume volume :=
  measurePreserving_piFinTwo _
#align measure_theory.volume_preserving_pi_fin_two MeasureTheory.volume_preserving_piFinTwo

theorem measurePreserving_finTwoArrow_vec {Î± : Type u} {m : MeasurableSpace Î±} (Î¼ Î½ : Measure Î±)
    [SigmaFinite Î¼] [SigmaFinite Î½] :
    MeasurePreserving MeasurableEquiv.finTwoArrow (Measure.pi ![Î¼, Î½]) (Î¼.prod Î½) :=
  haveI : âˆ€ i, SigmaFinite (![Î¼, Î½] i) := Fin.forall_fin_two.2 âŸ¨â€¹_â€º, â€¹_â€ºâŸ©
  measurePreserving_piFinTwo _
#align measure_theory.measure_preserving_fin_two_arrow_vec MeasureTheory.measurePreserving_finTwoArrow_vec

theorem measurePreserving_finTwoArrow {Î± : Type u} {m : MeasurableSpace Î±} (Î¼ : Measure Î±)
    [SigmaFinite Î¼] :
    MeasurePreserving MeasurableEquiv.finTwoArrow (Measure.pi fun _ => Î¼) (Î¼.prod Î¼) := by
  simpa only [Matrix.vec_single_eq_const, Matrix.vecCons_const] using
    measurePreserving_finTwoArrow_vec Î¼ Î¼
#align measure_theory.measure_preserving_fin_two_arrow MeasureTheory.measurePreserving_finTwoArrow

theorem volume_preserving_finTwoArrow (Î± : Type u) [MeasureSpace Î±]
    [SigmaFinite (volume : Measure Î±)] :
    MeasurePreserving (@MeasurableEquiv.finTwoArrow Î± _) volume volume :=
  measurePreserving_finTwoArrow volume
#align measure_theory.volume_preserving_fin_two_arrow MeasureTheory.volume_preserving_finTwoArrow

theorem measurePreserving_pi_empty {Î¹ : Type u} {Î± : Î¹ â†’ Type v} [IsEmpty Î¹]
    {m : âˆ€ i, MeasurableSpace (Î± i)} (Î¼ : âˆ€ i, Measure (Î± i)) :
    MeasurePreserving (MeasurableEquiv.ofUniqueOfUnique (âˆ€ i, Î± i) Unit) (Measure.pi Î¼)
      (Measure.dirac ()) := by
  set e := MeasurableEquiv.ofUniqueOfUnique (âˆ€ i, Î± i) Unit
  -- âŠ¢ MeasurePreserving â†‘e
  refine' âŸ¨e.measurable, _âŸ©
  -- âŠ¢ Measure.map (â†‘e) (Measure.pi Î¼) = Measure.dirac ()
  rw [Measure.pi_of_empty, Measure.map_dirac e.measurable]
  -- ğŸ‰ no goals
#align measure_theory.measure_preserving_pi_empty MeasureTheory.measurePreserving_pi_empty

theorem volume_preserving_pi_empty {Î¹ : Type u} (Î± : Î¹ â†’ Type v) [IsEmpty Î¹]
    [âˆ€ i, MeasureSpace (Î± i)] :
    MeasurePreserving (MeasurableEquiv.ofUniqueOfUnique (âˆ€ i, Î± i) Unit) volume volume :=
  measurePreserving_pi_empty fun _ => volume
#align measure_theory.volume_preserving_pi_empty MeasureTheory.volume_preserving_pi_empty

end MeasurePreserving

end MeasureTheory
