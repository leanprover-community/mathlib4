/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Yury Kudryashov
-/
import Mathlib.Analysis.Normed.Group.Basic
import Mathlib.MeasureTheory.Function.AEMeasurableSequence
import Mathlib.MeasureTheory.Group.Arithmetic
import Mathlib.MeasureTheory.Lattice
import Mathlib.Topology.Algebra.Order.LiminfLimsup
import Mathlib.Topology.ContinuousFunction.Basic
import Mathlib.Topology.Instances.EReal
import Mathlib.Topology.MetricSpace.HausdorffDistance
import Mathlib.Topology.GDelta
import Mathlib.Topology.Order.Lattice
import Mathlib.Topology.Semicontinuous

#align_import measure_theory.constructions.borel_space.basic from "leanprover-community/mathlib"@"9f55d0d4363ae59948c33864cbc52e0b12e0e8ce"

/-!
# Borel (measurable) space

## Main definitions

* `borel Œ±` : the least `œÉ`-algebra that contains all open sets;
* `class BorelSpace` : a space with `TopologicalSpace` and `MeasurableSpace` structures
  such that `‚ÄπMeasurableSpace Œ±‚Ä∫ = borel Œ±`;
* `class OpensMeasurableSpace` : a space with `TopologicalSpace` and `MeasurableSpace`
  structures such that all open sets are measurable; equivalently, `borel Œ± ‚â§ ‚ÄπMeasurableSpace Œ±‚Ä∫`.
* `BorelSpace` instances on `Empty`, `Unit`, `Bool`, `Nat`, `Int`, `Rat`;
* `MeasurableSpace` and `BorelSpace` instances on `‚Ñù`, `‚Ñù‚â•0`, `‚Ñù‚â•0‚àû`.

## Main statements

* `IsOpen.measurableSet`, `IsClosed.measurableSet`: open and closed sets are measurable;
* `Continuous.measurable` : a continuous function is measurable;
* `Continuous.measurable2` : if `f : Œ± ‚Üí Œ≤` and `g : Œ± ‚Üí Œ≥` are measurable and `op : Œ≤ √ó Œ≥ ‚Üí Œ¥`
  is continuous, then `fun x => op (f x, g y)` is measurable;
* `Measurable.add` etc : dot notation for arithmetic operations on `Measurable` predicates,
  and similarly for `dist` and `edist`;
* `AEMeasurable.add` : similar dot notation for almost everywhere measurable functions;
* `Measurable.ennreal*` : special cases for arithmetic operations on `‚Ñù‚â•0‚àû`.
-/


noncomputable section

open Classical Set Filter MeasureTheory

open Classical BigOperators Topology NNReal ENNReal MeasureTheory

universe u v w x y

variable {Œ± Œ≤ Œ≥ Œ≥‚ÇÇ Œ¥ : Type*} {Œπ : Sort y} {s t u : Set Œ±}

open MeasurableSpace TopologicalSpace

/-- `MeasurableSpace` structure generated by `TopologicalSpace`. -/
def borel (Œ± : Type u) [TopologicalSpace Œ±] : MeasurableSpace Œ± :=
  generateFrom { s : Set Œ± | IsOpen s }
#align borel borel

theorem borel_anti : Antitone (@borel Œ±) := fun _ _ h =>
  MeasurableSpace.generateFrom_le fun _ hs => .basic _ (h _ hs)
#align borel_anti borel_anti

theorem borel_eq_top_of_discrete [TopologicalSpace Œ±] [DiscreteTopology Œ±] : borel Œ± = ‚ä§ :=
  top_le_iff.1 fun s _ => GenerateMeasurable.basic s (isOpen_discrete s)
#align borel_eq_top_of_discrete borel_eq_top_of_discrete

theorem borel_eq_top_of_countable [TopologicalSpace Œ±] [T1Space Œ±] [Countable Œ±] : borel Œ± = ‚ä§ := by
  refine' top_le_iff.1 fun s _ => biUnion_of_singleton s ‚ñ∏ _
  apply MeasurableSet.biUnion s.to_countable
  intro x _
  apply MeasurableSet.of_compl
  apply GenerateMeasurable.basic
  exact isClosed_singleton.isOpen_compl
#align borel_eq_top_of_countable borel_eq_top_of_countable

theorem borel_eq_generateFrom_of_subbasis {s : Set (Set Œ±)} [t : TopologicalSpace Œ±]
    [SecondCountableTopology Œ±] (hs : t = .generateFrom s) : borel Œ± = .generateFrom s :=
  le_antisymm
    (generateFrom_le fun u (hu : t.IsOpen u) => by
      rw [hs] at hu
      induction hu
      case basic u hu => exact GenerateMeasurable.basic u hu
      case univ => exact @MeasurableSet.univ Œ± (generateFrom s)
      case inter s‚ÇÅ s‚ÇÇ _ _ hs‚ÇÅ hs‚ÇÇ => exact @MeasurableSet.inter Œ± (generateFrom s) _ _ hs‚ÇÅ hs‚ÇÇ
      case
        sUnion f hf ih =>
        rcases isOpen_sUnion_countable f (by rwa [hs]) with ‚ü®v, hv, vf, vu‚ü©
        rw [‚Üê vu]
        exact @MeasurableSet.sUnion Œ± (generateFrom s) _ hv fun x xv => ih _ (vf xv))
    (generateFrom_le fun u hu =>
      GenerateMeasurable.basic _ <| show t.IsOpen u by rw [hs]; exact GenerateOpen.basic _ hu)
#align borel_eq_generate_from_of_subbasis borel_eq_generateFrom_of_subbasis

theorem TopologicalSpace.IsTopologicalBasis.borel_eq_generateFrom [TopologicalSpace Œ±]
    [SecondCountableTopology Œ±] {s : Set (Set Œ±)} (hs : IsTopologicalBasis s) :
    borel Œ± = .generateFrom s :=
  borel_eq_generateFrom_of_subbasis hs.eq_generateFrom
#align topological_space.is_topological_basis.borel_eq_generate_from TopologicalSpace.IsTopologicalBasis.borel_eq_generateFrom

theorem isPiSystem_isOpen [TopologicalSpace Œ±] : IsPiSystem (IsOpen : Set Œ± ‚Üí Prop) :=
  fun _s hs _t ht _ => IsOpen.inter hs ht
#align is_pi_system_is_open isPiSystem_isOpen

theorem borel_eq_generateFrom_isClosed [TopologicalSpace Œ±] :
    borel Œ± = .generateFrom { s | IsClosed s } :=
  le_antisymm
    (generateFrom_le fun _t ht =>
      @MeasurableSet.of_compl Œ± _ (generateFrom { s | IsClosed s })
        (GenerateMeasurable.basic _ <| isClosed_compl_iff.2 ht))
    (generateFrom_le fun _t ht =>
      @MeasurableSet.of_compl Œ± _ (borel Œ±) (GenerateMeasurable.basic _ <| isOpen_compl_iff.2 ht))
#align borel_eq_generate_from_is_closed borel_eq_generateFrom_isClosed

section OrderTopology

variable (Œ±)

variable [TopologicalSpace Œ±] [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±]

theorem borel_eq_generateFrom_Iio : borel Œ± = .generateFrom (range Iio) := by
  refine' le_antisymm _ (generateFrom_le _)
  ¬∑ rw [borel_eq_generateFrom_of_subbasis (@OrderTopology.topology_eq_generate_intervals Œ± _ _ _)]
    letI : MeasurableSpace Œ± := MeasurableSpace.generateFrom (range Iio)
    have H : ‚àÄ a : Œ±, MeasurableSet (Iio a) := fun a => GenerateMeasurable.basic _ ‚ü®_, rfl‚ü©
    refine' generateFrom_le _
    rintro _ ‚ü®a, rfl | rfl‚ü© <;> [skip; apply H]
    by_cases h : ‚àÉ a', ‚àÄ b, a < b ‚Üî a' ‚â§ b
    ¬∑ rcases h with ‚ü®a', ha'‚ü©
      rw [(_ : Ioi a = (Iio a')·∂ú)]
      ¬∑ exact (H _).compl
      simp [Set.ext_iff, ha']
    ¬∑ rcases isOpen_iUnion_countable (fun a' : { a' : Œ± // a < a' } => { b | a'.1 < b }) fun a' =>
          isOpen_lt' _ with ‚ü®v, ‚ü®hv‚ü©, vu‚ü©
      simp [Set.ext_iff] at vu
      have : Ioi a = ‚ãÉ x : v, (Iio x.1.1)·∂ú := by
        simp only [compl_Iio, iUnion_coe_set, Set.ext_iff, mem_Ioi, mem_iUnion, mem_Ici,
          exists_prop, Subtype.exists, exists_and_right]
        refine' fun x => ‚ü®fun ax => _, fun ‚ü®a', ‚ü®h, _‚ü©, ax‚ü© => lt_of_lt_of_le h ax‚ü©
        rcases (vu x).2 (by
          refine' not_imp_comm.1 (fun h => _) h
          exact ‚ü®x, fun b =>
            ‚ü®fun ab => le_of_not_lt fun h' => h ‚ü®b, ab, h'‚ü©, lt_of_lt_of_le ax‚ü©‚ü©) with ‚ü®a', h‚ÇÅ, h‚ÇÇ‚ü©
        ¬∑ exact ‚ü®a', h‚ÇÅ, le_of_lt h‚ÇÇ‚ü©
      rw [this]
      skip
      apply MeasurableSet.iUnion
      exact fun _ => (H _).compl
  ¬∑ rw [forall_range_iff]
    intro a
    exact GenerateMeasurable.basic _ isOpen_Iio
#align borel_eq_generate_from_Iio borel_eq_generateFrom_Iio

theorem borel_eq_generateFrom_Ioi : borel Œ± = .generateFrom (range Ioi) :=
  @borel_eq_generateFrom_Iio Œ±·µí·µà _ (by infer_instance : SecondCountableTopology Œ±) _ _
#align borel_eq_generate_from_Ioi borel_eq_generateFrom_Ioi

theorem borel_eq_generateFrom_Iic :
    borel Œ± = MeasurableSpace.generateFrom (range Iic) := by
  rw [borel_eq_generateFrom_Ioi]
  refine' le_antisymm _ _
  ¬∑ refine' MeasurableSpace.generateFrom_le fun t ht => _
    obtain ‚ü®u, rfl‚ü© := ht
    rw [‚Üê compl_Iic]
    exact (MeasurableSpace.measurableSet_generateFrom (mem_range.mpr ‚ü®u, rfl‚ü©)).compl
  ¬∑ refine' MeasurableSpace.generateFrom_le fun t ht => _
    obtain ‚ü®u, rfl‚ü© := ht
    rw [‚Üê compl_Ioi]
    exact (MeasurableSpace.measurableSet_generateFrom (mem_range.mpr ‚ü®u, rfl‚ü©)).compl
#align borel_eq_generate_from_Iic borel_eq_generateFrom_Iic

theorem borel_eq_generateFrom_Ici : borel Œ± = MeasurableSpace.generateFrom (range Ici) :=
  @borel_eq_generateFrom_Iic Œ±·µí·µà _ _ _ _
#align borel_eq_generate_from_Ici borel_eq_generateFrom_Ici

end OrderTopology

theorem borel_comap {f : Œ± ‚Üí Œ≤} {t : TopologicalSpace Œ≤} :
    @borel Œ± (t.induced f) = (@borel Œ≤ t).comap f :=
  comap_generateFrom.symm
#align borel_comap borel_comap

theorem Continuous.borel_measurable [TopologicalSpace Œ±] [TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤}
    (hf : Continuous f) : @Measurable Œ± Œ≤ (borel Œ±) (borel Œ≤) f :=
  Measurable.of_le_map <|
    generateFrom_le fun s hs => GenerateMeasurable.basic (f ‚Åª¬π' s) (hs.preimage hf)
#align continuous.borel_measurable Continuous.borel_measurable

/-- A space with `MeasurableSpace` and `TopologicalSpace` structures such that
all open sets are measurable. -/
class OpensMeasurableSpace (Œ± : Type*) [TopologicalSpace Œ±] [h : MeasurableSpace Œ±] : Prop where
  /-- Borel-measurable sets are measurable. -/
  borel_le : borel Œ± ‚â§ h
#align opens_measurable_space OpensMeasurableSpace
#align opens_measurable_space.borel_le OpensMeasurableSpace.borel_le

/-- A space with `MeasurableSpace` and `TopologicalSpace` structures such that
the `œÉ`-algebra of measurable sets is exactly the `œÉ`-algebra generated by open sets. -/
class BorelSpace (Œ± : Type*) [TopologicalSpace Œ±] [MeasurableSpace Œ±] : Prop where
  /-- The measurable sets are exactly the Borel-measurable sets. -/
  measurable_eq : ‚ÄπMeasurableSpace Œ±‚Ä∫ = borel Œ±
#align borel_space BorelSpace
#align borel_space.measurable_eq BorelSpace.measurable_eq

namespace Mathlib.Tactic.Borelize

open Lean Elab Term Tactic Meta

/-- The behaviour of `borelize Œ±` depends on the existing assumptions on `Œ±`.

- if `Œ±` is a topological space with instances `[MeasurableSpace Œ±] [BorelSpace Œ±]`, then
  `borelize Œ±` replaces the former instance by `borel Œ±`;
- otherwise, `borelize Œ±` adds instances `borel Œ± : MeasurableSpace Œ±` and `‚ü®rfl‚ü© : BorelSpace Œ±`.

Finally, `borelize Œ± Œ≤ Œ≥` runs `borelize Œ±; borelize Œ≤; borelize Œ≥`.
-/
syntax "borelize" (ppSpace colGt term:max)* : tactic

/-- Add instances `borel e : MeasurableSpace e` and `‚ü®rfl‚ü© : BorelSpace e`. -/
def addBorelInstance (e : Expr) : TacticM Unit := do
  let t ‚Üê Lean.Elab.Term.exprToSyntax e
  evalTactic <| ‚Üê `(tactic|
    refine_lift
      letI : MeasurableSpace $t := borel $t
      haveI : BorelSpace $t := ‚ü®rfl‚ü©
      ?_)

/-- Given a type `e`, an assumption `i : MeasurableSpace e`, and an instance `[BorelSpace e]`,
replace `i` with `borel e`. -/
def borelToRefl (e : Expr) (i : FVarId) : TacticM Unit := do
  let te ‚Üê Lean.Elab.Term.exprToSyntax e
  evalTactic <| ‚Üê `(tactic|
    have := @BorelSpace.measurable_eq $te _ _ _)
  try
    liftMetaTactic fun m => return [‚Üê subst m i]
  catch _ =>
    let et ‚Üê synthInstance (‚Üê mkAppOptM ``TopologicalSpace #[e])
    throwError
      (m!"`‚ÄπTopologicalSpace {e}‚Ä∫ := {et}" ++ MessageData.ofFormat Format.line ++
        m!"depends on" ++ MessageData.ofFormat Format.line ++
        m!"{Expr.fvar i} : MeasurableSpace {e}`" ++ MessageData.ofFormat Format.line ++
        "so `borelize` isn't avaliable")
  evalTactic <| ‚Üê `(tactic|
    refine_lift
      letI : MeasurableSpace $te := borel $te
      ?_)

/-- Given a type `$t`, if there is an assumption `[i : MeasurableSpace $t]`, then try to prove
`[BorelSpace $t]` and replace `i` with `borel $t`. Otherwise, add instances
`borel $t : MeasurableSpace $t` and `‚ü®rfl‚ü© : BorelSpace $t`. -/
def borelize (t : Term) : TacticM Unit := withMainContext <| do
  let u ‚Üê mkFreshLevelMVar
  let e ‚Üê withoutRecover <| Tactic.elabTermEnsuringType t (mkSort (mkLevelSucc u))
  let i? ‚Üê findLocalDeclWithType? (‚Üê mkAppOptM ``MeasurableSpace #[e])
  i?.elim (addBorelInstance e) (borelToRefl e)

elab_rules : tactic
  | `(tactic| borelize $[$t:term]*) => t.forM borelize

end Mathlib.Tactic.Borelize

instance (priority := 100) OrderDual.opensMeasurableSpace {Œ± : Type*} [TopologicalSpace Œ±]
    [MeasurableSpace Œ±] [h : OpensMeasurableSpace Œ±] : OpensMeasurableSpace Œ±·µí·µà where
  borel_le := h.borel_le
#align order_dual.opens_measurable_space OrderDual.opensMeasurableSpace

instance (priority := 100) OrderDual.borelSpace {Œ± : Type*} [TopologicalSpace Œ±]
    [MeasurableSpace Œ±] [h : BorelSpace Œ±] : BorelSpace Œ±·µí·µà where
  measurable_eq := h.measurable_eq
#align order_dual.borel_space OrderDual.borelSpace

/-- In a `BorelSpace` all open sets are measurable. -/
instance (priority := 100) BorelSpace.opensMeasurable {Œ± : Type*} [TopologicalSpace Œ±]
    [MeasurableSpace Œ±] [BorelSpace Œ±] : OpensMeasurableSpace Œ± :=
  ‚ü®ge_of_eq <| BorelSpace.measurable_eq‚ü©
#align borel_space.opens_measurable BorelSpace.opensMeasurable

instance Subtype.borelSpace {Œ± : Type*} [TopologicalSpace Œ±] [MeasurableSpace Œ±]
    [hŒ± : BorelSpace Œ±] (s : Set Œ±) : BorelSpace s :=
  ‚ü®by borelize Œ±; symm; apply borel_comap‚ü©
#align subtype.borel_space Subtype.borelSpace

instance Subtype.opensMeasurableSpace {Œ± : Type*} [TopologicalSpace Œ±] [MeasurableSpace Œ±]
    [h : OpensMeasurableSpace Œ±] (s : Set Œ±) : OpensMeasurableSpace s :=
  ‚ü®by
    rw [borel_comap]
    exact comap_mono h.1‚ü©
#align subtype.opens_measurable_space Subtype.opensMeasurableSpace

lemma opensMeasurableSpace_iff_forall_measurableSet
    [TopologicalSpace Œ±] [MeasurableSpace Œ±] :
    OpensMeasurableSpace Œ± ‚Üî  (‚àÄ (s : Set Œ±), IsOpen s ‚Üí MeasurableSet s) := by
  refine ‚ü®fun h s hs ‚Ü¶ ?_, fun h ‚Ü¶ ‚ü®generateFrom_le h‚ü©‚ü©
  exact OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ hs

instance (priority := 100) BorelSpace.countablyGenerated {Œ± : Type*} [TopologicalSpace Œ±]
    [MeasurableSpace Œ±] [BorelSpace Œ±] [SecondCountableTopology Œ±] : CountablyGenerated Œ± := by
  obtain ‚ü®b, bct, -, hb‚ü© := exists_countable_basis Œ±
  refine' ‚ü®‚ü®b, bct, _‚ü©‚ü©
  borelize Œ±
  exact hb.borel_eq_generateFrom
#align borel_space.countably_generated BorelSpace.countablyGenerated

theorem MeasurableSet.induction_on_open [TopologicalSpace Œ±] [MeasurableSpace Œ±] [BorelSpace Œ±]
    {C : Set Œ± ‚Üí Prop} (h_open : ‚àÄ U, IsOpen U ‚Üí C U)
    (h_compl : ‚àÄ t, MeasurableSet t ‚Üí C t ‚Üí C t·∂ú)
    (h_union :
      ‚àÄ f : ‚Ñï ‚Üí Set Œ±,
        Pairwise (Disjoint on f) ‚Üí (‚àÄ i, MeasurableSet (f i)) ‚Üí (‚àÄ i, C (f i)) ‚Üí C (‚ãÉ i, f i)) :
    ‚àÄ ‚¶Ét‚¶Ñ, MeasurableSet t ‚Üí C t :=
  MeasurableSpace.induction_on_inter BorelSpace.measurable_eq isPiSystem_isOpen
    (h_open _ isOpen_empty) h_open h_compl h_union
#align measurable_set.induction_on_open MeasurableSet.induction_on_open

section

variable [TopologicalSpace Œ±] [MeasurableSpace Œ±] [OpensMeasurableSpace Œ±] [TopologicalSpace Œ≤]
  [MeasurableSpace Œ≤] [OpensMeasurableSpace Œ≤] [TopologicalSpace Œ≥] [MeasurableSpace Œ≥]
  [BorelSpace Œ≥] [TopologicalSpace Œ≥‚ÇÇ] [MeasurableSpace Œ≥‚ÇÇ] [BorelSpace Œ≥‚ÇÇ] [MeasurableSpace Œ¥]

theorem IsOpen.measurableSet (h : IsOpen s) : MeasurableSet s :=
  OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ h
#align is_open.measurable_set IsOpen.measurableSet

instance (priority := 500) {s : Set Œ±} [HasCountableSeparatingOn Œ± IsOpen s] :
    HasCountableSeparatingOn Œ± MeasurableSet s :=
  .mono (fun _ ‚Ü¶ IsOpen.measurableSet) Subset.rfl

@[measurability]
theorem measurableSet_interior : MeasurableSet (interior s) :=
  isOpen_interior.measurableSet
#align measurable_set_interior measurableSet_interior

theorem IsGŒ¥.measurableSet (h : IsGŒ¥ s) : MeasurableSet s := by
  rcases h with ‚ü®S, hSo, hSc, rfl‚ü©
  exact MeasurableSet.sInter hSc fun t ht => (hSo t ht).measurableSet
set_option linter.uppercaseLean3 false in
#align is_GŒ¥.measurable_set IsGŒ¥.measurableSet

theorem measurableSet_of_continuousAt {Œ≤} [EMetricSpace Œ≤] (f : Œ± ‚Üí Œ≤) :
    MeasurableSet { x | ContinuousAt f x } :=
  (isGŒ¥_setOf_continuousAt f).measurableSet
#align measurable_set_of_continuous_at measurableSet_of_continuousAt

theorem IsClosed.measurableSet (h : IsClosed s) : MeasurableSet s :=
  h.isOpen_compl.measurableSet.of_compl
#align is_closed.measurable_set IsClosed.measurableSet

theorem IsCompact.measurableSet [T2Space Œ±] (h : IsCompact s) : MeasurableSet s :=
  h.isClosed.measurableSet
#align is_compact.measurable_set IsCompact.measurableSet

@[measurability]
theorem measurableSet_closure : MeasurableSet (closure s) :=
  isClosed_closure.measurableSet
#align measurable_set_closure measurableSet_closure

theorem measurable_of_isOpen {f : Œ¥ ‚Üí Œ≥} (hf : ‚àÄ s, IsOpen s ‚Üí MeasurableSet (f ‚Åª¬π' s)) :
    Measurable f := by
  rw [‚ÄπBorelSpace Œ≥‚Ä∫.measurable_eq]
  exact measurable_generateFrom hf
#align measurable_of_is_open measurable_of_isOpen

theorem measurable_of_isClosed {f : Œ¥ ‚Üí Œ≥} (hf : ‚àÄ s, IsClosed s ‚Üí MeasurableSet (f ‚Åª¬π' s)) :
    Measurable f := by
  apply measurable_of_isOpen; intro s hs
  rw [‚Üê MeasurableSet.compl_iff, ‚Üê preimage_compl]; apply hf; rw [isClosed_compl_iff]; exact hs
#align measurable_of_is_closed measurable_of_isClosed

theorem measurable_of_isClosed' {f : Œ¥ ‚Üí Œ≥}
    (hf : ‚àÄ s, IsClosed s ‚Üí s.Nonempty ‚Üí s ‚â† univ ‚Üí MeasurableSet (f ‚Åª¬π' s)) : Measurable f := by
  apply measurable_of_isClosed; intro s hs
  cases' eq_empty_or_nonempty s with h1 h1
  ¬∑ simp [h1]
  by_cases h2 : s = univ
  ¬∑ simp [h2]
  exact hf s hs h1 h2
#align measurable_of_is_closed' measurable_of_isClosed'

instance nhds_isMeasurablyGenerated (a : Œ±) : (ùìù a).IsMeasurablyGenerated := by
  rw [nhds, iInf_subtype']
  refine' @Filter.iInf_isMeasurablyGenerated Œ± _ _ _ fun i => _
  exact i.2.2.measurableSet.principal_isMeasurablyGenerated
#align nhds_is_measurably_generated nhds_isMeasurablyGenerated

/-- If `s` is a measurable set, then `ùìù[s] a` is a measurably generated filter for
each `a`. This cannot be an `instance` because it depends on a non-instance `hs : MeasurableSet s`.
-/
theorem MeasurableSet.nhdsWithin_isMeasurablyGenerated {s : Set Œ±} (hs : MeasurableSet s) (a : Œ±) :
    (ùìù[s] a).IsMeasurablyGenerated :=
  haveI := hs.principal_isMeasurablyGenerated
  Filter.inf_isMeasurablyGenerated _ _
#align measurable_set.nhds_within_is_measurably_generated MeasurableSet.nhdsWithin_isMeasurablyGenerated

-- see Note [lower instance priority]
instance (priority := 100) OpensMeasurableSpace.toMeasurableSingletonClass [T1Space Œ±] :
    MeasurableSingletonClass Œ± :=
  ‚ü®fun _ => isClosed_singleton.measurableSet‚ü©
#align opens_measurable_space.to_measurable_singleton_class OpensMeasurableSpace.toMeasurableSingletonClass

instance Pi.opensMeasurableSpace {Œπ : Type*} {œÄ : Œπ ‚Üí Type*} [Countable Œπ]
    [t' : ‚àÄ i, TopologicalSpace (œÄ i)] [‚àÄ i, MeasurableSpace (œÄ i)]
    [‚àÄ i, SecondCountableTopology (œÄ i)] [‚àÄ i, OpensMeasurableSpace (œÄ i)] :
    OpensMeasurableSpace (‚àÄ i, œÄ i) := by
  constructor
  have : Pi.topologicalSpace = .generateFrom { t | ‚àÉ (s : ‚àÄ a, Set (œÄ a)) (i : Finset Œπ),
      (‚àÄ a ‚àà i, s a ‚àà countableBasis (œÄ a)) ‚àß t = pi (‚Üëi) s } := by
    rw [funext fun a => @eq_generateFrom_countableBasis (œÄ a) _ _, pi_generateFrom_eq]
  rw [borel_eq_generateFrom_of_subbasis this]
  apply generateFrom_le
  rintro _ ‚ü®s, i, hi, rfl‚ü©
  refine' MeasurableSet.pi i.countable_toSet fun a ha => IsOpen.measurableSet _
  rw [eq_generateFrom_countableBasis (œÄ a)]
  exact .basic _ (hi a ha)
#align pi.opens_measurable_space Pi.opensMeasurableSpace

/-- The typeclass `SecondCountableTopologyEither Œ± Œ≤` registers the fact that at least one of
the two spaces has second countable topology. This is the right assumption to ensure that continuous
maps from `Œ±` to `Œ≤` are strongly measurable. -/
class SecondCountableTopologyEither (Œ± Œ≤ : Type*) [TopologicalSpace Œ±] [TopologicalSpace Œ≤] :
  Prop where
  /-- The projection out of `SecondCountableTopologyEither` -/
  out : SecondCountableTopology Œ± ‚à® SecondCountableTopology Œ≤
#align second_countable_topology_either SecondCountableTopologyEither

instance (priority := 100) secondCountableTopologyEither_of_left (Œ± Œ≤ : Type*) [TopologicalSpace Œ±]
    [TopologicalSpace Œ≤] [SecondCountableTopology Œ±] : SecondCountableTopologyEither Œ± Œ≤ where
  out := Or.inl (by infer_instance)
#align second_countable_topology_either_of_left secondCountableTopologyEither_of_left

instance (priority := 100) secondCountableTopologyEither_of_right (Œ± Œ≤ : Type*)
    [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [SecondCountableTopology Œ≤] :
    SecondCountableTopologyEither Œ± Œ≤ where
  out := Or.inr (by infer_instance)
#align second_countable_topology_either_of_right secondCountableTopologyEither_of_right

/-- If either `Œ±` or `Œ≤` has second-countable topology, then the open sets in `Œ± √ó Œ≤` belong to the
product sigma-algebra. -/
instance Prod.opensMeasurableSpace [h : SecondCountableTopologyEither Œ± Œ≤] :
    OpensMeasurableSpace (Œ± √ó Œ≤) := by
  apply opensMeasurableSpace_iff_forall_measurableSet.2 (fun s hs ‚Ü¶ ?_)
  rcases h.out with hŒ±|hŒ≤
  ¬∑ let F : Set Œ± ‚Üí Set Œ≤ := fun a ‚Ü¶ {y | ‚àÉ b, IsOpen b ‚àß y ‚àà b ‚àß a √óÀ¢ b ‚äÜ s}
    have A : ‚àÄ a, IsOpen (F a) := by
      intro a
      apply isOpen_iff_forall_mem_open.2
      rintro y ‚ü®b, b_open, yb, hb‚ü©
      exact ‚ü®b, fun z zb ‚Ü¶ ‚ü®b, b_open, zb, hb‚ü©, b_open, yb‚ü©
    have : s = ‚ãÉ a ‚àà countableBasis Œ±, a √óÀ¢ F a := by
      apply Subset.antisymm
      ¬∑ rintro ‚ü®y1, y2‚ü© hy
        rcases isOpen_prod_iff.1 hs y1 y2 hy with ‚ü®u, v, u_open, v_open, yu, yv, huv‚ü©
        obtain ‚ü®a, ha, ya, au‚ü© : ‚àÉ a ‚àà countableBasis Œ±, y1 ‚àà a ‚àß a ‚äÜ u :=
          IsTopologicalBasis.exists_subset_of_mem_open (isBasis_countableBasis Œ±) yu u_open
        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop]
        exact ‚ü®a, ya, ha, v, v_open, yv, (Set.prod_mono_left au).trans huv‚ü©
      ¬∑ rintro ‚ü®y1, y2‚ü© hy
        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop] at hy
        rcases hy with ‚ü®a, ya, -, b, -, yb, hb‚ü©
        exact hb (mem_prod.2 ‚ü®ya, yb‚ü©)
    rw [this]
    apply MeasurableSet.biUnion (countable_countableBasis Œ±) (fun a ha ‚Ü¶ ?_)
    exact (isOpen_of_mem_countableBasis ha).measurableSet.prod (A a).measurableSet
  ¬∑ let F : Set Œ≤ ‚Üí Set Œ± := fun a ‚Ü¶ {y | ‚àÉ b, IsOpen b ‚àß y ‚àà b ‚àß b √óÀ¢ a ‚äÜ s}
    have A : ‚àÄ a, IsOpen (F a) := by
      intro a
      apply isOpen_iff_forall_mem_open.2
      rintro y ‚ü®b, b_open, yb, hb‚ü©
      exact ‚ü®b, fun z zb ‚Ü¶ ‚ü®b, b_open, zb, hb‚ü©, b_open, yb‚ü©
    have : s = ‚ãÉ a ‚àà countableBasis Œ≤, F a √óÀ¢ a := by
      apply Subset.antisymm
      ¬∑ rintro ‚ü®y1, y2‚ü© hy
        rcases isOpen_prod_iff.1 hs y1 y2 hy with ‚ü®u, v, u_open, v_open, yu, yv, huv‚ü©
        obtain ‚ü®a, ha, ya, au‚ü© : ‚àÉ a ‚àà countableBasis Œ≤, y2 ‚àà a ‚àß a ‚äÜ v :=
          IsTopologicalBasis.exists_subset_of_mem_open (isBasis_countableBasis Œ≤) yv v_open
        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop]
        exact ‚ü®a, ‚ü®u, u_open, yu, (Set.prod_mono_right au).trans huv‚ü©, ha, ya‚ü©
      ¬∑ rintro ‚ü®y1, y2‚ü© hy
        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop] at hy
        rcases hy with ‚ü®a, ‚ü®b, -, yb, hb‚ü©, -, ya‚ü©
        exact hb (mem_prod.2 ‚ü®yb, ya‚ü©)
    rw [this]
    apply MeasurableSet.biUnion (countable_countableBasis Œ≤) (fun a ha ‚Ü¶ ?_)
    exact (A a).measurableSet.prod (isOpen_of_mem_countableBasis ha).measurableSet

variable {Œ±' : Type*} [TopologicalSpace Œ±'] [MeasurableSpace Œ±']

theorem interior_ae_eq_of_null_frontier {Œº : Measure Œ±'} {s : Set Œ±'} (h : Œº (frontier s) = 0) :
    interior s =·µê[Œº] s :=
  interior_subset.eventuallyLE.antisymm <| subset_closure.eventuallyLE.trans (ae_le_set.2 h)
#align interior_ae_eq_of_null_frontier interior_ae_eq_of_null_frontier

theorem measure_interior_of_null_frontier {Œº : Measure Œ±'} {s : Set Œ±'} (h : Œº (frontier s) = 0) :
    Œº (interior s) = Œº s :=
  measure_congr (interior_ae_eq_of_null_frontier h)
#align measure_interior_of_null_frontier measure_interior_of_null_frontier

theorem nullMeasurableSet_of_null_frontier {s : Set Œ±} {Œº : Measure Œ±} (h : Œº (frontier s) = 0) :
    NullMeasurableSet s Œº :=
  ‚ü®interior s, isOpen_interior.measurableSet, (interior_ae_eq_of_null_frontier h).symm‚ü©
#align null_measurable_set_of_null_frontier nullMeasurableSet_of_null_frontier

theorem closure_ae_eq_of_null_frontier {Œº : Measure Œ±'} {s : Set Œ±'} (h : Œº (frontier s) = 0) :
    closure s =·µê[Œº] s :=
  ((ae_le_set.2 h).trans interior_subset.eventuallyLE).antisymm <| subset_closure.eventuallyLE
#align closure_ae_eq_of_null_frontier closure_ae_eq_of_null_frontier

theorem measure_closure_of_null_frontier {Œº : Measure Œ±'} {s : Set Œ±'} (h : Œº (frontier s) = 0) :
    Œº (closure s) = Œº s :=
  measure_congr (closure_ae_eq_of_null_frontier h)
#align measure_closure_of_null_frontier measure_closure_of_null_frontier

section Preorder

variable [Preorder Œ±] [OrderClosedTopology Œ±] {a b x : Œ±}

@[simp, measurability]
theorem measurableSet_Ici : MeasurableSet (Ici a) :=
  isClosed_Ici.measurableSet
#align measurable_set_Ici measurableSet_Ici

@[simp, measurability]
theorem measurableSet_Iic : MeasurableSet (Iic a) :=
  isClosed_Iic.measurableSet
#align measurable_set_Iic measurableSet_Iic

@[simp, measurability]
theorem measurableSet_Icc : MeasurableSet (Icc a b) :=
  isClosed_Icc.measurableSet
#align measurable_set_Icc measurableSet_Icc

instance nhdsWithin_Ici_isMeasurablyGenerated : (ùìù[Ici b] a).IsMeasurablyGenerated :=
  measurableSet_Ici.nhdsWithin_isMeasurablyGenerated _
#align nhds_within_Ici_is_measurably_generated nhdsWithin_Ici_isMeasurablyGenerated

instance nhdsWithin_Iic_isMeasurablyGenerated : (ùìù[Iic b] a).IsMeasurablyGenerated :=
  measurableSet_Iic.nhdsWithin_isMeasurablyGenerated _
#align nhds_within_Iic_is_measurably_generated nhdsWithin_Iic_isMeasurablyGenerated

instance nhdsWithin_Icc_isMeasurablyGenerated : IsMeasurablyGenerated (ùìù[Icc a b] x) := by
  rw [‚Üê Ici_inter_Iic, nhdsWithin_inter]
  infer_instance
#align nhds_within_Icc_is_measurably_generated nhdsWithin_Icc_isMeasurablyGenerated

instance atTop_isMeasurablyGenerated : (Filter.atTop : Filter Œ±).IsMeasurablyGenerated :=
  @Filter.iInf_isMeasurablyGenerated _ _ _ _ fun a =>
    (measurableSet_Ici : MeasurableSet (Ici a)).principal_isMeasurablyGenerated
#align at_top_is_measurably_generated atTop_isMeasurablyGenerated

instance atBot_isMeasurablyGenerated : (Filter.atBot : Filter Œ±).IsMeasurablyGenerated :=
  @Filter.iInf_isMeasurablyGenerated _ _ _ _ fun a =>
    (measurableSet_Iic : MeasurableSet (Iic a)).principal_isMeasurablyGenerated
#align at_bot_is_measurably_generated atBot_isMeasurablyGenerated

end Preorder

section PartialOrder

variable [PartialOrder Œ±] [OrderClosedTopology Œ±] [SecondCountableTopology Œ±] {a b : Œ±}

@[measurability]
theorem measurableSet_le' : MeasurableSet { p : Œ± √ó Œ± | p.1 ‚â§ p.2 } :=
  OrderClosedTopology.isClosed_le'.measurableSet
#align measurable_set_le' measurableSet_le'

@[measurability]
theorem measurableSet_le {f g : Œ¥ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    MeasurableSet { a | f a ‚â§ g a } :=
  hf.prod_mk hg measurableSet_le'
#align measurable_set_le measurableSet_le

end PartialOrder

section LinearOrder

variable [LinearOrder Œ±] [OrderClosedTopology Œ±] {a b x : Œ±}

-- we open this locale only here to avoid issues with list being treated as intervals above
open Interval

@[simp, measurability]
theorem measurableSet_Iio : MeasurableSet (Iio a) :=
  isOpen_Iio.measurableSet
#align measurable_set_Iio measurableSet_Iio

@[simp, measurability]
theorem measurableSet_Ioi : MeasurableSet (Ioi a) :=
  isOpen_Ioi.measurableSet
#align measurable_set_Ioi measurableSet_Ioi

@[simp, measurability]
theorem measurableSet_Ioo : MeasurableSet (Ioo a b) :=
  isOpen_Ioo.measurableSet
#align measurable_set_Ioo measurableSet_Ioo

@[simp, measurability]
theorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=
  measurableSet_Ioi.inter measurableSet_Iic
#align measurable_set_Ioc measurableSet_Ioc

@[simp, measurability]
theorem measurableSet_Ico : MeasurableSet (Ico a b) :=
  measurableSet_Ici.inter measurableSet_Iio
#align measurable_set_Ico measurableSet_Ico

instance nhdsWithin_Ioi_isMeasurablyGenerated : (ùìù[Ioi b] a).IsMeasurablyGenerated :=
  measurableSet_Ioi.nhdsWithin_isMeasurablyGenerated _
#align nhds_within_Ioi_is_measurably_generated nhdsWithin_Ioi_isMeasurablyGenerated

instance nhdsWithin_Iio_isMeasurablyGenerated : (ùìù[Iio b] a).IsMeasurablyGenerated :=
  measurableSet_Iio.nhdsWithin_isMeasurablyGenerated _
#align nhds_within_Iio_is_measurably_generated nhdsWithin_Iio_isMeasurablyGenerated

instance nhdsWithin_uIcc_isMeasurablyGenerated : IsMeasurablyGenerated (ùìù[[[a, b]]] x) :=
  nhdsWithin_Icc_isMeasurablyGenerated
#align nhds_within_uIcc_is_measurably_generated nhdsWithin_uIcc_isMeasurablyGenerated

@[measurability]
theorem measurableSet_lt' [SecondCountableTopology Œ±] : MeasurableSet { p : Œ± √ó Œ± | p.1 < p.2 } :=
  (isOpen_lt continuous_fst continuous_snd).measurableSet
#align measurable_set_lt' measurableSet_lt'

@[measurability]
theorem measurableSet_lt [SecondCountableTopology Œ±] {f g : Œ¥ ‚Üí Œ±} (hf : Measurable f)
    (hg : Measurable g) : MeasurableSet { a | f a < g a } :=
  hf.prod_mk hg measurableSet_lt'
#align measurable_set_lt measurableSet_lt

theorem nullMeasurableSet_lt [SecondCountableTopology Œ±] {Œº : Measure Œ¥} {f g : Œ¥ ‚Üí Œ±}
    (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) : NullMeasurableSet { a | f a < g a } Œº :=
  (hf.prod_mk hg).nullMeasurable measurableSet_lt'
#align null_measurable_set_lt nullMeasurableSet_lt

theorem Set.OrdConnected.measurableSet (h : OrdConnected s) : MeasurableSet s := by
  let u := ‚ãÉ (x ‚àà s) (y ‚àà s), Ioo x y
  have huopen : IsOpen u := isOpen_biUnion fun _ _ => isOpen_biUnion fun _ _ => isOpen_Ioo
  have humeas : MeasurableSet u := huopen.measurableSet
  have hfinite : (s \ u).Finite := s.finite_diff_iUnion_Ioo
  have : u ‚äÜ s := iUnion‚ÇÇ_subset fun x hx => iUnion‚ÇÇ_subset fun y hy =>
    Ioo_subset_Icc_self.trans (h.out hx hy)
  rw [‚Üê union_diff_cancel this]
  exact humeas.union hfinite.measurableSet
#align set.ord_connected.measurable_set Set.OrdConnected.measurableSet

theorem IsPreconnected.measurableSet (h : IsPreconnected s) : MeasurableSet s :=
  h.ordConnected.measurableSet
#align is_preconnected.measurable_set IsPreconnected.measurableSet

theorem generateFrom_Ico_mem_le_borel {Œ± : Type*} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderClosedTopology Œ±] (s t : Set Œ±) :
    MeasurableSpace.generateFrom { S | ‚àÉ l ‚àà s, ‚àÉ u ‚àà t, l < u ‚àß Ico l u = S }
      ‚â§ borel Œ± := by
  apply generateFrom_le
  borelize Œ±
  rintro _ ‚ü®a, -, b, -, -, rfl‚ü©
  exact measurableSet_Ico
#align generate_from_Ico_mem_le_borel generateFrom_Ico_mem_le_borel

theorem Dense.borel_eq_generateFrom_Ico_mem_aux {Œ± : Type*} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderTopology Œ±] [SecondCountableTopology Œ±] {s : Set Œ±} (hd : Dense s)
    (hbot : ‚àÄ x, IsBot x ‚Üí x ‚àà s) (hIoo : ‚àÄ x y : Œ±, x < y ‚Üí Ioo x y = ‚àÖ ‚Üí y ‚àà s) :
    borel Œ± = .generateFrom { S : Set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, l < u ‚àß Ico l u = S } := by
  set S : Set (Set Œ±) := { S | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, l < u ‚àß Ico l u = S }
  refine' le_antisymm _ (generateFrom_Ico_mem_le_borel _ _)
  letI : MeasurableSpace Œ± := generateFrom S
  rw [borel_eq_generateFrom_Iio]
  refine' generateFrom_le (forall_range_iff.2 fun a => _)
  rcases hd.exists_countable_dense_subset_bot_top with ‚ü®t, hts, hc, htd, htb, -‚ü©
  by_cases ha : ‚àÄ b < a, (Ioo b a).Nonempty
  ¬∑ convert_to MeasurableSet (‚ãÉ (l ‚àà t) (u ‚àà t) (_ : l < u) (_ : u ‚â§ a), Ico l u)
    ¬∑ ext y
      simp only [mem_iUnion, mem_Iio, mem_Ico]
      constructor
      ¬∑ intro hy
        rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) y with ‚ü®l, hlt, hly‚ü©
        rcases htd.exists_mem_open isOpen_Ioo (ha y hy) with ‚ü®u, hut, hyu, hua‚ü©
        exact ‚ü®l, hlt, u, hut, hly.trans_lt hyu, hua.le, hly, hyu‚ü©
      ¬∑ rintro ‚ü®l, -, u, -, -, hua, -, hyu‚ü©
        exact hyu.trans_le hua
    ¬∑ refine' MeasurableSet.biUnion hc fun a ha => MeasurableSet.biUnion hc fun b hb => _
      refine' MeasurableSet.iUnion fun hab => MeasurableSet.iUnion fun _ => _
      exact .basic _ ‚ü®a, hts ha, b, hts hb, hab, mem_singleton _‚ü©
  ¬∑ simp only [not_forall, not_nonempty_iff_eq_empty] at ha
    replace ha : a ‚àà s := hIoo ha.choose a ha.choose_spec.fst ha.choose_spec.snd
    convert_to MeasurableSet (‚ãÉ (l ‚àà t) (_ : l < a), Ico l a)
    ¬∑ symm
      simp only [‚Üê Ici_inter_Iio, ‚Üê iUnion_inter, inter_eq_right, subset_def, mem_iUnion,
        mem_Ici, mem_Iio]
      intro x hx
      rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) x with ‚ü®z, hzt, hzx‚ü©
      exact ‚ü®z, hzt, hzx.trans_lt hx, hzx‚ü©
    ¬∑ refine' .biUnion hc fun x hx => MeasurableSet.iUnion fun hlt => _
      exact .basic _ ‚ü®x, hts hx, a, ha, hlt, mem_singleton _‚ü©
#align dense.borel_eq_generate_from_Ico_mem_aux Dense.borel_eq_generateFrom_Ico_mem_aux

theorem Dense.borel_eq_generateFrom_Ico_mem {Œ± : Type*} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderTopology Œ±] [SecondCountableTopology Œ±] [DenselyOrdered Œ±] [NoMinOrder Œ±] {s : Set Œ±}
    (hd : Dense s) :
    borel Œ± = .generateFrom { S : Set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, l < u ‚àß Ico l u = S } :=
  hd.borel_eq_generateFrom_Ico_mem_aux (by simp) fun x y hxy H =>
    ((nonempty_Ioo.2 hxy).ne_empty H).elim
#align dense.borel_eq_generate_from_Ico_mem Dense.borel_eq_generateFrom_Ico_mem

theorem borel_eq_generateFrom_Ico (Œ± : Type*) [TopologicalSpace Œ±] [SecondCountableTopology Œ±]
    [LinearOrder Œ±] [OrderTopology Œ±] :
    borel Œ± = .generateFrom { S : Set Œ± | ‚àÉ (l u : Œ±), l < u ‚àß Ico l u = S } := by
  simpa only [exists_prop, mem_univ, true_and_iff] using
    (@dense_univ Œ± _).borel_eq_generateFrom_Ico_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ =>
      mem_univ _
#align borel_eq_generate_from_Ico borel_eq_generateFrom_Ico

theorem Dense.borel_eq_generateFrom_Ioc_mem_aux {Œ± : Type*} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderTopology Œ±] [SecondCountableTopology Œ±] {s : Set Œ±} (hd : Dense s)
    (hbot : ‚àÄ x, IsTop x ‚Üí x ‚àà s) (hIoo : ‚àÄ x y : Œ±, x < y ‚Üí Ioo x y = ‚àÖ ‚Üí x ‚àà s) :
    borel Œ± = .generateFrom { S : Set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, l < u ‚àß Ioc l u = S } := by
  convert hd.orderDual.borel_eq_generateFrom_Ico_mem_aux hbot fun x y hlt he => hIoo y x hlt _
    using 2
  ¬∑ ext s
    constructor <;> rintro ‚ü®l, hl, u, hu, hlt, rfl‚ü©
    exacts [‚ü®u, hu, l, hl, hlt, dual_Ico‚ü©, ‚ü®u, hu, l, hl, hlt, dual_Ioc‚ü©]
  ¬∑ erw [dual_Ioo]
    exact he
#align dense.borel_eq_generate_from_Ioc_mem_aux Dense.borel_eq_generateFrom_Ioc_mem_aux

theorem Dense.borel_eq_generateFrom_Ioc_mem {Œ± : Type*} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderTopology Œ±] [SecondCountableTopology Œ±] [DenselyOrdered Œ±] [NoMaxOrder Œ±] {s : Set Œ±}
    (hd : Dense s) :
    borel Œ± = .generateFrom { S : Set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, l < u ‚àß Ioc l u = S } :=
  hd.borel_eq_generateFrom_Ioc_mem_aux (by simp) fun x y hxy H =>
    ((nonempty_Ioo.2 hxy).ne_empty H).elim
#align dense.borel_eq_generate_from_Ioc_mem Dense.borel_eq_generateFrom_Ioc_mem

theorem borel_eq_generateFrom_Ioc (Œ± : Type*) [TopologicalSpace Œ±] [SecondCountableTopology Œ±]
    [LinearOrder Œ±] [OrderTopology Œ±] :
    borel Œ± = .generateFrom { S : Set Œ± | ‚àÉ l u, l < u ‚àß Ioc l u = S } := by
  simpa only [exists_prop, mem_univ, true_and_iff] using
    (@dense_univ Œ± _).borel_eq_generateFrom_Ioc_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ =>
      mem_univ _
#align borel_eq_generate_from_Ioc borel_eq_generateFrom_Ioc

namespace MeasureTheory.Measure

/-- Two finite measures on a Borel space are equal if they agree on all closed-open intervals.  If
`Œ±` is a conditionally complete linear order with no top element,
`MeasureTheory.Measure.ext_of_Ico` is an extensionality lemma with weaker assumptions on `Œº` and
`ŒΩ`. -/
theorem ext_of_Ico_finite {Œ± : Type*} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] (Œº ŒΩ : Measure Œ±)
    [IsFiniteMeasure Œº] (hŒºŒΩ : Œº univ = ŒΩ univ) (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) = ŒΩ (Ico a b)) :
    Œº = ŒΩ := by
  refine'
    ext_of_generate_finite _ (BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ico Œ±))
      (isPiSystem_Ico (id : Œ± ‚Üí Œ±) id) _ hŒºŒΩ
  ¬∑ rintro - ‚ü®a, b, hlt, rfl‚ü©
    exact h hlt
#align measure_theory.measure.ext_of_Ico_finite MeasureTheory.Measure.ext_of_Ico_finite

/-- Two finite measures on a Borel space are equal if they agree on all open-closed intervals.  If
`Œ±` is a conditionally complete linear order with no top element,
`MeasureTheory.Measure.ext_of_Ioc` is an extensionality lemma with weaker assumptions on `Œº` and
`ŒΩ`. -/
theorem ext_of_Ioc_finite {Œ± : Type*} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] (Œº ŒΩ : Measure Œ±)
    [IsFiniteMeasure Œº] (hŒºŒΩ : Œº univ = ŒΩ univ) (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) = ŒΩ (Ioc a b)) :
    Œº = ŒΩ := by
  refine' @ext_of_Ico_finite Œ±·µí·µà _ _ _ _ _ ‚Äπ_‚Ä∫ Œº ŒΩ _ hŒºŒΩ fun a b hab => _
  erw [dual_Ico (Œ± := Œ±)]
  exact h hab
#align measure_theory.measure.ext_of_Ioc_finite MeasureTheory.Measure.ext_of_Ioc_finite

/-- Two measures which are finite on closed-open intervals are equal if they agree on all
closed-open intervals. -/
theorem ext_of_Ico' {Œ± : Type*} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] [NoMaxOrder Œ±]
    (Œº ŒΩ : Measure Œ±) (hŒº : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) ‚â† ‚àû)
    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) = ŒΩ (Ico a b)) : Œº = ŒΩ := by
  rcases exists_countable_dense_bot_top Œ± with ‚ü®s, hsc, hsd, hsb, _‚ü©
  have : (‚ãÉ (l ‚àà s) (u ‚àà s) (_ : l < u), {Ico l u} : Set (Set Œ±)).Countable :=
    hsc.biUnion fun l _ => hsc.biUnion fun u _ => countable_iUnion fun _ => countable_singleton _
  simp only [‚Üê setOf_eq_eq_singleton, ‚Üê setOf_exists] at this
  refine'
    Measure.ext_of_generateFrom_of_cover_subset
      (BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ico Œ±)) (isPiSystem_Ico id id) _ this
      _ _ _
  ¬∑ rintro _ ‚ü®l, -, u, -, h, rfl‚ü©
    exact ‚ü®l, u, h, rfl‚ü©
  ¬∑ refine' sUnion_eq_univ_iff.2 fun x => _
    rcases hsd.exists_le' hsb x with ‚ü®l, hls, hlx‚ü©
    rcases hsd.exists_gt x with ‚ü®u, hus, hxu‚ü©
    exact ‚ü®_, ‚ü®l, hls, u, hus, hlx.trans_lt hxu, rfl‚ü©, hlx, hxu‚ü©
  ¬∑ rintro _ ‚ü®l, -, u, -, hlt, rfl‚ü©
    exact hŒº hlt
  ¬∑ rintro _ ‚ü®l, u, hlt, rfl‚ü©
    exact h hlt
#align measure_theory.measure.ext_of_Ico' MeasureTheory.Measure.ext_of_Ico'

/-- Two measures which are finite on closed-open intervals are equal if they agree on all
open-closed intervals. -/
theorem ext_of_Ioc' {Œ± : Type*} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] [NoMinOrder Œ±]
    (Œº ŒΩ : Measure Œ±) (hŒº : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) ‚â† ‚àû)
    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) = ŒΩ (Ioc a b)) : Œº = ŒΩ := by
  refine' @ext_of_Ico' Œ±·µí·µà _ _ _ _ _ ‚Äπ_‚Ä∫ _ Œº ŒΩ _ _ <;> intro a b hab <;> erw [dual_Ico (Œ± := Œ±)]
  exacts [hŒº hab, h hab]
#align measure_theory.measure.ext_of_Ioc' MeasureTheory.Measure.ext_of_Ioc'

/-- Two measures which are finite on closed-open intervals are equal if they agree on all
closed-open intervals. -/
theorem ext_of_Ico {Œ± : Type*} [TopologicalSpace Œ±] {_m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [ConditionallyCompleteLinearOrder Œ±] [OrderTopology Œ±]
    [BorelSpace Œ±] [NoMaxOrder Œ±] (Œº ŒΩ : Measure Œ±) [IsLocallyFiniteMeasure Œº]
    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) = ŒΩ (Ico a b)) : Œº = ŒΩ :=
  Œº.ext_of_Ico' ŒΩ (fun _ _ _ => measure_Ico_lt_top.ne) h
#align measure_theory.measure.ext_of_Ico MeasureTheory.Measure.ext_of_Ico

/-- Two measures which are finite on closed-open intervals are equal if they agree on all
open-closed intervals. -/
theorem ext_of_Ioc {Œ± : Type*} [TopologicalSpace Œ±] {_m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [ConditionallyCompleteLinearOrder Œ±] [OrderTopology Œ±]
    [BorelSpace Œ±] [NoMinOrder Œ±] (Œº ŒΩ : Measure Œ±) [IsLocallyFiniteMeasure Œº]
    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) = ŒΩ (Ioc a b)) : Œº = ŒΩ :=
  Œº.ext_of_Ioc' ŒΩ (fun _ _ _ => measure_Ioc_lt_top.ne) h
#align measure_theory.measure.ext_of_Ioc MeasureTheory.Measure.ext_of_Ioc

/-- Two finite measures on a Borel space are equal if they agree on all left-infinite right-closed
intervals. -/
theorem ext_of_Iic {Œ± : Type*} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] (Œº ŒΩ : Measure Œ±)
    [IsFiniteMeasure Œº] (h : ‚àÄ a, Œº (Iic a) = ŒΩ (Iic a)) : Œº = ŒΩ := by
  refine' ext_of_Ioc_finite Œº ŒΩ _ fun a b hlt => _
  ¬∑ rcases exists_countable_dense_bot_top Œ± with ‚ü®s, hsc, hsd, -, hst‚ü©
    have : DirectedOn (¬∑ ‚â§ ¬∑) s := directedOn_iff_directed.2 (Subtype.mono_coe _).directed_le
    simp only [‚Üê biSup_measure_Iic hsc (hsd.exists_ge' hst) this, h]
  rw [‚Üê Iic_diff_Iic, measure_diff (Iic_subset_Iic.2 hlt.le) measurableSet_Iic,
    measure_diff (Iic_subset_Iic.2 hlt.le) measurableSet_Iic, h a, h b]
  ¬∑ rw [‚Üê h a]
    exact (measure_lt_top Œº _).ne
  ¬∑ exact (measure_lt_top Œº _).ne
#align measure_theory.measure.ext_of_Iic MeasureTheory.Measure.ext_of_Iic

/-- Two finite measures on a Borel space are equal if they agree on all left-closed right-infinite
intervals. -/
theorem ext_of_Ici {Œ± : Type*} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] (Œº ŒΩ : Measure Œ±)
    [IsFiniteMeasure Œº] (h : ‚àÄ a, Œº (Ici a) = ŒΩ (Ici a)) : Œº = ŒΩ :=
  @ext_of_Iic Œ±·µí·µà _ _ _ _ _ ‚Äπ_‚Ä∫ _ _ _ h
#align measure_theory.measure.ext_of_Ici MeasureTheory.Measure.ext_of_Ici

end MeasureTheory.Measure

end LinearOrder

section LinearOrder

variable [LinearOrder Œ±] [OrderClosedTopology Œ±] {a b : Œ±}

@[measurability]
theorem measurableSet_uIcc : MeasurableSet (uIcc a b) :=
  measurableSet_Icc
#align measurable_set_uIcc measurableSet_uIcc

@[measurability]
theorem measurableSet_uIoc : MeasurableSet (uIoc a b) :=
  measurableSet_Ioc
#align measurable_set_uIoc measurableSet_uIoc

variable [SecondCountableTopology Œ±]

@[measurability]
theorem Measurable.max {f g : Œ¥ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun a => max (f a) (g a) := by
  simpa only [max_def'] using hf.piecewise (measurableSet_le hg hf) hg
#align measurable.max Measurable.max

@[measurability]
nonrec theorem AEMeasurable.max {f g : Œ¥ ‚Üí Œ±} {Œº : Measure Œ¥} (hf : AEMeasurable f Œº)
    (hg : AEMeasurable g Œº) : AEMeasurable (fun a => max (f a) (g a)) Œº :=
  ‚ü®fun a => max (hf.mk f a) (hg.mk g a), hf.measurable_mk.max hg.measurable_mk,
    EventuallyEq.comp‚ÇÇ hf.ae_eq_mk _ hg.ae_eq_mk‚ü©
#align ae_measurable.max AEMeasurable.max

@[measurability]
theorem Measurable.min {f g : Œ¥ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun a => min (f a) (g a) := by
  simpa only [min_def] using hf.piecewise (measurableSet_le hf hg) hg
#align measurable.min Measurable.min

@[measurability]
nonrec theorem AEMeasurable.min {f g : Œ¥ ‚Üí Œ±} {Œº : Measure Œ¥} (hf : AEMeasurable f Œº)
    (hg : AEMeasurable g Œº) : AEMeasurable (fun a => min (f a) (g a)) Œº :=
  ‚ü®fun a => min (hf.mk f a) (hg.mk g a), hf.measurable_mk.min hg.measurable_mk,
    EventuallyEq.comp‚ÇÇ hf.ae_eq_mk _ hg.ae_eq_mk‚ü©
#align ae_measurable.min AEMeasurable.min

end LinearOrder

/-- A continuous function from an `OpensMeasurableSpace` to a `BorelSpace`
is measurable. -/
theorem Continuous.measurable {f : Œ± ‚Üí Œ≥} (hf : Continuous f) : Measurable f :=
  hf.borel_measurable.mono OpensMeasurableSpace.borel_le (le_of_eq <| BorelSpace.measurable_eq)
#align continuous.measurable Continuous.measurable

/-- A continuous function from an `OpensMeasurableSpace` to a `BorelSpace`
is ae-measurable. -/
theorem Continuous.aemeasurable {f : Œ± ‚Üí Œ≥} (h : Continuous f) {Œº : Measure Œ±} : AEMeasurable f Œº :=
  h.measurable.aemeasurable
#align continuous.ae_measurable Continuous.aemeasurable

theorem ClosedEmbedding.measurable {f : Œ± ‚Üí Œ≥} (hf : ClosedEmbedding f) : Measurable f :=
  hf.continuous.measurable
#align closed_embedding.measurable ClosedEmbedding.measurable

/-- If a function is defined piecewise in terms of functions which are continuous on their
respective pieces, then it is measurable. -/
theorem ContinuousOn.measurable_piecewise {f g : Œ± ‚Üí Œ≥} {s : Set Œ±} [‚àÄ j : Œ±, Decidable (j ‚àà s)]
    (hf : ContinuousOn f s) (hg : ContinuousOn g s·∂ú) (hs : MeasurableSet s) :
    Measurable (s.piecewise f g) := by
  refine' measurable_of_isOpen fun t ht => _
  rw [piecewise_preimage, Set.ite]
  apply MeasurableSet.union
  ¬∑ rcases _root_.continuousOn_iff'.1 hf t ht with ‚ü®u, u_open, hu‚ü©
    rw [hu]
    exact u_open.measurableSet.inter hs
  ¬∑ rcases _root_.continuousOn_iff'.1 hg t ht with ‚ü®u, u_open, hu‚ü©
    rw [diff_eq_compl_inter, inter_comm, hu]
    exact u_open.measurableSet.inter hs.compl
#align continuous_on.measurable_piecewise ContinuousOn.measurable_piecewise

@[to_additive]
instance (priority := 100) ContinuousMul.measurableMul [Mul Œ≥] [ContinuousMul Œ≥] :
    MeasurableMul Œ≥ where
  measurable_const_mul _ := (continuous_const.mul continuous_id).measurable
  measurable_mul_const _ := (continuous_id.mul continuous_const).measurable
#align has_continuous_mul.has_measurable_mul ContinuousMul.measurableMul
#align has_continuous_add.has_measurable_add ContinuousAdd.measurableAdd

instance (priority := 100) ContinuousSub.measurableSub [Sub Œ≥] [ContinuousSub Œ≥] :
    MeasurableSub Œ≥ where
  measurable_const_sub _ := (continuous_const.sub continuous_id).measurable
  measurable_sub_const _ := (continuous_id.sub continuous_const).measurable
#align has_continuous_sub.has_measurable_sub ContinuousSub.measurableSub

@[to_additive]
instance (priority := 100) TopologicalGroup.measurableInv [Group Œ≥] [TopologicalGroup Œ≥] :
    MeasurableInv Œ≥ :=
  ‚ü®continuous_inv.measurable‚ü©
#align topological_group.has_measurable_inv TopologicalGroup.measurableInv
#align topological_add_group.has_measurable_neg TopologicalAddGroup.measurableNeg

instance (priority := 100) ContinuousSMul.measurableSMul {M Œ±} [TopologicalSpace M]
    [TopologicalSpace Œ±] [MeasurableSpace M] [MeasurableSpace Œ±] [OpensMeasurableSpace M]
    [BorelSpace Œ±] [SMul M Œ±] [ContinuousSMul M Œ±] : MeasurableSMul M Œ± :=
  ‚ü®fun _ => (continuous_const_smul _).measurable, fun _ =>
    (continuous_id.smul continuous_const).measurable‚ü©
#align has_continuous_smul.has_measurable_smul ContinuousSMul.measurableSMul

section Lattice

instance (priority := 100) ContinuousSup.measurableSup [Sup Œ≥] [ContinuousSup Œ≥] :
    MeasurableSup Œ≥ where
  measurable_const_sup _ := (continuous_const.sup continuous_id).measurable
  measurable_sup_const _ := (continuous_id.sup continuous_const).measurable
#align has_continuous_sup.has_measurable_sup ContinuousSup.measurableSup

instance (priority := 100) ContinuousSup.measurableSup‚ÇÇ [SecondCountableTopology Œ≥] [Sup Œ≥]
    [ContinuousSup Œ≥] : MeasurableSup‚ÇÇ Œ≥ :=
  ‚ü®continuous_sup.measurable‚ü©
#align has_continuous_sup.has_measurable_sup‚ÇÇ ContinuousSup.measurableSup‚ÇÇ

instance (priority := 100) ContinuousInf.measurableInf [Inf Œ≥] [ContinuousInf Œ≥] :
    MeasurableInf Œ≥ where
  measurable_const_inf _ := (continuous_const.inf continuous_id).measurable
  measurable_inf_const _ := (continuous_id.inf continuous_const).measurable
#align has_continuous_inf.has_measurable_inf ContinuousInf.measurableInf

instance (priority := 100) ContinuousInf.measurableInf‚ÇÇ [SecondCountableTopology Œ≥] [Inf Œ≥]
    [ContinuousInf Œ≥] : MeasurableInf‚ÇÇ Œ≥ :=
  ‚ü®continuous_inf.measurable‚ü©
#align has_continuous_inf.has_measurable_inf‚ÇÇ ContinuousInf.measurableInf‚ÇÇ

end Lattice

section Homeomorph

@[measurability]
protected theorem Homeomorph.measurable (h : Œ± ‚âÉ‚Çú Œ≥) : Measurable h :=
  h.continuous.measurable
#align homeomorph.measurable Homeomorph.measurable

/-- A homeomorphism between two Borel spaces is a measurable equivalence.-/
def Homeomorph.toMeasurableEquiv (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : Œ≥ ‚âÉ·µê Œ≥‚ÇÇ where
  measurable_toFun := h.measurable
  measurable_invFun := h.symm.measurable
  toEquiv := h.toEquiv
#align homeomorph.to_measurable_equiv Homeomorph.toMeasurableEquiv

lemma Homeomorph.measurableEmbedding (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : MeasurableEmbedding h :=
  h.toMeasurableEquiv.measurableEmbedding

@[simp]
theorem Homeomorph.toMeasurableEquiv_coe (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : (h.toMeasurableEquiv : Œ≥ ‚Üí Œ≥‚ÇÇ) = h :=
  rfl
#align homeomorph.to_measurable_equiv_coe Homeomorph.toMeasurableEquiv_coe

@[simp]
theorem Homeomorph.toMeasurableEquiv_symm_coe (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) :
    (h.toMeasurableEquiv.symm : Œ≥‚ÇÇ ‚Üí Œ≥) = h.symm :=
  rfl
#align homeomorph.to_measurable_equiv_symm_coe Homeomorph.toMeasurableEquiv_symm_coe

end Homeomorph

@[measurability]
theorem ContinuousMap.measurable (f : C(Œ±, Œ≥)) : Measurable f :=
  f.continuous.measurable
#align continuous_map.measurable ContinuousMap.measurable

theorem measurable_of_continuousOn_compl_singleton [T1Space Œ±] {f : Œ± ‚Üí Œ≥} (a : Œ±)
    (hf : ContinuousOn f {a}·∂ú) : Measurable f :=
  measurable_of_measurable_on_compl_singleton a
    (continuousOn_iff_continuous_restrict.1 hf).measurable
#align measurable_of_continuous_on_compl_singleton measurable_of_continuousOn_compl_singleton

theorem Continuous.measurable2 [SecondCountableTopologyEither Œ± Œ≤] {f : Œ¥ ‚Üí Œ±}
    {g : Œ¥ ‚Üí Œ≤} {c : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (h : Continuous fun p : Œ± √ó Œ≤ => c p.1 p.2) (hf : Measurable f)
    (hg : Measurable g) : Measurable fun a => c (f a) (g a) :=
  h.measurable.comp (hf.prod_mk hg)
#align continuous.measurable2 Continuous.measurable2

theorem Continuous.aemeasurable2 [SecondCountableTopologyEither Œ± Œ≤]
    {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ≤} {c : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {Œº : Measure Œ¥}
    (h : Continuous fun p : Œ± √ó Œ≤ => c p.1 p.2) (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    AEMeasurable (fun a => c (f a) (g a)) Œº :=
  h.measurable.comp_aemeasurable (hf.prod_mk hg)
#align continuous.ae_measurable2 Continuous.aemeasurable2

instance (priority := 100) HasContinuousInv‚ÇÄ.measurableInv [GroupWithZero Œ≥] [T1Space Œ≥]
    [HasContinuousInv‚ÇÄ Œ≥] : MeasurableInv Œ≥ :=
  ‚ü®measurable_of_continuousOn_compl_singleton 0 continuousOn_inv‚ÇÄ‚ü©
#align has_continuous_inv‚ÇÄ.has_measurable_inv HasContinuousInv‚ÇÄ.measurableInv

@[to_additive]
instance (priority := 100) ContinuousMul.measurableMul‚ÇÇ [SecondCountableTopology Œ≥] [Mul Œ≥]
    [ContinuousMul Œ≥] : MeasurableMul‚ÇÇ Œ≥ :=
  ‚ü®continuous_mul.measurable‚ü©
#align has_continuous_mul.has_measurable_mul‚ÇÇ ContinuousMul.measurableMul‚ÇÇ
#align has_continuous_add.has_measurable_mul‚ÇÇ ContinuousAdd.measurableMul‚ÇÇ

instance (priority := 100) ContinuousSub.measurableSub‚ÇÇ [SecondCountableTopology Œ≥] [Sub Œ≥]
    [ContinuousSub Œ≥] : MeasurableSub‚ÇÇ Œ≥ :=
  ‚ü®continuous_sub.measurable‚ü©
#align has_continuous_sub.has_measurable_sub‚ÇÇ ContinuousSub.measurableSub‚ÇÇ

instance (priority := 100) ContinuousSMul.measurableSMul‚ÇÇ {M Œ±} [TopologicalSpace M]
    [MeasurableSpace M] [OpensMeasurableSpace M] [TopologicalSpace Œ±]
    [SecondCountableTopologyEither M Œ±] [MeasurableSpace Œ±] [BorelSpace Œ±] [SMul M Œ±]
    [ContinuousSMul M Œ±] : MeasurableSMul‚ÇÇ M Œ± :=
  ‚ü®continuous_smul.measurable‚ü©
#align has_continuous_smul.has_measurable_smul‚ÇÇ ContinuousSMul.measurableSMul‚ÇÇ

end

section BorelSpace

variable [TopologicalSpace Œ±] [MeasurableSpace Œ±] [BorelSpace Œ±] [TopologicalSpace Œ≤]
  [MeasurableSpace Œ≤] [BorelSpace Œ≤] [TopologicalSpace Œ≥] [MeasurableSpace Œ≥] [BorelSpace Œ≥]
  [MeasurableSpace Œ¥]

theorem pi_le_borel_pi {Œπ : Type*} {œÄ : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (œÄ i)]
    [‚àÄ i, MeasurableSpace (œÄ i)] [‚àÄ i, BorelSpace (œÄ i)] :
      MeasurableSpace.pi ‚â§ borel (‚àÄ i, œÄ i) := by
  have : ‚Äπ‚àÄ i, MeasurableSpace (œÄ i)‚Ä∫ = fun i => borel (œÄ i) :=
    funext fun i => BorelSpace.measurable_eq
  rw [this]
  exact iSup_le fun i => comap_le_iff_le_map.2 <| (continuous_apply i).borel_measurable
#align pi_le_borel_pi pi_le_borel_pi

theorem prod_le_borel_prod : Prod.instMeasurableSpace ‚â§ borel (Œ± √ó Œ≤) := by
  rw [‚ÄπBorelSpace Œ±‚Ä∫.measurable_eq, ‚ÄπBorelSpace Œ≤‚Ä∫.measurable_eq]
  refine' sup_le _ _
  ¬∑ exact comap_le_iff_le_map.mpr continuous_fst.borel_measurable
  ¬∑ exact comap_le_iff_le_map.mpr continuous_snd.borel_measurable
#align prod_le_borel_prod prod_le_borel_prod

instance Pi.borelSpace {Œπ : Type*} {œÄ : Œπ ‚Üí Type*} [Countable Œπ] [‚àÄ i, TopologicalSpace (œÄ i)]
    [‚àÄ i, MeasurableSpace (œÄ i)] [‚àÄ i, SecondCountableTopology (œÄ i)] [‚àÄ i, BorelSpace (œÄ i)] :
    BorelSpace (‚àÄ i, œÄ i) :=
  ‚ü®le_antisymm pi_le_borel_pi OpensMeasurableSpace.borel_le‚ü©
#align pi.borel_space Pi.borelSpace

instance Prod.borelSpace [SecondCountableTopologyEither Œ± Œ≤] :
    BorelSpace (Œ± √ó Œ≤) :=
  ‚ü®le_antisymm prod_le_borel_prod OpensMeasurableSpace.borel_le‚ü©
#align prod.borel_space Prod.borelSpace

protected theorem Embedding.measurableEmbedding {f : Œ± ‚Üí Œ≤} (h‚ÇÅ : Embedding f)
    (h‚ÇÇ : MeasurableSet (range f)) : MeasurableEmbedding f :=
  show MeasurableEmbedding
      (((‚Üë) : range f ‚Üí Œ≤) ‚àò (Homeomorph.ofEmbedding f h‚ÇÅ).toMeasurableEquiv) from
    (MeasurableEmbedding.subtype_coe h‚ÇÇ).comp (MeasurableEquiv.measurableEmbedding _)
#align embedding.measurable_embedding Embedding.measurableEmbedding

protected theorem ClosedEmbedding.measurableEmbedding {f : Œ± ‚Üí Œ≤} (h : ClosedEmbedding f) :
    MeasurableEmbedding f :=
  h.toEmbedding.measurableEmbedding h.closed_range.measurableSet
#align closed_embedding.measurable_embedding ClosedEmbedding.measurableEmbedding

protected theorem OpenEmbedding.measurableEmbedding {f : Œ± ‚Üí Œ≤} (h : OpenEmbedding f) :
    MeasurableEmbedding f :=
  h.toEmbedding.measurableEmbedding h.open_range.measurableSet
#align open_embedding.measurable_embedding OpenEmbedding.measurableEmbedding

section LinearOrder

variable [LinearOrder Œ±] [OrderTopology Œ±] [SecondCountableTopology Œ±]

theorem measurable_of_Iio {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, MeasurableSet (f ‚Åª¬π' Iio x)) : Measurable f := by
  convert measurable_generateFrom (Œ± := Œ¥) _
  ¬∑ exact BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Iio _)
  ¬∑ rintro _ ‚ü®x, rfl‚ü©; exact hf x
#align measurable_of_Iio measurable_of_Iio

theorem UpperSemicontinuous.measurable [TopologicalSpace Œ¥] [OpensMeasurableSpace Œ¥] {f : Œ¥ ‚Üí Œ±}
    (hf : UpperSemicontinuous f) : Measurable f :=
  measurable_of_Iio fun y => (hf.isOpen_preimage y).measurableSet
#align upper_semicontinuous.measurable UpperSemicontinuous.measurable

theorem measurable_of_Ioi {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, MeasurableSet (f ‚Åª¬π' Ioi x)) : Measurable f := by
  convert measurable_generateFrom (Œ± := Œ¥) _
  ¬∑ exact BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ioi _)
  ¬∑ rintro _ ‚ü®x, rfl‚ü©; exact hf x
#align measurable_of_Ioi measurable_of_Ioi

theorem LowerSemicontinuous.measurable [TopologicalSpace Œ¥] [OpensMeasurableSpace Œ¥] {f : Œ¥ ‚Üí Œ±}
    (hf : LowerSemicontinuous f) : Measurable f :=
  measurable_of_Ioi fun y => (hf.isOpen_preimage y).measurableSet
#align lower_semicontinuous.measurable LowerSemicontinuous.measurable

theorem measurable_of_Iic {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, MeasurableSet (f ‚Åª¬π' Iic x)) : Measurable f := by
  apply measurable_of_Ioi
  simp_rw [‚Üê compl_Iic, preimage_compl, MeasurableSet.compl_iff]
  assumption
#align measurable_of_Iic measurable_of_Iic

theorem measurable_of_Ici {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, MeasurableSet (f ‚Åª¬π' Ici x)) : Measurable f := by
  apply measurable_of_Iio
  simp_rw [‚Üê compl_Ici, preimage_compl, MeasurableSet.compl_iff]
  assumption
#align measurable_of_Ici measurable_of_Ici

/-- If a function is the least upper bound of countably many measurable functions,
then it is measurable. -/
theorem Measurable.isLUB {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i))
    (hg : ‚àÄ b, IsLUB { a | ‚àÉ i, f i b = a } (g b)) : Measurable g := by
  change ‚àÄ b, IsLUB (range fun i => f i b) (g b) at hg
  rw [‚ÄπBorelSpace Œ±‚Ä∫.measurable_eq, borel_eq_generateFrom_Ioi Œ±]
  apply measurable_generateFrom
  rintro _ ‚ü®a, rfl‚ü©
  simp_rw [Set.preimage, mem_Ioi, lt_isLUB_iff (hg _), exists_range_iff, setOf_exists]
  exact MeasurableSet.iUnion fun i => hf i (isOpen_lt' _).measurableSet
#align measurable.is_lub Measurable.isLUB

/-- If a function is the least upper bound of countably many measurable functions on a measurable
set `s`, and coincides with a measurable function outside of `s`, then it is measurable. -/
theorem Measurable.isLUB_of_mem {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g g' : Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, Measurable (f i))
    {s : Set Œ¥} (hs : MeasurableSet s) (hg : ‚àÄ b ‚àà s, IsLUB { a | ‚àÉ i, f i b = a } (g b))
    (hg' : EqOn g g' s·∂ú) (g'_meas : Measurable g') : Measurable g := by
  rcases isEmpty_or_nonempty Œπ with hŒπ|‚ü®‚ü®i‚ü©‚ü©
  ¬∑ rcases eq_empty_or_nonempty s with rfl|‚ü®x, hx‚ü©
    ¬∑ convert g'_meas
      rwa [compl_empty, eqOn_univ] at hg'
    ¬∑ have A : ‚àÄ b ‚àà s, IsBot (g b) := by simpa using hg
      have B : ‚àÄ b ‚àà s, g b = g x := by
        intro b hb
        apply le_antisymm (A b hb (g x)) (A x hx (g b))
      have : g = s.piecewise (fun _y ‚Ü¶ g x) g' := by
        ext b
        by_cases hb : b ‚àà s
        ¬∑ simp [hb, B]
        ¬∑ simp [hb, hg' hb]
      rw [this]
      exact Measurable.piecewise hs measurable_const g'_meas
  ¬∑ let f' : Œπ ‚Üí Œ¥ ‚Üí Œ± := fun i ‚Ü¶ s.piecewise (f i) g'
    suffices ‚àÄ b, IsLUB { a | ‚àÉ i, f' i b = a } (g b) from
      Measurable.isLUB (fun i ‚Ü¶ Measurable.piecewise hs (hf i) g'_meas) this
    intro b
    by_cases hb : b ‚àà s
    ¬∑ have A : ‚àÄ i, f' i b = f i b := fun i ‚Ü¶ by simp [hb]
      simpa [A] using hg b hb
    ¬∑ have A : ‚àÄ i, f' i b = g' b := fun i ‚Ü¶ by simp [hb]
      have : {a | ‚àÉ (_i : Œπ), g' b = a} = {g' b} := by
        apply Subset.antisymm
        ¬∑ rintro - ‚ü®_j, rfl‚ü©
          simp only [mem_singleton_iff]
        ¬∑ rintro - rfl
          exact ‚ü®i, rfl‚ü©
      simp [A, this, hg' hb, isLUB_singleton]

theorem AEMeasurable.isLUB {Œπ} {Œº : Measure Œ¥} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, AEMeasurable (f i) Œº) (hg : ‚àÄ·µê b ‚àÇŒº, IsLUB { a | ‚àÉ i, f i b = a } (g b)) :
    AEMeasurable g Œº := by
  nontriviality Œ±
  haveI hŒ± : Nonempty Œ± := inferInstance
  cases' isEmpty_or_nonempty Œπ with hŒπ hŒπ
  ¬∑ simp only [IsEmpty.exists_iff, setOf_false, isLUB_empty_iff] at hg
    exact aemeasurable_const' (hg.mono fun a ha => hg.mono fun b hb => (ha _).antisymm (hb _))
  let p : Œ¥ ‚Üí (Œπ ‚Üí Œ±) ‚Üí Prop := fun x f' => IsLUB { a | ‚àÉ i, f' i = a } (g x)
  let g_seq := (aeSeqSet hf p).piecewise g fun _ => hŒ±.some
  have hg_seq : ‚àÄ b, IsLUB { a | ‚àÉ i, aeSeq hf p i b = a } (g_seq b) := by
    intro b
    simp only [aeSeq, Set.piecewise]
    split_ifs with h
    ¬∑ have h_set_eq : { a : Œ± | ‚àÉ i : Œπ, (hf i).mk (f i) b = a } =
        { a : Œ± | ‚àÉ i : Œπ, f i b = a } := by
        ext x
        simp_rw [Set.mem_setOf_eq, aeSeq.mk_eq_fun_of_mem_aeSeqSet hf h]
      rw [h_set_eq]
      exact aeSeq.fun_prop_of_mem_aeSeqSet hf h
    ¬∑ exact IsGreatest.isLUB ‚ü®(@exists_const (hŒ±.some = hŒ±.some) Œπ _).2 rfl, fun x ‚ü®i, hi‚ü© => hi.ge‚ü©
  refine' ‚ü®g_seq, Measurable.isLUB (aeSeq.measurable hf p) hg_seq, _‚ü©
  exact
    (ite_ae_eq_of_measure_compl_zero g (fun _ => hŒ±.some) (aeSeqSet hf p)
        (aeSeq.measure_compl_aeSeqSet_eq_zero hf hg)).symm
#align ae_measurable.is_lub AEMeasurable.isLUB

/-- If a function is the greatest lower bound of countably many measurable functions,
then it is measurable. -/
theorem Measurable.isGLB {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i))
    (hg : ‚àÄ b, IsGLB { a | ‚àÉ i, f i b = a } (g b)) : Measurable g :=
  Measurable.isLUB (Œ± := Œ±·µí·µà) hf hg
#align measurable.is_glb Measurable.isGLB

/-- If a function is the greatest lower bound of countably many measurable functions on a measurable
set `s`, and coincides with a measurable function outside of `s`, then it is measurable. -/
theorem Measurable.isGLB_of_mem {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g g' : Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, Measurable (f i))
    {s : Set Œ¥} (hs : MeasurableSet s) (hg : ‚àÄ b ‚àà s, IsGLB { a | ‚àÉ i, f i b = a } (g b))
    (hg' : EqOn g g' s·∂ú) (g'_meas : Measurable g') : Measurable g :=
  Measurable.isLUB_of_mem (Œ± := Œ±·µí·µà) hf hs hg hg'  g'_meas

theorem AEMeasurable.isGLB {Œπ} {Œº : Measure Œ¥} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, AEMeasurable (f i) Œº) (hg : ‚àÄ·µê b ‚àÇŒº, IsGLB { a | ‚àÉ i, f i b = a } (g b)) :
    AEMeasurable g Œº :=
  AEMeasurable.isLUB (Œ± := Œ±·µí·µà) hf hg
#align ae_measurable.is_glb AEMeasurable.isGLB

protected theorem Monotone.measurable [LinearOrder Œ≤] [OrderClosedTopology Œ≤] {f : Œ≤ ‚Üí Œ±}
    (hf : Monotone f) : Measurable f :=
  suffices h : ‚àÄ x, OrdConnected (f ‚Åª¬π' Ioi x) from measurable_of_Ioi fun x => (h x).measurableSet
  fun _ => ordConnected_def.mpr fun _a ha _ _ _c hc => lt_of_lt_of_le ha (hf hc.1)
#align monotone.measurable Monotone.measurable

theorem aemeasurable_restrict_of_monotoneOn [LinearOrder Œ≤] [OrderClosedTopology Œ≤] {Œº : Measure Œ≤}
    {s : Set Œ≤} (hs : MeasurableSet s) {f : Œ≤ ‚Üí Œ±} (hf : MonotoneOn f s) :
    AEMeasurable f (Œº.restrict s) :=
  have : Monotone (f ‚àò (‚Üë) : s ‚Üí Œ±) := fun ‚ü®x, hx‚ü© ‚ü®y, hy‚ü©=> fun (hxy : x ‚â§ y) => hf hx hy hxy
  aemeasurable_restrict_of_measurable_subtype hs this.measurable
#align ae_measurable_restrict_of_monotone_on aemeasurable_restrict_of_monotoneOn

protected theorem Antitone.measurable [LinearOrder Œ≤] [OrderClosedTopology Œ≤] {f : Œ≤ ‚Üí Œ±}
    (hf : Antitone f) : Measurable f :=
  @Monotone.measurable Œ±·µí·µà Œ≤ _ _ ‚Äπ_‚Ä∫ _ _ _ _ _ ‚Äπ_‚Ä∫ _ _ _ hf
#align antitone.measurable Antitone.measurable

theorem aemeasurable_restrict_of_antitoneOn [LinearOrder Œ≤] [OrderClosedTopology Œ≤] {Œº : Measure Œ≤}
    {s : Set Œ≤} (hs : MeasurableSet s) {f : Œ≤ ‚Üí Œ±} (hf : AntitoneOn f s) :
    AEMeasurable f (Œº.restrict s) :=
  @aemeasurable_restrict_of_monotoneOn Œ±·µí·µà Œ≤ _ _ ‚Äπ_‚Ä∫ _ _ _ _ _ ‚Äπ_‚Ä∫ _ _ _ _ hs _ hf
#align ae_measurable_restrict_of_antitone_on aemeasurable_restrict_of_antitoneOn

theorem measurableSet_of_mem_nhdsWithin_Ioi_aux {s : Set Œ±} (h : ‚àÄ x ‚àà s, s ‚àà ùìù[>] x)
    (h' : ‚àÄ x ‚àà s, ‚àÉ y, x < y) : MeasurableSet s := by
  choose! M hM using h'
  suffices H : (s \ interior s).Countable by
    have : s = interior s ‚à™ s \ interior s := by rw [union_diff_cancel interior_subset]
    rw [this]
    exact isOpen_interior.measurableSet.union H.measurableSet
  have A : ‚àÄ x ‚àà s, ‚àÉ y ‚àà Ioi x, Ioo x y ‚äÜ s := fun x hx =>
    (mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' (hM x hx)).1 (h x hx)
  choose! y hy h'y using A
  have B : Set.PairwiseDisjoint (s \ interior s) fun x => Ioo x (y x) := by
    intro x hx x' hx' hxx'
    rcases lt_or_gt_of_ne hxx' with (h' | h')
    ¬∑ refine disjoint_left.2 fun z hz h'z => ?_
      have : x' ‚àà interior s :=
        mem_interior.2 ‚ü®Ioo x (y x), h'y _ hx.1, isOpen_Ioo, ‚ü®h', h'z.1.trans hz.2‚ü©‚ü©
      exact False.elim (hx'.2 this)
    ¬∑ refine disjoint_left.2 fun z hz h'z => ?_
      have : x ‚àà interior s :=
        mem_interior.2 ‚ü®Ioo x' (y x'), h'y _ hx'.1, isOpen_Ioo, ‚ü®h', hz.1.trans h'z.2‚ü©‚ü©
      exact False.elim (hx.2 this)
  exact B.countable_of_Ioo fun x hx => hy x hx.1
#align measurable_set_of_mem_nhds_within_Ioi_aux measurableSet_of_mem_nhdsWithin_Ioi_aux

/-- If a set is a right-neighborhood of all of its points, then it is measurable. -/
theorem measurableSet_of_mem_nhdsWithin_Ioi {s : Set Œ±} (h : ‚àÄ x ‚àà s, s ‚àà ùìù[>] x) :
    MeasurableSet s := by
  by_cases H : ‚àÉ x ‚àà s, IsTop x
  ¬∑ rcases H with ‚ü®x‚ÇÄ, x‚ÇÄs, h‚ÇÄ‚ü©
    have : s = {x‚ÇÄ} ‚à™ s \ {x‚ÇÄ} := by rw [union_diff_cancel (singleton_subset_iff.2 x‚ÇÄs)]
    rw [this]
    refine' (measurableSet_singleton _).union _
    have A : ‚àÄ x ‚àà s \ {x‚ÇÄ}, x < x‚ÇÄ := fun x hx => lt_of_le_of_ne (h‚ÇÄ _) (by simpa using hx.2)
    refine' measurableSet_of_mem_nhdsWithin_Ioi_aux (fun x hx => _) fun x hx => ‚ü®x‚ÇÄ, A x hx‚ü©
    obtain ‚ü®u, hu, us‚ü© : ‚àÉ (u : Œ±), u ‚àà Ioi x ‚àß Ioo x u ‚äÜ s :=
      (mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' (A x hx)).1 (h x hx.1)
    refine' (mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' (A x hx)).2 ‚ü®u, hu, fun y hy => ‚ü®us hy, _‚ü©‚ü©
    exact ne_of_lt (hy.2.trans_le (h‚ÇÄ _))
  ¬∑ apply measurableSet_of_mem_nhdsWithin_Ioi_aux h
    simp only [IsTop] at H
    push_neg at H
    exact H
#align measurable_set_of_mem_nhds_within_Ioi measurableSet_of_mem_nhdsWithin_Ioi

lemma measurableSet_bddAbove_range {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    MeasurableSet {b | BddAbove (range (fun i ‚Ü¶ f i b))} := by
  rcases isEmpty_or_nonempty Œ± with hŒ±|hŒ±
  ¬∑ have : ‚àÄ b, range (fun i ‚Ü¶ f i b) = ‚àÖ := fun b ‚Ü¶ Iff.mp toFinset_eq_empty rfl
    simp [this]
  have A : ‚àÄ (i : Œπ) (c : Œ±), MeasurableSet {x | f i x ‚â§ c} := by
    intro i c
    exact measurableSet_le (hf i) measurable_const
  have B : ‚àÄ (c : Œ±), MeasurableSet {x | ‚àÄ i, f i x ‚â§ c} := by
    intro c
    rw [setOf_forall]
    exact MeasurableSet.iInter (fun i ‚Ü¶ A i c)
  obtain ‚ü®u, hu‚ü© : ‚àÉ (u : ‚Ñï ‚Üí Œ±), Tendsto u atTop atTop := exists_seq_tendsto (atTop : Filter Œ±)
  have : {b | BddAbove (range (fun i ‚Ü¶ f i b))} = {x | ‚àÉ n, ‚àÄ i, f i x ‚â§ u n} := by
    apply Subset.antisymm
    ¬∑ rintro x ‚ü®c, hc‚ü©
      obtain ‚ü®n, hn‚ü© : ‚àÉ n, c ‚â§ u n := (tendsto_atTop.1 hu c).exists
      exact ‚ü®n, fun i ‚Ü¶ (hc ((mem_range_self i))).trans hn‚ü©
    ¬∑ rintro x ‚ü®n, hn‚ü©
      refine ‚ü®u n, ?_‚ü©
      rintro - ‚ü®i, rfl‚ü©
      exact hn i
  rw [this, setOf_exists]
  exact MeasurableSet.iUnion (fun n ‚Ü¶ B (u n))

lemma measurableSet_bddBelow_range {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    MeasurableSet {b | BddBelow (range (fun i ‚Ü¶ f i b))} :=
  measurableSet_bddAbove_range (Œ± := Œ±·µí·µà) hf

end LinearOrder

@[measurability]
theorem Measurable.iSup_Prop {Œ±} [MeasurableSpace Œ±] [ConditionallyCompleteLattice Œ±]
    (p : Prop) {f : Œ¥ ‚Üí Œ±} (hf : Measurable f) : Measurable fun b => ‚®Ü _ : p, f b := by
  simp_rw [ciSup_eq_ite]
  split_ifs with h
  ¬∑ exact hf
  ¬∑ exact measurable_const
#align measurable.supr_Prop Measurable.iSup_Prop

@[measurability]
theorem Measurable.iInf_Prop {Œ±} [MeasurableSpace Œ±] [ConditionallyCompleteLattice Œ±]
    (p : Prop) {f : Œ¥ ‚Üí Œ±} (hf : Measurable f) : Measurable fun b => ‚®Ö _ : p, f b := by
  simp_rw [ciInf_eq_ite]
  split_ifs with h
  ¬∑ exact hf
  ¬∑ exact measurable_const
#align measurable.infi_Prop Measurable.iInf_Prop

section ConditionallyCompleteLinearOrder

variable [ConditionallyCompleteLinearOrder Œ±] [OrderTopology Œ±] [SecondCountableTopology Œ±]

@[measurability]
theorem measurable_iSup {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    Measurable (fun b ‚Ü¶ ‚®Ü i, f i b) := by
  rcases isEmpty_or_nonempty Œπ with hŒπ|hŒπ
  ¬∑ simp [iSup_of_empty']
  have A : MeasurableSet {b | BddAbove (range (fun i ‚Ü¶ f i b))} :=
    measurableSet_bddAbove_range hf
  have : Measurable (fun (_b : Œ¥) ‚Ü¶ sSup (‚àÖ : Set Œ±)) := measurable_const
  apply Measurable.isLUB_of_mem hf A _ _ this
  ¬∑ rintro b ‚ü®c, hc‚ü©
    apply isLUB_ciSup
    refine ‚ü®c, ?_‚ü©
    rintro d ‚ü®i, rfl‚ü©
    exact hc (mem_range_self i)
  ¬∑ intro b hb
    apply csSup_of_not_bddAbove
    exact hb

@[measurability]
theorem aemeasurable_iSup {Œπ} {Œº : Measure Œ¥} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, AEMeasurable (f i) Œº) : AEMeasurable (fun b => ‚®Ü i, f i b) Œº := by
  refine ‚ü®fun b ‚Ü¶ ‚®Ü i, (hf i).mk (f i) b, measurable_iSup (fun i ‚Ü¶ (hf i).measurable_mk), ?_‚ü©
  filter_upwards [ae_all_iff.2 (fun i ‚Ü¶ (hf i).ae_eq_mk)] with b hb using by simp [hb]
#align ae_measurable_supr aemeasurable_iSup

@[measurability]
theorem measurable_iInf {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    Measurable fun b => ‚®Ö i, f i b :=
  measurable_iSup (Œ± := Œ±·µí·µà) hf
#align measurable_infi measurable_iInf

@[measurability]
theorem aemeasurable_iInf {Œπ} {Œº : Measure Œ¥} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, AEMeasurable (f i) Œº) : AEMeasurable (fun b => ‚®Ö i, f i b) Œº :=
  aemeasurable_iSup (Œ± := Œ±·µí·µà) hf
#align ae_measurable_infi aemeasurable_iInf

theorem measurable_sSup {Œπ} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {s : Set Œπ} (hs : s.Countable)
    (hf : ‚àÄ i ‚àà s, Measurable (f i)) :
    Measurable fun x => sSup ((fun i => f i x) '' s) := by
  have : Countable ‚Üës := countable_coe_iff.2 hs
  convert measurable_iSup (f := (fun (i : s) ‚Ü¶ f i)) (fun i ‚Ü¶ hf i i.2) using 1
  ext b
  congr
  exact image_eq_range (fun i ‚Ü¶ f i b) s
#align measurable_cSup measurable_sSup

theorem measurable_sInf {Œπ} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {s : Set Œπ} (hs : s.Countable)
    (hf : ‚àÄ i ‚àà s, Measurable (f i)) :
    Measurable fun x => sInf ((fun i => f i x) '' s) :=
  measurable_sSup (Œ± := Œ±·µí·µà) hs hf
#align measurable_cInf measurable_sInf

theorem measurable_biSup {Œπ} (s : Set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.Countable)
    (hf : ‚àÄ i ‚àà s, Measurable (f i)) : Measurable fun b => ‚®Ü i ‚àà s, f i b := by
  haveI : Encodable s := hs.toEncodable
  by_cases H : ‚àÄ i, i ‚àà s
  ¬∑ have : ‚àÄ b, ‚®Ü i ‚àà s, f i b = ‚®Ü (i : s), f i b :=
      fun b ‚Ü¶ cbiSup_eq_of_forall (f := fun i ‚Ü¶ f i b) H
    simp only [this]
    exact measurable_iSup (fun (i : s) ‚Ü¶ hf i i.2)
  ¬∑ have : ‚àÄ b, ‚®Ü i ‚àà s, f i b = (‚®Ü (i : s), f i b) ‚äî sSup ‚àÖ :=
      fun b ‚Ü¶ cbiSup_eq_of_not_forall (f := fun i ‚Ü¶ f i b) H
    simp only [this]
    apply Measurable.sup _ measurable_const
    exact measurable_iSup (fun (i : s) ‚Ü¶ hf i i.2)
#align measurable_bsupr measurable_biSup

theorem aemeasurable_biSup {Œπ} {Œº : Measure Œ¥} (s : Set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.Countable)
    (hf : ‚àÄ i ‚àà s, AEMeasurable (f i) Œº) : AEMeasurable (fun b => ‚®Ü i ‚àà s, f i b) Œº := by
  let g : Œπ ‚Üí Œ¥ ‚Üí Œ± := fun i ‚Ü¶ if hi : i ‚àà s then (hf i hi).mk (f i) else fun _b ‚Ü¶ sSup ‚àÖ
  have : ‚àÄ i ‚àà s, Measurable (g i) := by
    intro i hi
    simpa [hi] using (hf i hi).measurable_mk
  refine ‚ü®fun b ‚Ü¶ ‚®Ü (i) (_ : i ‚àà s), g i b, measurable_biSup s hs this, ?_‚ü©
  have : ‚àÄ i ‚àà s, ‚àÄ·µê b ‚àÇŒº, f i b = g i b :=
    fun i hi ‚Ü¶ by simpa [hi] using (hf i hi).ae_eq_mk
  filter_upwards [(ae_ball_iff hs).2 this] with b hb
  exact iSup_congr fun i => iSup_congr (hb i)
#align ae_measurable_bsupr aemeasurable_biSup

theorem measurable_biInf {Œπ} (s : Set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.Countable)
    (hf : ‚àÄ i ‚àà s, Measurable (f i)) : Measurable fun b => ‚®Ö i ‚àà s, f i b :=
  measurable_biSup (Œ± := Œ±·µí·µà) s hs hf
#align measurable_binfi measurable_biInf

theorem aemeasurable_biInf {Œπ} {Œº : Measure Œ¥} (s : Set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.Countable)
    (hf : ‚àÄ i ‚àà s, AEMeasurable (f i) Œº) : AEMeasurable (fun b => ‚®Ö i ‚àà s, f i b) Œº :=
  aemeasurable_biSup (Œ± := Œ±·µí·µà) s hs hf
#align ae_measurable_binfi aemeasurable_biInf

/-- `liminf` over a general filter is measurable. See `measurable_liminf` for the version over `‚Ñï`.
-/
theorem measurable_liminf' {Œπ Œπ'} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {v : Filter Œπ} (hf : ‚àÄ i, Measurable (f i))
    {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí Set Œπ} (hv : v.HasCountableBasis p s) (hs : ‚àÄ j, (s j).Countable) :
    Measurable fun x => liminf (fun i => f i x) v := by
  /- We would like to write the liminf as `‚®Ü (j : Subtype p), ‚®Ö (i : s j), f i x`, as the
  measurability would follow from the measurability of infs and sups. Unfortunately, this is not
  true in general conditionally complete linear orders because of issues with empty sets or sets
  which are not bounded above or below. A slightly more complicated expression for the liminf,
  valid in general, is given in `Filter.HasBasis.liminf_eq_ite`. This expression, built from
  `if ... then ... else` and infs and sups, can be readily checked to be measurable. -/
  have : Countable (Subtype p) := Encodable.nonempty_encodable.1 hv.countable
  rcases isEmpty_or_nonempty (Subtype p) with hp|hp
  ¬∑ simp [hv.liminf_eq_sSup_iUnion_iInter]
  by_cases H : ‚àÉ (j : Subtype p), s j = ‚àÖ
  ¬∑ simp_rw [hv.liminf_eq_ite, if_pos H, measurable_const]
  simp_rw [hv.liminf_eq_ite, if_neg H]
  have : ‚àÄ i, Countable (s i) := fun i ‚Ü¶ countable_coe_iff.2 (hs i)
  let m : Subtype p ‚Üí Set Œ¥ := fun j ‚Ü¶ {x | BddBelow (range (fun (i : s j) ‚Ü¶ f i x))}
  have m_meas : ‚àÄ j, MeasurableSet (m j) :=
    fun j ‚Ü¶ measurableSet_bddBelow_range (fun (i : s j) ‚Ü¶ hf i)
  have mc_meas : MeasurableSet {x | ‚àÄ (j : Subtype p), x ‚àâ m j} := by
    rw [setOf_forall]
    exact MeasurableSet.iInter (fun j ‚Ü¶ (m_meas j).compl)
  apply Measurable.piecewise mc_meas measurable_const
  apply measurable_iSup (fun j ‚Ü¶ ?_)
  let reparam : Œ¥ ‚Üí Subtype p ‚Üí Subtype p := fun x ‚Ü¶ liminf_reparam (fun i ‚Ü¶ f i x) s p
  let F0 : Subtype p ‚Üí Œ¥ ‚Üí Œ± := fun j x ‚Ü¶ ‚®Ö (i : s j), f i x
  have F0_meas : ‚àÄ j, Measurable (F0 j) := fun j ‚Ü¶ measurable_iInf (fun (i : s j) ‚Ü¶ hf i)
  set F1 : Œ¥ ‚Üí Œ± := fun x ‚Ü¶ F0 (reparam x j) x with hF1
  change Measurable F1
  let g : ‚Ñï ‚Üí Subtype p := choose (exists_surjective_nat (Subtype p))
  have Z : ‚àÄ x, ‚àÉ n, x ‚àà m (g n) ‚à® ‚àÄ k, x ‚àâ m k := by
    intro x
    by_cases H : ‚àÉ k, x ‚àà m k
    ¬∑ rcases H with ‚ü®k, hk‚ü©
      rcases choose_spec (exists_surjective_nat (Subtype p)) k with ‚ü®n, rfl‚ü©
      exact ‚ü®n, Or.inl hk‚ü©
    ¬∑ push_neg at H
      exact ‚ü®0, Or.inr H‚ü©
  have : F1 = fun x ‚Ü¶ if x ‚àà m j then F0 j x else F0 (g (Nat.find (Z x))) x := by
    ext x
    have A : reparam x j = if x ‚àà m j then j else g (Nat.find (Z x)) := rfl
    split_ifs with hjx
    ¬∑ have : reparam x j = j := by rw [A, if_pos hjx]
      simp only [hF1, this]
    ¬∑ have : reparam x j = g (Nat.find (Z x)) := by rw [A, if_neg hjx]
      simp only [hF1, this]
  rw [this]
  apply Measurable.piecewise (m_meas j) (F0_meas j)
  apply Measurable.find (fun n ‚Ü¶ F0_meas (g n)) (fun n ‚Ü¶ ?_)
  exact (m_meas (g n)).union mc_meas
#align measurable_liminf' measurable_liminf'

/-- `limsup` over a general filter is measurable. See `measurable_limsup` for the version over `‚Ñï`.
-/
theorem measurable_limsup' {Œπ Œπ'} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {u : Filter Œπ} (hf : ‚àÄ i, Measurable (f i))
    {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí Set Œπ} (hu : u.HasCountableBasis p s) (hs : ‚àÄ i, (s i).Countable) :
    Measurable fun x => limsup (fun i => f i x) u :=
  measurable_liminf' (Œ± := Œ±·µí·µà) hf hu hs
#align measurable_limsup' measurable_limsup'

/-- `liminf` over `‚Ñï` is measurable. See `measurable_liminf'` for a version with a general filter.
-/
@[measurability]
theorem measurable_liminf {f : ‚Ñï ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    Measurable fun x => liminf (fun i => f i x) atTop :=
  measurable_liminf' hf atTop_countable_basis fun _ => to_countable _
#align measurable_liminf measurable_liminf

/-- `limsup` over `‚Ñï` is measurable. See `measurable_limsup'` for a version with a general filter.
-/
@[measurability]
theorem measurable_limsup {f : ‚Ñï ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    Measurable fun x => limsup (fun i => f i x) atTop :=
  measurable_limsup' hf atTop_countable_basis fun _ => to_countable _
#align measurable_limsup measurable_limsup

end ConditionallyCompleteLinearOrder

/-- Convert a `Homeomorph` to a `MeasurableEquiv`. -/
def Homemorph.toMeasurableEquiv (h : Œ± ‚âÉ‚Çú Œ≤) : Œ± ‚âÉ·µê Œ≤ where
  toEquiv := h.toEquiv
  measurable_toFun := h.continuous_toFun.measurable
  measurable_invFun := h.continuous_invFun.measurable
#align homemorph.to_measurable_equiv Homemorph.toMeasurableEquiv

protected theorem IsFiniteMeasureOnCompacts.map (Œº : Measure Œ±) [IsFiniteMeasureOnCompacts Œº]
    (f : Œ± ‚âÉ‚Çú Œ≤) : IsFiniteMeasureOnCompacts (Measure.map f Œº) := by
  refine ‚ü®fun K hK ‚Ü¶ ?_‚ü©
  change Measure.map f.toMeasurableEquiv Œº K < ‚àû
  rw [MeasurableEquiv.map_apply]
  exact IsCompact.measure_lt_top (f.isCompact_preimage.2 hK)
#align is_finite_measure_on_compacts.map IsFiniteMeasureOnCompacts.map

end BorelSpace

instance Empty.borelSpace : BorelSpace Empty :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©
#align empty.borel_space Empty.borelSpace

instance Unit.borelSpace : BorelSpace Unit :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©
#align unit.borel_space Unit.borelSpace

instance Bool.borelSpace : BorelSpace Bool :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©
#align bool.borel_space Bool.borelSpace

instance Nat.borelSpace : BorelSpace ‚Ñï :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©
#align nat.borel_space Nat.borelSpace

instance Int.borelSpace : BorelSpace ‚Ñ§ :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©
#align int.borel_space Int.borelSpace

instance Rat.borelSpace : BorelSpace ‚Ñö :=
  ‚ü®borel_eq_top_of_countable.symm‚ü©
#align rat.borel_space Rat.borelSpace

/- Instances on `Real` and `Complex` are special cases of `IsROrC` but without these instances,
Lean fails to prove `BorelSpace (Œπ ‚Üí ‚Ñù)`, so we leave them here. -/
instance Real.measurableSpace : MeasurableSpace ‚Ñù :=
  borel ‚Ñù
#align real.measurable_space Real.measurableSpace

instance Real.borelSpace : BorelSpace ‚Ñù :=
  ‚ü®rfl‚ü©
#align real.borel_space Real.borelSpace

instance NNReal.measurableSpace : MeasurableSpace ‚Ñù‚â•0 :=
  Subtype.instMeasurableSpace
#align nnreal.measurable_space NNReal.measurableSpace

instance NNReal.borelSpace : BorelSpace ‚Ñù‚â•0 :=
  Subtype.borelSpace _
#align nnreal.borel_space NNReal.borelSpace

instance ENNReal.measurableSpace : MeasurableSpace ‚Ñù‚â•0‚àû :=
  borel ‚Ñù‚â•0‚àû
#align ennreal.measurable_space ENNReal.measurableSpace

instance ENNReal.borelSpace : BorelSpace ‚Ñù‚â•0‚àû :=
  ‚ü®rfl‚ü©
#align ennreal.borel_space ENNReal.borelSpace

instance EReal.measurableSpace : MeasurableSpace EReal :=
  borel EReal
#align ereal.measurable_space EReal.measurableSpace

instance EReal.borelSpace : BorelSpace EReal :=
  ‚ü®rfl‚ü©
#align ereal.borel_space EReal.borelSpace

/-- One can cut out `‚Ñù‚â•0‚àû` into the sets `{0}`, `Ico (t^n) (t^(n+1))` for `n : ‚Ñ§` and `{‚àû}`. This
gives a way to compute the measure of a set in terms of sets on which a given function `f` does not
fluctuate by more than `t`. -/
theorem measure_eq_measure_preimage_add_measure_tsum_Ico_zpow [MeasurableSpace Œ±] (Œº : Measure Œ±)
    {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) {s : Set Œ±} (hs : MeasurableSet s) {t : ‚Ñù‚â•0} (ht : 1 < t) :
    Œº s =
      Œº (s ‚à© f ‚Åª¬π' {0}) + Œº (s ‚à© f ‚Åª¬π' {‚àû}) +
      ‚àë' n : ‚Ñ§, Œº (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
  have A : Œº s = Œº (s ‚à© f ‚Åª¬π' {0}) + Œº (s ‚à© f ‚Åª¬π' Ioi 0) := by
    rw [‚Üê measure_union]
    ¬∑ rw [‚Üê inter_distrib_left, ‚Üê preimage_union, singleton_union, Ioi_insert, ‚Üê _root_.bot_eq_zero,
        Ici_bot, preimage_univ, inter_univ]
    ¬∑ exact disjoint_singleton_left.mpr not_mem_Ioi_self
        |>.preimage f |>.inter_right' s |>.inter_left' s
    ¬∑ exact hs.inter (hf measurableSet_Ioi)
  have B : Œº (s ‚à© f ‚Åª¬π' Ioi 0) = Œº (s ‚à© f ‚Åª¬π' {‚àû}) + Œº (s ‚à© f ‚Åª¬π' Ioo 0 ‚àû) := by
    rw [‚Üê measure_union]
    ¬∑ rw [‚Üê inter_union_distrib_left]
      congr
      ext x
      simp only [mem_singleton_iff, mem_union, mem_Ioo, mem_Ioi, mem_preimage]
      have H : f x = ‚àû ‚à® f x < ‚àû := eq_or_lt_of_le le_top
      cases' H with H H
      ¬∑ simp only [H, eq_self_iff_true, or_false_iff, zero_lt_top, not_top_lt, and_false_iff]
      ¬∑ simp only [H, H.ne, and_true_iff, false_or_iff]
    ¬∑ refine disjoint_left.2 fun x hx h'x => ?_
      have : f x < ‚àû := h'x.2.2
      exact lt_irrefl _ (this.trans_le (le_of_eq hx.2.symm))
    ¬∑ exact hs.inter (hf measurableSet_Ioo)
  have C : Œº (s ‚à© f ‚Åª¬π' Ioo 0 ‚àû) =
      ‚àë' n : ‚Ñ§, Œº (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
    rw [‚Üê measure_iUnion,
      ENNReal.Ioo_zero_top_eq_iUnion_Ico_zpow (ENNReal.one_lt_coe_iff.2 ht) ENNReal.coe_ne_top,
      preimage_iUnion, inter_iUnion]
    ¬∑ intro i j
      simp only [Function.onFun]
      intro hij
      wlog h : i < j generalizing i j
      ¬∑ exact (this hij.symm (hij.lt_or_lt.resolve_left h)).symm
      refine disjoint_left.2 fun x hx h'x => lt_irrefl (f x) ?_
      calc
        f x < (t : ‚Ñù‚â•0‚àû) ^ (i + 1) := hx.2.2
        _ ‚â§ (t : ‚Ñù‚â•0‚àû) ^ j := (ENNReal.zpow_le_of_le (ENNReal.one_le_coe_iff.2 ht.le) h)
        _ ‚â§ f x := h'x.2.1
    ¬∑ intro n
      exact hs.inter (hf measurableSet_Ico)
  rw [A, B, C, add_assoc]
#align measure_eq_measure_preimage_add_measure_tsum_Ico_zpow measure_eq_measure_preimage_add_measure_tsum_Ico_zpow

section PseudoMetricSpace

variable [PseudoMetricSpace Œ±] [MeasurableSpace Œ±] [OpensMeasurableSpace Œ±]

variable [MeasurableSpace Œ≤] {x : Œ±} {Œµ : ‚Ñù}

open Metric

@[measurability]
theorem measurableSet_ball : MeasurableSet (Metric.ball x Œµ) :=
  Metric.isOpen_ball.measurableSet
#align measurable_set_ball measurableSet_ball

@[measurability]
theorem measurableSet_closedBall : MeasurableSet (Metric.closedBall x Œµ) :=
  Metric.isClosed_ball.measurableSet
#align measurable_set_closed_ball measurableSet_closedBall

@[measurability]
theorem measurable_infDist {s : Set Œ±} : Measurable fun x => infDist x s :=
  (continuous_infDist_pt s).measurable
#align measurable_inf_dist measurable_infDist

@[measurability]
theorem Measurable.infDist {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) {s : Set Œ±} :
    Measurable fun x => infDist (f x) s :=
  measurable_infDist.comp hf
#align measurable.inf_dist Measurable.infDist

@[measurability]
theorem measurable_infNndist {s : Set Œ±} : Measurable fun x => infNndist x s :=
  (continuous_infNndist_pt s).measurable
#align measurable_inf_nndist measurable_infNndist

@[measurability]
theorem Measurable.infNndist {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) {s : Set Œ±} :
    Measurable fun x => infNndist (f x) s :=
  measurable_infNndist.comp hf
#align measurable.inf_nndist Measurable.infNndist

section

variable [SecondCountableTopology Œ±]

@[measurability]
theorem measurable_dist : Measurable fun p : Œ± √ó Œ± => dist p.1 p.2 :=
  continuous_dist.measurable
#align measurable_dist measurable_dist

@[measurability]
theorem Measurable.dist {f g : Œ≤ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun b => dist (f b) (g b) :=
  (@continuous_dist Œ± _).measurable2 hf hg
#align measurable.dist Measurable.dist

@[measurability]
theorem measurable_nndist : Measurable fun p : Œ± √ó Œ± => nndist p.1 p.2 :=
  continuous_nndist.measurable
#align measurable_nndist measurable_nndist

@[measurability]
theorem Measurable.nndist {f g : Œ≤ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun b => nndist (f b) (g b) :=
  (@continuous_nndist Œ± _).measurable2 hf hg
#align measurable.nndist Measurable.nndist

end

end PseudoMetricSpace

section PseudoEMetricSpace

variable [PseudoEMetricSpace Œ±] [MeasurableSpace Œ±] [OpensMeasurableSpace Œ±]

variable [MeasurableSpace Œ≤] {x : Œ±} {Œµ : ‚Ñù‚â•0‚àû}

open EMetric

@[measurability]
theorem measurableSet_eball : MeasurableSet (EMetric.ball x Œµ) :=
  EMetric.isOpen_ball.measurableSet
#align measurable_set_eball measurableSet_eball

@[measurability]
theorem measurable_edist_right : Measurable (edist x) :=
  (continuous_const.edist continuous_id).measurable
#align measurable_edist_right measurable_edist_right

@[measurability]
theorem measurable_edist_left : Measurable fun y => edist y x :=
  (continuous_id.edist continuous_const).measurable
#align measurable_edist_left measurable_edist_left

@[measurability]
theorem measurable_infEdist {s : Set Œ±} : Measurable fun x => infEdist x s :=
  continuous_infEdist.measurable
#align measurable_inf_edist measurable_infEdist

@[measurability]
theorem Measurable.infEdist {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) {s : Set Œ±} :
    Measurable fun x => infEdist (f x) s :=
  measurable_infEdist.comp hf
#align measurable.inf_edist Measurable.infEdist

open Metric EMetric

/-- If a set has a closed thickening with finite measure, then the measure of its `r`-closed
thickenings converges to the measure of its closure as `r` tends to `0`. -/
theorem tendsto_measure_cthickening {Œº : Measure Œ±} {s : Set Œ±}
    (hs : ‚àÉ R > 0, Œº (cthickening R s) ‚â† ‚àû) :
    Tendsto (fun r => Œº (cthickening r s)) (ùìù 0) (ùìù (Œº (closure s))) := by
  have A : Tendsto (fun r => Œº (cthickening r s)) (ùìù[Ioi 0] 0) (ùìù (Œº (closure s))) := by
    rw [closure_eq_iInter_cthickening]
    exact
      tendsto_measure_biInter_gt (fun r _ => isClosed_cthickening.measurableSet)
        (fun i j _ ij => cthickening_mono ij _) hs
  have B : Tendsto (fun r => Œº (cthickening r s)) (ùìù[Iic 0] 0) (ùìù (Œº (closure s))) := by
    apply Tendsto.congr' _ tendsto_const_nhds
    filter_upwards [self_mem_nhdsWithin (Œ± := ‚Ñù)] with _ hr
    rw [cthickening_of_nonpos hr]
  convert B.sup A
  exact (nhds_left_sup_nhds_right' 0).symm
#align tendsto_measure_cthickening tendsto_measure_cthickening

/-- If a closed set has a closed thickening with finite measure, then the measure of its closed
`r`-thickenings converge to its measure as `r` tends to `0`. -/
theorem tendsto_measure_cthickening_of_isClosed {Œº : Measure Œ±} {s : Set Œ±}
    (hs : ‚àÉ R > 0, Œº (cthickening R s) ‚â† ‚àû) (h's : IsClosed s) :
    Tendsto (fun r => Œº (cthickening r s)) (ùìù 0) (ùìù (Œº s)) := by
  convert tendsto_measure_cthickening hs
  exact h's.closure_eq.symm
#align tendsto_measure_cthickening_of_is_closed tendsto_measure_cthickening_of_isClosed

/-- If a set has a thickening with finite measure, then the measures of its `r`-thickenings
converge to the measure of its closure as `r > 0` tends to `0`. -/
theorem tendsto_measure_thickening {Œº : Measure Œ±} {s : Set Œ±}
    (hs : ‚àÉ R > 0, Œº (thickening R s) ‚â† ‚àû) :
    Tendsto (fun r => Œº (thickening r s)) (ùìù[>] 0) (ùìù (Œº (closure s))) := by
  rw [closure_eq_iInter_thickening]
  exact tendsto_measure_biInter_gt (fun r _ => isOpen_thickening.measurableSet)
      (fun i j _ ij => thickening_mono ij _) hs

/-- If a closed set has a thickening with finite measure, then the measure of its
`r`-thickenings converge to its measure as `r > 0` tends to `0`. -/
theorem tendsto_measure_thickening_of_isClosed {Œº : Measure Œ±} {s : Set Œ±}
    (hs : ‚àÉ R > 0, Œº (thickening R s) ‚â† ‚àû) (h's : IsClosed s) :
    Tendsto (fun r => Œº (thickening r s)) (ùìù[>] 0) (ùìù (Œº s)) := by
  convert tendsto_measure_thickening hs
  exact h's.closure_eq.symm

variable [SecondCountableTopology Œ±]

@[measurability]
theorem measurable_edist : Measurable fun p : Œ± √ó Œ± => edist p.1 p.2 :=
  continuous_edist.measurable
#align measurable_edist measurable_edist

@[measurability]
theorem Measurable.edist {f g : Œ≤ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun b => edist (f b) (g b) :=
  (@continuous_edist Œ± _).measurable2 hf hg
#align measurable.edist Measurable.edist

@[measurability]
theorem AEMeasurable.edist {f g : Œ≤ ‚Üí Œ±} {Œº : Measure Œ≤} (hf : AEMeasurable f Œº)
    (hg : AEMeasurable g Œº) : AEMeasurable (fun a => edist (f a) (g a)) Œº :=
  (@continuous_edist Œ± _).aemeasurable2 hf hg
#align ae_measurable.edist AEMeasurable.edist

end PseudoEMetricSpace

/-- Given a compact set in a proper space, the measure of its `r`-closed thickenings converges to
its measure as `r` tends to `0`. -/
theorem tendsto_measure_cthickening_of_isCompact [MetricSpace Œ±] [MeasurableSpace Œ±]
    [OpensMeasurableSpace Œ±] [ProperSpace Œ±] {Œº : Measure Œ±} [IsFiniteMeasureOnCompacts Œº]
    {s : Set Œ±} (hs : IsCompact s) :
    Tendsto (fun r => Œº (Metric.cthickening r s)) (ùìù 0) (ùìù (Œº s)) :=
  tendsto_measure_cthickening_of_isClosed
    ‚ü®1, zero_lt_one, hs.isBounded.cthickening.measure_lt_top.ne‚ü© hs.isClosed
#align tendsto_measure_cthickening_of_is_compact tendsto_measure_cthickening_of_isCompact

namespace Real

open MeasurableSpace MeasureTheory

theorem borel_eq_generateFrom_Ioo_rat :
    borel ‚Ñù = .generateFrom (‚ãÉ (a : ‚Ñö) (b : ‚Ñö) (_ : a < b), {Ioo (a : ‚Ñù) (b : ‚Ñù)}) :=
  isTopologicalBasis_Ioo_rat.borel_eq_generateFrom
#align real.borel_eq_generate_from_Ioo_rat Real.borel_eq_generateFrom_Ioo_rat

theorem borel_eq_generateFrom_Iio_rat : borel ‚Ñù = .generateFrom (‚ãÉ a : ‚Ñö, {Iio (a : ‚Ñù)}) := by
  rw [borel_eq_generateFrom_Iio]
  refine le_antisymm
    (generateFrom_le ?_)
    (generateFrom_mono <| iUnion_subset fun q ‚Ü¶ singleton_subset_iff.mpr <| mem_range_self _)
  rintro _ ‚ü®a, rfl‚ü©
  have : IsLUB (range ((‚Üë) : ‚Ñö ‚Üí ‚Ñù) ‚à© Iio a) a := by
    simp [isLUB_iff_le_iff, mem_upperBounds, ‚Üê le_iff_forall_rat_lt_imp_le]
  rw [‚Üê this.biUnion_Iio_eq, ‚Üê image_univ, ‚Üê image_inter_preimage, univ_inter, biUnion_image]
  exact MeasurableSet.biUnion (to_countable _)
    fun b _ => GenerateMeasurable.basic (Iio (b : ‚Ñù)) (by simp)

theorem borel_eq_generateFrom_Ioi_rat : borel ‚Ñù = .generateFrom (‚ãÉ a : ‚Ñö, {Ioi (a : ‚Ñù)}) := by
  rw [borel_eq_generateFrom_Ioi]
  refine le_antisymm
    (generateFrom_le ?_)
    (generateFrom_mono <| iUnion_subset fun q ‚Ü¶ singleton_subset_iff.mpr <| mem_range_self _)
  rintro _ ‚ü®a, rfl‚ü©
  have : IsGLB (range ((‚Üë) : ‚Ñö ‚Üí ‚Ñù) ‚à© Ioi a) a := by
    simp [isGLB_iff_le_iff, mem_lowerBounds, ‚Üê le_iff_forall_lt_rat_imp_le]
  rw [‚Üê this.biUnion_Ioi_eq, ‚Üê image_univ, ‚Üê image_inter_preimage, univ_inter, biUnion_image]
  exact MeasurableSet.biUnion (to_countable _)
    fun b _ => GenerateMeasurable.basic (Ioi (b : ‚Ñù)) (by simp)

theorem borel_eq_generateFrom_Iic_rat : borel ‚Ñù = .generateFrom (‚ãÉ a : ‚Ñö, {Iic (a : ‚Ñù)}) := by
  rw [borel_eq_generateFrom_Ioi_rat, iUnion_singleton_eq_range, iUnion_singleton_eq_range]
  refine le_antisymm (generateFrom_le ?_) (generateFrom_le ?_) <;>
  rintro _ ‚ü®q, rfl‚ü© <;>
  dsimp only <;>
  [rw [‚Üê compl_Iic]; rw [‚Üê compl_Ioi]] <;>
  exact MeasurableSet.compl (GenerateMeasurable.basic _ (mem_range_self q))

theorem borel_eq_generateFrom_Ici_rat : borel ‚Ñù = .generateFrom (‚ãÉ a : ‚Ñö, {Ici (a : ‚Ñù)}) := by
  rw [borel_eq_generateFrom_Iio_rat, iUnion_singleton_eq_range, iUnion_singleton_eq_range]
  refine le_antisymm (generateFrom_le ?_) (generateFrom_le ?_) <;>
  rintro _ ‚ü®q, rfl‚ü© <;>
  dsimp only <;>
  [rw [‚Üê compl_Ici]; rw [‚Üê compl_Iio]] <;>
  exact MeasurableSet.compl (GenerateMeasurable.basic _ (mem_range_self q))

theorem isPiSystem_Ioo_rat :
    IsPiSystem (‚ãÉ (a : ‚Ñö) (b : ‚Ñö) (_ : a < b), {Ioo (a : ‚Ñù) (b : ‚Ñù)}) := by
  convert isPiSystem_Ioo ((‚Üë) : ‚Ñö ‚Üí ‚Ñù) ((‚Üë) : ‚Ñö ‚Üí ‚Ñù)
  ext x
  simp [eq_comm]
#align real.is_pi_system_Ioo_rat Real.isPiSystem_Ioo_rat

theorem isPiSystem_Iio_rat : IsPiSystem (‚ãÉ a : ‚Ñö, {Iio (a : ‚Ñù)}) := by
  convert isPiSystem_image_Iio (((‚Üë) : ‚Ñö ‚Üí ‚Ñù) '' univ)
  ext x
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]

theorem isPiSystem_Ioi_rat : IsPiSystem (‚ãÉ a : ‚Ñö, {Ioi (a : ‚Ñù)}) := by
  convert isPiSystem_image_Ioi (((‚Üë) : ‚Ñö ‚Üí ‚Ñù) '' univ)
  ext x
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]

theorem isPiSystem_Iic_rat : IsPiSystem (‚ãÉ a : ‚Ñö, {Iic (a : ‚Ñù)}) := by
  convert isPiSystem_image_Iic (((‚Üë) : ‚Ñö ‚Üí ‚Ñù) '' univ)
  ext x
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]

theorem isPiSystem_Ici_rat : IsPiSystem (‚ãÉ a : ‚Ñö, {Ici (a : ‚Ñù)}) := by
  convert isPiSystem_image_Ici (((‚Üë) : ‚Ñö ‚Üí ‚Ñù) '' univ)
  ext x
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]

/-- The intervals `(-(n + 1), (n + 1))` form a finite spanning sets in the set of open intervals
with rational endpoints for a locally finite measure `Œº` on `‚Ñù`. -/
def finiteSpanningSetsInIooRat (Œº : Measure ‚Ñù) [IsLocallyFiniteMeasure Œº] :
    Œº.FiniteSpanningSetsIn (‚ãÉ (a : ‚Ñö) (b : ‚Ñö) (_ : a < b), {Ioo (a : ‚Ñù) (b : ‚Ñù)}) where
  set n := Ioo (-(n + 1)) (n + 1)
  set_mem n := by
    simp only [mem_iUnion, mem_singleton_iff]
    refine' ‚ü®-(n + 1 : ‚Ñï), n + 1, _, by simp‚ü©
    -- TODO: norm_cast fails here?
    push_cast
    exact neg_lt_self n.cast_add_one_pos
  finite n := measure_Ioo_lt_top
  spanning :=
    iUnion_eq_univ_iff.2 fun x =>
      ‚ü®‚åä|x|‚åã‚Çä, neg_lt.1 ((neg_le_abs_self x).trans_lt (Nat.lt_floor_add_one _)),
        (le_abs_self x).trans_lt (Nat.lt_floor_add_one _)‚ü©
#align real.finite_spanning_sets_in_Ioo_rat Real.finiteSpanningSetsInIooRat

theorem measure_ext_Ioo_rat {Œº ŒΩ : Measure ‚Ñù} [IsLocallyFiniteMeasure Œº]
    (h : ‚àÄ a b : ‚Ñö, Œº (Ioo a b) = ŒΩ (Ioo a b)) : Œº = ŒΩ :=
  (finiteSpanningSetsInIooRat Œº).ext borel_eq_generateFrom_Ioo_rat isPiSystem_Ioo_rat <| by
    simp only [mem_iUnion, mem_singleton_iff]
    rintro _ ‚ü®a, b, -, rfl‚ü©
    apply h
#align real.measure_ext_Ioo_rat Real.measure_ext_Ioo_rat

end Real

variable [MeasurableSpace Œ±]

@[measurability]
theorem measurable_real_toNNReal : Measurable Real.toNNReal :=
  continuous_real_toNNReal.measurable
#align measurable_real_to_nnreal measurable_real_toNNReal

@[measurability]
theorem Measurable.real_toNNReal {f : Œ± ‚Üí ‚Ñù} (hf : Measurable f) :
    Measurable fun x => Real.toNNReal (f x) :=
  measurable_real_toNNReal.comp hf
#align measurable.real_to_nnreal Measurable.real_toNNReal

@[measurability]
theorem AEMeasurable.real_toNNReal {f : Œ± ‚Üí ‚Ñù} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => Real.toNNReal (f x)) Œº :=
  measurable_real_toNNReal.comp_aemeasurable hf
#align ae_measurable.real_to_nnreal AEMeasurable.real_toNNReal

@[measurability]
theorem measurable_coe_nnreal_real : Measurable ((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù) :=
  NNReal.continuous_coe.measurable
#align measurable_coe_nnreal_real measurable_coe_nnreal_real

@[measurability]
theorem Measurable.coe_nnreal_real {f : Œ± ‚Üí ‚Ñù‚â•0} (hf : Measurable f) :
    Measurable fun x => (f x : ‚Ñù) :=
  measurable_coe_nnreal_real.comp hf
#align measurable.coe_nnreal_real Measurable.coe_nnreal_real

@[measurability]
theorem AEMeasurable.coe_nnreal_real {f : Œ± ‚Üí ‚Ñù‚â•0} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x : ‚Ñù)) Œº :=
  measurable_coe_nnreal_real.comp_aemeasurable hf
#align ae_measurable.coe_nnreal_real AEMeasurable.coe_nnreal_real

@[measurability]
theorem measurable_coe_nnreal_ennreal : Measurable ((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0‚àû) :=
  ENNReal.continuous_coe.measurable
#align measurable_coe_nnreal_ennreal measurable_coe_nnreal_ennreal

@[measurability]
theorem Measurable.coe_nnreal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0} (hf : Measurable f) :
    Measurable fun x => (f x : ‚Ñù‚â•0‚àû) :=
  ENNReal.continuous_coe.measurable.comp hf
#align measurable.coe_nnreal_ennreal Measurable.coe_nnreal_ennreal

@[measurability]
theorem AEMeasurable.coe_nnreal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x : ‚Ñù‚â•0‚àû)) Œº :=
  ENNReal.continuous_coe.measurable.comp_aemeasurable hf
#align ae_measurable.coe_nnreal_ennreal AEMeasurable.coe_nnreal_ennreal

@[measurability]
theorem Measurable.ennreal_ofReal {f : Œ± ‚Üí ‚Ñù} (hf : Measurable f) :
    Measurable fun x => ENNReal.ofReal (f x) :=
  ENNReal.continuous_ofReal.measurable.comp hf
#align measurable.ennreal_of_real Measurable.ennreal_ofReal

@[measurability]
lemma AEMeasurable.ennreal_ofReal {f : Œ± ‚Üí ‚Ñù} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x ‚Ü¶ ENNReal.ofReal (f x)) Œº :=
  ENNReal.continuous_ofReal.measurable.comp_aemeasurable hf

@[simp, norm_cast]
theorem measurable_coe_nnreal_real_iff {f : Œ± ‚Üí ‚Ñù‚â•0} :
    Measurable (fun x => f x : Œ± ‚Üí ‚Ñù) ‚Üî Measurable f :=
  ‚ü®fun h => by simpa only [Real.toNNReal_coe] using h.real_toNNReal, Measurable.coe_nnreal_real‚ü©
#align measurable_coe_nnreal_real_iff measurable_coe_nnreal_real_iff

@[simp, norm_cast]
theorem aEMeasurable_coe_nnreal_real_iff {f : Œ± ‚Üí ‚Ñù‚â•0} {Œº : Measure Œ±} :
    AEMeasurable (fun x => f x : Œ± ‚Üí ‚Ñù) Œº ‚Üî AEMeasurable f Œº :=
  ‚ü®fun h => by simpa only [Real.toNNReal_coe] using h.real_toNNReal, AEMeasurable.coe_nnreal_real‚ü©
#align ae_measurable_coe_nnreal_real_iff aEMeasurable_coe_nnreal_real_iff

/-- The set of finite `‚Ñù‚â•0‚àû` numbers is `MeasurableEquiv` to `‚Ñù‚â•0`. -/
def MeasurableEquiv.ennrealEquivNNReal : { r : ‚Ñù‚â•0‚àû | r ‚â† ‚àû } ‚âÉ·µê ‚Ñù‚â•0 :=
  ENNReal.neTopHomeomorphNNReal.toMeasurableEquiv
#align measurable_equiv.ennreal_equiv_nnreal MeasurableEquiv.ennrealEquivNNReal

namespace ENNReal

theorem measurable_of_measurable_nnreal {f : ‚Ñù‚â•0‚àû ‚Üí Œ±} (h : Measurable fun p : ‚Ñù‚â•0 => f p) :
    Measurable f :=
  measurable_of_measurable_on_compl_singleton ‚àû
    (MeasurableEquiv.ennrealEquivNNReal.symm.measurable_comp_iff.1 h)
#align ennreal.measurable_of_measurable_nnreal ENNReal.measurable_of_measurable_nnreal

/-- `‚Ñù‚â•0‚àû` is `MeasurableEquiv` to `‚Ñù‚â•0 ‚äï Unit`. -/
def ennrealEquivSum : ‚Ñù‚â•0‚àû ‚âÉ·µê Sum ‚Ñù‚â•0 Unit :=
  { Equiv.optionEquivSumPUnit ‚Ñù‚â•0 with
    measurable_toFun := measurable_of_measurable_nnreal measurable_inl
    measurable_invFun :=
      measurable_sum measurable_coe_nnreal_ennreal (@measurable_const ‚Ñù‚â•0‚àû Unit _ _ ‚àû) }
#align ennreal.ennreal_equiv_sum ENNReal.ennrealEquivSum

open Function (uncurry)

theorem measurable_of_measurable_nnreal_prod [MeasurableSpace Œ≤] [MeasurableSpace Œ≥]
    {f : ‚Ñù‚â•0‚àû √ó Œ≤ ‚Üí Œ≥} (H‚ÇÅ : Measurable fun p : ‚Ñù‚â•0 √ó Œ≤ => f (p.1, p.2))
    (H‚ÇÇ : Measurable fun x => f (‚àû, x)) : Measurable f :=
  let e : ‚Ñù‚â•0‚àû √ó Œ≤ ‚âÉ·µê Sum (‚Ñù‚â•0 √ó Œ≤) (Unit √ó Œ≤) :=
    (ennrealEquivSum.prodCongr (MeasurableEquiv.refl Œ≤)).trans
      (MeasurableEquiv.sumProdDistrib _ _ _)
  e.symm.measurable_comp_iff.1 <| measurable_sum H‚ÇÅ (H‚ÇÇ.comp measurable_id.snd)
#align ennreal.measurable_of_measurable_nnreal_prod ENNReal.measurable_of_measurable_nnreal_prod

theorem measurable_of_measurable_nnreal_nnreal [MeasurableSpace Œ≤] {f : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû ‚Üí Œ≤}
    (h‚ÇÅ : Measurable fun p : ‚Ñù‚â•0 √ó ‚Ñù‚â•0 => f (p.1, p.2)) (h‚ÇÇ : Measurable fun r : ‚Ñù‚â•0 => f (‚àû, r))
    (h‚ÇÉ : Measurable fun r : ‚Ñù‚â•0 => f (r, ‚àû)) : Measurable f :=
  measurable_of_measurable_nnreal_prod
    (measurable_swap_iff.1 <| measurable_of_measurable_nnreal_prod (h‚ÇÅ.comp measurable_swap) h‚ÇÉ)
    (measurable_of_measurable_nnreal h‚ÇÇ)
#align ennreal.measurable_of_measurable_nnreal_nnreal ENNReal.measurable_of_measurable_nnreal_nnreal

@[measurability]
theorem measurable_ofReal : Measurable ENNReal.ofReal :=
  ENNReal.continuous_ofReal.measurable
#align ennreal.measurable_of_real ENNReal.measurable_ofReal

@[measurability]
theorem measurable_toReal : Measurable ENNReal.toReal :=
  ENNReal.measurable_of_measurable_nnreal measurable_coe_nnreal_real
#align ennreal.measurable_to_real ENNReal.measurable_toReal

@[measurability]
theorem measurable_toNNReal : Measurable ENNReal.toNNReal :=
  ENNReal.measurable_of_measurable_nnreal measurable_id
#align ennreal.measurable_to_nnreal ENNReal.measurable_toNNReal

instance instMeasurableMul‚ÇÇ : MeasurableMul‚ÇÇ ‚Ñù‚â•0‚àû := by
  refine' ‚ü®measurable_of_measurable_nnreal_nnreal _ _ _‚ü©
  ¬∑ simp only [‚Üê ENNReal.coe_mul, measurable_mul.coe_nnreal_ennreal]
  ¬∑ simp only [ENNReal.top_mul', ENNReal.coe_eq_zero]
    exact measurable_const.piecewise (measurableSet_singleton _) measurable_const
  ¬∑ simp only [ENNReal.mul_top', ENNReal.coe_eq_zero]
    exact measurable_const.piecewise (measurableSet_singleton _) measurable_const
#align ennreal.has_measurable_mul‚ÇÇ ENNReal.instMeasurableMul‚ÇÇ

instance instMeasurableSub‚ÇÇ : MeasurableSub‚ÇÇ ‚Ñù‚â•0‚àû :=
  ‚ü®by
    apply measurable_of_measurable_nnreal_nnreal <;>
      simp [‚Üê WithTop.coe_sub]; exact continuous_sub.measurable.coe_nnreal_ennreal‚ü©
#align ennreal.has_measurable_sub‚ÇÇ ENNReal.instMeasurableSub‚ÇÇ

instance instMeasurableInv : MeasurableInv ‚Ñù‚â•0‚àû :=
  ‚ü®continuous_inv.measurable‚ü©
#align ennreal.has_measurable_inv ENNReal.instMeasurableInv

instance : MeasurableSMul ‚Ñù‚â•0 ‚Ñù‚â•0‚àû where
  measurable_const_smul := by
    simp_rw [ENNReal.smul_def]
    exact fun _ ‚Ü¶ MeasurableSMul.measurable_const_smul _
  measurable_smul_const := fun x ‚Ü¶ by
    simp_rw [ENNReal.smul_def]
    exact measurable_coe_nnreal_ennreal.mul_const _

end ENNReal

@[measurability]
theorem Measurable.ennreal_toNNReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) :
    Measurable fun x => (f x).toNNReal :=
  ENNReal.measurable_toNNReal.comp hf
#align measurable.ennreal_to_nnreal Measurable.ennreal_toNNReal

@[measurability]
theorem AEMeasurable.ennreal_toNNReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x).toNNReal) Œº :=
  ENNReal.measurable_toNNReal.comp_aemeasurable hf
#align ae_measurable.ennreal_to_nnreal AEMeasurable.ennreal_toNNReal

@[simp, norm_cast]
theorem measurable_coe_nnreal_ennreal_iff {f : Œ± ‚Üí ‚Ñù‚â•0} :
    (Measurable fun x => (f x : ‚Ñù‚â•0‚àû)) ‚Üî Measurable f :=
  ‚ü®fun h => h.ennreal_toNNReal, fun h => h.coe_nnreal_ennreal‚ü©
#align measurable_coe_nnreal_ennreal_iff measurable_coe_nnreal_ennreal_iff

@[simp, norm_cast]
theorem aemeasurable_coe_nnreal_ennreal_iff {f : Œ± ‚Üí ‚Ñù‚â•0} {Œº : Measure Œ±} :
    AEMeasurable (fun x => (f x : ‚Ñù‚â•0‚àû)) Œº ‚Üî AEMeasurable f Œº :=
  ‚ü®fun h => h.ennreal_toNNReal, fun h => h.coe_nnreal_ennreal‚ü©
#align ae_measurable_coe_nnreal_ennreal_iff aemeasurable_coe_nnreal_ennreal_iff

@[measurability]
theorem Measurable.ennreal_toReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) :
    Measurable fun x => ENNReal.toReal (f x) :=
  ENNReal.measurable_toReal.comp hf
#align measurable.ennreal_to_real Measurable.ennreal_toReal

@[measurability]
theorem AEMeasurable.ennreal_toReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => ENNReal.toReal (f x)) Œº :=
  ENNReal.measurable_toReal.comp_aemeasurable hf
#align ae_measurable.ennreal_to_real AEMeasurable.ennreal_toReal

/-- note: `‚Ñù‚â•0‚àû` can probably be generalized in a future version of this lemma. -/
@[measurability]
theorem Measurable.ennreal_tsum {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} (h : ‚àÄ i, Measurable (f i)) :
    Measurable fun x => ‚àë' i, f i x := by
  simp_rw [ENNReal.tsum_eq_iSup_sum]
  apply measurable_iSup
  exact fun s => s.measurable_sum fun i _ => h i
#align measurable.ennreal_tsum Measurable.ennreal_tsum

@[measurability]
theorem Measurable.ennreal_tsum' {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} (h : ‚àÄ i, Measurable (f i)) :
    Measurable (‚àë' i, f i) := by
  convert Measurable.ennreal_tsum h with x
  exact tsum_apply (Pi.summable.2 fun _ => ENNReal.summable)
#align measurable.ennreal_tsum' Measurable.ennreal_tsum'

@[measurability]
theorem Measurable.nnreal_tsum {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0} (h : ‚àÄ i, Measurable (f i)) :
    Measurable fun x => ‚àë' i, f i x := by
  simp_rw [NNReal.tsum_eq_toNNReal_tsum]
  exact (Measurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_toNNReal
#align measurable.nnreal_tsum Measurable.nnreal_tsum

@[measurability]
theorem AEMeasurable.ennreal_tsum {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure Œ±}
    (h : ‚àÄ i, AEMeasurable (f i) Œº) : AEMeasurable (fun x => ‚àë' i, f i x) Œº := by
  simp_rw [ENNReal.tsum_eq_iSup_sum]
  apply aemeasurable_iSup
  exact fun s => Finset.aemeasurable_sum s fun i _ => h i
#align ae_measurable.ennreal_tsum AEMeasurable.ennreal_tsum

@[measurability]
theorem AEMeasurable.nnreal_tsum {Œ± : Type*} [MeasurableSpace Œ±] {Œπ : Type*} [Countable Œπ]
    {f : Œπ ‚Üí Œ± ‚Üí NNReal} {Œº : MeasureTheory.Measure Œ±} (h : ‚àÄ i : Œπ, AEMeasurable (f i) Œº) :
    AEMeasurable (fun x : Œ± => ‚àë' i : Œπ, f i x) Œº := by
  simp_rw [NNReal.tsum_eq_toNNReal_tsum]
  exact (AEMeasurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_toNNReal
#align ae_measurable.nnreal_tsum AEMeasurable.nnreal_tsum

@[measurability]
theorem measurable_coe_real_ereal : Measurable ((‚Üë) : ‚Ñù ‚Üí EReal) :=
  continuous_coe_real_ereal.measurable
#align measurable_coe_real_ereal measurable_coe_real_ereal

@[measurability]
theorem Measurable.coe_real_ereal {f : Œ± ‚Üí ‚Ñù} (hf : Measurable f) :
    Measurable fun x => (f x : EReal) :=
  measurable_coe_real_ereal.comp hf
#align measurable.coe_real_ereal Measurable.coe_real_ereal

@[measurability]
theorem AEMeasurable.coe_real_ereal {f : Œ± ‚Üí ‚Ñù} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x : EReal)) Œº :=
  measurable_coe_real_ereal.comp_aemeasurable hf
#align ae_measurable.coe_real_ereal AEMeasurable.coe_real_ereal

/-- The set of finite `EReal` numbers is `MeasurableEquiv` to `‚Ñù`. -/
def MeasurableEquiv.erealEquivReal : ({‚ä•, ‚ä§}·∂ú : Set EReal) ‚âÉ·µê ‚Ñù :=
  EReal.neBotTopHomeomorphReal.toMeasurableEquiv
#align measurable_equiv.ereal_equiv_real MeasurableEquiv.erealEquivReal

theorem EReal.measurable_of_measurable_real {f : EReal ‚Üí Œ±} (h : Measurable fun p : ‚Ñù => f p) :
    Measurable f :=
  measurable_of_measurable_on_compl_finite {‚ä•, ‚ä§} (by simp)
    (MeasurableEquiv.erealEquivReal.symm.measurable_comp_iff.1 h)
#align ereal.measurable_of_measurable_real EReal.measurable_of_measurable_real

@[measurability]
theorem measurable_ereal_toReal : Measurable EReal.toReal :=
  EReal.measurable_of_measurable_real (by simpa using measurable_id)
#align measurable_ereal_to_real measurable_ereal_toReal

@[measurability]
theorem Measurable.ereal_toReal {f : Œ± ‚Üí EReal} (hf : Measurable f) :
    Measurable fun x => (f x).toReal :=
  measurable_ereal_toReal.comp hf
#align measurable.ereal_to_real Measurable.ereal_toReal

@[measurability]
theorem AEMeasurable.ereal_toReal {f : Œ± ‚Üí EReal} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x).toReal) Œº :=
  measurable_ereal_toReal.comp_aemeasurable hf
#align ae_measurable.ereal_to_real AEMeasurable.ereal_toReal

@[measurability]
theorem measurable_coe_ennreal_ereal : Measurable ((‚Üë) : ‚Ñù‚â•0‚àû ‚Üí EReal) :=
  continuous_coe_ennreal_ereal.measurable
#align measurable_coe_ennreal_ereal measurable_coe_ennreal_ereal

@[measurability]
theorem Measurable.coe_ereal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) :
    Measurable fun x => (f x : EReal) :=
  measurable_coe_ennreal_ereal.comp hf
#align measurable.coe_ereal_ennreal Measurable.coe_ereal_ennreal

@[measurability]
theorem AEMeasurable.coe_ereal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x : EReal)) Œº :=
  measurable_coe_ennreal_ereal.comp_aemeasurable hf
#align ae_measurable.coe_ereal_ennreal AEMeasurable.coe_ereal_ennreal

/-- If a function `f : Œ± ‚Üí ‚Ñù‚â•0` is measurable and the measure is œÉ-finite, then there exists
spanning measurable sets with finite measure on which `f` is bounded.
See also `StronglyMeasurable.exists_spanning_measurableSet_norm_le` for functions into normed
groups. -/
theorem exists_spanning_measurableSet_le {m : MeasurableSpace Œ±} {f : Œ± ‚Üí ‚Ñù‚â•0}
    (hf : Measurable f) (Œº : Measure Œ±) [SigmaFinite Œº] :
    ‚àÉ s : ‚Ñï ‚Üí Set Œ±,
      (‚àÄ n, MeasurableSet (s n) ‚àß Œº (s n) < ‚àû ‚àß ‚àÄ x ‚àà s n, f x ‚â§ n) ‚àß
      ‚ãÉ i, s i = Set.univ := by
  let sigma_finite_sets := spanningSets Œº
  let norm_sets := fun n : ‚Ñï => { x | f x ‚â§ n }
  have norm_sets_spanning : ‚ãÉ n, norm_sets n = Set.univ := by
    ext1 x
    simp only [Set.mem_iUnion, Set.mem_setOf_eq, Set.mem_univ, iff_true_iff]
    exact exists_nat_ge (f x)
  let sets n := sigma_finite_sets n ‚à© norm_sets n
  have h_meas : ‚àÄ n, MeasurableSet (sets n) := by
    refine' fun n => MeasurableSet.inter _ _
    ¬∑ exact measurable_spanningSets Œº n
    ¬∑ exact hf measurableSet_Iic
  have h_finite : ‚àÄ n, Œº (sets n) < ‚àû := by
    refine' fun n => (measure_mono (Set.inter_subset_left _ _)).trans_lt _
    exact measure_spanningSets_lt_top Œº n
  refine' ‚ü®sets, fun n => ‚ü®h_meas n, h_finite n, _‚ü©, _‚ü©
  ¬∑ exact fun x hx => hx.2
  ¬∑ have :
      ‚ãÉ i, sigma_finite_sets i ‚à© norm_sets i = (‚ãÉ i, sigma_finite_sets i) ‚à© ‚ãÉ i, norm_sets i := by
      refine' Set.iUnion_inter_of_monotone (monotone_spanningSets Œº) fun i j hij x => _
      simp only [Set.mem_setOf_eq]
      refine' fun hif => hif.trans _
      exact_mod_cast hij
    rw [this, norm_sets_spanning, iUnion_spanningSets Œº, Set.inter_univ]

section NormedAddCommGroup

variable [NormedAddCommGroup Œ±] [OpensMeasurableSpace Œ±] [MeasurableSpace Œ≤]

@[measurability]
theorem measurable_norm : Measurable (norm : Œ± ‚Üí ‚Ñù) :=
  continuous_norm.measurable
#align measurable_norm measurable_norm

@[measurability]
theorem Measurable.norm {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) : Measurable fun a => norm (f a) :=
  measurable_norm.comp hf
#align measurable.norm Measurable.norm

@[measurability]
theorem AEMeasurable.norm {f : Œ≤ ‚Üí Œ±} {Œº : Measure Œ≤} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun a => norm (f a)) Œº :=
  measurable_norm.comp_aemeasurable hf
#align ae_measurable.norm AEMeasurable.norm

@[measurability]
theorem measurable_nnnorm : Measurable (nnnorm : Œ± ‚Üí ‚Ñù‚â•0) :=
  continuous_nnnorm.measurable
#align measurable_nnnorm measurable_nnnorm

@[measurability]
theorem Measurable.nnnorm {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) : Measurable fun a => ‚Äñf a‚Äñ‚Çä :=
  measurable_nnnorm.comp hf
#align measurable.nnnorm Measurable.nnnorm

@[measurability]
theorem AEMeasurable.nnnorm {f : Œ≤ ‚Üí Œ±} {Œº : Measure Œ≤} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun a => ‚Äñf a‚Äñ‚Çä) Œº :=
  measurable_nnnorm.comp_aemeasurable hf
#align ae_measurable.nnnorm AEMeasurable.nnnorm

@[measurability]
theorem measurable_ennnorm : Measurable fun x : Œ± => (‚Äñx‚Äñ‚Çä : ‚Ñù‚â•0‚àû) :=
  measurable_nnnorm.coe_nnreal_ennreal
#align measurable_ennnorm measurable_ennnorm

@[measurability]
theorem Measurable.ennnorm {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) : Measurable fun a => (‚Äñf a‚Äñ‚Çä : ‚Ñù‚â•0‚àû) :=
  hf.nnnorm.coe_nnreal_ennreal
#align measurable.ennnorm Measurable.ennnorm

@[measurability]
theorem AEMeasurable.ennnorm {f : Œ≤ ‚Üí Œ±} {Œº : Measure Œ≤} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun a => (‚Äñf a‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) Œº :=
  measurable_ennnorm.comp_aemeasurable hf
#align ae_measurable.ennnorm AEMeasurable.ennnorm

end NormedAddCommGroup
