/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Yury Kudryashov
-/
import Mathlib.Topology.GDelta
import Mathlib.MeasureTheory.Group.Arithmetic
import Mathlib.Topology.Instances.EReal
import Mathlib.Analysis.Normed.Group.Basic

#align_import measure_theory.constructions.borel_space.basic from "leanprover-community/mathlib"@"9f55d0d4363ae59948c33864cbc52e0b12e0e8ce"

/-!
# Borel (measurable) space

## Main definitions

* `borel Œ±` : the least `œÉ`-algebra that contains all open sets;
* `class BorelSpace` : a space with `TopologicalSpace` and `MeasurableSpace` structures
  such that `‚ÄπMeasurableSpace Œ±‚Ä∫ = borel Œ±`;
* `class OpensMeasurableSpace` : a space with `TopologicalSpace` and `MeasurableSpace`
  structures such that all open sets are measurable; equivalently, `borel Œ± ‚â§ ‚ÄπMeasurableSpace Œ±‚Ä∫`.
* `BorelSpace` instances on `Empty`, `Unit`, `Bool`, `Nat`, `Int`, `Rat`;
* `MeasurableSpace` and `BorelSpace` instances on `‚Ñù`, `‚Ñù‚â•0`, `‚Ñù‚â•0‚àû`.

## Main statements

* `IsOpen.measurableSet`, `IsClosed.measurableSet`: open and closed sets are measurable;
* `Continuous.measurable` : a continuous function is measurable;
* `Continuous.measurable2` : if `f : Œ± ‚Üí Œ≤` and `g : Œ± ‚Üí Œ≥` are measurable and `op : Œ≤ √ó Œ≥ ‚Üí Œ¥`
  is continuous, then `fun x => op (f x, g y)` is measurable;
* `Measurable.add` etc : dot notation for arithmetic operations on `Measurable` predicates,
  and similarly for `dist` and `edist`;
* `AEMeasurable.add` : similar dot notation for almost everywhere measurable functions;
-/


noncomputable section

open Set Filter MeasureTheory

open scoped Classical BigOperators Topology NNReal ENNReal MeasureTheory

universe u v w x y

variable {Œ± Œ≤ Œ≥ Œ≥‚ÇÇ Œ¥ : Type*} {Œπ : Sort y} {s t u : Set Œ±}

open MeasurableSpace TopologicalSpace

/-- `MeasurableSpace` structure generated by `TopologicalSpace`. -/
def borel (Œ± : Type u) [TopologicalSpace Œ±] : MeasurableSpace Œ± :=
  generateFrom { s : Set Œ± | IsOpen s }
#align borel borel

theorem borel_anti : Antitone (@borel Œ±) := fun _ _ h =>
  MeasurableSpace.generateFrom_le fun _ hs => .basic _ (h _ hs)
#align borel_anti borel_anti

theorem borel_eq_top_of_discrete [TopologicalSpace Œ±] [DiscreteTopology Œ±] : borel Œ± = ‚ä§ :=
  top_le_iff.1 fun s _ => GenerateMeasurable.basic s (isOpen_discrete s)
#align borel_eq_top_of_discrete borel_eq_top_of_discrete

theorem borel_eq_top_of_countable [TopologicalSpace Œ±] [T1Space Œ±] [Countable Œ±] : borel Œ± = ‚ä§ := by
  refine' top_le_iff.1 fun s _ => biUnion_of_singleton s ‚ñ∏ _
  apply MeasurableSet.biUnion s.to_countable
  intro x _
  apply MeasurableSet.of_compl
  apply GenerateMeasurable.basic
  exact isClosed_singleton.isOpen_compl
#align borel_eq_top_of_countable borel_eq_top_of_countable

theorem borel_eq_generateFrom_of_subbasis {s : Set (Set Œ±)} [t : TopologicalSpace Œ±]
    [SecondCountableTopology Œ±] (hs : t = .generateFrom s) : borel Œ± = .generateFrom s :=
  le_antisymm
    (generateFrom_le fun u (hu : t.IsOpen u) => by
      rw [hs] at hu
      induction hu with
      | basic u hu => exact GenerateMeasurable.basic u hu
      | univ => exact @MeasurableSet.univ Œ± (generateFrom s)
      | inter s‚ÇÅ s‚ÇÇ _ _ hs‚ÇÅ hs‚ÇÇ => exact @MeasurableSet.inter Œ± (generateFrom s) _ _ hs‚ÇÅ hs‚ÇÇ
      | sUnion f hf ih =>
        rcases isOpen_sUnion_countable f (by rwa [hs]) with ‚ü®v, hv, vf, vu‚ü©
        rw [‚Üê vu]
        exact @MeasurableSet.sUnion Œ± (generateFrom s) _ hv fun x xv => ih _ (vf xv))
    (generateFrom_le fun u hu =>
      GenerateMeasurable.basic _ <| show t.IsOpen u by rw [hs]; exact GenerateOpen.basic _ hu)
#align borel_eq_generate_from_of_subbasis borel_eq_generateFrom_of_subbasis

theorem TopologicalSpace.IsTopologicalBasis.borel_eq_generateFrom [TopologicalSpace Œ±]
    [SecondCountableTopology Œ±] {s : Set (Set Œ±)} (hs : IsTopologicalBasis s) :
    borel Œ± = .generateFrom s :=
  borel_eq_generateFrom_of_subbasis hs.eq_generateFrom
#align topological_space.is_topological_basis.borel_eq_generate_from TopologicalSpace.IsTopologicalBasis.borel_eq_generateFrom

theorem isPiSystem_isOpen [TopologicalSpace Œ±] : IsPiSystem ({s : Set Œ± | IsOpen s}) :=
  fun _s hs _t ht _ => IsOpen.inter hs ht
#align is_pi_system_is_open isPiSystem_isOpen

lemma isPiSystem_isClosed [TopologicalSpace Œ±] : IsPiSystem ({s : Set Œ± | IsClosed s}) :=
  fun _s hs _t ht _ ‚Ü¶ IsClosed.inter hs ht

theorem borel_eq_generateFrom_isClosed [TopologicalSpace Œ±] :
    borel Œ± = .generateFrom { s | IsClosed s } :=
  le_antisymm
    (generateFrom_le fun _t ht =>
      @MeasurableSet.of_compl Œ± _ (generateFrom { s | IsClosed s })
        (GenerateMeasurable.basic _ <| isClosed_compl_iff.2 ht))
    (generateFrom_le fun _t ht =>
      @MeasurableSet.of_compl Œ± _ (borel Œ±) (GenerateMeasurable.basic _ <| isOpen_compl_iff.2 ht))
#align borel_eq_generate_from_is_closed borel_eq_generateFrom_isClosed

theorem borel_comap {f : Œ± ‚Üí Œ≤} {t : TopologicalSpace Œ≤} :
    @borel Œ± (t.induced f) = (@borel Œ≤ t).comap f :=
  comap_generateFrom.symm
#align borel_comap borel_comap

theorem Continuous.borel_measurable [TopologicalSpace Œ±] [TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤}
    (hf : Continuous f) : @Measurable Œ± Œ≤ (borel Œ±) (borel Œ≤) f :=
  Measurable.of_le_map <|
    generateFrom_le fun s hs => GenerateMeasurable.basic (f ‚Åª¬π' s) (hs.preimage hf)
#align continuous.borel_measurable Continuous.borel_measurable

/-- A space with `MeasurableSpace` and `TopologicalSpace` structures such that
all open sets are measurable. -/
class OpensMeasurableSpace (Œ± : Type*) [TopologicalSpace Œ±] [h : MeasurableSpace Œ±] : Prop where
  /-- Borel-measurable sets are measurable. -/
  borel_le : borel Œ± ‚â§ h
#align opens_measurable_space OpensMeasurableSpace
#align opens_measurable_space.borel_le OpensMeasurableSpace.borel_le

/-- A space with `MeasurableSpace` and `TopologicalSpace` structures such that
the `œÉ`-algebra of measurable sets is exactly the `œÉ`-algebra generated by open sets. -/
class BorelSpace (Œ± : Type*) [TopologicalSpace Œ±] [MeasurableSpace Œ±] : Prop where
  /-- The measurable sets are exactly the Borel-measurable sets. -/
  measurable_eq : ‚ÄπMeasurableSpace Œ±‚Ä∫ = borel Œ±
#align borel_space BorelSpace
#align borel_space.measurable_eq BorelSpace.measurable_eq

namespace Mathlib.Tactic.Borelize

open Lean Elab Term Tactic Meta

/-- The behaviour of `borelize Œ±` depends on the existing assumptions on `Œ±`.

- if `Œ±` is a topological space with instances `[MeasurableSpace Œ±] [BorelSpace Œ±]`, then
  `borelize Œ±` replaces the former instance by `borel Œ±`;
- otherwise, `borelize Œ±` adds instances `borel Œ± : MeasurableSpace Œ±` and `‚ü®rfl‚ü© : BorelSpace Œ±`.

Finally, `borelize Œ± Œ≤ Œ≥` runs `borelize Œ±; borelize Œ≤; borelize Œ≥`.
-/
syntax "borelize" (ppSpace colGt term:max)* : tactic

/-- Add instances `borel e : MeasurableSpace e` and `‚ü®rfl‚ü© : BorelSpace e`. -/
def addBorelInstance (e : Expr) : TacticM Unit := do
  let t ‚Üê Lean.Elab.Term.exprToSyntax e
  evalTactic <| ‚Üê `(tactic|
    refine_lift
      letI : MeasurableSpace $t := borel $t
      haveI : BorelSpace $t := ‚ü®rfl‚ü©
      ?_)

/-- Given a type `e`, an assumption `i : MeasurableSpace e`, and an instance `[BorelSpace e]`,
replace `i` with `borel e`. -/
def borelToRefl (e : Expr) (i : FVarId) : TacticM Unit := do
  let te ‚Üê Lean.Elab.Term.exprToSyntax e
  evalTactic <| ‚Üê `(tactic|
    have := @BorelSpace.measurable_eq $te _ _ _)
  try
    liftMetaTactic fun m => return [‚Üê subst m i]
  catch _ =>
    let et ‚Üê synthInstance (‚Üê mkAppOptM ``TopologicalSpace #[e])
    throwError m!"\
      `‚ÄπTopologicalSpace {e}‚Ä∫ := {et}\n\
      depends on\n\
      {Expr.fvar i} : MeasurableSpace {e}`\n\
      so `borelize` isn't avaliable"
  evalTactic <| ‚Üê `(tactic|
    refine_lift
      letI : MeasurableSpace $te := borel $te
      ?_)

/-- Given a type `$t`, if there is an assumption `[i : MeasurableSpace $t]`, then try to prove
`[BorelSpace $t]` and replace `i` with `borel $t`. Otherwise, add instances
`borel $t : MeasurableSpace $t` and `‚ü®rfl‚ü© : BorelSpace $t`. -/
def borelize (t : Term) : TacticM Unit := withMainContext <| do
  let u ‚Üê mkFreshLevelMVar
  let e ‚Üê withoutRecover <| Tactic.elabTermEnsuringType t (mkSort (mkLevelSucc u))
  let i? ‚Üê findLocalDeclWithType? (‚Üê mkAppOptM ``MeasurableSpace #[e])
  i?.elim (addBorelInstance e) (borelToRefl e)

elab_rules : tactic
  | `(tactic| borelize $[$t:term]*) => t.forM borelize

end Mathlib.Tactic.Borelize

instance (priority := 100) OrderDual.opensMeasurableSpace {Œ± : Type*} [TopologicalSpace Œ±]
    [MeasurableSpace Œ±] [h : OpensMeasurableSpace Œ±] : OpensMeasurableSpace Œ±·µí·µà where
  borel_le := h.borel_le
#align order_dual.opens_measurable_space OrderDual.opensMeasurableSpace

instance (priority := 100) OrderDual.borelSpace {Œ± : Type*} [TopologicalSpace Œ±]
    [MeasurableSpace Œ±] [h : BorelSpace Œ±] : BorelSpace Œ±·µí·µà where
  measurable_eq := h.measurable_eq
#align order_dual.borel_space OrderDual.borelSpace

/-- In a `BorelSpace` all open sets are measurable. -/
instance (priority := 100) BorelSpace.opensMeasurable {Œ± : Type*} [TopologicalSpace Œ±]
    [MeasurableSpace Œ±] [BorelSpace Œ±] : OpensMeasurableSpace Œ± :=
  ‚ü®ge_of_eq <| BorelSpace.measurable_eq‚ü©
#align borel_space.opens_measurable BorelSpace.opensMeasurable

instance Subtype.borelSpace {Œ± : Type*} [TopologicalSpace Œ±] [MeasurableSpace Œ±]
    [hŒ± : BorelSpace Œ±] (s : Set Œ±) : BorelSpace s :=
  ‚ü®by borelize Œ±; symm; apply borel_comap‚ü©
#align subtype.borel_space Subtype.borelSpace

instance Countable.instBorelSpace [Countable Œ±] [MeasurableSpace Œ±] [MeasurableSingletonClass Œ±]
    [TopologicalSpace Œ±] [DiscreteTopology Œ±] : BorelSpace Œ± := by
  have : ‚àÄ s, @MeasurableSet Œ± inferInstance s := fun s ‚Ü¶ s.to_countable.measurableSet
  have : ‚àÄ s, @MeasurableSet Œ± (borel Œ±) s := fun s ‚Ü¶ measurableSet_generateFrom (isOpen_discrete s)
  exact ‚ü®by aesop‚ü©

instance Subtype.opensMeasurableSpace {Œ± : Type*} [TopologicalSpace Œ±] [MeasurableSpace Œ±]
    [h : OpensMeasurableSpace Œ±] (s : Set Œ±) : OpensMeasurableSpace s :=
  ‚ü®by
    rw [borel_comap]
    exact comap_mono h.1‚ü©
#align subtype.opens_measurable_space Subtype.opensMeasurableSpace

lemma opensMeasurableSpace_iff_forall_measurableSet
    [TopologicalSpace Œ±] [MeasurableSpace Œ±] :
    OpensMeasurableSpace Œ± ‚Üî  (‚àÄ (s : Set Œ±), IsOpen s ‚Üí MeasurableSet s) := by
  refine ‚ü®fun h s hs ‚Ü¶ ?_, fun h ‚Ü¶ ‚ü®generateFrom_le h‚ü©‚ü©
  exact OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ hs

instance (priority := 100) BorelSpace.countablyGenerated {Œ± : Type*} [TopologicalSpace Œ±]
    [MeasurableSpace Œ±] [BorelSpace Œ±] [SecondCountableTopology Œ±] : CountablyGenerated Œ± := by
  obtain ‚ü®b, bct, -, hb‚ü© := exists_countable_basis Œ±
  refine' ‚ü®‚ü®b, bct, _‚ü©‚ü©
  borelize Œ±
  exact hb.borel_eq_generateFrom
#align borel_space.countably_generated BorelSpace.countablyGenerated

theorem MeasurableSet.induction_on_open [TopologicalSpace Œ±] [MeasurableSpace Œ±] [BorelSpace Œ±]
    {C : Set Œ± ‚Üí Prop} (h_open : ‚àÄ U, IsOpen U ‚Üí C U)
    (h_compl : ‚àÄ t, MeasurableSet t ‚Üí C t ‚Üí C t·∂ú)
    (h_union :
      ‚àÄ f : ‚Ñï ‚Üí Set Œ±,
        Pairwise (Disjoint on f) ‚Üí (‚àÄ i, MeasurableSet (f i)) ‚Üí (‚àÄ i, C (f i)) ‚Üí C (‚ãÉ i, f i)) :
    ‚àÄ ‚¶Ét‚¶Ñ, MeasurableSet t ‚Üí C t :=
  MeasurableSpace.induction_on_inter BorelSpace.measurable_eq isPiSystem_isOpen
    (h_open _ isOpen_empty) h_open h_compl h_union
#align measurable_set.induction_on_open MeasurableSet.induction_on_open

section

variable [TopologicalSpace Œ±] [MeasurableSpace Œ±] [OpensMeasurableSpace Œ±] [TopologicalSpace Œ≤]
  [MeasurableSpace Œ≤] [OpensMeasurableSpace Œ≤] [TopologicalSpace Œ≥] [MeasurableSpace Œ≥]
  [BorelSpace Œ≥] [TopologicalSpace Œ≥‚ÇÇ] [MeasurableSpace Œ≥‚ÇÇ] [BorelSpace Œ≥‚ÇÇ] [MeasurableSpace Œ¥]

theorem IsOpen.measurableSet (h : IsOpen s) : MeasurableSet s :=
  OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ h
#align is_open.measurable_set IsOpen.measurableSet

instance (priority := 1000) {s : Set Œ±} [h : HasCountableSeparatingOn Œ± IsOpen s] :
    CountablySeparated s := by
    rw [CountablySeparated.subtype_iff]
    exact .mono (fun _ ‚Ü¶ IsOpen.measurableSet) Subset.rfl

@[measurability]
theorem measurableSet_interior : MeasurableSet (interior s) :=
  isOpen_interior.measurableSet
#align measurable_set_interior measurableSet_interior

theorem IsGŒ¥.measurableSet (h : IsGŒ¥ s) : MeasurableSet s := by
  rcases h with ‚ü®S, hSo, hSc, rfl‚ü©
  exact MeasurableSet.sInter hSc fun t ht => (hSo t ht).measurableSet
set_option linter.uppercaseLean3 false in
#align is_GŒ¥.measurable_set IsGŒ¥.measurableSet

theorem measurableSet_of_continuousAt {Œ≤} [EMetricSpace Œ≤] (f : Œ± ‚Üí Œ≤) :
    MeasurableSet { x | ContinuousAt f x } :=
  (IsGŒ¥.setOf_continuousAt f).measurableSet
#align measurable_set_of_continuous_at measurableSet_of_continuousAt

theorem IsClosed.measurableSet (h : IsClosed s) : MeasurableSet s :=
  h.isOpen_compl.measurableSet.of_compl
#align is_closed.measurable_set IsClosed.measurableSet

theorem IsCompact.measurableSet [T2Space Œ±] (h : IsCompact s) : MeasurableSet s :=
  h.isClosed.measurableSet
#align is_compact.measurable_set IsCompact.measurableSet

/-- If two points are topologically inseparable,
then they can't be separated by a Borel measurable set. -/
theorem Inseparable.mem_measurableSet_iff {x y : Œ≥} (h : Inseparable x y) {s : Set Œ≥}
    (hs : MeasurableSet s) : x ‚àà s ‚Üî y ‚àà s :=
  hs.induction_on_open (C := fun s ‚Ü¶ (x ‚àà s ‚Üî y ‚àà s)) (fun _ ‚Ü¶ h.mem_open_iff) (fun s _ hs ‚Ü¶ hs.not)
    fun _ _ _ h ‚Ü¶ by simp [h]

/-- If `K` is a compact set in an R‚ÇÅ space and `s ‚äá K` is a Borel measurable superset,
then `s` includes the closure of `K` as well. -/
theorem IsCompact.closure_subset_measurableSet [R1Space Œ≥] {K s : Set Œ≥} (hK : IsCompact K)
    (hs : MeasurableSet s) (hKs : K ‚äÜ s) : closure K ‚äÜ s := by
  rw [hK.closure_eq_biUnion_inseparable, iUnion‚ÇÇ_subset_iff]
  exact fun x hx y hy ‚Ü¶ (hy.mem_measurableSet_iff hs).1 (hKs hx)

/-- In an R‚ÇÅ topological space with Borel measure `Œº`,
the measure of the closure of a compact set `K` is equal to the measure of `K`.

See also `MeasureTheory.Measure.OuterRegular.measure_closure_eq_of_isCompact`
for a version that assumes `Œº` to be outer regular
but does not assume the `œÉ`-algebra to be Borel.  -/
theorem IsCompact.measure_closure [R1Space Œ≥] {K : Set Œ≥} (hK : IsCompact K) (Œº : Measure Œ≥) :
    Œº (closure K) = Œº K := by
  refine le_antisymm ?_ (measure_mono subset_closure)
  calc
    Œº (closure K) ‚â§ Œº (toMeasurable Œº K) := measure_mono <|
      hK.closure_subset_measurableSet (measurableSet_toMeasurable ..) (subset_toMeasurable ..)
    _ = Œº K := measure_toMeasurable ..

@[measurability]
theorem measurableSet_closure : MeasurableSet (closure s) :=
  isClosed_closure.measurableSet
#align measurable_set_closure measurableSet_closure

theorem measurable_of_isOpen {f : Œ¥ ‚Üí Œ≥} (hf : ‚àÄ s, IsOpen s ‚Üí MeasurableSet (f ‚Åª¬π' s)) :
    Measurable f := by
  rw [‚ÄπBorelSpace Œ≥‚Ä∫.measurable_eq]
  exact measurable_generateFrom hf
#align measurable_of_is_open measurable_of_isOpen

theorem measurable_of_isClosed {f : Œ¥ ‚Üí Œ≥} (hf : ‚àÄ s, IsClosed s ‚Üí MeasurableSet (f ‚Åª¬π' s)) :
    Measurable f := by
  apply measurable_of_isOpen; intro s hs
  rw [‚Üê MeasurableSet.compl_iff, ‚Üê preimage_compl]; apply hf; rw [isClosed_compl_iff]; exact hs
#align measurable_of_is_closed measurable_of_isClosed

theorem measurable_of_isClosed' {f : Œ¥ ‚Üí Œ≥}
    (hf : ‚àÄ s, IsClosed s ‚Üí s.Nonempty ‚Üí s ‚â† univ ‚Üí MeasurableSet (f ‚Åª¬π' s)) : Measurable f := by
  apply measurable_of_isClosed; intro s hs
  rcases eq_empty_or_nonempty s with h1 | h1
  ¬∑ simp [h1]
  by_cases h2 : s = univ
  ¬∑ simp [h2]
  exact hf s hs h1 h2
#align measurable_of_is_closed' measurable_of_isClosed'

instance nhds_isMeasurablyGenerated (a : Œ±) : (ùìù a).IsMeasurablyGenerated := by
  rw [nhds, iInf_subtype']
  refine' @Filter.iInf_isMeasurablyGenerated Œ± _ _ _ fun i => _
  exact i.2.2.measurableSet.principal_isMeasurablyGenerated
#align nhds_is_measurably_generated nhds_isMeasurablyGenerated

/-- If `s` is a measurable set, then `ùìù[s] a` is a measurably generated filter for
each `a`. This cannot be an `instance` because it depends on a non-instance `hs : MeasurableSet s`.
-/
theorem MeasurableSet.nhdsWithin_isMeasurablyGenerated {s : Set Œ±} (hs : MeasurableSet s) (a : Œ±) :
    (ùìù[s] a).IsMeasurablyGenerated :=
  haveI := hs.principal_isMeasurablyGenerated
  Filter.inf_isMeasurablyGenerated _ _
#align measurable_set.nhds_within_is_measurably_generated MeasurableSet.nhdsWithin_isMeasurablyGenerated

instance (priority := 100) OpensMeasurableSpace.separatesPoints [T0Space Œ±] :
    SeparatesPoints Œ± := by
  rw [separatesPoints_iff]
  intro x y hxy
  apply Inseparable.eq
  rw [inseparable_iff_forall_open]
  exact fun s hs => hxy _ hs.measurableSet

-- see Note [lower instance priority]
instance (priority := 100) OpensMeasurableSpace.toMeasurableSingletonClass [T1Space Œ±] :
    MeasurableSingletonClass Œ± :=
  ‚ü®fun _ => isClosed_singleton.measurableSet‚ü©
#align opens_measurable_space.to_measurable_singleton_class OpensMeasurableSpace.toMeasurableSingletonClass

instance Pi.opensMeasurableSpace {Œπ : Type*} {œÄ : Œπ ‚Üí Type*} [Countable Œπ]
    [t' : ‚àÄ i, TopologicalSpace (œÄ i)] [‚àÄ i, MeasurableSpace (œÄ i)]
    [‚àÄ i, SecondCountableTopology (œÄ i)] [‚àÄ i, OpensMeasurableSpace (œÄ i)] :
    OpensMeasurableSpace (‚àÄ i, œÄ i) := by
  constructor
  have : Pi.topologicalSpace = .generateFrom { t | ‚àÉ (s : ‚àÄ a, Set (œÄ a)) (i : Finset Œπ),
      (‚àÄ a ‚àà i, s a ‚àà countableBasis (œÄ a)) ‚àß t = pi (‚Üëi) s } := by
    simp only [funext fun a => @eq_generateFrom_countableBasis (œÄ a) _ _, pi_generateFrom_eq]
  rw [borel_eq_generateFrom_of_subbasis this]
  apply generateFrom_le
  rintro _ ‚ü®s, i, hi, rfl‚ü©
  refine' MeasurableSet.pi i.countable_toSet fun a ha => IsOpen.measurableSet _
  rw [eq_generateFrom_countableBasis (œÄ a)]
  exact .basic _ (hi a ha)
#align pi.opens_measurable_space Pi.opensMeasurableSpace

/-- The typeclass `SecondCountableTopologyEither Œ± Œ≤` registers the fact that at least one of
the two spaces has second countable topology. This is the right assumption to ensure that continuous
maps from `Œ±` to `Œ≤` are strongly measurable. -/
class SecondCountableTopologyEither (Œ± Œ≤ : Type*) [TopologicalSpace Œ±] [TopologicalSpace Œ≤] :
  Prop where
  /-- The projection out of `SecondCountableTopologyEither` -/
  out : SecondCountableTopology Œ± ‚à® SecondCountableTopology Œ≤
#align second_countable_topology_either SecondCountableTopologyEither

instance (priority := 100) secondCountableTopologyEither_of_left (Œ± Œ≤ : Type*) [TopologicalSpace Œ±]
    [TopologicalSpace Œ≤] [SecondCountableTopology Œ±] : SecondCountableTopologyEither Œ± Œ≤ where
  out := Or.inl (by infer_instance)
#align second_countable_topology_either_of_left secondCountableTopologyEither_of_left

instance (priority := 100) secondCountableTopologyEither_of_right (Œ± Œ≤ : Type*)
    [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [SecondCountableTopology Œ≤] :
    SecondCountableTopologyEither Œ± Œ≤ where
  out := Or.inr (by infer_instance)
#align second_countable_topology_either_of_right secondCountableTopologyEither_of_right

/-- If either `Œ±` or `Œ≤` has second-countable topology, then the open sets in `Œ± √ó Œ≤` belong to the
product sigma-algebra. -/
instance Prod.opensMeasurableSpace [h : SecondCountableTopologyEither Œ± Œ≤] :
    OpensMeasurableSpace (Œ± √ó Œ≤) := by
  apply opensMeasurableSpace_iff_forall_measurableSet.2 (fun s hs ‚Ü¶ ?_)
  rcases h.out with hŒ±|hŒ≤
  ¬∑ let F : Set Œ± ‚Üí Set Œ≤ := fun a ‚Ü¶ {y | ‚àÉ b, IsOpen b ‚àß y ‚àà b ‚àß a √óÀ¢ b ‚äÜ s}
    have A : ‚àÄ a, IsOpen (F a) := by
      intro a
      apply isOpen_iff_forall_mem_open.2
      rintro y ‚ü®b, b_open, yb, hb‚ü©
      exact ‚ü®b, fun z zb ‚Ü¶ ‚ü®b, b_open, zb, hb‚ü©, b_open, yb‚ü©
    have : s = ‚ãÉ a ‚àà countableBasis Œ±, a √óÀ¢ F a := by
      apply Subset.antisymm
      ¬∑ rintro ‚ü®y1, y2‚ü© hy
        rcases isOpen_prod_iff.1 hs y1 y2 hy with ‚ü®u, v, u_open, v_open, yu, yv, huv‚ü©
        obtain ‚ü®a, ha, ya, au‚ü© : ‚àÉ a ‚àà countableBasis Œ±, y1 ‚àà a ‚àß a ‚äÜ u :=
          IsTopologicalBasis.exists_subset_of_mem_open (isBasis_countableBasis Œ±) yu u_open
        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop]
        exact ‚ü®a, ya, ha, v, v_open, yv, (Set.prod_mono_left au).trans huv‚ü©
      ¬∑ rintro ‚ü®y1, y2‚ü© hy
        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop] at hy
        rcases hy with ‚ü®a, ya, -, b, -, yb, hb‚ü©
        exact hb (mem_prod.2 ‚ü®ya, yb‚ü©)
    rw [this]
    apply MeasurableSet.biUnion (countable_countableBasis Œ±) (fun a ha ‚Ü¶ ?_)
    exact (isOpen_of_mem_countableBasis ha).measurableSet.prod (A a).measurableSet
  ¬∑ let F : Set Œ≤ ‚Üí Set Œ± := fun a ‚Ü¶ {y | ‚àÉ b, IsOpen b ‚àß y ‚àà b ‚àß b √óÀ¢ a ‚äÜ s}
    have A : ‚àÄ a, IsOpen (F a) := by
      intro a
      apply isOpen_iff_forall_mem_open.2
      rintro y ‚ü®b, b_open, yb, hb‚ü©
      exact ‚ü®b, fun z zb ‚Ü¶ ‚ü®b, b_open, zb, hb‚ü©, b_open, yb‚ü©
    have : s = ‚ãÉ a ‚àà countableBasis Œ≤, F a √óÀ¢ a := by
      apply Subset.antisymm
      ¬∑ rintro ‚ü®y1, y2‚ü© hy
        rcases isOpen_prod_iff.1 hs y1 y2 hy with ‚ü®u, v, u_open, v_open, yu, yv, huv‚ü©
        obtain ‚ü®a, ha, ya, au‚ü© : ‚àÉ a ‚àà countableBasis Œ≤, y2 ‚àà a ‚àß a ‚äÜ v :=
          IsTopologicalBasis.exists_subset_of_mem_open (isBasis_countableBasis Œ≤) yv v_open
        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop]
        exact ‚ü®a, ‚ü®u, u_open, yu, (Set.prod_mono_right au).trans huv‚ü©, ha, ya‚ü©
      ¬∑ rintro ‚ü®y1, y2‚ü© hy
        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop] at hy
        rcases hy with ‚ü®a, ‚ü®b, -, yb, hb‚ü©, -, ya‚ü©
        exact hb (mem_prod.2 ‚ü®yb, ya‚ü©)
    rw [this]
    apply MeasurableSet.biUnion (countable_countableBasis Œ≤) (fun a ha ‚Ü¶ ?_)
    exact (A a).measurableSet.prod (isOpen_of_mem_countableBasis ha).measurableSet

variable {Œ±' : Type*} [TopologicalSpace Œ±'] [MeasurableSpace Œ±']

theorem interior_ae_eq_of_null_frontier {Œº : Measure Œ±'} {s : Set Œ±'} (h : Œº (frontier s) = 0) :
    interior s =·µê[Œº] s :=
  interior_subset.eventuallyLE.antisymm <| subset_closure.eventuallyLE.trans (ae_le_set.2 h)
#align interior_ae_eq_of_null_frontier interior_ae_eq_of_null_frontier

theorem measure_interior_of_null_frontier {Œº : Measure Œ±'} {s : Set Œ±'} (h : Œº (frontier s) = 0) :
    Œº (interior s) = Œº s :=
  measure_congr (interior_ae_eq_of_null_frontier h)
#align measure_interior_of_null_frontier measure_interior_of_null_frontier

theorem nullMeasurableSet_of_null_frontier {s : Set Œ±} {Œº : Measure Œ±} (h : Œº (frontier s) = 0) :
    NullMeasurableSet s Œº :=
  ‚ü®interior s, isOpen_interior.measurableSet, (interior_ae_eq_of_null_frontier h).symm‚ü©
#align null_measurable_set_of_null_frontier nullMeasurableSet_of_null_frontier

theorem closure_ae_eq_of_null_frontier {Œº : Measure Œ±'} {s : Set Œ±'} (h : Œº (frontier s) = 0) :
    closure s =·µê[Œº] s :=
  ((ae_le_set.2 h).trans interior_subset.eventuallyLE).antisymm <| subset_closure.eventuallyLE
#align closure_ae_eq_of_null_frontier closure_ae_eq_of_null_frontier

theorem measure_closure_of_null_frontier {Œº : Measure Œ±'} {s : Set Œ±'} (h : Œº (frontier s) = 0) :
    Œº (closure s) = Œº s :=
  measure_congr (closure_ae_eq_of_null_frontier h)
#align measure_closure_of_null_frontier measure_closure_of_null_frontier

/-- A continuous function from an `OpensMeasurableSpace` to a `BorelSpace`
is measurable. -/
theorem Continuous.measurable {f : Œ± ‚Üí Œ≥} (hf : Continuous f) : Measurable f :=
  hf.borel_measurable.mono OpensMeasurableSpace.borel_le (le_of_eq <| BorelSpace.measurable_eq)
#align continuous.measurable Continuous.measurable

/-- A continuous function from an `OpensMeasurableSpace` to a `BorelSpace`
is ae-measurable. -/
theorem Continuous.aemeasurable {f : Œ± ‚Üí Œ≥} (h : Continuous f) {Œº : Measure Œ±} : AEMeasurable f Œº :=
  h.measurable.aemeasurable
#align continuous.ae_measurable Continuous.aemeasurable

theorem ClosedEmbedding.measurable {f : Œ± ‚Üí Œ≥} (hf : ClosedEmbedding f) : Measurable f :=
  hf.continuous.measurable
#align closed_embedding.measurable ClosedEmbedding.measurable

/-- If a function is defined piecewise in terms of functions which are continuous on their
respective pieces, then it is measurable. -/
theorem ContinuousOn.measurable_piecewise {f g : Œ± ‚Üí Œ≥} {s : Set Œ±} [‚àÄ j : Œ±, Decidable (j ‚àà s)]
    (hf : ContinuousOn f s) (hg : ContinuousOn g s·∂ú) (hs : MeasurableSet s) :
    Measurable (s.piecewise f g) := by
  refine' measurable_of_isOpen fun t ht => _
  rw [piecewise_preimage, Set.ite]
  apply MeasurableSet.union
  ¬∑ rcases _root_.continuousOn_iff'.1 hf t ht with ‚ü®u, u_open, hu‚ü©
    rw [hu]
    exact u_open.measurableSet.inter hs
  ¬∑ rcases _root_.continuousOn_iff'.1 hg t ht with ‚ü®u, u_open, hu‚ü©
    rw [diff_eq_compl_inter, inter_comm, hu]
    exact u_open.measurableSet.inter hs.compl
#align continuous_on.measurable_piecewise ContinuousOn.measurable_piecewise

@[to_additive]
instance (priority := 100) ContinuousMul.measurableMul [Mul Œ≥] [ContinuousMul Œ≥] :
    MeasurableMul Œ≥ where
  measurable_const_mul _ := (continuous_const.mul continuous_id).measurable
  measurable_mul_const _ := (continuous_id.mul continuous_const).measurable
#align has_continuous_mul.has_measurable_mul ContinuousMul.measurableMul
#align has_continuous_add.has_measurable_add ContinuousAdd.measurableAdd

instance (priority := 100) ContinuousSub.measurableSub [Sub Œ≥] [ContinuousSub Œ≥] :
    MeasurableSub Œ≥ where
  measurable_const_sub _ := (continuous_const.sub continuous_id).measurable
  measurable_sub_const _ := (continuous_id.sub continuous_const).measurable
#align has_continuous_sub.has_measurable_sub ContinuousSub.measurableSub

@[to_additive]
instance (priority := 100) TopologicalGroup.measurableInv [Group Œ≥] [TopologicalGroup Œ≥] :
    MeasurableInv Œ≥ :=
  ‚ü®continuous_inv.measurable‚ü©
#align topological_group.has_measurable_inv TopologicalGroup.measurableInv
#align topological_add_group.has_measurable_neg TopologicalAddGroup.measurableNeg

instance (priority := 100) ContinuousSMul.measurableSMul {M Œ±} [TopologicalSpace M]
    [TopologicalSpace Œ±] [MeasurableSpace M] [MeasurableSpace Œ±] [OpensMeasurableSpace M]
    [BorelSpace Œ±] [SMul M Œ±] [ContinuousSMul M Œ±] : MeasurableSMul M Œ± :=
  ‚ü®fun _ => (continuous_const_smul _).measurable, fun _ =>
    (continuous_id.smul continuous_const).measurable‚ü©
#align has_continuous_smul.has_measurable_smul ContinuousSMul.measurableSMul

section Homeomorph

@[measurability]
protected theorem Homeomorph.measurable (h : Œ± ‚âÉ‚Çú Œ≥) : Measurable h :=
  h.continuous.measurable
#align homeomorph.measurable Homeomorph.measurable

/-- A homeomorphism between two Borel spaces is a measurable equivalence. -/
def Homeomorph.toMeasurableEquiv (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : Œ≥ ‚âÉ·µê Œ≥‚ÇÇ where
  measurable_toFun := h.measurable
  measurable_invFun := h.symm.measurable
  toEquiv := h.toEquiv
#align homeomorph.to_measurable_equiv Homeomorph.toMeasurableEquiv

lemma Homeomorph.measurableEmbedding (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : MeasurableEmbedding h :=
  h.toMeasurableEquiv.measurableEmbedding

@[simp]
theorem Homeomorph.toMeasurableEquiv_coe (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : (h.toMeasurableEquiv : Œ≥ ‚Üí Œ≥‚ÇÇ) = h :=
  rfl
#align homeomorph.to_measurable_equiv_coe Homeomorph.toMeasurableEquiv_coe

@[simp]
theorem Homeomorph.toMeasurableEquiv_symm_coe (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) :
    (h.toMeasurableEquiv.symm : Œ≥‚ÇÇ ‚Üí Œ≥) = h.symm :=
  rfl
#align homeomorph.to_measurable_equiv_symm_coe Homeomorph.toMeasurableEquiv_symm_coe

end Homeomorph

@[measurability]
theorem ContinuousMap.measurable (f : C(Œ±, Œ≥)) : Measurable f :=
  f.continuous.measurable
#align continuous_map.measurable ContinuousMap.measurable

theorem measurable_of_continuousOn_compl_singleton [T1Space Œ±] {f : Œ± ‚Üí Œ≥} (a : Œ±)
    (hf : ContinuousOn f {a}·∂ú) : Measurable f :=
  measurable_of_measurable_on_compl_singleton a
    (continuousOn_iff_continuous_restrict.1 hf).measurable
#align measurable_of_continuous_on_compl_singleton measurable_of_continuousOn_compl_singleton

theorem Continuous.measurable2 [SecondCountableTopologyEither Œ± Œ≤] {f : Œ¥ ‚Üí Œ±}
    {g : Œ¥ ‚Üí Œ≤} {c : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (h : Continuous fun p : Œ± √ó Œ≤ => c p.1 p.2) (hf : Measurable f)
    (hg : Measurable g) : Measurable fun a => c (f a) (g a) :=
  h.measurable.comp (hf.prod_mk hg)
#align continuous.measurable2 Continuous.measurable2

theorem Continuous.aemeasurable2 [SecondCountableTopologyEither Œ± Œ≤]
    {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ≤} {c : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {Œº : Measure Œ¥}
    (h : Continuous fun p : Œ± √ó Œ≤ => c p.1 p.2) (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    AEMeasurable (fun a => c (f a) (g a)) Œº :=
  h.measurable.comp_aemeasurable (hf.prod_mk hg)
#align continuous.ae_measurable2 Continuous.aemeasurable2

instance (priority := 100) HasContinuousInv‚ÇÄ.measurableInv [GroupWithZero Œ≥] [T1Space Œ≥]
    [HasContinuousInv‚ÇÄ Œ≥] : MeasurableInv Œ≥ :=
  ‚ü®measurable_of_continuousOn_compl_singleton 0 continuousOn_inv‚ÇÄ‚ü©
#align has_continuous_inv‚ÇÄ.has_measurable_inv HasContinuousInv‚ÇÄ.measurableInv

@[to_additive]
instance (priority := 100) ContinuousMul.measurableMul‚ÇÇ [SecondCountableTopology Œ≥] [Mul Œ≥]
    [ContinuousMul Œ≥] : MeasurableMul‚ÇÇ Œ≥ :=
  ‚ü®continuous_mul.measurable‚ü©
#align has_continuous_mul.has_measurable_mul‚ÇÇ ContinuousMul.measurableMul‚ÇÇ
#align has_continuous_add.has_measurable_mul‚ÇÇ ContinuousAdd.measurableMul‚ÇÇ

instance (priority := 100) ContinuousSub.measurableSub‚ÇÇ [SecondCountableTopology Œ≥] [Sub Œ≥]
    [ContinuousSub Œ≥] : MeasurableSub‚ÇÇ Œ≥ :=
  ‚ü®continuous_sub.measurable‚ü©
#align has_continuous_sub.has_measurable_sub‚ÇÇ ContinuousSub.measurableSub‚ÇÇ

instance (priority := 100) ContinuousSMul.measurableSMul‚ÇÇ {M Œ±} [TopologicalSpace M]
    [MeasurableSpace M] [OpensMeasurableSpace M] [TopologicalSpace Œ±]
    [SecondCountableTopologyEither M Œ±] [MeasurableSpace Œ±] [BorelSpace Œ±] [SMul M Œ±]
    [ContinuousSMul M Œ±] : MeasurableSMul‚ÇÇ M Œ± :=
  ‚ü®continuous_smul.measurable‚ü©
#align has_continuous_smul.has_measurable_smul‚ÇÇ ContinuousSMul.measurableSMul‚ÇÇ

end

section BorelSpace

variable [TopologicalSpace Œ±] [MeasurableSpace Œ±] [BorelSpace Œ±] [TopologicalSpace Œ≤]
  [MeasurableSpace Œ≤] [BorelSpace Œ≤] [TopologicalSpace Œ≥] [MeasurableSpace Œ≥] [BorelSpace Œ≥]
  [MeasurableSpace Œ¥]

theorem pi_le_borel_pi {Œπ : Type*} {œÄ : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (œÄ i)]
    [‚àÄ i, MeasurableSpace (œÄ i)] [‚àÄ i, BorelSpace (œÄ i)] :
      MeasurableSpace.pi ‚â§ borel (‚àÄ i, œÄ i) := by
  have : ‚Äπ‚àÄ i, MeasurableSpace (œÄ i)‚Ä∫ = fun i => borel (œÄ i) :=
    funext fun i => BorelSpace.measurable_eq
  rw [this]
  exact iSup_le fun i => comap_le_iff_le_map.2 <| (continuous_apply i).borel_measurable
#align pi_le_borel_pi pi_le_borel_pi

theorem prod_le_borel_prod : Prod.instMeasurableSpace ‚â§ borel (Œ± √ó Œ≤) := by
  rw [‚ÄπBorelSpace Œ±‚Ä∫.measurable_eq, ‚ÄπBorelSpace Œ≤‚Ä∫.measurable_eq]
  refine' sup_le _ _
  ¬∑ exact comap_le_iff_le_map.mpr continuous_fst.borel_measurable
  ¬∑ exact comap_le_iff_le_map.mpr continuous_snd.borel_measurable
#align prod_le_borel_prod prod_le_borel_prod

instance Pi.borelSpace {Œπ : Type*} {œÄ : Œπ ‚Üí Type*} [Countable Œπ] [‚àÄ i, TopologicalSpace (œÄ i)]
    [‚àÄ i, MeasurableSpace (œÄ i)] [‚àÄ i, SecondCountableTopology (œÄ i)] [‚àÄ i, BorelSpace (œÄ i)] :
    BorelSpace (‚àÄ i, œÄ i) :=
  ‚ü®le_antisymm pi_le_borel_pi OpensMeasurableSpace.borel_le‚ü©
#align pi.borel_space Pi.borelSpace

instance Prod.borelSpace [SecondCountableTopologyEither Œ± Œ≤] :
    BorelSpace (Œ± √ó Œ≤) :=
  ‚ü®le_antisymm prod_le_borel_prod OpensMeasurableSpace.borel_le‚ü©
#align prod.borel_space Prod.borelSpace

/-- Given a measurable embedding to a Borel space which is also a topological embedding, then the
source space is also a Borel space. -/
lemma MeasurableEmbedding.borelSpace {Œ± Œ≤ : Type*} [MeasurableSpace Œ±] [TopologicalSpace Œ±]
    [MeasurableSpace Œ≤] [TopologicalSpace Œ≤] [hŒ≤ : BorelSpace Œ≤] {e : Œ± ‚Üí Œ≤}
    (h'e : MeasurableEmbedding e) (h''e : Inducing e) :
    BorelSpace Œ± := by
  constructor
  have : MeasurableSpace.comap e (borel Œ≤) = ‚Äπ_‚Ä∫ := by simpa [hŒ≤.measurable_eq] using h'e.comap_eq
  rw [‚Üê this, ‚Üê borel_comap, h''e.induced]

instance _root_.ULift.instBorelSpace : BorelSpace (ULift Œ±) :=
  MeasurableEquiv.ulift.measurableEmbedding.borelSpace Homeomorph.ulift.inducing

instance DiscreteMeasurableSpace.toBorelSpace {Œ± : Type*} [TopologicalSpace Œ±] [DiscreteTopology Œ±]
    [MeasurableSpace Œ±] [DiscreteMeasurableSpace Œ±] : BorelSpace Œ± := by
  constructor; ext; simp [MeasurableSpace.measurableSet_generateFrom, measurableSet_discrete]

protected theorem Embedding.measurableEmbedding {f : Œ± ‚Üí Œ≤} (h‚ÇÅ : Embedding f)
    (h‚ÇÇ : MeasurableSet (range f)) : MeasurableEmbedding f :=
  show MeasurableEmbedding
      (((‚Üë) : range f ‚Üí Œ≤) ‚àò (Homeomorph.ofEmbedding f h‚ÇÅ).toMeasurableEquiv) from
    (MeasurableEmbedding.subtype_coe h‚ÇÇ).comp (MeasurableEquiv.measurableEmbedding _)
#align embedding.measurable_embedding Embedding.measurableEmbedding

protected theorem ClosedEmbedding.measurableEmbedding {f : Œ± ‚Üí Œ≤} (h : ClosedEmbedding f) :
    MeasurableEmbedding f :=
  h.toEmbedding.measurableEmbedding h.isClosed_range.measurableSet
#align closed_embedding.measurable_embedding ClosedEmbedding.measurableEmbedding

protected theorem OpenEmbedding.measurableEmbedding {f : Œ± ‚Üí Œ≤} (h : OpenEmbedding f) :
    MeasurableEmbedding f :=
  h.toEmbedding.measurableEmbedding h.isOpen_range.measurableSet
#align open_embedding.measurable_embedding OpenEmbedding.measurableEmbedding

instance Empty.borelSpace : BorelSpace Empty :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©
#align empty.borel_space Empty.borelSpace

instance Unit.borelSpace : BorelSpace Unit :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©
#align unit.borel_space Unit.borelSpace

instance Bool.borelSpace : BorelSpace Bool :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©
#align bool.borel_space Bool.borelSpace

instance Nat.borelSpace : BorelSpace ‚Ñï :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©
#align nat.borel_space Nat.borelSpace

instance Int.borelSpace : BorelSpace ‚Ñ§ :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©
#align int.borel_space Int.borelSpace

instance Rat.borelSpace : BorelSpace ‚Ñö :=
  ‚ü®borel_eq_top_of_countable.symm‚ü©
#align rat.borel_space Rat.borelSpace

/- Instances on `Real` and `Complex` are special cases of `RCLike` but without these instances,
Lean fails to prove `BorelSpace (Œπ ‚Üí ‚Ñù)`, so we leave them here. -/
instance Real.measurableSpace : MeasurableSpace ‚Ñù :=
  borel ‚Ñù
#align real.measurable_space Real.measurableSpace

instance Real.borelSpace : BorelSpace ‚Ñù :=
  ‚ü®rfl‚ü©
#align real.borel_space Real.borelSpace

instance NNReal.measurableSpace : MeasurableSpace ‚Ñù‚â•0 :=
  Subtype.instMeasurableSpace
#align nnreal.measurable_space NNReal.measurableSpace

instance NNReal.borelSpace : BorelSpace ‚Ñù‚â•0 :=
  Subtype.borelSpace _
#align nnreal.borel_space NNReal.borelSpace

instance ENNReal.measurableSpace : MeasurableSpace ‚Ñù‚â•0‚àû :=
  borel ‚Ñù‚â•0‚àû
#align ennreal.measurable_space ENNReal.measurableSpace

instance ENNReal.borelSpace : BorelSpace ‚Ñù‚â•0‚àû :=
  ‚ü®rfl‚ü©
#align ennreal.borel_space ENNReal.borelSpace

instance EReal.measurableSpace : MeasurableSpace EReal :=
  borel EReal
#align ereal.measurable_space EReal.measurableSpace

instance EReal.borelSpace : BorelSpace EReal :=
  ‚ü®rfl‚ü©
#align ereal.borel_space EReal.borelSpace

/-- One can cut out `‚Ñù‚â•0‚àû` into the sets `{0}`, `Ico (t^n) (t^(n+1))` for `n : ‚Ñ§` and `{‚àû}`. This
gives a way to compute the measure of a set in terms of sets on which a given function `f` does not
fluctuate by more than `t`. -/
theorem measure_eq_measure_preimage_add_measure_tsum_Ico_zpow [MeasurableSpace Œ±] (Œº : Measure Œ±)
    {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) {s : Set Œ±} (hs : MeasurableSet s) {t : ‚Ñù‚â•0} (ht : 1 < t) :
    Œº s =
      Œº (s ‚à© f ‚Åª¬π' {0}) + Œº (s ‚à© f ‚Åª¬π' {‚àû}) +
      ‚àë' n : ‚Ñ§, Œº (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
  have A : Œº s = Œº (s ‚à© f ‚Åª¬π' {0}) + Œº (s ‚à© f ‚Åª¬π' Ioi 0) := by
    rw [‚Üê measure_union]
    ¬∑ rw [‚Üê inter_union_distrib_left, ‚Üê preimage_union, singleton_union, Ioi_insert,
        ‚Üê _root_.bot_eq_zero, Ici_bot, preimage_univ, inter_univ]
    ¬∑ exact disjoint_singleton_left.mpr not_mem_Ioi_self
        |>.preimage f |>.inter_right' s |>.inter_left' s
    ¬∑ exact hs.inter (hf measurableSet_Ioi)
  have B : Œº (s ‚à© f ‚Åª¬π' Ioi 0) = Œº (s ‚à© f ‚Åª¬π' {‚àû}) + Œº (s ‚à© f ‚Åª¬π' Ioo 0 ‚àû) := by
    rw [‚Üê measure_union]
    ¬∑ rw [‚Üê inter_union_distrib_left]
      congr
      ext x
      simp only [mem_singleton_iff, mem_union, mem_Ioo, mem_Ioi, mem_preimage]
      obtain (H | H) : f x = ‚àû ‚à® f x < ‚àû := eq_or_lt_of_le le_top
      ¬∑ simp only [H, eq_self_iff_true, or_false_iff, ENNReal.zero_lt_top, not_top_lt, and_false]
      ¬∑ simp only [H, H.ne, and_true_iff, false_or_iff]
    ¬∑ refine disjoint_left.2 fun x hx h'x => ?_
      have : f x < ‚àû := h'x.2.2
      exact lt_irrefl _ (this.trans_le (le_of_eq hx.2.symm))
    ¬∑ exact hs.inter (hf measurableSet_Ioo)
  have C : Œº (s ‚à© f ‚Åª¬π' Ioo 0 ‚àû) =
      ‚àë' n : ‚Ñ§, Œº (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
    rw [‚Üê measure_iUnion,
      ENNReal.Ioo_zero_top_eq_iUnion_Ico_zpow (ENNReal.one_lt_coe_iff.2 ht) ENNReal.coe_ne_top,
      preimage_iUnion, inter_iUnion]
    ¬∑ intro i j hij
      wlog h : i < j generalizing i j
      ¬∑ exact (this hij.symm (hij.lt_or_lt.resolve_left h)).symm
      refine disjoint_left.2 fun x hx h'x => lt_irrefl (f x) ?_
      calc
        f x < (t : ‚Ñù‚â•0‚àû) ^ (i + 1) := hx.2.2
        _ ‚â§ (t : ‚Ñù‚â•0‚àû) ^ j := ENNReal.zpow_le_of_le (ENNReal.one_le_coe_iff.2 ht.le) h
        _ ‚â§ f x := h'x.2.1
    ¬∑ intro n
      exact hs.inter (hf measurableSet_Ico)
  rw [A, B, C, add_assoc]
#align measure_eq_measure_preimage_add_measure_tsum_Ico_zpow measure_eq_measure_preimage_add_measure_tsum_Ico_zpow

section PseudoMetricSpace

variable [PseudoMetricSpace Œ±] [MeasurableSpace Œ±] [OpensMeasurableSpace Œ±]
variable [MeasurableSpace Œ≤] {x : Œ±} {Œµ : ‚Ñù}

open Metric

@[measurability]
theorem measurableSet_ball : MeasurableSet (Metric.ball x Œµ) :=
  Metric.isOpen_ball.measurableSet
#align measurable_set_ball measurableSet_ball

@[measurability]
theorem measurableSet_closedBall : MeasurableSet (Metric.closedBall x Œµ) :=
  Metric.isClosed_ball.measurableSet
#align measurable_set_closed_ball measurableSet_closedBall

@[measurability]
theorem measurable_infDist {s : Set Œ±} : Measurable fun x => infDist x s :=
  (continuous_infDist_pt s).measurable
#align measurable_inf_dist measurable_infDist

@[measurability]
theorem Measurable.infDist {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) {s : Set Œ±} :
    Measurable fun x => infDist (f x) s :=
  measurable_infDist.comp hf
#align measurable.inf_dist Measurable.infDist

@[measurability]
theorem measurable_infNndist {s : Set Œ±} : Measurable fun x => infNndist x s :=
  (continuous_infNndist_pt s).measurable
#align measurable_inf_nndist measurable_infNndist

@[measurability]
theorem Measurable.infNndist {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) {s : Set Œ±} :
    Measurable fun x => infNndist (f x) s :=
  measurable_infNndist.comp hf
#align measurable.inf_nndist Measurable.infNndist

section

variable [SecondCountableTopology Œ±]

@[measurability]
theorem measurable_dist : Measurable fun p : Œ± √ó Œ± => dist p.1 p.2 :=
  continuous_dist.measurable
#align measurable_dist measurable_dist

@[measurability]
theorem Measurable.dist {f g : Œ≤ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun b => dist (f b) (g b) :=
  (@continuous_dist Œ± _).measurable2 hf hg
#align measurable.dist Measurable.dist

@[measurability]
theorem measurable_nndist : Measurable fun p : Œ± √ó Œ± => nndist p.1 p.2 :=
  continuous_nndist.measurable
#align measurable_nndist measurable_nndist

@[measurability]
theorem Measurable.nndist {f g : Œ≤ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun b => nndist (f b) (g b) :=
  (@continuous_nndist Œ± _).measurable2 hf hg
#align measurable.nndist Measurable.nndist

end

end PseudoMetricSpace

section PseudoEMetricSpace

variable [PseudoEMetricSpace Œ±] [MeasurableSpace Œ±] [OpensMeasurableSpace Œ±]
variable [MeasurableSpace Œ≤] {x : Œ±} {Œµ : ‚Ñù‚â•0‚àû}

open EMetric

@[measurability]
theorem measurableSet_eball : MeasurableSet (EMetric.ball x Œµ) :=
  EMetric.isOpen_ball.measurableSet
#align measurable_set_eball measurableSet_eball

@[measurability]
theorem measurable_edist_right : Measurable (edist x) :=
  (continuous_const.edist continuous_id).measurable
#align measurable_edist_right measurable_edist_right

@[measurability]
theorem measurable_edist_left : Measurable fun y => edist y x :=
  (continuous_id.edist continuous_const).measurable
#align measurable_edist_left measurable_edist_left

@[measurability]
theorem measurable_infEdist {s : Set Œ±} : Measurable fun x => infEdist x s :=
  continuous_infEdist.measurable
#align measurable_inf_edist measurable_infEdist

@[measurability]
theorem Measurable.infEdist {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) {s : Set Œ±} :
    Measurable fun x => infEdist (f x) s :=
  measurable_infEdist.comp hf
#align measurable.inf_edist Measurable.infEdist

open Metric EMetric

/-- If a set has a closed thickening with finite measure, then the measure of its `r`-closed
thickenings converges to the measure of its closure as `r` tends to `0`. -/
theorem tendsto_measure_cthickening {Œº : Measure Œ±} {s : Set Œ±}
    (hs : ‚àÉ R > 0, Œº (cthickening R s) ‚â† ‚àû) :
    Tendsto (fun r => Œº (cthickening r s)) (ùìù 0) (ùìù (Œº (closure s))) := by
  have A : Tendsto (fun r => Œº (cthickening r s)) (ùìù[Ioi 0] 0) (ùìù (Œº (closure s))) := by
    rw [closure_eq_iInter_cthickening]
    exact
      tendsto_measure_biInter_gt (fun r _ => isClosed_cthickening.measurableSet)
        (fun i j _ ij => cthickening_mono ij _) hs
  have B : Tendsto (fun r => Œº (cthickening r s)) (ùìù[Iic 0] 0) (ùìù (Œº (closure s))) := by
    apply Tendsto.congr' _ tendsto_const_nhds
    filter_upwards [self_mem_nhdsWithin (Œ± := ‚Ñù)] with _ hr
    rw [cthickening_of_nonpos hr]
  convert B.sup A
  exact (nhds_left_sup_nhds_right' 0).symm
#align tendsto_measure_cthickening tendsto_measure_cthickening

/-- If a closed set has a closed thickening with finite measure, then the measure of its closed
`r`-thickenings converge to its measure as `r` tends to `0`. -/
theorem tendsto_measure_cthickening_of_isClosed {Œº : Measure Œ±} {s : Set Œ±}
    (hs : ‚àÉ R > 0, Œº (cthickening R s) ‚â† ‚àû) (h's : IsClosed s) :
    Tendsto (fun r => Œº (cthickening r s)) (ùìù 0) (ùìù (Œº s)) := by
  convert tendsto_measure_cthickening hs
  exact h's.closure_eq.symm
#align tendsto_measure_cthickening_of_is_closed tendsto_measure_cthickening_of_isClosed

/-- If a set has a thickening with finite measure, then the measures of its `r`-thickenings
converge to the measure of its closure as `r > 0` tends to `0`. -/
theorem tendsto_measure_thickening {Œº : Measure Œ±} {s : Set Œ±}
    (hs : ‚àÉ R > 0, Œº (thickening R s) ‚â† ‚àû) :
    Tendsto (fun r => Œº (thickening r s)) (ùìù[>] 0) (ùìù (Œº (closure s))) := by
  rw [closure_eq_iInter_thickening]
  exact tendsto_measure_biInter_gt (fun r _ => isOpen_thickening.measurableSet)
      (fun i j _ ij => thickening_mono ij _) hs

/-- If a closed set has a thickening with finite measure, then the measure of its
`r`-thickenings converge to its measure as `r > 0` tends to `0`. -/
theorem tendsto_measure_thickening_of_isClosed {Œº : Measure Œ±} {s : Set Œ±}
    (hs : ‚àÉ R > 0, Œº (thickening R s) ‚â† ‚àû) (h's : IsClosed s) :
    Tendsto (fun r => Œº (thickening r s)) (ùìù[>] 0) (ùìù (Œº s)) := by
  convert tendsto_measure_thickening hs
  exact h's.closure_eq.symm

variable [SecondCountableTopology Œ±]

@[measurability]
theorem measurable_edist : Measurable fun p : Œ± √ó Œ± => edist p.1 p.2 :=
  continuous_edist.measurable
#align measurable_edist measurable_edist

@[measurability]
theorem Measurable.edist {f g : Œ≤ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun b => edist (f b) (g b) :=
  (@continuous_edist Œ± _).measurable2 hf hg
#align measurable.edist Measurable.edist

@[measurability]
theorem AEMeasurable.edist {f g : Œ≤ ‚Üí Œ±} {Œº : Measure Œ≤} (hf : AEMeasurable f Œº)
    (hg : AEMeasurable g Œº) : AEMeasurable (fun a => edist (f a) (g a)) Œº :=
  (@continuous_edist Œ± _).aemeasurable2 hf hg
#align ae_measurable.edist AEMeasurable.edist

end PseudoEMetricSpace

/-- Given a compact set in a proper space, the measure of its `r`-closed thickenings converges to
its measure as `r` tends to `0`. -/
theorem tendsto_measure_cthickening_of_isCompact [MetricSpace Œ±] [MeasurableSpace Œ±]
    [OpensMeasurableSpace Œ±] [ProperSpace Œ±] {Œº : Measure Œ±} [IsFiniteMeasureOnCompacts Œº]
    {s : Set Œ±} (hs : IsCompact s) :
    Tendsto (fun r => Œº (Metric.cthickening r s)) (ùìù 0) (ùìù (Œº s)) :=
  tendsto_measure_cthickening_of_isClosed
    ‚ü®1, zero_lt_one, hs.isBounded.cthickening.measure_lt_top.ne‚ü© hs.isClosed
#align tendsto_measure_cthickening_of_is_compact tendsto_measure_cthickening_of_isCompact

/-- If a measurable space is countably generated and separates points, it arises as
the borel sets of some second countable t4 topology (i.e. a separable metrizable one). -/
theorem exists_borelSpace_of_countablyGenerated_of_separatesPoints (Œ± : Type*)
    [m : MeasurableSpace Œ±] [CountablyGenerated Œ±] [SeparatesPoints Œ±] :
    ‚àÉ œÑ : TopologicalSpace Œ±, SecondCountableTopology Œ± ‚àß T4Space Œ± ‚àß BorelSpace Œ± := by
  rcases measurableEquiv_nat_bool_of_countablyGenerated Œ± with ‚ü®s, ‚ü®f‚ü©‚ü©
  letI := induced f inferInstance
  let F := f.toEquiv.toHomeomorphOfInducing $ inducing_induced _
  exact ‚ü®inferInstance, F.secondCountableTopology, F.symm.t4Space,
    MeasurableEmbedding.borelSpace f.measurableEmbedding F.inducing‚ü©

/-- If a measurable space on `Œ±` is countably generated and separates points, there is some
second countable t4 topology on `Œ±` (i.e. a separable metrizable one) for which every
open set is measurable. -/
theorem exists_opensMeasurableSpace_of_hasCountableSeparatingOn (Œ± : Type*)
    [m : MeasurableSpace Œ±] [HasCountableSeparatingOn Œ± MeasurableSet univ] :
    ‚àÉ œÑ : TopologicalSpace Œ±, SecondCountableTopology Œ± ‚àß T4Space Œ± ‚àß OpensMeasurableSpace Œ± := by
  rcases exists_countablyGenerated_le_of_hasCountableSeparatingOn Œ± with ‚ü®m', _, _, m'le‚ü©
  rcases exists_borelSpace_of_countablyGenerated_of_separatesPoints (m := m') with ‚ü®œÑ, _, _, œÑm'‚ü©
  exact ‚ü®œÑ, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, @OpensMeasurableSpace.mk _ _ m (œÑm'.measurable_eq.symm.le.trans m'le)‚ü©

namespace Real

open MeasurableSpace MeasureTheory

theorem borel_eq_generateFrom_Ioo_rat :
    borel ‚Ñù = .generateFrom (‚ãÉ (a : ‚Ñö) (b : ‚Ñö) (_ : a < b), {Ioo (a : ‚Ñù) (b : ‚Ñù)}) :=
  isTopologicalBasis_Ioo_rat.borel_eq_generateFrom
#align real.borel_eq_generate_from_Ioo_rat Real.borel_eq_generateFrom_Ioo_rat

theorem borel_eq_generateFrom_Iio_rat : borel ‚Ñù = .generateFrom (‚ãÉ a : ‚Ñö, {Iio (a : ‚Ñù)}) := by
  rw [borel_eq_generateFrom_Iio]
  refine le_antisymm
    (generateFrom_le ?_)
    (generateFrom_mono <| iUnion_subset fun q ‚Ü¶ singleton_subset_iff.mpr <| mem_range_self _)
  rintro _ ‚ü®a, rfl‚ü©
  have : IsLUB (range ((‚Üë) : ‚Ñö ‚Üí ‚Ñù) ‚à© Iio a) a := by
    simp [isLUB_iff_le_iff, mem_upperBounds, ‚Üê le_iff_forall_rat_lt_imp_le]
  rw [‚Üê this.biUnion_Iio_eq, ‚Üê image_univ, ‚Üê image_inter_preimage, univ_inter, biUnion_image]
  exact MeasurableSet.biUnion (to_countable _)
    fun b _ => GenerateMeasurable.basic (Iio (b : ‚Ñù)) (by simp)

theorem borel_eq_generateFrom_Ioi_rat : borel ‚Ñù = .generateFrom (‚ãÉ a : ‚Ñö, {Ioi (a : ‚Ñù)}) := by
  rw [borel_eq_generateFrom_Ioi]
  refine le_antisymm
    (generateFrom_le ?_)
    (generateFrom_mono <| iUnion_subset fun q ‚Ü¶ singleton_subset_iff.mpr <| mem_range_self _)
  rintro _ ‚ü®a, rfl‚ü©
  have : IsGLB (range ((‚Üë) : ‚Ñö ‚Üí ‚Ñù) ‚à© Ioi a) a := by
    simp [isGLB_iff_le_iff, mem_lowerBounds, ‚Üê le_iff_forall_lt_rat_imp_le]
  rw [‚Üê this.biUnion_Ioi_eq, ‚Üê image_univ, ‚Üê image_inter_preimage, univ_inter, biUnion_image]
  exact MeasurableSet.biUnion (to_countable _)
    fun b _ => GenerateMeasurable.basic (Ioi (b : ‚Ñù)) (by simp)

theorem borel_eq_generateFrom_Iic_rat : borel ‚Ñù = .generateFrom (‚ãÉ a : ‚Ñö, {Iic (a : ‚Ñù)}) := by
  rw [borel_eq_generateFrom_Ioi_rat, iUnion_singleton_eq_range, iUnion_singleton_eq_range]
  refine le_antisymm (generateFrom_le ?_) (generateFrom_le ?_) <;>
  rintro _ ‚ü®q, rfl‚ü© <;>
  dsimp only <;>
  [rw [‚Üê compl_Iic]; rw [‚Üê compl_Ioi]] <;>
  exact MeasurableSet.compl (GenerateMeasurable.basic _ (mem_range_self q))

theorem borel_eq_generateFrom_Ici_rat : borel ‚Ñù = .generateFrom (‚ãÉ a : ‚Ñö, {Ici (a : ‚Ñù)}) := by
  rw [borel_eq_generateFrom_Iio_rat, iUnion_singleton_eq_range, iUnion_singleton_eq_range]
  refine le_antisymm (generateFrom_le ?_) (generateFrom_le ?_) <;>
  rintro _ ‚ü®q, rfl‚ü© <;>
  dsimp only <;>
  [rw [‚Üê compl_Ici]; rw [‚Üê compl_Iio]] <;>
  exact MeasurableSet.compl (GenerateMeasurable.basic _ (mem_range_self q))

theorem isPiSystem_Ioo_rat :
    IsPiSystem (‚ãÉ (a : ‚Ñö) (b : ‚Ñö) (_ : a < b), {Ioo (a : ‚Ñù) (b : ‚Ñù)}) := by
  convert isPiSystem_Ioo ((‚Üë) : ‚Ñö ‚Üí ‚Ñù) ((‚Üë) : ‚Ñö ‚Üí ‚Ñù)
  ext x
  simp [eq_comm]
#align real.is_pi_system_Ioo_rat Real.isPiSystem_Ioo_rat

theorem isPiSystem_Iio_rat : IsPiSystem (‚ãÉ a : ‚Ñö, {Iio (a : ‚Ñù)}) := by
  convert isPiSystem_image_Iio (((‚Üë) : ‚Ñö ‚Üí ‚Ñù) '' univ)
  ext x
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]

theorem isPiSystem_Ioi_rat : IsPiSystem (‚ãÉ a : ‚Ñö, {Ioi (a : ‚Ñù)}) := by
  convert isPiSystem_image_Ioi (((‚Üë) : ‚Ñö ‚Üí ‚Ñù) '' univ)
  ext x
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]

theorem isPiSystem_Iic_rat : IsPiSystem (‚ãÉ a : ‚Ñö, {Iic (a : ‚Ñù)}) := by
  convert isPiSystem_image_Iic (((‚Üë) : ‚Ñö ‚Üí ‚Ñù) '' univ)
  ext x
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]

theorem isPiSystem_Ici_rat : IsPiSystem (‚ãÉ a : ‚Ñö, {Ici (a : ‚Ñù)}) := by
  convert isPiSystem_image_Ici (((‚Üë) : ‚Ñö ‚Üí ‚Ñù) '' univ)
  ext x
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]

/-- The intervals `(-(n + 1), (n + 1))` form a finite spanning sets in the set of open intervals
with rational endpoints for a locally finite measure `Œº` on `‚Ñù`. -/
def finiteSpanningSetsInIooRat (Œº : Measure ‚Ñù) [IsLocallyFiniteMeasure Œº] :
    Œº.FiniteSpanningSetsIn (‚ãÉ (a : ‚Ñö) (b : ‚Ñö) (_ : a < b), {Ioo (a : ‚Ñù) (b : ‚Ñù)}) where
  set n := Ioo (-(n + 1)) (n + 1)
  set_mem n := by
    simp only [mem_iUnion, mem_singleton_iff]
    refine' ‚ü®-(n + 1 : ‚Ñï), n + 1, _, by simp‚ü©
    -- TODO: norm_cast fails here?
    push_cast
    exact neg_lt_self n.cast_add_one_pos
  finite n := measure_Ioo_lt_top
  spanning :=
    iUnion_eq_univ_iff.2 fun x =>
      ‚ü®‚åä|x|‚åã‚Çä, neg_lt.1 ((neg_le_abs x).trans_lt (Nat.lt_floor_add_one _)),
        (le_abs_self x).trans_lt (Nat.lt_floor_add_one _)‚ü©
#align real.finite_spanning_sets_in_Ioo_rat Real.finiteSpanningSetsInIooRat

theorem measure_ext_Ioo_rat {Œº ŒΩ : Measure ‚Ñù} [IsLocallyFiniteMeasure Œº]
    (h : ‚àÄ a b : ‚Ñö, Œº (Ioo a b) = ŒΩ (Ioo a b)) : Œº = ŒΩ :=
  (finiteSpanningSetsInIooRat Œº).ext borel_eq_generateFrom_Ioo_rat isPiSystem_Ioo_rat <| by
    simp only [mem_iUnion, mem_singleton_iff]
    rintro _ ‚ü®a, b, -, rfl‚ü©
    apply h
#align real.measure_ext_Ioo_rat Real.measure_ext_Ioo_rat

end Real

variable [MeasurableSpace Œ±]

@[measurability]
theorem measurable_real_toNNReal : Measurable Real.toNNReal :=
  continuous_real_toNNReal.measurable
#align measurable_real_to_nnreal measurable_real_toNNReal

@[measurability]
theorem Measurable.real_toNNReal {f : Œ± ‚Üí ‚Ñù} (hf : Measurable f) :
    Measurable fun x => Real.toNNReal (f x) :=
  measurable_real_toNNReal.comp hf
#align measurable.real_to_nnreal Measurable.real_toNNReal

@[measurability]
theorem AEMeasurable.real_toNNReal {f : Œ± ‚Üí ‚Ñù} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => Real.toNNReal (f x)) Œº :=
  measurable_real_toNNReal.comp_aemeasurable hf
#align ae_measurable.real_to_nnreal AEMeasurable.real_toNNReal

@[measurability]
theorem measurable_coe_nnreal_real : Measurable ((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù) :=
  NNReal.continuous_coe.measurable
#align measurable_coe_nnreal_real measurable_coe_nnreal_real

@[measurability]
theorem Measurable.coe_nnreal_real {f : Œ± ‚Üí ‚Ñù‚â•0} (hf : Measurable f) :
    Measurable fun x => (f x : ‚Ñù) :=
  measurable_coe_nnreal_real.comp hf
#align measurable.coe_nnreal_real Measurable.coe_nnreal_real

@[measurability]
theorem AEMeasurable.coe_nnreal_real {f : Œ± ‚Üí ‚Ñù‚â•0} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x : ‚Ñù)) Œº :=
  measurable_coe_nnreal_real.comp_aemeasurable hf
#align ae_measurable.coe_nnreal_real AEMeasurable.coe_nnreal_real

@[measurability]
theorem measurable_coe_nnreal_ennreal : Measurable ((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0‚àû) :=
  ENNReal.continuous_coe.measurable
#align measurable_coe_nnreal_ennreal measurable_coe_nnreal_ennreal

@[measurability]
theorem Measurable.coe_nnreal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0} (hf : Measurable f) :
    Measurable fun x => (f x : ‚Ñù‚â•0‚àû) :=
  ENNReal.continuous_coe.measurable.comp hf
#align measurable.coe_nnreal_ennreal Measurable.coe_nnreal_ennreal

@[measurability]
theorem AEMeasurable.coe_nnreal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x : ‚Ñù‚â•0‚àû)) Œº :=
  ENNReal.continuous_coe.measurable.comp_aemeasurable hf
#align ae_measurable.coe_nnreal_ennreal AEMeasurable.coe_nnreal_ennreal

@[measurability]
theorem Measurable.ennreal_ofReal {f : Œ± ‚Üí ‚Ñù} (hf : Measurable f) :
    Measurable fun x => ENNReal.ofReal (f x) :=
  ENNReal.continuous_ofReal.measurable.comp hf
#align measurable.ennreal_of_real Measurable.ennreal_ofReal

@[measurability]
lemma AEMeasurable.ennreal_ofReal {f : Œ± ‚Üí ‚Ñù} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x ‚Ü¶ ENNReal.ofReal (f x)) Œº :=
  ENNReal.continuous_ofReal.measurable.comp_aemeasurable hf

@[simp, norm_cast]
theorem measurable_coe_nnreal_real_iff {f : Œ± ‚Üí ‚Ñù‚â•0} :
    Measurable (fun x => f x : Œ± ‚Üí ‚Ñù) ‚Üî Measurable f :=
  ‚ü®fun h => by simpa only [Real.toNNReal_coe] using h.real_toNNReal, Measurable.coe_nnreal_real‚ü©
#align measurable_coe_nnreal_real_iff measurable_coe_nnreal_real_iff

@[simp, norm_cast]
theorem aemeasurable_coe_nnreal_real_iff {f : Œ± ‚Üí ‚Ñù‚â•0} {Œº : Measure Œ±} :
    AEMeasurable (fun x => f x : Œ± ‚Üí ‚Ñù) Œº ‚Üî AEMeasurable f Œº :=
  ‚ü®fun h => by simpa only [Real.toNNReal_coe] using h.real_toNNReal, AEMeasurable.coe_nnreal_real‚ü©
#align ae_measurable_coe_nnreal_real_iff aemeasurable_coe_nnreal_real_iff

@[deprecated] -- 2024-03-02
alias aEMeasurable_coe_nnreal_real_iff := aemeasurable_coe_nnreal_real_iff

/-- The set of finite `‚Ñù‚â•0‚àû` numbers is `MeasurableEquiv` to `‚Ñù‚â•0`. -/
def MeasurableEquiv.ennrealEquivNNReal : { r : ‚Ñù‚â•0‚àû | r ‚â† ‚àû } ‚âÉ·µê ‚Ñù‚â•0 :=
  ENNReal.neTopHomeomorphNNReal.toMeasurableEquiv
#align measurable_equiv.ennreal_equiv_nnreal MeasurableEquiv.ennrealEquivNNReal

namespace ENNReal

theorem measurable_of_measurable_nnreal {f : ‚Ñù‚â•0‚àû ‚Üí Œ±} (h : Measurable fun p : ‚Ñù‚â•0 => f p) :
    Measurable f :=
  measurable_of_measurable_on_compl_singleton ‚àû
    (MeasurableEquiv.ennrealEquivNNReal.symm.measurable_comp_iff.1 h)
#align ennreal.measurable_of_measurable_nnreal ENNReal.measurable_of_measurable_nnreal

/-- `‚Ñù‚â•0‚àû` is `MeasurableEquiv` to `‚Ñù‚â•0 ‚äï Unit`. -/
def ennrealEquivSum : ‚Ñù‚â•0‚àû ‚âÉ·µê Sum ‚Ñù‚â•0 Unit :=
  { Equiv.optionEquivSumPUnit ‚Ñù‚â•0 with
    measurable_toFun := measurable_of_measurable_nnreal measurable_inl
    measurable_invFun :=
      measurable_sum measurable_coe_nnreal_ennreal (@measurable_const ‚Ñù‚â•0‚àû Unit _ _ ‚àû) }
#align ennreal.ennreal_equiv_sum ENNReal.ennrealEquivSum

open Function (uncurry)

theorem measurable_of_measurable_nnreal_prod [MeasurableSpace Œ≤] [MeasurableSpace Œ≥]
    {f : ‚Ñù‚â•0‚àû √ó Œ≤ ‚Üí Œ≥} (H‚ÇÅ : Measurable fun p : ‚Ñù‚â•0 √ó Œ≤ => f (p.1, p.2))
    (H‚ÇÇ : Measurable fun x => f (‚àû, x)) : Measurable f :=
  let e : ‚Ñù‚â•0‚àû √ó Œ≤ ‚âÉ·µê Sum (‚Ñù‚â•0 √ó Œ≤) (Unit √ó Œ≤) :=
    (ennrealEquivSum.prodCongr (MeasurableEquiv.refl Œ≤)).trans
      (MeasurableEquiv.sumProdDistrib _ _ _)
  e.symm.measurable_comp_iff.1 <| measurable_sum H‚ÇÅ (H‚ÇÇ.comp measurable_id.snd)
#align ennreal.measurable_of_measurable_nnreal_prod ENNReal.measurable_of_measurable_nnreal_prod

theorem measurable_of_measurable_nnreal_nnreal [MeasurableSpace Œ≤] {f : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû ‚Üí Œ≤}
    (h‚ÇÅ : Measurable fun p : ‚Ñù‚â•0 √ó ‚Ñù‚â•0 => f (p.1, p.2)) (h‚ÇÇ : Measurable fun r : ‚Ñù‚â•0 => f (‚àû, r))
    (h‚ÇÉ : Measurable fun r : ‚Ñù‚â•0 => f (r, ‚àû)) : Measurable f :=
  measurable_of_measurable_nnreal_prod
    (measurable_swap_iff.1 <| measurable_of_measurable_nnreal_prod (h‚ÇÅ.comp measurable_swap) h‚ÇÉ)
    (measurable_of_measurable_nnreal h‚ÇÇ)
#align ennreal.measurable_of_measurable_nnreal_nnreal ENNReal.measurable_of_measurable_nnreal_nnreal

@[measurability]
theorem measurable_ofReal : Measurable ENNReal.ofReal :=
  ENNReal.continuous_ofReal.measurable
#align ennreal.measurable_of_real ENNReal.measurable_ofReal

@[measurability]
theorem measurable_toReal : Measurable ENNReal.toReal :=
  ENNReal.measurable_of_measurable_nnreal measurable_coe_nnreal_real
#align ennreal.measurable_to_real ENNReal.measurable_toReal

@[measurability]
theorem measurable_toNNReal : Measurable ENNReal.toNNReal :=
  ENNReal.measurable_of_measurable_nnreal measurable_id
#align ennreal.measurable_to_nnreal ENNReal.measurable_toNNReal

instance instMeasurableMul‚ÇÇ : MeasurableMul‚ÇÇ ‚Ñù‚â•0‚àû := by
  refine' ‚ü®measurable_of_measurable_nnreal_nnreal _ _ _‚ü©
  ¬∑ simp only [‚Üê ENNReal.coe_mul, measurable_mul.coe_nnreal_ennreal]
  ¬∑ simp only [ENNReal.top_mul', ENNReal.coe_eq_zero]
    exact measurable_const.piecewise (measurableSet_singleton _) measurable_const
  ¬∑ simp only [ENNReal.mul_top', ENNReal.coe_eq_zero]
    exact measurable_const.piecewise (measurableSet_singleton _) measurable_const
#align ennreal.has_measurable_mul‚ÇÇ ENNReal.instMeasurableMul‚ÇÇ

instance instMeasurableSub‚ÇÇ : MeasurableSub‚ÇÇ ‚Ñù‚â•0‚àû :=
  ‚ü®by
    apply measurable_of_measurable_nnreal_nnreal <;>
      simp [‚Üê WithTop.coe_sub]; exact continuous_sub.measurable.coe_nnreal_ennreal‚ü©
#align ennreal.has_measurable_sub‚ÇÇ ENNReal.instMeasurableSub‚ÇÇ

instance instMeasurableInv : MeasurableInv ‚Ñù‚â•0‚àû :=
  ‚ü®continuous_inv.measurable‚ü©
#align ennreal.has_measurable_inv ENNReal.instMeasurableInv

instance : MeasurableSMul ‚Ñù‚â•0 ‚Ñù‚â•0‚àû where
  measurable_const_smul := by
    simp_rw [ENNReal.smul_def]
    exact fun _ ‚Ü¶ MeasurableSMul.measurable_const_smul _
  measurable_smul_const := fun x ‚Ü¶ by
    simp_rw [ENNReal.smul_def]
    exact measurable_coe_nnreal_ennreal.mul_const _

/-- A limit (over a general filter) of measurable `‚Ñù‚â•0‚àû` valued functions is measurable. -/
theorem measurable_of_tendsto' {Œπ : Type*} {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} {g : Œ± ‚Üí ‚Ñù‚â•0‚àû} (u : Filter Œπ)
    [NeBot u] [IsCountablyGenerated u] (hf : ‚àÄ i, Measurable (f i)) (lim : Tendsto f u (ùìù g)) :
    Measurable g := by
  rcases u.exists_seq_tendsto with ‚ü®x, hx‚ü©
  rw [tendsto_pi_nhds] at lim
  have : (fun y => liminf (fun n => (f (x n) y : ‚Ñù‚â•0‚àû)) atTop) = g := by
    ext1 y
    exact ((lim y).comp hx).liminf_eq
  rw [‚Üê this]
  show Measurable fun y => liminf (fun n => (f (x n) y : ‚Ñù‚â•0‚àû)) atTop
  exact measurable_liminf fun n => hf (x n)
#align measurable_of_tendsto_ennreal' ENNReal.measurable_of_tendsto'

-- 2024-03-09
@[deprecated] alias _root_.measurable_of_tendsto_ennreal' := ENNReal.measurable_of_tendsto'

/-- A sequential limit of measurable `‚Ñù‚â•0‚àû` valued functions is measurable. -/
theorem measurable_of_tendsto {f : ‚Ñï ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} {g : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : ‚àÄ i, Measurable (f i))
    (lim : Tendsto f atTop (ùìù g)) : Measurable g :=
  measurable_of_tendsto' atTop hf lim
#align measurable_of_tendsto_ennreal ENNReal.measurable_of_tendsto

-- 2024-03-09
@[deprecated] alias _root_.measurable_of_tendsto_ennreal := ENNReal.measurable_of_tendsto

/-- A limit (over a general filter) of a.e.-measurable `‚Ñù‚â•0‚àû` valued functions is
a.e.-measurable. -/
lemma aemeasurable_of_tendsto' {Œπ : Type*} {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} {g : Œ± ‚Üí ‚Ñù‚â•0‚àû}
    {Œº : Measure Œ±} (u : Filter Œπ) [NeBot u] [IsCountablyGenerated u]
    (hf : ‚àÄ i, AEMeasurable (f i) Œº) (hlim : ‚àÄ·µê a ‚àÇŒº, Tendsto (fun i ‚Ü¶ f i a) u (ùìù (g a))) :
    AEMeasurable g Œº := by
  rcases u.exists_seq_tendsto with ‚ü®v, hv‚ü©
  have h'f : ‚àÄ n, AEMeasurable (f (v n)) Œº := fun n ‚Ü¶ hf (v n)
  set p : Œ± ‚Üí (‚Ñï ‚Üí ‚Ñù‚â•0‚àû) ‚Üí Prop := fun x f' ‚Ü¶ Tendsto f' atTop (ùìù (g x))
  have hp : ‚àÄ·µê x ‚àÇŒº, p x fun n ‚Ü¶ f (v n) x := by
    filter_upwards [hlim] with x hx using hx.comp hv
  set aeSeqLim := fun x ‚Ü¶ ite (x ‚àà aeSeqSet h'f p) (g x) (‚ü®f (v 0) x‚ü© : Nonempty ‚Ñù‚â•0‚àû).some
  refine ‚ü®aeSeqLim, measurable_of_tendsto' atTop (aeSeq.measurable h'f p)
    (tendsto_pi_nhds.mpr fun x ‚Ü¶ ?_), ?_‚ü©
  ¬∑ unfold_let aeSeqLim
    simp_rw [aeSeq]
    split_ifs with hx
    ¬∑ simp_rw [aeSeq.mk_eq_fun_of_mem_aeSeqSet h'f hx]
      exact aeSeq.fun_prop_of_mem_aeSeqSet h'f hx
    ¬∑ exact tendsto_const_nhds
  ¬∑ exact (ite_ae_eq_of_measure_compl_zero g (fun x ‚Ü¶ (‚ü®f (v 0) x‚ü© : Nonempty ‚Ñù‚â•0‚àû).some)
      (aeSeqSet h'f p) (aeSeq.measure_compl_aeSeqSet_eq_zero h'f hp)).symm

/-- A limit of a.e.-measurable `‚Ñù‚â•0‚àû` valued functions is a.e.-measurable. -/
lemma aemeasurable_of_tendsto {f : ‚Ñï ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} {g : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure Œ±}
    (hf : ‚àÄ i, AEMeasurable (f i) Œº) (hlim : ‚àÄ·µê a ‚àÇŒº, Tendsto (fun i ‚Ü¶ f i a) atTop (ùìù (g a))) :
    AEMeasurable g Œº :=
  aemeasurable_of_tendsto' atTop hf hlim

end ENNReal

@[measurability]
theorem Measurable.ennreal_toNNReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) :
    Measurable fun x => (f x).toNNReal :=
  ENNReal.measurable_toNNReal.comp hf
#align measurable.ennreal_to_nnreal Measurable.ennreal_toNNReal

@[measurability]
theorem AEMeasurable.ennreal_toNNReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x).toNNReal) Œº :=
  ENNReal.measurable_toNNReal.comp_aemeasurable hf
#align ae_measurable.ennreal_to_nnreal AEMeasurable.ennreal_toNNReal

@[simp, norm_cast]
theorem measurable_coe_nnreal_ennreal_iff {f : Œ± ‚Üí ‚Ñù‚â•0} :
    (Measurable fun x => (f x : ‚Ñù‚â•0‚àû)) ‚Üî Measurable f :=
  ‚ü®fun h => h.ennreal_toNNReal, fun h => h.coe_nnreal_ennreal‚ü©
#align measurable_coe_nnreal_ennreal_iff measurable_coe_nnreal_ennreal_iff

@[simp, norm_cast]
theorem aemeasurable_coe_nnreal_ennreal_iff {f : Œ± ‚Üí ‚Ñù‚â•0} {Œº : Measure Œ±} :
    AEMeasurable (fun x => (f x : ‚Ñù‚â•0‚àû)) Œº ‚Üî AEMeasurable f Œº :=
  ‚ü®fun h => h.ennreal_toNNReal, fun h => h.coe_nnreal_ennreal‚ü©
#align ae_measurable_coe_nnreal_ennreal_iff aemeasurable_coe_nnreal_ennreal_iff

@[measurability]
theorem Measurable.ennreal_toReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) :
    Measurable fun x => ENNReal.toReal (f x) :=
  ENNReal.measurable_toReal.comp hf
#align measurable.ennreal_to_real Measurable.ennreal_toReal

@[measurability]
theorem AEMeasurable.ennreal_toReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => ENNReal.toReal (f x)) Œº :=
  ENNReal.measurable_toReal.comp_aemeasurable hf
#align ae_measurable.ennreal_to_real AEMeasurable.ennreal_toReal

/-- note: `‚Ñù‚â•0‚àû` can probably be generalized in a future version of this lemma. -/
@[measurability]
theorem Measurable.ennreal_tsum {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} (h : ‚àÄ i, Measurable (f i)) :
    Measurable fun x => ‚àë' i, f i x := by
  simp_rw [ENNReal.tsum_eq_iSup_sum]
  apply measurable_iSup
  exact fun s => s.measurable_sum fun i _ => h i
#align measurable.ennreal_tsum Measurable.ennreal_tsum

@[measurability]
theorem Measurable.ennreal_tsum' {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} (h : ‚àÄ i, Measurable (f i)) :
    Measurable (‚àë' i, f i) := by
  convert Measurable.ennreal_tsum h with x
  exact tsum_apply (Pi.summable.2 fun _ => ENNReal.summable)
#align measurable.ennreal_tsum' Measurable.ennreal_tsum'

@[measurability]
theorem Measurable.nnreal_tsum {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0} (h : ‚àÄ i, Measurable (f i)) :
    Measurable fun x => ‚àë' i, f i x := by
  simp_rw [NNReal.tsum_eq_toNNReal_tsum]
  exact (Measurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_toNNReal
#align measurable.nnreal_tsum Measurable.nnreal_tsum

@[measurability]
theorem AEMeasurable.ennreal_tsum {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure Œ±}
    (h : ‚àÄ i, AEMeasurable (f i) Œº) : AEMeasurable (fun x => ‚àë' i, f i x) Œº := by
  simp_rw [ENNReal.tsum_eq_iSup_sum]
  apply aemeasurable_iSup
  exact fun s => Finset.aemeasurable_sum s fun i _ => h i
#align ae_measurable.ennreal_tsum AEMeasurable.ennreal_tsum

@[measurability]
theorem AEMeasurable.nnreal_tsum {Œ± : Type*} [MeasurableSpace Œ±] {Œπ : Type*} [Countable Œπ]
    {f : Œπ ‚Üí Œ± ‚Üí NNReal} {Œº : MeasureTheory.Measure Œ±} (h : ‚àÄ i : Œπ, AEMeasurable (f i) Œº) :
    AEMeasurable (fun x : Œ± => ‚àë' i : Œπ, f i x) Œº := by
  simp_rw [NNReal.tsum_eq_toNNReal_tsum]
  exact (AEMeasurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_toNNReal
#align ae_measurable.nnreal_tsum AEMeasurable.nnreal_tsum

@[measurability]
theorem measurable_coe_real_ereal : Measurable ((‚Üë) : ‚Ñù ‚Üí EReal) :=
  continuous_coe_real_ereal.measurable
#align measurable_coe_real_ereal measurable_coe_real_ereal

@[measurability]
theorem Measurable.coe_real_ereal {f : Œ± ‚Üí ‚Ñù} (hf : Measurable f) :
    Measurable fun x => (f x : EReal) :=
  measurable_coe_real_ereal.comp hf
#align measurable.coe_real_ereal Measurable.coe_real_ereal

@[measurability]
theorem AEMeasurable.coe_real_ereal {f : Œ± ‚Üí ‚Ñù} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x : EReal)) Œº :=
  measurable_coe_real_ereal.comp_aemeasurable hf
#align ae_measurable.coe_real_ereal AEMeasurable.coe_real_ereal

/-- The set of finite `EReal` numbers is `MeasurableEquiv` to `‚Ñù`. -/
def MeasurableEquiv.erealEquivReal : ({‚ä•, ‚ä§}·∂ú : Set EReal) ‚âÉ·µê ‚Ñù :=
  EReal.neBotTopHomeomorphReal.toMeasurableEquiv
#align measurable_equiv.ereal_equiv_real MeasurableEquiv.erealEquivReal

theorem EReal.measurable_of_measurable_real {f : EReal ‚Üí Œ±} (h : Measurable fun p : ‚Ñù => f p) :
    Measurable f :=
  measurable_of_measurable_on_compl_finite {‚ä•, ‚ä§} (by simp)
    (MeasurableEquiv.erealEquivReal.symm.measurable_comp_iff.1 h)
#align ereal.measurable_of_measurable_real EReal.measurable_of_measurable_real

@[measurability]
theorem measurable_ereal_toReal : Measurable EReal.toReal :=
  EReal.measurable_of_measurable_real (by simpa using measurable_id)
#align measurable_ereal_to_real measurable_ereal_toReal

@[measurability]
theorem Measurable.ereal_toReal {f : Œ± ‚Üí EReal} (hf : Measurable f) :
    Measurable fun x => (f x).toReal :=
  measurable_ereal_toReal.comp hf
#align measurable.ereal_to_real Measurable.ereal_toReal

@[measurability]
theorem AEMeasurable.ereal_toReal {f : Œ± ‚Üí EReal} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x).toReal) Œº :=
  measurable_ereal_toReal.comp_aemeasurable hf
#align ae_measurable.ereal_to_real AEMeasurable.ereal_toReal

@[measurability]
theorem measurable_coe_ennreal_ereal : Measurable ((‚Üë) : ‚Ñù‚â•0‚àû ‚Üí EReal) :=
  continuous_coe_ennreal_ereal.measurable
#align measurable_coe_ennreal_ereal measurable_coe_ennreal_ereal

@[measurability]
theorem Measurable.coe_ereal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) :
    Measurable fun x => (f x : EReal) :=
  measurable_coe_ennreal_ereal.comp hf
#align measurable.coe_ereal_ennreal Measurable.coe_ereal_ennreal

@[measurability]
theorem AEMeasurable.coe_ereal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x : EReal)) Œº :=
  measurable_coe_ennreal_ereal.comp_aemeasurable hf
#align ae_measurable.coe_ereal_ennreal AEMeasurable.coe_ereal_ennreal

namespace NNReal

/-- A limit (over a general filter) of measurable `‚Ñù‚â•0` valued functions is measurable. -/
theorem measurable_of_tendsto' {Œπ} {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0} {g : Œ± ‚Üí ‚Ñù‚â•0} (u : Filter Œπ) [NeBot u]
    [IsCountablyGenerated u] (hf : ‚àÄ i, Measurable (f i)) (lim : Tendsto f u (ùìù g)) :
    Measurable g := by
  simp_rw [‚Üê measurable_coe_nnreal_ennreal_iff] at hf ‚ä¢
  refine' ENNReal.measurable_of_tendsto' u hf _
  rw [tendsto_pi_nhds] at lim ‚ä¢
  exact fun x => (ENNReal.continuous_coe.tendsto (g x)).comp (lim x)
#align measurable_of_tendsto_nnreal' NNReal.measurable_of_tendsto'

-- 2024-03-09
@[deprecated] alias _root_.measurable_of_tendsto_nnreal' := NNReal.measurable_of_tendsto'

/-- A sequential limit of measurable `‚Ñù‚â•0` valued functions is measurable. -/
theorem measurable_of_tendsto {f : ‚Ñï ‚Üí Œ± ‚Üí ‚Ñù‚â•0} {g : Œ± ‚Üí ‚Ñù‚â•0} (hf : ‚àÄ i, Measurable (f i))
    (lim : Tendsto f atTop (ùìù g)) : Measurable g :=
  measurable_of_tendsto' atTop hf lim
#align measurable_of_tendsto_nnreal NNReal.measurable_of_tendsto

-- 2024-03-09
@[deprecated] alias _root_.measurable_of_tendsto_nnreal := NNReal.measurable_of_tendsto

end NNReal

/-- If a function `f : Œ± ‚Üí ‚Ñù‚â•0` is measurable and the measure is œÉ-finite, then there exists
spanning measurable sets with finite measure on which `f` is bounded.
See also `StronglyMeasurable.exists_spanning_measurableSet_norm_le` for functions into normed
groups. -/
theorem exists_spanning_measurableSet_le {m : MeasurableSpace Œ±} {f : Œ± ‚Üí ‚Ñù‚â•0}
    (hf : Measurable f) (Œº : Measure Œ±) [SigmaFinite Œº] :
    ‚àÉ s : ‚Ñï ‚Üí Set Œ±,
      (‚àÄ n, MeasurableSet (s n) ‚àß Œº (s n) < ‚àû ‚àß ‚àÄ x ‚àà s n, f x ‚â§ n) ‚àß
      ‚ãÉ i, s i = Set.univ := by
  let sigma_finite_sets := spanningSets Œº
  let norm_sets := fun n : ‚Ñï => { x | f x ‚â§ n }
  have norm_sets_spanning : ‚ãÉ n, norm_sets n = Set.univ := by
    ext1 x
    simp only [Set.mem_iUnion, Set.mem_setOf_eq, Set.mem_univ, iff_true_iff]
    exact exists_nat_ge (f x)
  let sets n := sigma_finite_sets n ‚à© norm_sets n
  have h_meas : ‚àÄ n, MeasurableSet (sets n) := by
    refine' fun n => MeasurableSet.inter _ _
    ¬∑ exact measurable_spanningSets Œº n
    ¬∑ exact hf measurableSet_Iic
  have h_finite : ‚àÄ n, Œº (sets n) < ‚àû := by
    refine' fun n => (measure_mono (Set.inter_subset_left _ _)).trans_lt _
    exact measure_spanningSets_lt_top Œº n
  refine' ‚ü®sets, fun n => ‚ü®h_meas n, h_finite n, _‚ü©, _‚ü©
  ¬∑ exact fun x hx => hx.2
  ¬∑ have :
      ‚ãÉ i, sigma_finite_sets i ‚à© norm_sets i = (‚ãÉ i, sigma_finite_sets i) ‚à© ‚ãÉ i, norm_sets i := by
      refine' Set.iUnion_inter_of_monotone (monotone_spanningSets Œº) fun i j hij x => _
      simp only [norm_sets, Set.mem_setOf_eq]
      refine' fun hif => hif.trans _
      exact mod_cast hij
    rw [this, norm_sets_spanning, iUnion_spanningSets Œº, Set.inter_univ]

section NormedAddCommGroup

variable [NormedAddCommGroup Œ±] [OpensMeasurableSpace Œ±] [MeasurableSpace Œ≤]

@[measurability]
theorem measurable_norm : Measurable (norm : Œ± ‚Üí ‚Ñù) :=
  continuous_norm.measurable
#align measurable_norm measurable_norm

@[measurability]
theorem Measurable.norm {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) : Measurable fun a => norm (f a) :=
  measurable_norm.comp hf
#align measurable.norm Measurable.norm

@[measurability]
theorem AEMeasurable.norm {f : Œ≤ ‚Üí Œ±} {Œº : Measure Œ≤} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun a => norm (f a)) Œº :=
  measurable_norm.comp_aemeasurable hf
#align ae_measurable.norm AEMeasurable.norm

@[measurability]
theorem measurable_nnnorm : Measurable (nnnorm : Œ± ‚Üí ‚Ñù‚â•0) :=
  continuous_nnnorm.measurable
#align measurable_nnnorm measurable_nnnorm

@[measurability]
theorem Measurable.nnnorm {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) : Measurable fun a => ‚Äñf a‚Äñ‚Çä :=
  measurable_nnnorm.comp hf
#align measurable.nnnorm Measurable.nnnorm

@[measurability]
theorem AEMeasurable.nnnorm {f : Œ≤ ‚Üí Œ±} {Œº : Measure Œ≤} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun a => ‚Äñf a‚Äñ‚Çä) Œº :=
  measurable_nnnorm.comp_aemeasurable hf
#align ae_measurable.nnnorm AEMeasurable.nnnorm

@[measurability]
theorem measurable_ennnorm : Measurable fun x : Œ± => (‚Äñx‚Äñ‚Çä : ‚Ñù‚â•0‚àû) :=
  measurable_nnnorm.coe_nnreal_ennreal
#align measurable_ennnorm measurable_ennnorm

@[measurability]
theorem Measurable.ennnorm {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) : Measurable fun a => (‚Äñf a‚Äñ‚Çä : ‚Ñù‚â•0‚àû) :=
  hf.nnnorm.coe_nnreal_ennreal
#align measurable.ennnorm Measurable.ennnorm

@[measurability]
theorem AEMeasurable.ennnorm {f : Œ≤ ‚Üí Œ±} {Œº : Measure Œ≤} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun a => (‚Äñf a‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) Œº :=
  measurable_ennnorm.comp_aemeasurable hf
#align ae_measurable.ennnorm AEMeasurable.ennnorm

end NormedAddCommGroup
