/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Yury Kudryashov
-/
import Mathlib.MeasureTheory.Group.Arithmetic
import Mathlib.Topology.GDelta.MetrizableSpace
import Mathlib.Topology.Instances.EReal.Lemmas
import Mathlib.Topology.Instances.Rat

/-!
# Borel (measurable) space

## Main definitions

* `borel Œ±` : the least `œÉ`-algebra that contains all open sets;
* `class BorelSpace` : a space with `TopologicalSpace` and `MeasurableSpace` structures
  such that `‚ÄπMeasurableSpace Œ±‚Ä∫ = borel Œ±`;
* `class OpensMeasurableSpace` : a space with `TopologicalSpace` and `MeasurableSpace`
  structures such that all open sets are measurable; equivalently, `borel Œ± ‚â§ ‚ÄπMeasurableSpace Œ±‚Ä∫`.
* `BorelSpace` instances on `Empty`, `Unit`, `Bool`, `Nat`, `Int`, `Rat`;
* `MeasurableSpace` and `BorelSpace` instances on `‚Ñù`, `‚Ñù‚â•0`, `‚Ñù‚â•0‚àû`.

## Main statements

* `IsOpen.measurableSet`, `IsClosed.measurableSet`: open and closed sets are measurable;
* `Continuous.measurable` : a continuous function is measurable;
* `Continuous.measurable2` : if `f : Œ± ‚Üí Œ≤` and `g : Œ± ‚Üí Œ≥` are measurable and `op : Œ≤ √ó Œ≥ ‚Üí Œ¥`
  is continuous, then `fun x => op (f x, g y)` is measurable;
* `Measurable.add` etc : dot notation for arithmetic operations on `Measurable` predicates,
  and similarly for `dist` and `edist`;
* `AEMeasurable.add` : similar dot notation for almost everywhere measurable functions;
-/


noncomputable section

open Filter MeasureTheory Set Topology
open scoped NNReal ENNReal MeasureTheory

universe u v w x y

variable {Œ± Œ≤ Œ≥ Œ≥‚ÇÇ Œ¥ : Type*} {Œπ : Sort y} {s t u : Set Œ±}

open MeasurableSpace TopologicalSpace

/-- `MeasurableSpace` structure generated by `TopologicalSpace`. -/
def borel (Œ± : Type u) [TopologicalSpace Œ±] : MeasurableSpace Œ± :=
  generateFrom { s : Set Œ± | IsOpen s }

theorem borel_anti : Antitone (@borel Œ±) := fun _ _ h =>
  MeasurableSpace.generateFrom_le fun _ hs => .basic _ (h _ hs)

theorem borel_eq_top_of_discrete [TopologicalSpace Œ±] [DiscreteTopology Œ±] : borel Œ± = ‚ä§ :=
  top_le_iff.1 fun s _ => GenerateMeasurable.basic s (isOpen_discrete s)

theorem borel_eq_generateFrom_of_subbasis {s : Set (Set Œ±)} [t : TopologicalSpace Œ±]
    [SecondCountableTopology Œ±] (hs : t = .generateFrom s) : borel Œ± = .generateFrom s :=
  le_antisymm
    (generateFrom_le fun u (hu : t.IsOpen u) => by
      rw [hs] at hu
      induction hu with
      | basic u hu => exact GenerateMeasurable.basic u hu
      | univ => exact @MeasurableSet.univ Œ± (generateFrom s)
      | inter s‚ÇÅ s‚ÇÇ _ _ hs‚ÇÅ hs‚ÇÇ => exact @MeasurableSet.inter Œ± (generateFrom s) _ _ hs‚ÇÅ hs‚ÇÇ
      | sUnion f hf ih =>
        rcases isOpen_sUnion_countable f (by rwa [hs]) with ‚ü®v, hv, vf, vu‚ü©
        rw [‚Üê vu]
        exact @MeasurableSet.sUnion Œ± (generateFrom s) _ hv fun x xv => ih _ (vf xv))
    (generateFrom_le fun u hu =>
      GenerateMeasurable.basic _ <| show t.IsOpen u by rw [hs]; exact GenerateOpen.basic _ hu)

theorem TopologicalSpace.IsTopologicalBasis.borel_eq_generateFrom [TopologicalSpace Œ±]
    [SecondCountableTopology Œ±] {s : Set (Set Œ±)} (hs : IsTopologicalBasis s) :
    borel Œ± = .generateFrom s :=
  borel_eq_generateFrom_of_subbasis hs.eq_generateFrom

theorem isPiSystem_isOpen [TopologicalSpace Œ±] : IsPiSystem ({s : Set Œ± | IsOpen s}) :=
  fun _s hs _t ht _ => IsOpen.inter hs ht

lemma isPiSystem_isClosed [TopologicalSpace Œ±] : IsPiSystem ({s : Set Œ± | IsClosed s}) :=
  fun _s hs _t ht _ ‚Ü¶ IsClosed.inter hs ht

theorem borel_eq_generateFrom_isClosed [TopologicalSpace Œ±] :
    borel Œ± = .generateFrom { s | IsClosed s } :=
  le_antisymm
    (generateFrom_le fun _t ht =>
      @MeasurableSet.of_compl Œ± _ (generateFrom { s | IsClosed s })
        (GenerateMeasurable.basic _ <| isClosed_compl_iff.2 ht))
    (generateFrom_le fun _t ht =>
      @MeasurableSet.of_compl Œ± _ (borel Œ±) (GenerateMeasurable.basic _ <| isOpen_compl_iff.2 ht))

theorem borel_comap {f : Œ± ‚Üí Œ≤} {t : TopologicalSpace Œ≤} :
    @borel Œ± (t.induced f) = (@borel Œ≤ t).comap f :=
  comap_generateFrom.symm

theorem Continuous.borel_measurable [TopologicalSpace Œ±] [TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤}
    (hf : Continuous f) : @Measurable Œ± Œ≤ (borel Œ±) (borel Œ≤) f :=
  Measurable.of_le_map <|
    generateFrom_le fun s hs => GenerateMeasurable.basic (f ‚Åª¬π' s) (hs.preimage hf)

/-- A space with `MeasurableSpace` and `TopologicalSpace` structures such that
all open sets are measurable. -/
class OpensMeasurableSpace (Œ± : Type*) [TopologicalSpace Œ±] [h : MeasurableSpace Œ±] : Prop where
  /-- Borel-measurable sets are measurable. -/
  borel_le : borel Œ± ‚â§ h

/-- A space with `MeasurableSpace` and `TopologicalSpace` structures such that
the `œÉ`-algebra of measurable sets is exactly the `œÉ`-algebra generated by open sets. -/
class BorelSpace (Œ± : Type*) [TopologicalSpace Œ±] [MeasurableSpace Œ±] : Prop where
  /-- The measurable sets are exactly the Borel-measurable sets. -/
  measurable_eq : ‚ÄπMeasurableSpace Œ±‚Ä∫ = borel Œ±

namespace Mathlib.Tactic.Borelize

open Lean Elab Term Tactic Meta

/-- The behaviour of `borelize Œ±` depends on the existing assumptions on `Œ±`.

- if `Œ±` is a topological space with instances `[MeasurableSpace Œ±] [BorelSpace Œ±]`, then
  `borelize Œ±` replaces the former instance by `borel Œ±`;
- otherwise, `borelize Œ±` adds instances `borel Œ± : MeasurableSpace Œ±` and `‚ü®rfl‚ü© : BorelSpace Œ±`.

Finally, `borelize Œ± Œ≤ Œ≥` runs `borelize Œ±; borelize Œ≤; borelize Œ≥`.
-/
syntax "borelize" (ppSpace colGt term:max)* : tactic

/-- Add instances `borel e : MeasurableSpace e` and `‚ü®rfl‚ü© : BorelSpace e`. -/
def addBorelInstance (e : Expr) : TacticM Unit := do
  let t ‚Üê Lean.Elab.Term.exprToSyntax e
  evalTactic <| ‚Üê `(tactic|
    refine_lift
      letI : MeasurableSpace $t := borel $t
      haveI : BorelSpace $t := ‚ü®rfl‚ü©
      ?_)

/-- Given a type `e`, an assumption `i : MeasurableSpace e`, and an instance `[BorelSpace e]`,
replace `i` with `borel e`. -/
def borelToRefl (e : Expr) (i : FVarId) : TacticM Unit := do
  let te ‚Üê Lean.Elab.Term.exprToSyntax e
  evalTactic <| ‚Üê `(tactic|
    have := @BorelSpace.measurable_eq $te _ _ _)
  try
    liftMetaTactic fun m => return [‚Üê subst m i]
  catch _ =>
    let et ‚Üê synthInstance (‚Üê mkAppOptM ``TopologicalSpace #[e])
    throwError m!"\
      `‚ÄπTopologicalSpace {e}‚Ä∫ := {et}\n\
      depends on\n\
      {Expr.fvar i} : MeasurableSpace {e}`\n\
      so `borelize` isn't available"
  evalTactic <| ‚Üê `(tactic|
    refine_lift
      letI : MeasurableSpace $te := borel $te
      ?_)

/-- Given a type `$t`, if there is an assumption `[i : MeasurableSpace $t]`, then try to prove
`[BorelSpace $t]` and replace `i` with `borel $t`. Otherwise, add instances
`borel $t : MeasurableSpace $t` and `‚ü®rfl‚ü© : BorelSpace $t`. -/
def borelize (t : Term) : TacticM Unit := withMainContext <| do
  let u ‚Üê mkFreshLevelMVar
  let e ‚Üê withoutRecover <| Tactic.elabTermEnsuringType t (mkSort (mkLevelSucc u))
  let i? ‚Üê findLocalDeclWithType? (‚Üê mkAppOptM ``MeasurableSpace #[e])
  i?.elim (addBorelInstance e) (borelToRefl e)

elab_rules : tactic
  | `(tactic| borelize $[$t:term]*) => t.forM borelize

end Mathlib.Tactic.Borelize

instance (priority := 100) OrderDual.opensMeasurableSpace {Œ± : Type*} [TopologicalSpace Œ±]
    [MeasurableSpace Œ±] [h : OpensMeasurableSpace Œ±] : OpensMeasurableSpace Œ±·µí·µà where
  borel_le := h.borel_le

instance (priority := 100) OrderDual.borelSpace {Œ± : Type*} [TopologicalSpace Œ±]
    [MeasurableSpace Œ±] [h : BorelSpace Œ±] : BorelSpace Œ±·µí·µà where
  measurable_eq := h.measurable_eq

/-- In a `BorelSpace` all open sets are measurable. -/
instance (priority := 100) BorelSpace.opensMeasurable {Œ± : Type*} [TopologicalSpace Œ±]
    [MeasurableSpace Œ±] [BorelSpace Œ±] : OpensMeasurableSpace Œ± :=
  ‚ü®ge_of_eq <| BorelSpace.measurable_eq‚ü©

instance Subtype.borelSpace {Œ± : Type*} [TopologicalSpace Œ±] [MeasurableSpace Œ±]
    [hŒ± : BorelSpace Œ±] (p : Œ± ‚Üí Prop) : BorelSpace (Subtype p) :=
  ‚ü®by borelize Œ±; symm; apply borel_comap‚ü©

instance Countable.instBorelSpace [Countable Œ±] [MeasurableSpace Œ±] [MeasurableSingletonClass Œ±]
    [TopologicalSpace Œ±] [DiscreteTopology Œ±] : BorelSpace Œ± := by
  have : ‚àÄ s, @MeasurableSet Œ± inferInstance s := fun s ‚Ü¶ s.to_countable.measurableSet
  have : ‚àÄ s, @MeasurableSet Œ± (borel Œ±) s := fun s ‚Ü¶ measurableSet_generateFrom (isOpen_discrete s)
  exact ‚ü®by aesop‚ü©

instance Subtype.opensMeasurableSpace {Œ± : Type*} [TopologicalSpace Œ±] [MeasurableSpace Œ±]
    [h : OpensMeasurableSpace Œ±] (p : Œ± ‚Üí Prop) : OpensMeasurableSpace (Subtype p) :=
  ‚ü®by
    rw [borel_comap]
    exact comap_mono h.1‚ü©

lemma opensMeasurableSpace_iff_forall_measurableSet
    [TopologicalSpace Œ±] [MeasurableSpace Œ±] :
    OpensMeasurableSpace Œ± ‚Üî  (‚àÄ (s : Set Œ±), IsOpen s ‚Üí MeasurableSet s) := by
  refine ‚ü®fun h s hs ‚Ü¶ ?_, fun h ‚Ü¶ ‚ü®generateFrom_le h‚ü©‚ü©
  exact OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ hs

instance (priority := 100) BorelSpace.countablyGenerated {Œ± : Type*} [TopologicalSpace Œ±]
    [MeasurableSpace Œ±] [BorelSpace Œ±] [SecondCountableTopology Œ±] : CountablyGenerated Œ± := by
  obtain ‚ü®b, bct, -, hb‚ü© := exists_countable_basis Œ±
  refine ‚ü®‚ü®b, bct, ?_‚ü©‚ü©
  borelize Œ±
  exact hb.borel_eq_generateFrom

section

variable [TopologicalSpace Œ±] [MeasurableSpace Œ±] [OpensMeasurableSpace Œ±] [TopologicalSpace Œ≤]
  [MeasurableSpace Œ≤] [OpensMeasurableSpace Œ≤] [TopologicalSpace Œ≥] [MeasurableSpace Œ≥]
  [BorelSpace Œ≥] [TopologicalSpace Œ≥‚ÇÇ] [MeasurableSpace Œ≥‚ÇÇ] [BorelSpace Œ≥‚ÇÇ] [MeasurableSpace Œ¥]

theorem IsOpen.measurableSet (h : IsOpen s) : MeasurableSet s :=
  OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ h

theorem IsOpen.nullMeasurableSet {Œº} (h : IsOpen s) : NullMeasurableSet s Œº :=
  h.measurableSet.nullMeasurableSet

open scoped Function in -- required for scoped `on` notation
@[elab_as_elim]
theorem MeasurableSet.induction_on_open {C : ‚àÄ s : Set Œ≥, MeasurableSet s ‚Üí Prop}
    (isOpen : ‚àÄ U (hU : IsOpen U), C U hU.measurableSet)
    (compl : ‚àÄ t (ht : MeasurableSet t), C t ht ‚Üí C t·∂ú ht.compl)
    (iUnion : ‚àÄ f : ‚Ñï ‚Üí Set Œ≥, Pairwise (Disjoint on f) ‚Üí ‚àÄ (hf : ‚àÄ i, MeasurableSet (f i)),
      (‚àÄ i, C (f i) (hf i)) ‚Üí C (‚ãÉ i, f i) (.iUnion hf)) :
    ‚àÄ t (ht : MeasurableSet t), C t ht := fun t ht ‚Ü¶
  MeasurableSpace.induction_on_inter BorelSpace.measurable_eq isPiSystem_isOpen
    (isOpen _ isOpen_empty) isOpen compl iUnion t ht

instance (priority := 1000) {s : Set Œ±} [h : HasCountableSeparatingOn Œ± IsOpen s] :
    CountablySeparated s := by
  rw [CountablySeparated.subtype_iff]
  exact .mono (fun _ ‚Ü¶ IsOpen.measurableSet) Subset.rfl

@[measurability]
theorem measurableSet_interior : MeasurableSet (interior s) :=
  isOpen_interior.measurableSet

theorem IsGŒ¥.measurableSet (h : IsGŒ¥ s) : MeasurableSet s := by
  rcases h with ‚ü®S, hSo, hSc, rfl‚ü©
  exact MeasurableSet.sInter hSc fun t ht => (hSo t ht).measurableSet

theorem measurableSet_of_continuousAt {Œ≤} [PseudoEMetricSpace Œ≤] (f : Œ± ‚Üí Œ≤) :
    MeasurableSet { x | ContinuousAt f x } :=
  (IsGŒ¥.setOf_continuousAt f).measurableSet

theorem IsClosed.measurableSet (h : IsClosed s) : MeasurableSet s :=
  h.isOpen_compl.measurableSet.of_compl

theorem IsClosed.nullMeasurableSet {Œº} (h : IsClosed s) : NullMeasurableSet s Œº :=
  h.measurableSet.nullMeasurableSet

theorem IsCompact.measurableSet [T2Space Œ±] (h : IsCompact s) : MeasurableSet s :=
  h.isClosed.measurableSet

theorem IsCompact.nullMeasurableSet [T2Space Œ±] {Œº} (h : IsCompact s) : NullMeasurableSet s Œº :=
  h.isClosed.nullMeasurableSet

/-- If two points are topologically inseparable,
then they can't be separated by a Borel measurable set. -/
theorem Inseparable.mem_measurableSet_iff {x y : Œ≥} (h : Inseparable x y) {s : Set Œ≥}
    (hs : MeasurableSet s) : x ‚àà s ‚Üî y ‚àà s :=
  MeasurableSet.induction_on_open (fun _ ‚Ü¶ h.mem_open_iff) (fun _ _ ‚Ü¶ Iff.not)
    (fun _ _ _ h ‚Ü¶ by simp [h]) s hs

/-- If `K` is a compact set in an R‚ÇÅ space and `s ‚äá K` is a Borel measurable superset,
then `s` includes the closure of `K` as well. -/
theorem IsCompact.closure_subset_measurableSet [R1Space Œ≥] {K s : Set Œ≥} (hK : IsCompact K)
    (hs : MeasurableSet s) (hKs : K ‚äÜ s) : closure K ‚äÜ s := by
  rw [hK.closure_eq_biUnion_inseparable, iUnion‚ÇÇ_subset_iff]
  exact fun x hx y hy ‚Ü¶ (hy.mem_measurableSet_iff hs).1 (hKs hx)

/-- In an R‚ÇÅ topological space with Borel measure `Œº`,
the measure of the closure of a compact set `K` is equal to the measure of `K`.

See also `MeasureTheory.Measure.OuterRegular.measure_closure_eq_of_isCompact`
for a version that assumes `Œº` to be outer regular
but does not assume the `œÉ`-algebra to be Borel. -/
theorem IsCompact.measure_closure [R1Space Œ≥] {K : Set Œ≥} (hK : IsCompact K) (Œº : Measure Œ≥) :
    Œº (closure K) = Œº K := by
  refine le_antisymm ?_ (measure_mono subset_closure)
  calc
    Œº (closure K) ‚â§ Œº (toMeasurable Œº K) := measure_mono <|
      hK.closure_subset_measurableSet (measurableSet_toMeasurable ..) (subset_toMeasurable ..)
    _ = Œº K := measure_toMeasurable ..

@[measurability]
theorem measurableSet_closure : MeasurableSet (closure s) :=
  isClosed_closure.measurableSet

@[measurability]
theorem measurableSet_frontier : MeasurableSet (frontier s) :=
  measurableSet_closure.diff measurableSet_interior

theorem measurable_of_isOpen {f : Œ¥ ‚Üí Œ≥} (hf : ‚àÄ s, IsOpen s ‚Üí MeasurableSet (f ‚Åª¬π' s)) :
    Measurable f := by
  rw [‚ÄπBorelSpace Œ≥‚Ä∫.measurable_eq]
  exact measurable_generateFrom hf

theorem measurable_of_isClosed {f : Œ¥ ‚Üí Œ≥} (hf : ‚àÄ s, IsClosed s ‚Üí MeasurableSet (f ‚Åª¬π' s)) :
    Measurable f := by
  apply measurable_of_isOpen; intro s hs
  rw [‚Üê MeasurableSet.compl_iff, ‚Üê preimage_compl]; apply hf; rw [isClosed_compl_iff]; exact hs

theorem measurable_of_isClosed' {f : Œ¥ ‚Üí Œ≥}
    (hf : ‚àÄ s, IsClosed s ‚Üí s.Nonempty ‚Üí s ‚â† univ ‚Üí MeasurableSet (f ‚Åª¬π' s)) : Measurable f := by
  apply measurable_of_isClosed; intro s hs
  rcases eq_empty_or_nonempty s with h1 | h1
  ¬∑ simp [h1]
  by_cases h2 : s = univ
  ¬∑ simp [h2]
  exact hf s hs h1 h2

instance nhds_isMeasurablyGenerated (a : Œ±) : (ùìù a).IsMeasurablyGenerated := by
  rw [nhds, iInf_subtype']
  refine @Filter.iInf_isMeasurablyGenerated Œ± _ _ _ fun i => ?_
  exact i.2.2.measurableSet.principal_isMeasurablyGenerated

/-- If `s` is a measurable set, then `ùìù[s] a` is a measurably generated filter for
each `a`. This cannot be an `instance` because it depends on a non-instance `hs : MeasurableSet s`.
-/
theorem MeasurableSet.nhdsWithin_isMeasurablyGenerated {s : Set Œ±} (hs : MeasurableSet s) (a : Œ±) :
    (ùìù[s] a).IsMeasurablyGenerated :=
  haveI := hs.principal_isMeasurablyGenerated
  Filter.inf_isMeasurablyGenerated _ _

instance (priority := 100) OpensMeasurableSpace.separatesPoints [T0Space Œ±] :
    SeparatesPoints Œ± := by
  rw [separatesPoints_iff]
  intro x y hxy
  apply Inseparable.eq
  rw [inseparable_iff_forall_isOpen]
  exact fun s hs => hxy _ hs.measurableSet

theorem borel_eq_top_of_countable {Œ± : Type*} [TopologicalSpace Œ±] [T0Space Œ±] [Countable Œ±] :
    borel Œ± = ‚ä§ := by
  refine top_unique fun s _ ‚Ü¶ ?_
  borelize Œ±
  exact .of_discrete

-- see Note [lower instance priority]
instance (priority := 100) OpensMeasurableSpace.toMeasurableSingletonClass [T1Space Œ±] :
    MeasurableSingletonClass Œ± :=
  ‚ü®fun _ => isClosed_singleton.measurableSet‚ü©

instance Pi.opensMeasurableSpace {Œπ : Type*} {X : Œπ ‚Üí Type*} [Countable Œπ]
    [t' : ‚àÄ i, TopologicalSpace (X i)] [‚àÄ i, MeasurableSpace (X i)]
    [‚àÄ i, SecondCountableTopology (X i)] [‚àÄ i, OpensMeasurableSpace (X i)] :
    OpensMeasurableSpace (‚àÄ i, X i) := by
  constructor
  have : Pi.topologicalSpace = .generateFrom { t | ‚àÉ (s : ‚àÄ a, Set (X a)) (i : Finset Œπ),
      (‚àÄ a ‚àà i, s a ‚àà countableBasis (X a)) ‚àß t = pi (‚Üëi) s } := by
    simp only [funext fun a => @eq_generateFrom_countableBasis (X a) _ _, pi_generateFrom_eq]
  rw [borel_eq_generateFrom_of_subbasis this]
  apply generateFrom_le
  rintro _ ‚ü®s, i, hi, rfl‚ü©
  refine MeasurableSet.pi i.countable_toSet fun a ha => IsOpen.measurableSet ?_
  rw [eq_generateFrom_countableBasis (X a)]
  exact .basic _ (hi a ha)

/-- The typeclass `SecondCountableTopologyEither Œ± Œ≤` registers the fact that at least one of
the two spaces has second countable topology. This is the right assumption to ensure that continuous
maps from `Œ±` to `Œ≤` are strongly measurable. -/
class SecondCountableTopologyEither (Œ± Œ≤ : Type*) [TopologicalSpace Œ±] [TopologicalSpace Œ≤] :
  Prop where
  /-- The projection out of `SecondCountableTopologyEither` -/
  out : SecondCountableTopology Œ± ‚à® SecondCountableTopology Œ≤

instance (priority := 100) secondCountableTopologyEither_of_left (Œ± Œ≤ : Type*) [TopologicalSpace Œ±]
    [TopologicalSpace Œ≤] [SecondCountableTopology Œ±] : SecondCountableTopologyEither Œ± Œ≤ where
  out := Or.inl (by infer_instance)

instance (priority := 100) secondCountableTopologyEither_of_right (Œ± Œ≤ : Type*)
    [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [SecondCountableTopology Œ≤] :
    SecondCountableTopologyEither Œ± Œ≤ where
  out := Or.inr (by infer_instance)

/-- If either `Œ±` or `Œ≤` has second-countable topology, then the open sets in `Œ± √ó Œ≤` belong to the
product sigma-algebra. -/
instance Prod.opensMeasurableSpace [h : SecondCountableTopologyEither Œ± Œ≤] :
    OpensMeasurableSpace (Œ± √ó Œ≤) := by
  apply opensMeasurableSpace_iff_forall_measurableSet.2 (fun s hs ‚Ü¶ ?_)
  rcases h.out with hŒ±|hŒ≤
  ¬∑ let F : Set Œ± ‚Üí Set Œ≤ := fun a ‚Ü¶ {y | ‚àÉ b, IsOpen b ‚àß y ‚àà b ‚àß a √óÀ¢ b ‚äÜ s}
    have A : ‚àÄ a, IsOpen (F a) := by
      intro a
      apply isOpen_iff_forall_mem_open.2
      rintro y ‚ü®b, b_open, yb, hb‚ü©
      exact ‚ü®b, fun z zb ‚Ü¶ ‚ü®b, b_open, zb, hb‚ü©, b_open, yb‚ü©
    have : s = ‚ãÉ a ‚àà countableBasis Œ±, a √óÀ¢ F a := by
      apply Subset.antisymm
      ¬∑ rintro ‚ü®y1, y2‚ü© hy
        rcases isOpen_prod_iff.1 hs y1 y2 hy with ‚ü®u, v, u_open, v_open, yu, yv, huv‚ü©
        obtain ‚ü®a, ha, ya, au‚ü© : ‚àÉ a ‚àà countableBasis Œ±, y1 ‚àà a ‚àß a ‚äÜ u :=
          IsTopologicalBasis.exists_subset_of_mem_open (isBasis_countableBasis Œ±) yu u_open
        simp only [mem_iUnion, mem_prod, exists_and_left, exists_prop]
        exact ‚ü®a, ya, ha, v, v_open, yv, (Set.prod_mono_left au).trans huv‚ü©
      ¬∑ rintro ‚ü®y1, y2‚ü© hy
        simp only [mem_iUnion, mem_prod, exists_and_left, exists_prop] at hy
        rcases hy with ‚ü®a, ya, -, b, -, yb, hb‚ü©
        exact hb (mem_prod.2 ‚ü®ya, yb‚ü©)
    rw [this]
    apply MeasurableSet.biUnion (countable_countableBasis Œ±) (fun a ha ‚Ü¶ ?_)
    exact (isOpen_of_mem_countableBasis ha).measurableSet.prod (A a).measurableSet
  ¬∑ let F : Set Œ≤ ‚Üí Set Œ± := fun a ‚Ü¶ {y | ‚àÉ b, IsOpen b ‚àß y ‚àà b ‚àß b √óÀ¢ a ‚äÜ s}
    have A : ‚àÄ a, IsOpen (F a) := by
      intro a
      apply isOpen_iff_forall_mem_open.2
      rintro y ‚ü®b, b_open, yb, hb‚ü©
      exact ‚ü®b, fun z zb ‚Ü¶ ‚ü®b, b_open, zb, hb‚ü©, b_open, yb‚ü©
    have : s = ‚ãÉ a ‚àà countableBasis Œ≤, F a √óÀ¢ a := by
      apply Subset.antisymm
      ¬∑ rintro ‚ü®y1, y2‚ü© hy
        rcases isOpen_prod_iff.1 hs y1 y2 hy with ‚ü®u, v, u_open, v_open, yu, yv, huv‚ü©
        obtain ‚ü®a, ha, ya, au‚ü© : ‚àÉ a ‚àà countableBasis Œ≤, y2 ‚àà a ‚àß a ‚äÜ v :=
          IsTopologicalBasis.exists_subset_of_mem_open (isBasis_countableBasis Œ≤) yv v_open
        simp only [mem_iUnion, mem_prod, exists_and_left, exists_prop]
        exact ‚ü®a, ‚ü®u, u_open, yu, (Set.prod_mono_right au).trans huv‚ü©, ha, ya‚ü©
      ¬∑ rintro ‚ü®y1, y2‚ü© hy
        simp only [mem_iUnion, mem_prod, exists_and_left, exists_prop] at hy
        rcases hy with ‚ü®a, ‚ü®b, -, yb, hb‚ü©, -, ya‚ü©
        exact hb (mem_prod.2 ‚ü®yb, ya‚ü©)
    rw [this]
    apply MeasurableSet.biUnion (countable_countableBasis Œ≤) (fun a ha ‚Ü¶ ?_)
    exact (A a).measurableSet.prod (isOpen_of_mem_countableBasis ha).measurableSet

variable {Œ±' : Type*} [TopologicalSpace Œ±'] [MeasurableSpace Œ±']

theorem interior_ae_eq_of_null_frontier {Œº : Measure Œ±'} {s : Set Œ±'} (h : Œº (frontier s) = 0) :
    interior s =·µê[Œº] s :=
  interior_subset.eventuallyLE.antisymm <| subset_closure.eventuallyLE.trans (ae_le_set.2 h)

theorem measure_interior_of_null_frontier {Œº : Measure Œ±'} {s : Set Œ±'} (h : Œº (frontier s) = 0) :
    Œº (interior s) = Œº s :=
  measure_congr (interior_ae_eq_of_null_frontier h)

theorem nullMeasurableSet_of_null_frontier {s : Set Œ±} {Œº : Measure Œ±} (h : Œº (frontier s) = 0) :
    NullMeasurableSet s Œº :=
  ‚ü®interior s, isOpen_interior.measurableSet, (interior_ae_eq_of_null_frontier h).symm‚ü©

theorem closure_ae_eq_of_null_frontier {Œº : Measure Œ±'} {s : Set Œ±'} (h : Œº (frontier s) = 0) :
    closure s =·µê[Œº] s :=
  ((ae_le_set.2 h).trans interior_subset.eventuallyLE).antisymm <| subset_closure.eventuallyLE

theorem measure_closure_of_null_frontier {Œº : Measure Œ±'} {s : Set Œ±'} (h : Œº (frontier s) = 0) :
    Œº (closure s) = Œº s :=
  measure_congr (closure_ae_eq_of_null_frontier h)

theorem null_frontier_inter {Œº : Measure Œ±'} {s s' : Set Œ±'}
    (h : Œº (frontier s) = 0) (h' : Œº (frontier s') = 0) :
    Œº (frontier (s ‚à© s')) = 0 := by
  apply bot_unique
  calc Œº (frontier (s ‚à© s'))
  _ ‚â§ Œº (frontier s ‚à™ frontier s') := measure_mono <| (frontier_inter_subset _ _).trans (by grind)
  _ ‚â§ Œº (frontier s) + Œº (frontier s') := measure_union_le _ _
  _ = 0 := by simp [h, h']

instance separatesPointsOfOpensMeasurableSpaceOfT0Space [T0Space Œ±] :
    MeasurableSpace.SeparatesPoints Œ± where
  separates x y := by
    contrapose!
    exact fun a => exists_measurableSet_of_ne a

/-- A continuous function from an `OpensMeasurableSpace` to a `BorelSpace`
is measurable. -/
@[fun_prop]
theorem Continuous.measurable {f : Œ± ‚Üí Œ≥} (hf : Continuous f) : Measurable f :=
  hf.borel_measurable.mono OpensMeasurableSpace.borel_le (le_of_eq <| BorelSpace.measurable_eq)

/-- A continuous function from an `OpensMeasurableSpace` to a `BorelSpace`
is ae-measurable. -/
@[fun_prop]
theorem Continuous.aemeasurable {f : Œ± ‚Üí Œ≥} (h : Continuous f) {Œº : Measure Œ±} : AEMeasurable f Œº :=
  h.measurable.aemeasurable

theorem IsClosedEmbedding.measurable {f : Œ± ‚Üí Œ≥} (hf : IsClosedEmbedding f) : Measurable f :=
  hf.continuous.measurable

/-- If a function is defined piecewise in terms of functions which are continuous on their
respective pieces, then it is measurable. -/
theorem ContinuousOn.measurable_piecewise {f g : Œ± ‚Üí Œ≥} {s : Set Œ±} [‚àÄ j : Œ±, Decidable (j ‚àà s)]
    (hf : ContinuousOn f s) (hg : ContinuousOn g s·∂ú) (hs : MeasurableSet s) :
    Measurable (s.piecewise f g) := by
  refine measurable_of_isOpen fun t ht => ?_
  rw [piecewise_preimage, Set.ite]
  apply MeasurableSet.union
  ¬∑ rcases _root_.continuousOn_iff'.1 hf t ht with ‚ü®u, u_open, hu‚ü©
    rw [hu]
    exact u_open.measurableSet.inter hs
  ¬∑ rcases _root_.continuousOn_iff'.1 hg t ht with ‚ü®u, u_open, hu‚ü©
    rw [diff_eq_compl_inter, inter_comm, hu]
    exact u_open.measurableSet.inter hs.compl

@[to_additive]
instance (priority := 100) ContinuousMul.measurableMul [Mul Œ≥] [ContinuousMul Œ≥] :
    MeasurableMul Œ≥ where
  measurable_const_mul _ := (continuous_const.mul continuous_id).measurable
  measurable_mul_const _ := (continuous_id.mul continuous_const).measurable

instance (priority := 100) ContinuousSub.measurableSub [Sub Œ≥] [ContinuousSub Œ≥] :
    MeasurableSub Œ≥ where
  measurable_const_sub _ := (continuous_const.sub continuous_id).measurable
  measurable_sub_const _ := (continuous_id.sub continuous_const).measurable

@[to_additive]
instance (priority := 100) ContinuousInv.measurableInv [Inv Œ≥] [ContinuousInv Œ≥] :
    MeasurableInv Œ≥ := ‚ü®continuous_inv.measurable‚ü©

@[to_additive]
instance (priority := 100) ContinuousConstSMul.toMeasurableConstSMul {M Œ±} [TopologicalSpace Œ±]
    [MeasurableSpace Œ±] [BorelSpace Œ±] [SMul M Œ±] [ContinuousConstSMul M Œ±] :
    MeasurableConstSMul M Œ± where
  measurable_const_smul _ := (continuous_const_smul _).measurable

@[to_additive]
instance (priority := 100) ContinuousSMul.toMeasurableSMul {M Œ±} [TopologicalSpace M]
    [TopologicalSpace Œ±] [MeasurableSpace M] [MeasurableSpace Œ±] [OpensMeasurableSpace M]
    [BorelSpace Œ±] [SMul M Œ±] [ContinuousSMul M Œ±] : MeasurableSMul M Œ± where
  measurable_smul_const _ := (continuous_id.smul continuous_const).measurable

section Homeomorph

@[measurability]
protected theorem Homeomorph.measurable (h : Œ± ‚âÉ‚Çú Œ≥) : Measurable h :=
  h.continuous.measurable

/-- A homeomorphism between two Borel spaces is a measurable equivalence. -/
def Homeomorph.toMeasurableEquiv (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : Œ≥ ‚âÉ·µê Œ≥‚ÇÇ where
  measurable_toFun := h.measurable
  measurable_invFun := h.symm.measurable
  toEquiv := h.toEquiv

lemma Homeomorph.measurableEmbedding (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : MeasurableEmbedding h :=
  h.toMeasurableEquiv.measurableEmbedding

@[simp]
theorem Homeomorph.toMeasurableEquiv_coe (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : (h.toMeasurableEquiv : Œ≥ ‚Üí Œ≥‚ÇÇ) = h :=
  rfl

@[simp]
theorem Homeomorph.toMeasurableEquiv_symm_coe (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) :
    (h.toMeasurableEquiv.symm : Œ≥‚ÇÇ ‚Üí Œ≥) = h.symm :=
  rfl

end Homeomorph

@[measurability]
theorem ContinuousMap.measurable (f : C(Œ±, Œ≥)) : Measurable f :=
  f.continuous.measurable

@[fun_prop]
theorem measurable_of_continuousOn_compl_singleton [T1Space Œ±] {f : Œ± ‚Üí Œ≥} (a : Œ±)
    (hf : ContinuousOn f {a}·∂ú) : Measurable f :=
  measurable_of_measurable_on_compl_singleton a
    (continuousOn_iff_continuous_restrict.1 hf).measurable

theorem Continuous.measurable2 [SecondCountableTopologyEither Œ± Œ≤] {f : Œ¥ ‚Üí Œ±}
    {g : Œ¥ ‚Üí Œ≤} {c : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (h : Continuous fun p : Œ± √ó Œ≤ => c p.1 p.2) (hf : Measurable f)
    (hg : Measurable g) : Measurable fun a => c (f a) (g a) :=
  h.measurable.comp (hf.prodMk hg)

theorem Continuous.aemeasurable2 [SecondCountableTopologyEither Œ± Œ≤]
    {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ≤} {c : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {Œº : Measure Œ¥}
    (h : Continuous fun p : Œ± √ó Œ≤ => c p.1 p.2) (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    AEMeasurable (fun a => c (f a) (g a)) Œº :=
  h.measurable.comp_aemeasurable (hf.prodMk hg)

instance (priority := 100) HasContinuousInv‚ÇÄ.measurableInv [GroupWithZero Œ≥] [T1Space Œ≥]
    [HasContinuousInv‚ÇÄ Œ≥] : MeasurableInv Œ≥ :=
  ‚ü®measurable_of_continuousOn_compl_singleton 0 continuousOn_inv‚ÇÄ‚ü©

@[to_additive]
instance (priority := 100) ContinuousMul.measurableMul‚ÇÇ [SecondCountableTopology Œ≥] [Mul Œ≥]
    [ContinuousMul Œ≥] : MeasurableMul‚ÇÇ Œ≥ :=
  ‚ü®continuous_mul.measurable‚ü©

instance (priority := 100) ContinuousSub.measurableSub‚ÇÇ [SecondCountableTopology Œ≥] [Sub Œ≥]
    [ContinuousSub Œ≥] : MeasurableSub‚ÇÇ Œ≥ :=
  ‚ü®continuous_sub.measurable‚ü©

instance (priority := 100) ContinuousSMul.measurableSMul‚ÇÇ {M Œ±} [TopologicalSpace M]
    [MeasurableSpace M] [OpensMeasurableSpace M] [TopologicalSpace Œ±]
    [SecondCountableTopologyEither M Œ±] [MeasurableSpace Œ±] [BorelSpace Œ±] [SMul M Œ±]
    [ContinuousSMul M Œ±] : MeasurableSMul‚ÇÇ M Œ± :=
  ‚ü®continuous_smul.measurable‚ü©

end

section BorelSpace

variable [TopologicalSpace Œ±] [mŒ± : MeasurableSpace Œ±] [BorelSpace Œ±] [mŒ≤ : TopologicalSpace Œ≤]
  [MeasurableSpace Œ≤] [BorelSpace Œ≤] [TopologicalSpace Œ≥] [MeasurableSpace Œ≥] [BorelSpace Œ≥]
  [MeasurableSpace Œ¥]

theorem pi_le_borel_pi {Œπ : Type*} {X : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (X i)]
    [‚àÄ i, MeasurableSpace (X i)] [‚àÄ i, BorelSpace (X i)] :
      MeasurableSpace.pi ‚â§ borel (‚àÄ i, X i) := by
  have : ‚Äπ‚àÄ i, MeasurableSpace (X i)‚Ä∫ = fun i => borel (X i) :=
    funext fun i => BorelSpace.measurable_eq
  rw [this]
  exact iSup_le fun i => comap_le_iff_le_map.2 <| (continuous_apply i).borel_measurable

theorem prod_le_borel_prod : Prod.instMeasurableSpace ‚â§ borel (Œ± √ó Œ≤) := by
  rw [‚ÄπBorelSpace Œ±‚Ä∫.measurable_eq, ‚ÄπBorelSpace Œ≤‚Ä∫.measurable_eq]
  refine sup_le ?_ ?_
  ¬∑ exact comap_le_iff_le_map.mpr continuous_fst.borel_measurable
  ¬∑ exact comap_le_iff_le_map.mpr continuous_snd.borel_measurable

instance Pi.borelSpace {Œπ : Type*} {X : Œπ ‚Üí Type*} [Countable Œπ] [‚àÄ i, TopologicalSpace (X i)]
    [‚àÄ i, MeasurableSpace (X i)] [‚àÄ i, SecondCountableTopology (X i)] [‚àÄ i, BorelSpace (X i)] :
    BorelSpace (‚àÄ i, X i) :=
  ‚ü®le_antisymm pi_le_borel_pi OpensMeasurableSpace.borel_le‚ü©

instance Prod.borelSpace [SecondCountableTopologyEither Œ± Œ≤] :
    BorelSpace (Œ± √ó Œ≤) :=
  ‚ü®le_antisymm prod_le_borel_prod OpensMeasurableSpace.borel_le‚ü©

/-- Given a measurable embedding to a Borel space which is also a topological embedding, then the
source space is also a Borel space. -/
lemma MeasurableEmbedding.borelSpace {Œ± Œ≤ : Type*} [MeasurableSpace Œ±] [TopologicalSpace Œ±]
    [MeasurableSpace Œ≤] [TopologicalSpace Œ≤] [hŒ≤ : BorelSpace Œ≤] {e : Œ± ‚Üí Œ≤}
    (h'e : MeasurableEmbedding e) (h''e : IsInducing e) :
    BorelSpace Œ± := by
  constructor
  have : MeasurableSpace.comap e (borel Œ≤) = ‚Äπ_‚Ä∫ := by simpa [hŒ≤.measurable_eq] using h'e.comap_eq
  rw [‚Üê this, ‚Üê borel_comap, h''e.eq_induced]

instance _root_.ULift.instBorelSpace : BorelSpace (ULift Œ±) :=
  MeasurableEquiv.ulift.measurableEmbedding.borelSpace Homeomorph.ulift.isInducing

instance DiscreteMeasurableSpace.toBorelSpace {Œ± : Type*} [TopologicalSpace Œ±] [DiscreteTopology Œ±]
    [MeasurableSpace Œ±] [DiscreteMeasurableSpace Œ±] : BorelSpace Œ± := by
  constructor; ext; simp [MeasurableSpace.measurableSet_generateFrom, MeasurableSet.of_discrete]

protected theorem Topology.IsEmbedding.measurableEmbedding {f : Œ± ‚Üí Œ≤} (h‚ÇÅ : IsEmbedding f)
    (h‚ÇÇ : MeasurableSet (range f)) : MeasurableEmbedding f :=
  show MeasurableEmbedding
      (((‚Üë) : range f ‚Üí Œ≤) ‚àò h‚ÇÅ.toHomeomorph.toMeasurableEquiv) from
    (MeasurableEmbedding.subtype_coe h‚ÇÇ).comp (MeasurableEquiv.measurableEmbedding _)

protected theorem Topology.IsClosedEmbedding.measurableEmbedding {f : Œ± ‚Üí Œ≤}
    (h : IsClosedEmbedding f) : MeasurableEmbedding f :=
  h.isEmbedding.measurableEmbedding h.isClosed_range.measurableSet

protected theorem Topology.IsOpenEmbedding.measurableEmbedding {f : Œ± ‚Üí Œ≤} (h : IsOpenEmbedding f) :
    MeasurableEmbedding f :=
  h.isEmbedding.measurableEmbedding h.isOpen_range.measurableSet

instance Empty.borelSpace : BorelSpace Empty :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©

instance Unit.borelSpace : BorelSpace Unit :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©

instance Bool.borelSpace : BorelSpace Bool :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©

instance Nat.borelSpace : BorelSpace ‚Ñï :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©

instance Int.borelSpace : BorelSpace ‚Ñ§ :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©

instance Rat.borelSpace : BorelSpace ‚Ñö :=
  ‚ü®borel_eq_top_of_countable.symm‚ü©

/- Instances on `Real` and `Complex` are special cases of `RCLike` but without these instances,
Lean fails to prove `BorelSpace (Œπ ‚Üí ‚Ñù)`, so we leave them here. -/
instance Real.measurableSpace : MeasurableSpace ‚Ñù :=
  borel ‚Ñù

instance Real.borelSpace : BorelSpace ‚Ñù :=
  ‚ü®rfl‚ü©

instance NNReal.measurableSpace : MeasurableSpace ‚Ñù‚â•0 :=
  Subtype.instMeasurableSpace

instance NNReal.borelSpace : BorelSpace ‚Ñù‚â•0 :=
  Subtype.borelSpace _

instance ENNReal.measurableSpace : MeasurableSpace ‚Ñù‚â•0‚àû :=
  borel ‚Ñù‚â•0‚àû

instance ENNReal.borelSpace : BorelSpace ‚Ñù‚â•0‚àû :=
  ‚ü®rfl‚ü©

instance EReal.measurableSpace : MeasurableSpace EReal :=
  borel EReal

instance EReal.borelSpace : BorelSpace EReal :=
  ‚ü®rfl‚ü©

namespace MeasureTheory.Measure.IsFiniteMeasureOnCompacts

variable {mŒ±} in
protected theorem map (Œº : Measure Œ±) [IsFiniteMeasureOnCompacts Œº] (f : Œ± ‚âÉ‚Çú Œ≤) :
    IsFiniteMeasureOnCompacts (Œº.map f) := by
  refine ‚ü®fun K hK ‚Ü¶ ?_‚ü©
  rw [‚Üê f.toMeasurableEquiv_coe, MeasurableEquiv.map_apply]
  exact IsCompact.measure_lt_top (f.isCompact_preimage.2 hK)

variable {mŒ≤} in
protected theorem comap (Œº : Measure Œ≤) [IsFiniteMeasureOnCompacts Œº] (f : Œ± ‚âÉ‚Çú Œ≤) :
    IsFiniteMeasureOnCompacts (Œº.comap f) :=
  IsFiniteMeasureOnCompacts.comap' Œº f.continuous f.measurableEmbedding

end MeasureTheory.Measure.IsFiniteMeasureOnCompacts

end BorelSpace
