/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Yury Kudryashov
-/
import Mathlib.Analysis.Normed.Group.Basic
import Mathlib.MeasureTheory.Function.AEMeasurableSequence
import Mathlib.MeasureTheory.Group.Arithmetic
import Mathlib.MeasureTheory.Lattice
import Mathlib.Topology.Algebra.Order.LiminfLimsup
import Mathlib.Topology.ContinuousFunction.Basic
import Mathlib.Topology.Instances.EReal
import Mathlib.Topology.MetricSpace.HausdorffDistance
import Mathlib.Topology.GDelta
import Mathlib.Topology.Order.Lattice
import Mathlib.Topology.Semicontinuous

#align_import measure_theory.constructions.borel_space.basic from "leanprover-community/mathlib"@"9f55d0d4363ae59948c33864cbc52e0b12e0e8ce"

/-!
# Borel (measurable) space

## Main definitions

* `borel Œ±` : the least `œÉ`-algebra that contains all open sets;
* `class BorelSpace` : a space with `TopologicalSpace` and `MeasurableSpace` structures
  such that `‚ÄπMeasurableSpace Œ±‚Ä∫ = borel Œ±`;
* `class OpensMeasurableSpace` : a space with `TopologicalSpace` and `MeasurableSpace`
  structures such that all open sets are measurable; equivalently, `borel Œ± ‚â§ ‚ÄπMeasurableSpace Œ±‚Ä∫`.
* `BorelSpace` instances on `Empty`, `Unit`, `Bool`, `Nat`, `Int`, `Rat`;
* `MeasurableSpace` and `BorelSpace` instances on `‚Ñù`, `‚Ñù‚â•0`, `‚Ñù‚â•0‚àû`.

## Main statements

* `IsOpen.measurableSet`, `IsClosed.measurableSet`: open and closed sets are measurable;
* `Continuous.measurable` : a continuous function is measurable;
* `Continuous.measurable2` : if `f : Œ± ‚Üí Œ≤` and `g : Œ± ‚Üí Œ≥` are measurable and `op : Œ≤ √ó Œ≥ ‚Üí Œ¥`
  is continuous, then `fun x => op (f x, g y)` is measurable;
* `Measurable.add` etc : dot notation for arithmetic operations on `Measurable` predicates,
  and similarly for `dist` and `edist`;
* `AEMeasurable.add` : similar dot notation for almost everywhere measurable functions;
* `Measurable.ennreal*` : special cases for arithmetic operations on `‚Ñù‚â•0‚àû`.
-/


noncomputable section

open Classical Set Filter MeasureTheory

open Classical BigOperators Topology NNReal ENNReal MeasureTheory

universe u v w x y

variable {Œ± Œ≤ Œ≥ Œ≥‚ÇÇ Œ¥ : Type*} {Œπ : Sort y} {s t u : Set Œ±}

open MeasurableSpace TopologicalSpace

/-- `MeasurableSpace` structure generated by `TopologicalSpace`. -/
def borel (Œ± : Type u) [TopologicalSpace Œ±] : MeasurableSpace Œ± :=
  generateFrom { s : Set Œ± | IsOpen s }

theorem borel_anti : Antitone (@borel Œ±) := fun _ _ h =>
  MeasurableSpace.generateFrom_le fun _ hs => .basic _ (h _ hs)

theorem borel_eq_top_of_discrete [TopologicalSpace Œ±] [DiscreteTopology Œ±] : borel Œ± = ‚ä§ :=
  top_le_iff.1 fun s _ => GenerateMeasurable.basic s (isOpen_discrete s)

theorem borel_eq_top_of_countable [TopologicalSpace Œ±] [T1Space Œ±] [Countable Œ±] : borel Œ± = ‚ä§ := by
  refine' top_le_iff.1 fun s _ => biUnion_of_singleton s ‚ñ∏ _
  apply MeasurableSet.biUnion s.to_countable
  intro x _
  apply MeasurableSet.of_compl
  apply GenerateMeasurable.basic
  exact isClosed_singleton.isOpen_compl

theorem borel_eq_generateFrom_of_subbasis {s : Set (Set Œ±)} [t : TopologicalSpace Œ±]
    [SecondCountableTopology Œ±] (hs : t = .generateFrom s) : borel Œ± = .generateFrom s :=
  le_antisymm
    (generateFrom_le fun u (hu : t.IsOpen u) => by
      rw [hs] at hu
      induction hu
      case basic u hu => exact GenerateMeasurable.basic u hu
      case univ => exact @MeasurableSet.univ Œ± (generateFrom s)
      case inter s‚ÇÅ s‚ÇÇ _ _ hs‚ÇÅ hs‚ÇÇ => exact @MeasurableSet.inter Œ± (generateFrom s) _ _ hs‚ÇÅ hs‚ÇÇ
      case
        sUnion f hf ih =>
        rcases isOpen_sUnion_countable f (by rwa [hs]) with ‚ü®v, hv, vf, vu‚ü©
        rw [‚Üê vu]
        exact @MeasurableSet.sUnion Œ± (generateFrom s) _ hv fun x xv => ih _ (vf xv))
    (generateFrom_le fun u hu =>
      GenerateMeasurable.basic _ <| show t.IsOpen u by rw [hs]; exact GenerateOpen.basic _ hu)

theorem TopologicalSpace.IsTopologicalBasis.borel_eq_generateFrom [TopologicalSpace Œ±]
    [SecondCountableTopology Œ±] {s : Set (Set Œ±)} (hs : IsTopologicalBasis s) :
    borel Œ± = .generateFrom s :=
  borel_eq_generateFrom_of_subbasis hs.eq_generateFrom

theorem isPiSystem_isOpen [TopologicalSpace Œ±] : IsPiSystem (IsOpen : Set Œ± ‚Üí Prop) :=
  fun _s hs _t ht _ => IsOpen.inter hs ht

theorem borel_eq_generateFrom_isClosed [TopologicalSpace Œ±] :
    borel Œ± = .generateFrom { s | IsClosed s } :=
  le_antisymm
    (generateFrom_le fun _t ht =>
      @MeasurableSet.of_compl Œ± _ (generateFrom { s | IsClosed s })
        (GenerateMeasurable.basic _ <| isClosed_compl_iff.2 ht))
    (generateFrom_le fun _t ht =>
      @MeasurableSet.of_compl Œ± _ (borel Œ±) (GenerateMeasurable.basic _ <| isOpen_compl_iff.2 ht))

section OrderTopology

variable (Œ±)

variable [TopologicalSpace Œ±] [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±]

theorem borel_eq_generateFrom_Iio : borel Œ± = .generateFrom (range Iio) := by
  refine' le_antisymm _ (generateFrom_le _)
  ¬∑ rw [borel_eq_generateFrom_of_subbasis (@OrderTopology.topology_eq_generate_intervals Œ± _ _ _)]
    letI : MeasurableSpace Œ± := MeasurableSpace.generateFrom (range Iio)
    have H : ‚àÄ a : Œ±, MeasurableSet (Iio a) := fun a => GenerateMeasurable.basic _ ‚ü®_, rfl‚ü©
    refine' generateFrom_le _
    rintro _ ‚ü®a, rfl | rfl‚ü© <;> [skip; apply H]
    by_cases h : ‚àÉ a', ‚àÄ b, a < b ‚Üî a' ‚â§ b
    ¬∑ rcases h with ‚ü®a', ha'‚ü©
      rw [(_ : Ioi a = (Iio a')·∂ú)]
      ¬∑ exact (H _).compl
      simp [Set.ext_iff, ha']
    ¬∑ rcases isOpen_iUnion_countable (fun a' : { a' : Œ± // a < a' } => { b | a'.1 < b }) fun a' =>
          isOpen_lt' _ with ‚ü®v, ‚ü®hv‚ü©, vu‚ü©
      simp [Set.ext_iff] at vu
      have : Ioi a = ‚ãÉ x : v, (Iio x.1.1)·∂ú := by
        simp only [compl_Iio, iUnion_coe_set, Set.ext_iff, mem_Ioi, mem_iUnion, mem_Ici,
          exists_prop, Subtype.exists, exists_and_right]
        refine' fun x => ‚ü®fun ax => _, fun ‚ü®a', ‚ü®h, _‚ü©, ax‚ü© => lt_of_lt_of_le h ax‚ü©
        rcases (vu x).2 (by
          refine' not_imp_comm.1 (fun h => _) h
          exact ‚ü®x, fun b =>
            ‚ü®fun ab => le_of_not_lt fun h' => h ‚ü®b, ab, h'‚ü©, lt_of_lt_of_le ax‚ü©‚ü©) with ‚ü®a', h‚ÇÅ, h‚ÇÇ‚ü©
        ¬∑ exact ‚ü®a', h‚ÇÅ, le_of_lt h‚ÇÇ‚ü©
      rw [this]
      skip
      apply MeasurableSet.iUnion
      exact fun _ => (H _).compl
  ¬∑ rw [forall_range_iff]
    intro a
    exact GenerateMeasurable.basic _ isOpen_Iio

theorem borel_eq_generateFrom_Ioi : borel Œ± = .generateFrom (range Ioi) :=
  @borel_eq_generateFrom_Iio Œ±·µí·µà _ (by infer_instance : SecondCountableTopology Œ±) _ _

theorem borel_eq_generateFrom_Iic :
    borel Œ± = MeasurableSpace.generateFrom (range Iic) := by
  rw [borel_eq_generateFrom_Ioi]
  refine' le_antisymm _ _
  ¬∑ refine' MeasurableSpace.generateFrom_le fun t ht => _
    obtain ‚ü®u, rfl‚ü© := ht
    rw [‚Üê compl_Iic]
    exact (MeasurableSpace.measurableSet_generateFrom (mem_range.mpr ‚ü®u, rfl‚ü©)).compl
  ¬∑ refine' MeasurableSpace.generateFrom_le fun t ht => _
    obtain ‚ü®u, rfl‚ü© := ht
    rw [‚Üê compl_Ioi]
    exact (MeasurableSpace.measurableSet_generateFrom (mem_range.mpr ‚ü®u, rfl‚ü©)).compl

theorem borel_eq_generateFrom_Ici : borel Œ± = MeasurableSpace.generateFrom (range Ici) :=
  @borel_eq_generateFrom_Iic Œ±·µí·µà _ _ _ _

end OrderTopology

theorem borel_comap {f : Œ± ‚Üí Œ≤} {t : TopologicalSpace Œ≤} :
    @borel Œ± (t.induced f) = (@borel Œ≤ t).comap f :=
  comap_generateFrom.symm

theorem Continuous.borel_measurable [TopologicalSpace Œ±] [TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤}
    (hf : Continuous f) : @Measurable Œ± Œ≤ (borel Œ±) (borel Œ≤) f :=
  Measurable.of_le_map <|
    generateFrom_le fun s hs => GenerateMeasurable.basic (f ‚Åª¬π' s) (hs.preimage hf)

/-- A space with `MeasurableSpace` and `TopologicalSpace` structures such that
all open sets are measurable. -/
class OpensMeasurableSpace (Œ± : Type*) [TopologicalSpace Œ±] [h : MeasurableSpace Œ±] : Prop where
  /-- Borel-measurable sets are measurable. -/
  borel_le : borel Œ± ‚â§ h

/-- A space with `MeasurableSpace` and `TopologicalSpace` structures such that
the `œÉ`-algebra of measurable sets is exactly the `œÉ`-algebra generated by open sets. -/
class BorelSpace (Œ± : Type*) [TopologicalSpace Œ±] [MeasurableSpace Œ±] : Prop where
  /-- The measurable sets are exactly the Borel-measurable sets. -/
  measurable_eq : ‚ÄπMeasurableSpace Œ±‚Ä∫ = borel Œ±

namespace Mathlib.Tactic.Borelize

open Lean Elab Term Tactic Meta

/-- The behaviour of `borelize Œ±` depends on the existing assumptions on `Œ±`.

- if `Œ±` is a topological space with instances `[MeasurableSpace Œ±] [BorelSpace Œ±]`, then
  `borelize Œ±` replaces the former instance by `borel Œ±`;
- otherwise, `borelize Œ±` adds instances `borel Œ± : MeasurableSpace Œ±` and `‚ü®rfl‚ü© : BorelSpace Œ±`.

Finally, `borelize Œ± Œ≤ Œ≥` runs `borelize Œ±; borelize Œ≤; borelize Œ≥`.
-/
syntax "borelize" (ppSpace colGt term:max)* : tactic

/-- Add instances `borel e : MeasurableSpace e` and `‚ü®rfl‚ü© : BorelSpace e`. -/
def addBorelInstance (e : Expr) : TacticM Unit := do
  let t ‚Üê Lean.Elab.Term.exprToSyntax e
  evalTactic <| ‚Üê `(tactic|
    refine_lift
      letI : MeasurableSpace $t := borel $t
      haveI : BorelSpace $t := ‚ü®rfl‚ü©
      ?_)

/-- Given a type `e`, an assumption `i : MeasurableSpace e`, and an instance `[BorelSpace e]`,
replace `i` with `borel e`. -/
def borelToRefl (e : Expr) (i : FVarId) : TacticM Unit := do
  let te ‚Üê Lean.Elab.Term.exprToSyntax e
  evalTactic <| ‚Üê `(tactic|
    have := @BorelSpace.measurable_eq $te _ _ _)
  try
    liftMetaTactic fun m => return [‚Üê subst m i]
  catch _ =>
    let et ‚Üê synthInstance (‚Üê mkAppOptM ``TopologicalSpace #[e])
    throwError
      (m!"`‚ÄπTopologicalSpace {e}‚Ä∫ := {et}" ++ MessageData.ofFormat Format.line ++
        m!"depends on" ++ MessageData.ofFormat Format.line ++
        m!"{Expr.fvar i} : MeasurableSpace {e}`" ++ MessageData.ofFormat Format.line ++
        "so `borelize` isn't avaliable")
  evalTactic <| ‚Üê `(tactic|
    refine_lift
      letI : MeasurableSpace $te := borel $te
      ?_)

/-- Given a type `$t`, if there is an assumption `[i : MeasurableSpace $t]`, then try to prove
`[BorelSpace $t]` and replace `i` with `borel $t`. Otherwise, add instances
`borel $t : MeasurableSpace $t` and `‚ü®rfl‚ü© : BorelSpace $t`. -/
def borelize (t : Term) : TacticM Unit := withMainContext <| do
  let u ‚Üê mkFreshLevelMVar
  let e ‚Üê withoutRecover <| Tactic.elabTermEnsuringType t (mkSort (mkLevelSucc u))
  let i? ‚Üê findLocalDeclWithType? (‚Üê mkAppOptM ``MeasurableSpace #[e])
  i?.elim (addBorelInstance e) (borelToRefl e)

elab_rules : tactic
  | `(tactic| borelize $[$t:term]*) => t.forM borelize

end Mathlib.Tactic.Borelize

instance (priority := 100) OrderDual.opensMeasurableSpace {Œ± : Type*} [TopologicalSpace Œ±]
    [MeasurableSpace Œ±] [h : OpensMeasurableSpace Œ±] : OpensMeasurableSpace Œ±·µí·µà where
  borel_le := h.borel_le

instance (priority := 100) OrderDual.borelSpace {Œ± : Type*} [TopologicalSpace Œ±]
    [MeasurableSpace Œ±] [h : BorelSpace Œ±] : BorelSpace Œ±·µí·µà where
  measurable_eq := h.measurable_eq

/-- In a `BorelSpace` all open sets are measurable. -/
instance (priority := 100) BorelSpace.opensMeasurable {Œ± : Type*} [TopologicalSpace Œ±]
    [MeasurableSpace Œ±] [BorelSpace Œ±] : OpensMeasurableSpace Œ± :=
  ‚ü®ge_of_eq <| BorelSpace.measurable_eq‚ü©

instance Subtype.borelSpace {Œ± : Type*} [TopologicalSpace Œ±] [MeasurableSpace Œ±]
    [hŒ± : BorelSpace Œ±] (s : Set Œ±) : BorelSpace s :=
  ‚ü®by borelize Œ±; symm; apply borel_comap‚ü©

instance Subtype.opensMeasurableSpace {Œ± : Type*} [TopologicalSpace Œ±] [MeasurableSpace Œ±]
    [h : OpensMeasurableSpace Œ±] (s : Set Œ±) : OpensMeasurableSpace s :=
  ‚ü®by
    rw [borel_comap]
    exact comap_mono h.1‚ü©

lemma opensMeasurableSpace_iff_forall_measurableSet
    [TopologicalSpace Œ±] [MeasurableSpace Œ±] :
    OpensMeasurableSpace Œ± ‚Üî  (‚àÄ (s : Set Œ±), IsOpen s ‚Üí MeasurableSet s) := by
  refine ‚ü®fun h s hs ‚Ü¶ ?_, fun h ‚Ü¶ ‚ü®generateFrom_le h‚ü©‚ü©
  exact OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ hs

instance (priority := 100) BorelSpace.countablyGenerated {Œ± : Type*} [TopologicalSpace Œ±]
    [MeasurableSpace Œ±] [BorelSpace Œ±] [SecondCountableTopology Œ±] : CountablyGenerated Œ± := by
  obtain ‚ü®b, bct, -, hb‚ü© := exists_countable_basis Œ±
  refine' ‚ü®‚ü®b, bct, _‚ü©‚ü©
  borelize Œ±
  exact hb.borel_eq_generateFrom

theorem MeasurableSet.induction_on_open [TopologicalSpace Œ±] [MeasurableSpace Œ±] [BorelSpace Œ±]
    {C : Set Œ± ‚Üí Prop} (h_open : ‚àÄ U, IsOpen U ‚Üí C U)
    (h_compl : ‚àÄ t, MeasurableSet t ‚Üí C t ‚Üí C t·∂ú)
    (h_union :
      ‚àÄ f : ‚Ñï ‚Üí Set Œ±,
        Pairwise (Disjoint on f) ‚Üí (‚àÄ i, MeasurableSet (f i)) ‚Üí (‚àÄ i, C (f i)) ‚Üí C (‚ãÉ i, f i)) :
    ‚àÄ ‚¶Ét‚¶Ñ, MeasurableSet t ‚Üí C t :=
  MeasurableSpace.induction_on_inter BorelSpace.measurable_eq isPiSystem_isOpen
    (h_open _ isOpen_empty) h_open h_compl h_union

section

variable [TopologicalSpace Œ±] [MeasurableSpace Œ±] [OpensMeasurableSpace Œ±] [TopologicalSpace Œ≤]
  [MeasurableSpace Œ≤] [OpensMeasurableSpace Œ≤] [TopologicalSpace Œ≥] [MeasurableSpace Œ≥]
  [BorelSpace Œ≥] [TopologicalSpace Œ≥‚ÇÇ] [MeasurableSpace Œ≥‚ÇÇ] [BorelSpace Œ≥‚ÇÇ] [MeasurableSpace Œ¥]

theorem IsOpen.measurableSet (h : IsOpen s) : MeasurableSet s :=
  OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ h

instance (priority := 500) {s : Set Œ±} [HasCountableSeparatingOn Œ± IsOpen s] :
    HasCountableSeparatingOn Œ± MeasurableSet s :=
  .mono (fun _ ‚Ü¶ IsOpen.measurableSet) Subset.rfl

@[measurability]
theorem measurableSet_interior : MeasurableSet (interior s) :=
  isOpen_interior.measurableSet

theorem IsGŒ¥.measurableSet (h : IsGŒ¥ s) : MeasurableSet s := by
  rcases h with ‚ü®S, hSo, hSc, rfl‚ü©
  exact MeasurableSet.sInter hSc fun t ht => (hSo t ht).measurableSet

theorem measurableSet_of_continuousAt {Œ≤} [EMetricSpace Œ≤] (f : Œ± ‚Üí Œ≤) :
    MeasurableSet { x | ContinuousAt f x } :=
  (isGŒ¥_setOf_continuousAt f).measurableSet

theorem IsClosed.measurableSet (h : IsClosed s) : MeasurableSet s :=
  h.isOpen_compl.measurableSet.of_compl

theorem IsCompact.measurableSet [T2Space Œ±] (h : IsCompact s) : MeasurableSet s :=
  h.isClosed.measurableSet

@[measurability]
theorem measurableSet_closure : MeasurableSet (closure s) :=
  isClosed_closure.measurableSet

theorem measurable_of_isOpen {f : Œ¥ ‚Üí Œ≥} (hf : ‚àÄ s, IsOpen s ‚Üí MeasurableSet (f ‚Åª¬π' s)) :
    Measurable f := by
  rw [‚ÄπBorelSpace Œ≥‚Ä∫.measurable_eq]
  exact measurable_generateFrom hf

theorem measurable_of_isClosed {f : Œ¥ ‚Üí Œ≥} (hf : ‚àÄ s, IsClosed s ‚Üí MeasurableSet (f ‚Åª¬π' s)) :
    Measurable f := by
  apply measurable_of_isOpen; intro s hs
  rw [‚Üê MeasurableSet.compl_iff, ‚Üê preimage_compl]; apply hf; rw [isClosed_compl_iff]; exact hs

theorem measurable_of_is_closed' {f : Œ¥ ‚Üí Œ≥}
    (hf : ‚àÄ s, IsClosed s ‚Üí s.Nonempty ‚Üí s ‚â† univ ‚Üí MeasurableSet (f ‚Åª¬π' s)) : Measurable f := by
  apply measurable_of_isClosed; intro s hs
  cases' eq_empty_or_nonempty s with h1 h1; ¬∑ simp [h1]
  by_cases h2 : s = univ; ¬∑ simp [h2]
  exact hf s hs h1 h2

instance nhds_isMeasurablyGenerated (a : Œ±) : (ùìù a).IsMeasurablyGenerated := by
  rw [nhds, iInf_subtype']
  refine' @Filter.iInf_isMeasurablyGenerated Œ± _ _ _ fun i => _
  exact i.2.2.measurableSet.principal_isMeasurablyGenerated

/-- If `s` is a measurable set, then `ùìù[s] a` is a measurably generated filter for
each `a`. This cannot be an `instance` because it depends on a non-instance `hs : MeasurableSet s`.
-/
theorem MeasurableSet.nhdsWithin_isMeasurablyGenerated {s : Set Œ±} (hs : MeasurableSet s) (a : Œ±) :
    (ùìù[s] a).IsMeasurablyGenerated :=
  haveI := hs.principal_isMeasurablyGenerated
  Filter.inf_isMeasurablyGenerated _ _

-- see Note [lower instance priority]
instance (priority := 100) OpensMeasurableSpace.toMeasurableSingletonClass [T1Space Œ±] :
    MeasurableSingletonClass Œ± :=
  ‚ü®fun _ => isClosed_singleton.measurableSet‚ü©

instance Pi.opensMeasurableSpace {Œπ : Type*} {œÄ : Œπ ‚Üí Type*} [Countable Œπ]
    [t' : ‚àÄ i, TopologicalSpace (œÄ i)] [‚àÄ i, MeasurableSpace (œÄ i)]
    [‚àÄ i, SecondCountableTopology (œÄ i)] [‚àÄ i, OpensMeasurableSpace (œÄ i)] :
    OpensMeasurableSpace (‚àÄ i, œÄ i) := by
  constructor
  have : Pi.topologicalSpace = .generateFrom { t | ‚àÉ (s : ‚àÄ a, Set (œÄ a)) (i : Finset Œπ),
      (‚àÄ a ‚àà i, s a ‚àà countableBasis (œÄ a)) ‚àß t = pi (‚Üëi) s } := by
    rw [funext fun a => @eq_generateFrom_countableBasis (œÄ a) _ _, pi_generateFrom_eq]
  rw [borel_eq_generateFrom_of_subbasis this]
  apply generateFrom_le
  rintro _ ‚ü®s, i, hi, rfl‚ü©
  refine' MeasurableSet.pi i.countable_toSet fun a ha => IsOpen.measurableSet _
  rw [eq_generateFrom_countableBasis (œÄ a)]
  exact .basic _ (hi a ha)

/-- The typeclass `SecondCountableTopologyEither Œ± Œ≤` registers the fact that at least one of
the two spaces has second countable topology. This is the right assumption to ensure that continuous
maps from `Œ±` to `Œ≤` are strongly measurable. -/
class SecondCountableTopologyEither (Œ± Œ≤ : Type*) [TopologicalSpace Œ±] [TopologicalSpace Œ≤] :
  Prop where
  /-- The projection out of `SecondCountableTopologyEither` -/
  out : SecondCountableTopology Œ± ‚à® SecondCountableTopology Œ≤

instance (priority := 100) secondCountableTopologyEither_of_left (Œ± Œ≤ : Type*) [TopologicalSpace Œ±]
    [TopologicalSpace Œ≤] [SecondCountableTopology Œ±] : SecondCountableTopologyEither Œ± Œ≤ where
  out := Or.inl (by infer_instance)

instance (priority := 100) secondCountableTopologyEither_of_right (Œ± Œ≤ : Type*)
    [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [SecondCountableTopology Œ≤] :
    SecondCountableTopologyEither Œ± Œ≤ where out := Or.inr (by infer_instance)

/-- If either `Œ±` or `Œ≤` has second-countable topology, then the open sets in `Œ± √ó Œ≤` belong to the
product sigma-algebra. -/
instance Prod.opensMeasurableSpace [h : SecondCountableTopologyEither Œ± Œ≤] :
    OpensMeasurableSpace (Œ± √ó Œ≤) := by
  apply opensMeasurableSpace_iff_forall_measurableSet.2 (fun s hs ‚Ü¶ ?_)
  rcases h.out with hŒ±|hŒ≤
  ¬∑ let F : Set Œ± ‚Üí Set Œ≤ := fun a ‚Ü¶ {y | ‚àÉ b, IsOpen b ‚àß y ‚àà b ‚àß a √óÀ¢ b ‚äÜ s}
    have A : ‚àÄ a, IsOpen (F a) := by
      intro a
      apply isOpen_iff_forall_mem_open.2
      rintro y ‚ü®b, b_open, yb, hb‚ü©
      exact ‚ü®b, fun z zb ‚Ü¶ ‚ü®b, b_open, zb, hb‚ü©, b_open, yb‚ü©
    have : s = ‚ãÉ a ‚àà countableBasis Œ±, a √óÀ¢ F a := by
      apply Subset.antisymm
      ¬∑ rintro ‚ü®y1, y2‚ü© hy
        rcases isOpen_prod_iff.1 hs y1 y2 hy with ‚ü®u, v, u_open, v_open, yu, yv, huv‚ü©
        obtain ‚ü®a, ha, ya, au‚ü© : ‚àÉ a ‚àà countableBasis Œ±, y1 ‚àà a ‚àß a ‚äÜ u :=
          IsTopologicalBasis.exists_subset_of_mem_open (isBasis_countableBasis Œ±) yu u_open
        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop]
        exact ‚ü®a, ya, ha, v, v_open, yv, (Set.prod_mono_left au).trans huv‚ü©
      ¬∑ rintro ‚ü®y1, y2‚ü© hy
        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop] at hy
        rcases hy with ‚ü®a, ya, -, b, -, yb, hb‚ü©
        exact hb (mem_prod.2 ‚ü®ya, yb‚ü©)
    rw [this]
    apply MeasurableSet.biUnion (countable_countableBasis Œ±) (fun a ha ‚Ü¶ ?_)
    exact (isOpen_of_mem_countableBasis ha).measurableSet.prod (A a).measurableSet
  ¬∑ let F : Set Œ≤ ‚Üí Set Œ± := fun a ‚Ü¶ {y | ‚àÉ b, IsOpen b ‚àß y ‚àà b ‚àß b √óÀ¢ a ‚äÜ s}
    have A : ‚àÄ a, IsOpen (F a) := by
      intro a
      apply isOpen_iff_forall_mem_open.2
      rintro y ‚ü®b, b_open, yb, hb‚ü©
      exact ‚ü®b, fun z zb ‚Ü¶ ‚ü®b, b_open, zb, hb‚ü©, b_open, yb‚ü©
    have : s = ‚ãÉ a ‚àà countableBasis Œ≤, F a √óÀ¢ a := by
      apply Subset.antisymm
      ¬∑ rintro ‚ü®y1, y2‚ü© hy
        rcases isOpen_prod_iff.1 hs y1 y2 hy with ‚ü®u, v, u_open, v_open, yu, yv, huv‚ü©
        obtain ‚ü®a, ha, ya, au‚ü© : ‚àÉ a ‚àà countableBasis Œ≤, y2 ‚àà a ‚àß a ‚äÜ v :=
          IsTopologicalBasis.exists_subset_of_mem_open (isBasis_countableBasis Œ≤) yv v_open
        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop]
        exact ‚ü®a, ‚ü®u, u_open, yu, (Set.prod_mono_right au).trans huv‚ü©, ha, ya‚ü©
      ¬∑ rintro ‚ü®y1, y2‚ü© hy
        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop] at hy
        rcases hy with ‚ü®a, ‚ü®b, -, yb, hb‚ü©, -, ya‚ü©
        exact hb (mem_prod.2 ‚ü®yb, ya‚ü©)
    rw [this]
    apply MeasurableSet.biUnion (countable_countableBasis Œ≤) (fun a ha ‚Ü¶ ?_)
    exact (A a).measurableSet.prod (isOpen_of_mem_countableBasis ha).measurableSet

variable {Œ±' : Type*} [TopologicalSpace Œ±'] [MeasurableSpace Œ±']

theorem interior_ae_eq_of_null_frontier {Œº : Measure Œ±'} {s : Set Œ±'} (h : Œº (frontier s) = 0) :
    interior s =·µê[Œº] s :=
  interior_subset.eventuallyLE.antisymm <| subset_closure.eventuallyLE.trans (ae_le_set.2 h)

theorem measure_interior_of_null_frontier {Œº : Measure Œ±'} {s : Set Œ±'} (h : Œº (frontier s) = 0) :
    Œº (interior s) = Œº s :=
  measure_congr (interior_ae_eq_of_null_frontier h)

theorem nullMeasurableSet_of_null_frontier {s : Set Œ±} {Œº : Measure Œ±} (h : Œº (frontier s) = 0) :
    NullMeasurableSet s Œº :=
  ‚ü®interior s, isOpen_interior.measurableSet, (interior_ae_eq_of_null_frontier h).symm‚ü©

theorem closure_ae_eq_of_null_frontier {Œº : Measure Œ±'} {s : Set Œ±'} (h : Œº (frontier s) = 0) :
    closure s =·µê[Œº] s :=
  ((ae_le_set.2 h).trans interior_subset.eventuallyLE).antisymm <| subset_closure.eventuallyLE

theorem measure_closure_of_null_frontier {Œº : Measure Œ±'} {s : Set Œ±'} (h : Œº (frontier s) = 0) :
    Œº (closure s) = Œº s :=
  measure_congr (closure_ae_eq_of_null_frontier h)

section Preorder

variable [Preorder Œ±] [OrderClosedTopology Œ±] {a b x : Œ±}

@[simp, measurability]
theorem measurableSet_Ici : MeasurableSet (Ici a) :=
  isClosed_Ici.measurableSet

@[simp, measurability]
theorem measurableSet_Iic : MeasurableSet (Iic a) :=
  isClosed_Iic.measurableSet

@[simp, measurability]
theorem measurableSet_Icc : MeasurableSet (Icc a b) :=
  isClosed_Icc.measurableSet

instance nhdsWithin_Ici_isMeasurablyGenerated : (ùìù[Ici b] a).IsMeasurablyGenerated :=
  measurableSet_Ici.nhdsWithin_isMeasurablyGenerated _

instance nhdsWithin_Iic_isMeasurablyGenerated : (ùìù[Iic b] a).IsMeasurablyGenerated :=
  measurableSet_Iic.nhdsWithin_isMeasurablyGenerated _

instance nhdsWithin_Icc_isMeasurablyGenerated : IsMeasurablyGenerated (ùìù[Icc a b] x) := by
  rw [‚Üê Ici_inter_Iic, nhdsWithin_inter]
  infer_instance

instance atTop_isMeasurablyGenerated : (Filter.atTop : Filter Œ±).IsMeasurablyGenerated :=
  @Filter.iInf_isMeasurablyGenerated _ _ _ _ fun a =>
    (measurableSet_Ici : MeasurableSet (Ici a)).principal_isMeasurablyGenerated

instance atBot_isMeasurablyGenerated : (Filter.atBot : Filter Œ±).IsMeasurablyGenerated :=
  @Filter.iInf_isMeasurablyGenerated _ _ _ _ fun a =>
    (measurableSet_Iic : MeasurableSet (Iic a)).principal_isMeasurablyGenerated

end Preorder

section PartialOrder

variable [PartialOrder Œ±] [OrderClosedTopology Œ±] [SecondCountableTopology Œ±] {a b : Œ±}

@[measurability]
theorem measurableSet_le' : MeasurableSet { p : Œ± √ó Œ± | p.1 ‚â§ p.2 } :=
  OrderClosedTopology.isClosed_le'.measurableSet

@[measurability]
theorem measurableSet_le {f g : Œ¥ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    MeasurableSet { a | f a ‚â§ g a } :=
  hf.prod_mk hg measurableSet_le'

end PartialOrder

section LinearOrder

variable [LinearOrder Œ±] [OrderClosedTopology Œ±] {a b x : Œ±}

-- we open this locale only here to avoid issues with list being treated as intervals above
open Interval

@[simp, measurability]
theorem measurableSet_Iio : MeasurableSet (Iio a) :=
  isOpen_Iio.measurableSet

@[simp, measurability]
theorem measurableSet_Ioi : MeasurableSet (Ioi a) :=
  isOpen_Ioi.measurableSet

@[simp, measurability]
theorem measurableSet_Ioo : MeasurableSet (Ioo a b) :=
  isOpen_Ioo.measurableSet

@[simp, measurability]
theorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=
  measurableSet_Ioi.inter measurableSet_Iic

@[simp, measurability]
theorem measurableSet_Ico : MeasurableSet (Ico a b) :=
  measurableSet_Ici.inter measurableSet_Iio

instance nhdsWithin_Ioi_isMeasurablyGenerated : (ùìù[Ioi b] a).IsMeasurablyGenerated :=
  measurableSet_Ioi.nhdsWithin_isMeasurablyGenerated _

instance nhdsWithin_Iio_isMeasurablyGenerated : (ùìù[Iio b] a).IsMeasurablyGenerated :=
  measurableSet_Iio.nhdsWithin_isMeasurablyGenerated _

instance nhdsWithin_uIcc_isMeasurablyGenerated : IsMeasurablyGenerated (ùìù[[[a, b]]] x) :=
  nhdsWithin_Icc_isMeasurablyGenerated

@[measurability]
theorem measurableSet_lt' [SecondCountableTopology Œ±] : MeasurableSet { p : Œ± √ó Œ± | p.1 < p.2 } :=
  (isOpen_lt continuous_fst continuous_snd).measurableSet

@[measurability]
theorem measurableSet_lt [SecondCountableTopology Œ±] {f g : Œ¥ ‚Üí Œ±} (hf : Measurable f)
    (hg : Measurable g) : MeasurableSet { a | f a < g a } :=
  hf.prod_mk hg measurableSet_lt'

theorem nullMeasurableSet_lt [SecondCountableTopology Œ±] {Œº : Measure Œ¥} {f g : Œ¥ ‚Üí Œ±}
    (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) : NullMeasurableSet { a | f a < g a } Œº :=
  (hf.prod_mk hg).nullMeasurable measurableSet_lt'

theorem Set.OrdConnected.measurableSet (h : OrdConnected s) : MeasurableSet s := by
  let u := ‚ãÉ (x ‚àà s) (y ‚àà s), Ioo x y
  have huopen : IsOpen u := isOpen_biUnion fun _ _ => isOpen_biUnion fun _ _ => isOpen_Ioo
  have humeas : MeasurableSet u := huopen.measurableSet
  have hfinite : (s \ u).Finite := s.finite_diff_iUnion_Ioo
  have : u ‚äÜ s := iUnion‚ÇÇ_subset fun x hx => iUnion‚ÇÇ_subset fun y hy =>
    Ioo_subset_Icc_self.trans (h.out hx hy)
  rw [‚Üê union_diff_cancel this]
  exact humeas.union hfinite.measurableSet

theorem IsPreconnected.measurableSet (h : IsPreconnected s) : MeasurableSet s :=
  h.ordConnected.measurableSet

theorem generateFrom_Ico_mem_le_borel {Œ± : Type*} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderClosedTopology Œ±] (s t : Set Œ±) :
    MeasurableSpace.generateFrom { S | ‚àÉ l ‚àà s, ‚àÉ u ‚àà t, l < u ‚àß Ico l u = S }
      ‚â§ borel Œ± := by
  apply generateFrom_le
  borelize Œ±
  rintro _ ‚ü®a, -, b, -, -, rfl‚ü©
  exact measurableSet_Ico

theorem Dense.borel_eq_generateFrom_Ico_mem_aux {Œ± : Type*} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderTopology Œ±] [SecondCountableTopology Œ±] {s : Set Œ±} (hd : Dense s)
    (hbot : ‚àÄ x, IsBot x ‚Üí x ‚àà s) (hIoo : ‚àÄ x y : Œ±, x < y ‚Üí Ioo x y = ‚àÖ ‚Üí y ‚àà s) :
    borel Œ± = .generateFrom { S : Set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, l < u ‚àß Ico l u = S } := by
  set S : Set (Set Œ±) := { S | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, l < u ‚àß Ico l u = S }
  refine' le_antisymm _ (generateFrom_Ico_mem_le_borel _ _)
  letI : MeasurableSpace Œ± := generateFrom S
  rw [borel_eq_generateFrom_Iio]
  refine' generateFrom_le (forall_range_iff.2 fun a => _)
  rcases hd.exists_countable_dense_subset_bot_top with ‚ü®t, hts, hc, htd, htb, -‚ü©
  by_cases ha : ‚àÄ b < a, (Ioo b a).Nonempty
  ¬∑ convert_to MeasurableSet (‚ãÉ (l ‚àà t) (u ‚àà t) (_ : l < u) (_ : u ‚â§ a), Ico l u)
    ¬∑ ext y
      simp only [mem_iUnion, mem_Iio, mem_Ico]
      constructor
      ¬∑ intro hy
        rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) y with ‚ü®l, hlt, hly‚ü©
        rcases htd.exists_mem_open isOpen_Ioo (ha y hy) with ‚ü®u, hut, hyu, hua‚ü©
        exact ‚ü®l, hlt, u, hut, hly.trans_lt hyu, hua.le, hly, hyu‚ü©
      ¬∑ rintro ‚ü®l, -, u, -, -, hua, -, hyu‚ü©
        exact hyu.trans_le hua
    ¬∑ refine' MeasurableSet.biUnion hc fun a ha => MeasurableSet.biUnion hc fun b hb => _
      refine' MeasurableSet.iUnion fun hab => MeasurableSet.iUnion fun _ => _
      exact .basic _ ‚ü®a, hts ha, b, hts hb, hab, mem_singleton _‚ü©
  ¬∑ simp only [not_forall, not_nonempty_iff_eq_empty] at ha
    replace ha : a ‚àà s := hIoo ha.choose a ha.choose_spec.fst ha.choose_spec.snd
    convert_to MeasurableSet (‚ãÉ (l ‚àà t) (_ : l < a), Ico l a)
    ¬∑ symm
      simp only [‚Üê Ici_inter_Iio, ‚Üê iUnion_inter, inter_eq_right, subset_def, mem_iUnion,
        mem_Ici, mem_Iio]
      intro x hx
      rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) x with ‚ü®z, hzt, hzx‚ü©
      exact ‚ü®z, hzt, hzx.trans_lt hx, hzx‚ü©
    ¬∑ refine' .biUnion hc fun x hx => MeasurableSet.iUnion fun hlt => _
      exact .basic _ ‚ü®x, hts hx, a, ha, hlt, mem_singleton _‚ü©

theorem Dense.borel_eq_generateFrom_Ico_mem {Œ± : Type*} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderTopology Œ±] [SecondCountableTopology Œ±] [DenselyOrdered Œ±] [NoMinOrder Œ±] {s : Set Œ±}
    (hd : Dense s) :
    borel Œ± = .generateFrom { S : Set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, l < u ‚àß Ico l u = S } :=
  hd.borel_eq_generateFrom_Ico_mem_aux (by simp) fun x y hxy H =>
    ((nonempty_Ioo.2 hxy).ne_empty H).elim

theorem borel_eq_generateFrom_Ico (Œ± : Type*) [TopologicalSpace Œ±] [SecondCountableTopology Œ±]
    [LinearOrder Œ±] [OrderTopology Œ±] :
    borel Œ± = .generateFrom { S : Set Œ± | ‚àÉ (l u : Œ±), l < u ‚àß Ico l u = S } := by
  simpa only [exists_prop, mem_univ, true_and_iff] using
    (@dense_univ Œ± _).borel_eq_generateFrom_Ico_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ =>
      mem_univ _

theorem Dense.borel_eq_generateFrom_Ioc_mem_aux {Œ± : Type*} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderTopology Œ±] [SecondCountableTopology Œ±] {s : Set Œ±} (hd : Dense s)
    (hbot : ‚àÄ x, IsTop x ‚Üí x ‚àà s) (hIoo : ‚àÄ x y : Œ±, x < y ‚Üí Ioo x y = ‚àÖ ‚Üí x ‚àà s) :
    borel Œ± = .generateFrom { S : Set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, l < u ‚àß Ioc l u = S } := by
  convert hd.orderDual.borel_eq_generateFrom_Ico_mem_aux hbot fun x y hlt he => hIoo y x hlt _
    using 2
  ¬∑ ext s
    constructor <;> rintro ‚ü®l, hl, u, hu, hlt, rfl‚ü©
    exacts [‚ü®u, hu, l, hl, hlt, dual_Ico‚ü©, ‚ü®u, hu, l, hl, hlt, dual_Ioc‚ü©]
  ¬∑ erw [dual_Ioo]
    exact he

theorem Dense.borel_eq_generateFrom_Ioc_mem {Œ± : Type*} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderTopology Œ±] [SecondCountableTopology Œ±] [DenselyOrdered Œ±] [NoMaxOrder Œ±] {s : Set Œ±}
    (hd : Dense s) :
    borel Œ± = .generateFrom { S : Set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, l < u ‚àß Ioc l u = S } :=
  hd.borel_eq_generateFrom_Ioc_mem_aux (by simp) fun x y hxy H =>
    ((nonempty_Ioo.2 hxy).ne_empty H).elim

theorem borel_eq_generateFrom_Ioc (Œ± : Type*) [TopologicalSpace Œ±] [SecondCountableTopology Œ±]
    [LinearOrder Œ±] [OrderTopology Œ±] :
    borel Œ± = .generateFrom { S : Set Œ± | ‚àÉ l u, l < u ‚àß Ioc l u = S } := by
  simpa only [exists_prop, mem_univ, true_and_iff] using
    (@dense_univ Œ± _).borel_eq_generateFrom_Ioc_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ =>
      mem_univ _

namespace MeasureTheory.Measure

/-- Two finite measures on a Borel space are equal if they agree on all closed-open intervals.  If
`Œ±` is a conditionally complete linear order with no top element,
`MeasureTheory.Measure.ext_of_Ico` is an extensionality lemma with weaker assumptions on `Œº` and
`ŒΩ`. -/
theorem ext_of_Ico_finite {Œ± : Type*} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] (Œº ŒΩ : Measure Œ±)
    [IsFiniteMeasure Œº] (hŒºŒΩ : Œº univ = ŒΩ univ) (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) = ŒΩ (Ico a b)) :
    Œº = ŒΩ := by
  refine'
    ext_of_generate_finite _ (BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ico Œ±))
      (isPiSystem_Ico (id : Œ± ‚Üí Œ±) id) _ hŒºŒΩ
  ¬∑ rintro - ‚ü®a, b, hlt, rfl‚ü©
    exact h hlt

/-- Two finite measures on a Borel space are equal if they agree on all open-closed intervals.  If
`Œ±` is a conditionally complete linear order with no top element,
`MeasureTheory.Measure.ext_of_Ioc` is an extensionality lemma with weaker assumptions on `Œº` and
`ŒΩ`. -/
theorem ext_of_Ioc_finite {Œ± : Type*} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] (Œº ŒΩ : Measure Œ±)
    [IsFiniteMeasure Œº] (hŒºŒΩ : Œº univ = ŒΩ univ) (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) = ŒΩ (Ioc a b)) :
    Œº = ŒΩ := by
  refine' @ext_of_Ico_finite Œ±·µí·µà _ _ _ _ _ ‚Äπ_‚Ä∫ Œº ŒΩ _ hŒºŒΩ fun a b hab => _
  erw [dual_Ico (Œ± := Œ±)]
  exact h hab

/-- Two measures which are finite on closed-open intervals are equal if they agree on all
closed-open intervals. -/
theorem ext_of_Ico' {Œ± : Type*} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] [NoMaxOrder Œ±]
    (Œº ŒΩ : Measure Œ±) (hŒº : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) ‚â† ‚àû)
    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) = ŒΩ (Ico a b)) : Œº = ŒΩ := by
  rcases exists_countable_dense_bot_top Œ± with ‚ü®s, hsc, hsd, hsb, _‚ü©
  have : (‚ãÉ (l ‚àà s) (u ‚àà s) (_ : l < u), {Ico l u} : Set (Set Œ±)).Countable :=
    hsc.biUnion fun l _ => hsc.biUnion fun u _ => countable_iUnion fun _ => countable_singleton _
  simp only [‚Üê setOf_eq_eq_singleton, ‚Üê setOf_exists] at this
  refine'
    Measure.ext_of_generateFrom_of_cover_subset
      (BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ico Œ±)) (isPiSystem_Ico id id) _ this
      _ _ _
  ¬∑ rintro _ ‚ü®l, -, u, -, h, rfl‚ü©
    exact ‚ü®l, u, h, rfl‚ü©
  ¬∑ refine' sUnion_eq_univ_iff.2 fun x => _
    rcases hsd.exists_le' hsb x with ‚ü®l, hls, hlx‚ü©
    rcases hsd.exists_gt x with ‚ü®u, hus, hxu‚ü©
    exact ‚ü®_, ‚ü®l, hls, u, hus, hlx.trans_lt hxu, rfl‚ü©, hlx, hxu‚ü©
  ¬∑ rintro _ ‚ü®l, -, u, -, hlt, rfl‚ü©
    exact hŒº hlt
  ¬∑ rintro _ ‚ü®l, u, hlt, rfl‚ü©
    exact h hlt

/-- Two measures which are finite on closed-open intervals are equal if they agree on all
open-closed intervals. -/
theorem ext_of_Ioc' {Œ± : Type*} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] [NoMinOrder Œ±]
    (Œº ŒΩ : Measure Œ±) (hŒº : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) ‚â† ‚àû)
    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) = ŒΩ (Ioc a b)) : Œº = ŒΩ := by
  refine' @ext_of_Ico' Œ±·µí·µà _ _ _ _ _ ‚Äπ_‚Ä∫ _ Œº ŒΩ _ _ <;> intro a b hab <;> erw [dual_Ico (Œ± := Œ±)]
  exacts [hŒº hab, h hab]

/-- Two measures which are finite on closed-open intervals are equal if they agree on all
closed-open intervals. -/
theorem ext_of_Ico {Œ± : Type*} [TopologicalSpace Œ±] {_m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [ConditionallyCompleteLinearOrder Œ±] [OrderTopology Œ±]
    [BorelSpace Œ±] [NoMaxOrder Œ±] (Œº ŒΩ : Measure Œ±) [IsLocallyFiniteMeasure Œº]
    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) = ŒΩ (Ico a b)) : Œº = ŒΩ :=
  Œº.ext_of_Ico' ŒΩ (fun _ _ _ => measure_Ico_lt_top.ne) h

/-- Two measures which are finite on closed-open intervals are equal if they agree on all
open-closed intervals. -/
theorem ext_of_Ioc {Œ± : Type*} [TopologicalSpace Œ±] {_m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [ConditionallyCompleteLinearOrder Œ±] [OrderTopology Œ±]
    [BorelSpace Œ±] [NoMinOrder Œ±] (Œº ŒΩ : Measure Œ±) [IsLocallyFiniteMeasure Œº]
    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) = ŒΩ (Ioc a b)) : Œº = ŒΩ :=
  Œº.ext_of_Ioc' ŒΩ (fun _ _ _ => measure_Ioc_lt_top.ne) h

/-- Two finite measures on a Borel space are equal if they agree on all left-infinite right-closed
intervals. -/
theorem ext_of_Iic {Œ± : Type*} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] (Œº ŒΩ : Measure Œ±)
    [IsFiniteMeasure Œº] (h : ‚àÄ a, Œº (Iic a) = ŒΩ (Iic a)) : Œº = ŒΩ := by
  refine' ext_of_Ioc_finite Œº ŒΩ _ fun a b hlt => _
  ¬∑ rcases exists_countable_dense_bot_top Œ± with ‚ü®s, hsc, hsd, -, hst‚ü©
    have : DirectedOn (¬∑ ‚â§ ¬∑) s := directedOn_iff_directed.2 (Subtype.mono_coe _).directed_le
    simp only [‚Üê biSup_measure_Iic hsc (hsd.exists_ge' hst) this, h]
  rw [‚Üê Iic_diff_Iic, measure_diff (Iic_subset_Iic.2 hlt.le) measurableSet_Iic,
    measure_diff (Iic_subset_Iic.2 hlt.le) measurableSet_Iic, h a, h b]
  ¬∑ rw [‚Üê h a]
    exact (measure_lt_top Œº _).ne
  ¬∑ exact (measure_lt_top Œº _).ne

/-- Two finite measures on a Borel space are equal if they agree on all left-closed right-infinite
intervals. -/
theorem ext_of_Ici {Œ± : Type*} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] (Œº ŒΩ : Measure Œ±)
    [IsFiniteMeasure Œº] (h : ‚àÄ a, Œº (Ici a) = ŒΩ (Ici a)) : Œº = ŒΩ :=
  @ext_of_Iic Œ±·µí·µà _ _ _ _ _ ‚Äπ_‚Ä∫ _ _ _ h

end MeasureTheory.Measure

end LinearOrder

section LinearOrder

variable [LinearOrder Œ±] [OrderClosedTopology Œ±] {a b : Œ±}

@[measurability]
theorem measurableSet_uIcc : MeasurableSet (uIcc a b) :=
  measurableSet_Icc

@[measurability]
theorem measurableSet_uIoc : MeasurableSet (uIoc a b) :=
  measurableSet_Ioc

variable [SecondCountableTopology Œ±]

@[measurability]
theorem Measurable.max {f g : Œ¥ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun a => max (f a) (g a) := by
  simpa only [max_def'] using hf.piecewise (measurableSet_le hg hf) hg

@[measurability]
nonrec theorem AEMeasurable.max {f g : Œ¥ ‚Üí Œ±} {Œº : Measure Œ¥} (hf : AEMeasurable f Œº)
    (hg : AEMeasurable g Œº) : AEMeasurable (fun a => max (f a) (g a)) Œº :=
  ‚ü®fun a => max (hf.mk f a) (hg.mk g a), hf.measurable_mk.max hg.measurable_mk,
    EventuallyEq.comp‚ÇÇ hf.ae_eq_mk _ hg.ae_eq_mk‚ü©

@[measurability]
theorem Measurable.min {f g : Œ¥ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun a => min (f a) (g a) := by
  simpa only [min_def] using hf.piecewise (measurableSet_le hf hg) hg

@[measurability]
nonrec theorem AEMeasurable.min {f g : Œ¥ ‚Üí Œ±} {Œº : Measure Œ¥} (hf : AEMeasurable f Œº)
    (hg : AEMeasurable g Œº) : AEMeasurable (fun a => min (f a) (g a)) Œº :=
  ‚ü®fun a => min (hf.mk f a) (hg.mk g a), hf.measurable_mk.min hg.measurable_mk,
    EventuallyEq.comp‚ÇÇ hf.ae_eq_mk _ hg.ae_eq_mk‚ü©

end LinearOrder

/-- A continuous function from an `OpensMeasurableSpace` to a `BorelSpace`
is measurable. -/
theorem Continuous.measurable {f : Œ± ‚Üí Œ≥} (hf : Continuous f) : Measurable f :=
  hf.borel_measurable.mono OpensMeasurableSpace.borel_le (le_of_eq <| BorelSpace.measurable_eq)

/-- A continuous function from an `OpensMeasurableSpace` to a `BorelSpace`
is ae-measurable. -/
theorem Continuous.aemeasurable {f : Œ± ‚Üí Œ≥} (h : Continuous f) {Œº : Measure Œ±} : AEMeasurable f Œº :=
  h.measurable.aemeasurable

theorem ClosedEmbedding.measurable {f : Œ± ‚Üí Œ≥} (hf : ClosedEmbedding f) : Measurable f :=
  hf.continuous.measurable

/-- If a function is defined piecewise in terms of functions which are continuous on their
respective pieces, then it is measurable. -/
theorem ContinuousOn.measurable_piecewise {f g : Œ± ‚Üí Œ≥} {s : Set Œ±} [‚àÄ j : Œ±, Decidable (j ‚àà s)]
    (hf : ContinuousOn f s) (hg : ContinuousOn g s·∂ú) (hs : MeasurableSet s) :
    Measurable (s.piecewise f g) := by
  refine' measurable_of_isOpen fun t ht => _
  rw [piecewise_preimage, Set.ite]
  apply MeasurableSet.union
  ¬∑ rcases _root_.continuousOn_iff'.1 hf t ht with ‚ü®u, u_open, hu‚ü©
    rw [hu]
    exact u_open.measurableSet.inter hs
  ¬∑ rcases _root_.continuousOn_iff'.1 hg t ht with ‚ü®u, u_open, hu‚ü©
    rw [diff_eq_compl_inter, inter_comm, hu]
    exact u_open.measurableSet.inter hs.compl

@[to_additive]
instance (priority := 100) ContinuousMul.measurableMul [Mul Œ≥] [ContinuousMul Œ≥] :
    MeasurableMul Œ≥ where
  measurable_const_mul _ := (continuous_const.mul continuous_id).measurable
  measurable_mul_const _ := (continuous_id.mul continuous_const).measurable

instance (priority := 100) ContinuousSub.measurableSub [Sub Œ≥] [ContinuousSub Œ≥] :
    MeasurableSub Œ≥ where
  measurable_const_sub _ := (continuous_const.sub continuous_id).measurable
  measurable_sub_const _ := (continuous_id.sub continuous_const).measurable

@[to_additive]
instance (priority := 100) TopologicalGroup.measurableInv [Group Œ≥] [TopologicalGroup Œ≥] :
    MeasurableInv Œ≥ :=
  ‚ü®continuous_inv.measurable‚ü©

instance (priority := 100) ContinuousSMul.measurableSMul {M Œ±} [TopologicalSpace M]
    [TopologicalSpace Œ±] [MeasurableSpace M] [MeasurableSpace Œ±] [OpensMeasurableSpace M]
    [BorelSpace Œ±] [SMul M Œ±] [ContinuousSMul M Œ±] : MeasurableSMul M Œ± :=
  ‚ü®fun _ => (continuous_const_smul _).measurable, fun _ =>
    (continuous_id.smul continuous_const).measurable‚ü©

section Lattice

instance (priority := 100) ContinuousSup.measurableSup [Sup Œ≥] [ContinuousSup Œ≥] :
    MeasurableSup Œ≥ where
  measurable_const_sup _ := (continuous_const.sup continuous_id).measurable
  measurable_sup_const _ := (continuous_id.sup continuous_const).measurable

instance (priority := 100) ContinuousSup.measurableSup‚ÇÇ [SecondCountableTopology Œ≥] [Sup Œ≥]
    [ContinuousSup Œ≥] : MeasurableSup‚ÇÇ Œ≥ :=
  ‚ü®continuous_sup.measurable‚ü©

instance (priority := 100) ContinuousInf.measurableInf [Inf Œ≥] [ContinuousInf Œ≥] :
    MeasurableInf Œ≥ where
  measurable_const_inf _ := (continuous_const.inf continuous_id).measurable
  measurable_inf_const _ := (continuous_id.inf continuous_const).measurable

instance (priority := 100) ContinuousInf.measurableInf‚ÇÇ [SecondCountableTopology Œ≥] [Inf Œ≥]
    [ContinuousInf Œ≥] : MeasurableInf‚ÇÇ Œ≥ :=
  ‚ü®continuous_inf.measurable‚ü©

end Lattice

section Homeomorph

@[measurability]
protected theorem Homeomorph.measurable (h : Œ± ‚âÉ‚Çú Œ≥) : Measurable h :=
  h.continuous.measurable

/-- A homeomorphism between two Borel spaces is a measurable equivalence.-/
def Homeomorph.toMeasurableEquiv (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : Œ≥ ‚âÉ·µê Œ≥‚ÇÇ where
  measurable_toFun := h.measurable
  measurable_invFun := h.symm.measurable
  toEquiv := h.toEquiv

lemma Homeomorph.measurableEmbedding (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : MeasurableEmbedding h :=
  h.toMeasurableEquiv.measurableEmbedding

@[simp]
theorem Homeomorph.toMeasurableEquiv_coe (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : (h.toMeasurableEquiv : Œ≥ ‚Üí Œ≥‚ÇÇ) = h :=
  rfl

@[simp]
theorem Homeomorph.toMeasurableEquiv_symm_coe (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) :
    (h.toMeasurableEquiv.symm : Œ≥‚ÇÇ ‚Üí Œ≥) = h.symm :=
  rfl

end Homeomorph

@[measurability]
theorem ContinuousMap.measurable (f : C(Œ±, Œ≥)) : Measurable f :=
  f.continuous.measurable

theorem measurable_of_continuousOn_compl_singleton [T1Space Œ±] {f : Œ± ‚Üí Œ≥} (a : Œ±)
    (hf : ContinuousOn f {a}·∂ú) : Measurable f :=
  measurable_of_measurable_on_compl_singleton a
    (continuousOn_iff_continuous_restrict.1 hf).measurable

theorem Continuous.measurable2 [SecondCountableTopologyEither Œ± Œ≤] {f : Œ¥ ‚Üí Œ±}
    {g : Œ¥ ‚Üí Œ≤} {c : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (h : Continuous fun p : Œ± √ó Œ≤ => c p.1 p.2) (hf : Measurable f)
    (hg : Measurable g) : Measurable fun a => c (f a) (g a) :=
  h.measurable.comp (hf.prod_mk hg)

theorem Continuous.aemeasurable2 [SecondCountableTopologyEither Œ± Œ≤]
    {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ≤} {c : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {Œº : Measure Œ¥}
    (h : Continuous fun p : Œ± √ó Œ≤ => c p.1 p.2) (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    AEMeasurable (fun a => c (f a) (g a)) Œº :=
  h.measurable.comp_aemeasurable (hf.prod_mk hg)

instance (priority := 100) HasContinuousInv‚ÇÄ.measurableInv [GroupWithZero Œ≥] [T1Space Œ≥]
    [HasContinuousInv‚ÇÄ Œ≥] : MeasurableInv Œ≥ :=
  ‚ü®measurable_of_continuousOn_compl_singleton 0 continuousOn_inv‚ÇÄ‚ü©

@[to_additive]
instance (priority := 100) ContinuousMul.measurableMul‚ÇÇ [SecondCountableTopology Œ≥] [Mul Œ≥]
    [ContinuousMul Œ≥] : MeasurableMul‚ÇÇ Œ≥ :=
  ‚ü®continuous_mul.measurable‚ü©

instance (priority := 100) ContinuousSub.measurableSub‚ÇÇ [SecondCountableTopology Œ≥] [Sub Œ≥]
    [ContinuousSub Œ≥] : MeasurableSub‚ÇÇ Œ≥ :=
  ‚ü®continuous_sub.measurable‚ü©

instance (priority := 100) ContinuousSMul.measurableSMul‚ÇÇ {M Œ±} [TopologicalSpace M]
    [MeasurableSpace M] [OpensMeasurableSpace M] [TopologicalSpace Œ±]
    [SecondCountableTopologyEither M Œ±] [MeasurableSpace Œ±] [BorelSpace Œ±] [SMul M Œ±]
    [ContinuousSMul M Œ±] : MeasurableSMul‚ÇÇ M Œ± :=
  ‚ü®continuous_smul.measurable‚ü©

end

section BorelSpace

variable [TopologicalSpace Œ±] [MeasurableSpace Œ±] [BorelSpace Œ±] [TopologicalSpace Œ≤]
  [MeasurableSpace Œ≤] [BorelSpace Œ≤] [TopologicalSpace Œ≥] [MeasurableSpace Œ≥] [BorelSpace Œ≥]
  [MeasurableSpace Œ¥]

theorem pi_le_borel_pi {Œπ : Type*} {œÄ : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (œÄ i)]
    [‚àÄ i, MeasurableSpace (œÄ i)] [‚àÄ i, BorelSpace (œÄ i)] :
      MeasurableSpace.pi ‚â§ borel (‚àÄ i, œÄ i) := by
  have : ‚Äπ‚àÄ i, MeasurableSpace (œÄ i)‚Ä∫ = fun i => borel (œÄ i) :=
    funext fun i => BorelSpace.measurable_eq
  rw [this]
  exact iSup_le fun i => comap_le_iff_le_map.2 <| (continuous_apply i).borel_measurable

theorem prod_le_borel_prod : Prod.instMeasurableSpace ‚â§ borel (Œ± √ó Œ≤) := by
  rw [‚ÄπBorelSpace Œ±‚Ä∫.measurable_eq, ‚ÄπBorelSpace Œ≤‚Ä∫.measurable_eq]
  refine' sup_le _ _
  ¬∑ exact comap_le_iff_le_map.mpr continuous_fst.borel_measurable
  ¬∑ exact comap_le_iff_le_map.mpr continuous_snd.borel_measurable

instance Pi.borelSpace {Œπ : Type*} {œÄ : Œπ ‚Üí Type*} [Countable Œπ] [‚àÄ i, TopologicalSpace (œÄ i)]
    [‚àÄ i, MeasurableSpace (œÄ i)] [‚àÄ i, SecondCountableTopology (œÄ i)] [‚àÄ i, BorelSpace (œÄ i)] :
    BorelSpace (‚àÄ i, œÄ i) :=
  ‚ü®le_antisymm pi_le_borel_pi OpensMeasurableSpace.borel_le‚ü©

instance Prod.borelSpace [SecondCountableTopologyEither Œ± Œ≤] :
    BorelSpace (Œ± √ó Œ≤) :=
  ‚ü®le_antisymm prod_le_borel_prod OpensMeasurableSpace.borel_le‚ü©

protected theorem Embedding.measurableEmbedding {f : Œ± ‚Üí Œ≤} (h‚ÇÅ : Embedding f)
    (h‚ÇÇ : MeasurableSet (range f)) : MeasurableEmbedding f :=
  show MeasurableEmbedding
      (((‚Üë) : range f ‚Üí Œ≤) ‚àò (Homeomorph.ofEmbedding f h‚ÇÅ).toMeasurableEquiv) from
    (MeasurableEmbedding.subtype_coe h‚ÇÇ).comp (MeasurableEquiv.measurableEmbedding _)

protected theorem ClosedEmbedding.measurableEmbedding {f : Œ± ‚Üí Œ≤} (h : ClosedEmbedding f) :
    MeasurableEmbedding f :=
  h.toEmbedding.measurableEmbedding h.closed_range.measurableSet

protected theorem OpenEmbedding.measurableEmbedding {f : Œ± ‚Üí Œ≤} (h : OpenEmbedding f) :
    MeasurableEmbedding f :=
  h.toEmbedding.measurableEmbedding h.open_range.measurableSet

section LinearOrder

variable [LinearOrder Œ±] [OrderTopology Œ±] [SecondCountableTopology Œ±]

theorem measurable_of_Iio {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, MeasurableSet (f ‚Åª¬π' Iio x)) : Measurable f := by
  convert measurable_generateFrom (Œ± := Œ¥) _
  exact BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Iio _)
  rintro _ ‚ü®x, rfl‚ü©; exact hf x

theorem UpperSemicontinuous.measurable [TopologicalSpace Œ¥] [OpensMeasurableSpace Œ¥] {f : Œ¥ ‚Üí Œ±}
    (hf : UpperSemicontinuous f) : Measurable f :=
  measurable_of_Iio fun y => (hf.isOpen_preimage y).measurableSet

theorem measurable_of_Ioi {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, MeasurableSet (f ‚Åª¬π' Ioi x)) : Measurable f := by
  convert measurable_generateFrom (Œ± := Œ¥) _
  exact BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ioi _)
  rintro _ ‚ü®x, rfl‚ü©; exact hf x

theorem LowerSemicontinuous.measurable [TopologicalSpace Œ¥] [OpensMeasurableSpace Œ¥] {f : Œ¥ ‚Üí Œ±}
    (hf : LowerSemicontinuous f) : Measurable f :=
  measurable_of_Ioi fun y => (hf.isOpen_preimage y).measurableSet

theorem measurable_of_Iic {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, MeasurableSet (f ‚Åª¬π' Iic x)) : Measurable f := by
  apply measurable_of_Ioi
  simp_rw [‚Üê compl_Iic, preimage_compl, MeasurableSet.compl_iff]
  assumption

theorem measurable_of_Ici {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, MeasurableSet (f ‚Åª¬π' Ici x)) : Measurable f := by
  apply measurable_of_Iio
  simp_rw [‚Üê compl_Ici, preimage_compl, MeasurableSet.compl_iff]
  assumption

/-- If a function is the least upper bound of countably many measurable functions,
then it is measurable. -/
theorem Measurable.isLUB {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i))
    (hg : ‚àÄ b, IsLUB { a | ‚àÉ i, f i b = a } (g b)) : Measurable g := by
  change ‚àÄ b, IsLUB (range fun i => f i b) (g b) at hg
  rw [‚ÄπBorelSpace Œ±‚Ä∫.measurable_eq, borel_eq_generateFrom_Ioi Œ±]
  apply measurable_generateFrom
  rintro _ ‚ü®a, rfl‚ü©
  simp_rw [Set.preimage, mem_Ioi, lt_isLUB_iff (hg _), exists_range_iff, setOf_exists]
  exact MeasurableSet.iUnion fun i => hf i (isOpen_lt' _).measurableSet

/-- If a function is the least upper bound of countably many measurable functions on a measurable
set `s`, and coincides with a measurable function outside of `s`, then it is measurable. -/
theorem Measurable.isLUB_of_mem {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g g' : Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, Measurable (f i))
    {s : Set Œ¥} (hs : MeasurableSet s) (hg : ‚àÄ b ‚àà s, IsLUB { a | ‚àÉ i, f i b = a } (g b))
    (hg' : EqOn g g' s·∂ú) (g'_meas : Measurable g') : Measurable g := by
  rcases isEmpty_or_nonempty Œπ with hŒπ|‚ü®‚ü®i‚ü©‚ü©
  ¬∑ rcases eq_empty_or_nonempty s with rfl|‚ü®x, hx‚ü©
    ¬∑ convert g'_meas
      ext x
      simp only [compl_empty] at hg'
      exact hg' (mem_univ x)
    ¬∑ have A : ‚àÄ b ‚àà s, IsBot (g b) := by simpa using hg
      have B : ‚àÄ b ‚àà s, g b = g x := by
        intro b hb
        apply le_antisymm (A b hb (g x)) (A x hx (g b))
      have : g = s.piecewise (fun _y ‚Ü¶ g x) g' := by
        ext b
        by_cases hb : b ‚àà s
        ¬∑ simp [hb, B]
        ¬∑ simp [hb, hg' hb]
      rw [this]
      exact Measurable.piecewise hs measurable_const g'_meas
  ¬∑ let f' : Œπ ‚Üí Œ¥ ‚Üí Œ± := fun i ‚Ü¶ s.piecewise (f i) g'
    suffices ‚àÄ b, IsLUB { a | ‚àÉ i, f' i b = a } (g b) from
      Measurable.isLUB (fun i ‚Ü¶ Measurable.piecewise hs (hf i) g'_meas) this
    intro b
    by_cases hb : b ‚àà s
    ¬∑ have A : ‚àÄ i, f' i b = f i b := fun i ‚Ü¶ by simp [hb]
      simpa [A] using hg b hb
    ¬∑ have A : ‚àÄ i, f' i b = g' b := fun i ‚Ü¶ by simp [hb]
      have : {a | ‚àÉ (_i : Œπ), g' b = a} = {g' b} := by
        apply Subset.antisymm
        ¬∑ rintro - ‚ü®_j, rfl‚ü©
          simp only [mem_singleton_iff]
        ¬∑ rintro - rfl
          exact ‚ü®i, rfl‚ü©
      simp [A, this, hg' hb, isLUB_singleton]

theorem AEMeasurable.isLUB {Œπ} {Œº : Measure Œ¥} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, AEMeasurable (f i) Œº) (hg : ‚àÄ·µê b ‚àÇŒº, IsLUB { a | ‚àÉ i, f i b = a } (g b)) :
    AEMeasurable g Œº := by
  nontriviality Œ±
  haveI hŒ± : Nonempty Œ± := inferInstance
  cases' isEmpty_or_nonempty Œπ with hŒπ hŒπ
  ¬∑ simp only [IsEmpty.exists_iff, setOf_false, isLUB_empty_iff] at hg
    exact aemeasurable_const' (hg.mono fun a ha => hg.mono fun b hb => (ha _).antisymm (hb _))
  let p : Œ¥ ‚Üí (Œπ ‚Üí Œ±) ‚Üí Prop := fun x f' => IsLUB { a | ‚àÉ i, f' i = a } (g x)
  let g_seq := (aeSeqSet hf p).piecewise g fun _ => hŒ±.some
  have hg_seq : ‚àÄ b, IsLUB { a | ‚àÉ i, aeSeq hf p i b = a } (g_seq b) := by
    intro b
    simp only [aeSeq, Set.piecewise]
    split_ifs with h
    ¬∑ have h_set_eq : { a : Œ± | ‚àÉ i : Œπ, (hf i).mk (f i) b = a } =
        { a : Œ± | ‚àÉ i : Œπ, f i b = a } := by
        ext x
        simp_rw [Set.mem_setOf_eq, aeSeq.mk_eq_fun_of_mem_aeSeqSet hf h]
      rw [h_set_eq]
      exact aeSeq.fun_prop_of_mem_aeSeqSet hf h
    ¬∑ exact IsGreatest.isLUB ‚ü®(@exists_const (hŒ±.some = hŒ±.some) Œπ _).2 rfl, fun x ‚ü®i, hi‚ü© => hi.ge‚ü©
  refine' ‚ü®g_seq, Measurable.isLUB (aeSeq.measurable hf p) hg_seq, _‚ü©
  exact
    (ite_ae_eq_of_measure_compl_zero g (fun _ => hŒ±.some) (aeSeqSet hf p)
        (aeSeq.measure_compl_aeSeqSet_eq_zero hf hg)).symm

/-- If a function is the greatest lower bound of countably many measurable functions,
then it is measurable. -/
theorem Measurable.isGLB {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i))
    (hg : ‚àÄ b, IsGLB { a | ‚àÉ i, f i b = a } (g b)) : Measurable g :=
  Measurable.isLUB (Œ± := Œ±·µí·µà) hf hg

/-- If a function is the greatest lower bound of countably many measurable functions on a measurable
set `s`, and coincides with a measurable function outside of `s`, then it is measurable. -/
theorem Measurable.isGLB_of_mem {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g g' : Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, Measurable (f i))
    {s : Set Œ¥} (hs : MeasurableSet s) (hg : ‚àÄ b ‚àà s, IsGLB { a | ‚àÉ i, f i b = a } (g b))
    (hg' : EqOn g g' s·∂ú) (g'_meas : Measurable g') : Measurable g :=
  Measurable.isLUB_of_mem (Œ± := Œ±·µí·µà) hf hs hg hg'  g'_meas

theorem AEMeasurable.isGLB {Œπ} {Œº : Measure Œ¥} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, AEMeasurable (f i) Œº) (hg : ‚àÄ·µê b ‚àÇŒº, IsGLB { a | ‚àÉ i, f i b = a } (g b)) :
    AEMeasurable g Œº :=
  AEMeasurable.isLUB (Œ± := Œ±·µí·µà) hf hg

protected theorem Monotone.measurable [LinearOrder Œ≤] [OrderClosedTopology Œ≤] {f : Œ≤ ‚Üí Œ±}
    (hf : Monotone f) : Measurable f :=
  suffices h : ‚àÄ x, OrdConnected (f ‚Åª¬π' Ioi x) from measurable_of_Ioi fun x => (h x).measurableSet
  fun _ => ordConnected_def.mpr fun _a ha _ _ _c hc => lt_of_lt_of_le ha (hf hc.1)

theorem aemeasurable_restrict_of_monotoneOn [LinearOrder Œ≤] [OrderClosedTopology Œ≤] {Œº : Measure Œ≤}
    {s : Set Œ≤} (hs : MeasurableSet s) {f : Œ≤ ‚Üí Œ±} (hf : MonotoneOn f s) :
    AEMeasurable f (Œº.restrict s) :=
  have : Monotone (f ‚àò (‚Üë) : s ‚Üí Œ±) := fun ‚ü®x, hx‚ü© ‚ü®y, hy‚ü©=> fun (hxy : x ‚â§ y) => hf hx hy hxy
  aemeasurable_restrict_of_measurable_subtype hs this.measurable

protected theorem Antitone.measurable [LinearOrder Œ≤] [OrderClosedTopology Œ≤] {f : Œ≤ ‚Üí Œ±}
    (hf : Antitone f) : Measurable f :=
  @Monotone.measurable Œ±·µí·µà Œ≤ _ _ ‚Äπ_‚Ä∫ _ _ _ _ _ ‚Äπ_‚Ä∫ _ _ _ hf

theorem aemeasurable_restrict_of_antitoneOn [LinearOrder Œ≤] [OrderClosedTopology Œ≤] {Œº : Measure Œ≤}
    {s : Set Œ≤} (hs : MeasurableSet s) {f : Œ≤ ‚Üí Œ±} (hf : AntitoneOn f s) :
    AEMeasurable f (Œº.restrict s) :=
  @aemeasurable_restrict_of_monotoneOn Œ±·µí·µà Œ≤ _ _ ‚Äπ_‚Ä∫ _ _ _ _ _ ‚Äπ_‚Ä∫ _ _ _ _ hs _ hf

theorem measurableSet_of_mem_nhdsWithin_Ioi_aux {s : Set Œ±} (h : ‚àÄ x ‚àà s, s ‚àà ùìù[>] x)
    (h' : ‚àÄ x ‚àà s, ‚àÉ y, x < y) : MeasurableSet s := by
  choose! M hM using h'
  suffices H : (s \ interior s).Countable
  ¬∑ have : s = interior s ‚à™ s \ interior s := by rw [union_diff_cancel interior_subset]
    rw [this]
    exact isOpen_interior.measurableSet.union H.measurableSet
  have A : ‚àÄ x ‚àà s, ‚àÉ y ‚àà Ioi x, Ioo x y ‚äÜ s := fun x hx =>
    (mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' (hM x hx)).1 (h x hx)
  choose! y hy h'y using A
  have B : Set.PairwiseDisjoint (s \ interior s) fun x => Ioo x (y x) := by
    intro x hx x' hx' hxx'
    rcases lt_or_gt_of_ne hxx' with (h' | h')
    ¬∑ refine disjoint_left.2 fun z hz h'z => ?_
      have : x' ‚àà interior s :=
        mem_interior.2 ‚ü®Ioo x (y x), h'y _ hx.1, isOpen_Ioo, ‚ü®h', h'z.1.trans hz.2‚ü©‚ü©
      exact False.elim (hx'.2 this)
    ¬∑ refine disjoint_left.2 fun z hz h'z => ?_
      have : x ‚àà interior s :=
        mem_interior.2 ‚ü®Ioo x' (y x'), h'y _ hx'.1, isOpen_Ioo, ‚ü®h', hz.1.trans h'z.2‚ü©‚ü©
      exact False.elim (hx.2 this)
  exact B.countable_of_Ioo fun x hx => hy x hx.1

/-- If a set is a right-neighborhood of all of its points, then it is measurable. -/
theorem measurableSet_of_mem_nhdsWithin_Ioi {s : Set Œ±} (h : ‚àÄ x ‚àà s, s ‚àà ùìù[>] x) :
    MeasurableSet s := by
  by_cases H : ‚àÉ x ‚àà s, IsTop x
  ¬∑ rcases H with ‚ü®x‚ÇÄ, x‚ÇÄs, h‚ÇÄ‚ü©
    have : s = {x‚ÇÄ} ‚à™ s \ {x‚ÇÄ} := by rw [union_diff_cancel (singleton_subset_iff.2 x‚ÇÄs)]
    rw [this]
    refine' (measurableSet_singleton _).union _
    have A : ‚àÄ x ‚àà s \ {x‚ÇÄ}, x < x‚ÇÄ := fun x hx => lt_of_le_of_ne (h‚ÇÄ _) (by simpa using hx.2)
    refine' measurableSet_of_mem_nhdsWithin_Ioi_aux (fun x hx => _) fun x hx => ‚ü®x‚ÇÄ, A x hx‚ü©
    obtain ‚ü®u, hu, us‚ü© : ‚àÉ (u : Œ±), u ‚àà Ioi x ‚àß Ioo x u ‚äÜ s :=
      (mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' (A x hx)).1 (h x hx.1)
    refine' (mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' (A x hx)).2 ‚ü®u, hu, fun y hy => ‚ü®us hy, _‚ü©‚ü©
    exact ne_of_lt (hy.2.trans_le (h‚ÇÄ _))
  ¬∑ apply measurableSet_of_mem_nhdsWithin_Ioi_aux h
    simp only [IsTop] at H
    push_neg at H
    exact H

lemma measurableSet_bddAbove_range {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    MeasurableSet {b | BddAbove (range (fun i ‚Ü¶ f i b))} := by
  rcases isEmpty_or_nonempty Œ± with hŒ±|hŒ±
  ¬∑ have : ‚àÄ b, range (fun i ‚Ü¶ f i b) = ‚àÖ := fun b ‚Ü¶ Iff.mp toFinset_eq_empty rfl
    simp [this]
  have A : ‚àÄ (i : Œπ) (c : Œ±), MeasurableSet {x | f i x ‚â§ c} := by
    intro i c
    exact measurableSet_le (hf i) measurable_const
  have B : ‚àÄ (c : Œ±), MeasurableSet {x | ‚àÄ i, f i x ‚â§ c} := by
    intro c
    rw [setOf_forall]
    exact MeasurableSet.iInter (fun i ‚Ü¶ A i c)
  obtain ‚ü®u, hu‚ü© : ‚àÉ (u : ‚Ñï ‚Üí Œ±), Tendsto u atTop atTop := exists_seq_tendsto (atTop : Filter Œ±)
  have : {b | BddAbove (range (fun i ‚Ü¶ f i b))} = {x | ‚àÉ n, ‚àÄ i, f i x ‚â§ u n} := by
    apply Subset.antisymm
    ¬∑ rintro x ‚ü®c, hc‚ü©
      obtain ‚ü®n, hn‚ü© : ‚àÉ n, c ‚â§ u n := (tendsto_atTop.1 hu c).exists
      exact ‚ü®n, fun i ‚Ü¶ (hc ((mem_range_self i))).trans hn‚ü©
    ¬∑ rintro x ‚ü®n, hn‚ü©
      refine ‚ü®u n, ?_‚ü©
      rintro - ‚ü®i, rfl‚ü©
      exact hn i
  rw [this, setOf_exists]
  exact MeasurableSet.iUnion (fun n ‚Ü¶ B (u n))

lemma measurableSet_bddBelow_range {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    MeasurableSet {b | BddBelow (range (fun i ‚Ü¶ f i b))} :=
  measurableSet_bddAbove_range (Œ± := Œ±·µí·µà) hf

end LinearOrder

@[measurability]
theorem Measurable.iSup_Prop {Œ±} [MeasurableSpace Œ±] [ConditionallyCompleteLattice Œ±]
    (p : Prop) {f : Œ¥ ‚Üí Œ±} (hf : Measurable f) : Measurable fun b => ‚®Ü _ : p, f b :=
  _root_.by_cases (fun h : p => by convert hf; funext; exact ciSup_pos h) fun h : ¬¨p => by
    convert measurable_const using 1; funext; exact ciSup_neg h

@[measurability]
theorem Measurable.iInf_Prop {Œ±} [MeasurableSpace Œ±] [ConditionallyCompleteLattice Œ±]
    (p : Prop) {f : Œ¥ ‚Üí Œ±} (hf : Measurable f) : Measurable fun b => ‚®Ö _ : p, f b :=
  _root_.by_cases (fun h : p => by convert hf; funext; exact ciInf_pos h) fun h : ¬¨p => by
    convert measurable_const using 1; funext; exact ciInf_neg h

section ConditionallyCompleteLinearOrder

variable [ConditionallyCompleteLinearOrder Œ±] [OrderTopology Œ±] [SecondCountableTopology Œ±]

@[measurability]
theorem measurable_iSup {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    Measurable (fun b ‚Ü¶ ‚®Ü i, f i b) := by
  rcases isEmpty_or_nonempty Œπ with hŒπ|hŒπ
  ¬∑ simp [iSup_of_empty']
  have A : MeasurableSet {b | BddAbove (range (fun i ‚Ü¶ f i b))} :=
    measurableSet_bddAbove_range hf
  have : Measurable (fun (_b : Œ¥) ‚Ü¶ sSup (‚àÖ : Set Œ±)) := measurable_const
  apply Measurable.isLUB_of_mem hf A _ _ this
  ¬∑ rintro b ‚ü®c, hc‚ü©
    apply isLUB_ciSup
    refine ‚ü®c, ?_‚ü©
    rintro d ‚ü®i, rfl‚ü©
    exact hc (mem_range_self i)
  ¬∑ intro b hb
    apply csSup_of_not_bddAbove
    exact hb

@[measurability]
theorem aemeasurable_iSup {Œπ} {Œº : Measure Œ¥} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, AEMeasurable (f i) Œº) : AEMeasurable (fun b => ‚®Ü i, f i b) Œº := by
  refine ‚ü®fun b ‚Ü¶ ‚®Ü i, (hf i).mk (f i) b, measurable_iSup (fun i ‚Ü¶ (hf i).measurable_mk), ?_‚ü©
  filter_upwards [ae_all_iff.2 (fun i ‚Ü¶ (hf i).ae_eq_mk)] with b hb using by simp [hb]

@[measurability]
theorem measurable_iInf {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    Measurable fun b => ‚®Ö i, f i b :=
  measurable_iSup (Œ± := Œ±·µí·µà) hf

@[measurability]
theorem aemeasurable_iInf {Œπ} {Œº : Measure Œ¥} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, AEMeasurable (f i) Œº) : AEMeasurable (fun b => ‚®Ö i, f i b) Œº :=
  aemeasurable_iSup (Œ± := Œ±·µí·µà) hf

theorem measurable_sSup {Œπ} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {s : Set Œπ} (hs : s.Countable)
    (hf : ‚àÄ i ‚àà s, Measurable (f i)) :
    Measurable fun x => sSup ((fun i => f i x) '' s) := by
  have : Countable ‚Üës := countable_coe_iff.2 hs
  convert measurable_iSup (f := (fun (i : s) ‚Ü¶ f i)) (fun i ‚Ü¶ hf i i.2) using 1
  ext b
  congr
  exact image_eq_range (fun i ‚Ü¶ f i b) s

theorem measurable_sInf {Œπ} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {s : Set Œπ} (hs : s.Countable)
    (hf : ‚àÄ i ‚àà s, Measurable (f i)) :
    Measurable fun x => sInf ((fun i => f i x) '' s) :=
  measurable_sSup (Œ± := Œ±·µí·µà) hs hf

theorem measurable_biSup {Œπ} (s : Set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.Countable)
    (hf : ‚àÄ i ‚àà s, Measurable (f i)) : Measurable fun b => ‚®Ü i ‚àà s, f i b := by
  haveI : Encodable s := hs.toEncodable
  by_cases H : ‚àÄ i, i ‚àà s
  ¬∑ have : ‚àÄ b, ‚®Ü i ‚àà s, f i b = ‚®Ü (i : s), f i b :=
      fun b ‚Ü¶ cbiSup_eq_of_forall (f := fun i ‚Ü¶ f i b) H
    simp only [this]
    exact measurable_iSup (fun (i : s) ‚Ü¶ hf i i.2)
  ¬∑ have : ‚àÄ b, ‚®Ü i ‚àà s, f i b = (‚®Ü (i : s), f i b) ‚äî sSup ‚àÖ :=
      fun b ‚Ü¶ cbiSup_eq_of_not_forall (f := fun i ‚Ü¶ f i b) H
    simp only [this]
    apply Measurable.sup _ measurable_const
    exact measurable_iSup (fun (i : s) ‚Ü¶ hf i i.2)

theorem aemeasurable_biSup {Œπ} {Œº : Measure Œ¥} (s : Set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.Countable)
    (hf : ‚àÄ i ‚àà s, AEMeasurable (f i) Œº) : AEMeasurable (fun b => ‚®Ü i ‚àà s, f i b) Œº := by
  let g : Œπ ‚Üí Œ¥ ‚Üí Œ± := fun i ‚Ü¶ if hi : i ‚àà s then (hf i hi).mk (f i) else fun _b ‚Ü¶ sSup ‚àÖ
  have : ‚àÄ i ‚àà s, Measurable (g i) := by
    intro i hi
    simpa [hi] using (hf i hi).measurable_mk
  refine ‚ü®fun b ‚Ü¶ ‚®Ü (i) (_ : i ‚àà s), g i b, measurable_biSup s hs this, ?_‚ü©
  have : ‚àÄ i ‚àà s, ‚àÄ·µê b ‚àÇŒº, f i b = g i b :=
    fun i hi ‚Ü¶ by simpa [hi] using (hf i hi).ae_eq_mk
  filter_upwards [(ae_ball_iff hs).2 this] with b hb
  congr
  ext i
  congr
  ext hi
  simp [hi, hb]

theorem measurable_biInf {Œπ} (s : Set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.Countable)
    (hf : ‚àÄ i ‚àà s, Measurable (f i)) : Measurable fun b => ‚®Ö i ‚àà s, f i b :=
  measurable_biSup (Œ± := Œ±·µí·µà) s hs hf

theorem aemeasurable_biInf {Œπ} {Œº : Measure Œ¥} (s : Set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.Countable)
    (hf : ‚àÄ i ‚àà s, AEMeasurable (f i) Œº) : AEMeasurable (fun b => ‚®Ö i ‚àà s, f i b) Œº :=
  aemeasurable_biSup (Œ± := Œ±·µí·µà) s hs hf

/-- `liminf` over a general filter is measurable. See `measurable_liminf` for the version over `‚Ñï`.
-/
theorem measurable_liminf' {Œπ Œπ'} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {v : Filter Œπ} (hf : ‚àÄ i, Measurable (f i))
    {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí Set Œπ} (hv : v.HasCountableBasis p s) (hs : ‚àÄ j, (s j).Countable) :
    Measurable fun x => liminf (fun i => f i x) v := by
  /- We would like to write the liminf as `‚®Ü (j : Subtype p), ‚®Ö (i : s j), f i x`, as the
  measurability would follow from the measurability of infs and sups. Unfortunately, this is not
  true in general conditionally complete linear orders because of issues with empty sets or sets
  which are not bounded above or below. A slightly more complicated expression for the liminf,
  valid in general, is given in `Filter.HasBasis.liminf_eq_ite`. This expression, built from
  `if ... then ... else` and infs and sups, can be readily checked to be measurable. -/
  have : Countable (Subtype p) := Encodable.nonempty_encodable.1 hv.countable
  rcases isEmpty_or_nonempty (Subtype p) with hp|hp
  ¬∑ simp [hv.liminf_eq_sSup_iUnion_iInter]
  by_cases H : ‚àÉ (j : Subtype p), s j = ‚àÖ
  ¬∑ simp_rw [hv.liminf_eq_ite, if_pos H, measurable_const]
  simp_rw [hv.liminf_eq_ite, if_neg H]
  have : ‚àÄ i, Countable (s i) := fun i ‚Ü¶ countable_coe_iff.2 (hs i)
  let m : Subtype p ‚Üí Set Œ¥ := fun j ‚Ü¶ {x | BddBelow (range (fun (i : s j) ‚Ü¶ f i x))}
  have m_meas : ‚àÄ j, MeasurableSet (m j) :=
    fun j ‚Ü¶ measurableSet_bddBelow_range (fun (i : s j) ‚Ü¶ hf i)
  have mc_meas : MeasurableSet {x | ‚àÄ (j : Subtype p), x ‚àâ m j} := by
    rw [setOf_forall]
    exact MeasurableSet.iInter (fun j ‚Ü¶ (m_meas j).compl)
  apply Measurable.piecewise mc_meas measurable_const
  apply measurable_iSup (fun j ‚Ü¶ ?_)
  let reparam : Œ¥ ‚Üí Subtype p ‚Üí Subtype p := fun x ‚Ü¶ liminf_reparam (fun i ‚Ü¶ f i x) s p
  let F0 : Subtype p ‚Üí Œ¥ ‚Üí Œ± := fun j x ‚Ü¶ ‚®Ö (i : s j), f i x
  have F0_meas : ‚àÄ j, Measurable (F0 j) := fun j ‚Ü¶ measurable_iInf (fun (i : s j) ‚Ü¶ hf i)
  set F1 : Œ¥ ‚Üí Œ± := fun x ‚Ü¶ F0 (reparam x j) x with hF1
  change Measurable F1
  let g : ‚Ñï ‚Üí Subtype p := choose (exists_surjective_nat (Subtype p))
  have Z : ‚àÄ x, ‚àÉ n, x ‚àà m (g n) ‚à® ‚àÄ k, x ‚àâ m k := by
    intro x
    by_cases H : ‚àÉ k, x ‚àà m k
    ¬∑ rcases H with ‚ü®k, hk‚ü©
      rcases choose_spec (exists_surjective_nat (Subtype p)) k with ‚ü®n, rfl‚ü©
      exact ‚ü®n, Or.inl hk‚ü©
    ¬∑ push_neg at H
      exact ‚ü®0, Or.inr H‚ü©
  have : F1 = fun x ‚Ü¶ if x ‚àà m j then F0 j x else F0 (g (Nat.find (Z x))) x := by
    ext x
    have A : reparam x j = if x ‚àà m j then j else g (Nat.find (Z x)) := rfl
    split_ifs with hjx
    ¬∑ have : reparam x j = j := by rw [A, if_pos hjx]
      simp only [hF1, this]
    ¬∑ have : reparam x j = g (Nat.find (Z x)) := by rw [A, if_neg hjx]
      simp only [hF1, this]
  rw [this]
  apply Measurable.piecewise (m_meas j) (F0_meas j)
  apply Measurable.find (fun n ‚Ü¶ F0_meas (g n)) (fun n ‚Ü¶ ?_)
  exact (m_meas (g n)).union mc_meas

/-- `limsup` over a general filter is measurable. See `measurable_limsup` for the version over `‚Ñï`.
-/
theorem measurable_limsup' {Œπ Œπ'} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {u : Filter Œπ} (hf : ‚àÄ i, Measurable (f i))
    {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí Set Œπ} (hu : u.HasCountableBasis p s) (hs : ‚àÄ i, (s i).Countable) :
    Measurable fun x => limsup (fun i => f i x) u :=
  measurable_liminf' (Œ± := Œ±·µí·µà) hf hu hs

/-- `liminf` over `‚Ñï` is measurable. See `measurable_liminf'` for a version with a general filter.
-/
@[measurability]
theorem measurable_liminf {f : ‚Ñï ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    Measurable fun x => liminf (fun i => f i x) atTop :=
  measurable_liminf' hf atTop_countable_basis fun _ => to_countable _

/-- `limsup` over `‚Ñï` is measurable. See `measurable_limsup'` for a version with a general filter.
-/
@[measurability]
theorem measurable_limsup {f : ‚Ñï ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    Measurable fun x => limsup (fun i => f i x) atTop :=
  measurable_limsup' hf atTop_countable_basis fun _ => to_countable _

end ConditionallyCompleteLinearOrder

/-- Convert a `Homeomorph` to a `MeasurableEquiv`. -/
def Homemorph.toMeasurableEquiv (h : Œ± ‚âÉ‚Çú Œ≤) : Œ± ‚âÉ·µê Œ≤ where
  toEquiv := h.toEquiv
  measurable_toFun := h.continuous_toFun.measurable
  measurable_invFun := h.continuous_invFun.measurable

protected theorem IsFiniteMeasureOnCompacts.map {Œ± : Type*} {m0 : MeasurableSpace Œ±}
    [TopologicalSpace Œ±] [OpensMeasurableSpace Œ±] {Œ≤ : Type*} [MeasurableSpace Œ≤]
    [TopologicalSpace Œ≤] [BorelSpace Œ≤] [T2Space Œ≤] (Œº : Measure Œ±) [IsFiniteMeasureOnCompacts Œº]
    (f : Œ± ‚âÉ‚Çú Œ≤) : IsFiniteMeasureOnCompacts (Measure.map f Œº) :=
  ‚ü®by
    intro K hK
    rw [Measure.map_apply f.measurable hK.measurableSet]
    apply IsCompact.measure_lt_top
    rwa [f.isCompact_preimage]‚ü©

end BorelSpace

instance Empty.borelSpace : BorelSpace Empty :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©

instance Unit.borelSpace : BorelSpace Unit :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©

instance Bool.borelSpace : BorelSpace Bool :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©

instance Nat.borelSpace : BorelSpace ‚Ñï :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©

instance Int.borelSpace : BorelSpace ‚Ñ§ :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©

instance Rat.borelSpace : BorelSpace ‚Ñö :=
  ‚ü®borel_eq_top_of_countable.symm‚ü©

/- Instances on `Real` and `Complex` are special cases of `IsROrC` but without these instances,
Lean fails to prove `BorelSpace (Œπ ‚Üí ‚Ñù)`, so we leave them here. -/
instance Real.measurableSpace : MeasurableSpace ‚Ñù :=
  borel ‚Ñù

instance Real.borelSpace : BorelSpace ‚Ñù :=
  ‚ü®rfl‚ü©

instance NNReal.measurableSpace : MeasurableSpace ‚Ñù‚â•0 :=
  Subtype.instMeasurableSpace

instance NNReal.borelSpace : BorelSpace ‚Ñù‚â•0 :=
  Subtype.borelSpace _

instance ENNReal.measurableSpace : MeasurableSpace ‚Ñù‚â•0‚àû :=
  borel ‚Ñù‚â•0‚àû

instance ENNReal.borelSpace : BorelSpace ‚Ñù‚â•0‚àû :=
  ‚ü®rfl‚ü©

instance EReal.measurableSpace : MeasurableSpace EReal :=
  borel EReal

instance EReal.borelSpace : BorelSpace EReal :=
  ‚ü®rfl‚ü©

/-- One can cut out `‚Ñù‚â•0‚àû` into the sets `{0}`, `Ico (t^n) (t^(n+1))` for `n : ‚Ñ§` and `{‚àû}`. This
gives a way to compute the measure of a set in terms of sets on which a given function `f` does not
fluctuate by more than `t`. -/
theorem measure_eq_measure_preimage_add_measure_tsum_Ico_zpow [MeasurableSpace Œ±] (Œº : Measure Œ±)
    {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) {s : Set Œ±} (hs : MeasurableSet s) {t : ‚Ñù‚â•0} (ht : 1 < t) :
    Œº s =
      Œº (s ‚à© f ‚Åª¬π' {0}) + Œº (s ‚à© f ‚Åª¬π' {‚àû}) +
      ‚àë' n : ‚Ñ§, Œº (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
  have A : Œº s = Œº (s ‚à© f ‚Åª¬π' {0}) + Œº (s ‚à© f ‚Åª¬π' Ioi 0) := by
    rw [‚Üê measure_union]
    ¬∑ congr 1
      ext x
      have : 0 = f x ‚à® 0 < f x := eq_or_lt_of_le bot_le
      rw [eq_comm] at this
      simp only [‚Üê and_or_left, this, mem_singleton_iff, mem_inter_iff, and_true_iff, mem_union,
        mem_Ioi, mem_preimage]
    ¬∑ refine disjoint_left.2 fun x hx h'x => ?_
      have : 0 < f x := h'x.2
      exact lt_irrefl 0 (this.trans_le hx.2.le)
    ¬∑ exact hs.inter (hf measurableSet_Ioi)
  have B : Œº (s ‚à© f ‚Åª¬π' Ioi 0) = Œº (s ‚à© f ‚Åª¬π' {‚àû}) + Œº (s ‚à© f ‚Åª¬π' Ioo 0 ‚àû) := by
    rw [‚Üê measure_union]
    ¬∑ rw [‚Üê inter_union_distrib_left]
      congr
      ext x
      simp only [mem_singleton_iff, mem_union, mem_Ioo, mem_Ioi, mem_preimage]
      have H : f x = ‚àû ‚à® f x < ‚àû := eq_or_lt_of_le le_top
      cases' H with H H
      ¬∑ simp only [H, eq_self_iff_true, or_false_iff, WithTop.zero_lt_top, not_top_lt,
          and_false_iff]
      ¬∑ simp only [H, H.ne, and_true_iff, false_or_iff]
    ¬∑ refine disjoint_left.2 fun x hx h'x => ?_
      have : f x < ‚àû := h'x.2.2
      exact lt_irrefl _ (this.trans_le (le_of_eq hx.2.symm))
    ¬∑ exact hs.inter (hf measurableSet_Ioo)
  have C : Œº (s ‚à© f ‚Åª¬π' Ioo 0 ‚àû) =
      ‚àë' n : ‚Ñ§, Œº (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
    rw [‚Üê measure_iUnion,
      ENNReal.Ioo_zero_top_eq_iUnion_Ico_zpow (ENNReal.one_lt_coe_iff.2 ht) ENNReal.coe_ne_top,
      preimage_iUnion, inter_iUnion]
    ¬∑ intro i j
      simp only [Function.onFun]
      intro hij
      wlog h : i < j generalizing i j
      ¬∑ exact (this hij.symm (hij.lt_or_lt.resolve_left h)).symm
      refine disjoint_left.2 fun x hx h'x => lt_irrefl (f x) ?_
      calc
        f x < (t : ‚Ñù‚â•0‚àû) ^ (i + 1) := hx.2.2
        _ ‚â§ (t : ‚Ñù‚â•0‚àû) ^ j := (ENNReal.zpow_le_of_le (ENNReal.one_le_coe_iff.2 ht.le) h)
        _ ‚â§ f x := h'x.2.1
    ¬∑ intro n
      exact hs.inter (hf measurableSet_Ico)
  rw [A, B, C, add_assoc]

section PseudoMetricSpace

variable [PseudoMetricSpace Œ±] [MeasurableSpace Œ±] [OpensMeasurableSpace Œ±]

variable [MeasurableSpace Œ≤] {x : Œ±} {Œµ : ‚Ñù}

open Metric

@[measurability]
theorem measurableSet_ball : MeasurableSet (Metric.ball x Œµ) :=
  Metric.isOpen_ball.measurableSet

@[measurability]
theorem measurableSet_closedBall : MeasurableSet (Metric.closedBall x Œµ) :=
  Metric.isClosed_ball.measurableSet

@[measurability]
theorem measurable_infDist {s : Set Œ±} : Measurable fun x => infDist x s :=
  (continuous_infDist_pt s).measurable

@[measurability]
theorem Measurable.infDist {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) {s : Set Œ±} :
    Measurable fun x => infDist (f x) s :=
  measurable_infDist.comp hf

@[measurability]
theorem measurable_infNndist {s : Set Œ±} : Measurable fun x => infNndist x s :=
  (continuous_infNndist_pt s).measurable

@[measurability]
theorem Measurable.infNndist {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) {s : Set Œ±} :
    Measurable fun x => infNndist (f x) s :=
  measurable_infNndist.comp hf

section

variable [SecondCountableTopology Œ±]

@[measurability]
theorem measurable_dist : Measurable fun p : Œ± √ó Œ± => dist p.1 p.2 :=
  continuous_dist.measurable

@[measurability]
theorem Measurable.dist {f g : Œ≤ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun b => dist (f b) (g b) :=
  (@continuous_dist Œ± _).measurable2 hf hg

@[measurability]
theorem measurable_nndist : Measurable fun p : Œ± √ó Œ± => nndist p.1 p.2 :=
  continuous_nndist.measurable

@[measurability]
theorem Measurable.nndist {f g : Œ≤ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun b => nndist (f b) (g b) :=
  (@continuous_nndist Œ± _).measurable2 hf hg

end

end PseudoMetricSpace

section PseudoEMetricSpace

variable [PseudoEMetricSpace Œ±] [MeasurableSpace Œ±] [OpensMeasurableSpace Œ±]

variable [MeasurableSpace Œ≤] {x : Œ±} {Œµ : ‚Ñù‚â•0‚àû}

open EMetric

@[measurability]
theorem measurableSet_eball : MeasurableSet (EMetric.ball x Œµ) :=
  EMetric.isOpen_ball.measurableSet

@[measurability]
theorem measurable_edist_right : Measurable (edist x) :=
  (continuous_const.edist continuous_id).measurable

@[measurability]
theorem measurable_edist_left : Measurable fun y => edist y x :=
  (continuous_id.edist continuous_const).measurable

@[measurability]
theorem measurable_infEdist {s : Set Œ±} : Measurable fun x => infEdist x s :=
  continuous_infEdist.measurable

@[measurability]
theorem Measurable.infEdist {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) {s : Set Œ±} :
    Measurable fun x => infEdist (f x) s :=
  measurable_infEdist.comp hf

open Metric EMetric

/-- If a set has a closed thickening with finite measure, then the measure of its `r`-closed
thickenings converges to the measure of its closure as `r` tends to `0`. -/
theorem tendsto_measure_cthickening {Œº : Measure Œ±} {s : Set Œ±}
    (hs : ‚àÉ R > 0, Œº (cthickening R s) ‚â† ‚àû) :
    Tendsto (fun r => Œº (cthickening r s)) (ùìù 0) (ùìù (Œº (closure s))) := by
  have A : Tendsto (fun r => Œº (cthickening r s)) (ùìù[Ioi 0] 0) (ùìù (Œº (closure s))) := by
    rw [closure_eq_iInter_cthickening]
    exact
      tendsto_measure_biInter_gt (fun r _ => isClosed_cthickening.measurableSet)
        (fun i j _ ij => cthickening_mono ij _) hs
  have B : Tendsto (fun r => Œº (cthickening r s)) (ùìù[Iic 0] 0) (ùìù (Œº (closure s))) := by
    apply Tendsto.congr' _ tendsto_const_nhds
    filter_upwards [self_mem_nhdsWithin (Œ± := ‚Ñù)] with _ hr
    rw [cthickening_of_nonpos hr]
  convert B.sup A
  exact (nhds_left_sup_nhds_right' 0).symm

/-- If a closed set has a closed thickening with finite measure, then the measure of its closed
`r`-thickenings converge to its measure as `r` tends to `0`. -/
theorem tendsto_measure_cthickening_of_isClosed {Œº : Measure Œ±} {s : Set Œ±}
    (hs : ‚àÉ R > 0, Œº (cthickening R s) ‚â† ‚àû) (h's : IsClosed s) :
    Tendsto (fun r => Œº (cthickening r s)) (ùìù 0) (ùìù (Œº s)) := by
  convert tendsto_measure_cthickening hs
  exact h's.closure_eq.symm

/-- If a set has a thickening with finite measure, then the measures of its `r`-thickenings
converge to the measure of its closure as `r > 0` tends to `0`. -/
theorem tendsto_measure_thickening {Œº : Measure Œ±} {s : Set Œ±}
    (hs : ‚àÉ R > 0, Œº (thickening R s) ‚â† ‚àû) :
    Tendsto (fun r => Œº (thickening r s)) (ùìù[>] 0) (ùìù (Œº (closure s))) := by
  rw [closure_eq_iInter_thickening]
  exact tendsto_measure_biInter_gt (fun r _ => isOpen_thickening.measurableSet)
      (fun i j _ ij => thickening_mono ij _) hs

/-- If a closed set has a thickening with finite measure, then the measure of its
`r`-thickenings converge to its measure as `r > 0` tends to `0`. -/
theorem tendsto_measure_thickening_of_isClosed {Œº : Measure Œ±} {s : Set Œ±}
    (hs : ‚àÉ R > 0, Œº (thickening R s) ‚â† ‚àû) (h's : IsClosed s) :
    Tendsto (fun r => Œº (thickening r s)) (ùìù[>] 0) (ùìù (Œº s)) := by
  convert tendsto_measure_thickening hs
  exact h's.closure_eq.symm

variable [SecondCountableTopology Œ±]

@[measurability]
theorem measurable_edist : Measurable fun p : Œ± √ó Œ± => edist p.1 p.2 :=
  continuous_edist.measurable

@[measurability]
theorem Measurable.edist {f g : Œ≤ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun b => edist (f b) (g b) :=
  (@continuous_edist Œ± _).measurable2 hf hg

@[measurability]
theorem AEMeasurable.edist {f g : Œ≤ ‚Üí Œ±} {Œº : Measure Œ≤} (hf : AEMeasurable f Œº)
    (hg : AEMeasurable g Œº) : AEMeasurable (fun a => edist (f a) (g a)) Œº :=
  (@continuous_edist Œ± _).aemeasurable2 hf hg

end PseudoEMetricSpace

/-- Given a compact set in a proper space, the measure of its `r`-closed thickenings converges to
its measure as `r` tends to `0`. -/
theorem tendsto_measure_cthickening_of_isCompact [MetricSpace Œ±] [MeasurableSpace Œ±]
    [OpensMeasurableSpace Œ±] [ProperSpace Œ±] {Œº : Measure Œ±} [IsFiniteMeasureOnCompacts Œº]
    {s : Set Œ±} (hs : IsCompact s) :
    Tendsto (fun r => Œº (Metric.cthickening r s)) (ùìù 0) (ùìù (Œº s)) :=
  tendsto_measure_cthickening_of_isClosed
    ‚ü®1, zero_lt_one, hs.isBounded.cthickening.measure_lt_top.ne‚ü© hs.isClosed

namespace Real

open MeasurableSpace MeasureTheory

theorem borel_eq_generateFrom_Ioo_rat :
    borel ‚Ñù = .generateFrom (‚ãÉ (a : ‚Ñö) (b : ‚Ñö) (_ : a < b), {Ioo (a : ‚Ñù) (b : ‚Ñù)}) :=
  isTopologicalBasis_Ioo_rat.borel_eq_generateFrom

theorem borel_eq_generateFrom_Iio_rat : borel ‚Ñù = .generateFrom (‚ãÉ a : ‚Ñö, {Iio (a : ‚Ñù)}) := by
  rw [borel_eq_generateFrom_Iio]
  refine le_antisymm
    (generateFrom_le ?_)
    (generateFrom_mono <| iUnion_subset fun q ‚Ü¶ singleton_subset_iff.mpr <| mem_range_self _)
  rintro _ ‚ü®a, rfl‚ü©
  have : IsLUB (range ((‚Üë) : ‚Ñö ‚Üí ‚Ñù) ‚à© Iio a) a := by
    simp [isLUB_iff_le_iff, mem_upperBounds, ‚Üê le_iff_forall_rat_lt_imp_le]
  rw [‚Üê this.biUnion_Iio_eq, ‚Üê image_univ, ‚Üê image_inter_preimage, univ_inter, biUnion_image]
  exact MeasurableSet.biUnion (to_countable _)
    fun b _ => GenerateMeasurable.basic (Iio (b : ‚Ñù)) (by simp)

theorem borel_eq_generateFrom_Ioi_rat : borel ‚Ñù = .generateFrom (‚ãÉ a : ‚Ñö, {Ioi (a : ‚Ñù)}) := by
  rw [borel_eq_generateFrom_Ioi]
  refine le_antisymm
    (generateFrom_le ?_)
    (generateFrom_mono <| iUnion_subset fun q ‚Ü¶ singleton_subset_iff.mpr <| mem_range_self _)
  rintro _ ‚ü®a, rfl‚ü©
  have : IsGLB (range ((‚Üë) : ‚Ñö ‚Üí ‚Ñù) ‚à© Ioi a) a := by
    simp [isGLB_iff_le_iff, mem_lowerBounds, ‚Üê le_iff_forall_lt_rat_imp_le]
  rw [‚Üê this.biUnion_Ioi_eq, ‚Üê image_univ, ‚Üê image_inter_preimage, univ_inter, biUnion_image]
  exact MeasurableSet.biUnion (to_countable _)
    fun b _ => GenerateMeasurable.basic (Ioi (b : ‚Ñù)) (by simp)

theorem borel_eq_generateFrom_Iic_rat : borel ‚Ñù = .generateFrom (‚ãÉ a : ‚Ñö, {Iic (a : ‚Ñù)}) := by
  rw [borel_eq_generateFrom_Ioi_rat, iUnion_singleton_eq_range, iUnion_singleton_eq_range]
  refine le_antisymm (generateFrom_le ?_) (generateFrom_le ?_) <;>
  rintro _ ‚ü®q, rfl‚ü© <;>
  dsimp only <;>
  [rw [‚Üê compl_Iic]; rw [‚Üê compl_Ioi]] <;>
  exact MeasurableSet.compl (GenerateMeasurable.basic _ (mem_range_self q))

theorem borel_eq_generateFrom_Ici_rat : borel ‚Ñù = .generateFrom (‚ãÉ a : ‚Ñö, {Ici (a : ‚Ñù)}) := by
  rw [borel_eq_generateFrom_Iio_rat, iUnion_singleton_eq_range, iUnion_singleton_eq_range]
  refine le_antisymm (generateFrom_le ?_) (generateFrom_le ?_) <;>
  rintro _ ‚ü®q, rfl‚ü© <;>
  dsimp only <;>
  [rw [‚Üê compl_Ici]; rw [‚Üê compl_Iio]] <;>
  exact MeasurableSet.compl (GenerateMeasurable.basic _ (mem_range_self q))

theorem isPiSystem_Ioo_rat :
    IsPiSystem (‚ãÉ (a : ‚Ñö) (b : ‚Ñö) (_ : a < b), {Ioo (a : ‚Ñù) (b : ‚Ñù)}) := by
  convert isPiSystem_Ioo ((‚Üë) : ‚Ñö ‚Üí ‚Ñù) ((‚Üë) : ‚Ñö ‚Üí ‚Ñù)
  ext x
  simp [eq_comm]

theorem isPiSystem_Iio_rat : IsPiSystem (‚ãÉ a : ‚Ñö, {Iio (a : ‚Ñù)}) := by
  convert isPiSystem_image_Iio (((‚Üë) : ‚Ñö ‚Üí ‚Ñù) '' univ)
  ext x
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]

theorem isPiSystem_Ioi_rat : IsPiSystem (‚ãÉ a : ‚Ñö, {Ioi (a : ‚Ñù)}) := by
  convert isPiSystem_image_Ioi (((‚Üë) : ‚Ñö ‚Üí ‚Ñù) '' univ)
  ext x
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]

theorem isPiSystem_Iic_rat : IsPiSystem (‚ãÉ a : ‚Ñö, {Iic (a : ‚Ñù)}) := by
  convert isPiSystem_image_Iic (((‚Üë) : ‚Ñö ‚Üí ‚Ñù) '' univ)
  ext x
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]

theorem isPiSystem_Ici_rat : IsPiSystem (‚ãÉ a : ‚Ñö, {Ici (a : ‚Ñù)}) := by
  convert isPiSystem_image_Ici (((‚Üë) : ‚Ñö ‚Üí ‚Ñù) '' univ)
  ext x
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]

/-- The intervals `(-(n + 1), (n + 1))` form a finite spanning sets in the set of open intervals
with rational endpoints for a locally finite measure `Œº` on `‚Ñù`. -/
def finiteSpanningSetsInIooRat (Œº : Measure ‚Ñù) [IsLocallyFiniteMeasure Œº] :
    Œº.FiniteSpanningSetsIn (‚ãÉ (a : ‚Ñö) (b : ‚Ñö) (_ : a < b), {Ioo (a : ‚Ñù) (b : ‚Ñù)}) where
  set n := Ioo (-(n + 1)) (n + 1)
  set_mem n := by
    simp only [mem_iUnion, mem_singleton_iff]
    refine' ‚ü®-(n + 1 : ‚Ñï), n + 1, _, by simp‚ü©
    -- TODO: norm_cast fails here?
    exact (neg_nonpos.2 (@Nat.cast_nonneg ‚Ñö _ (n + 1))).trans_lt n.cast_add_one_pos
  finite n := measure_Ioo_lt_top
  spanning :=
    iUnion_eq_univ_iff.2 fun x =>
      ‚ü®‚åä|x|‚åã‚Çä, neg_lt.1 ((neg_le_abs_self x).trans_lt (Nat.lt_floor_add_one _)),
        (le_abs_self x).trans_lt (Nat.lt_floor_add_one _)‚ü©

theorem measure_ext_Ioo_rat {Œº ŒΩ : Measure ‚Ñù} [IsLocallyFiniteMeasure Œº]
    (h : ‚àÄ a b : ‚Ñö, Œº (Ioo a b) = ŒΩ (Ioo a b)) : Œº = ŒΩ :=
  (finiteSpanningSetsInIooRat Œº).ext borel_eq_generateFrom_Ioo_rat isPiSystem_Ioo_rat <| by
    simp only [mem_iUnion, mem_singleton_iff]
    rintro _ ‚ü®a, b, -, rfl‚ü©
    apply h

end Real

variable [MeasurableSpace Œ±]

@[measurability]
theorem measurable_real_toNNReal : Measurable Real.toNNReal :=
  continuous_real_toNNReal.measurable

@[measurability]
theorem Measurable.real_toNNReal {f : Œ± ‚Üí ‚Ñù} (hf : Measurable f) :
    Measurable fun x => Real.toNNReal (f x) :=
  measurable_real_toNNReal.comp hf

@[measurability]
theorem AEMeasurable.real_toNNReal {f : Œ± ‚Üí ‚Ñù} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => Real.toNNReal (f x)) Œº :=
  measurable_real_toNNReal.comp_aemeasurable hf

@[measurability]
theorem measurable_coe_nnreal_real : Measurable ((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù) :=
  NNReal.continuous_coe.measurable

@[measurability]
theorem Measurable.coe_nnreal_real {f : Œ± ‚Üí ‚Ñù‚â•0} (hf : Measurable f) :
    Measurable fun x => (f x : ‚Ñù) :=
  measurable_coe_nnreal_real.comp hf

@[measurability]
theorem AEMeasurable.coe_nnreal_real {f : Œ± ‚Üí ‚Ñù‚â•0} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x : ‚Ñù)) Œº :=
  measurable_coe_nnreal_real.comp_aemeasurable hf

@[measurability]
theorem measurable_coe_nnreal_ennreal : Measurable ((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0‚àû) :=
  ENNReal.continuous_coe.measurable

@[measurability]
theorem Measurable.coe_nnreal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0} (hf : Measurable f) :
    Measurable fun x => (f x : ‚Ñù‚â•0‚àû) :=
  ENNReal.continuous_coe.measurable.comp hf

@[measurability]
theorem AEMeasurable.coe_nnreal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x : ‚Ñù‚â•0‚àû)) Œº :=
  ENNReal.continuous_coe.measurable.comp_aemeasurable hf

@[measurability]
theorem Measurable.ennreal_ofReal {f : Œ± ‚Üí ‚Ñù} (hf : Measurable f) :
    Measurable fun x => ENNReal.ofReal (f x) :=
  ENNReal.continuous_ofReal.measurable.comp hf

@[simp, norm_cast]
theorem measurable_coe_nnreal_real_iff {f : Œ± ‚Üí ‚Ñù‚â•0} :
    Measurable (fun x => f x : Œ± ‚Üí ‚Ñù) ‚Üî Measurable f :=
  ‚ü®fun h => by simpa only [Real.toNNReal_coe] using h.real_toNNReal, Measurable.coe_nnreal_real‚ü©

@[simp, norm_cast]
theorem aEMeasurable_coe_nnreal_real_iff {f : Œ± ‚Üí ‚Ñù‚â•0} {Œº : Measure Œ±} :
    AEMeasurable (fun x => f x : Œ± ‚Üí ‚Ñù) Œº ‚Üî AEMeasurable f Œº :=
  ‚ü®fun h => by simpa only [Real.toNNReal_coe] using h.real_toNNReal, AEMeasurable.coe_nnreal_real‚ü©

/-- The set of finite `‚Ñù‚â•0‚àû` numbers is `MeasurableEquiv` to `‚Ñù‚â•0`. -/
def MeasurableEquiv.ennrealEquivNNReal : { r : ‚Ñù‚â•0‚àû | r ‚â† ‚àû } ‚âÉ·µê ‚Ñù‚â•0 :=
  ENNReal.neTopHomeomorphNNReal.toMeasurableEquiv

namespace ENNReal

theorem measurable_of_measurable_nnreal {f : ‚Ñù‚â•0‚àû ‚Üí Œ±} (h : Measurable fun p : ‚Ñù‚â•0 => f p) :
    Measurable f :=
  measurable_of_measurable_on_compl_singleton ‚àû
    (MeasurableEquiv.ennrealEquivNNReal.symm.measurable_comp_iff.1 h)

/-- `‚Ñù‚â•0‚àû` is `MeasurableEquiv` to `‚Ñù‚â•0 ‚äï Unit`. -/
def ennrealEquivSum : ‚Ñù‚â•0‚àû ‚âÉ·µê Sum ‚Ñù‚â•0 Unit :=
  { Equiv.optionEquivSumPUnit ‚Ñù‚â•0 with
    measurable_toFun := measurable_of_measurable_nnreal measurable_inl
    measurable_invFun :=
      measurable_sum measurable_coe_nnreal_ennreal (@measurable_const ‚Ñù‚â•0‚àû Unit _ _ ‚àû) }

open Function (uncurry)

theorem measurable_of_measurable_nnreal_prod [MeasurableSpace Œ≤] [MeasurableSpace Œ≥]
    {f : ‚Ñù‚â•0‚àû √ó Œ≤ ‚Üí Œ≥} (H‚ÇÅ : Measurable fun p : ‚Ñù‚â•0 √ó Œ≤ => f (p.1, p.2))
    (H‚ÇÇ : Measurable fun x => f (‚àû, x)) : Measurable f :=
  let e : ‚Ñù‚â•0‚àû √ó Œ≤ ‚âÉ·µê Sum (‚Ñù‚â•0 √ó Œ≤) (Unit √ó Œ≤) :=
    (ennrealEquivSum.prodCongr (MeasurableEquiv.refl Œ≤)).trans
      (MeasurableEquiv.sumProdDistrib _ _ _)
  e.symm.measurable_comp_iff.1 <| measurable_sum H‚ÇÅ (H‚ÇÇ.comp measurable_id.snd)

theorem measurable_of_measurable_nnreal_nnreal [MeasurableSpace Œ≤] {f : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû ‚Üí Œ≤}
    (h‚ÇÅ : Measurable fun p : ‚Ñù‚â•0 √ó ‚Ñù‚â•0 => f (p.1, p.2)) (h‚ÇÇ : Measurable fun r : ‚Ñù‚â•0 => f (‚àû, r))
    (h‚ÇÉ : Measurable fun r : ‚Ñù‚â•0 => f (r, ‚àû)) : Measurable f :=
  measurable_of_measurable_nnreal_prod
    (measurable_swap_iff.1 <| measurable_of_measurable_nnreal_prod (h‚ÇÅ.comp measurable_swap) h‚ÇÉ)
    (measurable_of_measurable_nnreal h‚ÇÇ)

@[measurability]
theorem measurable_ofReal : Measurable ENNReal.ofReal :=
  ENNReal.continuous_ofReal.measurable

@[measurability]
theorem measurable_toReal : Measurable ENNReal.toReal :=
  ENNReal.measurable_of_measurable_nnreal measurable_coe_nnreal_real

@[measurability]
theorem measurable_toNNReal : Measurable ENNReal.toNNReal :=
  ENNReal.measurable_of_measurable_nnreal measurable_id

instance instMeasurableMul‚ÇÇ : MeasurableMul‚ÇÇ ‚Ñù‚â•0‚àû := by
  refine' ‚ü®measurable_of_measurable_nnreal_nnreal _ _ _‚ü©
  ¬∑ simp only [‚Üê ENNReal.coe_mul, measurable_mul.coe_nnreal_ennreal]
  ¬∑ simp only [ENNReal.top_mul', ENNReal.coe_eq_zero]
    exact measurable_const.piecewise (measurableSet_singleton _) measurable_const
  ¬∑ simp only [ENNReal.mul_top', ENNReal.coe_eq_zero]
    exact measurable_const.piecewise (measurableSet_singleton _) measurable_const

instance instMeasurableSub‚ÇÇ : MeasurableSub‚ÇÇ ‚Ñù‚â•0‚àû :=
  ‚ü®by
    apply measurable_of_measurable_nnreal_nnreal <;>
      simp [‚Üê WithTop.coe_sub]; exact continuous_sub.measurable.coe_nnreal_ennreal‚ü©

instance instMeasurableInv : MeasurableInv ‚Ñù‚â•0‚àû :=
  ‚ü®continuous_inv.measurable‚ü©

instance : MeasurableSMul ‚Ñù‚â•0 ‚Ñù‚â•0‚àû where
  measurable_const_smul := by
    simp_rw [ENNReal.smul_def]
    exact fun _ ‚Ü¶ MeasurableSMul.measurable_const_smul _
  measurable_smul_const := fun x ‚Ü¶ by
    simp_rw [ENNReal.smul_def]
    exact measurable_coe_nnreal_ennreal.mul_const _

end ENNReal

@[measurability]
theorem Measurable.ennreal_toNNReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) :
    Measurable fun x => (f x).toNNReal :=
  ENNReal.measurable_toNNReal.comp hf

@[measurability]
theorem AEMeasurable.ennreal_toNNReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x).toNNReal) Œº :=
  ENNReal.measurable_toNNReal.comp_aemeasurable hf

@[simp, norm_cast]
theorem measurable_coe_nnreal_ennreal_iff {f : Œ± ‚Üí ‚Ñù‚â•0} :
    (Measurable fun x => (f x : ‚Ñù‚â•0‚àû)) ‚Üî Measurable f :=
  ‚ü®fun h => h.ennreal_toNNReal, fun h => h.coe_nnreal_ennreal‚ü©

@[simp, norm_cast]
theorem aemeasurable_coe_nnreal_ennreal_iff {f : Œ± ‚Üí ‚Ñù‚â•0} {Œº : Measure Œ±} :
    AEMeasurable (fun x => (f x : ‚Ñù‚â•0‚àû)) Œº ‚Üî AEMeasurable f Œº :=
  ‚ü®fun h => h.ennreal_toNNReal, fun h => h.coe_nnreal_ennreal‚ü©

@[measurability]
theorem Measurable.ennreal_toReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) :
    Measurable fun x => ENNReal.toReal (f x) :=
  ENNReal.measurable_toReal.comp hf

@[measurability]
theorem AEMeasurable.ennreal_toReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => ENNReal.toReal (f x)) Œº :=
  ENNReal.measurable_toReal.comp_aemeasurable hf

/-- note: `‚Ñù‚â•0‚àû` can probably be generalized in a future version of this lemma. -/
@[measurability]
theorem Measurable.ennreal_tsum {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} (h : ‚àÄ i, Measurable (f i)) :
    Measurable fun x => ‚àë' i, f i x := by
  simp_rw [ENNReal.tsum_eq_iSup_sum]
  apply measurable_iSup
  exact fun s => s.measurable_sum fun i _ => h i

@[measurability]
theorem Measurable.ennreal_tsum' {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} (h : ‚àÄ i, Measurable (f i)) :
    Measurable (‚àë' i, f i) := by
  convert Measurable.ennreal_tsum h with x
  exact tsum_apply (Pi.summable.2 fun _ => ENNReal.summable)

@[measurability]
theorem Measurable.nnreal_tsum {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0} (h : ‚àÄ i, Measurable (f i)) :
    Measurable fun x => ‚àë' i, f i x := by
  simp_rw [NNReal.tsum_eq_toNNReal_tsum]
  exact (Measurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_toNNReal

@[measurability]
theorem AEMeasurable.ennreal_tsum {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure Œ±}
    (h : ‚àÄ i, AEMeasurable (f i) Œº) : AEMeasurable (fun x => ‚àë' i, f i x) Œº := by
  simp_rw [ENNReal.tsum_eq_iSup_sum]
  apply aemeasurable_iSup
  exact fun s => Finset.aemeasurable_sum s fun i _ => h i

@[measurability]
theorem AEMeasurable.nnreal_tsum {Œ± : Type*} [MeasurableSpace Œ±] {Œπ : Type*} [Countable Œπ]
    {f : Œπ ‚Üí Œ± ‚Üí NNReal} {Œº : MeasureTheory.Measure Œ±} (h : ‚àÄ i : Œπ, AEMeasurable (f i) Œº) :
    AEMeasurable (fun x : Œ± => ‚àë' i : Œπ, f i x) Œº := by
  simp_rw [NNReal.tsum_eq_toNNReal_tsum]
  exact (AEMeasurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_toNNReal

@[measurability]
theorem measurable_coe_real_ereal : Measurable ((‚Üë) : ‚Ñù ‚Üí EReal) :=
  continuous_coe_real_ereal.measurable

@[measurability]
theorem Measurable.coe_real_ereal {f : Œ± ‚Üí ‚Ñù} (hf : Measurable f) :
    Measurable fun x => (f x : EReal) :=
  measurable_coe_real_ereal.comp hf

@[measurability]
theorem AEMeasurable.coe_real_ereal {f : Œ± ‚Üí ‚Ñù} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x : EReal)) Œº :=
  measurable_coe_real_ereal.comp_aemeasurable hf

/-- The set of finite `EReal` numbers is `MeasurableEquiv` to `‚Ñù`. -/
def MeasurableEquiv.erealEquivReal : ({‚ä•, ‚ä§}·∂ú : Set EReal) ‚âÉ·µê ‚Ñù :=
  EReal.neBotTopHomeomorphReal.toMeasurableEquiv

theorem EReal.measurable_of_measurable_real {f : EReal ‚Üí Œ±} (h : Measurable fun p : ‚Ñù => f p) :
    Measurable f :=
  measurable_of_measurable_on_compl_finite {‚ä•, ‚ä§} (by simp)
    (MeasurableEquiv.erealEquivReal.symm.measurable_comp_iff.1 h)

@[measurability]
theorem measurable_ereal_toReal : Measurable EReal.toReal :=
  EReal.measurable_of_measurable_real (by simpa using measurable_id)

@[measurability]
theorem Measurable.ereal_toReal {f : Œ± ‚Üí EReal} (hf : Measurable f) :
    Measurable fun x => (f x).toReal :=
  measurable_ereal_toReal.comp hf

@[measurability]
theorem AEMeasurable.ereal_toReal {f : Œ± ‚Üí EReal} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x).toReal) Œº :=
  measurable_ereal_toReal.comp_aemeasurable hf

@[measurability]
theorem measurable_coe_ennreal_ereal : Measurable ((‚Üë) : ‚Ñù‚â•0‚àû ‚Üí EReal) :=
  continuous_coe_ennreal_ereal.measurable

@[measurability]
theorem Measurable.coe_ereal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) :
    Measurable fun x => (f x : EReal) :=
  measurable_coe_ennreal_ereal.comp hf

@[measurability]
theorem AEMeasurable.coe_ereal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x : EReal)) Œº :=
  measurable_coe_ennreal_ereal.comp_aemeasurable hf

section NormedAddCommGroup

variable [NormedAddCommGroup Œ±] [OpensMeasurableSpace Œ±] [MeasurableSpace Œ≤]

@[measurability]
theorem measurable_norm : Measurable (norm : Œ± ‚Üí ‚Ñù) :=
  continuous_norm.measurable

@[measurability]
theorem Measurable.norm {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) : Measurable fun a => norm (f a) :=
  measurable_norm.comp hf

@[measurability]
theorem AEMeasurable.norm {f : Œ≤ ‚Üí Œ±} {Œº : Measure Œ≤} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun a => norm (f a)) Œº :=
  measurable_norm.comp_aemeasurable hf

@[measurability]
theorem measurable_nnnorm : Measurable (nnnorm : Œ± ‚Üí ‚Ñù‚â•0) :=
  continuous_nnnorm.measurable

@[measurability]
theorem Measurable.nnnorm {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) : Measurable fun a => ‚Äñf a‚Äñ‚Çä :=
  measurable_nnnorm.comp hf

@[measurability]
theorem AEMeasurable.nnnorm {f : Œ≤ ‚Üí Œ±} {Œº : Measure Œ≤} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun a => ‚Äñf a‚Äñ‚Çä) Œº :=
  measurable_nnnorm.comp_aemeasurable hf

@[measurability]
theorem measurable_ennnorm : Measurable fun x : Œ± => (‚Äñx‚Äñ‚Çä : ‚Ñù‚â•0‚àû) :=
  measurable_nnnorm.coe_nnreal_ennreal

@[measurability]
theorem Measurable.ennnorm {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) : Measurable fun a => (‚Äñf a‚Äñ‚Çä : ‚Ñù‚â•0‚àû) :=
  hf.nnnorm.coe_nnreal_ennreal

@[measurability]
theorem AEMeasurable.ennnorm {f : Œ≤ ‚Üí Œ±} {Œº : Measure Œ≤} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun a => (‚Äñf a‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) Œº :=
  measurable_ennnorm.comp_aemeasurable hf

end NormedAddCommGroup
