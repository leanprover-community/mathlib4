/-
Copyright (c) 2017 Johannes HÃ¶lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes HÃ¶lzl, Yury Kudryashov
-/
import Mathlib.Analysis.Normed.Group.Basic
import Mathlib.MeasureTheory.Function.AEMeasurableSequence
import Mathlib.MeasureTheory.Group.Arithmetic
import Mathlib.MeasureTheory.Lattice
import Mathlib.Topology.Algebra.Order.LiminfLimsup
import Mathlib.Topology.ContinuousFunction.Basic
import Mathlib.Topology.Instances.EReal
import Mathlib.Topology.MetricSpace.HausdorffDistance
import Mathlib.Topology.GDelta
import Mathlib.Topology.Order.Lattice
import Mathlib.Topology.Semicontinuous

#align_import measure_theory.constructions.borel_space.basic from "leanprover-community/mathlib"@"9f55d0d4363ae59948c33864cbc52e0b12e0e8ce"

/-!
# Borel (measurable) space

## Main definitions

* `borel Î±` : the least `Ïƒ`-algebra that contains all open sets;
* `class BorelSpace` : a space with `TopologicalSpace` and `MeasurableSpace` structures
  such that `â€¹MeasurableSpace Î±â€º = borel Î±`;
* `class OpensMeasurableSpace` : a space with `TopologicalSpace` and `MeasurableSpace`
  structures such that all open sets are measurable; equivalently, `borel Î± â‰¤ â€¹MeasurableSpace Î±â€º`.
* `BorelSpace` instances on `Empty`, `Unit`, `Bool`, `Nat`, `Int`, `Rat`;
* `MeasurableSpace` and `BorelSpace` instances on `â„`, `â„â‰¥0`, `â„â‰¥0âˆ`.

## Main statements

* `IsOpen.measurableSet`, `IsClosed.measurableSet`: open and closed sets are measurable;
* `Continuous.measurable` : a continuous function is measurable;
* `Continuous.measurable2` : if `f : Î± â†’ Î²` and `g : Î± â†’ Î³` are measurable and `op : Î² Ã— Î³ â†’ Î´`
  is continuous, then `fun x => op (f x, g y)` is measurable;
* `Measurable.add` etc : dot notation for arithmetic operations on `Measurable` predicates,
  and similarly for `dist` and `edist`;
* `AEMeasurable.add` : similar dot notation for almost everywhere measurable functions;
* `Measurable.ennreal*` : special cases for arithmetic operations on `â„â‰¥0âˆ`.
-/


noncomputable section

open Classical Set Filter MeasureTheory

open Classical BigOperators Topology NNReal ENNReal MeasureTheory

universe u v w x y

variable {Î± Î² Î³ Î³â‚‚ Î´ : Type*} {Î¹ : Sort y} {s t u : Set Î±}

open MeasurableSpace TopologicalSpace

/-- `MeasurableSpace` structure generated by `TopologicalSpace`. -/
def borel (Î± : Type u) [TopologicalSpace Î±] : MeasurableSpace Î± :=
  generateFrom { s : Set Î± | IsOpen s }
#align borel borel

theorem borel_anti : Antitone (@borel Î±) := fun _ _ h =>
  MeasurableSpace.generateFrom_le fun _ hs => .basic _ (h _ hs)
#align borel_anti borel_anti

theorem borel_eq_top_of_discrete [TopologicalSpace Î±] [DiscreteTopology Î±] : borel Î± = âŠ¤ :=
  top_le_iff.1 fun s _ => GenerateMeasurable.basic s (isOpen_discrete s)
#align borel_eq_top_of_discrete borel_eq_top_of_discrete

theorem borel_eq_top_of_countable [TopologicalSpace Î±] [T1Space Î±] [Countable Î±] : borel Î± = âŠ¤ := by
  refine' top_le_iff.1 fun s _ => biUnion_of_singleton s â–¸ _
  -- âŠ¢ MeasurableSet (â‹ƒ (x : Î±) (_ : x âˆˆ s), {x})
  apply MeasurableSet.biUnion s.to_countable
  -- âŠ¢ âˆ€ (b : Î±), b âˆˆ s â†’ MeasurableSet {b}
  intro x _
  -- âŠ¢ MeasurableSet {x}
  apply MeasurableSet.of_compl
  -- âŠ¢ MeasurableSet {x}á¶œ
  apply GenerateMeasurable.basic
  -- âŠ¢ {x}á¶œ âˆˆ {s | IsOpen s}
  exact isClosed_singleton.isOpen_compl
  -- ğŸ‰ no goals
#align borel_eq_top_of_countable borel_eq_top_of_countable

theorem borel_eq_generateFrom_of_subbasis {s : Set (Set Î±)} [t : TopologicalSpace Î±]
    [SecondCountableTopology Î±] (hs : t = .generateFrom s) : borel Î± = .generateFrom s :=
  le_antisymm
    (generateFrom_le fun u (hu : t.IsOpen u) => by
      rw [hs] at hu
      -- âŠ¢ MeasurableSet u
      induction hu
      case basic u hu => exact GenerateMeasurable.basic u hu
      -- ğŸ‰ no goals
      case univ => exact @MeasurableSet.univ Î± (generateFrom s)
      -- âŠ¢ MeasurableSet (sâœ âˆ© tâœ)
      -- ğŸ‰ no goals
      case inter sâ‚ sâ‚‚ _ _ hsâ‚ hsâ‚‚ => exact @MeasurableSet.inter Î± (generateFrom s) _ _ hsâ‚ hsâ‚‚
      -- âŠ¢ MeasurableSet (â‹ƒâ‚€ Sâœ)
      -- ğŸ‰ no goals
      case
        sUnion f hf ih =>
        rcases isOpen_sUnion_countable f (by rwa [hs]) with âŸ¨v, hv, vf, vuâŸ©
        rw [â† vu]
        exact @MeasurableSet.sUnion Î± (generateFrom s) _ hv fun x xv => ih _ (vf xv))
    (generateFrom_le fun u hu =>
      GenerateMeasurable.basic _ <| show t.IsOpen u by rw [hs]; exact GenerateOpen.basic _ hu)
                                                       -- âŠ¢ TopologicalSpace.IsOpen u
                                                                -- ğŸ‰ no goals
#align borel_eq_generate_from_of_subbasis borel_eq_generateFrom_of_subbasis

theorem TopologicalSpace.IsTopologicalBasis.borel_eq_generateFrom [TopologicalSpace Î±]
    [SecondCountableTopology Î±] {s : Set (Set Î±)} (hs : IsTopologicalBasis s) :
    borel Î± = .generateFrom s :=
  borel_eq_generateFrom_of_subbasis hs.eq_generateFrom
#align topological_space.is_topological_basis.borel_eq_generate_from TopologicalSpace.IsTopologicalBasis.borel_eq_generateFrom

theorem isPiSystem_isOpen [TopologicalSpace Î±] : IsPiSystem (IsOpen : Set Î± â†’ Prop) :=
  fun _s hs _t ht _ => IsOpen.inter hs ht
#align is_pi_system_is_open isPiSystem_isOpen

theorem borel_eq_generateFrom_isClosed [TopologicalSpace Î±] :
    borel Î± = .generateFrom { s | IsClosed s } :=
  le_antisymm
    (generateFrom_le fun _t ht =>
      @MeasurableSet.of_compl Î± _ (generateFrom { s | IsClosed s })
        (GenerateMeasurable.basic _ <| isClosed_compl_iff.2 ht))
    (generateFrom_le fun _t ht =>
      @MeasurableSet.of_compl Î± _ (borel Î±) (GenerateMeasurable.basic _ <| isOpen_compl_iff.2 ht))
#align borel_eq_generate_from_is_closed borel_eq_generateFrom_isClosed

section OrderTopology

variable (Î±)

variable [TopologicalSpace Î±] [SecondCountableTopology Î±] [LinearOrder Î±] [OrderTopology Î±]

theorem borel_eq_generateFrom_Iio : borel Î± = .generateFrom (range Iio) := by
  refine' le_antisymm _ (generateFrom_le _)
  -- âŠ¢ borel Î± â‰¤ MeasurableSpace.generateFrom (range Iio)
  Â· rw [borel_eq_generateFrom_of_subbasis (@OrderTopology.topology_eq_generate_intervals Î± _ _ _)]
    -- âŠ¢ MeasurableSpace.generateFrom {s | âˆƒ a, s = Ioi a âˆ¨ s = Iio a} â‰¤ MeasurableSp â€¦
    letI : MeasurableSpace Î± := MeasurableSpace.generateFrom (range Iio)
    -- âŠ¢ MeasurableSpace.generateFrom {s | âˆƒ a, s = Ioi a âˆ¨ s = Iio a} â‰¤ MeasurableSp â€¦
    have H : âˆ€ a : Î±, MeasurableSet (Iio a) := fun a => GenerateMeasurable.basic _ âŸ¨_, rflâŸ©
    -- âŠ¢ MeasurableSpace.generateFrom {s | âˆƒ a, s = Ioi a âˆ¨ s = Iio a} â‰¤ MeasurableSp â€¦
    refine' generateFrom_le _
    -- âŠ¢ âˆ€ (t : Set Î±), t âˆˆ {s | âˆƒ a, s = Ioi a âˆ¨ s = Iio a} â†’ MeasurableSet t
    rintro _ âŸ¨a, rfl | rflâŸ© <;> [skip; apply H]
    -- âŠ¢ MeasurableSet (Ioi a)
    by_cases h : âˆƒ a', âˆ€ b, a < b â†” a' â‰¤ b
    -- âŠ¢ MeasurableSet (Ioi a)
    Â· rcases h with âŸ¨a', ha'âŸ©
      -- âŠ¢ MeasurableSet (Ioi a)
      rw [(_ : Ioi a = (Iio a')á¶œ)]
      -- âŠ¢ MeasurableSet (Iio a')á¶œ
      Â· exact (H _).compl
        -- ğŸ‰ no goals
      simp [Set.ext_iff, ha']
      -- ğŸ‰ no goals
    Â· rcases isOpen_iUnion_countable (fun a' : { a' : Î± // a < a' } => { b | a'.1 < b }) fun a' =>
          isOpen_lt' _ with âŸ¨v, âŸ¨hvâŸ©, vuâŸ©
      simp [Set.ext_iff] at vu
      -- âŠ¢ MeasurableSet (Ioi a)
      have : Ioi a = â‹ƒ x : v, (Iio x.1.1)á¶œ := by
        simp [Set.ext_iff]
        refine' fun x => âŸ¨fun ax => _, fun âŸ¨a', âŸ¨h, _âŸ©, axâŸ© => lt_of_lt_of_le h axâŸ©
        rcases (vu x).2 (by
          refine' not_imp_comm.1 (fun h => _) h
          exact âŸ¨x, fun b =>
            âŸ¨fun ab => le_of_not_lt fun h' => h âŸ¨b, ab, h'âŸ©, lt_of_lt_of_le axâŸ©âŸ©) with âŸ¨a', hâ‚, hâ‚‚âŸ©
        Â· exact âŸ¨a', hâ‚, le_of_lt hâ‚‚âŸ©
      rw [this]
      -- âŠ¢ MeasurableSet (â‹ƒ (x : â†‘v), (Iio â†‘â†‘x)á¶œ)
      skip
      -- âŠ¢ MeasurableSet (â‹ƒ (x : â†‘v), (Iio â†‘â†‘x)á¶œ)
      apply MeasurableSet.iUnion
      -- âŠ¢ âˆ€ (b : â†‘v), MeasurableSet (Iio â†‘â†‘b)á¶œ
      exact fun _ => (H _).compl
      -- ğŸ‰ no goals
  Â· rw [forall_range_iff]
    -- âŠ¢ âˆ€ (i : Î±), MeasurableSet (Iio i)
    intro a
    -- âŠ¢ MeasurableSet (Iio a)
    exact GenerateMeasurable.basic _ isOpen_Iio
    -- ğŸ‰ no goals
#align borel_eq_generate_from_Iio borel_eq_generateFrom_Iio

theorem borel_eq_generateFrom_Ioi : borel Î± = .generateFrom (range Ioi) :=
  @borel_eq_generateFrom_Iio Î±áµ’áµˆ _ (by infer_instance : SecondCountableTopology Î±) _ _
                                       -- ğŸ‰ no goals
#align borel_eq_generate_from_Ioi borel_eq_generateFrom_Ioi

theorem borel_eq_generateFrom_Iic :
    borel Î± = MeasurableSpace.generateFrom (range Iic) := by
  rw [borel_eq_generateFrom_Ioi]
  -- âŠ¢ MeasurableSpace.generateFrom (range Ioi) = MeasurableSpace.generateFrom (ran â€¦
  refine' le_antisymm _ _
  -- âŠ¢ MeasurableSpace.generateFrom (range Ioi) â‰¤ MeasurableSpace.generateFrom (ran â€¦
  Â· refine' MeasurableSpace.generateFrom_le fun t ht => _
    -- âŠ¢ MeasurableSet t
    obtain âŸ¨u, rflâŸ© := ht
    -- âŠ¢ MeasurableSet (Ioi u)
    rw [â† compl_Iic]
    -- âŠ¢ MeasurableSet (Iic u)á¶œ
    exact (MeasurableSpace.measurableSet_generateFrom (mem_range.mpr âŸ¨u, rflâŸ©)).compl
    -- ğŸ‰ no goals
  Â· refine' MeasurableSpace.generateFrom_le fun t ht => _
    -- âŠ¢ MeasurableSet t
    obtain âŸ¨u, rflâŸ© := ht
    -- âŠ¢ MeasurableSet (Iic u)
    rw [â† compl_Ioi]
    -- âŠ¢ MeasurableSet (Ioi u)á¶œ
    exact (MeasurableSpace.measurableSet_generateFrom (mem_range.mpr âŸ¨u, rflâŸ©)).compl
    -- ğŸ‰ no goals
#align borel_eq_generate_from_Iic borel_eq_generateFrom_Iic

theorem borel_eq_generateFrom_Ici : borel Î± = MeasurableSpace.generateFrom (range Ici) :=
  @borel_eq_generateFrom_Iic Î±áµ’áµˆ _ _ _ _
#align borel_eq_generate_from_Ici borel_eq_generateFrom_Ici

end OrderTopology

theorem borel_comap {f : Î± â†’ Î²} {t : TopologicalSpace Î²} :
    @borel Î± (t.induced f) = (@borel Î² t).comap f :=
  comap_generateFrom.symm
#align borel_comap borel_comap

theorem Continuous.borel_measurable [TopologicalSpace Î±] [TopologicalSpace Î²] {f : Î± â†’ Î²}
    (hf : Continuous f) : @Measurable Î± Î² (borel Î±) (borel Î²) f :=
  Measurable.of_le_map <|
    generateFrom_le fun s hs => GenerateMeasurable.basic (f â»Â¹' s) (hs.preimage hf)
#align continuous.borel_measurable Continuous.borel_measurable

/-- A space with `MeasurableSpace` and `TopologicalSpace` structures such that
all open sets are measurable. -/
class OpensMeasurableSpace (Î± : Type*) [TopologicalSpace Î±] [h : MeasurableSpace Î±] : Prop where
  /-- Borel-measurable sets are measurable. -/
  borel_le : borel Î± â‰¤ h
#align opens_measurable_space OpensMeasurableSpace
#align opens_measurable_space.borel_le OpensMeasurableSpace.borel_le

/-- A space with `MeasurableSpace` and `TopologicalSpace` structures such that
the `Ïƒ`-algebra of measurable sets is exactly the `Ïƒ`-algebra generated by open sets. -/
class BorelSpace (Î± : Type*) [TopologicalSpace Î±] [MeasurableSpace Î±] : Prop where
  /-- The measurable sets are exactly the Borel-measurable sets. -/
  measurable_eq : â€¹MeasurableSpace Î±â€º = borel Î±
#align borel_space BorelSpace
#align borel_space.measurable_eq BorelSpace.measurable_eq

namespace Mathlib.Tactic.Borelize

open Lean Elab Term Tactic Meta

/-- The behaviour of `borelize Î±` depends on the existing assumptions on `Î±`.

- if `Î±` is a topological space with instances `[MeasurableSpace Î±] [BorelSpace Î±]`, then
  `borelize Î±` replaces the former instance by `borel Î±`;
- otherwise, `borelize Î±` adds instances `borel Î± : MeasurableSpace Î±` and `âŸ¨rflâŸ© : BorelSpace Î±`.

Finally, `borelize Î± Î² Î³` runs `borelize Î±; borelize Î²; borelize Î³`.
-/
syntax "borelize" (ppSpace colGt term:max)* : tactic

/-- Add instances `borel e : MeasurableSpace e` and `âŸ¨rflâŸ© : BorelSpace e`. -/
def addBorelInstance (e : Expr) : TacticM Unit := do
  let t â† Lean.Elab.Term.exprToSyntax e
  evalTactic <| â† `(tactic|
    refine_lift
      letI : MeasurableSpace $t := borel $t
      haveI : BorelSpace $t := âŸ¨rflâŸ©
      ?_)

/-- Given a type `e`, an assumption `i : MeasurableSpace e`, and an instance `[BorelSpace e]`,
replace `i` with `borel e`. -/
def borelToRefl (e : Expr) (i : FVarId) : TacticM Unit := do
  let t â† Lean.Elab.Term.exprToSyntax e
  evalTactic <| â† `(tactic|
    have := @BorelSpace.measurable_eq $t _ _ _)
  liftMetaTactic fun m => return [â† subst m i]
  evalTactic <| â† `(tactic|
    refine_lift
      letI : MeasurableSpace $t := borel $t
      ?_)

/-- Given a type `$t`, if there is an assumption `[i : MeasurableSpace $t]`, then try to prove
`[BorelSpace $t]` and replace `i` with `borel $t`. Otherwise, add instances
`borel $t : MeasurableSpace $t` and `âŸ¨rflâŸ© : BorelSpace $t`. -/
def borelize (t : Term) : TacticM Unit := withMainContext <| do
  let u â† mkFreshLevelMVar
  let e â† withoutRecover <| Tactic.elabTermEnsuringType t (mkSort (mkLevelSucc u))
  let i? â† findLocalDeclWithType? (â† mkAppOptM ``MeasurableSpace #[e])
  i?.elim (addBorelInstance e) (borelToRefl e)

elab_rules : tactic
  | `(tactic| borelize $[$t:term]*) => t.forM borelize

end Mathlib.Tactic.Borelize

instance (priority := 100) OrderDual.opensMeasurableSpace {Î± : Type*} [TopologicalSpace Î±]
    [MeasurableSpace Î±] [h : OpensMeasurableSpace Î±] : OpensMeasurableSpace Î±áµ’áµˆ where
  borel_le := h.borel_le
#align order_dual.opens_measurable_space OrderDual.opensMeasurableSpace

instance (priority := 100) OrderDual.borelSpace {Î± : Type*} [TopologicalSpace Î±]
    [MeasurableSpace Î±] [h : BorelSpace Î±] : BorelSpace Î±áµ’áµˆ where
  measurable_eq := h.measurable_eq
#align order_dual.borel_space OrderDual.borelSpace

/-- In a `BorelSpace` all open sets are measurable. -/
instance (priority := 100) BorelSpace.opensMeasurable {Î± : Type*} [TopologicalSpace Î±]
    [MeasurableSpace Î±] [BorelSpace Î±] : OpensMeasurableSpace Î± :=
  âŸ¨ge_of_eq <| BorelSpace.measurable_eqâŸ©
#align borel_space.opens_measurable BorelSpace.opensMeasurable

instance Subtype.borelSpace {Î± : Type*} [TopologicalSpace Î±] [MeasurableSpace Î±]
    [hÎ± : BorelSpace Î±] (s : Set Î±) : BorelSpace s :=
  âŸ¨by borelize Î±; symm; apply borel_comapâŸ©
      -- âŠ¢ instMeasurableSpace = borel â†‘s
                  -- âŠ¢ borel â†‘s = instMeasurableSpace
                        -- ğŸ‰ no goals
#align subtype.borel_space Subtype.borelSpace

instance Subtype.opensMeasurableSpace {Î± : Type*} [TopologicalSpace Î±] [MeasurableSpace Î±]
    [h : OpensMeasurableSpace Î±] (s : Set Î±) : OpensMeasurableSpace s :=
  âŸ¨by
    rw [borel_comap]
    -- âŠ¢ MeasurableSpace.comap val (borel Î±) â‰¤ instMeasurableSpace
    exact comap_mono h.1âŸ©
    -- ğŸ‰ no goals
#align subtype.opens_measurable_space Subtype.opensMeasurableSpace

lemma opensMeasurableSpace_iff_forall_measurableSet
    [TopologicalSpace Î±] [MeasurableSpace Î±] :
    OpensMeasurableSpace Î± â†”  (âˆ€ (s : Set Î±), IsOpen s â†’ MeasurableSet s) := by
  refine âŸ¨fun h s hs â†¦ ?_, fun h â†¦ âŸ¨generateFrom_le hâŸ©âŸ©
  -- âŠ¢ MeasurableSet s
  exact OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ hs
  -- ğŸ‰ no goals

instance (priority := 100) BorelSpace.countablyGenerated {Î± : Type*} [TopologicalSpace Î±]
    [MeasurableSpace Î±] [BorelSpace Î±] [SecondCountableTopology Î±] : CountablyGenerated Î± := by
  obtain âŸ¨b, bct, -, hbâŸ© := exists_countable_basis Î±
  -- âŠ¢ CountablyGenerated Î±
  refine' âŸ¨âŸ¨b, bct, _âŸ©âŸ©
  -- âŠ¢ instâœÂ² = MeasurableSpace.generateFrom b
  borelize Î±
  -- âŠ¢ borel Î± = MeasurableSpace.generateFrom b
  exact hb.borel_eq_generateFrom
  -- ğŸ‰ no goals
#align borel_space.countably_generated BorelSpace.countablyGenerated

theorem MeasurableSet.induction_on_open [TopologicalSpace Î±] [MeasurableSpace Î±] [BorelSpace Î±]
    {C : Set Î± â†’ Prop} (h_open : âˆ€ U, IsOpen U â†’ C U)
    (h_compl : âˆ€ t, MeasurableSet t â†’ C t â†’ C tá¶œ)
    (h_union :
      âˆ€ f : â„• â†’ Set Î±,
        Pairwise (Disjoint on f) â†’ (âˆ€ i, MeasurableSet (f i)) â†’ (âˆ€ i, C (f i)) â†’ C (â‹ƒ i, f i)) :
    âˆ€ â¦ƒtâ¦„, MeasurableSet t â†’ C t :=
  MeasurableSpace.induction_on_inter BorelSpace.measurable_eq isPiSystem_isOpen
    (h_open _ isOpen_empty) h_open h_compl h_union
#align measurable_set.induction_on_open MeasurableSet.induction_on_open

section

variable [TopologicalSpace Î±] [MeasurableSpace Î±] [OpensMeasurableSpace Î±] [TopologicalSpace Î²]
  [MeasurableSpace Î²] [OpensMeasurableSpace Î²] [TopologicalSpace Î³] [MeasurableSpace Î³]
  [BorelSpace Î³] [TopologicalSpace Î³â‚‚] [MeasurableSpace Î³â‚‚] [BorelSpace Î³â‚‚] [MeasurableSpace Î´]

theorem IsOpen.measurableSet (h : IsOpen s) : MeasurableSet s :=
  OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ h
#align is_open.measurable_set IsOpen.measurableSet

instance (priority := 500) {s : Set Î±} [HasCountableSeparatingOn Î± IsOpen s] :
    HasCountableSeparatingOn Î± MeasurableSet s :=
  .mono (fun _ â†¦ IsOpen.measurableSet) Subset.rfl

@[measurability]
theorem measurableSet_interior : MeasurableSet (interior s) :=
  isOpen_interior.measurableSet
#align measurable_set_interior measurableSet_interior

theorem IsGÎ´.measurableSet (h : IsGÎ´ s) : MeasurableSet s := by
  rcases h with âŸ¨S, hSo, hSc, rflâŸ©
  -- âŠ¢ MeasurableSet (â‹‚â‚€ S)
  exact MeasurableSet.sInter hSc fun t ht => (hSo t ht).measurableSet
  -- ğŸ‰ no goals
set_option linter.uppercaseLean3 false in
#align is_GÎ´.measurable_set IsGÎ´.measurableSet

theorem measurableSet_of_continuousAt {Î²} [EMetricSpace Î²] (f : Î± â†’ Î²) :
    MeasurableSet { x | ContinuousAt f x } :=
  (isGÎ´_setOf_continuousAt f).measurableSet
#align measurable_set_of_continuous_at measurableSet_of_continuousAt

theorem IsClosed.measurableSet (h : IsClosed s) : MeasurableSet s :=
  h.isOpen_compl.measurableSet.of_compl
#align is_closed.measurable_set IsClosed.measurableSet

theorem IsCompact.measurableSet [T2Space Î±] (h : IsCompact s) : MeasurableSet s :=
  h.isClosed.measurableSet
#align is_compact.measurable_set IsCompact.measurableSet

@[measurability]
theorem measurableSet_closure : MeasurableSet (closure s) :=
  isClosed_closure.measurableSet
#align measurable_set_closure measurableSet_closure

theorem measurable_of_isOpen {f : Î´ â†’ Î³} (hf : âˆ€ s, IsOpen s â†’ MeasurableSet (f â»Â¹' s)) :
    Measurable f := by
  rw [â€¹BorelSpace Î³â€º.measurable_eq]
  -- âŠ¢ Measurable f
  exact measurable_generateFrom hf
  -- ğŸ‰ no goals
#align measurable_of_is_open measurable_of_isOpen

theorem measurable_of_isClosed {f : Î´ â†’ Î³} (hf : âˆ€ s, IsClosed s â†’ MeasurableSet (f â»Â¹' s)) :
    Measurable f := by
  apply measurable_of_isOpen; intro s hs
  -- âŠ¢ âˆ€ (s : Set Î³), IsOpen s â†’ MeasurableSet (f â»Â¹' s)
                              -- âŠ¢ MeasurableSet (f â»Â¹' s)
  rw [â† MeasurableSet.compl_iff, â† preimage_compl]; apply hf; rw [isClosed_compl_iff]; exact hs
  -- âŠ¢ MeasurableSet (f â»Â¹' sá¶œ)
                                                    -- âŠ¢ IsClosed sá¶œ
                                                              -- âŠ¢ IsOpen s
                                                                                       -- ğŸ‰ no goals
#align measurable_of_is_closed measurable_of_isClosed

theorem measurable_of_is_closed' {f : Î´ â†’ Î³}
    (hf : âˆ€ s, IsClosed s â†’ s.Nonempty â†’ s â‰  univ â†’ MeasurableSet (f â»Â¹' s)) : Measurable f := by
  apply measurable_of_isClosed; intro s hs
  -- âŠ¢ âˆ€ (s : Set Î³), IsClosed s â†’ MeasurableSet (f â»Â¹' s)
                                -- âŠ¢ MeasurableSet (f â»Â¹' s)
  cases' eq_empty_or_nonempty s with h1 h1; Â· simp [h1]
  -- âŠ¢ MeasurableSet (f â»Â¹' s)
                                              -- ğŸ‰ no goals
  by_cases h2 : s = univ; Â· simp [h2]
  -- âŠ¢ MeasurableSet (f â»Â¹' s)
                            -- ğŸ‰ no goals
  exact hf s hs h1 h2
  -- ğŸ‰ no goals
#align measurable_of_is_closed' measurable_of_is_closed'

instance nhds_isMeasurablyGenerated (a : Î±) : (ğ“ a).IsMeasurablyGenerated := by
  rw [nhds, iInf_subtype']
  -- âŠ¢ IsMeasurablyGenerated (â¨… (x : { s // s âˆˆ {s | a âˆˆ s âˆ§ IsOpen s} }), ğ“Ÿ â†‘x)
  refine' @Filter.iInf_isMeasurablyGenerated Î± _ _ _ fun i => _
  -- âŠ¢ IsMeasurablyGenerated (ğ“Ÿ â†‘i)
  exact i.2.2.measurableSet.principal_isMeasurablyGenerated
  -- ğŸ‰ no goals
#align nhds_is_measurably_generated nhds_isMeasurablyGenerated

/-- If `s` is a measurable set, then `ğ“[s] a` is a measurably generated filter for
each `a`. This cannot be an `instance` because it depends on a non-instance `hs : MeasurableSet s`.
-/
theorem MeasurableSet.nhdsWithin_isMeasurablyGenerated {s : Set Î±} (hs : MeasurableSet s) (a : Î±) :
    (ğ“[s] a).IsMeasurablyGenerated :=
  haveI := hs.principal_isMeasurablyGenerated
  Filter.inf_isMeasurablyGenerated _ _
#align measurable_set.nhds_within_is_measurably_generated MeasurableSet.nhdsWithin_isMeasurablyGenerated

-- see Note [lower instance priority]
instance (priority := 100) OpensMeasurableSpace.toMeasurableSingletonClass [T1Space Î±] :
    MeasurableSingletonClass Î± :=
  âŸ¨fun _ => isClosed_singleton.measurableSetâŸ©
#align opens_measurable_space.to_measurable_singleton_class OpensMeasurableSpace.toMeasurableSingletonClass

instance Pi.opensMeasurableSpace {Î¹ : Type*} {Ï€ : Î¹ â†’ Type*} [Countable Î¹]
    [t' : âˆ€ i, TopologicalSpace (Ï€ i)] [âˆ€ i, MeasurableSpace (Ï€ i)]
    [âˆ€ i, SecondCountableTopology (Ï€ i)] [âˆ€ i, OpensMeasurableSpace (Ï€ i)] :
    OpensMeasurableSpace (âˆ€ i, Ï€ i) := by
  constructor
  -- âŠ¢ borel ((i : Î¹) â†’ Ï€ i) â‰¤ MeasurableSpace.pi
  have : Pi.topologicalSpace = .generateFrom { t | âˆƒ (s : âˆ€ a, Set (Ï€ a)) (i : Finset Î¹),
      (âˆ€ a âˆˆ i, s a âˆˆ countableBasis (Ï€ a)) âˆ§ t = pi (â†‘i) s } := by
    rw [funext fun a => @eq_generateFrom_countableBasis (Ï€ a) _ _, pi_generateFrom_eq]
  rw [borel_eq_generateFrom_of_subbasis this]
  -- âŠ¢ MeasurableSpace.generateFrom {t | âˆƒ s i, (âˆ€ (a : Î¹), a âˆˆ i â†’ s a âˆˆ countable â€¦
  apply generateFrom_le
  -- âŠ¢ âˆ€ (t : Set ((a : Î¹) â†’ Ï€ a)), t âˆˆ {t | âˆƒ s i, (âˆ€ (a : Î¹), a âˆˆ i â†’ s a âˆˆ count â€¦
  rintro _ âŸ¨s, i, hi, rflâŸ©
  -- âŠ¢ MeasurableSet (Set.pi (â†‘i) s)
  refine' MeasurableSet.pi i.countable_toSet fun a ha => IsOpen.measurableSet _
  -- âŠ¢ IsOpen (s a)
  rw [eq_generateFrom_countableBasis (Ï€ a)]
  -- âŠ¢ IsOpen (s a)
  exact .basic _ (hi a ha)
  -- ğŸ‰ no goals
#align pi.opens_measurable_space Pi.opensMeasurableSpace

/-- The typeclass `SecondCountableTopologyEither Î± Î²` registers the fact that at least one of
the two spaces has second countable topology. This is the right assumption to ensure that continuous
maps from `Î±` to `Î²` are strongly measurable. -/
class SecondCountableTopologyEither (Î± Î² : Type*) [TopologicalSpace Î±] [TopologicalSpace Î²] :
  Prop where
  /-- The projection out of `SecondCountableTopologyEither` -/
  out : SecondCountableTopology Î± âˆ¨ SecondCountableTopology Î²
#align second_countable_topology_either SecondCountableTopologyEither

instance (priority := 100) secondCountableTopologyEither_of_left (Î± Î² : Type*) [TopologicalSpace Î±]
    [TopologicalSpace Î²] [SecondCountableTopology Î±] : SecondCountableTopologyEither Î± Î²
    where out := Or.inl (by infer_instance)
                            -- ğŸ‰ no goals
#align second_countable_topology_either_of_left secondCountableTopologyEither_of_left

instance (priority := 100) secondCountableTopologyEither_of_right (Î± Î² : Type*)
    [TopologicalSpace Î±] [TopologicalSpace Î²] [SecondCountableTopology Î²] :
    SecondCountableTopologyEither Î± Î² where out := Or.inr (by infer_instance)
                                                              -- ğŸ‰ no goals
#align second_countable_topology_either_of_right secondCountableTopologyEither_of_right

/-- If either `Î±` or `Î²` has second-countable topology, then the open sets in `Î± Ã— Î²` belong to the
product sigma-algebra. -/
instance Prod.opensMeasurableSpace [h : SecondCountableTopologyEither Î± Î²] :
    OpensMeasurableSpace (Î± Ã— Î²) := by
  apply opensMeasurableSpace_iff_forall_measurableSet.2 (fun s hs â†¦ ?_)
  -- âŠ¢ MeasurableSet s
  rcases h.out with hÎ±|hÎ²
  -- âŠ¢ MeasurableSet s
  Â· let F : Set Î± â†’ Set Î² := fun a â†¦ {y | âˆƒ b, IsOpen b âˆ§ y âˆˆ b âˆ§ a Ã—Ë¢ b âŠ† s}
    -- âŠ¢ MeasurableSet s
    have A : âˆ€ a, IsOpen (F a) := by
      intro a
      apply isOpen_iff_forall_mem_open.2
      rintro y âŸ¨b, b_open, yb, hbâŸ©
      exact âŸ¨b, fun z zb â†¦ âŸ¨b, b_open, zb, hbâŸ©, b_open, ybâŸ©
    have : s = â‹ƒ a âˆˆ countableBasis Î±, a Ã—Ë¢ F a := by
      apply Subset.antisymm
      Â· rintro âŸ¨y1, y2âŸ© hy
        rcases isOpen_prod_iff.1 hs y1 y2 hy with âŸ¨u, v, u_open, v_open, yu, yv, huvâŸ©
        obtain âŸ¨a, ha, ya, auâŸ© : âˆƒ a âˆˆ countableBasis Î±, y1 âˆˆ a âˆ§ a âŠ† u :=
          IsTopologicalBasis.exists_subset_of_mem_open (isBasis_countableBasis Î±) yu u_open
        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop]
        exact âŸ¨a, ya, ha, v, v_open, yv, (Set.prod_mono_left au).trans huvâŸ©
      Â· rintro âŸ¨y1, y2âŸ© hy
        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop] at hy
        rcases hy with âŸ¨a, ya, -, b, -, yb, hbâŸ©
        exact hb (mem_prod.2 âŸ¨ya, ybâŸ©)
    rw [this]
    -- âŠ¢ MeasurableSet (â‹ƒ (a : Set Î±) (_ : a âˆˆ countableBasis Î±), a Ã—Ë¢ F a)
    apply MeasurableSet.biUnion (countable_countableBasis Î±) (fun a ha â†¦ ?_)
    -- âŠ¢ MeasurableSet (a Ã—Ë¢ F a)
    exact (isOpen_of_mem_countableBasis ha).measurableSet.prod (A a).measurableSet
    -- ğŸ‰ no goals
  Â· let F : Set Î² â†’ Set Î± := fun a â†¦ {y | âˆƒ b, IsOpen b âˆ§ y âˆˆ b âˆ§ b Ã—Ë¢ a âŠ† s}
    -- âŠ¢ MeasurableSet s
    have A : âˆ€ a, IsOpen (F a) := by
      intro a
      apply isOpen_iff_forall_mem_open.2
      rintro y âŸ¨b, b_open, yb, hbâŸ©
      exact âŸ¨b, fun z zb â†¦ âŸ¨b, b_open, zb, hbâŸ©, b_open, ybâŸ©
    have : s = â‹ƒ a âˆˆ countableBasis Î², F a Ã—Ë¢ a := by
      apply Subset.antisymm
      Â· rintro âŸ¨y1, y2âŸ© hy
        rcases isOpen_prod_iff.1 hs y1 y2 hy with âŸ¨u, v, u_open, v_open, yu, yv, huvâŸ©
        obtain âŸ¨a, ha, ya, auâŸ© : âˆƒ a âˆˆ countableBasis Î², y2 âˆˆ a âˆ§ a âŠ† v :=
          IsTopologicalBasis.exists_subset_of_mem_open (isBasis_countableBasis Î²) yv v_open
        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop]
        exact âŸ¨a, âŸ¨u, u_open, yu, (Set.prod_mono_right au).trans huvâŸ©, ha, yaâŸ©
      Â· rintro âŸ¨y1, y2âŸ© hy
        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop] at hy
        rcases hy with âŸ¨a, âŸ¨b, -, yb, hbâŸ©, -, yaâŸ©
        exact hb (mem_prod.2 âŸ¨yb, yaâŸ©)
    rw [this]
    -- âŠ¢ MeasurableSet (â‹ƒ (a : Set Î²) (_ : a âˆˆ countableBasis Î²), F a Ã—Ë¢ a)
    apply MeasurableSet.biUnion (countable_countableBasis Î²) (fun a ha â†¦ ?_)
    -- âŠ¢ MeasurableSet (F a Ã—Ë¢ a)
    exact (A a).measurableSet.prod (isOpen_of_mem_countableBasis ha).measurableSet
    -- ğŸ‰ no goals

variable {Î±' : Type*} [TopologicalSpace Î±'] [MeasurableSpace Î±']

theorem interior_ae_eq_of_null_frontier {Î¼ : Measure Î±'} {s : Set Î±'} (h : Î¼ (frontier s) = 0) :
    interior s =áµ[Î¼] s :=
  interior_subset.eventuallyLE.antisymm <| subset_closure.eventuallyLE.trans (ae_le_set.2 h)
#align interior_ae_eq_of_null_frontier interior_ae_eq_of_null_frontier

theorem measure_interior_of_null_frontier {Î¼ : Measure Î±'} {s : Set Î±'} (h : Î¼ (frontier s) = 0) :
    Î¼ (interior s) = Î¼ s :=
  measure_congr (interior_ae_eq_of_null_frontier h)
#align measure_interior_of_null_frontier measure_interior_of_null_frontier

theorem nullMeasurableSet_of_null_frontier {s : Set Î±} {Î¼ : Measure Î±} (h : Î¼ (frontier s) = 0) :
    NullMeasurableSet s Î¼ :=
  âŸ¨interior s, isOpen_interior.measurableSet, (interior_ae_eq_of_null_frontier h).symmâŸ©
#align null_measurable_set_of_null_frontier nullMeasurableSet_of_null_frontier

theorem closure_ae_eq_of_null_frontier {Î¼ : Measure Î±'} {s : Set Î±'} (h : Î¼ (frontier s) = 0) :
    closure s =áµ[Î¼] s :=
  ((ae_le_set.2 h).trans interior_subset.eventuallyLE).antisymm <| subset_closure.eventuallyLE
#align closure_ae_eq_of_null_frontier closure_ae_eq_of_null_frontier

theorem measure_closure_of_null_frontier {Î¼ : Measure Î±'} {s : Set Î±'} (h : Î¼ (frontier s) = 0) :
    Î¼ (closure s) = Î¼ s :=
  measure_congr (closure_ae_eq_of_null_frontier h)
#align measure_closure_of_null_frontier measure_closure_of_null_frontier

section Preorder

variable [Preorder Î±] [OrderClosedTopology Î±] {a b x : Î±}

@[simp, measurability]
theorem measurableSet_Ici : MeasurableSet (Ici a) :=
  isClosed_Ici.measurableSet
#align measurable_set_Ici measurableSet_Ici

@[simp, measurability]
theorem measurableSet_Iic : MeasurableSet (Iic a) :=
  isClosed_Iic.measurableSet
#align measurable_set_Iic measurableSet_Iic

@[simp, measurability]
theorem measurableSet_Icc : MeasurableSet (Icc a b) :=
  isClosed_Icc.measurableSet
#align measurable_set_Icc measurableSet_Icc

instance nhdsWithin_Ici_isMeasurablyGenerated : (ğ“[Ici b] a).IsMeasurablyGenerated :=
  measurableSet_Ici.nhdsWithin_isMeasurablyGenerated _
#align nhds_within_Ici_is_measurably_generated nhdsWithin_Ici_isMeasurablyGenerated

instance nhdsWithin_Iic_isMeasurablyGenerated : (ğ“[Iic b] a).IsMeasurablyGenerated :=
  measurableSet_Iic.nhdsWithin_isMeasurablyGenerated _
#align nhds_within_Iic_is_measurably_generated nhdsWithin_Iic_isMeasurablyGenerated

instance nhdsWithin_Icc_isMeasurablyGenerated : IsMeasurablyGenerated (ğ“[Icc a b] x) := by
  rw [â† Ici_inter_Iic, nhdsWithin_inter]
  -- âŠ¢ IsMeasurablyGenerated (ğ“[Ici a] x âŠ“ ğ“[Iic b] x)
  infer_instance
  -- ğŸ‰ no goals
#align nhds_within_Icc_is_measurably_generated nhdsWithin_Icc_isMeasurablyGenerated

instance atTop_isMeasurablyGenerated : (Filter.atTop : Filter Î±).IsMeasurablyGenerated :=
  @Filter.iInf_isMeasurablyGenerated _ _ _ _ fun a =>
    (measurableSet_Ici : MeasurableSet (Ici a)).principal_isMeasurablyGenerated
#align at_top_is_measurably_generated atTop_isMeasurablyGenerated

instance atBot_isMeasurablyGenerated : (Filter.atBot : Filter Î±).IsMeasurablyGenerated :=
  @Filter.iInf_isMeasurablyGenerated _ _ _ _ fun a =>
    (measurableSet_Iic : MeasurableSet (Iic a)).principal_isMeasurablyGenerated
#align at_bot_is_measurably_generated atBot_isMeasurablyGenerated

end Preorder

section PartialOrder

variable [PartialOrder Î±] [OrderClosedTopology Î±] [SecondCountableTopology Î±] {a b : Î±}

@[measurability]
theorem measurableSet_le' : MeasurableSet { p : Î± Ã— Î± | p.1 â‰¤ p.2 } :=
  OrderClosedTopology.isClosed_le'.measurableSet
#align measurable_set_le' measurableSet_le'

@[measurability]
theorem measurableSet_le {f g : Î´ â†’ Î±} (hf : Measurable f) (hg : Measurable g) :
    MeasurableSet { a | f a â‰¤ g a } :=
  hf.prod_mk hg measurableSet_le'
#align measurable_set_le measurableSet_le

end PartialOrder

section LinearOrder

variable [LinearOrder Î±] [OrderClosedTopology Î±] {a b x : Î±}

-- we open this locale only here to avoid issues with list being treated as intervals above
open Interval

@[simp, measurability]
theorem measurableSet_Iio : MeasurableSet (Iio a) :=
  isOpen_Iio.measurableSet
#align measurable_set_Iio measurableSet_Iio

@[simp, measurability]
theorem measurableSet_Ioi : MeasurableSet (Ioi a) :=
  isOpen_Ioi.measurableSet
#align measurable_set_Ioi measurableSet_Ioi

@[simp, measurability]
theorem measurableSet_Ioo : MeasurableSet (Ioo a b) :=
  isOpen_Ioo.measurableSet
#align measurable_set_Ioo measurableSet_Ioo

@[simp, measurability]
theorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=
  measurableSet_Ioi.inter measurableSet_Iic
#align measurable_set_Ioc measurableSet_Ioc

@[simp, measurability]
theorem measurableSet_Ico : MeasurableSet (Ico a b) :=
  measurableSet_Ici.inter measurableSet_Iio
#align measurable_set_Ico measurableSet_Ico

instance nhdsWithin_Ioi_isMeasurablyGenerated : (ğ“[Ioi b] a).IsMeasurablyGenerated :=
  measurableSet_Ioi.nhdsWithin_isMeasurablyGenerated _
#align nhds_within_Ioi_is_measurably_generated nhdsWithin_Ioi_isMeasurablyGenerated

instance nhdsWithin_Iio_isMeasurablyGenerated : (ğ“[Iio b] a).IsMeasurablyGenerated :=
  measurableSet_Iio.nhdsWithin_isMeasurablyGenerated _
#align nhds_within_Iio_is_measurably_generated nhdsWithin_Iio_isMeasurablyGenerated

instance nhdsWithin_uIcc_isMeasurablyGenerated : IsMeasurablyGenerated (ğ“[[[a, b]]] x) :=
  nhdsWithin_Icc_isMeasurablyGenerated
#align nhds_within_uIcc_is_measurably_generated nhdsWithin_uIcc_isMeasurablyGenerated

@[measurability]
theorem measurableSet_lt' [SecondCountableTopology Î±] : MeasurableSet { p : Î± Ã— Î± | p.1 < p.2 } :=
  (isOpen_lt continuous_fst continuous_snd).measurableSet
#align measurable_set_lt' measurableSet_lt'

@[measurability]
theorem measurableSet_lt [SecondCountableTopology Î±] {f g : Î´ â†’ Î±} (hf : Measurable f)
    (hg : Measurable g) : MeasurableSet { a | f a < g a } :=
  hf.prod_mk hg measurableSet_lt'
#align measurable_set_lt measurableSet_lt

theorem nullMeasurableSet_lt [SecondCountableTopology Î±] {Î¼ : Measure Î´} {f g : Î´ â†’ Î±}
    (hf : AEMeasurable f Î¼) (hg : AEMeasurable g Î¼) : NullMeasurableSet { a | f a < g a } Î¼ :=
  (hf.prod_mk hg).nullMeasurable measurableSet_lt'
#align null_measurable_set_lt nullMeasurableSet_lt

theorem Set.OrdConnected.measurableSet (h : OrdConnected s) : MeasurableSet s := by
  let u := â‹ƒ (x âˆˆ s) (y âˆˆ s), Ioo x y
  -- âŠ¢ MeasurableSet s
  have huopen : IsOpen u := isOpen_biUnion fun _ _ => isOpen_biUnion fun _ _ => isOpen_Ioo
  -- âŠ¢ MeasurableSet s
  have humeas : MeasurableSet u := huopen.measurableSet
  -- âŠ¢ MeasurableSet s
  have hfinite : (s \ u).Finite := s.finite_diff_iUnion_Ioo
  -- âŠ¢ MeasurableSet s
  have : u âŠ† s := iUnionâ‚‚_subset fun x hx => iUnionâ‚‚_subset fun y hy =>
    Ioo_subset_Icc_self.trans (h.out hx hy)
  rw [â† union_diff_cancel this]
  -- âŠ¢ MeasurableSet (u âˆª s \ u)
  exact humeas.union hfinite.measurableSet
  -- ğŸ‰ no goals
#align set.ord_connected.measurable_set Set.OrdConnected.measurableSet

theorem IsPreconnected.measurableSet (h : IsPreconnected s) : MeasurableSet s :=
  h.ordConnected.measurableSet
#align is_preconnected.measurable_set IsPreconnected.measurableSet

theorem generateFrom_Ico_mem_le_borel {Î± : Type*} [TopologicalSpace Î±] [LinearOrder Î±]
    [OrderClosedTopology Î±] (s t : Set Î±) :
    MeasurableSpace.generateFrom { S | âˆƒ l âˆˆ s, âˆƒ u âˆˆ t, l < u âˆ§ Ico l u = S }
      â‰¤ borel Î± := by
  apply generateFrom_le
  -- âŠ¢ âˆ€ (t_1 : Set Î±), t_1 âˆˆ {S | âˆƒ l, l âˆˆ s âˆ§ âˆƒ u, u âˆˆ t âˆ§ l < u âˆ§ Ico l u = S} â†’ â€¦
  borelize Î±
  -- âŠ¢ âˆ€ (t_1 : Set Î±), t_1 âˆˆ {S | âˆƒ l, l âˆˆ s âˆ§ âˆƒ u, u âˆˆ t âˆ§ l < u âˆ§ Ico l u = S} â†’ â€¦
  rintro _ âŸ¨a, -, b, -, -, rflâŸ©
  -- âŠ¢ MeasurableSet (Ico a b)
  exact measurableSet_Ico
  -- ğŸ‰ no goals
#align generate_from_Ico_mem_le_borel generateFrom_Ico_mem_le_borel

theorem Dense.borel_eq_generateFrom_Ico_mem_aux {Î± : Type*} [TopologicalSpace Î±] [LinearOrder Î±]
    [OrderTopology Î±] [SecondCountableTopology Î±] {s : Set Î±} (hd : Dense s)
    (hbot : âˆ€ x, IsBot x â†’ x âˆˆ s) (hIoo : âˆ€ x y : Î±, x < y â†’ Ioo x y = âˆ… â†’ y âˆˆ s) :
    borel Î± = .generateFrom { S : Set Î± | âˆƒ l âˆˆ s, âˆƒ u âˆˆ s, l < u âˆ§ Ico l u = S } := by
  set S : Set (Set Î±) := { S | âˆƒ l âˆˆ s, âˆƒ u âˆˆ s, l < u âˆ§ Ico l u = S }
  -- âŠ¢ borel Î± = MeasurableSpace.generateFrom S
  refine' le_antisymm _ (generateFrom_Ico_mem_le_borel _ _)
  -- âŠ¢ borel Î± â‰¤ MeasurableSpace.generateFrom S
  letI : MeasurableSpace Î± := generateFrom S
  -- âŠ¢ borel Î± â‰¤ MeasurableSpace.generateFrom S
  rw [borel_eq_generateFrom_Iio]
  -- âŠ¢ MeasurableSpace.generateFrom (range Iio) â‰¤ MeasurableSpace.generateFrom S
  refine' generateFrom_le (forall_range_iff.2 fun a => _)
  -- âŠ¢ MeasurableSet (Iio a)
  rcases hd.exists_countable_dense_subset_bot_top with âŸ¨t, hts, hc, htd, htb, -âŸ©
  -- âŠ¢ MeasurableSet (Iio a)
  by_cases ha : âˆ€ b < a, (Ioo b a).Nonempty
  -- âŠ¢ MeasurableSet (Iio a)
  Â· convert_to MeasurableSet (â‹ƒ (l âˆˆ t) (u âˆˆ t) (_ : l < u) (_ : u â‰¤ a), Ico l u)
    -- âŠ¢ Iio a = â‹ƒ (l : Î±) (_ : l âˆˆ t) (u : Î±) (_ : u âˆˆ t) (_ : l < u) (_ : u â‰¤ a), I â€¦
    Â· ext y
      -- âŠ¢ y âˆˆ Iio a â†” y âˆˆ â‹ƒ (l : Î±) (_ : l âˆˆ t) (u : Î±) (_ : u âˆˆ t) (_ : l < u) (_ : u â€¦
      simp only [mem_iUnion, mem_Iio, mem_Ico]
      -- âŠ¢ y < a â†” âˆƒ i h i_1 h h h, i â‰¤ y âˆ§ y < i_1
      constructor
      -- âŠ¢ y < a â†’ âˆƒ i h i_1 h h h, i â‰¤ y âˆ§ y < i_1
      Â· intro hy
        -- âŠ¢ âˆƒ i h i_1 h h h, i â‰¤ y âˆ§ y < i_1
        rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) y with âŸ¨l, hlt, hlyâŸ©
        -- âŠ¢ âˆƒ i h i_1 h h h, i â‰¤ y âˆ§ y < i_1
        rcases htd.exists_mem_open isOpen_Ioo (ha y hy) with âŸ¨u, hut, hyu, huaâŸ©
        -- âŠ¢ âˆƒ i h i_1 h h h, i â‰¤ y âˆ§ y < i_1
        exact âŸ¨l, hlt, u, hut, hly.trans_lt hyu, hua.le, hly, hyuâŸ©
        -- ğŸ‰ no goals
      Â· rintro âŸ¨l, -, u, -, -, hua, -, hyuâŸ©
        -- âŠ¢ y < a
        exact hyu.trans_le hua
        -- ğŸ‰ no goals
    Â· refine' MeasurableSet.biUnion hc fun a ha => MeasurableSet.biUnion hc fun b hb => _
      -- âŠ¢ MeasurableSet (â‹ƒ (_ : a < b) (_ : b â‰¤ aâœ), Ico a b)
      refine' MeasurableSet.iUnion fun hab => MeasurableSet.iUnion fun _ => _
      -- âŠ¢ MeasurableSet (Ico a b)
      exact .basic _ âŸ¨a, hts ha, b, hts hb, hab, mem_singleton _âŸ©
      -- ğŸ‰ no goals
  Â· simp only [not_forall, not_nonempty_iff_eq_empty] at ha
    -- âŠ¢ MeasurableSet (Iio a)
    replace ha : a âˆˆ s := hIoo ha.choose a ha.choose_spec.fst ha.choose_spec.snd
    -- âŠ¢ MeasurableSet (Iio a)
    convert_to MeasurableSet (â‹ƒ (l âˆˆ t) (_ : l < a), Ico l a)
    -- âŠ¢ Iio a = â‹ƒ (l : Î±) (_ : l âˆˆ t) (_ : l < a), Ico l a
    Â· symm
      -- âŠ¢ â‹ƒ (l : Î±) (_ : l âˆˆ t) (_ : l < a), Ico l a = Iio a
      simp only [â† Ici_inter_Iio, â† iUnion_inter, inter_eq_right_iff_subset, subset_def, mem_iUnion,
        mem_Ici, mem_Iio]
      intro x hx
      -- âŠ¢ âˆƒ i h h, i â‰¤ x
      rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) x with âŸ¨z, hzt, hzxâŸ©
      -- âŠ¢ âˆƒ i h h, i â‰¤ x
      exact âŸ¨z, hzt, hzx.trans_lt hx, hzxâŸ©
      -- ğŸ‰ no goals
    Â· refine' .biUnion hc fun x hx => MeasurableSet.iUnion fun hlt => _
      -- âŠ¢ MeasurableSet (Ico x a)
      exact .basic _ âŸ¨x, hts hx, a, ha, hlt, mem_singleton _âŸ©
      -- ğŸ‰ no goals
#align dense.borel_eq_generate_from_Ico_mem_aux Dense.borel_eq_generateFrom_Ico_mem_aux

theorem Dense.borel_eq_generateFrom_Ico_mem {Î± : Type*} [TopologicalSpace Î±] [LinearOrder Î±]
    [OrderTopology Î±] [SecondCountableTopology Î±] [DenselyOrdered Î±] [NoMinOrder Î±] {s : Set Î±}
    (hd : Dense s) :
    borel Î± = .generateFrom { S : Set Î± | âˆƒ l âˆˆ s, âˆƒ u âˆˆ s, l < u âˆ§ Ico l u = S } :=
  hd.borel_eq_generateFrom_Ico_mem_aux (by simp) fun x y hxy H =>
                                           -- ğŸ‰ no goals
    ((nonempty_Ioo.2 hxy).ne_empty H).elim
#align dense.borel_eq_generate_from_Ico_mem Dense.borel_eq_generateFrom_Ico_mem

theorem borel_eq_generateFrom_Ico (Î± : Type*) [TopologicalSpace Î±] [SecondCountableTopology Î±]
    [LinearOrder Î±] [OrderTopology Î±] :
    borel Î± = .generateFrom { S : Set Î± | âˆƒ (l u : Î±), l < u âˆ§ Ico l u = S } := by
  simpa only [exists_prop, mem_univ, true_and_iff] using
    (@dense_univ Î± _).borel_eq_generateFrom_Ico_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ =>
      mem_univ _
#align borel_eq_generate_from_Ico borel_eq_generateFrom_Ico

theorem Dense.borel_eq_generateFrom_Ioc_mem_aux {Î± : Type*} [TopologicalSpace Î±] [LinearOrder Î±]
    [OrderTopology Î±] [SecondCountableTopology Î±] {s : Set Î±} (hd : Dense s)
    (hbot : âˆ€ x, IsTop x â†’ x âˆˆ s) (hIoo : âˆ€ x y : Î±, x < y â†’ Ioo x y = âˆ… â†’ x âˆˆ s) :
    borel Î± = .generateFrom { S : Set Î± | âˆƒ l âˆˆ s, âˆƒ u âˆˆ s, l < u âˆ§ Ioc l u = S } := by
  convert hd.orderDual.borel_eq_generateFrom_Ico_mem_aux hbot fun x y hlt he => hIoo y x hlt _
    using 2
  Â· ext s
    -- âŠ¢ s âˆˆ {S | âˆƒ l, l âˆˆ sâœ âˆ§ âˆƒ u, u âˆˆ sâœ âˆ§ l < u âˆ§ Ioc l u = S} â†” s âˆˆ {S | âˆƒ l, l  â€¦
    constructor <;> rintro âŸ¨l, hl, u, hu, hlt, rflâŸ©
    -- âŠ¢ s âˆˆ {S | âˆƒ l, l âˆˆ sâœ âˆ§ âˆƒ u, u âˆˆ sâœ âˆ§ l < u âˆ§ Ioc l u = S} â†’ s âˆˆ {S | âˆƒ l, l  â€¦
                    -- âŠ¢ Ioc l u âˆˆ {S | âˆƒ l, l âˆˆ â†‘OrderDual.ofDual â»Â¹' s âˆ§ âˆƒ u, u âˆˆ â†‘OrderDual.ofDual â€¦
                    -- âŠ¢ Ico l u âˆˆ {S | âˆƒ l, l âˆˆ s âˆ§ âˆƒ u, u âˆˆ s âˆ§ l < u âˆ§ Ioc l u = S}
    exacts [âŸ¨u, hu, l, hl, hlt, dual_IcoâŸ©, âŸ¨u, hu, l, hl, hlt, dual_IocâŸ©]
    -- ğŸ‰ no goals
  Â· erw [dual_Ioo]
    -- âŠ¢ â†‘OrderDual.ofDual â»Â¹' Ioo x y = âˆ…
    exact he
    -- ğŸ‰ no goals
#align dense.borel_eq_generate_from_Ioc_mem_aux Dense.borel_eq_generateFrom_Ioc_mem_aux

theorem Dense.borel_eq_generateFrom_Ioc_mem {Î± : Type*} [TopologicalSpace Î±] [LinearOrder Î±]
    [OrderTopology Î±] [SecondCountableTopology Î±] [DenselyOrdered Î±] [NoMaxOrder Î±] {s : Set Î±}
    (hd : Dense s) :
    borel Î± = .generateFrom { S : Set Î± | âˆƒ l âˆˆ s, âˆƒ u âˆˆ s, l < u âˆ§ Ioc l u = S } :=
  hd.borel_eq_generateFrom_Ioc_mem_aux (by simp) fun x y hxy H =>
                                           -- ğŸ‰ no goals
    ((nonempty_Ioo.2 hxy).ne_empty H).elim
#align dense.borel_eq_generate_from_Ioc_mem Dense.borel_eq_generateFrom_Ioc_mem

theorem borel_eq_generateFrom_Ioc (Î± : Type*) [TopologicalSpace Î±] [SecondCountableTopology Î±]
    [LinearOrder Î±] [OrderTopology Î±] :
    borel Î± = .generateFrom { S : Set Î± | âˆƒ l u, l < u âˆ§ Ioc l u = S } := by
  simpa only [exists_prop, mem_univ, true_and_iff] using
    (@dense_univ Î± _).borel_eq_generateFrom_Ioc_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ =>
      mem_univ _
#align borel_eq_generate_from_Ioc borel_eq_generateFrom_Ioc

namespace MeasureTheory.Measure

/-- Two finite measures on a Borel space are equal if they agree on all closed-open intervals.  If
`Î±` is a conditionally complete linear order with no top element,
`MeasureTheory.Measure.ext_of_Ico` is an extensionality lemma with weaker assumptions on `Î¼` and
`Î½`. -/
theorem ext_of_Ico_finite {Î± : Type*} [TopologicalSpace Î±] {m : MeasurableSpace Î±}
    [SecondCountableTopology Î±] [LinearOrder Î±] [OrderTopology Î±] [BorelSpace Î±] (Î¼ Î½ : Measure Î±)
    [IsFiniteMeasure Î¼] (hÎ¼Î½ : Î¼ univ = Î½ univ) (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ico a b) = Î½ (Ico a b)) :
    Î¼ = Î½ := by
  refine'
    ext_of_generate_finite _ (BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ico Î±))
      (isPiSystem_Ico (id : Î± â†’ Î±) id) _ hÎ¼Î½
  Â· rintro - âŸ¨a, b, hlt, rflâŸ©
    -- âŠ¢ â†‘â†‘Î¼ (Ico a b) = â†‘â†‘Î½ (Ico a b)
    exact h hlt
    -- ğŸ‰ no goals
#align measure_theory.measure.ext_of_Ico_finite MeasureTheory.Measure.ext_of_Ico_finite

/-- Two finite measures on a Borel space are equal if they agree on all open-closed intervals.  If
`Î±` is a conditionally complete linear order with no top element,
`MeasureTheory.Measure.ext_of_Ioc` is an extensionality lemma with weaker assumptions on `Î¼` and
`Î½`. -/
theorem ext_of_Ioc_finite {Î± : Type*} [TopologicalSpace Î±] {m : MeasurableSpace Î±}
    [SecondCountableTopology Î±] [LinearOrder Î±] [OrderTopology Î±] [BorelSpace Î±] (Î¼ Î½ : Measure Î±)
    [IsFiniteMeasure Î¼] (hÎ¼Î½ : Î¼ univ = Î½ univ) (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ioc a b) = Î½ (Ioc a b)) :
    Î¼ = Î½ := by
  refine' @ext_of_Ico_finite Î±áµ’áµˆ _ _ _ _ _ â€¹_â€º Î¼ Î½ _ hÎ¼Î½ fun a b hab => _
  -- âŠ¢ â†‘â†‘Î¼ (Ico a b) = â†‘â†‘Î½ (Ico a b)
  erw [dual_Ico (Î± := Î±)]
  -- âŠ¢ â†‘â†‘Î¼ (â†‘OrderDual.ofDual â»Â¹' Ioc b a) = â†‘â†‘Î½ (â†‘OrderDual.ofDual â»Â¹' Ioc b a)
  exact h hab
  -- ğŸ‰ no goals
#align measure_theory.measure.ext_of_Ioc_finite MeasureTheory.Measure.ext_of_Ioc_finite

/-- Two measures which are finite on closed-open intervals are equal if the agree on all
closed-open intervals. -/
theorem ext_of_Ico' {Î± : Type*} [TopologicalSpace Î±] {m : MeasurableSpace Î±}
    [SecondCountableTopology Î±] [LinearOrder Î±] [OrderTopology Î±] [BorelSpace Î±] [NoMaxOrder Î±]
    (Î¼ Î½ : Measure Î±) (hÎ¼ : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ico a b) â‰  âˆ)
    (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ico a b) = Î½ (Ico a b)) : Î¼ = Î½ := by
  rcases exists_countable_dense_bot_top Î± with âŸ¨s, hsc, hsd, hsb, _âŸ©
  -- âŠ¢ Î¼ = Î½
  have : (â‹ƒ (l âˆˆ s) (u âˆˆ s) (_ : l < u), {Ico l u} : Set (Set Î±)).Countable :=
    hsc.biUnion fun l _ => hsc.biUnion fun u _ => countable_iUnion fun _ => countable_singleton _
  simp only [â† setOf_eq_eq_singleton, â† setOf_exists] at this
  -- âŠ¢ Î¼ = Î½
  refine'
    Measure.ext_of_generateFrom_of_cover_subset
      (BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ico Î±)) (isPiSystem_Ico id id) _ this
      _ _ _
  Â· rintro _ âŸ¨l, -, u, -, h, rflâŸ©
    -- âŠ¢ Ico l u âˆˆ {S | âˆƒ l u, l < u âˆ§ Ico l u = S}
    exact âŸ¨l, u, h, rflâŸ©
    -- ğŸ‰ no goals
  Â· refine' sUnion_eq_univ_iff.2 fun x => _
    -- âŠ¢ âˆƒ b, b âˆˆ {x | âˆƒ i i_1 i_2 i_3 i_4, x = Ico i i_2} âˆ§ x âˆˆ b
    rcases hsd.exists_le' hsb x with âŸ¨l, hls, hlxâŸ©
    -- âŠ¢ âˆƒ b, b âˆˆ {x | âˆƒ i i_1 i_2 i_3 i_4, x = Ico i i_2} âˆ§ x âˆˆ b
    rcases hsd.exists_gt x with âŸ¨u, hus, hxuâŸ©
    -- âŠ¢ âˆƒ b, b âˆˆ {x | âˆƒ i i_1 i_2 i_3 i_4, x = Ico i i_2} âˆ§ x âˆˆ b
    exact âŸ¨_, âŸ¨l, hls, u, hus, hlx.trans_lt hxu, rflâŸ©, hlx, hxuâŸ©
    -- ğŸ‰ no goals
  Â· rintro _ âŸ¨l, -, u, -, hlt, rflâŸ©
    -- âŠ¢ â†‘â†‘Î¼ (Ico l u) â‰  âŠ¤
    exact hÎ¼ hlt
    -- ğŸ‰ no goals
  Â· rintro _ âŸ¨l, u, hlt, rflâŸ©
    -- âŠ¢ â†‘â†‘Î¼ (Ico l u) = â†‘â†‘Î½ (Ico l u)
    exact h hlt
    -- ğŸ‰ no goals
#align measure_theory.measure.ext_of_Ico' MeasureTheory.Measure.ext_of_Ico'

/-- Two measures which are finite on closed-open intervals are equal if the agree on all
open-closed intervals. -/
theorem ext_of_Ioc' {Î± : Type*} [TopologicalSpace Î±] {m : MeasurableSpace Î±}
    [SecondCountableTopology Î±] [LinearOrder Î±] [OrderTopology Î±] [BorelSpace Î±] [NoMinOrder Î±]
    (Î¼ Î½ : Measure Î±) (hÎ¼ : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ioc a b) â‰  âˆ)
    (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ioc a b) = Î½ (Ioc a b)) : Î¼ = Î½ := by
  refine' @ext_of_Ico' Î±áµ’áµˆ _ _ _ _ _ â€¹_â€º _ Î¼ Î½ _ _ <;> intro a b hab <;> erw [dual_Ico (Î± := Î±)]
  -- âŠ¢ âˆ€ â¦ƒa b : Î±áµ’áµˆâ¦„, a < b â†’ â†‘â†‘Î¼ (Ico a b) â‰  âŠ¤
                                                       -- âŠ¢ â†‘â†‘Î¼ (Ico a b) â‰  âŠ¤
                                                       -- âŠ¢ â†‘â†‘Î¼ (Ico a b) = â†‘â†‘Î½ (Ico a b)
                                                                         -- âŠ¢ â†‘â†‘Î¼ (â†‘OrderDual.ofDual â»Â¹' Ioc b a) â‰  âŠ¤
                                                                         -- âŠ¢ â†‘â†‘Î¼ (â†‘OrderDual.ofDual â»Â¹' Ioc b a) = â†‘â†‘Î½ (â†‘OrderDual.ofDual â»Â¹' Ioc b a)
  exacts [hÎ¼ hab, h hab]
  -- ğŸ‰ no goals
#align measure_theory.measure.ext_of_Ioc' MeasureTheory.Measure.ext_of_Ioc'

/-- Two measures which are finite on closed-open intervals are equal if the agree on all
closed-open intervals. -/
theorem ext_of_Ico {Î± : Type*} [TopologicalSpace Î±] {_m : MeasurableSpace Î±}
    [SecondCountableTopology Î±] [ConditionallyCompleteLinearOrder Î±] [OrderTopology Î±]
    [BorelSpace Î±] [NoMaxOrder Î±] (Î¼ Î½ : Measure Î±) [IsLocallyFiniteMeasure Î¼]
    (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ico a b) = Î½ (Ico a b)) : Î¼ = Î½ :=
  Î¼.ext_of_Ico' Î½ (fun _ _ _ => measure_Ico_lt_top.ne) h
#align measure_theory.measure.ext_of_Ico MeasureTheory.Measure.ext_of_Ico

/-- Two measures which are finite on closed-open intervals are equal if the agree on all
open-closed intervals. -/
theorem ext_of_Ioc {Î± : Type*} [TopologicalSpace Î±] {_m : MeasurableSpace Î±}
    [SecondCountableTopology Î±] [ConditionallyCompleteLinearOrder Î±] [OrderTopology Î±]
    [BorelSpace Î±] [NoMinOrder Î±] (Î¼ Î½ : Measure Î±) [IsLocallyFiniteMeasure Î¼]
    (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ioc a b) = Î½ (Ioc a b)) : Î¼ = Î½ :=
  Î¼.ext_of_Ioc' Î½ (fun _ _ _ => measure_Ioc_lt_top.ne) h
#align measure_theory.measure.ext_of_Ioc MeasureTheory.Measure.ext_of_Ioc

/-- Two finite measures on a Borel space are equal if they agree on all left-infinite right-closed
intervals. -/
theorem ext_of_Iic {Î± : Type*} [TopologicalSpace Î±] {m : MeasurableSpace Î±}
    [SecondCountableTopology Î±] [LinearOrder Î±] [OrderTopology Î±] [BorelSpace Î±] (Î¼ Î½ : Measure Î±)
    [IsFiniteMeasure Î¼] (h : âˆ€ a, Î¼ (Iic a) = Î½ (Iic a)) : Î¼ = Î½ := by
  refine' ext_of_Ioc_finite Î¼ Î½ _ fun a b hlt => _
  -- âŠ¢ â†‘â†‘Î¼ univ = â†‘â†‘Î½ univ
  Â· rcases exists_countable_dense_bot_top Î± with âŸ¨s, hsc, hsd, -, hstâŸ©
    -- âŠ¢ â†‘â†‘Î¼ univ = â†‘â†‘Î½ univ
    have : DirectedOn (Â· â‰¤ Â·) s := directedOn_iff_directed.2 (directed_of_sup fun _ _ => id)
    -- âŠ¢ â†‘â†‘Î¼ univ = â†‘â†‘Î½ univ
    simp only [â† biSup_measure_Iic hsc (hsd.exists_ge' hst) this, h]
    -- ğŸ‰ no goals
  rw [â† Iic_diff_Iic, measure_diff (Iic_subset_Iic.2 hlt.le) measurableSet_Iic,
    measure_diff (Iic_subset_Iic.2 hlt.le) measurableSet_Iic, h a, h b]
  Â· rw [â† h a]
    -- âŠ¢ â†‘â†‘Î¼ (Iic a) â‰  âŠ¤
    exact (measure_lt_top Î¼ _).ne
    -- ğŸ‰ no goals
  Â· exact (measure_lt_top Î¼ _).ne
    -- ğŸ‰ no goals
#align measure_theory.measure.ext_of_Iic MeasureTheory.Measure.ext_of_Iic

/-- Two finite measures on a Borel space are equal if they agree on all left-closed right-infinite
intervals. -/
theorem ext_of_Ici {Î± : Type*} [TopologicalSpace Î±] {m : MeasurableSpace Î±}
    [SecondCountableTopology Î±] [LinearOrder Î±] [OrderTopology Î±] [BorelSpace Î±] (Î¼ Î½ : Measure Î±)
    [IsFiniteMeasure Î¼] (h : âˆ€ a, Î¼ (Ici a) = Î½ (Ici a)) : Î¼ = Î½ :=
  @ext_of_Iic Î±áµ’áµˆ _ _ _ _ _ â€¹_â€º _ _ _ h
#align measure_theory.measure.ext_of_Ici MeasureTheory.Measure.ext_of_Ici

end MeasureTheory.Measure

end LinearOrder

section LinearOrder

variable [LinearOrder Î±] [OrderClosedTopology Î±] {a b : Î±}

@[measurability]
theorem measurableSet_uIcc : MeasurableSet (uIcc a b) :=
  measurableSet_Icc
#align measurable_set_uIcc measurableSet_uIcc

@[measurability]
theorem measurableSet_uIoc : MeasurableSet (uIoc a b) :=
  measurableSet_Ioc
#align measurable_set_uIoc measurableSet_uIoc

variable [SecondCountableTopology Î±]

@[measurability]
theorem Measurable.max {f g : Î´ â†’ Î±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun a => max (f a) (g a) := by
  simpa only [max_def'] using hf.piecewise (measurableSet_le hg hf) hg
  -- ğŸ‰ no goals
#align measurable.max Measurable.max

@[measurability]
nonrec theorem AEMeasurable.max {f g : Î´ â†’ Î±} {Î¼ : Measure Î´} (hf : AEMeasurable f Î¼)
    (hg : AEMeasurable g Î¼) : AEMeasurable (fun a => max (f a) (g a)) Î¼ :=
  âŸ¨fun a => max (hf.mk f a) (hg.mk g a), hf.measurable_mk.max hg.measurable_mk,
    EventuallyEq.compâ‚‚ hf.ae_eq_mk _ hg.ae_eq_mkâŸ©
#align ae_measurable.max AEMeasurable.max

@[measurability]
theorem Measurable.min {f g : Î´ â†’ Î±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun a => min (f a) (g a) := by
  simpa only [min_def] using hf.piecewise (measurableSet_le hf hg) hg
  -- ğŸ‰ no goals
#align measurable.min Measurable.min

@[measurability]
nonrec theorem AEMeasurable.min {f g : Î´ â†’ Î±} {Î¼ : Measure Î´} (hf : AEMeasurable f Î¼)
    (hg : AEMeasurable g Î¼) : AEMeasurable (fun a => min (f a) (g a)) Î¼ :=
  âŸ¨fun a => min (hf.mk f a) (hg.mk g a), hf.measurable_mk.min hg.measurable_mk,
    EventuallyEq.compâ‚‚ hf.ae_eq_mk _ hg.ae_eq_mkâŸ©
#align ae_measurable.min AEMeasurable.min

end LinearOrder

/-- A continuous function from an `OpensMeasurableSpace` to a `BorelSpace`
is measurable. -/
theorem Continuous.measurable {f : Î± â†’ Î³} (hf : Continuous f) : Measurable f :=
  hf.borel_measurable.mono OpensMeasurableSpace.borel_le (le_of_eq <| BorelSpace.measurable_eq)
#align continuous.measurable Continuous.measurable

/-- A continuous function from an `OpensMeasurableSpace` to a `BorelSpace`
is ae-measurable. -/
theorem Continuous.aemeasurable {f : Î± â†’ Î³} (h : Continuous f) {Î¼ : Measure Î±} : AEMeasurable f Î¼ :=
  h.measurable.aemeasurable
#align continuous.ae_measurable Continuous.aemeasurable

theorem ClosedEmbedding.measurable {f : Î± â†’ Î³} (hf : ClosedEmbedding f) : Measurable f :=
  hf.continuous.measurable
#align closed_embedding.measurable ClosedEmbedding.measurable

/-- If a function is defined piecewise in terms of functions which are continuous on their
respective pieces, then it is measurable. -/
theorem ContinuousOn.measurable_piecewise {f g : Î± â†’ Î³} {s : Set Î±} [âˆ€ j : Î±, Decidable (j âˆˆ s)]
    (hf : ContinuousOn f s) (hg : ContinuousOn g sá¶œ) (hs : MeasurableSet s) :
    Measurable (s.piecewise f g) := by
  refine' measurable_of_isOpen fun t ht => _
  -- âŠ¢ MeasurableSet (Set.piecewise s f g â»Â¹' t)
  rw [piecewise_preimage, Set.ite]
  -- âŠ¢ MeasurableSet (f â»Â¹' t âˆ© s âˆª g â»Â¹' t \ s)
  apply MeasurableSet.union
  -- âŠ¢ MeasurableSet (f â»Â¹' t âˆ© s)
  Â· rcases _root_.continuousOn_iff'.1 hf t ht with âŸ¨u, u_open, huâŸ©
    -- âŠ¢ MeasurableSet (f â»Â¹' t âˆ© s)
    rw [hu]
    -- âŠ¢ MeasurableSet (u âˆ© s)
    exact u_open.measurableSet.inter hs
    -- ğŸ‰ no goals
  Â· rcases _root_.continuousOn_iff'.1 hg t ht with âŸ¨u, u_open, huâŸ©
    -- âŠ¢ MeasurableSet (g â»Â¹' t \ s)
    rw [diff_eq_compl_inter, inter_comm, hu]
    -- âŠ¢ MeasurableSet (u âˆ© sá¶œ)
    exact u_open.measurableSet.inter hs.compl
    -- ğŸ‰ no goals
#align continuous_on.measurable_piecewise ContinuousOn.measurable_piecewise

@[to_additive]
instance (priority := 100) ContinuousMul.measurableMul [Mul Î³] [ContinuousMul Î³] :
    MeasurableMul Î³ where
  measurable_const_mul _ := (continuous_const.mul continuous_id).measurable
  measurable_mul_const _ := (continuous_id.mul continuous_const).measurable
#align has_continuous_mul.has_measurable_mul ContinuousMul.measurableMul
#align has_continuous_add.has_measurable_add ContinuousAdd.measurableAdd

instance (priority := 100) ContinuousSub.measurableSub [Sub Î³] [ContinuousSub Î³] :
    MeasurableSub Î³ where
  measurable_const_sub _ := (continuous_const.sub continuous_id).measurable
  measurable_sub_const _ := (continuous_id.sub continuous_const).measurable
#align has_continuous_sub.has_measurable_sub ContinuousSub.measurableSub

@[to_additive]
instance (priority := 100) TopologicalGroup.measurableInv [Group Î³] [TopologicalGroup Î³] :
    MeasurableInv Î³ :=
  âŸ¨continuous_inv.measurableâŸ©
#align topological_group.has_measurable_inv TopologicalGroup.measurableInv
#align topological_add_group.has_measurable_neg TopologicalAddGroup.measurableNeg

instance (priority := 100) ContinuousSMul.measurableSMul {M Î±} [TopologicalSpace M]
    [TopologicalSpace Î±] [MeasurableSpace M] [MeasurableSpace Î±] [OpensMeasurableSpace M]
    [BorelSpace Î±] [SMul M Î±] [ContinuousSMul M Î±] : MeasurableSMul M Î± :=
  âŸ¨fun _ => (continuous_const_smul _).measurable, fun _ =>
    (continuous_id.smul continuous_const).measurableâŸ©
#align has_continuous_smul.has_measurable_smul ContinuousSMul.measurableSMul

section Lattice

instance (priority := 100) ContinuousSup.measurableSup [Sup Î³] [ContinuousSup Î³] :
    MeasurableSup Î³ where
  measurable_const_sup _ := (continuous_const.sup continuous_id).measurable
  measurable_sup_const _ := (continuous_id.sup continuous_const).measurable
#align has_continuous_sup.has_measurable_sup ContinuousSup.measurableSup

instance (priority := 100) ContinuousSup.measurableSupâ‚‚ [SecondCountableTopology Î³] [Sup Î³]
    [ContinuousSup Î³] : MeasurableSupâ‚‚ Î³ :=
  âŸ¨continuous_sup.measurableâŸ©
#align has_continuous_sup.has_measurable_supâ‚‚ ContinuousSup.measurableSupâ‚‚

instance (priority := 100) ContinuousInf.measurableInf [Inf Î³] [ContinuousInf Î³] :
    MeasurableInf Î³ where
  measurable_const_inf _ := (continuous_const.inf continuous_id).measurable
  measurable_inf_const _ := (continuous_id.inf continuous_const).measurable
#align has_continuous_inf.has_measurable_inf ContinuousInf.measurableInf

instance (priority := 100) ContinuousInf.measurableInfâ‚‚ [SecondCountableTopology Î³] [Inf Î³]
    [ContinuousInf Î³] : MeasurableInfâ‚‚ Î³ :=
  âŸ¨continuous_inf.measurableâŸ©
#align has_continuous_inf.has_measurable_infâ‚‚ ContinuousInf.measurableInfâ‚‚

end Lattice

section Homeomorph

@[measurability]
protected theorem Homeomorph.measurable (h : Î± â‰ƒâ‚œ Î³) : Measurable h :=
  h.continuous.measurable
#align homeomorph.measurable Homeomorph.measurable

/-- A homeomorphism between two Borel spaces is a measurable equivalence.-/
def Homeomorph.toMeasurableEquiv (h : Î³ â‰ƒâ‚œ Î³â‚‚) : Î³ â‰ƒáµ Î³â‚‚ where
  measurable_toFun := h.measurable
  measurable_invFun := h.symm.measurable
  toEquiv := h.toEquiv
#align homeomorph.to_measurable_equiv Homeomorph.toMeasurableEquiv

@[simp]
theorem Homeomorph.toMeasurableEquiv_coe (h : Î³ â‰ƒâ‚œ Î³â‚‚) : (h.toMeasurableEquiv : Î³ â†’ Î³â‚‚) = h :=
  rfl
#align homeomorph.to_measurable_equiv_coe Homeomorph.toMeasurableEquiv_coe

@[simp]
theorem Homeomorph.toMeasurableEquiv_symm_coe (h : Î³ â‰ƒâ‚œ Î³â‚‚) :
    (h.toMeasurableEquiv.symm : Î³â‚‚ â†’ Î³) = h.symm :=
  rfl
#align homeomorph.to_measurable_equiv_symm_coe Homeomorph.toMeasurableEquiv_symm_coe

end Homeomorph

@[measurability]
theorem ContinuousMap.measurable (f : C(Î±, Î³)) : Measurable f :=
  f.continuous.measurable
#align continuous_map.measurable ContinuousMap.measurable

theorem measurable_of_continuousOn_compl_singleton [T1Space Î±] {f : Î± â†’ Î³} (a : Î±)
    (hf : ContinuousOn f {a}á¶œ) : Measurable f :=
  measurable_of_measurable_on_compl_singleton a
    (continuousOn_iff_continuous_restrict.1 hf).measurable
#align measurable_of_continuous_on_compl_singleton measurable_of_continuousOn_compl_singleton

theorem Continuous.measurable2 [SecondCountableTopologyEither Î± Î²] {f : Î´ â†’ Î±}
    {g : Î´ â†’ Î²} {c : Î± â†’ Î² â†’ Î³} (h : Continuous fun p : Î± Ã— Î² => c p.1 p.2) (hf : Measurable f)
    (hg : Measurable g) : Measurable fun a => c (f a) (g a) :=
  h.measurable.comp (hf.prod_mk hg)
#align continuous.measurable2 Continuous.measurable2

theorem Continuous.aemeasurable2 [SecondCountableTopologyEither Î± Î²]
    {f : Î´ â†’ Î±} {g : Î´ â†’ Î²} {c : Î± â†’ Î² â†’ Î³} {Î¼ : Measure Î´}
    (h : Continuous fun p : Î± Ã— Î² => c p.1 p.2) (hf : AEMeasurable f Î¼) (hg : AEMeasurable g Î¼) :
    AEMeasurable (fun a => c (f a) (g a)) Î¼ :=
  h.measurable.comp_aemeasurable (hf.prod_mk hg)
#align continuous.ae_measurable2 Continuous.aemeasurable2

instance (priority := 100) HasContinuousInvâ‚€.measurableInv [GroupWithZero Î³] [T1Space Î³]
    [HasContinuousInvâ‚€ Î³] : MeasurableInv Î³ :=
  âŸ¨measurable_of_continuousOn_compl_singleton 0 continuousOn_invâ‚€âŸ©
#align has_continuous_invâ‚€.has_measurable_inv HasContinuousInvâ‚€.measurableInv

@[to_additive]
instance (priority := 100) ContinuousMul.measurableMulâ‚‚ [SecondCountableTopology Î³] [Mul Î³]
    [ContinuousMul Î³] : MeasurableMulâ‚‚ Î³ :=
  âŸ¨continuous_mul.measurableâŸ©
#align has_continuous_mul.has_measurable_mulâ‚‚ ContinuousMul.measurableMulâ‚‚
#align has_continuous_add.has_measurable_mulâ‚‚ ContinuousAdd.measurableMulâ‚‚

instance (priority := 100) ContinuousSub.measurableSubâ‚‚ [SecondCountableTopology Î³] [Sub Î³]
    [ContinuousSub Î³] : MeasurableSubâ‚‚ Î³ :=
  âŸ¨continuous_sub.measurableâŸ©
#align has_continuous_sub.has_measurable_subâ‚‚ ContinuousSub.measurableSubâ‚‚

instance (priority := 100) ContinuousSMul.measurableSMulâ‚‚ {M Î±} [TopologicalSpace M]
    [MeasurableSpace M] [OpensMeasurableSpace M] [TopologicalSpace Î±]
    [SecondCountableTopologyEither M Î±] [MeasurableSpace Î±] [BorelSpace Î±] [SMul M Î±]
    [ContinuousSMul M Î±] : MeasurableSMulâ‚‚ M Î± :=
  âŸ¨continuous_smul.measurableâŸ©
#align has_continuous_smul.has_measurable_smulâ‚‚ ContinuousSMul.measurableSMulâ‚‚

end

section BorelSpace

variable [TopologicalSpace Î±] [MeasurableSpace Î±] [BorelSpace Î±] [TopologicalSpace Î²]
  [MeasurableSpace Î²] [BorelSpace Î²] [TopologicalSpace Î³] [MeasurableSpace Î³] [BorelSpace Î³]
  [MeasurableSpace Î´]

theorem pi_le_borel_pi {Î¹ : Type*} {Ï€ : Î¹ â†’ Type*} [âˆ€ i, TopologicalSpace (Ï€ i)]
    [âˆ€ i, MeasurableSpace (Ï€ i)] [âˆ€ i, BorelSpace (Ï€ i)] :
      MeasurableSpace.pi â‰¤ borel (âˆ€ i, Ï€ i) := by
  have : â€¹âˆ€ i, MeasurableSpace (Ï€ i)â€º = fun i => borel (Ï€ i) :=
    funext fun i => BorelSpace.measurable_eq
  rw [this]
  -- âŠ¢ MeasurableSpace.pi â‰¤ borel ((i : Î¹) â†’ Ï€ i)
  exact iSup_le fun i => comap_le_iff_le_map.2 <| (continuous_apply i).borel_measurable
  -- ğŸ‰ no goals
#align pi_le_borel_pi pi_le_borel_pi

theorem prod_le_borel_prod : Prod.instMeasurableSpace â‰¤ borel (Î± Ã— Î²) := by
  rw [â€¹BorelSpace Î±â€º.measurable_eq, â€¹BorelSpace Î²â€º.measurable_eq]
  -- âŠ¢ Prod.instMeasurableSpace â‰¤ borel (Î± Ã— Î²)
  refine' sup_le _ _
  -- âŠ¢ MeasurableSpace.comap Prod.fst (borel Î±) â‰¤ borel (Î± Ã— Î²)
  Â· exact comap_le_iff_le_map.mpr continuous_fst.borel_measurable
    -- ğŸ‰ no goals
  Â· exact comap_le_iff_le_map.mpr continuous_snd.borel_measurable
    -- ğŸ‰ no goals
#align prod_le_borel_prod prod_le_borel_prod

instance Pi.borelSpace {Î¹ : Type*} {Ï€ : Î¹ â†’ Type*} [Countable Î¹] [âˆ€ i, TopologicalSpace (Ï€ i)]
    [âˆ€ i, MeasurableSpace (Ï€ i)] [âˆ€ i, SecondCountableTopology (Ï€ i)] [âˆ€ i, BorelSpace (Ï€ i)] :
    BorelSpace (âˆ€ i, Ï€ i) :=
  âŸ¨le_antisymm pi_le_borel_pi OpensMeasurableSpace.borel_leâŸ©
#align pi.borel_space Pi.borelSpace

instance Prod.borelSpace [SecondCountableTopologyEither Î± Î²] :
    BorelSpace (Î± Ã— Î²) :=
  âŸ¨le_antisymm prod_le_borel_prod OpensMeasurableSpace.borel_leâŸ©
#align prod.borel_space Prod.borelSpace

protected theorem Embedding.measurableEmbedding {f : Î± â†’ Î²} (hâ‚ : Embedding f)
    (hâ‚‚ : MeasurableSet (range f)) : MeasurableEmbedding f :=
  show MeasurableEmbedding
      (((â†‘) : range f â†’ Î²) âˆ˜ (Homeomorph.ofEmbedding f hâ‚).toMeasurableEquiv) from
    (MeasurableEmbedding.subtype_coe hâ‚‚).comp (MeasurableEquiv.measurableEmbedding _)
#align embedding.measurable_embedding Embedding.measurableEmbedding

protected theorem ClosedEmbedding.measurableEmbedding {f : Î± â†’ Î²} (h : ClosedEmbedding f) :
    MeasurableEmbedding f :=
  h.toEmbedding.measurableEmbedding h.closed_range.measurableSet
#align closed_embedding.measurable_embedding ClosedEmbedding.measurableEmbedding

protected theorem OpenEmbedding.measurableEmbedding {f : Î± â†’ Î²} (h : OpenEmbedding f) :
    MeasurableEmbedding f :=
  h.toEmbedding.measurableEmbedding h.open_range.measurableSet
#align open_embedding.measurable_embedding OpenEmbedding.measurableEmbedding

section LinearOrder

variable [LinearOrder Î±] [OrderTopology Î±] [SecondCountableTopology Î±]

theorem measurable_of_Iio {f : Î´ â†’ Î±} (hf : âˆ€ x, MeasurableSet (f â»Â¹' Iio x)) : Measurable f := by
  convert measurable_generateFrom (Î± := Î´) _
  exact BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Iio _)
  -- âŠ¢ âˆ€ (t : Set Î±), t âˆˆ range Iio â†’ MeasurableSet (f â»Â¹' t)
  rintro _ âŸ¨x, rflâŸ©; exact hf x
  -- âŠ¢ MeasurableSet (f â»Â¹' Iio x)
                     -- ğŸ‰ no goals
#align measurable_of_Iio measurable_of_Iio

theorem UpperSemicontinuous.measurable [TopologicalSpace Î´] [OpensMeasurableSpace Î´] {f : Î´ â†’ Î±}
    (hf : UpperSemicontinuous f) : Measurable f :=
  measurable_of_Iio fun y => (hf.isOpen_preimage y).measurableSet
#align upper_semicontinuous.measurable UpperSemicontinuous.measurable

theorem measurable_of_Ioi {f : Î´ â†’ Î±} (hf : âˆ€ x, MeasurableSet (f â»Â¹' Ioi x)) : Measurable f := by
  convert measurable_generateFrom (Î± := Î´) _
  exact BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ioi _)
  -- âŠ¢ âˆ€ (t : Set Î±), t âˆˆ range Ioi â†’ MeasurableSet (f â»Â¹' t)
  rintro _ âŸ¨x, rflâŸ©; exact hf x
  -- âŠ¢ MeasurableSet (f â»Â¹' Ioi x)
                     -- ğŸ‰ no goals
#align measurable_of_Ioi measurable_of_Ioi

theorem LowerSemicontinuous.measurable [TopologicalSpace Î´] [OpensMeasurableSpace Î´] {f : Î´ â†’ Î±}
    (hf : LowerSemicontinuous f) : Measurable f :=
  measurable_of_Ioi fun y => (hf.isOpen_preimage y).measurableSet
#align lower_semicontinuous.measurable LowerSemicontinuous.measurable

theorem measurable_of_Iic {f : Î´ â†’ Î±} (hf : âˆ€ x, MeasurableSet (f â»Â¹' Iic x)) : Measurable f := by
  apply measurable_of_Ioi
  -- âŠ¢ âˆ€ (x : Î±), MeasurableSet (f â»Â¹' Ioi x)
  simp_rw [â† compl_Iic, preimage_compl, MeasurableSet.compl_iff]
  -- âŠ¢ âˆ€ (x : Î±), MeasurableSet (f â»Â¹' Iic x)
  assumption
  -- ğŸ‰ no goals
#align measurable_of_Iic measurable_of_Iic

theorem measurable_of_Ici {f : Î´ â†’ Î±} (hf : âˆ€ x, MeasurableSet (f â»Â¹' Ici x)) : Measurable f := by
  apply measurable_of_Iio
  -- âŠ¢ âˆ€ (x : Î±), MeasurableSet (f â»Â¹' Iio x)
  simp_rw [â† compl_Ici, preimage_compl, MeasurableSet.compl_iff]
  -- âŠ¢ âˆ€ (x : Î±), MeasurableSet (f â»Â¹' Ici x)
  assumption
  -- ğŸ‰ no goals
#align measurable_of_Ici measurable_of_Ici

theorem Measurable.isLUB {Î¹} [Countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±} (hf : âˆ€ i, Measurable (f i))
    (hg : âˆ€ b, IsLUB { a | âˆƒ i, f i b = a } (g b)) : Measurable g := by
  change âˆ€ b, IsLUB (range fun i => f i b) (g b) at hg
  -- âŠ¢ Measurable g
  rw [â€¹BorelSpace Î±â€º.measurable_eq, borel_eq_generateFrom_Ioi Î±]
  -- âŠ¢ Measurable g
  apply measurable_generateFrom
  -- âŠ¢ âˆ€ (t : Set Î±), t âˆˆ range Ioi â†’ MeasurableSet (g â»Â¹' t)
  rintro _ âŸ¨a, rflâŸ©
  -- âŠ¢ MeasurableSet (g â»Â¹' Ioi a)
  simp_rw [Set.preimage, mem_Ioi, lt_isLUB_iff (hg _), exists_range_iff, setOf_exists]
  -- âŠ¢ MeasurableSet (â‹ƒ (i : Î¹), {x | a < f i x})
  exact MeasurableSet.iUnion fun i => hf i (isOpen_lt' _).measurableSet
  -- ğŸ‰ no goals
#align measurable.is_lub Measurable.isLUB

private theorem AEMeasurable.is_lub_of_nonempty {Î¹} (hÎ¹ : Nonempty Î¹) {Î¼ : Measure Î´} [Countable Î¹]
    {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±} (hf : âˆ€ i, AEMeasurable (f i) Î¼)
    (hg : âˆ€áµ b âˆ‚Î¼, IsLUB { a | âˆƒ i, f i b = a } (g b)) : AEMeasurable g Î¼ := by
  let p : Î´ â†’ (Î¹ â†’ Î±) â†’ Prop := fun x f' => IsLUB { a | âˆƒ i, f' i = a } (g x)
  -- âŠ¢ AEMeasurable g
  let g_seq x := ite (x âˆˆ aeSeqSet hf p) (g x) (âŸ¨g xâŸ© : Nonempty Î±).some
  -- âŠ¢ AEMeasurable g
  have hg_seq : âˆ€ b, IsLUB { a | âˆƒ i, aeSeq hf p i b = a } (g_seq b) := by
    intro b
    haveI hÎ± : Nonempty Î± := Nonempty.map g âŸ¨bâŸ©
    simp only [aeSeq]
    split_ifs with h
    Â· have h_set_eq :
          { a : Î± | âˆƒ i : Î¹, (hf i).mk (f i) b = a } = { a : Î± | âˆƒ i : Î¹, f i b = a } := by
        ext x
        simp_rw [Set.mem_setOf_eq, aeSeq.mk_eq_fun_of_mem_aeSeqSet hf h]
      rw [h_set_eq]
      exact aeSeq.fun_prop_of_mem_aeSeqSet hf h
    Â· have h_singleton : { a : Î± | âˆƒ _ : Î¹, hÎ±.some = a } = {hÎ±.some} := by
        ext1 x
        exact âŸ¨fun hx => hx.choose_spec.symm, fun hx => âŸ¨hÎ¹.some, hx.symmâŸ©âŸ©
      rw [h_singleton]
      exact isLUB_singleton
  refine' âŸ¨g_seq, Measurable.isLUB (aeSeq.measurable hf p) hg_seq, _âŸ©
  -- âŠ¢ g =áµ[Î¼] g_seq
  exact
    (ite_ae_eq_of_measure_compl_zero g (fun x => (âŸ¨g xâŸ© : Nonempty Î±).some) (aeSeqSet hf p)
        (aeSeq.measure_compl_aeSeqSet_eq_zero hf hg)).symm

theorem AEMeasurable.isLUB {Î¹} {Î¼ : Measure Î´} [Countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±}
    (hf : âˆ€ i, AEMeasurable (f i) Î¼) (hg : âˆ€áµ b âˆ‚Î¼, IsLUB { a | âˆƒ i, f i b = a } (g b)) :
    AEMeasurable g Î¼ := by
  rcases eq_zero_or_neZero Î¼ with rfl | hÎ¼
  -- âŠ¢ AEMeasurable g
  Â· exact aemeasurable_zero_measure
    -- ğŸ‰ no goals
  by_cases hÎ¹ : Nonempty Î¹
  -- âŠ¢ AEMeasurable g
  Â· exact AEMeasurable.is_lub_of_nonempty hÎ¹ hf hg
    -- ğŸ‰ no goals
  suffices âˆƒ x, g =áµ[Î¼] fun _ => g x by
    exact âŸ¨fun _ => g this.choose, measurable_const, this.choose_specâŸ©
  have h_empty : âˆ€ x, { a : Î± | âˆƒ i : Î¹, f i x = a } = âˆ… := by
    intro x
    ext1 y
    rw [Set.mem_setOf_eq, Set.mem_empty_iff_false, iff_false_iff]
    exact fun hi => hÎ¹ (nonempty_of_exists hi)
  simp_rw [h_empty] at hg
  -- âŠ¢ âˆƒ x, g =áµ[Î¼] fun x_1 => g x
  exact âŸ¨hg.exists.choose, hg.mono fun y hy => IsLUB.unique hy hg.exists.choose_specâŸ©
  -- ğŸ‰ no goals
#align ae_measurable.is_lub AEMeasurable.isLUB

theorem Measurable.isGLB {Î¹} [Countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±} (hf : âˆ€ i, Measurable (f i))
    (hg : âˆ€ b, IsGLB { a | âˆƒ i, f i b = a } (g b)) : Measurable g := by
  change âˆ€ b, IsGLB (range fun i => f i b) (g b) at hg
  -- âŠ¢ Measurable g
  rw [â€¹BorelSpace Î±â€º.measurable_eq, borel_eq_generateFrom_Iio Î±]
  -- âŠ¢ Measurable g
  apply measurable_generateFrom
  -- âŠ¢ âˆ€ (t : Set Î±), t âˆˆ range Iio â†’ MeasurableSet (g â»Â¹' t)
  rintro _ âŸ¨a, rflâŸ©
  -- âŠ¢ MeasurableSet (g â»Â¹' Iio a)
  simp_rw [Set.preimage, mem_Iio, isGLB_lt_iff (hg _), exists_range_iff, setOf_exists]
  -- âŠ¢ MeasurableSet (â‹ƒ (i : Î¹), {x | f i x < a})
  exact MeasurableSet.iUnion fun i => hf i (isOpen_gt' _).measurableSet
  -- ğŸ‰ no goals
#align measurable.is_glb Measurable.isGLB

theorem AEMeasurable.isGLB {Î¹} {Î¼ : Measure Î´} [Countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±}
    (hf : âˆ€ i, AEMeasurable (f i) Î¼) (hg : âˆ€áµ b âˆ‚Î¼, IsGLB { a | âˆƒ i, f i b = a } (g b)) :
    AEMeasurable g Î¼ := by
  nontriviality Î±
  -- âŠ¢ AEMeasurable g
  haveI hÎ± : Nonempty Î± := inferInstance
  -- âŠ¢ AEMeasurable g
  cases' isEmpty_or_nonempty Î¹ with hÎ¹ hÎ¹
  -- âŠ¢ AEMeasurable g
  Â· simp only [IsEmpty.exists_iff, setOf_false, isGLB_empty_iff] at hg
    -- âŠ¢ AEMeasurable g
    exact aemeasurable_const' (hg.mono fun a ha => hg.mono fun b hb => (hb _).antisymm (ha _))
    -- ğŸ‰ no goals
  let p : Î´ â†’ (Î¹ â†’ Î±) â†’ Prop := fun x f' => IsGLB { a | âˆƒ i, f' i = a } (g x)
  -- âŠ¢ AEMeasurable g
  let g_seq := (aeSeqSet hf p).piecewise g fun _ => hÎ±.some
  -- âŠ¢ AEMeasurable g
  have hg_seq : âˆ€ b, IsGLB { a | âˆƒ i, aeSeq hf p i b = a } (g_seq b) := by
    intro b
    simp only [aeSeq, Set.piecewise]
    split_ifs with h
    Â· have h_set_eq : { a : Î± | âˆƒ i : Î¹, (hf i).mk (f i) b = a } =
        { a : Î± | âˆƒ i : Î¹, f i b = a } := by
        ext x
        simp_rw [Set.mem_setOf_eq, aeSeq.mk_eq_fun_of_mem_aeSeqSet hf h]
      rw [h_set_eq]
      exact aeSeq.fun_prop_of_mem_aeSeqSet hf h
    Â· exact IsLeast.isGLB âŸ¨(@exists_const (hÎ±.some = hÎ±.some) Î¹ _).2 rfl, fun x âŸ¨i, hiâŸ© => hi.leâŸ©
  refine' âŸ¨g_seq, Measurable.isGLB (aeSeq.measurable hf p) hg_seq, _âŸ©
  -- âŠ¢ g =áµ[Î¼] g_seq
  exact
    (ite_ae_eq_of_measure_compl_zero g (fun _ => hÎ±.some) (aeSeqSet hf p)
        (aeSeq.measure_compl_aeSeqSet_eq_zero hf hg)).symm
#align ae_measurable.is_glb AEMeasurable.isGLB

protected theorem Monotone.measurable [LinearOrder Î²] [OrderClosedTopology Î²] {f : Î² â†’ Î±}
    (hf : Monotone f) : Measurable f :=
  suffices h : âˆ€ x, OrdConnected (f â»Â¹' Ioi x) from measurable_of_Ioi fun x => (h x).measurableSet
  fun _ => ordConnected_def.mpr fun _a ha _ _ _c hc => lt_of_lt_of_le ha (hf hc.1)
#align monotone.measurable Monotone.measurable

theorem aemeasurable_restrict_of_monotoneOn [LinearOrder Î²] [OrderClosedTopology Î²] {Î¼ : Measure Î²}
    {s : Set Î²} (hs : MeasurableSet s) {f : Î² â†’ Î±} (hf : MonotoneOn f s) :
    AEMeasurable f (Î¼.restrict s) :=
  have : Monotone (f âˆ˜ (â†‘) : s â†’ Î±) := fun âŸ¨x, hxâŸ© âŸ¨y, hyâŸ©=> fun (hxy : x â‰¤ y) => hf hx hy hxy
  aemeasurable_restrict_of_measurable_subtype hs this.measurable
#align ae_measurable_restrict_of_monotone_on aemeasurable_restrict_of_monotoneOn

protected theorem Antitone.measurable [LinearOrder Î²] [OrderClosedTopology Î²] {f : Î² â†’ Î±}
    (hf : Antitone f) : Measurable f :=
  @Monotone.measurable Î±áµ’áµˆ Î² _ _ â€¹_â€º _ _ _ _ _ â€¹_â€º _ _ _ hf
#align antitone.measurable Antitone.measurable

theorem aemeasurable_restrict_of_antitoneOn [LinearOrder Î²] [OrderClosedTopology Î²] {Î¼ : Measure Î²}
    {s : Set Î²} (hs : MeasurableSet s) {f : Î² â†’ Î±} (hf : AntitoneOn f s) :
    AEMeasurable f (Î¼.restrict s) :=
  @aemeasurable_restrict_of_monotoneOn Î±áµ’áµˆ Î² _ _ â€¹_â€º _ _ _ _ _ â€¹_â€º _ _ _ _ hs _ hf
#align ae_measurable_restrict_of_antitone_on aemeasurable_restrict_of_antitoneOn

theorem measurableSet_of_mem_nhdsWithin_Ioi_aux {s : Set Î±} (h : âˆ€ x âˆˆ s, s âˆˆ ğ“[>] x)
    (h' : âˆ€ x âˆˆ s, âˆƒ y, x < y) : MeasurableSet s := by
  choose! M hM using h'
  -- âŠ¢ MeasurableSet s
  suffices H : (s \ interior s).Countable
  -- âŠ¢ MeasurableSet s
  Â· have : s = interior s âˆª s \ interior s := by rw [union_diff_cancel interior_subset]
    -- âŠ¢ MeasurableSet s
    rw [this]
    -- âŠ¢ MeasurableSet (interior s âˆª s \ interior s)
    exact isOpen_interior.measurableSet.union H.measurableSet
    -- ğŸ‰ no goals
  have A : âˆ€ x âˆˆ s, âˆƒ y âˆˆ Ioi x, Ioo x y âŠ† s := fun x hx =>
    (mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' (hM x hx)).1 (h x hx)
  choose! y hy h'y using A
  -- âŠ¢ Set.Countable (s \ interior s)
  have B : Set.PairwiseDisjoint (s \ interior s) fun x => Ioo x (y x) := by
    intro x hx x' hx' hxx'
    rcases lt_or_gt_of_ne hxx' with (h' | h')
    Â· refine disjoint_left.2 fun z hz h'z => ?_
      have : x' âˆˆ interior s :=
        mem_interior.2 âŸ¨Ioo x (y x), h'y _ hx.1, isOpen_Ioo, âŸ¨h', h'z.1.trans hz.2âŸ©âŸ©
      exact False.elim (hx'.2 this)
    Â· refine disjoint_left.2 fun z hz h'z => ?_
      have : x âˆˆ interior s :=
        mem_interior.2 âŸ¨Ioo x' (y x'), h'y _ hx'.1, isOpen_Ioo, âŸ¨h', hz.1.trans h'z.2âŸ©âŸ©
      exact False.elim (hx.2 this)
  exact B.countable_of_Ioo fun x hx => hy x hx.1
  -- ğŸ‰ no goals
#align measurable_set_of_mem_nhds_within_Ioi_aux measurableSet_of_mem_nhdsWithin_Ioi_aux

/-- If a set is a right-neighborhood of all of its points, then it is measurable. -/
theorem measurableSet_of_mem_nhdsWithin_Ioi {s : Set Î±} (h : âˆ€ x âˆˆ s, s âˆˆ ğ“[>] x) :
    MeasurableSet s := by
  by_cases H : âˆƒ x âˆˆ s, IsTop x
  -- âŠ¢ MeasurableSet s
  Â· rcases H with âŸ¨xâ‚€, xâ‚€s, hâ‚€âŸ©
    -- âŠ¢ MeasurableSet s
    have : s = {xâ‚€} âˆª s \ {xâ‚€} := by rw [union_diff_cancel (singleton_subset_iff.2 xâ‚€s)]
    -- âŠ¢ MeasurableSet s
    rw [this]
    -- âŠ¢ MeasurableSet ({xâ‚€} âˆª s \ {xâ‚€})
    refine' (measurableSet_singleton _).union _
    -- âŠ¢ MeasurableSet (s \ {xâ‚€})
    have A : âˆ€ x âˆˆ s \ {xâ‚€}, x < xâ‚€ := fun x hx => lt_of_le_of_ne (hâ‚€ _) (by simpa using hx.2)
    -- âŠ¢ MeasurableSet (s \ {xâ‚€})
    refine' measurableSet_of_mem_nhdsWithin_Ioi_aux (fun x hx => _) fun x hx => âŸ¨xâ‚€, A x hxâŸ©
    -- âŠ¢ s \ {xâ‚€} âˆˆ ğ“[Ioi x] x
    obtain âŸ¨u, hu, usâŸ© : âˆƒ (u : Î±), u âˆˆ Ioi x âˆ§ Ioo x u âŠ† s :=
      (mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' (A x hx)).1 (h x hx.1)
    refine' (mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' (A x hx)).2 âŸ¨u, hu, fun y hy => âŸ¨us hy, _âŸ©âŸ©
    -- âŠ¢ Â¬y âˆˆ {xâ‚€}
    exact ne_of_lt (hy.2.trans_le (hâ‚€ _))
    -- ğŸ‰ no goals
  Â· apply measurableSet_of_mem_nhdsWithin_Ioi_aux h
    -- âŠ¢ âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ y, x < y
    simp only [IsTop] at H
    -- âŠ¢ âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ y, x < y
    push_neg at H
    -- âŠ¢ âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ y, x < y
    exact H
    -- ğŸ‰ no goals
#align measurable_set_of_mem_nhds_within_Ioi measurableSet_of_mem_nhdsWithin_Ioi

end LinearOrder

@[measurability]
theorem Measurable.iSup_Prop {Î±} [MeasurableSpace Î±] [CompleteLattice Î±] (p : Prop) {f : Î´ â†’ Î±}
    (hf : Measurable f) : Measurable fun b => â¨† _ : p, f b :=
  _root_.by_cases (fun h : p => by convert hf; funext; exact iSup_pos h) fun h : Â¬p => by
                                   -- âŠ¢ â¨† (_ : p), f xâœ = f xâœ
                                               -- âŠ¢ â¨† (_ : p), f xâœ = f xâœ
                                                       -- ğŸ‰ no goals
    convert measurable_const using 1; funext; exact iSup_neg h
    -- âŠ¢ (fun b => â¨† (_ : p), f b) = fun x => ?convert_5
                                      -- âŠ¢ â¨† (_ : p), f xâœ = ?convert_5
                                              -- ğŸ‰ no goals
#align measurable.supr_Prop Measurable.iSup_Prop

@[measurability]
theorem Measurable.iInf_Prop {Î±} [MeasurableSpace Î±] [CompleteLattice Î±] (p : Prop) {f : Î´ â†’ Î±}
    (hf : Measurable f) : Measurable fun b => â¨… _ : p, f b :=
  _root_.by_cases (fun h : p => by convert hf; funext; exact iInf_pos h) fun h : Â¬p => by
                                   -- âŠ¢ â¨… (_ : p), f xâœ = f xâœ
                                               -- âŠ¢ â¨… (_ : p), f xâœ = f xâœ
                                                       -- ğŸ‰ no goals
    convert measurable_const using 1; funext; exact iInf_neg h
    -- âŠ¢ (fun b => â¨… (_ : p), f b) = fun x => ?convert_5
                                      -- âŠ¢ â¨… (_ : p), f xâœ = ?convert_5
                                              -- ğŸ‰ no goals
#align measurable.infi_Prop Measurable.iInf_Prop

section CompleteLinearOrder

variable [CompleteLinearOrder Î±] [OrderTopology Î±] [SecondCountableTopology Î±]

@[measurability]
theorem measurable_iSup {Î¹} [Countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} (hf : âˆ€ i, Measurable (f i)) :
    Measurable fun b => â¨† i, f i b :=
  Measurable.isLUB hf fun _ => isLUB_iSup
#align measurable_supr measurable_iSup

@[measurability]
theorem aemeasurable_iSup {Î¹} {Î¼ : Measure Î´} [Countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±}
    (hf : âˆ€ i, AEMeasurable (f i) Î¼) : AEMeasurable (fun b => â¨† i, f i b) Î¼ :=
  AEMeasurable.isLUB hf <| ae_of_all Î¼ fun _ => isLUB_iSup
#align ae_measurable_supr aemeasurable_iSup

@[measurability]
theorem measurable_iInf {Î¹} [Countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} (hf : âˆ€ i, Measurable (f i)) :
    Measurable fun b => â¨… i, f i b :=
  Measurable.isGLB hf fun _ => isGLB_iInf
#align measurable_infi measurable_iInf

@[measurability]
theorem aemeasurable_iInf {Î¹} {Î¼ : Measure Î´} [Countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±}
    (hf : âˆ€ i, AEMeasurable (f i) Î¼) : AEMeasurable (fun b => â¨… i, f i b) Î¼ :=
  AEMeasurable.isGLB hf <| ae_of_all Î¼ fun _ => isGLB_iInf
#align ae_measurable_infi aemeasurable_iInf

theorem measurable_biSup {Î¹} (s : Set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : s.Countable)
    (hf : âˆ€ i, Measurable (f i)) : Measurable fun b => â¨† i âˆˆ s, f i b := by
  haveI : Encodable s := hs.toEncodable
  -- âŠ¢ Measurable fun b => â¨† (i : Î¹) (_ : i âˆˆ s), f i b
  simp only [iSup_subtype']
  -- âŠ¢ Measurable fun b => â¨† (x : { i // i âˆˆ s }), f (â†‘x) b
  exact measurable_iSup fun i => hf i
  -- ğŸ‰ no goals
#align measurable_bsupr measurable_biSup

theorem aemeasurable_biSup {Î¹} {Î¼ : Measure Î´} (s : Set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : s.Countable)
    (hf : âˆ€ i, AEMeasurable (f i) Î¼) : AEMeasurable (fun b => â¨† i âˆˆ s, f i b) Î¼ := by
  haveI : Encodable s := hs.toEncodable
  -- âŠ¢ AEMeasurable fun b => â¨† (i : Î¹) (_ : i âˆˆ s), f i b
  simp only [iSup_subtype']
  -- âŠ¢ AEMeasurable fun b => â¨† (x : { i // i âˆˆ s }), f (â†‘x) b
  exact aemeasurable_iSup fun i => hf i
  -- ğŸ‰ no goals
#align ae_measurable_bsupr aemeasurable_biSup

theorem measurable_biInf {Î¹} (s : Set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : s.Countable)
    (hf : âˆ€ i, Measurable (f i)) : Measurable fun b => â¨… i âˆˆ s, f i b := by
  haveI : Encodable s := hs.toEncodable
  -- âŠ¢ Measurable fun b => â¨… (i : Î¹) (_ : i âˆˆ s), f i b
  simp only [iInf_subtype']
  -- âŠ¢ Measurable fun b => â¨… (x : { i // i âˆˆ s }), f (â†‘x) b
  exact measurable_iInf fun i => hf i
  -- ğŸ‰ no goals
#align measurable_binfi measurable_biInf

theorem aemeasurable_biInf {Î¹} {Î¼ : Measure Î´} (s : Set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : s.Countable)
    (hf : âˆ€ i, AEMeasurable (f i) Î¼) : AEMeasurable (fun b => â¨… i âˆˆ s, f i b) Î¼ := by
  haveI : Encodable s := hs.toEncodable
  -- âŠ¢ AEMeasurable fun b => â¨… (i : Î¹) (_ : i âˆˆ s), f i b
  simp only [iInf_subtype']
  -- âŠ¢ AEMeasurable fun b => â¨… (x : { i // i âˆˆ s }), f (â†‘x) b
  exact aemeasurable_iInf fun i => hf i
  -- ğŸ‰ no goals
#align ae_measurable_binfi aemeasurable_biInf

/-- `liminf` over a general filter is measurable. See `measurable_liminf` for the version over `â„•`.
-/
theorem measurable_liminf' {Î¹ Î¹'} {f : Î¹ â†’ Î´ â†’ Î±} {u : Filter Î¹} (hf : âˆ€ i, Measurable (f i))
    {p : Î¹' â†’ Prop} {s : Î¹' â†’ Set Î¹} (hu : u.HasCountableBasis p s) (hs : âˆ€ i, (s i).Countable) :
    Measurable fun x => liminf (fun i => f i x) u := by
  simp_rw [hu.toHasBasis.liminf_eq_iSup_iInf]
  -- âŠ¢ Measurable fun x => â¨† (i : Î¹') (_ : p i), â¨… (a : Î¹) (_ : a âˆˆ s i), f a x
  refine' measurable_biSup _ hu.countable _
  -- âŠ¢ âˆ€ (i : Î¹'), Measurable fun x => â¨… (a : Î¹) (_ : a âˆˆ s i), f a x
  exact fun i => measurable_biInf _ (hs i) hf
  -- ğŸ‰ no goals
#align measurable_liminf' measurable_liminf'

/-- `limsup` over a general filter is measurable. See `measurable_limsup` for the version over `â„•`.
-/
theorem measurable_limsup' {Î¹ Î¹'} {f : Î¹ â†’ Î´ â†’ Î±} {u : Filter Î¹} (hf : âˆ€ i, Measurable (f i))
    {p : Î¹' â†’ Prop} {s : Î¹' â†’ Set Î¹} (hu : u.HasCountableBasis p s) (hs : âˆ€ i, (s i).Countable) :
    Measurable fun x => limsup (fun i => f i x) u := by
  simp_rw [hu.toHasBasis.limsup_eq_iInf_iSup]
  -- âŠ¢ Measurable fun x => â¨… (i : Î¹') (_ : p i), â¨† (a : Î¹) (_ : a âˆˆ s i), f a x
  refine' measurable_biInf _ hu.countable _
  -- âŠ¢ âˆ€ (i : Î¹'), Measurable fun x => â¨† (a : Î¹) (_ : a âˆˆ s i), f a x
  exact fun i => measurable_biSup _ (hs i) hf
  -- ğŸ‰ no goals
#align measurable_limsup' measurable_limsup'

/-- `liminf` over `â„•` is measurable. See `measurable_liminf'` for a version with a general filter.
-/
@[measurability]
theorem measurable_liminf {f : â„• â†’ Î´ â†’ Î±} (hf : âˆ€ i, Measurable (f i)) :
    Measurable fun x => liminf (fun i => f i x) atTop :=
  measurable_liminf' hf atTop_countable_basis fun _ => to_countable _
#align measurable_liminf measurable_liminf

/-- `limsup` over `â„•` is measurable. See `measurable_limsup'` for a version with a general filter.
-/
@[measurability]
theorem measurable_limsup {f : â„• â†’ Î´ â†’ Î±} (hf : âˆ€ i, Measurable (f i)) :
    Measurable fun x => limsup (fun i => f i x) atTop :=
  measurable_limsup' hf atTop_countable_basis fun _ => to_countable _
#align measurable_limsup measurable_limsup

end CompleteLinearOrder

section ConditionallyCompleteLinearOrder

variable [ConditionallyCompleteLinearOrder Î±] [OrderTopology Î±] [SecondCountableTopology Î±]

theorem measurable_cSup {Î¹} {f : Î¹ â†’ Î´ â†’ Î±} {s : Set Î¹} (hs : s.Countable)
    (hf : âˆ€ i, Measurable (f i)) (bdd : âˆ€ x, BddAbove ((fun i => f i x) '' s)) :
    Measurable fun x => sSup ((fun i => f i x) '' s) := by
  cases' eq_empty_or_nonempty s with h2s h2s
  -- âŠ¢ Measurable fun x => sSup ((fun i => f i x) '' s)
  Â· simp [h2s, measurable_const]
    -- ğŸ‰ no goals
  Â· apply measurable_of_Iic
    -- âŠ¢ âˆ€ (x : Î±), MeasurableSet ((fun x => sSup ((fun i => f i x) '' s)) â»Â¹' Iic x)
    intro y
    -- âŠ¢ MeasurableSet ((fun x => sSup ((fun i => f i x) '' s)) â»Â¹' Iic y)
    simp_rw [preimage, mem_Iic, csSup_le_iff (bdd _) (h2s.image _), ball_image_iff, setOf_forall]
    -- âŠ¢ MeasurableSet (â‹‚ (i : Î¹) (_ : i âˆˆ s), {x | f i x â‰¤ y})
    exact MeasurableSet.biInter hs fun i _ => measurableSet_le (hf i) measurable_const
    -- ğŸ‰ no goals
#align measurable_cSup measurable_cSup

theorem measurable_cInf {Î¹} {f : Î¹ â†’ Î´ â†’ Î±} {s : Set Î¹} (hs : s.Countable)
    (hf : âˆ€ i, Measurable (f i)) (bdd : âˆ€ x, BddBelow ((fun i => f i x) '' s)) :
    Measurable fun x => sInf ((fun i => f i x) '' s) :=
  @measurable_cSup Î±áµ’áµˆ _ _ _ _ _ _ _ _ _ _ _ hs hf bdd
#align measurable_cInf measurable_cInf

theorem measurable_ciSup {Î¹ : Type*} [Countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} (hf : âˆ€ i, Measurable (f i))
    (bdd : âˆ€ x, BddAbove (range fun i => f i x)) : Measurable fun x => â¨† i, f i x := by
  change Measurable fun x => sSup (range fun i : Î¹ => f i x)
  -- âŠ¢ Measurable fun x => sSup (range fun i => f i x)
  simp_rw [â† image_univ] at bdd âŠ¢
  -- âŠ¢ Measurable fun x => sSup ((fun i => f i x) '' univ)
  refine' measurable_cSup countable_univ hf bdd
  -- ğŸ‰ no goals
#align measurable_csupr measurable_ciSup

theorem measurable_ciInf {Î¹ : Type*} [Countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} (hf : âˆ€ i, Measurable (f i))
    (bdd : âˆ€ x, BddBelow (range fun i => f i x)) : Measurable fun x => â¨… i, f i x :=
  @measurable_ciSup Î±áµ’áµˆ _ _ _ _ _ _ _ _ _ _ _ hf bdd
#align measurable_cinfi measurable_ciInf

end ConditionallyCompleteLinearOrder

/-- Convert a `Homeomorph` to a `MeasurableEquiv`. -/
def Homemorph.toMeasurableEquiv (h : Î± â‰ƒâ‚œ Î²) : Î± â‰ƒáµ Î² where
  toEquiv := h.toEquiv
  measurable_toFun := h.continuous_toFun.measurable
  measurable_invFun := h.continuous_invFun.measurable
#align homemorph.to_measurable_equiv Homemorph.toMeasurableEquiv

protected theorem IsFiniteMeasureOnCompacts.map {Î± : Type*} {m0 : MeasurableSpace Î±}
    [TopologicalSpace Î±] [OpensMeasurableSpace Î±] {Î² : Type*} [MeasurableSpace Î²]
    [TopologicalSpace Î²] [BorelSpace Î²] [T2Space Î²] (Î¼ : Measure Î±) [IsFiniteMeasureOnCompacts Î¼]
    (f : Î± â‰ƒâ‚œ Î²) : IsFiniteMeasureOnCompacts (Measure.map f Î¼) :=
  âŸ¨by
    intro K hK
    -- âŠ¢ â†‘â†‘(Measure.map (â†‘f) Î¼) K < âŠ¤
    rw [Measure.map_apply f.measurable hK.measurableSet]
    -- âŠ¢ â†‘â†‘Î¼ (â†‘f â»Â¹' K) < âŠ¤
    apply IsCompact.measure_lt_top
    -- âŠ¢ IsCompact (â†‘f â»Â¹' K)
    rwa [f.isCompact_preimage]âŸ©
    -- ğŸ‰ no goals
#align is_finite_measure_on_compacts.map IsFiniteMeasureOnCompacts.map

end BorelSpace

instance Empty.borelSpace : BorelSpace Empty :=
  âŸ¨borel_eq_top_of_discrete.symmâŸ©
#align empty.borel_space Empty.borelSpace

instance Unit.borelSpace : BorelSpace Unit :=
  âŸ¨borel_eq_top_of_discrete.symmâŸ©
#align unit.borel_space Unit.borelSpace

instance Bool.borelSpace : BorelSpace Bool :=
  âŸ¨borel_eq_top_of_discrete.symmâŸ©
#align bool.borel_space Bool.borelSpace

instance Nat.borelSpace : BorelSpace â„• :=
  âŸ¨borel_eq_top_of_discrete.symmâŸ©
#align nat.borel_space Nat.borelSpace

instance Int.borelSpace : BorelSpace â„¤ :=
  âŸ¨borel_eq_top_of_discrete.symmâŸ©
#align int.borel_space Int.borelSpace

instance Rat.borelSpace : BorelSpace â„š :=
  âŸ¨borel_eq_top_of_countable.symmâŸ©
#align rat.borel_space Rat.borelSpace

/- Instances on `Real` and `Complex` are special cases of `IsROrC` but without these instances,
Lean fails to prove `BorelSpace (Î¹ â†’ â„)`, so we leave them here. -/
instance Real.measurableSpace : MeasurableSpace â„ :=
  borel â„
#align real.measurable_space Real.measurableSpace

instance Real.borelSpace : BorelSpace â„ :=
  âŸ¨rflâŸ©
#align real.borel_space Real.borelSpace

instance NNReal.measurableSpace : MeasurableSpace â„â‰¥0 :=
  Subtype.instMeasurableSpace
#align nnreal.measurable_space NNReal.measurableSpace

instance NNReal.borelSpace : BorelSpace â„â‰¥0 :=
  Subtype.borelSpace _
#align nnreal.borel_space NNReal.borelSpace

instance ENNReal.measurableSpace : MeasurableSpace â„â‰¥0âˆ :=
  borel â„â‰¥0âˆ
#align ennreal.measurable_space ENNReal.measurableSpace

instance ENNReal.borelSpace : BorelSpace â„â‰¥0âˆ :=
  âŸ¨rflâŸ©
#align ennreal.borel_space ENNReal.borelSpace

instance EReal.measurableSpace : MeasurableSpace EReal :=
  borel EReal
#align ereal.measurable_space EReal.measurableSpace

instance EReal.borelSpace : BorelSpace EReal :=
  âŸ¨rflâŸ©
#align ereal.borel_space EReal.borelSpace

/-- One can cut out `â„â‰¥0âˆ` into the sets `{0}`, `Ico (t^n) (t^(n+1))` for `n : â„¤` and `{âˆ}`. This
gives a way to compute the measure of a set in terms of sets on which a given function `f` does not
fluctuate by more than `t`. -/
theorem measure_eq_measure_preimage_add_measure_tsum_Ico_zpow [MeasurableSpace Î±] (Î¼ : Measure Î±)
    {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) {s : Set Î±} (hs : MeasurableSet s) {t : â„â‰¥0} (ht : 1 < t) :
    Î¼ s =
      Î¼ (s âˆ© f â»Â¹' {0}) + Î¼ (s âˆ© f â»Â¹' {âˆ}) +
      âˆ‘' n : â„¤, Î¼ (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) := by
  have A : Î¼ s = Î¼ (s âˆ© f â»Â¹' {0}) + Î¼ (s âˆ© f â»Â¹' Ioi 0) := by
    rw [â† measure_union]
    Â· congr 1
      ext x
      have : 0 = f x âˆ¨ 0 < f x := eq_or_lt_of_le bot_le
      rw [eq_comm] at this
      simp only [â† and_or_left, this, mem_singleton_iff, mem_inter_iff, and_true_iff, mem_union,
        mem_Ioi, mem_preimage]
    Â· refine disjoint_left.2 fun x hx h'x => ?_
      have : 0 < f x := h'x.2
      exact lt_irrefl 0 (this.trans_le hx.2.le)
    Â· exact hs.inter (hf measurableSet_Ioi)
  have B : Î¼ (s âˆ© f â»Â¹' Ioi 0) = Î¼ (s âˆ© f â»Â¹' {âˆ}) + Î¼ (s âˆ© f â»Â¹' Ioo 0 âˆ) := by
    rw [â† measure_union]
    Â· rw [â† inter_union_distrib_left]
      congr
      ext x
      simp only [mem_singleton_iff, mem_union, mem_Ioo, mem_Ioi, mem_preimage]
      have H : f x = âˆ âˆ¨ f x < âˆ := eq_or_lt_of_le le_top
      cases' H with H H
      Â· simp only [H, eq_self_iff_true, or_false_iff, WithTop.zero_lt_top, not_top_lt,
          and_false_iff]
      Â· simp only [H, H.ne, and_true_iff, false_or_iff]
    Â· refine disjoint_left.2 fun x hx h'x => ?_
      have : f x < âˆ := h'x.2.2
      exact lt_irrefl _ (this.trans_le (le_of_eq hx.2.symm))
    Â· exact hs.inter (hf measurableSet_Ioo)
  have C : Î¼ (s âˆ© f â»Â¹' Ioo 0 âˆ) =
      âˆ‘' n : â„¤, Î¼ (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) := by
    rw [â† measure_iUnion,
      ENNReal.Ioo_zero_top_eq_iUnion_Ico_zpow (ENNReal.one_lt_coe_iff.2 ht) ENNReal.coe_ne_top,
      preimage_iUnion, inter_iUnion]
    Â· intro i j
      simp only [Function.onFun]
      intro hij
      wlog h : i < j generalizing i j
      Â· exact (this hij.symm (hij.lt_or_lt.resolve_left h)).symm
      refine disjoint_left.2 fun x hx h'x => lt_irrefl (f x) ?_
      calc
        f x < (t : â„â‰¥0âˆ) ^ (i + 1) := hx.2.2
        _ â‰¤ (t : â„â‰¥0âˆ) ^ j := (ENNReal.zpow_le_of_le (ENNReal.one_le_coe_iff.2 ht.le) h)
        _ â‰¤ f x := h'x.2.1
    Â· intro n
      exact hs.inter (hf measurableSet_Ico)
  rw [A, B, C, add_assoc]
  -- ğŸ‰ no goals
#align measure_eq_measure_preimage_add_measure_tsum_Ico_zpow measure_eq_measure_preimage_add_measure_tsum_Ico_zpow

section PseudoMetricSpace

variable [PseudoMetricSpace Î±] [MeasurableSpace Î±] [OpensMeasurableSpace Î±]

variable [MeasurableSpace Î²] {x : Î±} {Îµ : â„}

open Metric

@[measurability]
theorem measurableSet_ball : MeasurableSet (Metric.ball x Îµ) :=
  Metric.isOpen_ball.measurableSet
#align measurable_set_ball measurableSet_ball

@[measurability]
theorem measurableSet_closedBall : MeasurableSet (Metric.closedBall x Îµ) :=
  Metric.isClosed_ball.measurableSet
#align measurable_set_closed_ball measurableSet_closedBall

@[measurability]
theorem measurable_infDist {s : Set Î±} : Measurable fun x => infDist x s :=
  (continuous_infDist_pt s).measurable
#align measurable_inf_dist measurable_infDist

@[measurability]
theorem Measurable.infDist {f : Î² â†’ Î±} (hf : Measurable f) {s : Set Î±} :
    Measurable fun x => infDist (f x) s :=
  measurable_infDist.comp hf
#align measurable.inf_dist Measurable.infDist

@[measurability]
theorem measurable_infNndist {s : Set Î±} : Measurable fun x => infNndist x s :=
  (continuous_infNndist_pt s).measurable
#align measurable_inf_nndist measurable_infNndist

@[measurability]
theorem Measurable.infNndist {f : Î² â†’ Î±} (hf : Measurable f) {s : Set Î±} :
    Measurable fun x => infNndist (f x) s :=
  measurable_infNndist.comp hf
#align measurable.inf_nndist Measurable.infNndist

section

variable [SecondCountableTopology Î±]

@[measurability]
theorem measurable_dist : Measurable fun p : Î± Ã— Î± => dist p.1 p.2 :=
  continuous_dist.measurable
#align measurable_dist measurable_dist

@[measurability]
theorem Measurable.dist {f g : Î² â†’ Î±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun b => dist (f b) (g b) :=
  (@continuous_dist Î± _).measurable2 hf hg
#align measurable.dist Measurable.dist

@[measurability]
theorem measurable_nndist : Measurable fun p : Î± Ã— Î± => nndist p.1 p.2 :=
  continuous_nndist.measurable
#align measurable_nndist measurable_nndist

@[measurability]
theorem Measurable.nndist {f g : Î² â†’ Î±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun b => nndist (f b) (g b) :=
  (@continuous_nndist Î± _).measurable2 hf hg
#align measurable.nndist Measurable.nndist

end

end PseudoMetricSpace

section PseudoEMetricSpace

variable [PseudoEMetricSpace Î±] [MeasurableSpace Î±] [OpensMeasurableSpace Î±]

variable [MeasurableSpace Î²] {x : Î±} {Îµ : â„â‰¥0âˆ}

open EMetric

@[measurability]
theorem measurableSet_eball : MeasurableSet (EMetric.ball x Îµ) :=
  EMetric.isOpen_ball.measurableSet
#align measurable_set_eball measurableSet_eball

@[measurability]
theorem measurable_edist_right : Measurable (edist x) :=
  (continuous_const.edist continuous_id).measurable
#align measurable_edist_right measurable_edist_right

@[measurability]
theorem measurable_edist_left : Measurable fun y => edist y x :=
  (continuous_id.edist continuous_const).measurable
#align measurable_edist_left measurable_edist_left

@[measurability]
theorem measurable_infEdist {s : Set Î±} : Measurable fun x => infEdist x s :=
  continuous_infEdist.measurable
#align measurable_inf_edist measurable_infEdist

@[measurability]
theorem Measurable.infEdist {f : Î² â†’ Î±} (hf : Measurable f) {s : Set Î±} :
    Measurable fun x => infEdist (f x) s :=
  measurable_infEdist.comp hf
#align measurable.inf_edist Measurable.infEdist

open Metric EMetric

/-- If a set has a closed thickening with finite measure, then the measure of its `r`-closed
thickenings converges to the measure of its closure as `r` tends to `0`. -/
theorem tendsto_measure_cthickening {Î¼ : Measure Î±} {s : Set Î±}
    (hs : âˆƒ R > 0, Î¼ (cthickening R s) â‰  âˆ) :
    Tendsto (fun r => Î¼ (cthickening r s)) (ğ“ 0) (ğ“ (Î¼ (closure s))) := by
  have A : Tendsto (fun r => Î¼ (cthickening r s)) (ğ“[Ioi 0] 0) (ğ“ (Î¼ (closure s))) := by
    rw [closure_eq_iInter_cthickening]
    exact
      tendsto_measure_biInter_gt (fun r _ => isClosed_cthickening.measurableSet)
        (fun i j _ ij => cthickening_mono ij _) hs
  have B : Tendsto (fun r => Î¼ (cthickening r s)) (ğ“[Iic 0] 0) (ğ“ (Î¼ (closure s))) := by
    apply Tendsto.congr' _ tendsto_const_nhds
    filter_upwards [self_mem_nhdsWithin (Î± := â„)] with _ hr
    rw [cthickening_of_nonpos hr]
  convert B.sup A
  -- âŠ¢ ğ“ 0 = ğ“[Iic 0] 0 âŠ” ğ“[Ioi 0] 0
  exact (nhds_left_sup_nhds_right' 0).symm
  -- ğŸ‰ no goals
#align tendsto_measure_cthickening tendsto_measure_cthickening

/-- If a closed set has a closed thickening with finite measure, then the measure of its closed
`r`-thickenings converge to its measure as `r` tends to `0`. -/
theorem tendsto_measure_cthickening_of_isClosed {Î¼ : Measure Î±} {s : Set Î±}
    (hs : âˆƒ R > 0, Î¼ (cthickening R s) â‰  âˆ) (h's : IsClosed s) :
    Tendsto (fun r => Î¼ (cthickening r s)) (ğ“ 0) (ğ“ (Î¼ s)) := by
  convert tendsto_measure_cthickening hs
  -- âŠ¢ s = closure s
  exact h's.closure_eq.symm
  -- ğŸ‰ no goals
#align tendsto_measure_cthickening_of_is_closed tendsto_measure_cthickening_of_isClosed

/-- If a set has a thickening with finite measure, then the measures of its `r`-thickenings
converge to the measure of its closure as `r > 0` tends to `0`. -/
theorem tendsto_measure_thickening {Î¼ : Measure Î±} {s : Set Î±}
    (hs : âˆƒ R > 0, Î¼ (thickening R s) â‰  âˆ) :
    Tendsto (fun r => Î¼ (thickening r s)) (ğ“[>] 0) (ğ“ (Î¼ (closure s))) := by
  rw [closure_eq_iInter_thickening]
  -- âŠ¢ Tendsto (fun r => â†‘â†‘Î¼ (thickening r s)) (ğ“[Ioi 0] 0) (ğ“ (â†‘â†‘Î¼ (â‹‚ (Î´ : â„) (_ : â€¦
  exact tendsto_measure_biInter_gt (fun r _ => isOpen_thickening.measurableSet)
      (fun i j _ ij => thickening_mono ij _) hs

/-- If a closed set has a thickening with finite measure, then the measure of its
`r`-thickenings converge to its measure as `r > 0` tends to `0`. -/
theorem tendsto_measure_thickening_of_isClosed {Î¼ : Measure Î±} {s : Set Î±}
    (hs : âˆƒ R > 0, Î¼ (thickening R s) â‰  âˆ) (h's : IsClosed s) :
    Tendsto (fun r => Î¼ (thickening r s)) (ğ“[>] 0) (ğ“ (Î¼ s)) := by
  convert tendsto_measure_thickening hs
  -- âŠ¢ s = closure s
  exact h's.closure_eq.symm
  -- ğŸ‰ no goals

variable [SecondCountableTopology Î±]

@[measurability]
theorem measurable_edist : Measurable fun p : Î± Ã— Î± => edist p.1 p.2 :=
  continuous_edist.measurable
#align measurable_edist measurable_edist

@[measurability]
theorem Measurable.edist {f g : Î² â†’ Î±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun b => edist (f b) (g b) :=
  (@continuous_edist Î± _).measurable2 hf hg
#align measurable.edist Measurable.edist

@[measurability]
theorem AEMeasurable.edist {f g : Î² â†’ Î±} {Î¼ : Measure Î²} (hf : AEMeasurable f Î¼)
    (hg : AEMeasurable g Î¼) : AEMeasurable (fun a => edist (f a) (g a)) Î¼ :=
  (@continuous_edist Î± _).aemeasurable2 hf hg
#align ae_measurable.edist AEMeasurable.edist

end PseudoEMetricSpace

/-- Given a compact set in a proper space, the measure of its `r`-closed thickenings converges to
its measure as `r` tends to `0`. -/
theorem tendsto_measure_cthickening_of_isCompact [MetricSpace Î±] [MeasurableSpace Î±]
    [OpensMeasurableSpace Î±] [ProperSpace Î±] {Î¼ : Measure Î±} [IsFiniteMeasureOnCompacts Î¼]
    {s : Set Î±} (hs : IsCompact s) :
    Tendsto (fun r => Î¼ (Metric.cthickening r s)) (ğ“ 0) (ğ“ (Î¼ s)) :=
  tendsto_measure_cthickening_of_isClosed âŸ¨1, zero_lt_one, hs.bounded.cthickening.measure_lt_top.neâŸ©
    hs.isClosed
#align tendsto_measure_cthickening_of_is_compact tendsto_measure_cthickening_of_isCompact

namespace Real

open MeasurableSpace MeasureTheory

theorem borel_eq_generateFrom_Ioo_rat :
    borel â„ = .generateFrom (â‹ƒ (a : â„š) (b : â„š) (_ : a < b), {Ioo (a : â„) (b : â„)}) :=
  isTopologicalBasis_Ioo_rat.borel_eq_generateFrom
#align real.borel_eq_generate_from_Ioo_rat Real.borel_eq_generateFrom_Ioo_rat

theorem borel_eq_generateFrom_Iio_rat : borel â„ = .generateFrom (â‹ƒ a : â„š, {Iio (a : â„)}) := by
  rw [borel_eq_generateFrom_Iio]
  -- âŠ¢ MeasurableSpace.generateFrom (range Iio) = MeasurableSpace.generateFrom (â‹ƒ ( â€¦
  refine le_antisymm
    (generateFrom_le ?_)
    (generateFrom_mono <| iUnion_subset fun q â†¦ singleton_subset_iff.mpr <| mem_range_self _)
  rintro _ âŸ¨a, rflâŸ©
  -- âŠ¢ MeasurableSet (Iio a)
  have : IsLUB (range ((â†‘) : â„š â†’ â„) âˆ© Iio a) a := by
    simp [isLUB_iff_le_iff, mem_upperBounds, â† le_iff_forall_rat_lt_imp_le]
  rw [â† this.biUnion_Iio_eq, â† image_univ, â† image_inter_preimage, univ_inter, biUnion_image]
  -- âŠ¢ MeasurableSet (â‹ƒ (y : â„š) (_ : y âˆˆ Rat.cast â»Â¹' Iio a), Iio â†‘y)
  exact MeasurableSet.biUnion (to_countable _)
    fun b _ => GenerateMeasurable.basic (Iio (b : â„)) (by simp)

theorem borel_eq_generateFrom_Ioi_rat : borel â„ = .generateFrom (â‹ƒ a : â„š, {Ioi (a : â„)}) := by
  rw [borel_eq_generateFrom_Ioi]
  -- âŠ¢ MeasurableSpace.generateFrom (range Ioi) = MeasurableSpace.generateFrom (â‹ƒ ( â€¦
  refine le_antisymm
    (generateFrom_le ?_)
    (generateFrom_mono <| iUnion_subset fun q â†¦ singleton_subset_iff.mpr <| mem_range_self _)
  rintro _ âŸ¨a, rflâŸ©
  -- âŠ¢ MeasurableSet (Ioi a)
  have : IsGLB (range ((â†‘) : â„š â†’ â„) âˆ© Ioi a) a := by
    simp [isGLB_iff_le_iff, mem_lowerBounds, â† le_iff_forall_lt_rat_imp_le]
  rw [â† this.biUnion_Ioi_eq, â† image_univ, â† image_inter_preimage, univ_inter, biUnion_image]
  -- âŠ¢ MeasurableSet (â‹ƒ (y : â„š) (_ : y âˆˆ Rat.cast â»Â¹' Ioi a), Ioi â†‘y)
  exact MeasurableSet.biUnion (to_countable _)
    fun b _ => GenerateMeasurable.basic (Ioi (b : â„)) (by simp)

theorem borel_eq_generateFrom_Iic_rat : borel â„ = .generateFrom (â‹ƒ a : â„š, {Iic (a : â„)}) := by
  rw [borel_eq_generateFrom_Ioi_rat, iUnion_singleton_eq_range, iUnion_singleton_eq_range]
  -- âŠ¢ MeasurableSpace.generateFrom (range fun a => Ioi â†‘a) = MeasurableSpace.gener â€¦
  refine le_antisymm (generateFrom_le ?_) (generateFrom_le ?_) <;>
  rintro _ âŸ¨q, rflâŸ© <;>
  dsimp only <;>
  [rw [â† compl_Iic]; rw [â† compl_Ioi]] <;>
  exact MeasurableSet.compl (GenerateMeasurable.basic _ (mem_range_self q))
  -- ğŸ‰ no goals
  -- ğŸ‰ no goals

theorem borel_eq_generateFrom_Ici_rat : borel â„ = .generateFrom (â‹ƒ a : â„š, {Ici (a : â„)}) := by
  rw [borel_eq_generateFrom_Iio_rat, iUnion_singleton_eq_range, iUnion_singleton_eq_range]
  -- âŠ¢ MeasurableSpace.generateFrom (range fun a => Iio â†‘a) = MeasurableSpace.gener â€¦
  refine le_antisymm (generateFrom_le ?_) (generateFrom_le ?_) <;>
  rintro _ âŸ¨q, rflâŸ© <;>
  dsimp only <;>
  [rw [â† compl_Ici]; rw [â† compl_Iio]] <;>
  exact MeasurableSet.compl (GenerateMeasurable.basic _ (mem_range_self q))
  -- ğŸ‰ no goals
  -- ğŸ‰ no goals

theorem isPiSystem_Ioo_rat :
    IsPiSystem (â‹ƒ (a : â„š) (b : â„š) (_ : a < b), {Ioo (a : â„) (b : â„)}) := by
  convert isPiSystem_Ioo ((â†‘) : â„š â†’ â„) ((â†‘) : â„š â†’ â„)
  -- âŠ¢ â‹ƒ (a : â„š) (b : â„š) (_ : a < b), {Ioo â†‘a â†‘b} = {S | âˆƒ l u, â†‘l < â†‘u âˆ§ Ioo â†‘l â†‘u â€¦
  ext x
  -- âŠ¢ x âˆˆ â‹ƒ (a : â„š) (b : â„š) (_ : a < b), {Ioo â†‘a â†‘b} â†” x âˆˆ {S | âˆƒ l u, â†‘l < â†‘u âˆ§ I â€¦
  simp [eq_comm]
  -- ğŸ‰ no goals
#align real.is_pi_system_Ioo_rat Real.isPiSystem_Ioo_rat

theorem isPiSystem_Iio_rat : IsPiSystem (â‹ƒ a : â„š, {Iio (a : â„)}) := by
  convert isPiSystem_image_Iio (((â†‘) : â„š â†’ â„) '' univ)
  -- âŠ¢ â‹ƒ (a : â„š), {Iio â†‘a} = Iio '' (Rat.cast '' univ)
  ext x
  -- âŠ¢ x âˆˆ â‹ƒ (a : â„š), {Iio â†‘a} â†” x âˆˆ Iio '' (Rat.cast '' univ)
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]
  -- ğŸ‰ no goals

theorem isPiSystem_Ioi_rat : IsPiSystem (â‹ƒ a : â„š, {Ioi (a : â„)}) := by
  convert isPiSystem_image_Ioi (((â†‘) : â„š â†’ â„) '' univ)
  -- âŠ¢ â‹ƒ (a : â„š), {Ioi â†‘a} = Ioi '' (Rat.cast '' univ)
  ext x
  -- âŠ¢ x âˆˆ â‹ƒ (a : â„š), {Ioi â†‘a} â†” x âˆˆ Ioi '' (Rat.cast '' univ)
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]
  -- ğŸ‰ no goals

theorem isPiSystem_Iic_rat : IsPiSystem (â‹ƒ a : â„š, {Iic (a : â„)}) := by
  convert isPiSystem_image_Iic (((â†‘) : â„š â†’ â„) '' univ)
  -- âŠ¢ â‹ƒ (a : â„š), {Iic â†‘a} = Iic '' (Rat.cast '' univ)
  ext x
  -- âŠ¢ x âˆˆ â‹ƒ (a : â„š), {Iic â†‘a} â†” x âˆˆ Iic '' (Rat.cast '' univ)
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]
  -- ğŸ‰ no goals

theorem isPiSystem_Ici_rat : IsPiSystem (â‹ƒ a : â„š, {Ici (a : â„)}) := by
  convert isPiSystem_image_Ici (((â†‘) : â„š â†’ â„) '' univ)
  -- âŠ¢ â‹ƒ (a : â„š), {Ici â†‘a} = Ici '' (Rat.cast '' univ)
  ext x
  -- âŠ¢ x âˆˆ â‹ƒ (a : â„š), {Ici â†‘a} â†” x âˆˆ Ici '' (Rat.cast '' univ)
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]
  -- ğŸ‰ no goals

/-- The intervals `(-(n + 1), (n + 1))` form a finite spanning sets in the set of open intervals
with rational endpoints for a locally finite measure `Î¼` on `â„`. -/
def finiteSpanningSetsInIooRat (Î¼ : Measure â„) [IsLocallyFiniteMeasure Î¼] :
    Î¼.FiniteSpanningSetsIn (â‹ƒ (a : â„š) (b : â„š) (_ : a < b), {Ioo (a : â„) (b : â„)}) where
  set n := Ioo (-(n + 1)) (n + 1)
  set_mem n := by
    simp only [mem_iUnion, mem_singleton_iff]
    -- âŠ¢ âˆƒ i i_1 h, Ioo (-(â†‘n + 1)) (â†‘n + 1) = Ioo â†‘i â†‘i_1
    refine' âŸ¨-(n + 1 : â„•), n + 1, _, by simpâŸ©
    -- âŠ¢ -â†‘(n + 1) < â†‘n + 1
    -- TODO: norm_cast fails here?
    exact (neg_nonpos.2 (@Nat.cast_nonneg â„š _ (n + 1))).trans_lt n.cast_add_one_pos
    -- ğŸ‰ no goals
  finite n := measure_Ioo_lt_top
  spanning :=
    iUnion_eq_univ_iff.2 fun x =>
      âŸ¨âŒŠ|x|âŒ‹â‚Š, neg_lt.1 ((neg_le_abs_self x).trans_lt (Nat.lt_floor_add_one _)),
        (le_abs_self x).trans_lt (Nat.lt_floor_add_one _)âŸ©
#align real.finite_spanning_sets_in_Ioo_rat Real.finiteSpanningSetsInIooRat

theorem measure_ext_Ioo_rat {Î¼ Î½ : Measure â„} [IsLocallyFiniteMeasure Î¼]
    (h : âˆ€ a b : â„š, Î¼ (Ioo a b) = Î½ (Ioo a b)) : Î¼ = Î½ :=
  (finiteSpanningSetsInIooRat Î¼).ext borel_eq_generateFrom_Ioo_rat isPiSystem_Ioo_rat <| by
    simp only [mem_iUnion, mem_singleton_iff]
    -- âŠ¢ âˆ€ (s : Set â„), (âˆƒ i i_1 h, s = Ioo â†‘i â†‘i_1) â†’ â†‘â†‘Î¼ s = â†‘â†‘Î½ s
    rintro _ âŸ¨a, b, -, rflâŸ©
    -- âŠ¢ â†‘â†‘Î¼ (Ioo â†‘a â†‘b) = â†‘â†‘Î½ (Ioo â†‘a â†‘b)
    apply h
    -- ğŸ‰ no goals
#align real.measure_ext_Ioo_rat Real.measure_ext_Ioo_rat

end Real

variable [MeasurableSpace Î±]

@[measurability]
theorem measurable_real_toNNReal : Measurable Real.toNNReal :=
  continuous_real_toNNReal.measurable
#align measurable_real_to_nnreal measurable_real_toNNReal

@[measurability]
theorem Measurable.real_toNNReal {f : Î± â†’ â„} (hf : Measurable f) :
    Measurable fun x => Real.toNNReal (f x) :=
  measurable_real_toNNReal.comp hf
#align measurable.real_to_nnreal Measurable.real_toNNReal

@[measurability]
theorem AEMeasurable.real_toNNReal {f : Î± â†’ â„} {Î¼ : Measure Î±} (hf : AEMeasurable f Î¼) :
    AEMeasurable (fun x => Real.toNNReal (f x)) Î¼ :=
  measurable_real_toNNReal.comp_aemeasurable hf
#align ae_measurable.real_to_nnreal AEMeasurable.real_toNNReal

@[measurability]
theorem measurable_coe_nnreal_real : Measurable ((â†‘) : â„â‰¥0 â†’ â„) :=
  NNReal.continuous_coe.measurable
#align measurable_coe_nnreal_real measurable_coe_nnreal_real

@[measurability]
theorem Measurable.coe_nnreal_real {f : Î± â†’ â„â‰¥0} (hf : Measurable f) :
    Measurable fun x => (f x : â„) :=
  measurable_coe_nnreal_real.comp hf
#align measurable.coe_nnreal_real Measurable.coe_nnreal_real

@[measurability]
theorem AEMeasurable.coe_nnreal_real {f : Î± â†’ â„â‰¥0} {Î¼ : Measure Î±} (hf : AEMeasurable f Î¼) :
    AEMeasurable (fun x => (f x : â„)) Î¼ :=
  measurable_coe_nnreal_real.comp_aemeasurable hf
#align ae_measurable.coe_nnreal_real AEMeasurable.coe_nnreal_real

@[measurability]
theorem measurable_coe_nnreal_ennreal : Measurable ((â†‘) : â„â‰¥0 â†’ â„â‰¥0âˆ) :=
  ENNReal.continuous_coe.measurable
#align measurable_coe_nnreal_ennreal measurable_coe_nnreal_ennreal

@[measurability]
theorem Measurable.coe_nnreal_ennreal {f : Î± â†’ â„â‰¥0} (hf : Measurable f) :
    Measurable fun x => (f x : â„â‰¥0âˆ) :=
  ENNReal.continuous_coe.measurable.comp hf
#align measurable.coe_nnreal_ennreal Measurable.coe_nnreal_ennreal

@[measurability]
theorem AEMeasurable.coe_nnreal_ennreal {f : Î± â†’ â„â‰¥0} {Î¼ : Measure Î±} (hf : AEMeasurable f Î¼) :
    AEMeasurable (fun x => (f x : â„â‰¥0âˆ)) Î¼ :=
  ENNReal.continuous_coe.measurable.comp_aemeasurable hf
#align ae_measurable.coe_nnreal_ennreal AEMeasurable.coe_nnreal_ennreal

@[measurability]
theorem Measurable.ennreal_ofReal {f : Î± â†’ â„} (hf : Measurable f) :
    Measurable fun x => ENNReal.ofReal (f x) :=
  ENNReal.continuous_ofReal.measurable.comp hf
#align measurable.ennreal_of_real Measurable.ennreal_ofReal

@[simp, norm_cast]
theorem measurable_coe_nnreal_real_iff {f : Î± â†’ â„â‰¥0} :
    Measurable (fun x => f x : Î± â†’ â„) â†” Measurable f :=
  âŸ¨fun h => by simpa only [Real.toNNReal_coe] using h.real_toNNReal, Measurable.coe_nnreal_realâŸ©
               -- ğŸ‰ no goals
#align measurable_coe_nnreal_real_iff measurable_coe_nnreal_real_iff

@[simp, norm_cast]
theorem aEMeasurable_coe_nnreal_real_iff {f : Î± â†’ â„â‰¥0} {Î¼ : Measure Î±} :
    AEMeasurable (fun x => f x : Î± â†’ â„) Î¼ â†” AEMeasurable f Î¼ :=
  âŸ¨fun h => by simpa only [Real.toNNReal_coe] using h.real_toNNReal, AEMeasurable.coe_nnreal_realâŸ©
               -- ğŸ‰ no goals
#align ae_measurable_coe_nnreal_real_iff aEMeasurable_coe_nnreal_real_iff

/-- The set of finite `â„â‰¥0âˆ` numbers is `MeasurableEquiv` to `â„â‰¥0`. -/
def MeasurableEquiv.ennrealEquivNNReal : { r : â„â‰¥0âˆ | r â‰  âˆ } â‰ƒáµ â„â‰¥0 :=
  ENNReal.neTopHomeomorphNNReal.toMeasurableEquiv
#align measurable_equiv.ennreal_equiv_nnreal MeasurableEquiv.ennrealEquivNNReal

namespace ENNReal

theorem measurable_of_measurable_nnreal {f : â„â‰¥0âˆ â†’ Î±} (h : Measurable fun p : â„â‰¥0 => f p) :
    Measurable f :=
  measurable_of_measurable_on_compl_singleton âˆ
    (MeasurableEquiv.ennrealEquivNNReal.symm.measurable_comp_iff.1 h)
#align ennreal.measurable_of_measurable_nnreal ENNReal.measurable_of_measurable_nnreal

/-- `â„â‰¥0âˆ` is `MeasurableEquiv` to `â„â‰¥0 âŠ• Unit`. -/
def ennrealEquivSum : â„â‰¥0âˆ â‰ƒáµ Sum â„â‰¥0 Unit :=
  { Equiv.optionEquivSumPUnit â„â‰¥0 with
    measurable_toFun := measurable_of_measurable_nnreal measurable_inl
    measurable_invFun :=
      measurable_sum measurable_coe_nnreal_ennreal (@measurable_const â„â‰¥0âˆ Unit _ _ âˆ) }
#align ennreal.ennreal_equiv_sum ENNReal.ennrealEquivSum

open Function (uncurry)

theorem measurable_of_measurable_nnreal_prod [MeasurableSpace Î²] [MeasurableSpace Î³]
    {f : â„â‰¥0âˆ Ã— Î² â†’ Î³} (Hâ‚ : Measurable fun p : â„â‰¥0 Ã— Î² => f (p.1, p.2))
    (Hâ‚‚ : Measurable fun x => f (âˆ, x)) : Measurable f :=
  let e : â„â‰¥0âˆ Ã— Î² â‰ƒáµ Sum (â„â‰¥0 Ã— Î²) (Unit Ã— Î²) :=
    (ennrealEquivSum.prodCongr (MeasurableEquiv.refl Î²)).trans
      (MeasurableEquiv.sumProdDistrib _ _ _)
  e.symm.measurable_comp_iff.1 <| measurable_sum Hâ‚ (Hâ‚‚.comp measurable_id.snd)
#align ennreal.measurable_of_measurable_nnreal_prod ENNReal.measurable_of_measurable_nnreal_prod

theorem measurable_of_measurable_nnreal_nnreal [MeasurableSpace Î²] {f : â„â‰¥0âˆ Ã— â„â‰¥0âˆ â†’ Î²}
    (hâ‚ : Measurable fun p : â„â‰¥0 Ã— â„â‰¥0 => f (p.1, p.2)) (hâ‚‚ : Measurable fun r : â„â‰¥0 => f (âˆ, r))
    (hâ‚ƒ : Measurable fun r : â„â‰¥0 => f (r, âˆ)) : Measurable f :=
  measurable_of_measurable_nnreal_prod
    (measurable_swap_iff.1 <| measurable_of_measurable_nnreal_prod (hâ‚.comp measurable_swap) hâ‚ƒ)
    (measurable_of_measurable_nnreal hâ‚‚)
#align ennreal.measurable_of_measurable_nnreal_nnreal ENNReal.measurable_of_measurable_nnreal_nnreal

@[measurability]
theorem measurable_ofReal : Measurable ENNReal.ofReal :=
  ENNReal.continuous_ofReal.measurable
#align ennreal.measurable_of_real ENNReal.measurable_ofReal

@[measurability]
theorem measurable_toReal : Measurable ENNReal.toReal :=
  ENNReal.measurable_of_measurable_nnreal measurable_coe_nnreal_real
#align ennreal.measurable_to_real ENNReal.measurable_toReal

@[measurability]
theorem measurable_toNNReal : Measurable ENNReal.toNNReal :=
  ENNReal.measurable_of_measurable_nnreal measurable_id
#align ennreal.measurable_to_nnreal ENNReal.measurable_toNNReal

instance instMeasurableMulâ‚‚ : MeasurableMulâ‚‚ â„â‰¥0âˆ := by
  refine' âŸ¨measurable_of_measurable_nnreal_nnreal _ _ _âŸ©
  Â· simp only [â† ENNReal.coe_mul, measurable_mul.coe_nnreal_ennreal]
    -- ğŸ‰ no goals
  Â· simp only [ENNReal.top_mul', ENNReal.coe_eq_zero]
    -- âŠ¢ Measurable fun r => if r = 0 then 0 else âŠ¤
    exact measurable_const.piecewise (measurableSet_singleton _) measurable_const
    -- ğŸ‰ no goals
  Â· simp only [ENNReal.mul_top', ENNReal.coe_eq_zero]
    -- âŠ¢ Measurable fun r => if r = 0 then 0 else âŠ¤
    exact measurable_const.piecewise (measurableSet_singleton _) measurable_const
    -- ğŸ‰ no goals
#align ennreal.has_measurable_mulâ‚‚ ENNReal.instMeasurableMulâ‚‚

instance instMeasurableSubâ‚‚ : MeasurableSubâ‚‚ â„â‰¥0âˆ :=
  âŸ¨by
    apply measurable_of_measurable_nnreal_nnreal <;>
      simp [â† WithTop.coe_sub]; exact continuous_sub.measurable.coe_nnreal_ennrealâŸ©
      -- âŠ¢ Measurable fun p => â†‘p.fst - â†‘p.snd
      -- ğŸ‰ no goals
      -- ğŸ‰ no goals
                                -- ğŸ‰ no goals
#align ennreal.has_measurable_subâ‚‚ ENNReal.instMeasurableSubâ‚‚

instance instMeasurableInv : MeasurableInv â„â‰¥0âˆ :=
  âŸ¨continuous_inv.measurableâŸ©
#align ennreal.has_measurable_inv ENNReal.instMeasurableInv

end ENNReal

@[measurability]
theorem Measurable.ennreal_toNNReal {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) :
    Measurable fun x => (f x).toNNReal :=
  ENNReal.measurable_toNNReal.comp hf
#align measurable.ennreal_to_nnreal Measurable.ennreal_toNNReal

@[measurability]
theorem AEMeasurable.ennreal_toNNReal {f : Î± â†’ â„â‰¥0âˆ} {Î¼ : Measure Î±} (hf : AEMeasurable f Î¼) :
    AEMeasurable (fun x => (f x).toNNReal) Î¼ :=
  ENNReal.measurable_toNNReal.comp_aemeasurable hf
#align ae_measurable.ennreal_to_nnreal AEMeasurable.ennreal_toNNReal

@[simp, norm_cast]
theorem measurable_coe_nnreal_ennreal_iff {f : Î± â†’ â„â‰¥0} :
    (Measurable fun x => (f x : â„â‰¥0âˆ)) â†” Measurable f :=
  âŸ¨fun h => h.ennreal_toNNReal, fun h => h.coe_nnreal_ennrealâŸ©
#align measurable_coe_nnreal_ennreal_iff measurable_coe_nnreal_ennreal_iff

@[simp, norm_cast]
theorem aemeasurable_coe_nnreal_ennreal_iff {f : Î± â†’ â„â‰¥0} {Î¼ : Measure Î±} :
    AEMeasurable (fun x => (f x : â„â‰¥0âˆ)) Î¼ â†” AEMeasurable f Î¼ :=
  âŸ¨fun h => h.ennreal_toNNReal, fun h => h.coe_nnreal_ennrealâŸ©
#align ae_measurable_coe_nnreal_ennreal_iff aemeasurable_coe_nnreal_ennreal_iff

@[measurability]
theorem Measurable.ennreal_toReal {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) :
    Measurable fun x => ENNReal.toReal (f x) :=
  ENNReal.measurable_toReal.comp hf
#align measurable.ennreal_to_real Measurable.ennreal_toReal

@[measurability]
theorem AEMeasurable.ennreal_toReal {f : Î± â†’ â„â‰¥0âˆ} {Î¼ : Measure Î±} (hf : AEMeasurable f Î¼) :
    AEMeasurable (fun x => ENNReal.toReal (f x)) Î¼ :=
  ENNReal.measurable_toReal.comp_aemeasurable hf
#align ae_measurable.ennreal_to_real AEMeasurable.ennreal_toReal

/-- note: `â„â‰¥0âˆ` can probably be generalized in a future version of this lemma. -/
@[measurability]
theorem Measurable.ennreal_tsum {Î¹} [Countable Î¹] {f : Î¹ â†’ Î± â†’ â„â‰¥0âˆ} (h : âˆ€ i, Measurable (f i)) :
    Measurable fun x => âˆ‘' i, f i x := by
  simp_rw [ENNReal.tsum_eq_iSup_sum]
  -- âŠ¢ Measurable fun x => â¨† (s : Finset Î¹), âˆ‘ i in s, f i x
  apply measurable_iSup
  -- âŠ¢ âˆ€ (i : Finset Î¹), Measurable fun b => âˆ‘ i in i, f i b
  exact fun s => s.measurable_sum fun i _ => h i
  -- ğŸ‰ no goals
#align measurable.ennreal_tsum Measurable.ennreal_tsum

@[measurability]
theorem Measurable.ennreal_tsum' {Î¹} [Countable Î¹] {f : Î¹ â†’ Î± â†’ â„â‰¥0âˆ} (h : âˆ€ i, Measurable (f i)) :
    Measurable (âˆ‘' i, f i) := by
  convert Measurable.ennreal_tsum h with x
  -- âŠ¢ tsum (fun i => f i) x = âˆ‘' (i : Î¹), f i x
  exact tsum_apply (Pi.summable.2 fun _ => ENNReal.summable)
  -- ğŸ‰ no goals
#align measurable.ennreal_tsum' Measurable.ennreal_tsum'

@[measurability]
theorem Measurable.nnreal_tsum {Î¹} [Countable Î¹] {f : Î¹ â†’ Î± â†’ â„â‰¥0} (h : âˆ€ i, Measurable (f i)) :
    Measurable fun x => âˆ‘' i, f i x := by
  simp_rw [NNReal.tsum_eq_toNNReal_tsum]
  -- âŠ¢ Measurable fun x => ENNReal.toNNReal (âˆ‘' (b : Î¹), â†‘(f b x))
  exact (Measurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_toNNReal
  -- ğŸ‰ no goals
#align measurable.nnreal_tsum Measurable.nnreal_tsum

@[measurability]
theorem AEMeasurable.ennreal_tsum {Î¹} [Countable Î¹] {f : Î¹ â†’ Î± â†’ â„â‰¥0âˆ} {Î¼ : Measure Î±}
    (h : âˆ€ i, AEMeasurable (f i) Î¼) : AEMeasurable (fun x => âˆ‘' i, f i x) Î¼ := by
  simp_rw [ENNReal.tsum_eq_iSup_sum]
  -- âŠ¢ AEMeasurable fun x => â¨† (s : Finset Î¹), âˆ‘ i in s, f i x
  apply aemeasurable_iSup
  -- âŠ¢ âˆ€ (i : Finset Î¹), AEMeasurable fun b => âˆ‘ i in i, f i b
  exact fun s => Finset.aemeasurable_sum s fun i _ => h i
  -- ğŸ‰ no goals
#align ae_measurable.ennreal_tsum AEMeasurable.ennreal_tsum

@[measurability]
theorem AEMeasurable.nnreal_tsum {Î± : Type*} [MeasurableSpace Î±] {Î¹ : Type*} [Countable Î¹]
    {f : Î¹ â†’ Î± â†’ NNReal} {Î¼ : MeasureTheory.Measure Î±} (h : âˆ€ i : Î¹, AEMeasurable (f i) Î¼) :
    AEMeasurable (fun x : Î± => âˆ‘' i : Î¹, f i x) Î¼ := by
  simp_rw [NNReal.tsum_eq_toNNReal_tsum]
  -- âŠ¢ AEMeasurable fun x => ENNReal.toNNReal (âˆ‘' (b : Î¹), â†‘(f b x))
  exact (AEMeasurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_toNNReal
  -- ğŸ‰ no goals
#align ae_measurable.nnreal_tsum AEMeasurable.nnreal_tsum

@[measurability]
theorem measurable_coe_real_ereal : Measurable ((â†‘) : â„ â†’ EReal) :=
  continuous_coe_real_ereal.measurable
#align measurable_coe_real_ereal measurable_coe_real_ereal

@[measurability]
theorem Measurable.coe_real_ereal {f : Î± â†’ â„} (hf : Measurable f) :
    Measurable fun x => (f x : EReal) :=
  measurable_coe_real_ereal.comp hf
#align measurable.coe_real_ereal Measurable.coe_real_ereal

@[measurability]
theorem AEMeasurable.coe_real_ereal {f : Î± â†’ â„} {Î¼ : Measure Î±} (hf : AEMeasurable f Î¼) :
    AEMeasurable (fun x => (f x : EReal)) Î¼ :=
  measurable_coe_real_ereal.comp_aemeasurable hf
#align ae_measurable.coe_real_ereal AEMeasurable.coe_real_ereal

/-- The set of finite `EReal` numbers is `MeasurableEquiv` to `â„`. -/
def MeasurableEquiv.erealEquivReal : ({âŠ¥, âŠ¤}á¶œ : Set EReal) â‰ƒáµ â„ :=
  EReal.neBotTopHomeomorphReal.toMeasurableEquiv
#align measurable_equiv.ereal_equiv_real MeasurableEquiv.erealEquivReal

theorem EReal.measurable_of_measurable_real {f : EReal â†’ Î±} (h : Measurable fun p : â„ => f p) :
    Measurable f :=
  measurable_of_measurable_on_compl_finite {âŠ¥, âŠ¤} (by simp)
                                                      -- ğŸ‰ no goals
    (MeasurableEquiv.erealEquivReal.symm.measurable_comp_iff.1 h)
#align ereal.measurable_of_measurable_real EReal.measurable_of_measurable_real

@[measurability]
theorem measurable_ereal_toReal : Measurable EReal.toReal :=
  EReal.measurable_of_measurable_real (by simpa using measurable_id)
                                          -- ğŸ‰ no goals
#align measurable_ereal_to_real measurable_ereal_toReal

@[measurability]
theorem Measurable.ereal_toReal {f : Î± â†’ EReal} (hf : Measurable f) :
    Measurable fun x => (f x).toReal :=
  measurable_ereal_toReal.comp hf
#align measurable.ereal_to_real Measurable.ereal_toReal

@[measurability]
theorem AEMeasurable.ereal_toReal {f : Î± â†’ EReal} {Î¼ : Measure Î±} (hf : AEMeasurable f Î¼) :
    AEMeasurable (fun x => (f x).toReal) Î¼ :=
  measurable_ereal_toReal.comp_aemeasurable hf
#align ae_measurable.ereal_to_real AEMeasurable.ereal_toReal

@[measurability]
theorem measurable_coe_ennreal_ereal : Measurable ((â†‘) : â„â‰¥0âˆ â†’ EReal) :=
  continuous_coe_ennreal_ereal.measurable
#align measurable_coe_ennreal_ereal measurable_coe_ennreal_ereal

@[measurability]
theorem Measurable.coe_ereal_ennreal {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) :
    Measurable fun x => (f x : EReal) :=
  measurable_coe_ennreal_ereal.comp hf
#align measurable.coe_ereal_ennreal Measurable.coe_ereal_ennreal

@[measurability]
theorem AEMeasurable.coe_ereal_ennreal {f : Î± â†’ â„â‰¥0âˆ} {Î¼ : Measure Î±} (hf : AEMeasurable f Î¼) :
    AEMeasurable (fun x => (f x : EReal)) Î¼ :=
  measurable_coe_ennreal_ereal.comp_aemeasurable hf
#align ae_measurable.coe_ereal_ennreal AEMeasurable.coe_ereal_ennreal

section NormedAddCommGroup

variable [NormedAddCommGroup Î±] [OpensMeasurableSpace Î±] [MeasurableSpace Î²]

@[measurability]
theorem measurable_norm : Measurable (norm : Î± â†’ â„) :=
  continuous_norm.measurable
#align measurable_norm measurable_norm

@[measurability]
theorem Measurable.norm {f : Î² â†’ Î±} (hf : Measurable f) : Measurable fun a => norm (f a) :=
  measurable_norm.comp hf
#align measurable.norm Measurable.norm

@[measurability]
theorem AEMeasurable.norm {f : Î² â†’ Î±} {Î¼ : Measure Î²} (hf : AEMeasurable f Î¼) :
    AEMeasurable (fun a => norm (f a)) Î¼ :=
  measurable_norm.comp_aemeasurable hf
#align ae_measurable.norm AEMeasurable.norm

@[measurability]
theorem measurable_nnnorm : Measurable (nnnorm : Î± â†’ â„â‰¥0) :=
  continuous_nnnorm.measurable
#align measurable_nnnorm measurable_nnnorm

@[measurability]
theorem Measurable.nnnorm {f : Î² â†’ Î±} (hf : Measurable f) : Measurable fun a => â€–f aâ€–â‚Š :=
  measurable_nnnorm.comp hf
#align measurable.nnnorm Measurable.nnnorm

@[measurability]
theorem AEMeasurable.nnnorm {f : Î² â†’ Î±} {Î¼ : Measure Î²} (hf : AEMeasurable f Î¼) :
    AEMeasurable (fun a => â€–f aâ€–â‚Š) Î¼ :=
  measurable_nnnorm.comp_aemeasurable hf
#align ae_measurable.nnnorm AEMeasurable.nnnorm

@[measurability]
theorem measurable_ennnorm : Measurable fun x : Î± => (â€–xâ€–â‚Š : â„â‰¥0âˆ) :=
  measurable_nnnorm.coe_nnreal_ennreal
#align measurable_ennnorm measurable_ennnorm

@[measurability]
theorem Measurable.ennnorm {f : Î² â†’ Î±} (hf : Measurable f) : Measurable fun a => (â€–f aâ€–â‚Š : â„â‰¥0âˆ) :=
  hf.nnnorm.coe_nnreal_ennreal
#align measurable.ennnorm Measurable.ennnorm

@[measurability]
theorem AEMeasurable.ennnorm {f : Î² â†’ Î±} {Î¼ : Measure Î²} (hf : AEMeasurable f Î¼) :
    AEMeasurable (fun a => (â€–f aâ€–â‚Š : â„â‰¥0âˆ)) Î¼ :=
  measurable_ennnorm.comp_aemeasurable hf
#align ae_measurable.ennnorm AEMeasurable.ennnorm

end NormedAddCommGroup
