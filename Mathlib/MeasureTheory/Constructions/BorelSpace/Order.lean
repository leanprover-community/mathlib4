/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Yury Kudryashov, Kexing Ying
-/
import Mathlib.Topology.Semicontinuous
import Mathlib.MeasureTheory.Function.AEMeasurableSequence
import Mathlib.MeasureTheory.Order.Lattice
import Mathlib.Topology.Order.Lattice
import Mathlib.MeasureTheory.Constructions.BorelSpace.Basic

/-!
# Borel sigma algebras on spaces with orders

## Main statements

* `borel_eq_generateFrom_Ixx` (where Ixx is one of {Iio, Ioi, Iic, Ici, Ico, Ioc}):
  The Borel sigma algebra of a linear order topology is generated by intervals of the given kind.
* `Dense.borel_eq_generateFrom_Ico_mem`, `Dense.borel_eq_generateFrom_Ioc_mem`:
  The Borel sigma algebra of a dense linear order topology is generated by intervals of a given
  kind, with endpoints from dense subsets.
* `ext_of_Ico`, `ext_of_Ioc`:
  A locally finite Borel measure on a second countable conditionally complete linear order is
  characterized by the measures of intervals of the given kind.
* `ext_of_Iic`, `ext_of_Ici`:
  A finite Borel measure on a second countable linear order is characterized by the measures of
  intervals of the given kind.
* `UpperSemicontinuous.measurable`, `LowerSemicontinuous.measurable`:
  Semicontinuous functions are measurable.
* `Measurable.iSup`, `Measurable.iInf`, `Measurable.sSup`, `Measurable.sInf`:
  Countable supremums and infimums of measurable functions to conditionally complete linear orders
  are measurable.
* `Measurable.liminf`, `Measurable.limsup`:
  Countable liminfs and limsups of measurable functions to conditionally complete linear orders
  are measurable.

-/

open Set Filter MeasureTheory MeasurableSpace TopologicalSpace

open scoped Topology NNReal ENNReal MeasureTheory

universe u v w x y

variable {Œ± Œ≤ Œ≥ Œ¥ : Type*} {Œπ : Sort y} {s t u : Set Œ±}

section OrderTopology

variable (Œ±)
variable [TopologicalSpace Œ±] [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±]

theorem borel_eq_generateFrom_Iio : borel Œ± = .generateFrom (range Iio) := by
  refine le_antisymm ?_ (generateFrom_le ?_)
  ¬∑ rw [borel_eq_generateFrom_of_subbasis (@OrderTopology.topology_eq_generate_intervals Œ± _ _ _)]
    letI : MeasurableSpace Œ± := MeasurableSpace.generateFrom (range Iio)
    have H : ‚àÄ a : Œ±, MeasurableSet (Iio a) := fun a => GenerateMeasurable.basic _ ‚ü®_, rfl‚ü©
    refine generateFrom_le ?_
    rintro _ ‚ü®a, rfl | rfl‚ü©
    ¬∑ rcases em (‚àÉ b, a ‚ãñ b) with ‚ü®b, hb‚ü© | hcovBy
      ¬∑ rw [hb.Ioi_eq, ‚Üê compl_Iio]
        exact (H _).compl
      ¬∑ rcases isOpen_biUnion_countable (Ioi a) Ioi fun _ _ ‚Ü¶ isOpen_Ioi with ‚ü®t, hat, htc, htU‚ü©
        have : Ioi a = ‚ãÉ b ‚àà t, Ici b := by
          refine Subset.antisymm ?_ <| iUnion‚ÇÇ_subset fun b hb ‚Ü¶ Ici_subset_Ioi.2 (hat hb)
          refine Subset.trans ?_ <| iUnion‚ÇÇ_mono fun _ _ ‚Ü¶ Ioi_subset_Ici_self
          simpa [CovBy, htU, subset_def] using hcovBy
        simp only [this, ‚Üê compl_Iio]
        exact .biUnion htc <| fun _ _ ‚Ü¶ (H _).compl
    ¬∑ apply H
  ¬∑ rw [forall_mem_range]
    intro a
    exact GenerateMeasurable.basic _ isOpen_Iio

theorem borel_eq_generateFrom_Ioi : borel Œ± = .generateFrom (range Ioi) :=
  @borel_eq_generateFrom_Iio Œ±·µí·µà _ (by infer_instance : SecondCountableTopology Œ±) _ _

theorem borel_eq_generateFrom_Iic :
    borel Œ± = MeasurableSpace.generateFrom (range Iic) := by
  rw [borel_eq_generateFrom_Ioi]
  refine le_antisymm ?_ ?_
  ¬∑ refine MeasurableSpace.generateFrom_le fun t ht => ?_
    obtain ‚ü®u, rfl‚ü© := ht
    rw [‚Üê compl_Iic]
    exact (MeasurableSpace.measurableSet_generateFrom (mem_range.mpr ‚ü®u, rfl‚ü©)).compl
  ¬∑ refine MeasurableSpace.generateFrom_le fun t ht => ?_
    obtain ‚ü®u, rfl‚ü© := ht
    rw [‚Üê compl_Ioi]
    exact (MeasurableSpace.measurableSet_generateFrom (mem_range.mpr ‚ü®u, rfl‚ü©)).compl

theorem borel_eq_generateFrom_Ici : borel Œ± = MeasurableSpace.generateFrom (range Ici) :=
  @borel_eq_generateFrom_Iic Œ±·µí·µà _ _ _ _

end OrderTopology

section Orders

variable [TopologicalSpace Œ±] {mŒ± : MeasurableSpace Œ±} [OpensMeasurableSpace Œ±]
variable {mŒ¥ : MeasurableSpace Œ¥}

section Preorder

variable [Preorder Œ±] [OrderClosedTopology Œ±] {a b x : Œ±} {Œº : Measure Œ±}

@[simp, measurability]
theorem measurableSet_Ici : MeasurableSet (Ici a) :=
  isClosed_Ici.measurableSet

theorem nullMeasurableSet_Ici : NullMeasurableSet (Ici a) Œº :=
  measurableSet_Ici.nullMeasurableSet

@[simp, measurability]
theorem measurableSet_Iic : MeasurableSet (Iic a) :=
  isClosed_Iic.measurableSet

theorem nullMeasurableSet_Iic : NullMeasurableSet (Iic a) Œº :=
  measurableSet_Iic.nullMeasurableSet

@[simp, measurability]
theorem measurableSet_Icc : MeasurableSet (Icc a b) :=
  isClosed_Icc.measurableSet

theorem nullMeasurableSet_Icc : NullMeasurableSet (Icc a b) Œº :=
  measurableSet_Icc.nullMeasurableSet

instance nhdsWithin_Ici_isMeasurablyGenerated : (ùìù[Ici b] a).IsMeasurablyGenerated :=
  measurableSet_Ici.nhdsWithin_isMeasurablyGenerated _

instance nhdsWithin_Iic_isMeasurablyGenerated : (ùìù[Iic b] a).IsMeasurablyGenerated :=
  measurableSet_Iic.nhdsWithin_isMeasurablyGenerated _

instance nhdsWithin_Icc_isMeasurablyGenerated : IsMeasurablyGenerated (ùìù[Icc a b] x) := by
  rw [‚Üê Ici_inter_Iic, nhdsWithin_inter]
  infer_instance

instance atTop_isMeasurablyGenerated : (Filter.atTop : Filter Œ±).IsMeasurablyGenerated :=
  @Filter.iInf_isMeasurablyGenerated _ _ _ _ fun a =>
    (measurableSet_Ici : MeasurableSet (Ici a)).principal_isMeasurablyGenerated

instance atBot_isMeasurablyGenerated : (Filter.atBot : Filter Œ±).IsMeasurablyGenerated :=
  @Filter.iInf_isMeasurablyGenerated _ _ _ _ fun a =>
    (measurableSet_Iic : MeasurableSet (Iic a)).principal_isMeasurablyGenerated

instance [R1Space Œ±] : IsMeasurablyGenerated (cocompact Œ±) where
  exists_measurable_subset := by
    intro _ hs
    obtain ‚ü®t, ht, hts‚ü© := mem_cocompact.mp hs
    exact ‚ü®(closure t)·∂ú, ht.closure.compl_mem_cocompact, isClosed_closure.measurableSet.compl,
      (compl_subset_compl.2 subset_closure).trans hts‚ü©

end Preorder

section PartialOrder

variable [PartialOrder Œ±] [OrderClosedTopology Œ±] [SecondCountableTopology Œ±] {a b : Œ±}

@[measurability]
theorem measurableSet_le' : MeasurableSet { p : Œ± √ó Œ± | p.1 ‚â§ p.2 } :=
  OrderClosedTopology.isClosed_le'.measurableSet

@[measurability]
theorem measurableSet_le {f g : Œ¥ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    MeasurableSet { a | f a ‚â§ g a } :=
  hf.prodMk hg measurableSet_le'

end PartialOrder

section LinearOrder

variable [LinearOrder Œ±] [OrderClosedTopology Œ±] {a b x : Œ±} {Œº : Measure Œ±}

-- we open this scope only here to avoid issues with list being treated as intervals above
open Interval

@[simp, measurability]
theorem measurableSet_Iio : MeasurableSet (Iio a) :=
  isOpen_Iio.measurableSet

theorem nullMeasurableSet_Iio : NullMeasurableSet (Iio a) Œº :=
  measurableSet_Iio.nullMeasurableSet

@[simp, measurability]
theorem measurableSet_Ioi : MeasurableSet (Ioi a) :=
  isOpen_Ioi.measurableSet

theorem nullMeasurableSet_Ioi : NullMeasurableSet (Ioi a) Œº :=
  measurableSet_Ioi.nullMeasurableSet

@[simp, measurability]
theorem measurableSet_Ioo : MeasurableSet (Ioo a b) :=
  isOpen_Ioo.measurableSet

theorem nullMeasurableSet_Ioo : NullMeasurableSet (Ioo a b) Œº :=
  measurableSet_Ioo.nullMeasurableSet

@[simp, measurability]
theorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=
  measurableSet_Ioi.inter measurableSet_Iic

theorem nullMeasurableSet_Ioc : NullMeasurableSet (Ioc a b) Œº :=
  measurableSet_Ioc.nullMeasurableSet

@[simp, measurability]
theorem measurableSet_Ico : MeasurableSet (Ico a b) :=
  measurableSet_Ici.inter measurableSet_Iio

theorem nullMeasurableSet_Ico : NullMeasurableSet (Ico a b) Œº :=
  measurableSet_Ico.nullMeasurableSet

instance nhdsWithin_Ioi_isMeasurablyGenerated : (ùìù[Ioi b] a).IsMeasurablyGenerated :=
  measurableSet_Ioi.nhdsWithin_isMeasurablyGenerated _

instance nhdsWithin_Iio_isMeasurablyGenerated : (ùìù[Iio b] a).IsMeasurablyGenerated :=
  measurableSet_Iio.nhdsWithin_isMeasurablyGenerated _

instance nhdsWithin_uIcc_isMeasurablyGenerated : IsMeasurablyGenerated (ùìù[[[a, b]]] x) :=
  nhdsWithin_Icc_isMeasurablyGenerated

@[measurability]
theorem measurableSet_lt' [SecondCountableTopology Œ±] : MeasurableSet { p : Œ± √ó Œ± | p.1 < p.2 } :=
  (isOpen_lt continuous_fst continuous_snd).measurableSet

@[measurability]
theorem measurableSet_lt [SecondCountableTopology Œ±] {f g : Œ¥ ‚Üí Œ±} (hf : Measurable f)
    (hg : Measurable g) : MeasurableSet { a | f a < g a } :=
  hf.prodMk hg measurableSet_lt'

theorem nullMeasurableSet_lt [SecondCountableTopology Œ±] {Œº : Measure Œ¥} {f g : Œ¥ ‚Üí Œ±}
    (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) : NullMeasurableSet { a | f a < g a } Œº :=
  (hf.prodMk hg).nullMeasurable measurableSet_lt'

theorem nullMeasurableSet_lt' [SecondCountableTopology Œ±] {Œº : Measure (Œ± √ó Œ±)} :
    NullMeasurableSet { p : Œ± √ó Œ± | p.1 < p.2 } Œº :=
  measurableSet_lt'.nullMeasurableSet

theorem nullMeasurableSet_le [SecondCountableTopology Œ±] {Œº : Measure Œ¥}
    {f g : Œ¥ ‚Üí Œ±} (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    NullMeasurableSet { a | f a ‚â§ g a } Œº :=
  (hf.prodMk hg).nullMeasurable measurableSet_le'

theorem Set.OrdConnected.measurableSet (h : OrdConnected s) : MeasurableSet s := by
  let u := ‚ãÉ (x ‚àà s) (y ‚àà s), Ioo x y
  have huopen : IsOpen u := isOpen_biUnion fun _ _ => isOpen_biUnion fun _ _ => isOpen_Ioo
  have humeas : MeasurableSet u := huopen.measurableSet
  have hfinite : (s \ u).Finite := s.finite_diff_iUnion_Ioo
  have : u ‚äÜ s := iUnion‚ÇÇ_subset fun x hx => iUnion‚ÇÇ_subset fun y hy =>
    Ioo_subset_Icc_self.trans (h.out hx hy)
  rw [‚Üê union_diff_cancel this]
  exact humeas.union hfinite.measurableSet

theorem IsPreconnected.measurableSet (h : IsPreconnected s) : MeasurableSet s :=
  h.ordConnected.measurableSet

theorem generateFrom_Ico_mem_le_borel {Œ± : Type*} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderClosedTopology Œ±] (s t : Set Œ±) :
    MeasurableSpace.generateFrom { S | ‚àÉ l ‚àà s, ‚àÉ u ‚àà t, l < u ‚àß Ico l u = S }
      ‚â§ borel Œ± := by
  apply generateFrom_le
  borelize Œ±
  rintro _ ‚ü®a, -, b, -, -, rfl‚ü©
  exact measurableSet_Ico

theorem Dense.borel_eq_generateFrom_Ico_mem_aux {Œ± : Type*} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderTopology Œ±] [SecondCountableTopology Œ±] {s : Set Œ±} (hd : Dense s)
    (hbot : ‚àÄ x, IsBot x ‚Üí x ‚àà s) (hIoo : ‚àÄ x y : Œ±, x < y ‚Üí Ioo x y = ‚àÖ ‚Üí y ‚àà s) :
    borel Œ± = .generateFrom { S : Set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, l < u ‚àß Ico l u = S } := by
  set S : Set (Set Œ±) := { S | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, l < u ‚àß Ico l u = S }
  refine le_antisymm ?_ (generateFrom_Ico_mem_le_borel _ _)
  letI : MeasurableSpace Œ± := generateFrom S
  rw [borel_eq_generateFrom_Iio]
  refine generateFrom_le (forall_mem_range.2 fun a => ?_)
  rcases hd.exists_countable_dense_subset_bot_top with ‚ü®t, hts, hc, htd, htb, -‚ü©
  by_cases ha : ‚àÄ b < a, (Ioo b a).Nonempty
  ¬∑ convert_to MeasurableSet (‚ãÉ (l ‚àà t) (u ‚àà t) (_ : l < u) (_ : u ‚â§ a), Ico l u)
    ¬∑ ext y
      simp only [mem_iUnion, mem_Iio, mem_Ico]
      constructor
      ¬∑ intro hy
        rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) y with ‚ü®l, hlt, hly‚ü©
        rcases htd.exists_mem_open isOpen_Ioo (ha y hy) with ‚ü®u, hut, hyu, hua‚ü©
        exact ‚ü®l, hlt, u, hut, hly.trans_lt hyu, hua.le, hly, hyu‚ü©
      ¬∑ rintro ‚ü®l, -, u, -, -, hua, -, hyu‚ü©
        exact hyu.trans_le hua
    ¬∑ refine MeasurableSet.biUnion hc fun a ha => MeasurableSet.biUnion hc fun b hb => ?_
      refine MeasurableSet.iUnion fun hab => MeasurableSet.iUnion fun _ => ?_
      exact .basic _ ‚ü®a, hts ha, b, hts hb, hab, mem_singleton _‚ü©
  ¬∑ simp only [not_forall, not_nonempty_iff_eq_empty] at ha
    replace ha : a ‚àà s := hIoo ha.choose a ha.choose_spec.fst ha.choose_spec.snd
    convert_to MeasurableSet (‚ãÉ (l ‚àà t) (_ : l < a), Ico l a)
    ¬∑ symm
      simp only [‚Üê Ici_inter_Iio, ‚Üê iUnion_inter, inter_eq_right, subset_def, mem_iUnion,
        mem_Ici, mem_Iio]
      intro x hx
      rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) x with ‚ü®z, hzt, hzx‚ü©
      exact ‚ü®z, hzt, hzx.trans_lt hx, hzx‚ü©
    ¬∑ refine .biUnion hc fun x hx => MeasurableSet.iUnion fun hlt => ?_
      exact .basic _ ‚ü®x, hts hx, a, ha, hlt, mem_singleton _‚ü©

theorem Dense.borel_eq_generateFrom_Ico_mem {Œ± : Type*} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderTopology Œ±] [SecondCountableTopology Œ±] [DenselyOrdered Œ±] [NoMinOrder Œ±] {s : Set Œ±}
    (hd : Dense s) :
    borel Œ± = .generateFrom { S : Set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, l < u ‚àß Ico l u = S } :=
  hd.borel_eq_generateFrom_Ico_mem_aux (by simp) fun _ _ hxy H =>
    ((nonempty_Ioo.2 hxy).ne_empty H).elim

theorem borel_eq_generateFrom_Ico (Œ± : Type*) [TopologicalSpace Œ±] [SecondCountableTopology Œ±]
    [LinearOrder Œ±] [OrderTopology Œ±] :
    borel Œ± = .generateFrom { S : Set Œ± | ‚àÉ (l u : Œ±), l < u ‚àß Ico l u = S } := by
  simpa only [exists_prop, mem_univ, true_and] using
    (@dense_univ Œ± _).borel_eq_generateFrom_Ico_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ =>
      mem_univ _

theorem Dense.borel_eq_generateFrom_Ioc_mem_aux {Œ± : Type*} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderTopology Œ±] [SecondCountableTopology Œ±] {s : Set Œ±} (hd : Dense s)
    (hbot : ‚àÄ x, IsTop x ‚Üí x ‚àà s) (hIoo : ‚àÄ x y : Œ±, x < y ‚Üí Ioo x y = ‚àÖ ‚Üí x ‚àà s) :
    borel Œ± = .generateFrom { S : Set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, l < u ‚àß Ioc l u = S } := by
  convert hd.orderDual.borel_eq_generateFrom_Ico_mem_aux hbot fun x y hlt he => hIoo y x hlt _
    using 2
  ¬∑ ext s
    constructor <;> rintro ‚ü®l, hl, u, hu, hlt, rfl‚ü©
    exacts [‚ü®u, hu, l, hl, hlt, Ico_toDual‚ü©, ‚ü®u, hu, l, hl, hlt, Ioc_toDual‚ü©]
  ¬∑ erw [Ioo_toDual]
    exact he

theorem Dense.borel_eq_generateFrom_Ioc_mem {Œ± : Type*} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderTopology Œ±] [SecondCountableTopology Œ±] [DenselyOrdered Œ±] [NoMaxOrder Œ±] {s : Set Œ±}
    (hd : Dense s) :
    borel Œ± = .generateFrom { S : Set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, l < u ‚àß Ioc l u = S } :=
  hd.borel_eq_generateFrom_Ioc_mem_aux (by simp) fun _ _ hxy H =>
    ((nonempty_Ioo.2 hxy).ne_empty H).elim

theorem borel_eq_generateFrom_Ioc (Œ± : Type*) [TopologicalSpace Œ±] [SecondCountableTopology Œ±]
    [LinearOrder Œ±] [OrderTopology Œ±] :
    borel Œ± = .generateFrom { S : Set Œ± | ‚àÉ l u, l < u ‚àß Ioc l u = S } := by
  simpa only [exists_prop, mem_univ, true_and] using
    (@dense_univ Œ± _).borel_eq_generateFrom_Ioc_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ =>
      mem_univ _

namespace MeasureTheory.Measure

/-- Two finite measures on a Borel space are equal if they agree on all closed-open intervals.  If
`Œ±` is a conditionally complete linear order with no top element,
`MeasureTheory.Measure.ext_of_Ico` is an extensionality lemma with weaker assumptions on `Œº` and
`ŒΩ`. -/
theorem ext_of_Ico_finite {Œ± : Type*} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] (Œº ŒΩ : Measure Œ±)
    [IsFiniteMeasure Œº] (hŒºŒΩ : Œº univ = ŒΩ univ) (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) = ŒΩ (Ico a b)) :
    Œº = ŒΩ := by
  refine
    ext_of_generate_finite _ (BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ico Œ±))
      (isPiSystem_Ico (id : Œ± ‚Üí Œ±) id) ?_ hŒºŒΩ
  rintro - ‚ü®a, b, hlt, rfl‚ü©
  exact h hlt

/-- Two finite measures on a Borel space are equal if they agree on all open-closed intervals.  If
`Œ±` is a conditionally complete linear order with no top element,
`MeasureTheory.Measure.ext_of_Ioc` is an extensionality lemma with weaker assumptions on `Œº` and
`ŒΩ`. -/
theorem ext_of_Ioc_finite {Œ± : Type*} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] (Œº ŒΩ : Measure Œ±)
    [IsFiniteMeasure Œº] (hŒºŒΩ : Œº univ = ŒΩ univ) (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) = ŒΩ (Ioc a b)) :
    Œº = ŒΩ := by
  refine @ext_of_Ico_finite Œ±·µí·µà _ _ _ _ _ ‚Äπ_‚Ä∫ Œº ŒΩ _ hŒºŒΩ fun a b hab => ?_
  erw [Ico_toDual (Œ± := Œ±)]
  exact h hab

/-- Two measures which are finite on closed-open intervals are equal if they agree on all
closed-open intervals. -/
theorem ext_of_Ico' {Œ± : Type*} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] [NoMaxOrder Œ±]
    (Œº ŒΩ : Measure Œ±) (hŒº : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) ‚â† ‚àû)
    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) = ŒΩ (Ico a b)) : Œº = ŒΩ := by
  rcases exists_countable_dense_bot_top Œ± with ‚ü®s, hsc, hsd, hsb, _‚ü©
  have : (‚ãÉ (l ‚àà s) (u ‚àà s) (_ : l < u), {Ico l u} : Set (Set Œ±)).Countable :=
    hsc.biUnion fun l _ => hsc.biUnion fun u _ => countable_iUnion fun _ => countable_singleton _
  simp only [‚Üê setOf_eq_eq_singleton, ‚Üê setOf_exists] at this
  refine
    Measure.ext_of_generateFrom_of_cover_subset
      (BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ico Œ±)) (isPiSystem_Ico id id) ?_ this
      ?_ ?_ ?_
  ¬∑ rintro _ ‚ü®l, -, u, -, h, rfl‚ü©
    exact ‚ü®l, u, h, rfl‚ü©
  ¬∑ refine sUnion_eq_univ_iff.2 fun x => ?_
    rcases hsd.exists_le' hsb x with ‚ü®l, hls, hlx‚ü©
    rcases hsd.exists_gt x with ‚ü®u, hus, hxu‚ü©
    exact ‚ü®_, ‚ü®l, hls, u, hus, hlx.trans_lt hxu, rfl‚ü©, hlx, hxu‚ü©
  ¬∑ rintro _ ‚ü®l, -, u, -, hlt, rfl‚ü©
    exact hŒº hlt
  ¬∑ rintro _ ‚ü®l, u, hlt, rfl‚ü©
    exact h hlt

/-- Two measures which are finite on closed-open intervals are equal if they agree on all
open-closed intervals. -/
theorem ext_of_Ioc' {Œ± : Type*} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] [NoMinOrder Œ±]
    (Œº ŒΩ : Measure Œ±) (hŒº : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) ‚â† ‚àû)
    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) = ŒΩ (Ioc a b)) : Œº = ŒΩ := by
  refine @ext_of_Ico' Œ±·µí·µà _ _ _ _ _ ‚Äπ_‚Ä∫ _ Œº ŒΩ ?_ ?_ <;> intro a b hab <;> erw [Ico_toDual (Œ± := Œ±)]
  exacts [hŒº hab, h hab]

/-- Two measures which are finite on closed-open intervals are equal if they agree on all
closed-open intervals. -/
theorem ext_of_Ico {Œ± : Type*} [TopologicalSpace Œ±] {_m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [ConditionallyCompleteLinearOrder Œ±] [OrderTopology Œ±]
    [BorelSpace Œ±] [NoMaxOrder Œ±] (Œº ŒΩ : Measure Œ±) [IsLocallyFiniteMeasure Œº]
    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) = ŒΩ (Ico a b)) : Œº = ŒΩ :=
  Œº.ext_of_Ico' ŒΩ (fun _ _ _ => measure_Ico_lt_top.ne) h

/-- Two measures which are finite on closed-open intervals are equal if they agree on all
open-closed intervals. -/
theorem ext_of_Ioc {Œ± : Type*} [TopologicalSpace Œ±] {_m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [ConditionallyCompleteLinearOrder Œ±] [OrderTopology Œ±]
    [BorelSpace Œ±] [NoMinOrder Œ±] (Œº ŒΩ : Measure Œ±) [IsLocallyFiniteMeasure Œº]
    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) = ŒΩ (Ioc a b)) : Œº = ŒΩ :=
  Œº.ext_of_Ioc' ŒΩ (fun _ _ _ => measure_Ioc_lt_top.ne) h

/-- Two finite measures on a Borel space are equal if they agree on all left-infinite right-closed
intervals. -/
theorem ext_of_Iic {Œ± : Type*} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] (Œº ŒΩ : Measure Œ±)
    [IsFiniteMeasure Œº] (h : ‚àÄ a, Œº (Iic a) = ŒΩ (Iic a)) : Œº = ŒΩ := by
  refine ext_of_Ioc_finite Œº ŒΩ ?_ fun a b hlt => ?_
  ¬∑ rcases exists_countable_dense_bot_top Œ± with ‚ü®s, hsc, hsd, -, hst‚ü©
    have : DirectedOn (¬∑ ‚â§ ¬∑) s := directedOn_iff_directed.2 (Subtype.mono_coe _).directed_le
    simp only [‚Üê biSup_measure_Iic hsc (hsd.exists_ge' hst) this, h]
  rw [‚Üê Iic_diff_Iic, measure_diff (Iic_subset_Iic.2 hlt.le) nullMeasurableSet_Iic,
    measure_diff (Iic_subset_Iic.2 hlt.le) nullMeasurableSet_Iic, h a, h b]
  ¬∑ rw [‚Üê h a]
    finiteness
  ¬∑ finiteness

/-- Two finite measures on a Borel space are equal if they agree on all left-closed right-infinite
intervals. -/
theorem ext_of_Ici {Œ± : Type*} [TopologicalSpace Œ±] {_ : MeasurableSpace Œ±}
    [SecondCountableTopology Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] (Œº ŒΩ : Measure Œ±)
    [IsFiniteMeasure Œº] (h : ‚àÄ a, Œº (Ici a) = ŒΩ (Ici a)) : Œº = ŒΩ :=
  @ext_of_Iic Œ±·µí·µà _ _ _ _ _ ‚Äπ_‚Ä∫ _ _ _ h

end MeasureTheory.Measure

@[measurability]
theorem measurableSet_uIcc : MeasurableSet (uIcc a b) :=
  measurableSet_Icc

@[measurability]
theorem measurableSet_uIoc : MeasurableSet (uIoc a b) :=
  measurableSet_Ioc

variable [SecondCountableTopology Œ±]

@[measurability, fun_prop]
theorem Measurable.max {f g : Œ¥ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun a => max (f a) (g a) := by
  simpa only [max_def'] using hf.piecewise (measurableSet_le hg hf) hg

@[measurability, fun_prop]
nonrec theorem AEMeasurable.max {f g : Œ¥ ‚Üí Œ±} {Œº : Measure Œ¥} (hf : AEMeasurable f Œº)
    (hg : AEMeasurable g Œº) : AEMeasurable (fun a => max (f a) (g a)) Œº :=
  ‚ü®fun a => max (hf.mk f a) (hg.mk g a), hf.measurable_mk.max hg.measurable_mk,
    EventuallyEq.comp‚ÇÇ hf.ae_eq_mk _ hg.ae_eq_mk‚ü©

@[measurability, fun_prop]
theorem Measurable.min {f g : Œ¥ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun a => min (f a) (g a) := by
  simpa only [min_def] using hf.piecewise (measurableSet_le hf hg) hg

@[measurability, fun_prop]
nonrec theorem AEMeasurable.min {f g : Œ¥ ‚Üí Œ±} {Œº : Measure Œ¥} (hf : AEMeasurable f Œº)
    (hg : AEMeasurable g Œº) : AEMeasurable (fun a => min (f a) (g a)) Œº :=
  ‚ü®fun a => min (hf.mk f a) (hg.mk g a), hf.measurable_mk.min hg.measurable_mk,
    EventuallyEq.comp‚ÇÇ hf.ae_eq_mk _ hg.ae_eq_mk‚ü©

end LinearOrder

section Lattice

variable [TopologicalSpace Œ≥] {mŒ≥ : MeasurableSpace Œ≥} [BorelSpace Œ≥]

instance (priority := 100) ContinuousSup.measurableSup [Max Œ≥] [ContinuousSup Œ≥] :
    MeasurableSup Œ≥ where
  measurable_const_sup _ := (continuous_const.sup continuous_id).measurable
  measurable_sup_const _ := (continuous_id.sup continuous_const).measurable

instance (priority := 100) ContinuousSup.measurableSup‚ÇÇ [SecondCountableTopology Œ≥] [Max Œ≥]
    [ContinuousSup Œ≥] : MeasurableSup‚ÇÇ Œ≥ :=
  ‚ü®continuous_sup.measurable‚ü©

instance (priority := 100) ContinuousInf.measurableInf [Min Œ≥] [ContinuousInf Œ≥] :
    MeasurableInf Œ≥ where
  measurable_const_inf _ := (continuous_const.inf continuous_id).measurable
  measurable_inf_const _ := (continuous_id.inf continuous_const).measurable

instance (priority := 100) ContinuousInf.measurableInf‚ÇÇ [SecondCountableTopology Œ≥] [Min Œ≥]
    [ContinuousInf Œ≥] : MeasurableInf‚ÇÇ Œ≥ :=
  ‚ü®continuous_inf.measurable‚ü©

end Lattice

end Orders

section BorelSpace

variable [TopologicalSpace Œ±] {mŒ± : MeasurableSpace Œ±} [BorelSpace Œ±]
variable [TopologicalSpace Œ≤] {mŒ≤ : MeasurableSpace Œ≤} [BorelSpace Œ≤]
variable {mŒ¥ : MeasurableSpace Œ¥}

section LinearOrder

variable [LinearOrder Œ±] [OrderTopology Œ±] [SecondCountableTopology Œ±]

theorem measurable_of_Iio {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, MeasurableSet (f ‚Åª¬π' Iio x)) : Measurable f := by
  convert measurable_generateFrom (Œ± := Œ¥) _
  ¬∑ exact BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Iio _)
  ¬∑ rintro _ ‚ü®x, rfl‚ü©; exact hf x

theorem UpperSemicontinuous.measurable [TopologicalSpace Œ¥] [OpensMeasurableSpace Œ¥] {f : Œ¥ ‚Üí Œ±}
    (hf : UpperSemicontinuous f) : Measurable f :=
  measurable_of_Iio fun y => (hf.isOpen_preimage y).measurableSet

theorem measurable_of_Ioi {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, MeasurableSet (f ‚Åª¬π' Ioi x)) : Measurable f := by
  convert measurable_generateFrom (Œ± := Œ¥) _
  ¬∑ exact BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ioi _)
  ¬∑ rintro _ ‚ü®x, rfl‚ü©; exact hf x

theorem LowerSemicontinuous.measurable [TopologicalSpace Œ¥] [OpensMeasurableSpace Œ¥] {f : Œ¥ ‚Üí Œ±}
    (hf : LowerSemicontinuous f) : Measurable f :=
  measurable_of_Ioi fun y => (hf.isOpen_preimage y).measurableSet

theorem measurable_of_Iic {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, MeasurableSet (f ‚Åª¬π' Iic x)) : Measurable f := by
  apply measurable_of_Ioi
  simp_rw [‚Üê compl_Iic, preimage_compl, MeasurableSet.compl_iff]
  assumption

theorem measurable_of_Ici {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, MeasurableSet (f ‚Åª¬π' Ici x)) : Measurable f := by
  apply measurable_of_Iio
  simp_rw [‚Üê compl_Ici, preimage_compl, MeasurableSet.compl_iff]
  assumption

/-- If a function is the least upper bound of countably many measurable functions,
then it is measurable. -/
theorem Measurable.isLUB {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i))
    (hg : ‚àÄ b, IsLUB { a | ‚àÉ i, f i b = a } (g b)) : Measurable g := by
  change ‚àÄ b, IsLUB (range fun i => f i b) (g b) at hg
  rw [‚ÄπBorelSpace Œ±‚Ä∫.measurable_eq, borel_eq_generateFrom_Ioi Œ±]
  apply measurable_generateFrom
  rintro _ ‚ü®a, rfl‚ü©
  simp_rw [Set.preimage, mem_Ioi, lt_isLUB_iff (hg _), exists_range_iff, setOf_exists]
  exact MeasurableSet.iUnion fun i => hf i (isOpen_lt' _).measurableSet

/-- If a function is the least upper bound of countably many measurable functions on a measurable
set `s`, and coincides with a measurable function outside of `s`, then it is measurable. -/
theorem Measurable.isLUB_of_mem {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g g' : Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, Measurable (f i))
    {s : Set Œ¥} (hs : MeasurableSet s) (hg : ‚àÄ b ‚àà s, IsLUB { a | ‚àÉ i, f i b = a } (g b))
    (hg' : EqOn g g' s·∂ú) (g'_meas : Measurable g') : Measurable g := by
  classical
  rcases isEmpty_or_nonempty Œπ with hŒπ | ‚ü®‚ü®i‚ü©‚ü©
  ¬∑ rcases eq_empty_or_nonempty s with rfl | ‚ü®x, hx‚ü©
    ¬∑ convert g'_meas
      rwa [compl_empty, eqOn_univ] at hg'
    ¬∑ have A : ‚àÄ b ‚àà s, IsBot (g b) := by simpa using hg
      have B : ‚àÄ b ‚àà s, g b = g x := by
        intro b hb
        apply le_antisymm (A b hb (g x)) (A x hx (g b))
      have : g = s.piecewise (fun _y ‚Ü¶ g x) g' := by
        ext b
        by_cases hb : b ‚àà s
        ¬∑ simp [hb, B]
        ¬∑ simp [hb, hg' hb]
      rw [this]
      exact Measurable.piecewise hs measurable_const g'_meas
  ¬∑ have : Nonempty Œπ := ‚ü®i‚ü©
    let f' : Œπ ‚Üí Œ¥ ‚Üí Œ± := fun i ‚Ü¶ s.piecewise (f i) g'
    suffices ‚àÄ b, IsLUB { a | ‚àÉ i, f' i b = a } (g b) from
      Measurable.isLUB (fun i ‚Ü¶ Measurable.piecewise hs (hf i) g'_meas) this
    intro b
    by_cases hb : b ‚àà s
    ¬∑ have A : ‚àÄ i, f' i b = f i b := fun i ‚Ü¶ by simp [f', hb]
      simpa [A] using hg b hb
    ¬∑ have A : ‚àÄ i, f' i b = g' b := fun i ‚Ü¶ by simp [f', hb]
      simp [A, hg' hb, isLUB_singleton]

theorem AEMeasurable.isLUB {Œπ} {Œº : Measure Œ¥} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, AEMeasurable (f i) Œº) (hg : ‚àÄ·µê b ‚àÇŒº, IsLUB { a | ‚àÉ i, f i b = a } (g b)) :
    AEMeasurable g Œº := by
  classical
  nontriviality Œ±
  haveI hŒ± : Nonempty Œ± := inferInstance
  rcases isEmpty_or_nonempty Œπ with hŒπ | hŒπ
  ¬∑ simp only [IsEmpty.exists_iff, setOf_false, isLUB_empty_iff] at hg
    exact aemeasurable_const' (hg.mono fun a ha => hg.mono fun b hb => (ha _).antisymm (hb _))
  let p : Œ¥ ‚Üí (Œπ ‚Üí Œ±) ‚Üí Prop := fun x f' => IsLUB { a | ‚àÉ i, f' i = a } (g x)
  let g_seq := (aeSeqSet hf p).piecewise g fun _ => hŒ±.some
  have hg_seq : ‚àÄ b, IsLUB { a | ‚àÉ i, aeSeq hf p i b = a } (g_seq b) := by
    intro b
    simp only [g_seq, aeSeq, Set.piecewise]
    split_ifs with h
    ¬∑ have h_set_eq : { a : Œ± | ‚àÉ i : Œπ, (hf i).mk (f i) b = a } =
        { a : Œ± | ‚àÉ i : Œπ, f i b = a } := by
        ext x
        simp_rw [Set.mem_setOf_eq, aeSeq.mk_eq_fun_of_mem_aeSeqSet hf h]
      rw [h_set_eq]
      exact aeSeq.fun_prop_of_mem_aeSeqSet hf h
    ¬∑ exact IsGreatest.isLUB ‚ü®(@exists_const (hŒ±.some = hŒ±.some) Œπ _).2 rfl, fun x ‚ü®i, hi‚ü© => hi.ge‚ü©
  refine ‚ü®g_seq, Measurable.isLUB (aeSeq.measurable hf p) hg_seq, ?_‚ü©
  exact
    (ite_ae_eq_of_measure_compl_zero g (fun _ => hŒ±.some) (aeSeqSet hf p)
        (aeSeq.measure_compl_aeSeqSet_eq_zero hf hg)).symm

/-- If a function is the greatest lower bound of countably many measurable functions,
then it is measurable. -/
theorem Measurable.isGLB {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i))
    (hg : ‚àÄ b, IsGLB { a | ‚àÉ i, f i b = a } (g b)) : Measurable g :=
  Measurable.isLUB (Œ± := Œ±·µí·µà) hf hg

/-- If a function is the greatest lower bound of countably many measurable functions on a measurable
set `s`, and coincides with a measurable function outside of `s`, then it is measurable. -/
theorem Measurable.isGLB_of_mem {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g g' : Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, Measurable (f i))
    {s : Set Œ¥} (hs : MeasurableSet s) (hg : ‚àÄ b ‚àà s, IsGLB { a | ‚àÉ i, f i b = a } (g b))
    (hg' : EqOn g g' s·∂ú) (g'_meas : Measurable g') : Measurable g :=
  Measurable.isLUB_of_mem (Œ± := Œ±·µí·µà) hf hs hg hg'  g'_meas

theorem AEMeasurable.isGLB {Œπ} {Œº : Measure Œ¥} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, AEMeasurable (f i) Œº) (hg : ‚àÄ·µê b ‚àÇŒº, IsGLB { a | ‚àÉ i, f i b = a } (g b)) :
    AEMeasurable g Œº :=
  AEMeasurable.isLUB (Œ± := Œ±·µí·µà) hf hg

protected theorem Monotone.measurable [LinearOrder Œ≤] [OrderClosedTopology Œ≤] {f : Œ≤ ‚Üí Œ±}
    (hf : Monotone f) : Measurable f :=
  suffices h : ‚àÄ x, OrdConnected (f ‚Åª¬π' Ioi x) from measurable_of_Ioi fun x => (h x).measurableSet
  fun _ => ordConnected_def.mpr fun _a ha _ _ _c hc => lt_of_lt_of_le ha (hf hc.1)

theorem aemeasurable_restrict_of_monotoneOn [LinearOrder Œ≤] [OrderClosedTopology Œ≤] {Œº : Measure Œ≤}
    {s : Set Œ≤} (hs : MeasurableSet s) {f : Œ≤ ‚Üí Œ±} (hf : MonotoneOn f s) :
    AEMeasurable f (Œº.restrict s) :=
  have : Monotone (f ‚àò (‚Üë) : s ‚Üí Œ±) := fun ‚ü®x, hx‚ü© ‚ü®y, hy‚ü© => fun (hxy : x ‚â§ y) => hf hx hy hxy
  aemeasurable_restrict_of_measurable_subtype hs this.measurable

protected theorem Antitone.measurable [LinearOrder Œ≤] [OrderClosedTopology Œ≤] {f : Œ≤ ‚Üí Œ±}
    (hf : Antitone f) : Measurable f :=
  @Monotone.measurable Œ±·µí·µà Œ≤ _ _ ‚Äπ_‚Ä∫ _ _ _ _ _ ‚Äπ_‚Ä∫ _ _ _ hf

theorem aemeasurable_restrict_of_antitoneOn [LinearOrder Œ≤] [OrderClosedTopology Œ≤] {Œº : Measure Œ≤}
    {s : Set Œ≤} (hs : MeasurableSet s) {f : Œ≤ ‚Üí Œ±} (hf : AntitoneOn f s) :
    AEMeasurable f (Œº.restrict s) :=
  @aemeasurable_restrict_of_monotoneOn Œ±·µí·µà Œ≤ _ _ ‚Äπ_‚Ä∫ _ _ _ _ _ ‚Äπ_‚Ä∫ _ _ _ _ hs _ hf

theorem MeasurableSet.of_mem_nhdsGT_aux {s : Set Œ±} (h : ‚àÄ x ‚àà s, s ‚àà ùìù[>] x)
    (h' : ‚àÄ x ‚àà s, ‚àÉ y, x < y) : MeasurableSet s := by
  choose! M hM using h'
  suffices H : (s \ interior s).Countable by
    have : s = interior s ‚à™ s \ interior s := by rw [union_diff_cancel interior_subset]
    rw [this]
    exact isOpen_interior.measurableSet.union H.measurableSet
  have A : ‚àÄ x ‚àà s, ‚àÉ y ‚àà Ioi x, Ioo x y ‚äÜ s := fun x hx =>
    (mem_nhdsGT_iff_exists_Ioo_subset' (hM x hx)).1 (h x hx)
  choose! y hy h'y using A
  have B : Set.PairwiseDisjoint (s \ interior s) fun x => Ioo x (y x) := by
    intro x hx x' hx' hxx'
    rcases lt_or_gt_of_ne hxx' with (h' | h')
    ¬∑ refine disjoint_left.2 fun z hz h'z => ?_
      have : x' ‚àà interior s :=
        mem_interior.2 ‚ü®Ioo x (y x), h'y _ hx.1, isOpen_Ioo, ‚ü®h', h'z.1.trans hz.2‚ü©‚ü©
      exact False.elim (hx'.2 this)
    ¬∑ refine disjoint_left.2 fun z hz h'z => ?_
      have : x ‚àà interior s :=
        mem_interior.2 ‚ü®Ioo x' (y x'), h'y _ hx'.1, isOpen_Ioo, ‚ü®h', hz.1.trans h'z.2‚ü©‚ü©
      exact False.elim (hx.2 this)
  exact B.countable_of_Ioo fun x hx => hy x hx.1

/-- If a set is a right-neighborhood of all of its points, then it is measurable. -/
theorem MeasurableSet.of_mem_nhdsGT {s : Set Œ±} (h : ‚àÄ x ‚àà s, s ‚àà ùìù[>] x) : MeasurableSet s := by
  by_cases H : ‚àÉ x ‚àà s, IsTop x
  ¬∑ rcases H with ‚ü®x‚ÇÄ, x‚ÇÄs, h‚ÇÄ‚ü©
    have : s = { x‚ÇÄ } ‚à™ s \ { x‚ÇÄ } := by rw [union_diff_cancel (singleton_subset_iff.2 x‚ÇÄs)]
    rw [this]
    refine (measurableSet_singleton _).union ?_
    have A : ‚àÄ x ‚àà s \ { x‚ÇÄ }, x < x‚ÇÄ := fun x hx => lt_of_le_of_ne (h‚ÇÄ _) (by simpa using hx.2)
    refine .of_mem_nhdsGT_aux (fun x hx => ?_) fun x hx => ‚ü®x‚ÇÄ, A x hx‚ü©
    obtain ‚ü®u, hu, us‚ü© : ‚àÉ (u : Œ±), u ‚àà Ioi x ‚àß Ioo x u ‚äÜ s :=
      (mem_nhdsGT_iff_exists_Ioo_subset' (A x hx)).1 (h x hx.1)
    refine (mem_nhdsGT_iff_exists_Ioo_subset' (A x hx)).2 ‚ü®u, hu, fun y hy => ‚ü®us hy, ?_‚ü©‚ü©
    exact ne_of_lt (hy.2.trans_le (h‚ÇÄ _))
  ¬∑ refine .of_mem_nhdsGT_aux h ?_
    simp only [IsTop] at H
    push_neg at H
    exact H

lemma measurableSet_bddAbove_range {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    MeasurableSet {b | BddAbove (range (fun i ‚Ü¶ f i b))} := by
  rcases isEmpty_or_nonempty Œ± with hŒ±|hŒ±
  ¬∑ have : ‚àÄ b, range (fun i ‚Ü¶ f i b) = ‚àÖ := fun b ‚Ü¶ eq_empty_of_isEmpty _
    simp [this]
  have A : ‚àÄ (i : Œπ) (c : Œ±), MeasurableSet {x | f i x ‚â§ c} := by
    intro i c
    exact measurableSet_le (hf i) measurable_const
  have B : ‚àÄ (c : Œ±), MeasurableSet {x | ‚àÄ i, f i x ‚â§ c} := by
    intro c
    rw [setOf_forall]
    exact MeasurableSet.iInter (fun i ‚Ü¶ A i c)
  obtain ‚ü®u, hu‚ü© : ‚àÉ (u : ‚Ñï ‚Üí Œ±), Tendsto u atTop atTop := exists_seq_tendsto (atTop : Filter Œ±)
  have : {b | BddAbove (range (fun i ‚Ü¶ f i b))} = {x | ‚àÉ n, ‚àÄ i, f i x ‚â§ u n} := by
    apply Subset.antisymm
    ¬∑ rintro x ‚ü®c, hc‚ü©
      obtain ‚ü®n, hn‚ü© : ‚àÉ n, c ‚â§ u n := (tendsto_atTop.1 hu c).exists
      exact ‚ü®n, fun i ‚Ü¶ (hc ((mem_range_self i))).trans hn‚ü©
    ¬∑ rintro x ‚ü®n, hn‚ü©
      refine ‚ü®u n, ?_‚ü©
      rintro - ‚ü®i, rfl‚ü©
      exact hn i
  rw [this, setOf_exists]
  exact MeasurableSet.iUnion (fun n ‚Ü¶ B (u n))

lemma measurableSet_bddBelow_range {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    MeasurableSet {b | BddBelow (range (fun i ‚Ü¶ f i b))} :=
  measurableSet_bddAbove_range (Œ± := Œ±·µí·µà) hf

end LinearOrder

section ConditionallyCompleteLattice

@[measurability, fun_prop]
theorem Measurable.iSup_Prop {Œ±} {mŒ± : MeasurableSpace Œ±} [ConditionallyCompleteLattice Œ±]
    (p : Prop) {f : Œ¥ ‚Üí Œ±} (hf : Measurable f) : Measurable fun b => ‚®Ü _ : p, f b := by
  classical
  simp_rw [ciSup_eq_ite]
  split_ifs with h
  ¬∑ exact hf
  ¬∑ exact measurable_const

@[measurability, fun_prop]
theorem Measurable.iInf_Prop {Œ±} {mŒ± : MeasurableSpace Œ±} [ConditionallyCompleteLattice Œ±]
    (p : Prop) {f : Œ¥ ‚Üí Œ±} (hf : Measurable f) : Measurable fun b => ‚®Ö _ : p, f b := by
  classical
  simp_rw [ciInf_eq_ite]
  split_ifs with h
  ¬∑ exact hf
  ¬∑ exact measurable_const

end ConditionallyCompleteLattice

section ConditionallyCompleteLinearOrder

variable [ConditionallyCompleteLinearOrder Œ±] [OrderTopology Œ±] [SecondCountableTopology Œ±]

@[measurability, fun_prop]
protected theorem Measurable.iSup {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    Measurable (fun b ‚Ü¶ ‚®Ü i, f i b) := by
  rcases isEmpty_or_nonempty Œπ with hŒπ|hŒπ
  ¬∑ simp [iSup_of_empty']
  have A : MeasurableSet {b | BddAbove (range (fun i ‚Ü¶ f i b))} :=
    measurableSet_bddAbove_range hf
  have : Measurable (fun (_b : Œ¥) ‚Ü¶ sSup (‚àÖ : Set Œ±)) := measurable_const
  apply Measurable.isLUB_of_mem hf A _ _ this
  ¬∑ intro b hb
    apply isLUB_ciSup
    simpa
  ¬∑ intro b hb
    apply csSup_of_not_bddAbove
    simpa

-- TODO: Why does this error?
-- /-- Compositional version of `Measurable.iSup` for use by `fun_prop`. -/
-- @[fun_prop]
-- protected lemma Measurable.iSup'' {_ : MeasurableSpace Œ≥} {Œπ : Sort*} [Countable Œπ]
--     {f : Œπ ‚Üí Œ≥ ‚Üí Œ¥ ‚Üí Œ±} {h : Œ≥ ‚Üí Œ¥} (hf : ‚àÄ i, Measurable ‚Üø(f i)) (hh : Measurable h) :
--     Measurable fun a ‚Ü¶ (‚®Ü i, f i a) (h a) := by
--   simp_rw [iSup_apply]
--   exact .iSup fun i ‚Ü¶ by fun_prop

@[measurability, fun_prop]
protected theorem AEMeasurable.iSup {Œπ} {Œº : Measure Œ¥} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, AEMeasurable (f i) Œº) : AEMeasurable (fun b => ‚®Ü i, f i b) Œº := by
  refine ‚ü®fun b ‚Ü¶ ‚®Ü i, (hf i).mk (f i) b, .iSup (fun i ‚Ü¶ (hf i).measurable_mk), ?_‚ü©
  filter_upwards [ae_all_iff.2 (fun i ‚Ü¶ (hf i).ae_eq_mk)] with b hb using by simp [hb]

@[measurability, fun_prop]
protected theorem Measurable.iInf {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    Measurable fun b => ‚®Ö i, f i b :=
  .iSup (Œ± := Œ±·µí·µà) hf

@[measurability, fun_prop]
protected theorem AEMeasurable.iInf {Œπ} {Œº : Measure Œ¥} [Countable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, AEMeasurable (f i) Œº) : AEMeasurable (fun b => ‚®Ö i, f i b) Œº :=
  .iSup (Œ± := Œ±·µí·µà) hf

protected theorem Measurable.sSup {Œπ} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {s : Set Œπ} (hs : s.Countable)
    (hf : ‚àÄ i ‚àà s, Measurable (f i)) :
    Measurable fun x => sSup ((fun i => f i x) '' s) := by
  simp_rw [image_eq_range]
  have : Countable s := hs.to_subtype
  exact .iSup fun i ‚Ü¶ hf i i.2

protected theorem Measurable.sInf {Œπ} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {s : Set Œπ} (hs : s.Countable)
    (hf : ‚àÄ i ‚àà s, Measurable (f i)) :
    Measurable fun x => sInf ((fun i => f i x) '' s) :=
  .sSup (Œ± := Œ±·µí·µà) hs hf

theorem Measurable.biSup {Œπ} (s : Set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.Countable)
    (hf : ‚àÄ i ‚àà s, Measurable (f i)) : Measurable fun b => ‚®Ü i ‚àà s, f i b := by
  haveI : Encodable s := hs.toEncodable
  by_cases H : ‚àÄ i, i ‚àà s
  ¬∑ have : ‚àÄ b, ‚®Ü i ‚àà s, f i b = ‚®Ü (i : s), f i b :=
      fun b ‚Ü¶ cbiSup_eq_of_forall (f := fun i ‚Ü¶ f i b) H
    simp only [this]
    exact .iSup (fun (i : s) ‚Ü¶ hf i i.2)
  ¬∑ have : ‚àÄ b, ‚®Ü i ‚àà s, f i b = (‚®Ü (i : s), f i b) ‚äî sSup ‚àÖ :=
      fun b ‚Ü¶ cbiSup_eq_of_not_forall (f := fun i ‚Ü¶ f i b) H
    simp only [this]
    apply Measurable.sup _ measurable_const
    exact .iSup (fun (i : s) ‚Ü¶ hf i i.2)

theorem AEMeasurable.biSup {Œπ} {Œº : Measure Œ¥} (s : Set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.Countable)
    (hf : ‚àÄ i ‚àà s, AEMeasurable (f i) Œº) : AEMeasurable (fun b => ‚®Ü i ‚àà s, f i b) Œº := by
  classical
  let g : Œπ ‚Üí Œ¥ ‚Üí Œ± := fun i ‚Ü¶ if hi : i ‚àà s then (hf i hi).mk (f i) else fun _b ‚Ü¶ sSup ‚àÖ
  have : ‚àÄ i ‚àà s, Measurable (g i) := by
    intro i hi
    simpa [g, hi] using (hf i hi).measurable_mk
  refine ‚ü®fun b ‚Ü¶ ‚®Ü (i) (_ : i ‚àà s), g i b, .biSup s hs this, ?_‚ü©
  have : ‚àÄ i ‚àà s, ‚àÄ·µê b ‚àÇŒº, f i b = g i b :=
    fun i hi ‚Ü¶ by simpa [g, hi] using (hf i hi).ae_eq_mk
  filter_upwards [(ae_ball_iff hs).2 this] with b hb
  exact iSup_congr fun i => iSup_congr (hb i)

theorem Measurable.biInf {Œπ} (s : Set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.Countable)
    (hf : ‚àÄ i ‚àà s, Measurable (f i)) : Measurable fun b => ‚®Ö i ‚àà s, f i b :=
  .biSup (Œ± := Œ±·µí·µà) s hs hf

theorem AEMeasurable.biInf {Œπ} {Œº : Measure Œ¥} (s : Set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.Countable)
    (hf : ‚àÄ i ‚àà s, AEMeasurable (f i) Œº) : AEMeasurable (fun b => ‚®Ö i ‚àà s, f i b) Œº :=
  .biSup (Œ± := Œ±·µí·µà) s hs hf

/-- `liminf` over a general filter is measurable. See `Measurable.liminf` for the version over `‚Ñï`.
-/
theorem Measurable.liminf' {Œπ Œπ'} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {v : Filter Œπ} (hf : ‚àÄ i, Measurable (f i))
    {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí Set Œπ} (hv : v.HasCountableBasis p s) (hs : ‚àÄ j, (s j).Countable) :
    Measurable fun x => liminf (f ¬∑ x) v := by
  classical
  /- We would like to write the liminf as `‚®Ü (j : Subtype p), ‚®Ö (i : s j), f i x`, as the
  measurability would follow from the measurability of infs and sups. Unfortunately, this is not
  true in general conditionally complete linear orders because of issues with empty sets or sets
  which are not bounded above or below. A slightly more complicated expression for the liminf,
  valid in general, is given in `Filter.HasBasis.liminf_eq_ite`. This expression, built from
  `if ... then ... else` and infs and sups, can be readily checked to be measurable. -/
  have : Countable (Subtype p) := hv.countable
  rcases isEmpty_or_nonempty (Subtype p) with hp|hp
  ¬∑ simp [hv.liminf_eq_sSup_iUnion_iInter]
  by_cases H : ‚àÉ (j : Subtype p), s j = ‚àÖ
  ¬∑ simp_rw [hv.liminf_eq_ite, if_pos H, measurable_const]
  simp_rw [hv.liminf_eq_ite, if_neg H]
  have : ‚àÄ i, Countable (s i) := fun i ‚Ü¶ countable_coe_iff.2 (hs i)
  let m : Subtype p ‚Üí Set Œ¥ := fun j ‚Ü¶ {x | BddBelow (range (fun (i : s j) ‚Ü¶ f i x))}
  have m_meas : ‚àÄ j, MeasurableSet (m j) :=
    fun j ‚Ü¶ measurableSet_bddBelow_range (fun (i : s j) ‚Ü¶ hf i)
  have mc_meas : MeasurableSet {x | ‚àÄ (j : Subtype p), x ‚àâ m j} := by
    rw [setOf_forall]
    exact MeasurableSet.iInter (fun j ‚Ü¶ (m_meas j).compl)
  refine measurable_const.piecewise mc_meas <| .iSup fun j ‚Ü¶ ?_
  let reparam : Œ¥ ‚Üí Subtype p ‚Üí Subtype p := fun x ‚Ü¶ liminf_reparam (fun i ‚Ü¶ f i x) s p
  let F0 : Subtype p ‚Üí Œ¥ ‚Üí Œ± := fun j x ‚Ü¶ ‚®Ö (i : s j), f i x
  have F0_meas : ‚àÄ j, Measurable (F0 j) := fun j ‚Ü¶ .iInf (fun (i : s j) ‚Ü¶ hf i)
  set F1 : Œ¥ ‚Üí Œ± := fun x ‚Ü¶ F0 (reparam x j) x with hF1
  change Measurable F1
  let g : ‚Ñï ‚Üí Subtype p := Classical.choose (exists_surjective_nat (Subtype p))
  have Z : ‚àÄ x, ‚àÉ n, x ‚àà m (g n) ‚à® ‚àÄ k, x ‚àâ m k := by
    intro x
    by_cases H : ‚àÉ k, x ‚àà m k
    ¬∑ rcases H with ‚ü®k, hk‚ü©
      rcases Classical.choose_spec (exists_surjective_nat (Subtype p)) k with ‚ü®n, rfl‚ü©
      exact ‚ü®n, Or.inl hk‚ü©
    ¬∑ push_neg at H
      exact ‚ü®0, Or.inr H‚ü©
  have : F1 = fun x ‚Ü¶ if x ‚àà m j then F0 j x else F0 (g (Nat.find (Z x))) x := by
    ext x
    have A : reparam x j = if x ‚àà m j then j else g (Nat.find (Z x)) := rfl
    split_ifs with hjx
    ¬∑ have : reparam x j = j := by rw [A, if_pos hjx]
      simp only [hF1, this]
    ¬∑ have : reparam x j = g (Nat.find (Z x)) := by rw [A, if_neg hjx]
      simp only [hF1, this]
  rw [this]
  apply Measurable.piecewise (m_meas j) (F0_meas j)
  apply Measurable.find (fun n ‚Ü¶ F0_meas (g n)) (fun n ‚Ü¶ ?_)
  exact (m_meas (g n)).union mc_meas

/-- `limsup` over a general filter is measurable. See `Measurable.limsup` for the version over `‚Ñï`.
-/
theorem Measurable.limsup' {Œπ Œπ'} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {u : Filter Œπ} (hf : ‚àÄ i, Measurable (f i))
    {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí Set Œπ} (hu : u.HasCountableBasis p s) (hs : ‚àÄ i, (s i).Countable) :
    Measurable fun x => limsup (fun i => f i x) u :=
  .liminf' (Œ± := Œ±·µí·µà) hf hu hs

/-- `liminf` over `‚Ñï` is measurable. See `Measurable.liminf'` for a version with a general filter.
-/
@[measurability, fun_prop]
theorem Measurable.liminf {f : ‚Ñï ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    Measurable fun x => liminf (fun i => f i x) atTop :=
  .liminf' hf atTop_countable_basis fun _ => to_countable _

/-- `limsup` over `‚Ñï` is measurable. See `Measurable.limsup'` for a version with a general filter.
-/
@[measurability, fun_prop]
theorem Measurable.limsup {f : ‚Ñï ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    Measurable fun x => limsup (fun i => f i x) atTop :=
  .limsup' hf atTop_countable_basis fun _ => to_countable _

end ConditionallyCompleteLinearOrder

@[deprecated (since := "2025-05-30")]
alias Homemorph.toMeasurableEquiv := Homeomorph.toMeasurableEquiv

end BorelSpace

section ENNReal

/-- One can cut out `‚Ñù‚â•0‚àû` into the sets `{0}`, `Ico (t^n) (t^(n+1))` for `n : ‚Ñ§` and `{‚àû}`. This
gives a way to compute the measure of a set in terms of sets on which a given function `f` does not
fluctuate by more than `t`. -/
theorem measure_eq_measure_preimage_add_measure_tsum_Ico_zpow {Œ± : Type*} {mŒ± : MeasurableSpace Œ±}
    (Œº : Measure Œ±) {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) {s : Set Œ±} (hs : MeasurableSet s)
    {t : ‚Ñù‚â•0} (ht : 1 < t) :
    Œº s =
      Œº (s ‚à© f ‚Åª¬π' {0}) + Œº (s ‚à© f ‚Åª¬π' {‚àû}) +
      ‚àë' n : ‚Ñ§, Œº (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
  have A : Œº s = Œº (s ‚à© f ‚Åª¬π' {0}) + Œº (s ‚à© f ‚Åª¬π' Ioi 0) := by
    rw [‚Üê measure_union]
    ¬∑ rw [‚Üê inter_union_distrib_left, ‚Üê preimage_union, singleton_union, Ioi_insert,
        ‚Üê _root_.bot_eq_zero, Ici_bot, preimage_univ, inter_univ]
    ¬∑ exact disjoint_singleton_left.mpr notMem_Ioi_self
        |>.preimage f |>.inter_right' s |>.inter_left' s
    ¬∑ exact hs.inter (hf measurableSet_Ioi)
  have B : Œº (s ‚à© f ‚Åª¬π' Ioi 0) = Œº (s ‚à© f ‚Åª¬π' {‚àû}) + Œº (s ‚à© f ‚Åª¬π' Ioo 0 ‚àû) := by
    rw [‚Üê measure_union]
    ¬∑ rw [‚Üê inter_union_distrib_left]
      congr
      ext x
      simp only [mem_singleton_iff, mem_union, mem_Ioo, mem_Ioi, mem_preimage]
      obtain (H | H) : f x = ‚àû ‚à® f x < ‚àû := eq_or_lt_of_le le_top
      ¬∑ simp only [H, or_false, ENNReal.zero_lt_top, not_top_lt, and_false]
      ¬∑ simp only [H, H.ne, and_true, false_or]
    ¬∑ refine disjoint_left.2 fun x hx h'x => ?_
      have : f x < ‚àû := h'x.2.2
      exact lt_irrefl _ (this.trans_le (le_of_eq hx.2.symm))
    ¬∑ exact hs.inter (hf measurableSet_Ioo)
  have C : Œº (s ‚à© f ‚Åª¬π' Ioo 0 ‚àû) =
      ‚àë' n : ‚Ñ§, Œº (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
    rw [‚Üê measure_iUnion,
      ENNReal.Ioo_zero_top_eq_iUnion_Ico_zpow (ENNReal.one_lt_coe_iff.2 ht) ENNReal.coe_ne_top,
      preimage_iUnion, inter_iUnion]
    ¬∑ intro i j hij
      wlog h : i < j generalizing i j
      ¬∑ exact (this hij.symm (hij.lt_or_gt.resolve_left h)).symm
      refine disjoint_left.2 fun x hx h'x => lt_irrefl (f x) ?_
      calc
        f x < (t : ‚Ñù‚â•0‚àû) ^ (i + 1) := hx.2.2
        _ ‚â§ (t : ‚Ñù‚â•0‚àû) ^ j := ENNReal.zpow_le_of_le (ENNReal.one_le_coe_iff.2 ht.le) h
        _ ‚â§ f x := h'x.2.1
    ¬∑ intro n
      exact hs.inter (hf measurableSet_Ico)
  rw [A, B, C, add_assoc]

end ENNReal
