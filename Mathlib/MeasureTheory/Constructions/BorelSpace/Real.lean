/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Yury Kudryashov
-/
import Mathlib.MeasureTheory.Constructions.BorelSpace.Order

#align_import measure_theory.constructions.borel_space.basic from "leanprover-community/mathlib"@"9f55d0d4363ae59948c33864cbc52e0b12e0e8ce"

/-!
# Borel (measurable) spaces ‚Ñù, ‚Ñù‚â•0, ‚Ñù‚â•0‚àû

## Main statements

* `borel_eq_generateFrom_Ixx_rat` (where Ixx is one of {Ioo, Ioi, Iio, Ici, Iic):
  the Borel sigma algebra on ‚Ñù is generated by intervals with rational endpoints;
* `isPiSystem_Ixx_rat` (where Ixx is one of {Ioo, Ioi, Iio, Ici, Iic):
  intervals with rational endpoints form a pi system on ‚Ñù;
* `measurable_real_toNNReal`, `measurable_coe_nnreal_real`, `measurable_coe_nnreal_ennreal`,
  `ENNReal.measurable_ofReal`, `ENNReal.measurable_toReal`:
  measurability of various coercions between ‚Ñù, ‚Ñù‚â•0, and ‚Ñù‚â•0‚àû;
* `Measurable.real_toNNReal`, `Measurable.coe_nnreal_real`, `Measurable.coe_nnreal_ennreal`,
  `Measurable.ennreal_ofReal`, `Measurable.ennreal_toNNReal`, `Measurable.ennreal_toReal`:
  measurability of functions composed with various coercions between ‚Ñù, ‚Ñù‚â•0, and ‚Ñù‚â•0‚àû
  (also similar results for a.e.-measurability);
* `Measurable.ennreal*` : measurability of special cases for arithmetic operations on `‚Ñù‚â•0‚àû`.
-/

open Set Filter MeasureTheory MeasurableSpace

open scoped Classical Topology NNReal ENNReal MeasureTheory

universe u v w x y

variable {Œ± Œ≤ Œ≥ Œ¥ : Type*} {Œπ : Sort y} {s t u : Set Œ±}

namespace Real

theorem borel_eq_generateFrom_Ioo_rat :
    borel ‚Ñù = .generateFrom (‚ãÉ (a : ‚Ñö) (b : ‚Ñö) (_ : a < b), {Ioo (a : ‚Ñù) (b : ‚Ñù)}) :=
  isTopologicalBasis_Ioo_rat.borel_eq_generateFrom
#align real.borel_eq_generate_from_Ioo_rat Real.borel_eq_generateFrom_Ioo_rat

theorem borel_eq_generateFrom_Iio_rat : borel ‚Ñù = .generateFrom (‚ãÉ a : ‚Ñö, {Iio (a : ‚Ñù)}) := by
  rw [borel_eq_generateFrom_Iio]
  refine le_antisymm
    (generateFrom_le ?_)
    (generateFrom_mono <| iUnion_subset fun q ‚Ü¶ singleton_subset_iff.mpr <| mem_range_self _)
  rintro _ ‚ü®a, rfl‚ü©
  have : IsLUB (range ((‚Üë) : ‚Ñö ‚Üí ‚Ñù) ‚à© Iio a) a := by
    simp [isLUB_iff_le_iff, mem_upperBounds, ‚Üê le_iff_forall_rat_lt_imp_le]
  rw [‚Üê this.biUnion_Iio_eq, ‚Üê image_univ, ‚Üê image_inter_preimage, univ_inter, biUnion_image]
  exact MeasurableSet.biUnion (to_countable _)
    fun b _ => GenerateMeasurable.basic (Iio (b : ‚Ñù)) (by simp)

theorem borel_eq_generateFrom_Ioi_rat : borel ‚Ñù = .generateFrom (‚ãÉ a : ‚Ñö, {Ioi (a : ‚Ñù)}) := by
  rw [borel_eq_generateFrom_Ioi]
  refine le_antisymm
    (generateFrom_le ?_)
    (generateFrom_mono <| iUnion_subset fun q ‚Ü¶ singleton_subset_iff.mpr <| mem_range_self _)
  rintro _ ‚ü®a, rfl‚ü©
  have : IsGLB (range ((‚Üë) : ‚Ñö ‚Üí ‚Ñù) ‚à© Ioi a) a := by
    simp [isGLB_iff_le_iff, mem_lowerBounds, ‚Üê le_iff_forall_lt_rat_imp_le]
  rw [‚Üê this.biUnion_Ioi_eq, ‚Üê image_univ, ‚Üê image_inter_preimage, univ_inter, biUnion_image]
  exact MeasurableSet.biUnion (to_countable _)
    fun b _ => GenerateMeasurable.basic (Ioi (b : ‚Ñù)) (by simp)

theorem borel_eq_generateFrom_Iic_rat : borel ‚Ñù = .generateFrom (‚ãÉ a : ‚Ñö, {Iic (a : ‚Ñù)}) := by
  rw [borel_eq_generateFrom_Ioi_rat, iUnion_singleton_eq_range, iUnion_singleton_eq_range]
  refine le_antisymm (generateFrom_le ?_) (generateFrom_le ?_) <;>
  rintro _ ‚ü®q, rfl‚ü© <;>
  dsimp only <;>
  [rw [‚Üê compl_Iic]; rw [‚Üê compl_Ioi]] <;>
  exact MeasurableSet.compl (GenerateMeasurable.basic _ (mem_range_self q))

theorem borel_eq_generateFrom_Ici_rat : borel ‚Ñù = .generateFrom (‚ãÉ a : ‚Ñö, {Ici (a : ‚Ñù)}) := by
  rw [borel_eq_generateFrom_Iio_rat, iUnion_singleton_eq_range, iUnion_singleton_eq_range]
  refine le_antisymm (generateFrom_le ?_) (generateFrom_le ?_) <;>
  rintro _ ‚ü®q, rfl‚ü© <;>
  dsimp only <;>
  [rw [‚Üê compl_Ici]; rw [‚Üê compl_Iio]] <;>
  exact MeasurableSet.compl (GenerateMeasurable.basic _ (mem_range_self q))

theorem isPiSystem_Ioo_rat :
    IsPiSystem (‚ãÉ (a : ‚Ñö) (b : ‚Ñö) (_ : a < b), {Ioo (a : ‚Ñù) (b : ‚Ñù)}) := by
  convert isPiSystem_Ioo ((‚Üë) : ‚Ñö ‚Üí ‚Ñù) ((‚Üë) : ‚Ñö ‚Üí ‚Ñù)
  ext x
  simp [eq_comm]
#align real.is_pi_system_Ioo_rat Real.isPiSystem_Ioo_rat

theorem isPiSystem_Iio_rat : IsPiSystem (‚ãÉ a : ‚Ñö, {Iio (a : ‚Ñù)}) := by
  convert isPiSystem_image_Iio (((‚Üë) : ‚Ñö ‚Üí ‚Ñù) '' univ)
  ext x
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]

theorem isPiSystem_Ioi_rat : IsPiSystem (‚ãÉ a : ‚Ñö, {Ioi (a : ‚Ñù)}) := by
  convert isPiSystem_image_Ioi (((‚Üë) : ‚Ñö ‚Üí ‚Ñù) '' univ)
  ext x
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]

theorem isPiSystem_Iic_rat : IsPiSystem (‚ãÉ a : ‚Ñö, {Iic (a : ‚Ñù)}) := by
  convert isPiSystem_image_Iic (((‚Üë) : ‚Ñö ‚Üí ‚Ñù) '' univ)
  ext x
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]

theorem isPiSystem_Ici_rat : IsPiSystem (‚ãÉ a : ‚Ñö, {Ici (a : ‚Ñù)}) := by
  convert isPiSystem_image_Ici (((‚Üë) : ‚Ñö ‚Üí ‚Ñù) '' univ)
  ext x
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]

/-- The intervals `(-(n + 1), (n + 1))` form a finite spanning sets in the set of open intervals
with rational endpoints for a locally finite measure `Œº` on `‚Ñù`. -/
def finiteSpanningSetsInIooRat (Œº : Measure ‚Ñù) [IsLocallyFiniteMeasure Œº] :
    Œº.FiniteSpanningSetsIn (‚ãÉ (a : ‚Ñö) (b : ‚Ñö) (_ : a < b), {Ioo (a : ‚Ñù) (b : ‚Ñù)}) where
  set n := Ioo (-(n + 1)) (n + 1)
  set_mem n := by
    simp only [mem_iUnion, mem_singleton_iff]
    refine ‚ü®-(n + 1 : ‚Ñï), n + 1, ?_, by simp‚ü©
    -- TODO: norm_cast fails here?
    push_cast
    exact neg_lt_self n.cast_add_one_pos
  finite n := measure_Ioo_lt_top
  spanning :=
    iUnion_eq_univ_iff.2 fun x =>
      ‚ü®‚åä|x|‚åã‚Çä, neg_lt.1 ((neg_le_abs x).trans_lt (Nat.lt_floor_add_one _)),
        (le_abs_self x).trans_lt (Nat.lt_floor_add_one _)‚ü©
#align real.finite_spanning_sets_in_Ioo_rat Real.finiteSpanningSetsInIooRat

theorem measure_ext_Ioo_rat {Œº ŒΩ : Measure ‚Ñù} [IsLocallyFiniteMeasure Œº]
    (h : ‚àÄ a b : ‚Ñö, Œº (Ioo a b) = ŒΩ (Ioo a b)) : Œº = ŒΩ :=
  (finiteSpanningSetsInIooRat Œº).ext borel_eq_generateFrom_Ioo_rat isPiSystem_Ioo_rat <| by
    simp only [mem_iUnion, mem_singleton_iff]
    rintro _ ‚ü®a, b, -, rfl‚ü©
    apply h
#align real.measure_ext_Ioo_rat Real.measure_ext_Ioo_rat

end Real

variable [MeasurableSpace Œ±]

@[measurability]
theorem measurable_real_toNNReal : Measurable Real.toNNReal :=
  continuous_real_toNNReal.measurable
#align measurable_real_to_nnreal measurable_real_toNNReal

@[measurability]
theorem Measurable.real_toNNReal {f : Œ± ‚Üí ‚Ñù} (hf : Measurable f) :
    Measurable fun x => Real.toNNReal (f x) :=
  measurable_real_toNNReal.comp hf
#align measurable.real_to_nnreal Measurable.real_toNNReal

@[measurability]
theorem AEMeasurable.real_toNNReal {f : Œ± ‚Üí ‚Ñù} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => Real.toNNReal (f x)) Œº :=
  measurable_real_toNNReal.comp_aemeasurable hf
#align ae_measurable.real_to_nnreal AEMeasurable.real_toNNReal

@[measurability]
theorem measurable_coe_nnreal_real : Measurable ((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù) :=
  NNReal.continuous_coe.measurable
#align measurable_coe_nnreal_real measurable_coe_nnreal_real

@[measurability]
theorem Measurable.coe_nnreal_real {f : Œ± ‚Üí ‚Ñù‚â•0} (hf : Measurable f) :
    Measurable fun x => (f x : ‚Ñù) :=
  measurable_coe_nnreal_real.comp hf
#align measurable.coe_nnreal_real Measurable.coe_nnreal_real

@[measurability]
theorem AEMeasurable.coe_nnreal_real {f : Œ± ‚Üí ‚Ñù‚â•0} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x : ‚Ñù)) Œº :=
  measurable_coe_nnreal_real.comp_aemeasurable hf
#align ae_measurable.coe_nnreal_real AEMeasurable.coe_nnreal_real

@[measurability]
theorem measurable_coe_nnreal_ennreal : Measurable ((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0‚àû) :=
  ENNReal.continuous_coe.measurable
#align measurable_coe_nnreal_ennreal measurable_coe_nnreal_ennreal

@[measurability]
theorem Measurable.coe_nnreal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0} (hf : Measurable f) :
    Measurable fun x => (f x : ‚Ñù‚â•0‚àû) :=
  ENNReal.continuous_coe.measurable.comp hf
#align measurable.coe_nnreal_ennreal Measurable.coe_nnreal_ennreal

@[measurability]
theorem AEMeasurable.coe_nnreal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x : ‚Ñù‚â•0‚àû)) Œº :=
  ENNReal.continuous_coe.measurable.comp_aemeasurable hf
#align ae_measurable.coe_nnreal_ennreal AEMeasurable.coe_nnreal_ennreal

@[measurability]
theorem Measurable.ennreal_ofReal {f : Œ± ‚Üí ‚Ñù} (hf : Measurable f) :
    Measurable fun x => ENNReal.ofReal (f x) :=
  ENNReal.continuous_ofReal.measurable.comp hf
#align measurable.ennreal_of_real Measurable.ennreal_ofReal

@[measurability]
lemma AEMeasurable.ennreal_ofReal {f : Œ± ‚Üí ‚Ñù} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x ‚Ü¶ ENNReal.ofReal (f x)) Œº :=
  ENNReal.continuous_ofReal.measurable.comp_aemeasurable hf

@[simp, norm_cast]
theorem measurable_coe_nnreal_real_iff {f : Œ± ‚Üí ‚Ñù‚â•0} :
    Measurable (fun x => f x : Œ± ‚Üí ‚Ñù) ‚Üî Measurable f :=
  ‚ü®fun h => by simpa only [Real.toNNReal_coe] using h.real_toNNReal, Measurable.coe_nnreal_real‚ü©
#align measurable_coe_nnreal_real_iff measurable_coe_nnreal_real_iff

@[simp, norm_cast]
theorem aemeasurable_coe_nnreal_real_iff {f : Œ± ‚Üí ‚Ñù‚â•0} {Œº : Measure Œ±} :
    AEMeasurable (fun x => f x : Œ± ‚Üí ‚Ñù) Œº ‚Üî AEMeasurable f Œº :=
  ‚ü®fun h ‚Ü¶ by simpa only [Real.toNNReal_coe] using h.real_toNNReal, AEMeasurable.coe_nnreal_real‚ü©
#align ae_measurable_coe_nnreal_real_iff aemeasurable_coe_nnreal_real_iff

@[deprecated (since := "2024-03-02")]
alias aEMeasurable_coe_nnreal_real_iff := aemeasurable_coe_nnreal_real_iff

/-- The set of finite `‚Ñù‚â•0‚àû` numbers is `MeasurableEquiv` to `‚Ñù‚â•0`. -/
def MeasurableEquiv.ennrealEquivNNReal : { r : ‚Ñù‚â•0‚àû | r ‚â† ‚àû } ‚âÉ·µê ‚Ñù‚â•0 :=
  ENNReal.neTopHomeomorphNNReal.toMeasurableEquiv
#align measurable_equiv.ennreal_equiv_nnreal MeasurableEquiv.ennrealEquivNNReal

namespace ENNReal

theorem measurable_of_measurable_nnreal {f : ‚Ñù‚â•0‚àû ‚Üí Œ±} (h : Measurable fun p : ‚Ñù‚â•0 => f p) :
    Measurable f :=
  measurable_of_measurable_on_compl_singleton ‚àû
    (MeasurableEquiv.ennrealEquivNNReal.symm.measurable_comp_iff.1 h)
#align ennreal.measurable_of_measurable_nnreal ENNReal.measurable_of_measurable_nnreal

/-- `‚Ñù‚â•0‚àû` is `MeasurableEquiv` to `‚Ñù‚â•0 ‚äï Unit`. -/
def ennrealEquivSum : ‚Ñù‚â•0‚àû ‚âÉ·µê Sum ‚Ñù‚â•0 Unit :=
  { Equiv.optionEquivSumPUnit ‚Ñù‚â•0 with
    measurable_toFun := measurable_of_measurable_nnreal measurable_inl
    measurable_invFun :=
      measurable_sum measurable_coe_nnreal_ennreal (@measurable_const ‚Ñù‚â•0‚àû Unit _ _ ‚àû) }
#align ennreal.ennreal_equiv_sum ENNReal.ennrealEquivSum

open Function (uncurry)

theorem measurable_of_measurable_nnreal_prod [MeasurableSpace Œ≤] [MeasurableSpace Œ≥]
    {f : ‚Ñù‚â•0‚àû √ó Œ≤ ‚Üí Œ≥} (H‚ÇÅ : Measurable fun p : ‚Ñù‚â•0 √ó Œ≤ => f (p.1, p.2))
    (H‚ÇÇ : Measurable fun x => f (‚àû, x)) : Measurable f :=
  let e : ‚Ñù‚â•0‚àû √ó Œ≤ ‚âÉ·µê Sum (‚Ñù‚â•0 √ó Œ≤) (Unit √ó Œ≤) :=
    (ennrealEquivSum.prodCongr (MeasurableEquiv.refl Œ≤)).trans
      (MeasurableEquiv.sumProdDistrib _ _ _)
  e.symm.measurable_comp_iff.1 <| measurable_sum H‚ÇÅ (H‚ÇÇ.comp measurable_id.snd)
#align ennreal.measurable_of_measurable_nnreal_prod ENNReal.measurable_of_measurable_nnreal_prod

theorem measurable_of_measurable_nnreal_nnreal [MeasurableSpace Œ≤] {f : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû ‚Üí Œ≤}
    (h‚ÇÅ : Measurable fun p : ‚Ñù‚â•0 √ó ‚Ñù‚â•0 => f (p.1, p.2)) (h‚ÇÇ : Measurable fun r : ‚Ñù‚â•0 => f (‚àû, r))
    (h‚ÇÉ : Measurable fun r : ‚Ñù‚â•0 => f (r, ‚àû)) : Measurable f :=
  measurable_of_measurable_nnreal_prod
    (measurable_swap_iff.1 <| measurable_of_measurable_nnreal_prod (h‚ÇÅ.comp measurable_swap) h‚ÇÉ)
    (measurable_of_measurable_nnreal h‚ÇÇ)
#align ennreal.measurable_of_measurable_nnreal_nnreal ENNReal.measurable_of_measurable_nnreal_nnreal

@[measurability]
theorem measurable_ofReal : Measurable ENNReal.ofReal :=
  ENNReal.continuous_ofReal.measurable
#align ennreal.measurable_of_real ENNReal.measurable_ofReal

@[measurability]
theorem measurable_toReal : Measurable ENNReal.toReal :=
  ENNReal.measurable_of_measurable_nnreal measurable_coe_nnreal_real
#align ennreal.measurable_to_real ENNReal.measurable_toReal

@[measurability]
theorem measurable_toNNReal : Measurable ENNReal.toNNReal :=
  ENNReal.measurable_of_measurable_nnreal measurable_id
#align ennreal.measurable_to_nnreal ENNReal.measurable_toNNReal

instance instMeasurableMul‚ÇÇ : MeasurableMul‚ÇÇ ‚Ñù‚â•0‚àû := by
  refine ‚ü®measurable_of_measurable_nnreal_nnreal ?_ ?_ ?_‚ü©
  ¬∑ simp only [‚Üê ENNReal.coe_mul, measurable_mul.coe_nnreal_ennreal]
  ¬∑ simp only [ENNReal.top_mul', ENNReal.coe_eq_zero]
    exact measurable_const.piecewise (measurableSet_singleton _) measurable_const
  ¬∑ simp only [ENNReal.mul_top', ENNReal.coe_eq_zero]
    exact measurable_const.piecewise (measurableSet_singleton _) measurable_const
#align ennreal.has_measurable_mul‚ÇÇ ENNReal.instMeasurableMul‚ÇÇ

instance instMeasurableSub‚ÇÇ : MeasurableSub‚ÇÇ ‚Ñù‚â•0‚àû :=
  ‚ü®by
    apply measurable_of_measurable_nnreal_nnreal <;>
      simp [‚Üê WithTop.coe_sub]; exact continuous_sub.measurable.coe_nnreal_ennreal‚ü©
#align ennreal.has_measurable_sub‚ÇÇ ENNReal.instMeasurableSub‚ÇÇ

instance instMeasurableInv : MeasurableInv ‚Ñù‚â•0‚àû :=
  ‚ü®continuous_inv.measurable‚ü©
#align ennreal.has_measurable_inv ENNReal.instMeasurableInv

instance : MeasurableSMul ‚Ñù‚â•0 ‚Ñù‚â•0‚àû where
  measurable_const_smul := by
    simp_rw [ENNReal.smul_def]
    exact fun _ ‚Ü¶ MeasurableSMul.measurable_const_smul _
  measurable_smul_const := fun x ‚Ü¶ by
    simp_rw [ENNReal.smul_def]
    exact measurable_coe_nnreal_ennreal.mul_const _

/-- A limit (over a general filter) of measurable `‚Ñù‚â•0‚àû` valued functions is measurable. -/
theorem measurable_of_tendsto' {Œπ : Type*} {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} {g : Œ± ‚Üí ‚Ñù‚â•0‚àû} (u : Filter Œπ)
    [NeBot u] [IsCountablyGenerated u] (hf : ‚àÄ i, Measurable (f i)) (lim : Tendsto f u (ùìù g)) :
    Measurable g := by
  rcases u.exists_seq_tendsto with ‚ü®x, hx‚ü©
  rw [tendsto_pi_nhds] at lim
  have : (fun y => liminf (fun n => (f (x n) y : ‚Ñù‚â•0‚àû)) atTop) = g := by
    ext1 y
    exact ((lim y).comp hx).liminf_eq
  rw [‚Üê this]
  show Measurable fun y => liminf (fun n => (f (x n) y : ‚Ñù‚â•0‚àû)) atTop
  exact measurable_liminf fun n => hf (x n)
#align measurable_of_tendsto_ennreal' ENNReal.measurable_of_tendsto'

@[deprecated (since := "2024-03-09")] alias
_root_.measurable_of_tendsto_ennreal' := ENNReal.measurable_of_tendsto'

/-- A sequential limit of measurable `‚Ñù‚â•0‚àû` valued functions is measurable. -/
theorem measurable_of_tendsto {f : ‚Ñï ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} {g : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : ‚àÄ i, Measurable (f i))
    (lim : Tendsto f atTop (ùìù g)) : Measurable g :=
  measurable_of_tendsto' atTop hf lim
#align measurable_of_tendsto_ennreal ENNReal.measurable_of_tendsto

@[deprecated (since := "2024-03-09")] alias
_root_.measurable_of_tendsto_ennreal := ENNReal.measurable_of_tendsto

/-- A limit (over a general filter) of a.e.-measurable `‚Ñù‚â•0‚àû` valued functions is
a.e.-measurable. -/
lemma aemeasurable_of_tendsto' {Œπ : Type*} {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} {g : Œ± ‚Üí ‚Ñù‚â•0‚àû}
    {Œº : Measure Œ±} (u : Filter Œπ) [NeBot u] [IsCountablyGenerated u]
    (hf : ‚àÄ i, AEMeasurable (f i) Œº) (hlim : ‚àÄ·µê a ‚àÇŒº, Tendsto (fun i ‚Ü¶ f i a) u (ùìù (g a))) :
    AEMeasurable g Œº := by
  rcases u.exists_seq_tendsto with ‚ü®v, hv‚ü©
  have h'f : ‚àÄ n, AEMeasurable (f (v n)) Œº := fun n ‚Ü¶ hf (v n)
  set p : Œ± ‚Üí (‚Ñï ‚Üí ‚Ñù‚â•0‚àû) ‚Üí Prop := fun x f' ‚Ü¶ Tendsto f' atTop (ùìù (g x))
  have hp : ‚àÄ·µê x ‚àÇŒº, p x fun n ‚Ü¶ f (v n) x := by
    filter_upwards [hlim] with x hx using hx.comp hv
  set aeSeqLim := fun x ‚Ü¶ ite (x ‚àà aeSeqSet h'f p) (g x) (‚ü®f (v 0) x‚ü© : Nonempty ‚Ñù‚â•0‚àû).some
  refine ‚ü®aeSeqLim, measurable_of_tendsto' atTop (aeSeq.measurable h'f p)
    (tendsto_pi_nhds.mpr fun x ‚Ü¶ ?_), ?_‚ü©
  ¬∑ unfold_let aeSeqLim
    simp_rw [aeSeq]
    split_ifs with hx
    ¬∑ simp_rw [aeSeq.mk_eq_fun_of_mem_aeSeqSet h'f hx]
      exact aeSeq.fun_prop_of_mem_aeSeqSet h'f hx
    ¬∑ exact tendsto_const_nhds
  ¬∑ exact (ite_ae_eq_of_measure_compl_zero g (fun x ‚Ü¶ (‚ü®f (v 0) x‚ü© : Nonempty ‚Ñù‚â•0‚àû).some)
      (aeSeqSet h'f p) (aeSeq.measure_compl_aeSeqSet_eq_zero h'f hp)).symm

/-- A limit of a.e.-measurable `‚Ñù‚â•0‚àû` valued functions is a.e.-measurable. -/
lemma aemeasurable_of_tendsto {f : ‚Ñï ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} {g : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure Œ±}
    (hf : ‚àÄ i, AEMeasurable (f i) Œº) (hlim : ‚àÄ·µê a ‚àÇŒº, Tendsto (fun i ‚Ü¶ f i a) atTop (ùìù (g a))) :
    AEMeasurable g Œº :=
  aemeasurable_of_tendsto' atTop hf hlim

end ENNReal

@[measurability]
theorem Measurable.ennreal_toNNReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) :
    Measurable fun x => (f x).toNNReal :=
  ENNReal.measurable_toNNReal.comp hf
#align measurable.ennreal_to_nnreal Measurable.ennreal_toNNReal

@[measurability]
theorem AEMeasurable.ennreal_toNNReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x).toNNReal) Œº :=
  ENNReal.measurable_toNNReal.comp_aemeasurable hf
#align ae_measurable.ennreal_to_nnreal AEMeasurable.ennreal_toNNReal

@[simp, norm_cast]
theorem measurable_coe_nnreal_ennreal_iff {f : Œ± ‚Üí ‚Ñù‚â•0} :
    (Measurable fun x => (f x : ‚Ñù‚â•0‚àû)) ‚Üî Measurable f :=
  ‚ü®fun h => h.ennreal_toNNReal, fun h => h.coe_nnreal_ennreal‚ü©
#align measurable_coe_nnreal_ennreal_iff measurable_coe_nnreal_ennreal_iff

@[simp, norm_cast]
theorem aemeasurable_coe_nnreal_ennreal_iff {f : Œ± ‚Üí ‚Ñù‚â•0} {Œº : Measure Œ±} :
    AEMeasurable (fun x => (f x : ‚Ñù‚â•0‚àû)) Œº ‚Üî AEMeasurable f Œº :=
  ‚ü®fun h => h.ennreal_toNNReal, fun h => h.coe_nnreal_ennreal‚ü©
#align ae_measurable_coe_nnreal_ennreal_iff aemeasurable_coe_nnreal_ennreal_iff

@[measurability]
theorem Measurable.ennreal_toReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) :
    Measurable fun x => ENNReal.toReal (f x) :=
  ENNReal.measurable_toReal.comp hf
#align measurable.ennreal_to_real Measurable.ennreal_toReal

@[measurability]
theorem AEMeasurable.ennreal_toReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => ENNReal.toReal (f x)) Œº :=
  ENNReal.measurable_toReal.comp_aemeasurable hf
#align ae_measurable.ennreal_to_real AEMeasurable.ennreal_toReal

/-- note: `‚Ñù‚â•0‚àû` can probably be generalized in a future version of this lemma. -/
@[measurability]
theorem Measurable.ennreal_tsum {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} (h : ‚àÄ i, Measurable (f i)) :
    Measurable fun x => ‚àë' i, f i x := by
  simp_rw [ENNReal.tsum_eq_iSup_sum]
  apply measurable_iSup
  exact fun s => s.measurable_sum fun i _ => h i
#align measurable.ennreal_tsum Measurable.ennreal_tsum

@[measurability]
theorem Measurable.ennreal_tsum' {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} (h : ‚àÄ i, Measurable (f i)) :
    Measurable (‚àë' i, f i) := by
  convert Measurable.ennreal_tsum h with x
  exact tsum_apply (Pi.summable.2 fun _ => ENNReal.summable)
#align measurable.ennreal_tsum' Measurable.ennreal_tsum'

@[measurability]
theorem Measurable.nnreal_tsum {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0} (h : ‚àÄ i, Measurable (f i)) :
    Measurable fun x => ‚àë' i, f i x := by
  simp_rw [NNReal.tsum_eq_toNNReal_tsum]
  exact (Measurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_toNNReal
#align measurable.nnreal_tsum Measurable.nnreal_tsum

@[measurability]
theorem AEMeasurable.ennreal_tsum {Œπ} [Countable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure Œ±}
    (h : ‚àÄ i, AEMeasurable (f i) Œº) : AEMeasurable (fun x => ‚àë' i, f i x) Œº := by
  simp_rw [ENNReal.tsum_eq_iSup_sum]
  apply aemeasurable_iSup
  exact fun s => Finset.aemeasurable_sum s fun i _ => h i
#align ae_measurable.ennreal_tsum AEMeasurable.ennreal_tsum

@[measurability]
theorem AEMeasurable.nnreal_tsum {Œ± : Type*} [MeasurableSpace Œ±] {Œπ : Type*} [Countable Œπ]
    {f : Œπ ‚Üí Œ± ‚Üí NNReal} {Œº : MeasureTheory.Measure Œ±} (h : ‚àÄ i : Œπ, AEMeasurable (f i) Œº) :
    AEMeasurable (fun x : Œ± => ‚àë' i : Œπ, f i x) Œº := by
  simp_rw [NNReal.tsum_eq_toNNReal_tsum]
  exact (AEMeasurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_toNNReal
#align ae_measurable.nnreal_tsum AEMeasurable.nnreal_tsum

@[measurability]
theorem measurable_coe_real_ereal : Measurable ((‚Üë) : ‚Ñù ‚Üí EReal) :=
  continuous_coe_real_ereal.measurable
#align measurable_coe_real_ereal measurable_coe_real_ereal

@[measurability]
theorem Measurable.coe_real_ereal {f : Œ± ‚Üí ‚Ñù} (hf : Measurable f) :
    Measurable fun x => (f x : EReal) :=
  measurable_coe_real_ereal.comp hf
#align measurable.coe_real_ereal Measurable.coe_real_ereal

@[measurability]
theorem AEMeasurable.coe_real_ereal {f : Œ± ‚Üí ‚Ñù} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x : EReal)) Œº :=
  measurable_coe_real_ereal.comp_aemeasurable hf
#align ae_measurable.coe_real_ereal AEMeasurable.coe_real_ereal

/-- The set of finite `EReal` numbers is `MeasurableEquiv` to `‚Ñù`. -/
def MeasurableEquiv.erealEquivReal : ({‚ä•, ‚ä§}·∂ú : Set EReal) ‚âÉ·µê ‚Ñù :=
  EReal.neBotTopHomeomorphReal.toMeasurableEquiv
#align measurable_equiv.ereal_equiv_real MeasurableEquiv.erealEquivReal

theorem EReal.measurable_of_measurable_real {f : EReal ‚Üí Œ±} (h : Measurable fun p : ‚Ñù => f p) :
    Measurable f :=
  measurable_of_measurable_on_compl_finite {‚ä•, ‚ä§} (by simp)
    (MeasurableEquiv.erealEquivReal.symm.measurable_comp_iff.1 h)
#align ereal.measurable_of_measurable_real EReal.measurable_of_measurable_real

@[measurability]
theorem measurable_ereal_toReal : Measurable EReal.toReal :=
  EReal.measurable_of_measurable_real (by simpa using measurable_id)
#align measurable_ereal_to_real measurable_ereal_toReal

@[measurability]
theorem Measurable.ereal_toReal {f : Œ± ‚Üí EReal} (hf : Measurable f) :
    Measurable fun x => (f x).toReal :=
  measurable_ereal_toReal.comp hf
#align measurable.ereal_to_real Measurable.ereal_toReal

@[measurability]
theorem AEMeasurable.ereal_toReal {f : Œ± ‚Üí EReal} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x).toReal) Œº :=
  measurable_ereal_toReal.comp_aemeasurable hf
#align ae_measurable.ereal_to_real AEMeasurable.ereal_toReal

@[measurability]
theorem measurable_coe_ennreal_ereal : Measurable ((‚Üë) : ‚Ñù‚â•0‚àû ‚Üí EReal) :=
  continuous_coe_ennreal_ereal.measurable
#align measurable_coe_ennreal_ereal measurable_coe_ennreal_ereal

@[measurability]
theorem Measurable.coe_ereal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) :
    Measurable fun x => (f x : EReal) :=
  measurable_coe_ennreal_ereal.comp hf
#align measurable.coe_ereal_ennreal Measurable.coe_ereal_ennreal

@[measurability]
theorem AEMeasurable.coe_ereal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure Œ±} (hf : AEMeasurable f Œº) :
    AEMeasurable (fun x => (f x : EReal)) Œº :=
  measurable_coe_ennreal_ereal.comp_aemeasurable hf
#align ae_measurable.coe_ereal_ennreal AEMeasurable.coe_ereal_ennreal

namespace NNReal

/-- A limit (over a general filter) of measurable `‚Ñù‚â•0` valued functions is measurable. -/
theorem measurable_of_tendsto' {Œπ} {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0} {g : Œ± ‚Üí ‚Ñù‚â•0} (u : Filter Œπ) [NeBot u]
    [IsCountablyGenerated u] (hf : ‚àÄ i, Measurable (f i)) (lim : Tendsto f u (ùìù g)) :
    Measurable g := by
  simp_rw [‚Üê measurable_coe_nnreal_ennreal_iff] at hf ‚ä¢
  refine ENNReal.measurable_of_tendsto' u hf ?_
  rw [tendsto_pi_nhds] at lim ‚ä¢
  exact fun x => (ENNReal.continuous_coe.tendsto (g x)).comp (lim x)
#align measurable_of_tendsto_nnreal' NNReal.measurable_of_tendsto'

@[deprecated (since := "2024-03-09")] alias
_root_.measurable_of_tendsto_nnreal' := NNReal.measurable_of_tendsto'

/-- A sequential limit of measurable `‚Ñù‚â•0` valued functions is measurable. -/
theorem measurable_of_tendsto {f : ‚Ñï ‚Üí Œ± ‚Üí ‚Ñù‚â•0} {g : Œ± ‚Üí ‚Ñù‚â•0} (hf : ‚àÄ i, Measurable (f i))
    (lim : Tendsto f atTop (ùìù g)) : Measurable g :=
  measurable_of_tendsto' atTop hf lim
#align measurable_of_tendsto_nnreal NNReal.measurable_of_tendsto

@[deprecated (since := "2024-03-09")] alias
_root_.measurable_of_tendsto_nnreal := NNReal.measurable_of_tendsto

end NNReal

/-- If a function `f : Œ± ‚Üí ‚Ñù‚â•0` is measurable and the measure is œÉ-finite, then there exists
spanning measurable sets with finite measure on which `f` is bounded.
See also `StronglyMeasurable.exists_spanning_measurableSet_norm_le` for functions into normed
groups. -/
theorem exists_spanning_measurableSet_le {m : MeasurableSpace Œ±} {f : Œ± ‚Üí ‚Ñù‚â•0}
    (hf : Measurable f) (Œº : Measure Œ±) [SigmaFinite Œº] :
    ‚àÉ s : ‚Ñï ‚Üí Set Œ±,
      (‚àÄ n, MeasurableSet (s n) ‚àß Œº (s n) < ‚àû ‚àß ‚àÄ x ‚àà s n, f x ‚â§ n) ‚àß
      ‚ãÉ i, s i = Set.univ := by
  let sigma_finite_sets := spanningSets Œº
  let norm_sets := fun n : ‚Ñï => { x | f x ‚â§ n }
  have norm_sets_spanning : ‚ãÉ n, norm_sets n = Set.univ := by
    ext1 x
    simp only [Set.mem_iUnion, Set.mem_setOf_eq, Set.mem_univ, iff_true_iff]
    exact exists_nat_ge (f x)
  let sets n := sigma_finite_sets n ‚à© norm_sets n
  have h_meas : ‚àÄ n, MeasurableSet (sets n) := by
    refine fun n => MeasurableSet.inter ?_ ?_
    ¬∑ exact measurable_spanningSets Œº n
    ¬∑ exact hf measurableSet_Iic
  have h_finite : ‚àÄ n, Œº (sets n) < ‚àû := by
    refine fun n => (measure_mono Set.inter_subset_left).trans_lt ?_
    exact measure_spanningSets_lt_top Œº n
  refine ‚ü®sets, fun n => ‚ü®h_meas n, h_finite n, ?_‚ü©, ?_‚ü©
  ¬∑ exact fun x hx => hx.2
  ¬∑ have :
      ‚ãÉ i, sigma_finite_sets i ‚à© norm_sets i = (‚ãÉ i, sigma_finite_sets i) ‚à© ‚ãÉ i, norm_sets i := by
      refine Set.iUnion_inter_of_monotone (monotone_spanningSets Œº) fun i j hij x => ?_
      simp only [norm_sets, Set.mem_setOf_eq]
      refine fun hif => hif.trans ?_
      exact mod_cast hij
    rw [this, norm_sets_spanning, iUnion_spanningSets Œº, Set.inter_univ]
