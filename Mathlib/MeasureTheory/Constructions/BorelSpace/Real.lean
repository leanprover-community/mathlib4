/-
Copyright (c) 2017 Johannes HÃ¶lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes HÃ¶lzl, Yury Kudryashov
-/
import Mathlib.MeasureTheory.Constructions.BorelSpace.Order
import Mathlib.MeasureTheory.MeasurableSpace.Prod
import Mathlib.MeasureTheory.Measure.Typeclasses.NoAtoms
import Mathlib.Topology.Instances.Real.Lemmas

/-!
# Borel (measurable) spaces â„, â„â‰¥0, â„â‰¥0âˆ

## Main statements

* `borel_eq_generateFrom_Ixx_rat` (where Ixx is one of {Ioo, Ioi, Iio, Ici, Iic):
  the Borel sigma algebra on â„ is generated by intervals with rational endpoints;
* `isPiSystem_Ixx_rat` (where Ixx is one of {Ioo, Ioi, Iio, Ici, Iic):
  intervals with rational endpoints form a pi system on â„;
* `measurable_real_toNNReal`, `measurable_coe_nnreal_real`, `measurable_coe_nnreal_ennreal`,
  `ENNReal.measurable_ofReal`, `ENNReal.measurable_toReal`:
  measurability of various coercions between â„, â„â‰¥0, and â„â‰¥0âˆ;
* `Measurable.real_toNNReal`, `Measurable.coe_nnreal_real`, `Measurable.coe_nnreal_ennreal`,
  `Measurable.ennreal_ofReal`, `Measurable.ennreal_toNNReal`, `Measurable.ennreal_toReal`:
  measurability of functions composed with various coercions between â„, â„â‰¥0, and â„â‰¥0âˆ
  (also similar results for a.e.-measurability);
* `Measurable.ennreal*` : measurability of special cases for arithmetic operations on `â„â‰¥0âˆ`.
-/

open Set Filter MeasureTheory MeasurableSpace

open scoped Topology NNReal ENNReal

universe u v w x y

variable {Î± Î² Î³ Î´ : Type*} {Î¹ : Sort y} {s t u : Set Î±}

namespace Real

theorem borel_eq_generateFrom_Ioo_rat :
    borel â„ = .generateFrom (â‹ƒ (a : â„š) (b : â„š) (_ : a < b), {Ioo (a : â„) (b : â„)}) :=
  isTopologicalBasis_Ioo_rat.borel_eq_generateFrom

theorem borel_eq_generateFrom_Iio_rat : borel â„ = .generateFrom (â‹ƒ a : â„š, {Iio (a : â„)}) := by
  rw [borel_eq_generateFrom_Iio]
  refine le_antisymm
    (generateFrom_le ?_)
    (generateFrom_mono <| iUnion_subset fun q â†¦ singleton_subset_iff.mpr <| mem_range_self _)
  rintro _ âŸ¨a, rflâŸ©
  have : IsLUB (range ((â†‘) : â„š â†’ â„) âˆ© Iio a) a := by
    simp [isLUB_iff_le_iff, mem_upperBounds, â† le_iff_forall_rat_lt_imp_le]
  rw [â† this.biUnion_Iio_eq, â† image_univ, â† image_inter_preimage, univ_inter, biUnion_image]
  exact MeasurableSet.biUnion (to_countable _)
    fun b _ => GenerateMeasurable.basic (Iio (b : â„)) (by simp)

theorem borel_eq_generateFrom_Ioi_rat : borel â„ = .generateFrom (â‹ƒ a : â„š, {Ioi (a : â„)}) := by
  rw [borel_eq_generateFrom_Ioi]
  refine le_antisymm
    (generateFrom_le ?_)
    (generateFrom_mono <| iUnion_subset fun q â†¦ singleton_subset_iff.mpr <| mem_range_self _)
  rintro _ âŸ¨a, rflâŸ©
  have : IsGLB (range ((â†‘) : â„š â†’ â„) âˆ© Ioi a) a := by
    simp [isGLB_iff_le_iff, mem_lowerBounds, â† le_iff_forall_lt_rat_imp_le]
  rw [â† this.biUnion_Ioi_eq, â† image_univ, â† image_inter_preimage, univ_inter, biUnion_image]
  exact MeasurableSet.biUnion (to_countable _)
    fun b _ => GenerateMeasurable.basic (Ioi (b : â„)) (by simp)

theorem borel_eq_generateFrom_Iic_rat : borel â„ = .generateFrom (â‹ƒ a : â„š, {Iic (a : â„)}) := by
  rw [borel_eq_generateFrom_Ioi_rat, iUnion_singleton_eq_range, iUnion_singleton_eq_range]
  refine le_antisymm (generateFrom_le ?_) (generateFrom_le ?_) <;>
  rintro _ âŸ¨q, rflâŸ© <;>
  dsimp only <;>
  [rw [â† compl_Iic]; rw [â† compl_Ioi]] <;>
  exact MeasurableSet.compl (GenerateMeasurable.basic _ (mem_range_self q))

theorem borel_eq_generateFrom_Ici_rat : borel â„ = .generateFrom (â‹ƒ a : â„š, {Ici (a : â„)}) := by
  rw [borel_eq_generateFrom_Iio_rat, iUnion_singleton_eq_range, iUnion_singleton_eq_range]
  refine le_antisymm (generateFrom_le ?_) (generateFrom_le ?_) <;>
  rintro _ âŸ¨q, rflâŸ© <;>
  dsimp only <;>
  [rw [â† compl_Ici]; rw [â† compl_Iio]] <;>
  exact MeasurableSet.compl (GenerateMeasurable.basic _ (mem_range_self q))

theorem isPiSystem_Ioo_rat :
    IsPiSystem (â‹ƒ (a : â„š) (b : â„š) (_ : a < b), {Ioo (a : â„) (b : â„)}) := by
  convert isPiSystem_Ioo ((â†‘) : â„š â†’ â„) ((â†‘) : â„š â†’ â„)
  ext x
  simp [eq_comm]

theorem isPiSystem_Iio_rat : IsPiSystem (â‹ƒ a : â„š, {Iio (a : â„)}) := by
  convert isPiSystem_image_Iio (((â†‘) : â„š â†’ â„) '' univ)
  ext x
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]

theorem isPiSystem_Ioi_rat : IsPiSystem (â‹ƒ a : â„š, {Ioi (a : â„)}) := by
  convert isPiSystem_image_Ioi (((â†‘) : â„š â†’ â„) '' univ)
  ext x
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]

theorem isPiSystem_Iic_rat : IsPiSystem (â‹ƒ a : â„š, {Iic (a : â„)}) := by
  convert isPiSystem_image_Iic (((â†‘) : â„š â†’ â„) '' univ)
  ext x
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]

theorem isPiSystem_Ici_rat : IsPiSystem (â‹ƒ a : â„š, {Ici (a : â„)}) := by
  convert isPiSystem_image_Ici (((â†‘) : â„š â†’ â„) '' univ)
  ext x
  simp only [iUnion_singleton_eq_range, mem_range, image_univ, mem_image, exists_exists_eq_and]

/-- The intervals `(-(n + 1), (n + 1))` form a finite spanning sets in the set of open intervals
with rational endpoints for a locally finite measure `Î¼` on `â„`. -/
def finiteSpanningSetsInIooRat (Î¼ : Measure â„) [IsLocallyFiniteMeasure Î¼] :
    Î¼.FiniteSpanningSetsIn (â‹ƒ (a : â„š) (b : â„š) (_ : a < b), {Ioo (a : â„) (b : â„)}) where
  set n := Ioo (-(n + 1)) (n + 1)
  set_mem n := by
    simp only [mem_iUnion, mem_singleton_iff]
    refine âŸ¨-(n + 1 : â„•), n + 1, ?_, by simpâŸ©
    -- TODO: norm_cast fails here?
    push_cast
    exact neg_lt_self n.cast_add_one_pos
  finite _ := measure_Ioo_lt_top
  spanning :=
    iUnion_eq_univ_iff.2 fun x =>
      âŸ¨âŒŠ|x|âŒ‹â‚Š, neg_lt.1 ((neg_le_abs x).trans_lt (Nat.lt_floor_add_one _)),
        (le_abs_self x).trans_lt (Nat.lt_floor_add_one _)âŸ©

theorem measure_ext_Ioo_rat {Î¼ Î½ : Measure â„} [IsLocallyFiniteMeasure Î¼]
    (h : âˆ€ a b : â„š, Î¼ (Ioo a b) = Î½ (Ioo a b)) : Î¼ = Î½ :=
  (finiteSpanningSetsInIooRat Î¼).ext borel_eq_generateFrom_Ioo_rat isPiSystem_Ioo_rat <| by
    simp only [mem_iUnion, mem_singleton_iff]
    rintro _ âŸ¨a, b, -, rflâŸ©
    apply h

end Real

variable {mÎ± : MeasurableSpace Î±}

@[measurability, fun_prop]
theorem measurable_real_toNNReal : Measurable Real.toNNReal :=
  continuous_real_toNNReal.measurable

@[measurability, fun_prop]
theorem Measurable.real_toNNReal {f : Î± â†’ â„} (hf : Measurable f) :
    Measurable fun x => Real.toNNReal (f x) :=
  measurable_real_toNNReal.comp hf

@[measurability, fun_prop]
theorem AEMeasurable.real_toNNReal {f : Î± â†’ â„} {Î¼ : Measure Î±} (hf : AEMeasurable f Î¼) :
    AEMeasurable (fun x => Real.toNNReal (f x)) Î¼ :=
  measurable_real_toNNReal.comp_aemeasurable hf

@[measurability]
theorem measurable_coe_nnreal_real : Measurable ((â†‘) : â„â‰¥0 â†’ â„) :=
  NNReal.continuous_coe.measurable

@[measurability, fun_prop]
theorem Measurable.coe_nnreal_real {f : Î± â†’ â„â‰¥0} (hf : Measurable f) :
    Measurable fun x => (f x : â„) :=
  measurable_coe_nnreal_real.comp hf

@[measurability, fun_prop]
theorem AEMeasurable.coe_nnreal_real {f : Î± â†’ â„â‰¥0} {Î¼ : Measure Î±} (hf : AEMeasurable f Î¼) :
    AEMeasurable (fun x => (f x : â„)) Î¼ :=
  measurable_coe_nnreal_real.comp_aemeasurable hf

@[measurability]
theorem measurable_coe_nnreal_ennreal : Measurable ((â†‘) : â„â‰¥0 â†’ â„â‰¥0âˆ) :=
  ENNReal.continuous_coe.measurable

@[measurability, fun_prop]
theorem Measurable.coe_nnreal_ennreal {f : Î± â†’ â„â‰¥0} (hf : Measurable f) :
    Measurable fun x => (f x : â„â‰¥0âˆ) :=
  ENNReal.continuous_coe.measurable.comp hf

@[measurability, fun_prop]
theorem AEMeasurable.coe_nnreal_ennreal {f : Î± â†’ â„â‰¥0} {Î¼ : Measure Î±} (hf : AEMeasurable f Î¼) :
    AEMeasurable (fun x => (f x : â„â‰¥0âˆ)) Î¼ :=
  ENNReal.continuous_coe.measurable.comp_aemeasurable hf

@[measurability, fun_prop]
theorem Measurable.ennreal_ofReal {f : Î± â†’ â„} (hf : Measurable f) :
    Measurable fun x => ENNReal.ofReal (f x) :=
  ENNReal.continuous_ofReal.measurable.comp hf

@[measurability, fun_prop]
lemma AEMeasurable.ennreal_ofReal {f : Î± â†’ â„} {Î¼ : Measure Î±} (hf : AEMeasurable f Î¼) :
    AEMeasurable (fun x â†¦ ENNReal.ofReal (f x)) Î¼ :=
  ENNReal.continuous_ofReal.measurable.comp_aemeasurable hf

@[simp, norm_cast]
theorem measurable_coe_nnreal_real_iff {f : Î± â†’ â„â‰¥0} :
    Measurable (fun x => f x : Î± â†’ â„) â†” Measurable f :=
  âŸ¨fun h => by simpa only [Real.toNNReal_coe] using h.real_toNNReal, Measurable.coe_nnreal_realâŸ©

@[simp, norm_cast]
theorem aemeasurable_coe_nnreal_real_iff {f : Î± â†’ â„â‰¥0} {Î¼ : Measure Î±} :
    AEMeasurable (fun x => f x : Î± â†’ â„) Î¼ â†” AEMeasurable f Î¼ :=
  âŸ¨fun h â†¦ by simpa only [Real.toNNReal_coe] using h.real_toNNReal, AEMeasurable.coe_nnreal_realâŸ©

/-- The set of finite `â„â‰¥0âˆ` numbers is `MeasurableEquiv` to `â„â‰¥0`. -/
def MeasurableEquiv.ennrealEquivNNReal : { r : â„â‰¥0âˆ | r â‰  âˆ } â‰ƒáµ â„â‰¥0 :=
  ENNReal.neTopHomeomorphNNReal.toMeasurableEquiv

namespace ENNReal

theorem measurable_of_measurable_nnreal {f : â„â‰¥0âˆ â†’ Î±} (h : Measurable fun p : â„â‰¥0 => f p) :
    Measurable f :=
  measurable_of_measurable_on_compl_singleton âˆ
    (MeasurableEquiv.ennrealEquivNNReal.symm.measurable_comp_iff.1 h)

/-- `â„â‰¥0âˆ` is `MeasurableEquiv` to `â„â‰¥0 âŠ• Unit`. -/
def ennrealEquivSum : â„â‰¥0âˆ â‰ƒáµ â„â‰¥0 âŠ• Unit :=
  { Equiv.optionEquivSumPUnit â„â‰¥0 with
    measurable_toFun := measurable_of_measurable_nnreal measurable_inl
    measurable_invFun :=
      measurable_sum measurable_coe_nnreal_ennreal (@measurable_const â„â‰¥0âˆ Unit _ _ âˆ) }

open Function (uncurry)

theorem measurable_of_measurable_nnreal_prod {_ : MeasurableSpace Î²} {_ : MeasurableSpace Î³}
    {f : â„â‰¥0âˆ Ã— Î² â†’ Î³} (Hâ‚ : Measurable fun p : â„â‰¥0 Ã— Î² => f (p.1, p.2))
    (Hâ‚‚ : Measurable fun x => f (âˆ, x)) : Measurable f :=
  let e : â„â‰¥0âˆ Ã— Î² â‰ƒáµ (â„â‰¥0 Ã— Î²) âŠ• (Unit Ã— Î²) :=
    (ennrealEquivSum.prodCongr (MeasurableEquiv.refl Î²)).trans
      (MeasurableEquiv.sumProdDistrib _ _ _)
  e.symm.measurable_comp_iff.1 <| measurable_sum Hâ‚ (Hâ‚‚.comp measurable_id.snd)

theorem measurable_of_measurable_nnreal_nnreal {_ : MeasurableSpace Î²} {f : â„â‰¥0âˆ Ã— â„â‰¥0âˆ â†’ Î²}
    (hâ‚ : Measurable fun p : â„â‰¥0 Ã— â„â‰¥0 => f (p.1, p.2)) (hâ‚‚ : Measurable fun r : â„â‰¥0 => f (âˆ, r))
    (hâ‚ƒ : Measurable fun r : â„â‰¥0 => f (r, âˆ)) : Measurable f :=
  measurable_of_measurable_nnreal_prod
    (measurable_swap_iff.1 <| measurable_of_measurable_nnreal_prod (hâ‚.comp measurable_swap) hâ‚ƒ)
    (measurable_of_measurable_nnreal hâ‚‚)

@[measurability]
theorem measurable_ofReal : Measurable ENNReal.ofReal :=
  ENNReal.continuous_ofReal.measurable

@[measurability]
theorem measurable_toReal : Measurable ENNReal.toReal :=
  ENNReal.measurable_of_measurable_nnreal measurable_coe_nnreal_real

@[measurability]
theorem measurable_toNNReal : Measurable ENNReal.toNNReal :=
  ENNReal.measurable_of_measurable_nnreal measurable_id

instance instMeasurableMulâ‚‚ : MeasurableMulâ‚‚ â„â‰¥0âˆ := by
  refine âŸ¨measurable_of_measurable_nnreal_nnreal ?_ ?_ ?_âŸ©
  Â· simp only [â† ENNReal.coe_mul, measurable_mul.coe_nnreal_ennreal]
  Â· simp only [ENNReal.top_mul', ENNReal.coe_eq_zero]
    exact measurable_const.piecewise (measurableSet_singleton _) measurable_const
  Â· simp only [ENNReal.mul_top', ENNReal.coe_eq_zero]
    exact measurable_const.piecewise (measurableSet_singleton _) measurable_const

instance instMeasurableSubâ‚‚ : MeasurableSubâ‚‚ â„â‰¥0âˆ :=
  âŸ¨by
    apply measurable_of_measurable_nnreal_nnreal <;>
      simp [â† WithTop.coe_sub, tsub_eq_zero_of_le];
        exact continuous_sub.measurable.coe_nnreal_ennrealâŸ©

instance instMeasurableInv : MeasurableInv â„â‰¥0âˆ :=
  âŸ¨continuous_inv.measurableâŸ©

instance : MeasurableSMul â„â‰¥0 â„â‰¥0âˆ where
  measurable_const_smul _ := by simp_rw [ENNReal.smul_def]; exact measurable_const_smul _
  measurable_smul_const _ := by
    simp_rw [ENNReal.smul_def]
    exact measurable_coe_nnreal_ennreal.mul_const _

/-- A limit (over a general filter) of measurable `â„â‰¥0âˆ` valued functions is measurable. -/
theorem measurable_of_tendsto' {Î¹ : Type*} {f : Î¹ â†’ Î± â†’ â„â‰¥0âˆ} {g : Î± â†’ â„â‰¥0âˆ} (u : Filter Î¹)
    [NeBot u] [IsCountablyGenerated u] (hf : âˆ€ i, Measurable (f i)) (lim : Tendsto f u (ğ“ g)) :
    Measurable g := by
  rcases u.exists_seq_tendsto with âŸ¨x, hxâŸ©
  rw [tendsto_pi_nhds] at lim
  have : (fun y => liminf (fun n => (f (x n) y : â„â‰¥0âˆ)) atTop) = g := by
    ext1 y
    exact ((lim y).comp hx).liminf_eq
  rw [â† this]
  show Measurable fun y => liminf (fun n => (f (x n) y : â„â‰¥0âˆ)) atTop
  exact .liminf fun n => hf (x n)

/-- A sequential limit of measurable `â„â‰¥0âˆ` valued functions is measurable. -/
theorem measurable_of_tendsto {f : â„• â†’ Î± â†’ â„â‰¥0âˆ} {g : Î± â†’ â„â‰¥0âˆ} (hf : âˆ€ i, Measurable (f i))
    (lim : Tendsto f atTop (ğ“ g)) : Measurable g :=
  measurable_of_tendsto' atTop hf lim

/-- A limit (over a general filter) of a.e.-measurable `â„â‰¥0âˆ` valued functions is
a.e.-measurable. -/
lemma aemeasurable_of_tendsto' {Î¹ : Type*} {f : Î¹ â†’ Î± â†’ â„â‰¥0âˆ} {g : Î± â†’ â„â‰¥0âˆ}
    {Î¼ : Measure Î±} (u : Filter Î¹) [NeBot u] [IsCountablyGenerated u]
    (hf : âˆ€ i, AEMeasurable (f i) Î¼) (hlim : âˆ€áµ a âˆ‚Î¼, Tendsto (fun i â†¦ f i a) u (ğ“ (g a))) :
    AEMeasurable g Î¼ := by
  rcases u.exists_seq_tendsto with âŸ¨v, hvâŸ©
  have h'f : âˆ€ n, AEMeasurable (f (v n)) Î¼ := fun n â†¦ hf (v n)
  set p : Î± â†’ (â„• â†’ â„â‰¥0âˆ) â†’ Prop := fun x f' â†¦ Tendsto f' atTop (ğ“ (g x))
  have hp : âˆ€áµ x âˆ‚Î¼, p x fun n â†¦ f (v n) x := by
    filter_upwards [hlim] with x hx using hx.comp hv
  classical
  set aeSeqLim := fun x â†¦ ite (x âˆˆ aeSeqSet h'f p) (g x) (âŸ¨f (v 0) xâŸ© : Nonempty â„â‰¥0âˆ).some
  refine âŸ¨aeSeqLim, measurable_of_tendsto' atTop (aeSeq.measurable h'f p)
    (tendsto_pi_nhds.mpr fun x â†¦ ?_), ?_âŸ©
  Â· unfold aeSeqLim
    simp_rw [aeSeq]
    split_ifs with hx
    Â· simp_rw [aeSeq.mk_eq_fun_of_mem_aeSeqSet h'f hx]
      exact aeSeq.fun_prop_of_mem_aeSeqSet h'f hx
    Â· exact tendsto_const_nhds
  Â· exact (ite_ae_eq_of_measure_compl_zero g (fun x â†¦ (âŸ¨f (v 0) xâŸ© : Nonempty â„â‰¥0âˆ).some)
      (aeSeqSet h'f p) (aeSeq.measure_compl_aeSeqSet_eq_zero h'f hp)).symm

/-- A limit of a.e.-measurable `â„â‰¥0âˆ` valued functions is a.e.-measurable. -/
lemma aemeasurable_of_tendsto {f : â„• â†’ Î± â†’ â„â‰¥0âˆ} {g : Î± â†’ â„â‰¥0âˆ} {Î¼ : Measure Î±}
    (hf : âˆ€ i, AEMeasurable (f i) Î¼) (hlim : âˆ€áµ a âˆ‚Î¼, Tendsto (fun i â†¦ f i a) atTop (ğ“ (g a))) :
    AEMeasurable g Î¼ :=
  aemeasurable_of_tendsto' atTop hf hlim

end ENNReal

@[measurability, fun_prop]
theorem Measurable.ennreal_toNNReal {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) :
    Measurable fun x => (f x).toNNReal :=
  ENNReal.measurable_toNNReal.comp hf

@[measurability, fun_prop]
theorem AEMeasurable.ennreal_toNNReal {f : Î± â†’ â„â‰¥0âˆ} {Î¼ : Measure Î±} (hf : AEMeasurable f Î¼) :
    AEMeasurable (fun x => (f x).toNNReal) Î¼ :=
  ENNReal.measurable_toNNReal.comp_aemeasurable hf

@[simp, norm_cast]
theorem measurable_coe_nnreal_ennreal_iff {f : Î± â†’ â„â‰¥0} :
    (Measurable fun x => (f x : â„â‰¥0âˆ)) â†” Measurable f :=
  âŸ¨fun h => h.ennreal_toNNReal, fun h => h.coe_nnreal_ennrealâŸ©

@[simp, norm_cast]
theorem aemeasurable_coe_nnreal_ennreal_iff {f : Î± â†’ â„â‰¥0} {Î¼ : Measure Î±} :
    AEMeasurable (fun x => (f x : â„â‰¥0âˆ)) Î¼ â†” AEMeasurable f Î¼ :=
  âŸ¨fun h => h.ennreal_toNNReal, fun h => h.coe_nnreal_ennrealâŸ©

@[measurability, fun_prop]
theorem Measurable.ennreal_toReal {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) :
    Measurable fun x => ENNReal.toReal (f x) :=
  ENNReal.measurable_toReal.comp hf

@[measurability, fun_prop]
theorem AEMeasurable.ennreal_toReal {f : Î± â†’ â„â‰¥0âˆ} {Î¼ : Measure Î±} (hf : AEMeasurable f Î¼) :
    AEMeasurable (fun x => ENNReal.toReal (f x)) Î¼ :=
  ENNReal.measurable_toReal.comp_aemeasurable hf

/-- note: `â„â‰¥0âˆ` can probably be generalized in a future version of this lemma. -/
@[measurability, fun_prop]
theorem Measurable.ennreal_tsum {Î¹} [Countable Î¹] {f : Î¹ â†’ Î± â†’ â„â‰¥0âˆ} (h : âˆ€ i, Measurable (f i)) :
    Measurable fun x => âˆ‘' i, f i x := by
  simp_rw [ENNReal.tsum_eq_iSup_sum]
  exact .iSup fun s â†¦ s.measurable_sum fun i _ => h i

@[measurability, fun_prop]
theorem Measurable.ennreal_tsum' {Î¹} [Countable Î¹] {f : Î¹ â†’ Î± â†’ â„â‰¥0âˆ} (h : âˆ€ i, Measurable (f i)) :
    Measurable (âˆ‘' i, f i) := by
  convert Measurable.ennreal_tsum h with x
  exact tsum_apply (Pi.summable.2 fun _ => ENNReal.summable)

@[measurability, fun_prop]
theorem Measurable.nnreal_tsum {Î¹} [Countable Î¹] {f : Î¹ â†’ Î± â†’ â„â‰¥0} (h : âˆ€ i, Measurable (f i)) :
    Measurable fun x => âˆ‘' i, f i x := by
  simp_rw [NNReal.tsum_eq_toNNReal_tsum]
  exact (Measurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_toNNReal

@[measurability, fun_prop]
theorem AEMeasurable.ennreal_tsum {Î¹} [Countable Î¹] {f : Î¹ â†’ Î± â†’ â„â‰¥0âˆ} {Î¼ : Measure Î±}
    (h : âˆ€ i, AEMeasurable (f i) Î¼) : AEMeasurable (fun x => âˆ‘' i, f i x) Î¼ := by
  simp_rw [ENNReal.tsum_eq_iSup_sum]
  exact .iSup fun s â†¦ Finset.aemeasurable_sum s fun i _ => h i

@[measurability, fun_prop]
theorem AEMeasurable.nnreal_tsum {Î± : Type*} {_ : MeasurableSpace Î±} {Î¹ : Type*} [Countable Î¹]
    {f : Î¹ â†’ Î± â†’ NNReal} {Î¼ : Measure Î±} (h : âˆ€ i : Î¹, AEMeasurable (f i) Î¼) :
    AEMeasurable (fun x : Î± => âˆ‘' i : Î¹, f i x) Î¼ := by
  simp_rw [NNReal.tsum_eq_toNNReal_tsum]
  exact (AEMeasurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_toNNReal

@[measurability, fun_prop]
theorem measurable_coe_real_ereal : Measurable ((â†‘) : â„ â†’ EReal) :=
  continuous_coe_real_ereal.measurable

@[measurability]
theorem Measurable.coe_real_ereal {f : Î± â†’ â„} (hf : Measurable f) :
    Measurable fun x => (f x : EReal) :=
  measurable_coe_real_ereal.comp hf

@[measurability]
theorem AEMeasurable.coe_real_ereal {f : Î± â†’ â„} {Î¼ : Measure Î±} (hf : AEMeasurable f Î¼) :
    AEMeasurable (fun x => (f x : EReal)) Î¼ :=
  measurable_coe_real_ereal.comp_aemeasurable hf

/-- The set of finite `EReal` numbers is `MeasurableEquiv` to `â„`. -/
def MeasurableEquiv.erealEquivReal : ({âŠ¥, âŠ¤}á¶œ : Set EReal) â‰ƒáµ â„ :=
  EReal.neBotTopHomeomorphReal.toMeasurableEquiv

theorem EReal.measurable_of_measurable_real {f : EReal â†’ Î±} (h : Measurable fun p : â„ => f p) :
    Measurable f :=
  measurable_of_measurable_on_compl_finite {âŠ¥, âŠ¤} (by simp)
    (MeasurableEquiv.erealEquivReal.symm.measurable_comp_iff.1 h)

@[measurability]
theorem measurable_ereal_toReal : Measurable EReal.toReal :=
  EReal.measurable_of_measurable_real (by simpa using measurable_id)

@[measurability, fun_prop]
theorem Measurable.ereal_toReal {f : Î± â†’ EReal} (hf : Measurable f) :
    Measurable fun x => (f x).toReal :=
  measurable_ereal_toReal.comp hf

@[measurability, fun_prop]
theorem AEMeasurable.ereal_toReal {f : Î± â†’ EReal} {Î¼ : Measure Î±} (hf : AEMeasurable f Î¼) :
    AEMeasurable (fun x => (f x).toReal) Î¼ :=
  measurable_ereal_toReal.comp_aemeasurable hf

@[measurability]
theorem measurable_coe_ennreal_ereal : Measurable ((â†‘) : â„â‰¥0âˆ â†’ EReal) :=
  continuous_coe_ennreal_ereal.measurable

@[measurability, fun_prop]
theorem Measurable.coe_ereal_ennreal {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) :
    Measurable fun x => (f x : EReal) :=
  measurable_coe_ennreal_ereal.comp hf

@[measurability, fun_prop]
theorem AEMeasurable.coe_ereal_ennreal {f : Î± â†’ â„â‰¥0âˆ} {Î¼ : Measure Î±} (hf : AEMeasurable f Î¼) :
    AEMeasurable (fun x => (f x : EReal)) Î¼ :=
  measurable_coe_ennreal_ereal.comp_aemeasurable hf

@[measurability]
theorem measurable_ereal_toENNReal : Measurable EReal.toENNReal :=
  EReal.measurable_of_measurable_real (by simpa using ENNReal.measurable_ofReal)

@[measurability, fun_prop]
theorem Measurable.ereal_toENNReal {f : Î± â†’ EReal} (hf : Measurable f) :
    Measurable fun x => (f x).toENNReal :=
  measurable_ereal_toENNReal.comp hf

@[measurability, fun_prop]
theorem AEMeasurable.ereal_toENNReal {f : Î± â†’ EReal} {Î¼ : Measure Î±} (hf : AEMeasurable f Î¼) :
    AEMeasurable (fun x => (f x).toENNReal) Î¼ :=
  measurable_ereal_toENNReal.comp_aemeasurable hf

namespace NNReal

instance : MeasurableSMulâ‚‚ â„â‰¥0 â„â‰¥0âˆ where
  measurable_smul := show Measurable fun r : â„â‰¥0 Ã— â„â‰¥0âˆ â†¦ (r.1 : â„â‰¥0) * r.2 by fun_prop

/-- A limit (over a general filter) of measurable `â„â‰¥0` valued functions is measurable. -/
theorem measurable_of_tendsto' {Î¹} {f : Î¹ â†’ Î± â†’ â„â‰¥0} {g : Î± â†’ â„â‰¥0} (u : Filter Î¹) [NeBot u]
    [IsCountablyGenerated u] (hf : âˆ€ i, Measurable (f i)) (lim : Tendsto f u (ğ“ g)) :
    Measurable g := by
  simp_rw [â† measurable_coe_nnreal_ennreal_iff] at hf âŠ¢
  refine ENNReal.measurable_of_tendsto' u hf ?_
  rw [tendsto_pi_nhds] at lim âŠ¢
  exact fun x => (ENNReal.continuous_coe.tendsto (g x)).comp (lim x)

/-- A sequential limit of measurable `â„â‰¥0` valued functions is measurable. -/
theorem measurable_of_tendsto {f : â„• â†’ Î± â†’ â„â‰¥0} {g : Î± â†’ â„â‰¥0} (hf : âˆ€ i, Measurable (f i))
    (lim : Tendsto f atTop (ğ“ g)) : Measurable g :=
  measurable_of_tendsto' atTop hf lim

end NNReal

namespace EReal

lemma measurableEmbedding_coe : MeasurableEmbedding Real.toEReal :=
  isOpenEmbedding_coe.measurableEmbedding

instance : MeasurableAddâ‚‚ EReal := âŸ¨EReal.lowerSemicontinuous_add.measurableâŸ©

section MeasurableMul

variable {Î± Î² Î³ : Type*} {mÎ± : MeasurableSpace Î±} {mÎ² : MeasurableSpace Î²} {mÎ³ : MeasurableSpace Î³}

lemma measurable_of_real_prod {f : EReal Ã— Î² â†’ Î³}
    (h_real : Measurable fun p : â„ Ã— Î² â†¦ f (p.1, p.2))
    (h_bot : Measurable fun x â†¦ f (âŠ¥, x)) (h_top : Measurable fun x â†¦ f (âŠ¤, x)) : Measurable f :=
  .of_unionâ‚ƒ_range_cover (measurableEmbedding_prodMk_left _) (measurableEmbedding_prodMk_left _)
    (measurableEmbedding_coe.prodMap .id) (by simp [-univ_subset_iff, subset_def, EReal.forall])
    h_bot h_top h_real

lemma measurable_of_real_real {f : EReal Ã— EReal â†’ Î²}
    (h_real : Measurable fun p : â„ Ã— â„ â†¦ f (p.1, p.2))
    (h_bot_left : Measurable fun r : â„ â†¦ f (âŠ¥, r))
    (h_top_left : Measurable fun r : â„ â†¦ f (âŠ¤, r))
    (h_bot_right : Measurable fun r : â„ â†¦ f (r, âŠ¥))
    (h_top_right : Measurable fun r : â„ â†¦ f (r, âŠ¤)) :
    Measurable f := by
  refine measurable_of_real_prod ?_ ?_ ?_
  Â· refine measurable_swap_iff.mp <| measurable_of_real_prod ?_ h_bot_right h_top_right
    exact h_real.comp measurable_swap
  Â· exact measurable_of_measurable_real h_bot_left
  Â· exact measurable_of_measurable_real h_top_left

private lemma measurable_const_mul (c : EReal) : Measurable fun (x : EReal) â†¦ c * x := by
  refine measurable_of_measurable_real ?_
  have h1 : (fun (p : â„) â†¦ (âŠ¥ : EReal) * p)
      = fun p â†¦ if p = 0 then (0 : EReal) else (if p < 0 then âŠ¤ else âŠ¥) := by
    ext p
    split_ifs with h1 h2
    Â· simp [h1]
    Â· rw [bot_mul_coe_of_neg h2]
    Â· rw [bot_mul_coe_of_pos]
      exact lt_of_le_of_ne (not_lt.mp h2) (Ne.symm h1)
  have h2 : Measurable fun (p : â„) â†¦ if p = 0 then (0 : EReal) else if p < 0 then âŠ¤ else âŠ¥ := by
    refine Measurable.piecewise (measurableSet_singleton _) measurable_const ?_
    exact Measurable.piecewise measurableSet_Iio measurable_const measurable_const
  induction c with
  | bot => rwa [h1]
  | coe c => exact (measurable_id.const_mul _).coe_real_ereal
  | top =>
    simp_rw [â† neg_bot, neg_mul]
    apply Measurable.neg
    rwa [h1]

instance : MeasurableMulâ‚‚ EReal := by
  refine âŸ¨measurable_of_real_real ?_ ?_ ?_ ?_ ?_âŸ©
  Â· exact (measurable_fst.mul measurable_snd).coe_real_ereal
  Â· exact (measurable_const_mul _).comp measurable_coe_real_ereal
  Â· exact (measurable_const_mul _).comp measurable_coe_real_ereal
  Â· simp_rw [mul_comm _ âŠ¥]
    exact (measurable_const_mul _).comp measurable_coe_real_ereal
  Â· simp_rw [mul_comm _ âŠ¤]
    exact (measurable_const_mul _).comp measurable_coe_real_ereal

end MeasurableMul

end EReal

/-- If a function `f : Î± â†’ â„â‰¥0` is measurable and the measure is Ïƒ-finite, then there exists
spanning measurable sets with finite measure on which `f` is bounded.
See also `StronglyMeasurable.exists_spanning_measurableSet_norm_le` for functions into normed
groups. -/
theorem exists_spanning_measurableSet_le {f : Î± â†’ â„â‰¥0} (hf : Measurable f) (Î¼ : Measure Î±)
    [SigmaFinite Î¼] :
    âˆƒ s : â„• â†’ Set Î±,
      (âˆ€ n, MeasurableSet (s n) âˆ§ Î¼ (s n) < âˆ âˆ§ âˆ€ x âˆˆ s n, f x â‰¤ n) âˆ§
      â‹ƒ i, s i = Set.univ := by
  let sigma_finite_sets := spanningSets Î¼
  let norm_sets := fun n : â„• => { x | f x â‰¤ n }
  have norm_sets_spanning : â‹ƒ n, norm_sets n = Set.univ := by
    ext1 x
    simp only [Set.mem_iUnion, Set.mem_setOf_eq, Set.mem_univ, iff_true]
    exact exists_nat_ge (f x)
  let sets n := sigma_finite_sets n âˆ© norm_sets n
  have h_meas : âˆ€ n, MeasurableSet (sets n) := by
    refine fun n => MeasurableSet.inter ?_ ?_
    Â· exact measurableSet_spanningSets Î¼ n
    Â· exact hf measurableSet_Iic
  have h_finite : âˆ€ n, Î¼ (sets n) < âˆ := by
    refine fun n => (measure_mono Set.inter_subset_left).trans_lt ?_
    exact measure_spanningSets_lt_top Î¼ n
  refine âŸ¨sets, fun n => âŸ¨h_meas n, h_finite n, ?_âŸ©, ?_âŸ©
  Â· exact fun x hx => hx.2
  Â· have :
      â‹ƒ i, sigma_finite_sets i âˆ© norm_sets i = (â‹ƒ i, sigma_finite_sets i) âˆ© â‹ƒ i, norm_sets i := by
      refine Set.iUnion_inter_of_monotone (monotone_spanningSets Î¼) fun i j hij x => ?_
      simp only [norm_sets, Set.mem_setOf_eq]
      refine fun hif => hif.trans ?_
      exact mod_cast hij
    rw [this, norm_sets_spanning, iUnion_spanningSets Î¼, Set.inter_univ]

variable (Î¼ : Measure â„) [IsFiniteMeasureOnCompacts Î¼]

lemma tendsto_measure_Icc_nhdsWithin_right' (b : â„) :
    Tendsto (fun Î´ â†¦ Î¼ (Icc (b - Î´) (b + Î´))) (ğ“[>] (0 : â„)) (ğ“ (Î¼ {b})) := by
  rw [Real.singleton_eq_inter_Icc]
  apply tendsto_measure_biInter_gt (fun r hr â†¦ nullMeasurableSet_Icc)
  Â· intro r s _rpos hrs
    exact Icc_subset_Icc (by linarith) (by linarith)
  Â· exact âŸ¨1, zero_lt_one, isCompact_Icc.measure_ne_topâŸ©

lemma tendsto_measure_Icc_nhdsWithin_right (b : â„) :
    Tendsto (fun Î´ â†¦ Î¼ (Icc (b - Î´) (b + Î´))) (ğ“[â‰¥] (0 : â„)) (ğ“ (Î¼ {b})) := by
  simp only [â† nhdsGT_sup_nhdsWithin_singleton, nhdsWithin_singleton, tendsto_sup,
    tendsto_measure_Icc_nhdsWithin_right' Î¼ b, true_and, tendsto_pure_left]
  intro s hs
  simpa using mem_of_mem_nhds hs

lemma tendsto_measure_Icc [NoAtoms Î¼] (b : â„) :
    Tendsto (fun Î´ â†¦ Î¼ (Icc (b - Î´) (b + Î´))) (ğ“ (0 : â„)) (ğ“ 0) := by
  rw [â† nhdsLT_sup_nhdsGE, tendsto_sup]
  constructor
  Â· apply tendsto_const_nhds.congr'
    filter_upwards [self_mem_nhdsWithin] with r (hr : r < 0)
    rw [Icc_eq_empty (by linarith), measure_empty]
  Â· simpa only [measure_singleton] using tendsto_measure_Icc_nhdsWithin_right Î¼ b
