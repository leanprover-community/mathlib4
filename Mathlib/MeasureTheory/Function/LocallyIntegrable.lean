/-
Copyright (c) 2022 Floris van Doorn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Floris van Doorn

! This file was ported from Lean 3 source module measure_theory.function.locally_integrable
! leanprover-community/mathlib commit 08a4542bec7242a5c60f179e4e49de8c0d677b1b
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathlib.MeasureTheory.Integral.IntegrableOn

/-!
# Locally integrable functions

A function is called *locally integrable* (`MeasureTheory.LocallyIntegrable`) if it is integrable
on a neighborhood of every point. More generally, it is *locally integrable on `s`* if it is
locally integrable on a neighbourhood within `s` of any point of `s`.

This file contains properties of locally integrable functions, and integrability results
on compact sets.

## Main statements

* `Continuous.locallyIntegrable`: A continuous function is locally integrable.
* `ContinuousOn.locallyIntegrableOn`: A function which is continuous on `s` is locally
  integrable on `s`.
-/


open MeasureTheory MeasureTheory.Measure Set Function TopologicalSpace

open scoped Topology Interval

variable {X Y E R : Type _} [MeasurableSpace X] [TopologicalSpace X]

variable [MeasurableSpace Y] [TopologicalSpace Y]

variable [NormedAddCommGroup E] {f : X ‚Üí E} {Œº : Measure X} {s : Set X}

namespace MeasureTheory

section LocallyIntegrableOn

/-- A function `f : X ‚Üí E` is *locally integrable on s*, for `s ‚äÜ X`, if for every `x ‚àà s` there is
a neighbourhood of `x` within `s` on which `f` is integrable. (Note this is, in general, strictly
weaker than local integrability with respect to `Œº.restrict s`.) -/
def LocallyIntegrableOn (f : X ‚Üí E) (s : Set X) (Œº : Measure X := by volume_tac) : Prop :=
  ‚àÄ x : X, x ‚àà s ‚Üí IntegrableAtFilter f (ùìù[s] x) Œº
#align measure_theory.locally_integrable_on MeasureTheory.LocallyIntegrableOn

theorem LocallyIntegrableOn.mono (hf : MeasureTheory.LocallyIntegrableOn f s Œº) {t : Set X}
    (hst : t ‚äÜ s) : LocallyIntegrableOn f t Œº := fun x hx =>
  (hf x <| hst hx).filter_mono (nhdsWithin_mono x hst)
#align measure_theory.locally_integrable_on.mono MeasureTheory.LocallyIntegrableOn.mono

theorem LocallyIntegrableOn.norm (hf : LocallyIntegrableOn f s Œº) :
    LocallyIntegrableOn (fun x => ‚Äñf x‚Äñ) s Œº := fun t ht =>
  let ‚ü®U, hU_nhd, hU_int‚ü© := hf t ht
  ‚ü®U, hU_nhd, hU_int.norm‚ü©
#align measure_theory.locally_integrable_on.norm MeasureTheory.LocallyIntegrableOn.norm

theorem IntegrableOn.locallyIntegrableOn (hf : IntegrableOn f s Œº) : LocallyIntegrableOn f s Œº :=
  fun _ _ => ‚ü®s, self_mem_nhdsWithin, hf‚ü©
#align measure_theory.integrable_on.locally_integrable_on MeasureTheory.IntegrableOn.locallyIntegrableOn

/-- If a function is locally integrable on a compact set, then it is integrable on that set. -/
theorem LocallyIntegrableOn.integrableOn_isCompact (hf : LocallyIntegrableOn f s Œº)
    (hs : IsCompact s) : IntegrableOn f s Œº :=
  IsCompact.induction_on hs integrableOn_empty (fun _u _v huv hv => hv.mono_set huv)
    (fun _u _v hu hv => integrableOn_union.mpr ‚ü®hu, hv‚ü©) hf
#align measure_theory.locally_integrable_on.integrable_on_is_compact MeasureTheory.LocallyIntegrableOn.integrableOn_isCompact

theorem LocallyIntegrableOn.integrableOn_compact_subset (hf : LocallyIntegrableOn f s Œº) {t : Set X}
    (hst : t ‚äÜ s) (ht : IsCompact t) : IntegrableOn f t Œº :=
  (hf.mono hst).integrableOn_isCompact ht
#align measure_theory.locally_integrable_on.integrable_on_compact_subset MeasureTheory.LocallyIntegrableOn.integrableOn_compact_subset

theorem LocallyIntegrableOn.aestronglyMeasurable [SecondCountableTopology X]
    (hf : LocallyIntegrableOn f s Œº) : AEStronglyMeasurable f (Œº.restrict s) := by
  have : ‚àÄ x : s, ‚àÉ u, IsOpen u ‚àß x.1 ‚àà u ‚àß IntegrableOn f (u ‚à© s) Œº := by
    rintro ‚ü®x, hx‚ü©
    rcases hf x hx with ‚ü®t, ht, h't‚ü©
    rcases mem_nhdsWithin.1 ht with ‚ü®u, u_open, x_mem, u_sub‚ü©
    refine' ‚ü®u, u_open, x_mem, h't.mono_set u_sub‚ü©
  choose u u_open xu hu using this
  obtain ‚ü®T, T_count, hT‚ü© : ‚àÉ T : Set s, T.Countable ‚àß s = ‚ãÉ i : T, u i ‚à© s := by
    have : s ‚äÜ ‚ãÉ x : s, u x := fun y hy => mem_iUnion_of_mem ‚ü®y, hy‚ü© (xu ‚ü®y, hy‚ü©)
    obtain ‚ü®T, hT_count, hT_un‚ü© := isOpen_iUnion_countable u u_open
    refine' ‚ü®T, hT_count, _‚ü©
    rw [‚Üê hT_un, biUnion_eq_iUnion] at this
    rw [‚Üê iUnion_inter, eq_comm, inter_eq_right_iff_subset]
    exact this
  have : Countable T := countable_coe_iff.mpr T_count
  rw [hT, aestronglyMeasurable_iUnion_iff]
  exact fun i : T => (hu i).aestronglyMeasurable
#align measure_theory.locally_integrable_on.ae_strongly_measurable MeasureTheory.LocallyIntegrableOn.aestronglyMeasurable

/-- If `s` is either open, or closed, then `f` is locally integrable on `s` iff it is integrable on
every compact subset contained in `s`. -/
theorem locallyIntegrableOn_iff [LocallyCompactSpace X] [T2Space X] (hs : IsClosed s ‚à® IsOpen s) :
    LocallyIntegrableOn f s Œº ‚Üî ‚àÄ (k : Set X), k ‚äÜ s ‚Üí (IsCompact k ‚Üí IntegrableOn f k Œº) := by
  -- The correct condition is that `s` be *locally closed*, i.e. for every `x ‚àà s` there is some
  -- `U ‚àà ùìù x` such that `U ‚à© s` is closed. But mathlib doesn't have locally closed sets yet.
  refine' ‚ü®fun hf k hk => hf.integrableOn_compact_subset hk, fun hf x hx => _‚ü©
  cases hs with
  | inl hs =>
    exact
      let ‚ü®K, hK, h2K‚ü© := exists_compact_mem_nhds x
      ‚ü®_, inter_mem_nhdsWithin s h2K,
        hf _ (inter_subset_left _ _)
          (isCompact_of_isClosed_subset hK (hs.inter hK.isClosed) (inter_subset_right _ _))‚ü©
  | inr hs =>
    obtain ‚ü®K, hK, h2K, h3K‚ü© := exists_compact_subset hs hx
    refine' ‚ü®K, _, hf K h3K hK‚ü©
    simpa only [IsOpen.nhdsWithin_eq hs hx, interior_eq_nhds'] using h2K
#align measure_theory.locally_integrable_on_iff MeasureTheory.locallyIntegrableOn_iff

end LocallyIntegrableOn

/-- A function `f : X ‚Üí E` is *locally integrable* if it is integrable on a neighborhood of every
point. In particular, it is integrable on all compact sets,
see `LocallyIntegrable.integrableOn_isCompact`. -/
def LocallyIntegrable (f : X ‚Üí E) (Œº : Measure X := by volume_tac) : Prop :=
  ‚àÄ x : X, IntegrableAtFilter f (ùìù x) Œº
#align measure_theory.locally_integrable MeasureTheory.LocallyIntegrable

theorem locallyIntegrableOn_univ : LocallyIntegrableOn f univ Œº ‚Üî LocallyIntegrable f Œº := by
  simp only [LocallyIntegrableOn, nhdsWithin_univ, mem_univ, true_imp_iff]; rfl
#align measure_theory.locally_integrable_on_univ MeasureTheory.locallyIntegrableOn_univ

theorem LocallyIntegrable.locallyIntegrableOn (hf : LocallyIntegrable f Œº) (s : Set X) :
    LocallyIntegrableOn f s Œº := fun x _ => (hf x).filter_mono nhdsWithin_le_nhds
#align measure_theory.locally_integrable.locally_integrable_on MeasureTheory.LocallyIntegrable.locallyIntegrableOn

theorem Integrable.locallyIntegrable (hf : Integrable f Œº) : LocallyIntegrable f Œº := fun _ =>
  hf.integrableAtFilter _
#align measure_theory.integrable.locally_integrable MeasureTheory.Integrable.locallyIntegrable

/-- If `f` is locally integrable with respect to `Œº.restrict s`, it is locally integrable on `s`.
(See `locallyIntegrableOn_iff_locallyIntegrable_restrict` for an iff statement when `s` is
closed.) -/
theorem locallyIntegrableOn_of_locallyIntegrable_restrict [OpensMeasurableSpace X]
    (hf : LocallyIntegrable f (Œº.restrict s)) : LocallyIntegrableOn f s Œº := by
  intro x _
  obtain ‚ü®t, ht_mem, ht_int‚ü© := hf x
  obtain ‚ü®u, hu_sub, hu_o, hu_mem‚ü© := mem_nhds_iff.mp ht_mem
  refine' ‚ü®_, inter_mem_nhdsWithin s (hu_o.mem_nhds hu_mem), _‚ü©
  simpa only [IntegrableOn, Measure.restrict_restrict hu_o.measurableSet, inter_comm] using
    ht_int.mono_set hu_sub
#align measure_theory.locally_integrable_on_of_locally_integrable_restrict MeasureTheory.locallyIntegrableOn_of_locallyIntegrable_restrict

/-- If `s` is closed, being locally integrable on `s` wrt `Œº` is equivalent to being locally
integrable with respect to `Œº.restrict s`. For the one-way implication without assuming `s` closed,
see `locallyIntegrableOn_of_locallyIntegrable_restrict`. -/
theorem locallyIntegrableOn_iff_locallyIntegrable_restrict [OpensMeasurableSpace X]
    (hs : IsClosed s) : LocallyIntegrableOn f s Œº ‚Üî LocallyIntegrable f (Œº.restrict s) := by
  refine' ‚ü®fun hf x => _, locallyIntegrableOn_of_locallyIntegrable_restrict‚ü©
  by_cases h : x ‚àà s
  ¬∑ obtain ‚ü®t, ht_nhds, ht_int‚ü© := hf x h
    obtain ‚ü®u, hu_o, hu_x, hu_sub‚ü© := mem_nhdsWithin.mp ht_nhds
    refine' ‚ü®u, hu_o.mem_nhds hu_x, _‚ü©
    rw [IntegrableOn, restrict_restrict hu_o.measurableSet]
    exact ht_int.mono_set hu_sub
  ¬∑ rw [‚Üê isOpen_compl_iff] at hs
    refine' ‚ü®s·∂ú, hs.mem_nhds h, _‚ü©
    rw [IntegrableOn, restrict_restrict, inter_comm, inter_compl_self, ‚Üê IntegrableOn]
    exacts [integrableOn_empty, hs.measurableSet]
#align measure_theory.locally_integrable_on_iff_locally_integrable_restrict MeasureTheory.locallyIntegrableOn_iff_locallyIntegrable_restrict

/-- If a function is locally integrable, then it is integrable on any compact set. -/
theorem LocallyIntegrable.integrableOn_isCompact {k : Set X} (hf : LocallyIntegrable f Œº)
    (hk : IsCompact k) : IntegrableOn f k Œº :=
  (hf.locallyIntegrableOn k).integrableOn_isCompact hk
#align measure_theory.locally_integrable.integrable_on_is_compact MeasureTheory.LocallyIntegrable.integrableOn_isCompact

/-- If a function is locally integrable, then it is integrable on an open neighborhood of any
compact set. -/
theorem LocallyIntegrable.integrableOn_nhds_isCompact (hf : LocallyIntegrable f Œº) {k : Set X}
    (hk : IsCompact k) : ‚àÉ u, IsOpen u ‚àß k ‚äÜ u ‚àß IntegrableOn f u Œº := by
  refine' IsCompact.induction_on hk _ _ _ _
  ¬∑ refine' ‚ü®‚àÖ, isOpen_empty, Subset.rfl, integrableOn_empty‚ü©
  ¬∑ rintro s t hst ‚ü®u, u_open, tu, hu‚ü©
    exact ‚ü®u, u_open, hst.trans tu, hu‚ü©
  ¬∑ rintro s t ‚ü®u, u_open, su, hu‚ü© ‚ü®v, v_open, tv, hv‚ü©
    exact ‚ü®u ‚à™ v, u_open.union v_open, union_subset_union su tv, hu.union hv‚ü©
  ¬∑ intro x _
    rcases hf x with ‚ü®u, ux, hu‚ü©
    rcases mem_nhds_iff.1 ux with ‚ü®v, vu, v_open, xv‚ü©
    exact ‚ü®v, nhdsWithin_le_nhds (v_open.mem_nhds xv), v, v_open, Subset.rfl, hu.mono_set vu‚ü©
#align measure_theory.locally_integrable.integrable_on_nhds_is_compact MeasureTheory.LocallyIntegrable.integrableOn_nhds_isCompact

theorem locallyIntegrable_iff [LocallyCompactSpace X] :
    LocallyIntegrable f Œº ‚Üî ‚àÄ k : Set X, IsCompact k ‚Üí IntegrableOn f k Œº :=
  ‚ü®fun hf _k hk => hf.integrableOn_isCompact hk, fun hf x =>
    let ‚ü®K, hK, h2K‚ü© := exists_compact_mem_nhds x
    ‚ü®K, h2K, hf K hK‚ü©‚ü©
#align measure_theory.locally_integrable_iff MeasureTheory.locallyIntegrable_iff

theorem LocallyIntegrable.aestronglyMeasurable [SecondCountableTopology X]
    (hf : LocallyIntegrable f Œº) : AEStronglyMeasurable f Œº := by
  simpa only [restrict_univ] using (locallyIntegrableOn_univ.mpr hf).aestronglyMeasurable
#align measure_theory.locally_integrable.ae_strongly_measurable MeasureTheory.LocallyIntegrable.aestronglyMeasurable

theorem locallyIntegrable_const [LocallyFiniteMeasure Œº] (c : E) :
    LocallyIntegrable (fun _ => c) Œº := by
  intro x
  rcases Œº.finiteAt_nhds x with ‚ü®U, hU, h'U‚ü©
  refine' ‚ü®U, hU, _‚ü©
  simp only [h'U, integrableOn_const, or_true_iff]
#align measure_theory.locally_integrable_const MeasureTheory.locallyIntegrable_const

theorem locallyIntegrableOn_const [LocallyFiniteMeasure Œº] (c : E) :
    LocallyIntegrableOn (fun _ => c) s Œº :=
  (locallyIntegrable_const c).locallyIntegrableOn s
#align measure_theory.locally_integrable_on_const MeasureTheory.locallyIntegrableOn_const

theorem LocallyIntegrable.indicator (hf : LocallyIntegrable f Œº) {s : Set X}
    (hs : MeasurableSet s) : LocallyIntegrable (s.indicator f) Œº := by
  intro x
  rcases hf x with ‚ü®U, hU, h'U‚ü©
  exact ‚ü®U, hU, h'U.indicator hs‚ü©
#align measure_theory.locally_integrable.indicator MeasureTheory.LocallyIntegrable.indicator

theorem locallyIntegrable_map_homeomorph [BorelSpace X] [BorelSpace Y] (e : X ‚âÉ‚Çú Y) {f : Y ‚Üí E}
    {Œº : Measure X} : LocallyIntegrable f (Measure.map e Œº) ‚Üî LocallyIntegrable (f ‚àò e) Œº := by
  refine' ‚ü®fun h x => _, fun h x => _‚ü©
  ¬∑ rcases h (e x) with ‚ü®U, hU, h'U‚ü©
    refine' ‚ü®e ‚Åª¬π' U, e.continuous.continuousAt.preimage_mem_nhds hU, _‚ü©
    exact (integrableOn_map_equiv e.toMeasurableEquiv).1 h'U
  ¬∑ rcases h (e.symm x) with ‚ü®U, hU, h'U‚ü©
    refine' ‚ü®e.symm ‚Åª¬π' U, e.symm.continuous.continuousAt.preimage_mem_nhds hU, _‚ü©
    apply (integrableOn_map_equiv e.toMeasurableEquiv).2
    simp only [Homeomorph.toMeasurableEquiv_coe]
    convert h'U
    ext x
    simp only [mem_preimage, Homeomorph.symm_apply_apply]
#align measure_theory.locally_integrable_map_homeomorph MeasureTheory.locallyIntegrable_map_homeomorph

end MeasureTheory

open MeasureTheory

section borel

variable [OpensMeasurableSpace X] [LocallyFiniteMeasure Œº]

variable {K : Set X} {a b : X}

/-- A continuous function `f` is locally integrable with respect to any locally finite measure. -/
theorem Continuous.locallyIntegrable [SecondCountableTopologyEither X E] (hf : Continuous f) :
    LocallyIntegrable f Œº :=
  hf.integrableAt_nhds
#align continuous.locally_integrable Continuous.locallyIntegrable

/-- A function `f` continuous on a set `K` is locally integrable on this set with respect
to any locally finite measure. -/
theorem ContinuousOn.locallyIntegrableOn [SecondCountableTopologyEither X E] (hf : ContinuousOn f K)
    (hK : MeasurableSet K) : LocallyIntegrableOn f K Œº := fun _x hx =>
  hf.integrableAt_nhdsWithin hK hx
#align continuous_on.locally_integrable_on ContinuousOn.locallyIntegrableOn

variable [MetrizableSpace X]

/-- A function `f` continuous on a compact set `K` is integrable on this set with respect to any
locally finite measure. -/
theorem ContinuousOn.integrableOn_compact (hK : IsCompact K) (hf : ContinuousOn f K) :
    IntegrableOn f K Œº := by
  letI := metrizableSpaceMetric X
  refine' LocallyIntegrableOn.integrableOn_isCompact (fun x hx => _) hK
  exact hf.integrableAt_nhdsWithin_of_isSeparable hK.measurableSet hK.isSeparable hx
#align continuous_on.integrable_on_compact ContinuousOn.integrableOn_compact

theorem ContinuousOn.integrableOn_Icc [Preorder X] [CompactIccSpace X]
    (hf : ContinuousOn f (Icc a b)) : IntegrableOn f (Icc a b) Œº :=
  hf.integrableOn_compact isCompact_Icc
#align continuous_on.integrable_on_Icc ContinuousOn.integrableOn_Icc

theorem Continuous.integrableOn_Icc [Preorder X] [CompactIccSpace X] (hf : Continuous f) :
    IntegrableOn f (Icc a b) Œº :=
  hf.continuousOn.integrableOn_Icc
#align continuous.integrable_on_Icc Continuous.integrableOn_Icc

theorem Continuous.integrableOn_Ioc [Preorder X] [CompactIccSpace X] (hf : Continuous f) :
    IntegrableOn f (Ioc a b) Œº :=
  hf.integrableOn_Icc.mono_set Ioc_subset_Icc_self
#align continuous.integrable_on_Ioc Continuous.integrableOn_Ioc

theorem ContinuousOn.integrableOn_uIcc [LinearOrder X] [CompactIccSpace X]
    (hf : ContinuousOn f [[a, b]]) : IntegrableOn f [[a, b]] Œº :=
  hf.integrableOn_Icc
#align continuous_on.integrable_on_uIcc ContinuousOn.integrableOn_uIcc

theorem Continuous.integrableOn_uIcc [LinearOrder X] [CompactIccSpace X] (hf : Continuous f) :
    IntegrableOn f [[a, b]] Œº :=
  hf.integrableOn_Icc
#align continuous.integrable_on_uIcc Continuous.integrableOn_uIcc

theorem Continuous.integrableOn_uIoc [LinearOrder X] [CompactIccSpace X] (hf : Continuous f) :
    IntegrableOn f (Œô a b) Œº :=
  hf.integrableOn_Ioc
#align continuous.integrable_on_uIoc Continuous.integrableOn_uIoc

/-- A continuous function with compact support is integrable on the whole space. -/
theorem Continuous.integrable_of_hasCompactSupport (hf : Continuous f) (hcf : HasCompactSupport f) :
    Integrable f Œº :=
  (integrableOn_iff_integrable_of_support_subset (subset_tsupport f)).mp <|
    hf.continuousOn.integrableOn_compact hcf
#align continuous.integrable_of_has_compact_support Continuous.integrable_of_hasCompactSupport

end borel

open scoped ENNReal

section Monotone

variable [BorelSpace X] [ConditionallyCompleteLinearOrder X] [ConditionallyCompleteLinearOrder E]
  [OrderTopology X] [OrderTopology E] [SecondCountableTopology E]

theorem MonotoneOn.integrableOn_of_measure_ne_top (hmono : MonotoneOn f s) {a b : X}
    (ha : IsLeast s a) (hb : IsGreatest s b) (hs : Œº s ‚â† ‚àû) (h's : MeasurableSet s) :
    IntegrableOn f s Œº := by
  borelize E
  obtain rfl | _ := s.eq_empty_or_nonempty
  ¬∑ exact integrableOn_empty
  have hbelow : BddBelow (f '' s) := ‚ü®f a, fun x ‚ü®y, hy, hyx‚ü© => hyx ‚ñ∏ hmono ha.1 hy (ha.2 hy)‚ü©
  have habove : BddAbove (f '' s) := ‚ü®f b, fun x ‚ü®y, hy, hyx‚ü© => hyx ‚ñ∏ hmono hy hb.1 (hb.2 hy)‚ü©
  have : Metric.Bounded (f '' s) := Metric.bounded_of_bddAbove_of_bddBelow habove hbelow
  rcases bounded_iff_forall_norm_le.mp this with ‚ü®C, hC‚ü©
  have A : IntegrableOn (fun _ => C) s Œº := by
    simp only [hs.lt_top, integrableOn_const, or_true_iff]
  refine'
    Integrable.mono' A (aemeasurable_restrict_of_monotoneOn h's hmono).aestronglyMeasurable
      ((ae_restrict_iff' h's).mpr <| ae_of_all _ fun y hy => hC (f y) (mem_image_of_mem f hy))
#align monotone_on.integrable_on_of_measure_ne_top MonotoneOn.integrableOn_of_measure_ne_top

theorem MonotoneOn.integrableOn_isCompact [FiniteMeasureOnCompacts Œº] (hs : IsCompact s)
    (hmono : MonotoneOn f s) : IntegrableOn f s Œº := by
  obtain rfl | h := s.eq_empty_or_nonempty
  ¬∑ exact integrableOn_empty
  ¬∑ exact
      hmono.integrableOn_of_measure_ne_top (hs.isLeast_sInf h) (hs.isGreatest_sSup h)
        hs.measure_lt_top.ne hs.measurableSet
#align monotone_on.integrable_on_is_compact MonotoneOn.integrableOn_isCompact

theorem AntitoneOn.integrableOn_of_measure_ne_top (hanti : AntitoneOn f s) {a b : X}
    (ha : IsLeast s a) (hb : IsGreatest s b) (hs : Œº s ‚â† ‚àû) (h's : MeasurableSet s) :
    IntegrableOn f s Œº :=
  hanti.dual_right.integrableOn_of_measure_ne_top ha hb hs h's
#align antitone_on.integrable_on_of_measure_ne_top AntitoneOn.integrableOn_of_measure_ne_top

theorem AntioneOn.integrableOn_isCompact [FiniteMeasureOnCompacts Œº] (hs : IsCompact s)
    (hanti : AntitoneOn f s) : IntegrableOn f s Œº :=
  hanti.dual_right.integrableOn_isCompact (E := E·µí·µà) hs
#align antione_on.integrable_on_is_compact AntioneOn.integrableOn_isCompact

theorem Monotone.locallyIntegrable [LocallyFiniteMeasure Œº] (hmono : Monotone f) :
    LocallyIntegrable f Œº := by
  intro x
  rcases Œº.finiteAt_nhds x with ‚ü®U, hU, h'U‚ü©
  obtain ‚ü®a, b, xab, hab, abU‚ü© : ‚àÉ a b : X, x ‚àà Icc a b ‚àß Icc a b ‚àà ùìù x ‚àß Icc a b ‚äÜ U
  exact exists_Icc_mem_subset_of_mem_nhds hU
  have ab : a ‚â§ b := xab.1.trans xab.2
  refine' ‚ü®Icc a b, hab, _‚ü©
  exact
    (hmono.monotoneOn _).integrableOn_of_measure_ne_top (isLeast_Icc ab) (isGreatest_Icc ab)
      ((measure_mono abU).trans_lt h'U).ne measurableSet_Icc
#align monotone.locally_integrable Monotone.locallyIntegrable

theorem Antitone.locallyIntegrable [LocallyFiniteMeasure Œº] (hanti : Antitone f) :
    LocallyIntegrable f Œº :=
  hanti.dual_right.locallyIntegrable
#align antitone.locally_integrable Antitone.locallyIntegrable

end Monotone

namespace MeasureTheory

variable [OpensMeasurableSpace X] {A K : Set X}

section Mul

variable [NormedRing R] [SecondCountableTopologyEither X R] {g g' : X ‚Üí R}

theorem IntegrableOn.mul_continuousOn_of_subset (hg : IntegrableOn g A Œº) (hg' : ContinuousOn g' K)
    (hA : MeasurableSet A) (hK : IsCompact K) (hAK : A ‚äÜ K) :
    IntegrableOn (fun x => g x * g' x) A Œº := by
  rcases IsCompact.exists_bound_of_continuousOn hK hg' with ‚ü®C, hC‚ü©
  rw [IntegrableOn, ‚Üê mem‚Ñíp_one_iff_integrable] at hg‚ä¢
  have : ‚àÄ·µê x ‚àÇŒº.restrict A, ‚Äñg x * g' x‚Äñ ‚â§ C * ‚Äñg x‚Äñ := by
    filter_upwards [ae_restrict_mem hA]with x hx
    refine' (norm_mul_le _ _).trans _
    rw [mul_comm]
    apply mul_le_mul_of_nonneg_right (hC x (hAK hx)) (norm_nonneg _)
  exact
    Mem‚Ñíp.of_le_mul hg (hg.aestronglyMeasurable.mul <| (hg'.mono hAK).aestronglyMeasurable hA) this
#align measure_theory.integrable_on.mul_continuous_on_of_subset MeasureTheory.IntegrableOn.mul_continuousOn_of_subset

theorem IntegrableOn.mul_continuousOn [T2Space X] (hg : IntegrableOn g K Œº)
    (hg' : ContinuousOn g' K) (hK : IsCompact K) : IntegrableOn (fun x => g x * g' x) K Œº :=
  hg.mul_continuousOn_of_subset hg' hK.measurableSet hK (Subset.refl _)
#align measure_theory.integrable_on.mul_continuous_on MeasureTheory.IntegrableOn.mul_continuousOn

theorem IntegrableOn.continuousOn_mul_of_subset (hg : ContinuousOn g K) (hg' : IntegrableOn g' A Œº)
    (hK : IsCompact K) (hA : MeasurableSet A) (hAK : A ‚äÜ K) :
    IntegrableOn (fun x => g x * g' x) A Œº := by
  rcases IsCompact.exists_bound_of_continuousOn hK hg with ‚ü®C, hC‚ü©
  rw [IntegrableOn, ‚Üê mem‚Ñíp_one_iff_integrable] at hg'‚ä¢
  have : ‚àÄ·µê x ‚àÇŒº.restrict A, ‚Äñg x * g' x‚Äñ ‚â§ C * ‚Äñg' x‚Äñ := by
    filter_upwards [ae_restrict_mem hA]with x hx
    refine' (norm_mul_le _ _).trans _
    apply mul_le_mul_of_nonneg_right (hC x (hAK hx)) (norm_nonneg _)
  exact
    Mem‚Ñíp.of_le_mul hg' (((hg.mono hAK).aestronglyMeasurable hA).mul hg'.aestronglyMeasurable) this
#align measure_theory.integrable_on.continuous_on_mul_of_subset MeasureTheory.IntegrableOn.continuousOn_mul_of_subset

theorem IntegrableOn.continuousOn_mul [T2Space X] (hg : ContinuousOn g K)
    (hg' : IntegrableOn g' K Œº) (hK : IsCompact K) : IntegrableOn (fun x => g x * g' x) K Œº :=
  hg'.continuousOn_mul_of_subset hg hK hK.measurableSet Subset.rfl
#align measure_theory.integrable_on.continuous_on_mul MeasureTheory.IntegrableOn.continuousOn_mul

end Mul

section Smul

variable {ùïú : Type _} [NormedField ùïú] [NormedSpace ùïú E]

theorem IntegrableOn.continuousOn_smul [T2Space X] [SecondCountableTopologyEither X ùïú] {g : X ‚Üí E}
    (hg : IntegrableOn g K Œº) {f : X ‚Üí ùïú} (hf : ContinuousOn f K) (hK : IsCompact K) :
    IntegrableOn (fun x => f x ‚Ä¢ g x) K Œº := by
  rw [IntegrableOn, ‚Üê integrable_norm_iff]
  ¬∑ simp_rw [norm_smul]
    refine' IntegrableOn.continuousOn_mul _ hg.norm hK
    exact continuous_norm.comp_continuousOn hf
  ¬∑ exact (hf.aestronglyMeasurable hK.measurableSet).smul hg.1
#align measure_theory.integrable_on.continuous_on_smul MeasureTheory.IntegrableOn.continuousOn_smul

theorem IntegrableOn.smul_continuousOn [T2Space X] [SecondCountableTopologyEither X E] {f : X ‚Üí ùïú}
    (hf : IntegrableOn f K Œº) {g : X ‚Üí E} (hg : ContinuousOn g K) (hK : IsCompact K) :
    IntegrableOn (fun x => f x ‚Ä¢ g x) K Œº := by
  rw [IntegrableOn, ‚Üê integrable_norm_iff]
  ¬∑ simp_rw [norm_smul]
    refine' IntegrableOn.mul_continuousOn hf.norm _ hK
    exact continuous_norm.comp_continuousOn hg
  ¬∑ exact hf.1.smul (hg.aestronglyMeasurable hK.measurableSet)
#align measure_theory.integrable_on.smul_continuous_on MeasureTheory.IntegrableOn.smul_continuousOn

end Smul

namespace LocallyIntegrableOn

theorem continuousOn_mul [LocallyCompactSpace X] [T2Space X] [NormedRing R]
    [SecondCountableTopologyEither X R] {f g : X ‚Üí R} {s : Set X} (hf : LocallyIntegrableOn f s Œº)
    (hg : ContinuousOn g s) (hs : IsOpen s) : LocallyIntegrableOn (fun x => g x * f x) s Œº := by
  rw [MeasureTheory.locallyIntegrableOn_iff (Or.inr hs)] at hf‚ä¢
  exact fun k hk_sub hk_c => (hf k hk_sub hk_c).continuousOn_mul (hg.mono hk_sub) hk_c
#align measure_theory.locally_integrable_on.continuous_on_mul MeasureTheory.LocallyIntegrableOn.continuousOn_mul

theorem mul_continuousOn [LocallyCompactSpace X] [T2Space X] [NormedRing R]
    [SecondCountableTopologyEither X R] {f g : X ‚Üí R} {s : Set X} (hf : LocallyIntegrableOn f s Œº)
    (hg : ContinuousOn g s) (hs : IsOpen s) : LocallyIntegrableOn (fun x => f x * g x) s Œº := by
  rw [MeasureTheory.locallyIntegrableOn_iff (Or.inr hs)] at hf‚ä¢
  exact fun k hk_sub hk_c => (hf k hk_sub hk_c).mul_continuousOn (hg.mono hk_sub) hk_c
#align measure_theory.locally_integrable_on.mul_continuous_on MeasureTheory.LocallyIntegrableOn.mul_continuousOn

theorem continuousOn_smul [LocallyCompactSpace X] [T2Space X] {ùïú : Type _} [NormedField ùïú]
    [SecondCountableTopologyEither X ùïú] [NormedSpace ùïú E] {f : X ‚Üí E} {g : X ‚Üí ùïú} {s : Set X}
    (hs : IsOpen s) (hf : LocallyIntegrableOn f s Œº) (hg : ContinuousOn g s) :
    LocallyIntegrableOn (fun x => g x ‚Ä¢ f x) s Œº := by
  rw [MeasureTheory.locallyIntegrableOn_iff (Or.inr hs)] at hf‚ä¢
  exact fun k hk_sub hk_c => (hf k hk_sub hk_c).continuousOn_smul (hg.mono hk_sub) hk_c
#align measure_theory.locally_integrable_on.continuous_on_smul MeasureTheory.LocallyIntegrableOn.continuousOn_smul

theorem smul_continuousOn [LocallyCompactSpace X] [T2Space X] {ùïú : Type _} [NormedField ùïú]
    [SecondCountableTopologyEither X E] [NormedSpace ùïú E] {f : X ‚Üí ùïú} {g : X ‚Üí E} {s : Set X}
    (hs : IsOpen s) (hf : LocallyIntegrableOn f s Œº) (hg : ContinuousOn g s) :
    LocallyIntegrableOn (fun x => f x ‚Ä¢ g x) s Œº := by
  rw [MeasureTheory.locallyIntegrableOn_iff (Or.inr hs)] at hf‚ä¢
  exact fun k hk_sub hk_c => (hf k hk_sub hk_c).smul_continuousOn (hg.mono hk_sub) hk_c
#align measure_theory.locally_integrable_on.smul_continuous_on MeasureTheory.LocallyIntegrableOn.smul_continuousOn

end LocallyIntegrableOn

end MeasureTheory
