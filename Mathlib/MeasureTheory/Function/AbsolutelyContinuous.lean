/-
Copyright (c) 2025 Yizheng Zhu. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yizheng Zhu
-/
<<<<<<< HEAD
=======
import Mathlib.Algebra.BigOperators.Group.Finset.Basic
import Mathlib.Algebra.BigOperators.Group.Finset.Defs
import Mathlib.Algebra.BigOperators.Ring.Finset
>>>>>>> db03350a7c (absolutely continuous functions)
import Mathlib.Analysis.Normed.Group.Bounded
import Mathlib.Analysis.Normed.Group.Uniform
import Mathlib.Analysis.Normed.MulAction
import Mathlib.Order.SuccPred.IntervalSucc
import Mathlib.Topology.EMetricSpace.BoundedVariation
<<<<<<< HEAD
=======
import Mathlib.Topology.EMetricSpace.Lipschitz
import Mathlib.Topology.MetricSpace.Pseudo.Defs
>>>>>>> db03350a7c (absolutely continuous functions)

/-!
# Absolutely Continuous Functions

This file defines absolutely continuous functions on a closed interval `uIcc a b` and proves some
basic properties about absolutely continuous functions.

<<<<<<< HEAD
A function `f` is *absolutely continuous* on `uIcc a b` if for any `Œµ > 0`, there is `Œ¥ > 0` such
that for any finite disjoint collection of intervals `uIoc (a i) (b i)` for `i < n` where `a i`,
`b i` are all in `uIcc a b` for `i < n`,  if `‚àë i ‚àà range n, dist (a i) (b i) < Œ¥`, then
`‚àë i ‚àà range n, dist (f (a i)) (f (b i)) < Œµ`.

We give a filter version of the definition of absolutely continuous functions in
`AbsolutelyContinuousOnInterval` based on `AbsolutelyContinuousOnInterval.totalLengthFilter`
and `AbsolutelyContinuousOnInterval.disjWithin` and prove its equivalence with the `Œµ`-`Œ¥`
definition in `absolutelyContinuousOnInterval_iff`.

We use the filter version to prove that absolutely continuous functions are closed under
* addition - `AbsolutelyContinuousOnInterval.fun_add`, `AbsolutelyContinuousOnInterval.add`;
* negation - `AbsolutelyContinuousOnInterval.fun_neg`, `AbsolutelyContinuousOnInterval.neg`;
* subtraction - `AbsolutelyContinuousOnInterval.fun_sub`, `AbsolutelyContinuousOnInterval.sub`;
* scalar multiplication - `AbsolutelyContinuousOnInterval.const_smul`,
`AbsolutelyContinuousOnInterval.const_mul`;
* multiplication - `AbsolutelyContinuousOnInterval.fun_smul`, `AbsolutelyContinuousOnInterval.smul`,
`AbsolutelyContinuousOnInterval.fun_mul`, `AbsolutelyContinuousOnInterval.mul`;
and that absolutely continuous implies uniform continuous in
`AbsolutelyContinuousOnInterval.uniformlyContinuousOn`

We use the the `Œµ`-`Œ¥` definition to prove that
* Lipschitz continuous functions are absolutely continuous -
`LipschitzOnWith.absolutelyContinuousOnInterval`;
* absolutely continuous functions have bounded variation -
`AbsolutelyContinuousOnInterval.boundedVariationOn`.

=======
>>>>>>> db03350a7c (absolutely continuous functions)
## Tags
absolutely continuous
-/

<<<<<<< HEAD
variable {X F : Type*} [PseudoMetricSpace X] [SeminormedAddCommGroup F]

open Set Filter Function

open scoped Topology NNReal
=======
open Set Filter Function

open scoped Topology

lemma Monotone.sum_range_sub {u : ‚Ñï ‚Üí ‚Ñù} (hu : Monotone u) (n : ‚Ñï) :
    ‚àë i ‚àà Finset.range n, dist (u i) (u (i + 1)) = u n - u 0 := by
  rw [‚Üê Finset.sum_range_sub]
  congr; ext i
  rw [dist_comm, Real.dist_eq, abs_eq_self.mpr]
  linarith [@hu i (i + 1) (by omega)]
>>>>>>> db03350a7c (absolutely continuous functions)

namespace AbsolutelyContinuousOnInterval

/-- The filter on the collection of all the finite sequences of `uIoc` intervals induced by the
<<<<<<< HEAD
function that maps the finite sequence of the intervals to the total length of the intervals.
Details:
1. Technically the filter is on `‚Ñï √ó (‚Ñï ‚Üí X √ó X)`. A finite sequence `uIoc (a i) (b i)`, `i < n`
is represented by any `E : ‚Ñï √ó (‚Ñï ‚Üí X √ó X)` which satisfies `E.1 = n` and `E.2 i = (a i, b i)` for
`i < n`. Its total length is `‚àë i ‚àà Finset.range n, dist (a i) (b i)`.
2. For a sequence `G : ‚Ñï ‚Üí ‚Ñï √ó (‚Ñï ‚Üí X √ó X)`, `G` convergence along `totalLengthFilter` means that
the total length of `G j`, i.e., `‚àë i ‚àà Finset.range (G j).1, dist ((G j).2 i).1 ((G j).2 i).2)`,
tends to `0` as `j` tends to infinity.
-/
def totalLengthFilter : Filter (‚Ñï √ó (‚Ñï ‚Üí X √ó X)) := Filter.comap
  (fun E ‚Ü¶ ‚àë i ‚àà Finset.range E.1, dist (E.2 i).1 (E.2 i).2) (ùìù 0)

lemma hasBasis_totalLengthFilter : totalLengthFilter.HasBasis (fun (Œµ : ‚Ñù) => 0 < Œµ)
    (fun (Œµ : ‚Ñù) =>
      {E : ‚Ñï √ó (‚Ñï ‚Üí X √ó X) | ‚àë i ‚àà Finset.range E.1, dist (E.2 i).1 (E.2 i).2 < Œµ}) := by
  convert Filter.HasBasis.comap (Œ± := ‚Ñù) _ (nhds_basis_Ioo_pos _) using 1
  ext Œµ E
  simp only [mem_setOf_eq, zero_sub, zero_add, mem_preimage, mem_Ioo, iff_and_self]
  suffices 0 ‚â§ ‚àë i ‚àà Finset.range E.1, dist (E.2 i).1 (E.2 i).2 by grind
  exact Finset.sum_nonneg (fun _ _ ‚Ü¶ dist_nonneg)

/-- The subcollection of all the finite sequences of `uIoc` intervals consisting of
`uIoc (a i) (b i)`, `i < n` where `a i`, `b i` are all in `uIcc a b` for `i < n` and
`uIoc (a i) (b i)` are mutually disjoint for `i < n`. Technically the finite sequence
`uIoc (a i) (b i)`, `i < n` is represented by any `E : ‚Ñï √ó (‚Ñï ‚Üí ‚Ñù √ó ‚Ñù)` which satisfies
`E.1 = n` and `E.2 i = (a i, b i)` for `i < n`. -/
def disjWithin (a b : ‚Ñù) := {E : ‚Ñï √ó (‚Ñï ‚Üí ‚Ñù √ó ‚Ñù) |
  (‚àÄ i ‚àà Finset.range E.1, (E.2 i).1 ‚àà uIcc a b ‚àß (E.2 i).2 ‚àà uIcc a b) ‚àß
  Set.PairwiseDisjoint (Finset.range E.1) (fun i ‚Ü¶ uIoc (E.2 i).1 (E.2 i).2)}

lemma disjWithin_comm (a b : ‚Ñù) : disjWithin a b = disjWithin b a := by
  rw [disjWithin, disjWithin, uIcc_comm]

lemma disjWithin_mono {a b c d : ‚Ñù} (habcd : uIcc c d ‚äÜ uIcc a b) :
    disjWithin c d ‚äÜ disjWithin a b := by
  simp +contextual only [disjWithin, Finset.mem_range, setOf_subset_setOf, and_true,
    and_imp, Prod.forall]
  exact fun (n I h _ i hi) ‚Ü¶ ‚ü®habcd (h i hi).left, habcd (h i hi).right‚ü©

/-- `AbsolutelyContinuousOnInterval f a b`: A function `f` is *absolutely continuous* on `uIcc a b`
if the function which (intuitively) maps `uIoc (a i) (b i)`, `i < n` to
`‚àë i ‚àà Finset.range n, dist (f (a i)) (f (b i))` tendsto `ùìù 0` wrt `totalLengthFilter` restricted
to `disjWithin a b`. This is equivalent to the traditional `Œµ`-`Œ¥` definition: for any `Œµ > 0`,
there is `Œ¥ > 0` such that for any finite disjoint collection of intervals `uIoc (a i) (b i)` for
`i < n` where `a i`, `b i` are all in `uIcc a b` for `i < n`, if
`‚àë i ‚àà range n, dist (a i) (b i) < Œ¥`, then `‚àë i ‚àà range n, dist (f (a i)) (f (b i)) < Œµ`. -/
def _root_.AbsolutelyContinuousOnInterval (f : ‚Ñù ‚Üí X) (a b : ‚Ñù) :=
  Tendsto (fun E ‚Ü¶ ‚àë i ‚àà Finset.range E.1, dist (f (E.2 i).1) (f (E.2 i).2))
    (totalLengthFilter ‚äì ùìü (disjWithin a b)) (ùìù 0)

/-- The traditional `Œµ`-`Œ¥` definition of absolutely continuous: A function `f` is
*absolutely continuous* on `uIcc a b` if for any `Œµ > 0`, there is `Œ¥ > 0` such that for
any finite disjoint collection of intervals `uIoc (a i) (b i)` for `i < n` where `a i`, `b i` are
all in `uIcc a b` for `i < n`,  if `‚àë i ‚àà range n, dist (a i) (b i) < Œ¥`, then
`‚àë i ‚àà range n, dist (f (a i)) (f (b i)) < Œµ`. -/
theorem _root_.absolutelyContinuousOnInterval_iff (f : ‚Ñù ‚Üí X) (a b : ‚Ñù) :
    AbsolutelyContinuousOnInterval f a b ‚Üî
    ‚àÄ Œµ > (0 : ‚Ñù), ‚àÉ Œ¥ > (0 : ‚Ñù), ‚àÄ E, E ‚àà disjWithin a b ‚Üí
    ‚àë i ‚àà Finset.range E.1, dist (E.2 i).1 (E.2 i).2 < Œ¥ ‚Üí
    ‚àë i ‚àà Finset.range E.1, dist (f (E.2 i).1) (f (E.2 i).2) < Œµ := by
  simp [AbsolutelyContinuousOnInterval, Metric.tendsto_nhds,
    Filter.HasBasis.eventually_iff (hasBasis_totalLengthFilter.inf_principal _),
    imp.swap, abs_of_nonneg (Finset.sum_nonneg (fun _ _ ‚Ü¶ dist_nonneg))]

variable {f g : ‚Ñù ‚Üí X} {a b c d : ‚Ñù}

theorem symm (hf : AbsolutelyContinuousOnInterval f a b) :
    AbsolutelyContinuousOnInterval f b a := by
  simp_all [AbsolutelyContinuousOnInterval, disjWithin_comm]

theorem mono (hf : AbsolutelyContinuousOnInterval f a b) (habcd : uIcc c d ‚äÜ uIcc a b) :
    AbsolutelyContinuousOnInterval f c d := by
  simp only [AbsolutelyContinuousOnInterval, Tendsto] at *
  refine le_trans (Filter.map_mono ?_) hf
  gcongr; exact disjWithin_mono habcd

variable {f g : ‚Ñù ‚Üí F}

theorem fun_add (hf : AbsolutelyContinuousOnInterval f a b)
    (hg : AbsolutelyContinuousOnInterval g a b) :
    AbsolutelyContinuousOnInterval (fun x ‚Ü¶ f x + g x) a b := by
  apply squeeze_zero (fun t ‚Ü¶ ?_) (fun t ‚Ü¶ ?_) (by simpa using hf.add hg)
  ¬∑ exact Finset.sum_nonneg (fun i hi ‚Ü¶ by positivity)
  ¬∑ rw [‚Üê Finset.sum_add_distrib]
    gcongr
    exact dist_add_add_le _ _ _ _

theorem add (hf : AbsolutelyContinuousOnInterval f a b)
    (hg : AbsolutelyContinuousOnInterval g a b) :
    AbsolutelyContinuousOnInterval (f + g) a b :=
  hf.fun_add hg

theorem fun_neg (hf : AbsolutelyContinuousOnInterval f a b) :
    AbsolutelyContinuousOnInterval (fun x ‚Ü¶ -(f x)) a b := by
  apply squeeze_zero (fun t ‚Ü¶ ?_) (fun t ‚Ü¶ ?_) (by simpa using hf)
  ¬∑ exact Finset.sum_nonneg (fun i hi ‚Ü¶ by positivity)
  ¬∑ simp

theorem neg (hf : AbsolutelyContinuousOnInterval f a b) :
    AbsolutelyContinuousOnInterval (-f) a b :=
  hf.fun_neg

theorem fun_sub (hf : AbsolutelyContinuousOnInterval f a b)
    (hg : AbsolutelyContinuousOnInterval g a b) :
    AbsolutelyContinuousOnInterval (fun x ‚Ü¶ f x - g x) a b := by
  simp_rw [fun x ‚Ü¶ show f x - g x = f x + (-(g x)) by abel]
  exact hf.fun_add (hg.fun_neg)

theorem sub (hf : AbsolutelyContinuousOnInterval f a b)
    (hg : AbsolutelyContinuousOnInterval g a b) :
    AbsolutelyContinuousOnInterval (f - g) a b :=
  hf.fun_sub hg

theorem const_smul {M : Type*} [SeminormedRing M] [Module M F] [NormSMulClass M F]
    (Œ± : M) (hf : AbsolutelyContinuousOnInterval f a b) :
    AbsolutelyContinuousOnInterval (fun x ‚Ü¶ Œ± ‚Ä¢ f x) a b := by
  apply squeeze_zero (fun t ‚Ü¶ ?_) (fun t ‚Ü¶ ?_) (by simpa using hf.const_mul ‚ÄñŒ±‚Äñ)
  ¬∑ exact Finset.sum_nonneg (fun i hi ‚Ü¶ by positivity)
  ¬∑ rw [Finset.mul_sum]
    gcongr
    simp only [dist_smul‚ÇÄ]
    rfl

theorem const_mul {f : ‚Ñù ‚Üí ‚Ñù} (Œ± : ‚Ñù) (hf : AbsolutelyContinuousOnInterval f a b) :
    AbsolutelyContinuousOnInterval (fun x ‚Ü¶ Œ± * f x) a b :=
  hf.const_smul Œ±

lemma uniformity_eq_comap_totalLengthFilter :
    uniformity X = comap (fun x ‚Ü¶ (1, fun _ ‚Ü¶ x)) totalLengthFilter := by
  refine Filter.HasBasis.eq_of_same_basis Metric.uniformity_basis_dist ?_
  convert hasBasis_totalLengthFilter.comap _
  simp

/-- If `f` is absolutely continuous on `uIcc a b`, then `f` is uniformly continuous on `uIcc a b`.
-/
theorem uniformlyContinuousOn (hf : AbsolutelyContinuousOnInterval f a b) :
    UniformContinuousOn f (uIcc a b) := by
  simp only [UniformContinuousOn, Filter.tendsto_iff_comap, uniformity_eq_comap_totalLengthFilter]
  simp only [AbsolutelyContinuousOnInterval, Filter.tendsto_iff_comap] at hf
  convert Filter.comap_mono hf
  ¬∑ simp only [comap_inf, comap_principal]
    congr
    ext p
    simp only [disjWithin, Finset.mem_range, preimage_setOf_eq, Nat.lt_one_iff,
      forall_eq, mem_setOf_eq, mem_prod]
    simp
  ¬∑ simp only [totalLengthFilter, comap_comap]
    congr 1

/-- If `f` is absolutely continuous on `uIcc a b`, then `f` is continuous on `uIcc a b`. -/
theorem continuousOn (hf : AbsolutelyContinuousOnInterval f a b) :
=======
function that the finite sequence of the intervals to the total length of the intervals -/
def TotalLengthFilter : Filter (‚Ñï √ó (‚Ñï ‚Üí ‚Ñù √ó ‚Ñù)) := Filter.comap
  (fun E ‚Ü¶ ‚àë i ‚àà Finset.range E.1, dist (E.2 i).1 (E.2 i).2) (ùìù[‚â•] 0)

lemma TotalLengthFilter_hasBasis : TotalLengthFilter.HasBasis
    (fun (Œµ : ‚Ñù) => 0 < Œµ)
    (fun (Œµ : ‚Ñù) => {E | ‚àë i ‚àà Finset.range E.1, dist (E.2 i).1 (E.2 i).2 < Œµ}) := by
  convert Filter.HasBasis.comap _ (nhdsGE_basis _) <;> try infer_instance
  ext E
  simp only [mem_setOf_eq, mem_preimage, mem_Ico, iff_and_self]
  exact fun _ ‚Ü¶ Finset.sum_nonneg (fun _ _ ‚Ü¶ dist_nonneg)

/-- The subcollection of all the finite sequences of `uIoc` intervals, requiring that every
interval must have endpoints in `uIcc a b` and they are mutually disjoint -/
def DisjEnds (a b : ‚Ñù) := {E : ‚Ñï √ó (‚Ñï ‚Üí ‚Ñù √ó ‚Ñù) |
  (‚àÄ i ‚àà Finset.range E.1, (E.2 i).1 ‚àà uIcc a b ‚àß (E.2 i).2 ‚àà uIcc a b) ‚àß
  Set.PairwiseDisjoint (Finset.range E.1) (fun i ‚Ü¶ uIoc (E.2 i).1 (E.2 i).2)}

lemma DisjEnds_comm (a b : ‚Ñù) : DisjEnds a b = DisjEnds b a := by rw [DisjEnds, DisjEnds, uIcc_comm]

lemma DisjEnds_mono {a b c d : ‚Ñù} (habcd : uIcc c d ‚äÜ uIcc a b) : DisjEnds c d ‚äÜ DisjEnds a b := by
  simp +contextual only [DisjEnds, Finset.mem_range, setOf_subset_setOf, and_true,
    and_imp, Prod.forall]
  exact fun (n I h1 h2 i hi) ‚Ü¶ ‚ü®habcd (h1 i hi).left, habcd (h1 i hi).right‚ü©

end AbsolutelyContinuousOnInterval

/-- `AbsolutelyContinuousOnInterval f a b`: A function `f` is *absolutely continuous* on `uIcc a b`
if the function which applis `f` to every endpoint of the finite sequences of `uIoc` intervals
tendsto `TotalLengthFilter` wrt `TotalLengthFilter` restricted to `DisjEnds a b`. -/
def AbsolutelyContinuousOnInterval (f : ‚Ñù ‚Üí ‚Ñù) (a b : ‚Ñù) :=
  open AbsolutelyContinuousOnInterval in
  Tendsto (fun E ‚Ü¶ (E.1, fun i ‚Ü¶ ((f (E.2 i).1, f (E.2 i).2))))
    (TotalLengthFilter ‚äì ùìü (DisjEnds a b)) TotalLengthFilter

/-- The traditional `Œµ`-`Œ¥` definition of absolutely continuous; A function `f` is
*absolutely continuous* on `uIcc a b` if for any `Œµ > 0`, there is `Œ¥ > 0` such that for any finite
 disjoint collection of intervals `(x i, y i]` for `i < n`, all contained in `uIcc a b`,
 if `‚àë i ‚àà range n, y i - x i < Œ¥`, then `‚àë i ‚àà range n, |f (y i) - f (x i)| < Œµ`.
-/
theorem absolutelyContinuousOnInterval_iff (f : ‚Ñù ‚Üí ‚Ñù) (a b : ‚Ñù) :
    open AbsolutelyContinuousOnInterval in
    AbsolutelyContinuousOnInterval f a b ‚Üî
    ‚àÄ Œµ > (0 : ‚Ñù), ‚àÉ Œ¥ > (0 : ‚Ñù), ‚àÄ E, E ‚àà DisjEnds a b ‚Üí
    ‚àë i ‚àà Finset.range E.1, dist (E.2 i).1 (E.2 i).2 < Œ¥ ‚Üí
    ‚àë i ‚àà Finset.range E.1, dist (f (E.2 i).1) (f (E.2 i).2) < Œµ := by
  open AbsolutelyContinuousOnInterval in
  simp only [AbsolutelyContinuousOnInterval]
  rw [Filter.HasBasis.tendsto_iff (TotalLengthFilter_hasBasis.inf_principal _)
        TotalLengthFilter_hasBasis]
  simp +contextual [imp.swap]
namespace AbsolutelyContinuousOnInterval

theorem symm {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} (hf : AbsolutelyContinuousOnInterval f a b) :
    AbsolutelyContinuousOnInterval f b a := by
  simp only [AbsolutelyContinuousOnInterval] at *
  rwa [DisjEnds_comm]

theorem mono {f : ‚Ñù ‚Üí ‚Ñù} {a b c d : ‚Ñù} (hf : AbsolutelyContinuousOnInterval f a b)
    (habcd : uIcc c d ‚äÜ uIcc a b) :
    AbsolutelyContinuousOnInterval f c d := by
  simp only [AbsolutelyContinuousOnInterval, Tendsto] at *
  refine le_trans ?_ hf
  apply Filter.map_mono
  gcongr; exact DisjEnds_mono habcd

theorem add {f g : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù}
    (hf : AbsolutelyContinuousOnInterval f a b) (hg : AbsolutelyContinuousOnInterval g a b) :
    AbsolutelyContinuousOnInterval (fun x ‚Ü¶ f x + g x) a b := by
  simp only [AbsolutelyContinuousOnInterval, Filter.tendsto_iff_comap] at *
  refine le_trans (le_inf hf hg) ?_
  rw [Filter.HasBasis.le_basis_iff
      ( (Filter.HasBasis.comap _ TotalLengthFilter_hasBasis).inf
        (Filter.HasBasis.comap _ TotalLengthFilter_hasBasis))
      (Filter.HasBasis.comap _ TotalLengthFilter_hasBasis)]
  intro Œµ hŒµ
  refine ‚ü®(Œµ / 2, Œµ / 2), by simpa, ?_‚ü©
  simp only [preimage_setOf_eq]
  intro E hE
  simp only [mem_inter_iff, mem_setOf_eq] at hE ‚ä¢
  calc
    _ ‚â§ ‚àë x ‚àà Finset.range E.1, (dist (f (E.2 x).1) (f (E.2 x).2) +
        dist (g (E.2 x).1) (g (E.2 x).2)) := by
      gcongr; exact dist_add_add_le _ _ _ _
    _ = (‚àë x ‚àà Finset.range E.1, dist (f (E.2 x).1) (f (E.2 x).2)) +
        (‚àë x ‚àà Finset.range E.1, dist (g (E.2 x).1) (g (E.2 x).2)) := by
      apply Finset.sum_add_distrib
    _ < Œµ / 2 + Œµ / 2 := by gcongr <;> tauto
    _ = Œµ := by simp

theorem const_mul {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} (hf : AbsolutelyContinuousOnInterval f a b) (Œ± : ‚Ñù) :
    AbsolutelyContinuousOnInterval (fun x ‚Ü¶ Œ± * f x) a b := by
  simp only [AbsolutelyContinuousOnInterval, Filter.tendsto_iff_comap] at *
  refine le_trans hf ?_
  rw [Filter.HasBasis.le_basis_iff
      (Filter.HasBasis.comap _ TotalLengthFilter_hasBasis)
      (Filter.HasBasis.comap _ TotalLengthFilter_hasBasis)]
  intro Œµ hŒµ
  have : |Œ±| ‚â• 0 := by simp
  refine ‚ü®Œµ / (|Œ±| + 1) , by positivity, ?_‚ü©
  simp only [preimage_setOf_eq]
  intro E hE
  simp only [mem_setOf_eq] at hE ‚ä¢
  calc
    _ = ‚àë x ‚àà Finset.range E.1, |Œ±| * dist (f (E.2 x).1) (f (E.2 x).2) := by
      congr; simp_rw [‚Üê smul_eq_mul, dist_smul‚ÇÄ]; rfl
    _ = |Œ±| * ‚àë x ‚àà Finset.range E.1, dist (f (E.2 x).1) (f (E.2 x).2) := by
      symm; exact Finset.mul_sum _ _ _
    _ ‚â§ |Œ±| * (Œµ / (|Œ±| + 1)) := by gcongr
    _ < (|Œ±| + 1) * (Œµ / (|Œ±| + 1)) := by gcongr; linarith
    _ = Œµ := by field_simp

theorem neg {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} (hf : AbsolutelyContinuousOnInterval f a b) :
    AbsolutelyContinuousOnInterval (fun x ‚Ü¶ -(f x) ) a b := by
  convert hf.const_mul (-1) using 1; simp

theorem sub {f g : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù}
    (hf : AbsolutelyContinuousOnInterval f a b) (hg : AbsolutelyContinuousOnInterval g a b) :
    AbsolutelyContinuousOnInterval (fun x ‚Ü¶ f x - g x) a b := by
  simp_rw [fun x ‚Ü¶ show f x - g x = f x + (-(g x)) by abel]
  exact hf.add (hg.neg)

/-- If `f` is absolutely continuous on `uIcc a b`, then `f` is uniformly continuous on `uIcc a b`.
-/
theorem uniformlyContinuousOn {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} (hf : AbsolutelyContinuousOnInterval f a b) :
    UniformContinuousOn f (uIcc a b) := by
  simp only [UniformContinuousOn]
  simp only [AbsolutelyContinuousOnInterval] at hf
  rw [Filter.tendsto_iff_comap] at hf ‚ä¢
  let J (x : ‚Ñù √ó ‚Ñù) : (‚Ñï √ó (‚Ñï ‚Üí ‚Ñù √ó ‚Ñù)) := (1, fun _ ‚Ü¶ x)
  have : uniformity ‚Ñù = comap J TotalLengthFilter := by
    refine Filter.HasBasis.eq_of_same_basis Metric.uniformity_basis_dist ?_
    convert TotalLengthFilter_hasBasis.comap J
    ext p; simp [J]
  rw [this]
  convert Filter.comap_mono (m := J) hf
  ¬∑ simp only [comap_inf, comap_principal, J]
    congr
    ext p
    simp only [DisjEnds, Finset.mem_range, preimage_setOf_eq, Nat.lt_one_iff,
      forall_eq, mem_setOf_eq]
    exact ‚ü®fun hp ‚Ü¶ ‚ü®hp, by simp [PairwiseDisjoint, Set.Pairwise]‚ü©, fun hp ‚Ü¶ hp.left‚ü©
  ¬∑ rw [comap_comap, comap_comap]
    congr 1

/-- If `f` is absolutely continuous on `uIcc a b`, then `f` is continuous on `uIcc a b`. -/
theorem continuousOn {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} (hf : AbsolutelyContinuousOnInterval f a b) :
>>>>>>> db03350a7c (absolutely continuous functions)
    ContinuousOn f (uIcc a b) :=
  hf.uniformlyContinuousOn.continuousOn

/-- If `f` is absolutely continuous on `uIcc a b`, then `f` is bounded on `uIcc a b`. -/
<<<<<<< HEAD
theorem exists_bound (hf : AbsolutelyContinuousOnInterval f a b) :
    ‚àÉ (C : ‚Ñù), ‚àÄ x ‚àà uIcc a b, ‚Äñf x‚Äñ ‚â§ C :=
  isCompact_Icc.exists_bound_of_continuousOn (hf.continuousOn)

/-- If `f` and `g` are absolutely continuous on `uIcc a b`, then `f ‚Ä¢ g` is absolutely continuous
on `uIcc a b`. -/
theorem fun_smul {M : Type*} [SeminormedRing M] [Module M F] [NormSMulClass M F]
    {f : ‚Ñù ‚Üí M} {g : ‚Ñù ‚Üí F}
    (hf : AbsolutelyContinuousOnInterval f a b) (hg : AbsolutelyContinuousOnInterval g a b) :
    AbsolutelyContinuousOnInterval (fun x ‚Ü¶ f x ‚Ä¢ g x) a b := by
  obtain ‚ü®C, hC‚ü© := hf.exists_bound
  obtain ‚ü®D, hD‚ü© := hg.exists_bound
  unfold AbsolutelyContinuousOnInterval at hf hg
  apply squeeze_zero' ?_ ?_
    (by simpa using (hg.const_mul C).add (hf.const_mul D))
  ¬∑ exact Filter.Eventually.of_forall <| fun _ ‚Ü¶ Finset.sum_nonneg (fun i hi ‚Ü¶ by exact dist_nonneg)
  rw [eventually_inf_principal]
  filter_upwards with (n, I) hnI
  simp only [Finset.mul_sum, ‚Üê Finset.sum_add_distrib]
  gcongr with i hi
  trans dist (f (I i).1 ‚Ä¢ g (I i).1) (f (I i).1 ‚Ä¢ g (I i).2) +
    dist (f (I i).1 ‚Ä¢ g (I i).2) (f (I i).2 ‚Ä¢ g (I i).2)
  ¬∑ exact dist_triangle _ _ _
  ¬∑ simp only [disjWithin, mem_setOf_eq] at hnI
    gcongr
    ¬∑ rw [dist_smul‚ÇÄ]
      gcongr
      exact hC _ (hnI.left i hi |>.left)
    ¬∑ rw [mul_comm]
      grw [dist_pair_smul]
      gcongr
      rw [dist_zero_right]
      exact hD _ (hnI.left i hi |>.right)

/-- If `f` and `g` are absolutely continuous on `uIcc a b`, then `f ‚Ä¢ g` is absolutely continuous
on `uIcc a b`. -/
theorem smul {M : Type*} [SeminormedRing M] [Module M F] [NormSMulClass M F]
    {f : ‚Ñù ‚Üí M} {g : ‚Ñù ‚Üí F}
    (hf : AbsolutelyContinuousOnInterval f a b) (hg : AbsolutelyContinuousOnInterval g a b) :
    AbsolutelyContinuousOnInterval (f ‚Ä¢ g) a b :=
  hf.fun_smul hg

/-- If `f` and `g` are absolutely continuous on `uIcc a b`, then `f * g` is absolutely continuous
on `uIcc a b`. -/
theorem fun_mul {f g : ‚Ñù ‚Üí ‚Ñù}
    (hf : AbsolutelyContinuousOnInterval f a b) (hg : AbsolutelyContinuousOnInterval g a b) :
    AbsolutelyContinuousOnInterval (fun x ‚Ü¶ f x * g x) a b :=
  hf.fun_smul hg

/-- If `f` and `g` are absolutely continuous on `uIcc a b`, then `f * g` is absolutely continuous
on `uIcc a b`. -/
theorem mul {f g : ‚Ñù ‚Üí ‚Ñù}
    (hf : AbsolutelyContinuousOnInterval f a b) (hg : AbsolutelyContinuousOnInterval g a b) :
    AbsolutelyContinuousOnInterval (fun x ‚Ü¶ f x * g x) a b :=
  hf.fun_mul hg

/-- If `f` is Lipschitz on `uIcc a b`, then `f` is absolutely continuous on `uIcc a b`. -/
theorem _root_.LipschitzOnWith.absolutelyContinuousOnInterval {f : ‚Ñù ‚Üí X} {K : ‚Ñù‚â•0}
    (hfK : LipschitzOnWith K f (uIcc a b)) : AbsolutelyContinuousOnInterval f a b := by
  rw [absolutelyContinuousOnInterval_iff]
  intro Œµ hŒµ
  refine ‚ü®Œµ / (K + 1), by positivity, fun (n, I) hnI‚ÇÅ hnI‚ÇÇ ‚Ü¶ ?_‚ü©
  calc
    _ ‚â§ ‚àë i ‚àà Finset.range n, K * dist (I i).1 (I i).2 := by
      apply Finset.sum_le_sum
      intro i hi
      have := hfK (hnI‚ÇÅ.left i hi).left (hnI‚ÇÅ.left i hi).right
      apply ENNReal.toReal_mono (Ne.symm (not_eq_of_beq_eq_false rfl)) at this
      rwa [ENNReal.toReal_mul, ‚Üê dist_edist, ‚Üê dist_edist] at this
    _ = K * ‚àë i ‚àà Finset.range n, dist (I i).1 (I i).2 := by symm; exact Finset.mul_sum _ _ _
    _ ‚â§ K * (Œµ / (K + 1)) := by gcongr
    _ < (K + 1) * (Œµ / (K + 1)) := by gcongr; linarith
    _ = Œµ := by field_simp

/-- If `f` is absolutely continuous on `uIcc a b`, then `f` has bounded variation on `uIcc a b`. -/
theorem boundedVariationOn (hf : AbsolutelyContinuousOnInterval f a b) :
    BoundedVariationOn f (uIcc a b) := by
  -- We may assume wlog that `a ‚â§ b`.
  wlog hab‚ÇÄ : a ‚â§ b generalizing a b
  ¬∑ specialize @this b a hf.symm (by linarith)
    rwa [uIcc_comm]
  rw [uIcc_of_le hab‚ÇÄ]
  -- Split the cases `a = b` (which is trivial) and `a < b`.
  rcases hab‚ÇÄ.eq_or_lt with rfl | hab
  ¬∑ simp [BoundedVariationOn]
  -- Now remains the case `a < b`.
  -- Use the `Œµ`-`Œ¥` definition of AC to get a `Œ¥ > 0` such that whenever a finite set of disjoint
  --   intervals `uIoc (a i) (b i)`, `i < n` have total length `< Œ¥` and `a i, b i` are all in
  --  `[a, b]`, we have `‚àë i ‚àà range n, dist (f (a i)) (f (b i)) < 1`.
  rw [absolutelyContinuousOnInterval_iff] at hf
  obtain ‚ü®Œ¥, hŒ¥‚ÇÅ, hŒ¥‚ÇÇ‚ü© := hf 1 (by linarith)
  have hab‚ÇÅ : 0 < b - a := by linarith
  -- Split `[a, b]` into subintervals `[a + i * Œ¥', a + (i + 1) * Œ¥']` for `i = 0, ..., n`, where
  --   `a + (n + 1) * Œ¥' = b` and `Œ¥' < Œ¥`.
  obtain ‚ü®n, hn‚ü© := exists_nat_one_div_lt (div_pos hŒ¥‚ÇÅ hab‚ÇÅ)
  set Œ¥' := (b - a) / (n + 1)
  have hŒ¥‚ÇÉ : Œ¥' < Œ¥ := by
    dsimp only [Œ¥']
    convert mul_lt_mul_of_pos_right hn hab‚ÇÅ using 1 <;> field_simp
  have h_mono : Monotone fun (i : ‚Ñï) ‚Ü¶ a + ‚Üëi * Œ¥' := by
    apply Monotone.const_add
    apply Monotone.mul_const Nat.mono_cast
    simp only [Œ¥']
    refine div_nonneg ?_ ?_ <;> linarith
  -- The variation of `f` on `[a, b]` is the sum of the variations on these subintervals.
  have v_sum : eVariationOn f (Icc a b) =
      ‚àë i ‚àà Finset.range (n + 1), eVariationOn f (Icc (a + i * Œ¥') (a + (i + 1) * Œ¥')) := by
    convert eVariationOn.sum' f (I := fun i ‚Ü¶ a + i * Œ¥') h_mono |>.symm
    ¬∑ simp
    ¬∑ simp only [Nat.cast_add, Nat.cast_one, Œ¥']; field_simp; abel
    ¬∑ norm_cast
  -- The variation of `f` on any subinterval `[x, y]` of `[a, b]` of length `< Œ¥` is `‚â§ 1`.
  have v_each (x y : ‚Ñù) (_ : a ‚â§ x) (_ : x ‚â§ y) (_ : y < x + Œ¥) (_ : y ‚â§ b) :
      eVariationOn f (Icc x y) ‚â§ 1 := by
    simp only [eVariationOn, iSup_le_iff]
    intro p
    obtain ‚ü®hp‚ÇÅ, hp‚ÇÇ‚ü© := p.2.property
    -- Focus on a partition `p` of `[x, y]` and show its variation with `f` is `‚â§ 1`.
    have vf : ‚àë i ‚àà Finset.range p.1, dist (f (p.2.val i)) (f (p.2.val (i + 1))) < 1 := by
      apply hŒ¥‚ÇÇ (p.1, (fun i ‚Ü¶ (p.2.val i, p.2.val (i + 1))))
      ¬∑ constructor
        ¬∑ have : Icc x y ‚äÜ uIcc a b := by rw [uIcc_of_le hab‚ÇÄ]; gcongr
          intro i hi
          constructor <;> exact this (hp‚ÇÇ _)
        ¬∑ rw [PairwiseDisjoint]
          convert hp‚ÇÅ.pairwise_disjoint_on_Ioc_succ.set_pairwise (Finset.range p.1) using 3
          rw [uIoc_of_le (hp‚ÇÅ (by omega))]
          rfl
      ¬∑ suffices p.2.val p.1 - p.2.val 0 < Œ¥ by
          convert this
          rw [‚Üê Finset.sum_range_sub]
          congr; ext i
          rw [dist_comm, Real.dist_eq, abs_eq_self.mpr]
          linarith [@hp‚ÇÅ i (i + 1) (by omega)]
        linarith [mem_Icc.mp (hp‚ÇÇ p.1), mem_Icc.mp (hp‚ÇÇ 0)]
    -- Reduce edist in the goal to dist and clear up
    have veq: (‚àë i ‚àà Finset.range p.1, edist (f (p.2.val (i + 1))) (f (p.2.val i))).toReal =
        ‚àë i ‚àà Finset.range p.1, dist (f (p.2.val i)) (f (p.2.val (i + 1))) := by
      rw [ENNReal.toReal_sum (by simp [edist_ne_top])]
      simp_rw [‚Üê dist_edist]; congr; ext i; nth_rw 1 [dist_comm]
    have not_top : ‚àë i ‚àà Finset.range p.1, edist (f (p.2.val (i + 1))) (f (p.2.val i)) ‚â† ‚ä§ := by
      simp [edist_ne_top]
    rw [‚Üê ENNReal.ofReal_toReal not_top]
    convert ENNReal.ofReal_le_ofReal (veq.symm ‚ñ∏ vf.le)
    simp
  -- Reduce to goal that the variation of `f` on each of these subintervals is finite.
  simp only [BoundedVariationOn, v_sum, ne_eq, ENNReal.sum_eq_top, Finset.mem_range, not_exists,
    not_and]
  intro i hi
  -- Reduce finiteness to `‚â§ 1`.
  suffices eVariationOn f (Icc (a + i * Œ¥') (a + (i + 1) * Œ¥')) ‚â§ 1 from
    fun hC ‚Ü¶ by simp [hC] at this
  -- Verify that `[a + i * Œ¥', a + (i + 1) * Œ¥']` is indeed a subinterval of `[a, b]`
  apply v_each
  ¬∑ convert h_mono (show 0 ‚â§ i by omega); simp
  ¬∑ convert h_mono (show i ‚â§ i + 1 by omega); norm_cast
  ¬∑ rw [add_mul, ‚Üê add_assoc]; simpa
  ¬∑ convert h_mono (show i + 1 ‚â§ n + 1 by omega)
    ¬∑ norm_cast
    ¬∑ simp only [Nat.cast_add, Nat.cast_one, Œ¥']; field_simp; abel
=======
theorem exists_bound {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} (hf : AbsolutelyContinuousOnInterval f a b) :
    ‚àÉ (C : ‚Ñù), ‚àÄ x ‚àà uIcc a b, |f x| ‚â§ C :=
  isCompact_Icc.exists_bound_of_continuousOn (hf.continuousOn)

/-- If `f` is absolutely continuous on `uIcc a b`, then `f` is bounded on `uIcc a b` by a positive
number. -/
theorem exists_pos_bound {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} (hf : AbsolutelyContinuousOnInterval f a b) :
    ‚àÉ (C : ‚Ñù), C > 0 ‚àß ‚àÄ x ‚àà uIcc a b, |f x| ‚â§ C := by
  obtain ‚ü®C, hC‚ü© := hf.exists_bound
  exact ‚ü®max C 1, by simp, fun x hx ‚Ü¶ by simp [hC x hx]‚ü©

/-- If `f` and `g` are absolutely continuous on `uIcc a b`, then `f * g` is absolutely continuous
on `uIcc a b`. -/
theorem mul {f g : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù}
    (hf : AbsolutelyContinuousOnInterval f a b) (hg : AbsolutelyContinuousOnInterval g a b) :
    AbsolutelyContinuousOnInterval (fun x ‚Ü¶ f x * g x) a b := by
  obtain ‚ü®C, hC1, hC2‚ü© := hf.exists_pos_bound
  obtain ‚ü®D, hD1, hD2‚ü© := hg.exists_pos_bound
  simp only [AbsolutelyContinuousOnInterval, Filter.tendsto_iff_comap] at *
  have h0 : TotalLengthFilter ‚äì ùìü (DisjEnds a b) ‚â§ ùìü (DisjEnds a b) := by exact inf_le_right
  refine le_trans (le_inf (le_inf hf hg) h0) ?_
  rw [Filter.HasBasis.le_basis_iff
      ( ((Filter.HasBasis.comap _ TotalLengthFilter_hasBasis).inf
        (Filter.HasBasis.comap _ TotalLengthFilter_hasBasis)).inf_principal _)
      (Filter.HasBasis.comap _ TotalLengthFilter_hasBasis)]
  intro Œµ hŒµ
  simp only [preimage_setOf_eq]
  refine ‚ü®(Œµ / (C + D), Œµ / (C + D)), (by simp only [and_self]; positivity), ?_‚ü©
  intro (n, I) hnI
  simp only [mem_inter_iff, mem_setOf_eq] at hnI ‚ä¢
  calc
  _ ‚â§ ‚àë i ‚àà Finset.range n, (C * dist (g ((I i).1)) (g ((I i).2)) +
        D * dist (f ((I i).1))  (f ((I i).2))) := by
    gcongr with i hi
    trans dist (f (I i).1 * g (I i).1) (f (I i).1 * g (I i).2) +
      dist (f (I i).1 * g (I i).2) (f (I i).2 * g (I i).2)
    ¬∑ exact dist_triangle _ _ _
    ¬∑ have := hnI.right
      simp only [DisjEnds, mem_setOf_eq] at this
      gcongr
      ¬∑ rw [‚Üê smul_eq_mul, ‚Üê smul_eq_mul, dist_smul‚ÇÄ]
        gcongr
        exact hC2 _ (this.left i hi |>.left)
      ¬∑ rw [mul_comm _ (g (I i).2), mul_comm _ (g (I i).2), ‚Üê smul_eq_mul, ‚Üê smul_eq_mul,
            dist_smul‚ÇÄ]
        gcongr
        exact hD2 _ (this.left i hi |>.right)
  _ = C * ‚àë i ‚àà Finset.range n, dist (g ((I i).1)) (g ((I i).2)) +
      D * ‚àë i ‚àà Finset.range n, dist (f ((I i).1)) (f ((I i).2)) := by
    rw [Finset.sum_add_distrib, Finset.mul_sum, Finset.mul_sum]
  _ < C * (Œµ / (C + D)) + D * (Œµ / (C + D)) := by gcongr <;> tauto
  _ = Œµ := by field_simp

end AbsolutelyContinuousOnInterval

/-- If `f` is Lipschitz on `uIcc a b`, then `f` is absolutely continuous on `uIcc a b`. -/
theorem LipschitzOnWith.absolutelyContinuousOnInterval {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù}
    (hf : ‚àÉ K, LipschitzOnWith K f (uIcc a b)) :
    AbsolutelyContinuousOnInterval f a b := by
  rw [absolutelyContinuousOnInterval_iff]
  intro Œµ hŒµ
  obtain ‚ü®K, hfK‚ü© := hf
  use Œµ / (K + 1)
  refine ‚ü®by positivity, ?_‚ü©
  intro (n, I) hnI1 hnI2
  simp only [AbsolutelyContinuousOnInterval.DisjEnds, mem_setOf_eq] at hnI1
  simp only at hnI2
  simp only [LipschitzOnWith] at hfK
  calc
  _ ‚â§ ‚àë i ‚àà Finset.range n, K * dist (I i).1 (I i).2 := by
    apply Finset.sum_le_sum
    intro i hi
    have := hfK (hnI1.left i hi).left (hnI1.left i hi).right
    apply ENNReal.toReal_mono at this
    ¬∑ rwa [ENNReal.toReal_mul, ‚Üê dist_edist, ‚Üê dist_edist] at this
    ¬∑ exact Ne.symm (not_eq_of_beq_eq_false rfl)
  _ = K * ‚àë i ‚àà Finset.range n, dist (I i).1 (I i).2 := by symm; exact Finset.mul_sum _ _ _
  _ ‚â§ K * (Œµ / (K + 1)) := by gcongr
  _ < (K + 1) * (Œµ / (K + 1)) := by gcongr; linarith
  _ = Œµ := by field_simp

namespace AbsolutelyContinuousOnInterval

/-- If `f` is absolutely continuous on `uIcc a b`, then `f` has bounded variation on `uIcc a b`. -/
theorem boundedVariationOn {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} (hf : AbsolutelyContinuousOnInterval f a b) :
    BoundedVariationOn f (uIcc a b) := by
  wlog hab0 : a ‚â§ b
  ¬∑ specialize @this f b a hf.symm (by linarith)
    rwa [uIcc_comm]
  rw [uIcc_of_le hab0]
  by_cases hab1 : a = b
  ¬∑ rw [show Icc a b = {a} by simp [hab1]]
    simp [BoundedVariationOn]
  ¬∑ have hab : a < b := lt_of_le_of_ne hab0 hab1
    rw [absolutelyContinuousOnInterval_iff] at hf
    obtain ‚ü®Œ¥, hŒ¥1, hŒ¥2‚ü© := hf 1 (by linarith)
    have hab1 : 0 < b - a := by linarith
    obtain ‚ü®n, hn‚ü© := exists_nat_one_div_lt (div_pos hŒ¥1 hab1)
    set Œ¥' := (b - a) / (n + 1)
    have hŒ¥3 : Œ¥' < Œ¥ := by
      dsimp only [Œ¥']
      convert mul_lt_mul_of_pos_right hn hab1 using 1 <;> field_simp
    have h_mono : Monotone fun (i : ‚Ñï) ‚Ü¶ a + ‚Üëi * Œ¥' := by
      apply Monotone.const_add
      apply Monotone.mul_const Nat.mono_cast
      simp only [Œ¥']
      refine div_nonneg ?_ ?_ <;> linarith
    have v_sum: eVariationOn f (Icc a b) =
        ‚àë i ‚àà Finset.range (n + 1), eVariationOn f (Icc (a + i * Œ¥') (a + (i + 1) * Œ¥')) := by
      convert eVariationOn.sum' f (I := fun i ‚Ü¶ a + i * Œ¥') h_mono
      ¬∑ simp
      ¬∑ simp only [Nat.cast_add, Nat.cast_one, Œ¥']; field_simp; abel
      ¬∑ norm_cast
    have v_each (x y : ‚Ñù) (hxy1 : a ‚â§ x) (hxy2 : x ‚â§ y) (hxy3 : y < x + Œ¥) (hxy4 : y ‚â§ b):
        eVariationOn f (Icc x y) ‚â§ 1 := by
      simp only [eVariationOn]
      rw [iSup_le_iff]
      intro p
      obtain ‚ü®hp1, hp2‚ü© := p.2.property
      have vf: ‚àë i ‚àà Finset.range p.1, dist (f (p.2.val i)) (f (p.2.val (i + 1))) ‚â§ 1 := by
        suffices ‚àë i ‚àà Finset.range p.1, dist (f (p.2.val i)) (f (p.2.val (i + 1))) < 1 by
          linarith
        apply hŒ¥2 (p.1, (fun i ‚Ü¶ (p.2.val i, p.2.val (i + 1))))
        ¬∑ simp only [DisjEnds, mem_setOf_eq]
          constructor
          ¬∑ have : Icc x y ‚äÜ uIcc a b := by rw [uIcc_of_le hab0]; gcongr
            intro i hi
            constructor <;> exact this (hp2 _)
          ¬∑ rw [PairwiseDisjoint]
            convert hp1.pairwise_disjoint_on_Ioc_succ.set_pairwise (Finset.range p.1) using 3
            rw [uIoc_of_le (hp1 (by omega))]
            rfl
        ¬∑ simp only
          rw [hp1.sum_range_sub]
          linarith [mem_Icc.mp (hp2 p.1), mem_Icc.mp (hp2 0)]
      have veq: (‚àë i ‚àà Finset.range p.1, edist (f (p.2.val (i + 1))) (f (p.2.val i))).toReal =
          ‚àë i ‚àà Finset.range p.1, dist (f (p.2.val i)) (f (p.2.val (i + 1))) := by
        rw [ENNReal.toReal_sum (by simp [edist_ne_top])]
        simp_rw [‚Üê dist_edist]; congr; ext i; nth_rw 1 [dist_comm]
      have not_top : ‚àë i ‚àà Finset.range p.1, edist (f (p.2.val (i + 1))) (f (p.2.val i)) ‚â† ‚ä§ := by
        simp [edist_ne_top]
      rw [‚Üê ENNReal.ofReal_toReal not_top]
      convert ENNReal.ofReal_le_ofReal (veq.symm ‚ñ∏ vf)
      simp
    unfold BoundedVariationOn
    rw [v_sum]
    simp only [ne_eq, ENNReal.sum_eq_top, Finset.mem_range, not_exists, not_and]
    intro i hi
    suffices eVariationOn f (Icc (a + i * Œ¥') (a + (i + 1) * Œ¥')) ‚â§ 1 by
      intro hC; simp [hC] at this
    apply v_each
    ¬∑ convert h_mono (show 0 ‚â§ i by omega); simp
    ¬∑ convert h_mono (show i ‚â§ i + 1 by omega); norm_cast
    ¬∑ rw [add_mul, ‚Üê add_assoc]; simpa
    ¬∑ convert h_mono (show i + 1 ‚â§ n + 1 by omega)
      ¬∑ norm_cast
      ¬∑ simp only [Nat.cast_add, Nat.cast_one, Œ¥']; field_simp; abel
>>>>>>> db03350a7c (absolutely continuous functions)

end AbsolutelyContinuousOnInterval
