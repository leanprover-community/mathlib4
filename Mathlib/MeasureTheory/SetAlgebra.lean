/-
Copyright (c) 2024 Etienne Marion. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Etienne Marion
-/
import Mathlib.MeasureTheory.SetSemiring

/-!
# Algebra of sets

in this file we define the notion of algebra of sets ang give its basic properties. An algebra
of sets is a family of sets containing the empty set and closed by complement and binary union.
It is therefore similar to a `Ïƒ`-algebra, except that it is not necessarily closed
by countable unions.

We also define the algebra of sets generated by a family of sets ang give its basic properties,
and we prove that it is countable when it is generated by a countable family. We prove that
the `Ïƒ`-algebra generated by a family of sets `ğ’œ` is the same as the one generated by the algebra
of sets generated by `ğ’œ`.

## Main definitions

* `MeasureTheory.IsSetAlgebra`: property of being an algebra of sets.
* `MeasureTheory.generateSetAlgebra`: the algebra of sets generated by a family of sets.

## Main statements

* `MeasureTheory.mem_generateSetAlgebra_elim`: If a set `s` belongs to the algebra of sets
  generated by `ğ’œ`, then it can be written as a finite union of finite intersections of sets which
  are in `ğ’œ` or have their complement in `ğ’œ`.
* `MeasureTheory.countable_generateSetAlgebra`: If a family of sets is countable then so is
  the algebra of sets generated by it.

## References

* <https://en.wikipedia.org/wiki/Field_of_sets>

## Tags

algebra of sets, generated algebra of sets
-/

open MeasurableSpace Set

namespace MeasureTheory

variable {Î± : Type*} {ğ’œ : Set (Set Î±)} {s t : Set Î±}

/-! ### Definition and basic properties of an algebra of sets -/

/-- An algebra of sets is a family of sets containing the empty set and closed by complement and
union. Consequently it is also closed by difference (see `IsSetAlgebra.diff_mem`) and intersection
(see `IsSetAlgebra.inter_mem`). -/
structure IsSetAlgebra (ğ’œ : Set (Set Î±)) : Prop where
  empty_mem : âˆ… âˆˆ ğ’œ
  compl_mem : âˆ€ â¦ƒsâ¦„, s âˆˆ ğ’œ â†’ sá¶œ âˆˆ ğ’œ
  union_mem : âˆ€ â¦ƒs tâ¦„, s âˆˆ ğ’œ â†’ t âˆˆ ğ’œ â†’ s âˆª t âˆˆ ğ’œ

namespace IsSetAlgebra

/-- An algebra of sets contains the whole set. -/
theorem univ_mem (hğ’œ : IsSetAlgebra ğ’œ) : univ âˆˆ ğ’œ :=
  compl_empty â–¸ hğ’œ.compl_mem hğ’œ.empty_mem

/-- An algebra of sets is closed by intersection. -/
theorem inter_mem (hğ’œ : IsSetAlgebra ğ’œ) (s_mem : s âˆˆ ğ’œ) (t_mem : t âˆˆ ğ’œ) :
    s âˆ© t âˆˆ ğ’œ :=
  inter_eq_compl_compl_union_compl .. â–¸
    hğ’œ.compl_mem (hğ’œ.union_mem (hğ’œ.compl_mem s_mem) (hğ’œ.compl_mem t_mem))

/-- An algebra of sets is closed by difference. -/
theorem diff_mem (hğ’œ : IsSetAlgebra ğ’œ) (s_mem : s âˆˆ ğ’œ) (t_mem : t âˆˆ ğ’œ) :
    s \ t âˆˆ ğ’œ := hğ’œ.inter_mem s_mem (hğ’œ.compl_mem t_mem)

/-- An algebra of sets is a ring of sets. -/
theorem isSetRing (hğ’œ : IsSetAlgebra ğ’œ) : IsSetRing ğ’œ where
  empty_mem := hğ’œ.empty_mem
  union_mem := hğ’œ.union_mem
  diff_mem := fun _ _ â†¦ hğ’œ.diff_mem

/-- An algebra of sets is closed by finite unions. -/
theorem biUnion_mem {Î¹ : Type*} (hğ’œ : IsSetAlgebra ğ’œ) {s : Î¹ â†’ Set Î±} (S : Finset Î¹)
    (hs : âˆ€ i âˆˆ S, s i âˆˆ ğ’œ) : â‹ƒ i âˆˆ S, s i âˆˆ ğ’œ := hğ’œ.isSetRing.biUnion_mem S hs

/-- An algebra of sets is closed by finite intersections. -/
theorem biInter_mem {Î¹ : Type*} (hğ’œ : IsSetAlgebra ğ’œ) {s : Î¹ â†’ Set Î±} (S : Finset Î¹)
    (hs : âˆ€ i âˆˆ S, s i âˆˆ ğ’œ) : â‹‚ i âˆˆ S, s i âˆˆ ğ’œ := by
  by_cases h : S = âˆ…
  Â· rw [h, â† Finset.set_biInter_coe, Finset.coe_empty, biInter_empty]
    exact hğ’œ.univ_mem
  Â· rw [â† ne_eq, â† Finset.nonempty_iff_ne_empty] at h
    exact hğ’œ.isSetRing.biInter_mem S h hs

end IsSetAlgebra

section generateSetAlgebra

/-! ### Definition and properties of the algebra of sets generated by some family -/

/-- `generateSetAlgebra ğ’œ` is the smallest algebra of sets containing `ğ’œ`. -/
inductive generateSetAlgebra {Î± : Type*} (ğ’œ : Set (Set Î±)) : Set (Set Î±)
  | base (s : Set Î±) (s_mem : s âˆˆ ğ’œ) : generateSetAlgebra ğ’œ s
  | empty : generateSetAlgebra ğ’œ âˆ…
  | compl (s : Set Î±) (hs : generateSetAlgebra ğ’œ s) : generateSetAlgebra ğ’œ sá¶œ
  | union (s t : Set Î±) (hs : generateSetAlgebra ğ’œ s) (ht : generateSetAlgebra ğ’œ t) :
      generateSetAlgebra ğ’œ (s âˆª t)

/-- The algebra of sets generated by a family of sets is an algebra of sets. -/
theorem isSetAlgebra_generateSetAlgebra :
    IsSetAlgebra (generateSetAlgebra ğ’œ) where
  empty_mem := generateSetAlgebra.empty
  compl_mem := fun _ hs â†¦ generateSetAlgebra.compl _ hs
  union_mem := fun _ _ hs ht â†¦ generateSetAlgebra.union _ _ hs ht

/-- The algebra of sets generated by `ğ’œ` contains `ğ’œ`. -/
theorem self_subset_generateSetAlgebra : ğ’œ âŠ† generateSetAlgebra ğ’œ :=
  fun _ â†¦ generateSetAlgebra.base _

/-- The measurable space generated by a family of sets `ğ’œ` is the same as the one generated
by the algebra of sets generated by `ğ’œ`. -/
@[simp]
theorem generateFrom_generateSetAlgebra_eq :
    generateFrom (generateSetAlgebra ğ’œ) = generateFrom ğ’œ := by
  refine le_antisymm (fun s ms â†¦ ?_) (generateFrom_mono self_subset_generateSetAlgebra)
  refine @generateFrom_induction _ _ (generateSetAlgebra ğ’œ) (fun t ht â†¦ ?_)
    (@MeasurableSet.empty _ (generateFrom ğ’œ))
    (fun t â†¦ MeasurableSet.compl)
    (fun f hf â†¦ MeasurableSet.iUnion hf)
    s ms
  induction ht with
  | base u u_mem => exact measurableSet_generateFrom u_mem
  | empty => exact @MeasurableSet.empty _ (generateFrom ğ’œ)
  | compl u _ mu => exact mu.compl
  | union u v _ _ mu mv  => exact MeasurableSet.union mu mv

/-- If a family of sets `ğ’œ` is contained in `â„¬`, then the algebra of sets generated by `ğ’œ`
is contained in the one generated by `â„¬`. -/
theorem generateSetAlgebra_mono {â„¬ : Set (Set Î±)} (h : ğ’œ âŠ† â„¬) :
    generateSetAlgebra ğ’œ âŠ† generateSetAlgebra â„¬ := by
  intro s hs
  induction hs with
  | base t t_mem => exact self_subset_generateSetAlgebra (h t_mem)
  | empty => exact isSetAlgebra_generateSetAlgebra.empty_mem
  | compl t _ t_mem => exact isSetAlgebra_generateSetAlgebra.compl_mem t_mem
  | union t u _ _ t_mem u_mem => exact isSetAlgebra_generateSetAlgebra.union_mem t_mem u_mem

namespace IsSetAlgebra

/-- If a family of sets `ğ’œ` is contained in an algebra of sets `â„¬`, then so is the algebra of sets
generated by `ğ’œ`. -/
theorem generateSetAlgebra_subset {â„¬ : Set (Set Î±)} (h : ğ’œ âŠ† â„¬)
    (hâ„¬ : IsSetAlgebra â„¬) : generateSetAlgebra ğ’œ âŠ† â„¬ := by
  intro s hs
  induction hs with
  | base t t_mem => exact h t_mem
  | empty => exact hâ„¬.empty_mem
  | compl t _ t_mem => exact hâ„¬.compl_mem t_mem
  | union t u _ _ t_mem u_mem => exact hâ„¬.union_mem t_mem u_mem

/-- If `ğ’œ` is an algebra of sets, then it contains the algebra generated by itself. -/
theorem generateSetAlgebra_subset_self (hğ’œ : IsSetAlgebra ğ’œ) :
    generateSetAlgebra ğ’œ âŠ† ğ’œ := hğ’œ.generateSetAlgebra_subset subset_rfl

/-- If `ğ’œ` is an algebra of sets, then it is equal to the algebra generated by itself. -/
theorem generateSetAlgebra_eq (hğ’œ : IsSetAlgebra ğ’œ) : generateSetAlgebra ğ’œ = ğ’œ :=
  Subset.antisymm hğ’œ.generateSetAlgebra_subset_self self_subset_generateSetAlgebra

end IsSetAlgebra

/-- If a set belongs to the algebra of sets generated by `ğ’œ` then it can be written as a finite
union of finite intersections of sets which are in `ğ’œ` or have their complement in `ğ’œ`. -/
theorem mem_generateSetAlgebra_elim (s_mem : s âˆˆ generateSetAlgebra ğ’œ) :
    âˆƒ A : Set (Set (Set Î±)), A.Finite âˆ§ (âˆ€ a âˆˆ A, a.Finite) âˆ§
    (âˆ€áµ‰ (a âˆˆ A) (t âˆˆ a), t âˆˆ ğ’œ âˆ¨ tá¶œ âˆˆ ğ’œ) âˆ§ s = â‹ƒ a âˆˆ A, â‹‚ t âˆˆ a, t := by
  induction s_mem with
  | base u u_mem =>
    refine âŸ¨{{u}}, finite_singleton {u},
      fun a ha â†¦ eq_of_mem_singleton ha â–¸ finite_singleton u,
      fun a ha t ht â†¦ ?_, by simpâŸ©
    rw [eq_of_mem_singleton ha, ha, eq_of_mem_singleton ht, ht] at *
    exact Or.inl u_mem
  | empty => exact âŸ¨âˆ…, finite_empty, fun _ h â†¦ (not_mem_empty _ h).elim,
    fun _ ha _ _ â†¦ (not_mem_empty _ ha).elim, by simpâŸ©
  | compl u _ u_ind =>
    rcases u_ind with âŸ¨A, A_fin, mem_A, hA, u_eqâŸ©
    have := finite_coe_iff.2 A_fin
    have := fun a : A â†¦ finite_coe_iff.2 <| mem_A a.1 a.2
    refine âŸ¨{{(f a).1á¶œ | a : A} | f : (Î  a : A, â†‘a)}, finite_coe_iff.1 inferInstance,
      fun a âŸ¨f, hfâŸ© â†¦ hf â–¸ finite_coe_iff.1 inferInstance, fun a ha t ht â†¦ ?_, ?_âŸ©
    Â· rcases ha with âŸ¨f, rflâŸ©
      rcases ht with âŸ¨a, rflâŸ©
      rw [compl_compl, or_comm]
      exact hA a.1 a.2 (f a).1 (f a).2
    Â· ext x
      simp only [u_eq, compl_iUnion, compl_iInter, mem_iInter, mem_iUnion, mem_compl_iff,
        exists_prop, Subtype.exists, mem_setOf_eq, iUnion_exists, iUnion_iUnion_eq',
        iInter_exists]
      constructor <;> intro hx
      Â· choose f hf using hx
        exact âŸ¨fun âŸ¨a, haâŸ© â†¦ âŸ¨f a ha, (hf a ha).1âŸ©, fun _ a ha h â†¦ by rw [â† h]; exact (hf a ha).2âŸ©
      Â· rcases hx with âŸ¨f, hfâŸ©
        exact fun a ha â†¦ âŸ¨f âŸ¨a, haâŸ©, (f âŸ¨a, haâŸ©).2, hf (f âŸ¨a, haâŸ©)á¶œ a ha rflâŸ©
  | union u v _ _ u_ind v_ind =>
    rcases u_ind with âŸ¨Au, Au_fin, mem_Au, hAu, u_eqâŸ©
    rcases v_ind with âŸ¨Av, Av_fin, mem_Av, hAv, v_eqâŸ©
    refine âŸ¨Au âˆª Av, Au_fin.union Av_fin, ?_, ?_, by rw [u_eq, v_eq, â† biUnion_union]âŸ©
    Â· rintro a (ha | ha)
      Â· exact mem_Au a ha
      Â· exact mem_Av a ha
    Â· rintro a (ha | ha) t ht
      Â· exact hAu a ha t ht
      Â· exact hAv a ha t ht

/-- If a family of sets is countable then so is the algebra of sets generated by it. -/
theorem countable_generateSetAlgebra (h : ğ’œ.Countable) :
    (generateSetAlgebra ğ’œ).Countable := by
  let â„¬ := {s | s âˆˆ ğ’œ} âˆª {s | sá¶œ âˆˆ ğ’œ}
  have count_â„¬ : â„¬.Countable := by
    apply h.union
    have : compl '' ğ’œ = {s | sá¶œ âˆˆ ğ’œ} := by
      ext s; simp
      exact âŸ¨fun âŸ¨x, x_mem, hxâŸ© â†¦ by simp [â† hx, x_mem], fun hs â†¦ âŸ¨sá¶œ, hs, by simpâŸ©âŸ©
    exact this â–¸ h.image compl
  let f : Set (Set (Set Î±)) â†’ Set Î± := fun A â†¦ â‹ƒ a âˆˆ A, â‹‚ t âˆˆ a, t
  let ğ’ := {a | a.Finite âˆ§ a âŠ† â„¬}
  have count_ğ’ : ğ’.Countable := countable_setOf_finite_subset (countable_coe_iff.1 count_â„¬)
  let ğ’Ÿ := {A | A.Finite âˆ§ A âŠ† ğ’}
  have count_ğ’Ÿ : ğ’Ÿ.Countable := countable_setOf_finite_subset (countable_coe_iff.1 count_ğ’)
  have : generateSetAlgebra ğ’œ âŠ† f '' ğ’Ÿ := by
    intro s s_mem
    rcases mem_generateSetAlgebra_elim s_mem with âŸ¨A, A_fin, mem_A, hA, rflâŸ©
    exact âŸ¨A, âŸ¨A_fin, fun a ha â†¦ âŸ¨mem_A a ha, hA a haâŸ©âŸ©, rflâŸ©
  exact (count_ğ’Ÿ.image f).mono this

end generateSetAlgebra

end MeasureTheory
