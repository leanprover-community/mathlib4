import Mathlib.MeasureTheory.Measure.Portmanteau
import Mathlib.MeasureTheory.Integral.Layercake
import Mathlib.MeasureTheory.Integral.BoundedContinuousFunction
import Mathlib.Tactic

/-!
# Outline of portmanteau implication: liminf condition for open sets implies weak convergence

This file contains steps needed to prove the portmanteau implication
`le_liminf_open_implies_convergence`. Some intermediate steps need to be generalized
and cleaned up, and are to be placed in appropriate files. The main part should go
to the file `Mathlib.MeasureTheory.Measure.Portmanteau`.
-/

open MeasureTheory Filter
open scoped ENNReal NNReal BoundedContinuousFunction Topology

/-- With truncation level `t`, the truncated cast `‚Ñù‚â•0‚àû ‚Üí ‚Ñù` is given by `x ‚Ü¶ (min t x).toReal`.
Unlike `ENNReal.toReal`, this cast is continuous and monotone when `t ‚â† ‚àû`. -/
noncomputable def ENNReal.truncateToReal (t x : ‚Ñù‚â•0‚àû) : ‚Ñù :=
  (min t x).toReal

lemma ENNReal.truncateToReal_eq_toReal {t x : ‚Ñù‚â•0‚àû} (t_ne_top : t ‚â† ‚àû) (x_le : x ‚â§ t) :
    ENNReal.truncateToReal t x = x.toReal := by
  have x_lt_top : x < ‚àû := lt_of_le_of_lt x_le t_ne_top.lt_top
  have obs : min t x ‚â† ‚àû := by
    simp_all only [ne_eq, ge_iff_le, min_eq_top, false_and, not_false_eq_true]
  exact (ENNReal.toReal_eq_toReal obs x_lt_top.ne).mpr (min_eq_right x_le)

lemma ENNReal.truncateToReal_le {t : ‚Ñù‚â•0‚àû} (t_ne_top : t ‚â† ‚àû) {x : ‚Ñù‚â•0‚àû} :
    ENNReal.truncateToReal t x ‚â§ t.toReal := by
  rw [ENNReal.truncateToReal]
  apply (toReal_le_toReal _ t_ne_top).mpr (min_le_left t x)
  simp_all only [ne_eq, ge_iff_le, min_eq_top, false_and, not_false_eq_true]

lemma ENNReal.truncateToReal_nonneg {t x : ‚Ñù‚â•0‚àû} :
    0 ‚â§ ENNReal.truncateToReal t x := toReal_nonneg

/-- The truncated cast `ENNReal.truncateToReal t : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù` is monotone when `t ‚â† ‚àû`. -/
lemma ENNReal.monotone_truncateToReal {t : ‚Ñù‚â•0‚àû} (t_ne_top : t ‚â† ‚àû) :
    Monotone (ENNReal.truncateToReal t) := by
  intro x y x_le_y
  have obs_x : min t x ‚â† ‚àû := by
    simp_all only [ne_eq, ge_iff_le, min_eq_top, false_and, not_false_eq_true]
  have obs_y : min t y ‚â† ‚àû := by
    simp_all only [ne_eq, ge_iff_le, min_eq_top, false_and, not_false_eq_true]
  exact (ENNReal.toReal_le_toReal obs_x obs_y).mpr (min_le_min_left t x_le_y)

-- Q: Missing?
lemma ENNReal.continuousOn_toReal :
    ContinuousOn (fun (x : ‚Ñù‚â•0‚àû) ‚Ü¶ x.toReal) { x | x ‚â† ‚àû } := by
  change ContinuousOn (((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù) ‚àò (fun (x : ‚Ñù‚â•0‚àû) ‚Ü¶ x.toNNReal)) { x | x ‚â† ‚àû }
  apply NNReal.continuous_coe.comp_continuousOn continuousOn_toNNReal

/-- The truncated cast `ENNReal.truncateToReal t : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù` is continuous when `t ‚â† ‚àû`. -/
lemma ENNReal.continuous_truncateToReal {t : ‚Ñù‚â•0‚àû} (t_ne_top : t ‚â† ‚àû) :
    Continuous (ENNReal.truncateToReal t) := by
  apply ENNReal.continuousOn_toReal.comp_continuous (continuous_min.comp (Continuous.Prod.mk t))
  simp [t_ne_top]

/-- If `xs : Œπ ‚Üí ‚Ñù‚â•0‚àû` is bounded, then we have `liminf (toReal ‚àò xs) = toReal (liminf xs)`. -/
lemma ENNReal.liminf_toReal_eq {Œπ : Type*} {F : Filter Œπ} [NeBot F] {b : ‚Ñù‚â•0‚àû} (b_ne_top : b ‚â† ‚àû)
  {xs : Œπ ‚Üí ‚Ñù‚â•0‚àû} (le_b : ‚àÄ i, xs i ‚â§ b) :
    F.liminf (fun i ‚Ü¶ (xs i).toReal) = (F.liminf xs).toReal := by
  have liminf_le : F.liminf xs ‚â§ b := by
    apply liminf_le_of_le
    ¬∑ use 0
      simp only [ge_iff_le, zero_le, eventually_map, eventually_true]
    ¬∑ intro y h
      obtain ‚ü®i, hi‚ü© := h.exists
      exact hi.trans (le_b i)
  have aux : ‚àÄ i, (xs i).toReal = ENNReal.truncateToReal b (xs i) := by
    intro i
    rw [ENNReal.truncateToReal_eq_toReal b_ne_top (le_b i)]
  have aux' : (F.liminf xs).toReal = ENNReal.truncateToReal b (F.liminf xs) := by
    rw [ENNReal.truncateToReal_eq_toReal b_ne_top liminf_le]
  simp_rw [aux, aux']
  have key := Monotone.map_liminf_of_continuousAt (F := F)
          (ENNReal.monotone_truncateToReal b_ne_top) xs
          (ENNReal.continuous_truncateToReal b_ne_top).continuousAt ?_ ?_
  ¬∑ rw [key]
    rfl
  ¬∑ use b
    simp only [eventually_map]
    exact eventually_of_forall le_b
  ¬∑ use 0
    apply eventually_of_forall
    intro y
    simp only [ge_iff_le, zero_le]

-- NOTE: Missing from Mathlib?
-- What would be a good generality?
-- (Mixes order-boundedness and metric-boundedness, so typeclasses don't readily exist.)
lemma Filter.isBounded_le_map_of_bounded_range {Œπ : Type*} (F : Filter Œπ) {f : Œπ ‚Üí ‚Ñù}
    (h : Bornology.IsBounded (Set.range f)) :
    (F.map f).IsBounded (¬∑ ‚â§ ¬∑) := by
  rw [Real.isBounded_iff_bddBelow_bddAbove] at h
  obtain ‚ü®c, hc‚ü© := h.2
  refine isBoundedUnder_of ‚ü®c, by simpa [mem_upperBounds] using hc‚ü©

lemma Filter.isBounded_ge_map_of_bounded_range {Œπ : Type*} (F : Filter Œπ) {f : Œπ ‚Üí ‚Ñù}
    (h : Bornology.IsBounded (Set.range f)) :
    (F.map f).IsBounded (¬∑ ‚â• ¬∑) := by
  rw [Real.isBounded_iff_bddBelow_bddAbove] at h
  obtain ‚ü®c, hc‚ü© := h.1
  apply isBoundedUnder_of ‚ü®c, by simpa [mem_lowerBounds] using hc‚ü©

section le_liminf_open_implies_convergence

variable {Œ© : Type} [MeasurableSpace Œ©] [TopologicalSpace Œ©] [OpensMeasurableSpace Œ©]

lemma lintegral_le_liminf_lintegral_of_forall_isOpen_measure_le_liminf_measure
    {Œº : Measure Œ©} [SigmaFinite Œº] {Œºs : ‚Ñï ‚Üí Measure Œ©} [‚àÄ i, SigmaFinite (Œºs i)]
    {f : Œ© ‚Üí ‚Ñù} (f_cont : Continuous f) (f_nn : 0 ‚â§ f)
    (h_opens : ‚àÄ G, IsOpen G ‚Üí Œº G ‚â§ atTop.liminf (fun i ‚Ü¶ Œºs i G)) :
    ‚à´‚Åª x, ENNReal.ofReal (f x) ‚àÇŒº ‚â§ atTop.liminf (fun i ‚Ü¶ ‚à´‚Åª x, ENNReal.ofReal (f x) ‚àÇ (Œºs i)) := by
  simp_rw [lintegral_eq_lintegral_meas_lt _ (eventually_of_forall f_nn) f_cont.aemeasurable]
  calc  ‚à´‚Åª (t : ‚Ñù) in Set.Ioi 0, Œº {a | t < f a}
      ‚â§ ‚à´‚Åª (t : ‚Ñù) in Set.Ioi 0, atTop.liminf (fun i ‚Ü¶ (Œºs i) {a | t < f a})
            := (lintegral_mono (fun t ‚Ü¶ h_opens _ (continuous_def.mp f_cont _ isOpen_Ioi))).trans ?_
    _ ‚â§ atTop.liminf (fun i ‚Ü¶ ‚à´‚Åª (t : ‚Ñù) in Set.Ioi 0, (Œºs i) {a | t < f a})
            := lintegral_liminf_le (fun n ‚Ü¶ Antitone.measurable
                (fun s t hst ‚Ü¶ measure_mono (fun œâ hœâ ‚Ü¶ lt_of_le_of_lt hst hœâ)))
  rfl

theorem BoundedContinuousFunction.lintegral_le_edist_mul
  {Œº : Measure Œ©} [IsFiniteMeasure Œº] (f : Œ© ‚Üí·µá ‚Ñù‚â•0) :
    (‚à´‚Åª x, f x ‚àÇŒº) ‚â§ edist 0 f * (Œº Set.univ) := by
  have bound : ‚àÄ x, f x ‚â§ nndist 0 f := by
    intro x
    convert nndist_coe_le_nndist x
    simp only [coe_zero, Pi.zero_apply, NNReal.nndist_zero_eq_val]
  apply le_trans (lintegral_mono (fun x ‚Ü¶ ENNReal.coe_le_coe.mpr (bound x)))
  simp

-- Missing?
lemma ENNReal.monotoneOn_toReal : MonotoneOn ENNReal.toReal {‚àû}·∂ú :=
  fun _ _ _ hy x_le_y ‚Ü¶ toReal_mono hy x_le_y

-- Argh. :|
lemma Real.lipschitzWith_toNNReal : LipschitzWith 1 Real.toNNReal := by
  apply lipschitzWith_iff_dist_le_mul.mpr
  intro x y
  simp only [NNReal.coe_one, one_mul, NNReal.dist_eq, coe_toNNReal', ge_iff_le, Real.dist_eq]
  simpa only [ge_iff_le, NNReal.coe_one, dist_prod_same_right, one_mul, Real.dist_eq] using
    lipschitzWith_iff_dist_le_mul.mp lipschitzWith_max (x, 0) (y, 0)

lemma integral_le_liminf_integral_of_forall_isOpen_measure_le_liminf_measure
    {Œº : Measure Œ©} [IsProbabilityMeasure Œº] {Œºs : ‚Ñï ‚Üí Measure Œ©} [‚àÄ i, IsProbabilityMeasure (Œºs i)]
    {f : Œ© ‚Üí·µá ‚Ñù} (f_nn : 0 ‚â§ f)
    (h_opens : ‚àÄ G, IsOpen G ‚Üí Œº G ‚â§ atTop.liminf (fun i ‚Ü¶ Œºs i G)) :
      ‚à´ x, (f x) ‚àÇŒº ‚â§ atTop.liminf (fun i ‚Ü¶ ‚à´ x, (f x) ‚àÇ (Œºs i)) := by
  have same := lintegral_le_liminf_lintegral_of_forall_isOpen_measure_le_liminf_measure
                  f.continuous f_nn h_opens
  rw [@integral_eq_lintegral_of_nonneg_ae Œ© _ Œº f (eventually_of_forall f_nn)
        f.continuous.measurable.aestronglyMeasurable]
  convert (ENNReal.toReal_le_toReal ?_ ?_).mpr same
  ¬∑ simp only [fun i ‚Ü¶ @integral_eq_lintegral_of_nonneg_ae Œ© _ (Œºs i) f (eventually_of_forall f_nn)
                        f.continuous.measurable.aestronglyMeasurable]
    let g := BoundedContinuousFunction.comp _ Real.lipschitzWith_toNNReal f
    have bound : ‚àÄ i, ‚à´‚Åª x, ENNReal.ofReal (f x) ‚àÇ(Œºs i) ‚â§ nndist 0 g := fun i ‚Ü¶ by
      simpa only [coe_nnreal_ennreal_nndist, measure_univ, mul_one, ge_iff_le] using
            BoundedContinuousFunction.lintegral_le_edist_mul (Œº := Œºs i) g
    apply ENNReal.liminf_toReal_eq ENNReal.coe_ne_top bound
  ¬∑ exact (f.lintegral_of_real_lt_top Œº).ne
  ¬∑ apply ne_of_lt
    have obs := fun (i : ‚Ñï) ‚Ü¶ @BoundedContinuousFunction.lintegral_nnnorm_le Œ© _ _ (Œºs i) ‚Ñù _ f
    simp only [measure_univ, mul_one] at obs
    apply lt_of_le_of_lt _ (show (‚Äñf‚Äñ‚Çä : ‚Ñù‚â•0‚àû) < ‚àû from ENNReal.coe_lt_top)
    apply liminf_le_of_le
    ¬∑ refine ‚ü®0, eventually_of_forall (by simp only [ge_iff_le, zero_le, forall_const])‚ü©
    ¬∑ intro x hx
      obtain ‚ü®i, hi‚ü© := hx.exists
      apply le_trans hi
      convert obs i with x
      have aux := ENNReal.ofReal_eq_coe_nnreal (f_nn x)
      simp only [ContinuousMap.toFun_eq_coe, BoundedContinuousFunction.coe_to_continuous_fun] at aux
      rw [aux]
      congr
      exact (Real.norm_of_nonneg (f_nn x)).symm

lemma tendsto_integral_of_forall_integral_le_liminf_integral {Œπ : Type*} {L : Filter Œπ}
    {Œº : Measure Œ©} [IsProbabilityMeasure Œº] {Œºs : Œπ ‚Üí Measure Œ©} [‚àÄ i, IsProbabilityMeasure (Œºs i)]
    (h : ‚àÄ f : Œ© ‚Üí·µá ‚Ñù, 0 ‚â§ f ‚Üí ‚à´ x, (f x) ‚àÇŒº ‚â§ L.liminf (fun i ‚Ü¶ ‚à´ x, (f x) ‚àÇ (Œºs i)))
    (f : Œ© ‚Üí·µá ‚Ñù) :
    Tendsto (fun i ‚Ü¶ ‚à´ x, (f x) ‚àÇ (Œºs i)) L (ùìù (‚à´ x, (f x) ‚àÇŒº)) := by
  by_cases L_bot : L = ‚ä•
  ¬∑ simp only [L_bot, tendsto_bot]
  have : NeBot L := ‚ü®L_bot‚ü©
  have obs := BoundedContinuousFunction.isBounded_range_integral Œºs f
  have bdd_above : IsBoundedUnder (¬∑ ‚â§ ¬∑) L (fun i ‚Ü¶ ‚à´ (x : Œ©), f x ‚àÇŒºs i) :=
    isBounded_le_map_of_bounded_range _ obs
  have bdd_below : IsBoundedUnder (¬∑ ‚â• ¬∑) L (fun i ‚Ü¶ ‚à´ (x : Œ©), f x ‚àÇŒºs i) :=
    isBounded_ge_map_of_bounded_range _ obs
  apply @tendsto_of_le_liminf_of_limsup_le ‚Ñù Œπ _ _ _ L (fun i ‚Ü¶ ‚à´ x, (f x) ‚àÇ (Œºs i)) (‚à´ x, (f x) ‚àÇŒº)
  ¬∑ have key := h _ (f.add_norm_nonneg)
    simp_rw [f.integral_add_const ‚Äñf‚Äñ] at key
    simp only [measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul] at key
    have := liminf_add_const L (fun i ‚Ü¶ ‚à´ x, (f x) ‚àÇ (Œºs i)) ‚Äñf‚Äñ bdd_above bdd_below
    rwa [this, add_le_add_iff_right] at key
  ¬∑ have key := h _ (f.norm_sub_nonneg)
    simp_rw [f.integral_const_sub ‚Äñf‚Äñ] at key
    simp only [measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul] at key
    have := liminf_const_sub L (fun i ‚Ü¶ ‚à´ x, (f x) ‚àÇ (Œºs i)) ‚Äñf‚Äñ bdd_above bdd_below
    rwa [this, sub_le_sub_iff_left] at key
  ¬∑ exact bdd_above
  ¬∑ exact bdd_below

-- Not needed?
/-- A characterization of weak convergence of probability measures by the condition that the
integrals of every continuous bounded nonnegative function converge to the integral of the function
against the limit measure. -/
lemma ProbabilityMeasure.tendsto_iff_forall_nonneg_integral_tendsto {Œ≥ : Type _} {F : Filter Œ≥}
    {Œºs : Œ≥ ‚Üí ProbabilityMeasure Œ©} {Œº : ProbabilityMeasure Œ©} :
    Tendsto Œºs F (ùìù Œº) ‚Üî
      ‚àÄ f : Œ© ‚Üí·µá ‚Ñù, 0 ‚â§ f ‚Üí
        Tendsto (fun i ‚Ü¶ ‚à´ œâ, (f œâ) ‚àÇ(Œºs i : Measure Œ©)) F (ùìù (‚à´ œâ, (f œâ) ‚àÇ(Œº : Measure Œ©))) := by
  rw [ProbabilityMeasure.tendsto_iff_forall_integral_tendsto]
  refine ‚ü®fun h f _ ‚Ü¶ h f, fun h f ‚Ü¶ ?_‚ü©
  set g := f + BoundedContinuousFunction.const _ ‚Äñf‚Äñ with g_def
  have fx_eq : ‚àÄ x, f x = g x - ‚Äñf‚Äñ := by
    intro x
    simp only [BoundedContinuousFunction.coe_add, BoundedContinuousFunction.const_toFun, Pi.add_apply,
               add_sub_cancel]
  have key := h g (f.add_norm_nonneg)
  simp [g_def] at key
  simp_rw [integral_add (f.integrable _) (integrable_const ‚Äñf‚Äñ)] at key
  simp only [integral_const, measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul] at key
  simp_rw [fx_eq]
  convert tendsto_add.comp (Tendsto.prod_mk_nhds key (@tendsto_const_nhds _ _ _ (-‚Äñf‚Äñ) F)) <;> simp

/-- One implication of the portmanteau theorem. -/
theorem ProbabilityMeasure.tendsto_of_forall_isOpen_le_liminf {Œº : ProbabilityMeasure Œ©}
  {Œºs : ‚Ñï ‚Üí ProbabilityMeasure Œ©} (h_opens : ‚àÄ G, IsOpen G ‚Üí Œº G ‚â§ atTop.liminf (fun i ‚Ü¶ Œºs i G)) :
    atTop.Tendsto (fun i ‚Ü¶ Œºs i) (ùìù Œº) := by
  refine ProbabilityMeasure.tendsto_iff_forall_integral_tendsto.mpr ?_
  apply tendsto_integral_of_forall_integral_le_liminf_integral
  intro f f_nn
  apply integral_le_liminf_integral_of_forall_isOpen_measure_le_liminf_measure (f := f) f_nn
  intro G G_open
  specialize h_opens G G_open
  simp only at h_opens
  have aux := Monotone.map_liminf_of_continuousAt (F := atTop) ENNReal.coe_mono (Œºs ¬∑ G) ?_ ?_ ?_
  ¬∑ have obs := ENNReal.coe_mono h_opens
    simp only [ne_eq, ProbabilityMeasure.ennreal_coeFn_eq_coeFn_toMeasure, aux] at obs
    convert obs
    simp only [Function.comp_apply, ne_eq, ProbabilityMeasure.ennreal_coeFn_eq_coeFn_toMeasure]
  ¬∑ apply ENNReal.continuous_coe.continuousAt
  ¬∑ use 1
    simp only [eventually_map, ProbabilityMeasure.apply_le_one, eventually_atTop, ge_iff_le,
      implies_true, forall_const, exists_const]
  ¬∑ use 0
    simp only [zero_le, eventually_map, eventually_atTop, ge_iff_le, implies_true, forall_const,
      exists_const]

end le_liminf_open_implies_convergence
