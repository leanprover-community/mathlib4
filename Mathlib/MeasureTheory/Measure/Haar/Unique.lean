/-
Copyright (c) 2023 S√©bastien Gou√´zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: S√©bastien Gou√´zel
-/
import Mathlib.MeasureTheory.Constructions.Prod.Integral
import Mathlib.MeasureTheory.Group.Integral
import Mathlib.Topology.UrysohnsLemma
import Mathlib.MeasureTheory.Measure.Haar.Basic

/-!
# Uniqueness of Haar measure in locally compact groups

In a locally compact group, we prove that two left-invariant measures which are finite on compact
sets give the same value to the integral of continuous compactly supported functions, in
`integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport`. From this, we deduce various uniqueness
statements for left invariant measures (up to scalar multiplication):
* `measure_isMulLeftInvariant_eq_smul_of_ne_top`: two left-invariant measures which are inner
  regular for finite measure sets with respect to compact sets give the same measure to
  compact sets.
* `isMulLeftInvariant_eq_smul_of_innerRegular`: two left invariant measures which are
  inner regular coincide up to a scalar.
* `isHaarMeasure_eq_smul_of_innerRegular`: two Haar measures which are inner regular coincide up
  to a nonzero scalar.
* `isMulLeftInvariant_eq_smul_of_regular`: two left invariant measure which are
  regular coincide up to a scalar.
* `isHaarMeasure_eq_smul_of_regular`: two Haar measures which are regular coincide up to a
  nonzero scalar.
* `isHaarMeasure_eq_smul`: in a second countable space, two Haar measures coincide up to a
  nonzero scalar.
* `isMulLeftInvariant_eq_of_isProbabilityMeasure`: two left-invariant probability measures which
  are inner regular for finite measure sets with respect to compact sets coincide.

In general, uniqueness statements for Haar measures in the literature make some assumption of
regularity, either regularity or inner regularity. We have tried to minimize the assumptions in the
theorems above (notably in `integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport`, which doesn't
make any regularity assumption), and cover the different results that exist in the literature.

The main result is `integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport`, and the other ones
follow readily from this one by using continuous compactly supported functions to approximate
characteristic functions of set.

To prove `integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport`, we use a change of variables
to express integrals with respect to a left-invariant measure as integrals with respect to a given
right-invariant measure (with a suitable density function). The uniqueness readily follows.

On second-countable groups, one can arrive to slightly different uniqueness results by using that
the operations are measurable. In particular, one can get uniqueness assuming œÉ-finiteness of
the measures but discarding the assumption that they are finite on compact sets. See
`haarMeasure_unique` in the file `MeasureTheory.Measure.Haar.Basic`.
-/

open MeasureTheory Filter Set TopologicalSpace Function MeasureTheory Measure
open scoped Uniformity Topology ENNReal Pointwise NNReal

/-- In a locally compact regular space with an inner regular measure, the measure of a compact
set `k` is the infimum of the integrals of compactly supported functions equal to `1` on `k`. -/
lemma IsCompact.measure_eq_biInf_integral_hasCompactSupport
    {X : Type*} [TopologicalSpace X] [MeasurableSpace X] [BorelSpace X]
    {k : Set X} (hk : IsCompact k)
    (Œº : Measure X) [IsFiniteMeasureOnCompacts Œº] [InnerRegularCompactLTTop Œº]
    [LocallyCompactSpace X] [RegularSpace X] :
    Œº k = ‚®Ö (f : X ‚Üí ‚Ñù) (_ : Continuous f) (_ : HasCompactSupport f) (_ : EqOn f 1 k)
      (_ : 0 ‚â§ f), ENNReal.ofReal (‚à´ x, f x ‚àÇŒº) := by
  apply le_antisymm
  ¬∑ simp only [le_iInf_iff]
    intro f f_cont f_comp fk f_nonneg
    apply (f_cont.integrable_of_hasCompactSupport f_comp).measure_le_integral
    ¬∑ exact eventually_of_forall f_nonneg
    ¬∑ exact fun x hx ‚Ü¶ by simp [fk hx]
  ¬∑ apply le_of_forall_lt' (fun r hr ‚Ü¶ ?_)
    simp only [iInf_lt_iff, exists_prop, exists_and_left]
    obtain ‚ü®U, kU, U_open, mu_U‚ü© : ‚àÉ U, k ‚äÜ U ‚àß IsOpen U ‚àß Œº U < r :=
      hk.exists_isOpen_lt_of_lt r hr
    obtain ‚ü®‚ü®f, f_cont‚ü©, fk, fU, f_comp, f_range‚ü© : ‚àÉ (f : C(X, ‚Ñù)), EqOn f 1 k ‚àß EqOn f 0 U·∂ú
        ‚àß HasCompactSupport f ‚àß ‚àÄ (x : X), f x ‚àà Icc 0 1 := exists_continuous_one_zero_of_isCompact
      hk U_open.isClosed_compl (disjoint_compl_right_iff_subset.mpr kU)
    refine ‚ü®f, f_cont, f_comp, fk, fun x ‚Ü¶ (f_range x).1, ?_‚ü©
    exact (integral_le_measure (fun x _hx ‚Ü¶ (f_range x).2) (fun x hx ‚Ü¶ (fU hx).le)).trans_lt mu_U

namespace MeasureTheory

/-- The parameterized integral `x ‚Ü¶ ‚à´ y, g (y‚Åª¬π * x) ‚àÇŒº` depends continuously on `y` when `g` is a
compactly supported continuous function on a topological group `G`, and `Œº` is finite on compact
sets. -/
@[to_additive]
lemma continuous_integral_apply_inv_mul
    {G : Type*} [TopologicalSpace G] [LocallyCompactSpace G] [Group G] [TopologicalGroup G]
    [MeasurableSpace G] [BorelSpace G]
    {Œº : Measure G} [IsFiniteMeasureOnCompacts Œº] {E : Type*} [NormedAddCommGroup E]
    [NormedSpace ‚Ñù E] {g : G ‚Üí E}
    (hg : Continuous g) (h'g : HasCompactSupport g) :
    Continuous (fun (x : G) ‚Ü¶ ‚à´ y, g (y‚Åª¬π * x) ‚àÇŒº) := by
  let k := tsupport g
  have k_comp : IsCompact k := h'g
  apply continuous_iff_continuousAt.2 (fun x‚ÇÄ ‚Ü¶ ?_)
  obtain ‚ü®t, t_comp, ht‚ü© : ‚àÉ t, IsCompact t ‚àß t ‚àà ùìù x‚ÇÄ := exists_compact_mem_nhds x‚ÇÄ
  let k' : Set G := t ‚Ä¢ k‚Åª¬π
  have k'_comp : IsCompact k' := t_comp.smul_set k_comp.inv
  have A : ContinuousOn (fun (x : G) ‚Ü¶ ‚à´ y, g (y‚Åª¬π * x) ‚àÇŒº) t := by
    apply continuousOn_integral_of_compact_support k'_comp
    ¬∑ exact (hg.comp (continuous_snd.inv.mul continuous_fst)).continuousOn
    ¬∑ intro p x hp hx
      contrapose! hx
      refine ‚ü®p, p‚Åª¬π * x, hp, ?_, by simp‚ü©
      simpa only [Set.mem_inv, mul_inv_rev, inv_inv] using subset_tsupport _ hx
  exact A.continuousAt ht

namespace Measure

section Group

variable {G : Type*} [TopologicalSpace G] [LocallyCompactSpace G] [Group G] [TopologicalGroup G]
  [MeasurableSpace G] [BorelSpace G]

/-- In a group with a left invariant measure `Œº` and a right invariant measure `ŒΩ`, one can express
integrals with respect to `Œº` as integrals with respect to `ŒΩ` up to a constant scaling factor
(given in the statement as `‚à´ x, g x ‚àÇŒº` where `g` is a fixed reference function) and an
explicit density `y ‚Ü¶ 1/‚à´ z, g (z‚Åª¬π * y) ‚àÇŒΩ`. -/
@[to_additive]
lemma integral_isMulLeftInvariant_isMulRightInvariant_combo
    {Œº ŒΩ : Measure G} [IsFiniteMeasureOnCompacts Œº] [IsFiniteMeasureOnCompacts ŒΩ]
    [IsMulLeftInvariant Œº] [IsMulRightInvariant ŒΩ] [IsOpenPosMeasure ŒΩ]
    {f g : G ‚Üí ‚Ñù} (hf : Continuous f) (h'f : HasCompactSupport f)
    (hg : Continuous g) (h'g : HasCompactSupport g) (g_nonneg : 0 ‚â§ g) {x‚ÇÄ : G} (g_pos : g x‚ÇÄ ‚â† 0) :
    ‚à´ x, f x ‚àÇŒº = (‚à´ y, f y * (‚à´ z, g (z‚Åª¬π * y) ‚àÇŒΩ)‚Åª¬π ‚àÇŒΩ) * ‚à´ x, g x ‚àÇŒº := by
  let D : G ‚Üí ‚Ñù := fun (x : G) ‚Ü¶ ‚à´ y, g (y‚Åª¬π * x) ‚àÇŒΩ
  have D_cont : Continuous D := continuous_integral_apply_inv_mul hg h'g
  have D_pos : ‚àÄ x, 0 < D x := by
    intro x
    have C : Continuous (fun y ‚Ü¶ g (y‚Åª¬π * x)) := hg.comp (continuous_inv.mul continuous_const)
    apply (integral_pos_iff_support_of_nonneg _ _).2
    ¬∑ apply C.isOpen_support.measure_pos ŒΩ
      exact ‚ü®x * x‚ÇÄ‚Åª¬π, by simpa using g_pos‚ü©
    ¬∑ exact fun y ‚Ü¶ g_nonneg (y‚Åª¬π * x)
    ¬∑ apply C.integrable_of_hasCompactSupport
      exact h'g.comp_homeomorph ((Homeomorph.inv G).trans (Homeomorph.mulRight x))
  calc
  ‚à´ x, f x ‚àÇŒº = ‚à´ x, f x * (D x)‚Åª¬π * D x ‚àÇŒº := by
    congr with x; rw [mul_assoc, inv_mul_cancel (D_pos x).ne', mul_one]
  _ = ‚à´ x, (‚à´ y, f x * (D x)‚Åª¬π * g (y‚Åª¬π * x) ‚àÇŒΩ) ‚àÇŒº := by simp_rw [integral_mul_left]
  _ = ‚à´ y, (‚à´ x, f x * (D x)‚Åª¬π * g (y‚Åª¬π * x) ‚àÇŒº) ‚àÇŒΩ := by
      apply integral_integral_swap_of_hasCompactSupport
      ¬∑ apply Continuous.mul
        ¬∑ exact (hf.comp continuous_fst).mul
            ((D_cont.comp continuous_fst).inv‚ÇÄ (fun x ‚Ü¶ (D_pos _).ne'))
        ¬∑ exact hg.comp (continuous_snd.inv.mul continuous_fst)
      ¬∑ let K := tsupport f
        have K_comp : IsCompact K := h'f
        let L := tsupport g
        have L_comp : IsCompact L := h'g
        let M := (fun (p : G √ó G) ‚Ü¶ p.1 * p.2‚Åª¬π) '' (K √óÀ¢ L)
        have M_comp : IsCompact M :=
          (K_comp.prod L_comp).image (continuous_fst.mul continuous_snd.inv)
        have M'_comp : IsCompact (closure M) := M_comp.closure
        have : ‚àÄ (p : G √ó G), p ‚àâ K √óÀ¢ closure M ‚Üí f p.1 * (D p.1)‚Åª¬π * g (p.2‚Åª¬π * p.1) = 0 := by
          rintro ‚ü®x, y‚ü© hxy
          by_cases H : x ‚àà K; swap
          ¬∑ simp [image_eq_zero_of_nmem_tsupport H]
          have : g (y‚Åª¬π * x) = 0 := by
            apply image_eq_zero_of_nmem_tsupport
            contrapose! hxy
            simp only [mem_prod, H, true_and]
            apply subset_closure
            simp only [mem_image, mem_prod, Prod.exists]
            exact ‚ü®x, y‚Åª¬π * x, ‚ü®H, hxy‚ü©, by group‚ü©
          simp [this]
        apply HasCompactSupport.intro' (K_comp.prod M'_comp) ?_ this
        exact (isClosed_tsupport f).prod isClosed_closure
  _ = ‚à´ y, (‚à´ x, f (y * x) * (D (y * x))‚Åª¬π * g x ‚àÇŒº) ‚àÇŒΩ := by
      congr with y
      rw [‚Üê integral_mul_left_eq_self _ y]
      simp
  _ = ‚à´ x, (‚à´ y, f (y * x) * (D (y * x))‚Åª¬π * g x ‚àÇŒΩ) ‚àÇŒº := by
      apply (integral_integral_swap_of_hasCompactSupport _ _).symm
      ¬∑ apply Continuous.mul ?_ (hg.comp continuous_fst)
        exact (hf.comp (continuous_snd.mul continuous_fst)).mul
          ((D_cont.comp (continuous_snd.mul continuous_fst)).inv‚ÇÄ (fun x ‚Ü¶ (D_pos _).ne'))
      ¬∑ let K := tsupport f
        have K_comp : IsCompact K := h'f
        let L := tsupport g
        have L_comp : IsCompact L := h'g
        let M := (fun (p : G √ó G) ‚Ü¶ p.1 * p.2‚Åª¬π) '' (K √óÀ¢ L)
        have M_comp : IsCompact M :=
          (K_comp.prod L_comp).image (continuous_fst.mul continuous_snd.inv)
        have M'_comp : IsCompact (closure M) := M_comp.closure
        have : ‚àÄ (p : G √ó G), p ‚àâ L √óÀ¢ closure M ‚Üí
            f (p.2 * p.1) * (D (p.2 * p.1))‚Åª¬π * g p.1 = 0 := by
          rintro ‚ü®x, y‚ü© hxy
          by_cases H : x ‚àà L; swap
          ¬∑ simp [image_eq_zero_of_nmem_tsupport H]
          have : f (y * x) = 0 := by
            apply image_eq_zero_of_nmem_tsupport
            contrapose! hxy
            simp only [mem_prod, H, true_and]
            apply subset_closure
            simp only [mem_image, mem_prod, Prod.exists]
            refine ‚ü®y * x, x, ‚ü®hxy, H‚ü©, by group‚ü©
          simp [this]
        apply HasCompactSupport.intro' (L_comp.prod M'_comp) ?_ this
        exact (isClosed_tsupport g).prod isClosed_closure
  _ = ‚à´ x, (‚à´ y, f y * (D y)‚Åª¬π ‚àÇŒΩ) * g x ‚àÇŒº := by
      simp_rw [integral_mul_right]
      congr with x
      conv_rhs => rw [‚Üê integral_mul_right_eq_self _ x]
  _ = (‚à´ y, f y * (D y)‚Åª¬π ‚àÇŒΩ) * ‚à´ x, g x ‚àÇŒº := integral_mul_left _ _

/-- **Uniqueness of left-invariant measures**: Given two left-invariant measures which are finite on
compacts, they coincide in the following sense: they give the same value to the integral of
continuous compactly supported functions, up to a multiplicative constant. -/
@[to_additive integral_isAddLeftInvariant_eq_smul_of_hasCompactSupport]
lemma integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport
    (Œº' Œº : Measure G) [IsFiniteMeasureOnCompacts Œº] [IsFiniteMeasureOnCompacts Œº']
    [IsMulLeftInvariant Œº] [IsMulLeftInvariant Œº'] [IsOpenPosMeasure Œº] :
    ‚àÉ (c : ‚Ñù‚â•0), ‚àÄ (f : G ‚Üí ‚Ñù), Continuous f ‚Üí HasCompactSupport f ‚Üí
      ‚à´ x, f x ‚àÇŒº' = ‚à´ x, f x ‚àÇ(c ‚Ä¢ Œº) := by
  -- The group has to be locally compact, otherwise all integrals vanish and the result is trivial.
  by_cases H : LocallyCompactSpace G; swap
  ¬∑ refine ‚ü®0, fun f f_cont f_comp ‚Ü¶ ?_‚ü©
    rcases f_comp.eq_zero_or_locallyCompactSpace_of_group f_cont with hf|hf
    ¬∑ simp [hf]
    ¬∑ exact (H hf).elim
  -- Fix some nonzero continuous function with compact support `g`.
  obtain ‚ü®g, g_cont, g_comp, g_nonneg, g_one‚ü© :
      ‚àÉ (g : G ‚Üí ‚Ñù), Continuous g ‚àß HasCompactSupport g ‚àß 0 ‚â§ g ‚àß g 1 ‚â† 0 := by
    rcases exists_compact_mem_nhds (1 : G) with ‚ü®k, hk, k_mem‚ü©
    rcases exists_continuous_one_zero_of_isCompact hk isClosed_empty (disjoint_empty k)
      with ‚ü®‚ü®g, g_cont‚ü©, gk, -, g_comp, hg‚ü©
    refine ‚ü®g, g_cont, g_comp, fun x ‚Ü¶ (hg x).1, ?_‚ü©
    have := gk (mem_of_mem_nhds k_mem)
    simp only [ContinuousMap.coe_mk, Pi.one_apply] at this
    simp [this]
  have int_g_pos : 0 < ‚à´ x, g x ‚àÇŒº := by
    apply (integral_pos_iff_support_of_nonneg g_nonneg _).2
    ¬∑ exact IsOpen.measure_pos Œº g_cont.isOpen_support ‚ü®1, g_one‚ü©
    ¬∑ exact g_cont.integrable_of_hasCompactSupport g_comp
  -- The proportionality constant we are looking for will be the ratio of the integrals of `g`
  -- with respect to `Œº'` and `Œº`.
  let c : ‚Ñù := (‚à´ x, g x ‚àÇŒº) ‚Åª¬π * (‚à´ x, g x ‚àÇŒº')
  have c_nonneg : 0 ‚â§ c :=
    mul_nonneg (inv_nonneg.2 (integral_nonneg g_nonneg)) (integral_nonneg g_nonneg)
  refine ‚ü®‚ü®c, c_nonneg‚ü©, fun f f_cont f_comp ‚Ü¶ ?_‚ü©
  /- use the lemma `integral_mulLeftInvariant_mulRightInvariant_combo` for `Œº` and then `Œº'`
  to reexpress the integral of `f` as the integral of `g` times a factor which only depends
  on a right-invariant measure `ŒΩ`. We use `ŒΩ = Œº.inv` for convenience. -/
  let ŒΩ := Œº.inv
  have A : ‚à´ x, f x ‚àÇŒº = (‚à´ y, f y * (‚à´ z, g (z‚Åª¬π * y) ‚àÇŒΩ)‚Åª¬π ‚àÇŒΩ) * ‚à´ x, g x ‚àÇŒº :=
    integral_isMulLeftInvariant_isMulRightInvariant_combo f_cont f_comp g_cont g_comp g_nonneg g_one
  rw [‚Üê mul_inv_eq_iff_eq_mul‚ÇÄ int_g_pos.ne'] at A
  have B : ‚à´ x, f x ‚àÇŒº' = (‚à´ y, f y * (‚à´ z, g (z‚Åª¬π * y) ‚àÇŒΩ)‚Åª¬π ‚àÇŒΩ) * ‚à´ x, g x ‚àÇŒº' :=
    integral_isMulLeftInvariant_isMulRightInvariant_combo f_cont f_comp g_cont g_comp g_nonneg g_one
  /- Since the `ŒΩ`-factor is the same for `Œº` and `Œº'`, this gives the result. -/
  rw [‚Üê A, mul_assoc, mul_comm] at B
  simp only [B, integral_smul_nnreal_measure]
  rfl

/-- **Uniqueness of left-invariant measures**: Given two left-invariant measures which are finite on
compacts and inner regular for finite measure sets with respect to compact sets,
they coincide in the following sense: they give the same value to finite measure sets,
up to a multiplicative constant. -/
@[to_additive]
lemma measure_isMulLeftInvariant_eq_smul_of_ne_top
    (Œº' Œº : Measure G) [IsFiniteMeasureOnCompacts Œº] [IsFiniteMeasureOnCompacts Œº']
    [IsMulLeftInvariant Œº] [IsMulLeftInvariant Œº'] [IsOpenPosMeasure Œº]
    [InnerRegularCompactLTTop Œº] [InnerRegularCompactLTTop Œº'] :
    ‚àÉ (c : ‚Ñù‚â•0), ‚àÄ (s : Set G), Œº s < ‚àû ‚Üí Œº' s < ‚àû ‚Üí Œº' s = (c ‚Ä¢ Œº) s := by
  /- We know that the measures integrate in the same way continuous compactly supported functions,
  up to a constant `c`. We will use this constant `c`. -/
  rcases integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport Œº' Œº with ‚ü®c, hc‚ü©
  refine ‚ü®c, fun s hs h's ‚Ü¶ ?_‚ü©
  /- By regularity, every compact set may be approximated by a continuous compactly supported
  function. Therefore, the measures coincide on compact sets. -/
  have A : ‚àÄ k, IsCompact k ‚Üí Œº' k = (c ‚Ä¢ Œº) k := by
    intro k hk
    rw [hk.measure_eq_biInf_integral_hasCompactSupport Œº',
        hk.measure_eq_biInf_integral_hasCompactSupport (c ‚Ä¢ Œº)]
    congr! 7 with f f_cont f_comp _fk _f_nonneg
    exact hc f f_cont f_comp
  /- By regularity, every measurable set of finite measure may be approximated by compact sets.
  Therefore, the measures coincide on measurable sets of finite measure. -/
  have B : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí Œº' s < ‚àû ‚Üí Œº' s = (c ‚Ä¢ Œº) s := by
    intro s s_meas hs h's
    have : (c ‚Ä¢ Œº) s ‚â† ‚àû := by simp [ENNReal.mul_eq_top, hs.ne]
    rw [s_meas.measure_eq_iSup_isCompact_of_ne_top h's.ne,
        s_meas.measure_eq_iSup_isCompact_of_ne_top this]
    congr! 4 with K _Ks K_comp
    exact A K K_comp
  /- Finally, replace an arbitrary finite measure set with a measurable version, and use the
  version for measurable sets. -/
  let t := toMeasurable Œº' s ‚à© toMeasurable Œº s
  have st : s ‚äÜ t := subset_inter (subset_toMeasurable Œº' s) (subset_toMeasurable Œº s)
  have mu'_t : Œº' t = Œº' s := by
    apply le_antisymm
    ¬∑ exact (measure_mono (inter_subset_left _ _)).trans (measure_toMeasurable s).le
    ¬∑ exact measure_mono st
  have mu_t : Œº t = Œº s := by
    apply le_antisymm
    ¬∑ exact (measure_mono (inter_subset_right _ _)).trans (measure_toMeasurable s).le
    ¬∑ exact measure_mono st
  simp only [‚Üê mu'_t, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, ‚Üê mu_t,
    nnreal_smul_coe_apply]
  apply B
  ¬∑ exact (measurableSet_toMeasurable _ _).inter (measurableSet_toMeasurable _ _)
  ¬∑ exact mu_t.le.trans_lt hs
  ¬∑ exact mu'_t.le.trans_lt h's

/-- **Uniqueness of left-invariant measures**: Given two left-invariant measures which are finite
on compacts and inner regular, they coincide up to a multiplicative constant. -/
@[to_additive isAddLeftInvariant_eq_smul_of_innerRegular]
lemma isMulLeftInvariant_eq_smul_of_innerRegular
    (Œº' Œº : Measure G) [IsFiniteMeasureOnCompacts Œº] [IsFiniteMeasureOnCompacts Œº']
    [IsMulLeftInvariant Œº] [IsMulLeftInvariant Œº'] [IsOpenPosMeasure Œº]
    [InnerRegular Œº] [InnerRegular Œº'] :
    ‚àÉ (c : ‚Ñù‚â•0), Œº' = c ‚Ä¢ Œº := by
  rcases measure_isMulLeftInvariant_eq_smul_of_ne_top Œº' Œº with ‚ü®c, hc‚ü©
  refine ‚ü®c, ?_‚ü©
  ext s hs
  rw [hs.measure_eq_iSup_isCompact, hs.measure_eq_iSup_isCompact]
  congr! 4 with K _Ks K_comp
  exact hc K K_comp.measure_lt_top K_comp.measure_lt_top

/-- **Uniqueness of left-invariant measures**: Two inner regular Haar measures coincide up to a
multiplicative constant. -/
@[to_additive isAddHaarMeasure_eq_smul_of_innerRegular]
lemma isHaarMeasure_eq_smul_of_innerRegular
    (Œº' Œº : Measure G) [IsHaarMeasure Œº] [IsHaarMeasure Œº'] [InnerRegular Œº] [InnerRegular Œº'] :
    ‚àÉ c : ‚Ñù‚â•0‚àû, c ‚â† 0 ‚àß c ‚â† ‚àû ‚àß Œº' = c ‚Ä¢ Œº := by
  rcases isMulLeftInvariant_eq_smul_of_innerRegular Œº' Œº with ‚ü®c, hc‚ü©
  refine ‚ü®c, ?_, ENNReal.coe_ne_top, hc‚ü©
  intro h
  simp only [ENNReal.coe_eq_zero.1 h, zero_smul] at hc
  have : 0 < Œº' univ := NeZero.pos (Œº' univ)
  simp [hc] at this

/-- **Uniqueness of left-invariant measures**: Given two left-invariant measures which are finite
on compacts and regular, they coincide up to a multiplicative constant. -/
@[to_additive isAddLeftInvariant_eq_smul_of_regular]
lemma isMulLeftInvariant_eq_smul_of_regular
    (Œº' Œº : Measure G) [IsFiniteMeasureOnCompacts Œº] [IsFiniteMeasureOnCompacts Œº']
    [IsMulLeftInvariant Œº] [IsMulLeftInvariant Œº'] [IsOpenPosMeasure Œº]
    [Regular Œº] [Regular Œº'] :
    ‚àÉ (c : ‚Ñù‚â•0), Œº' = c ‚Ä¢ Œº := by
  rcases measure_isMulLeftInvariant_eq_smul_of_ne_top Œº' Œº with ‚ü®c, hc‚ü©
  refine ‚ü®c, ?_‚ü©
  have A : ‚àÄ U, IsOpen U ‚Üí Œº' U = (c ‚Ä¢ Œº) U := by
    intro U hU
    rw [hU.measure_eq_iSup_isCompact, hU.measure_eq_iSup_isCompact]
    congr! 4 with K _KU K_comp
    exact hc K K_comp.measure_lt_top K_comp.measure_lt_top
  ext s _hs
  rw [s.measure_eq_iInf_isOpen, s.measure_eq_iInf_isOpen]
  congr! 4 with U _sU U_open
  exact A U U_open

/-- **Uniqueness of left-invariant measures**: Two regular Haar measures coincide up to a
multiplicative constant. -/
@[to_additive isAddHaarMeasure_eq_smul_of_regular]
lemma isHaarMeasure_eq_smul_of_regular
    (Œº' Œº : Measure G) [IsHaarMeasure Œº] [IsHaarMeasure Œº'] [Regular Œº] [Regular Œº'] :
    ‚àÉ c : ‚Ñù‚â•0‚àû, c ‚â† 0 ‚àß c ‚â† ‚àû ‚àß Œº' = c ‚Ä¢ Œº := by
  rcases isMulLeftInvariant_eq_smul_of_regular Œº' Œº with ‚ü®c, hc‚ü©
  refine ‚ü®c, ?_, ENNReal.coe_ne_top, hc‚ü©
  intro h
  simp only [ENNReal.coe_eq_zero.1 h, zero_smul] at hc
  have : 0 < Œº' univ := NeZero.pos (Œº' univ)
  simp [hc] at this

/-- **Uniqueness of left-invariant measures**: Two Haar measures coincide up to a multiplicative
constant in a second countable group. -/
@[to_additive isAddHaarMeasure_eq_smul]
lemma isHaarMeasure_eq_smul [SecondCountableTopology G]
    (Œº' Œº : Measure G) [IsHaarMeasure Œº] [IsHaarMeasure Œº'] :
    ‚àÉ c : ‚Ñù‚â•0‚àû, c ‚â† 0 ‚àß c ‚â† ‚àû ‚àß Œº' = c ‚Ä¢ Œº :=
  isHaarMeasure_eq_smul_of_regular Œº' Œº
  -- one could use as well `isHaarMeasure_eq_smul_isHaarMeasure_of_innerRegular Œº' Œº`, as in a
  -- second countable topological space all Haar measures are regular and inner regular
#align measure_theory.measure.is_haar_measure_eq_smul_is_haar_measure MeasureTheory.Measure.isHaarMeasure_eq_smul
#align measure_theory.measure.is_add_haar_measure_eq_smul_is_add_haar_measure MeasureTheory.Measure.isAddHaarMeasure_eq_smul

/-- **Uniqueness of left-invariant measures**: Given two left-invariant probability measures which
are inner regular for finite measure sets with respect to compact sets, they coincide. -/
@[to_additive]
lemma isMulLeftInvariant_eq_of_isProbabilityMeasure
    (Œº' Œº : Measure G) [IsProbabilityMeasure Œº] [IsProbabilityMeasure Œº']
    [InnerRegularCompactLTTop Œº] [InnerRegularCompactLTTop Œº']
    [IsMulLeftInvariant Œº] [IsMulLeftInvariant Œº'] : Œº' = Œº := by
  rcases isMulLeftInvariant_eq_smul_of_regular Œº' Œº with ‚ü®c, hc‚ü©
  have : ((c : ‚Ñù‚â•0‚àû) ‚Ä¢ Œº) univ = Œº' univ := by rw [hc]; rfl
  simp only [smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, measure_univ, smul_eq_mul,
    mul_one, ENNReal.coe_eq_one] at this
  simp [hc, this]

/-- An invariant œÉ-finite measure is absolutely continuous with respect to a Haar measure in a
second countable grop. -/
@[to_additive
"An invariant measure is absolutely continuous with respect to an additive Haar measure. "]
theorem absolutelyContinuous_isHaarMeasure [LocallyCompactSpace G] [T2Space G]
    [SecondCountableTopology G] (Œº ŒΩ : Measure G)
    [SigmaFinite Œº] [IsMulLeftInvariant Œº] [IsHaarMeasure ŒΩ] : Œº ‚â™ ŒΩ := by
  have K : PositiveCompacts G := Classical.arbitrary _
  obtain ‚ü®c, -, -, h‚ü© : ‚àÉ c : ‚Ñù‚â•0‚àû, c ‚â† 0 ‚àß c ‚â† ‚àû ‚àß haarMeasure K = c ‚Ä¢ ŒΩ :=
    isHaarMeasure_eq_smul _ _
  rw [haarMeasure_unique Œº K, h, smul_smul]
  exact AbsolutelyContinuous.smul (Eq.absolutelyContinuous rfl) _

end Group

section CommGroup

variable {G : Type*} [CommGroup G] [TopologicalSpace G] [TopologicalGroup G]
  [MeasurableSpace G] [BorelSpace G] (Œº : Measure G) [IsHaarMeasure Œº]

/-- Any regular Haar measure is invariant under inversion in an abelian group. -/
@[to_additive "Any regular additive Haar measure is invariant under negation in an abelian group."]
instance (priority := 100) IsHaarMeasure.isInvInvariant_of_regular
    [LocallyCompactSpace G] [Regular Œº] : IsInvInvariant Œº := by
  -- the image measure is a Haar measure. By uniqueness up to multiplication, it is of the form
  -- `c Œº`. Applying again inversion, one gets the measure `c^2 Œº`. But since inversion is an
  -- involution, this is also `Œº`. Hence, `c^2 = 1`, which implies `c = 1`.
  constructor
  have : IsHaarMeasure Œº.inv := (MulEquiv.inv G).isHaarMeasure_map Œº continuous_inv continuous_inv
  obtain ‚ü®c, _, _, hc‚ü© : ‚àÉ c : ‚Ñù‚â•0‚àû, c ‚â† 0 ‚àß c ‚â† ‚àû ‚àß Œº.inv = c ‚Ä¢ Œº :=
    isHaarMeasure_eq_smul_of_regular _ _
  have : map Inv.inv (map Inv.inv Œº) = c ^ 2 ‚Ä¢ Œº := by
    rw [‚Üê inv_def Œº, hc, Measure.map_smul, ‚Üê inv_def Œº, hc, smul_smul, pow_two]
  have Œºeq : Œº = c ^ 2 ‚Ä¢ Œº := by
    rw [map_map continuous_inv.measurable continuous_inv.measurable] at this
    simpa only [inv_involutive, Involutive.comp_self, Measure.map_id]
  have K : PositiveCompacts G := Classical.arbitrary _
  have : c ^ 2 * Œº K = 1 ^ 2 * Œº K := by
    conv_rhs => rw [Œºeq]
    simp
  have : c ^ 2 = 1 ^ 2 :=
    (ENNReal.mul_eq_mul_right (measure_pos_of_nonempty_interior _ K.interior_nonempty).ne'
          K.isCompact.measure_lt_top.ne).1 this
  have : c = 1 := (ENNReal.pow_strictMono two_ne_zero).injective this
  rw [hc, this, one_smul]
#align measure_theory.measure.is_haar_measure.is_inv_invariant MeasureTheory.Measure.IsHaarMeasure.isInvInvariant_of_regular
#align measure_theory.measure.is_add_haar_measure.is_neg_invariant MeasureTheory.Measure.IsAddHaarMeasure.isNegInvariant_of_regular

/-- Any inner regular Haar measure is invariant under inversion in an abelian group. -/
@[to_additive "Any regular additive Haar measure is invariant under negation in an abelian group."]
instance (priority := 100) IsHaarMeasure.isInvInvariant_of_innerRegular
    [LocallyCompactSpace G] [InnerRegular Œº] : IsInvInvariant Œº := by
  -- the image measure is a Haar measure. By uniqueness up to multiplication, it is of the form
  -- `c Œº`. Applying again inversion, one gets the measure `c^2 Œº`. But since inversion is an
  -- involution, this is also `Œº`. Hence, `c^2 = 1`, which implies `c = 1`.
  constructor
  have : IsHaarMeasure Œº.inv := (MulEquiv.inv G).isHaarMeasure_map Œº continuous_inv continuous_inv
  obtain ‚ü®c, _, _, hc‚ü© : ‚àÉ c : ‚Ñù‚â•0‚àû, c ‚â† 0 ‚àß c ‚â† ‚àû ‚àß Œº.inv = c ‚Ä¢ Œº :=
    isHaarMeasure_eq_smul_of_innerRegular _ _
  have : map Inv.inv (map Inv.inv Œº) = c ^ 2 ‚Ä¢ Œº := by
    rw [‚Üê inv_def Œº, hc, Measure.map_smul, ‚Üê inv_def Œº, hc, smul_smul, pow_two]
  have Œºeq : Œº = c ^ 2 ‚Ä¢ Œº := by
    rw [map_map continuous_inv.measurable continuous_inv.measurable] at this
    simpa only [inv_involutive, Involutive.comp_self, Measure.map_id]
  have K : PositiveCompacts G := Classical.arbitrary _
  have : c ^ 2 * Œº K = 1 ^ 2 * Œº K := by
    conv_rhs => rw [Œºeq]
    simp
  have : c ^ 2 = 1 ^ 2 :=
    (ENNReal.mul_eq_mul_right (measure_pos_of_nonempty_interior _ K.interior_nonempty).ne'
          K.isCompact.measure_lt_top.ne).1 this
  have : c = 1 := (ENNReal.pow_strictMono two_ne_zero).injective this
  rw [hc, this, one_smul]

@[to_additive]
theorem measurePreserving_zpow [CompactSpace G] [RootableBy G ‚Ñ§]
    [InnerRegularCompactLTTop Œº] {n : ‚Ñ§} (hn : n ‚â† 0) :
    MeasurePreserving (fun g : G => g ^ n) Œº Œº :=
  { measurable := (continuous_zpow n).measurable
    map_eq := by
      let f := @zpowGroupHom G _ n
      have hf : Continuous f := continuous_zpow n
      have : (Œº.map f).IsHaarMeasure :=
        isHaarMeasure_map_of_isFiniteMeasure Œº f hf (RootableBy.surjective_pow G ‚Ñ§ hn)
      have : InnerRegular (Œº.map f) := InnerRegular.map_of_continuous hf
      obtain ‚ü®C, -, -, hC‚ü© := isHaarMeasure_eq_smul_of_innerRegular (Œº.map f) Œº
      suffices C = 1 by rwa [this, one_smul] at hC
      have h_univ : (Œº.map f) univ = Œº univ := by
        rw [map_apply_of_aemeasurable hf.measurable.aemeasurable MeasurableSet.univ,
          preimage_univ]
      have hŒº‚ÇÄ : Œº univ ‚â† 0 := IsOpenPosMeasure.open_pos univ isOpen_univ univ_nonempty
      have hŒº‚ÇÅ : Œº univ ‚â† ‚àû := CompactSpace.isFiniteMeasure.measure_univ_lt_top.ne
      rwa [hC, smul_apply, Algebra.id.smul_eq_mul, mul_comm, ‚Üê ENNReal.eq_div_iff hŒº‚ÇÄ hŒº‚ÇÅ,
        ENNReal.div_self hŒº‚ÇÄ hŒº‚ÇÅ] at h_univ }
#align measure_theory.measure.measure_preserving_zpow MeasureTheory.Measure.measurePreserving_zpow
#align measure_theory.measure.measure_preserving_zsmul MeasureTheory.Measure.measurePreserving_zsmul

@[to_additive]
theorem MeasurePreserving.zpow [CompactSpace G] [RootableBy G ‚Ñ§]
    [InnerRegularCompactLTTop Œº] {n : ‚Ñ§} (hn : n ‚â† 0) {X : Type*}
    [MeasurableSpace X] {Œº' : Measure X} {f : X ‚Üí G} (hf : MeasurePreserving f Œº' Œº) :
    MeasurePreserving (fun x => f x ^ n) Œº' Œº :=
  (measurePreserving_zpow Œº hn).comp hf
#align measure_theory.measure.measure_preserving.zpow MeasureTheory.Measure.MeasurePreserving.zpow
#align measure_theory.measure.measure_preserving.zsmul MeasureTheory.Measure.MeasurePreserving.zsmul

end CommGroup

end Measure

end MeasureTheory
