/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro

! This file was ported from Lean 3 source module measure_theory.measure.measure_space
! leanprover-community/mathlib commit 88fcb83fe7996142dfcfe7368d31304a9adc874a
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathlib.MeasureTheory.Measure.NullMeasurable
import Mathlib.MeasureTheory.MeasurableSpace
import Mathlib.Topology.Algebra.Order.LiminfLimsup
import Mathlib.Tactic

/-!
# Measure spaces

The definition of a measure and a measure space are in `measure_theory.measure_space_def`, with
only a few basic properties. This file provides many more properties of these objects.
This separation allows the measurability tactic to import only the file `measure_space_def`, and to
be available in `measure_space` (through `measurable_space`).

Given a measurable space `Œ±`, a measure on `Œ±` is a function that sends measurable sets to the
extended nonnegative reals that satisfies the following conditions:
1. `Œº ‚àÖ = 0`;
2. `Œº` is countably additive. This means that the measure of a countable union of pairwise disjoint
   sets is equal to the measure of the individual sets.

Every measure can be canonically extended to an outer measure, so that it assigns values to
all subsets, not just the measurable subsets. On the other hand, a measure that is countably
additive on measurable sets can be restricted to measurable sets to obtain a measure.
In this file a measure is defined to be an outer measure that is countably additive on
measurable sets, with the additional assumption that the outer measure is the canonical
extension of the restricted measure.

Measures on `Œ±` form a complete lattice, and are closed under scalar multiplication with `‚Ñù‚â•0‚àû`.

We introduce the following typeclasses for measures:

* `is_probability_measure Œº`: `Œº univ = 1`;
* `is_finite_measure Œº`: `Œº univ < ‚àû`;
* `sigma_finite Œº`: there exists a countable collection of sets that cover `univ`
  where `Œº` is finite;
* `is_locally_finite_measure Œº` : `‚àÄ x, ‚àÉ s ‚àà ùìù x, Œº s < ‚àû`;
* `has_no_atoms Œº` : `‚àÄ x, Œº {x} = 0`; possibly should be redefined as
  `‚àÄ s, 0 < Œº s ‚Üí ‚àÉ t ‚äÜ s, 0 < Œº t ‚àß Œº t < Œº s`.

Given a measure, the null sets are the sets where `Œº s = 0`, where `Œº` denotes the corresponding
outer measure (so `s` might not be measurable). We can then define the completion of `Œº` as the
measure on the least `œÉ`-algebra that also contains all null sets, by defining the measure to be `0`
on the null sets.

## Main statements

* `completion` is the completion of a measure to all null measurable sets.
* `measure.of_measurable` and `outer_measure.to_measure` are two important ways to define a measure.

## Implementation notes

Given `Œº : measure Œ±`, `Œº s` is the value of the *outer measure* applied to `s`.
This conveniently allows us to apply the measure to sets without proving that they are measurable.
We get countable subadditivity for all sets, but only countable additivity for measurable sets.

You often don't want to define a measure via its constructor.
Two ways that are sometimes more convenient:
* `measure.of_measurable` is a way to define a measure by only giving its value on measurable sets
  and proving the properties (1) and (2) mentioned above.
* `outer_measure.to_measure` is a way of obtaining a measure from an outer measure by showing that
  all measurable sets in the measurable space are Carath√©odory measurable.

To prove that two measures are equal, there are multiple options:
* `ext`: two measures are equal if they are equal on all measurable sets.
* `ext_of_generate_from_of_Union`: two measures are equal if they are equal on a œÄ-system generating
  the measurable sets, if the œÄ-system contains a spanning increasing sequence of sets where the
  measures take finite value (in particular the measures are œÉ-finite). This is a special case of
  the more general `ext_of_generate_from_of_cover`
* `ext_of_generate_finite`: two finite measures are equal if they are equal on a œÄ-system
  generating the measurable sets. This is a special case of `ext_of_generate_from_of_Union` using
  `C ‚à™ {univ}`, but is easier to work with.

A `measure_space` is a class that is a measurable space with a canonical measure.
The measure is denoted `volume`.

## References

* <https://en.wikipedia.org/wiki/Measure_(mathematics)>
* <https://en.wikipedia.org/wiki/Complete_measure>
* <https://en.wikipedia.org/wiki/Almost_everywhere>

## Tags

measure, almost everywhere, measure space, completion, null set, null measurable set
-/


noncomputable section

open Set

open Filter hiding map

open Function MeasurableSpace

open TopologicalSpace (SecondCountableTopology)

open Classical Topology BigOperators Filter ENNReal NNReal Interval MeasureTheory

variable {Œ± Œ≤ Œ≥ Œ¥ Œπ R R' : Type _}

namespace MeasureTheory

section

variable {m : MeasurableSpace Œ±} {Œº Œº‚ÇÅ Œº‚ÇÇ : Measure Œ±} {s s‚ÇÅ s‚ÇÇ t : Set Œ±}

instance ae_isMeasurablyGenerated : IsMeasurablyGenerated Œº.ae :=
  ‚ü®fun _s hs =>
    let ‚ü®t, hst, htm, htŒº‚ü© := exists_measurable_superset_of_null hs
    ‚ü®t·∂ú, compl_mem_ae_iff.2 htŒº, htm.compl, compl_subset_comm.1 hst‚ü©‚ü©
#align measure_theory.ae_is_measurably_generated MeasureTheory.ae_isMeasurablyGenerated

/-- See also `measure_theory.ae_restrict_uIoc_iff`. -/
theorem ae_uIoc_iff [LinearOrder Œ±] {a b : Œ±} {P : Œ± ‚Üí Prop} :
    (‚àÄ·µê x ‚àÇŒº, x ‚àà Œô a b ‚Üí P x) ‚Üî (‚àÄ·µê x ‚àÇŒº, x ‚àà Ioc a b ‚Üí P x) ‚àß ‚àÄ·µê x ‚àÇŒº, x ‚àà Ioc b a ‚Üí P x := by
  simp only [uIoc_eq_union, mem_union, or_imp, eventually_and]
#align measure_theory.ae_uIoc_iff MeasureTheory.ae_uIoc_iff

theorem measure_union (hd : Disjoint s‚ÇÅ s‚ÇÇ) (h : MeasurableSet s‚ÇÇ) : Œº (s‚ÇÅ ‚à™ s‚ÇÇ) = Œº s‚ÇÅ + Œº s‚ÇÇ :=
  measure_union‚ÇÄ h.nullMeasurableSet hd.AeDisjoint
#align measure_theory.measure_union MeasureTheory.measure_union

theorem measure_union' (hd : Disjoint s‚ÇÅ s‚ÇÇ) (h : MeasurableSet s‚ÇÅ) : Œº (s‚ÇÅ ‚à™ s‚ÇÇ) = Œº s‚ÇÅ + Œº s‚ÇÇ :=
  measure_union‚ÇÄ' h.nullMeasurableSet hd.AeDisjoint
#align measure_theory.measure_union' MeasureTheory.measure_union'

theorem measure_inter_add_diff (s : Set Œ±) (ht : MeasurableSet t) : Œº (s ‚à© t) + Œº (s \ t) = Œº s :=
  measure_inter_add_diff‚ÇÄ _ ht.nullMeasurableSet
#align measure_theory.measure_inter_add_diff MeasureTheory.measure_inter_add_diff

theorem measure_diff_add_inter (s : Set Œ±) (ht : MeasurableSet t) : Œº (s \ t) + Œº (s ‚à© t) = Œº s :=
  (add_comm _ _).trans (measure_inter_add_diff s ht)
#align measure_theory.measure_diff_add_inter MeasureTheory.measure_diff_add_inter

theorem measure_union_add_inter (s : Set Œ±) (ht : MeasurableSet t) :
    Œº (s ‚à™ t) + Œº (s ‚à© t) = Œº s + Œº t := by
  rw [‚Üê measure_inter_add_diff (s ‚à™ t) ht, Set.union_inter_cancel_right, union_diff_right, ‚Üê
    measure_inter_add_diff s ht]
  ac_rfl
#align measure_theory.measure_union_add_inter MeasureTheory.measure_union_add_inter

theorem measure_union_add_inter' (hs : MeasurableSet s) (t : Set Œ±) :
    Œº (s ‚à™ t) + Œº (s ‚à© t) = Œº s + Œº t := by
  rw [union_comm, inter_comm, measure_union_add_inter t hs, add_comm]
#align measure_theory.measure_union_add_inter' MeasureTheory.measure_union_add_inter'

theorem measure_add_measure_compl (h : MeasurableSet s) : Œº s + Œº (s·∂ú) = Œº univ :=
  measure_add_measure_compl‚ÇÄ h.nullMeasurableSet
#align measure_theory.measure_add_measure_compl MeasureTheory.measure_add_measure_compl

theorem measure_bunion·µ¢‚ÇÄ {s : Set Œ≤} {f : Œ≤ ‚Üí Set Œ±} (hs : s.Countable)
    (hd : s.Pairwise (AeDisjoint Œº on f)) (h : ‚àÄ b ‚àà s, NullMeasurableSet (f b) Œº) :
    Œº (‚ãÉ b ‚àà s, f b) = ‚àë' p : s, Œº (f p) := by
  haveI := hs.toEncodable
  rw [bunion·µ¢_eq_union·µ¢]
  exact measure_union·µ¢‚ÇÄ (hd.on_injective Subtype.coe_injective fun x => x.2) fun x => h x x.2
#align measure_theory.measure_bUnion‚ÇÄ MeasureTheory.measure_bunion·µ¢‚ÇÄ

theorem measure_bunion·µ¢ {s : Set Œ≤} {f : Œ≤ ‚Üí Set Œ±} (hs : s.Countable) (hd : s.PairwiseDisjoint f)
    (h : ‚àÄ b ‚àà s, MeasurableSet (f b)) : Œº (‚ãÉ b ‚àà s, f b) = ‚àë' p : s, Œº (f p) :=
  measure_bunion·µ¢‚ÇÄ hs hd.AeDisjoint fun b hb => (h b hb).nullMeasurableSet
#align measure_theory.measure_bUnion MeasureTheory.measure_bunion·µ¢

theorem measure_union‚Çõ‚ÇÄ {S : Set (Set Œ±)} (hs : S.Countable) (hd : S.Pairwise (AeDisjoint Œº))
    (h : ‚àÄ s ‚àà S, NullMeasurableSet s Œº) : Œº (‚ãÉ‚ÇÄ S) = ‚àë' s : S, Œº s := by
  rw [union‚Çõ_eq_bunion·µ¢, measure_bunion·µ¢‚ÇÄ hs hd h]
#align measure_theory.measure_sUnion‚ÇÄ MeasureTheory.measure_union‚Çõ‚ÇÄ

theorem measure_union‚Çõ {S : Set (Set Œ±)} (hs : S.Countable) (hd : S.Pairwise Disjoint)
    (h : ‚àÄ s ‚àà S, MeasurableSet s) : Œº (‚ãÉ‚ÇÄ S) = ‚àë' s : S, Œº s := by
  rw [union‚Çõ_eq_bunion·µ¢, measure_bunion·µ¢ hs hd h]
#align measure_theory.measure_sUnion MeasureTheory.measure_union‚Çõ

theorem measure_bunion·µ¢_finset‚ÇÄ {s : Finset Œπ} {f : Œπ ‚Üí Set Œ±}
    (hd : Set.Pairwise (‚Üës) (AeDisjoint Œº on f)) (hm : ‚àÄ b ‚àà s, NullMeasurableSet (f b) Œº) :
    Œº (‚ãÉ b ‚àà s, f b) = ‚àë p in s, Œº (f p) := by
  rw [‚Üê Finset.sum_attach, Finset.attach_eq_univ, ‚Üê tsum_fintype]
  exact measure_bunion·µ¢‚ÇÄ s.countable_toSet hd hm
#align measure_theory.measure_bUnion_finset‚ÇÄ MeasureTheory.measure_bunion·µ¢_finset‚ÇÄ

theorem measure_bunion·µ¢_finset {s : Finset Œπ} {f : Œπ ‚Üí Set Œ±} (hd : PairwiseDisjoint (‚Üës) f)
    (hm : ‚àÄ b ‚àà s, MeasurableSet (f b)) : Œº (‚ãÉ b ‚àà s, f b) = ‚àë p in s, Œº (f p) :=
  measure_bunion·µ¢_finset‚ÇÄ hd.AeDisjoint fun b hb => (hm b hb).nullMeasurableSet
#align measure_theory.measure_bUnion_finset MeasureTheory.measure_bunion·µ¢_finset

/-- The measure of a disjoint union (even uncountable) of measurable sets is at least the sum of
the measures of the sets. -/
theorem tsum_meas_le_meas_union·µ¢_of_disjoint {Œπ : Type _} [MeasurableSpace Œ±] (Œº : Measure Œ±)
    {As : Œπ ‚Üí Set Œ±} (As_mble : ‚àÄ i : Œπ, MeasurableSet (As i))
    (As_disj : Pairwise (Disjoint on As)) : (‚àë' i, Œº (As i)) ‚â§ Œº (‚ãÉ i, As i) := by
  rcases show Summable fun i => Œº (As i) from ENNReal.summable with ‚ü®S, hS‚ü©
  rw [hS.tsum_eq]
  refine' tendsto_le_of_eventuallyLE hS tendsto_const_nhds (eventually_of_forall _)
  intro s
  simp [‚Üê measure_bunion·µ¢_finset (fun _i _hi _j _hj hij => As_disj hij) fun i _ => As_mble i]
  exact measure_mono (union·µ¢‚ÇÇ_subset_union·µ¢ (fun i : Œπ => i ‚àà s) fun i : Œπ => As i)
#align measure_theory.tsum_meas_le_meas_Union_of_disjoint MeasureTheory.tsum_meas_le_meas_union·µ¢_of_disjoint

/-- If `s` is a countable set, then the measure of its preimage can be found as the sum of measures
of the fibers `f ‚Åª¬π' {y}`. -/
theorem tsum_measure_preimage_singleton {s : Set Œ≤} (hs : s.Countable) {f : Œ± ‚Üí Œ≤}
    (hf : ‚àÄ y ‚àà s, MeasurableSet (f ‚Åª¬π' {y})) : (‚àë' b : s, Œº (f ‚Åª¬π' {‚Üëb})) = Œº (f ‚Åª¬π' s) := by
  rw [‚Üê Set.bunion·µ¢_preimage_singleton, measure_bunion·µ¢ hs (pairwiseDisjoint_fiber f s) hf]
#align measure_theory.tsum_measure_preimage_singleton MeasureTheory.tsum_measure_preimage_singleton

/-- If `s` is a `finset`, then the measure of its preimage can be found as the sum of measures
of the fibers `f ‚Åª¬π' {y}`. -/
theorem sum_measure_preimage_singleton (s : Finset Œ≤) {f : Œ± ‚Üí Œ≤}
    (hf : ‚àÄ y ‚àà s, MeasurableSet (f ‚Åª¬π' {y})) : (‚àë b in s, Œº (f ‚Åª¬π' {b})) = Œº (f ‚Åª¬π' ‚Üës) := by
  simp only [‚Üê measure_bunion·µ¢_finset (pairwiseDisjoint_fiber f s) hf,
    Finset.set_bunion·µ¢_preimage_singleton]
#align measure_theory.sum_measure_preimage_singleton MeasureTheory.sum_measure_preimage_singleton

theorem measure_diff_null' (h : Œº (s‚ÇÅ ‚à© s‚ÇÇ) = 0) : Œº (s‚ÇÅ \ s‚ÇÇ) = Œº s‚ÇÅ :=
  measure_congr <| diff_ae_eq_self.2 h
#align measure_theory.measure_diff_null' MeasureTheory.measure_diff_null'

theorem measure_diff_null (h : Œº s‚ÇÇ = 0) : Œº (s‚ÇÅ \ s‚ÇÇ) = Œº s‚ÇÅ :=
  measure_diff_null' <| measure_mono_null (inter_subset_right _ _) h
#align measure_theory.measure_diff_null MeasureTheory.measure_diff_null

theorem measure_add_diff (hs : MeasurableSet s) (t : Set Œ±) : Œº s + Œº (t \ s) = Œº (s ‚à™ t) := by
  rw [‚Üê measure_union' (@disjoint_sdiff_right _ s t) hs, union_diff_self]
#align measure_theory.measure_add_diff MeasureTheory.measure_add_diff

theorem measure_diff' (s : Set Œ±) (hm : MeasurableSet t) (h_fin : Œº t ‚â† ‚àû) :
    Œº (s \ t) = Œº (s ‚à™ t) - Œº t :=
  Eq.symm <| ENNReal.sub_eq_of_add_eq h_fin <| by rw [add_comm, measure_add_diff hm, union_comm]
#align measure_theory.measure_diff' MeasureTheory.measure_diff'

theorem measure_diff (h : s‚ÇÇ ‚äÜ s‚ÇÅ) (h‚ÇÇ : MeasurableSet s‚ÇÇ) (h_fin : Œº s‚ÇÇ ‚â† ‚àû) :
    Œº (s‚ÇÅ \ s‚ÇÇ) = Œº s‚ÇÅ - Œº s‚ÇÇ := by rw [measure_diff' _ h‚ÇÇ h_fin, union_eq_self_of_subset_right h]
#align measure_theory.measure_diff MeasureTheory.measure_diff

theorem le_measure_diff : Œº s‚ÇÅ - Œº s‚ÇÇ ‚â§ Œº (s‚ÇÅ \ s‚ÇÇ) :=
  tsub_le_iff_left.2 <|
    calc
      Œº s‚ÇÅ ‚â§ Œº (s‚ÇÇ ‚à™ s‚ÇÅ) := measure_mono (subset_union_right _ _)
      _ = Œº (s‚ÇÇ ‚à™ s‚ÇÅ \ s‚ÇÇ) := (congr_arg Œº union_diff_self.symm)
      _ ‚â§ Œº s‚ÇÇ + Œº (s‚ÇÅ \ s‚ÇÇ) := measure_union_le _ _

#align measure_theory.le_measure_diff MeasureTheory.le_measure_diff

theorem measure_diff_lt_of_lt_add (hs : MeasurableSet s) (hst : s ‚äÜ t) (hs' : Œº s ‚â† ‚àû) {Œµ : ‚Ñù‚â•0‚àû}
    (h : Œº t < Œº s + Œµ) : Œº (t \ s) < Œµ := by
  rw [measure_diff hst hs hs']; rw [add_comm] at h
  exact ENNReal.sub_lt_of_lt_add (measure_mono hst) h
#align measure_theory.measure_diff_lt_of_lt_add MeasureTheory.measure_diff_lt_of_lt_add

theorem measure_diff_le_iff_le_add (hs : MeasurableSet s) (hst : s ‚äÜ t) (hs' : Œº s ‚â† ‚àû) {Œµ : ‚Ñù‚â•0‚àû} :
    Œº (t \ s) ‚â§ Œµ ‚Üî Œº t ‚â§ Œº s + Œµ := by rw [measure_diff hst hs hs', tsub_le_iff_left]
#align measure_theory.measure_diff_le_iff_le_add MeasureTheory.measure_diff_le_iff_le_add

theorem measure_eq_measure_of_null_diff {s t : Set Œ±} (hst : s ‚äÜ t) (h_nulldiff : Œº (t \ s) = 0) :
    Œº s = Œº t := measure_congr <|
      EventuallyLE.antisymm (HasSubset.Subset.eventuallyLE hst) (ae_le_set.mpr h_nulldiff)
#align measure_theory.measure_eq_measure_of_null_diff MeasureTheory.measure_eq_measure_of_null_diff

theorem measure_eq_measure_of_between_null_diff {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Set Œ±} (h12 : s‚ÇÅ ‚äÜ s‚ÇÇ) (h23 : s‚ÇÇ ‚äÜ s‚ÇÉ)
    (h_nulldiff : Œº (s‚ÇÉ \ s‚ÇÅ) = 0) : Œº s‚ÇÅ = Œº s‚ÇÇ ‚àß Œº s‚ÇÇ = Œº s‚ÇÉ := by
  have le12 : Œº s‚ÇÅ ‚â§ Œº s‚ÇÇ := measure_mono h12
  have le23 : Œº s‚ÇÇ ‚â§ Œº s‚ÇÉ := measure_mono h23
  have key : Œº s‚ÇÉ ‚â§ Œº s‚ÇÅ :=
    calc
      Œº s‚ÇÉ = Œº (s‚ÇÉ \ s‚ÇÅ ‚à™ s‚ÇÅ) := by rw [diff_union_of_subset (h12.trans h23)]
      _ ‚â§ Œº (s‚ÇÉ \ s‚ÇÅ) + Œº s‚ÇÅ := (measure_union_le _ _)
      _ = Œº s‚ÇÅ := by simp only [h_nulldiff, zero_add]

  exact ‚ü®le12.antisymm (le23.trans key), le23.antisymm (key.trans le12)‚ü©
#align measure_theory.measure_eq_measure_of_between_null_diff MeasureTheory.measure_eq_measure_of_between_null_diff

theorem measure_eq_measure_smaller_of_between_null_diff {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Set Œ±} (h12 : s‚ÇÅ ‚äÜ s‚ÇÇ)
    (h23 : s‚ÇÇ ‚äÜ s‚ÇÉ) (h_nulldiff : Œº (s‚ÇÉ \ s‚ÇÅ) = 0) : Œº s‚ÇÅ = Œº s‚ÇÇ :=
  (measure_eq_measure_of_between_null_diff h12 h23 h_nulldiff).1
#align measure_theory.measure_eq_measure_smaller_of_between_null_diff MeasureTheory.measure_eq_measure_smaller_of_between_null_diff

theorem measure_eq_measure_larger_of_between_null_diff {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Set Œ±} (h12 : s‚ÇÅ ‚äÜ s‚ÇÇ)
    (h23 : s‚ÇÇ ‚äÜ s‚ÇÉ) (h_nulldiff : Œº (s‚ÇÉ \ s‚ÇÅ) = 0) : Œº s‚ÇÇ = Œº s‚ÇÉ :=
  (measure_eq_measure_of_between_null_diff h12 h23 h_nulldiff).2
#align measure_theory.measure_eq_measure_larger_of_between_null_diff MeasureTheory.measure_eq_measure_larger_of_between_null_diff

theorem measure_compl (h‚ÇÅ : MeasurableSet s) (h_fin : Œº s ‚â† ‚àû) : Œº (s·∂ú) = Œº univ - Œº s := by
  rw [compl_eq_univ_diff]
  exact measure_diff (subset_univ s) h‚ÇÅ h_fin
#align measure_theory.measure_compl MeasureTheory.measure_compl

@[simp]
theorem union_ae_eq_left_iff_ae_subset : (s ‚à™ t : Set Œ±) =·µê[Œº] s ‚Üî t ‚â§·µê[Œº] s := by
  rw [ae_le_set]
  refine'
    ‚ü®fun h => by simpa only [union_diff_left] using (ae_eq_set.mp h).1, fun h =>
      eventuallyLE_antisymm_iff.mpr
        ‚ü®by rwa [ae_le_set, union_diff_left],
          HasSubset.Subset.eventuallyLE <| subset_union_left s t‚ü©‚ü©
#align measure_theory.union_ae_eq_left_iff_ae_subset MeasureTheory.union_ae_eq_left_iff_ae_subset

@[simp]
theorem union_ae_eq_right_iff_ae_subset : (s ‚à™ t : Set Œ±) =·µê[Œº] t ‚Üî s ‚â§·µê[Œº] t := by
  rw [union_comm, union_ae_eq_left_iff_ae_subset]
#align measure_theory.union_ae_eq_right_iff_ae_subset MeasureTheory.union_ae_eq_right_iff_ae_subset

theorem ae_eq_of_ae_subset_of_measure_ge (h‚ÇÅ : s ‚â§·µê[Œº] t) (h‚ÇÇ : Œº t ‚â§ Œº s) (hsm : MeasurableSet s)
    (ht : Œº t ‚â† ‚àû) : s =·µê[Œº] t := by
  refine' eventuallyLE_antisymm_iff.mpr ‚ü®h‚ÇÅ, ae_le_set.mpr _‚ü©
  replace h‚ÇÇ : Œº t = Œº s; exact h‚ÇÇ.antisymm (measure_mono_ae h‚ÇÅ)
  replace ht : Œº s ‚â† ‚àû; exact h‚ÇÇ ‚ñ∏ ht
  rw [measure_diff' t hsm ht, measure_congr (union_ae_eq_left_iff_ae_subset.mpr h‚ÇÅ), h‚ÇÇ, tsub_self]
#align measure_theory.ae_eq_of_ae_subset_of_measure_ge MeasureTheory.ae_eq_of_ae_subset_of_measure_ge

/-- If `s ‚äÜ t`, `Œº t ‚â§ Œº s`, `Œº t ‚â† ‚àû`, and `s` is measurable, then `s =·µê[Œº] t`. -/
theorem ae_eq_of_subset_of_measure_ge (h‚ÇÅ : s ‚äÜ t) (h‚ÇÇ : Œº t ‚â§ Œº s) (hsm : MeasurableSet s)
    (ht : Œº t ‚â† ‚àû) : s =·µê[Œº] t :=
  ae_eq_of_ae_subset_of_measure_ge (HasSubset.Subset.eventuallyLE h‚ÇÅ) h‚ÇÇ hsm ht
#align measure_theory.ae_eq_of_subset_of_measure_ge MeasureTheory.ae_eq_of_subset_of_measure_ge

theorem measure_union·µ¢_congr_of_subset [Countable Œ≤] {s : Œ≤ ‚Üí Set Œ±} {t : Œ≤ ‚Üí Set Œ±}
    (hsub : ‚àÄ b, s b ‚äÜ t b) (h_le : ‚àÄ b, Œº (t b) ‚â§ Œº (s b)) : Œº (‚ãÉ b, s b) = Œº (‚ãÉ b, t b) := by
  rcases Classical.em (‚àÉ b, Œº (t b) = ‚àû) with (‚ü®b, hb‚ü© | htop)
  ¬∑
    calc
      Œº (‚ãÉ b, s b) = ‚àû := top_unique (hb ‚ñ∏ (h_le b).trans <| measure_mono <| subset_union·µ¢ _ _)
      _ = Œº (‚ãÉ b, t b) := Eq.symm <| top_unique <| hb ‚ñ∏ measure_mono (subset_union·µ¢ _ _)

  push_neg  at htop
  refine' le_antisymm (measure_mono (union·µ¢_mono hsub)) _
  set M := toMeasurable Œº
  have H : ‚àÄ b, (M (t b) ‚à© M (‚ãÉ b, s b) : Set Œ±) =·µê[Œº] M (t b) := by
    refine' fun b => ae_eq_of_subset_of_measure_ge (inter_subset_left _ _) _ _ _
    ¬∑
      calc
        Œº (M (t b)) = Œº (t b) := measure_toMeasurable _
        _ ‚â§ Œº (s b) := (h_le b)
        _ ‚â§ Œº (M (t b) ‚à© M (‚ãÉ b, s b)) :=
          measure_mono <|
            subset_inter ((hsub b).trans <| subset_toMeasurable _ _)
              ((subset_union·µ¢ _ _).trans <| subset_toMeasurable _ _)

    ¬∑ exact (measurableSet_toMeasurable _ _).inter (measurableSet_toMeasurable _ _)
    ¬∑ rw [measure_toMeasurable]
      exact htop b
  calc
    Œº (‚ãÉ b, t b) ‚â§ Œº (‚ãÉ b, M (t b)) := measure_mono (union·µ¢_mono fun b => subset_toMeasurable _ _)
    _ = Œº (‚ãÉ b, M (t b) ‚à© M (‚ãÉ b, s b)) := (measure_congr (EventuallyEq.countable_union·µ¢ H).symm)
    _ ‚â§ Œº (M (‚ãÉ b, s b)) := (measure_mono (union·µ¢_subset fun b => inter_subset_right _ _))
    _ = Œº (‚ãÉ b, s b) := measure_toMeasurable _

#align measure_theory.measure_Union_congr_of_subset MeasureTheory.measure_union·µ¢_congr_of_subset

theorem measure_union_congr_of_subset {t‚ÇÅ t‚ÇÇ : Set Œ±} (hs : s‚ÇÅ ‚äÜ s‚ÇÇ) (hsŒº : Œº s‚ÇÇ ‚â§ Œº s‚ÇÅ)
    (ht : t‚ÇÅ ‚äÜ t‚ÇÇ) (htŒº : Œº t‚ÇÇ ‚â§ Œº t‚ÇÅ) : Œº (s‚ÇÅ ‚à™ t‚ÇÅ) = Œº (s‚ÇÇ ‚à™ t‚ÇÇ) := by
  rw [union_eq_union·µ¢, union_eq_union·µ¢]
  exact measure_union·µ¢_congr_of_subset (Bool.forall_bool.2 ‚ü®ht, hs‚ü©) (Bool.forall_bool.2 ‚ü®htŒº, hsŒº‚ü©)
#align measure_theory.measure_union_congr_of_subset MeasureTheory.measure_union_congr_of_subset

@[simp]
theorem measure_union·µ¢_toMeasurable [Countable Œ≤] (s : Œ≤ ‚Üí Set Œ±) :
    Œº (‚ãÉ b, toMeasurable Œº (s b)) = Œº (‚ãÉ b, s b) :=
  Eq.symm <|
    measure_union·µ¢_congr_of_subset (fun _b => subset_toMeasurable _ _) fun _b =>
      (measure_toMeasurable _).le
#align measure_theory.measure_Union_to_measurable MeasureTheory.measure_union·µ¢_toMeasurable

theorem measure_bunion·µ¢_toMeasurable {I : Set Œ≤} (hc : I.Countable) (s : Œ≤ ‚Üí Set Œ±) :
    Œº (‚ãÉ b ‚àà I, toMeasurable Œº (s b)) = Œº (‚ãÉ b ‚àà I, s b) := by
  haveI := hc.toEncodable
  simp only [bunion·µ¢_eq_union·µ¢, measure_union·µ¢_toMeasurable]
#align measure_theory.measure_bUnion_to_measurable MeasureTheory.measure_bunion·µ¢_toMeasurable

@[simp]
theorem measure_toMeasurable_union : Œº (toMeasurable Œº s ‚à™ t) = Œº (s ‚à™ t) :=
  Eq.symm <|
    measure_union_congr_of_subset (subset_toMeasurable _ _) (measure_toMeasurable _).le Subset.rfl
      le_rfl
#align measure_theory.measure_to_measurable_union MeasureTheory.measure_toMeasurable_union

@[simp]
theorem measure_union_toMeasurable : Œº (s ‚à™ toMeasurable Œº t) = Œº (s ‚à™ t) :=
  Eq.symm <|
    measure_union_congr_of_subset Subset.rfl le_rfl (subset_toMeasurable _ _)
      (measure_toMeasurable _).le
#align measure_theory.measure_union_to_measurable MeasureTheory.measure_union_toMeasurable

theorem sum_measure_le_measure_univ {s : Finset Œπ} {t : Œπ ‚Üí Set Œ±}
    (h : ‚àÄ i ‚àà s, MeasurableSet (t i)) (H : Set.PairwiseDisjoint (‚Üës) t) :
    (‚àë i in s, Œº (t i)) ‚â§ Œº (univ : Set Œ±) := by
  rw [‚Üê measure_bunion·µ¢_finset H h]
  exact measure_mono (subset_univ _)
#align measure_theory.sum_measure_le_measure_univ MeasureTheory.sum_measure_le_measure_univ

theorem tsum_measure_le_measure_univ {s : Œπ ‚Üí Set Œ±} (hs : ‚àÄ i, MeasurableSet (s i))
    (H : Pairwise (Disjoint on s)) : (‚àë' i, Œº (s i)) ‚â§ Œº (univ : Set Œ±) := by
  rw [ENNReal.tsum_eq_sup·µ¢_sum]
  exact sup·µ¢_le fun s => sum_measure_le_measure_univ (fun i _hi => hs i) fun i _hi j _hj hij => H hij
#align measure_theory.tsum_measure_le_measure_univ MeasureTheory.tsum_measure_le_measure_univ

/-- Pigeonhole principle for measure spaces: if `‚àë' i, Œº (s i) > Œº univ`, then
one of the intersections `s i ‚à© s j` is not empty. -/
theorem exists_nonempty_inter_of_measure_univ_lt_tsum_measure {m : MeasurableSpace Œ±}
    (Œº : Measure Œ±) {s : Œπ ‚Üí Set Œ±} (hs : ‚àÄ i, MeasurableSet (s i))
    (H : Œº (univ : Set Œ±) < ‚àë' i, Œº (s i)) : ‚àÉ (i j : _)(_h : i ‚â† j), (s i ‚à© s j).Nonempty := by
  contrapose! H
  apply tsum_measure_le_measure_univ hs
  intro i j hij
  rw [Function.onFun, disjoint_iff_inf_le]
  exact fun x hx => H i j hij ‚ü®x, hx‚ü©
#align measure_theory.exists_nonempty_inter_of_measure_univ_lt_tsum_measure MeasureTheory.exists_nonempty_inter_of_measure_univ_lt_tsum_measure

/-- Pigeonhole principle for measure spaces: if `s` is a `finset` and
`‚àë i in s, Œº (t i) > Œº univ`, then one of the intersections `t i ‚à© t j` is not empty. -/
theorem exists_nonempty_inter_of_measure_univ_lt_sum_measure {m : MeasurableSpace Œ±} (Œº : Measure Œ±)
    {s : Finset Œπ} {t : Œπ ‚Üí Set Œ±} (h : ‚àÄ i ‚àà s, MeasurableSet (t i))
    (H : Œº (univ : Set Œ±) < ‚àë i in s, Œº (t i)) :
    ‚àÉ i ‚àà s, ‚àÉ j ‚àà s, ‚àÉ _h : i ‚â† j, (t i ‚à© t j).Nonempty := by
  contrapose! H
  apply sum_measure_le_measure_univ h
  intro i hi j hj hij
  rw [Function.onFun, disjoint_iff_inf_le]
  exact fun x hx => H i hi j hj hij ‚ü®x, hx‚ü©
#align measure_theory.exists_nonempty_inter_of_measure_univ_lt_sum_measure MeasureTheory.exists_nonempty_inter_of_measure_univ_lt_sum_measure

/-- If two sets `s` and `t` are included in a set `u`, and `Œº s + Œº t > Œº u`,
then `s` intersects `t`. Version assuming that `t` is measurable. -/
theorem nonempty_inter_of_measure_lt_add {m : MeasurableSpace Œ±} (Œº : Measure Œ±) {s t u : Set Œ±}
    (ht : MeasurableSet t) (h's : s ‚äÜ u) (h't : t ‚äÜ u) (h : Œº u < Œº s + Œº t) : (s ‚à© t).Nonempty :=
  by
  rw [‚Üê Set.not_disjoint_iff_nonempty_inter]
  contrapose! h
  calc
    Œº s + Œº t = Œº (s ‚à™ t) := (measure_union h ht).symm
    _ ‚â§ Œº u := measure_mono (union_subset h's h't)

#align measure_theory.nonempty_inter_of_measure_lt_add MeasureTheory.nonempty_inter_of_measure_lt_add

/-- If two sets `s` and `t` are included in a set `u`, and `Œº s + Œº t > Œº u`,
then `s` intersects `t`. Version assuming that `s` is measurable. -/
theorem nonempty_inter_of_measure_lt_add' {m : MeasurableSpace Œ±} (Œº : Measure Œ±) {s t u : Set Œ±}
    (hs : MeasurableSet s) (h's : s ‚äÜ u) (h't : t ‚äÜ u) (h : Œº u < Œº s + Œº t) : (s ‚à© t).Nonempty :=
  by
  rw [add_comm] at h
  rw [inter_comm]
  exact nonempty_inter_of_measure_lt_add Œº hs h't h's h
#align measure_theory.nonempty_inter_of_measure_lt_add' MeasureTheory.nonempty_inter_of_measure_lt_add'

/-- Continuity from below: the measure of the union of a directed sequence of (not necessarily
-measurable) sets is the supremum of the measures. -/
theorem measure_union·µ¢_eq_sup·µ¢ [Countable Œπ] {s : Œπ ‚Üí Set Œ±} (hd : Directed (¬∑ ‚äÜ ¬∑) s) :
    Œº (‚ãÉ i, s i) = ‚®Ü i, Œº (s i) := by
  cases nonempty_encodable Œπ
  -- WLOG, `Œπ = ‚Ñï`
  generalize ht : Function.extend Encodable.encode s ‚ä• = t
  replace hd : Directed (¬∑ ‚äÜ ¬∑) t := ht ‚ñ∏ hd.extend_bot Encodable.encode_injective
  suffices Œº (‚ãÉ n, t n) = ‚®Ü n, Œº (t n) by
    simp only [‚Üê ht, Encodable.encode_injective.apply_extend Œº, ‚Üê sup·µ¢_eq_union·µ¢,
      sup·µ¢_extend_bot Encodable.encode_injective, (¬∑ ‚àò ¬∑), Pi.bot_apply, bot_eq_empty,
      measure_empty] at this
    exact this.trans (sup·µ¢_extend_bot Encodable.encode_injective _)
  clear! Œπ
  -- The `‚â•` inequality is trivial
  refine' le_antisymm _ (sup·µ¢_le fun i => measure_mono <| subset_union·µ¢ _ _)
  -- Choose `T n ‚äá t n` of the same measure, put `Td n = disjointed T`
  set T : ‚Ñï ‚Üí Set Œ± := fun n => toMeasurable Œº (t n)
  set Td : ‚Ñï ‚Üí Set Œ± := disjointed T
  have hm : ‚àÄ n, MeasurableSet (Td n) :=
    MeasurableSet.disjointed fun n => measurableSet_toMeasurable _ _
  calc
    Œº (‚ãÉ n, t n) ‚â§ Œº (‚ãÉ n, T n) := measure_mono (union·µ¢_mono fun i => subset_toMeasurable _ _)
    _ = Œº (‚ãÉ n, Td n) := by rw [union·µ¢_disjointed]
    _ ‚â§ ‚àë' n, Œº (Td n) := (measure_union·µ¢_le _)
    _ = ‚®Ü I : Finset ‚Ñï, ‚àë n in I, Œº (Td n) := ENNReal.tsum_eq_sup·µ¢_sum
    _ ‚â§ ‚®Ü n, Œº (t n) := sup·µ¢_le fun I => by
      rcases hd.finset_le I with ‚ü®N, hN‚ü©
      calc
        (‚àë n in I, Œº (Td n)) = Œº (‚ãÉ n ‚àà I, Td n) :=
          (measure_bunion·µ¢_finset ((disjoint_disjointed T).set_pairwise I) fun n _ => hm n).symm
        _ ‚â§ Œº (‚ãÉ n ‚àà I, T n) := (measure_mono (union·µ¢‚ÇÇ_mono fun n _hn => disjointed_subset _ _))
        _ = Œº (‚ãÉ n ‚àà I, t n) := (measure_bunion·µ¢_toMeasurable I.countable_toSet _)
        _ ‚â§ Œº (t N) := (measure_mono (union·µ¢‚ÇÇ_subset hN))
        _ ‚â§ ‚®Ü n, Œº (t n) := le_sup·µ¢ (Œº ‚àò t) N

#align measure_theory.measure_Union_eq_supr MeasureTheory.measure_union·µ¢_eq_sup·µ¢

theorem measure_bunion·µ¢_eq_sup·µ¢ {s : Œπ ‚Üí Set Œ±} {t : Set Œπ} (ht : t.Countable)
    (hd : DirectedOn ((¬∑ ‚äÜ ¬∑) on s) t) : Œº (‚ãÉ i ‚àà t, s i) = ‚®Ü i ‚àà t, Œº (s i) := by
  haveI := ht.toEncodable
  rw [bunion·µ¢_eq_union·µ¢, measure_union·µ¢_eq_sup·µ¢ hd.directed_val, ‚Üê sup·µ¢_subtype'']
#align measure_theory.measure_bUnion_eq_supr MeasureTheory.measure_bunion·µ¢_eq_sup·µ¢

/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t ¬´expr ‚äÜ ¬ª s k) -/
/-- Continuity from above: the measure of the intersection of a decreasing sequence of measurable
sets is the infimum of the measures. -/
theorem measure_inter·µ¢_eq_inf·µ¢ [Countable Œπ] {s : Œπ ‚Üí Set Œ±} (h : ‚àÄ i, MeasurableSet (s i))
    (hd : Directed (¬∑ ‚äá ¬∑) s) (hfin : ‚àÉ i, Œº (s i) ‚â† ‚àû) : Œº (‚ãÇ i, s i) = ‚®Ö i, Œº (s i) := by
  rcases hfin with ‚ü®k, hk‚ü©
  have : ‚àÄ (t) (_ : t ‚äÜ s k), Œº t ‚â† ‚àû := fun t ht => ne_top_of_le_ne_top hk (measure_mono ht)
  rw [‚Üê ENNReal.sub_sub_cancel hk (inf·µ¢_le _ k), ENNReal.sub_inf·µ¢, ‚Üê
    ENNReal.sub_sub_cancel hk (measure_mono (inter·µ¢_subset _ k)), ‚Üê
    measure_diff (inter·µ¢_subset _ k) (MeasurableSet.inter·µ¢ h) (this _ (inter·µ¢_subset _ k)),
    diff_inter·µ¢, measure_union·µ¢_eq_sup·µ¢]
  ¬∑ congr 1
    refine' le_antisymm (sup·µ¢_mono' fun i => _) (sup·µ¢_mono fun i => _)
    ¬∑ rcases hd i k with ‚ü®j, hji, hjk‚ü©
      use j
      rw [‚Üê measure_diff hjk (h _) (this _ hjk)]
      exact measure_mono (diff_subset_diff_right hji)
    ¬∑ rw [tsub_le_iff_right, ‚Üê measure_union, Set.union_comm]
      exact measure_mono (diff_subset_iff.1 <| Subset.refl _)
      apply disjoint_sdiff_left
      apply h i
  ¬∑ exact hd.mono_comp _ fun _ _ => diff_subset_diff_right
#align measure_theory.measure_Inter_eq_infi MeasureTheory.measure_inter·µ¢_eq_inf·µ¢

/-- Continuity from below: the measure of the union of an increasing sequence of measurable sets
is the limit of the measures. -/
theorem tendsto_measure_union·µ¢ [SemilatticeSup Œπ] [Countable Œπ] {s : Œπ ‚Üí Set Œ±} (hm : Monotone s) :
    Tendsto (Œº ‚àò s) atTop (ùìù (Œº (‚ãÉ n, s n))) := by
  rw [measure_union·µ¢_eq_sup·µ¢ (directed_of_sup hm)]
  exact tendsto_atTop_sup·µ¢ fun n m hnm => measure_mono <| hm hnm
#align measure_theory.tendsto_measure_Union MeasureTheory.tendsto_measure_union·µ¢

/-- Continuity from above: the measure of the intersection of a decreasing sequence of measurable
sets is the limit of the measures. -/
theorem tendsto_measure_inter·µ¢ [Countable Œπ] [SemilatticeSup Œπ] {s : Œπ ‚Üí Set Œ±}
    (hs : ‚àÄ n, MeasurableSet (s n)) (hm : Antitone s) (hf : ‚àÉ i, Œº (s i) ‚â† ‚àû) :
    Tendsto (Œº ‚àò s) atTop (ùìù (Œº (‚ãÇ n, s n))) := by
  rw [measure_inter·µ¢_eq_inf·µ¢ hs (directed_of_sup hm) hf]
  exact tendsto_atTop_inf·µ¢ fun n m hnm => measure_mono <| hm hnm
#align measure_theory.tendsto_measure_Inter MeasureTheory.tendsto_measure_inter·µ¢

/-- The measure of the intersection of a decreasing sequence of measurable
sets indexed by a linear order with first countable topology is the limit of the measures. -/
theorem tendsto_measure_binter·µ¢_gt {Œπ : Type _} [LinearOrder Œπ] [TopologicalSpace Œπ]
    [OrderTopology Œπ] [DenselyOrdered Œπ] [TopologicalSpace.FirstCountableTopology Œπ] {s : Œπ ‚Üí Set Œ±}
    {a : Œπ} (hs : ‚àÄ r > a, MeasurableSet (s r)) (hm : ‚àÄ i j, a < i ‚Üí i ‚â§ j ‚Üí s i ‚äÜ s j)
    (hf : ‚àÉ r > a, Œº (s r) ‚â† ‚àû) : Tendsto (Œº ‚àò s) (ùìù[Ioi a] a) (ùìù (Œº (‚ãÇ r > a, s r))) := by
  refine' tendsto_order.2 ‚ü®fun l hl => _, fun L hL => _‚ü©
  ¬∑
    filter_upwards [self_mem_nhdsWithin (s:=Ioi a)] with r hr using hl.trans_le
        (measure_mono (binter·µ¢_subset_of_mem hr))
  obtain ‚ü®u, u_anti, u_pos, u_lim‚ü© :
    ‚àÉ u : ‚Ñï ‚Üí Œπ, StrictAnti u ‚àß (‚àÄ n : ‚Ñï, a < u n) ‚àß Tendsto u atTop (ùìù a) := by
    rcases hf with ‚ü®r, ar, _‚ü©
    rcases exists_seq_strictAnti_tendsto' ar with ‚ü®w, w_anti, w_mem, w_lim‚ü©
    exact ‚ü®w, w_anti, fun n => (w_mem n).1, w_lim‚ü©
  have A : Tendsto (Œº ‚àò s ‚àò u) atTop (ùìù (Œº (‚ãÇ n, s (u n)))) := by
    refine' tendsto_measure_inter·µ¢ (fun n => hs _ (u_pos n)) _ _
    ¬∑ intro m n hmn
      exact hm _ _ (u_pos n) (u_anti.antitone hmn)
    ¬∑ rcases hf with ‚ü®r, rpos, hr‚ü©
      obtain ‚ü®n, hn‚ü© : ‚àÉ n : ‚Ñï, u n < r := ((tendsto_order.1 u_lim).2 r rpos).exists
      refine' ‚ü®n, ne_of_lt (lt_of_le_of_lt _ hr.lt_top)‚ü©
      exact measure_mono (hm _ _ (u_pos n) hn.le)
  have B : (‚ãÇ n, s (u n)) = ‚ãÇ r > a, s r := by
    apply Subset.antisymm
    ¬∑ simp only [subset_inter·µ¢_iff, gt_iff_lt]
      intro r rpos
      obtain ‚ü®n, hn‚ü© : ‚àÉ n, u n < r := ((tendsto_order.1 u_lim).2 _ rpos).exists
      exact Subset.trans (inter·µ¢_subset _ n) (hm (u n) r (u_pos n) hn.le)
    ¬∑ simp only [subset_inter·µ¢_iff, gt_iff_lt]
      intro n
      apply binter·µ¢_subset_of_mem
      exact u_pos n
  rw [B] at A
  obtain ‚ü®n, hn‚ü© : ‚àÉ n, Œº (s (u n)) < L := ((tendsto_order.1 A).2 _ hL).exists
  have : Ioc a (u n) ‚àà ùìù[>] a := Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, u_pos n‚ü©
  filter_upwards [this]with r hr using lt_of_le_of_lt (measure_mono (hm _ _ hr.1 hr.2)) hn
#align measure_theory.tendsto_measure_bInter_gt MeasureTheory.tendsto_measure_binter·µ¢_gt

/-- One direction of the **Borel-Cantelli lemma**: if (s·µ¢) is a sequence of sets such
that `‚àë Œº s·µ¢` is finite, then the limit superior of the `s·µ¢` is a null set. -/
theorem measure_limsup_eq_zero {s : ‚Ñï ‚Üí Set Œ±} (hs : (‚àë' i, Œº (s i)) ‚â† ‚àû) :
    Œº (limsup s atTop) = 0 := by
  -- First we replace the sequence `s‚Çô` with a sequence of measurable sets `t‚Çô ‚äá s‚Çô` of the same
  -- measure.
  set t : ‚Ñï ‚Üí Set Œ± := fun n => toMeasurable Œº (s n)
  have ht : (‚àë' i, Œº (t i)) ‚â† ‚àû := by simpa only [measure_toMeasurable] using hs
  suffices Œº (limsup t atTop) = 0 by
    have A : s ‚â§ t := fun n => subset_toMeasurable Œº (s n)
    -- TODO default args fail
    exact
      measure_mono_null
        (limsup_le_limsup (eventually_of_forall (Pi.le_def.mp A)) isCobounded_le_of_bot
          isBounded_le_of_top)
        this
  -- Next we unfold `limsup` for sets and replace equality with an inequality
  simp only [limsup_eq_inf·µ¢_sup·µ¢_of_nat', Set.inf·µ¢_eq_inter·µ¢, Set.sup·µ¢_eq_union·µ¢, ‚Üê
    nonpos_iff_eq_zero]
  -- Finally, we estimate `Œº (‚ãÉ i, t (i + n))` by `‚àë i', Œº (t (i + n))`
  refine'
    le_of_tendsto_of_tendsto'
      (tendsto_measure_inter·µ¢
        (fun i => MeasurableSet.union·µ¢ fun b => measurableSet_toMeasurable _ _) _
        ‚ü®0, ne_top_of_le_ne_top ht (measure_union·µ¢_le t)‚ü©)
      (ENNReal.tendsto_sum_nat_add (Œº ‚àò t) ht) fun n => measure_union·µ¢_le _
  intro n m hnm x
  simp only [Set.mem_union·µ¢]
  exact fun ‚ü®i, hi‚ü© => ‚ü®i + (m - n), by simpa only [add_assoc, tsub_add_cancel_of_le hnm] using hi‚ü©
#align measure_theory.measure_limsup_eq_zero MeasureTheory.measure_limsup_eq_zero

/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic filter.is_bounded_default -/
/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic filter.is_bounded_default -/
theorem measure_liminf_eq_zero {s : ‚Ñï ‚Üí Set Œ±} (h : (‚àë' i, Œº (s i)) ‚â† ‚ä§) : Œº (liminf s atTop) = 0 :=
  by
  rw [‚Üê le_zero_iff]
  have : liminf s atTop ‚â§ limsup s atTop :=
    liminf_le_limsup
      (by isBoundedDefault)
      (by isBoundedDefault)
  exact (Œº.mono this).trans (by simp [measure_limsup_eq_zero h])
#align measure_theory.measure_liminf_eq_zero MeasureTheory.measure_liminf_eq_zero

theorem limsup_ae_eq_of_forall_ae_eq (s : ‚Ñï ‚Üí Set Œ±) {t : Set Œ±}
    (h : ‚àÄ n, s n =·µê[Œº] t) :-- Need `@` below because of diamond; see gh issue #16932
        @limsup
        (Set Œ±) ‚Ñï _ s atTop =·µê[Œº]
      t := by
  simp_rw [ae_eq_set] at h‚ä¢
  constructor
  ¬∑ rw [atTop.limsup_sdiff s t]
    apply measure_limsup_eq_zero
    simp [h]
  ¬∑ rw [atTop.sdiff_limsup s t]
    apply measure_liminf_eq_zero
    simp [h]
#align measure_theory.limsup_ae_eq_of_forall_ae_eq MeasureTheory.limsup_ae_eq_of_forall_ae_eq

theorem liminf_ae_eq_of_forall_ae_eq (s : ‚Ñï ‚Üí Set Œ±) {t : Set Œ±}
    (h : ‚àÄ n, s n =·µê[Œº] t) :-- Need `@` below because of diamond; see gh issue #16932
        @liminf
        (Set Œ±) ‚Ñï _ s atTop =·µê[Œº]
      t := by
  simp_rw [ae_eq_set] at h‚ä¢
  constructor
  ¬∑ rw [atTop.liminf_sdiff s t]
    apply measure_liminf_eq_zero
    simp [h]
  ¬∑ rw [atTop.sdiff_liminf s t]
    apply measure_limsup_eq_zero
    simp [h]
#align measure_theory.liminf_ae_eq_of_forall_ae_eq MeasureTheory.liminf_ae_eq_of_forall_ae_eq

theorem measure_if {x : Œ≤} {t : Set Œ≤} {s : Set Œ±} :
    Œº (if x ‚àà t then s else ‚àÖ) = indicator t (fun _ => Œº s) x := by split_ifs with h <;> simp [h]
#align measure_theory.measure_if MeasureTheory.measure_if

end
