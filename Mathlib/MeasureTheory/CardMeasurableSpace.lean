/-
Copyright (c) 2022 SÃ©bastien GouÃ«zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: SÃ©bastien GouÃ«zel, Violeta HernÃ¡ndez Palacios

! This file was ported from Lean 3 source module measure_theory.card_measurable_space
! leanprover-community/mathlib commit f2b108e8e97ba393f22bf794989984ddcc1da89b
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.MeasureTheory.MeasurableSpaceDef
import Mathbin.SetTheory.Cardinal.Cofinality
import Mathbin.SetTheory.Cardinal.Continuum

/-!
# Cardinal of sigma-algebras

If a sigma-algebra is generated by a set of sets `s`, then the cardinality of the sigma-algebra is
bounded by `(max (#s) 2) ^ â„µâ‚€`. This is stated in `measurable_space.cardinal_generate_measurable_le`
and `measurable_space.cardinal_measurable_set_le`.

In particular, if `#s â‰¤ ğ” `, then the generated sigma-algebra has cardinality at most `ğ” `, see
`measurable_space.cardinal_measurable_set_le_continuum`.

For the proof, we rely on an explicit inductive construction of the sigma-algebra generated by
`s` (instead of the inductive predicate `generate_measurable`). This transfinite inductive
construction is parameterized by an ordinal `< Ï‰â‚`, and the cardinality bound is preserved along
each step of the construction. We show in `measurable_space.generate_measurable_eq_rec` that this
indeed generates this sigma-algebra.
-/


universe u

variable {Î± : Type u}

open Cardinal

open Cardinal Set

-- mathport name: exprÏ‰â‚
local notation "Ï‰â‚" => (aleph 1 : Cardinal.{u}).ord.out.Î±

namespace MeasurableSpace

/-- Transfinite induction construction of the sigma-algebra generated by a set of sets `s`. At each
step, we add all elements of `s`, the empty set, the complements of already constructed sets, and
countable unions of already constructed sets. We index this construction by an ordinal `< Ï‰â‚`, as
this will be enough to generate all sets in the sigma-algebra.

This construction is very similar to that of the Borel hierarchy. -/
def generateMeasurableRec (s : Set (Set Î±)) : Ï‰â‚ â†’ Set (Set Î±)
  | i =>
    let S := â‹ƒ j : Iio i, generate_measurable_rec j.1
    s âˆª {âˆ…} âˆª compl '' S âˆª Set.range fun f : â„• â†’ S => â‹ƒ n, (f n).1decreasing_by
  exact j.2
#align measurable_space.generate_measurable_rec MeasurableSpace.generateMeasurableRec

theorem self_subset_generateMeasurableRec (s : Set (Set Î±)) (i : Ï‰â‚) :
    s âŠ† generateMeasurableRec s i :=
  by
  unfold generate_measurable_rec
  apply_rules [subset_union_of_subset_left]
  exact subset_rfl
#align measurable_space.self_subset_generate_measurable_rec MeasurableSpace.self_subset_generateMeasurableRec

theorem empty_mem_generateMeasurableRec (s : Set (Set Î±)) (i : Ï‰â‚) :
    âˆ… âˆˆ generateMeasurableRec s i :=
  by
  unfold generate_measurable_rec
  exact mem_union_left _ (mem_union_left _ (mem_union_right _ (mem_singleton âˆ…)))
#align measurable_space.empty_mem_generate_measurable_rec MeasurableSpace.empty_mem_generateMeasurableRec

theorem compl_mem_generateMeasurableRec {s : Set (Set Î±)} {i j : Ï‰â‚} (h : j < i) {t : Set Î±}
    (ht : t âˆˆ generateMeasurableRec s j) : tá¶œ âˆˆ generateMeasurableRec s i :=
  by
  unfold generate_measurable_rec
  exact mem_union_left _ (mem_union_right _ âŸ¨t, mem_Union.2 âŸ¨âŸ¨j, hâŸ©, htâŸ©, rflâŸ©)
#align measurable_space.compl_mem_generate_measurable_rec MeasurableSpace.compl_mem_generateMeasurableRec

theorem unionáµ¢_mem_generateMeasurableRec {s : Set (Set Î±)} {i : Ï‰â‚} {f : â„• â†’ Set Î±}
    (hf : âˆ€ n, âˆƒ j < i, f n âˆˆ generateMeasurableRec s j) : (â‹ƒ n, f n) âˆˆ generateMeasurableRec s i :=
  by
  unfold generate_measurable_rec
  exact
    mem_union_right _
      âŸ¨fun n =>
        âŸ¨f n,
          let âŸ¨j, hj, hfâŸ© := hf n
          mem_Union.2 âŸ¨âŸ¨j, hjâŸ©, hfâŸ©âŸ©,
        rflâŸ©
#align measurable_space.Union_mem_generate_measurable_rec MeasurableSpace.unionáµ¢_mem_generateMeasurableRec

theorem generateMeasurableRec_subset (s : Set (Set Î±)) {i j : Ï‰â‚} (h : i â‰¤ j) :
    generateMeasurableRec s i âŠ† generateMeasurableRec s j := fun x hx =>
  by
  rcases eq_or_lt_of_le h with (rfl | h)
  Â· exact hx
  Â· convert Union_mem_generate_measurable_rec fun n => âŸ¨i, h, hxâŸ©
    exact (Union_const x).symm
#align measurable_space.generate_measurable_rec_subset MeasurableSpace.generateMeasurableRec_subset

/-- At each step of the inductive construction, the cardinality bound `â‰¤ (max (#s) 2) ^ â„µâ‚€` holds.
-/
theorem cardinal_generateMeasurableRec_le (s : Set (Set Î±)) (i : Ï‰â‚) :
    (#generateMeasurableRec s i) â‰¤ max (#s) 2 ^ aleph0.{u} :=
  by
  apply (aleph 1).ord.out.wo.wf.induction i
  intro i IH
  have A := aleph_0_le_aleph 1
  have B : aleph 1 â‰¤ max (#s) 2 ^ aleph0.{u} :=
    aleph_one_le_continuum.trans (power_le_power_right (le_max_right _ _))
  have C : â„µâ‚€ â‰¤ max (#s) 2 ^ aleph0.{u} := A.trans B
  have J : (#â‹ƒ j : Iio i, generate_measurable_rec s j.1) â‰¤ max (#s) 2 ^ aleph0.{u} :=
    by
    apply (mk_Union_le _).trans
    have D : (â¨† j : Iio i, #generate_measurable_rec s j) â‰¤ _ := csupáµ¢_le' fun âŸ¨j, hjâŸ© => IH j hj
    apply (mul_le_mul' ((mk_subtype_le _).trans (aleph 1).mk_ord_out.le) D).trans
    rw [mul_eq_max A C]
    exact max_le B le_rfl
  rw [generate_measurable_rec]
  apply_rules [(mk_union_le _ _).trans, add_le_of_le C, mk_image_le.trans]
  Â· exact (le_max_left _ _).trans (self_le_power _ one_lt_aleph_0.le)
  Â· rw [mk_singleton]
    exact one_lt_aleph_0.le.trans C
  Â· apply mk_range_le.trans
    simp only [mk_pi, Subtype.val_eq_coe, prod_const, lift_uzero, mk_denumerable, lift_aleph_0]
    have := @power_le_power_right _ _ â„µâ‚€ J
    rwa [â† power_mul, aleph_0_mul_aleph_0] at this
#align measurable_space.cardinal_generate_measurable_rec_le MeasurableSpace.cardinal_generateMeasurableRec_le

/-- `generate_measurable_rec s` generates precisely the smallest sigma-algebra containing `s`. -/
theorem generateMeasurable_eq_rec (s : Set (Set Î±)) :
    { t | GenerateMeasurable s t } = â‹ƒ i, generateMeasurableRec s i :=
  by
  ext t; refine' âŸ¨fun ht => _, fun ht => _âŸ©
  Â· inhabit Ï‰â‚
    induction' ht with u hu u hu IH f hf IH
    Â· exact mem_Union.2 âŸ¨default, self_subset_generate_measurable_rec s _ huâŸ©
    Â· exact mem_Union.2 âŸ¨default, empty_mem_generate_measurable_rec s _âŸ©
    Â· rcases mem_Union.1 IH with âŸ¨i, hiâŸ©
      obtain âŸ¨j, hjâŸ© := exists_gt i
      exact mem_Union.2 âŸ¨j, compl_mem_generate_measurable_rec hj hiâŸ©
    Â· have : âˆ€ n, âˆƒ i, f n âˆˆ generate_measurable_rec s i := fun n => by simpa using IH n
      choose I hI using this
      refine'
        mem_Union.2
          âŸ¨Ordinal.enum (Â· < Â·) (Ordinal.lsub fun n => Ordinal.typein.{u} (Â· < Â·) (I n)) _,
            Union_mem_generate_measurable_rec fun n => âŸ¨I n, _, hI nâŸ©âŸ©
      Â· rw [Ordinal.type_lt]
        refine' Ordinal.lsub_lt_ord_lift _ fun i => Ordinal.typein_lt_self _
        rw [mk_denumerable, lift_aleph_0, is_regular_aleph_one.cof_eq]
        exact aleph_0_lt_aleph_one
      Â· rw [â† Ordinal.typein_lt_typein (Â· < Â·), Ordinal.typein_enum]
        apply Ordinal.lt_lsub fun n : â„• => _
  Â· rcases ht with âŸ¨t, âŸ¨i, rflâŸ©, hxâŸ©
    revert t
    apply (aleph 1).ord.out.wo.wf.induction i
    intro j H t ht
    unfold generate_measurable_rec at ht
    rcases ht with (((h | h) | âŸ¨u, âŸ¨-, âŸ¨âŸ¨k, hkâŸ©, rflâŸ©, huâŸ©, rflâŸ©) | âŸ¨f, rflâŸ©)
    Â· exact generate_measurable.basic t h
    Â· convert generate_measurable.empty
    Â· exact generate_measurable.compl u (H k hk u hu)
    Â· apply generate_measurable.union _ fun n => _
      obtain âŸ¨-, âŸ¨âŸ¨k, hkâŸ©, rflâŸ©, hfâŸ© := (f n).Prop
      exact H k hk _ hf
#align measurable_space.generate_measurable_eq_rec MeasurableSpace.generateMeasurable_eq_rec

/-- If a sigma-algebra is generated by a set of sets `s`, then the sigma-algebra has cardinality at
most `(max (#s) 2) ^ â„µâ‚€`. -/
theorem cardinal_generateMeasurable_le (s : Set (Set Î±)) :
    (#{ t | GenerateMeasurable s t }) â‰¤ max (#s) 2 ^ aleph0.{u} :=
  by
  rw [generate_measurable_eq_rec]
  apply (mk_Union_le _).trans
  rw [(aleph 1).mk_ord_out]
  refine'
    le_trans
      (mul_le_mul' aleph_one_le_continuum
        (csupáµ¢_le' fun i => cardinal_generate_measurable_rec_le s i))
      _
  have := power_le_power_right (le_max_right (#s) 2)
  rw [mul_eq_max aleph_0_le_continuum (aleph_0_le_continuum.trans this)]
  exact max_le this le_rfl
#align measurable_space.cardinal_generate_measurable_le MeasurableSpace.cardinal_generateMeasurable_le

/-- If a sigma-algebra is generated by a set of sets `s`, then the sigma
algebra has cardinality at most `(max (#s) 2) ^ â„µâ‚€`. -/
theorem cardinal_measurableSet_le (s : Set (Set Î±)) :
    (#{ t | @MeasurableSet Î± (generateFrom s) t }) â‰¤ max (#s) 2 ^ aleph0.{u} :=
  cardinal_generateMeasurable_le s
#align measurable_space.cardinal_measurable_set_le MeasurableSpace.cardinal_measurableSet_le

/-- If a sigma-algebra is generated by a set of sets `s` with cardinality at most the continuum,
then the sigma algebra has the same cardinality bound. -/
theorem cardinal_generateMeasurable_le_continuum {s : Set (Set Î±)} (hs : (#s) â‰¤ ğ” ) :
    (#{ t | GenerateMeasurable s t }) â‰¤ ğ”  :=
  (cardinal_generateMeasurable_le s).trans
    (by
      rw [â† continuum_power_aleph_0]
      exact_mod_cast power_le_power_right (max_le hs (nat_lt_continuum 2).le))
#align measurable_space.cardinal_generate_measurable_le_continuum MeasurableSpace.cardinal_generateMeasurable_le_continuum

/-- If a sigma-algebra is generated by a set of sets `s` with cardinality at most the continuum,
then the sigma algebra has the same cardinality bound. -/
theorem cardinal_measurableSet_le_continuum {s : Set (Set Î±)} :
    (#s) â‰¤ ğ”  â†’ (#{ t | @MeasurableSet Î± (generateFrom s) t }) â‰¤ ğ”  :=
  cardinal_generateMeasurable_le_continuum
#align measurable_space.cardinal_measurable_set_le_continuum MeasurableSpace.cardinal_measurableSet_le_continuum

end MeasurableSpace

