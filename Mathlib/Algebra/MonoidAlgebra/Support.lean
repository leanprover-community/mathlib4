/-
Copyright (c) 2022 Damiano Testa. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Damiano Testa
-/
module

public import Mathlib.Algebra.Group.Embedding
public import Mathlib.Algebra.MonoidAlgebra.Module
public import Mathlib.LinearAlgebra.Finsupp.Supported
public import Mathlib.Algebra.Group.Pointwise.Finset.Basic

import Mathlib.LinearAlgebra.Span.Basic

/-!
# Lemmas about the support of a finitely supported function
-/

public section

open scoped Pointwise

universe u₁ u₂ u₃

namespace MonoidAlgebra

open Finset Finsupp

variable {k : Type u₁} {G : Type u₂} [Semiring k]

section Mul
variable [Mul G]

@[to_additive (dont_translate := k) support_coeff_mul_subset]
theorem support_coeff_mul_subset [DecidableEq G] (a b : k[G]) :
    (a * b).coeff.support ⊆ a.coeff.support * b.coeff.support := by
  simp only [MonoidAlgebra.mul_def, coeff_finsuppSum]
  grw [Finsupp.support_sum, biUnion_subset]
  rintro x hx
  grw [Finsupp.support_sum, biUnion_subset]
  exact fun y hy ↦ support_single_subset.trans <| singleton_subset_iff.2 <| mem_image₂_of_mem hx hy

@[to_additive (dont_translate := k) support_coeff_single_mul_subset]
lemma support_coeff_single_mul_subset [DecidableEq G] (f : k[G]) (r : k) (a : G) :
    (single a r * f : k[G]).coeff.support ⊆ Finset.image (a * ·) f.coeff.support := by
  grw [support_coeff_mul_subset, coeff_single, support_single_subset]
  change image₂ _ _ _ ⊆ _
  rw [image₂_singleton_left]

@[to_additive (dont_translate := k) support_coeff_mul_single_subset]
theorem support_coeff_mul_single_subset [DecidableEq G] (f : k[G]) (r : k) (a : G) :
    (f * single a r).coeff.support ⊆ Finset.image (· * a) f.coeff.support := by
  grw [support_coeff_mul_subset, coeff_single, support_single_subset]
  change image₂ _ _ _ ⊆ _
  rw [image₂_singleton_right]

@[to_additive (dont_translate := k) support_coeff_single_mul_eq_image]
theorem support_coeff_single_mul_eq_image [DecidableEq G] (f : k[G]) {r : k}
    (hr : ∀ y, r * y = 0 ↔ y = 0) {x : G} (lx : IsLeftRegular x) :
    (single x r * f : k[G]).coeff.support = Finset.image (x * ·) f.coeff.support := by
  refine subset_antisymm (support_coeff_single_mul_subset f _ _) fun y hy => ?_
  obtain ⟨y, yf, rfl⟩ : ∃ a ∈ f.coeff.support, x * a = y := by grind
  simp [coeff_mul, mem_support_iff.mp yf, hr, lx.eq_iff]

@[to_additive (dont_translate := k) support_coeff_mul_single_eq_image]
theorem support_coeff_mul_single_eq_image [DecidableEq G] (f : k[G]) {r : k}
    (hr : ∀ y, y * r = 0 ↔ y = 0) {x : G} (rx : IsRightRegular x) :
    (f * single x r).coeff.support = Finset.image (· * x) f.coeff.support := by
  refine subset_antisymm (support_coeff_mul_single_subset f _ _) fun y hy => ?_
  obtain ⟨y, yf, rfl⟩ : ∃ a : G, a ∈ f.coeff.support ∧ a * x = y := by grind
  simp [coeff_mul, mem_support_iff.mp yf, hr, rx.eq_iff]

@[to_additive (dont_translate := k) support_coeff_mul_single]
theorem support_coeff_mul_single [IsRightCancelMul G] (f : k[G]) (r : k)
    (hr : ∀ y, y * r = 0 ↔ y = 0) (x : G) :
    (f * single x r).coeff.support = f.coeff.support.map (mulRightEmbedding x) := by
  classical ext; simp [support_coeff_mul_single_eq_image f hr (.all x)]

@[to_additive (dont_translate := k) support_coeff_single_mul]
theorem support_coeff_single_mul [IsLeftCancelMul G] (f : k[G]) (r : k)
    (hr : ∀ y, r * y = 0 ↔ y = 0) (x : G) :
    (single x r * f : k[G]).coeff.support =
      f.coeff.support.map (mulLeftEmbedding x) := by
  classical ext; simp [support_coeff_single_mul_eq_image f hr (.all x)]

end Mul

@[to_additive (dont_translate := k) support_coeff_one_subset]
lemma support_coeff_one_subset [One G] : (1 : k[G]).coeff.support ⊆ 1 :=
  Finsupp.support_single_subset

@[to_additive (dont_translate := k) (attr := simp) support_coeff_one]
lemma support_coeff_one [One G] [NeZero (1 : k)] : (1 : k[G]).coeff.support = 1 :=
  Finsupp.support_single_ne_zero _ one_ne_zero

section Span

/-- An element of `k[G]` is in the subalgebra generated by its support. -/
theorem mem_span_support_coeff [MulOneClass G] (f : k[G]) :
    f ∈ Submodule.span k (of k G '' f.coeff.support) := by
  simp [of, ← supported_eq_span_single, mem_supported]

end Span

end MonoidAlgebra

namespace AddMonoidAlgebra

open Finset Finsupp MulOpposite

variable {k : Type u₁} {G : Type u₂} [Semiring k]

section Span

/-- An element of `k[G]` is in the submodule generated by its support. -/
theorem mem_span_support (f : k[G]) : f ∈ Submodule.span k (of' k G '' f.coeff.support) := by
  simp [of', ← supported_eq_span_single, mem_supported]

@[deprecated (since := "2025-12-08")] alias mem_span_support' := mem_span_support

end Span

end AddMonoidAlgebra
