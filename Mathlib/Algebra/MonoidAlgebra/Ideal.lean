/-
Copyright (c) 2023 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser
-/
import Mathlib.Algebra.MonoidAlgebra.Division
import Mathlib.RingTheory.Ideal.Basic

#align_import algebra.monoid_algebra.ideal from "leanprover-community/mathlib"@"72c366d0475675f1309d3027d3d7d47ee4423951"

/-!
# Lemmas about ideals of `MonoidAlgebra` and `AddMonoidAlgebra`
-/


variable {k A G : Type*}

/-- If `x` belongs to the ideal generated by generators in `s`, then every element of the support of
`x` factors through an element of `s`.

We could spell `âˆƒ d, m = d * m` as `MulOpposite.op m' âˆ£ MulOpposite.op m` but this would be worse.
-/
theorem MonoidAlgebra.mem_ideal_span_of_image [Monoid G] [Semiring k] {s : Set G}
    {x : MonoidAlgebra k G} :
    x âˆˆ Ideal.span (MonoidAlgebra.of k G '' s) â†” âˆ€ m âˆˆ x.support, âˆƒ m' âˆˆ s, âˆƒ d, m = d * m' := by
  let RHS : Ideal (MonoidAlgebra k G) :=
    { carrier := { p | âˆ€ m : G, m âˆˆ p.support â†’ âˆƒ m' âˆˆ s, âˆƒ d, m = d * m' }
      add_mem' := fun {x y} hx hy m hm => by
        classical exact (Finset.mem_union.1 <| Finsupp.support_add hm).elim (hx m) (hy m)
      zero_mem' := fun m hm => by cases hm
      smul_mem' := fun x y hy m hm => by
        classical
        replace hm := Finset.mem_biUnion.mp (Finsupp.support_sum hm)
        obtain âŸ¨xm, -, hmâŸ© := hm
        replace hm := Finset.mem_biUnion.mp (Finsupp.support_sum hm)
        obtain âŸ¨ym, hym, hmâŸ© := hm
        replace hm := Finset.mem_singleton.mp (Finsupp.support_single_subset hm)
        obtain rfl := hm
        -- porting note: changed `Exists.imp` to `And.imp_right` due to change in `âˆƒ x âˆˆ s`
        -- elaboration
        refine' (hy _ hym).imp fun sm p => And.imp_right _ p
        rintro âŸ¨d, rflâŸ©
        exact âŸ¨xm * d, (mul_assoc _ _ _).symmâŸ© }
  change _ â†” x âˆˆ RHS
  -- âŠ¢ x âˆˆ Ideal.span (â†‘(of k G) '' s) â†” x âˆˆ RHS
  constructor
  -- âŠ¢ x âˆˆ Ideal.span (â†‘(of k G) '' s) â†’ x âˆˆ RHS
  Â· revert x
    -- âŠ¢ âˆ€ {x : MonoidAlgebra k G}, x âˆˆ Ideal.span (â†‘(of k G) '' s) â†’ x âˆˆ RHS
    rw [â†SetLike.le_def] -- porting note: refine needs this even though it's defeq?
    -- âŠ¢ Ideal.span (â†‘(of k G) '' s) â‰¤ RHS
    refine Ideal.span_le.2 ?_
    -- âŠ¢ â†‘(of k G) '' s âŠ† â†‘RHS
    rintro _ âŸ¨i, hi, rflâŸ© m hm
    -- âŠ¢ âˆƒ m', m' âˆˆ s âˆ§ âˆƒ d, m = d * m'
    refine' âŸ¨_, hi, 1, _âŸ©
    -- âŠ¢ m = 1 * i
    obtain rfl := Finset.mem_singleton.mp (Finsupp.support_single_subset hm)
    -- âŠ¢ m = 1 * m
    exact (one_mul _).symm
    -- ðŸŽ‰ no goals
  Â· intro hx
    -- âŠ¢ x âˆˆ Ideal.span (â†‘(of k G) '' s)
    rw [â† Finsupp.sum_single x]
    -- âŠ¢ Finsupp.sum x Finsupp.single âˆˆ Ideal.span (â†‘(of k G) '' s)
    refine Ideal.sum_mem _ fun i hi => ?_  -- porting note: changed `apply` to `refine`
    -- âŠ¢ Finsupp.single i (â†‘x i) âˆˆ Ideal.span (â†‘(of k G) '' s)
    obtain âŸ¨d, hd, d2, rflâŸ© := hx _ hi
    -- âŠ¢ Finsupp.single (d2 * d) (â†‘x (d2 * d)) âˆˆ Ideal.span (â†‘(of k G) '' s)
    convert Ideal.mul_mem_left _ (id <| Finsupp.single d2 <| x (d2 * d) : MonoidAlgebra k G) _
    pick_goal 3
    refine' Ideal.subset_span âŸ¨_, hd, rflâŸ©
    -- âŠ¢ Finsupp.single (d2 * d) (â†‘x (d2 * d)) = id (Finsupp.single d2 (â†‘x (d2 * d))) â€¦
    rw [id.def, MonoidAlgebra.of_apply, MonoidAlgebra.single_mul_single, mul_one]
    -- ðŸŽ‰ no goals
#align monoid_algebra.mem_ideal_span_of_image MonoidAlgebra.mem_ideal_span_of_image

/-- If `x` belongs to the ideal generated by generators in `s`, then every element of the support of
`x` factors additively through an element of `s`.
-/
theorem AddMonoidAlgebra.mem_ideal_span_of'_image [AddMonoid A] [Semiring k] {s : Set A}
    {x : AddMonoidAlgebra k A} :
    x âˆˆ Ideal.span (AddMonoidAlgebra.of' k A '' s) â†” âˆ€ m âˆˆ x.support, âˆƒ m' âˆˆ s, âˆƒ d, m = d + m' :=
  @MonoidAlgebra.mem_ideal_span_of_image k (Multiplicative A) _ _ _ _
#align add_monoid_algebra.mem_ideal_span_of'_image AddMonoidAlgebra.mem_ideal_span_of'_image
