/-
Copyright (c) 2017 Johannes Hölzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl, Yury Kudryashov, Kim Morrison
-/
module

public import Mathlib.Algebra.GroupWithZero.Action.TransferInstance
public import Mathlib.Algebra.Module.Defs
public import Mathlib.Data.Finsupp.Basic
public import Mathlib.Data.Finsupp.SMulWithZero

/-!
# Monoid algebras

When the domain of a `Finsupp` has a multiplicative or additive structure, we can define
a convolution product. To mathematicians this structure is known as the "monoid algebra",
i.e. the finite formal linear combinations over a given semiring of elements of a monoid `M`.
The "group ring" `ℤ[G]` or the "group algebra" `k[G]` are typical uses.

In fact the construction of the "monoid algebra" makes sense when `M` is not even a monoid, but
merely a magma, i.e., when `M` carries a multiplication which is not required to satisfy any
conditions at all. In this case the construction yields a not-necessarily-unital,
not-necessarily-associative algebra but it is still adjoint to the forgetful functor from such
algebras to magmas, and we prove this as `MonoidAlgebra.liftMagma`.

In this file we define `MonoidAlgebra R M` and `AddMonoidAlgebra R M` as one-field structures around
`M →₀ R`, and then define the convolution product on these.

When the domain is additive, this is used to define polynomials:
```
Polynomial R := AddMonoidAlgebra R ℕ
MvPolynomial σ α := AddMonoidAlgebra R (σ →₀ ℕ)
```

When the domain is multiplicative, e.g. a group, this will be used to define the group ring.

## Notation

We introduce the notation `R[M]` for both `MonoidAlgebra R M` and `AddMonoidAlgebra R M`.
The notations are scoped to their respective namespaces, and which one `R[M]` resolves to therefore
depends on which of the two namespaces is open.
-/

@[expose] public section

assert_not_exists NonUnitalAlgHom AlgEquiv

noncomputable section

open Finsupp hiding single

-- We make sure the additivisable argument comes first to avoid doing
-- `to_additive (relevant_arg := 2)` everywhere.
variable {G M N O ι R S : Type*}

/-- The additive monoid algebra over a semiring `R` generated by the additive monoid `M`.

It is the type of finite formal `R`-linear combinations of terms of `M`,
endowed with the convolution product. -/
structure AddMonoidAlgebra (R M : Type*) [Semiring R] where
  /-- Construct an element of the additive monoid algebra `R[M]`
  from its coefficients `M →₀ R`. -/
  ofCoeff ::
  /-- The coefficients `M →₀ R` of an element of the additive monoid algebra `R[M]`. -/
  coeff : M →₀ R

/-- The monoid algebra over a semiring `R` generated by the monoid `M`.

It is the type of finite formal `R`-linear combinations of terms of `M`,
endowed with the convolution product. -/
@[to_additive (relevant_arg := 2), to_additive_dont_translate]
structure MonoidAlgebra (R M : Type*) [Semiring R] where
  /-- Construct an element of the monoid algebra `R[M]`
  from its coefficients `M →₀ R`. -/
  ofCoeff ::
  /-- The coefficients `M →₀ R` of an element of the monoid algebra `R[M]`. -/
  coeff : M →₀ R

namespace AddMonoidAlgebra

open Lean.PrettyPrinter Delaborator

@[inherit_doc AddMonoidAlgebra]
scoped syntax:max (priority := high) term noWs "[" term "]" : term

macro_rules | `($R[$M]) => `(AddMonoidAlgebra $R $M)

/-- Unexpander for `AddMonoidAlgebra`. -/
@[scoped app_unexpander AddMonoidAlgebra]
meta def unexpander : Unexpander
  | `($_ $R $M) => `($R[$M])
  | _ => throw ()

/-- This prevents `ofCoeff x` being printed as `{ coeff := x }` by `delabStructureInstance`. -/
@[app_delab ofCoeff] meta def delabOfCoeff : Delab := delabApp

end AddMonoidAlgebra

namespace MonoidAlgebra
section Notation

open Lean.PrettyPrinter Delaborator

/-- This prevents `ofCoeff x` being printed as `{ coeff := x }` by `delabStructureInstance`. -/
@[app_delab ofCoeff] meta def delabOfCoeff : Delab := delabApp

@[inherit_doc MonoidAlgebra]
scoped syntax:max (priority := high) term noWs "[" term "]" : term

macro_rules | `($R[$M]) => `(MonoidAlgebra $R $M)

/-- Unexpander for `MonoidAlgebra`. -/
@[scoped app_unexpander MonoidAlgebra]
meta def unexpander : Unexpander
  | `($_ $R $M) => `($R[$M])
  | _ => throw ()

end Notation

section Semiring
variable [Semiring R] {x y : R[M]} {r r₁ r₂ : R} {m m' m₁ m₂ m₁' m₂' : M}

@[to_additive] lemma coeff_ofCoeff (x : M →₀ R) : (ofCoeff x).coeff = x := rfl
@[to_additive] lemma ofCoeff_coeff (x : R[M]) : ofCoeff x.coeff = x := rfl

/-- `MonoidAlgebra.coeff` as an equiv. -/
@[to_additive (attr := simps! apply symm_apply)
/-- `AddMonoidAlgebra.coeff` as an equiv. -/]
def coeffEquiv : R[M] ≃ (M →₀ R) where
  toFun := coeff
  invFun := ofCoeff
  left_inv _ := rfl
  right_inv _ := rfl

@[to_additive] lemma «forall» {P : R[M] → Prop} : (∀ p, P p) ↔ ∀ q, P ⟨q⟩ :=
  coeffEquiv.forall_congr_left

@[to_additive] lemma «exists» {P : R[M] → Prop} : (∃ p, P p) ↔ ∃ q, P ⟨q⟩ :=
  coeffEquiv.exists_congr_left

@[to_additive]
lemma coeff_injective : (coeff : R[M] → M →₀ R).Injective := coeffEquiv.injective

@[to_additive]
lemma ofCoeff_injective : (ofCoeff : (M →₀ R) → R[M]).Injective :=
  coeffEquiv.symm.injective

@[to_additive (attr := simp)]
lemma coeff_inj : x.coeff = y.coeff ↔ x = y := coeff_injective.eq_iff

@[to_additive]
lemma ofCoeff_inj {x y : M →₀ R} : ofCoeff x = ofCoeff y ↔ x = y := ofCoeff_injective.eq_iff

@[to_additive (attr := ext)] alias ⟨ext, _⟩ := coeff_inj

@[to_additive]
instance inhabited : Inhabited R[M] := fast_instance% coeffEquiv.inhabited

@[to_additive]
instance nontrivial [Nontrivial R] [Nonempty M] : Nontrivial R[M] :=
  coeffEquiv.nontrivial

-- TODO: Make `Function.Surjective.unique` an `abbrev`
@[to_additive] instance unique [Subsingleton R] : Unique R[M] := coeffEquiv.unique

@[to_additive]
instance instDecidableEq [DecidableEq R] [DecidableEq M] : DecidableEq R[M] :=
  coeffEquiv.decidableEq

@[to_additive]
instance addCommMonoid : AddCommMonoid R[M] :=
 fast_instance% coeffEquiv.addCommMonoid

/-- `MonoidAlgebra.coeff` as an `AddEquiv`. -/
@[to_additive (attr := simps! apply symm_apply)
/-- `AddMonoidAlgebra.coeff` as an `AddEquiv`. -/]
def coeffAddEquiv : R[M] ≃+ (M →₀ R) := coeffEquiv.addEquiv

@[to_additive (attr := simp)] lemma coeff_zero : coeff (0 : R[M]) = 0 := rfl
@[to_additive (attr := simp)] lemma ofCoeff_zero : (ofCoeff 0 : R[M]) = 0 := rfl
@[to_additive (attr := simp)] lemma coeff_eq_zero : coeff x = 0 ↔ x = 0 := coeff_inj
@[to_additive (attr := simp)] lemma ofCoeff_eq_zero {x : M →₀ R} : ofCoeff x = 0 ↔ x = 0 :=
  ofCoeff_inj

@[to_additive (attr := simp)]
lemma coeff_add (x y : R[M]) : coeff (x + y) = coeff x + coeff y := rfl

@[to_additive (attr := simp)]
lemma ofCoeff_add (x y : M →₀ R) : ofCoeff (x + y) = ofCoeff x + ofCoeff y := rfl

@[to_additive (attr := simp)]
lemma coeff_sum (s : Finset ι) (f : ι → R[M]) :
    coeff (∑ i ∈ s, f i) = ∑ i ∈ s, coeff (f i) := map_sum coeffAddEquiv ..

@[to_additive (attr := simp)]
lemma ofCoeff_sum (s : Finset ι) (f : ι → M →₀ R) :
    ofCoeff (∑ i ∈ s, f i) = ∑ i ∈ s, ofCoeff (f i) := map_sum coeffAddEquiv.symm ..

@[to_additive (attr := simp)]
lemma coeff_finsuppSum [AddCommMonoid N] (f : ι →₀ N) (g : ι → N → R[M]) :
    coeff (f.sum g) = f.sum (fun i n ↦ coeff (g i n)) := map_finsuppSum coeffAddEquiv ..

@[to_additive (attr := simp)]
lemma ofCoeff_finsuppSum [AddCommMonoid N] (f : ι →₀ N) (g : ι → N → M →₀ R) :
    ofCoeff (f.sum g) = f.sum (fun i n ↦ ofCoeff (g i n)) := map_finsuppSum coeffAddEquiv.symm ..

@[to_additive]
instance instIsCancelAdd [IsCancelAdd R] : IsCancelAdd R[M] :=
  coeffEquiv.isCancelAdd

/-- `MonoidAlgebra.single m r` for `m : M`, `r : R` is the element `rm : R[M]`. -/
@[to_additive
/-- `AddMonoidAlgebra.single m r` for `m : M`, `r : R` is the element `rm : R[M]`. -/]
def single (m : M) (r : R) : R[M] := .ofCoeff <| .single m r

@[to_additive (attr := simp)]
lemma coeff_single (m : M) (r : R) : (single m r).coeff = .single m r := rfl

@[to_additive (attr := simp)]
lemma ofCoeff_single (m : M) (r : R) : ofCoeff (.single m r) = single m r := rfl

@[to_additive]
lemma single_inj : single m₁ r₁ = single m₂ r₂ ↔ m₁ = m₂ ∧ r₁ = r₂ ∨ r₁ = 0 ∧ r₂ = 0 := by
  simp [← coeff_inj, Finsupp.single_eq_single_iff]

@[to_additive]
lemma single_left_inj (hr : r ≠ 0) : single m₁ r = single m₂ r ↔ m₁ = m₂ := by simp [single_inj, hr]

@[to_additive (attr := simp)]
lemma single_right_inj : single m r₁ = single m r₂ ↔ r₁ = r₂ := by simp +contextual [single_inj]

/-- `MonoidAlgebra.single m r` is injective in `m` if `r ≠ 0`. For injectivity in `r`, see
`MonoidAlgebra.single_injective`. -/
@[to_additive
/-- `AddMonoidAlgebra.single m r` is injective in `m` if `r ≠ 0`. For injectivity in `r`, see
`AddMonoidAlgebra.single_injective`.-/]
lemma single_left_injective (hr : r ≠ 0) : Function.Injective fun m : M ↦ single m r :=
  fun _ _ ↦ (single_left_inj hr).1

@[to_additive]
lemma single_right_injective : (single m : R → R[M]).Injective := fun _ _ ↦ single_right_inj.1

@[to_additive]
lemma single_add_single_inj (hr₁ : r₁ ≠ 0) (hr₂ : r₂ ≠ 0) :
    single m₁ r₁ + single m₂ r₂ = single m₁' r₁ + single m₂' r₂ ↔
      m₁ = m₁' ∧ m₂ = m₂' ∨ r₁ = r₂ ∧ m₁ = m₂' ∧ m₂ = m₁' ∨ r₁ + r₂ = 0 ∧ m₁ = m₂ ∧ m₁' = m₂' := by
  simp [← coeff_inj, single_add_single_eq_single_add_single, *]

/-- Remove a term from an element of the monoid algebra. -/
@[to_additive /-- Remove a term from an element of the monoid algebra. -/]
def erase (m : M) (x : R[M]) : R[M] := .ofCoeff <| .erase m x.coeff

@[to_additive (attr := simp)]
lemma coeff_erase (m : M) (x : R[M]) : (x.erase m).coeff = x.coeff.erase m := rfl

@[to_additive (attr := simp)]
lemma ofCoeff_erase (m : M) (x : M →₀ R) : ofCoeff (x.erase m) = (ofCoeff x).erase m := rfl

@[to_additive (attr := simp)]
lemma erase_zero (m : M) : erase m (0 : R[M]) = 0 := by ext; simp

@[to_additive (attr := simp)]
lemma erase_single (m : M) (r : R) : erase m (single m r) = 0 := by ext; simp

/-- Replace the `m`-th coefficient of an element `x` of the monoid algebra by a given value `r : R`.
If `r = 0`, this is equal to `x.erase m`. -/
@[to_additive
/-- Replace the `m`-th coefficient of an element `x` of the monoid algebra by a given value `r : R`.
If `r = 0`, this is equal to `x.erase m`. -/]
def update (m : M) (r : R) (x : R[M]) : R[M] :=
  ofCoeff (x.coeff.update m r)

@[to_additive (attr := simp)]
lemma coeff_update (m : M) (r : R) (x : R[M]) :
    (x.update m r).coeff = x.coeff.update m r := rfl

@[to_additive (attr := simp)]
lemma ofCoeff_update (m : M) (r : R) (x : M →₀ R) :
    ofCoeff (x.update m r) = (ofCoeff x).update m r := rfl

section SMul

/-! ### Basic scalar multiplication instances

This section collects instances needed for the algebraic structure of `Polynomial`,
which is defined in terms of `MonoidAlgebra`.
Further results on scalar multiplication can be found in
`Mathlib/Algebra/MonoidAlgebra/Module.lean`.
-/

variable {A : Type*} [SMulZeroClass A R]

@[to_additive (dont_translate := A) smulZeroClass]
instance smulZeroClass : SMulZeroClass A R[M] := fast_instance% coeffEquiv.smulZeroClass _

@[to_additive (attr := simp) (dont_translate := A) coeff_smul]
lemma coeff_smul (a : A) (x : R[M]) : coeff (a • x) = a • coeff x := rfl

@[to_additive (dont_translate := A) coeff_smul_apply]
lemma coeff_smul_apply (a : A) (x : R[M]) (m : M) : coeff (a • x) m = a • coeff x m := rfl

@[deprecated (since := "2025-11-26")] alias smul_apply := coeff_smul_apply

@[to_additive (attr := simp) (dont_translate := A) ofCoeff_smul]
lemma ofCoeff_smul (a : A) (x : M →₀ R) : ofCoeff (a • x) = a • ofCoeff x := rfl

@[to_additive (attr := simp) (dont_translate := A) smul_single]
lemma smul_single (a : A) (m : M) (r : R) : a • single m r = single m (a • r) := by ext; simp

@[to_additive (attr := simp) (dont_translate := R) smul_single']
lemma smul_single' (r' : R) (m : M) (r : R) : r' • single m r = single m (r' * r) := smul_single ..

@[to_additive (dont_translate := N) distribSMul]
instance distribSMul [DistribSMul N R] : DistribSMul N R[M] :=
  fast_instance% coeffEquiv.distribSMul _

@[to_additive (dont_translate := N) (relevant_arg := M) isScalarTower]
instance isScalarTower [SMulZeroClass N R] [SMulZeroClass O R] [SMul N O] [IsScalarTower N O R] :
    IsScalarTower N O R[M] := coeffEquiv.isScalarTower ..

@[to_additive (dont_translate := N) (relevant_arg := M) smulCommClass]
instance smulCommClass [SMulZeroClass N R] [SMulZeroClass O R] [SMulCommClass N O R] :
    SMulCommClass N O R[M] := coeffEquiv.smulCommClass ..

@[to_additive (dont_translate := N) isCentralScalar]
instance isCentralScalar [SMulZeroClass N R] [SMulZeroClass Nᵐᵒᵖ R] [IsCentralScalar N R] :
    IsCentralScalar N R[M] := coeffEquiv.isCentralScalar _

end SMul

@[to_additive (attr := simp)]
lemma single_zero (m : M) : (single m 0 : R[M]) = 0 := by simp [single]

@[to_additive (attr := simp)]
lemma single_add (m : M) (r₁ r₂ : R) : single m (r₁ + r₂) = single m r₁ + single m r₂ := by
  ext; simp

@[to_additive (attr := deprecated coeff_add (since := "2025-11-26"))]
lemma coe_add (f g : R[M]) : ⇑(f + g).coeff = f.coeff + g.coeff := rfl

@[to_additive]
lemma single_add_erase (m : M) (x : R[M]) : single m (x.coeff m) + x.erase m = x := by
  ext; simp [Finsupp.single_add_erase]

@[to_additive]
lemma erase_add_single (m : M) (x : R[M]) : x.erase m + single m (x.coeff m) = x := by
  ext; simp [Finsupp.erase_add_single]

/-- `MonoidAlgebra.single` as an `AddMonoidHom`.

TODO: Rename to `singleAddMonoidHom`. -/
@[to_additive (attr := simps)
/-- `AddMonoidAlgebra.single` as an `AddMonoidHom`.

TODO: Rename to `singleAddMonoidHom`. -/]
def singleAddHom (m : M) : R →+ R[M] where
  toFun := single m
  map_zero' := single_zero _
  map_add' := single_add _

/-- If two additive homomorphisms from `R[M]` are equal on each `single r m`,
then they are equal. -/
@[to_additive AddMonoidAlgebra.addMonoidHom_ext
/-- If two additive homomorphisms from `R[M]` are equal on each `single r m`,
then they are equal. -/]
lemma addMonoidHom_ext [AddZeroClass N] ⦃f g : R[M] →+ N⦄
    (h : ∀ m r, f (single m r) = g (single m r)) : f = g := by
  have : f.comp coeffAddEquiv.symm.toAddMonoidHom = g.comp coeffAddEquiv.symm.toAddMonoidHom :=
    Finsupp.addHom_ext h
  convert congr(($this).comp coeffAddEquiv.toAddMonoidHom)

/-- If two additive homomorphisms from `R[M]` are equal on each `single r m`,
then they are equal.

We formulate this using equality of `AddMonoidHom`s so that `ext` tactic can apply a type-specific
extensionality lemma after this one.  E.g., if the fiber `M` is `ℕ` or `ℤ`, then it suffices to
verify `f (single a 1) = g (single a 1)`.

TODO: Rename to `addMonoidHom_ext'`. -/
@[to_additive (attr := ext high)
/-- If two additive homomorphisms from `R[M]` are equal on each `single r m`, then they are equal.

We formulate this using equality of `AddMonoidHom`s so that `ext` tactic can apply a type-specific
extensionality lemma after this one.  E.g., if the fiber `M` is `ℕ` or `ℤ`, then it suffices to
verify `f (single a 1) = g (single a 1)`.

TODO: Rename to `addMonoidHom_ext'`. -/]
lemma addHom_ext' {N : Type*} [AddZeroClass N] ⦃f g : R[M] →+ N⦄
    (hfg : ∀ m, f.comp (singleAddHom m) = g.comp (singleAddHom m)) : f = g :=
  addMonoidHom_ext <| by simpa [DFunLike.ext_iff] using hfg

@[to_additive (attr := deprecated Finsupp.sum_single_index (since := "2025-11-26"))]
lemma sum_single_index [AddCommMonoid N] {m : M} {r : R} {h : M → R → N} (h_zero : h m 0 = 0) :
    (single m r).coeff.sum h = h m r := by
  simp [h_zero]

@[to_additive (attr := simp)]
lemma sum_coeff_single (f : R[M]) : f.coeff.sum single = f := by ext; simp

@[to_additive (attr := deprecated sum_coeff_single (since := "2025-11-26"))]
alias sum_single := sum_coeff_single

@[to_additive (attr := deprecated Finsupp.single_apply (since := "2025-11-26"))]
protected theorem coeff_single_apply {a a' : M} {b : R} [Decidable (a = a')] :
    (single a b).coeff a' = if a = a' then b else 0 :=
  Finsupp.single_apply

@[to_additive (attr := simp)]
lemma single_eq_zero : single m r = 0 ↔ r = 0 := by simp [← coeff_inj]

@[to_additive] lemma single_ne_zero : single m r ≠ 0 ↔ r ≠ 0 := single_eq_zero.not

@[to_additive (attr := elab_as_elim)]
lemma induction {motive : R[M] → Prop} (x : R[M])
    (zero : motive 0)
    (single_add : ∀ m r x, m ∉ x.coeff.support → r ≠ 0 → motive x → motive (single m r + x)) :
    motive x :=
  Finsupp.induction (motive := fun x ↦ motive <| ofCoeff x) x.coeff
    (by simpa using zero) (fun m r x ↦ single_add m r (ofCoeff x))

@[to_additive (attr := elab_as_elim)]
lemma induction_linear {p : R[M] → Prop} (x : R[M]) (zero : p 0)
    (add : ∀ x y : R[M], p x → p y → p (x + y))
    (single : ∀ m r, p (single m r)) : p x :=
  Finsupp.induction_linear (motive := (p <| ofCoeff ·)) x.coeff zero (fun _ _ ↦ add _ _)
    (fun _ _ ↦ single _ _)

@[to_additive (attr := simp) addSubmonoidClosure_single]
lemma addSubmonoidClosure_single :
    AddSubmonoid.closure {x : R[M] | ∃ m r, x = single m r} = ⊤ :=
  top_unique fun x _hx => induction x (AddSubmonoid.zero_mem _) fun a b _f _ha _hb =>
    AddSubmonoid.add_mem _ <| AddSubmonoid.subset_closure <| ⟨a, b, rfl⟩

section One
variable [One M]

/-- The unit of the multiplication is `single 1 1`,
i.e. the function that is `1` at `1` and `0` elsewhere. -/
@[to_additive (dont_translate := R)
/-- The unit of the multiplication is `single 1 1`,
i.e. the function that is `1` at `1` and `0` elsewhere. -/]
instance one : One R[M] where one := single 1 1

@[to_additive (dont_translate := R) one_def]
lemma one_def : (1 : R[M]) = single 1 1 := rfl

@[to_additive (attr := simp) (dont_translate := R)]
lemma coeff_one_one : (1 : R[M]).coeff 1 = 1 := by simp [one_def]

end One

section Mul
variable [Mul M]

/-- The multiplication in an additive monoid algebra.

We make it irreducible so that Lean doesn't unfold it when trying to unify two different things. -/
@[no_expose]
def _root_.AddMonoidAlgebra.mul' [Add M] (x y : AddMonoidAlgebra R M) : AddMonoidAlgebra R M :=
  x.coeff.sum fun m₁ r₁ ↦ y.coeff.sum fun m₂ r₂ ↦ .single (m₁ + m₂) (r₁ * r₂)

/-- The multiplication in a monoid algebra.

We make it irreducible so that Lean doesn't unfold it when trying to unify two different things. -/
@[to_additive existing mul', no_expose]
def mul' (x y : R[M]) : R[M] :=
  x.coeff.sum fun m₁ r₁ ↦ y.coeff.sum fun m₂ r₂ ↦ single (m₁ * m₂) (r₁ * r₂)

/-- The product of `x y : R[M]` is the finitely supported function whose value at `m`
is the sum of `x m₁ * y m₂` over all pairs `m₁, m₂` such that `m₁ * m₂ = m`. -/
@[to_additive instMul
/-- The product of `x y : R[M]` is the finitely supported function whose value at `m`
is the sum of `x m₁ * y m₂` over all pairs `m₁, m₂` such that `m₁ + m₂ = m`. -/]
instance instMul : Mul R[M] where mul := mul'

@[to_additive (dont_translate := R) mul_def]
lemma mul_def (x y : R[M]) :
    x * y = x.coeff.sum fun m₁ r₁ ↦ y.coeff.sum fun m₂ r₂ ↦ single (m₁ * m₂) (r₁ * r₂) := by
  with_unfolding_all rfl

@[to_additive (dont_translate := R)]
instance nonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring R[M] where
  zero_mul := by simp [mul_def]
  mul_zero := by simp [mul_def]
  left_distrib := by classical simp [mul_def, mul_add, sum_add, sum_add_index]
  right_distrib := by classical simp [mul_def, add_mul, sum_add, sum_add_index]

@[to_additive (dont_translate := R) coeff_mul]
lemma coeff_mul [DecidableEq M] (x y : R[M]) (m : M) :
    (x * y).coeff m =
      x.coeff.sum fun m₁ r₁ ↦ y.coeff.sum fun m₂ r₂ ↦ if m₁ * m₂ = m then r₁ * r₂ else 0 := by
  simp [mul_def, Finsupp.single_apply]

@[to_additive (attr := deprecated coeff_mul (since := "2025-11-26")) (dont_translate := R)
  mul_apply]
alias mul_apply := coeff_mul

open Finset in
@[to_additive (dont_translate := R) coeff_mul_antidiag]
lemma coeff_mul_antidiag (x y : R[M]) (m : M) (s : Finset (M × M))
    (hs : ∀ {p}, p ∈ s ↔ p.1 * p.2 = m) : (x * y).coeff m = ∑ p ∈ s, x.coeff p.1 * y.coeff p.2 := by
  classical
  let F (p : M × M) : R := if p.1 * p.2 = m then x.coeff p.1 * y.coeff p.2 else 0
  calc
    (x * y).coeff m = ∑ m₁ ∈ x.coeff.support, ∑ m₂ ∈ y.coeff.support, F (m₁, m₂) := coeff_mul ..
    _ = ∑ p ∈ x.coeff.support ×ˢ y.coeff.support with p.1 * p.2 = m, x.coeff p.1 * y.coeff p.2 := by
      rw [Finset.sum_filter, Finset.sum_product]
    _ = ∑ p ∈ s with p.1 ∈ x.coeff.support ∧ p.2 ∈ y.coeff.support, x.coeff p.1 * y.coeff p.2 := by
      congr! 1; ext; simp only [mem_filter, mem_product, hs, and_comm]
    _ = ∑ p ∈ s, x.coeff p.1 * y.coeff p.2 :=
      sum_subset (filter_subset _ _) fun p hps hp => by
        simp only [mem_filter, mem_support_iff, not_and, Classical.not_not] at hp ⊢
        by_cases h1 : x.coeff p.1 = 0
        · rw [h1, zero_mul]
        · rw [hp hps h1, mul_zero]

@[to_additive (attr := deprecated coeff_mul_antidiag (since := "2025-11-26")) (dont_translate := R)
  mul_apply_antidiagonal]
alias mul_apply_antidiagonal := coeff_mul_antidiag

@[to_additive (attr := simp) (dont_translate := R) single_mul_single]
lemma single_mul_single (m₁ m₂ : M) (r₁ r₂ : R) :
    single m₁ r₁ * single m₂ r₂ = single (m₁ * m₂) (r₁ * r₂) := by simp [mul_def]

@[to_additive (attr := simp) (dont_translate := R) single_commute_single]
lemma single_commute_single (hm : Commute m₁ m₂) (hr : Commute r₁ r₂) :
    Commute (single m₁ r₁) (single m₂ r₂) := by simp [Commute, SemiconjBy, hm.eq, hr.eq]

@[to_additive (attr := simp) (dont_translate := R) single_commute]
lemma single_commute (hm : ∀ m', Commute m m') (hr : ∀ r', Commute r r') (x : R[M]) :
    Commute (single m r) x := by
  have : AddMonoidHom.mulLeft (single m r) = AddMonoidHom.mulRight (single m r) := by
    ext m' r' : 2; exact single_commute_single (hm m') (hr r')
  exact congr($this x)

@[to_additive (dont_translate := R) coeff_mul_single_eq_coeff_mul]
lemma coeff_mul_single_eq_coeff_mul (m₂ : M) (H : ∀ m' ∈ x.coeff.support, m' * m = m₁ ↔ m' = m₂) :
    (x * single m r).coeff m₁ = x.coeff m₂ * r := by
  classical
  calc
    (x * single m r).coeff m₁
    _ = x.coeff.sum fun m' r' ↦ if m' * m = m₁ then r' * r else 0 := by simp [coeff_mul]
    _ = x.coeff.sum fun m' r' ↦ if m' = m₂ then r' * r else 0 := by gcongr; simp [*]
    _ = x.coeff m₂ * r := by simp +contextual [Finsupp.sum_eq_single m₂]

@[to_additive (dont_translate := R) coeff_single_mul_eq_mul_coeff]
lemma coeff_single_mul_eq_mul_coeff (m₂ : M) (H : ∀ m' ∈ x.coeff.support, m * m' = m₁ ↔ m' = m₂) :
    (single m r * x).coeff m₁ = r * x.coeff m₂ := by
  classical
  calc
    (single m r * x).coeff m₁
    _ = x.coeff.sum fun m' r' ↦ if m * m' = m₁ then r * r' else 0 := by simp [coeff_mul]
    _ = x.coeff.sum fun m' r' ↦ if m' = m₂ then r * r' else 0 := by gcongr; simp [*]
    _ = r * x.coeff m₂ := by simp +contextual [Finsupp.sum_eq_single m₂]

@[to_additive (attr := simp) (dont_translate := R) coeff_mul_single_of_forall_add_ne]
lemma coeff_mul_single_of_forall_mul_ne (r : R) (x : R[M]) (h : ∀ d, d * m ≠ m') :
    (x * single m r).coeff m' = 0 := by classical simp [coeff_mul, h]

@[to_additive (attr := simp) (dont_translate := R) coeff_single_mul_of_forall_add_ne]
lemma coeff_single_mul_of_forall_mul_ne (r : R) (x : R[M]) (h : ∀ d, m * d ≠ m') :
    (single m r * x).coeff m' = 0 := by classical simp [coeff_mul, h]

@[to_additive (attr := deprecated coeff_mul_single_of_forall_mul_ne (since := "2026-01-02"))
  (dont_translate := R)]
lemma mul_single_apply_of_not_exists_mul (r : R) {g g' : M} (x : R[M])
    (h : ¬∃ d, g' = d * g) : (x * single g r).coeff g' = 0 :=
  coeff_mul_single_of_forall_mul_ne _ _ <| by simpa [eq_comm] using h

@[to_additive (attr := deprecated coeff_single_mul_of_forall_mul_ne (since := "2026-01-02"))
  (dont_translate := R)]
lemma single_mul_apply_of_not_exists_mul (r : R) {g g' : M} (x : R[M])
    (h : ¬∃ d, g' = g * d) : (single g r * x).coeff g' = 0 :=
  coeff_single_mul_of_forall_mul_ne _ _ <| by simpa [eq_comm] using h

variable (R M : Type*) [Semiring R] [Mul M] in
/-- The embedding of a magma into its magma algebra. -/
@[simps]
def ofMagma : M →ₙ* R[M] where
  toFun a := single a 1
  map_mul' a b := by ext; simp [mul_def, Finsupp.sum_single_index]

end Mul

section Semigroup
variable [Semigroup M]

@[to_additive (dont_translate := R)]
instance nonUnitalSemiring : NonUnitalSemiring R[M] where
  mul_assoc := by simp [mul_def, sum_sum_index, mul_add, add_mul, mul_assoc]

end Semigroup

section MulOneClass
variable [MulOneClass M]

@[to_additive (dont_translate := R)]
instance nonAssocSemiring : NonAssocSemiring R[M] where
  natCast n := single 1 n
  natCast_zero := by simp
  natCast_succ := by simp [one_def]
  one_mul := by simp [mul_def, one_def]
  mul_one := by simp [mul_def, one_def]

@[to_additive (dont_translate := R)]
lemma natCast_def (n : ℕ) : (n : R[M]) = single 1 (n : R) := rfl

@[to_additive (dont_translate := R)]
lemma ofNat_def (n : ℕ) [n.AtLeastTwo] : (ofNat(n) : R[M]) = single 1 ofNat(n) := rfl

@[to_additive (dont_translate := R) (attr := simp)]
lemma coeff_natCast (n : ℕ) : (n : R[M]).coeff = .single 1 (n : R) := rfl

@[to_additive (dont_translate := R) (attr := simp)]
lemma coeff_ofNat (n : ℕ) [n.AtLeastTwo] : (ofNat(n) : R[M]).coeff = .single 1 ofNat(n) := rfl

@[to_additive (dont_translate := R) coeff_mul_single_zero_apply]
lemma coeff_mul_single_one_apply (x : R[M]) (r : R) (m : M) :
    (x * single 1 r).coeff m = x.coeff m * r :=
  coeff_mul_single_eq_coeff_mul _ (by simp)

@[to_additive (dont_translate := R) coeff_single_zero_mul_apply]
lemma coeff_single_one_mul_apply (x : R[M]) (r : R) (m : M) :
    (single 1 r * x).coeff m = r * x.coeff m :=
  x.coeff_single_mul_eq_mul_coeff _ (by simp)

@[deprecated (since := "2026-01-02")] alias mul_single_one_apply := coeff_mul_single_one_apply
@[deprecated (since := "2026-01-02")] alias single_one_mul_apply := coeff_single_one_mul_apply

variable (R M : Type*) [Semiring R] [MulOneClass M] in
/-- The embedding of a unital magma into its magma algebra. -/
@[simps! apply]
def of : M →* R[M] where
  __ := ofMagma R M
  map_one' := rfl

lemma of_injective [Nontrivial R] : Function.Injective (of R M) := fun a b h ↦ by
  simpa [← coeff_inj, Finsupp.single_eq_single_iff] using h

lemma of_commute (h : ∀ m', Commute m m') (f : R[M]) : Commute (of R M m) f :=
  single_commute h .one_left f

/-- `MonoidAlgebra.single` as a `MonoidHom` from the product type into the monoid algebra.

Note the order of the elements of the product are reversed compared to the arguments of
`MonoidAlgebra.single`. -/
@[simps]
def singleHom : R × M →* R[M] where
  toFun a := single a.2 a.1
  map_one' := rfl
  map_mul' _a _b := by simp

/-- `MonoidAlgebra.single 1` as a `RingHom` -/
@[to_additive (attr := simps) (dont_translate := R)
/-- `AddMonoidAlgebra.single 1` as a `RingHom` -/]
def singleOneRingHom : R →+* R[M] where
  __ := singleAddHom 1
  map_one' := rfl
  map_mul' := by simp

/-- If two ring homomorphisms from `R[M]` are equal on all `single m 1` and
`single 1 r`, then they are equal. -/
@[to_additive (dont_translate := R S)
/-- If two ring homomorphisms from `R[M]` are equal on all `single m 1` and `single 0 r`,
then they are equal. -/]
lemma ringHom_ext [Semiring S] {f g : R[M] →+* S}
    (h₁ : ∀ r, f (single 1 r) = g (single 1 r)) (h_of : ∀ m, f (single m 1) = g (single m 1)) :
    f = g :=
  RingHom.coe_addMonoidHom_injective <| addMonoidHom_ext fun m r ↦ by
    simpa [← map_mul] using congr($(h₁ r) * $(h_of m))

/-- If two ring homomorphisms from `R[M]` are equal on all `single m 1`
and `single 1 r`, then they are equal.

See note [partially-applied ext lemmas]. -/
@[ext high]
lemma ringHom_ext' [Semiring S] {f g : R[M] →+* S}
    (h₁ : f.comp singleOneRingHom = g.comp singleOneRingHom)
    (h_of : (f : R[M] →* S).comp (of R M) =
      (g : R[M] →* S).comp (of R M)) : f = g :=
  ringHom_ext (by simpa [DFunLike.ext_iff] using h₁) (by simpa [DFunLike.ext_iff] using h_of)

end MulOneClass

section Monoid
variable [Monoid M] [Monoid N]

@[to_additive]
instance semiring : Semiring R[M] where

@[to_additive (attr := simp) (dont_translate := R) single_pow]
lemma single_pow (m : M) (r : R) : ∀ n : ℕ, single m r ^ n = single (m ^ n) (r ^ n)
  | 0 => by simp [one_def]
  | n + 1 => by simp [pow_succ, single_pow _ _ n]

lemma induction_on {p : R[M] → Prop} (x : R[M])
    (hM : ∀ m, p (of R M m)) (hadd : ∀ x y : R[M], p x → p y → p (x + y))
    (hsmul : ∀ (r : R) (x), p x → p (r • x)) : p x :=
  Finsupp.induction_linear (motive := fun x ↦ p <| ofCoeff x) x.coeff
    (by simpa using hsmul 0 (of R M 1) (hM 1))
    (fun x y hf hg ↦ hadd (ofCoeff x) (ofCoeff y) hf hg)
    fun m r ↦ by simpa using hsmul r (of R M m) (hM m)

@[to_additive (dont_translate := R)]
instance isLocalHom_singleOneRingHom : IsLocalHom (singleOneRingHom (R := R) (M := M)) where
  map_nonunit := by
    simp_rw [isUnit_iff_exists]
    rintro a ⟨x, hax, hxa⟩
    refine ⟨x.coeff 1, ?_, ?_⟩
    · simpa [coeff_single_one_mul_apply] using congr(($hax).coeff 1)
    · simpa [coeff_mul_single_one_apply] using congr(($hxa).coeff 1)

variable (M) in
/-- The trivial monoid algebra is the base ring. -/
@[to_additive (dont_translate := R) (attr := simps! apply symm_apply)
/-- The trivial additive monoid algebra is the base ring. -/]
def uniqueRingEquiv [Unique M] : R[M] ≃+* R where
  toAddEquiv := coeffAddEquiv.trans .finsuppUnique
  map_mul' x y := (coeff_mul ..).trans <| by simp [Finsupp.sum_unique, Unique.eq_default]

/-- A product monoid algebra is a nested monoid algebra. -/
@[to_additive (dont_translate := R)
/-- An additive product monoid algebra is a nested additive monoid algebra. -/]
def curryAddEquiv : R[M × N] ≃+ R[N][M] :=
  coeffAddEquiv.trans <| .trans Finsupp.curryAddEquiv <| .trans
    (Finsupp.mapRange.addEquiv coeffAddEquiv.symm) coeffAddEquiv.symm

@[to_additive (dont_translate := R) (attr := simp)]
lemma curryAddEquiv_single (m : M) (n : N) (r : R) :
    curryAddEquiv (single (m, n) r) = single m (single n r) := by simp [curryAddEquiv]

@[to_additive (attr := simp)]
lemma curryAddEquiv_symm_single (m : M) (n : N) (r : R) :
    curryAddEquiv.symm (single m <| single n r) = (single (m, n) r) := by simp [curryAddEquiv]

/-- A product monoid algebra is a nested monoid algebra. -/
@[to_additive (dont_translate := R)
/-- An additive product monoid algebra is a nested additive monoid algebra. -/]
def curryRingEquiv : R[M × N] ≃+* R[N][M] where
  toAddEquiv := curryAddEquiv
  map_mul' := curryAddEquiv (M := M) (N := N).toAddMonoidHom.map_mul_iff.2 <| by
    ext ⟨m₁, n₁⟩ r₁ ⟨m₂, n₂⟩ r₂; simp

@[to_additive (dont_translate := R) (attr := simp)]
lemma curryRingEquiv_single (m : M) (n : N) (r : R) :
    curryRingEquiv (single (m, n) r) = single m (single n r) := by simp [curryRingEquiv]

@[to_additive (dont_translate := R) (attr := simp)]
lemma curryRingEquiv_symm_single (m : M) (n : N) (r : R) :
    curryRingEquiv.symm (single m <| single n r) = (single (m, n) r) := by
  simp [curryRingEquiv, RingEquiv.symm_apply_eq]

variable [IsCancelMul M]

@[to_additive (dont_translate := R) (attr := simp) coeff_mul_single_add]
lemma coeff_mul_single_mul (x : R[M]) (r : R) (m m' : M) :
    (x * single m r).coeff (m' * m) = x.coeff m' * r :=
  coeff_mul_single_eq_coeff_mul _ (by simp)

@[to_additive (dont_translate := R) (attr := simp) coeff_single_mul_add]
lemma coeff_single_mul_mul (x : R[M]) (r : R) (m m' : M) :
    (single m r * x).coeff (m * m') = r * x.coeff m' :=
  x.coeff_single_mul_eq_mul_coeff _ (by simp)

end Monoid

section Group
variable [Group G]

@[to_additive (attr := simp) (dont_translate := R) coeff_mul_single_apply]
lemma coeff_mul_single_apply (x : R[G]) (r : R) (g h : G) :
    (x * single g r).coeff h = x.coeff (h * g⁻¹) * r :=
  coeff_mul_single_eq_coeff_mul _ <| by simp [eq_mul_inv_iff_mul_eq]

@[to_additive (attr := simp) (dont_translate := R) coeff_single_mul_apply]
lemma coeff_single_mul_apply (x : R[G]) (r : R) (g h : G) :
    (single g r * x).coeff h = r * x.coeff (g⁻¹ * h) :=
  coeff_single_mul_eq_mul_coeff _ <| by simp [eq_inv_mul_iff_mul_eq]

@[to_additive (dont_translate := R) coeff_mul_apply_left]
lemma coeff_mul_apply_left (x y : R[G]) (g : G) :
    (x * y).coeff g = x.coeff.sum fun h r ↦ r * y.coeff (h⁻¹ * g) := by
  classical rw [coeff_mul]; gcongr; simp +contextual [← eq_inv_mul_iff_mul_eq]

@[to_additive (dont_translate := R) coeff_mul_apply_right]
lemma coeff_mul_apply_right (x y : R[G]) (g : G) :
    (x * y).coeff g = y.coeff.sum fun h r ↦ x.coeff (g * h⁻¹) * r := by
  classical rw [coeff_mul, Finsupp.sum_comm]; gcongr; simp +contextual [← eq_mul_inv_iff_mul_eq]

@[deprecated (since := "2026-01-02")] alias mul_single_apply := coeff_mul_single_apply
@[deprecated (since := "2026-01-02")] alias single_mul_apply := coeff_single_mul_apply
@[deprecated (since := "2026-01-02")] alias mul_apply_left := coeff_mul_apply_left
@[deprecated (since := "2026-01-02")] alias mul_apply_right := coeff_mul_apply_right

end Group
end Semiring

section CommSemiring
variable [CommSemiring R]

@[to_additive (dont_translate := R)]
instance nonUnitalCommSemiring [CommSemigroup M] : NonUnitalCommSemiring R[M] where
  mul_comm f g := by simp [mul_def, Finsupp.sum, mul_comm, f.coeff.support.sum_comm]

@[to_additive (dont_translate := R)]
lemma single_one_comm [MulOneClass M] (r : R) (f : R[M]) :
    single (1 : M) r * f = f * single (1 : M) r :=
  single_commute .one_left (.all _) f

section CommMonoid
variable [CommMonoid M]

@[to_additive (dont_translate := R)]
instance commSemiring : CommSemiring R[M] where

open Finset in
@[to_additive (dont_translate := R) (attr := simp) prod_single]
lemma prod_single (s : Finset ι) (m : ι → M) (r : ι → R) :
    ∏ i ∈ s, single (m i) (r i) = single (∏ i ∈ s, m i) (∏ i ∈ s, r i) :=
  Finset.cons_induction_on s rfl fun i s hi ih ↦ by
    rw [prod_cons, ih, single_mul_single, prod_cons, prod_cons]

open Finset in
@[to_additive (dont_translate := R) (attr := simp) finsuppProd_single]
lemma finsuppProd_single [AddCommMonoid N] (f : ι →₀ N) (m : ι → N → M) (r : ι → N → R) :
    f.prod (fun i n ↦ single (m i n) (r i n)) = single (f.prod m) (f.prod r) := prod_single ..

end CommMonoid
end CommSemiring

section Ring
variable [Ring R]

@[to_additive (dont_translate := R) addCommGroup]
instance addCommGroup : AddCommGroup R[M] := fast_instance% coeffEquiv.addCommGroup

@[to_additive (attr := simp) (dont_translate := R)]
lemma coeff_neg (x : R[M]) : (-x).coeff = -x.coeff := rfl

@[to_additive (attr := simp) (dont_translate := R)]
lemma ofCoeff_neg (x : M →₀ R) : ofCoeff (-x) = -ofCoeff x := rfl

@[to_additive (attr := simp) (dont_translate := R)]
lemma single_neg (m : M) (r : R) : single m (-r) = -single m r := by ext; simp

@[to_additive (attr := simp) (dont_translate := R)]
lemma coeff_sub (x y : R[M]) : (x - y).coeff = x.coeff - y.coeff := rfl

@[to_additive (attr := simp) (dont_translate := R)]
lemma ofCoeff_sub (x y : M →₀ R) : ofCoeff (x - y) = ofCoeff x - ofCoeff y := rfl

@[to_additive (attr := simp) (dont_translate := R)]
lemma single_sub (m : M) (r s : R) : single m (r - s) = single m r - single m s := by ext; simp

@[to_additive (dont_translate := R)]
instance nonUnitalNonAssocRing [Mul M] : NonUnitalNonAssocRing R[M] where

@[to_additive (dont_translate := R)]
instance nonUnitalRing [Semigroup M] : NonUnitalRing R[M] where

@[to_additive (dont_translate := R)]
instance nonAssocRing [MulOneClass M] : NonAssocRing R[M] where
  intCast z := single 1 z
  intCast_ofNat n := by simp [natCast_def]
  intCast_negSucc n := by simp [natCast_def, one_def]

@[to_additive (dont_translate := R)]
lemma intCast_def [MulOneClass M] (z : ℤ) : (z : R[M]) = single 1 (z : R) := rfl

@[to_additive (dont_translate := R)]
instance ring [Monoid M] : Ring R[M] where

@[deprecated coeff_neg (since := "2025-11-26")]
lemma neg_apply (m : M) (x : R[M]) : (-x).coeff m = -x.coeff m := rfl

end Ring

section CommRing
variable [CommRing R]

@[to_additive (dont_translate := R)]
instance nonUnitalCommRing [CommSemigroup M] : NonUnitalCommRing R[M] where

@[to_additive (dont_translate := R)]
instance commRing [CommMonoid M] : CommRing R[M] where

end CommRing
end MonoidAlgebra

/-! ### Additive monoids -/

namespace AddMonoidAlgebra
variable [Semiring R]

section

variable (R M : Type*) [Semiring R]

/-- The embedding of an additive magma into its additive magma algebra. -/
@[simps]
def ofMagma [Add M] : Multiplicative M →ₙ* R[M] where
  toFun a := single a.toAdd 1
  map_mul' := by simp [mul_def]

/-- Embedding of a magma with zero into its magma algebra. -/
def of [AddZeroClass M] : Multiplicative M →* R[M] where
  __ := ofMagma R M
  map_one' := rfl

/-- Embedding of a magma with zero `M`, into its magma algebra, having `M` as source. -/
def of' : M → R[M] := fun m => single m 1

end

@[simp]
theorem of_apply [AddZeroClass M] (a : Multiplicative M) : of R M a = single a.toAdd 1 :=
  rfl

@[simp]
theorem of'_apply (a : M) : of' R M a = single a 1 :=
  rfl

theorem of'_eq_of [AddZeroClass M] (a : M) : of' R M a = of R M (.ofAdd a) := rfl

theorem of_injective [Nontrivial R] [AddZeroClass M] : Function.Injective (of R M) := fun a b h ↦ by
  simpa [← coeff_inj, Finsupp.single_eq_single_iff] using h

lemma of'_commute [AddZeroClass M] {a : M} (h : ∀ a', AddCommute a a') (f : AddMonoidAlgebra R M) :
    Commute (of' R M a) f :=
  single_commute h .one_left f

/-- `Finsupp.single` as a `MonoidHom` from the product type into the additive monoid algebra.

Note the order of the elements of the product are reversed compared to the arguments of
`Finsupp.single`.
-/
@[simps]
def singleHom [AddZeroClass M] : R × Multiplicative M →* R[M] where
  toFun a := single a.2.toAdd a.1
  map_one' := rfl
  map_mul' _a _b := (single_mul_single ..).symm

theorem induction_on [AddMonoid M] {p : R[M] → Prop} (x : R[M])
    (hM : ∀ m, p (of R M <| .ofAdd m)) (hadd : ∀ x y : R[M], p x → p y → p (x + y))
    (hsmul : ∀ (r : R) (x), p x → p (r • x)) : p x :=
  Finsupp.induction_linear (motive := fun x ↦ p (ofCoeff x)) x.coeff
    (by simpa using hsmul 0 (of R M 1) (hM 0))
    (fun x y hf hg ↦ hadd (ofCoeff x) (ofCoeff y) hf hg)
    fun m r ↦ by simpa using hsmul r (of R M m) (hM m)

/-- If two ring homomorphisms from `R[M]` are equal on all `single m 1`
and `single 0 r`, then they are equal.

See note [partially-applied ext lemmas]. -/
@[ext high]
theorem ringHom_ext' [Semiring S] [AddMonoid M] {f g : R[M] →+* S}
    (h₁ : f.comp singleZeroRingHom = g.comp singleZeroRingHom)
    (h_of : (f : R[M] →* S).comp (of R M) = (g : R[M] →* S).comp (of R M)) :
    f = g :=
  ringHom_ext (RingHom.congr_fun h₁) (DFunLike.congr_fun h_of)

end AddMonoidAlgebra
