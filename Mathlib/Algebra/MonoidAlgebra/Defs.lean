/-
Copyright (c) 2017 Johannes Hölzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl, Yury Kudryashov, Kim Morrison
-/
import Mathlib.Algebra.GroupWithZero.Action.TransferInstance
import Mathlib.Algebra.Module.Defs
import Mathlib.Data.Finsupp.Basic
import Mathlib.Data.Finsupp.SMulWithZero

/-!
# Monoid algebras

When the domain of a `Finsupp` has a multiplicative or additive structure, we can define
a convolution product. To mathematicians this structure is known as the "monoid algebra",
i.e. the finite formal linear combinations over a given semiring of elements of a monoid `M`.
The "group ring" `ℤ[G]` or the "group algebra" `k[G]` are typical uses.

In fact the construction of the "monoid algebra" makes sense when `M` is not even a monoid, but
merely a magma, i.e., when `M` carries a multiplication which is not required to satisfy any
conditions at all. In this case the construction yields a not-necessarily-unital,
not-necessarily-associative algebra but it is still adjoint to the forgetful functor from such
algebras to magmas, and we prove this as `MonoidAlgebra.liftMagma`.

In this file we define `MonoidAlgebra R M := M →₀ R`, and `AddMonoidAlgebra R M`
in the same way, and then define the convolution product on these.

When the domain is additive, this is used to define polynomials:
```
Polynomial R := AddMonoidAlgebra R ℕ
MvPolynomial σ α := AddMonoidAlgebra R (σ →₀ ℕ)
```

When the domain is multiplicative, e.g. a group, this will be used to define the group ring.

## Notation

We introduce the notation `R[A]` for `AddMonoidAlgebra R A`.
-/

assert_not_exists NonUnitalAlgHom AlgEquiv

noncomputable section

open Finsupp hiding single

-- We make sure the additivisable argument comes first to avoid doing
-- `to_additive (relevant_arg := 2)` everywhere.
variable {G M N O ι R S : Type*}

/-- The additive monoid algebra over a semiring `R` generated by the additive monoid `M`.

It is the type of finite formal `R`-linear combinations of terms of `M`,
endowed with the convolution product. -/
structure AddMonoidAlgebra (R M : Type*) [Semiring R] where
  /-- Construct an element of the additive monoid algebra `R[M]` from its coefficients `M →₀ R`. -/
  ofCoeff ::
  /-- The coefficients `M →₀ R` of an element of the additive monoid algebra `R[M]`. -/
  coeff : M →₀ R

/-- The monoid algebra over a semiring `R` generated by the monoid `M`.

It is the type of finite formal `R`-linear combinations of terms of `M`,
endowed with the convolution product. -/
@[to_additive (relevant_arg := 2), to_additive_dont_translate]
structure MonoidAlgebra (R M : Type*) [Semiring R] where
  /-- Construct an element of the monoid algebra `R[M]` from its coefficients `M →₀ R`. -/
  ofCoeff ::
  /-- The coefficients `M →₀ R` of an element of the monoid algebra `R[M]`. -/
  coeff : M →₀ R

namespace AddMonoidAlgebra

@[inherit_doc AddMonoidAlgebra]
scoped syntax:max (priority := high) term noWs "[" term "]" : term

macro_rules | `($R[$M]) => `(AddMonoidAlgebra $R $M)

/-- Unexpander for `AddMonoidAlgebra`. -/
@[scoped app_unexpander AddMonoidAlgebra]
def unexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $k $g) => `($k[$g])
  | _ => throw ()

end AddMonoidAlgebra

namespace MonoidAlgebra

@[inherit_doc MonoidAlgebra]
scoped syntax:max (priority := high) term noWs "[" term "]" : term

macro_rules | `($R[$M]) => `(MonoidAlgebra $R $M)

/-- Unexpander for `MonoidAlgebra`. -/
@[scoped app_unexpander MonoidAlgebra]
def unexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $R $M) => `($R[$M])
  | _ => throw ()
section Semiring
variable [Semiring R] {x y : R[M]} {r r₁ r₂ : R} {m m' m₁ m₂ : M}

@[to_additive] lemma coeff_ofCoeff (x : M →₀ R) : (ofCoeff x).coeff = x := rfl
@[to_additive] lemma ofCoeff_coeff (x : R[M]) : ofCoeff x.coeff = x := rfl

/-- `MonoidAlgebra.coeff` as an equiv. -/
@[to_additive (attr := simps!)
/-- `AddMonoidAlgebra.coeff` as an equiv. -/]
def coeffEquiv : R[M] ≃ (M →₀ R) where
  toFun := coeff
  invFun := ofCoeff
  left_inv _ := rfl
  right_inv _ := rfl

@[to_additive] lemma coeff_injective : (coeff : R[M] → M →₀ R).Injective := coeffEquiv.injective
@[to_additive] lemma ofCoeff_injective : (ofCoeff : (M →₀ R) → R[M]).Injective :=
  coeffEquiv.symm.injective

@[to_additive (attr := simp)]
lemma coeff_inj : x.coeff = y.coeff ↔ x = y := coeff_injective.eq_iff

@[to_additive]
lemma ofCoeff_inj {x y : M →₀ R} : ofCoeff x = ofCoeff y ↔ x = y := ofCoeff_injective.eq_iff

@[to_additive (attr := ext)] alias ⟨ext, _⟩ := coeff_inj

@[to_additive] instance inhabited : Inhabited R[M] := coeffEquiv.inhabited
@[to_additive] instance nontrivial [Nontrivial R] [Nonempty M] : Nontrivial R[M] :=
  coeffEquiv.nontrivial
@[to_additive] instance unique [Subsingleton R] : Unique R[M] := coeffEquiv.unique
@[to_additive] instance addCommMonoid : AddCommMonoid R[M] :=
  fast_instance% coeffEquiv.addCommMonoid
@[to_additive] instance instIsCancelAdd [IsCancelAdd R] : IsCancelAdd R[M] :=
  coeffEquiv.isCancelAdd

/-- `MonoidAlgebra.single m r` for `m : M`, `r : R` is the element `rm : R[M]`. -/
@[to_additive
/-- `AddMonoidAlgebra.single m r` for `m : M`, `r : R` is the element `rm : R[M]`. -/]
def single (m : M) (r : R) : R[M] := .ofCoeff <| .single m r

section SMul

/-! ### Basic scalar multiplication instances

This section collects instances needed for the algebraic structure of `Polynomial`,
which is defined in terms of `MonoidAlgebra`.
Further results on scalar multiplication can be found in
`Mathlib/Algebra/MonoidAlgebra/Module.lean`.
-/

variable {A : Type*} [SMulZeroClass A R]

@[to_additive (dont_translate := A) smulZeroClass]
instance smulZeroClass : SMulZeroClass A R[M] := fast_instance% coeffEquiv.smulZeroClass _

@[to_additive (attr := simp) (dont_translate := A) coeff_smul]
lemma coeff_smul (a : A) (x : R[M]) : coeff (a • x) = a • coeff x := rfl

@[to_additive (attr := simp) (dont_translate := A) ofCoeff_smul]
lemma ofCoeff_smul (a : A) (x : M →₀ R) : ofCoeff (a • x) = a • ofCoeff x := rfl

@[to_additive (attr := simp) (dont_translate := A) smul_single]
lemma smul_single (a : A) (m : M) (r : R) : a • single m r = single m (a • r) := by
  ext; simp [single]

@[to_additive (attr := simp) (dont_translate := R) smul_single']
lemma smul_single' (r' : R) (m : M) (r : R) : r' • single m r = single m (r' * r) := smul_single ..

@[to_additive (attr := deprecated coeff_smul (since := "2025-08-15")) (dont_translate := A)]
lemma smul_apply (r : A) (m : M) (x : R[M]) : (r • x).coeff m = r • x.coeff m := rfl

@[to_additive (dont_translate := N) distribSMul]
instance distribSMul [DistribSMul N R] : DistribSMul N R[M] :=
  fast_instance% coeffEquiv.distribSMul _

@[to_additive (dont_translate := N) isScalarTower]
instance isScalarTower [SMulZeroClass N R] [SMulZeroClass O R] [SMul N O] [IsScalarTower N O R] :
    IsScalarTower N O R[M] := coeffEquiv.isScalarTower ..

@[to_additive (dont_translate := N) smulCommClass]
instance smulCommClass [SMulZeroClass N R] [SMulZeroClass O R] [SMulCommClass N O R] :
    SMulCommClass N O R[M] := coeffEquiv.smulCommClass ..

@[to_additive (dont_translate := N) isCentralScalar]
instance isCentralScalar [SMulZeroClass N R] [SMulZeroClass Nᵐᵒᵖ R] [IsCentralScalar N R] :
    IsCentralScalar N R[M] := coeffEquiv.isCentralScalar _

end SMul

/-- `MonoidAlgebra.coeff` as an `AddEquiv`. -/
@[to_additive (attr := simps!)
/-- `AddMonoidAlgebra.coeff` as an `AddEquiv`. -/]
def coeffAddEquiv : R[M] ≃+ (M →₀ R) := coeffEquiv.addEquiv

@[to_additive (attr := simp)] lemma coeff_zero : coeff (0 : R[M]) = 0 := rfl
@[to_additive (attr := simp)] lemma ofCoeff_zero : (ofCoeff 0 : R[M]) = 0 := rfl
@[to_additive (attr := simp)] lemma coeff_eq_zero : coeff x = 0 ↔ x = 0 := coeff_inj
@[to_additive (attr := simp)] lemma ofCoeff_eq_zero {x : M →₀ R} : ofCoeff x = 0 ↔ x = 0 :=
  ofCoeff_inj

@[to_additive (attr := simp)]
lemma coeff_add (x y : R[M]) : coeff (x + y) = coeff x + coeff y := rfl

@[to_additive (attr := simp)]
lemma ofCoeff_add (x y : M →₀ R) : ofCoeff (x + y) = ofCoeff x + ofCoeff y := rfl

@[to_additive (attr := simp)]
lemma coeff_sum (s : Finset ι) (f : ι → R[M]) : coeff (∑ i ∈ s, f i) = ∑ i ∈ s, coeff (f i) :=
  map_sum coeffAddEquiv ..

@[to_additive (attr := simp)]
lemma ofCoeff_sum (s : Finset ι) (f : ι → M →₀ R) :
    ofCoeff (∑ i ∈ s, f i) = ∑ i ∈ s, ofCoeff (f i) := map_sum coeffAddEquiv.symm ..

@[to_additive (attr := simp)]
lemma coeff_finsuppSum [AddCommMonoid N] (f : ι →₀ N) (g : ι → N → R[M]) :
    coeff (f.sum g) = f.sum (fun i n ↦ coeff (g i n)) := map_finsuppSum coeffAddEquiv ..

@[to_additive (attr := simp)]
lemma ofCoeff_finsuppSum [AddCommMonoid N] (f : ι →₀ N) (g : ι → N → M →₀ R) :
    ofCoeff (f.sum g) = f.sum (fun i n ↦ ofCoeff (g i n)) := map_finsuppSum coeffAddEquiv.symm ..

@[to_additive (attr := simp)]
lemma coeff_single (m : M) (r : R) : (single m r).coeff = .single m r := rfl

@[to_additive (attr := simp)]
lemma single_zero (m : M) : (single m 0 : R[M]) = 0 := by simp [single]

@[to_additive (attr := simp)]
lemma single_add (m : M) (r₁ r₂ : R) : single m (r₁ + r₂) = single m r₁ + single m r₂ := by
  simp [single]

@[to_additive (attr := deprecated coeff_add (since := "2025-08-15"))]
lemma coe_add (f g : R[M]) : ⇑(f + g).coeff = f.coeff + g.coeff := rfl

/-- `MonoidAlgebra.single` as an `AddMonoidHom`.

TODO: Rename to `singleAddMonoidHom`. -/
@[to_additive (attr := simps)
/-- `AddMonoidAlgebra.single` as an `AddMonoidHom`.

TODO: Rename to `singleAddMonoidHom`. -/]
def singleAddHom (m : M) : R →+ R[M] where
  toFun := single m
  map_zero' := single_zero _
  map_add' := single_add _

/-- If two additive homomorphisms from `R[M]` are equal on each `single r m`,
then they are equal. -/
@[to_additive
/-- If two additive homomorphisms from `R[M]` are equal on each `single r m`,
then they are equal. -/]
lemma addMonoidHom_ext [AddZeroClass N] ⦃f g : R[M] →+ N⦄
    (h : ∀ m r, f (single m r) = g (single m r)) : f = g := by
  have : f.comp coeffAddEquiv.symm.toAddMonoidHom = g.comp coeffAddEquiv.symm.toAddMonoidHom :=
    Finsupp.addHom_ext h
  convert congr(($this).comp coeffAddEquiv.toAddMonoidHom)

/-- If two additive homomorphisms from `R[M]` are equal on each `single r m`, then they are equal.

We formulate this using equality of `AddMonoidHom`s so that `ext` tactic can apply a type-specific
extensionality lemma after this one.  E.g., if the fiber `M` is `ℕ` or `ℤ`, then it suffices to
verify `f (single a 1) = g (single a 1)`.

TODO: Rename to `addMonoidHom_ext'`. -/
@[to_additive (attr := ext high)
/-- If two additive homomorphisms from `R[M]` are equal on each `single r m`, then they are equal.

We formulate this using equality of `AddMonoidHom`s so that `ext` tactic can apply a type-specific
extensionality lemma after this one.  E.g., if the fiber `M` is `ℕ` or `ℤ`, then it suffices to
verify `f (single a 1) = g (single a 1)`.

TODO: Rename to `addMonoidHom_ext'`. -/]
lemma addHom_ext' {N : Type*} [AddZeroClass N] ⦃f g : R[M] →+ N⦄
    (hfg : ∀ m, f.comp (singleAddHom m) = g.comp (singleAddHom m)) : f = g :=
  addMonoidHom_ext <| by simpa [DFunLike.ext_iff] using hfg

@[to_additive (attr := deprecated Finsupp.sum_single_index (since := "2025-08-14"))]
lemma sum_single_index [AddCommMonoid N] {m : M} {r : R} {h : M → R → N} (h_zero : h m 0 = 0) :
    (single m r).coeff.sum h = h m r := by
  simp [h_zero]

@[to_additive (attr := simp)]
lemma sum_coeff_single (f : R[M]) : f.coeff.sum single = f := by ext; simp

@[to_additive (attr := deprecated sum_coeff_single (since := "2025-08-14"))]
alias sum_single := sum_coeff_single

@[to_additive (attr := deprecated Finsupp.single_apply (since := "2025-08-14"))]
protected theorem single_apply {a a' : M} {b : R} [Decidable (a = a')] :
    (single a b).coeff a' = if a = a' then b else 0 :=
  Finsupp.single_apply

@[to_additive (attr := simp)] lemma single_eq_zero : single m r = 0 ↔ r = 0 := by simp [single]
@[to_additive] lemma single_ne_zero : single m r ≠ 0 ↔ r ≠ 0 := by simp [single]

@[to_additive (attr := elab_as_elim)]
lemma induction_linear {p : R[M] → Prop} (f : R[M]) (zero : p 0)
    (add : ∀ x y : R[M], p x → p y → p (x + y)) (single : ∀ m r, p (single m r)) : p f :=
  Finsupp.induction_linear (motive := (p <| ofCoeff ·)) f.coeff zero (fun _ _ ↦ add _ _)
    (fun _ _ ↦ single _ _)

section One
variable [One M]

/-- The unit of the multiplication is `single 1 1`,
i.e. the function that is `1` at `1` and `0` elsewhere. -/
@[to_additive (dont_translate := R)
/-- The unit of the multiplication is `single 1 1`,
i.e. the function that is `1` at `1` and `0` elsewhere. -/]
instance one : One R[M] where one := single 1 1

@[to_additive (dont_translate := R)] lemma one_def : (1 : R[M]) = single 1 1 := rfl

@[to_additive (attr := simp) (dont_translate := R)]
lemma coeff_one_one : (1 : R[M]).coeff 1 = 1 := by simp [one_def]

end One

section Mul
variable [Mul M]

/-- The multiplication in an additive monoid algebra.

We make it irreducible so that Lean doesn't unfold it when trying to unify two different things. -/
def _root_.AddMonoidAlgebra.mul' [Add M] (x y : AddMonoidAlgebra R M) : AddMonoidAlgebra R M :=
  x.coeff.sum fun m₁ r₁ ↦ y.coeff.sum fun m₂ r₂ ↦ .single (m₁ + m₂) (r₁ * r₂)

/-- The multiplication in a monoid algebra.

We make it irreducible so that Lean doesn't unfold it when trying to unify two different things. -/
@[to_additive existing mul']
def mul' (x y : R[M]) : R[M] :=
  x.coeff.sum fun m₁ r₁ ↦ y.coeff.sum fun m₂ r₂ ↦ single (m₁ * m₂) (r₁ * r₂)

/-- The product of `x y : R[M]` is the finitely supported function whose value at `m` is the sum of
`x m₁ * y m₂` over all pairs `m₁, m₂` such that `m₁ * m₂ = m`.
(Think of the group ring of a group.) -/
@[to_additive instMul]
instance instMul : Mul R[M] where mul := mul'

@[to_additive (dont_translate := R) mul_def]
lemma mul_def (x y : R[M]) :
    x * y = x.coeff.sum fun m₁ r₁ ↦ y.coeff.sum fun m₂ r₂ ↦ single (m₁ * m₂) (r₁ * r₂) := by
  with_unfolding_all rfl

@[to_additive (dont_translate := R)]
instance nonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring R[M] where
  zero_mul := by simp [mul_def]
  mul_zero := by simp [mul_def]
  left_distrib := by classical simp [mul_def, mul_add, sum_add, sum_add_index]
  right_distrib := by classical simp [mul_def, add_mul, sum_add, sum_add_index]

@[to_additive (dont_translate := R) coeff_mul]
lemma coeff_mul [DecidableEq M] (x y : R[M]) (m : M) :
    (x * y).coeff m =
      x.coeff.sum fun m₁ r₁ ↦ y.coeff.sum fun m₂ r₂ ↦ if m₁ * m₂ = m then r₁ * r₂ else 0 := by
  simp [mul_def, Finsupp.single_apply]

@[to_additive (attr := deprecated coeff_mul (since := "2025-08-15")) (dont_translate := R)
  mul_apply]
alias mul_apply := coeff_mul

open Finset in
@[to_additive (dont_translate := R) coeff_mul_antidiag]
lemma coeff_mul_antidiag (x y : R[M]) (m : M) (s : Finset (M × M))
    (hs : ∀ {p}, p ∈ s ↔ p.1 * p.2 = m) : (x * y).coeff m = ∑ p ∈ s, x.coeff p.1 * y.coeff p.2 := by
  classical
  let F (p : M × M) : R := if p.1 * p.2 = m then x.coeff p.1 * y.coeff p.2 else 0
  calc
    (x * y).coeff m = ∑ m₁ ∈ x.coeff.support, ∑ m₂ ∈ y.coeff.support, F (m₁, m₂) := coeff_mul ..
    _ = ∑ p ∈ x.coeff.support ×ˢ y.coeff.support with p.1 * p.2 = m, x.coeff p.1 * y.coeff p.2 := by
      rw [Finset.sum_filter, Finset.sum_product]
    _ = ∑ p ∈ s with p.1 ∈ x.coeff.support ∧ p.2 ∈ y.coeff.support, x.coeff p.1 * y.coeff p.2 := by
      congr! 1; ext; simp only [mem_filter, mem_product, hs, and_comm]
    _ = ∑ p ∈ s, x.coeff p.1 * y.coeff p.2 :=
      sum_subset (filter_subset _ _) fun p hps hp => by
        simp only [mem_filter, mem_support_iff, not_and, Classical.not_not] at hp ⊢
        by_cases h1 : x.coeff p.1 = 0
        · rw [h1, zero_mul]
        · rw [hp hps h1, mul_zero]

@[to_additive (attr := deprecated coeff_mul_antidiag (since := "2025-08-15")) (dont_translate := R)
  mul_apply_antidiagonal]
alias mul_apply_antidiagonal := coeff_mul_antidiag

@[to_additive (attr := simp) (dont_translate := R) single_mul_single]
lemma single_mul_single (m₁ m₂ : M) (r₁ r₂ : R) :
    single m₁ r₁ * single m₂ r₂ = single (m₁ * m₂) (r₁ * r₂) := by simp [mul_def]

@[to_additive (attr := simp) (dont_translate := R) single_commute_single]
lemma single_commute_single (hm : Commute m₁ m₂) (hr : Commute r₁ r₂) :
    Commute (single m₁ r₁) (single m₂ r₂) := by simp [Commute, SemiconjBy, hm.eq, hr.eq]

@[to_additive (attr := simp) (dont_translate := R) single_commute]
lemma single_commute (hm : ∀ m', Commute m m') (hr : ∀ r', Commute r r') (x : R[M]) :
    Commute (single m r) x := by
  have : AddMonoidHom.mulLeft (single m r) = AddMonoidHom.mulRight (single m r) := by
    ext m' r' : 2; exact single_commute_single (hm m') (hr r')
  exact congr($this x)

@[to_additive (dont_translate := R) coeff_mul_single_aux]
lemma coeff_mul_single_aux (H : ∀ m' ∈ x.coeff.support, m' * m = m₁ ↔ m' = m₂) :
    (x * single m r).coeff m₁ = x.coeff m₂ * r := by
  classical
  calc
    (x * single m r).coeff m₁
    _ = x.coeff.sum fun m' r' ↦ if m' * m = m₁ then r' * r else 0 := by simp [coeff_mul]
    _ = x.coeff.sum fun m' r' ↦ if m' = m₂ then r' * r else 0 := by congr! 2; simp [*]
    _ = x.coeff m₂ * r := by simp +contextual [Finsupp.sum_eq_single m₂]

@[to_additive (dont_translate := R) coeff_single_mul_aux]
lemma coeff_single_mul_aux (H : ∀ m' ∈ x.coeff.support, m * m' = m₁ ↔ m' = m₂) :
    (single m r * x).coeff m₁ = r * x.coeff m₂ := by
  classical
  calc
    (single m r * x).coeff m₁
    _ = x.coeff.sum fun m' r' ↦ if m * m' = m₁ then r * r' else 0 := by simp [coeff_mul]
    _ = x.coeff.sum fun m' r' ↦ if m' = m₂ then r * r' else 0 := by congr! 2; simp [*]
    _ = r * x.coeff m₂ := by simp +contextual [Finsupp.sum_eq_single m₂]

@[to_additive (attr := simp) (dont_translate := R) coeff_mul_single_of_forall_add_ne]
lemma coeff_mul_single_of_forall_mul_ne (r : R) (x : R[M]) (h : ∀ d, d * m ≠ m') :
    (x * single m r).coeff m' = 0 := by classical simp [coeff_mul, h]

@[to_additive (attr := simp) (dont_translate := R) coeff_single_mul_of_forall_add_ne]
lemma coeff_single_mul_of_forall_mul_ne (r : R) (x : R[M]) (h : ∀ d, m * d ≠ m') :
    (single m r * x).coeff m' = 0 := by classical simp [coeff_mul, h]

@[to_additive (attr := deprecated coeff_mul_single_of_forall_mul_ne (since := "2025-08-16"))
  (dont_translate := R)]
lemma mul_single_apply_of_not_exists_mul (r : R) {g g' : M} (x : R[M])
    (h : ¬∃ d, g' = d * g) : (x * single g r).coeff g' = 0 :=
  coeff_mul_single_of_forall_mul_ne _ _ <| by simpa [eq_comm] using h

@[to_additive (attr := deprecated coeff_single_mul_of_forall_mul_ne (since := "2025-08-16"))
  (dont_translate := R)]
lemma single_mul_apply_of_not_exists_mul (r : R) {g g' : M} (x : R[M])
    (h : ¬∃ d, g' = g * d) : (single g r * x).coeff g' = 0 :=
  coeff_single_mul_of_forall_mul_ne _ _ <| by simpa [eq_comm] using h

variable (R M : Type*) [Semiring R] [Mul M] in
/-- The embedding of a magma into its magma algebra. -/
@[simps]
def ofMagma : M →ₙ* R[M] where
  toFun a := single a 1
  map_mul' a b := by ext; simp [mul_def, Finsupp.sum_single_index]

end Mul

section Semigroup
variable [Semigroup M]

@[to_additive (dont_translate := R)]
instance nonUnitalSemiring : NonUnitalSemiring R[M] where
  mul_assoc := by simp [mul_def, sum_sum_index, mul_add, add_mul, mul_assoc]

end Semigroup

section MulOneClass
variable [MulOneClass M]

@[to_additive (dont_translate := R)]
instance nonAssocSemiring : NonAssocSemiring R[M] where
  natCast n := single 1 n
  natCast_zero := by simp
  natCast_succ := by simp [one_def]
  one_mul := by simp [mul_def, one_def]
  mul_one := by simp [mul_def, one_def]

@[to_additive (dont_translate := R)]
theorem natCast_def (n : ℕ) : (n : R[M]) = single (1 : M) (n : R) :=
  rfl

@[to_additive (dont_translate := R) coeff_mul_single_zero]
lemma coeff_mul_single_one (x : R[M]) (r : R) (m : M) : (x * single 1 r).coeff m = x.coeff m * r :=
  coeff_mul_single_aux (by simp)

lemma coeff_single_one_mul (x : R[M]) (r : R) (m : M) : (single 1 r * x).coeff m = r * x.coeff m :=
  x.coeff_single_mul_aux (by simp)

@[deprecated (since := "2025-08-16")] alias mul_single_one_apply := coeff_mul_single_one
@[deprecated (since := "2025-08-16")] alias single_one_mul_apply := coeff_single_one_mul

variable (R M : Type*) [Semiring R] [MulOneClass M] in
/-- The embedding of a unital magma into its magma algebra. -/
@[simps]
def of : M →* R[M] where
  __ := ofMagma R M
  map_one' := rfl

lemma of_injective [Nontrivial R] : Function.Injective (of R M) := fun a b h ↦ by
  simpa [← coeff_inj, Finsupp.single_eq_single_iff] using h

lemma of_commute (h : ∀ m', Commute m m') (f : R[M]) : Commute (of R M m) f :=
  single_commute h .one_left f

/-- `MonoidAlgebra.single` as a `MonoidHom` from the product type into the monoid algebra.

Note the order of the elements of the product are reversed compared to the arguments of
`MonoidAlgebra.single`. -/
@[simps]
def singleHom : R × M →* R[M] where
  toFun a := single a.2 a.1
  map_one' := rfl
  map_mul' _a _b := by simp

/-- `MonoidAlgebra.single 1` as a `RingHom` -/
@[to_additive (attr := simps) (dont_translate := R)
/-- `AddMonoidAlgebra.single 1` as a `RingHom` -/]
def singleOneRingHom : R →+* R[M] where
  __ := singleAddHom 1
  map_one' := rfl
  map_mul' := by simp

/-- If two ring homomorphisms from `R[M]` are equal on all `single a 1` and `single 1 b`,
then they are equal. -/
@[to_additive (dont_translate := R S)
/-- If two ring homomorphisms from `R[M]` are equal on all `single a 1` and `single 0 b`,
then they are equal. -/]
lemma ringHom_ext [Semiring S] {f g : R[M] →+* S}
    (h₁ : ∀ r, f (single 1 r) = g (single 1 r)) (h_of : ∀ m, f (single m 1) = g (single m 1)) :
    f = g :=
  RingHom.coe_addMonoidHom_injective <| addMonoidHom_ext fun m r ↦ by
    simpa [← map_mul] using congr($(h₁ r) * $(h_of m))

/-- If two ring homomorphisms from `R[M]` are equal on all `single a 1`
and `single 1 b`, then they are equal.

See note [partially-applied ext lemmas]. -/
@[ext high]
lemma ringHom_ext' [Semiring S] {f g : R[M] →+* S}
    (h₁ : f.comp singleOneRingHom = g.comp singleOneRingHom)
    (h_of : (f : R[M] →* S).comp (of R M) = (g : R[M] →* S).comp (of R M)) : f = g :=
  ringHom_ext (by simpa [DFunLike.ext_iff] using h₁) (by simpa [DFunLike.ext_iff] using h_of)

end MulOneClass

section Monoid
variable [Monoid M]

@[to_additive]
instance semiring : Semiring R[M] where

@[to_additive (attr := simp) (dont_translate := R)]
lemma single_pow (m : M) (r : R) : ∀ n : ℕ, single m r ^ n = single (m ^ n) (r ^ n)
  | 0 => by simp [one_def]
  | n + 1 => by simp [pow_succ, single_pow _ _ n]

lemma induction_on {p : R[M] → Prop} (x : R[M])
    (hM : ∀ m, p (of R M m)) (hadd : ∀ x y : R[M], p x → p y → p (x + y))
    (hsmul : ∀ (r : R) (x), p x → p (r • x)) : p x :=
  Finsupp.induction_linear (motive := fun x ↦ p (ofCoeff x)) x.coeff
    (by simpa using hsmul 0 (of R M 1) (hM 1))
    (fun x y hf hg => hadd (ofCoeff x) (ofCoeff y) hf hg)
    fun m r ↦ by simpa using hsmul r (of R M m) (hM m)

instance isLocalHom_singleOneRingHom : IsLocalHom (singleOneRingHom (R := R) (M := M)) where
  map_nonunit := by
    simp_rw [isUnit_iff_exists]
    rintro a ⟨x, hax, hxa⟩
    refine ⟨x.coeff 1, ?_, ?_⟩
    · simpa [coeff_single_one_mul] using congr(($hax).coeff 1)
    · simpa [coeff_mul_single_one] using congr(($hxa).coeff 1)

end Monoid

section Group
variable [Group G]

@[to_additive (attr := simp) (dont_translate := R) coeff_mul_single]
lemma coeff_mul_single (x : R[G]) (r : R) (g h : G) :
    (x * single g r).coeff h = x.coeff (h * g⁻¹) * r :=
  coeff_mul_single_aux <| by simp [eq_mul_inv_iff_mul_eq]

@[to_additive (attr := simp) (dont_translate := R) coeff_single_mul]
lemma coeff_single_mul (x : R[G]) (r : R) (g h : G) :
    (single g r * x).coeff h = r * x.coeff (g⁻¹ * h) :=
  coeff_single_mul_aux <| by simp [eq_inv_mul_iff_mul_eq]

@[to_additive (dont_translate := R) coeff_mul_left]
lemma coeff_mul_left (x y : R[G]) (g : G) :
    (x * y).coeff g = x.coeff.sum fun h r ↦ r * y.coeff (h⁻¹ * g) := by
  classical rw [coeff_mul]; congr! 1; simp +contextual [← eq_inv_mul_iff_mul_eq]

@[to_additive (dont_translate := R) coeff_mul_right]
lemma coeff_mul_right (x y : R[G]) (g : G) :
    (x * y).coeff g = y.coeff.sum fun h r ↦ x.coeff (g * h⁻¹) * r := by
  classical rw [coeff_mul, Finsupp.sum_comm]; congr! 1; simp +contextual [← eq_mul_inv_iff_mul_eq]

@[deprecated (since := "2025-08-16")] alias mul_single_apply := coeff_mul_single
@[deprecated (since := "2025-08-16")] alias single_mul_apply := coeff_single_mul
@[deprecated (since := "2025-08-16")] alias mul_apply_left := coeff_mul_left
@[deprecated (since := "2025-08-16")] alias mul_apply_right := coeff_mul_right

end Group
end Semiring

section CommSemiring
variable [CommSemiring R]

@[to_additive (dont_translate := R)]
instance nonUnitalCommSemiring [CommSemigroup M] : NonUnitalCommSemiring R[M] where
  mul_comm f g := by simp [mul_def, Finsupp.sum, mul_comm, f.coeff.support.sum_comm]

@[to_additive (dont_translate := R)]
lemma single_one_comm [MulOneClass M] (r : R) (f : R[M]) :
    single (1 : M) r * f = f * single (1 : M) r :=
  single_commute .one_left (.all _) f

section CommMonoid
variable [CommMonoid M]

@[to_additive (dont_translate := R)]
instance commSemiring : CommSemiring R[M] where

open Finset in
@[to_additive (dont_translate := R) prod_single]
lemma prod_single (s : Finset ι) (m : ι → M) (r : ι → R) :
    ∏ i ∈ s, single (m i) (r i) = single (∏ i ∈ s, m i) (∏ i ∈ s, r i) :=
  Finset.cons_induction_on s rfl fun i s hi ih ↦ by
    rw [prod_cons, ih, single_mul_single, prod_cons, prod_cons]

end CommMonoid
end CommSemiring

section Ring
variable [Ring R]

@[to_additive (dont_translate := R)]
instance addCommGroup : AddCommGroup R[M] := fast_instance% coeffEquiv.addCommGroup

@[to_additive (attr := simp) (dont_translate := R)]
lemma coeff_neg (x : R[M]) : (-x).coeff = -x.coeff := rfl

@[to_additive (attr := simp) (dont_translate := R)]
lemma ofCoeff_neg (x : M →₀ R) : ofCoeff (-x) = -ofCoeff x := rfl

@[to_additive (attr := simp) (dont_translate := R)]
lemma single_neg (m : M) (r : R) : single m (-r) = -single m r := by simp [single]

@[to_additive (dont_translate := R)]
instance nonUnitalNonAssocRing [Mul M] : NonUnitalNonAssocRing R[M] where

@[to_additive (dont_translate := R)]
instance nonUnitalRing [Semigroup M] : NonUnitalRing R[M] where

@[to_additive (dont_translate := R)]
instance nonAssocRing [MulOneClass M] : NonAssocRing R[M] where
  intCast z := single 1 z
  intCast_ofNat n := by simp [natCast_def]
  intCast_negSucc n := by simp [natCast_def, one_def]

@[to_additive (dont_translate := R)]
lemma intCast_def [MulOneClass M] (z : ℤ) : (z : R[M]) = single 1 (z : R) := rfl

@[to_additive (dont_translate := R)]
instance ring [Monoid M] : Ring R[M] where

@[deprecated coeff_neg (since := "2025-08-15")]
lemma neg_apply (m : M) (x : R[M]) : (-x).coeff m = -x.coeff m := rfl

end Ring

section CommRing
variable [CommRing R]

@[to_additive (dont_translate := R)]
instance nonUnitalCommRing [CommSemigroup M] : NonUnitalCommRing R[M] where

@[to_additive (dont_translate := R)]
instance commRing [CommMonoid M] : CommRing R[M] where

end CommRing
end MonoidAlgebra

/-! ### Additive monoids -/

namespace AddMonoidAlgebra
variable [Semiring R]

section

variable (R M : Type*) [Semiring R]

/-- The embedding of an additive magma into its additive magma algebra. -/
@[simps]
def ofMagma [Add M] : Multiplicative M →ₙ* R[M] where
  toFun a := single a 1
  map_mul' a b := by simp [mul_def]; rfl

/-- Embedding of a magma with zero into its magma algebra. -/
def of [AddZeroClass M] : Multiplicative M →* R[M] :=
  { ofMagma R M with
    toFun := fun a => single a 1
    map_one' := rfl }

/-- Embedding of a magma with zero `M`, into its magma algebra, having `M` as source. -/
def of' : M → R[M] := fun a => single a 1

end

@[simp]
theorem of_apply [AddZeroClass M] (a : Multiplicative M) : of R M a = single a.toAdd 1 :=
  rfl

@[simp]
theorem of'_apply (a : M) : of' R M a = single a 1 :=
  rfl

theorem of'_eq_of [AddZeroClass M] (a : M) : of' R M a = of R M (.ofAdd a) := rfl

theorem of_injective [Nontrivial R] [AddZeroClass M] : Function.Injective (of R M) := fun a b h ↦ by
  simpa [← coeff_inj, Finsupp.single_eq_single_iff] using h

lemma of'_commute [AddZeroClass M] {a : M} (h : ∀ a', AddCommute a a') (f : AddMonoidAlgebra R M) :
    Commute (of' R M a) f :=
  single_commute h .one_left f

/-- `Finsupp.single` as a `MonoidHom` from the product type into the additive monoid algebra.

Note the order of the elements of the product are reversed compared to the arguments of
`Finsupp.single`.
-/
@[simps]
def singleHom [AddZeroClass M] : R × Multiplicative M →* R[M] where
  toFun a := single a.2.toAdd a.1
  map_one' := rfl
  map_mul' _a _b := (single_mul_single ..).symm

theorem induction_on [AddMonoid M] {p : R[M] → Prop} (x : R[M])
    (hM : ∀ m, p (of R M <| .ofAdd m)) (hadd : ∀ x y : R[M], p x → p y → p (x + y))
    (hsmul : ∀ (r : R) (x), p x → p (r • x)) : p x :=
  Finsupp.induction_linear (motive := fun x ↦ p (ofCoeff x)) x.coeff
    (by simpa using hsmul 0 (of R M 1) (hM 0))
    (fun x y hf hg ↦ hadd (ofCoeff x) (ofCoeff y) hf hg)
    fun m r ↦ by simpa using hsmul r (of R M m) (hM m)

/-! #### Algebra structure -/

/-- If two ring homomorphisms from `R[M]` are equal on all `single a 1`
and `single 0 b`, then they are equal.

See note [partially-applied ext lemmas]. -/
@[ext high]
theorem ringHom_ext' [Semiring S] [AddMonoid M] {f g : R[M] →+* S}
    (h₁ : f.comp singleZeroRingHom = g.comp singleZeroRingHom)
    (h_of : (f : R[M] →* S).comp (of R M) = (g : R[M] →* S).comp (of R M)) :
    f = g :=
  ringHom_ext (RingHom.congr_fun h₁) (DFunLike.congr_fun h_of)

end AddMonoidAlgebra
