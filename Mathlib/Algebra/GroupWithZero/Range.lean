/-
Copyright (c) 2025 Antoine Chambert-Loir and Filippo Nuccio. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Antoine Chambert-Loir, María Inés de Frutos-Fernández, Filippo A. E. Nuccio
-/

import Mathlib.Algebra.Group.Subgroup.Pointwise
import Mathlib.Algebra.GroupWithZero.Units.Lemmas
import Mathlib.Algebra.GroupWithZero.WithZero

/-! # The range of a MonoidWithZeroHom
Given a `MonoidWithZeroHom` `f : A → B` whose codomain `B` is a `MonoidWithZero`, we define the
type `MonoidWithZeroHom.valueMonoid` as the submonoid of `Bˣ` generated by the invertible elements
in the range of `f`. For example, if `A = ℕ`, `f` is the natural cast to `B` where `B` is
* `ℝ≥0`, then `MonoidWithZero.valueMonoid` are the positive natural numbers in `ℝ≥0`;
* `WithZero ℤ`, then `MonoidWithZero.valueMonoid = {1}`.


`MonoidWithZeroHom.valueMonoid₀` is the `MonoidWithZero` obtained by
adjoining `0` to the previous type.

Likewise, `MonoidWithZeroHom.valueGroup` is the *subgroup* of `Bˣ` generated by the invertible
elements in `range f` and ``MonoidWithZeroHom.valueGroup₀` adds a `0` to the previous group.

When `B` is commutative, then both `MonoidWithZeroHom.valueGroup f` and
`MonoidWithZeroHom.valueGroup₀ f` are also commutative and the former can be described more
explicitly (see `MonoidWithZeroHom.mem_valueGroup_iff_of_comm`).

## Main Results
* `valueMonoid f` is the smallest submonoid of `Bˣ` containing the range of `f`;
* `valueMonoid₀ f` is the smallest submonoid with `0` containing the range of `f`;
* `valueGroup f` is the smallest subgroup of `Bˣ` containing the range of `f`;
* `valueMonoid₀ f` is the smallest subgroup with `0` containing the range of `f`;
* When `B` is a group with zero, rather than merely a monoid with zero, the above definitions
all coincide: see `valueMonoid_eq_valueGroup` for an equality as submonoids and
`valueMonoid_eq_valueGroup'` for an equality as subsets.
* When `B` is a *commutative* group with zero, `MonoidWithZeroHom.valueGroup` can be
explicitly described as the elements that are ratios of terms in `range f` , see
`MonoidWithZeroHom.mem_valueGroup_iff_of_comm`.

## Implementation details
`MonoidWithZeroHom.valueMonoid` is defined explicitly in terms of its carrier, by proving the
required properties; that it coincides with the submonoid generated by the closure is proven in
`MonoidWithZeroHom.valueMonoid_eq_closure`, but using the latter as definition yields to unwanted
unfolding.
-/

namespace MonoidWithZeroHom

open Set Subgroup Submonoid

variable {A B F : Type*} [FunLike F A B] (f : F)

section MonoidWithZeroHom

variable [MonoidWithZero A] [MonoidWithZero B] [MonoidWithZeroHomClass F A B]

/-- For a morphism of monoids with zero `f`, this is a smallest submonoid of the invertible
elements in the codomain containing the range of `f`. -/
def valueMonoid : Submonoid Bˣ where
  carrier := (↑)⁻¹' (range f)
  mul_mem' hb hb' := by
    obtain ⟨y, hy⟩ := hb
    obtain ⟨y', hy'⟩ := hb'
    use y * y'
    rw [map_mul, hy, hy', @Units.val_mul]
  one_mem' := ⟨1, by simp⟩

lemma one_mem_valueMonoid : 1 ∈ valueMonoid f := ⟨1, map_one ..⟩

lemma coe_one : (⟨(1 : Bˣ), (one_mem_valueMonoid f)⟩ : valueMonoid f) = 1 := rfl

lemma mem_valueMonoid_iff {b : Bˣ} : b ∈ valueMonoid f ↔ b ∈ (↑)⁻¹' (range f) := Iff.rfl

lemma valueMonoid_eq_closure : valueMonoid f = Submonoid.closure ((↑)⁻¹' (range f)) :=
  (valueMonoid f).closure_eq.symm

/-- For a morphism of monoids with zero `f`, this is the smallest subgroup of the invertible
elements in the codomain containing the range of `f`. -/
def valueGroup : Subgroup Bˣ := closure (valueMonoid f)

lemma valueGroup_def : valueGroup f = Subgroup.closure (valueMonoid f) := rfl

/-- For a morphism of monoids with zero `f`, this is the smallest submonoid with zero of the
codomain containing the range of `f`. -/
abbrev valueMonoid₀ := WithZero (valueMonoid f)

/-- For a morphism of monoids with zero `f`, this is a smallest subgroup with zero of the
codomain containing the range of `f`. -/
abbrev valueGroup₀ := WithZero (valueGroup f)

lemma mem_valueMonoid {b : Bˣ} (hb : b.val ∈ range f) : b ∈ valueMonoid f := by
  rcases hb with ⟨c, _⟩
  simp only [mem_valueMonoid_iff, mem_preimage, mem_range]
  use c

lemma mem_valueGroup {b : Bˣ} (hb : b.1 ∈ range f) : b ∈ valueGroup f := by
  suffices b ∈ valueMonoid f from Subgroup.mem_closure.mpr fun _ a ↦ a this
  exact mem_valueMonoid _ hb

lemma inv_mem_valueGroup {b : Bˣ} (hb : b.1 ∈ range f) : b⁻¹ ∈ valueGroup f :=
  Subgroup.inv_mem _ (mem_valueGroup f hb)

end MonoidWithZeroHom

noncomputable section Restrict

variable [MonoidWithZero A] [GroupWithZero B] [MonoidWithZeroHomClass F A B]

open Function

open Classical in
/-- The inclusion of `valueGroup₀ f` into `B` as a multiplicative homomorphism. -/
def valueGroup₀_MulWithZeroHom : valueGroup₀ f →*₀ B :=
  (withZeroUnitsHom).comp <| WithZero.map' (valueGroup f).subtype

lemma valueGroup₀_MulWithZeroHom_injective : Injective (valueGroup₀_MulWithZeroHom f) := by
  classical
  change Injective <| WithZero.withZeroUnitsEquiv.toEquiv ∘ _
  rw [Equiv.comp_injective]
  exact WithZero.map'_injective <| subtype_injective (valueGroup f)

variable {f} in
lemma valueGroup₀_MulWithZeroHom_surjective (hf : Surjective f) :
    Surjective (valueGroup₀_MulWithZeroHom f) := by
  classical
  change Surjective <| WithZero.withZeroUnitsEquiv.toEquiv ∘ _
  rw [Equiv.comp_surjective]
  apply WithZero.map'_surjective
  simp
  refine range_eq_univ.mp ?_
  simp only [Subtype.range_coe_subtype, SetLike.setOf_mem_eq, coe_eq_univ]
  rw [Subgroup.eq_top_iff']
  intro b
  obtain ⟨a, ha⟩ := hf b
  apply mem_valueGroup
  use a

def valueGroup₀_MulEquiv_of_surjective (hf : Surjective f) : valueGroup₀ f ≃* B :=
  .ofBijective _ ⟨valueGroup₀_MulWithZeroHom_injective f, valueGroup₀_MulWithZeroHom_surjective hf⟩


-- variable (f) in
open Classical in
/-- This is the restriction of `f` as a function taking values in `valueGroup₀ f`. It cannot land
in `valueMonoid₀ f` because in general `f a` needs not be a unit, so it will not be in
`valueMonoid₀ f`. -/
@[simps!]
def restrict₀ : A →*₀ (valueGroup₀ f) where
  toFun a :=
    if h : f a ≠ 0 then (⟨Units.mk0 (f a) h, mem_valueGroup _ ⟨a, rfl⟩⟩ : valueGroup f) else 0
  map_one' := by simp; rfl
  map_mul' := by
    intro a b
    simp only [map_mul, ne_eq, Units.mk0_mul, dite_mul, zero_mul]
    split_ifs with h hb ha
    any_goals rfl
    all_goals rw [mul_eq_zero] at h; tauto
  map_zero' := by simp

variable {f}

-- @[simp]
lemma restrict₀_of_ne_zero {a : A} (h : f a ≠ 0) :
    restrict₀ f a = (⟨Units.mk0 (f a) h, mem_valueGroup _ ⟨a, rfl⟩⟩ : valueGroup f) :=
  by simp [restrict₀_apply, h]

@[simp]
lemma restrict₀_of_eq_zero {a : A} (h : f a = 0) :
    restrict₀ f a = 0 := by simp [restrict₀_apply, h]

@[simp 1010]
lemma restrict₀_eq_zero_iff {a : A} : restrict₀ f a = 0 ↔ f a = 0 := by
  refine ⟨fun h ↦ ?_, restrict₀_of_eq_zero⟩
  · by_contra H; simp [H] at h

lemma restrict₀_eq (a : A) : valueGroup₀_MulWithZeroHom f (restrict₀ f a) = f a := by
  simp [restrict₀_apply]
  split_ifs with h
  · simp [h]
  · rfl

@[simp 1010]
lemma restrict₀_eq_one_iff {a : A} : restrict₀ f a = 1 ↔ f a = 1 := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · apply_fun (valueGroup₀_MulWithZeroHom f) at h
    rwa [restrict₀_eq] at h
  · simp [h]
    rfl


end Restrict
noncomputable section GroupWithZero

variable [GroupWithZero A] [GroupWithZero B] [MonoidWithZeroHomClass F A B] {f}

/- When the *domain* is itself a group with zero, the `valueMonoid` and the `valueGroup` coincide.-/
lemma valueMonoid_eq_valueGroup : (valueMonoid f) = (valueGroup f).toSubmonoid := by
  rw [valueGroup_def, Subgroup.closure_toSubmonoid, Eq.comm]
  apply Submonoid.closure_eq_of_le
  · simp only [union_subset_iff, subset_refl, true_and]
    intro _ ⟨y, hy⟩
    use y⁻¹
    simp [hy]
  · simp [Submonoid.closure_union]

variable (f)

lemma valueMonoid_eq_valueGroup' : (valueMonoid f : Set Bˣ) = valueGroup f := by
  rw [valueMonoid_eq_valueGroup, coe_toSubmonoid]

lemma valueGroup_eq_range : Units.val '' (valueGroup f) = (range f \ {0}) := by
  ext x
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · obtain ⟨y, ⟨hy, rfl⟩⟩ := h
    simp only [mem_diff, mem_range, mem_singleton_iff, Units.ne_zero, not_false_eq_true, and_true]
    obtain ⟨a, _⟩ := (valueMonoid_eq_valueGroup' f).symm ▸ hy
    use a
  · simp only [mem_diff, mem_range, mem_singleton_iff] at h
    obtain ⟨⟨y, hy⟩, hx₀⟩ := h
    refine ⟨Units.mk0 x hx₀, ?_, rfl⟩
    simpa [← valueMonoid_eq_valueGroup', Units.val_mk0, mem_range] using ⟨y, hy⟩

lemma restrict₀_range_eq_top : range (restrict₀ f) = ⊤ := by
  rw [top_eq_univ, range_eq_univ]
  intro x
  match x with
  | 0 => use 0; simp
  | some ⟨u, hu⟩ =>
    change u ∈ (valueGroup f : Set Bˣ) at hu
    rw [← valueMonoid_eq_valueGroup'] at hu
    obtain ⟨v, hv⟩ := hu
    use v
    simp [restrict₀_apply, hv, Units.ne_zero, WithZero.coe]


-- def restrict₀_valueGroup_equiv : valueMonoid (restrict₀ f) ≃ valueMonoid f where
--   toFun z := by
--     rcases z with ⟨x, hx⟩
--     rw [mem_valueMonoid_iff] at hx
--
--   invFun x := by sorry
--   left_inv x := by sorry
--   right_inv x := by sorry

--
-- def restrict₀_valueGroup_equiv : valueGroup (restrict₀ f) ≃ valueGroup f where
--   toFun x := by
--   invFun x := by sorry
--   left_inv x := by sorry
--   right_inv x := by sorry
open Function

def restrict₀_valueGroup₀_MulEquiv : valueGroup₀ (restrict₀ f) ≃* valueGroup₀ f :=
    valueGroup₀_MulEquiv_of_surjective (restrict₀ f)
      <| by simpa [← Set.range_eq_univ] using restrict₀_range_eq_top _


def restrict₀_valueGroup₀_MonoidWithZeroHom : valueGroup₀ (restrict₀ f) →*₀ valueGroup₀ f where
  __ := restrict₀_valueGroup₀_MulEquiv f
  map_zero' := by simp
  map_one' := by simp

end GroupWithZero
section CommGroupWithZero
--
variable [MonoidWithZero A] [CommGroupWithZero B] [MonoidWithZeroHomClass F A B]

theorem mem_valueGroup_iff_of_comm {y : Bˣ} :
    y ∈ (valueGroup f) ↔ ∃ a, f a ≠ 0 ∧ ∃ x, f a * y = f x := by
  refine ⟨fun hy ↦ ?_, fun ⟨a, ha, ⟨x, hy⟩⟩ ↦ ?_⟩
  · simp only [valueGroup, valueMonoid, Submonoid.coe_set_mk, Subsemigroup.coe_set_mk] at hy
    induction hy using Subgroup.closure_induction with
    | mem _ h =>
      obtain ⟨a, ha⟩ := h
      exact ⟨a, ha.symm ▸ Units.ne_zero _, ⟨a * a, by simp [← ha]⟩⟩
    | one => exact ⟨1, by simp, 1, by simp⟩
    | mul c d hc hd hcy hdy =>
      obtain ⟨u, hu, a, ha⟩ := hcy
      obtain ⟨v, hv, b, hb⟩ := hdy
      refine ⟨u * v, by simp [hu, hv], a * b, ?_⟩
      simpa [map_mul, Units.val_mul, ← hb, ← ha] using mul_mul_mul_comm ..
    | inv c hc hcy  =>
      obtain ⟨u, hu, a, ha⟩ := hcy
      exact ⟨a, by simp [← ha, hu], u, by simp [← ha]⟩
  · have hv : f x ≠ 0 := by
      simp only [← hy, ne_eq, mul_eq_zero, ha, Units.ne_zero, or_self, not_false_eq_true]
    let v := (Ne.isUnit hv).unit
    have hv₀ : f x = ↑v := IsUnit.unit_spec (Ne.isUnit hv)
    let u := (Ne.isUnit ha).unit
    have ha₀ : f a = ↑u := IsUnit.unit_spec (Ne.isUnit ha)
    rw_mod_cast [hv₀, ha₀, Eq.comm, ← inv_mul_eq_iff_eq_mul] at hy
    rw [← hy]
    apply Subgroup.mul_mem
    · apply inv_mem_valueGroup
      use a
    · apply mem_valueGroup
      use x

instance : CommGroupWithZero (valueGroup₀ f) where
  mul_comm _ _ := mul_comm ..


end CommGroupWithZero

end MonoidWithZeroHom

namespace MonoidHomWithZero

@[deprecated (since := "2025-07-02")] alias valueMonoid := MonoidWithZeroHom.valueMonoid
@[deprecated (since := "2025-07-02")] alias valueGroup := MonoidWithZeroHom.valueGroup
@[deprecated (since := "2025-07-02")] alias valueMonoid₀ := MonoidWithZeroHom.valueMonoid₀
@[deprecated (since := "2025-07-02")] alias valueGroup₀ := MonoidWithZeroHom.valueGroup₀

end MonoidHomWithZero
