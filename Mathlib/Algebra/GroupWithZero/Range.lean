/-
Copyright (c) 2025 Antoine Chambert-Loir and Filippo Nuccio. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Antoine Chambert-Loir, María Inés de Frutos-Fernández, Filippo A. E. Nuccio
-/

import Mathlib.Algebra.Group.Subgroup.Pointwise
import Mathlib.Algebra.GroupWithZero.Units.Lemmas
import Mathlib.Algebra.GroupWithZero.WithZero

/-! # The range of a MonoidHomWithZero
Given a `MonoidWithZeroHom` `f : A → B` whose codomain `B` is a `MonoidWithZero`, we define the
type `MonoidHomWithZero.valueMonoid` as the submonoid of `Bˣ` generated by the invertible elements
in the range of `f`; `MonoidHomWithZero.valueMonoid₀` is the `MonoidWithZero` obtained by
adjoining `0` to the previous type.

Likewise, `MonoidHomWithZero.valueGroup` is the *subgroup* of `Bˣ` generated by the invertible
elements in `range f` and ``MonoidHomWithZero.valueGroup₀` adds a `0` to the previous group.

When `B` is commutative, then both `MonoidHomWithZero.valueGroup f` and
`MonoidHomWithZero.valueGroup₀ f` are also commutative and the former can be described more
explicitly (see `MonoidHomWithZero.mem_valueGroup_iff_of_comm`).

## Main Results
* `valueMonoid f` is the smallest submonoid of `Bˣ` containing the range of `f`;
* `valueMonoid₀ f` is the smallest submonoid with `0` containing the range of `f`;
* `valueGroup f` is the smallest subgroup of `Bˣ` containing the range of `f`;
* `valueMonoid₀ f` is the smallest subgroup with `0` containing the range of `f`;
* When `B` is a group with zero, rather than merely a monoid with zero, the above definitions
all coincide: see `valueMonoid_eq_valueGroup` for an equality as submonoids and
`valueMonoid_eq_valueGroup'` for an equality as subsets.
* When `B` is a *commutative* group with zero, `MonoidHomWithZero.valueGroup` can be
explicitely descibed as the elements that are ratios of terms in `range f` , see
`MonoidHomWithZero.mem_valueGroup_iff_of_comm`.

## Implementation details
`MonoidHomWithZero.valueMonoid` is defined explicitely in terms of its carrier, by proving the
required properties; that it coincides with the submonoid generated by the closure is proven in
`MonoidHomWithZero.valueMonoid_eq_closure`, but using the latter as definition yields to unwanted
unfolding.
-/

namespace MonoidHomWithZero

open Set Subgroup Submonoid

variable {A B F : Type*} [FunLike F A B] (f : F)

section MonoidWithZero

variable [MonoidWithZero A] [MonoidWithZero B] [MonoidWithZeroHomClass F A B]

/-- For a morphism of monoids with zero `f`, this is a smallest submonoid of the invertible
elements in the codomain containing the range of `f`. -/
def valueMonoid : Submonoid Bˣ where
  carrier := (↑)⁻¹' (range f)
  mul_mem' {_ _} hb hb' := by
    obtain ⟨y, hy⟩ := hb
    obtain ⟨y', hy'⟩ := hb'
    use y * y'
    rw [map_mul, hy, hy', @Units.val_mul]
  one_mem' := ⟨1, by simp⟩

lemma mem_valueMonoid_iff (b : Bˣ) : b ∈ valueMonoid f ↔ b ∈ (↑)⁻¹' (range f) := Iff.rfl

lemma valueMonoid_eq_closure : valueMonoid f = Submonoid.closure ((↑)⁻¹' (range f)) :=
  (valueMonoid f).closure_eq.symm

/-- For a morphism of monoids with zero `f`, this is a smallest subgroup of the invertible
elements in the codomain containing the range of `f`. -/
def valueGroup : Subgroup Bˣ := closure (valueMonoid f)

lemma valueGroup_def : valueGroup f = Subgroup.closure (valueMonoid f) := rfl

/-- For a morphism of monoids with zero `f`, this is a smallest submonoid with zero of the
codomain containing the range of `f`. -/
abbrev valueMonoid₀ := WithZero (valueMonoid f)

/-- For a morphism of monoids with zero `f`, this is a smallest subgroup with zero of the
codomain containing the range of `f`. -/
abbrev valueGroup₀ := WithZero (valueGroup f)

-- instance : CoeOut (valueGroup₀ f) B :=
--   ⟨fun x ↦ match x with | 0 => 0 | some b => b.1⟩
--
-- lemma coe_ne_zero [Nontrivial B] {x : valueGroup₀ f} (hx : x ≠ 0) : (↑x : B) ≠ 0 := by
--   obtain ⟨b, hb⟩ := Option.ne_none_iff_exists'.mp hx
--   simp [hb]

instance : MonoidWithZero (valueMonoid₀ f) := inferInstance

instance : GroupWithZero (valueGroup₀ f) := inferInstance

lemma mem_valueMonoid
    {b : Bˣ} (hb : b.1 ∈ range f) : b ∈ valueMonoid f := by
  rcases hb with ⟨c, _⟩
  simp only [mem_valueMonoid_iff, mem_preimage, mem_range]
  use c

lemma mem_valueGroup
    {b : Bˣ} (hb : b.1 ∈ range f) : b ∈ valueGroup f := by
  suffices b ∈ valueMonoid f from Subgroup.mem_closure.mpr fun _ a ↦ a this
  exact mem_valueMonoid _ hb

lemma inv_mem_valueGroup
    {b : Bˣ} (hb : b.1 ∈ range f) : b⁻¹ ∈ valueGroup f :=
  Subgroup.inv_mem _ (mem_valueGroup f hb)

end MonoidWithZero

noncomputable section GroupWithZero

variable [GroupWithZero B]
--
-- open WithZero in
-- def toValueGroup₀ [MonoidWithZero A] [MonoidWithZeroHomClass F A B] (f : F)
--     [DecidableEq B] : range f → valueGroup₀ f := by
--   rintro ⟨b, hb⟩
--   by_cases hb₀ : b = 0
--   · use 0
--   · use coe ⟨(Ne.isUnit hb₀).unit, mem_valueGroup f hb⟩

variable [GroupWithZero A] [MonoidWithZeroHomClass F A B] {f}

/- When the *domain* is itself a group with zero, the `valueMonoid` and the `valueGroup` coincide.-/
lemma valueMonoid_eq_valueGroup : (valueMonoid f) = (valueGroup f).toSubmonoid := by
  simp [valueGroup]
  rw [Subgroup.closure_toSubmonoid]
  rw [Eq.comm]
  apply Submonoid.closure_eq_of_le
  · simp only [union_subset_iff, subset_refl, true_and, valueMonoid]
    intro x ⟨y, hy⟩
    simp at hy
    use y⁻¹
    simp only [MulEquiv.toMonoidHom_eq_coe, MonoidHom.coe_comp, MonoidHom.coe_coe,
      Function.comp_apply, map_inv₀]
    rw [hy]
    simp
  · rw [Submonoid.closure_union]
    simp

lemma valueMonoid_eq_valueGroup' : ((valueMonoid f) : Set Bˣ) = valueGroup f := by
  rw [valueMonoid_eq_valueGroup]
  rfl

lemma valueGroup_eq_range : Units.val '' (valueGroup f) = (range f \ {0}) := by
  ext x
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · rw [← valueMonoid_eq_valueGroup'] at h
    obtain ⟨y, ⟨hy, rfl⟩⟩  := h
    simp only [Subgroup.coe_toSubmonoid, Subgroup.closure_eq, SetLike.mem_coe] at hy
    simp
    simp [valueMonoid] at hy
    obtain ⟨a, ha⟩ := hy
    use a
  · rw [← valueMonoid_eq_valueGroup']
    simp only [mem_diff, mem_range, mem_singleton_iff] at h
    obtain ⟨⟨y, hy⟩, hx₀⟩ := h
    set u : Bˣ := Units.mk0 x hx₀ with hu
    simp
    use u
    constructor
    · apply mem_valueMonoid
      rw [hu]
      simp
      use y
    · rfl


end GroupWithZero
section CommGroupWithZero
--
variable [MonoidWithZero A] [CommGroupWithZero B] [MonoidWithZeroHomClass F A B]


theorem mem_valueGroup_iff_of_comm (y : Bˣ) :
    y ∈ (valueGroup f) ↔ ∃ a, f a ≠ 0 ∧ ∃ x, f a * y = f x := by
  refine ⟨fun hy ↦ ?_, fun ⟨a, ha, ⟨x, hy⟩⟩ ↦ ?_⟩
  · simp only [valueGroup, valueMonoid, Submonoid.coe_set_mk, Subsemigroup.coe_set_mk] at hy
    induction hy using Subgroup.closure_induction with
    | mem _ h =>
      obtain ⟨a, ha⟩ := h
      exact ⟨a, ha.symm ▸ Units.ne_zero _, ⟨a * a, by simp [← ha]⟩⟩
    | one => exact ⟨1, by simp, 1, by simp⟩
    | mul c d hc hd hcy hdy =>
      obtain ⟨u, hu, ⟨a, ha⟩⟩ := hcy
      obtain ⟨v, hv, ⟨b, hb⟩⟩ := hdy
      refine ⟨u * v, by simp [hu, hv], a * b, ?_⟩
      simpa [map_mul, Units.val_mul, ← hb, ← ha] using mul_mul_mul_comm ..
    | inv c hc hcy  =>
      obtain ⟨u, hu, ⟨a, ha⟩⟩ := hcy
      exact ⟨a, by simp [← ha, hu], u, by simp [← ha]⟩
  · have hv : f x ≠ 0 := by
      rw [← hy]
      simp [ha]
    let v := (Ne.isUnit hv).unit
    have hv₀ : f x = ↑v := rfl
    rw [hv₀] at hy
    let u := (Ne.isUnit ha).unit
    have ha₀ : f a = ↑u := rfl
    rw [ha₀] at hy
    norm_cast at hy
    rw [Eq.comm, ← inv_mul_eq_iff_eq_mul] at hy
    rw [← hy]
    apply Subgroup.mul_mem
    · apply inv_mem_valueGroup
      use a
    · apply mem_valueGroup
      use x


-- theorem mem_valueGroup₀_iff_of_comm (y : B) :
--     y ∈ range ((↑) : valueGroup₀ f → _) ↔ ∃ a, f a ≠ 0 ∧ ∃ x, f a * y = f x := by
--   by_cases hy : y ≠ 0
--   · refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
--     · obtain ⟨u, hu⟩ := h
--       replace hu : u ≠ 0 := sorry
--       have := coe_ne_zero f hu
--       have mm := (mem_valueGroup_iff_of_comm f)






instance : CommGroupWithZero (valueGroup₀ f) where
  toGroupWithZero := inferInstance
  mul_comm _ _ := mul_comm ..


end CommGroupWithZero

end MonoidHomWithZero
