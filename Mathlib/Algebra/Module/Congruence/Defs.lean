/-
Copyright (c) 2025 Junyan Xu. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Junyan Xu
-/
import Mathlib.Algebra.Module.Equiv.Defs
import Mathlib.GroupTheory.Congruence.Basic

/-!
# Congruence relations respecting scalar multiplication
-/

variable (R S M N : Type*)

/-- A congruence relation that preserves additive action. -/
structure VAddCon [VAdd S M] extends Setoid M where
  /-- A `VAddCon` is closed under additive action. -/
  vadd (s : S) {x y} : r x y → r (s +ᵥ x) (s +ᵥ y)

/-- A congruence relation that preserves scalar multiplication. -/
@[to_additive] structure SMulCon [SMul S M] extends Setoid M where
  /-- A `SMulCon` is closed under scalar multiplication. -/
  smul (s : S) {x y} : r x y → r (s • x) (s • y)

/-- A congruence relation that preserves addition and scalar multiplication.
The quotient by a `ModuleCon` inherits `DistribSMul`, `DistribMulAction`, and `Module` instances. -/
structure ModuleCon [Add M] [SMul S M] extends AddCon M, SMulCon S M

/-- The `SMulCon` underlying an `ModuleCon`. -/
add_decl_doc ModuleCon.toSMulCon

variable {S M}

namespace SMulCon

variable (S) in
/-- The inductively defined smallest `VAddCon` containing a given binary
relation. -/
inductive _root_.VAddConGen.Rel [VAdd S M] (r : M → M → Prop) : M → M → Prop
  | of : ∀ x y, r x y → VAddConGen.Rel r x y
  | refl : ∀ x, VAddConGen.Rel r x x
  | symm : ∀ {x y}, VAddConGen.Rel r x y → VAddConGen.Rel r y x
  | trans : ∀ {x y z}, VAddConGen.Rel r x y → VAddConGen.Rel r y z → VAddConGen.Rel r x z
  | vadd : ∀ (s : S) {x y}, VAddConGen.Rel r x y → VAddConGen.Rel r (s +ᵥ x) (s +ᵥ y)

variable (S) in
/-- The inductively defined smallest `SMulCon` containing a given binary
relation. -/
@[to_additive VAddConGen.Rel]
inductive _root_.SMulConGen.Rel [SMul S M] (r : M → M → Prop) : M → M → Prop
  | of : ∀ x y, r x y → SMulConGen.Rel r x y
  | refl : ∀ x, SMulConGen.Rel r x x
  | symm : ∀ {x y}, SMulConGen.Rel r x y → SMulConGen.Rel r y x
  | trans : ∀ {x y z}, SMulConGen.Rel r x y → SMulConGen.Rel r y z → SMulConGen.Rel r x z
  | smul : ∀ (s : S) {x y}, SMulConGen.Rel r x y → SMulConGen.Rel r (s • x) (s • y)

variable (S) in
/-- The inductively defined smallest `SMulCon` containing a given binary
relation. -/
@[to_additive /-- The inductively defined smallest `VAddCon` containing
a given binary relation. -/]
def _root_.smulConGen [SMul S M] (r : M → M → Prop) : SMulCon S M where
  r := SMulConGen.Rel S r
  iseqv := ⟨SMulConGen.Rel.refl, SMulConGen.Rel.symm, SMulConGen.Rel.trans⟩
  smul := SMulConGen.Rel.smul

/-- A coercion from a `SMulCon` to its underlying binary relation. -/
@[to_additive
/-- A coercion from a `VAddCon` to its underlying binary relation. -/]
instance [SMul S M] : FunLike (SMulCon S M) M (M → Prop) where
  coe c := c.r
  coe_injective' x y h := by
    rcases x with ⟨⟨x, _⟩, _⟩
    rcases y with ⟨⟨y, _⟩, _⟩
    have : x = y := h
    subst x; rfl

@[to_additive (attr := simp)]
theorem rel_eq_coe [SMul S M] (c : SMulCon S M) : c.r = c :=
  rfl

@[to_additive]
lemma smulConGen_le [SMul S M] {r : M → M → Prop} {c : SMulCon S M}
    (h : ∀ x y, r x y → c x y) : smulConGen S r ≤ c := sorry

/-- The quotient by a congruence relation preserving scalar multiplication. -/
@[to_additive /-- The quotient by a congruence relation preserving additive action. -/]
protected def Quotient [SMul S M] (c : SMulCon S M) : Type _ := Quotient c.toSetoid

@[to_additive] instance [SMul S M] (c : SMulCon S M) : SMul S c.Quotient where
  smul s := Quotient.map (s • ·) (@c.smul s)

instance [SMul S M] [Zero M] (c : SMulCon S M) : Zero c.Quotient where
  zero := ⟦0⟧

instance [Zero M] [SMulZeroClass S M] (c : SMulCon S M) : SMulZeroClass S c.Quotient where
  smul_zero s := congr_arg _ (smul_zero s)

instance [Zero S] [Zero M] [SMulWithZero S M] (c : SMulCon S M) : SMulWithZero S c.Quotient :=
  fast_instance% Quotient.mk''_surjective.smulWithZero ⟨_, rfl⟩ fun _ _ ↦ rfl

@[to_additive] instance [Monoid S] [MulAction S M] (c : SMulCon S M) : MulAction S c.Quotient :=
  fast_instance% Quotient.mk''_surjective.mulAction (⟦·⟧) fun _ _ ↦ rfl

section addConGen

variable [AddZeroClass M] [DistribSMul S M]

/-- The `AddCon` generated by a relation respecting scalar multiplication is a `ModuleCon`. -/
def addConGen' (r : M → M → Prop) (hr : ∀ (s : S) {m m'}, r m m' → r (s • m) (s • m')) :
    ModuleCon S M where
  toAddCon := addConGen r
  smul s _ _ h := ((addConGen r).comap (DistribSMul.toAddMonoidHom M s) <| by simp).addConGen_le
    (fun _ _ h ↦ .of _ _ (hr s h)) h

/-- The `AddCon` generated by a `SMulCon` is a `ModuleCon`. -/
protected abbrev addConGen (c : SMulCon S M) : ModuleCon S M := addConGen' c.r c.smul

end addConGen

end SMulCon

namespace ModuleCon

variable (S) in
/-- The inductively defined smallest `ModuleCon` containing a given binary
relation. -/
inductive _root_.ModuleConGen.Rel [Add M] [SMul S M] (r : M → M → Prop) : M → M → Prop
  | of : ∀ x y, r x y → ModuleConGen.Rel r x y
  | refl : ∀ x, ModuleConGen.Rel r x x
  | symm : ∀ {x y}, ModuleConGen.Rel r x y → ModuleConGen.Rel r y x
  | trans : ∀ {x y z}, ModuleConGen.Rel r x y → ModuleConGen.Rel r y z → ModuleConGen.Rel r x z
  | add : ∀ {w x y z}, ModuleConGen.Rel r w x → ModuleConGen.Rel r y z →
      ModuleConGen.Rel r (w + y) (x + z)
  | smul : ∀ (s : S) {x y}, ModuleConGen.Rel r x y → ModuleConGen.Rel r (s • x) (s • y)

variable (S) in
/-- The inductively defined smallest `ModuleCon` containing a given binary
relation. -/
def _root_.moduleConGen [Add M] [SMul S M] (r : M → M → Prop) : ModuleCon S M where
  r := ModuleConGen.Rel S r
  iseqv := ⟨ModuleConGen.Rel.refl, ModuleConGen.Rel.symm, ModuleConGen.Rel.trans⟩
  add' := ModuleConGen.Rel.add
  smul := ModuleConGen.Rel.smul

/-- A coercion from a `ModuleCon` to its underlying binary relation. -/
instance [Add M] [SMul S M] : FunLike (ModuleCon S M) M (M → Prop) where
  coe c := c.r
  coe_injective' x y h := by
    rcases x with ⟨⟨⟨x, _⟩, _⟩, _⟩
    rcases y with ⟨⟨⟨y, _⟩, _⟩, _⟩
    have : x = y := h
    subst x; rfl

@[simp]
theorem rel_eq_coe [Add M] [SMul S M] (c : ModuleCon S M) : c.r = c :=
  rfl

/-- The quotient by a congruence relation preserving addition and scalar multiplication. -/
protected def Quotient [Add M] [SMul S M] (c : ModuleCon S M) : Type _ := Quotient c.toSetoid

instance [SMul S M] [Add M] (c : ModuleCon S M) : SMul S c.Quotient :=
  inferInstanceAs (SMul S c.toSMulCon.Quotient)

instance [SMul S M] [Zero M] [Add M] (c : ModuleCon S M) : Zero c.Quotient where
  zero := ⟦0⟧

instance [SMul S M] [Add M] (c : ModuleCon S M) : Add c.Quotient :=
  inferInstanceAs (Add c.toAddCon.Quotient)

instance [SMul S M] [AddZeroClass M] (c : ModuleCon S M) : AddZeroClass c.Quotient :=
  inferInstanceAs (AddZeroClass c.toAddCon.Quotient)

instance [SMul S M] [AddCommMagma M] (c : ModuleCon S M) : AddCommMagma c.Quotient :=
  inferInstanceAs (AddCommMagma c.toAddCon.Quotient)

instance [SMul S M] [AddSemigroup M] (c : ModuleCon S M) : AddSemigroup c.Quotient :=
  inferInstanceAs (AddSemigroup c.toAddCon.Quotient)

instance [SMul S M] [AddCommSemigroup M] (c : ModuleCon S M) : AddCommSemigroup c.Quotient :=
  inferInstanceAs (AddCommSemigroup c.toAddCon.Quotient)

instance [SMul S M] [AddMonoid M] (c : ModuleCon S M) : AddMonoid c.Quotient :=
  inferInstanceAs (AddMonoid c.toAddCon.Quotient)

instance [SMul S M] [AddCommMonoid M] (c : ModuleCon S M) : AddCommMonoid c.Quotient :=
  inferInstanceAs (AddCommMonoid c.toAddCon.Quotient)

instance [SMul S M] [AddGroup M] (c : ModuleCon S M) : AddGroup c.Quotient :=
  inferInstanceAs (AddGroup c.toAddCon.Quotient)

instance [SMul S M] [AddCommGroup M] (c : ModuleCon S M) : AddCommGroup c.Quotient :=
  inferInstanceAs (AddCommGroup c.toAddCon.Quotient)

instance [Zero M] [Add M] [SMulZeroClass S M] (c : ModuleCon S M) : SMulZeroClass S c.Quotient :=
  inferInstanceAs (SMulZeroClass S c.toSMulCon.Quotient)

instance [Zero S] [Zero M] [Add M] [SMulWithZero S M] (c : ModuleCon S M) :
    SMulWithZero S c.Quotient :=
  inferInstanceAs (SMulWithZero S c.toSMulCon.Quotient)

instance [Monoid S] [Add M] [MulAction S M] (c : ModuleCon S M) : MulAction S c.Quotient :=
  inferInstanceAs (MulAction S c.toSMulCon.Quotient)

instance [AddZeroClass M] [DistribSMul S M] (c : ModuleCon S M) : DistribSMul S c.Quotient :=
  fast_instance% Quotient.mk''_surjective.distribSMul c.mk' fun _ _ ↦ rfl

instance [Monoid S] [AddMonoid M] [DistribMulAction S M] (c : ModuleCon S M) :
    DistribMulAction S c.Quotient := fast_instance%
  Quotient.mk''_surjective.distribMulAction c.mk' fun _ _ ↦ rfl

instance [Semiring S] [AddCommMonoid M] [Module S M] (c : ModuleCon S M) : Module S c.Quotient :=
  fast_instance% Quotient.mk''_surjective.module _ c.mk' fun _ _ ↦ rfl

end ModuleCon

section ker

variable {R N}

/-- The kernel of a `MulActionHom` as a congruence relation. -/
@[to_additive /-- The kernel of an `AddActionHom` as a congruence relation. -/]
def SMulCon.ker [SMul R M] [SMul S N] {φ : R → S} (f : M →ₑ[φ] N) : SMulCon R M where
  __ := Setoid.ker f
  smul r _ _ h := by rw [Setoid.ker_def] at h ⊢; simp_rw [map_smulₛₗ, h]

/-- The kernel of a `DistribMulActionHom` as a congruence relation. -/
def ModuleCon.ker [Monoid R] [Monoid S] [AddMonoid M] [AddMonoid N] [DistribMulAction R M]
    [DistribMulAction S N] {φ : R →* S} (f : M →ₑ+[φ] N) : ModuleCon R M where
  __ := SMulCon.ker f.toMulActionHom
  __ := AddCon.ker f

/-- The first isomorphism theorem for semimodules in the case of a surjective homomorphism. -/
noncomputable def ModuleCon.quotientKerEquivOfSurjective [Semiring S] [AddCommMonoid M]
    [AddCommMonoid N] [Module S M] [Module S N] (f : M →ₗ[S] N) (hf : Function.Surjective f) :
    (ker f.toDistribMulActionHom).Quotient ≃ₗ[S] N where
  __ := AddCon.quotientKerEquivOfSurjective f.toAddMonoidHom hf
  map_smul' s := by rintro ⟨⟩; apply map_smul f

end ker
