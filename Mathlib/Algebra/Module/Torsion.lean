/-
Copyright (c) 2022 Pierre-Alexandre Bazin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Pierre-Alexandre Bazin
-/
import Mathlib.Algebra.DirectSum.Module
import Mathlib.Algebra.Module.BigOperators
import Mathlib.LinearAlgebra.Isomorphisms
import Mathlib.GroupTheory.Torsion
import Mathlib.RingTheory.Coprime.Ideal
import Mathlib.RingTheory.Finiteness

#align_import algebra.module.torsion from "leanprover-community/mathlib"@"cdc34484a07418af43daf8198beaf5c00324bca8"

/-!
# Torsion submodules

## Main definitions

* `torsionOf R M x` : the torsion ideal of `x`, containing all `a` such that `a ‚Ä¢ x = 0`.
* `Submodule.torsionBy R M a` : the `a`-torsion submodule, containing all elements `x` of `M` such
  that `a ‚Ä¢ x = 0`.
* `Submodule.torsionBySet R M s` : the submodule containing all elements `x` of `M` such that
  `a ‚Ä¢ x = 0` for all `a` in `s`.
* `Submodule.torsion' R M S` : the `S`-torsion submodule, containing all elements `x` of `M` such
  that `a ‚Ä¢ x = 0` for some `a` in `S`.
* `Submodule.torsion R M` : the torsion submodule, containing all elements `x` of `M` such that
  `a ‚Ä¢ x = 0` for some non-zero-divisor `a` in `R`.
* `Module.IsTorsionBy R M a` : the property that defines an `a`-torsion module. Similarly,
  `IsTorsionBySet`, `IsTorsion'` and `IsTorsion`.
* `Module.IsTorsionBySet.module` : Creates an `R ‚ß∏ I`-module from an `R`-module that
  `IsTorsionBySet R _ I`.

## Main statements

* `quot_torsionOf_equiv_span_singleton` : isomorphism between the span of an element of `M` and
  the quotient by its torsion ideal.
* `torsion' R M S` and `torsion R M` are submodules.
* `torsionBySet_eq_torsionBySet_span` : torsion by a set is torsion by the ideal generated by it.
* `Submodule.torsionBy_is_torsionBy` : the `a`-torsion submodule is an `a`-torsion module.
  Similar lemmas for `torsion'` and `torsion`.
* `Submodule.torsionBy_isInternal` : a `‚àè i, p i`-torsion module is the internal direct sum of its
  `p i`-torsion submodules when the `p i` are pairwise coprime. A more general version with coprime
  ideals is `Submodule.torsionBySet_is_internal`.
* `Submodule.noZeroSMulDivisors_iff_torsion_bot` : a module over a domain has
  `NoZeroSMulDivisors` (that is, there is no non-zero `a`, `x` such that `a ‚Ä¢ x = 0`)
  iff its torsion submodule is trivial.
* `Submodule.QuotientTorsion.torsion_eq_bot` : quotienting by the torsion submodule makes the
  torsion submodule of the new module trivial. If `R` is a domain, we can derive an instance
  `Submodule.QuotientTorsion.noZeroSMulDivisors : NoZeroSMulDivisors R (M ‚ß∏ torsion R M)`.

## Notation

* The notions are defined for a `CommSemiring R` and a `Module R M`. Some additional hypotheses on
  `R` and `M` are required by some lemmas.
* The letters `a`, `b`, ... are used for scalars (in `R`), while `x`, `y`, ... are used for vectors
  (in `M`).

## Tags

Torsion, submodule, module, quotient
-/

set_option autoImplicit true


namespace Ideal

section TorsionOf

variable (R M : Type*) [Semiring R] [AddCommMonoid M] [Module R M]

/-- The torsion ideal of `x`, containing all `a` such that `a ‚Ä¢ x = 0`.-/
@[simps!]
def torsionOf (x : M) : Ideal R :=
  -- Porting note: broken dot notation on LinearMap.ker Lean4#1910
  LinearMap.ker (LinearMap.toSpanSingleton R M x)
#align ideal.torsion_of Ideal.torsionOf

@[simp]
theorem torsionOf_zero : torsionOf R M (0 : M) = ‚ä§ := by simp [torsionOf]
                                                         -- üéâ no goals
#align ideal.torsion_of_zero Ideal.torsionOf_zero

variable {R M}

@[simp]
theorem mem_torsionOf_iff (x : M) (a : R) : a ‚àà torsionOf R M x ‚Üî a ‚Ä¢ x = 0 :=
  Iff.rfl
#align ideal.mem_torsion_of_iff Ideal.mem_torsionOf_iff

variable (R)

@[simp]
theorem torsionOf_eq_top_iff (m : M) : torsionOf R M m = ‚ä§ ‚Üî m = 0 := by
  refine' ‚ü®fun h => _, fun h => by simp [h]‚ü©
  -- ‚ä¢ m = 0
  rw [‚Üê one_smul R m, ‚Üê mem_torsionOf_iff m (1 : R), h]
  -- ‚ä¢ 1 ‚àà ‚ä§
  exact Submodule.mem_top
  -- üéâ no goals
#align ideal.torsion_of_eq_top_iff Ideal.torsionOf_eq_top_iff

@[simp]
theorem torsionOf_eq_bot_iff_of_noZeroSMulDivisors [Nontrivial R] [NoZeroSMulDivisors R M] (m : M) :
    torsionOf R M m = ‚ä• ‚Üî m ‚â† 0 := by
  refine' ‚ü®fun h contra => _, fun h => (Submodule.eq_bot_iff _).mpr fun r hr => _‚ü©
  -- ‚ä¢ False
  ¬∑ rw [contra, torsionOf_zero] at h
    -- ‚ä¢ False
    exact bot_ne_top.symm h
    -- üéâ no goals
  ¬∑ rw [mem_torsionOf_iff, smul_eq_zero] at hr
    -- ‚ä¢ r = 0
    tauto
    -- üéâ no goals
#align ideal.torsion_of_eq_bot_iff_of_no_zero_smul_divisors Ideal.torsionOf_eq_bot_iff_of_noZeroSMulDivisors

/-- See also `CompleteLattice.Independent.linearIndependent` which provides the same conclusion
but requires the stronger hypothesis `NoZeroSMulDivisors R M`. -/
theorem CompleteLattice.Independent.linear_independent' {Œπ R M : Type*} {v : Œπ ‚Üí M} [Ring R]
    [AddCommGroup M] [Module R M] (hv : CompleteLattice.Independent fun i => R ‚àô v i)
    (h_ne_zero : ‚àÄ i, Ideal.torsionOf R M (v i) = ‚ä•) : LinearIndependent R v := by
  refine' linearIndependent_iff_not_smul_mem_span.mpr fun i r hi => _
  -- ‚ä¢ r = 0
  replace hv := CompleteLattice.independent_def.mp hv i
  -- ‚ä¢ r = 0
  simp only [iSup_subtype', ‚Üê Submodule.span_range_eq_iSup, disjoint_iff] at hv
  -- ‚ä¢ r = 0
  have : r ‚Ä¢ v i ‚àà ‚ä• := by
    rw [‚Üê hv, Submodule.mem_inf]
    refine' ‚ü®Submodule.mem_span_singleton.mpr ‚ü®r, rfl‚ü©, _‚ü©
    convert hi
    ext
    simp
  rw [‚Üê Submodule.mem_bot R, ‚Üê h_ne_zero i]
  -- ‚ä¢ r ‚àà torsionOf R M (v i)
  simpa using this
  -- üéâ no goals
#align ideal.complete_lattice.independent.linear_independent' Ideal.CompleteLattice.Independent.linear_independent'

end TorsionOf

section

variable (R M : Type*) [Ring R] [AddCommGroup M] [Module R M]

/-- The span of `x` in `M` is isomorphic to `R` quotiented by the torsion ideal of `x`.-/
noncomputable def quotTorsionOfEquivSpanSingleton (x : M) : (R ‚ß∏ torsionOf R M x) ‚âÉ‚Çó[R] R ‚àô x :=
  (LinearMap.toSpanSingleton R M x).quotKerEquivRange.trans <|
    LinearEquiv.ofEq _ _ (LinearMap.span_singleton_eq_range R M x).symm
#align ideal.quot_torsion_of_equiv_span_singleton Ideal.quotTorsionOfEquivSpanSingleton

variable {R M}

@[simp]
theorem quotTorsionOfEquivSpanSingleton_apply_mk (x : M) (a : R) :
    quotTorsionOfEquivSpanSingleton R M x (Submodule.Quotient.mk a) =
      a ‚Ä¢ ‚ü®x, Submodule.mem_span_singleton_self x‚ü© :=
  rfl
#align ideal.quot_torsion_of_equiv_span_singleton_apply_mk Ideal.quotTorsionOfEquivSpanSingleton_apply_mk

end

end Ideal

open nonZeroDivisors

section Defs

variable (R M : Type*) [CommSemiring R] [AddCommMonoid M] [Module R M]

namespace Submodule

/-- The `a`-torsion submodule for `a` in `R`, containing all elements `x` of `M` such that
  `a ‚Ä¢ x = 0`. -/
@[simps!]
def torsionBy (a : R) : Submodule R M :=
  -- Porting note: broken dot notation on LinearMap.ker Lean4#1910
  LinearMap.ker (DistribMulAction.toLinearMap R M a)
#align submodule.torsion_by Submodule.torsionBy

/-- The submodule containing all elements `x` of `M` such that `a ‚Ä¢ x = 0` for all `a` in `s`. -/
@[simps!]
def torsionBySet (s : Set R) : Submodule R M :=
  sInf (torsionBy R M '' s)
#align submodule.torsion_by_set Submodule.torsionBySet

-- Porting note: torsion' had metavariables and factoring out this fixed it
-- perhaps there is a better fix
/-- The additive submonoid of all elements `x` of `M` such that `a ‚Ä¢ x = 0`
for some `a` in `S`.-/
@[simps!]
def torsion'AddSubMonoid (S : Type w) [CommMonoid S] [DistribMulAction S M] :
    AddSubmonoid M where
  carrier := { x | ‚àÉ a : S, a ‚Ä¢ x = 0 }
  add_mem' := by
    intro x y ‚ü®a,hx‚ü© ‚ü®b,hy‚ü©
    -- ‚ä¢ x + y ‚àà {x | ‚àÉ a, a ‚Ä¢ x = 0}
    use b * a
    -- ‚ä¢ (b * a) ‚Ä¢ (x + y) = 0
    rw [smul_add, mul_smul, mul_comm, mul_smul, hx, hy, smul_zero, smul_zero, add_zero]
    -- üéâ no goals
  zero_mem' := ‚ü®1, smul_zero 1‚ü©

/-- The `S`-torsion submodule, containing all elements `x` of `M` such that `a ‚Ä¢ x = 0` for some
`a` in `S`. -/
@[simps!]
def torsion' (S : Type w) [CommMonoid S] [DistribMulAction S M] [SMulCommClass S R M] :
    Submodule R M :=
  { torsion'AddSubMonoid M S with
    smul_mem' := fun a x ‚ü®b, h‚ü© => ‚ü®b, by rw [smul_comm, h, smul_zero]‚ü©}
                                          -- üéâ no goals
#align submodule.torsion' Submodule.torsion'

/-- The torsion submodule, containing all elements `x` of `M` such that `a ‚Ä¢ x = 0` for some
  non-zero-divisor `a` in `R`. -/
@[reducible]
def torsion :=
  torsion' R M R‚Å∞
#align submodule.torsion Submodule.torsion

end Submodule

namespace Module

/-- An `a`-torsion module is a module where every element is `a`-torsion. -/
@[reducible]
def IsTorsionBy (a : R) :=
  ‚àÄ ‚¶Éx : M‚¶Ñ, a ‚Ä¢ x = 0
#align module.is_torsion_by Module.IsTorsionBy

/-- A module where every element is `a`-torsion for all `a` in `s`. -/
@[reducible]
def IsTorsionBySet (s : Set R) :=
  ‚àÄ ‚¶Éx : M‚¶Ñ ‚¶Éa : s‚¶Ñ, (a : R) ‚Ä¢ x = 0
#align module.is_torsion_by_set Module.IsTorsionBySet

/-- An `S`-torsion module is a module where every element is `a`-torsion for some `a` in `S`. -/
@[reducible]
def IsTorsion' (S : Type*) [SMul S M] :=
  ‚àÄ ‚¶Éx : M‚¶Ñ, ‚àÉ a : S, a ‚Ä¢ x = 0
#align module.is_torsion' Module.IsTorsion'

/-- A torsion module is a module where every element is `a`-torsion for some non-zero-divisor `a`.
-/
@[reducible]
def IsTorsion :=
  ‚àÄ ‚¶Éx : M‚¶Ñ, ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 0
#align module.is_torsion Module.IsTorsion

end Module

end Defs

variable {R M : Type*}

section

variable [CommSemiring R] [AddCommMonoid M] [Module R M] (s : Set R) (a : R)

namespace Submodule

@[simp]
theorem smul_torsionBy (x : torsionBy R M a) : a ‚Ä¢ x = 0 :=
  Subtype.ext x.prop
#align submodule.smul_torsion_by Submodule.smul_torsionBy

@[simp]
theorem smul_coe_torsionBy (x : torsionBy R M a) : a ‚Ä¢ (x : M) = 0 :=
  x.prop
#align submodule.smul_coe_torsion_by Submodule.smul_coe_torsionBy

@[simp]
theorem mem_torsionBy_iff (x : M) : x ‚àà torsionBy R M a ‚Üî a ‚Ä¢ x = 0 :=
  Iff.rfl
#align submodule.mem_torsion_by_iff Submodule.mem_torsionBy_iff

@[simp]
theorem mem_torsionBySet_iff (x : M) : x ‚àà torsionBySet R M s ‚Üî ‚àÄ a : s, (a : R) ‚Ä¢ x = 0 := by
  refine' ‚ü®fun h ‚ü®a, ha‚ü© => mem_sInf.mp h _ (Set.mem_image_of_mem _ ha), fun h => mem_sInf.mpr _‚ü©
  -- ‚ä¢ ‚àÄ (p : Submodule R M), p ‚àà torsionBy R M '' s ‚Üí x ‚àà p
  rintro _ ‚ü®a, ha, rfl‚ü©; exact h ‚ü®a, ha‚ü©
  -- ‚ä¢ x ‚àà torsionBy R M a
                         -- üéâ no goals
#align submodule.mem_torsion_by_set_iff Submodule.mem_torsionBySet_iff

@[simp]
theorem torsionBySet_singleton_eq : torsionBySet R M {a} = torsionBy R M a := by
  ext x
  -- ‚ä¢ x ‚àà torsionBySet R M {a} ‚Üî x ‚àà torsionBy R M a
  simp only [mem_torsionBySet_iff, SetCoe.forall, Subtype.coe_mk, Set.mem_singleton_iff,
    forall_eq, mem_torsionBy_iff]
#align submodule.torsion_by_singleton_eq Submodule.torsionBySet_singleton_eq

theorem torsionBySet_le_torsionBySet_of_subset {s t : Set R} (st : s ‚äÜ t) :
    torsionBySet R M t ‚â§ torsionBySet R M s :=
  sInf_le_sInf fun _ ‚ü®a, ha, h‚ü© => ‚ü®a, st ha, h‚ü©
#align submodule.torsion_by_set_le_torsion_by_set_of_subset Submodule.torsionBySet_le_torsionBySet_of_subset

/-- Torsion by a set is torsion by the ideal generated by it. -/
theorem torsionBySet_eq_torsionBySet_span :
    torsionBySet R M s = torsionBySet R M (Ideal.span s) := by
  refine le_antisymm (fun x hx => ?_) (torsionBySet_le_torsionBySet_of_subset subset_span)
  -- ‚ä¢ x ‚àà torsionBySet R M ‚Üë(Ideal.span s)
  rw [mem_torsionBySet_iff] at hx ‚ä¢
  -- ‚ä¢ ‚àÄ (a : ‚Üë‚Üë(Ideal.span s)), ‚Üëa ‚Ä¢ x = 0
  suffices Ideal.span s ‚â§ Ideal.torsionOf R M x by
    rintro ‚ü®a, ha‚ü©
    exact this ha
  rw [Ideal.span_le]
  -- ‚ä¢ s ‚äÜ ‚Üë(Ideal.torsionOf R M x)
  exact fun a ha => hx ‚ü®a, ha‚ü©
  -- üéâ no goals
#align submodule.torsion_by_set_eq_torsion_by_span Submodule.torsionBySet_eq_torsionBySet_span

theorem torsionBySet_span_singleton_eq : torsionBySet R M (R ‚àô a) = torsionBy R M a :=
  (torsionBySet_eq_torsionBySet_span _).symm.trans <| torsionBySet_singleton_eq _
#align submodule.torsion_by_span_singleton_eq Submodule.torsionBySet_span_singleton_eq

theorem torsionBy_le_torsionBy_of_dvd (a b : R) (dvd : a ‚à£ b) :
    torsionBy R M a ‚â§ torsionBy R M b := by
  rw [‚Üê torsionBySet_span_singleton_eq, ‚Üê torsionBySet_singleton_eq]
  -- ‚ä¢ torsionBySet R M ‚Üë(span R {a}) ‚â§ torsionBySet R M {b}
  apply torsionBySet_le_torsionBySet_of_subset
  -- ‚ä¢ {b} ‚äÜ ‚Üë(span R {a})
  rintro c (rfl : c = b); exact Ideal.mem_span_singleton.mpr dvd
  -- ‚ä¢ c ‚àà ‚Üë(span R {a})
                          -- üéâ no goals
#align submodule.torsion_by_le_torsion_by_of_dvd Submodule.torsionBy_le_torsionBy_of_dvd

@[simp]
theorem torsionBy_one : torsionBy R M 1 = ‚ä• :=
  eq_bot_iff.mpr fun _ h => by
    rw [mem_torsionBy_iff, one_smul] at h
    -- ‚ä¢ x‚úù ‚àà ‚ä•
    exact h
    -- üéâ no goals
#align submodule.torsion_by_one Submodule.torsionBy_one

@[simp]
theorem torsionBySet_univ : torsionBySet R M Set.univ = ‚ä• := by
  rw [eq_bot_iff, ‚Üê torsionBy_one, ‚Üê torsionBySet_singleton_eq]
  -- ‚ä¢ torsionBySet R M Set.univ ‚â§ torsionBySet R M {1}
  exact torsionBySet_le_torsionBySet_of_subset fun _ _ => trivial
  -- üéâ no goals
#align submodule.torsion_by_univ Submodule.torsionBySet_univ

end Submodule

open Submodule

namespace Module

@[simp]
theorem isTorsionBySet_singleton_iff : IsTorsionBySet R M {a} ‚Üî IsTorsionBy R M a := by
  refine' ‚ü®fun h x => @h _ ‚ü®_, Set.mem_singleton _‚ü©, fun h x => _‚ü©
  -- ‚ä¢ ‚àÄ ‚¶Éa_1 : ‚Üë{a}‚¶Ñ, ‚Üëa_1 ‚Ä¢ x = 0
  rintro ‚ü®b, rfl : b = a‚ü©; exact @h _
  -- ‚ä¢ ‚Üë{ val := b, property := (_ : b = b) } ‚Ä¢ x = 0
                           -- üéâ no goals
#align module.is_torsion_by_singleton_iff Module.isTorsionBySet_singleton_iff

theorem isTorsionBySet_iff_torsionBySet_eq_top :
    IsTorsionBySet R M s ‚Üî Submodule.torsionBySet R M s = ‚ä§ :=
  ‚ü®fun h => eq_top_iff.mpr fun _ _ => (mem_torsionBySet_iff _ _).mpr <| @h _, fun h x => by
    rw [‚Üê mem_torsionBySet_iff, h]
    -- ‚ä¢ x ‚àà ‚ä§
    trivial‚ü©
    -- üéâ no goals
#align module.is_torsion_by_set_iff_torsion_by_set_eq_top Module.isTorsionBySet_iff_torsionBySet_eq_top

/-- An `a`-torsion module is a module whose `a`-torsion submodule is the full space. -/
theorem isTorsionBy_iff_torsionBy_eq_top : IsTorsionBy R M a ‚Üî torsionBy R M a = ‚ä§ := by
  rw [‚Üê torsionBySet_singleton_eq, ‚Üê isTorsionBySet_singleton_iff,
    isTorsionBySet_iff_torsionBySet_eq_top]
#align module.is_torsion_by_iff_torsion_by_eq_top Module.isTorsionBy_iff_torsionBy_eq_top

theorem isTorsionBySet_iff_is_torsion_by_span :
    IsTorsionBySet R M s ‚Üî IsTorsionBySet R M (Ideal.span s) := by
  rw [isTorsionBySet_iff_torsionBySet_eq_top, isTorsionBySet_iff_torsionBySet_eq_top,
    torsionBySet_eq_torsionBySet_span]
#align module.is_torsion_by_set_iff_is_torsion_by_span Module.isTorsionBySet_iff_is_torsion_by_span

theorem isTorsionBySet_span_singleton_iff : IsTorsionBySet R M (R ‚àô a) ‚Üî IsTorsionBy R M a :=
  (isTorsionBySet_iff_is_torsion_by_span _).symm.trans <| isTorsionBySet_singleton_iff _
#align module.is_torsion_by_span_singleton_iff Module.isTorsionBySet_span_singleton_iff

end Module

namespace Submodule

open Module

theorem torsionBySet_isTorsionBySet : IsTorsionBySet R (torsionBySet R M s) s := fun ‚ü®_, hx‚ü© a =>
  Subtype.ext <| (mem_torsionBySet_iff _ _).mp hx a
#align submodule.torsion_by_set_is_torsion_by_set Submodule.torsionBySet_isTorsionBySet

/-- The `a`-torsion submodule is an `a`-torsion module. -/
theorem torsionBy_isTorsionBy : IsTorsionBy R (torsionBy R M a) a := fun _ => smul_torsionBy _ _
#align submodule.torsion_by_is_torsion_by Submodule.torsionBy_isTorsionBy

@[simp]
theorem torsionBy_torsionBy_eq_top : torsionBy R (torsionBy R M a) a = ‚ä§ :=
  (isTorsionBy_iff_torsionBy_eq_top a).mp <| torsionBy_isTorsionBy a
#align submodule.torsion_by_torsion_by_eq_top Submodule.torsionBy_torsionBy_eq_top

@[simp]
theorem torsionBySet_torsionBySet_eq_top : torsionBySet R (torsionBySet R M s) s = ‚ä§ :=
  (isTorsionBySet_iff_torsionBySet_eq_top s).mp <| torsionBySet_isTorsionBySet s
#align submodule.torsion_by_set_torsion_by_set_eq_top Submodule.torsionBySet_torsionBySet_eq_top

variable (R M)

theorem torsion_gc :
    @GaloisConnection (Submodule R M) (Ideal R)·µí·µà _ _ annihilator fun I =>
      torsionBySet R M <| OrderDual.ofDual I :=
  fun _ _ =>
  ‚ü®fun h x hx => (mem_torsionBySet_iff _ _).mpr fun ‚ü®_, ha‚ü© => mem_annihilator.mp (h ha) x hx,
    fun h a ha => mem_annihilator.mpr fun _ hx => (mem_torsionBySet_iff _ _).mp (h hx) ‚ü®a, ha‚ü©‚ü©
#align submodule.torsion_gc Submodule.torsion_gc

variable {R M}

section Coprime

open BigOperators

variable {Œπ : Type*} {p : Œπ ‚Üí Ideal R} {S : Finset Œπ}

variable (hp : (S : Set Œπ).Pairwise fun i j => p i ‚äî p j = ‚ä§)

-- Porting note: mem_iSup_finset_iff_exists_sum now requires DecidableEq Œπ
theorem iSup_torsionBySet_ideal_eq_torsionBySet_iInf [DecidableEq Œπ] :
    ‚®Ü i ‚àà S, torsionBySet R M (p i) = torsionBySet R M ‚Üë(‚®Ö i ‚àà S, p i) := by
  cases' S.eq_empty_or_nonempty with h h
  -- ‚ä¢ ‚®Ü (i : Œπ) (_ : i ‚àà S), torsionBySet R M ‚Üë(p i) = torsionBySet R M ‚Üë(‚®Ö (i : Œπ ‚Ä¶
  ¬∑ simp only [h]
    -- ‚ä¢ ‚®Ü (i : Œπ) (_ : i ‚àà ‚àÖ), torsionBySet R M ‚Üë(p i) = torsionBySet R M ‚Üë(‚®Ö (i : Œπ ‚Ä¶
    -- Porting note: converts were not cooperating
    convert iSup_emptyset (f := fun i => torsionBySet R M (p i)) <;> simp
    -- ‚ä¢ x‚úù ‚àà ‚àÖ ‚Üî x‚úù ‚àà ‚àÖ
                                                                     -- üéâ no goals
                                                                     -- üéâ no goals
  apply le_antisymm
  -- ‚ä¢ ‚®Ü (i : Œπ) (_ : i ‚àà S), torsionBySet R M ‚Üë(p i) ‚â§ torsionBySet R M ‚Üë(‚®Ö (i : Œπ ‚Ä¶
  ¬∑ apply iSup_le _
    -- ‚ä¢ ‚àÄ (i : Œπ), ‚®Ü (_ : i ‚àà S), torsionBySet R M ‚Üë(p i) ‚â§ torsionBySet R M ‚Üë(‚®Ö (i  ‚Ä¶
    intro i
    -- ‚ä¢ ‚®Ü (_ : i ‚àà S), torsionBySet R M ‚Üë(p i) ‚â§ torsionBySet R M ‚Üë(‚®Ö (i : Œπ) (_ : i ‚Ä¶
    apply iSup_le _
    -- ‚ä¢ i ‚àà S ‚Üí torsionBySet R M ‚Üë(p i) ‚â§ torsionBySet R M ‚Üë(‚®Ö (i : Œπ) (_ : i ‚àà S),  ‚Ä¶
    intro is
    -- ‚ä¢ torsionBySet R M ‚Üë(p i) ‚â§ torsionBySet R M ‚Üë(‚®Ö (i : Œπ) (_ : i ‚àà S), p i)
    apply torsionBySet_le_torsionBySet_of_subset
    -- ‚ä¢ ‚Üë(‚®Ö (i : Œπ) (_ : i ‚àà S), p i) ‚äÜ ‚Üë(p i)
    exact (iInf_le (fun i => ‚®Ö _ : i ‚àà S, p i) i).trans (iInf_le _ is)
    -- üéâ no goals
  ¬∑ intro x hx
    -- ‚ä¢ x ‚àà ‚®Ü (i : Œπ) (_ : i ‚àà S), torsionBySet R M ‚Üë(p i)
    rw [mem_iSup_finset_iff_exists_sum]
    -- ‚ä¢ ‚àÉ Œº, ‚àë i in S, ‚Üë(Œº i) = x
    obtain ‚ü®Œº, hŒº‚ü© :=
      (mem_iSup_finset_iff_exists_sum _ _).mp
        ((Ideal.eq_top_iff_one _).mp <| (Ideal.iSup_iInf_eq_top_iff_pairwise h _).mpr hp)
    refine' ‚ü®fun i => ‚ü®(Œº i : R) ‚Ä¢ x, _‚ü©, _‚ü©
    -- ‚ä¢ ‚Üë(Œº i) ‚Ä¢ x ‚àà torsionBySet R M ‚Üë(p i)
    ¬∑ rw [mem_torsionBySet_iff] at hx ‚ä¢
      -- ‚ä¢ ‚àÄ (a : ‚Üë‚Üë(p i)), ‚Üëa ‚Ä¢ ‚Üë(Œº i) ‚Ä¢ x = 0
      rintro ‚ü®a, ha‚ü©
      -- ‚ä¢ ‚Üë{ val := a, property := ha } ‚Ä¢ ‚Üë(Œº i) ‚Ä¢ x = 0
      rw [smul_smul]
      -- ‚ä¢ (‚Üë{ val := a, property := ha } * ‚Üë(Œº i)) ‚Ä¢ x = 0
      suffices : a * Œº i ‚àà ‚®Ö i ‚àà S, p i
      -- ‚ä¢ (‚Üë{ val := a, property := ha } * ‚Üë(Œº i)) ‚Ä¢ x = 0
      exact hx ‚ü®_, this‚ü©
      -- ‚ä¢ a * ‚Üë(Œº i) ‚àà ‚®Ö (i : Œπ) (_ : i ‚àà S), p i
      rw [mem_iInf]
      -- ‚ä¢ ‚àÄ (i_1 : Œπ), a * ‚Üë(Œº i) ‚àà ‚®Ö (_ : i_1 ‚àà S), p i_1
      intro j
      -- ‚ä¢ a * ‚Üë(Œº i) ‚àà ‚®Ö (_ : j ‚àà S), p j
      rw [mem_iInf]
      -- ‚ä¢ j ‚àà S ‚Üí a * ‚Üë(Œº i) ‚àà p j
      intro hj
      -- ‚ä¢ a * ‚Üë(Œº i) ‚àà p j
      by_cases ij : j = i
      -- ‚ä¢ a * ‚Üë(Œº i) ‚àà p j
      ¬∑ rw [ij]
        -- ‚ä¢ a * ‚Üë(Œº i) ‚àà p i
        exact Ideal.mul_mem_right _ _ ha
        -- üéâ no goals
      ¬∑ have := coe_mem (Œº i)
        -- ‚ä¢ a * ‚Üë(Œº i) ‚àà p j
        simp only [mem_iInf] at this
        -- ‚ä¢ a * ‚Üë(Œº i) ‚àà p j
        exact Ideal.mul_mem_left _ _ (this j hj ij)
        -- üéâ no goals
    ¬∑ rw [‚Üê Finset.sum_smul, hŒº, one_smul]
      -- üéâ no goals
#align submodule.supr_torsion_by_ideal_eq_torsion_by_infi Submodule.iSup_torsionBySet_ideal_eq_torsionBySet_iInf

-- Porting note: iSup_torsionBySet_ideal_eq_torsionBySet_iInf now requires DecidableEq Œπ
theorem supIndep_torsionBySet_ideal [DecidableEq Œπ] : S.SupIndep fun i => torsionBySet R M <| p i :=
  fun T hT i hi hiT => by
  rw [disjoint_iff, Finset.sup_eq_iSup,
    iSup_torsionBySet_ideal_eq_torsionBySet_iInf fun i hi j hj ij => hp (hT hi) (hT hj) ij]
  have := GaloisConnection.u_inf
    (b‚ÇÅ := OrderDual.toDual (p i)) (b‚ÇÇ := OrderDual.toDual (‚®Ö i ‚àà T, p i)) (torsion_gc R M)
  dsimp at this ‚ä¢
  -- ‚ä¢ torsionBySet R M ‚Üë(p i) ‚äì torsionBySet R M ‚Üë(‚®Ö (i : Œπ) (_ : i ‚àà T), p i) = ‚ä•
  rw [‚Üê this, Ideal.sup_iInf_eq_top, top_coe, torsionBySet_univ]
  -- ‚ä¢ ‚àÄ (i_1 : Œπ), i_1 ‚àà T ‚Üí p i ‚äî p i_1 = ‚ä§
  intro j hj; apply hp hi (hT hj); rintro rfl; exact hiT hj
  -- ‚ä¢ p i ‚äî p j = ‚ä§
              -- ‚ä¢ i ‚â† j
                                   -- ‚ä¢ False
                                               -- üéâ no goals
#align submodule.sup_indep_torsion_by_ideal Submodule.supIndep_torsionBySet_ideal

variable {q : Œπ ‚Üí R} (hq : (S : Set Œπ).Pairwise <| (IsCoprime on q))

theorem iSup_torsionBy_eq_torsionBy_prod [DecidableEq Œπ] :
    ‚®Ü i ‚àà S, torsionBy R M (q i) = torsionBy R M (‚àè i in S, q i) := by
  rw [‚Üê torsionBySet_span_singleton_eq, Ideal.submodule_span_eq, ‚Üê
    Ideal.finset_inf_span_singleton _ _ hq, Finset.inf_eq_iInf, ‚Üê
    iSup_torsionBySet_ideal_eq_torsionBySet_iInf]
  congr
  -- ‚ä¢ (fun i => ‚®Ü (_ : i ‚àà S), torsionBy R M (q i)) = fun i => ‚®Ü (_ : i ‚àà S), tors ‚Ä¶
  ext : 1
  -- ‚ä¢ ‚®Ü (_ : x‚úù ‚àà S), torsionBy R M (q x‚úù) = ‚®Ü (_ : x‚úù ‚àà S), torsionBySet R M ‚Üë(Id ‚Ä¶
  congr
  -- ‚ä¢ (fun h => torsionBy R M (q x‚úù)) = fun h => torsionBySet R M ‚Üë(Ideal.span {q  ‚Ä¶
  ext : 1
  -- ‚ä¢ torsionBy R M (q x‚úù¬π) = torsionBySet R M ‚Üë(Ideal.span {q x‚úù¬π})
  exact (torsionBySet_span_singleton_eq _).symm
  -- ‚ä¢ Set.Pairwise ‚ÜëS fun i j => Ideal.span {q i} ‚äî Ideal.span {q j} = ‚ä§
  exact fun i hi j hj ij => (Ideal.sup_eq_top_iff_isCoprime _ _).mpr (hq hi hj ij)
  -- üéâ no goals
#align submodule.supr_torsion_by_eq_torsion_by_prod Submodule.iSup_torsionBy_eq_torsionBy_prod

-- Porting note: supIndep_torsionBySet_ideal now requires DecidableEq Œπ
theorem supIndep_torsionBy [DecidableEq Œπ] : S.SupIndep fun i => torsionBy R M <| q i := by
  convert supIndep_torsionBySet_ideal (M := M) fun i hi j hj ij =>
      (Ideal.sup_eq_top_iff_isCoprime (q i) _).mpr <| hq hi hj ij
  exact (torsionBySet_span_singleton_eq (R := R) (M := M) _).symm
  -- üéâ no goals
#align submodule.sup_indep_torsion_by Submodule.supIndep_torsionBy

end Coprime

end Submodule

end

section NeedsGroup

variable [CommRing R] [AddCommGroup M] [Module R M]

namespace Submodule

open BigOperators

variable {Œπ : Type*} [DecidableEq Œπ] {S : Finset Œπ}

/-- If the `p i` are pairwise coprime, a `‚®Ö i, p i`-torsion module is the internal direct sum of
its `p i`-torsion submodules.-/
theorem torsionBySet_isInternal {p : Œπ ‚Üí Ideal R}
    (hp : (S : Set Œπ).Pairwise fun i j => p i ‚äî p j = ‚ä§)
    (hM : Module.IsTorsionBySet R M (‚®Ö i ‚àà S, p i : Ideal R)) :
    DirectSum.IsInternal fun i : S => torsionBySet R M <| p i :=
  DirectSum.isInternal_submodule_of_independent_of_iSup_eq_top
    (CompleteLattice.independent_iff_supIndep.mpr <| supIndep_torsionBySet_ideal hp)
    (by
      apply (iSup_subtype'' ‚ÜëS fun i => torsionBySet R M <| p i).trans
      -- ‚ä¢ ‚®Ü (t : Œπ) (_ : t ‚àà ‚ÜëS), torsionBySet R M ‚Üë(p t) = ‚ä§
      -- Porting note: times out if we change apply below to <|
      apply (iSup_torsionBySet_ideal_eq_torsionBySet_iInf hp).trans <|
        (Module.isTorsionBySet_iff_torsionBySet_eq_top _).mp hM)
#align submodule.torsion_by_set_is_internal Submodule.torsionBySet_isInternal

/-- If the `q i` are pairwise coprime, a `‚àè i, q i`-torsion module is the internal direct sum of
its `q i`-torsion submodules.-/
theorem torsionBy_isInternal {q : Œπ ‚Üí R} (hq : (S : Set Œπ).Pairwise <| (IsCoprime on q))
    (hM : Module.IsTorsionBy R M <| ‚àè i in S, q i) :
    DirectSum.IsInternal fun i : S => torsionBy R M <| q i := by
  rw [‚Üê Module.isTorsionBySet_span_singleton_iff, Ideal.submodule_span_eq, ‚Üê
    Ideal.finset_inf_span_singleton _ _ hq, Finset.inf_eq_iInf] at hM
  convert torsionBySet_isInternal
      (fun i hi j hj ij => (Ideal.sup_eq_top_iff_isCoprime (q i) _).mpr <| hq hi hj ij) hM
  exact (torsionBySet_span_singleton_eq _ (R := R) (M := M)).symm
  -- üéâ no goals
#align submodule.torsion_by_is_internal Submodule.torsionBy_isInternal

end Submodule

namespace Module

variable {I : Ideal R} (hM : IsTorsionBySet R M I)

/-- can't be an instance because hM can't be inferred -/
def IsTorsionBySet.hasSMul : SMul (R ‚ß∏ I) M where
  smul b x :=
    Quotient.liftOn' b (¬∑ ‚Ä¢ x) fun b‚ÇÅ b‚ÇÇ h =>
      show b‚ÇÅ ‚Ä¢ x = b‚ÇÇ ‚Ä¢ x from by
        have : (-b‚ÇÅ + b‚ÇÇ) ‚Ä¢ x = 0 := @hM x ‚ü®_, QuotientAddGroup.leftRel_apply.mp h‚ü©
        -- ‚ä¢ b‚ÇÅ ‚Ä¢ x = b‚ÇÇ ‚Ä¢ x
        rw [add_smul, neg_smul, neg_add_eq_zero] at this
        -- ‚ä¢ b‚ÇÅ ‚Ä¢ x = b‚ÇÇ ‚Ä¢ x
        exact this
        -- üéâ no goals
#align module.is_torsion_by_set.has_smul Module.IsTorsionBySet.hasSMul

@[simp]
theorem IsTorsionBySet.mk_smul (b : R) (x : M) :
    haveI := hM.hasSMul
    Ideal.Quotient.mk I b ‚Ä¢ x = b ‚Ä¢ x :=
  rfl
#align module.is_torsion_by_set.mk_smul Module.IsTorsionBySet.mk_smul

/-- An `(R ‚ß∏ I)`-module is an `R`-module which `IsTorsionBySet R M I`. -/
def IsTorsionBySet.module : Module (R ‚ß∏ I) M :=
  @Function.Surjective.moduleLeft _ _ _ _ _ _ _ hM.hasSMul _ Ideal.Quotient.mk_surjective
    (IsTorsionBySet.mk_smul hM)
#align module.is_torsion_by_set.module Module.IsTorsionBySet.module

instance IsTorsionBySet.isScalarTower
    {S : Type*} [SMul S R] [SMul S M] [IsScalarTower S R M] [IsScalarTower S R R] :
    @IsScalarTower S (R ‚ß∏ I) M _ (IsTorsionBySet.module hM).toSMul _ :=
  -- Porting note: still needed to be fed the Module R / I M instance
  @IsScalarTower.mk S (R ‚ß∏ I) M _ (IsTorsionBySet.module hM).toSMul _
    (fun b d x => Quotient.inductionOn' d fun c => (smul_assoc b c x : _))
#align module.is_torsion_by_set.is_scalar_tower Module.IsTorsionBySet.isScalarTower

instance : Module (R ‚ß∏ I) (M ‚ß∏ I ‚Ä¢ (‚ä§ : Submodule R M)) :=
  IsTorsionBySet.module (R := R) (I := I) fun x r => by
    induction x using Quotient.inductionOn
    -- ‚ä¢ ‚Üër ‚Ä¢ Quotient.mk (Submodule.quotientRel (I ‚Ä¢ ‚ä§)) a‚úù = 0
    refine' (Submodule.Quotient.mk_eq_zero _).mpr (Submodule.smul_mem_smul r.prop _)
    -- ‚ä¢ a‚úù ‚àà ‚ä§
    trivial
    -- üéâ no goals

end Module

namespace Submodule

instance (I : Ideal R) : Module (R ‚ß∏ I) (torsionBySet R M I) :=
  -- Porting note: times out without the (R := R)
  Module.IsTorsionBySet.module <| torsionBySet_isTorsionBySet (R := R) I

@[simp]
theorem torsionBySet.mk_smul (I : Ideal R) (b : R) (x : torsionBySet R M I) :
    Ideal.Quotient.mk I b ‚Ä¢ x = b ‚Ä¢ x :=
  rfl
#align submodule.torsion_by_set.mk_smul Submodule.torsionBySet.mk_smul

instance (I : Ideal R) {S : Type*} [SMul S R] [SMul S M] [IsScalarTower S R M]
    [IsScalarTower S R R] : IsScalarTower S (R ‚ß∏ I) (torsionBySet R M I) :=
  inferInstance

/-- The `a`-torsion submodule as an `(R ‚ß∏ R‚àôa)`-module. -/
instance (a : R) : Module (R ‚ß∏ R ‚àô a) (torsionBy R M a) :=
  Module.IsTorsionBySet.module <|
    (Module.isTorsionBySet_span_singleton_iff a).mpr <| torsionBy_isTorsionBy a

-- Porting note: added for torsionBy.mk_ideal_smul
instance (a : R) : Module (R ‚ß∏ Ideal.span {a}) (torsionBy R M a) :=
   inferInstanceAs <| Module (R ‚ß∏ R ‚àô a) (torsionBy R M a)

-- Porting note: added because torsionBy.mk_smul simplifies
@[simp]
theorem torsionBy.mk_ideal_smul (a b : R) (x : torsionBy R M a) :
    (Ideal.Quotient.mk (Ideal.span {a})) b ‚Ä¢ x = b ‚Ä¢ x :=
  rfl

theorem torsionBy.mk_smul (a b : R) (x : torsionBy R M a) :
    Ideal.Quotient.mk (R ‚àô a) b ‚Ä¢ x = b ‚Ä¢ x :=
  rfl
#align submodule.torsion_by.mk_smul Submodule.torsionBy.mk_smul

instance (a : R) {S : Type*} [SMul S R] [SMul S M] [IsScalarTower S R M] [IsScalarTower S R R] :
    IsScalarTower S (R ‚ß∏ R ‚àô a) (torsionBy R M a) :=
  inferInstance

end Submodule

end NeedsGroup

namespace Submodule

section Torsion'

open Module

variable [CommSemiring R] [AddCommMonoid M] [Module R M]

variable (S : Type*) [CommMonoid S] [DistribMulAction S M] [SMulCommClass S R M]

@[simp]
theorem mem_torsion'_iff (x : M) : x ‚àà torsion' R M S ‚Üî ‚àÉ a : S, a ‚Ä¢ x = 0 :=
  Iff.rfl
#align submodule.mem_torsion'_iff Submodule.mem_torsion'_iff

-- @[simp] Porting note : simp can prove this
theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 0 :=
  Iff.rfl
#align submodule.mem_torsion_iff Submodule.mem_torsion_iff

@[simps]
instance : SMul S (torsion' R M S) :=
  ‚ü®fun s x =>
    ‚ü®s ‚Ä¢ (x : M), by
      obtain ‚ü®x, a, h‚ü© := x
      -- ‚ä¢ s ‚Ä¢ ‚Üë{ val := x, property := (_ : ‚àÉ a, a ‚Ä¢ x = 0) } ‚àà torsion' R M S
      use a
      -- ‚ä¢ a ‚Ä¢ s ‚Ä¢ ‚Üë{ val := x, property := (_ : ‚àÉ a, a ‚Ä¢ x = 0) } = 0
      dsimp
      -- ‚ä¢ a ‚Ä¢ s ‚Ä¢ x = 0
      rw [smul_comm, h, smul_zero]‚ü©‚ü©
      -- üéâ no goals

instance : DistribMulAction S (torsion' R M S) :=
  Subtype.coe_injective.distribMulAction (torsion' R M S).subtype.toAddMonoidHom fun (_ : S) _ =>
    rfl

instance : SMulCommClass S R (torsion' R M S) :=
  ‚ü®fun _ _ _ => Subtype.ext <| smul_comm _ _ _‚ü©

/-- An `S`-torsion module is a module whose `S`-torsion submodule is the full space. -/
theorem isTorsion'_iff_torsion'_eq_top : IsTorsion' M S ‚Üî torsion' R M S = ‚ä§ :=
  ‚ü®fun h => eq_top_iff.mpr fun _ _ => @h _, fun h x => by
    rw [‚Üê @mem_torsion'_iff R, h]
    -- ‚ä¢ x ‚àà ‚ä§
    trivial‚ü©
    -- üéâ no goals
#align submodule.is_torsion'_iff_torsion'_eq_top Submodule.isTorsion'_iff_torsion'_eq_top

/-- The `S`-torsion submodule is an `S`-torsion module. -/
theorem torsion'_isTorsion' : IsTorsion' (torsion' R M S) S := fun ‚ü®_, ‚ü®a, h‚ü©‚ü© => ‚ü®a, Subtype.ext h‚ü©
#align submodule.torsion'_is_torsion' Submodule.torsion'_isTorsion'

@[simp]
theorem torsion'_torsion'_eq_top : torsion' R (torsion' R M S) S = ‚ä§ :=
  (isTorsion'_iff_torsion'_eq_top S).mp <| torsion'_isTorsion' S
#align submodule.torsion'_torsion'_eq_top Submodule.torsion'_torsion'_eq_top

/-- The torsion submodule of the torsion submodule (viewed as a module) is the full
torsion module. -/
-- @[simp] Porting note: simp can prove this
theorem torsion_torsion_eq_top : torsion R (torsion R M) = ‚ä§ :=
  torsion'_torsion'_eq_top R‚Å∞
#align submodule.torsion_torsion_eq_top Submodule.torsion_torsion_eq_top

/-- The torsion submodule is always a torsion module. -/
theorem torsion_isTorsion : Module.IsTorsion R (torsion R M) :=
  torsion'_isTorsion' R‚Å∞
#align submodule.torsion_is_torsion Submodule.torsion_isTorsion

end Torsion'

section Torsion

variable [CommSemiring R] [AddCommMonoid M] [Module R M]

open BigOperators

variable (R M)

theorem _root_.Module.isTorsionBySet_annihilator_top :
    Module.IsTorsionBySet R M (‚ä§ : Submodule R M).annihilator := fun x ha =>
  mem_annihilator.mp ha.prop x mem_top
#align module.is_torsion_by_set_annihilator_top Module.isTorsionBySet_annihilator_top

variable {R M}

theorem _root_.Submodule.annihilator_top_inter_nonZeroDivisors [Module.Finite R M]
    (hM : Module.IsTorsion R M) : ((‚ä§ : Submodule R M).annihilator : Set R) ‚à© R‚Å∞ ‚â† ‚àÖ := by
  obtain ‚ü®S, hS‚ü© := ‚ÄπModule.Finite R M‚Ä∫.out
  -- ‚ä¢ ‚Üë(annihilator ‚ä§) ‚à© ‚ÜëR‚Å∞ ‚â† ‚àÖ
  refine' Set.Nonempty.ne_empty ‚ü®_, _, (‚àè x in S, (@hM x).choose : R‚Å∞).prop‚ü©
  -- ‚ä¢ ‚Üë(‚àè x in S, Exists.choose (_ : ‚àÉ a, a ‚Ä¢ x = 0)) ‚àà ‚Üë(annihilator ‚ä§)
  rw [Submonoid.coe_finset_prod, SetLike.mem_coe, ‚Üê hS, mem_annihilator_span]
  -- ‚ä¢ ‚àÄ (n : ‚Üë‚ÜëS), (‚àè i in S, ‚Üë(Exists.choose (_ : ‚àÉ a, a ‚Ä¢ i = 0))) ‚Ä¢ ‚Üën = 0
  intro n
  -- ‚ä¢ (‚àè i in S, ‚Üë(Exists.choose (_ : ‚àÉ a, a ‚Ä¢ i = 0))) ‚Ä¢ ‚Üën = 0
  letI := Classical.decEq M
  -- ‚ä¢ (‚àè i in S, ‚Üë(Exists.choose (_ : ‚àÉ a, a ‚Ä¢ i = 0))) ‚Ä¢ ‚Üën = 0
  rw [‚Üê Finset.prod_erase_mul _ _ n.prop, mul_smul, ‚Üê Submonoid.smul_def, (@hM n).choose_spec,
    smul_zero]
#align submodule.annihilator_top_inter_non_zero_divisors Submodule.annihilator_top_inter_nonZeroDivisors

variable [NoZeroDivisors R] [Nontrivial R]

theorem coe_torsion_eq_annihilator_ne_bot :
    (torsion R M : Set M) = { x : M | (R ‚àô x).annihilator ‚â† ‚ä• } := by
  ext x; simp_rw [Submodule.ne_bot_iff, mem_annihilator, mem_span_singleton]
  -- ‚ä¢ x ‚àà ‚Üë(torsion R M) ‚Üî x ‚àà {x | annihilator (span R {x}) ‚â† ‚ä•}
         -- ‚ä¢ x ‚àà ‚Üë(torsion R M) ‚Üî x ‚àà {x | ‚àÉ x_1, (‚àÄ (n : M), (‚àÉ a, a ‚Ä¢ x = n) ‚Üí x_1 ‚Ä¢ n  ‚Ä¶
  exact
    ‚ü®fun ‚ü®a, hax‚ü© =>
      ‚ü®a, fun _ ‚ü®b, hb‚ü© => by rw [‚Üê hb, smul_comm, ‚Üê Submonoid.smul_def, hax, smul_zero],
        nonZeroDivisors.coe_ne_zero _‚ü©,
      fun ‚ü®a, hax, ha‚ü© => ‚ü®‚ü®_, mem_nonZeroDivisors_of_ne_zero ha‚ü©, hax x ‚ü®1, one_smul _ _‚ü©‚ü©‚ü©
#align submodule.coe_torsion_eq_annihilator_ne_bot Submodule.coe_torsion_eq_annihilator_ne_bot

/-- A module over a domain has `NoZeroSMulDivisors` iff its torsion submodule is trivial. -/
theorem noZeroSMulDivisors_iff_torsion_eq_bot : NoZeroSMulDivisors R M ‚Üî torsion R M = ‚ä• := by
  constructor <;> intro h
  -- ‚ä¢ NoZeroSMulDivisors R M ‚Üí torsion R M = ‚ä•
                  -- ‚ä¢ torsion R M = ‚ä•
                  -- ‚ä¢ NoZeroSMulDivisors R M
  ¬∑ haveI : NoZeroSMulDivisors R M := h
    -- ‚ä¢ torsion R M = ‚ä•
    rw [eq_bot_iff]
    -- ‚ä¢ torsion R M ‚â§ ‚ä•
    rintro x ‚ü®a, hax‚ü©
    -- ‚ä¢ x ‚àà ‚ä•
    change (a : R) ‚Ä¢ x = 0 at hax
    -- ‚ä¢ x ‚àà ‚ä•
    cases' eq_zero_or_eq_zero_of_smul_eq_zero hax with h0 h0
    -- ‚ä¢ x ‚àà ‚ä•
    ¬∑ exfalso
      -- ‚ä¢ False
      exact nonZeroDivisors.coe_ne_zero a h0
      -- üéâ no goals
    ¬∑ exact h0
      -- üéâ no goals
  ¬∑ exact
      { eq_zero_or_eq_zero_of_smul_eq_zero := fun {a} {x} hax => by
          by_cases ha : a = 0
          ¬∑ left
            exact ha
          ¬∑ right
            rw [‚Üê mem_bot R, ‚Üê h]
            exact ‚ü®‚ü®a, mem_nonZeroDivisors_of_ne_zero ha‚ü©, hax‚ü© }
#align submodule.no_zero_smul_divisors_iff_torsion_eq_bot Submodule.noZeroSMulDivisors_iff_torsion_eq_bot

end Torsion

namespace QuotientTorsion

variable [CommRing R] [AddCommGroup M] [Module R M]

/-- Quotienting by the torsion submodule gives a torsion-free module. -/
@[simp]
theorem torsion_eq_bot : torsion R (M ‚ß∏ torsion R M) = ‚ä• :=
  eq_bot_iff.mpr fun z =>
    Quotient.inductionOn' z fun x ‚ü®a, hax‚ü© => by
      rw [Quotient.mk''_eq_mk, ‚Üê Quotient.mk_smul, Quotient.mk_eq_zero] at hax
      -- ‚ä¢ Quotient.mk'' x ‚àà ‚ä•
      rw [mem_bot, Quotient.mk''_eq_mk, Quotient.mk_eq_zero]
      -- ‚ä¢ x ‚àà torsion R M
      cases' hax with b h
      -- ‚ä¢ x ‚àà torsion R M
      exact ‚ü®b * a, (mul_smul _ _ _).trans h‚ü©
      -- üéâ no goals
#align submodule.quotient_torsion.torsion_eq_bot Submodule.QuotientTorsion.torsion_eq_bot

instance noZeroSMulDivisors [IsDomain R] : NoZeroSMulDivisors R (M ‚ß∏ torsion R M) :=
  noZeroSMulDivisors_iff_torsion_eq_bot.mpr torsion_eq_bot
#align submodule.quotient_torsion.no_zero_smul_divisors Submodule.QuotientTorsion.noZeroSMulDivisors

end QuotientTorsion

section PTorsion

open Module

section

variable [Monoid R] [AddCommMonoid M] [DistribMulAction R M]

theorem isTorsion'_powers_iff (p : R) :
    IsTorsion' M (Submonoid.powers p) ‚Üî ‚àÄ x : M, ‚àÉ n : ‚Ñï, p ^ n ‚Ä¢ x = 0 := by
  -- Porting note: previous term proof was having trouble elaborating
  constructor
  -- ‚ä¢ IsTorsion' M { x // x ‚àà Submonoid.powers p } ‚Üí ‚àÄ (x : M), ‚àÉ n, p ^ n ‚Ä¢ x = 0
  ¬∑ intro h x
    -- ‚ä¢ ‚àÉ n, p ^ n ‚Ä¢ x = 0
    let ‚ü®‚ü®a, ‚ü®n, hn‚ü©‚ü©, hx‚ü© := @h x
    -- ‚ä¢ ‚àÉ n, p ^ n ‚Ä¢ x = 0
    dsimp at hn
    -- ‚ä¢ ‚àÉ n, p ^ n ‚Ä¢ x = 0
    use n
    -- ‚ä¢ p ^ n ‚Ä¢ x = 0
    rw [hn]
    -- ‚ä¢ a ‚Ä¢ x = 0
    apply hx
    -- üéâ no goals
  ¬∑ intro h x
    -- ‚ä¢ ‚àÉ a, a ‚Ä¢ x = 0
    let ‚ü®n, hn‚ü© := h x
    -- ‚ä¢ ‚àÉ a, a ‚Ä¢ x = 0
    exact ‚ü®‚ü®_, ‚ü®n, rfl‚ü©‚ü©, hn‚ü©
    -- üéâ no goals
#align submodule.is_torsion'_powers_iff Submodule.isTorsion'_powers_iff

/-- In a `p ^ ‚àû`-torsion module (that is, a module where all elements are cancelled by scalar
multiplication by some power of `p`), the smallest `n` such that `p ^ n ‚Ä¢ x = 0`.-/
def pOrder {p : R} (hM : IsTorsion' M <| Submonoid.powers p) (x : M)
    [‚àÄ n : ‚Ñï, Decidable (p ^ n ‚Ä¢ x = 0)] :=
  Nat.find <| (isTorsion'_powers_iff p).mp hM x
#align submodule.p_order Submodule.pOrder

@[simp]
theorem pow_pOrder_smul {p : R} (hM : IsTorsion' M <| Submonoid.powers p) (x : M)
    [‚àÄ n : ‚Ñï, Decidable (p ^ n ‚Ä¢ x = 0)] : p ^ pOrder hM x ‚Ä¢ x = 0 :=
  Nat.find_spec <| (isTorsion'_powers_iff p).mp hM x
#align submodule.pow_p_order_smul Submodule.pow_pOrder_smul

end

variable [CommSemiring R] [AddCommMonoid M] [Module R M] [‚àÄ x : M, Decidable (x = 0)]

theorem exists_isTorsionBy {p : R} (hM : IsTorsion' M <| Submonoid.powers p) (d : ‚Ñï) (hd : d ‚â† 0)
    (s : Fin d ‚Üí M) (hs : span R (Set.range s) = ‚ä§) :
    ‚àÉ j : Fin d, Module.IsTorsionBy R M (p ^ pOrder hM (s j)) := by
  let oj := List.argmax (fun i => pOrder hM <| s i) (List.finRange d)
  -- ‚ä¢ ‚àÉ j, IsTorsionBy R M (p ^ pOrder hM (s j))
  have hoj : oj.isSome :=
    Option.ne_none_iff_isSome.mp fun eq_none =>
      hd <| List.finRange_eq_nil.mp <| List.argmax_eq_none.mp eq_none
  use Option.get _ hoj
  -- ‚ä¢ IsTorsionBy R M (p ^ pOrder hM (s (Option.get oj hoj)))
  rw [isTorsionBy_iff_torsionBy_eq_top, eq_top_iff, ‚Üê hs, Submodule.span_le,
    Set.range_subset_iff]
  intro i; change (p ^ pOrder hM (s (Option.get oj hoj))) ‚Ä¢ s i = 0
  -- ‚ä¢ s i ‚àà ‚Üë(torsionBy R M (p ^ pOrder hM (s (Option.get oj hoj))))
           -- ‚ä¢ p ^ pOrder hM (s (Option.get oj hoj)) ‚Ä¢ s i = 0
  have : pOrder hM (s i) ‚â§ pOrder hM (s <| Option.get _ hoj) :=
    List.le_of_mem_argmax (List.mem_finRange i) (Option.get_mem hoj)
  rw [‚Üê Nat.sub_add_cancel this, pow_add, mul_smul, pow_pOrder_smul, smul_zero]
  -- üéâ no goals
#align submodule.exists_is_torsion_by Submodule.exists_isTorsionBy

end PTorsion

end Submodule

namespace Ideal.Quotient

open Submodule

theorem torsionBy_eq_span_singleton {R : Type w} [CommRing R] (a b : R) (ha : a ‚àà R‚Å∞) :
    torsionBy R (R ‚ß∏ R ‚àô a * b) a = R ‚àô mk (R ‚àô a * b) b := by
  ext x; rw [mem_torsionBy_iff, Submodule.mem_span_singleton]
  -- ‚ä¢ x ‚àà torsionBy R (R ‚ß∏ Submodule.span R {a * b}) a ‚Üî x ‚àà Submodule.span R {‚Üë(m ‚Ä¶
         -- ‚ä¢ a ‚Ä¢ x = 0 ‚Üî ‚àÉ a_1, a_1 ‚Ä¢ ‚Üë(mk (Submodule.span R {a * b})) b = x
  obtain ‚ü®x, rfl‚ü© := mk_surjective x; constructor <;> intro h
  -- ‚ä¢ a ‚Ä¢ ‚Üë(mk (Submodule.span R {a * b})) x = 0 ‚Üî ‚àÉ a_1, a_1 ‚Ä¢ ‚Üë(mk (Submodule.sp ‚Ä¶
                                      -- ‚ä¢ a ‚Ä¢ ‚Üë(mk (Submodule.span R {a * b})) x = 0 ‚Üí ‚àÉ a_2, a_2 ‚Ä¢ ‚Üë(mk (Submodule.sp ‚Ä¶
                                                      -- ‚ä¢ ‚àÉ a_1, a_1 ‚Ä¢ ‚Üë(mk (Submodule.span R {a * b})) b = ‚Üë(mk (Submodule.span R {a  ‚Ä¶
                                                      -- ‚ä¢ a ‚Ä¢ ‚Üë(mk (Submodule.span R {a * b})) x = 0
  ¬∑ rw [‚Üê mk_eq_mk, ‚Üê Quotient.mk_smul, Quotient.mk_eq_zero, Submodule.mem_span_singleton] at h
    -- ‚ä¢ ‚àÉ a_1, a_1 ‚Ä¢ ‚Üë(mk (Submodule.span R {a * b})) b = ‚Üë(mk (Submodule.span R {a  ‚Ä¶
    obtain ‚ü®c, h‚ü© := h
    -- ‚ä¢ ‚àÉ a_1, a_1 ‚Ä¢ ‚Üë(mk (Submodule.span R {a * b})) b = ‚Üë(mk (Submodule.span R {a  ‚Ä¶
    rw [smul_eq_mul, smul_eq_mul, mul_comm, mul_assoc, mul_cancel_left_mem_nonZeroDivisors ha,
      mul_comm] at h
    use c
    -- ‚ä¢ c ‚Ä¢ ‚Üë(mk (Submodule.span R {a * b})) b = ‚Üë(mk (Submodule.span R {a * b})) x
    rw [‚Üê h, ‚Üê mk_eq_mk, ‚Üê Quotient.mk_smul, smul_eq_mul, mk_eq_mk]
    -- üéâ no goals
  ¬∑ obtain ‚ü®c, h‚ü© := h
    -- ‚ä¢ a ‚Ä¢ ‚Üë(mk (Submodule.span R {a * b})) x = 0
    rw [‚Üê h, smul_comm, ‚Üê mk_eq_mk, ‚Üê Quotient.mk_smul,
      (Quotient.mk_eq_zero _).mpr <| mem_span_singleton_self _, smul_zero]
#align ideal.quotient.torsion_by_eq_span_singleton Ideal.Quotient.torsionBy_eq_span_singleton

end Ideal.Quotient

namespace AddMonoid

theorem isTorsion_iff_isTorsion_nat [AddCommMonoid M] :
    AddMonoid.IsTorsion M ‚Üî Module.IsTorsion ‚Ñï M := by
  refine' ‚ü®fun h x => _, fun h x => _‚ü©
  -- ‚ä¢ ‚àÉ a, a ‚Ä¢ x = 0
  ¬∑ obtain ‚ü®n, h0, hn‚ü© := (isOfFinAddOrder_iff_nsmul_eq_zero x).mp (h x)
    -- ‚ä¢ ‚àÉ a, a ‚Ä¢ x = 0
    exact ‚ü®‚ü®n, mem_nonZeroDivisors_of_ne_zero <| ne_of_gt h0‚ü©, hn‚ü©
    -- üéâ no goals
  ¬∑ rw [isOfFinAddOrder_iff_nsmul_eq_zero]
    -- ‚ä¢ ‚àÉ n, 0 < n ‚àß n ‚Ä¢ x = 0
    obtain ‚ü®n, hn‚ü© := @h x
    -- ‚ä¢ ‚àÉ n, 0 < n ‚àß n ‚Ä¢ x = 0
    refine' ‚ü®n, Nat.pos_of_ne_zero (nonZeroDivisors.coe_ne_zero _), hn‚ü©
    -- üéâ no goals
#align add_monoid.is_torsion_iff_is_torsion_nat AddMonoid.isTorsion_iff_isTorsion_nat

theorem isTorsion_iff_isTorsion_int [AddCommGroup M] :
    AddMonoid.IsTorsion M ‚Üî Module.IsTorsion ‚Ñ§ M := by
  refine' ‚ü®fun h x => _, fun h x => _‚ü©
  -- ‚ä¢ ‚àÉ a, a ‚Ä¢ x = 0
  ¬∑ obtain ‚ü®n, h0, hn‚ü© := (isOfFinAddOrder_iff_nsmul_eq_zero x).mp (h x)
    -- ‚ä¢ ‚àÉ a, a ‚Ä¢ x = 0
    exact
      ‚ü®‚ü®n, mem_nonZeroDivisors_of_ne_zero <| ne_of_gt <| Int.coe_nat_pos.mpr h0‚ü©,
        (coe_nat_zsmul _ _).trans hn‚ü©
  ¬∑ rw [isOfFinAddOrder_iff_nsmul_eq_zero]
    -- ‚ä¢ ‚àÉ n, 0 < n ‚àß n ‚Ä¢ x = 0
    obtain ‚ü®n, hn‚ü© := @h x
    -- ‚ä¢ ‚àÉ n, 0 < n ‚àß n ‚Ä¢ x = 0
    exact exists_nsmul_eq_zero_of_zsmul_eq_zero (nonZeroDivisors.coe_ne_zero n) hn
    -- üéâ no goals
#align add_monoid.is_torsion_iff_is_torsion_int AddMonoid.isTorsion_iff_isTorsion_int

end AddMonoid
