/-
Copyright (c) 2024 Christopher Hoskin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Christopher Hoskin
-/

import Mathlib.Algebra.Module.Submodule.Lattice
import Mathlib.Order.Sublattice
import Mathlib.Algebra.Algebra.Subalgebra.Basic
import Mathlib.Algebra.Module.Submodule.Invariant
import Mathlib.LinearAlgebra.Basis.Flag

/-!
# Nest algebras

Nest algebras are an operator analogue of upper triangular matrices. They have been extensively
studied in the context of Hilbert spaces, but also in more general contexts.

This file develops the algebraic aspects of the theory.

## Main definitions

- `NestAlg`: The nest algebra generated by a `Nest`
- `Basis.toNest`: Every basis of a free module generates a `Nest` (and hence a nest subalgebra)

## References

- [K. R. Davidson, *Nest algebras*][davidson1988]
- [Z. Mesyan, *Infinite-Dimensional Triangularization*][mesyan2018]

## Tags

nest algebra, triangularization
-/

variable {R M : Type*}

variable [CommSemiring R] [AddCommMonoid M] [Module R M]

/--
The nest algebra of a nest
-/
def NestAlg (N : Set (Submodule R M)) : Subalgebra R (M →ₗ[R] M) where
  carrier := { T | ∀ (n : N), ↑n ∈ Module.End.invtSubmodule (T : Module.End R M)}
  add_mem' S T := by
    intro n x hx
    aesop
  mul_mem' S T := by
    intro n h hx
    aesop
  one_mem' := by aesop
  zero_mem' := by aesop
  algebraMap_mem' := by
    intro r n x hx
    aesop


/-! ### Free Modules -/

variable {ι : Type*} [LinearOrder ι] (v : ι → M)

/--
The lattice homomorphism from `WithBot (WithTop ι)` into `Submodule R M`
-/
def toNestMap : LatticeHom (WithBot (WithTop ι)) (Submodule R M) :=
  LatticeHom.withBot' (LatticeHom.withTop' (⟨fun i => Submodule.span R (v '' Set.Iio i),
  fun _ _ hab => sInf_le_sInf (fun _ hn =>
    subset_trans (Set.image_subset _ (Set.Iio_subset_Iio hab)) hn)⟩ : ι →o Submodule R M))

/--
The nest generated by a linearly ordered basis
-/
def toNest : Nest (Submodule R M) where
  carrier := Set.range (toNestMap v)
  chain := Monotone.isChain_range (OrderHomClass.mono _)
  mem_bot := by
    use ⊥
    rfl
  mem_top := by
    use ⊤
    rfl

variable (bm : Basis ι R M)

-- Existing finite dim case
#check Basis.toFlag

def Basis.toFlag' : Flag (Submodule R M) where
  carrier := Set.range (toNestMap bm)
  Chain' := Monotone.isChain_range (OrderHomClass.mono _)
  max_chain' := by
    intro s hs hbs
    apply subset_antisymm hbs
    intro p hp
    simp
    sorry
