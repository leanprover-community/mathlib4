/-
Copyright (c) 2024 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathlib.Algebra.Homology.Embedding.HomEquiv
import Mathlib.Algebra.Homology.Embedding.StupidTrunc

/-!
# The stupid filtration

-/

open CategoryTheory Category Limits

namespace ComplexShape

namespace Embedding

variable {Œπ‚ÇÅ : Type*} {c‚ÇÅ : ComplexShape Œπ‚ÇÅ} {Œπ : Type*} {c : ComplexShape Œπ}
  (e‚ÇÅ : Embedding c‚ÇÅ c)
  {Œπ‚ÇÇ : Type*} {c‚ÇÇ : ComplexShape Œπ‚ÇÇ} (e‚ÇÇ : Embedding c‚ÇÇ c)
  {Œπ‚ÇÉ : Type*} {c‚ÇÉ : ComplexShape Œπ‚ÇÉ} (e‚ÇÉ : Embedding c‚ÇÉ c)

structure Subset : Prop where
  subset : Set.range e‚ÇÅ.f ‚äÜ Set.range e‚ÇÇ.f

namespace Subset

lemma refl : e‚ÇÅ.Subset e‚ÇÅ where
  subset := by rfl

variable {e‚ÇÅ e‚ÇÇ e‚ÇÉ}

lemma trans (h‚ÇÅ‚ÇÇ : e‚ÇÅ.Subset e‚ÇÇ) (h‚ÇÇ‚ÇÉ : e‚ÇÇ.Subset e‚ÇÉ) : e‚ÇÅ.Subset e‚ÇÉ where
  subset := h‚ÇÅ‚ÇÇ.subset.trans h‚ÇÇ‚ÇÉ.subset

section

variable (h : e‚ÇÅ.Subset e‚ÇÇ)
include h
lemma exists_index (i‚ÇÅ : Œπ‚ÇÅ) : ‚àÉ (i‚ÇÇ : Œπ‚ÇÇ), e‚ÇÇ.f i‚ÇÇ = e‚ÇÅ.f i‚ÇÅ := h.subset ‚ü®i‚ÇÅ, rfl‚ü©

noncomputable def index (i‚ÇÅ : Œπ‚ÇÅ) : Œπ‚ÇÇ := (h.exists_index i‚ÇÅ).choose

lemma f_index (i‚ÇÅ : Œπ‚ÇÅ) : e‚ÇÇ.f (h.index i‚ÇÅ) = e‚ÇÅ.f i‚ÇÅ := (h.exists_index i‚ÇÅ).choose_spec

end

end Subset

end Embedding

end ComplexShape

namespace HomologicalComplex

variable {C : Type*} [Category C] [HasZeroMorphisms C] [HasZeroObject C]
variable {Œπ Œπ‚ÇÅ Œπ‚ÇÇ Œπ‚ÇÉ : Type*} {c‚ÇÅ : ComplexShape Œπ‚ÇÅ} {c‚ÇÇ : ComplexShape Œπ‚ÇÇ}
  {c‚ÇÉ : ComplexShape Œπ‚ÇÉ} {c : ComplexShape Œπ}
  (K L : HomologicalComplex C c) (œÜ : K ‚ü∂ L)
  {e‚ÇÅ : c‚ÇÅ.Embedding c} {e‚ÇÇ : c‚ÇÇ.Embedding c} {e‚ÇÉ : c‚ÇÉ.Embedding c} (h : e‚ÇÅ.Subset e‚ÇÇ)

noncomputable def restrictionStupidTruncIso [e‚ÇÅ.IsRelIff] [e‚ÇÇ.IsRelIff] :
    (K.stupidTrunc e‚ÇÇ).restriction e‚ÇÅ ‚âÖ K.restriction e‚ÇÅ :=
  Hom.isoOfComponents (fun i‚ÇÅ => K.stupidTruncXIso e‚ÇÇ (h.f_index i‚ÇÅ)) (fun i‚ÇÅ j‚ÇÅ _ => by
    dsimp [stupidTrunc, stupidTruncXIso]
    rw [(K.restriction e‚ÇÇ).extend_d_eq e‚ÇÇ (h.f_index i‚ÇÅ) (h.f_index j‚ÇÅ),
      K.restriction_d_eq e‚ÇÇ (h.f_index i‚ÇÅ) (h.f_index j‚ÇÅ)]
    simp [restrictionXIso])

variable {K L} in
@[reassoc (attr := simp)]
lemma restrictionStupidTruncIso_hom_naturality [e‚ÇÅ.IsRelIff] [e‚ÇÇ.IsRelIff] :
    restrictionMap (stupidTruncMap œÜ e‚ÇÇ) e‚ÇÅ ‚â´ (L.restrictionStupidTruncIso h).hom =
      (K.restrictionStupidTruncIso h).hom ‚â´ restrictionMap œÜ e‚ÇÅ := by
  ext i‚ÇÅ
  dsimp [stupidTruncMap, restrictionStupidTruncIso, stupidTruncXIso]
  rw [extendMap_f _ e‚ÇÇ (h.f_index i‚ÇÅ), restrictionMap_f' _ e‚ÇÇ (h.f_index i‚ÇÅ)]
  simp [restrictionXIso]

variable {K L} in
@[reassoc (attr := simp)]
lemma restrictionStupidTruncIso_inv_naturality [e‚ÇÅ.IsRelIff] [e‚ÇÇ.IsRelIff] :
    (K.restrictionStupidTruncIso h).inv ‚â´ restrictionMap (stupidTruncMap œÜ e‚ÇÇ) e‚ÇÅ =
       restrictionMap œÜ e‚ÇÅ ‚â´ (L.restrictionStupidTruncIso h).inv := by
  ext i‚ÇÅ
  dsimp [stupidTruncMap, restrictionStupidTruncIso, stupidTruncXIso]
  rw [extendMap_f _ e‚ÇÇ (h.f_index i‚ÇÅ), restrictionMap_f' _ e‚ÇÇ (h.f_index i‚ÇÅ)]
  simp [restrictionXIso]

noncomputable def mapStupidTruncLE [e‚ÇÅ.IsTruncLE] [e‚ÇÇ.IsRelIff] :
    K.stupidTrunc e‚ÇÇ ‚ü∂ K.stupidTrunc e‚ÇÅ :=
  e‚ÇÅ.liftExtend ((K.restrictionStupidTruncIso h).hom)
    (fun _ hi‚ÇÅ _ _ => hi‚ÇÅ.false_of_isTruncLE.elim)

noncomputable def mapStupidTruncGE [e‚ÇÅ.IsTruncGE] [e‚ÇÇ.IsRelIff] :
    K.stupidTrunc e‚ÇÅ ‚ü∂ K.stupidTrunc e‚ÇÇ :=
  e‚ÇÅ.descExtend ((K.restrictionStupidTruncIso h).inv)
    (fun _ hi‚ÇÅ _ _ => hi‚ÇÅ.false_of_isTruncGE.elim)

open ComplexShape.Embedding

variable {K L} in
@[reassoc (attr := simp)]
lemma mapStupidTruncLE_naturality [e‚ÇÅ.IsTruncLE] [e‚ÇÇ.IsRelIff] :
    stupidTruncMap œÜ e‚ÇÇ ‚â´ L.mapStupidTruncLE h =
      K.mapStupidTruncLE h ‚â´ stupidTruncMap œÜ e‚ÇÅ := by
  apply (e‚ÇÅ.homEquiv _ _).injective
  ext1
  dsimp [homEquiv, mapStupidTruncLE, stupidTruncMap]
  rw [homRestrict_precomp, homRestrict_comp_extendMap, homRestrict_liftExtend,
    homRestrict_liftExtend]
  apply restrictionStupidTruncIso_hom_naturality

@[reassoc (attr := simp)]
lemma mapStupidTruncLE_fac [e‚ÇÅ.IsTruncLE] [e‚ÇÇ.IsTruncLE] :
    K.œÄStupidTrunc e‚ÇÇ ‚â´ K.mapStupidTruncLE h = K.œÄStupidTrunc e‚ÇÅ := by
  apply (e‚ÇÅ.homEquiv _ _).injective
  ext i‚ÇÅ : 2
  dsimp [mapStupidTruncLE]
  rw [homRestrict_precomp, homRestrict_liftExtend, homRestrict_f e‚ÇÅ _ rfl]
  dsimp [œÄStupidTrunc]
  rw [œÄStupidTruncf_eq, œÄStupidTruncf_eq' _ _ (h.f_index i‚ÇÅ)]
  simp [restrictionStupidTruncIso, stupidTruncXIso, extendXIso, extend.XIso, restrictionXIso]

instance [e‚ÇÅ.IsTruncLE] [e‚ÇÇ.IsTruncLE] : Epi (K.mapStupidTruncLE h) :=
  epi_of_epi_fac (K.mapStupidTruncLE_fac h)

variable (e‚ÇÅ) in
@[simp]
noncomputable def mapStupidTruncLE_refl [e‚ÇÅ.IsTruncLE] :
    K.mapStupidTruncLE (Subset.refl e‚ÇÅ) = ùüô _ := by
  rw [‚Üê cancel_epi (K.œÄStupidTrunc e‚ÇÅ), mapStupidTruncLE_fac, comp_id]

@[reassoc (attr := simp)]
noncomputable def mapStupidTruncLE_trans [e‚ÇÅ.IsTruncLE] [e‚ÇÇ.IsTruncLE] [e‚ÇÉ.IsTruncLE]
    (h' : e‚ÇÇ.Subset e‚ÇÉ) :
    K.mapStupidTruncLE h' ‚â´ K.mapStupidTruncLE h = K.mapStupidTruncLE (h.trans h') := by
  rw [‚Üê cancel_epi (K.œÄStupidTrunc e‚ÇÉ), mapStupidTruncLE_fac_assoc,
    mapStupidTruncLE_fac, mapStupidTruncLE_fac]

variable {K L} in
@[reassoc (attr := simp)]
lemma mapStupidTruncGE_naturality [e‚ÇÅ.IsTruncGE] [e‚ÇÇ.IsRelIff] :
    K.mapStupidTruncGE h ‚â´ stupidTruncMap œÜ e‚ÇÇ =
      stupidTruncMap œÜ e‚ÇÅ ‚â´ L.mapStupidTruncGE h := by
  apply (e‚ÇÅ.homEquiv' _ _).injective
  ext1
  dsimp [homEquiv, mapStupidTruncGE, stupidTruncMap]
  rw [homRestrict'_postcomp, extend_comp_homRestrict', homRestrict'_descExtend,
    homRestrict'_descExtend]
  apply restrictionStupidTruncIso_inv_naturality

@[reassoc (attr := simp)]
lemma mapStupidTruncGE_fac [e‚ÇÅ.IsTruncGE] [e‚ÇÇ.IsTruncGE] :
    K.mapStupidTruncGE h ‚â´ K.ŒπStupidTrunc e‚ÇÇ = K.ŒπStupidTrunc e‚ÇÅ := by
  apply (e‚ÇÅ.homEquiv' _ _).injective
  ext i‚ÇÅ : 2
  dsimp [mapStupidTruncGE]
  rw [homRestrict'_postcomp, homRestrict'_descExtend, homRestrict'_f e‚ÇÅ _ rfl]
  dsimp [ŒπStupidTrunc]
  rw [ŒπStupidTruncf_eq, ŒπStupidTruncf'_eq _ _ (h.f_index i‚ÇÅ)]
  simp [restrictionStupidTruncIso, stupidTruncXIso, extendXIso, extend.XIso, restrictionXIso]

instance [e‚ÇÅ.IsTruncGE] [e‚ÇÇ.IsTruncGE] : Mono (K.mapStupidTruncGE h) :=
  mono_of_mono_fac (K.mapStupidTruncGE_fac h)

lemma isIso_mapStupidTruncGE_f [e‚ÇÅ.IsTruncGE] [e‚ÇÇ.IsTruncGE] (i : Œπ)
    (hi : (‚àÉ i‚ÇÅ, e‚ÇÅ.f i‚ÇÅ = i) ‚à® (‚àÄ i‚ÇÇ, e‚ÇÇ.f i‚ÇÇ ‚â† i)) :
    IsIso ((K.mapStupidTruncGE h).f i) := by
  obtain ‚ü®i‚ÇÅ, hi‚ÇÅ‚ü© | hi := hi
  ¬∑ have fac := (eval _ _ i).congr_map (K.mapStupidTruncGE_fac h)
    dsimp at fac
    obtain ‚ü®i‚ÇÇ, hi‚ÇÇ‚ü© := h.subset ‚ü®_, hi‚ÇÅ‚ü©
    have := K.isIso_ŒπStupidTrunc_f e‚ÇÅ hi‚ÇÅ
    have := K.isIso_ŒπStupidTrunc_f e‚ÇÇ hi‚ÇÇ
    exact IsIso.of_isIso_fac_right fac
  ¬∑ refine ‚ü®0, ?_, ?_‚ü©
    ¬∑ apply IsZero.eq_of_src
      apply isZero_stupidTrunc_X
      intro i‚ÇÅ hi‚ÇÅ
      obtain ‚ü®i‚ÇÇ, hi‚ÇÇ‚ü© := h.subset ‚ü®_, hi‚ÇÅ‚ü©
      exact hi i‚ÇÇ hi‚ÇÇ
    ¬∑ apply IsZero.eq_of_src
      apply isZero_stupidTrunc_X
      exact hi

variable (e‚ÇÅ) in
@[simp]
noncomputable def mapStupidTruncGE_refl [e‚ÇÅ.IsTruncGE] :
    K.mapStupidTruncGE (Subset.refl e‚ÇÅ) = ùüô _ := by
  rw [‚Üê cancel_mono (K.ŒπStupidTrunc e‚ÇÅ), mapStupidTruncGE_fac, id_comp]

@[reassoc (attr := simp)]
noncomputable def mapStupidTruncGE_trans [e‚ÇÅ.IsTruncGE] [e‚ÇÇ.IsTruncGE] [e‚ÇÉ.IsTruncGE]
    (h' : e‚ÇÇ.Subset e‚ÇÉ) :
    K.mapStupidTruncGE h ‚â´ K.mapStupidTruncGE h' = K.mapStupidTruncGE (h.trans h') := by
  rw [‚Üê cancel_mono (K.ŒπStupidTrunc e‚ÇÉ), assoc, mapStupidTruncGE_fac,
    mapStupidTruncGE_fac, mapStupidTruncGE_fac]

end HomologicalComplex

namespace ComplexShape

namespace Embedding

namespace Subset

variable {Œπ Œπ‚ÇÅ Œπ‚ÇÇ Œπ‚ÇÉ : Type*} {c‚ÇÅ : ComplexShape Œπ‚ÇÅ} {c‚ÇÇ : ComplexShape Œπ‚ÇÇ}
  {c‚ÇÉ : ComplexShape Œπ‚ÇÉ} {c : ComplexShape Œπ}
  {e‚ÇÅ : c‚ÇÅ.Embedding c} {e‚ÇÇ : c‚ÇÇ.Embedding c} (h : e‚ÇÅ.Subset e‚ÇÇ)
variable (C : Type*) [Category C] [HasZeroMorphisms C] [HasZeroObject C]

@[simps!]
noncomputable def restrictionStupidTruncNatIso [e‚ÇÅ.IsRelIff] [e‚ÇÇ.IsRelIff] :
    e‚ÇÇ.stupidTruncFunctor C ‚ãô e‚ÇÅ.restrictionFunctor C ‚âÖ e‚ÇÅ.restrictionFunctor C :=
  NatIso.ofComponents (fun K => K.restrictionStupidTruncIso h)

section

variable [e‚ÇÅ.IsTruncLE] [e‚ÇÇ.IsRelIff] (h : e‚ÇÅ.Subset e‚ÇÇ)
variable (C : Type*) [Category C] [HasZeroMorphisms C] [HasZeroObject C]

@[simps]
noncomputable def mapStupidTruncLE :
    e‚ÇÇ.stupidTruncFunctor C ‚ü∂ e‚ÇÅ.stupidTruncFunctor C where
  app K := K.mapStupidTruncLE h

end

section

variable [e‚ÇÅ.IsTruncGE] [e‚ÇÇ.IsRelIff] (h : e‚ÇÅ.Subset e‚ÇÇ)
variable (C : Type*) [Category C] [HasZeroMorphisms C] [HasZeroObject C]

@[simps]
noncomputable def mapStupidTruncGE :
    e‚ÇÅ.stupidTruncFunctor C ‚ü∂ e‚ÇÇ.stupidTruncFunctor C where
  app K := K.mapStupidTruncGE h

end


end Subset

section

variable {Œπ' : Type*} {c' : ComplexShape Œπ'} {Œ± : Type*} [Category Œ±] {Œπ : Œ± ‚Üí Type*}
  {c : Œ† (a : Œ±), ComplexShape (Œπ a)} (e : Œ† (a : Œ±), Embedding (c a) c')
  (he : ‚àÄ ‚¶Éa a' : Œ±‚¶Ñ (_ : a' ‚ü∂ a), (e a).Subset (e a'))
  [‚àÄ a, (e a).IsTruncLE]
  (C : Type*) [Category C] [HasZeroMorphisms C] [HasZeroObject C]

@[simps]
noncomputable def stupidTruncLEFiltration :
    Œ± ‚•§ (HomologicalComplex C c' ‚•§ HomologicalComplex C c') where
  obj a := (e a).stupidTruncFunctor C
  map {a a'} œÜ := (he œÜ).mapStupidTruncLE C

instance {a a' : Œ±} (œÜ : a ‚ü∂ a') (K : HomologicalComplex C c') :
    Epi (((stupidTruncLEFiltration e he C).map œÜ).app K) := by
  dsimp
  infer_instance

end

section

variable {Œπ' : Type*} {c' : ComplexShape Œπ'} {Œ± : Type*} [Category Œ±] {Œπ : Œ± ‚Üí Type*}
  {c : Œ† (a : Œ±), ComplexShape (Œπ a)} (e : Œ† (a : Œ±), Embedding (c a) c')
  (he : ‚àÄ ‚¶Éa a' : Œ±‚¶Ñ (_ : a ‚ü∂ a'), (e a).Subset (e a'))
  [‚àÄ a, (e a).IsTruncGE]
  (C : Type*) [Category C] [HasZeroMorphisms C] [HasZeroObject C]

@[simps]
noncomputable def stupidTruncGEFiltration :
    Œ± ‚•§ (HomologicalComplex C c' ‚•§ HomologicalComplex C c') where
  obj a := (e a).stupidTruncFunctor C
  map {a a'} œÜ := (he œÜ).mapStupidTruncGE C

instance {a a' : Œ±} (œÜ : a ‚ü∂ a') (K : HomologicalComplex C c') :
    Mono (((stupidTruncGEFiltration e he C).map œÜ).app K) := by
  dsimp
  infer_instance

end


end Embedding

end ComplexShape
