/-
Copyright (c) 2021 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison

! This file was ported from Lean 3 source module algebra.homology.single
! leanprover-community/mathlib commit 324a7502510e835cdbd3de1519b6c66b51fb2467
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Homology.Homology

/-!
# Chain complexes supported in a single degree

We define `single V j c : V ‚•§ homological_complex V c`,
which constructs complexes in `V` of shape `c`, supported in degree `j`.

Similarly `single‚ÇÄ V : V ‚•§ chain_complex V ‚Ñï` is the special case for
`‚Ñï`-indexed chain complexes, with the object supported in degree `0`,
but with better definitional properties.

In `to_single‚ÇÄ_equiv` we characterize chain maps to a `‚Ñï`-indexed complex concentrated in degree 0;
they are equivalent to `{ f : C.X 0 ‚ü∂ X // C.d 1 0 ‚â´ f = 0 }`.
(This is useful translating between a projective resolution and
an augmented exact complex of projectives.)
-/


noncomputable section

open CategoryTheory

open CategoryTheory.Limits

universe v u

variable (V : Type u) [Category.{v} V] [HasZeroMorphisms V] [HasZeroObject V]

namespace HomologicalComplex

variable {Œπ : Type _} [DecidableEq Œπ] (c : ComplexShape Œπ)

attribute [local instance] has_zero_object.has_zero

/-- The functor `V ‚•§ homological_complex V c` creating a chain complex supported in a single degree.

See also `chain_complex.single‚ÇÄ : V ‚•§ chain_complex V ‚Ñï`,
which has better definitional properties,
if you are working with `‚Ñï`-indexed complexes.
-/
@[simps]
def single (j : Œπ) : V ‚•§ HomologicalComplex V c
    where
  obj A :=
    { pt := fun i => if i = j then A else 0
      d := fun i j => 0 }
  map A B f :=
    {
      f := fun i =>
        if h : i = j then
          eqToHom
              (by
                dsimp
                rw [if_pos h]) ‚â´
            f ‚â´
              eqToHom
                (by
                  dsimp
                  rw [if_pos h])
        else 0 }
  map_id' A := by
    ext
    dsimp
    split_ifs with h
    ¬∑ subst h
      simp
    ¬∑ rw [if_neg h]
      simp
  map_comp' A B C f g := by
    ext
    dsimp
    split_ifs with h
    ¬∑ subst h
      simp
    ¬∑ simp
#align homological_complex.single HomologicalComplex.single

/-- The object in degree `j` of `(single V c h).obj A` is just `A`.
-/
@[simps]
def singleObjXSelf (j : Œπ) (A : V) : ((single V c j).obj A).pt j ‚âÖ A :=
  eqToIso (by simp)
#align homological_complex.single_obj_X_self HomologicalComplex.singleObjXSelf

@[simp]
theorem single_map_f_self (j : Œπ) {A B : V} (f : A ‚ü∂ B) :
    ((single V c j).map f).f j = (singleObjXSelf V c j A).Hom ‚â´ f ‚â´ (singleObjXSelf V c j B).inv :=
  by
  simp
  rfl
#align homological_complex.single_map_f_self HomologicalComplex.single_map_f_self

instance (j : Œπ) : Faithful (single V c j)
    where map_injective' X Y f g w := by
    have := congr_hom w j
    dsimp at this
    simp only [dif_pos] at this
    rw [‚Üê is_iso.inv_comp_eq, inv_eq_to_hom, eq_to_hom_trans_assoc, eq_to_hom_refl,
      category.id_comp, ‚Üê is_iso.comp_inv_eq, category.assoc, inv_eq_to_hom, eq_to_hom_trans,
      eq_to_hom_refl, category.comp_id] at this
    exact this

instance (j : Œπ) : Full (single V c j)
    where
  preimage X Y f := eqToHom (by simp) ‚â´ f.f j ‚â´ eqToHom (by simp)
  witness' X Y f := by
    ext i
    dsimp
    split_ifs
    ¬∑ subst h
      simp
    ¬∑ symm
      apply zero_of_target_iso_zero
      dsimp
      rw [if_neg h]

end HomologicalComplex

open HomologicalComplex

namespace ChainComplex

attribute [local instance] has_zero_object.has_zero

/-- `chain_complex.single‚ÇÄ V` is the embedding of `V` into `chain_complex V ‚Ñï`
as chain complexes supported in degree 0.

This is naturally isomorphic to `single V _ 0`, but has better definitional properties.
-/
def single‚ÇÄ : V ‚•§ ChainComplex V ‚Ñï
    where
  obj X :=
    { pt := fun n =>
        match n with
        | 0 => X
        | n + 1 => 0
      d := fun i j => 0 }
  map X Y f :=
    {
      f := fun n =>
        match n with
        | 0 => f
        | n + 1 => 0 }
  map_id' X := by
    ext n
    cases n
    rfl
    dsimp
    unfold_aux
    simp
  map_comp' X Y Z f g := by
    ext n
    cases n
    rfl
    dsimp
    unfold_aux
    simp
#align chain_complex.single‚ÇÄ ChainComplex.single‚ÇÄ

@[simp]
theorem single‚ÇÄ_obj_x_0 (X : V) : ((single‚ÇÄ V).obj X).pt 0 = X :=
  rfl
#align chain_complex.single‚ÇÄ_obj_X_0 ChainComplex.single‚ÇÄ_obj_x_0

@[simp]
theorem single‚ÇÄ_obj_x_succ (X : V) (n : ‚Ñï) : ((single‚ÇÄ V).obj X).pt (n + 1) = 0 :=
  rfl
#align chain_complex.single‚ÇÄ_obj_X_succ ChainComplex.single‚ÇÄ_obj_x_succ

@[simp]
theorem single‚ÇÄ_obj_x_d (X : V) (i j : ‚Ñï) : ((single‚ÇÄ V).obj X).d i j = 0 :=
  rfl
#align chain_complex.single‚ÇÄ_obj_X_d ChainComplex.single‚ÇÄ_obj_x_d

@[simp]
theorem single‚ÇÄ_obj_x_dTo (X : V) (j : ‚Ñï) : ((single‚ÇÄ V).obj X).dTo j = 0 :=
  by
  rw [d_to_eq ((single‚ÇÄ V).obj X) rfl]
  simp
#align chain_complex.single‚ÇÄ_obj_X_d_to ChainComplex.single‚ÇÄ_obj_x_dTo

@[simp]
theorem single‚ÇÄ_obj_x_dFrom (X : V) (i : ‚Ñï) : ((single‚ÇÄ V).obj X).dFrom i = 0 :=
  by
  cases i
  ¬∑ rw [d_from_eq_zero]
    simp
  ¬∑ rw [d_from_eq ((single‚ÇÄ V).obj X) rfl]
    simp
#align chain_complex.single‚ÇÄ_obj_X_d_from ChainComplex.single‚ÇÄ_obj_x_dFrom

@[simp]
theorem single‚ÇÄ_map_f_0 {X Y : V} (f : X ‚ü∂ Y) : ((single‚ÇÄ V).map f).f 0 = f :=
  rfl
#align chain_complex.single‚ÇÄ_map_f_0 ChainComplex.single‚ÇÄ_map_f_0

@[simp]
theorem single‚ÇÄ_map_f_succ {X Y : V} (f : X ‚ü∂ Y) (n : ‚Ñï) : ((single‚ÇÄ V).map f).f (n + 1) = 0 :=
  rfl
#align chain_complex.single‚ÇÄ_map_f_succ ChainComplex.single‚ÇÄ_map_f_succ

section

variable [HasEqualizers V] [HasCokernels V] [HasImages V] [HasImageMaps V]

/-- Sending objects to chain complexes supported at `0` then taking `0`-th homology
is the same as doing nothing.
-/
noncomputable def homologyFunctor0Single‚ÇÄ : single‚ÇÄ V ‚ãô homologyFunctor V _ 0 ‚âÖ ùü≠ V :=
  NatIso.ofComponents (fun X => homology.congr _ _ (by simp) (by simp) ‚â™‚â´ homologyZeroZero)
    fun X Y f => by
    ext
    dsimp [homologyFunctor]
    simp
#align chain_complex.homology_functor_0_single‚ÇÄ ChainComplex.homologyFunctor0Single‚ÇÄ

/-- Sending objects to chain complexes supported at `0` then taking `(n+1)`-st homology
is the same as the zero functor.
-/
noncomputable def homologyFunctorSuccSingle‚ÇÄ (n : ‚Ñï) :
    single‚ÇÄ V ‚ãô homologyFunctor V _ (n + 1) ‚âÖ 0 :=
  NatIso.ofComponents
    (fun X =>
      homology.congr _ _ (by simp) (by simp) ‚â™‚â´
        homologyZeroZero ‚â™‚â´ (Functor.zero_obj _).isoZero.symm)
    fun X Y f => (functor.zero_obj _).eq_of_tgt _ _
#align chain_complex.homology_functor_succ_single‚ÇÄ ChainComplex.homologyFunctorSuccSingle‚ÇÄ

end

variable {V}

/-- Morphisms from a `‚Ñï`-indexed chain complex `C`
to a single object chain complex with `X` concentrated in degree 0
are the same as morphisms `f : C.X 0 ‚ü∂ X` such that `C.d 1 0 ‚â´ f = 0`.
-/
@[simps]
def toSingle‚ÇÄEquiv (C : ChainComplex V ‚Ñï) (X : V) :
    (C ‚ü∂ (single‚ÇÄ V).obj X) ‚âÉ { f : C.pt 0 ‚ü∂ X // C.d 1 0 ‚â´ f = 0 }
    where
  toFun f :=
    ‚ü®f.f 0, by
      rw [‚Üê f.comm 1 0]
      simp‚ü©
  invFun f :=
    { f := fun i =>
        match i with
        | 0 => f.1
        | n + 1 => 0
      comm' := fun i j h =>
        by
        rcases i with (_ | _ | i) <;> cases j <;> unfold_aux <;>
          simp only [comp_zero, zero_comp, single‚ÇÄ_obj_X_d]
        ¬∑ rw [C.shape, zero_comp]
          simp
        ¬∑ exact f.2.symm
        ¬∑ rw [C.shape, zero_comp]
          simp [i.succ_succ_ne_one.symm] }
  left_inv f := by
    ext i
    rcases i with ‚ü®‚ü©
    ¬∑ rfl
    ¬∑ ext
  right_inv := by tidy
#align chain_complex.to_single‚ÇÄ_equiv ChainComplex.toSingle‚ÇÄEquiv

@[ext]
theorem to_single‚ÇÄ_ext {C : ChainComplex V ‚Ñï} {X : V} (f g : C ‚ü∂ (single‚ÇÄ V).obj X)
    (h : f.f 0 = g.f 0) : f = g :=
  (toSingle‚ÇÄEquiv C X).Injective
    (by
      ext
      exact h)
#align chain_complex.to_single‚ÇÄ_ext ChainComplex.to_single‚ÇÄ_ext

/-- Morphisms from a single object chain complex with `X` concentrated in degree 0
to a `‚Ñï`-indexed chain complex `C` are the same as morphisms `f : X ‚Üí C.X`.
-/
@[simps]
def fromSingle‚ÇÄEquiv (C : ChainComplex V ‚Ñï) (X : V) : ((single‚ÇÄ V).obj X ‚ü∂ C) ‚âÉ (X ‚ü∂ C.pt 0)
    where
  toFun f := f.f 0
  invFun f :=
    { f := fun i =>
        match i with
        | 0 => f
        | n + 1 => 0
      comm' := fun i j h => by
        cases i <;> cases j <;> unfold_aux <;>
          simp only [shape, ComplexShape.down_Rel, Nat.one_ne_zero, not_false_iff, comp_zero,
            zero_comp, Nat.succ_ne_zero, single‚ÇÄ_obj_X_d] }
  left_inv f := by
    ext i
    cases i
    ¬∑ rfl
    ¬∑ ext
  right_inv g := rfl
#align chain_complex.from_single‚ÇÄ_equiv ChainComplex.fromSingle‚ÇÄEquiv

variable (V)

/-- `single‚ÇÄ` is the same as `single V _ 0`. -/
def single‚ÇÄIsoSingle : single‚ÇÄ V ‚âÖ single V _ 0 :=
  NatIso.ofComponents
    (fun X =>
      { Hom := { f := fun i => by cases i <;> simpa using ùüô _ }
        inv := { f := fun i => by cases i <;> simpa using ùüô _ }
        hom_inv_id' := by
          ext (_ | i) <;>
            ¬∑ dsimp
              simp
        inv_hom_id' := by
          ext (_ | i)
          ¬∑ apply category.id_comp
          ¬∑ apply has_zero_object.to_zero_ext })
    fun X Y f => by
    ext (_ | i) <;>
      ¬∑ dsimp
        simp
#align chain_complex.single‚ÇÄ_iso_single ChainComplex.single‚ÇÄIsoSingle

instance : Faithful (single‚ÇÄ V) :=
  Faithful.of_iso (single‚ÇÄIsoSingle V).symm

instance : Full (single‚ÇÄ V) :=
  Full.ofIso (single‚ÇÄIsoSingle V).symm

end ChainComplex

namespace CochainComplex

attribute [local instance] has_zero_object.has_zero

/-- `cochain_complex.single‚ÇÄ V` is the embedding of `V` into `cochain_complex V ‚Ñï`
as cochain complexes supported in degree 0.

This is naturally isomorphic to `single V _ 0`, but has better definitional properties.
-/
def single‚ÇÄ : V ‚•§ CochainComplex V ‚Ñï
    where
  obj X :=
    { pt := fun n =>
        match n with
        | 0 => X
        | n + 1 => 0
      d := fun i j => 0 }
  map X Y f :=
    {
      f := fun n =>
        match n with
        | 0 => f
        | n + 1 => 0 }
  map_id' X := by
    ext n
    cases n
    rfl
    dsimp
    unfold_aux
    simp
  map_comp' X Y Z f g := by
    ext n
    cases n
    rfl
    dsimp
    unfold_aux
    simp
#align cochain_complex.single‚ÇÄ CochainComplex.single‚ÇÄ

@[simp]
theorem single‚ÇÄ_obj_x_0 (X : V) : ((single‚ÇÄ V).obj X).pt 0 = X :=
  rfl
#align cochain_complex.single‚ÇÄ_obj_X_0 CochainComplex.single‚ÇÄ_obj_x_0

@[simp]
theorem single‚ÇÄ_obj_x_succ (X : V) (n : ‚Ñï) : ((single‚ÇÄ V).obj X).pt (n + 1) = 0 :=
  rfl
#align cochain_complex.single‚ÇÄ_obj_X_succ CochainComplex.single‚ÇÄ_obj_x_succ

@[simp]
theorem single‚ÇÄ_obj_x_d (X : V) (i j : ‚Ñï) : ((single‚ÇÄ V).obj X).d i j = 0 :=
  rfl
#align cochain_complex.single‚ÇÄ_obj_X_d CochainComplex.single‚ÇÄ_obj_x_d

@[simp]
theorem single‚ÇÄ_obj_x_dFrom (X : V) (j : ‚Ñï) : ((single‚ÇÄ V).obj X).dFrom j = 0 :=
  by
  rw [d_from_eq ((single‚ÇÄ V).obj X) rfl]
  simp
#align cochain_complex.single‚ÇÄ_obj_X_d_from CochainComplex.single‚ÇÄ_obj_x_dFrom

@[simp]
theorem single‚ÇÄ_obj_x_dTo (X : V) (i : ‚Ñï) : ((single‚ÇÄ V).obj X).dTo i = 0 :=
  by
  cases i
  ¬∑ rw [d_to_eq_zero]
    simp
  ¬∑ rw [d_to_eq ((single‚ÇÄ V).obj X) rfl]
    simp
#align cochain_complex.single‚ÇÄ_obj_X_d_to CochainComplex.single‚ÇÄ_obj_x_dTo

@[simp]
theorem single‚ÇÄ_map_f_0 {X Y : V} (f : X ‚ü∂ Y) : ((single‚ÇÄ V).map f).f 0 = f :=
  rfl
#align cochain_complex.single‚ÇÄ_map_f_0 CochainComplex.single‚ÇÄ_map_f_0

@[simp]
theorem single‚ÇÄ_map_f_succ {X Y : V} (f : X ‚ü∂ Y) (n : ‚Ñï) : ((single‚ÇÄ V).map f).f (n + 1) = 0 :=
  rfl
#align cochain_complex.single‚ÇÄ_map_f_succ CochainComplex.single‚ÇÄ_map_f_succ

section

variable [HasEqualizers V] [HasCokernels V] [HasImages V] [HasImageMaps V]

/-- Sending objects to cochain complexes supported at `0` then taking `0`-th homology
is the same as doing nothing.
-/
noncomputable def homologyFunctor0Single‚ÇÄ : single‚ÇÄ V ‚ãô homologyFunctor V _ 0 ‚âÖ ùü≠ V :=
  NatIso.ofComponents (fun X => homology.congr _ _ (by simp) (by simp) ‚â™‚â´ homologyZeroZero)
    fun X Y f => by
    ext
    dsimp [homologyFunctor]
    simp
#align cochain_complex.homology_functor_0_single‚ÇÄ CochainComplex.homologyFunctor0Single‚ÇÄ

/-- Sending objects to cochain complexes supported at `0` then taking `(n+1)`-st homology
is the same as the zero functor.
-/
noncomputable def homologyFunctorSuccSingle‚ÇÄ (n : ‚Ñï) :
    single‚ÇÄ V ‚ãô homologyFunctor V _ (n + 1) ‚âÖ 0 :=
  NatIso.ofComponents
    (fun X =>
      homology.congr _ _ (by simp) (by simp) ‚â™‚â´
        homologyZeroZero ‚â™‚â´ (Functor.zero_obj _).isoZero.symm)
    fun X Y f => (functor.zero_obj _).eq_of_tgt _ _
#align cochain_complex.homology_functor_succ_single‚ÇÄ CochainComplex.homologyFunctorSuccSingle‚ÇÄ

end

variable {V}

/-- Morphisms from a single object cochain complex with `X` concentrated in degree 0
to a `‚Ñï`-indexed cochain complex `C`
are the same as morphisms `f : X ‚ü∂ C.X 0` such that `f ‚â´ C.d 0 1 = 0`.
-/
def fromSingle‚ÇÄEquiv (C : CochainComplex V ‚Ñï) (X : V) :
    ((single‚ÇÄ V).obj X ‚ü∂ C) ‚âÉ { f : X ‚ü∂ C.pt 0 // f ‚â´ C.d 0 1 = 0 }
    where
  toFun f :=
    ‚ü®f.f 0, by
      rw [f.comm 0 1]
      simp‚ü©
  invFun f :=
    { f := fun i =>
        match i with
        | 0 => f.1
        | n + 1 => 0
      comm' := fun i j h =>
        by
        rcases j with (_ | _ | j) <;> cases i <;> unfold_aux <;>
          simp only [comp_zero, zero_comp, single‚ÇÄ_obj_X_d]
        ¬∑ convert comp_zero
          rw [C.shape]
          simp
        ¬∑ exact f.2
        ¬∑ convert comp_zero
          rw [C.shape]
          simp only [ComplexShape.up_Rel, zero_add]
          exact (Nat.one_lt_succ_succ j).Ne }
  left_inv f := by
    ext i
    rcases i with ‚ü®‚ü©
    ¬∑ rfl
    ¬∑ ext
  right_inv := by tidy
#align cochain_complex.from_single‚ÇÄ_equiv CochainComplex.fromSingle‚ÇÄEquiv

variable (V)

/-- `single‚ÇÄ` is the same as `single V _ 0`. -/
def single‚ÇÄIsoSingle : single‚ÇÄ V ‚âÖ single V _ 0 :=
  NatIso.ofComponents
    (fun X =>
      { Hom := { f := fun i => by cases i <;> simpa using ùüô _ }
        inv := { f := fun i => by cases i <;> simpa using ùüô _ }
        hom_inv_id' := by
          ext (_ | i) <;>
            ¬∑ dsimp
              simp
        inv_hom_id' := by
          ext (_ | i)
          ¬∑ apply category.id_comp
          ¬∑ apply has_zero_object.to_zero_ext })
    fun X Y f => by
    ext (_ | i) <;>
      ¬∑ dsimp
        simp
#align cochain_complex.single‚ÇÄ_iso_single CochainComplex.single‚ÇÄIsoSingle

instance : Faithful (single‚ÇÄ V) :=
  Faithful.of_iso (single‚ÇÄIsoSingle V).symm

instance : Full (single‚ÇÄ V) :=
  Full.ofIso (single‚ÇÄIsoSingle V).symm

end CochainComplex

