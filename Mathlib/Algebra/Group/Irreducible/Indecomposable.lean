/-
Copyright (c) 2025 Oliver Nash. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Oliver Nash
-/
module

public import Mathlib.Algebra.Group.Irreducible.Defs
public import Mathlib.Algebra.Group.Subgroup.Lattice
public import Mathlib.Algebra.Group.Subgroup.Pointwise
public import Mathlib.Algebra.Group.Submonoid.Basic
public import Mathlib.Algebra.Order.Group.Defs
public import Mathlib.Algebra.Order.Monoid.Defs
public import Mathlib.Order.Preorder.Finite

/-!
# Indecomposable elements of monoids
-/

@[expose] public section

open Set

variable {ι M G S : Type*} [Monoid M] [CommGroup G] [LinearOrder S]

/-- Given a family of elements of a monoid, a member is said to be indecomposable if it cannot be
written as a product of two others in a non-trivial way. -/
@[to_additive (attr := simp) /-- Given a family of elements of an additive monoid, a member is said
to be indecomposable if it cannot be written as a sum of two others in a non-trivial way.-/]
def IsMulIndecomposable (v : ι → M) (s : Set ι) (i : ι) : Prop :=
  i ∈ s ∧ ∀ᵉ (j ∈ s) (k ∈ s), v i = v j * v k → v j = 1 ∨ v k = 1

@[to_additive]
protected lemma IsMulIndecomposable.subset (v : ι → M) (s : Set ι) :
    {i | IsMulIndecomposable v s i} ⊆ s := by
  aesop

@[to_additive]
lemma isMulIndecomposable_id_univ [Subsingleton Mˣ] {x : M} (hx : x ≠ 1) :
    IsMulIndecomposable id univ x ↔ Irreducible x :=
  ⟨fun h ↦ ⟨by simpa, by simpa using h⟩, fun h ↦ by simpa using h.isUnit_or_isUnit⟩

/-- The "base" of a set of points of a monoid relative to a morphism `f`. -/
@[to_additive /-- The "base" of `v` relative to a morphism `f`.

In the case that `v` is the set of roots of a crystallographic root system, and `S = ℚ`, this is the
base of the root system associated to `f`. -/]
def IsMulIndecomposable.baseOf [Monoid S] (v : ι → M) (f : M →* S) : Set ι :=
  {j | IsMulIndecomposable v {i | 1 < f (v i)} j}

@[to_additive]
lemma IsMulIndecomposable.baseOf_subset_one_lt [Monoid S] (v : ι → M) (f : M →* S) :
    IsMulIndecomposable.baseOf v f ⊆ {i | 1 < f (v i)} :=
  IsMulIndecomposable.subset _ _

@[to_additive]
lemma IsMulIndecomposable.image_baseOf_inv_comp_eq [InvolutiveInv ι]
    [CommGroup S] [IsOrderedMonoid S]
    (v : ι → G) (hv_inv : ∀ i, v i⁻¹ = (v i)⁻¹)
    (f : G →* S) :
    v '' baseOf v (invMonoidHom.comp f) = (invMonoidHom ∘ v) '' baseOf v f := by
  suffices ∀ (f : G →* S),
      v '' baseOf v (invMonoidHom.comp f) ⊆ (invMonoidHom ∘ v) '' baseOf v f by
    apply subset_antisymm (this f)
    replace this := image_mono (f := invMonoidHom) <| this (invMonoidHom.comp f)
    rw [← MonoidHom.comp_assoc, invMonoidHom_comp_invMonoidHom, MonoidHom.id_comp, image_comp,
      ← image_comp invMonoidHom invMonoidHom, ← MonoidHom.coe_comp, invMonoidHom_comp_invMonoidHom,
      ← image_comp] at this
    simpa using this
  clear f
  rintro f g ⟨i, ⟨hi, hi'⟩, rfl⟩
  refine ⟨i⁻¹, ⟨by simpa [hv_inv] using hi, fun j hj k hk hi ↦ ?_⟩, by simp [hv_inv]⟩
  replace hi : v i = v j⁻¹ * v k⁻¹ := by
    rwa [hv_inv, inv_eq_iff_eq_inv, mul_inv, ← hv_inv, ← hv_inv] at hi
  specialize hi' j⁻¹ (by simpa [hv_inv]) k⁻¹ (by simpa [hv_inv]) hi
  aesop

/-- Given a finite family of points `v` in a monoid `M`, together with a morphism into a
linearly-ordered monoid `f : M →* S`, the submonoid generated by those points of `v` which lie in
the "half space" where `f > 1` is generated by the subset of such points which are indecomposable
with respect to points in this half space. -/
@[to_additive /-- Given a finite family of points `v` in an additive monoid `M`, together with a
morphism into a linearly-ordered additive monoid `f : M →+ S`, the submonoid generated by those
points of `v` which lie in the half space where `f > 0` is generated by the subset of such points
which are indecomposable with respect to points in this half space.

If `v` is the set of roots of a crystallographic root system and `S = ℚ`, then this is
[serre1965](Ch. V, §9, Lemma 2) and it may be used to prove that the root system has a base. -/]
lemma Submonoid.closure_image_isMulIndecomposable_baseOf [Finite ι]
    [CommMonoid S] [IsOrderedCancelMonoid S]
    (v : ι → M) (f : M →* S) :
    closure (v '' IsMulIndecomposable.baseOf v f) = closure (v '' {i | 1 < f (v i)}) := by
  refine le_antisymm (closure_mono (image_mono <| IsMulIndecomposable.baseOf_subset_one_lt v f))
    (closure_le.mpr ?_)
  rintro - ⟨i, hi : 1 < f (v i), rfl⟩
  by_contra hi'
  let t : Set ι := {i | IsMulIndecomposable v {j | 1 < f (v j)} i}
  let s : Set ι := {j | 1 < f (v j) ∧ v j ∉ closure (v '' t)}
  have hne : s.Nonempty := ⟨i, hi, hi'⟩
  clear! i
  obtain ⟨i, hi⟩ := s.toFinite.exists_minimalFor (f ∘ v) s hne
  have ⟨(hi₀ : 1 < f (v i)), (hi₁ : v i ∉ _)⟩ : i ∈ s := hi.prop
  have hi₂ (k : ι) (hk₀ : 1 < f (v k)) (hk₁ : f (v k) < f (v i)) : v k ∈ closure (v '' t) := by
    by_contra hk₂; exact not_le.mpr hk₁ <| hi.le_of_le ⟨hk₀, hk₂⟩ hk₁.le
  have hi₃ : i ∉ t := by contrapose! hi₁; exact subset_closure <| mem_image_of_mem v hi₁
  obtain ⟨j, k, hj, hk, hjk⟩ : ∃ (j k : ι) (hj : 1 < f (v j)) (hk : 1 < f (v k)),
      v i = v j * v k := by
    grind [IsMulIndecomposable]
  have hj' : v j ∈ closure (v '' t) := hi₂ j hj <| by aesop
  have hk' : v k ∈ closure (v '' t) := hi₂ k hk <| by aesop
  replace hjk : v i ∈ closure (v '' t) := hjk ▸ mul_mem hj' hk'
  exact hi₁ hjk

@[deprecated (since := "2025-12-30")]
alias Submonoid.closure_image_one_lt_and_isMulIndecomposable :=
  Submonoid.closure_image_isMulIndecomposable_baseOf

@[to_additive]
lemma Subgroup.closure_image_isMulIndecomposable_baseOf [Finite ι] [InvolutiveInv ι]
    [CommGroup S] [IsOrderedMonoid S]
    (v : ι → G) (hv_inv : ∀ i, v i⁻¹ = (v i)⁻¹)
    (f : G →* S) (hf : ∀ i, f (v i) ≠ 1) :
    closure (v '' IsMulIndecomposable.baseOf v f) = closure (range v) := by
  rw [← image_univ]
  refine le_antisymm (closure_mono (image_mono <| by simp)) ((closure_le _).mpr ?_)
  have : univ = {i | 1 < f (v i)} ∪ {i | f (v i) < 1} := by ext i; simp [(hf i).symm]
  rw [this, image_union, union_subset_iff]
  refine ⟨le_trans ?_ (le_closure_toSubmonoid (v '' IsMulIndecomposable.baseOf v f)), ?_⟩
  · simp [Submonoid.closure_image_isMulIndecomposable_baseOf]
  · let f' : G →* S := invMonoidHom.comp f
    have h₁ : (invMonoidHom ∘ v) '' IsMulIndecomposable.baseOf v f' =
        v '' IsMulIndecomposable.baseOf v f := by
      rw [image_comp, IsMulIndecomposable.image_baseOf_inv_comp_eq v hv_inv f, image_comp,
        ← image_comp]
      simp
    have h₂ : v '' {i | f (v i) < 1} = v '' {i | 1 < f' (v i)} := by simp [f']
    rw [h₂, ← h₁, image_comp, coe_invMonoidHom, image_inv_eq_inv, closure_inv]
    refine le_trans ?_ (le_closure_toSubmonoid (v '' IsMulIndecomposable.baseOf v f'))
    simp [Submonoid.closure_image_isMulIndecomposable_baseOf]

namespace IsMulIndecomposable

@[to_additive]
lemma pairwise_div_notMem_range [InvolutiveInv ι]
    (v : ι → G)
    (hv_one : ∀ i, v i ≠ 1)
    (hv_inv : ∀ i, v i⁻¹ = (v i)⁻¹)
    (s t : Set ι)
    (hst : s ⊆ {i | IsMulIndecomposable v t i})
    (hv_t : ∀ i, i ∈ t ∨ i⁻¹ ∈ t) :
    s.Pairwise fun i j ↦ v i / v j ∉ range v := by
  have h_sub : s ⊆ t := hst.trans (IsMulIndecomposable.subset _ _)
  intro i hi j hj hne
  by_contra! ⟨k, hk⟩
  rcases hv_t k with hk' | hk'
  · suffices ¬ IsMulIndecomposable v t i from this (hst hi)
    simp only [IsMulIndecomposable, hv_one, or_self, imp_false, not_and, not_forall, not_not]
    exact fun _ ↦ ⟨k, hk', j, h_sub hj, by simp [hk]⟩
  · suffices ¬ IsMulIndecomposable v t j from this (hst hj)
    simp only [IsMulIndecomposable, hv_one, or_self, imp_false, not_and, not_forall, not_not]
    exact fun _ ↦ ⟨k⁻¹, hk', i, h_sub hi, by simp [hv_inv, hk]⟩

@[to_additive]
lemma pairwise_div_notMem_range' [InvolutiveInv ι] [CommGroup S] [IsOrderedMonoid S]
    (v : ι → G) (hv_inv : ∀ i, v i⁻¹ = (v i)⁻¹)
    (f : G →* S) (hf : ∀ i, f (v i) ≠ 1)
    (s : Set ι) (hst : s ⊆ {j | IsMulIndecomposable v {i | 1 < f (v i)} j}) :
    s.Pairwise fun i j ↦ v i / v j ∉ range v := by
  have hv_one : ∀ i, v i ≠ 1 := fun i ↦ by contrapose! hf; exact ⟨i, by simp [hf]⟩
  apply pairwise_div_notMem_range v hv_one hv_inv s {i | 1 < f (v i)} hst fun i ↦ ?_
  simpa [hv_inv] using (hf i).symm

@[to_additive]
lemma pairwise_baseOf_div_notMem [InvolutiveInv ι] [CommGroup S] [IsOrderedMonoid S]
    (v : ι → G) (hv_inv : ∀ i, v i⁻¹ = (v i)⁻¹)
    (f : G →* S) (hf : ∀ i, f (v i) ≠ 1) :
    (baseOf v f).Pairwise fun i j ↦ v i / v j ∉ range v :=
  pairwise_div_notMem_range' v hv_inv f hf (baseOf v f) (.refl _)

set_option linter.style.whitespace false in -- manual alignment is not recognised
@[to_additive]
lemma mem_or_inv_mem_closure_baseOf [Finite ι] [InvolutiveInv ι] [CommGroup S] [IsOrderedMonoid S]
    (v : ι → G)
    (f : G →* S) (i : ι) (hi : f (v i) ≠ 1) (hi' : v i⁻¹ = (v i)⁻¹) :
     v i    ∈ Submonoid.closure (v '' baseOf v f) ∨
    (v i)⁻¹ ∈ Submonoid.closure (v '' baseOf v f) := by
  rw [Submonoid.closure_image_isMulIndecomposable_baseOf v f]
  rcases lt_or_gt_of_ne hi with hj | hj
  · right
    exact Submonoid.subset_closure ⟨i⁻¹, by simpa [hi']⟩
  · left
    exact Submonoid.subset_closure ⟨i, by simpa⟩

end IsMulIndecomposable

@[to_additive]
lemma Submonoid.mem_closure_image_one_lt_iff [CommMonoid S] [IsOrderedCancelMonoid S]
    (v : ι → M) (f : M →* S) (i : ι) (hv_one : v i ≠ 1) :
    v i ∈ closure (v '' {i | 1 < f (v i)}) ↔ 1 < f (v i) := by
  refine ⟨fun hi ↦ ?_, fun hi ↦ subset_closure <| mem_image_of_mem v hi⟩
  suffices v i = 1 ∨ 1 < f (v i) from this.resolve_left hv_one
  refine closure_induction (by aesop) (by simp) (fun x y _ _ hx hy ↦ ?_) hi
  rcases hx with rfl | hx; · simpa
  rcases hy with rfl | hy; · right; simpa
  right
  simpa only [map_mul] using Left.one_lt_mul hx hy

@[to_additive]
lemma Submonoid.apply_ne_one_of_mem_or_inv_mem_closure
    [InvolutiveInv ι] [CommGroup S] [IsOrderedMonoid S]
    (v : ι → G)
    (f : G →* S)
    (s : Set ι)
    (hf : ∀ i ∈ s, 1 < f (v i))
    (i : ι) (hv_one : v i ≠ 1) (hv_inv : v i⁻¹ = (v i)⁻¹)
    (hsp : v i ∈ closure (v '' s) ∨ (v i)⁻¹ ∈ closure (v '' s)) :
    f (v i) ≠ 1 := by
  wlog hi : v i ∈ closure (v '' s)
  · rcases hsp with hi' | hi'; · contradiction
    simpa [hv_inv] using this v f s hf i⁻¹ (by simpa [hv_inv]) (by simp [hv_inv])
      (by left; simpa [hv_inv]) (by simpa [hv_inv])
  suffices v i ≠ 1 → 1 < f (v i) from (this hv_one).ne'
  refine closure_induction (by aesop) (by simp) (fun x y _ _ hx hy _ ↦ ?_) hi
  rcases eq_or_ne x 1 with rfl | hx'; · grind
  rcases eq_or_ne y 1 with rfl | hy'; · grind
  simpa using lt_mul_of_lt_of_one_lt (hx hx') (hy hy')

open Submonoid in
@[to_additive]
lemma IsMulIndecomposable.apply_ne_one_iff_mem_closure
    [Finite ι] [InvolutiveInv ι] [CommGroup S] [IsOrderedMonoid S]
    (v : ι → G) (f : G →* S) (i : ι) (hi : v i ≠ 1) (hi' : v i⁻¹ = (v i)⁻¹) :
    f (v i) ≠ 1 ↔ v i ∈ closure (v '' baseOf v f) ∨
                 (v i)⁻¹ ∈ closure (v '' baseOf v f) :=
  ⟨fun h ↦ mem_or_inv_mem_closure_baseOf v f i h hi',
    apply_ne_one_of_mem_or_inv_mem_closure v f (baseOf v f) (baseOf_subset_one_lt v f) i hi hi'⟩
