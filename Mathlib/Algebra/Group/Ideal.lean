/-
Copyright (c) 2025 Dexin Zhang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Dexin Zhang
-/
import Mathlib.Algebra.Order.Monoid.Canonical.Defs
import Mathlib.GroupTheory.GroupAction.SubMulAction
import Mathlib.Order.WellFoundedSet

/-!
# Semigroup ideals

This file defines (left) semigroup ideals (also called monoid ideals sometimes), which are sets `s`
in a semigroup such that `a * b ∈ s` whenever `b ∈ s`. Note that semigroup ideals are different from
ring ideals, where a ring ideal must also be an additive submonoid of the ring.

## Main definitions

* `SemigroupIdeal`: a (left) semigroup ideal in a semigroup `M` is a set `s` such that `a * b ∈ s`
  whenever `b ∈ s`.
* `SemigroupIdeal.closure`: the semigroup ideal generated by a set `s`.
* `SemigroupIdeal.FG`: a semigroup ideal is finitely generated if it is generated by a finite set.

## Main results

* In a canonically ordered and well-quasi-ordered monoid, any semigroup ideal is finitely generated,
  and the semigroup ideals satisfy the ascending chain condition.

## References

* [Samuel Eilenberg and M. P. Schützenberger, *Rational Sets in Commutative Monoids*][eilenberg1969]
-/

open Set Pointwise

/-- A (left) semigroup ideal in a semigroup `M` is a set `s` such that `a * b ∈ s` whenever
`b ∈ s`. -/
@[to_additive /-- A (left) additive semigroup ideal in an additive semigroup `M` is a set `s` such
that `a + b ∈ s` whenever `b ∈ s`. -/]
abbrev SemigroupIdeal (M : Type*) [Semigroup M] :=
  SubMulAction M M

namespace SemigroupIdeal

variable {M : Type*}

section Semigroup

variable [Semigroup M]

@[to_additive]
protected theorem mul_mem (I : SemigroupIdeal M) (x : M) {y : M} : y ∈ I → x * y ∈ I :=
  SubMulAction.smul_mem I x

/-- The semigroup ideal generated by a set `s`, defined as `s ∪ Set.univ * s`. -/
@[to_additive /-- The additive semigroup ideal generated by a set `s`, defined as
`s ∪ Set.univ + s`. -/]
def closure (s : Set M) : SemigroupIdeal M where
  carrier := s ∪ univ * s
  smul_mem' x y := by
    rintro (hy | ⟨y, -, z, hz, rfl⟩)
    · exact Or.inr (mul_mem_mul (mem_univ _) hy)
    · simpa [← mul_assoc] using Or.inr (mul_mem_mul (mem_univ _) hz)

@[to_additive]
theorem coe_closure {s : Set M} : (closure s : Set M) = s ∪ univ * s := rfl

@[to_additive]
theorem mem_closure {x : M} {s} : x ∈ closure s ↔ x ∈ s ∨ ∃ y, ∃ z ∈ s, y * z = x := by
  rw [← SetLike.mem_coe, coe_closure]
  simp [mem_mul]

@[to_additive]
theorem closure_mono {s₁ s₂ : Set M} : s₁ ⊆ s₂ → closure s₁ ≤ closure s₂ := by
  rintro h y (hy | ⟨x, -, y, hy, rfl⟩)
  · exact Or.inl (h hy)
  · exact Or.inr ⟨x, mem_univ _, y, h hy, rfl⟩

@[to_additive]
theorem subset_closure {s} : s ⊆ (closure s : Set M) :=
  fun _ hx => Or.inl hx

@[to_additive]
theorem mem_closure_of_mem {s : Set M} {x} : x ∈ s → x ∈ closure s :=
  fun hx => subset_closure hx

@[to_additive]
theorem closure_le {s} {I : SemigroupIdeal M} :
    closure s ≤ I ↔ s ⊆ (I : Set M) := by
  constructor
  · intro h
    apply subset_closure.trans
    rwa [SetLike.coe_subset_coe]
  · intro hs x hx
    simp only [mem_closure] at hx
    rcases hx with hx | ⟨y, z, hz, rfl⟩
    · exact hs hx
    · exact SemigroupIdeal.mul_mem _ _ (hs hz)

/-- A semigroup ideal is finitely generated if it is generated by a finite set. -/
@[to_additive /-- An additive semigroup ideal is finitely generated if it is generated by a finite
set. -/]
def FG (I : SemigroupIdeal M) :=
  ∃ (s : Set M), s.Finite ∧ I = closure s

@[to_additive]
theorem fg_iff {I : SemigroupIdeal M} : I.FG ↔ ∃ (s : Finset M), I = closure s :=
  exists_finite_iff_finset

end Semigroup

section Monoid

variable [Monoid M]

/-- In a monoid, the semigroup ideal generated by `s` is just `univ * s`. -/
@[to_additive /-- In an additive monoid, the semigroup ideal generated by `s` is just
`univ + s`. -/]
theorem coe_closure' {s : Set M} : (closure s : Set M) = univ * s := by
  rw [coe_closure, union_eq_right]
  exact fun x hx => ⟨1, mem_univ 1, x, hx, by simp⟩

@[to_additive]
theorem mem_closure' {s : Set M} {x} : x ∈ closure s ↔ ∃ y, ∃ z ∈ s, y * z = x := by
  rw [← SetLike.mem_coe, coe_closure']
  simp [mem_mul]

end Monoid

section WellQuasiOrderedLE

variable [CommMonoid M] [PartialOrder M] [WellQuasiOrderedLE M] [CanonicallyOrderedMul M]

/-- In a canonically ordered and well-quasi-ordered monoid, any semigroup ideal is finitely
generated. -/
@[to_additive /-- In a canonically ordered and well-quasi-ordered additive monoid, any semigroup
ideal is finitely generated. -/]
theorem fg_of_wellQuasiOrderedLE (I : SemigroupIdeal M) : I.FG := by
  have hpwo := isPWO_of_wellQuasiOrderedLE { x | x ∈ I }
  refine ⟨_, (setOf_minimal_antichain _).finite_of_partiallyWellOrderedOn
    (hpwo.mono (setOf_minimal_subset _)), ?_⟩
  ext x
  simp only [mem_closure', SetLike.setOf_mem_eq, SetLike.mem_coe, mem_setOf_eq]
  constructor
  · intro hx
    rcases hpwo.exists_le_minimal hx with ⟨z, hz, hz'⟩
    rw [le_iff_exists_mul'] at hz
    rcases hz with ⟨y, rfl⟩
    exact ⟨y, z, hz', rfl⟩
  · rintro ⟨y, z, hz, rfl⟩
    apply SubMulAction.smul_mem
    exact hz.1

/-- In a canonically ordered and well-quasi-ordered monoid, the semigroup ideals satisfy the
ascending chain condition. -/
@[to_additive /-- A canonically ordered and well-quasi-ordered additive monoid, the semigroup ideals
satisfy the ascending chain condition. -/]
instance : WellFoundedGT (SemigroupIdeal M) := by
  rw [wellFoundedGT_iff_monotone_chain_condition]
  intro f
  let I : SemigroupIdeal M :=
    { carrier := ⋃ i, f i
      smul_mem' x y hy := by
        simp only [mem_iUnion, SetLike.mem_coe] at hy ⊢
        rcases hy with ⟨i, hi⟩
        exact ⟨i, SubMulAction.smul_mem _ _ hi⟩ }
  have hI : ∀ i, f i ≤ I := fun i => subset_iUnion (SetLike.coe ∘ f) i
  rcases fg_iff.1 (fg_of_wellQuasiOrderedLE I) with ⟨s, hI'⟩
  have hs : ∀ x ∈ s, ∃ i, x ∈ f i := by
    intro x hx
    apply subset_closure (s := (s : Set M)) at hx
    rw [SetLike.mem_coe, ← hI'] at hx
    exact mem_iUnion.1 hx
  choose! g hg using hs
  exists s.sup g
  intro n hn
  apply (f.mono hn).antisymm
  apply (hI n).trans
  intro x hx
  rw [hI', mem_closure'] at hx
  rcases hx with ⟨y, z, hz, rfl⟩
  exact SemigroupIdeal.mul_mem _ _ (f.mono (Finset.le_sup hz) (hg _ hz))

end WellQuasiOrderedLE

end SemigroupIdeal
