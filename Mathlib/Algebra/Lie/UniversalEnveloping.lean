/-
Copyright (c) 2020 Oliver Nash. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Oliver Nash
-/
import Mathlib.Algebra.Lie.OfAssociative
import Mathlib.Algebra.RingQuot
import Mathlib.LinearAlgebra.TensorAlgebra.Basic

#align_import algebra.lie.universal_enveloping from "leanprover-community/mathlib"@"32b08ef840dd25ca2e47e035c5da03ce16d2dc3c"

/-!
# Universal enveloping algebra

Given a commutative ring `R` and a Lie algebra `L` over `R`, we construct the universal
enveloping algebra of `L`, together with its universal property.

## Main definitions

  * `UniversalEnvelopingAlgebra`: the universal enveloping algebra, endowed with an
    `R`-algebra structure.
  * `UniversalEnvelopingAlgebra.Î¹`: the Lie algebra morphism from `L` to its universal
    enveloping algebra.
  * `UniversalEnvelopingAlgebra.lift`: given an associative algebra `A`, together with a Lie
    algebra morphism `f : L â†’â‚—â…Râ† A`, `lift R L f : UniversalEnvelopingAlgebra R L â†’â‚[R] A` is the
    unique morphism of algebras through which `f` factors.
  * `UniversalEnvelopingAlgebra.Î¹_comp_lift`: states that the lift of a morphism is indeed part
    of a factorisation.
  * `UniversalEnvelopingAlgebra.lift_unique`: states that lifts of morphisms are indeed unique.
  * `UniversalEnvelopingAlgebra.hom_ext`: a restatement of `lift_unique` as an extensionality
    lemma.

## Tags

lie algebra, universal enveloping algebra, tensor algebra
-/


universe uâ‚ uâ‚‚ uâ‚ƒ

variable (R : Type uâ‚) (L : Type uâ‚‚)

variable [CommRing R] [LieRing L] [LieAlgebra R L]

local notation "Î¹â‚œ" => TensorAlgebra.Î¹ R

namespace UniversalEnvelopingAlgebra

/-- The quotient by the ideal generated by this relation is the universal enveloping algebra.

Note that we have avoided using the more natural expression:
| lie_compat (x y : L) : rel (Î¹â‚œ â…x, yâ†) â…Î¹â‚œ x, Î¹â‚œ yâ†
so that our construction needs only the semiring structure of the tensor algebra. -/
inductive Rel : TensorAlgebra R L â†’ TensorAlgebra R L â†’ Prop
  | lie_compat (x y : L) : Rel (Î¹â‚œ â…x, yâ† + Î¹â‚œ y * Î¹â‚œ x) (Î¹â‚œ x * Î¹â‚œ y)
#align universal_enveloping_algebra.rel UniversalEnvelopingAlgebra.Rel

end UniversalEnvelopingAlgebra

/-- The universal enveloping algebra of a Lie algebra. -/
def UniversalEnvelopingAlgebra :=
  RingQuot (UniversalEnvelopingAlgebra.Rel R L)
#align universal_enveloping_algebra UniversalEnvelopingAlgebra

namespace UniversalEnvelopingAlgebra

-- Porting note(https://github.com/leanprover-community/mathlib4/issues/5020): the next three
-- instances were derived automatically in mathlib3.

instance instInhabited : Inhabited (UniversalEnvelopingAlgebra R L) :=
  inferInstanceAs (Inhabited (RingQuot (UniversalEnvelopingAlgebra.Rel R L)))
#align universal_enveloping_algebra.inhabited UniversalEnvelopingAlgebra.instInhabited

instance instRing : Ring (UniversalEnvelopingAlgebra R L) :=
  inferInstanceAs (Ring (RingQuot (UniversalEnvelopingAlgebra.Rel R L)))
#align universal_enveloping_algebra.ring UniversalEnvelopingAlgebra.instRing

instance instAlgebra : Algebra R (UniversalEnvelopingAlgebra R L) :=
  inferInstanceAs (Algebra R (RingQuot (UniversalEnvelopingAlgebra.Rel R L)))
#align universal_enveloping_algebra.algebra UniversalEnvelopingAlgebra.instAlgebra


/-- The quotient map from the tensor algebra to the universal enveloping algebra as a morphism of
associative algebras. -/
def mkAlgHom : TensorAlgebra R L â†’â‚[R] UniversalEnvelopingAlgebra R L :=
  RingQuot.mkAlgHom R (Rel R L)
#align universal_enveloping_algebra.mk_alg_hom UniversalEnvelopingAlgebra.mkAlgHom

variable {L}

/-- The natural Lie algebra morphism from a Lie algebra to its universal enveloping algebra. -/
@[simps!] -- Porting note: added
def Î¹ : L â†’â‚—â…Râ† UniversalEnvelopingAlgebra R L :=
  { (mkAlgHom R L).toLinearMap.comp Î¹â‚œ with
    map_lie' := fun {x y} => by
      suffices mkAlgHom R L (Î¹â‚œ â…x, yâ† + Î¹â‚œ y * Î¹â‚œ x) = mkAlgHom R L (Î¹â‚œ x * Î¹â‚œ y) by
        rw [AlgHom.map_mul] at this; simp [LieRing.of_associative_ring_bracket, â† this]
      exact RingQuot.mkAlgHom_rel _ (Rel.lie_compat x y) }
      -- ğŸ‰ no goals
#align universal_enveloping_algebra.Î¹ UniversalEnvelopingAlgebra.Î¹

variable {A : Type uâ‚ƒ} [Ring A] [Algebra R A] (f : L â†’â‚—â…Râ† A)

/-- The universal property of the universal enveloping algebra: Lie algebra morphisms into
associative algebras lift to associative algebra morphisms from the universal enveloping algebra. -/
def lift : (L â†’â‚—â…Râ† A) â‰ƒ (UniversalEnvelopingAlgebra R L â†’â‚[R] A) where
  toFun f :=
    RingQuot.liftAlgHom R
      âŸ¨TensorAlgebra.lift R (f : L â†’â‚—[R] A), by
        intro a b h; induction' h with x y
        -- âŠ¢ â†‘(â†‘(TensorAlgebra.lift R) â†‘f) a = â†‘(â†‘(TensorAlgebra.lift R) â†‘f) b
                     -- âŠ¢ â†‘(â†‘(TensorAlgebra.lift R) â†‘f) (â†‘Î¹â‚œ â…x, yâ† + â†‘Î¹â‚œ y * â†‘Î¹â‚œ x) = â†‘(â†‘(TensorAlgeb â€¦
        simp only [LieRing.of_associative_ring_bracket, map_add, TensorAlgebra.lift_Î¹_apply,
          LieHom.coe_toLinearMap, LieHom.map_lie, map_mul, sub_add_cancel]âŸ©
  invFun F := (F : UniversalEnvelopingAlgebra R L â†’â‚—â…Râ† A).comp (Î¹ R)
  left_inv f := by
    ext
    -- âŠ¢ â†‘((fun F => LieHom.comp (AlgHom.toLieHom F) (Î¹ R)) ((fun f => â†‘(RingQuot.lif â€¦
    -- Porting note: was
    -- simp only [Î¹, mkAlgHom, TensorAlgebra.lift_Î¹_apply, LieHom.coe_toLinearMap,
    --   LinearMap.toFun_eq_coe, LinearMap.coe_comp, LieHom.coe_comp, AlgHom.coe_toLieHom,
    --   LieHom.coe_mk, Function.comp_apply, AlgHom.toLinearMap_apply,
    --   RingQuot.liftAlgHom_mkAlgHom_apply]
    simp only [LieHom.coe_comp, Function.comp_apply, AlgHom.coe_toLieHom,
      UniversalEnvelopingAlgebra.Î¹_apply, mkAlgHom]
    rw [RingQuot.liftAlgHom_mkAlgHom_apply]
    -- âŠ¢ â†‘(â†‘(TensorAlgebra.lift R) â†‘f) (â†‘Î¹â‚œ xâœ) = â†‘f xâœ
    simp only [TensorAlgebra.lift_Î¹_apply, LieHom.coe_toLinearMap]
    -- ğŸ‰ no goals
  right_inv F := by
    apply RingQuot.ringQuot_ext'
    -- âŠ¢ AlgHom.comp ((fun f => â†‘(RingQuot.liftAlgHom R) { val := â†‘(TensorAlgebra.lif â€¦
    ext
    -- âŠ¢ â†‘(LinearMap.comp (AlgHom.toLinearMap (AlgHom.comp ((fun f => â†‘(RingQuot.lift â€¦
    -- Porting note: was
    -- simp only [Î¹, mkAlgHom, TensorAlgebra.lift_Î¹_apply, LieHom.coe_toLinearMap,
    --   LinearMap.toFun_eq_coe, LinearMap.coe_comp, LieHom.coe_linearMap_comp,
    --   AlgHom.comp_toLinearMap, Function.comp_apply, AlgHom.toLinearMap_apply,
    --   RingQuot.liftAlgHom_mkAlgHom_apply, AlgHom.coe_toLieHom, LieHom.coe_mk]
    simp [mkAlgHom]
    -- ğŸ‰ no goals
#align universal_enveloping_algebra.lift UniversalEnvelopingAlgebra.lift

@[simp]
theorem lift_symm_apply (F : UniversalEnvelopingAlgebra R L â†’â‚[R] A) :
    (lift R).symm F = (F : UniversalEnvelopingAlgebra R L â†’â‚—â…Râ† A).comp (Î¹ R) :=
  rfl
#align universal_enveloping_algebra.lift_symm_apply UniversalEnvelopingAlgebra.lift_symm_apply

@[simp]
theorem Î¹_comp_lift : lift R f âˆ˜ Î¹ R = f :=
  funext <| LieHom.ext_iff.mp <| (lift R).symm_apply_apply f
#align universal_enveloping_algebra.Î¹_comp_lift UniversalEnvelopingAlgebra.Î¹_comp_lift

-- Porting note: moved `@[simp]` to the next theorem (LHS simplifies)
theorem lift_Î¹_apply (x : L) : lift R f (Î¹ R x) = f x := by
  rw [â† Function.comp_apply (f := lift R f) (g := Î¹ R) (x := x), Î¹_comp_lift]
  -- ğŸ‰ no goals
#align universal_enveloping_algebra.lift_Î¹_apply UniversalEnvelopingAlgebra.lift_Î¹_apply

@[simp]
theorem lift_Î¹_apply' (x : L) :
    lift R f ((UniversalEnvelopingAlgebra.mkAlgHom R L) (Î¹â‚œ x)) = f x := by
  simpa using lift_Î¹_apply R f x
  -- ğŸ‰ no goals

theorem lift_unique (g : UniversalEnvelopingAlgebra R L â†’â‚[R] A) : g âˆ˜ Î¹ R = f â†” g = lift R f := by
  refine' Iff.trans _ (lift R).symm_apply_eq
  -- âŠ¢ â†‘g âˆ˜ â†‘(Î¹ R) = â†‘f â†” â†‘(lift R).symm g = f
  constructor <;> Â· intro h; ext; simp [â† h]
  -- âŠ¢ â†‘g âˆ˜ â†‘(Î¹ R) = â†‘f â†’ â†‘(lift R).symm g = f
                    -- âŠ¢ â†‘(lift R).symm g = f
                             -- âŠ¢ â†‘(â†‘(lift R).symm g) xâœ = â†‘f xâœ
                                  -- ğŸ‰ no goals
                    -- âŠ¢ â†‘g âˆ˜ â†‘(Î¹ R) = â†‘f
                             -- âŠ¢ (â†‘g âˆ˜ â†‘(Î¹ R)) xâœ = â†‘f xâœ
                                  -- ğŸ‰ no goals
#align universal_enveloping_algebra.lift_unique UniversalEnvelopingAlgebra.lift_unique

/-- See note [partially-applied ext lemmas]. -/
@[ext]
theorem hom_ext {gâ‚ gâ‚‚ : UniversalEnvelopingAlgebra R L â†’â‚[R] A}
    (h :
      (gâ‚ : UniversalEnvelopingAlgebra R L â†’â‚—â…Râ† A).comp (Î¹ R) =
        (gâ‚‚ : UniversalEnvelopingAlgebra R L â†’â‚—â…Râ† A).comp (Î¹ R)) :
    gâ‚ = gâ‚‚ :=
  have h' : (lift R).symm gâ‚ = (lift R).symm gâ‚‚ := by ext; simp [h]
                                                      -- âŠ¢ â†‘(â†‘(lift R).symm gâ‚) xâœ = â†‘(â†‘(lift R).symm gâ‚‚) xâœ
                                                           -- ğŸ‰ no goals
  (lift R).symm.injective h'
#align universal_enveloping_algebra.hom_ext UniversalEnvelopingAlgebra.hom_ext

end UniversalEnvelopingAlgebra
