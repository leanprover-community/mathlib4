/-
Copyright (c) 2025 Yaël Dillies, Patrick Luo. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yaël Dillies, Patrick Luo
-/
import Mathlib.Algebra.Group.Irreducible.Defs
import Mathlib.Algebra.Group.Submonoid.BigOperators
import Mathlib.GroupTheory.Finiteness

/-!
# An affine monoid with no non-trivial unit is generated by its irreducible elements

This file proves that an additive cancellative monoid with no non-trivial unit unit is generated by
its irreducible elements.
-/

variable {M : Type*} {S : Set M}

section CommMonoid
variable [CommMonoid M] [Subsingleton Mˣ]

/-- Any set `S` inside a salient monoid contains the irreducible elements of the submonoid it
generates. -/
@[to_additive "Any set `S` inside a salient monoid contains the irreducible elements of the
submonoid it generates."]
lemma irreducible_mem_submonoidClosure_subset : {p ∈ Submonoid.closure S | Irreducible p} ⊆ S := by
  refine fun x hx ↦
      Submonoid.closure_induction (s := S) (motive := fun x _ ↦ (Irreducible x → x ∈ S))
      (fun _ hx _ ↦ hx) (by simp) (fun a b _ _ ha hb h ↦ ?_) hx.1 hx.2
  obtain rfl | rfl := h.eq_one_or_eq_one <;> simp_all

/-- Irreducible elements lie in all sets generating a salient monoid. -/
@[to_additive "Irreducible elements lie in all sets generating a salient monoid."]
lemma irreducible_subset_of_submonoidClosure_eq_top (hS : Submonoid.closure S = ⊤) :
    {p | Irreducible p} ⊆ S := by
  simpa [hS] using irreducible_mem_submonoidClosure_subset (S := S)

/-- A finitely generated submonoid of a salient monoid has finitely many irreducible elements. -/
@[to_additive
"A finitely generated salient submonoid of a salient monoid has finitely many irreducible
elements."]
lemma Submonoid.FG.finite_irreducible_mem_submonoidClosure {S : Submonoid M} :
    S.FG → {p ∈ S | Irreducible p}.Finite := by
  rintro ⟨T, hT⟩; exact T.finite_toSet.subset <| hT ▸ irreducible_mem_submonoidClosure_subset

variable [Monoid.FG M]

/-- A finitely generated salient monoid has finitely many irreducible elements. -/
@[to_additive "A finitely generated salient monoid has finitely many irreducible elements."]
lemma finite_irreducible : {p : M | Irreducible p}.Finite := by
  simpa using Monoid.FG.fg_top.finite_irreducible_mem_submonoidClosure

end CommMonoid

section CancelCommMonoid
variable [CancelCommMonoid M] [Monoid.FG M] [Subsingleton Mˣ] {S : Set M}

/-- A finitely generated cancellative salient monoid is generated by its (finitely many) irreducible
 elements. -/
@[to_additive (attr := simp)
"A finitely generated cancellative salient monoid is generated by its (finitely many) irreducible
elements."]
lemma Submonoid.closure_irreducible : Submonoid.closure {p : M | Irreducible p} = ⊤ := by
  classical
  -- Pick a minimal set `S` generating `M`.
  obtain ⟨S, hSgen, hSmax⟩ := Submonoid.exists_minimal_closure_eq_top M
  -- We claim that `S` is the set of irreducible elements of `M`.
  convert hSgen
  -- We already know that `S` contains all irreducible elements...
  refine (irreducible_subset_of_submonoidClosure_eq_top hSgen).antisymm fun r hrS ↦ ?_
  -- So let us for contradiction assume that `r ∈ S` is reducible.
  by_contra hrirred
  -- If `r = 1`, then `S` isn't minimal. Contradiction.
  obtain rfl | hr₀ := eq_or_ne r 1
  · simpa using hSmax (y := S \ {1}) (by simpa) Finset.sdiff_subset hrS
  -- Else find `a`, `b` non-units such that `a * b = r`.
  simp only [irreducible_iff, Set.mem_setOf_eq, not_and, not_forall, Classical.not_imp,
    not_or] at hrirred
  obtain ⟨a, b, hr, ha, hb⟩ := hrirred <| by simpa
  -- Write `a = ∏ s ∈ S, s ^ m s`, `b = ∏ s ∈ S, s ^ n s` for some coefficients `m`, `n`.
  obtain ⟨m, -, hm⟩ := Submonoid.mem_closure_finset (x := a).mp (by rw [hSgen]; trivial)
  obtain ⟨n, -, hn⟩ := Submonoid.mem_closure_finset (x := b).mp (by rw [hSgen]; trivial)
  -- Single out the `r` term in the two products.
  replace hm : a = r ^ m r * ∏ s ∈ S \ {r}, s ^ m s := by
    rw [← hm, ← Finset.prod_sdiff <| Finset.singleton_subset_iff.2 hrS, Finset.prod_singleton,
      mul_comm]
  replace hn : b = r ^ n r * ∏ s ∈ S \ {r}, s ^ n s := by
    rw [← hn, ← Finset.prod_sdiff <| Finset.singleton_subset_iff.2 hrS, Finset.prod_singleton,
      mul_comm]
  -- Multiply the two equations together to write `r` as a power (namely `m r + n r`) of itself
  -- times a product of elements of `S \ {r}` (namely `∏ s ∈ S \ {r}, s ^ (m s + n s)`).
  have hr' : r = r ^ (m r + n r) * (∏ s ∈ S \ {r}, s ^ m s) * ∏ s ∈ S \ {r}, s ^ n s := by
    rwa [pow_add, mul_assoc, mul_assoc, ← mul_assoc (r ^ n r), mul_comm (r ^ n r) _, mul_assoc,
      ← hn, ← mul_assoc, ← hm]
  -- Case on whether that power is `0`, `1` or at least `2`.
  match hr : m r + n r with
  -- If that power is `0`, then `r` can be written as a product of elements of `S \ {r}` and `S` was
  -- not minimal. Contradiction.
  | 0 =>
    have : ({r} : Set M) ⊆ closure (S \ {r}) := by
      simp only [hr, pow_zero, one_mul] at hr'
      rw [hr', Set.singleton_subset_iff]
      refine mul_mem ?_ ?_ <;> refine prod_mem _ fun s hs ↦ pow_mem (subset_closure ?_) _ <;>
        rw [← hr'] <;> simpa using hs
    specialize hSmax (y := S \ {r}) (by simp [Submonoid.closure_sdiff_eq_closure this, hSgen])
      Finset.sdiff_subset
    simpa using hSmax hrS
  -- Assume that power is `1`.
  | 1 =>
    -- By cancelling on both sides we get `∏ s ∈ S \ {r}, s ^ (m s + n s) = 1`.
    simp only [hr, pow_one, mul_assoc, eq_comm (a := r), mul_eq_left, LeftCancelMonoid.mul_eq_one,
      Finset.prod_eq_one_iff] at hr'
    -- This means, by saliency of `M` that `∏ s ∈ S \ {r}, s ^ m s = ∏ s ∈ S \ {r}, s ^ n s = 1`.
    -- Furthermore, `m r + n r = 1` implies that one of `m r` or `n r` is zero.
    -- Therefore one of `a` or `b` is `1`, contradicting the fact that they are non-units.
    obtain h | h : m r = 0 ∨ n r = 0 := by omega
    · obtain rfl : a = 1 := by simpa [h, Finset.prod_eq_one hr'.1] using hm
      simp at ha
    · obtain rfl : b = 1 := by simpa [h, Finset.prod_eq_one hr'.2] using hn
      simp at hb
  -- If that power is at least `2`, then we can write `1` as `r` times something.
  -- Since `M` is salient, this means that `r = 1`. Contradiction.
  | N + 2 => simp [eq_comm (a := (1 : M)), hr, hr₀, pow_add, mul_assoc, mul_left_comm] at hr'

end CancelCommMonoid
