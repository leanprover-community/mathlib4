/-
Copyright (c) 2024 María Inés de Frutos Fernández. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: María Inés de Frutos Fernández, Xavier Généreux
-/
import Mathlib.Algebra.Algebra.Equiv
import Mathlib.Algebra.Algebra.NonUnitalHom
import Mathlib.Data.Finsupp.Basic
import Mathlib.LinearAlgebra.FreeModule.Basic

/-!

This file presents a skewed version of `Mathlib.Algebra.MonoidAlgebra.Basic`.

We define `SkewMonoidAlgebra k G` attached with a skewed convolution product.
Here, the product of two elements `f g : SkewMonoidAlgebra k G` is the finitely supported
function whose value at `a` is the sum of `f x * (x • g y)` over all pairs `x, y`
such that `x * y = a`.

The associativity of the skewed multiplication depends on the `[MulSemiringAction G k]` instance.
In particular, this means that unlike in `Mathlib.Algebra.MonoidAlgebra.Basic`, `G` will
need to be a monoid for most of our uses.

TODO: Add lemmas that show `IsSMulRegular.skewMonoidAlgebra` and
`IsSMulRegular.skewMonoidAlgebra_iff` as a consequence of
`SkewMonoidAlgebra.Module.free` and that this property is preserved under
a LinearEquiv. (See #10541 for discussion)
-/

noncomputable section

/-- The skew monoid algebra over a semiring `k` generated by the monoid `G`.
It is the type of finite formal `k`-linear combinations of terms of `G`,
endowed with a skewed convolution product. -/
structure SkewMonoidAlgebra (k : Type*) (G : Type*) [Zero k] where
  /-- Map **from** `G →₀ k`. -/
  ofFinsupp ::
  /-- Map **to** `G →₀ k`. -/
  toFinsupp : G →₀ k

open Function hiding Commute
namespace SkewMonoidAlgebra

universe u₁ u₂

variable {k : Type u₁} {G : Type u₂} {H : Type*} {R : Type*}

section AddCommMonoid

variable [AddCommMonoid k]

@[simp]
theorem eta (f : SkewMonoidAlgebra k G) : ofFinsupp f.toFinsupp = f := rfl

private irreducible_def add :
    SkewMonoidAlgebra k G → SkewMonoidAlgebra k G → SkewMonoidAlgebra k G
  | ⟨a⟩, ⟨b⟩ => ⟨a + b⟩

private irreducible_def smul {S : Type*} [SMulZeroClass S k] :
    S → SkewMonoidAlgebra k G → SkewMonoidAlgebra k G
  | s, ⟨b⟩ => ⟨s • b⟩

instance zero : Zero (SkewMonoidAlgebra k G) := ⟨⟨0⟩⟩

instance add' : Add (SkewMonoidAlgebra k G) := ⟨add⟩

instance smulZeroClass {S : Type*} [SMulZeroClass S k] :
    SMulZeroClass S (SkewMonoidAlgebra k G) where
  smul s f := smul s f
  smul_zero a := by simp only [smul_def]; exact congr_arg ofFinsupp (smul_zero a)

@[simp]
theorem ofFinsupp_zero : (⟨0⟩ : SkewMonoidAlgebra k G) = 0 := rfl

@[simp]
theorem ofFinsupp_add {a b} : (⟨a + b⟩ : SkewMonoidAlgebra k G) = ⟨a⟩ + ⟨b⟩ :=
  show _ = add _ _ by rw [add_def]

@[simp]
theorem ofFinsupp_smul {S : Type*} [SMulZeroClass S k] (a : S) (b : G →₀ k) :
    (⟨a • b⟩ : SkewMonoidAlgebra k G) = (a • ⟨b⟩ : SkewMonoidAlgebra k G) :=
  show _ = smul _ _ by rw [smul_def]

@[simp]
theorem toFinsupp_zero : (0 : SkewMonoidAlgebra k G).toFinsupp = 0 := rfl

@[simp]
theorem toFinsupp_add (a b : SkewMonoidAlgebra k G) :
    (a + b).toFinsupp = a.toFinsupp + b.toFinsupp := by
  cases a
  cases b
  rw [← ofFinsupp_add]

@[simp]
theorem toFinsupp_smul {S : Type*} [SMulZeroClass S k] (a : S) (b : SkewMonoidAlgebra k G) :
    (a • b).toFinsupp = a • b.toFinsupp := by
  cases b
  rw [← ofFinsupp_smul]

theorem _root_.IsSMulRegular.skewMonoidAlgebra {S : Type*} [Monoid S] [DistribMulAction S k] {a : S}
    (ha : IsSMulRegular k a) : IsSMulRegular (SkewMonoidAlgebra k G) a
  | ⟨_x⟩, ⟨_y⟩, h => by
    simp only [← ofFinsupp_smul] at h
    exact congr_arg _ <| ha.finsupp (ofFinsupp.inj (h))

theorem toFinsupp_injective :
    Function.Injective (toFinsupp : SkewMonoidAlgebra k G → Finsupp _ _) :=
  fun ⟨_x⟩ ⟨_y⟩ => congr_arg _

@[simp]
theorem toFinsupp_inj {a b : SkewMonoidAlgebra k G} : a.toFinsupp = b.toFinsupp ↔ a = b :=
  toFinsupp_injective.eq_iff

theorem ofFinsupp_injective :
    Function.Injective (ofFinsupp : Finsupp _ _ → SkewMonoidAlgebra k G) :=
  fun _x _y => congr_arg toFinsupp

/-- A more convenient spelling of `SkewMonoidAlgebra.ofFinsupp.injEq` in terms of `Iff`. -/
theorem ofFinsupp_inj {a b} : (⟨a⟩ : SkewMonoidAlgebra k G) = ⟨b⟩ ↔ a = b :=
  ofFinsupp_injective.eq_iff

@[simp]
theorem toFinsupp_eq_zero {a : SkewMonoidAlgebra k G} : a.toFinsupp = 0 ↔ a = 0 := by
  rw [← toFinsupp_zero, toFinsupp_inj]

@[simp]
theorem ofFinsupp_eq_zero {a} : (⟨a⟩ : SkewMonoidAlgebra k G) = 0 ↔ a = 0 := by
  rw [← ofFinsupp_zero, ofFinsupp_inj]

instance inhabited : Inhabited (SkewMonoidAlgebra k G) := ⟨0⟩

instance nontrivial [Nontrivial k] [Nonempty G] :
    Nontrivial (SkewMonoidAlgebra k G) := Function.Injective.nontrivial ofFinsupp_injective

instance addCommMonoid : AddCommMonoid (SkewMonoidAlgebra k G) where
    __ := toFinsupp_injective.addCommMonoid _ toFinsupp_zero toFinsupp_add
      (fun _ _ => toFinsupp_smul _ _)
    toAdd  := SkewMonoidAlgebra.add'
    toZero := SkewMonoidAlgebra.zero
    nsmul  := (. • .)

instance isCancelAdd [IsCancelAdd k] : IsCancelAdd (SkewMonoidAlgebra k G) :=
  Function.Injective.isCancelAdd toFinsupp toFinsupp_injective toFinsupp_add

section Support

/-- For `f : SkewMonoidAlgebra k G`, `f.support` is the set of all `a ∈ G` such that
`f a ≠ 0`. -/
def support : SkewMonoidAlgebra k G → Finset G
  | ⟨p⟩ => p.support

@[simp]
theorem support_ofFinsupp (p) : support (⟨p⟩ : SkewMonoidAlgebra k G) = p.support := by
  rw [support]

theorem support_toFinsupp (p : SkewMonoidAlgebra k G) : p.toFinsupp.support = p.support := by
  rw [support]

@[simp]
theorem support_zero : (0 : SkewMonoidAlgebra k G).support = ∅ := rfl

@[simp]
theorem support_eq_empty {p} : p.support = ∅ ↔ (p : SkewMonoidAlgebra k G) = 0 := by
  rcases p with ⟨⟩
  simp only [support, Finsupp.support_eq_empty, ofFinsupp_eq_zero]

end Support

section Coeff

/-- `coeff f a` (often denoted `f.coeff a`) is the coefficient of `a` in `f`. -/
def coeff : SkewMonoidAlgebra k G → G → k
  | ⟨p⟩ => p

@[simp]
theorem coeff_ofFinsupp (p) : coeff (⟨p⟩ : SkewMonoidAlgebra k G) = p :=
  rfl

theorem coeff_injective : Injective (coeff : SkewMonoidAlgebra k G → G → k) := by
  rintro ⟨p⟩ ⟨q⟩
  simp only [coeff, DFunLike.coe_fn_eq, imp_self, ofFinsupp.injEq]

@[simp]
theorem coeff_inj (p q : SkewMonoidAlgebra k G) : p.coeff = q.coeff ↔ p = q :=
  coeff_injective.eq_iff

theorem toFinsupp_apply (f : SkewMonoidAlgebra k G) (g) : f.toFinsupp g = f.coeff g :=
  rfl

@[simp]
theorem coeff_zero (g : G) : coeff (0 : SkewMonoidAlgebra k G) g = 0 :=
  rfl

@[simp]
theorem mem_support_iff {f : SkewMonoidAlgebra k G} {a : G} : a ∈ f.support ↔ f.coeff a ≠ 0 := by
  rcases f with ⟨⟩
  simp only [coeff, support_ofFinsupp, Finsupp.mem_support_iff, ne_eq, implies_true]

theorem not_mem_support_iff {f : SkewMonoidAlgebra k G} {a : G} :
    a ∉ f.support ↔ f.coeff a = 0 := by
  simp only [mem_support_iff, ne_eq, not_not]

theorem ext_iff {p q : SkewMonoidAlgebra k G} : p = q ↔ ∀ n, coeff p n = coeff q n := by
  rcases p with ⟨f : G →₀ k⟩
  rcases q with ⟨g : G →₀ k⟩
  simpa [coeff] using DFunLike.ext_iff (f := f) (g := g)

@[ext]
theorem ext {p q : SkewMonoidAlgebra k G} : (∀ a, coeff p a = coeff q a) → p = q :=
  ext_iff.2

@[simp]
theorem coeff_add (p q : SkewMonoidAlgebra k G) (a : G) :
    coeff (p + q) a = coeff p a + coeff q a := by
  rcases p with ⟨⟩
  rcases q with ⟨⟩
  simp_rw [← ofFinsupp_add, coeff]
  exact Finsupp.add_apply _ _ _

@[simp]
theorem coeff_smul {S} [SMulZeroClass S k] (r : S) (p : SkewMonoidAlgebra k G) (a : G) :
    coeff (r • p) a = r • coeff p a := by
  rcases p with ⟨⟩
  simp_rw [← ofFinsupp_smul, coeff]
  exact Finsupp.smul_apply _ _ _

end Coeff

section Single

/-- `single a b` is the finitely supported function with value `b` at `a` and zero otherwise. -/
def single (a : G) (b : k) : SkewMonoidAlgebra k G := ⟨Finsupp.single a b⟩

@[simp]
theorem toFinsupp_single (a : G) (b : k) : (single a b).toFinsupp = Finsupp.single a b := rfl

@[simp]
theorem ofFinsupp_single (a : G) (b : k) : ⟨Finsupp.single a b⟩ = single a b := rfl

theorem coeff_single {a a' : G} {b : k} [Decidable (a = a')] :
    coeff (single a b) a' = if a = a' then b else 0 := by
  simp [coeff, Finsupp.single_apply]

theorem single_zero_right (a : G) : single a (0 : k) = 0 := by
  ext a'; classical
  by_cases h : a = a'
  · rw [coeff_single]; simp [h]
  · rw [coeff_single]; simp_all only [↓reduceIte, coeff_zero]

@[simp]
theorem single_add (a : G) (b₁ b₂ : k) : single a (b₁ + b₂) = single a b₁ + single a b₂ := by
  simp_rw [single, Finsupp.single_add]
  rw [← toFinsupp_add]

theorem single_zero (a : G) : (single a 0 : SkewMonoidAlgebra k G) = 0 := by
  rw [ofFinsupp_eq_zero, single, Finsupp.single_zero]

theorem single_eq_zero {a : G} {b : k} : single a b = 0 ↔ b = 0 := by
  simp only [ofFinsupp_eq_zero, single, Finsupp.single_eq_zero]

theorem toFinsupp_single' : single = (fun (a : G) (b : k) ↦ ofFinsupp (Finsupp.single a b)) := rfl

/-- Group isomorphism between `SkewMonoidAlgebra k G` and `G →₀ k`. This is an
implementation detail, but it can be useful to transfer results from `Finsupp`
to `SkewMonoidAlgebra`. -/
@[simps apply symm_apply]
def toFinsuppAddEquiv : SkewMonoidAlgebra k G ≃+ (G →₀ k) where
  toFun        := toFinsupp
  invFun       := ofFinsupp
  left_inv     := fun ⟨_p⟩ => rfl
  right_inv _p := rfl
  map_add'     := toFinsupp_add

theorem smul_single {S} [SMulZeroClass S k] (s : S) (a : G) (b : k) :
    s • single a b = single a (s • b) :=
  toFinsupp_injective <| by simp;

theorem single_injective (a : G) : Function.Injective (single a : k → SkewMonoidAlgebra k G) :=
  toFinsuppAddEquiv.symm.injective.comp (Finsupp.single_injective a)

theorem _root_.IsSMulRegular.skewMonoidAlgebra_iff {S : Type*} [Monoid S] [DistribMulAction S k]
    {a : S} [inst : Nonempty G]: IsSMulRegular k a ↔ IsSMulRegular (SkewMonoidAlgebra k G) a := by
  constructor
  · exact IsSMulRegular.skewMonoidAlgebra
  · intro ha b₁ b₂ inj
    rw [← (single_injective _).eq_iff, ← smul_single, ← smul_single] at inj
    exact single_injective (Classical.choice inst) (ha inj)

end Single

section One

variable [One G] [One k]

/-- The unit of the multiplication is `single 1 1`, i.e. the function that is `1` at `1` and
  zero elsewhere. -/
instance one : One (SkewMonoidAlgebra k G) := ⟨single 1 1⟩

theorem ofFinsupp_one : (⟨Finsupp.single 1 1⟩ : SkewMonoidAlgebra k G) = 1 :=
  rfl

@[simp]
theorem toFinsupp_one : (1 : SkewMonoidAlgebra k G).toFinsupp = Finsupp.single 1 1 :=
  rfl

@[simp]
theorem toFinsupp_eq_one {a : SkewMonoidAlgebra k G} :
    a.toFinsupp = Finsupp.single 1 1 ↔ a = 1 := by
  rw [← toFinsupp_one, toFinsupp_inj]

@[simp]
theorem ofFinsupp_eq_one {a} :
    (⟨a⟩ : SkewMonoidAlgebra k G) = 1 ↔ a = Finsupp.single 1 1 := by
  rw [← ofFinsupp_one, ofFinsupp_inj]

-- This is not a `simp` lemma as `single_zero_left` is more general.
theorem single_zero_one  : single 1 (1 : k) = 1 :=
  rfl

theorem one_def : (1 : SkewMonoidAlgebra k G) = single 1 1 :=
  rfl

@[simp]
theorem coeff_one_one : coeff (1 : SkewMonoidAlgebra k G) 1 = 1 := by
  simp only [coeff, toFinsupp_single, Finsupp.single_eq_same]

theorem coeff_one {a : G} [Decidable (a = 1)] :
    (1 : SkewMonoidAlgebra k G).coeff a = if a = 1 then 1 else 0 := by
  classical
  simp_rw [eq_comm (a := (a : G)) (b := (1 : G))]
  simpa using coeff_single

end One

section sum

instance [DecidableEq G] [DecidableEq k] : DecidableEq (SkewMonoidAlgebra k G) :=
  Equiv.decidableEq toFinsuppAddEquiv.toEquiv

/-- `sum f g` is the sum of `g a (f.coeff a)` over the support of `f`. -/
def sum {N : Type*} [AddCommMonoid N] (f : SkewMonoidAlgebra k G) (g : G → k → N) : N :=
  ∑ a ∈ f.support, g a (f.coeff a)

theorem sum_def {N : Type*} [AddCommMonoid N] (f : SkewMonoidAlgebra k G) (g : G → k → N) :
    sum f g = ∑ a ∈ f.support, g a (f.coeff a) := rfl

@[simp]
theorem sum_single_index {N} [AddCommMonoid N] {a : G} {b : k} {h : G → k → N}
    (h_zero : h a 0 = 0) : (SkewMonoidAlgebra.single a b).sum h = h a b :=
  Finsupp.sum_single_index h_zero

theorem map_sum' {N P : Type*} [AddCommMonoid N] [AddCommMonoid P] {H : Type*} [FunLike H N P]
    [AddMonoidHomClass H N P] (h : H) (f : SkewMonoidAlgebra k G) (g : G → k → N) :
    h (sum f g) = sum f fun (a : G) (b : k) => h (g a b) :=
  map_sum h _ _

theorem toFinsupp_sum {N : Type*} [AddCommMonoid N] (f : SkewMonoidAlgebra k G) (g : G → k → N) :
    sum f g = Finsupp.sum f.toFinsupp g := rfl

theorem toFinsupp_sum' {k' G' : Type*} [AddCommMonoid k'] (f : SkewMonoidAlgebra k G)
    (g : G → k → SkewMonoidAlgebra k' G') :
    (sum f g).toFinsupp = Finsupp.sum f.toFinsupp (fun (a : G) (b : k) ↦ (g a b).toFinsupp) :=
  map_sum toFinsuppAddEquiv (fun (a : G) => g a (f.coeff a)) f.toFinsupp.support

theorem ofFinsupp_sum {k' G' : Type*} [AddCommMonoid k'] (f : G →₀ k)
    (g : G → k → G' →₀ k'):
    (⟨Finsupp.sum f g⟩ : SkewMonoidAlgebra k' G') = sum ⟨f⟩ (fun (a : G) (b : k) ↦ ⟨(g a b)⟩) := by
  apply toFinsupp_injective; simp only [toFinsupp_sum']

theorem sum_single (f : SkewMonoidAlgebra k G) : f.sum single = f := by
  apply toFinsupp_injective; simp only [toFinsupp_sum', toFinsupp_single, Finsupp.sum_single]

theorem sum_add_index' {S : Type*} [AddCommMonoid S] {f g : SkewMonoidAlgebra k G} {h : G → k → S}
    (hf : ∀ i, h i 0 = 0) (h_add : ∀ a b₁ b₂, h a (b₁ + b₂) = h a b₁ + h a b₂) :
    (f + g).sum h = f.sum h + g.sum h := by
  rw [show f + g = ⟨f.toFinsupp + g.toFinsupp⟩ from add_def f g]
  exact Finsupp.sum_add_index' hf h_add

theorem sum_add_index {S : Type*} [DecidableEq G] [AddCommMonoid S]
    {f g : SkewMonoidAlgebra k G} {h : G → k → S} (h_zero : ∀ a ∈ f.support ∪ g.support, h a 0 = 0)
    (h_add : ∀ a ∈ f.support ∪ g.support, ∀ (b₁ b₂ : k), h a (b₁ + b₂) = h a b₁ + h a b₂) :
    (f + g).sum h = f.sum h + g.sum h := by
  rw [show f + g = ⟨f.toFinsupp + g.toFinsupp⟩ from add_def f g]
  exact Finsupp.sum_add_index h_zero h_add

@[simp]
theorem sum_add' {S : Type*} [AddCommMonoid S] (p : SkewMonoidAlgebra k G) (f g : G → k → S) :
    p.sum (f + g) = p.sum f + p.sum g := Finsupp.sum_add

@[simp]
theorem sum_add {S : Type*} [AddCommMonoid S] (p : SkewMonoidAlgebra k G) (f g : G → k → S) :
    (p.sum fun n x => f n x + g n x) = p.sum f + p.sum g :=
  sum_add' _ _ _

@[simp]
theorem sum_zero_index {S : Type*} [AddCommMonoid S] {f : G → k → S} :
    (0 : SkewMonoidAlgebra k G).sum f = 0 := by
  simp [sum]

@[simp]
theorem sum_zero {N : Type*} [AddCommMonoid N] {f : SkewMonoidAlgebra k G} :
    (f.sum fun _ _ => (0 : N)) = 0 :=
  Finset.sum_const_zero

theorem sum_sum_index {α β M N P : Type*} [AddCommMonoid M] [AddCommMonoid N] [AddCommMonoid P]
    {f : SkewMonoidAlgebra M α} {g : α → M → SkewMonoidAlgebra N β} {h : β → N → P}
    (h_zero : ∀ (a : β), h a 0 = 0)
    (h_add : ∀ (a : β) (b₁ b₂ : N), h a (b₁ + b₂) = h a b₁ + h a b₂) :
    sum (sum f g) h = sum f fun (a : α) (b : M) => sum (g a b) h := by
  rw [toFinsupp_sum, toFinsupp_sum' f g, Finsupp.sum_sum_index h_zero h_add]; rfl

@[simp]
theorem coeff_sum {k' G' : Type*} [AddCommMonoid k'] {f : SkewMonoidAlgebra k G}
    {g : G → k → SkewMonoidAlgebra k' G'} {a₂ : G'} :
    (f.sum g).coeff a₂ = f.sum fun a₁ b => (g a₁ b).coeff a₂ := by
  simp_rw [coeff, toFinsupp_sum', toFinsupp_sum, Finsupp.sum_apply]

theorem sum_mul {S : Type*} [NonUnitalNonAssocSemiring S] (b : S) (s : SkewMonoidAlgebra k G)
    {f : G → k → S} : s.sum f * b = s.sum fun a c => f a c * b := by
  simp only [sum, Finsupp.sum, Finset.sum_mul]

theorem mul_sum {S : Type*} [NonUnitalNonAssocSemiring S] (b : S) (s : SkewMonoidAlgebra k G)
    {f : G → k → S} : b * s.sum f = s.sum fun a c => b * f a c := by
  simp only [sum, Finsupp.sum, Finset.mul_sum]

@[simp]
theorem sum_ite_eq' {N : Type*} [AddCommMonoid N] [DecidableEq G] (f : SkewMonoidAlgebra k G)
    (a : G) (b : G → k → N) : (sum f fun (x : G) (v : k) => if x = a then b x v else 0) =
      if a ∈ f.support then b a (f.coeff a) else 0 := by
  simp only [sum, Finsupp.sum, f.toFinsupp.support.sum_ite_eq', support]

theorem smul_sum {M : Type*} [AddCommMonoid M] [DistribSMul R M]
    {v : SkewMonoidAlgebra k G} {c : R} {h : G → k → M} :
    c • v.sum h = v.sum fun a b => c • h a b :=
  Finset.smul_sum

theorem sum_congr {f : SkewMonoidAlgebra k G} {M : Type*} [AddCommMonoid M] {g1 g2 : G → k → M}
    (h : ∀ x ∈ f.support, g1 x (f.coeff x) = g2 x (f.coeff x)) :
    f.sum g1 = f.sum g2 :=
  Finset.sum_congr rfl h

end sum

section mapDomain

/-- Given `f : G → G'` and `v : SkewMonoidAlgebra k G`, `mapDomain f v : SkewMonoidAlgebra k G'`
is the finitely supported function whose value at `a : G'` is the sum of `v x` over all `x`
such that `f x = a`. -/
def mapDomain {G' : Type*} (f : G → G') (v : SkewMonoidAlgebra k G) : SkewMonoidAlgebra k G' :=
  v.sum fun a => single (f a)

lemma toFinsupp_mapDomain {G' : Type*} (f : G → G') (v : SkewMonoidAlgebra k G) :
    (mapDomain f v).toFinsupp = Finsupp.mapDomain f v.toFinsupp := by
  rw [mapDomain, Finsupp.mapDomain, toFinsupp_sum']; simp_rw [single]

@[simp]
theorem mapDomain_id {v : SkewMonoidAlgebra k G} : mapDomain id v = v := sum_single _

theorem mapDomain_comp {G' G'' : Type*} {f : G → G'} {g : G' → G''} {v : SkewMonoidAlgebra k G} :
    mapDomain (g ∘ f) v = mapDomain g (mapDomain f v) :=
  ((sum_sum_index (fun a => single_zero (g a)) (fun a => single_add (g a))).trans
    (sum_congr fun _ _ => sum_single_index (single_zero _))).symm

theorem mapDomain_zero {G' : Type*} {f : G → G'} :
    mapDomain f (0 : SkewMonoidAlgebra k G) = (0 : SkewMonoidAlgebra k G') :=
  sum_zero_index

theorem mapDomain_add {G' : Type*} {f : G → G'} {v₁ v₂ : SkewMonoidAlgebra k G} :
    mapDomain f (v₁ + v₂) = mapDomain f v₁ + mapDomain f v₂ :=
  sum_add_index' (fun _ => single_zero _) fun _ => single_add _

theorem mapDomain_sum {k' G' : Type*} [AddCommMonoid k'] {f : G → G'} {s : SkewMonoidAlgebra k' G}
    {v : G → k' → SkewMonoidAlgebra k G} :
    mapDomain f (s.sum v) = s.sum fun a b => mapDomain f (v a b) :=
    map_sum'
    { toFun := mapDomain f
      map_zero' := mapDomain_zero
      map_add' := fun _ _ ↦ mapDomain_add:
      SkewMonoidAlgebra k G →+ SkewMonoidAlgebra k G'} _ _

theorem sum_mapDomain_index {α β M N : Type*}
    [Semiring M] [AddCommMonoid N] {f : α → β} {s : SkewMonoidAlgebra M α} {h : β → M → N}
    (h_zero : ∀ (b : β), h b 0 = 0)
    (h_add : ∀ (b : β) (m₁ m₂ : M), h b (m₁ + m₂) = h b m₁ + h b m₂) :
    sum (mapDomain f s) h = sum s fun (a : α) (m : M) => h (f a) m :=
  (sum_sum_index h_zero h_add).trans <| sum_congr fun _ _ => sum_single_index (h_zero _)

theorem mapDomain_single {G' : Type*} {f : G → G'} {a : G} {b : k} :
    mapDomain f (single a b) = single (f a) b :=
  sum_single_index <| single_zero _

theorem mapDomain_smul {M α β : Type*} [Monoid R] [AddCommMonoid M] [DistribMulAction R M]
    {f : α → β} (b : R) (v : SkewMonoidAlgebra M α) : mapDomain f (b • v) = b • mapDomain f v := by
  apply toFinsupp_injective
  simp only [toFinsupp_mapDomain, toFinsupp_smul, Finsupp.mapDomain_smul]

/-- A non-commutative version of `SkewMonoidAlgebra.lift`: given an additive homomorphism
`f : k →+ R` and a homomorphism `g : G → R`, returns the additive homomorphism from
`SkewMonoidAlgebra k G` such that `liftNC f g (single a b) = f b * g a`.

If `k` is a semiring and `f` is a ring homomorphism and for all `x : R`, `y : G` the equality
`(f (y • x)) * g y = (g y) * (f x))` holds, then the result is a ring homomorphism (see
`SkewMonoidAlgebra.liftNCRingHom`).

If `R` is a `k`-algebra and `f = algebraMap k R`, then the result is an algebra homomorphism called
`SkewMonoidAlgebra.lift`. -/
def liftNC [NonUnitalNonAssocSemiring R] (f : k →+ R) (g : G → R) :
    SkewMonoidAlgebra k G →+ R :=
  (Finsupp.liftAddHom fun x : G => (AddMonoidHom.mulRight (g x)).comp f).comp
    (AddEquiv.toAddMonoidHom toFinsuppAddEquiv)

@[simp] theorem liftNC_single [NonUnitalNonAssocSemiring R] (f : k →+ R) (g : G → R) (a : G)
    (b : k) : liftNC f g (single a b) = f b * g a :=
  Finsupp.liftAddHom_apply_single _ _ _

end mapDomain

end AddCommMonoid

section AddCommGroup

variable [AddCommGroup k]

private irreducible_def neg : SkewMonoidAlgebra k G → SkewMonoidAlgebra k G
  | ⟨a⟩ => ⟨-a⟩

instance neg' : Neg (SkewMonoidAlgebra k G) :=
  ⟨neg⟩

instance sub : Sub (SkewMonoidAlgebra k G) :=
  ⟨fun a b => a + -b⟩

@[simp]
theorem ofFinsupp_neg {a} : (⟨-a⟩ : SkewMonoidAlgebra k G) = -⟨a⟩ :=
  show _ = neg _ by rw [neg_def]

@[simp]
theorem ofFinsupp_sub {a b} : (⟨a - b⟩ : SkewMonoidAlgebra k G) = ⟨a⟩ - ⟨b⟩ := by
  rw [sub_eq_add_neg, ofFinsupp_add, ofFinsupp_neg]; rfl

@[simp]
theorem toFinsupp_neg  (a : SkewMonoidAlgebra k G) : (-a).toFinsupp = -a.toFinsupp := by
  cases a; rw [← ofFinsupp_neg]

@[simp]
theorem toFinsupp_sub (a b : SkewMonoidAlgebra k G) :
    (a - b).toFinsupp = a.toFinsupp - b.toFinsupp := by
  rw [sub_eq_add_neg, ← toFinsupp_neg, ← toFinsupp_add]; rfl

end AddCommGroup

section Mul

variable [Mul G]

section SMul

variable [SMul G k] [NonAssocSemiring k]

/-- The product of `f g : SkewMonoidAlgebra k G` is the finitely supported function whose value
  at `a` is the sum of `f x * (x • g y)` over all pairs `x, y` such that `x * y = a`.
  (Think of a skew group ring.)-/
instance mul : Mul (SkewMonoidAlgebra k G) :=
  ⟨fun f g => f.sum fun a₁ b₁ => g.sum fun a₂ b₂ => single (a₁ * a₂) (b₁ * (a₁ • b₂))⟩

theorem mul_def {f g : SkewMonoidAlgebra k G} :
    f * g = f.sum fun a₁ b₁ => g.sum fun a₂ b₂ => single (a₁ * a₂) (b₁ * (a₁ • b₂)) :=
  rfl

end SMul

section DistribSMul

instance nonUnitalNonAssocSemiring [NonAssocSemiring k] [DistribSMul G k] :
    NonUnitalNonAssocSemiring (SkewMonoidAlgebra k G) where
  left_distrib := fun f g h => by
    haveI := Classical.decEq G
    simp only [mul_def]
    refine Eq.trans (congr_arg (sum f) (funext₂ fun a₁ b₁ => sum_add_index ?_ ?_)) ?_ <;>
      simp only [smul_zero, smul_add, mul_add, mul_zero, single_zero, single_add,
        forall_true_iff, sum_add]
  right_distrib := fun f g h => by
    haveI := Classical.decEq G
    simp only [mul_def]
    refine Eq.trans (sum_add_index ?_ ?_) ?_ <;>
      simp only [add_mul, zero_mul, single_zero, single_add, forall_true_iff, sum_zero, sum_add]
  zero_mul := fun f => by
    simp only [mul_def]
    exact sum_zero_index
  mul_zero := fun f => by
    simp only [mul_def]
    exact Eq.trans (congr_arg (sum f) (funext₂ fun a₁ b₁ => sum_zero_index)) sum_zero

variable [Semiring R] [Semiring k] [SMul G k]

theorem liftNC_mul {g_hom : Type*} [FunLike g_hom G R]
    [MulHomClass g_hom G R] (f : k →+* R) (g : g_hom) (a b : SkewMonoidAlgebra k G)
    (h_comm : ∀ {x y}, y ∈ a.support → (f (y • b.coeff x)) * g y = (g y) * (f (b.coeff x))) :
    liftNC (f : k →+ R) g (a * b) = liftNC (f : k →+ R) g a * liftNC (f : k →+ R) g b := by
  conv_rhs => rw [← sum_single a, ← sum_single b]
  simp_rw [mul_def, map_sum', liftNC_single, sum_mul, mul_sum]
  refine Finset.sum_congr rfl fun y hy => Finset.sum_congr rfl fun x _hx => ?_
  simp only [AddMonoidHom.coe_coe, map_mul]
  rw [mul_assoc, ← mul_assoc (f (y • b.coeff x)), h_comm hy, mul_assoc, mul_assoc]

theorem sum_smul_index {N : Type*} [AddCommMonoid N]
    {g : SkewMonoidAlgebra k G} {b : k} {h : G → k → N} (h0 : ∀ i, h i 0 = 0) :
    (b • g).sum h = g.sum fun i a => h i (b * a) := by
  simp only [toFinsupp_sum, toFinsupp_smul, Finsupp.sum_smul_index h0]

theorem sum_smul_index' {N : Type*} [DistribSMul R k] [AddCommMonoid N]
    {g : SkewMonoidAlgebra k G} {b : R} {h : G → k → N} (h0 : ∀ i, h i 0 = 0) :
    (b • g).sum h = g.sum fun i c => h i (b • c) := by
  simp only [toFinsupp_sum, toFinsupp_smul, Finsupp.sum_smul_index' h0]

end DistribSMul

end Mul

/-! #### Semiring structure -/

section Semiring

variable [Semiring k] [Monoid G] [MulSemiringAction G k]

open MulSemiringAction

instance nonUnitalSemiring : NonUnitalSemiring (SkewMonoidAlgebra k G) where
  mul_assoc := fun f g h => by
    simp only [mul_def]
    rw [sum_sum_index]; congr; ext a₁ b₁
    rw [sum_sum_index, sum_sum_index]; congr; ext a₂ b₂
    rw [sum_sum_index, sum_single_index]; congr; ext a₃ b₃
    rw [sum_single_index, mul_assoc, mul_assoc]
    all_goals simp only [smul_add, mul_smul, smul_mul, smul_zero,
      mul_zero, forall_const, single_zero, single_add, forall_true_iff, add_mul,
      mul_add, zero_mul, mul_zero, sum_zero, sum_add]

instance nonAssocSemiring : NonAssocSemiring (SkewMonoidAlgebra k G) where
  natCast := fun n => single 1 n
  natCast_zero := by simp only [Nat.cast_zero, single_zero]
  natCast_succ := fun _ => by simp only [Nat.cast_add, Nat.cast_one, single_add]; rfl
  one_mul := fun f => by
    simp only [one_def, mul_def]
    rw [sum_single_index]
    simp only [one_mul, one_smul, zero_mul, single_zero, sum_zero,
      sum_single_index, sum_single]
    simp only [one_mul, one_smul, zero_mul, single_zero, sum_zero];
  mul_one := fun f => by
    simp only [one_def, mul_def, mul_one, smul_zero, mul_zero, single_zero, sum_single_index,
      MulDistribMulAction.smul_one]
    rw [sum_single]

theorem natCast_def (n : ℕ) : (n : SkewMonoidAlgebra k G) = single (1 : G) (n : k) := rfl

instance semiring : Semiring (SkewMonoidAlgebra k G) where
  __ := SkewMonoidAlgebra.nonUnitalSemiring
  __ := SkewMonoidAlgebra.nonAssocSemiring

variable [Semiring R]

@[simp]
theorem liftNC_one {g_hom : Type*} [FunLike g_hom G R] [OneHomClass g_hom G R] (f : k →+* R)
    (g : g_hom) : liftNC (f : k →+ R) g 1 = 1 := by
  simp only [one_def, liftNC_single, AddMonoidHom.coe_coe, map_one, mul_one]

/-- `liftNC` as a `RingHom`, for when `f x` and `g y` commute -/
def liftNCRingHom (f : k →+* R) (g : G →* R) (h_comm : ∀ {x y}, (f (y • x)) * g y = (g y) * (f x)) :
    SkewMonoidAlgebra k G →+* R where
  __ := liftNC (f : k →+ R) g
  map_one' := liftNC_one _ _
  map_mul' := fun _a _b => liftNC_mul _ _ _ _ fun {_ _} _ => h_comm

end Semiring

/-! #### Derived instances -/

section DerivedInstances

instance unique [AddCommMonoid k] [Subsingleton k] : Unique (SkewMonoidAlgebra k G) :=
  Function.Injective.unique toFinsupp_injective

instance addCommGroup [AddCommGroup k] : AddCommGroup (SkewMonoidAlgebra k G) where
  __ := toFinsupp_injective.addCommGroup _ (toFinsupp_zero (k := k))
    toFinsupp_add toFinsupp_neg toFinsupp_sub (fun _ _ => toFinsupp_smul _ _)
    (fun _ _ => toFinsupp_smul _ _)
  toAdd := SkewMonoidAlgebra.add'

instance nonUnitalNonAssocRing [Ring k] [Monoid G] [MulSemiringAction G k] :
    NonUnitalNonAssocRing (SkewMonoidAlgebra k G) where
  __ := SkewMonoidAlgebra.addCommGroup
  __ := SkewMonoidAlgebra.nonUnitalNonAssocSemiring

instance nonUnitalRing [Ring k] [Monoid G] [MulSemiringAction G k] :
    NonUnitalRing (SkewMonoidAlgebra k G) where
  __ := SkewMonoidAlgebra.addCommGroup
  __ := SkewMonoidAlgebra.nonUnitalSemiring

instance nonAssocRing [Ring k] [Monoid G] [MulSemiringAction G k] :
    NonAssocRing (SkewMonoidAlgebra k G) where
  __ := SkewMonoidAlgebra.addCommGroup
  __ := SkewMonoidAlgebra.nonAssocSemiring
  intCast := fun z => single 1 (z : k)
  intCast_ofNat := fun n => by simp; rfl
  intCast_negSucc := fun n => by
    simp only [Int.cast_negSucc, Nat.cast_add, Nat.cast_one, neg_add_rev, single_add]
    rw [single]; rw [single];
    simp only [Finsupp.single_neg, ofFinsupp_neg, ofFinsupp_single, ofFinsupp_one, add_right_inj]
    rfl

theorem intCast_def [Ring k] [Monoid G] [MulSemiringAction G k] (z : ℤ) :
    (z : SkewMonoidAlgebra k G) = single (1 : G) (z : k) :=
  rfl

instance ring [Ring k] [Monoid G] [MulSemiringAction G k]: Ring (SkewMonoidAlgebra k G) where
  __ := SkewMonoidAlgebra.nonAssocRing
  __ := SkewMonoidAlgebra.semiring

variable {S : Type*}

instance distribSMul {S} [AddCommMonoid k] [DistribSMul S k] :
    DistribSMul S (SkewMonoidAlgebra k G) where
  __ := toFinsupp_injective.distribSMul ⟨⟨toFinsupp, toFinsupp_zero⟩, toFinsupp_add⟩
    toFinsupp_smul
  toSMulZeroClass := SkewMonoidAlgebra.smulZeroClass

instance distribMulAction {S} [Monoid S] [AddCommMonoid k]  [DistribMulAction S k] :
    DistribMulAction S (SkewMonoidAlgebra k G) where
  __ := toFinsupp_injective.distribMulAction ⟨⟨toFinsupp, toFinsupp_zero (k := k)⟩, toFinsupp_add⟩
      toFinsupp_smul
  toSMul := smulZeroClass.toSMul

instance module {S} [Semiring S] [AddCommMonoid k] [Module S k] :
    Module S (SkewMonoidAlgebra k G) where
  __ := toFinsupp_injective.module _ ⟨⟨toFinsupp, toFinsupp_zero⟩, toFinsupp_add⟩ toFinsupp_smul
  toDistribMulAction := distribMulAction

instance faithfulSMul {S} [AddCommMonoid k] [SMulZeroClass S k] [FaithfulSMul S k] [Nonempty G] :
    FaithfulSMul S (SkewMonoidAlgebra k G) where
  eq_of_smul_eq_smul {_s₁ _s₂} h := by
    apply eq_of_smul_eq_smul fun a : G →₀ k => congr_arg toFinsupp _
    intro a
    simp_rw [ofFinsupp_smul, h]

instance isScalarTower {S₁ S₂} [AddCommMonoid k] [SMul S₁ S₂] [SMulZeroClass S₁ k]
    [SMulZeroClass S₂ k] [IsScalarTower S₁ S₂ k] : IsScalarTower S₁ S₂ (SkewMonoidAlgebra k G) :=
  ⟨by rintro _ _ ⟨⟩; simp_rw [← ofFinsupp_smul, smul_assoc]⟩

instance smulCommClass {S₁ S₂} [AddCommMonoid k] [SMulZeroClass S₁ k] [SMulZeroClass S₂ k]
    [SMulCommClass S₁ S₂ k] : SMulCommClass S₁ S₂ (SkewMonoidAlgebra k G) :=
  ⟨by rintro m n ⟨f⟩; simp_rw [← ofFinsupp_smul, smul_comm m n f]⟩

instance isCentralScalar {S} [AddCommMonoid k] [SMulZeroClass S k] [SMulZeroClass Sᵐᵒᵖ k]
    [IsCentralScalar S k] : IsCentralScalar S (SkewMonoidAlgebra k G) :=
  ⟨by rintro _ ⟨⟩; simp_rw [← ofFinsupp_smul, op_smul_eq_smul]⟩

section Module.Free

variable [Semiring S]

/-- Linear equivalence between `SkewMonoidAlgebra k G` and `G →₀ k`. This is an
implementation detail, but it can be useful to transfer results from `Finsupp`
to `SkewMonoidAlgebra`. -/
def toFinsuppLinearEquiv [AddCommMonoid k] [Module S k] : SkewMonoidAlgebra k G ≃ₗ[S] (G →₀ k) :=
  AddEquiv.toLinearEquiv toFinsuppAddEquiv
      (by simp only [toFinsuppAddEquiv_apply, toFinsupp_smul, forall_const])

/-- The basis on `SkewMonoidAlgebra k G` with basis vectors `fun i ↦ single i 1` -/
def basisSingleOne [Semiring k] : Basis G k (SkewMonoidAlgebra k G) where
  repr := toFinsuppLinearEquiv

instance Module.free [Semiring k] : Module.Free k (SkewMonoidAlgebra k G) :=
  Module.Free.of_basis basisSingleOne

end Module.Free

variable {M α : Type*} [Monoid G] [AddCommMonoid M] [MulAction G α]

/-- Scalar multiplication acting on the domain.

This is not an instance as it would conflict with the action on the range.
See the `instance_diamonds` test for examples of such conflicts. -/
def comapSMul [AddCommMonoid M] : SMul G (SkewMonoidAlgebra M α) where smul g := mapDomain (g • ·)

attribute [local instance] comapSMul

theorem comapSMul_def (g : G) (f : SkewMonoidAlgebra M α) : g • f = mapDomain (g • ·) f := rfl

@[simp]
theorem comapSMul_single (g : G) (a : α) (b : M) : g • single a b = single (g • a) b :=
  mapDomain_single

/-- `comapSMul` is multiplicative -/
def comapMulAction : MulAction G (SkewMonoidAlgebra M α) where
  one_smul f := by rw [comapSMul_def, one_smul_eq_id, mapDomain_id]
  mul_smul g g' f := by
    rw [comapSMul_def, comapSMul_def, comapSMul_def, ← comp_smul_left, mapDomain_comp]

attribute [local instance] comapMulAction
/-- This is not an instance as it conflicts with `SkewMonoidAlgebra.distribMulAction`
  when `G = kˣ`. -/
def comapDistribMulActionSelf [AddCommMonoid k] :
    DistribMulAction G (SkewMonoidAlgebra k G) where
  smul_zero g := by
    ext
    simp only [comapSMul_def, smul_eq_mul, sum_zero_index, toFinsupp_zero, Finsupp.coe_zero,
      Pi.zero_apply, mapDomain]
  smul_add g f f' := by
    ext
    simp only [comapSMul_def, mapDomain_add]

end DerivedInstances

section MiscTheorems

variable [Semiring k]

theorem coeff_mul [DecidableEq G] [Monoid G] [MulSemiringAction G k] (f g : SkewMonoidAlgebra k G)
    (x : G) : (f * g).coeff x = f.sum fun a₁ b₁ => g.sum fun a₂ b₂ =>
      if a₁ * a₂ = x then b₁ * a₁ • b₂ else 0 := by
  rw [mul_def, coeff_sum]; congr; ext
  rw [coeff_sum]; congr; ext
  exact coeff_single

open BigOperators

theorem coeff_mul_antidiagonal [Monoid G] (f g : SkewMonoidAlgebra k G) [MulSemiringAction G k]
    (x : G) (s : Finset (G × G)) (hs : ∀ {p : G × G}, p ∈ s ↔ p.1 * p.2 = x) :
    (f * g).coeff x = ∑ p in s, f.coeff p.1 * p.1 • g.coeff p.2 := by
  classical
  let F : G × G → k := fun p => if p.1 * p.2 = x then f.coeff p.1 * p.1 • g.coeff p.2 else 0
  calc
    (f * g).coeff x = ∑ a₁ in f.support, ∑ a₂ in g.support, F (a₁, a₂) := coeff_mul f g x
    _ = ∑ p in f.support ×ˢ g.support, F p := Finset.sum_product.symm
    _ = ∑ p in (f.support ×ˢ g.support).filter fun p : G × G =>
        p.1 * p.2 = x, f.coeff p.1 * p.1 • g.coeff p.2 := (Finset.sum_filter _ _).symm
    _ = ∑ p in s.filter fun p : G × G => p.1 ∈ f.support ∧ p.2 ∈ g.support,
        f.coeff p.1 * p.1 • g.coeff p.2 :=
      (Finset.sum_congr
        (by ext; simp only [Finset.mem_filter, Finset.mem_product, hs, and_comm])
        fun _ _ => rfl)
    _ = ∑ p in s, f.coeff p.1 * p.1 • g.coeff p.2 :=
      Finset.sum_subset (Finset.filter_subset _ _) fun p hps hp => by
        simp only [Finset.mem_filter, mem_support_iff, not_and, Classical.not_not] at hp ⊢
        by_cases h1 : f.coeff p.1 = 0
        · rw [h1, zero_mul]
        · rw [hp hps h1, smul_zero, mul_zero]

@[simp]
theorem single_mul_single [Monoid G] [MulSemiringAction G k] {a₁ a₂ : G} {b₁ b₂ : k} :
    (single a₁ b₁) * (single a₂ b₂) = single (a₁ * a₂) (b₁ * a₁ • b₂) :=
  (sum_single_index (by simp only [zero_mul, single_zero, sum_zero])).trans
    (sum_single_index (by simp only [smul_zero, mul_zero, single_zero]))

/-- Like `mapDomain_zero`, but for the `1` we define in this file -/
theorem mapDomain_one {α : Type*} {β : Type*} {α₂ : Type*} [Semiring β] [Monoid α] [Monoid α₂]
    {F : Type*} [FunLike F α α₂] [MonoidHomClass F α α₂] (f : F) :
    (mapDomain f (1 : SkewMonoidAlgebra β α) : SkewMonoidAlgebra β α₂) =
      (1 : SkewMonoidAlgebra β α₂) := by
  simp_rw [one_def, mapDomain_single, map_one]

/- Like `mapDomain_add`, but for the skewed convolutive multiplication we define in this
  file. This theorem holds assuming that `(hf : ∀ (a : α) (x : β), a • x = (f a) • x)`. -/
theorem mapDomain_mul {α : Type*} {β : Type*} {α₂ : Type*} [Semiring β] [Monoid α]
    [MulSemiringAction α β] [Monoid α₂] [MulSemiringAction α₂ β]
    {F : Type*} [FunLike F α α₂] [MulHomClass F α α₂] {f : F} (x y : SkewMonoidAlgebra β α)
    (hf : ∀ (a : α) (x : β), a • x = (f a) • x) :
    mapDomain f (x * y) = mapDomain f x * mapDomain f y := by
  rw [mul_def, mapDomain_sum]
  have : (sum x fun a b => sum y fun a₂ b₂ =>
      mapDomain (↑f) (single (a * a₂) (b * a • b₂))) =
      sum (mapDomain (↑f) x) fun a₁ b₁ =>
        sum (mapDomain (↑f) y) fun a₂ b₂ => single (a₁ * a₂) (b₁ * a₁ • b₂) := by
    simp_rw [mapDomain_single, map_mul]
    rw [sum_mapDomain_index]
    · congr
      ext a b c
      rw [sum_mapDomain_index]
      · congr
        ext a₂ b₂ a₃
        rw [hf]
      · simp only [smul_zero, mul_zero, single,
          ofFinsupp_eq_zero, Finsupp.single_zero, forall_const]
      · intros a₂ b₁ b₂
        simp only [smul_add, mul_add]
        rw [single_add]
    · simp only [zero_mul, single_zero, sum_zero, forall_const]
    · simp only [add_mul, single_add, sum_add, forall_const]
  convert this using 4
  rw [mapDomain_sum]

variable (k G)

/-- The embedding of a monoid into its skew monoid algebra. -/
def of [Monoid G] [MulSemiringAction G k] : G →* SkewMonoidAlgebra k G where
  toFun a      := single a 1
  map_one'     := rfl
  map_mul' a b := by simp only [single_mul_single, smul_one, mul_one]

@[simp]
lemma of_apply [inst : Semiring k] [inst : Monoid G]
    [inst : MulSemiringAction G k] (a : G) : (of k G) a = single a 1 := by
  simp only [of, MonoidHom.coe_mk, OneHom.coe_mk]

theorem smul_of [Monoid G] [MulSemiringAction G k] (g : G) (r : k) : r • of k G g = single g r := by
  rw [of_apply, smul_single, smul_eq_mul, mul_one];

theorem of_injective [Monoid G] [MulSemiringAction G k] [Nontrivial k] :
    Function.Injective (of k G) := fun a b h => by
  simp_rw [of_apply, ← toFinsupp_inj] at h
  simpa using (Finsupp.single_eq_single_iff _ _ _ _).mp h

theorem coeff_mul_single_aux [Monoid G] [MulSemiringAction G k] (f : SkewMonoidAlgebra k G) {r : k}
    {x y z : G} (H : ∀ a, a * x = z ↔ a = y) : (f * single x r).coeff z = f.coeff y * y • r := by
  classical
  have A : ∀ a₁ b₁, ((single x r).sum fun a₂ b₂ => ite (a₁ * a₂ = z) (b₁ * a₁ • b₂) 0) =
      ite (a₁ * x = z) (b₁ * a₁ • r) 0 :=
    fun a₁ b₁ => sum_single_index <| by simp
  calc
    (HMul.hMul (β := SkewMonoidAlgebra k G) f (single x r)).coeff z =
        sum f fun a b => if a = y then b * y • r else 0 := by
          simp only [coeff_mul, A, H, sum_ite_eq']
    _ = if y ∈ f.support then f.coeff y * y • r else 0 := (f.support.sum_ite_eq' _ _)
    _ = f.coeff y * y • r := by split_ifs with h <;> simp [support] at h <;> simp [h, coeff]

theorem coeff_mul_single_one [Monoid G] [MulSemiringAction G k] (f : SkewMonoidAlgebra k G) (r : k)
    (x : G) : (HMul.hMul (β := SkewMonoidAlgebra k G) f (single 1 r)).coeff x = f.coeff x * x • r :=
  f.coeff_mul_single_aux fun a => by rw [mul_one]

theorem coeff_mul_single_of_not_exists_mul [Monoid G] [MulSemiringAction G k] (r : k) {g g' : G}
    (x : SkewMonoidAlgebra k G) (h : ¬∃ d, g' = d * g) : (x * single g r).coeff g' = 0 := by
  classical
  simp_rw [coeff_mul, toFinsupp_sum]
  rw [Finsupp.sum_comm, single, Finsupp.sum_single_index]
  · apply Finset.sum_eq_zero
    simp_rw [ite_eq_right_iff]
    rintro g'' _ rfl
    exact absurd ⟨_, rfl⟩ h
  · simp_rw [Finsupp.sum, smul_zero, mul_zero, ite_self, Finset.sum_const_zero]

theorem coeff_single_mul_aux [Monoid G] [MulSemiringAction G k] (f : SkewMonoidAlgebra k G) {r : k}
    {x y z : G} (H : ∀ a, x * a = y ↔ a = z) : (single x r * f).coeff y = r * x • f.coeff z := by
  classical
  have : (f.sum fun a b => ite (x * a = y) (0 * x • b) 0) = 0 := by
    simp only [zero_mul, ite_self,sum_zero]
  calc
    (HMul.hMul (α := SkewMonoidAlgebra k G) (single x r) f).coeff y =
        sum f fun a b => ite (x * a = y) (r * x • b) 0 :=
      (coeff_mul _ _ _).trans <| sum_single_index this
    _ = f.sum fun a b => ite (a = z) (r * x • b) 0 := by simp only [H]
    _ = if z ∈ f.support then r * x • f.coeff z else 0 := (f.support.sum_ite_eq' _ _)
    _ = _ := by split_ifs with h <;> simp [support] at h <;> simp [h, coeff]

theorem coeff_single_one_mul [Monoid G] [MulSemiringAction G k] (f : SkewMonoidAlgebra k G) (r : k)
    (x : G) : (single (1 : G) r * f).coeff x = r * f.coeff x := by
  rw [coeff_single_mul_aux, one_smul]
  simp only [one_mul, forall_const]

theorem coeff_single_mul_of_not_exists_mul [Monoid G] [MulSemiringAction G k] (r : k) {g g' : G}
    (x : SkewMonoidAlgebra k G) (h : ¬∃ d, g' = g * d) : (single g r * x).coeff g' = 0 := by
  classical
  rw [coeff_mul, sum_single_index]
  · apply Finset.sum_eq_zero
    simp_rw [ite_eq_right_iff]
    rintro g'' _hg'' rfl
    exact absurd ⟨_, rfl⟩ h
  · simp_rw [toFinsupp_sum, Finsupp.sum, zero_mul, ite_self, Finset.sum_const_zero]

end MiscTheorems

section AddHom

variable [AddCommMonoid k]

theorem addHom_ext {N : Type*} [AddZeroClass N] ⦃f g : SkewMonoidAlgebra k G →+ N⦄
    (H : ∀ x y, f (single x y) = g (single x y)) : f = g := by
  have hf (x : G →₀ k) {f : SkewMonoidAlgebra k G →+ N} :
    f (ofFinsupp x) = (AddMonoidHom.comp f
      ⟨⟨ofFinsupp, ofFinsupp_zero⟩, (fun _ _ ↦ ofFinsupp_add)⟩) x := by rfl
  simp_rw [hf] at H
  convert Finsupp.addHom_ext H
  refine' ⟨fun heq => by rw [heq], fun heq => by ext x; rw [← eta x]; simp_rw [hf, heq]⟩

/-- `single` as an `AddMonoidHom`.

See `lsingle` for the stronger version as a linear map. -/
@[simps]
def singleAddHom (a : G) : k →+ SkewMonoidAlgebra k G where
  toFun := single a
  map_zero' := single_zero a
  map_add' _ := single_add a _

@[ext high]
theorem addHom_ext' {N : Type*} [AddZeroClass N] ⦃f g : SkewMonoidAlgebra k G →+ N⦄
    (H : ∀ x, f.comp (singleAddHom x) = g.comp (singleAddHom x)) : f = g :=
  addHom_ext fun x => DFunLike.congr_fun (H x)

end AddHom

/-! #### Non-unital, non-associative algebra structure -/

section NonUnitalNonAssocAlgebra

variable [Semiring k] [Monoid G] [MulSemiringAction G k]

theorem liftNC_smul [MulOneClass G] {R : Type*} [Semiring R] (f : k →+* R) (g : G →* R) (c : k)
    (φ : SkewMonoidAlgebra k G) :
    liftNC (f : k →+ R) g (c • φ) = f c * liftNC (f : k →+ R) g φ := by
  suffices this :
    (liftNC ↑f g).comp (smulAddHom k (SkewMonoidAlgebra k G) c) =
      (AddMonoidHom.mulLeft (f c)).comp (liftNC ↑f g) by exact DFunLike.congr_fun this φ
  refine addHom_ext' fun a => AddMonoidHom.ext fun b => ?_
  simp only [AddMonoidHom.coe_comp, Function.comp_apply, singleAddHom_apply, smulAddHom_apply,
    smul_single, smul_eq_mul, AddMonoidHom.coe_mulLeft]
  erw [liftNC_single, liftNC_single, AddMonoidHom.coe_coe, map_mul, mul_assoc]

variable (k) (G)

instance isScalarTower_self [IsScalarTower k k k] :
    IsScalarTower k (SkewMonoidAlgebra k G) (SkewMonoidAlgebra k G) :=
  ⟨fun t a b => by
    classical
    simp only [smul_eq_mul, coeff_mul, Finsupp.coe_smul]
    refine Eq.trans (sum_smul_index' (g := a) (b := t) ?_) ?_ <;>
      simp only [coeff_mul, ← smul_sum, smul_mul_assoc, ← smul_single,
        zero_mul, imp_true_iff, sum_zero, smul_zero, single_zero]; rfl⟩

end NonUnitalNonAssocAlgebra

section DistribMulActionHom

variable [Semiring R] {M N : Type*} [AddCommMonoid M] [AddCommMonoid N]
variable [DistribMulAction R M] [DistribMulAction R N]

/-- `single` as a `DistribMulActionSemiHom`.

See also `lsingle` for the version as a linear map. -/
@[simps]
def DistribMulActionHom.single {α : Type*} (a : α) : M →+[R] SkewMonoidAlgebra M α where
  __ := singleAddHom a
  map_smul' := fun k m => by simp only [singleAddHom, smul_single, MonoidHom.id_apply]

theorem distribMulActionHom_ext {α : Type*} {f g : SkewMonoidAlgebra M α →+[R] N}
    (h : ∀ (a : α) (m : M), f (single a m) = g (single a m)) : f = g :=
  DistribMulActionHom.toAddMonoidHom_injective <| addHom_ext h

/-- See note [partially-applied ext lemmas]. -/
@[ext]
theorem distribMulActionHom_ext' {α : Type*} {f g : SkewMonoidAlgebra M α →+[R] N}
    (h : ∀ a : α, f.comp (DistribMulActionHom.single a) = g.comp (DistribMulActionHom.single a)) :
    f = g :=
  distribMulActionHom_ext fun a => DistribMulActionHom.congr_fun (h a)

/-- Interpret `single a` as a linear map. -/
def lsingle {α : Type*} (a : α) [Module R M] : M →ₗ[R] (SkewMonoidAlgebra M α) where
  __ := singleAddHom a
  map_smul' := fun _ _ => (smul_single _ _ _).symm

/-- Two `R`-linear maps from `SkewMonoidAlgebra M α` which agree on each `single x y`
  agree everywhere. -/
theorem lhom_ext {α : Type*} [Module R M] [Module R N] ⦃φ ψ : SkewMonoidAlgebra M α →ₗ[R] N⦄
    (h : ∀ a b, φ (single a b) = ψ (single a b)) : φ = ψ :=
  LinearMap.toAddMonoidHom_injective <| addHom_ext h

@[ext high]
theorem lhom_ext' {α : Type*} [Module R M] [Module R N] ⦃φ ψ : SkewMonoidAlgebra M α →ₗ[R] N⦄
    (h : ∀ a, φ.comp (lsingle a) = ψ.comp (lsingle a)) : φ = ψ :=
  lhom_ext fun a => LinearMap.congr_fun (h a)

variable {A : Type*} [NonUnitalNonAssocSemiring A]
variable [Semiring k] [Monoid G] [MulSemiringAction G k]

/-- A non_unital `k`-algebra homomorphism from `SkewMonoidAlgebra k G` is uniquely defined by its
values on the functions `single a 1`. -/
theorem nonUnitalAlgHom_ext [DistribMulAction k A] {φ₁ φ₂ : SkewMonoidAlgebra k G →ₙₐ[k] A}
    (h : ∀ x, φ₁ (single x 1) = φ₂ (single x 1)) : φ₁ = φ₂ := by
  apply NonUnitalAlgHom.to_distribMulActionHom_injective
  apply distribMulActionHom_ext'
  intro a
  ext
  simp only [DistribMulActionHom.comp_apply, NonUnitalAlgHom.coe_to_distribMulActionHom,
    DistribMulActionHom.single_toFun, ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe,
    singleAddHom_apply, h]

/-- See note [partially-applied ext lemmas]. -/
@[ext high]
theorem nonUnitalAlgHom_ext' [DistribMulAction k A] {φ₁ φ₂ : SkewMonoidAlgebra k G →ₙₐ[k] A}
    (h : φ₁.toMulHom.comp (of k G).toMulHom = φ₂.toMulHom.comp (of k G).toMulHom) : φ₁ = φ₂ :=
  nonUnitalAlgHom_ext <| DFunLike.congr_fun h

end DistribMulActionHom

/-! #### Algebra structure -/

section Algebra

variable [Monoid G]

section Semiring

variable [Semiring k] [MulSemiringAction G k]

/-- `single 1` as a `RingHom` -/
def singleOneRingHom : k →+* SkewMonoidAlgebra k G where
  __ := singleAddHom 1
  map_one' := rfl
  map_mul' := fun x y => by
    simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe, singleAddHom_apply,
      single_mul_single, mul_one]
    simp only [one_smul]

/-- `mapDomain` is an `AddMonoidHom`. -/
@[simps]
def mapDomain.addMonoidHom {M α β : Type*} [AddCommMonoid M] (f : α → β) :
    SkewMonoidAlgebra M α →+ SkewMonoidAlgebra M β where
  toFun        := mapDomain f
  map_zero'    := mapDomain_zero
  map_add' _ _ := mapDomain_add

/-- If f : G → H is a multiplicative homomorphism between two monoids and
  `∀ (a : G) (x : k), a • x = (f a) • x`, then `mapDomain f` is a ring homomorphism
  between their skew monoid algebras. -/
def mapDomainRingHom {H F : Type*} [Monoid H] [FunLike F G H] [MonoidHomClass F G H]
    [MulSemiringAction H k] {f : F} (hf : ∀ (a : G) (x : k), a • x = (f a) • x) :
    SkewMonoidAlgebra k G →+* SkewMonoidAlgebra k H where
  __ := (mapDomain.addMonoidHom f : SkewMonoidAlgebra k G →+ SkewMonoidAlgebra k H)
  map_one' := mapDomain_one f
  map_mul' := fun x y => mapDomain_mul x y hf

/-- If two ring homomorphisms from `SkewMonoidAlgebra k G` are equal on all `single a 1`
and `single 1 b`, then they are equal. -/
theorem ringHom_ext {f g : SkewMonoidAlgebra k G →+* k} (h₁ : ∀ b, f (single 1 b) = g (single 1 b))
    (h_of : ∀ a, f (single a 1) = g (single a 1)) : f = g :=
  have {a : G} {b₁ b₂ : k} : (single 1 b₁) * (single a b₂) = single a (b₁ * b₂) := by
    simp only [single_mul_single, one_mul, one_smul]
  RingHom.coe_addMonoidHom_injective <|
    addHom_ext fun a b => by
      rw [← mul_one b, ← this]
      erw [AddMonoidHom.coe_coe f, AddMonoidHom.coe_coe g]; rw [f.map_mul, g.map_mul, h₁, h_of]

/-- If two ring homomorphisms from `SkewMonoidAlgebra k G` are equal on all `single a 1`
and `single 1 b`, then they are equal.

See note [partially-applied ext lemmas]. -/
@[ext high]
theorem ringHom_ext' {f g : SkewMonoidAlgebra k G →+* k}
    (h₁ : f.comp singleOneRingHom = g.comp singleOneRingHom)
    (h_of : (f : SkewMonoidAlgebra k G →* k).comp (of k G) =
      (g : SkewMonoidAlgebra k G →* k).comp (of k G)) : f = g :=
  ringHom_ext (RingHom.congr_fun h₁) (DFunLike.congr_fun h_of)

end Semiring

section CommSemiring

variable [CommSemiring k]

/-- The instance `Algebra k (SkewMonoidAlgebra A G)` whenever we have `Algebra k A`.
  In particular this provides the instance `Algebra k (SkewMonoidAlgebra k G)`.
  This requires `SmulTrivAction G k A`. -/
instance algebra {A : Type*} [Semiring A] [MulSemiringAction G A] [Algebra k A]
    [SMulCommClass G k A] : Algebra k (SkewMonoidAlgebra A G) where
  __ := singleOneRingHom.comp (algebraMap k A)
  smul_def' := fun r a => by
    simp only [RingHom.coe_comp, comp_apply]
    ext
    simp only [coeff_smul, Algebra.smul_def, singleOneRingHom, singleAddHom, ZeroHom.toFun_eq_coe,
      ZeroHom.coe_mk, RingHom.coe_mk, MonoidHom.coe_mk, OneHom.coe_mk, coeff_single_one_mul];
  commutes' := fun r f => by
    simp only [RingHom.coe_comp, comp_apply]
    ext
    simp only [singleOneRingHom, singleAddHom, ZeroHom.toFun_eq_coe, ZeroHom.coe_mk, RingHom.coe_mk,
      MonoidHom.coe_mk, OneHom.coe_mk, coeff_single_one_mul, Algebra.commutes, coeff_mul_single_one,
      smul_algebraMap]

@[simp]
theorem coe_algebraMap {A : Type*} [Semiring A] [Algebra k A] [MulSemiringAction G A]
    [SMulCommClass G k A] :
    ⇑(@algebraMap k (SkewMonoidAlgebra A G) _ _ _) = single 1 ∘ algebraMap k A :=
  rfl

theorem single_eq_algebraMap_mul_of (a : G) (b : k) [MulSemiringAction G k] [SMulCommClass G k k] :
    single a b = (@algebraMap k (SkewMonoidAlgebra k G) _ _ _) b * of k G a := by
  simp only [coe_algebraMap, Algebra.id.map_eq_id, comp_apply, RingHom.id_apply, of_apply,
    single_mul_single, one_mul, smul_one, mul_one]

theorem single_algebraMap_eq_algebraMap_mul_of {A : Type*} [Semiring A] [Algebra k A] (a : G)
    (b : k) [MulSemiringAction G A] [SMulCommClass G k A] :
    single a (algebraMap k A b) = (algebraMap k (SkewMonoidAlgebra A G)) b * of A G a := by
  simp only [coe_algebraMap, comp_apply, of_apply, single_mul_single, one_mul, smul_one, mul_one]

end CommSemiring

end Algebra

section coeff_mul

-- We now prove some additional statements that hold for group algebras.
variable [Semiring k] [Group G] [MulSemiringAction G k]

@[simp]
theorem coeff_mul_single (f : SkewMonoidAlgebra k G) (r : k) (x y : G) :
    (f * single x r).coeff y = f.coeff (y * x⁻¹) * (y * x⁻¹) • r :=
  f.coeff_mul_single_aux fun _a => eq_mul_inv_iff_mul_eq.symm

@[simp]
theorem coeff_single_mul (r : k) (x : G) (f : SkewMonoidAlgebra k G) (y : G) :
    (single x r * f).coeff y = r * x • f.coeff (x⁻¹ * y) :=
  f.coeff_single_mul_aux fun _z => eq_inv_mul_iff_mul_eq.symm

theorem coeff_mul_left (f g : SkewMonoidAlgebra k G) (x : G) :
    (f * g).coeff x = f.sum fun a b => b * a • g.coeff (a⁻¹ * x) :=
  calc
    (f * g).coeff x = sum f fun a b => (single a b * g).coeff x := by
      rw [← coeff_sum, ← sum_mul g f, f.sum_single]
    _ = _ := by simp only [coeff_single_mul, Finsupp.sum]

theorem coeff_mul_right (f g : SkewMonoidAlgebra k G) (x : G) :
    (f * g).coeff x = g.sum fun a b => f.coeff (x * a⁻¹) * (x * a⁻¹) • b :=
  calc
    (f * g).coeff x = sum g fun a b => (f * single a b).coeff x := by
      rw [← coeff_sum, ← mul_sum f g, g.sum_single]
    _ = _ := by simp only [coeff_mul_single, Finsupp.sum]

end coeff_mul

section CommMonoid

instance commSemiring [CommSemiring k] [CommMonoid G] [MulSemiringAction G k]
    [SMulCommClass G k k] : CommSemiring (SkewMonoidAlgebra k G) where
  mul_comm := by
    intro a b
    simp only [mul_def]
    have hgk (g : G) (r : k) : g • r = r := by
      rw [← Algebra.id.map_eq_self r, smul_algebraMap g r]
    simp_rw [hgk, toFinsupp_sum]
    rw [Finsupp.sum_comm]
    apply Finsupp.sum_congr
    intro x _
    apply Finsupp.sum_congr
    intro y _
    rw [mul_comm, mul_comm (a.toFinsupp y) _]

end CommMonoid

end SkewMonoidAlgebra

end
