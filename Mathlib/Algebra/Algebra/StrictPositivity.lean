/-
Copyright (c) 2025 Frédéric Dupuis. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Frédéric Dupuis
-/

import Mathlib.Algebra.Algebra.Spectrum.Quasispectrum
import Mathlib.Algebra.Order.Star.Basic
import Mathlib.Algebra.Order.Module.Defs
import Mathlib.Tactic.ContinuousFunctionalCalculus

/-!
# Strictly positive elements of a C⋆-algebra

This file introduces strictly positive elements of a C⋆-algebra (also known as positive definite
elements).

## Implementation notes

Note that, while the current definition is adequate in the unital case, it will eventually be
replaced by a definition that makes sense in the non-unital case (an element is strictly
positive if the hereditary C⋆-subalgebra generated by that element is the whole algebra).
Thus, it is best to avoid unfolding the definition and only use the API provided.

## TODO

+ Generalize the definition to non-unital algebras.
-/

/-- An element of a C⋆-algebra is *strictly positive* if it is nonnegative and invertible.

NOTE: This definition will be generalized to the non-unital case in the future; do not unfold
the definition and use the API provided instead to avoid breakage when the refactor happens. -/
def IsStrictlyPositive {A : Type*} [LE A] [Ring A] (a : A) : Prop :=
  0 ≤ a ∧ IsUnit a

variable {A : Type*}

namespace IsStrictlyPositive

section basic

variable [PartialOrder A] [Ring A]

@[grind =]
lemma iff_of_unital {a : A} : IsStrictlyPositive a ↔ 0 ≤ a ∧ IsUnit a := Iff.rfl

@[aesop 20% apply (rule_sets := [CStarAlgebra])]
protected lemma nonneg {a : A} (ha : IsStrictlyPositive a) : 0 ≤ a := ha.1

@[aesop 20% apply (rule_sets := [CStarAlgebra])]
protected lemma isUnit {a : A} (ha : IsStrictlyPositive a) : IsUnit a := ha.2

lemma _root_.IsUnit.isStrictlyPositive {a : A} (ha : IsUnit a) (ha₀ : 0 ≤ a) :
    IsStrictlyPositive a := ⟨ha₀, ha⟩

@[grind →]
lemma isSelfAdjoint [StarRing A] [StarOrderedRing A] {a : A} (ha : IsStrictlyPositive a) :
    IsSelfAdjoint a := by cfc_tac

end basic

section Algebra

variable {𝕜 : Type*} [Semifield 𝕜] [PartialOrder 𝕜] [Ring A] [PartialOrder A] [Algebra 𝕜 A]

@[grind ←, aesop safe apply]
protected lemma smul [PosSMulMono 𝕜 A] {c : 𝕜} (hc : 0 < c) {a : A} (ha : IsStrictlyPositive a) :
    IsStrictlyPositive (c • a) := by
  have hunit : IsUnit (c • a) := by
    rw [isUnit_iff_exists]
    refine ⟨c⁻¹ • ha.isUnit.unit⁻¹, ?_⟩
    have h₁ : c * c⁻¹ = 1 := mul_inv_cancel₀ (ne_of_lt hc).symm
    have h₂ : c⁻¹ * c = 1 := inv_mul_cancel₀ (ne_of_lt hc).symm
    simp [smul_smul, h₁, h₂]
  have hnonneg : 0 ≤ c • a := smul_nonneg hc.le ha.1
  exact hunit.isStrictlyPositive hnonneg

lemma spectrum_pos [NonnegSpectrumClass 𝕜 A] {a : A} (ha : IsStrictlyPositive a) {x : 𝕜}
    (hx : x ∈ spectrum 𝕜 a) : 0 < x := by
  have h₁ : 0 ≤ x := by grind
  have h₂ : x ≠ 0 := by grind [= spectrum.zero_notMem_iff]
  exact lt_of_le_of_ne h₁ (id (Ne.symm h₂))

grind_pattern IsStrictlyPositive.spectrum_pos => x ∈ spectrum 𝕜 a, IsStrictlyPositive a

end Algebra

end IsStrictlyPositive

/-
TODO:
+ Depend only on `NonnegSpectrumClass`
+ Add stuff to `Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unital`
-/
