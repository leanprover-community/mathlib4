/-
Copyright (c) 2025 Fr√©d√©ric Dupuis. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Fr√©d√©ric Dupuis
-/

import Mathlib.Algebra.Algebra.Spectrum.Quasispectrum
import Mathlib.Algebra.Order.Star.Basic
import Mathlib.Algebra.Order.Module.Defs
import Mathlib.Tactic.ContinuousFunctionalCalculus

/-!
# Strictly positive elements of an algebra

This file introduces strictly positive elements of an algebra (also known as positive definite
elements). This is mostly used for C‚ãÜ-algebras, but the basic definition makes sense in a more
general context.

## Implementation notes

Note that, while the current definition is adequate in the unital case, it will eventually be
replaced by a definition that makes sense in the non-unital case (an element is strictly
positive if the hereditary C‚ãÜ-subalgebra generated by that element is the whole algebra).
Thus, it is best to avoid unfolding the definition and only use the API provided.

## TODO

+ Generalize the definition to non-unital algebras.
-/

/-- An element of an ordered algebra is *strictly positive* if it is nonnegative and invertible.

NOTE: This definition will be generalized to the non-unital case in the future; do not unfold
the definition and use the API provided instead to avoid breakage when the refactor happens. -/
def IsStrictlyPositive {A : Type*} [LE A] [Monoid A] [Zero A] (a : A) : Prop :=
  0 ‚â§ a ‚àß IsUnit a

variable {A : Type*}

namespace IsStrictlyPositive

section basic

@[grind =]
lemma iff_of_unital [LE A] [Monoid A] [Zero A] {a : A} :
    IsStrictlyPositive a ‚Üî 0 ‚â§ a ‚àß IsUnit a := Iff.rfl

@[aesop 20% apply (rule_sets := [CStarAlgebra])]
protected lemma nonneg [LE A] [Monoid A] [Zero A] {a : A} (ha : IsStrictlyPositive a) :
    0 ‚â§ a := ha.1

@[aesop 20% apply (rule_sets := [CStarAlgebra])]
protected lemma isUnit [LE A] [Monoid A] [Zero A] {a : A} (ha : IsStrictlyPositive a) :
    IsUnit a := ha.2

lemma _root_.IsUnit.isStrictlyPositive [LE A] [Monoid A] [Zero A]
    {a : A} (ha : IsUnit a) (ha‚ÇÄ : 0 ‚â§ a) : IsStrictlyPositive a := iff_of_unital.mpr ‚ü®ha‚ÇÄ, ha‚ü©

@[grind ‚Üí]
lemma isSelfAdjoint [Semiring A] [PartialOrder A] [StarRing A] [StarOrderedRing A] {a : A}
    (ha : IsStrictlyPositive a) : IsSelfAdjoint a := ha.nonneg.isSelfAdjoint

@[simp, grind]
lemma _root_.isStrictlyPositive_one [LE A] [Monoid A] [Zero A] [ZeroLEOneClass A] :
    IsStrictlyPositive (1 : A) := iff_of_unital.mpr ‚ü®zero_le_one, isUnit_one‚ü©

end basic

section StarOrderedRing
variable [Semiring A] [StarRing A] [PartialOrder A] [StarOrderedRing A]

lemma _root_.IsUnit.isStrictlyPositive_conjugate_iff {u a : A} (hu : IsUnit u) :
    IsStrictlyPositive (u * a * star u) ‚Üî IsStrictlyPositive a := by
  simp_rw [IsStrictlyPositive.iff_of_unital, hu.conjugate_nonneg_iff]
  lift u to AÀ£ using hu
  rw [‚Üê Units.coe_star, Units.isUnit_mul_units, Units.isUnit_units_mul]

lemma _root_.IsUnit.isStrictlyPositive_conjugate_iff' {u a : A} (hu : IsUnit u) :
    IsStrictlyPositive (star u * a * u) ‚Üî IsStrictlyPositive a := by
  simpa using hu.star.isStrictlyPositive_conjugate_iff

end StarOrderedRing

section Algebra

variable {ùïú : Type*} [Ring A] [PartialOrder A]

@[grind ‚Üê, aesop safe apply]
protected lemma smul [Semifield ùïú] [PartialOrder ùïú] [Algebra ùïú A] [PosSMulMono ùïú A] {c : ùïú}
    (hc : 0 < c) {a : A} (ha : IsStrictlyPositive a) :
    IsStrictlyPositive (c ‚Ä¢ a) := by
  have hunit : IsUnit (c ‚Ä¢ a) :=
    isUnit_iff_exists.mpr ‚ü®c‚Åª¬π ‚Ä¢ ha.isUnit.unit‚Åª¬π, by simp [(ne_of_lt hc).symm]‚ü©
  exact hunit.isStrictlyPositive (smul_nonneg hc.le ha.nonneg)

@[grind ‚Üê, aesop safe apply]
lemma _root_.isStrictlyPositive_algebraMap [ZeroLEOneClass A] [Semifield ùïú] [PartialOrder ùïú]
    [Algebra ùïú A] [PosSMulMono ùïú A] {c : ùïú} (hc : 0 < c) :
    IsStrictlyPositive (algebraMap ùïú A c) := by
  rw [Algebra.algebraMap_eq_smul_one]
  exact IsStrictlyPositive.smul hc isStrictlyPositive_one

lemma spectrum_pos [CommSemiring ùïú] [PartialOrder ùïú] [Algebra ùïú A]
    [NonnegSpectrumClass ùïú A] {a : A} (ha : IsStrictlyPositive a) {x : ùïú}
    (hx : x ‚àà spectrum ùïú a) : 0 < x := by
  have h‚ÇÅ : 0 ‚â§ x := by grind
  have h‚ÇÇ : x ‚â† 0 := by grind [= spectrum.zero_notMem_iff]
  exact lt_of_le_of_ne h‚ÇÅ h‚ÇÇ.symm

grind_pattern IsStrictlyPositive.spectrum_pos => x ‚àà spectrum ùïú a, IsStrictlyPositive a

end Algebra

end IsStrictlyPositive
