/-
Copyright (c) 2025 FrÃ©dÃ©ric Dupuis. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: FrÃ©dÃ©ric Dupuis
-/

import Mathlib.Algebra.Algebra.Spectrum.Quasispectrum
import Mathlib.Algebra.Order.Star.Basic
import Mathlib.Algebra.Order.Module.Defs
import Mathlib.Tactic.ContinuousFunctionalCalculus

/-!
# Strictly positive elements of a Câ‹†-algebra

This file introduces strictly positive elements of a Câ‹†-algebra (also known as positive definite
elements).

## Implementation notes

Note that, while the current definition is adequate in the unital case, it will eventually be
replaced by a definition that makes sense in the non-unital case (an element is strictly
positive if the hereditary Câ‹†-subalgebra generated by that element is the whole algebra).
Thus, it is best to avoid unfolding the definition and only use the API provided.

## TODO

+ Generalize the definition to non-unital algebras.
-/

/-- An element of a Câ‹†-algebra is *strictly positive* if it is nonnegative and invertible.

NOTE: This definition will be generalized to the non-unital case in the future; do not unfold
the definition and use the API provided instead to avoid breakage when the refactor happens. -/
def IsStrictlyPositive {A : Type*} [LE A] [Ring A] (a : A) : Prop :=
  0 â‰¤ a âˆ§ IsUnit a

variable {A : Type*}

namespace IsStrictlyPositive

section basic

variable [PartialOrder A] [Ring A]

@[grind =]
lemma iff_of_unital {a : A} : IsStrictlyPositive a â†” 0 â‰¤ a âˆ§ IsUnit a := Iff.rfl

@[aesop 20% apply (rule_sets := [CStarAlgebra])]
protected lemma nonneg {a : A} (ha : IsStrictlyPositive a) : 0 â‰¤ a := ha.1

@[aesop 20% apply (rule_sets := [CStarAlgebra])]
protected lemma isUnit {a : A} (ha : IsStrictlyPositive a) : IsUnit a := ha.2

lemma _root_.IsUnit.isStrictlyPositive {a : A} (ha : IsUnit a) (haâ‚€ : 0 â‰¤ a) :
    IsStrictlyPositive a := âŸ¨haâ‚€, haâŸ©

@[grind â†’]
lemma isSelfAdjoint [StarRing A] [StarOrderedRing A] {a : A} (ha : IsStrictlyPositive a) :
    IsSelfAdjoint a := by cfc_tac

end basic

section Algebra

variable {ğ•œ : Type*} [Semifield ğ•œ] [PartialOrder ğ•œ] [Ring A] [PartialOrder A] [Algebra ğ•œ A]

@[grind â†, aesop safe apply]
protected lemma smul [PosSMulMono ğ•œ A] {c : ğ•œ} (hc : 0 < c) {a : A} (ha : IsStrictlyPositive a) :
    IsStrictlyPositive (c â€¢ a) := by
  have hunit : IsUnit (c â€¢ a) := by
    rw [isUnit_iff_exists]
    refine âŸ¨câ»Â¹ â€¢ ha.isUnit.unitâ»Â¹, ?_âŸ©
    have hâ‚ : c * câ»Â¹ = 1 := mul_inv_cancelâ‚€ (ne_of_lt hc).symm
    have hâ‚‚ : câ»Â¹ * c = 1 := inv_mul_cancelâ‚€ (ne_of_lt hc).symm
    simp [smul_smul, hâ‚, hâ‚‚]
  have hnonneg : 0 â‰¤ c â€¢ a := smul_nonneg hc.le ha.1
  exact hunit.isStrictlyPositive hnonneg

lemma spectrum_pos [NonnegSpectrumClass ğ•œ A] {a : A} (ha : IsStrictlyPositive a) {x : ğ•œ}
    (hx : x âˆˆ spectrum ğ•œ a) : 0 < x := by
  have hâ‚ : 0 â‰¤ x := by grind
  have hâ‚‚ : x â‰  0 := by grind [= spectrum.zero_notMem_iff]
  exact lt_of_le_of_ne hâ‚ (id (Ne.symm hâ‚‚))

grind_pattern IsStrictlyPositive.spectrum_pos => x âˆˆ spectrum ğ•œ a, IsStrictlyPositive a

end Algebra

end IsStrictlyPositive

/-
TODO:
+ Depend only on `NonnegSpectrumClass`
+ Add stuff to `Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unital`
-/
