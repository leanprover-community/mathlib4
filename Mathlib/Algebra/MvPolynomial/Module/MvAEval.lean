/-
Copyright (c) 2024 Brendan Murphy. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Brendan Murphy
-/
import Mathlib.Algebra.MvPolynomial.Basic
import Mathlib.RingTheory.Finiteness

/-!
# Action of the multivariate polynomial ring on a module induced by elements of an algebra.

Given an interpretation `T : σ → A` of our variables in a commutative
`R`-algebra `A` and an `A`-module `M` we define an `MvPolynomial σ R`-module
`Module.MvAEval R M T`, which is a type synonym of `M` with the action of a
polynomial `f` given by `f • m = MvPolynomial.aeval T f • m`.
In particular `X i • m = T i • m`.

As a special case of this, given an `A`-module `M`, a family of endomorphisms
`Φ : σ → M →ₗ[R] M`, and a proof `h` that the `Φ i` pairwise commute we define
a type synonym `Module.MvAEval' Φ h` for `M` carrying the `MvPolynomial σ R`-module
structure in which `X i • m = Φ i m`. Since the endomorphism ring is in general
not a commutative algebra we must pass the subring of it generated by the `Φ i`.
In order to define a commutative algebra structure on this we need to include
the proof `h` at the type level, which is why we use the auxilliary definition
`MvAEval'.auxRing`.
-/

open Set Function MvPolynomial

namespace Module
/--
Suppose `σ` is an indexing type, `T : σ → A` a `σ`-indexed family of elements
of an `R`-algebra `A` and `M` is an `A`-module. Loosely speaking,
`Module.MvAEval R M T` is the `MvPolynomial σ R`-module with elements `m : M`,
where the action of a polynomial $f$ is given by $f • m = f(X i ↦ T i) • m$.

More precisely, `Module.MvAEval R M T` has elements `Module.MvAEval.of R M T m`
for `m : M`, and the action of `f` is `f • of R M T m = of R M T (aeval T f • m)`.
-/
@[nolint unusedArguments]
def MvAEval (R M : Type*) {A σ : Type*} [CommSemiring R] [CommSemiring A] [Algebra R A]
    [AddCommMonoid M] [Module A M] [Module R M] [IsScalarTower R A M] (_ : σ → A) := M

instance MvAEval.instAddCommGroup {R A M σ} [CommSemiring R] [CommSemiring A]
    (T : σ → A) [Algebra R A] [AddCommGroup M] [Module A M] [Module R M]
    [IsScalarTower R A M] : AddCommGroup <| MvAEval R M T :=
  inferInstanceAs (AddCommGroup M)

variable {R A M σ} [CommSemiring R] [CommSemiring A] (T : σ → A) [Algebra R A]
  [AddCommMonoid M] [Module A M] [Module R M] [IsScalarTower R A M]

namespace MvAEval

instance instAddCommMonoid : AddCommMonoid <| MvAEval R M T := inferInstanceAs (AddCommMonoid M)

instance instModuleOrig : Module R <| MvAEval R M T := inferInstanceAs (Module R M)

instance instFiniteOrig [Finite R M] : Finite R <| MvAEval R M T := inferInstanceAs (Finite R M)

instance instModulePolynomial : Module (MvPolynomial σ R) <| MvAEval R M T :=
  compHom M (aeval T).toRingHom

variable (R M) in
/--
The canonical linear equivalence between `M` and `Module.MvAEval R M a` as an `R`-module.
-/
def of : M ≃ₗ[R] MvAEval R M T :=
  LinearEquiv.refl _ _

lemma of_aeval_smul (f : MvPolynomial σ R) (m : M) :
    of R M T (aeval T f • m) = f • of R M T m := rfl

@[simp] lemma of_symm_smul (f : MvPolynomial σ R) (m : MvAEval R M T) :
    (of R M T).symm (f • m) = aeval T f • (of R M T).symm m := rfl

@[simp] lemma C_smul (c : R) (m : MvAEval R M T) :
    (C c : MvPolynomial σ R) • m = c • m :=
  (of R M T).symm.injective <| by simp

lemma X_smul_of (i : σ) (m : M) :
    (X i : MvPolynomial σ R) • (of R M T m) = of R M T (T i • m) := by
  rw [← of_aeval_smul, aeval_X]

lemma of_symm_X_smul (i : σ) (m : MvAEval R M T) :
    (of R M T).symm ((X i : MvPolynomial σ R) • m) = T i • (of R M T).symm m := by
  rw [of_symm_smul, aeval_X]

instance instIsScalarTowerOrigPolynomial :
    IsScalarTower R (MvPolynomial σ R) <| MvAEval R M T where
  smul_assoc r f m := by
    apply (of R M T).symm.injective
    rw [of_symm_smul, map_smul, smul_assoc, map_smul, of_symm_smul]

instance instFinitePolynomial [Finite R M] : Finite (MvPolynomial σ R) <| MvAEval R M T :=
  Finite.of_restrictScalars_finite R _ _

/-- Construct an `MvPolynomial σ R`-linear map out of `MvAEval R M T` from a
`R`-linear map out of `M`. -/
def _root_.LinearMap.ofMvAEval {N} [AddCommMonoid N] [Module R N]
    [Module (MvPolynomial σ R) N] [IsScalarTower R (MvPolynomial σ R) N]
    (f : M →ₗ[R] N) (hf : ∀ i m, f (T i • m) = (X i : MvPolynomial σ R) • f m) :
    MvAEval R M T →ₗ[MvPolynomial σ R] N where
  __ := f ∘ₗ (of R M T).symm
  map_smul' p m := by
    dsimp
    induction' p using induction_on generalizing m
    <;> simp only [← algebraMap_eq, AlgHom.commutes, algebraMap_smul,
      map_smul, map_add, add_smul, map_mul, aeval_X, mul_smul]
    · congr <;> apply_assumption
    · rw [← hf, ← of_symm_X_smul]; apply_assumption

lemma annihilator_eq_ker_aeval [FaithfulSMul A M] :
    annihilator (MvPolynomial σ R) (MvAEval R M T) = RingHom.ker (aeval T) := by
  ext p
  simp_rw [mem_annihilator, RingHom.mem_ker]
  conv_lhs => change ∀ m : M, aeval T p • m = 0; intro m; rw [← zero_smul A m]
  exact Iff.trans Function.funext_iff.symm smul_left_injective'.eq_iff

@[simp]
lemma annihilator_top_eq_ker_aeval [FaithfulSMul A M] :
    (⊤ : Submodule (MvPolynomial σ R) <| MvAEval R M T).annihilator =
      RingHom.ker (aeval T) :=
  Eq.trans (Submodule.annihilator_top) (annihilator_eq_ker_aeval T)

section Submodule

variable {p : Submodule R M} (hp : ∀ i, p ≤ p.comap (Algebra.lsmul R R M (T i)))
  {q : Submodule (MvPolynomial σ R) <| MvAEval R M T}

variable (R M) in
/-- We can turn an `MvPolynomial σ R`-submodule into an `R`-submodule by
forgetting the action of `X`. -/
def comapSubmodule :
    CompleteLatticeHom (Submodule (MvPolynomial σ R) <| MvAEval R M T) (Submodule R M) :=
  (Submodule.orderIsoMapComap (of R M T)).symm.toCompleteLatticeHom.comp <|
    Submodule.restrictScalarsLatticeHom R (MvPolynomial σ R) (MvAEval R M T)

@[simp] lemma mem_comapSubmodule {x : M} :
    x ∈ comapSubmodule R M T q ↔ of R M T x ∈ q :=
  Iff.rfl

@[simp] lemma comapSubmodule_le_comap (i : σ) :
    comapSubmodule R M T q ≤
      (comapSubmodule R M T q).comap (Algebra.lsmul R R M (T i)) := by
  intro m hm
  simpa only [Submodule.mem_comap, Algebra.lsmul_coe, mem_comapSubmodule,
    ← X_smul_of] using q.smul_mem (X i) hm

/-- An `R`-submodule which is stable under the actions of the `T i` can be
promoted to an `MvPolynomial σ R`-submodule. -/
def mapSubmodule : Submodule (MvPolynomial σ R) <| MvAEval R M T :=
  { toAddSubmonoid := p.toAddSubmonoid.map (of R M T)
    smul_mem' := by
      rintro f - ⟨m : M, h : m ∈ p, rfl⟩
      simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,
        AddSubmonoid.mem_map, Submodule.mem_toAddSubmonoid]
      refine ⟨aeval T f • m, ?_, of_aeval_smul T f m⟩
      induction' f using induction_on with r f g hf hg f i ih generalizing m
      <;> simp only [aeval_C, aeval_X, algebraMap_smul,
        map_add, map_mul, add_smul, mul_smul]
      · exact p.smul_mem r h
      · exact p.add_mem (hf m h) (hg m h)
      · exact ih (T i • m) (hp i h) }

@[simp] lemma mem_mapSubmodule {m : MvAEval R M T} :
    m ∈ mapSubmodule T hp ↔ (of R M T).symm m ∈ p :=
  ⟨fun ⟨_, hm, hm'⟩ ↦ hm'.symm ▸ hm, fun hm ↦ ⟨(of R M T).symm m, hm, rfl⟩⟩

@[simp] lemma mapSubmodule_comapSubmodule (h := comapSubmodule_le_comap T) :
    mapSubmodule T (p := comapSubmodule R M T q) h = q := by
  ext; simp

@[simp] lemma comapSubmodule_mapSubmodule :
    comapSubmodule R M T (mapSubmodule T hp) = p := by
  ext; simp

variable (R M)

lemma injective_comapSubmodule : Injective (comapSubmodule R M T) := by
  intro q₁ q₂ hq
  rw [← mapSubmodule_comapSubmodule (q := q₁), ← mapSubmodule_comapSubmodule (q := q₂)]
  simp_rw [hq]

lemma range_comapSubmodule :
    range (comapSubmodule R M T) = {p | ∀ i, p ≤ p.comap (Algebra.lsmul R R M (T i))} :=
  le_antisymm (fun _ ⟨_, hq⟩ ↦ hq ▸ comapSubmodule_le_comap T)
    (fun _ hp ↦ ⟨mapSubmodule T hp, comapSubmodule_mapSubmodule T hp⟩)

end Submodule

end MvAEval

section

/-- A type synonym for `Algebra.adjoin R (range Φ)`. Since the proof that
the various `Φ i` commute is in the type we can define a `CommSemiring` instance. -/
@[nolint unusedArguments]
def MvAEval'.auxRing (Φ : σ → M →ₗ[R] M) (_ : ∀ i j, Φ i ∘ₗ Φ j = Φ j ∘ₗ Φ i) :=
  Algebra.adjoin R (range Φ)

variable (Φ : σ → M →ₗ[R] M) (h : ∀ i j, Φ i ∘ₗ Φ j = Φ j ∘ₗ Φ i)

instance : CommSemiring (MvAEval'.auxRing Φ h) :=
  Algebra.adjoinCommSemiringOfComm R <| by
    simpa only [mem_range, forall_exists_index, forall_apply_eq_imp_iff]

/--
Given an `R`-module `M`, a family of linear maps `Φ : σ → M →ₗ[R] M`, and a
proof `h` that the maps in the family pairwise commute, `Module.MvAEval' Φ h`
is loosely speaking the `MvPolynomial σ R`-module with elements `m : M`, where
the action of a polynomial $f$ is given by $f • m = f(X i ↦ Φ i) • m$.
We can't define this directly in terms of `MvEval` and `Φ` like in the
univariate case, since `aeval` for multivariate polynomials only works for
commutative algebras (the univariate polynomial ring is the free algebra on one
generator, but the multivariate polynomial ring on `σ` is only the free
*commutative* algebra on `σ`). So we use `aeval` with `Φ` modified so that its
codomain is restricted to the `R`-subalgebra of `M →ₗ[R] M` generated by `Φ`.

`Module.MvAEval'` is defined as a special case of `Module.MvAEval` in which the
`R`-algebra is `Algebra.adjoin R (range Φ)`. We use a type synonym
`MvAEval'.auxRing Φ h` which includes the proof `h` so that a `CommSemiring`
instance may be defined. -/
abbrev MvAEval' := MvAEval R M (A := MvAEval'.auxRing Φ h) <|
  Subtype.coind Φ fun i => Algebra.subset_adjoin <| Set.mem_range_self i

namespace MvAEval'

/--
A more explicit version of `MvAEval.of`.
-/
abbrev of' : M ≃ₗ[R] MvAEval' Φ h := MvAEval.of R M _

variable {h}

/--
The canonical linear equivalence between `M` and `Module.MvAEval' h` as an `R`-module.
-/
abbrev of : M ≃ₗ[R] MvAEval' Φ h := of' Φ h

variable {Φ}

lemma X_smul_of (i : σ) (m : M) :
    (X i : MvPolynomial σ R) • (of Φ m : MvAEval' Φ h) = of Φ (Φ i m) :=
  letI := Fact.mk h; MvAEval.X_smul_of _ i m

lemma of_symm_X_smul (i : σ) (m : MvAEval' Φ h) :
    (of Φ).symm ((X i : MvPolynomial σ R) • m) = Φ i ((of Φ).symm m) :=
  letI := Fact.mk h; MvAEval.of_symm_X_smul _ i m

end MvAEval'

end

end Module
