/-
Copyright (c) 2025 Scott Carnahan. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Carnahan
-/
module

public import Mathlib.Algebra.MvPolynomial.Funext
public import Mathlib.RingTheory.Binomial

/-!
## Multivariate polynomials with restricted values

In this file we define rings of restricted-value polynomials, namely those that take values in a
subring of the coefficient ring, when evaluated at the subring. The main example is the subring of
rational polynomials that take integer values on integer inputs, which is generated by elements of
the form `Ring.choose (X i) n`.

# Main declaration

* `MvPolynomial.restrictedValue`: A polynomial `φ ψ : MvPolynomial σ S` is `R`-valued if
evaluation at elements of `R` yields an element of `R`.

-/

@[expose] public section

namespace MvPolynomial

variable {σ : Type*}

/-- The subring of multiple-variable polynomials with coefficients in `S` that take values in a
subring `R` when evaluated at elements of `R`. -/
def restrictedValue (σ) (R S : Type*) [CommRing R] [CommRing S] [Algebra R S] :
    Subring (MvPolynomial σ S) where
  carrier := {f | ∀ g : σ → R, eval ((algebraMap R S) ∘ g) f ∈ (algebraMap R S).range}
  mul_mem' hx hy := by
    intro g
    obtain ⟨x0, hx0⟩ := RingHom.mem_range.mp (hx g)
    obtain ⟨y0, hy0⟩ := RingHom.mem_range.mp (hy g)
    use x0 * y0
    simp [hx0, hy0]
  one_mem' := by
    simp only [RingHom.mem_range, Set.mem_setOf_eq, map_one, forall_const]
    use 1
    exact algebraMap.coe_one
  add_mem' hx hy := by
    intro g
    obtain ⟨x0, hx0⟩ := RingHom.mem_range.mp (hx g)
    obtain ⟨y0, hy0⟩ := RingHom.mem_range.mp (hy g)
    use x0 + y0
    simp [hx0, hy0]
  zero_mem' := by
    simp only [RingHom.mem_range, Set.mem_setOf_eq, map_zero, forall_const]
    use 0
    exact algebraMap.coe_zero
  neg_mem' hx := by
    intro g
    obtain ⟨x0, hx0⟩ := RingHom.mem_range.mp (hx g)
    use -x0
    simp [hx0]

section IntegerValued

lemma eval_choose (i : σ) (n : ℕ) (g : σ → ℤ) :
    eval ((algebraMap ℤ ℚ) ∘ g) (Ring.choose (X i : MvPolynomial σ ℚ) n) =
      (algebraMap ℤ ℚ) (Ring.choose (g i) n) := by
  simp [Ring.map_choose]

lemma choose_mem_restrictedValue (i : σ) (n : ℕ) :
    (Ring.choose (X i) n) ∈ restrictedValue σ ℤ ℚ := by
  intro g
  rw [eval_choose]
  exact RingHom.mem_range_self (algebraMap ℤ ℚ) (Ring.choose (g i) n)

lemma choose_eq (i : σ) (n : ℕ) :
    (Ring.choose (X i : MvPolynomial σ ℚ) n) =
    (n.factorial : ℚ)⁻¹ • rename (fun () ↦ i) ((pUnitAlgEquiv ℚ).symm (descPochhammer ℚ n)) := by
  have := IsAddTorsionFree.of_module_rat (MvPolynomial σ ℚ)
  apply (nsmul_right_inj (Nat.factorial_ne_zero n)).mp
  rw [← Ring.descPochhammer_eq_factorial_smul_choose, pUnitAlgEquiv_symm_apply, ← smul_assoc]
  have : n.factorial • (n.factorial : ℚ)⁻¹ = 1 := by
    rw [nsmul_eq_mul', inv_mul_eq_div]
    field_simp
  rw [this, one_smul, Polynomial.eval₂_eq_sum, Polynomial.smeval_eq_sum, Polynomial.sum_def,
    Polynomial.sum_def]
  simp only [Polynomial.smul_pow, zsmul_eq_mul, map_sum, map_mul, algHom_C, algebraMap_eq, map_pow,
    rename_X]
  refine Finset.sum_bijective id Function.bijective_id ?_ ?_
  · intro j
    simp only [Polynomial.mem_support_iff, id_eq]
    rw [← descPochhammer_coeff_map (algebraMap ℤ ℚ), algebraMap_int_eq, eq_intCast]
    exact Int.cast_ne_zero.symm
  · intro j h
    rw [C_mul', id_eq, ← descPochhammer_coeff_map (algebraMap ℤ ℚ), algebraMap_int_eq, eq_intCast,
      ← smul_eq_mul]
    norm_cast

lemma choose_support [DecidableEq σ] (i : σ) (n : ℕ) :
    (Ring.choose (X i : MvPolynomial σ ℚ) n).support ⊆
      Finset.image (fun d ↦ Finsupp.single i d) (Finset.range (n + 1)) := by
  intro g hg
  simp only [choose_eq, pUnitAlgEquiv_symm_apply, mem_support_iff, coeff_smul, smul_eq_mul, ne_eq,
    mul_eq_zero, inv_eq_zero, Nat.cast_eq_zero, not_or] at hg
  let h := hg.2
  rw [← ne_eq, ← mem_support_iff, support_rename_of_injective (fun ⦃_ _⦄ ↦ congrFun rfl),
    Finset.mem_image] at h
  swap; · exact i
  obtain ⟨d, hd₁, hd₂⟩ := h
  simp only [Finset.mem_image, Finset.mem_range]
  use d ()
  constructor
  · rw [mem_support_iff, coeff_eval₂_pUnit, ← Polynomial.mem_support_iff] at hd₁
    have := Polynomial.le_natDegree_of_mem_supp (d ()) hd₁
    rw [descPochhammer_natDegree] at this
    exact Order.lt_add_one_iff.mpr this
  · rw [← hd₂]
    ext j
    by_cases hij : i = j
    · simp only [hij, Finsupp.single_eq_same, Finsupp.mapDomain, Finsupp.sum,
        Finsupp.coe_finset_sum, Finset.sum_apply, Finsupp.single_eq_same]
      rw [Finset.sum_eq_single () (fun _ _ h ↦ (by simp at h))]
      exact fun h ↦ Finsupp.notMem_support_iff.mp h
    · simp [hij, Finsupp.mapDomain]

end IntegerValued
/-
lemma leadingCoeff_of_choose [LinearOrder σ] (i : σ) (n : ℕ) :
    (Ring.choose (X i : MvPolynomial σ ℚ) n).leadingCoeff toLex = (n.factorial : ℚ)⁻¹ := by
  rw [leadingCoeff_toLex]
  sorry


lemma leadingCoeff_of_choose_prod [LinearOrder σ] (n : σ →₀ ℕ) :
    (∏ i ∈ n.support, Ring.choose (X i : MvPolynomial σ ℚ) (n i)).leadingCoeff toLex =
      ∏ i ∈ n.support, ((n i).factorial : ℚ)⁻¹ := by
  rw [@leadingCoeff_toLex]

  sorry


lemma restrictedValue_subset_span_choose [LinearOrder σ] (p : restrictedValue σ ℤ ℚ) :
    AddMonoidAlgebra.supDegree toLex (p.val - (p.val.leadingCoeff toLex) •
      ∏ i ∈ (AddMonoidAlgebra.supDegree toLex p.val).support,
        Ring.choose (X i : MvPolynomial σ ℚ) ((AddMonoidAlgebra.supDegree toLex p.val) i)) <
      AddMonoidAlgebra.supDegree toLex p.val := by

  sorry

/-- The ring of integer-valued polynomials is generated by binomial coefficients in variables. -/
lemma integerValued_iff :
    restrictedValue σ ℤ ℚ =
      Subring.closure {Ring.choose (X i : MvPolynomial σ ℚ) n | (i : σ) (n : ℕ)} := by
  sorry
-/
end MvPolynomial
