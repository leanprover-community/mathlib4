/-
Copyright (c) 2024 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathlib.Algebra.Category.ModuleCat.Presheaf.Pullback
import Mathlib.Algebra.Category.ModuleCat.Differentials.Basic
import Mathlib.Algebra.Category.Ring.Constructions

/-!
# The presheaf of differentials

In this file, we define the type `M.Derivation œÜ` of derivations
with values in a presheaf of `R`-modules `M` relative to
a morphism of `œÜ : S ‚ü∂ F.op ‚ãô R` of presheaves of commutative rings
over categories `C` and `D` that are related by a functor `F : C ‚•§ D`.
We formalize the notion of universal derivation.

Geometrically, if `f : X ‚ü∂ S` is a morphisms of schemes (or more generally
a morphism of commutative ringed spaces), we would like to apply
these definitions in the case where `F` is the pullback functors from
open subsets of `S` to open subsets of `X` and `œÜ` is the
morphism $O_S ‚ü∂ f_* O_X$.

In order to prove that there exists a universal derivation, the target
of which shall be called the presheaf of relative differentials of `œÜ`,
we first study the case where `F` is the identity functor.
In this case where we have a morphism of presheaves of commutative
rings `œÜ' : S' ‚ü∂ R`, we construct a derivation
`DifferentialsConstruction.derivation'` which is universal.
Then, the general case (TODO) shall be obtained by observing that
derivations for `S ‚ü∂ F.op ‚ãô R` identify to derivations
for `S' ‚ü∂ R` where `S'` is the pullback by `F` of the presheaf of
commutative rings `S` (the data is the same: it suffices
to show that the two vanishing conditions `d_app` are equivalent).

-/

universe v u v‚ÇÅ v‚ÇÇ v‚ÇÉ u‚ÇÅ u‚ÇÇ u‚ÇÉ

open CategoryTheory Limits

variable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D]
  {E : Type u‚ÇÉ} [Category.{v‚ÇÉ} E]

namespace PresheafOfModules

variable {S : C·µí·µñ ‚•§ CommRingCat.{u}} {F : C ‚•§ D} {G : D ‚•§ E}
  {S' R : D·µí·µñ ‚•§ CommRingCat.{u}} {T : E·µí·µñ ‚•§ CommRingCat.{u}}
  (M N : PresheafOfModules.{v} (R ‚ãô forget‚ÇÇ _ _))
  (œÜ : S ‚ü∂ F.op ‚ãô R) (œÜ' : S' ‚ü∂ R)

/-- Given a morphism of presheaves of commutative rings `œÜ : S ‚ü∂ F.op ‚ãô R`,
this is the type of relative `œÜ`-derivation of a presheaf of `R`-modules `M`. -/
@[ext]
structure Derivation where
  /-- the underlying additive map `R.obj X ‚Üí+ M.obj X` of a derivation -/
  d {X : D·µí·µñ} : R.obj X ‚Üí+ M.obj X
  d_mul {X : D·µí·µñ} (a b : R.obj X) : d (a * b) = a ‚Ä¢ d b + b ‚Ä¢ d a := by aesop_cat
  d_map {X Y : D·µí·µñ} (f : X ‚ü∂ Y) (x : R.obj X) :
    d (R.map f x) = M.map f (d x) := by aesop_cat
  d_app {X : C·µí·µñ} (a : S.obj X) : d (œÜ.app X a) = 0 := by aesop_cat

namespace Derivation

-- Note: `d_app` cannot be a simp lemma because `dsimp` would
-- simplify the composition of functors `R ‚ãô forget‚ÇÇ _ _`
attribute [simp] d_mul d_map

section AddCommGroup

instance : Zero (M.Derivation œÜ) where
  zero := { d := 0 }

@[simp] lemma zero_d_apply {X : D·µí·µñ} (x : R.obj X) :
    (0 : M.Derivation œÜ).d x = 0 := rfl

variable {M œÜ}

instance : Neg (M.Derivation œÜ) where
  neg d :=
    { d := -d.d
      d_mul := fun a b ‚Ü¶ by dsimp; simp only [d_mul, smul_neg]; abel
      d_app := by intros; dsimp; rw [neg_eq_zero]; apply d_app }

@[simp] lemma neg_d_apply (d : M.Derivation œÜ) {X : D·µí·µñ} (x : R.obj X) :
    (-d).d x = -d.d x := rfl

instance : Add (M.Derivation œÜ) where
  add d‚ÇÅ d‚ÇÇ :=
    { d := d‚ÇÅ.d + d‚ÇÇ.d
      d_mul := by intros; dsimp; simp only [d_mul, smul_add]; abel
      d_map := by simp
      d_app := fun _ ‚Ü¶ by
        dsimp
        erw [d_app, d_app, add_zero] }

@[simp] lemma add_d_apply (d d' : M.Derivation œÜ) {X : D·µí·µñ} (x : R.obj X) :
    (d + d').d x = d.d x + d'.d x := rfl

instance : Sub (M.Derivation œÜ) where
  sub d‚ÇÅ d‚ÇÇ :=
    { d := d‚ÇÅ.d - d‚ÇÇ.d
      d_mul := by intros; dsimp; simp only [d_mul, smul_sub]; abel
      d_map := by simp
      d_app := fun _ ‚Ü¶ by
        dsimp
        erw [d_app, d_app, sub_zero] }

@[simp] lemma sub_d_apply (d d' : M.Derivation œÜ) {X : D·µí·µñ} (x : R.obj X) :
    (d - d').d x = d.d x - d'.d x := rfl

instance : AddCommGroup (M.Derivation œÜ) where
  add_assoc _ _ _ := by ext; dsimp; rw [add_assoc]
  zero_add _ := by ext; dsimp; rw [zero_add]
  add_zero _ := by ext; dsimp; rw [add_zero]
  neg_add_cancel _ := by ext; dsimp; rw [neg_add_cancel]
  add_comm _ _ := by ext; dsimp; rw [add_comm]
  sub_eq_add_neg _ _ := by ext; dsimp; rw [sub_eq_add_neg]
  nsmul := nsmulRec
  zsmul := zsmulRec

end AddCommGroup

variable {M N œÜ}

lemma congr_d {d d' : M.Derivation œÜ} (h : d = d') {X : D·µí·µñ} (b : R.obj X) :
    d.d b = d'.d b := by rw [h]

variable (d : M.Derivation œÜ)

@[simp] lemma d_one (X : D·µí·µñ) : d.d (X := X) 1 = 0 := by
  simpa using d.d_mul (X := X) 1 1

lemma d_zsmul (n : ‚Ñ§) {X : D·µí·µñ} (x : R.obj X) : d.d (n ‚Ä¢ x) = n ‚Ä¢ d.d x := by
  rw [map_zsmul]

@[simp]
lemma d_int_eq_zero (X : D·µí·µñ) (n : ‚Ñ§) : d.d (X := X) n = 0 := by
  trans d.d (n ‚Ä¢ 1)
  ¬∑ simp
  ¬∑ rw [d_zsmul, d_one, zsmul_zero]

@[simp]
lemma d_ulift_int_eq_zero (X : D·µí·µñ) (f : CommRingCat.of (ULift.{u} ‚Ñ§) ‚ü∂ R.obj X)
    (n : ULift.{u} ‚Ñ§) :
    d.d (X := X) (f n) = 0 := by
  obtain rfl := CommRingCat.isInitial.hom_ext f
    ((Int.castRingHom _).comp ULift.ringEquiv.toRingHom)
  apply d_int_eq_zero

/-- The postcomposition of a derivation by a morphism of presheaves of modules. -/
@[simps! d_apply]
def postcomp (f : M ‚ü∂ N) : N.Derivation œÜ where
  d := (f.app _).hom.toAddMonoidHom.comp d.d
  d_map {X Y} g x := by simpa using naturality_apply f g (d.d x)
  d_app {X} a := by
    dsimp
    erw [d_app, map_zero]

variable (N) in
@[simp]
lemma postcomp_zero : d.postcomp (0 : _ ‚ü∂ N) = 0 := rfl

lemma postcomp_comp {P : PresheafOfModules.{v} (R ‚ãô forget‚ÇÇ _ _ )} (f : M ‚ü∂ N) (g : N ‚ü∂ P) :
    d.postcomp (f ‚â´ g) = (d.postcomp f).postcomp g := rfl

/-- The universal property that a derivation `d : M.Derivation œÜ` must
satisfy so that the presheaf of modules `M` can be considered as the presheaf of
(relative) differentials of a presheaf of commutative rings `œÜ : S ‚ü∂ F.op ‚ãô R`. -/
structure Universal where
  /-- An absolyte derivation of `M'` descends as a morphism `M ‚ü∂ M'`. -/
  desc {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ CommRingCat RingCat)}
    (d' : M'.Derivation œÜ) : M ‚ü∂ M'
  fac {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ CommRingCat RingCat)}
    (d' : M'.Derivation œÜ) : d.postcomp (desc d') = d' := by aesop_cat
  postcomp_injective {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ CommRingCat RingCat)}
    {œÜ œÜ' : M ‚ü∂ M'} (h : d.postcomp œÜ = d.postcomp œÜ') : œÜ = œÜ' := by aesop_cat

attribute [simp] Universal.fac

instance : Subsingleton d.Universal where
  allEq h‚ÇÅ h‚ÇÇ := by
    suffices ‚àÄ {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ CommRingCat RingCat)}
      (d' : M'.Derivation œÜ), h‚ÇÅ.desc d' = h‚ÇÇ.desc d' by
        cases h‚ÇÅ
        cases h‚ÇÇ
        simp only [Universal.mk.injEq]
        ext : 2
        apply this
    intro M' d'
    apply h‚ÇÅ.postcomp_injective
    simp

namespace Universal

variable {d} (hd : d.Universal)

@[simp]
lemma desc_postcomp {M' : PresheafOfModules.{v} (R ‚ãô forget‚ÇÇ CommRingCat RingCat)}
    (f : M ‚ü∂ M') : hd.desc (d.postcomp f) = f :=
  hd.postcomp_injective (by simp)

@[simps]
def homEquiv {M' : PresheafOfModules.{v} (R ‚ãô forget‚ÇÇ CommRingCat RingCat)} :
    (M ‚ü∂ M') ‚âÉ M'.Derivation œÜ where
  toFun f := d.postcomp f
  invFun d' := hd.desc d'
  left_inv f := by simp
  right_inv d' := by simp

lemma homEquiv_comp {M' M'' : PresheafOfModules.{v} (R ‚ãô forget‚ÇÇ CommRingCat RingCat)}
    (f : M ‚ü∂ M') (g : M' ‚ü∂ M'') :
    hd.homEquiv (f ‚â´ g) = (hd.homEquiv f).postcomp g := rfl

end Universal

end Derivation

/-- The property that there exists a universal derivation for
a morphism of presheaves of commutative rings `S ‚ü∂ F.op ‚ãô R`. -/
class HasDifferentials : Prop where
  exists_universal_derivation : ‚àÉ (M : PresheafOfModules.{u} (R ‚ãô forget‚ÇÇ _ _))
      (d : M.Derivation œÜ), Nonempty d.Universal

lemma Derivation.Universal.hasDifferentials {M : PresheafOfModules.{u} (R ‚ãô forget‚ÇÇ _ _)}
    {d : M.Derivation œÜ} (hd : d.Universal) : HasDifferentials œÜ :=
  ‚ü®_ ,_, ‚ü®hd‚ü©‚ü©

section

variable [HasDifferentials œÜ]

noncomputable def relativeDifferentials : PresheafOfModules.{u} (R ‚ãô forget‚ÇÇ _ _) :=
  (HasDifferentials.exists_universal_derivation (œÜ := œÜ)).choose

noncomputable def universalDerivation : (relativeDifferentials œÜ).Derivation œÜ :=
  (HasDifferentials.exists_universal_derivation (œÜ := œÜ)).choose_spec.choose

noncomputable def universalUniversalDerivation : (universalDerivation œÜ).Universal :=
  (HasDifferentials.exists_universal_derivation (œÜ := œÜ)).choose_spec.choose_spec.some

end

/--  Given a morphism of presheaf of commutative rings `œÜ : S ‚ü∂ F.op ‚ãô R`,
this is functor which sends a presheaf of modules `M` to the abelian group `M.Derivation œÜ`. -/
@[simps obj]
def derivationFunctor :
    PresheafOfModules.{v} (R ‚ãô forget‚ÇÇ CommRingCat RingCat) ‚•§ Ab where
  obj M := AddCommGrp.of (M.Derivation œÜ)
  map f := AddMonoidHom.mk' (fun d ‚Ü¶ d.postcomp f) (by aesop_cat)

@[simp]
lemma derivationFunctor_map_apply
    {M N : PresheafOfModules.{v} (R ‚ãô forget‚ÇÇ CommRingCat RingCat)} (f : M ‚ü∂ N)
    (d : M.Derivation œÜ) :
    DFunLike.coe (Œ± := M.Derivation œÜ) (Œ≤ := fun _ ‚Ü¶ N.Derivation œÜ)
      ((derivationFunctor œÜ).map f) d = d.postcomp f := rfl

namespace Derivation

variable {M œÜ}

namespace Universal

@[simps]
def corepresentableBy {d : M.Derivation œÜ} (hd : d.Universal) :
    (derivationFunctor.{v} œÜ ‚ãô forget _).CorepresentableBy M where
  homEquiv := hd.homEquiv
  homEquiv_comp _ _ := hd.homEquiv_comp _ _

end Universal

variable (h : (derivationFunctor.{v} œÜ ‚ãô forget _).CorepresentableBy M)

def ofCorepresentableBy : M.Derivation œÜ := h.homEquiv (ùüô _)

lemma ofCorepresentableBy_postcomp {M' : PresheafOfModules.{v} (R ‚ãô forget‚ÇÇ _ _)} (f : M ‚ü∂ M') :
    (ofCorepresentableBy h).postcomp f = h.homEquiv f := by
  simpa using (h.homEquiv_comp f (ùüô _)).symm

def universalOfCorepresentableBy : (ofCorepresentableBy h).Universal where
  desc d := h.homEquiv.symm d
  fac {M'} d := by
    rw [ofCorepresentableBy_postcomp]
    apply Equiv.apply_symm_apply
  postcomp_injective H :=
    h.homEquiv.injective (by simpa only [ofCorepresentableBy_postcomp] using H)

end Derivation

/-- Given a morphism of presheaves of commutative rings `œÜ : S ‚ü∂ R`,
this is the type of relative `œÜ`-derivation of a presheaf of `R`-modules `M`. -/
abbrev Derivation' : Type _ := M.Derivation (F := ùü≠ D) œÜ'

namespace Derivation'

variable {M œÜ'}

@[simp]
nonrec lemma d_app (d : M.Derivation' œÜ') {X : D·µí·µñ} (a : S'.obj X) :
    d.d (œÜ'.app X a) = 0 :=
  d.d_app _

/-- The derivation relative to the morphism of commutative rings `œÜ'.app X` induced by
a derivation relative to a morphism of presheaves of commutative rings. -/
noncomputable def app (d : M.Derivation' œÜ') (X : D·µí·µñ) : (M.obj X).Derivation (œÜ'.app X) :=
  ModuleCat.Derivation.mk (fun b ‚Ü¶ d.d b)

@[simp]
lemma app_apply (d : M.Derivation' œÜ') {X : D·µí·µñ} (b : R.obj X) :
    (d.app X).d b = d.d b := rfl

section

variable (d : ‚àÄ (X : D·µí·µñ), (M.obj X).Derivation (œÜ'.app X))

/-- Given a morphism of presheaves of commutative rings `œÜ'`, this is the
in derivation `M.Derivation' œÜ'` that is given by a compatible family of derivations
with values in the modules `M.obj X` for all `X`. -/
def mk (d_map : ‚àÄ ‚¶ÉX Y : D·µí·µñ‚¶Ñ (f : X ‚ü∂ Y) (x : R.obj X),
    (d Y).d ((R.map f) x) = (M.map f) ((d X).d x)) : M.Derivation' œÜ' where
  d {X} := AddMonoidHom.mk' (d X).d (by simp)

variable (d_map : ‚àÄ ‚¶ÉX Y : D·µí·µñ‚¶Ñ (f : X ‚ü∂ Y) (x : R.obj X),
      (d Y).d ((R.map f) x) = (M.map f) ((d X).d x))

@[simp]
lemma mk_app (X : D·µí·µñ) : (mk d d_map).app X = d X := rfl

/-- Constructor for `Derivation.Universal` in the case `F` is the identity functor. -/
def Universal.mk {d : M.Derivation' œÜ'}
    (desc : ‚àÄ {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ _ _)}
      (_ : M'.Derivation' œÜ'), M ‚ü∂ M')
    (fac : ‚àÄ {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ _ _)}
      (d' : M'.Derivation' œÜ'), d.postcomp (desc d') = d')
    (postcomp_injective : ‚àÄ {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ _ _)}
      {Œ± Œ≤ : M ‚ü∂ M'}, d.postcomp Œ± = d.postcomp Œ≤ ‚Üí Œ± = Œ≤) : d.Universal where
  desc := desc
  fac := fac
  postcomp_injective := postcomp_injective

end

end Derivation'

namespace DifferentialsConstruction

/-- The presheaf of relative differentials of a morphism of presheaves of
commutative rings. -/
@[simps (config := .lemmasOnly)]
noncomputable def relativeDifferentials' :
    PresheafOfModules.{u} (R ‚ãô forget‚ÇÇ _ _) where
  obj X := CommRingCat.KaehlerDifferential (œÜ'.app X)
  map f := CommRingCat.KaehlerDifferential.map (œÜ'.naturality f)
  -- Without `dsimp`, `ext` doesn't pick up the right lemmas.
  map_id _ := by dsimp; ext; simp
  map_comp _ _ := by dsimp; ext; simp

attribute [simp] relativeDifferentials'_obj

@[simp]
lemma relativeDifferentials'_map_d {X Y : D·µí·µñ} (f : X ‚ü∂ Y) (x : R.obj X) :
    DFunLike.coe (Œ± := CommRingCat.KaehlerDifferential (œÜ'.app X))
      (Œ≤ := fun _ ‚Ü¶ CommRingCat.KaehlerDifferential (œÜ'.app Y))
      ((relativeDifferentials' œÜ').map f).hom (CommRingCat.KaehlerDifferential.d x) =
        CommRingCat.KaehlerDifferential.d (R.map f x) :=
  CommRingCat.KaehlerDifferential.map_d (œÜ'.naturality f) _

/-- The universal derivation. -/
noncomputable def derivation' : (relativeDifferentials' œÜ').Derivation' œÜ' :=
  Derivation'.mk (fun X ‚Ü¶ CommRingCat.KaehlerDifferential.D (œÜ'.app X))
    (fun _ _ f x ‚Ü¶ (relativeDifferentials'_map_d œÜ' f x).symm)

/-- The derivation `Derivation' œÜ'` is universal. -/
noncomputable def isUniversal' : (derivation' œÜ').Universal :=
  Derivation'.Universal.mk
    (fun {M'} d' ‚Ü¶
      { app := fun X ‚Ü¶ (d'.app X).desc
        naturality := fun {X Y} f ‚Ü¶ CommRingCat.KaehlerDifferential.ext (fun b ‚Ü¶ by
          dsimp
          rw [ModuleCat.Derivation.desc_d, Derivation'.app_apply]
          erw [relativeDifferentials'_map_d œÜ' f]
          rw [ModuleCat.Derivation.desc_d]
          dsimp
          rw [Derivation.d_map]
          dsimp) })
    (fun {M'} d' ‚Ü¶ by
      ext X b
      apply ModuleCat.Derivation.desc_d)
    (fun {M} Œ± Œ≤ h ‚Ü¶ by
      ext1 X
      exact CommRingCat.KaehlerDifferential.ext (Derivation.congr_d h))

instance : HasDifferentials (F := ùü≠ D) œÜ' := (isUniversal' œÜ').hasDifferentials

end DifferentialsConstruction

section

variable {œÜ M} {dœÜ : M.Derivation œÜ} (hdœÜ : dœÜ.Universal)
  {œà : R ‚ü∂ G.op ‚ãô T} {œÜœà : S ‚ü∂ (F ‚ãô G).op ‚ãô T} (fac : œÜœà = œÜ ‚â´ whiskerLeft F.op œà)
  {P : PresheafOfModules.{v} (T ‚ãô forget‚ÇÇ _ _)}

namespace Derivation

@[simps]
def induced {M' : PresheafOfModules.{v} (T ‚ãô forget‚ÇÇ _ _)}
    (d : M'.Derivation œà) : M'.Derivation œÜœà where
  d := d.d
  d_mul := by simp
  d_map := by simp
  d_app _ := by subst fac; apply d.d_app

local notation "pushforwardœà" =>
  pushforward (F := G) (R := T ‚ãô forget‚ÇÇ _ _) (œÜ := whiskerRight œà (forget‚ÇÇ _ RingCat))

local notation "pullbackœà" =>
  pullback (F := G) (R := T ‚ãô forget‚ÇÇ _ _) (œÜ := whiskerRight œà (forget‚ÇÇ _ RingCat))

local notation "adjunctionœà" =>
  (pullbackPushforwardAdjunction
    (F := G) (R := T ‚ãô forget‚ÇÇ _ _) (œÜ := whiskerRight œà (forget‚ÇÇ _ RingCat)))

variable (dœÜœà : P.Derivation œÜœà)

protected noncomputable def pushforward : ((pushforwardœà).obj P).Derivation œÜ where
  d := AddMonoidHom.mk' (fun a ‚Ü¶ dœÜœà.d (œà.app _ a)) (by simp)
  d_mul {X} a b := by
    dsimp
    rw [map_mul, dœÜœà.d_mul]
    rfl
  d_map {X Y} f a :=
    (congr_arg dœÜœà.d (congr_fun ((forget _).congr_map (œà.naturality f)) a)).trans
      (dœÜœà.d_map _ _)
  d_app a := by subst fac; exact dœÜœà.d_app a

lemma pushforward_d_apply (Y : D·µí·µñ) (a : R.obj Y) :
    (Derivation.pushforward fac dœÜœà).d a = dœÜœà.d (œà.app _ a) := rfl

lemma pushforward_postcomp {P' : PresheafOfModules.{v} (T ‚ãô forget‚ÇÇ _ _)} (Œ± : P ‚ü∂ P') :
    Derivation.pushforward fac (dœÜœà.postcomp Œ±) =
      (Derivation.pushforward fac dœÜœà).postcomp ((pushforwardœà).map Œ±) := rfl

@[simp]
lemma pushforward_induced {M' : PresheafOfModules.{v} (T ‚ãô forget‚ÇÇ _ _)} (d : M'.Derivation œà) :
    Derivation.pushforward fac (induced fac d) = 0 := by
  ext X a
  apply d.d_app

namespace Universal

noncomputable def pushforwardMap : M ‚ü∂ (pushforwardœà).obj P :=
  hdœÜ.desc (Derivation.pushforward fac dœÜœà)

variable [(pushforward (F := G) (R := T ‚ãô forget‚ÇÇ _ _)
  (whiskerRight œà (forget‚ÇÇ _ RingCat))).IsRightAdjoint]

noncomputable def pullbackMap : (pullbackœà).obj M ‚ü∂ P :=
  ((adjunctionœà).homEquiv M P).symm (hdœÜ.pushforwardMap fac dœÜœà)

lemma homEquiv_pullbackMap_comp
    {P' : PresheafOfModules.{v} (T ‚ãô forget‚ÇÇ _ _)} (Œ± : P ‚ü∂ P') :
    (((adjunctionœà).homEquiv _ _) (hdœÜ.pullbackMap fac dœÜœà ‚â´ Œ±)) =
      hdœÜ.homEquiv.symm (Derivation.pushforward fac (dœÜœà.postcomp Œ±)) := by
  apply hdœÜ.homEquiv.injective
  dsimp only [pullbackMap, pushforwardMap, pushforward_postcomp]
  simp only [homEquiv_apply, homEquiv_symm_apply, PresheafOfModules.Derivation.Universal.fac,
    Adjunction.homEquiv_naturality_right, Equiv.apply_symm_apply, postcomp_comp]

@[simp]
lemma pullbackMap_comp_eq_zero_iff
    {P' : PresheafOfModules.{v} (T ‚ãô forget‚ÇÇ _ _)} (Œ± : P ‚ü∂ P') :
    hdœÜ.pullbackMap fac dœÜœà ‚â´ Œ± = 0 ‚Üî
      Derivation.pushforward fac (dœÜœà.postcomp Œ±) = 0 := by
  rw [‚Üê EmbeddingLike.apply_eq_iff_eq ((adjunctionœà).homEquiv M P'),
    ‚Üê EmbeddingLike.apply_eq_iff_eq hdœÜ.homEquiv, homEquiv_pullbackMap_comp]
  simp only [homEquiv_symm_apply, homEquiv_apply, PresheafOfModules.Derivation.Universal.fac]
  rfl

variable {hdœÜ fac dœÜœà}
  {c : CokernelCofork (hdœÜ.pullbackMap fac dœÜœà)} (hc : IsColimit c) (hdœÜœà : dœÜœà.Universal)

namespace corepresentableByOfIsColimitCokernelCofork

variable {M' : PresheafOfModules.{v} (T ‚ãô forget‚ÇÇ _ _)}

@[simps]
noncomputable def homEquivToFun (f : c.pt ‚ü∂ M') : M'.Derivation œà where
  d := (dœÜœà.postcomp (c.œÄ ‚â´ f)).d
  d_map := by simp
  d_mul := by simp
  d_app := congr_d ((pullbackMap_comp_eq_zero_iff hdœÜ fac dœÜœà (c.œÄ ‚â´ f)).1 (by simp))

noncomputable def homEquivInvFun (d : M'.Derivation œà) : c.pt ‚ü∂ M' :=
  (CokernelCofork.IsColimit.desc' hc (hdœÜœà.desc (Derivation.induced fac d)) (by simp)).1

@[simp]
lemma œÄ_homEquivInvFun (d : M'.Derivation œà) :
    c.œÄ ‚â´ homEquivInvFun hc hdœÜœà d = hdœÜœà.desc (Derivation.induced fac d) :=
  (CokernelCofork.IsColimit.desc' _ _ _).2

@[simp]
lemma homEquiv_left_inv (f : c.pt ‚ü∂ M') :
    homEquivInvFun hc hdœÜœà (homEquivToFun f) = f := by
  apply Cofork.IsColimit.hom_ext hc
  rw [œÄ_homEquivInvFun]
  apply hdœÜœà.postcomp_injective
  rw [PresheafOfModules.Derivation.Universal.fac]
  ext
  dsimp

@[simp]
lemma homEquiv_right_inv (d : M'.Derivation œà) :
    homEquivToFun (homEquivInvFun hc hdœÜœà d) = d := by
  ext : 2
  simp

end corepresentableByOfIsColimitCokernelCofork

open corepresentableByOfIsColimitCokernelCofork in
noncomputable def corepresentableByOfIsColimitCokernelCofork :
    (derivationFunctor œà ‚ãô forget _).CorepresentableBy c.pt where
  homEquiv {M'} :=
    { toFun := homEquivToFun
      invFun := homEquivInvFun hc hdœÜœà
      left_inv := fun _ ‚Ü¶ by simp
      right_inv := fun _ ‚Ü¶ by simp }
  homEquiv_comp _ _ := rfl

noncomputable def ofIsColimitCokernelCofork :
    (ofCorepresentableBy (corepresentableByOfIsColimitCokernelCofork hc hdœÜœà)).Universal :=
  universalOfCorepresentableBy (corepresentableByOfIsColimitCokernelCofork hc hdœÜœà)

end Universal

end Derivation

lemma hasDifferentials_of_tower
    [HasDifferentials œÜ] [HasDifferentials œÜœà]
    [(pushforward.{u} (F := G) (R := T ‚ãô forget‚ÇÇ _ _)
      (whiskerRight œà (forget‚ÇÇ _ RingCat))).IsRightAdjoint]
    (fac : œÜœà = œÜ ‚â´ whiskerLeft F.op œà) :
    HasDifferentials œà :=
  ‚ü®cokernel (Derivation.Universal.pullbackMap
    (universalUniversalDerivation œÜ) fac _), _,
      ‚ü®Derivation.Universal.ofIsColimitCokernelCofork (colimit.isColimit _)
        (universalUniversalDerivation œÜœà)‚ü©‚ü©

end

def absoluteDerivationEquiv
    (œÜ : (Functor.const C·µí·µñ).obj (CommRingCat.of (ULift.{u} ‚Ñ§)) ‚ü∂ F.op ‚ãô R)
    {M : PresheafOfModules.{u} (R ‚ãô forget‚ÇÇ _ _)} :
    M.Derivation œÜ ‚âÉ M.Derivation (F := ùü≠ D)
      (S := (Functor.const D·µí·µñ).obj (CommRingCat.of (ULift.{u} ‚Ñ§))) (R := R)
      { app := fun X ‚Ü¶ CommRingCat.isInitial.{u}.to _ } where
  toFun d :=
    { d := d.d
      d_mul := by simp
      d_map := by simp
      d_app := by simp }
  invFun d :=
    { d := d.d
      d_mul := by simp
      d_map := by simp
      d_app := by simp }
  left_inv _ := rfl
  right_inv _ := rfl

def absoluteDerivationUniversalEquiv
    (œÜ : (Functor.const C·µí·µñ).obj (CommRingCat.of (ULift.{u} ‚Ñ§)) ‚ü∂ F.op ‚ãô R)
    (M : PresheafOfModules.{u} (R ‚ãô forget‚ÇÇ _ _))
    (d : M.Derivation (F := ùü≠ D)
      (S := (Functor.const D·µí·µñ).obj (CommRingCat.of (ULift.{u} ‚Ñ§))) (R := R)
      { app := fun X ‚Ü¶ CommRingCat.isInitial.{u}.to _ }) :
    d.Universal ‚âÉ ((absoluteDerivationEquiv œÜ).symm d).Universal where
  toFun hd :=
    { desc := fun d' ‚Ü¶ hd.desc (absoluteDerivationEquiv œÜ d')
      fac := fun d' ‚Ü¶ (absoluteDerivationEquiv œÜ).injective
        (hd.fac (absoluteDerivationEquiv œÜ d'))
      postcomp_injective :=
        fun h ‚Ü¶ hd.postcomp_injective ((absoluteDerivationEquiv œÜ).symm.injective h) }
  invFun hd :=
    { desc := fun d' ‚Ü¶ hd.desc ((absoluteDerivationEquiv œÜ).symm d')
      fac := fun d' ‚Ü¶ (absoluteDerivationEquiv œÜ).symm.injective
        (hd.fac ((absoluteDerivationEquiv œÜ).symm d'))
      postcomp_injective :=
        fun h ‚Ü¶ hd.postcomp_injective ((absoluteDerivationEquiv œÜ).injective h) }
  left_inv := fun _ ‚Ü¶ Subsingleton.elim _ _
  right_inv := fun _ ‚Ü¶ Subsingleton.elim _ _

instance hasAbsoluteDifferentials
    (œÜ : (Functor.const C·µí·µñ).obj (CommRingCat.of (ULift.{u} ‚Ñ§)) ‚ü∂ F.op ‚ãô R) :
    HasDifferentials œÜ :=
  ((absoluteDerivationUniversalEquiv œÜ _ _) (universalUniversalDerivation _)).hasDifferentials

instance hasDifferentials
    [(pushforward.{u} (F := F) (R := R ‚ãô forget‚ÇÇ _ _)
      (whiskerRight œÜ (forget‚ÇÇ _ RingCat))).IsRightAdjoint] : HasDifferentials œÜ := by
  let œÜ‚ÇÄ : (Functor.const _).obj (CommRingCat.of (ULift.{u} ‚Ñ§)) ‚ü∂ S :=
    { app := fun X ‚Ü¶ CommRingCat.isInitial.{u}.to _ }
  exact hasDifferentials_of_tower (F := ùü≠ C) (œÜ := œÜ‚ÇÄ) (œà := œÜ) (fac := rfl)

-- TODO: deduce the exact (cokernel) sequence of a tower from
-- Derivation.Universal.ofIsColimitCokernelCofork

end PresheafOfModules
