/-
Copyright (c) 2023 Jireh Loreaux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jireh Loreaux
-/
import Mathlib.Algebra.Order.Nonneg.Ring
import Mathlib.Algebra.Star.Order
import Mathlib.Algebra.Star.SelfAdjoint

/-!
# Positive elements in a star ordered ring

This file creates `StarOrderedRing.Positive R` as an abbreviation for `{ x : R // 0 ≤ x }`.
Some of the instances defined in `Mathlib.Algebra.Order.Nonneg.Ring` hold for a `StarOrderedRing`
instead of an `OrderedSemiring`, but for different reasons. So we add instances

In a `StarOrderedRing`, the elements of `StarOrderedRing.Positive R` are those in the additive
submonoid generated by elements of the form `star s * s`. Even though this technically corresponds
to the nonnegative elements, the "positive" terminology is standard throughout the literature
(at least in C⋆-algebra theory and operator theory), so we choose to prefer that. Another benefit of
this terminology is that we can distinguish hypotheses of the form `0 ≤ x` with `x : R` from
`x : StarOrderedRing.Positive R` within the name of a declaration.

The advantage of using this over other definitions of positivity is that it allows us to unify
several different concepts under a single umbrella. For example, one might be tempted to consider
the collection of bounded linear operators on an Hilbert space and define positivity as
`∀ x, 0 ≤ ⟪T x, x⟫`, but this doesn't generalize nicely to C⋆-algebras. Alternatively, one could
define positivity as those self-adjoint elements with nonnegative spectrum, but this requires the
algebra to be unital. Our definition herein conveniently sidesteps these issues.

We place everything in the `StarOrderedRing` namespace in order to avoid collisions or confusion
with other parts of the library.

## Main definitions

* `StarOrderedRing.Positive R`: The additive submonoid of a star ordered ring `R` generated by
  elements of the form `star s * s` for `s : R`.
* `StarOrderedRing.Positive.toSelfAdjoint : Positive R →+ selfAdjoint R`: the identity map as an
  `AddMonoidHom`.
* `StarOrderedRing.Positive.instAddMonoidWithOne`: Makes `Positive R` into an `AddMonoidWithOne`
* `StarOrderedRing.Positive.instCanonicallyOrderedAddMonoid`: Makes `Positive R` into a
  `CanonicallyOrderedAddMonoid` which avoids duplication of some lemmas (e.g., `zero_le`)

-/

universe u

variable {R : Type u}

namespace StarOrderedRing

/-- The positive elements of a star ordered ring. This is just a type synonym for `{x : R // 0 ≤ x}`

Regarding naming of lemmas: whenever a lemma involves a hypothesis of the form `0 ≤ x` with `x : R`,
it will be referenced as `nonneg` in the declaration name. However, when the hypothesis is
`x : Positive R`, the declaration name will use `positive` (or `Positive`), not `pos`, so as to
avoid confusion with `0 < x`. -/
abbrev Positive (R : Type _) [Zero R] [Preorder R] := {x : R // 0 ≤ x}

theorem Positive.coe_nonneg [Zero R] [Preorder R] (x : Positive R) : (0 : R) ≤ x := x.property

theorem Positive.nonneg [Zero R] [Preorder R] (x : Positive R) : 0 ≤ x := x.property

section NonUnitalSemiring

variable [NonUnitalSemiring R] [PartialOrder R] [StarOrderedRing R]

theorem Positive.val_mem_addSubmonoid_closure (x : Positive R) :
    (x : R) ∈ AddSubmonoid.closure (Set.range fun s : R => star s * s) :=
  nonneg_iff.mp x.property

theorem isSelfAdjoint_of_nonneg
    {x : R} (hx : 0 ≤ x) : IsSelfAdjoint x := by
  rw [nonneg_iff] at hx
  refine AddSubmonoid.closure_induction hx ?_ (isSelfAdjoint_zero R) fun _ _ => IsSelfAdjoint.add
  rintro - ⟨s, rfl⟩
  exact IsSelfAdjoint.star_mul_self s

theorem Positive.isSelfAdjoint (x : Positive R) :
    IsSelfAdjoint (x : R) :=
  isSelfAdjoint_of_nonneg x.property

theorem le_iff_exists_positive {x y : R} : x ≤ y ↔ ∃ p : Positive R, y = x + p := by
  rw [le_iff']
  simp only [Subtype.exists, exists_prop]

instance Positive.instCanonicallyOrderedAddMonoid : CanonicallyOrderedAddMonoid (Positive R) where
  bot_le := Subtype.property
  exists_add_of_le := @fun x y (h : (x : R) ≤ y) => by
    convert le_iff_exists_positive.mp h using 2
    exact Subtype.ext_iff
  le_self_add x y := by simpa using add_le_add_left y.property x

end NonUnitalSemiring

namespace Positive

section NonUnitalRing

variable [NonUnitalRing R] [PartialOrder R] [StarOrderedRing R]

/-- The identity map from `Positive R` to `selfAdjoint R`, as an `AddMonoidHom`. -/
def toSelfAdjoint : Positive R →+ selfAdjoint R where
  toFun := Subtype.map id (fun _ => isSelfAdjoint_of_nonneg)
  map_zero' := rfl
  map_add' _ _ := rfl

@[simp]
theorem val_toSelfAdjoint {x : Positive R} : (toSelfAdjoint x : R) = x :=
  rfl

lemma toSelfAdjoint_le {x y : Positive R} :
    toSelfAdjoint x ≤ toSelfAdjoint y ↔ x ≤ y :=
  Iff.rfl

end NonUnitalRing

section Semiring

variable [Semiring R] [PartialOrder R] [StarOrderedRing R]

variable (R)

instance instOne : One (Positive R) := ⟨⟨1, zero_le_one⟩⟩

@[simp, norm_cast]
lemma val_one : (1 : Positive R) = (1 : R) :=
  rfl

variable {R}

instance instNeZeroOne [Nontrivial R] : NeZero (1 : Positive R) where
  out := by rw [Ne.def, Subtype.ext_iff]; exact one_ne_zero

instance instNontrivial [Nontrivial R] : Nontrivial (Positive R) where
  exists_pair_ne := ⟨1, 0, NeZero.ne 1⟩

instance instNatCast : NatCast (Positive R) where
  natCast n := ⟨n, n.cast_nonneg'⟩

@[simp, norm_cast]
theorem val_natCast (n : ℕ) : ((n : Positive R) : R) = n := rfl

instance instAddCommMonoidWithOne : AddCommMonoidWithOne (Positive R) :=
  Subtype.val_injective.addCommMonoidWithOne _ rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) val_natCast

end Semiring

section Ring

variable [Ring R] [PartialOrder R] [StarOrderedRing R]

@[simp]
theorem toSelfAdjoint_natCast (n : ℕ) :
    toSelfAdjoint (n : Positive R) = (n : selfAdjoint R) := by
  ext; rfl

end Ring

end Positive

end StarOrderedRing
