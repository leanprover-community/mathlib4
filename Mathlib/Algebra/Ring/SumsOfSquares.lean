/-
Copyright (c) 2024 Florent Schaffhauser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Florent Schaffhauser
-/

import Mathlib.Algebra.Ring.Defs
import Mathlib.Algebra.Group.Submonoid.Basic
import Mathlib.Algebra.Group.Even
import Mathlib.Algebra.Order.Ring.Defs

/-!
# Sums of squares

We introduce sums of squares in a type `R` endowed with an `[Add R]`, `[Zero R]` and `[Mul R]`
instances. Sums of squares in `R` are defined by an inductive predicate `isSumSq : R → Prop`:
`0 : R` is a sum of squares and if `S` is a sum of squares, then for all `a : R`, `a * a + S` is a
sum of squares in `R`.

## Main declaration

- The predicate `isSumSq : R → Prop`, defining the property of being a sum of squares in `R`.

## Auxiliary declarations

- The type `SumSqIn R` : in an additive monoid with multiplication `R`, we introduce the type
`SumSqIn R` as the submonoid of `R` whose carrier is the subset `{S : R | isSumSq S}`.

## Theorems

- `isSumSq.add`: if `S1` and `S2` are sums of squares in `R`, then so is `S1 + S2`.
- `SumSq.nonneg`: in a linearly ordered semiring `R` with an `[ExistsAddOfLE R]` instance, sums of
squares are non-negative.
- `SquaresInSumSq`: a square is a sum of squares.
- `SquaresAddClosure`: the submonoid of `R` generated by the squares in `R` is the set of sums of
squares in `R`.

-/

variable {R : Type*}

/--
In a type `R` with an addition, a zero element and a multiplication, the property of being a sum of
squares is defined by an inductive predicate: `0 : R` is a sum of squares and if `S` is a sum of
squares, then for all `a : R`, `a * a + S` is a sum of squares in `R`.
-/

@[mk_iff]
inductive isSumSq [Add R] [Zero R] [Mul R] : R → Prop
  | zero                              : isSumSq 0
  | sq_add (a S : R) (pS : isSumSq S) : isSumSq (a * a + S)

/--
If `S1` and `S2` are sums of squares in a semiring `R`, then `S1 + S2` is a sum of squares in `R`.
-/

theorem isSumSq.add [AddMonoid R] [Mul R] {S1 S2 : R} (p1 : isSumSq S1)
    (p2 : isSumSq S2) : isSumSq (S1 + S2) := by
  induction p1 with
  | zero             => rewrite [zero_add]; exact p2
  | sq_add a S pS ih => rewrite [add_assoc]; exact isSumSq.sq_add a (S + S2) ih

variable (R) in

/--
In an additive monoid with multiplication `R`, the type `SumSqIn R` is the submonoid of sums of
squares in `R`.
-/

def SumSqIn [AddMonoid R] [Mul R] : AddSubmonoid R where
  carrier   := {S : R | isSumSq S}
  zero_mem' := isSumSq.zero
  add_mem'  := isSumSq.add

variable (R) in

/--
The set of squares in a type `R` endowed with a `Mul R` instance. By definition, a square in `R` is
a term `x : R` such that `x = y * y` for some `y : R` (see Mathlib.Algebra.Group.Even).
-/

def Squares [Mul R] : Set R := {x : R | IsSquare x}

/--
In an additive monoid with multiplication, every square is a sum of squares.
-/

theorem SquaresInSumSq [AddMonoid R] [Mul R ] : Squares R ⊆ SumSqIn R := by
  intro x px
  rcases px with ⟨y, py⟩
  simp [SumSqIn]
  rw [py, ← AddMonoid.add_zero (y * y)]
  apply isSumSq.sq_add
  exact isSumSq.zero

/--
In an additive monoid with multiplication `R`, the submonoid generated by the squares is the set of
sums of squares.
-/

theorem SquaresAddClosure [AddMonoid R] [Mul R] : AddSubmonoid.closure (Squares R) = SumSqIn R := by
  ext x
  constructor
  · intro px
    refine AddSubmonoid.mem_carrier.mp ?h.mp.a
    simp only [AddSubmonoid.mem_closure] at px
    apply px (SumSqIn R)
    exact SquaresInSumSq
  · intro px
    apply AddSubmonoid.mem_closure.mpr
    intro M pM
    induction' px with a S _ pS
    · exact AddSubmonoid.zero_mem M
    · refine AddSubmonoid.add_mem M ?h.mpr.sq_add.a pS
      apply pM
      use a

/--
Let `R` be a linearly ordered semiring in which the property `a ≤ b → ∃ c, a + c = b` holds
(e.g. `R = ℕ`). If `S : R` is a sum of squares in `R`, then `0 ≤ S`. This is used in
`Mathlib.Algebra.Ring.Semireal.Defs` to show that linearly ordered fields are semireal.
-/

theorem isSumSq.nonneg [LinearOrderedSemiring R] [ExistsAddOfLE R] {S : R}
    (pS : isSumSq S) : 0 ≤ S := by
  induction pS with
  | zero             => simp only [le_refl]
  | sq_add x S _ ih  => apply add_nonneg ?_ ih; simp only [← pow_two x, sq_nonneg]
