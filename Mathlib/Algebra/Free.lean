/-
Copyright (c) 2019 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau
-/
import Mathlib.Algebra.Hom.Group
import Mathlib.Algebra.Hom.Equiv.Basic
import Mathlib.Control.Applicative
import Mathlib.Control.Traversable.Basic
import Mathlib.Logic.Equiv.Defs
import Mathlib.Data.List.Basic

#align_import algebra.free from "leanprover-community/mathlib"@"6d0adfa76594f304b4650d098273d4366edeb61b"

/-!
# Free constructions

## Main definitions

* `FreeMagma Î±`: free magma (structure with binary operation without any axioms) over alphabet `Î±`,
  defined inductively, with traversable instance and decidable equality.
* `MagmaAssocQuotient Î±`: quotient of a magma `Î±` by the associativity equivalence relation.
* `FreeSemigroup Î±`: free semigroup over alphabet `Î±`, defined as a structure with two fields
  `head : Î±` and `tail : List Î±` (i.e. nonempty lists), with traversable instance and decidable
  equality.
* `FreeMagmaAssocQuotientEquiv Î±`: isomorphism between `MagmaAssocQuotient (FreeMagma Î±)` and
  `FreeSemigroup Î±`.
* `FreeMagma.lift`: the universal property of the free magma, expressing its adjointness.
-/

universe u v l

/-- Free nonabelian additive magma over a given alphabet. -/
inductive FreeAddMagma (Î± : Type u) : Type u
  | of : Î± â†’ FreeAddMagma Î±
  | add : FreeAddMagma Î± â†’ FreeAddMagma Î± â†’ FreeAddMagma Î±
  deriving DecidableEq
#align free_add_magma FreeAddMagma
compile_inductive% FreeAddMagma

/-- Free magma over a given alphabet. -/
@[to_additive]
inductive FreeMagma (Î± : Type u) : Type u
  | of : Î± â†’ FreeMagma Î±
  | mul : FreeMagma Î± â†’ FreeMagma Î± â†’ FreeMagma Î±
  deriving DecidableEq
#align free_magma FreeMagma
compile_inductive% FreeMagma

namespace FreeMagma

variable {Î± : Type u}

@[to_additive]
instance [Inhabited Î±] : Inhabited (FreeMagma Î±) := âŸ¨of defaultâŸ©

@[to_additive]
instance : Mul (FreeMagma Î±) := âŸ¨FreeMagma.mulâŸ©

-- Porting note: invalid attribute 'match_pattern', declaration is in an imported module
-- attribute [match_pattern] Mul.mul

@[to_additive (attr := simp)]
theorem mul_eq (x y : FreeMagma Î±) : mul x y = x * y := rfl
#align free_magma.mul_eq FreeMagma.mul_eq

/- Porting note: these lemmas are autogenerated by the inductive definition and due to
the existence of mul_eq not in simp normal form -/
attribute [nolint simpNF] FreeAddMagma.add.sizeOf_spec
attribute [nolint simpNF] FreeMagma.mul.sizeOf_spec
attribute [nolint simpNF] FreeAddMagma.add.injEq
attribute [nolint simpNF] FreeMagma.mul.injEq

/-- Recursor for `FreeMagma` using `x * y` instead of `FreeMagma.mul x y`. -/
@[to_additive (attr := elab_as_elim) "Recursor for `FreeAddMagma` using `x + y` instead of
`FreeAddMagma.add x y`."]
def recOnMul {C : FreeMagma Î± â†’ Sort l} (x) (ih1 : âˆ€ x, C (of x))
    (ih2 : âˆ€ x y, C x â†’ C y â†’ C (x * y)) : C x :=
  FreeMagma.recOn x ih1 ih2
#align free_magma.rec_on_mul FreeMagma.recOnMul

@[to_additive (attr := ext 1100)]
theorem hom_ext {Î² : Type v} [Mul Î²] {f g : FreeMagma Î± â†’â‚™* Î²} (h : f âˆ˜ of = g âˆ˜ of) : f = g :=
  (FunLike.ext _ _) fun x â†¦ recOnMul x (congr_fun h) <| by intros; simp only [map_mul, *]
                                                           -- âŠ¢ â†‘f (xâœ * yâœ) = â†‘g (xâœ * yâœ)
                                                                   -- ğŸ‰ no goals
#align free_magma.hom_ext FreeMagma.hom_ext

end FreeMagma

/-- Lifts a function `Î± â†’ Î²` to a magma homomorphism `FreeMagma Î± â†’ Î²` given a magma `Î²`. -/
def FreeMagma.liftAux {Î± : Type u} {Î² : Type v} [Mul Î²] (f : Î± â†’ Î²) : FreeMagma Î± â†’ Î²
  | FreeMagma.of x => f x
  | x * y => liftAux f x * liftAux f y
#align free_magma.lift_aux FreeMagma.liftAux

/-- Lifts a function `Î± â†’ Î²` to an additive magma homomorphism `FreeAddMagma Î± â†’ Î²` given
an additive magma `Î²`. -/
def FreeAddMagma.liftAux {Î± : Type u} {Î² : Type v} [Add Î²] (f : Î± â†’ Î²) : FreeAddMagma Î± â†’ Î²
  | FreeAddMagma.of x => f x
  | x + y => liftAux f x + liftAux f y
#align free_add_magma.lift_aux FreeAddMagma.liftAux

attribute [to_additive existing] FreeMagma.liftAux

namespace FreeMagma

section lift

variable {Î± : Type u} {Î² : Type v} [Mul Î²] (f : Î± â†’ Î²)

/-- The universal property of the free magma expressing its adjointness. -/
@[to_additive (attr := simps symm_apply)
"The universal property of the free additive magma expressing its adjointness."]
def lift : (Î± â†’ Î²) â‰ƒ (FreeMagma Î± â†’â‚™* Î²) where
  toFun f :=
  { toFun := liftAux f
    map_mul' := fun x y â†¦ rfl }
  invFun F := F âˆ˜ of
  left_inv f := by rfl
                   -- ğŸ‰ no goals
  right_inv F := by ext; rfl
                    -- âŠ¢ (â†‘((fun f => { toFun := liftAux f, map_mul' := (_ : âˆ€ (x y : FreeMagma Î±), l â€¦
                         -- ğŸ‰ no goals
#align free_magma.lift FreeMagma.lift

@[to_additive (attr := simp)]
theorem lift_of (x) : lift f (of x) = f x := rfl
#align free_magma.lift_of FreeMagma.lift_of

@[to_additive (attr := simp)]
theorem lift_comp_of : lift f âˆ˜ of = f := rfl
#align free_magma.lift_comp_of FreeMagma.lift_comp_of

@[to_additive (attr := simp)]
theorem lift_comp_of' (f : FreeMagma Î± â†’â‚™* Î²) : lift (f âˆ˜ of) = f := lift.apply_symm_apply f
#align free_magma.lift_comp_of' FreeMagma.lift_comp_of'

end lift

section Map

variable {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²)

/-- The unique magma homomorphism `FreeMagma Î± â†’â‚™* FreeMagma Î²` that sends
each `of x` to `of (f x)`. -/
@[to_additive "The unique additive magma homomorphism `FreeAddMagma Î± â†’ FreeAddMagma Î²` that sends
each `of x` to `of (f x)`."]
def map (f : Î± â†’ Î²) : FreeMagma Î± â†’â‚™* FreeMagma Î² := lift (of âˆ˜ f)
#align free_magma.map FreeMagma.map

@[to_additive (attr := simp)]
theorem map_of (x) : map f (of x) = of (f x) := rfl
#align free_magma.map_of FreeMagma.map_of

end Map

section Category

variable {Î± Î² : Type u}

@[to_additive]
instance : Monad FreeMagma where
  pure := of
  bind x f := lift f x

/-- Recursor on `FreeMagma` using `pure` instead of `of`. -/
@[to_additive (attr := elab_as_elim) "Recursor on `FreeAddMagma` using `pure` instead of `of`."]
protected def recOnPure {C : FreeMagma Î± â†’ Sort l} (x) (ih1 : âˆ€ x, C (pure x))
    (ih2 : âˆ€ x y, C x â†’ C y â†’ C (x * y)) : C x :=
  FreeMagma.recOnMul x ih1 ih2
#align free_magma.rec_on_pure FreeMagma.recOnPure

-- Porting note: dsimp can not prove this
@[to_additive (attr := simp, nolint simpNF)]
theorem map_pure (f : Î± â†’ Î²) (x) : (f <$> pure x : FreeMagma Î²) = pure (f x) := rfl
#align free_magma.map_pure FreeMagma.map_pure

@[to_additive (attr := simp)]
theorem map_mul' (f : Î± â†’ Î²) (x y : FreeMagma Î±) : f <$> (x * y) = f <$> x * f <$> y := rfl
#align free_magma.map_mul' FreeMagma.map_mul'

-- Porting note: dsimp can not prove this
@[to_additive (attr := simp, nolint simpNF)]
theorem pure_bind (f : Î± â†’ FreeMagma Î²) (x) : pure x >>= f = f x := rfl
#align free_magma.pure_bind FreeMagma.pure_bind

@[to_additive (attr := simp)]
theorem mul_bind (f : Î± â†’ FreeMagma Î²) (x y : FreeMagma Î±) : x * y >>= f = (x >>= f) * (y >>= f) :=
  rfl
#align free_magma.mul_bind FreeMagma.mul_bind

@[to_additive (attr := simp)]
theorem pure_seq {Î± Î² : Type u} {f : Î± â†’ Î²} {x : FreeMagma Î±} : pure f <*> x = f <$> x := rfl
#align free_magma.pure_seq FreeMagma.pure_seq

@[to_additive (attr := simp)]
theorem mul_seq {Î± Î² : Type u} {f g : FreeMagma (Î± â†’ Î²)} {x : FreeMagma Î±} :
    f * g <*> x = (f <*> x) * (g <*> x) := rfl
#align free_magma.mul_seq FreeMagma.mul_seq

@[to_additive]
instance instLawfulMonadFreeMagma : LawfulMonad FreeMagma.{u} := LawfulMonad.mk'
  (pure_bind := fun f x â†¦ rfl)
  (bind_assoc := fun x f g â†¦ FreeMagma.recOnPure x (fun x â†¦ rfl) fun x y ih1 ih2 â†¦ by
    rw [mul_bind, mul_bind, mul_bind, ih1, ih2])
    -- ğŸ‰ no goals
  (id_map := fun x â†¦ FreeMagma.recOnPure x (fun _ â†¦ rfl) fun x y ih1 ih2 â†¦ by
    -- ğŸ‰ no goals
    rw [map_mul', ih1, ih2])

end Category

end FreeMagma

/-- `FreeMagma` is traversable. -/
protected def FreeMagma.traverse {m : Type u â†’ Type u} [Applicative m] {Î± Î² : Type u}
    (F : Î± â†’ m Î²) : FreeMagma Î± â†’ m (FreeMagma Î²)
  | FreeMagma.of x => FreeMagma.of <$> F x
  | x * y => (Â· * Â·) <$> x.traverse F <*> y.traverse F
#align free_magma.traverse FreeMagma.traverse

/-- `FreeAddMagma` is traversable. -/
protected def FreeAddMagma.traverse {m : Type u â†’ Type u} [Applicative m] {Î± Î² : Type u}
    (F : Î± â†’ m Î²) : FreeAddMagma Î± â†’ m (FreeAddMagma Î²)
  | FreeAddMagma.of x => FreeAddMagma.of <$> F x
  | x + y => (Â· + Â·) <$> x.traverse F <*> y.traverse F
#align free_add_magma.traverse FreeAddMagma.traverse

attribute [to_additive existing] FreeMagma.traverse

namespace FreeMagma

variable {Î± : Type u}

section Category

variable {Î² : Type u}

@[to_additive]
instance : Traversable FreeMagma := âŸ¨@FreeMagma.traverseâŸ©

variable {m : Type u â†’ Type u} [Applicative m] (F : Î± â†’ m Î²)

@[to_additive (attr := simp)]
theorem traverse_pure (x) : traverse F (pure x : FreeMagma Î±) = pure <$> F x := rfl
#align free_magma.traverse_pure FreeMagma.traverse_pure

@[to_additive (attr := simp)]
theorem traverse_pure' : traverse F âˆ˜ pure = fun x â†¦ (pure <$> F x : m (FreeMagma Î²)) := rfl
#align free_magma.traverse_pure' FreeMagma.traverse_pure'

@[to_additive (attr := simp)]
theorem traverse_mul (x y : FreeMagma Î±) :
    traverse F (x * y) = (Â· * Â·) <$> traverse F x <*> traverse F y := rfl
#align free_magma.traverse_mul FreeMagma.traverse_mul

@[to_additive (attr := simp)]
theorem traverse_mul' :
    Function.comp (traverse F) âˆ˜ @Mul.mul (FreeMagma Î±) _ = fun x y â†¦
      (Â· * Â·) <$> traverse F x <*> traverse F y := rfl
#align free_magma.traverse_mul' FreeMagma.traverse_mul'

@[to_additive (attr := simp)]
theorem traverse_eq (x) : FreeMagma.traverse F x = traverse F x := rfl
#align free_magma.traverse_eq FreeMagma.traverse_eq

-- Porting note: dsimp can not prove this
@[to_additive (attr := simp, nolint simpNF)]
theorem mul_map_seq (x y : FreeMagma Î±) :
    ((Â· * Â·) <$> x <*> y : Id (FreeMagma Î±)) = (x * y : FreeMagma Î±) := rfl
#align free_magma.mul_map_seq FreeMagma.mul_map_seq

@[to_additive]
instance : LawfulTraversable FreeMagma.{u} :=
  { instLawfulMonadFreeMagma with
    id_traverse := fun x â†¦
      FreeMagma.recOnPure x (fun x â†¦ rfl) fun x y ih1 ih2 â†¦ by
        rw [traverse_mul, ih1, ih2, mul_map_seq]
        -- ğŸ‰ no goals
    comp_traverse := fun f g x â†¦
      FreeMagma.recOnPure x
        (fun x â†¦ by simp only [(Â· âˆ˜ Â·), traverse_pure, traverse_pure', functor_norm])
                    -- ğŸ‰ no goals
        (fun x y ih1 ih2 â†¦ by
          rw [traverse_mul, ih1, ih2, traverse_mul];
          -- âŠ¢ (Seq.seq ((fun x x_1 => x * x_1) <$> Functor.Comp.mk (traverse f <$> travers â€¦
          simp [Functor.Comp.map_mk, Functor.map_map, (Â· âˆ˜ Â·), Comp.seq_mk, seq_map_assoc,
            map_seq, traverse_mul])
    naturality := fun Î· Î± Î² f x â†¦
      FreeMagma.recOnPure x
        (fun x â†¦ by simp only [traverse_pure, functor_norm, Function.comp_apply])
                    -- ğŸ‰ no goals
        (fun x y ih1 ih2 â†¦ by simp only [traverse_mul, functor_norm, ih1, ih2])
                              -- ğŸ‰ no goals
    traverse_eq_map_id := fun f x â†¦
        -- âŠ¢ id.mk (f <$> x) * id.mk (f <$> y) = id.mk (f <$> x * f <$> y)
                                                            -- ğŸ‰ no goals
      FreeMagma.recOnPure x (fun _ â†¦ rfl) fun x y ih1 ih2 â†¦ by
        rw [traverse_mul, ih1, ih2, map_mul', mul_map_seq]; rfl }

end Category

end FreeMagma

-- Porting note: changed String to Lean.Format
/-- Representation of an element of a free magma. -/
protected def FreeMagma.repr {Î± : Type u} [Repr Î±] : FreeMagma Î± â†’ Lean.Format
  | FreeMagma.of x => repr x
  | x * y => "( " ++ x.repr ++ " * " ++ y.repr ++ " )"
#align free_magma.repr FreeMagma.repr

/-- Representation of an element of a free additive magma. -/
protected def FreeAddMagma.repr {Î± : Type u} [Repr Î±] : FreeAddMagma Î± â†’ Lean.Format
  | FreeAddMagma.of x => repr x
  | x + y => "( " ++ x.repr ++ " + " ++ y.repr ++ " )"
#align free_add_magma.repr FreeAddMagma.repr

attribute [to_additive existing] FreeMagma.repr

@[to_additive]
instance {Î± : Type u} [Repr Î±] : Repr (FreeMagma Î±) := âŸ¨fun o _ => FreeMagma.repr oâŸ©

/-- Length of an element of a free magma. -/
def FreeMagma.length {Î± : Type u} : FreeMagma Î± â†’ â„•
  | FreeMagma.of _x => 1
  | x * y => x.length + y.length
#align free_magma.length FreeMagma.length

/-- Length of an element of a free additive magma. -/
def FreeAddMagma.length {Î± : Type u} : FreeAddMagma Î± â†’ â„•
  | FreeAddMagma.of _x => 1
  | x + y => x.length + y.length
#align free_add_magma.length FreeAddMagma.length

attribute [to_additive existing (attr := simp)] FreeMagma.length

/-- Associativity relations for an additive magma. -/
inductive AddMagma.AssocRel (Î± : Type u) [Add Î±] : Î± â†’ Î± â†’ Prop
  | intro : âˆ€ x y z, AddMagma.AssocRel Î± (x + y + z) (x + (y + z))
  | left : âˆ€ w x y z, AddMagma.AssocRel Î± (w + (x + y + z)) (w + (x + (y + z)))
#align add_magma.assoc_rel AddMagma.AssocRel

/-- Associativity relations for a magma. -/
@[to_additive AddMagma.AssocRel "Associativity relations for an additive magma."]
inductive Magma.AssocRel (Î± : Type u) [Mul Î±] : Î± â†’ Î± â†’ Prop
  | intro : âˆ€ x y z, Magma.AssocRel Î± (x * y * z) (x * (y * z))
  | left : âˆ€ w x y z, Magma.AssocRel Î± (w * (x * y * z)) (w * (x * (y * z)))
#align magma.assoc_rel Magma.AssocRel

namespace Magma

/-- Semigroup quotient of a magma. -/
@[to_additive AddMagma.FreeAddSemigroup "Additive semigroup quotient of an additive magma."]
def AssocQuotient (Î± : Type u) [Mul Î±] : Type u :=
  Quot <| AssocRel Î±
#align magma.assoc_quotient Magma.AssocQuotient

namespace AssocQuotient

variable {Î± : Type u} [Mul Î±]

@[to_additive]
theorem quot_mk_assoc (x y z : Î±) : Quot.mk (AssocRel Î±) (x * y * z) = Quot.mk _ (x * (y * z)) :=
  Quot.sound (AssocRel.intro _ _ _)
#align magma.assoc_quotient.quot_mk_assoc Magma.AssocQuotient.quot_mk_assoc

@[to_additive]
theorem quot_mk_assoc_left (x y z w : Î±) :
    Quot.mk (AssocRel Î±) (x * (y * z * w)) = Quot.mk _ (x * (y * (z * w))) :=
  Quot.sound (AssocRel.left _ _ _ _)
#align magma.assoc_quotient.quot_mk_assoc_left Magma.AssocQuotient.quot_mk_assoc_left

@[to_additive]
instance : Semigroup (AssocQuotient Î±) where
  mul x y := by
    refine' Quot.liftOnâ‚‚ x y (fun x y â†¦ Quot.mk _ (x * y)) _ _
    -- âŠ¢ âˆ€ (a bâ‚ bâ‚‚ : Î±), AssocRel Î± bâ‚ bâ‚‚ â†’ (fun x y => Quot.mk (AssocRel Î±) (x * y) â€¦
    Â· rintro a bâ‚ bâ‚‚ (âŸ¨c, d, eâŸ© | âŸ¨c, d, e, fâŸ©) <;> simp only
      -- âŠ¢ (fun x y => Quot.mk (AssocRel Î±) (x * y)) a (c * d * e) = (fun x y => Quot.m â€¦
                                                    -- âŠ¢ Quot.mk (AssocRel Î±) (a * (c * d * e)) = Quot.mk (AssocRel Î±) (a * (c * (d * â€¦
                                                    -- âŠ¢ Quot.mk (AssocRel Î±) (a * (c * (d * e * f))) = Quot.mk (AssocRel Î±) (a * (c  â€¦
      Â· exact quot_mk_assoc_left _ _ _ _
        -- ğŸ‰ no goals
      Â· rw [â† quot_mk_assoc, quot_mk_assoc_left, quot_mk_assoc]
        -- ğŸ‰ no goals
    Â· rintro aâ‚ aâ‚‚ b (âŸ¨c, d, eâŸ© | âŸ¨c, d, e, fâŸ©) <;> simp only
      -- âŠ¢ (fun x y => Quot.mk (AssocRel Î±) (x * y)) (c * d * e) b = (fun x y => Quot.m â€¦
                                                    -- âŠ¢ Quot.mk (AssocRel Î±) (c * d * e * b) = Quot.mk (AssocRel Î±) (c * (d * e) * b)
                                                    -- âŠ¢ Quot.mk (AssocRel Î±) (c * (d * e * f) * b) = Quot.mk (AssocRel Î±) (c * (d *  â€¦
      Â· simp only [quot_mk_assoc, quot_mk_assoc_left]
        -- ğŸ‰ no goals
      Â· rw [quot_mk_assoc, quot_mk_assoc, quot_mk_assoc_left, quot_mk_assoc_left,
          quot_mk_assoc_left, â† quot_mk_assoc c d, â† quot_mk_assoc c d, quot_mk_assoc_left]
  mul_assoc x y z :=
    Quot.induction_onâ‚ƒ x y z fun a b c â†¦ quot_mk_assoc a b c

/-- Embedding from magma to its free semigroup. -/
@[to_additive "Embedding from additive magma to its free additive semigroup."]
def of : Î± â†’â‚™* AssocQuotient Î± := âŸ¨Quot.mk _, fun _x _y â†¦ rflâŸ©
#align magma.assoc_quotient.of Magma.AssocQuotient.of

@[to_additive]
instance [Inhabited Î±] : Inhabited (AssocQuotient Î±) := âŸ¨of defaultâŸ©

@[to_additive (attr := elab_as_elim)]
protected theorem induction_on {C : AssocQuotient Î± â†’ Prop} (x : AssocQuotient Î±)
    (ih : âˆ€ x, C (of x)) : C x := Quot.induction_on x ih
#align magma.assoc_quotient.induction_on Magma.AssocQuotient.induction_on

section lift

variable {Î² : Type v} [Semigroup Î²] (f : Î± â†’â‚™* Î²)

@[to_additive (attr := ext 1100)]
theorem hom_ext {f g : AssocQuotient Î± â†’â‚™* Î²} (h : f.comp of = g.comp of) : f = g :=
  (FunLike.ext _ _) fun x => AssocQuotient.induction_on x <| FunLike.congr_fun h
#align magma.assoc_quotient.hom_ext Magma.AssocQuotient.hom_ext

/-- Lifts a magma homomorphism `Î± â†’ Î²` to a semigroup homomorphism `Magma.AssocQuotient Î± â†’ Î²`
given a semigroup `Î²`. -/
@[to_additive (attr := simps symm_apply) "Lifts an additive magma homomorphism `Î± â†’ Î²` to an
additive semigroup homomorphism `AddMagma.AssocQuotient Î± â†’ Î²` given an additive semigroup `Î²`."]
def lift : (Î± â†’â‚™* Î²) â‰ƒ (AssocQuotient Î± â†’â‚™* Î²) where
  toFun f :=
  { toFun := fun x â†¦
      Quot.liftOn x f <| by rintro a b (âŸ¨c, d, eâŸ© | âŸ¨c, d, e, fâŸ©) <;> simp only [map_mul, mul_assoc]
                            -- âŠ¢ â†‘f (c * d * e) = â†‘f (c * (d * e))
                                                                      -- ğŸ‰ no goals
                                                                      -- ğŸ‰ no goals
    map_mul' := fun x y â†¦ Quot.induction_onâ‚‚ x y (map_mul f) }
  invFun f := f.comp of
  left_inv f := (FunLike.ext _ _) fun x â†¦ rfl
  right_inv f := hom_ext <| (FunLike.ext _ _) fun x â†¦ rfl
#align magma.assoc_quotient.lift Magma.AssocQuotient.lift

@[to_additive (attr := simp)]
theorem lift_of (x : Î±) : lift f (of x) = f x := rfl
#align magma.assoc_quotient.lift_of Magma.AssocQuotient.lift_of

@[to_additive (attr := simp)]
theorem lift_comp_of : (lift f).comp of = f := lift.symm_apply_apply f
#align magma.assoc_quotient.lift_comp_of Magma.AssocQuotient.lift_comp_of

@[to_additive (attr := simp)]
theorem lift_comp_of' (f : AssocQuotient Î± â†’â‚™* Î²) : lift (f.comp of) = f := lift.apply_symm_apply f
#align magma.assoc_quotient.lift_comp_of' Magma.AssocQuotient.lift_comp_of'

end lift

variable {Î² : Type v} [Mul Î²] (f : Î± â†’â‚™* Î²)

/-- From a magma homomorphism `Î± â†’â‚™* Î²` to a semigroup homomorphism
`Magma.AssocQuotient Î± â†’â‚™* Magma.AssocQuotient Î²`. -/
@[to_additive "From an additive magma homomorphism `Î± â†’ Î²` to an additive semigroup homomorphism
`AddMagma.AssocQuotient Î± â†’ AddMagma.AssocQuotient Î²`."]
def map : AssocQuotient Î± â†’â‚™* AssocQuotient Î² := lift (of.comp f)
#align magma.assoc_quotient.map Magma.AssocQuotient.map

@[to_additive (attr := simp)]
theorem map_of (x) : map f (of x) = of (f x) := rfl
#align magma.assoc_quotient.map_of Magma.AssocQuotient.map_of

end AssocQuotient

end Magma

/-- Free additive semigroup over a given alphabet. -/
structure FreeAddSemigroup (Î± : Type u) where
  /-- The head of the element -/
  head : Î±
  /-- The tail of the element -/
  tail : List Î±
#align free_add_semigroup FreeAddSemigroup
compile_inductive% FreeAddSemigroup

/-- Free semigroup over a given alphabet. -/
@[to_additive (attr := ext)]
structure FreeSemigroup (Î± : Type u) where
  /-- The head of the element -/
  head : Î±
  /-- The tail of the element -/
  tail : List Î±
#align free_semigroup FreeSemigroup
compile_inductive% FreeSemigroup

namespace FreeSemigroup

variable {Î± : Type u}

@[to_additive]
instance : Semigroup (FreeSemigroup Î±) where
  mul L1 L2 := âŸ¨L1.1, L1.2 ++ L2.1 :: L2.2âŸ©
  -- Porting note: replaced ext by FreeSemigroup.ext
  mul_assoc _L1 _L2 _L3 := FreeSemigroup.ext _ _ rfl <| List.append_assoc _ _ _

@[to_additive (attr := simp)]
theorem head_mul (x y : FreeSemigroup Î±) : (x * y).1 = x.1 := rfl
#align free_semigroup.head_mul FreeSemigroup.head_mul

@[to_additive (attr := simp)]
theorem tail_mul (x y : FreeSemigroup Î±) : (x * y).2 = x.2 ++ y.1 :: y.2 := rfl
#align free_semigroup.tail_mul FreeSemigroup.tail_mul

@[to_additive (attr := simp)]
theorem mk_mul_mk (x y : Î±) (L1 L2 : List Î±) : mk x L1 * mk y L2 = mk x (L1 ++ y :: L2) := rfl
#align free_semigroup.mk_mul_mk FreeSemigroup.mk_mul_mk

/-- The embedding `Î± â†’ FreeSemigroup Î±`. -/
@[to_additive (attr := simps) "The embedding `Î± â†’ FreeAddSemigroup Î±`."]
def of (x : Î±) : FreeSemigroup Î± := âŸ¨x, []âŸ©
#align free_semigroup.of FreeSemigroup.of

/-- Length of an element of free semigroup. -/
@[to_additive "Length of an element of free additive semigroup"]
def length (x : FreeSemigroup Î±) : â„• := x.tail.length + 1
#align free_semigroup.length FreeSemigroup.length

@[to_additive (attr := simp)]
theorem length_mul (x y : FreeSemigroup Î±) : (x * y).length = x.length + y.length := by
  simp [length, â† add_assoc, add_right_comm, List.length, List.length_append]
  -- ğŸ‰ no goals
#align free_semigroup.length_mul FreeSemigroup.length_mul

@[to_additive (attr := simp)]
theorem length_of (x : Î±) : (of x).length = 1 := rfl
#align free_semigroup.length_of FreeSemigroup.length_of

@[to_additive]
instance [Inhabited Î±] : Inhabited (FreeSemigroup Î±) := âŸ¨of defaultâŸ©

/-- Recursor for free semigroup using `of` and `*`. -/
@[to_additive (attr := elab_as_elim) "Recursor for free additive semigroup using `of` and `+`."]
protected def recOnMul {C : FreeSemigroup Î± â†’ Sort l} (x) (ih1 : âˆ€ x, C (of x))
    (ih2 : âˆ€ x y, C (of x) â†’ C y â†’ C (of x * y)) : C x :=
      FreeSemigroup.recOn x fun f s â†¦
      List.recOn s ih1 (fun hd tl ih f â†¦ ih2 f âŸ¨hd, tlâŸ© (ih1 f) (ih hd)) f
#align free_semigroup.rec_on_mul FreeSemigroup.recOnMul

@[to_additive (attr := ext 1100)]
theorem hom_ext {Î² : Type v} [Mul Î²] {f g : FreeSemigroup Î± â†’â‚™* Î²} (h : f âˆ˜ of = g âˆ˜ of) : f = g :=
  (FunLike.ext _ _) fun x â†¦
    FreeSemigroup.recOnMul x (congr_fun h) fun x y hx hy â†¦ by simp only [map_mul, *]
                                                              -- ğŸ‰ no goals
#align free_semigroup.hom_ext FreeSemigroup.hom_ext

section lift

variable {Î² : Type v} [Semigroup Î²] (f : Î± â†’ Î²)

/-- Lifts a function `Î± â†’ Î²` to a semigroup homomorphism `FreeSemigroup Î± â†’ Î²` given
a semigroup `Î²`. -/
@[to_additive (attr := simps symm_apply) "Lifts a function `Î± â†’ Î²` to an additive semigroup
homomorphism `FreeAddSemigroup Î± â†’ Î²` given an additive semigroup `Î²`."]
def lift : (Î± â†’ Î²) â‰ƒ (FreeSemigroup Î± â†’â‚™* Î²) where
  toFun f :=
    { toFun := fun x â†¦ x.2.foldl (fun a b â†¦ a * f b) (f x.1)
      map_mul' := fun x y â†¦ by
        simp only [head_mul, tail_mul, â† List.foldl_map f, List.foldl_append, List.foldl_cons,
          List.foldl_assoc] }
  invFun f := f âˆ˜ of
  left_inv f := rfl
  right_inv f := hom_ext rfl
#align free_semigroup.lift FreeSemigroup.lift

@[to_additive (attr := simp)]
theorem lift_of (x : Î±) : lift f (of x) = f x := rfl
#align free_semigroup.lift_of FreeSemigroup.lift_of

@[to_additive (attr := simp)]
theorem lift_comp_of : lift f âˆ˜ of = f := rfl
#align free_semigroup.lift_comp_of FreeSemigroup.lift_comp_of

@[to_additive (attr := simp)]
theorem lift_comp_of' (f : FreeSemigroup Î± â†’â‚™* Î²) : lift (f âˆ˜ of) = f := hom_ext rfl
#align free_semigroup.lift_comp_of' FreeSemigroup.lift_comp_of'

@[to_additive]
theorem lift_of_mul (x y) : lift f (of x * y) = f x * lift f y := by rw [map_mul, lift_of]
                                                                     -- ğŸ‰ no goals
#align free_semigroup.lift_of_mul FreeSemigroup.lift_of_mul

end lift

section Map

variable {Î² : Type v} (f : Î± â†’ Î²)

/-- The unique semigroup homomorphism that sends `of x` to `of (f x)`. -/
@[to_additive "The unique additive semigroup homomorphism that sends `of x` to `of (f x)`."]
def map : FreeSemigroup Î± â†’â‚™* FreeSemigroup Î² :=
  lift <| of âˆ˜ f
#align free_semigroup.map FreeSemigroup.map

@[to_additive (attr := simp)]
theorem map_of (x) : map f (of x) = of (f x) := rfl
#align free_semigroup.map_of FreeSemigroup.map_of

@[to_additive (attr := simp)]
theorem length_map (x) : (map f x).length = x.length :=
  FreeSemigroup.recOnMul x (fun x â†¦ rfl) (fun x y hx hy â†¦ by simp only [map_mul, length_mul, *])
                                                             -- ğŸ‰ no goals
#align free_semigroup.length_map FreeSemigroup.length_map

end Map

section Category

variable {Î² : Type u}

@[to_additive]
instance : Monad FreeSemigroup where
  pure := of
  bind x f := lift f x

/-- Recursor that uses `pure` instead of `of`. -/
@[to_additive (attr := elab_as_elim) "Recursor that uses `pure` instead of `of`."]
def recOnPure {C : FreeSemigroup Î± â†’ Sort l} (x) (ih1 : âˆ€ x, C (pure x))
    (ih2 : âˆ€ x y, C (pure x) â†’ C y â†’ C (pure x * y)) : C x :=
  FreeSemigroup.recOnMul x ih1 ih2
#align free_semigroup.rec_on_pure FreeSemigroup.recOnPure

-- Porting note: dsimp can not prove this
@[to_additive (attr := simp, nolint simpNF)]
theorem map_pure (f : Î± â†’ Î²) (x) : (f <$> pure x : FreeSemigroup Î²) = pure (f x) := rfl
#align free_semigroup.map_pure FreeSemigroup.map_pure

@[to_additive (attr := simp)]
theorem map_mul' (f : Î± â†’ Î²) (x y : FreeSemigroup Î±) : f <$> (x * y) = f <$> x * f <$> y :=
  map_mul (map f) _ _
#align free_semigroup.map_mul' FreeSemigroup.map_mul'

-- Porting note: dsimp can not prove this
@[to_additive (attr := simp, nolint simpNF)]
theorem pure_bind (f : Î± â†’ FreeSemigroup Î²) (x) : pure x >>= f = f x := rfl
#align free_semigroup.pure_bind FreeSemigroup.pure_bind

@[to_additive (attr := simp)]
theorem mul_bind (f : Î± â†’ FreeSemigroup Î²) (x y : FreeSemigroup Î±) :
    x * y >>= f = (x >>= f) * (y >>= f) := map_mul (lift f) _ _
#align free_semigroup.mul_bind FreeSemigroup.mul_bind

@[to_additive (attr := simp)]
theorem pure_seq {f : Î± â†’ Î²} {x : FreeSemigroup Î±} : pure f <*> x = f <$> x := rfl
#align free_semigroup.pure_seq FreeSemigroup.pure_seq

@[to_additive (attr := simp)]
theorem mul_seq {f g : FreeSemigroup (Î± â†’ Î²)} {x : FreeSemigroup Î±} :
    f * g <*> x = (f <*> x) * (g <*> x) := mul_bind _ _ _
#align free_semigroup.mul_seq FreeSemigroup.mul_seq

@[to_additive]
instance instLawfulMonadFreeSemigroup : LawfulMonad FreeSemigroup.{u} := LawfulMonad.mk'
  (pure_bind := fun _ _ â†¦ rfl)
  (bind_assoc := fun x g f â†¦
    recOnPure x (fun x â†¦ rfl) fun x y ih1 ih2 â†¦ by rw [mul_bind, mul_bind, mul_bind, ih1, ih2])
                                                   -- ğŸ‰ no goals
                                                                    -- ğŸ‰ no goals
  (id_map := fun x â†¦ recOnPure x (fun _ â†¦ rfl) fun x y ih1 ih2 â†¦ by rw [map_mul', ih1, ih2])

/-- `FreeSemigroup` is traversable. -/
@[to_additive "`FreeAddSemigroup` is traversable."]
protected def traverse {m : Type u â†’ Type u} [Applicative m] {Î± Î² : Type u}
    (F : Î± â†’ m Î²) (x : FreeSemigroup Î±) : m (FreeSemigroup Î²) :=
  recOnPure x (fun x â†¦ pure <$> F x) fun _x _y ihx ihy â†¦ (Â· * Â·) <$> ihx <*> ihy
#align free_semigroup.traverse FreeSemigroup.traverse

@[to_additive]
instance : Traversable FreeSemigroup := âŸ¨@FreeSemigroup.traverseâŸ©

variable {m : Type u â†’ Type u} [Applicative m] (F : Î± â†’ m Î²)

@[to_additive (attr := simp)]
theorem traverse_pure (x) : traverse F (pure x : FreeSemigroup Î±) = pure <$> F x := rfl
#align free_semigroup.traverse_pure FreeSemigroup.traverse_pure

@[to_additive (attr := simp)]
theorem traverse_pure' : traverse F âˆ˜ pure = fun x â†¦ (pure <$> F x : m (FreeSemigroup Î²)) := rfl
#align free_semigroup.traverse_pure' FreeSemigroup.traverse_pure'

section

variable [LawfulApplicative m]

@[to_additive (attr := simp)]
theorem traverse_mul (x y : FreeSemigroup Î±) :
    traverse F (x * y) = (Â· * Â·) <$> traverse F x <*> traverse F y :=
  let âŸ¨x, L1âŸ© := x
  let âŸ¨y, L2âŸ© := y
  List.recOn L1 (fun x â†¦ rfl)
    (fun hd tl ih x â†¦ show
        (Â· * Â·) <$> pure <$> F x <*> traverse F (mk hd tl * mk y L2) =
          (Â· * Â·) <$> ((Â· * Â·) <$> pure <$> F x <*> traverse F (mk hd tl)) <*> traverse F (mk y L2)
        by rw [ih]; simp only [(Â· âˆ˜ Â·), (mul_assoc _ _ _).symm, functor_norm])
           -- âŠ¢ (Seq.seq ((fun x x_1 => x * x_1) <$> pure <$> F x) fun x => Seq.seq ((fun x  â€¦
                    -- ğŸ‰ no goals
    x
#align free_semigroup.traverse_mul FreeSemigroup.traverse_mul

@[to_additive (attr := simp)]
theorem traverse_mul' :
    Function.comp (traverse F) âˆ˜ @Mul.mul (FreeSemigroup Î±) _ = fun x y â†¦
      (Â· * Â·) <$> traverse F x <*> traverse F y := funext fun x â†¦ funext fun y â†¦ traverse_mul F x y
#align free_semigroup.traverse_mul' FreeSemigroup.traverse_mul'

end

@[to_additive (attr := simp)]
theorem traverse_eq (x) : FreeSemigroup.traverse F x = traverse F x := rfl
#align free_semigroup.traverse_eq FreeSemigroup.traverse_eq

-- Porting note: dsimp can not prove this
@[to_additive (attr := simp, nolint simpNF)]
theorem mul_map_seq (x y : FreeSemigroup Î±) :
    ((Â· * Â·) <$> x <*> y : Id (FreeSemigroup Î±)) = (x * y : FreeSemigroup Î±) := rfl
#align free_semigroup.mul_map_seq FreeSemigroup.mul_map_seq

@[to_additive]
instance : LawfulTraversable FreeSemigroup.{u} :=
  { instLawfulMonadFreeSemigroup with
    id_traverse := fun x â†¦
      FreeSemigroup.recOnMul x (fun x â†¦ rfl) fun x y ih1 ih2 â†¦ by
        rw [traverse_mul, ih1, ih2, mul_map_seq]
        -- ğŸ‰ no goals
    comp_traverse := fun f g x â†¦
      recOnPure x (fun x â†¦ by simp only [traverse_pure, functor_norm, (Â· âˆ˜ Â·)])
                              -- ğŸ‰ no goals
        fun x y ih1 ih2 â†¦ by (rw [traverse_mul, ih1, ih2,
          traverse_mul, Functor.Comp.map_mk]; simp only [Function.comp, functor_norm, traverse_mul])
                                              -- ğŸ‰ no goals
    naturality := fun Î· Î± Î² f x â†¦
      recOnPure x (fun x â†¦ by simp only [traverse_pure, functor_norm, Function.comp])
                              -- ğŸ‰ no goals
          (fun x y ih1 ih2 â†¦ by simp only [traverse_mul, functor_norm, ih1, ih2])
                                -- ğŸ‰ no goals
    traverse_eq_map_id := fun f x â†¦
        -- âŠ¢ id.mk (f <$> of x) * id.mk (f <$> y) = id.mk (f <$> of x * f <$> y)
                                                            -- ğŸ‰ no goals
      FreeSemigroup.recOnMul x (fun _ â†¦ rfl) fun x y ih1 ih2 â†¦ by
        rw [traverse_mul, ih1, ih2, map_mul', mul_map_seq]; rfl }

end Category

@[to_additive]
instance [DecidableEq Î±] : DecidableEq (FreeSemigroup Î±) :=
  fun _ _ â†¦ decidable_of_iff' _ (FreeSemigroup.ext_iff _ _)

end FreeSemigroup

namespace FreeMagma

variable {Î± : Type u} {Î² : Type v}

/-- The canonical multiplicative morphism from `FreeMagma Î±` to `FreeSemigroup Î±`. -/
@[to_additive "The canonical additive morphism from `FreeAddMagma Î±` to `FreeAddSemigroup Î±`."]
def toFreeSemigroup : FreeMagma Î± â†’â‚™* FreeSemigroup Î± := FreeMagma.lift FreeSemigroup.of
#align free_magma.to_free_semigroup FreeMagma.toFreeSemigroup

@[to_additive (attr := simp)]
theorem toFreeSemigroup_of (x : Î±) : toFreeSemigroup (of x) = FreeSemigroup.of x := rfl
#align free_magma.to_free_semigroup_of FreeMagma.toFreeSemigroup_of

@[to_additive (attr := simp)]
theorem toFreeSemigroup_comp_of : @toFreeSemigroup Î± âˆ˜ of = FreeSemigroup.of := rfl
#align free_magma.to_free_semigroup_comp_of FreeMagma.toFreeSemigroup_comp_of

@[to_additive]
theorem toFreeSemigroup_comp_map (f : Î± â†’ Î²) :
    toFreeSemigroup.comp (map f) = (FreeSemigroup.map f).comp toFreeSemigroup :=
  by ext1; rfl
     -- âŠ¢ â†‘(MulHom.comp toFreeSemigroup (map f)) âˆ˜ of = â†‘(MulHom.comp (FreeSemigroup.m â€¦
           -- ğŸ‰ no goals
#align free_magma.to_free_semigroup_comp_map FreeMagma.toFreeSemigroup_comp_map

@[to_additive]
theorem toFreeSemigroup_map (f : Î± â†’ Î²) (x : FreeMagma Î±) :
    toFreeSemigroup (map f x) = FreeSemigroup.map f (toFreeSemigroup x) :=
  FunLike.congr_fun (toFreeSemigroup_comp_map f) x
#align free_magma.to_free_semigroup_map FreeMagma.toFreeSemigroup_map

@[to_additive (attr := simp)]
theorem length_toFreeSemigroup (x : FreeMagma Î±) : (toFreeSemigroup x).length = x.length :=
  FreeMagma.recOnMul x (fun x â†¦ rfl) fun x y hx hy â†¦ by
    rw [map_mul, FreeSemigroup.length_mul, hx, hy]; rfl
    -- âŠ¢ length x + length y = length (x * y)
                                                    -- ğŸ‰ no goals
#align free_magma.length_to_free_semigroup FreeMagma.length_toFreeSemigroup

end FreeMagma

/-- Isomorphism between `Magma.AssocQuotient (FreeMagma Î±)` and `FreeSemigroup Î±`. -/
@[to_additive "Isomorphism between `AddMagma.AssocQuotient (FreeAddMagma Î±)` and
`FreeAddSemigroup Î±`."]
def FreeMagmaAssocQuotientEquiv (Î± : Type u) :
    Magma.AssocQuotient (FreeMagma Î±) â‰ƒ* FreeSemigroup Î± :=
      (Magma.AssocQuotient.lift FreeMagma.toFreeSemigroup).toMulEquiv
      (FreeSemigroup.lift (Magma.AssocQuotient.of âˆ˜ FreeMagma.of))
      (by ext; rfl)
          -- âŠ¢ (â†‘(MulHom.comp (MulHom.comp (â†‘FreeSemigroup.lift (â†‘Magma.AssocQuotient.of âˆ˜  â€¦
               -- ğŸ‰ no goals
      (by ext1; rfl)
          -- âŠ¢ â†‘(MulHom.comp (â†‘Magma.AssocQuotient.lift FreeMagma.toFreeSemigroup) (â†‘FreeSe â€¦
                -- ğŸ‰ no goals
#align free_magma_assoc_quotient_equiv FreeMagmaAssocQuotientEquiv
