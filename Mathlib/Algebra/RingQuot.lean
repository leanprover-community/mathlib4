/-
Copyright (c) 2020 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison
-/
import Mathlib.Algebra.Algebra.Hom
import Mathlib.RingTheory.Ideal.Quotient

#align_import algebra.ring_quot from "leanprover-community/mathlib"@"e5820f6c8fcf1b75bcd7738ae4da1c5896191f72"

/-!
# Quotients of non-commutative rings

Unfortunately, ideals have only been developed in the commutative case as `Ideal`,
and it's not immediately clear how one should formalise ideals in the non-commutative case.

In this file, we directly define the quotient of a semiring by any relation,
by building a bigger relation that represents the ideal generated by that relation.

We prove the universal properties of the quotient, and recommend avoiding relying on the actual
definition, which is made irreducible for this purpose.

Since everything runs in parallel for quotients of `R`-algebras, we do that case at the same time.
-/

set_option autoImplicit true


universe uR uS uT uA

variable {R : Type uR} [Semiring R]

variable {S : Type uS} [CommSemiring S]
variable {T : Type uT}

variable {A : Type uA} [Semiring A] [Algebra S A]

namespace RingCon

instance (c : RingCon A) : Algebra S c.Quotient where
  smul := (Â· â€¢ Â·)
  toRingHom := c.mk'.comp (algebraMap S A)
  commutes' _ := Quotient.ind' fun _ â†¦ congr_arg Quotient.mk'' <| Algebra.commutes _ _
  smul_def' _ := Quotient.ind' fun _ â†¦ congr_arg Quotient.mk'' <| Algebra.smul_def _ _

@[simp, norm_cast]
theorem coe_algebraMap (c : RingCon A) (s : S) :
    (algebraMap S A s : c.Quotient) = algebraMap S _ s :=
  rfl
#align ring_con.coe_algebra_map RingCon.coe_algebraMap

end RingCon

namespace RingQuot

/-- Given an arbitrary relation `r` on a ring, we strengthen it to a relation `Rel r`,
such that the equivalence relation generated by `Rel r` has `x ~ y` if and only if
`x - y` is in the ideal generated by elements `a - b` such that `r a b`.
-/
inductive Rel (r : R â†’ R â†’ Prop) : R â†’ R â†’ Prop
  | of â¦ƒx y : Râ¦„ (h : r x y) : Rel r x y
  | add_left â¦ƒa b câ¦„ : Rel r a b â†’ Rel r (a + c) (b + c)
  | mul_left â¦ƒa b câ¦„ : Rel r a b â†’ Rel r (a * c) (b * c)
  | mul_right â¦ƒa b câ¦„ : Rel r b c â†’ Rel r (a * b) (a * c)
#align ring_quot.rel RingQuot.Rel

theorem Rel.add_right {r : R â†’ R â†’ Prop} â¦ƒa b c : Râ¦„ (h : Rel r b c) : Rel r (a + b) (a + c) := by
  rw [add_comm a b, add_comm a c]
  -- âŠ¢ Rel r (b + a) (c + a)
  exact Rel.add_left h
  -- ðŸŽ‰ no goals
#align ring_quot.rel.add_right RingQuot.Rel.add_right

theorem Rel.neg {R : Type uR} [Ring R] {r : R â†’ R â†’ Prop} â¦ƒa b : Râ¦„ (h : Rel r a b) :
    Rel r (-a) (-b) := by simp only [neg_eq_neg_one_mul a, neg_eq_neg_one_mul b, Rel.mul_right h]
                          -- ðŸŽ‰ no goals
#align ring_quot.rel.neg RingQuot.Rel.neg

theorem Rel.sub_left {R : Type uR} [Ring R] {r : R â†’ R â†’ Prop} â¦ƒa b c : Râ¦„ (h : Rel r a b) :
    Rel r (a - c) (b - c) := by simp only [sub_eq_add_neg, h.add_left]
                                -- ðŸŽ‰ no goals
#align ring_quot.rel.sub_left RingQuot.Rel.sub_left

theorem Rel.sub_right {R : Type uR} [Ring R] {r : R â†’ R â†’ Prop} â¦ƒa b c : Râ¦„ (h : Rel r b c) :
    Rel r (a - b) (a - c) := by simp only [sub_eq_add_neg, h.neg.add_right]
                                -- ðŸŽ‰ no goals
#align ring_quot.rel.sub_right RingQuot.Rel.sub_right

theorem Rel.smul {r : A â†’ A â†’ Prop} (k : S) â¦ƒa b : Aâ¦„ (h : Rel r a b) : Rel r (k â€¢ a) (k â€¢ b) := by
  simp only [Algebra.smul_def, Rel.mul_right h]
  -- ðŸŽ‰ no goals
#align ring_quot.rel.smul RingQuot.Rel.smul

/-- `EqvGen (RingQuot.Rel r)` is a ring congruence. -/
def ringCon (r : R â†’ R â†’ Prop) : RingCon R where
  r := EqvGen (Rel r)
  iseqv := EqvGen.is_equivalence _
  add' {a b c d} hab hcd := by
    induction hab generalizing c d with
    | rel _ _ hab =>
      refine' (EqvGen.rel _ _ hab.add_left).trans _ _ _ _
      induction hcd with
      | rel _ _ hcd => exact EqvGen.rel _ _ hcd.add_right
      | refl => exact EqvGen.refl _
      | symm _ _ _ h => exact h.symm _ _
      | trans _ _ _ _ _ h h' => exact h.trans _ _ _ h'
    | refl => induction hcd with
      | rel _ _ hcd => exact EqvGen.rel _ _ hcd.add_right
      | refl => exact EqvGen.refl _
      | symm _ _ _ h => exact h.symm _ _
      | trans _ _ _ _ _ h h' => exact h.trans _ _ _ h'
    | symm x y _ hxy => exact (hxy hcd.symm).symm
    | trans x y z _ _ h h' => exact (h hcd).trans _ _ _ (h' <| EqvGen.refl _)
  mul' {a b c d} hab hcd := by
    induction hab generalizing c d with
    | rel _ _ hab =>
      refine' (EqvGen.rel _ _ hab.mul_left).trans _ _ _ _
      induction hcd with
      | rel _ _ hcd => exact EqvGen.rel _ _ hcd.mul_right
      | refl => exact EqvGen.refl _
      | symm _ _ _ h => exact h.symm _ _
      | trans _ _ _ _ _ h h' => exact h.trans _ _ _ h'
    | refl => induction hcd with
      | rel _ _ hcd => exact EqvGen.rel _ _ hcd.mul_right
      | refl => exact EqvGen.refl _
      | symm _ _ _ h => exact h.symm _ _
      | trans _ _ _ _ _ h h' => exact h.trans _ _ _ h'
    | symm x y _ hxy => exact (hxy hcd.symm).symm
    | trans x y z _ _ h h' => exact (h hcd).trans _ _ _ (h' <| EqvGen.refl _)
#align ring_quot.ring_con RingQuot.ringCon

theorem eqvGen_rel_eq (r : R â†’ R â†’ Prop) : EqvGen (Rel r) = RingConGen.Rel r := by
  ext xâ‚ xâ‚‚
  -- âŠ¢ EqvGen (Rel r) xâ‚ xâ‚‚ â†” RingConGen.Rel r xâ‚ xâ‚‚
  constructor
  -- âŠ¢ EqvGen (Rel r) xâ‚ xâ‚‚ â†’ RingConGen.Rel r xâ‚ xâ‚‚
  Â· intro h
    -- âŠ¢ RingConGen.Rel r xâ‚ xâ‚‚
    induction h with
    | rel _ _ h => induction h with
      | of => exact RingConGen.Rel.of _ _ â€¹_â€º
      | add_left _ h => exact h.add (RingConGen.Rel.refl _)
      | mul_left _ h => exact h.mul (RingConGen.Rel.refl _)
      | mul_right _ h => exact (RingConGen.Rel.refl _).mul h
    | refl => exact RingConGen.Rel.refl _
    | symm => exact RingConGen.Rel.symm â€¹_â€º
    | trans => exact RingConGen.Rel.trans â€¹_â€º â€¹_â€º
  Â· intro h
    -- âŠ¢ EqvGen (Rel r) xâ‚ xâ‚‚
    induction h with
    | of => exact EqvGen.rel _ _ (Rel.of â€¹_â€º)
    | refl => exact (RingQuot.ringCon r).refl _
    | symm => exact (RingQuot.ringCon r).symm â€¹_â€º
    | trans => exact (RingQuot.ringCon r).trans â€¹_â€º â€¹_â€º
    | add => exact (RingQuot.ringCon r).add â€¹_â€º â€¹_â€º
    | mul => exact (RingQuot.ringCon r).mul â€¹_â€º â€¹_â€º
#align ring_quot.eqv_gen_rel_eq RingQuot.eqvGen_rel_eq

end RingQuot

/-- The quotient of a ring by an arbitrary relation. -/
structure RingQuot (r : R â†’ R â†’ Prop) where
  toQuot : Quot (RingQuot.Rel r)
#align ring_quot RingQuot

namespace RingQuot

variable (r : R â†’ R â†’ Prop)

-- can't be irreducible, causes diamonds in â„•-algebras
private def natCast (n : â„•) : RingQuot r :=
  âŸ¨Quot.mk _ nâŸ©

private irreducible_def zero : RingQuot r :=
  âŸ¨Quot.mk _ 0âŸ©

private irreducible_def one : RingQuot r :=
  âŸ¨Quot.mk _ 1âŸ©

private irreducible_def add : RingQuot r â†’ RingQuot r â†’ RingQuot r
  | âŸ¨aâŸ©, âŸ¨bâŸ© => âŸ¨Quot.mapâ‚‚ (Â· + Â·) Rel.add_right Rel.add_left a bâŸ©

private irreducible_def mul : RingQuot r â†’ RingQuot r â†’ RingQuot r
  | âŸ¨aâŸ©, âŸ¨bâŸ© => âŸ¨Quot.mapâ‚‚ (Â· * Â·) Rel.mul_right Rel.mul_left a bâŸ©

private irreducible_def neg {R : Type uR} [Ring R] (r : R â†’ R â†’ Prop) : RingQuot r â†’ RingQuot r
  | âŸ¨aâŸ© => âŸ¨Quot.map (fun a â†¦ -a) Rel.neg aâŸ©

private irreducible_def sub {R : Type uR} [Ring R] (r : R â†’ R â†’ Prop) :
  RingQuot r â†’ RingQuot r â†’ RingQuot r
  | âŸ¨aâŸ©, âŸ¨bâŸ© => âŸ¨Quot.mapâ‚‚ Sub.sub Rel.sub_right Rel.sub_left a bâŸ©

private irreducible_def npow (n : â„•) : RingQuot r â†’ RingQuot r
  | âŸ¨aâŸ© =>
    âŸ¨Quot.lift (fun a â†¦ Quot.mk (RingQuot.Rel r) (a ^ n))
        (fun a b (h : Rel r a b) â†¦ by
          -- note we can't define a `Rel.pow` as `Rel` isn't reflexive so `Rel r 1 1` isn't true
          dsimp only
          -- âŠ¢ Quot.mk (Rel r) (a ^ n) = Quot.mk (Rel r) (b ^ n)
          induction n with
          | zero => rw [pow_zero, pow_zero]
          | succ n ih =>
            rw [pow_succ, pow_succ]
            -- Porting note:
            -- `simpa [mul_def] using congr_argâ‚‚ (fun x y â†¦ mul r âŸ¨xâŸ© âŸ¨yâŸ©) (Quot.sound h) ih`
            -- mysteriously doesn't work
            have := congr_argâ‚‚ (fun x y â†¦ mul r âŸ¨xâŸ© âŸ¨yâŸ©) (Quot.sound h) ih
            dsimp only at this
            simp [mul_def] at this
            exact this)
        aâŸ©

-- note: this cannot be irreducible, as otherwise diamonds don't commute.
private def smul [Algebra S R] (n : S) : RingQuot r â†’ RingQuot r
  | âŸ¨aâŸ© => âŸ¨Quot.map (fun a â†¦ n â€¢ a) (Rel.smul n) aâŸ©

instance : NatCast (RingQuot r) :=
  âŸ¨natCast râŸ©

instance : Zero (RingQuot r) :=
  âŸ¨zero râŸ©

instance : One (RingQuot r) :=
  âŸ¨one râŸ©

instance : Add (RingQuot r) :=
  âŸ¨add râŸ©

instance : Mul (RingQuot r) :=
  âŸ¨mul râŸ©

instance : Pow (RingQuot r) â„• :=
  âŸ¨fun x n â†¦ npow r n xâŸ©

instance {R : Type uR} [Ring R] (r : R â†’ R â†’ Prop) : Neg (RingQuot r) :=
  âŸ¨neg râŸ©

instance {R : Type uR} [Ring R] (r : R â†’ R â†’ Prop) : Sub (RingQuot r) :=
  âŸ¨sub râŸ©

instance [Algebra S R] : SMul S (RingQuot r) :=
  âŸ¨smul râŸ©

theorem zero_quot : (âŸ¨Quot.mk _ 0âŸ© : RingQuot r) = 0 :=
  show _ = zero r by rw [zero_def]
                     -- ðŸŽ‰ no goals
#align ring_quot.zero_quot RingQuot.zero_quot

theorem one_quot : (âŸ¨Quot.mk _ 1âŸ© : RingQuot r) = 1 :=
  show _ = one r by rw [one_def]
                    -- ðŸŽ‰ no goals
#align ring_quot.one_quot RingQuot.one_quot

theorem add_quot {a b} : (âŸ¨Quot.mk _ aâŸ© + âŸ¨Quot.mk _ bâŸ© : RingQuot r) = âŸ¨Quot.mk _ (a + b)âŸ© := by
  show add r _ _ = _
  -- âŠ¢ RingQuot.add r { toQuot := Quot.mk (Rel r) a } { toQuot := Quot.mk (Rel r) b â€¦
  rw [add_def]
  -- âŠ¢ (match { toQuot := Quot.mk (Rel r) a }, { toQuot := Quot.mk (Rel r) b } with
  rfl
  -- ðŸŽ‰ no goals
#align ring_quot.add_quot RingQuot.add_quot

theorem mul_quot {a b} : (âŸ¨Quot.mk _ aâŸ© * âŸ¨Quot.mk _ bâŸ© : RingQuot r) = âŸ¨Quot.mk _ (a * b)âŸ© := by
  show mul r _ _ = _
  -- âŠ¢ RingQuot.mul r { toQuot := Quot.mk (Rel r) a } { toQuot := Quot.mk (Rel r) b â€¦
  rw [mul_def]
  -- âŠ¢ (match { toQuot := Quot.mk (Rel r) a }, { toQuot := Quot.mk (Rel r) b } with
  rfl
  -- ðŸŽ‰ no goals
#align ring_quot.mul_quot RingQuot.mul_quot

theorem pow_quot {a} {n : â„•} : (âŸ¨Quot.mk _ aâŸ© ^ n : RingQuot r) = âŸ¨Quot.mk _ (a ^ n)âŸ© := by
  show npow r _ _ = _
  -- âŠ¢ RingQuot.npow r n { toQuot := Quot.mk (Rel r) a } = { toQuot := Quot.mk (Rel â€¦
  rw [npow_def]
  -- ðŸŽ‰ no goals
#align ring_quot.pow_quot RingQuot.pow_quot

theorem neg_quot {R : Type uR} [Ring R] (r : R â†’ R â†’ Prop) {a} :
    (-âŸ¨Quot.mk _ aâŸ© : RingQuot r) = âŸ¨Quot.mk _ (-a)âŸ© := by
  show neg r _ = _
  -- âŠ¢ RingQuot.neg r { toQuot := Quot.mk (Rel r) a } = { toQuot := Quot.mk (Rel r) â€¦
  rw [neg_def]
  -- âŠ¢ (match { toQuot := Quot.mk (Rel r) a } with
  rfl
  -- ðŸŽ‰ no goals
#align ring_quot.neg_quot RingQuot.neg_quot

theorem sub_quot {R : Type uR} [Ring R] (r : R â†’ R â†’ Prop) {a b} :
    (âŸ¨Quot.mk _ aâŸ© - âŸ¨Quot.mk _ bâŸ© : RingQuot r) = âŸ¨Quot.mk _ (a - b)âŸ© := by
  show sub r _ _ = _
  -- âŠ¢ RingQuot.sub r { toQuot := Quot.mk (Rel r) a } { toQuot := Quot.mk (Rel r) b â€¦
  rw [sub_def]
  -- âŠ¢ (match { toQuot := Quot.mk (Rel r) a }, { toQuot := Quot.mk (Rel r) b } with
  rfl
  -- ðŸŽ‰ no goals
#align ring_quot.sub_quot RingQuot.sub_quot

theorem smul_quot [Algebra S R] {n : S} {a : R} :
    (n â€¢ âŸ¨Quot.mk _ aâŸ© : RingQuot r) = âŸ¨Quot.mk _ (n â€¢ a)âŸ© := by
  show smul r _ _ = _
  -- âŠ¢ RingQuot.smul r n { toQuot := Quot.mk (Rel r) a } = { toQuot := Quot.mk (Rel â€¦
  rw [smul]
  -- âŠ¢ (match { toQuot := Quot.mk (Rel r) a } with
  rfl
  -- ðŸŽ‰ no goals
#align ring_quot.smul_quot RingQuot.smul_quot

instance instIsScalarTowerRingQuot [CommSemiring T] [SMul S T] [Algebra S R] [Algebra T R]
    [IsScalarTower S T R] :
    IsScalarTower S T (RingQuot r) :=
  âŸ¨fun s t âŸ¨aâŸ© => Quot.inductionOn a <| fun a' => by simp only [RingQuot.smul_quot, smul_assoc]âŸ©
                                                     -- ðŸŽ‰ no goals

instance instSMulCommClassRingQuot [CommSemiring T] [Algebra S R] [Algebra T R]
    [SMulCommClass S T R] :
    SMulCommClass S T (RingQuot r) :=
  âŸ¨fun s t âŸ¨aâŸ© => Quot.inductionOn a <| fun a' => by simp only [RingQuot.smul_quot, smul_comm]âŸ©
                                                     -- ðŸŽ‰ no goals

instance instAddCommMonoid (r : R â†’ R â†’ Prop) : AddCommMonoid (RingQuot r) where
  add := (Â· + Â·)
  zero := 0
  add_assoc := by
    rintro âŸ¨âŸ¨âŸ©âŸ© âŸ¨âŸ¨âŸ©âŸ© âŸ¨âŸ¨âŸ©âŸ©
    -- âŠ¢ { toQuot := Quot.mk (Rel r) aâœÂ² } + { toQuot := Quot.mk (Rel r) aâœÂ¹ } + { to â€¦
    simp only [add_quot, add_assoc]
    -- ðŸŽ‰ no goals
  zero_add := by
    rintro âŸ¨âŸ¨âŸ©âŸ©
    -- âŠ¢ 0 + { toQuot := Quot.mk (Rel r) aâœ } = { toQuot := Quot.mk (Rel r) aâœ }
    simp [add_quot, â† zero_quot, zero_add]
    -- ðŸŽ‰ no goals
  add_zero := by
    rintro âŸ¨âŸ¨âŸ©âŸ©
    -- âŠ¢ { toQuot := Quot.mk (Rel r) aâœ } + 0 = { toQuot := Quot.mk (Rel r) aâœ }
    simp only [add_quot, â† zero_quot, add_zero]
    -- ðŸŽ‰ no goals
  add_comm := by
    rintro âŸ¨âŸ¨âŸ©âŸ© âŸ¨âŸ¨âŸ©âŸ©
    -- âŠ¢ { toQuot := Quot.mk (Rel r) aâœÂ¹ } + { toQuot := Quot.mk (Rel r) aâœ } = { toQ â€¦
    simp only [add_quot, add_comm]
    -- ðŸŽ‰ no goals
  nsmul := (Â· â€¢ Â·)
    -- âŠ¢ (fun x x_1 => x â€¢ x_1) 0 { toQuot := Quot.mk (Rel r) aâœ } = 0
  nsmul_zero := by
    -- ðŸŽ‰ no goals
    rintro âŸ¨âŸ¨âŸ©âŸ©
    simp only [smul_quot, zero_smul, zero_quot]
    -- âŠ¢ (fun x x_1 => x â€¢ x_1) (n + 1) { toQuot := Quot.mk (Rel r) aâœ } = { toQuot : â€¦
  nsmul_succ := by
    rintro n âŸ¨âŸ¨âŸ©âŸ©
    simp only [smul_quot, nsmul_eq_mul, Nat.cast_add, Nat.cast_one, add_mul, one_mul,
               add_comm, add_quot]

instance instMonoidWithZero (r : R â†’ R â†’ Prop) : MonoidWithZero (RingQuot r) where
  mul_assoc := by
    rintro âŸ¨âŸ¨âŸ©âŸ© âŸ¨âŸ¨âŸ©âŸ© âŸ¨âŸ¨âŸ©âŸ©
    -- âŠ¢ { toQuot := Quot.mk (Rel r) aâœÂ² } * { toQuot := Quot.mk (Rel r) aâœÂ¹ } * { to â€¦
    simp only [mul_quot, mul_assoc]
    -- ðŸŽ‰ no goals
  one_mul := by
    rintro âŸ¨âŸ¨âŸ©âŸ©
    -- âŠ¢ 1 * { toQuot := Quot.mk (Rel r) aâœ } = { toQuot := Quot.mk (Rel r) aâœ }
    simp only [mul_quot, â† one_quot, one_mul]
    -- ðŸŽ‰ no goals
  mul_one := by
    rintro âŸ¨âŸ¨âŸ©âŸ©
    -- âŠ¢ { toQuot := Quot.mk (Rel r) aâœ } * 1 = { toQuot := Quot.mk (Rel r) aâœ }
    simp only [mul_quot, â† one_quot, mul_one]
    -- ðŸŽ‰ no goals
  zero_mul := by
    rintro âŸ¨âŸ¨âŸ©âŸ©
    -- âŠ¢ 0 * { toQuot := Quot.mk (Rel r) aâœ } = 0
    simp only [mul_quot, â† zero_quot, zero_mul]
    -- ðŸŽ‰ no goals
  mul_zero := by
    rintro âŸ¨âŸ¨âŸ©âŸ©
    -- âŠ¢ { toQuot := Quot.mk (Rel r) aâœ } * 0 = 0
    simp only [mul_quot, â† zero_quot, mul_zero]
    -- âŠ¢ (fun n x => x ^ n) 0 { toQuot := Quot.mk (Rel r) aâœ } = 1
    -- ðŸŽ‰ no goals
    -- ðŸŽ‰ no goals
  npow n x := x ^ n
  npow_zero := by
    -- âŠ¢ (fun n x => x ^ n) (n + 1) { toQuot := Quot.mk (Rel r) aâœ } = { toQuot := Qu â€¦
    rintro âŸ¨âŸ¨âŸ©âŸ©
    -- ðŸŽ‰ no goals
    simp only [pow_quot, â† one_quot, pow_zero]
  npow_succ := by
    rintro n âŸ¨âŸ¨âŸ©âŸ©
    simp only [pow_quot, mul_quot, pow_succ]

instance instSemiring (r : R â†’ R â†’ Prop) : Semiring (RingQuot r) where
  natCast := natCast r
  natCast_zero := by simp [Nat.cast, natCast, â† zero_quot]
                     -- ðŸŽ‰ no goals
  natCast_succ := by simp [Nat.cast, natCast, â† one_quot, add_quot]
                     -- ðŸŽ‰ no goals
    -- âŠ¢ { toQuot := Quot.mk (Rel r) aâœÂ² } * ({ toQuot := Quot.mk (Rel r) aâœÂ¹ } + { t â€¦
  left_distrib := by
    -- ðŸŽ‰ no goals
    rintro âŸ¨âŸ¨âŸ©âŸ© âŸ¨âŸ¨âŸ©âŸ© âŸ¨âŸ¨âŸ©âŸ©
    simp only [mul_quot, add_quot, left_distrib]
    -- âŠ¢ ({ toQuot := Quot.mk (Rel r) aâœÂ² } + { toQuot := Quot.mk (Rel r) aâœÂ¹ }) * {  â€¦
  right_distrib := by
    -- âŠ¢ (fun x x_1 => x â€¢ x_1) 0 { toQuot := Quot.mk (Rel r) aâœ } = 0
    -- ðŸŽ‰ no goals
    -- ðŸŽ‰ no goals
    rintro âŸ¨âŸ¨âŸ©âŸ© âŸ¨âŸ¨âŸ©âŸ© âŸ¨âŸ¨âŸ©âŸ©
    simp only [mul_quot, add_quot, right_distrib]
    -- âŠ¢ (fun x x_1 => x â€¢ x_1) (n + 1) { toQuot := Quot.mk (Rel r) aâœ } = { toQuot : â€¦
  nsmul := (Â· â€¢ Â·)
  nsmul_zero := by
    rintro âŸ¨âŸ¨âŸ©âŸ©
    simp only [smul_quot, zero_smul, zero_quot]
  nsmul_succ := by
    rintro n âŸ¨âŸ¨âŸ©âŸ©
    simp only [smul_quot, nsmul_eq_mul, Nat.cast_add, Nat.cast_one, add_mul, one_mul,
               add_comm, add_quot]
  __ := instAddCommMonoid r
  __ := instMonoidWithZero r

-- can't be irreducible, causes diamonds in â„¤-algebras
private def intCast {R : Type uR} [Ring R] (r : R â†’ R â†’ Prop) (z : â„¤) : RingQuot r :=
  âŸ¨Quot.mk _ zâŸ©

instance instRing {R : Type uR} [Ring R] (r : R â†’ R â†’ Prop) : Ring (RingQuot r) :=
  { RingQuot.instSemiring r with
    neg := Neg.neg
    add_left_neg := by
      rintro âŸ¨âŸ¨âŸ©âŸ©
      -- âŠ¢ -{ toQuot := Quot.mk (Rel r) aâœ } + { toQuot := Quot.mk (Rel r) aâœ } = 0
      simp [neg_quot, add_quot, â† zero_quot]
      -- ðŸŽ‰ no goals
    sub := Sub.sub
      -- âŠ¢ { toQuot := Quot.mk (Rel r) aâœÂ¹ } - { toQuot := Quot.mk (Rel r) aâœ } = { toQ â€¦
    sub_eq_add_neg := by
      -- ðŸŽ‰ no goals
      rintro âŸ¨âŸ¨âŸ©âŸ© âŸ¨âŸ¨âŸ©âŸ©
      simp [neg_quot, sub_quot, add_quot, sub_eq_add_neg]
    zsmul := (Â· â€¢ Â·)
      -- âŠ¢ (fun x x_1 => x â€¢ x_1) 0 { toQuot := Quot.mk (Rel r) aâœ } = 0
    zsmul_zero' := by
      -- ðŸŽ‰ no goals
      rintro âŸ¨âŸ¨âŸ©âŸ©
      simp [smul_quot, â† zero_quot]
      -- âŠ¢ (fun x x_1 => x â€¢ x_1) (Int.ofNat (Nat.succ n)) { toQuot := Quot.mk (Rel r)  â€¦
    zsmul_succ' := by
      -- ðŸŽ‰ no goals
      rintro n âŸ¨âŸ¨âŸ©âŸ©
      simp [smul_quot, add_quot, add_mul, add_comm]
      -- âŠ¢ (fun x x_1 => x â€¢ x_1) (Int.negSucc n) { toQuot := Quot.mk (Rel r) aâœ } = -( â€¦
    zsmul_neg' := by
      -- ðŸŽ‰ no goals
      rintro n âŸ¨âŸ¨âŸ©âŸ©
      simp [smul_quot, neg_quot, add_mul]
    intCast := intCast r
    intCast_ofNat := fun n => congrArg RingQuot.mk <| by
      exact congrArg (Quot.mk _) (Int.cast_ofNat _)
      -- ðŸŽ‰ no goals
    intCast_negSucc := fun n => congrArg RingQuot.mk <| by
      simp_rw [neg_def]
      -- âŠ¢ Quot.mk (Rel r) â†‘(Int.negSucc n) = Quot.map (fun a => -a) (_ : âˆ€ â¦ƒa b : Râ¦„,  â€¦
      exact congrArg (Quot.mk _) (Int.cast_negSucc n) }
      -- ðŸŽ‰ no goals

instance instCommSemiring {R : Type uR} [CommSemiring R] (r : R â†’ R â†’ Prop) :
  CommSemiring (RingQuot r) :=
  { RingQuot.instSemiring r with
    mul_comm := by
      rintro âŸ¨âŸ¨âŸ©âŸ© âŸ¨âŸ¨âŸ©âŸ©
      -- âŠ¢ { toQuot := Quot.mk (Rel r) aâœÂ¹ } * { toQuot := Quot.mk (Rel r) aâœ } = { toQ â€¦
      simp [mul_quot, mul_comm] }
      -- ðŸŽ‰ no goals

instance {R : Type uR} [CommRing R] (r : R â†’ R â†’ Prop) : CommRing (RingQuot r) :=
  { RingQuot.instCommSemiring r, RingQuot.instRing r with }

instance instInhabitedRingQuot (r : R â†’ R â†’ Prop) : Inhabited (RingQuot r) :=
  âŸ¨0âŸ©

instance instAlgebraRingQuot [Algebra S R] (r : R â†’ R â†’ Prop) : Algebra S (RingQuot r) where
  smul := (Â· â€¢ Â·)
  toFun r := âŸ¨Quot.mk _ (algebraMap S R r)âŸ©
  map_one' := by simp [â† one_quot]
                 -- ðŸŽ‰ no goals
  map_mul' := by simp [mul_quot]
                 -- ðŸŽ‰ no goals
  map_zero' := by simp [â† zero_quot]
                  -- ðŸŽ‰ no goals
  map_add' := by simp [add_quot]
                 -- ðŸŽ‰ no goals
  commutes' r := by
    rintro âŸ¨âŸ¨aâŸ©âŸ©
    -- âŠ¢ â†‘{ toMonoidHom := { toOneHom := { toFun := fun r => { toQuot := Quot.mk (Rel â€¦
    simp [Algebra.commutes, mul_quot]
    -- ðŸŽ‰ no goals
  smul_def' r := by
    rintro âŸ¨âŸ¨aâŸ©âŸ©
    -- âŠ¢ r â€¢ { toQuot := Quot.mk (Rel râœ) a } = â†‘{ toMonoidHom := { toOneHom := { toF â€¦
    simp [smul_quot, Algebra.smul_def, mul_quot]
    -- ðŸŽ‰ no goals

/-- The quotient map from a ring to its quotient, as a homomorphism of rings.
-/
irreducible_def mkRingHom (r : R â†’ R â†’ Prop) : R â†’+* RingQuot r :=
  { toFun := fun x â†¦ âŸ¨Quot.mk _ xâŸ©
    map_one' := by simp [â† one_quot]
                   -- ðŸŽ‰ no goals
    map_mul' := by simp [mul_quot]
                   -- ðŸŽ‰ no goals
    map_zero' := by simp [â† zero_quot]
                    -- ðŸŽ‰ no goals
    map_add' := by simp [add_quot] }
                   -- ðŸŽ‰ no goals
#align ring_quot.mk_ring_hom RingQuot.mkRingHom

theorem mkRingHom_rel {r : R â†’ R â†’ Prop} {x y : R} (w : r x y) : mkRingHom r x = mkRingHom r y := by
  simp [mkRingHom_def, Quot.sound (Rel.of w)]
  -- ðŸŽ‰ no goals
#align ring_quot.mk_ring_hom_rel RingQuot.mkRingHom_rel

theorem mkRingHom_surjective (r : R â†’ R â†’ Prop) : Function.Surjective (mkRingHom r) := by
  simp [mkRingHom_def]
  -- âŠ¢ Function.Surjective fun x => { toQuot := Quot.mk (Rel r) x }
  rintro âŸ¨âŸ¨âŸ©âŸ©
  -- âŠ¢ âˆƒ a, (fun x => { toQuot := Quot.mk (Rel r) x }) a = { toQuot := Quot.mk (Rel â€¦
  simp
  -- ðŸŽ‰ no goals
#align ring_quot.mk_ring_hom_surjective RingQuot.mkRingHom_surjective

@[ext 1100]
theorem ringQuot_ext [Semiring T] {r : R â†’ R â†’ Prop} (f g : RingQuot r â†’+* T)
    (w : f.comp (mkRingHom r) = g.comp (mkRingHom r)) : f = g := by
  ext x
  -- âŠ¢ â†‘f x = â†‘g x
  rcases mkRingHom_surjective r x with âŸ¨x, rflâŸ©
  -- âŠ¢ â†‘f (â†‘(mkRingHom r) x) = â†‘g (â†‘(mkRingHom r) x)
  exact (RingHom.congr_fun w x : _)
  -- ðŸŽ‰ no goals
#align ring_quot.ring_quot_ext RingQuot.ringQuot_ext

variable [Semiring T]

irreducible_def preLift {r : R â†’ R â†’ Prop} { f : R â†’+* T } (h : âˆ€ â¦ƒx yâ¦„, r x y â†’ f x = f y) :
  RingQuot r â†’+* T :=
  { toFun := fun x â†¦ Quot.lift f
        (by
          rintro _ _ r
          -- âŠ¢ â†‘f aâœ = â†‘f bâœ
          induction r with
          | of r => exact h r
          | add_left _ r' => rw [map_add, map_add, r']
          | mul_left _ r' => rw [map_mul, map_mul, r']
          | mul_right _ r' => rw [map_mul, map_mul, r'])
        x.toQuot
    map_zero' := by simp only [â† zero_quot, f.map_zero]
                    -- ðŸŽ‰ no goals
    map_add' := by
      rintro âŸ¨âŸ¨xâŸ©âŸ© âŸ¨âŸ¨yâŸ©âŸ©
      -- âŠ¢ OneHom.toFun (â†‘{ toOneHom := { toFun := fun x => Quot.lift â†‘f (_ : âˆ€ (a b :  â€¦
                   -- ðŸŽ‰ no goals
      simp only [add_quot, f.map_add x y]
      -- ðŸŽ‰ no goals
      -- âŠ¢ OneHom.toFun { toFun := fun x => Quot.lift â†‘f (_ : âˆ€ (a b : R), Rel r a b â†’  â€¦
    map_one' := by simp only [â† one_quot, f.map_one]
      -- ðŸŽ‰ no goals
    map_mul' := by
      rintro âŸ¨âŸ¨xâŸ©âŸ© âŸ¨âŸ¨yâŸ©âŸ©
      simp only [mul_quot, f.map_mul x y] }

/-- Any ring homomorphism `f : R â†’+* T` which respects a relation `r : R â†’ R â†’ Prop`
factors uniquely through a morphism `RingQuot r â†’+* T`.
-/
irreducible_def lift {r : R â†’ R â†’ Prop} :
  { f : R â†’+* T // âˆ€ â¦ƒx yâ¦„, r x y â†’ f x = f y } â‰ƒ (RingQuot r â†’+* T) :=
  { toFun := fun f â†¦ preLift f.prop
    invFun := fun F â†¦ âŸ¨F.comp (mkRingHom r), fun x y h â†¦ congr_arg F (mkRingHom_rel h)âŸ©
    left_inv := fun f â†¦ by
      ext
      -- âŠ¢ â†‘â†‘((fun F => { val := RingHom.comp F (mkRingHom r), property := (_ : âˆ€ (x y  â€¦
      simp only [preLift_def, mkRingHom_def, RingHom.coe_comp, RingHom.coe_mk, MonoidHom.coe_mk,
                 OneHom.coe_mk, Function.comp_apply]
    right_inv := fun F â†¦ by
      simp only [preLift_def]
      -- âŠ¢ { toMonoidHom := { toOneHom := { toFun := fun x => Quot.lift â†‘(RingHom.comp  â€¦
      ext
      -- âŠ¢ â†‘(RingHom.comp { toMonoidHom := { toOneHom := { toFun := fun x => Quot.lift  â€¦
      simp only [mkRingHom_def, RingHom.coe_comp, RingHom.coe_mk, MonoidHom.coe_mk, OneHom.coe_mk,
                 Function.comp_apply, forall_const] }
#align ring_quot.lift RingQuot.lift

@[simp]
theorem lift_mkRingHom_apply (f : R â†’+* T) {r : R â†’ R â†’ Prop} (w : âˆ€ â¦ƒx yâ¦„, r x y â†’ f x = f y) (x) :
    lift âŸ¨f, wâŸ© (mkRingHom r x) = f x := by
  simp_rw [lift_def, preLift_def, mkRingHom_def]
  -- âŠ¢ â†‘(â†‘{ toFun := fun f => { toMonoidHom := { toOneHom := { toFun := fun x => Qu â€¦
  rfl
  -- ðŸŽ‰ no goals
#align ring_quot.lift_mk_ring_hom_apply RingQuot.lift_mkRingHom_apply

-- note this is essentially `lift.symm_apply_eq.mp h`
theorem lift_unique (f : R â†’+* T) {r : R â†’ R â†’ Prop} (w : âˆ€ â¦ƒx yâ¦„, r x y â†’ f x = f y)
    (g : RingQuot r â†’+* T) (h : g.comp (mkRingHom r) = f) : g = lift âŸ¨f, wâŸ© := by
  ext
  -- âŠ¢ â†‘(RingHom.comp g (mkRingHom r)) xâœ = â†‘(RingHom.comp (â†‘lift { val := f, prope â€¦
  simp [h]
  -- ðŸŽ‰ no goals
#align ring_quot.lift_unique RingQuot.lift_unique

theorem eq_lift_comp_mkRingHom {r : R â†’ R â†’ Prop} (f : RingQuot r â†’+* T) :
    f = lift âŸ¨f.comp (mkRingHom r), fun x y h â†¦ congr_arg f (mkRingHom_rel h)âŸ© := by
  conv_lhs => rw [â† lift.apply_symm_apply f]
  -- âŠ¢ â†‘lift (â†‘lift.symm f) = â†‘lift { val := RingHom.comp f (mkRingHom r), property â€¦
  rw [lift_def]
  -- âŠ¢ â†‘{ toFun := fun f => preLift (_ : âˆ€ â¦ƒx y : Râ¦„, r x y â†’ â†‘â†‘f x = â†‘â†‘f y), invFu â€¦
  rfl
  -- ðŸŽ‰ no goals
#align ring_quot.eq_lift_comp_mk_ring_hom RingQuot.eq_lift_comp_mkRingHom

section CommRing

/-!
We now verify that in the case of a commutative ring, the `RingQuot` construction
agrees with the quotient by the appropriate ideal.
-/


variable {B : Type uR} [CommRing B]

/-- The universal ring homomorphism from `RingQuot r` to `B â§¸ Ideal.ofRel r`. -/
def ringQuotToIdealQuotient (r : B â†’ B â†’ Prop) : RingQuot r â†’+* B â§¸ Ideal.ofRel r :=
  lift âŸ¨Ideal.Quotient.mk (Ideal.ofRel r),
        fun x y h â†¦ Ideal.Quotient.eq.2 <| Submodule.mem_sInf.mpr
          fun _ w â†¦ w âŸ¨x, y, h, sub_add_cancel x yâŸ©âŸ©
#align ring_quot.ring_quot_to_ideal_quotient RingQuot.ringQuotToIdealQuotient

@[simp]
theorem ringQuotToIdealQuotient_apply (r : B â†’ B â†’ Prop) (x : B) :
    ringQuotToIdealQuotient r (mkRingHom r x) = Ideal.Quotient.mk (Ideal.ofRel r) x := by
  simp_rw [ringQuotToIdealQuotient, lift_def, preLift_def, mkRingHom_def]
  -- âŠ¢ â†‘(â†‘{ toFun := fun f => { toMonoidHom := { toOneHom := { toFun := fun x => Qu â€¦
  rfl
  -- ðŸŽ‰ no goals
#align ring_quot.ring_quot_to_ideal_quotient_apply RingQuot.ringQuotToIdealQuotient_apply

/-- The universal ring homomorphism from `B â§¸ Ideal.ofRel r` to `RingQuot r`. -/
def idealQuotientToRingQuot (r : B â†’ B â†’ Prop) : B â§¸ Ideal.ofRel r â†’+* RingQuot r :=
  Ideal.Quotient.lift (Ideal.ofRel r) (mkRingHom r)
    (by
      refine' fun x h â†¦ Submodule.span_induction h _ _ _ _
      Â· rintro y âŸ¨a, b, h, suâŸ©
        -- âŠ¢ â†‘(mkRingHom r) y = 0
        symm at su
        -- âŠ¢ â†‘(mkRingHom r) y = 0
        rw [â† sub_eq_iff_eq_add] at su
        -- âŠ¢ â†‘(mkRingHom r) y = 0
        rw [â† su, RingHom.map_sub, mkRingHom_rel h, sub_self]
        -- ðŸŽ‰ no goals
      Â· simp
        -- ðŸŽ‰ no goals
      Â· intro a b ha hb
        -- âŠ¢ â†‘(mkRingHom r) (a + b) = 0
        simp [ha, hb]
        -- ðŸŽ‰ no goals
      Â· intro a x hx
        -- âŠ¢ â†‘(mkRingHom r) (a â€¢ x) = 0
        simp [hx])
        -- ðŸŽ‰ no goals
#align ring_quot.ideal_quotient_to_ring_quot RingQuot.idealQuotientToRingQuot

@[simp]
theorem idealQuotientToRingQuot_apply (r : B â†’ B â†’ Prop) (x : B) :
    idealQuotientToRingQuot r (Ideal.Quotient.mk _ x) = mkRingHom r x :=
  rfl
#align ring_quot.ideal_quotient_to_ring_quot_apply RingQuot.idealQuotientToRingQuot_apply


/-- The ring equivalence between `RingQuot r` and `(Ideal.ofRel r).quotient`
-/
def ringQuotEquivIdealQuotient (r : B â†’ B â†’ Prop) : RingQuot r â‰ƒ+* B â§¸ Ideal.ofRel r :=
  RingEquiv.ofHomInv (ringQuotToIdealQuotient r) (idealQuotientToRingQuot r)
    (by
      ext x
      -- âŠ¢ â†‘(RingHom.comp (RingHom.comp â†‘(idealQuotientToRingQuot r) â†‘(ringQuotToIdealQ â€¦
      simp_rw [ringQuotToIdealQuotient, lift_def, preLift_def, mkRingHom_def]
      -- âŠ¢ â†‘(RingHom.comp (RingHom.comp â†‘(idealQuotientToRingQuot r) â†‘(â†‘{ toFun := fun  â€¦
      change mkRingHom r x = _
      -- âŠ¢ â†‘(mkRingHom r) x = â†‘(RingHom.comp (RingHom.id (RingQuot r)) { toMonoidHom := â€¦
      rw [mkRingHom_def]
      -- âŠ¢ â†‘{ toMonoidHom := { toOneHom := { toFun := fun x => { toQuot := Quot.mk (Rel â€¦
      rfl)
      -- ðŸŽ‰ no goals
    (by
      ext x
      -- âŠ¢ â†‘(RingHom.comp (RingHom.comp â†‘(ringQuotToIdealQuotient r) â†‘(idealQuotientToR â€¦
      simp_rw [ringQuotToIdealQuotient, lift_def, preLift_def, mkRingHom_def]
      -- âŠ¢ â†‘(RingHom.comp (RingHom.comp â†‘(â†‘{ toFun := fun f => { toMonoidHom := { toOne â€¦
      change Quot.lift _ _ ((mkRingHom r) x).toQuot = _
      -- âŠ¢ Quot.lift â†‘â†‘{ val := Ideal.Quotient.mk (Ideal.ofRel r), property := (_ : âˆ€ ( â€¦
      rw [mkRingHom_def]
      -- âŠ¢ Quot.lift â†‘â†‘{ val := Ideal.Quotient.mk (Ideal.ofRel r), property := (_ : âˆ€ ( â€¦
      rfl)
      -- ðŸŽ‰ no goals
#align ring_quot.ring_quot_equiv_ideal_quotient RingQuot.ringQuotEquivIdealQuotient

end CommRing

section StarRing

variable [StarRing R] (hr : âˆ€ a b, r a b â†’ r (star a) (star b))

theorem Rel.star â¦ƒa b : Râ¦„ (h : Rel r a b) : Rel r (star a) (star b) := by
  induction h with
  | of h          => exact Rel.of (hr _ _ h)
  | add_left _ h  => rw [star_add, star_add]
                     exact Rel.add_left h
  | mul_left _ h  => rw [star_mul, star_mul]
                     exact Rel.mul_right h
  | mul_right _ h => rw [star_mul, star_mul]
                     exact Rel.mul_left h
#align ring_quot.rel.star RingQuot.Rel.star

private irreducible_def star' : RingQuot r â†’ RingQuot r
  | âŸ¨aâŸ© => âŸ¨Quot.map (star : R â†’ R) (Rel.star r hr) aâŸ©

theorem star'_quot (hr : âˆ€ a b, r a b â†’ r (star a) (star b)) {a} :
    (star' r hr âŸ¨Quot.mk _ aâŸ© : RingQuot r) = âŸ¨Quot.mk _ (star a)âŸ© := star'_def _ _ _
#align ring_quot.star'_quot RingQuot.star'_quot

/-- Transfer a star_ring instance through a quotient, if the quotient is invariant to `star` -/
def starRing {R : Type uR} [Semiring R] [StarRing R] (r : R â†’ R â†’ Prop)
    (hr : âˆ€ a b, r a b â†’ r (star a) (star b)) : StarRing (RingQuot r) where
  star := star' r hr
  star_involutive := by
    rintro âŸ¨âŸ¨âŸ©âŸ©
    -- âŠ¢ star (star { toQuot := Quot.mk (Rel r) aâœ }) = { toQuot := Quot.mk (Rel r) a â€¦
    simp [star'_quot]
    -- ðŸŽ‰ no goals
  star_mul := by
    rintro âŸ¨âŸ¨âŸ©âŸ© âŸ¨âŸ¨âŸ©âŸ©
    -- âŠ¢ star ({ toQuot := Quot.mk (Rel r) aâœÂ¹ } * { toQuot := Quot.mk (Rel r) aâœ })  â€¦
    simp [star'_quot, mul_quot, star_mul]
    -- ðŸŽ‰ no goals
  star_add := by
    rintro âŸ¨âŸ¨âŸ©âŸ© âŸ¨âŸ¨âŸ©âŸ©
    -- âŠ¢ star ({ toQuot := Quot.mk (Rel r) aâœÂ¹ } + { toQuot := Quot.mk (Rel r) aâœ })  â€¦
    simp [star'_quot, add_quot, star_add]
    -- ðŸŽ‰ no goals
#align ring_quot.star_ring RingQuot.starRing

end StarRing

section Algebra

variable (S)

/-- The quotient map from an `S`-algebra to its quotient, as a homomorphism of `S`-algebras.
-/
irreducible_def mkAlgHom (s : A â†’ A â†’ Prop) : A â†’â‚[S] RingQuot s :=
  { mkRingHom s with
    commutes' := fun _ â†¦ by simp [mkRingHom_def]; rfl }
                            -- âŠ¢ { toQuot := Quot.mk (Rel s) (â†‘(algebraMap S A) xâœ) } = â†‘(algebraMap S (RingQ â€¦
                                                  -- ðŸŽ‰ no goals
#align ring_quot.mk_alg_hom RingQuot.mkAlgHom

@[simp]
theorem mkAlgHom_coe (s : A â†’ A â†’ Prop) : (mkAlgHom S s : A â†’+* RingQuot s) = mkRingHom s := by
  simp_rw [mkAlgHom_def, mkRingHom_def]
  -- âŠ¢ â†‘{ toRingHom := { toMonoidHom := { toOneHom := { toFun := fun x => { toQuot  â€¦
  rfl
  -- ðŸŽ‰ no goals
#align ring_quot.mk_alg_hom_coe RingQuot.mkAlgHom_coe

theorem mkAlgHom_rel {s : A â†’ A â†’ Prop} {x y : A} (w : s x y) : mkAlgHom S s x = mkAlgHom S s y :=
  by simp [mkAlgHom_def, mkRingHom_def, Quot.sound (Rel.of w)]
     -- ðŸŽ‰ no goals
#align ring_quot.mk_alg_hom_rel RingQuot.mkAlgHom_rel

theorem mkAlgHom_surjective (s : A â†’ A â†’ Prop) : Function.Surjective (mkAlgHom S s) := by
  suffices : Function.Surjective fun x â†¦ (âŸ¨.mk (Rel s) xâŸ© : RingQuot s)
  -- âŠ¢ Function.Surjective â†‘(mkAlgHom S s)
  Â· simpa [mkAlgHom_def, mkRingHom_def]
    -- ðŸŽ‰ no goals
  rintro âŸ¨âŸ¨aâŸ©âŸ©
  -- âŠ¢ âˆƒ a_1, (fun x => { toQuot := Quot.mk (Rel s) x }) a_1 = { toQuot := Quot.mk  â€¦
  use a
  -- ðŸŽ‰ no goals
#align ring_quot.mk_alg_hom_surjective RingQuot.mkAlgHom_surjective

variable {B : Type uâ‚„} [Semiring B] [Algebra S B]

@[ext 1100]
theorem ringQuot_ext' {s : A â†’ A â†’ Prop} (f g : RingQuot s â†’â‚[S] B)
    (w : f.comp (mkAlgHom S s) = g.comp (mkAlgHom S s)) : f = g := by
  ext x
  -- âŠ¢ â†‘f x = â†‘g x
  rcases mkAlgHom_surjective S s x with âŸ¨x, rflâŸ©
  -- âŠ¢ â†‘f (â†‘(mkAlgHom S s) x) = â†‘g (â†‘(mkAlgHom S s) x)
  exact AlgHom.congr_fun w x
  -- ðŸŽ‰ no goals
#align ring_quot.ring_quot_ext' RingQuot.ringQuot_ext'

irreducible_def preLiftAlgHom {s : A â†’ A â†’ Prop} { f : A â†’â‚[S] B }
  (h : âˆ€ â¦ƒx yâ¦„, s x y â†’ f x = f y) : RingQuot s â†’â‚[S] B :=
{ toFun := fun x â†¦ Quot.lift f
            (by
              rintro _ _ r
              -- âŠ¢ â†‘f aâœ = â†‘f bâœ
              induction r with
              | of r => exact h r
              | add_left _ r' => simp only [map_add, r']
              | mul_left _ r' => simp only [map_mul, r']
              | mul_right _ r' => simp only [map_mul, r'])
            x.toQuot
  map_zero' := by simp only [â† zero_quot, f.map_zero]
                  -- ðŸŽ‰ no goals
  map_add' := by
    rintro âŸ¨âŸ¨xâŸ©âŸ© âŸ¨âŸ¨yâŸ©âŸ©
    -- âŠ¢ OneHom.toFun (â†‘{ toOneHom := { toFun := fun x => Quot.lift â†‘f (_ : âˆ€ (a b :  â€¦
                 -- ðŸŽ‰ no goals
    simp only [add_quot, f.map_add x y]
    -- ðŸŽ‰ no goals
    -- âŠ¢ OneHom.toFun { toFun := fun x => Quot.lift â†‘f (_ : âˆ€ (a b : A), Rel s a b â†’  â€¦
  map_one' := by simp only [â† one_quot, f.map_one]
    -- ðŸŽ‰ no goals
  map_mul' := by
    rintro âŸ¨âŸ¨xâŸ©âŸ© âŸ¨âŸ¨yâŸ©âŸ©
    simp only [mul_quot, f.map_mul x y]
  commutes' := by
    rintro x
    -- âŠ¢ OneHom.toFun (â†‘â†‘{ toMonoidHom := { toOneHom := { toFun := fun x => Quot.lift â€¦
    simp [â† one_quot, smul_quot, Algebra.algebraMap_eq_smul_one] }
    -- ðŸŽ‰ no goals

/-- Any `S`-algebra homomorphism `f : A â†’â‚[S] B` which respects a relation `s : A â†’ A â†’ Prop`
factors uniquely through a morphism `RingQuot s â†’â‚[S] B`.
-/
irreducible_def liftAlgHom {s : A â†’ A â†’ Prop} :
  { f : A â†’â‚[S] B // âˆ€ â¦ƒx yâ¦„, s x y â†’ f x = f y } â‰ƒ (RingQuot s â†’â‚[S] B) :=
  { toFun := fun f' â†¦ preLiftAlgHom _ f'.prop
    invFun := fun F â†¦ âŸ¨F.comp (mkAlgHom S s), fun _ _ h â†¦ congr_arg F (mkAlgHom_rel S h)âŸ©
    left_inv := fun f â†¦ by
      ext
      -- âŠ¢ â†‘â†‘((fun F => { val := AlgHom.comp F (mkAlgHom S s), property := (_ : âˆ€ (x x_ â€¦
      simp only [preLiftAlgHom_def, mkAlgHom_def, mkRingHom_def, RingHom.toMonoidHom_eq_coe,
                 RingHom.coe_monoidHom_mk, AlgHom.coe_comp, AlgHom.coe_mk, RingHom.coe_mk,
                 MonoidHom.coe_mk, OneHom.coe_mk, Function.comp_apply]
    right_inv := fun F â†¦ by
      ext
      -- âŠ¢ â†‘(AlgHom.comp ((fun f' => preLiftAlgHom S (_ : âˆ€ â¦ƒx y : Aâ¦„, s x y â†’ â†‘â†‘f' x = â€¦
      simp only [preLiftAlgHom_def, mkAlgHom_def, mkRingHom_def, RingHom.toMonoidHom_eq_coe,
                 RingHom.coe_monoidHom_mk, AlgHom.coe_comp, AlgHom.coe_mk, RingHom.coe_mk,
                 MonoidHom.coe_mk, OneHom.coe_mk, Function.comp_apply] }
#align ring_quot.lift_alg_hom RingQuot.liftAlgHom

@[simp]
theorem liftAlgHom_mkAlgHom_apply (f : A â†’â‚[S] B) {s : A â†’ A â†’ Prop}
    (w : âˆ€ â¦ƒx yâ¦„, s x y â†’ f x = f y) (x) : (liftAlgHom S âŸ¨f, wâŸ©) ((mkAlgHom S s) x) = f x := by
  simp_rw [liftAlgHom_def, preLiftAlgHom_def, mkAlgHom_def, mkRingHom_def]
  -- âŠ¢ â†‘(â†‘{ toFun := fun f' => { toRingHom := { toMonoidHom := { toOneHom := { toFu â€¦
  rfl
  -- ðŸŽ‰ no goals
#align ring_quot.lift_alg_hom_mk_alg_hom_apply RingQuot.liftAlgHom_mkAlgHom_apply

-- note this is essentially `(liftAlgHom S).symm_apply_eq.mp h`
theorem liftAlgHom_unique (f : A â†’â‚[S] B) {s : A â†’ A â†’ Prop} (w : âˆ€ â¦ƒx yâ¦„, s x y â†’ f x = f y)
    (g : RingQuot s â†’â‚[S] B) (h : g.comp (mkAlgHom S s) = f) : g = liftAlgHom S âŸ¨f, wâŸ© := by
  ext
  -- âŠ¢ â†‘(AlgHom.comp g (mkAlgHom S s)) xâœ = â†‘(AlgHom.comp (â†‘(liftAlgHom S) { val := â€¦
  simp [h]
  -- ðŸŽ‰ no goals
#align ring_quot.lift_alg_hom_unique RingQuot.liftAlgHom_unique

theorem eq_liftAlgHom_comp_mkAlgHom {s : A â†’ A â†’ Prop} (f : RingQuot s â†’â‚[S] B) :
    f = liftAlgHom S âŸ¨f.comp (mkAlgHom S s), fun x y h â†¦ congr_arg f (mkAlgHom_rel S h)âŸ© := by
  conv_lhs => rw [â† (liftAlgHom S).apply_symm_apply f]
  -- âŠ¢ â†‘(liftAlgHom S) (â†‘(liftAlgHom S).symm f) = â†‘(liftAlgHom S) { val := AlgHom.c â€¦
  rw [liftAlgHom]
  -- âŠ¢ â†‘{ toFun := fun f' => preLiftAlgHom S (_ : âˆ€ â¦ƒx y : Aâ¦„, s x y â†’ â†‘â†‘f' x = â†‘â†‘f â€¦
  rfl
  -- ðŸŽ‰ no goals
#align ring_quot.eq_lift_alg_hom_comp_mk_alg_hom RingQuot.eq_liftAlgHom_comp_mkAlgHom

end Algebra

end RingQuot
