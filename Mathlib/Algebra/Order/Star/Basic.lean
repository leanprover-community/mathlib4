/-
Copyright (c) 2023 Kim Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import Mathlib.Algebra.Group.Submonoid.Operations
import Mathlib.Algebra.GroupWithZero.Regular
import Mathlib.Algebra.NoZeroSMulDivisors.Defs
import Mathlib.Algebra.Order.Group.Nat
import Mathlib.Algebra.Order.Group.Opposite
import Mathlib.Algebra.Star.SelfAdjoint
import Mathlib.Algebra.Star.StarRingHom
import Mathlib.Tactic.ContinuousFunctionalCalculus
import Mathlib.Algebra.Star.StarProjection
import Mathlib.Algebra.Order.Module.OrderedSMul

/-! # Star ordered rings

We define the class `StarOrderedRing R`, which says that the order on `R` respects the
star operation, i.e. an element `r` is nonnegative iff it is in the `AddSubmonoid` generated by
elements of the form `star s * s`. In many cases, including all Câ‹†-algebras, this can be reduced to
`0 â‰¤ r â†” âˆƒ s, r = star s * s`. However, this generality is slightly more convenient (e.g., it
allows us to register a `StarOrderedRing` instance for `â„š`), and more closely resembles the
literature (see the seminal paper [*The positive cone in Banach algebras*][kelleyVaught1953])

In order to accommodate `NonUnitalSemiring R`, we actually don't characterize nonnegativity, but
rather the entire `â‰¤` relation with `StarOrderedRing.le_iff`. However, notice that when `R` is a
`NonUnitalRing`, these are equivalent (see `StarOrderedRing.nonneg_iff` and
`StarOrderedRing.of_nonneg_iff`).

It is important to note that while a `StarOrderedRing` is an `OrderedAddCommMonoid` it is often
*not* an `OrderedSemiring`.

## TODO

* In a Banach star algebra without a well-defined square root, the natural ordering is given by the
  positive cone which is the _closure_ of the sums of elements `star r * r`. A weaker version of
  `StarOrderedRing` could be defined for this case (again, see
  [*The positive cone in Banach algebras*][kelleyVaught1953]). Note that the current definition has
  the advantage of not requiring a topology.
-/

open Set
open scoped NNRat

universe u

variable {R : Type u}

/-- An ordered `*`-ring is a `*`ring with a partial order such that the nonnegative elements
constitute precisely the `AddSubmonoid` generated by elements of the form `star s * s`.

If you are working with a `NonUnitalRing` and not a `NonUnitalSemiring`, it may be more
convenient to declare instances using `StarOrderedRing.of_nonneg_iff`. -/
class StarOrderedRing (R : Type u) [NonUnitalSemiring R] [PartialOrder R]
    [StarRing R] : Prop where
  /-- characterization of the order in terms of the `StarRing` structure. -/
  le_iff :
    âˆ€ x y : R, x â‰¤ y â†” âˆƒ p, p âˆˆ AddSubmonoid.closure (Set.range fun s => star s * s) âˆ§ y = x + p

namespace StarOrderedRing

-- see note [lower instance priority]
instance (priority := 100) toIsOrderedAddMonoid [NonUnitalSemiring R] [PartialOrder R]
    [StarRing R] [StarOrderedRing R] : IsOrderedAddMonoid R where
  add_le_add_left := fun x y hle z â†¦ by
    rw [StarOrderedRing.le_iff] at hle âŠ¢
    refine hle.imp fun s hs â†¦ ?_
    rw [hs.2, add_assoc]
    exact âŸ¨hs.1, rflâŸ©

-- see note [lower instance priority]
instance (priority := 100) toExistsAddOfLE [NonUnitalSemiring R] [PartialOrder R]
    [StarRing R] [StarOrderedRing R] : ExistsAddOfLE R where
  exists_add_of_le h :=
    match (le_iff _ _).mp h with
    | âŸ¨p, _, hpâŸ© => âŸ¨p, hpâŸ©

/-- To construct a `StarOrderedRing` instance it suffices to show that `x â‰¤ y` if and only if
`y = x + star s * s` for some `s : R`.

This is provided for convenience because it holds in some common scenarios (e.g.,`â„â‰¥0`, `C(X, â„â‰¥0)`)
and obviates the hassle of `AddSubmonoid.closure_induction` when creating those instances.

If you are working with a `NonUnitalRing` and not a `NonUnitalSemiring`, see
`StarOrderedRing.of_nonneg_iff` for a more convenient version.
-/
lemma of_le_iff [NonUnitalSemiring R] [PartialOrder R] [StarRing R]
    (h_le_iff : âˆ€ x y : R, x â‰¤ y â†” âˆƒ s, y = x + star s * s) : StarOrderedRing R where
  le_iff x y := by
    refine âŸ¨fun h => ?_, ?_âŸ©
    Â· obtain âŸ¨p, hpâŸ© := (h_le_iff x y).mp h
      exact âŸ¨star p * p, AddSubmonoid.subset_closure âŸ¨p, rflâŸ©, hpâŸ©
    Â· rintro âŸ¨p, hp, hpxyâŸ©
      revert x y hpxy
      refine AddSubmonoid.closure_induction ?_ (fun x y h => add_zero x â–¸ h.ge) ?_ hp
      Â· rintro _ âŸ¨s, rflâŸ© x y rfl
        exact (h_le_iff _ _).mpr âŸ¨s, rflâŸ©
      Â· rintro _ _ _ _ ha hb x y rfl
        rw [â† add_assoc]
        exact (ha _ _ rfl).trans (hb _ _ rfl)

/-- When `R` is a non-unital ring, to construct a `StarOrderedRing` instance it suffices to
show that the nonnegative elements are precisely those elements in the `AddSubmonoid` generated
by `star s * s` for `s : R`. -/
lemma of_nonneg_iff [NonUnitalRing R] [PartialOrder R] [StarRing R]
    (h_add : âˆ€ {x y : R}, x â‰¤ y â†’ âˆ€ z, z + x â‰¤ z + y)
    (h_nonneg_iff : âˆ€ x : R, 0 â‰¤ x â†” x âˆˆ AddSubmonoid.closure (Set.range fun s : R => star s * s)) :
    StarOrderedRing R where
  le_iff x y := by
    have : AddLeftMono R := âŸ¨fun _ _ _ h => h_add h _âŸ©
    simpa only [â† sub_eq_iff_eq_add', sub_nonneg, exists_eq_right'] using h_nonneg_iff (y - x)

/-- When `R` is a non-unital ring, to construct a `StarOrderedRing` instance it suffices to
show that the nonnegative elements are precisely those elements of the form `star s * s`
for `s : R`.

This is provided for convenience because it holds in many common scenarios (e.g.,`â„`, `â„‚`, or
any Câ‹†-algebra), and obviates the hassle of `AddSubmonoid.closure_induction` when creating those
instances. -/
lemma of_nonneg_iff' [NonUnitalRing R] [PartialOrder R] [StarRing R]
    (h_add : âˆ€ {x y : R}, x â‰¤ y â†’ âˆ€ z, z + x â‰¤ z + y)
    (h_nonneg_iff : âˆ€ x : R, 0 â‰¤ x â†” âˆƒ s, x = star s * s) : StarOrderedRing R :=
  of_le_iff <| by
    have : AddLeftMono R := âŸ¨fun _ _ _ h => h_add h _âŸ©
    simpa [sub_eq_iff_eq_add', sub_nonneg] using fun x y => h_nonneg_iff (y - x)

theorem nonneg_iff [NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R] {x : R} :
    0 â‰¤ x â†” x âˆˆ AddSubmonoid.closure (Set.range fun s : R => star s * s) := by
  simp only [le_iff, zero_add, exists_eq_right']

end StarOrderedRing

section NonUnitalSemiring

variable [NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]

lemma IsSelfAdjoint.mono {x y : R} (h : x â‰¤ y) (hx : IsSelfAdjoint x) : IsSelfAdjoint y := by
  rw [StarOrderedRing.le_iff] at h
  obtain âŸ¨d, hd, rflâŸ© := h
  rw [IsSelfAdjoint, star_add, hx.star_eq]
  congr
  refine AddMonoidHom.eqOn_closureM (f := starAddEquiv (R := R)) (g := .id R) ?_ hd
  rintro - âŸ¨s, rflâŸ©
  simp

@[aesop 10% apply]
lemma IsSelfAdjoint.of_nonneg {x : R} (hx : 0 â‰¤ x) : IsSelfAdjoint x :=
  .mono hx <| .zero R

/-- An alias of `IsSelfAdjoint.of_nonneg` for use with dot notation. -/
alias LE.le.isSelfAdjoint := IsSelfAdjoint.of_nonneg

/-- The combination `(IsSelfAdjoint.star_eq <| .of_nonneg Â·)` for use with dot notation. -/
lemma LE.le.star_eq {x : R} (hx : 0 â‰¤ x) : star x = x :=
  hx.isSelfAdjoint.star_eq

@[simp]
theorem star_mul_self_nonneg (r : R) : 0 â‰¤ star r * r :=
  StarOrderedRing.nonneg_iff.mpr <| AddSubmonoid.subset_closure âŸ¨r, rflâŸ©

@[simp]
theorem mul_star_self_nonneg (r : R) : 0 â‰¤ r * star r := by
  simpa only [star_star] using star_mul_self_nonneg (star r)

@[aesop safe apply (rule_sets := [CStarAlgebra])]
protected theorem IsSelfAdjoint.mul_self_nonneg {a : R} (ha : IsSelfAdjoint a) : 0 â‰¤ a * a := by
  simpa [ha.star_eq] using star_mul_self_nonneg a

/-- A star projection is non-negative in a star-ordered ring. -/
theorem IsStarProjection.nonneg {p : R} (hp : IsStarProjection p) : 0 â‰¤ p :=
  hp.isIdempotentElem â–¸ hp.isSelfAdjoint.mul_self_nonneg

@[aesop safe apply]
theorem conjugate_nonneg {a : R} (ha : 0 â‰¤ a) (c : R) : 0 â‰¤ star c * a * c := by
  rw [StarOrderedRing.nonneg_iff] at ha
  refine AddSubmonoid.closure_induction (fun x hx => ?_)
    (by rw [mul_zero, zero_mul]) (fun x y _ _ hx hy => ?_) ha
  Â· obtain âŸ¨x, rflâŸ© := hx
    convert star_mul_self_nonneg (x * c) using 1
    rw [star_mul, â† mul_assoc, mul_assoc _ _ c]
  Â· calc
      0 â‰¤ star c * x * c + 0 := by rw [add_zero]; exact hx
      _ â‰¤ star c * x * c + star c * y * c := add_le_add_left hy _
      _ â‰¤ _ := by rw [mul_add, add_mul]

@[aesop safe apply]
theorem conjugate_nonneg' {a : R} (ha : 0 â‰¤ a) (c : R) : 0 â‰¤ c * a * star c := by
  simpa only [star_star] using conjugate_nonneg ha (star c)

@[aesop 90% apply (rule_sets := [CStarAlgebra])]
protected theorem IsSelfAdjoint.conjugate_nonneg {a : R} (ha : 0 â‰¤ a) {c : R}
    (hc : IsSelfAdjoint c) : 0 â‰¤ c * a * c := by
  nth_rewrite 2 [â† hc]; exact conjugate_nonneg' ha c

theorem conjugate_nonneg_of_nonneg {a : R} (ha : 0 â‰¤ a) {c : R} (hc : 0 â‰¤ c) :
    0 â‰¤ c * a * c :=
  IsSelfAdjoint.of_nonneg hc |>.conjugate_nonneg ha

theorem conjugate_le_conjugate {a b : R} (hab : a â‰¤ b) (c : R) :
    star c * a * c â‰¤ star c * b * c := by
  rw [StarOrderedRing.le_iff] at hab âŠ¢
  obtain âŸ¨p, hp, rflâŸ© := hab
  simp_rw [â† StarOrderedRing.nonneg_iff] at hp âŠ¢
  exact âŸ¨star c * p * c, conjugate_nonneg hp c, by simp only [add_mul, mul_add]âŸ©

theorem conjugate_le_conjugate' {a b : R} (hab : a â‰¤ b) (c : R) :
    c * a * star c â‰¤ c * b * star c := by
  simpa only [star_star] using conjugate_le_conjugate hab (star c)

protected theorem IsSelfAdjoint.conjugate_le_conjugate {a b : R} (hab : a â‰¤ b) {c : R}
    (hc : IsSelfAdjoint c) : c * a * c â‰¤ c * b * c := by
  simpa only [hc.star_eq] using conjugate_le_conjugate hab c

theorem conjugate_le_conjugate_of_nonneg {a b : R} (hab : a â‰¤ b) {c : R} (hc : 0 â‰¤ c) :
    c * a * c â‰¤ c * b * c :=
  IsSelfAdjoint.of_nonneg hc |>.conjugate_le_conjugate hab

@[simp]
lemma star_le_star_iff {x y : R} : star x â‰¤ star y â†” x â‰¤ y := by
  suffices âˆ€ x y, x â‰¤ y â†’ star x â‰¤ star y from
    âŸ¨by simpa only [star_star] using this (star x) (star y), this x yâŸ©
  intro x y h
  rw [StarOrderedRing.le_iff] at h âŠ¢
  obtain âŸ¨d, hd, rflâŸ© := h
  refine âŸ¨starAddEquiv d, ?_, star_add _ _âŸ©
  refine AddMonoidHom.mclosure_preimage_le _ _ <| AddSubmonoid.closure_mono ?_ hd
  rintro - âŸ¨s, rflâŸ©
  exact âŸ¨s, by simpâŸ©

@[simp]
lemma star_lt_star_iff {x y : R} : star x < star y â†” x < y := by
  by_cases h : x = y
  Â· simp [h]
  Â· simpa [le_iff_lt_or_eq, h] using star_le_star_iff (x := x) (y := y)

lemma star_le_iff {x y : R} : star x â‰¤ y â†” x â‰¤ star y := by rw [â† star_le_star_iff, star_star]

lemma star_lt_iff {x y : R} : star x < y â†” x < star y := by rw [â† star_lt_star_iff, star_star]

@[simp]
lemma star_nonneg_iff {x : R} : 0 â‰¤ star x â†” 0 â‰¤ x := by
  simpa using star_le_star_iff (x := 0) (y := x)

@[simp]
lemma star_nonpos_iff {x : R} : star x â‰¤ 0 â†” x â‰¤ 0 := by
  simpa using star_le_star_iff (x := x) (y := 0)

@[simp]
lemma star_pos_iff {x : R} : 0 < star x â†” 0 < x := by
  simpa using star_lt_star_iff (x := 0) (y := x)

@[simp]
lemma star_neg_iff {x : R} : star x < 0 â†” x < 0 := by
  simpa using star_lt_star_iff (x := x) (y := 0)

theorem conjugate_lt_conjugate {a b : R} (hab : a < b) {c : R} (hc : IsRegular c) :
    star c * a * c < star c * b * c := by
  rw [(conjugate_le_conjugate hab.le _).lt_iff_ne, hc.right.ne_iff, hc.star.left.ne_iff]
  exact hab.ne

theorem conjugate_lt_conjugate' {a b : R} (hab : a < b) {c : R} (hc : IsRegular c) :
    c * a * star c < c * b * star c := by
  simpa only [star_star] using conjugate_lt_conjugate hab hc.star

theorem conjugate_pos {a : R} (ha : 0 < a) {c : R} (hc : IsRegular c) : 0 < star c * a * c := by
  simpa only [mul_zero, zero_mul] using conjugate_lt_conjugate ha hc

theorem conjugate_pos' {a : R} (ha : 0 < a) {c : R} (hc : IsRegular c) : 0 < c * a * star c := by
  simpa only [star_star] using conjugate_pos ha hc.star

theorem star_mul_self_pos [Nontrivial R] {x : R} (hx : IsRegular x) : 0 < star x * x := by
  rw [(star_mul_self_nonneg _).lt_iff_ne, â† mul_zero (star x), hx.star.left.ne_iff]
  exact hx.ne_zero.symm

theorem mul_star_self_pos [Nontrivial R] {x : R} (hx : IsRegular x) : 0 < x * star x := by
  simpa using star_mul_self_pos hx.star

end NonUnitalSemiring

section Semiring
variable [Semiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]

instance : ZeroLEOneClass R where
  zero_le_one := by simpa using star_mul_self_nonneg (1 : R)

@[simp]
lemma one_le_star_iff {x : R} : 1 â‰¤ star x â†” 1 â‰¤ x := by
  simpa using star_le_star_iff (x := 1) (y := x)

@[simp]
lemma star_le_one_iff {x : R} : star x â‰¤ 1 â†” x â‰¤ 1 := by
  simpa using star_le_star_iff (x := x) (y := 1)

@[simp]
lemma one_lt_star_iff {x : R} : 1 < star x â†” 1 < x := by
  simpa using star_lt_star_iff (x := 1) (y := x)

@[simp]
lemma star_lt_one_iff {x : R} : star x < 1 â†” x < 1 := by
  simpa using star_lt_star_iff (x := x) (y := 1)

@[aesop safe apply (rule_sets := [CStarAlgebra])]
protected theorem IsSelfAdjoint.sq_nonneg {a : R} (ha : IsSelfAdjoint a) : 0 â‰¤ a ^ 2 := by
  simp [sq, ha.mul_self_nonneg]

end Semiring

namespace MulOpposite

instance [NonUnitalSemiring R] [StarRing R] [PartialOrder R] [StarOrderedRing R] :
    StarOrderedRing Ráµáµ’áµ– where
  le_iff x y := by
    rw [â† unop_le_unop, StarOrderedRing.le_iff, op_surjective.exists,
      â† (AddSubmonoid.closure _).comap_map_eq_of_injective opAddEquiv.injective]
    congr! with p
    Â· simp [AddMonoidHom.map_mclosure, â† range_comp', Function.comp_def,
        â† (star_involutive.surjective.comp op_surjective).range_comp]
    Â· simp [â† op_inj (Î± := R)]

end MulOpposite

section StarModule

variable {A : Type*} [Semiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]
  [NonUnitalRing A] [StarRing A] [PartialOrder A] [StarOrderedRing A] [Module R A]
  [StarModule R A] [NoZeroSMulDivisors R A] [IsScalarTower R A A] [SMulCommClass R A A]

lemma StarModule.smul_lt_smul_of_pos {a b : A} {c : R} (hab : a < b) (hc : 0 < c) :
    c â€¢ a < c â€¢ b := by
  rw [â† sub_pos] at hab âŠ¢
  rw [â† smul_sub]
  refine lt_of_le_of_ne ?le ?ne
  case le =>
    have hab := le_of_lt hab
    rw [StarOrderedRing.nonneg_iff] at hab âŠ¢
    refine AddSubmonoid.closure_induction ?mem ?zero ?add hab
    case mem =>
      intro x hx
      have hc := le_of_lt hc
      rw [StarOrderedRing.nonneg_iff] at hc
      refine AddSubmonoid.closure_induction ?memc ?zeroc ?addc hc
      case memc =>
        intro c' hc'
        obtain âŸ¨z, hzâŸ© := hc'
        obtain âŸ¨y, hyâŸ© := hx
        apply AddSubmonoid.subset_closure
        refine âŸ¨z â€¢ y, ?_âŸ©
        simp only [star_smul, smul_mul_smul_comm, hz, hy]
      case zeroc => simp only [zero_smul, zero_mem]
      case addc => exact fun c' d _ _ â†¦ by simpa only [add_smul] using add_mem
    case zero => simp only [smul_zero, zero_mem]
    case add => exact fun x y _ _ â†¦ by simpa only [smul_add] using add_mem
  case ne =>
    refine (smul_ne_zero ?_ ?_).symm
    Â· exact (ne_of_lt hc).symm
    Â· exact (ne_of_lt hab).symm

instance (priority := 100) StarModule.toOrderedSMul {ğ•œ : Type*} [DivisionSemiring ğ•œ]
    [PartialOrder ğ•œ] [StarRing ğ•œ] [StarOrderedRing ğ•œ] [PosMulReflectLT ğ•œ] [Module ğ•œ A]
    [StarModule ğ•œ A] [NoZeroSMulDivisors ğ•œ A] [IsScalarTower ğ•œ A A] [SMulCommClass ğ•œ A A] :
    OrderedSMul ğ•œ A where
  smul_lt_smul_of_pos := StarModule.smul_lt_smul_of_pos
  lt_of_smul_lt_smul_of_pos {a} {b} {c} hab hc := by
    have hc' : câ»Â¹ * c = 1 := inv_mul_cancelâ‚€ (ne_of_lt hc).symm
    have hmain : câ»Â¹ â€¢ (c â€¢ a) < câ»Â¹ â€¢ (c â€¢ b) := StarModule.smul_lt_smul_of_pos hab
      (inv_pos_of_pos hc)
    simpa [smul_smul, hc'] using hmain

end StarModule

section OrderClass

variable {F R S : Type*} [NonUnitalSemiring R] [PartialOrder R] [StarRing R]
  [StarOrderedRing R]
variable [NonUnitalSemiring S] [PartialOrder S] [StarRing S] [StarOrderedRing S]

-- we prove this auxiliary lemma in order to avoid duplicating the proof twice below.
lemma NonUnitalStarRingHom.map_le_map_of_map_star (f : R â†’â‹†â‚™+* S) {x y : R} (hxy : x â‰¤ y) :
    f x â‰¤ f y := by
  rw [StarOrderedRing.le_iff] at hxy âŠ¢
  obtain âŸ¨p, hp, rflâŸ© := hxy
  refine âŸ¨f p, ?_, map_add f _ _âŸ©
  have hf : âˆ€ r, f (star r) = star (f r) := map_star _
  induction hp using AddSubmonoid.closure_induction
  all_goals aesop

instance (priority := 100) StarRingHomClass.instOrderHomClass [FunLike F R S]
    [NonUnitalSemiring R] [StarRing R] [StarOrderedRing R] [NonUnitalSemiring S]
    [StarRing S] [StarOrderedRing S] [NonUnitalRingHomClass F R S]
    [NonUnitalStarRingHomClass F R S] : OrderHomClass F R S where
  map_rel f := (f : R â†’â‹†â‚™+* S).map_le_map_of_map_star

instance (priority := 100) StarRingEquivClass.instOrderIsoClass [EquivLike F R S]
    [StarRingEquivClass F R S] : OrderIsoClass F R S where
  map_le_map_iff f x y := by
    refine âŸ¨fun h â†¦ ?_, map_rel fâŸ©
    let f_inv : S â†’â‹†â‚™+* R := (f : R â‰ƒâ‹†+* S).symm
    have f_inv_f (r : R) : f_inv (f r) = r := EquivLike.inv_apply_apply f r
    rw [â† f_inv_f x, â† f_inv_f y]
    exact NonUnitalStarRingHom.map_le_map_of_map_star f_inv h

end OrderClass

instance Nat.instStarOrderedRing : StarOrderedRing â„• where
  le_iff a b := by
    have : AddSubmonoid.closure (range fun x : â„• â†¦ x * x) = âŠ¤ :=
      eq_top_mono
        (AddSubmonoid.closure_mono <| singleton_subset_iff.2 <| mem_range.2 âŸ¨1, one_mul _âŸ©)
        Nat.addSubmonoid_closure_one
    simp [this, le_iff_exists_add]

namespace IsStarProjection

section Ring
variable [Ring R] [PartialOrder R] [StarRing R] [StarOrderedRing R] {p : R}

theorem one_sub_nonneg (hp : IsStarProjection p) : 0 â‰¤ 1 - p := hp.one_sub.nonneg

theorem le_one (hp : IsStarProjection p) : p â‰¤ 1 := sub_nonneg.mp hp.one_sub_nonneg

/-- For a star projection `p`, we have `0 â‰¤ p â‰¤ 1`. -/
theorem mem_Icc (hp : IsStarProjection p) : p âˆˆ Set.Icc (0 : R) 1 := by
  simp only [Set.mem_Icc, hp.nonneg, hp.le_one, and_self]

end Ring

section NonUnitalRing
variable [NonUnitalRing R] [PartialOrder R] [StarRing R] [StarOrderedRing R] {p q : R}

/-- A star projection `p` is less than or equal to a star projection `q` when `p * q = p`. -/
theorem le_of_mul_eq_left (hp : IsStarProjection p) (hq : IsStarProjection q)
    (hpq : p * q = p) : p â‰¤ q := sub_nonneg.mp (hp.sub_of_mul_eq_left hq hpq).nonneg

/-- A star projection `p` is less than or equal to a star projection `q` when `q * p = p`. -/
theorem le_of_mul_eq_right (hp : IsStarProjection p) (hq : IsStarProjection q)
    (hpq : q * p = p) : p â‰¤ q := sub_nonneg.mp (hp.sub_of_mul_eq_right hq hpq).nonneg

end NonUnitalRing

end IsStarProjection
