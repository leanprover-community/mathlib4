/-
Copyright (c) 2021 Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Patrick Massot, Anatole Dedecker
-/
import Mathlib.Order.Filter.Bases
import Mathlib.Topology.Algebra.Module.Basic

/-!
# TODO

# Group and ring filter bases

A `GroupFilterBasis` is a `FilterBasis` on a group with some properties relating
the basis to the group structure. The main theorem is that a `GroupFilterBasis`
on a group gives a topology on the group which makes it into a topological group
with neighborhoods of the neutral element generated by the given basis.

## Main definitions and results

Given a group `G` and a ring `R`:

* `GroupFilterBasis G`: the type of filter bases that will become neighborhood of `1`
  for a topology on `G` compatible with the group structure
* `GroupFilterBasis.topology`: the associated topology
* `GroupFilterBasis.isTopologicalGroup`: the compatibility between the above topology
  and the group structure
* `RingFilterBasis R`: the type of filter bases that will become neighborhood of `0`
  for a topology on `R` compatible with the ring structure
* `RingFilterBasis.topology`: the associated topology
* `RingFilterBasis.isTopologicalRing`: the compatibility between the above topology
  and the ring structure

## References

* [N. Bourbaki, *General Topology*][bourbaki1966]
-/


open Filter Set TopologicalSpace Function

open Topology Filter Pointwise

universe u

namespace Filter

/-!
## Filter bases for group topologies
-/

/-- A `GroupFilterBasis` on a group is a `FilterBasis` satisfying some additional axioms.
  Example : if `G` is a topological group then the neighbourhoods of the identity are a
  `GroupFilterBasis`. Conversely given a `GroupFilterBasis` one can define a topology
  compatible with the group structure on `G`. -/
class IsGroupBasis {G : Type*} {Î¹ : Sort*} [Group G] (p : Î¹ â†’ Prop) (s : Î¹ â†’ Set G)
    extends IsBasis p s : Prop where
  one' : âˆ€ {i}, p i â†’ (1 : G) âˆˆ s i
  mul' : âˆ€ {i}, p i â†’ âˆƒ j, p j âˆ§ s j * s j âŠ† s i
  inv' : âˆ€ {i}, p i â†’ âˆƒ j, p j âˆ§ s j âŠ† (s i)â»Â¹
  conj' : âˆ€ xâ‚€, âˆ€ {i}, p i â†’ âˆƒ j, p j âˆ§ MapsTo (xâ‚€ * Â· * xâ‚€â»Â¹) (s j) (s i)

/-- An `AddGroupFilterBasis` on an additive group is a `FilterBasis` satisfying some additional
  axioms. Example : if `G` is a topological group then the neighbourhoods of the identity are an
  `AddGroupFilterBasis`. Conversely given an `AddGroupFilterBasis` one can define a topology
  compatible with the group structure on `G`. -/
class IsAddGroupBasis {G : Type*} {Î¹ : Sort*} [AddGroup G] (p : Î¹ â†’ Prop) (s : Î¹ â†’ Set G)
    extends IsBasis p s : Prop where
  zero' : âˆ€ {i}, p i â†’ (0 : G) âˆˆ s i
  add' : âˆ€ {i}, p i â†’ âˆƒ j, p j âˆ§ s j + s j âŠ† s i
  neg' : âˆ€ {i}, p i â†’ âˆƒ j, p j âˆ§ s j âŠ† -(s i)
  conj' : âˆ€ xâ‚€, âˆ€ {i}, p i â†’ âˆƒ j, p j âˆ§ MapsTo (xâ‚€ + Â· + -xâ‚€) (s j) (s i)

attribute [to_additive existing] IsGroupBasis IsGroupBasis.conj'
  IsGroupBasis.toIsBasis

/-- `GroupFilterBasis` constructor in the commutative group case. -/
@[to_additive "`AddGroupFilterBasis` constructor in the additive commutative group case."]
theorem IsGroupBasis.mk_of_comm {G : Type*} {Î¹ : Sort*} [CommGroup G] (p : Î¹ â†’ Prop) (s : Î¹ â†’ Set G)
    (toIsBasis : IsBasis p s) (one : âˆ€ {i}, p i â†’ (1 : G) âˆˆ s i)
    (mul : âˆ€ {i}, p i â†’ âˆƒ j, p j âˆ§ s j * s j âŠ† s i)
    (inv : âˆ€ {i}, p i â†’ âˆƒ j, p j âˆ§ s j âŠ† (s i)â»Â¹) :
    IsGroupBasis p s where
  toIsBasis := toIsBasis
  one' := one
  mul' := mul
  inv' := inv
  conj' x U U_in := âŸ¨U, U_in, by simpa only [mul_inv_cancel_comm, preimage_id'] using mapsTo_id _âŸ©

namespace IsGroupBasis

variable {G : Type*} {Î¹ : Sort*} [Group G] {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set G} (hB : IsGroupBasis p s)
include hB

@[to_additive]
theorem one {i} : p i â†’ (1 : G) âˆˆ s i := hB.one'

@[to_additive]
theorem mul {i} : p i â†’ âˆƒ j, p j âˆ§ s j * s j âŠ† s i := hB.mul'

@[to_additive]
theorem inv {i} : p i â†’ âˆƒ j, p j âˆ§ s j âŠ† (s i)â»Â¹ := hB.inv'

@[to_additive]
theorem conj : âˆ€ xâ‚€, âˆ€ {i}, p i â†’ âˆƒ j, p j âˆ§ MapsTo (xâ‚€ * Â· * xâ‚€â»Â¹) (s j) (s i) :=
  hB.conj'

@[to_additive]
theorem subset_mul_self {i} (h : p i) : s i âŠ† s i * s i :=
  fun x x_in â†¦ âŸ¨1, hB.one h, x, x_in, one_mul xâŸ©

/-!
### Proving `TopologicalGroup` from `Filter.IsGroupBasis`
-/

@[to_additive]
lemma topologicalGroup [TopologicalSpace G] [ContinuousConstSMul G G] (hB' : (ð“ 1).HasBasis p s) :
    TopologicalGroup G := by
  refine TopologicalGroup.of_nhds_one ?_ ?_ ?_ ?_
  Â· refine hB'.prod_self.tendsto_iff hB' |>.mpr fun i hi â†¦ (hB.mul hi).imp
      fun j âŸ¨hj, hjiâŸ© â†¦ âŸ¨hj, ?_âŸ©
    simpa [â† image2_mul, forall_mem_comm] using hji
  Â· exact hB'.tendsto_iff hB' |>.mpr fun i hi â†¦ (hB.inv hi).imp fun j â†¦ id
  Â· intro xâ‚€
    simp_rw [â† smul_eq_mul, â† Homeomorph.smul_apply xâ‚€, (Homeomorph.smul xâ‚€).map_nhds_eq,
      Homeomorph.smul_apply xâ‚€, smul_eq_mul, mul_one]
  Â· exact fun xâ‚€ â†¦ hB'.tendsto_iff hB' |>.mpr fun i hi â†¦ (hB.conj xâ‚€ hi).imp fun j â†¦ id

/-!
### Constructing a group topology from `Filter.IsGroupBasis`
-/

/-- The neighborhood function of a `GroupFilterBasis`. -/
@[to_additive "The neighborhood function of an `AddGroupFilterBasis`."]
def N : G â†’ Filter G := fun x â†¦ x â€¢ hB.filter

@[to_additive (attr := simp)]
theorem N_one : hB.N 1 = hB.filter := by
  simp only [N, one_smul]

@[to_additive]
theorem hasBasis_N (x : G) :
    HasBasis (hB.N x) p (fun i â†¦ x â€¢ (s i)) :=
  hB.hasBasis.map (fun y â†¦ x * y)

/-- The topological space structure coming from a group filter basis. -/
@[to_additive "The topological space structure coming from an additive group filter basis."]
def topology : TopologicalSpace G :=
  TopologicalSpace.mkOfNhds hB.N

@[to_additive]
theorem nhds_eq {xâ‚€ : G} : @nhds G hB.topology xâ‚€ = hB.N xâ‚€ := by
  apply TopologicalSpace.nhds_mkOfNhds_of_hasBasis hB.hasBasis_N
  Â· intro a i hi
    exact âŸ¨1, hB.one hi, mul_one aâŸ©
  Â· intro a i hi
    rcases hB.mul hi with âŸ¨j, hj, hjiâŸ©
    filter_upwards [hB.hasBasis_N a |>.mem_of_mem hj]
    rintro _ âŸ¨x, hx, rflâŸ©
    calc
      (a * x) â€¢ (s j) âˆˆ hB.N (a * x) := hB.hasBasis_N _ |>.mem_of_mem hj
      _ = a â€¢ x â€¢ (s j) := smul_smul .. |>.symm
      _ âŠ† a â€¢ (s j * s j) := smul_set_mono <| smul_set_subset_smul hx
      _ âŠ† a â€¢ (s i) := smul_set_mono hji

@[to_additive]
theorem nhds_one_eq :
    @nhds G hB.topology (1 : G) = hB.filter := by
  rw [hB.nhds_eq, hB.N_one]

@[to_additive]
theorem nhds_hasBasis (xâ‚€ : G) :
    HasBasis (@nhds G hB.topology xâ‚€) p (fun i â†¦ xâ‚€ â€¢ (s i)) := by
  rw [hB.nhds_eq]
  apply hB.hasBasis_N

@[to_additive]
theorem nhds_one_hasBasis :
    HasBasis (@nhds G hB.topology 1) p s := by
  rw [hB.nhds_one_eq]
  exact hB.hasBasis

@[to_additive]
theorem mem_nhds_one {i} (hi : p i) :
    s i âˆˆ @nhds G hB.topology 1 :=
  hB.nhds_one_hasBasis.mem_of_mem hi

-- See note [lower instance priority]
/-- If a group is endowed with a topological structure coming from a group filter basis then it's a
topological group. -/
@[to_additive "If a group is endowed with a topological structure coming from a group filter basis
then it's a topological group."]
instance (priority := 100) instContinuousConstSMul :
    @ContinuousConstSMul G G hB.topology _ := by
  letI := hB.topology
  refine âŸ¨?_âŸ©
  simp_rw [continuous_iff_continuousAt, ContinuousAt, Tendsto, nhds_eq, N, â† Filter.map_smul,
    smul_eq_mul, map_map, comp_mul_left, le_refl, implies_true]

-- See note [lower instance priority]
/-- If a group is endowed with a topological structure coming from a group filter basis then it's a
topological group. -/
@[to_additive "If a group is endowed with a topological structure coming from a group filter basis
then it's a topological group."]
instance (priority := 100) instTopologicalGroup :
    @TopologicalGroup G hB.topology _ := by
  letI := hB.topology
  exact hB.topologicalGroup hB.nhds_one_hasBasis

end IsGroupBasis

/-!
## Filter bases for ring topologies
-/

/-- A `RingFilterBasis` on a ring is a `FilterBasis` satisfying some additional axioms.
  Example : if `R` is a topological ring then the neighbourhoods of the identity are a
  `RingFilterBasis`. Conversely given a `RingFilterBasis` on a ring `R`, one can define a
  topology on `R` which is compatible with the ring structure. -/
class IsRingBasis {R : Type*} {Î¹ : Sort*} [Ring R] (p : Î¹ â†’ Prop) (s : Î¹ â†’ Set R)
    extends IsAddGroupBasis p s : Prop where
  mul' : âˆ€ {i}, p i â†’ âˆƒ j, p j âˆ§ s j * s j âŠ† s i
  mul_left' : âˆ€ (xâ‚€ : R) {i}, p i â†’ âˆƒ j, p j âˆ§ MapsTo (xâ‚€ * Â·) (s j) (s i)
  mul_right' : âˆ€ (xâ‚€ : R) {i}, p i â†’ âˆƒ j, p j âˆ§ MapsTo (Â· * xâ‚€) (s j) (s i)

namespace IsRingBasis

variable {R : Type*} {Î¹ : Sort*} [Ring R] {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set R} (hB : IsRingBasis p s)
include hB

theorem mul {i} (hi : p i) : âˆƒ j, p j âˆ§ s j * s j âŠ† s i :=
  hB.mul' hi

theorem mul_left (xâ‚€ : R) {i} (hi : p i) : âˆƒ j, p j âˆ§ MapsTo (xâ‚€ * Â·) (s j) (s i) :=
  hB.mul_left' xâ‚€ hi

theorem mul_right (xâ‚€ : R) {i} (hi : p i) : âˆƒ j, p j âˆ§ MapsTo (Â· * xâ‚€) (s j) (s i) :=
  hB.mul_right' xâ‚€ hi

/-!
### Proving `TopologicalRing` from `Filter.IsRingBasis`
-/

lemma topologicalRing [TopologicalSpace R] [ContinuousConstVAdd R R] (hB' : (ð“ 0).HasBasis p s) :
    TopologicalRing R := by
  haveI := hB.topologicalAddGroup hB'
  refine TopologicalRing.of_addGroup_of_nhds_zero ?_ ?_ ?_
  Â· refine hB'.prod_self.tendsto_iff hB' |>.mpr fun i hi â†¦ (hB.mul hi).imp
      fun j âŸ¨hj, hjiâŸ© â†¦ âŸ¨hj, ?_âŸ©
    simpa [â† image2_mul, forall_mem_comm] using hji
  Â· exact fun xâ‚€ â†¦ hB'.tendsto_iff hB' |>.mpr fun i hi â†¦ (hB.mul_left xâ‚€ hi).imp fun j â†¦ id
  Â· exact fun xâ‚€ â†¦ hB'.tendsto_iff hB' |>.mpr fun i hi â†¦ (hB.mul_right xâ‚€ hi).imp fun j â†¦ id

/-!
### Constructing a ring topology from `Filter.IsRingBasis`
-/

/-- The topology associated to a ring filter basis.
It has the given basis as a basis of neighborhoods of zero. -/
nonrec abbrev topology : TopologicalSpace R := hB.topology

/-- If a ring is endowed with a topological structure coming from
a ring filter basis then it's a topological ring. -/
instance (priority := 100) instTopologicalRing :
    @TopologicalRing R hB.topology _ := by
  letI := hB.topology
  haveI := hB.instContinuousConstVAdd
  exact hB.topologicalRing hB.nhds_zero_hasBasis

end IsRingBasis

/-!
## Filter bases for module topologies
-/

/-- A `ModuleFilterBasis` on a module is a `FilterBasis` satisfying some additional axioms.
  Example : if `M` is a topological module then the neighbourhoods of zero are a
  `ModuleFilterBasis`. Conversely given a `ModuleFilterBasis` one can define a topology
  compatible with the module structure on `M`. -/
structure IsModuleBasis (R : Type*) {M : Type*} {Î¹ : Sort*} [Ring R] [TopologicalSpace R]
    [AddCommGroup M] [Module R M] (p : Î¹ â†’ Prop) (s : Î¹ â†’ Set M)
    extends IsAddGroupBasis p s : Prop where
  smul' : âˆ€ {i}, p i â†’ âˆƒ V âˆˆ ð“ (0 : R), âˆƒ j, p j âˆ§ V â€¢ (s j) âŠ† s i
  smul_left' : âˆ€ (xâ‚€ : R) {i}, p i â†’ âˆƒ j, p j âˆ§ MapsTo (xâ‚€ â€¢ Â·) (s j) (s i)
  smul_right' : âˆ€ (mâ‚€ : M) {i}, p i â†’ âˆ€á¶  x in ð“ (0 : R), x â€¢ mâ‚€ âˆˆ s i

theorem IsModuleBasis.mk_of_hasBasis {R M : Type*} {Î¹R Î¹M : Sort*} [Ring R] [TopologicalSpace R]
    [AddCommGroup M] [Module R M] {pR : Î¹R â†’ Prop} {sR : Î¹R â†’ Set R} (hR : (ð“ 0).HasBasis pR sR)
    (pM : Î¹M â†’ Prop) (sM : Î¹M â†’ Set M) (toIsAddGroupBasis : IsAddGroupBasis pM sM)
    (smul : âˆ€ {i}, pM i â†’ âˆƒ j, pR j âˆ§ âˆƒ k, pM k âˆ§ (sR j) â€¢ (sM k) âŠ† sM i)
    (smul_left : âˆ€ (xâ‚€ : R) {i}, pM i â†’ âˆƒ j, pM j âˆ§ MapsTo (xâ‚€ â€¢ Â·) (sM j) (sM i))
    (smul_right : âˆ€ (mâ‚€ : M) {i}, pM i â†’ âˆƒ j, pR j âˆ§ MapsTo (Â· â€¢ mâ‚€) (sR j) (sM i)) :
    IsModuleBasis R pM sM where
  toIsAddGroupBasis := toIsAddGroupBasis
  smul' hi := smul hi |>.imp' sR fun _ â†¦ And.imp_left <| hR.mem_of_mem
  smul_left' := smul_left
  smul_right' mâ‚€ _ hi := hR.eventually_iff.mpr <| smul_right mâ‚€ hi

namespace IsModuleBasis

variable {R M : Type*} {Î¹ : Sort*} [Ring R] [TopologicalSpace R]
    [AddCommGroup M] [Module R M] {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set M} (hB : IsModuleBasis R p s)
include hB

theorem smul {i} (hi : p i) : âˆƒ V âˆˆ ð“ (0 : R), âˆƒ j, p j âˆ§ V â€¢ (s j) âŠ† s i :=
  hB.smul' hi

theorem smul_left (xâ‚€ : R) {i} (hi : p i) : âˆƒ j, p j âˆ§ MapsTo (xâ‚€ â€¢ Â·) (s j) (s i) :=
  hB.smul_left' xâ‚€ hi

theorem smul_right (mâ‚€ : M) {i} (hi : p i) : âˆ€á¶  x in ð“ (0 : R), x â€¢ mâ‚€ âˆˆ s i :=
  hB.smul_right' mâ‚€ hi

/- TODO
/-- If `R` is discrete then the trivial additive group filter basis on any `R`-module is a
module filter basis. -/
instance [DiscreteTopology R] : Inhabited (ModuleFilterBasis R M) :=
  âŸ¨{
      show AddGroupFilterBasis M from
        default with
      smul' := by
        rintro U (rfl : U âˆˆ {{(0 : M)}})
        use univ, univ_mem, {0}, rfl
        rintro a âŸ¨x, -, m, rfl, rflâŸ©
        simp only [smul_zero, mem_singleton_iff]
      smul_left' := by
        rintro xâ‚€ U (h : U âˆˆ {{(0 : M)}})
        rw [mem_singleton_iff] at h
        use {0}, rfl
        simp [h]
      smul_right' := by
        rintro mâ‚€ U (h : U âˆˆ (0 : Set (Set M)))
        rw [Set.mem_zero] at h
        simp [h, nhds_discrete] }âŸ©
-/

/-!
### Proving `ContinuousSMul` from `Filter.IsModuleBasis`
-/

theorem continuousSMul [TopologicalRing R] [TopologicalSpace M] [ContinuousConstVAdd M M]
    (hB' : (ð“ 0).HasBasis p s) : ContinuousSMul R M := by
  haveI := hB.topologicalAddGroup hB'
  refine ContinuousSMul.of_nhds_zero ?_ ?_ ?_
  Â· refine basis_sets _ |>.prod_pprod hB' |>.tendsto_iff hB' |>.mpr fun i hi â†¦
      let âŸ¨V, hV, j, hj, hVjâŸ© := (hB.smul hi); âŸ¨âŸ¨V, jâŸ©, âŸ¨hV, hjâŸ©, ?_âŸ©
    simpa [forall_swap (Î± := M), â† image2_smul] using hVj
  Â· exact fun mâ‚€ â†¦ hB'.tendsto_right_iff.mpr fun i hi â†¦ hB.smul_right mâ‚€ hi
  Â· exact fun xâ‚€ â†¦ hB'.tendsto_iff hB' |>.mpr fun i hi â†¦ (hB.smul_left xâ‚€ hi).imp fun j â†¦ id

/-!
### Constructing a module topology from `Filter.IsModuleBasis`
-/

/-- The topology associated to a module filter basis on a module over a topological ring.
It has the given basis as a basis of neighborhoods of zero. -/
nonrec abbrev topology : TopologicalSpace M := hB.topology

/-- The topology associated to a module filter basis on a module over a topological ring.
It has the given basis as a basis of neighborhoods of zero. This version gets the ring
topology by unification instead of type class inference. -/
abbrev topology' {R M : Type*} {Î¹ : Sort*} [CommRing R] {_ : TopologicalSpace R}
    [AddCommGroup M] [Module R M] {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set M} (hB : IsModuleBasis R p s) :
    TopologicalSpace M :=
  hB.topology

/-- If a module is endowed with a topological structure coming from
a module filter basis then it's a topological module. -/
instance (priority := 100) instContinuousSMul [TopologicalRing R] :
    @ContinuousSMul R M _ _ hB.topology := by
  letI := hB.topology
  haveI := hB.instContinuousConstVAdd
  exact hB.continuousSMul hB.nhds_zero_hasBasis

end IsModuleBasis

end Filter
