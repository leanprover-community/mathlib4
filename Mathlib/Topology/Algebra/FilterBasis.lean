/-
Copyright (c) 2021 Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Patrick Massot
-/
import Mathlib.Order.Filter.Bases
import Mathlib.Topology.Algebra.Module.Basic

#align_import topology.algebra.filter_basis from "leanprover-community/mathlib"@"f2ce6086713c78a7f880485f7917ea547a215982"

/-!
# Group and ring filter bases

A `GroupFilterBasis` is a `FilterBasis` on a group with some properties relating
the basis to the group structure. The main theorem is that a `GroupFilterBasis`
on a group gives a topology on the group which makes it into a topological group
with neighborhoods of the neutral element generated by the given basis.

## Main definitions and results

Given a group `G` and a ring `R`:

* `GroupFilterBasis G`: the type of filter bases that will become neighborhood of `1`
  for a topology on `G` compatible with the group structure
* `GroupFilterBasis.topology`: the associated topology
* `GroupFilterBasis.isTopologicalGroup`: the compatibility between the above topology
  and the group structure
* `RingFilterBasis R`: the type of filter bases that will become neighborhood of `0`
  for a topology on `R` compatible with the ring structure
* `RingFilterBasis.topology`: the associated topology
* `RingFilterBasis.isTopologicalRing`: the compatibility between the above topology
  and the ring structure

## References

* [N. Bourbaki, *General Topology*][bourbaki1966]
-/


open Filter Set TopologicalSpace Function

open Topology Filter Pointwise

universe u

/-- A `GroupFilterBasis` on a group is a `FilterBasis` satisfying some additional axioms.
  Example : if `G` is a topological group then the neighbourhoods of the identity are a
  `GroupFilterBasis`. Conversely given a `GroupFilterBasis` one can define a topology
  compatible with the group structure on `G`. -/
class GroupFilterBasis (G : Type u) [Group G] extends FilterBasis G where
  one' : âˆ€ {U}, U âˆˆ sets â†’ (1 : G) âˆˆ U
  mul' : âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V * V âŠ† U
  inv' : âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V âŠ† (fun x â†¦ xâ»Â¹) â»Â¹' U
  conj' : âˆ€ xâ‚€, âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V âŠ† (fun x â†¦ xâ‚€ * x * xâ‚€â»Â¹) â»Â¹' U
#align group_filter_basis GroupFilterBasis

/-- An `AddGroupFilterBasis` on an additive group is a `FilterBasis` satisfying some additional
  axioms. Example : if `G` is a topological group then the neighbourhoods of the identity are an
  `AddGroupFilterBasis`. Conversely given an `AddGroupFilterBasis` one can define a topology
  compatible with the group structure on `G`. -/
class AddGroupFilterBasis (A : Type u) [AddGroup A] extends FilterBasis A where
  zero' : âˆ€ {U}, U âˆˆ sets â†’ (0 : A) âˆˆ U
  add' : âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V + V âŠ† U
  neg' : âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V âŠ† (fun x â†¦ -x) â»Â¹' U
  conj' : âˆ€ xâ‚€, âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V âŠ† (fun x â†¦ xâ‚€ + x + -xâ‚€) â»Â¹' U
#align add_group_filter_basis AddGroupFilterBasis

attribute [to_additive existing] GroupFilterBasis GroupFilterBasis.conj'
  GroupFilterBasis.toFilterBasis

/-- `GroupFilterBasis` constructor in the commutative group case. -/
@[to_additive "`AddGroupFilterBasis` constructor in the additive commutative group case."]
def groupFilterBasisOfComm {G : Type*} [CommGroup G] (sets : Set (Set G))
    (nonempty : sets.Nonempty) (inter_sets : âˆ€ x y, x âˆˆ sets â†’ y âˆˆ sets â†’ âˆƒ z âˆˆ sets, z âŠ† x âˆ© y)
    (one : âˆ€ U âˆˆ sets, (1 : G) âˆˆ U) (mul : âˆ€ U âˆˆ sets, âˆƒ V âˆˆ sets, V * V âŠ† U)
    (inv : âˆ€ U âˆˆ sets, âˆƒ V âˆˆ sets, V âŠ† (fun x â†¦ xâ»Â¹) â»Â¹' U) : GroupFilterBasis G :=
  { sets := sets
    nonempty := nonempty
    inter_sets := inter_sets _ _
    one' := one _
    mul' := mul _
    inv' := inv _
    conj' := fun x U U_in â†¦ âŸ¨U, U_in, by simp only [mul_inv_cancel_comm, preimage_id']; rflâŸ© }
                                         -- âŠ¢ U âŠ† U
                                                                                        -- ğŸ‰ no goals
#align group_filter_basis_of_comm groupFilterBasisOfComm
#align add_group_filter_basis_of_comm addGroupFilterBasisOfComm

namespace GroupFilterBasis

variable {G : Type u} [Group G] {B : GroupFilterBasis G}

@[to_additive]
instance : Membership (Set G) (GroupFilterBasis G) :=
  âŸ¨fun s f â†¦ s âˆˆ f.setsâŸ©

@[to_additive]
theorem one {U : Set G} : U âˆˆ B â†’ (1 : G) âˆˆ U :=
  GroupFilterBasis.one'
#align group_filter_basis.one GroupFilterBasis.one
#align add_group_filter_basis.zero AddGroupFilterBasis.zero

@[to_additive]
theorem mul {U : Set G} : U âˆˆ B â†’ âˆƒ V âˆˆ B, V * V âŠ† U :=
  GroupFilterBasis.mul'
#align group_filter_basis.mul GroupFilterBasis.mul
#align add_group_filter_basis.add AddGroupFilterBasis.add

@[to_additive]
theorem inv {U : Set G} : U âˆˆ B â†’ âˆƒ V âˆˆ B, V âŠ† (fun x â†¦ xâ»Â¹) â»Â¹' U :=
  GroupFilterBasis.inv'
#align group_filter_basis.inv GroupFilterBasis.inv
#align add_group_filter_basis.neg AddGroupFilterBasis.neg

@[to_additive]
theorem conj : âˆ€ xâ‚€, âˆ€ {U}, U âˆˆ B â†’ âˆƒ V âˆˆ B, V âŠ† (fun x â†¦ xâ‚€ * x * xâ‚€â»Â¹) â»Â¹' U :=
  GroupFilterBasis.conj'
#align group_filter_basis.conj GroupFilterBasis.conj
#align add_group_filter_basis.conj AddGroupFilterBasis.conj

/-- The trivial group filter basis consists of `{1}` only. The associated topology
is discrete. -/
@[to_additive "The trivial additive group filter basis consists of `{0}` only. The associated
topology is discrete."]
instance : Inhabited (GroupFilterBasis G) := âŸ¨by
  refine'
    { sets := {{1}}
      nonempty := singleton_nonempty _.. }
  all_goals simp only [exists_prop, mem_singleton_iff]
  Â· rintro - - rfl rfl
    -- âŠ¢ âˆƒ z, z = {1} âˆ§ z âŠ† {1} âˆ© {1}
    use {1}
    -- âŠ¢ {1} = {1} âˆ§ {1} âŠ† {1} âˆ© {1}
    simp
    -- ğŸ‰ no goals
  Â· simp
    -- ğŸ‰ no goals
  Â· rintro - rfl
    -- âŠ¢ âˆƒ V, V = {1} âˆ§ V * V âŠ† {1}
    use {1}
    -- âŠ¢ {1} = {1} âˆ§ {1} * {1} âŠ† {1}
    simp
    -- ğŸ‰ no goals
  Â· rintro - rfl
    -- âŠ¢ âˆƒ V, V = {1} âˆ§ V âŠ† (fun x => xâ»Â¹) â»Â¹' {1}
    use {1}
    -- âŠ¢ {1} = {1} âˆ§ {1} âŠ† (fun x => xâ»Â¹) â»Â¹' {1}
    simp
    -- ğŸ‰ no goals
  Â· rintro xâ‚€ - rfl
    -- âŠ¢ âˆƒ V, V = {1} âˆ§ V âŠ† (fun x => xâ‚€ * x * xâ‚€â»Â¹) â»Â¹' {1}
    use {1}
    -- âŠ¢ {1} = {1} âˆ§ {1} âŠ† (fun x => xâ‚€ * x * xâ‚€â»Â¹) â»Â¹' {1}
    simpâŸ©
    -- ğŸ‰ no goals

@[to_additive]
theorem prod_subset_self (B : GroupFilterBasis G) {U : Set G} (h : U âˆˆ B) : U âŠ† U * U :=
  fun x x_in â†¦ âŸ¨1, x, one h, x_in, one_mul xâŸ©
#align group_filter_basis.prod_subset_self GroupFilterBasis.prod_subset_self
#align add_group_filter_basis.sum_subset_self AddGroupFilterBasis.sum_subset_self

/-- The neighborhood function of a `GroupFilterBasis`. -/
@[to_additive "The neighborhood function of an `AddGroupFilterBasis`."]
def N (B : GroupFilterBasis G) : G â†’ Filter G :=
  fun x â†¦ map (fun y â†¦ x * y) B.toFilterBasis.filter
set_option linter.uppercaseLean3 false in
#align group_filter_basis.N GroupFilterBasis.N
set_option linter.uppercaseLean3 false in
#align add_group_filter_basis.N AddGroupFilterBasis.N

@[to_additive (attr := simp)]
theorem N_one (B : GroupFilterBasis G) : B.N 1 = B.toFilterBasis.filter := by
  simp only [N, one_mul, map_id']
  -- ğŸ‰ no goals
set_option linter.uppercaseLean3 false in
#align group_filter_basis.N_one GroupFilterBasis.N_one
set_option linter.uppercaseLean3 false in
#align add_group_filter_basis.N_zero AddGroupFilterBasis.N_zero

@[to_additive]
protected theorem hasBasis (B : GroupFilterBasis G) (x : G) :
    HasBasis (B.N x) (fun V : Set G â†¦ V âˆˆ B) fun V â†¦ (fun y â†¦ x * y) '' V :=
  HasBasis.map (fun y â†¦ x * y) toFilterBasis.hasBasis
#align group_filter_basis.has_basis GroupFilterBasis.hasBasis
#align add_group_filter_basis.has_basis AddGroupFilterBasis.hasBasis

/-- The topological space structure coming from a group filter basis. -/
@[to_additive "The topological space structure coming from an additive group filter basis."]
def topology (B : GroupFilterBasis G) : TopologicalSpace G :=
  TopologicalSpace.mkOfNhds B.N
#align group_filter_basis.topology GroupFilterBasis.topology
#align add_group_filter_basis.topology AddGroupFilterBasis.topology

@[to_additive]
theorem nhds_eq (B : GroupFilterBasis G) {xâ‚€ : G} : @nhds G B.topology xâ‚€ = B.N xâ‚€ := by
  rw [TopologicalSpace.nhds_mkOfNhds]
  -- âŠ¢ pure â‰¤ N B
  Â· intro x U U_in
    -- âŠ¢ U âˆˆ pure x
    rw [(B.hasBasis x).mem_iff] at U_in
    -- âŠ¢ U âˆˆ pure x
    rcases U_in with âŸ¨V, V_in, HâŸ©
    -- âŠ¢ U âˆˆ pure x
    simpa [mem_pure] using H (mem_image_of_mem _ (GroupFilterBasis.one V_in))
    -- ğŸ‰ no goals
  Â· intro x U U_in
    -- âŠ¢ âˆƒ t, t âˆˆ N B x âˆ§ t âŠ† U âˆ§ âˆ€ (a' : G), a' âˆˆ t â†’ U âˆˆ N B a'
    rw [(B.hasBasis x).mem_iff] at U_in
    -- âŠ¢ âˆƒ t, t âˆˆ N B x âˆ§ t âŠ† U âˆ§ âˆ€ (a' : G), a' âˆˆ t â†’ U âˆˆ N B a'
    rcases U_in with âŸ¨V, V_in, HâŸ©
    -- âŠ¢ âˆƒ t, t âˆˆ N B x âˆ§ t âŠ† U âˆ§ âˆ€ (a' : G), a' âˆˆ t â†’ U âˆˆ N B a'
    rcases GroupFilterBasis.mul V_in with âŸ¨W, W_in, hWâŸ©
    -- âŠ¢ âˆƒ t, t âˆˆ N B x âˆ§ t âŠ† U âˆ§ âˆ€ (a' : G), a' âˆˆ t â†’ U âˆˆ N B a'
    use (fun y â†¦ x * y) '' W, image_mem_map (FilterBasis.mem_filter_of_mem _ W_in)
    -- âŠ¢ (fun y => x * y) '' W âŠ† U âˆ§ âˆ€ (a' : G), a' âˆˆ (fun y => x * y) '' W â†’ U âˆˆ N B â€¦
    constructor
    -- âŠ¢ (fun y => x * y) '' W âŠ† U
    Â· rw [image_subset_iff] at H âŠ¢
      -- âŠ¢ W âŠ† (fun y => x * y) â»Â¹' U
      exact ((B.prod_subset_self W_in).trans hW).trans H
      -- ğŸ‰ no goals
    Â· rintro y âŸ¨t, tW, rflâŸ©
      -- âŠ¢ U âˆˆ N B ((fun y => x * y) t)
      rw [(B.hasBasis _).mem_iff]
      -- âŠ¢ âˆƒ i, i âˆˆ B âˆ§ (fun y => (fun y => x * y) t * y) '' i âŠ† U
      use W, W_in
      -- âŠ¢ (fun y => (fun y => x * y) t * y) '' W âŠ† U
      apply Subset.trans _ H
      -- âŠ¢ (fun y => (fun y => x * y) t * y) '' W âŠ† (fun y => x * y) '' V
      clear H
      -- âŠ¢ (fun y => (fun y => x * y) t * y) '' W âŠ† (fun y => x * y) '' V
      rintro z âŸ¨w, wW, rflâŸ©
      -- âŠ¢ (fun y => (fun y => x * y) t * y) w âˆˆ (fun y => x * y) '' V
      exact âŸ¨t * w, hW (mul_mem_mul tW wW), by simp [mul_assoc]âŸ©
      -- ğŸ‰ no goals
#align group_filter_basis.nhds_eq GroupFilterBasis.nhds_eq
#align add_group_filter_basis.nhds_eq AddGroupFilterBasis.nhds_eq

@[to_additive]
theorem nhds_one_eq (B : GroupFilterBasis G) :
    @nhds G B.topology (1 : G) = B.toFilterBasis.filter := by
  rw [B.nhds_eq]
  -- âŠ¢ N B 1 = FilterBasis.filter toFilterBasis
  simp only [N, one_mul]
  -- âŠ¢ map (fun y => y) (FilterBasis.filter toFilterBasis) = FilterBasis.filter toF â€¦
  exact map_id
  -- ğŸ‰ no goals
#align group_filter_basis.nhds_one_eq GroupFilterBasis.nhds_one_eq
#align add_group_filter_basis.nhds_zero_eq AddGroupFilterBasis.nhds_zero_eq

@[to_additive]
theorem nhds_hasBasis (B : GroupFilterBasis G) (xâ‚€ : G) :
    HasBasis (@nhds G B.topology xâ‚€) (fun V : Set G â†¦ V âˆˆ B) fun V â†¦ (fun y â†¦ xâ‚€ * y) '' V := by
  rw [B.nhds_eq]
  -- âŠ¢ HasBasis (N B xâ‚€) (fun V => V âˆˆ B) fun V => (fun y => xâ‚€ * y) '' V
  apply B.hasBasis
  -- ğŸ‰ no goals
#align group_filter_basis.nhds_has_basis GroupFilterBasis.nhds_hasBasis
#align add_group_filter_basis.nhds_has_basis AddGroupFilterBasis.nhds_hasBasis

@[to_additive]
theorem nhds_one_hasBasis (B : GroupFilterBasis G) :
    HasBasis (@nhds G B.topology 1) (fun V : Set G â†¦ V âˆˆ B) id := by
  rw [B.nhds_one_eq]
  -- âŠ¢ HasBasis (FilterBasis.filter toFilterBasis) (fun V => V âˆˆ B) id
  exact B.toFilterBasis.hasBasis
  -- ğŸ‰ no goals
#align group_filter_basis.nhds_one_has_basis GroupFilterBasis.nhds_one_hasBasis
#align add_group_filter_basis.nhds_zero_has_basis AddGroupFilterBasis.nhds_zero_hasBasis

@[to_additive]
theorem mem_nhds_one (B : GroupFilterBasis G) {U : Set G} (hU : U âˆˆ B) :
    U âˆˆ @nhds G B.topology 1 := by
  rw [B.nhds_one_hasBasis.mem_iff]
  -- âŠ¢ âˆƒ i, i âˆˆ B âˆ§ id i âŠ† U
  exact âŸ¨U, hU, rfl.subsetâŸ©
  -- ğŸ‰ no goals
#align group_filter_basis.mem_nhds_one GroupFilterBasis.mem_nhds_one
#align add_group_filter_basis.mem_nhds_zero AddGroupFilterBasis.mem_nhds_zero

-- See note [lower instance priority]
/-- If a group is endowed with a topological structure coming from a group filter basis then it's a
topological group. -/
@[to_additive "If a group is endowed with a topological structure coming from a group filter basis
then it's a topological group."]
instance (priority := 100) isTopologicalGroup (B : GroupFilterBasis G) :
    @TopologicalGroup G B.topology _ := by
  letI := B.topology
  -- âŠ¢ TopologicalGroup G
  have basis := B.nhds_one_hasBasis
  -- âŠ¢ TopologicalGroup G
  have basis' := basis.prod basis
  -- âŠ¢ TopologicalGroup G
  refine' TopologicalGroup.of_nhds_one _ _ _ _
  Â· rw [basis'.tendsto_iff basis]
    -- âŠ¢ âˆ€ (ib : Set G), ib âˆˆ B â†’ âˆƒ ia, (ia.fst âˆˆ B âˆ§ ia.snd âˆˆ B) âˆ§ âˆ€ (x : G Ã— G), x  â€¦
    suffices âˆ€ U âˆˆ B, âˆƒ V W, (V âˆˆ B âˆ§ W âˆˆ B) âˆ§ âˆ€ a b, a âˆˆ V â†’ b âˆˆ W â†’ a * b âˆˆ U by simpa
    -- âŠ¢ âˆ€ (U : Set G), U âˆˆ B â†’ âˆƒ V W, (V âˆˆ B âˆ§ W âˆˆ B) âˆ§ âˆ€ (a b : G), a âˆˆ V â†’ b âˆˆ W â†’ â€¦
    intro U U_in
    -- âŠ¢ âˆƒ V W, (V âˆˆ B âˆ§ W âˆˆ B) âˆ§ âˆ€ (a b : G), a âˆˆ V â†’ b âˆˆ W â†’ a * b âˆˆ U
    rcases mul U_in with âŸ¨V, V_in, hVâŸ©
    -- âŠ¢ âˆƒ V W, (V âˆˆ B âˆ§ W âˆˆ B) âˆ§ âˆ€ (a b : G), a âˆˆ V â†’ b âˆˆ W â†’ a * b âˆˆ U
    refine' âŸ¨V, V, âŸ¨V_in, V_inâŸ©, _âŸ©
    -- âŠ¢ âˆ€ (a b : G), a âˆˆ V â†’ b âˆˆ V â†’ a * b âˆˆ U
    intro a b a_in b_in
    -- âŠ¢ a * b âˆˆ U
    exact hV âŸ¨a, b, a_in, b_in, rflâŸ©
    -- ğŸ‰ no goals
  Â· rw [basis.tendsto_iff basis]
    -- âŠ¢ âˆ€ (ib : Set G), ib âˆˆ B â†’ âˆƒ ia, ia âˆˆ B âˆ§ âˆ€ (x : G), x âˆˆ id ia â†’ xâ»Â¹ âˆˆ id ib
    intro U U_in
    -- âŠ¢ âˆƒ ia, ia âˆˆ B âˆ§ âˆ€ (x : G), x âˆˆ id ia â†’ xâ»Â¹ âˆˆ id U
    simpa using inv U_in
    -- ğŸ‰ no goals
  Â· intro xâ‚€
    -- âŠ¢ ğ“ xâ‚€ = map (fun x => xâ‚€ * x) (ğ“ 1)
    rw [nhds_eq, nhds_one_eq]
    -- âŠ¢ N B xâ‚€ = map (fun x => xâ‚€ * x) (FilterBasis.filter toFilterBasis)
    rfl
    -- ğŸ‰ no goals
  Â· intro xâ‚€
    -- âŠ¢ Tendsto (fun x => xâ‚€ * x * xâ‚€â»Â¹) (ğ“ 1) (ğ“ 1)
    rw [basis.tendsto_iff basis]
    -- âŠ¢ âˆ€ (ib : Set G), ib âˆˆ B â†’ âˆƒ ia, ia âˆˆ B âˆ§ âˆ€ (x : G), x âˆˆ id ia â†’ xâ‚€ * x * xâ‚€â»Â¹ â€¦
    intro U U_in
    -- âŠ¢ âˆƒ ia, ia âˆˆ B âˆ§ âˆ€ (x : G), x âˆˆ id ia â†’ xâ‚€ * x * xâ‚€â»Â¹ âˆˆ id U
    exact conj xâ‚€ U_in
    -- ğŸ‰ no goals
#align group_filter_basis.is_topological_group GroupFilterBasis.isTopologicalGroup
#align add_group_filter_basis.is_topological_add_group AddGroupFilterBasis.isTopologicalAddGroup

end GroupFilterBasis

/-- A `RingFilterBasis` on a ring is a `FilterBasis` satisfying some additional axioms.
  Example : if `R` is a topological ring then the neighbourhoods of the identity are a
  `RingFilterBasis`. Conversely given a `RingFilterBasis` on a ring `R`, one can define a
  topology on `R` which is compatible with the ring structure. -/
class RingFilterBasis (R : Type u) [Ring R] extends AddGroupFilterBasis R where
  mul' : âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V * V âŠ† U
  mul_left' : âˆ€ (xâ‚€ : R) {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V âŠ† (fun x â†¦ xâ‚€ * x) â»Â¹' U
  mul_right' : âˆ€ (xâ‚€ : R) {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V âŠ† (fun x â†¦ x * xâ‚€) â»Â¹' U
#align ring_filter_basis RingFilterBasis

namespace RingFilterBasis

variable {R : Type u} [Ring R] (B : RingFilterBasis R)

instance : Membership (Set R) (RingFilterBasis R) :=
  âŸ¨fun s B â†¦ s âˆˆ B.setsâŸ©

theorem mul {U : Set R} (hU : U âˆˆ B) : âˆƒ V âˆˆ B, V * V âŠ† U :=
  mul' hU
#align ring_filter_basis.mul RingFilterBasis.mul

theorem mul_left (xâ‚€ : R) {U : Set R} (hU : U âˆˆ B) : âˆƒ V âˆˆ B, V âŠ† (fun x â†¦ xâ‚€ * x) â»Â¹' U :=
  mul_left' xâ‚€ hU
#align ring_filter_basis.mul_left RingFilterBasis.mul_left

theorem mul_right (xâ‚€ : R) {U : Set R} (hU : U âˆˆ B) : âˆƒ V âˆˆ B, V âŠ† (fun x â†¦ x * xâ‚€) â»Â¹' U :=
  mul_right' xâ‚€ hU
#align ring_filter_basis.mul_right RingFilterBasis.mul_right

/-- The topology associated to a ring filter basis.
It has the given basis as a basis of neighborhoods of zero. -/
def topology : TopologicalSpace R :=
  B.toAddGroupFilterBasis.topology
#align ring_filter_basis.topology RingFilterBasis.topology

/-- If a ring is endowed with a topological structure coming from
a ring filter basis then it's a topological ring. -/
instance (priority := 100) isTopologicalRing {R : Type u} [Ring R] (B : RingFilterBasis R) :
    @TopologicalRing R B.topology _ := by
  let B' := B.toAddGroupFilterBasis
  -- âŠ¢ TopologicalRing R
  letI := B'.topology
  -- âŠ¢ TopologicalRing R
  have basis := B'.nhds_zero_hasBasis
  -- âŠ¢ TopologicalRing R
  have basis' := basis.prod basis
  -- âŠ¢ TopologicalRing R
  haveI := B'.isTopologicalAddGroup
  -- âŠ¢ TopologicalRing R
  apply TopologicalRing.of_addGroup_of_nhds_zero
  Â· rw [basis'.tendsto_iff basis]
    -- âŠ¢ âˆ€ (ib : Set R), ib âˆˆ B' â†’ âˆƒ ia, (ia.fst âˆˆ B' âˆ§ ia.snd âˆˆ B') âˆ§ âˆ€ (x : R Ã— R), â€¦
    suffices âˆ€ U âˆˆ B', âˆƒ V W, (V âˆˆ B' âˆ§ W âˆˆ B') âˆ§ âˆ€ a b, a âˆˆ V â†’ b âˆˆ W â†’ a * b âˆˆ U by simpa
    -- âŠ¢ âˆ€ (U : Set R), U âˆˆ B' â†’ âˆƒ V W, (V âˆˆ B' âˆ§ W âˆˆ B') âˆ§ âˆ€ (a b : R), a âˆˆ V â†’ b âˆˆ  â€¦
    intro U U_in
    -- âŠ¢ âˆƒ V W, (V âˆˆ B' âˆ§ W âˆˆ B') âˆ§ âˆ€ (a b : R), a âˆˆ V â†’ b âˆˆ W â†’ a * b âˆˆ U
    rcases B.mul U_in with âŸ¨V, V_in, hVâŸ©
    -- âŠ¢ âˆƒ V W, (V âˆˆ B' âˆ§ W âˆˆ B') âˆ§ âˆ€ (a b : R), a âˆˆ V â†’ b âˆˆ W â†’ a * b âˆˆ U
    refine' âŸ¨V, V, âŸ¨V_in, V_inâŸ©, _âŸ©
    -- âŠ¢ âˆ€ (a b : R), a âˆˆ V â†’ b âˆˆ V â†’ a * b âˆˆ U
    intro a b a_in b_in
    -- âŠ¢ a * b âˆˆ U
    exact hV âŸ¨a, b, a_in, b_in, rflâŸ©
    -- ğŸ‰ no goals
  Â· intro xâ‚€
    -- âŠ¢ Tendsto (fun x => xâ‚€ * x) (ğ“ 0) (ğ“ 0)
    rw [basis.tendsto_iff basis]
    -- âŠ¢ âˆ€ (ib : Set R), ib âˆˆ B' â†’ âˆƒ ia, ia âˆˆ B' âˆ§ âˆ€ (x : R), x âˆˆ id ia â†’ xâ‚€ * x âˆˆ id â€¦
    intro U
    -- âŠ¢ U âˆˆ B' â†’ âˆƒ ia, ia âˆˆ B' âˆ§ âˆ€ (x : R), x âˆˆ id ia â†’ xâ‚€ * x âˆˆ id U
    simpa using B.mul_left xâ‚€
    -- ğŸ‰ no goals
  Â· intro xâ‚€
    -- âŠ¢ Tendsto (fun x => x * xâ‚€) (ğ“ 0) (ğ“ 0)
    rw [basis.tendsto_iff basis]
    -- âŠ¢ âˆ€ (ib : Set R), ib âˆˆ B' â†’ âˆƒ ia, ia âˆˆ B' âˆ§ âˆ€ (x : R), x âˆˆ id ia â†’ x * xâ‚€ âˆˆ id â€¦
    intro U
    -- âŠ¢ U âˆˆ B' â†’ âˆƒ ia, ia âˆˆ B' âˆ§ âˆ€ (x : R), x âˆˆ id ia â†’ x * xâ‚€ âˆˆ id U
    simpa using B.mul_right xâ‚€
    -- ğŸ‰ no goals
#align ring_filter_basis.is_topological_ring RingFilterBasis.isTopologicalRing

end RingFilterBasis

/-- A `ModuleFilterBasis` on a module is a `FilterBasis` satisfying some additional axioms.
  Example : if `M` is a topological module then the neighbourhoods of zero are a
  `ModuleFilterBasis`. Conversely given a `ModuleFilterBasis` one can define a topology
  compatible with the module structure on `M`. -/
structure ModuleFilterBasis (R M : Type*) [CommRing R] [TopologicalSpace R] [AddCommGroup M]
  [Module R M] extends AddGroupFilterBasis M where
  smul' : âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ ğ“ (0 : R), âˆƒ W âˆˆ sets, V â€¢ W âŠ† U
  smul_left' : âˆ€ (xâ‚€ : R) {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V âŠ† (fun x â†¦ xâ‚€ â€¢ x) â»Â¹' U
  smul_right' : âˆ€ (mâ‚€ : M) {U}, U âˆˆ sets â†’ âˆ€á¶  x in ğ“ (0 : R), x â€¢ mâ‚€ âˆˆ U
#align module_filter_basis ModuleFilterBasis

namespace ModuleFilterBasis

variable {R M : Type*} [CommRing R] [TopologicalSpace R] [AddCommGroup M] [Module R M]
  (B : ModuleFilterBasis R M)

instance GroupFilterBasis.hasMem : Membership (Set M) (ModuleFilterBasis R M) :=
  âŸ¨fun s B â†¦ s âˆˆ B.setsâŸ©
#align module_filter_basis.group_filter_basis.has_mem ModuleFilterBasis.GroupFilterBasis.hasMem

theorem smul {U : Set M} (hU : U âˆˆ B) : âˆƒ V âˆˆ ğ“ (0 : R), âˆƒ W âˆˆ B, V â€¢ W âŠ† U :=
  B.smul' hU
#align module_filter_basis.smul ModuleFilterBasis.smul

theorem smul_left (xâ‚€ : R) {U : Set M} (hU : U âˆˆ B) : âˆƒ V âˆˆ B, V âŠ† (fun x â†¦ xâ‚€ â€¢ x) â»Â¹' U :=
  B.smul_left' xâ‚€ hU
#align module_filter_basis.smul_left ModuleFilterBasis.smul_left

theorem smul_right (mâ‚€ : M) {U : Set M} (hU : U âˆˆ B) : âˆ€á¶  x in ğ“ (0 : R), x â€¢ mâ‚€ âˆˆ U :=
  B.smul_right' mâ‚€ hU
#align module_filter_basis.smul_right ModuleFilterBasis.smul_right

/-- If `R` is discrete then the trivial additive group filter basis on any `R`-module is a
module filter basis. -/
instance [DiscreteTopology R] : Inhabited (ModuleFilterBasis R M) :=
  âŸ¨{
      show AddGroupFilterBasis M from
        default with
      smul' := by
        rintro U (rfl : U âˆˆ {{(0 : M)}})
        -- âŠ¢ âˆƒ V, V âˆˆ ğ“ 0 âˆ§ âˆƒ W, W âˆˆ AddGroupFilterBasis.toFilterBasis.sets âˆ§ V â€¢ W âŠ† {0}
        use univ, univ_mem, {0}, rfl
        -- âŠ¢ univ â€¢ {0} âŠ† {0}
        rintro a âŸ¨x, m, -, rfl, rflâŸ©
        -- âŠ¢ (fun x x_1 => x â€¢ x_1) x 0 âˆˆ {0}
        simp only [smul_zero, mem_singleton_iff]
        -- ğŸ‰ no goals
      smul_left' := by
        rintro xâ‚€ U (h : U âˆˆ {{(0 : M)}})
        -- âŠ¢ âˆƒ V, V âˆˆ AddGroupFilterBasis.toFilterBasis.sets âˆ§ V âŠ† (fun x => xâ‚€ â€¢ x) â»Â¹' U
        rw [mem_singleton_iff] at h
        -- âŠ¢ âˆƒ V, V âˆˆ AddGroupFilterBasis.toFilterBasis.sets âˆ§ V âŠ† (fun x => xâ‚€ â€¢ x) â»Â¹' U
        use {0}, rfl
        -- âŠ¢ {0} âŠ† (fun x => xâ‚€ â€¢ x) â»Â¹' U
        simp [h]
        -- ğŸ‰ no goals
      smul_right' := by
        rintro mâ‚€ U (h : U âˆˆ (0 : Set (Set M)))
        -- âŠ¢ âˆ€á¶  (x : R) in ğ“ 0, x â€¢ mâ‚€ âˆˆ U
        rw [Set.mem_zero] at h
        -- âŠ¢ âˆ€á¶  (x : R) in ğ“ 0, x â€¢ mâ‚€ âˆˆ U
        simp [h, nhds_discrete] }âŸ©
        -- ğŸ‰ no goals

/-- The topology associated to a module filter basis on a module over a topological ring.
It has the given basis as a basis of neighborhoods of zero. -/
def topology : TopologicalSpace M :=
  B.toAddGroupFilterBasis.topology
#align module_filter_basis.topology ModuleFilterBasis.topology

/-- The topology associated to a module filter basis on a module over a topological ring.
It has the given basis as a basis of neighborhoods of zero. This version gets the ring
topology by unification instead of type class inference. -/
def topology' {R M : Type*} [CommRing R] {_ : TopologicalSpace R} [AddCommGroup M] [Module R M]
    (B : ModuleFilterBasis R M) : TopologicalSpace M :=
  B.toAddGroupFilterBasis.topology
#align module_filter_basis.topology' ModuleFilterBasis.topology'

/-- A topological add group with a basis of `ğ“ 0` satisfying the axioms of `ModuleFilterBasis`
is a topological module.

This lemma is mathematically useless because one could obtain such a result by applying
`ModuleFilterBasis.continuousSMul` and use the fact that group topologies are characterized
by their neighborhoods of 0 to obtain the `ContinuousSMul` on the pre-existing topology.

But it turns out it's just easier to get it as a byproduct of the proof, so this is just a free
quality-of-life improvement. -/
theorem _root_.ContinuousSMul.of_basis_zero {Î¹ : Type*} [TopologicalRing R] [TopologicalSpace M]
    [TopologicalAddGroup M] {p : Î¹ â†’ Prop} {b : Î¹ â†’ Set M} (h : HasBasis (ğ“ 0) p b)
    (hsmul : âˆ€ {i}, p i â†’ âˆƒ V âˆˆ ğ“ (0 : R), âˆƒ (j : _) (_ : p j), V â€¢ b j âŠ† b i)
    (hsmul_left : âˆ€ (xâ‚€ : R) {i}, p i â†’ âˆƒ (j : _) (_ : p j), b j âŠ† (fun x â†¦ xâ‚€ â€¢ x) â»Â¹' b i)
    (hsmul_right : âˆ€ (mâ‚€ : M) {i}, p i â†’ âˆ€á¶  x in ğ“ (0 : R), x â€¢ mâ‚€ âˆˆ b i) : ContinuousSMul R M := by
  apply ContinuousSMul.of_nhds_zero
  Â· rw [h.tendsto_right_iff]
    -- âŠ¢ âˆ€ (i : Î¹), p i â†’ âˆ€á¶  (x : R Ã— M) in ğ“ 0 Ã—Ë¢ ğ“ 0, x.fst â€¢ x.snd âˆˆ b i
    intro i hi
    -- âŠ¢ âˆ€á¶  (x : R Ã— M) in ğ“ 0 Ã—Ë¢ ğ“ 0, x.fst â€¢ x.snd âˆˆ b i
    rcases hsmul hi with âŸ¨V, V_in, j, hj, hVjâŸ©
    -- âŠ¢ âˆ€á¶  (x : R Ã— M) in ğ“ 0 Ã—Ë¢ ğ“ 0, x.fst â€¢ x.snd âˆˆ b i
    apply mem_of_superset (prod_mem_prod V_in <| h.mem_of_mem hj)
    -- âŠ¢ V Ã—Ë¢ b j âŠ† {x | (fun x => x.fst â€¢ x.snd âˆˆ b i) x}
    rintro âŸ¨v, wâŸ© âŸ¨v_in : v âˆˆ V, w_in : w âˆˆ b jâŸ©
    -- âŠ¢ (v, w) âˆˆ {x | (fun x => x.fst â€¢ x.snd âˆˆ b i) x}
    exact hVj (Set.smul_mem_smul v_in w_in)
    -- ğŸ‰ no goals
  Â· intro mâ‚€
    -- âŠ¢ Tendsto (fun a => a â€¢ mâ‚€) (ğ“ 0) (ğ“ 0)
    rw [h.tendsto_right_iff]
    -- âŠ¢ âˆ€ (i : Î¹), p i â†’ âˆ€á¶  (x : R) in ğ“ 0, x â€¢ mâ‚€ âˆˆ b i
    intro i hi
    -- âŠ¢ âˆ€á¶  (x : R) in ğ“ 0, x â€¢ mâ‚€ âˆˆ b i
    exact hsmul_right mâ‚€ hi
    -- ğŸ‰ no goals
  Â· intro xâ‚€
    -- âŠ¢ Tendsto (fun m => xâ‚€ â€¢ m) (ğ“ 0) (ğ“ 0)
    rw [h.tendsto_right_iff]
    -- âŠ¢ âˆ€ (i : Î¹), p i â†’ âˆ€á¶  (x : M) in ğ“ 0, xâ‚€ â€¢ x âˆˆ b i
    intro i hi
    -- âŠ¢ âˆ€á¶  (x : M) in ğ“ 0, xâ‚€ â€¢ x âˆˆ b i
    rcases hsmul_left xâ‚€ hi with âŸ¨j, hj, hjiâŸ©
    -- âŠ¢ âˆ€á¶  (x : M) in ğ“ 0, xâ‚€ â€¢ x âˆˆ b i
    exact mem_of_superset (h.mem_of_mem hj) hji
    -- ğŸ‰ no goals
#align has_continuous_smul.of_basis_zero ContinuousSMul.of_basis_zero

/-- If a module is endowed with a topological structure coming from
a module filter basis then it's a topological module. -/
instance (priority := 100) continuousSMul [TopologicalRing R] :
    @ContinuousSMul R M _ _ B.topology := by
  let B' := B.toAddGroupFilterBasis
  -- âŠ¢ ContinuousSMul R M
  let _ := B'.topology
  -- âŠ¢ ContinuousSMul R M
  have _ := B'.isTopologicalAddGroup
  -- âŠ¢ ContinuousSMul R M
  exact ContinuousSMul.of_basis_zero B'.nhds_zero_hasBasis
      (fun {_} => by simpa using B.smul)
      (by simpa using B.smul_left) B.smul_right
#align module_filter_basis.has_continuous_smul ModuleFilterBasis.continuousSMul

/-- Build a module filter basis from compatible ring and additive group filter bases. -/
def ofBases {R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] (BR : RingFilterBasis R)
    (BM : AddGroupFilterBasis M) (smul : âˆ€ {U}, U âˆˆ BM â†’ âˆƒ V âˆˆ BR, âˆƒ W âˆˆ BM, V â€¢ W âŠ† U)
    (smul_left : âˆ€ (xâ‚€ : R) {U}, U âˆˆ BM â†’ âˆƒ V âˆˆ BM, V âŠ† (fun x â†¦ xâ‚€ â€¢ x) â»Â¹' U)
    (smul_right : âˆ€ (mâ‚€ : M) {U}, U âˆˆ BM â†’ âˆƒ V âˆˆ BR, V âŠ† (fun x â†¦ x â€¢ mâ‚€) â»Â¹' U) :
    @ModuleFilterBasis R M _ BR.topology _ _ :=
  let _ := BR.topology
  { BM with
    smul' := by
      intro U U_in
      -- âŠ¢ âˆƒ V, V âˆˆ ğ“ 0 âˆ§ âˆƒ W, W âˆˆ AddGroupFilterBasis.toFilterBasis.sets âˆ§ V â€¢ W âŠ† U
      rcases smul U_in with âŸ¨V, V_in, W, W_in, HâŸ©
      -- âŠ¢ âˆƒ V, V âˆˆ ğ“ 0 âˆ§ âˆƒ W, W âˆˆ AddGroupFilterBasis.toFilterBasis.sets âˆ§ V â€¢ W âŠ† U
      exact âŸ¨V, BR.toAddGroupFilterBasis.mem_nhds_zero V_in, W, W_in, HâŸ©
      -- ğŸ‰ no goals
    smul_left' := smul_left
    smul_right' := by
      intro mâ‚€ U U_in
      -- âŠ¢ âˆ€á¶  (x : R) in ğ“ 0, x â€¢ mâ‚€ âˆˆ U
      rcases smul_right mâ‚€ U_in with âŸ¨V, V_in, HâŸ©
      -- âŠ¢ âˆ€á¶  (x : R) in ğ“ 0, x â€¢ mâ‚€ âˆˆ U
      exact mem_of_superset (BR.toAddGroupFilterBasis.mem_nhds_zero V_in) H }
      -- ğŸ‰ no goals
#align module_filter_basis.of_bases ModuleFilterBasis.ofBases

end ModuleFilterBasis
