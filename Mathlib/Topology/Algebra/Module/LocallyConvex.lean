/-
Copyright (c) 2022 Anatole Dedecker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anatole Dedecker
-/
import Mathlib.Analysis.Convex.Topology
import Mathlib.Topology.Connected.LocPathConnected

/-!
# Locally convex topological modules

A `LocallyConvexSpace` is a topological semimodule over an ordered semiring in which any point
admits a neighborhood basis made of convex sets, or equivalently, in which convex neighborhoods of
a point form a neighborhood basis at that point.

In a module, this is equivalent to `0` satisfying such properties.

## Main results

- `locallyConvexSpace_iff_zero` : in a module, local convexity at zero gives
  local convexity everywhere
- `WithSeminorms.locallyConvexSpace` : a topology generated by a family of seminorms is locally
  convex (in `Analysis.LocallyConvex.WithSeminorms`)
- `NormedSpace.locallyConvexSpace` : a normed space is locally convex
  (in `Analysis.LocallyConvex.WithSeminorms`)

## TODO

- define a structure `LocallyConvexFilterBasis`, extending `ModuleFilterBasis`, for filter
  bases generating a locally convex topology

-/

assert_not_exists NormedSpace

open TopologicalSpace Filter Set

open Topology Pointwise

section Semimodule

/-- A `LocallyConvexSpace` is a topological semimodule over an ordered semiring in which convex
neighborhoods of a point form a neighborhood basis at that point. -/
class LocallyConvexSpace (ğ•œ E : Type*) [OrderedSemiring ğ•œ] [AddCommMonoid E] [Module ğ•œ E]
    [TopologicalSpace E] : Prop where
  convex_basis : âˆ€ x : E, (ğ“ x).HasBasis (fun s : Set E => s âˆˆ ğ“ x âˆ§ Convex ğ•œ s) id

variable (ğ•œ E : Type*) [OrderedSemiring ğ•œ] [AddCommMonoid E] [Module ğ•œ E] [TopologicalSpace E]

theorem locallyConvexSpace_iff :
    LocallyConvexSpace ğ•œ E â†” âˆ€ x : E, (ğ“ x).HasBasis (fun s : Set E => s âˆˆ ğ“ x âˆ§ Convex ğ•œ s) id :=
  âŸ¨@LocallyConvexSpace.convex_basis _ _ _ _ _ _, LocallyConvexSpace.mkâŸ©

theorem LocallyConvexSpace.ofBases {Î¹ : Type*} (b : E â†’ Î¹ â†’ Set E) (p : E â†’ Î¹ â†’ Prop)
    (hbasis : âˆ€ x : E, (ğ“ x).HasBasis (p x) (b x)) (hconvex : âˆ€ x i, p x i â†’ Convex ğ•œ (b x i)) :
    LocallyConvexSpace ğ•œ E :=
  âŸ¨fun x =>
    (hbasis x).to_hasBasis
      (fun i hi => âŸ¨b x i, âŸ¨âŸ¨(hbasis x).mem_of_mem hi, hconvex x i hiâŸ©, le_refl (b x i)âŸ©âŸ©)
      fun s hs =>
      âŸ¨(hbasis x).index s hs.1, âŸ¨(hbasis x).property_index hs.1, (hbasis x).set_index_subset hs.1âŸ©âŸ©âŸ©

theorem LocallyConvexSpace.convex_basis_zero [LocallyConvexSpace ğ•œ E] :
    (ğ“ 0 : Filter E).HasBasis (fun s => s âˆˆ (ğ“ 0 : Filter E) âˆ§ Convex ğ•œ s) id :=
  LocallyConvexSpace.convex_basis 0

theorem locallyConvexSpace_iff_exists_convex_subset :
    LocallyConvexSpace ğ•œ E â†” âˆ€ x : E, âˆ€ U âˆˆ ğ“ x, âˆƒ S âˆˆ ğ“ x, Convex ğ•œ S âˆ§ S âŠ† U :=
  (locallyConvexSpace_iff ğ•œ E).trans (forall_congr' fun _ => hasBasis_self)

end Semimodule

section Module

variable (ğ•œ E : Type*) [OrderedSemiring ğ•œ] [AddCommGroup E] [Module ğ•œ E] [TopologicalSpace E]
  [IsTopologicalAddGroup E]

theorem LocallyConvexSpace.ofBasisZero {Î¹ : Type*} (b : Î¹ â†’ Set E) (p : Î¹ â†’ Prop)
    (hbasis : (ğ“ 0).HasBasis p b) (hconvex : âˆ€ i, p i â†’ Convex ğ•œ (b i)) :
    LocallyConvexSpace ğ•œ E := by
  refine LocallyConvexSpace.ofBases ğ•œ E (fun (x : E) (i : Î¹) => (x + Â·) '' b i) (fun _ => p)
    (fun x => ?_) fun x i hi => (hconvex i hi).translate x
  rw [â† map_add_left_nhds_zero]
  exact hbasis.map _

theorem locallyConvexSpace_iff_zero : LocallyConvexSpace ğ•œ E â†”
    (ğ“ 0 : Filter E).HasBasis (fun s : Set E => s âˆˆ (ğ“ 0 : Filter E) âˆ§ Convex ğ•œ s) id :=
  âŸ¨fun h => @LocallyConvexSpace.convex_basis _ _ _ _ _ _ h 0, fun h =>
    LocallyConvexSpace.ofBasisZero ğ•œ E _ _ h fun _ => And.rightâŸ©

theorem locallyConvexSpace_iff_exists_convex_subset_zero :
    LocallyConvexSpace ğ•œ E â†” âˆ€ U âˆˆ (ğ“ 0 : Filter E), âˆƒ S âˆˆ (ğ“ 0 : Filter E), Convex ğ•œ S âˆ§ S âŠ† U :=
  (locallyConvexSpace_iff_zero ğ•œ E).trans hasBasis_self

-- see Note [lower instance priority]
instance (priority := 100) LocallyConvexSpace.toLocPathConnectedSpace [Module â„ E]
    [ContinuousSMul â„ E] [LocallyConvexSpace â„ E] : LocPathConnectedSpace E :=
  .of_bases (fun x â†¦ convex_basis (ğ•œ := â„) x)
    fun _ _ hs â†¦ hs.2.isPathConnected <| nonempty_of_mem <| mem_of_mem_nhds hs.1

/-- Convex subsets of locally convex spaces are locally path-connected. -/
theorem Convex.locPathConnectedSpace [Module â„ E] [ContinuousSMul â„ E] [LocallyConvexSpace â„ E]
    {S : Set E} (hS : Convex â„ S) : LocPathConnectedSpace S := by
  refine âŸ¨fun x â†¦ âŸ¨fun s â†¦ âŸ¨fun hs â†¦ ?_, fun âŸ¨t, htâŸ© â†¦ mem_of_superset ht.1.1 ht.2âŸ©âŸ©âŸ©
  let âŸ¨t, htâŸ© := (mem_nhds_subtype S x s).mp hs
  let âŸ¨t', ht'âŸ© := (LocallyConvexSpace.convex_basis (ğ•œ := â„) x.1).mem_iff.mp ht.1
  refine âŸ¨(â†‘) â»Â¹' t', âŸ¨?_, ?_âŸ©, (preimage_mono ht'.2).trans ht.2âŸ©
  Â· exact continuousAt_subtype_val.preimage_mem_nhds ht'.1.1
  Â· refine Subtype.preimage_coe_self_inter _ _ â–¸ IsPathConnected.preimage_coe ?_ inter_subset_left
    exact (hS.inter ht'.1.2).isPathConnected âŸ¨x, x.2, mem_of_mem_nhds ht'.1.1âŸ©

end Module

section LinearOrderedField

variable (ğ•œ E : Type*) [LinearOrderedField ğ•œ] [AddCommGroup E] [Module ğ•œ E] [TopologicalSpace E]
  [IsTopologicalAddGroup E] [ContinuousConstSMul ğ•œ E]

theorem LocallyConvexSpace.convex_open_basis_zero [LocallyConvexSpace ğ•œ E] :
    (ğ“ 0 : Filter E).HasBasis (fun s => (0 : E) âˆˆ s âˆ§ IsOpen s âˆ§ Convex ğ•œ s) id :=
  (LocallyConvexSpace.convex_basis_zero ğ•œ E).to_hasBasis
    (fun s hs =>
      âŸ¨interior s, âŸ¨mem_interior_iff_mem_nhds.mpr hs.1, isOpen_interior, hs.2.interiorâŸ©,
        interior_subsetâŸ©)
    fun s hs => âŸ¨s, âŸ¨hs.2.1.mem_nhds hs.1, hs.2.2âŸ©, subset_rflâŸ©

variable {ğ•œ E}

/-- In a locally convex space, if `s`, `t` are disjoint convex sets, `s` is compact and `t` is
closed, then we can find open disjoint convex sets containing them. -/
theorem Disjoint.exists_open_convexes [LocallyConvexSpace ğ•œ E] {s t : Set E} (disj : Disjoint s t)
    (hsâ‚ : Convex ğ•œ s) (hsâ‚‚ : IsCompact s) (htâ‚ : Convex ğ•œ t) (htâ‚‚ : IsClosed t) :
    âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ Convex ğ•œ u âˆ§ Convex ğ•œ v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint u v := by
  letI : UniformSpace E := IsTopologicalAddGroup.toUniformSpace E
  haveI : IsUniformAddGroup E := isUniformAddGroup_of_addCommGroup
  have := (LocallyConvexSpace.convex_open_basis_zero ğ•œ E).comap fun x : E Ã— E => x.2 - x.1
  rw [â† uniformity_eq_comap_nhds_zero] at this
  rcases disj.exists_uniform_thickening_of_basis this hsâ‚‚ htâ‚‚ with âŸ¨V, âŸ¨hV0, hVopen, hVconvexâŸ©, hVâŸ©
  refine âŸ¨s + V, t + V, hVopen.add_left, hVopen.add_left, hsâ‚.add hVconvex, htâ‚.add hVconvex,
    subset_add_left _ hV0, subset_add_left _ hV0, ?_âŸ©
  simp_rw [â† iUnion_add_left_image, image_add_left]
  simp_rw [UniformSpace.ball, â† preimage_comp, sub_eq_neg_add] at hV
  exact hV

end LinearOrderedField

section LatticeOps

variable {Î¹ : Sort*} {ğ•œ E F : Type*} [OrderedSemiring ğ•œ] [AddCommMonoid E] [Module ğ•œ E]
  [AddCommMonoid F] [Module ğ•œ F]

theorem locallyConvexSpace_sInf {ts : Set (TopologicalSpace E)}
    (h : âˆ€ t âˆˆ ts, @LocallyConvexSpace ğ•œ E _ _ _ t) : @LocallyConvexSpace ğ•œ E _ _ _ (sInf ts) := by
  letI : TopologicalSpace E := sInf ts
  refine
    LocallyConvexSpace.ofBases ğ•œ E (fun _ => fun If : Set ts Ã— (ts â†’ Set E) => â‹‚ i âˆˆ If.1, If.2 i)
      (fun x => fun If : Set ts Ã— (ts â†’ Set E) =>
        If.1.Finite âˆ§ âˆ€ i âˆˆ If.1, If.2 i âˆˆ @nhds _ (â†‘i) x âˆ§ Convex ğ•œ (If.2 i))
      (fun x => ?_) fun x If hif => convex_iInter fun i => convex_iInter fun hi => (hif.2 i hi).2
  rw [nhds_sInf, â† iInf_subtype'']
  exact hasBasis_iInf' fun i : ts => (@locallyConvexSpace_iff ğ•œ E _ _ _ â†‘i).mp (h (â†‘i) i.2) x

theorem locallyConvexSpace_iInf {ts' : Î¹ â†’ TopologicalSpace E}
    (h' : âˆ€ i, @LocallyConvexSpace ğ•œ E _ _ _ (ts' i)) :
    @LocallyConvexSpace ğ•œ E _ _ _ (â¨… i, ts' i) := by
  refine locallyConvexSpace_sInf ?_
  rwa [forall_mem_range]

theorem locallyConvexSpace_inf {tâ‚ tâ‚‚ : TopologicalSpace E} (hâ‚ : @LocallyConvexSpace ğ•œ E _ _ _ tâ‚)
    (hâ‚‚ : @LocallyConvexSpace ğ•œ E _ _ _ tâ‚‚) : @LocallyConvexSpace ğ•œ E _ _ _ (tâ‚ âŠ“ tâ‚‚) := by
  rw [inf_eq_iInf]
  refine locallyConvexSpace_iInf fun b => ?_
  cases b <;> assumption

theorem locallyConvexSpace_induced {t : TopologicalSpace F} [LocallyConvexSpace ğ•œ F]
    (f : E â†’â‚—[ğ•œ] F) : @LocallyConvexSpace ğ•œ E _ _ _ (t.induced f) := by
  letI : TopologicalSpace E := t.induced f
  refine LocallyConvexSpace.ofBases ğ•œ E (fun _ => preimage f)
    (fun x => fun s : Set F => s âˆˆ ğ“ (f x) âˆ§ Convex ğ•œ s) (fun x => ?_) fun x s âŸ¨_, hsâŸ© =>
    hs.linear_preimage f
  rw [nhds_induced]
  exact (LocallyConvexSpace.convex_basis <| f x).comap f

instance Pi.locallyConvexSpace {Î¹ : Type*} {X : Î¹ â†’ Type*} [âˆ€ i, AddCommMonoid (X i)]
    [âˆ€ i, TopologicalSpace (X i)] [âˆ€ i, Module ğ•œ (X i)] [âˆ€ i, LocallyConvexSpace ğ•œ (X i)] :
    LocallyConvexSpace ğ•œ (âˆ€ i, X i) :=
  locallyConvexSpace_iInf fun i => locallyConvexSpace_induced (LinearMap.proj i)

instance Prod.locallyConvexSpace [TopologicalSpace E] [TopologicalSpace F] [LocallyConvexSpace ğ•œ E]
    [LocallyConvexSpace ğ•œ F] : LocallyConvexSpace ğ•œ (E Ã— F) :=
  locallyConvexSpace_inf
    (locallyConvexSpace_induced (LinearMap.fst _ _ _))
    (locallyConvexSpace_induced (LinearMap.snd _ _ _))

end LatticeOps

section LinearOrderedSemiring

instance LinearOrderedSemiring.toLocallyConvexSpace {R : Type*} [TopologicalSpace R]
    [LinearOrderedSemiring R] [OrderTopology R] :
    LocallyConvexSpace R R where
  convex_basis x := by
    obtain hl | hl := isBot_or_exists_lt x
    Â· refine hl.rec ?_ _
      intro
      refine nhds_bot_basis.to_hasBasis' ?_ ?_
      Â· intros
        refine âŸ¨Set.Iio _, ?_, .rflâŸ©
        simp_all [Iio_mem_nhds, convex_Iio]
      Â· simp +contextual
    obtain hu | hu := isTop_or_exists_gt x
    Â· refine hu.rec ?_ _
      intro
      refine nhds_top_basis.to_hasBasis' ?_ ?_
      Â· intros
        refine âŸ¨Set.Ioi _, ?_, subset_refl _âŸ©
        simp_all [Ioi_mem_nhds, convex_Ioi]
      Â· simp +contextual
    refine (nhds_basis_Ioo' hl hu).to_hasBasis' ?_ ?_
    Â· simp only [id_eq, and_imp, Prod.forall]
      intros
      refine âŸ¨_, ?_, subset_refl _âŸ©
      simp_all [Ioo_mem_nhds, convex_Ioo]
    Â· simp +contextual

end LinearOrderedSemiring
