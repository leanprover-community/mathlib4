/-
Copyright (c) 2022 Anatole Dedecker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anatole Dedecker
-/
import Mathlib.Analysis.Convex.Topology

#align_import topology.algebra.module.locally_convex from "leanprover-community/mathlib"@"f2ce6086713c78a7f880485f7917ea547a215982"

/-!
# Locally convex topological modules

A `LocallyConvexSpace` is a topological semimodule over an ordered semiring in which any point
admits a neighborhood basis made of convex sets, or equivalently, in which convex neighborhoods of
a point form a neighborhood basis at that point.

In a module, this is equivalent to `0` satisfying such properties.

## Main results

- `locallyConvexSpace_iff_zero` : in a module, local convexity at zero gives
  local convexity everywhere
- `WithSeminorms.locallyConvexSpace` : a topology generated by a family of seminorms is locally
  convex (in `Analysis.LocallyConvex.WithSeminorms`)
- `NormedSpace.locallyConvexSpace` : a normed space is locally convex
  (in `Analysis.LocallyConvex.WithSeminorms`)

## TODO

- define a structure `LocallyConvexFilterBasis`, extending `ModuleFilterBasis`, for filter
  bases generating a locally convex topology

-/


open TopologicalSpace Filter Set

open Topology Pointwise

section Semimodule

/-- A `LocallyConvexSpace` is a topological semimodule over an ordered semiring in which convex
neighborhoods of a point form a neighborhood basis at that point. -/
class LocallyConvexSpace (ùïú E : Type*) [OrderedSemiring ùïú] [AddCommMonoid E] [Module ùïú E]
    [TopologicalSpace E] : Prop where
  convex_basis : ‚àÄ x : E, (ùìù x).HasBasis (fun s : Set E => s ‚àà ùìù x ‚àß Convex ùïú s) id
#align locally_convex_space LocallyConvexSpace

variable (ùïú E : Type*) [OrderedSemiring ùïú] [AddCommMonoid E] [Module ùïú E] [TopologicalSpace E]

theorem locallyConvexSpace_iff :
    LocallyConvexSpace ùïú E ‚Üî ‚àÄ x : E, (ùìù x).HasBasis (fun s : Set E => s ‚àà ùìù x ‚àß Convex ùïú s) id :=
  ‚ü®@LocallyConvexSpace.convex_basis _ _ _ _ _ _, LocallyConvexSpace.mk‚ü©
#align locally_convex_space_iff locallyConvexSpace_iff

theorem LocallyConvexSpace.ofBases {Œπ : Type*} (b : E ‚Üí Œπ ‚Üí Set E) (p : E ‚Üí Œπ ‚Üí Prop)
    (hbasis : ‚àÄ x : E, (ùìù x).HasBasis (p x) (b x)) (hconvex : ‚àÄ x i, p x i ‚Üí Convex ùïú (b x i)) :
    LocallyConvexSpace ùïú E :=
  ‚ü®fun x =>
    (hbasis x).to_hasBasis
      (fun i hi => ‚ü®b x i, ‚ü®‚ü®(hbasis x).mem_of_mem hi, hconvex x i hi‚ü©, le_refl (b x i)‚ü©‚ü©)
      fun s hs =>
      ‚ü®(hbasis x).index s hs.1, ‚ü®(hbasis x).property_index hs.1, (hbasis x).set_index_subset hs.1‚ü©‚ü©‚ü©
#align locally_convex_space.of_bases LocallyConvexSpace.ofBases

theorem LocallyConvexSpace.convex_basis_zero [LocallyConvexSpace ùïú E] :
    (ùìù 0 : Filter E).HasBasis (fun s => s ‚àà (ùìù 0 : Filter E) ‚àß Convex ùïú s) id :=
  LocallyConvexSpace.convex_basis 0
#align locally_convex_space.convex_basis_zero LocallyConvexSpace.convex_basis_zero

theorem locallyConvexSpace_iff_exists_convex_subset :
    LocallyConvexSpace ùïú E ‚Üî ‚àÄ x : E, ‚àÄ U ‚àà ùìù x, ‚àÉ S ‚àà ùìù x, Convex ùïú S ‚àß S ‚äÜ U :=
  (locallyConvexSpace_iff ùïú E).trans (forall_congr' fun _ => hasBasis_self)
#align locally_convex_space_iff_exists_convex_subset locallyConvexSpace_iff_exists_convex_subset

end Semimodule

section Module

variable (ùïú E : Type*) [OrderedSemiring ùïú] [AddCommGroup E] [Module ùïú E] [TopologicalSpace E]
  [TopologicalAddGroup E]

theorem LocallyConvexSpace.ofBasisZero {Œπ : Type*} (b : Œπ ‚Üí Set E) (p : Œπ ‚Üí Prop)
    (hbasis : (ùìù 0).HasBasis p b) (hconvex : ‚àÄ i, p i ‚Üí Convex ùïú (b i)) :
    LocallyConvexSpace ùïú E := by
  refine LocallyConvexSpace.ofBases ùïú E (fun (x : E) (i : Œπ) => (x + ¬∑) '' b i) (fun _ => p)
    (fun x => ?_) fun x i hi => (hconvex i hi).translate x
  rw [‚Üê map_add_left_nhds_zero]
  exact hbasis.map _
#align locally_convex_space.of_basis_zero LocallyConvexSpace.ofBasisZero

theorem locallyConvexSpace_iff_zero : LocallyConvexSpace ùïú E ‚Üî
    (ùìù 0 : Filter E).HasBasis (fun s : Set E => s ‚àà (ùìù 0 : Filter E) ‚àß Convex ùïú s) id :=
  ‚ü®fun h => @LocallyConvexSpace.convex_basis _ _ _ _ _ _ h 0, fun h =>
    LocallyConvexSpace.ofBasisZero ùïú E _ _ h fun _ => And.right‚ü©
#align locally_convex_space_iff_zero locallyConvexSpace_iff_zero

theorem locallyConvexSpace_iff_exists_convex_subset_zero :
    LocallyConvexSpace ùïú E ‚Üî ‚àÄ U ‚àà (ùìù 0 : Filter E), ‚àÉ S ‚àà (ùìù 0 : Filter E), Convex ùïú S ‚àß S ‚äÜ U :=
  (locallyConvexSpace_iff_zero ùïú E).trans hasBasis_self
#align locally_convex_space_iff_exists_convex_subset_zero locallyConvexSpace_iff_exists_convex_subset_zero

-- see Note [lower instance priority]
instance (priority := 100) LocallyConvexSpace.toLocallyConnectedSpace [Module ‚Ñù E]
    [ContinuousSMul ‚Ñù E] [LocallyConvexSpace ‚Ñù E] : LocallyConnectedSpace E :=
  locallyConnectedSpace_of_connected_bases _ _
    (fun x => @LocallyConvexSpace.convex_basis ‚Ñù _ _ _ _ _ _ x) fun _ _ hs => hs.2.isPreconnected
#align locally_convex_space.to_locally_connected_space LocallyConvexSpace.toLocallyConnectedSpace

end Module

section LinearOrderedField

variable (ùïú E : Type*) [LinearOrderedField ùïú] [AddCommGroup E] [Module ùïú E] [TopologicalSpace E]
  [TopologicalAddGroup E] [ContinuousConstSMul ùïú E]

theorem LocallyConvexSpace.convex_open_basis_zero [LocallyConvexSpace ùïú E] :
    (ùìù 0 : Filter E).HasBasis (fun s => (0 : E) ‚àà s ‚àß IsOpen s ‚àß Convex ùïú s) id :=
  (LocallyConvexSpace.convex_basis_zero ùïú E).to_hasBasis
    (fun s hs =>
      ‚ü®interior s, ‚ü®mem_interior_iff_mem_nhds.mpr hs.1, isOpen_interior, hs.2.interior‚ü©,
        interior_subset‚ü©)
    fun s hs => ‚ü®s, ‚ü®hs.2.1.mem_nhds hs.1, hs.2.2‚ü©, subset_rfl‚ü©
#align locally_convex_space.convex_open_basis_zero LocallyConvexSpace.convex_open_basis_zero

variable {ùïú E}

/-- In a locally convex space, if `s`, `t` are disjoint convex sets, `s` is compact and `t` is
closed, then we can find open disjoint convex sets containing them. -/
theorem Disjoint.exists_open_convexes [LocallyConvexSpace ùïú E] {s t : Set E} (disj : Disjoint s t)
    (hs‚ÇÅ : Convex ùïú s) (hs‚ÇÇ : IsCompact s) (ht‚ÇÅ : Convex ùïú t) (ht‚ÇÇ : IsClosed t) :
    ‚àÉ u v, IsOpen u ‚àß IsOpen v ‚àß Convex ùïú u ‚àß Convex ùïú v ‚àß s ‚äÜ u ‚àß t ‚äÜ v ‚àß Disjoint u v := by
  letI : UniformSpace E := TopologicalAddGroup.toUniformSpace E
  haveI : UniformAddGroup E := comm_topologicalAddGroup_is_uniform
  have := (LocallyConvexSpace.convex_open_basis_zero ùïú E).comap fun x : E √ó E => x.2 - x.1
  rw [‚Üê uniformity_eq_comap_nhds_zero] at this
  rcases disj.exists_uniform_thickening_of_basis this hs‚ÇÇ ht‚ÇÇ with ‚ü®V, ‚ü®hV0, hVopen, hVconvex‚ü©, hV‚ü©
  refine ‚ü®s + V, t + V, hVopen.add_left, hVopen.add_left, hs‚ÇÅ.add hVconvex, ht‚ÇÅ.add hVconvex,
    subset_add_left _ hV0, subset_add_left _ hV0, ?_‚ü©
  simp_rw [‚Üê iUnion_add_left_image, image_add_left]
  simp_rw [UniformSpace.ball, ‚Üê preimage_comp, sub_eq_neg_add] at hV
  exact hV
#align disjoint.exists_open_convexes Disjoint.exists_open_convexes

end LinearOrderedField

section LatticeOps

variable {Œπ : Sort*} {ùïú E F : Type*} [OrderedSemiring ùïú] [AddCommMonoid E] [Module ùïú E]
  [AddCommMonoid F] [Module ùïú F]

theorem locallyConvexSpace_sInf {ts : Set (TopologicalSpace E)}
    (h : ‚àÄ t ‚àà ts, @LocallyConvexSpace ùïú E _ _ _ t) : @LocallyConvexSpace ùïú E _ _ _ (sInf ts) := by
  letI : TopologicalSpace E := sInf ts
  refine
    LocallyConvexSpace.ofBases ùïú E (fun _ => fun If : Set ts √ó (ts ‚Üí Set E) => ‚ãÇ i ‚àà If.1, If.2 i)
      (fun x => fun If : Set ts √ó (ts ‚Üí Set E) =>
        If.1.Finite ‚àß ‚àÄ i ‚àà If.1, If.2 i ‚àà @nhds _ (‚Üëi) x ‚àß Convex ùïú (If.2 i))
      (fun x => ?_) fun x If hif => convex_iInter fun i => convex_iInter fun hi => (hif.2 i hi).2
  rw [nhds_sInf, ‚Üê iInf_subtype'']
  exact hasBasis_iInf' fun i : ts => (@locallyConvexSpace_iff ùïú E _ _ _ ‚Üëi).mp (h (‚Üëi) i.2) x
#align locally_convex_space_Inf locallyConvexSpace_sInf

theorem locallyConvexSpace_iInf {ts' : Œπ ‚Üí TopologicalSpace E}
    (h' : ‚àÄ i, @LocallyConvexSpace ùïú E _ _ _ (ts' i)) :
    @LocallyConvexSpace ùïú E _ _ _ (‚®Ö i, ts' i) := by
  refine locallyConvexSpace_sInf ?_
  rwa [forall_mem_range]
#align locally_convex_space_infi locallyConvexSpace_iInf

theorem locallyConvexSpace_inf {t‚ÇÅ t‚ÇÇ : TopologicalSpace E} (h‚ÇÅ : @LocallyConvexSpace ùïú E _ _ _ t‚ÇÅ)
    (h‚ÇÇ : @LocallyConvexSpace ùïú E _ _ _ t‚ÇÇ) : @LocallyConvexSpace ùïú E _ _ _ (t‚ÇÅ ‚äì t‚ÇÇ) := by
  rw [inf_eq_iInf]
  refine locallyConvexSpace_iInf fun b => ?_
  cases b <;> assumption
#align locally_convex_space_inf locallyConvexSpace_inf

theorem locallyConvexSpace_induced {t : TopologicalSpace F} [LocallyConvexSpace ùïú F]
    (f : E ‚Üí‚Çó[ùïú] F) : @LocallyConvexSpace ùïú E _ _ _ (t.induced f) := by
  letI : TopologicalSpace E := t.induced f
  refine LocallyConvexSpace.ofBases ùïú E (fun _ => preimage f)
    (fun x => fun s : Set F => s ‚àà ùìù (f x) ‚àß Convex ùïú s) (fun x => ?_) fun x s ‚ü®_, hs‚ü© =>
    hs.linear_preimage f
  rw [nhds_induced]
  exact (LocallyConvexSpace.convex_basis <| f x).comap f
#align locally_convex_space_induced locallyConvexSpace_induced

instance Pi.locallyConvexSpace {Œπ : Type*} {X : Œπ ‚Üí Type*} [‚àÄ i, AddCommMonoid (X i)]
    [‚àÄ i, TopologicalSpace (X i)] [‚àÄ i, Module ùïú (X i)] [‚àÄ i, LocallyConvexSpace ùïú (X i)] :
    LocallyConvexSpace ùïú (‚àÄ i, X i) :=
  locallyConvexSpace_iInf fun i => locallyConvexSpace_induced (LinearMap.proj i)
#align pi.locally_convex_space Pi.locallyConvexSpace

instance Prod.locallyConvexSpace [TopologicalSpace E] [TopologicalSpace F] [LocallyConvexSpace ùïú E]
    [LocallyConvexSpace ùïú F] : LocallyConvexSpace ùïú (E √ó F) :=
-- Porting note: had to specify `t‚ÇÅ` and `t‚ÇÇ`
  locallyConvexSpace_inf (t‚ÇÅ := induced Prod.fst _) (t‚ÇÇ := induced Prod.snd _)
    (locallyConvexSpace_induced (LinearMap.fst _ _ _))
    (locallyConvexSpace_induced (LinearMap.snd _ _ _))
#align prod.locally_convex_space Prod.locallyConvexSpace

end LatticeOps
