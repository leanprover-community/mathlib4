/-
Copyright (c) 2022 Anatole Dedecker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anatole Dedecker
-/
import Mathlib.Topology.Coherent
import Mathlib.Topology.UniformSpace.Equiv
import Mathlib.Topology.UniformSpace.Pi
import Mathlib.Topology.UniformSpace.UniformApproximation

/-!
# Topology and uniform structure of uniform convergence

This files endows `Î± â†’ Î²` with the topologies / uniform structures of
- uniform convergence on `Î±`
- uniform convergence on a specified family `ğ”–` of sets of `Î±`, also called `ğ”–`-convergence

Since `Î± â†’ Î²` is already endowed with the topologies and uniform structures of pointwise
convergence, we introduce type aliases `UniformFun Î± Î²` (denoted `Î± â†’áµ¤ Î²`) and
`UniformOnFun Î± Î² ğ”–` (denoted `Î± â†’áµ¤[ğ”–] Î²`) and we actually endow *these* with the structures
of uniform and `ğ”–`-convergence respectively.

Usual examples of the second construction include :
- the topology of compact convergence, when `ğ”–` is the set of compacts of `Î±`
- the strong topology on the dual of a topological vector space (TVS) `E`, when `ğ”–` is the set of
  Von Neumann bounded subsets of `E`
- the weak-* topology on the dual of a TVS `E`, when `ğ”–` is the set of singletons of `E`.

This file contains a lot of technical facts, so it is heavily commented, proofs included!

## Main definitions

* `UniformFun.gen`: basis sets for the uniformity of uniform convergence. These are sets
  of the form `S(V) := {(f, g) | âˆ€ x : Î±, (f x, g x) âˆˆ V}` for some `V : Set (Î² Ã— Î²)`
* `UniformFun.uniformSpace`: uniform structure of uniform convergence. This is the
  `UniformSpace` on `Î± â†’áµ¤ Î²` whose uniformity is generated by the sets `S(V)` for `V âˆˆ ğ“¤ Î²`.
  We will denote this uniform space as `ğ’°(Î±, Î², uÎ²)`, both in the comments and as a local notation
  in the Lean code, where `uÎ²` is the uniform space structure on `Î²`.
  This is declared as an instance on `Î± â†’áµ¤ Î²`.
* `UniformOnFun.uniformSpace`: uniform structure of `ğ”–`-convergence, where
  `ğ”– : Set (Set Î±)`. This is the infimum, for `S âˆˆ ğ”–`, of the pullback of `ğ’° S Î²` by the map of
  restriction to `S`. We will denote it `ğ’±(Î±, Î², ğ”–, uÎ²)`, where `uÎ²` is the uniform space structure
  on `Î²`.
  This is declared as an instance on `Î± â†’áµ¤[ğ”–] Î²`.

## Main statements

### Basic properties

* `UniformFun.uniformContinuous_eval`: evaluation is uniformly continuous on `Î± â†’áµ¤ Î²`.
* `UniformFun.t2Space`: the topology of uniform convergence on `Î± â†’áµ¤ Î²` is Tâ‚‚ if
  `Î²` is Tâ‚‚.
* `UniformFun.tendsto_iff_tendstoUniformly`: `ğ’°(Î±, Î², uÎ²)` is
  indeed the uniform structure of uniform convergence
* `UniformOnFun.uniformContinuous_eval_of_mem`: evaluation at a point contained in a
  set of `ğ”–` is uniformly continuous on `Î± â†’áµ¤[ğ”–] Î²`
* `UniformOnFun.t2Space_of_covering`: the topology of `ğ”–`-convergence on `Î± â†’áµ¤[ğ”–] Î²` is Tâ‚‚ if
  `Î²` is Tâ‚‚ and `ğ”–` covers `Î±`
* `UniformOnFun.tendsto_iff_tendstoUniformlyOn`:
  `ğ’±(Î±, Î², ğ”– uÎ²)` is indeed the uniform structure of `ğ”–`-convergence

### Functoriality and compatibility with product of uniform spaces

In order to avoid the need for filter bases as much as possible when using these definitions,
we develop an extensive API for manipulating these structures abstractly. As usual in the topology
section of mathlib, we first state results about the complete lattices of `UniformSpace`s on
fixed types, and then we use these to deduce categorical-like results about maps between two
uniform spaces.

We only describe these in the harder case of `ğ”–`-convergence, as the names of the corresponding
results for uniform convergence can easily be guessed.

#### Order statements

* `UniformOnFun.mono`: let `uâ‚`, `uâ‚‚` be two uniform structures on `Î³` and
  `ğ”–â‚ ğ”–â‚‚ : Set (Set Î±)`. If `uâ‚ â‰¤ uâ‚‚` and `ğ”–â‚‚ âŠ† ğ”–â‚` then `ğ’±(Î±, Î³, ğ”–â‚, uâ‚) â‰¤ ğ’±(Î±, Î³, ğ”–â‚‚, uâ‚‚)`.
* `UniformOnFun.iInf_eq`: if `u` is a family of uniform structures on `Î³`, then
  `ğ’±(Î±, Î³, ğ”–, (â¨… i, u i)) = â¨… i, ğ’±(Î±, Î³, ğ”–, u i)`.
* `UniformOnFun.comap_eq`: if `u` is a uniform structures on `Î²` and `f : Î³ â†’ Î²`, then
  `ğ’±(Î±, Î³, ğ”–, comap f u) = comap (fun g â†¦ f âˆ˜ g) ğ’±(Î±, Î³, ğ”–, uâ‚)`.

An interesting note about these statements is that they are proved without ever unfolding the basis
definition of the uniform structure of uniform convergence! Instead, we build a
(not very interesting) Galois connection `UniformFun.gc` and then rely on the Galois
connection API to do most of the work.

#### Morphism statements (unbundled)

* `UniformOnFun.postcomp_uniformContinuous`: if `f : Î³ â†’ Î²` is uniformly
  continuous, then `(fun g â†¦ f âˆ˜ g) : (Î± â†’áµ¤[ğ”–] Î³) â†’ (Î± â†’áµ¤[ğ”–] Î²)` is uniformly continuous.
* `UniformOnFun.postcomp_isUniformInducing`: if `f : Î³ â†’ Î²` is a uniform
  inducing, then `(fun g â†¦ f âˆ˜ g) : (Î± â†’áµ¤[ğ”–] Î³) â†’ (Î± â†’áµ¤[ğ”–] Î²)` is a uniform inducing.
* `UniformOnFun.precomp_uniformContinuous`: let `f : Î³ â†’ Î±`, `ğ”– : Set (Set Î±)`,
  `ğ”— : Set (Set Î³)`, and assume that `âˆ€ T âˆˆ ğ”—, f '' T âˆˆ ğ”–`. Then, the function
  `(fun g â†¦ g âˆ˜ f) : (Î± â†’áµ¤[ğ”–] Î²) â†’ (Î³ â†’áµ¤[ğ”—] Î²)` is uniformly continuous.

#### Isomorphism statements (bundled)

* `UniformOnFun.congrRight`: turn a uniform isomorphism `Î³ â‰ƒáµ¤ Î²` into a uniform isomorphism
  `(Î± â†’áµ¤[ğ”–] Î³) â‰ƒáµ¤ (Î± â†’áµ¤[ğ”–] Î²)` by post-composing.
* `UniformOnFun.congrLeft`: turn a bijection `e : Î³ â‰ƒ Î±` such that we have both
  `âˆ€ T âˆˆ ğ”—, e '' T âˆˆ ğ”–` and `âˆ€ S âˆˆ ğ”–, e â»Â¹' S âˆˆ ğ”—` into a uniform isomorphism
  `(Î³ â†’áµ¤[ğ”—] Î²) â‰ƒáµ¤ (Î± â†’áµ¤[ğ”–] Î²)` by pre-composing.
* `UniformOnFun.uniformEquivPiComm`: the natural bijection between `Î± â†’ Î  i, Î´ i`
  and `Î  i, Î± â†’ Î´ i`, upgraded to a uniform isomorphism between `Î± â†’áµ¤[ğ”–] (Î  i, Î´ i)` and
  `Î  i, Î± â†’áµ¤[ğ”–] Î´ i`.

#### Important use cases

* If `G` is a uniform group, then `Î± â†’áµ¤[ğ”–] G` is a uniform group: since `(/) : G Ã— G â†’ G` is
  uniformly continuous, `UniformOnFun.postcomp_uniformContinuous` tells us that
  `((/) âˆ˜ â€”) : (Î± â†’áµ¤[ğ”–] G Ã— G) â†’ (Î± â†’áµ¤[ğ”–] G)` is uniformly continuous. By precomposing with
  `UniformOnFun.uniformEquivProdArrow`, this gives that
  `(/) : (Î± â†’áµ¤[ğ”–] G) Ã— (Î± â†’áµ¤[ğ”–] G) â†’ (Î± â†’áµ¤[ğ”–] G)` is also uniformly continuous
* The transpose of a continuous linear map is continuous for the strong topologies: since
  continuous linear maps are uniformly continuous and map bounded sets to bounded sets,
  this is just a special case of `UniformOnFun.precomp_uniformContinuous`.

## TODO

* Show that the uniform structure of `ğ”–`-convergence is exactly the structure of `ğ”–'`-convergence,
  where `ğ”–'` is the ***noncovering*** bornology (i.e ***not*** what `Bornology` currently refers
  to in mathlib) generated by `ğ”–`.

## References

* [N. Bourbaki, *General Topology, Chapter X*][bourbaki1966]

## Tags

uniform convergence
-/

noncomputable section

open Filter Set Topology
open scoped Uniformity

section TypeAlias

/-- The type of functions from `Î±` to `Î²` equipped with the uniform structure and topology of
uniform convergence. We denote it `Î± â†’áµ¤ Î²`. -/
def UniformFun (Î± Î² : Type*) :=
  Î± â†’ Î²

/-- The type of functions from `Î±` to `Î²` equipped with the uniform structure and topology of
uniform convergence on some family `ğ”–` of subsets of `Î±`. We denote it `Î± â†’áµ¤[ğ”–] Î²`. -/
@[nolint unusedArguments]
def UniformOnFun (Î± Î² : Type*) (_ : Set (Set Î±)) :=
  Î± â†’ Î²

@[inherit_doc] scoped[UniformConvergence] notation:25 Î± " â†’áµ¤ " Î²:0 => UniformFun Î± Î²

@[inherit_doc] scoped[UniformConvergence] notation:25 Î± " â†’áµ¤[" ğ”– "] " Î²:0 => UniformOnFun Î± Î² ğ”–

open UniformConvergence

variable {Î± Î² : Type*} {ğ”– : Set (Set Î±)}

instance [Nonempty Î²] : Nonempty (Î± â†’áµ¤ Î²) := Pi.instNonempty

instance [Nonempty Î²] : Nonempty (Î± â†’áµ¤[ğ”–] Î²) := Pi.instNonempty

instance [Subsingleton Î²] : Subsingleton (Î± â†’áµ¤ Î²) :=
  inferInstanceAs <| Subsingleton <| Î± â†’ Î²

instance [Subsingleton Î²] : Subsingleton (Î± â†’áµ¤[ğ”–] Î²) :=
  inferInstanceAs <| Subsingleton <| Î± â†’ Î²

/-- Reinterpret `f : Î± â†’ Î²` as an element of `Î± â†’áµ¤ Î²`. -/
def UniformFun.ofFun : (Î± â†’ Î²) â‰ƒ (Î± â†’áµ¤ Î²) :=
  âŸ¨fun x => x, fun x => x, fun _ => rfl, fun _ => rflâŸ©

/-- Reinterpret `f : Î± â†’ Î²` as an element of `Î± â†’áµ¤[ğ”–] Î²`. -/
def UniformOnFun.ofFun (ğ”–) : (Î± â†’ Î²) â‰ƒ (Î± â†’áµ¤[ğ”–] Î²) :=
  âŸ¨fun x => x, fun x => x, fun _ => rfl, fun _ => rflâŸ©

/-- Reinterpret `f : Î± â†’áµ¤ Î²` as an element of `Î± â†’ Î²`. -/
def UniformFun.toFun : (Î± â†’áµ¤ Î²) â‰ƒ (Î± â†’ Î²) :=
  UniformFun.ofFun.symm

/-- Reinterpret `f : Î± â†’áµ¤[ğ”–] Î²` as an element of `Î± â†’ Î²`. -/
def UniformOnFun.toFun (ğ”–) : (Î± â†’áµ¤[ğ”–] Î²) â‰ƒ (Î± â†’ Î²) :=
  (UniformOnFun.ofFun ğ”–).symm

@[simp] lemma UniformFun.toFun_ofFun (f : Î± â†’ Î²) : toFun (ofFun f) = f := rfl
@[simp] lemma UniformFun.ofFun_toFun (f : Î± â†’áµ¤ Î²) : ofFun (toFun f) = f := rfl
@[simp] lemma UniformOnFun.toFun_ofFun (f : Î± â†’ Î²) : toFun ğ”– (ofFun ğ”– f) = f := rfl
@[simp] lemma UniformOnFun.ofFun_toFun (f : Î± â†’áµ¤[ğ”–] Î²) : ofFun ğ”– (toFun ğ”– f) = f := rfl

-- Note: we don't declare a `CoeFun` instance because Lean wouldn't insert it when writing
-- `f x` (because of definitional equality with `Î± â†’ Î²`).
end TypeAlias

open UniformConvergence

namespace UniformFun

variable (Î± Î² : Type*) {Î³ Î¹ : Type*}
variable {p : Filter Î¹}

/-- Basis sets for the uniformity of uniform convergence: `gen Î± Î² V` is the set of pairs `(f, g)`
of functions `Î± â†’áµ¤ Î²` such that `âˆ€ x, (f x, g x) âˆˆ V`. -/
protected def gen (V : Set (Î² Ã— Î²)) : Set ((Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²)) :=
  { uv : (Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²) | âˆ€ x, (toFun uv.1 x, toFun uv.2 x) âˆˆ V }

/-- If `ğ“•` is a filter on `Î² Ã— Î²`, then the set of all `UniformFun.gen Î± Î² V` for
`V âˆˆ ğ“•` is a filter basis on `(Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²)`. This will only be applied to `ğ“• = ğ“¤ Î²` when
`Î²` is equipped with a `UniformSpace` structure, but it is useful to define it for any filter in
order to be able to state that it has a lower adjoint (see `UniformFun.gc`). -/
protected theorem isBasis_gen (ğ“‘ : Filter <| Î² Ã— Î²) :
    IsBasis (fun V : Set (Î² Ã— Î²) => V âˆˆ ğ“‘) (UniformFun.gen Î± Î²) :=
  âŸ¨âŸ¨univ, univ_memâŸ©, @fun U V hU hV =>
    âŸ¨U âˆ© V, inter_mem hU hV, fun _ huv => âŸ¨fun x => (huv x).left, fun x => (huv x).rightâŸ©âŸ©âŸ©

/-- For `ğ“• : Filter (Î² Ã— Î²)`, this is the set of all `UniformFun.gen Î± Î² V` for
`V âˆˆ ğ“•` as a bundled `FilterBasis` over `(Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²)`. This will only be applied to
`ğ“• = ğ“¤ Î²` when `Î²` is equipped with a `UniformSpace` structure, but it is useful to define it for
any filter in order to be able to state that it has a lower adjoint
(see `UniformFun.gc`). -/
protected def basis (ğ“• : Filter <| Î² Ã— Î²) : FilterBasis ((Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²)) :=
  (UniformFun.isBasis_gen Î± Î² ğ“•).filterBasis

/-- For `ğ“• : Filter (Î² Ã— Î²)`, this is the filter generated by the filter basis
`UniformFun.basis Î± Î² ğ“•`. For `ğ“• = ğ“¤ Î²`, this will be the uniformity of uniform
convergence on `Î±`. -/
protected def filter (ğ“• : Filter <| Î² Ã— Î²) : Filter ((Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²)) :=
  (UniformFun.basis Î± Î² ğ“•).filter

--local notation "Î¦" => fun (Î± Î² : Type*) (uvx : ((Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²)) Ã— Î±) =>
  --(uvx.fst.fst uvx.2, uvx.1.2 uvx.2)

protected def phi (Î± Î² : Type*) (uvx : ((Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²)) Ã— Î±) : Î² Ã— Î² :=
  (uvx.fst.fst uvx.2, uvx.1.2 uvx.2)

set_option quotPrecheck false -- Porting note: error message suggested to do this
/- This is a lower adjoint to `UniformFun.filter` (see `UniformFun.gc`).
The exact definition of the lower adjoint `l` is not interesting; we will only use that it exists
(in `UniformFun.mono` and `UniformFun.iInf_eq`) and that
`l (Filter.map (Prod.map f f) ğ“•) = Filter.map (Prod.map ((âˆ˜) f) ((âˆ˜) f)) (l ğ“•)` for each
`ğ“• : Filter (Î³ Ã— Î³)` and `f : Î³ â†’ Î±` (in `UniformFun.comap_eq`). -/
local notation "lowerAdjoint" => fun ğ“ => map (UniformFun.phi Î± Î²) (ğ“ Ã—Ë¢ âŠ¤)

/-- The function `UniformFun.filter Î± Î² : Filter (Î² Ã— Î²) â†’ Filter ((Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²))`
has a lower adjoint `l` (in the sense of `GaloisConnection`). The exact definition of `l` is not
interesting; we will only use that it exists (in `UniformFun.mono` and
`UniformFun.iInf_eq`) and that
`l (Filter.map (Prod.map f f) ğ“•) = Filter.map (Prod.map ((âˆ˜) f) ((âˆ˜) f)) (l ğ“•)` for each
`ğ“• : Filter (Î³ Ã— Î³)` and `f : Î³ â†’ Î±` (in `UniformFun.comap_eq`). -/
protected theorem gc : GaloisConnection lowerAdjoint fun ğ“• => UniformFun.filter Î± Î² ğ“• := by
  intro ğ“ ğ“•
  symm
  calc
    ğ“ â‰¤ UniformFun.filter Î± Î² ğ“• â†” (UniformFun.basis Î± Î² ğ“•).sets âŠ† ğ“.sets := by
      rw [UniformFun.filter, â† FilterBasis.generate, le_generate_iff]
    _ â†” âˆ€ U âˆˆ ğ“•, UniformFun.gen Î± Î² U âˆˆ ğ“ := image_subset_iff
    _ â†” âˆ€ U âˆˆ ğ“•,
          { uv | âˆ€ x, (uv, x) âˆˆ { t : ((Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²)) Ã— Î± | (t.1.1 t.2, t.1.2 t.2) âˆˆ U } } âˆˆ
            ğ“ :=
      Iff.rfl
    _ â†” âˆ€ U âˆˆ ğ“•,
          { uvx : ((Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²)) Ã— Î± | (uvx.1.1 uvx.2, uvx.1.2 uvx.2) âˆˆ U } âˆˆ
            ğ“ Ã—Ë¢ (âŠ¤ : Filter Î±) :=
      forallâ‚‚_congr fun U _hU => mem_prod_top.symm
    _ â†” lowerAdjoint ğ“ â‰¤ ğ“• := Iff.rfl

variable [UniformSpace Î²]

/-- Core of the uniform structure of uniform convergence. -/
protected def uniformCore : UniformSpace.Core (Î± â†’áµ¤ Î²) :=
  UniformSpace.Core.mkOfBasis (UniformFun.basis Î± Î² (ğ“¤ Î²))
    (fun _ âŸ¨_, hV, hVUâŸ© _ => hVU â–¸ fun _ => refl_mem_uniformity hV)
    (fun _ âŸ¨V, hV, hVUâŸ© =>
      hVU â–¸
        âŸ¨UniformFun.gen Î± Î² (Prod.swap â»Â¹' V), âŸ¨Prod.swap â»Â¹' V, tendsto_swap_uniformity hV, rflâŸ©,
          fun _ huv x => huv xâŸ©)
    fun _ âŸ¨_, hV, hVUâŸ© =>
    hVU â–¸
      let âŸ¨W, hW, hWVâŸ© := comp_mem_uniformity_sets hV
      âŸ¨UniformFun.gen Î± Î² W, âŸ¨W, hW, rflâŸ©, fun _ âŸ¨w, huw, hwvâŸ© x => hWV âŸ¨w x, âŸ¨huw x, hwv xâŸ©âŸ©âŸ©

/-- Uniform structure of uniform convergence, declared as an instance on `Î± â†’áµ¤ Î²`.
We will denote it `ğ’°(Î±, Î², uÎ²)` in the rest of this file. -/
instance uniformSpace : UniformSpace (Î± â†’áµ¤ Î²) :=
  UniformSpace.ofCore (UniformFun.uniformCore Î± Î²)

/-- Topology of uniform convergence, declared as an instance on `Î± â†’áµ¤ Î²`. -/
instance topologicalSpace : TopologicalSpace (Î± â†’áµ¤ Î²) :=
  inferInstance

local notation "ğ’°(" Î± ", " Î² ", " u ")" => @UniformFun.uniformSpace Î± Î² u

/-- By definition, the uniformity of `Î± â†’áµ¤ Î²` admits the family `{(f, g) | âˆ€ x, (f x, g x) âˆˆ V}`
for `V âˆˆ ğ“¤ Î²` as a filter basis. -/
protected theorem hasBasis_uniformity :
    (ğ“¤ (Î± â†’áµ¤ Î²)).HasBasis (Â· âˆˆ ğ“¤ Î²) (UniformFun.gen Î± Î²) :=
  (UniformFun.isBasis_gen Î± Î² (ğ“¤ Î²)).hasBasis

/-- The uniformity of `Î± â†’áµ¤ Î²` admits the family `{(f, g) | âˆ€ x, (f x, g x) âˆˆ V}` for `V âˆˆ ğ“‘` as
a filter basis, for any basis `ğ“‘` of `ğ“¤ Î²` (in the case `ğ“‘ = (ğ“¤ Î²).as_basis` this is true by
definition). -/
protected theorem hasBasis_uniformity_of_basis {Î¹ : Sort*} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set (Î² Ã— Î²)}
    (h : (ğ“¤ Î²).HasBasis p s) : (ğ“¤ (Î± â†’áµ¤ Î²)).HasBasis p (UniformFun.gen Î± Î² âˆ˜ s) :=
  (UniformFun.hasBasis_uniformity Î± Î²).to_hasBasis
    (fun _ hU =>
      let âŸ¨i, hi, hiUâŸ© := h.mem_iff.mp hU
      âŸ¨i, hi, fun _ huv x => hiU (huv x)âŸ©)
    fun i hi => âŸ¨s i, h.mem_of_mem hi, subset_refl _âŸ©

/-- For `f : Î± â†’áµ¤ Î²`, `ğ“ f` admits the family `{g | âˆ€ x, (f x, g x) âˆˆ V}` for `V âˆˆ ğ“‘` as a filter
basis, for any basis `ğ“‘` of `ğ“¤ Î²`. -/
protected theorem hasBasis_nhds_of_basis (f) {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set (Î² Ã— Î²)}
    (h : HasBasis (ğ“¤ Î²) p s) :
    (ğ“ f).HasBasis p fun i => { g | (f, g) âˆˆ UniformFun.gen Î± Î² (s i) } :=
  nhds_basis_uniformity' (UniformFun.hasBasis_uniformity_of_basis Î± Î² h)

/-- For `f : Î± â†’áµ¤ Î²`, `ğ“ f` admits the family `{g | âˆ€ x, (f x, g x) âˆˆ V}` for `V âˆˆ ğ“¤ Î²` as a
filter basis. -/
protected theorem hasBasis_nhds (f) :
    (ğ“ f).HasBasis (fun V => V âˆˆ ğ“¤ Î²) fun V => { g | (f, g) âˆˆ UniformFun.gen Î± Î² V } :=
  UniformFun.hasBasis_nhds_of_basis Î± Î² f (Filter.basis_sets _)

variable {Î±}

/-- Evaluation at a fixed point is uniformly continuous on `Î± â†’áµ¤ Î²`. -/
theorem uniformContinuous_eval (x : Î±) :
    UniformContinuous (Function.eval x âˆ˜ toFun : (Î± â†’áµ¤ Î²) â†’ Î²) := by
  change _ â‰¤ _
  rw [map_le_iff_le_comap,
    (UniformFun.hasBasis_uniformity Î± Î²).le_basis_iff ((ğ“¤ _).basis_sets.comap _)]
  exact fun U hU => âŸ¨U, hU, fun uv huv => huv xâŸ©

variable {Î²}

@[simp]
protected lemma mem_gen {Î²} {f g : Î± â†’áµ¤ Î²} {V : Set (Î² Ã— Î²)} :
    (f, g) âˆˆ UniformFun.gen Î± Î² V â†” âˆ€ x, (toFun f x, toFun g x) âˆˆ V :=
  .rfl

/-- If `uâ‚` and `uâ‚‚` are two uniform structures on `Î³` and `uâ‚ â‰¤ uâ‚‚`, then
`ğ’°(Î±, Î³, uâ‚) â‰¤ ğ’°(Î±, Î³, uâ‚‚)`. -/
protected theorem mono : Monotone (@UniformFun.uniformSpace Î± Î³) := fun _ _ hu =>
  (UniformFun.gc Î± Î³).monotone_u hu

/-- If `u` is a family of uniform structures on `Î³`, then
`ğ’°(Î±, Î³, (â¨… i, u i)) = â¨… i, ğ’°(Î±, Î³, u i)`. -/
protected theorem iInf_eq {u : Î¹ â†’ UniformSpace Î³} : ğ’°(Î±, Î³, (â¨… i, u i)) = â¨… i, ğ’°(Î±, Î³, u i) := by
  -- This follows directly from the fact that the upper adjoint in a Galois connection maps
  -- infimas to infimas.
  ext : 1
  change UniformFun.filter Î± Î³ ğ“¤[â¨… i, u i] = ğ“¤[â¨… i, ğ’°(Î±, Î³, u i)]
  rw [iInf_uniformity, iInf_uniformity]
  exact (UniformFun.gc Î± Î³).u_iInf

/-- If `uâ‚` and `uâ‚‚` are two uniform structures on `Î³`, then
`ğ’°(Î±, Î³, uâ‚ âŠ“ uâ‚‚) = ğ’°(Î±, Î³, uâ‚) âŠ“ ğ’°(Î±, Î³, uâ‚‚)`. -/
protected theorem inf_eq {uâ‚ uâ‚‚ : UniformSpace Î³} :
    ğ’°(Î±, Î³, uâ‚ âŠ“ uâ‚‚) = ğ’°(Î±, Î³, uâ‚) âŠ“ ğ’°(Î±, Î³, uâ‚‚) := by
  -- This follows directly from the fact that the upper adjoint in a Galois connection maps
  -- infimas to infimas.
  rw [inf_eq_iInf, inf_eq_iInf, UniformFun.iInf_eq]
  refine iInf_congr fun i => ?_
  cases i <;> rfl

/-- Post-composition by a uniform inducing function is
a uniform inducing function for the uniform structures of uniform convergence.

More precisely, if `f : Î³ â†’ Î²` is uniform inducing,
then `(f âˆ˜ Â·) : (Î± â†’áµ¤ Î³) â†’ (Î± â†’áµ¤ Î²)` is uniform inducing. -/
lemma postcomp_isUniformInducing [UniformSpace Î³] {f : Î³ â†’ Î²}
    (hf : IsUniformInducing f) : IsUniformInducing (ofFun âˆ˜ (f âˆ˜ Â·) âˆ˜ toFun : (Î± â†’áµ¤ Î³) â†’ Î± â†’áµ¤ Î²) :=
  âŸ¨((UniformFun.hasBasis_uniformity _ _).comap _).eq_of_same_basis <|
    UniformFun.hasBasis_uniformity_of_basis _ _ (hf.basis_uniformity (ğ“¤ Î²).basis_sets)âŸ©

/-- Post-composition by a uniform embedding is
a uniform embedding for the uniform structures of uniform convergence.

More precisely, if `f : Î³ â†’ Î²` is a uniform embedding,
then `(f âˆ˜ Â·) : (Î± â†’áµ¤ Î³) â†’ (Î± â†’áµ¤ Î²)` is a uniform embedding. -/
protected theorem postcomp_isUniformEmbedding [UniformSpace Î³] {f : Î³ â†’ Î²}
    (hf : IsUniformEmbedding f) :
    IsUniformEmbedding (ofFun âˆ˜ (f âˆ˜ Â·) âˆ˜ toFun : (Î± â†’áµ¤ Î³) â†’ Î± â†’áµ¤ Î²) where
  toIsUniformInducing := UniformFun.postcomp_isUniformInducing hf.isUniformInducing
  injective _ _ H := funext fun _ â†¦ hf.injective (congrFun H _)

/-- If `u` is a uniform structures on `Î²` and `f : Î³ â†’ Î²`, then
`ğ’°(Î±, Î³, comap f u) = comap (fun g â†¦ f âˆ˜ g) ğ’°(Î±, Î³, uâ‚)`. -/
protected theorem comap_eq {f : Î³ â†’ Î²} :
    ğ’°(Î±, Î³, â€¹UniformSpace Î²â€º.comap f) = ğ’°(Î±, Î², _).comap (f âˆ˜ Â·) := by
  letI : UniformSpace Î³ := .comap f â€¹_â€º
  exact (UniformFun.postcomp_isUniformInducing (f := f) âŸ¨rflâŸ©).comap_uniformSpace.symm

/-- Post-composition by a uniformly continuous function is uniformly continuous on `Î± â†’áµ¤ Î²`.

More precisely, if `f : Î³ â†’ Î²` is uniformly continuous, then `(fun g â†¦ f âˆ˜ g) : (Î± â†’áµ¤ Î³) â†’ (Î± â†’áµ¤ Î²)`
is uniformly continuous. -/
protected theorem postcomp_uniformContinuous [UniformSpace Î³] {f : Î³ â†’ Î²}
    (hf : UniformContinuous f) :
    UniformContinuous (ofFun âˆ˜ (f âˆ˜ Â·) âˆ˜ toFun : (Î± â†’áµ¤ Î³) â†’ Î± â†’áµ¤ Î²) := by
  -- This is a direct consequence of `UniformFun.comap_eq`
    refine uniformContinuous_iff.mpr ?_
    exact (UniformFun.mono (uniformContinuous_iff.mp hf)).trans_eq UniformFun.comap_eq
    -- Porting note: the original calc proof below gives a deterministic timeout
    --calc
    --  ğ’°(Î±, Î³, _) â‰¤ ğ’°(Î±, Î³, â€¹UniformSpace Î²â€º.comap f) :=
    --    UniformFun.mono (uniformContinuous_iff.mp hf)
    --  _ = ğ’°(Î±, Î², _).comap (f âˆ˜ Â·) := @UniformFun.comap_eq Î± Î² Î³ _ f

/-- Turn a uniform isomorphism `Î³ â‰ƒáµ¤ Î²` into a uniform isomorphism `(Î± â†’áµ¤ Î³) â‰ƒáµ¤ (Î± â†’áµ¤ Î²)` by
post-composing. -/
protected def congrRight [UniformSpace Î³] (e : Î³ â‰ƒáµ¤ Î²) : (Î± â†’áµ¤ Î³) â‰ƒáµ¤ (Î± â†’áµ¤ Î²) :=
  { Equiv.piCongrRight fun _ => e.toEquiv with
    uniformContinuous_toFun := UniformFun.postcomp_uniformContinuous e.uniformContinuous
    uniformContinuous_invFun := UniformFun.postcomp_uniformContinuous e.symm.uniformContinuous }

/-- Pre-composition by any function is uniformly continuous for the uniform structures of
uniform convergence.

More precisely, for any `f : Î³ â†’ Î±`, the function `(Â· âˆ˜ f) : (Î± â†’áµ¤ Î²) â†’ (Î³ â†’áµ¤ Î²)` is uniformly
continuous. -/
protected theorem precomp_uniformContinuous {f : Î³ â†’ Î±} :
    UniformContinuous fun g : Î± â†’áµ¤ Î² => ofFun (toFun g âˆ˜ f) := by
  -- Here we simply go back to filter bases.
  rw [UniformContinuous,
      (UniformFun.hasBasis_uniformity Î± Î²).tendsto_iff (UniformFun.hasBasis_uniformity Î³ Î²)]
  exact fun U hU => âŸ¨U, hU, fun uv huv x => huv (f x)âŸ©

/-- Turn a bijection `Î³ â‰ƒ Î±` into a uniform isomorphism
`(Î³ â†’áµ¤ Î²) â‰ƒáµ¤ (Î± â†’áµ¤ Î²)` by pre-composing. -/
protected def congrLeft (e : Î³ â‰ƒ Î±) : (Î³ â†’áµ¤ Î²) â‰ƒáµ¤ (Î± â†’áµ¤ Î²) where
  toEquiv := e.arrowCongr (.refl _)
  uniformContinuous_toFun := UniformFun.precomp_uniformContinuous
  uniformContinuous_invFun := UniformFun.precomp_uniformContinuous

/-- The natural map `UniformFun.toFun` from `Î± â†’áµ¤ Î²` to `Î± â†’ Î²` is uniformly continuous.

In other words, the uniform structure of uniform convergence is finer than that of pointwise
convergence, aka the product uniform structure. -/
protected theorem uniformContinuous_toFun : UniformContinuous (toFun : (Î± â†’áµ¤ Î²) â†’ Î± â†’ Î²) := by
  -- By definition of the product uniform structure, this is just `uniform_continuous_eval`.
  rw [uniformContinuous_pi]
  intro x
  exact uniformContinuous_eval Î² x

/-- The topology of uniform convergence is Tâ‚‚. -/
instance [T2Space Î²] : T2Space (Î± â†’áµ¤ Î²) :=
  .of_injective_continuous toFun.injective UniformFun.uniformContinuous_toFun.continuous

/-- The topology of uniform convergence indeed gives the same notion of convergence as
`TendstoUniformly`. -/
protected theorem tendsto_iff_tendstoUniformly {F : Î¹ â†’ Î± â†’áµ¤ Î²} {f : Î± â†’áµ¤ Î²} :
    Tendsto F p (ğ“ f) â†” TendstoUniformly (toFun âˆ˜ F) (toFun f) p := by
  rw [(UniformFun.hasBasis_nhds Î± Î² f).tendsto_right_iff, TendstoUniformly]
  simp only [mem_setOf, UniformFun.gen, Function.comp_def]

/-- The natural bijection between `Î± â†’ Î² Ã— Î³` and `(Î± â†’ Î²) Ã— (Î± â†’ Î³)`, upgraded to a uniform
isomorphism between `Î± â†’áµ¤ Î² Ã— Î³` and `(Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î³)`. -/
protected def uniformEquivProdArrow [UniformSpace Î³] : (Î± â†’áµ¤ Î² Ã— Î³) â‰ƒáµ¤ (Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î³) :=
  -- Denote `Ï†` this bijection. We want to show that
  -- `comap Ï† (ğ’°(Î±, Î², uÎ²) Ã— ğ’°(Î±, Î³, uÎ³)) = ğ’°(Î±, Î² Ã— Î³, uÎ² Ã— uÎ³)`.
  -- But `uÎ² Ã— uÎ³` is defined as `comap fst uÎ² âŠ“ comap snd uÎ³`, so we just have to apply
  -- `UniformFun.inf_eq` and `UniformFun.comap_eq`, which leaves us to check
  -- that some square commutes.
  Equiv.toUniformEquivOfIsUniformInducing (Equiv.arrowProdEquivProdArrow _ _ _) <| by
    constructor
    change
      comap (Prod.map (Equiv.arrowProdEquivProdArrow _ _ _) (Equiv.arrowProdEquivProdArrow _ _ _))
          _ = _
    simp_rw [UniformFun]
    rw [â† uniformity_comap]
    congr
    unfold instUniformSpaceProd
    rw [UniformSpace.comap_inf, â† UniformSpace.comap_comap, â† UniformSpace.comap_comap]
    have := (@UniformFun.inf_eq Î± (Î² Ã— Î³)
      (UniformSpace.comap Prod.fst â€¹_â€º) (UniformSpace.comap Prod.snd â€¹_â€º)).symm
    rwa [UniformFun.comap_eq, UniformFun.comap_eq] at this

-- the relevant diagram commutes by definition
variable (Î±) (Î´ : Î¹ â†’ Type*) [âˆ€ i, UniformSpace (Î´ i)]

/-- The natural bijection between `Î± â†’ Î  i, Î´ i` and `Î  i, Î± â†’ Î´ i`, upgraded to a uniform
isomorphism between `Î± â†’áµ¤ (Î  i, Î´ i)` and `Î  i, Î± â†’áµ¤ Î´ i`. -/
protected def uniformEquivPiComm : UniformEquiv (Î± â†’áµ¤ âˆ€ i, Î´ i) (âˆ€ i, Î± â†’áµ¤ Î´ i) :=
  -- Denote `Ï†` this bijection. We want to show that
    -- `comap Ï† (Î  i, ğ’°(Î±, Î´ i, uÎ´ i)) = ğ’°(Î±, (Î  i, Î´ i), (Î  i, uÎ´ i))`.
    -- But `Î  i, uÎ´ i` is defined as `â¨… i, comap (eval i) (uÎ´ i)`, so we just have to apply
    -- `UniformFun.iInf_eq` and `UniformFun.comap_eq`, which leaves us to check
    -- that some square commutes.
    @Equiv.toUniformEquivOfIsUniformInducing
    _ _ ğ’°(Î±, âˆ€ i, Î´ i, Pi.uniformSpace Î´)
    (@Pi.uniformSpace Î¹ (fun i => Î± â†’ Î´ i) fun i => ğ’°(Î±, Î´ i, _)) (Equiv.piComm _) <| by
      refine @IsUniformInducing.mk ?_ ?_ ?_ ?_ ?_ ?_
      change comap (Prod.map Function.swap Function.swap) _ = _
      rw [â† uniformity_comap]
      congr
      unfold Pi.uniformSpace
      rw [UniformSpace.ofCoreEq_toCore, UniformSpace.ofCoreEq_toCore,
        UniformSpace.comap_iInf, UniformFun.iInf_eq]
      refine iInf_congr fun i => ?_
      rw [â† UniformSpace.comap_comap, UniformFun.comap_eq]
      rfl

-- Like in the previous lemma, the diagram actually commutes by definition

/-- The set of continuous functions is closed in the uniform convergence topology.
This is a simple wrapper over `TendstoUniformly.continuous`. -/
theorem isClosed_setOf_continuous [TopologicalSpace Î±] :
    IsClosed {f : Î± â†’áµ¤ Î² | Continuous (toFun f)} := by
  refine isClosed_iff_forall_filter.2 fun f u _ hu huf â†¦ ?_
  rw [â† tendsto_id', UniformFun.tendsto_iff_tendstoUniformly] at huf
  exact huf.continuous (le_principal_iff.mp hu)

variable {Î±} (Î²) in
theorem uniformSpace_eq_inf_precomp_of_cover {Î´â‚ Î´â‚‚ : Type*} (Ï†â‚ : Î´â‚ â†’ Î±) (Ï†â‚‚ : Î´â‚‚ â†’ Î±)
    (h_cover : range Ï†â‚ âˆª range Ï†â‚‚ = univ) :
    ğ’°(Î±, Î², _) =
      .comap (ofFun âˆ˜ (Â· âˆ˜ Ï†â‚) âˆ˜ toFun) ğ’°(Î´â‚, Î², _) âŠ“
      .comap (ofFun âˆ˜ (Â· âˆ˜ Ï†â‚‚) âˆ˜ toFun) ğ’°(Î´â‚‚, Î², _) := by
  ext : 1
  refine le_antisymm (le_inf ?_ ?_) ?_
  Â· exact tendsto_iff_comap.mp UniformFun.precomp_uniformContinuous
  Â· exact tendsto_iff_comap.mp UniformFun.precomp_uniformContinuous
  Â· refine
      (UniformFun.hasBasis_uniformity Î´â‚ Î² |>.comap _).inf
      (UniformFun.hasBasis_uniformity Î´â‚‚ Î² |>.comap _)
        |>.le_basis_iff (UniformFun.hasBasis_uniformity Î± Î²) |>.mpr fun U hU â†¦
        âŸ¨âŸ¨U, UâŸ©, âŸ¨hU, hUâŸ©, fun âŸ¨f, gâŸ© hfg x â†¦ ?_âŸ©
    rcases h_cover.ge <| mem_univ x with (âŸ¨y, rflâŸ©|âŸ¨y, rflâŸ©)
    Â· exact hfg.1 y
    Â· exact hfg.2 y

variable {Î±} (Î²) in
theorem uniformSpace_eq_iInf_precomp_of_cover {Î´ : Î¹ â†’ Type*} (Ï† : Î  i, Î´ i â†’ Î±)
    (h_cover : âˆƒ I : Set Î¹, I.Finite âˆ§ â‹ƒ i âˆˆ I, range (Ï† i) = univ) :
    ğ’°(Î±, Î², _) = â¨… i, .comap (ofFun âˆ˜ (Â· âˆ˜ Ï† i) âˆ˜ toFun) ğ’°(Î´ i, Î², _) := by
  ext : 1
  simp_rw [iInf_uniformity, uniformity_comap]
  refine le_antisymm (le_iInf fun i â†¦ tendsto_iff_comap.mp UniformFun.precomp_uniformContinuous) ?_
  rcases h_cover with âŸ¨I, I_finite, I_coverâŸ©
  refine HasBasis.iInf (fun i : Î¹ â†¦ UniformFun.hasBasis_uniformity (Î´ i) Î² |>.comap _)
      |>.le_basis_iff (UniformFun.hasBasis_uniformity Î± Î²) |>.mpr fun U hU â†¦
    âŸ¨âŸ¨I, fun _ â†¦ UâŸ©, âŸ¨I_finite, fun _ â†¦ hUâŸ©, fun âŸ¨f, gâŸ© hfg x â†¦ ?_âŸ©
  rcases mem_iUnionâ‚‚.mp <| I_cover.ge <| mem_univ x with âŸ¨i, hi, y, rflâŸ©
  exact mem_iInter.mp hfg âŸ¨i, hiâŸ© y

end UniformFun

namespace UniformOnFun

variable {Î± Î² : Type*} {Î³ Î¹ : Type*}
variable {s : Set Î±} {p : Filter Î¹}

local notation "ğ’°(" Î± ", " Î² ", " u ")" => @UniformFun.uniformSpace Î± Î² u

/-- Basis sets for the uniformity of `ğ”–`-convergence: for `S : Set Î±` and `V : Set (Î² Ã— Î²)`,
`gen ğ”– S V` is the set of pairs `(f, g)` of functions `Î± â†’áµ¤[ğ”–] Î²` such that
`âˆ€ x âˆˆ S, (f x, g x) âˆˆ V`. Note that the family `ğ”– : Set (Set Î±)` is only used to specify which
type alias of `Î± â†’ Î²` to use here. -/
protected def gen (ğ”–) (S : Set Î±) (V : Set (Î² Ã— Î²)) : Set ((Î± â†’áµ¤[ğ”–] Î²) Ã— (Î± â†’áµ¤[ğ”–] Î²)) :=
  { uv : (Î± â†’áµ¤[ğ”–] Î²) Ã— (Î± â†’áµ¤[ğ”–] Î²) | âˆ€ x âˆˆ S, (toFun ğ”– uv.1 x, toFun ğ”– uv.2 x) âˆˆ V }

/-- For `S : Set Î±` and `V : Set (Î² Ã— Î²)`, we have
`UniformOnFun.gen ğ”– S V = (S.restrict Ã— S.restrict) â»Â¹' (UniformFun.gen S Î² V)`.
This is the crucial fact for proving that the family `UniformOnFun.gen S V` for `S âˆˆ ğ”–` and
`V âˆˆ ğ“¤ Î²` is indeed a basis for the uniformity `Î± â†’áµ¤[ğ”–] Î²` endowed with `ğ’±(Î±, Î², ğ”–, uÎ²)`
the uniform structure of `ğ”–`-convergence, as defined in `UniformOnFun.uniformSpace`. -/
protected theorem gen_eq_preimage_restrict {ğ”–} (S : Set Î±) (V : Set (Î² Ã— Î²)) :
    UniformOnFun.gen ğ”– S V =
      Prod.map (S.restrict âˆ˜ UniformFun.toFun) (S.restrict âˆ˜ UniformFun.toFun) â»Â¹'
        UniformFun.gen S Î² V := by
  ext uv
  exact âŸ¨fun h âŸ¨x, hxâŸ© => h x hx, fun h x hx => h âŸ¨x, hxâŸ©âŸ©

/-- `UniformOnFun.gen` is antitone in the first argument and monotone in the second. -/
protected theorem gen_mono {ğ”–} {S S' : Set Î±} {V V' : Set (Î² Ã— Î²)} (hS : S' âŠ† S) (hV : V âŠ† V') :
    UniformOnFun.gen ğ”– S V âŠ† UniformOnFun.gen ğ”– S' V' := fun _uv h x hx => hV (h x <| hS hx)

/-- If `ğ”– : Set (Set Î±)` is nonempty and directed and `ğ“‘` is a filter basis on `Î² Ã— Î²`, then the
family `UniformOnFun.gen ğ”– S V` for `S âˆˆ ğ”–` and `V âˆˆ ğ“‘` is a filter basis on
`(Î± â†’áµ¤[ğ”–] Î²) Ã— (Î± â†’áµ¤[ğ”–] Î²)`.
We will show in `has_basis_uniformity_of_basis` that, if `ğ“‘` is a basis for `ğ“¤ Î²`, then the
corresponding filter is the uniformity of `Î± â†’áµ¤[ğ”–] Î²`. -/
protected theorem isBasis_gen (ğ”– : Set (Set Î±)) (h : ğ”–.Nonempty) (h' : DirectedOn (Â· âŠ† Â·) ğ”–)
    (ğ“‘ : FilterBasis <| Î² Ã— Î²) :
    IsBasis (fun SV : Set Î± Ã— Set (Î² Ã— Î²) => SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ ğ“‘) fun SV =>
      UniformOnFun.gen ğ”– SV.1 SV.2 :=
  âŸ¨h.prod ğ“‘.nonempty, fun {Uâ‚Vâ‚ Uâ‚‚Vâ‚‚} hâ‚ hâ‚‚ =>
    let âŸ¨Uâ‚ƒ, hUâ‚ƒ, hUâ‚â‚ƒ, hUâ‚‚â‚ƒâŸ© := h' Uâ‚Vâ‚.1 hâ‚.1 Uâ‚‚Vâ‚‚.1 hâ‚‚.1
    let âŸ¨Vâ‚ƒ, hVâ‚ƒ, hVâ‚â‚‚â‚ƒâŸ© := ğ“‘.inter_sets hâ‚.2 hâ‚‚.2
    âŸ¨âŸ¨Uâ‚ƒ, Vâ‚ƒâŸ©,
      âŸ¨âŸ¨hUâ‚ƒ, hVâ‚ƒâŸ©, fun _ H =>
        âŸ¨fun x hx => (hVâ‚â‚‚â‚ƒ <| H x <| hUâ‚â‚ƒ hx).1, fun x hx => (hVâ‚â‚‚â‚ƒ <| H x <| hUâ‚‚â‚ƒ hx).2âŸ©âŸ©âŸ©âŸ©

variable (Î± Î²) [UniformSpace Î²] (ğ”– : Set (Set Î±))

/-- Uniform structure of `ğ”–`-convergence, i.e uniform convergence on the elements of `ğ”–`,
declared as an instance on `Î± â†’áµ¤[ğ”–] Î²`. It is defined as the infimum, for `S âˆˆ ğ”–`, of the pullback
by `S.restrict`, the map of restriction to `S`, of the uniform structure `ğ’°(s, Î², uÎ²)` on
`â†¥S â†’áµ¤ Î²`. We will denote it `ğ’±(Î±, Î², ğ”–, uÎ²)`, where `uÎ²` is the uniform structure on `Î²`. -/
instance uniformSpace : UniformSpace (Î± â†’áµ¤[ğ”–] Î²) :=
  â¨… (s : Set Î±) (_ : s âˆˆ ğ”–),
    .comap (UniformFun.ofFun âˆ˜ s.restrict âˆ˜ UniformOnFun.toFun ğ”–) ğ’°(s, Î², _)

local notation "ğ’±(" Î± ", " Î² ", " ğ”– ", " u ")" => @UniformOnFun.uniformSpace Î± Î² u ğ”–

/-- Topology of `ğ”–`-convergence, i.e uniform convergence on the elements of `ğ”–`, declared as an
instance on `Î± â†’áµ¤[ğ”–] Î²`. -/
instance topologicalSpace : TopologicalSpace (Î± â†’áµ¤[ğ”–] Î²) :=
  ğ’±(Î±, Î², ğ”–, _).toTopologicalSpace

/-- The topology of `ğ”–`-convergence is the infimum, for `S âˆˆ ğ”–`, of topology induced by the map
of `S.restrict : (Î± â†’áµ¤[ğ”–] Î²) â†’ (â†¥S â†’áµ¤ Î²)` of restriction to `S`, where `â†¥S â†’áµ¤ Î²` is endowed with
the topology of uniform convergence. -/
protected theorem topologicalSpace_eq :
    UniformOnFun.topologicalSpace Î± Î² ğ”– =
      â¨… (s : Set Î±) (_ : s âˆˆ ğ”–), TopologicalSpace.induced
        (UniformFun.ofFun âˆ˜ s.restrict âˆ˜ toFun ğ”–) (UniformFun.topologicalSpace s Î²) := by
  simp only [UniformOnFun.topologicalSpace, UniformSpace.toTopologicalSpace_iInf]
  rfl

protected theorem hasBasis_uniformity_of_basis_auxâ‚ {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set (Î² Ã— Î²)}
    (hb : HasBasis (ğ“¤ Î²) p s) (S : Set Î±) :
    (@uniformity (Î± â†’áµ¤[ğ”–] Î²) ((UniformFun.uniformSpace S Î²).comap S.restrict)).HasBasis p fun i =>
      UniformOnFun.gen ğ”– S (s i) := by
  simp_rw [UniformOnFun.gen_eq_preimage_restrict, uniformity_comap]
  exact (UniformFun.hasBasis_uniformity_of_basis S Î² hb).comap _

protected theorem hasBasis_uniformity_of_basis_auxâ‚‚ (h : DirectedOn (Â· âŠ† Â·) ğ”–) {p : Î¹ â†’ Prop}
    {s : Î¹ â†’ Set (Î² Ã— Î²)} (hb : HasBasis (ğ“¤ Î²) p s) :
    DirectedOn
      ((fun s : Set Î± => (UniformFun.uniformSpace s Î²).comap (s.restrict : (Î± â†’áµ¤ Î²) â†’ s â†’áµ¤ Î²)) â»Â¹'o
        GE.ge)
      ğ”– :=
  h.mono fun _ _ hst =>
    ((UniformOnFun.hasBasis_uniformity_of_basis_auxâ‚ Î± Î² ğ”– hb _).le_basis_iff
          (UniformOnFun.hasBasis_uniformity_of_basis_auxâ‚ Î± Î² ğ”– hb _)).mpr
      fun V hV => âŸ¨V, hV, UniformOnFun.gen_mono hst subset_rflâŸ©

/-- If `ğ”– : Set (Set Î±)` is nonempty and directed and `ğ“‘` is a filter basis of `ğ“¤ Î²`, then the
uniformity of `Î± â†’áµ¤[ğ”–] Î²` admits the family `{(f, g) | âˆ€ x âˆˆ S, (f x, g x) âˆˆ V}` for `S âˆˆ ğ”–` and
`V âˆˆ ğ“‘` as a filter basis. -/
protected theorem hasBasis_uniformity_of_basis (h : ğ”–.Nonempty) (h' : DirectedOn (Â· âŠ† Â·) ğ”–)
    {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set (Î² Ã— Î²)} (hb : HasBasis (ğ“¤ Î²) p s) :
    (ğ“¤ (Î± â†’áµ¤[ğ”–] Î²)).HasBasis (fun Si : Set Î± Ã— Î¹ => Si.1 âˆˆ ğ”– âˆ§ p Si.2) fun Si =>
      UniformOnFun.gen ğ”– Si.1 (s Si.2) := by
  simp only [iInf_uniformity]
  exact
    hasBasis_biInf_of_directed h (fun S => UniformOnFun.gen ğ”– S âˆ˜ s) _
      (fun S _hS => UniformOnFun.hasBasis_uniformity_of_basis_auxâ‚ Î± Î² ğ”– hb S)
      (UniformOnFun.hasBasis_uniformity_of_basis_auxâ‚‚ Î± Î² ğ”– h' hb)

/-- If `ğ”– : Set (Set Î±)` is nonempty and directed, then the uniformity of `Î± â†’áµ¤[ğ”–] Î²` admits the
family `{(f, g) | âˆ€ x âˆˆ S, (f x, g x) âˆˆ V}` for `S âˆˆ ğ”–` and `V âˆˆ ğ“¤ Î²` as a filter basis. -/
protected theorem hasBasis_uniformity (h : ğ”–.Nonempty) (h' : DirectedOn (Â· âŠ† Â·) ğ”–) :
    (ğ“¤ (Î± â†’áµ¤[ğ”–] Î²)).HasBasis (fun SV : Set Î± Ã— Set (Î² Ã— Î²) => SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ ğ“¤ Î²) fun SV =>
      UniformOnFun.gen ğ”– SV.1 SV.2 :=
  UniformOnFun.hasBasis_uniformity_of_basis Î± Î² ğ”– h h' (ğ“¤ Î²).basis_sets

variable {Î± Î²}

/-- Let `t i` be a nonempty directed subfamily of `ğ”–`
such that every `s âˆˆ ğ”–` is included in some `t i`.
Let `V` bounded by `p` be a basis of entourages of `Î²`.

Then `UniformOnFun.gen ğ”– (t i) (V j)` bounded by `p j` is a basis of entourages of `Î± â†’áµ¤[ğ”–] Î²`. -/
protected theorem hasBasis_uniformity_of_covering_of_basis {Î¹ Î¹' : Type*} [Nonempty Î¹]
    {t : Î¹ â†’ Set Î±} {p : Î¹' â†’ Prop} {V : Î¹' â†’ Set (Î² Ã— Î²)} (ht : âˆ€ i, t i âˆˆ ğ”–)
    (hdir : Directed (Â· âŠ† Â·) t) (hex : âˆ€ s âˆˆ ğ”–, âˆƒ i, s âŠ† t i) (hb : HasBasis (ğ“¤ Î²) p V) :
    (ğ“¤ (Î± â†’áµ¤[ğ”–] Î²)).HasBasis (fun i : Î¹ Ã— Î¹' â†¦ p i.2) fun i â†¦
      UniformOnFun.gen ğ”– (t i.1) (V i.2) := by
  have hne : ğ”–.Nonempty := (range_nonempty t).mono (range_subset_iff.2 ht)
  have hd : DirectedOn (Â· âŠ† Â·) ğ”– := fun sâ‚ hsâ‚ sâ‚‚ hsâ‚‚ â†¦ by
    rcases hex sâ‚ hsâ‚, hex sâ‚‚ hsâ‚‚ with âŸ¨âŸ¨iâ‚, hisâ‚âŸ©, iâ‚‚, hisâ‚‚âŸ©
    rcases hdir iâ‚ iâ‚‚ with âŸ¨i, hiâ‚, hiâ‚‚âŸ©
    exact âŸ¨t i, ht _, hisâ‚.trans hiâ‚, hisâ‚‚.trans hiâ‚‚âŸ©
  refine (UniformOnFun.hasBasis_uniformity_of_basis Î± Î² ğ”– hne hd hb).to_hasBasis
    (fun âŸ¨s, i'âŸ© âŸ¨hs, hi'âŸ© â†¦ ?_) fun âŸ¨i, i'âŸ© hi' â†¦ âŸ¨(t i, i'), âŸ¨ht i, hi'âŸ©, Subset.rflâŸ©
  rcases hex s hs with âŸ¨i, hiâŸ©
  exact âŸ¨(i, i'), hi', UniformOnFun.gen_mono hi Subset.rflâŸ©

/-- If `t n` is a monotone sequence of sets in `ğ”–`
such that each `s âˆˆ ğ”–` is included in some `t n`
and `V n` is an antitone basis of entourages of `Î²`,
then `UniformOnFun.gen ğ”– (t n) (V n)` is an antitone basis of entourages of `Î± â†’áµ¤[ğ”–] Î²`. -/
protected theorem hasAntitoneBasis_uniformity {Î¹ : Type*} [Preorder Î¹] [IsDirected Î¹ (Â· â‰¤ Â·)]
    {t : Î¹ â†’ Set Î±} {V : Î¹ â†’ Set (Î² Ã— Î²)}
    (ht : âˆ€ n, t n âˆˆ ğ”–) (hmono : Monotone t) (hex : âˆ€ s âˆˆ ğ”–, âˆƒ n, s âŠ† t n)
    (hb : HasAntitoneBasis (ğ“¤ Î²) V) :
    (ğ“¤ (Î± â†’áµ¤[ğ”–] Î²)).HasAntitoneBasis fun n â†¦ UniformOnFun.gen ğ”– (t n) (V n) := by
  have := hb.nonempty
  refine âŸ¨(UniformOnFun.hasBasis_uniformity_of_covering_of_basis ğ”–
    ht hmono.directed_le hex hb.1).to_hasBasis ?_ fun i _ â†¦ âŸ¨(i, i), trivial, Subset.rflâŸ©, ?_âŸ©
  Â· rintro âŸ¨k, lâŸ© -
    rcases directed_of (Â· â‰¤ Â·) k l with âŸ¨n, hkn, hlnâŸ©
    exact âŸ¨n, trivial, UniformOnFun.gen_mono (hmono hkn) (hb.2 <| hln)âŸ©
  Â· exact fun k l h â†¦ UniformOnFun.gen_mono (hmono h) (hb.2 h)

protected theorem isCountablyGenerated_uniformity [IsCountablyGenerated (ğ“¤ Î²)] {t : â„• â†’ Set Î±}
    (ht : âˆ€ n, t n âˆˆ ğ”–) (hmono : Monotone t) (hex : âˆ€ s âˆˆ ğ”–, âˆƒ n, s âŠ† t n) :
    IsCountablyGenerated (ğ“¤ (Î± â†’áµ¤[ğ”–] Î²)) :=
  let âŸ¨_V, hVâŸ© := exists_antitone_basis (ğ“¤ Î²)
  (UniformOnFun.hasAntitoneBasis_uniformity ğ”– ht hmono hex hV).isCountablyGenerated

variable (Î± Î²)

/-- For `f : Î± â†’áµ¤[ğ”–] Î²`, where `ğ”– : Set (Set Î±)` is nonempty and directed, `ğ“ f` admits the
family `{g | âˆ€ x âˆˆ S, (f x, g x) âˆˆ V}` for `S âˆˆ ğ”–` and `V âˆˆ ğ“‘` as a filter basis, for any basis
`ğ“‘` of `ğ“¤ Î²`. -/
protected theorem hasBasis_nhds_of_basis (f : Î± â†’áµ¤[ğ”–] Î²) (h : ğ”–.Nonempty)
    (h' : DirectedOn (Â· âŠ† Â·) ğ”–) {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set (Î² Ã— Î²)} (hb : HasBasis (ğ“¤ Î²) p s) :
    (ğ“ f).HasBasis (fun Si : Set Î± Ã— Î¹ => Si.1 âˆˆ ğ”– âˆ§ p Si.2) fun Si =>
      { g | (g, f) âˆˆ UniformOnFun.gen ğ”– Si.1 (s Si.2) } :=
  letI : UniformSpace (Î± â†’ Î²) := UniformOnFun.uniformSpace Î± Î² ğ”–
  nhds_basis_uniformity (UniformOnFun.hasBasis_uniformity_of_basis Î± Î² ğ”– h h' hb)

/-- For `f : Î± â†’áµ¤[ğ”–] Î²`, where `ğ”– : Set (Set Î±)` is nonempty and directed, `ğ“ f` admits the
family `{g | âˆ€ x âˆˆ S, (f x, g x) âˆˆ V}` for `S âˆˆ ğ”–` and `V âˆˆ ğ“¤ Î²` as a filter basis. -/
protected theorem hasBasis_nhds (f : Î± â†’áµ¤[ğ”–] Î²) (h : ğ”–.Nonempty) (h' : DirectedOn (Â· âŠ† Â·) ğ”–) :
    (ğ“ f).HasBasis (fun SV : Set Î± Ã— Set (Î² Ã— Î²) => SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ ğ“¤ Î²) fun SV =>
      { g | (g, f) âˆˆ UniformOnFun.gen ğ”– SV.1 SV.2 } :=
  UniformOnFun.hasBasis_nhds_of_basis Î± Î² ğ”– f h h' (Filter.basis_sets _)

/-- If `S âˆˆ ğ”–`, then the restriction to `S` is a uniformly continuous map from `Î± â†’áµ¤[ğ”–] Î²` to
`â†¥S â†’áµ¤ Î²`. -/
protected theorem uniformContinuous_restrict (h : s âˆˆ ğ”–) :
    UniformContinuous (UniformFun.ofFun âˆ˜ (s.restrict : (Î± â†’ Î²) â†’ s â†’ Î²) âˆ˜ toFun ğ”–) := by
  change _ â‰¤ _
  simp only [UniformOnFun.uniformSpace, map_le_iff_le_comap, iInf_uniformity]
  exact iInfâ‚‚_le s h

variable {Î±}

/-- A version of `UniformOnFun.hasBasis_uniformity_of_basis`
with weaker conclusion and weaker assumptions.

We make no assumptions about the set `ğ”–`
but conclude only that the uniformity is equal to some indexed infimum. -/
protected theorem uniformity_eq_of_basis {Î¹ : Sort*} {p : Î¹ â†’ Prop} {V : Î¹ â†’ Set (Î² Ã— Î²)}
    (h : (ğ“¤ Î²).HasBasis p V) :
    ğ“¤ (Î± â†’áµ¤[ğ”–] Î²) = â¨… s âˆˆ ğ”–, â¨… (i) (_ : p i), ğ“Ÿ (UniformOnFun.gen ğ”– s (V i)) := by
  simp_rw [iInf_uniformity, uniformity_comap,
    (UniformFun.hasBasis_uniformity_of_basis _ _ h).eq_biInf, comap_iInf, comap_principal,
    Function.comp_apply, UniformFun.gen, Subtype.forall, UniformOnFun.gen, preimage_setOf_eq,
    Prod.map_fst, Prod.map_snd, Function.comp_apply, UniformFun.toFun_ofFun, restrict_apply]

protected theorem uniformity_eq : ğ“¤ (Î± â†’áµ¤[ğ”–] Î²) = â¨… s âˆˆ ğ”–, â¨… V âˆˆ ğ“¤ Î², ğ“Ÿ (UniformOnFun.gen ğ”– s V) :=
  UniformOnFun.uniformity_eq_of_basis _ _ (ğ“¤ Î²).basis_sets

protected theorem gen_mem_uniformity (hs : s âˆˆ ğ”–) {V : Set (Î² Ã— Î²)} (hV : V âˆˆ ğ“¤ Î²) :
    UniformOnFun.gen ğ”– s V âˆˆ ğ“¤ (Î± â†’áµ¤[ğ”–] Î²) := by
  rw [UniformOnFun.uniformity_eq]
  apply_rules [mem_iInf_of_mem, mem_principal_self]

/-- A version of `UniformOnFun.hasBasis_nhds_of_basis`
with weaker conclusion and weaker assumptions.

We make no assumptions about the set `ğ”–`
but conclude only that the neighbourhoods filter is equal to some indexed infimum. -/
protected theorem nhds_eq_of_basis {Î¹ : Sort*} {p : Î¹ â†’ Prop} {V : Î¹ â†’ Set (Î² Ã— Î²)}
    (h : (ğ“¤ Î²).HasBasis p V) (f : Î± â†’áµ¤[ğ”–] Î²) :
    ğ“ f = â¨… s âˆˆ ğ”–, â¨… (i) (_ : p i), ğ“Ÿ {g | âˆ€ x âˆˆ s, (toFun ğ”– f x, toFun ğ”– g x) âˆˆ V i} := by
  simp_rw [nhds_eq_comap_uniformity, UniformOnFun.uniformity_eq_of_basis _ _ h, comap_iInf,
    comap_principal, UniformOnFun.gen, preimage_setOf_eq]

protected theorem nhds_eq (f : Î± â†’áµ¤[ğ”–] Î²) :
    ğ“ f = â¨… s âˆˆ ğ”–, â¨… V âˆˆ ğ“¤ Î², ğ“Ÿ {g | âˆ€ x âˆˆ s, (toFun ğ”– f x, toFun ğ”– g x) âˆˆ V} :=
  UniformOnFun.nhds_eq_of_basis _ _ (ğ“¤ Î²).basis_sets f

protected theorem gen_mem_nhds (f : Î± â†’áµ¤[ğ”–] Î²) (hs : s âˆˆ ğ”–) {V : Set (Î² Ã— Î²)} (hV : V âˆˆ ğ“¤ Î²) :
    {g | âˆ€ x âˆˆ s, (toFun ğ”– f x, toFun ğ”– g x) âˆˆ V} âˆˆ ğ“ f := by
  rw [UniformOnFun.nhds_eq]
  apply_rules [mem_iInf_of_mem, mem_principal_self]

theorem uniformContinuous_ofUniformFun :
    UniformContinuous fun f : Î± â†’áµ¤ Î² â†¦ ofFun ğ”– (UniformFun.toFun f) := by
  simp only [UniformContinuous, UniformOnFun.uniformity_eq, tendsto_iInf, tendsto_principal,
    (UniformFun.hasBasis_uniformity _ _).eventually_iff]
  exact fun _ _ U hU â†¦ âŸ¨U, hU, fun f hf x _ â†¦ hf xâŸ©

/-- The uniformity on `Î± â†’áµ¤[ğ”–] Î²` is the same as the uniformity on `Î± â†’áµ¤ Î²`,
provided that `Set.univ âˆˆ ğ”–`.

Here we formulate it as a `UniformEquiv`. -/
def uniformEquivUniformFun (h : univ âˆˆ ğ”–) : (Î± â†’áµ¤[ğ”–] Î²) â‰ƒáµ¤ (Î± â†’áµ¤ Î²) where
  toFun f := UniformFun.ofFun <| toFun _ f
  invFun f := ofFun _ <| UniformFun.toFun f
  uniformContinuous_toFun := by
    simp only [UniformContinuous, (UniformFun.hasBasis_uniformity _ _).tendsto_right_iff]
    intro U hU
    filter_upwards [UniformOnFun.gen_mem_uniformity _ _ h hU] with f hf x using hf x (mem_univ _)
  uniformContinuous_invFun := uniformContinuous_ofUniformFun _ _

/-- Let `uâ‚`, `uâ‚‚` be two uniform structures on `Î³` and `ğ”–â‚ ğ”–â‚‚ : Set (Set Î±)`. If `uâ‚ â‰¤ uâ‚‚` and
`ğ”–â‚‚ âŠ† ğ”–â‚` then `ğ’±(Î±, Î³, ğ”–â‚, uâ‚) â‰¤ ğ’±(Î±, Î³, ğ”–â‚‚, uâ‚‚)`. -/
protected theorem mono â¦ƒuâ‚ uâ‚‚ : UniformSpace Î³â¦„ (hu : uâ‚ â‰¤ uâ‚‚) â¦ƒğ”–â‚ ğ”–â‚‚ : Set (Set Î±)â¦„
    (hğ”– : ğ”–â‚‚ âŠ† ğ”–â‚) : ğ’±(Î±, Î³, ğ”–â‚, uâ‚) â‰¤ ğ’±(Î±, Î³, ğ”–â‚‚, uâ‚‚) :=
  calc
    ğ’±(Î±, Î³, ğ”–â‚, uâ‚) â‰¤ ğ’±(Î±, Î³, ğ”–â‚‚, uâ‚) := iInf_le_iInf_of_subset hğ”–
    _ â‰¤ ğ’±(Î±, Î³, ğ”–â‚‚, uâ‚‚) := iInfâ‚‚_mono fun _i _hi => UniformSpace.comap_mono <| UniformFun.mono hu

/-- If `x : Î±` is in some `S âˆˆ ğ”–`, then evaluation at `x` is uniformly continuous on
`Î± â†’áµ¤[ğ”–] Î²`. -/
theorem uniformContinuous_eval_of_mem {x : Î±} (hxs : x âˆˆ s) (hs : s âˆˆ ğ”–) :
    UniformContinuous ((Function.eval x : (Î± â†’ Î²) â†’ Î²) âˆ˜ toFun ğ”–) :=
  (UniformFun.uniformContinuous_eval Î² (âŸ¨x, hxsâŸ© : s)).comp
    (UniformOnFun.uniformContinuous_restrict Î± Î² ğ”– hs)

theorem uniformContinuous_eval_of_mem_sUnion {x : Î±} (hx : x âˆˆ â‹ƒâ‚€ ğ”–) :
    UniformContinuous ((Function.eval x : (Î± â†’ Î²) â†’ Î²) âˆ˜ toFun ğ”–) :=
  let âŸ¨_s, hs, hxsâŸ© := hx
  uniformContinuous_eval_of_mem _ _ hxs hs

variable {Î²} {ğ”–}

theorem uniformContinuous_eval (h : â‹ƒâ‚€ ğ”– = univ) (x : Î±) :
    UniformContinuous ((Function.eval x : (Î± â†’ Î²) â†’ Î²) âˆ˜ toFun ğ”–) :=
  uniformContinuous_eval_of_mem_sUnion _ _ <| h.symm â–¸ mem_univ _

/-- If `u` is a family of uniform structures on `Î³`, then
`ğ’±(Î±, Î³, ğ”–, (â¨… i, u i)) = â¨… i, ğ’±(Î±, Î³, ğ”–, u i)`. -/
protected theorem iInf_eq {u : Î¹ â†’ UniformSpace Î³} :
    ğ’±(Î±, Î³, ğ”–, â¨… i, u i) = â¨… i, ğ’±(Î±, Î³, ğ”–, u i) := by
  simp_rw [UniformOnFun.uniformSpace, UniformFun.iInf_eq, UniformSpace.comap_iInf]
  rw [iInf_comm]
  exact iInf_congr fun s => iInf_comm

/-- If `uâ‚` and `uâ‚‚` are two uniform structures on `Î³`, then
`ğ’±(Î±, Î³, ğ”–, uâ‚ âŠ“ uâ‚‚) = ğ’±(Î±, Î³, ğ”–, uâ‚) âŠ“ ğ’±(Î±, Î³, ğ”–, uâ‚‚)`. -/
protected theorem inf_eq {uâ‚ uâ‚‚ : UniformSpace Î³} :
    ğ’±(Î±, Î³, ğ”–, uâ‚ âŠ“ uâ‚‚) = ğ’±(Î±, Î³, ğ”–, uâ‚) âŠ“ ğ’±(Î±, Î³, ğ”–, uâ‚‚) := by
  rw [inf_eq_iInf, inf_eq_iInf, UniformOnFun.iInf_eq]
  refine iInf_congr fun i => ?_
  cases i <;> rfl

/-- If `u` is a uniform structure on `Î²` and `f : Î³ â†’ Î²`, then
`ğ’±(Î±, Î³, ğ”–, comap f u) = comap (fun g â†¦ f âˆ˜ g) ğ’±(Î±, Î³, ğ”–, uâ‚)`. -/
protected theorem comap_eq {f : Î³ â†’ Î²} :
    ğ’±(Î±, Î³, ğ”–, â€¹UniformSpace Î²â€º.comap f) = ğ’±(Î±, Î², ğ”–, _).comap (f âˆ˜ Â·) := by
  -- We reduce this to `UniformFun.comap_eq` using the fact that `comap` distributes
  -- on `iInf`.
  simp_rw [UniformOnFun.uniformSpace, UniformSpace.comap_iInf, UniformFun.comap_eq, â†
    UniformSpace.comap_comap]
  -- By definition, `âˆ€ S âˆˆ ğ”–, (f âˆ˜ â€”) âˆ˜ S.restrict = S.restrict âˆ˜ (f âˆ˜ â€”)`.
  rfl

/-- Post-composition by a uniformly continuous function is uniformly continuous for the
uniform structures of `ğ”–`-convergence.

More precisely, if `f : Î³ â†’ Î²` is uniformly continuous, then
`(fun g â†¦ f âˆ˜ g) : (Î± â†’áµ¤[ğ”–] Î³) â†’ (Î± â†’áµ¤[ğ”–] Î²)` is uniformly continuous. -/
protected theorem postcomp_uniformContinuous [UniformSpace Î³] {f : Î³ â†’ Î²}
    (hf : UniformContinuous f) : UniformContinuous (ofFun ğ”– âˆ˜ (f âˆ˜ Â·) âˆ˜ toFun ğ”–) := by
  -- This is a direct consequence of `UniformOnFun.comap_eq`
  rw [uniformContinuous_iff]
  exact (UniformOnFun.mono (uniformContinuous_iff.mp hf) subset_rfl).trans_eq UniformOnFun.comap_eq

/-- Post-composition by a uniform inducing is a uniform inducing for the
uniform structures of `ğ”–`-convergence.

More precisely, if `f : Î³ â†’ Î²` is a uniform inducing, then
`(fun g â†¦ f âˆ˜ g) : (Î± â†’áµ¤[ğ”–] Î³) â†’ (Î± â†’áµ¤[ğ”–] Î²)` is a uniform inducing. -/
lemma postcomp_isUniformInducing [UniformSpace Î³] {f : Î³ â†’ Î²}
    (hf : IsUniformInducing f) : IsUniformInducing (ofFun ğ”– âˆ˜ (f âˆ˜ Â·) âˆ˜ toFun ğ”–) := by
  -- This is a direct consequence of `UniformOnFun.comap_eq`
  constructor
  replace hf : (ğ“¤ Î²).comap (Prod.map f f) = _ := hf.comap_uniformity
  change comap (Prod.map (ofFun ğ”– âˆ˜ (f âˆ˜ Â·) âˆ˜ toFun ğ”–) (ofFun ğ”– âˆ˜ (f âˆ˜ Â·) âˆ˜ toFun ğ”–)) _ = _
  rw [â† uniformity_comap] at hf âŠ¢
  congr
  rw [â† UniformSpace.ext hf, UniformOnFun.comap_eq]
  rfl

/-- Post-composition by a uniform embedding is a uniform embedding for the
uniform structures of `ğ”–`-convergence.

More precisely, if `f : Î³ â†’ Î²` is a uniform embedding, then
`(fun g â†¦ f âˆ˜ g) : (Î± â†’áµ¤[ğ”–] Î³) â†’ (Î± â†’áµ¤[ğ”–] Î²)` is a uniform embedding. -/
protected theorem postcomp_isUniformEmbedding [UniformSpace Î³] {f : Î³ â†’ Î²}
    (hf : IsUniformEmbedding f) : IsUniformEmbedding (ofFun ğ”– âˆ˜ (f âˆ˜ Â·) âˆ˜ toFun ğ”–) where
  toIsUniformInducing := UniformOnFun.postcomp_isUniformInducing hf.isUniformInducing
  injective _ _ H := funext fun _ â†¦ hf.injective (congrFun H _)

/-- Turn a uniform isomorphism `Î³ â‰ƒáµ¤ Î²` into a uniform isomorphism `(Î± â†’áµ¤[ğ”–] Î³) â‰ƒáµ¤ (Î± â†’áµ¤[ğ”–] Î²)`
by post-composing. -/
protected def congrRight [UniformSpace Î³] (e : Î³ â‰ƒáµ¤ Î²) : (Î± â†’áµ¤[ğ”–] Î³) â‰ƒáµ¤ (Î± â†’áµ¤[ğ”–] Î²) :=
  { Equiv.piCongrRight fun _a => e.toEquiv with
    uniformContinuous_toFun := UniformOnFun.postcomp_uniformContinuous e.uniformContinuous
    uniformContinuous_invFun := UniformOnFun.postcomp_uniformContinuous e.symm.uniformContinuous }

/-- Let `f : Î³ â†’ Î±`, `ğ”– : Set (Set Î±)`, `ğ”— : Set (Set Î³)`, and assume that `âˆ€ T âˆˆ ğ”—, f '' T âˆˆ ğ”–`.
Then, the function `(fun g â†¦ g âˆ˜ f) : (Î± â†’áµ¤[ğ”–] Î²) â†’ (Î³ â†’áµ¤[ğ”—] Î²)` is uniformly continuous.

Note that one can easily see that assuming `âˆ€ T âˆˆ ğ”—, âˆƒ S âˆˆ ğ”–, f '' T âŠ† S` would work too, but
we will get this for free when we prove that `ğ’±(Î±, Î², ğ”–, uÎ²) = ğ’±(Î±, Î², ğ”–', uÎ²)` where `ğ”–'` is the
***noncovering*** bornology generated by `ğ”–`. -/
protected theorem precomp_uniformContinuous {ğ”— : Set (Set Î³)} {f : Î³ â†’ Î±}
    (hf : MapsTo (f '' Â·) ğ”— ğ”–) :
    UniformContinuous fun g : Î± â†’áµ¤[ğ”–] Î² => ofFun ğ”— (toFun ğ”– g âˆ˜ f) := by
  -- This follows from the fact that `(Â· âˆ˜ f) Ã— (Â· âˆ˜ f)` maps `gen (f '' t) V` to `gen t V`.
  simp_rw [UniformContinuous, UniformOnFun.uniformity_eq, tendsto_iInf]
  refine fun t ht V hV â†¦ tendsto_iInf' (f '' t) <| tendsto_iInf' (hf ht) <|
    tendsto_iInf' V <| tendsto_iInf' hV ?_
  simpa only [tendsto_principal_principal, UniformOnFun.gen] using fun _ â†¦ forall_mem_image.1

/-- Turn a bijection `e : Î³ â‰ƒ Î±` such that we have both `âˆ€ T âˆˆ ğ”—, e '' T âˆˆ ğ”–` and
`âˆ€ S âˆˆ ğ”–, e â»Â¹' S âˆˆ ğ”—` into a uniform isomorphism `(Î³ â†’áµ¤[ğ”—] Î²) â‰ƒáµ¤ (Î± â†’áµ¤[ğ”–] Î²)` by pre-composing. -/
protected def congrLeft {ğ”— : Set (Set Î³)} (e : Î³ â‰ƒ Î±) (he : ğ”— âŠ† image e â»Â¹' ğ”–)
    (he' : ğ”– âŠ† preimage e â»Â¹' ğ”—) : (Î³ â†’áµ¤[ğ”—] Î²) â‰ƒáµ¤ (Î± â†’áµ¤[ğ”–] Î²) :=
  { Equiv.arrowCongr e (Equiv.refl _) with
    uniformContinuous_toFun := UniformOnFun.precomp_uniformContinuous fun s hs â†¦ by
      change e.symm '' s âˆˆ ğ”—
      rw [â† preimage_equiv_eq_image_symm]
      exact he' hs
    uniformContinuous_invFun := UniformOnFun.precomp_uniformContinuous he }

/-- If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. -/
theorem t2Space_of_covering [T2Space Î²] (h : â‹ƒâ‚€ ğ”– = univ) : T2Space (Î± â†’áµ¤[ğ”–] Î²) where
  t2 f g hfg := by
    obtain âŸ¨x, hxâŸ© := not_forall.mp (mt funext hfg)
    obtain âŸ¨s, hs, hxsâŸ© : âˆƒ s âˆˆ ğ”–, x âˆˆ s := mem_sUnion.mp (h.symm â–¸ True.intro)
    exact separated_by_continuous (uniformContinuous_eval_of_mem Î² ğ”– hxs hs).continuous hx

/-- The restriction map from `Î± â†’áµ¤[ğ”–] Î²` to `â‹ƒâ‚€ ğ”– â†’ Î²` is uniformly continuous. -/
theorem uniformContinuous_restrict_toFun :
    UniformContinuous ((â‹ƒâ‚€ ğ”–).restrict âˆ˜ toFun ğ”– : (Î± â†’áµ¤[ğ”–] Î²) â†’ â‹ƒâ‚€ ğ”– â†’ Î²) := by
  rw [uniformContinuous_pi]
  intro âŸ¨x, hxâŸ©
  obtain âŸ¨s : Set Î±, hs : s âˆˆ ğ”–, hxs : x âˆˆ sâŸ© := mem_sUnion.mpr hx
  exact uniformContinuous_eval_of_mem Î² ğ”– hxs hs

/-- If `ğ”–` covers `Î±`, the natural map `UniformOnFun.toFun` from `Î± â†’áµ¤[ğ”–] Î²` to `Î± â†’ Î²` is
uniformly continuous.

In other words, if `ğ”–` covers `Î±`, then the uniform structure of `ğ”–`-convergence is finer than
that of pointwise convergence. -/
protected theorem uniformContinuous_toFun (h : â‹ƒâ‚€ ğ”– = univ) :
    UniformContinuous (toFun ğ”– : (Î± â†’áµ¤[ğ”–] Î²) â†’ Î± â†’ Î²) := by
  rw [uniformContinuous_pi]
  exact uniformContinuous_eval h

/-- If `f : Î± â†’áµ¤[ğ”–] Î²` is continuous at `x` and `x` admits a neighbourhood `V âˆˆ ğ”–`,
then evaluation of `g : Î± â†’áµ¤[ğ”–] Î²` at `y : Î±` is continuous in `(g, y)` at `(f, x)`. -/
protected theorem continuousAt_evalâ‚‚ [TopologicalSpace Î±] {f : Î± â†’áµ¤[ğ”–] Î²} {x : Î±}
    (hğ”– : âˆƒ V âˆˆ ğ”–, V âˆˆ ğ“ x) (hc : ContinuousAt (toFun ğ”– f) x) :
    ContinuousAt (fun fx : (Î± â†’áµ¤[ğ”–] Î²) Ã— Î± â†¦ toFun ğ”– fx.1 fx.2) (f, x) := by
  rw [ContinuousAt, nhds_eq_comap_uniformity, tendsto_comap_iff, â† lift'_comp_uniformity,
    tendsto_lift']
  intro U hU
  rcases hğ”– with âŸ¨V, hV, hVxâŸ©
  filter_upwards [prod_mem_nhds (UniformOnFun.gen_mem_nhds _ _ _ hV hU)
    (inter_mem hVx <| hc <| UniformSpace.ball_mem_nhds _ hU)]
    with âŸ¨g, yâŸ© âŸ¨hg, hyV, hyâŸ© using âŸ¨toFun ğ”– f y, hy, hg y hyVâŸ©

/-- If each point of `Î±` admits a neighbourhood `V âˆˆ ğ”–`,
then the evaluation of `f : Î± â†’áµ¤[ğ”–] Î²` at `x : Î±` is continuous in `(f, x)`
on the set of `(f, x)` such that `f` is continuous at `x`. -/
protected theorem continuousOn_evalâ‚‚ [TopologicalSpace Î±] (hğ”– : âˆ€ x, âˆƒ V âˆˆ ğ”–, V âˆˆ ğ“ x) :
    ContinuousOn (fun fx : (Î± â†’áµ¤[ğ”–] Î²) Ã— Î± â†¦ toFun ğ”– fx.1 fx.2)
      {fx | ContinuousAt (toFun ğ”– fx.1) fx.2} := fun (_f, x) hc â†¦
  (UniformOnFun.continuousAt_evalâ‚‚ (hğ”– x) hc).continuousWithinAt

/-- Convergence in the topology of `ğ”–`-convergence means uniform convergence on `S` (in the sense
of `TendstoUniformlyOn`) for all `S âˆˆ ğ”–`. -/
protected theorem tendsto_iff_tendstoUniformlyOn {F : Î¹ â†’ Î± â†’áµ¤[ğ”–] Î²} {f : Î± â†’áµ¤[ğ”–] Î²} :
    Tendsto F p (ğ“ f) â†” âˆ€ s âˆˆ ğ”–, TendstoUniformlyOn (toFun ğ”– âˆ˜ F) (toFun ğ”– f) p s := by
  simp only [UniformOnFun.nhds_eq, tendsto_iInf, tendsto_principal, TendstoUniformlyOn,
    Function.comp_apply, mem_setOf]

protected lemma continuous_rng_iff {X : Type*} [TopologicalSpace X] {f : X â†’ (Î± â†’áµ¤[ğ”–] Î²)} :
    Continuous f â†” âˆ€ s âˆˆ ğ”–,
      Continuous (UniformFun.ofFun âˆ˜ s.restrict âˆ˜ UniformOnFun.toFun ğ”– âˆ˜ f) := by
  simp only [continuous_iff_continuousAt, ContinuousAt,
    UniformOnFun.tendsto_iff_tendstoUniformlyOn, UniformFun.tendsto_iff_tendstoUniformly,
    tendstoUniformlyOn_iff_tendstoUniformly_comp_coe, @forall_swap X, Function.comp_apply,
    Function.comp_def, restrict_eq, UniformFun.toFun_ofFun]

instance [CompleteSpace Î²] : CompleteSpace (Î± â†’áµ¤[ğ”–] Î²) := by
  rcases isEmpty_or_nonempty Î²
  Â· infer_instance
  Â· refine âŸ¨fun {F} hF â†¦ ?_âŸ©
    have := hF.1
    have : âˆ€ x âˆˆ â‹ƒâ‚€ ğ”–, âˆƒ y : Î², Tendsto (toFun ğ”– Â· x) F (ğ“ y) := fun x hx â†¦
      CompleteSpace.complete (hF.map (uniformContinuous_eval_of_mem_sUnion _ _ hx))
    choose! g hg using this
    use ofFun ğ”– g
    simp_rw [UniformOnFun.nhds_eq_of_basis _ _ uniformity_hasBasis_closed, le_iInfâ‚‚_iff,
      le_principal_iff]
    intro s hs U âŸ¨hU, hUcâŸ©
    rcases cauchy_iff.mp hF |>.2 _ <| UniformOnFun.gen_mem_uniformity _ _ hs hU
      with âŸ¨V, hV, hVUâŸ©
    filter_upwards [hV] with f hf x hx
    refine hUc.mem_of_tendsto ((hg x âŸ¨s, hs, hxâŸ©).prodMk_nhds tendsto_const_nhds) ?_
    filter_upwards [hV] with g' hg' using hVU (mk_mem_prod hg' hf) _ hx

/-- The natural bijection between `Î± â†’ Î² Ã— Î³` and `(Î± â†’ Î²) Ã— (Î± â†’ Î³)`, upgraded to a uniform
isomorphism between `Î± â†’áµ¤[ğ”–] Î² Ã— Î³` and `(Î± â†’áµ¤[ğ”–] Î²) Ã— (Î± â†’áµ¤[ğ”–] Î³)`. -/
protected def uniformEquivProdArrow [UniformSpace Î³] :
    (Î± â†’áµ¤[ğ”–] Î² Ã— Î³) â‰ƒáµ¤ (Î± â†’áµ¤[ğ”–] Î²) Ã— (Î± â†’áµ¤[ğ”–] Î³) :=
  -- Denote `Ï†` this bijection. We want to show that
  -- `comap Ï† (ğ’±(Î±, Î², ğ”–, uÎ²) Ã— ğ’±(Î±, Î³, ğ”–, uÎ³)) = ğ’±(Î±, Î² Ã— Î³, ğ”–, uÎ² Ã— uÎ³)`.
  -- But `uÎ² Ã— uÎ³` is defined as `comap fst uÎ² âŠ“ comap snd uÎ³`, so we just have to apply
  -- `UniformOnFun.inf_eq` and `UniformOnFun.comap_eq`,
  -- which leaves us to check that some square commutes.
  -- We could also deduce this from `UniformFun.uniformEquivProdArrow`,
  -- but it turns out to be more annoying.
  ((UniformOnFun.ofFun ğ”–).symm.trans <| (Equiv.arrowProdEquivProdArrow _ _ _).trans <|
    (UniformOnFun.ofFun ğ”–).prodCongr (UniformOnFun.ofFun ğ”–)).toUniformEquivOfIsUniformInducing <| by
      constructor
      rw [uniformity_prod, comap_inf, comap_comap, comap_comap]
      have H := @UniformOnFun.inf_eq Î± (Î² Ã— Î³) ğ”–
        (UniformSpace.comap Prod.fst â€¹_â€º) (UniformSpace.comap Prod.snd â€¹_â€º)
      apply_fun (fun u â†¦ @uniformity (Î± â†’áµ¤[ğ”–] Î² Ã— Î³) u) at H
      convert H.symm using 1
      rw [UniformOnFun.comap_eq, UniformOnFun.comap_eq]
      erw [inf_uniformity]
      rw [uniformity_comap, uniformity_comap]
      rfl
-- the relevant diagram commutes by definition

variable (ğ”–) (Î´ : Î¹ â†’ Type*) [âˆ€ i, UniformSpace (Î´ i)] in
/-- The natural bijection between `Î± â†’ Î  i, Î´ i` and `Î  i, Î± â†’ Î´ i`, upgraded to a uniform
isomorphism between `Î± â†’áµ¤[ğ”–] (Î  i, Î´ i)` and `Î  i, Î± â†’áµ¤[ğ”–] Î´ i`. -/
protected def uniformEquivPiComm : (Î± â†’áµ¤[ğ”–] ((i : Î¹) â†’ Î´ i)) â‰ƒáµ¤ ((i : Î¹) â†’ Î± â†’áµ¤[ğ”–] Î´ i) :=
  -- Denote `Ï†` this bijection. We want to show that
  -- `comap Ï† (Î  i, ğ’±(Î±, Î´ i, ğ”–, uÎ´ i)) = ğ’±(Î±, (Î  i, Î´ i), ğ”–, (Î  i, uÎ´ i))`.
  -- But `Î  i, uÎ´ i` is defined as `â¨… i, comap (eval i) (uÎ´ i)`, so we just have to apply
  -- `UniformOnFun.iInf_eq` and `UniformOnFun.comap_eq`,
  -- which leaves us to check that some square commutes.
  -- We could also deduce this from `UniformFun.uniformEquivPiComm`, but it turns out
  -- to be more annoying.
  @Equiv.toUniformEquivOfIsUniformInducing (Î± â†’áµ¤[ğ”–] ((i : Î¹) â†’ Î´ i)) ((i : Î¹) â†’ Î± â†’áµ¤[ğ”–] Î´ i)
      _ _ (Equiv.piComm _) <| by
    constructor
    change comap (Prod.map Function.swap Function.swap) _ = _
    erw [â† uniformity_comap]
    congr
    rw [Pi.uniformSpace, UniformSpace.ofCoreEq_toCore, Pi.uniformSpace,
      UniformSpace.ofCoreEq_toCore, UniformSpace.comap_iInf, UniformOnFun.iInf_eq]
    refine iInf_congr fun i => ?_
    rw [â† UniformSpace.comap_comap, UniformOnFun.comap_eq]
    rfl
-- Like in the previous lemma, the diagram actually commutes by definition

/-- Suppose that the topology on `Î±` is defined by its restrictions to the sets of `ğ”–`.

Then the set of continuous functions is closed
in the topology of uniform convergence on the sets of `ğ”–`. -/
theorem isClosed_setOf_continuous [TopologicalSpace Î±] (h : IsCoherentWith ğ”–) :
    IsClosed {f : Î± â†’áµ¤[ğ”–] Î² | Continuous (toFun ğ”– f)} := by
  refine isClosed_iff_forall_filter.2 fun f u _ hu huf â†¦ h.continuous_iff.2 fun s hs â†¦ ?_
  rw [â† tendsto_id', UniformOnFun.tendsto_iff_tendstoUniformlyOn] at huf
  exact (huf s hs).continuousOn <| hu fun _ â†¦ Continuous.continuousOn

variable (ğ”–) in
theorem uniformSpace_eq_inf_precomp_of_cover {Î´â‚ Î´â‚‚ : Type*} (Ï†â‚ : Î´â‚ â†’ Î±) (Ï†â‚‚ : Î´â‚‚ â†’ Î±)
    (ğ”—â‚ : Set (Set Î´â‚)) (ğ”—â‚‚ : Set (Set Î´â‚‚))
    (h_imageâ‚ : MapsTo (Ï†â‚ '' Â·) ğ”—â‚ ğ”–) (h_imageâ‚‚ : MapsTo (Ï†â‚‚ '' Â·) ğ”—â‚‚ ğ”–)
    (h_preimageâ‚ : MapsTo (Ï†â‚ â»Â¹' Â·) ğ”– ğ”—â‚) (h_preimageâ‚‚ : MapsTo (Ï†â‚‚ â»Â¹' Â·) ğ”– ğ”—â‚‚)
    (h_cover : âˆ€ S âˆˆ ğ”–, S âŠ† range Ï†â‚ âˆª range Ï†â‚‚) :
    ğ’±(Î±, Î², ğ”–, _) =
      .comap (ofFun ğ”—â‚ âˆ˜ (Â· âˆ˜ Ï†â‚) âˆ˜ toFun ğ”–) ğ’±(Î´â‚, Î², ğ”—â‚, _) âŠ“
      .comap (ofFun ğ”—â‚‚ âˆ˜ (Â· âˆ˜ Ï†â‚‚) âˆ˜ toFun ğ”–) ğ’±(Î´â‚‚, Î², ğ”—â‚‚, _) := by
  set Ïˆâ‚ : Î  S : Set Î±, Ï†â‚ â»Â¹' S â†’ S := fun S â†¦ S.restrictPreimage Ï†â‚
  set Ïˆâ‚‚ : Î  S : Set Î±, Ï†â‚‚ â»Â¹' S â†’ S := fun S â†¦ S.restrictPreimage Ï†â‚‚
  have : âˆ€ S âˆˆ ğ”–, ğ’°(S, Î², _) = .comap (Â· âˆ˜ Ïˆâ‚ S) ğ’°(_, Î², _) âŠ“ .comap (Â· âˆ˜ Ïˆâ‚‚ S) ğ’°(_, Î², _) := by
    refine fun S hS â†¦ UniformFun.uniformSpace_eq_inf_precomp_of_cover Î² _ _ ?_
    simpa only [â† univ_subset_iff, Ïˆâ‚, Ïˆâ‚‚, range_restrictPreimage, â† preimage_union,
      â† image_subset_iff, image_univ, Subtype.range_val] using h_cover S hS
  refine le_antisymm (le_inf ?_ ?_) (le_iInfâ‚‚ fun S hS â†¦ ?_)
  Â· rw [â† uniformContinuous_iff]
    exact UniformOnFun.precomp_uniformContinuous h_imageâ‚
  Â· rw [â† uniformContinuous_iff]
    exact UniformOnFun.precomp_uniformContinuous h_imageâ‚‚
  Â· simp_rw [this S hS, uniformSpace, UniformSpace.comap_iInf, UniformSpace.comap_inf,
      â† UniformSpace.comap_comap]
    exact inf_le_inf
      (iInfâ‚‚_le_of_le _ (h_preimageâ‚ hS) le_rfl)
      (iInfâ‚‚_le_of_le _ (h_preimageâ‚‚ hS) le_rfl)

variable (ğ”–) in
theorem uniformSpace_eq_iInf_precomp_of_cover {Î´ : Î¹ â†’ Type*} (Ï† : Î  i, Î´ i â†’ Î±)
    (ğ”— : âˆ€ i, Set (Set (Î´ i))) (h_image : âˆ€ i, MapsTo (Ï† i '' Â·) (ğ”— i) ğ”–)
    (h_preimage : âˆ€ i, MapsTo (Ï† i â»Â¹' Â·) ğ”– (ğ”— i))
    (h_cover : âˆ€ S âˆˆ ğ”–, âˆƒ I : Set Î¹, I.Finite âˆ§ S âŠ† â‹ƒ i âˆˆ I, range (Ï† i)) :
    ğ’±(Î±, Î², ğ”–, _) = â¨… i, .comap (ofFun (ğ”— i) âˆ˜ (Â· âˆ˜ Ï† i) âˆ˜ toFun ğ”–) ğ’±(Î´ i, Î², ğ”— i, _) := by
  set Ïˆ : Î  S : Set Î±, Î  i : Î¹, (Ï† i) â»Â¹' S â†’ S := fun S i â†¦ S.restrictPreimage (Ï† i)
  have : âˆ€ S âˆˆ ğ”–, ğ’°(S, Î², _) = â¨… i, .comap (Â· âˆ˜ Ïˆ S i) ğ’°(_, Î², _) := fun S hS â†¦ by
    rcases h_cover S hS with âŸ¨I, I_finite, I_coverâŸ©
    refine UniformFun.uniformSpace_eq_iInf_precomp_of_cover Î² _ âŸ¨I, I_finite, ?_âŸ©
    simpa only [â† univ_subset_iff, Ïˆ, range_restrictPreimage, â† preimage_iUnionâ‚‚,
      â† image_subset_iff, image_univ, Subtype.range_val] using I_cover
  -- With a better theory of ideals we may be able to simplify the following by replacing `ğ”— i`
  -- by `(Ï† i â»Â¹' Â·) '' ğ”–`.
  refine le_antisymm (le_iInf fun i â†¦ ?_) (le_iInfâ‚‚ fun S hS â†¦ ?_)
  Â· rw [â† uniformContinuous_iff]
    exact UniformOnFun.precomp_uniformContinuous (h_image i)
  Â· simp_rw [this S hS, uniformSpace, UniformSpace.comap_iInf, â† UniformSpace.comap_comap]
    exact iInf_mono fun i â†¦ iInfâ‚‚_le_of_le _ (h_preimage i hS) le_rfl

end UniformOnFun

namespace UniformFun

instance {Î± Î² : Type*} [UniformSpace Î²] [CompleteSpace Î²] : CompleteSpace (Î± â†’áµ¤ Î²) :=
  (UniformOnFun.uniformEquivUniformFun Î² {univ} (mem_singleton _)).completeSpace_iff.1 inferInstance

end UniformFun

section UniformComposition

variable {Î± Î² Î³ Î¹ : Type*} [UniformSpace Î²] [UniformSpace Î³] {p : Filter Î¹} {s : Set Î²}
  {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {g : Î² â†’ Î³}

/-- Composing on the left by a uniformly continuous function preserves uniform convergence -/
theorem UniformContinuousOn.comp_tendstoUniformly
    (hF : âˆ€ i x, F i x âˆˆ s) (hf : âˆ€ x, f x âˆˆ s) (hg : UniformContinuousOn g s)
    (h : TendstoUniformly F f p) :
    TendstoUniformly (fun i x => g (F i x)) (fun x => g (f x)) p := by
  rw [uniformContinuousOn_iff_restrict] at hg
  lift F to Î¹ â†’ Î± â†’ s using hF with F' hF'
  lift f to Î± â†’ s using hf with f' hf'
  rw [tendstoUniformly_iff_tendsto] at h
  have : Tendsto (fun q â†¦ (f' q.2, F' q.1 q.2)) (p Ã—Ë¢ âŠ¤) (ğ“¤ s) :=
    h.of_tendsto_comp isUniformEmbedding_subtype_val.comap_uniformity.le
  apply UniformContinuous.comp_tendstoUniformly hg ?_
  rwa [â† tendstoUniformly_iff_tendsto] at this

theorem UniformContinuousOn.comp_tendstoUniformly_eventually
    (hF : âˆ€á¶  i in p, âˆ€ x, F i x âˆˆ s) (hf : âˆ€ x, f x âˆˆ s) (hg : UniformContinuousOn g s)
    (h : TendstoUniformly F f p) :
    TendstoUniformly (fun i x â†¦ g (F i x)) (fun x â†¦ g (f x)) p := by
  classical
  obtain âŸ¨s', hs', hsâŸ© := eventually_iff_exists_mem.mp hF
  let F' : Î¹ â†’ Î± â†’ Î² := fun i x => if i âˆˆ s' then F i x else f x
  have hF : F =á¶ [p] F' :=  by
    rw [eventuallyEq_iff_exists_mem]
    refine âŸ¨s', hs', fun y hy => by aesopâŸ©
  have h' : TendstoUniformly F' f p := by
    rwa [tendstoUniformly_congr hF] at h
  apply (tendstoUniformly_congr _).mpr
    (UniformContinuousOn.comp_tendstoUniformly (by aesop) hf hg h')
  rw [eventuallyEq_iff_exists_mem]
  refine âŸ¨s', hs', fun i hi => by aesopâŸ©

theorem UniformContinuousOn.comp_tendstoUniformlyOn_eventually {t : Set Î±}
    (hF : âˆ€á¶  i in p, âˆ€ x âˆˆ t, F i x âˆˆ s) (hf : âˆ€ x âˆˆ t, f x âˆˆ s)
    {g : Î² â†’ Î³} (hg : UniformContinuousOn g s) (h : TendstoUniformlyOn F f p t) :
    TendstoUniformlyOn (fun i x â†¦ g (F i x)) (fun x => g (f x)) p t := by
  rw [tendstoUniformlyOn_iff_restrict]
  apply UniformContinuousOn.comp_tendstoUniformly_eventually (by simpa using hF )
     (by simpa using hf) hg (tendstoUniformlyOn_iff_restrict.mp h)

end UniformComposition
