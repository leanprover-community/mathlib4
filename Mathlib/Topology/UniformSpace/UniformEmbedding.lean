/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, S√©bastien Gou√´zel, Patrick Massot
-/
import Mathlib.Topology.UniformSpace.Cauchy
import Mathlib.Topology.UniformSpace.Separation
import Mathlib.Topology.DenseEmbedding

#align_import topology.uniform_space.uniform_embedding from "leanprover-community/mathlib"@"195fcd60ff2bfe392543bceb0ec2adcdb472db4c"

/-!
# Uniform embeddings of uniform spaces.

Extension of uniform continuous functions.
-/


open Filter Function Set Uniformity Topology

section

universe u v w
variable {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [UniformSpace Œ±] [UniformSpace Œ≤] [UniformSpace Œ≥]

/-!
### Uniform inducing maps
-/

/-- A map `f : Œ± ‚Üí Œ≤` between uniform spaces is called *uniform inducing* if the uniformity filter
on `Œ±` is the pullback of the uniformity filter on `Œ≤` under `Prod.map f f`. If `Œ±` is a separated
space, then this implies that `f` is injective, hence it is a `UniformEmbedding`. -/
@[mk_iff uniformInducing_iff]
structure UniformInducing (f : Œ± ‚Üí Œ≤) : Prop where
  /-- The uniformity filter on the domain is the pullback of the uniformity filter on the codomain
  under `Prod.map f f`. -/
  comap_uniformity : comap (fun x : Œ± √ó Œ± => (f x.1, f x.2)) (ùì§ Œ≤) = ùì§ Œ±
#align uniform_inducing UniformInducing
#align uniform_inducing_iff uniformInducing_iff

protected lemma UniformInducing.comap_uniformSpace {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) :
    ‚ÄπUniformSpace Œ≤‚Ä∫.comap f = ‚ÄπUniformSpace Œ±‚Ä∫ :=
  UniformSpace.ext hf.1
#align uniform_inducing.comap_uniform_space UniformInducing.comap_uniformSpace

lemma uniformInducing_iff' {f : Œ± ‚Üí Œ≤} :
    UniformInducing f ‚Üî UniformContinuous f ‚àß comap (Prod.map f f) (ùì§ Œ≤) ‚â§ ùì§ Œ± := by
  rw [uniformInducing_iff, UniformContinuous, tendsto_iff_comap, le_antisymm_iff, and_comm]; rfl
#align uniform_inducing_iff' uniformInducing_iff'

protected lemma Filter.HasBasis.uniformInducing_iff {Œπ Œπ'} {p : Œπ ‚Üí Prop} {p' : Œπ' ‚Üí Prop} {s s'}
    (h : (ùì§ Œ±).HasBasis p s) (h' : (ùì§ Œ≤).HasBasis p' s') {f : Œ± ‚Üí Œ≤} :
    UniformInducing f ‚Üî
      (‚àÄ i, p' i ‚Üí ‚àÉ j, p j ‚àß ‚àÄ x y, (x, y) ‚àà s j ‚Üí (f x, f y) ‚àà s' i) ‚àß
        (‚àÄ j, p j ‚Üí ‚àÉ i, p' i ‚àß ‚àÄ x y, (f x, f y) ‚àà s' i ‚Üí (x, y) ‚àà s j) := by
  simp [uniformInducing_iff', h.uniformContinuous_iff h', (h'.comap _).le_basis_iff h, subset_def]
#align filter.has_basis.uniform_inducing_iff Filter.HasBasis.uniformInducing_iff

theorem UniformInducing.mk' {f : Œ± ‚Üí Œ≤}
    (h : ‚àÄ s, s ‚àà ùì§ Œ± ‚Üî ‚àÉ t ‚àà ùì§ Œ≤, ‚àÄ x y : Œ±, (f x, f y) ‚àà t ‚Üí (x, y) ‚àà s) : UniformInducing f :=
  ‚ü®by simp [eq_comm, Filter.ext_iff, subset_def, h]‚ü©
#align uniform_inducing.mk' UniformInducing.mk'

theorem uniformInducing_id : UniformInducing (@id Œ±) :=
  ‚ü®by rw [‚Üê Prod.map_def, Prod.map_id, comap_id]‚ü©
#align uniform_inducing_id uniformInducing_id

theorem UniformInducing.comp {g : Œ≤ ‚Üí Œ≥} (hg : UniformInducing g) {f : Œ± ‚Üí Œ≤}
    (hf : UniformInducing f) : UniformInducing (g ‚àò f) :=
  ‚ü®by rw [‚Üê hf.1, ‚Üê hg.1, comap_comap]; rfl‚ü©
#align uniform_inducing.comp UniformInducing.comp

theorem UniformInducing.basis_uniformity {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {Œπ : Sort*}
    {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set (Œ≤ √ó Œ≤)} (H : (ùì§ Œ≤).HasBasis p s) :
    (ùì§ Œ±).HasBasis p fun i => Prod.map f f ‚Åª¬π' s i :=
  hf.1 ‚ñ∏ H.comap _
#align uniform_inducing.basis_uniformity UniformInducing.basis_uniformity

theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  simp only [Cauchy, map_neBot_iff, prod_map_map_eq, map_le_iff_le_comap, ‚Üê hf.comap_uniformity]
#align uniform_inducing.cauchy_map_iff UniformInducing.cauchy_map_iff

theorem uniformInducing_of_compose {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} (hf : UniformContinuous f)
    (hg : UniformContinuous g) (hgf : UniformInducing (g ‚àò f)) : UniformInducing f := by
  refine' ‚ü®le_antisymm _ hf.le_comap‚ü©
  rw [‚Üê hgf.1, ‚Üê Prod.map_def, ‚Üê Prod.map_def, ‚Üê Prod.map_comp_map f f g g, ‚Üê comap_comap]
  exact comap_mono hg.le_comap
#align uniform_inducing_of_compose uniformInducing_of_compose

theorem UniformInducing.uniformContinuous {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) :
    UniformContinuous f := (uniformInducing_iff'.1 hf).1
#align uniform_inducing.uniform_continuous UniformInducing.uniformContinuous

theorem UniformInducing.uniformContinuous_iff {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} (hg : UniformInducing g) :
    UniformContinuous f ‚Üî UniformContinuous (g ‚àò f) := by
  dsimp only [UniformContinuous, Tendsto]
  rw [‚Üê hg.comap_uniformity, ‚Üê map_le_iff_le_comap, Filter.map_map]; rfl
#align uniform_inducing.uniform_continuous_iff UniformInducing.uniformContinuous_iff

theorem UniformInducing.inducing {f : Œ± ‚Üí Œ≤} (h : UniformInducing f) : Inducing f := by
  obtain rfl := h.comap_uniformSpace
  exact inducing_induced f
#align uniform_inducing.inducing UniformInducing.inducing

theorem UniformInducing.prod {Œ±' : Type*} {Œ≤' : Type*} [UniformSpace Œ±'] [UniformSpace Œ≤']
    {e‚ÇÅ : Œ± ‚Üí Œ±'} {e‚ÇÇ : Œ≤ ‚Üí Œ≤'} (h‚ÇÅ : UniformInducing e‚ÇÅ) (h‚ÇÇ : UniformInducing e‚ÇÇ) :
    UniformInducing fun p : Œ± √ó Œ≤ => (e‚ÇÅ p.1, e‚ÇÇ p.2) :=
  ‚ü®by simp [(¬∑ ‚àò ¬∑), uniformity_prod, ‚Üê h‚ÇÅ.1, ‚Üê h‚ÇÇ.1, comap_inf, comap_comap]‚ü©
#align uniform_inducing.prod UniformInducing.prod

theorem UniformInducing.denseInducing {f : Œ± ‚Üí Œ≤} (h : UniformInducing f) (hd : DenseRange f) :
    DenseInducing f :=
  { dense := hd
    induced := h.inducing.induced }
#align uniform_inducing.dense_inducing UniformInducing.denseInducing

protected theorem UniformInducing.injective [T0Space Œ±] {f : Œ± ‚Üí Œ≤} (h : UniformInducing f) :
    Injective f :=
  h.inducing.injective

/-!
### Uniform embeddings
-/

/-- A map `f : Œ± ‚Üí Œ≤` between uniform spaces is a *uniform embedding* if it is uniform inducing and
injective. If `Œ±` is a separated space, then the latter assumption follows from the former. -/
@[mk_iff uniformEmbedding_iff]
structure UniformEmbedding (f : Œ± ‚Üí Œ≤) extends UniformInducing f : Prop where
  /-- A uniform embedding is injective. -/
  inj : Function.Injective f
#align uniform_embedding UniformEmbedding
#align uniform_embedding_iff uniformEmbedding_iff

theorem uniformEmbedding_iff' {f : Œ± ‚Üí Œ≤} :
    UniformEmbedding f ‚Üî Injective f ‚àß UniformContinuous f ‚àß comap (Prod.map f f) (ùì§ Œ≤) ‚â§ ùì§ Œ± := by
  rw [uniformEmbedding_iff, and_comm, uniformInducing_iff']
#align uniform_embedding_iff' uniformEmbedding_iff'

theorem Filter.HasBasis.uniformEmbedding_iff' {Œπ Œπ'} {p : Œπ ‚Üí Prop} {p' : Œπ' ‚Üí Prop} {s s'}
    (h : (ùì§ Œ±).HasBasis p s) (h' : (ùì§ Œ≤).HasBasis p' s') {f : Œ± ‚Üí Œ≤} :
    UniformEmbedding f ‚Üî Injective f ‚àß
      (‚àÄ i, p' i ‚Üí ‚àÉ j, p j ‚àß ‚àÄ x y, (x, y) ‚àà s j ‚Üí (f x, f y) ‚àà s' i) ‚àß
        (‚àÄ j, p j ‚Üí ‚àÉ i, p' i ‚àß ‚àÄ x y, (f x, f y) ‚àà s' i ‚Üí (x, y) ‚àà s j) := by
  rw [uniformEmbedding_iff, and_comm, h.uniformInducing_iff h']
#align filter.has_basis.uniform_embedding_iff' Filter.HasBasis.uniformEmbedding_iff'

theorem Filter.HasBasis.uniformEmbedding_iff {Œπ Œπ'} {p : Œπ ‚Üí Prop} {p' : Œπ' ‚Üí Prop} {s s'}
    (h : (ùì§ Œ±).HasBasis p s) (h' : (ùì§ Œ≤).HasBasis p' s') {f : Œ± ‚Üí Œ≤} :
    UniformEmbedding f ‚Üî Injective f ‚àß UniformContinuous f ‚àß
      (‚àÄ j, p j ‚Üí ‚àÉ i, p' i ‚àß ‚àÄ x y, (f x, f y) ‚àà s' i ‚Üí (x, y) ‚àà s j) := by
  simp only [h.uniformEmbedding_iff' h', h.uniformContinuous_iff h']
#align filter.has_basis.uniform_embedding_iff Filter.HasBasis.uniformEmbedding_iff

theorem uniformEmbedding_subtype_val {p : Œ± ‚Üí Prop} :
    UniformEmbedding (Subtype.val : Subtype p ‚Üí Œ±) :=
  { comap_uniformity := rfl
    inj := Subtype.val_injective }
#align uniform_embedding_subtype_val uniformEmbedding_subtype_val
#align uniform_embedding_subtype_coe uniformEmbedding_subtype_val

theorem uniformEmbedding_set_inclusion {s t : Set Œ±} (hst : s ‚äÜ t) :
    UniformEmbedding (inclusion hst) where
  comap_uniformity := by rw [uniformity_subtype, uniformity_subtype, comap_comap]; rfl
  inj := inclusion_injective hst
#align uniform_embedding_set_inclusion uniformEmbedding_set_inclusion

theorem UniformEmbedding.comp {g : Œ≤ ‚Üí Œ≥} (hg : UniformEmbedding g) {f : Œ± ‚Üí Œ≤}
    (hf : UniformEmbedding f) : UniformEmbedding (g ‚àò f) :=
  { hg.toUniformInducing.comp hf.toUniformInducing with inj := hg.inj.comp hf.inj }
#align uniform_embedding.comp UniformEmbedding.comp

theorem Equiv.uniformEmbedding {Œ± Œ≤ : Type*} [UniformSpace Œ±] [UniformSpace Œ≤] (f : Œ± ‚âÉ Œ≤)
    (h‚ÇÅ : UniformContinuous f) (h‚ÇÇ : UniformContinuous f.symm) : UniformEmbedding f :=
  uniformEmbedding_iff'.2 ‚ü®f.injective, h‚ÇÅ, by rwa [‚Üê Equiv.prodCongr_apply, ‚Üê map_equiv_symm]‚ü©
#align equiv.uniform_embedding Equiv.uniformEmbedding

theorem uniformEmbedding_inl : UniformEmbedding (Sum.inl : Œ± ‚Üí Œ± ‚äï Œ≤) :=
  uniformEmbedding_iff'.2 ‚ü®Sum.inl_injective, uniformContinuous_inl, fun s hs =>
    ‚ü®Prod.map Sum.inl Sum.inl '' s ‚à™ range (Prod.map Sum.inr Sum.inr),
      union_mem_sup (image_mem_map hs) range_mem_map, fun x h => by simpa using h‚ü©‚ü©
#align uniform_embedding_inl uniformEmbedding_inl

theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=
  uniformEmbedding_iff'.2 ‚ü®Sum.inr_injective, uniformContinuous_inr, fun s hs =>
    ‚ü®range (Prod.map Sum.inl Sum.inl) ‚à™ Prod.map Sum.inr Sum.inr '' s,
      union_mem_sup range_mem_map (image_mem_map hs), fun x h => by simpa using h‚ü©‚ü©
#align uniform_embedding_inr uniformEmbedding_inr

/-- If the domain of a `UniformInducing` map `f` is a T‚ÇÄ space, then `f` is injective,
hence it is a `UniformEmbedding`. -/
protected theorem UniformInducing.uniformEmbedding [T0Space Œ±] {f : Œ± ‚Üí Œ≤}
    (hf : UniformInducing f) : UniformEmbedding f :=
  ‚ü®hf, hf.inducing.injective‚ü©
#align uniform_inducing.uniform_embedding UniformInducing.uniformEmbedding

theorem uniformEmbedding_iff_uniformInducing [T0Space Œ±] {f : Œ± ‚Üí Œ≤} :
    UniformEmbedding f ‚Üî UniformInducing f :=
  ‚ü®UniformEmbedding.toUniformInducing, UniformInducing.uniformEmbedding‚ü©
#align uniform_embedding_iff_uniform_inducing uniformEmbedding_iff_uniformInducing

/-- If a map `f : Œ± ‚Üí Œ≤` sends any two distinct points to point that are **not** related by a fixed
`s ‚àà ùì§ Œ≤`, then `f` is uniform inducing with respect to the discrete uniformity on `Œ±`:
the preimage of `ùì§ Œ≤` under `Prod.map f f` is the principal filter generated by the diagonal in
`Œ± √ó Œ±`. -/
theorem comap_uniformity_of_spaced_out {Œ±} {f : Œ± ‚Üí Œ≤} {s : Set (Œ≤ √ó Œ≤)} (hs : s ‚àà ùì§ Œ≤)
    (hf : Pairwise fun x y => (f x, f y) ‚àâ s) : comap (Prod.map f f) (ùì§ Œ≤) = ùìü idRel := by
  refine' le_antisymm _ (@refl_le_uniformity Œ± (UniformSpace.comap f _))
  calc
    comap (Prod.map f f) (ùì§ Œ≤) ‚â§ comap (Prod.map f f) (ùìü s) := comap_mono (le_principal_iff.2 hs)
    _ = ùìü (Prod.map f f ‚Åª¬π' s) := comap_principal
    _ ‚â§ ùìü idRel := principal_mono.2 ?_
  rintro ‚ü®x, y‚ü©; simpa [not_imp_not] using @hf x y
#align comap_uniformity_of_spaced_out comap_uniformity_of_spaced_out

/-- If a map `f : Œ± ‚Üí Œ≤` sends any two distinct points to point that are **not** related by a fixed
`s ‚àà ùì§ Œ≤`, then `f` is a uniform embedding with respect to the discrete uniformity on `Œ±`. -/
theorem uniformEmbedding_of_spaced_out {Œ±} {f : Œ± ‚Üí Œ≤} {s : Set (Œ≤ √ó Œ≤)} (hs : s ‚àà ùì§ Œ≤)
    (hf : Pairwise fun x y => (f x, f y) ‚àâ s) : @UniformEmbedding Œ± Œ≤ ‚ä• ‚Äπ_‚Ä∫ f := by
  let _ : UniformSpace Œ± := ‚ä•; have := discreteTopology_bot Œ±
  exact UniformInducing.uniformEmbedding ‚ü®comap_uniformity_of_spaced_out hs hf‚ü©
#align uniform_embedding_of_spaced_out uniformEmbedding_of_spaced_out

protected theorem UniformEmbedding.embedding {f : Œ± ‚Üí Œ≤} (h : UniformEmbedding f) : Embedding f :=
  { toInducing := h.toUniformInducing.inducing
    inj := h.inj }
#align uniform_embedding.embedding UniformEmbedding.embedding

theorem UniformEmbedding.denseEmbedding {f : Œ± ‚Üí Œ≤} (h : UniformEmbedding f) (hd : DenseRange f) :
    DenseEmbedding f :=
  { h.embedding with dense := hd }
#align uniform_embedding.dense_embedding UniformEmbedding.denseEmbedding

theorem closedEmbedding_of_spaced_out {Œ±} [TopologicalSpace Œ±] [DiscreteTopology Œ±]
    [SeparatedSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set (Œ≤ √ó Œ≤)} (hs : s ‚àà ùì§ Œ≤)
    (hf : Pairwise fun x y => (f x, f y) ‚àâ s) : ClosedEmbedding f := by
  rcases @DiscreteTopology.eq_bot Œ± _ _ with rfl; let _ : UniformSpace Œ± := ‚ä•
  exact
    { (uniformEmbedding_of_spaced_out hs hf).embedding with
      closed_range := isClosed_range_of_spaced_out hs hf }
#align closed_embedding_of_spaced_out closedEmbedding_of_spaced_out

theorem closure_image_mem_nhds_of_uniformInducing {s : Set (Œ± √ó Œ±)} {e : Œ± ‚Üí Œ≤} (b : Œ≤)
    (he‚ÇÅ : UniformInducing e) (he‚ÇÇ : DenseInducing e) (hs : s ‚àà ùì§ Œ±) :
    ‚àÉ a, closure (e '' { a' | (a, a') ‚àà s }) ‚àà ùìù b := by
  obtain ‚ü®U, ‚ü®hU, hUo, hsymm‚ü©, hs‚ü© :
    ‚àÉ U, (U ‚àà ùì§ Œ≤ ‚àß IsOpen U ‚àß SymmetricRel U) ‚àß Prod.map e e ‚Åª¬π' U ‚äÜ s := by
      rwa [‚Üê he‚ÇÅ.comap_uniformity, (uniformity_hasBasis_open_symmetric.comap _).mem_iff] at hs
  rcases he‚ÇÇ.dense.mem_nhds (UniformSpace.ball_mem_nhds b hU) with ‚ü®a, ha‚ü©
  refine ‚ü®a, mem_of_superset ?_ (closure_mono <| image_subset _ <| ball_mono hs a)‚ü©
  have ho : IsOpen (UniformSpace.ball (e a) U) := UniformSpace.isOpen_ball (e a) hUo
  refine mem_of_superset (ho.mem_nhds <| (mem_ball_symmetry hsymm).2 ha) fun y hy => ?_
  refine mem_closure_iff_nhds.2 fun V hV => ?_
  rcases he‚ÇÇ.dense.mem_nhds (inter_mem hV (ho.mem_nhds hy)) with ‚ü®x, hxV, hxU‚ü©
  exact ‚ü®e x, hxV, mem_image_of_mem e hxU‚ü©
#align closure_image_mem_nhds_of_uniform_inducing closure_image_mem_nhds_of_uniformInducing

theorem uniformEmbedding_subtypeEmb (p : Œ± ‚Üí Prop) {e : Œ± ‚Üí Œ≤} (ue : UniformEmbedding e)
    (de : DenseEmbedding e) : UniformEmbedding (DenseEmbedding.subtypeEmb p e) :=
  { comap_uniformity := by
      simp [comap_comap, (¬∑ ‚àò ¬∑), DenseEmbedding.subtypeEmb, uniformity_subtype,
        ue.comap_uniformity.symm]
    inj := (de.subtype p).inj }
#align uniform_embedding_subtype_emb uniformEmbedding_subtypeEmb

theorem UniformEmbedding.prod {Œ±' : Type*} {Œ≤' : Type*} [UniformSpace Œ±'] [UniformSpace Œ≤']
    {e‚ÇÅ : Œ± ‚Üí Œ±'} {e‚ÇÇ : Œ≤ ‚Üí Œ≤'} (h‚ÇÅ : UniformEmbedding e‚ÇÅ) (h‚ÇÇ : UniformEmbedding e‚ÇÇ) :
    UniformEmbedding fun p : Œ± √ó Œ≤ => (e‚ÇÅ p.1, e‚ÇÇ p.2) :=
  { h‚ÇÅ.toUniformInducing.prod h‚ÇÇ.toUniformInducing with inj := h‚ÇÅ.inj.Prod_map h‚ÇÇ.inj }
#align uniform_embedding.prod UniformEmbedding.prod

theorem isComplete_of_complete_image {m : Œ± ‚Üí Œ≤} {s : Set Œ±} (hm : UniformInducing m)
    (hs : IsComplete (m '' s)) : IsComplete s := by
  intro f hf hfs
  rw [le_principal_iff] at hfs
  obtain ‚ü®_, ‚ü®x, hx, rfl‚ü©, hyf‚ü© : ‚àÉ y ‚àà m '' s, map m f ‚â§ ùìù y
  exact hs (f.map m) (hf.map hm.uniformContinuous) (le_principal_iff.2 (image_mem_map hfs))
  rw [map_le_iff_le_comap, ‚Üê nhds_induced, ‚Üê hm.inducing.induced] at hyf
  exact ‚ü®x, hx, hyf‚ü©
#align is_complete_of_complete_image isComplete_of_complete_image

theorem IsComplete.completeSpace_coe {s : Set Œ±} (hs : IsComplete s) : CompleteSpace s :=
  completeSpace_iff_isComplete_univ.2 <|
    isComplete_of_complete_image uniformEmbedding_subtype_val.toUniformInducing <| by simp [hs]
#align is_complete.complete_space_coe IsComplete.completeSpace_coe

/-- A set is complete iff its image under a uniform inducing map is complete. -/
theorem isComplete_image_iff {m : Œ± ‚Üí Œ≤} {s : Set Œ±} (hm : UniformInducing m) :
    IsComplete (m '' s) ‚Üî IsComplete s := by
  refine' ‚ü®isComplete_of_complete_image hm, fun c => _‚ü©
  haveI : CompleteSpace s := c.completeSpace_coe
  set m' : s ‚Üí Œ≤ := m ‚àò (‚Üë)
  suffices IsComplete (range m') by rwa [range_comp, Subtype.range_coe] at this
  have hm' : UniformInducing m' := hm.comp uniformEmbedding_subtype_val.toUniformInducing
  intro f hf hfm
  rw [Filter.le_principal_iff] at hfm
  have cf' : Cauchy (comap m' f) :=
    hf.comap' hm'.comap_uniformity.le (NeBot.comap_of_range_mem hf.1 hfm)
  rcases CompleteSpace.complete cf' with ‚ü®x, hx‚ü©
  rw [hm'.inducing.nhds_eq_comap, comap_le_comap_iff hfm] at hx
  exact ‚ü®m' x, mem_range_self _, hx‚ü©
#align is_complete_image_iff isComplete_image_iff

theorem completeSpace_iff_isComplete_range {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) :
    CompleteSpace Œ± ‚Üî IsComplete (range f) := by
  rw [completeSpace_iff_isComplete_univ, ‚Üê isComplete_image_iff hf, image_univ]
#align complete_space_iff_is_complete_range completeSpace_iff_isComplete_range

theorem UniformInducing.isComplete_range [CompleteSpace Œ±] {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) :
    IsComplete (range f) :=
  (completeSpace_iff_isComplete_range hf).1 ‚Äπ_‚Ä∫
#align uniform_inducing.is_complete_range UniformInducing.isComplete_range

theorem completeSpace_congr {e : Œ± ‚âÉ Œ≤} (he : UniformEmbedding e) :
    CompleteSpace Œ± ‚Üî CompleteSpace Œ≤ := by
  rw [completeSpace_iff_isComplete_range he.toUniformInducing, e.range_eq_univ,
    completeSpace_iff_isComplete_univ]
#align complete_space_congr completeSpace_congr

theorem completeSpace_coe_iff_isComplete {s : Set Œ±} : CompleteSpace s ‚Üî IsComplete s :=
  (completeSpace_iff_isComplete_range uniformEmbedding_subtype_val.toUniformInducing).trans <| by
    rw [Subtype.range_coe]
#align complete_space_coe_iff_is_complete completeSpace_coe_iff_isComplete

theorem IsClosed.completeSpace_coe [CompleteSpace Œ±] {s : Set Œ±} (hs : IsClosed s) :
    CompleteSpace s :=
  hs.isComplete.completeSpace_coe
#align is_closed.complete_space_coe IsClosed.completeSpace_coe

/-- The lift of a complete space to another universe is still complete. -/
instance ULift.completeSpace [h : CompleteSpace Œ±] : CompleteSpace (ULift Œ±) :=
  haveI : UniformEmbedding (@Equiv.ulift Œ±) := ‚ü®‚ü®rfl‚ü©, ULift.down_injective‚ü©
  (completeSpace_congr this).2 h
#align ulift.complete_space ULift.completeSpace

theorem completeSpace_extension {m : Œ≤ ‚Üí Œ±} (hm : UniformInducing m) (dense : DenseRange m)
    (h : ‚àÄ f : Filter Œ≤, Cauchy f ‚Üí ‚àÉ x : Œ±, map m f ‚â§ ùìù x) : CompleteSpace Œ± :=
  ‚ü®fun {f : Filter Œ±} (hf : Cauchy f) =>
    let p : Set (Œ± √ó Œ±) ‚Üí Set Œ± ‚Üí Set Œ± := fun s t => { y : Œ± | ‚àÉ x : Œ±, x ‚àà t ‚àß (x, y) ‚àà s }
    let g := (ùì§ Œ±).lift fun s => f.lift' (p s)
    have mp‚ÇÄ : Monotone p := fun a b h t s ‚ü®x, xs, xa‚ü© => ‚ü®x, xs, h xa‚ü©
    have mp‚ÇÅ : ‚àÄ {s}, Monotone (p s) := fun h x ‚ü®y, ya, yxs‚ü© => ‚ü®y, h ya, yxs‚ü©
    have : f ‚â§ g := le_iInf‚ÇÇ fun s hs => le_iInf‚ÇÇ fun t ht =>
      le_principal_iff.mpr <| mem_of_superset ht fun x hx => ‚ü®x, hx, refl_mem_uniformity hs‚ü©
    have : NeBot g := hf.left.mono this
    have : NeBot (comap m g) :=
      comap_neBot fun t ht =>
        let ‚ü®t', ht', ht_mem‚ü© := (mem_lift_sets <| monotone_lift' monotone_const mp‚ÇÄ).mp ht
        let ‚ü®t'', ht'', ht'_sub‚ü© := (mem_lift'_sets mp‚ÇÅ).mp ht_mem
        let ‚ü®x, (hx : x ‚àà t'')‚ü© := hf.left.nonempty_of_mem ht''
        have h‚ÇÄ : NeBot (ùìù[range m] x) := dense.nhdsWithin_neBot x
        have h‚ÇÅ : { y | (x, y) ‚àà t' } ‚àà ùìù[range m] x :=
          @mem_inf_of_left Œ± (ùìù x) (ùìü (range m)) _ <| mem_nhds_left x ht'
        have h‚ÇÇ : range m ‚àà ùìù[range m] x :=
          @mem_inf_of_right Œ± (ùìù x) (ùìü (range m)) _ <| Subset.refl _
        have : { y | (x, y) ‚àà t' } ‚à© range m ‚àà ùìù[range m] x := @inter_mem Œ± (ùìù[range m] x) _ _ h‚ÇÅ h‚ÇÇ
        let ‚ü®y, xyt', b, b_eq‚ü© := h‚ÇÄ.nonempty_of_mem this
        ‚ü®b, b_eq.symm ‚ñ∏ ht'_sub ‚ü®x, hx, xyt'‚ü©‚ü©
    have : Cauchy g :=
      ‚ü®‚ÄπNeBot g‚Ä∫, fun s hs =>
        let ‚ü®s‚ÇÅ, hs‚ÇÅ, (comp_s‚ÇÅ : compRel s‚ÇÅ s‚ÇÅ ‚äÜ s)‚ü© := comp_mem_uniformity_sets hs
        let ‚ü®s‚ÇÇ, hs‚ÇÇ, (comp_s‚ÇÇ : compRel s‚ÇÇ s‚ÇÇ ‚äÜ s‚ÇÅ)‚ü© := comp_mem_uniformity_sets hs‚ÇÅ
        let ‚ü®t, ht, (prod_t : t √óÀ¢ t ‚äÜ s‚ÇÇ)‚ü© := mem_prod_same_iff.mp (hf.right hs‚ÇÇ)
        have hg‚ÇÅ : p (preimage Prod.swap s‚ÇÅ) t ‚àà g :=
          mem_lift (symm_le_uniformity hs‚ÇÅ) <| @mem_lift' Œ± Œ± f _ t ht
        have hg‚ÇÇ : p s‚ÇÇ t ‚àà g := mem_lift hs‚ÇÇ <| @mem_lift' Œ± Œ± f _ t ht
        have hg : p (Prod.swap ‚Åª¬π' s‚ÇÅ) t √óÀ¢ p s‚ÇÇ t ‚àà g √óÀ¢ g := @prod_mem_prod Œ± Œ± _ _ g g hg‚ÇÅ hg‚ÇÇ
        (g √óÀ¢ g).sets_of_superset hg fun ‚ü®a, b‚ü© ‚ü®‚ü®c‚ÇÅ, c‚ÇÅt, hc‚ÇÅ‚ü©, ‚ü®c‚ÇÇ, c‚ÇÇt, hc‚ÇÇ‚ü©‚ü© =>
          have : (c‚ÇÅ, c‚ÇÇ) ‚àà t √óÀ¢ t := ‚ü®c‚ÇÅt, c‚ÇÇt‚ü©
          comp_s‚ÇÅ <| prod_mk_mem_compRel hc‚ÇÅ <| comp_s‚ÇÇ <| prod_mk_mem_compRel (prod_t this) hc‚ÇÇ‚ü©
    have : Cauchy (Filter.comap m g) := ‚ÄπCauchy g‚Ä∫.comap' (le_of_eq hm.comap_uniformity) ‚Äπ_‚Ä∫
    let ‚ü®x, (hx : map m (Filter.comap m g) ‚â§ ùìù x)‚ü© := h _ this
    have : ClusterPt x (map m (Filter.comap m g)) :=
      (le_nhds_iff_adhp_of_cauchy (this.map hm.uniformContinuous)).mp hx
    have : ClusterPt x g := this.mono map_comap_le
    ‚ü®x,
      calc
        f ‚â§ g := by assumption
        _ ‚â§ ùìù x := le_nhds_of_cauchy_adhp ‚ÄπCauchy g‚Ä∫ this
        ‚ü©‚ü©
#align complete_space_extension completeSpace_extension

theorem totallyBounded_preimage {f : Œ± ‚Üí Œ≤} {s : Set Œ≤} (hf : UniformEmbedding f)
    (hs : TotallyBounded s) : TotallyBounded (f ‚Åª¬π' s) := fun t ht => by
  rw [‚Üê hf.comap_uniformity] at ht
  rcases mem_comap.2 ht with ‚ü®t', ht', ts‚ü©
  rcases totallyBounded_iff_subset.1 (totallyBounded_subset (image_preimage_subset f s) hs) _ ht'
    with ‚ü®c, cs, hfc, hct‚ü©
  refine' ‚ü®f ‚Åª¬π' c, hfc.preimage (hf.inj.injOn _), fun x h => _‚ü©
  have := hct (mem_image_of_mem f h); simp at this ‚ä¢
  rcases this with ‚ü®z, zc, zt‚ü©
  rcases cs zc with ‚ü®y, -, rfl‚ü©
  exact ‚ü®y, zc, ts zt‚ü©
#align totally_bounded_preimage totallyBounded_preimage

instance CompleteSpace.sum [CompleteSpace Œ±] [CompleteSpace Œ≤] : CompleteSpace (Sum Œ± Œ≤) := by
  rw [completeSpace_iff_isComplete_univ, ‚Üê range_inl_union_range_inr]
  exact uniformEmbedding_inl.toUniformInducing.isComplete_range.union
    uniformEmbedding_inr.toUniformInducing.isComplete_range
#align complete_space.sum CompleteSpace.sum

end

theorem uniformEmbedding_comap {Œ± : Type*} {Œ≤ : Type*} {f : Œ± ‚Üí Œ≤} [u : UniformSpace Œ≤]
    (hf : Function.Injective f) : @UniformEmbedding Œ± Œ≤ (UniformSpace.comap f u) u f :=
  @UniformEmbedding.mk _ _ (UniformSpace.comap f u) _ _
    (@UniformInducing.mk _ _ (UniformSpace.comap f u) _ _ rfl) hf
#align uniform_embedding_comap uniformEmbedding_comap

/-- Pull back a uniform space structure by an embedding, adjusting the new uniform structure to
make sure that its topology is defeq to the original one. -/
def Embedding.comapUniformSpace {Œ± Œ≤} [TopologicalSpace Œ±] [u : UniformSpace Œ≤] (f : Œ± ‚Üí Œ≤)
    (h : Embedding f) : UniformSpace Œ± :=
  (u.comap f).replaceTopology h.induced
#align embedding.comap_uniform_space Embedding.comapUniformSpace

theorem Embedding.to_uniformEmbedding {Œ± Œ≤} [TopologicalSpace Œ±] [u : UniformSpace Œ≤] (f : Œ± ‚Üí Œ≤)
    (h : Embedding f) : @UniformEmbedding Œ± Œ≤ (h.comapUniformSpace f) u f :=
  let _ := h.comapUniformSpace f
  { comap_uniformity := rfl
    inj := h.inj }
#align embedding.to_uniform_embedding Embedding.to_uniformEmbedding

section UniformExtension

variable {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*} [UniformSpace Œ±] [UniformSpace Œ≤] [UniformSpace Œ≥]
  {e : Œ≤ ‚Üí Œ±} (h_e : UniformInducing e) (h_dense : DenseRange e) {f : Œ≤ ‚Üí Œ≥}
  (h_f : UniformContinuous f)

local notation "œà" => DenseInducing.extend (UniformInducing.denseInducing h_e h_dense) f

theorem uniformly_extend_exists [CompleteSpace Œ≥] (a : Œ±) : ‚àÉ c, Tendsto f (comap e (ùìù a)) (ùìù c) :=
  let de := h_e.denseInducing h_dense
  have : Cauchy (ùìù a) := cauchy_nhds
  have : Cauchy (comap e (ùìù a)) :=
    this.comap' (le_of_eq h_e.comap_uniformity) (de.comap_nhds_neBot _)
  have : Cauchy (map f (comap e (ùìù a))) := this.map h_f
  CompleteSpace.complete this
#align uniformly_extend_exists uniformly_extend_exists

theorem uniform_extend_subtype [CompleteSpace Œ≥] {p : Œ± ‚Üí Prop} {e : Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≥} {b : Œ≤}
    {s : Set Œ±} (hf : UniformContinuous fun x : Subtype p => f x.val) (he : UniformEmbedding e)
    (hd : ‚àÄ x : Œ≤, x ‚àà closure (range e)) (hb : closure (e '' s) ‚àà ùìù b) (hs : IsClosed s)
    (hp : ‚àÄ x ‚àà s, p x) : ‚àÉ c, Tendsto f (comap e (ùìù b)) (ùìù c) := by
  have de : DenseEmbedding e := he.denseEmbedding hd
  have de' : DenseEmbedding (DenseEmbedding.subtypeEmb p e) := de.subtype p
  have ue' : UniformEmbedding (DenseEmbedding.subtypeEmb p e) := uniformEmbedding_subtypeEmb _ he de
  have : b ‚àà closure (e '' { x | p x }) :=
    (closure_mono <| monotone_image <| hp) (mem_of_mem_nhds hb)
  let ‚ü®c, hc‚ü© := uniformly_extend_exists ue'.toUniformInducing de'.dense hf ‚ü®b, this‚ü©
  replace hc : Tendsto (f ‚àò Subtype.val) (((ùìù b).comap e).comap Subtype.val) (ùìù c) := by
    simpa only [nhds_subtype_eq_comap, comap_comap, DenseEmbedding.subtypeEmb_coe] using hc
  refine ‚ü®c, (tendsto_comap'_iff ?_).1 hc‚ü©
  rw [Subtype.range_coe_subtype]
  exact ‚ü®_, hb, by rwa [‚Üê de.toInducing.closure_eq_preimage_closure_image, hs.closure_eq]‚ü©
#align uniform_extend_subtype uniform_extend_subtype

theorem uniformly_extend_spec [CompleteSpace Œ≥] (a : Œ±) : Tendsto f (comap e (ùìù a)) (ùìù (œà a)) := by
  simpa only [DenseInducing.extend] using
    tendsto_nhds_limUnder (uniformly_extend_exists h_e ‚Äπ_‚Ä∫ h_f _)
#align uniformly_extend_spec uniformly_extend_spec

theorem uniformContinuous_uniformly_extend [CompleteSpace Œ≥] : UniformContinuous œà := fun d hd =>
  let ‚ü®s, hs, hs_comp‚ü© := comp3_mem_uniformity hd
  have h_pnt : ‚àÄ {a m}, m ‚àà ùìù a ‚Üí ‚àÉ c ‚àà f '' (e ‚Åª¬π' m), (c, œà a) ‚àà s ‚àß (œà a, c) ‚àà s :=
    fun {a m} hm =>
    have nb : NeBot (map f (comap e (ùìù a))) :=
      ((h_e.denseInducing h_dense).comap_nhds_neBot _).map _
    have :
      f '' (e ‚Åª¬π' m) ‚à© ({ c | (c, œà a) ‚àà s } ‚à© { c | (œà a, c) ‚àà s }) ‚àà map f (comap e (ùìù a)) :=
      inter_mem (image_mem_map <| preimage_mem_comap <| hm)
        (uniformly_extend_spec h_e h_dense h_f _
          (inter_mem (mem_nhds_right _ hs) (mem_nhds_left _ hs)))
    nb.nonempty_of_mem this
  have : (Prod.map f f) ‚Åª¬π' s ‚àà ùì§ Œ≤ := h_f hs
  have : (Prod.map f f) ‚Åª¬π' s ‚àà comap (Prod.map e e) (ùì§ Œ±) := by
    rwa [‚Üê h_e.comap_uniformity] at this
  let ‚ü®t, ht, ts‚ü© := this
  show (Prod.map œà œà) ‚Åª¬π' d ‚àà ùì§ Œ± from
    mem_of_superset (interior_mem_uniformity ht) fun ‚ü®x‚ÇÅ, x‚ÇÇ‚ü© hx_t => by
      have : interior t ‚àà ùìù (x‚ÇÅ, x‚ÇÇ) := isOpen_interior.mem_nhds hx_t
      let ‚ü®m‚ÇÅ, hm‚ÇÅ, m‚ÇÇ, hm‚ÇÇ, (hm : m‚ÇÅ √óÀ¢ m‚ÇÇ ‚äÜ interior t)‚ü© := mem_nhds_prod_iff.mp this
      obtain ‚ü®_, ‚ü®a, ha‚ÇÅ, rfl‚ü©, _, ha‚ÇÇ‚ü© := h_pnt hm‚ÇÅ
      obtain ‚ü®_, ‚ü®b, hb‚ÇÅ, rfl‚ü©, hb‚ÇÇ, _‚ü© := h_pnt hm‚ÇÇ
      have : Prod.map f f (a, b) ‚àà s :=
        ts <| mem_preimage.2 <| interior_subset (@hm (e a, e b) ‚ü®ha‚ÇÅ, hb‚ÇÅ‚ü©)
      exact hs_comp ‚ü®f a, ha‚ÇÇ, ‚ü®f b, this, hb‚ÇÇ‚ü©‚ü©
#align uniform_continuous_uniformly_extend uniformContinuous_uniformly_extend

variable [SeparatedSpace Œ≥]

theorem uniformly_extend_of_ind (b : Œ≤) : œà (e b) = f b :=
  DenseInducing.extend_eq_at _ h_f.continuous.continuousAt
#align uniformly_extend_of_ind uniformly_extend_of_ind

theorem uniformly_extend_unique {g : Œ± ‚Üí Œ≥} (hg : ‚àÄ b, g (e b) = f b) (hc : Continuous g) : œà = g :=
  DenseInducing.extend_unique _ hg hc
#align uniformly_extend_unique uniformly_extend_unique

end UniformExtension
