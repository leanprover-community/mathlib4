/-
Copyright (c) 2025 Aaron Liu. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Aaron Liu
-/
import Mathlib.Topology.UniformSpace.Uniformizable

/-!
# Fine Uniformity

The fine uniformity on a topological space is the finest uniformity
compatible with the given topology. In general the topology generated by this uniformity
is coarser than the ambient topology, they coincide only for completely regular spaces.

The fine uniformity can be seen as a functor from the category of topological spaces and
continuous maps to the category of uniform spaces and uniformly continuous maps,
and when seen this way it is the left adjoint to the forgetful functor.

## References

* <https://en.wikipedia.org/wiki/Uniformizable_space#Fine_uniformity>
-/

variable {α β : Type*} {ι : Sort*}

open Topology Uniformity Set

section

variable (α) in
/--
The fine uniformity on a topological space is the finest uniformity
compatible with the given topology. In general the topology generated by this uniformity
is coarser than the ambient topology, they coincide only for completely regular spaces.
-/
def fineUniformity [TopologicalSpace α] : UniformSpace α :=
  ⨅ (u : UniformSpace α) (_ : ‹TopologicalSpace α› ≤ u.toTopologicalSpace), u

theorem fineUniformity_mono {t₁ t₂ : TopologicalSpace α} (h : t₁ ≤ t₂) :
    @fineUniformity α t₁ ≤ @fineUniformity α t₂ :=
  biInf_mono fun _ => h.trans

theorem monotone_fineUniformity : Monotone (@fineUniformity α) :=
  @fineUniformity_mono α

theorem gc_fineUniformity :
    GaloisConnection (@fineUniformity α) (@UniformSpace.toTopologicalSpace α) := by
  apply GaloisConnection.monotone_intro
  · exact @UniformSpace.toTopologicalSpace_mono α
  · exact monotone_fineUniformity
  · simp [UniformSpace.toTopologicalSpace_iInf]
  · intro a
    unfold fineUniformity
    -- fixme: why does this timeout
    -- exact iInf₂_le (f := fun u (b : a.toTopologicalSpace ≤ u.toTopologicalSpace) => u) a le_rfl
    trans ⨅ (_ : a.toTopologicalSpace ≤ a.toTopologicalSpace), a
    · -- PS: why does `exact` timeout here
      apply iInf_le (fun u => ⨅ (_ : a.toTopologicalSpace ≤ u.toTopologicalSpace), u) a
    · exact iInf_le (fun _ => a) le_rfl

theorem fineUniformity_le_iff {t : TopologicalSpace α} {u : UniformSpace α} :
    @fineUniformity α t ≤ u ↔ t ≤ u.toTopologicalSpace := gc_fineUniformity.le_iff_le

theorem fineUniformity_sup {t₁ t₂ : TopologicalSpace α} :
    @fineUniformity α (t₁ ⊔ t₂) = @fineUniformity α t₁ ⊔ @fineUniformity α t₂ :=
  gc_fineUniformity.l_sup

theorem fineUniformity_iSup {t : ι → TopologicalSpace α} :
    @fineUniformity α (iSup t) = ⨆ i, @fineUniformity α (t i) :=
  gc_fineUniformity.l_iSup

theorem fineUniformity_sSup {t : Set (TopologicalSpace α)} :
    @fineUniformity α (sSup t) = ⨆ i ∈ t, @fineUniformity α i :=
  gc_fineUniformity.l_sSup

theorem fineUniformity_iSup₂ {κ : ι → Sort*} {t : (i : ι) → κ i → TopologicalSpace α} :
    @fineUniformity α (⨆ (i) (j), t i j) = ⨆ (i) (j), @fineUniformity α (t i j) :=
  gc_fineUniformity.l_iSup₂

theorem fineUniformity_discrete [TopologicalSpace α] [DiscreteTopology α] :
    fineUniformity α = ⊥ :=
  ‹DiscreteTopology α›.eq_bot ▸ gc_fineUniformity.l_bot

theorem toTopologicalSpace_fineUniformity_eq [TopologicalSpace α] [CompletelyRegularSpace α] :
    (fineUniformity α).toTopologicalSpace = ‹TopologicalSpace α› :=
  ((gc_fineUniformity.exists_eq_u _).mp
    (CompletelyRegularSpace.exists_uniformity.elim fun u hu => ⟨u, hu.symm⟩)).symm

theorem fineUniformity_top : @fineUniformity α ⊤ = ⊤ := by
  ext s
  rw [top_uniformity, Filter.mem_top]
  constructor
  · rw [eq_univ_iff_forall]
    intro h a
    have top : ∃ (u : UniformSpace α), ⊤ = u.toTopologicalSpace :=
      ⟨⊤, UniformSpace.toTopologicalSpace_top⟩
    rw [gc_fineUniformity.exists_eq_u] at top
    have comap : Prod.mk a.fst ⁻¹' s ∈
        Filter.comap (Prod.mk a.fst) (@uniformity α (@fineUniformity α ⊤)) := by
      rw [Filter.mem_comap_iff_compl]
      filter_upwards [h] with x hxs ⟨u, hu, hxu⟩
      subst hxu
      exact hu hxs
    rw [← @nhds_eq_comap_uniformity, ← top, nhds_top, Filter.mem_top] at comap
    change a.snd ∈ Prod.mk a.fst ⁻¹' s
    rw [comap]
    exact mem_univ a.snd
  · rintro rfl
    exact Filter.univ_mem

theorem uniformContinuous_fineUniformity_iff {t : TopologicalSpace α} {u : UniformSpace β}
    {f : α → β} : UniformContinuous[@fineUniformity α t, u] f ↔
    Continuous[t, u.toTopologicalSpace] f := by
  rw [uniformContinuous_iff, fineUniformity_le_iff, continuous_iff_le_induced,
    UniformSpace.toTopologicalSpace_comap]

theorem uniformContinuous_fineUniformity_fineUniformity
    [TopologicalSpace α] [TopologicalSpace β] {f : α → β} (hf : Continuous f) :
    UniformContinuous[fineUniformity α, fineUniformity β] f := by
  rw [uniformContinuous_fineUniformity_iff]
  rw [continuous_iff_coinduced_le] at hf ⊢
  exact hf.trans (gc_fineUniformity.le_u_l _)

end
