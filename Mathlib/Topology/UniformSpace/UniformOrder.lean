/-
Copyright (c) 2024 Wen Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Wen Yang
-/
import Mathlib.Topology.UniformSpace.Basic

/-!
# Uniform ordered space

## References

* [Leopoldo Nachbin, *Topology and Order*][Nachbin1965Topology]
-/

open Filter Function Set Uniformity Topology

universe u v w
variable {α : Type u} {β : Type v} {γ : Type w}

/-- A semi-uniform structure is like a uniform structure but without symmetry. -/
structure SemiUniform (α : Type u) where
  /-- The semi-uniformity filter. -/
  semiuniformity : Filter (α × α)
  /-- Every set in the semi-uniformity filter includes the diagonal. -/
  refl : ∀ r ∈ semiuniformity, ∀ (x), (x, x) ∈ r
  /-- For every set `r ∈ semiuniformity`,
  there exists `t ∈ semiuniformity` such that `t ○ t ⊆ r`. -/
  comp : ∀ r ∈ semiuniformity, ∃ t ∈ semiuniformity, t ○ t ⊆ r

/-- The uniformity consists of the sets `U ∩ W⁻¹` where `U, W ∈ semiuniformity`. -/
def SemiUniform.UniformSpaceCore (S : SemiUniform α) : UniformSpace.Core α where
  uniformity := {
    sets := {U | ∃ V ∈ S.semiuniformity, ∃ W ∈ S.semiuniformity, U = V ∩ Prod.swap ⁻¹' W}
    univ_sets := ⟨univ, by simp, univ, by simp⟩
    sets_of_superset := by
      intro A B ⟨V, hV, W, hW, _⟩ _
      exact ⟨V ∪ B, exists_mem_subset_iff.mp (Exists.intro V ⟨hV, by simp⟩),
        ⟨W ∪ Prod.swap ⁻¹' B, exists_mem_subset_iff.mp (Exists.intro W ⟨hW, by simp⟩), by aesop⟩⟩
    inter_sets := by
      intro A B ⟨V, _, W, _, _⟩ ⟨V', _, W', _, _⟩
      exact ⟨V ∩ V', by aesop, ⟨W ∩ W', by aesop, by aesop⟩⟩
  }
  refl := by refine principal_le_iff.mpr ?_; have := S.refl; aesop
  symm := by refine tendsto_def.mpr ?_; intro A ⟨V, _, W, _, _⟩; exact ⟨W, by aesop, ⟨V, by aesop⟩⟩
  comp := by
    rw [le_def]
    intro A ⟨V, hV, W, hW, hVW⟩
    rw [mem_lift'_sets _]
    · obtain ⟨X, _, hX1⟩ := S.comp V hV
      obtain ⟨Y, _, hY1⟩ := S.comp W hW
      use X ∩ Prod.swap ⁻¹' Y
      constructor
      · aesop
      · have hX2 : X ∩ Prod.swap ⁻¹' Y ⊆ X := by exact inter_subset_left _ _
        have hY2 : X ∩ Prod.swap ⁻¹' Y ⊆ Prod.swap ⁻¹' Y := by exact inter_subset_right _ _
        have hXY := subset_inter (compRel_mono hX2 hX2) (compRel_mono hY2 hY2)
        have hY3 : Prod.swap ⁻¹' Y ○ Prod.swap ⁻¹' Y = Prod.swap ⁻¹' (Y ○ Y) := by aesop
        have hY4 : Prod.swap ⁻¹' (Y ○ Y) ⊆ Prod.swap ⁻¹' W := by rel [hY1]
        rw [hY3] at hXY
        rw [hVW]
        exact hXY.trans $ inter_subset_inter hX1 hY4
    · exact Monotone.compRel (fun ⦃a b⦄ a ↦ a) fun ⦃a b⦄ a ↦ a

/-- The uniform space generated by a semi-uniform structure. -/
def SemiUniform.UniformSpace (S : SemiUniform α) : UniformSpace α :=
  UniformSpace.ofCore S.UniformSpaceCore

/-- The preorder generated by a semi-uniform structure. -/
def SemiUniform.Preorder (S : SemiUniform α) : Preorder α where
  le := fun x y => ∀ s ∈ S.semiuniformity, (x, y) ∈ s
  le_refl := fun x => by have := S.refl ; aesop
  le_trans :=  fun x y z hxy hyz => by
    intro s hs
    obtain ⟨t, ht, hts⟩ : ∃ t ∈ S.semiuniformity, t ○ t ⊆ s := S.comp s hs
    aesop

/-- The uniform preordered space. -/
class UniformPreorder (α : Type u) [U : UniformSpace α] [P : Preorder α] where
  /-- The semi-uniform structure that generates the uniform preordered space. -/
  semiuniform : SemiUniform α
  /-- The uniform structure is generated by `semiuniform`. -/
  generateUniform : U = semiuniform.UniformSpace
  /-- The preorder is generated by `semiuniform`. -/
  generatePreorder : P = semiuniform.Preorder
