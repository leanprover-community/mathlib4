/-
Copyright (c) 2021 Oliver Nash. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Oliver Nash, Yury Kudryashov
-/
import Mathlib.Topology.CompactOpen
import Mathlib.Topology.UniformSpace.UniformConvergenceTopology

#align_import topology.uniform_space.compact_convergence from "leanprover-community/mathlib"@"dc6c365e751e34d100e80fe6e314c3c3e0fd2988"

/-!
# Compact convergence (uniform convergence on compact sets)

Given a topological space `Î±` and a uniform space `Î²` (e.g., a metric space or a topological group),
the space of continuous maps `C(Î±, Î²)` carries a natural uniform space structure.
We define this uniform space structure in this file
and also prove its basic properties.

## Main definitions

- `ContinuousMap.toUniformOnFunIsCompact`:
  natural embedding of `C(Î±, Î²)`
  into the space `Î± â†’áµ¤[{K | IsCompact K}] Î²` of all maps `Î± â†’ Î²`
  with the uniform space structure of uniform convergence on compacts.

- `ContinuousMap.compactConvergenceUniformSpace`:
  the `UniformSpace` structure on `C(Î±, Î²)` induced by the map above.

## Main results

* `ContinuousMap.mem_compactConvergence_entourage_iff`:
  a characterisation of the entourages of `C(Î±, Î²)`.

  The entourages are generated by the following sets.
  Given `K : Set Î±` and `V : Set (Î² Ã— Î²)`,
  let `E(K, V) : Set (C(Î±, Î²) Ã— C(Î±, Î²))` be the set of pairs of continuous functions `Î± â†’ Î²`
  which are `V`-close on `K`:
  $$
    E(K, V) = \{ (f, g) | âˆ€ (x âˆˆ K), (f x, g x) âˆˆ V \}.
  $$
  Then the sets `E(K, V)` for all compact sets `K` and all entourages `V`
  form a basis of entourages of `C(Î±, Î²)`.

  As usual, this basis of entourages provides a basis of neighbourhoods
  by fixing `f`, see `nhds_basis_uniformity'`.

* `Filter.HasBasis.compactConvergenceUniformity`:
  a similar statement that uses a basis of entourages of `Î²` instead of all entourages.
  It is useful, e.g., if `Î²` is a metric space.

* `ContinuousMap.tendsto_iff_forall_compact_tendstoUniformlyOn`:
  a sequence of functions `Fâ‚™` in `C(Î±, Î²)` converges in the compact-open topology to some `f`
  iff `Fâ‚™` converges to `f` uniformly on each compact subset `K` of `Î±`.

* Topology induced by the uniformity described above agrees with the compact-open topology.
  This is essentially the same as `ContinuousMap.tendsto_iff_forall_compact_tendstoUniformlyOn`.

  This fact is not available as a separate theorem.
  Instead, we override the projection of `ContinuousMap.compactConvergenceUniformity`
  to `TopologicalSpace` to be `ContinuousMap.compactOpen` and prove that they agree,
  see Note [forgetful inheritance] and implementation notes below.

* `ContinuousMap.tendsto_iff_tendstoLocallyUniformly`:
  on a weakly locally compact space,
  a sequence of functions `Fâ‚™` in `C(Î±, Î²)` converges to some `f`
  iff `Fâ‚™` converges to `f` locally uniformly.

* `ContinuousMap.tendsto_iff_tendstoUniformly`:
  on a compact space, a sequence of functions `Fâ‚™` in `C(Î±, Î²)` converges to some `f`
  iff `Fâ‚™` converges to `f` uniformly.

## Implementation details

For technical reasons (see Note [forgetful inheritance]),
instead of defining a `UniformSpace C(Î±, Î²)` structure
and proving in a theorem that it agrees with the compact-open topology,
we override the projection right in the definition,
so that the resulting instance uses the compact-open topology.

## TODO

* Results about uniformly continuous functions `Î³ â†’ C(Î±, Î²)`
  and uniform limits of sequences `Î¹ â†’ Î³ â†’ C(Î±, Î²)`.
-/


universe uâ‚ uâ‚‚ uâ‚ƒ

open scoped Uniformity Topology UniformConvergence

open UniformSpace Set Filter

variable {Î± : Type uâ‚} {Î² : Type uâ‚‚} [TopologicalSpace Î±] [UniformSpace Î²]
variable (K : Set Î±) (V : Set (Î² Ã— Î²)) (f : C(Î±, Î²))

namespace ContinuousMap

/-- Compact-open topology on `C(Î±, Î²)` agrees with the topology of uniform convergence on compacts:
a family of continuous functions `F i` tends to `f` in the compact-open topology
if and only if the `F i` tends to `f` uniformly on all compact sets. -/
theorem tendsto_iff_forall_compact_tendstoUniformlyOn
    {Î¹ : Type uâ‚ƒ} {p : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} {f} :
    Tendsto F p (ğ“ f) â†” âˆ€ K, IsCompact K â†’ TendstoUniformlyOn (fun i a => F i a) f p K := by
  rw [tendsto_nhds_compactOpen]
  constructor
  Â· -- Let us prove that convergence in the compact-open topology
    -- implies uniform convergence on compacts.
    -- Consider a compact set `K`
    intro h K hK
    -- Since `K` is compact, it suffices to prove locally uniform convergence
    rw [â† tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact hK]
    -- Now choose an entourage `U` in the codomain and a point `x âˆˆ K`.
    intro U hU x _
    -- Choose an open symmetric entourage `V` such that `V â—‹ V âŠ† U`.
    rcases comp_open_symm_mem_uniformity_sets hU with âŸ¨V, hV, hVo, hVsymm, hVUâŸ©
    -- Then choose a closed entourage `W âŠ† V`
    rcases mem_uniformity_isClosed hV with âŸ¨W, hW, hWc, hWUâŸ©
    -- Consider `s = {y âˆˆ K | (f x, f y) âˆˆ W}`
    set s := K âˆ© f â»Â¹' ball (f x) W
    -- This is a neighbourhood of `x` within `K`, because `W` is an entourage.
    have hnhds : s âˆˆ ğ“[K] x := inter_mem_nhdsWithin _ <| f.continuousAt _ (ball_mem_nhds _ hW)
    -- This set is compact because it is an intersection of `K`
    -- with a closed set `{y | (f x, f y) âˆˆ W} = f â»Â¹' UniformSpace.ball (f x) W`
    have hcomp : IsCompact s := hK.inter_right <| (isClosed_ball _ hWc).preimage f.continuous
    -- `f` maps `s` to the open set `ball (f x) V = {z | (f x, z) âˆˆ V}`
    have hmaps : MapsTo f s (ball (f x) V) := fun x hx â†¦ hWU hx.2
    use s, hnhds
    -- Continuous maps `F i` in a neighbourhood of `f` map `s` to `ball (f x) V` as well.
    refine (h s hcomp _ (isOpen_ball _ hVo) hmaps).mono fun g hg y hy â†¦ ?_
    -- Then for `y âˆˆ s` we have `(f y, f x) âˆˆ V` and `(f x, F i y) âˆˆ V`, thus `(f y, F i y) âˆˆ U`
    exact hVU âŸ¨f x, hVsymm.mk_mem_comm.2 <| hmaps hy, hg hyâŸ©
  Â· -- Now we prove that uniform convergence on compacts
    -- implies convergence in the compact-open topology
    -- Consider a compact set `K`, an open set `U`, and a continuous map `f` that maps `K` to `U`
    intro h K hK U hU hf
    -- Due to Lebesgue number lemma, there exists an entourage `V`
    -- such that `U` includes the `V`-thickening of `f '' K`.
    rcases lebesgue_number_of_compact_open (hK.image (map_continuous f)) hU hf.image_subset
        with âŸ¨V, hV, -, hVfâŸ©
    -- Then any continuous map that is uniformly `V`-close to `f` on `K`
    -- maps `K` to `U` as well
    filter_upwards [h K hK V hV] with g hg x hx using hVf _ (mem_image_of_mem f hx) (hg x hx)
#align continuous_map.tendsto_iff_forall_compact_tendsto_uniformly_on ContinuousMap.tendsto_iff_forall_compact_tendstoUniformlyOn

/-- Interpret a bundled continuous map as an element of `Î± â†’áµ¤[{K | IsCompact K}] Î²`.

We use this map to induce the `UniformSpace` structure on `C(Î±, Î²)`. -/
def toUniformOnFunIsCompact (f : C(Î±, Î²)) : Î± â†’áµ¤[{K | IsCompact K}] Î² :=
  UniformOnFun.ofFun {K | IsCompact K} f

@[simp]
theorem toUniformOnFun_toFun (f : C(Î±, Î²)) :
    UniformOnFun.toFun _ f.toUniformOnFunIsCompact = f := rfl

open UniformSpace in
/-- Uniform space structure on `C(Î±, Î²)`.

The uniformity comes from `Î± â†’áµ¤[{K | IsCompact K}] Î²` (i.e., `UniformOnFun Î± Î² {K | IsCompact K}`)
which defines topology of uniform convergence on compact sets.
We use `ContinuousMap.tendsto_iff_forall_compact_tendstoUniformlyOn`
to show that the induced topology agrees with the compact-open topology
and replace the topology with `compactOpen` to avoid non-defeq diamonds,
see Note [forgetful inheritance].  -/
instance compactConvergenceUniformSpace : UniformSpace C(Î±, Î²) :=
  .replaceTopology (.comap toUniformOnFunIsCompact inferInstance) <| by
    refine TopologicalSpace.ext_nhds fun f â†¦ eq_of_forall_le_iff fun l â†¦ ?_
    simp_rw [â† tendsto_id', tendsto_iff_forall_compact_tendstoUniformlyOn,
      nhds_induced, tendsto_comap_iff, UniformOnFun.tendsto_iff_tendstoUniformlyOn]
    rfl
#align continuous_map.compact_convergence_uniform_space ContinuousMap.compactConvergenceUniformSpace

theorem uniformEmbedding_toUniformOnFunIsCompact :
    UniformEmbedding (toUniformOnFunIsCompact : C(Î±, Î²) â†’ Î± â†’áµ¤[{K | IsCompact K}] Î²) where
  comap_uniformity := rfl
  inj := DFunLike.coe_injective

-- The following definitions and theorems
-- used to be a part of the construction of the `UniformSpace C(Î±, Î²)` structure
-- before it was migrated to `UniformOnFun`
#noalign continuous_map.compact_conv_nhd
#noalign continuous_map.self_mem_compact_conv_nhd
#noalign continuous_map.compact_conv_nhd_mono
#noalign continuous_map.compact_conv_nhd_mem_comp
#noalign continuous_map.compact_conv_nhd_nhd_basis
#noalign continuous_map.compact_conv_nhd_subset_inter
#noalign continuous_map.compact_conv_nhd_compact_entourage_nonempty
#noalign continuous_map.compact_conv_nhd_filter_is_basis
#noalign continuous_map.compact_convergence_filter_basis
#noalign continuous_map.mem_compact_convergence_nhd_filter
#noalign continuous_map.compact_convergence_topology
#noalign continuous_map.nhds_compact_convergence
#noalign continuous_map.has_basis_nhds_compact_convergence
#noalign continuous_map.tendsto_iff_forall_compact_tendsto_uniformly_on'
#noalign continuous_map.compact_conv_nhd_subset_compact_open
#noalign continuous_map.Inter_compact_open_gen_subset_compact_conv_nhd
#noalign continuous_map.compact_open_eq_compact_convergence
#noalign continuous_map.compact_convergence_uniformity
#noalign continuous_map.has_basis_compact_convergence_uniformity_aux
#noalign continuous_map.mem_compact_convergence_uniformity

theorem _root_.Filter.HasBasis.compactConvergenceUniformity {Î¹ : Type*} {pi : Î¹ â†’ Prop}
    {s : Î¹ â†’ Set (Î² Ã— Î²)} (h : (ğ“¤ Î²).HasBasis pi s) :
    HasBasis (ğ“¤ C(Î±, Î²)) (fun p : Set Î± Ã— Î¹ => IsCompact p.1 âˆ§ pi p.2) fun p =>
      { fg : C(Î±, Î²) Ã— C(Î±, Î²) | âˆ€ x âˆˆ p.1, (fg.1 x, fg.2 x) âˆˆ s p.2 } := by
  rw [â† uniformEmbedding_toUniformOnFunIsCompact.comap_uniformity]
  exact .comap _ <| UniformOnFun.hasBasis_uniformity_of_basis _ _ {K | IsCompact K}
    âŸ¨âˆ…, isCompact_emptyâŸ© (directedOn_of_sup_mem fun _ _ â†¦ IsCompact.union) h
#align filter.has_basis.compact_convergence_uniformity Filter.HasBasis.compactConvergenceUniformity

theorem hasBasis_compactConvergenceUniformity :
    HasBasis (ğ“¤ C(Î±, Î²)) (fun p : Set Î± Ã— Set (Î² Ã— Î²) => IsCompact p.1 âˆ§ p.2 âˆˆ ğ“¤ Î²) fun p =>
      { fg : C(Î±, Î²) Ã— C(Î±, Î²) | âˆ€ x âˆˆ p.1, (fg.1 x, fg.2 x) âˆˆ p.2 } :=
  (basis_sets _).compactConvergenceUniformity
#align continuous_map.has_basis_compact_convergence_uniformity ContinuousMap.hasBasis_compactConvergenceUniformity

theorem mem_compactConvergence_entourage_iff (X : Set (C(Î±, Î²) Ã— C(Î±, Î²))) :
    X âˆˆ ğ“¤ C(Î±, Î²) â†”
      âˆƒ (K : Set Î±) (V : Set (Î² Ã— Î²)), IsCompact K âˆ§ V âˆˆ ğ“¤ Î² âˆ§
        { fg : C(Î±, Î²) Ã— C(Î±, Î²) | âˆ€ x âˆˆ K, (fg.1 x, fg.2 x) âˆˆ V } âŠ† X := by
  simp [hasBasis_compactConvergenceUniformity.mem_iff, and_assoc]
#align continuous_map.mem_compact_convergence_entourage_iff ContinuousMap.mem_compactConvergence_entourage_iff

/-- If `K` is a compact exhaustion of `Î±`
and `V i` bounded by `p i` is a basis of entourages of `Î²`,
then `fun (n, i) â†¦ {(f, g) | âˆ€ x âˆˆ K n, (f x, g x) âˆˆ V i}` bounded by `p i`
is a basis of entourages of `C(Î±, Î²)`. -/
theorem _root_.CompactExhaustion.hasBasis_compactConvergenceUniformity {Î¹ : Type*}
    {p : Î¹ â†’ Prop} {V : Î¹ â†’ Set (Î² Ã— Î²)} (K : CompactExhaustion Î±) (hb : (ğ“¤ Î²).HasBasis p V) :
    HasBasis (ğ“¤ C(Î±, Î²)) (fun i : â„• Ã— Î¹ â†¦ p i.2) fun i â†¦
      {fg | âˆ€ x âˆˆ K i.1, (fg.1 x, fg.2 x) âˆˆ V i.2} :=
  (UniformOnFun.hasBasis_uniformity_of_covering_of_basis {K | IsCompact K} K.isCompact
    (Monotone.directed_le K.subset) (fun _ â†¦ K.exists_superset_of_isCompact) hb).comap _

theorem _root_.CompactExhaustion.hasAntitoneBasis_compactConvergenceUniformity
    {V : â„• â†’ Set (Î² Ã— Î²)} (K : CompactExhaustion Î±) (hb : (ğ“¤ Î²).HasAntitoneBasis V) :
    HasAntitoneBasis (ğ“¤ C(Î±, Î²)) fun n â†¦ {fg | âˆ€ x âˆˆ K n, (fg.1 x, fg.2 x) âˆˆ V n} :=
  (UniformOnFun.hasAntitoneBasis_uniformity {K | IsCompact K} K.isCompact
    K.subset (fun _ â†¦ K.exists_superset_of_isCompact) hb).comap _

/-- If `Î±` is a weakly locally compact Ïƒ-compact space
(e.g., a proper pseudometric space or a compact spaces)
and the uniformity on `Î²` is pseudometrizable,
then the uniformity on `C(Î±, Î²)` is pseudometrizable too.
-/
instance [WeaklyLocallyCompactSpace Î±] [SigmaCompactSpace Î±] [IsCountablyGenerated (ğ“¤ Î²)] :
    IsCountablyGenerated (ğ“¤ (C(Î±, Î²))) :=
  let âŸ¨_V, hVâŸ© := exists_antitone_basis (ğ“¤ Î²)
  ((CompactExhaustion.choice Î±).hasAntitoneBasis_compactConvergenceUniformity
    hV).isCountablyGenerated

variable {Î¹ : Type uâ‚ƒ} {p : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} {f}

/-- Locally uniform convergence implies convergence in the compact-open topology. -/
theorem tendsto_of_tendstoLocallyUniformly (h : TendstoLocallyUniformly (fun i a => F i a) f p) :
    Tendsto F p (ğ“ f) := by
  rw [tendsto_iff_forall_compact_tendstoUniformlyOn]
  intro K hK
  rw [â† tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact hK]
  exact h.tendstoLocallyUniformlyOn
#align continuous_map.tendsto_of_tendsto_locally_uniformly ContinuousMap.tendsto_of_tendstoLocallyUniformly

/-- In a weakly locally compact space,
convergence in the compact-open topology is the same as locally uniform convergence.

The right-to-left implication holds in any topological space,
see `ContinuousMap.tendsto_of_tendstoLocallyUniformly`. -/
theorem tendsto_iff_tendstoLocallyUniformly [WeaklyLocallyCompactSpace Î±] :
    Tendsto F p (ğ“ f) â†” TendstoLocallyUniformly (fun i a => F i a) f p := by
  refine âŸ¨fun h V hV x â†¦ ?_, tendsto_of_tendstoLocallyUniformlyâŸ©
  rw [tendsto_iff_forall_compact_tendstoUniformlyOn] at h
  obtain âŸ¨n, hnâ‚, hnâ‚‚âŸ© := exists_compact_mem_nhds x
  exact âŸ¨n, hnâ‚‚, h n hnâ‚ V hVâŸ©
#align continuous_map.tendsto_iff_tendsto_locally_uniformly ContinuousMap.tendsto_iff_tendstoLocallyUniformly

@[deprecated tendsto_iff_tendstoLocallyUniformly]
theorem tendstoLocallyUniformly_of_tendsto [WeaklyLocallyCompactSpace Î±] (h : Tendsto F p (ğ“ f)) :
    TendstoLocallyUniformly (fun i a => F i a) f p :=
  tendsto_iff_tendstoLocallyUniformly.1 h
#align continuous_map.tendsto_locally_uniformly_of_tendsto ContinuousMap.tendstoLocallyUniformly_of_tendsto

section CompactDomain

variable [CompactSpace Î±]

theorem hasBasis_compactConvergenceUniformity_of_compact :
    HasBasis (ğ“¤ C(Î±, Î²)) (fun V : Set (Î² Ã— Î²) => V âˆˆ ğ“¤ Î²) fun V =>
      { fg : C(Î±, Î²) Ã— C(Î±, Î²) | âˆ€ x, (fg.1 x, fg.2 x) âˆˆ V } :=
  hasBasis_compactConvergenceUniformity.to_hasBasis
    (fun p hp => âŸ¨p.2, hp.2, fun _fg hfg x _hx => hfg xâŸ©) fun V hV =>
    âŸ¨âŸ¨univ, VâŸ©, âŸ¨isCompact_univ, hVâŸ©, fun _fg hfg x => hfg x (mem_univ x)âŸ©
#align continuous_map.has_basis_compact_convergence_uniformity_of_compact ContinuousMap.hasBasis_compactConvergenceUniformity_of_compact

/-- Convergence in the compact-open topology is the same as uniform convergence for sequences of
continuous functions on a compact space. -/
theorem tendsto_iff_tendstoUniformly :
    Tendsto F p (ğ“ f) â†” TendstoUniformly (fun i a => F i a) f p := by
  rw [tendsto_iff_forall_compact_tendstoUniformlyOn, â† tendstoUniformlyOn_univ]
  exact âŸ¨fun h => h univ isCompact_univ, fun h K _hK => h.mono (subset_univ K)âŸ©
#align continuous_map.tendsto_iff_tendsto_uniformly ContinuousMap.tendsto_iff_tendstoUniformly

end CompactDomain

end ContinuousMap
