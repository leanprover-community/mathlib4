/-
Copyright (c) 2021 Oliver Nash. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Oliver Nash, Yury Kudryashov
-/
import Mathlib.Topology.CompactOpen
import Mathlib.Topology.Compactness.CompactlyCoherentSpace
import Mathlib.Topology.Maps.Proper.Basic
import Mathlib.Topology.UniformSpace.Compact
import Mathlib.Topology.UniformSpace.UniformConvergenceTopology

/-!
# Compact convergence (uniform convergence on compact sets)

Given a topological space `Œ±` and a uniform space `Œ≤` (e.g., a metric space or a topological group),
the space of continuous maps `C(Œ±, Œ≤)` carries a natural uniform space structure.
We define this uniform space structure in this file
and also prove its basic properties.

## Main definitions

- `ContinuousMap.toUniformOnFunIsCompact`:
  natural embedding of `C(Œ±, Œ≤)`
  into the space `Œ± ‚Üí·µ§[{K | IsCompact K}] Œ≤` of all maps `Œ± ‚Üí Œ≤`
  with the uniform space structure of uniform convergence on compacts.

- `ContinuousMap.compactConvergenceUniformSpace`:
  the `UniformSpace` structure on `C(Œ±, Œ≤)` induced by the map above.

## Main results

* `ContinuousMap.mem_compactConvergence_entourage_iff`:
  a characterisation of the entourages of `C(Œ±, Œ≤)`.

  The entourages are generated by the following sets.
  Given `K : Set Œ±` and `V : Set (Œ≤ √ó Œ≤)`,
  let `E(K, V) : Set (C(Œ±, Œ≤) √ó C(Œ±, Œ≤))` be the set of pairs of continuous functions `Œ± ‚Üí Œ≤`
  which are `V`-close on `K`:
  $$
    E(K, V) = \{ (f, g) | ‚àÄ (x ‚àà K), (f x, g x) ‚àà V \}.
  $$
  Then the sets `E(K, V)` for all compact sets `K` and all entourages `V`
  form a basis of entourages of `C(Œ±, Œ≤)`.

  As usual, this basis of entourages provides a basis of neighbourhoods
  by fixing `f`, see `nhds_basis_uniformity'`.

* `Filter.HasBasis.compactConvergenceUniformity`:
  a similar statement that uses a basis of entourages of `Œ≤` instead of all entourages.
  It is useful, e.g., if `Œ≤` is a metric space.

* `ContinuousMap.tendsto_iff_forall_isCompact_tendstoUniformlyOn`:
  a sequence of functions `F‚Çô` in `C(Œ±, Œ≤)` converges in the compact-open topology to some `f`
  iff `F‚Çô` converges to `f` uniformly on each compact subset `K` of `Œ±`.

* Topology induced by the uniformity described above agrees with the compact-open topology.
  This is essentially the same as `ContinuousMap.tendsto_iff_forall_isCompact_tendstoUniformlyOn`.

  This fact is not available as a separate theorem.
  Instead, we override the projection of `ContinuousMap.compactConvergenceUniformity`
  to `TopologicalSpace` to be `ContinuousMap.compactOpen` and prove that they agree,
  see Note [forgetful inheritance] and implementation notes below.

* `ContinuousMap.tendsto_iff_tendstoLocallyUniformly`:
  on a weakly locally compact space,
  a sequence of functions `F‚Çô` in `C(Œ±, Œ≤)` converges to some `f`
  iff `F‚Çô` converges to `f` locally uniformly.

* `ContinuousMap.tendsto_iff_tendstoUniformly`:
  on a compact space, a sequence of functions `F‚Çô` in `C(Œ±, Œ≤)` converges to some `f`
  iff `F‚Çô` converges to `f` uniformly.

## Implementation details

For technical reasons (see Note [forgetful inheritance]),
instead of defining a `UniformSpace C(Œ±, Œ≤)` structure
and proving in a theorem that it agrees with the compact-open topology,
we override the projection right in the definition,
so that the resulting instance uses the compact-open topology.

## TODO

* Results about uniformly continuous functions `Œ≥ ‚Üí C(Œ±, Œ≤)`
  and uniform limits of sequences `Œπ ‚Üí Œ≥ ‚Üí C(Œ±, Œ≤)`.
-/

open Filter Set Topology UniformSpace
open scoped Uniformity UniformConvergence

universe u‚ÇÅ u‚ÇÇ u‚ÇÉ
variable {Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [TopologicalSpace Œ±] [UniformSpace Œ≤]
variable (K : Set Œ±) (V : Set (Œ≤ √ó Œ≤)) (f : C(Œ±, Œ≤))

namespace ContinuousMap

/-- Compact-open topology on `C(Œ±, Œ≤)` agrees with the topology of uniform convergence on compacts:
a family of continuous functions `F i` tends to `f` in the compact-open topology
if and only if the `F i` tends to `f` uniformly on all compact sets. -/
theorem tendsto_iff_forall_isCompact_tendstoUniformlyOn
    {Œπ : Type u‚ÇÉ} {p : Filter Œπ} {F : Œπ ‚Üí C(Œ±, Œ≤)} {f} :
    Tendsto F p (ùìù f) ‚Üî ‚àÄ K, IsCompact K ‚Üí TendstoUniformlyOn (fun i a => F i a) f p K := by
  rw [tendsto_nhds_compactOpen]
  constructor
  ¬∑ -- Let us prove that convergence in the compact-open topology
    -- implies uniform convergence on compacts.
    -- Consider a compact set `K`
    intro h K hK
    -- Since `K` is compact, it suffices to prove locally uniform convergence
    rw [‚Üê tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact hK]
    -- Now choose an entourage `U` in the codomain and a point `x ‚àà K`.
    intro U hU x _
    -- Choose an open symmetric entourage `V` such that `V ‚óã V ‚äÜ U`.
    rcases comp_open_symm_mem_uniformity_sets hU with ‚ü®V, hV, hVo, hVsymm, hVU‚ü©
    -- Then choose a closed entourage `W ‚äÜ V`
    rcases mem_uniformity_isClosed hV with ‚ü®W, hW, hWc, hWU‚ü©
    -- Consider `s = {y ‚àà K | (f x, f y) ‚àà W}`
    set s := K ‚à© f ‚Åª¬π' ball (f x) W
    -- This is a neighbourhood of `x` within `K`, because `W` is an entourage.
    have hnhds : s ‚àà ùìù[K] x := inter_mem_nhdsWithin _ <| f.continuousAt _ (ball_mem_nhds _ hW)
    -- This set is compact because it is an intersection of `K`
    -- with a closed set `{y | (f x, f y) ‚àà W} = f ‚Åª¬π' UniformSpace.ball (f x) W`
    have hcomp : IsCompact s := hK.inter_right <| (isClosed_ball _ hWc).preimage f.continuous
    -- `f` maps `s` to the open set `ball (f x) V = {z | (f x, z) ‚àà V}`
    have hmaps : MapsTo f s (ball (f x) V) := fun x hx ‚Ü¶ hWU hx.2
    use s, hnhds
    -- Continuous maps `F i` in a neighbourhood of `f` map `s` to `ball (f x) V` as well.
    refine (h s hcomp _ (isOpen_ball _ hVo) hmaps).mono fun g hg y hy ‚Ü¶ ?_
    -- Then for `y ‚àà s` we have `(f y, f x) ‚àà V` and `(f x, F i y) ‚àà V`, thus `(f y, F i y) ‚àà U`
    exact hVU ‚ü®f x, hVsymm.mk_mem_comm.2 <| hmaps hy, hg hy‚ü©
  ¬∑ -- Now we prove that uniform convergence on compacts
    -- implies convergence in the compact-open topology
    -- Consider a compact set `K`, an open set `U`, and a continuous map `f` that maps `K` to `U`
    intro h K hK U hU hf
    -- Due to Lebesgue number lemma, there exists an entourage `V`
    -- such that `U` includes the `V`-thickening of `f '' K`.
    rcases lebesgue_number_of_compact_open (hK.image (map_continuous f)) hU hf.image_subset
        with ‚ü®V, hV, -, hVf‚ü©
    -- Then any continuous map that is uniformly `V`-close to `f` on `K`
    -- maps `K` to `U` as well
    filter_upwards [h K hK V hV] with g hg x hx using hVf _ (mem_image_of_mem f hx) (hg x hx)

/-- Interpret a bundled continuous map as an element of `Œ± ‚Üí·µ§[{K | IsCompact K}] Œ≤`.

We use this map to induce the `UniformSpace` structure on `C(Œ±, Œ≤)`. -/
def toUniformOnFunIsCompact (f : C(Œ±, Œ≤)) : Œ± ‚Üí·µ§[{K | IsCompact K}] Œ≤ :=
  UniformOnFun.ofFun {K | IsCompact K} f

@[simp]
theorem toUniformOnFun_toFun (f : C(Œ±, Œ≤)) :
    UniformOnFun.toFun _ f.toUniformOnFunIsCompact = f := rfl

theorem range_toUniformOnFunIsCompact :
    range (toUniformOnFunIsCompact) = {f : UniformOnFun Œ± Œ≤ {K | IsCompact K} | Continuous f} :=
  Set.ext fun f ‚Ü¶ ‚ü®fun g ‚Ü¶ g.choose_spec ‚ñ∏ g.choose.2, fun hf ‚Ü¶ ‚ü®‚ü®f, hf‚ü©, rfl‚ü©‚ü©

open UniformSpace in
/-- Uniform space structure on `C(Œ±, Œ≤)`.

The uniformity comes from `Œ± ‚Üí·µ§[{K | IsCompact K}] Œ≤` (i.e., `UniformOnFun Œ± Œ≤ {K | IsCompact K}`)
which defines topology of uniform convergence on compact sets.
We use `ContinuousMap.tendsto_iff_forall_isCompact_tendstoUniformlyOn`
to show that the induced topology agrees with the compact-open topology
and replace the topology with `compactOpen` to avoid non-defeq diamonds,
see Note [forgetful inheritance]. -/
instance compactConvergenceUniformSpace : UniformSpace C(Œ±, Œ≤) :=
  .replaceTopology (.comap toUniformOnFunIsCompact inferInstance) <| by
    refine TopologicalSpace.ext_nhds fun f ‚Ü¶ eq_of_forall_le_iff fun l ‚Ü¶ ?_
    simp_rw [‚Üê tendsto_id', tendsto_iff_forall_isCompact_tendstoUniformlyOn,
      nhds_induced, tendsto_comap_iff, UniformOnFun.tendsto_iff_tendstoUniformlyOn]
    rfl

theorem isUniformEmbedding_toUniformOnFunIsCompact :
    IsUniformEmbedding (toUniformOnFunIsCompact : C(Œ±, Œ≤) ‚Üí Œ± ‚Üí·µ§[{K | IsCompact K}] Œ≤) where
  comap_uniformity := rfl
  injective := DFunLike.coe_injective

open UniformOnFun in
/-- `f : X ‚Üí C(Œ±, Œ≤)` is continuous if any only if it is continuous when reinterpreted as a
map `f : X ‚Üí Œ± ‚Üí·µ§[{K | IsCompact K}] Œ≤`. -/
theorem continuous_iff_continuous_uniformOnFun {X : Type*} [TopologicalSpace X] (f : X ‚Üí C(Œ±, Œ≤)) :
    Continuous f ‚Üî Continuous (fun x ‚Ü¶ ofFun {K | IsCompact K} (f x)) :=
  isUniformEmbedding_toUniformOnFunIsCompact.isInducing.continuous_iff

-- The following definitions and theorems
-- used to be a part of the construction of the `UniformSpace C(Œ±, Œ≤)` structure
-- before it was migrated to `UniformOnFun`

theorem _root_.Filter.HasBasis.compactConvergenceUniformity {Œπ : Type*} {pi : Œπ ‚Üí Prop}
    {s : Œπ ‚Üí Set (Œ≤ √ó Œ≤)} (h : (ùì§ Œ≤).HasBasis pi s) :
    HasBasis (ùì§ C(Œ±, Œ≤)) (fun p : Set Œ± √ó Œπ => IsCompact p.1 ‚àß pi p.2) fun p =>
      { fg : C(Œ±, Œ≤) √ó C(Œ±, Œ≤) | ‚àÄ x ‚àà p.1, (fg.1 x, fg.2 x) ‚àà s p.2 } := by
  rw [‚Üê isUniformEmbedding_toUniformOnFunIsCompact.comap_uniformity]
  exact .comap _ <| UniformOnFun.hasBasis_uniformity_of_basis _ _ {K | IsCompact K}
    ‚ü®‚àÖ, isCompact_empty‚ü© (directedOn_of_sup_mem fun _ _ ‚Ü¶ IsCompact.union) h

theorem hasBasis_compactConvergenceUniformity :
    HasBasis (ùì§ C(Œ±, Œ≤)) (fun p : Set Œ± √ó Set (Œ≤ √ó Œ≤) => IsCompact p.1 ‚àß p.2 ‚àà ùì§ Œ≤) fun p =>
      { fg : C(Œ±, Œ≤) √ó C(Œ±, Œ≤) | ‚àÄ x ‚àà p.1, (fg.1 x, fg.2 x) ‚àà p.2 } :=
  (basis_sets _).compactConvergenceUniformity

theorem mem_compactConvergence_entourage_iff (X : Set (C(Œ±, Œ≤) √ó C(Œ±, Œ≤))) :
    X ‚àà ùì§ C(Œ±, Œ≤) ‚Üî
      ‚àÉ (K : Set Œ±) (V : Set (Œ≤ √ó Œ≤)), IsCompact K ‚àß V ‚àà ùì§ Œ≤ ‚àß
        { fg : C(Œ±, Œ≤) √ó C(Œ±, Œ≤) | ‚àÄ x ‚àà K, (fg.1 x, fg.2 x) ‚àà V } ‚äÜ X := by
  simp [hasBasis_compactConvergenceUniformity.mem_iff, and_assoc]

/-- If `K` is a compact exhaustion of `Œ±`
and `V i` bounded by `p i` is a basis of entourages of `Œ≤`,
then `fun (n, i) ‚Ü¶ {(f, g) | ‚àÄ x ‚àà K n, (f x, g x) ‚àà V i}` bounded by `p i`
is a basis of entourages of `C(Œ±, Œ≤)`. -/
theorem _root_.CompactExhaustion.hasBasis_compactConvergenceUniformity {Œπ : Type*}
    {p : Œπ ‚Üí Prop} {V : Œπ ‚Üí Set (Œ≤ √ó Œ≤)} (K : CompactExhaustion Œ±) (hb : (ùì§ Œ≤).HasBasis p V) :
    HasBasis (ùì§ C(Œ±, Œ≤)) (fun i : ‚Ñï √ó Œπ ‚Ü¶ p i.2) fun i ‚Ü¶
      {fg | ‚àÄ x ‚àà K i.1, (fg.1 x, fg.2 x) ‚àà V i.2} :=
  (UniformOnFun.hasBasis_uniformity_of_covering_of_basis {K | IsCompact K} K.isCompact
    (Monotone.directed_le K.subset) (fun _ ‚Ü¶ K.exists_superset_of_isCompact) hb).comap _

theorem _root_.CompactExhaustion.hasAntitoneBasis_compactConvergenceUniformity
    {V : ‚Ñï ‚Üí Set (Œ≤ √ó Œ≤)} (K : CompactExhaustion Œ±) (hb : (ùì§ Œ≤).HasAntitoneBasis V) :
    HasAntitoneBasis (ùì§ C(Œ±, Œ≤)) fun n ‚Ü¶ {fg | ‚àÄ x ‚àà K n, (fg.1 x, fg.2 x) ‚àà V n} :=
  (UniformOnFun.hasAntitoneBasis_uniformity {K | IsCompact K} K.isCompact
    K.subset (fun _ ‚Ü¶ K.exists_superset_of_isCompact) hb).comap _

/-- If `Œ±` is a weakly locally compact œÉ-compact space
(e.g., a proper pseudometric space or a compact spaces)
and the uniformity on `Œ≤` is pseudometrizable,
then the uniformity on `C(Œ±, Œ≤)` is pseudometrizable too.
-/
instance [WeaklyLocallyCompactSpace Œ±] [SigmaCompactSpace Œ±] [IsCountablyGenerated (ùì§ Œ≤)] :
    IsCountablyGenerated (ùì§ (C(Œ±, Œ≤))) :=
  let ‚ü®_V, hV‚ü© := exists_antitone_basis (ùì§ Œ≤)
  ((CompactExhaustion.choice Œ±).hasAntitoneBasis_compactConvergenceUniformity
    hV).isCountablyGenerated

variable {Œπ : Type u‚ÇÉ} {p : Filter Œπ} {F : Œπ ‚Üí C(Œ±, Œ≤)} {f}

/-- Locally uniform convergence implies convergence in the compact-open topology. -/
theorem tendsto_of_tendstoLocallyUniformly (h : TendstoLocallyUniformly (fun i a => F i a) f p) :
    Tendsto F p (ùìù f) := by
  rw [tendsto_iff_forall_isCompact_tendstoUniformlyOn]
  intro K hK
  rw [‚Üê tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact hK]
  exact h.tendstoLocallyUniformlyOn

/-- In a weakly locally compact space,
convergence in the compact-open topology is the same as locally uniform convergence.

The right-to-left implication holds in any topological space,
see `ContinuousMap.tendsto_of_tendstoLocallyUniformly`. -/
theorem tendsto_iff_tendstoLocallyUniformly [WeaklyLocallyCompactSpace Œ±] :
    Tendsto F p (ùìù f) ‚Üî TendstoLocallyUniformly (fun i a => F i a) f p := by
  refine ‚ü®fun h V hV x ‚Ü¶ ?_, tendsto_of_tendstoLocallyUniformly‚ü©
  rw [tendsto_iff_forall_isCompact_tendstoUniformlyOn] at h
  obtain ‚ü®n, hn‚ÇÅ, hn‚ÇÇ‚ü© := exists_compact_mem_nhds x
  exact ‚ü®n, hn‚ÇÇ, h n hn‚ÇÅ V hV‚ü©

section Functorial

variable {Œ≥ Œ¥ : Type*} [TopologicalSpace Œ≥] [UniformSpace Œ¥]

theorem uniformContinuous_comp (g : C(Œ≤, Œ¥)) (hg : UniformContinuous g) :
    UniformContinuous (ContinuousMap.comp g : C(Œ±, Œ≤) ‚Üí C(Œ±, Œ¥)) :=
  isUniformEmbedding_toUniformOnFunIsCompact.uniformContinuous_iff.mpr <|
    UniformOnFun.postcomp_uniformContinuous hg |>.comp
      isUniformEmbedding_toUniformOnFunIsCompact.uniformContinuous

theorem isUniformInducing_comp (g : C(Œ≤, Œ¥)) (hg : IsUniformInducing g) :
    IsUniformInducing (ContinuousMap.comp g : C(Œ±, Œ≤) ‚Üí C(Œ±, Œ¥)) :=
  isUniformEmbedding_toUniformOnFunIsCompact.isUniformInducing.of_comp_iff.mp <|
    UniformOnFun.postcomp_isUniformInducing hg |>.comp
      isUniformEmbedding_toUniformOnFunIsCompact.isUniformInducing

theorem isUniformEmbedding_comp (g : C(Œ≤, Œ¥)) (hg : IsUniformEmbedding g) :
    IsUniformEmbedding (ContinuousMap.comp g : C(Œ±, Œ≤) ‚Üí C(Œ±, Œ¥)) :=
  isUniformEmbedding_toUniformOnFunIsCompact.of_comp_iff.mp <|
    UniformOnFun.postcomp_isUniformEmbedding hg |>.comp
      isUniformEmbedding_toUniformOnFunIsCompact

theorem uniformContinuous_comp_left (g : C(Œ±, Œ≥)) :
    UniformContinuous (fun f ‚Ü¶ f.comp g : C(Œ≥, Œ≤) ‚Üí C(Œ±, Œ≤)) :=
  isUniformEmbedding_toUniformOnFunIsCompact.uniformContinuous_iff.mpr <|
    UniformOnFun.precomp_uniformContinuous (fun _ hK ‚Ü¶ hK.image g.continuous) |>.comp
      isUniformEmbedding_toUniformOnFunIsCompact.uniformContinuous

/-- Any pair of a homeomorphism `X ‚âÉ‚Çú Z` and an isomorphism `Y ‚âÉ·µ§ T` of uniform spaces gives rise
to an isomorphism `C(X, Y) ‚âÉ·µ§ C(Z, T)`. -/
protected def _root_.UniformEquiv.arrowCongr (œÜ : Œ± ‚âÉ‚Çú Œ≥) (œà : Œ≤ ‚âÉ·µ§ Œ¥) :
    C(Œ±, Œ≤) ‚âÉ·µ§ C(Œ≥, Œ¥) where
  toFun f := .comp œà.toHomeomorph <| f.comp œÜ.symm
  invFun f := .comp œà.symm.toHomeomorph <| f.comp œÜ
  left_inv f := ext fun _ ‚Ü¶ œà.left_inv (f _) |>.trans <| congrArg f <| œÜ.left_inv _
  right_inv f := ext fun _ ‚Ü¶ œà.right_inv (f _) |>.trans <| congrArg f <| œÜ.right_inv _
  uniformContinuous_toFun := uniformContinuous_comp _ œà.uniformContinuous |>.comp <|
    uniformContinuous_comp_left _
  uniformContinuous_invFun := uniformContinuous_comp _ œà.symm.uniformContinuous |>.comp <|
    uniformContinuous_comp_left _

end Functorial

section CompactDomain

variable [CompactSpace Œ±]

theorem hasBasis_compactConvergenceUniformity_of_compact :
    HasBasis (ùì§ C(Œ±, Œ≤)) (fun V : Set (Œ≤ √ó Œ≤) => V ‚àà ùì§ Œ≤) fun V ‚Ü¶
      {fg : C(Œ±, Œ≤) √ó C(Œ±, Œ≤) | ‚àÄ x, (fg.1 x, fg.2 x) ‚àà V} :=
  hasBasis_compactConvergenceUniformity.to_hasBasis
    (fun p hp => ‚ü®p.2, hp.2, fun _fg hfg x _hx => hfg x‚ü©) fun V hV ‚Ü¶
    ‚ü®‚ü®univ, V‚ü©, ‚ü®isCompact_univ, hV‚ü©, fun _fg hfg x => hfg x (mem_univ x)‚ü©

theorem _root_.Filter.HasBasis.compactConvergenceUniformity_of_compact
    {Œπ : Sort*} {p : Œπ ‚Üí Prop} {V : Œπ ‚Üí Set (Œ≤ √ó Œ≤)} (h : (ùì§ Œ≤).HasBasis p V) :
    HasBasis (ùì§ C(Œ±, Œ≤)) p fun i ‚Ü¶ {fg : C(Œ±, Œ≤) √ó C(Œ±, Œ≤) | ‚àÄ x, (fg.1 x, fg.2 x) ‚àà V i} :=
  hasBasis_compactConvergenceUniformity_of_compact.to_hasBasis
    (fun _U hU ‚Ü¶ (h.mem_iff.mp hU).imp fun _i ‚ü®hpi, hi‚ü© ‚Ü¶ ‚ü®hpi, fun _ h a ‚Ü¶ hi <| h a‚ü©)
    fun i hi ‚Ü¶ ‚ü®V i, h.mem_of_mem hi, .rfl‚ü©

open UniformFun in
theorem isUniformEmbedding_uniformFunOfFun :
    IsUniformEmbedding ((ofFun ¬∑) : C(Œ±, Œ≤) ‚Üí Œ± ‚Üí·µ§ Œ≤) where
  comap_uniformity := UniformOnFun.uniformEquivUniformFun Œ≤ _ isCompact_univ
    |>.isUniformEmbedding.comp isUniformEmbedding_toUniformOnFunIsCompact
    |>.comap_uniformity
  injective := DFunLike.coe_injective

/-- Convergence in the compact-open topology is the same as uniform convergence for sequences of
continuous functions on a compact space. -/
theorem tendsto_iff_tendstoUniformly :
    Tendsto F p (ùìù f) ‚Üî TendstoUniformly (fun i a => F i a) f p := by
  simp [isUniformEmbedding_uniformFunOfFun.isInducing.tendsto_nhds_iff,
    UniformFun.tendsto_iff_tendstoUniformly, Function.comp_def]

open UniformFun in
/-- When `Œ±` is compact, `f : X ‚Üí C(Œ±, Œ≤)` is continuous if any only if it is continuous when
reinterpreted as a map `f : X ‚Üí Œ± ‚Üí·µ§ Œ≤`. -/
theorem continuous_iff_continuous_uniformFun {X : Type*} [TopologicalSpace X] (f : X ‚Üí C(Œ±, Œ≤)) :
    Continuous f ‚Üî Continuous (fun x ‚Ü¶ ofFun (f x)) :=
  isUniformEmbedding_uniformFunOfFun.isInducing.continuous_iff

end CompactDomain

section ContinuousOnRestrict

/-- Given functions `F i, f` which are continuous on a compact set `s`, `F` tends to `f`
uniformly on `s` if and only if the restrictions (as elements of `C(s, Œ≤)`) converge. -/
theorem _root_.ContinuousOn.tendsto_restrict_iff_tendstoUniformlyOn {s : Set Œ±} [CompactSpace s]
    {f : Œ± ‚Üí Œ≤} (hf : ContinuousOn f s) {Œπ : Type*} {p : Filter Œπ}
    {F : Œπ ‚Üí Œ± ‚Üí Œ≤} (hF : ‚àÄ i, ContinuousOn (F i) s) :
    Tendsto (fun i ‚Ü¶ ‚ü®_, (hF i).restrict‚ü© : Œπ ‚Üí C(s, Œ≤)) p (ùìù ‚ü®_, hf.restrict‚ü©) ‚Üî
      TendstoUniformlyOn F f p s := by
  rw [ContinuousMap.tendsto_iff_tendstoUniformly, tendstoUniformlyOn_iff_tendstoUniformly_comp_coe]
  congr!

open UniformOnFun in
/-- A family `f : X ‚Üí Œ± ‚Üí Œ≤`, each of which is continuous on a compact set `s : Set Œ±` is
continuous in the topology `X ‚Üí Œ± ‚Üí·µ§[{s}] Œ≤` if and only if the family of continuous restrictions
`X ‚Üí C(s, Œ≤)` is continuous. -/
theorem _root_.ContinuousOn.continuous_restrict_iff_continuous_uniformOnFun
    {X : Type*} [TopologicalSpace X] {f : X ‚Üí Œ± ‚Üí Œ≤} {s : Set Œ±}
    (hf : ‚àÄ x, ContinuousOn (f x) s) [CompactSpace s] :
    Continuous (fun x ‚Ü¶ ‚ü®_, (hf x).restrict‚ü© : X ‚Üí C(s, Œ≤)) ‚Üî
      Continuous (fun x ‚Ü¶ ofFun {s} (f x)) := by
  rw [ContinuousMap.continuous_iff_continuous_uniformFun, UniformOnFun.continuous_rng_iff]
  simp [Function.comp_def]

end ContinuousOnRestrict

theorem uniformSpace_eq_inf_precomp_of_cover {Œ¥‚ÇÅ Œ¥‚ÇÇ : Type*} [TopologicalSpace Œ¥‚ÇÅ]
    [TopologicalSpace Œ¥‚ÇÇ] (œÜ‚ÇÅ : C(Œ¥‚ÇÅ, Œ±)) (œÜ‚ÇÇ : C(Œ¥‚ÇÇ, Œ±)) (h_proper‚ÇÅ : IsProperMap œÜ‚ÇÅ)
    (h_proper‚ÇÇ : IsProperMap œÜ‚ÇÇ) (h_cover : range œÜ‚ÇÅ ‚à™ range œÜ‚ÇÇ = univ) :
    (inferInstanceAs <| UniformSpace C(Œ±, Œ≤)) =
      .comap (comp ¬∑ œÜ‚ÇÅ) inferInstance ‚äì
      .comap (comp ¬∑ œÜ‚ÇÇ) inferInstance := by
  -- We check the analogous result for `UniformOnFun` using
  -- `UniformOnFun.uniformSpace_eq_inf_precomp_of_cover`...
  set ùîñ : Set (Set Œ±) := {K | IsCompact K}
  set ùîó‚ÇÅ : Set (Set Œ¥‚ÇÅ) := {K | IsCompact K}
  set ùîó‚ÇÇ : Set (Set Œ¥‚ÇÇ) := {K | IsCompact K}
  have h_image‚ÇÅ : MapsTo (œÜ‚ÇÅ '' ¬∑) ùîó‚ÇÅ ùîñ := fun K hK ‚Ü¶ hK.image œÜ‚ÇÅ.continuous
  have h_image‚ÇÇ : MapsTo (œÜ‚ÇÇ '' ¬∑) ùîó‚ÇÇ ùîñ := fun K hK ‚Ü¶ hK.image œÜ‚ÇÇ.continuous
  have h_preimage‚ÇÅ : MapsTo (œÜ‚ÇÅ ‚Åª¬π' ¬∑) ùîñ ùîó‚ÇÅ := fun K ‚Ü¶ h_proper‚ÇÅ.isCompact_preimage
  have h_preimage‚ÇÇ : MapsTo (œÜ‚ÇÇ ‚Åª¬π' ¬∑) ùîñ ùîó‚ÇÇ := fun K ‚Ü¶ h_proper‚ÇÇ.isCompact_preimage
  have h_cover' : ‚àÄ S ‚àà ùîñ, S ‚äÜ range œÜ‚ÇÅ ‚à™ range œÜ‚ÇÇ := fun S _ ‚Ü¶ h_cover ‚ñ∏ subset_univ _
  -- ... and we just pull it back.
  simp_rw +zetaDelta [compactConvergenceUniformSpace, replaceTopology_eq,
    UniformOnFun.uniformSpace_eq_inf_precomp_of_cover _ _ _ _ _
      h_image‚ÇÅ h_image‚ÇÇ h_preimage‚ÇÅ h_preimage‚ÇÇ h_cover',
    UniformSpace.comap_inf, ‚Üê UniformSpace.comap_comap]
  rfl

theorem uniformSpace_eq_iInf_precomp_of_cover {Œ¥ : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (Œ¥ i)]
    (œÜ : Œ† i, C(Œ¥ i, Œ±)) (h_proper : ‚àÄ i, IsProperMap (œÜ i))
    (h_lf : LocallyFinite fun i ‚Ü¶ range (œÜ i)) (h_cover : ‚ãÉ i, range (œÜ i) = univ) :
    (inferInstanceAs <| UniformSpace C(Œ±, Œ≤)) = ‚®Ö i, .comap (comp ¬∑ (œÜ i)) inferInstance := by
  -- We check the analogous result for `UniformOnFun` using
  -- `UniformOnFun.uniformSpace_eq_iInf_precomp_of_cover`...
  set ùîñ : Set (Set Œ±) := {K | IsCompact K}
  set ùîó : Œ† i, Set (Set (Œ¥ i)) := fun i ‚Ü¶ {K | IsCompact K}
  have h_image : ‚àÄ i, MapsTo (œÜ i '' ¬∑) (ùîó i) ùîñ := fun i K hK ‚Ü¶ hK.image (œÜ i).continuous
  have h_preimage : ‚àÄ i, MapsTo (œÜ i ‚Åª¬π' ¬∑) ùîñ (ùîó i) := fun i K ‚Ü¶ (h_proper i).isCompact_preimage
  have h_cover' : ‚àÄ S ‚àà ùîñ, ‚àÉ I : Set Œπ, I.Finite ‚àß S ‚äÜ ‚ãÉ i ‚àà I, range (œÜ i) := fun S hS ‚Ü¶ by
    refine ‚ü®{i | (range (œÜ i) ‚à© S).Nonempty}, h_lf.finite_nonempty_inter_compact hS,
      inter_eq_right.mp ?_‚ü©
    simp_rw [iUnion‚ÇÇ_inter, mem_setOf, iUnion_nonempty_self, ‚Üê iUnion_inter, h_cover, univ_inter]
  -- ... and we just pull it back.
  simp_rw +zetaDelta [compactConvergenceUniformSpace, replaceTopology_eq,
    UniformOnFun.uniformSpace_eq_iInf_precomp_of_cover _ _ _ h_image h_preimage h_cover',
    UniformSpace.comap_iInf, ‚Üê UniformSpace.comap_comap]
  rfl

section CompleteSpace

variable [CompleteSpace Œ≤]

/-- If the topology on `Œ±` is generated by its restrictions to compact sets, then the space of
continuous maps `C(Œ±, Œ≤)` is complete (w.r.t. the compact convergence uniformity).

Sufficient conditions on `Œ±` to satisfy this condition are (weak) local compactness and sequential
compactness. -/
instance instCompleteSpaceOfCompactlyCoherentSpace [CompactlyCoherentSpace Œ±] :
    CompleteSpace C(Œ±, Œ≤) := by
  rw [completeSpace_iff_isComplete_range
    isUniformEmbedding_toUniformOnFunIsCompact.isUniformInducing,
    range_toUniformOnFunIsCompact, ‚Üê completeSpace_coe_iff_isComplete]
  exact (UniformOnFun.isClosed_setOf_continuous
    CompactlyCoherentSpace.isCoherentWith).completeSpace_coe

@[deprecated (since := "2025-06-03")]
alias completeSpace_of_isCoherentWith := instCompleteSpaceOfCompactlyCoherentSpace

end CompleteSpace

/-- If `C(Œ±, Œ≤)` is a complete space, then for any (possibly, discontinuous) function `f`
and any set `s`, the set of functions `g : C(Œ±, Œ≤)` that are equal to `f` on `s`
is a complete set.

Note that this set does not have to be a closed set when `Œ≤` is not T0.
This lemma is useful to prove that, e.g., the space of paths between two points
and the space of homotopies between two continuous maps are complete spaces,
without assuming that the codomain is a Hausdorff space. -/
theorem isComplete_setOf_eqOn [CompleteSpace C(Œ±, Œ≤)] (f : Œ± ‚Üí Œ≤) (s : Set Œ±) :
    IsComplete {g : C(Œ±, Œ≤) | EqOn g f s} := by
  classical
  intro l hlc hlf
  rcases CompleteSpace.complete hlc with ‚ü®f', hf'‚ü©
  have := hlc.1
  have H‚ÇÅ : ‚àÄ x ‚àà s, Inseparable (f x) (f' x) := fun x hx ‚Ü¶ by
    refine tendsto_nhds_unique_inseparable ?_ ((continuous_eval_const x).continuousAt.mono_left hf')
    refine tendsto_const_nhds.congr' <| .filter_mono ?_ hlf
    exact fun _ h ‚Ü¶ (h hx).symm
  have H‚ÇÇ (x) : Inseparable (s.piecewise f f' x) (f' x) := by
    by_cases hx : x ‚àà s <;> simp [hx, H‚ÇÅ, Inseparable.refl]
  set g : C(Œ±, Œ≤) :=
    ‚ü®s.piecewise f f', (continuous_congr_of_inseparable H‚ÇÇ).mpr <| map_continuous f'‚ü©
  refine ‚ü®g, Set.piecewise_eqOn _ _ _, hf'.trans_eq ?_‚ü©
  rwa [eq_comm, ‚Üê Inseparable, ‚Üê inseparable_coe, inseparable_pi]

end ContinuousMap
