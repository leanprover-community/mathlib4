/-
Copyright (c) 2021 Oliver Nash. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Oliver Nash, Yury Kudryashov
-/
import Mathlib.Topology.CompactOpen
import Mathlib.Topology.LocallyFinite
import Mathlib.Topology.ProperMap
import Mathlib.Topology.UniformSpace.UniformConvergenceTopology

#align_import topology.uniform_space.compact_convergence from "leanprover-community/mathlib"@"dc6c365e751e34d100e80fe6e314c3c3e0fd2988"

/-!
# Compact convergence (uniform convergence on compact sets)

Given a topological space `Œ±` and a uniform space `Œ≤` (e.g., a metric space or a topological group),
the space of continuous maps `C(Œ±, Œ≤)` carries a natural uniform space structure.
We define this uniform space structure in this file
and also prove its basic properties.

## Main definitions

- `ContinuousMap.toUniformOnFunIsCompact`:
  natural embedding of `C(Œ±, Œ≤)`
  into the space `Œ± ‚Üí·µ§[{K | IsCompact K}] Œ≤` of all maps `Œ± ‚Üí Œ≤`
  with the uniform space structure of uniform convergence on compacts.

- `ContinuousMap.compactConvergenceUniformSpace`:
  the `UniformSpace` structure on `C(Œ±, Œ≤)` induced by the map above.

## Main results

* `ContinuousMap.mem_compactConvergence_entourage_iff`:
  a characterisation of the entourages of `C(Œ±, Œ≤)`.

  The entourages are generated by the following sets.
  Given `K : Set Œ±` and `V : Set (Œ≤ √ó Œ≤)`,
  let `E(K, V) : Set (C(Œ±, Œ≤) √ó C(Œ±, Œ≤))` be the set of pairs of continuous functions `Œ± ‚Üí Œ≤`
  which are `V`-close on `K`:
  $$
    E(K, V) = \{ (f, g) | ‚àÄ (x ‚àà K), (f x, g x) ‚àà V \}.
  $$
  Then the sets `E(K, V)` for all compact sets `K` and all entourages `V`
  form a basis of entourages of `C(Œ±, Œ≤)`.

  As usual, this basis of entourages provides a basis of neighbourhoods
  by fixing `f`, see `nhds_basis_uniformity'`.

* `Filter.HasBasis.compactConvergenceUniformity`:
  a similar statement that uses a basis of entourages of `Œ≤` instead of all entourages.
  It is useful, e.g., if `Œ≤` is a metric space.

* `ContinuousMap.tendsto_iff_forall_compact_tendstoUniformlyOn`:
  a sequence of functions `F‚Çô` in `C(Œ±, Œ≤)` converges in the compact-open topology to some `f`
  iff `F‚Çô` converges to `f` uniformly on each compact subset `K` of `Œ±`.

* Topology induced by the uniformity described above agrees with the compact-open topology.
  This is essentially the same as `ContinuousMap.tendsto_iff_forall_compact_tendstoUniformlyOn`.

  This fact is not available as a separate theorem.
  Instead, we override the projection of `ContinuousMap.compactConvergenceUniformity`
  to `TopologicalSpace` to be `ContinuousMap.compactOpen` and prove that they agree,
  see Note [forgetful inheritance] and implementation notes below.

* `ContinuousMap.tendsto_iff_tendstoLocallyUniformly`:
  on a weakly locally compact space,
  a sequence of functions `F‚Çô` in `C(Œ±, Œ≤)` converges to some `f`
  iff `F‚Çô` converges to `f` locally uniformly.

* `ContinuousMap.tendsto_iff_tendstoUniformly`:
  on a compact space, a sequence of functions `F‚Çô` in `C(Œ±, Œ≤)` converges to some `f`
  iff `F‚Çô` converges to `f` uniformly.

## Implementation details

For technical reasons (see Note [forgetful inheritance]),
instead of defining a `UniformSpace C(Œ±, Œ≤)` structure
and proving in a theorem that it agrees with the compact-open topology,
we override the projection right in the definition,
so that the resulting instance uses the compact-open topology.

## TODO

* Results about uniformly continuous functions `Œ≥ ‚Üí C(Œ±, Œ≤)`
  and uniform limits of sequences `Œπ ‚Üí Œ≥ ‚Üí C(Œ±, Œ≤)`.
-/


universe u‚ÇÅ u‚ÇÇ u‚ÇÉ

open scoped Uniformity Topology UniformConvergence

open UniformSpace Set Filter

variable {Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [TopologicalSpace Œ±] [UniformSpace Œ≤]
variable (K : Set Œ±) (V : Set (Œ≤ √ó Œ≤)) (f : C(Œ±, Œ≤))

namespace ContinuousMap

/-- Compact-open topology on `C(Œ±, Œ≤)` agrees with the topology of uniform convergence on compacts:
a family of continuous functions `F i` tends to `f` in the compact-open topology
if and only if the `F i` tends to `f` uniformly on all compact sets. -/
theorem tendsto_iff_forall_compact_tendstoUniformlyOn
    {Œπ : Type u‚ÇÉ} {p : Filter Œπ} {F : Œπ ‚Üí C(Œ±, Œ≤)} {f} :
    Tendsto F p (ùìù f) ‚Üî ‚àÄ K, IsCompact K ‚Üí TendstoUniformlyOn (fun i a => F i a) f p K := by
  rw [tendsto_nhds_compactOpen]
  constructor
  ¬∑ -- Let us prove that convergence in the compact-open topology
    -- implies uniform convergence on compacts.
    -- Consider a compact set `K`
    intro h K hK
    -- Since `K` is compact, it suffices to prove locally uniform convergence
    rw [‚Üê tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact hK]
    -- Now choose an entourage `U` in the codomain and a point `x ‚àà K`.
    intro U hU x _
    -- Choose an open symmetric entourage `V` such that `V ‚óã V ‚äÜ U`.
    rcases comp_open_symm_mem_uniformity_sets hU with ‚ü®V, hV, hVo, hVsymm, hVU‚ü©
    -- Then choose a closed entourage `W ‚äÜ V`
    rcases mem_uniformity_isClosed hV with ‚ü®W, hW, hWc, hWU‚ü©
    -- Consider `s = {y ‚àà K | (f x, f y) ‚àà W}`
    set s := K ‚à© f ‚Åª¬π' ball (f x) W
    -- This is a neighbourhood of `x` within `K`, because `W` is an entourage.
    have hnhds : s ‚àà ùìù[K] x := inter_mem_nhdsWithin _ <| f.continuousAt _ (ball_mem_nhds _ hW)
    -- This set is compact because it is an intersection of `K`
    -- with a closed set `{y | (f x, f y) ‚àà W} = f ‚Åª¬π' UniformSpace.ball (f x) W`
    have hcomp : IsCompact s := hK.inter_right <| (isClosed_ball _ hWc).preimage f.continuous
    -- `f` maps `s` to the open set `ball (f x) V = {z | (f x, z) ‚àà V}`
    have hmaps : MapsTo f s (ball (f x) V) := fun x hx ‚Ü¶ hWU hx.2
    use s, hnhds
    -- Continuous maps `F i` in a neighbourhood of `f` map `s` to `ball (f x) V` as well.
    refine (h s hcomp _ (isOpen_ball _ hVo) hmaps).mono fun g hg y hy ‚Ü¶ ?_
    -- Then for `y ‚àà s` we have `(f y, f x) ‚àà V` and `(f x, F i y) ‚àà V`, thus `(f y, F i y) ‚àà U`
    exact hVU ‚ü®f x, hVsymm.mk_mem_comm.2 <| hmaps hy, hg hy‚ü©
  ¬∑ -- Now we prove that uniform convergence on compacts
    -- implies convergence in the compact-open topology
    -- Consider a compact set `K`, an open set `U`, and a continuous map `f` that maps `K` to `U`
    intro h K hK U hU hf
    -- Due to Lebesgue number lemma, there exists an entourage `V`
    -- such that `U` includes the `V`-thickening of `f '' K`.
    rcases lebesgue_number_of_compact_open (hK.image (map_continuous f)) hU hf.image_subset
        with ‚ü®V, hV, -, hVf‚ü©
    -- Then any continuous map that is uniformly `V`-close to `f` on `K`
    -- maps `K` to `U` as well
    filter_upwards [h K hK V hV] with g hg x hx using hVf _ (mem_image_of_mem f hx) (hg x hx)
#align continuous_map.tendsto_iff_forall_compact_tendsto_uniformly_on ContinuousMap.tendsto_iff_forall_compact_tendstoUniformlyOn

/-- Interpret a bundled continuous map as an element of `Œ± ‚Üí·µ§[{K | IsCompact K}] Œ≤`.

We use this map to induce the `UniformSpace` structure on `C(Œ±, Œ≤)`. -/
def toUniformOnFunIsCompact (f : C(Œ±, Œ≤)) : Œ± ‚Üí·µ§[{K | IsCompact K}] Œ≤ :=
  UniformOnFun.ofFun {K | IsCompact K} f

@[simp]
theorem toUniformOnFun_toFun (f : C(Œ±, Œ≤)) :
    UniformOnFun.toFun _ f.toUniformOnFunIsCompact = f := rfl

open UniformSpace in
/-- Uniform space structure on `C(Œ±, Œ≤)`.

The uniformity comes from `Œ± ‚Üí·µ§[{K | IsCompact K}] Œ≤` (i.e., `UniformOnFun Œ± Œ≤ {K | IsCompact K}`)
which defines topology of uniform convergence on compact sets.
We use `ContinuousMap.tendsto_iff_forall_compact_tendstoUniformlyOn`
to show that the induced topology agrees with the compact-open topology
and replace the topology with `compactOpen` to avoid non-defeq diamonds,
see Note [forgetful inheritance].  -/
instance compactConvergenceUniformSpace : UniformSpace C(Œ±, Œ≤) :=
  .replaceTopology (.comap toUniformOnFunIsCompact inferInstance) <| by
    refine TopologicalSpace.ext_nhds fun f ‚Ü¶ eq_of_forall_le_iff fun l ‚Ü¶ ?_
    simp_rw [‚Üê tendsto_id', tendsto_iff_forall_compact_tendstoUniformlyOn,
      nhds_induced, tendsto_comap_iff, UniformOnFun.tendsto_iff_tendstoUniformlyOn]
    rfl
#align continuous_map.compact_convergence_uniform_space ContinuousMap.compactConvergenceUniformSpace

theorem uniformEmbedding_toUniformOnFunIsCompact :
    UniformEmbedding (toUniformOnFunIsCompact : C(Œ±, Œ≤) ‚Üí Œ± ‚Üí·µ§[{K | IsCompact K}] Œ≤) where
  comap_uniformity := rfl
  inj := DFunLike.coe_injective

-- The following definitions and theorems
-- used to be a part of the construction of the `UniformSpace C(Œ±, Œ≤)` structure
-- before it was migrated to `UniformOnFun`
#noalign continuous_map.compact_conv_nhd
#noalign continuous_map.self_mem_compact_conv_nhd
#noalign continuous_map.compact_conv_nhd_mono
#noalign continuous_map.compact_conv_nhd_mem_comp
#noalign continuous_map.compact_conv_nhd_nhd_basis
#noalign continuous_map.compact_conv_nhd_subset_inter
#noalign continuous_map.compact_conv_nhd_compact_entourage_nonempty
#noalign continuous_map.compact_conv_nhd_filter_is_basis
#noalign continuous_map.compact_convergence_filter_basis
#noalign continuous_map.mem_compact_convergence_nhd_filter
#noalign continuous_map.compact_convergence_topology
#noalign continuous_map.nhds_compact_convergence
#noalign continuous_map.has_basis_nhds_compact_convergence
#noalign continuous_map.tendsto_iff_forall_compact_tendsto_uniformly_on'
#noalign continuous_map.compact_conv_nhd_subset_compact_open
#noalign continuous_map.Inter_compact_open_gen_subset_compact_conv_nhd
#noalign continuous_map.compact_open_eq_compact_convergence
#noalign continuous_map.compact_convergence_uniformity
#noalign continuous_map.has_basis_compact_convergence_uniformity_aux
#noalign continuous_map.mem_compact_convergence_uniformity

theorem _root_.Filter.HasBasis.compactConvergenceUniformity {Œπ : Type*} {pi : Œπ ‚Üí Prop}
    {s : Œπ ‚Üí Set (Œ≤ √ó Œ≤)} (h : (ùì§ Œ≤).HasBasis pi s) :
    HasBasis (ùì§ C(Œ±, Œ≤)) (fun p : Set Œ± √ó Œπ => IsCompact p.1 ‚àß pi p.2) fun p =>
      { fg : C(Œ±, Œ≤) √ó C(Œ±, Œ≤) | ‚àÄ x ‚àà p.1, (fg.1 x, fg.2 x) ‚àà s p.2 } := by
  rw [‚Üê uniformEmbedding_toUniformOnFunIsCompact.comap_uniformity]
  exact .comap _ <| UniformOnFun.hasBasis_uniformity_of_basis _ _ {K | IsCompact K}
    ‚ü®‚àÖ, isCompact_empty‚ü© (directedOn_of_sup_mem fun _ _ ‚Ü¶ IsCompact.union) h
#align filter.has_basis.compact_convergence_uniformity Filter.HasBasis.compactConvergenceUniformity

theorem hasBasis_compactConvergenceUniformity :
    HasBasis (ùì§ C(Œ±, Œ≤)) (fun p : Set Œ± √ó Set (Œ≤ √ó Œ≤) => IsCompact p.1 ‚àß p.2 ‚àà ùì§ Œ≤) fun p =>
      { fg : C(Œ±, Œ≤) √ó C(Œ±, Œ≤) | ‚àÄ x ‚àà p.1, (fg.1 x, fg.2 x) ‚àà p.2 } :=
  (basis_sets _).compactConvergenceUniformity
#align continuous_map.has_basis_compact_convergence_uniformity ContinuousMap.hasBasis_compactConvergenceUniformity

theorem mem_compactConvergence_entourage_iff (X : Set (C(Œ±, Œ≤) √ó C(Œ±, Œ≤))) :
    X ‚àà ùì§ C(Œ±, Œ≤) ‚Üî
      ‚àÉ (K : Set Œ±) (V : Set (Œ≤ √ó Œ≤)), IsCompact K ‚àß V ‚àà ùì§ Œ≤ ‚àß
        { fg : C(Œ±, Œ≤) √ó C(Œ±, Œ≤) | ‚àÄ x ‚àà K, (fg.1 x, fg.2 x) ‚àà V } ‚äÜ X := by
  simp [hasBasis_compactConvergenceUniformity.mem_iff, and_assoc]
#align continuous_map.mem_compact_convergence_entourage_iff ContinuousMap.mem_compactConvergence_entourage_iff

/-- If `K` is a compact exhaustion of `Œ±`
and `V i` bounded by `p i` is a basis of entourages of `Œ≤`,
then `fun (n, i) ‚Ü¶ {(f, g) | ‚àÄ x ‚àà K n, (f x, g x) ‚àà V i}` bounded by `p i`
is a basis of entourages of `C(Œ±, Œ≤)`. -/
theorem _root_.CompactExhaustion.hasBasis_compactConvergenceUniformity {Œπ : Type*}
    {p : Œπ ‚Üí Prop} {V : Œπ ‚Üí Set (Œ≤ √ó Œ≤)} (K : CompactExhaustion Œ±) (hb : (ùì§ Œ≤).HasBasis p V) :
    HasBasis (ùì§ C(Œ±, Œ≤)) (fun i : ‚Ñï √ó Œπ ‚Ü¶ p i.2) fun i ‚Ü¶
      {fg | ‚àÄ x ‚àà K i.1, (fg.1 x, fg.2 x) ‚àà V i.2} :=
  (UniformOnFun.hasBasis_uniformity_of_covering_of_basis {K | IsCompact K} K.isCompact
    (Monotone.directed_le K.subset) (fun _ ‚Ü¶ K.exists_superset_of_isCompact) hb).comap _

theorem _root_.CompactExhaustion.hasAntitoneBasis_compactConvergenceUniformity
    {V : ‚Ñï ‚Üí Set (Œ≤ √ó Œ≤)} (K : CompactExhaustion Œ±) (hb : (ùì§ Œ≤).HasAntitoneBasis V) :
    HasAntitoneBasis (ùì§ C(Œ±, Œ≤)) fun n ‚Ü¶ {fg | ‚àÄ x ‚àà K n, (fg.1 x, fg.2 x) ‚àà V n} :=
  (UniformOnFun.hasAntitoneBasis_uniformity {K | IsCompact K} K.isCompact
    K.subset (fun _ ‚Ü¶ K.exists_superset_of_isCompact) hb).comap _

/-- If `Œ±` is a weakly locally compact œÉ-compact space
(e.g., a proper pseudometric space or a compact spaces)
and the uniformity on `Œ≤` is pseudometrizable,
then the uniformity on `C(Œ±, Œ≤)` is pseudometrizable too.
-/
instance [WeaklyLocallyCompactSpace Œ±] [SigmaCompactSpace Œ±] [IsCountablyGenerated (ùì§ Œ≤)] :
    IsCountablyGenerated (ùì§ (C(Œ±, Œ≤))) :=
  let ‚ü®_V, hV‚ü© := exists_antitone_basis (ùì§ Œ≤)
  ((CompactExhaustion.choice Œ±).hasAntitoneBasis_compactConvergenceUniformity
    hV).isCountablyGenerated

variable {Œπ : Type u‚ÇÉ} {p : Filter Œπ} {F : Œπ ‚Üí C(Œ±, Œ≤)} {f}

/-- Locally uniform convergence implies convergence in the compact-open topology. -/
theorem tendsto_of_tendstoLocallyUniformly (h : TendstoLocallyUniformly (fun i a => F i a) f p) :
    Tendsto F p (ùìù f) := by
  rw [tendsto_iff_forall_compact_tendstoUniformlyOn]
  intro K hK
  rw [‚Üê tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact hK]
  exact h.tendstoLocallyUniformlyOn
#align continuous_map.tendsto_of_tendsto_locally_uniformly ContinuousMap.tendsto_of_tendstoLocallyUniformly

/-- In a weakly locally compact space,
convergence in the compact-open topology is the same as locally uniform convergence.

The right-to-left implication holds in any topological space,
see `ContinuousMap.tendsto_of_tendstoLocallyUniformly`. -/
theorem tendsto_iff_tendstoLocallyUniformly [WeaklyLocallyCompactSpace Œ±] :
    Tendsto F p (ùìù f) ‚Üî TendstoLocallyUniformly (fun i a => F i a) f p := by
  refine ‚ü®fun h V hV x ‚Ü¶ ?_, tendsto_of_tendstoLocallyUniformly‚ü©
  rw [tendsto_iff_forall_compact_tendstoUniformlyOn] at h
  obtain ‚ü®n, hn‚ÇÅ, hn‚ÇÇ‚ü© := exists_compact_mem_nhds x
  exact ‚ü®n, hn‚ÇÇ, h n hn‚ÇÅ V hV‚ü©
#align continuous_map.tendsto_iff_tendsto_locally_uniformly ContinuousMap.tendsto_iff_tendstoLocallyUniformly

@[deprecated tendsto_iff_tendstoLocallyUniformly (since := "2023-09-03")]
theorem tendstoLocallyUniformly_of_tendsto [WeaklyLocallyCompactSpace Œ±] (h : Tendsto F p (ùìù f)) :
    TendstoLocallyUniformly (fun i a => F i a) f p :=
  tendsto_iff_tendstoLocallyUniformly.1 h
#align continuous_map.tendsto_locally_uniformly_of_tendsto ContinuousMap.tendstoLocallyUniformly_of_tendsto

section Functorial

variable {Œ≥ Œ¥ : Type*} [TopologicalSpace Œ≥] [UniformSpace Œ¥]

theorem uniformContinuous_comp (g : C(Œ≤, Œ¥)) (hg : UniformContinuous g) :
    UniformContinuous (ContinuousMap.comp g : C(Œ±, Œ≤) ‚Üí C(Œ±, Œ¥)) :=
  uniformEmbedding_toUniformOnFunIsCompact.uniformContinuous_iff.mpr <|
    UniformOnFun.postcomp_uniformContinuous hg |>.comp
      uniformEmbedding_toUniformOnFunIsCompact.uniformContinuous

theorem uniformInducing_comp (g : C(Œ≤, Œ¥)) (hg : UniformInducing g) :
    UniformInducing (ContinuousMap.comp g : C(Œ±, Œ≤) ‚Üí C(Œ±, Œ¥)) :=
  uniformEmbedding_toUniformOnFunIsCompact.toUniformInducing.of_comp_iff.mp <|
    UniformOnFun.postcomp_uniformInducing hg |>.comp
      uniformEmbedding_toUniformOnFunIsCompact.toUniformInducing

theorem uniformEmbedding_comp (g : C(Œ≤, Œ¥)) (hg : UniformEmbedding g) :
    UniformEmbedding (ContinuousMap.comp g : C(Œ±, Œ≤) ‚Üí C(Œ±, Œ¥)) :=
  uniformEmbedding_toUniformOnFunIsCompact.of_comp_iff.mp <|
    UniformOnFun.postcomp_uniformEmbedding hg |>.comp
      uniformEmbedding_toUniformOnFunIsCompact

theorem uniformContinuous_comp_left (g : C(Œ±, Œ≥)) :
    UniformContinuous (fun f ‚Ü¶ f.comp g : C(Œ≥, Œ≤) ‚Üí C(Œ±, Œ≤)) :=
  uniformEmbedding_toUniformOnFunIsCompact.uniformContinuous_iff.mpr <|
    UniformOnFun.precomp_uniformContinuous (fun _ hK ‚Ü¶ hK.image g.continuous) |>.comp
      uniformEmbedding_toUniformOnFunIsCompact.uniformContinuous

/-- Any pair of a homeomorphism `X ‚âÉ‚Çú Z` and an isomorphism `Y ‚âÉ·µ§ T` of uniform spaces gives rise
to an isomorphism `C(X, Y) ‚âÉ·µ§ C(Z, T)`. -/
protected def _root_.UniformEquiv.arrowCongr (œÜ : Œ± ‚âÉ‚Çú Œ≥) (œà : Œ≤ ‚âÉ·µ§ Œ¥) :
    C(Œ±, Œ≤) ‚âÉ·µ§ C(Œ≥, Œ¥) where
  toFun f := .comp œà.toHomeomorph <| f.comp œÜ.symm
  invFun f := .comp œà.symm.toHomeomorph <| f.comp œÜ
  left_inv f := ext fun _ ‚Ü¶ œà.left_inv (f _) |>.trans <| congrArg f <| œÜ.left_inv _
  right_inv f := ext fun _ ‚Ü¶ œà.right_inv (f _) |>.trans <| congrArg f <| œÜ.right_inv _
  uniformContinuous_toFun := uniformContinuous_comp _ œà.uniformContinuous |>.comp <|
    uniformContinuous_comp_left _
  uniformContinuous_invFun := uniformContinuous_comp _ œà.symm.uniformContinuous |>.comp <|
    uniformContinuous_comp_left _

end Functorial

section CompactDomain

variable [CompactSpace Œ±]

theorem hasBasis_compactConvergenceUniformity_of_compact :
    HasBasis (ùì§ C(Œ±, Œ≤)) (fun V : Set (Œ≤ √ó Œ≤) => V ‚àà ùì§ Œ≤) fun V =>
      { fg : C(Œ±, Œ≤) √ó C(Œ±, Œ≤) | ‚àÄ x, (fg.1 x, fg.2 x) ‚àà V } :=
  hasBasis_compactConvergenceUniformity.to_hasBasis
    (fun p hp => ‚ü®p.2, hp.2, fun _fg hfg x _hx => hfg x‚ü©) fun V hV =>
    ‚ü®‚ü®univ, V‚ü©, ‚ü®isCompact_univ, hV‚ü©, fun _fg hfg x => hfg x (mem_univ x)‚ü©
#align continuous_map.has_basis_compact_convergence_uniformity_of_compact ContinuousMap.hasBasis_compactConvergenceUniformity_of_compact

/-- Convergence in the compact-open topology is the same as uniform convergence for sequences of
continuous functions on a compact space. -/
theorem tendsto_iff_tendstoUniformly :
    Tendsto F p (ùìù f) ‚Üî TendstoUniformly (fun i a => F i a) f p := by
  rw [tendsto_iff_forall_compact_tendstoUniformlyOn, ‚Üê tendstoUniformlyOn_univ]
  exact ‚ü®fun h => h univ isCompact_univ, fun h K _hK => h.mono (subset_univ K)‚ü©
#align continuous_map.tendsto_iff_tendsto_uniformly ContinuousMap.tendsto_iff_tendstoUniformly

end CompactDomain

theorem uniformSpace_eq_inf_precomp_of_cover {Œ¥‚ÇÅ Œ¥‚ÇÇ : Type*} [TopologicalSpace Œ¥‚ÇÅ]
    [TopologicalSpace Œ¥‚ÇÇ] (œÜ‚ÇÅ : C(Œ¥‚ÇÅ, Œ±)) (œÜ‚ÇÇ : C(Œ¥‚ÇÇ, Œ±)) (h_proper‚ÇÅ : IsProperMap œÜ‚ÇÅ)
    (h_proper‚ÇÇ : IsProperMap œÜ‚ÇÇ) (h_cover : range œÜ‚ÇÅ ‚à™ range œÜ‚ÇÇ = univ) :
    (inferInstanceAs <| UniformSpace C(Œ±, Œ≤)) =
      .comap (comp ¬∑ œÜ‚ÇÅ) inferInstance ‚äì
      .comap (comp ¬∑ œÜ‚ÇÇ) inferInstance := by
  -- We check the analogous result for `UniformOnFun` using
  -- `UniformOnFun.uniformSpace_eq_inf_precomp_of_cover`...
  set ùîñ : Set (Set Œ±) := {K | IsCompact K}
  set ùîó‚ÇÅ : Set (Set Œ¥‚ÇÅ) := {K | IsCompact K}
  set ùîó‚ÇÇ : Set (Set Œ¥‚ÇÇ) := {K | IsCompact K}
  have h_image‚ÇÅ : MapsTo (œÜ‚ÇÅ '' ¬∑) ùîó‚ÇÅ ùîñ := fun K hK ‚Ü¶ hK.image œÜ‚ÇÅ.continuous
  have h_image‚ÇÇ : MapsTo (œÜ‚ÇÇ '' ¬∑) ùîó‚ÇÇ ùîñ := fun K hK ‚Ü¶ hK.image œÜ‚ÇÇ.continuous
  have h_preimage‚ÇÅ : MapsTo (œÜ‚ÇÅ ‚Åª¬π' ¬∑) ùîñ ùîó‚ÇÅ := fun K ‚Ü¶ h_proper‚ÇÅ.isCompact_preimage
  have h_preimage‚ÇÇ : MapsTo (œÜ‚ÇÇ ‚Åª¬π' ¬∑) ùîñ ùîó‚ÇÇ := fun K ‚Ü¶ h_proper‚ÇÇ.isCompact_preimage
  have h_cover' : ‚àÄ S ‚àà ùîñ, S ‚äÜ range œÜ‚ÇÅ ‚à™ range œÜ‚ÇÇ := fun S _ ‚Ü¶ h_cover ‚ñ∏ subset_univ _
  -- ... and we just pull it back.
  simp_rw [compactConvergenceUniformSpace, replaceTopology_eq, inferInstanceAs, inferInstance,
    UniformOnFun.uniformSpace_eq_inf_precomp_of_cover _ _ _ _ _
      h_image‚ÇÅ h_image‚ÇÇ h_preimage‚ÇÅ h_preimage‚ÇÇ h_cover',
    UniformSpace.comap_inf, ‚Üê UniformSpace.comap_comap]
  rfl

theorem uniformSpace_eq_iInf_precomp_of_cover {Œ¥ : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (Œ¥ i)]
    (œÜ : Œ† i, C(Œ¥ i, Œ±)) (h_proper : ‚àÄ i, IsProperMap (œÜ i))
    (h_lf : LocallyFinite fun i ‚Ü¶ range (œÜ i)) (h_cover : ‚ãÉ i, range (œÜ i) = univ) :
    (inferInstanceAs <| UniformSpace C(Œ±, Œ≤)) = ‚®Ö i, .comap (comp ¬∑ (œÜ i)) inferInstance := by
  -- We check the analogous result for `UniformOnFun` using
  -- `UniformOnFun.uniformSpace_eq_iInf_precomp_of_cover`...
  set ùîñ : Set (Set Œ±) := {K | IsCompact K}
  set ùîó : Œ† i, Set (Set (Œ¥ i)) := fun i ‚Ü¶ {K | IsCompact K}
  have h_image : ‚àÄ i, MapsTo (œÜ i '' ¬∑) (ùîó i) ùîñ := fun i K hK ‚Ü¶ hK.image (œÜ i).continuous
  have h_preimage : ‚àÄ i, MapsTo (œÜ i ‚Åª¬π' ¬∑) ùîñ (ùîó i) := fun i K ‚Ü¶ (h_proper i).isCompact_preimage
  have h_cover' : ‚àÄ S ‚àà ùîñ, ‚àÉ I : Set Œπ, I.Finite ‚àß S ‚äÜ ‚ãÉ i ‚àà I, range (œÜ i) := fun S hS ‚Ü¶ by
    refine ‚ü®{i | (range (œÜ i) ‚à© S).Nonempty}, h_lf.finite_nonempty_inter_compact hS,
      inter_eq_right.mp ?_‚ü©
    simp_rw [iUnion‚ÇÇ_inter, mem_setOf, iUnion_nonempty_self, ‚Üê iUnion_inter, h_cover, univ_inter]
  -- ... and we just pull it back.
  simp_rw [compactConvergenceUniformSpace, replaceTopology_eq, inferInstanceAs, inferInstance,
    UniformOnFun.uniformSpace_eq_iInf_precomp_of_cover _ _ _ h_image h_preimage h_cover',
    UniformSpace.comap_iInf, ‚Üê UniformSpace.comap_comap]
  rfl

end ContinuousMap
