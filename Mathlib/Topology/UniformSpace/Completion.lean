/-
Copyright (c) 2018 Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Patrick Massot, Johannes H√∂lzl

! This file was ported from Lean 3 source module topology.uniform_space.completion
! leanprover-community/mathlib commit dc6c365e751e34d100e80fe6e314c3c3e0fd2988
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathlib.Topology.UniformSpace.AbstractCompletion

/-!
# Hausdorff completions of uniform spaces

The goal is to construct a left-adjoint to the inclusion of complete Hausdorff uniform spaces
into all uniform spaces. Any uniform space `Œ±` gets a completion `Completion Œ±` and a morphism
(ie. uniformly continuous map) `(‚Üë) : Œ± ‚Üí Completion Œ±` which solves the universal
mapping problem of factorizing morphisms from `Œ±` to any complete Hausdorff uniform space `Œ≤`.
It means any uniformly continuous `f : Œ± ‚Üí Œ≤` gives rise to a unique morphism
`Completion.extension f : Completion Œ± ‚Üí Œ≤` such that `f = Completion.extension f ‚àò (‚Üë)`.
Actually `Completion.extension f` is defined for all maps from `Œ±` to `Œ≤` but it has the desired
properties only if `f` is uniformly continuous.

Beware that `(‚Üë)` is not injective if `Œ±` is not Hausdorff. But its image is always
dense. The adjoint functor acting on morphisms is then constructed by the usual abstract nonsense.
For every uniform spaces `Œ±` and `Œ≤`, it turns `f : Œ± ‚Üí Œ≤` into a morphism
  `Completion.map f : Completion Œ± ‚Üí Completion Œ≤`
such that
  `(‚Üë) ‚àò f = (Completion.map f) ‚àò (‚Üë)`
provided `f` is uniformly continuous. This construction is compatible with composition.

In this file we introduce the following concepts:

* `CauchyFilter Œ±` the uniform completion of the uniform space `Œ±` (using Cauchy filters).
  These are not minimal filters.

* `Completion Œ± := Quotient (separationSetoid (CauchyFilter Œ±))` the Hausdorff completion.

## References

This formalization is mostly based on
  N. Bourbaki: General Topology
  I. M. James: Topologies and Uniformities
From a slightly different perspective in order to reuse material in topology.uniform_space.basic.
-/


noncomputable section

open Filter Set

universe u v w x

open Uniformity Classical Topology Filter

/-- Space of Cauchy filters

This is essentially the completion of a uniform space. The embeddings are the neighbourhood filters.
This space is not minimal, the separated uniform space (i.e. quotiented on the intersection of all
entourages) is necessary for this.
-/
def CauchyFilter (Œ± : Type u) [UniformSpace Œ±] : Type u :=
  { f : Filter Œ± // Cauchy f }
set_option linter.uppercaseLean3 false in
#align Cauchy CauchyFilter

namespace CauchyFilter

section

variable {Œ± : Type u} [UniformSpace Œ±]

variable {Œ≤ : Type v} {Œ≥ : Type w}

variable [UniformSpace Œ≤] [UniformSpace Œ≥]

/-- The pairs of Cauchy filters generated by a set. -/
def gen (s : Set (Œ± √ó Œ±)) : Set (CauchyFilter Œ± √ó CauchyFilter Œ±) :=
  { p | s ‚àà p.1.val √óÀ¢ p.2.val }
set_option linter.uppercaseLean3 false in
#align Cauchy.gen CauchyFilter.gen

theorem monotone_gen : Monotone (gen : Set (Œ± √ó Œ±) ‚Üí _) :=
  monotone_setOf fun p => @Filter.monotone_mem _ (p.1.val √óÀ¢ p.2.val)
set_option linter.uppercaseLean3 false in
#align Cauchy.monotone_gen CauchyFilter.monotone_gen

-- porting note: this was a calc proof, but I could not make it work
private theorem symm_gen : map Prod.swap ((ùì§ Œ±).lift' gen) ‚â§ (ùì§ Œ±).lift' gen := by
  let f := fun s : Set (Œ± √ó Œ±) =>
        { p : CauchyFilter Œ± √ó CauchyFilter Œ± | s ‚àà (p.2.val √óÀ¢ p.1.val : Filter (Œ± √ó Œ±)) }
  have h‚ÇÅ : map Prod.swap ((ùì§ Œ±).lift' gen) = (ùì§ Œ±).lift' f := by
    delta gen
    simp [map_lift'_eq, monotone_setOf, Filter.monotone_mem, Function.comp,
      image_swap_eq_preimage_swap]
  have h‚ÇÇ : (ùì§ Œ±).lift' f ‚â§ (ùì§ Œ±).lift' gen :=
    uniformity_lift_le_swap
      (monotone_principal.comp
        (monotone_setOf fun p => @Filter.monotone_mem _ (p.2.val √óÀ¢ p.1.val)))
      (by
        have h := fun p : CauchyFilter Œ± √ó CauchyFilter Œ± => @Filter.prod_comm _ _ p.2.val p.1.val
        simp [Function.comp, h, mem_map']
        exact le_rfl)
  exact h‚ÇÅ.trans_le h‚ÇÇ

private theorem compRel_gen_gen_subset_gen_compRel {s t : Set (Œ± √ó Œ±)} :
    compRel (gen s) (gen t) ‚äÜ (gen (compRel s t) : Set (CauchyFilter Œ± √ó CauchyFilter Œ±)) :=
  fun ‚ü®f, g‚ü© ‚ü®h, h‚ÇÅ, h‚ÇÇ‚ü© =>
  let ‚ü®t‚ÇÅ, (ht‚ÇÅ : t‚ÇÅ ‚àà f.val), t‚ÇÇ, (ht‚ÇÇ : t‚ÇÇ ‚àà h.val), (h‚ÇÅ : t‚ÇÅ √óÀ¢ t‚ÇÇ ‚äÜ s)‚ü© := mem_prod_iff.mp h‚ÇÅ
  let ‚ü®t‚ÇÉ, (ht‚ÇÉ : t‚ÇÉ ‚àà h.val), t‚ÇÑ, (ht‚ÇÑ : t‚ÇÑ ‚àà g.val), (h‚ÇÇ : t‚ÇÉ √óÀ¢ t‚ÇÑ ‚äÜ t)‚ü© := mem_prod_iff.mp h‚ÇÇ
  have : t‚ÇÇ ‚à© t‚ÇÉ ‚àà h.val := inter_mem ht‚ÇÇ ht‚ÇÉ
  let ‚ü®x, xt‚ÇÇ, xt‚ÇÉ‚ü© := h.property.left.nonempty_of_mem this
  (f.val √óÀ¢ g.val).sets_of_superset (prod_mem_prod ht‚ÇÅ ht‚ÇÑ)
    fun ‚ü®a, b‚ü© ‚ü®(ha : a ‚àà t‚ÇÅ), (hb : b ‚àà t‚ÇÑ)‚ü© =>
    ‚ü®x, h‚ÇÅ (show (a, x) ‚àà t‚ÇÅ √óÀ¢ t‚ÇÇ from ‚ü®ha, xt‚ÇÇ‚ü©), h‚ÇÇ (show (x, b) ‚àà t‚ÇÉ √óÀ¢ t‚ÇÑ from ‚ü®xt‚ÇÉ, hb‚ü©)‚ü©

private theorem comp_gen : (((ùì§ Œ±).lift' gen).lift' fun s => compRel s s) ‚â§ (ùì§ Œ±).lift' gen :=
  calc
    (((ùì§ Œ±).lift' gen).lift' fun s => compRel s s) =
        (ùì§ Œ±).lift' fun s => compRel (gen s) (gen s) := by
      rw [lift'_lift'_assoc]
      ¬∑ exact monotone_gen
      ¬∑ exact monotone_id.compRel monotone_id
    _ ‚â§ (ùì§ Œ±).lift' fun s => gen <| compRel s s :=
      lift'_mono' fun s _hs => compRel_gen_gen_subset_gen_compRel
    _ = ((ùì§ Œ±).lift' fun s : Set (Œ± √ó Œ±) => compRel s s).lift' gen := by
      rw [lift'_lift'_assoc]
      ¬∑ exact monotone_id.compRel monotone_id
      ¬∑ exact monotone_gen
    _ ‚â§ (ùì§ Œ±).lift' gen := lift'_mono comp_le_uniformity le_rfl

instance : UniformSpace (CauchyFilter Œ±) :=
  UniformSpace.ofCore
    { uniformity := (ùì§ Œ±).lift' gen
      refl := principal_le_lift'.2 fun _s hs ‚ü®a, b‚ü© =>
        fun (a_eq_b : a = b) => a_eq_b ‚ñ∏ a.property.right hs
      symm := symm_gen
      comp := comp_gen }

theorem mem_uniformity {s : Set (CauchyFilter Œ± √ó CauchyFilter Œ±)} :
    s ‚àà ùì§ (CauchyFilter Œ±) ‚Üî ‚àÉ t ‚àà ùì§ Œ±, gen t ‚äÜ s :=
  mem_lift'_sets monotone_gen
set_option linter.uppercaseLean3 false in
#align Cauchy.mem_uniformity CauchyFilter.mem_uniformity

theorem mem_uniformity' {s : Set (CauchyFilter Œ± √ó CauchyFilter Œ±)} :
    s ‚àà ùì§ (CauchyFilter Œ±) ‚Üî ‚àÉ t ‚àà ùì§ Œ±, ‚àÄ f g : CauchyFilter Œ±, t ‚àà f.1 √óÀ¢ g.1 ‚Üí (f, g) ‚àà s := by
  refine mem_uniformity.trans (exists_congr (fun t => and_congr_right_iff.mpr (fun _h => ?_)))
  exact ‚ü®fun h _f _g ht => h ht, fun h _p hp => h _ _ hp‚ü©
set_option linter.uppercaseLean3 false in
#align Cauchy.mem_uniformity' CauchyFilter.mem_uniformity'

/-- Embedding of `Œ±` into its completion `CauchyFilter Œ±` -/
def pureCauchy (a : Œ±) : CauchyFilter Œ± :=
  ‚ü®pure a, cauchy_pure‚ü©
set_option linter.uppercaseLean3 false in
#align Cauchy.pure_cauchy CauchyFilter.pureCauchy

theorem uniformInducing_pureCauchy : UniformInducing (pureCauchy : Œ± ‚Üí CauchyFilter Œ±) :=
  ‚ü®have : (preimage fun x : Œ± √ó Œ± => (pureCauchy x.fst, pureCauchy x.snd)) ‚àò gen = id :=
      funext fun s =>
        Set.ext fun ‚ü®a‚ÇÅ, a‚ÇÇ‚ü© => by simp [preimage, gen, pureCauchy, prod_principal_principal]
    calc
      comap (fun x : Œ± √ó Œ± => (pureCauchy x.fst, pureCauchy x.snd)) ((ùì§ Œ±).lift' gen) =
          (ùì§ Œ±).lift' ((preimage fun x : Œ± √ó Œ± => (pureCauchy x.fst, pureCauchy x.snd)) ‚àò gen) :=
        comap_lift'_eq
      _ = ùì§ Œ± := by simp [this]
      ‚ü©
set_option linter.uppercaseLean3 false in
#align Cauchy.uniform_inducing_pure_cauchy CauchyFilter.uniformInducing_pureCauchy

theorem uniformEmbedding_pureCauchy : UniformEmbedding (pureCauchy : Œ± ‚Üí CauchyFilter Œ±) :=
  { uniformInducing_pureCauchy with
    inj := fun _a‚ÇÅ _a‚ÇÇ h => pure_injective <| Subtype.ext_iff_val.1 h }
set_option linter.uppercaseLean3 false in
#align Cauchy.uniform_embedding_pure_cauchy CauchyFilter.uniformEmbedding_pureCauchy

theorem denseRange_pureCauchy : DenseRange (pureCauchy : Œ± ‚Üí CauchyFilter Œ±) := fun f => by
  have h_ex : ‚àÄ s ‚àà ùì§ (CauchyFilter Œ±), ‚àÉ y : Œ±, (f, pureCauchy y) ‚àà s := fun s hs =>
    let ‚ü®t'', ht''‚ÇÅ, (ht''‚ÇÇ : gen t'' ‚äÜ s)‚ü© := (mem_lift'_sets monotone_gen).mp hs
    let ‚ü®t', ht'‚ÇÅ, ht'‚ÇÇ‚ü© := comp_mem_uniformity_sets ht''‚ÇÅ
    have : t' ‚àà f.val √óÀ¢ f.val := f.property.right ht'‚ÇÅ
    let ‚ü®t, ht, (h : t √óÀ¢ t ‚äÜ t')‚ü© := mem_prod_same_iff.mp this
    let ‚ü®x, (hx : x ‚àà t)‚ü© := f.property.left.nonempty_of_mem ht
    have : t'' ‚àà f.val √óÀ¢ pure x :=
      mem_prod_iff.mpr
        ‚ü®t, ht, { y : Œ± | (x, y) ‚àà t' }, h <| mk_mem_prod hx hx,
          fun ‚ü®a, b‚ü© ‚ü®(h‚ÇÅ : a ‚àà t), (h‚ÇÇ : (x, b) ‚àà t')‚ü© =>
          ht'‚ÇÇ <| prod_mk_mem_compRel (@h (a, x) ‚ü®h‚ÇÅ, hx‚ü©) h‚ÇÇ‚ü©
    ‚ü®x, ht''‚ÇÇ <| by dsimp [gen] ; exact this‚ü©
  simp only [closure_eq_cluster_pts, ClusterPt, nhds_eq_uniformity, lift'_inf_principal_eq,
    Set.inter_comm _ (range pureCauchy), mem_setOf_eq]
  refine (lift'_neBot_iff ?_).mpr (fun s hs => ?_)
  . refine monotone_const.inter ?_
    simp_rw [UniformSpace.ball]
    exact monotone_preimage
  . let ‚ü®y, hy‚ü© := h_ex s hs
    have : pureCauchy y ‚àà range pureCauchy ‚à© { y : CauchyFilter Œ± | (f, y) ‚àà s } :=
      ‚ü®mem_range_self y, hy‚ü©
    exact ‚ü®_, this‚ü©
set_option linter.uppercaseLean3 false in
#align Cauchy.dense_range_pure_cauchy CauchyFilter.denseRange_pureCauchy

theorem denseInducing_pureCauchy : DenseInducing (pureCauchy : Œ± ‚Üí CauchyFilter Œ±) :=
  uniformInducing_pureCauchy.denseInducing denseRange_pureCauchy
set_option linter.uppercaseLean3 false in
#align Cauchy.dense_inducing_pure_cauchy CauchyFilter.denseInducing_pureCauchy

theorem denseEmbedding_pureCauchy : DenseEmbedding (pureCauchy : Œ± ‚Üí CauchyFilter Œ±) :=
  uniformEmbedding_pureCauchy.denseEmbedding denseRange_pureCauchy
set_option linter.uppercaseLean3 false in
#align Cauchy.dense_embedding_pure_cauchy CauchyFilter.denseEmbedding_pureCauchy

theorem nonempty_cauchyFilter_iff : Nonempty (CauchyFilter Œ±) ‚Üî Nonempty Œ± := by
  constructor <;> rintro ‚ü®c‚ü©
  ¬∑ have := eq_univ_iff_forall.1 denseEmbedding_pureCauchy.toDenseInducing.closure_range c
    obtain ‚ü®_, ‚ü®_, a, _‚ü©‚ü© := mem_closure_iff.1 this _ isOpen_univ trivial
    exact ‚ü®a‚ü©
  ¬∑ exact ‚ü®pureCauchy c‚ü©
set_option linter.uppercaseLean3 false in
#align Cauchy.nonempty_Cauchy_iff CauchyFilter.nonempty_cauchyFilter_iff

section

-- porting note: I commented this
-- set_option eqn_compiler.zeta true

instance : CompleteSpace (CauchyFilter Œ±) :=
  completeSpace_extension uniformInducing_pureCauchy denseRange_pureCauchy fun f hf =>
    let f' : CauchyFilter Œ± := ‚ü®f, hf‚ü©
    have : map pureCauchy f ‚â§ (ùì§ <| CauchyFilter Œ±).lift' (preimage (Prod.mk f')) :=
      le_lift'.2 fun s hs =>
        let ‚ü®t, ht‚ÇÅ, (ht‚ÇÇ : gen t ‚äÜ s)‚ü© := (mem_lift'_sets monotone_gen).mp hs
        let ‚ü®t', ht', (h : t' √óÀ¢ t' ‚äÜ t)‚ü© := mem_prod_same_iff.mp (hf.right ht‚ÇÅ)
        have : t' ‚äÜ { y : Œ± | (f', pureCauchy y) ‚àà gen t } := fun x hx =>
          (f √óÀ¢ pure x).sets_of_superset (prod_mem_prod ht' hx) h
        f.sets_of_superset ht' <| Subset.trans this (preimage_mono ht‚ÇÇ)
    ‚ü®f', by simp [nhds_eq_uniformity] ; assumption‚ü©

end

instance [Inhabited Œ±] : Inhabited (CauchyFilter Œ±) :=
  ‚ü®pureCauchy default‚ü©

instance [h : Nonempty Œ±] : Nonempty (CauchyFilter Œ±) :=
  h.recOn fun a => Nonempty.intro <| CauchyFilter.pureCauchy a

section Extend

/-- Extend a uniformly continuous function `Œ± ‚Üí Œ≤` to a function `CauchyFilter Œ± ‚Üí Œ≤`.
Outputs junk when `f` is not uniformly continuous. -/
def extend (f : Œ± ‚Üí Œ≤) : CauchyFilter Œ± ‚Üí Œ≤ :=
  if UniformContinuous f then denseInducing_pureCauchy.extend f
  else fun x => f (nonempty_cauchyFilter_iff.1 ‚ü®x‚ü©).some
set_option linter.uppercaseLean3 false in
#align Cauchy.extend CauchyFilter.extend

section SeparatedSpace

variable [SeparatedSpace Œ≤]

theorem extend_pureCauchy {f : Œ± ‚Üí Œ≤} (hf : UniformContinuous f) (a : Œ±) :
    extend f (pureCauchy a) = f a := by
  rw [extend, if_pos hf]
  exact uniformly_extend_of_ind uniformInducing_pureCauchy denseRange_pureCauchy hf _
set_option linter.uppercaseLean3 false in
#align Cauchy.extend_pure_cauchy CauchyFilter.extend_pureCauchy

end SeparatedSpace

variable [CompleteSpace Œ≤]

theorem uniformContinuous_extend {f : Œ± ‚Üí Œ≤} : UniformContinuous (extend f) := by
  by_cases hf : UniformContinuous f
  ¬∑ rw [extend, if_pos hf]
    exact uniformContinuous_uniformly_extend uniformInducing_pureCauchy denseRange_pureCauchy hf
  ¬∑ rw [extend, if_neg hf]
    exact uniformContinuous_of_const fun a _b => by congr
set_option linter.uppercaseLean3 false in
#align Cauchy.uniform_continuous_extend CauchyFilter.uniformContinuous_extend

end Extend

end

theorem cauchyFilter_eq {Œ± : Type _} [Inhabited Œ±] [UniformSpace Œ±] [CompleteSpace Œ±]
    [SeparatedSpace Œ±] {f g : CauchyFilter Œ±} :
    lim f.1 = lim g.1 ‚Üî (f, g) ‚àà separationRel (CauchyFilter Œ±) := by
  constructor
  ¬∑ intro e s hs
    rcases CauchyFilter.mem_uniformity'.1 hs with ‚ü®t, tu, ts‚ü©
    apply ts
    rcases comp_mem_uniformity_sets tu with ‚ü®d, du, dt‚ü©
    refine'
      mem_prod_iff.2
        ‚ü®_, f.2.le_nhds_lim (mem_nhds_right (lim f.1) du), _,
          g.2.le_nhds_lim (mem_nhds_left (lim g.1) du), fun x h => _‚ü©
    cases' x with a b
    cases' h with h‚ÇÅ h‚ÇÇ
    rw [‚Üê e] at h‚ÇÇ
    exact dt ‚ü®_, h‚ÇÅ, h‚ÇÇ‚ü©
  ¬∑ intro H
    refine' separated_def.1 (by infer_instance) _ _ fun t tu => _
    rcases mem_uniformity_isClosed tu with ‚ü®d, du, dc, dt‚ü©
    refine'
      H { p | (lim p.1.1, lim p.2.1) ‚àà t } (CauchyFilter.mem_uniformity'.2 ‚ü®d, du, fun f g h => _‚ü©)
    rcases mem_prod_iff.1 h with ‚ü®x, xf, y, yg, h‚ü©
    have limc : ‚àÄ (f : CauchyFilter Œ±), ‚àÄ x ‚àà f.1, lim f.1 ‚àà closure x := by
      intro f x xf
      rw [closure_eq_cluster_pts]
      exact f.2.1.mono (le_inf f.2.le_nhds_lim (le_principal_iff.2 xf))
    have := dc.closure_subset_iff.2 h
    rw [closure_prod_eq] at this
    refine' dt (this ‚ü®_, _‚ü©) <;> dsimp <;> apply limc <;> assumption
set_option linter.uppercaseLean3 false in
#align Cauchy.Cauchy_eq CauchyFilter.cauchyFilter_eq

section

attribute [local instance] UniformSpace.separationSetoid

-- porting note: added types in Function.Injective
theorem separated_pureCauchy_injective {Œ± : Type _} [UniformSpace Œ±] [s : SeparatedSpace Œ±] :
    @Function.Injective Œ± (Quotient (UniformSpace.separationSetoid (CauchyFilter Œ±)))
      fun a : Œ± => ‚ü¶pureCauchy a‚üß
  | a, b, h => by
    refine separated_def.1 s _ _ (fun s hs => ?_)
    rw [‚Üê (@uniformEmbedding_pureCauchy Œ± _).comap_uniformity, Filter.mem_comap] at hs
    obtain ‚ü®t, ht, hts‚ü© := hs
    exact @hts (a, b) (Quotient.exact h t ht)
set_option linter.uppercaseLean3 false in
#align Cauchy.separated_pure_cauchy_injective CauchyFilter.separated_pureCauchy_injective

end

end CauchyFilter

attribute [local instance] UniformSpace.separationSetoid

open CauchyFilter Set

namespace UniformSpace

variable (Œ± : Type _) [UniformSpace Œ±]

variable {Œ≤ : Type _} [UniformSpace Œ≤]

variable {Œ≥ : Type _} [UniformSpace Œ≥]

instance completeSpace_separation [h : CompleteSpace Œ±] :
    CompleteSpace (Quotient (separationSetoid Œ±)) := by
  constructor
  intro f hf
  have : Cauchy (f.comap fun x => ‚ü¶x‚üß) :=
    hf.comap' comap_quotient_le_uniformity <| hf.left.comap_of_surj (surjective_quotient_mk _)
  let ‚ü®x, (hx : (f.comap fun x => ‚ü¶x‚üß) ‚â§ ùìù x)‚ü© := CompleteSpace.complete this
  exact ‚ü®‚ü¶x‚üß,
    (comap_le_comap_iff <| by simp).1
      (hx.trans <| map_le_iff_le_comap.1 continuous_quotient_mk'.continuousAt)‚ü©
#align uniform_space.complete_space_separation UniformSpace.completeSpace_separation

/-- Hausdorff completion of `Œ±` -/
def Completion :=
  Quotient (separationSetoid <| CauchyFilter Œ±)
#align uniform_space.completion UniformSpace.Completion

namespace Completion

instance inhabited [Inhabited Œ±] : Inhabited (Completion Œ±) :=
  Quotient.instInhabitedQuotient (separationSetoid (CauchyFilter Œ±))

instance (priority := 50) uniformSpace : UniformSpace (Completion Œ±) :=
  separationSetoid.uniformSpace

instance completeSpace : CompleteSpace (Completion Œ±) :=
  UniformSpace.completeSpace_separation (CauchyFilter Œ±)

instance separatedSpace : SeparatedSpace (Completion Œ±) :=
  UniformSpace.separated_separation

instance t3Space : T3Space (Completion Œ±) :=
  separated_t3

/-- The map from a uniform space to its completion.

porting note: this was added to create a target for the `@[coe]` attribute. -/
@[coe] def coe' : Œ± ‚Üí Completion Œ± := Quotient.mk' ‚àò pureCauchy

/-- Automatic coercion from `Œ±` to its completion. Not always injective. -/
instance : Coe Œ± (Completion Œ±) :=
  ‚ü®coe' Œ±‚ü©

-- note [use has_coe_t]
protected theorem coe_eq : ((‚Üë) : Œ± ‚Üí Completion Œ±) = Quotient.mk' ‚àò pureCauchy :=
  rfl
#align uniform_space.completion.coe_eq UniformSpace.Completion.coe_eq

theorem comap_coe_eq_uniformity :
    ((ùì§ _).comap fun p : Œ± √ó Œ± => ((p.1 : Completion Œ±), (p.2 : Completion Œ±))) = ùì§ Œ± := by
  have :
    (fun x : Œ± √ó Œ± => ((x.1 : Completion Œ±), (x.2 : Completion Œ±))) =
      (fun x : CauchyFilter Œ± √ó CauchyFilter Œ± => (‚ü¶x.1‚üß, ‚ü¶x.2‚üß)) ‚àò fun x : Œ± √ó Œ± =>
        (pureCauchy x.1, pureCauchy x.2) :=
    by ext ‚ü®a, b‚ü© <;> simp <;> rfl
  rw [this, ‚Üê Filter.comap_comap]
  change Filter.comap _ (Filter.comap _ (ùì§ <| Quotient <| separationSetoid <| CauchyFilter Œ±)) = ùì§ Œ±
  rw [comap_quotient_eq_uniformity, uniformEmbedding_pureCauchy.comap_uniformity]
#align uniform_space.completion.comap_coe_eq_uniformity UniformSpace.Completion.comap_coe_eq_uniformity

theorem uniformInducing_coe : UniformInducing ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  ‚ü®comap_coe_eq_uniformity Œ±‚ü©
#align uniform_space.completion.uniform_inducing_coe UniformSpace.Completion.uniformInducing_coe

variable {Œ±}

theorem denseRange_coe : DenseRange ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  denseRange_pureCauchy.quotient
#align uniform_space.completion.dense_range_coe UniformSpace.Completion.denseRange_coe

variable (Œ±)

/-- The Haudorff completion as an abstract completion. -/
def cPkg {Œ± : Type _} [UniformSpace Œ±] : AbstractCompletion Œ± where
  space := Completion Œ±
  coe := (‚Üë)
  uniformStruct := by infer_instance
  complete := by infer_instance
  separation := by infer_instance
  uniformInducing := Completion.uniformInducing_coe Œ±
  dense := Completion.denseRange_coe
#align uniform_space.completion.cpkg UniformSpace.Completion.cPkg

instance AbstractCompletion.inhabited : Inhabited (AbstractCompletion Œ±) :=
  ‚ü®cPkg‚ü©
#align uniform_space.completion.abstract_completion.inhabited UniformSpace.Completion.AbstractCompletion.inhabited

attribute [local instance]
  AbstractCompletion.uniformStruct AbstractCompletion.complete AbstractCompletion.separation

theorem nonempty_completion_iff : Nonempty (Completion Œ±) ‚Üî Nonempty Œ± :=
  cPkg.dense.nonempty_iff.symm
#align uniform_space.completion.nonempty_completion_iff UniformSpace.Completion.nonempty_completion_iff

theorem uniformContinuous_coe : UniformContinuous ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  cPkg.uniformContinuous_coe
#align uniform_space.completion.uniform_continuous_coe UniformSpace.Completion.uniformContinuous_coe

theorem continuous_coe : Continuous ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  cPkg.continuous_coe
#align uniform_space.completion.continuous_coe UniformSpace.Completion.continuous_coe

theorem uniformEmbedding_coe [SeparatedSpace Œ±] : UniformEmbedding ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  { comap_uniformity := comap_coe_eq_uniformity Œ±
    inj := separated_pureCauchy_injective }
#align uniform_space.completion.uniform_embedding_coe UniformSpace.Completion.uniformEmbedding_coe

theorem coe_injective [SeparatedSpace Œ±] : Function.Injective ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  UniformEmbedding.inj (uniformEmbedding_coe _)
#align uniform_space.completion.coe_injective UniformSpace.Completion.coe_injective

variable {Œ±}

theorem denseInducing_coe : DenseInducing ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  { (uniformInducing_coe Œ±).inducing with dense := denseRange_coe }
#align uniform_space.completion.dense_inducing_coe UniformSpace.Completion.denseInducing_coe

/-- The uniform bijection between a complete space and its uniform completion. -/
def UniformCompletion.completeEquivSelf [CompleteSpace Œ±] [SeparatedSpace Œ±] : Completion Œ± ‚âÉ·µ§ Œ± :=
  AbstractCompletion.compareEquiv Completion.cPkg AbstractCompletion.ofComplete
#align uniform_space.completion.uniform_completion.complete_equiv_self UniformSpace.Completion.UniformCompletion.completeEquivSelf

open TopologicalSpace

instance separableSpace_completion [SeparableSpace Œ±] : SeparableSpace (Completion Œ±) :=
  Completion.denseInducing_coe.separableSpace
#align uniform_space.completion.separable_space_completion UniformSpace.Completion.separableSpace_completion

theorem denseEmbedding_coe [SeparatedSpace Œ±] : DenseEmbedding ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  { denseInducing_coe with inj := separated_pureCauchy_injective }
#align uniform_space.completion.dense_embedding_coe UniformSpace.Completion.denseEmbedding_coe

theorem denseRange_coe‚ÇÇ :
    DenseRange fun x : Œ± √ó Œ≤ => ((x.1 : Completion Œ±), (x.2 : Completion Œ≤)) :=
  denseRange_coe.prod_map denseRange_coe
#align uniform_space.completion.dense_range_coe‚ÇÇ UniformSpace.Completion.denseRange_coe‚ÇÇ

theorem denseRange_coe‚ÇÉ :
    DenseRange fun x : Œ± √ó Œ≤ √ó Œ≥ =>
      ((x.1 : Completion Œ±), ((x.2.1 : Completion Œ≤), (x.2.2 : Completion Œ≥))) :=
  denseRange_coe.prod_map denseRange_coe‚ÇÇ
#align uniform_space.completion.dense_range_coe‚ÇÉ UniformSpace.Completion.denseRange_coe‚ÇÉ

@[elab_as_elim]
theorem induction_on {p : Completion Œ± ‚Üí Prop} (a : Completion Œ±) (hp : IsClosed { a | p a })
    (ih : ‚àÄ a : Œ±, p a) : p a :=
  isClosed_property denseRange_coe hp ih a
#align uniform_space.completion.induction_on UniformSpace.Completion.induction_on

@[elab_as_elim]
theorem induction_on‚ÇÇ {p : Completion Œ± ‚Üí Completion Œ≤ ‚Üí Prop} (a : Completion Œ±) (b : Completion Œ≤)
    (hp : IsClosed { x : Completion Œ± √ó Completion Œ≤ | p x.1 x.2 })
    (ih : ‚àÄ (a : Œ±) (b : Œ≤), p a b) : p a b :=
  have : ‚àÄ x : Completion Œ± √ó Completion Œ≤, p x.1 x.2 :=
    isClosed_property denseRange_coe‚ÇÇ hp fun ‚ü®a, b‚ü© => ih a b
  this (a, b)
#align uniform_space.completion.induction_on‚ÇÇ UniformSpace.Completion.induction_on‚ÇÇ

@[elab_as_elim]
theorem induction_on‚ÇÉ {p : Completion Œ± ‚Üí Completion Œ≤ ‚Üí Completion Œ≥ ‚Üí Prop} (a : Completion Œ±)
    (b : Completion Œ≤) (c : Completion Œ≥)
    (hp : IsClosed { x : Completion Œ± √ó Completion Œ≤ √ó Completion Œ≥ | p x.1 x.2.1 x.2.2 })
    (ih : ‚àÄ (a : Œ±) (b : Œ≤) (c : Œ≥), p a b c) : p a b c :=
  have : ‚àÄ x : Completion Œ± √ó Completion Œ≤ √ó Completion Œ≥, p x.1 x.2.1 x.2.2 :=
    isClosed_property denseRange_coe‚ÇÉ hp fun ‚ü®a, b, c‚ü© => ih a b c
  this (a, b, c)
#align uniform_space.completion.induction_on‚ÇÉ UniformSpace.Completion.induction_on‚ÇÉ

theorem ext {Y : Type _} [TopologicalSpace Y] [T2Space Y] {f g : Completion Œ± ‚Üí Y}
    (hf : Continuous f) (hg : Continuous g) (h : ‚àÄ a : Œ±, f a = g a) : f = g :=
  cPkg.funext hf hg h
#align uniform_space.completion.ext UniformSpace.Completion.ext

theorem ext' {Y : Type _} [TopologicalSpace Y] [T2Space Y] {f g : Completion Œ± ‚Üí Y}
    (hf : Continuous f) (hg : Continuous g) (h : ‚àÄ a : Œ±, f a = g a) (a : Completion Œ±) :
    f a = g a :=
  congr_fun (ext hf hg h) a
#align uniform_space.completion.ext' UniformSpace.Completion.ext'

section Extension

variable {f : Œ± ‚Üí Œ≤}

/-- "Extension" to the completion. It is defined for any map `f` but
returns an arbitrary constant value if `f` is not uniformly continuous -/
protected def extension (f : Œ± ‚Üí Œ≤) : Completion Œ± ‚Üí Œ≤ :=
  cPkg.extend f
#align uniform_space.completion.extension UniformSpace.Completion.extension

section CompleteSpace

variable [CompleteSpace Œ≤]

theorem uniformContinuous_extension : UniformContinuous (Completion.extension f) :=
  cPkg.uniformContinuous_extend
#align uniform_space.completion.uniform_continuous_extension UniformSpace.Completion.uniformContinuous_extension

@[continuity]
theorem continuous_extension : Continuous (Completion.extension f) :=
  cPkg.continuous_extend
#align uniform_space.completion.continuous_extension UniformSpace.Completion.continuous_extension

end CompleteSpace

/- porting note: removed `@[simp]` because this lemma doesn't even trigger on itself in Lean 3 or
Lean 4 unless the user manually supplies the `hf` argument, so it is useless as a `simp` lemma. -/
theorem extension_coe [SeparatedSpace Œ≤] (hf : UniformContinuous f) (a : Œ±) :
    (Completion.extension f) a = f a :=
  cPkg.extend_coe hf a
#align uniform_space.completion.extension_coe UniformSpace.Completion.extension_coe

variable [SeparatedSpace Œ≤] [CompleteSpace Œ≤]

theorem extension_unique (hf : UniformContinuous f) {g : Completion Œ± ‚Üí Œ≤}
    (hg : UniformContinuous g) (h : ‚àÄ a : Œ±, f a = g (a : Completion Œ±)) :
    Completion.extension f = g :=
  cPkg.extend_unique hf hg h
#align uniform_space.completion.extension_unique UniformSpace.Completion.extension_unique

@[simp]
theorem extension_comp_coe {f : Completion Œ± ‚Üí Œ≤} (hf : UniformContinuous f) :
    Completion.extension (f ‚àò (‚Üë)) = f :=
  cPkg.extend_comp_coe hf
#align uniform_space.completion.extension_comp_coe UniformSpace.Completion.extension_comp_coe

end Extension

section Map

variable {f : Œ± ‚Üí Œ≤}

/-- Completion functor acting on morphisms -/
protected def map (f : Œ± ‚Üí Œ≤) : Completion Œ± ‚Üí Completion Œ≤ :=
  cPkg.map cPkg f
#align uniform_space.completion.map UniformSpace.Completion.map

theorem uniformContinuous_map : UniformContinuous (Completion.map f) :=
  cPkg.uniformContinuous_map cPkg f
#align uniform_space.completion.uniform_continuous_map UniformSpace.Completion.uniformContinuous_map

@[continuity]
theorem continuous_map : Continuous (Completion.map f) :=
  cPkg.continuous_map cPkg f
#align uniform_space.completion.continuous_map UniformSpace.Completion.continuous_map

/- porting note: removed `@[simp]` because this lemma doesn't even trigger on itself in Lean 3 or
Lean 4 unless the user manually supplies the `hf` argument, so it is useless as a `simp` lemma. -/
theorem map_coe (hf : UniformContinuous f) (a : Œ±) : (Completion.map f) a = f a :=
  cPkg.map_coe cPkg hf a
#align uniform_space.completion.map_coe UniformSpace.Completion.map_coe

theorem map_unique {f : Œ± ‚Üí Œ≤} {g : Completion Œ± ‚Üí Completion Œ≤} (hg : UniformContinuous g)
    (h : ‚àÄ a : Œ±, ‚Üë(f a) = g a) : Completion.map f = g :=
  cPkg.map_unique cPkg hg h
#align uniform_space.completion.map_unique UniformSpace.Completion.map_unique

@[simp]
theorem map_id : Completion.map (@id Œ±) = id :=
  cPkg.map_id
#align uniform_space.completion.map_id UniformSpace.Completion.map_id

theorem extension_map [CompleteSpace Œ≥] [SeparatedSpace Œ≥] {f : Œ≤ ‚Üí Œ≥} {g : Œ± ‚Üí Œ≤}
    (hf : UniformContinuous f) (hg : UniformContinuous g) :
    Completion.extension f ‚àò Completion.map g = Completion.extension (f ‚àò g) :=
  Completion.ext (continuous_extension.comp continuous_map) continuous_extension <| by
    intro a
    -- porting note: this is not provable by simp [hf, hg, hf.comp hg, map_coe, extension_coe],
    -- but should be?
    rw [extension_coe (hf.comp hg), Function.comp_apply, map_coe hg, extension_coe hf,
      Function.comp_apply]
#align uniform_space.completion.extension_map UniformSpace.Completion.extension_map

theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} (hg : UniformContinuous g) (hf : UniformContinuous f) :
    Completion.map g ‚àò Completion.map f = Completion.map (g ‚àò f) :=
  extension_map ((uniformContinuous_coe _).comp hg) hf
#align uniform_space.completion.map_comp UniformSpace.Completion.map_comp

end Map

/- In this section we construct isomorphisms between the completion of a uniform space and the
completion of its separation quotient -/
section SeparationQuotientCompletion

/-- The isomorphism between the completion of a uniform space and the completion of its separation
quotient. -/
def completionSeparationQuotientEquiv (Œ± : Type u) [UniformSpace Œ±] :
    Completion (SeparationQuotient Œ±) ‚âÉ Completion Œ± := by
  refine'
    ‚ü®Completion.extension (SeparationQuotient.lift ((‚Üë) : Œ± ‚Üí Completion Œ±)),
      Completion.map Quotient.mk', _, _‚ü©
  ¬∑ intro a
    refine' induction_on a (isClosed_eq (continuous_map.comp continuous_extension) continuous_id) _
    rintro ‚ü®a‚ü©
    -- porting note: had to insert rewrites to switch between Quot.mk, Quotient.mk, Quotient.mk'
    rw [‚Üê Quotient.mk,extension_coe (SeparationQuotient.uniformContinuous_lift _),
      SeparationQuotient.lift_mk (uniformContinuous_coe Œ±), map_coe]
    . rfl
    . exact uniformContinuous_quotient_mk
  ¬∑ intro a
    refine' Completion.induction_on a
        (isClosed_eq (continuous_extension.comp continuous_map) continuous_id) fun a => _
    rw [map_coe]
    -- porting note: add SeparationQuotient.lift_mk' for Quotient.mk' ?
    . rw [extension_coe (SeparationQuotient.uniformContinuous_lift _), Quotient.mk',
        SeparationQuotient.lift_mk (uniformContinuous_coe Œ±) _]
    . exact uniformContinuous_quotient_mk
#align uniform_space.completion.completion_separation_quotient_equiv UniformSpace.Completion.completionSeparationQuotientEquiv

theorem uniformContinuous_completionSeparationQuotientEquiv :
    UniformContinuous (completionSeparationQuotientEquiv Œ±) :=
  uniformContinuous_extension
#align uniform_space.completion.uniform_continuous_completion_separation_quotient_equiv UniformSpace.Completion.uniformContinuous_completionSeparationQuotientEquiv

theorem uniformContinuous_completionSeparationQuotientEquiv_symm :
    UniformContinuous (completionSeparationQuotientEquiv Œ±).symm :=
  uniformContinuous_map
#align uniform_space.completion.uniform_continuous_completion_separation_quotient_equiv_symm UniformSpace.Completion.uniformContinuous_completionSeparationQuotientEquiv_symm

end SeparationQuotientCompletion

section Extension‚ÇÇ

variable (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥)

open Function

/-- Extend a two variable map to the Hausdorff completions. -/
protected def extension‚ÇÇ (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : Completion Œ± ‚Üí Completion Œ≤ ‚Üí Œ≥ :=
  cPkg.extend‚ÇÇ cPkg f
#align uniform_space.completion.extension‚ÇÇ UniformSpace.Completion.extension‚ÇÇ

section SeparatedSpace

variable [SeparatedSpace Œ≥] {f}

/- porting note: removed `@[simp]` because this lemma doesn't even trigger on itself in Lean 3 or
Lean 4 unless the user manually supplies the `hf` argument, so it is useless as a `simp` lemma. -/
theorem extension‚ÇÇ_coe_coe (hf : UniformContinuous‚ÇÇ f) (a : Œ±) (b : Œ≤) :
    Completion.extension‚ÇÇ f a b = f a b :=
  cPkg.extension‚ÇÇ_coe_coe cPkg hf a b
#align uniform_space.completion.extension‚ÇÇ_coe_coe UniformSpace.Completion.extension‚ÇÇ_coe_coe

end SeparatedSpace

variable [CompleteSpace Œ≥]

theorem uniformContinuous_extension‚ÇÇ : UniformContinuous‚ÇÇ (Completion.extension‚ÇÇ f) :=
  cPkg.uniformContinuous_extension‚ÇÇ cPkg f
#align uniform_space.completion.uniform_continuous_extension‚ÇÇ UniformSpace.Completion.uniformContinuous_extension‚ÇÇ

end Extension‚ÇÇ

section Map‚ÇÇ

open Function

/-- Lift a two variable map to the Hausdorff completions. -/
protected def map‚ÇÇ (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : Completion Œ± ‚Üí Completion Œ≤ ‚Üí Completion Œ≥ :=
  cPkg.map‚ÇÇ cPkg cPkg f
#align uniform_space.completion.map‚ÇÇ UniformSpace.Completion.map‚ÇÇ

theorem uniformContinuous_map‚ÇÇ (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : UniformContinuous‚ÇÇ (Completion.map‚ÇÇ f) :=
  cPkg.uniformContinuous_map‚ÇÇ cPkg cPkg f
#align uniform_space.completion.uniform_continuous_map‚ÇÇ UniformSpace.Completion.uniformContinuous_map‚ÇÇ

theorem continuous_map‚ÇÇ {Œ¥} [TopologicalSpace Œ¥] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {a : Œ¥ ‚Üí Completion Œ±}
    {b : Œ¥ ‚Üí Completion Œ≤} (ha : Continuous a) (hb : Continuous b) :
    Continuous fun d : Œ¥ => Completion.map‚ÇÇ f (a d) (b d) :=
  cPkg.continuous_map‚ÇÇ cPkg cPkg ha hb
#align uniform_space.completion.continuous_map‚ÇÇ UniformSpace.Completion.continuous_map‚ÇÇ

theorem map‚ÇÇ_coe_coe (a : Œ±) (b : Œ≤) (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (hf : UniformContinuous‚ÇÇ f) :
    Completion.map‚ÇÇ f (a : Completion Œ±) (b : Completion Œ≤) = f a b :=
  cPkg.map‚ÇÇ_coe_coe cPkg cPkg a b f hf
#align uniform_space.completion.map‚ÇÇ_coe_coe UniformSpace.Completion.map‚ÇÇ_coe_coe

end Map‚ÇÇ

end Completion

end UniformSpace
