/-
Copyright (c) 2018 Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Patrick Massot, Johannes H√∂lzl
-/
import Mathlib.Topology.UniformSpace.AbstractCompletion

#align_import topology.uniform_space.completion from "leanprover-community/mathlib"@"dc6c365e751e34d100e80fe6e314c3c3e0fd2988"

/-!
# Hausdorff completions of uniform spaces

The goal is to construct a left-adjoint to the inclusion of complete Hausdorff uniform spaces
into all uniform spaces. Any uniform space `Œ±` gets a completion `Completion Œ±` and a morphism
(ie. uniformly continuous map) `(‚Üë) : Œ± ‚Üí Completion Œ±` which solves the universal
mapping problem of factorizing morphisms from `Œ±` to any complete Hausdorff uniform space `Œ≤`.
It means any uniformly continuous `f : Œ± ‚Üí Œ≤` gives rise to a unique morphism
`Completion.extension f : Completion Œ± ‚Üí Œ≤` such that `f = Completion.extension f ‚àò (‚Üë)`.
Actually `Completion.extension f` is defined for all maps from `Œ±` to `Œ≤` but it has the desired
properties only if `f` is uniformly continuous.

Beware that `(‚Üë)` is not injective if `Œ±` is not Hausdorff. But its image is always
dense. The adjoint functor acting on morphisms is then constructed by the usual abstract nonsense.
For every uniform spaces `Œ±` and `Œ≤`, it turns `f : Œ± ‚Üí Œ≤` into a morphism
  `Completion.map f : Completion Œ± ‚Üí Completion Œ≤`
such that
  `(‚Üë) ‚àò f = (Completion.map f) ‚àò (‚Üë)`
provided `f` is uniformly continuous. This construction is compatible with composition.

In this file we introduce the following concepts:

* `CauchyFilter Œ±` the uniform completion of the uniform space `Œ±` (using Cauchy filters).
  These are not minimal filters.

* `Completion Œ± := Quotient (separationSetoid (CauchyFilter Œ±))` the Hausdorff completion.

## References

This formalization is mostly based on
  N. Bourbaki: General Topology
  I. M. James: Topologies and Uniformities
From a slightly different perspective in order to reuse material in `Topology.UniformSpace.Basic`.
-/


noncomputable section

open Filter Set

universe u v w x

open scoped Classical
open Uniformity Topology Filter

/-- Space of Cauchy filters

This is essentially the completion of a uniform space. The embeddings are the neighbourhood filters.
This space is not minimal, the separated uniform space (i.e. quotiented on the intersection of all
entourages) is necessary for this.
-/
def CauchyFilter (Œ± : Type u) [UniformSpace Œ±] : Type u :=
  { f : Filter Œ± // Cauchy f }
set_option linter.uppercaseLean3 false in
#align Cauchy CauchyFilter

namespace CauchyFilter

section

variable {Œ± : Type u} [UniformSpace Œ±]
variable {Œ≤ : Type v} {Œ≥ : Type w}
variable [UniformSpace Œ≤] [UniformSpace Œ≥]

instance (f : CauchyFilter Œ±) : NeBot f.1 := f.2.1

/-- The pairs of Cauchy filters generated by a set. -/
def gen (s : Set (Œ± √ó Œ±)) : Set (CauchyFilter Œ± √ó CauchyFilter Œ±) :=
  { p | s ‚àà p.1.val √óÀ¢ p.2.val }
set_option linter.uppercaseLean3 false in
#align Cauchy.gen CauchyFilter.gen

theorem monotone_gen : Monotone (gen : Set (Œ± √ó Œ±) ‚Üí _) :=
  monotone_setOf fun p => @Filter.monotone_mem _ (p.1.val √óÀ¢ p.2.val)
set_option linter.uppercaseLean3 false in
#align Cauchy.monotone_gen CauchyFilter.monotone_gen

-- Porting note: this was a calc proof, but I could not make it work
private theorem symm_gen : map Prod.swap ((ùì§ Œ±).lift' gen) ‚â§ (ùì§ Œ±).lift' gen := by
  let f := fun s : Set (Œ± √ó Œ±) =>
        { p : CauchyFilter Œ± √ó CauchyFilter Œ± | s ‚àà (p.2.val √óÀ¢ p.1.val : Filter (Œ± √ó Œ±)) }
  have h‚ÇÅ : map Prod.swap ((ùì§ Œ±).lift' gen) = (ùì§ Œ±).lift' f := by
    delta gen
    simp [map_lift'_eq, monotone_setOf, Filter.monotone_mem, Function.comp,
      image_swap_eq_preimage_swap]
  have h‚ÇÇ : (ùì§ Œ±).lift' f ‚â§ (ùì§ Œ±).lift' gen :=
    uniformity_lift_le_swap
      (monotone_principal.comp
        (monotone_setOf fun p => @Filter.monotone_mem _ (p.2.val √óÀ¢ p.1.val)))
      (by
        have h := fun p : CauchyFilter Œ± √ó CauchyFilter Œ± => @Filter.prod_comm _ _ p.2.val p.1.val
        simp [f, Function.comp, h, mem_map']
        exact le_rfl)
  exact h‚ÇÅ.trans_le h‚ÇÇ

private theorem compRel_gen_gen_subset_gen_compRel {s t : Set (Œ± √ó Œ±)} :
    compRel (gen s) (gen t) ‚äÜ (gen (compRel s t) : Set (CauchyFilter Œ± √ó CauchyFilter Œ±)) :=
  fun ‚ü®f, g‚ü© ‚ü®h, h‚ÇÅ, h‚ÇÇ‚ü© =>
  let ‚ü®t‚ÇÅ, (ht‚ÇÅ : t‚ÇÅ ‚àà f.val), t‚ÇÇ, (ht‚ÇÇ : t‚ÇÇ ‚àà h.val), (h‚ÇÅ : t‚ÇÅ √óÀ¢ t‚ÇÇ ‚äÜ s)‚ü© := mem_prod_iff.mp h‚ÇÅ
  let ‚ü®t‚ÇÉ, (ht‚ÇÉ : t‚ÇÉ ‚àà h.val), t‚ÇÑ, (ht‚ÇÑ : t‚ÇÑ ‚àà g.val), (h‚ÇÇ : t‚ÇÉ √óÀ¢ t‚ÇÑ ‚äÜ t)‚ü© := mem_prod_iff.mp h‚ÇÇ
  have : t‚ÇÇ ‚à© t‚ÇÉ ‚àà h.val := inter_mem ht‚ÇÇ ht‚ÇÉ
  let ‚ü®x, xt‚ÇÇ, xt‚ÇÉ‚ü© := h.property.left.nonempty_of_mem this
  (f.val √óÀ¢ g.val).sets_of_superset (prod_mem_prod ht‚ÇÅ ht‚ÇÑ)
    fun ‚ü®a, b‚ü© ‚ü®(ha : a ‚àà t‚ÇÅ), (hb : b ‚àà t‚ÇÑ)‚ü© =>
    ‚ü®x, h‚ÇÅ (show (a, x) ‚àà t‚ÇÅ √óÀ¢ t‚ÇÇ from ‚ü®ha, xt‚ÇÇ‚ü©), h‚ÇÇ (show (x, b) ‚àà t‚ÇÉ √óÀ¢ t‚ÇÑ from ‚ü®xt‚ÇÉ, hb‚ü©)‚ü©

private theorem comp_gen : (((ùì§ Œ±).lift' gen).lift' fun s => compRel s s) ‚â§ (ùì§ Œ±).lift' gen :=
  calc
    (((ùì§ Œ±).lift' gen).lift' fun s => compRel s s) =
        (ùì§ Œ±).lift' fun s => compRel (gen s) (gen s) := by
      rw [lift'_lift'_assoc]
      ¬∑ exact monotone_gen
      ¬∑ exact monotone_id.compRel monotone_id
    _ ‚â§ (ùì§ Œ±).lift' fun s => gen <| compRel s s :=
      lift'_mono' fun s _hs => compRel_gen_gen_subset_gen_compRel
    _ = ((ùì§ Œ±).lift' fun s : Set (Œ± √ó Œ±) => compRel s s).lift' gen := by
      rw [lift'_lift'_assoc]
      ¬∑ exact monotone_id.compRel monotone_id
      ¬∑ exact monotone_gen
    _ ‚â§ (ùì§ Œ±).lift' gen := lift'_mono comp_le_uniformity le_rfl

instance : UniformSpace (CauchyFilter Œ±) :=
  UniformSpace.ofCore
    { uniformity := (ùì§ Œ±).lift' gen
      refl := principal_le_lift'.2 fun _s hs ‚ü®a, b‚ü© =>
        fun (a_eq_b : a = b) => a_eq_b ‚ñ∏ a.property.right hs
      symm := symm_gen
      comp := comp_gen }

theorem mem_uniformity {s : Set (CauchyFilter Œ± √ó CauchyFilter Œ±)} :
    s ‚àà ùì§ (CauchyFilter Œ±) ‚Üî ‚àÉ t ‚àà ùì§ Œ±, gen t ‚äÜ s :=
  mem_lift'_sets monotone_gen
set_option linter.uppercaseLean3 false in
#align Cauchy.mem_uniformity CauchyFilter.mem_uniformity

theorem basis_uniformity {Œπ : Sort*} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set (Œ± √ó Œ±)} (h : (ùì§ Œ±).HasBasis p s) :
    (ùì§ (CauchyFilter Œ±)).HasBasis p (gen ‚àò s) :=
  h.lift' monotone_gen

theorem mem_uniformity' {s : Set (CauchyFilter Œ± √ó CauchyFilter Œ±)} :
    s ‚àà ùì§ (CauchyFilter Œ±) ‚Üî ‚àÉ t ‚àà ùì§ Œ±, ‚àÄ f g : CauchyFilter Œ±, t ‚àà f.1 √óÀ¢ g.1 ‚Üí (f, g) ‚àà s := by
  refine mem_uniformity.trans (exists_congr (fun t => and_congr_right_iff.mpr (fun _h => ?_)))
  exact ‚ü®fun h _f _g ht => h ht, fun h _p hp => h _ _ hp‚ü©
set_option linter.uppercaseLean3 false in
#align Cauchy.mem_uniformity' CauchyFilter.mem_uniformity'

/-- Embedding of `Œ±` into its completion `CauchyFilter Œ±` -/
def pureCauchy (a : Œ±) : CauchyFilter Œ± :=
  ‚ü®pure a, cauchy_pure‚ü©
set_option linter.uppercaseLean3 false in
#align Cauchy.pure_cauchy CauchyFilter.pureCauchy

theorem uniformInducing_pureCauchy : UniformInducing (pureCauchy : Œ± ‚Üí CauchyFilter Œ±) :=
  ‚ü®have : (preimage fun x : Œ± √ó Œ± => (pureCauchy x.fst, pureCauchy x.snd)) ‚àò gen = id :=
      funext fun s =>
        Set.ext fun ‚ü®a‚ÇÅ, a‚ÇÇ‚ü© => by simp [preimage, gen, pureCauchy, prod_principal_principal]
    calc
      comap (fun x : Œ± √ó Œ± => (pureCauchy x.fst, pureCauchy x.snd)) ((ùì§ Œ±).lift' gen) =
          (ùì§ Œ±).lift' ((preimage fun x : Œ± √ó Œ± => (pureCauchy x.fst, pureCauchy x.snd)) ‚àò gen) :=
        comap_lift'_eq
      _ = ùì§ Œ± := by simp [this]
      ‚ü©
set_option linter.uppercaseLean3 false in
#align Cauchy.uniform_inducing_pure_cauchy CauchyFilter.uniformInducing_pureCauchy

theorem uniformEmbedding_pureCauchy : UniformEmbedding (pureCauchy : Œ± ‚Üí CauchyFilter Œ±) :=
  { uniformInducing_pureCauchy with
    inj := fun _a‚ÇÅ _a‚ÇÇ h => pure_injective <| Subtype.ext_iff_val.1 h }
set_option linter.uppercaseLean3 false in
#align Cauchy.uniform_embedding_pure_cauchy CauchyFilter.uniformEmbedding_pureCauchy

theorem denseRange_pureCauchy : DenseRange (pureCauchy : Œ± ‚Üí CauchyFilter Œ±) := fun f => by
  have h_ex : ‚àÄ s ‚àà ùì§ (CauchyFilter Œ±), ‚àÉ y : Œ±, (f, pureCauchy y) ‚àà s := fun s hs =>
    let ‚ü®t'', ht''‚ÇÅ, (ht''‚ÇÇ : gen t'' ‚äÜ s)‚ü© := (mem_lift'_sets monotone_gen).mp hs
    let ‚ü®t', ht'‚ÇÅ, ht'‚ÇÇ‚ü© := comp_mem_uniformity_sets ht''‚ÇÅ
    have : t' ‚àà f.val √óÀ¢ f.val := f.property.right ht'‚ÇÅ
    let ‚ü®t, ht, (h : t √óÀ¢ t ‚äÜ t')‚ü© := mem_prod_same_iff.mp this
    let ‚ü®x, (hx : x ‚àà t)‚ü© := f.property.left.nonempty_of_mem ht
    have : t'' ‚àà f.val √óÀ¢ pure x :=
      mem_prod_iff.mpr
        ‚ü®t, ht, { y : Œ± | (x, y) ‚àà t' }, h <| mk_mem_prod hx hx,
          fun ‚ü®a, b‚ü© ‚ü®(h‚ÇÅ : a ‚àà t), (h‚ÇÇ : (x, b) ‚àà t')‚ü© =>
          ht'‚ÇÇ <| prod_mk_mem_compRel (@h (a, x) ‚ü®h‚ÇÅ, hx‚ü©) h‚ÇÇ‚ü©
    ‚ü®x, ht''‚ÇÇ <| by dsimp [gen]; exact this‚ü©
  simp only [closure_eq_cluster_pts, ClusterPt, nhds_eq_uniformity, lift'_inf_principal_eq,
    Set.inter_comm _ (range pureCauchy), mem_setOf_eq]
  refine (lift'_neBot_iff ?_).mpr (fun s hs => ?_)
  ¬∑ exact monotone_const.inter monotone_preimage
  ¬∑ let ‚ü®y, hy‚ü© := h_ex s hs
    have : pureCauchy y ‚àà range pureCauchy ‚à© { y : CauchyFilter Œ± | (f, y) ‚àà s } :=
      ‚ü®mem_range_self y, hy‚ü©
    exact ‚ü®_, this‚ü©
set_option linter.uppercaseLean3 false in
#align Cauchy.dense_range_pure_cauchy CauchyFilter.denseRange_pureCauchy

theorem denseInducing_pureCauchy : DenseInducing (pureCauchy : Œ± ‚Üí CauchyFilter Œ±) :=
  uniformInducing_pureCauchy.denseInducing denseRange_pureCauchy
set_option linter.uppercaseLean3 false in
#align Cauchy.dense_inducing_pure_cauchy CauchyFilter.denseInducing_pureCauchy

theorem denseEmbedding_pureCauchy : DenseEmbedding (pureCauchy : Œ± ‚Üí CauchyFilter Œ±) :=
  uniformEmbedding_pureCauchy.denseEmbedding denseRange_pureCauchy
set_option linter.uppercaseLean3 false in
#align Cauchy.dense_embedding_pure_cauchy CauchyFilter.denseEmbedding_pureCauchy

theorem nonempty_cauchyFilter_iff : Nonempty (CauchyFilter Œ±) ‚Üî Nonempty Œ± := by
  constructor <;> rintro ‚ü®c‚ü©
  ¬∑ have := eq_univ_iff_forall.1 denseEmbedding_pureCauchy.toDenseInducing.closure_range c
    obtain ‚ü®_, ‚ü®_, a, _‚ü©‚ü© := mem_closure_iff.1 this _ isOpen_univ trivial
    exact ‚ü®a‚ü©
  ¬∑ exact ‚ü®pureCauchy c‚ü©
set_option linter.uppercaseLean3 false in
#align Cauchy.nonempty_Cauchy_iff CauchyFilter.nonempty_cauchyFilter_iff

section

-- Porting note: I commented this
-- set_option eqn_compiler.zeta true

instance : CompleteSpace (CauchyFilter Œ±) :=
  completeSpace_extension uniformInducing_pureCauchy denseRange_pureCauchy fun f hf =>
    let f' : CauchyFilter Œ± := ‚ü®f, hf‚ü©
    have : map pureCauchy f ‚â§ (ùì§ <| CauchyFilter Œ±).lift' (preimage (Prod.mk f')) :=
      le_lift'.2 fun s hs =>
        let ‚ü®t, ht‚ÇÅ, (ht‚ÇÇ : gen t ‚äÜ s)‚ü© := (mem_lift'_sets monotone_gen).mp hs
        let ‚ü®t', ht', (h : t' √óÀ¢ t' ‚äÜ t)‚ü© := mem_prod_same_iff.mp (hf.right ht‚ÇÅ)
        have : t' ‚äÜ { y : Œ± | (f', pureCauchy y) ‚àà gen t } := fun x hx =>
          (f √óÀ¢ pure x).sets_of_superset (prod_mem_prod ht' hx) h
        f.sets_of_superset ht' <| Subset.trans this (preimage_mono ht‚ÇÇ)
    ‚ü®f', by simp [nhds_eq_uniformity]; assumption‚ü©

end

instance [Inhabited Œ±] : Inhabited (CauchyFilter Œ±) :=
  ‚ü®pureCauchy default‚ü©

instance [h : Nonempty Œ±] : Nonempty (CauchyFilter Œ±) :=
  h.recOn fun a => Nonempty.intro <| CauchyFilter.pureCauchy a

section Extend

/-- Extend a uniformly continuous function `Œ± ‚Üí Œ≤` to a function `CauchyFilter Œ± ‚Üí Œ≤`.
Outputs junk when `f` is not uniformly continuous. -/
def extend (f : Œ± ‚Üí Œ≤) : CauchyFilter Œ± ‚Üí Œ≤ :=
  if UniformContinuous f then denseInducing_pureCauchy.extend f
  else fun x => f (nonempty_cauchyFilter_iff.1 ‚ü®x‚ü©).some
set_option linter.uppercaseLean3 false in
#align Cauchy.extend CauchyFilter.extend

section T0Space

variable [T0Space Œ≤]

theorem extend_pureCauchy {f : Œ± ‚Üí Œ≤} (hf : UniformContinuous f) (a : Œ±) :
    extend f (pureCauchy a) = f a := by
  rw [extend, if_pos hf]
  exact uniformly_extend_of_ind uniformInducing_pureCauchy denseRange_pureCauchy hf _
set_option linter.uppercaseLean3 false in
#align Cauchy.extend_pure_cauchy CauchyFilter.extend_pureCauchy

end T0Space

variable [CompleteSpace Œ≤]

theorem uniformContinuous_extend {f : Œ± ‚Üí Œ≤} : UniformContinuous (extend f) := by
  by_cases hf : UniformContinuous f
  ¬∑ rw [extend, if_pos hf]
    exact uniformContinuous_uniformly_extend uniformInducing_pureCauchy denseRange_pureCauchy hf
  ¬∑ rw [extend, if_neg hf]
    exact uniformContinuous_of_const fun a _b => by congr
set_option linter.uppercaseLean3 false in
#align Cauchy.uniform_continuous_extend CauchyFilter.uniformContinuous_extend

end Extend

theorem inseparable_iff {f g : CauchyFilter Œ±} : Inseparable f g ‚Üî f.1 √óÀ¢ g.1 ‚â§ ùì§ Œ± :=
  (basis_uniformity (basis_sets _)).inseparable_iff_uniformity

theorem inseparable_iff_of_le_nhds {f g : CauchyFilter Œ±} {a b : Œ±}
    (ha : f.1 ‚â§ ùìù a) (hb : g.1 ‚â§ ùìù b) : Inseparable a b ‚Üî Inseparable f g := by
  rw [‚Üê tendsto_id'] at ha hb
  rw [inseparable_iff, (ha.comp tendsto_fst).inseparable_iff_uniformity (hb.comp tendsto_snd)]
  simp only [Function.comp_apply, id_eq, Prod.mk.eta, ‚Üê Function.id_def, tendsto_id']

theorem inseparable_lim_iff [CompleteSpace Œ±] {f g : CauchyFilter Œ±} :
    haveI := f.2.1.nonempty; Inseparable (lim f.1) (lim g.1) ‚Üî Inseparable f g :=
  inseparable_iff_of_le_nhds f.2.le_nhds_lim g.2.le_nhds_lim

end

theorem cauchyFilter_eq {Œ± : Type*} [UniformSpace Œ±] [CompleteSpace Œ±] [T0Space Œ±]
    {f g : CauchyFilter Œ±} :
    haveI := f.2.1.nonempty; lim f.1 = lim g.1 ‚Üî Inseparable f g := by
  rw [‚Üê inseparable_iff_eq, inseparable_lim_iff]
set_option linter.uppercaseLean3 false in
#align Cauchy.Cauchy_eq CauchyFilter.cauchyFilter_eq

section

theorem separated_pureCauchy_injective {Œ± : Type*} [UniformSpace Œ±] [T0Space Œ±] :
    Function.Injective fun a : Œ± => SeparationQuotient.mk (pureCauchy a) := fun a b h ‚Ü¶
  Inseparable.eq <| (inseparable_iff_of_le_nhds (pure_le_nhds a) (pure_le_nhds b)).2 <|
    SeparationQuotient.mk_eq_mk.1 h
set_option linter.uppercaseLean3 false in
#align Cauchy.separated_pure_cauchy_injective CauchyFilter.separated_pureCauchy_injective

end

end CauchyFilter

open CauchyFilter Set

namespace UniformSpace

variable (Œ± : Type*) [UniformSpace Œ±]
variable {Œ≤ : Type*} [UniformSpace Œ≤]
variable {Œ≥ : Type*} [UniformSpace Œ≥]

/-- Hausdorff completion of `Œ±` -/
def Completion := SeparationQuotient (CauchyFilter Œ±)
#align uniform_space.completion UniformSpace.Completion

namespace Completion

instance inhabited [Inhabited Œ±] : Inhabited (Completion Œ±) :=
  inferInstanceAs <| Inhabited (Quotient _)

instance uniformSpace : UniformSpace (Completion Œ±) :=
  SeparationQuotient.instUniformSpace

instance completeSpace : CompleteSpace (Completion Œ±) :=
  SeparationQuotient.instCompleteSpace

instance t0Space : T0Space (Completion Œ±) := SeparationQuotient.instT0Space

/-- The map from a uniform space to its completion.

porting note: this was added to create a target for the `@[coe]` attribute. -/
@[coe] def coe' : Œ± ‚Üí Completion Œ± := SeparationQuotient.mk ‚àò pureCauchy

/-- Automatic coercion from `Œ±` to its completion. Not always injective. -/
instance : Coe Œ± (Completion Œ±) :=
  ‚ü®coe' Œ±‚ü©

-- note [use has_coe_t]
protected theorem coe_eq : ((‚Üë) : Œ± ‚Üí Completion Œ±) = SeparationQuotient.mk ‚àò pureCauchy := rfl
#align uniform_space.completion.coe_eq UniformSpace.Completion.coe_eq

theorem uniformInducing_coe : UniformInducing ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  SeparationQuotient.uniformInducing_mk.comp uniformInducing_pureCauchy
#align uniform_space.completion.uniform_inducing_coe UniformSpace.Completion.uniformInducing_coe

theorem comap_coe_eq_uniformity :
    ((ùì§ _).comap fun p : Œ± √ó Œ± => ((p.1 : Completion Œ±), (p.2 : Completion Œ±))) = ùì§ Œ± :=
  (uniformInducing_coe _).1
#align uniform_space.completion.comap_coe_eq_uniformity UniformSpace.Completion.comap_coe_eq_uniformity

variable {Œ±}

theorem denseRange_coe : DenseRange ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  SeparationQuotient.surjective_mk.denseRange.comp denseRange_pureCauchy
    SeparationQuotient.continuous_mk
#align uniform_space.completion.dense_range_coe UniformSpace.Completion.denseRange_coe

variable (Œ±)

/-- The Haudorff completion as an abstract completion. -/
def cPkg {Œ± : Type*} [UniformSpace Œ±] : AbstractCompletion Œ± where
  space := Completion Œ±
  coe := (‚Üë)
  uniformStruct := by infer_instance
  complete := by infer_instance
  separation := by infer_instance
  uniformInducing := Completion.uniformInducing_coe Œ±
  dense := Completion.denseRange_coe
#align uniform_space.completion.cpkg UniformSpace.Completion.cPkg

instance AbstractCompletion.inhabited : Inhabited (AbstractCompletion Œ±) :=
  ‚ü®cPkg‚ü©
#align uniform_space.completion.abstract_completion.inhabited UniformSpace.Completion.AbstractCompletion.inhabited

attribute [local instance]
  AbstractCompletion.uniformStruct AbstractCompletion.complete AbstractCompletion.separation

theorem nonempty_completion_iff : Nonempty (Completion Œ±) ‚Üî Nonempty Œ± :=
  cPkg.dense.nonempty_iff.symm
#align uniform_space.completion.nonempty_completion_iff UniformSpace.Completion.nonempty_completion_iff

theorem uniformContinuous_coe : UniformContinuous ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  cPkg.uniformContinuous_coe
#align uniform_space.completion.uniform_continuous_coe UniformSpace.Completion.uniformContinuous_coe

theorem continuous_coe : Continuous ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  cPkg.continuous_coe
#align uniform_space.completion.continuous_coe UniformSpace.Completion.continuous_coe

theorem uniformEmbedding_coe [T0Space Œ±] : UniformEmbedding ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  { comap_uniformity := comap_coe_eq_uniformity Œ±
    inj := separated_pureCauchy_injective }
#align uniform_space.completion.uniform_embedding_coe UniformSpace.Completion.uniformEmbedding_coe

theorem coe_injective [T0Space Œ±] : Function.Injective ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  UniformEmbedding.inj (uniformEmbedding_coe _)
#align uniform_space.completion.coe_injective UniformSpace.Completion.coe_injective

variable {Œ±}

theorem denseInducing_coe : DenseInducing ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  { (uniformInducing_coe Œ±).inducing with dense := denseRange_coe }
#align uniform_space.completion.dense_inducing_coe UniformSpace.Completion.denseInducing_coe

/-- The uniform bijection between a complete space and its uniform completion. -/
def UniformCompletion.completeEquivSelf [CompleteSpace Œ±] [T0Space Œ±] : Completion Œ± ‚âÉ·µ§ Œ± :=
  AbstractCompletion.compareEquiv Completion.cPkg AbstractCompletion.ofComplete
#align uniform_space.completion.uniform_completion.complete_equiv_self UniformSpace.Completion.UniformCompletion.completeEquivSelf

open TopologicalSpace

instance separableSpace_completion [SeparableSpace Œ±] : SeparableSpace (Completion Œ±) :=
  Completion.denseInducing_coe.separableSpace
#align uniform_space.completion.separable_space_completion UniformSpace.Completion.separableSpace_completion

theorem denseEmbedding_coe [T0Space Œ±] : DenseEmbedding ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  { denseInducing_coe with inj := separated_pureCauchy_injective }
#align uniform_space.completion.dense_embedding_coe UniformSpace.Completion.denseEmbedding_coe

theorem denseRange_coe‚ÇÇ :
    DenseRange fun x : Œ± √ó Œ≤ => ((x.1 : Completion Œ±), (x.2 : Completion Œ≤)) :=
  denseRange_coe.prod_map denseRange_coe
#align uniform_space.completion.dense_range_coe‚ÇÇ UniformSpace.Completion.denseRange_coe‚ÇÇ

theorem denseRange_coe‚ÇÉ :
    DenseRange fun x : Œ± √ó Œ≤ √ó Œ≥ =>
      ((x.1 : Completion Œ±), ((x.2.1 : Completion Œ≤), (x.2.2 : Completion Œ≥))) :=
  denseRange_coe.prod_map denseRange_coe‚ÇÇ
#align uniform_space.completion.dense_range_coe‚ÇÉ UniformSpace.Completion.denseRange_coe‚ÇÉ

@[elab_as_elim]
theorem induction_on {p : Completion Œ± ‚Üí Prop} (a : Completion Œ±) (hp : IsClosed { a | p a })
    (ih : ‚àÄ a : Œ±, p a) : p a :=
  isClosed_property denseRange_coe hp ih a
#align uniform_space.completion.induction_on UniformSpace.Completion.induction_on

@[elab_as_elim]
theorem induction_on‚ÇÇ {p : Completion Œ± ‚Üí Completion Œ≤ ‚Üí Prop} (a : Completion Œ±) (b : Completion Œ≤)
    (hp : IsClosed { x : Completion Œ± √ó Completion Œ≤ | p x.1 x.2 })
    (ih : ‚àÄ (a : Œ±) (b : Œ≤), p a b) : p a b :=
  have : ‚àÄ x : Completion Œ± √ó Completion Œ≤, p x.1 x.2 :=
    isClosed_property denseRange_coe‚ÇÇ hp fun ‚ü®a, b‚ü© => ih a b
  this (a, b)
#align uniform_space.completion.induction_on‚ÇÇ UniformSpace.Completion.induction_on‚ÇÇ

@[elab_as_elim]
theorem induction_on‚ÇÉ {p : Completion Œ± ‚Üí Completion Œ≤ ‚Üí Completion Œ≥ ‚Üí Prop} (a : Completion Œ±)
    (b : Completion Œ≤) (c : Completion Œ≥)
    (hp : IsClosed { x : Completion Œ± √ó Completion Œ≤ √ó Completion Œ≥ | p x.1 x.2.1 x.2.2 })
    (ih : ‚àÄ (a : Œ±) (b : Œ≤) (c : Œ≥), p a b c) : p a b c :=
  have : ‚àÄ x : Completion Œ± √ó Completion Œ≤ √ó Completion Œ≥, p x.1 x.2.1 x.2.2 :=
    isClosed_property denseRange_coe‚ÇÉ hp fun ‚ü®a, b, c‚ü© => ih a b c
  this (a, b, c)
#align uniform_space.completion.induction_on‚ÇÉ UniformSpace.Completion.induction_on‚ÇÉ

theorem ext {Y : Type*} [TopologicalSpace Y] [T2Space Y] {f g : Completion Œ± ‚Üí Y}
    (hf : Continuous f) (hg : Continuous g) (h : ‚àÄ a : Œ±, f a = g a) : f = g :=
  cPkg.funext hf hg h
#align uniform_space.completion.ext UniformSpace.Completion.ext

theorem ext' {Y : Type*} [TopologicalSpace Y] [T2Space Y] {f g : Completion Œ± ‚Üí Y}
    (hf : Continuous f) (hg : Continuous g) (h : ‚àÄ a : Œ±, f a = g a) (a : Completion Œ±) :
    f a = g a :=
  congr_fun (ext hf hg h) a
#align uniform_space.completion.ext' UniformSpace.Completion.ext'

section Extension

variable {f : Œ± ‚Üí Œ≤}

/-- "Extension" to the completion. It is defined for any map `f` but
returns an arbitrary constant value if `f` is not uniformly continuous -/
protected def extension (f : Œ± ‚Üí Œ≤) : Completion Œ± ‚Üí Œ≤ :=
  cPkg.extend f
#align uniform_space.completion.extension UniformSpace.Completion.extension

section CompleteSpace

variable [CompleteSpace Œ≤]

theorem uniformContinuous_extension : UniformContinuous (Completion.extension f) :=
  cPkg.uniformContinuous_extend
#align uniform_space.completion.uniform_continuous_extension UniformSpace.Completion.uniformContinuous_extension

@[continuity, fun_prop]
theorem continuous_extension : Continuous (Completion.extension f) :=
  cPkg.continuous_extend
#align uniform_space.completion.continuous_extension UniformSpace.Completion.continuous_extension

end CompleteSpace

/- porting note: removed `@[simp]` because this lemma doesn't even trigger on itself in Lean 3 or
Lean 4 unless the user manually supplies the `hf` argument, so it is useless as a `simp` lemma. -/
theorem extension_coe [T0Space Œ≤] (hf : UniformContinuous f) (a : Œ±) :
    (Completion.extension f) a = f a :=
  cPkg.extend_coe hf a
#align uniform_space.completion.extension_coe UniformSpace.Completion.extension_coe

variable [T0Space Œ≤] [CompleteSpace Œ≤]

theorem extension_unique (hf : UniformContinuous f) {g : Completion Œ± ‚Üí Œ≤}
    (hg : UniformContinuous g) (h : ‚àÄ a : Œ±, f a = g (a : Completion Œ±)) :
    Completion.extension f = g :=
  cPkg.extend_unique hf hg h
#align uniform_space.completion.extension_unique UniformSpace.Completion.extension_unique

@[simp]
theorem extension_comp_coe {f : Completion Œ± ‚Üí Œ≤} (hf : UniformContinuous f) :
    Completion.extension (f ‚àò (‚Üë)) = f :=
  cPkg.extend_comp_coe hf
#align uniform_space.completion.extension_comp_coe UniformSpace.Completion.extension_comp_coe

end Extension

section Map

variable {f : Œ± ‚Üí Œ≤}

/-- Completion functor acting on morphisms -/
protected def map (f : Œ± ‚Üí Œ≤) : Completion Œ± ‚Üí Completion Œ≤ :=
  cPkg.map cPkg f
#align uniform_space.completion.map UniformSpace.Completion.map

theorem uniformContinuous_map : UniformContinuous (Completion.map f) :=
  cPkg.uniformContinuous_map cPkg f
#align uniform_space.completion.uniform_continuous_map UniformSpace.Completion.uniformContinuous_map

@[continuity]
theorem continuous_map : Continuous (Completion.map f) :=
  cPkg.continuous_map cPkg f
#align uniform_space.completion.continuous_map UniformSpace.Completion.continuous_map

/- porting note: removed `@[simp]` because this lemma doesn't even trigger on itself in Lean 3 or
Lean 4 unless the user manually supplies the `hf` argument, so it is useless as a `simp` lemma. -/
theorem map_coe (hf : UniformContinuous f) (a : Œ±) : (Completion.map f) a = f a :=
  cPkg.map_coe cPkg hf a
#align uniform_space.completion.map_coe UniformSpace.Completion.map_coe

theorem map_unique {f : Œ± ‚Üí Œ≤} {g : Completion Œ± ‚Üí Completion Œ≤} (hg : UniformContinuous g)
    (h : ‚àÄ a : Œ±, ‚Üë(f a) = g a) : Completion.map f = g :=
  cPkg.map_unique cPkg hg h
#align uniform_space.completion.map_unique UniformSpace.Completion.map_unique

@[simp]
theorem map_id : Completion.map (@id Œ±) = id :=
  cPkg.map_id
#align uniform_space.completion.map_id UniformSpace.Completion.map_id

theorem extension_map [CompleteSpace Œ≥] [T0Space Œ≥] {f : Œ≤ ‚Üí Œ≥} {g : Œ± ‚Üí Œ≤}
    (hf : UniformContinuous f) (hg : UniformContinuous g) :
    Completion.extension f ‚àò Completion.map g = Completion.extension (f ‚àò g) :=
  Completion.ext (continuous_extension.comp continuous_map) continuous_extension <| by
    intro a
    -- Porting note: this is not provable by simp [hf, hg, hf.comp hg, map_coe, extension_coe],
    -- but should be?
    rw [extension_coe (hf.comp hg), Function.comp_apply, map_coe hg, extension_coe hf,
      Function.comp_apply]
#align uniform_space.completion.extension_map UniformSpace.Completion.extension_map

theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} (hg : UniformContinuous g) (hf : UniformContinuous f) :
    Completion.map g ‚àò Completion.map f = Completion.map (g ‚àò f) :=
  extension_map ((uniformContinuous_coe _).comp hg) hf
#align uniform_space.completion.map_comp UniformSpace.Completion.map_comp

end Map

/- In this section we construct isomorphisms between the completion of a uniform space and the
completion of its separation quotient -/
section SeparationQuotientCompletion

open SeparationQuotient in
/-- The isomorphism between the completion of a uniform space and the completion of its separation
quotient. -/
def completionSeparationQuotientEquiv (Œ± : Type u) [UniformSpace Œ±] :
    Completion (SeparationQuotient Œ±) ‚âÉ Completion Œ± := by
  refine ‚ü®Completion.extension (lift' ((‚Üë) : Œ± ‚Üí Completion Œ±)),
    Completion.map SeparationQuotient.mk, fun a ‚Ü¶ ?_, fun a ‚Ü¶ ?_‚ü©
  ¬∑ refine induction_on a (isClosed_eq (continuous_map.comp continuous_extension) continuous_id) ?_
    refine SeparationQuotient.surjective_mk.forall.2 fun a ‚Ü¶ ?_
    rw [extension_coe (uniformContinuous_lift' _), lift'_mk (uniformContinuous_coe Œ±),
      map_coe uniformContinuous_mk]
  ¬∑ refine induction_on a
      (isClosed_eq (continuous_extension.comp continuous_map) continuous_id) fun a ‚Ü¶ ?_
    rw [map_coe uniformContinuous_mk, extension_coe (uniformContinuous_lift' _),
      lift'_mk (uniformContinuous_coe _)]
#align uniform_space.completion.completion_separation_quotient_equiv UniformSpace.Completion.completionSeparationQuotientEquiv

theorem uniformContinuous_completionSeparationQuotientEquiv :
    UniformContinuous (completionSeparationQuotientEquiv Œ±) :=
  uniformContinuous_extension
#align uniform_space.completion.uniform_continuous_completion_separation_quotient_equiv UniformSpace.Completion.uniformContinuous_completionSeparationQuotientEquiv

theorem uniformContinuous_completionSeparationQuotientEquiv_symm :
    UniformContinuous (completionSeparationQuotientEquiv Œ±).symm :=
  uniformContinuous_map
#align uniform_space.completion.uniform_continuous_completion_separation_quotient_equiv_symm UniformSpace.Completion.uniformContinuous_completionSeparationQuotientEquiv_symm

end SeparationQuotientCompletion

section Extension‚ÇÇ

variable (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥)

open Function

/-- Extend a two variable map to the Hausdorff completions. -/
protected def extension‚ÇÇ (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : Completion Œ± ‚Üí Completion Œ≤ ‚Üí Œ≥ :=
  cPkg.extend‚ÇÇ cPkg f
#align uniform_space.completion.extension‚ÇÇ UniformSpace.Completion.extension‚ÇÇ

section T0Space

variable [T0Space Œ≥] {f}

/- porting note: removed `@[simp]` because this lemma doesn't even trigger on itself in Lean 3 or
Lean 4 unless the user manually supplies the `hf` argument, so it is useless as a `simp` lemma. -/
theorem extension‚ÇÇ_coe_coe (hf : UniformContinuous‚ÇÇ f) (a : Œ±) (b : Œ≤) :
    Completion.extension‚ÇÇ f a b = f a b :=
  cPkg.extension‚ÇÇ_coe_coe cPkg hf a b
#align uniform_space.completion.extension‚ÇÇ_coe_coe UniformSpace.Completion.extension‚ÇÇ_coe_coe

end T0Space

variable [CompleteSpace Œ≥]

theorem uniformContinuous_extension‚ÇÇ : UniformContinuous‚ÇÇ (Completion.extension‚ÇÇ f) :=
  cPkg.uniformContinuous_extension‚ÇÇ cPkg f
#align uniform_space.completion.uniform_continuous_extension‚ÇÇ UniformSpace.Completion.uniformContinuous_extension‚ÇÇ

end Extension‚ÇÇ

section Map‚ÇÇ

open Function

/-- Lift a two variable map to the Hausdorff completions. -/
protected def map‚ÇÇ (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : Completion Œ± ‚Üí Completion Œ≤ ‚Üí Completion Œ≥ :=
  cPkg.map‚ÇÇ cPkg cPkg f
#align uniform_space.completion.map‚ÇÇ UniformSpace.Completion.map‚ÇÇ

theorem uniformContinuous_map‚ÇÇ (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : UniformContinuous‚ÇÇ (Completion.map‚ÇÇ f) :=
  cPkg.uniformContinuous_map‚ÇÇ cPkg cPkg f
#align uniform_space.completion.uniform_continuous_map‚ÇÇ UniformSpace.Completion.uniformContinuous_map‚ÇÇ

theorem continuous_map‚ÇÇ {Œ¥} [TopologicalSpace Œ¥] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {a : Œ¥ ‚Üí Completion Œ±}
    {b : Œ¥ ‚Üí Completion Œ≤} (ha : Continuous a) (hb : Continuous b) :
    Continuous fun d : Œ¥ => Completion.map‚ÇÇ f (a d) (b d) :=
  cPkg.continuous_map‚ÇÇ cPkg cPkg ha hb
#align uniform_space.completion.continuous_map‚ÇÇ UniformSpace.Completion.continuous_map‚ÇÇ

theorem map‚ÇÇ_coe_coe (a : Œ±) (b : Œ≤) (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (hf : UniformContinuous‚ÇÇ f) :
    Completion.map‚ÇÇ f (a : Completion Œ±) (b : Completion Œ≤) = f a b :=
  cPkg.map‚ÇÇ_coe_coe cPkg cPkg a b f hf
#align uniform_space.completion.map‚ÇÇ_coe_coe UniformSpace.Completion.map‚ÇÇ_coe_coe

end Map‚ÇÇ

end Completion

end UniformSpace
