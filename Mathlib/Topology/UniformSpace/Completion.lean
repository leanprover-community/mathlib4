/-
Copyright (c) 2018 Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Patrick Massot, Johannes H√∂lzl
-/
import Mathlib.Topology.UniformSpace.AbstractCompletion

/-!
# Hausdorff completions of uniform spaces

The goal is to construct a left-adjoint to the inclusion of complete Hausdorff uniform spaces
into all uniform spaces. Any uniform space `Œ±` gets a completion `Completion Œ±` and a morphism
(i.e. uniformly continuous map) `(‚Üë) : Œ± ‚Üí Completion Œ±` which solves the universal
mapping problem of factorizing morphisms from `Œ±` to any complete Hausdorff uniform space `Œ≤`.
It means any uniformly continuous `f : Œ± ‚Üí Œ≤` gives rise to a unique morphism
`Completion.extension f : Completion Œ± ‚Üí Œ≤` such that `f = Completion.extension f ‚àò (‚Üë)`.
Actually `Completion.extension f` is defined for all maps from `Œ±` to `Œ≤` but it has the desired
properties only if `f` is uniformly continuous.

Beware that `(‚Üë)` is not injective if `Œ±` is not Hausdorff. But its image is always
dense. The adjoint functor acting on morphisms is then constructed by the usual abstract nonsense.
For every uniform spaces `Œ±` and `Œ≤`, it turns `f : Œ± ‚Üí Œ≤` into a morphism
  `Completion.map f : Completion Œ± ‚Üí Completion Œ≤`
such that
  `(‚Üë) ‚àò f = (Completion.map f) ‚àò (‚Üë)`
provided `f` is uniformly continuous. This construction is compatible with composition.

In this file we introduce the following concepts:

* `CauchyFilter Œ±` the uniform completion of the uniform space `Œ±` (using Cauchy filters).
  These are not minimal filters.

* `Completion Œ± := Quotient (separationSetoid (CauchyFilter Œ±))` the Hausdorff completion.

## References

This formalization is mostly based on
  N. Bourbaki: General Topology
  I. M. James: Topologies and Uniformities
From a slightly different perspective in order to reuse material in `Topology.UniformSpace.Basic`.
-/

noncomputable section

open Filter Set
open scoped SetRel Uniformity Topology

universe u v w

/-- Space of Cauchy filters

This is essentially the completion of a uniform space. The embeddings are the neighbourhood filters.
This space is not minimal, the separated uniform space (i.e. quotiented on the intersection of all
entourages) is necessary for this.
-/
def CauchyFilter (Œ± : Type u) [UniformSpace Œ±] : Type u :=
  { f : Filter Œ± // Cauchy f }

namespace CauchyFilter

section

variable {Œ± : Type u} [UniformSpace Œ±]
variable {Œ≤ : Type v} {Œ≥ : Type w}
variable [UniformSpace Œ≤] [UniformSpace Œ≥]

instance (f : CauchyFilter Œ±) : NeBot f.1 := f.2.1

/-- The pairs of Cauchy filters generated by a set. -/
def gen (s : SetRel Œ± Œ±) : SetRel (CauchyFilter Œ±) (CauchyFilter Œ±) :=
  { p | s ‚àà p.1.val √óÀ¢ p.2.val }

theorem monotone_gen : Monotone (gen : SetRel Œ± Œ± ‚Üí _) :=
  monotone_setOf fun p => @Filter.monotone_mem _ (p.1.val √óÀ¢ p.2.val)

-- Porting note: this was a calc proof, but I could not make it work
private theorem symm_gen : map Prod.swap ((ùì§ Œ±).lift' gen) ‚â§ (ùì§ Œ±).lift' gen := by
  let f := fun s : SetRel Œ± Œ± =>
        { p : CauchyFilter Œ± √ó CauchyFilter Œ± | s ‚àà (p.2.val √óÀ¢ p.1.val : Filter (Œ± √ó Œ±)) }
  have h‚ÇÅ : map Prod.swap ((ùì§ Œ±).lift' gen) = (ùì§ Œ±).lift' f := by
    delta gen
    simp [f, map_lift'_eq, monotone_setOf, Filter.monotone_mem, Function.comp_def,
      image_swap_eq_preimage_swap]
  have h‚ÇÇ : (ùì§ Œ±).lift' f ‚â§ (ùì§ Œ±).lift' gen :=
    uniformity_lift_le_swap
      (monotone_principal.comp
        (monotone_setOf fun p => @Filter.monotone_mem _ (p.2.val √óÀ¢ p.1.val)))
      (by
        have h := fun p : CauchyFilter Œ± √ó CauchyFilter Œ± => @Filter.prod_comm _ _ p.2.val p.1.val
        simp only [Function.comp, h, mem_map, f]
        exact le_rfl)
  exact h‚ÇÅ.trans_le h‚ÇÇ

private theorem subset_gen_relComp {s t : SetRel Œ± Œ±} : gen s ‚óã gen t ‚äÜ gen (s ‚óã t) :=
  fun ‚ü®f, g‚ü© ‚ü®h, h‚ÇÅ, h‚ÇÇ‚ü© =>
  let ‚ü®t‚ÇÅ, (ht‚ÇÅ : t‚ÇÅ ‚àà f.val), t‚ÇÇ, (ht‚ÇÇ : t‚ÇÇ ‚àà h.val), (h‚ÇÅ : t‚ÇÅ √óÀ¢ t‚ÇÇ ‚äÜ s)‚ü© := mem_prod_iff.mp h‚ÇÅ
  let ‚ü®t‚ÇÉ, (ht‚ÇÉ : t‚ÇÉ ‚àà h.val), t‚ÇÑ, (ht‚ÇÑ : t‚ÇÑ ‚àà g.val), (h‚ÇÇ : t‚ÇÉ √óÀ¢ t‚ÇÑ ‚äÜ t)‚ü© := mem_prod_iff.mp h‚ÇÇ
  have : t‚ÇÇ ‚à© t‚ÇÉ ‚àà h.val := inter_mem ht‚ÇÇ ht‚ÇÉ
  let ‚ü®x, xt‚ÇÇ, xt‚ÇÉ‚ü© := h.property.left.nonempty_of_mem this
  (f.val √óÀ¢ g.val).sets_of_superset (prod_mem_prod ht‚ÇÅ ht‚ÇÑ)
    fun ‚ü®a, b‚ü© ‚ü®(ha : a ‚àà t‚ÇÅ), (hb : b ‚àà t‚ÇÑ)‚ü© =>
    ‚ü®x, h‚ÇÅ (show (a, x) ‚àà t‚ÇÅ √óÀ¢ t‚ÇÇ from ‚ü®ha, xt‚ÇÇ‚ü©), h‚ÇÇ (show (x, b) ‚àà t‚ÇÉ √óÀ¢ t‚ÇÑ from ‚ü®xt‚ÇÉ, hb‚ü©)‚ü©

private theorem comp_gen : ((ùì§ Œ±).lift' gen).lift' (fun s ‚Ü¶ s ‚óã s) ‚â§ (ùì§ Œ±).lift' gen :=
  calc
        ((ùì§ Œ±).lift' gen).lift' (fun s ‚Ü¶ s ‚óã s)
    _ = (ùì§ Œ±).lift' fun s ‚Ü¶ gen s ‚óã gen s := by
      rw [lift'_lift'_assoc]
      ¬∑ exact monotone_gen
      ¬∑ exact monotone_id.relComp monotone_id
    _ ‚â§ (ùì§ Œ±).lift' fun s ‚Ü¶ gen <| s ‚óã s := lift'_mono' fun _ _hs => subset_gen_relComp
    _ = ((ùì§ Œ±).lift' fun s : SetRel Œ± Œ± => s ‚óã s).lift' gen := by
      rw [lift'_lift'_assoc]
      ¬∑ exact monotone_id.relComp monotone_id
      ¬∑ exact monotone_gen
    _ ‚â§ (ùì§ Œ±).lift' gen := lift'_mono comp_le_uniformity le_rfl

instance : UniformSpace (CauchyFilter Œ±) :=
  UniformSpace.ofCore
    { uniformity := (ùì§ Œ±).lift' gen
      refl := principal_le_lift'.2 fun _s hs ‚ü®a, b‚ü© =>
        fun (a_eq_b : a = b) => a_eq_b ‚ñ∏ a.property.right hs
      symm := symm_gen
      comp := comp_gen }

theorem mem_uniformity {s : Set (CauchyFilter Œ± √ó CauchyFilter Œ±)} :
    s ‚àà ùì§ (CauchyFilter Œ±) ‚Üî ‚àÉ t ‚àà ùì§ Œ±, gen t ‚äÜ s :=
  mem_lift'_sets monotone_gen

theorem basis_uniformity {Œπ : Sort*} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí SetRel Œ± Œ±} (h : (ùì§ Œ±).HasBasis p s) :
    (ùì§ (CauchyFilter Œ±)).HasBasis p (gen ‚àò s) :=
  h.lift' monotone_gen

theorem mem_uniformity' {s : Set (CauchyFilter Œ± √ó CauchyFilter Œ±)} :
    s ‚àà ùì§ (CauchyFilter Œ±) ‚Üî ‚àÉ t ‚àà ùì§ Œ±, ‚àÄ f g : CauchyFilter Œ±, t ‚àà f.1 √óÀ¢ g.1 ‚Üí (f, g) ‚àà s := by
  refine mem_uniformity.trans (exists_congr (fun t => and_congr_right_iff.mpr (fun _h => ?_)))
  exact ‚ü®fun h _f _g ht => h ht, fun h _p hp => h _ _ hp‚ü©

/-- Embedding of `Œ±` into its completion `CauchyFilter Œ±` -/
def pureCauchy (a : Œ±) : CauchyFilter Œ± :=
  ‚ü®pure a, cauchy_pure‚ü©

theorem isUniformInducing_pureCauchy : IsUniformInducing (pureCauchy : Œ± ‚Üí CauchyFilter Œ±) :=
  ‚ü®have : (preimage fun x : Œ± √ó Œ± => (pureCauchy x.fst, pureCauchy x.snd)) ‚àò gen = id :=
      funext fun s =>
        Set.ext fun ‚ü®a‚ÇÅ, a‚ÇÇ‚ü© => by simp [preimage, gen, pureCauchy]
    calc
      comap (fun x : Œ± √ó Œ± => (pureCauchy x.fst, pureCauchy x.snd)) ((ùì§ Œ±).lift' gen) =
          (ùì§ Œ±).lift' ((preimage fun x : Œ± √ó Œ± => (pureCauchy x.fst, pureCauchy x.snd)) ‚àò gen) :=
        comap_lift'_eq
      _ = ùì§ Œ± := by simp [this]
      ‚ü©

theorem isUniformEmbedding_pureCauchy : IsUniformEmbedding (pureCauchy : Œ± ‚Üí CauchyFilter Œ±) where
  __ := isUniformInducing_pureCauchy
  injective _a‚ÇÅ _a‚ÇÇ h := pure_injective <| Subtype.ext_iff.1 h

theorem denseRange_pureCauchy : DenseRange (pureCauchy : Œ± ‚Üí CauchyFilter Œ±) := fun f => by
  have h_ex : ‚àÄ s ‚àà ùì§ (CauchyFilter Œ±), ‚àÉ y : Œ±, (f, pureCauchy y) ‚àà s := fun s hs =>
    let ‚ü®t'', ht''‚ÇÅ, (ht''‚ÇÇ : gen t'' ‚äÜ s)‚ü© := (mem_lift'_sets monotone_gen).mp hs
    let ‚ü®t', ht'‚ÇÅ, ht'‚ÇÇ‚ü© := comp_mem_uniformity_sets ht''‚ÇÅ
    have : t' ‚àà f.val √óÀ¢ f.val := f.property.right ht'‚ÇÅ
    let ‚ü®t, ht, (h : t √óÀ¢ t ‚äÜ t')‚ü© := mem_prod_same_iff.mp this
    let ‚ü®x, (hx : x ‚àà t)‚ü© := f.property.left.nonempty_of_mem ht
    have : t'' ‚àà f.val √óÀ¢ pure x :=
      mem_prod_iff.mpr
        ‚ü®t, ht, { y : Œ± | (x, y) ‚àà t' }, h <| mk_mem_prod hx hx,
          fun ‚ü®a, b‚ü© ‚ü®(h‚ÇÅ : a ‚àà t), (h‚ÇÇ : (x, b) ‚àà t')‚ü© =>
          ht'‚ÇÇ <| SetRel.prodMk_mem_comp (@h (a, x) ‚ü®h‚ÇÅ, hx‚ü©) h‚ÇÇ‚ü©
    ‚ü®x, ht''‚ÇÇ <| by dsimp [gen]; exact this‚ü©
  simp only [closure_eq_cluster_pts, ClusterPt, nhds_eq_uniformity, lift'_inf_principal_eq,
    Set.inter_comm _ (range pureCauchy), mem_setOf_eq]
  refine (lift'_neBot_iff ?_).mpr (fun s hs => ?_)
  ¬∑ exact monotone_const.inter monotone_preimage
  ¬∑ let ‚ü®y, hy‚ü© := h_ex s hs
    have : pureCauchy y ‚àà range pureCauchy ‚à© { y : CauchyFilter Œ± | (f, y) ‚àà s } :=
      ‚ü®mem_range_self y, hy‚ü©
    exact ‚ü®_, this‚ü©

theorem isDenseInducing_pureCauchy : IsDenseInducing (pureCauchy : Œ± ‚Üí CauchyFilter Œ±) :=
  isUniformInducing_pureCauchy.isDenseInducing denseRange_pureCauchy

theorem isDenseEmbedding_pureCauchy : IsDenseEmbedding (pureCauchy : Œ± ‚Üí CauchyFilter Œ±) :=
  isUniformEmbedding_pureCauchy.isDenseEmbedding denseRange_pureCauchy

theorem nonempty_cauchyFilter_iff : Nonempty (CauchyFilter Œ±) ‚Üî Nonempty Œ± := by
  constructor <;> rintro ‚ü®c‚ü©
  ¬∑ have := eq_univ_iff_forall.1 isDenseEmbedding_pureCauchy.isDenseInducing.closure_range c
    obtain ‚ü®_, ‚ü®_, a, _‚ü©‚ü© := mem_closure_iff.1 this _ isOpen_univ trivial
    exact ‚ü®a‚ü©
  ¬∑ exact ‚ü®pureCauchy c‚ü©

section

instance : CompleteSpace (CauchyFilter Œ±) :=
  completeSpace_extension isUniformInducing_pureCauchy denseRange_pureCauchy fun f hf =>
    let f' : CauchyFilter Œ± := ‚ü®f, hf‚ü©
    have : map pureCauchy f ‚â§ (ùì§ <| CauchyFilter Œ±).lift' (preimage (Prod.mk f')) :=
      le_lift'.2 fun _ hs =>
        let ‚ü®t, ht‚ÇÅ, ht‚ÇÇ‚ü© := (mem_lift'_sets monotone_gen).mp hs
        let ‚ü®t', ht', (h : t' √óÀ¢ t' ‚äÜ t)‚ü© := mem_prod_same_iff.mp (hf.right ht‚ÇÅ)
        have : t' ‚äÜ { y : Œ± | (f', pureCauchy y) ‚àà gen t } := fun x hx =>
          (f √óÀ¢ pure x).sets_of_superset (prod_mem_prod ht' hx) h
        f.sets_of_superset ht' <| Subset.trans this (preimage_mono ht‚ÇÇ)
    ‚ü®f', by simpa [nhds_eq_uniformity]‚ü©

end

instance [Inhabited Œ±] : Inhabited (CauchyFilter Œ±) :=
  ‚ü®pureCauchy default‚ü©

instance [h : Nonempty Œ±] : Nonempty (CauchyFilter Œ±) :=
  h.recOn fun a => Nonempty.intro <| CauchyFilter.pureCauchy a

section Extend

open Classical in
/-- Extend a uniformly continuous function `Œ± ‚Üí Œ≤` to a function `CauchyFilter Œ± ‚Üí Œ≤`.
Outputs junk when `f` is not uniformly continuous. -/
def extend (f : Œ± ‚Üí Œ≤) : CauchyFilter Œ± ‚Üí Œ≤ :=
  if UniformContinuous f then isDenseInducing_pureCauchy.extend f
  else fun x => f (nonempty_cauchyFilter_iff.1 ‚ü®x‚ü©).some

section T0Space

variable [T0Space Œ≤]

theorem extend_pureCauchy {f : Œ± ‚Üí Œ≤} (hf : UniformContinuous f) (a : Œ±) :
    extend f (pureCauchy a) = f a := by
  rw [extend, if_pos hf]
  exact uniformly_extend_of_ind isUniformInducing_pureCauchy denseRange_pureCauchy hf _

end T0Space

variable [CompleteSpace Œ≤]

theorem uniformContinuous_extend {f : Œ± ‚Üí Œ≤} : UniformContinuous (extend f) := by
  by_cases hf : UniformContinuous f
  ¬∑ rw [extend, if_pos hf]
    exact uniformContinuous_uniformly_extend isUniformInducing_pureCauchy denseRange_pureCauchy hf
  ¬∑ rw [extend, if_neg hf]
    exact uniformContinuous_of_const fun a _b => by congr

end Extend

theorem inseparable_iff {f g : CauchyFilter Œ±} : Inseparable f g ‚Üî f.1 √óÀ¢ g.1 ‚â§ ùì§ Œ± :=
  (basis_uniformity (basis_sets _)).inseparable_iff_uniformity

theorem inseparable_iff_of_le_nhds {f g : CauchyFilter Œ±} {a b : Œ±}
    (ha : f.1 ‚â§ ùìù a) (hb : g.1 ‚â§ ùìù b) : Inseparable a b ‚Üî Inseparable f g := by
  rw [‚Üê tendsto_id'] at ha hb
  rw [inseparable_iff, (ha.comp tendsto_fst).inseparable_iff_uniformity (hb.comp tendsto_snd)]
  simp only [Function.comp_apply, id_eq, Prod.mk.eta, ‚Üê Function.id_def, tendsto_id']

theorem inseparable_lim_iff [CompleteSpace Œ±] {f g : CauchyFilter Œ±} :
    haveI := f.2.1.nonempty; Inseparable (lim f.1) (lim g.1) ‚Üî Inseparable f g :=
  inseparable_iff_of_le_nhds f.2.le_nhds_lim g.2.le_nhds_lim

end

theorem cauchyFilter_eq {Œ± : Type*} [UniformSpace Œ±] [CompleteSpace Œ±] [T0Space Œ±]
    {f g : CauchyFilter Œ±} :
    haveI := f.2.1.nonempty; lim f.1 = lim g.1 ‚Üî Inseparable f g := by
  rw [‚Üê inseparable_iff_eq, inseparable_lim_iff]

section

theorem separated_pureCauchy_injective {Œ± : Type*} [UniformSpace Œ±] [T0Space Œ±] :
    Function.Injective fun a : Œ± => SeparationQuotient.mk (pureCauchy a) := fun a b h ‚Ü¶
  Inseparable.eq <| (inseparable_iff_of_le_nhds (pure_le_nhds a) (pure_le_nhds b)).2 <|
    SeparationQuotient.mk_eq_mk.1 h

end

end CauchyFilter

open CauchyFilter Set

namespace UniformSpace

variable (Œ± : Type*) [UniformSpace Œ±]
variable {Œ≤ : Type*} [UniformSpace Œ≤]
variable {Œ≥ : Type*} [UniformSpace Œ≥]

/-- Hausdorff completion of `Œ±` -/
def Completion := SeparationQuotient (CauchyFilter Œ±)

namespace Completion

instance inhabited [Inhabited Œ±] : Inhabited (Completion Œ±) :=
  inferInstanceAs <| Inhabited (Quotient _)

instance uniformSpace : UniformSpace (Completion Œ±) :=
  SeparationQuotient.instUniformSpace

instance completeSpace : CompleteSpace (Completion Œ±) :=
  SeparationQuotient.instCompleteSpace

instance t0Space : T0Space (Completion Œ±) := SeparationQuotient.instT0Space

variable {Œ±} in
/-- The map from a uniform space to its completion. -/
@[coe] def coe' : Œ± ‚Üí Completion Œ± := SeparationQuotient.mk ‚àò pureCauchy

/-- Automatic coercion from `Œ±` to its completion. Not always injective. -/
instance : Coe Œ± (Completion Œ±) :=
  ‚ü®coe'‚ü©

-- note [use has_coe_t]
protected theorem coe_eq : ((‚Üë) : Œ± ‚Üí Completion Œ±) = SeparationQuotient.mk ‚àò pureCauchy := rfl

theorem isUniformInducing_coe : IsUniformInducing ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  SeparationQuotient.isUniformInducing_mk.comp isUniformInducing_pureCauchy

theorem comap_coe_eq_uniformity :
    ((ùì§ _).comap fun p : Œ± √ó Œ± => ((p.1 : Completion Œ±), (p.2 : Completion Œ±))) = ùì§ Œ± :=
  (isUniformInducing_coe _).1

variable {Œ±} in
theorem denseRange_coe : DenseRange ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  SeparationQuotient.surjective_mk.denseRange.comp denseRange_pureCauchy
    SeparationQuotient.continuous_mk

/-- The Hausdorff completion as an abstract completion. -/
def cPkg {Œ± : Type*} [UniformSpace Œ±] : AbstractCompletion Œ± where
  space := Completion Œ±
  coe := (‚Üë)
  uniformStruct := by infer_instance
  complete := by infer_instance
  separation := by infer_instance
  isUniformInducing := Completion.isUniformInducing_coe Œ±
  dense := Completion.denseRange_coe

instance AbstractCompletion.inhabited : Inhabited (AbstractCompletion Œ±) :=
  ‚ü®cPkg‚ü©

attribute [local instance]
  AbstractCompletion.uniformStruct AbstractCompletion.complete AbstractCompletion.separation

theorem nonempty_completion_iff : Nonempty (Completion Œ±) ‚Üî Nonempty Œ± :=
  cPkg.dense.nonempty_iff.symm

theorem uniformContinuous_coe : UniformContinuous ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  cPkg.uniformContinuous_coe

theorem continuous_coe : Continuous ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  cPkg.continuous_coe

theorem isUniformEmbedding_coe [T0Space Œ±] : IsUniformEmbedding ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  { comap_uniformity := comap_coe_eq_uniformity Œ±
    injective := separated_pureCauchy_injective }

theorem coe_injective [T0Space Œ±] : Function.Injective ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  IsUniformEmbedding.injective (isUniformEmbedding_coe _)

variable {Œ±}

@[simp]
lemma coe_inj [T0Space Œ±] {a b : Œ±} : (a : Completion Œ±) = b ‚Üî a = b :=
  (coe_injective _).eq_iff

theorem isDenseInducing_coe : IsDenseInducing ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  { (isUniformInducing_coe Œ±).isInducing with dense := denseRange_coe }

/-- The uniform bijection between a complete space and its uniform completion. -/
def UniformCompletion.completeEquivSelf [CompleteSpace Œ±] [T0Space Œ±] : Completion Œ± ‚âÉ·µ§ Œ± :=
  AbstractCompletion.compareEquiv Completion.cPkg AbstractCompletion.ofComplete

open TopologicalSpace

instance separableSpace_completion [SeparableSpace Œ±] : SeparableSpace (Completion Œ±) :=
  Completion.isDenseInducing_coe.separableSpace

theorem isDenseEmbedding_coe [T0Space Œ±] : IsDenseEmbedding ((‚Üë) : Œ± ‚Üí Completion Œ±) :=
  { isDenseInducing_coe with injective := separated_pureCauchy_injective }

theorem denseRange_coe‚ÇÇ :
    DenseRange fun x : Œ± √ó Œ≤ => ((x.1 : Completion Œ±), (x.2 : Completion Œ≤)) :=
  denseRange_coe.prodMap denseRange_coe

theorem denseRange_coe‚ÇÉ :
    DenseRange fun x : Œ± √ó Œ≤ √ó Œ≥ =>
      ((x.1 : Completion Œ±), ((x.2.1 : Completion Œ≤), (x.2.2 : Completion Œ≥))) :=
  denseRange_coe.prodMap denseRange_coe‚ÇÇ

@[elab_as_elim]
theorem induction_on {p : Completion Œ± ‚Üí Prop} (a : Completion Œ±) (hp : IsClosed { a | p a })
    (ih : ‚àÄ a : Œ±, p a) : p a :=
  isClosed_property denseRange_coe hp ih a

@[elab_as_elim]
theorem induction_on‚ÇÇ {p : Completion Œ± ‚Üí Completion Œ≤ ‚Üí Prop} (a : Completion Œ±) (b : Completion Œ≤)
    (hp : IsClosed { x : Completion Œ± √ó Completion Œ≤ | p x.1 x.2 })
    (ih : ‚àÄ (a : Œ±) (b : Œ≤), p a b) : p a b :=
  have : ‚àÄ x : Completion Œ± √ó Completion Œ≤, p x.1 x.2 :=
    isClosed_property denseRange_coe‚ÇÇ hp fun ‚ü®a, b‚ü© => ih a b
  this (a, b)

@[elab_as_elim]
theorem induction_on‚ÇÉ {p : Completion Œ± ‚Üí Completion Œ≤ ‚Üí Completion Œ≥ ‚Üí Prop} (a : Completion Œ±)
    (b : Completion Œ≤) (c : Completion Œ≥)
    (hp : IsClosed { x : Completion Œ± √ó Completion Œ≤ √ó Completion Œ≥ | p x.1 x.2.1 x.2.2 })
    (ih : ‚àÄ (a : Œ±) (b : Œ≤) (c : Œ≥), p a b c) : p a b c :=
  have : ‚àÄ x : Completion Œ± √ó Completion Œ≤ √ó Completion Œ≥, p x.1 x.2.1 x.2.2 :=
    isClosed_property denseRange_coe‚ÇÉ hp fun ‚ü®a, b, c‚ü© => ih a b c
  this (a, b, c)

theorem ext {Y : Type*} [TopologicalSpace Y] [T2Space Y] {f g : Completion Œ± ‚Üí Y}
    (hf : Continuous f) (hg : Continuous g) (h : ‚àÄ a : Œ±, f a = g a) : f = g :=
  cPkg.funext hf hg h

theorem ext' {Y : Type*} [TopologicalSpace Y] [T2Space Y] {f g : Completion Œ± ‚Üí Y}
    (hf : Continuous f) (hg : Continuous g) (h : ‚àÄ a : Œ±, f a = g a) (a : Completion Œ±) :
    f a = g a :=
  congr_fun (ext hf hg h) a

section Extension

variable {f : Œ± ‚Üí Œ≤}

/-- "Extension" to the completion. It is defined for any map `f` but
returns an arbitrary constant value if `f` is not uniformly continuous -/
protected def extension (f : Œ± ‚Üí Œ≤) : Completion Œ± ‚Üí Œ≤ :=
  cPkg.extend f

section CompleteSpace

variable [CompleteSpace Œ≤]

theorem uniformContinuous_extension : UniformContinuous (Completion.extension f) :=
  cPkg.uniformContinuous_extend

@[continuity, fun_prop]
theorem continuous_extension : Continuous (Completion.extension f) :=
  cPkg.continuous_extend

end CompleteSpace

theorem extension_coe [T0Space Œ≤] (hf : UniformContinuous f) (a : Œ±) :
    (Completion.extension f) a = f a :=
  cPkg.extend_coe hf a

theorem inseparable_extension_coe (hf : UniformContinuous f) (x : Œ±) :
    Inseparable (Completion.extension f x) (f x) :=
  cPkg.inseparable_extend_coe hf x

lemma isUniformInducing_extension [CompleteSpace Œ≤] (h : IsUniformInducing f) :
    IsUniformInducing (Completion.extension f) :=
  cPkg.isUniformInducing_extend h

variable [T0Space Œ≤] [CompleteSpace Œ≤]

theorem extension_unique (hf : UniformContinuous f) {g : Completion Œ± ‚Üí Œ≤}
    (hg : UniformContinuous g) (h : ‚àÄ a : Œ±, f a = g (a : Completion Œ±)) :
    Completion.extension f = g :=
  cPkg.extend_unique hf hg h

@[simp]
theorem extension_comp_coe {f : Completion Œ± ‚Üí Œ≤} (hf : UniformContinuous f) :
    Completion.extension (f ‚àò (‚Üë)) = f :=
  cPkg.extend_comp_coe hf

end Extension

section Map

variable {f : Œ± ‚Üí Œ≤}

/-- Completion functor acting on morphisms -/
protected def map (f : Œ± ‚Üí Œ≤) : Completion Œ± ‚Üí Completion Œ≤ :=
  cPkg.map cPkg f

theorem uniformContinuous_map : UniformContinuous (Completion.map f) :=
  cPkg.uniformContinuous_map cPkg f

@[continuity]
theorem continuous_map : Continuous (Completion.map f) :=
  cPkg.continuous_map cPkg f

theorem map_coe (hf : UniformContinuous f) (a : Œ±) : (Completion.map f) a = f a :=
  cPkg.map_coe cPkg hf a

theorem map_unique {f : Œ± ‚Üí Œ≤} {g : Completion Œ± ‚Üí Completion Œ≤} (hg : UniformContinuous g)
    (h : ‚àÄ a : Œ±, ‚Üë(f a) = g a) : Completion.map f = g :=
  cPkg.map_unique cPkg hg h

@[simp]
theorem map_id : Completion.map (@id Œ±) = id :=
  cPkg.map_id

theorem extension_map [CompleteSpace Œ≥] [T0Space Œ≥] {f : Œ≤ ‚Üí Œ≥} {g : Œ± ‚Üí Œ≤}
    (hf : UniformContinuous f) (hg : UniformContinuous g) :
    Completion.extension f ‚àò Completion.map g = Completion.extension (f ‚àò g) :=
  Completion.ext (continuous_extension.comp continuous_map) continuous_extension <| by
    simp [hf, hg, hf.comp hg, map_coe, extension_coe]

theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} (hg : UniformContinuous g) (hf : UniformContinuous f) :
    Completion.map g ‚àò Completion.map f = Completion.map (g ‚àò f) :=
  extension_map ((uniformContinuous_coe _).comp hg) hf

end Map

/- In this section we construct isomorphisms between the completion of a uniform space and the
completion of its separation quotient -/
section SeparationQuotientCompletion

open SeparationQuotient in
/-- The isomorphism between the completion of a uniform space and the completion of its separation
quotient. -/
def completionSeparationQuotientEquiv (Œ± : Type u) [UniformSpace Œ±] :
    Completion (SeparationQuotient Œ±) ‚âÉ Completion Œ± := by
  refine ‚ü®Completion.extension (lift' ((‚Üë) : Œ± ‚Üí Completion Œ±)),
    Completion.map SeparationQuotient.mk, fun a ‚Ü¶ ?_, fun a ‚Ü¶ ?_‚ü©
  ¬∑ refine induction_on a (isClosed_eq (continuous_map.comp continuous_extension) continuous_id) ?_
    refine SeparationQuotient.surjective_mk.forall.2 fun a ‚Ü¶ ?_
    rw [extension_coe (uniformContinuous_lift' _), lift'_mk (uniformContinuous_coe Œ±),
      map_coe uniformContinuous_mk]
  ¬∑ refine induction_on a
      (isClosed_eq (continuous_extension.comp continuous_map) continuous_id) fun a ‚Ü¶ ?_
    rw [map_coe uniformContinuous_mk, extension_coe (uniformContinuous_lift' _),
      lift'_mk (uniformContinuous_coe _)]

theorem uniformContinuous_completionSeparationQuotientEquiv :
    UniformContinuous (completionSeparationQuotientEquiv Œ±) :=
  uniformContinuous_extension

theorem uniformContinuous_completionSeparationQuotientEquiv_symm :
    UniformContinuous (completionSeparationQuotientEquiv Œ±).symm :=
  uniformContinuous_map

end SeparationQuotientCompletion

section Extension‚ÇÇ

variable (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥)

open Function

/-- Extend a two variable map to the Hausdorff completions. -/
protected def extension‚ÇÇ (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : Completion Œ± ‚Üí Completion Œ≤ ‚Üí Œ≥ :=
  cPkg.extend‚ÇÇ cPkg f

section T0Space

variable [T0Space Œ≥] {f}

theorem extension‚ÇÇ_coe_coe (hf : UniformContinuous‚ÇÇ f) (a : Œ±) (b : Œ≤) :
    Completion.extension‚ÇÇ f a b = f a b :=
  cPkg.extension‚ÇÇ_coe_coe cPkg hf a b

end T0Space

variable [CompleteSpace Œ≥]

theorem uniformContinuous_extension‚ÇÇ : UniformContinuous‚ÇÇ (Completion.extension‚ÇÇ f) :=
  cPkg.uniformContinuous_extension‚ÇÇ cPkg f

end Extension‚ÇÇ

section Map‚ÇÇ

open Function

/-- Lift a two variable map to the Hausdorff completions. -/
protected def map‚ÇÇ (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : Completion Œ± ‚Üí Completion Œ≤ ‚Üí Completion Œ≥ :=
  cPkg.map‚ÇÇ cPkg cPkg f

theorem uniformContinuous_map‚ÇÇ (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : UniformContinuous‚ÇÇ (Completion.map‚ÇÇ f) :=
  cPkg.uniformContinuous_map‚ÇÇ cPkg cPkg f

theorem continuous_map‚ÇÇ {Œ¥} [TopologicalSpace Œ¥] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {a : Œ¥ ‚Üí Completion Œ±}
    {b : Œ¥ ‚Üí Completion Œ≤} (ha : Continuous a) (hb : Continuous b) :
    Continuous fun d : Œ¥ => Completion.map‚ÇÇ f (a d) (b d) :=
  cPkg.continuous_map‚ÇÇ cPkg cPkg ha hb

theorem map‚ÇÇ_coe_coe (a : Œ±) (b : Œ≤) (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (hf : UniformContinuous‚ÇÇ f) :
    Completion.map‚ÇÇ f (a : Completion Œ±) (b : Completion Œ≤) = f a b :=
  cPkg.map‚ÇÇ_coe_coe cPkg cPkg a b f hf

end Map‚ÇÇ

end Completion

end UniformSpace
