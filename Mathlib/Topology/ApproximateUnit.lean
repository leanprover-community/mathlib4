/-
Copyright (c) 2024 Jireh Loreaux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jireh Loreaux
-/
import Mathlib.Topology.Bornology.Basic
import Mathlib.Topology.Defs.Filter

/-! # Approximate units

An *approximate unit* is a filter basis such that multiplication on the left (or right) by `m`
tends to `m` alqng the filter generated by the basis. In the case of normed rings, it is often
required that the elements of the basis are contained in the unit ball. In order to reduce the
type class burden, we instead only require a bornology on the underlying type, and a bounded
set containing all the elements of the basis.

Examples of approximate units include:

- The trivial approximate unit with filter basis `() â†¦ {1}` in a normed ring.
- In a Câ‹†-algebra, the collection of sections `fun a â†¦ {x | a â‰¤ x} âˆ© ball 0 1` where `a`
  ranges over the positive elements of norm strictly less than 1.
  forms a basis for a filter, and is an approximate unit if the elements are contained in the
  positive cone.

## Main declarations

+ `Filter.mulLeftRightTendsto`: the largest filter `l` such that `Tendsto (Â· * m) l (ğ“ m)`
  and `Tendsto (m * Â·) l (ğ“ m)` for all `m`.
+ `ApproximateUnit`: a filter smaller than `Filter.mulLeftRightTendsto` with a basis all of whose
  elements are contained in a given bounded set.

## Implementation details

Unlike most areas of the library, it is actually not the *filter* itself that is important, but
rather the filter basis. Indeed, the only property relevant to the filter is that it is smaller
than `Filter.mulLeftRightTendsto`. Moreover, in the case of Câ‹†-algebras, one always uses properties
of the filter basis (e.g., that the sets are contained in the intersection of the positive cone
and the unit ball). For this reason, we define `ApproximateUnit` as a structure extending
both `Filter` and `Filter.HasBasis`, and we provide a convenience constructor for `Filter.IsBasis`.

-/

open Filter Topology Bornology

section Def

variable {Î± Î¹ : Type*} [TopologicalSpace Î±] [Mul Î±]

namespace Filter

/-- The largest filter `l` such that `Tendsto (Â· * m) l (ğ“ m)` and `Tendsto (m * Â·) l (ğ“ m)` -/
@[to_additive]
def mulLeftRightTendsto : Filter Î± :=
  sSup { l : Filter Î± | âˆ€ (m : Î±), Tendsto (Â· * m) l (ğ“ m) âˆ§ Tendsto (m * Â·) l (ğ“ m) }

@[to_additive]
lemma mulLeftRightTendsto.tendsto_mul_left (m : Î±) :
    Tendsto (Â· * m) mulLeftRightTendsto (ğ“ m) := by
  simp_rw [mulLeftRightTendsto, tendsto_def, mem_sSup]
  aesop

@[to_additive]
lemma mulLeftRightTendsto.tendsto_mul_right (m : Î±) :
    Tendsto (m * Â·) mulLeftRightTendsto (ğ“ m) := by
  simp_rw [mulLeftRightTendsto, tendsto_def, mem_sSup]
  aesop

@[to_additive]
lemma mulLeftRightTendsto.le_iff {l : Filter Î±} :
    l â‰¤ mulLeftRightTendsto â†” âˆ€ m, Tendsto (Â· * m) l (ğ“ m) âˆ§ Tendsto (m * Â·) l (ğ“ m) :=
  âŸ¨fun h m â†¦ âŸ¨(tendsto_mul_left m).mono_left h, (tendsto_mul_right m).mono_left hâŸ©,
    fun h â†¦ le_sSup hâŸ©

end Filter

variable [Bornology Î±]

/-- An *approximate unit* is a filter smaller than `mulLeftRightTendsto` along with a basis
consisting of sets contained in a given bounded set. The former condition is equivalent to the
condition that for all `m`, multiplication on the left (or right) tends to `m` along the filter.

Note: this extends `Filter` and `Filter.HasBasis` rather than taking  -/
structure ApproximateUnit (p : Î¹ â†’ Prop) (s : Î¹ â†’ Set Î±)
    extends Filter Î±, toFilter.HasBasis p s where
  /-- The filter generated by the basis is smaller than `Filter.mulLeftRightTendsto`. -/
  filter_le : toFilter â‰¤ mulLeftRightTendsto
  /-- All elements of the basis are bounded. -/
  bounded : âˆƒ t, IsBounded t âˆ§ âˆ€ i, p i â†’ s i âŠ† t

/-- Create an approximate unit from a filter basis satisfying the necessary properties. -/
@[simps toFilter toHasBasis]
def Filter.IsBasis.approximateUnit {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} (b : IsBasis p s)
    (h_le : b.filter â‰¤ mulLeftRightTendsto)
    (h_bdd : âˆƒ t, Bornology.IsBounded t âˆ§ âˆ€ i, p i â†’ s i âŠ† t) :
    ApproximateUnit p s where
  toFilter := b.filter
  toHasBasis := b.hasBasis
  filter_le := h_le
  bounded := h_bdd

namespace ApproximateUnit

variable {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±}

lemma tendsto_mul_left (au : ApproximateUnit p s) (m : Î±) :
    Tendsto (Â· * m) au.toFilter (ğ“ m) :=
  mulLeftRightTendsto.le_iff.mp au.filter_le m |>.1

lemma tendsto_mul_right (au : ApproximateUnit p s) (m : Î±) :
    Tendsto (m * Â·) au.toFilter (ğ“ m) :=
  mulLeftRightTendsto.le_iff.mp au.filter_le m |>.2

end ApproximateUnit

end Def

/-- A unital magma with a topology and bornology has the trivial approximate unit `ğ“Ÿ {1}` with
basis `{1}`. -/
@[simps toFilter toHasBasis]
def ApproximateUnit.ofUnit (Î± : Type*) [TopologicalSpace Î±] [MulOneClass Î±] [Bornology Î±] :
    ApproximateUnit (fun _ => True) (fun _ : Unit => {(1 : Î±)}) where
  toFilter := ğ“Ÿ {1}
  toHasBasis := Filter.hasBasis_principal {1}
  filter_le := by
    rw [Filter.mulLeftRightTendsto.le_iff]
    simpa [- pure_one, tendsto_pure_left]
      using fun _ _ â†¦ mem_of_mem_nhds
  bounded := âŸ¨{1}, by simpâŸ©

section DirectedOn

/-- If `s : Set Î±` is a nonempty directed set, then the collection of sections `{x | Â· â‰¤ x} âˆ© s`
contained in `s` forms a basis for a filter on `Î±`. -/
lemma DirectedOn.filterIsBasis {Î± : Type*} [Preorder Î±] {s : Set Î±}
    (h : DirectedOn (Â· â‰¤ Â·) s) (hs : s.Nonempty) :
    Filter.IsBasis (Â· âˆˆ s) ({x | Â· â‰¤ x} âˆ© s) where
  nonempty := hs
  inter {x y} hx hy := by
    obtain âŸ¨z, hz, hxz, hyzâŸ© := h x hx y hy
    refine âŸ¨z, hz, fun w hw â†¦ ?_âŸ©
    have : x â‰¤ w âˆ§ y â‰¤ w := âŸ¨hxz.trans hw.1, hyz.trans hw.1âŸ©
    aesop

end DirectedOn
