/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro, Yury Kudryashov
-/
import Mathlib.Order.Filter.Interval
import Mathlib.Order.Interval.Set.Pi
import Mathlib.Tactic.TFAE
import Mathlib.Tactic.NormNum
import Mathlib.Topology.Order.LeftRight
import Mathlib.Topology.Order.OrderClosed

#align_import topology.order.basic from "leanprover-community/mathlib"@"3efd324a3a31eaa40c9d5bfc669c4fafee5f9423"

/-!
# Theory of topology on ordered spaces

## Main definitions

The order topology on an ordered space is the topology generated by all open intervals (or
equivalently by those of the form `(-‚àû, a)` and `(b, +‚àû)`). We define it as `Preorder.topology Œ±`.
However, we do *not* register it as an instance (as many existing ordered types already have
topologies, which would be equal but not definitionally equal to `Preorder.topology Œ±`). Instead,
we introduce a class `OrderTopology Œ±` (which is a `Prop`, also known as a mixin) saying that on
the type `Œ±` having already a topological space structure and a preorder structure, the topological
structure is equal to the order topology.

We prove many basic properties of such topologies.

## Main statements

This file contains the proofs of the following facts. For exact requirements
(`OrderClosedTopology` vs `OrderTopology`, `Preorder` vs `PartialOrder` vs `LinearOrder` etc)
see their statements.

* `exists_Ioc_subset_of_mem_nhds`, `exists_Ico_subset_of_mem_nhds` : if `x < y`, then any
  neighborhood of `x` includes an interval `[x, z)` for some `z ‚àà (x, y]`, and any neighborhood
  of `y` includes an interval `(z, y]` for some `z ‚àà [x, y)`.
* `tendsto_of_tendsto_of_tendsto_of_le_of_le` : theorem known as squeeze theorem,
  sandwich theorem, theorem of Carabinieri, and two policemen (and a drunk) theorem; if `g` and `h`
  both converge to `a`, and eventually `g x ‚â§ f x ‚â§ h x`, then `f` converges to `a`.

## Implementation notes

We do _not_ register the order topology as an instance on a preorder (or even on a linear order).
Indeed, on many such spaces, a topology has already been constructed in a different way (think
of the discrete spaces `‚Ñï` or `‚Ñ§`, or `‚Ñù` that could inherit a topology as the completion of `‚Ñö`),
and is in general not defeq to the one generated by the intervals. We make it available as a
definition `Preorder.topology Œ±` though, that can be registered as an instance when necessary, or
for specific types.
-/


open Set Filter TopologicalSpace Topology Function

open OrderDual (toDual ofDual)

universe u v w

variable {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w}

-- Porting note (#11215): TODO: define `Preorder.topology` before `OrderTopology` and reuse the def
/-- The order topology on an ordered type is the topology generated by open intervals. We register
it on a preorder, but it is mostly interesting in linear orders, where it is also order-closed.
We define it as a mixin. If you want to introduce the order topology on a preorder, use
`Preorder.topology`. -/
class OrderTopology (Œ± : Type*) [t : TopologicalSpace Œ±] [Preorder Œ±] : Prop where
  /-- The topology is generated by open intervals `Set.Ioi _` and `Set.Iio _`. -/
  topology_eq_generate_intervals : t = generateFrom { s | ‚àÉ a, s = Ioi a ‚à® s = Iio a }
#align order_topology OrderTopology

/-- (Order) topology on a partial order `Œ±` generated by the subbase of open intervals
`(a, ‚àû) = { x ‚à£ a < x }, (-‚àû , b) = {x ‚à£ x < b}` for all `a, b` in `Œ±`. We do not register it as an
instance as many ordered sets are already endowed with the same topology, most often in a non-defeq
way though. Register as a local instance when necessary. -/
def Preorder.topology (Œ± : Type*) [Preorder Œ±] : TopologicalSpace Œ± :=
  generateFrom { s : Set Œ± | ‚àÉ a : Œ±, s = { b : Œ± | a < b } ‚à® s = { b : Œ± | b < a } }
#align preorder.topology Preorder.topology

section OrderTopology

section Preorder

variable [TopologicalSpace Œ±] [Preorder Œ±] [t : OrderTopology Œ±]

instance : OrderTopology Œ±·µí·µà :=
  ‚ü®by
    convert OrderTopology.topology_eq_generate_intervals (Œ± := Œ±) using 6
    apply or_comm‚ü©

theorem isOpen_iff_generate_intervals {s : Set Œ±} :
    IsOpen s ‚Üî GenerateOpen { s | ‚àÉ a, s = Ioi a ‚à® s = Iio a } s := by
  rw [t.topology_eq_generate_intervals]; rfl
#align is_open_iff_generate_intervals isOpen_iff_generate_intervals

theorem isOpen_lt' (a : Œ±) : IsOpen { b : Œ± | a < b } :=
  isOpen_iff_generate_intervals.2 <| .basic _ ‚ü®a, .inl rfl‚ü©
#align is_open_lt' isOpen_lt'

theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=
  isOpen_iff_generate_intervals.2 <| .basic _ ‚ü®a, .inr rfl‚ü©
#align is_open_gt' isOpen_gt'

theorem lt_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù b, a < x :=
  (isOpen_lt' _).mem_nhds h
#align lt_mem_nhds lt_mem_nhds

theorem le_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù b, a ‚â§ x :=
  (lt_mem_nhds h).mono fun _ => le_of_lt
#align le_mem_nhds le_mem_nhds

theorem gt_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù a, x < b :=
  (isOpen_gt' _).mem_nhds h
#align gt_mem_nhds gt_mem_nhds

theorem ge_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù a, x ‚â§ b :=
  (gt_mem_nhds h).mono fun _ => le_of_lt
#align ge_mem_nhds ge_mem_nhds

theorem nhds_eq_order (a : Œ±) : ùìù a = (‚®Ö b ‚àà Iio a, ùìü (Ioi b)) ‚äì ‚®Ö b ‚àà Ioi a, ùìü (Iio b) := by
  rw [t.topology_eq_generate_intervals, nhds_generateFrom]
  simp_rw [mem_setOf_eq, @and_comm (a ‚àà _), exists_or, or_and_right, iInf_or, iInf_and, iInf_exists,
    iInf_inf_eq, iInf_comm (Œπ := Set Œ±), iInf_iInf_eq_left, mem_Ioi, mem_Iio]
#align nhds_eq_order nhds_eq_order

theorem tendsto_order {f : Œ≤ ‚Üí Œ±} {a : Œ±} {x : Filter Œ≤} :
    Tendsto f x (ùìù a) ‚Üî (‚àÄ a' < a, ‚àÄ·∂† b in x, a' < f b) ‚àß ‚àÄ a' > a, ‚àÄ·∂† b in x, f b < a' := by
  simp only [nhds_eq_order a, tendsto_inf, tendsto_iInf, tendsto_principal]; rfl
#align tendsto_order tendsto_order

instance tendstoIccClassNhds (a : Œ±) : TendstoIxxClass Icc (ùìù a) (ùìù a) := by
  simp only [nhds_eq_order, iInf_subtype']
  refine
    ((hasBasis_iInf_principal_finite _).inf (hasBasis_iInf_principal_finite _)).tendstoIxxClass
      fun s _ => ?_
  refine ((ordConnected_biInter ?_).inter (ordConnected_biInter ?_)).out <;> intro _ _
  exacts [ordConnected_Ioi, ordConnected_Iio]
#align tendsto_Icc_class_nhds tendstoIccClassNhds

instance tendstoIcoClassNhds (a : Œ±) : TendstoIxxClass Ico (ùìù a) (ùìù a) :=
  tendstoIxxClass_of_subset fun _ _ => Ico_subset_Icc_self
#align tendsto_Ico_class_nhds tendstoIcoClassNhds

instance tendstoIocClassNhds (a : Œ±) : TendstoIxxClass Ioc (ùìù a) (ùìù a) :=
  tendstoIxxClass_of_subset fun _ _ => Ioc_subset_Icc_self
#align tendsto_Ioc_class_nhds tendstoIocClassNhds

instance tendstoIooClassNhds (a : Œ±) : TendstoIxxClass Ioo (ùìù a) (ùìù a) :=
  tendstoIxxClass_of_subset fun _ _ => Ioo_subset_Icc_self
#align tendsto_Ioo_class_nhds tendstoIooClassNhds

/-- **Squeeze theorem** (also known as **sandwich theorem**). This version assumes that inequalities
hold eventually for the filter. -/
theorem tendsto_of_tendsto_of_tendsto_of_le_of_le' {f g h : Œ≤ ‚Üí Œ±} {b : Filter Œ≤} {a : Œ±}
    (hg : Tendsto g b (ùìù a)) (hh : Tendsto h b (ùìù a)) (hgf : ‚àÄ·∂† b in b, g b ‚â§ f b)
    (hfh : ‚àÄ·∂† b in b, f b ‚â§ h b) : Tendsto f b (ùìù a) :=
  (hg.Icc hh).of_smallSets <| hgf.and hfh
#align tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_of_tendsto_of_tendsto_of_le_of_le'

/-- **Squeeze theorem** (also known as **sandwich theorem**). This version assumes that inequalities
hold everywhere. -/
theorem tendsto_of_tendsto_of_tendsto_of_le_of_le {f g h : Œ≤ ‚Üí Œ±} {b : Filter Œ≤} {a : Œ±}
    (hg : Tendsto g b (ùìù a)) (hh : Tendsto h b (ùìù a)) (hgf : g ‚â§ f) (hfh : f ‚â§ h) :
    Tendsto f b (ùìù a) :=
  tendsto_of_tendsto_of_tendsto_of_le_of_le' hg hh (eventually_of_forall hgf)
    (eventually_of_forall hfh)
#align tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_of_tendsto_of_tendsto_of_le_of_le

theorem nhds_order_unbounded {a : Œ±} (hu : ‚àÉ u, a < u) (hl : ‚àÉ l, l < a) :
    ùìù a = ‚®Ö (l) (_ : l < a) (u) (_ : a < u), ùìü (Ioo l u) := by
  simp only [nhds_eq_order, ‚Üê inf_biInf, ‚Üê biInf_inf, *, ‚Üê inf_principal, ‚Üê Ioi_inter_Iio]; rfl
#align nhds_order_unbounded nhds_order_unbounded

theorem tendsto_order_unbounded {f : Œ≤ ‚Üí Œ±} {a : Œ±} {x : Filter Œ≤} (hu : ‚àÉ u, a < u)
    (hl : ‚àÉ l, l < a) (h : ‚àÄ l u, l < a ‚Üí a < u ‚Üí ‚àÄ·∂† b in x, l < f b ‚àß f b < u) :
    Tendsto f x (ùìù a) := by
  simp only [nhds_order_unbounded hu hl, tendsto_iInf, tendsto_principal]
  exact fun l hl u => h l u hl
#align tendsto_order_unbounded tendsto_order_unbounded

end Preorder

instance tendstoIxxNhdsWithin {Œ± : Type*} [TopologicalSpace Œ±] (a : Œ±) {s t : Set Œ±}
    {Ixx} [TendstoIxxClass Ixx (ùìù a) (ùìù a)] [TendstoIxxClass Ixx (ùìü s) (ùìü t)] :
    TendstoIxxClass Ixx (ùìù[s] a) (ùìù[t] a) :=
  Filter.tendstoIxxClass_inf
#align tendsto_Ixx_nhds_within tendstoIxxNhdsWithin

instance tendstoIccClassNhdsPi {Œπ : Type*} {Œ± : Œπ ‚Üí Type*} [‚àÄ i, Preorder (Œ± i)]
    [‚àÄ i, TopologicalSpace (Œ± i)] [‚àÄ i, OrderTopology (Œ± i)] (f : ‚àÄ i, Œ± i) :
    TendstoIxxClass Icc (ùìù f) (ùìù f) := by
  constructor
  conv in (ùìù f).smallSets => rw [nhds_pi, Filter.pi]
  simp only [smallSets_iInf, smallSets_comap_eq_comap_image, tendsto_iInf, tendsto_comap_iff]
  intro i
  have : Tendsto (fun g : ‚àÄ i, Œ± i => g i) (ùìù f) (ùìù (f i)) := (continuous_apply i).tendsto f
  refine (this.comp tendsto_fst).Icc (this.comp tendsto_snd) |>.smallSets_mono ?_
  filter_upwards [] using fun ‚ü®f, g‚ü© ‚Ü¶ image_subset_iff.mpr fun p hp ‚Ü¶ ‚ü®hp.1 i, hp.2 i‚ü©
#align tendsto_Icc_class_nhds_pi tendstoIccClassNhdsPi

-- Porting note (#10756): new lemma
theorem induced_topology_le_preorder [Preorder Œ±] [Preorder Œ≤] [TopologicalSpace Œ≤]
    [OrderTopology Œ≤] {f : Œ± ‚Üí Œ≤} (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y) :
    induced f ‚ÄπTopologicalSpace Œ≤‚Ä∫ ‚â§ Preorder.topology Œ± := by
  let _ := Preorder.topology Œ±; have : OrderTopology Œ± := ‚ü®rfl‚ü©
  refine le_of_nhds_le_nhds fun x => ?_
  simp only [nhds_eq_order, nhds_induced, comap_inf, comap_iInf, comap_principal, Ioi, Iio, ‚Üê hf]
  refine inf_le_inf (le_iInf‚ÇÇ fun a ha => ?_) (le_iInf‚ÇÇ fun a ha => ?_)
  exacts [iInf‚ÇÇ_le (f a) ha, iInf‚ÇÇ_le (f a) ha]

-- Porting note (#10756): new lemma
theorem induced_topology_eq_preorder [Preorder Œ±] [Preorder Œ≤] [TopologicalSpace Œ≤]
    [OrderTopology Œ≤] {f : Œ± ‚Üí Œ≤} (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)
    (H‚ÇÅ : ‚àÄ {a b x}, b < f a ‚Üí ¬¨(b < f x) ‚Üí ‚àÉ y, y < a ‚àß b ‚â§ f y)
    (H‚ÇÇ : ‚àÄ {a b x}, f a < b ‚Üí ¬¨(f x < b) ‚Üí ‚àÉ y, a < y ‚àß f y ‚â§ b) :
    induced f ‚ÄπTopologicalSpace Œ≤‚Ä∫ = Preorder.topology Œ± := by
  let _ := Preorder.topology Œ±; have : OrderTopology Œ± := ‚ü®rfl‚ü©
  refine le_antisymm (induced_topology_le_preorder hf) ?_
  refine le_of_nhds_le_nhds fun a => ?_
  simp only [nhds_eq_order, nhds_induced, comap_inf, comap_iInf, comap_principal]
  refine inf_le_inf (le_iInf‚ÇÇ fun b hb => ?_) (le_iInf‚ÇÇ fun b hb => ?_)
  ¬∑ rcases em (‚àÉ x, ¬¨(b < f x)) with (‚ü®x, hx‚ü© | hb)
    ¬∑ rcases H‚ÇÅ hb hx with ‚ü®y, hya, hyb‚ü©
      exact iInf‚ÇÇ_le_of_le y hya (principal_mono.2 fun z hz => hyb.trans_lt (hf.2 hz))
    ¬∑ push_neg at hb
      exact le_principal_iff.2 (univ_mem' hb)
  ¬∑ rcases em (‚àÉ x, ¬¨(f x < b)) with (‚ü®x, hx‚ü© | hb)
    ¬∑ rcases H‚ÇÇ hb hx with ‚ü®y, hya, hyb‚ü©
      exact iInf‚ÇÇ_le_of_le y hya (principal_mono.2 fun z hz => (hf.2 hz).trans_le hyb)
    ¬∑ push_neg at hb
      exact le_principal_iff.2 (univ_mem' hb)

theorem induced_orderTopology' {Œ± : Type u} {Œ≤ : Type v} [Preorder Œ±] [ta : TopologicalSpace Œ≤]
    [Preorder Œ≤] [OrderTopology Œ≤] (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)
    (H‚ÇÅ : ‚àÄ {a x}, x < f a ‚Üí ‚àÉ b < a, x ‚â§ f b) (H‚ÇÇ : ‚àÄ {a x}, f a < x ‚Üí ‚àÉ b > a, f b ‚â§ x) :
    @OrderTopology _ (induced f ta) _ :=
  let _ := induced f ta
  ‚ü®induced_topology_eq_preorder hf (fun h _ => H‚ÇÅ h) (fun h _ => H‚ÇÇ h)‚ü©
#align induced_order_topology' induced_orderTopology'

theorem induced_orderTopology {Œ± : Type u} {Œ≤ : Type v} [Preorder Œ±] [ta : TopologicalSpace Œ≤]
    [Preorder Œ≤] [OrderTopology Œ≤] (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)
    (H : ‚àÄ {x y}, x < y ‚Üí ‚àÉ a, x < f a ‚àß f a < y) : @OrderTopology _ (induced f ta) _ :=
  induced_orderTopology' f (hf)
    (fun xa => let ‚ü®b, xb, ba‚ü© := H xa; ‚ü®b, hf.1 ba, le_of_lt xb‚ü©)
    fun ax => let ‚ü®b, ab, bx‚ü© := H ax; ‚ü®b, hf.1 ab, le_of_lt bx‚ü©
#align induced_order_topology induced_orderTopology

/-- The topology induced by a strictly monotone function with order-connected range is the preorder
topology. -/
nonrec theorem StrictMono.induced_topology_eq_preorder {Œ± Œ≤ : Type*} [LinearOrder Œ±]
    [LinearOrder Œ≤] [t : TopologicalSpace Œ≤] [OrderTopology Œ≤] {f : Œ± ‚Üí Œ≤}
    (hf : StrictMono f) (hc : OrdConnected (range f)) : t.induced f = Preorder.topology Œ± := by
  refine induced_topology_eq_preorder hf.lt_iff_lt (fun h‚ÇÅ h‚ÇÇ => ?_) fun h‚ÇÅ h‚ÇÇ => ?_
  ¬∑ rcases hc.out (mem_range_self _) (mem_range_self _) ‚ü®not_lt.1 h‚ÇÇ, h‚ÇÅ.le‚ü© with ‚ü®y, rfl‚ü©
    exact ‚ü®y, hf.lt_iff_lt.1 h‚ÇÅ, le_rfl‚ü©
  ¬∑ rcases hc.out (mem_range_self _) (mem_range_self _) ‚ü®h‚ÇÅ.le, not_lt.1 h‚ÇÇ‚ü© with ‚ü®y, rfl‚ü©
    exact ‚ü®y, hf.lt_iff_lt.1 h‚ÇÅ, le_rfl‚ü©

/-- A strictly monotone function between linear orders with order topology is a topological
embedding provided that the range of `f` is order-connected. -/
theorem StrictMono.embedding_of_ordConnected {Œ± Œ≤ : Type*} [LinearOrder Œ±] [LinearOrder Œ≤]
    [TopologicalSpace Œ±] [h : OrderTopology Œ±] [TopologicalSpace Œ≤] [OrderTopology Œ≤] {f : Œ± ‚Üí Œ≤}
    (hf : StrictMono f) (hc : OrdConnected (range f)) : Embedding f :=
  ‚ü®‚ü®h.1.trans <| Eq.symm <| hf.induced_topology_eq_preorder hc‚ü©, hf.injective‚ü©

/-- On a `Set.OrdConnected` subset of a linear order, the order topology for the restriction of the
order is the same as the restriction to the subset of the order topology. -/
instance orderTopology_of_ordConnected {Œ± : Type u} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderTopology Œ±] {t : Set Œ±} [ht : OrdConnected t] : OrderTopology t :=
  ‚ü®(Subtype.strictMono_coe t).induced_topology_eq_preorder <| by
    rwa [‚Üê @Subtype.range_val _ t] at ht‚ü©
#align order_topology_of_ord_connected orderTopology_of_ordConnected

theorem nhdsWithin_Ici_eq'' [TopologicalSpace Œ±] [Preorder Œ±] [OrderTopology Œ±] (a : Œ±) :
    ùìù[‚â•] a = (‚®Ö (u) (_ : a < u), ùìü (Iio u)) ‚äì ùìü (Ici a) := by
  rw [nhdsWithin, nhds_eq_order]
  refine le_antisymm (inf_le_inf_right _ inf_le_right) (le_inf (le_inf ?_ inf_le_left) inf_le_right)
  exact inf_le_right.trans (le_iInf‚ÇÇ fun l hl => principal_mono.2 <| Ici_subset_Ioi.2 hl)
#align nhds_within_Ici_eq'' nhdsWithin_Ici_eq''

theorem nhdsWithin_Iic_eq'' [TopologicalSpace Œ±] [Preorder Œ±] [OrderTopology Œ±] (a : Œ±) :
    ùìù[‚â§] a = (‚®Ö l < a, ùìü (Ioi l)) ‚äì ùìü (Iic a) :=
  nhdsWithin_Ici_eq'' (toDual a)
#align nhds_within_Iic_eq'' nhdsWithin_Iic_eq''

theorem nhdsWithin_Ici_eq' [TopologicalSpace Œ±] [Preorder Œ±] [OrderTopology Œ±] {a : Œ±}
    (ha : ‚àÉ u, a < u) : ùìù[‚â•] a = ‚®Ö (u) (_ : a < u), ùìü (Ico a u) := by
  simp only [nhdsWithin_Ici_eq'', biInf_inf ha, inf_principal, Iio_inter_Ici]
#align nhds_within_Ici_eq' nhdsWithin_Ici_eq'

theorem nhdsWithin_Iic_eq' [TopologicalSpace Œ±] [Preorder Œ±] [OrderTopology Œ±] {a : Œ±}
    (ha : ‚àÉ l, l < a) : ùìù[‚â§] a = ‚®Ö l < a, ùìü (Ioc l a) := by
  simp only [nhdsWithin_Iic_eq'', biInf_inf ha, inf_principal, Ioi_inter_Iic]
#align nhds_within_Iic_eq' nhdsWithin_Iic_eq'

theorem nhdsWithin_Ici_basis' [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] {a : Œ±}
    (ha : ‚àÉ u, a < u) : (ùìù[‚â•] a).HasBasis (fun u => a < u) fun u => Ico a u :=
  (nhdsWithin_Ici_eq' ha).symm ‚ñ∏
    hasBasis_biInf_principal
      (fun b hb c hc => ‚ü®min b c, lt_min hb hc, Ico_subset_Ico_right (min_le_left _ _),
        Ico_subset_Ico_right (min_le_right _ _)‚ü©)
      ha
#align nhds_within_Ici_basis' nhdsWithin_Ici_basis'

theorem nhdsWithin_Iic_basis' [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] {a : Œ±}
    (ha : ‚àÉ l, l < a) : (ùìù[‚â§] a).HasBasis (fun l => l < a) fun l => Ioc l a := by
  convert nhdsWithin_Ici_basis' (Œ± := Œ±·µí·µà) ha using 2
  exact dual_Ico.symm
#align nhds_within_Iic_basis' nhdsWithin_Iic_basis'

theorem nhdsWithin_Ici_basis [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [NoMaxOrder Œ±]
    (a : Œ±) : (ùìù[‚â•] a).HasBasis (fun u => a < u) fun u => Ico a u :=
  nhdsWithin_Ici_basis' (exists_gt a)
#align nhds_within_Ici_basis nhdsWithin_Ici_basis

theorem nhdsWithin_Iic_basis [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [NoMinOrder Œ±]
    (a : Œ±) : (ùìù[‚â§] a).HasBasis (fun l => l < a) fun l => Ioc l a :=
  nhdsWithin_Iic_basis' (exists_lt a)
#align nhds_within_Iic_basis nhdsWithin_Iic_basis

theorem nhds_top_order [TopologicalSpace Œ±] [Preorder Œ±] [OrderTop Œ±] [OrderTopology Œ±] :
    ùìù (‚ä§ : Œ±) = ‚®Ö (l) (h‚ÇÇ : l < ‚ä§), ùìü (Ioi l) := by simp [nhds_eq_order (‚ä§ : Œ±)]
#align nhds_top_order nhds_top_order

theorem nhds_bot_order [TopologicalSpace Œ±] [Preorder Œ±] [OrderBot Œ±] [OrderTopology Œ±] :
    ùìù (‚ä• : Œ±) = ‚®Ö (l) (h‚ÇÇ : ‚ä• < l), ùìü (Iio l) := by simp [nhds_eq_order (‚ä• : Œ±)]
#align nhds_bot_order nhds_bot_order

theorem nhds_top_basis [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTop Œ±] [OrderTopology Œ±]
    [Nontrivial Œ±] : (ùìù ‚ä§).HasBasis (fun a : Œ± => a < ‚ä§) fun a : Œ± => Ioi a := by
  have : ‚àÉ x : Œ±, x < ‚ä§ := (exists_ne ‚ä§).imp fun x hx => hx.lt_top
  simpa only [Iic_top, nhdsWithin_univ, Ioc_top] using nhdsWithin_Iic_basis' this
#align nhds_top_basis nhds_top_basis

theorem nhds_bot_basis [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderBot Œ±] [OrderTopology Œ±]
    [Nontrivial Œ±] : (ùìù ‚ä•).HasBasis (fun a : Œ± => ‚ä• < a) fun a : Œ± => Iio a :=
  nhds_top_basis (Œ± := Œ±·µí·µà)
#align nhds_bot_basis nhds_bot_basis

theorem nhds_top_basis_Ici [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTop Œ±] [OrderTopology Œ±]
    [Nontrivial Œ±] [DenselyOrdered Œ±] : (ùìù ‚ä§).HasBasis (fun a : Œ± => a < ‚ä§) Ici :=
  nhds_top_basis.to_hasBasis
    (fun _a ha => let ‚ü®b, hab, hb‚ü© := exists_between ha; ‚ü®b, hb, Ici_subset_Ioi.mpr hab‚ü©)
    fun a ha => ‚ü®a, ha, Ioi_subset_Ici_self‚ü©
#align nhds_top_basis_Ici nhds_top_basis_Ici

theorem nhds_bot_basis_Iic [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderBot Œ±] [OrderTopology Œ±]
    [Nontrivial Œ±] [DenselyOrdered Œ±] : (ùìù ‚ä•).HasBasis (fun a : Œ± => ‚ä• < a) Iic :=
  nhds_top_basis_Ici (Œ± := Œ±·µí·µà)
#align nhds_bot_basis_Iic nhds_bot_basis_Iic

theorem tendsto_nhds_top_mono [TopologicalSpace Œ≤] [Preorder Œ≤] [OrderTop Œ≤] [OrderTopology Œ≤]
    {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : Tendsto f l (ùìù ‚ä§)) (hg : f ‚â§·∂†[l] g) : Tendsto g l (ùìù ‚ä§) := by
  simp only [nhds_top_order, tendsto_iInf, tendsto_principal] at hf ‚ä¢
  intro x hx
  filter_upwards [hf x hx, hg] with _ using lt_of_lt_of_le
#align tendsto_nhds_top_mono tendsto_nhds_top_mono

theorem tendsto_nhds_bot_mono [TopologicalSpace Œ≤] [Preorder Œ≤] [OrderBot Œ≤] [OrderTopology Œ≤]
    {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : Tendsto f l (ùìù ‚ä•)) (hg : g ‚â§·∂†[l] f) : Tendsto g l (ùìù ‚ä•) :=
  tendsto_nhds_top_mono (Œ≤ := Œ≤·µí·µà) hf hg
#align tendsto_nhds_bot_mono tendsto_nhds_bot_mono

theorem tendsto_nhds_top_mono' [TopologicalSpace Œ≤] [Preorder Œ≤] [OrderTop Œ≤] [OrderTopology Œ≤]
    {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : Tendsto f l (ùìù ‚ä§)) (hg : f ‚â§ g) : Tendsto g l (ùìù ‚ä§) :=
  tendsto_nhds_top_mono hf (eventually_of_forall hg)
#align tendsto_nhds_top_mono' tendsto_nhds_top_mono'

theorem tendsto_nhds_bot_mono' [TopologicalSpace Œ≤] [Preorder Œ≤] [OrderBot Œ≤] [OrderTopology Œ≤]
    {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : Tendsto f l (ùìù ‚ä•)) (hg : g ‚â§ f) : Tendsto g l (ùìù ‚ä•) :=
  tendsto_nhds_bot_mono hf (eventually_of_forall hg)
#align tendsto_nhds_bot_mono' tendsto_nhds_bot_mono'

section LinearOrder

variable [TopologicalSpace Œ±] [LinearOrder Œ±]

section OrderTopology

variable [OrderTopology Œ±]

theorem order_separated {a‚ÇÅ a‚ÇÇ : Œ±} (h : a‚ÇÅ < a‚ÇÇ) :
    ‚àÉ u v : Set Œ±, IsOpen u ‚àß IsOpen v ‚àß a‚ÇÅ ‚àà u ‚àß a‚ÇÇ ‚àà v ‚àß ‚àÄ b‚ÇÅ ‚àà u, ‚àÄ b‚ÇÇ ‚àà v, b‚ÇÅ < b‚ÇÇ :=
  let ‚ü®x, hx, y, hy, h‚ü© := h.exists_disjoint_Iio_Ioi
  ‚ü®Iio x, Ioi y, isOpen_gt' _, isOpen_lt' _, hx, hy, h‚ü©
#align order_separated order_separated

-- see Note [lower instance priority]
instance (priority := 100) OrderTopology.to_orderClosedTopology : OrderClosedTopology Œ± where
  isClosed_le' := isOpen_compl_iff.1 <| isOpen_prod_iff.mpr fun a‚ÇÅ a‚ÇÇ (h : ¬¨a‚ÇÅ ‚â§ a‚ÇÇ) =>
    have h : a‚ÇÇ < a‚ÇÅ := lt_of_not_ge h
    let ‚ü®u, v, hu, hv, ha‚ÇÅ, ha‚ÇÇ, h‚ü© := order_separated h
    ‚ü®v, u, hv, hu, ha‚ÇÇ, ha‚ÇÅ, fun ‚ü®b‚ÇÅ, b‚ÇÇ‚ü© ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© => not_le_of_gt <| h b‚ÇÇ h‚ÇÇ b‚ÇÅ h‚ÇÅ‚ü©
#align order_topology.to_order_closed_topology OrderTopology.to_orderClosedTopology

theorem exists_Ioc_subset_of_mem_nhds {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) (h : ‚àÉ l, l < a) :
    ‚àÉ l < a, Ioc l a ‚äÜ s :=
  (nhdsWithin_Iic_basis' h).mem_iff.mp (nhdsWithin_le_nhds hs)
#align exists_Ioc_subset_of_mem_nhds exists_Ioc_subset_of_mem_nhds

theorem exists_Ioc_subset_of_mem_nhds' {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) {l : Œ±} (hl : l < a) :
    ‚àÉ l' ‚àà Ico l a, Ioc l' a ‚äÜ s :=
  let ‚ü®l', hl'a, hl's‚ü© := exists_Ioc_subset_of_mem_nhds hs ‚ü®l, hl‚ü©
  ‚ü®max l l', ‚ü®le_max_left _ _, max_lt hl hl'a‚ü©,
    (Ioc_subset_Ioc_left <| le_max_right _ _).trans hl's‚ü©
#align exists_Ioc_subset_of_mem_nhds' exists_Ioc_subset_of_mem_nhds'

theorem exists_Ico_subset_of_mem_nhds' {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) {u : Œ±} (hu : a < u) :
    ‚àÉ u' ‚àà Ioc a u, Ico a u' ‚äÜ s := by
  simpa only [OrderDual.exists, exists_prop, dual_Ico, dual_Ioc] using
    exists_Ioc_subset_of_mem_nhds' (show ofDual ‚Åª¬π' s ‚àà ùìù (toDual a) from hs) hu.dual
#align exists_Ico_subset_of_mem_nhds' exists_Ico_subset_of_mem_nhds'

theorem exists_Ico_subset_of_mem_nhds {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) (h : ‚àÉ u, a < u) :
    ‚àÉ u, a < u ‚àß Ico a u ‚äÜ s :=
  let ‚ü®_l', hl'‚ü© := h;
  let ‚ü®l, hl‚ü© := exists_Ico_subset_of_mem_nhds' hs hl'
  ‚ü®l, hl.1.1, hl.2‚ü©
#align exists_Ico_subset_of_mem_nhds exists_Ico_subset_of_mem_nhds

theorem exists_Icc_mem_subset_of_mem_nhdsWithin_Ici {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù[‚â•] a) :
    ‚àÉ b, a ‚â§ b ‚àß Icc a b ‚àà ùìù[‚â•] a ‚àß Icc a b ‚äÜ s := by
  rcases (em (IsMax a)).imp_right not_isMax_iff.mp with (ha | ha)
  ¬∑ use a
    simpa [ha.Ici_eq] using hs
  ¬∑ rcases (nhdsWithin_Ici_basis' ha).mem_iff.mp hs with ‚ü®b, hab, hbs‚ü©
    rcases eq_empty_or_nonempty (Ioo a b) with (H | ‚ü®c, hac, hcb‚ü©)
    ¬∑ have : Ico a b = Icc a a := by rw [‚Üê Icc_union_Ioo_eq_Ico le_rfl hab, H, union_empty]
      exact ‚ü®a, le_rfl, this ‚ñ∏ ‚ü®Ico_mem_nhdsWithin_Ici' hab, hbs‚ü©‚ü©
    ¬∑ refine ‚ü®c, hac.le, Icc_mem_nhdsWithin_Ici' hac, ?_‚ü©
      exact (Icc_subset_Ico_right hcb).trans hbs
#align exists_Icc_mem_subset_of_mem_nhds_within_Ici exists_Icc_mem_subset_of_mem_nhdsWithin_Ici

theorem exists_Icc_mem_subset_of_mem_nhdsWithin_Iic {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù[‚â§] a) :
    ‚àÉ b ‚â§ a, Icc b a ‚àà ùìù[‚â§] a ‚àß Icc b a ‚äÜ s := by
  simpa only [dual_Icc, toDual.surjective.exists] using
    exists_Icc_mem_subset_of_mem_nhdsWithin_Ici (Œ± := Œ±·µí·µà) (a := toDual a) hs
#align exists_Icc_mem_subset_of_mem_nhds_within_Iic exists_Icc_mem_subset_of_mem_nhdsWithin_Iic

theorem exists_Icc_mem_subset_of_mem_nhds {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) :
    ‚àÉ b c, a ‚àà Icc b c ‚àß Icc b c ‚àà ùìù a ‚àß Icc b c ‚äÜ s := by
  rcases exists_Icc_mem_subset_of_mem_nhdsWithin_Iic (nhdsWithin_le_nhds hs) with
    ‚ü®b, hba, hb_nhds, hbs‚ü©
  rcases exists_Icc_mem_subset_of_mem_nhdsWithin_Ici (nhdsWithin_le_nhds hs) with
    ‚ü®c, hac, hc_nhds, hcs‚ü©
  refine ‚ü®b, c, ‚ü®hba, hac‚ü©, ?_‚ü©
  rw [‚Üê Icc_union_Icc_eq_Icc hba hac, ‚Üê nhds_left_sup_nhds_right]
  exact ‚ü®union_mem_sup hb_nhds hc_nhds, union_subset hbs hcs‚ü©
#align exists_Icc_mem_subset_of_mem_nhds exists_Icc_mem_subset_of_mem_nhds

theorem IsOpen.exists_Ioo_subset [Nontrivial Œ±] {s : Set Œ±} (hs : IsOpen s) (h : s.Nonempty) :
    ‚àÉ a b, a < b ‚àß Ioo a b ‚äÜ s := by
  obtain ‚ü®x, hx‚ü© : ‚àÉ x, x ‚àà s := h
  obtain ‚ü®y, hy‚ü© : ‚àÉ y, y ‚â† x := exists_ne x
  rcases lt_trichotomy x y with (H | rfl | H)
  ¬∑ obtain ‚ü®u, xu, hu‚ü© : ‚àÉ u, x < u ‚àß Ico x u ‚äÜ s :=
      exists_Ico_subset_of_mem_nhds (hs.mem_nhds hx) ‚ü®y, H‚ü©
    exact ‚ü®x, u, xu, Ioo_subset_Ico_self.trans hu‚ü©
  ¬∑ exact (hy rfl).elim
  ¬∑ obtain ‚ü®l, lx, hl‚ü© : ‚àÉ l, l < x ‚àß Ioc l x ‚äÜ s :=
      exists_Ioc_subset_of_mem_nhds (hs.mem_nhds hx) ‚ü®y, H‚ü©
    exact ‚ü®l, x, lx, Ioo_subset_Ioc_self.trans hl‚ü©
#align is_open.exists_Ioo_subset IsOpen.exists_Ioo_subset

theorem dense_of_exists_between [Nontrivial Œ±] {s : Set Œ±}
    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí ‚àÉ c ‚àà s, a < c ‚àß c < b) : Dense s := by
  refine dense_iff_inter_open.2 fun U U_open U_nonempty => ?_
  obtain ‚ü®a, b, hab, H‚ü© : ‚àÉ a b : Œ±, a < b ‚àß Ioo a b ‚äÜ U := U_open.exists_Ioo_subset U_nonempty
  obtain ‚ü®x, xs, hx‚ü© : ‚àÉ x ‚àà s, a < x ‚àß x < b := h hab
  exact ‚ü®x, ‚ü®H hx, xs‚ü©‚ü©
#align dense_of_exists_between dense_of_exists_between

/-- A set in a nontrivial densely linear ordered type is dense in the sense of topology if and only
if for any `a < b` there exists `c ‚àà s`, `a < c < b`. Each implication requires less typeclass
assumptions. -/
theorem dense_iff_exists_between [DenselyOrdered Œ±] [Nontrivial Œ±] {s : Set Œ±} :
    Dense s ‚Üî ‚àÄ a b, a < b ‚Üí ‚àÉ c ‚àà s, a < c ‚àß c < b :=
  ‚ü®fun h _ _ hab => h.exists_between hab, dense_of_exists_between‚ü©
#align dense_iff_exists_between dense_iff_exists_between

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`,
provided `a` is neither a bottom element nor a top element. -/
theorem mem_nhds_iff_exists_Ioo_subset' {a : Œ±} {s : Set Œ±} (hl : ‚àÉ l, l < a) (hu : ‚àÉ u, a < u) :
    s ‚àà ùìù a ‚Üî ‚àÉ l u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s := by
  constructor
  ¬∑ intro h
    rcases exists_Ico_subset_of_mem_nhds h hu with ‚ü®u, au, hu‚ü©
    rcases exists_Ioc_subset_of_mem_nhds h hl with ‚ü®l, la, hl‚ü©
    exact ‚ü®l, u, ‚ü®la, au‚ü©, Ioc_union_Ico_eq_Ioo la au ‚ñ∏ union_subset hl hu‚ü©
  ¬∑ rintro ‚ü®l, u, ha, h‚ü©
    apply mem_of_superset (Ioo_mem_nhds ha.1 ha.2) h
#align mem_nhds_iff_exists_Ioo_subset' mem_nhds_iff_exists_Ioo_subset'

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`.
-/
theorem mem_nhds_iff_exists_Ioo_subset [NoMaxOrder Œ±] [NoMinOrder Œ±] {a : Œ±} {s : Set Œ±} :
    s ‚àà ùìù a ‚Üî ‚àÉ l u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s :=
  mem_nhds_iff_exists_Ioo_subset' (exists_lt a) (exists_gt a)
#align mem_nhds_iff_exists_Ioo_subset mem_nhds_iff_exists_Ioo_subset

theorem nhds_basis_Ioo' {a : Œ±} (hl : ‚àÉ l, l < a) (hu : ‚àÉ u, a < u) :
    (ùìù a).HasBasis (fun b : Œ± √ó Œ± => b.1 < a ‚àß a < b.2) fun b => Ioo b.1 b.2 :=
  ‚ü®fun s => (mem_nhds_iff_exists_Ioo_subset' hl hu).trans <| by simp‚ü©
#align nhds_basis_Ioo' nhds_basis_Ioo'

theorem nhds_basis_Ioo [NoMaxOrder Œ±] [NoMinOrder Œ±] (a : Œ±) :
    (ùìù a).HasBasis (fun b : Œ± √ó Œ± => b.1 < a ‚àß a < b.2) fun b => Ioo b.1 b.2 :=
  nhds_basis_Ioo' (exists_lt a) (exists_gt a)
#align nhds_basis_Ioo nhds_basis_Ioo

theorem Filter.Eventually.exists_Ioo_subset [NoMaxOrder Œ±] [NoMinOrder Œ±] {a : Œ±} {p : Œ± ‚Üí Prop}
    (hp : ‚àÄ·∂† x in ùìù a, p x) : ‚àÉ l u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ { x | p x } :=
  mem_nhds_iff_exists_Ioo_subset.1 hp
#align filter.eventually.exists_Ioo_subset Filter.Eventually.exists_Ioo_subset

theorem Dense.topology_eq_generateFrom [DenselyOrdered Œ±] {s : Set Œ±} (hs : Dense s) :
    ‚ÄπTopologicalSpace Œ±‚Ä∫ = .generateFrom (Ioi '' s ‚à™ Iio '' s) := by
  refine (OrderTopology.topology_eq_generate_intervals (Œ± := Œ±)).trans ?_
  refine le_antisymm (generateFrom_anti ?_) (le_generateFrom ?_)
  ¬∑ simp only [union_subset_iff, image_subset_iff]
    exact ‚ü®fun a _ ‚Ü¶ ‚ü®a, .inl rfl‚ü©, fun a _ ‚Ü¶ ‚ü®a, .inr rfl‚ü©‚ü©
  ¬∑ rintro _ ‚ü®a, rfl | rfl‚ü©
    ¬∑ rw [hs.Ioi_eq_biUnion]
      let _ := generateFrom (Ioi '' s ‚à™ Iio '' s)
      exact isOpen_iUnion fun x ‚Ü¶ isOpen_iUnion fun h ‚Ü¶ .basic _ <| .inl <| mem_image_of_mem _ h.1
    ¬∑ rw [hs.Iio_eq_biUnion]
      let _ := generateFrom (Ioi '' s ‚à™ Iio '' s)
      exact isOpen_iUnion fun x ‚Ü¶ isOpen_iUnion fun h ‚Ü¶ .basic _ <| .inr <| mem_image_of_mem _ h.1

@[deprecated OrderBot.atBot_eq (since := "2024-02-14")]
theorem atBot_le_nhds_bot [OrderBot Œ±] : (atBot : Filter Œ±) ‚â§ ùìù ‚ä• := by
  rw [OrderBot.atBot_eq]
  apply pure_le_nhds
#align at_bot_le_nhds_bot atBot_le_nhds_bot

@[deprecated OrderTop.atTop_eq (since := "2024-02-14")]
theorem atTop_le_nhds_top [OrderTop Œ±] : (atTop : Filter Œ±) ‚â§ ùìù ‚ä§ :=
  set_option linter.deprecated false in @atBot_le_nhds_bot Œ±·µí·µà _ _ _
#align at_top_le_nhds_top atTop_le_nhds_top

variable (Œ±)

/-- Let `Œ±` be a densely ordered linear order with order topology. If `Œ±` is a separable space, then
it has second countable topology. Note that the "densely ordered" assumption cannot be dropped, see
[double arrow space](https://topology.pi-base.org/spaces/S000093) for a counterexample. -/
theorem SecondCountableTopology.of_separableSpace_orderTopology [DenselyOrdered Œ±]
    [SeparableSpace Œ±] : SecondCountableTopology Œ± := by
  rcases exists_countable_dense Œ± with ‚ü®s, hc, hd‚ü©
  refine ‚ü®‚ü®_, ?_, hd.topology_eq_generateFrom‚ü©‚ü©
  exact (hc.image _).union (hc.image _)

variable {Œ±}

-- Porting note (#10756): new lemma
/-- The set of points which are isolated on the right is countable when the space is
second-countable. -/
theorem countable_setOf_covBy_right [SecondCountableTopology Œ±] :
    Set.Countable { x : Œ± | ‚àÉ y, x ‚ãñ y } := by
  nontriviality Œ±
  let s := { x : Œ± | ‚àÉ y, x ‚ãñ y }
  have : ‚àÄ x ‚àà s, ‚àÉ y, x ‚ãñ y := fun x => id
  choose! y hy using this
  have Hy : ‚àÄ x z, x ‚àà s ‚Üí z < y x ‚Üí z ‚â§ x := fun x z hx => (hy x hx).le_of_lt
  suffices H : ‚àÄ a : Set Œ±, IsOpen a ‚Üí Set.Countable { x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a } by
    have : s ‚äÜ ‚ãÉ a ‚àà countableBasis Œ±, { x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a } := fun x hx => by
      rcases (isBasis_countableBasis Œ±).exists_mem_of_ne (hy x hx).ne with ‚ü®a, ab, xa, ya‚ü©
      exact mem_iUnion‚ÇÇ.2 ‚ü®a, ab, hx, xa, ya‚ü©
    refine Set.Countable.mono this ?_
    refine Countable.biUnion (countable_countableBasis Œ±) fun a ha => H _ ?_
    exact isOpen_of_mem_countableBasis ha
  intro a ha
  suffices H : Set.Countable { x | (x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a) ‚àß ¬¨IsBot x } from
    H.of_diff (subsingleton_isBot Œ±).countable
  simp only [and_assoc]
  let t := { x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a ‚àß ¬¨IsBot x }
  have : ‚àÄ x ‚àà t, ‚àÉ z < x, Ioc z x ‚äÜ a := by
    intro x hx
    apply exists_Ioc_subset_of_mem_nhds (ha.mem_nhds hx.2.1)
    simpa only [IsBot, not_forall, not_le] using hx.right.right.right
  choose! z hz h'z using this
  have : PairwiseDisjoint t fun x => Ioc (z x) x := fun x xt x' x't hxx' => by
    rcases hxx'.lt_or_lt with (h' | h')
    ¬∑ refine disjoint_left.2 fun u ux ux' => xt.2.2.1 ?_
      refine h'z x' x't ‚ü®ux'.1.trans_le (ux.2.trans (hy x xt.1).le), ?_‚ü©
      by_contra! H
      exact lt_irrefl _ ((Hy _ _ xt.1 H).trans_lt h')
    ¬∑ refine disjoint_left.2 fun u ux ux' => x't.2.2.1 ?_
      refine h'z x xt ‚ü®ux.1.trans_le (ux'.2.trans (hy x' x't.1).le), ?_‚ü©
      by_contra! H
      exact lt_irrefl _ ((Hy _ _ x't.1 H).trans_lt h')
  refine this.countable_of_isOpen (fun x hx => ?_) fun x hx => ‚ü®x, hz x hx, le_rfl‚ü©
  suffices H : Ioc (z x) x = Ioo (z x) (y x) by
    rw [H]
    exact isOpen_Ioo
  exact Subset.antisymm (Ioc_subset_Ioo_right (hy x hx.1).lt) fun u hu => ‚ü®hu.1, Hy _ _ hx.1 hu.2‚ü©

/-- The set of points which are isolated on the right is countable when the space is
second-countable. -/
@[deprecated countable_setOf_covBy_right]
theorem countable_of_isolated_right' [SecondCountableTopology Œ±] :
    Set.Countable { x : Œ± | ‚àÉ y, x < y ‚àß Ioo x y = ‚àÖ } := by
  simpa only [‚Üê covBy_iff_Ioo_eq] using countable_setOf_covBy_right
#align countable_of_isolated_right countable_of_isolated_right'

/-- The set of points which are isolated on the left is countable when the space is
second-countable. -/
theorem countable_setOf_covBy_left [SecondCountableTopology Œ±] :
    Set.Countable { x : Œ± | ‚àÉ y, y ‚ãñ x } := by
  convert countable_setOf_covBy_right (Œ± := Œ±·µí·µà) using 5
  exact toDual_covBy_toDual_iff.symm

/-- The set of points which are isolated on the left is countable when the space is
second-countable. -/
theorem countable_of_isolated_left' [SecondCountableTopology Œ±] :
    Set.Countable { x : Œ± | ‚àÉ y, y < x ‚àß Ioo y x = ‚àÖ } := by
  simpa only [‚Üê covBy_iff_Ioo_eq] using countable_setOf_covBy_left
#align countable_of_isolated_left countable_of_isolated_left'

/-- Consider a disjoint family of intervals `(x, y)` with `x < y` in a second-countable space.
Then the family is countable.
This is not a straightforward consequence of second-countability as some of these intervals might be
empty (but in fact this can happen only for countably many of them). -/
theorem Set.PairwiseDisjoint.countable_of_Ioo [SecondCountableTopology Œ±] {y : Œ± ‚Üí Œ±} {s : Set Œ±}
    (h : PairwiseDisjoint s fun x => Ioo x (y x)) (h' : ‚àÄ x ‚àà s, x < y x) : s.Countable :=
  have : (s \ { x | ‚àÉ y, x ‚ãñ y }).Countable :=
    (h.subset diff_subset).countable_of_isOpen (fun _ _ => isOpen_Ioo)
      fun x hx => (h' _ hx.1).exists_lt_lt (mt (Exists.intro (y x)) hx.2)
  this.of_diff countable_setOf_covBy_right
#align set.pairwise_disjoint.countable_of_Ioo Set.PairwiseDisjoint.countable_of_Ioo

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(x, ‚àû)` is separated above from `f x` is countable. -/
theorem countable_image_lt_image_Ioi [LinearOrder Œ≤] (f : Œ≤ ‚Üí Œ±) [SecondCountableTopology Œ±] :
    Set.Countable {x | ‚àÉ z, f x < z ‚àß ‚àÄ y, x < y ‚Üí z ‚â§ f y} := by
  /- If the values of `f` are separated above on the right of `x`, there is an interval `(f x, z x)`
    which is not reached by `f`. This gives a family of disjoint open intervals in `Œ±`. Such a
    family can only be countable as `Œ±` is second-countable. -/
  nontriviality Œ≤
  have : Nonempty Œ± := Nonempty.map f (by infer_instance)
  let s := {x | ‚àÉ z, f x < z ‚àß ‚àÄ y, x < y ‚Üí z ‚â§ f y}
  have : ‚àÄ x, x ‚àà s ‚Üí ‚àÉ z, f x < z ‚àß ‚àÄ y, x < y ‚Üí z ‚â§ f y := fun x hx ‚Ü¶ hx
  -- choose `z x` such that `f` does not take the values in `(f x, z x)`.
  choose! z hz using this
  have I : InjOn f s := by
    apply StrictMonoOn.injOn
    intro x hx y _ hxy
    calc
      f x < z x := (hz x hx).1
      _ ‚â§ f y := (hz x hx).2 y hxy
  -- show that `f s` is countable by arguing that a disjoint family of disjoint open intervals
  -- (the intervals `(f x, z x)`) is at most countable.
  have fs_count : (f '' s).Countable := by
    have A : (f '' s).PairwiseDisjoint fun x => Ioo x (z (invFunOn f s x)) := by
      rintro _ ‚ü®u, us, rfl‚ü© _ ‚ü®v, vs, rfl‚ü© huv
      wlog hle : u ‚â§ v generalizing u v
      ¬∑ exact (this v vs u us huv.symm (le_of_not_le hle)).symm
      have hlt : u < v := hle.lt_of_ne (ne_of_apply_ne _ huv)
      apply disjoint_iff_forall_ne.2
      rintro a ha b hb rfl
      simp only [I.leftInvOn_invFunOn us, I.leftInvOn_invFunOn vs] at ha hb
      exact lt_irrefl _ ((ha.2.trans_le ((hz u us).2 v hlt)).trans hb.1)
    apply Set.PairwiseDisjoint.countable_of_Ioo A
    rintro _ ‚ü®y, ys, rfl‚ü©
    simpa only [I.leftInvOn_invFunOn ys] using (hz y ys).1
  exact MapsTo.countable_of_injOn (mapsTo_image f s) I fs_count

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(x, ‚àû)` is separated below from `f x` is countable. -/
theorem countable_image_gt_image_Ioi [LinearOrder Œ≤] (f : Œ≤ ‚Üí Œ±) [SecondCountableTopology Œ±] :
    Set.Countable {x | ‚àÉ z, z < f x ‚àß ‚àÄ y, x < y ‚Üí f y ‚â§ z} :=
  countable_image_lt_image_Ioi (Œ± := Œ±·µí·µà) f

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(-‚àû, x)` is separated above from `f x` is countable. -/
theorem countable_image_lt_image_Iio [LinearOrder Œ≤] (f : Œ≤ ‚Üí Œ±) [SecondCountableTopology Œ±] :
    Set.Countable {x | ‚àÉ z, f x < z ‚àß ‚àÄ y, y < x ‚Üí z ‚â§ f y} :=
  countable_image_lt_image_Ioi (Œ≤ := Œ≤·µí·µà) f

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(-‚àû, x)` is separated below from `f x` is countable. -/
theorem countable_image_gt_image_Iio [LinearOrder Œ≤] (f : Œ≤ ‚Üí Œ±) [SecondCountableTopology Œ±] :
    Set.Countable {x | ‚àÉ z, z < f x ‚àß ‚àÄ y, y < x ‚Üí f y ‚â§ z} :=
  countable_image_lt_image_Ioi (Œ± := Œ±·µí·µà) (Œ≤ := Œ≤·µí·µà) f

instance instIsCountablyGenerated_atTop [SecondCountableTopology Œ±] :
    IsCountablyGenerated (atTop : Filter Œ±) := by
  by_cases h : ‚àÉ (x : Œ±), IsTop x
  ¬∑ rcases h with ‚ü®x, hx‚ü©
    rw [atTop_eq_pure_of_isTop hx]
    exact isCountablyGenerated_pure x
  ¬∑ rcases exists_countable_basis Œ± with ‚ü®b, b_count, b_ne, hb‚ü©
    have : Countable b := by exact Iff.mpr countable_coe_iff b_count
    have A : ‚àÄ (s : b), ‚àÉ (x : Œ±), x ‚àà (s : Set Œ±) := by
      intro s
      have : (s : Set Œ±) ‚â† ‚àÖ := by
        intro H
        apply b_ne
        convert s.2
        exact H.symm
      exact Iff.mp nmem_singleton_empty this
    choose a ha using A
    have : (atTop : Filter Œ±) = (generate (Ici '' (range a))) := by
      apply atTop_eq_generate_of_not_bddAbove
      intro ‚ü®x, hx‚ü©
      simp only [IsTop, not_exists, not_forall, not_le] at h
      rcases h x with ‚ü®y, hy‚ü©
      obtain ‚ü®s, sb, -, hs‚ü© : ‚àÉ s, s ‚àà b ‚àß y ‚àà s ‚àß s ‚äÜ Ioi x :=
        hb.exists_subset_of_mem_open hy isOpen_Ioi
      have I : a ‚ü®s, sb‚ü© ‚â§ x := hx (mem_range_self _)
      have J : x < a ‚ü®s, sb‚ü© := hs (ha ‚ü®s, sb‚ü©)
      exact lt_irrefl _ (I.trans_lt J)
    rw [this]
    exact ‚ü®_, (countable_range _).image _, rfl‚ü©

instance instIsCountablyGenerated_atBot [SecondCountableTopology Œ±] :
    IsCountablyGenerated (atBot : Filter Œ±) :=
  @instIsCountablyGenerated_atTop Œ±·µí·µà _ _ _ _

section Pi

/-!
### Intervals in `Œ† i, œÄ i` belong to `ùìù x`

For each lemma `pi_Ixx_mem_nhds` we add a non-dependent version `pi_Ixx_mem_nhds'` because
sometimes Lean fails to unify different instances while trying to apply the dependent version to,
e.g., `Œπ ‚Üí ‚Ñù`.
-/

variable {Œπ : Type*} {œÄ : Œπ ‚Üí Type*} [Finite Œπ] [‚àÄ i, LinearOrder (œÄ i)]
  [‚àÄ i, TopologicalSpace (œÄ i)] [‚àÄ i, OrderTopology (œÄ i)] {a b x : ‚àÄ i, œÄ i} {a' b' x' : Œπ ‚Üí Œ±}

theorem pi_Iic_mem_nhds (ha : ‚àÄ i, x i < a i) : Iic a ‚àà ùìù x :=
  pi_univ_Iic a ‚ñ∏ set_pi_mem_nhds (Set.toFinite _) fun _ _ => Iic_mem_nhds (ha _)
#align pi_Iic_mem_nhds pi_Iic_mem_nhds

theorem pi_Iic_mem_nhds' (ha : ‚àÄ i, x' i < a' i) : Iic a' ‚àà ùìù x' :=
  pi_Iic_mem_nhds ha
#align pi_Iic_mem_nhds' pi_Iic_mem_nhds'

theorem pi_Ici_mem_nhds (ha : ‚àÄ i, a i < x i) : Ici a ‚àà ùìù x :=
  pi_univ_Ici a ‚ñ∏ set_pi_mem_nhds (Set.toFinite _) fun _ _ => Ici_mem_nhds (ha _)
#align pi_Ici_mem_nhds pi_Ici_mem_nhds

theorem pi_Ici_mem_nhds' (ha : ‚àÄ i, a' i < x' i) : Ici a' ‚àà ùìù x' :=
  pi_Ici_mem_nhds ha
#align pi_Ici_mem_nhds' pi_Ici_mem_nhds'

theorem pi_Icc_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Icc a b ‚àà ùìù x :=
  pi_univ_Icc a b ‚ñ∏ set_pi_mem_nhds finite_univ fun _ _ => Icc_mem_nhds (ha _) (hb _)
#align pi_Icc_mem_nhds pi_Icc_mem_nhds

theorem pi_Icc_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Icc a' b' ‚àà ùìù x' :=
  pi_Icc_mem_nhds ha hb
#align pi_Icc_mem_nhds' pi_Icc_mem_nhds'

variable [Nonempty Œπ]

theorem pi_Iio_mem_nhds (ha : ‚àÄ i, x i < a i) : Iio a ‚àà ùìù x := by
  refine mem_of_superset (set_pi_mem_nhds Set.finite_univ fun i _ => ?_) (pi_univ_Iio_subset a)
  exact Iio_mem_nhds (ha i)
#align pi_Iio_mem_nhds pi_Iio_mem_nhds

theorem pi_Iio_mem_nhds' (ha : ‚àÄ i, x' i < a' i) : Iio a' ‚àà ùìù x' :=
  pi_Iio_mem_nhds ha
#align pi_Iio_mem_nhds' pi_Iio_mem_nhds'

theorem pi_Ioi_mem_nhds (ha : ‚àÄ i, a i < x i) : Ioi a ‚àà ùìù x :=
  @pi_Iio_mem_nhds Œπ (fun i => (œÄ i)·µí·µà) _ _ _ _ _ _ _ ha
#align pi_Ioi_mem_nhds pi_Ioi_mem_nhds

theorem pi_Ioi_mem_nhds' (ha : ‚àÄ i, a' i < x' i) : Ioi a' ‚àà ùìù x' :=
  pi_Ioi_mem_nhds ha
#align pi_Ioi_mem_nhds' pi_Ioi_mem_nhds'

theorem pi_Ioc_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ioc a b ‚àà ùìù x := by
  refine mem_of_superset (set_pi_mem_nhds Set.finite_univ fun i _ => ?_) (pi_univ_Ioc_subset a b)
  exact Ioc_mem_nhds (ha i) (hb i)
#align pi_Ioc_mem_nhds pi_Ioc_mem_nhds

theorem pi_Ioc_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ioc a' b' ‚àà ùìù x' :=
  pi_Ioc_mem_nhds ha hb
#align pi_Ioc_mem_nhds' pi_Ioc_mem_nhds'

theorem pi_Ico_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ico a b ‚àà ùìù x := by
  refine mem_of_superset (set_pi_mem_nhds Set.finite_univ fun i _ => ?_) (pi_univ_Ico_subset a b)
  exact Ico_mem_nhds (ha i) (hb i)
#align pi_Ico_mem_nhds pi_Ico_mem_nhds

theorem pi_Ico_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ico a' b' ‚àà ùìù x' :=
  pi_Ico_mem_nhds ha hb
#align pi_Ico_mem_nhds' pi_Ico_mem_nhds'

theorem pi_Ioo_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ioo a b ‚àà ùìù x := by
  refine mem_of_superset (set_pi_mem_nhds Set.finite_univ fun i _ => ?_) (pi_univ_Ioo_subset a b)
  exact Ioo_mem_nhds (ha i) (hb i)
#align pi_Ioo_mem_nhds pi_Ioo_mem_nhds

theorem pi_Ioo_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ioo a' b' ‚àà ùìù x' :=
  pi_Ioo_mem_nhds ha hb
#align pi_Ioo_mem_nhds' pi_Ioo_mem_nhds'

end Pi

end OrderTopology
