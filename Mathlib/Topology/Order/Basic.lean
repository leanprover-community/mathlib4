/-
Copyright (c) 2017 Johannes HÃ¶lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes HÃ¶lzl, Mario Carneiro, Yury Kudryashov
-/
module

public import Mathlib.Order.Filter.Interval
public import Mathlib.Order.Interval.Set.Pi
public import Mathlib.Order.OrdContinuous
public import Mathlib.Tactic.TFAE
public import Mathlib.Tactic.NormNum
public import Mathlib.Topology.Order.LeftRight
public import Mathlib.Topology.Order.OrderClosed

/-!
# Theory of topology on ordered spaces

## Main definitions

The order topology on an ordered space is the topology generated by all open intervals (or
equivalently by those of the form `(-âˆ, a)` and `(b, +âˆ)`). We define it as `Preorder.topology Î±`.
However, we do *not* register it as an instance (as many existing ordered types already have
topologies, which would be equal but not definitionally equal to `Preorder.topology Î±`). Instead,
we introduce a class `OrderTopology Î±` (which is a `Prop`, also known as a mixin) saying that on
the type `Î±` having already a topological space structure and a preorder structure, the topological
structure is equal to the order topology.

We prove many basic properties of such topologies.

## Main statements

This file contains the proofs of the following facts. For exact requirements
(`OrderClosedTopology` vs `OrderTopology`, `Preorder` vs `PartialOrder` vs `LinearOrder` etc)
see their statements.

* `exists_Ioc_subset_of_mem_nhds`, `exists_Ico_subset_of_mem_nhds` : if `x < y`, then any
  neighborhood of `x` includes an interval `[x, z)` for some `z âˆˆ (x, y]`, and any neighborhood
  of `y` includes an interval `(z, y]` for some `z âˆˆ [x, y)`.
* `tendsto_of_tendsto_of_tendsto_of_le_of_le` : theorem known as squeeze theorem,
  sandwich theorem, theorem of Carabinieri, and two policemen (and a drunk) theorem; if `g` and `h`
  both converge to `a`, and eventually `g x â‰¤ f x â‰¤ h x`, then `f` converges to `a`.

## Implementation notes

We do _not_ register the order topology as an instance on a preorder (or even on a linear order).
Indeed, on many such spaces, a topology has already been constructed in a different way (think
of the discrete spaces `â„•` or `â„¤`, or `â„` that could inherit a topology as the completion of `â„š`),
and is in general not defeq to the one generated by the intervals. We make it available as a
definition `Preorder.topology Î±` though, that can be registered as an instance when necessary, or
for specific types.
-/

@[expose] public section


open Set Filter TopologicalSpace Topology Function

open OrderDual (toDual ofDual)

universe u v w

variable {Î± : Type u} {Î² : Type v} {Î³ : Type w}

-- TODO: define `Preorder.topology` before `OrderTopology` and reuse the def
/-- The order topology on an ordered type is the topology generated by open intervals. We register
it on a preorder, but it is mostly interesting in linear orders, where it is also order-closed.
We define it as a mixin. If you want to introduce the order topology on a preorder, use
`Preorder.topology`. -/
class OrderTopology (Î± : Type*) [t : TopologicalSpace Î±] [Preorder Î±] : Prop where
  /-- The topology is generated by open intervals `Set.Ioi _` and `Set.Iio _`. -/
  topology_eq_generate_intervals : t = generateFrom { s | âˆƒ a, s = Ioi a âˆ¨ s = Iio a }

/-- (Order) topology on a partial order `Î±` generated by the subbase of open intervals
`(a, âˆ) = { x âˆ£ a < x }, (-âˆ, b) = {x âˆ£ x < b}` for all `a, b` in `Î±`. We do not register it as an
instance as many ordered sets are already endowed with the same topology, most often in a non-defeq
way though. Register as a local instance when necessary. -/
def Preorder.topology (Î± : Type*) [Preorder Î±] : TopologicalSpace Î± :=
  generateFrom { s : Set Î± | âˆƒ a : Î±, s = { b : Î± | a < b } âˆ¨ s = { b : Î± | b < a } }

section Preorder

variable [ts : TopologicalSpace Î±] [Preorder Î±]

/-- A countable preordered set equipped with the order topology is second countable. -/
instance (priority := 100) [OrderTopology Î±] [Countable Î±] :
    SecondCountableTopology Î± := by
  refine âŸ¨{ s : Set Î± | âˆƒ a, s = Ioi a âˆ¨ s = Iio a }, ?_, ?_âŸ©
  Â· let f1 : Î± â†’ Set Î± := fun a => Ioi a
    let f2 : Î± â†’ Set Î± := fun a => Iio a
    exact Countable.mono (fun s hs => by grind) ((countable_range f1).union (countable_range f2))
  Â· simp [OrderTopology.topology_eq_generate_intervals]

instance [t : OrderTopology Î±] : OrderTopology Î±áµ’áµˆ :=
  âŸ¨by
    convert OrderTopology.topology_eq_generate_intervals (Î± := Î±) using 6
    apply or_commâŸ©

protected theorem OrderTopology.continuous_iff [OrderTopology Î±] [TopologicalSpace Î²] {f : Î² â†’ Î±} :
    Continuous f â†” âˆ€ a, IsOpen (f â»Â¹' Ioi a) âˆ§ IsOpen (f â»Â¹' Iio a) := by
  simp_rw [OrderTopology.topology_eq_generate_intervals, continuous_generateFrom_iff]
  aesop

theorem isOpen_iff_generate_intervals [t : OrderTopology Î±] {s : Set Î±} :
    IsOpen s â†” GenerateOpen { s | âˆƒ a, s = Ioi a âˆ¨ s = Iio a } s := by
  rw [t.topology_eq_generate_intervals]; rfl

theorem isOpen_lt' [OrderTopology Î±] (a : Î±) : IsOpen { b : Î± | a < b } :=
  isOpen_iff_generate_intervals.2 <| .basic _ âŸ¨a, .inl rflâŸ©

theorem isOpen_Ioi' [OrderTopology Î±] (a : Î±) : IsOpen (Ioi a) := isOpen_lt' a

theorem isOpen_gt' [OrderTopology Î±] (a : Î±) : IsOpen { b : Î± | b < a } :=
  isOpen_iff_generate_intervals.2 <| .basic _ âŸ¨a, .inr rflâŸ©

theorem isOpen_Iio' [OrderTopology Î±] (a : Î±) : IsOpen (Iio a) := isOpen_gt' a

theorem lt_mem_nhds [OrderTopology Î±] {a b : Î±} (h : a < b) : âˆ€á¶  x in ğ“ b, a < x :=
  (isOpen_lt' _).mem_nhds h

theorem le_mem_nhds [OrderTopology Î±] {a b : Î±} (h : a < b) : âˆ€á¶  x in ğ“ b, a â‰¤ x :=
  (lt_mem_nhds h).mono fun _ => le_of_lt

theorem gt_mem_nhds [OrderTopology Î±] {a b : Î±} (h : a < b) : âˆ€á¶  x in ğ“ a, x < b :=
  (isOpen_gt' _).mem_nhds h

theorem ge_mem_nhds [OrderTopology Î±] {a b : Î±} (h : a < b) : âˆ€á¶  x in ğ“ a, x â‰¤ b :=
  (gt_mem_nhds h).mono fun _ => le_of_lt

theorem nhds_eq_order [OrderTopology Î±] (a : Î±) :
    ğ“ a = (â¨… b âˆˆ Iio a, ğ“Ÿ (Ioi b)) âŠ“ â¨… b âˆˆ Ioi a, ğ“Ÿ (Iio b) := by
  rw [OrderTopology.topology_eq_generate_intervals (Î± := Î±), nhds_generateFrom]
  simp_rw [mem_setOf_eq, @and_comm (a âˆˆ _), exists_or, or_and_right, iInf_or, iInf_and,
    iInf_exists, iInf_inf_eq, iInf_comm (Î¹ := Set Î±), iInf_iInf_eq_left, mem_Ioi, mem_Iio]

theorem tendsto_order [OrderTopology Î±] {f : Î² â†’ Î±} {a : Î±} {x : Filter Î²} :
    Tendsto f x (ğ“ a) â†” (âˆ€ a' < a, âˆ€á¶  b in x, a' < f b) âˆ§ âˆ€ a' > a, âˆ€á¶  b in x, f b < a' := by
  simp only [nhds_eq_order a, tendsto_inf, tendsto_iInf, tendsto_principal]; rfl
instance tendstoIccClassNhds [OrderTopology Î±] (a : Î±) : TendstoIxxClass Icc (ğ“ a) (ğ“ a) := by
  simp only [nhds_eq_order, iInf_subtype']
  refine
    ((hasBasis_iInf_principal_finite _).inf (hasBasis_iInf_principal_finite _)).tendstoIxxClass
      fun s _ => ?_
  refine ((ordConnected_biInter ?_).inter (ordConnected_biInter ?_)).out <;> intro _ _
  exacts [ordConnected_Ioi, ordConnected_Iio]

instance tendstoIcoClassNhds [OrderTopology Î±] (a : Î±) : TendstoIxxClass Ico (ğ“ a) (ğ“ a) :=
  tendstoIxxClass_of_subset fun _ _ => Ico_subset_Icc_self

instance tendstoIocClassNhds [OrderTopology Î±] (a : Î±) : TendstoIxxClass Ioc (ğ“ a) (ğ“ a) :=
  tendstoIxxClass_of_subset fun _ _ => Ioc_subset_Icc_self

instance tendstoIooClassNhds [OrderTopology Î±] (a : Î±) : TendstoIxxClass Ioo (ğ“ a) (ğ“ a) :=
  tendstoIxxClass_of_subset fun _ _ => Ioo_subset_Icc_self

variable (Î±) in
/-- In a second countable topological space with the order topology, the topology is generated
by half-infinite open intervals with endpoints in a countable set. -/
lemma exists_countable_generateFrom_Ioi_Iio
    [OrderTopology Î±] [SecondCountableTopology Î±] :
    âˆƒ (c : Set Î±), c.Countable âˆ§ ts = generateFrom { s | âˆƒ a âˆˆ c, s = Ioi a âˆ¨ s = Iio a } := by
  rcases isEmpty_or_nonempty Î± with hÎ± | hÎ±
  Â· exact âŸ¨âˆ…, by simp, Subsingleton.elim _ _âŸ©
  obtain âŸ¨t, t_subs, t_count, htâŸ© : âˆƒ t âŠ† { s | âˆƒ a, s = Ioi a âˆ¨ s = Iio a },
      t.Countable âˆ§ ts = generateFrom t :=
    exists_countable_of_generateFrom OrderTopology.topology_eq_generate_intervals
  have A : âˆ€ s âˆˆ t, âˆƒ a, s = Ioi a âˆ¨ s = Iio a := t_subs
  choose! a ha using A
  refine âŸ¨a '' t, t_count.image _, ?_âŸ©
  apply le_antisymm
  Â· apply le_generateFrom_iff_subset_isOpen.2
    simp only [mem_image, exists_exists_and_eq_and, setOf_subset_setOf, forall_exists_index,
      and_imp]
    grind [isOpen_Iio', isOpen_Ioi']
  Â· rw [ht]
    apply generateFrom_anti
    grind

/-- If a topology is generated by half-open intervals with endpoints in a set `c`, then the sets
formed by intersecting finitely many of these intervals form a topological basis. -/
lemma isTopologicalBasis_biInter_Ioi_Iio_of_generateFrom (c : Set Î±)
    (h : ts = generateFrom { s | âˆƒ a âˆˆ c, s = Ioi a âˆ¨ s = Iio a }) :
    IsTopologicalBasis {s | âˆƒ (f g : Set Î±), f âŠ† c âˆ§ g âŠ† c âˆ§ f.Finite âˆ§ g.Finite
      âˆ§ s = (â‹‚ a âˆˆ f, Ioi a) âˆ© (â‹‚ a âˆˆ g, Iio a)} := by
  refine IsTopologicalBasis.of_isOpen_of_subset ?_ (isTopologicalBasis_of_subbasis h) ?_
  Â· rintro u âŸ¨f, g, hfc, hgc, hf_fin, hg_fin, rflâŸ©
    apply IsOpen.inter
    Â· apply hf_fin.isOpen_biInter (fun i hi â†¦ ?_)
      rw [h]
      exact isOpen_generateFrom_of_mem âŸ¨i, hfc hi, Or.inl rflâŸ©
    Â· apply hg_fin.isOpen_biInter (fun i hi â†¦ ?_)
      rw [h]
      exact isOpen_generateFrom_of_mem âŸ¨i, hgc hi, Or.inr rflâŸ©
  simp only [exists_and_left, image_subset_iff, preimage_setOf_eq, setOf_subset_setOf, and_imp]
  intro k k_fin hk
  let kl := {s âˆˆ k | âˆƒ a âˆˆ c, s = Ioi a}
  let kr := {s âˆˆ k | âˆƒ a âˆˆ c, s = Iio a}
  have k_eq : k = kl âˆª kr := by
    have : âˆ€ s âˆˆ k, âˆƒ a âˆˆ c, s = Ioi a âˆ¨ s = Iio a := hk
    ext
    simp only [mem_union, mem_setOf_eq, kl, kr]
    grind
  have : Finite kl := k_fin.subset (by simp [k_eq])
  have : Finite kr := k_fin.subset (by simp [k_eq])
  have Al : âˆ€ s : kl, âˆƒ a âˆˆ c, s = Ioi a := fun s â†¦ s.2.2
  choose al alc hal using Al
  have Ar : âˆ€ s : kr, âˆƒ a âˆˆ c, s = Iio a := fun s â†¦ s.2.2
  choose ar arc har using Ar
  refine âŸ¨range al, by simp [range_subset_iff, alc], range ar,
    by simp [range_subset_iff, arc], finite_range _, finite_range _, ?_âŸ©
  rw [k_eq, sInter_eq_biInter, biInter_union, biInter_range, biInter_range, biInter_eq_iInter,
    biInter_eq_iInter]
  simp [hal, har]

/-- **Squeeze theorem** (also known as **sandwich theorem**). This version assumes that inequalities
hold eventually for the filter. -/
theorem tendsto_of_tendsto_of_tendsto_of_le_of_le' [OrderTopology Î±] {f g h : Î² â†’ Î±} {b : Filter Î²}
    {a : Î±} (hg : Tendsto g b (ğ“ a)) (hh : Tendsto h b (ğ“ a)) (hgf : âˆ€á¶  b in b, g b â‰¤ f b)
    (hfh : âˆ€á¶  b in b, f b â‰¤ h b) : Tendsto f b (ğ“ a) :=
  (hg.Icc hh).of_smallSets <| hgf.and hfh

alias Filter.Tendsto.squeeze' := tendsto_of_tendsto_of_tendsto_of_le_of_le'

/-- **Squeeze theorem** (also known as **sandwich theorem**). This version assumes that inequalities
hold everywhere. -/
theorem tendsto_of_tendsto_of_tendsto_of_le_of_le [OrderTopology Î±] {f g h : Î² â†’ Î±} {b : Filter Î²}
    {a : Î±} (hg : Tendsto g b (ğ“ a)) (hh : Tendsto h b (ğ“ a)) (hgf : g â‰¤ f) (hfh : f â‰¤ h) :
    Tendsto f b (ğ“ a) :=
  tendsto_of_tendsto_of_tendsto_of_le_of_le' hg hh (Eventually.of_forall hgf)
    (Eventually.of_forall hfh)

alias Filter.Tendsto.squeeze := tendsto_of_tendsto_of_tendsto_of_le_of_le

theorem nhds_order_unbounded [OrderTopology Î±] {a : Î±} (hu : âˆƒ u, a < u) (hl : âˆƒ l, l < a) :
    ğ“ a = â¨… (l) (_ : l < a) (u) (_ : a < u), ğ“Ÿ (Ioo l u) := by
  simp only [nhds_eq_order, â† inf_biInf, â† biInf_inf, *, â† inf_principal, â† Ioi_inter_Iio]; rfl

theorem tendsto_order_unbounded [OrderTopology Î±] {f : Î² â†’ Î±} {a : Î±} {x : Filter Î²}
    (hu : âˆƒ u, a < u) (hl : âˆƒ l, l < a) (h : âˆ€ l u, l < a â†’ a < u â†’ âˆ€á¶  b in x, l < f b âˆ§ f b < u) :
    Tendsto f x (ğ“ a) := by
  simp only [nhds_order_unbounded hu hl, tendsto_iInf, tendsto_principal]
  exact fun l hl u => h l u hl

end Preorder

instance tendstoIxxNhdsWithin {Î± : Type*} [TopologicalSpace Î±] (a : Î±) {s t : Set Î±}
    {Ixx} [TendstoIxxClass Ixx (ğ“ a) (ğ“ a)] [TendstoIxxClass Ixx (ğ“Ÿ s) (ğ“Ÿ t)] :
    TendstoIxxClass Ixx (ğ“[s] a) (ğ“[t] a) :=
  Filter.tendstoIxxClass_inf

instance tendstoIccClassNhdsPi {Î¹ : Type*} {Î± : Î¹ â†’ Type*} [âˆ€ i, Preorder (Î± i)]
    [âˆ€ i, TopologicalSpace (Î± i)] [âˆ€ i, OrderTopology (Î± i)] (f : âˆ€ i, Î± i) :
    TendstoIxxClass Icc (ğ“ f) (ğ“ f) := by
  constructor
  conv in (ğ“ f).smallSets => rw [nhds_pi, Filter.pi]
  simp only [smallSets_iInf, smallSets_comap_eq_comap_image, tendsto_iInf, tendsto_comap_iff]
  intro i
  have : Tendsto (fun g : âˆ€ i, Î± i => g i) (ğ“ f) (ğ“ (f i)) := (continuous_apply i).tendsto f
  refine (this.comp tendsto_fst).Icc (this.comp tendsto_snd) |>.smallSets_mono ?_
  filter_upwards [] using fun âŸ¨f, gâŸ© â†¦ image_subset_iff.mpr fun p hp â†¦ âŸ¨hp.1 i, hp.2 iâŸ©

theorem induced_topology_le_preorder [Preorder Î±] [Preorder Î²] [TopologicalSpace Î²]
    [OrderTopology Î²] {f : Î± â†’ Î²} (hf : âˆ€ {x y}, f x < f y â†” x < y) :
    induced f â€¹TopologicalSpace Î²â€º â‰¤ Preorder.topology Î± := by
  let _ := Preorder.topology Î±; have : OrderTopology Î± := âŸ¨rflâŸ©
  refine le_of_nhds_le_nhds fun x => ?_
  simp only [nhds_eq_order, nhds_induced, comap_inf, comap_iInf, comap_principal, Ioi, Iio, â† hf]
  refine inf_le_inf (le_iInfâ‚‚ fun a ha => ?_) (le_iInfâ‚‚ fun a ha => ?_)
  exacts [iInfâ‚‚_le (f a) ha, iInfâ‚‚_le (f a) ha]

theorem induced_topology_eq_preorder [Preorder Î±] [Preorder Î²] [TopologicalSpace Î²]
    [OrderTopology Î²] {f : Î± â†’ Î²} (hf : âˆ€ {x y}, f x < f y â†” x < y)
    (Hâ‚ : âˆ€ {a b x}, b < f a â†’ Â¬(b < f x) â†’ âˆƒ y, y < a âˆ§ b â‰¤ f y)
    (Hâ‚‚ : âˆ€ {a b x}, f a < b â†’ Â¬(f x < b) â†’ âˆƒ y, a < y âˆ§ f y â‰¤ b) :
    induced f â€¹TopologicalSpace Î²â€º = Preorder.topology Î± := by
  let _ := Preorder.topology Î±; have : OrderTopology Î± := âŸ¨rflâŸ©
  refine le_antisymm (induced_topology_le_preorder hf) ?_
  refine le_of_nhds_le_nhds fun a => ?_
  simp only [nhds_eq_order, nhds_induced, comap_inf, comap_iInf, comap_principal]
  refine inf_le_inf (le_iInfâ‚‚ fun b hb => ?_) (le_iInfâ‚‚ fun b hb => ?_)
  Â· by_cases! h : âˆƒ x, Â¬(b < f x)
    Â· rcases h with âŸ¨x, hxâŸ©
      rcases Hâ‚ hb hx with âŸ¨y, hya, hybâŸ©
      exact iInfâ‚‚_le_of_le y hya (principal_mono.2 fun z hz => hyb.trans_lt (hf.2 hz))
    Â· exact le_principal_iff.2 (univ_mem' h)
  Â· by_cases! h : âˆƒ x, Â¬(f x < b)
    Â· rcases h with âŸ¨x, hxâŸ©
      rcases Hâ‚‚ hb hx with âŸ¨y, hya, hybâŸ©
      exact iInfâ‚‚_le_of_le y hya (principal_mono.2 fun z hz => (hf.2 hz).trans_le hyb)
    Â· exact le_principal_iff.2 (univ_mem' h)

theorem induced_orderTopology' {Î± : Type u} {Î² : Type v} [Preorder Î±] [ta : TopologicalSpace Î²]
    [Preorder Î²] [OrderTopology Î²] (f : Î± â†’ Î²) (hf : âˆ€ {x y}, f x < f y â†” x < y)
    (Hâ‚ : âˆ€ {a x}, x < f a â†’ âˆƒ b < a, x â‰¤ f b) (Hâ‚‚ : âˆ€ {a x}, f a < x â†’ âˆƒ b > a, f b â‰¤ x) :
    @OrderTopology _ (induced f ta) _ :=
  let _ := induced f ta
  âŸ¨induced_topology_eq_preorder hf (fun h _ => Hâ‚ h) (fun h _ => Hâ‚‚ h)âŸ©

theorem induced_orderTopology {Î± : Type u} {Î² : Type v} [Preorder Î±] [ta : TopologicalSpace Î²]
    [Preorder Î²] [OrderTopology Î²] (f : Î± â†’ Î²) (hf : âˆ€ {x y}, f x < f y â†” x < y)
    (H : âˆ€ {x y}, x < y â†’ âˆƒ a, x < f a âˆ§ f a < y) : @OrderTopology _ (induced f ta) _ :=
  induced_orderTopology' f (hf)
    (fun xa => let âŸ¨b, xb, baâŸ© := H xa; âŸ¨b, hf.1 ba, le_of_lt xbâŸ©)
    fun ax => let âŸ¨b, ab, bxâŸ© := H ax; âŸ¨b, hf.1 ab, le_of_lt bxâŸ©

/-- The topology induced by a strictly monotone function with order-connected range is the preorder
topology. -/
nonrec theorem StrictMono.induced_topology_eq_preorder {Î± Î² : Type*} [LinearOrder Î±]
    [LinearOrder Î²] [t : TopologicalSpace Î²] [OrderTopology Î²] {f : Î± â†’ Î²}
    (hf : StrictMono f) (hc : OrdConnected (range f)) : t.induced f = Preorder.topology Î± := by
  refine induced_topology_eq_preorder hf.lt_iff_lt (fun hâ‚ hâ‚‚ => ?_) fun hâ‚ hâ‚‚ => ?_
  Â· rcases hc.out (mem_range_self _) (mem_range_self _) âŸ¨not_lt.1 hâ‚‚, hâ‚.leâŸ© with âŸ¨y, rflâŸ©
    exact âŸ¨y, hf.lt_iff_lt.1 hâ‚, le_rflâŸ©
  Â· rcases hc.out (mem_range_self _) (mem_range_self _) âŸ¨hâ‚.le, not_lt.1 hâ‚‚âŸ© with âŸ¨y, rflâŸ©
    exact âŸ¨y, hf.lt_iff_lt.1 hâ‚, le_rflâŸ©

/-- A strictly monotone function between linear orders with order topology is a topological
embedding provided that the range of `f` is order-connected. -/
theorem StrictMono.isEmbedding_of_ordConnected {Î± Î² : Type*} [LinearOrder Î±] [LinearOrder Î²]
    [TopologicalSpace Î±] [h : OrderTopology Î±] [TopologicalSpace Î²] [OrderTopology Î²] {f : Î± â†’ Î²}
    (hf : StrictMono f) (hc : OrdConnected (range f)) : IsEmbedding f :=
  âŸ¨âŸ¨h.1.trans <| Eq.symm <| hf.induced_topology_eq_preorder hcâŸ©, hf.injectiveâŸ©

/-- An `OrderEmbedding` is a topological embedding provided that the range of `f` is
order-connected -/
lemma OrderEmbedding.isEmbedding_of_ordConnected {Î± Î² : Type*} [LinearOrder Î±] [LinearOrder Î²]
    [TopologicalSpace Î±] [OrderTopology Î±] [TopologicalSpace Î²] [OrderTopology Î²]
    (f : Î± â†ªo Î²) (hc : OrdConnected (range f)) : Topology.IsEmbedding f :=
  f.strictMono.isEmbedding_of_ordConnected hc

/-- On a `Set.OrdConnected` subset of a linear order, the order topology for the restriction of the
order is the same as the restriction to the subset of the order topology. -/
instance orderTopology_of_ordConnected {Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±]
    [OrderTopology Î±] {t : Set Î±} [ht : OrdConnected t] : OrderTopology t :=
  âŸ¨(Subtype.strictMono_coe t).induced_topology_eq_preorder <| by
    rwa [â† @Subtype.range_val _ t] at htâŸ©

theorem nhdsGE_eq_iInf_inf_principal [TopologicalSpace Î±] [Preorder Î±] [OrderTopology Î±] (a : Î±) :
    ğ“[â‰¥] a = (â¨… (u) (_ : a < u), ğ“Ÿ (Iio u)) âŠ“ ğ“Ÿ (Ici a) := by
  rw [nhdsWithin, nhds_eq_order]
  refine le_antisymm (inf_le_inf_right _ inf_le_right) (le_inf (le_inf ?_ inf_le_left) inf_le_right)
  exact inf_le_right.trans (le_iInfâ‚‚ fun l hl => principal_mono.2 <| Ici_subset_Ioi.2 hl)

theorem nhdsLE_eq_iInf_inf_principal [TopologicalSpace Î±] [Preorder Î±] [OrderTopology Î±] (a : Î±) :
    ğ“[â‰¤] a = (â¨… l < a, ğ“Ÿ (Ioi l)) âŠ“ ğ“Ÿ (Iic a) :=
  nhdsGE_eq_iInf_inf_principal (toDual a)

theorem nhdsGE_eq_iInf_principal [TopologicalSpace Î±] [Preorder Î±] [OrderTopology Î±] {a : Î±}
    (ha : âˆƒ u, a < u) : ğ“[â‰¥] a = â¨… (u) (_ : a < u), ğ“Ÿ (Ico a u) := by
  simp only [nhdsGE_eq_iInf_inf_principal, biInf_inf ha, inf_principal, Iio_inter_Ici]

theorem nhdsLE_eq_iInf_principal [TopologicalSpace Î±] [Preorder Î±] [OrderTopology Î±] {a : Î±}
    (ha : âˆƒ l, l < a) : ğ“[â‰¤] a = â¨… l < a, ğ“Ÿ (Ioc l a) := by
  simp only [nhdsLE_eq_iInf_inf_principal, biInf_inf ha, inf_principal, Ioi_inter_Iic]

theorem nhdsGE_basis_of_exists_gt [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {a : Î±}
    (ha : âˆƒ u, a < u) : (ğ“[â‰¥] a).HasBasis (fun u => a < u) fun u => Ico a u :=
  (nhdsGE_eq_iInf_principal ha).symm â–¸
    hasBasis_biInf_principal
      (fun b hb c hc => âŸ¨min b c, lt_min hb hc, Ico_subset_Ico_right (min_le_left _ _),
        Ico_subset_Ico_right (min_le_right _ _)âŸ©)
      ha

theorem nhdsLE_basis_of_exists_lt [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {a : Î±}
    (ha : âˆƒ l, l < a) : (ğ“[â‰¤] a).HasBasis (fun l => l < a) fun l => Ioc l a := by
  convert nhdsGE_basis_of_exists_gt (Î± := Î±áµ’áµˆ) ha using 2
  exact Ico_toDual.symm

theorem nhdsGE_basis [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMaxOrder Î±] (a : Î±) :
    (ğ“[â‰¥] a).HasBasis (fun u => a < u) fun u => Ico a u :=
  nhdsGE_basis_of_exists_gt (exists_gt a)

theorem nhdsLE_basis [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMinOrder Î±] (a : Î±) :
    (ğ“[â‰¤] a).HasBasis (fun l => l < a) fun l => Ioc l a :=
  nhdsLE_basis_of_exists_lt (exists_lt a)

theorem nhds_top_order [TopologicalSpace Î±] [Preorder Î±] [OrderTop Î±] [OrderTopology Î±] :
    ğ“ (âŠ¤ : Î±) = â¨… (l) (_ : l < âŠ¤), ğ“Ÿ (Ioi l) := by simp [nhds_eq_order (âŠ¤ : Î±)]

theorem nhds_bot_order [TopologicalSpace Î±] [Preorder Î±] [OrderBot Î±] [OrderTopology Î±] :
    ğ“ (âŠ¥ : Î±) = â¨… (l) (_ : âŠ¥ < l), ğ“Ÿ (Iio l) := by simp [nhds_eq_order (âŠ¥ : Î±)]

theorem nhds_top_basis [TopologicalSpace Î±] [LinearOrder Î±] [OrderTop Î±] [OrderTopology Î±]
    [Nontrivial Î±] : (ğ“ âŠ¤).HasBasis (fun a : Î± => a < âŠ¤) fun a : Î± => Ioi a := by
  have : âˆƒ x : Î±, x < âŠ¤ := (exists_ne âŠ¤).imp fun x hx => hx.lt_top
  simpa only [Iic_top, nhdsWithin_univ, Ioc_top] using nhdsLE_basis_of_exists_lt this

theorem nhds_bot_basis [TopologicalSpace Î±] [LinearOrder Î±] [OrderBot Î±] [OrderTopology Î±]
    [Nontrivial Î±] : (ğ“ âŠ¥).HasBasis (fun a : Î± => âŠ¥ < a) fun a : Î± => Iio a :=
  nhds_top_basis (Î± := Î±áµ’áµˆ)

theorem nhds_top_basis_Ici [TopologicalSpace Î±] [LinearOrder Î±] [OrderTop Î±] [OrderTopology Î±]
    [Nontrivial Î±] [DenselyOrdered Î±] : (ğ“ âŠ¤).HasBasis (fun a : Î± => a < âŠ¤) Ici :=
  nhds_top_basis.to_hasBasis
    (fun _a ha => let âŸ¨b, hab, hbâŸ© := exists_between ha; âŸ¨b, hb, Ici_subset_Ioi.mpr habâŸ©)
    fun a ha => âŸ¨a, ha, Ioi_subset_Ici_selfâŸ©

theorem nhds_bot_basis_Iic [TopologicalSpace Î±] [LinearOrder Î±] [OrderBot Î±] [OrderTopology Î±]
    [Nontrivial Î±] [DenselyOrdered Î±] : (ğ“ âŠ¥).HasBasis (fun a : Î± => âŠ¥ < a) Iic :=
  nhds_top_basis_Ici (Î± := Î±áµ’áµˆ)

theorem tendsto_nhds_top_mono [TopologicalSpace Î²] [Preorder Î²] [OrderTop Î²] [OrderTopology Î²]
    {l : Filter Î±} {f g : Î± â†’ Î²} (hf : Tendsto f l (ğ“ âŠ¤)) (hg : f â‰¤á¶ [l] g) : Tendsto g l (ğ“ âŠ¤) := by
  simp only [nhds_top_order, tendsto_iInf, tendsto_principal] at hf âŠ¢
  intro x hx
  filter_upwards [hf x hx, hg] with _ using lt_of_lt_of_le

theorem tendsto_nhds_bot_mono [TopologicalSpace Î²] [Preorder Î²] [OrderBot Î²] [OrderTopology Î²]
    {l : Filter Î±} {f g : Î± â†’ Î²} (hf : Tendsto f l (ğ“ âŠ¥)) (hg : g â‰¤á¶ [l] f) : Tendsto g l (ğ“ âŠ¥) :=
  tendsto_nhds_top_mono (Î² := Î²áµ’áµˆ) hf hg

theorem tendsto_nhds_top_mono' [TopologicalSpace Î²] [Preorder Î²] [OrderTop Î²] [OrderTopology Î²]
    {l : Filter Î±} {f g : Î± â†’ Î²} (hf : Tendsto f l (ğ“ âŠ¤)) (hg : f â‰¤ g) : Tendsto g l (ğ“ âŠ¤) :=
  tendsto_nhds_top_mono hf (Eventually.of_forall hg)

theorem tendsto_nhds_bot_mono' [TopologicalSpace Î²] [Preorder Î²] [OrderBot Î²] [OrderTopology Î²]
    {l : Filter Î±} {f g : Î± â†’ Î²} (hf : Tendsto f l (ğ“ âŠ¥)) (hg : g â‰¤ f) : Tendsto g l (ğ“ âŠ¥) :=
  tendsto_nhds_bot_mono hf (Eventually.of_forall hg)

section LinearOrder

variable [TopologicalSpace Î±] [LinearOrder Î±]

section OrderTopology
variable [OrderTopology Î±]

theorem order_separated {aâ‚ aâ‚‚ : Î±} (h : aâ‚ < aâ‚‚) :
    âˆƒ u v : Set Î±, IsOpen u âˆ§ IsOpen v âˆ§ aâ‚ âˆˆ u âˆ§ aâ‚‚ âˆˆ v âˆ§ âˆ€ bâ‚ âˆˆ u, âˆ€ bâ‚‚ âˆˆ v, bâ‚ < bâ‚‚ :=
  let âŸ¨x, hx, y, hy, hâŸ© := h.exists_disjoint_Iio_Ioi
  âŸ¨Iio x, Ioi y, isOpen_gt' _, isOpen_lt' _, hx, hy, hâŸ©

-- see Note [lower instance priority]
instance (priority := 100) OrderTopology.to_orderClosedTopology : OrderClosedTopology Î± where
  isClosed_le' := isOpen_compl_iff.1 <| isOpen_prod_iff.mpr fun aâ‚ aâ‚‚ (h : Â¬aâ‚ â‰¤ aâ‚‚) =>
    have h : aâ‚‚ < aâ‚ := lt_of_not_ge h
    let âŸ¨u, v, hu, hv, haâ‚, haâ‚‚, hâŸ© := order_separated h
    âŸ¨v, u, hv, hu, haâ‚‚, haâ‚, fun âŸ¨bâ‚, bâ‚‚âŸ© âŸ¨hâ‚, hâ‚‚âŸ© => not_le_of_gt <| h bâ‚‚ hâ‚‚ bâ‚ hâ‚âŸ©

theorem exists_Ioc_subset_of_mem_nhds {a : Î±} {s : Set Î±} (hs : s âˆˆ ğ“ a) (h : âˆƒ l, l < a) :
    âˆƒ l < a, Ioc l a âŠ† s :=
  (nhdsLE_basis_of_exists_lt h).mem_iff.mp (nhdsWithin_le_nhds hs)

theorem exists_Ioc_subset_of_mem_nhds' {a : Î±} {s : Set Î±} (hs : s âˆˆ ğ“ a) {l : Î±} (hl : l < a) :
    âˆƒ l' âˆˆ Ico l a, Ioc l' a âŠ† s :=
  let âŸ¨l', hl'a, hl'sâŸ© := exists_Ioc_subset_of_mem_nhds hs âŸ¨l, hlâŸ©
  âŸ¨max l l', âŸ¨le_max_left _ _, max_lt hl hl'aâŸ©,
    (Ioc_subset_Ioc_left <| le_max_right _ _).trans hl'sâŸ©

theorem exists_Ico_subset_of_mem_nhds' {a : Î±} {s : Set Î±} (hs : s âˆˆ ğ“ a) {u : Î±} (hu : a < u) :
    âˆƒ u' âˆˆ Ioc a u, Ico a u' âŠ† s := by
  simpa only [OrderDual.exists, exists_prop, Ico_toDual, Ioc_toDual] using
    exists_Ioc_subset_of_mem_nhds' (show ofDual â»Â¹' s âˆˆ ğ“ (toDual a) from hs) hu.dual

theorem exists_Ico_subset_of_mem_nhds {a : Î±} {s : Set Î±} (hs : s âˆˆ ğ“ a) (h : âˆƒ u, a < u) :
    âˆƒ u, a < u âˆ§ Ico a u âŠ† s :=
  let âŸ¨_l', hl'âŸ© := h
  let âŸ¨l, hlâŸ© := exists_Ico_subset_of_mem_nhds' hs hl'
  âŸ¨l, hl.1.1, hl.2âŸ©

theorem exists_Icc_mem_subset_of_mem_nhdsGE {a : Î±} {s : Set Î±} (hs : s âˆˆ ğ“[â‰¥] a) :
    âˆƒ b, a â‰¤ b âˆ§ Icc a b âˆˆ ğ“[â‰¥] a âˆ§ Icc a b âŠ† s := by
  rcases (em (IsMax a)).imp_right not_isMax_iff.mp with (ha | ha)
  Â· use a
    simpa [ha.Ici_eq] using hs
  Â· rcases(nhdsGE_basis_of_exists_gt ha).mem_iff.mp hs with âŸ¨b, hab, hbsâŸ©
    rcases eq_empty_or_nonempty (Ioo a b) with (H | âŸ¨c, hac, hcbâŸ©)
    Â· have : Ico a b = Icc a a := by rw [â† Icc_union_Ioo_eq_Ico le_rfl hab, H, union_empty]
      exact âŸ¨a, le_rfl, this â–¸ âŸ¨Ico_mem_nhdsGE hab, hbsâŸ©âŸ©
    Â· refine âŸ¨c, hac.le, Icc_mem_nhdsGE hac, ?_âŸ©
      exact (Icc_subset_Ico_right hcb).trans hbs

theorem exists_Icc_mem_subset_of_mem_nhdsLE {a : Î±} {s : Set Î±} (hs : s âˆˆ ğ“[â‰¤] a) :
    âˆƒ b â‰¤ a, Icc b a âˆˆ ğ“[â‰¤] a âˆ§ Icc b a âŠ† s := by
  simpa only [Icc_toDual, toDual.surjective.exists] using
    exists_Icc_mem_subset_of_mem_nhdsGE (Î± := Î±áµ’áµˆ) (a := toDual a) hs

theorem exists_Icc_mem_subset_of_mem_nhds {a : Î±} {s : Set Î±} (hs : s âˆˆ ğ“ a) :
    âˆƒ b c, a âˆˆ Icc b c âˆ§ Icc b c âˆˆ ğ“ a âˆ§ Icc b c âŠ† s := by
  rcases exists_Icc_mem_subset_of_mem_nhdsLE (nhdsWithin_le_nhds hs) with
    âŸ¨b, hba, hb_nhds, hbsâŸ©
  rcases exists_Icc_mem_subset_of_mem_nhdsGE (nhdsWithin_le_nhds hs) with
    âŸ¨c, hac, hc_nhds, hcsâŸ©
  refine âŸ¨b, c, âŸ¨hba, hacâŸ©, ?_âŸ©
  rw [â† Icc_union_Icc_eq_Icc hba hac, â† nhdsLE_sup_nhdsGE]
  exact âŸ¨union_mem_sup hb_nhds hc_nhds, union_subset hbs hcsâŸ©

theorem IsOpen.exists_Ioo_subset [Nontrivial Î±] {s : Set Î±} (hs : IsOpen s) (h : s.Nonempty) :
    âˆƒ a b, a < b âˆ§ Ioo a b âŠ† s := by
  obtain âŸ¨x, hxâŸ© : âˆƒ x, x âˆˆ s := h
  obtain âŸ¨y, hyâŸ© : âˆƒ y, y â‰  x := exists_ne x
  rcases lt_trichotomy x y with (H | rfl | H)
  Â· obtain âŸ¨u, xu, huâŸ© : âˆƒ u, x < u âˆ§ Ico x u âŠ† s :=
      exists_Ico_subset_of_mem_nhds (hs.mem_nhds hx) âŸ¨y, HâŸ©
    exact âŸ¨x, u, xu, Ioo_subset_Ico_self.trans huâŸ©
  Â· exact (hy rfl).elim
  Â· obtain âŸ¨l, lx, hlâŸ© : âˆƒ l, l < x âˆ§ Ioc l x âŠ† s :=
      exists_Ioc_subset_of_mem_nhds (hs.mem_nhds hx) âŸ¨y, HâŸ©
    exact âŸ¨l, x, lx, Ioo_subset_Ioc_self.trans hlâŸ©

theorem dense_of_exists_between [Nontrivial Î±] {s : Set Î±}
    (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ âˆƒ c âˆˆ s, a < c âˆ§ c < b) : Dense s := by
  refine dense_iff_inter_open.2 fun U U_open U_nonempty => ?_
  obtain âŸ¨a, b, hab, HâŸ© : âˆƒ a b : Î±, a < b âˆ§ Ioo a b âŠ† U := U_open.exists_Ioo_subset U_nonempty
  obtain âŸ¨x, xs, hxâŸ© : âˆƒ x âˆˆ s, a < x âˆ§ x < b := h hab
  exact âŸ¨x, âŸ¨H hx, xsâŸ©âŸ©

theorem IsUpperSet.isClosed [WellFoundedLT Î±] {s : Set Î±} (h : IsUpperSet s) : IsClosed s := by
  obtain rfl | âŸ¨a, rflâŸ© := h.eq_empty_or_Ici
  exacts [isClosed_empty, isClosed_Ici]

theorem IsLowerSet.isClosed [WellFoundedGT Î±] {s : Set Î±} (h : IsLowerSet s) : IsClosed s :=
  h.toDual.isClosed

theorem IsLowerSet.isOpen [WellFoundedLT Î±] {s : Set Î±} (h : IsLowerSet s) : IsOpen s := by
  simpa using h.compl.isClosed

theorem IsUpperSet.isOpen [WellFoundedGT Î±] {s : Set Î±} (h : IsUpperSet s) : IsOpen s :=
  h.toDual.isOpen

/-- A set in a nontrivial densely linear ordered type is dense in the sense of topology if and only
if for any `a < b` there exists `c âˆˆ s`, `a < c < b`. Each implication requires less typeclass
assumptions. -/
theorem dense_iff_exists_between [DenselyOrdered Î±] [Nontrivial Î±] {s : Set Î±} :
    Dense s â†” âˆ€ a b, a < b â†’ âˆƒ c âˆˆ s, a < c âˆ§ c < b :=
  âŸ¨fun h _ _ hab => h.exists_between hab, dense_of_exists_betweenâŸ©

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`,
provided `a` is neither a bottom element nor a top element. -/
theorem mem_nhds_iff_exists_Ioo_subset' {a : Î±} {s : Set Î±} (hl : âˆƒ l, l < a)
    (hu : âˆƒ u, a < u) : s âˆˆ ğ“ a â†” âˆƒ l u, a âˆˆ Ioo l u âˆ§ Ioo l u âŠ† s := by
  constructor
  Â· intro h
    rcases exists_Ico_subset_of_mem_nhds h hu with âŸ¨u, au, huâŸ©
    rcases exists_Ioc_subset_of_mem_nhds h hl with âŸ¨l, la, hlâŸ©
    exact âŸ¨l, u, âŸ¨la, auâŸ©, Ioc_union_Ico_eq_Ioo la au â–¸ union_subset hl huâŸ©
  Â· rintro âŸ¨l, u, ha, hâŸ©
    apply mem_of_superset (Ioo_mem_nhds ha.1 ha.2) h

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`.
-/
theorem mem_nhds_iff_exists_Ioo_subset [NoMaxOrder Î±] [NoMinOrder Î±] {a : Î±}
    {s : Set Î±} : s âˆˆ ğ“ a â†” âˆƒ l u, a âˆˆ Ioo l u âˆ§ Ioo l u âŠ† s :=
  mem_nhds_iff_exists_Ioo_subset' (exists_lt a) (exists_gt a)

theorem nhds_basis_Ioo' {a : Î±} (hl : âˆƒ l, l < a) (hu : âˆƒ u, a < u) :
    (ğ“ a).HasBasis (fun b : Î± Ã— Î± => b.1 < a âˆ§ a < b.2) fun b => Ioo b.1 b.2 :=
  âŸ¨fun s => (mem_nhds_iff_exists_Ioo_subset' hl hu).trans <| by simpâŸ©

theorem nhds_basis_Ioo [NoMaxOrder Î±] [NoMinOrder Î±] (a : Î±) :
    (ğ“ a).HasBasis (fun b : Î± Ã— Î± => b.1 < a âˆ§ a < b.2) fun b => Ioo b.1 b.2 :=
  nhds_basis_Ioo' (exists_lt a) (exists_gt a)

theorem Filter.Eventually.exists_Ioo_subset [NoMaxOrder Î±] [NoMinOrder Î±] {a : Î±}
    {p : Î± â†’ Prop} (hp : âˆ€á¶  x in ğ“ a, p x) : âˆƒ l u, a âˆˆ Ioo l u âˆ§ Ioo l u âŠ† { x | p x } :=
  mem_nhds_iff_exists_Ioo_subset.1 hp

theorem Dense.topology_eq_generateFrom [DenselyOrdered Î±] {s : Set Î±}
    (hs : Dense s) : â€¹TopologicalSpace Î±â€º = .generateFrom (Ioi '' s âˆª Iio '' s) := by
  refine (OrderTopology.topology_eq_generate_intervals (Î± := Î±)).trans ?_
  refine le_antisymm (generateFrom_anti ?_) (le_generateFrom ?_)
  Â· simp only [union_subset_iff, image_subset_iff]
    exact âŸ¨fun a _ â†¦ âŸ¨a, .inl rflâŸ©, fun a _ â†¦ âŸ¨a, .inr rflâŸ©âŸ©
  Â· rintro _ âŸ¨a, rfl | rflâŸ©
    Â· rw [hs.Ioi_eq_biUnion]
      let _ := generateFrom (Ioi '' s âˆª Iio '' s)
      exact isOpen_iUnion fun x â†¦ isOpen_iUnion fun h â†¦ .basic _ <| .inl <| mem_image_of_mem _ h.1
    Â· rw [hs.Iio_eq_biUnion]
      let _ := generateFrom (Ioi '' s âˆª Iio '' s)
      exact isOpen_iUnion fun x â†¦ isOpen_iUnion fun h â†¦ .basic _ <| .inr <| mem_image_of_mem _ h.1

theorem PredOrder.hasBasis_nhds_Ioc_of_exists_gt [PredOrder Î±] {a : Î±} (ha : âˆƒ u, a < u) :
    (ğ“ a).HasBasis (a < Â·) (Set.Ico a Â·) :=
  PredOrder.nhdsGE_eq_nhds a â–¸ nhdsGE_basis_of_exists_gt ha

theorem PredOrder.hasBasis_nhds_Ioc [PredOrder Î±] [NoMaxOrder Î±] {a : Î±} :
    (ğ“ a).HasBasis (a < Â·) (Set.Ico a Â·) :=
  PredOrder.hasBasis_nhds_Ioc_of_exists_gt (exists_gt a)

theorem SuccOrder.hasBasis_nhds_Ioc_of_exists_lt [SuccOrder Î±] {a : Î±} (ha : âˆƒ l, l < a) :
    (ğ“ a).HasBasis (Â· < a) (Set.Ioc Â· a) :=
  SuccOrder.nhdsLE_eq_nhds a â–¸ nhdsLE_basis_of_exists_lt ha

theorem SuccOrder.hasBasis_nhds_Ioc [SuccOrder Î±] {a : Î±} [NoMinOrder Î±] :
    (ğ“ a).HasBasis (Â· < a) (Set.Ioc Â· a) :=
  SuccOrder.hasBasis_nhds_Ioc_of_exists_lt (exists_lt a)

variable (Î±) in
/-- Let `Î±` be a densely ordered linear order with order topology. If `Î±` is a separable space, then
it has second countable topology. Note that the "densely ordered" assumption cannot be dropped, see
[double arrow space](https://topology.pi-base.org/spaces/S000093) for a counterexample. -/
theorem SecondCountableTopology.of_separableSpace_orderTopology [DenselyOrdered Î±]
    [SeparableSpace Î±] : SecondCountableTopology Î± := by
  rcases exists_countable_dense Î± with âŸ¨s, hc, hdâŸ©
  refine âŸ¨âŸ¨_, ?_, hd.topology_eq_generateFromâŸ©âŸ©
  exact (hc.image _).union (hc.image _)

/-- The set of points which are isolated on the right is countable when the space is
second-countable. -/
theorem countable_setOf_covBy_right [SecondCountableTopology Î±] :
    Set.Countable { x : Î± | âˆƒ y, x â‹– y } := by
  nontriviality Î±
  let s := { x : Î± | âˆƒ y, x â‹– y }
  have : âˆ€ x âˆˆ s, âˆƒ y, x â‹– y := fun x => id
  choose! y hy using this
  have Hy : âˆ€ x z, x âˆˆ s â†’ z < y x â†’ z â‰¤ x := fun x z hx => (hy x hx).le_of_lt
  suffices H : âˆ€ a : Set Î±, IsOpen a â†’ Set.Countable { x | x âˆˆ s âˆ§ x âˆˆ a âˆ§ y x âˆ‰ a } by
    have : s âŠ† â‹ƒ a âˆˆ countableBasis Î±, { x | x âˆˆ s âˆ§ x âˆˆ a âˆ§ y x âˆ‰ a } := fun x hx => by
      rcases (isBasis_countableBasis Î±).exists_mem_of_ne (hy x hx).ne with âŸ¨a, ab, xa, yaâŸ©
      exact mem_iUnionâ‚‚.2 âŸ¨a, ab, hx, xa, yaâŸ©
    refine Set.Countable.mono this ?_
    refine Countable.biUnion (countable_countableBasis Î±) fun a ha => H _ ?_
    exact isOpen_of_mem_countableBasis ha
  intro a ha
  suffices H : Set.Countable { x | (x âˆˆ s âˆ§ x âˆˆ a âˆ§ y x âˆ‰ a) âˆ§ Â¬IsBot x } from
    H.of_diff (subsingleton_isBot Î±).countable
  simp only [and_assoc]
  let t := { x | x âˆˆ s âˆ§ x âˆˆ a âˆ§ y x âˆ‰ a âˆ§ Â¬IsBot x }
  have : âˆ€ x âˆˆ t, âˆƒ z < x, Ioc z x âŠ† a := by
    intro x hx
    apply exists_Ioc_subset_of_mem_nhds (ha.mem_nhds hx.2.1)
    simpa only [IsBot, not_forall, not_le] using hx.right.right.right
  choose! z hz h'z using this
  have : PairwiseDisjoint t fun x => Ioc (z x) x := fun x xt x' x't hxx' => by
    rcases hxx'.lt_or_gt with (h' | h')
    Â· refine disjoint_left.2 fun u ux ux' => xt.2.2.1 ?_
      refine h'z x' x't âŸ¨ux'.1.trans_le (ux.2.trans (hy x xt.1).le), ?_âŸ©
      by_contra! H
      exact lt_irrefl _ ((Hy _ _ xt.1 H).trans_lt h')
    Â· refine disjoint_left.2 fun u ux ux' => x't.2.2.1 ?_
      refine h'z x xt âŸ¨ux.1.trans_le (ux'.2.trans (hy x' x't.1).le), ?_âŸ©
      by_contra! H
      exact lt_irrefl _ ((Hy _ _ x't.1 H).trans_lt h')
  refine this.countable_of_isOpen (fun x hx => ?_) fun x hx => âŸ¨x, hz x hx, le_rflâŸ©
  suffices H : Ioc (z x) x = Ioo (z x) (y x) by
    rw [H]
    exact isOpen_Ioo
  exact Subset.antisymm (Ioc_subset_Ioo_right (hy x hx.1).lt) fun u hu => âŸ¨hu.1, Hy _ _ hx.1 hu.2âŸ©

/-- The set of points which are isolated on the left is countable when the space is
second-countable. -/
theorem countable_setOf_covBy_left [SecondCountableTopology Î±] :
    Set.Countable { x : Î± | âˆƒ y, y â‹– x } := by
  convert countable_setOf_covBy_right (Î± := Î±áµ’áµˆ) using 5
  exact toDual_covBy_toDual_iff.symm

/-- The set of points which are isolated on the left is countable when the space is
second-countable. -/
theorem countable_of_isolated_left' [SecondCountableTopology Î±] :
    Set.Countable { x : Î± | âˆƒ y, y < x âˆ§ Ioo y x = âˆ… } := by
  simpa only [â† covBy_iff_Ioo_eq] using countable_setOf_covBy_left

/-- Consider a disjoint family of intervals `(x, y)` with `x < y` in a second-countable space.
Then the family is countable.
This is not a straightforward consequence of second-countability as some of these intervals might be
empty (but in fact this can happen only for countably many of them). -/
theorem Set.PairwiseDisjoint.countable_of_Ioo [SecondCountableTopology Î±]
    {y : Î± â†’ Î±} {s : Set Î±} (h : PairwiseDisjoint s fun x => Ioo x (y x))
    (h' : âˆ€ x âˆˆ s, x < y x) : s.Countable :=
  have : (s \ { x | âˆƒ y, x â‹– y }).Countable :=
    (h.subset diff_subset).countable_of_isOpen (fun _ _ => isOpen_Ioo)
      fun x hx => (h' _ hx.1).exists_lt_lt (mt (Exists.intro (y x)) hx.2)
  this.of_diff countable_setOf_covBy_right

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(x, âˆ)` is separated above from `f x` is countable. We give
here a version relative to a set `t`. -/
theorem countable_image_lt_image_Ioi_within
    [LinearOrder Î²] [SecondCountableTopology Î±] (t : Set Î²) (f : Î² â†’ Î±) :
    Set.Countable {x âˆˆ t | âˆƒ z, f x < z âˆ§ âˆ€ y âˆˆ t, x < y â†’ z â‰¤ f y} := by
  /- If the values of `f` are separated above on the right of `x`, there is an interval `(f x, z x)`
    which is not reached by `f`. This gives a family of disjoint open intervals in `Î±`. Such a
    family can only be countable as `Î±` is second-countable. -/
  nontriviality Î²
  have : Nonempty Î± := Nonempty.map f (by infer_instance)
  let s := {x âˆˆ t | âˆƒ z, f x < z âˆ§ âˆ€ y âˆˆ t, x < y â†’ z â‰¤ f y}
  have : âˆ€ x, x âˆˆ s â†’ âˆƒ z, f x < z âˆ§ âˆ€ y âˆˆ t, x < y â†’ z â‰¤ f y := fun x hx â†¦ hx.2
  -- choose `z x` such that `f` does not take the values in `(f x, z x)`.
  choose! z hz using this
  have I : InjOn f s := by
    apply StrictMonoOn.injOn
    intro x hx y hy hxy
    calc
      f x < z x := (hz x hx).1
      _ â‰¤ f y := (hz x hx).2 y hy.1 hxy
  -- show that `f s` is countable by arguing that a disjoint family of disjoint open intervals
  -- (the intervals `(f x, z x)`) is at most countable.
  have fs_count : (f '' s).Countable := by
    have A : (f '' s).PairwiseDisjoint fun x => Ioo x (z (invFunOn f s x)) := by
      rintro _ âŸ¨u, us, rflâŸ© _ âŸ¨v, vs, rflâŸ© huv
      wlog hle : u â‰¤ v generalizing u v
      Â· exact (this v vs u us huv.symm (le_of_not_ge hle)).symm
      have hlt : u < v := hle.lt_of_ne (ne_of_apply_ne _ huv)
      apply disjoint_iff_forall_ne.2
      rintro a ha b hb rfl
      simp only [I.leftInvOn_invFunOn us, I.leftInvOn_invFunOn vs] at ha hb
      exact lt_irrefl _ ((ha.2.trans_le ((hz u us).2 v vs.1 hlt)).trans hb.1)
    apply Set.PairwiseDisjoint.countable_of_Ioo A
    rintro _ âŸ¨y, ys, rflâŸ©
    simpa only [I.leftInvOn_invFunOn ys] using (hz y ys).1
  exact MapsTo.countable_of_injOn (mapsTo_image f s) I fs_count

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(x, âˆ)` is separated above from `f x` is countable. -/
theorem countable_image_lt_image_Ioi [LinearOrder Î²] (f : Î² â†’ Î±)
    [SecondCountableTopology Î±] : Set.Countable {x | âˆƒ z, f x < z âˆ§ âˆ€ y, x < y â†’ z â‰¤ f y} := by
  simpa using countable_image_lt_image_Ioi_within univ f

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(x, âˆ)` is separated below from `f x` is countable. We give
here a version relative to a set `t`. -/
theorem countable_image_gt_image_Ioi_within
    [LinearOrder Î²] [SecondCountableTopology Î±] (t : Set Î²) (f : Î² â†’ Î±) :
    Set.Countable {x âˆˆ t | âˆƒ z, z < f x âˆ§ âˆ€ y âˆˆ t, x < y â†’ f y â‰¤ z} :=
  countable_image_lt_image_Ioi_within (Î± := Î±áµ’áµˆ) t f

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(x, âˆ)` is separated below from `f x` is countable. -/
theorem countable_image_gt_image_Ioi [LinearOrder Î²] (f : Î² â†’ Î±)
    [SecondCountableTopology Î±] : Set.Countable {x | âˆƒ z, z < f x âˆ§ âˆ€ y, x < y â†’ f y â‰¤ z} :=
  countable_image_lt_image_Ioi (Î± := Î±áµ’áµˆ) f

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(-âˆ, x)` is separated above from `f x` is countable. We give
here a version relative to a set `t`. -/
theorem countable_image_lt_image_Iio_within
    [LinearOrder Î²] [SecondCountableTopology Î±] (t : Set Î²) (f : Î² â†’ Î±) :
    Set.Countable {x âˆˆ t | âˆƒ z, f x < z âˆ§ âˆ€ y âˆˆ t, y < x â†’ z â‰¤ f y} :=
  countable_image_lt_image_Ioi_within (Î² := Î²áµ’áµˆ) t f

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(-âˆ, x)` is separated above from `f x` is countable. -/
theorem countable_image_lt_image_Iio [LinearOrder Î²] (f : Î² â†’ Î±)
    [SecondCountableTopology Î±] : Set.Countable {x | âˆƒ z, f x < z âˆ§ âˆ€ y, y < x â†’ z â‰¤ f y} :=
  countable_image_lt_image_Ioi (Î² := Î²áµ’áµˆ) f

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(-âˆ, x)` is separated below from `f x` is countable. We give
here a version relative to a set `t`. -/
theorem countable_image_gt_image_Iio_within
    [LinearOrder Î²] [SecondCountableTopology Î±] (t : Set Î²) (f : Î² â†’ Î±) :
    Set.Countable {x âˆˆ t | âˆƒ z, z < f x âˆ§ âˆ€ y âˆˆ t, y < x â†’ f y â‰¤ z} :=
  countable_image_lt_image_Ioi_within (Î± := Î±áµ’áµˆ) (Î² := Î²áµ’áµˆ) t f

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(-âˆ, x)` is separated below from `f x` is countable. -/
theorem countable_image_gt_image_Iio [LinearOrder Î²] (f : Î² â†’ Î±)
    [SecondCountableTopology Î±] : Set.Countable {x | âˆƒ z, z < f x âˆ§ âˆ€ y, y < x â†’ f y â‰¤ z} :=
  countable_image_lt_image_Ioi (Î± := Î±áµ’áµˆ) (Î² := Î²áµ’áµˆ) f

instance instIsCountablyGenerated_atTop [SecondCountableTopology Î±] :
    IsCountablyGenerated (atTop : Filter Î±) := by
  obtain (h | âŸ¨x, hxâŸ©) := Set.eq_empty_or_nonempty {x : Î± | IsTop x}
  Â· rcases exists_countable_basis Î± with âŸ¨b, b_count, b_ne, hbâŸ©
    have A (s : b) : s.1.Nonempty := by aesop (add simp [nonempty_iff_ne_empty])
    choose a ha using A
    have : atTop = generate (Ici '' range a) := by
      refine atTop_eq_generate_of_not_bddAbove fun âŸ¨x, hxâŸ© â†¦ ?_
      simp only [eq_empty_iff_forall_notMem, IsTop, mem_setOf_eq, not_forall, not_le] at h
      rcases h x with âŸ¨y, hyâŸ©
      obtain âŸ¨s, sb, -, hsâŸ© := hb.exists_subset_of_mem_open hy isOpen_Ioi
      exact ((hx (mem_range_self _)).trans_lt (hs (ha âŸ¨s, sbâŸ©))).false
    rw [this]
    have := countable_coe_iff.2 b_count
    exact âŸ¨_, (countable_range _).image _, rflâŸ©
  Â· rw [atTop_eq_pure_of_isTop hx]
    exact isCountablyGenerated_pure x

instance instIsCountablyGenerated_atBot [SecondCountableTopology Î±] :
    IsCountablyGenerated (atBot : Filter Î±) :=
  @instIsCountablyGenerated_atTop Î±áµ’áµˆ _ _ _ _

end OrderTopology

section Pi

/-!
### Intervals in `Î  i, X i` belong to `ğ“ x`

For each lemma `pi_Ixx_mem_nhds` we add a non-dependent version `pi_Ixx_mem_nhds'` because
sometimes Lean fails to unify different instances while trying to apply the dependent version to,
e.g., `Î¹ â†’ â„`.
-/

variable [OrderTopology Î±] {Î¹ : Type*} {X : Î¹ â†’ Type*} [Finite Î¹] [âˆ€ i, LinearOrder (X i)]
  [âˆ€ i, TopologicalSpace (X i)] [âˆ€ i, OrderTopology (X i)] {a b x : âˆ€ i, X i} {a' b' x' : Î¹ â†’ Î±}

theorem pi_Iic_mem_nhds (ha : âˆ€ i, x i < a i) : Iic a âˆˆ ğ“ x :=
  pi_univ_Iic a â–¸ set_pi_mem_nhds (Set.toFinite _) fun _ _ => Iic_mem_nhds (ha _)

theorem pi_Iic_mem_nhds' (ha : âˆ€ i, x' i < a' i) : Iic a' âˆˆ ğ“ x' :=
  pi_Iic_mem_nhds ha

theorem pi_Ici_mem_nhds (ha : âˆ€ i, a i < x i) : Ici a âˆˆ ğ“ x :=
  pi_univ_Ici a â–¸ set_pi_mem_nhds (Set.toFinite _) fun _ _ => Ici_mem_nhds (ha _)

theorem pi_Ici_mem_nhds' (ha : âˆ€ i, a' i < x' i) : Ici a' âˆˆ ğ“ x' :=
  pi_Ici_mem_nhds ha

theorem pi_Icc_mem_nhds (ha : âˆ€ i, a i < x i) (hb : âˆ€ i, x i < b i) : Icc a b âˆˆ ğ“ x :=
  pi_univ_Icc a b â–¸ set_pi_mem_nhds finite_univ fun _ _ => Icc_mem_nhds (ha _) (hb _)

theorem pi_Icc_mem_nhds' (ha : âˆ€ i, a' i < x' i) (hb : âˆ€ i, x' i < b' i) : Icc a' b' âˆˆ ğ“ x' :=
  pi_Icc_mem_nhds ha hb

variable [Nonempty Î¹]

theorem pi_Iio_mem_nhds (ha : âˆ€ i, x i < a i) : Iio a âˆˆ ğ“ x := mem_of_superset
  (set_pi_mem_nhds finite_univ fun i _ â†¦ Iio_mem_nhds (ha i)) (pi_univ_Iio_subset a)

theorem pi_Iio_mem_nhds' (ha : âˆ€ i, x' i < a' i) : Iio a' âˆˆ ğ“ x' :=
  pi_Iio_mem_nhds ha

theorem pi_Ioi_mem_nhds (ha : âˆ€ i, a i < x i) : Ioi a âˆˆ ğ“ x :=
  pi_Iio_mem_nhds (X := fun i => (X i)áµ’áµˆ) ha

theorem pi_Ioi_mem_nhds' (ha : âˆ€ i, a' i < x' i) : Ioi a' âˆˆ ğ“ x' :=
  pi_Ioi_mem_nhds ha

theorem pi_Ioc_mem_nhds (ha : âˆ€ i, a i < x i) (hb : âˆ€ i, x i < b i) : Ioc a b âˆˆ ğ“ x := by
  refine mem_of_superset (set_pi_mem_nhds Set.finite_univ fun i _ => ?_) (pi_univ_Ioc_subset a b)
  exact Ioc_mem_nhds (ha i) (hb i)

theorem pi_Ioc_mem_nhds' (ha : âˆ€ i, a' i < x' i) (hb : âˆ€ i, x' i < b' i) : Ioc a' b' âˆˆ ğ“ x' :=
  pi_Ioc_mem_nhds ha hb

theorem pi_Ico_mem_nhds (ha : âˆ€ i, a i < x i) (hb : âˆ€ i, x i < b i) : Ico a b âˆˆ ğ“ x := by
  refine mem_of_superset (set_pi_mem_nhds Set.finite_univ fun i _ => ?_) (pi_univ_Ico_subset a b)
  exact Ico_mem_nhds (ha i) (hb i)

theorem pi_Ico_mem_nhds' (ha : âˆ€ i, a' i < x' i) (hb : âˆ€ i, x' i < b' i) : Ico a' b' âˆˆ ğ“ x' :=
  pi_Ico_mem_nhds ha hb

theorem pi_Ioo_mem_nhds (ha : âˆ€ i, a i < x i) (hb : âˆ€ i, x i < b i) : Ioo a b âˆˆ ğ“ x := by
  refine mem_of_superset (set_pi_mem_nhds Set.finite_univ fun i _ => ?_) (pi_univ_Ioo_subset a b)
  exact Ioo_mem_nhds (ha i) (hb i)

theorem pi_Ioo_mem_nhds' (ha : âˆ€ i, a' i < x' i) (hb : âˆ€ i, x' i < b' i) : Ioo a' b' âˆˆ ğ“ x' :=
  pi_Ioo_mem_nhds ha hb

end Pi

end LinearOrder

section ConditionallyCompleteLinearOrder
variable {X : Type*} [ConditionallyCompleteLinearOrder X] [TopologicalSpace X] [OrderTopology X]
variable {Y : Type*} [ConditionallyCompleteLinearOrder Y] [TopologicalSpace Y] [OrderTopology Y]
variable [DenselyOrdered X] {f : X â†’ Y} {x : X}

/-- An order-theoretically left-continuous function is topologically left-continuous, assuming
the function is between conditionally complete linear orders with order topologies, and the domain
is densely ordered. -/
lemma LeftOrdContinuous.continuousWithinAt_Iic (hf : LeftOrdContinuous f) :
    ContinuousWithinAt f (Iic x) x := by
  rw [ContinuousWithinAt, OrderTopology.topology_eq_generate_intervals (Î± := Y)]
  simp_rw [TopologicalSpace.tendsto_nhds_generateFrom_iff, mem_nhdsWithin]
  rintro V âŸ¨z, rfl | rflâŸ© hxz
  -- The case `V = Ioi z`.
  Â· obtain âŸ¨_, âŸ¨a, hax, rflâŸ©, hzaâŸ© := (lt_isLUB_iff <| hf isLUB_Iio).mp hxz
    exact âŸ¨Ioi a, isOpen_Ioi, hax, fun b hab â†¦ hza.trans_le <| hf.mono hab.1.leâŸ©
  -- The case `V = Iio z`.
  Â· exact âŸ¨univ, isOpen_univ, trivial, fun a ha â†¦ (hf.mono ha.2).trans_lt hxzâŸ©

/-- An order-theoretically right-continuous function is topologically right-continuous, assuming
the function is between conditionally complete linear orders with order topologies, and the domain
is densely ordered. -/
lemma RightOrdContinuous.continuousWithinAt_Ici (hf : RightOrdContinuous f) :
    ContinuousWithinAt f (Ici x) x := hf.orderDual.continuousWithinAt_Iic

end ConditionallyCompleteLinearOrder
