/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro, Yury Kudryashov
-/
import Mathlib.Order.Filter.Interval
import Mathlib.Order.Interval.Set.Pi
import Mathlib.Order.OrdContinuous
import Mathlib.Tactic.TFAE
import Mathlib.Tactic.NormNum
import Mathlib.Topology.Order.LeftRight
import Mathlib.Topology.Order.OrderClosed

/-!
# Theory of topology on ordered spaces

## Main definitions

The order topology on an ordered space is the topology generated by all open intervals (or
equivalently by those of the form `(-‚àû, a)` and `(b, +‚àû)`). We define it as `Preorder.topology Œ±`.
However, we do *not* register it as an instance (as many existing ordered types already have
topologies, which would be equal but not definitionally equal to `Preorder.topology Œ±`). Instead,
we introduce a class `OrderTopology Œ±` (which is a `Prop`, also known as a mixin) saying that on
the type `Œ±` having already a topological space structure and a preorder structure, the topological
structure is equal to the order topology.

We prove many basic properties of such topologies.

## Main statements

This file contains the proofs of the following facts. For exact requirements
(`OrderClosedTopology` vs `OrderTopology`, `Preorder` vs `PartialOrder` vs `LinearOrder` etc)
see their statements.

* `exists_Ioc_subset_of_mem_nhds`, `exists_Ico_subset_of_mem_nhds` : if `x < y`, then any
  neighborhood of `x` includes an interval `[x, z)` for some `z ‚àà (x, y]`, and any neighborhood
  of `y` includes an interval `(z, y]` for some `z ‚àà [x, y)`.
* `tendsto_of_tendsto_of_tendsto_of_le_of_le` : theorem known as squeeze theorem,
  sandwich theorem, theorem of Carabinieri, and two policemen (and a drunk) theorem; if `g` and `h`
  both converge to `a`, and eventually `g x ‚â§ f x ‚â§ h x`, then `f` converges to `a`.

## Implementation notes

We do _not_ register the order topology as an instance on a preorder (or even on a linear order).
Indeed, on many such spaces, a topology has already been constructed in a different way (think
of the discrete spaces `‚Ñï` or `‚Ñ§`, or `‚Ñù` that could inherit a topology as the completion of `‚Ñö`),
and is in general not defeq to the one generated by the intervals. We make it available as a
definition `Preorder.topology Œ±` though, that can be registered as an instance when necessary, or
for specific types.
-/


open Set Filter TopologicalSpace Topology Function

open OrderDual (toDual ofDual)

universe u v w

variable {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w}

-- TODO: define `Preorder.topology` before `OrderTopology` and reuse the def
/-- The order topology on an ordered type is the topology generated by open intervals. We register
it on a preorder, but it is mostly interesting in linear orders, where it is also order-closed.
We define it as a mixin. If you want to introduce the order topology on a preorder, use
`Preorder.topology`. -/
class OrderTopology (Œ± : Type*) [t : TopologicalSpace Œ±] [Preorder Œ±] : Prop where
  /-- The topology is generated by open intervals `Set.Ioi _` and `Set.Iio _`. -/
  topology_eq_generate_intervals : t = generateFrom { s | ‚àÉ a, s = Ioi a ‚à® s = Iio a }

/-- (Order) topology on a partial order `Œ±` generated by the subbase of open intervals
`(a, ‚àû) = { x ‚à£ a < x }, (-‚àû, b) = {x ‚à£ x < b}` for all `a, b` in `Œ±`. We do not register it as an
instance as many ordered sets are already endowed with the same topology, most often in a non-defeq
way though. Register as a local instance when necessary. -/
def Preorder.topology (Œ± : Type*) [Preorder Œ±] : TopologicalSpace Œ± :=
  generateFrom { s : Set Œ± | ‚àÉ a : Œ±, s = { b : Œ± | a < b } ‚à® s = { b : Œ± | b < a } }

section Preorder

variable [ts : TopologicalSpace Œ±] [Preorder Œ±]

instance [t : OrderTopology Œ±] : OrderTopology Œ±·µí·µà :=
  ‚ü®by
    convert OrderTopology.topology_eq_generate_intervals (Œ± := Œ±) using 6
    apply or_comm‚ü©

protected theorem OrderTopology.continuous_iff [OrderTopology Œ±] [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} :
    Continuous f ‚Üî ‚àÄ a, IsOpen (f ‚Åª¬π' Ioi a) ‚àß IsOpen (f ‚Åª¬π' Iio a) := by
  simp_rw [OrderTopology.topology_eq_generate_intervals, continuous_generateFrom_iff]
  aesop

theorem isOpen_iff_generate_intervals [t : OrderTopology Œ±] {s : Set Œ±} :
    IsOpen s ‚Üî GenerateOpen { s | ‚àÉ a, s = Ioi a ‚à® s = Iio a } s := by
  rw [t.topology_eq_generate_intervals]; rfl

theorem isOpen_lt' [OrderTopology Œ±] (a : Œ±) : IsOpen { b : Œ± | a < b } :=
  isOpen_iff_generate_intervals.2 <| .basic _ ‚ü®a, .inl rfl‚ü©

theorem isOpen_Ioi' [OrderTopology Œ±] (a : Œ±) : IsOpen (Ioi a) := isOpen_lt' a

theorem isOpen_gt' [OrderTopology Œ±] (a : Œ±) : IsOpen { b : Œ± | b < a } :=
  isOpen_iff_generate_intervals.2 <| .basic _ ‚ü®a, .inr rfl‚ü©

theorem isOpen_Iio' [OrderTopology Œ±] (a : Œ±) : IsOpen (Iio a) := isOpen_gt' a

theorem lt_mem_nhds [OrderTopology Œ±] {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù b, a < x :=
  (isOpen_lt' _).mem_nhds h

theorem le_mem_nhds [OrderTopology Œ±] {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù b, a ‚â§ x :=
  (lt_mem_nhds h).mono fun _ => le_of_lt

theorem gt_mem_nhds [OrderTopology Œ±] {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù a, x < b :=
  (isOpen_gt' _).mem_nhds h

theorem ge_mem_nhds [OrderTopology Œ±] {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù a, x ‚â§ b :=
  (gt_mem_nhds h).mono fun _ => le_of_lt

theorem nhds_eq_order [OrderTopology Œ±] (a : Œ±) :
    ùìù a = (‚®Ö b ‚àà Iio a, ùìü (Ioi b)) ‚äì ‚®Ö b ‚àà Ioi a, ùìü (Iio b) := by
  rw [OrderTopology.topology_eq_generate_intervals (Œ± := Œ±), nhds_generateFrom]
  simp_rw [mem_setOf_eq, @and_comm (a ‚àà _), exists_or, or_and_right, iInf_or, iInf_and,
    iInf_exists, iInf_inf_eq, iInf_comm (Œπ := Set Œ±), iInf_iInf_eq_left, mem_Ioi, mem_Iio]

theorem tendsto_order [OrderTopology Œ±] {f : Œ≤ ‚Üí Œ±} {a : Œ±} {x : Filter Œ≤} :
    Tendsto f x (ùìù a) ‚Üî (‚àÄ a' < a, ‚àÄ·∂† b in x, a' < f b) ‚àß ‚àÄ a' > a, ‚àÄ·∂† b in x, f b < a' := by
  simp only [nhds_eq_order a, tendsto_inf, tendsto_iInf, tendsto_principal]; rfl
instance tendstoIccClassNhds [OrderTopology Œ±] (a : Œ±) : TendstoIxxClass Icc (ùìù a) (ùìù a) := by
  simp only [nhds_eq_order, iInf_subtype']
  refine
    ((hasBasis_iInf_principal_finite _).inf (hasBasis_iInf_principal_finite _)).tendstoIxxClass
      fun s _ => ?_
  refine ((ordConnected_biInter ?_).inter (ordConnected_biInter ?_)).out <;> intro _ _
  exacts [ordConnected_Ioi, ordConnected_Iio]

instance tendstoIcoClassNhds [OrderTopology Œ±] (a : Œ±) : TendstoIxxClass Ico (ùìù a) (ùìù a) :=
  tendstoIxxClass_of_subset fun _ _ => Ico_subset_Icc_self

instance tendstoIocClassNhds [OrderTopology Œ±] (a : Œ±) : TendstoIxxClass Ioc (ùìù a) (ùìù a) :=
  tendstoIxxClass_of_subset fun _ _ => Ioc_subset_Icc_self

instance tendstoIooClassNhds [OrderTopology Œ±] (a : Œ±) : TendstoIxxClass Ioo (ùìù a) (ùìù a) :=
  tendstoIxxClass_of_subset fun _ _ => Ioo_subset_Icc_self

variable (Œ±) in
/-- In a second countable topological space with the order topology, the topology is generated
by half-infinite open intervals with endpoints in a countable set. -/
lemma exists_countable_generateFrom_Ioi_Iio
    [OrderTopology Œ±] [SecondCountableTopology Œ±] :
    ‚àÉ (c : Set Œ±), c.Countable ‚àß ts = generateFrom { s | ‚àÉ a ‚àà c, s = Ioi a ‚à® s = Iio a } := by
  rcases isEmpty_or_nonempty Œ± with hŒ± | hŒ±
  ¬∑ exact ‚ü®‚àÖ, by simp, Subsingleton.elim _ _‚ü©
  obtain ‚ü®t, t_subs, t_count, ht‚ü© : ‚àÉ t ‚äÜ { s | ‚àÉ a, s = Ioi a ‚à® s = Iio a },
      t.Countable ‚àß ts = generateFrom t :=
    exists_countable_of_generateFrom OrderTopology.topology_eq_generate_intervals
  have A : ‚àÄ s ‚àà t, ‚àÉ a, s = Ioi a ‚à® s = Iio a := t_subs
  choose! a ha using A
  refine ‚ü®a '' t, t_count.image _, ?_‚ü©
  apply le_antisymm
  ¬∑ apply le_generateFrom_iff_subset_isOpen.2
    simp only [mem_image, exists_exists_and_eq_and, setOf_subset_setOf, forall_exists_index,
      and_imp]
    grind [isOpen_Iio', isOpen_Ioi']
  ¬∑ rw [ht]
    apply generateFrom_anti
    intro s hs
    simp only [mem_image, exists_exists_and_eq_and, mem_setOf_eq]
    grind

/-- If a topology is generated by half-open intervals with endpoints in a set `c`, then the sets
formed by intersecting finitely many of these intervals form a topological basis. -/
lemma isTopologicalBasis_biInter_Ioi_Iio_of_generateFrom (c : Set Œ±)
    (h : ts = generateFrom { s | ‚àÉ a ‚àà c, s = Ioi a ‚à® s = Iio a }) :
    IsTopologicalBasis {s | ‚àÉ (f g : Set Œ±), f ‚äÜ c ‚àß g ‚äÜ c ‚àß f.Finite ‚àß g.Finite
      ‚àß s = (‚ãÇ a ‚àà f, Ioi a) ‚à© (‚ãÇ a ‚àà g, Iio a)} := by
  refine IsTopologicalBasis.of_isOpen_of_subset ?_ (isTopologicalBasis_of_subbasis h) ?_
  ¬∑ rintro u ‚ü®f, g, hfc, hgc, hf_fin, hg_fin, rfl‚ü©
    apply IsOpen.inter
    ¬∑ apply hf_fin.isOpen_biInter (fun i hi ‚Ü¶ ?_)
      rw [h]
      exact isOpen_generateFrom_of_mem ‚ü®i, hfc hi, Or.inl rfl‚ü©
    ¬∑ apply hg_fin.isOpen_biInter (fun i hi ‚Ü¶ ?_)
      rw [h]
      exact isOpen_generateFrom_of_mem ‚ü®i, hgc hi, Or.inr rfl‚ü©
  simp only [exists_and_left, image_subset_iff, preimage_setOf_eq, setOf_subset_setOf, and_imp]
  intro k k_fin hk
  let kl := {s ‚àà k | ‚àÉ a ‚àà c, s = Ioi a}
  let kr := {s ‚àà k | ‚àÉ a ‚àà c, s = Iio a}
  have k_eq : k = kl ‚à™ kr := by
    have : ‚àÄ s ‚àà k, ‚àÉ a ‚àà c, s = Ioi a ‚à® s = Iio a := hk
    ext
    simp only [mem_union, mem_setOf_eq, kl, kr]
    grind
  have : Finite kl := k_fin.subset (by simp [k_eq])
  have : Finite kr := k_fin.subset (by simp [k_eq])
  have Al : ‚àÄ s : kl, ‚àÉ a ‚àà c, s = Ioi a := fun s ‚Ü¶ s.2.2
  choose al alc hal using Al
  have Ar : ‚àÄ s : kr, ‚àÉ a ‚àà c, s = Iio a := fun s ‚Ü¶ s.2.2
  choose ar arc har using Ar
  refine ‚ü®range al, by simp [range_subset_iff, alc], range ar,
    by simp [range_subset_iff, arc], finite_range _, finite_range _, ?_‚ü©
  rw [k_eq, sInter_eq_biInter, biInter_union, biInter_range, biInter_range, biInter_eq_iInter,
    biInter_eq_iInter]
  simp [hal, har]

/-- **Squeeze theorem** (also known as **sandwich theorem**). This version assumes that inequalities
hold eventually for the filter. -/
theorem tendsto_of_tendsto_of_tendsto_of_le_of_le' [OrderTopology Œ±] {f g h : Œ≤ ‚Üí Œ±} {b : Filter Œ≤}
    {a : Œ±} (hg : Tendsto g b (ùìù a)) (hh : Tendsto h b (ùìù a)) (hgf : ‚àÄ·∂† b in b, g b ‚â§ f b)
    (hfh : ‚àÄ·∂† b in b, f b ‚â§ h b) : Tendsto f b (ùìù a) :=
  (hg.Icc hh).of_smallSets <| hgf.and hfh

alias Filter.Tendsto.squeeze' := tendsto_of_tendsto_of_tendsto_of_le_of_le'

/-- **Squeeze theorem** (also known as **sandwich theorem**). This version assumes that inequalities
hold everywhere. -/
theorem tendsto_of_tendsto_of_tendsto_of_le_of_le [OrderTopology Œ±] {f g h : Œ≤ ‚Üí Œ±} {b : Filter Œ≤}
    {a : Œ±} (hg : Tendsto g b (ùìù a)) (hh : Tendsto h b (ùìù a)) (hgf : g ‚â§ f) (hfh : f ‚â§ h) :
    Tendsto f b (ùìù a) :=
  tendsto_of_tendsto_of_tendsto_of_le_of_le' hg hh (Eventually.of_forall hgf)
    (Eventually.of_forall hfh)

alias Filter.Tendsto.squeeze := tendsto_of_tendsto_of_tendsto_of_le_of_le

theorem nhds_order_unbounded [OrderTopology Œ±] {a : Œ±} (hu : ‚àÉ u, a < u) (hl : ‚àÉ l, l < a) :
    ùìù a = ‚®Ö (l) (_ : l < a) (u) (_ : a < u), ùìü (Ioo l u) := by
  simp only [nhds_eq_order, ‚Üê inf_biInf, ‚Üê biInf_inf, *, ‚Üê inf_principal, ‚Üê Ioi_inter_Iio]; rfl

theorem tendsto_order_unbounded [OrderTopology Œ±] {f : Œ≤ ‚Üí Œ±} {a : Œ±} {x : Filter Œ≤}
    (hu : ‚àÉ u, a < u) (hl : ‚àÉ l, l < a) (h : ‚àÄ l u, l < a ‚Üí a < u ‚Üí ‚àÄ·∂† b in x, l < f b ‚àß f b < u) :
    Tendsto f x (ùìù a) := by
  simp only [nhds_order_unbounded hu hl, tendsto_iInf, tendsto_principal]
  exact fun l hl u => h l u hl

end Preorder

instance tendstoIxxNhdsWithin {Œ± : Type*} [TopologicalSpace Œ±] (a : Œ±) {s t : Set Œ±}
    {Ixx} [TendstoIxxClass Ixx (ùìù a) (ùìù a)] [TendstoIxxClass Ixx (ùìü s) (ùìü t)] :
    TendstoIxxClass Ixx (ùìù[s] a) (ùìù[t] a) :=
  Filter.tendstoIxxClass_inf

instance tendstoIccClassNhdsPi {Œπ : Type*} {Œ± : Œπ ‚Üí Type*} [‚àÄ i, Preorder (Œ± i)]
    [‚àÄ i, TopologicalSpace (Œ± i)] [‚àÄ i, OrderTopology (Œ± i)] (f : ‚àÄ i, Œ± i) :
    TendstoIxxClass Icc (ùìù f) (ùìù f) := by
  constructor
  conv in (ùìù f).smallSets => rw [nhds_pi, Filter.pi]
  simp only [smallSets_iInf, smallSets_comap_eq_comap_image, tendsto_iInf, tendsto_comap_iff]
  intro i
  have : Tendsto (fun g : ‚àÄ i, Œ± i => g i) (ùìù f) (ùìù (f i)) := (continuous_apply i).tendsto f
  refine (this.comp tendsto_fst).Icc (this.comp tendsto_snd) |>.smallSets_mono ?_
  filter_upwards [] using fun ‚ü®f, g‚ü© ‚Ü¶ image_subset_iff.mpr fun p hp ‚Ü¶ ‚ü®hp.1 i, hp.2 i‚ü©

theorem induced_topology_le_preorder [Preorder Œ±] [Preorder Œ≤] [TopologicalSpace Œ≤]
    [OrderTopology Œ≤] {f : Œ± ‚Üí Œ≤} (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y) :
    induced f ‚ÄπTopologicalSpace Œ≤‚Ä∫ ‚â§ Preorder.topology Œ± := by
  let _ := Preorder.topology Œ±; have : OrderTopology Œ± := ‚ü®rfl‚ü©
  refine le_of_nhds_le_nhds fun x => ?_
  simp only [nhds_eq_order, nhds_induced, comap_inf, comap_iInf, comap_principal, Ioi, Iio, ‚Üê hf]
  refine inf_le_inf (le_iInf‚ÇÇ fun a ha => ?_) (le_iInf‚ÇÇ fun a ha => ?_)
  exacts [iInf‚ÇÇ_le (f a) ha, iInf‚ÇÇ_le (f a) ha]

theorem induced_topology_eq_preorder [Preorder Œ±] [Preorder Œ≤] [TopologicalSpace Œ≤]
    [OrderTopology Œ≤] {f : Œ± ‚Üí Œ≤} (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)
    (H‚ÇÅ : ‚àÄ {a b x}, b < f a ‚Üí ¬¨(b < f x) ‚Üí ‚àÉ y, y < a ‚àß b ‚â§ f y)
    (H‚ÇÇ : ‚àÄ {a b x}, f a < b ‚Üí ¬¨(f x < b) ‚Üí ‚àÉ y, a < y ‚àß f y ‚â§ b) :
    induced f ‚ÄπTopologicalSpace Œ≤‚Ä∫ = Preorder.topology Œ± := by
  let _ := Preorder.topology Œ±; have : OrderTopology Œ± := ‚ü®rfl‚ü©
  refine le_antisymm (induced_topology_le_preorder hf) ?_
  refine le_of_nhds_le_nhds fun a => ?_
  simp only [nhds_eq_order, nhds_induced, comap_inf, comap_iInf, comap_principal]
  refine inf_le_inf (le_iInf‚ÇÇ fun b hb => ?_) (le_iInf‚ÇÇ fun b hb => ?_)
  ¬∑ rcases em (‚àÉ x, ¬¨(b < f x)) with (‚ü®x, hx‚ü© | hb)
    ¬∑ rcases H‚ÇÅ hb hx with ‚ü®y, hya, hyb‚ü©
      exact iInf‚ÇÇ_le_of_le y hya (principal_mono.2 fun z hz => hyb.trans_lt (hf.2 hz))
    ¬∑ push_neg at hb
      exact le_principal_iff.2 (univ_mem' hb)
  ¬∑ rcases em (‚àÉ x, ¬¨(f x < b)) with (‚ü®x, hx‚ü© | hb)
    ¬∑ rcases H‚ÇÇ hb hx with ‚ü®y, hya, hyb‚ü©
      exact iInf‚ÇÇ_le_of_le y hya (principal_mono.2 fun z hz => (hf.2 hz).trans_le hyb)
    ¬∑ push_neg at hb
      exact le_principal_iff.2 (univ_mem' hb)

theorem induced_orderTopology' {Œ± : Type u} {Œ≤ : Type v} [Preorder Œ±] [ta : TopologicalSpace Œ≤]
    [Preorder Œ≤] [OrderTopology Œ≤] (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)
    (H‚ÇÅ : ‚àÄ {a x}, x < f a ‚Üí ‚àÉ b < a, x ‚â§ f b) (H‚ÇÇ : ‚àÄ {a x}, f a < x ‚Üí ‚àÉ b > a, f b ‚â§ x) :
    @OrderTopology _ (induced f ta) _ :=
  let _ := induced f ta
  ‚ü®induced_topology_eq_preorder hf (fun h _ => H‚ÇÅ h) (fun h _ => H‚ÇÇ h)‚ü©

theorem induced_orderTopology {Œ± : Type u} {Œ≤ : Type v} [Preorder Œ±] [ta : TopologicalSpace Œ≤]
    [Preorder Œ≤] [OrderTopology Œ≤] (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)
    (H : ‚àÄ {x y}, x < y ‚Üí ‚àÉ a, x < f a ‚àß f a < y) : @OrderTopology _ (induced f ta) _ :=
  induced_orderTopology' f (hf)
    (fun xa => let ‚ü®b, xb, ba‚ü© := H xa; ‚ü®b, hf.1 ba, le_of_lt xb‚ü©)
    fun ax => let ‚ü®b, ab, bx‚ü© := H ax; ‚ü®b, hf.1 ab, le_of_lt bx‚ü©

/-- The topology induced by a strictly monotone function with order-connected range is the preorder
topology. -/
nonrec theorem StrictMono.induced_topology_eq_preorder {Œ± Œ≤ : Type*} [LinearOrder Œ±]
    [LinearOrder Œ≤] [t : TopologicalSpace Œ≤] [OrderTopology Œ≤] {f : Œ± ‚Üí Œ≤}
    (hf : StrictMono f) (hc : OrdConnected (range f)) : t.induced f = Preorder.topology Œ± := by
  refine induced_topology_eq_preorder hf.lt_iff_lt (fun h‚ÇÅ h‚ÇÇ => ?_) fun h‚ÇÅ h‚ÇÇ => ?_
  ¬∑ rcases hc.out (mem_range_self _) (mem_range_self _) ‚ü®not_lt.1 h‚ÇÇ, h‚ÇÅ.le‚ü© with ‚ü®y, rfl‚ü©
    exact ‚ü®y, hf.lt_iff_lt.1 h‚ÇÅ, le_rfl‚ü©
  ¬∑ rcases hc.out (mem_range_self _) (mem_range_self _) ‚ü®h‚ÇÅ.le, not_lt.1 h‚ÇÇ‚ü© with ‚ü®y, rfl‚ü©
    exact ‚ü®y, hf.lt_iff_lt.1 h‚ÇÅ, le_rfl‚ü©

/-- A strictly monotone function between linear orders with order topology is a topological
embedding provided that the range of `f` is order-connected. -/
theorem StrictMono.isEmbedding_of_ordConnected {Œ± Œ≤ : Type*} [LinearOrder Œ±] [LinearOrder Œ≤]
    [TopologicalSpace Œ±] [h : OrderTopology Œ±] [TopologicalSpace Œ≤] [OrderTopology Œ≤] {f : Œ± ‚Üí Œ≤}
    (hf : StrictMono f) (hc : OrdConnected (range f)) : IsEmbedding f :=
  ‚ü®‚ü®h.1.trans <| Eq.symm <| hf.induced_topology_eq_preorder hc‚ü©, hf.injective‚ü©

/-- An `OrderEmbedding` is a topological embedding provided that the range of `f` is
order-connected -/
lemma OrderEmbedding.isEmbedding_of_ordConnected {Œ± Œ≤ : Type*} [LinearOrder Œ±] [LinearOrder Œ≤]
    [TopologicalSpace Œ±] [OrderTopology Œ±] [TopologicalSpace Œ≤] [OrderTopology Œ≤]
    (f : Œ± ‚Ü™o Œ≤) (hc : OrdConnected (range f)) : Topology.IsEmbedding f :=
  f.strictMono.isEmbedding_of_ordConnected hc

/-- On a `Set.OrdConnected` subset of a linear order, the order topology for the restriction of the
order is the same as the restriction to the subset of the order topology. -/
instance orderTopology_of_ordConnected {Œ± : Type u} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderTopology Œ±] {t : Set Œ±} [ht : OrdConnected t] : OrderTopology t :=
  ‚ü®(Subtype.strictMono_coe t).induced_topology_eq_preorder <| by
    rwa [‚Üê @Subtype.range_val _ t] at ht‚ü©

theorem nhdsGE_eq_iInf_inf_principal [TopologicalSpace Œ±] [Preorder Œ±] [OrderTopology Œ±] (a : Œ±) :
    ùìù[‚â•] a = (‚®Ö (u) (_ : a < u), ùìü (Iio u)) ‚äì ùìü (Ici a) := by
  rw [nhdsWithin, nhds_eq_order]
  refine le_antisymm (inf_le_inf_right _ inf_le_right) (le_inf (le_inf ?_ inf_le_left) inf_le_right)
  exact inf_le_right.trans (le_iInf‚ÇÇ fun l hl => principal_mono.2 <| Ici_subset_Ioi.2 hl)

theorem nhdsLE_eq_iInf_inf_principal [TopologicalSpace Œ±] [Preorder Œ±] [OrderTopology Œ±] (a : Œ±) :
    ùìù[‚â§] a = (‚®Ö l < a, ùìü (Ioi l)) ‚äì ùìü (Iic a) :=
  nhdsGE_eq_iInf_inf_principal (toDual a)

theorem nhdsGE_eq_iInf_principal [TopologicalSpace Œ±] [Preorder Œ±] [OrderTopology Œ±] {a : Œ±}
    (ha : ‚àÉ u, a < u) : ùìù[‚â•] a = ‚®Ö (u) (_ : a < u), ùìü (Ico a u) := by
  simp only [nhdsGE_eq_iInf_inf_principal, biInf_inf ha, inf_principal, Iio_inter_Ici]

theorem nhdsLE_eq_iInf_principal [TopologicalSpace Œ±] [Preorder Œ±] [OrderTopology Œ±] {a : Œ±}
    (ha : ‚àÉ l, l < a) : ùìù[‚â§] a = ‚®Ö l < a, ùìü (Ioc l a) := by
  simp only [nhdsLE_eq_iInf_inf_principal, biInf_inf ha, inf_principal, Ioi_inter_Iic]

theorem nhdsGE_basis_of_exists_gt [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] {a : Œ±}
    (ha : ‚àÉ u, a < u) : (ùìù[‚â•] a).HasBasis (fun u => a < u) fun u => Ico a u :=
  (nhdsGE_eq_iInf_principal ha).symm ‚ñ∏
    hasBasis_biInf_principal
      (fun b hb c hc => ‚ü®min b c, lt_min hb hc, Ico_subset_Ico_right (min_le_left _ _),
        Ico_subset_Ico_right (min_le_right _ _)‚ü©)
      ha

theorem nhdsLE_basis_of_exists_lt [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] {a : Œ±}
    (ha : ‚àÉ l, l < a) : (ùìù[‚â§] a).HasBasis (fun l => l < a) fun l => Ioc l a := by
  convert nhdsGE_basis_of_exists_gt (Œ± := Œ±·µí·µà) ha using 2
  exact Ico_toDual.symm

theorem nhdsGE_basis [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [NoMaxOrder Œ±] (a : Œ±) :
    (ùìù[‚â•] a).HasBasis (fun u => a < u) fun u => Ico a u :=
  nhdsGE_basis_of_exists_gt (exists_gt a)

theorem nhdsLE_basis [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [NoMinOrder Œ±] (a : Œ±) :
    (ùìù[‚â§] a).HasBasis (fun l => l < a) fun l => Ioc l a :=
  nhdsLE_basis_of_exists_lt (exists_lt a)

theorem nhds_top_order [TopologicalSpace Œ±] [Preorder Œ±] [OrderTop Œ±] [OrderTopology Œ±] :
    ùìù (‚ä§ : Œ±) = ‚®Ö (l) (_ : l < ‚ä§), ùìü (Ioi l) := by simp [nhds_eq_order (‚ä§ : Œ±)]

theorem nhds_bot_order [TopologicalSpace Œ±] [Preorder Œ±] [OrderBot Œ±] [OrderTopology Œ±] :
    ùìù (‚ä• : Œ±) = ‚®Ö (l) (_ : ‚ä• < l), ùìü (Iio l) := by simp [nhds_eq_order (‚ä• : Œ±)]

theorem nhds_top_basis [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTop Œ±] [OrderTopology Œ±]
    [Nontrivial Œ±] : (ùìù ‚ä§).HasBasis (fun a : Œ± => a < ‚ä§) fun a : Œ± => Ioi a := by
  have : ‚àÉ x : Œ±, x < ‚ä§ := (exists_ne ‚ä§).imp fun x hx => hx.lt_top
  simpa only [Iic_top, nhdsWithin_univ, Ioc_top] using nhdsLE_basis_of_exists_lt this

theorem nhds_bot_basis [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderBot Œ±] [OrderTopology Œ±]
    [Nontrivial Œ±] : (ùìù ‚ä•).HasBasis (fun a : Œ± => ‚ä• < a) fun a : Œ± => Iio a :=
  nhds_top_basis (Œ± := Œ±·µí·µà)

theorem nhds_top_basis_Ici [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTop Œ±] [OrderTopology Œ±]
    [Nontrivial Œ±] [DenselyOrdered Œ±] : (ùìù ‚ä§).HasBasis (fun a : Œ± => a < ‚ä§) Ici :=
  nhds_top_basis.to_hasBasis
    (fun _a ha => let ‚ü®b, hab, hb‚ü© := exists_between ha; ‚ü®b, hb, Ici_subset_Ioi.mpr hab‚ü©)
    fun a ha => ‚ü®a, ha, Ioi_subset_Ici_self‚ü©

theorem nhds_bot_basis_Iic [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderBot Œ±] [OrderTopology Œ±]
    [Nontrivial Œ±] [DenselyOrdered Œ±] : (ùìù ‚ä•).HasBasis (fun a : Œ± => ‚ä• < a) Iic :=
  nhds_top_basis_Ici (Œ± := Œ±·µí·µà)

theorem tendsto_nhds_top_mono [TopologicalSpace Œ≤] [Preorder Œ≤] [OrderTop Œ≤] [OrderTopology Œ≤]
    {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : Tendsto f l (ùìù ‚ä§)) (hg : f ‚â§·∂†[l] g) : Tendsto g l (ùìù ‚ä§) := by
  simp only [nhds_top_order, tendsto_iInf, tendsto_principal] at hf ‚ä¢
  intro x hx
  filter_upwards [hf x hx, hg] with _ using lt_of_lt_of_le

theorem tendsto_nhds_bot_mono [TopologicalSpace Œ≤] [Preorder Œ≤] [OrderBot Œ≤] [OrderTopology Œ≤]
    {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : Tendsto f l (ùìù ‚ä•)) (hg : g ‚â§·∂†[l] f) : Tendsto g l (ùìù ‚ä•) :=
  tendsto_nhds_top_mono (Œ≤ := Œ≤·µí·µà) hf hg

theorem tendsto_nhds_top_mono' [TopologicalSpace Œ≤] [Preorder Œ≤] [OrderTop Œ≤] [OrderTopology Œ≤]
    {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : Tendsto f l (ùìù ‚ä§)) (hg : f ‚â§ g) : Tendsto g l (ùìù ‚ä§) :=
  tendsto_nhds_top_mono hf (Eventually.of_forall hg)

theorem tendsto_nhds_bot_mono' [TopologicalSpace Œ≤] [Preorder Œ≤] [OrderBot Œ≤] [OrderTopology Œ≤]
    {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : Tendsto f l (ùìù ‚ä•)) (hg : g ‚â§ f) : Tendsto g l (ùìù ‚ä•) :=
  tendsto_nhds_bot_mono hf (Eventually.of_forall hg)

section LinearOrder

variable [TopologicalSpace Œ±] [LinearOrder Œ±]

section OrderTopology

theorem order_separated [OrderTopology Œ±] {a‚ÇÅ a‚ÇÇ : Œ±} (h : a‚ÇÅ < a‚ÇÇ) :
    ‚àÉ u v : Set Œ±, IsOpen u ‚àß IsOpen v ‚àß a‚ÇÅ ‚àà u ‚àß a‚ÇÇ ‚àà v ‚àß ‚àÄ b‚ÇÅ ‚àà u, ‚àÄ b‚ÇÇ ‚àà v, b‚ÇÅ < b‚ÇÇ :=
  let ‚ü®x, hx, y, hy, h‚ü© := h.exists_disjoint_Iio_Ioi
  ‚ü®Iio x, Ioi y, isOpen_gt' _, isOpen_lt' _, hx, hy, h‚ü©

-- see Note [lower instance priority]
instance (priority := 100) OrderTopology.to_orderClosedTopology [OrderTopology Œ±] :
    OrderClosedTopology Œ± where
  isClosed_le' := isOpen_compl_iff.1 <| isOpen_prod_iff.mpr fun a‚ÇÅ a‚ÇÇ (h : ¬¨a‚ÇÅ ‚â§ a‚ÇÇ) =>
    have h : a‚ÇÇ < a‚ÇÅ := lt_of_not_ge h
    let ‚ü®u, v, hu, hv, ha‚ÇÅ, ha‚ÇÇ, h‚ü© := order_separated h
    ‚ü®v, u, hv, hu, ha‚ÇÇ, ha‚ÇÅ, fun ‚ü®b‚ÇÅ, b‚ÇÇ‚ü© ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© => not_le_of_gt <| h b‚ÇÇ h‚ÇÇ b‚ÇÅ h‚ÇÅ‚ü©

theorem exists_Ioc_subset_of_mem_nhds [OrderTopology Œ±] {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a)
    (h : ‚àÉ l, l < a) : ‚àÉ l < a, Ioc l a ‚äÜ s :=
  (nhdsLE_basis_of_exists_lt h).mem_iff.mp (nhdsWithin_le_nhds hs)

theorem exists_Ioc_subset_of_mem_nhds' [OrderTopology Œ±] {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) {l : Œ±}
    (hl : l < a) : ‚àÉ l' ‚àà Ico l a, Ioc l' a ‚äÜ s :=
  let ‚ü®l', hl'a, hl's‚ü© := exists_Ioc_subset_of_mem_nhds hs ‚ü®l, hl‚ü©
  ‚ü®max l l', ‚ü®le_max_left _ _, max_lt hl hl'a‚ü©,
    (Ioc_subset_Ioc_left <| le_max_right _ _).trans hl's‚ü©

theorem exists_Ico_subset_of_mem_nhds' [OrderTopology Œ±] {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) {u : Œ±}
    (hu : a < u) : ‚àÉ u' ‚àà Ioc a u, Ico a u' ‚äÜ s := by
  simpa only [OrderDual.exists, exists_prop, Ico_toDual, Ioc_toDual] using
    exists_Ioc_subset_of_mem_nhds' (show ofDual ‚Åª¬π' s ‚àà ùìù (toDual a) from hs) hu.dual

theorem exists_Ico_subset_of_mem_nhds [OrderTopology Œ±] {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a)
    (h : ‚àÉ u, a < u) : ‚àÉ u, a < u ‚àß Ico a u ‚äÜ s :=
  let ‚ü®_l', hl'‚ü© := h
  let ‚ü®l, hl‚ü© := exists_Ico_subset_of_mem_nhds' hs hl'
  ‚ü®l, hl.1.1, hl.2‚ü©

theorem exists_Icc_mem_subset_of_mem_nhdsGE [OrderTopology Œ±] {a : Œ±} {s : Set Œ±}
    (hs : s ‚àà ùìù[‚â•] a) : ‚àÉ b, a ‚â§ b ‚àß Icc a b ‚àà ùìù[‚â•] a ‚àß Icc a b ‚äÜ s := by
  rcases (em (IsMax a)).imp_right not_isMax_iff.mp with (ha | ha)
  ¬∑ use a
    simpa [ha.Ici_eq] using hs
  ¬∑ rcases(nhdsGE_basis_of_exists_gt ha).mem_iff.mp hs with ‚ü®b, hab, hbs‚ü©
    rcases eq_empty_or_nonempty (Ioo a b) with (H | ‚ü®c, hac, hcb‚ü©)
    ¬∑ have : Ico a b = Icc a a := by rw [‚Üê Icc_union_Ioo_eq_Ico le_rfl hab, H, union_empty]
      exact ‚ü®a, le_rfl, this ‚ñ∏ ‚ü®Ico_mem_nhdsGE hab, hbs‚ü©‚ü©
    ¬∑ refine ‚ü®c, hac.le, Icc_mem_nhdsGE hac, ?_‚ü©
      exact (Icc_subset_Ico_right hcb).trans hbs

theorem exists_Icc_mem_subset_of_mem_nhdsLE [OrderTopology Œ±] {a : Œ±} {s : Set Œ±}
    (hs : s ‚àà ùìù[‚â§] a) : ‚àÉ b ‚â§ a, Icc b a ‚àà ùìù[‚â§] a ‚àß Icc b a ‚äÜ s := by
  simpa only [Icc_toDual, toDual.surjective.exists] using
    exists_Icc_mem_subset_of_mem_nhdsGE (Œ± := Œ±·µí·µà) (a := toDual a) hs

theorem exists_Icc_mem_subset_of_mem_nhds [OrderTopology Œ±] {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) :
    ‚àÉ b c, a ‚àà Icc b c ‚àß Icc b c ‚àà ùìù a ‚àß Icc b c ‚äÜ s := by
  rcases exists_Icc_mem_subset_of_mem_nhdsLE (nhdsWithin_le_nhds hs) with
    ‚ü®b, hba, hb_nhds, hbs‚ü©
  rcases exists_Icc_mem_subset_of_mem_nhdsGE (nhdsWithin_le_nhds hs) with
    ‚ü®c, hac, hc_nhds, hcs‚ü©
  refine ‚ü®b, c, ‚ü®hba, hac‚ü©, ?_‚ü©
  rw [‚Üê Icc_union_Icc_eq_Icc hba hac, ‚Üê nhdsLE_sup_nhdsGE]
  exact ‚ü®union_mem_sup hb_nhds hc_nhds, union_subset hbs hcs‚ü©

theorem IsOpen.exists_Ioo_subset [OrderTopology Œ±] [Nontrivial Œ±] {s : Set Œ±} (hs : IsOpen s)
    (h : s.Nonempty) : ‚àÉ a b, a < b ‚àß Ioo a b ‚äÜ s := by
  obtain ‚ü®x, hx‚ü© : ‚àÉ x, x ‚àà s := h
  obtain ‚ü®y, hy‚ü© : ‚àÉ y, y ‚â† x := exists_ne x
  rcases lt_trichotomy x y with (H | rfl | H)
  ¬∑ obtain ‚ü®u, xu, hu‚ü© : ‚àÉ u, x < u ‚àß Ico x u ‚äÜ s :=
      exists_Ico_subset_of_mem_nhds (hs.mem_nhds hx) ‚ü®y, H‚ü©
    exact ‚ü®x, u, xu, Ioo_subset_Ico_self.trans hu‚ü©
  ¬∑ exact (hy rfl).elim
  ¬∑ obtain ‚ü®l, lx, hl‚ü© : ‚àÉ l, l < x ‚àß Ioc l x ‚äÜ s :=
      exists_Ioc_subset_of_mem_nhds (hs.mem_nhds hx) ‚ü®y, H‚ü©
    exact ‚ü®l, x, lx, Ioo_subset_Ioc_self.trans hl‚ü©

theorem dense_of_exists_between [OrderTopology Œ±] [Nontrivial Œ±] {s : Set Œ±}
    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí ‚àÉ c ‚àà s, a < c ‚àß c < b) : Dense s := by
  refine dense_iff_inter_open.2 fun U U_open U_nonempty => ?_
  obtain ‚ü®a, b, hab, H‚ü© : ‚àÉ a b : Œ±, a < b ‚àß Ioo a b ‚äÜ U := U_open.exists_Ioo_subset U_nonempty
  obtain ‚ü®x, xs, hx‚ü© : ‚àÉ x ‚àà s, a < x ‚àß x < b := h hab
  exact ‚ü®x, ‚ü®H hx, xs‚ü©‚ü©

theorem IsUpperSet.isClosed [OrderTopology Œ±] [WellFoundedLT Œ±] {s : Set Œ±} (h : IsUpperSet s) :
    IsClosed s := by
  obtain rfl | ‚ü®a, rfl‚ü© := h.eq_empty_or_Ici
  exacts [isClosed_empty, isClosed_Ici]

theorem IsLowerSet.isClosed [OrderTopology Œ±] [WellFoundedGT Œ±] {s : Set Œ±} (h : IsLowerSet s) :
    IsClosed s :=
  h.toDual.isClosed

theorem IsLowerSet.isOpen [OrderTopology Œ±] [WellFoundedLT Œ±] {s : Set Œ±} (h : IsLowerSet s) :
    IsOpen s := by
  simpa using h.compl.isClosed

theorem IsUpperSet.isOpen [OrderTopology Œ±] [WellFoundedGT Œ±] {s : Set Œ±} (h : IsUpperSet s) :
    IsOpen s :=
  h.toDual.isOpen

/-- A set in a nontrivial densely linear ordered type is dense in the sense of topology if and only
if for any `a < b` there exists `c ‚àà s`, `a < c < b`. Each implication requires less typeclass
assumptions. -/
theorem dense_iff_exists_between [OrderTopology Œ±] [DenselyOrdered Œ±] [Nontrivial Œ±] {s : Set Œ±} :
    Dense s ‚Üî ‚àÄ a b, a < b ‚Üí ‚àÉ c ‚àà s, a < c ‚àß c < b :=
  ‚ü®fun h _ _ hab => h.exists_between hab, dense_of_exists_between‚ü©

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`,
provided `a` is neither a bottom element nor a top element. -/
theorem mem_nhds_iff_exists_Ioo_subset' [OrderTopology Œ±] {a : Œ±} {s : Set Œ±} (hl : ‚àÉ l, l < a)
    (hu : ‚àÉ u, a < u) : s ‚àà ùìù a ‚Üî ‚àÉ l u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s := by
  constructor
  ¬∑ intro h
    rcases exists_Ico_subset_of_mem_nhds h hu with ‚ü®u, au, hu‚ü©
    rcases exists_Ioc_subset_of_mem_nhds h hl with ‚ü®l, la, hl‚ü©
    exact ‚ü®l, u, ‚ü®la, au‚ü©, Ioc_union_Ico_eq_Ioo la au ‚ñ∏ union_subset hl hu‚ü©
  ¬∑ rintro ‚ü®l, u, ha, h‚ü©
    apply mem_of_superset (Ioo_mem_nhds ha.1 ha.2) h

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`.
-/
theorem mem_nhds_iff_exists_Ioo_subset [OrderTopology Œ±] [NoMaxOrder Œ±] [NoMinOrder Œ±] {a : Œ±}
    {s : Set Œ±} : s ‚àà ùìù a ‚Üî ‚àÉ l u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s :=
  mem_nhds_iff_exists_Ioo_subset' (exists_lt a) (exists_gt a)

theorem nhds_basis_Ioo' [OrderTopology Œ±] {a : Œ±} (hl : ‚àÉ l, l < a) (hu : ‚àÉ u, a < u) :
    (ùìù a).HasBasis (fun b : Œ± √ó Œ± => b.1 < a ‚àß a < b.2) fun b => Ioo b.1 b.2 :=
  ‚ü®fun s => (mem_nhds_iff_exists_Ioo_subset' hl hu).trans <| by simp‚ü©

theorem nhds_basis_Ioo [OrderTopology Œ±] [NoMaxOrder Œ±] [NoMinOrder Œ±] (a : Œ±) :
    (ùìù a).HasBasis (fun b : Œ± √ó Œ± => b.1 < a ‚àß a < b.2) fun b => Ioo b.1 b.2 :=
  nhds_basis_Ioo' (exists_lt a) (exists_gt a)

theorem Filter.Eventually.exists_Ioo_subset [OrderTopology Œ±] [NoMaxOrder Œ±] [NoMinOrder Œ±] {a : Œ±}
    {p : Œ± ‚Üí Prop} (hp : ‚àÄ·∂† x in ùìù a, p x) : ‚àÉ l u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ { x | p x } :=
  mem_nhds_iff_exists_Ioo_subset.1 hp

theorem Dense.topology_eq_generateFrom [OrderTopology Œ±] [DenselyOrdered Œ±] {s : Set Œ±}
    (hs : Dense s) : ‚ÄπTopologicalSpace Œ±‚Ä∫ = .generateFrom (Ioi '' s ‚à™ Iio '' s) := by
  refine (OrderTopology.topology_eq_generate_intervals (Œ± := Œ±)).trans ?_
  refine le_antisymm (generateFrom_anti ?_) (le_generateFrom ?_)
  ¬∑ simp only [union_subset_iff, image_subset_iff]
    exact ‚ü®fun a _ ‚Ü¶ ‚ü®a, .inl rfl‚ü©, fun a _ ‚Ü¶ ‚ü®a, .inr rfl‚ü©‚ü©
  ¬∑ rintro _ ‚ü®a, rfl | rfl‚ü©
    ¬∑ rw [hs.Ioi_eq_biUnion]
      let _ := generateFrom (Ioi '' s ‚à™ Iio '' s)
      exact isOpen_iUnion fun x ‚Ü¶ isOpen_iUnion fun h ‚Ü¶ .basic _ <| .inl <| mem_image_of_mem _ h.1
    ¬∑ rw [hs.Iio_eq_biUnion]
      let _ := generateFrom (Ioi '' s ‚à™ Iio '' s)
      exact isOpen_iUnion fun x ‚Ü¶ isOpen_iUnion fun h ‚Ü¶ .basic _ <| .inr <| mem_image_of_mem _ h.1

theorem PredOrder.hasBasis_nhds_Ioc_of_exists_gt [OrderTopology Œ±] [PredOrder Œ±] {a : Œ±}
    (ha : ‚àÉ u, a < u) : (ùìù a).HasBasis (a < ¬∑) (Set.Ico a ¬∑) :=
  PredOrder.nhdsGE_eq_nhds a ‚ñ∏ nhdsGE_basis_of_exists_gt ha

theorem PredOrder.hasBasis_nhds_Ioc [OrderTopology Œ±] [PredOrder Œ±] [NoMaxOrder Œ±] {a : Œ±} :
    (ùìù a).HasBasis (a < ¬∑) (Set.Ico a ¬∑) :=
  PredOrder.hasBasis_nhds_Ioc_of_exists_gt (exists_gt a)

theorem SuccOrder.hasBasis_nhds_Ioc_of_exists_lt [OrderTopology Œ±] [SuccOrder Œ±] {a : Œ±}
    (ha : ‚àÉ l, l < a) : (ùìù a).HasBasis (¬∑ < a) (Set.Ioc ¬∑ a) :=
  SuccOrder.nhdsLE_eq_nhds a ‚ñ∏ nhdsLE_basis_of_exists_lt ha

theorem SuccOrder.hasBasis_nhds_Ioc [OrderTopology Œ±] [SuccOrder Œ±] {a : Œ±} [NoMinOrder Œ±] :
    (ùìù a).HasBasis (¬∑ < a) (Set.Ioc ¬∑ a) :=
  SuccOrder.hasBasis_nhds_Ioc_of_exists_lt (exists_lt a)

variable (Œ±) in
/-- Let `Œ±` be a densely ordered linear order with order topology. If `Œ±` is a separable space, then
it has second countable topology. Note that the "densely ordered" assumption cannot be dropped, see
[double arrow space](https://topology.pi-base.org/spaces/S000093) for a counterexample. -/
theorem SecondCountableTopology.of_separableSpace_orderTopology [OrderTopology Œ±] [DenselyOrdered Œ±]
    [SeparableSpace Œ±] : SecondCountableTopology Œ± := by
  rcases exists_countable_dense Œ± with ‚ü®s, hc, hd‚ü©
  refine ‚ü®‚ü®_, ?_, hd.topology_eq_generateFrom‚ü©‚ü©
  exact (hc.image _).union (hc.image _)

/-- The set of points which are isolated on the right is countable when the space is
second-countable. -/
theorem countable_setOf_covBy_right [OrderTopology Œ±] [SecondCountableTopology Œ±] :
    Set.Countable { x : Œ± | ‚àÉ y, x ‚ãñ y } := by
  nontriviality Œ±
  let s := { x : Œ± | ‚àÉ y, x ‚ãñ y }
  have : ‚àÄ x ‚àà s, ‚àÉ y, x ‚ãñ y := fun x => id
  choose! y hy using this
  have Hy : ‚àÄ x z, x ‚àà s ‚Üí z < y x ‚Üí z ‚â§ x := fun x z hx => (hy x hx).le_of_lt
  suffices H : ‚àÄ a : Set Œ±, IsOpen a ‚Üí Set.Countable { x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a } by
    have : s ‚äÜ ‚ãÉ a ‚àà countableBasis Œ±, { x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a } := fun x hx => by
      rcases (isBasis_countableBasis Œ±).exists_mem_of_ne (hy x hx).ne with ‚ü®a, ab, xa, ya‚ü©
      exact mem_iUnion‚ÇÇ.2 ‚ü®a, ab, hx, xa, ya‚ü©
    refine Set.Countable.mono this ?_
    refine Countable.biUnion (countable_countableBasis Œ±) fun a ha => H _ ?_
    exact isOpen_of_mem_countableBasis ha
  intro a ha
  suffices H : Set.Countable { x | (x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a) ‚àß ¬¨IsBot x } from
    H.of_diff (subsingleton_isBot Œ±).countable
  simp only [and_assoc]
  let t := { x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a ‚àß ¬¨IsBot x }
  have : ‚àÄ x ‚àà t, ‚àÉ z < x, Ioc z x ‚äÜ a := by
    intro x hx
    apply exists_Ioc_subset_of_mem_nhds (ha.mem_nhds hx.2.1)
    simpa only [IsBot, not_forall, not_le] using hx.right.right.right
  choose! z hz h'z using this
  have : PairwiseDisjoint t fun x => Ioc (z x) x := fun x xt x' x't hxx' => by
    rcases hxx'.lt_or_gt with (h' | h')
    ¬∑ refine disjoint_left.2 fun u ux ux' => xt.2.2.1 ?_
      refine h'z x' x't ‚ü®ux'.1.trans_le (ux.2.trans (hy x xt.1).le), ?_‚ü©
      by_contra! H
      exact lt_irrefl _ ((Hy _ _ xt.1 H).trans_lt h')
    ¬∑ refine disjoint_left.2 fun u ux ux' => x't.2.2.1 ?_
      refine h'z x xt ‚ü®ux.1.trans_le (ux'.2.trans (hy x' x't.1).le), ?_‚ü©
      by_contra! H
      exact lt_irrefl _ ((Hy _ _ x't.1 H).trans_lt h')
  refine this.countable_of_isOpen (fun x hx => ?_) fun x hx => ‚ü®x, hz x hx, le_rfl‚ü©
  suffices H : Ioc (z x) x = Ioo (z x) (y x) by
    rw [H]
    exact isOpen_Ioo
  exact Subset.antisymm (Ioc_subset_Ioo_right (hy x hx.1).lt) fun u hu => ‚ü®hu.1, Hy _ _ hx.1 hu.2‚ü©

/-- The set of points which are isolated on the left is countable when the space is
second-countable. -/
theorem countable_setOf_covBy_left [OrderTopology Œ±] [SecondCountableTopology Œ±] :
    Set.Countable { x : Œ± | ‚àÉ y, y ‚ãñ x } := by
  convert countable_setOf_covBy_right (Œ± := Œ±·µí·µà) using 5
  exact toDual_covBy_toDual_iff.symm

/-- The set of points which are isolated on the left is countable when the space is
second-countable. -/
theorem countable_of_isolated_left' [OrderTopology Œ±] [SecondCountableTopology Œ±] :
    Set.Countable { x : Œ± | ‚àÉ y, y < x ‚àß Ioo y x = ‚àÖ } := by
  simpa only [‚Üê covBy_iff_Ioo_eq] using countable_setOf_covBy_left

/-- Consider a disjoint family of intervals `(x, y)` with `x < y` in a second-countable space.
Then the family is countable.
This is not a straightforward consequence of second-countability as some of these intervals might be
empty (but in fact this can happen only for countably many of them). -/
theorem Set.PairwiseDisjoint.countable_of_Ioo [OrderTopology Œ±] [SecondCountableTopology Œ±]
    {y : Œ± ‚Üí Œ±} {s : Set Œ±} (h : PairwiseDisjoint s fun x => Ioo x (y x))
    (h' : ‚àÄ x ‚àà s, x < y x) : s.Countable :=
  have : (s \ { x | ‚àÉ y, x ‚ãñ y }).Countable :=
    (h.subset diff_subset).countable_of_isOpen (fun _ _ => isOpen_Ioo)
      fun x hx => (h' _ hx.1).exists_lt_lt (mt (Exists.intro (y x)) hx.2)
  this.of_diff countable_setOf_covBy_right

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(x, ‚àû)` is separated above from `f x` is countable. We give
here a version relative to a set `t`. -/
theorem countable_image_lt_image_Ioi_within
    [OrderTopology Œ±] [LinearOrder Œ≤] [SecondCountableTopology Œ±] (t : Set Œ≤) (f : Œ≤ ‚Üí Œ±) :
    Set.Countable {x ‚àà t | ‚àÉ z, f x < z ‚àß ‚àÄ y ‚àà t, x < y ‚Üí z ‚â§ f y} := by
  /- If the values of `f` are separated above on the right of `x`, there is an interval `(f x, z x)`
    which is not reached by `f`. This gives a family of disjoint open intervals in `Œ±`. Such a
    family can only be countable as `Œ±` is second-countable. -/
  nontriviality Œ≤
  have : Nonempty Œ± := Nonempty.map f (by infer_instance)
  let s := {x ‚àà t | ‚àÉ z, f x < z ‚àß ‚àÄ y ‚àà t, x < y ‚Üí z ‚â§ f y}
  have : ‚àÄ x, x ‚àà s ‚Üí ‚àÉ z, f x < z ‚àß ‚àÄ y ‚àà t, x < y ‚Üí z ‚â§ f y := fun x hx ‚Ü¶ hx.2
  -- choose `z x` such that `f` does not take the values in `(f x, z x)`.
  choose! z hz using this
  have I : InjOn f s := by
    apply StrictMonoOn.injOn
    intro x hx y hy hxy
    calc
      f x < z x := (hz x hx).1
      _ ‚â§ f y := (hz x hx).2 y hy.1 hxy
  -- show that `f s` is countable by arguing that a disjoint family of disjoint open intervals
  -- (the intervals `(f x, z x)`) is at most countable.
  have fs_count : (f '' s).Countable := by
    have A : (f '' s).PairwiseDisjoint fun x => Ioo x (z (invFunOn f s x)) := by
      rintro _ ‚ü®u, us, rfl‚ü© _ ‚ü®v, vs, rfl‚ü© huv
      wlog hle : u ‚â§ v generalizing u v
      ¬∑ exact (this v vs u us huv.symm (le_of_not_ge hle)).symm
      have hlt : u < v := hle.lt_of_ne (ne_of_apply_ne _ huv)
      apply disjoint_iff_forall_ne.2
      rintro a ha b hb rfl
      simp only [I.leftInvOn_invFunOn us, I.leftInvOn_invFunOn vs] at ha hb
      exact lt_irrefl _ ((ha.2.trans_le ((hz u us).2 v vs.1 hlt)).trans hb.1)
    apply Set.PairwiseDisjoint.countable_of_Ioo A
    rintro _ ‚ü®y, ys, rfl‚ü©
    simpa only [I.leftInvOn_invFunOn ys] using (hz y ys).1
  exact MapsTo.countable_of_injOn (mapsTo_image f s) I fs_count

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(x, ‚àû)` is separated above from `f x` is countable. -/
theorem countable_image_lt_image_Ioi [OrderTopology Œ±] [LinearOrder Œ≤] (f : Œ≤ ‚Üí Œ±)
    [SecondCountableTopology Œ±] : Set.Countable {x | ‚àÉ z, f x < z ‚àß ‚àÄ y, x < y ‚Üí z ‚â§ f y} := by
  simpa using countable_image_lt_image_Ioi_within univ f

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(x, ‚àû)` is separated below from `f x` is countable. We give
here a version relative to a set `t`. -/
theorem countable_image_gt_image_Ioi_within
    [OrderTopology Œ±] [LinearOrder Œ≤] [SecondCountableTopology Œ±] (t : Set Œ≤) (f : Œ≤ ‚Üí Œ±) :
    Set.Countable {x ‚àà t | ‚àÉ z, z < f x ‚àß ‚àÄ y ‚àà t, x < y ‚Üí f y ‚â§ z} :=
  countable_image_lt_image_Ioi_within (Œ± := Œ±·µí·µà) t f

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(x, ‚àû)` is separated below from `f x` is countable. -/
theorem countable_image_gt_image_Ioi [OrderTopology Œ±] [LinearOrder Œ≤] (f : Œ≤ ‚Üí Œ±)
    [SecondCountableTopology Œ±] : Set.Countable {x | ‚àÉ z, z < f x ‚àß ‚àÄ y, x < y ‚Üí f y ‚â§ z} :=
  countable_image_lt_image_Ioi (Œ± := Œ±·µí·µà) f

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(-‚àû, x)` is separated above from `f x` is countable. We give
here a version relative to a set `t`. -/
theorem countable_image_lt_image_Iio_within
    [OrderTopology Œ±] [LinearOrder Œ≤] [SecondCountableTopology Œ±] (t : Set Œ≤) (f : Œ≤ ‚Üí Œ±) :
    Set.Countable {x ‚àà t | ‚àÉ z, f x < z ‚àß ‚àÄ y ‚àà t, y < x ‚Üí z ‚â§ f y} :=
  countable_image_lt_image_Ioi_within (Œ≤ := Œ≤·µí·µà) t f

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(-‚àû, x)` is separated above from `f x` is countable. -/
theorem countable_image_lt_image_Iio [OrderTopology Œ±] [LinearOrder Œ≤] (f : Œ≤ ‚Üí Œ±)
    [SecondCountableTopology Œ±] : Set.Countable {x | ‚àÉ z, f x < z ‚àß ‚àÄ y, y < x ‚Üí z ‚â§ f y} :=
  countable_image_lt_image_Ioi (Œ≤ := Œ≤·µí·µà) f

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(-‚àû, x)` is separated below from `f x` is countable. We give
here a version relative to a set `t`. -/
theorem countable_image_gt_image_Iio_within
    [OrderTopology Œ±] [LinearOrder Œ≤] [SecondCountableTopology Œ±] (t : Set Œ≤) (f : Œ≤ ‚Üí Œ±) :
    Set.Countable {x ‚àà t | ‚àÉ z, z < f x ‚àß ‚àÄ y ‚àà t, y < x ‚Üí f y ‚â§ z} :=
  countable_image_lt_image_Ioi_within (Œ± := Œ±·µí·µà) (Œ≤ := Œ≤·µí·µà) t f

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(-‚àû, x)` is separated below from `f x` is countable. -/
theorem countable_image_gt_image_Iio [OrderTopology Œ±] [LinearOrder Œ≤] (f : Œ≤ ‚Üí Œ±)
    [SecondCountableTopology Œ±] : Set.Countable {x | ‚àÉ z, z < f x ‚àß ‚àÄ y, y < x ‚Üí f y ‚â§ z} :=
  countable_image_lt_image_Ioi (Œ± := Œ±·µí·µà) (Œ≤ := Œ≤·µí·µà) f

instance instIsCountablyGenerated_atTop [OrderTopology Œ±] [SecondCountableTopology Œ±] :
    IsCountablyGenerated (atTop : Filter Œ±) := by
  by_cases h : ‚àÉ (x : Œ±), IsTop x
  ¬∑ rcases h with ‚ü®x, hx‚ü©
    rw [atTop_eq_pure_of_isTop hx]
    exact isCountablyGenerated_pure x
  ¬∑ rcases exists_countable_basis Œ± with ‚ü®b, b_count, b_ne, hb‚ü©
    have : Countable b := by exact Iff.mpr countable_coe_iff b_count
    have A : ‚àÄ (s : b), ‚àÉ (x : Œ±), x ‚àà (s : Set Œ±) := by
      intro s
      have : (s : Set Œ±) ‚â† ‚àÖ := by
        intro H
        apply b_ne
        convert s.2
        exact H.symm
      exact Iff.mp notMem_singleton_empty this
    choose a ha using A
    have : (atTop : Filter Œ±) = (generate (Ici '' (range a))) := by
      apply atTop_eq_generate_of_not_bddAbove
      intro ‚ü®x, hx‚ü©
      simp only [IsTop, not_exists, not_forall, not_le] at h
      rcases h x with ‚ü®y, hy‚ü©
      obtain ‚ü®s, sb, -, hs‚ü© : ‚àÉ s, s ‚àà b ‚àß y ‚àà s ‚àß s ‚äÜ Ioi x :=
        hb.exists_subset_of_mem_open hy isOpen_Ioi
      have I : a ‚ü®s, sb‚ü© ‚â§ x := hx (mem_range_self _)
      have J : x < a ‚ü®s, sb‚ü© := hs (ha ‚ü®s, sb‚ü©)
      exact lt_irrefl _ (I.trans_lt J)
    rw [this]
    exact ‚ü®_, (countable_range _).image _, rfl‚ü©

instance instIsCountablyGenerated_atBot [OrderTopology Œ±] [SecondCountableTopology Œ±] :
    IsCountablyGenerated (atBot : Filter Œ±) :=
  @instIsCountablyGenerated_atTop Œ±·µí·µà _ _ _ _

section Pi

/-!
### Intervals in `Œ† i, X i` belong to `ùìù x`

For each lemma `pi_Ixx_mem_nhds` we add a non-dependent version `pi_Ixx_mem_nhds'` because
sometimes Lean fails to unify different instances while trying to apply the dependent version to,
e.g., `Œπ ‚Üí ‚Ñù`.
-/

variable [OrderTopology Œ±] {Œπ : Type*} {X : Œπ ‚Üí Type*} [Finite Œπ] [‚àÄ i, LinearOrder (X i)]
  [‚àÄ i, TopologicalSpace (X i)] [‚àÄ i, OrderTopology (X i)] {a b x : ‚àÄ i, X i} {a' b' x' : Œπ ‚Üí Œ±}

theorem pi_Iic_mem_nhds (ha : ‚àÄ i, x i < a i) : Iic a ‚àà ùìù x :=
  pi_univ_Iic a ‚ñ∏ set_pi_mem_nhds (Set.toFinite _) fun _ _ => Iic_mem_nhds (ha _)

theorem pi_Iic_mem_nhds' (ha : ‚àÄ i, x' i < a' i) : Iic a' ‚àà ùìù x' :=
  pi_Iic_mem_nhds ha

theorem pi_Ici_mem_nhds (ha : ‚àÄ i, a i < x i) : Ici a ‚àà ùìù x :=
  pi_univ_Ici a ‚ñ∏ set_pi_mem_nhds (Set.toFinite _) fun _ _ => Ici_mem_nhds (ha _)

theorem pi_Ici_mem_nhds' (ha : ‚àÄ i, a' i < x' i) : Ici a' ‚àà ùìù x' :=
  pi_Ici_mem_nhds ha

theorem pi_Icc_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Icc a b ‚àà ùìù x :=
  pi_univ_Icc a b ‚ñ∏ set_pi_mem_nhds finite_univ fun _ _ => Icc_mem_nhds (ha _) (hb _)

theorem pi_Icc_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Icc a' b' ‚àà ùìù x' :=
  pi_Icc_mem_nhds ha hb

variable [Nonempty Œπ]

theorem pi_Iio_mem_nhds (ha : ‚àÄ i, x i < a i) : Iio a ‚àà ùìù x := mem_of_superset
  (set_pi_mem_nhds finite_univ fun i _ ‚Ü¶ Iio_mem_nhds (ha i)) (pi_univ_Iio_subset a)

theorem pi_Iio_mem_nhds' (ha : ‚àÄ i, x' i < a' i) : Iio a' ‚àà ùìù x' :=
  pi_Iio_mem_nhds ha

theorem pi_Ioi_mem_nhds (ha : ‚àÄ i, a i < x i) : Ioi a ‚àà ùìù x :=
  pi_Iio_mem_nhds (X := fun i => (X i)·µí·µà) ha

theorem pi_Ioi_mem_nhds' (ha : ‚àÄ i, a' i < x' i) : Ioi a' ‚àà ùìù x' :=
  pi_Ioi_mem_nhds ha

theorem pi_Ioc_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ioc a b ‚àà ùìù x := by
  refine mem_of_superset (set_pi_mem_nhds Set.finite_univ fun i _ => ?_) (pi_univ_Ioc_subset a b)
  exact Ioc_mem_nhds (ha i) (hb i)

theorem pi_Ioc_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ioc a' b' ‚àà ùìù x' :=
  pi_Ioc_mem_nhds ha hb

theorem pi_Ico_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ico a b ‚àà ùìù x := by
  refine mem_of_superset (set_pi_mem_nhds Set.finite_univ fun i _ => ?_) (pi_univ_Ico_subset a b)
  exact Ico_mem_nhds (ha i) (hb i)

theorem pi_Ico_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ico a' b' ‚àà ùìù x' :=
  pi_Ico_mem_nhds ha hb

theorem pi_Ioo_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ioo a b ‚àà ùìù x := by
  refine mem_of_superset (set_pi_mem_nhds Set.finite_univ fun i _ => ?_) (pi_univ_Ioo_subset a b)
  exact Ioo_mem_nhds (ha i) (hb i)

theorem pi_Ioo_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ioo a' b' ‚àà ùìù x' :=
  pi_Ioo_mem_nhds ha hb

end Pi

end OrderTopology

end LinearOrder

section ConditionallyCompleteLinearOrder
variable {X : Type*} [ConditionallyCompleteLinearOrder X] [TopologicalSpace X] [OrderTopology X]
variable {Y : Type*} [ConditionallyCompleteLinearOrder Y] [TopologicalSpace Y] [OrderTopology Y]
variable [DenselyOrdered X] {f : X ‚Üí Y} {x : X}

/-- An order-theoretically left-continuous function is topologically left-continuous, assuming
the function is between conditionally complete linear orders with order topologies, and the domain
is densely ordered. -/
lemma LeftOrdContinuous.continuousWithinAt_Iic (hf : LeftOrdContinuous f) :
    ContinuousWithinAt f (Iic x) x := by
  rw [ContinuousWithinAt, OrderTopology.topology_eq_generate_intervals (Œ± := Y)]
  simp_rw [TopologicalSpace.tendsto_nhds_generateFrom_iff, mem_nhdsWithin]
  rintro V ‚ü®z, rfl | rfl‚ü© hxz
  -- The case `V = Ioi z`.
  ¬∑ obtain ‚ü®_, ‚ü®a, hax, rfl‚ü©, hza‚ü© := (lt_isLUB_iff <| hf isLUB_Iio).mp hxz
    exact ‚ü®Ioi a, isOpen_Ioi, hax, fun b hab ‚Ü¶ hza.trans_le <| hf.mono hab.1.le‚ü©
  -- The case `V = Iio z`.
  ¬∑ exact ‚ü®univ, isOpen_univ, trivial, fun a ha ‚Ü¶ (hf.mono ha.2).trans_lt hxz‚ü©

/-- An order-theoretically right-continuous function is topologically right-continuous, assuming
the function is between conditionally complete linear orders with order topologies, and the domain
is densely ordered. -/
lemma RightOrdContinuous.continuousWithinAt_Ici (hf : RightOrdContinuous f) :
    ContinuousWithinAt f (Ici x) x := hf.orderDual.continuousWithinAt_Iic

end ConditionallyCompleteLinearOrder
