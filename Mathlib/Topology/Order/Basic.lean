/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro, Yury Kudryashov
-/
import Mathlib.Data.Set.Intervals.Pi
import Mathlib.Data.Set.Pointwise.Basic
import Mathlib.Order.Filter.Interval
import Mathlib.Tactic.TFAE
import Mathlib.Tactic.NormNum
import Mathlib.Topology.Order.LeftRight
import Mathlib.Topology.Order.OrderClosed

#align_import topology.order.basic from "leanprover-community/mathlib"@"3efd324a3a31eaa40c9d5bfc669c4fafee5f9423"

/-!
# Theory of topology on ordered spaces

## Main definitions

The order topology on an ordered space is the topology generated by all open intervals (or
equivalently by those of the form `(-‚àû, a)` and `(b, +‚àû)`). We define it as `Preorder.topology Œ±`.
However, we do *not* register it as an instance (as many existing ordered types already have
topologies, which would be equal but not definitionally equal to `Preorder.topology Œ±`). Instead,
we introduce a class `OrderTopology Œ±` (which is a `Prop`, also known as a mixin) saying that on
the type `Œ±` having already a topological space structure and a preorder structure, the topological
structure is equal to the order topology.

We prove many basic properties of such topologies.

## Main statements

This file contains the proofs of the following facts. For exact requirements
(`OrderClosedTopology` vs `OrderTopology`, `Preorder` vs `PartialOrder` vs `LinearOrder` etc)
see their statements.

* `exists_Ioc_subset_of_mem_nhds`, `exists_Ico_subset_of_mem_nhds` : if `x < y`, then any
  neighborhood of `x` includes an interval `[x, z)` for some `z ‚àà (x, y]`, and any neighborhood
  of `y` includes an interval `(z, y]` for some `z ‚àà [x, y)`.
* `tendsto_of_tendsto_of_tendsto_of_le_of_le` : theorem known as squeeze theorem,
  sandwich theorem, theorem of Carabinieri, and two policemen (and a drunk) theorem; if `g` and `h`
  both converge to `a`, and eventually `g x ‚â§ f x ‚â§ h x`, then `f` converges to `a`.

## Implementation notes

We do _not_ register the order topology as an instance on a preorder (or even on a linear order).
Indeed, on many such spaces, a topology has already been constructed in a different way (think
of the discrete spaces `‚Ñï` or `‚Ñ§`, or `‚Ñù` that could inherit a topology as the completion of `‚Ñö`),
and is in general not defeq to the one generated by the intervals. We make it available as a
definition `Preorder.topology Œ±` though, that can be registered as an instance when necessary, or
for specific types.
-/


open Set Filter TopologicalSpace Topology Function

open OrderDual (toDual ofDual)

universe u v w

variable {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w}

-- Porting note (#11215): TODO: define `Preorder.topology` before `OrderTopology` and reuse the def
/-- The order topology on an ordered type is the topology generated by open intervals. We register
it on a preorder, but it is mostly interesting in linear orders, where it is also order-closed.
We define it as a mixin. If you want to introduce the order topology on a preorder, use
`Preorder.topology`. -/
class OrderTopology (Œ± : Type*) [t : TopologicalSpace Œ±] [Preorder Œ±] : Prop where
  /-- The topology is generated by open intervals `Set.Ioi _` and `Set.Iio _`. -/
  topology_eq_generate_intervals : t = generateFrom { s | ‚àÉ a, s = Ioi a ‚à® s = Iio a }
#align order_topology OrderTopology

/-- (Order) topology on a partial order `Œ±` generated by the subbase of open intervals
`(a, ‚àû) = { x ‚à£ a < x }, (-‚àû , b) = {x ‚à£ x < b}` for all `a, b` in `Œ±`. We do not register it as an
instance as many ordered sets are already endowed with the same topology, most often in a non-defeq
way though. Register as a local instance when necessary. -/
def Preorder.topology (Œ± : Type*) [Preorder Œ±] : TopologicalSpace Œ± :=
  generateFrom { s : Set Œ± | ‚àÉ a : Œ±, s = { b : Œ± | a < b } ‚à® s = { b : Œ± | b < a } }
#align preorder.topology Preorder.topology

section OrderTopology

section Preorder

variable [TopologicalSpace Œ±] [Preorder Œ±] [t : OrderTopology Œ±]

instance : OrderTopology Œ±·µí·µà :=
  ‚ü®by
    convert OrderTopology.topology_eq_generate_intervals (Œ± := Œ±) using 6
    apply or_comm‚ü©

theorem isOpen_iff_generate_intervals {s : Set Œ±} :
    IsOpen s ‚Üî GenerateOpen { s | ‚àÉ a, s = Ioi a ‚à® s = Iio a } s := by
  rw [t.topology_eq_generate_intervals]; rfl
#align is_open_iff_generate_intervals isOpen_iff_generate_intervals

theorem isOpen_lt' (a : Œ±) : IsOpen { b : Œ± | a < b } :=
  isOpen_iff_generate_intervals.2 <| .basic _ ‚ü®a, .inl rfl‚ü©
#align is_open_lt' isOpen_lt'

theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=
  isOpen_iff_generate_intervals.2 <| .basic _ ‚ü®a, .inr rfl‚ü©
#align is_open_gt' isOpen_gt'

theorem lt_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù b, a < x :=
  (isOpen_lt' _).mem_nhds h
#align lt_mem_nhds lt_mem_nhds

theorem le_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù b, a ‚â§ x :=
  (lt_mem_nhds h).mono fun _ => le_of_lt
#align le_mem_nhds le_mem_nhds

theorem gt_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù a, x < b :=
  (isOpen_gt' _).mem_nhds h
#align gt_mem_nhds gt_mem_nhds

theorem ge_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù a, x ‚â§ b :=
  (gt_mem_nhds h).mono fun _ => le_of_lt
#align ge_mem_nhds ge_mem_nhds

theorem nhds_eq_order (a : Œ±) : ùìù a = (‚®Ö b ‚àà Iio a, ùìü (Ioi b)) ‚äì ‚®Ö b ‚àà Ioi a, ùìü (Iio b) := by
  rw [t.topology_eq_generate_intervals, nhds_generateFrom]
  simp_rw [mem_setOf_eq, @and_comm (a ‚àà _), exists_or, or_and_right, iInf_or, iInf_and, iInf_exists,
    iInf_inf_eq, iInf_comm (Œπ := Set Œ±), iInf_iInf_eq_left, mem_Ioi, mem_Iio]
#align nhds_eq_order nhds_eq_order

theorem tendsto_order {f : Œ≤ ‚Üí Œ±} {a : Œ±} {x : Filter Œ≤} :
    Tendsto f x (ùìù a) ‚Üî (‚àÄ a' < a, ‚àÄ·∂† b in x, a' < f b) ‚àß ‚àÄ a' > a, ‚àÄ·∂† b in x, f b < a' := by
  simp only [nhds_eq_order a, tendsto_inf, tendsto_iInf, tendsto_principal]; rfl
#align tendsto_order tendsto_order

instance tendstoIccClassNhds (a : Œ±) : TendstoIxxClass Icc (ùìù a) (ùìù a) := by
  simp only [nhds_eq_order, iInf_subtype']
  refine
    ((hasBasis_iInf_principal_finite _).inf (hasBasis_iInf_principal_finite _)).tendstoIxxClass
      fun s _ => ?_
  refine' ((ordConnected_biInter _).inter (ordConnected_biInter _)).out <;> intro _ _
  exacts [ordConnected_Ioi, ordConnected_Iio]
#align tendsto_Icc_class_nhds tendstoIccClassNhds

instance tendstoIcoClassNhds (a : Œ±) : TendstoIxxClass Ico (ùìù a) (ùìù a) :=
  tendstoIxxClass_of_subset fun _ _ => Ico_subset_Icc_self
#align tendsto_Ico_class_nhds tendstoIcoClassNhds

instance tendstoIocClassNhds (a : Œ±) : TendstoIxxClass Ioc (ùìù a) (ùìù a) :=
  tendstoIxxClass_of_subset fun _ _ => Ioc_subset_Icc_self
#align tendsto_Ioc_class_nhds tendstoIocClassNhds

instance tendstoIooClassNhds (a : Œ±) : TendstoIxxClass Ioo (ùìù a) (ùìù a) :=
  tendstoIxxClass_of_subset fun _ _ => Ioo_subset_Icc_self
#align tendsto_Ioo_class_nhds tendstoIooClassNhds

/-- **Squeeze theorem** (also known as **sandwich theorem**). This version assumes that inequalities
hold eventually for the filter. -/
theorem tendsto_of_tendsto_of_tendsto_of_le_of_le' {f g h : Œ≤ ‚Üí Œ±} {b : Filter Œ≤} {a : Œ±}
    (hg : Tendsto g b (ùìù a)) (hh : Tendsto h b (ùìù a)) (hgf : ‚àÄ·∂† b in b, g b ‚â§ f b)
    (hfh : ‚àÄ·∂† b in b, f b ‚â§ h b) : Tendsto f b (ùìù a) :=
  (hg.Icc hh).of_smallSets <| hgf.and hfh
#align tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_of_tendsto_of_tendsto_of_le_of_le'

/-- **Squeeze theorem** (also known as **sandwich theorem**). This version assumes that inequalities
hold everywhere. -/
theorem tendsto_of_tendsto_of_tendsto_of_le_of_le {f g h : Œ≤ ‚Üí Œ±} {b : Filter Œ≤} {a : Œ±}
    (hg : Tendsto g b (ùìù a)) (hh : Tendsto h b (ùìù a)) (hgf : g ‚â§ f) (hfh : f ‚â§ h) :
    Tendsto f b (ùìù a) :=
  tendsto_of_tendsto_of_tendsto_of_le_of_le' hg hh (eventually_of_forall hgf)
    (eventually_of_forall hfh)
#align tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_of_tendsto_of_tendsto_of_le_of_le

theorem nhds_order_unbounded {a : Œ±} (hu : ‚àÉ u, a < u) (hl : ‚àÉ l, l < a) :
    ùìù a = ‚®Ö (l) (_ : l < a) (u) (_ : a < u), ùìü (Ioo l u) := by
  simp only [nhds_eq_order, ‚Üê inf_biInf, ‚Üê biInf_inf, *, ‚Üê inf_principal, ‚Üê Ioi_inter_Iio]; rfl
#align nhds_order_unbounded nhds_order_unbounded

theorem tendsto_order_unbounded {f : Œ≤ ‚Üí Œ±} {a : Œ±} {x : Filter Œ≤} (hu : ‚àÉ u, a < u)
    (hl : ‚àÉ l, l < a) (h : ‚àÄ l u, l < a ‚Üí a < u ‚Üí ‚àÄ·∂† b in x, l < f b ‚àß f b < u) :
    Tendsto f x (ùìù a) := by
  simp only [nhds_order_unbounded hu hl, tendsto_iInf, tendsto_principal]
  exact fun l hl u => h l u hl
#align tendsto_order_unbounded tendsto_order_unbounded

end Preorder

instance tendstoIxxNhdsWithin {Œ± : Type*} [TopologicalSpace Œ±] (a : Œ±) {s t : Set Œ±}
    {Ixx} [TendstoIxxClass Ixx (ùìù a) (ùìù a)] [TendstoIxxClass Ixx (ùìü s) (ùìü t)] :
    TendstoIxxClass Ixx (ùìù[s] a) (ùìù[t] a) :=
  Filter.tendstoIxxClass_inf
#align tendsto_Ixx_nhds_within tendstoIxxNhdsWithin

instance tendstoIccClassNhdsPi {Œπ : Type*} {Œ± : Œπ ‚Üí Type*} [‚àÄ i, Preorder (Œ± i)]
    [‚àÄ i, TopologicalSpace (Œ± i)] [‚àÄ i, OrderTopology (Œ± i)] (f : ‚àÄ i, Œ± i) :
    TendstoIxxClass Icc (ùìù f) (ùìù f) := by
  constructor
  conv in (ùìù f).smallSets => rw [nhds_pi, Filter.pi]
  simp only [smallSets_iInf, smallSets_comap, tendsto_iInf, tendsto_lift', (¬∑ ‚àò ¬∑),
    mem_powerset_iff]
  intro i s hs
  have : Tendsto (fun g : ‚àÄ i, Œ± i => g i) (ùìù f) (ùìù (f i)) := (continuous_apply i).tendsto f
  refine' (tendsto_lift'.1 ((this.comp tendsto_fst).Icc (this.comp tendsto_snd)) s hs).mono _
  exact fun p hp g hg => hp ‚ü®hg.1 _, hg.2 _‚ü©
#align tendsto_Icc_class_nhds_pi tendstoIccClassNhdsPi

-- Porting note (#10756): new lemma
theorem induced_topology_le_preorder [Preorder Œ±] [Preorder Œ≤] [TopologicalSpace Œ≤]
    [OrderTopology Œ≤] {f : Œ± ‚Üí Œ≤} (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y) :
    induced f ‚ÄπTopologicalSpace Œ≤‚Ä∫ ‚â§ Preorder.topology Œ± := by
  let _ := Preorder.topology Œ±; have : OrderTopology Œ± := ‚ü®rfl‚ü©
  refine le_of_nhds_le_nhds fun x => ?_
  simp only [nhds_eq_order, nhds_induced, comap_inf, comap_iInf, comap_principal, Ioi, Iio, ‚Üê hf]
  refine inf_le_inf (le_iInf‚ÇÇ fun a ha => ?_) (le_iInf‚ÇÇ fun a ha => ?_)
  exacts [iInf‚ÇÇ_le (f a) ha, iInf‚ÇÇ_le (f a) ha]

-- Porting note (#10756): new lemma
theorem induced_topology_eq_preorder [Preorder Œ±] [Preorder Œ≤] [TopologicalSpace Œ≤]
    [OrderTopology Œ≤] {f : Œ± ‚Üí Œ≤} (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)
    (H‚ÇÅ : ‚àÄ {a b x}, b < f a ‚Üí ¬¨(b < f x) ‚Üí ‚àÉ y, y < a ‚àß b ‚â§ f y)
    (H‚ÇÇ : ‚àÄ {a b x}, f a < b ‚Üí ¬¨(f x < b) ‚Üí ‚àÉ y, a < y ‚àß f y ‚â§ b) :
    induced f ‚ÄπTopologicalSpace Œ≤‚Ä∫ = Preorder.topology Œ± := by
  let _ := Preorder.topology Œ±; have : OrderTopology Œ± := ‚ü®rfl‚ü©
  refine le_antisymm (induced_topology_le_preorder hf) ?_
  refine le_of_nhds_le_nhds fun a => ?_
  simp only [nhds_eq_order, nhds_induced, comap_inf, comap_iInf, comap_principal]
  refine inf_le_inf (le_iInf‚ÇÇ fun b hb => ?_) (le_iInf‚ÇÇ fun b hb => ?_)
  ¬∑ rcases em (‚àÉ x, ¬¨(b < f x)) with (‚ü®x, hx‚ü© | hb)
    ¬∑ rcases H‚ÇÅ hb hx with ‚ü®y, hya, hyb‚ü©
      exact iInf‚ÇÇ_le_of_le y hya (principal_mono.2 fun z hz => hyb.trans_lt (hf.2 hz))
    ¬∑ push_neg at hb
      exact le_principal_iff.2 (univ_mem' hb)
  ¬∑ rcases em (‚àÉ x, ¬¨(f x < b)) with (‚ü®x, hx‚ü© | hb)
    ¬∑ rcases H‚ÇÇ hb hx with ‚ü®y, hya, hyb‚ü©
      exact iInf‚ÇÇ_le_of_le y hya (principal_mono.2 fun z hz => (hf.2 hz).trans_le hyb)
    ¬∑ push_neg at hb
      exact le_principal_iff.2 (univ_mem' hb)

theorem induced_orderTopology' {Œ± : Type u} {Œ≤ : Type v} [Preorder Œ±] [ta : TopologicalSpace Œ≤]
    [Preorder Œ≤] [OrderTopology Œ≤] (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)
    (H‚ÇÅ : ‚àÄ {a x}, x < f a ‚Üí ‚àÉ b < a, x ‚â§ f b) (H‚ÇÇ : ‚àÄ {a x}, f a < x ‚Üí ‚àÉ b > a, f b ‚â§ x) :
    @OrderTopology _ (induced f ta) _ :=
  let _ := induced f ta
  ‚ü®induced_topology_eq_preorder hf (fun h _ => H‚ÇÅ h) (fun h _ => H‚ÇÇ h)‚ü©
#align induced_order_topology' induced_orderTopology'

theorem induced_orderTopology {Œ± : Type u} {Œ≤ : Type v} [Preorder Œ±] [ta : TopologicalSpace Œ≤]
    [Preorder Œ≤] [OrderTopology Œ≤] (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)
    (H : ‚àÄ {x y}, x < y ‚Üí ‚àÉ a, x < f a ‚àß f a < y) : @OrderTopology _ (induced f ta) _ :=
  induced_orderTopology' f (hf)
    (fun xa => let ‚ü®b, xb, ba‚ü© := H xa; ‚ü®b, hf.1 ba, le_of_lt xb‚ü©)
    fun ax => let ‚ü®b, ab, bx‚ü© := H ax; ‚ü®b, hf.1 ab, le_of_lt bx‚ü©
#align induced_order_topology induced_orderTopology

/-- The topology induced by a strictly monotone function with order-connected range is the preorder
topology. -/
nonrec theorem StrictMono.induced_topology_eq_preorder {Œ± Œ≤ : Type*} [LinearOrder Œ±]
    [LinearOrder Œ≤] [t : TopologicalSpace Œ≤] [OrderTopology Œ≤] {f : Œ± ‚Üí Œ≤}
    (hf : StrictMono f) (hc : OrdConnected (range f)) : t.induced f = Preorder.topology Œ± := by
  refine induced_topology_eq_preorder hf.lt_iff_lt (fun h‚ÇÅ h‚ÇÇ => ?_) fun h‚ÇÅ h‚ÇÇ => ?_
  ¬∑ rcases hc.out (mem_range_self _) (mem_range_self _) ‚ü®not_lt.1 h‚ÇÇ, h‚ÇÅ.le‚ü© with ‚ü®y, rfl‚ü©
    exact ‚ü®y, hf.lt_iff_lt.1 h‚ÇÅ, le_rfl‚ü©
  ¬∑ rcases hc.out (mem_range_self _) (mem_range_self _) ‚ü®h‚ÇÅ.le, not_lt.1 h‚ÇÇ‚ü© with ‚ü®y, rfl‚ü©
    exact ‚ü®y, hf.lt_iff_lt.1 h‚ÇÅ, le_rfl‚ü©

/-- A strictly monotone function between linear orders with order topology is a topological
embedding provided that the range of `f` is order-connected. -/
theorem StrictMono.embedding_of_ordConnected {Œ± Œ≤ : Type*} [LinearOrder Œ±] [LinearOrder Œ≤]
    [TopologicalSpace Œ±] [h : OrderTopology Œ±] [TopologicalSpace Œ≤] [OrderTopology Œ≤] {f : Œ± ‚Üí Œ≤}
    (hf : StrictMono f) (hc : OrdConnected (range f)) : Embedding f :=
  ‚ü®‚ü®h.1.trans <| Eq.symm <| hf.induced_topology_eq_preorder hc‚ü©, hf.injective‚ü©

/-- On a `Set.OrdConnected` subset of a linear order, the order topology for the restriction of the
order is the same as the restriction to the subset of the order topology. -/
instance orderTopology_of_ordConnected {Œ± : Type u} [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderTopology Œ±] {t : Set Œ±} [ht : OrdConnected t] : OrderTopology t :=
  ‚ü®(Subtype.strictMono_coe t).induced_topology_eq_preorder <| by
    rwa [‚Üê @Subtype.range_val _ t] at ht‚ü©
#align order_topology_of_ord_connected orderTopology_of_ordConnected

theorem nhdsWithin_Ici_eq'' [TopologicalSpace Œ±] [Preorder Œ±] [OrderTopology Œ±] (a : Œ±) :
    ùìù[‚â•] a = (‚®Ö (u) (_ : a < u), ùìü (Iio u)) ‚äì ùìü (Ici a) := by
  rw [nhdsWithin, nhds_eq_order]
  refine' le_antisymm (inf_le_inf_right _ inf_le_right) (le_inf (le_inf _ inf_le_left) inf_le_right)
  exact inf_le_right.trans (le_iInf‚ÇÇ fun l hl => principal_mono.2 <| Ici_subset_Ioi.2 hl)
#align nhds_within_Ici_eq'' nhdsWithin_Ici_eq''

theorem nhdsWithin_Iic_eq'' [TopologicalSpace Œ±] [Preorder Œ±] [OrderTopology Œ±] (a : Œ±) :
    ùìù[‚â§] a = (‚®Ö l < a, ùìü (Ioi l)) ‚äì ùìü (Iic a) :=
  nhdsWithin_Ici_eq'' (toDual a)
#align nhds_within_Iic_eq'' nhdsWithin_Iic_eq''

theorem nhdsWithin_Ici_eq' [TopologicalSpace Œ±] [Preorder Œ±] [OrderTopology Œ±] {a : Œ±}
    (ha : ‚àÉ u, a < u) : ùìù[‚â•] a = ‚®Ö (u) (_ : a < u), ùìü (Ico a u) := by
  simp only [nhdsWithin_Ici_eq'', biInf_inf ha, inf_principal, Iio_inter_Ici]
#align nhds_within_Ici_eq' nhdsWithin_Ici_eq'

theorem nhdsWithin_Iic_eq' [TopologicalSpace Œ±] [Preorder Œ±] [OrderTopology Œ±] {a : Œ±}
    (ha : ‚àÉ l, l < a) : ùìù[‚â§] a = ‚®Ö l < a, ùìü (Ioc l a) := by
  simp only [nhdsWithin_Iic_eq'', biInf_inf ha, inf_principal, Ioi_inter_Iic]
#align nhds_within_Iic_eq' nhdsWithin_Iic_eq'

theorem nhdsWithin_Ici_basis' [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] {a : Œ±}
    (ha : ‚àÉ u, a < u) : (ùìù[‚â•] a).HasBasis (fun u => a < u) fun u => Ico a u :=
  (nhdsWithin_Ici_eq' ha).symm ‚ñ∏
    hasBasis_biInf_principal
      (fun b hb c hc => ‚ü®min b c, lt_min hb hc, Ico_subset_Ico_right (min_le_left _ _),
        Ico_subset_Ico_right (min_le_right _ _)‚ü©)
      ha
#align nhds_within_Ici_basis' nhdsWithin_Ici_basis'

theorem nhdsWithin_Iic_basis' [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] {a : Œ±}
    (ha : ‚àÉ l, l < a) : (ùìù[‚â§] a).HasBasis (fun l => l < a) fun l => Ioc l a := by
  convert nhdsWithin_Ici_basis' (Œ± := Œ±·µí·µà) ha using 2
  exact dual_Ico.symm
#align nhds_within_Iic_basis' nhdsWithin_Iic_basis'

theorem nhdsWithin_Ici_basis [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [NoMaxOrder Œ±]
    (a : Œ±) : (ùìù[‚â•] a).HasBasis (fun u => a < u) fun u => Ico a u :=
  nhdsWithin_Ici_basis' (exists_gt a)
#align nhds_within_Ici_basis nhdsWithin_Ici_basis

theorem nhdsWithin_Iic_basis [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [NoMinOrder Œ±]
    (a : Œ±) : (ùìù[‚â§] a).HasBasis (fun l => l < a) fun l => Ioc l a :=
  nhdsWithin_Iic_basis' (exists_lt a)
#align nhds_within_Iic_basis nhdsWithin_Iic_basis

theorem nhds_top_order [TopologicalSpace Œ±] [Preorder Œ±] [OrderTop Œ±] [OrderTopology Œ±] :
    ùìù (‚ä§ : Œ±) = ‚®Ö (l) (h‚ÇÇ : l < ‚ä§), ùìü (Ioi l) := by simp [nhds_eq_order (‚ä§ : Œ±)]
#align nhds_top_order nhds_top_order

theorem nhds_bot_order [TopologicalSpace Œ±] [Preorder Œ±] [OrderBot Œ±] [OrderTopology Œ±] :
    ùìù (‚ä• : Œ±) = ‚®Ö (l) (h‚ÇÇ : ‚ä• < l), ùìü (Iio l) := by simp [nhds_eq_order (‚ä• : Œ±)]
#align nhds_bot_order nhds_bot_order

theorem nhds_top_basis [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTop Œ±] [OrderTopology Œ±]
    [Nontrivial Œ±] : (ùìù ‚ä§).HasBasis (fun a : Œ± => a < ‚ä§) fun a : Œ± => Ioi a := by
  have : ‚àÉ x : Œ±, x < ‚ä§ := (exists_ne ‚ä§).imp fun x hx => hx.lt_top
  simpa only [Iic_top, nhdsWithin_univ, Ioc_top] using nhdsWithin_Iic_basis' this
#align nhds_top_basis nhds_top_basis

theorem nhds_bot_basis [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderBot Œ±] [OrderTopology Œ±]
    [Nontrivial Œ±] : (ùìù ‚ä•).HasBasis (fun a : Œ± => ‚ä• < a) fun a : Œ± => Iio a :=
  nhds_top_basis (Œ± := Œ±·µí·µà)
#align nhds_bot_basis nhds_bot_basis

theorem nhds_top_basis_Ici [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTop Œ±] [OrderTopology Œ±]
    [Nontrivial Œ±] [DenselyOrdered Œ±] : (ùìù ‚ä§).HasBasis (fun a : Œ± => a < ‚ä§) Ici :=
  nhds_top_basis.to_hasBasis
    (fun _a ha => let ‚ü®b, hab, hb‚ü© := exists_between ha; ‚ü®b, hb, Ici_subset_Ioi.mpr hab‚ü©)
    fun a ha => ‚ü®a, ha, Ioi_subset_Ici_self‚ü©
#align nhds_top_basis_Ici nhds_top_basis_Ici

theorem nhds_bot_basis_Iic [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderBot Œ±] [OrderTopology Œ±]
    [Nontrivial Œ±] [DenselyOrdered Œ±] : (ùìù ‚ä•).HasBasis (fun a : Œ± => ‚ä• < a) Iic :=
  nhds_top_basis_Ici (Œ± := Œ±·µí·µà)
#align nhds_bot_basis_Iic nhds_bot_basis_Iic

theorem tendsto_nhds_top_mono [TopologicalSpace Œ≤] [Preorder Œ≤] [OrderTop Œ≤] [OrderTopology Œ≤]
    {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : Tendsto f l (ùìù ‚ä§)) (hg : f ‚â§·∂†[l] g) : Tendsto g l (ùìù ‚ä§) := by
  simp only [nhds_top_order, tendsto_iInf, tendsto_principal] at hf ‚ä¢
  intro x hx
  filter_upwards [hf x hx, hg] with _ using lt_of_lt_of_le
#align tendsto_nhds_top_mono tendsto_nhds_top_mono

theorem tendsto_nhds_bot_mono [TopologicalSpace Œ≤] [Preorder Œ≤] [OrderBot Œ≤] [OrderTopology Œ≤]
    {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : Tendsto f l (ùìù ‚ä•)) (hg : g ‚â§·∂†[l] f) : Tendsto g l (ùìù ‚ä•) :=
  tendsto_nhds_top_mono (Œ≤ := Œ≤·µí·µà) hf hg
#align tendsto_nhds_bot_mono tendsto_nhds_bot_mono

theorem tendsto_nhds_top_mono' [TopologicalSpace Œ≤] [Preorder Œ≤] [OrderTop Œ≤] [OrderTopology Œ≤]
    {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : Tendsto f l (ùìù ‚ä§)) (hg : f ‚â§ g) : Tendsto g l (ùìù ‚ä§) :=
  tendsto_nhds_top_mono hf (eventually_of_forall hg)
#align tendsto_nhds_top_mono' tendsto_nhds_top_mono'

theorem tendsto_nhds_bot_mono' [TopologicalSpace Œ≤] [Preorder Œ≤] [OrderBot Œ≤] [OrderTopology Œ≤]
    {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : Tendsto f l (ùìù ‚ä•)) (hg : g ‚â§ f) : Tendsto g l (ùìù ‚ä•) :=
  tendsto_nhds_bot_mono hf (eventually_of_forall hg)
#align tendsto_nhds_bot_mono' tendsto_nhds_bot_mono'

section LinearOrder

variable [TopologicalSpace Œ±] [LinearOrder Œ±]

section OrderTopology

variable [OrderTopology Œ±]

theorem order_separated {a‚ÇÅ a‚ÇÇ : Œ±} (h : a‚ÇÅ < a‚ÇÇ) :
    ‚àÉ u v : Set Œ±, IsOpen u ‚àß IsOpen v ‚àß a‚ÇÅ ‚àà u ‚àß a‚ÇÇ ‚àà v ‚àß ‚àÄ b‚ÇÅ ‚àà u, ‚àÄ b‚ÇÇ ‚àà v, b‚ÇÅ < b‚ÇÇ :=
  let ‚ü®x, hx, y, hy, h‚ü© := h.exists_disjoint_Iio_Ioi
  ‚ü®Iio x, Ioi y, isOpen_gt' _, isOpen_lt' _, hx, hy, h‚ü©
#align order_separated order_separated

-- see Note [lower instance priority]
instance (priority := 100) OrderTopology.to_orderClosedTopology : OrderClosedTopology Œ± where
  isClosed_le' := isOpen_compl_iff.1 <| isOpen_prod_iff.mpr fun a‚ÇÅ a‚ÇÇ (h : ¬¨a‚ÇÅ ‚â§ a‚ÇÇ) =>
    have h : a‚ÇÇ < a‚ÇÅ := lt_of_not_ge h
    let ‚ü®u, v, hu, hv, ha‚ÇÅ, ha‚ÇÇ, h‚ü© := order_separated h
    ‚ü®v, u, hv, hu, ha‚ÇÇ, ha‚ÇÅ, fun ‚ü®b‚ÇÅ, b‚ÇÇ‚ü© ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© => not_le_of_gt <| h b‚ÇÇ h‚ÇÇ b‚ÇÅ h‚ÇÅ‚ü©
#align order_topology.to_order_closed_topology OrderTopology.to_orderClosedTopology

theorem exists_Ioc_subset_of_mem_nhds {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) (h : ‚àÉ l, l < a) :
    ‚àÉ l < a, Ioc l a ‚äÜ s :=
  (nhdsWithin_Iic_basis' h).mem_iff.mp (nhdsWithin_le_nhds hs)
#align exists_Ioc_subset_of_mem_nhds exists_Ioc_subset_of_mem_nhds

theorem exists_Ioc_subset_of_mem_nhds' {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) {l : Œ±} (hl : l < a) :
    ‚àÉ l' ‚àà Ico l a, Ioc l' a ‚äÜ s :=
  let ‚ü®l', hl'a, hl's‚ü© := exists_Ioc_subset_of_mem_nhds hs ‚ü®l, hl‚ü©
  ‚ü®max l l', ‚ü®le_max_left _ _, max_lt hl hl'a‚ü©,
    (Ioc_subset_Ioc_left <| le_max_right _ _).trans hl's‚ü©
#align exists_Ioc_subset_of_mem_nhds' exists_Ioc_subset_of_mem_nhds'

theorem exists_Ico_subset_of_mem_nhds' {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) {u : Œ±} (hu : a < u) :
    ‚àÉ u' ‚àà Ioc a u, Ico a u' ‚äÜ s := by
  simpa only [OrderDual.exists, exists_prop, dual_Ico, dual_Ioc] using
    exists_Ioc_subset_of_mem_nhds' (show ofDual ‚Åª¬π' s ‚àà ùìù (toDual a) from hs) hu.dual
#align exists_Ico_subset_of_mem_nhds' exists_Ico_subset_of_mem_nhds'

theorem exists_Ico_subset_of_mem_nhds {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) (h : ‚àÉ u, a < u) :
    ‚àÉ u, a < u ‚àß Ico a u ‚äÜ s :=
  let ‚ü®_l', hl'‚ü© := h;
  let ‚ü®l, hl‚ü© := exists_Ico_subset_of_mem_nhds' hs hl'
  ‚ü®l, hl.1.1, hl.2‚ü©
#align exists_Ico_subset_of_mem_nhds exists_Ico_subset_of_mem_nhds

theorem exists_Icc_mem_subset_of_mem_nhdsWithin_Ici {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù[‚â•] a) :
    ‚àÉ b, a ‚â§ b ‚àß Icc a b ‚àà ùìù[‚â•] a ‚àß Icc a b ‚äÜ s := by
  rcases (em (IsMax a)).imp_right not_isMax_iff.mp with (ha | ha)
  ¬∑ use a
    simpa [ha.Ici_eq] using hs
  ¬∑ rcases (nhdsWithin_Ici_basis' ha).mem_iff.mp hs with ‚ü®b, hab, hbs‚ü©
    rcases eq_empty_or_nonempty (Ioo a b) with (H | ‚ü®c, hac, hcb‚ü©)
    ¬∑ have : Ico a b = Icc a a := by rw [‚Üê Icc_union_Ioo_eq_Ico le_rfl hab, H, union_empty]
      exact ‚ü®a, le_rfl, this ‚ñ∏ ‚ü®Ico_mem_nhdsWithin_Ici' hab, hbs‚ü©‚ü©
    ¬∑ refine' ‚ü®c, hac.le, Icc_mem_nhdsWithin_Ici' hac, _‚ü©
      exact (Icc_subset_Ico_right hcb).trans hbs
#align exists_Icc_mem_subset_of_mem_nhds_within_Ici exists_Icc_mem_subset_of_mem_nhdsWithin_Ici

theorem exists_Icc_mem_subset_of_mem_nhdsWithin_Iic {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù[‚â§] a) :
    ‚àÉ b ‚â§ a, Icc b a ‚àà ùìù[‚â§] a ‚àß Icc b a ‚äÜ s := by
  simpa only [dual_Icc, toDual.surjective.exists] using
    exists_Icc_mem_subset_of_mem_nhdsWithin_Ici (Œ± := Œ±·µí·µà) (a := toDual a) hs
#align exists_Icc_mem_subset_of_mem_nhds_within_Iic exists_Icc_mem_subset_of_mem_nhdsWithin_Iic

theorem exists_Icc_mem_subset_of_mem_nhds {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) :
    ‚àÉ b c, a ‚àà Icc b c ‚àß Icc b c ‚àà ùìù a ‚àß Icc b c ‚äÜ s := by
  rcases exists_Icc_mem_subset_of_mem_nhdsWithin_Iic (nhdsWithin_le_nhds hs) with
    ‚ü®b, hba, hb_nhds, hbs‚ü©
  rcases exists_Icc_mem_subset_of_mem_nhdsWithin_Ici (nhdsWithin_le_nhds hs) with
    ‚ü®c, hac, hc_nhds, hcs‚ü©
  refine' ‚ü®b, c, ‚ü®hba, hac‚ü©, _‚ü©
  rw [‚Üê Icc_union_Icc_eq_Icc hba hac, ‚Üê nhds_left_sup_nhds_right]
  exact ‚ü®union_mem_sup hb_nhds hc_nhds, union_subset hbs hcs‚ü©
#align exists_Icc_mem_subset_of_mem_nhds exists_Icc_mem_subset_of_mem_nhds

theorem IsOpen.exists_Ioo_subset [Nontrivial Œ±] {s : Set Œ±} (hs : IsOpen s) (h : s.Nonempty) :
    ‚àÉ a b, a < b ‚àß Ioo a b ‚äÜ s := by
  obtain ‚ü®x, hx‚ü© : ‚àÉ x, x ‚àà s := h
  obtain ‚ü®y, hy‚ü© : ‚àÉ y, y ‚â† x := exists_ne x
  rcases lt_trichotomy x y with (H | rfl | H)
  ¬∑ obtain ‚ü®u, xu, hu‚ü© : ‚àÉ u, x < u ‚àß Ico x u ‚äÜ s :=
      exists_Ico_subset_of_mem_nhds (hs.mem_nhds hx) ‚ü®y, H‚ü©
    exact ‚ü®x, u, xu, Ioo_subset_Ico_self.trans hu‚ü©
  ¬∑ exact (hy rfl).elim
  ¬∑ obtain ‚ü®l, lx, hl‚ü© : ‚àÉ l, l < x ‚àß Ioc l x ‚äÜ s :=
      exists_Ioc_subset_of_mem_nhds (hs.mem_nhds hx) ‚ü®y, H‚ü©
    exact ‚ü®l, x, lx, Ioo_subset_Ioc_self.trans hl‚ü©
#align is_open.exists_Ioo_subset IsOpen.exists_Ioo_subset

theorem dense_of_exists_between [Nontrivial Œ±] {s : Set Œ±}
    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí ‚àÉ c ‚àà s, a < c ‚àß c < b) : Dense s := by
  refine dense_iff_inter_open.2 fun U U_open U_nonempty => ?_
  obtain ‚ü®a, b, hab, H‚ü© : ‚àÉ a b : Œ±, a < b ‚àß Ioo a b ‚äÜ U := U_open.exists_Ioo_subset U_nonempty
  obtain ‚ü®x, xs, hx‚ü© : ‚àÉ x ‚àà s, a < x ‚àß x < b := h hab
  exact ‚ü®x, ‚ü®H hx, xs‚ü©‚ü©
#align dense_of_exists_between dense_of_exists_between

/-- A set in a nontrivial densely linear ordered type is dense in the sense of topology if and only
if for any `a < b` there exists `c ‚àà s`, `a < c < b`. Each implication requires less typeclass
assumptions. -/
theorem dense_iff_exists_between [DenselyOrdered Œ±] [Nontrivial Œ±] {s : Set Œ±} :
    Dense s ‚Üî ‚àÄ a b, a < b ‚Üí ‚àÉ c ‚àà s, a < c ‚àß c < b :=
  ‚ü®fun h _ _ hab => h.exists_between hab, dense_of_exists_between‚ü©
#align dense_iff_exists_between dense_iff_exists_between

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`,
provided `a` is neither a bottom element nor a top element. -/
theorem mem_nhds_iff_exists_Ioo_subset' {a : Œ±} {s : Set Œ±} (hl : ‚àÉ l, l < a) (hu : ‚àÉ u, a < u) :
    s ‚àà ùìù a ‚Üî ‚àÉ l u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s := by
  constructor
  ¬∑ intro h
    rcases exists_Ico_subset_of_mem_nhds h hu with ‚ü®u, au, hu‚ü©
    rcases exists_Ioc_subset_of_mem_nhds h hl with ‚ü®l, la, hl‚ü©
    exact ‚ü®l, u, ‚ü®la, au‚ü©, Ioc_union_Ico_eq_Ioo la au ‚ñ∏ union_subset hl hu‚ü©
  ¬∑ rintro ‚ü®l, u, ha, h‚ü©
    apply mem_of_superset (Ioo_mem_nhds ha.1 ha.2) h
#align mem_nhds_iff_exists_Ioo_subset' mem_nhds_iff_exists_Ioo_subset'

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`.
-/
theorem mem_nhds_iff_exists_Ioo_subset [NoMaxOrder Œ±] [NoMinOrder Œ±] {a : Œ±} {s : Set Œ±} :
    s ‚àà ùìù a ‚Üî ‚àÉ l u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s :=
  mem_nhds_iff_exists_Ioo_subset' (exists_lt a) (exists_gt a)
#align mem_nhds_iff_exists_Ioo_subset mem_nhds_iff_exists_Ioo_subset

theorem nhds_basis_Ioo' {a : Œ±} (hl : ‚àÉ l, l < a) (hu : ‚àÉ u, a < u) :
    (ùìù a).HasBasis (fun b : Œ± √ó Œ± => b.1 < a ‚àß a < b.2) fun b => Ioo b.1 b.2 :=
  ‚ü®fun s => (mem_nhds_iff_exists_Ioo_subset' hl hu).trans <| by simp‚ü©
#align nhds_basis_Ioo' nhds_basis_Ioo'

theorem nhds_basis_Ioo [NoMaxOrder Œ±] [NoMinOrder Œ±] (a : Œ±) :
    (ùìù a).HasBasis (fun b : Œ± √ó Œ± => b.1 < a ‚àß a < b.2) fun b => Ioo b.1 b.2 :=
  nhds_basis_Ioo' (exists_lt a) (exists_gt a)
#align nhds_basis_Ioo nhds_basis_Ioo

theorem Filter.Eventually.exists_Ioo_subset [NoMaxOrder Œ±] [NoMinOrder Œ±] {a : Œ±} {p : Œ± ‚Üí Prop}
    (hp : ‚àÄ·∂† x in ùìù a, p x) : ‚àÉ l u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ { x | p x } :=
  mem_nhds_iff_exists_Ioo_subset.1 hp
#align filter.eventually.exists_Ioo_subset Filter.Eventually.exists_Ioo_subset

theorem Dense.topology_eq_generateFrom [DenselyOrdered Œ±] {s : Set Œ±} (hs : Dense s) :
    ‚ÄπTopologicalSpace Œ±‚Ä∫ = .generateFrom (Ioi '' s ‚à™ Iio '' s) := by
  refine (OrderTopology.topology_eq_generate_intervals (Œ± := Œ±)).trans ?_
  refine le_antisymm (generateFrom_anti ?_) (le_generateFrom ?_)
  ¬∑ simp only [union_subset_iff, image_subset_iff]
    exact ‚ü®fun a _ ‚Ü¶ ‚ü®a, .inl rfl‚ü©, fun a _ ‚Ü¶ ‚ü®a, .inr rfl‚ü©‚ü©
  ¬∑ rintro _ ‚ü®a, rfl | rfl‚ü©
    ¬∑ rw [hs.Ioi_eq_biUnion]
      let _ := generateFrom (Ioi '' s ‚à™ Iio '' s)
      exact isOpen_iUnion fun x ‚Ü¶ isOpen_iUnion fun h ‚Ü¶ .basic _ <| .inl <| mem_image_of_mem _ h.1
    ¬∑ rw [hs.Iio_eq_biUnion]
      let _ := generateFrom (Ioi '' s ‚à™ Iio '' s)
      exact isOpen_iUnion fun x ‚Ü¶ isOpen_iUnion fun h ‚Ü¶ .basic _ <| .inr <| mem_image_of_mem _ h.1

@[deprecated OrderBot.atBot_eq] -- 2024-02-14
theorem atBot_le_nhds_bot [OrderBot Œ±] : (atBot : Filter Œ±) ‚â§ ùìù ‚ä• := by
  rw [OrderBot.atBot_eq]
  apply pure_le_nhds
#align at_bot_le_nhds_bot atBot_le_nhds_bot

@[deprecated OrderTop.atTop_eq] -- 2024-02-14
theorem atTop_le_nhds_top [OrderTop Œ±] : (atTop : Filter Œ±) ‚â§ ùìù ‚ä§ :=
  set_option linter.deprecated false in @atBot_le_nhds_bot Œ±·µí·µà _ _ _
#align at_top_le_nhds_top atTop_le_nhds_top

variable (Œ±)

/-- Let `Œ±` be a densely ordered linear order with order topology. If `Œ±` is a separable space, then
it has second countable topology. Note that the "densely ordered" assumption cannot be dropped, see
[double arrow space](https://topology.pi-base.org/spaces/S000093) for a counterexample. -/
theorem SecondCountableTopology.of_separableSpace_orderTopology [DenselyOrdered Œ±]
    [SeparableSpace Œ±] : SecondCountableTopology Œ± := by
  rcases exists_countable_dense Œ± with ‚ü®s, hc, hd‚ü©
  refine ‚ü®‚ü®_, ?_, hd.topology_eq_generateFrom‚ü©‚ü©
  exact (hc.image _).union (hc.image _)

variable {Œ±}

-- Porting note (#10756): new lemma
/-- The set of points which are isolated on the right is countable when the space is
second-countable. -/
theorem countable_setOf_covBy_right [SecondCountableTopology Œ±] :
    Set.Countable { x : Œ± | ‚àÉ y, x ‚ãñ y } := by
  nontriviality Œ±
  let s := { x : Œ± | ‚àÉ y, x ‚ãñ y }
  have : ‚àÄ x ‚àà s, ‚àÉ y, x ‚ãñ y := fun x => id
  choose! y hy using this
  have Hy : ‚àÄ x z, x ‚àà s ‚Üí z < y x ‚Üí z ‚â§ x := fun x z hx => (hy x hx).le_of_lt
  suffices H : ‚àÄ a : Set Œ±, IsOpen a ‚Üí Set.Countable { x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a } by
    have : s ‚äÜ ‚ãÉ a ‚àà countableBasis Œ±, { x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a } := fun x hx => by
      rcases (isBasis_countableBasis Œ±).exists_mem_of_ne (hy x hx).ne with ‚ü®a, ab, xa, ya‚ü©
      exact mem_iUnion‚ÇÇ.2 ‚ü®a, ab, hx, xa, ya‚ü©
    refine Set.Countable.mono this ?_
    refine' Countable.biUnion (countable_countableBasis Œ±) fun a ha => H _ _
    exact isOpen_of_mem_countableBasis ha
  intro a ha
  suffices H : Set.Countable { x | (x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a) ‚àß ¬¨IsBot x } from
    H.of_diff (subsingleton_isBot Œ±).countable
  simp only [and_assoc]
  let t := { x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a ‚àß ¬¨IsBot x }
  have : ‚àÄ x ‚àà t, ‚àÉ z < x, Ioc z x ‚äÜ a := by
    intro x hx
    apply exists_Ioc_subset_of_mem_nhds (ha.mem_nhds hx.2.1)
    simpa only [IsBot, not_forall, not_le] using hx.right.right.right
  choose! z hz h'z using this
  have : PairwiseDisjoint t fun x => Ioc (z x) x := fun x xt x' x't hxx' => by
    rcases hxx'.lt_or_lt with (h' | h')
    ¬∑ refine' disjoint_left.2 fun u ux ux' => xt.2.2.1 _
      refine' h'z x' x't ‚ü®ux'.1.trans_le (ux.2.trans (hy x xt.1).le), _‚ü©
      by_contra! H
      exact lt_irrefl _ ((Hy _ _ xt.1 H).trans_lt h')
    ¬∑ refine' disjoint_left.2 fun u ux ux' => x't.2.2.1 _
      refine' h'z x xt ‚ü®ux.1.trans_le (ux'.2.trans (hy x' x't.1).le), _‚ü©
      by_contra! H
      exact lt_irrefl _ ((Hy _ _ x't.1 H).trans_lt h')
  refine' this.countable_of_isOpen (fun x hx => _) fun x hx => ‚ü®x, hz x hx, le_rfl‚ü©
  suffices H : Ioc (z x) x = Ioo (z x) (y x) by
    rw [H]
    exact isOpen_Ioo
  exact Subset.antisymm (Ioc_subset_Ioo_right (hy x hx.1).lt) fun u hu => ‚ü®hu.1, Hy _ _ hx.1 hu.2‚ü©

/-- The set of points which are isolated on the right is countable when the space is
second-countable. -/
@[deprecated countable_setOf_covBy_right]
theorem countable_of_isolated_right' [SecondCountableTopology Œ±] :
    Set.Countable { x : Œ± | ‚àÉ y, x < y ‚àß Ioo x y = ‚àÖ } := by
  simpa only [‚Üê covBy_iff_Ioo_eq] using countable_setOf_covBy_right
#align countable_of_isolated_right countable_of_isolated_right'

/-- The set of points which are isolated on the left is countable when the space is
second-countable. -/
theorem countable_setOf_covBy_left [SecondCountableTopology Œ±] :
    Set.Countable { x : Œ± | ‚àÉ y, y ‚ãñ x } := by
  convert countable_setOf_covBy_right (Œ± := Œ±·µí·µà) using 5
  exact toDual_covBy_toDual_iff.symm

/-- The set of points which are isolated on the left is countable when the space is
second-countable. -/
theorem countable_of_isolated_left' [SecondCountableTopology Œ±] :
    Set.Countable { x : Œ± | ‚àÉ y, y < x ‚àß Ioo y x = ‚àÖ } := by
  simpa only [‚Üê covBy_iff_Ioo_eq] using countable_setOf_covBy_left
#align countable_of_isolated_left countable_of_isolated_left'

/-- Consider a disjoint family of intervals `(x, y)` with `x < y` in a second-countable space.
Then the family is countable.
This is not a straightforward consequence of second-countability as some of these intervals might be
empty (but in fact this can happen only for countably many of them). -/
theorem Set.PairwiseDisjoint.countable_of_Ioo [SecondCountableTopology Œ±] {y : Œ± ‚Üí Œ±} {s : Set Œ±}
    (h : PairwiseDisjoint s fun x => Ioo x (y x)) (h' : ‚àÄ x ‚àà s, x < y x) : s.Countable :=
  have : (s \ { x | ‚àÉ y, x ‚ãñ y }).Countable :=
    (h.subset (diff_subset _ _)).countable_of_isOpen (fun _ _ => isOpen_Ioo)
      fun x hx => (h' _ hx.1).exists_lt_lt (mt (Exists.intro (y x)) hx.2)
  this.of_diff countable_setOf_covBy_right
#align set.pairwise_disjoint.countable_of_Ioo Set.PairwiseDisjoint.countable_of_Ioo

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(x, ‚àû)` is separated above from `f x` is countable. -/
theorem countable_image_lt_image_Ioi [LinearOrder Œ≤] (f : Œ≤ ‚Üí Œ±) [SecondCountableTopology Œ±] :
    Set.Countable {x | ‚àÉ z, f x < z ‚àß ‚àÄ y, x < y ‚Üí z ‚â§ f y} := by
  /- If the values of `f` are separated above on the right of `x`, there is an interval `(f x, z x)`
    which is not reached by `f`. This gives a family of disjoint open intervals in `Œ±`. Such a
    family can only be countable as `Œ±` is second-countable. -/
  nontriviality Œ≤
  have : Nonempty Œ± := Nonempty.map f (by infer_instance)
  let s := {x | ‚àÉ z, f x < z ‚àß ‚àÄ y, x < y ‚Üí z ‚â§ f y}
  have : ‚àÄ x, x ‚àà s ‚Üí ‚àÉ z, f x < z ‚àß ‚àÄ y, x < y ‚Üí z ‚â§ f y := fun x hx ‚Ü¶ hx
  -- choose `z x` such that `f` does not take the values in `(f x, z x)`.
  choose! z hz using this
  have I : InjOn f s := by
    apply StrictMonoOn.injOn
    intro x hx y _ hxy
    calc
      f x < z x := (hz x hx).1
      _ ‚â§ f y := (hz x hx).2 y hxy
  -- show that `f s` is countable by arguing that a disjoint family of disjoint open intervals
  -- (the intervals `(f x, z x)`) is at most countable.
  have fs_count : (f '' s).Countable := by
    have A : (f '' s).PairwiseDisjoint fun x => Ioo x (z (invFunOn f s x)) := by
      rintro _ ‚ü®u, us, rfl‚ü© _ ‚ü®v, vs, rfl‚ü© huv
      wlog hle : u ‚â§ v generalizing u v
      ¬∑ exact (this v vs u us huv.symm (le_of_not_le hle)).symm
      have hlt : u < v := hle.lt_of_ne (ne_of_apply_ne _ huv)
      apply disjoint_iff_forall_ne.2
      rintro a ha b hb rfl
      simp only [I.leftInvOn_invFunOn us, I.leftInvOn_invFunOn vs] at ha hb
      exact lt_irrefl _ ((ha.2.trans_le ((hz u us).2 v hlt)).trans hb.1)
    apply Set.PairwiseDisjoint.countable_of_Ioo A
    rintro _ ‚ü®y, ys, rfl‚ü©
    simpa only [I.leftInvOn_invFunOn ys] using (hz y ys).1
  exact MapsTo.countable_of_injOn (mapsTo_image f s) I fs_count

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(x, ‚àû)` is separated below from `f x` is countable. -/
theorem countable_image_gt_image_Ioi [LinearOrder Œ≤] (f : Œ≤ ‚Üí Œ±) [SecondCountableTopology Œ±] :
    Set.Countable {x | ‚àÉ z, z < f x ‚àß ‚àÄ y, x < y ‚Üí f y ‚â§ z} :=
  countable_image_lt_image_Ioi (Œ± := Œ±·µí·µà) f

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(-‚àû, x)` is separated above from `f x` is countable. -/
theorem countable_image_lt_image_Iio [LinearOrder Œ≤] (f : Œ≤ ‚Üí Œ±) [SecondCountableTopology Œ±] :
    Set.Countable {x | ‚àÉ z, f x < z ‚àß ‚àÄ y, y < x ‚Üí z ‚â§ f y} :=
  countable_image_lt_image_Ioi (Œ≤ := Œ≤·µí·µà) f

/-- For a function taking values in a second countable space, the set of points `x` for
which the image under `f` of `(-‚àû, x)` is separated below from `f x` is countable. -/
theorem countable_image_gt_image_Iio [LinearOrder Œ≤] (f : Œ≤ ‚Üí Œ±) [SecondCountableTopology Œ±] :
    Set.Countable {x | ‚àÉ z, z < f x ‚àß ‚àÄ y, y < x ‚Üí f y ‚â§ z} :=
  countable_image_lt_image_Ioi (Œ± := Œ±·µí·µà) (Œ≤ := Œ≤·µí·µà) f

instance instIsCountablyGenerated_atTop [SecondCountableTopology Œ±] :
    IsCountablyGenerated (atTop : Filter Œ±) := by
  by_cases h : ‚àÉ (x : Œ±), IsTop x
  ¬∑ rcases h with ‚ü®x, hx‚ü©
    rw [atTop_eq_pure_of_isTop hx]
    exact isCountablyGenerated_pure x
  ¬∑ rcases exists_countable_basis Œ± with ‚ü®b, b_count, b_ne, hb‚ü©
    have : Countable b := by exact Iff.mpr countable_coe_iff b_count
    have A : ‚àÄ (s : b), ‚àÉ (x : Œ±), x ‚àà (s : Set Œ±) := by
      intro s
      have : (s : Set Œ±) ‚â† ‚àÖ := by
        intro H
        apply b_ne
        convert s.2
        exact H.symm
      exact Iff.mp nmem_singleton_empty this
    choose a ha using A
    have : (atTop : Filter Œ±) = (generate (Ici '' (range a))) := by
      apply atTop_eq_generate_of_not_bddAbove
      intro ‚ü®x, hx‚ü©
      simp only [IsTop, not_exists, not_forall, not_le] at h
      rcases h x with ‚ü®y, hy‚ü©
      obtain ‚ü®s, sb, -, hs‚ü© : ‚àÉ s, s ‚àà b ‚àß y ‚àà s ‚àß s ‚äÜ Ioi x :=
        hb.exists_subset_of_mem_open hy isOpen_Ioi
      have I : a ‚ü®s, sb‚ü© ‚â§ x := hx (mem_range_self _)
      have J : x < a ‚ü®s, sb‚ü© := hs (ha ‚ü®s, sb‚ü©)
      exact lt_irrefl _ (I.trans_lt J)
    rw [this]
    exact ‚ü®_, (countable_range _).image _, rfl‚ü©

instance instIsCountablyGenerated_atBot [SecondCountableTopology Œ±] :
    IsCountablyGenerated (atBot : Filter Œ±) :=
  @instIsCountablyGenerated_atTop Œ±·µí·µà _ _ _ _

section Pi

/-!
### Intervals in `Œ† i, œÄ i` belong to `ùìù x`

For each lemma `pi_Ixx_mem_nhds` we add a non-dependent version `pi_Ixx_mem_nhds'` because
sometimes Lean fails to unify different instances while trying to apply the dependent version to,
e.g., `Œπ ‚Üí ‚Ñù`.
-/

variable {Œπ : Type*} {œÄ : Œπ ‚Üí Type*} [Finite Œπ] [‚àÄ i, LinearOrder (œÄ i)]
  [‚àÄ i, TopologicalSpace (œÄ i)] [‚àÄ i, OrderTopology (œÄ i)] {a b x : ‚àÄ i, œÄ i} {a' b' x' : Œπ ‚Üí Œ±}

theorem pi_Iic_mem_nhds (ha : ‚àÄ i, x i < a i) : Iic a ‚àà ùìù x :=
  pi_univ_Iic a ‚ñ∏ set_pi_mem_nhds (Set.toFinite _) fun _ _ => Iic_mem_nhds (ha _)
#align pi_Iic_mem_nhds pi_Iic_mem_nhds

theorem pi_Iic_mem_nhds' (ha : ‚àÄ i, x' i < a' i) : Iic a' ‚àà ùìù x' :=
  pi_Iic_mem_nhds ha
#align pi_Iic_mem_nhds' pi_Iic_mem_nhds'

theorem pi_Ici_mem_nhds (ha : ‚àÄ i, a i < x i) : Ici a ‚àà ùìù x :=
  pi_univ_Ici a ‚ñ∏ set_pi_mem_nhds (Set.toFinite _) fun _ _ => Ici_mem_nhds (ha _)
#align pi_Ici_mem_nhds pi_Ici_mem_nhds

theorem pi_Ici_mem_nhds' (ha : ‚àÄ i, a' i < x' i) : Ici a' ‚àà ùìù x' :=
  pi_Ici_mem_nhds ha
#align pi_Ici_mem_nhds' pi_Ici_mem_nhds'

theorem pi_Icc_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Icc a b ‚àà ùìù x :=
  pi_univ_Icc a b ‚ñ∏ set_pi_mem_nhds finite_univ fun _ _ => Icc_mem_nhds (ha _) (hb _)
#align pi_Icc_mem_nhds pi_Icc_mem_nhds

theorem pi_Icc_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Icc a' b' ‚àà ùìù x' :=
  pi_Icc_mem_nhds ha hb
#align pi_Icc_mem_nhds' pi_Icc_mem_nhds'

variable [Nonempty Œπ]

theorem pi_Iio_mem_nhds (ha : ‚àÄ i, x i < a i) : Iio a ‚àà ùìù x := by
  refine' mem_of_superset (set_pi_mem_nhds Set.finite_univ fun i _ => _) (pi_univ_Iio_subset a)
  exact Iio_mem_nhds (ha i)
#align pi_Iio_mem_nhds pi_Iio_mem_nhds

theorem pi_Iio_mem_nhds' (ha : ‚àÄ i, x' i < a' i) : Iio a' ‚àà ùìù x' :=
  pi_Iio_mem_nhds ha
#align pi_Iio_mem_nhds' pi_Iio_mem_nhds'

theorem pi_Ioi_mem_nhds (ha : ‚àÄ i, a i < x i) : Ioi a ‚àà ùìù x :=
  @pi_Iio_mem_nhds Œπ (fun i => (œÄ i)·µí·µà) _ _ _ _ _ _ _ ha
#align pi_Ioi_mem_nhds pi_Ioi_mem_nhds

theorem pi_Ioi_mem_nhds' (ha : ‚àÄ i, a' i < x' i) : Ioi a' ‚àà ùìù x' :=
  pi_Ioi_mem_nhds ha
#align pi_Ioi_mem_nhds' pi_Ioi_mem_nhds'

theorem pi_Ioc_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ioc a b ‚àà ùìù x := by
  refine' mem_of_superset (set_pi_mem_nhds Set.finite_univ fun i _ => _) (pi_univ_Ioc_subset a b)
  exact Ioc_mem_nhds (ha i) (hb i)
#align pi_Ioc_mem_nhds pi_Ioc_mem_nhds

theorem pi_Ioc_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ioc a' b' ‚àà ùìù x' :=
  pi_Ioc_mem_nhds ha hb
#align pi_Ioc_mem_nhds' pi_Ioc_mem_nhds'

theorem pi_Ico_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ico a b ‚àà ùìù x := by
  refine' mem_of_superset (set_pi_mem_nhds Set.finite_univ fun i _ => _) (pi_univ_Ico_subset a b)
  exact Ico_mem_nhds (ha i) (hb i)
#align pi_Ico_mem_nhds pi_Ico_mem_nhds

theorem pi_Ico_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ico a' b' ‚àà ùìù x' :=
  pi_Ico_mem_nhds ha hb
#align pi_Ico_mem_nhds' pi_Ico_mem_nhds'

theorem pi_Ioo_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ioo a b ‚àà ùìù x := by
  refine' mem_of_superset (set_pi_mem_nhds Set.finite_univ fun i _ => _) (pi_univ_Ioo_subset a b)
  exact Ioo_mem_nhds (ha i) (hb i)
#align pi_Ioo_mem_nhds pi_Ioo_mem_nhds

theorem pi_Ioo_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ioo a' b' ‚àà ùìù x' :=
  pi_Ioo_mem_nhds ha hb
#align pi_Ioo_mem_nhds' pi_Ioo_mem_nhds'

end Pi

/-!
### Neighborhoods to the left and to the right on an `OrderTopology`

We've seen some properties of left and right neighborhood of a point in an `OrderClosedTopology`.
In an `OrderTopology`, such neighborhoods can be characterized as the sets containing suitable
intervals to the right or to the left of `a`. We give now these characterizations. -/

open List in
/-- The following statements are equivalent:

0. `s` is a neighborhood of `a` within `(a, +‚àû)`;
1. `s` is a neighborhood of `a` within `(a, b]`;
2. `s` is a neighborhood of `a` within `(a, b)`;
3. `s` includes `(a, u)` for some `u ‚àà (a, b]`;
4. `s` includes `(a, u)` for some `u > a`.
-/
theorem TFAE_mem_nhdsWithin_Ioi {a b : Œ±} (hab : a < b) (s : Set Œ±) :
    TFAE [s ‚àà ùìù[>] a,
      s ‚àà ùìù[Ioc a b] a,
      s ‚àà ùìù[Ioo a b] a,
      ‚àÉ u ‚àà Ioc a b, Ioo a u ‚äÜ s,
      ‚àÉ u ‚àà Ioi a, Ioo a u ‚äÜ s] := by
  tfae_have 1 ‚Üî 2
  ¬∑ rw [nhdsWithin_Ioc_eq_nhdsWithin_Ioi hab]
  tfae_have 1 ‚Üî 3
  ¬∑ rw [nhdsWithin_Ioo_eq_nhdsWithin_Ioi hab]
  tfae_have 4 ‚Üí 5
  ¬∑ exact fun ‚ü®u, umem, hu‚ü© => ‚ü®u, umem.1, hu‚ü©
  tfae_have 5 ‚Üí 1
  ¬∑ rintro ‚ü®u, hau, hu‚ü©
    exact mem_of_superset (Ioo_mem_nhdsWithin_Ioi ‚ü®le_refl a, hau‚ü©) hu
  tfae_have 1 ‚Üí 4
  ¬∑ intro h
    rcases mem_nhdsWithin_iff_exists_mem_nhds_inter.1 h with ‚ü®v, va, hv‚ü©
    rcases exists_Ico_subset_of_mem_nhds' va hab with ‚ü®u, au, hu‚ü©
    refine' ‚ü®u, au, fun x hx => _‚ü©
    refine' hv ‚ü®hu ‚ü®le_of_lt hx.1, hx.2‚ü©, _‚ü©
    exact hx.1
  tfae_finish
#align tfae_mem_nhds_within_Ioi TFAE_mem_nhdsWithin_Ioi

theorem mem_nhdsWithin_Ioi_iff_exists_mem_Ioc_Ioo_subset {a u' : Œ±} {s : Set Œ±} (hu' : a < u') :
    s ‚àà ùìù[>] a ‚Üî ‚àÉ u ‚àà Ioc a u', Ioo a u ‚äÜ s :=
  (TFAE_mem_nhdsWithin_Ioi hu' s).out 0 3
#align mem_nhds_within_Ioi_iff_exists_mem_Ioc_Ioo_subset mem_nhdsWithin_Ioi_iff_exists_mem_Ioc_Ioo_subset

/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u)`
with `a < u < u'`, provided `a` is not a top element. -/
theorem mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' {a u' : Œ±} {s : Set Œ±} (hu' : a < u') :
    s ‚àà ùìù[>] a ‚Üî ‚àÉ u ‚àà Ioi a, Ioo a u ‚äÜ s :=
  (TFAE_mem_nhdsWithin_Ioi hu' s).out 0 4
#align mem_nhds_within_Ioi_iff_exists_Ioo_subset' mem_nhdsWithin_Ioi_iff_exists_Ioo_subset'

theorem nhdsWithin_Ioi_basis' {a : Œ±} (h : ‚àÉ b, a < b) : (ùìù[>] a).HasBasis (a < ¬∑) (Ioo a) :=
  let ‚ü®_, h‚ü© := h
  ‚ü®fun _ => mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' h‚ü©

lemma nhdsWithin_Ioi_basis [NoMaxOrder Œ±] (a : Œ±) : (ùìù[>] a).HasBasis (a < ¬∑) (Ioo a) :=
  nhdsWithin_Ioi_basis' <| exists_gt a

theorem nhdsWithin_Ioi_eq_bot_iff {a : Œ±} : ùìù[>] a = ‚ä• ‚Üî IsTop a ‚à® ‚àÉ b, a ‚ãñ b := by
  by_cases ha : IsTop a
  ¬∑ simp [ha, ha.isMax.Ioi_eq]
  ¬∑ simp only [ha, false_or]
    rw [isTop_iff_isMax, not_isMax_iff] at ha
    simp only [(nhdsWithin_Ioi_basis' ha).eq_bot_iff, covBy_iff_Ioo_eq]

/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u)`
with `a < u`. -/
theorem mem_nhdsWithin_Ioi_iff_exists_Ioo_subset [NoMaxOrder Œ±] {a : Œ±} {s : Set Œ±} :
    s ‚àà ùìù[>] a ‚Üî ‚àÉ u ‚àà Ioi a, Ioo a u ‚äÜ s :=
  let ‚ü®_u', hu'‚ü© := exists_gt a
  mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' hu'
#align mem_nhds_within_Ioi_iff_exists_Ioo_subset mem_nhdsWithin_Ioi_iff_exists_Ioo_subset

/-- The set of points which are isolated on the right is countable when the space is
second-countable. -/
theorem countable_setOf_isolated_right [SecondCountableTopology Œ±] :
    { x : Œ± | ùìù[>] x = ‚ä• }.Countable := by
  simp only [nhdsWithin_Ioi_eq_bot_iff, setOf_or]
  exact (subsingleton_isTop Œ±).countable.union countable_setOf_covBy_right

/-- The set of points which are isolated on the left is countable when the space is
second-countable. -/
theorem countable_setOf_isolated_left [SecondCountableTopology Œ±] :
    { x : Œ± | ùìù[<] x = ‚ä• }.Countable :=
  countable_setOf_isolated_right (Œ± := Œ±·µí·µà)

/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u]`
with `a < u`. -/
theorem mem_nhdsWithin_Ioi_iff_exists_Ioc_subset [NoMaxOrder Œ±] [DenselyOrdered Œ±] {a : Œ±}
    {s : Set Œ±} : s ‚àà ùìù[>] a ‚Üî ‚àÉ u ‚àà Ioi a, Ioc a u ‚äÜ s := by
  rw [mem_nhdsWithin_Ioi_iff_exists_Ioo_subset]
  constructor
  ¬∑ rintro ‚ü®u, au, as‚ü©
    rcases exists_between au with ‚ü®v, hv‚ü©
    exact ‚ü®v, hv.1, fun x hx => as ‚ü®hx.1, lt_of_le_of_lt hx.2 hv.2‚ü©‚ü©
  ¬∑ rintro ‚ü®u, au, as‚ü©
    exact ‚ü®u, au, Subset.trans Ioo_subset_Ioc_self as‚ü©
#align mem_nhds_within_Ioi_iff_exists_Ioc_subset mem_nhdsWithin_Ioi_iff_exists_Ioc_subset

open List in
/-- The following statements are equivalent:

0. `s` is a neighborhood of `b` within `(-‚àû, b)`
1. `s` is a neighborhood of `b` within `[a, b)`
2. `s` is a neighborhood of `b` within `(a, b)`
3. `s` includes `(l, b)` for some `l ‚àà [a, b)`
4. `s` includes `(l, b)` for some `l < b` -/
theorem TFAE_mem_nhdsWithin_Iio {a b : Œ±} (h : a < b) (s : Set Œ±) :
    TFAE [s ‚àà ùìù[<] b,-- 0 : `s` is a neighborhood of `b` within `(-‚àû, b)`
        s ‚àà ùìù[Ico a b] b,-- 1 : `s` is a neighborhood of `b` within `[a, b)`
        s ‚àà ùìù[Ioo a b] b,-- 2 : `s` is a neighborhood of `b` within `(a, b)`
        ‚àÉ l ‚àà Ico a b, Ioo l b ‚äÜ s,-- 3 : `s` includes `(l, b)` for some `l ‚àà [a, b)`
        ‚àÉ l ‚àà Iio b, Ioo l b ‚äÜ s] := by-- 4 : `s` includes `(l, b)` for some `l < b`
  simpa only [exists_prop, OrderDual.exists, dual_Ioi, dual_Ioc, dual_Ioo] using
    TFAE_mem_nhdsWithin_Ioi h.dual (ofDual ‚Åª¬π' s)
#align tfae_mem_nhds_within_Iio TFAE_mem_nhdsWithin_Iio

theorem mem_nhdsWithin_Iio_iff_exists_mem_Ico_Ioo_subset {a l' : Œ±} {s : Set Œ±} (hl' : l' < a) :
    s ‚àà ùìù[<] a ‚Üî ‚àÉ l ‚àà Ico l' a, Ioo l a ‚äÜ s :=
  (TFAE_mem_nhdsWithin_Iio hl' s).out 0 3
#align mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset mem_nhdsWithin_Iio_iff_exists_mem_Ico_Ioo_subset

/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `(l, a)`
with `l < a`, provided `a` is not a bottom element. -/
theorem mem_nhdsWithin_Iio_iff_exists_Ioo_subset' {a l' : Œ±} {s : Set Œ±} (hl' : l' < a) :
    s ‚àà ùìù[<] a ‚Üî ‚àÉ l ‚àà Iio a, Ioo l a ‚äÜ s :=
  (TFAE_mem_nhdsWithin_Iio hl' s).out 0 4
#align mem_nhds_within_Iio_iff_exists_Ioo_subset' mem_nhdsWithin_Iio_iff_exists_Ioo_subset'

/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `(l, a)`
with `l < a`. -/
theorem mem_nhdsWithin_Iio_iff_exists_Ioo_subset [NoMinOrder Œ±] {a : Œ±} {s : Set Œ±} :
    s ‚àà ùìù[<] a ‚Üî ‚àÉ l ‚àà Iio a, Ioo l a ‚äÜ s :=
  let ‚ü®_, h‚ü© := exists_lt a
  mem_nhdsWithin_Iio_iff_exists_Ioo_subset' h
#align mem_nhds_within_Iio_iff_exists_Ioo_subset mem_nhdsWithin_Iio_iff_exists_Ioo_subset

/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `[l, a)`
with `l < a`. -/
theorem mem_nhdsWithin_Iio_iff_exists_Ico_subset [NoMinOrder Œ±] [DenselyOrdered Œ±] {a : Œ±}
    {s : Set Œ±} : s ‚àà ùìù[<] a ‚Üî ‚àÉ l ‚àà Iio a, Ico l a ‚äÜ s := by
  have : ofDual ‚Åª¬π' s ‚àà ùìù[>] toDual a ‚Üî _ := mem_nhdsWithin_Ioi_iff_exists_Ioc_subset
  simpa only [OrderDual.exists, exists_prop, dual_Ioc] using this
#align mem_nhds_within_Iio_iff_exists_Ico_subset mem_nhdsWithin_Iio_iff_exists_Ico_subset

theorem nhdsWithin_Iio_basis' {a : Œ±} (h : ‚àÉ b, b < a) : (ùìù[<] a).HasBasis (¬∑ < a) (Ioo ¬∑ a) :=
  let ‚ü®_, h‚ü© := h
  ‚ü®fun _ => mem_nhdsWithin_Iio_iff_exists_Ioo_subset' h‚ü©

theorem nhdsWithin_Iio_eq_bot_iff {a : Œ±} : ùìù[<] a = ‚ä• ‚Üî IsBot a ‚à® ‚àÉ b, b ‚ãñ a := by
    convert (config := {preTransparency := .default})
      nhdsWithin_Ioi_eq_bot_iff (a := OrderDual.toDual a) using 4
    exact ofDual_covBy_ofDual_iff

open List in
/-- The following statements are equivalent:

0. `s` is a neighborhood of `a` within `[a, +‚àû)`;
1. `s` is a neighborhood of `a` within `[a, b]`;
2. `s` is a neighborhood of `a` within `[a, b)`;
3. `s` includes `[a, u)` for some `u ‚àà (a, b]`;
4. `s` includes `[a, u)` for some `u > a`.
-/
theorem TFAE_mem_nhdsWithin_Ici {a b : Œ±} (hab : a < b) (s : Set Œ±) :
    TFAE [s ‚àà ùìù[‚â•] a,
      s ‚àà ùìù[Icc a b] a,
      s ‚àà ùìù[Ico a b] a,
      ‚àÉ u ‚àà Ioc a b, Ico a u ‚äÜ s,
      ‚àÉ u ‚àà Ioi a , Ico a u ‚äÜ s] := by
  tfae_have 1 ‚Üî 2
  ¬∑ rw [nhdsWithin_Icc_eq_nhdsWithin_Ici hab]
  tfae_have 1 ‚Üî 3
  ¬∑ rw [nhdsWithin_Ico_eq_nhdsWithin_Ici hab]
  tfae_have 1 ‚Üî 5
  ¬∑ exact (nhdsWithin_Ici_basis' ‚ü®b, hab‚ü©).mem_iff
  tfae_have 4 ‚Üí 5
  ¬∑ exact fun ‚ü®u, umem, hu‚ü© => ‚ü®u, umem.1, hu‚ü©
  tfae_have 5 ‚Üí 4
  ¬∑ rintro ‚ü®u, hua, hus‚ü©
    exact
      ‚ü®min u b, ‚ü®lt_min hua hab, min_le_right _ _‚ü©,
        (Ico_subset_Ico_right <| min_le_left _ _).trans hus‚ü©
  tfae_finish
#align tfae_mem_nhds_within_Ici TFAE_mem_nhdsWithin_Ici

theorem mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset {a u' : Œ±} {s : Set Œ±} (hu' : a < u') :
    s ‚àà ùìù[‚â•] a ‚Üî ‚àÉ u ‚àà Ioc a u', Ico a u ‚äÜ s :=
  (TFAE_mem_nhdsWithin_Ici hu' s).out 0 3 (by norm_num) (by norm_num)
#align mem_nhds_within_Ici_iff_exists_mem_Ioc_Ico_subset mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset

/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u)`
with `a < u < u'`, provided `a` is not a top element. -/
theorem mem_nhdsWithin_Ici_iff_exists_Ico_subset' {a u' : Œ±} {s : Set Œ±} (hu' : a < u') :
    s ‚àà ùìù[‚â•] a ‚Üî ‚àÉ u ‚àà Ioi a, Ico a u ‚äÜ s :=
  (TFAE_mem_nhdsWithin_Ici hu' s).out 0 4 (by norm_num) (by norm_num)
#align mem_nhds_within_Ici_iff_exists_Ico_subset' mem_nhdsWithin_Ici_iff_exists_Ico_subset'

/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u)`
with `a < u`. -/
theorem mem_nhdsWithin_Ici_iff_exists_Ico_subset [NoMaxOrder Œ±] {a : Œ±} {s : Set Œ±} :
    s ‚àà ùìù[‚â•] a ‚Üî ‚àÉ u ‚àà Ioi a, Ico a u ‚äÜ s :=
  let ‚ü®_, hu'‚ü© := exists_gt a
  mem_nhdsWithin_Ici_iff_exists_Ico_subset' hu'
#align mem_nhds_within_Ici_iff_exists_Ico_subset mem_nhdsWithin_Ici_iff_exists_Ico_subset

theorem nhdsWithin_Ici_basis_Ico [NoMaxOrder Œ±] (a : Œ±) :
    (ùìù[‚â•] a).HasBasis (fun u => a < u) (Ico a) :=
  ‚ü®fun _ => mem_nhdsWithin_Ici_iff_exists_Ico_subset‚ü©
#align nhds_within_Ici_basis_Ico nhdsWithin_Ici_basis_Ico

/-- The filter of right neighborhoods has a basis of closed intervals. -/
theorem nhdsWithin_Ici_basis_Icc [NoMaxOrder Œ±] [DenselyOrdered Œ±] {a : Œ±} :
    (ùìù[‚â•] a).HasBasis (a < ¬∑) (Icc a) :=
  (nhdsWithin_Ici_basis _).to_hasBasis
    (fun _u hu ‚Ü¶ (exists_between hu).imp fun _v hv ‚Ü¶ hv.imp_right Icc_subset_Ico_right)
    fun u hu ‚Ü¶ ‚ü®u, hu, Ico_subset_Icc_self‚ü©

/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u]`
with `a < u`. -/
theorem mem_nhdsWithin_Ici_iff_exists_Icc_subset [NoMaxOrder Œ±] [DenselyOrdered Œ±] {a : Œ±}
    {s : Set Œ±} : s ‚àà ùìù[‚â•] a ‚Üî ‚àÉ u, a < u ‚àß Icc a u ‚äÜ s :=
  nhdsWithin_Ici_basis_Icc.mem_iff
#align mem_nhds_within_Ici_iff_exists_Icc_subset mem_nhdsWithin_Ici_iff_exists_Icc_subset

open List in
/-- The following statements are equivalent:

0. `s` is a neighborhood of `b` within `(-‚àû, b]`
1. `s` is a neighborhood of `b` within `[a, b]`
2. `s` is a neighborhood of `b` within `(a, b]`
3. `s` includes `(l, b]` for some `l ‚àà [a, b)`
4. `s` includes `(l, b]` for some `l < b` -/
theorem TFAE_mem_nhdsWithin_Iic {a b : Œ±} (h : a < b) (s : Set Œ±) :
    TFAE [s ‚àà ùìù[‚â§] b,-- 0 : `s` is a neighborhood of `b` within `(-‚àû, b]`
      s ‚àà ùìù[Icc a b] b,-- 1 : `s` is a neighborhood of `b` within `[a, b]`
      s ‚àà ùìù[Ioc a b] b,-- 2 : `s` is a neighborhood of `b` within `(a, b]`
      ‚àÉ l ‚àà Ico a b, Ioc l b ‚äÜ s,-- 3 : `s` includes `(l, b]` for some `l ‚àà [a, b)`
      ‚àÉ l ‚àà Iio b, Ioc l b ‚äÜ s] := by-- 4 : `s` includes `(l, b]` for some `l < b`
  simpa only [exists_prop, OrderDual.exists, dual_Ici, dual_Ioc, dual_Icc, dual_Ico] using
    TFAE_mem_nhdsWithin_Ici h.dual (ofDual ‚Åª¬π' s)
#align tfae_mem_nhds_within_Iic TFAE_mem_nhdsWithin_Iic

theorem mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset {a l' : Œ±} {s : Set Œ±} (hl' : l' < a) :
    s ‚àà ùìù[‚â§] a ‚Üî ‚àÉ l ‚àà Ico l' a, Ioc l a ‚äÜ s :=
  (TFAE_mem_nhdsWithin_Iic hl' s).out 0 3 (by norm_num) (by norm_num)
#align mem_nhds_within_Iic_iff_exists_mem_Ico_Ioc_subset mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset

/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `(l, a]`
with `l < a`, provided `a` is not a bottom element. -/
theorem mem_nhdsWithin_Iic_iff_exists_Ioc_subset' {a l' : Œ±} {s : Set Œ±} (hl' : l' < a) :
    s ‚àà ùìù[‚â§] a ‚Üî ‚àÉ l ‚àà Iio a, Ioc l a ‚äÜ s :=
  (TFAE_mem_nhdsWithin_Iic hl' s).out 0 4 (by norm_num) (by norm_num)
#align mem_nhds_within_Iic_iff_exists_Ioc_subset' mem_nhdsWithin_Iic_iff_exists_Ioc_subset'

/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `(l, a]`
with `l < a`. -/
theorem mem_nhdsWithin_Iic_iff_exists_Ioc_subset [NoMinOrder Œ±] {a : Œ±} {s : Set Œ±} :
    s ‚àà ùìù[‚â§] a ‚Üî ‚àÉ l ‚àà Iio a, Ioc l a ‚äÜ s :=
  let ‚ü®_, hl'‚ü© := exists_lt a
  mem_nhdsWithin_Iic_iff_exists_Ioc_subset' hl'
#align mem_nhds_within_Iic_iff_exists_Ioc_subset mem_nhdsWithin_Iic_iff_exists_Ioc_subset

/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `[l, a]`
with `l < a`. -/
theorem mem_nhdsWithin_Iic_iff_exists_Icc_subset [NoMinOrder Œ±] [DenselyOrdered Œ±] {a : Œ±}
    {s : Set Œ±} : s ‚àà ùìù[‚â§] a ‚Üî ‚àÉ l, l < a ‚àß Icc l a ‚äÜ s :=
  calc s ‚àà ùìù[‚â§] a ‚Üî ofDual ‚Åª¬π' s ‚àà ùìù[‚â•] (toDual a) := Iff.rfl
  _ ‚Üî ‚àÉ u : Œ±, toDual a < toDual u ‚àß Icc (toDual a) (toDual u) ‚äÜ ofDual ‚Åª¬π' s :=
    mem_nhdsWithin_Ici_iff_exists_Icc_subset
  _ ‚Üî ‚àÉ l, l < a ‚àß Icc l a ‚äÜ s := by simp only [dual_Icc]; rfl
#align mem_nhds_within_Iic_iff_exists_Icc_subset mem_nhdsWithin_Iic_iff_exists_Icc_subset

/-- The filter of left neighborhoods has a basis of closed intervals. -/
theorem nhdsWithin_Iic_basis_Icc [NoMinOrder Œ±] [DenselyOrdered Œ±] {a : Œ±} :
    (ùìù[‚â§] a).HasBasis (¬∑ < a) (Icc ¬∑ a) :=
  ‚ü®fun _ ‚Ü¶ mem_nhdsWithin_Iic_iff_exists_Icc_subset‚ü©

end OrderTopology

end LinearOrder

section LinearOrderedAddCommGroup

variable [TopologicalSpace Œ±] [LinearOrderedAddCommGroup Œ±] [OrderTopology Œ±]
variable {l : Filter Œ≤} {f g : Œ≤ ‚Üí Œ±}

theorem nhds_eq_iInf_abs_sub (a : Œ±) : ùìù a = ‚®Ö r > 0, ùìü { b | |a - b| < r } := by
  simp only [nhds_eq_order, abs_lt, setOf_and, ‚Üê inf_principal, iInf_inf_eq]
  refine (congr_arg‚ÇÇ _ ?_ ?_).trans (inf_comm ..)
  ¬∑ refine (Equiv.subLeft a).iInf_congr fun x => ?_; simp [Ioi]
  ¬∑ refine (Equiv.subRight a).iInf_congr fun x => ?_; simp [Iio]
#align nhds_eq_infi_abs_sub nhds_eq_iInf_abs_sub

theorem orderTopology_of_nhds_abs {Œ± : Type*} [TopologicalSpace Œ±] [LinearOrderedAddCommGroup Œ±]
    (h_nhds : ‚àÄ a : Œ±, ùìù a = ‚®Ö r > 0, ùìü { b | |a - b| < r }) : OrderTopology Œ± := by
  refine' ‚ü®TopologicalSpace.ext_nhds fun a => _‚ü©
  rw [h_nhds]
  letI := Preorder.topology Œ±; letI : OrderTopology Œ± := ‚ü®rfl‚ü©
  exact (nhds_eq_iInf_abs_sub a).symm
#align order_topology_of_nhds_abs orderTopology_of_nhds_abs

theorem LinearOrderedAddCommGroup.tendsto_nhds {x : Filter Œ≤} {a : Œ±} :
    Tendsto f x (ùìù a) ‚Üî ‚àÄ Œµ > (0 : Œ±), ‚àÄ·∂† b in x, |f b - a| < Œµ := by
  simp [nhds_eq_iInf_abs_sub, abs_sub_comm a]
#align linear_ordered_add_comm_group.tendsto_nhds LinearOrderedAddCommGroup.tendsto_nhds

theorem eventually_abs_sub_lt (a : Œ±) {Œµ : Œ±} (hŒµ : 0 < Œµ) : ‚àÄ·∂† x in ùìù a, |x - a| < Œµ :=
  (nhds_eq_iInf_abs_sub a).symm ‚ñ∏
    mem_iInf_of_mem Œµ (mem_iInf_of_mem hŒµ <| by simp only [abs_sub_comm, mem_principal_self])
#align eventually_abs_sub_lt eventually_abs_sub_lt

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`
and `g` tends to `atTop` then `f + g` tends to `atTop`. -/
theorem Filter.Tendsto.add_atTop {C : Œ±} (hf : Tendsto f l (ùìù C)) (hg : Tendsto g l atTop) :
    Tendsto (fun x => f x + g x) l atTop := by
  nontriviality Œ±
  obtain ‚ü®C', hC'‚ü© : ‚àÉ C', C' < C := exists_lt C
  refine' tendsto_atTop_add_left_of_le' _ C' _ hg
  exact (hf.eventually (lt_mem_nhds hC')).mono fun x => le_of_lt
#align filter.tendsto.add_at_top Filter.Tendsto.add_atTop

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`
and `g` tends to `atBot` then `f + g` tends to `atBot`. -/
theorem Filter.Tendsto.add_atBot {C : Œ±} (hf : Tendsto f l (ùìù C)) (hg : Tendsto g l atBot) :
    Tendsto (fun x => f x + g x) l atBot :=
  Filter.Tendsto.add_atTop (Œ± := Œ±·µí·µà) hf hg
#align filter.tendsto.add_at_bot Filter.Tendsto.add_atBot

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to
`atTop` and `g` tends to `C` then `f + g` tends to `atTop`. -/
theorem Filter.Tendsto.atTop_add {C : Œ±} (hf : Tendsto f l atTop) (hg : Tendsto g l (ùìù C)) :
    Tendsto (fun x => f x + g x) l atTop := by
  conv in _ + _ => rw [add_comm]
  exact hg.add_atTop hf
#align filter.tendsto.at_top_add Filter.Tendsto.atTop_add

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to
`atBot` and `g` tends to `C` then `f + g` tends to `atBot`. -/
theorem Filter.Tendsto.atBot_add {C : Œ±} (hf : Tendsto f l atBot) (hg : Tendsto g l (ùìù C)) :
    Tendsto (fun x => f x + g x) l atBot := by
  conv in _ + _ => rw [add_comm]
  exact hg.add_atBot hf
#align filter.tendsto.at_bot_add Filter.Tendsto.atBot_add

theorem nhds_basis_abs_sub_lt [NoMaxOrder Œ±] (a : Œ±) :
    (ùìù a).HasBasis (fun Œµ : Œ± => (0 : Œ±) < Œµ) fun Œµ => { b | |b - a| < Œµ } := by
  simp only [nhds_eq_iInf_abs_sub, abs_sub_comm (a := a)]
  refine hasBasis_biInf_principal' (fun x hx y hy => ?_) (exists_gt _)
  exact ‚ü®min x y, lt_min hx hy, fun _ hz => hz.trans_le (min_le_left _ _),
    fun _ hz => hz.trans_le (min_le_right _ _)‚ü©
#align nhds_basis_abs_sub_lt nhds_basis_abs_sub_lt

theorem nhds_basis_Ioo_pos [NoMaxOrder Œ±] (a : Œ±) :
    (ùìù a).HasBasis (fun Œµ : Œ± => (0 : Œ±) < Œµ) fun Œµ => Ioo (a - Œµ) (a + Œµ) := by
  convert nhds_basis_abs_sub_lt a
  simp only [Ioo, abs_lt, ‚Üê sub_lt_iff_lt_add, neg_lt_sub_iff_lt_add, sub_lt_comm]
#align nhds_basis_Ioo_pos nhds_basis_Ioo_pos

theorem nhds_basis_Icc_pos [NoMaxOrder Œ±] [DenselyOrdered Œ±] (a : Œ±) :
    (ùìù a).HasBasis ((0 : Œ±) < ¬∑) fun Œµ ‚Ü¶ Icc (a - Œµ) (a + Œµ) :=
  (nhds_basis_Ioo_pos a).to_hasBasis
    (fun _Œµ Œµ‚ÇÄ ‚Ü¶ let ‚ü®Œ¥, Œ¥‚ÇÄ, Œ¥Œµ‚ü© := exists_between Œµ‚ÇÄ
      ‚ü®Œ¥, Œ¥‚ÇÄ, Icc_subset_Ioo (sub_lt_sub_left Œ¥Œµ _) (add_lt_add_left Œ¥Œµ _)‚ü©)
    (fun Œµ Œµ‚ÇÄ ‚Ü¶ ‚ü®Œµ, Œµ‚ÇÄ, Ioo_subset_Icc_self‚ü©)

variable (Œ±)

theorem nhds_basis_zero_abs_sub_lt [NoMaxOrder Œ±] :
    (ùìù (0 : Œ±)).HasBasis (fun Œµ : Œ± => (0 : Œ±) < Œµ) fun Œµ => { b | |b| < Œµ } := by
  simpa using nhds_basis_abs_sub_lt (0 : Œ±)
#align nhds_basis_zero_abs_sub_lt nhds_basis_zero_abs_sub_lt

variable {Œ±}

/-- If `a` is positive we can form a basis from only nonnegative `Set.Ioo` intervals -/
theorem nhds_basis_Ioo_pos_of_pos [NoMaxOrder Œ±] {a : Œ±} (ha : 0 < a) :
    (ùìù a).HasBasis (fun Œµ : Œ± => (0 : Œ±) < Œµ ‚àß Œµ ‚â§ a) fun Œµ => Ioo (a - Œµ) (a + Œµ) :=
  (nhds_basis_Ioo_pos a).restrict fun Œµ hŒµ => ‚ü®min a Œµ, lt_min ha hŒµ, min_le_left _ _,
    Ioo_subset_Ioo (sub_le_sub_left (min_le_right _ _) _) (add_le_add_left (min_le_right _ _) _)‚ü©
#align nhds_basis_Ioo_pos_of_pos nhds_basis_Ioo_pos_of_pos

end LinearOrderedAddCommGroup

@[deprecated image_neg]
theorem preimage_neg [AddGroup Œ±] : preimage (Neg.neg : Œ± ‚Üí Œ±) = image (Neg.neg : Œ± ‚Üí Œ±) :=
  funext fun _ => image_neg.symm
#align preimage_neg preimage_neg

@[deprecated] -- use `Filter.map_neg` from `Mathlib.Order.Filter.Pointwise`
theorem Filter.map_neg_eq_comap_neg [AddGroup Œ±] :
    map (Neg.neg : Œ± ‚Üí Œ±) = comap (Neg.neg : Œ± ‚Üí Œ±) :=
  funext fun _ => map_eq_comap_of_inverse (funext neg_neg) (funext neg_neg)
#align filter.map_neg_eq_comap_neg Filter.map_neg_eq_comap_neg

section OrderTopology

variable [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [LinearOrder Œ±] [LinearOrder Œ≤] [OrderTopology Œ±]
  [OrderTopology Œ≤]

theorem IsLUB.frequently_mem {a : Œ±} {s : Set Œ±} (ha : IsLUB s a) (hs : s.Nonempty) :
    ‚àÉ·∂† x in ùìù[‚â§] a, x ‚àà s := by
  rcases hs with ‚ü®a', ha'‚ü©
  intro h
  rcases (ha.1 ha').eq_or_lt with (rfl | ha'a)
  ¬∑ exact h.self_of_nhdsWithin le_rfl ha'
  ¬∑ rcases (mem_nhdsWithin_Iic_iff_exists_Ioc_subset' ha'a).1 h with ‚ü®b, hba, hb‚ü©
    rcases ha.exists_between hba with ‚ü®b', hb's, hb'‚ü©
    exact hb hb' hb's
#align is_lub.frequently_mem IsLUB.frequently_mem

theorem IsLUB.frequently_nhds_mem {a : Œ±} {s : Set Œ±} (ha : IsLUB s a) (hs : s.Nonempty) :
    ‚àÉ·∂† x in ùìù a, x ‚àà s :=
  (ha.frequently_mem hs).filter_mono inf_le_left
#align is_lub.frequently_nhds_mem IsLUB.frequently_nhds_mem

theorem IsGLB.frequently_mem {a : Œ±} {s : Set Œ±} (ha : IsGLB s a) (hs : s.Nonempty) :
    ‚àÉ·∂† x in ùìù[‚â•] a, x ‚àà s :=
  IsLUB.frequently_mem (Œ± := Œ±·µí·µà) ha hs
#align is_glb.frequently_mem IsGLB.frequently_mem

theorem IsGLB.frequently_nhds_mem {a : Œ±} {s : Set Œ±} (ha : IsGLB s a) (hs : s.Nonempty) :
    ‚àÉ·∂† x in ùìù a, x ‚àà s :=
  (ha.frequently_mem hs).filter_mono inf_le_left
#align is_glb.frequently_nhds_mem IsGLB.frequently_nhds_mem

theorem IsLUB.mem_closure {a : Œ±} {s : Set Œ±} (ha : IsLUB s a) (hs : s.Nonempty) : a ‚àà closure s :=
  (ha.frequently_nhds_mem hs).mem_closure
#align is_lub.mem_closure IsLUB.mem_closure

theorem IsGLB.mem_closure {a : Œ±} {s : Set Œ±} (ha : IsGLB s a) (hs : s.Nonempty) : a ‚àà closure s :=
  (ha.frequently_nhds_mem hs).mem_closure
#align is_glb.mem_closure IsGLB.mem_closure

theorem IsLUB.nhdsWithin_neBot {a : Œ±} {s : Set Œ±} (ha : IsLUB s a) (hs : s.Nonempty) :
    NeBot (ùìù[s] a) :=
  mem_closure_iff_nhdsWithin_neBot.1 (ha.mem_closure hs)
#align is_lub.nhds_within_ne_bot IsLUB.nhdsWithin_neBot

theorem IsGLB.nhdsWithin_neBot : ‚àÄ {a : Œ±} {s : Set Œ±}, IsGLB s a ‚Üí s.Nonempty ‚Üí NeBot (ùìù[s] a) :=
  IsLUB.nhdsWithin_neBot (Œ± := Œ±·µí·µà)
#align is_glb.nhds_within_ne_bot IsGLB.nhdsWithin_neBot

theorem isLUB_of_mem_nhds {s : Set Œ±} {a : Œ±} {f : Filter Œ±} (hsa : a ‚àà upperBounds s) (hsf : s ‚àà f)
    [NeBot (f ‚äì ùìù a)] : IsLUB s a :=
  ‚ü®hsa, fun b hb =>
    not_lt.1 fun hba =>
      have : s ‚à© { a | b < a } ‚àà f ‚äì ùìù a := inter_mem_inf hsf (IsOpen.mem_nhds (isOpen_lt' _) hba)
      let ‚ü®_x, ‚ü®hxs, hxb‚ü©‚ü© := Filter.nonempty_of_mem this
      have : b < b := lt_of_lt_of_le hxb <| hb hxs
      lt_irrefl b this‚ü©
#align is_lub_of_mem_nhds isLUB_of_mem_nhds

theorem isLUB_of_mem_closure {s : Set Œ±} {a : Œ±} (hsa : a ‚àà upperBounds s) (hsf : a ‚àà closure s) :
    IsLUB s a := by
  rw [mem_closure_iff_clusterPt, ClusterPt, inf_comm] at hsf
  exact isLUB_of_mem_nhds hsa (mem_principal_self s)
#align is_lub_of_mem_closure isLUB_of_mem_closure

theorem isGLB_of_mem_nhds :
    ‚àÄ {s : Set Œ±} {a : Œ±} {f : Filter Œ±}, a ‚àà lowerBounds s ‚Üí s ‚àà f ‚Üí NeBot (f ‚äì ùìù a) ‚Üí IsGLB s a :=
  isLUB_of_mem_nhds (Œ± := Œ±·µí·µà)
#align is_glb_of_mem_nhds isGLB_of_mem_nhds

theorem isGLB_of_mem_closure {s : Set Œ±} {a : Œ±} (hsa : a ‚àà lowerBounds s) (hsf : a ‚àà closure s) :
    IsGLB s a :=
  isLUB_of_mem_closure (Œ± := Œ±·µí·µà) hsa hsf
#align is_glb_of_mem_closure isGLB_of_mem_closure

theorem IsLUB.mem_upperBounds_of_tendsto [Preorder Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥]
    {f : Œ± ‚Üí Œ≥} {s : Set Œ±} {a : Œ±} {b : Œ≥} (hf : MonotoneOn f s) (ha : IsLUB s a)
    (hb : Tendsto f (ùìù[s] a) (ùìù b)) : b ‚àà upperBounds (f '' s) := by
  rintro _ ‚ü®x, hx, rfl‚ü©
  replace ha := ha.inter_Ici_of_mem hx
  haveI := ha.nhdsWithin_neBot ‚ü®x, hx, le_rfl‚ü©
  refine' ge_of_tendsto (hb.mono_left (nhdsWithin_mono _ (inter_subset_left s (Ici x)))) _
  exact mem_of_superset self_mem_nhdsWithin fun y hy => hf hx hy.1 hy.2
#align is_lub.mem_upper_bounds_of_tendsto IsLUB.mem_upperBounds_of_tendsto

-- For a version of this theorem in which the convergence considered on the domain `Œ±` is as `x : Œ±`
-- tends to infinity, rather than tending to a point `x` in `Œ±`, see `isLUB_of_tendsto_atTop`
theorem IsLUB.isLUB_of_tendsto [Preorder Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥] {f : Œ± ‚Üí Œ≥}
    {s : Set Œ±} {a : Œ±} {b : Œ≥} (hf : MonotoneOn f s) (ha : IsLUB s a) (hs : s.Nonempty)
    (hb : Tendsto f (ùìù[s] a) (ùìù b)) : IsLUB (f '' s) b :=
  haveI := ha.nhdsWithin_neBot hs
  ‚ü®ha.mem_upperBounds_of_tendsto hf hb, fun _b' hb' =>
    le_of_tendsto hb (mem_of_superset self_mem_nhdsWithin fun _ hx => hb' <| mem_image_of_mem _ hx)‚ü©
#align is_lub.is_lub_of_tendsto IsLUB.isLUB_of_tendsto

theorem IsGLB.mem_lowerBounds_of_tendsto [Preorder Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥]
    {f : Œ± ‚Üí Œ≥} {s : Set Œ±} {a : Œ±} {b : Œ≥} (hf : MonotoneOn f s) (ha : IsGLB s a)
    (hb : Tendsto f (ùìù[s] a) (ùìù b)) : b ‚àà lowerBounds (f '' s) :=
  IsLUB.mem_upperBounds_of_tendsto (Œ± := Œ±·µí·µà) (Œ≥ := Œ≥·µí·µà) hf.dual ha hb
#align is_glb.mem_lower_bounds_of_tendsto IsGLB.mem_lowerBounds_of_tendsto

-- For a version of this theorem in which the convergence considered on the domain `Œ±` is as
-- `x : Œ±` tends to negative infinity, rather than tending to a point `x` in `Œ±`, see
-- `isGLB_of_tendsto_atBot`
theorem IsGLB.isGLB_of_tendsto [Preorder Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥] {f : Œ± ‚Üí Œ≥}
    {s : Set Œ±} {a : Œ±} {b : Œ≥} (hf : MonotoneOn f s) :
    IsGLB s a ‚Üí s.Nonempty ‚Üí Tendsto f (ùìù[s] a) (ùìù b) ‚Üí IsGLB (f '' s) b :=
  IsLUB.isLUB_of_tendsto (Œ± := Œ±·µí·µà) (Œ≥ := Œ≥·µí·µà) hf.dual
#align is_glb.is_glb_of_tendsto IsGLB.isGLB_of_tendsto

theorem IsLUB.mem_lowerBounds_of_tendsto [Preorder Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥]
    {f : Œ± ‚Üí Œ≥} {s : Set Œ±} {a : Œ±} {b : Œ≥} (hf : AntitoneOn f s) (ha : IsLUB s a)
    (hb : Tendsto f (ùìù[s] a) (ùìù b)) : b ‚àà lowerBounds (f '' s) :=
  IsLUB.mem_upperBounds_of_tendsto (Œ≥ := Œ≥·µí·µà) hf ha hb
#align is_lub.mem_lower_bounds_of_tendsto IsLUB.mem_lowerBounds_of_tendsto

theorem IsLUB.isGLB_of_tendsto [Preorder Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥] :
    ‚àÄ {f : Œ± ‚Üí Œ≥} {s : Set Œ±} {a : Œ±} {b : Œ≥},
      AntitoneOn f s ‚Üí IsLUB s a ‚Üí s.Nonempty ‚Üí Tendsto f (ùìù[s] a) (ùìù b) ‚Üí IsGLB (f '' s) b :=
  IsLUB.isLUB_of_tendsto (Œ≥ := Œ≥·µí·µà)
#align is_lub.is_glb_of_tendsto IsLUB.isGLB_of_tendsto

theorem IsGLB.mem_upperBounds_of_tendsto [Preorder Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥]
    {f : Œ± ‚Üí Œ≥} {s : Set Œ±} {a : Œ±} {b : Œ≥} (hf : AntitoneOn f s) (ha : IsGLB s a)
    (hb : Tendsto f (ùìù[s] a) (ùìù b)) : b ‚àà upperBounds (f '' s) :=
  IsGLB.mem_lowerBounds_of_tendsto (Œ≥ := Œ≥·µí·µà) hf ha hb
#align is_glb.mem_upper_bounds_of_tendsto IsGLB.mem_upperBounds_of_tendsto

theorem IsGLB.isLUB_of_tendsto [Preorder Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥] :
    ‚àÄ {f : Œ± ‚Üí Œ≥} {s : Set Œ±} {a : Œ±} {b : Œ≥},
      AntitoneOn f s ‚Üí IsGLB s a ‚Üí s.Nonempty ‚Üí Tendsto f (ùìù[s] a) (ùìù b) ‚Üí IsLUB (f '' s) b :=
  IsGLB.isGLB_of_tendsto (Œ≥ := Œ≥·µí·µà)
#align is_glb.is_lub_of_tendsto IsGLB.isLUB_of_tendsto

theorem IsLUB.mem_of_isClosed {a : Œ±} {s : Set Œ±} (ha : IsLUB s a) (hs : s.Nonempty)
    (sc : IsClosed s) : a ‚àà s :=
  sc.closure_subset <| ha.mem_closure hs
#align is_lub.mem_of_is_closed IsLUB.mem_of_isClosed

alias IsClosed.isLUB_mem := IsLUB.mem_of_isClosed
#align is_closed.is_lub_mem IsClosed.isLUB_mem

theorem IsGLB.mem_of_isClosed {a : Œ±} {s : Set Œ±} (ha : IsGLB s a) (hs : s.Nonempty)
    (sc : IsClosed s) : a ‚àà s :=
  sc.closure_subset <| ha.mem_closure hs
#align is_glb.mem_of_is_closed IsGLB.mem_of_isClosed

alias IsClosed.isGLB_mem := IsGLB.mem_of_isClosed
#align is_closed.is_glb_mem IsClosed.isGLB_mem

/-!
### Existence of sequences tending to `sInf` or `sSup` of a given set
-/

theorem IsLUB.exists_seq_strictMono_tendsto_of_not_mem {t : Set Œ±} {x : Œ±}
    [IsCountablyGenerated (ùìù x)] (htx : IsLUB t x) (not_mem : x ‚àâ t) (ht : t.Nonempty) :
    ‚àÉ u : ‚Ñï ‚Üí Œ±, StrictMono u ‚àß (‚àÄ n, u n < x) ‚àß Tendsto u atTop (ùìù x) ‚àß ‚àÄ n, u n ‚àà t := by
  obtain ‚ü®v, hvx, hvt‚ü© := exists_seq_forall_of_frequently (htx.frequently_mem ht)
  replace hvx := hvx.mono_right nhdsWithin_le_nhds
  have hvx' : ‚àÄ {n}, v n < x := (htx.1 (hvt _)).lt_of_ne (ne_of_mem_of_not_mem (hvt _) not_mem)
  have : ‚àÄ k, ‚àÄ·∂† l in atTop, v k < v l := fun k => hvx.eventually (lt_mem_nhds hvx')
  choose N hN hvN using fun k => ((eventually_gt_atTop k).and (this k)).exists
  refine ‚ü®fun k => v (N^[k] 0), strictMono_nat_of_lt_succ fun _ => ?_, fun _ => hvx',
    hvx.comp (strictMono_nat_of_lt_succ fun _ => ?_).tendsto_atTop, fun _ => hvt _‚ü©
  ¬∑ rw [iterate_succ_apply']; exact hvN _
  ¬∑ rw [iterate_succ_apply']; exact hN _
#align is_lub.exists_seq_strict_mono_tendsto_of_not_mem IsLUB.exists_seq_strictMono_tendsto_of_not_mem

theorem IsLUB.exists_seq_monotone_tendsto {t : Set Œ±} {x : Œ±} [IsCountablyGenerated (ùìù x)]
    (htx : IsLUB t x) (ht : t.Nonempty) :
    ‚àÉ u : ‚Ñï ‚Üí Œ±, Monotone u ‚àß (‚àÄ n, u n ‚â§ x) ‚àß Tendsto u atTop (ùìù x) ‚àß ‚àÄ n, u n ‚àà t := by
  by_cases h : x ‚àà t
  ¬∑ exact ‚ü®fun _ => x, monotone_const, fun n => le_rfl, tendsto_const_nhds, fun _ => h‚ü©
  ¬∑ rcases htx.exists_seq_strictMono_tendsto_of_not_mem h ht with ‚ü®u, hu‚ü©
    exact ‚ü®u, hu.1.monotone, fun n => (hu.2.1 n).le, hu.2.2‚ü©
#align is_lub.exists_seq_monotone_tendsto IsLUB.exists_seq_monotone_tendsto

theorem exists_seq_strictMono_tendsto' {Œ± : Type*} [LinearOrder Œ±] [TopologicalSpace Œ±]
    [DenselyOrdered Œ±] [OrderTopology Œ±] [FirstCountableTopology Œ±] {x y : Œ±} (hy : y < x) :
    ‚àÉ u : ‚Ñï ‚Üí Œ±, StrictMono u ‚àß (‚àÄ n, u n ‚àà Ioo y x) ‚àß Tendsto u atTop (ùìù x) := by
  have hx : x ‚àâ Ioo y x := fun h => (lt_irrefl x h.2).elim
  have ht : Set.Nonempty (Ioo y x) := nonempty_Ioo.2 hy
  rcases (isLUB_Ioo hy).exists_seq_strictMono_tendsto_of_not_mem hx ht with ‚ü®u, hu‚ü©
  exact ‚ü®u, hu.1, hu.2.2.symm‚ü©
#align exists_seq_strict_mono_tendsto' exists_seq_strictMono_tendsto'

theorem exists_seq_strictMono_tendsto [DenselyOrdered Œ±] [NoMinOrder Œ±] [FirstCountableTopology Œ±]
    (x : Œ±) : ‚àÉ u : ‚Ñï ‚Üí Œ±, StrictMono u ‚àß (‚àÄ n, u n < x) ‚àß Tendsto u atTop (ùìù x) := by
  obtain ‚ü®y, hy‚ü© : ‚àÉ y, y < x := exists_lt x
  rcases exists_seq_strictMono_tendsto' hy with ‚ü®u, hu_mono, hu_mem, hux‚ü©
  exact ‚ü®u, hu_mono, fun n => (hu_mem n).2, hux‚ü©
#align exists_seq_strict_mono_tendsto exists_seq_strictMono_tendsto

theorem exists_seq_strictMono_tendsto_nhdsWithin [DenselyOrdered Œ±] [NoMinOrder Œ±]
    [FirstCountableTopology Œ±] (x : Œ±) :
    ‚àÉ u : ‚Ñï ‚Üí Œ±, StrictMono u ‚àß (‚àÄ n, u n < x) ‚àß Tendsto u atTop (ùìù[<] x) :=
  let ‚ü®u, hu, hx, h‚ü© := exists_seq_strictMono_tendsto x
  ‚ü®u, hu, hx, tendsto_nhdsWithin_mono_right (range_subset_iff.2 hx) <| tendsto_nhdsWithin_range.2 h‚ü©
#align exists_seq_strict_mono_tendsto_nhds_within exists_seq_strictMono_tendsto_nhdsWithin

theorem exists_seq_tendsto_sSup {Œ± : Type*} [ConditionallyCompleteLinearOrder Œ±]
    [TopologicalSpace Œ±] [OrderTopology Œ±] [FirstCountableTopology Œ±] {S : Set Œ±} (hS : S.Nonempty)
    (hS' : BddAbove S) : ‚àÉ u : ‚Ñï ‚Üí Œ±, Monotone u ‚àß Tendsto u atTop (ùìù (sSup S)) ‚àß ‚àÄ n, u n ‚àà S := by
  rcases (isLUB_csSup hS hS').exists_seq_monotone_tendsto hS with ‚ü®u, hu‚ü©
  exact ‚ü®u, hu.1, hu.2.2‚ü©
#align exists_seq_tendsto_Sup exists_seq_tendsto_sSup

theorem IsGLB.exists_seq_strictAnti_tendsto_of_not_mem {t : Set Œ±} {x : Œ±}
    [IsCountablyGenerated (ùìù x)] (htx : IsGLB t x) (not_mem : x ‚àâ t) (ht : t.Nonempty) :
    ‚àÉ u : ‚Ñï ‚Üí Œ±, StrictAnti u ‚àß (‚àÄ n, x < u n) ‚àß Tendsto u atTop (ùìù x) ‚àß ‚àÄ n, u n ‚àà t :=
  IsLUB.exists_seq_strictMono_tendsto_of_not_mem (Œ± := Œ±·µí·µà) htx not_mem ht
#align is_glb.exists_seq_strict_anti_tendsto_of_not_mem IsGLB.exists_seq_strictAnti_tendsto_of_not_mem

theorem IsGLB.exists_seq_antitone_tendsto {t : Set Œ±} {x : Œ±} [IsCountablyGenerated (ùìù x)]
    (htx : IsGLB t x) (ht : t.Nonempty) :
    ‚àÉ u : ‚Ñï ‚Üí Œ±, Antitone u ‚àß (‚àÄ n, x ‚â§ u n) ‚àß Tendsto u atTop (ùìù x) ‚àß ‚àÄ n, u n ‚àà t :=
  IsLUB.exists_seq_monotone_tendsto (Œ± := Œ±·µí·µà) htx ht
#align is_glb.exists_seq_antitone_tendsto IsGLB.exists_seq_antitone_tendsto

theorem exists_seq_strictAnti_tendsto' [DenselyOrdered Œ±] [FirstCountableTopology Œ±] {x y : Œ±}
    (hy : x < y) : ‚àÉ u : ‚Ñï ‚Üí Œ±, StrictAnti u ‚àß (‚àÄ n, u n ‚àà Ioo x y) ‚àß Tendsto u atTop (ùìù x) := by
  simpa only [dual_Ioo]
    using exists_seq_strictMono_tendsto' (Œ± := Œ±·µí·µà) (OrderDual.toDual_lt_toDual.2 hy)
#align exists_seq_strict_anti_tendsto' exists_seq_strictAnti_tendsto'

theorem exists_seq_strictAnti_tendsto [DenselyOrdered Œ±] [NoMaxOrder Œ±] [FirstCountableTopology Œ±]
    (x : Œ±) : ‚àÉ u : ‚Ñï ‚Üí Œ±, StrictAnti u ‚àß (‚àÄ n, x < u n) ‚àß Tendsto u atTop (ùìù x) :=
  exists_seq_strictMono_tendsto (Œ± := Œ±·µí·µà) x
#align exists_seq_strict_anti_tendsto exists_seq_strictAnti_tendsto

theorem exists_seq_strictAnti_tendsto_nhdsWithin [DenselyOrdered Œ±] [NoMaxOrder Œ±]
    [FirstCountableTopology Œ±] (x : Œ±) :
    ‚àÉ u : ‚Ñï ‚Üí Œ±, StrictAnti u ‚àß (‚àÄ n, x < u n) ‚àß Tendsto u atTop (ùìù[>] x) :=
  exists_seq_strictMono_tendsto_nhdsWithin (Œ± := Œ±·µí·µà) _
#align exists_seq_strict_anti_tendsto_nhds_within exists_seq_strictAnti_tendsto_nhdsWithin

theorem exists_seq_strictAnti_strictMono_tendsto [DenselyOrdered Œ±] [FirstCountableTopology Œ±]
    {x y : Œ±} (h : x < y) :
    ‚àÉ u v : ‚Ñï ‚Üí Œ±, StrictAnti u ‚àß StrictMono v ‚àß (‚àÄ k, u k ‚àà Ioo x y) ‚àß (‚àÄ l, v l ‚àà Ioo x y) ‚àß
      (‚àÄ k l, u k < v l) ‚àß Tendsto u atTop (ùìù x) ‚àß Tendsto v atTop (ùìù y) := by
  rcases exists_seq_strictAnti_tendsto' h with ‚ü®u, hu_anti, hu_mem, hux‚ü©
  rcases exists_seq_strictMono_tendsto' (hu_mem 0).2 with ‚ü®v, hv_mono, hv_mem, hvy‚ü©
  exact
    ‚ü®u, v, hu_anti, hv_mono, hu_mem, fun l => ‚ü®(hu_mem 0).1.trans (hv_mem l).1, (hv_mem l).2‚ü©,
      fun k l => (hu_anti.antitone (zero_le k)).trans_lt (hv_mem l).1, hux, hvy‚ü©
#align exists_seq_strict_anti_strict_mono_tendsto exists_seq_strictAnti_strictMono_tendsto

theorem exists_seq_tendsto_sInf {Œ± : Type*} [ConditionallyCompleteLinearOrder Œ±]
    [TopologicalSpace Œ±] [OrderTopology Œ±] [FirstCountableTopology Œ±] {S : Set Œ±} (hS : S.Nonempty)
    (hS' : BddBelow S) : ‚àÉ u : ‚Ñï ‚Üí Œ±, Antitone u ‚àß Tendsto u atTop (ùìù (sInf S)) ‚àß ‚àÄ n, u n ‚àà S :=
  exists_seq_tendsto_sSup (Œ± := Œ±·µí·µà) hS hS'
#align exists_seq_tendsto_Inf exists_seq_tendsto_sInf

end OrderTopology

section DenselyOrdered

variable [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [DenselyOrdered Œ±] {a b : Œ±}
  {s : Set Œ±}

/-- The closure of the interval `(a, +‚àû)` is the closed interval `[a, +‚àû)`, unless `a` is a top
element. -/
theorem closure_Ioi' {a : Œ±} (h : (Ioi a).Nonempty) : closure (Ioi a) = Ici a := by
  apply Subset.antisymm
  ¬∑ exact closure_minimal Ioi_subset_Ici_self isClosed_Ici
  ¬∑ rw [‚Üê diff_subset_closure_iff, Ici_diff_Ioi_same, singleton_subset_iff]
    exact isGLB_Ioi.mem_closure h
#align closure_Ioi' closure_Ioi'

/-- The closure of the interval `(a, +‚àû)` is the closed interval `[a, +‚àû)`. -/
@[simp]
theorem closure_Ioi (a : Œ±) [NoMaxOrder Œ±] : closure (Ioi a) = Ici a :=
  closure_Ioi' nonempty_Ioi
#align closure_Ioi closure_Ioi

/-- The closure of the interval `(-‚àû, a)` is the closed interval `(-‚àû, a]`, unless `a` is a bottom
element. -/
theorem closure_Iio' (h : (Iio a).Nonempty) : closure (Iio a) = Iic a :=
  closure_Ioi' (Œ± := Œ±·µí·µà) h
#align closure_Iio' closure_Iio'

/-- The closure of the interval `(-‚àû, a)` is the interval `(-‚àû, a]`. -/
@[simp]
theorem closure_Iio (a : Œ±) [NoMinOrder Œ±] : closure (Iio a) = Iic a :=
  closure_Iio' nonempty_Iio
#align closure_Iio closure_Iio

/-- The closure of the open interval `(a, b)` is the closed interval `[a, b]`. -/
@[simp]
theorem closure_Ioo {a b : Œ±} (hab : a ‚â† b) : closure (Ioo a b) = Icc a b := by
  apply Subset.antisymm
  ¬∑ exact closure_minimal Ioo_subset_Icc_self isClosed_Icc
  ¬∑ cases' hab.lt_or_lt with hab hab
    ¬∑ rw [‚Üê diff_subset_closure_iff, Icc_diff_Ioo_same hab.le]
      have hab' : (Ioo a b).Nonempty := nonempty_Ioo.2 hab
      simp only [insert_subset_iff, singleton_subset_iff]
      exact ‚ü®(isGLB_Ioo hab).mem_closure hab', (isLUB_Ioo hab).mem_closure hab'‚ü©
    ¬∑ rw [Icc_eq_empty_of_lt hab]
      exact empty_subset _
#align closure_Ioo closure_Ioo

/-- The closure of the interval `(a, b]` is the closed interval `[a, b]`. -/
@[simp]
theorem closure_Ioc {a b : Œ±} (hab : a ‚â† b) : closure (Ioc a b) = Icc a b := by
  apply Subset.antisymm
  ¬∑ exact closure_minimal Ioc_subset_Icc_self isClosed_Icc
  ¬∑ apply Subset.trans _ (closure_mono Ioo_subset_Ioc_self)
    rw [closure_Ioo hab]
#align closure_Ioc closure_Ioc

/-- The closure of the interval `[a, b)` is the closed interval `[a, b]`. -/
@[simp]
theorem closure_Ico {a b : Œ±} (hab : a ‚â† b) : closure (Ico a b) = Icc a b := by
  apply Subset.antisymm
  ¬∑ exact closure_minimal Ico_subset_Icc_self isClosed_Icc
  ¬∑ apply Subset.trans _ (closure_mono Ioo_subset_Ico_self)
    rw [closure_Ioo hab]
#align closure_Ico closure_Ico

@[simp]
theorem interior_Ici' {a : Œ±} (ha : (Iio a).Nonempty) : interior (Ici a) = Ioi a := by
  rw [‚Üê compl_Iio, interior_compl, closure_Iio' ha, compl_Iic]
#align interior_Ici' interior_Ici'

theorem interior_Ici [NoMinOrder Œ±] {a : Œ±} : interior (Ici a) = Ioi a :=
  interior_Ici' nonempty_Iio
#align interior_Ici interior_Ici

@[simp]
theorem interior_Iic' {a : Œ±} (ha : (Ioi a).Nonempty) : interior (Iic a) = Iio a :=
  interior_Ici' (Œ± := Œ±·µí·µà) ha
#align interior_Iic' interior_Iic'

theorem interior_Iic [NoMaxOrder Œ±] {a : Œ±} : interior (Iic a) = Iio a :=
  interior_Iic' nonempty_Ioi
#align interior_Iic interior_Iic

@[simp]
theorem interior_Icc [NoMinOrder Œ±] [NoMaxOrder Œ±] {a b : Œ±} : interior (Icc a b) = Ioo a b := by
  rw [‚Üê Ici_inter_Iic, interior_inter, interior_Ici, interior_Iic, Ioi_inter_Iio]
#align interior_Icc interior_Icc

@[simp]
theorem Icc_mem_nhds_iff [NoMinOrder Œ±] [NoMaxOrder Œ±] {a b x : Œ±} :
    Icc a b ‚àà ùìù x ‚Üî x ‚àà Ioo a b := by
  rw [‚Üê interior_Icc, mem_interior_iff_mem_nhds]

@[simp]
theorem interior_Ico [NoMinOrder Œ±] {a b : Œ±} : interior (Ico a b) = Ioo a b := by
  rw [‚Üê Ici_inter_Iio, interior_inter, interior_Ici, interior_Iio, Ioi_inter_Iio]
#align interior_Ico interior_Ico

@[simp]
theorem Ico_mem_nhds_iff [NoMinOrder Œ±] {a b x : Œ±} : Ico a b ‚àà ùìù x ‚Üî x ‚àà Ioo a b := by
  rw [‚Üê interior_Ico, mem_interior_iff_mem_nhds]

@[simp]
theorem interior_Ioc [NoMaxOrder Œ±] {a b : Œ±} : interior (Ioc a b) = Ioo a b := by
  rw [‚Üê Ioi_inter_Iic, interior_inter, interior_Ioi, interior_Iic, Ioi_inter_Iio]
#align interior_Ioc interior_Ioc

@[simp]
theorem Ioc_mem_nhds_iff [NoMaxOrder Œ±] {a b x : Œ±} : Ioc a b ‚àà ùìù x ‚Üî x ‚àà Ioo a b := by
  rw [‚Üê interior_Ioc, mem_interior_iff_mem_nhds]

theorem closure_interior_Icc {a b : Œ±} (h : a ‚â† b) : closure (interior (Icc a b)) = Icc a b :=
  (closure_minimal interior_subset isClosed_Icc).antisymm <|
    calc
      Icc a b = closure (Ioo a b) := (closure_Ioo h).symm
      _ ‚äÜ closure (interior (Icc a b)) :=
        closure_mono (interior_maximal Ioo_subset_Icc_self isOpen_Ioo)
#align closure_interior_Icc closure_interior_Icc

theorem Ioc_subset_closure_interior (a b : Œ±) : Ioc a b ‚äÜ closure (interior (Ioc a b)) := by
  rcases eq_or_ne a b with (rfl | h)
  ¬∑ simp
  ¬∑ calc
      Ioc a b ‚äÜ Icc a b := Ioc_subset_Icc_self
      _ = closure (Ioo a b) := (closure_Ioo h).symm
      _ ‚äÜ closure (interior (Ioc a b)) :=
        closure_mono (interior_maximal Ioo_subset_Ioc_self isOpen_Ioo)
#align Ioc_subset_closure_interior Ioc_subset_closure_interior

theorem Ico_subset_closure_interior (a b : Œ±) : Ico a b ‚äÜ closure (interior (Ico a b)) := by
  simpa only [dual_Ioc] using Ioc_subset_closure_interior (OrderDual.toDual b) (OrderDual.toDual a)
#align Ico_subset_closure_interior Ico_subset_closure_interior

@[simp]
theorem frontier_Ici' {a : Œ±} (ha : (Iio a).Nonempty) : frontier (Ici a) = {a} := by
  simp [frontier, ha]
#align frontier_Ici' frontier_Ici'

theorem frontier_Ici [NoMinOrder Œ±] {a : Œ±} : frontier (Ici a) = {a} :=
  frontier_Ici' nonempty_Iio
#align frontier_Ici frontier_Ici

@[simp]
theorem frontier_Iic' {a : Œ±} (ha : (Ioi a).Nonempty) : frontier (Iic a) = {a} := by
  simp [frontier, ha]
#align frontier_Iic' frontier_Iic'

theorem frontier_Iic [NoMaxOrder Œ±] {a : Œ±} : frontier (Iic a) = {a} :=
  frontier_Iic' nonempty_Ioi
#align frontier_Iic frontier_Iic

@[simp]
theorem frontier_Ioi' {a : Œ±} (ha : (Ioi a).Nonempty) : frontier (Ioi a) = {a} := by
  simp [frontier, closure_Ioi' ha, Iic_diff_Iio, Icc_self]
#align frontier_Ioi' frontier_Ioi'

theorem frontier_Ioi [NoMaxOrder Œ±] {a : Œ±} : frontier (Ioi a) = {a} :=
  frontier_Ioi' nonempty_Ioi
#align frontier_Ioi frontier_Ioi

@[simp]
theorem frontier_Iio' {a : Œ±} (ha : (Iio a).Nonempty) : frontier (Iio a) = {a} := by
  simp [frontier, closure_Iio' ha, Iic_diff_Iio, Icc_self]
#align frontier_Iio' frontier_Iio'

theorem frontier_Iio [NoMinOrder Œ±] {a : Œ±} : frontier (Iio a) = {a} :=
  frontier_Iio' nonempty_Iio
#align frontier_Iio frontier_Iio

@[simp]
theorem frontier_Icc [NoMinOrder Œ±] [NoMaxOrder Œ±] {a b : Œ±} (h : a ‚â§ b) :
    frontier (Icc a b) = {a, b} := by simp [frontier, h, Icc_diff_Ioo_same]
#align frontier_Icc frontier_Icc

@[simp]
theorem frontier_Ioo {a b : Œ±} (h : a < b) : frontier (Ioo a b) = {a, b} := by
  rw [frontier, closure_Ioo h.ne, interior_Ioo, Icc_diff_Ioo_same h.le]
#align frontier_Ioo frontier_Ioo

@[simp]
theorem frontier_Ico [NoMinOrder Œ±] {a b : Œ±} (h : a < b) : frontier (Ico a b) = {a, b} := by
  rw [frontier, closure_Ico h.ne, interior_Ico, Icc_diff_Ioo_same h.le]
#align frontier_Ico frontier_Ico

@[simp]
theorem frontier_Ioc [NoMaxOrder Œ±] {a b : Œ±} (h : a < b) : frontier (Ioc a b) = {a, b} := by
  rw [frontier, closure_Ioc h.ne, interior_Ioc, Icc_diff_Ioo_same h.le]
#align frontier_Ioc frontier_Ioc

theorem nhdsWithin_Ioi_neBot' {a b : Œ±} (H‚ÇÅ : (Ioi a).Nonempty) (H‚ÇÇ : a ‚â§ b) :
    NeBot (ùìù[Ioi a] b) :=
  mem_closure_iff_nhdsWithin_neBot.1 <| by rwa [closure_Ioi' H‚ÇÅ]
#align nhds_within_Ioi_ne_bot' nhdsWithin_Ioi_neBot'

theorem nhdsWithin_Ioi_neBot [NoMaxOrder Œ±] {a b : Œ±} (H : a ‚â§ b) : NeBot (ùìù[Ioi a] b) :=
  nhdsWithin_Ioi_neBot' nonempty_Ioi H
#align nhds_within_Ioi_ne_bot nhdsWithin_Ioi_neBot

theorem nhdsWithin_Ioi_self_neBot' {a : Œ±} (H : (Ioi a).Nonempty) : NeBot (ùìù[>] a) :=
  nhdsWithin_Ioi_neBot' H (le_refl a)
#align nhds_within_Ioi_self_ne_bot' nhdsWithin_Ioi_self_neBot'

instance nhdsWithin_Ioi_self_neBot [NoMaxOrder Œ±] (a : Œ±) : NeBot (ùìù[>] a) :=
  nhdsWithin_Ioi_neBot (le_refl a)
#align nhds_within_Ioi_self_ne_bot nhdsWithin_Ioi_self_neBot

theorem nhdsWithin_Iio_neBot' {b c : Œ±} (H‚ÇÅ : (Iio c).Nonempty) (H‚ÇÇ : b ‚â§ c) :
    NeBot (ùìù[Iio c] b) :=
  mem_closure_iff_nhdsWithin_neBot.1 <| by rwa [closure_Iio' H‚ÇÅ]
#align nhds_within_Iio_ne_bot' nhdsWithin_Iio_neBot'

theorem nhdsWithin_Iio_neBot [NoMinOrder Œ±] {a b : Œ±} (H : a ‚â§ b) : NeBot (ùìù[Iio b] a) :=
  nhdsWithin_Iio_neBot' nonempty_Iio H
#align nhds_within_Iio_ne_bot nhdsWithin_Iio_neBot

theorem nhdsWithin_Iio_self_neBot' {b : Œ±} (H : (Iio b).Nonempty) : NeBot (ùìù[<] b) :=
  nhdsWithin_Iio_neBot' H (le_refl b)
#align nhds_within_Iio_self_ne_bot' nhdsWithin_Iio_self_neBot'

instance nhdsWithin_Iio_self_neBot [NoMinOrder Œ±] (a : Œ±) : NeBot (ùìù[<] a) :=
  nhdsWithin_Iio_neBot (le_refl a)
#align nhds_within_Iio_self_ne_bot nhdsWithin_Iio_self_neBot

theorem right_nhdsWithin_Ico_neBot {a b : Œ±} (H : a < b) : NeBot (ùìù[Ico a b] b) :=
  (isLUB_Ico H).nhdsWithin_neBot (nonempty_Ico.2 H)
#align right_nhds_within_Ico_ne_bot right_nhdsWithin_Ico_neBot

theorem left_nhdsWithin_Ioc_neBot {a b : Œ±} (H : a < b) : NeBot (ùìù[Ioc a b] a) :=
  (isGLB_Ioc H).nhdsWithin_neBot (nonempty_Ioc.2 H)
#align left_nhds_within_Ioc_ne_bot left_nhdsWithin_Ioc_neBot

theorem left_nhdsWithin_Ioo_neBot {a b : Œ±} (H : a < b) : NeBot (ùìù[Ioo a b] a) :=
  (isGLB_Ioo H).nhdsWithin_neBot (nonempty_Ioo.2 H)
#align left_nhds_within_Ioo_ne_bot left_nhdsWithin_Ioo_neBot

theorem right_nhdsWithin_Ioo_neBot {a b : Œ±} (H : a < b) : NeBot (ùìù[Ioo a b] b) :=
  (isLUB_Ioo H).nhdsWithin_neBot (nonempty_Ioo.2 H)
#align right_nhds_within_Ioo_ne_bot right_nhdsWithin_Ioo_neBot

theorem comap_coe_nhdsWithin_Iio_of_Ioo_subset (hb : s ‚äÜ Iio b)
    (hs : s.Nonempty ‚Üí ‚àÉ a < b, Ioo a b ‚äÜ s) : comap ((‚Üë) : s ‚Üí Œ±) (ùìù[<] b) = atTop := by
  nontriviality
  haveI : Nonempty s := nontrivial_iff_nonempty.1 ‚Äπ_‚Ä∫
  rcases hs (nonempty_subtype.1 ‚Äπ_‚Ä∫) with ‚ü®a, h, hs‚ü©
  ext u; constructor
  ¬∑ rintro ‚ü®t, ht, hts‚ü©
    obtain ‚ü®x, ‚ü®hxa : a ‚â§ x, hxb : x < b‚ü©, hxt : Ioo x b ‚äÜ t‚ü© :=
      (mem_nhdsWithin_Iio_iff_exists_mem_Ico_Ioo_subset h).mp ht
    obtain ‚ü®y, hxy, hyb‚ü© := exists_between hxb
    refine' mem_of_superset (mem_atTop ‚ü®y, hs ‚ü®hxa.trans_lt hxy, hyb‚ü©‚ü©) _
    rintro ‚ü®z, hzs‚ü© (hyz : y ‚â§ z)
    exact hts (hxt ‚ü®hxy.trans_le hyz, hb hzs‚ü©)
  ¬∑ intro hu
    obtain ‚ü®x : s, hx : ‚àÄ z, x ‚â§ z ‚Üí z ‚àà u‚ü© := mem_atTop_sets.1 hu
    exact ‚ü®Ioo x b, Ioo_mem_nhdsWithin_Iio' (hb x.2), fun z hz => hx _ hz.1.le‚ü©
#align comap_coe_nhds_within_Iio_of_Ioo_subset comap_coe_nhdsWithin_Iio_of_Ioo_subset

theorem comap_coe_nhdsWithin_Ioi_of_Ioo_subset (ha : s ‚äÜ Ioi a)
    (hs : s.Nonempty ‚Üí ‚àÉ b > a, Ioo a b ‚äÜ s) : comap ((‚Üë) : s ‚Üí Œ±) (ùìù[>] a) = atBot :=
  comap_coe_nhdsWithin_Iio_of_Ioo_subset (show ofDual ‚Åª¬π' s ‚äÜ Iio (toDual a) from ha) fun h => by
    simpa only [OrderDual.exists, dual_Ioo] using hs h
#align comap_coe_nhds_within_Ioi_of_Ioo_subset comap_coe_nhdsWithin_Ioi_of_Ioo_subset

theorem map_coe_atTop_of_Ioo_subset (hb : s ‚äÜ Iio b) (hs : ‚àÄ a' < b, ‚àÉ a < b, Ioo a b ‚äÜ s) :
    map ((‚Üë) : s ‚Üí Œ±) atTop = ùìù[<] b := by
  rcases eq_empty_or_nonempty (Iio b) with (hb' | ‚ü®a, ha‚ü©)
  ¬∑ have : IsEmpty s := ‚ü®fun x => hb'.subset (hb x.2)‚ü©
    rw [filter_eq_bot_of_isEmpty atTop, Filter.map_bot, hb', nhdsWithin_empty]
  ¬∑ rw [‚Üê comap_coe_nhdsWithin_Iio_of_Ioo_subset hb fun _ => hs a ha, map_comap_of_mem]
    rw [Subtype.range_val]
    exact (mem_nhdsWithin_Iio_iff_exists_Ioo_subset' ha).2 (hs a ha)
#align map_coe_at_top_of_Ioo_subset map_coe_atTop_of_Ioo_subset

theorem map_coe_atBot_of_Ioo_subset (ha : s ‚äÜ Ioi a) (hs : ‚àÄ b' > a, ‚àÉ b > a, Ioo a b ‚äÜ s) :
    map ((‚Üë) : s ‚Üí Œ±) atBot = ùìù[>] a := by
  -- the elaborator gets stuck without `(... : _)`
  refine' (map_coe_atTop_of_Ioo_subset (show ofDual ‚Åª¬π' s ‚äÜ Iio (toDual a) from ha)
    fun b' hb' => _ : _)
  simpa only [OrderDual.exists, dual_Ioo] using hs b' hb'
#align map_coe_at_bot_of_Ioo_subset map_coe_atBot_of_Ioo_subset

/-- The `atTop` filter for an open interval `Ioo a b` comes from the left-neighbourhoods filter at
the right endpoint in the ambient order. -/
theorem comap_coe_Ioo_nhdsWithin_Iio (a b : Œ±) : comap ((‚Üë) : Ioo a b ‚Üí Œ±) (ùìù[<] b) = atTop :=
  comap_coe_nhdsWithin_Iio_of_Ioo_subset Ioo_subset_Iio_self fun h =>
    ‚ü®a, nonempty_Ioo.1 h, Subset.refl _‚ü©
#align comap_coe_Ioo_nhds_within_Iio comap_coe_Ioo_nhdsWithin_Iio

/-- The `atBot` filter for an open interval `Ioo a b` comes from the right-neighbourhoods filter at
the left endpoint in the ambient order. -/
theorem comap_coe_Ioo_nhdsWithin_Ioi (a b : Œ±) : comap ((‚Üë) : Ioo a b ‚Üí Œ±) (ùìù[>] a) = atBot :=
  comap_coe_nhdsWithin_Ioi_of_Ioo_subset Ioo_subset_Ioi_self fun h =>
    ‚ü®b, nonempty_Ioo.1 h, Subset.refl _‚ü©
#align comap_coe_Ioo_nhds_within_Ioi comap_coe_Ioo_nhdsWithin_Ioi

theorem comap_coe_Ioi_nhdsWithin_Ioi (a : Œ±) : comap ((‚Üë) : Ioi a ‚Üí Œ±) (ùìù[>] a) = atBot :=
  comap_coe_nhdsWithin_Ioi_of_Ioo_subset (Subset.refl _) fun ‚ü®x, hx‚ü© => ‚ü®x, hx, Ioo_subset_Ioi_self‚ü©
#align comap_coe_Ioi_nhds_within_Ioi comap_coe_Ioi_nhdsWithin_Ioi

theorem comap_coe_Iio_nhdsWithin_Iio (a : Œ±) : comap ((‚Üë) : Iio a ‚Üí Œ±) (ùìù[<] a) = atTop :=
  comap_coe_Ioi_nhdsWithin_Ioi (Œ± := Œ±·µí·µà) a
#align comap_coe_Iio_nhds_within_Iio comap_coe_Iio_nhdsWithin_Iio

@[simp]
theorem map_coe_Ioo_atTop {a b : Œ±} (h : a < b) : map ((‚Üë) : Ioo a b ‚Üí Œ±) atTop = ùìù[<] b :=
  map_coe_atTop_of_Ioo_subset Ioo_subset_Iio_self fun _ _ => ‚ü®_, h, Subset.refl _‚ü©
#align map_coe_Ioo_at_top map_coe_Ioo_atTop

@[simp]
theorem map_coe_Ioo_atBot {a b : Œ±} (h : a < b) : map ((‚Üë) : Ioo a b ‚Üí Œ±) atBot = ùìù[>] a :=
  map_coe_atBot_of_Ioo_subset Ioo_subset_Ioi_self fun _ _ => ‚ü®_, h, Subset.refl _‚ü©
#align map_coe_Ioo_at_bot map_coe_Ioo_atBot

@[simp]
theorem map_coe_Ioi_atBot (a : Œ±) : map ((‚Üë) : Ioi a ‚Üí Œ±) atBot = ùìù[>] a :=
  map_coe_atBot_of_Ioo_subset (Subset.refl _) fun b hb => ‚ü®b, hb, Ioo_subset_Ioi_self‚ü©
#align map_coe_Ioi_at_bot map_coe_Ioi_atBot

@[simp]
theorem map_coe_Iio_atTop (a : Œ±) : map ((‚Üë) : Iio a ‚Üí Œ±) atTop = ùìù[<] a :=
  map_coe_Ioi_atBot (Œ± := Œ±·µí·µà) _
#align map_coe_Iio_at_top map_coe_Iio_atTop

variable {l : Filter Œ≤} {f : Œ± ‚Üí Œ≤}

@[simp]
theorem tendsto_comp_coe_Ioo_atTop (h : a < b) :
    Tendsto (fun x : Ioo a b => f x) atTop l ‚Üî Tendsto f (ùìù[<] b) l := by
  rw [‚Üê map_coe_Ioo_atTop h, tendsto_map'_iff]; rfl
#align tendsto_comp_coe_Ioo_at_top tendsto_comp_coe_Ioo_atTop

@[simp]
theorem tendsto_comp_coe_Ioo_atBot (h : a < b) :
    Tendsto (fun x : Ioo a b => f x) atBot l ‚Üî Tendsto f (ùìù[>] a) l := by
  rw [‚Üê map_coe_Ioo_atBot h, tendsto_map'_iff]; rfl
#align tendsto_comp_coe_Ioo_at_bot tendsto_comp_coe_Ioo_atBot

-- Porting note (#11215): TODO: `simpNF` claims that `simp` can't use
-- this lemma to simplify LHS but it can
@[simp, nolint simpNF]
theorem tendsto_comp_coe_Ioi_atBot :
    Tendsto (fun x : Ioi a => f x) atBot l ‚Üî Tendsto f (ùìù[>] a) l := by
  rw [‚Üê map_coe_Ioi_atBot, tendsto_map'_iff]; rfl
#align tendsto_comp_coe_Ioi_at_bot tendsto_comp_coe_Ioi_atBot

-- Porting note (#11215): TODO: `simpNF` claims that `simp` can't use
-- this lemma to simplify LHS but it can
@[simp, nolint simpNF]
theorem tendsto_comp_coe_Iio_atTop :
    Tendsto (fun x : Iio a => f x) atTop l ‚Üî Tendsto f (ùìù[<] a) l := by
  rw [‚Üê map_coe_Iio_atTop, tendsto_map'_iff]; rfl
#align tendsto_comp_coe_Iio_at_top tendsto_comp_coe_Iio_atTop

@[simp]
theorem tendsto_Ioo_atTop {f : Œ≤ ‚Üí Ioo a b} :
    Tendsto f l atTop ‚Üî Tendsto (fun x => (f x : Œ±)) l (ùìù[<] b) := by
  rw [‚Üê comap_coe_Ioo_nhdsWithin_Iio, tendsto_comap_iff]; rfl
#align tendsto_Ioo_at_top tendsto_Ioo_atTop

@[simp]
theorem tendsto_Ioo_atBot {f : Œ≤ ‚Üí Ioo a b} :
    Tendsto f l atBot ‚Üî Tendsto (fun x => (f x : Œ±)) l (ùìù[>] a) := by
  rw [‚Üê comap_coe_Ioo_nhdsWithin_Ioi, tendsto_comap_iff]; rfl
#align tendsto_Ioo_at_bot tendsto_Ioo_atBot

@[simp]
theorem tendsto_Ioi_atBot {f : Œ≤ ‚Üí Ioi a} :
    Tendsto f l atBot ‚Üî Tendsto (fun x => (f x : Œ±)) l (ùìù[>] a) := by
  rw [‚Üê comap_coe_Ioi_nhdsWithin_Ioi, tendsto_comap_iff]; rfl
#align tendsto_Ioi_at_bot tendsto_Ioi_atBot

@[simp]
theorem tendsto_Iio_atTop {f : Œ≤ ‚Üí Iio a} :
    Tendsto f l atTop ‚Üî Tendsto (fun x => (f x : Œ±)) l (ùìù[<] a) := by
  rw [‚Üê comap_coe_Iio_nhdsWithin_Iio, tendsto_comap_iff]; rfl
#align tendsto_Iio_at_top tendsto_Iio_atTop

instance (x : Œ±) [Nontrivial Œ±] : NeBot (ùìù[‚â†] x) := by
  refine forall_mem_nonempty_iff_neBot.1 fun s hs => ?_
  obtain ‚ü®u, u_open, xu, us‚ü© : ‚àÉ u : Set Œ±, IsOpen u ‚àß x ‚àà u ‚àß u ‚à© {x}·∂ú ‚äÜ s := mem_nhdsWithin.1 hs
  obtain ‚ü®a, b, a_lt_b, hab‚ü© : ‚àÉ a b : Œ±, a < b ‚àß Ioo a b ‚äÜ u := u_open.exists_Ioo_subset ‚ü®x, xu‚ü©
  obtain ‚ü®y, hy‚ü© : ‚àÉ y, a < y ‚àß y < b := exists_between a_lt_b
  rcases ne_or_eq x y with (xy | rfl)
  ¬∑ exact ‚ü®y, us ‚ü®hab hy, xy.symm‚ü©‚ü©
  obtain ‚ü®z, hz‚ü© : ‚àÉ z, a < z ‚àß z < x := exists_between hy.1
  exact ‚ü®z, us ‚ü®hab ‚ü®hz.1, hz.2.trans hy.2‚ü©, hz.2.ne‚ü©‚ü©

/-- Let `s` be a dense set in a nontrivial dense linear order `Œ±`. If `s` is a
separable space (e.g., if `Œ±` has a second countable topology), then there exists a countable
dense subset `t ‚äÜ s` such that `t` does not contain bottom/top elements of `Œ±`. -/
theorem Dense.exists_countable_dense_subset_no_bot_top [Nontrivial Œ±] {s : Set Œ±} [SeparableSpace s]
    (hs : Dense s) :
    ‚àÉ t, t ‚äÜ s ‚àß t.Countable ‚àß Dense t ‚àß (‚àÄ x, IsBot x ‚Üí x ‚àâ t) ‚àß ‚àÄ x, IsTop x ‚Üí x ‚àâ t := by
  rcases hs.exists_countable_dense_subset with ‚ü®t, hts, htc, htd‚ü©
  refine' ‚ü®t \ ({ x | IsBot x } ‚à™ { x | IsTop x }), _, _, _, fun x hx => _, fun x hx => _‚ü©
  ¬∑ exact (diff_subset _ _).trans hts
  ¬∑ exact htc.mono (diff_subset _ _)
  ¬∑ exact htd.diff_finite ((subsingleton_isBot Œ±).finite.union (subsingleton_isTop Œ±).finite)
  ¬∑ simp [hx]
  ¬∑ simp [hx]
#align dense.exists_countable_dense_subset_no_bot_top Dense.exists_countable_dense_subset_no_bot_top

variable (Œ±)

/-- If `Œ±` is a nontrivial separable dense linear order, then there exists a
countable dense set `s : Set Œ±` that contains neither top nor bottom elements of `Œ±`.
For a dense set containing both bot and top elements, see
`exists_countable_dense_bot_top`. -/
theorem exists_countable_dense_no_bot_top [SeparableSpace Œ±] [Nontrivial Œ±] :
    ‚àÉ s : Set Œ±, s.Countable ‚àß Dense s ‚àß (‚àÄ x, IsBot x ‚Üí x ‚àâ s) ‚àß ‚àÄ x, IsTop x ‚Üí x ‚àâ s := by
  simpa using dense_univ.exists_countable_dense_subset_no_bot_top
#align exists_countable_dense_no_bot_top exists_countable_dense_no_bot_top

end DenselyOrdered

section ConditionallyCompleteLinearOrder

variable [ConditionallyCompleteLinearOrder Œ±] [TopologicalSpace Œ±] [OrderTopology Œ±]
  [ConditionallyCompleteLinearOrder Œ≤] [TopologicalSpace Œ≤] [OrderClosedTopology Œ≤] [Nonempty Œ≥]

/-- A monotone function continuous at the supremum of a nonempty set sends this supremum to
the supremum of the image of this set. -/
theorem Monotone.map_sSup_of_continuousAt' {f : Œ± ‚Üí Œ≤} {A : Set Œ±} (Cf : ContinuousAt f (sSup A))
    (Mf : Monotone f) (A_nonemp : A.Nonempty) (A_bdd : BddAbove A := by bddDefault) :
    f (sSup A) = sSup (f '' A) :=
  --This is a particular case of the more general `IsLUB.isLUB_of_tendsto`
  .symm <| ((isLUB_csSup A_nonemp A_bdd).isLUB_of_tendsto (Mf.monotoneOn _) A_nonemp <|
    Cf.mono_left inf_le_left).csSup_eq (A_nonemp.image f)
#align monotone.map_Sup_of_continuous_at' Monotone.map_sSup_of_continuousAt'

/-- A monotone function continuous at the indexed supremum over a nonempty `Sort` sends this indexed
supremum to the indexed supremum of the composition. -/
theorem Monotone.map_iSup_of_continuousAt' {Œπ : Sort*} [Nonempty Œπ] {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
    (Cf : ContinuousAt f (iSup g)) (Mf : Monotone f)
    (bdd : BddAbove (range g) := by bddDefault) : f (‚®Ü i, g i) = ‚®Ü i, f (g i) := by
  rw [iSup, Monotone.map_sSup_of_continuousAt' Cf Mf (range_nonempty g) bdd, ‚Üê range_comp, iSup]
  rfl
#align monotone.map_supr_of_continuous_at' Monotone.map_iSup_of_continuousAt'

/-- A monotone function continuous at the infimum of a nonempty set sends this infimum to
the infimum of the image of this set. -/
theorem Monotone.map_sInf_of_continuousAt' {f : Œ± ‚Üí Œ≤} {A : Set Œ±} (Cf : ContinuousAt f (sInf A))
    (Mf : Monotone f) (A_nonemp : A.Nonempty) (A_bdd : BddBelow A := by bddDefault) :
    f (sInf A) = sInf (f '' A) :=
  Monotone.map_sSup_of_continuousAt' (Œ± := Œ±·µí·µà) (Œ≤ := Œ≤·µí·µà) Cf Mf.dual A_nonemp A_bdd
#align monotone.map_Inf_of_continuous_at' Monotone.map_sInf_of_continuousAt'

/-- A monotone function continuous at the indexed infimum over a nonempty `Sort` sends this indexed
infimum to the indexed infimum of the composition. -/
theorem Monotone.map_iInf_of_continuousAt' {Œπ : Sort*} [Nonempty Œπ] {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
    (Cf : ContinuousAt f (iInf g)) (Mf : Monotone f)
    (bdd : BddBelow (range g) := by bddDefault) : f (‚®Ö i, g i) = ‚®Ö i, f (g i) := by
  rw [iInf, Monotone.map_sInf_of_continuousAt' Cf Mf (range_nonempty g) bdd, ‚Üê range_comp, iInf]
  rfl
#align monotone.map_infi_of_continuous_at' Monotone.map_iInf_of_continuousAt'

/-- An antitone function continuous at the infimum of a nonempty set sends this infimum to
the supremum of the image of this set. -/
theorem Antitone.map_sInf_of_continuousAt' {f : Œ± ‚Üí Œ≤} {A : Set Œ±} (Cf : ContinuousAt f (sInf A))
    (Af : Antitone f) (A_nonemp : A.Nonempty) (A_bdd : BddBelow A := by bddDefault) :
    f (sInf A) = sSup (f '' A) :=
  Monotone.map_sInf_of_continuousAt' (Œ≤ := Œ≤·µí·µà) Cf Af.dual_right A_nonemp A_bdd
#align antitone.map_Inf_of_continuous_at' Antitone.map_sInf_of_continuousAt'

/-- An antitone function continuous at the indexed infimum over a nonempty `Sort` sends this indexed
infimum to the indexed supremum of the composition. -/
theorem Antitone.map_iInf_of_continuousAt' {Œπ : Sort*} [Nonempty Œπ] {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
    (Cf : ContinuousAt f (iInf g)) (Af : Antitone f)
    (bdd : BddBelow (range g) := by bddDefault) : f (‚®Ö i, g i) = ‚®Ü i, f (g i) := by
  rw [iInf, Antitone.map_sInf_of_continuousAt' Cf Af (range_nonempty g) bdd, ‚Üê range_comp, iSup]
  rfl
#align antitone.map_infi_of_continuous_at' Antitone.map_iInf_of_continuousAt'

/-- An antitone function continuous at the supremum of a nonempty set sends this supremum to
the infimum of the image of this set. -/
theorem Antitone.map_sSup_of_continuousAt' {f : Œ± ‚Üí Œ≤} {A : Set Œ±} (Cf : ContinuousAt f (sSup A))
    (Af : Antitone f) (A_nonemp : A.Nonempty) (A_bdd : BddAbove A := by bddDefault) :
    f (sSup A) = sInf (f '' A) :=
  Monotone.map_sSup_of_continuousAt' (Œ≤ := Œ≤·µí·µà) Cf Af.dual_right A_nonemp A_bdd
#align antitone.map_Sup_of_continuous_at' Antitone.map_sSup_of_continuousAt'

/-- An antitone function continuous at the indexed supremum over a nonempty `Sort` sends this
indexed supremum to the indexed infimum of the composition. -/
theorem Antitone.map_iSup_of_continuousAt' {Œπ : Sort*} [Nonempty Œπ] {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
    (Cf : ContinuousAt f (iSup g)) (Af : Antitone f)
    (bdd : BddAbove (range g) := by bddDefault) : f (‚®Ü i, g i) = ‚®Ö i, f (g i) := by
  rw [iSup, Antitone.map_sSup_of_continuousAt' Cf Af (range_nonempty g) bdd, ‚Üê range_comp, iInf]
  rfl
#align antitone.map_supr_of_continuous_at' Antitone.map_iSup_of_continuousAt'

end ConditionallyCompleteLinearOrder

section CompleteLinearOrder

variable [CompleteLinearOrder Œ±] [TopologicalSpace Œ±] [OrderTopology Œ±] [CompleteLinearOrder Œ≤]
  [TopologicalSpace Œ≤] [OrderClosedTopology Œ≤] [Nonempty Œ≥]

theorem sSup_mem_closure {Œ± : Type u} [TopologicalSpace Œ±] [CompleteLinearOrder Œ±] [OrderTopology Œ±]
    {s : Set Œ±} (hs : s.Nonempty) : sSup s ‚àà closure s :=
  (isLUB_sSup s).mem_closure hs
#align Sup_mem_closure sSup_mem_closure

theorem sInf_mem_closure {Œ± : Type u} [TopologicalSpace Œ±] [CompleteLinearOrder Œ±] [OrderTopology Œ±]
    {s : Set Œ±} (hs : s.Nonempty) : sInf s ‚àà closure s :=
  (isGLB_sInf s).mem_closure hs
#align Inf_mem_closure sInf_mem_closure

theorem IsClosed.sSup_mem {Œ± : Type u} [TopologicalSpace Œ±] [CompleteLinearOrder Œ±]
    [OrderTopology Œ±] {s : Set Œ±} (hs : s.Nonempty) (hc : IsClosed s) : sSup s ‚àà s :=
  (isLUB_sSup s).mem_of_isClosed hs hc
#align is_closed.Sup_mem IsClosed.sSup_mem

theorem IsClosed.sInf_mem {Œ± : Type u} [TopologicalSpace Œ±] [CompleteLinearOrder Œ±]
    [OrderTopology Œ±] {s : Set Œ±} (hs : s.Nonempty) (hc : IsClosed s) : sInf s ‚àà s :=
  (isGLB_sInf s).mem_of_isClosed hs hc
#align is_closed.Inf_mem IsClosed.sInf_mem

/-- A monotone function `f` sending `bot` to `bot` and continuous at the supremum of a set sends
this supremum to the supremum of the image of this set. -/
theorem Monotone.map_sSup_of_continuousAt {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (sSup s))
    (Mf : Monotone f) (fbot : f ‚ä• = ‚ä•) : f (sSup s) = sSup (f '' s) := by
  rcases s.eq_empty_or_nonempty with h | h
  ¬∑ simp [h, fbot]
  ¬∑ exact Mf.map_sSup_of_continuousAt' Cf h
#align monotone.map_Sup_of_continuous_at Monotone.map_sSup_of_continuousAt

/-- If a monotone function sending `bot` to `bot` is continuous at the indexed supremum over
a `Sort`, then it sends this indexed supremum to the indexed supremum of the composition. -/
theorem Monotone.map_iSup_of_continuousAt {Œπ : Sort*} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
    (Cf : ContinuousAt f (iSup g)) (Mf : Monotone f) (fbot : f ‚ä• = ‚ä•) :
    f (‚®Ü i, g i) = ‚®Ü i, f (g i) := by
  rw [iSup, Mf.map_sSup_of_continuousAt Cf fbot, ‚Üê range_comp, iSup]; rfl
#align monotone.map_supr_of_continuous_at Monotone.map_iSup_of_continuousAt

/-- A monotone function `f` sending `top` to `top` and continuous at the infimum of a set sends
this infimum to the infimum of the image of this set. -/
theorem Monotone.map_sInf_of_continuousAt {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (sInf s))
    (Mf : Monotone f) (ftop : f ‚ä§ = ‚ä§) : f (sInf s) = sInf (f '' s) :=
  Monotone.map_sSup_of_continuousAt (Œ± := Œ±·µí·µà) (Œ≤ := Œ≤·µí·µà) Cf Mf.dual ftop
#align monotone.map_Inf_of_continuous_at Monotone.map_sInf_of_continuousAt

/-- If a monotone function sending `top` to `top` is continuous at the indexed infimum over
a `Sort`, then it sends this indexed infimum to the indexed infimum of the composition. -/
theorem Monotone.map_iInf_of_continuousAt {Œπ : Sort*} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
    (Cf : ContinuousAt f (iInf g)) (Mf : Monotone f) (ftop : f ‚ä§ = ‚ä§) : f (iInf g) = iInf (f ‚àò g) :=
  Monotone.map_iSup_of_continuousAt (Œ± := Œ±·µí·µà) (Œ≤ := Œ≤·µí·µà) Cf Mf.dual ftop
#align monotone.map_infi_of_continuous_at Monotone.map_iInf_of_continuousAt

/-- An antitone function `f` sending `bot` to `top` and continuous at the supremum of a set sends
this supremum to the infimum of the image of this set. -/
theorem Antitone.map_sSup_of_continuousAt {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (sSup s))
    (Af : Antitone f) (fbot : f ‚ä• = ‚ä§) : f (sSup s) = sInf (f '' s) :=
  Monotone.map_sSup_of_continuousAt (show ContinuousAt (OrderDual.toDual ‚àò f) (sSup s) from Cf) Af
    fbot
#align antitone.map_Sup_of_continuous_at Antitone.map_sSup_of_continuousAt

/-- An antitone function sending `bot` to `top` is continuous at the indexed supremum over
a `Sort`, then it sends this indexed supremum to the indexed supremum of the composition. -/
theorem Antitone.map_iSup_of_continuousAt {Œπ : Sort*} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
    (Cf : ContinuousAt f (iSup g)) (Af : Antitone f) (fbot : f ‚ä• = ‚ä§) :
    f (‚®Ü i, g i) = ‚®Ö i, f (g i) :=
  Monotone.map_iSup_of_continuousAt (show ContinuousAt (OrderDual.toDual ‚àò f) (iSup g) from Cf) Af
    fbot
#align antitone.map_supr_of_continuous_at Antitone.map_iSup_of_continuousAt

/-- An antitone function `f` sending `top` to `bot` and continuous at the infimum of a set sends
this infimum to the supremum of the image of this set. -/
theorem Antitone.map_sInf_of_continuousAt {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (sInf s))
    (Af : Antitone f) (ftop : f ‚ä§ = ‚ä•) : f (sInf s) = sSup (f '' s) :=
  Monotone.map_sInf_of_continuousAt (show ContinuousAt (OrderDual.toDual ‚àò f) (sInf s) from Cf) Af
    ftop
#align antitone.map_Inf_of_continuous_at Antitone.map_sInf_of_continuousAt

/-- If an antitone function sending `top` to `bot` is continuous at the indexed infimum over
a `Sort`, then it sends this indexed infimum to the indexed supremum of the composition. -/
theorem Antitone.map_iInf_of_continuousAt {Œπ : Sort*} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
    (Cf : ContinuousAt f (iInf g)) (Af : Antitone f) (ftop : f ‚ä§ = ‚ä•) : f (iInf g) = iSup (f ‚àò g) :=
  Monotone.map_iInf_of_continuousAt (show ContinuousAt (OrderDual.toDual ‚àò f) (iInf g) from Cf) Af
    ftop
#align antitone.map_infi_of_continuous_at Antitone.map_iInf_of_continuousAt

end CompleteLinearOrder

section ConditionallyCompleteLinearOrder

variable [ConditionallyCompleteLinearOrder Œ±] [TopologicalSpace Œ±] [OrderTopology Œ±]
  [ConditionallyCompleteLinearOrder Œ≤] [TopologicalSpace Œ≤] [OrderClosedTopology Œ≤] [Nonempty Œ≥]

theorem csSup_mem_closure {s : Set Œ±} (hs : s.Nonempty) (B : BddAbove s) : sSup s ‚àà closure s :=
  (isLUB_csSup hs B).mem_closure hs
#align cSup_mem_closure csSup_mem_closure

theorem csInf_mem_closure {s : Set Œ±} (hs : s.Nonempty) (B : BddBelow s) : sInf s ‚àà closure s :=
  (isGLB_csInf hs B).mem_closure hs
#align cInf_mem_closure csInf_mem_closure

theorem IsClosed.csSup_mem {s : Set Œ±} (hc : IsClosed s) (hs : s.Nonempty) (B : BddAbove s) :
    sSup s ‚àà s :=
  (isLUB_csSup hs B).mem_of_isClosed hs hc
#align is_closed.cSup_mem IsClosed.csSup_mem

theorem IsClosed.csInf_mem {s : Set Œ±} (hc : IsClosed s) (hs : s.Nonempty) (B : BddBelow s) :
    sInf s ‚àà s :=
  (isGLB_csInf hs B).mem_of_isClosed hs hc
#align is_closed.cInf_mem IsClosed.csInf_mem

theorem IsClosed.isLeast_csInf {s : Set Œ±} (hc : IsClosed s) (hs : s.Nonempty) (B : BddBelow s) :
    IsLeast s (sInf s) :=
  ‚ü®hc.csInf_mem hs B, (isGLB_csInf hs B).1‚ü©

theorem IsClosed.isGreatest_csSup {s : Set Œ±} (hc : IsClosed s) (hs : s.Nonempty) (B : BddAbove s) :
    IsGreatest s (sSup s) :=
  IsClosed.isLeast_csInf (Œ± := Œ±·µí·µà) hc hs B

/-- If a monotone function is continuous at the supremum of a nonempty bounded above set `s`,
then it sends this supremum to the supremum of the image of `s`. -/
theorem Monotone.map_csSup_of_continuousAt {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (sSup s))
    (Mf : Monotone f) (ne : s.Nonempty) (H : BddAbove s) : f (sSup s) = sSup (f '' s) := by
  refine' ((isLUB_csSup (ne.image f) (Mf.map_bddAbove H)).unique _).symm
  refine' (isLUB_csSup ne H).isLUB_of_tendsto (fun x _ y _ xy => Mf xy) ne _
  exact Cf.mono_left inf_le_left
#align monotone.map_cSup_of_continuous_at Monotone.map_csSup_of_continuousAt

/-- If a monotone function is continuous at the indexed supremum of a bounded function on
a nonempty `Sort`, then it sends this supremum to the supremum of the composition. -/
theorem Monotone.map_ciSup_of_continuousAt {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±} (Cf : ContinuousAt f (‚®Ü i, g i))
    (Mf : Monotone f) (H : BddAbove (range g)) : f (‚®Ü i, g i) = ‚®Ü i, f (g i) := by
  rw [iSup, Mf.map_csSup_of_continuousAt Cf (range_nonempty _) H, ‚Üê range_comp, iSup]; rfl
#align monotone.map_csupr_of_continuous_at Monotone.map_ciSup_of_continuousAt

/-- If a monotone function is continuous at the infimum of a nonempty bounded below set `s`,
then it sends this infimum to the infimum of the image of `s`. -/
theorem Monotone.map_csInf_of_continuousAt {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (sInf s))
    (Mf : Monotone f) (ne : s.Nonempty) (H : BddBelow s) : f (sInf s) = sInf (f '' s) :=
  Monotone.map_csSup_of_continuousAt (Œ± := Œ±·µí·µà) (Œ≤ := Œ≤·µí·µà) Cf Mf.dual ne H
#align monotone.map_cInf_of_continuous_at Monotone.map_csInf_of_continuousAt

/-- A continuous monotone function sends indexed infimum to indexed infimum in conditionally
complete linear order, under a boundedness assumption. -/
theorem Monotone.map_ciInf_of_continuousAt {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±} (Cf : ContinuousAt f (‚®Ö i, g i))
    (Mf : Monotone f) (H : BddBelow (range g)) : f (‚®Ö i, g i) = ‚®Ö i, f (g i) :=
  Monotone.map_ciSup_of_continuousAt (Œ± := Œ±·µí·µà) (Œ≤ := Œ≤·µí·µà) Cf Mf.dual H
#align monotone.map_cinfi_of_continuous_at Monotone.map_ciInf_of_continuousAt

/-- If an antitone function is continuous at the supremum of a nonempty bounded above set `s`,
then it sends this supremum to the infimum of the image of `s`. -/
theorem Antitone.map_csSup_of_continuousAt {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (sSup s))
    (Af : Antitone f) (ne : s.Nonempty) (H : BddAbove s) : f (sSup s) = sInf (f '' s) :=
  Monotone.map_csSup_of_continuousAt (show ContinuousAt (OrderDual.toDual ‚àò f) (sSup s) from Cf) Af
    ne H
#align antitone.map_cSup_of_continuous_at Antitone.map_csSup_of_continuousAt

/-- If an antitone function is continuous at the indexed supremum of a bounded function on
a nonempty `Sort`, then it sends this supremum to the infimum of the composition. -/
theorem Antitone.map_ciSup_of_continuousAt {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±} (Cf : ContinuousAt f (‚®Ü i, g i))
    (Af : Antitone f) (H : BddAbove (range g)) : f (‚®Ü i, g i) = ‚®Ö i, f (g i) :=
  Monotone.map_ciSup_of_continuousAt (show ContinuousAt (OrderDual.toDual ‚àò f) (‚®Ü i, g i) from Cf)
    Af H
#align antitone.map_csupr_of_continuous_at Antitone.map_ciSup_of_continuousAt

/-- If an antitone function is continuous at the infimum of a nonempty bounded below set `s`,
then it sends this infimum to the supremum of the image of `s`. -/
theorem Antitone.map_csInf_of_continuousAt {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (sInf s))
    (Af : Antitone f) (ne : s.Nonempty) (H : BddBelow s) : f (sInf s) = sSup (f '' s) :=
  Monotone.map_csInf_of_continuousAt (show ContinuousAt (OrderDual.toDual ‚àò f) (sInf s) from Cf) Af
    ne H
#align antitone.map_cInf_of_continuous_at Antitone.map_csInf_of_continuousAt

/-- A continuous antitone function sends indexed infimum to indexed supremum in conditionally
complete linear order, under a boundedness assumption. -/
theorem Antitone.map_ciInf_of_continuousAt {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±} (Cf : ContinuousAt f (‚®Ö i, g i))
    (Af : Antitone f) (H : BddBelow (range g)) : f (‚®Ö i, g i) = ‚®Ü i, f (g i) :=
  Monotone.map_ciInf_of_continuousAt (show ContinuousAt (OrderDual.toDual ‚àò f) (‚®Ö i, g i) from Cf)
    Af H
#align antitone.map_cinfi_of_continuous_at Antitone.map_ciInf_of_continuousAt

/-- A monotone map has a limit to the left of any point `x`, equal to `sSup (f '' (Iio x))`. -/
theorem Monotone.tendsto_nhdsWithin_Iio {Œ± Œ≤ : Type*} [LinearOrder Œ±] [TopologicalSpace Œ±]
    [OrderTopology Œ±] [ConditionallyCompleteLinearOrder Œ≤] [TopologicalSpace Œ≤] [OrderTopology Œ≤]
    {f : Œ± ‚Üí Œ≤} (Mf : Monotone f) (x : Œ±) : Tendsto f (ùìù[<] x) (ùìù (sSup (f '' Iio x))) := by
  rcases eq_empty_or_nonempty (Iio x) with (h | h); ¬∑ simp [h]
  refine' tendsto_order.2 ‚ü®fun l hl => _, fun m hm => _‚ü©
  ¬∑ obtain ‚ü®z, zx, lz‚ü© : ‚àÉ a : Œ±, a < x ‚àß l < f a := by
      simpa only [mem_image, exists_prop, exists_exists_and_eq_and] using
        exists_lt_of_lt_csSup (h.image _) hl
    exact mem_of_superset (Ioo_mem_nhdsWithin_Iio' zx) fun y hy => lz.trans_le (Mf hy.1.le)
  ¬∑ refine mem_of_superset self_mem_nhdsWithin fun _ hy => lt_of_le_of_lt ?_ hm
    exact le_csSup (Mf.map_bddAbove bddAbove_Iio) (mem_image_of_mem _ hy)
#align monotone.tendsto_nhds_within_Iio Monotone.tendsto_nhdsWithin_Iio

/-- A monotone map has a limit to the right of any point `x`, equal to `sInf (f '' (Ioi x))`. -/
theorem Monotone.tendsto_nhdsWithin_Ioi {Œ± Œ≤ : Type*} [LinearOrder Œ±] [TopologicalSpace Œ±]
    [OrderTopology Œ±] [ConditionallyCompleteLinearOrder Œ≤] [TopologicalSpace Œ≤] [OrderTopology Œ≤]
    {f : Œ± ‚Üí Œ≤} (Mf : Monotone f) (x : Œ±) : Tendsto f (ùìù[>] x) (ùìù (sInf (f '' Ioi x))) :=
  Monotone.tendsto_nhdsWithin_Iio (Œ± := Œ±·µí·µà) (Œ≤ := Œ≤·µí·µà) Mf.dual x
#align monotone.tendsto_nhds_within_Ioi Monotone.tendsto_nhdsWithin_Ioi

end ConditionallyCompleteLinearOrder

end OrderTopology
