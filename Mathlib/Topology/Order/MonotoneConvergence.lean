/-
Copyright (c) 2021 Heather Macbeth. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Heather Macbeth, Yury Kudryashov
-/
import Mathlib.Topology.Order.Basic

/-!
# Bounded monotone sequences converge

In this file we prove a few theorems of the form ‚Äúif the range of a monotone function `f : Œπ ‚Üí Œ±`
admits a least upper bound `a`, then `f x` tends to `a` as `x ‚Üí ‚àû`‚Äù, as well as version of this
statement for (conditionally) complete lattices that use `‚®Ü x, f x` instead of `IsLUB`.

These theorems work for linear orders with order topologies as well as their products (both in terms
of `Prod` and in terms of function types). In order to reduce code duplication, we introduce two
typeclasses (one for the property formulated above and one for the dual property), prove theorems
assuming one of these typeclasses, and provide instances for linear orders and their products.

We also prove some "inverse" results: if `f n` is a monotone sequence and `a` is its limit,
then `f n ‚â§ a` for all `n`.

## Tags

monotone convergence
-/

open Filter Set Function
open scoped Topology

variable {Œ± Œ≤ : Type*}

/-- We say that `Œ±` is a `SupConvergenceClass` if the following holds. Let `f : Œπ ‚Üí Œ±` be a
monotone function, let `a : Œ±` be a least upper bound of `Set.range f`. Then `f x` tends to `ùìù a`
 as `x ‚Üí ‚àû` (formally, at the filter `Filter.atTop`). We require this for `Œπ = (s : Set Œ±)`,
`f = CoeTC.coe` in the definition, then prove it for any `f` in `tendsto_atTop_isLUB`.

This property holds for linear orders with order topology as well as their products. -/
class SupConvergenceClass (Œ± : Type*) [Preorder Œ±] [TopologicalSpace Œ±] : Prop where
  /-- proof that a monotone function tends to `ùìù a` as `x ‚Üí ‚àû` -/
  tendsto_coe_atTop_isLUB :
    ‚àÄ (a : Œ±) (s : Set Œ±), IsLUB s a ‚Üí Tendsto (CoeTC.coe : s ‚Üí Œ±) atTop (ùìù a)

/-- We say that `Œ±` is an `InfConvergenceClass` if the following holds. Let `f : Œπ ‚Üí Œ±` be a
monotone function, let `a : Œ±` be a greatest lower bound of `Set.range f`. Then `f x` tends to `ùìù a`
as `x ‚Üí -‚àû` (formally, at the filter `Filter.atBot`). We require this for `Œπ = (s : Set Œ±)`,
`f = CoeTC.coe` in the definition, then prove it for any `f` in `tendsto_atBot_isGLB`.

This property holds for linear orders with order topology as well as their products. -/
class InfConvergenceClass (Œ± : Type*) [Preorder Œ±] [TopologicalSpace Œ±] : Prop where
  /-- proof that a monotone function tends to `ùìù a` as `x ‚Üí -‚àû`-/
  tendsto_coe_atBot_isGLB :
    ‚àÄ (a : Œ±) (s : Set Œ±), IsGLB s a ‚Üí Tendsto (CoeTC.coe : s ‚Üí Œ±) atBot (ùìù a)

instance OrderDual.supConvergenceClass [Preorder Œ±] [TopologicalSpace Œ±] [InfConvergenceClass Œ±] :
    SupConvergenceClass Œ±·µí·µà :=
  ‚ü®‚ÄπInfConvergenceClass Œ±‚Ä∫.1‚ü©

instance OrderDual.infConvergenceClass [Preorder Œ±] [TopologicalSpace Œ±] [SupConvergenceClass Œ±] :
    InfConvergenceClass Œ±·µí·µà :=
  ‚ü®‚ÄπSupConvergenceClass Œ±‚Ä∫.1‚ü©

-- see Note [lower instance priority]
instance (priority := 100) LinearOrder.supConvergenceClass [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderTopology Œ±] : SupConvergenceClass Œ± := by
  refine ‚ü®fun a s ha => tendsto_order.2 ‚ü®fun b hb => ?_, fun b hb => ?_‚ü©‚ü©
  ¬∑ rcases ha.exists_between hb with ‚ü®c, hcs, bc, bca‚ü©
    lift c to s using hcs
    exact (eventually_ge_atTop c).mono fun x hx => bc.trans_le hx
  ¬∑ exact Eventually.of_forall fun x => (ha.1 x.2).trans_lt hb

-- see Note [lower instance priority]
instance (priority := 100) LinearOrder.infConvergenceClass [TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderTopology Œ±] : InfConvergenceClass Œ± :=
  show InfConvergenceClass Œ±·µí·µà·µí·µà from OrderDual.infConvergenceClass

section

variable {Œπ : Type*} [Preorder Œπ] [TopologicalSpace Œ±]

section IsLUB

variable [Preorder Œ±] [SupConvergenceClass Œ±] {f : Œπ ‚Üí Œ±} {a : Œ±}

theorem tendsto_atTop_isLUB (h_mono : Monotone f) (ha : IsLUB (Set.range f) a) :
    Tendsto f atTop (ùìù a) := by
  suffices Tendsto (rangeFactorization f) atTop atTop from
    (SupConvergenceClass.tendsto_coe_atTop_isLUB _ _ ha).comp this
  exact h_mono.rangeFactorization.tendsto_atTop_atTop fun b => b.2.imp fun a ha => ha.ge

theorem tendsto_atBot_isLUB (h_anti : Antitone f) (ha : IsLUB (Set.range f) a) :
    Tendsto f atBot (ùìù a) := by convert tendsto_atTop_isLUB h_anti.dual_left ha using 1

end IsLUB

section IsGLB

variable [Preorder Œ±] [InfConvergenceClass Œ±] {f : Œπ ‚Üí Œ±} {a : Œ±}

theorem tendsto_atBot_isGLB (h_mono : Monotone f) (ha : IsGLB (Set.range f) a) :
    Tendsto f atBot (ùìù a) := by convert tendsto_atTop_isLUB h_mono.dual ha.dual using 1

theorem tendsto_atTop_isGLB (h_anti : Antitone f) (ha : IsGLB (Set.range f) a) :
    Tendsto f atTop (ùìù a) := by convert tendsto_atBot_isLUB h_anti.dual ha.dual using 1

end IsGLB

section CiSup

variable [ConditionallyCompleteLattice Œ±] [SupConvergenceClass Œ±] {f : Œπ ‚Üí Œ±}

theorem tendsto_atTop_ciSup (h_mono : Monotone f) (hbdd : BddAbove <| range f) :
    Tendsto f atTop (ùìù (‚®Ü i, f i)) := by
  cases isEmpty_or_nonempty Œπ
  exacts [tendsto_of_isEmpty, tendsto_atTop_isLUB h_mono (isLUB_ciSup hbdd)]

theorem tendsto_atBot_ciSup (h_anti : Antitone f) (hbdd : BddAbove <| range f) :
    Tendsto f atBot (ùìù (‚®Ü i, f i)) := by convert tendsto_atTop_ciSup h_anti.dual hbdd.dual using 1

end CiSup

section CiInf

variable [ConditionallyCompleteLattice Œ±] [InfConvergenceClass Œ±] {f : Œπ ‚Üí Œ±}

theorem tendsto_atBot_ciInf (h_mono : Monotone f) (hbdd : BddBelow <| range f) :
    Tendsto f atBot (ùìù (‚®Ö i, f i)) := by convert tendsto_atTop_ciSup h_mono.dual hbdd.dual using 1

theorem tendsto_atTop_ciInf (h_anti : Antitone f) (hbdd : BddBelow <| range f) :
    Tendsto f atTop (ùìù (‚®Ö i, f i)) := by convert tendsto_atBot_ciSup h_anti.dual hbdd.dual using 1

end CiInf

section iSup

variable [CompleteLattice Œ±] [SupConvergenceClass Œ±] {f : Œπ ‚Üí Œ±}

theorem tendsto_atTop_iSup (h_mono : Monotone f) : Tendsto f atTop (ùìù (‚®Ü i, f i)) :=
  tendsto_atTop_ciSup h_mono (OrderTop.bddAbove _)

theorem tendsto_atBot_iSup (h_anti : Antitone f) : Tendsto f atBot (ùìù (‚®Ü i, f i)) :=
  tendsto_atBot_ciSup h_anti (OrderTop.bddAbove _)

end iSup

section iInf

variable [CompleteLattice Œ±] [InfConvergenceClass Œ±] {f : Œπ ‚Üí Œ±}

theorem tendsto_atBot_iInf (h_mono : Monotone f) : Tendsto f atBot (ùìù (‚®Ö i, f i)) :=
  tendsto_atBot_ciInf h_mono (OrderBot.bddBelow _)

theorem tendsto_atTop_iInf (h_anti : Antitone f) : Tendsto f atTop (ùìù (‚®Ö i, f i)) :=
  tendsto_atTop_ciInf h_anti (OrderBot.bddBelow _)

end iInf

end

instance Prod.supConvergenceClass
    [Preorder Œ±] [Preorder Œ≤] [TopologicalSpace Œ±] [TopologicalSpace Œ≤]
    [SupConvergenceClass Œ±] [SupConvergenceClass Œ≤] : SupConvergenceClass (Œ± √ó Œ≤) := by
  constructor
  rintro ‚ü®a, b‚ü© s h
  rw [isLUB_prod, ‚Üê range_restrict, ‚Üê range_restrict] at h
  have A : Tendsto (fun x : s => (x : Œ± √ó Œ≤).1) atTop (ùìù a) :=
    tendsto_atTop_isLUB (monotone_fst.restrict s) h.1
  have B : Tendsto (fun x : s => (x : Œ± √ó Œ≤).2) atTop (ùìù b) :=
    tendsto_atTop_isLUB (monotone_snd.restrict s) h.2
  convert A.prod_mk_nhds B
  -- Porting note: previously required below to close
  -- ext1 ‚ü®‚ü®x, y‚ü©, h‚ü©
  -- rfl

instance [Preorder Œ±] [Preorder Œ≤] [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [InfConvergenceClass Œ±]
    [InfConvergenceClass Œ≤] : InfConvergenceClass (Œ± √ó Œ≤) :=
  show InfConvergenceClass (Œ±·µí·µà √ó Œ≤·µí·µà)·µí·µà from OrderDual.infConvergenceClass

instance Pi.supConvergenceClass
    {Œπ : Type*} {Œ± : Œπ ‚Üí Type*} [‚àÄ i, Preorder (Œ± i)] [‚àÄ i, TopologicalSpace (Œ± i)]
    [‚àÄ i, SupConvergenceClass (Œ± i)] : SupConvergenceClass (‚àÄ i, Œ± i) := by
  refine ‚ü®fun f s h => ?_‚ü©
  simp only [isLUB_pi, ‚Üê range_restrict] at h
  exact tendsto_pi_nhds.2 fun i => tendsto_atTop_isLUB ((monotone_eval _).restrict _) (h i)

instance Pi.infConvergenceClass
    {Œπ : Type*} {Œ± : Œπ ‚Üí Type*} [‚àÄ i, Preorder (Œ± i)] [‚àÄ i, TopologicalSpace (Œ± i)]
    [‚àÄ i, InfConvergenceClass (Œ± i)] : InfConvergenceClass (‚àÄ i, Œ± i) :=
  show InfConvergenceClass (‚àÄ i, (Œ± i)·µí·µà)·µí·µà from OrderDual.infConvergenceClass

instance Pi.supConvergenceClass' {Œπ : Type*} [Preorder Œ±] [TopologicalSpace Œ±]
    [SupConvergenceClass Œ±] : SupConvergenceClass (Œπ ‚Üí Œ±) :=
  supConvergenceClass

instance Pi.infConvergenceClass' {Œπ : Type*} [Preorder Œ±] [TopologicalSpace Œ±]
    [InfConvergenceClass Œ±] : InfConvergenceClass (Œπ ‚Üí Œ±) :=
  Pi.infConvergenceClass

theorem tendsto_of_monotone {Œπ Œ± : Type*} [Preorder Œπ] [TopologicalSpace Œ±]
    [ConditionallyCompleteLinearOrder Œ±] [OrderTopology Œ±] {f : Œπ ‚Üí Œ±} (h_mono : Monotone f) :
    Tendsto f atTop atTop ‚à® ‚àÉ l, Tendsto f atTop (ùìù l) := by
  classical
  exact if H : BddAbove (range f) then Or.inr ‚ü®_, tendsto_atTop_ciSup h_mono H‚ü©
  else Or.inl <| tendsto_atTop_atTop_of_monotone' h_mono H

theorem tendsto_of_antitone {Œπ Œ± : Type*} [Preorder Œπ] [TopologicalSpace Œ±]
    [ConditionallyCompleteLinearOrder Œ±] [OrderTopology Œ±] {f : Œπ ‚Üí Œ±} (h_mono : Antitone f) :
    Tendsto f atTop atBot ‚à® ‚àÉ l, Tendsto f atTop (ùìù l) :=
  @tendsto_of_monotone Œπ Œ±·µí·µà _ _ _ _ _ h_mono

theorem tendsto_iff_tendsto_subseq_of_monotone {Œπ‚ÇÅ Œπ‚ÇÇ Œ± : Type*} [SemilatticeSup Œπ‚ÇÅ] [Preorder Œπ‚ÇÇ]
    [Nonempty Œπ‚ÇÅ] [TopologicalSpace Œ±] [ConditionallyCompleteLinearOrder Œ±] [OrderTopology Œ±]
    [NoMaxOrder Œ±] {f : Œπ‚ÇÇ ‚Üí Œ±} {œÜ : Œπ‚ÇÅ ‚Üí Œπ‚ÇÇ} {l : Œ±} (hf : Monotone f)
    (hg : Tendsto œÜ atTop atTop) : Tendsto f atTop (ùìù l) ‚Üî Tendsto (f ‚àò œÜ) atTop (ùìù l) := by
  constructor <;> intro h
  ¬∑ exact h.comp hg
  ¬∑ rcases tendsto_of_monotone hf with (h' | ‚ü®l', hl'‚ü©)
    ¬∑ exact (not_tendsto_atTop_of_tendsto_nhds h (h'.comp hg)).elim
    ¬∑ rwa [tendsto_nhds_unique h (hl'.comp hg)]

theorem tendsto_iff_tendsto_subseq_of_antitone {Œπ‚ÇÅ Œπ‚ÇÇ Œ± : Type*} [SemilatticeSup Œπ‚ÇÅ] [Preorder Œπ‚ÇÇ]
    [Nonempty Œπ‚ÇÅ] [TopologicalSpace Œ±] [ConditionallyCompleteLinearOrder Œ±] [OrderTopology Œ±]
    [NoMinOrder Œ±] {f : Œπ‚ÇÇ ‚Üí Œ±} {œÜ : Œπ‚ÇÅ ‚Üí Œπ‚ÇÇ} {l : Œ±} (hf : Antitone f)
    (hg : Tendsto œÜ atTop atTop) : Tendsto f atTop (ùìù l) ‚Üî Tendsto (f ‚àò œÜ) atTop (ùìù l) :=
  tendsto_iff_tendsto_subseq_of_monotone (Œ± := Œ±·µí·µà) hf hg

/-! The next family of results, such as `isLUB_of_tendsto_atTop` and `iSup_eq_of_tendsto`, are
converses to the standard fact that bounded monotone functions converge. They state, that if a
monotone function `f` tends to `a` along `Filter.atTop`, then that value `a` is a least upper bound
for the range of `f`.

Related theorems above (`IsLUB.isLUB_of_tendsto`, `IsGLB.isGLB_of_tendsto` etc) cover the case
when `f x` tends to `a` as `x` tends to some point `b` in the domain. -/

theorem Monotone.ge_of_tendsto [TopologicalSpace Œ±] [Preorder Œ±] [OrderClosedTopology Œ±]
    [SemilatticeSup Œ≤] {f : Œ≤ ‚Üí Œ±} {a : Œ±} (hf : Monotone f) (ha : Tendsto f atTop (ùìù a)) (b : Œ≤) :
    f b ‚â§ a :=
  haveI : Nonempty Œ≤ := Nonempty.intro b
  _root_.ge_of_tendsto ha ((eventually_ge_atTop b).mono fun _ hxy => hf hxy)

theorem Monotone.le_of_tendsto [TopologicalSpace Œ±] [Preorder Œ±] [OrderClosedTopology Œ±]
    [SemilatticeInf Œ≤] {f : Œ≤ ‚Üí Œ±} {a : Œ±} (hf : Monotone f) (ha : Tendsto f atBot (ùìù a)) (b : Œ≤) :
    a ‚â§ f b :=
  hf.dual.ge_of_tendsto ha b

theorem Antitone.le_of_tendsto [TopologicalSpace Œ±] [Preorder Œ±] [OrderClosedTopology Œ±]
    [SemilatticeSup Œ≤] {f : Œ≤ ‚Üí Œ±} {a : Œ±} (hf : Antitone f) (ha : Tendsto f atTop (ùìù a)) (b : Œ≤) :
    a ‚â§ f b :=
  hf.dual_right.ge_of_tendsto ha b

theorem Antitone.ge_of_tendsto [TopologicalSpace Œ±] [Preorder Œ±] [OrderClosedTopology Œ±]
    [SemilatticeInf Œ≤] {f : Œ≤ ‚Üí Œ±} {a : Œ±} (hf : Antitone f) (ha : Tendsto f atBot (ùìù a)) (b : Œ≤) :
    f b ‚â§ a :=
  hf.dual_right.le_of_tendsto ha b

theorem isLUB_of_tendsto_atTop [TopologicalSpace Œ±] [Preorder Œ±] [OrderClosedTopology Œ±]
    [Nonempty Œ≤] [SemilatticeSup Œ≤] {f : Œ≤ ‚Üí Œ±} {a : Œ±} (hf : Monotone f)
    (ha : Tendsto f atTop (ùìù a)) : IsLUB (Set.range f) a := by
  constructor
  ¬∑ rintro _ ‚ü®b, rfl‚ü©
    exact hf.ge_of_tendsto ha b
  ¬∑ exact fun _ hb => le_of_tendsto' ha fun x => hb (Set.mem_range_self x)

theorem isGLB_of_tendsto_atBot [TopologicalSpace Œ±] [Preorder Œ±] [OrderClosedTopology Œ±]
    [Nonempty Œ≤] [SemilatticeInf Œ≤] {f : Œ≤ ‚Üí Œ±} {a : Œ±} (hf : Monotone f)
    (ha : Tendsto f atBot (ùìù a)) : IsGLB (Set.range f) a :=
  @isLUB_of_tendsto_atTop Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ _ hf.dual ha

theorem isLUB_of_tendsto_atBot [TopologicalSpace Œ±] [Preorder Œ±] [OrderClosedTopology Œ±]
    [Nonempty Œ≤] [SemilatticeInf Œ≤] {f : Œ≤ ‚Üí Œ±} {a : Œ±} (hf : Antitone f)
    (ha : Tendsto f atBot (ùìù a)) : IsLUB (Set.range f) a :=
  @isLUB_of_tendsto_atTop Œ± Œ≤·µí·µà _ _ _ _ _ _ _ hf.dual_left ha

theorem isGLB_of_tendsto_atTop [TopologicalSpace Œ±] [Preorder Œ±] [OrderClosedTopology Œ±]
    [Nonempty Œ≤] [SemilatticeSup Œ≤] {f : Œ≤ ‚Üí Œ±} {a : Œ±} (hf : Antitone f)
    (ha : Tendsto f atTop (ùìù a)) : IsGLB (Set.range f) a :=
  @isGLB_of_tendsto_atBot Œ± Œ≤·µí·µà _ _ _ _ _ _ _ hf.dual_left ha

theorem iSup_eq_of_tendsto {Œ± Œ≤} [TopologicalSpace Œ±] [CompleteLinearOrder Œ±] [OrderTopology Œ±]
    [Nonempty Œ≤] [SemilatticeSup Œ≤] {f : Œ≤ ‚Üí Œ±} {a : Œ±} (hf : Monotone f) :
    Tendsto f atTop (ùìù a) ‚Üí iSup f = a :=
  tendsto_nhds_unique (tendsto_atTop_iSup hf)

theorem iInf_eq_of_tendsto {Œ±} [TopologicalSpace Œ±] [CompleteLinearOrder Œ±] [OrderTopology Œ±]
    [Nonempty Œ≤] [SemilatticeSup Œ≤] {f : Œ≤ ‚Üí Œ±} {a : Œ±} (hf : Antitone f) :
    Tendsto f atTop (ùìù a) ‚Üí iInf f = a :=
  tendsto_nhds_unique (tendsto_atTop_iInf hf)

theorem iSup_eq_iSup_subseq_of_monotone {Œπ‚ÇÅ Œπ‚ÇÇ Œ± : Type*} [Preorder Œπ‚ÇÇ] [CompleteLattice Œ±]
    {l : Filter Œπ‚ÇÅ} [l.NeBot] {f : Œπ‚ÇÇ ‚Üí Œ±} {œÜ : Œπ‚ÇÅ ‚Üí Œπ‚ÇÇ} (hf : Monotone f)
    (hœÜ : Tendsto œÜ l atTop) : ‚®Ü i, f i = ‚®Ü i, f (œÜ i) :=
  le_antisymm
    (iSup_mono' fun i =>
      Exists.imp (fun j (hj : i ‚â§ œÜ j) => hf hj) (hœÜ.eventually <| eventually_ge_atTop i).exists)
    (iSup_mono' fun i => ‚ü®œÜ i, le_rfl‚ü©)

theorem iSup_eq_iSup_subseq_of_antitone {Œπ‚ÇÅ Œπ‚ÇÇ Œ± : Type*} [Preorder Œπ‚ÇÇ] [CompleteLattice Œ±]
    {l : Filter Œπ‚ÇÅ} [l.NeBot] {f : Œπ‚ÇÇ ‚Üí Œ±} {œÜ : Œπ‚ÇÅ ‚Üí Œπ‚ÇÇ} (hf : Antitone f)
    (hœÜ : Tendsto œÜ l atBot) : ‚®Ü i, f i = ‚®Ü i, f (œÜ i) :=
  le_antisymm
    (iSup_mono' fun i =>
      Exists.imp (fun j (hj : œÜ j ‚â§ i) => hf hj) (hœÜ.eventually <| eventually_le_atBot i).exists)
    (iSup_mono' fun i => ‚ü®œÜ i, le_rfl‚ü©)

theorem iInf_eq_iInf_subseq_of_monotone {Œπ‚ÇÅ Œπ‚ÇÇ Œ± : Type*} [Preorder Œπ‚ÇÇ] [CompleteLattice Œ±]
    {l : Filter Œπ‚ÇÅ} [l.NeBot] {f : Œπ‚ÇÇ ‚Üí Œ±} {œÜ : Œπ‚ÇÅ ‚Üí Œπ‚ÇÇ} (hf : Monotone f)
    (hœÜ : Tendsto œÜ l atBot) : ‚®Ö i, f i = ‚®Ö i, f (œÜ i) :=
  iSup_eq_iSup_subseq_of_monotone hf.dual hœÜ

theorem iInf_eq_iInf_subseq_of_antitone {Œπ‚ÇÅ Œπ‚ÇÇ Œ± : Type*} [Preorder Œπ‚ÇÇ] [CompleteLattice Œ±]
    {l : Filter Œπ‚ÇÅ} [l.NeBot] {f : Œπ‚ÇÇ ‚Üí Œ±} {œÜ : Œπ‚ÇÅ ‚Üí Œπ‚ÇÇ} (hf : Antitone f)
    (hœÜ : Tendsto œÜ l atTop) : ‚®Ö i, f i = ‚®Ö i, f (œÜ i) :=
  iSup_eq_iSup_subseq_of_antitone hf.dual hœÜ
