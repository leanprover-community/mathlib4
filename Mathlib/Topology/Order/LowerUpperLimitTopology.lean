/-
Copyright (c) 2025 Yongxi Lin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yongxi Lin
-/
module

public import Mathlib.Topology.Order.OrderClosed

/-!
# Lower and Upper topology

This file introduces the lower limit topology on a preorder as the topology generated by the
right-open left-closed intervals. We also introduce the dual upper limit topology, generated by the
right-closed left-open intervals.

## Main statements

- `continuous_iff_rightContinuous` - a function is continuous with respects to the lower limit
  topology iff it is right continuous

## Implementation notes

A type synonym `WithLowerLimit` is introduced and for a preorder `Î±`, `WithLowerLimit Î±`
is made an instance of `TopologicalSpace` by the topology generated by the
right-open left-closed intervals.

We define a mixin class `IsLowerLimit` for the class of types which are both a preorder and a
topology and where the topology is generated by the right-open left-closed intervals. It is shown
that `WithLowerLimit Î±` is an instance of `IsLowerLimit`.

Similarly for the upper limit topology.

## Motivation

The lower limit topology can be used to give a topological characertization of right continuous
functions.

-/

@[expose] public section

open Set TopologicalSpace Topology Filter

namespace Topology

variable {Î± Î² : Type*}

/--
The lower limit topology is the topology generated by the right-open left-closed intervals.
-/
def lowerLimit (Î± : Type*) [Preorder Î±] : TopologicalSpace Î± :=
  TopologicalSpace.generateFrom {s | âˆƒ i j, s = Set.Ico i j}

/--
The upper limit topology is the topology generated by the right-closed left-open intervals.
-/
def upperLimit (Î± : Type*) [Preorder Î±] : TopologicalSpace Î± :=
  TopologicalSpace.generateFrom {s | âˆƒ i j, s = Set.Ioc i j}

/-- Type synonym for a preorder equipped with the lower limit topology. -/
def WithLowerLimit (Î± : Type*) := Î±

namespace WithLowerLimit

/-- `toLowerLimit` is the identity function to the `WithLowerLimit` of a type. -/
@[match_pattern] def toLowerLimit : Î± â‰ƒ WithLowerLimit Î± := Equiv.refl _

/-- `ofLowerLimit` is the identity function from the `WithLowerLimit` of a type. -/
@[match_pattern] def ofLowerLimit : WithLowerLimit Î± â‰ƒ Î± := Equiv.refl _

@[simp] lemma toLowerLimit_symm : (@toLowerLimit Î±).symm = ofLowerLimit := rfl
@[simp] lemma ofLowerLimit_symm : (@ofLowerLimit Î±).symm = toLowerLimit := rfl
@[simp] lemma toLowerLimit_ofLowerLimit (a : WithLowerLimit Î±) : toLowerLimit (ofLowerLimit a) =
  a := rfl

@[simp] lemma ofLowerLimit_toLowerLimit (a : Î±) : ofLowerLimit (toLowerLimit a) = a := rfl

lemma toLower_inj {a b : Î±} : toLowerLimit a = toLowerLimit b â†” a = b := Iff.rfl

theorem ofLower_inj {a b : WithLowerLimit Î±} : ofLowerLimit a = ofLowerLimit b â†” a = b :=
  Iff.rfl

/-- A recursor for `WithLowerLimit`. Use as `induction x`. -/
@[elab_as_elim, cases_eliminator, induction_eliminator]
protected def rec {motive : WithLowerLimit Î± â†’ Sort*}
    (toLowerLimit : âˆ€ a, motive (toLowerLimit a)) : âˆ€ a, motive a :=
  fun a => toLowerLimit (ofLowerLimit a)

instance [Nonempty Î±] : Nonempty (WithLowerLimit Î±) := â€¹Nonempty Î±â€º
instance [Inhabited Î±] : Inhabited (WithLowerLimit Î±) := â€¹Inhabited Î±â€º

section Preorder

variable [Preorder Î±] {s : Set Î±}

instance : Preorder (WithLowerLimit Î±) := â€¹Preorder Î±â€º
instance : TopologicalSpace (WithLowerLimit Î±) := lowerLimit (WithLowerLimit Î±)

@[simp] lemma toLowerLimit_le_toLowerLimit {x y : Î±} : toLowerLimit x â‰¤ toLowerLimit y â†” x â‰¤ y
  := .rfl
@[simp] lemma toLowerLimit_lt_toLowerLimit {x y : Î±} : toLowerLimit x < toLowerLimit y â†” x < y
  := .rfl
@[simp] lemma ofLowerLimit_le_ofLowerLimit {x y : WithLowerLimit Î±} :
  ofLowerLimit x â‰¤ ofLowerLimit y â†” x â‰¤ y := .rfl
@[simp] lemma ofLowerLimit_lt_ofLowerLimit {x y : WithLowerLimit Î±} :
  ofLowerLimit x < ofLowerLimit y â†” x < y := .rfl

lemma isOpen_preimage_ofLowerLimit : IsOpen (ofLowerLimit â»Â¹' s) â†” IsOpen[lowerLimit Î±] s := Iff.rfl

lemma isOpen_def (T : Set (WithLowerLimit Î±)) : IsOpen T â†” IsOpen[lowerLimit Î±]
  (WithLowerLimit.toLowerLimit â»Â¹' T) := Iff.rfl

end Preorder

instance [PartialOrder Î±] : PartialOrder (WithLowerLimit Î±) := â€¹PartialOrder Î±â€º
instance [LinearOrder Î±] : LinearOrder (WithLowerLimit Î±) := â€¹LinearOrder Î±â€º

end WithLowerLimit

/-- Type synonym for a preorder equipped with the upper topology. -/
def WithUpperLimit (Î± : Type*) := Î±

namespace WithUpperLimit

/-- `toUpper` is the identity function to the `WithUpper` of a type. -/
@[match_pattern] def toUpperLimit : Î± â‰ƒ WithUpperLimit Î± := Equiv.refl _

/-- `ofUpper` is the identity function from the `WithUpper` of a type. -/
@[match_pattern] def ofUpperLimit : WithUpperLimit Î± â‰ƒ Î± := Equiv.refl _

@[simp] lemma toUpperLimit_symm {Î±} : (@toUpperLimit Î±).symm = ofUpperLimit := rfl
@[simp] lemma ofUpperLimit_symm : (@ofUpperLimit Î±).symm = toUpperLimit := rfl
@[simp] lemma toUpperLimit_ofUpperLimit (a : WithUpperLimit Î±) : toUpperLimit (ofUpperLimit a) =
  a := rfl
@[simp] lemma ofUpperLimit_toUpperLimit (a : Î±) : ofUpperLimit (toUpperLimit a) = a := rfl
lemma toUpperLimit_inj {a b : Î±} : toUpperLimit a = toUpperLimit b â†” a = b := Iff.rfl
lemma ofUpperLimit_inj {a b : WithUpperLimit Î±} : ofUpperLimit a = ofUpperLimit b â†” a = b := Iff.rfl

/-- A recursor for `WithUpperLimit`. Use as `induction x`. -/
@[elab_as_elim, cases_eliminator, induction_eliminator]
protected def rec {motive : WithUpperLimit Î± â†’ Sort*}
    (toUpperLimit : âˆ€ a, motive (toUpperLimit a)) : âˆ€ a, motive a :=
  fun a => toUpperLimit (ofUpperLimit a)

instance [Nonempty Î±] : Nonempty (WithUpperLimit Î±) := â€¹Nonempty Î±â€º
instance [Inhabited Î±] : Inhabited (WithUpperLimit Î±) := â€¹Inhabited Î±â€º

section Preorder

variable [Preorder Î±] {s : Set Î±}

instance : Preorder (WithUpperLimit Î±) := â€¹Preorder Î±â€º
instance : TopologicalSpace (WithUpperLimit Î±) := upperLimit (WithUpperLimit Î±)

@[simp] lemma toUpperLimit_le_toUpperLimit {x y : Î±} : toUpperLimit x â‰¤ toUpperLimit y â†” x â‰¤ y
  := .rfl
@[simp] lemma toUpperLimit_lt_toUpperLimit {x y : Î±} : toUpperLimit x < toUpperLimit y â†” x < y
  := .rfl
@[simp] lemma ofUpperLimit_le_ofUpperLimit {x y : WithUpperLimit Î±} :
  ofUpperLimit x â‰¤ ofUpperLimit y â†” x â‰¤ y := .rfl
@[simp] lemma ofUpperLimit_lt_ofUpperLimit {x y : WithUpperLimit Î±} :
  ofUpperLimit x < ofUpperLimit y â†” x < y := .rfl

lemma isOpen_preimage_ofUpperLimit : IsOpen (ofUpperLimit â»Â¹' s) â†” (upperLimit Î±).IsOpen s
  := Iff.rfl

lemma isOpen_def {s : Set (WithUpperLimit Î±)} : IsOpen s â†” (upperLimit Î±).IsOpen
  (toUpperLimit â»Â¹' s) := Iff.rfl

end Preorder

instance [PartialOrder Î±] : PartialOrder (WithUpperLimit Î±) := â€¹PartialOrder Î±â€º
instance [LinearOrder Î±] : LinearOrder (WithUpperLimit Î±) := â€¹LinearOrder Î±â€º

end WithUpperLimit

/--
The lower limit topology is the topology generated by the right-open left-closed intervals.
-/
class IsLowerLimit (Î± : Type*) [t : TopologicalSpace Î±] [Preorder Î±] : Prop where
  topology_eq_lowerLimitTopology : t = lowerLimit Î±

attribute [nolint docBlame] IsLowerLimit.topology_eq_lowerLimitTopology

theorem nhds_lowerLimit_eq {Î± : Type*} [TopologicalSpace Î±] [Preorder Î±] (a : Î±) :
    @nhds Î± (lowerLimit Î±) a = ð“[â‰¥] a := by
  sorry

theorem continuous_iff_rightContinuous {Î± Î² : Type*} [TopologicalSpace Î±] [TopologicalSpace Î²]
    [Preorder Î±] (f : Î± â†’ Î²) :
    @Continuous Î± Î² (lowerLimit Î±) inferInstance f
    â†” âˆ€ a, ContinuousWithinAt f (Set.Ici a) a := by
  sorry

/--
The upper limit topology is the topology generated by the right-closed left-open intervals.
-/
class IsUpperLimit (Î± : Type*) [t : TopologicalSpace Î±] [Preorder Î±] : Prop where
  topology_eq_upperLimitTopology : t = upperLimit Î±

theorem nhds_upperLimit_eq {Î± : Type*} [TopologicalSpace Î±] [Preorder Î±] (a : Î±) :
    @nhds Î± (upperLimit Î±) a = ð“[â‰¤] a := by
  sorry

theorem continuous_iff_leftContinuous {Î± Î² : Type*} [TopologicalSpace Î±] [TopologicalSpace Î²]
    [Preorder Î±] (f : Î± â†’ Î²) :
    @Continuous Î± Î² (upperLimit Î±) inferInstance f
    â†” âˆ€ a, ContinuousWithinAt f (Set.Iic a) a := by
  sorry

attribute [nolint docBlame] IsUpperLimit.topology_eq_upperLimitTopology

instance [Preorder Î±] : IsLowerLimit (WithLowerLimit Î±) := âŸ¨rflâŸ©
instance [Preorder Î±] : IsUpperLimit (WithUpperLimit Î±) := âŸ¨rflâŸ©

/--
The lower limit topology is homeomorphic to the upper limit topology on the dual order.
-/
def WithLowerLimit.toDualHomeomorph [Preorder Î±] : WithLowerLimit Î± â‰ƒâ‚œ WithUpperLimit Î±áµ’áµˆ where
  toFun := OrderDual.toDual
  invFun := OrderDual.ofDual
  left_inv := OrderDual.toDual_ofDual
  right_inv := OrderDual.ofDual_toDual
  continuous_toFun := by
    apply continuous_def.2
    intro s hs
    simp [OrderDual.toDual, ]
  continuous_invFun := sorry

namespace IsLowerLimit

section Preorder

variable (Î±)
variable [Preorder Î±] [TopologicalSpace Î±] [IsLowerLimit Î±] {s : Set Î±}

lemma topology_eq : â€¹_â€º = lowerLimit Î± := topology_eq_lowerLimitTopology

isTopologicalBasis

variable {Î±}

/-- If `Î±` is equipped with the lower limit topology, then it is homeomorphic to `WithLowerLimit Î±`.
-/
def withLowerLimitHomeomorph : WithLowerLimit Î± â‰ƒâ‚œ Î± :=
  WithLowerLimit.ofLowerLimit.toHomeomorphOfIsInducing âŸ¨topology_eq Î± â–¸ induced_id.symmâŸ©

theorem isOpen_iff_generate_Ico :
    IsOpen s â†” GenerateOpen { t | âˆƒ i j, t = Set.Ico i j } s := by
  simp [topology_eq Î±, lowerLimit, generateFrom, IsOpen]

instance _root_.OrderDual.instIsUpperLimit : IsUpperLimit Î±áµ’áµˆ where
  topology_eq_upperLimitTopology := sorry

end Preorder

section LinearOrder

variable [LinearOrder Î±] [TopologicalSpace Î±] [IsLowerLimit Î±]

instance : ClosedIciTopology Î± := by
  constructor
  refine fun a => isOpen_compl_iff.1 (isOpen_iff_forall_mem_open.2 fun x hx => ?_)
  refine âŸ¨Ico x a, ?_, ?_, ?_âŸ©
  Â· grind
  Â· simp only [isOpen_iff_generate_Ico]
    exact GenerateOpen.basic _ âŸ¨x, a, rflâŸ©
  Â· simp [notMem_Ici.1 hx]

instance [NoMaxOrder Î±] : OrderClosedTopology Î± := by
  constructor
  refine isOpen_compl_iff.1 (isOpen_iff_forall_mem_open.2 fun x hx => ?_)
  obtain âŸ¨c, hcâŸ© := exists_gt x.1
  refine âŸ¨Ico x.1 c Ã—Ë¢ Ico x.2 x.1, fun y hy => ?_, ?_, ?_âŸ©
  Â· simpa using LT.lt.not_ge (LT.lt.trans_le hy.2.2 hy.1.1)
  Â· refine IsOpen.prod ?_ ?_
    Â· simp only [isOpen_iff_generate_Ico]
      exact GenerateOpen.basic _ âŸ¨x.1, c, rflâŸ©
    Â· simp only [isOpen_iff_generate_Ico]
      exact GenerateOpen.basic _ âŸ¨x.2, x.1, rflâŸ©
  Â· simp_all

end LinearOrder

end IsLowerLimit

namespace IsUpperLimit

section Preorder

variable (Î±)
variable [Preorder Î±] [TopologicalSpace Î±] [IsUpperLimit Î±] {s : Set Î±}

lemma topology_eq : â€¹_â€º = upperLimit Î± := topology_eq_upperLimitTopology

variable {Î±}

/-- If `Î±` is equipped with the upper limit topology, then it is homeomorphic to `WithUpperLimit Î±`.
-/
def withUpperLimitHomeomorph : WithUpperLimit Î± â‰ƒâ‚œ Î± :=
  WithUpperLimit.ofUpperLimit.toHomeomorphOfIsInducing âŸ¨topology_eq Î± â–¸ induced_id.symmâŸ©

theorem isOpen_iff_generate_Ioc :
    IsOpen s â†” GenerateOpen { t | âˆƒ i j, t = Set.Ioc i j } s := by
  simp [topology_eq Î±, upperLimit, generateFrom, IsOpen]

instance _root_.OrderDual.instIsLowerLimit : IsLowerLimit Î±áµ’áµˆ where
  topology_eq_lowerLimitTopology := sorry

end Preorder

section LinearOrder

variable [LinearOrder Î±] [TopologicalSpace Î±] [IsUpperLimit Î±]

instance : ClosedIicTopology Î± := sorry

instance [NoMinOrder Î±] : OrderClosedTopology Î± := by sorry

end LinearOrder

end IsUpperLimit

end Topology

#min_imports
