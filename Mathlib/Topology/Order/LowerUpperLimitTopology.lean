/-
Copyright (c) 2025 Yongxi Lin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yongxi Lin
-/
module

public import Mathlib.Topology.Order
public import Mathlib.Topology.Order.OrderClosed

/-!
# Lower and Upper topology

This file introduces the lower limit topology on a preorder as the topology generated by the
right-open left-closed intervals. We also introduce the dual upper limit topology, generated by the
right-closed left-open intervals.

## Main statements

- `IsLower.t0Space` - the lower topology on a partial order is T₀
- `IsLower.isTopologicalBasis` - the complements of the upper closures of finite
  subsets form a basis for the lower topology
- `IsLower.continuousInf` - the inf map is continuous with respect to the lower topology

## Implementation notes

A type synonym `WithLower` is introduced and for a preorder `α`, `WithLower α`
is made an instance of `TopologicalSpace` by the topology generated by the complements of the
closed intervals to infinity.

We define a mixin class `IsLower` for the class of types which are both a preorder and a
topology and where the topology is generated by the complements of the closed intervals to infinity.
It is shown that `WithLower α` is an instance of `IsLower`.

Similarly for the upper topology.

## Motivation

The lower limit topology can be used to give a topological characertization of right continuous
functions.

## References

* [Gierz et al, *A Compendium of Continuous Lattices*][GierzEtAl1980]

-/

@[expose] public section

open Set TopologicalSpace Topology

namespace Topology

/--
The lower limit topology is the topology generated by the right-open left-closed intervals.
-/
def lowerLimit (ι : Type*) [Preorder ι] : TopologicalSpace ι :=
  TopologicalSpace.generateFrom {s | ∃ i j, s = Set.Ico i j}

/--
The upper limit topology is the topology generated by the right-closed left-open intervals.
-/
def upperLimit (ι : Type*) [Preorder ι] : TopologicalSpace ι :=
  TopologicalSpace.generateFrom {s | ∃ i j, s = Set.Ioc i j}

/-- Type synonym for a preorder equipped with the lower limit topology. -/
def WithLowerLimit (ι : Type*) := ι

variable {α β : Type*}

namespace WithLowerLimit

/-- `toLowerLimit` is the identity function to the `WithLowerLimit` of a type. -/
@[match_pattern] def toLowerLimit : α ≃ WithLowerLimit α := Equiv.refl _

/-- `ofLowerLimit` is the identity function from the `WithLowerLimit` of a type. -/
@[match_pattern] def ofLowerLimit : WithLowerLimit α ≃ α := Equiv.refl _

@[simp] lemma toLowerLimit_symm : (@toLowerLimit α).symm = ofLowerLimit := rfl
@[simp] lemma ofLowerLimit_symm : (@ofLowerLimit α).symm = toLowerLimit := rfl
@[simp] lemma toLowerLimit_ofLowerLimit (a : WithLowerLimit α) : toLowerLimit (ofLowerLimit a) =
  a := rfl

@[simp] lemma ofLowerLimit_toLowerLimit (a : α) : ofLowerLimit (toLowerLimit a) = a := rfl

lemma toLower_inj {a b : α} : toLowerLimit a = toLowerLimit b ↔ a = b := Iff.rfl

theorem ofLower_inj {a b : WithLowerLimit α} : ofLowerLimit a = ofLowerLimit b ↔ a = b :=
  Iff.rfl

/-- A recursor for `WithLowerLimit`. Use as `induction x`. -/
@[elab_as_elim, cases_eliminator, induction_eliminator]
protected def rec {β : WithLowerLimit α → Sort*} (h : ∀ a, β (toLowerLimit a)) : ∀ a, β a :=
  fun a => h (ofLowerLimit a)

instance [Nonempty α] : Nonempty (WithLowerLimit α) := ‹Nonempty α›
instance [Inhabited α] : Inhabited (WithLowerLimit α) := ‹Inhabited α›

section Preorder

variable [Preorder α] {s : Set α}

instance : Preorder (WithLowerLimit α) := ‹Preorder α›
instance : TopologicalSpace (WithLowerLimit α) := lowerLimit (WithLowerLimit α)

@[simp] lemma toLowerLimit_le_toLowerLimit {x y : α} : toLowerLimit x ≤ toLowerLimit y ↔ x ≤ y
  := .rfl
@[simp] lemma toLowerLimit_lt_toLowerLimit {x y : α} : toLowerLimit x < toLowerLimit y ↔ x < y
  := .rfl
@[simp] lemma ofLowerLimit_le_ofLowerLimit {x y : WithLowerLimit α} :
  ofLowerLimit x ≤ ofLowerLimit y ↔ x ≤ y := .rfl
@[simp] lemma ofLowerLimit_lt_ofLowerLimit {x y : WithLowerLimit α} :
  ofLowerLimit x < ofLowerLimit y ↔ x < y := .rfl

lemma isOpen_preimage_ofLowerLimit : IsOpen (ofLowerLimit ⁻¹' s) ↔ IsOpen[lowerLimit α] s := Iff.rfl

lemma isOpen_def (T : Set (WithLowerLimit α)) : IsOpen T ↔ IsOpen[lowerLimit α]
  (WithLowerLimit.toLowerLimit ⁻¹' T) := Iff.rfl

end Preorder

instance [PartialOrder α] : PartialOrder (WithLowerLimit α) := ‹PartialOrder α›
instance [LinearOrder α] : LinearOrder (WithLowerLimit α) := ‹LinearOrder α›

end WithLowerLimit

/-- Type synonym for a preorder equipped with the upper topology. -/
def WithUpperLimit (α : Type*) := α

namespace WithUpperLimit

/-- `toUpper` is the identity function to the `WithUpper` of a type. -/
@[match_pattern] def toUpperLimit : α ≃ WithUpperLimit α := Equiv.refl _

/-- `ofUpper` is the identity function from the `WithUpper` of a type. -/
@[match_pattern] def ofUpperLimit : WithUpperLimit α ≃ α := Equiv.refl _

@[simp] lemma toUpperLimit_symm {α} : (@toUpperLimit α).symm = ofUpperLimit := rfl
@[simp] lemma ofUpperLimit_symm : (@ofUpperLimit α).symm = toUpperLimit := rfl
@[simp] lemma toUpperLimit_ofUpperLimit (a : WithUpperLimit α) : toUpperLimit (ofUpperLimit a) =
  a := rfl
@[simp] lemma ofUpperLimit_toUpperLimit (a : α) : ofUpperLimit (toUpperLimit a) = a := rfl
lemma toUpperLimit_inj {a b : α} : toUpperLimit a = toUpperLimit b ↔ a = b := Iff.rfl
lemma ofUpperLimit_inj {a b : WithUpperLimit α} : ofUpperLimit a = ofUpperLimit b ↔ a = b := Iff.rfl

/-- A recursor for `WithUpperLimit`. Use as `induction x`. -/
@[elab_as_elim, cases_eliminator, induction_eliminator]
protected def rec {β : WithUpperLimit α → Sort*} (h : ∀ a, β (toUpperLimit a)) : ∀ a, β a :=
  fun a => h (ofUpperLimit a)

instance [Nonempty α] : Nonempty (WithUpperLimit α) := ‹Nonempty α›
instance [Inhabited α] : Inhabited (WithUpperLimit α) := ‹Inhabited α›

section Preorder

variable [Preorder α] {s : Set α}

instance : Preorder (WithUpperLimit α) := ‹Preorder α›
instance : TopologicalSpace (WithUpperLimit α) := upperLimit (WithUpperLimit α)

@[simp] lemma toUpperLimit_le_toUpperLimit {x y : α} : toUpperLimit x ≤ toUpperLimit y ↔ x ≤ y
  := .rfl
@[simp] lemma toUpperLimit_lt_toUpperLimit {x y : α} : toUpperLimit x < toUpperLimit y ↔ x < y
  := .rfl
@[simp] lemma ofUpperLimit_le_ofUpperLimit {x y : WithUpperLimit α} :
  ofUpperLimit x ≤ ofUpperLimit y ↔ x ≤ y := .rfl
@[simp] lemma ofUpperLimit_lt_ofUpperLimit {x y : WithUpperLimit α} :
  ofUpperLimit x < ofUpperLimit y ↔ x < y := .rfl

lemma isOpen_preimage_ofUpperLimit : IsOpen (ofUpperLimit ⁻¹' s) ↔ (upperLimit α).IsOpen s
  := Iff.rfl

lemma isOpen_def {s : Set (WithUpperLimit α)} : IsOpen s ↔ (upperLimit α).IsOpen
  (toUpperLimit ⁻¹' s) := Iff.rfl

end Preorder

instance [PartialOrder α] : PartialOrder (WithUpperLimit α) := ‹PartialOrder α›
instance [LinearOrder α] : LinearOrder (WithUpperLimit α) := ‹LinearOrder α›

end WithUpperLimit

/--
The lower limit topology is the topology generated by the right-open left-closed intervals.
-/
class IsLowerLimit (α : Type*) [t : TopologicalSpace α] [Preorder α] : Prop where
  topology_eq_lowerLimitTopology : t = lowerLimit α

attribute [nolint docBlame] IsLowerLimit.topology_eq_lowerLimitTopology

/--
The upper limit topology is the topology generated by the right-closed left-open intervals.
-/
class IsUpperLimit (α : Type*) [t : TopologicalSpace α] [Preorder α] : Prop where
  topology_eq_upperLimitTopology : t = upperLimit α

attribute [nolint docBlame] IsUpperLimit.topology_eq_upperLimitTopology

instance [Preorder α] : IsLowerLimit (WithLowerLimit α) := ⟨rfl⟩
instance [Preorder α] : IsUpperLimit (WithUpperLimit α) := ⟨rfl⟩

/--
The lower limit topology is homeomorphic to the upper limit topology on the dual order.
-/
def WithLowerLimit.toDualHomeomorph [Preorder α] : WithLowerLimit α ≃ₜ WithUpperLimit αᵒᵈ where
  toFun := OrderDual.toDual
  invFun := OrderDual.ofDual
  left_inv := OrderDual.toDual_ofDual
  right_inv := OrderDual.ofDual_toDual
  continuous_toFun := sorry
  continuous_invFun := sorry

namespace IsLowerLimit

section Preorder

variable (α)
variable [Preorder α] [TopologicalSpace α] [IsLowerLimit α] {s : Set α}

lemma topology_eq : ‹_› = lowerLimit α := topology_eq_lowerLimitTopology

variable {α}

/-- If `α` is equipped with the lower limit topology, then it is homeomorphic to `WithLowerLimit α`.
-/
def withLowerLimitHomeomorph : WithLowerLimit α ≃ₜ α :=
  WithLowerLimit.ofLowerLimit.toHomeomorphOfIsInducing ⟨topology_eq α ▸ induced_id.symm⟩

theorem isOpen_iff_generate_Ici_compl :
    IsOpen s ↔ GenerateOpen { t | ∃ i j, t = Set.Ico i j } s := by
  simp [topology_eq α, lowerLimit, generateFrom, IsOpen]

instance _root_.OrderDual.instIsUpperLimit [Preorder α] [TopologicalSpace α] [IsLowerLimit α] :
    IsUpperLimit αᵒᵈ where
  topology_eq_upperLimitTopology := sorry

/-- A function `f : β → α` with lower limit topology in the codomain is continuous
if and only if it is right continuous.
-/
lemma continuous_iff_rightContinuous [TopologicalSpace β] {f : β → α} :
    Continuous f ↔ ∀ a, IsClosed (f ⁻¹' (Ici a)) := by
  sorry

end Preorder

section LinearOrder

variable [LinearOrder α] [TopologicalSpace α] [IsLowerLimit α]

/-- Left-closed right-infinite intervals [a, ∞) are closed in the lower topology. -/
instance : ClosedIciTopology α := by
  constructor
  intro a
  apply isOpen_compl_iff.1
  apply isOpen_iff_forall_mem_open.2
  intro x hx
  refine ⟨Ico x a, ?_, ?_, ?_⟩
  · grind
  · sorry
  · simp [notMem_Ici.1 hx]

-- see Note [lower instance priority]
/-- The lower limit topology on a linear order is T₂. -/
instance (priority := 90) tSpace : T2Space α :=
  (t0Space_iff_inseparable α).2 fun x y h =>
    Ici_injective <| by simpa only [inseparable_iff_closure_eq, closure_singleton] using h

end LinearOrder

#min_imports
