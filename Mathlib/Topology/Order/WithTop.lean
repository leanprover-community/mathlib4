/-
Copyright (c) 2025 RÃ©my Degenne. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: RÃ©my Degenne, SÃ©bastien GouÃ«zel
-/
import Mathlib.Topology.Order.Basic
import Mathlib.Data.Fintype.WithTopBot

/-! # Order topology on `WithTop Î¹`

When `Î¹` is a topological space with the order topology, we also endow `WithTop Î¹` with the order
topology. If `Î¹` is second countable, we prove that `WithTop Î¹` also is.
-/

open Set Filter
open scoped Topology

namespace TopologicalSpace

variable {Î¹ : Type*} [Preorder Î¹]

@[nolint unusedArguments]
instance [TopologicalSpace Î¹] [OrderTopology Î¹] : TopologicalSpace (WithTop Î¹) :=
  Preorder.topology _

instance [TopologicalSpace Î¹] [OrderTopology Î¹] : OrderTopology (WithTop Î¹) := âŸ¨rflâŸ©

instance [ts : TopologicalSpace Î¹] [ht : OrderTopology Î¹] [SecondCountableTopology Î¹] :
    SecondCountableTopology (WithTop Î¹) := by
  classical
  rcases isEmpty_or_nonempty Î¹ with hÎ¹ | âŸ¨âŸ¨xâ‚€âŸ©âŸ©
  Â· infer_instance
  /- Let `c` be a countable set in `Î¹` such that the topology is generated by the sets `Iio a`
  and `Ioi a` for `a âˆˆ c`, by second-countability. Let `c'` be a dense set in `Î¹`, again by
  second-countability. Let `d` in `WithTop Î¹` be obtained from `c âˆª c'`, by adding `âŠ¤` and a point
  `xâ‚ : Î¹` with `Ioi xâ‚ = âˆ…` if there is one.
  We will show that the topology on `WithTop Î¹` is generated by the intervals `Iio a` and `Ioi a`
  for `a âˆˆ d`, which will conclude the proof by countability of `d`. -/
  obtain âŸ¨c, c_count, hcâŸ© : âˆƒ (c : Set Î¹), c.Countable âˆ§
      ts = generateFrom { s | âˆƒ a âˆˆ c, s = Ioi a âˆ¨ s = Iio a } :=
    exists_countable_generateFrom_Ioi_Iio Î¹
  obtain âŸ¨c', c'_count, hc'âŸ© : âˆƒ c' : Set Î¹, c'.Countable âˆ§ Dense c' :=
    SeparableSpace.exists_countable_dense
  let xâ‚ : Î¹ := if h : âˆƒ x, Ioi x = âˆ… then h.choose else xâ‚€
  let d : Set (WithTop Î¹) := (â†‘)'' c âˆª (â†‘)'' c' âˆª {âŠ¤} âˆª {(xâ‚ : WithTop Î¹)}
  suffices H : instWithTopOfOrderTopology
      = generateFrom {s | âˆƒ a âˆˆ d, s = Ioi a âˆ¨ s = Iio a} by
    refine âŸ¨{s | âˆƒ a âˆˆ d, s = Ioi a âˆ¨ s = Iio a}, ?_, by rw [â† H]âŸ©
    have d_count : d.Countable :=
      (((c_count.image _).union (c'_count.image _)).union (by simp)).union (by simp)
    have : {s | âˆƒ a âˆˆ d, s = Ioi a âˆ¨ s = Iio a} = Ioi '' d âˆª Iio '' d := by
      ext; simp; grind
    rw [this]
    exact (d_count.image _).union (d_count.image _)
  -- We should check the easy direction that all the elements in our generating set are open.
  -- This is trivial as these are all intervals.
  apply le_antisymm
  Â· apply le_generateFrom_iff_subset_isOpen.2
    simp only [setOf_subset_setOf, forall_exists_index, and_imp]
    grind [isOpen_Iio', isOpen_Ioi']
  /- Now, let us check that our sets indeed generates the topology. As the topology is
  generated by the open half-infinite intervals by definition, we should check that open
  half-infinite intervals are covered by finite intersections of our sets. -/
  let basis : Set (Set Î¹) := {s | âˆƒ (f g : Set Î¹), f âŠ† c âˆ§ g âŠ† c âˆ§ f.Finite âˆ§ g.Finite
      âˆ§ s = (â‹‚ a âˆˆ f, Ioi a) âˆ© (â‹‚ a âˆˆ g, Iio a)}
  have h_basis : IsTopologicalBasis basis := isTopologicalBasis_biInter_Ioi_Iio_of_generateFrom c hc
  rw [OrderTopology.topology_eq_generate_intervals (Î± := WithTop Î¹)]
  apply le_generateFrom_iff_subset_isOpen.2
  simp only [setOf_subset_setOf, forall_exists_index]
  rintro u a (rfl | rfl)
  -- Consider an interval of the form `Ioi a`. We should cover it by finite intersections of
  -- our sets.
  Â· induction a with
    | top =>
      -- for `a = âŠ¤`, this is trivial as `Ioi âŠ¤` is in our set by design
      apply isOpen_generateFrom_of_mem
      exact âŸ¨âŠ¤, by simp [d]âŸ©
    | coe a =>
      -- for `a : Î¹`, we consider an element `b âˆˆ Ioi a`, and seek a finite intersection of our
      -- sets containing it and contained in `Ioi a`.
      rw [@isOpen_iff_forall_mem_open]
      intro b hb
      induction b with
      | top =>
        -- if `b = âŠ¤`, then either `Ioi a` is empty in `Î¹` and then we use `Ioi (â†‘xâ‚)` which is
        -- in our set and reduced to `âŠ¤`
        rcases eq_empty_or_nonempty (Ioi a) with ha | ha
        Â· refine âŸ¨Ioi xâ‚, ?_, ?_, by simpâŸ©
          Â· have : Ioi xâ‚ = âˆ… := by
              have h : âˆƒ x, Ioi x = âˆ… := âŸ¨a, haâŸ©
              simp only [xâ‚, h, â†“reduceDIte]
              exact h.choose_spec
            simp [WithTop.Ioi_coe, this]
          Â· apply isOpen_generateFrom_of_mem
            simp [d]
        -- If `Ioi a` is not empty in `Î¹`, it contains a point `b` in the dense set `c'`, and then
        -- we use `Ioi (â†‘b)` which is in our set, contained in `Ioi (â†‘a)` and contains `âŠ¤`.
        Â· obtain âŸ¨b, bc', hbâŸ© : âˆƒ b âˆˆ c', b âˆˆ Ioi a := hc'.exists_mem_open (isOpen_Ioi' a) ha
          refine âŸ¨Ioi b, ?_, ?_, by simpâŸ©
          Â· apply Ioi_subset_Ioi
            simpa using hb.le
          Â· apply isOpen_generateFrom_of_mem
            exact âŸ¨b, by simp [d, bc'], Or.inl rflâŸ©
      | coe b =>
        -- if `b` comes from `Î¹`, then in `Î¹` we can find a finite intersection of our sets
        -- containing `b` and contained in `Ioi a`. We lift it to `WithTop Î¹`.
        simp only [mem_Ioi, WithTop.coe_lt_coe] at hb
        obtain âŸ¨t, âŸ¨f, g, hfc, hgc, f_fin, g_fin, rflâŸ©, hb, hfgâŸ© :
          âˆƒ t âˆˆ basis, b âˆˆ t âˆ§ t âŠ† Ioi a := h_basis.isOpen_iff.1 (isOpen_Ioi' a) b hb
        refine âŸ¨(â‹‚ z âˆˆ f, Ioi z) âˆ© â‹‚ z âˆˆ g, Iio z, ?_, ?_, by simpa using hbâŸ©
        Â· intro w hw
          induction w with
          | top => simp
          | coe w =>
            simp only [mem_Ioi, WithTop.coe_lt_coe]
            apply hfg
            simpa using hw
        Â· apply @IsOpen.inter _ (generateFrom {s | âˆƒ a âˆˆ d, s = Ioi a âˆ¨ s = Iio a})
          Â· apply @Finite.isOpen_biInter _ _ (generateFrom {s | âˆƒ a âˆˆ d, s = Ioi a âˆ¨ s = Iio a})
            Â· exact f_fin
            Â· intro i hi
              apply isOpen_generateFrom_of_mem
              simp [d]
              grind
          Â· apply @Finite.isOpen_biInter _ _ (generateFrom {s | âˆƒ a âˆˆ d, s = Ioi a âˆ¨ s = Iio a})
            Â· exact g_fin
            Â· intro i hi
              apply isOpen_generateFrom_of_mem
              simp [d]
              grind
  -- Consider an interval of the form `Iio a`. We should cover it by finite intersections of
  -- our sets.
  Â· induction a with
    | top =>
      -- for `a = âŠ¤`, this is trivial as `Iio âŠ¤` is in our set by design
      apply isOpen_generateFrom_of_mem
      exact âŸ¨âŠ¤, by simp [d]âŸ©
    | coe a =>
      -- for `a : Î¹`, we consider an element `b âˆˆ Iio a`, and seek a finite intersection of our
      -- sets containing it and contained in `Iio a`.
      rw [@isOpen_iff_forall_mem_open]
      intro b hb
      induction b with
      | top => simp at hb
      | coe b =>
        -- `b` can not be equal to `âŠ¤`, so it comes from `Î¹`. In `Î¹` we can find a finite
        -- intersection of our sets containing `b` and contained in `Iio a`. We lift it
        -- to `WithTop Î¹`, and intersect with `Iio âŠ¤` (which is also in our set) to exclude `âŠ¤`.
        simp only [mem_Iio, WithTop.coe_lt_coe] at hb
        obtain âŸ¨t, âŸ¨f, g, hfc, hgc, f_fin, g_fin, rflâŸ©, hb, hfgâŸ© :
          âˆƒ t âˆˆ basis, b âˆˆ t âˆ§ t âŠ† Iio a := h_basis.isOpen_iff.1 (isOpen_Iio' a) b hb
        refine âŸ¨(â‹‚ z âˆˆ f, Ioi z) âˆ© (â‹‚ z âˆˆ g, Iio z) âˆ© Iio âŠ¤, ?_, ?_, by simpa using hbâŸ©
        Â· intro w hw
          induction w with
          | top => simp at hw
          | coe w =>
            simp only [mem_Iio, WithTop.coe_lt_coe]
            apply hfg
            simpa using hw
        Â· apply @IsOpen.inter _ (generateFrom {s | âˆƒ a âˆˆ d, s = Ioi a âˆ¨ s = Iio a}); swap
          Â· apply isOpen_generateFrom_of_mem
            simp [d]
          apply @IsOpen.inter _ (generateFrom {s | âˆƒ a âˆˆ d, s = Ioi a âˆ¨ s = Iio a})
          Â· apply @Finite.isOpen_biInter _ _ (generateFrom {s | âˆƒ a âˆˆ d, s = Ioi a âˆ¨ s = Iio a})
            Â· exact f_fin
            Â· intro i hi
              apply isOpen_generateFrom_of_mem
              simp [d]
              grind
          Â· apply @Finite.isOpen_biInter _ _ (generateFrom {s | âˆƒ a âˆˆ d, s = Ioi a âˆ¨ s = Iio a})
            Â· exact g_fin
            Â· intro i hi
              apply isOpen_generateFrom_of_mem
              simp [d]
              grind

end TopologicalSpace

namespace WithTop

variable {Î¹ : Type*} [LinearOrder Î¹] [TopologicalSpace Î¹] [OrderTopology Î¹]

section Coe

lemma isEmbedding_coe : Topology.IsEmbedding ((â†‘) : Î¹ â†’ WithTop Î¹) := by
  refine WithTop.coe_strictMono.isEmbedding_of_ordConnected (Î± := Î¹) ?_
  rw [WithTop.range_coe]
  exact Set.ordConnected_Iio

lemma isOpenEmbedding_coe : Topology.IsOpenEmbedding ((â†‘) : Î¹ â†’ WithTop Î¹) :=
  âŸ¨isEmbedding_coe, by rw [WithTop.range_coe]; exact isOpen_IioâŸ©

lemma nhds_coe {r : Î¹} : ğ“ (r : WithTop Î¹) = (ğ“ r).map (â†‘) :=
  (isOpenEmbedding_coe.map_nhds_eq r).symm

@[fun_prop, continuity]
lemma continuous_coe : Continuous ((â†‘) : Î¹ â†’ WithTop Î¹) := isEmbedding_coe.continuous

end Coe

section ContinuousUnTop

lemma tendsto_untopD (d : Î¹) {a : WithTop Î¹} (ha : a â‰  âŠ¤) :
    Tendsto (untopD d) (ğ“ a) (ğ“ (untopD d a)) := by
  lift a to Î¹ using ha
  rw [nhds_coe, tendsto_map'_iff]
  exact tendsto_id

lemma continuousOn_untopD (d : Î¹) : ContinuousOn (untopD d) { a : WithTop Î¹ | a â‰  âŠ¤ } :=
  fun _a ha â†¦ ContinuousAt.continuousWithinAt (tendsto_untopD d ha)

lemma tendsto_untopA [Nonempty Î¹] {a : WithTop Î¹} (ha : a â‰  âŠ¤) :
    Tendsto untopA (ğ“ a) (ğ“ a.untopA) := tendsto_untopD _ ha

lemma continuousOn_untopA [Nonempty Î¹] : ContinuousOn untopA { a : WithTop Î¹ | a â‰  âŠ¤ } :=
  continuousOn_untopD _

lemma tendsto_untop (a : {a : WithTop Î¹ | a â‰  âŠ¤}) :
    Tendsto (fun x â†¦ untop x.1 x.2) (ğ“ a) (ğ“ (untop a.1 a.2)) := by
  have : Nonempty Î¹ := âŸ¨untop a.1 a.2âŸ©
  simp only [â† untopA_eq_untop, ne_eq, coe_setOf, mem_setOf_eq]
  exact (tendsto_untopA a.2).comp <| tendsto_subtype_rng.mp tendsto_id

lemma continuous_untop : Continuous (fun x : {a : WithTop Î¹ | a â‰  âŠ¤} â†¦ untop x.1 x.2) :=
  continuous_iff_continuousAt.mpr tendsto_untop

end ContinuousUnTop

variable (Î¹) in
/-- Homeomorphism between the non-top elements of `WithTop Î¹` and `Î¹`. -/
noncomputable
def neTopHomeomorph : { a : WithTop Î¹ | a â‰  âŠ¤ } â‰ƒâ‚œ Î¹ where
  toEquiv := Equiv.withTopSubtypeNe
  continuous_toFun := continuous_untop
  continuous_invFun := continuous_coe.subtype_mk _

variable (Î¹) in
/-- If `Î¹` has a top element, then `WithTop Î¹` is homeomorphic to `Î¹ âŠ• Unit`. -/
noncomputable
def sumHomeomorph [OrderTop Î¹] : WithTop Î¹ â‰ƒâ‚œ Î¹ âŠ• Unit where
  toFun x := if h : x = âŠ¤ then Sum.inr () else Sum.inl x.untopA
  invFun x := match x with
    | Sum.inl i => (i : WithTop Î¹)
    | Sum.inr () => âŠ¤
  left_inv x := by cases x <;> simp
  right_inv x := by cases x <;> simp
  continuous_toFun := by
    have h_fr : frontier ({âŠ¤} : Set (WithTop Î¹)) = âˆ… := by
      simp only [frontier, Set.finite_singleton, Set.Finite.isClosed, IsClosed.closure_eq]
      suffices interior ({âŠ¤} : Set (WithTop Î¹)) = {âŠ¤} by simp [this]
      rw [interior_eq_iff_isOpen]
      have : {âŠ¤} = Set.Ioi ((âŠ¤ : Î¹) : WithTop Î¹) := by ext; simp
      rw [this]
      exact isOpen_Ioi
    refine continuous_if' (by simp [h_fr]) (by simp [h_fr]) (by simp) ?_
    exact Continuous.comp_continuousOn (by fun_prop) continuousOn_untopA
  continuous_invFun := continuous_sum_dom.mpr âŸ¨by fun_prop, by fun_propâŸ©

end WithTop
