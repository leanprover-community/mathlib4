/-
Copyright (c) 2025 R√©my Degenne. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: R√©my Degenne, S√©bastien Gou√´zel
-/
import Mathlib.Topology.Order.Basic
import Mathlib.Data.Fintype.WithTopBot

/-! # Order topology on `WithTop Œπ`

When `Œπ` is a topological space with the order topology, we also endow `WithTop Œπ` with the order
topology. If `Œπ` is second countable, we prove that `WithTop Œπ` also is.
-/

open Set Filter
open scoped Topology

namespace TopologicalSpace

variable {Œπ : Type*} [Preorder Œπ]

@[nolint unusedArguments]
instance [TopologicalSpace Œπ] [OrderTopology Œπ] : TopologicalSpace (WithTop Œπ) :=
  Preorder.topology _

instance [TopologicalSpace Œπ] [OrderTopology Œπ] : OrderTopology (WithTop Œπ) := ‚ü®rfl‚ü©

instance [ts : TopologicalSpace Œπ] [ht : OrderTopology Œπ] [SecondCountableTopology Œπ] :
    SecondCountableTopology (WithTop Œπ) := by
  classical
  rcases isEmpty_or_nonempty Œπ with hŒπ | ‚ü®‚ü®x‚ÇÄ‚ü©‚ü©
  ¬∑ infer_instance
  /- Let `c` be a countable set in `Œπ` such that the topology is generated by the sets `Iio a`
  and `Ioi a` for `a ‚àà c`, by second-countability. Let `c'` be a dense set in `Œπ`, again by
  second-countability. Let `d` in `WithTop Œπ` be obtained from `c ‚à™ c'`, by adding `‚ä§` and a point
  `x‚ÇÅ : Œπ` with `Ioi x‚ÇÅ = ‚àÖ` if there is one.
  We will show that the topology on `WithTop Œπ` is generated by the intervals `Iio a` and `Ioi a`
  for `a ‚àà d`, which will conclude the proof by countability of `d`. -/
  obtain ‚ü®c, c_count, hc‚ü© : ‚àÉ (c : Set Œπ), c.Countable ‚àß
      ts = generateFrom { s | ‚àÉ a ‚àà c, s = Ioi a ‚à® s = Iio a } :=
    exists_countable_generateFrom_Ioi_Iio Œπ
  obtain ‚ü®c', c'_count, hc'‚ü© : ‚àÉ c' : Set Œπ, c'.Countable ‚àß Dense c' :=
    SeparableSpace.exists_countable_dense
  let x‚ÇÅ : Œπ := if h : ‚àÉ x, Ioi x = ‚àÖ then h.choose else x‚ÇÄ
  let d : Set (WithTop Œπ) := (‚Üë)'' c ‚à™ (‚Üë)'' c' ‚à™ {‚ä§} ‚à™ {(x‚ÇÅ : WithTop Œπ)}
  suffices H : instWithTopOfOrderTopology
      = generateFrom {s | ‚àÉ a ‚àà d, s = Ioi a ‚à® s = Iio a} by
    refine ‚ü®{s | ‚àÉ a ‚àà d, s = Ioi a ‚à® s = Iio a}, ?_, by rw [‚Üê H]‚ü©
    have d_count : d.Countable :=
      (((c_count.image _).union (c'_count.image _)).union (by simp)).union (by simp)
    have : {s | ‚àÉ a ‚àà d, s = Ioi a ‚à® s = Iio a} = Ioi '' d ‚à™ Iio '' d := by
      ext; simp; grind
    rw [this]
    exact (d_count.image _).union (d_count.image _)
  -- We should check the easy direction that all the elements in our generating set are open.
  -- This is trivial as these are all intervals.
  apply le_antisymm
  ¬∑ apply le_generateFrom_iff_subset_isOpen.2
    simp only [setOf_subset_setOf, forall_exists_index, and_imp]
    grind [isOpen_Iio', isOpen_Ioi']
  /- Now, let us check that our sets indeed generates the topology. As the topology is
  generated by the open half-infinite intervals by definition, we should check that open
  half-infinite intervals are covered by finite intersections of our sets. -/
  let basis : Set (Set Œπ) := {s | ‚àÉ (f g : Set Œπ), f ‚äÜ c ‚àß g ‚äÜ c ‚àß f.Finite ‚àß g.Finite
      ‚àß s = (‚ãÇ a ‚àà f, Ioi a) ‚à© (‚ãÇ a ‚àà g, Iio a)}
  have h_basis : IsTopologicalBasis basis := isTopologicalBasis_biInter_Ioi_Iio_of_generateFrom c hc
  rw [OrderTopology.topology_eq_generate_intervals (Œ± := WithTop Œπ)]
  apply le_generateFrom_iff_subset_isOpen.2
  simp only [setOf_subset_setOf, forall_exists_index]
  rintro u a (rfl | rfl)
  -- Consider an interval of the form `Ioi a`. We should cover it by finite intersections of
  -- our sets.
  ¬∑ induction a with
    | top =>
      -- for `a = ‚ä§`, this is trivial as `Ioi ‚ä§` is in our set by design
      apply isOpen_generateFrom_of_mem
      exact ‚ü®‚ä§, by simp [d]‚ü©
    | coe a =>
      -- for `a : Œπ`, we consider an element `b ‚àà Ioi a`, and seek a finite intersection of our
      -- sets containing it and contained in `Ioi a`.
      rw [@isOpen_iff_forall_mem_open]
      intro b hb
      induction b with
      | top =>
        -- if `b = ‚ä§`, then either `Ioi a` is empty in `Œπ` and then we use `Ioi (‚Üëx‚ÇÅ)` which is
        -- in our set and reduced to `‚ä§`
        rcases eq_empty_or_nonempty (Ioi a) with ha | ha
        ¬∑ refine ‚ü®Ioi x‚ÇÅ, ?_, ?_, by simp‚ü©
          ¬∑ have : Ioi x‚ÇÅ = ‚àÖ := by
              have h : ‚àÉ x, Ioi x = ‚àÖ := ‚ü®a, ha‚ü©
              simp only [x‚ÇÅ, h, ‚ÜìreduceDIte]
              exact h.choose_spec
            simp [WithTop.Ioi_coe, this]
          ¬∑ apply isOpen_generateFrom_of_mem
            simp [d]
        -- If `Ioi a` is not empty in `Œπ`, it contains a point `b` in the dense set `c'`, and then
        -- we use `Ioi (‚Üëb)` which is in our set, contained in `Ioi (‚Üëa)` and contains `‚ä§`.
        ¬∑ obtain ‚ü®b, bc', hb‚ü© : ‚àÉ b ‚àà c', b ‚àà Ioi a := hc'.exists_mem_open (isOpen_Ioi' a) ha
          refine ‚ü®Ioi b, ?_, ?_, by simp‚ü©
          ¬∑ apply Ioi_subset_Ioi
            simpa using hb.le
          ¬∑ apply isOpen_generateFrom_of_mem
            exact ‚ü®b, by simp [d, bc'], Or.inl rfl‚ü©
      | coe b =>
        -- if `b` comes from `Œπ`, then in `Œπ` we can find a finite intersection of our sets
        -- containing `b` and contained in `Ioi a`. We lift it to `WithTop Œπ`.
        simp only [mem_Ioi, WithTop.coe_lt_coe] at hb
        obtain ‚ü®t, ‚ü®f, g, hfc, hgc, f_fin, g_fin, rfl‚ü©, hb, hfg‚ü© :
          ‚àÉ t ‚àà basis, b ‚àà t ‚àß t ‚äÜ Ioi a := h_basis.isOpen_iff.1 (isOpen_Ioi' a) b hb
        refine ‚ü®(‚ãÇ z ‚àà f, Ioi z) ‚à© ‚ãÇ z ‚àà g, Iio z, ?_, ?_, by simpa using hb‚ü©
        ¬∑ intro w hw
          induction w with
          | top => simp
          | coe w =>
            simp only [mem_Ioi, WithTop.coe_lt_coe]
            apply hfg
            simpa using hw
        ¬∑ apply @IsOpen.inter _ (generateFrom {s | ‚àÉ a ‚àà d, s = Ioi a ‚à® s = Iio a})
          ¬∑ apply @Finite.isOpen_biInter _ _ (generateFrom {s | ‚àÉ a ‚àà d, s = Ioi a ‚à® s = Iio a})
            ¬∑ exact f_fin
            ¬∑ intro i hi
              apply isOpen_generateFrom_of_mem
              simp [d]
              grind
          ¬∑ apply @Finite.isOpen_biInter _ _ (generateFrom {s | ‚àÉ a ‚àà d, s = Ioi a ‚à® s = Iio a})
            ¬∑ exact g_fin
            ¬∑ intro i hi
              apply isOpen_generateFrom_of_mem
              simp [d]
              grind
  -- Consider an interval of the form `Iio a`. We should cover it by finite intersections of
  -- our sets.
  ¬∑ induction a with
    | top =>
      -- for `a = ‚ä§`, this is trivial as `Iio ‚ä§` is in our set by design
      apply isOpen_generateFrom_of_mem
      exact ‚ü®‚ä§, by simp [d]‚ü©
    | coe a =>
      -- for `a : Œπ`, we consider an element `b ‚àà Iio a`, and seek a finite intersection of our
      -- sets containing it and contained in `Iio a`.
      rw [@isOpen_iff_forall_mem_open]
      intro b hb
      induction b with
      | top => simp at hb
      | coe b =>
        -- `b` can not be equal to `‚ä§`, so it comes from `Œπ`. In `Œπ` we can find a finite
        -- intersection of our sets containing `b` and contained in `Iio a`. We lift it
        -- to `WithTop Œπ`, and intersect with `Iio ‚ä§` (which is also in our set) to exclude `‚ä§`.
        simp only [mem_Iio, WithTop.coe_lt_coe] at hb
        obtain ‚ü®t, ‚ü®f, g, hfc, hgc, f_fin, g_fin, rfl‚ü©, hb, hfg‚ü© :
          ‚àÉ t ‚àà basis, b ‚àà t ‚àß t ‚äÜ Iio a := h_basis.isOpen_iff.1 (isOpen_Iio' a) b hb
        refine ‚ü®(‚ãÇ z ‚àà f, Ioi z) ‚à© (‚ãÇ z ‚àà g, Iio z) ‚à© Iio ‚ä§, ?_, ?_, by simpa using hb‚ü©
        ¬∑ intro w hw
          induction w with
          | top => simp at hw
          | coe w =>
            simp only [mem_Iio, WithTop.coe_lt_coe]
            apply hfg
            simpa using hw
        ¬∑ apply @IsOpen.inter _ (generateFrom {s | ‚àÉ a ‚àà d, s = Ioi a ‚à® s = Iio a}); swap
          ¬∑ apply isOpen_generateFrom_of_mem
            simp [d]
          apply @IsOpen.inter _ (generateFrom {s | ‚àÉ a ‚àà d, s = Ioi a ‚à® s = Iio a})
          ¬∑ apply @Finite.isOpen_biInter _ _ (generateFrom {s | ‚àÉ a ‚àà d, s = Ioi a ‚à® s = Iio a})
            ¬∑ exact f_fin
            ¬∑ intro i hi
              apply isOpen_generateFrom_of_mem
              simp [d]
              grind
          ¬∑ apply @Finite.isOpen_biInter _ _ (generateFrom {s | ‚àÉ a ‚àà d, s = Ioi a ‚à® s = Iio a})
            ¬∑ exact g_fin
            ¬∑ intro i hi
              apply isOpen_generateFrom_of_mem
              simp [d]
              grind

end TopologicalSpace

namespace WithTop

variable {Œπ : Type*} [LinearOrder Œπ] [TopologicalSpace Œπ] [OrderTopology Œπ]

section Coe

lemma isEmbedding_coe : Topology.IsEmbedding ((‚Üë) : Œπ ‚Üí WithTop Œπ) := by
  refine WithTop.coe_strictMono.isEmbedding_of_ordConnected ?_
  rw [WithTop.range_coe]
  exact Set.ordConnected_Iio

lemma isOpenEmbedding_coe : Topology.IsOpenEmbedding ((‚Üë) : Œπ ‚Üí WithTop Œπ) :=
  ‚ü®isEmbedding_coe, by rw [WithTop.range_coe]; exact isOpen_Iio‚ü©

lemma nhds_coe {r : Œπ} : ùìù (r : WithTop Œπ) = (ùìù r).map (‚Üë) :=
  (isOpenEmbedding_coe.map_nhds_eq r).symm

@[fun_prop, continuity]
lemma continuous_coe : Continuous ((‚Üë) : Œπ ‚Üí WithTop Œπ) := isEmbedding_coe.continuous

end Coe

/-- Send an element of `WithTop Œπ` to `Œπ`, with an arbitrary default value for `‚ä§`. -/
noncomputable
abbrev _root_.WithTop.untopA [Nonempty Œπ] : WithTop Œπ ‚Üí Œπ := WithTop.untopD (Classical.arbitrary Œπ)

@[simp]
lemma untopA_coe_enat (n : ‚Ñï) : WithTop.untopA (n : ‚Ñï‚àû) = n := rfl

lemma tendsto_untopA [Nonempty Œπ] {a : WithTop Œπ} (ha : a ‚â† ‚ä§) :
    Tendsto WithTop.untopA (ùìù a) (ùìù a.untopA) := by
  lift a to Œπ using ha
  rw [nhds_coe, tendsto_map'_iff]
  exact tendsto_id

lemma continuousOn_untopA [Nonempty Œπ] : ContinuousOn WithTop.untopA { a : WithTop Œπ | a ‚â† ‚ä§ } :=
  fun _a ha ‚Ü¶ ContinuousAt.continuousWithinAt (WithTop.tendsto_untopA ha)

variable (Œπ) in
noncomputable
def neTopEquiv [Nonempty Œπ] : { a : WithTop Œπ | a ‚â† ‚ä§ } ‚âÉ Œπ where
  toFun x := WithTop.untopA x
  invFun x := ‚ü®x, WithTop.coe_ne_top‚ü©
  left_inv := fun x => Subtype.eq <| by
    lift (x : WithTop Œπ) to Œπ using x.2 with y
    simp
  right_inv x := by simp

variable (Œπ) in
noncomputable
def neTopHomeomorph [Nonempty Œπ] : { a : WithTop Œπ | a ‚â† ‚ä§ } ‚âÉ‚Çú Œπ where
  toEquiv := neTopEquiv Œπ
  continuous_toFun := continuousOn_iff_continuous_restrict.1 continuousOn_untopA
  continuous_invFun := continuous_coe.subtype_mk _

variable (Œπ) in
/-- If `Œπ` has a top element, then `WithTop Œπ` is homeomorphic to `Œπ ‚äï Unit`. -/
noncomputable
def sumHomeomorph [OrderTop Œπ] : WithTop Œπ ‚âÉ‚Çú Œπ ‚äï Unit where
  toFun x := if h : x = ‚ä§ then Sum.inr () else Sum.inl x.untopA
  invFun x := match x with
    | Sum.inl i => (i : WithTop Œπ)
    | Sum.inr () => ‚ä§
  left_inv x := by cases x <;> simp
  right_inv x := by cases x <;> simp
  continuous_toFun := by
    have h_fr : frontier ({‚ä§} : Set (WithTop Œπ)) = ‚àÖ := by
      simp only [frontier, Set.finite_singleton, Set.Finite.isClosed, IsClosed.closure_eq]
      suffices interior ({‚ä§} : Set (WithTop Œπ)) = {‚ä§} by simp [this]
      rw [interior_eq_iff_isOpen]
      have : {‚ä§} = Set.Ioi ((‚ä§ : Œπ) : WithTop Œπ) := by ext; simp
      rw [this]
      exact isOpen_Ioi
    refine continuous_if' (by simp [h_fr]) (by simp [h_fr]) (by simp) ?_
    exact Continuous.comp_continuousOn (by fun_prop) continuousOn_untopA
  continuous_invFun := continuous_sum_dom.mpr ‚ü®by fun_prop, by fun_prop‚ü©

end WithTop
