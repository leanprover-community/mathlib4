/-
Copyright (c) 2023 Christopher Hoskin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Christopher Hoskin
-/
import Mathlib.Topology.Homeomorph
import Mathlib.Topology.Order.Lattice
import Mathlib.Order.Hom.CompleteLattice

#align_import topology.order.lower_topology from "leanprover-community/mathlib"@"98e83c3d541c77cdb7da20d79611a780ff8e7d90"

/-!
# Lower and Upper topology

This file introduces the lower topology on a preorder as the topology generated by the complements
of the left-closed right-infinite intervals.

For completeness we also introduce the dual upper topology, generated by the complements of the
right-closed left-infinite intervals.

## Main statements

- `LowerTopology.t0Space` - the lower topology on a partial order is T‚ÇÄ
- `LowerTopology.isTopologicalBasis` - the complements of the upper closures of finite
  subsets form a basis for the lower topology
- `LowerTopology.continuousInf` - the inf map is continuous with respect to the lower topology

## Implementation notes

A type synonym `WithLowerTopology` is introduced and for a preorder `Œ±`, `WithLowerTopology Œ±`
is made an instance of `TopologicalSpace` by the topology generated by the complements of the
closed intervals to infinity.

We define a mixin class `LowerTopology` for the class of types which are both a preorder and a
topology and where the topology is generated by the complements of the closed intervals to infinity.
It is shown that `WithLowerTopology Œ±` is an instance of `LowerTopology`.

Similarly for the upper topology.

## Motivation

The lower topology is used with the `Scott` topology to define the Lawson topology. The restriction
of the lower topology to the spectrum of a complete lattice coincides with the hull-kernel topology.

## References

* [Gierz et al, *A Compendium of Continuous Lattices*][GierzEtAl1980]

## Tags

lower topology, upper topology, preorder
-/

set_option autoImplicit true

open Set TopologicalSpace

section WithLowerTopology

variable (Œ± Œ≤ : Type*)

/-- Type synonym for a preorder equipped with the lower topology. -/
def WithLowerTopology := Œ±
#align with_lower_topology WithLowerTopology

variable {Œ± Œ≤}

namespace WithLowerTopology

/-- `toLower` is the identity function to the `WithLowerTopology` of a type.  -/
@[match_pattern]
def toLower : Œ± ‚âÉ WithLowerTopology Œ± := Equiv.refl _
#align with_lower_topology.to_lower WithLowerTopology.toLower

/-- `ofLower` is the identity function from the `WithLowerTopology` of a type.  -/
@[match_pattern]
def ofLower : WithLowerTopology Œ± ‚âÉ Œ± := Equiv.refl _
#align with_lower_topology.of_lower WithLowerTopology.ofLower

@[simp]
theorem to_withLowerTopology_symm_eq : (@toLower Œ±).symm = ofLower :=
  rfl
#align with_lower_topology.to_with_lower_topology_symm_eq WithLowerTopology.to_withLowerTopology_symm_eq

@[simp]
theorem of_withLowerTopology_symm_eq : (@ofLower Œ±).symm = toLower :=
  rfl
#align with_lower_topology.of_with_lower_topology_symm_eq WithLowerTopology.of_withLowerTopology_symm_eq

@[simp]
theorem toLower_ofLower (a : WithLowerTopology Œ±) : toLower (ofLower a) = a :=
  rfl
#align with_lower_topology.to_lower_of_lower WithLowerTopology.toLower_ofLower

@[simp]
theorem ofLower_toLower (a : Œ±) : ofLower (toLower a) = a :=
  rfl
#align with_lower_topology.of_lower_to_lower WithLowerTopology.ofLower_toLower

-- porting note: removed @[simp] to make linter happy
theorem toLower_inj {a b : Œ±} : toLower a = toLower b ‚Üî a = b :=
  Iff.rfl
#align with_lower_topology.to_lower_inj WithLowerTopology.toLower_inj

-- porting note: removed @[simp] to make linter happy
theorem ofLower_inj {a b : WithLowerTopology Œ±} : ofLower a = ofLower b ‚Üî a = b :=
  Iff.rfl
#align with_lower_topology.of_lower_inj WithLowerTopology.ofLower_inj

/-- A recursor for `WithLowerTopology`. Use as `induction x using WithLowerTopology.rec`. -/
protected def rec {Œ≤ : WithLowerTopology Œ± ‚Üí Sort*} (h : ‚àÄ a, Œ≤ (toLower a)) : ‚àÄ a, Œ≤ a := fun a =>
  h (ofLower a)
#align with_lower_topology.rec WithLowerTopology.rec

instance [Nonempty Œ±] : Nonempty (WithLowerTopology Œ±) :=
  ‚ÄπNonempty Œ±‚Ä∫

instance [Inhabited Œ±] : Inhabited (WithLowerTopology Œ±) :=
  ‚ÄπInhabited Œ±‚Ä∫

variable [Preorder Œ±]

instance : Preorder (WithLowerTopology Œ±) :=
  ‚ÄπPreorder Œ±‚Ä∫

instance : TopologicalSpace (WithLowerTopology Œ±) :=
  generateFrom { s | ‚àÉ a, (Ici a)·∂ú = s }

theorem isOpen_preimage_ofLower (S : Set Œ±) :
    IsOpen (WithLowerTopology.ofLower ‚Åª¬π' S) ‚Üî
      (generateFrom { s : Set Œ± | ‚àÉ a : Œ±, (Ici a)·∂ú = s }).IsOpen S :=
  Iff.rfl
#align with_lower_topology.is_open_preimage_of_lower WithLowerTopology.isOpen_preimage_ofLower

theorem isOpen_def (T : Set (WithLowerTopology Œ±)) :
    IsOpen T ‚Üî (generateFrom { s : Set Œ± | ‚àÉ a : Œ±, (Ici a)·∂ú = s }).IsOpen
    (WithLowerTopology.toLower ‚Åª¬π' T) :=
  Iff.rfl
#align with_lower_topology.is_open_def WithLowerTopology.isOpen_def

end WithLowerTopology

end WithLowerTopology

section WithUpperTopology

variable (Œ± Œ≤ : Type*)

/-- Type synonym for a preorder equipped with the upper topology. -/
def WithUpperTopology := Œ±

variable {Œ± Œ≤}

namespace WithUpperTopology

/-- `toUpper` is the identity function to the `WithUpperTopology` of a type.  -/
@[match_pattern]
def toUpper : Œ± ‚âÉ WithUpperTopology Œ± := Equiv.refl _

/-- `ofUpper` is the identity function from the `WithUpperTopology` of a type.  -/
@[match_pattern]
def ofUpper : WithUpperTopology Œ± ‚âÉ Œ± := Equiv.refl _

@[simp]
theorem to_withUpperTopology_symm_eq {Œ±} : (@toUpper Œ±).symm = ofUpper :=
  rfl

@[simp]
theorem of_withUpperTopology_symm_eq : (@ofUpper Œ±).symm = toUpper :=
  rfl

@[simp]
theorem toUpper_ofUpper (a : WithUpperTopology Œ±) : toUpper (ofUpper a) = a :=
  rfl

@[simp]
theorem ofUpper_toUpper (a : Œ±) : ofUpper (toUpper a) = a :=
  rfl

theorem toUpper_inj {a b : Œ±} : toUpper a = toUpper b ‚Üî a = b :=
  Iff.rfl

theorem ofUpper_inj {a b : WithUpperTopology Œ±} : ofUpper a = ofUpper b ‚Üî a = b :=
  Iff.rfl

/-- A recursor for `WithUpperTopology`. Use as `induction x using WithUpperTopology.rec`. -/
protected def rec {Œ≤ : WithUpperTopology Œ± ‚Üí Sort*} (h : ‚àÄ a, Œ≤ (toUpper a)) : ‚àÄ a, Œ≤ a := fun a =>
  h (ofUpper a)

instance [Nonempty Œ±] : Nonempty (WithUpperTopology Œ±) :=
  ‚ÄπNonempty Œ±‚Ä∫

instance [Inhabited Œ±] : Inhabited (WithUpperTopology Œ±) :=
  ‚ÄπInhabited Œ±‚Ä∫

variable [Preorder Œ±]

instance : Preorder (WithUpperTopology Œ±) :=
  ‚ÄπPreorder Œ±‚Ä∫

instance : TopologicalSpace (WithUpperTopology Œ±) :=
  generateFrom { s | ‚àÉ a, (Iic a)·∂ú = s }

theorem isOpen_preimage_ofUpper (S : Set Œ±) :
    IsOpen (WithUpperTopology.ofUpper ‚Åª¬π' S) ‚Üî
      (generateFrom { s : Set Œ± | ‚àÉ a : Œ±, (Iic a)·∂ú = s }).IsOpen S :=
  Iff.rfl

theorem isOpen_def (T : Set (WithUpperTopology Œ±)) :
    IsOpen T ‚Üî (generateFrom { s : Set Œ± | ‚àÉ a : Œ±, (Iic a)·∂ú = s }).IsOpen
    (WithUpperTopology.toUpper ‚Åª¬π' T) :=
  Iff.rfl

end WithUpperTopology

end WithUpperTopology

/--
The lower topology is the topology generated by the complements of the left-closed right-infinite
intervals.
-/
class LowerTopology (Œ± : Type*) [t : TopologicalSpace Œ±] [Preorder Œ±] : Prop where
  topology_eq_lowerTopology : t = generateFrom { s | ‚àÉ a, (Ici a)·∂ú = s }
#align lower_topology LowerTopology

/--
The upper topology is the topology generated by the complements of the right-closed left-infinite
intervals.
-/
class UpperTopology (Œ± : Type*) [t : TopologicalSpace Œ±] [Preorder Œ±] : Prop where
  topology_eq_upperTopology : t = generateFrom { s | ‚àÉ a, (Iic a)·∂ú = s }

instance [Preorder Œ±] : LowerTopology (WithLowerTopology Œ±) :=
  ‚ü®rfl‚ü©

instance [Preorder Œ±] : UpperTopology (WithUpperTopology Œ±) :=
  ‚ü®rfl‚ü©

def toOrderDualHomeomorph [Preorder Œ±] : WithLowerTopology Œ± ‚âÉ‚Çú WithUpperTopology Œ±·µí·µà where
  toFun := OrderDual.toDual
  invFun := OrderDual.ofDual
  left_inv := OrderDual.toDual_ofDual
  right_inv := OrderDual.ofDual_toDual
  continuous_toFun := continuous_coinduced_rng
  continuous_invFun := continuous_coinduced_rng

namespace LowerTopology

/-- The complements of the upper closures of finite sets are a collection of lower sets
which form a basis for the lower topology. -/
def lowerBasis (Œ± : Type*) [Preorder Œ±] :=
  { s : Set Œ± | ‚àÉ t : Set Œ±, t.Finite ‚àß (upperClosure t : Set Œ±)·∂ú = s }
#align lower_topology.lower_basis LowerTopology.lowerBasis

section Preorder

variable (Œ±)
variable [Preorder Œ±] [TopologicalSpace Œ±] [LowerTopology Œ±] {s : Set Œ±}

lemma topology_eq : ‚Äπ_‚Ä∫ = generateFrom { s | ‚àÉ a : Œ±, (Ici a)·∂ú = s } := topology_eq_lowerTopology

variable {Œ±}

/-- If `Œ±` is equipped with the lower topology, then it is homeomorphic to `WithLowerTopology Œ±`.
-/
def withLowerTopologyHomeomorph : WithLowerTopology Œ± ‚âÉ‚Çú Œ± :=
  WithLowerTopology.ofLower.toHomeomorphOfInducing ‚ü®by erw [topology_eq Œ±, induced_id]; rfl‚ü©
                                                       -- ‚ä¢ WithLowerTopology.instTopologicalSpaceWithLowerTopology = generateFrom {s |  ‚Ä¶
                                                                                        -- üéâ no goals
#align lower_topology.with_lower_topology_homeomorph LowerTopology.withLowerTopologyHomeomorph

theorem isOpen_iff_generate_Ici_compl : IsOpen s ‚Üî GenerateOpen { t | ‚àÉ a, (Ici a)·∂ú = t } s := by
  rw [topology_eq Œ±]; rfl
  -- ‚ä¢ IsOpen s ‚Üî GenerateOpen {t | ‚àÉ a, (Ici a)·∂ú = t} s
                      -- üéâ no goals
#align lower_topology.is_open_iff_generate_Ici_compl LowerTopology.isOpen_iff_generate_Ici_compl

instance instUpperTopologyDual [Preorder Œ±] [TopologicalSpace Œ±] [LowerTopology Œ±] :
    UpperTopology (Œ±·µí·µà) where
  topology_eq_upperTopology := topology_eq_lowerTopology (Œ± := Œ±)

/-- Left-closed right-infinite intervals [a, ‚àû) are closed in the lower topology. -/
instance : ClosedIciTopology Œ± :=
  ‚ü®fun a ‚Ü¶ isOpen_compl_iff.1 <| isOpen_iff_generate_Ici_compl.2 <| GenerateOpen.basic _ ‚ü®a, rfl‚ü©‚ü©

-- Porting note: The old `LowerTopology.isClosed_Ici` was removed, since one can now use
-- the general `isClosed_Ici` lemma thanks to the instance above.
#align lower_topology.is_closed_Ici isClosed_Ici

/-- The upper closure of a finite set is closed in the lower topology. -/
theorem isClosed_upperClosure (h : s.Finite) : IsClosed (upperClosure s : Set Œ±) := by
  simp only [‚Üê UpperSet.iInf_Ici, UpperSet.coe_iInf]
  -- ‚ä¢ IsClosed (‚ãÉ (i : Œ±) (_ : i ‚àà s), ‚Üë(UpperSet.Ici i))
  exact isClosed_biUnion h fun _ _ => isClosed_Ici
  -- üéâ no goals
#align lower_topology.is_closed_upper_closure LowerTopology.isClosed_upperClosure

/-- Every set open in the lower topology is a lower set. -/
theorem isLowerSet_of_isOpen (h : IsOpen s) : IsLowerSet s := by
  -- porting note: `rw` leaves a shadowed assumption
  replace h := isOpen_iff_generate_Ici_compl.1 h
  -- ‚ä¢ IsLowerSet s
  induction h
  case basic u h' => obtain ‚ü®a, rfl‚ü© := h'; exact (isUpperSet_Ici a).compl
  -- üéâ no goals
  case univ => exact isLowerSet_univ
  -- ‚ä¢ IsLowerSet (s‚úù ‚à© t‚úù)
  -- üéâ no goals
  case inter u v _ _ hu2 hv2 => exact hu2.inter hv2
  -- ‚ä¢ IsLowerSet (‚ãÉ‚ÇÄ S‚úù)
  -- üéâ no goals
  case sUnion _ _ ih => exact isLowerSet_sUnion ih
  -- üéâ no goals
  -- üéâ no goals
#align lower_topology.is_lower_set_of_is_open LowerTopology.isLowerSet_of_isOpen

theorem isUpperSet_of_isClosed (h : IsClosed s) : IsUpperSet s :=
  isLowerSet_compl.1 <| isLowerSet_of_isOpen h.isOpen_compl
#align lower_topology.is_upper_set_of_is_closed LowerTopology.isUpperSet_of_isClosed

/--
The closure of a singleton `{a}` in the lower topology is the left-closed right-infinite interval
[a, ‚àû).
-/
@[simp]
theorem closure_singleton (a : Œ±) : closure {a} = Ici a :=
  Subset.antisymm ((closure_minimal fun _ h => h.ge) <| isClosed_Ici) <|
    (isUpperSet_of_isClosed isClosed_closure).Ici_subset <| subset_closure rfl
#align lower_topology.closure_singleton LowerTopology.closure_singleton

protected theorem isTopologicalBasis : IsTopologicalBasis (lowerBasis Œ±) := by
  convert isTopologicalBasis_of_subbasis (topology_eq Œ±)
  -- ‚ä¢ lowerBasis Œ± = (fun f => ‚ãÇ‚ÇÄ f) '' {f | Set.Finite f ‚àß f ‚äÜ {s | ‚àÉ a, (Ici a)·∂ú ‚Ä¶
  simp_rw [lowerBasis, coe_upperClosure, compl_iUnion]
  -- ‚ä¢ {s | ‚àÉ t, Set.Finite t ‚àß ‚ãÇ (i : Œ±) (_ : i ‚àà t), (Ici i)·∂ú = s} = (fun f => ‚ãÇ‚ÇÄ ‚Ä¶
  ext s
  -- ‚ä¢ s ‚àà {s | ‚àÉ t, Set.Finite t ‚àß ‚ãÇ (i : Œ±) (_ : i ‚àà t), (Ici i)·∂ú = s} ‚Üî s ‚àà (fun ‚Ä¶
  constructor
  -- ‚ä¢ s ‚àà {s | ‚àÉ t, Set.Finite t ‚àß ‚ãÇ (i : Œ±) (_ : i ‚àà t), (Ici i)·∂ú = s} ‚Üí s ‚àà (fun ‚Ä¶
  ¬∑ rintro ‚ü®F, hF, rfl‚ü©
    -- ‚ä¢ ‚ãÇ (i : Œ±) (_ : i ‚àà F), (Ici i)·∂ú ‚àà (fun f => ‚ãÇ‚ÇÄ f) '' {f | Set.Finite f ‚àß f ‚äÜ ‚Ä¶
    refine' ‚ü®(fun a => (Ici a)·∂ú) '' F, ‚ü®hF.image _, image_subset_iff.2 fun _ _ => ‚ü®_, rfl‚ü©‚ü©, _‚ü©
    -- ‚ä¢ (fun f => ‚ãÇ‚ÇÄ f) ((fun a => (Ici a)·∂ú) '' F) = ‚ãÇ (i : Œ±) (_ : i ‚àà F), (Ici i)·∂ú
    simp only [sInter_image]
    -- üéâ no goals
  ¬∑ rintro ‚ü®F, ‚ü®hF, hs‚ü©, rfl‚ü©
    -- ‚ä¢ (fun f => ‚ãÇ‚ÇÄ f) F ‚àà {s | ‚àÉ t, Set.Finite t ‚àß ‚ãÇ (i : Œ±) (_ : i ‚àà t), (Ici i)·∂ú ‚Ä¶
    haveI := hF.to_subtype
    -- ‚ä¢ (fun f => ‚ãÇ‚ÇÄ f) F ‚àà {s | ‚àÉ t, Set.Finite t ‚àß ‚ãÇ (i : Œ±) (_ : i ‚àà t), (Ici i)·∂ú ‚Ä¶
    rw [subset_def, Subtype.forall'] at hs
    -- ‚ä¢ (fun f => ‚ãÇ‚ÇÄ f) F ‚àà {s | ‚àÉ t, Set.Finite t ‚àß ‚ãÇ (i : Œ±) (_ : i ‚àà t), (Ici i)·∂ú ‚Ä¶
    choose f hf using hs
    -- ‚ä¢ (fun f => ‚ãÇ‚ÇÄ f) F ‚àà {s | ‚àÉ t, Set.Finite t ‚àß ‚ãÇ (i : Œ±) (_ : i ‚àà t), (Ici i)·∂ú ‚Ä¶
    exact ‚ü®_, finite_range f, by simp_rw [biInter_range, hf, sInter_eq_iInter]‚ü©
    -- üéâ no goals
#align lower_topology.is_topological_basis LowerTopology.isTopologicalBasis

/-- A function `f : Œ≤ ‚Üí Œ±` with lower topology in the codomain is continuous provided that the
preimage of every interval `Set.Ici a` is a closed set.

TODO: upgrade to an `iff`. -/
lemma continuous_of_Ici [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} (h : ‚àÄ a, IsClosed (f ‚Åª¬π' (Ici a))) :
    Continuous f := by
  obtain rfl := LowerTopology.topology_eq Œ±
  -- ‚ä¢ Continuous f
  refine continuous_generateFrom ?_
  -- ‚ä¢ ‚àÄ (s : Set Œ±), s ‚àà {s | ‚àÉ a, (Ici a)·∂ú = s} ‚Üí IsOpen (f ‚Åª¬π' s)
  rintro _ ‚ü®a, rfl‚ü©
  -- ‚ä¢ IsOpen (f ‚Åª¬π' (Ici a)·∂ú)
  exact (h a).isOpen_compl
  -- üéâ no goals

end Preorder

section PartialOrder

variable [PartialOrder Œ±] [TopologicalSpace Œ±] [LowerTopology Œ±]

-- see Note [lower instance priority]
/-- The lower topology on a partial order is T‚ÇÄ. -/
instance (priority := 90) t0Space : T0Space Œ± :=
  (t0Space_iff_inseparable Œ±).2 fun x y h =>
    Ici_injective <| by simpa only [inseparable_iff_closure_eq, closure_singleton] using h
                        -- üéâ no goals

end PartialOrder

end LowerTopology


namespace UpperTopology

/-- The complements of the lower closures of finite sets are a collection of upper sets
which form a basis for the upper topology. -/
def upperBasis (Œ± : Type*) [Preorder Œ±] :=
  { s : Set Œ± | ‚àÉ t : Set Œ±, t.Finite ‚àß (lowerClosure t : Set Œ±)·∂ú = s }

section Preorder

variable (Œ±)
variable [Preorder Œ±] [TopologicalSpace Œ±] [UpperTopology Œ±] {s : Set Œ±}

lemma topology_eq : ‚Äπ_‚Ä∫ = generateFrom { s | ‚àÉ a : Œ±, (Iic a)·∂ú = s } := topology_eq_upperTopology

variable {Œ±}

/-- If `Œ±` is equipped with the upper topology, then it is homeomorphic to `WithUpperTopology Œ±`.
-/
def withUpperTopologyHomeomorph : WithUpperTopology Œ± ‚âÉ‚Çú Œ± :=
  WithUpperTopology.ofUpper.toHomeomorphOfInducing ‚ü®by erw [topology_eq Œ±, induced_id]; rfl‚ü©
                                                       -- ‚ä¢ WithUpperTopology.instTopologicalSpaceWithUpperTopology = generateFrom {s |  ‚Ä¶
                                                                                        -- üéâ no goals

theorem isOpen_iff_generate_Iic_compl : IsOpen s ‚Üî GenerateOpen { t | ‚àÉ a, (Iic a)·∂ú = t } s := by
  rw [topology_eq Œ±]; rfl
  -- ‚ä¢ IsOpen s ‚Üî GenerateOpen {t | ‚àÉ a, (Iic a)·∂ú = t} s
                      -- üéâ no goals

instance instLowerTopologyDual [Preorder Œ±] [TopologicalSpace Œ±] [UpperTopology Œ±] :
    LowerTopology (Œ±·µí·µà) where
  topology_eq_lowerTopology := topology_eq_upperTopology (Œ± := Œ±)

/-- Left-infinite right-closed intervals (-‚àû,a] are closed in the upper topology. -/
instance : ClosedIicTopology Œ± :=
  ‚ü®fun a ‚Ü¶ isOpen_compl_iff.1 <| isOpen_iff_generate_Iic_compl.2 <| GenerateOpen.basic _ ‚ü®a, rfl‚ü©‚ü©

/-- The lower closure of a finite set is closed in the upper topology. -/
theorem isClosed_lowerClosure (h : s.Finite) : IsClosed (lowerClosure s : Set Œ±) :=
  LowerTopology.isClosed_upperClosure (Œ± := Œ±·µí·µà) h

/-- Every set open in the upper topology is a upper set. -/
theorem isUpperSet_of_isOpen (h : IsOpen s) : IsUpperSet s :=
  LowerTopology.isLowerSet_of_isOpen (Œ± := Œ±·µí·µà) h

theorem isLowerSet_of_isClosed (h : IsClosed s) : IsLowerSet s :=
  isUpperSet_compl.1 <| isUpperSet_of_isOpen h.isOpen_compl

/--
The closure of a singleton `{a}` in the upper topology is the left-infinite right-closed interval
(-‚àû,a].
-/
@[simp]
theorem closure_singleton (a : Œ±) : closure {a} = Iic a :=
  LowerTopology.closure_singleton (Œ± := Œ±·µí·µà) _

protected theorem isTopologicalBasis : IsTopologicalBasis (upperBasis Œ±) :=
  LowerTopology.isTopologicalBasis (Œ± := Œ±·µí·µà)

/-- A function `f : Œ≤ ‚Üí Œ±` with upper topology in the codomain is continuous provided that the
preimage of every interval `Set.Iic a` is a closed set.

TODO: upgrade to an `iff`. -/
lemma continuous_of_Iic [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} (h : ‚àÄ a, IsClosed (f ‚Åª¬π' (Iic a))) :
    Continuous f :=
  LowerTopology.continuous_of_Ici (Œ± := Œ±·µí·µà) h

end Preorder


section PartialOrder

variable [PartialOrder Œ±] [TopologicalSpace Œ±] [UpperTopology Œ±]

-- see Note [lower instance priority]
/-- The upper topology on a partial order is T‚ÇÄ. -/
instance (priority := 90) t0Space : T0Space Œ± :=
  LowerTopology.t0Space (Œ± := Œ±·µí·µà)

end PartialOrder

end UpperTopology

instance instLowerTopologyProd [Preorder Œ±] [TopologicalSpace Œ±] [LowerTopology Œ±] [OrderBot Œ±]
    [Preorder Œ≤] [TopologicalSpace Œ≤] [LowerTopology Œ≤] [OrderBot Œ≤] : LowerTopology (Œ± √ó Œ≤) where
  topology_eq_lowerTopology := by
    refine' le_antisymm (le_generateFrom _) _
    -- ‚ä¢ ‚àÄ (s : Set (Œ± √ó Œ≤)), s ‚àà {s | ‚àÉ a, (Ici a)·∂ú = s} ‚Üí IsOpen s
    ¬∑ rintro _ ‚ü®x, rfl‚ü©
      -- ‚ä¢ IsOpen (Ici x)·∂ú
      exact (isClosed_Ici.prod isClosed_Ici).isOpen_compl
      -- üéâ no goals
    rw [(LowerTopology.isTopologicalBasis.prod LowerTopology.isTopologicalBasis).eq_generateFrom,
      le_generateFrom_iff_subset_isOpen, image2_subset_iff]
    rintro _ ‚ü®s, hs, rfl‚ü© _ ‚ü®t, ht, rfl‚ü©
    -- ‚ä¢ (‚Üë(upperClosure s))·∂ú √óÀ¢ (‚Üë(upperClosure t))·∂ú ‚àà {s | IsOpen s}
    dsimp
    -- ‚ä¢ IsOpen ((‚Üë(upperClosure s))·∂ú √óÀ¢ (‚Üë(upperClosure t))·∂ú)
    simp_rw [coe_upperClosure, compl_iUnion, prod_eq, preimage_iInter, preimage_compl]
    -- ‚ä¢ IsOpen ((‚ãÇ (i : Œ±) (_ : i ‚àà s), (Prod.fst ‚Åª¬π' Ici i)·∂ú) ‚à© ‚ãÇ (i : Œ≤) (_ : i ‚àà  ‚Ä¶
    -- without `let`, `refine` tries to use the product topology and fails
    let _ : TopologicalSpace (Œ± √ó Œ≤) := generateFrom { s | ‚àÉ a, (Ici a)·∂ú = s }
    -- ‚ä¢ IsOpen ((‚ãÇ (i : Œ±) (_ : i ‚àà s), (Prod.fst ‚Åª¬π' Ici i)·∂ú) ‚à© ‚ãÇ (i : Œ≤) (_ : i ‚àà  ‚Ä¶
    refine (isOpen_biInter hs fun a _ => ?_).inter (isOpen_biInter ht fun b _ => ?_)
    -- ‚ä¢ IsOpen (Prod.fst ‚Åª¬π' Ici a)·∂ú
    ¬∑ exact GenerateOpen.basic _ ‚ü®(a, ‚ä•), by simp [Ici_prod_eq, prod_univ]‚ü©
      -- üéâ no goals
    ¬∑ exact GenerateOpen.basic _ ‚ü®(‚ä•, b), by simp [Ici_prod_eq, univ_prod]‚ü©
      -- üéâ no goals

instance instUpperTopologyProd [Preorder Œ±] [TopologicalSpace Œ±] [UpperTopology Œ±] [OrderTop Œ±]
    [Preorder Œ≤] [TopologicalSpace Œ≤] [UpperTopology Œ≤] [OrderTop Œ≤] : UpperTopology (Œ± √ó Œ≤) where
  topology_eq_upperTopology := by
    suffices : LowerTopology (Œ± √ó Œ≤)·µí·µà
    -- ‚ä¢ instTopologicalSpaceProd = generateFrom {s | ‚àÉ a, (Iic a)·∂ú = s}
    ¬∑ exact LowerTopology.topology_eq_lowerTopology (Œ± := (Œ± √ó Œ≤)·µí·µà)
      -- üéâ no goals
    exact instLowerTopologyProd (Œ± := Œ±·µí·µà) (Œ≤ := Œ≤·µí·µà)
    -- üéâ no goals

section CompleteLattice_LowerTopology

variable [CompleteLattice Œ±] [CompleteLattice Œ≤] [TopologicalSpace Œ±] [LowerTopology Œ±]
  [TopologicalSpace Œ≤] [LowerTopology Œ≤]

protected theorem sInfHom.continuous (f : sInfHom Œ± Œ≤) : Continuous f := by
  refine LowerTopology.continuous_of_Ici fun b => ?_
  -- ‚ä¢ IsClosed (‚Üëf ‚Åª¬π' Ici b)
  convert isClosed_Ici (a := sInf <| f ‚Åª¬π' Ici b)
  -- ‚ä¢ ‚Üëf ‚Åª¬π' Ici b = Ici (sInf (‚Üëf ‚Åª¬π' Ici b))
  refine' Subset.antisymm (fun a => sInf_le) fun a ha => le_trans _ <|
    OrderHomClass.mono (f : Œ± ‚Üío Œ≤) ha
  refine' LE.le.trans _ (map_sInf f _).ge
  -- ‚ä¢ b ‚â§ sInf (‚Üëf '' (‚Üëf ‚Åª¬π' Ici b))
  simp
  -- üéâ no goals
#align Inf_hom.continuous sInfHom.continuous

-- see Note [lower instance priority]
instance (priority := 90) LowerTopology.continuousInf : ContinuousInf Œ± :=
  ‚ü®(infsInfHom : sInfHom (Œ± √ó Œ±) Œ±).continuous‚ü©
#align lower_topology.to_has_continuous_inf LowerTopology.continuousInf

end CompleteLattice_LowerTopology

section CompleteLattice_UpperTopology

variable [CompleteLattice Œ±] [CompleteLattice Œ≤] [TopologicalSpace Œ±] [UpperTopology Œ±]
  [TopologicalSpace Œ≤] [UpperTopology Œ≤]

protected theorem sSupHom.continuous (f : sSupHom Œ± Œ≤) : Continuous f :=
  sInfHom.continuous (Œ± := Œ±·µí·µà) (Œ≤ := Œ≤·µí·µà) (sSupHom.dual.toFun f)

-- see Note [lower instance priority]
instance (priority := 90) UpperTopology.continuousInf : ContinuousSup Œ± :=
  ‚ü®(supsSupHom : sSupHom (Œ± √ó Œ±) Œ±).continuous‚ü©

end CompleteLattice_UpperTopology

lemma UpperDual_iff_Lower [Preorder Œ±] [TopologicalSpace Œ±] :
    UpperTopology Œ±·µí·µà ‚Üî LowerTopology Œ± := by
  constructor
  -- ‚ä¢ UpperTopology Œ±·µí·µà ‚Üí LowerTopology Œ±
  ¬∑ apply UpperTopology.instLowerTopologyDual
    -- üéâ no goals
  ¬∑ apply LowerTopology.instUpperTopologyDual
    -- üéâ no goals

lemma LowerDual_iff_Upper [Preorder Œ±] [TopologicalSpace Œ±] :
    LowerTopology Œ±·µí·µà ‚Üî UpperTopology Œ± := by
  constructor
  -- ‚ä¢ LowerTopology Œ±·µí·µà ‚Üí UpperTopology Œ±
  ¬∑ apply LowerTopology.instUpperTopologyDual
    -- üéâ no goals
  ¬∑ apply UpperTopology.instLowerTopologyDual
    -- üéâ no goals
