/-
Copyright (c) 2023 Christopher Hoskin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Christopher Hoskin
-/
import Mathlib.Order.Hom.CompleteLattice
import Mathlib.Topology.Homeomorph.Defs
import Mathlib.Topology.Order.Lattice

/-!
# Lower and Upper topology

This file introduces the lower topology on a preorder as the topology generated by the complements
of the left-closed right-infinite intervals.

For completeness we also introduce the dual upper topology, generated by the complements of the
right-closed left-infinite intervals.

## Main statements

- `IsLower.t0Space` - the lower topology on a partial order is Tâ‚€
- `IsLower.isTopologicalBasis` - the complements of the upper closures of finite
  subsets form a basis for the lower topology
- `IsLower.continuousInf` - the inf map is continuous with respect to the lower topology

## Implementation notes

A type synonym `WithLower` is introduced and for a preorder `Î±`, `WithLower Î±`
is made an instance of `TopologicalSpace` by the topology generated by the complements of the
closed intervals to infinity.

We define a mixin class `IsLower` for the class of types which are both a preorder and a
topology and where the topology is generated by the complements of the closed intervals to infinity.
It is shown that `WithLower Î±` is an instance of `IsLower`.

Similarly for the upper topology.

## Motivation

The lower topology is used with the `Scott` topology to define the Lawson topology. The restriction
of the lower topology to the spectrum of a complete lattice coincides with the hull-kernel topology.

## References

* [Gierz et al, *A Compendium of Continuous Lattices*][GierzEtAl1980]

## Tags

lower topology, upper topology, preorder
-/

open Set TopologicalSpace Topology

namespace Topology

/--
The lower topology is the topology generated by the complements of the left-closed right-infinite
intervals.
-/
def lower (Î± : Type*) [Preorder Î±] : TopologicalSpace Î± := generateFrom {s | âˆƒ a, (Ici a)á¶œ = s}

/--
The upper topology is the topology generated by the complements of the right-closed left-infinite
intervals.
-/
def upper (Î± : Type*) [Preorder Î±] : TopologicalSpace Î± := generateFrom {s | âˆƒ a, (Iic a)á¶œ = s}

/-- Type synonym for a preorder equipped with the lower set topology. -/
def WithLower (Î± : Type*) := Î±

variable {Î± Î² : Type*}

namespace WithLower

/-- `toLower` is the identity function to the `WithLower` of a type. -/
@[match_pattern] def toLower : Î± â‰ƒ WithLower Î± := Equiv.refl _

/-- `ofLower` is the identity function from the `WithLower` of a type. -/
@[match_pattern] def ofLower : WithLower Î± â‰ƒ Î± := Equiv.refl _

@[simp] lemma toLower_symm : (@toLower Î±).symm = ofLower := rfl
@[simp] lemma ofLower_symm : (@ofLower Î±).symm = toLower := rfl
@[simp] lemma toLower_ofLower (a : WithLower Î±) : toLower (ofLower a) = a := rfl

@[simp] lemma ofLower_toLower (a : Î±) : ofLower (toLower a) = a := rfl

lemma toLower_inj {a b : Î±} : toLower a = toLower b â†” a = b := Iff.rfl

theorem ofLower_inj {a b : WithLower Î±} : ofLower a = ofLower b â†” a = b :=
  Iff.rfl

/-- A recursor for `WithLower`. Use as `induction x`. -/
@[elab_as_elim, cases_eliminator, induction_eliminator]
protected def rec {Î² : WithLower Î± â†’ Sort*} (h : âˆ€ a, Î² (toLower a)) : âˆ€ a, Î² a := fun a â†¦
  h (ofLower a)

instance [Nonempty Î±] : Nonempty (WithLower Î±) := â€¹Nonempty Î±â€º
instance [Inhabited Î±] : Inhabited (WithLower Î±) := â€¹Inhabited Î±â€º

section Preorder

variable [Preorder Î±] {s : Set Î±}

instance : Preorder (WithLower Î±) := â€¹Preorder Î±â€º
instance : TopologicalSpace (WithLower Î±) := lower (WithLower Î±)

@[simp] lemma toLower_le_toLower {x y : Î±} : toLower x â‰¤ toLower y â†” x â‰¤ y := .rfl
@[simp] lemma toLower_lt_toLower {x y : Î±} : toLower x < toLower y â†” x < y := .rfl
@[simp] lemma ofLower_le_ofLower {x y : WithLower Î±} : ofLower x â‰¤ ofLower y â†” x â‰¤ y := .rfl
@[simp] lemma ofLower_lt_ofLower {x y : WithLower Î±} : ofLower x < ofLower y â†” x < y := .rfl

lemma isOpen_preimage_ofLower : IsOpen (ofLower â»Â¹' s) â†” IsOpen[lower Î±] s := Iff.rfl

lemma isOpen_def (T : Set (WithLower Î±)) : IsOpen T â†” IsOpen[lower Î±] (WithLower.toLower â»Â¹' T) :=
  Iff.rfl

theorem continuous_toLower [TopologicalSpace Î±] [ClosedIciTopology Î±] :
    Continuous (toLower : Î± â†’ WithLower Î±) :=
  continuous_generateFrom_iff.mpr <| by rintro _ âŸ¨a, rflâŸ©; exact isClosed_Ici.isOpen_compl

end Preorder

instance [PartialOrder Î±] : PartialOrder (WithLower Î±) := â€¹PartialOrder Î±â€º
instance [LinearOrder Î±] : LinearOrder (WithLower Î±) := â€¹LinearOrder Î±â€º

end WithLower

/-- Type synonym for a preorder equipped with the upper topology. -/
def WithUpper (Î± : Type*) := Î±
namespace WithUpper

/-- `toUpper` is the identity function to the `WithUpper` of a type. -/
@[match_pattern] def toUpper : Î± â‰ƒ WithUpper Î± := Equiv.refl _

/-- `ofUpper` is the identity function from the `WithUpper` of a type. -/
@[match_pattern] def ofUpper : WithUpper Î± â‰ƒ Î± := Equiv.refl _

@[simp] lemma toUpper_symm {Î±} : (@toUpper Î±).symm = ofUpper := rfl
@[simp] lemma ofUpper_symm : (@ofUpper Î±).symm = toUpper := rfl
@[simp] lemma toUpper_ofUpper (a : WithUpper Î±) : toUpper (ofUpper a) = a := rfl
@[simp] lemma ofUpper_toUpper (a : Î±) : ofUpper (toUpper a) = a := rfl
lemma toUpper_inj {a b : Î±} : toUpper a = toUpper b â†” a = b := Iff.rfl
lemma ofUpper_inj {a b : WithUpper Î±} : ofUpper a = ofUpper b â†” a = b := Iff.rfl

/-- A recursor for `WithUpper`. Use as `induction x`. -/
@[elab_as_elim, cases_eliminator, induction_eliminator]
protected def rec {Î² : WithUpper Î± â†’ Sort*} (h : âˆ€ a, Î² (toUpper a)) : âˆ€ a, Î² a := fun a â†¦
  h (ofUpper a)

instance [Nonempty Î±] : Nonempty (WithUpper Î±) := â€¹Nonempty Î±â€º
instance [Inhabited Î±] : Inhabited (WithUpper Î±) := â€¹Inhabited Î±â€º

section Preorder

variable [Preorder Î±] {s : Set Î±}

instance : Preorder (WithUpper Î±) := â€¹Preorder Î±â€º
instance : TopologicalSpace (WithUpper Î±) := upper (WithUpper Î±)

@[simp] lemma toUpper_le_toUpper {x y : Î±} : toUpper x â‰¤ toUpper y â†” x â‰¤ y := .rfl
@[simp] lemma toUpper_lt_toUpper {x y : Î±} : toUpper x < toUpper y â†” x < y := .rfl
@[simp] lemma ofUpper_le_ofUpper {x y : WithUpper Î±} : ofUpper x â‰¤ ofUpper y â†” x â‰¤ y := .rfl
@[simp] lemma ofUpper_lt_ofUpper {x y : WithUpper Î±} : ofUpper x < ofUpper y â†” x < y := .rfl

lemma isOpen_preimage_ofUpper : IsOpen (ofUpper â»Â¹' s) â†” (upper Î±).IsOpen s := Iff.rfl

lemma isOpen_def {s : Set (WithUpper Î±)} : IsOpen s â†” (upper Î±).IsOpen (toUpper â»Â¹' s) := Iff.rfl

theorem continuous_toUpper [TopologicalSpace Î±] [ClosedIicTopology Î±] :
    Continuous (toUpper : Î± â†’ WithUpper Î±) :=
  continuous_generateFrom_iff.mpr <| by rintro _ âŸ¨a, rflâŸ©; exact isClosed_Iic.isOpen_compl

end Preorder

instance [PartialOrder Î±] : PartialOrder (WithUpper Î±) := â€¹PartialOrder Î±â€º
instance [LinearOrder Î±] : LinearOrder (WithUpper Î±) := â€¹LinearOrder Î±â€º

end WithUpper

/--
The lower topology is the topology generated by the complements of the left-closed right-infinite
intervals.
-/
class IsLower (Î± : Type*) [t : TopologicalSpace Î±] [Preorder Î±] : Prop where
  topology_eq_lowerTopology : t = lower Î±

attribute [nolint docBlame] IsLower.topology_eq_lowerTopology

/--
The upper topology is the topology generated by the complements of the right-closed left-infinite
intervals.
-/
class IsUpper (Î± : Type*) [t : TopologicalSpace Î±] [Preorder Î±] : Prop where
  topology_eq_upperTopology : t = upper Î±
attribute [nolint docBlame] IsUpper.topology_eq_upperTopology

instance [Preorder Î±] : IsLower (WithLower Î±) := âŸ¨rflâŸ©
instance [Preorder Î±] : IsUpper (WithUpper Î±) := âŸ¨rflâŸ©

/--
The lower topology is homeomorphic to the upper topology on the dual order
-/
def WithLower.toDualHomeomorph [Preorder Î±] : WithLower Î± â‰ƒâ‚œ WithUpper Î±áµ’áµˆ where
  toFun := OrderDual.toDual
  invFun := OrderDual.ofDual
  left_inv := OrderDual.toDual_ofDual
  right_inv := OrderDual.ofDual_toDual
  continuous_toFun := continuous_coinduced_rng
  continuous_invFun := continuous_coinduced_rng

namespace IsLower

/-- The complements of the upper closures of finite sets are a collection of lower sets
which form a basis for the lower topology. -/
def lowerBasis (Î± : Type*) [Preorder Î±] :=
  { s : Set Î± | âˆƒ t : Set Î±, t.Finite âˆ§ (upperClosure t : Set Î±)á¶œ = s }

section Preorder

variable (Î±)
variable [Preorder Î±] [TopologicalSpace Î±] [IsLower Î±] {s : Set Î±}

lemma topology_eq : â€¹_â€º = lower Î± := topology_eq_lowerTopology

variable {Î±}

/-- If `Î±` is equipped with the lower topology, then it is homeomorphic to `WithLower Î±`.
-/
def withLowerHomeomorph : WithLower Î± â‰ƒâ‚œ Î± :=
  WithLower.ofLower.toHomeomorphOfIsInducing âŸ¨topology_eq Î± â–¸ induced_id.symmâŸ©

theorem isOpen_iff_generate_Ici_compl : IsOpen s â†” GenerateOpen { t | âˆƒ a, (Ici a)á¶œ = t } s := by
  rw [topology_eq Î±]; rfl

instance _root_.OrderDual.instIsUpper [Preorder Î±] [TopologicalSpace Î±] [IsLower Î±] :
    IsUpper Î±áµ’áµˆ where
  topology_eq_upperTopology := topology_eq_lowerTopology (Î± := Î±)

/-- Left-closed right-infinite intervals [a, âˆž) are closed in the lower topology. -/
instance : ClosedIciTopology Î± :=
  âŸ¨fun a â†¦ isOpen_compl_iff.1 <| isOpen_iff_generate_Ici_compl.2 <| GenerateOpen.basic _ âŸ¨a, rflâŸ©âŸ©

/-- The upper closure of a finite set is closed in the lower topology. -/
theorem isClosed_upperClosure (h : s.Finite) : IsClosed (upperClosure s : Set Î±) := by
  simp only [â† UpperSet.iInf_Ici, UpperSet.coe_iInf]
  exact h.isClosed_biUnion fun _ _ â†¦ isClosed_Ici

/-- Every set open in the lower topology is a lower set. -/
theorem isLowerSet_of_isOpen (h : IsOpen s) : IsLowerSet s := by
  replace h := isOpen_iff_generate_Ici_compl.1 h
  induction h with
  | basic u h' => obtain âŸ¨a, rflâŸ© := h'; exact (isUpperSet_Ici a).compl
  | univ => exact isLowerSet_univ
  | inter u v _ _ hu2 hv2 => exact hu2.inter hv2
  | sUnion _ _ ih => exact isLowerSet_sUnion ih

theorem isUpperSet_of_isClosed (h : IsClosed s) : IsUpperSet s :=
  isLowerSet_compl.1 <| isLowerSet_of_isOpen h.isOpen_compl

theorem tendsto_nhds_iff_not_le {Î² : Type*} {f : Î² â†’ Î±} {l : Filter Î²} {x : Î±} :
    Filter.Tendsto f l (ð“ x) â†” âˆ€ y, Â¬y â‰¤ x â†’ âˆ€á¶  z in l, Â¬y â‰¤ f z := by
  simp [topology_eq_lowerTopology, tendsto_nhds_generateFrom_iff, Filter.Eventually, Ici,
    compl_setOf]

/--
The closure of a singleton `{a}` in the lower topology is the left-closed right-infinite interval
[a, âˆž).
-/
@[simp]
theorem closure_singleton (a : Î±) : closure {a} = Ici a :=
  Subset.antisymm ((closure_minimal fun _ h â†¦ h.ge) <| isClosed_Ici) <|
    (isUpperSet_of_isClosed isClosed_closure).Ici_subset <| subset_closure rfl

protected theorem isTopologicalBasis : IsTopologicalBasis (lowerBasis Î±) := by
  convert isTopologicalBasis_of_subbasis (topology_eq Î±)
  simp_rw [lowerBasis, coe_upperClosure, compl_iUnion]
  ext s
  constructor
  Â· rintro âŸ¨F, hF, rflâŸ©
    refine âŸ¨(fun a â†¦ (Ici a)á¶œ) '' F, âŸ¨hF.image _, image_subset_iff.2 fun _ _ â†¦ âŸ¨_, rflâŸ©âŸ©, ?_âŸ©
    simp only [sInter_image]
  Â· rintro âŸ¨F, âŸ¨hF, hsâŸ©, rflâŸ©
    haveI := hF.to_subtype
    rw [subset_def, Subtype.forall'] at hs
    choose f hf using hs
    exact âŸ¨_, finite_range f, by simp_rw [biInter_range, hf, sInter_eq_iInter]âŸ©

/-- A function `f : Î² â†’ Î±` with lower topology in the codomain is continuous
if and only if the preimage of every interval `Set.Ici a` is a closed set.
-/
lemma continuous_iff_Ici [TopologicalSpace Î²] {f : Î² â†’ Î±} :
    Continuous f â†” âˆ€ a, IsClosed (f â»Â¹' (Ici a)) := by
  obtain rfl := IsLower.topology_eq Î±
  simp [continuous_generateFrom_iff]

end Preorder

section PartialOrder

variable [PartialOrder Î±] [TopologicalSpace Î±] [IsLower Î±]

-- see Note [lower instance priority]
/-- The lower topology on a partial order is Tâ‚€. -/
instance (priority := 90) t0Space : T0Space Î± :=
  (t0Space_iff_inseparable Î±).2 fun x y h â†¦
    Ici_injective <| by simpa only [inseparable_iff_closure_eq, closure_singleton] using h

end PartialOrder

section LinearOrder

variable [LinearOrder Î±] [TopologicalSpace Î±] [IsLower Î±]

lemma isTopologicalBasis_insert_univ_subbasis :
    IsTopologicalBasis (insert univ {s : Set Î± | âˆƒ a, (Ici a)á¶œ = s}) :=
  isTopologicalBasis_of_subbasis_of_inter (by rw [topology_eq Î±, lower]) (by
    rintro _ âŸ¨b, rflâŸ© _ âŸ¨c, rflâŸ©
    use b âŠ“ c
    rw [compl_Ici, compl_Ici, compl_Ici, Iio_inter_Iio])

theorem tendsto_nhds_iff_lt {Î² : Type*} {f : Î² â†’ Î±} {l : Filter Î²} {x : Î±} :
    Filter.Tendsto f l (ð“ x) â†” âˆ€ y, x < y â†’ âˆ€á¶  z in l, f z < y := by
  simp only [tendsto_nhds_iff_not_le, not_le]

end LinearOrder

section CompleteLinearOrder

variable [CompleteLinearOrder Î±] [t : TopologicalSpace Î±] [IsLower Î±]

lemma isTopologicalSpace_basis (U : Set Î±) : IsOpen U â†” U = univ âˆ¨ âˆƒ a, (Ici a)á¶œ = U := by
  by_cases hU : U = univ
  Â· simp only [hU, isOpen_univ, compl_Ici, true_or]
  refine âŸ¨?_, isTopologicalBasis_insert_univ_subbasis.isOpenâŸ©
  intro hO
  apply Or.inr
  convert IsTopologicalBasis.open_eq_sUnion isTopologicalBasis_insert_univ_subbasis hO
  constructor
  Â· intro âŸ¨a, haâŸ©
    use {U}
    constructor
    Â· apply subset_trans (singleton_subset_iff.mpr _) (subset_insert _ _)
      use a
    Â· rw [sUnion_singleton]
  Â· intro âŸ¨S, hS1, hS2âŸ©
    have hUS : univ âˆ‰ S := by
      by_contra hUS'
      apply hU
      rw [hS2]
      exact sUnion_eq_univ_iff.mpr (fun a â†¦ âŸ¨univ, hUS', trivialâŸ©)
    use sSup {a | (Ici a)á¶œ âˆˆ S}
    rw [hS2, sUnion_eq_compl_sInter_compl, compl_inj_iff]
    apply le_antisymm
    Â· intro b hb
      simp only [sInter_image, mem_iInter, mem_compl_iff]
      intro s hs
      obtain âŸ¨a, haâŸ© := (subset_insert_iff_of_notMem hUS).mp hS1 hs
      subst hS2 ha
      simp_all only [compl_Ici, mem_Ici, sSup_le_iff, mem_setOf_eq, mem_Iio, not_lt]
    Â· intro b hb
      rw [mem_Ici, sSup_le_iff]
      intro c hc
      simp only [sInter_image, mem_iInter] at hb
      rw [â† not_lt, â† mem_Iio, â† compl_Ici]
      exact hb _ hc

end CompleteLinearOrder

end IsLower


namespace IsUpper

/-- The complements of the lower closures of finite sets are a collection of upper sets
which form a basis for the upper topology. -/
def upperBasis (Î± : Type*) [Preorder Î±] :=
  { s : Set Î± | âˆƒ t : Set Î±, t.Finite âˆ§ (lowerClosure t : Set Î±)á¶œ = s }

section Preorder

variable (Î±)
variable [Preorder Î±] [TopologicalSpace Î±] [IsUpper Î±] {s : Set Î±}

lemma topology_eq : â€¹_â€º = upper Î± := topology_eq_upperTopology

variable {Î±}

/-- If `Î±` is equipped with the upper topology, then it is homeomorphic to `WithUpper Î±`.
-/
def withUpperHomeomorph : WithUpper Î± â‰ƒâ‚œ Î± :=
  WithUpper.ofUpper.toHomeomorphOfIsInducing âŸ¨topology_eq Î± â–¸ induced_id.symmâŸ©

theorem isOpen_iff_generate_Iic_compl : IsOpen s â†” GenerateOpen { t | âˆƒ a, (Iic a)á¶œ = t } s := by
  rw [topology_eq Î±]; rfl

instance _root_.OrderDual.instIsLower [Preorder Î±] [TopologicalSpace Î±] [IsUpper Î±] :
    IsLower Î±áµ’áµˆ where
  topology_eq_lowerTopology := topology_eq_upperTopology (Î± := Î±)

/-- Left-infinite right-closed intervals (-âˆž,a] are closed in the upper topology. -/
instance : ClosedIicTopology Î± :=
  âŸ¨fun a â†¦ isOpen_compl_iff.1 <| isOpen_iff_generate_Iic_compl.2 <| GenerateOpen.basic _ âŸ¨a, rflâŸ©âŸ©

/-- The lower closure of a finite set is closed in the upper topology. -/
theorem isClosed_lowerClosure (h : s.Finite) : IsClosed (lowerClosure s : Set Î±) :=
  IsLower.isClosed_upperClosure (Î± := Î±áµ’áµˆ) h

/-- Every set open in the upper topology is a upper set. -/
theorem isUpperSet_of_isOpen (h : IsOpen s) : IsUpperSet s :=
  IsLower.isLowerSet_of_isOpen (Î± := Î±áµ’áµˆ) h

theorem isLowerSet_of_isClosed (h : IsClosed s) : IsLowerSet s :=
  isUpperSet_compl.1 <| isUpperSet_of_isOpen h.isOpen_compl

theorem tendsto_nhds_iff_not_le {Î² : Type*} {f : Î² â†’ Î±} {l : Filter Î²} {x : Î±} :
    Filter.Tendsto f l (ð“ x) â†” âˆ€ y, Â¬x â‰¤ y â†’ âˆ€á¶  z in l, Â¬f z â‰¤ y :=
  IsLower.tendsto_nhds_iff_not_le (Î± := Î±áµ’áµˆ)

/--
The closure of a singleton `{a}` in the upper topology is the left-infinite right-closed interval
(-âˆž,a].
-/
@[simp]
theorem closure_singleton (a : Î±) : closure {a} = Iic a :=
  IsLower.closure_singleton (Î± := Î±áµ’áµˆ) _

protected theorem isTopologicalBasis : IsTopologicalBasis (upperBasis Î±) :=
  IsLower.isTopologicalBasis (Î± := Î±áµ’áµˆ)

/-- A function `f : Î² â†’ Î±` with upper topology in the codomain is continuous
if and only if the preimage of every interval `Set.Iic a` is a closed set. -/
lemma continuous_iff_Iic [TopologicalSpace Î²] {f : Î² â†’ Î±} :
    Continuous f â†” âˆ€ a, IsClosed (f â»Â¹' (Iic a)) :=
  IsLower.continuous_iff_Ici (Î± := Î±áµ’áµˆ)

end Preorder


section PartialOrder

variable [PartialOrder Î±] [TopologicalSpace Î±] [IsUpper Î±]

-- see Note [lower instance priority]
/-- The upper topology on a partial order is Tâ‚€. -/
instance (priority := 90) t0Space : T0Space Î± :=
  IsLower.t0Space (Î± := Î±áµ’áµˆ)

end PartialOrder

section LinearOrder

variable [LinearOrder Î±] [TopologicalSpace Î±] [IsUpper Î±]

lemma isTopologicalBasis_insert_univ_subbasis :
    IsTopologicalBasis (insert univ {s : Set Î± | âˆƒ a, (Iic a)á¶œ = s}) :=
  IsLower.isTopologicalBasis_insert_univ_subbasis (Î± := Î±áµ’áµˆ)

theorem tendsto_nhds_iff_lt {Î² : Type*} {f : Î² â†’ Î±} {l : Filter Î²} {x : Î±} :
    Filter.Tendsto f l (ð“ x) â†” âˆ€ y < x, âˆ€á¶  z in l, y < f z :=
  IsLower.tendsto_nhds_iff_lt (Î± := Î±áµ’áµˆ)

end LinearOrder

section CompleteLinearOrder

variable [CompleteLinearOrder Î±] [t : TopologicalSpace Î±] [IsUpper Î±]

lemma isTopologicalSpace_basis (U : Set Î±) : IsOpen U â†” U = univ âˆ¨ âˆƒ a, (Iic a)á¶œ = U :=
  IsLower.isTopologicalSpace_basis (Î± := Î±áµ’áµˆ) U

end CompleteLinearOrder

end IsUpper

instance instIsLowerProd [Preorder Î±] [TopologicalSpace Î±] [IsLower Î±]
    [OrderBot Î±] [Preorder Î²] [TopologicalSpace Î²] [IsLower Î²] [OrderBot Î²] :
    IsLower (Î± Ã— Î²) where
  topology_eq_lowerTopology := by
    refine le_antisymm (le_generateFrom ?_) ?_
    Â· rintro _ âŸ¨x, rflâŸ©
      exact (isClosed_Ici.prod isClosed_Ici).isOpen_compl
    rw [(IsLower.isTopologicalBasis.prod
      IsLower.isTopologicalBasis).eq_generateFrom, le_generateFrom_iff_subset_isOpen,
      image2_subset_iff]
    rintro _ âŸ¨s, hs, rflâŸ© _ âŸ¨t, ht, rflâŸ©
    dsimp
    simp_rw [coe_upperClosure, compl_iUnion, prod_eq, preimage_iInter, preimage_compl]
    -- without `let`, `refine` tries to use the product topology and fails
    let _ : TopologicalSpace (Î± Ã— Î²) := lower (Î± Ã— Î²)
    refine (hs.isOpen_biInter fun a _ â†¦ ?_).inter (ht.isOpen_biInter fun b _ â†¦ ?_)
    Â· exact GenerateOpen.basic _ âŸ¨(a, âŠ¥), by simp [Ici_prod_eq, prod_univ]âŸ©
    Â· exact GenerateOpen.basic _ âŸ¨(âŠ¥, b), by simp [Ici_prod_eq, univ_prod]âŸ©

instance instIsUpperProd [Preorder Î±] [TopologicalSpace Î±] [IsUpper Î±]
    [OrderTop Î±] [Preorder Î²] [TopologicalSpace Î²] [IsUpper Î²] [OrderTop Î²] :
    IsUpper (Î± Ã— Î²) where
  topology_eq_upperTopology := by
    suffices IsLower (Î± Ã— Î²)áµ’áµˆ from IsLower.topology_eq_lowerTopology (Î± := (Î± Ã— Î²)áµ’áµˆ)
    exact instIsLowerProd (Î± := Î±áµ’áµˆ) (Î² := Î²áµ’áµˆ)

section CompleteLattice_IsLower

variable [CompleteLattice Î±] [CompleteLattice Î²] [TopologicalSpace Î±] [IsLower Î±]
  [TopologicalSpace Î²] [IsLower Î²]

protected lemma _root_.sInfHom.continuous (f : sInfHom Î± Î²) : Continuous f := by
  refine IsLower.continuous_iff_Ici.2 fun b â†¦ ?_
  convert isClosed_Ici (a := sInf <| f â»Â¹' Ici b)
  refine Subset.antisymm (fun a â†¦ sInf_le) fun a ha â†¦ le_trans ?_ <|
    OrderHomClass.mono (f : Î± â†’o Î²) ha
  refine LE.le.trans ?_ (map_sInf f _).ge
  simp

-- see Note [lower instance priority]
instance (priority := 90) IsLower.toContinuousInf : ContinuousInf Î± :=
  âŸ¨(infsInfHom : sInfHom (Î± Ã— Î±) Î±).continuousâŸ©

end CompleteLattice_IsLower

section CompleteLattice_IsUpper

variable [CompleteLattice Î±] [CompleteLattice Î²] [TopologicalSpace Î±] [IsUpper Î±]
  [TopologicalSpace Î²] [IsUpper Î²]

protected lemma _root_.sSupHom.continuous (f : sSupHom Î± Î²) : Continuous f :=
  sInfHom.continuous (Î± := Î±áµ’áµˆ) (Î² := Î²áµ’áµˆ) (sSupHom.dual.toFun f)

-- see Note [lower instance priority]
instance (priority := 90) IsUpper.toContinuousInf : ContinuousSup Î± :=
  âŸ¨(supsSupHom : sSupHom (Î± Ã— Î±) Î±).continuousâŸ©

end CompleteLattice_IsUpper

lemma isUpper_orderDual [Preorder Î±] [TopologicalSpace Î±] : IsUpper Î±áµ’áµˆ â†” IsLower Î± := by
  constructor
  Â· apply OrderDual.instIsLower
  Â· apply OrderDual.instIsUpper

lemma isLower_orderDual [Preorder Î±] [TopologicalSpace Î±] : IsLower Î±áµ’áµˆ â†” IsUpper Î± :=
  isUpper_orderDual.symm

end Topology

/-- The SierpiÅ„ski topology on `Prop` is the upper topology -/
instance : IsUpper Prop where
  topology_eq_upperTopology := by
    rw [Topology.upper, sierpinskiSpace, â† generateFrom_insert_empty]
    congr
    exact le_antisymm
      (fun h hs â†¦ by
        simp only [compl_Iic, mem_setOf_eq]
        rw [â† Ioi_True, â† Ioi_False] at hs
        rcases hs with (rfl | rfl)
        Â· use True
        Â· use False)
      (by rintro _ âŸ¨a, rflâŸ©; by_cases a <;> aesop (add simp [Ioi, lt_iff_le_not_ge]))
