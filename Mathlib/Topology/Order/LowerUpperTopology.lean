/-
Copyright (c) 2023 Christopher Hoskin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Christopher Hoskin
-/
import Mathlib.Order.Hom.CompleteLattice
import Mathlib.Topology.Homeomorph.Defs
import Mathlib.Topology.Order.Lattice

/-!
# Lower and Upper topology

This file introduces the lower topology on a preorder as the topology generated by the complements
of the left-closed right-infinite intervals.

For completeness we also introduce the dual upper topology, generated by the complements of the
right-closed left-infinite intervals.

## Main statements

- `IsLower.t0Space` - the lower topology on a partial order is T‚ÇÄ
- `IsLower.isTopologicalBasis` - the complements of the upper closures of finite
  subsets form a basis for the lower topology
- `IsLower.continuousInf` - the inf map is continuous with respect to the lower topology

## Implementation notes

A type synonym `WithLower` is introduced and for a preorder `Œ±`, `WithLower Œ±`
is made an instance of `TopologicalSpace` by the topology generated by the complements of the
closed intervals to infinity.

We define a mixin class `IsLower` for the class of types which are both a preorder and a
topology and where the topology is generated by the complements of the closed intervals to infinity.
It is shown that `WithLower Œ±` is an instance of `IsLower`.

Similarly for the upper topology.

## Motivation

The lower topology is used with the `Scott` topology to define the Lawson topology. The restriction
of the lower topology to the spectrum of a complete lattice coincides with the hull-kernel topology.

## References

* [Gierz et al, *A Compendium of Continuous Lattices*][GierzEtAl1980]

## Tags

lower topology, upper topology, preorder
-/

open Set TopologicalSpace Topology

namespace Topology

/--
The lower topology is the topology generated by the complements of the left-closed right-infinite
intervals.
-/
def lower (Œ± : Type*) [Preorder Œ±] : TopologicalSpace Œ± := generateFrom {s | ‚àÉ a, (Ici a)·∂ú = s}

/--
The upper topology is the topology generated by the complements of the right-closed left-infinite
intervals.
-/
def upper (Œ± : Type*) [Preorder Œ±] : TopologicalSpace Œ± := generateFrom {s | ‚àÉ a, (Iic a)·∂ú = s}

/-- Type synonym for a preorder equipped with the lower set topology. -/
def WithLower (Œ± : Type*) := Œ±

variable {Œ± Œ≤ : Type*}

namespace WithLower

/-- `toLower` is the identity function to the `WithLower` of a type. -/
@[match_pattern] def toLower : Œ± ‚âÉ WithLower Œ± := Equiv.refl _

/-- `ofLower` is the identity function from the `WithLower` of a type. -/
@[match_pattern] def ofLower : WithLower Œ± ‚âÉ Œ± := Equiv.refl _

@[simp] lemma toLower_symm : (@toLower Œ±).symm = ofLower := rfl
@[simp] lemma ofLower_symm : (@ofLower Œ±).symm = toLower := rfl
@[simp] lemma toLower_ofLower (a : WithLower Œ±) : toLower (ofLower a) = a := rfl

@[simp] lemma ofLower_toLower (a : Œ±) : ofLower (toLower a) = a := rfl

lemma toLower_inj {a b : Œ±} : toLower a = toLower b ‚Üî a = b := Iff.rfl

theorem ofLower_inj {a b : WithLower Œ±} : ofLower a = ofLower b ‚Üî a = b :=
  Iff.rfl

/-- A recursor for `WithLower`. Use as `induction x`. -/
@[elab_as_elim, cases_eliminator, induction_eliminator]
protected def rec {Œ≤ : WithLower Œ± ‚Üí Sort*} (h : ‚àÄ a, Œ≤ (toLower a)) : ‚àÄ a, Œ≤ a := fun a =>
  h (ofLower a)

instance [Nonempty Œ±] : Nonempty (WithLower Œ±) := ‚ÄπNonempty Œ±‚Ä∫
instance [Inhabited Œ±] : Inhabited (WithLower Œ±) := ‚ÄπInhabited Œ±‚Ä∫

section Preorder

variable [Preorder Œ±] {s : Set Œ±}

instance : Preorder (WithLower Œ±) := ‚ÄπPreorder Œ±‚Ä∫
instance : TopologicalSpace (WithLower Œ±) := lower (WithLower Œ±)

@[simp] lemma toLower_le_toLower {x y : Œ±} : toLower x ‚â§ toLower y ‚Üî x ‚â§ y := .rfl
@[simp] lemma toLower_lt_toLower {x y : Œ±} : toLower x < toLower y ‚Üî x < y := .rfl
@[simp] lemma ofLower_le_ofLower {x y : WithLower Œ±} : ofLower x ‚â§ ofLower y ‚Üî x ‚â§ y := .rfl
@[simp] lemma ofLower_lt_ofLower {x y : WithLower Œ±} : ofLower x < ofLower y ‚Üî x < y := .rfl

lemma isOpen_preimage_ofLower : IsOpen (ofLower ‚Åª¬π' s) ‚Üî IsOpen[lower Œ±] s := Iff.rfl

lemma isOpen_def (T : Set (WithLower Œ±)) : IsOpen T ‚Üî IsOpen[lower Œ±] (WithLower.toLower ‚Åª¬π' T) :=
  Iff.rfl

theorem continuous_toLower [TopologicalSpace Œ±] [ClosedIciTopology Œ±] :
    Continuous (toLower : Œ± ‚Üí WithLower Œ±) :=
  continuous_generateFrom_iff.mpr <| by rintro _ ‚ü®a, rfl‚ü©; exact isClosed_Ici.isOpen_compl

end Preorder

instance [PartialOrder Œ±] : PartialOrder (WithLower Œ±) := ‚ÄπPartialOrder Œ±‚Ä∫
instance [LinearOrder Œ±] : LinearOrder (WithLower Œ±) := ‚ÄπLinearOrder Œ±‚Ä∫

end WithLower

/-- Type synonym for a preorder equipped with the upper topology. -/
def WithUpper (Œ± : Type*) := Œ±
namespace WithUpper

/-- `toUpper` is the identity function to the `WithUpper` of a type. -/
@[match_pattern] def toUpper : Œ± ‚âÉ WithUpper Œ± := Equiv.refl _

/-- `ofUpper` is the identity function from the `WithUpper` of a type. -/
@[match_pattern] def ofUpper : WithUpper Œ± ‚âÉ Œ± := Equiv.refl _

@[simp] lemma toUpper_symm {Œ±} : (@toUpper Œ±).symm = ofUpper := rfl
@[simp] lemma ofUpper_symm : (@ofUpper Œ±).symm = toUpper := rfl
@[simp] lemma toUpper_ofUpper (a : WithUpper Œ±) : toUpper (ofUpper a) = a := rfl
@[simp] lemma ofUpper_toUpper (a : Œ±) : ofUpper (toUpper a) = a := rfl
lemma toUpper_inj {a b : Œ±} : toUpper a = toUpper b ‚Üî a = b := Iff.rfl
lemma ofUpper_inj {a b : WithUpper Œ±} : ofUpper a = ofUpper b ‚Üî a = b := Iff.rfl

/-- A recursor for `WithUpper`. Use as `induction x`. -/
@[elab_as_elim, cases_eliminator, induction_eliminator]
protected def rec {Œ≤ : WithUpper Œ± ‚Üí Sort*} (h : ‚àÄ a, Œ≤ (toUpper a)) : ‚àÄ a, Œ≤ a := fun a =>
  h (ofUpper a)

instance [Nonempty Œ±] : Nonempty (WithUpper Œ±) := ‚ÄπNonempty Œ±‚Ä∫
instance [Inhabited Œ±] : Inhabited (WithUpper Œ±) := ‚ÄπInhabited Œ±‚Ä∫

section Preorder

variable [Preorder Œ±] {s : Set Œ±}

instance : Preorder (WithUpper Œ±) := ‚ÄπPreorder Œ±‚Ä∫
instance : TopologicalSpace (WithUpper Œ±) := upper (WithUpper Œ±)

@[simp] lemma toUpper_le_toUpper {x y : Œ±} : toUpper x ‚â§ toUpper y ‚Üî x ‚â§ y := .rfl
@[simp] lemma toUpper_lt_toUpper {x y : Œ±} : toUpper x < toUpper y ‚Üî x < y := .rfl
@[simp] lemma ofUpper_le_ofUpper {x y : WithUpper Œ±} : ofUpper x ‚â§ ofUpper y ‚Üî x ‚â§ y := .rfl
@[simp] lemma ofUpper_lt_ofUpper {x y : WithUpper Œ±} : ofUpper x < ofUpper y ‚Üî x < y := .rfl

lemma isOpen_preimage_ofUpper : IsOpen (ofUpper ‚Åª¬π' s) ‚Üî (upper Œ±).IsOpen s := Iff.rfl

lemma isOpen_def {s : Set (WithUpper Œ±)} : IsOpen s ‚Üî (upper Œ±).IsOpen (toUpper ‚Åª¬π' s) := Iff.rfl

theorem continuous_toUpper [TopologicalSpace Œ±] [ClosedIicTopology Œ±] :
    Continuous (toUpper : Œ± ‚Üí WithUpper Œ±) :=
  continuous_generateFrom_iff.mpr <| by rintro _ ‚ü®a, rfl‚ü©; exact isClosed_Iic.isOpen_compl

end Preorder

instance [PartialOrder Œ±] : PartialOrder (WithUpper Œ±) := ‚ÄπPartialOrder Œ±‚Ä∫
instance [LinearOrder Œ±] : LinearOrder (WithUpper Œ±) := ‚ÄπLinearOrder Œ±‚Ä∫

end WithUpper

/--
The lower topology is the topology generated by the complements of the left-closed right-infinite
intervals.
-/
class IsLower (Œ± : Type*) [t : TopologicalSpace Œ±] [Preorder Œ±] : Prop where
  topology_eq_lowerTopology : t = lower Œ±

attribute [nolint docBlame] IsLower.topology_eq_lowerTopology

/--
The upper topology is the topology generated by the complements of the right-closed left-infinite
intervals.
-/
class IsUpper (Œ± : Type*) [t : TopologicalSpace Œ±] [Preorder Œ±] : Prop where
  topology_eq_upperTopology : t = upper Œ±
attribute [nolint docBlame] IsUpper.topology_eq_upperTopology

instance [Preorder Œ±] : IsLower (WithLower Œ±) := ‚ü®rfl‚ü©
instance [Preorder Œ±] : IsUpper (WithUpper Œ±) := ‚ü®rfl‚ü©

/--
The lower topology is homeomorphic to the upper topology on the dual order
-/
def WithLower.toDualHomeomorph [Preorder Œ±] : WithLower Œ± ‚âÉ‚Çú WithUpper Œ±·µí·µà where
  toFun := OrderDual.toDual
  invFun := OrderDual.ofDual
  left_inv := OrderDual.toDual_ofDual
  right_inv := OrderDual.ofDual_toDual
  continuous_toFun := continuous_coinduced_rng
  continuous_invFun := continuous_coinduced_rng

namespace IsLower

/-- The complements of the upper closures of finite sets are a collection of lower sets
which form a basis for the lower topology. -/
def lowerBasis (Œ± : Type*) [Preorder Œ±] :=
  { s : Set Œ± | ‚àÉ t : Set Œ±, t.Finite ‚àß (upperClosure t : Set Œ±)·∂ú = s }

section Preorder

variable (Œ±)
variable [Preorder Œ±] [TopologicalSpace Œ±] [IsLower Œ±] {s : Set Œ±}

lemma topology_eq : ‚Äπ_‚Ä∫ = lower Œ± := topology_eq_lowerTopology

variable {Œ±}

/-- If `Œ±` is equipped with the lower topology, then it is homeomorphic to `WithLower Œ±`.
-/
def withLowerHomeomorph : WithLower Œ± ‚âÉ‚Çú Œ± :=
  WithLower.ofLower.toHomeomorphOfIsInducing ‚ü®topology_eq Œ± ‚ñ∏ induced_id.symm‚ü©

theorem isOpen_iff_generate_Ici_compl : IsOpen s ‚Üî GenerateOpen { t | ‚àÉ a, (Ici a)·∂ú = t } s := by
  rw [topology_eq Œ±]; rfl

instance _root_.OrderDual.instIsUpper [Preorder Œ±] [TopologicalSpace Œ±] [IsLower Œ±] :
    IsUpper Œ±·µí·µà where
  topology_eq_upperTopology := topology_eq_lowerTopology (Œ± := Œ±)

/-- Left-closed right-infinite intervals [a, ‚àû) are closed in the lower topology. -/
instance : ClosedIciTopology Œ± :=
  ‚ü®fun a ‚Ü¶ isOpen_compl_iff.1 <| isOpen_iff_generate_Ici_compl.2 <| GenerateOpen.basic _ ‚ü®a, rfl‚ü©‚ü©

/-- The upper closure of a finite set is closed in the lower topology. -/
theorem isClosed_upperClosure (h : s.Finite) : IsClosed (upperClosure s : Set Œ±) := by
  simp only [‚Üê UpperSet.iInf_Ici, UpperSet.coe_iInf]
  exact h.isClosed_biUnion fun _ _ => isClosed_Ici

/-- Every set open in the lower topology is a lower set. -/
theorem isLowerSet_of_isOpen (h : IsOpen s) : IsLowerSet s := by
  replace h := isOpen_iff_generate_Ici_compl.1 h
  induction h with
  | basic u h' => obtain ‚ü®a, rfl‚ü© := h'; exact (isUpperSet_Ici a).compl
  | univ => exact isLowerSet_univ
  | inter u v _ _ hu2 hv2 => exact hu2.inter hv2
  | sUnion _ _ ih => exact isLowerSet_sUnion ih

theorem isUpperSet_of_isClosed (h : IsClosed s) : IsUpperSet s :=
  isLowerSet_compl.1 <| isLowerSet_of_isOpen h.isOpen_compl

theorem tendsto_nhds_iff_not_le {Œ≤ : Type*} {f : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} {x : Œ±} :
    Filter.Tendsto f l (ùìù x) ‚Üî ‚àÄ y, ¬¨y ‚â§ x ‚Üí ‚àÄ·∂† z in l, ¬¨y ‚â§ f z := by
  simp [topology_eq_lowerTopology, tendsto_nhds_generateFrom_iff, Filter.Eventually, Ici,
    compl_setOf]

/--
The closure of a singleton `{a}` in the lower topology is the left-closed right-infinite interval
[a, ‚àû).
-/
@[simp]
theorem closure_singleton (a : Œ±) : closure {a} = Ici a :=
  Subset.antisymm ((closure_minimal fun _ h => h.ge) <| isClosed_Ici) <|
    (isUpperSet_of_isClosed isClosed_closure).Ici_subset <| subset_closure rfl

protected theorem isTopologicalBasis : IsTopologicalBasis (lowerBasis Œ±) := by
  convert isTopologicalBasis_of_subbasis (topology_eq Œ±)
  simp_rw [lowerBasis, coe_upperClosure, compl_iUnion]
  ext s
  constructor
  ¬∑ rintro ‚ü®F, hF, rfl‚ü©
    refine ‚ü®(fun a => (Ici a)·∂ú) '' F, ‚ü®hF.image _, image_subset_iff.2 fun _ _ => ‚ü®_, rfl‚ü©‚ü©, ?_‚ü©
    simp only [sInter_image]
  ¬∑ rintro ‚ü®F, ‚ü®hF, hs‚ü©, rfl‚ü©
    haveI := hF.to_subtype
    rw [subset_def, Subtype.forall'] at hs
    choose f hf using hs
    exact ‚ü®_, finite_range f, by simp_rw [biInter_range, hf, sInter_eq_iInter]‚ü©

/-- A function `f : Œ≤ ‚Üí Œ±` with lower topology in the codomain is continuous
if and only if the preimage of every interval `Set.Ici a` is a closed set.
-/
lemma continuous_iff_Ici [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} :
    Continuous f ‚Üî ‚àÄ a, IsClosed (f ‚Åª¬π' (Ici a)) := by
  obtain rfl := IsLower.topology_eq Œ±
  simp [continuous_generateFrom_iff]

end Preorder

section PartialOrder

variable [PartialOrder Œ±] [TopologicalSpace Œ±] [IsLower Œ±]

-- see Note [lower instance priority]
/-- The lower topology on a partial order is T‚ÇÄ. -/
instance (priority := 90) t0Space : T0Space Œ± :=
  (t0Space_iff_inseparable Œ±).2 fun x y h =>
    Ici_injective <| by simpa only [inseparable_iff_closure_eq, closure_singleton] using h

end PartialOrder

section LinearOrder

variable [LinearOrder Œ±] [TopologicalSpace Œ±] [IsLower Œ±]

lemma isTopologicalBasis_insert_univ_subbasis :
    IsTopologicalBasis (insert univ {s : Set Œ± | ‚àÉ a, (Ici a)·∂ú = s}) :=
  isTopologicalBasis_of_subbasis_of_inter (by rw [topology_eq Œ±, lower]) (by
    rintro _ ‚ü®b, rfl‚ü© _ ‚ü®c, rfl‚ü©
    use b ‚äì c
    rw [compl_Ici, compl_Ici, compl_Ici, Iio_inter_Iio])

theorem tendsto_nhds_iff_lt {Œ≤ : Type*} {f : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} {x : Œ±} :
    Filter.Tendsto f l (ùìù x) ‚Üî ‚àÄ y, x < y ‚Üí ‚àÄ·∂† z in l, f z < y := by
  simp only [tendsto_nhds_iff_not_le, not_le]

end LinearOrder

section CompleteLinearOrder

variable [CompleteLinearOrder Œ±] [t : TopologicalSpace Œ±] [IsLower Œ±]

lemma isTopologicalSpace_basis (U : Set Œ±) : IsOpen U ‚Üî U = univ ‚à® ‚àÉ a, (Ici a)·∂ú = U := by
  by_cases hU : U = univ
  ¬∑ simp only [hU, isOpen_univ, compl_Ici, true_or]
  refine ‚ü®?_, isTopologicalBasis_insert_univ_subbasis.isOpen‚ü©
  intro hO
  apply Or.inr
  convert IsTopologicalBasis.open_eq_sUnion isTopologicalBasis_insert_univ_subbasis hO
  constructor
  ¬∑ intro ‚ü®a, ha‚ü©
    use {U}
    constructor
    ¬∑ apply subset_trans (singleton_subset_iff.mpr _) (subset_insert _ _)
      use a
    ¬∑ rw [sUnion_singleton]
  ¬∑ intro ‚ü®S, hS1, hS2‚ü©
    have hUS : univ ‚àâ S := by
      by_contra hUS'
      apply hU
      rw [hS2]
      exact sUnion_eq_univ_iff.mpr (fun a => ‚ü®univ, hUS', trivial‚ü©)
    use sSup {a | (Ici a)·∂ú ‚àà S}
    rw [hS2, sUnion_eq_compl_sInter_compl, compl_inj_iff]
    apply le_antisymm
    ¬∑ intro b hb
      simp only [sInter_image, mem_iInter, mem_compl_iff]
      intro s hs
      obtain ‚ü®a, ha‚ü© := (subset_insert_iff_of_notMem hUS).mp hS1 hs
      subst hS2 ha
      simp_all only [compl_Ici, mem_Ici, sSup_le_iff, mem_setOf_eq, mem_Iio, not_lt]
    ¬∑ intro b hb
      rw [mem_Ici, sSup_le_iff]
      intro c hc
      simp only [sInter_image, mem_iInter] at hb
      rw [‚Üê not_lt, ‚Üê mem_Iio, ‚Üê compl_Ici]
      exact hb _ hc

end CompleteLinearOrder

end IsLower


namespace IsUpper

/-- The complements of the lower closures of finite sets are a collection of upper sets
which form a basis for the upper topology. -/
def upperBasis (Œ± : Type*) [Preorder Œ±] :=
  { s : Set Œ± | ‚àÉ t : Set Œ±, t.Finite ‚àß (lowerClosure t : Set Œ±)·∂ú = s }

section Preorder

variable (Œ±)
variable [Preorder Œ±] [TopologicalSpace Œ±] [IsUpper Œ±] {s : Set Œ±}

lemma topology_eq : ‚Äπ_‚Ä∫ = upper Œ± := topology_eq_upperTopology

variable {Œ±}

/-- If `Œ±` is equipped with the upper topology, then it is homeomorphic to `WithUpper Œ±`.
-/
def withUpperHomeomorph : WithUpper Œ± ‚âÉ‚Çú Œ± :=
  WithUpper.ofUpper.toHomeomorphOfIsInducing ‚ü®topology_eq Œ± ‚ñ∏ induced_id.symm‚ü©

theorem isOpen_iff_generate_Iic_compl : IsOpen s ‚Üî GenerateOpen { t | ‚àÉ a, (Iic a)·∂ú = t } s := by
  rw [topology_eq Œ±]; rfl

instance _root_.OrderDual.instIsLower [Preorder Œ±] [TopologicalSpace Œ±] [IsUpper Œ±] :
    IsLower Œ±·µí·µà where
  topology_eq_lowerTopology := topology_eq_upperTopology (Œ± := Œ±)

/-- Left-infinite right-closed intervals (-‚àû,a] are closed in the upper topology. -/
instance : ClosedIicTopology Œ± :=
  ‚ü®fun a ‚Ü¶ isOpen_compl_iff.1 <| isOpen_iff_generate_Iic_compl.2 <| GenerateOpen.basic _ ‚ü®a, rfl‚ü©‚ü©

/-- The lower closure of a finite set is closed in the upper topology. -/
theorem isClosed_lowerClosure (h : s.Finite) : IsClosed (lowerClosure s : Set Œ±) :=
  IsLower.isClosed_upperClosure (Œ± := Œ±·µí·µà) h

/-- Every set open in the upper topology is a upper set. -/
theorem isUpperSet_of_isOpen (h : IsOpen s) : IsUpperSet s :=
  IsLower.isLowerSet_of_isOpen (Œ± := Œ±·µí·µà) h

theorem isLowerSet_of_isClosed (h : IsClosed s) : IsLowerSet s :=
  isUpperSet_compl.1 <| isUpperSet_of_isOpen h.isOpen_compl

theorem tendsto_nhds_iff_not_le {Œ≤ : Type*} {f : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} {x : Œ±} :
    Filter.Tendsto f l (ùìù x) ‚Üî ‚àÄ y, ¬¨x ‚â§ y ‚Üí ‚àÄ·∂† z in l, ¬¨f z ‚â§ y :=
  IsLower.tendsto_nhds_iff_not_le (Œ± := Œ±·µí·µà)

/--
The closure of a singleton `{a}` in the upper topology is the left-infinite right-closed interval
(-‚àû,a].
-/
@[simp]
theorem closure_singleton (a : Œ±) : closure {a} = Iic a :=
  IsLower.closure_singleton (Œ± := Œ±·µí·µà) _

protected theorem isTopologicalBasis : IsTopologicalBasis (upperBasis Œ±) :=
  IsLower.isTopologicalBasis (Œ± := Œ±·µí·µà)

/-- A function `f : Œ≤ ‚Üí Œ±` with upper topology in the codomain is continuous
if and only if the preimage of every interval `Set.Iic a` is a closed set. -/
lemma continuous_iff_Iic [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} :
    Continuous f ‚Üî ‚àÄ a, IsClosed (f ‚Åª¬π' (Iic a)) :=
  IsLower.continuous_iff_Ici (Œ± := Œ±·µí·µà)

end Preorder


section PartialOrder

variable [PartialOrder Œ±] [TopologicalSpace Œ±] [IsUpper Œ±]

-- see Note [lower instance priority]
/-- The upper topology on a partial order is T‚ÇÄ. -/
instance (priority := 90) t0Space : T0Space Œ± :=
  IsLower.t0Space (Œ± := Œ±·µí·µà)

end PartialOrder

section LinearOrder

variable [LinearOrder Œ±] [TopologicalSpace Œ±] [IsUpper Œ±]

lemma isTopologicalBasis_insert_univ_subbasis :
    IsTopologicalBasis (insert univ {s : Set Œ± | ‚àÉ a, (Iic a)·∂ú = s}) :=
  IsLower.isTopologicalBasis_insert_univ_subbasis (Œ± := Œ±·µí·µà)

theorem tendsto_nhds_iff_lt {Œ≤ : Type*} {f : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} {x : Œ±} :
    Filter.Tendsto f l (ùìù x) ‚Üî ‚àÄ y < x, ‚àÄ·∂† z in l, y < f z :=
  IsLower.tendsto_nhds_iff_lt (Œ± := Œ±·µí·µà)

end LinearOrder

section CompleteLinearOrder

variable [CompleteLinearOrder Œ±] [t : TopologicalSpace Œ±] [IsUpper Œ±]

lemma isTopologicalSpace_basis (U : Set Œ±) : IsOpen U ‚Üî U = univ ‚à® ‚àÉ a, (Iic a)·∂ú = U :=
  IsLower.isTopologicalSpace_basis (Œ± := Œ±·µí·µà) U

end CompleteLinearOrder

end IsUpper

instance instIsLowerProd [Preorder Œ±] [TopologicalSpace Œ±] [IsLower Œ±]
    [OrderBot Œ±] [Preorder Œ≤] [TopologicalSpace Œ≤] [IsLower Œ≤] [OrderBot Œ≤] :
    IsLower (Œ± √ó Œ≤) where
  topology_eq_lowerTopology := by
    refine le_antisymm (le_generateFrom ?_) ?_
    ¬∑ rintro _ ‚ü®x, rfl‚ü©
      exact (isClosed_Ici.prod isClosed_Ici).isOpen_compl
    rw [(IsLower.isTopologicalBasis.prod
      IsLower.isTopologicalBasis).eq_generateFrom, le_generateFrom_iff_subset_isOpen,
      image2_subset_iff]
    rintro _ ‚ü®s, hs, rfl‚ü© _ ‚ü®t, ht, rfl‚ü©
    dsimp
    simp_rw [coe_upperClosure, compl_iUnion, prod_eq, preimage_iInter, preimage_compl]
    -- without `let`, `refine` tries to use the product topology and fails
    let _ : TopologicalSpace (Œ± √ó Œ≤) := lower (Œ± √ó Œ≤)
    refine (hs.isOpen_biInter fun a _ => ?_).inter (ht.isOpen_biInter fun b _ => ?_)
    ¬∑ exact GenerateOpen.basic _ ‚ü®(a, ‚ä•), by simp [Ici_prod_eq, prod_univ]‚ü©
    ¬∑ exact GenerateOpen.basic _ ‚ü®(‚ä•, b), by simp [Ici_prod_eq, univ_prod]‚ü©

instance instIsUpperProd [Preorder Œ±] [TopologicalSpace Œ±] [IsUpper Œ±]
    [OrderTop Œ±] [Preorder Œ≤] [TopologicalSpace Œ≤] [IsUpper Œ≤] [OrderTop Œ≤] :
    IsUpper (Œ± √ó Œ≤) where
  topology_eq_upperTopology := by
    suffices IsLower (Œ± √ó Œ≤)·µí·µà from IsLower.topology_eq_lowerTopology (Œ± := (Œ± √ó Œ≤)·µí·µà)
    exact instIsLowerProd (Œ± := Œ±·µí·µà) (Œ≤ := Œ≤·µí·µà)

section CompleteLattice_IsLower

variable [CompleteLattice Œ±] [CompleteLattice Œ≤] [TopologicalSpace Œ±] [IsLower Œ±]
  [TopologicalSpace Œ≤] [IsLower Œ≤]

protected lemma _root_.sInfHom.continuous (f : sInfHom Œ± Œ≤) : Continuous f := by
  refine IsLower.continuous_iff_Ici.2 fun b => ?_
  convert isClosed_Ici (a := sInf <| f ‚Åª¬π' Ici b)
  refine Subset.antisymm (fun a => sInf_le) fun a ha => le_trans ?_ <|
    OrderHomClass.mono (f : Œ± ‚Üío Œ≤) ha
  refine LE.le.trans ?_ (map_sInf f _).ge
  simp

-- see Note [lower instance priority]
instance (priority := 90) IsLower.toContinuousInf : ContinuousInf Œ± :=
  ‚ü®(infsInfHom : sInfHom (Œ± √ó Œ±) Œ±).continuous‚ü©

end CompleteLattice_IsLower

section CompleteLattice_IsUpper

variable [CompleteLattice Œ±] [CompleteLattice Œ≤] [TopologicalSpace Œ±] [IsUpper Œ±]
  [TopologicalSpace Œ≤] [IsUpper Œ≤]

protected lemma _root_.sSupHom.continuous (f : sSupHom Œ± Œ≤) : Continuous f :=
  sInfHom.continuous (Œ± := Œ±·µí·µà) (Œ≤ := Œ≤·µí·µà) (sSupHom.dual.toFun f)

-- see Note [lower instance priority]
instance (priority := 90) IsUpper.toContinuousInf : ContinuousSup Œ± :=
  ‚ü®(supsSupHom : sSupHom (Œ± √ó Œ±) Œ±).continuous‚ü©

end CompleteLattice_IsUpper

lemma isUpper_orderDual [Preorder Œ±] [TopologicalSpace Œ±] : IsUpper Œ±·µí·µà ‚Üî IsLower Œ± := by
  constructor
  ¬∑ apply OrderDual.instIsLower
  ¬∑ apply OrderDual.instIsUpper

lemma isLower_orderDual [Preorder Œ±] [TopologicalSpace Œ±] : IsLower Œ±·µí·µà ‚Üî IsUpper Œ± :=
  isUpper_orderDual.symm

end Topology

/-- The Sierpi≈Ñski topology on `Prop` is the upper topology -/
instance : IsUpper Prop where
  topology_eq_upperTopology := by
    rw [Topology.upper, sierpinskiSpace, ‚Üê generateFrom_insert_empty]
    congr
    exact le_antisymm
      (fun h hs => by
        simp only [compl_Iic, mem_setOf_eq]
        rw [‚Üê Ioi_True, ‚Üê Ioi_False] at hs
        rcases hs with (rfl | rfl)
        ¬∑ use True
        ¬∑ use False)
      (by rintro _ ‚ü®a, rfl‚ü©; by_cases a <;> aesop (add simp [Ioi, lt_iff_le_not_ge]))
