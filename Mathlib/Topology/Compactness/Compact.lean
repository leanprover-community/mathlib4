/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro, Yury Kudryashov
-/
import Mathlib.Topology.Bases
import Mathlib.Data.Set.Accumulate
import Mathlib.Topology.Bornology.Basic
import Mathlib.Topology.LocallyFinite
/-!
# Compact sets and compact spaces

## Main definitions

We define the following properties for sets in a topological space:

* `IsCompact`: a set such that each open cover has a finite subcover. This is defined in mathlib
  using filters. The main property of a compact set is `IsCompact.elim_finite_subcover`.
* `CompactSpace`: typeclass stating that the whole space is a compact set.
* `NoncompactSpace`: a space that is not a compact space.

## Main results

* `isCompact_univ_pi`: **Tychonov's theorem** - an arbitrary product of compact sets
  is compact.
-/
open Set Filter Topology TopologicalSpace Classical

universe u v

variable {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type*} {œÄ : Œπ ‚Üí Type*}

variable [TopologicalSpace Œ±] [TopologicalSpace Œ≤] {s t : Set Œ±}

-- compact sets
section Compact

/-- A set `s` is compact if for every nontrivial filter `f` that contains `s`,
    there exists `a ‚àà s` such that every set of `f` meets every neighborhood of `a`. -/
def IsCompact (s : Set Œ±) :=
  ‚àÄ ‚¶Éf‚¶Ñ [NeBot f], f ‚â§ ùìü s ‚Üí ‚àÉ a ‚àà s, ClusterPt a f
#align is_compact IsCompact

/-- The complement to a compact set belongs to a filter `f` if it belongs to each filter
`ùìù a ‚äì f`, `a ‚àà s`. -/
theorem IsCompact.compl_mem_sets (hs : IsCompact s) {f : Filter Œ±} (hf : ‚àÄ a ‚àà s, s·∂ú ‚àà ùìù a ‚äì f) :
    s·∂ú ‚àà f := by
  contrapose! hf
  simp only [not_mem_iff_inf_principal_compl, compl_compl, inf_assoc] at hf ‚ä¢
  exact @hs _ hf inf_le_right
#align is_compact.compl_mem_sets IsCompact.compl_mem_sets

/-- The complement to a compact set belongs to a filter `f` if each `a ‚àà s` has a neighborhood `t`
within `s` such that `t·∂ú` belongs to `f`. -/
theorem IsCompact.compl_mem_sets_of_nhdsWithin (hs : IsCompact s) {f : Filter Œ±}
    (hf : ‚àÄ a ‚àà s, ‚àÉ t ‚àà ùìù[s] a, t·∂ú ‚àà f) : s·∂ú ‚àà f := by
  refine' hs.compl_mem_sets fun a ha => _
  rcases hf a ha with ‚ü®t, ht, hst‚ü©
  replace ht := mem_inf_principal.1 ht
  apply mem_inf_of_inter ht hst
  rintro x ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© hs
  exact h‚ÇÇ (h‚ÇÅ hs)
#align is_compact.compl_mem_sets_of_nhds_within IsCompact.compl_mem_sets_of_nhdsWithin

/-- If `p : Set Œ± ‚Üí Prop` is stable under restriction and union, and each point `x`
  of a compact set `s` has a neighborhood `t` within `s` such that `p t`, then `p s` holds. -/
@[elab_as_elim]
theorem IsCompact.induction_on {s : Set Œ±} (hs : IsCompact s) {p : Set Œ± ‚Üí Prop} (he : p ‚àÖ)
    (hmono : ‚àÄ ‚¶És t‚¶Ñ, s ‚äÜ t ‚Üí p t ‚Üí p s) (hunion : ‚àÄ ‚¶És t‚¶Ñ, p s ‚Üí p t ‚Üí p (s ‚à™ t))
    (hnhds : ‚àÄ x ‚àà s, ‚àÉ t ‚àà ùìù[s] x, p t) : p s := by
  let f : Filter Œ± :=
    { sets := { t | p t·∂ú }
      univ_sets := by simpa
      sets_of_superset := fun ht‚ÇÅ ht => hmono (compl_subset_compl.2 ht) ht‚ÇÅ
      inter_sets := fun ht‚ÇÅ ht‚ÇÇ => by simp [compl_inter, hunion ht‚ÇÅ ht‚ÇÇ] }
  have : s·∂ú ‚àà f := hs.compl_mem_sets_of_nhdsWithin (by simpa using hnhds)
  rwa [‚Üê compl_compl s]
#align is_compact.induction_on IsCompact.induction_on

/-- The intersection of a compact set and a closed set is a compact set. -/
theorem IsCompact.inter_right (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s ‚à© t) := by
  intro f hnf hstf
  obtain ‚ü®a, hsa, ha‚ü© : ‚àÉ a ‚àà s, ClusterPt a f :=
    hs (le_trans hstf (le_principal_iff.2 (inter_subset_left _ _)))
  have : a ‚àà t := ht.mem_of_nhdsWithin_neBot <|
    ha.mono <| le_trans hstf (le_principal_iff.2 (inter_subset_right _ _))
  exact ‚ü®a, ‚ü®hsa, this‚ü©, ha‚ü©
#align is_compact.inter_right IsCompact.inter_right

/-- The intersection of a closed set and a compact set is a compact set. -/
theorem IsCompact.inter_left (ht : IsCompact t) (hs : IsClosed s) : IsCompact (s ‚à© t) :=
  inter_comm t s ‚ñ∏ ht.inter_right hs
#align is_compact.inter_left IsCompact.inter_left

/-- The set difference of a compact set and an open set is a compact set. -/
theorem IsCompact.diff (hs : IsCompact s) (ht : IsOpen t) : IsCompact (s \ t) :=
  hs.inter_right (isClosed_compl_iff.mpr ht)
#align is_compact.diff IsCompact.diff

/-- A closed subset of a compact set is a compact set. -/
theorem IsCompact.of_isClosed_subset (hs : IsCompact s) (ht : IsClosed t) (h : t ‚äÜ s) :
    IsCompact t :=
  inter_eq_self_of_subset_right h ‚ñ∏ hs.inter_right ht
#align is_compact_of_is_closed_subset IsCompact.of_isClosed_subset

theorem IsCompact.image_of_continuousOn {f : Œ± ‚Üí Œ≤} (hs : IsCompact s) (hf : ContinuousOn f s) :
    IsCompact (f '' s) := by
  intro l lne ls
  have : NeBot (l.comap f ‚äì ùìü s) :=
    comap_inf_principal_neBot_of_image_mem lne (le_principal_iff.1 ls)
  obtain ‚ü®a, has, ha‚ü© : ‚àÉ a ‚àà s, ClusterPt a (l.comap f ‚äì ùìü s) := @hs _ this inf_le_right
  haveI := ha.neBot
  use f a, mem_image_of_mem f has
  have : Tendsto f (ùìù a ‚äì (comap f l ‚äì ùìü s)) (ùìù (f a) ‚äì l) := by
    convert (hf a has).inf (@tendsto_comap _ _ f l) using 1
    rw [nhdsWithin]
    ac_rfl
  exact this.neBot
#align is_compact.image_of_continuous_on IsCompact.image_of_continuousOn

theorem IsCompact.image {f : Œ± ‚Üí Œ≤} (hs : IsCompact s) (hf : Continuous f) : IsCompact (f '' s) :=
  hs.image_of_continuousOn hf.continuousOn
#align is_compact.image IsCompact.image

theorem IsCompact.adherence_nhdset {f : Filter Œ±} (hs : IsCompact s) (hf‚ÇÇ : f ‚â§ ùìü s)
    (ht‚ÇÅ : IsOpen t) (ht‚ÇÇ : ‚àÄ a ‚àà s, ClusterPt a f ‚Üí a ‚àà t) : t ‚àà f :=
  Classical.by_cases mem_of_eq_bot fun (this : f ‚äì ùìü t·∂ú ‚â† ‚ä•) =>
    let ‚ü®a, ha, (hfa : ClusterPt a <| f ‚äì ùìü t·∂ú)‚ü© := @hs _ ‚ü®this‚ü© <| inf_le_of_left_le hf‚ÇÇ
    have : a ‚àà t := ht‚ÇÇ a ha hfa.of_inf_left
    have : t·∂ú ‚à© t ‚àà ùìù[t·∂ú] a := inter_mem_nhdsWithin _ (IsOpen.mem_nhds ht‚ÇÅ this)
    have A : ùìù[t·∂ú] a = ‚ä• := empty_mem_iff_bot.1 <| compl_inter_self t ‚ñ∏ this
    have : ùìù[t·∂ú] a ‚â† ‚ä• := hfa.of_inf_right.ne
    absurd A this
#align is_compact.adherence_nhdset IsCompact.adherence_nhdset

theorem isCompact_iff_ultrafilter_le_nhds :
    IsCompact s ‚Üî ‚àÄ f : Ultrafilter Œ±, ‚Üëf ‚â§ ùìü s ‚Üí ‚àÉ a ‚àà s, ‚Üëf ‚â§ ùìù a := by
  refine' (forall_neBot_le_iff _).trans _
  ¬∑ rintro f g hle ‚ü®a, has, haf‚ü©
    exact ‚ü®a, has, haf.mono hle‚ü©
  ¬∑ simp only [Ultrafilter.clusterPt_iff]
#align is_compact_iff_ultrafilter_le_nhds isCompact_iff_ultrafilter_le_nhds

alias ‚ü®IsCompact.ultrafilter_le_nhds, _‚ü© := isCompact_iff_ultrafilter_le_nhds
#align is_compact.ultrafilter_le_nhds IsCompact.ultrafilter_le_nhds

theorem isCompact_iff_ultrafilter_le_nhds' :
    IsCompact s ‚Üî ‚àÄ f : Ultrafilter Œ±, s ‚àà f ‚Üí ‚àÉ a ‚àà s, ‚Üëf ‚â§ ùìù a := by
  simp only [isCompact_iff_ultrafilter_le_nhds, le_principal_iff, Ultrafilter.mem_coe]

alias ‚ü®IsCompact.ultrafilter_le_nhds', _‚ü© := isCompact_iff_ultrafilter_le_nhds'

/-- If a compact set belongs to a filter and this filter has a unique cluster point `y` in this set,
then the filter is less than or equal to `ùìù y`. -/
lemma IsCompact.le_nhds_of_unique_clusterPt (hs : IsCompact s) {l : Filter Œ±} {y : Œ±}
    (hmem : s ‚àà l) (h : ‚àÄ x ‚àà s, ClusterPt x l ‚Üí x = y) : l ‚â§ ùìù y := by
  refine le_iff_ultrafilter.2 fun f hf ‚Ü¶ ?_
  rcases hs.ultrafilter_le_nhds' f (hf hmem) with ‚ü®x, hxs, hx‚ü©
  convert ‚Üê hx
  exact h x hxs (.mono (.of_le_nhds hx) hf)

/-- If values of `f : Œ≤ ‚Üí Œ±` belong to a compact set `s` eventually along a filter `l`
and `y` is a unique `MapClusterPt` for `f` along `l` in `s`,
then `f` tends to `ùìù y` along `l`. -/
lemma IsCompact.tendsto_nhds_of_unique_mapClusterPt {l : Filter Œ≤} {y : Œ±} {f : Œ≤ ‚Üí Œ±}
    (hs : IsCompact s) (hmem : ‚àÄ·∂† x in l, f x ‚àà s) (h : ‚àÄ x ‚àà s, MapClusterPt x l f ‚Üí x = y) :
    Tendsto f l (ùìù y) :=
  hs.le_nhds_of_unique_clusterPt (mem_map.2 hmem) h

/-- For every open directed cover of a compact set, there exists a single element of the
cover which itself includes the set. -/
theorem IsCompact.elim_directed_cover {Œπ : Type v} [hŒπ : Nonempty Œπ] (hs : IsCompact s)
    (U : Œπ ‚Üí Set Œ±) (hUo : ‚àÄ i, IsOpen (U i)) (hsU : s ‚äÜ ‚ãÉ i, U i) (hdU : Directed (¬∑ ‚äÜ ¬∑) U) :
    ‚àÉ i, s ‚äÜ U i :=
  hŒπ.elim fun i‚ÇÄ =>
    IsCompact.induction_on hs ‚ü®i‚ÇÄ, empty_subset _‚ü© (fun _ _ hs ‚ü®i, hi‚ü© => ‚ü®i, hs.trans hi‚ü©)
      (fun _ _ ‚ü®i, hi‚ü© ‚ü®j, hj‚ü© =>
        let ‚ü®k, hki, hkj‚ü© := hdU i j
        ‚ü®k, union_subset (Subset.trans hi hki) (Subset.trans hj hkj)‚ü©)
      fun _x hx =>
      let ‚ü®i, hi‚ü© := mem_iUnion.1 (hsU hx)
      ‚ü®U i, mem_nhdsWithin_of_mem_nhds (IsOpen.mem_nhds (hUo i) hi), i, Subset.refl _‚ü©
#align is_compact.elim_directed_cover IsCompact.elim_directed_cover

/-- For every open cover of a compact set, there exists a finite subcover. -/
theorem IsCompact.elim_finite_subcover {Œπ : Type v} (hs : IsCompact s) (U : Œπ ‚Üí Set Œ±)
    (hUo : ‚àÄ i, IsOpen (U i)) (hsU : s ‚äÜ ‚ãÉ i, U i) : ‚àÉ t : Finset Œπ, s ‚äÜ ‚ãÉ i ‚àà t, U i :=
  hs.elim_directed_cover _ (fun _ => isOpen_biUnion fun i _ => hUo i)
    (iUnion_eq_iUnion_finset U ‚ñ∏ hsU)
    (directed_of_isDirected_le fun _ _ h => biUnion_subset_biUnion_left h)
#align is_compact.elim_finite_subcover IsCompact.elim_finite_subcover

theorem IsCompact.elim_nhds_subcover' (hs : IsCompact s) (U : ‚àÄ x ‚àà s, Set Œ±)
    (hU : ‚àÄ x (hx : x ‚àà s), U x ‚Äπx ‚àà s‚Ä∫ ‚àà ùìù x) : ‚àÉ t : Finset s, s ‚äÜ ‚ãÉ x ‚àà t, U (x : s) x.2 :=
  (hs.elim_finite_subcover (fun x : s => interior (U x x.2)) (fun _ => isOpen_interior) fun x hx =>
        mem_iUnion.2 ‚ü®‚ü®x, hx‚ü©, mem_interior_iff_mem_nhds.2 <| hU _ _‚ü©).imp
    fun _t ht => ht.trans <| iUnion‚ÇÇ_mono fun _ _ => interior_subset
#align is_compact.elim_nhds_subcover' IsCompact.elim_nhds_subcover'

theorem IsCompact.elim_nhds_subcover (hs : IsCompact s) (U : Œ± ‚Üí Set Œ±) (hU : ‚àÄ x ‚àà s, U x ‚àà ùìù x) :
    ‚àÉ t : Finset Œ±, (‚àÄ x ‚àà t, x ‚àà s) ‚àß s ‚äÜ ‚ãÉ x ‚àà t, U x :=
  let ‚ü®t, ht‚ü© := hs.elim_nhds_subcover' (fun x _ => U x) hU
  ‚ü®t.image (‚Üë), fun x hx =>
    let ‚ü®y, _, hyx‚ü© := Finset.mem_image.1 hx
    hyx ‚ñ∏ y.2,
    by rwa [Finset.set_biUnion_finset_image]‚ü©
#align is_compact.elim_nhds_subcover IsCompact.elim_nhds_subcover

/-- The neighborhood filter of a compact set is disjoint with a filter `l` if and only if the
neighborhood filter of each point of this set is disjoint with `l`. -/
theorem IsCompact.disjoint_nhdsSet_left {l : Filter Œ±} (hs : IsCompact s) :
    Disjoint (ùìùÀ¢ s) l ‚Üî ‚àÄ x ‚àà s, Disjoint (ùìù x) l := by
  refine' ‚ü®fun h x hx => h.mono_left <| nhds_le_nhdsSet hx, fun H => _‚ü©
  choose! U hxU hUl using fun x hx => (nhds_basis_opens x).disjoint_iff_left.1 (H x hx)
  choose hxU hUo using hxU
  rcases hs.elim_nhds_subcover U fun x hx => (hUo x hx).mem_nhds (hxU x hx) with ‚ü®t, hts, hst‚ü©
  refine (hasBasis_nhdsSet _).disjoint_iff_left.2
    ‚ü®‚ãÉ x ‚àà t, U x, ‚ü®isOpen_biUnion fun x hx => hUo x (hts x hx), hst‚ü©, ?_‚ü©
  rw [compl_iUnion‚ÇÇ, biInter_finset_mem]
  exact fun x hx => hUl x (hts x hx)
#align is_compact.disjoint_nhds_set_left IsCompact.disjoint_nhdsSet_left

/-- A filter `l` is disjoint with the neighborhood filter of a compact set if and only if it is
disjoint with the neighborhood filter of each point of this set. -/
theorem IsCompact.disjoint_nhdsSet_right {l : Filter Œ±} (hs : IsCompact s) :
    Disjoint l (ùìùÀ¢ s) ‚Üî ‚àÄ x ‚àà s, Disjoint l (ùìù x) := by
  simpa only [disjoint_comm] using hs.disjoint_nhdsSet_left
#align is_compact.disjoint_nhds_set_right IsCompact.disjoint_nhdsSet_right

-- porting note: todo: reformulate using `Disjoint`
/-- For every directed family of closed sets whose intersection avoids a compact set,
there exists a single element of the family which itself avoids this compact set. -/
theorem IsCompact.elim_directed_family_closed {Œπ : Type v} [hŒπ : Nonempty Œπ] (hs : IsCompact s)
    (Z : Œπ ‚Üí Set Œ±) (hZc : ‚àÄ i, IsClosed (Z i)) (hsZ : (s ‚à© ‚ãÇ i, Z i) = ‚àÖ)
    (hdZ : Directed (¬∑ ‚äá ¬∑) Z) : ‚àÉ i : Œπ, s ‚à© Z i = ‚àÖ :=
  let ‚ü®t, ht‚ü© :=
    hs.elim_directed_cover (compl ‚àò Z) (fun i => (hZc i).isOpen_compl)
      (by
        simpa only [subset_def, not_forall, eq_empty_iff_forall_not_mem, mem_iUnion, exists_prop,
          mem_inter_iff, not_and, iff_self_iff, mem_iInter, mem_compl_iff] using hsZ)
      (hdZ.mono_comp _ fun _ _ => compl_subset_compl.mpr)
  ‚ü®t, by
    simpa only [subset_def, not_forall, eq_empty_iff_forall_not_mem, mem_iUnion, exists_prop,
      mem_inter_iff, not_and, iff_self_iff, mem_iInter, mem_compl_iff] using ht‚ü©
#align is_compact.elim_directed_family_closed IsCompact.elim_directed_family_closed

-- porting note: todo: reformulate using `Disjoint`
/-- For every family of closed sets whose intersection avoids a compact set,
there exists a finite subfamily whose intersection avoids this compact set. -/
theorem IsCompact.elim_finite_subfamily_closed {s : Set Œ±} {Œπ : Type v} (hs : IsCompact s)
    (Z : Œπ ‚Üí Set Œ±) (hZc : ‚àÄ i, IsClosed (Z i)) (hsZ : (s ‚à© ‚ãÇ i, Z i) = ‚àÖ) :
    ‚àÉ t : Finset Œπ, (s ‚à© ‚ãÇ i ‚àà t, Z i) = ‚àÖ :=
  hs.elim_directed_family_closed _ (fun t ‚Ü¶ isClosed_biInter fun _ _ ‚Ü¶ hZc _)
    (by rwa [‚Üê iInter_eq_iInter_finset])
    (directed_of_isDirected_le fun _ _ h ‚Ü¶ biInter_subset_biInter_left h)
#align is_compact.elim_finite_subfamily_closed IsCompact.elim_finite_subfamily_closed

/-- If `s` is a compact set in a topological space `Œ±` and `f : Œπ ‚Üí Set Œ±` is a locally finite
family of sets, then `f i ‚à© s` is nonempty only for a finitely many `i`. -/
theorem LocallyFinite.finite_nonempty_inter_compact {Œπ : Type*} {f : Œπ ‚Üí Set Œ±}
    (hf : LocallyFinite f) {s : Set Œ±} (hs : IsCompact s) : { i | (f i ‚à© s).Nonempty }.Finite := by
  choose U hxU hUf using hf
  rcases hs.elim_nhds_subcover U fun x _ => hxU x with ‚ü®t, -, hsU‚ü©
  refine' (t.finite_toSet.biUnion fun x _ => hUf x).subset _
  rintro i ‚ü®x, hx‚ü©
  rcases mem_iUnion‚ÇÇ.1 (hsU hx.2) with ‚ü®c, hct, hcx‚ü©
  exact mem_biUnion hct ‚ü®x, hx.1, hcx‚ü©
#align locally_finite.finite_nonempty_inter_compact LocallyFinite.finite_nonempty_inter_compact

/-- To show that a compact set intersects the intersection of a family of closed sets,
  it is sufficient to show that it intersects every finite subfamily. -/
theorem IsCompact.inter_iInter_nonempty {s : Set Œ±} {Œπ : Type v} (hs : IsCompact s) (Z : Œπ ‚Üí Set Œ±)
    (hZc : ‚àÄ i, IsClosed (Z i)) (hsZ : ‚àÄ t : Finset Œπ, (s ‚à© ‚ãÇ i ‚àà t, Z i).Nonempty) :
    (s ‚à© ‚ãÇ i, Z i).Nonempty := by
  contrapose! hsZ
  exact hs.elim_finite_subfamily_closed Z hZc hsZ
#align is_compact.inter_Inter_nonempty IsCompact.inter_iInter_nonempty

/-- Cantor's intersection theorem:
the intersection of a directed family of nonempty compact closed sets is nonempty. -/
theorem IsCompact.nonempty_iInter_of_directed_nonempty_compact_closed {Œπ : Type v} [hŒπ : Nonempty Œπ]
    (Z : Œπ ‚Üí Set Œ±) (hZd : Directed (¬∑ ‚äá ¬∑) Z) (hZn : ‚àÄ i, (Z i).Nonempty)
    (hZc : ‚àÄ i, IsCompact (Z i)) (hZcl : ‚àÄ i, IsClosed (Z i)) : (‚ãÇ i, Z i).Nonempty := by
  let i‚ÇÄ := hŒπ.some
  suffices (Z i‚ÇÄ ‚à© ‚ãÇ i, Z i).Nonempty by
    rwa [inter_eq_right.mpr (iInter_subset _ i‚ÇÄ)] at this
  simp only [nonempty_iff_ne_empty] at hZn ‚ä¢
  apply mt ((hZc i‚ÇÄ).elim_directed_family_closed Z hZcl)
  push_neg
  simp only [‚Üê nonempty_iff_ne_empty] at hZn ‚ä¢
  refine' ‚ü®hZd, fun i => _‚ü©
  rcases hZd i‚ÇÄ i with ‚ü®j, hji‚ÇÄ, hji‚ü©
  exact (hZn j).mono (subset_inter hji‚ÇÄ hji)
#align is_compact.nonempty_Inter_of_directed_nonempty_compact_closed IsCompact.nonempty_iInter_of_directed_nonempty_compact_closed

/-- Cantor's intersection theorem for sequences indexed by `‚Ñï`:
the intersection of a decreasing sequence of nonempty compact closed sets is nonempty. -/
theorem IsCompact.nonempty_iInter_of_sequence_nonempty_compact_closed (Z : ‚Ñï ‚Üí Set Œ±)
    (hZd : ‚àÄ i, Z (i + 1) ‚äÜ Z i) (hZn : ‚àÄ i, (Z i).Nonempty) (hZ0 : IsCompact (Z 0))
    (hZcl : ‚àÄ i, IsClosed (Z i)) : (‚ãÇ i, Z i).Nonempty :=
  have Zmono : Antitone Z := antitone_nat_of_succ_le hZd
  have hZd : Directed (¬∑ ‚äá ¬∑) Z := Zmono.directed_ge
  have : ‚àÄ i, Z i ‚äÜ Z 0 := fun i => Zmono <| zero_le i
  have hZc : ‚àÄ i, IsCompact (Z i) := fun i => hZ0.of_isClosed_subset (hZcl i) (this i)
  IsCompact.nonempty_iInter_of_directed_nonempty_compact_closed Z hZd hZn hZc hZcl
#align is_compact.nonempty_Inter_of_sequence_nonempty_compact_closed IsCompact.nonempty_iInter_of_sequence_nonempty_compact_closed

/-- For every open cover of a compact set, there exists a finite subcover. -/
theorem IsCompact.elim_finite_subcover_image {b : Set Œπ} {c : Œπ ‚Üí Set Œ±} (hs : IsCompact s)
    (hc‚ÇÅ : ‚àÄ i ‚àà b, IsOpen (c i)) (hc‚ÇÇ : s ‚äÜ ‚ãÉ i ‚àà b, c i) :
    ‚àÉ b', b' ‚äÜ b ‚àß Set.Finite b' ‚àß s ‚äÜ ‚ãÉ i ‚àà b', c i := by
  simp only [Subtype.forall', biUnion_eq_iUnion] at hc‚ÇÅ hc‚ÇÇ
  rcases hs.elim_finite_subcover (fun i => c i : b ‚Üí Set Œ±) hc‚ÇÅ hc‚ÇÇ with ‚ü®d, hd‚ü©
  refine' ‚ü®Subtype.val '' d.toSet, _, d.finite_toSet.image _, _‚ü©
  ¬∑ simp
  ¬∑ rwa [biUnion_image]
#align is_compact.elim_finite_subcover_image IsCompact.elim_finite_subcover_image‚Çì

/-- A set `s` is compact if for every open cover of `s`, there exists a finite subcover. -/
theorem isCompact_of_finite_subcover
    (h : ‚àÄ {Œπ : Type u} (U : Œπ ‚Üí Set Œ±), (‚àÄ i, IsOpen (U i)) ‚Üí (s ‚äÜ ‚ãÉ i, U i) ‚Üí
      ‚àÉ t : Finset Œπ, s ‚äÜ ‚ãÉ i ‚àà t, U i) :
    IsCompact s := fun f hf hfs => by
  contrapose! h
  simp only [ClusterPt, not_neBot, ‚Üê disjoint_iff, SetCoe.forall',
    (nhds_basis_opens _).disjoint_iff_left] at h
  choose U hU hUf using h
  refine ‚ü®s, U, fun x => (hU x).2, fun x hx => mem_iUnion.2 ‚ü®‚ü®x, hx‚ü©, (hU _).1‚ü©, fun t ht => ?_‚ü©
  refine compl_not_mem (le_principal_iff.1 hfs) ?_
  refine mem_of_superset ((biInter_finset_mem t).2 fun x _ => hUf x) ?_
  rw [subset_compl_comm, compl_iInter‚ÇÇ]
  simpa only [compl_compl]
#align is_compact_of_finite_subcover isCompact_of_finite_subcover

-- porting note: todo: reformulate using `Disjoint`
/-- A set `s` is compact if for every family of closed sets whose intersection avoids `s`,
there exists a finite subfamily whose intersection avoids `s`. -/
theorem isCompact_of_finite_subfamily_closed
    (h : ‚àÄ {Œπ : Type u} (Z : Œπ ‚Üí Set Œ±), (‚àÄ i, IsClosed (Z i)) ‚Üí (s ‚à© ‚ãÇ i, Z i) = ‚àÖ ‚Üí
      ‚àÉ t : Finset Œπ, (s ‚à© ‚ãÇ i ‚àà t, Z i) = ‚àÖ) :
    IsCompact s :=
  isCompact_of_finite_subcover fun U hUo hsU => by
    rw [‚Üê disjoint_compl_right_iff_subset, compl_iUnion, disjoint_iff] at hsU
    rcases h (fun i => (U i)·∂ú) (fun i => (hUo _).isClosed_compl) hsU with ‚ü®t, ht‚ü©
    refine ‚ü®t, ?_‚ü©
    rwa [‚Üê disjoint_compl_right_iff_subset, compl_iUnion‚ÇÇ, disjoint_iff]
#align is_compact_of_finite_subfamily_closed isCompact_of_finite_subfamily_closed

/-- A set `s` is compact if and only if
for every open cover of `s`, there exists a finite subcover. -/
theorem isCompact_iff_finite_subcover :
    IsCompact s ‚Üî ‚àÄ {Œπ : Type u} (U : Œπ ‚Üí Set Œ±),
      (‚àÄ i, IsOpen (U i)) ‚Üí (s ‚äÜ ‚ãÉ i, U i) ‚Üí ‚àÉ t : Finset Œπ, s ‚äÜ ‚ãÉ i ‚àà t, U i :=
  ‚ü®fun hs => hs.elim_finite_subcover, isCompact_of_finite_subcover‚ü©
#align is_compact_iff_finite_subcover isCompact_iff_finite_subcover

/-- A set `s` is compact if and only if
for every family of closed sets whose intersection avoids `s`,
there exists a finite subfamily whose intersection avoids `s`. -/
theorem isCompact_iff_finite_subfamily_closed :
    IsCompact s ‚Üî ‚àÄ {Œπ : Type u} (Z : Œπ ‚Üí Set Œ±),
      (‚àÄ i, IsClosed (Z i)) ‚Üí (s ‚à© ‚ãÇ i, Z i) = ‚àÖ ‚Üí ‚àÉ t : Finset Œπ, (s ‚à© ‚ãÇ i ‚àà t, Z i) = ‚àÖ :=
  ‚ü®fun hs => hs.elim_finite_subfamily_closed, isCompact_of_finite_subfamily_closed‚ü©
#align is_compact_iff_finite_subfamily_closed isCompact_iff_finite_subfamily_closed

/-- If `s : Set (Œ± √ó Œ≤)` belongs to `ùìù x √óÀ¢ l` for all `x` from a compact set `K`,
then it belongs to `(ùìùÀ¢ K) √óÀ¢ l`,
i.e., there exist an open `U ‚äá K` and `t ‚àà l` such that `U √óÀ¢ t ‚äÜ s`. -/
theorem IsCompact.mem_nhdsSet_prod_of_forall {K : Set Œ±} {l : Filter Œ≤} {s : Set (Œ± √ó Œ≤)}
    (hK : IsCompact K) (hs : ‚àÄ x ‚àà K, s ‚àà ùìù x √óÀ¢ l) : s ‚àà (ùìùÀ¢ K) √óÀ¢ l := by
  refine hK.induction_on (by simp) (fun t t' ht hs ‚Ü¶ ?_) (fun t t' ht ht' ‚Ü¶ ?_) fun x hx ‚Ü¶ ?_
  ¬∑ exact prod_mono (nhdsSet_mono ht) le_rfl hs
  ¬∑ simp [sup_prod, *]
  ¬∑ rcases ((nhds_basis_opens _).prod l.basis_sets).mem_iff.1 (hs x hx)
      with ‚ü®‚ü®u, v‚ü©, ‚ü®‚ü®hx, huo‚ü©, hv‚ü©, hs‚ü©
    refine ‚ü®u, nhdsWithin_le_nhds (huo.mem_nhds hx), mem_of_superset ?_ hs‚ü©
    exact prod_mem_prod (huo.mem_nhdsSet.2 Subset.rfl) hv

theorem IsCompact.nhdsSet_prod_eq_biSup {K : Set Œ±} (hK : IsCompact K) (l : Filter Œ≤) :
    (ùìùÀ¢ K) √óÀ¢ l = ‚®Ü x ‚àà K, ùìù x √óÀ¢ l :=
  le_antisymm (fun s hs ‚Ü¶ hK.mem_nhdsSet_prod_of_forall <| by simpa using hs)
    (iSup‚ÇÇ_le fun x hx ‚Ü¶ prod_mono (nhds_le_nhdsSet hx) le_rfl)

theorem IsCompact.prod_nhdsSet_eq_biSup {K : Set Œ≤} (hK : IsCompact K) (l : Filter Œ±) :
    l √óÀ¢ (ùìùÀ¢ K) = ‚®Ü y ‚àà K, l √óÀ¢ ùìù y := by
  simp only [prod_comm (f := l), hK.nhdsSet_prod_eq_biSup, map_iSup]

/-- If `s : Set (Œ± √ó Œ≤)` belongs to `l √óÀ¢ ùìù y` for all `y` from a compact set `K`,
then it belongs to `l √óÀ¢ (ùìùÀ¢ K)`,
i.e., there exist `t ‚àà l` and an open `U ‚äá K` such that `t √óÀ¢ U ‚äÜ s`. -/
theorem IsCompact.mem_prod_nhdsSet_of_forall {K : Set Œ≤} {l : Filter Œ±} {s : Set (Œ± √ó Œ≤)}
    (hK : IsCompact K) (hs : ‚àÄ y ‚àà K, s ‚àà l √óÀ¢ ùìù y) : s ‚àà l √óÀ¢ ùìùÀ¢ K :=
  (hK.prod_nhdsSet_eq_biSup l).symm ‚ñ∏ by simpa using hs

/-- To show that `‚àÄ y ‚àà K, P x y` holds for `x` close enough to `x‚ÇÄ` when `K` is compact,
it is sufficient to show that for all `y‚ÇÄ ‚àà K` there `P x y` holds for `(x, y)` close enough
to `(x‚ÇÄ, y‚ÇÄ)`.

Provided for backwards compatibility,
see `IsCompact.mem_prod_nhdsSet_of_forall` for a stronger statement.
-/
theorem IsCompact.eventually_forall_of_forall_eventually {x‚ÇÄ : Œ±} {K : Set Œ≤} (hK : IsCompact K)
    {P : Œ± ‚Üí Œ≤ ‚Üí Prop} (hP : ‚àÄ y ‚àà K, ‚àÄ·∂† z : Œ± √ó Œ≤ in ùìù (x‚ÇÄ, y), P z.1 z.2) :
    ‚àÄ·∂† x in ùìù x‚ÇÄ, ‚àÄ y ‚àà K, P x y := by
  simp only [nhds_prod_eq, ‚Üê eventually_iSup, ‚Üê hK.prod_nhdsSet_eq_biSup] at hP
  exact hP.curry.mono fun _ h ‚Ü¶ h.self_of_nhdsSet
#align is_compact.eventually_forall_of_forall_eventually IsCompact.eventually_forall_of_forall_eventually

@[simp]
theorem isCompact_empty : IsCompact (‚àÖ : Set Œ±) := fun _f hnf hsf =>
  Not.elim hnf.ne <| empty_mem_iff_bot.1 <| le_principal_iff.1 hsf
#align is_compact_empty isCompact_empty

@[simp]
theorem isCompact_singleton {a : Œ±} : IsCompact ({a} : Set Œ±) := fun f hf hfa =>
  ‚ü®a, rfl, ClusterPt.of_le_nhds'
    (hfa.trans <| by simpa only [principal_singleton] using pure_le_nhds a) hf‚ü©
#align is_compact_singleton isCompact_singleton

theorem Set.Subsingleton.isCompact {s : Set Œ±} (hs : s.Subsingleton) : IsCompact s :=
  Subsingleton.induction_on hs isCompact_empty fun _ => isCompact_singleton
#align set.subsingleton.is_compact Set.Subsingleton.isCompact

-- porting note: golfed a proof instead of fixing it
theorem Set.Finite.isCompact_biUnion {s : Set Œπ} {f : Œπ ‚Üí Set Œ±} (hs : s.Finite)
    (hf : ‚àÄ i ‚àà s, IsCompact (f i)) : IsCompact (‚ãÉ i ‚àà s, f i) :=
  isCompact_iff_ultrafilter_le_nhds'.2 <| fun l hl => by
    rw [Ultrafilter.finite_biUnion_mem_iff hs] at hl
    rcases hl with ‚ü®i, his, hi‚ü©
    rcases (hf i his).ultrafilter_le_nhds _ (le_principal_iff.2 hi) with ‚ü®x, hxi, hlx‚ü©
    exact ‚ü®x, mem_iUnion‚ÇÇ.2 ‚ü®i, his, hxi‚ü©, hlx‚ü©
#align set.finite.is_compact_bUnion Set.Finite.isCompact_biUnion

theorem Finset.isCompact_biUnion (s : Finset Œπ) {f : Œπ ‚Üí Set Œ±} (hf : ‚àÄ i ‚àà s, IsCompact (f i)) :
    IsCompact (‚ãÉ i ‚àà s, f i) :=
  s.finite_toSet.isCompact_biUnion hf
#align finset.is_compact_bUnion Finset.isCompact_biUnion

theorem isCompact_accumulate {K : ‚Ñï ‚Üí Set Œ±} (hK : ‚àÄ n, IsCompact (K n)) (n : ‚Ñï) :
    IsCompact (Accumulate K n) :=
  (finite_le_nat n).isCompact_biUnion fun k _ => hK k
#align is_compact_accumulate isCompact_accumulate

-- porting note: new lemma
theorem Set.Finite.isCompact_sUnion {S : Set (Set Œ±)} (hf : S.Finite) (hc : ‚àÄ s ‚àà S, IsCompact s) :
    IsCompact (‚ãÉ‚ÇÄ S) := by
  rw [sUnion_eq_biUnion]; exact hf.isCompact_biUnion hc

-- porting note: generalized to `Œπ : Sort*`
theorem isCompact_iUnion {Œπ : Sort*} {f : Œπ ‚Üí Set Œ±} [Finite Œπ] (h : ‚àÄ i, IsCompact (f i)) :
    IsCompact (‚ãÉ i, f i) :=
  (finite_range f).isCompact_sUnion <| forall_range_iff.2 h
#align is_compact_Union isCompact_iUnion

theorem Set.Finite.isCompact (hs : s.Finite) : IsCompact s :=
  biUnion_of_singleton s ‚ñ∏ hs.isCompact_biUnion fun _ _ => isCompact_singleton
#align set.finite.is_compact Set.Finite.isCompact

theorem IsCompact.finite_of_discrete [DiscreteTopology Œ±] {s : Set Œ±} (hs : IsCompact s) :
    s.Finite := by
  have : ‚àÄ x : Œ±, ({x} : Set Œ±) ‚àà ùìù x := by simp [nhds_discrete]
  rcases hs.elim_nhds_subcover (fun x => {x}) fun x _ => this x with ‚ü®t, _, hst‚ü©
  simp only [‚Üê t.set_biUnion_coe, biUnion_of_singleton] at hst
  exact t.finite_toSet.subset hst
#align is_compact.finite_of_discrete IsCompact.finite_of_discrete

theorem isCompact_iff_finite [DiscreteTopology Œ±] {s : Set Œ±} : IsCompact s ‚Üî s.Finite :=
  ‚ü®fun h => h.finite_of_discrete, fun h => h.isCompact‚ü©
#align is_compact_iff_finite isCompact_iff_finite

theorem IsCompact.union (hs : IsCompact s) (ht : IsCompact t) : IsCompact (s ‚à™ t) := by
  rw [union_eq_iUnion]; exact isCompact_iUnion fun b => by cases b <;> assumption
#align is_compact.union IsCompact.union

protected theorem IsCompact.insert (hs : IsCompact s) (a) : IsCompact (insert a s) :=
  isCompact_singleton.union hs
#align is_compact.insert IsCompact.insert

-- porting note: todo: reformulate using `ùìùÀ¢`
/-- If `V : Œπ ‚Üí Set Œ±` is a decreasing family of closed compact sets then any neighborhood of
`‚ãÇ i, V i` contains some `V i`. We assume each `V i` is compact *and* closed because `Œ±` is
not assumed to be Hausdorff. See `exists_subset_nhd_of_compact` for version assuming this. -/
theorem exists_subset_nhds_of_isCompact' {Œπ : Type*} [Nonempty Œπ] {V : Œπ ‚Üí Set Œ±}
    (hV : Directed (¬∑ ‚äá ¬∑) V) (hV_cpct : ‚àÄ i, IsCompact (V i)) (hV_closed : ‚àÄ i, IsClosed (V i))
    {U : Set Œ±} (hU : ‚àÄ x ‚àà ‚ãÇ i, V i, U ‚àà ùìù x) : ‚àÉ i, V i ‚äÜ U := by
  obtain ‚ü®W, hsubW, W_op, hWU‚ü© := exists_open_set_nhds hU
  suffices : ‚àÉ i, V i ‚äÜ W
  ¬∑ exact this.imp fun i hi => hi.trans hWU
  by_contra' H
  replace H : ‚àÄ i, (V i ‚à© W·∂ú).Nonempty := fun i => Set.inter_compl_nonempty_iff.mpr (H i)
  have : (‚ãÇ i, V i ‚à© W·∂ú).Nonempty := by
    refine'
      IsCompact.nonempty_iInter_of_directed_nonempty_compact_closed _ (fun i j => _) H
        (fun i => (hV_cpct i).inter_right W_op.isClosed_compl) fun i =>
        (hV_closed i).inter W_op.isClosed_compl
    rcases hV i j with ‚ü®k, hki, hkj‚ü©
    refine' ‚ü®k, ‚ü®fun x => _, fun x => _‚ü©‚ü© <;> simp only [and_imp, mem_inter_iff, mem_compl_iff] <;>
      tauto
  have : ¬¨‚ãÇ i : Œπ, V i ‚äÜ W := by simpa [‚Üê iInter_inter, inter_compl_nonempty_iff]
  contradiction
#align exists_subset_nhds_of_is_compact' exists_subset_nhds_of_isCompact'

/-- If `Œ±` has a basis consisting of compact opens, then an open set in `Œ±` is compact open iff
  it is a finite union of some elements in the basis -/
theorem isCompact_open_iff_eq_finite_iUnion_of_isTopologicalBasis (b : Œπ ‚Üí Set Œ±)
    (hb : IsTopologicalBasis (Set.range b)) (hb' : ‚àÄ i, IsCompact (b i)) (U : Set Œ±) :
    IsCompact U ‚àß IsOpen U ‚Üî ‚àÉ s : Set Œπ, s.Finite ‚àß U = ‚ãÉ i ‚àà s, b i := by
  constructor
  ¬∑ rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    obtain ‚ü®Œ≤, f, e, hf‚ü© := hb.open_eq_iUnion h‚ÇÇ
    choose f' hf' using hf
    have : b ‚àò f' = f := funext hf'
    subst this
    obtain ‚ü®t, ht‚ü© :=
      h‚ÇÅ.elim_finite_subcover (b ‚àò f') (fun i => hb.isOpen (Set.mem_range_self _)) (by rw [e])
    refine' ‚ü®t.image f', Set.Finite.intro inferInstance, le_antisymm _ _‚ü©
    ¬∑ refine' Set.Subset.trans ht _
      simp only [Set.iUnion_subset_iff]
      intro i hi
      erw [‚Üê Set.iUnion_subtype (fun x : Œπ => x ‚àà t.image f') fun i => b i.1]
      exact Set.subset_iUnion (fun i : t.image f' => b i) ‚ü®_, Finset.mem_image_of_mem _ hi‚ü©
    ¬∑ apply Set.iUnion‚ÇÇ_subset
      rintro i hi
      obtain ‚ü®j, -, rfl‚ü© := Finset.mem_image.mp hi
      rw [e]
      exact Set.subset_iUnion (b ‚àò f') j
  ¬∑ rintro ‚ü®s, hs, rfl‚ü©
    constructor
    ¬∑ exact hs.isCompact_biUnion fun i _ => hb' i
    ¬∑ exact isOpen_biUnion fun i _ => hb.isOpen (Set.mem_range_self _)
#align is_compact_open_iff_eq_finite_Union_of_is_topological_basis isCompact_open_iff_eq_finite_iUnion_of_isTopologicalBasis

namespace Filter

/-- `Filter.cocompact` is the filter generated by complements to compact sets. -/
def cocompact (Œ± : Type*) [TopologicalSpace Œ±] : Filter Œ± :=
  ‚®Ö (s : Set Œ±) (_ : IsCompact s), ùìü s·∂ú
#align filter.cocompact Filter.cocompact

theorem hasBasis_cocompact : (cocompact Œ±).HasBasis IsCompact compl :=
  hasBasis_biInf_principal'
    (fun s hs t ht =>
      ‚ü®s ‚à™ t, hs.union ht, compl_subset_compl.2 (subset_union_left s t),
        compl_subset_compl.2 (subset_union_right s t)‚ü©)
    ‚ü®‚àÖ, isCompact_empty‚ü©
#align filter.has_basis_cocompact Filter.hasBasis_cocompact

theorem mem_cocompact : s ‚àà cocompact Œ± ‚Üî ‚àÉ t, IsCompact t ‚àß t·∂ú ‚äÜ s :=
  hasBasis_cocompact.mem_iff
#align filter.mem_cocompact Filter.mem_cocompact

theorem mem_cocompact' : s ‚àà cocompact Œ± ‚Üî ‚àÉ t, IsCompact t ‚àß s·∂ú ‚äÜ t :=
  mem_cocompact.trans <| exists_congr fun _ => and_congr_right fun _ => compl_subset_comm
#align filter.mem_cocompact' Filter.mem_cocompact'

theorem _root_.IsCompact.compl_mem_cocompact (hs : IsCompact s) : s·∂ú ‚àà Filter.cocompact Œ± :=
  hasBasis_cocompact.mem_of_mem hs
#align is_compact.compl_mem_cocompact IsCompact.compl_mem_cocompact

theorem cocompact_le_cofinite : cocompact Œ± ‚â§ cofinite := fun s hs =>
  compl_compl s ‚ñ∏ hs.isCompact.compl_mem_cocompact
#align filter.cocompact_le_cofinite Filter.cocompact_le_cofinite

theorem cocompact_eq_cofinite (Œ± : Type*) [TopologicalSpace Œ±] [DiscreteTopology Œ±] :
    cocompact Œ± = cofinite := by
  simp only [cocompact, hasBasis_cofinite.eq_biInf, isCompact_iff_finite]
#align filter.cocompact_eq_cofinite Filter.cocompact_eq_cofinite

@[simp] theorem _root_.Nat.cocompact_eq : cocompact ‚Ñï = atTop :=
  (cocompact_eq_cofinite ‚Ñï).trans Nat.cofinite_eq_atTop
#align nat.cocompact_eq Nat.cocompact_eq

theorem Tendsto.isCompact_insert_range_of_cocompact {f : Œ± ‚Üí Œ≤} {b}
    (hf : Tendsto f (cocompact Œ±) (ùìù b)) (hfc : Continuous f) : IsCompact (insert b (range f)) := by
  intro l hne hle
  by_cases hb : ClusterPt b l
  ¬∑ exact ‚ü®b, Or.inl rfl, hb‚ü©
  simp only [clusterPt_iff, not_forall, ‚Üê not_disjoint_iff_nonempty_inter, not_not] at hb
  rcases hb with ‚ü®s, hsb, t, htl, hd‚ü©
  rcases mem_cocompact.1 (hf hsb) with ‚ü®K, hKc, hKs‚ü©
  have : f '' K ‚àà l := by
    filter_upwards [htl, le_principal_iff.1 hle] with y hyt hyf
    rcases hyf with (rfl | ‚ü®x, rfl‚ü©)
    exacts [(hd.le_bot ‚ü®mem_of_mem_nhds hsb, hyt‚ü©).elim,
      mem_image_of_mem _ (not_not.1 fun hxK => hd.le_bot ‚ü®hKs hxK, hyt‚ü©)]
  rcases hKc.image hfc (le_principal_iff.2 this) with ‚ü®y, hy, hyl‚ü©
  exact ‚ü®y, Or.inr <| image_subset_range _ _ hy, hyl‚ü©
#align filter.tendsto.is_compact_insert_range_of_cocompact Filter.Tendsto.isCompact_insert_range_of_cocompact

theorem Tendsto.isCompact_insert_range_of_cofinite {f : Œπ ‚Üí Œ±} {a} (hf : Tendsto f cofinite (ùìù a)) :
    IsCompact (insert a (range f)) := by
  letI : TopologicalSpace Œπ := ‚ä•; haveI h : DiscreteTopology Œπ := ‚ü®rfl‚ü©
  rw [‚Üê cocompact_eq_cofinite Œπ] at hf
  exact hf.isCompact_insert_range_of_cocompact continuous_of_discreteTopology
#align filter.tendsto.is_compact_insert_range_of_cofinite Filter.Tendsto.isCompact_insert_range_of_cofinite

theorem Tendsto.isCompact_insert_range {f : ‚Ñï ‚Üí Œ±} {a} (hf : Tendsto f atTop (ùìù a)) :
    IsCompact (insert a (range f)) :=
  Filter.Tendsto.isCompact_insert_range_of_cofinite <| Nat.cofinite_eq_atTop.symm ‚ñ∏ hf
#align filter.tendsto.is_compact_insert_range Filter.Tendsto.isCompact_insert_range

/-- `Filter.coclosedCompact` is the filter generated by complements to closed compact sets.
In a Hausdorff space, this is the same as `Filter.cocompact`. -/
def coclosedCompact (Œ± : Type*) [TopologicalSpace Œ±] : Filter Œ± :=
  ‚®Ö (s : Set Œ±) (_ : IsClosed s) (_ : IsCompact s), ùìü s·∂ú
#align filter.coclosed_compact Filter.coclosedCompact

theorem hasBasis_coclosedCompact :
    (Filter.coclosedCompact Œ±).HasBasis (fun s => IsClosed s ‚àß IsCompact s) compl := by
  simp only [Filter.coclosedCompact, iInf_and']
  refine' hasBasis_biInf_principal' _ ‚ü®‚àÖ, isClosed_empty, isCompact_empty‚ü©
  rintro s ‚ü®hs‚ÇÅ, hs‚ÇÇ‚ü© t ‚ü®ht‚ÇÅ, ht‚ÇÇ‚ü©
  exact ‚ü®s ‚à™ t, ‚ü®‚ü®hs‚ÇÅ.union ht‚ÇÅ, hs‚ÇÇ.union ht‚ÇÇ‚ü©, compl_subset_compl.2 (subset_union_left _ _),
    compl_subset_compl.2 (subset_union_right _ _)‚ü©‚ü©
#align filter.has_basis_coclosed_compact Filter.hasBasis_coclosedCompact

theorem mem_coclosedCompact : s ‚àà coclosedCompact Œ± ‚Üî ‚àÉ t, IsClosed t ‚àß IsCompact t ‚àß t·∂ú ‚äÜ s := by
  simp only [hasBasis_coclosedCompact.mem_iff, and_assoc]
#align filter.mem_coclosed_compact Filter.mem_coclosedCompact

theorem mem_coclosed_compact' : s ‚àà coclosedCompact Œ± ‚Üî ‚àÉ t, IsClosed t ‚àß IsCompact t ‚àß s·∂ú ‚äÜ t := by
  simp only [mem_coclosedCompact, compl_subset_comm]
#align filter.mem_coclosed_compact' Filter.mem_coclosed_compact'

theorem cocompact_le_coclosedCompact : cocompact Œ± ‚â§ coclosedCompact Œ± :=
  iInf_mono fun _ => le_iInf fun _ => le_rfl
#align filter.cocompact_le_coclosed_compact Filter.cocompact_le_coclosedCompact

end Filter

theorem IsCompact.compl_mem_coclosedCompact_of_isClosed (hs : IsCompact s) (hs' : IsClosed s) :
    s·∂ú ‚àà Filter.coclosedCompact Œ± :=
  hasBasis_coclosedCompact.mem_of_mem ‚ü®hs', hs‚ü©
#align is_compact.compl_mem_coclosed_compact_of_is_closed IsCompact.compl_mem_coclosedCompact_of_isClosed

namespace Bornology

variable (Œ±)

/-- Sets that are contained in a compact set form a bornology. Its `cobounded` filter is
`Filter.cocompact`. See also `Bornology.relativelyCompact` the bornology of sets with compact
closure. -/
def inCompact : Bornology Œ± where
  cobounded' := Filter.cocompact Œ±
  le_cofinite' := Filter.cocompact_le_cofinite
#align bornology.in_compact Bornology.inCompact

variable {Œ±}

theorem inCompact.isBounded_iff : @IsBounded _ (inCompact Œ±) s ‚Üî ‚àÉ t, IsCompact t ‚àß s ‚äÜ t := by
  change s·∂ú ‚àà Filter.cocompact Œ± ‚Üî _
  rw [Filter.mem_cocompact]
  simp
#align bornology.in_compact.is_bounded_iff Bornology.inCompact.isBounded_iff

end Bornology

#noalign nhds_contain_boxes
#noalign nhds_contain_boxes.symm
#noalign nhds_contain_boxes.comm
#noalign nhds_contain_boxes_of_singleton
#noalign nhds_contain_boxes_of_compact

/-- If `s` and `t` are compact sets, then the set neighborhoods filter of `s √óÀ¢ t`
is the product of set neighborhoods filters for `s` and `t`.

For general sets, only the `‚â§` inequality holds, see `nhdsSet_prod_le`. -/
theorem IsCompact.nhdsSet_prod_eq {s : Set Œ±} {t : Set Œ≤} (hs : IsCompact s) (ht : IsCompact t) :
    ùìùÀ¢ (s √óÀ¢ t) = ùìùÀ¢ s √óÀ¢ ùìùÀ¢ t := by
  simp_rw [hs.nhdsSet_prod_eq_biSup, ht.prod_nhdsSet_eq_biSup, nhdsSet, sSup_image, biSup_prod,
    nhds_prod_eq]

/-- The product of a neighborhood of `s` and a neighborhood of `t` is a neighborhood of `s √óÀ¢ t`,
formulated in terms of a filter inequality. -/
theorem nhdsSet_prod_le (s : Set Œ±) (t : Set Œ≤) : ùìùÀ¢ (s √óÀ¢ t) ‚â§ ùìùÀ¢ s √óÀ¢ ùìùÀ¢ t :=
  ((hasBasis_nhdsSet _).prod (hasBasis_nhdsSet _)).ge_iff.2 fun (_u, _v) ‚ü®‚ü®huo, hsu‚ü©, hvo, htv‚ü© ‚Ü¶
    (huo.prod hvo).mem_nhdsSet.2 <| prod_mono hsu htv

/-- If `s` and `t` are compact sets and `n` is an open neighborhood of `s √ó t`, then there exist
open neighborhoods `u ‚äá s` and `v ‚äá t` such that `u √ó v ‚äÜ n`.

See also `IsCompact.nhdsSet_prod_eq`. -/
theorem generalized_tube_lemma {s : Set Œ±} (hs : IsCompact s) {t : Set Œ≤} (ht : IsCompact t)
    {n : Set (Œ± √ó Œ≤)} (hn : IsOpen n) (hp : s √óÀ¢ t ‚äÜ n) :
    ‚àÉ (u : Set Œ±) (v : Set Œ≤), IsOpen u ‚àß IsOpen v ‚àß s ‚äÜ u ‚àß t ‚äÜ v ‚àß u √óÀ¢ v ‚äÜ n := by
  rw [‚Üê hn.mem_nhdsSet, hs.nhdsSet_prod_eq ht,
    ((hasBasis_nhdsSet _).prod (hasBasis_nhdsSet _)).mem_iff] at hp
  rcases hp with ‚ü®‚ü®u, v‚ü©, ‚ü®‚ü®huo, hsu‚ü©, hvo, htv‚ü©, hn‚ü©
  exact ‚ü®u, v, huo, hvo, hsu, htv, hn‚ü©
#align generalized_tube_lemma generalized_tube_lemma

/-- Type class for compact spaces. Separation is sometimes included in the definition, especially
in the French literature, but we do not include it here. -/
class CompactSpace (Œ± : Type*) [TopologicalSpace Œ±] : Prop where
  /-- In a compact space, `Set.univ` is a compact set. -/
  isCompact_univ : IsCompact (univ : Set Œ±)
#align compact_space CompactSpace

-- see Note [lower instance priority]
instance (priority := 10) Subsingleton.compactSpace [Subsingleton Œ±] : CompactSpace Œ± :=
  ‚ü®subsingleton_univ.isCompact‚ü©
#align subsingleton.compact_space Subsingleton.compactSpace

theorem isCompact_univ_iff : IsCompact (univ : Set Œ±) ‚Üî CompactSpace Œ± :=
  ‚ü®fun h => ‚ü®h‚ü©, fun h => h.1‚ü©
#align is_compact_univ_iff isCompact_univ_iff

theorem isCompact_univ [h : CompactSpace Œ±] : IsCompact (univ : Set Œ±) :=
  h.isCompact_univ
#align is_compact_univ isCompact_univ

theorem cluster_point_of_compact [CompactSpace Œ±] (f : Filter Œ±) [NeBot f] : ‚àÉ x, ClusterPt x f :=
  by simpa using isCompact_univ (show f ‚â§ ùìü univ by simp)
#align cluster_point_of_compact cluster_point_of_compact

nonrec theorem Ultrafilter.le_nhds_lim [CompactSpace Œ±] (F : Ultrafilter Œ±) : ‚ÜëF ‚â§ ùìù F.lim := by
  rcases isCompact_univ.ultrafilter_le_nhds F (by simp) with ‚ü®x, -, h‚ü©
  exact le_nhds_lim ‚ü®x, h‚ü©
set_option linter.uppercaseLean3 false in
#align ultrafilter.le_nhds_Lim Ultrafilter.le_nhds_lim

theorem CompactSpace.elim_nhds_subcover [CompactSpace Œ±] (U : Œ± ‚Üí Set Œ±) (hU : ‚àÄ x, U x ‚àà ùìù x) :
    ‚àÉ t : Finset Œ±, ‚ãÉ x ‚àà t, U x = ‚ä§ := by
  obtain ‚ü®t, -, s‚ü© := IsCompact.elim_nhds_subcover isCompact_univ U fun x _ => hU x
  exact ‚ü®t, top_unique s‚ü©
#align compact_space.elim_nhds_subcover CompactSpace.elim_nhds_subcover

theorem compactSpace_of_finite_subfamily_closed
    (h : ‚àÄ {Œπ : Type u} (Z : Œπ ‚Üí Set Œ±), (‚àÄ i, IsClosed (Z i)) ‚Üí ‚ãÇ i, Z i = ‚àÖ ‚Üí
      ‚àÉ t : Finset Œπ, ‚ãÇ i ‚àà t, Z i = ‚àÖ) :
    CompactSpace Œ± where
  isCompact_univ := isCompact_of_finite_subfamily_closed fun Z => by
    simpa using h Z
#align compact_space_of_finite_subfamily_closed compactSpace_of_finite_subfamily_closed

theorem IsClosed.isCompact [CompactSpace Œ±] {s : Set Œ±} (h : IsClosed s) : IsCompact s :=
  isCompact_univ.of_isClosed_subset h (subset_univ _)
#align is_closed.is_compact IsClosed.isCompact

/-- If a filter has a unique cluster point `y` in a compact topological space,
then the filter is less than or equal to `ùìù y`. -/
lemma le_nhds_of_unique_clusterPt [CompactSpace Œ±] {l : Filter Œ±} {y : Œ±}
    (h : ‚àÄ x, ClusterPt x l ‚Üí x = y) : l ‚â§ ùìù y :=
  isCompact_univ.le_nhds_of_unique_clusterPt univ_mem fun x _ ‚Ü¶ h x

/-- If `y` is a unique `MapClusterPt` for `f` along `l`
and the codomain of `f` is a compact space,
then `f` tends to `ùìù y` along `l`. -/
lemma tendsto_nhds_of_unique_mapClusterPt [CompactSpace Œ±] {l : Filter Œ≤} {y : Œ±} {f : Œ≤ ‚Üí Œ±}
    (h : ‚àÄ x, MapClusterPt x l f ‚Üí x = y) :
    Tendsto f l (ùìù y) :=
  le_nhds_of_unique_clusterPt h

/-- `Œ±` is a noncompact topological space if it is not a compact space. -/
class NoncompactSpace (Œ± : Type*) [TopologicalSpace Œ±] : Prop where
  /-- In a noncompact space, `Set.univ` is not a compact set. -/
  noncompact_univ : ¬¨IsCompact (univ : Set Œ±)
#align noncompact_space NoncompactSpace

-- porting note: a lemma instead of `export` to make `Œ±` explicit
lemma noncompact_univ (Œ± : Type*) [TopologicalSpace Œ±] [NoncompactSpace Œ±] :
    ¬¨IsCompact (univ : Set Œ±) :=
  NoncompactSpace.noncompact_univ

theorem IsCompact.ne_univ [NoncompactSpace Œ±] {s : Set Œ±} (hs : IsCompact s) : s ‚â† univ := fun h =>
  noncompact_univ Œ± (h ‚ñ∏ hs)
#align is_compact.ne_univ IsCompact.ne_univ

instance [NoncompactSpace Œ±] : NeBot (Filter.cocompact Œ±) := by
  refine' Filter.hasBasis_cocompact.neBot_iff.2 fun hs => _
  contrapose hs; rw [not_nonempty_iff_eq_empty, compl_empty_iff] at hs
  rw [hs]; exact noncompact_univ Œ±

@[simp]
theorem Filter.cocompact_eq_bot [CompactSpace Œ±] : Filter.cocompact Œ± = ‚ä• :=
  Filter.hasBasis_cocompact.eq_bot_iff.mpr ‚ü®Set.univ, isCompact_univ, Set.compl_univ‚ü©
#align filter.cocompact_eq_bot Filter.cocompact_eq_bot

instance [NoncompactSpace Œ±] : NeBot (Filter.coclosedCompact Œ±) :=
  neBot_of_le Filter.cocompact_le_coclosedCompact

theorem noncompactSpace_of_neBot (_ : NeBot (Filter.cocompact Œ±)) : NoncompactSpace Œ± :=
  ‚ü®fun h' => (Filter.nonempty_of_mem h'.compl_mem_cocompact).ne_empty compl_univ‚ü©
#align noncompact_space_of_ne_bot noncompactSpace_of_neBot

theorem Filter.cocompact_neBot_iff : NeBot (Filter.cocompact Œ±) ‚Üî NoncompactSpace Œ± :=
  ‚ü®noncompactSpace_of_neBot, fun _ => inferInstance‚ü©
#align filter.cocompact_ne_bot_iff Filter.cocompact_neBot_iff

theorem not_compactSpace_iff : ¬¨CompactSpace Œ± ‚Üî NoncompactSpace Œ± :=
  ‚ü®fun h‚ÇÅ => ‚ü®fun h‚ÇÇ => h‚ÇÅ ‚ü®h‚ÇÇ‚ü©‚ü©, fun ‚ü®h‚ÇÅ‚ü© ‚ü®h‚ÇÇ‚ü© => h‚ÇÅ h‚ÇÇ‚ü©
#align not_compact_space_iff not_compactSpace_iff

instance : NoncompactSpace ‚Ñ§ :=
  noncompactSpace_of_neBot <| by simp only [Filter.cocompact_eq_cofinite, Filter.cofinite_neBot]

-- Note: We can't make this into an instance because it loops with `Finite.compactSpace`.
/-- A compact discrete space is finite. -/
theorem finite_of_compact_of_discrete [CompactSpace Œ±] [DiscreteTopology Œ±] : Finite Œ± :=
  Finite.of_finite_univ <| isCompact_univ.finite_of_discrete
#align finite_of_compact_of_discrete finite_of_compact_of_discrete

theorem exists_nhds_ne_neBot (Œ± : Type*) [TopologicalSpace Œ±] [CompactSpace Œ±] [Infinite Œ±] :
    ‚àÉ z : Œ±, (ùìù[‚â†] z).NeBot := by
  by_contra' H
  simp_rw [not_neBot] at H
  haveI := discreteTopology_iff_nhds_ne.2 H
  exact Infinite.not_finite (finite_of_compact_of_discrete : Finite Œ±)
#align exists_nhds_ne_ne_bot exists_nhds_ne_neBot

theorem finite_cover_nhds_interior [CompactSpace Œ±] {U : Œ± ‚Üí Set Œ±} (hU : ‚àÄ x, U x ‚àà ùìù x) :
    ‚àÉ t : Finset Œ±, ‚ãÉ x ‚àà t, interior (U x) = univ :=
  let ‚ü®t, ht‚ü© := isCompact_univ.elim_finite_subcover (fun x => interior (U x))
    (fun _ => isOpen_interior) fun x _ => mem_iUnion.2 ‚ü®x, mem_interior_iff_mem_nhds.2 (hU x)‚ü©
  ‚ü®t, univ_subset_iff.1 ht‚ü©
#align finite_cover_nhds_interior finite_cover_nhds_interior

theorem finite_cover_nhds [CompactSpace Œ±] {U : Œ± ‚Üí Set Œ±} (hU : ‚àÄ x, U x ‚àà ùìù x) :
    ‚àÉ t : Finset Œ±, ‚ãÉ x ‚àà t, U x = univ :=
  let ‚ü®t, ht‚ü© := finite_cover_nhds_interior hU
  ‚ü®t, univ_subset_iff.1 <| ht.symm.subset.trans <| iUnion‚ÇÇ_mono fun _ _ => interior_subset‚ü©
#align finite_cover_nhds finite_cover_nhds

/-- If `Œ±` is a compact space, then a locally finite family of sets of `Œ±` can have only finitely
many nonempty elements. -/
theorem LocallyFinite.finite_nonempty_of_compact {Œπ : Type*} [CompactSpace Œ±] {f : Œπ ‚Üí Set Œ±}
    (hf : LocallyFinite f) : { i | (f i).Nonempty }.Finite := by
  simpa only [inter_univ] using hf.finite_nonempty_inter_compact isCompact_univ
#align locally_finite.finite_nonempty_of_compact LocallyFinite.finite_nonempty_of_compact

/-- If `Œ±` is a compact space, then a locally finite family of nonempty sets of `Œ±` can have only
finitely many elements, `Set.Finite` version. -/
theorem LocallyFinite.finite_of_compact {Œπ : Type*} [CompactSpace Œ±] {f : Œπ ‚Üí Set Œ±}
    (hf : LocallyFinite f) (hne : ‚àÄ i, (f i).Nonempty) : (univ : Set Œπ).Finite := by
  simpa only [hne] using hf.finite_nonempty_of_compact
#align locally_finite.finite_of_compact LocallyFinite.finite_of_compact

/-- If `Œ±` is a compact space, then a locally finite family of nonempty sets of `Œ±` can have only
finitely many elements, `Fintype` version. -/
noncomputable def LocallyFinite.fintypeOfCompact {Œπ : Type*} [CompactSpace Œ±] {f : Œπ ‚Üí Set Œ±}
    (hf : LocallyFinite f) (hne : ‚àÄ i, (f i).Nonempty) : Fintype Œπ :=
  fintypeOfFiniteUniv (hf.finite_of_compact hne)
#align locally_finite.fintype_of_compact LocallyFinite.fintypeOfCompact

/-- The comap of the cocompact filter on `Œ≤` by a continuous function `f : Œ± ‚Üí Œ≤` is less than or
equal to the cocompact filter on `Œ±`.
This is a reformulation of the fact that images of compact sets are compact. -/
theorem Filter.comap_cocompact_le {f : Œ± ‚Üí Œ≤} (hf : Continuous f) :
    (Filter.cocompact Œ≤).comap f ‚â§ Filter.cocompact Œ± := by
  rw [(Filter.hasBasis_cocompact.comap f).le_basis_iff Filter.hasBasis_cocompact]
  intro t ht
  refine' ‚ü®f '' t, ht.image hf, _‚ü©
  simpa using t.subset_preimage_image f
#align filter.comap_cocompact_le Filter.comap_cocompact_le

theorem isCompact_range [CompactSpace Œ±] {f : Œ± ‚Üí Œ≤} (hf : Continuous f) : IsCompact (range f) := by
  rw [‚Üê image_univ]; exact isCompact_univ.image hf
#align is_compact_range isCompact_range

theorem isCompact_diagonal [CompactSpace Œ±] : IsCompact (diagonal Œ±) :=
  @range_diag Œ± ‚ñ∏ isCompact_range (continuous_id.prod_mk continuous_id)
#align is_compact_diagonal isCompact_diagonal

-- porting note: renamed, golfed
/-- If `X` is a compact topological space, then `Prod.snd : X √ó Y ‚Üí Y` is a closed map. -/
theorem isClosedMap_snd_of_compactSpace {X : Type*} [TopologicalSpace X] [CompactSpace X]
    {Y : Type*} [TopologicalSpace Y] : IsClosedMap (Prod.snd : X √ó Y ‚Üí Y) := fun s hs => by
  rw [‚Üê isOpen_compl_iff, isOpen_iff_mem_nhds]
  intro y hy
  have : univ √óÀ¢ {y} ‚äÜ s·∂ú
  ¬∑ exact fun (x, y') ‚ü®_, rfl‚ü© hs => hy ‚ü®(x, y'), hs, rfl‚ü©
  rcases generalized_tube_lemma isCompact_univ isCompact_singleton hs.isOpen_compl this
    with ‚ü®U, V, -, hVo, hU, hV, hs‚ü©
  refine mem_nhds_iff.2 ‚ü®V, ?_, hVo, hV rfl‚ü©
  rintro _ hzV ‚ü®z, hzs, rfl‚ü©
  exact hs ‚ü®hU trivial, hzV‚ü© hzs
#align is_closed_proj_of_is_compact isClosedMap_snd_of_compactSpace

/-- If `Y` is a compact topological space, then `Prod.fst : X √ó Y ‚Üí X` is a closed map. -/
theorem isClosedMap_fst_of_compactSpace {X Y : Type*} [TopologicalSpace X]
    [TopologicalSpace Y] [CompactSpace Y] : IsClosedMap (Prod.fst : X √ó Y ‚Üí X) :=
  isClosedMap_snd_of_compactSpace.comp isClosedMap_swap

theorem exists_subset_nhds_of_compactSpace [CompactSpace Œ±] {Œπ : Type*} [Nonempty Œπ]
    {V : Œπ ‚Üí Set Œ±} (hV : Directed (¬∑ ‚äá ¬∑) V) (hV_closed : ‚àÄ i, IsClosed (V i)) {U : Set Œ±}
    (hU : ‚àÄ x ‚àà ‚ãÇ i, V i, U ‚àà ùìù x) : ‚àÉ i, V i ‚äÜ U :=
  exists_subset_nhds_of_isCompact' hV (fun i => (hV_closed i).isCompact) hV_closed hU
#align exists_subset_nhds_of_compact_space exists_subset_nhds_of_compactSpace

/-- If `f : Œ± ‚Üí Œ≤` is an `Inducing` map, the image `f '' s` of a set `s` is compact
  if and only if `s` is compact. -/
theorem Inducing.isCompact_iff {f : Œ± ‚Üí Œ≤} (hf : Inducing f) {s : Set Œ±} :
    IsCompact s ‚Üî IsCompact (f '' s) := by
  refine ‚ü®fun hs => hs.image hf.continuous, fun hs F F_ne_bot F_le => ?_‚ü©
  obtain ‚ü®_, ‚ü®x, x_in : x ‚àà s, rfl‚ü©, hx : ClusterPt (f x) (map f F)‚ü© :=
    hs ((map_mono F_le).trans_eq map_principal)
  exact ‚ü®x, x_in, hf.mapClusterPt_iff.1 hx‚ü©
#align inducing.is_compact_iff Inducing.isCompact_iff

/-- If `f : Œ± ‚Üí Œ≤` is an `Embedding`, the image `f '' s` of a set `s` is compact
  if and only if `s` is compact. -/
theorem Embedding.isCompact_iff {f : Œ± ‚Üí Œ≤} (hf : Embedding f) :
    IsCompact s ‚Üî IsCompact (f '' s) := hf.toInducing.isCompact_iff
#align embedding.is_compact_iff_is_compact_image Embedding.isCompact_iff

/-- The preimage of a compact set under an inducing map is a compact set. -/
theorem Inducing.isCompact_preimage {f : Œ± ‚Üí Œ≤} (hf : Inducing f) (hf' : IsClosed (range f))
    {K : Set Œ≤} (hK : IsCompact K) : IsCompact (f ‚Åª¬π' K) := by
  replace hK := hK.inter_right hf'
  rwa [hf.isCompact_iff, image_preimage_eq_inter_range]

/-- The preimage of a compact set under a closed embedding is a compact set. -/
theorem ClosedEmbedding.isCompact_preimage {f : Œ± ‚Üí Œ≤} (hf : ClosedEmbedding f)
    {K : Set Œ≤} (hK : IsCompact K) : IsCompact (f ‚Åª¬π' K) :=
  hf.toInducing.isCompact_preimage (hf.closed_range) hK
#align closed_embedding.is_compact_preimage ClosedEmbedding.isCompact_preimage

/-- A closed embedding is proper, ie, inverse images of compact sets are contained in compacts.
Moreover, the preimage of a compact set is compact, see `ClosedEmbedding.isCompact_preimage`. -/
theorem ClosedEmbedding.tendsto_cocompact {f : Œ± ‚Üí Œ≤} (hf : ClosedEmbedding f) :
    Tendsto f (Filter.cocompact Œ±) (Filter.cocompact Œ≤) :=
  Filter.hasBasis_cocompact.tendsto_right_iff.mpr fun _K hK =>
    (hf.isCompact_preimage hK).compl_mem_cocompact
#align closed_embedding.tendsto_cocompact ClosedEmbedding.tendsto_cocompact

/-- Sets of subtype are compact iff the image under a coercion is. -/
theorem Subtype.isCompact_iff {p : Œ± ‚Üí Prop} {s : Set { a // p a }} :
    IsCompact s ‚Üî IsCompact ((‚Üë) '' s : Set Œ±) :=
  embedding_subtype_val.isCompact_iff
#align is_compact_iff_is_compact_in_subtype Subtype.isCompact_iff

theorem isCompact_iff_isCompact_univ {s : Set Œ±} : IsCompact s ‚Üî IsCompact (univ : Set s) := by
  rw [Subtype.isCompact_iff, image_univ, Subtype.range_coe]
#align is_compact_iff_is_compact_univ isCompact_iff_isCompact_univ

theorem isCompact_iff_compactSpace {s : Set Œ±} : IsCompact s ‚Üî CompactSpace s :=
  isCompact_iff_isCompact_univ.trans isCompact_univ_iff
#align is_compact_iff_compact_space isCompact_iff_compactSpace

theorem IsCompact.finite {s : Set Œ±} (hs : IsCompact s) (hs' : DiscreteTopology s) : s.Finite :=
  finite_coe_iff.mp (@finite_of_compact_of_discrete _ _ (isCompact_iff_compactSpace.mp hs) hs')
#align is_compact.finite IsCompact.finite

theorem exists_nhds_ne_inf_principal_neBot {s : Set Œ±} (hs : IsCompact s) (hs' : s.Infinite) :
    ‚àÉ z ‚àà s, (ùìù[‚â†] z ‚äì ùìü s).NeBot := by
  by_contra' H
  simp_rw [not_neBot] at H
  exact hs' (hs.finite <| discreteTopology_subtype_iff.mpr H)
#align exists_nhds_ne_inf_principal_ne_bot exists_nhds_ne_inf_principal_neBot

protected theorem ClosedEmbedding.noncompactSpace [NoncompactSpace Œ±] {f : Œ± ‚Üí Œ≤}
    (hf : ClosedEmbedding f) : NoncompactSpace Œ≤ :=
  noncompactSpace_of_neBot hf.tendsto_cocompact.neBot
#align closed_embedding.noncompact_space ClosedEmbedding.noncompactSpace

protected theorem ClosedEmbedding.compactSpace [h : CompactSpace Œ≤] {f : Œ± ‚Üí Œ≤}
    (hf : ClosedEmbedding f) : CompactSpace Œ± :=
  ‚ü®by rw [hf.toInducing.isCompact_iff, image_univ]; exact hf.closed_range.isCompact‚ü©
#align closed_embedding.compact_space ClosedEmbedding.compactSpace

theorem IsCompact.prod {s : Set Œ±} {t : Set Œ≤} (hs : IsCompact s) (ht : IsCompact t) :
    IsCompact (s √óÀ¢ t) := by
  rw [isCompact_iff_ultrafilter_le_nhds'] at hs ht ‚ä¢
  intro f hfs
  obtain ‚ü®a : Œ±, sa : a ‚àà s, ha : map Prod.fst f.1 ‚â§ ùìù a‚ü© :=
    hs (f.map Prod.fst) (mem_map.2 <| mem_of_superset hfs fun x => And.left)
  obtain ‚ü®b : Œ≤, tb : b ‚àà t, hb : map Prod.snd f.1 ‚â§ ùìù b‚ü© :=
    ht (f.map Prod.snd) (mem_map.2 <| mem_of_superset hfs fun x => And.right)
  rw [map_le_iff_le_comap] at ha hb
  refine' ‚ü®‚ü®a, b‚ü©, ‚ü®sa, tb‚ü©, _‚ü©
  rw [nhds_prod_eq]; exact le_inf ha hb
#align is_compact.prod IsCompact.prod

/-- Finite topological spaces are compact. -/
instance (priority := 100) Finite.compactSpace [Finite Œ±] : CompactSpace Œ± where
  isCompact_univ := finite_univ.isCompact
#align finite.compact_space Finite.compactSpace

/-- The product of two compact spaces is compact. -/
instance [CompactSpace Œ±] [CompactSpace Œ≤] : CompactSpace (Œ± √ó Œ≤) :=
  ‚ü®by rw [‚Üê univ_prod_univ]; exact isCompact_univ.prod isCompact_univ‚ü©

/-- The disjoint union of two compact spaces is compact. -/
instance [CompactSpace Œ±] [CompactSpace Œ≤] : CompactSpace (Œ± ‚äï Œ≤) :=
  ‚ü®by
    rw [‚Üê range_inl_union_range_inr]
    exact (isCompact_range continuous_inl).union (isCompact_range continuous_inr)‚ü©

instance [Finite Œπ] [‚àÄ i, TopologicalSpace (œÄ i)] [‚àÄ i, CompactSpace (œÄ i)] :
    CompactSpace (Œ£i, œÄ i) := by
  refine' ‚ü®_‚ü©
  rw [Sigma.univ]
  exact isCompact_iUnion fun i => isCompact_range continuous_sigmaMk

/-- The coproduct of the cocompact filters on two topological spaces is the cocompact filter on
their product. -/
theorem Filter.coprod_cocompact :
    (Filter.cocompact Œ±).coprod (Filter.cocompact Œ≤) = Filter.cocompact (Œ± √ó Œ≤) := by
  apply le_antisymm
  ¬∑ exact sup_le (comap_cocompact_le continuous_fst) (comap_cocompact_le continuous_snd)
  ¬∑ refine (hasBasis_cocompact.coprod hasBasis_cocompact).ge_iff.2 fun K hK ‚Ü¶ ?_
    rw [‚Üê univ_prod, ‚Üê prod_univ, ‚Üê compl_prod_eq_union]
    exact (hK.1.prod hK.2).compl_mem_cocompact
#align filter.coprod_cocompact Filter.coprod_cocompact

theorem Prod.noncompactSpace_iff :
    NoncompactSpace (Œ± √ó Œ≤) ‚Üî NoncompactSpace Œ± ‚àß Nonempty Œ≤ ‚à® Nonempty Œ± ‚àß NoncompactSpace Œ≤ := by
  simp [‚Üê Filter.cocompact_neBot_iff, ‚Üê Filter.coprod_cocompact, Filter.coprod_neBot_iff]
#align prod.noncompact_space_iff Prod.noncompactSpace_iff

-- See Note [lower instance priority]
instance (priority := 100) Prod.noncompactSpace_left [NoncompactSpace Œ±] [Nonempty Œ≤] :
    NoncompactSpace (Œ± √ó Œ≤) :=
  Prod.noncompactSpace_iff.2 (Or.inl ‚ü®‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü©)
#align prod.noncompact_space_left Prod.noncompactSpace_left

-- See Note [lower instance priority]
instance (priority := 100) Prod.noncompactSpace_right [Nonempty Œ±] [NoncompactSpace Œ≤] :
    NoncompactSpace (Œ± √ó Œ≤) :=
  Prod.noncompactSpace_iff.2 (Or.inr ‚ü®‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü©)
#align prod.noncompact_space_right Prod.noncompactSpace_right

section Tychonoff

variable [‚àÄ i, TopologicalSpace (œÄ i)]

/-- **Tychonoff's theorem**: product of compact sets is compact. -/
theorem isCompact_pi_infinite {s : ‚àÄ i, Set (œÄ i)} :
    (‚àÄ i, IsCompact (s i)) ‚Üí IsCompact { x : ‚àÄ i, œÄ i | ‚àÄ i, x i ‚àà s i } := by
  simp only [isCompact_iff_ultrafilter_le_nhds, nhds_pi, Filter.pi, exists_prop, mem_setOf_eq,
    le_iInf_iff, le_principal_iff]
  intro h f hfs
  have : ‚àÄ i : Œπ, ‚àÉ a, a ‚àà s i ‚àß Tendsto (Function.eval i) f (ùìù a) := by
    refine fun i => h i (f.map _) (mem_map.2 ?_)
    exact mem_of_superset hfs fun x hx => hx i
  choose a ha using this
  exact ‚ü®a, fun i => (ha i).left, fun i => (ha i).right.le_comap‚ü©
#align is_compact_pi_infinite isCompact_pi_infinite

/-- **Tychonoff's theorem** formulated using `Set.pi`: product of compact sets is compact. -/
theorem isCompact_univ_pi {s : ‚àÄ i, Set (œÄ i)} (h : ‚àÄ i, IsCompact (s i)) :
    IsCompact (pi univ s) := by
  convert isCompact_pi_infinite h
  simp only [‚Üê mem_univ_pi, setOf_mem_eq]
#align is_compact_univ_pi isCompact_univ_pi

instance Pi.compactSpace [‚àÄ i, CompactSpace (œÄ i)] : CompactSpace (‚àÄ i, œÄ i) :=
  ‚ü®by rw [‚Üê pi_univ univ]; exact isCompact_univ_pi fun i => isCompact_univ‚ü©
#align pi.compact_space Pi.compactSpace

instance Function.compactSpace [CompactSpace Œ≤] : CompactSpace (Œπ ‚Üí Œ≤) :=
  Pi.compactSpace
#align function.compact_space Function.compactSpace

/-- **Tychonoff's theorem** formulated in terms of filters: `Filter.cocompact` on an indexed product
type `Œ† d, Œ∫ d` the `Filter.coprod·µ¢` of filters `Filter.cocompact` on `Œ∫ d`. -/
theorem Filter.coprod·µ¢_cocompact {Œ¥ : Type*} {Œ∫ : Œ¥ ‚Üí Type*} [‚àÄ d, TopologicalSpace (Œ∫ d)] :
    (Filter.coprod·µ¢ fun d => Filter.cocompact (Œ∫ d)) = Filter.cocompact (‚àÄ d, Œ∫ d) := by
  refine' le_antisymm (iSup_le fun i => Filter.comap_cocompact_le (continuous_apply i)) _
  refine' compl_surjective.forall.2 fun s H => _
  simp only [compl_mem_coprod·µ¢, Filter.mem_cocompact, compl_subset_compl, image_subset_iff] at H ‚ä¢
  choose K hKc htK using H
  exact ‚ü®Set.pi univ K, isCompact_univ_pi hKc, fun f hf i _ => htK i hf‚ü©
set_option linter.uppercaseLean3 false in
#align filter.Coprod_cocompact Filter.coprod·µ¢_cocompact

end Tychonoff

instance Quot.compactSpace {r : Œ± ‚Üí Œ± ‚Üí Prop} [CompactSpace Œ±] : CompactSpace (Quot r) :=
  ‚ü®by
    rw [‚Üê range_quot_mk]
    exact isCompact_range continuous_quot_mk‚ü©
#align quot.compact_space Quot.compactSpace

instance Quotient.compactSpace {s : Setoid Œ±} [CompactSpace Œ±] : CompactSpace (Quotient s) :=
  Quot.compactSpace
#align quotient.compact_space Quotient.compactSpace

theorem IsClosed.exists_minimal_nonempty_closed_subset [CompactSpace Œ±] {S : Set Œ±}
    (hS : IsClosed S) (hne : S.Nonempty) :
    ‚àÉ V : Set Œ±, V ‚äÜ S ‚àß V.Nonempty ‚àß IsClosed V ‚àß
      ‚àÄ V' : Set Œ±, V' ‚äÜ V ‚Üí V'.Nonempty ‚Üí IsClosed V' ‚Üí V' = V := by
  let opens := { U : Set Œ± | S·∂ú ‚äÜ U ‚àß IsOpen U ‚àß U·∂ú.Nonempty }
  obtain ‚ü®U, ‚ü®Uc, Uo, Ucne‚ü©, h‚ü© :=
    zorn_subset opens fun c hc hz => by
      by_cases hcne : c.Nonempty
      ¬∑ obtain ‚ü®U‚ÇÄ, hU‚ÇÄ‚ü© := hcne
        haveI : Nonempty { U // U ‚àà c } := ‚ü®‚ü®U‚ÇÄ, hU‚ÇÄ‚ü©‚ü©
        obtain ‚ü®U‚ÇÄcompl, -, -‚ü© := hc hU‚ÇÄ
        use ‚ãÉ‚ÇÄ c
        refine' ‚ü®‚ü®_, _, _‚ü©, fun U hU a ha => ‚ü®U, hU, ha‚ü©‚ü©
        ¬∑ exact fun a ha => ‚ü®U‚ÇÄ, hU‚ÇÄ, U‚ÇÄcompl ha‚ü©
        ¬∑ exact isOpen_sUnion fun _ h => (hc h).2.1
        ¬∑ convert_to (‚ãÇ U : { U // U ‚àà c }, U.1·∂ú).Nonempty
          ¬∑ ext
            simp only [not_exists, exists_prop, not_and, Set.mem_iInter, Subtype.forall,
              mem_setOf_eq, mem_compl_iff, mem_sUnion]
          apply IsCompact.nonempty_iInter_of_directed_nonempty_compact_closed
          ¬∑ rintro ‚ü®U, hU‚ü© ‚ü®U', hU'‚ü©
            obtain ‚ü®V, hVc, hVU, hVU'‚ü© := hz.directedOn U hU U' hU'
            exact ‚ü®‚ü®V, hVc‚ü©, Set.compl_subset_compl.mpr hVU, Set.compl_subset_compl.mpr hVU'‚ü©
          ¬∑ exact fun U => (hc U.2).2.2
          ¬∑ exact fun U => (hc U.2).2.1.isClosed_compl.isCompact
          ¬∑ exact fun U => (hc U.2).2.1.isClosed_compl
      ¬∑ use S·∂ú
        refine' ‚ü®‚ü®Set.Subset.refl _, isOpen_compl_iff.mpr hS, _‚ü©, fun U Uc => (hcne ‚ü®U, Uc‚ü©).elim‚ü©
        rw [compl_compl]
        exact hne
  refine' ‚ü®U·∂ú, Set.compl_subset_comm.mp Uc, Ucne, Uo.isClosed_compl, _‚ü©
  intro V' V'sub V'ne V'cls
  have : V'·∂ú = U := by
    refine' h V'·∂ú ‚ü®_, isOpen_compl_iff.mpr V'cls, _‚ü© (Set.subset_compl_comm.mp V'sub)
    exact Set.Subset.trans Uc (Set.subset_compl_comm.mp V'sub)
    simp only [compl_compl, V'ne]
  rw [‚Üê this, compl_compl]
#align is_closed.exists_minimal_nonempty_closed_subset IsClosed.exists_minimal_nonempty_closed_subset
