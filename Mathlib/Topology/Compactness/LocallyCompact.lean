/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro, Yury Kudryashov
-/
import Mathlib.Topology.Compactness.Compact
/-!
# Locally compact spaces

We define the following classes of topological spaces:
* `WeaklyLocallyCompactSpace`: every point `x` has a compact neighborhood.
* `LocallyCompactSpace`: for every point `x`, every open neighborhood of `x` contains a compact
  neighborhood of `x`. The definition is formulated in terms of the neighborhood filter.
-/
open Set Filter Topology TopologicalSpace Classical

variable {X : Type*} {Y : Type*} {Œπ : Type*}

variable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}


/-- We say that a topological space is a *weakly locally compact space*,
if each point of this space admits a compact neighborhood. -/
class WeaklyLocallyCompactSpace (X : Type*) [TopologicalSpace X] : Prop where
  /-- Every point of a weakly locally compact space admits a compact neighborhood. -/
  exists_compact_mem_nhds (x : X) : ‚àÉ s, IsCompact s ‚àß s ‚àà ùìù x

export WeaklyLocallyCompactSpace (exists_compact_mem_nhds)
#align exists_compact_mem_nhds WeaklyLocallyCompactSpace.exists_compact_mem_nhds

instance [WeaklyLocallyCompactSpace X] [WeaklyLocallyCompactSpace Y] :
    WeaklyLocallyCompactSpace (X √ó Y) where
  exists_compact_mem_nhds x :=
    let ‚ü®s‚ÇÅ, hc‚ÇÅ, h‚ÇÅ‚ü© := exists_compact_mem_nhds x.1
    let ‚ü®s‚ÇÇ, hc‚ÇÇ, h‚ÇÇ‚ü© := exists_compact_mem_nhds x.2
    ‚ü®s‚ÇÅ √óÀ¢ s‚ÇÇ, hc‚ÇÅ.prod hc‚ÇÇ, prod_mem_nhds h‚ÇÅ h‚ÇÇ‚ü©

instance {Œπ : Type*} [Finite Œπ] {X : Œπ ‚Üí Type*} [(i : Œπ) ‚Üí TopologicalSpace (X i)]
    [(i : Œπ) ‚Üí WeaklyLocallyCompactSpace (X i)] :
    WeaklyLocallyCompactSpace ((i : Œπ) ‚Üí X i) where
  exists_compact_mem_nhds := fun f ‚Ü¶ by
    choose s hsc hs using fun i ‚Ü¶ exists_compact_mem_nhds (f i)
    exact ‚ü®pi univ s, isCompact_univ_pi hsc, set_pi_mem_nhds univ.toFinite fun i _ ‚Ü¶ hs i‚ü©

instance (priority := 100) [CompactSpace X] : WeaklyLocallyCompactSpace X where
  exists_compact_mem_nhds _ := ‚ü®univ, isCompact_univ, univ_mem‚ü©

/-- In a weakly locally compact space,
every compact set is contained in the interior of a compact set. -/
theorem exists_compact_superset [WeaklyLocallyCompactSpace X] {K : Set X} (hK : IsCompact K) :
    ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K' := by
  choose s hc hmem using fun x : X ‚Ü¶ exists_compact_mem_nhds x
  rcases hK.elim_nhds_subcover _ fun x _ ‚Ü¶ interior_mem_nhds.2 (hmem x) with ‚ü®I, -, hIK‚ü©
  refine ‚ü®‚ãÉ x ‚àà I, s x, I.isCompact_biUnion fun _ _ ‚Ü¶ hc _, hIK.trans ?_‚ü©
  exact iUnion‚ÇÇ_subset fun x hx ‚Ü¶ interior_mono <| subset_iUnion‚ÇÇ (s := fun x _ ‚Ü¶ s x) x hx
#align exists_compact_superset exists_compact_superset

/-- In a weakly locally compact space,
the filters `ùìù x` and `cocompact X` are disjoint for all `X`. -/
theorem disjoint_nhds_cocompact [WeaklyLocallyCompactSpace X] (x : X) :
    Disjoint (ùìù x) (cocompact X) :=
  let ‚ü®_, hc, hx‚ü© := exists_compact_mem_nhds x
  disjoint_of_disjoint_of_mem disjoint_compl_right hx hc.compl_mem_cocompact

/-- There are various definitions of "locally compact space" in the literature,
which agree for Hausdorff spaces but not in general.
This one is the precise condition on X needed
for the evaluation map `C(X, Y) √ó X ‚Üí Y` to be continuous for all `Y`
when `C(X, Y)` is given the compact-open topology.

See also `WeaklyLocallyCompactSpace`, a typeclass that only assumes
that each point has a compact neighborhood. -/
class LocallyCompactSpace (X : Type*) [TopologicalSpace X] : Prop where
  /-- In a locally compact space,
    every neighbourhood of every point contains a compact neighbourhood of that same point. -/
  local_compact_nhds : ‚àÄ (x : X), ‚àÄ n ‚àà ùìù x, ‚àÉ s ‚àà ùìù x, s ‚äÜ n ‚àß IsCompact s
#align locally_compact_space LocallyCompactSpace

theorem compact_basis_nhds [LocallyCompactSpace X] (x : X) :
    (ùìù x).HasBasis (fun s => s ‚àà ùìù x ‚àß IsCompact s) fun s => s :=
  hasBasis_self.2 <| by simpa only [and_comm] using LocallyCompactSpace.local_compact_nhds x
#align compact_basis_nhds compact_basis_nhds

theorem local_compact_nhds [LocallyCompactSpace X] {x : X} {n : Set X} (h : n ‚àà ùìù x) :
    ‚àÉ s ‚àà ùìù x, s ‚äÜ n ‚àß IsCompact s :=
  LocallyCompactSpace.local_compact_nhds _ _ h
#align local_compact_nhds local_compact_nhds

theorem locallyCompactSpace_of_hasBasis {Œπ : X ‚Üí Type*} {p : ‚àÄ x, Œπ x ‚Üí Prop}
    {s : ‚àÄ x, Œπ x ‚Üí Set X} (h : ‚àÄ x, (ùìù x).HasBasis (p x) (s x))
    (hc : ‚àÄ x i, p x i ‚Üí IsCompact (s x i)) : LocallyCompactSpace X :=
  ‚ü®fun x _t ht =>
    let ‚ü®i, hp, ht‚ü© := (h x).mem_iff.1 ht
    ‚ü®s x i, (h x).mem_of_mem hp, ht, hc x i hp‚ü©‚ü©
#align locally_compact_space_of_has_basis locallyCompactSpace_of_hasBasis

instance Prod.locallyCompactSpace (X : Type*) (Y : Type*) [TopologicalSpace X]
    [TopologicalSpace Y] [LocallyCompactSpace X] [LocallyCompactSpace Y] :
    LocallyCompactSpace (X √ó Y) :=
  have := fun x : X √ó Y => (compact_basis_nhds x.1).prod_nhds' (compact_basis_nhds x.2)
  locallyCompactSpace_of_hasBasis this fun _ _ ‚ü®‚ü®_, h‚ÇÅ‚ü©, _, h‚ÇÇ‚ü© => h‚ÇÅ.prod h‚ÇÇ
#align prod.locally_compact_space Prod.locallyCompactSpace

section Pi

variable {X : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (X i)] [‚àÄ i, LocallyCompactSpace (X i)]

/-- In general it suffices that all but finitely many of the spaces are compact,
  but that's not straightforward to state and use. -/
instance Pi.locallyCompactSpace_of_finite [Finite Œπ] : LocallyCompactSpace (‚àÄ i, X i) :=
  ‚ü®fun t n hn => by
    rw [nhds_pi, Filter.mem_pi] at hn
    obtain ‚ü®s, -, n', hn', hsub‚ü© := hn
    choose n'' hn'' hsub' hc using fun i =>
      LocallyCompactSpace.local_compact_nhds (t i) (n' i) (hn' i)
    refine' ‚ü®(Set.univ : Set Œπ).pi n'', _, subset_trans (fun _ h => _) hsub, isCompact_univ_pi hc‚ü©
    ¬∑ exact (set_pi_mem_nhds_iff (@Set.finite_univ Œπ _) _).mpr fun i _ => hn'' i
    ¬∑ exact fun i _ => hsub' i (h i trivial)‚ü©
#align pi.locally_compact_space_of_finite Pi.locallyCompactSpace_of_finite

/-- For spaces that are not Hausdorff. -/
instance Pi.locallyCompactSpace [‚àÄ i, CompactSpace (X i)] : LocallyCompactSpace (‚àÄ i, X i) :=
  ‚ü®fun t n hn => by
    rw [nhds_pi, Filter.mem_pi] at hn
    obtain ‚ü®s, hs, n', hn', hsub‚ü© := hn
    choose n'' hn'' hsub' hc using fun i =>
      LocallyCompactSpace.local_compact_nhds (t i) (n' i) (hn' i)
    refine' ‚ü®s.pi n'', _, subset_trans (fun _ => _) hsub, _‚ü©
    ¬∑ exact (set_pi_mem_nhds_iff hs _).mpr fun i _ => hn'' i
    ¬∑ exact forall‚ÇÇ_imp fun i _ hi' => hsub' i hi'
    ¬∑ rw [‚Üê Set.univ_pi_ite]
      refine' isCompact_univ_pi fun i => _
      by_cases h : i ‚àà s
      ¬∑ rw [if_pos h]
        exact hc i
      ¬∑ rw [if_neg h]
        exact CompactSpace.isCompact_univ‚ü©
#align pi.locally_compact_space Pi.locallyCompactSpace

instance Function.locallyCompactSpace_of_finite [Finite Œπ] [LocallyCompactSpace Y] :
    LocallyCompactSpace (Œπ ‚Üí Y) :=
  Pi.locallyCompactSpace_of_finite
#align function.locally_compact_space_of_finite Function.locallyCompactSpace_of_finite

instance Function.locallyCompactSpace [LocallyCompactSpace Y] [CompactSpace Y] :
    LocallyCompactSpace (Œπ ‚Üí Y) :=
  Pi.locallyCompactSpace
#align function.locally_compact_space Function.locallyCompactSpace

end Pi

/-- A reformulation of the definition of locally compact space: In a locally compact space,
  every open set containing `x` has a compact subset containing `x` in its interior. -/
theorem exists_compact_subset [LocallyCompactSpace X] {x : X} {U : Set X} (hU : IsOpen U)
    (hx : x ‚àà U) : ‚àÉ K : Set X, IsCompact K ‚àß x ‚àà interior K ‚àß K ‚äÜ U := by
  rcases LocallyCompactSpace.local_compact_nhds x U (hU.mem_nhds hx) with ‚ü®K, h1K, h2K, h3K‚ü©
  exact ‚ü®K, h3K, mem_interior_iff_mem_nhds.2 h1K, h2K‚ü©
#align exists_compact_subset exists_compact_subset

instance (priority := 100) [LocallyCompactSpace X] : WeaklyLocallyCompactSpace X where
  exists_compact_mem_nhds (x : X) :=
    let ‚ü®K, hKc, hx, _‚ü© := exists_compact_subset isOpen_univ (mem_univ x)
    ‚ü®K, hKc, mem_interior_iff_mem_nhds.1 hx‚ü©

/-- In a locally compact space, for every containment `K ‚äÜ U` of a compact set `K` in an open
  set `U`, there is a compact neighborhood `L` such that `K ‚äÜ L ‚äÜ U`: equivalently, there is a
  compact `L` such that `K ‚äÜ interior L` and `L ‚äÜ U`. -/
theorem exists_compact_between [hX : LocallyCompactSpace X] {K U : Set X} (hK : IsCompact K)
    (hU : IsOpen U) (h_KU : K ‚äÜ U) : ‚àÉ L, IsCompact L ‚àß K ‚äÜ interior L ‚àß L ‚äÜ U := by
  choose V hVc hxV hKV using fun x : K => exists_compact_subset hU (h_KU x.2)
  have : K ‚äÜ ‚ãÉ x, interior (V x) := fun x hx => mem_iUnion.2 ‚ü®‚ü®x, hx‚ü©, hxV _‚ü©
  rcases hK.elim_finite_subcover _ (fun x => @isOpen_interior X _ (V x)) this with ‚ü®t, ht‚ü©
  refine'
    ‚ü®_, t.isCompact_biUnion fun x _ => hVc x, fun x hx => _, Set.iUnion‚ÇÇ_subset fun i _ => hKV i‚ü©
  rcases mem_iUnion‚ÇÇ.1 (ht hx) with ‚ü®y, hyt, hy‚ü©
  exact interior_mono (subset_iUnion‚ÇÇ y hyt) hy
#align exists_compact_between exists_compact_between

protected theorem ClosedEmbedding.locallyCompactSpace [LocallyCompactSpace Y] {f : X ‚Üí Y}
    (hf : ClosedEmbedding f) : LocallyCompactSpace X :=
  haveI : ‚àÄ x : X, (ùìù x).HasBasis (fun s => s ‚àà ùìù (f x) ‚àß IsCompact s) fun s => f ‚Åª¬π' s := by
    intro x
    rw [hf.toInducing.nhds_eq_comap]
    exact (compact_basis_nhds _).comap _
  locallyCompactSpace_of_hasBasis this fun x s hs => hf.isCompact_preimage hs.2
#align closed_embedding.locally_compact_space ClosedEmbedding.locallyCompactSpace

protected theorem IsClosed.locallyCompactSpace [LocallyCompactSpace X] {s : Set X}
    (hs : IsClosed s) : LocallyCompactSpace s :=
  (closedEmbedding_subtype_val hs).locallyCompactSpace
#align is_closed.locally_compact_space IsClosed.locallyCompactSpace

protected theorem OpenEmbedding.locallyCompactSpace [LocallyCompactSpace Y] {f : X ‚Üí Y}
    (hf : OpenEmbedding f) : LocallyCompactSpace X := by
  have : ‚àÄ x : X, (ùìù x).HasBasis
      (fun s => (s ‚àà ùìù (f x) ‚àß IsCompact s) ‚àß s ‚äÜ range f) fun s => f ‚Åª¬π' s := by
    intro x
    rw [hf.toInducing.nhds_eq_comap]
    exact
      ((compact_basis_nhds _).restrict_subset <| hf.open_range.mem_nhds <| mem_range_self _).comap _
  refine' locallyCompactSpace_of_hasBasis this fun x s hs => _
  rw [hf.toInducing.isCompact_iff, image_preimage_eq_of_subset hs.2]
  exact hs.1.2
#align open_embedding.locally_compact_space OpenEmbedding.locallyCompactSpace

protected theorem IsOpen.locallyCompactSpace [LocallyCompactSpace X] {s : Set X} (hs : IsOpen s) :
    LocallyCompactSpace s :=
  hs.openEmbedding_subtype_val.locallyCompactSpace
#align is_open.locally_compact_space IsOpen.locallyCompactSpace
