/-
Copyright (c) 2025 Adam Topaz. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Justin Curry, Adam Topaz
-/
import Mathlib.Combinatorics.Quiver.ReflQuiver
import Mathlib.Order.CompletePartialOrder
import Mathlib.Topology.Order.UpperLowerSetTopology
import Mathlib.Topology.Sheaves.SheafCondition.OpensLeCover

/-!

Let `X` be a preorder `‚â§`, and consider the associated Alexandrov topology on `X`.
Given a functor `F : X ‚•§ C` to a complete category, we can extend `F` to a
presheaf on (the topological space) `X` by taking the right Kan extension along the canonical
functor `X ‚•§ (Opens X)·µí·µñ` sending `x : X` to the principal open `{y | x ‚â§ y}` in the
Alexandrov topology.

This file proves that this presheaf is a sheaf.

-/

noncomputable section

universe v u
open CategoryTheory Limits Functor
open TopCat Presheaf SheafCondition
open TopologicalSpace Topology

variable
  {X : Type v} [TopologicalSpace X] [Preorder X] [Topology.IsUpperSet X]
  {C : Type u} [Category.{v} C] [HasLimits C]
  (F : X ‚•§ C)

namespace Alexandrov

/-- Given `x : X`, this is the principal open subset of `X` generated by `x`. -/
def principalOpen (x : X) : Opens X := .mk { y | x ‚â§ y } <| by
  rw [IsUpperSet.isOpen_iff_isUpperSet]
  intro y z h1 h2
  exact le_trans h2 h1

lemma self_mem_principalOpen (x : X) : x ‚àà principalOpen x := le_refl _

@[simp]
lemma principalOpen_le_iff {x : X} (U : Opens X) :
    principalOpen x ‚â§ U ‚Üî x ‚àà U := by
  refine ‚ü®fun h => h <| self_mem_principalOpen _, fun hx y hy => ?_‚ü©
  ¬∑ have := U.isOpen
    rw [IsUpperSet.isOpen_iff_isUpperSet] at this
    exact this hy hx

lemma principalOpen_le {x y : X} (h : x ‚â§ y) :
    principalOpen y ‚â§ principalOpen x :=
  fun _ hc => le_trans h hc

variable (X) in
/-- The functor sending `x : X` to the principal open associated with `x`. -/
@[simps]
def principals : X ‚•§ (Opens X)·µí·µñ where
  obj x := .op <| principalOpen x
  map {x y} f := .op <| principalOpen_le f.le |>.hom

lemma exists_le_of_le_sup {Œπ : Type v} {x : X}
    (Us : Œπ ‚Üí Opens X) (h : principalOpen x ‚â§ iSup Us) :
    ‚àÉ i : Œπ, principalOpen x ‚â§ Us i := by
  grind [principalOpen_le_iff, Opens.mem_iSup]

/-- The right kan extension of `F` along `X ‚•§ (Opens X)·µí·µñ`. -/
abbrev principalsKanExtension : (Opens X)·µí·µñ ‚•§ C :=
  (principals X).pointwiseRightKanExtension F

/-- Given a structured arrow `f` with domain `U : Opens X` over `principals X`,
this functor sends `f` to its "generator", an element of `X`. -/
abbrev generator (U : Opens X) :
    StructuredArrow (.op U) (principals X) ‚•§ X :=
  StructuredArrow.proj (.op U) (principals X)

/-- Given a structured arrow `f` with domain `iSup Us` over `principals X`,
where `Us` is a family of `Opens X`, this functor sends `f` to the principal open
associated with it, considered as an object in the full subcategory of all `V : Opens X`
such that `V ‚â§ Us i` for some `i`.

This definition is primarily meant to be used in `lowerCone`, and `isLimit` below.
-/
@[simps]
def projSup {Œπ : Type v} (Us : Œπ ‚Üí Opens X) :
    StructuredArrow (.op <| iSup Us) (principals X) ‚•§
      (ObjectProperty.FullSubcategory fun V => ‚àÉ i, V ‚â§ Us i)·µí·µñ where
  obj f := .op <| .mk (principalOpen f.right) <| exists_le_of_le_sup Us f.hom.unop.le
  map e := .op <| LE.le.hom <| principalOpen_le <| e.right.le

variable {F} in
/-- This is an auxiliary definition which is only meant to be used in `isLimit` below. -/
@[simps]
def lowerCone
    {Œ± : Type v} (Us : Œ± ‚Üí Opens X)
    (S : Cone ((ObjectProperty.Œπ fun V => ‚àÉ i, V ‚â§ Us i).op ‚ãô principalsKanExtension F)) :
    Cone (generator (iSup Us) ‚ãô F) where
  pt := S.pt
  œÄ := {
    app := fun f =>
      S.œÄ.app ((projSup Us).obj f) ‚â´ limit.œÄ (generator (principalOpen f.right) ‚ãô F)
        ‚ü®.mk .unit, f.right, ùüô _‚ü©
    naturality := by
      rintro x y e
      simp only [Functor.const_obj_obj, Functor.comp_obj, Functor.const_obj_map,
        Functor.op_obj, ObjectProperty.Œπ_obj, Functor.pointwiseRightKanExtension_obj,
        Category.id_comp, Functor.comp_map, Category.assoc]
      rw [‚Üê S.w ((projSup Us).map e), Category.assoc]
      congr 1
      simp only [projSup_obj, Functor.comp_obj, Functor.op_obj, ObjectProperty.Œπ_obj,
        Functor.pointwiseRightKanExtension_obj, projSup_map, homOfLE_leOfHom, Functor.comp_map,
        Functor.op_map, Quiver.Hom.unop_op,
        Functor.pointwiseRightKanExtension_map, limit.lift_œÄ]
      let xx : StructuredArrow (Opposite.op (principalOpen x.right)) (principals X) :=
        ‚ü®.mk .unit, x.right, ùüô _‚ü©
      let yy : StructuredArrow (Opposite.op (principalOpen x.right)) (principals X) :=
        ‚ü®.mk .unit, y.right, .op <| LE.le.hom <| principalOpen_le e.right.le‚ü©
      let ee : xx ‚ü∂ yy := { left := ùüô _, right := e.right }
      exact limit.w
        (StructuredArrow.proj (Opposite.op (principalOpen x.right)) (principals X) ‚ãô F) ee
        |>.symm
  }

/--
This is the main construction in this file showing that the right Kan extension
of `F : X ‚•§ C` along `principals : X ‚•§ (Opens X)·µí·µñ` is a sheaf, by showing that a certain
cone is a limit cone.

See `isSheaf_principalsKanExtension` for the main application.
-/
def isLimit {X : TopCat.{v}} [Preorder X] [Topology.IsUpperSet X]
    (F : X ‚•§ C)
    (Œ± : Type v) (Us : Œ± ‚Üí Opens X) :
    IsLimit (mapCone (principalsKanExtension F) (opensLeCoverCocone Us).op) where
  lift S := limit.lift _ (lowerCone Us S)
  fac := by
    rintro S ‚ü®V, i, hV‚ü©
    dsimp [forget, opensLeCoverCocone]
    ext ‚ü®_, x, f‚ü©
    simp only [comp_obj, StructuredArrow.proj_obj, Category.assoc, limit.lift_œÄ, lowerCone_pt,
      lowerCone_œÄ_app, const_obj_obj, projSup_obj, StructuredArrow.map_obj_right, op_obj,
      ObjectProperty.Œπ_obj, pointwiseRightKanExtension_obj]
    have e : principalOpen x ‚â§ V := f.unop.le
    let VV : (ObjectProperty.FullSubcategory fun V => ‚àÉ i, V ‚â§ Us i) := ‚ü®V, i, hV‚ü©
    let xx : (ObjectProperty.FullSubcategory fun V => ‚àÉ i, V ‚â§ Us i) :=
      ‚ü®principalOpen x, i, le_trans e hV‚ü©
    let ee : xx ‚ü∂ VV := e.hom
    rw [‚Üê S.w ee.op, Category.assoc]
    congr 1
    simp only [comp_obj, op_obj, ObjectProperty.Œπ_obj, pointwiseRightKanExtension_obj,
      Functor.comp_map, op_map, Quiver.Hom.unop_op,
      pointwiseRightKanExtension_map, limit.lift_œÄ, xx, VV]
    congr
  uniq := by
    intro S m hm
    dsimp
    symm
    ext ‚ü®_, x, f‚ü©
    simp only [lowerCone_pt, comp_obj, limit.lift_œÄ, lowerCone_œÄ_app, const_obj_obj, projSup_obj,
      op_obj, ObjectProperty.Œπ_obj, pointwiseRightKanExtension_obj]
    specialize hm ‚ü®principalOpen x, ?_‚ü©
    ¬∑ apply exists_le_of_le_sup
      exact f.unop.le
    ¬∑ rw [‚Üê hm]
      simp only [mapCone_pt, Cocone.op_pt, pointwiseRightKanExtension_obj,
        const_obj_obj, comp_obj, op_obj, ObjectProperty.Œπ_obj, mapCone_œÄ_app, Cocone.op_œÄ,
        NatTrans.op_app, pointwiseRightKanExtension_map, Category.assoc, limit.lift_œÄ]
      congr

theorem isSheaf_principalsKanExtension
    {X : TopCat.{v}} [Preorder X] [Topology.IsUpperSet X] (F : X ‚•§ C) :
    Presheaf.IsSheaf (principalsKanExtension F) := by
  rw [isSheaf_iff_isSheafOpensLeCover]
  intro Œπ Us
  constructor
  apply isLimit

end Alexandrov

open Alexandrov

/--
The main theorem of this file.
If `X` is a topological space and preorder whose topology is the `UpperSet` topology associated
with the preorder, `F : X ‚•§ C` is a functor into a complete category from the preorder category,
and `P : (Opens X)·µí·µñ ‚•§ C` denotes the right Kan extension of `F` along the
functor `X ‚•§ (Open X)·µí·µñ` which sends `x : X` to `{y | x ‚â§ y}`, then `P` is a sheaf.
-/
theorem Topology.IsUpperSet.isSheaf_of_isRightKanExtension
    (P : (Opens X)·µí·µñ ‚•§ C)
    (Œ∑ : Alexandrov.principals X ‚ãô P ‚ü∂ F)
    [P.IsRightKanExtension Œ∑] :
    Presheaf.IsSheaf (Opens.grothendieckTopology X) P := by
  let Œ≥ : principals X ‚ãô principalsKanExtension F ‚ü∂ F :=
    (principals X).pointwiseRightKanExtensionCounit F
  let _ : (principalsKanExtension F).IsRightKanExtension Œ≥ := inferInstance
  have : P ‚âÖ principalsKanExtension F :=
    @rightKanExtensionUnique _ _ _ _ _ _ _ _ _ _ (by assumption) _ _ (by assumption)
  change TopCat.Presheaf.IsSheaf (X := TopCat.of X) P
  rw [isSheaf_iso_iff this]
  let _ : Preorder (TopCat.of X) := inferInstanceAs <| Preorder X
  have _ : Topology.IsUpperSet (TopCat.of X) := inferInstanceAs <| Topology.IsUpperSet X
  exact isSheaf_principalsKanExtension (X := TopCat.of X) F
