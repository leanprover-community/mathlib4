/-
Copyright (c) 2021 Justus Springer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Justus Springer

! This file was ported from Lean 3 source module topology.sheaves.sheaf_condition.sites
! leanprover-community/mathlib commit d39590fc8728fbf6743249802486f8c91ffe07bc
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Sites.Spaces
import Mathbin.Topology.Sheaves.Sheaf
import Mathbin.CategoryTheory.Sites.DenseSubsite

/-!

# Coverings and sieves; from sheaves on sites and sheaves on spaces

In this file, we connect coverings in a topological space to sieves in the associated Grothendieck
topology, in preparation of connecting the sheaf condition on sites to the various sheaf conditions
on spaces.

We also specialize results about sheaves on sites to sheaves on spaces; we show that the inclusion
functor from a topological basis to `topological_space.opens` is cover_dense, that open maps
induce cover_preserving functors, and that open embeddings induce compatible_preserving functors.

-/


noncomputable section

universe w v u

open CategoryTheory TopologicalSpace

namespace TopCat.Presheaf

variable {X : TopCat.{w}}

/-- Given a presieve `R` on `U`, we obtain a covering family of open sets in `X`, by taking as index
type the type of dependent pairs `(V, f)`, where `f : V ‚ü∂ U` is in `R`.
-/
def coveringOfPresieve (U : Opens X) (R : Presieve U) : (Œ£V, { f : V ‚ü∂ U // R f }) ‚Üí Opens X :=
  fun f => f.1
#align Top.presheaf.covering_of_presieve TopCat.Presheaf.coveringOfPresieve

@[simp]
theorem coveringOfPresieve_apply (U : Opens X) (R : Presieve U) (f : Œ£V, { f : V ‚ü∂ U // R f }) :
    coveringOfPresieve U R f = f.1 :=
  rfl
#align Top.presheaf.covering_of_presieve_apply TopCat.Presheaf.coveringOfPresieve_apply

namespace CoveringOfPresieve

variable (U : Opens X) (R : Presieve U)

/--
If `R` is a presieve in the grothendieck topology on `opens X`, the covering family associated to
`R` really is _covering_, i.e. the union of all open sets equals `U`.
-/
theorem iSup_eq_of_mem_grothendieck (hR : Sieve.generate R ‚àà Opens.grothendieckTopology X U) :
    iSup (coveringOfPresieve U R) = U := by
  apply le_antisymm
  ¬∑ refine' iSup_le _
    intro f
    exact f.2.1.le
  intro x hxU
  rw [opens.mem_supr]
  obtain ‚ü®V, iVU, ‚ü®W, iVW, iWU, hiWU, -‚ü©, hxV‚ü© := hR x hxU
  exact ‚ü®‚ü®W, ‚ü®iWU, hiWU‚ü©‚ü©, iVW.le hxV‚ü©
#align Top.presheaf.covering_of_presieve.supr_eq_of_mem_grothendieck TopCat.Presheaf.coveringOfPresieve.iSup_eq_of_mem_grothendieck

end CoveringOfPresieve

/-- Given a family of opens `U : Œπ ‚Üí opens X` and any open `Y : opens X`, we obtain a presieve
on `Y` by declaring that a morphism `f : V ‚ü∂ Y` is a member of the presieve if and only if
there exists an index `i : Œπ` such that `V = U i`.
-/
def presieveOfCoveringAux {Œπ : Type v} (U : Œπ ‚Üí Opens X) (Y : Opens X) : Presieve Y := fun V f =>
  ‚àÉ i, V = U i
#align Top.presheaf.presieve_of_covering_aux TopCat.Presheaf.presieveOfCoveringAux

/-- Take `Y` to be `supr U` and obtain a presieve over `supr U`. -/
def presieveOfCovering {Œπ : Type v} (U : Œπ ‚Üí Opens X) : Presieve (iSup U) :=
  presieveOfCoveringAux U (iSup U)
#align Top.presheaf.presieve_of_covering TopCat.Presheaf.presieveOfCovering

/-- Given a presieve `R` on `Y`, if we take its associated family of opens via
    `covering_of_presieve` (which may not cover `Y` if `R` is not covering), and take
    the presieve on `Y` associated to the family of opens via `presieve_of_covering_aux`,
    then we get back the original presieve `R`. -/
@[simp]
theorem covering_presieve_eq_self {Y : Opens X} (R : Presieve Y) :
    presieveOfCoveringAux (coveringOfPresieve Y R) Y = R :=
  by
  ext (Z f)
  exact ‚ü®fun ‚ü®‚ü®_, _, h‚ü©, rfl‚ü© => by convert h, fun h => ‚ü®‚ü®Z, f, h‚ü©, rfl‚ü©‚ü©
#align Top.presheaf.covering_presieve_eq_self TopCat.Presheaf.covering_presieve_eq_self

namespace PresieveOfCovering

variable {Œπ : Type v} (U : Œπ ‚Üí Opens X)

/-- The sieve generated by `presieve_of_covering U` is a member of the grothendieck topology.
-/
theorem mem_grothendieckTopology :
    Sieve.generate (presieveOfCovering U) ‚àà Opens.grothendieckTopology X (iSup U) :=
  by
  intro x hx
  obtain ‚ü®i, hxi‚ü© := opens.mem_supr.mp hx
  exact ‚ü®U i, opens.le_supr U i, ‚ü®U i, ùüô _, opens.le_supr U i, ‚ü®i, rfl‚ü©, category.id_comp _‚ü©, hxi‚ü©
#align Top.presheaf.presieve_of_covering.mem_grothendieck_topology TopCat.Presheaf.presieveOfCovering.mem_grothendieckTopology

/-- An index `i : Œπ` can be turned into a dependent pair `(V, f)`, where `V` is an open set and
`f : V ‚ü∂ supr U` is a member of `presieve_of_covering U f`.
-/
def homOfIndex (i : Œπ) : Œ£V, { f : V ‚ü∂ iSup U // presieveOfCovering U f } :=
  ‚ü®U i, Opens.leSupr U i, i, rfl‚ü©
#align Top.presheaf.presieve_of_covering.hom_of_index TopCat.Presheaf.presieveOfCovering.homOfIndex

/-- By using the axiom of choice, a dependent pair `(V, f)` where `f : V ‚ü∂ supr U` is a member of
`presieve_of_covering U f` can be turned into an index `i : Œπ`, such that `V = U i`.
-/
def indexOfHom (f : Œ£V, { f : V ‚ü∂ iSup U // presieveOfCovering U f }) : Œπ :=
  f.2.2.some
#align Top.presheaf.presieve_of_covering.index_of_hom TopCat.Presheaf.presieveOfCovering.indexOfHom

theorem indexOfHom_spec (f : Œ£V, { f : V ‚ü∂ iSup U // presieveOfCovering U f }) :
    f.1 = U (indexOfHom U f) :=
  f.2.2.choose_spec
#align Top.presheaf.presieve_of_covering.index_of_hom_spec TopCat.Presheaf.presieveOfCovering.indexOfHom_spec

end PresieveOfCovering

end TopCat.Presheaf

namespace TopCat.Opens

variable {X : TopCat} {Œπ : Type _}

theorem coverDense_iff_isBasis [Category Œπ] (B : Œπ ‚•§ Opens X) :
    CoverDense (Opens.grothendieckTopology X) B ‚Üî Opens.IsBasis (Set.range B.obj) :=
  by
  rw [opens.is_basis_iff_nbhd]
  constructor; intro hd U x hx; rcases hd.1 U x hx with ‚ü®V, f, ‚ü®i, f‚ÇÅ, f‚ÇÇ, hc‚ü©, hV‚ü©
  exact ‚ü®B.obj i, ‚ü®i, rfl‚ü©, f‚ÇÅ.le hV, f‚ÇÇ.le‚ü©
  intro hb; constructor; intro U x hx; rcases hb hx with ‚ü®_, ‚ü®i, rfl‚ü©, hx, hi‚ü©
  exact ‚ü®B.obj i, ‚ü®‚ü®hi‚ü©‚ü©, ‚ü®‚ü®i, ùüô _, ‚ü®‚ü®hi‚ü©‚ü©, rfl‚ü©‚ü©, hx‚ü©
#align Top.opens.cover_dense_iff_is_basis TopCat.Opens.coverDense_iff_isBasis

theorem coverDense_inducedFunctor {B : Œπ ‚Üí Opens X} (h : Opens.IsBasis (Set.range B)) :
    CoverDense (Opens.grothendieckTopology X) (inducedFunctor B) :=
  (coverDense_iff_isBasis _).2 h
#align Top.opens.cover_dense_induced_functor TopCat.Opens.coverDense_inducedFunctor

end TopCat.Opens

section OpenEmbedding

open TopCat.Presheaf Opposite

variable {C : Type u} [Category.{v} C]

variable {X Y : TopCat.{w}} {f : X ‚ü∂ Y} {F : Y.Presheaf C}

theorem OpenEmbedding.compatiblePreserving (hf : OpenEmbedding f) :
    CompatiblePreserving (Opens.grothendieckTopology Y) hf.IsOpenMap.Functor :=
  by
  haveI : mono f := (TopCat.mono_iff_injective f).mpr hf.inj
  apply compatible_preserving_of_downwards_closed
  intro U V i
  refine'
    ‚ü®(opens.map f).obj V, eq_to_iso <| opens.ext <| Set.image_preimage_eq_of_subset fun x h => _‚ü©
  obtain ‚ü®_, _, rfl‚ü© := i.le h
  exact ‚ü®_, rfl‚ü©
#align open_embedding.compatible_preserving OpenEmbedding.compatiblePreserving

theorem IsOpenMap.coverPreserving (hf : IsOpenMap f) :
    CoverPreserving (Opens.grothendieckTopology X) (Opens.grothendieckTopology Y) hf.Functor :=
  by
  constructor
  rintro U S hU _ ‚ü®x, hx, rfl‚ü©
  obtain ‚ü®V, i, hV, hxV‚ü© := hU x hx
  exact ‚ü®_, hf.functor.map i, ‚ü®_, i, ùüô _, hV, rfl‚ü©, Set.mem_image_of_mem f hxV‚ü©
#align is_open_map.cover_preserving IsOpenMap.coverPreserving

theorem TopCat.Presheaf.isSheaf_of_openEmbedding (h : OpenEmbedding f) (hF : F.IsSheaf) :
    IsSheaf (h.IsOpenMap.Functor.op ‚ãô F) :=
  pullback_isSheaf_of_coverPreserving h.CompatiblePreserving h.IsOpenMap.CoverPreserving ‚ü®_, hF‚ü©
#align Top.presheaf.is_sheaf_of_open_embedding TopCat.Presheaf.isSheaf_of_openEmbedding

end OpenEmbedding

namespace TopCat.Sheaf

open TopCat Opposite

variable {C : Type u} [Category.{v} C]

variable {X : TopCat.{w}} {Œπ : Type _} {B : Œπ ‚Üí Opens X}

variable (F : X.Presheaf C) (F' : Sheaf C X) (h : Opens.IsBasis (Set.range B))

/-- The empty component of a sheaf is terminal -/
def isTerminalOfEmpty (F : Sheaf C X) : Limits.IsTerminal (F.val.obj (op ‚ä•)) :=
  F.isTerminalOfBotCover ‚ä• (by tidy)
#align Top.sheaf.is_terminal_of_empty TopCat.Sheaf.isTerminalOfEmpty

/-- A variant of `is_terminal_of_empty` that is easier to `apply`. -/
def isTerminalOfEqEmpty (F : X.Sheaf C) {U : Opens X} (h : U = ‚ä•) :
    Limits.IsTerminal (F.val.obj (op U)) := by convert F.is_terminal_of_empty
#align Top.sheaf.is_terminal_of_eq_empty TopCat.Sheaf.isTerminalOfEqEmpty

/-- If a family `B` of open sets forms a basis of the topology on `X`, and if `F'`
    is a sheaf on `X`, then a homomorphism between a presheaf `F` on `X` and `F'`
    is equivalent to a homomorphism between their restrictions to the indexing type
    `Œπ` of `B`, with the induced category structure on `Œπ`. -/
def restrictHomEquivHom : ((inducedFunctor B).op ‚ãô F ‚ü∂ (inducedFunctor B).op ‚ãô F'.1) ‚âÉ (F ‚ü∂ F'.1) :=
  @CoverDense.restrictHomEquivHom _ _ _ _ _ _ _ _ (Opens.coverDense_inducedFunctor h) _ F F'
#align Top.sheaf.restrict_hom_equiv_hom TopCat.Sheaf.restrictHomEquivHom

@[simp]
theorem extend_hom_app (Œ± : (inducedFunctor B).op ‚ãô F ‚ü∂ (inducedFunctor B).op ‚ãô F'.1) (i : Œπ) :
    (restrictHomEquivHom F F' h Œ±).app (op (B i)) = Œ±.app (op i) :=
  by
  nth_rw 2 [‚Üê (restrict_hom_equiv_hom F F' h).left_inv Œ±]
  rfl
#align Top.sheaf.extend_hom_app TopCat.Sheaf.extend_hom_app

include h

theorem hom_ext {Œ± Œ≤ : F ‚ü∂ F'.1} (he : ‚àÄ i, Œ±.app (op (B i)) = Œ≤.app (op (B i))) : Œ± = Œ≤ :=
  by
  apply (restrict_hom_equiv_hom F F' h).symm.Injective
  ext i
  exact he i.unop
#align Top.sheaf.hom_ext TopCat.Sheaf.hom_ext

end TopCat.Sheaf

