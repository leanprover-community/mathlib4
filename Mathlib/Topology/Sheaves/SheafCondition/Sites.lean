/-
Copyright (c) 2021 Justus Springer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Justus Springer
-/
import Mathlib.CategoryTheory.Sites.Spaces
import Mathlib.Topology.Sheaves.Sheaf
import Mathlib.CategoryTheory.Sites.DenseSubsite

#align_import topology.sheaves.sheaf_condition.sites from "leanprover-community/mathlib"@"d39590fc8728fbf6743249802486f8c91ffe07bc"

/-!

# Coverings and sieves; from sheaves on sites and sheaves on spaces

In this file, we connect coverings in a topological space to sieves in the associated Grothendieck
topology, in preparation of connecting the sheaf condition on sites to the various sheaf conditions
on spaces.

We also specialize results about sheaves on sites to sheaves on spaces; we show that the inclusion
functor from a topological basis to `TopologicalSpace.Opens` is `CoverDense`, that open maps
induce `CoverPreserving` functors, and that open embeddings induce `CompatiblePreserving` functors.

-/


noncomputable section

set_option linter.uppercaseLean3 false -- Porting note: Added because of too many false positives

universe w v u

open CategoryTheory TopologicalSpace

namespace TopCat.Presheaf

variable {X : TopCat.{w}}

/-- Given a presieve `R` on `U`, we obtain a covering family of open sets in `X`, by taking as index
type the type of dependent pairs `(V, f)`, where `f : V âŸ¶ U` is in `R`.
-/
def coveringOfPresieve (U : Opens X) (R : Presieve U) : (Î£V, { f : V âŸ¶ U // R f }) â†’ Opens X :=
  fun f => f.1
#align Top.presheaf.covering_of_presieve TopCat.Presheaf.coveringOfPresieve

@[simp]
theorem coveringOfPresieve_apply (U : Opens X) (R : Presieve U) (f : Î£V, { f : V âŸ¶ U // R f }) :
    coveringOfPresieve U R f = f.1 := rfl
#align Top.presheaf.covering_of_presieve_apply TopCat.Presheaf.coveringOfPresieve_apply

namespace coveringOfPresieve

variable (U : Opens X) (R : Presieve U)

/-- If `R` is a presieve in the grothendieck topology on `Opens X`, the covering family associated
to `R` really is _covering_, i.e. the union of all open sets equals `U`.
-/
theorem iSup_eq_of_mem_grothendieck (hR : Sieve.generate R âˆˆ Opens.grothendieckTopology X U) :
    iSup (coveringOfPresieve U R) = U := by
  apply le_antisymm
  -- âŠ¢ iSup (coveringOfPresieve U R) â‰¤ U
  Â· refine' iSup_le _
    -- âŠ¢ âˆ€ (i : (V : Opens â†‘X) Ã— { f // R f }), coveringOfPresieve U R i â‰¤ U
    intro f
    -- âŠ¢ coveringOfPresieve U R f â‰¤ U
    exact f.2.1.le
    -- ğŸ‰ no goals
  intro x hxU
  -- âŠ¢ x âˆˆ â†‘(iSup (coveringOfPresieve U R))
  rw [Opens.coe_iSup, Set.mem_iUnion]
  -- âŠ¢ âˆƒ i, x âˆˆ â†‘(coveringOfPresieve U R i)
  obtain âŸ¨V, iVU, âŸ¨W, iVW, iWU, hiWU, -âŸ©, hxVâŸ© := hR x hxU
  -- âŠ¢ âˆƒ i, x âˆˆ â†‘(coveringOfPresieve U R i)
  exact âŸ¨âŸ¨W, âŸ¨iWU, hiWUâŸ©âŸ©, iVW.le hxVâŸ©
  -- ğŸ‰ no goals
#align Top.presheaf.covering_of_presieve.supr_eq_of_mem_grothendieck TopCat.Presheaf.coveringOfPresieve.iSup_eq_of_mem_grothendieck

end coveringOfPresieve

/-- Given a family of opens `U : Î¹ â†’ Opens X` and any open `Y : Opens X`, we obtain a presieve
on `Y` by declaring that a morphism `f : V âŸ¶ Y` is a member of the presieve if and only if
there exists an index `i : Î¹` such that `V = U i`.
-/
def presieveOfCoveringAux {Î¹ : Type v} (U : Î¹ â†’ Opens X) (Y : Opens X) : Presieve Y :=
  fun V _ => âˆƒ i, V = U i
#align Top.presheaf.presieve_of_covering_aux TopCat.Presheaf.presieveOfCoveringAux

/-- Take `Y` to be `iSup U` and obtain a presieve over `iSup U`. -/
def presieveOfCovering {Î¹ : Type v} (U : Î¹ â†’ Opens X) : Presieve (iSup U) :=
  presieveOfCoveringAux U (iSup U)
#align Top.presheaf.presieve_of_covering TopCat.Presheaf.presieveOfCovering

/-- Given a presieve `R` on `Y`, if we take its associated family of opens via
    `coveringOfPresieve` (which may not cover `Y` if `R` is not covering), and take
    the presieve on `Y` associated to the family of opens via `presieveOfCoveringAux`,
    then we get back the original presieve `R`. -/
@[simp]
theorem covering_presieve_eq_self {Y : Opens X} (R : Presieve Y) :
    presieveOfCoveringAux (coveringOfPresieve Y R) Y = R := by
  funext Z
  -- âŠ¢ presieveOfCoveringAux (coveringOfPresieve Y R) Y = R
  ext f
  -- âŠ¢ f âˆˆ presieveOfCoveringAux (coveringOfPresieve Y R) Y â†” f âˆˆ R
  exact âŸ¨fun âŸ¨âŸ¨_, f', hâŸ©, rflâŸ© => by rwa [Subsingleton.elim f f'], fun h => âŸ¨âŸ¨Z, f, hâŸ©, rflâŸ©âŸ©
  -- ğŸ‰ no goals
#align Top.presheaf.covering_presieve_eq_self TopCat.Presheaf.covering_presieve_eq_self

namespace presieveOfCovering

variable {Î¹ : Type v} (U : Î¹ â†’ Opens X)

/-- The sieve generated by `presieveOfCovering U` is a member of the grothendieck topology.
-/
theorem mem_grothendieckTopology :
    Sieve.generate (presieveOfCovering U) âˆˆ Opens.grothendieckTopology X (iSup U) := by
  intro x hx
  -- âŠ¢ âˆƒ U_1 f, (Sieve.generate (presieveOfCovering U)).arrows f âˆ§ x âˆˆ U_1
  obtain âŸ¨i, hxiâŸ© := Opens.mem_iSup.mp hx
  -- âŠ¢ âˆƒ U_1 f, (Sieve.generate (presieveOfCovering U)).arrows f âˆ§ x âˆˆ U_1
  exact âŸ¨U i, Opens.leSupr U i, âŸ¨U i, ğŸ™ _, Opens.leSupr U i, âŸ¨i, rflâŸ©, Category.id_comp _âŸ©, hxiâŸ©
  -- ğŸ‰ no goals
#align Top.presheaf.presieve_of_covering.mem_grothendieck_topology TopCat.Presheaf.presieveOfCovering.mem_grothendieckTopology

/-- An index `i : Î¹` can be turned into a dependent pair `(V, f)`, where `V` is an open set and
`f : V âŸ¶ iSup U` is a member of `presieveOfCovering U f`.
-/
def homOfIndex (i : Î¹) : Î£V, { f : V âŸ¶ iSup U // presieveOfCovering U f } :=
  âŸ¨U i, Opens.leSupr U i, i, rflâŸ©
#align Top.presheaf.presieve_of_covering.hom_of_index TopCat.Presheaf.presieveOfCovering.homOfIndex

/-- By using the axiom of choice, a dependent pair `(V, f)` where `f : V âŸ¶ iSup U` is a member of
`presieveOfCovering U f` can be turned into an index `i : Î¹`, such that `V = U i`.
-/
def indexOfHom (f : Î£V, { f : V âŸ¶ iSup U // presieveOfCovering U f }) : Î¹ :=
  f.2.2.choose
#align Top.presheaf.presieve_of_covering.index_of_hom TopCat.Presheaf.presieveOfCovering.indexOfHom

theorem indexOfHom_spec (f : Î£V, { f : V âŸ¶ iSup U // presieveOfCovering U f }) :
    f.1 = U (indexOfHom U f) :=
  f.2.2.choose_spec
#align Top.presheaf.presieve_of_covering.index_of_hom_spec TopCat.Presheaf.presieveOfCovering.indexOfHom_spec

end presieveOfCovering

end TopCat.Presheaf

namespace TopCat.Opens

variable {X : TopCat} {Î¹ : Type*}

theorem coverDense_iff_isBasis [Category Î¹] (B : Î¹ â¥¤ Opens X) :
    CoverDense (Opens.grothendieckTopology X) B â†” Opens.IsBasis (Set.range B.obj) := by
  rw [Opens.isBasis_iff_nbhd]
  -- âŠ¢ CoverDense (Opens.grothendieckTopology â†‘X) B â†” âˆ€ {U : Opens â†‘X} {x : â†‘X}, x  â€¦
  constructor; intro hd U x hx; rcases hd.1 U x hx with âŸ¨V, f, âŸ¨i, fâ‚, fâ‚‚, _âŸ©, hVâŸ©
  -- âŠ¢ CoverDense (Opens.grothendieckTopology â†‘X) B â†’ âˆ€ {U : Opens â†‘X} {x : â†‘X}, x  â€¦
               -- âŠ¢ âˆƒ U', U' âˆˆ Set.range B.obj âˆ§ x âˆˆ U' âˆ§ U' â‰¤ U
                                -- âŠ¢ âˆƒ U', U' âˆˆ Set.range B.obj âˆ§ x âˆˆ U' âˆ§ U' â‰¤ U
  exact âŸ¨B.obj i, âŸ¨i, rflâŸ©, fâ‚.le hV, fâ‚‚.leâŸ©
  -- âŠ¢ (âˆ€ {U : Opens â†‘X} {x : â†‘X}, x âˆˆ U â†’ âˆƒ U', U' âˆˆ Set.range B.obj âˆ§ x âˆˆ U' âˆ§ U' â€¦
  intro hb; constructor; intro U x hx; rcases hb hx with âŸ¨_, âŸ¨i, rflâŸ©, hx, hiâŸ©
  -- âŠ¢ CoverDense (Opens.grothendieckTopology â†‘X) B
            -- âŠ¢ âˆ€ (U : Opens â†‘X), Sieve.coverByImage B U âˆˆ GrothendieckTopology.sieves (Open â€¦
                         -- âŠ¢ âˆƒ U_1 f, (Sieve.coverByImage B U).arrows f âˆ§ x âˆˆ U_1
                                       -- âŠ¢ âˆƒ U_1 f, (Sieve.coverByImage B U).arrows f âˆ§ x âˆˆ U_1
  exact âŸ¨B.obj i, âŸ¨âŸ¨hiâŸ©âŸ©, âŸ¨âŸ¨i, ğŸ™ _, âŸ¨âŸ¨hiâŸ©âŸ©, rflâŸ©âŸ©, hxâŸ©
  -- ğŸ‰ no goals
#align Top.opens.cover_dense_iff_is_basis TopCat.Opens.coverDense_iff_isBasis

theorem coverDense_inducedFunctor {B : Î¹ â†’ Opens X} (h : Opens.IsBasis (Set.range B)) :
    CoverDense (Opens.grothendieckTopology X) (inducedFunctor B) :=
  (coverDense_iff_isBasis _).2 h
#align Top.opens.cover_dense_induced_functor TopCat.Opens.coverDense_inducedFunctor

end TopCat.Opens

section OpenEmbedding

open TopCat.Presheaf Opposite

variable {C : Type u} [Category.{v} C]

variable {X Y : TopCat.{w}} {f : X âŸ¶ Y} {F : Y.Presheaf C}

theorem OpenEmbedding.compatiblePreserving (hf : OpenEmbedding f) :
    CompatiblePreserving (Opens.grothendieckTopology Y) hf.isOpenMap.functor := by
  haveI : Mono f := (TopCat.mono_iff_injective f).mpr hf.inj
  -- âŠ¢ CompatiblePreserving (Opens.grothendieckTopology â†‘Y) (IsOpenMap.functor (_ : â€¦
  apply compatiblePreservingOfDownwardsClosed
  -- âŠ¢ {c : Opens â†‘X} â†’ {d : Opens â†‘Y} â†’ (d âŸ¶ (IsOpenMap.functor (_ : IsOpenMap â†‘f) â€¦
  intro U V i
  -- âŠ¢ (c' : Opens â†‘X) Ã— ((IsOpenMap.functor (_ : IsOpenMap â†‘f)).obj c' â‰… V)
  refine' âŸ¨(Opens.map f).obj V, eqToIso <| Opens.ext <| Set.image_preimage_eq_of_subset fun x h â†¦ _âŸ©
  -- âŠ¢ x âˆˆ Set.range fun x => â†‘f x
  obtain âŸ¨_, _, rflâŸ© := i.le h
  -- âŠ¢ â†‘f wâœ âˆˆ Set.range fun x => â†‘f x
  exact âŸ¨_, rflâŸ©
  -- ğŸ‰ no goals
#align open_embedding.compatible_preserving OpenEmbedding.compatiblePreserving

theorem IsOpenMap.coverPreserving (hf : IsOpenMap f) :
    CoverPreserving (Opens.grothendieckTopology X) (Opens.grothendieckTopology Y) hf.functor := by
  constructor
  -- âŠ¢ âˆ€ {U : Opens â†‘X} {S : Sieve U}, S âˆˆ GrothendieckTopology.sieves (Opens.groth â€¦
  rintro U S hU _ âŸ¨x, hx, rflâŸ©
  -- âŠ¢ âˆƒ U_1 f_1, (Sieve.functorPushforward (functor hf) S).arrows f_1 âˆ§ â†‘f x âˆˆ U_1
  obtain âŸ¨V, i, hV, hxVâŸ© := hU x hx
  -- âŠ¢ âˆƒ U_1 f_1, (Sieve.functorPushforward (functor hf) S).arrows f_1 âˆ§ â†‘f x âˆˆ U_1
  exact âŸ¨_, hf.functor.map i, âŸ¨_, i, ğŸ™ _, hV, rflâŸ©, Set.mem_image_of_mem f hxVâŸ©
  -- ğŸ‰ no goals
#align is_open_map.cover_preserving IsOpenMap.coverPreserving

theorem TopCat.Presheaf.isSheaf_of_openEmbedding (h : OpenEmbedding f) (hF : F.IsSheaf) :
    IsSheaf (h.isOpenMap.functor.op â‹™ F) :=
  pullback_isSheaf_of_coverPreserving h.compatiblePreserving h.isOpenMap.coverPreserving âŸ¨_, hFâŸ©
#align Top.presheaf.is_sheaf_of_open_embedding TopCat.Presheaf.isSheaf_of_openEmbedding

end OpenEmbedding

namespace TopCat.Sheaf

open TopCat Opposite

variable {C : Type u} [Category.{v} C]

variable {X : TopCat.{w}} {Î¹ : Type*} {B : Î¹ â†’ Opens X}

variable (F : X.Presheaf C) (F' : Sheaf C X) (h : Opens.IsBasis (Set.range B))

/-- The empty component of a sheaf is terminal. -/
def isTerminalOfEmpty (F : Sheaf C X) : Limits.IsTerminal (F.val.obj (op âŠ¥)) :=
  F.isTerminalOfBotCover âŠ¥ (fun _ h => h.elim)
#align Top.sheaf.is_terminal_of_empty TopCat.Sheaf.isTerminalOfEmpty

/-- A variant of `isTerminalOfEmpty` that is easier to `apply`. -/
def isTerminalOfEqEmpty (F : X.Sheaf C) {U : Opens X} (h : U = âŠ¥) :
    Limits.IsTerminal (F.val.obj (op U)) := by
  convert F.isTerminalOfEmpty
  -- ğŸ‰ no goals
#align Top.sheaf.is_terminal_of_eq_empty TopCat.Sheaf.isTerminalOfEqEmpty

/-- If a family `B` of open sets forms a basis of the topology on `X`, and if `F'`
    is a sheaf on `X`, then a homomorphism between a presheaf `F` on `X` and `F'`
    is equivalent to a homomorphism between their restrictions to the indexing type
    `Î¹` of `B`, with the induced category structure on `Î¹`. -/
def restrictHomEquivHom : ((inducedFunctor B).op â‹™ F âŸ¶ (inducedFunctor B).op â‹™ F'.1) â‰ƒ (F âŸ¶ F'.1) :=
  @CoverDense.restrictHomEquivHom _ _ _ _ _ _ _ _ (Opens.coverDense_inducedFunctor h) _ F F'
#align Top.sheaf.restrict_hom_equiv_hom TopCat.Sheaf.restrictHomEquivHom

@[simp]
theorem extend_hom_app (Î± : (inducedFunctor B).op â‹™ F âŸ¶ (inducedFunctor B).op â‹™ F'.1) (i : Î¹) :
    (restrictHomEquivHom F F' h Î±).app (op (B i)) = Î±.app (op i) := by
  nth_rw 2 [â† (restrictHomEquivHom F F' h).left_inv Î±]
  -- âŠ¢ NatTrans.app (â†‘(restrictHomEquivHom F F' h) Î±) (op (B i)) = NatTrans.app (Eq â€¦
  rfl
  -- ğŸ‰ no goals
#align Top.sheaf.extend_hom_app TopCat.Sheaf.extend_hom_app

theorem hom_ext {Î± Î² : F âŸ¶ F'.1} (he : âˆ€ i, Î±.app (op (B i)) = Î².app (op (B i))) : Î± = Î² := by
  apply (restrictHomEquivHom F F' h).symm.injective
  -- âŠ¢ â†‘(restrictHomEquivHom F F' h).symm Î± = â†‘(restrictHomEquivHom F F' h).symm Î²
  ext i
  -- âŠ¢ NatTrans.app (â†‘(restrictHomEquivHom F F' h).symm Î±) i = NatTrans.app (â†‘(rest â€¦
  exact he i.unop
  -- ğŸ‰ no goals
#align Top.sheaf.hom_ext TopCat.Sheaf.hom_ext

end TopCat.Sheaf
