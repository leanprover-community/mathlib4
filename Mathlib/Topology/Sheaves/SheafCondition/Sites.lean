/-
Copyright (c) 2021 Justus Springer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Justus Springer
-/
import Mathlib.CategoryTheory.Sites.Spaces
import Mathlib.Topology.Sheaves.Sheaf
import Mathlib.CategoryTheory.Sites.DenseSubsite

#align_import topology.sheaves.sheaf_condition.sites from "leanprover-community/mathlib"@"d39590fc8728fbf6743249802486f8c91ffe07bc"

/-!

# Coverings and sieves; from sheaves on sites and sheaves on spaces

In this file, we connect coverings in a topological space to sieves in the associated Grothendieck
topology, in preparation of connecting the sheaf condition on sites to the various sheaf conditions
on spaces.

We also specialize results about sheaves on sites to sheaves on spaces; we show that the inclusion
functor from a topological basis to `TopologicalSpace.Opens` is cover dense, that open maps
induce cover preserving functors, and that open embeddings induce continuous functors.

-/


noncomputable section

set_option linter.uppercaseLean3 false

universe w v u

open CategoryTheory TopologicalSpace

namespace TopCat.Presheaf

variable {X : TopCat.{w}}

/-- Given a presieve `R` on `U`, we obtain a covering family of open sets in `X`, by taking as index
type the type of dependent pairs `(V, f)`, where `f : V ‚ü∂ U` is in `R`.
-/
def coveringOfPresieve (U : Opens X) (R : Presieve U) : (Œ£V, { f : V ‚ü∂ U // R f }) ‚Üí Opens X :=
  fun f => f.1
#align Top.presheaf.covering_of_presieve TopCat.Presheaf.coveringOfPresieve

@[simp]
theorem coveringOfPresieve_apply (U : Opens X) (R : Presieve U) (f : Œ£V, { f : V ‚ü∂ U // R f }) :
    coveringOfPresieve U R f = f.1 := rfl
#align Top.presheaf.covering_of_presieve_apply TopCat.Presheaf.coveringOfPresieve_apply

namespace coveringOfPresieve

variable (U : Opens X) (R : Presieve U)

/-- If `R` is a presieve in the grothendieck topology on `Opens X`, the covering family associated
to `R` really is _covering_, i.e. the union of all open sets equals `U`.
-/
theorem iSup_eq_of_mem_grothendieck (hR : Sieve.generate R ‚àà Opens.grothendieckTopology X U) :
    iSup (coveringOfPresieve U R) = U := by
  apply le_antisymm
  ¬∑ refine iSup_le ?_
    intro f
    exact f.2.1.le
  intro x hxU
  rw [Opens.coe_iSup, Set.mem_iUnion]
  obtain ‚ü®V, iVU, ‚ü®W, iVW, iWU, hiWU, -‚ü©, hxV‚ü© := hR x hxU
  exact ‚ü®‚ü®W, ‚ü®iWU, hiWU‚ü©‚ü©, iVW.le hxV‚ü©
#align Top.presheaf.covering_of_presieve.supr_eq_of_mem_grothendieck TopCat.Presheaf.coveringOfPresieve.iSup_eq_of_mem_grothendieck

end coveringOfPresieve

/-- Given a family of opens `U : Œπ ‚Üí Opens X` and any open `Y : Opens X`, we obtain a presieve
on `Y` by declaring that a morphism `f : V ‚ü∂ Y` is a member of the presieve if and only if
there exists an index `i : Œπ` such that `V = U i`.
-/
def presieveOfCoveringAux {Œπ : Type v} (U : Œπ ‚Üí Opens X) (Y : Opens X) : Presieve Y :=
  fun V _ => ‚àÉ i, V = U i
#align Top.presheaf.presieve_of_covering_aux TopCat.Presheaf.presieveOfCoveringAux

/-- Take `Y` to be `iSup U` and obtain a presieve over `iSup U`. -/
def presieveOfCovering {Œπ : Type v} (U : Œπ ‚Üí Opens X) : Presieve (iSup U) :=
  presieveOfCoveringAux U (iSup U)
#align Top.presheaf.presieve_of_covering TopCat.Presheaf.presieveOfCovering

/-- Given a presieve `R` on `Y`, if we take its associated family of opens via
    `coveringOfPresieve` (which may not cover `Y` if `R` is not covering), and take
    the presieve on `Y` associated to the family of opens via `presieveOfCoveringAux`,
    then we get back the original presieve `R`. -/
@[simp]
theorem covering_presieve_eq_self {Y : Opens X} (R : Presieve Y) :
    presieveOfCoveringAux (coveringOfPresieve Y R) Y = R := by
  funext Z
  ext f
  exact ‚ü®fun ‚ü®‚ü®_, f', h‚ü©, rfl‚ü© => by rwa [Subsingleton.elim f f'], fun h => ‚ü®‚ü®Z, f, h‚ü©, rfl‚ü©‚ü©
#align Top.presheaf.covering_presieve_eq_self TopCat.Presheaf.covering_presieve_eq_self

namespace presieveOfCovering

variable {Œπ : Type v} (U : Œπ ‚Üí Opens X)

/-- The sieve generated by `presieveOfCovering U` is a member of the grothendieck topology.
-/
theorem mem_grothendieckTopology :
    Sieve.generate (presieveOfCovering U) ‚àà Opens.grothendieckTopology X (iSup U) := by
  intro x hx
  obtain ‚ü®i, hxi‚ü© := Opens.mem_iSup.mp hx
  exact ‚ü®U i, Opens.leSupr U i, ‚ü®U i, ùüô _, Opens.leSupr U i, ‚ü®i, rfl‚ü©, Category.id_comp _‚ü©, hxi‚ü©
#align Top.presheaf.presieve_of_covering.mem_grothendieck_topology TopCat.Presheaf.presieveOfCovering.mem_grothendieckTopology

/-- An index `i : Œπ` can be turned into a dependent pair `(V, f)`, where `V` is an open set and
`f : V ‚ü∂ iSup U` is a member of `presieveOfCovering U f`.
-/
def homOfIndex (i : Œπ) : Œ£V, { f : V ‚ü∂ iSup U // presieveOfCovering U f } :=
  ‚ü®U i, Opens.leSupr U i, i, rfl‚ü©
#align Top.presheaf.presieve_of_covering.hom_of_index TopCat.Presheaf.presieveOfCovering.homOfIndex

/-- By using the axiom of choice, a dependent pair `(V, f)` where `f : V ‚ü∂ iSup U` is a member of
`presieveOfCovering U f` can be turned into an index `i : Œπ`, such that `V = U i`.
-/
def indexOfHom (f : Œ£V, { f : V ‚ü∂ iSup U // presieveOfCovering U f }) : Œπ :=
  f.2.2.choose
#align Top.presheaf.presieve_of_covering.index_of_hom TopCat.Presheaf.presieveOfCovering.indexOfHom

theorem indexOfHom_spec (f : Œ£V, { f : V ‚ü∂ iSup U // presieveOfCovering U f }) :
    f.1 = U (indexOfHom U f) :=
  f.2.2.choose_spec
#align Top.presheaf.presieve_of_covering.index_of_hom_spec TopCat.Presheaf.presieveOfCovering.indexOfHom_spec

end presieveOfCovering

end TopCat.Presheaf

namespace TopCat.Opens

variable {X : TopCat} {Œπ : Type*}

theorem coverDense_iff_isBasis [Category Œπ] (B : Œπ ‚•§ Opens X) :
    B.IsCoverDense (Opens.grothendieckTopology X) ‚Üî Opens.IsBasis (Set.range B.obj) := by
  rw [Opens.isBasis_iff_nbhd]
  constructor
  ¬∑ intro hd U x hx; rcases hd.1 U x hx with ‚ü®V, f, ‚ü®i, f‚ÇÅ, f‚ÇÇ, _‚ü©, hV‚ü©
    exact ‚ü®B.obj i, ‚ü®i, rfl‚ü©, f‚ÇÅ.le hV, f‚ÇÇ.le‚ü©
  intro hb; constructor; intro U x hx; rcases hb hx with ‚ü®_, ‚ü®i, rfl‚ü©, hx, hi‚ü©
  exact ‚ü®B.obj i, ‚ü®‚ü®hi‚ü©‚ü©, ‚ü®‚ü®i, ùüô _, ‚ü®‚ü®hi‚ü©‚ü©, rfl‚ü©‚ü©, hx‚ü©
#align Top.opens.cover_dense_iff_is_basis TopCat.Opens.coverDense_iff_isBasis

theorem coverDense_inducedFunctor {B : Œπ ‚Üí Opens X} (h : Opens.IsBasis (Set.range B)) :
    (inducedFunctor B).IsCoverDense (Opens.grothendieckTopology X)  :=
  (coverDense_iff_isBasis _).2 h
#align Top.opens.cover_dense_induced_functor TopCat.Opens.coverDense_inducedFunctor

end TopCat.Opens

section OpenEmbedding

open TopCat.Presheaf Opposite

variable {C : Type u} [Category.{v} C]
variable {X Y : TopCat.{w}} {f : X ‚ü∂ Y} {F : Y.Presheaf C}

theorem OpenEmbedding.compatiblePreserving (hf : OpenEmbedding f) :
    CompatiblePreserving (Opens.grothendieckTopology Y) hf.isOpenMap.functor := by
  haveI : Mono f := (TopCat.mono_iff_injective f).mpr hf.inj
  apply compatiblePreservingOfDownwardsClosed
  intro U V i
  refine ‚ü®(Opens.map f).obj V, eqToIso <| Opens.ext <| Set.image_preimage_eq_of_subset fun x h ‚Ü¶ ?_‚ü©
  obtain ‚ü®_, _, rfl‚ü© := i.le h
  exact ‚ü®_, rfl‚ü©
#align open_embedding.compatible_preserving OpenEmbedding.compatiblePreserving

theorem IsOpenMap.coverPreserving (hf : IsOpenMap f) :
    CoverPreserving (Opens.grothendieckTopology X) (Opens.grothendieckTopology Y) hf.functor := by
  constructor
  rintro U S hU _ ‚ü®x, hx, rfl‚ü©
  obtain ‚ü®V, i, hV, hxV‚ü© := hU x hx
  exact ‚ü®_, hf.functor.map i, ‚ü®_, i, ùüô _, hV, rfl‚ü©, Set.mem_image_of_mem f hxV‚ü©
#align is_open_map.cover_preserving IsOpenMap.coverPreserving


lemma OpenEmbedding.functor_isContinuous (h : OpenEmbedding f) :
    h.isOpenMap.functor.IsContinuous (Opens.grothendieckTopology X)
      (Opens.grothendieckTopology Y) := by
  apply Functor.isContinuous_of_coverPreserving
  ¬∑ exact h.compatiblePreserving
  ¬∑ exact h.isOpenMap.coverPreserving

theorem TopCat.Presheaf.isSheaf_of_openEmbedding (h : OpenEmbedding f) (hF : F.IsSheaf) :
    IsSheaf (h.isOpenMap.functor.op ‚ãô F) := by
  have := h.functor_isContinuous
  exact Functor.op_comp_isSheaf _ _ _ ‚ü®_, hF‚ü©
#align Top.presheaf.is_sheaf_of_open_embedding TopCat.Presheaf.isSheaf_of_openEmbedding

variable (f)

instance : RepresentablyFlat (Opens.map f) := by
  constructor
  intro U
  refine @IsCofiltered.mk _ _ ?_ ?_
  ¬∑ constructor
    ¬∑ intro V W
      exact ‚ü®‚ü®‚ü®PUnit.unit‚ü©, V.right ‚äì W.right, homOfLE <| le_inf V.hom.le W.hom.le‚ü©,
        StructuredArrow.homMk (homOfLE inf_le_left),
        StructuredArrow.homMk (homOfLE inf_le_right), trivial‚ü©
    ¬∑ exact fun _ _ _ _ ‚Ü¶ ‚ü®_, ùüô _, by simp [eq_iff_true_of_subsingleton]‚ü©
  ¬∑ exact ‚ü®StructuredArrow.mk <| show U ‚ü∂ (Opens.map f).obj ‚ä§ from homOfLE le_top‚ü©

theorem compatiblePreserving_opens_map :
    CompatiblePreserving (Opens.grothendieckTopology X) (Opens.map f) :=
  compatiblePreservingOfFlat _ _

theorem coverPreserving_opens_map : CoverPreserving (Opens.grothendieckTopology Y)
    (Opens.grothendieckTopology X) (Opens.map f) := by
  constructor
  intro U S hS x hx
  obtain ‚ü®V, i, hi, hxV‚ü© := hS (f x) hx
  exact ‚ü®_, (Opens.map f).map i, ‚ü®_, _, ùüô _, hi, Subsingleton.elim _ _‚ü©, hxV‚ü©

instance : (Opens.map f).IsContinuous (Opens.grothendieckTopology Y)
    (Opens.grothendieckTopology X) := by
  apply Functor.isContinuous_of_coverPreserving
  ¬∑ exact compatiblePreserving_opens_map f
  ¬∑ exact coverPreserving_opens_map f

end OpenEmbedding

namespace TopCat.Sheaf

open TopCat Opposite

variable {C : Type u} [Category.{v} C]
variable {X : TopCat.{w}} {Œπ : Type*} {B : Œπ ‚Üí Opens X}
variable (F : X.Presheaf C) (F' : Sheaf C X) (h : Opens.IsBasis (Set.range B))

/-- The empty component of a sheaf is terminal. -/
def isTerminalOfEmpty (F : Sheaf C X) : Limits.IsTerminal (F.val.obj (op ‚ä•)) :=
  F.isTerminalOfBotCover ‚ä• (fun _ h => h.elim)
#align Top.sheaf.is_terminal_of_empty TopCat.Sheaf.isTerminalOfEmpty

/-- A variant of `isTerminalOfEmpty` that is easier to `apply`. -/
def isTerminalOfEqEmpty (F : X.Sheaf C) {U : Opens X} (h : U = ‚ä•) :
    Limits.IsTerminal (F.val.obj (op U)) := by
  convert F.isTerminalOfEmpty
#align Top.sheaf.is_terminal_of_eq_empty TopCat.Sheaf.isTerminalOfEqEmpty

/-- If a family `B` of open sets forms a basis of the topology on `X`, and if `F'`
    is a sheaf on `X`, then a homomorphism between a presheaf `F` on `X` and `F'`
    is equivalent to a homomorphism between their restrictions to the indexing type
    `Œπ` of `B`, with the induced category structure on `Œπ`. -/
def restrictHomEquivHom :
    ((inducedFunctor B).op ‚ãô F ‚ü∂ (inducedFunctor B).op ‚ãô F'.1) ‚âÉ (F ‚ü∂ F'.1) :=
  @Functor.IsCoverDense.restrictHomEquivHom _ _ _ _ _ _ _ _
    (Opens.coverDense_inducedFunctor h) _ F F'
#align Top.sheaf.restrict_hom_equiv_hom TopCat.Sheaf.restrictHomEquivHom

@[simp]
theorem extend_hom_app (Œ± : (inducedFunctor B).op ‚ãô F ‚ü∂ (inducedFunctor B).op ‚ãô F'.1) (i : Œπ) :
    (restrictHomEquivHom F F' h Œ±).app (op (B i)) = Œ±.app (op i) := by
  nth_rw 2 [‚Üê (restrictHomEquivHom F F' h).left_inv Œ±]
  rfl
#align Top.sheaf.extend_hom_app TopCat.Sheaf.extend_hom_app

theorem hom_ext {Œ± Œ≤ : F ‚ü∂ F'.1} (he : ‚àÄ i, Œ±.app (op (B i)) = Œ≤.app (op (B i))) : Œ± = Œ≤ := by
  apply (restrictHomEquivHom F F' h).symm.injective
  ext i
  exact he i.unop
#align Top.sheaf.hom_ext TopCat.Sheaf.hom_ext

end TopCat.Sheaf
