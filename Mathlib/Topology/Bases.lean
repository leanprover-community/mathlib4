/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro
-/
import Mathlib.Data.Set.Constructions
import Mathlib.Order.Filter.AtTopBot.CountablyGenerated
import Mathlib.Topology.Constructions
import Mathlib.Topology.ContinuousOn

/-!
# Bases of topologies. Countability axioms.

A topological basis on a topological space `t` is a collection of sets,
such that all open sets can be generated as unions of these sets, without the need to take
finite intersections of them. This file introduces a framework for dealing with these collections,
and also what more we can say under certain countability conditions on bases,
which are referred to as first- and second-countable.
We also briefly cover the theory of separable spaces, which are those with a countable, dense
subset. If a space is second-countable, and also has a countably generated uniformity filter
(for example, if `t` is a metric space), it will automatically be separable (and indeed, these
conditions are equivalent in this case).

## Main definitions

* `TopologicalSpace.IsTopologicalBasis s`: The topological space `t` has basis `s`.
* `TopologicalSpace.SeparableSpace Œ±`: The topological space `t` has a countable, dense subset.
* `TopologicalSpace.IsSeparable s`: The set `s` is contained in the closure of a countable set.
* `FirstCountableTopology Œ±`: A topology in which `ùìù x` is countably generated for
  every `x`.
* `SecondCountableTopology Œ±`: A topology which has a topological basis which is
  countable.

## Main results

* `TopologicalSpace.FirstCountableTopology.tendsto_subseq`: In a first-countable space,
  cluster points are limits of subsequences.
* `TopologicalSpace.SecondCountableTopology.isOpen_iUnion_countable`: In a second-countable space,
  the union of arbitrarily-many open sets is equal to a sub-union of only countably many of these
  sets.
* `TopologicalSpace.SecondCountableTopology.countable_cover_nhds`: Consider `f : Œ± ‚Üí Set Œ±` with the
  property that `f x ‚àà ùìù x` for all `x`. Then there is some countable set `s` whose image covers
  the space.

## Implementation Notes
For our applications we are interested that there exists a countable basis, but we do not need the
concrete basis itself. This allows us to declare these type classes as `Prop` to use them as mixins.

## TODO

More fine grained instances for `FirstCountableTopology`,
`TopologicalSpace.SeparableSpace`, and more.
-/

open Set Filter Function Topology

noncomputable section

namespace TopologicalSpace

universe u

variable {Œ± : Type u} {Œ≤ : Type*} [t : TopologicalSpace Œ±] {B : Set (Set Œ±)} {s : Set Œ±}

/-- A topological basis is one that satisfies the necessary conditions so that
  it suffices to take unions of the basis sets to get a topology (without taking
  finite intersections as well). -/
structure IsTopologicalBasis (s : Set (Set Œ±)) : Prop where
  /-- For every point `x`, the set of `t ‚àà s` such that `x ‚àà t` is directed downwards. -/
  exists_subset_inter : ‚àÄ t‚ÇÅ ‚àà s, ‚àÄ t‚ÇÇ ‚àà s, ‚àÄ x ‚àà t‚ÇÅ ‚à© t‚ÇÇ, ‚àÉ t‚ÇÉ ‚àà s, x ‚àà t‚ÇÉ ‚àß t‚ÇÉ ‚äÜ t‚ÇÅ ‚à© t‚ÇÇ
  /-- The sets from `s` cover the whole space. -/
  sUnion_eq : ‚ãÉ‚ÇÄ s = univ
  /-- The topology is generated by sets from `s`. -/
  eq_generateFrom : t = generateFrom s

/-- If a family of sets `s` generates the topology, then intersections of finite
subcollections of `s` form a topological basis. -/
theorem isTopologicalBasis_of_subbasis {s : Set (Set Œ±)} (hs : t = generateFrom s) :
    IsTopologicalBasis ((fun f => ‚ãÇ‚ÇÄ f) '' { f : Set (Set Œ±) | f.Finite ‚àß f ‚äÜ s }) := by
  subst t; letI := generateFrom s
  refine ‚ü®?_, ?_, le_antisymm (le_generateFrom ?_) <| generateFrom_anti fun t ht => ?_‚ü©
  ¬∑ rintro _ ‚ü®t‚ÇÅ, ‚ü®hft‚ÇÅ, ht‚ÇÅb‚ü©, rfl‚ü© _ ‚ü®t‚ÇÇ, ‚ü®hft‚ÇÇ, ht‚ÇÇb‚ü©, rfl‚ü© x h
    exact ‚ü®_, ‚ü®_, ‚ü®hft‚ÇÅ.union hft‚ÇÇ, union_subset ht‚ÇÅb ht‚ÇÇb‚ü©, sInter_union t‚ÇÅ t‚ÇÇ‚ü©, h, Subset.rfl‚ü©
  ¬∑ rw [sUnion_image, iUnion‚ÇÇ_eq_univ_iff]
    exact fun x => ‚ü®‚àÖ, ‚ü®finite_empty, empty_subset _‚ü©, sInter_empty.substr <| mem_univ x‚ü©
  ¬∑ rintro _ ‚ü®t, ‚ü®hft, htb‚ü©, rfl‚ü©
    exact hft.isOpen_sInter fun s hs ‚Ü¶ GenerateOpen.basic _ <| htb hs
  ¬∑ rw [‚Üê sInter_singleton t]
    exact ‚ü®{t}, ‚ü®finite_singleton t, singleton_subset_iff.2 ht‚ü©, rfl‚ü©

theorem isTopologicalBasis_of_subbasis_of_finiteInter {s : Set (Set Œ±)} (hsg : t = generateFrom s)
    (hsi : FiniteInter s) : IsTopologicalBasis s := by
  convert isTopologicalBasis_of_subbasis hsg
  refine le_antisymm (fun t ht ‚Ü¶ ‚ü®{t}, by simpa using ht‚ü©) ?_
  rintro _ ‚ü®g, ‚ü®hg, hgs‚ü©, rfl‚ü©
  lift g to Finset (Set Œ±) using hg
  exact hsi.finiteInter_mem g hgs

theorem isTopologicalBasis_of_subbasis_of_inter {r : Set (Set Œ±)} (hsg : t = generateFrom r)
    (hsi : ‚àÄ ‚¶És‚¶Ñ, s ‚àà r ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà r ‚Üí s ‚à© t ‚àà r) : IsTopologicalBasis (insert univ r) :=
  isTopologicalBasis_of_subbasis_of_finiteInter (by simpa using hsg) (FiniteInter.mk‚ÇÇ hsi)

theorem IsTopologicalBasis.of_hasBasis_nhds {s : Set (Set Œ±)}
    (h_nhds : ‚àÄ a, (ùìù a).HasBasis (fun t ‚Ü¶ t ‚àà s ‚àß a ‚àà t) id) : IsTopologicalBasis s where
  exists_subset_inter t‚ÇÅ ht‚ÇÅ t‚ÇÇ ht‚ÇÇ x hx := by
    simpa only [and_assoc, (h_nhds x).mem_iff]
      using (inter_mem ((h_nhds _).mem_of_mem ‚ü®ht‚ÇÅ, hx.1‚ü©) ((h_nhds _).mem_of_mem ‚ü®ht‚ÇÇ, hx.2‚ü©))
  sUnion_eq := sUnion_eq_univ_iff.2 fun x ‚Ü¶ (h_nhds x).ex_mem
  eq_generateFrom := ext_nhds fun x ‚Ü¶ by
    simpa only [nhds_generateFrom, and_comm] using (h_nhds x).eq_biInf

/-- If a family of open sets `s` is such that every open neighbourhood contains some
member of `s`, then `s` is a topological basis. -/
theorem isTopologicalBasis_of_isOpen_of_nhds {s : Set (Set Œ±)} (h_open : ‚àÄ u ‚àà s, IsOpen u)
    (h_nhds : ‚àÄ (a : Œ±) (u : Set Œ±), a ‚àà u ‚Üí IsOpen u ‚Üí ‚àÉ v ‚àà s, a ‚àà v ‚àß v ‚äÜ u) :
    IsTopologicalBasis s :=
  .of_hasBasis_nhds <| fun a ‚Ü¶
    (nhds_basis_opens a).to_hasBasis' (by simpa [and_assoc] using h_nhds a)
      fun _ ‚ü®hts, hat‚ü© ‚Ü¶ (h_open _ hts).mem_nhds hat

/-- A set `s` is in the neighbourhood of `a` iff there is some basis set `t`, which
contains `a` and is itself contained in `s`. -/
theorem IsTopologicalBasis.mem_nhds_iff {a : Œ±} {s : Set Œ±} {b : Set (Set Œ±)}
    (hb : IsTopologicalBasis b) : s ‚àà ùìù a ‚Üî ‚àÉ t ‚àà b, a ‚àà t ‚àß t ‚äÜ s := by
  change s ‚àà (ùìù a).sets ‚Üî ‚àÉ t ‚àà b, a ‚àà t ‚àß t ‚äÜ s
  rw [hb.eq_generateFrom, nhds_generateFrom, biInf_sets_eq]
  ¬∑ simp [and_assoc, and_left_comm]
  ¬∑ rintro s ‚ü®hs‚ÇÅ, hs‚ÇÇ‚ü© t ‚ü®ht‚ÇÅ, ht‚ÇÇ‚ü©
    let ‚ü®u, hu‚ÇÅ, hu‚ÇÇ, hu‚ÇÉ‚ü© := hb.1 _ hs‚ÇÇ _ ht‚ÇÇ _ ‚ü®hs‚ÇÅ, ht‚ÇÅ‚ü©
    exact ‚ü®u, ‚ü®hu‚ÇÇ, hu‚ÇÅ‚ü©, le_principal_iff.2 (hu‚ÇÉ.trans inter_subset_left),
      le_principal_iff.2 (hu‚ÇÉ.trans inter_subset_right)‚ü©
  ¬∑ rcases eq_univ_iff_forall.1 hb.sUnion_eq a with ‚ü®i, h1, h2‚ü©
    exact ‚ü®i, h2, h1‚ü©

theorem IsTopologicalBasis.isOpen_iff {s : Set Œ±} {b : Set (Set Œ±)} (hb : IsTopologicalBasis b) :
    IsOpen s ‚Üî ‚àÄ a ‚àà s, ‚àÉ t ‚àà b, a ‚àà t ‚àß t ‚äÜ s := by simp [isOpen_iff_mem_nhds, hb.mem_nhds_iff]

theorem IsTopologicalBasis.of_isOpen_of_subset {s s' : Set (Set Œ±)} (h_open : ‚àÄ u ‚àà s', IsOpen u)
    (hs : IsTopologicalBasis s) (hss' : s ‚äÜ s') : IsTopologicalBasis s' :=
  isTopologicalBasis_of_isOpen_of_nhds h_open fun a _ ha u_open ‚Ü¶
    have ‚ü®t, hts, ht‚ü© := hs.isOpen_iff.mp u_open a ha; ‚ü®t, hss' hts, ht‚ü©

theorem IsTopologicalBasis.nhds_hasBasis {b : Set (Set Œ±)} (hb : IsTopologicalBasis b) {a : Œ±} :
    (ùìù a).HasBasis (fun t : Set Œ± => t ‚àà b ‚àß a ‚àà t) fun t => t :=
  ‚ü®fun s => hb.mem_nhds_iff.trans <| by simp only [and_assoc]‚ü©

protected theorem IsTopologicalBasis.isOpen {s : Set Œ±} {b : Set (Set Œ±)}
    (hb : IsTopologicalBasis b) (hs : s ‚àà b) : IsOpen s := by
  rw [hb.eq_generateFrom]
  exact .basic s hs

theorem IsTopologicalBasis.insert_empty {s : Set (Set Œ±)} (h : IsTopologicalBasis s) :
    IsTopologicalBasis (insert ‚àÖ s) :=
  h.of_isOpen_of_subset (by rintro _ (rfl | hu); exacts [isOpen_empty, h.isOpen hu])
    (subset_insert ..)

theorem IsTopologicalBasis.diff_empty {s : Set (Set Œ±)} (h : IsTopologicalBasis s) :
    IsTopologicalBasis (s \ {‚àÖ}) :=
  isTopologicalBasis_of_isOpen_of_nhds (fun _ hu ‚Ü¶ h.isOpen hu.1) fun a _ ha hu ‚Ü¶
    have ‚ü®t, hts, ht‚ü© := h.isOpen_iff.mp hu a ha
    ‚ü®t, ‚ü®hts, ne_of_mem_of_not_mem' ht.1 <| notMem_empty _‚ü©, ht‚ü©

protected theorem IsTopologicalBasis.mem_nhds {a : Œ±} {s : Set Œ±} {b : Set (Set Œ±)}
    (hb : IsTopologicalBasis b) (hs : s ‚àà b) (ha : a ‚àà s) : s ‚àà ùìù a :=
  (hb.isOpen hs).mem_nhds ha

theorem IsTopologicalBasis.exists_subset_of_mem_open {b : Set (Set Œ±)} (hb : IsTopologicalBasis b)
    {a : Œ±} {u : Set Œ±} (au : a ‚àà u) (ou : IsOpen u) : ‚àÉ v ‚àà b, a ‚àà v ‚àß v ‚äÜ u :=
  hb.mem_nhds_iff.1 <| IsOpen.mem_nhds ou au

/-- Any open set is the union of the basis sets contained in it. -/
theorem IsTopologicalBasis.open_eq_sUnion' {B : Set (Set Œ±)} (hB : IsTopologicalBasis B) {u : Set Œ±}
    (ou : IsOpen u) : u = ‚ãÉ‚ÇÄ { s ‚àà B | s ‚äÜ u } :=
  ext fun _a =>
    ‚ü®fun ha =>
      let ‚ü®b, hb, ab, bu‚ü© := hB.exists_subset_of_mem_open ha ou
      ‚ü®b, ‚ü®hb, bu‚ü©, ab‚ü©,
      fun ‚ü®_b, ‚ü®_, bu‚ü©, ab‚ü© => bu ab‚ü©

theorem IsTopologicalBasis.open_eq_sUnion {B : Set (Set Œ±)} (hB : IsTopologicalBasis B) {u : Set Œ±}
    (ou : IsOpen u) : ‚àÉ S ‚äÜ B, u = ‚ãÉ‚ÇÄ S :=
  ‚ü®{ s ‚àà B | s ‚äÜ u }, fun _ h => h.1, hB.open_eq_sUnion' ou‚ü©

theorem IsTopologicalBasis.open_iff_eq_sUnion {B : Set (Set Œ±)} (hB : IsTopologicalBasis B)
    {u : Set Œ±} : IsOpen u ‚Üî ‚àÉ S ‚äÜ B, u = ‚ãÉ‚ÇÄ S :=
  ‚ü®hB.open_eq_sUnion, fun ‚ü®_S, hSB, hu‚ü© => hu.symm ‚ñ∏ isOpen_sUnion fun _s hs => hB.isOpen (hSB hs)‚ü©

theorem IsTopologicalBasis.open_eq_iUnion {B : Set (Set Œ±)} (hB : IsTopologicalBasis B) {u : Set Œ±}
    (ou : IsOpen u) : ‚àÉ (Œ≤ : Type u) (f : Œ≤ ‚Üí Set Œ±), (u = ‚ãÉ i, f i) ‚àß ‚àÄ i, f i ‚àà B :=
  ‚ü®‚Ü•({ s ‚àà B | s ‚äÜ u }), (‚Üë), by
    rw [‚Üê sUnion_eq_iUnion]
    apply hB.open_eq_sUnion' ou, fun s => And.left s.2‚ü©

@[elab_as_elim]
lemma IsTopologicalBasis.isOpen_induction {P : Set Œ± ‚Üí Prop} (hB : IsTopologicalBasis B)
    (basis : ‚àÄ b ‚àà B, P b) (sUnion : ‚àÄ S, (‚àÄ s ‚àà S, P s) ‚Üí P (‚ãÉ‚ÇÄ S)) {s : Set Œ±} (hs : IsOpen s) :
    P s := by
  obtain ‚ü®S, hS, rfl‚ü© := hB.open_eq_sUnion hs; exact sUnion _ fun b hb ‚Ü¶ basis _ <| hS hb

lemma IsTopologicalBasis.subset_of_forall_subset {t : Set Œ±} (hB : IsTopologicalBasis B)
    (hs : IsOpen s) (h : ‚àÄ U ‚àà B, U ‚äÜ s ‚Üí U ‚äÜ t) : s ‚äÜ t := by
  rw [hB.open_eq_sUnion' hs]; simpa [sUnion_subset_iff]

lemma IsTopologicalBasis.eq_of_forall_subset_iff {t : Set Œ±} (hB : IsTopologicalBasis B)
    (hs : IsOpen s) (ht : IsOpen t) (h : ‚àÄ U ‚àà B, U ‚äÜ s ‚Üî U ‚äÜ t) : s = t := by
  rw [hB.open_eq_sUnion' hs, hB.open_eq_sUnion' ht]
  exact congr_arg _ (Set.ext fun U ‚Ü¶ and_congr_right <| h _)

/-- A point `a` is in the closure of `s` iff all basis sets containing `a` intersect `s`. -/
theorem IsTopologicalBasis.mem_closure_iff {b : Set (Set Œ±)} (hb : IsTopologicalBasis b) {s : Set Œ±}
    {a : Œ±} : a ‚àà closure s ‚Üî ‚àÄ o ‚àà b, a ‚àà o ‚Üí (o ‚à© s).Nonempty :=
  (mem_closure_iff_nhds_basis' hb.nhds_hasBasis).trans <| by simp only [and_imp]

/-- A set is dense iff it has non-trivial intersection with all basis sets. -/
theorem IsTopologicalBasis.dense_iff {b : Set (Set Œ±)} (hb : IsTopologicalBasis b) {s : Set Œ±} :
    Dense s ‚Üî ‚àÄ o ‚àà b, Set.Nonempty o ‚Üí (o ‚à© s).Nonempty := by
  simp only [Dense, hb.mem_closure_iff]
  exact ‚ü®fun h o hb ‚ü®a, ha‚ü© => h a o hb ha, fun h a o hb ha => h o hb ‚ü®a, ha‚ü©‚ü©

theorem IsTopologicalBasis.isOpenMap_iff {Œ≤} [TopologicalSpace Œ≤] {B : Set (Set Œ±)}
    (hB : IsTopologicalBasis B) {f : Œ± ‚Üí Œ≤} : IsOpenMap f ‚Üî ‚àÄ s ‚àà B, IsOpen (f '' s) := by
  refine ‚ü®fun H o ho => H _ (hB.isOpen ho), fun hf o ho => ?_‚ü©
  rw [hB.open_eq_sUnion' ho, sUnion_eq_iUnion, image_iUnion]
  exact isOpen_iUnion fun s => hf s s.2.1

theorem IsTopologicalBasis.exists_nonempty_subset {B : Set (Set Œ±)} (hb : IsTopologicalBasis B)
    {u : Set Œ±} (hu : u.Nonempty) (ou : IsOpen u) : ‚àÉ v ‚àà B, Set.Nonempty v ‚àß v ‚äÜ u :=
  let ‚ü®x, hx‚ü© := hu
  let ‚ü®v, vB, xv, vu‚ü© := hb.exists_subset_of_mem_open hx ou
  ‚ü®v, vB, ‚ü®x, xv‚ü©, vu‚ü©

theorem isTopologicalBasis_opens : IsTopologicalBasis { U : Set Œ± | IsOpen U } :=
  isTopologicalBasis_of_isOpen_of_nhds (by tauto) (by tauto)

protected lemma IsTopologicalBasis.isInducing {Œ≤} [TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤} {T : Set (Set Œ≤)}
    (hf : IsInducing f) (h : IsTopologicalBasis T) : IsTopologicalBasis ((preimage f) '' T) :=
  .of_hasBasis_nhds fun a ‚Ü¶ by
    convert (hf.basis_nhds (h.nhds_hasBasis (a := f a))).to_image_id with s
    aesop

protected theorem IsTopologicalBasis.induced {Œ±} [s : TopologicalSpace Œ≤] (f : Œ± ‚Üí Œ≤)
    {T : Set (Set Œ≤)} (h : IsTopologicalBasis T) :
    IsTopologicalBasis (t := induced f s) ((preimage f) '' T) :=
  h.isInducing (t := induced f s) (.induced f)

protected theorem IsTopologicalBasis.inf {t‚ÇÅ t‚ÇÇ : TopologicalSpace Œ≤} {B‚ÇÅ B‚ÇÇ : Set (Set Œ≤)}
    (h‚ÇÅ : IsTopologicalBasis (t := t‚ÇÅ) B‚ÇÅ) (h‚ÇÇ : IsTopologicalBasis (t := t‚ÇÇ) B‚ÇÇ) :
    IsTopologicalBasis (t := t‚ÇÅ ‚äì t‚ÇÇ) (image2 (¬∑ ‚à© ¬∑) B‚ÇÅ B‚ÇÇ) := by
  refine .of_hasBasis_nhds (t := ?_) fun a ‚Ü¶ ?_
  rw [nhds_inf (t‚ÇÅ := t‚ÇÅ)]
  convert ((h‚ÇÅ.nhds_hasBasis (t := t‚ÇÅ)).inf (h‚ÇÇ.nhds_hasBasis (t := t‚ÇÇ))).to_image_id
  aesop

theorem IsTopologicalBasis.inf_induced {Œ≥} [s : TopologicalSpace Œ≤] {B‚ÇÅ : Set (Set Œ±)}
    {B‚ÇÇ : Set (Set Œ≤)} (h‚ÇÅ : IsTopologicalBasis B‚ÇÅ) (h‚ÇÇ : IsTopologicalBasis B‚ÇÇ) (f‚ÇÅ : Œ≥ ‚Üí Œ±)
    (f‚ÇÇ : Œ≥ ‚Üí Œ≤) :
    IsTopologicalBasis (t := induced f‚ÇÅ t ‚äì induced f‚ÇÇ s) (image2 (f‚ÇÅ ‚Åª¬π' ¬∑ ‚à© f‚ÇÇ ‚Åª¬π' ¬∑) B‚ÇÅ B‚ÇÇ) := by
  simpa only [image2_image_left, image2_image_right] using (h‚ÇÅ.induced f‚ÇÅ).inf (h‚ÇÇ.induced f‚ÇÇ)

protected theorem IsTopologicalBasis.prod {Œ≤} [TopologicalSpace Œ≤] {B‚ÇÅ : Set (Set Œ±)}
    {B‚ÇÇ : Set (Set Œ≤)} (h‚ÇÅ : IsTopologicalBasis B‚ÇÅ) (h‚ÇÇ : IsTopologicalBasis B‚ÇÇ) :
    IsTopologicalBasis (image2 (¬∑ √óÀ¢ ¬∑) B‚ÇÅ B‚ÇÇ) :=
  h‚ÇÅ.inf_induced h‚ÇÇ Prod.fst Prod.snd

theorem isTopologicalBasis_of_cover {Œπ} {U : Œπ ‚Üí Set Œ±} (Uo : ‚àÄ i, IsOpen (U i))
    (Uc : ‚ãÉ i, U i = univ) {b : ‚àÄ i, Set (Set (U i))} (hb : ‚àÄ i, IsTopologicalBasis (b i)) :
    IsTopologicalBasis (‚ãÉ i : Œπ, image ((‚Üë) : U i ‚Üí Œ±) '' b i) := by
  refine isTopologicalBasis_of_isOpen_of_nhds (fun u hu => ?_) ?_
  ¬∑ simp only [mem_iUnion, mem_image] at hu
    rcases hu with ‚ü®i, s, sb, rfl‚ü©
    exact (Uo i).isOpenMap_subtype_val _ ((hb i).isOpen sb)
  ¬∑ intro a u ha uo
    rcases iUnion_eq_univ_iff.1 Uc a with ‚ü®i, hi‚ü©
    lift a to ‚Ü•(U i) using hi
    rcases (hb i).exists_subset_of_mem_open ha (uo.preimage continuous_subtype_val) with
      ‚ü®v, hvb, hav, hvu‚ü©
    exact ‚ü®(‚Üë) '' v, mem_iUnion.2 ‚ü®i, mem_image_of_mem _ hvb‚ü©, mem_image_of_mem _ hav,
      image_subset_iff.2 hvu‚ü©

protected theorem IsTopologicalBasis.continuous_iff {Œ≤ : Type*} [TopologicalSpace Œ≤]
    {B : Set (Set Œ≤)} (hB : IsTopologicalBasis B) {f : Œ± ‚Üí Œ≤} :
    Continuous f ‚Üî ‚àÄ s ‚àà B, IsOpen (f ‚Åª¬π' s) := by
  rw [hB.eq_generateFrom, continuous_generateFrom_iff]

@[simp] lemma isTopologicalBasis_empty : IsTopologicalBasis (‚àÖ : Set (Set Œ±)) ‚Üî IsEmpty Œ± where
  mp h := by simpa using h.sUnion_eq.symm
  mpr h := ‚ü®by simp, by simp [Set.univ_eq_empty_iff.2], Subsingleton.elim ..‚ü©

variable (Œ±)

/-- A separable space is one with a countable dense subset, available through
`TopologicalSpace.exists_countable_dense`. If `Œ±` is also known to be nonempty, then
`TopologicalSpace.denseSeq` provides a sequence `‚Ñï ‚Üí Œ±` with dense range, see
`TopologicalSpace.denseRange_denseSeq`.

If `Œ±` is a uniform space with countably generated uniformity filter (e.g., an `EMetricSpace`), then
this condition is equivalent to `SecondCountableTopology Œ±`. In this case the
latter should be used as a typeclass argument in theorems because Lean can automatically deduce
`TopologicalSpace.SeparableSpace` from `SecondCountableTopology` using
`TopologicalSpace.SecondCountableTopology.to_separableSpace`, but deducing
`SecondCountableTopology` from `TopologicalSpace.SeparableSpace` requires more assumptions.
-/
@[mk_iff] class SeparableSpace : Prop where
  /-- There exists a countable dense set. -/
  exists_countable_dense : ‚àÉ s : Set Œ±, s.Countable ‚àß Dense s

theorem exists_countable_dense [SeparableSpace Œ±] : ‚àÉ s : Set Œ±, s.Countable ‚àß Dense s :=
  SeparableSpace.exists_countable_dense

/-- A nonempty separable space admits a sequence with dense range. Instead of running `cases` on the
conclusion of this lemma, you might want to use `TopologicalSpace.denseSeq` and
`TopologicalSpace.denseRange_denseSeq`.

If `Œ±` might be empty, then `TopologicalSpace.exists_countable_dense` is the main way to use
separability of `Œ±`. -/
theorem exists_dense_seq [SeparableSpace Œ±] [Nonempty Œ±] : ‚àÉ u : ‚Ñï ‚Üí Œ±, DenseRange u := by
  obtain ‚ü®s : Set Œ±, hs, s_dense‚ü© := exists_countable_dense Œ±
  obtain ‚ü®u, hu‚ü© := Set.countable_iff_exists_subset_range.mp hs
  exact ‚ü®u, s_dense.mono hu‚ü©

/-- A dense sequence in a non-empty separable topological space.

If `Œ±` might be empty, then `TopologicalSpace.exists_countable_dense` is the main way to use
separability of `Œ±`. -/
def denseSeq [SeparableSpace Œ±] [Nonempty Œ±] : ‚Ñï ‚Üí Œ± :=
  Classical.choose (exists_dense_seq Œ±)

/-- The sequence `TopologicalSpace.denseSeq Œ±` has dense range. -/
@[simp]
theorem denseRange_denseSeq [SeparableSpace Œ±] [Nonempty Œ±] : DenseRange (denseSeq Œ±) :=
  Classical.choose_spec (exists_dense_seq Œ±)

variable {Œ±}

instance (priority := 100) Countable.to_separableSpace [Countable Œ±] : SeparableSpace Œ± where
  exists_countable_dense := ‚ü®Set.univ, Set.countable_univ, dense_univ‚ü©

/-- If `f` has a dense range and its domain is countable, then its codomain is a separable space.
See also `DenseRange.separableSpace`. -/
theorem SeparableSpace.of_denseRange {Œπ : Sort _} [Countable Œπ] (u : Œπ ‚Üí Œ±) (hu : DenseRange u) :
    SeparableSpace Œ± :=
  ‚ü®‚ü®range u, countable_range u, hu‚ü©‚ü©

alias _root_.DenseRange.separableSpace' := SeparableSpace.of_denseRange

/-- If `Œ±` is a separable space and `f : Œ± ‚Üí Œ≤` is a continuous map with dense range, then `Œ≤` is
a separable space as well. E.g., the completion of a separable uniform space is separable. -/
protected theorem _root_.DenseRange.separableSpace [SeparableSpace Œ±] [TopologicalSpace Œ≤]
    {f : Œ± ‚Üí Œ≤} (h : DenseRange f) (h' : Continuous f) : SeparableSpace Œ≤ :=
  let ‚ü®s, s_cnt, s_dense‚ü© := exists_countable_dense Œ±
  ‚ü®‚ü®f '' s, Countable.image s_cnt f, h.dense_image h' s_dense‚ü©‚ü©

theorem _root_.Topology.IsQuotientMap.separableSpace [SeparableSpace Œ±] [TopologicalSpace Œ≤]
    {f : Œ± ‚Üí Œ≤} (hf : IsQuotientMap f) : SeparableSpace Œ≤ :=
  hf.surjective.denseRange.separableSpace hf.continuous

/-- The product of two separable spaces is a separable space. -/
instance [TopologicalSpace Œ≤] [SeparableSpace Œ±] [SeparableSpace Œ≤] : SeparableSpace (Œ± √ó Œ≤) := by
  rcases exists_countable_dense Œ± with ‚ü®s, hsc, hsd‚ü©
  rcases exists_countable_dense Œ≤ with ‚ü®t, htc, htd‚ü©
  exact ‚ü®‚ü®s √óÀ¢ t, hsc.prod htc, hsd.prod htd‚ü©‚ü©

/-- The product of a countable family of separable spaces is a separable space. -/
instance {Œπ : Type*} {X : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (X i)] [‚àÄ i, SeparableSpace (X i)]
    [Countable Œπ] : SeparableSpace (‚àÄ i, X i) := by
  choose t htc htd using (exists_countable_dense <| X ¬∑)
  haveI := fun i ‚Ü¶ (htc i).to_subtype
  nontriviality ‚àÄ i, X i; inhabit ‚àÄ i, X i
  classical
    set f : (Œ£ I : Finset Œπ, ‚àÄ i : I, t i) ‚Üí ‚àÄ i, X i := fun ‚ü®I, g‚ü© i ‚Ü¶
      if hi : i ‚àà I then g ‚ü®i, hi‚ü© else (default : ‚àÄ i, X i) i
    refine ‚ü®‚ü®range f, countable_range f, dense_iff_inter_open.2 fun U hU ‚ü®g, hg‚ü© ‚Ü¶ ?_‚ü©‚ü©
    rcases isOpen_pi_iff.1 hU g hg with ‚ü®I, u, huo, huU‚ü©
    have : ‚àÄ i : I, ‚àÉ y ‚àà t i, y ‚àà u i := fun i ‚Ü¶
      (htd i).exists_mem_open (huo i i.2).1 ‚ü®_, (huo i i.2).2‚ü©
    choose y hyt hyu using this
    lift y to ‚àÄ i : I, t i using hyt
    refine ‚ü®f ‚ü®I, y‚ü©, huU fun i (hi : i ‚àà I) ‚Ü¶ ?_, mem_range_self (f := f) ‚ü®I, y‚ü©‚ü©
    simp only [f, dif_pos hi]
    exact hyu ‚ü®i, _‚ü©

instance [SeparableSpace Œ±] {r : Œ± ‚Üí Œ± ‚Üí Prop} : SeparableSpace (Quot r) :=
  isQuotientMap_quot_mk.separableSpace

instance [SeparableSpace Œ±] {s : Setoid Œ±} : SeparableSpace (Quotient s) :=
  isQuotientMap_quot_mk.separableSpace

/-- A topological space with discrete topology is separable iff it is countable. -/
theorem separableSpace_iff_countable [DiscreteTopology Œ±] : SeparableSpace Œ± ‚Üî Countable Œ± := by
  simp [separableSpace_iff, countable_univ_iff]

/-- In a separable space, a family of nonempty disjoint open sets is countable. -/
theorem _root_.Pairwise.countable_of_isOpen_disjoint [SeparableSpace Œ±] {Œπ : Type*}
    {s : Œπ ‚Üí Set Œ±} (hd : Pairwise (Disjoint on s)) (ho : ‚àÄ i, IsOpen (s i))
    (hne : ‚àÄ i, (s i).Nonempty) : Countable Œπ := by
  rcases exists_countable_dense Œ± with ‚ü®u, u_countable, u_dense‚ü©
  choose f hfu hfs using fun i ‚Ü¶ u_dense.exists_mem_open (ho i) (hne i)
  have f_inj : Injective f := fun i j hij ‚Ü¶
    hd.eq <| not_disjoint_iff.2 ‚ü®f i, hfs i, hij.symm ‚ñ∏ hfs j‚ü©
  have := u_countable.to_subtype
  exact (f_inj.codRestrict hfu).countable

/-- In a separable space, a family of nonempty disjoint open sets is countable. -/
theorem _root_.Set.PairwiseDisjoint.countable_of_isOpen [SeparableSpace Œ±] {Œπ : Type*}
    {s : Œπ ‚Üí Set Œ±} {a : Set Œπ} (h : a.PairwiseDisjoint s) (ho : ‚àÄ i ‚àà a, IsOpen (s i))
    (hne : ‚àÄ i ‚àà a, (s i).Nonempty) : a.Countable :=
  (h.subtype _ _).countable_of_isOpen_disjoint (Subtype.forall.2 ho) (Subtype.forall.2 hne)

/-- In a separable space, a family of disjoint sets with nonempty interiors is countable. -/
theorem _root_.Set.PairwiseDisjoint.countable_of_nonempty_interior [SeparableSpace Œ±] {Œπ : Type*}
    {s : Œπ ‚Üí Set Œ±} {a : Set Œπ} (h : a.PairwiseDisjoint s)
    (ha : ‚àÄ i ‚àà a, (interior (s i)).Nonempty) : a.Countable :=
  (h.mono fun _ => interior_subset).countable_of_isOpen (fun _ _ => isOpen_interior) ha

/-- A set `s` in a topological space is separable if it is contained in the closure of a countable
set `c`. Beware that this definition does not require that `c` is contained in `s` (to express the
latter, use `TopologicalSpace.SeparableSpace s` or
`TopologicalSpace.IsSeparable (univ : Set s))`. In metric spaces, the two definitions are
equivalent, see `TopologicalSpace.IsSeparable.separableSpace`. -/
def IsSeparable (s : Set Œ±) :=
  ‚àÉ c : Set Œ±, c.Countable ‚àß s ‚äÜ closure c

theorem IsSeparable.mono {s u : Set Œ±} (hs : IsSeparable s) (hu : u ‚äÜ s) : IsSeparable u := by
  rcases hs with ‚ü®c, c_count, hs‚ü©
  exact ‚ü®c, c_count, hu.trans hs‚ü©

theorem IsSeparable.iUnion {Œπ : Sort*} [Countable Œπ] {s : Œπ ‚Üí Set Œ±}
    (hs : ‚àÄ i, IsSeparable (s i)) : IsSeparable (‚ãÉ i, s i) := by
  choose c hc h'c using hs
  refine ‚ü®‚ãÉ i, c i, countable_iUnion hc, iUnion_subset_iff.2 fun i => ?_‚ü©
  exact (h'c i).trans (closure_mono (subset_iUnion _ i))

@[simp]
theorem isSeparable_iUnion {Œπ : Sort*} [Countable Œπ] {s : Œπ ‚Üí Set Œ±} :
    IsSeparable (‚ãÉ i, s i) ‚Üî ‚àÄ i, IsSeparable (s i) :=
  ‚ü®fun h i ‚Ü¶ h.mono <| subset_iUnion s i, .iUnion‚ü©

@[simp]
theorem isSeparable_union {s t : Set Œ±} : IsSeparable (s ‚à™ t) ‚Üî IsSeparable s ‚àß IsSeparable t := by
  simp [union_eq_iUnion, and_comm]

theorem IsSeparable.union {s u : Set Œ±} (hs : IsSeparable s) (hu : IsSeparable u) :
    IsSeparable (s ‚à™ u) :=
  isSeparable_union.2 ‚ü®hs, hu‚ü©

@[simp]
theorem isSeparable_closure : IsSeparable (closure s) ‚Üî IsSeparable s := by
  simp only [IsSeparable, isClosed_closure.closure_subset_iff]

protected alias ‚ü®_, IsSeparable.closure‚ü© := isSeparable_closure

theorem _root_.Set.Countable.isSeparable {s : Set Œ±} (hs : s.Countable) : IsSeparable s :=
  ‚ü®s, hs, subset_closure‚ü©

theorem _root_.Set.Finite.isSeparable {s : Set Œ±} (hs : s.Finite) : IsSeparable s :=
  hs.countable.isSeparable

theorem IsSeparable.univ_pi {Œπ : Type*} [Countable Œπ] {X : Œπ ‚Üí Type*} {s : ‚àÄ i, Set (X i)}
    [‚àÄ i, TopologicalSpace (X i)] (h : ‚àÄ i, IsSeparable (s i)) :
    IsSeparable (univ.pi s) := by
  classical
  rcases eq_empty_or_nonempty (univ.pi s) with he | ‚ü®f‚ÇÄ, -‚ü©
  ¬∑ rw [he]
    exact countable_empty.isSeparable
  ¬∑ choose c c_count hc using h
    haveI := fun i ‚Ü¶ (c_count i).to_subtype
    set g : (I : Finset Œπ) √ó ((i : I) ‚Üí c i) ‚Üí (i : Œπ) ‚Üí X i := fun ‚ü®I, f‚ü© i ‚Ü¶
      if hi : i ‚àà I then f ‚ü®i, hi‚ü© else f‚ÇÄ i
    refine ‚ü®range g, countable_range g, fun f hf ‚Ü¶ mem_closure_iff.2 fun o ho hfo ‚Ü¶ ?_‚ü©
    rcases isOpen_pi_iff.1 ho f hfo with ‚ü®I, u, huo, hI‚ü©
    rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : (i : I) ‚Üí c i, g ‚ü®I, f‚ü© ‚àà Set.pi I u
    ¬∑ exact ‚ü®g ‚ü®I, f‚ü©, hI hf, mem_range_self (f := g) ‚ü®I, f‚ü©‚ü©
    suffices H : ‚àÄ i ‚àà I, (u i ‚à© c i).Nonempty by
      choose f hfu hfc using H
      refine ‚ü®fun i ‚Ü¶ ‚ü®f i i.2, hfc i i.2‚ü©, fun i (hi : i ‚àà I) ‚Ü¶ ?_‚ü©
      simpa only [g, dif_pos hi] using hfu i hi
    intro i hi
    exact mem_closure_iff.1 (hc i <| hf _ trivial) _ (huo i hi).1 (huo i hi).2

lemma isSeparable_pi {Œπ : Type*} [Countable Œπ] {Œ± : Œπ ‚Üí Type*} {s : ‚àÄ i, Set (Œ± i)}
    [‚àÄ i, TopologicalSpace (Œ± i)] (h : ‚àÄ i, IsSeparable (s i)) :
    IsSeparable {f : ‚àÄ i, Œ± i | ‚àÄ i, f i ‚àà s i} := by
  simpa only [‚Üê mem_univ_pi] using IsSeparable.univ_pi h

lemma IsSeparable.prod {Œ≤ : Type*} [TopologicalSpace Œ≤]
    {s : Set Œ±} {t : Set Œ≤} (hs : IsSeparable s) (ht : IsSeparable t) :
    IsSeparable (s √óÀ¢ t) := by
  rcases hs with ‚ü®cs, cs_count, hcs‚ü©
  rcases ht with ‚ü®ct, ct_count, hct‚ü©
  refine ‚ü®cs √óÀ¢ ct, cs_count.prod ct_count, ?_‚ü©
  rw [closure_prod_eq]
  gcongr

theorem IsSeparable.image {Œ≤ : Type*} [TopologicalSpace Œ≤] {s : Set Œ±} (hs : IsSeparable s)
    {f : Œ± ‚Üí Œ≤} (hf : Continuous f) : IsSeparable (f '' s) := by
  rcases hs with ‚ü®c, c_count, hc‚ü©
  refine ‚ü®f '' c, c_count.image _, ?_‚ü©
  rw [image_subset_iff]
  exact hc.trans (closure_subset_preimage_closure_image hf)

theorem _root_.Dense.isSeparable_iff (hs : Dense s) :
    IsSeparable s ‚Üî SeparableSpace Œ± := by
  simp_rw [IsSeparable, separableSpace_iff, dense_iff_closure_eq, ‚Üê univ_subset_iff,
    ‚Üê hs.closure_eq, isClosed_closure.closure_subset_iff]

theorem isSeparable_univ_iff : IsSeparable (univ : Set Œ±) ‚Üî SeparableSpace Œ± :=
  dense_univ.isSeparable_iff

theorem isSeparable_range [TopologicalSpace Œ≤] [SeparableSpace Œ±] {f : Œ± ‚Üí Œ≤} (hf : Continuous f) :
    IsSeparable (range f) :=
  image_univ (f := f) ‚ñ∏ (isSeparable_univ_iff.2 ‚Äπ_‚Ä∫).image hf

theorem IsSeparable.of_subtype (s : Set Œ±) [SeparableSpace s] : IsSeparable s := by
  simpa using isSeparable_range (continuous_subtype_val (p := (¬∑ ‚àà s)))

theorem IsSeparable.of_separableSpace [h : SeparableSpace Œ±] (s : Set Œ±) : IsSeparable s :=
  IsSeparable.mono (isSeparable_univ_iff.2 h) (subset_univ _)

end TopologicalSpace

open TopologicalSpace

protected theorem IsTopologicalBasis.iInf {Œ≤ : Type*} {Œπ : Type*} {t : Œπ ‚Üí TopologicalSpace Œ≤}
    {T : Œπ ‚Üí Set (Set Œ≤)} (h_basis : ‚àÄ i, IsTopologicalBasis (t := t i) (T i)) :
    IsTopologicalBasis (t := ‚®Ö i, t i)
      { S | ‚àÉ (U : Œπ ‚Üí Set Œ≤) (F : Finset Œπ), (‚àÄ i, i ‚àà F ‚Üí U i ‚àà T i) ‚àß S = ‚ãÇ i ‚àà F, U i } := by
  let _ := ‚®Ö i, t i
  refine isTopologicalBasis_of_isOpen_of_nhds ?_ ?_
  ¬∑ rintro - ‚ü®U, F, hU, rfl‚ü©
    refine isOpen_biInter_finset fun i hi ‚Ü¶
      (h_basis i).isOpen (t := t i) (hU i hi) |>.mono (iInf_le _ _)
  ¬∑ intro a u ha hu
    rcases (nhds_iInf (t := t) (a := a)).symm ‚ñ∏ HasBasis.iInf'
      (fun i ‚Ü¶ (h_basis i).nhds_hasBasis (t := t i)) |>.mem_iff.1 (hu.mem_nhds ha)
      with ‚ü®‚ü®F, U‚ü©, ‚ü®hF, hU‚ü©, hUu‚ü©
    refine ‚ü®_, ‚ü®U, hF.toFinset, ?_, rfl‚ü©, ?_, ?_‚ü© <;> simp only [Finite.mem_toFinset, mem_iInter]
    ¬∑ exact fun i hi ‚Ü¶ (hU i hi).1
    ¬∑ exact fun i hi ‚Ü¶ (hU i hi).2
    ¬∑ exact hUu

theorem IsTopologicalBasis.iInf_induced {Œ≤ : Type*} {Œπ : Type*} {X : Œπ ‚Üí Type*}
    [t : Œ† i, TopologicalSpace (X i)] {T : Œ† i, Set (Set (X i))}
    (cond : ‚àÄ i, IsTopologicalBasis (T i)) (f : Œ† i, Œ≤ ‚Üí X i) :
    IsTopologicalBasis (t := ‚®Ö i, induced (f i) (t i))
      { S | ‚àÉ (U : ‚àÄ i, Set (X i)) (F : Finset Œπ),
        (‚àÄ i, i ‚àà F ‚Üí U i ‚àà T i) ‚àß S = ‚ãÇ (i) (_ : i ‚àà F), f i ‚Åª¬π' U i } := by
  convert IsTopologicalBasis.iInf (fun i ‚Ü¶ (cond i).induced (f i)) with S
  constructor <;> rintro ‚ü®U, F, hUT, hSU‚ü©
  ¬∑ exact ‚ü®fun i ‚Ü¶ (f i) ‚Åª¬π' (U i), F, fun i hi ‚Ü¶ mem_image_of_mem _ (hUT i hi), hSU‚ü©
  ¬∑ choose! U' hU' hUU' using hUT
    exact ‚ü®U', F, hU', hSU ‚ñ∏ (.symm <| iInter‚ÇÇ_congr hUU')‚ü©

theorem isTopologicalBasis_pi {Œπ : Type*} {X : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (X i)]
    {T : ‚àÄ i, Set (Set (X i))} (cond : ‚àÄ i, IsTopologicalBasis (T i)) :
    IsTopologicalBasis { S | ‚àÉ (U : ‚àÄ i, Set (X i)) (F : Finset Œπ),
      (‚àÄ i, i ‚àà F ‚Üí U i ‚àà T i) ‚àß S = (F : Set Œπ).pi U } := by
  simpa only [Set.pi_def] using IsTopologicalBasis.iInf_induced cond eval

theorem isTopologicalBasis_singletons (Œ± : Type*) [TopologicalSpace Œ±] [DiscreteTopology Œ±] :
    IsTopologicalBasis { s | ‚àÉ x : Œ±, (s : Set Œ±) = {x} } :=
  isTopologicalBasis_of_isOpen_of_nhds (fun _ _ => isOpen_discrete _) fun x _ hx _ =>
    ‚ü®{x}, ‚ü®x, rfl‚ü©, mem_singleton x, singleton_subset_iff.2 hx‚ü©

theorem isTopologicalBasis_subtype
    {Œ± : Type*} [TopologicalSpace Œ±] {B : Set (Set Œ±)}
    (h : TopologicalSpace.IsTopologicalBasis B) (p : Œ± ‚Üí Prop) :
    IsTopologicalBasis (Set.preimage (Subtype.val (p := p)) '' B) :=
  h.isInducing ‚ü®rfl‚ü©

section
variable {Œπ : Type*} {X : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (X i)]

lemma isOpenMap_eval (i : Œπ) : IsOpenMap (Function.eval i : (‚àÄ i, X i) ‚Üí X i) := by
  classical
  refine (isTopologicalBasis_pi fun _ ‚Ü¶ isTopologicalBasis_opens).isOpenMap_iff.2 ?_
  rintro _ ‚ü®U, s, hU, rfl‚ü©
  obtain h | h := ((s : Set Œπ).pi U).eq_empty_or_nonempty
  ¬∑ simp [h]
  by_cases hi : i ‚àà s
  ¬∑ rw [eval_image_pi (mod_cast hi) h]
    exact hU _ hi
  ¬∑ rw [eval_image_pi_of_notMem (mod_cast hi), if_pos h]
    exact isOpen_univ

end

theorem Dense.exists_countable_dense_subset {Œ± : Type*} [TopologicalSpace Œ±] {s : Set Œ±}
    [SeparableSpace s] (hs : Dense s) : ‚àÉ t ‚äÜ s, t.Countable ‚àß Dense t :=
  let ‚ü®t, htc, htd‚ü© := exists_countable_dense s
  ‚ü®(‚Üë) '' t, Subtype.coe_image_subset s t, htc.image Subtype.val,
    hs.denseRange_val.dense_image continuous_subtype_val htd‚ü©

/-- Let `s` be a dense set in a topological space `Œ±` with partial order structure. If `s` is a
separable space (e.g., if `Œ±` has a second countable topology), then there exists a countable
dense subset `t ‚äÜ s` such that `t` contains bottom/top element of `Œ±` when they exist and belong
to `s`. For a dense subset containing neither bot nor top elements, see
`Dense.exists_countable_dense_subset_no_bot_top`. -/
theorem Dense.exists_countable_dense_subset_bot_top {Œ± : Type*} [TopologicalSpace Œ±]
    [PartialOrder Œ±] {s : Set Œ±} [SeparableSpace s] (hs : Dense s) :
    ‚àÉ t ‚äÜ s, t.Countable ‚àß Dense t ‚àß (‚àÄ x, IsBot x ‚Üí x ‚àà s ‚Üí x ‚àà t) ‚àß
      ‚àÄ x, IsTop x ‚Üí x ‚àà s ‚Üí x ‚àà t := by
  rcases hs.exists_countable_dense_subset with ‚ü®t, hts, htc, htd‚ü©
  refine ‚ü®(t ‚à™ ({ x | IsBot x } ‚à™ { x | IsTop x })) ‚à© s, ?_, ?_, ?_, ?_, ?_‚ü©
  exacts [inter_subset_right,
    (htc.union ((countable_isBot Œ±).union (countable_isTop Œ±))).mono inter_subset_left,
    htd.mono (subset_inter subset_union_left hts), fun x hx hxs => ‚ü®Or.inr <| Or.inl hx, hxs‚ü©,
    fun x hx hxs => ‚ü®Or.inr <| Or.inr hx, hxs‚ü©]

instance separableSpace_univ {Œ± : Type*} [TopologicalSpace Œ±] [SeparableSpace Œ±] :
    SeparableSpace (univ : Set Œ±) :=
  (Equiv.Set.univ Œ±).symm.surjective.denseRange.separableSpace (continuous_id.subtype_mk _)

/-- If `Œ±` is a separable topological space with a partial order, then there exists a countable
dense set `s : Set Œ±` that contains those of both bottom and top elements of `Œ±` that actually
exist. For a dense set containing neither bot nor top elements, see
`exists_countable_dense_no_bot_top`. -/
theorem exists_countable_dense_bot_top (Œ± : Type*) [TopologicalSpace Œ±] [SeparableSpace Œ±]
    [PartialOrder Œ±] :
    ‚àÉ s : Set Œ±, s.Countable ‚àß Dense s ‚àß (‚àÄ x, IsBot x ‚Üí x ‚àà s) ‚àß ‚àÄ x, IsTop x ‚Üí x ‚àà s := by
  simpa using dense_univ.exists_countable_dense_subset_bot_top

namespace TopologicalSpace

universe u

variable (Œ± : Type u) [t : TopologicalSpace Œ±]

/-- A first-countable space is one in which every point has a
  countable neighborhood basis. -/
class _root_.FirstCountableTopology : Prop where
  /-- The filter `ùìù a` is countably generated for all points `a`. -/
  nhds_generated_countable : ‚àÄ a : Œ±, (ùìù a).IsCountablyGenerated

attribute [instance] FirstCountableTopology.nhds_generated_countable

/-- If `Œ≤` is a first-countable space, then its induced topology via `f` on `Œ±` is also
first-countable. -/
theorem firstCountableTopology_induced (Œ± Œ≤ : Type*) [t : TopologicalSpace Œ≤]
    [FirstCountableTopology Œ≤] (f : Œ± ‚Üí Œ≤) : @FirstCountableTopology Œ± (t.induced f) :=
  let _ := t.induced f
  ‚ü®fun x ‚Ü¶ nhds_induced f x ‚ñ∏ inferInstance‚ü©

variable {Œ±}

instance Subtype.firstCountableTopology (s : Set Œ±) [FirstCountableTopology Œ±] :
    FirstCountableTopology s :=
  firstCountableTopology_induced s Œ± (‚Üë)

protected theorem _root_.Topology.IsInducing.firstCountableTopology {Œ≤ : Type*}
    [TopologicalSpace Œ≤] [FirstCountableTopology Œ≤] {f : Œ± ‚Üí Œ≤} (hf : IsInducing f) :
    FirstCountableTopology Œ± := by
  rw [hf.1]
  exact firstCountableTopology_induced Œ± Œ≤ f

protected theorem _root_.Topology.IsEmbedding.firstCountableTopology {Œ≤ : Type*}
    [TopologicalSpace Œ≤] [FirstCountableTopology Œ≤] {f : Œ± ‚Üí Œ≤} (hf : IsEmbedding f) :
    FirstCountableTopology Œ± :=
  hf.1.firstCountableTopology

namespace FirstCountableTopology

/-- In a first-countable space, a cluster point `x` of a sequence
is the limit of some subsequence. -/
theorem tendsto_subseq [FirstCountableTopology Œ±] {u : ‚Ñï ‚Üí Œ±} {x : Œ±}
    (hx : MapClusterPt x atTop u) : ‚àÉ œà : ‚Ñï ‚Üí ‚Ñï, StrictMono œà ‚àß Tendsto (u ‚àò œà) atTop (ùìù x) :=
  subseq_tendsto_of_neBot hx

end FirstCountableTopology

instance {Œ≤} [TopologicalSpace Œ≤] [FirstCountableTopology Œ±] [FirstCountableTopology Œ≤] :
    FirstCountableTopology (Œ± √ó Œ≤) :=
  ‚ü®fun ‚ü®x, y‚ü© => by rw [nhds_prod_eq]; infer_instance‚ü©

section Pi

instance {Œπ : Type*} {X : Œπ ‚Üí Type*} [Countable Œπ] [‚àÄ i, TopologicalSpace (X i)]
    [‚àÄ i, FirstCountableTopology (X i)] : FirstCountableTopology (‚àÄ i, X i) :=
  ‚ü®fun f => by rw [nhds_pi]; infer_instance‚ü©

end Pi

instance isCountablyGenerated_nhdsWithin (x : Œ±) [IsCountablyGenerated (ùìù x)] (s : Set Œ±) :
    IsCountablyGenerated (ùìù[s] x) :=
  Inf.isCountablyGenerated _ _

variable (Œ±) in
/-- A second-countable space is one with a countable basis. -/
class _root_.SecondCountableTopology : Prop where
  /-- There exists a countable set of sets that generates the topology. -/
  is_open_generated_countable : ‚àÉ b : Set (Set Œ±), b.Countable ‚àß t = TopologicalSpace.generateFrom b

protected theorem IsTopologicalBasis.secondCountableTopology {b : Set (Set Œ±)}
    (hb : IsTopologicalBasis b) (hc : b.Countable) : SecondCountableTopology Œ± :=
  ‚ü®‚ü®b, hc, hb.eq_generateFrom‚ü©‚ü©

lemma SecondCountableTopology.mk' {Œ±} {b : Set (Set Œ±)} (hc : b.Countable) :
    @SecondCountableTopology Œ± (generateFrom b) :=
  @SecondCountableTopology.mk Œ± (generateFrom b) ‚ü®b, hc, rfl‚ü©

instance _root_.Finite.toSecondCountableTopology [Finite Œ±] : SecondCountableTopology Œ± where
  is_open_generated_countable :=
    ‚ü®_, {U | IsOpen U}.to_countable, TopologicalSpace.isTopologicalBasis_opens.eq_generateFrom‚ü©

variable (Œ±)

theorem exists_countable_basis [SecondCountableTopology Œ±] :
    ‚àÉ b : Set (Set Œ±), b.Countable ‚àß ‚àÖ ‚àâ b ‚àß IsTopologicalBasis b := by
  obtain ‚ü®b, hb‚ÇÅ, hb‚ÇÇ‚ü© := @SecondCountableTopology.is_open_generated_countable Œ± _ _
  refine ‚ü®_, ?_, notMem_diff_of_mem ?_, (isTopologicalBasis_of_subbasis hb‚ÇÇ).diff_empty‚ü©
  exacts [((countable_setOf_finite_subset hb‚ÇÅ).image _).mono diff_subset, rfl]

/-- A countable topological basis of `Œ±`. -/
def countableBasis [SecondCountableTopology Œ±] : Set (Set Œ±) :=
  (exists_countable_basis Œ±).choose

theorem countable_countableBasis [SecondCountableTopology Œ±] : (countableBasis Œ±).Countable :=
  (exists_countable_basis Œ±).choose_spec.1

instance encodableCountableBasis [SecondCountableTopology Œ±] : Encodable (countableBasis Œ±) :=
  (countable_countableBasis Œ±).toEncodable

theorem empty_notMem_countableBasis [SecondCountableTopology Œ±] : ‚àÖ ‚àâ countableBasis Œ± :=
  (exists_countable_basis Œ±).choose_spec.2.1

@[deprecated (since := "2025-05-24")] alias empty_nmem_countableBasis := empty_notMem_countableBasis

theorem isBasis_countableBasis [SecondCountableTopology Œ±] :
    IsTopologicalBasis (countableBasis Œ±) :=
  (exists_countable_basis Œ±).choose_spec.2.2

theorem eq_generateFrom_countableBasis [SecondCountableTopology Œ±] :
    ‚ÄπTopologicalSpace Œ±‚Ä∫ = generateFrom (countableBasis Œ±) :=
  (isBasis_countableBasis Œ±).eq_generateFrom

variable {Œ±}

theorem isOpen_of_mem_countableBasis [SecondCountableTopology Œ±] {s : Set Œ±}
    (hs : s ‚àà countableBasis Œ±) : IsOpen s :=
  (isBasis_countableBasis Œ±).isOpen hs

theorem nonempty_of_mem_countableBasis [SecondCountableTopology Œ±] {s : Set Œ±}
    (hs : s ‚àà countableBasis Œ±) : s.Nonempty :=
  nonempty_iff_ne_empty.2 <| ne_of_mem_of_not_mem hs <| empty_notMem_countableBasis Œ±

variable (Œ±)

-- see Note [lower instance priority]
instance (priority := 100) SecondCountableTopology.to_firstCountableTopology
    [SecondCountableTopology Œ±] : FirstCountableTopology Œ± :=
  ‚ü®fun _ => HasCountableBasis.isCountablyGenerated <|
      ‚ü®(isBasis_countableBasis Œ±).nhds_hasBasis,
        (countable_countableBasis Œ±).mono inter_subset_left‚ü©‚ü©

-- see Note [lower instance priority]
instance (priority := 100) [Countable Œ±] [FirstCountableTopology Œ±] :
    SecondCountableTopology Œ± where
  is_open_generated_countable := by
    -- The countable union of the countable neighborhood bases at each point is a countable basis.
    choose b hxb hbb using fun x : Œ± => (nhds_basis_opens x).exists_antitone_subbasis
    use range b.uncurry, countable_range b.uncurry
    apply le_antisymm
    ¬∑ rw [le_generateFrom_iff_subset_isOpen]
      rintro _ ‚ü®‚ü®x, n‚ü©, rfl‚ü©
      exact (hxb x n).right
    ¬∑ rw [le_iff_nhds]
      intro x
      rw [(hbb x).ge_iff]
      intro n _
      refine @IsOpen.mem_nhds Œ± (generateFrom (range b.uncurry)) x (b x n) ?_ (hxb x n).left
      exact isOpen_generateFrom_of_mem ‚ü®‚ü®x, n‚ü©, rfl‚ü©

/-- If `Œ≤` is a second-countable space, then its induced topology via
`f` on `Œ±` is also second-countable. -/
theorem secondCountableTopology_induced (Œ± Œ≤) [t : TopologicalSpace Œ≤] [SecondCountableTopology Œ≤]
    (f : Œ± ‚Üí Œ≤) : @SecondCountableTopology Œ± (t.induced f) := by
  rcases @SecondCountableTopology.is_open_generated_countable Œ≤ _ _ with ‚ü®b, hb, eq‚ü©
  letI := t.induced f
  refine { is_open_generated_countable := ‚ü®preimage f '' b, hb.image _, ?_‚ü© }
  rw [eq, induced_generateFrom_eq]

variable {Œ±}

instance Subtype.secondCountableTopology (s : Set Œ±) [SecondCountableTopology Œ±] :
    SecondCountableTopology s :=
  secondCountableTopology_induced s Œ± (‚Üë)

lemma secondCountableTopology_iInf {Œ± Œπ} [Countable Œπ] {t : Œπ ‚Üí TopologicalSpace Œ±}
    (ht : ‚àÄ i, @SecondCountableTopology Œ± (t i)) : @SecondCountableTopology Œ± (‚®Ö i, t i) := by
  rw [funext fun i => @eq_generateFrom_countableBasis Œ± (t i) (ht i), ‚Üê generateFrom_iUnion]
  exact SecondCountableTopology.mk' <|
    countable_iUnion fun i => @countable_countableBasis _ (t i) (ht i)

-- TODO: more fine grained instances for `FirstCountableTopology`, `SeparableSpace`, `T2Space`, ...
instance {Œ≤ : Type*} [TopologicalSpace Œ≤] [SecondCountableTopology Œ±] [SecondCountableTopology Œ≤] :
    SecondCountableTopology (Œ± √ó Œ≤) :=
  ((isBasis_countableBasis Œ±).prod (isBasis_countableBasis Œ≤)).secondCountableTopology <|
    (countable_countableBasis Œ±).image2 (countable_countableBasis Œ≤) _

instance {Œπ : Type*} {X : Œπ ‚Üí Type*} [Countable Œπ] [‚àÄ a, TopologicalSpace (X a)]
    [‚àÄ a, SecondCountableTopology (X a)] : SecondCountableTopology (‚àÄ a, X a) :=
  secondCountableTopology_iInf fun _ => secondCountableTopology_induced _ _ _

-- see Note [lower instance priority]
instance (priority := 100) SecondCountableTopology.to_separableSpace [SecondCountableTopology Œ±] :
    SeparableSpace Œ± := by
  choose p hp using fun s : countableBasis Œ± => nonempty_of_mem_countableBasis s.2
  exact ‚ü®‚ü®range p, countable_range _, (isBasis_countableBasis Œ±).dense_iff.2 fun o ho _ =>
          ‚ü®p ‚ü®o, ho‚ü©, hp ‚ü®o, _‚ü©, mem_range_self _‚ü©‚ü©‚ü©

/-- A countable open cover induces a second-countable topology if all open covers
are themselves second countable. -/
theorem secondCountableTopology_of_countable_cover {Œπ} [Countable Œπ] {U : Œπ ‚Üí Set Œ±}
    [‚àÄ i, SecondCountableTopology (U i)] (Uo : ‚àÄ i, IsOpen (U i)) (hc : ‚ãÉ i, U i = univ) :
    SecondCountableTopology Œ± :=
  haveI : IsTopologicalBasis (‚ãÉ i, image ((‚Üë) : U i ‚Üí Œ±) '' countableBasis (U i)) :=
    isTopologicalBasis_of_cover Uo hc fun i => isBasis_countableBasis (U i)
  this.secondCountableTopology (countable_iUnion fun _ => (countable_countableBasis _).image _)

/-- In a second-countable space, an open set, given as a union of open sets,
is equal to the union of countably many of those sets.
In particular, any open covering of `Œ±` has a countable subcover: Œ± is a Lindel√∂f space. -/
theorem isOpen_iUnion_countable [SecondCountableTopology Œ±] {Œπ} (s : Œπ ‚Üí Set Œ±)
    (H : ‚àÄ i, IsOpen (s i)) : ‚àÉ T : Set Œπ, T.Countable ‚àß ‚ãÉ i ‚àà T, s i = ‚ãÉ i, s i := by
  let B := { b ‚àà countableBasis Œ± | ‚àÉ i, b ‚äÜ s i }
  choose f hf using fun b : B => b.2.2
  haveI : Countable B := ((countable_countableBasis Œ±).mono (sep_subset _ _)).to_subtype
  refine ‚ü®_, countable_range f, (iUnion‚ÇÇ_subset_iUnion _ _).antisymm (sUnion_subset ?_)‚ü©
  rintro _ ‚ü®i, rfl‚ü© x xs
  rcases (isBasis_countableBasis Œ±).exists_subset_of_mem_open xs (H _) with ‚ü®b, hb, xb, bs‚ü©
  exact ‚ü®_, ‚ü®_, rfl‚ü©, _, ‚ü®‚ü®‚ü®_, hb, _, bs‚ü©, rfl‚ü©, rfl‚ü©, hf _ xb‚ü©

theorem isOpen_biUnion_countable [SecondCountableTopology Œ±] {Œπ : Type*} (I : Set Œπ) (s : Œπ ‚Üí Set Œ±)
    (H : ‚àÄ i ‚àà I, IsOpen (s i)) : ‚àÉ T ‚äÜ I, T.Countable ‚àß ‚ãÉ i ‚àà T, s i = ‚ãÉ i ‚àà I, s i := by
  simp_rw [‚Üê Subtype.exists_set_subtype, biUnion_image]
  rcases isOpen_iUnion_countable (fun i : I ‚Ü¶ s i) fun i ‚Ü¶ H i i.2 with ‚ü®T, hTc, hU‚ü©
  exact ‚ü®T, hTc.image _, hU.trans <| iUnion_subtype ..‚ü©

theorem isOpen_sUnion_countable [SecondCountableTopology Œ±] (S : Set (Set Œ±))
    (H : ‚àÄ s ‚àà S, IsOpen s) : ‚àÉ T : Set (Set Œ±), T.Countable ‚àß T ‚äÜ S ‚àß ‚ãÉ‚ÇÄ T = ‚ãÉ‚ÇÄ S := by
  simpa only [and_left_comm, sUnion_eq_biUnion] using isOpen_biUnion_countable S id H

/-- In a topological space with second countable topology, if `f` is a function that sends each
point `x` to a neighborhood of `x`, then for some countable set `s`, the neighborhoods `f x`,
`x ‚àà s`, cover the whole space. -/
theorem countable_cover_nhds [SecondCountableTopology Œ±] {f : Œ± ‚Üí Set Œ±} (hf : ‚àÄ x, f x ‚àà ùìù x) :
    ‚àÉ s : Set Œ±, s.Countable ‚àß ‚ãÉ x ‚àà s, f x = univ := by
  rcases isOpen_iUnion_countable (fun x => interior (f x)) fun x => isOpen_interior with
    ‚ü®s, hsc, hsU‚ü©
  suffices ‚ãÉ x ‚àà s, interior (f x) = univ from
    ‚ü®s, hsc, flip eq_univ_of_subset this <| iUnion‚ÇÇ_mono fun _ _ => interior_subset‚ü©
  simp only [hsU, eq_univ_iff_forall, mem_iUnion]
  exact fun x => ‚ü®x, mem_interior_iff_mem_nhds.2 (hf x)‚ü©

theorem countable_cover_nhdsWithin [SecondCountableTopology Œ±] {f : Œ± ‚Üí Set Œ±} {s : Set Œ±}
    (hf : ‚àÄ x ‚àà s, f x ‚àà ùìù[s] x) : ‚àÉ t ‚äÜ s, t.Countable ‚àß s ‚äÜ ‚ãÉ x ‚àà t, f x := by
  have : ‚àÄ x : s, (‚Üë) ‚Åª¬π' f x ‚àà ùìù x := fun x => preimage_coe_mem_nhds_subtype.2 (hf x x.2)
  rcases countable_cover_nhds this with ‚ü®t, htc, htU‚ü©
  refine ‚ü®(‚Üë) '' t, Subtype.coe_image_subset _ _, htc.image _, fun x hx => ?_‚ü©
  simp only [biUnion_image, eq_univ_iff_forall, ‚Üê preimage_iUnion, mem_preimage] at htU ‚ä¢
  exact htU ‚ü®x, hx‚ü©

/-- In a second countable topological space, any open set is a countable union of elements in a
given topological basis. -/
lemma IsTopologicalBasis.exists_countable_biUnion_of_isOpen [SecondCountableTopology Œ±]
    {t : Set (Set Œ±)} (ht : IsTopologicalBasis t) {u : Set Œ±} (hu : IsOpen u) :
    ‚àÉ s ‚äÜ t, s.Countable ‚àß u = ‚ãÉ a ‚àà s, a := by
  have A : ‚àÄ x ‚àà u, ‚àÉ a ‚àà t, x ‚àà a ‚àß a ‚äÜ u :=
    fun x hx ‚Ü¶ ht.exists_subset_of_mem_open hx hu
  choose! a hat xa au using A
  obtain ‚ü®T, T_count, hT‚ü© : ‚àÉ T : Set u, T.Countable ‚àß ‚ãÉ i ‚àà T, a i = ‚ãÉ (i : u), a i := by
    apply isOpen_iUnion_countable _
    rintro ‚ü®x, hx‚ü©
    exact ht.isOpen (hat x hx)
  refine ‚ü®(fun (x : u) ‚Ü¶ a x) '' T, ?_, T_count.image _, ?_‚ü©
  ¬∑ simp only [image_subset_iff]
    rintro ‚ü®x, xu‚ü© -
    exact hat x xu
  rw [biUnion_image, hT]
  apply Subset.antisymm
  ¬∑ intro x hx
    simp
    grind
  ¬∑ simp
    grind

/-- In a second countable topological space, any topological basis contains a countable subset
which is also a topological basis. -/
lemma IsTopologicalBasis.exists_countable
    [SecondCountableTopology Œ±] {t : Set (Set Œ±)} (ht : IsTopologicalBasis t) :
    ‚àÉ s ‚äÜ t, s.Countable ‚àß IsTopologicalBasis s := by
  have A : ‚àÄ u ‚àà countableBasis Œ±, ‚àÉ s ‚äÜ t, s.Countable ‚àß u = ‚ãÉ a ‚àà s, a :=
    fun u hu ‚Ü¶ ht.exists_countable_biUnion_of_isOpen ((isBasis_countableBasis Œ±).isOpen hu)
  choose! s hst s_count hs using A
  refine ‚ü®‚ãÉ u ‚àà countableBasis Œ±, s u, by simpa using hst,
    (countable_countableBasis Œ±).biUnion s_count, ?_‚ü©
  apply isTopologicalBasis_of_isOpen_of_nhds
  ¬∑ simp only [mem_iUnion, exists_prop, forall_exists_index, and_imp]
    have := @ht.isOpen
    grind
  ¬∑ intro x v hx hv
    simp only [mem_iUnion, exists_prop]
    obtain ‚ü®u, u_mem, xu, uv‚ü© : ‚àÉ u ‚àà countableBasis Œ±, x ‚àà u ‚àß u ‚äÜ v :=
      (isBasis_countableBasis Œ±).isOpen_iff.1 hv _ hx
    have : x ‚àà ‚ãÉ a ‚àà s u, a := by
      convert xu
      exact (hs u u_mem).symm
    obtain ‚ü®w, ws, xw‚ü© : ‚àÉ w ‚àà s u, x ‚àà w := by simpa using this
    refine ‚ü®w, ‚ü®u, u_mem, ws‚ü©, xw, ?_‚ü©
    apply Subset.trans (Subset.trans _ (hs u u_mem).symm.subset) uv
    exact subset_iUnion‚ÇÇ_of_subset w ws fun ‚¶Éa‚¶Ñ a ‚Ü¶ a

/-- In a second countable topological space, any family generating the topology admits a
countable generating subfamily. -/
lemma exists_countable_of_generateFrom
    {Œ± : Type*} [ts : TopologicalSpace Œ±] [SecondCountableTopology Œ±] {t : Set (Set Œ±)}
    (ht : ts = generateFrom t) :
    ‚àÉ s ‚äÜ t, s.Countable ‚àß ts = generateFrom s := by
  let t' := (fun f => ‚ãÇ‚ÇÄ f) '' { f : Set (Set Œ±) | f.Finite ‚àß f ‚äÜ t }
  have : IsTopologicalBasis t' := TopologicalSpace.isTopologicalBasis_of_subbasis ht
  obtain ‚ü®s', s't', s'_count, hs'‚ü© : ‚àÉ s' ‚äÜ t', s'.Countable ‚àß IsTopologicalBasis s' :=
    this.exists_countable
  have A : ‚àÄ u ‚àà s', ‚àÉ (f : Set (Set Œ±)), f.Finite ‚àß f ‚äÜ t ‚àß ‚ãÇ‚ÇÄ f = u :=
    fun u hu ‚Ü¶ by simpa [t', and_assoc] using s't' hu
  choose! f f_fin ft hf using A
  refine ‚ü®‚ãÉ u ‚àà s', f u, by simpa using ft, ?_, ?_‚ü©
  ¬∑ apply s'_count.biUnion
    intro u hu
    exact Finite.countable (f_fin u hu)
  ¬∑ apply le_antisymm
    ¬∑ apply le_generateFrom_iff_subset_isOpen.2
      simp only [iUnion_subset_iff]
      intro u hu v hv
      rw [ht]
      apply isOpen_generateFrom_of_mem
      exact ft u hu hv
    ¬∑ rw [hs'.eq_generateFrom]
      apply le_generateFrom_iff_subset_isOpen.2
      intro u hu
      rw [‚Üê hf u hu, sInter_eq_biInter]
      change IsOpen[generateFrom _] (‚ãÇ i ‚àà f u, i)
      apply @Finite.isOpen_biInter _ _ (generateFrom (‚ãÉ u ‚àà s', f u)) _ _
      ¬∑ apply f_fin u hu
      ¬∑ intro i hi
        apply isOpen_generateFrom_of_mem
        simp
        grind

section Sigma

variable {Œπ : Type*} {E : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (E i)]

/-- In a disjoint union space `Œ£ i, E i`, one can form a topological basis by taking the union of
topological bases on each of the parts of the space. -/
theorem IsTopologicalBasis.sigma {s : ‚àÄ i : Œπ, Set (Set (E i))}
    (hs : ‚àÄ i, IsTopologicalBasis (s i)) :
    IsTopologicalBasis (‚ãÉ i : Œπ, (fun u => (Sigma.mk i '' u : Set (Œ£ i, E i))) '' s i) := by
  refine .of_hasBasis_nhds fun a ‚Ü¶ ?_
  rw [Sigma.nhds_eq]
  convert (((hs a.1).nhds_hasBasis).map _).to_image_id
  aesop

/-- A countable disjoint union of second countable spaces is second countable. -/
instance [Countable Œπ] [‚àÄ i, SecondCountableTopology (E i)] :
    SecondCountableTopology (Œ£ i, E i) := by
  let b := ‚ãÉ i : Œπ, (fun u => (Sigma.mk i '' u : Set (Œ£ i, E i))) '' countableBasis (E i)
  have A : IsTopologicalBasis b := IsTopologicalBasis.sigma fun i => isBasis_countableBasis _
  have B : b.Countable := countable_iUnion fun i => (countable_countableBasis _).image _
  exact A.secondCountableTopology B

end Sigma

section Sum

variable {Œ≤ : Type*} [TopologicalSpace Œ≤]

/-- In a sum space `Œ± ‚äï Œ≤`, one can form a topological basis by taking the union of
topological bases on each of the two components. -/
theorem IsTopologicalBasis.sum {s : Set (Set Œ±)} (hs : IsTopologicalBasis s) {t : Set (Set Œ≤)}
    (ht : IsTopologicalBasis t) :
    IsTopologicalBasis ((fun u => Sum.inl '' u) '' s ‚à™ (fun u => Sum.inr '' u) '' t) := by
  apply isTopologicalBasis_of_isOpen_of_nhds
  ¬∑ rintro u (‚ü®w, hw, rfl‚ü© | ‚ü®w, hw, rfl‚ü©)
    ¬∑ exact IsOpenEmbedding.inl.isOpenMap w (hs.isOpen hw)
    ¬∑ exact IsOpenEmbedding.inr.isOpenMap w (ht.isOpen hw)
  ¬∑ rintro (x | x) u hxu u_open
    ¬∑ obtain ‚ü®v, vs, xv, vu‚ü© : ‚àÉ v ‚àà s, x ‚àà v ‚àß v ‚äÜ Sum.inl ‚Åª¬π' u :=
        hs.exists_subset_of_mem_open hxu (isOpen_sum_iff.1 u_open).1
      exact ‚ü®Sum.inl '' v, mem_union_left _ (mem_image_of_mem _ vs), mem_image_of_mem _ xv,
        image_subset_iff.2 vu‚ü©
    ¬∑ obtain ‚ü®v, vs, xv, vu‚ü© : ‚àÉ v ‚àà t, x ‚àà v ‚àß v ‚äÜ Sum.inr ‚Åª¬π' u :=
        ht.exists_subset_of_mem_open hxu (isOpen_sum_iff.1 u_open).2
      exact ‚ü®Sum.inr '' v, mem_union_right _ (mem_image_of_mem _ vs), mem_image_of_mem _ xv,
        image_subset_iff.2 vu‚ü©

/-- A sum type of two second countable spaces is second countable. -/
instance [SecondCountableTopology Œ±] [SecondCountableTopology Œ≤] :
    SecondCountableTopology (Œ± ‚äï Œ≤) := by
  let b :=
    (fun u => Sum.inl '' u) '' countableBasis Œ± ‚à™ (fun u => Sum.inr '' u) '' countableBasis Œ≤
  have A : IsTopologicalBasis b := (isBasis_countableBasis Œ±).sum (isBasis_countableBasis Œ≤)
  have B : b.Countable :=
    (Countable.image (countable_countableBasis _) _).union
      (Countable.image (countable_countableBasis _) _)
  exact A.secondCountableTopology B

end Sum

section Quotient

variable {X : Type*} [TopologicalSpace X] {Y : Type*} [TopologicalSpace Y] {œÄ : X ‚Üí Y}

/-- The image of a topological basis under an open quotient map is a topological basis. -/
theorem IsTopologicalBasis.isQuotientMap {V : Set (Set X)} (hV : IsTopologicalBasis V)
    (h' : IsQuotientMap œÄ) (h : IsOpenMap œÄ) : IsTopologicalBasis (Set.image œÄ '' V) := by
  apply isTopologicalBasis_of_isOpen_of_nhds
  ¬∑ rintro - ‚ü®U, U_in_V, rfl‚ü©
    apply h U (hV.isOpen U_in_V)
  ¬∑ intro y U y_in_U U_open
    obtain ‚ü®x, rfl‚ü© := h'.surjective y
    let W := œÄ ‚Åª¬π' U
    have x_in_W : x ‚àà W := y_in_U
    have W_open : IsOpen W := U_open.preimage h'.continuous
    obtain ‚ü®Z, Z_in_V, x_in_Z, Z_in_W‚ü© := hV.exists_subset_of_mem_open x_in_W W_open
    have XZ_in_U : œÄ '' Z ‚äÜ U := (Set.image_mono Z_in_W).trans (image_preimage_subset œÄ U)
    exact ‚ü®œÄ '' Z, ‚ü®Z, Z_in_V, rfl‚ü©, ‚ü®x, x_in_Z, rfl‚ü©, XZ_in_U‚ü©

/-- A second countable space is mapped by an open quotient map to a second countable space. -/
theorem _root_.Topology.IsQuotientMap.secondCountableTopology [SecondCountableTopology X]
    (h' : IsQuotientMap œÄ) (h : IsOpenMap œÄ) : SecondCountableTopology Y where
  is_open_generated_countable := by
    obtain ‚ü®V, V_countable, -, V_generates‚ü© := exists_countable_basis X
    exact ‚ü®Set.image œÄ '' V, V_countable.image (Set.image œÄ),
      (V_generates.isQuotientMap h' h).eq_generateFrom‚ü©

variable {S : Setoid X}

/-- The image of a topological basis "downstairs" in an open quotient is a topological basis. -/
theorem IsTopologicalBasis.quotient {V : Set (Set X)} (hV : IsTopologicalBasis V)
    (h : IsOpenMap (Quotient.mk' : X ‚Üí Quotient S)) :
    IsTopologicalBasis (Set.image (Quotient.mk' : X ‚Üí Quotient S) '' V) :=
  hV.isQuotientMap isQuotientMap_quotient_mk' h

/-- An open quotient of a second countable space is second countable. -/
theorem Quotient.secondCountableTopology [SecondCountableTopology X]
    (h : IsOpenMap (Quotient.mk' : X ‚Üí Quotient S)) : SecondCountableTopology (Quotient S) :=
  isQuotientMap_quotient_mk'.secondCountableTopology h

end Quotient

end TopologicalSpace

open TopologicalSpace

variable {Œ± Œ≤ : Type*} [TopologicalSpace Œ±] {f : Œ± ‚Üí Œ≤}

protected theorem Topology.IsInducing.secondCountableTopology [TopologicalSpace Œ≤]
    [SecondCountableTopology Œ≤] (hf : IsInducing f) : SecondCountableTopology Œ± := by
  rw [hf.1]
  exact secondCountableTopology_induced Œ± Œ≤ f

protected theorem Topology.IsEmbedding.secondCountableTopology
    [TopologicalSpace Œ≤] [SecondCountableTopology Œ≤]
    (hf : IsEmbedding f) : SecondCountableTopology Œ± :=
  hf.1.secondCountableTopology

protected theorem Topology.IsEmbedding.separableSpace
    [TopologicalSpace Œ≤] [SecondCountableTopology Œ≤] {f : Œ± ‚Üí Œ≤} (hf : IsEmbedding f) :
    TopologicalSpace.SeparableSpace Œ± := by
  have := hf.secondCountableTopology
  exact SecondCountableTopology.to_separableSpace
