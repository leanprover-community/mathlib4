/-
Copyright (c) 2019 S√©bastien Gou√´zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: S√©bastien Gou√´zel

! This file was ported from Lean 3 source module topology.metric_space.baire
! leanprover-community/mathlib commit f2ce6086713c78a7f880485f7917ea547a215982
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathlib.Analysis.SpecificLimits.Basic
import Mathlib.Order.Filter.CountableInter
import Mathlib.Topology.GDelta
import Mathlib.Topology.Sets.Compacts

/-!
# Baire theorem

In a complete metric space, a countable intersection of dense open subsets is dense.

The good concept underlying the theorem is that of a GŒ¥ set, i.e., a countable intersection
of open sets. Then Baire theorem can also be formulated as the fact that a countable
intersection of dense GŒ¥ sets is a dense GŒ¥ set. We prove Baire theorem, giving several different
formulations that can be handy. We also prove the important consequence that, if the space is
covered by a countable union of closed sets, then the union of their interiors is dense.

We also define the filter `residual Œ±` generated by dense `GŒ¥` sets and prove that this filter
has the countable intersection property.
-/


noncomputable section

open Classical Topology Filter ENNReal

open Filter Encodable Set TopologicalSpace

variable {Œ± : Type _} {Œ≤ : Type _} {Œ≥ : Type _} {Œπ : Type _}

section BaireTheorem

open EMetric ENNReal

/-- The property `BaireSpace Œ±` means that the topological space `Œ±` has the Baire property:
any countable intersection of open dense subsets is dense.
Formulated here when the source space is ‚Ñï (and subsumed below by `dense_inter·µ¢_of_open` working
with any encodable source space). -/
class BaireSpace (Œ± : Type _) [TopologicalSpace Œ±] : Prop where
  baire_property : ‚àÄ f : ‚Ñï ‚Üí Set Œ±, (‚àÄ n, IsOpen (f n)) ‚Üí (‚àÄ n, Dense (f n)) ‚Üí Dense (‚ãÇ n, f n)
#align baire_space BaireSpace

/-- Baire theorems asserts that various topological spaces have the Baire property.
Two versions of these theorems are given.
The first states that complete pseudo_emetric spaces are Baire. -/
instance (priority := 100) baire_category_theorem_emetric_complete [PseudoEMetricSpace Œ±]
    [CompleteSpace Œ±] : BaireSpace Œ± := by
  refine' ‚ü®fun f ho hd => _‚ü©
  let B : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû := fun n => 1 / 2 ^ n
  have Bpos : ‚àÄ n, 0 < B n := by
    intro n
    simp only [one_div, one_mul, ENNReal.inv_pos]
    exact pow_ne_top two_ne_top
  /- Translate the density assumption into two functions `center` and `radius` associating
    to any n, x, Œ¥, Œ¥pos a center and a positive radius such that
    `closedBall center radius` is included both in `f n` and in `closedBall x Œ¥`.
    We can also require `radius ‚â§ (1/2)^(n+1)`, to ensure we get a Cauchy sequence later. -/
  have : ‚àÄ n x Œ¥, Œ¥ ‚â† 0 ‚Üí ‚àÉ y r, 0 < r ‚àß r ‚â§ B (n + 1) ‚àß closedBall y r ‚äÜ closedBall x Œ¥ ‚à© f n :=
    by
    intro n x Œ¥ Œ¥pos
    have : x ‚àà closure (f n) := hd n x
    rcases EMetric.mem_closure_iff.1 this (Œ¥ / 2) (ENNReal.half_pos Œ¥pos) with ‚ü®y, ys, xy‚ü©
    rw [edist_comm] at xy
    obtain ‚ü®r, rpos, hr‚ü© : ‚àÉ r > 0, closedBall y r ‚äÜ f n :=
      nhds_basis_closed_eball.mem_iff.1 (isOpen_iff_mem_nhds.1 (ho n) y ys)
    refine' ‚ü®y, min (min (Œ¥ / 2) r) (B (n + 1)), _, _, fun z hz => ‚ü®_, _‚ü©‚ü©
    show 0 < min (min (Œ¥ / 2) r) (B (n + 1))
    exact lt_min (lt_min (ENNReal.half_pos Œ¥pos) rpos) (Bpos (n + 1))
    show min (min (Œ¥ / 2) r) (B (n + 1)) ‚â§ B (n + 1)
    exact min_le_right _ _
    show z ‚àà closedBall x Œ¥
    exact
      calc
        edist z x ‚â§ edist z y + edist y x := edist_triangle _ _ _
        _ ‚â§ min (min (Œ¥ / 2) r) (B (n + 1)) + Œ¥ / 2 := (add_le_add hz (le_of_lt xy))
        _ ‚â§ Œ¥ / 2 + Œ¥ / 2 := (add_le_add (le_trans (min_le_left _ _) (min_le_left _ _)) le_rfl)
        _ = Œ¥ := ENNReal.add_halves Œ¥
    show z ‚àà f n
    exact hr (calc
      edist z y ‚â§ min (min (Œ¥ / 2) r) (B (n + 1)) := hz
      _ ‚â§ r := le_trans (min_le_left _ _) (min_le_right _ _))
  choose! center radius Hpos HB Hball using this
  refine' fun x => (mem_closure_iff_nhds_basis nhds_basis_closed_eball).2 fun Œµ Œµpos => _
  /- `Œµ` is positive. We have to find a point in the ball of radius `Œµ` around `x` belonging to all
    `f n`. For this, we construct inductively a sequence `F n = (c n, r n)` such that the closed
    ball `closedBall (c n) (r n)` is included in the previous ball and in `f n`, and such that
    `r n` is small enough to ensure that `c n` is a Cauchy sequence. Then `c n` converges to a
    limit which belongs to all the `f n`. -/
  let F : ‚Ñï ‚Üí Œ± √ó ‚Ñù‚â•0‚àû := fun n =>
    Nat.recOn n (Prod.mk x (min Œµ (B 0))) fun n p => Prod.mk (center n p.1 p.2) (radius n p.1 p.2)
  let c : ‚Ñï ‚Üí Œ± := fun n => (F n).1
  let r : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû := fun n => (F n).2
  have rpos : ‚àÄ n, 0 < r n := by
    intro n
    induction' n with n hn
    exact lt_min Œµpos (Bpos 0)
    exact Hpos n (c n) (r n) hn.ne'
  have r0 : ‚àÄ n, r n ‚â† 0 := fun n => (rpos n).ne'
  have rB : ‚àÄ n, r n ‚â§ B n := by
    intro n
    induction' n with n _
    exact min_le_right _ _
    exact HB n (c n) (r n) (r0 n)
  have incl : ‚àÄ n, closedBall (c (n + 1)) (r (n + 1)) ‚äÜ closedBall (c n) (r n) ‚à© f n :=
    fun n => Hball n (c n) (r n) (r0 n)
  have cdist : ‚àÄ n, edist (c n) (c (n + 1)) ‚â§ B n := by
    intro n
    rw [edist_comm]
    have A : c (n + 1) ‚àà closedBall (c (n + 1)) (r (n + 1)) := mem_closedBall_self
    have I :=
      calc
        closedBall (c (n + 1)) (r (n + 1)) ‚äÜ closedBall (c n) (r n) :=
          Subset.trans (incl n) (inter_subset_left _ _)
        _ ‚äÜ closedBall (c n) (B n) := closedBall_subset_closedBall (rB n)
    exact I A
  have : CauchySeq c := cauchySeq_of_edist_le_geometric_two _ one_ne_top cdist
  -- as the sequence `c n` is Cauchy in a complete space, it converges to a limit `y`.
  rcases cauchySeq_tendsto_of_complete this with ‚ü®y, ylim‚ü©
  -- this point `y` will be the desired point. We will check that it belongs to all
  -- `f n` and to `ball x Œµ`.
  use y
  simp only [exists_prop, Set.mem_inter·µ¢]
  have I : ‚àÄ n, ‚àÄ m ‚â• n, closedBall (c m) (r m) ‚äÜ closedBall (c n) (r n) := by
    intro n
    refine' Nat.le_induction _ fun m _ h => _
    ¬∑ exact Subset.refl _
    ¬∑ exact Subset.trans (incl m) (Subset.trans (inter_subset_left _ _) h)
  have yball : ‚àÄ n, y ‚àà closedBall (c n) (r n) := by
    intro n
    refine' isClosed_ball.mem_of_tendsto ylim _
    refine' (Filter.eventually_ge_atTop n).mono fun m hm => _
    exact I n m hm mem_closedBall_self
  constructor
  show ‚àÄ n, y ‚àà f n
  ¬∑ intro n
    have : closedBall (c (n + 1)) (r (n + 1)) ‚äÜ f n :=
      Subset.trans (incl n) (inter_subset_right _ _)
    exact this (yball (n + 1))
  show edist y x ‚â§ Œµ
  exact le_trans (yball 0) (min_le_left _ _)
#align baire_category_theorem_emetric_complete baire_category_theorem_emetric_complete

/-- The second theorem states that locally compact spaces are Baire. -/
instance (priority := 100) baire_category_theorem_locally_compact [TopologicalSpace Œ±] [T2Space Œ±]
    [LocallyCompactSpace Œ±] : BaireSpace Œ± := by
  constructor
  intro f ho hd
  /- To prove that an intersection of open dense subsets is dense, prove that its intersection
    with any open neighbourhood `U` is dense. Define recursively a decreasing sequence `K` of
    compact neighbourhoods: start with some compact neighbourhood inside `U`, then at each step,
    take its interior, intersect with `f n`, then choose a compact neighbourhood inside the
    intersection. -/
  apply dense_iff_inter_open.2
  intro U U_open U_nonempty
  rcases exists_positiveCompacts_subset U_open U_nonempty with ‚ü®K‚ÇÄ, hK‚ÇÄ‚ü©
  have : ‚àÄ (n) (K : PositiveCompacts Œ±), ‚àÉ K' : PositiveCompacts Œ±, ‚ÜëK' ‚äÜ f n ‚à© interior K := by
    refine' fun n K => exists_positiveCompacts_subset ((ho n).inter isOpen_interior) _
    rw [inter_comm]
    exact (hd n).inter_open_nonempty _ isOpen_interior K.interior_nonempty
  choose K_next hK_next using this
  let K : ‚Ñï ‚Üí PositiveCompacts Œ± := fun n => Nat.recOn n K‚ÇÄ K_next
  -- This is a decreasing sequence of positive compacts contained in suitable open sets `f n`.
  have hK_decreasing : ‚àÄ n : ‚Ñï, ((K (n + 1)).carrier) ‚äÜ (f n ‚à© (K n).carrier) :=
    fun n => (hK_next n (K n)).trans <| inter_subset_inter_right _ interior_subset
  -- Prove that ÃÄ`‚ãÇ n : ‚Ñï, K n` is inside `U ‚à© ‚ãÇ n : ‚Ñï, f n`.
  have hK_subset : (‚ãÇ n, (K n).carrier : Set Œ±) ‚äÜ U ‚à© ‚ãÇ n, f n := by
    intro x hx
    simp only [mem_inter·µ¢] at hx
    simp only [mem_inter_iff, mem_inter] at hx‚ä¢
    refine' ‚ü®hK‚ÇÄ <| hx 0, _‚ü©
    simp only [mem_inter·µ¢]
    exact fun n => (hK_decreasing n (hx (n + 1))).1
  /- Prove that `‚ãÇ n : ‚Ñï, K n` is not empty, as an intersection of a decreasing sequence
    of nonempty compact subsets. -/
  have hK_nonempty : (‚ãÇ n, (K n).carrier : Set Œ±).Nonempty :=
    IsCompact.nonempty_inter·µ¢_of_sequence_nonempty_compact_closed _
      (fun n => (hK_decreasing n).trans (inter_subset_right _ _)) (fun n => (K n).nonempty)
      (K 0).isCompact fun n => (K n).isCompact.isClosed
  exact hK_nonempty.mono hK_subset
#align baire_category_theorem_locally_compact baire_category_theorem_locally_compact

variable [TopologicalSpace Œ±] [BaireSpace Œ±]

/-- Definition of a Baire space. -/
theorem dense_inter·µ¢_of_open_nat {f : ‚Ñï ‚Üí Set Œ±} (ho : ‚àÄ n, IsOpen (f n)) (hd : ‚àÄ n, Dense (f n)) :
    Dense (‚ãÇ n, f n) :=
  BaireSpace.baire_property f ho hd
#align dense_Inter_of_open_nat dense_inter·µ¢_of_open_nat

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ‚ãÇ‚ÇÄ. -/
theorem dense_inter‚Çõ_of_open {S : Set (Set Œ±)} (ho : ‚àÄ s ‚àà S, IsOpen s) (hS : S.Countable)
    (hd : ‚àÄ s ‚àà S, Dense s) : Dense (‚ãÇ‚ÇÄ S) := by
  cases' S.eq_empty_or_nonempty with h h
  ¬∑ simp [h]
  ¬∑ rcases hS.exists_eq_range h with ‚ü®f, hf‚ü©
    have F : ‚àÄ n, f n ‚àà S := fun n => by rw [hf]; exact mem_range_self _
    rw [hf, inter‚Çõ_range]
    exact dense_inter·µ¢_of_open_nat (fun n => ho _ (F n)) fun n => hd _ (F n)
#align dense_sInter_of_open dense_inter‚Çõ_of_open

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with
an index set which is a countable set in any type. -/
theorem dense_binter·µ¢_of_open {S : Set Œ≤} {f : Œ≤ ‚Üí Set Œ±} (ho : ‚àÄ s ‚àà S, IsOpen (f s))
    (hS : S.Countable) (hd : ‚àÄ s ‚àà S, Dense (f s)) : Dense (‚ãÇ s ‚àà S, f s) := by
  rw [‚Üê inter‚Çõ_image]
  apply dense_inter‚Çõ_of_open
  ¬∑ rwa [ball_image_iff]
  ¬∑ exact hS.image _
  ¬∑ rwa [ball_image_iff]
#align dense_bInter_of_open dense_binter·µ¢_of_open

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with
an index set which is an encodable type. -/
theorem dense_inter·µ¢_of_open [Encodable Œ≤] {f : Œ≤ ‚Üí Set Œ±} (ho : ‚àÄ s, IsOpen (f s))
    (hd : ‚àÄ s, Dense (f s)) : Dense (‚ãÇ s, f s) := by
  rw [‚Üê inter‚Çõ_range]
  apply dense_inter‚Çõ_of_open
  ¬∑ rwa [forall_range_iff]
  ¬∑ exact countable_range _
  ¬∑ rwa [forall_range_iff]
#align dense_Inter_of_open dense_inter·µ¢_of_open

/-- Baire theorem: a countable intersection of dense GŒ¥ sets is dense. Formulated here with ‚ãÇ‚ÇÄ. -/
theorem dense_inter‚Çõ_of_GŒ¥ {S : Set (Set Œ±)} (ho : ‚àÄ s ‚àà S, IsGŒ¥ s) (hS : S.Countable)
    (hd : ‚àÄ s ‚àà S, Dense s) : Dense (‚ãÇ‚ÇÄ S) := by
  -- the result follows from the result for a countable intersection of dense open sets,
  -- by rewriting each set as a countable intersection of open sets, which are of course dense.
  choose T hTo hTc hsT using ho
  -- porting note: the commented out term was there before
  have : ‚ãÇ‚ÇÄ S = ‚ãÇ‚ÇÄ ‚ãÉ s ‚àà S, T s ‚Äπ_‚Ä∫ := by --(inter‚Çõ_union·µ¢ (fun s hs => (hT s hs).2.2)).symm
    simp [inter‚Çõ_union·µ¢, (hsT _ _).symm, ‚Üê inter‚Çõ_eq_binter·µ¢]
  rw [this]
  refine' dense_inter‚Çõ_of_open _ (hS.bunion·µ¢ hTc) _ <;> simp only [mem_union·µ¢] <;>
    rintro t ‚ü®s, hs, tTs‚ü©
  show IsOpen t
  exact hTo s hs t tTs
  show Dense t
  ¬∑ intro x
    have := hd s hs x
    rw [hsT s hs] at this
    exact closure_mono (inter‚Çõ_subset_of_mem tTs) this
set_option linter.uppercaseLean3 false in
#align dense_sInter_of_GŒ¥ dense_inter‚Çõ_of_GŒ¥

/-- Baire theorem: a countable intersection of dense GŒ¥ sets is dense. Formulated here with
an index set which is an encodable type. -/
theorem dense_inter·µ¢_of_GŒ¥ [Encodable Œ≤] {f : Œ≤ ‚Üí Set Œ±} (ho : ‚àÄ s, IsGŒ¥ (f s))
    (hd : ‚àÄ s, Dense (f s)) : Dense (‚ãÇ s, f s) := by
  rw [‚Üê inter‚Çõ_range]
  exact dense_inter‚Çõ_of_GŒ¥ (forall_range_iff.2 ‚Äπ_‚Ä∫) (countable_range _) (forall_range_iff.2 ‚Äπ_‚Ä∫)
set_option linter.uppercaseLean3 false in
#align dense_Inter_of_GŒ¥ dense_inter·µ¢_of_GŒ¥

-- Porting note: In `ho` and `hd`, changed `‚àÄ s ‚àà S` to `‚àÄ s (H : s ‚àà S)`
/-- Baire theorem: a countable intersection of dense GŒ¥ sets is dense. Formulated here with
an index set which is a countable set in any type. -/
theorem dense_binter·µ¢_of_GŒ¥ {S : Set Œ≤} {f : ‚àÄ x ‚àà S, Set Œ±} (ho : ‚àÄ s (H : s ‚àà S), IsGŒ¥ (f s H))
    (hS : S.Countable) (hd : ‚àÄ s (H : s ‚àà S), Dense (f s H)) : Dense (‚ãÇ s ‚àà S, f s ‚Äπ_‚Ä∫) := by
  rw [binter·µ¢_eq_inter·µ¢]
  haveI := hS.toEncodable
  exact dense_inter·µ¢_of_GŒ¥ (fun s => ho s s.2) fun s => hd s s.2
set_option linter.uppercaseLean3 false in
#align dense_bInter_of_GŒ¥ dense_binter·µ¢_of_GŒ¥

/-- Baire theorem: the intersection of two dense GŒ¥ sets is dense. -/
theorem Dense.inter_of_GŒ¥ {s t : Set Œ±} (hs : IsGŒ¥ s) (ht : IsGŒ¥ t) (hsc : Dense s)
    (htc : Dense t) : Dense (s ‚à© t) := by
  rw [inter_eq_inter·µ¢]
  apply dense_inter·µ¢_of_GŒ¥ <;> simp [Bool.forall_bool, *]
set_option linter.uppercaseLean3 false in
#align dense.inter_of_GŒ¥ Dense.inter_of_GŒ¥

/-- A property holds on a residual (comeagre) set if and only if it holds on some dense `GŒ¥` set. -/
theorem eventually_residual {p : Œ± ‚Üí Prop} :
    (‚àÄ·∂† x in residual Œ±, p x) ‚Üî ‚àÉ t : Set Œ±, IsGŒ¥ t ‚àß Dense t ‚àß ‚àÄ x ‚àà t, p x :=
  calc
    (‚àÄ·∂† x in residual Œ±, p x) ‚Üî ‚àÄ·∂† x in ‚®Ö (t : Set Œ±) (_ht : IsGŒ¥ t ‚àß Dense t), ùìü t, p x := by
      simp only [residual, inf·µ¢_and]
    _ ‚Üî ‚àÉ (t : Set Œ±) (_ : IsGŒ¥ t ‚àß Dense t), ‚àÄ·∂† x in ùìü t, p x := by
      simp only [exists_prop]
      apply mem_binf·µ¢_of_directed
      ¬∑ intro t‚ÇÅ h‚ÇÅ t‚ÇÇ h‚ÇÇ
        exact ‚ü®t‚ÇÅ ‚à© t‚ÇÇ, ‚ü®h‚ÇÅ.1.inter h‚ÇÇ.1, Dense.inter_of_GŒ¥ h‚ÇÅ.1 h‚ÇÇ.1 h‚ÇÅ.2 h‚ÇÇ.2‚ü©, by simp‚ü©
      ¬∑ exact ‚ü®univ, isGŒ¥_univ, dense_univ‚ü©
    _ ‚Üî _ := by simp [and_assoc]
#align eventually_residual eventually_residual

/-- A set is residual (comeagre) if and only if it includes a dense `GŒ¥` set. -/
theorem mem_residual {s : Set Œ±} : s ‚àà residual Œ± ‚Üî ‚àÉ (t : _) (_ : t ‚äÜ s), IsGŒ¥ t ‚àß Dense t :=
  (eventually_residual (p := fun x => x ‚àà s)).trans <|
    exists_congr fun t => by rw [exists_prop, and_comm (a := t ‚äÜ s), subset_def, and_assoc]
#align mem_residual mem_residual

theorem dense_of_mem_residual {s : Set Œ±} (hs : s ‚àà residual Œ±) : Dense s :=
  let ‚ü®_, hts, _, hd‚ü© := mem_residual.1 hs
  hd.mono hts
#align dense_of_mem_residual dense_of_mem_residual

instance : CountableInterFilter (residual Œ±) := ‚ü®by
  intro S hSc hS
  simp only [mem_residual] at *
  choose T hTs hT using hS
  refine' ‚ü®‚ãÇ s ‚àà S, T s ‚Äπ_‚Ä∫, _, _, _‚ü©
  ¬∑ rw [inter‚Çõ_eq_binter·µ¢]
    exact inter·µ¢‚ÇÇ_mono hTs
  ¬∑ exact isGŒ¥_binter·µ¢ hSc fun s hs => (hT s hs).1
  ¬∑ exact dense_binter·µ¢_of_GŒ¥ (fun s hs => (hT s hs).1) hSc fun s hs => (hT s hs).2‚ü©

/-- If a countable family of closed sets cover a dense `GŒ¥` set, then the union of their interiors
is dense. Formulated here with `‚ãÉ`. -/
theorem IsGŒ¥.dense_union·µ¢_interior_of_closed [Encodable Œπ] {s : Set Œ±} (hs : IsGŒ¥ s) (hd : Dense s)
    {f : Œπ ‚Üí Set Œ±} (hc : ‚àÄ i, IsClosed (f i)) (hU : s ‚äÜ ‚ãÉ i, f i) :
    Dense (‚ãÉ i, interior (f i)) := by
  let g i := frontier (f i)·∂ú
  have hgo : ‚àÄ i, IsOpen (g i) := fun i => isClosed_frontier.isOpen_compl
  have hgd : Dense (‚ãÇ i, g i) := by
    refine' dense_inter·µ¢_of_open hgo fun i x => _
    rw [closure_compl, interior_frontier (hc _)]
    exact id
  refine' (hd.inter_of_GŒ¥ hs (isGŒ¥_inter·µ¢ fun i => (hgo i).isGŒ¥) hgd).mono _
  rintro x ‚ü®hxs, hxg‚ü©
  rw [mem_inter·µ¢] at hxg
  rcases mem_union·µ¢.1 (hU hxs) with ‚ü®i, hi‚ü©
  exact mem_union·µ¢.2 ‚ü®i, self_diff_frontier (f i) ‚ñ∏ ‚ü®hi, hxg _‚ü©‚ü©
set_option linter.uppercaseLean3 false in
#align is_GŒ¥.dense_Union_interior_of_closed IsGŒ¥.dense_union·µ¢_interior_of_closed

/-- If a countable family of closed sets cover a dense `GŒ¥` set, then the union of their interiors
is dense. Formulated here with a union over a countable set in any type. -/
theorem IsGŒ¥.dense_bunion·µ¢_interior_of_closed {t : Set Œπ} {s : Set Œ±} (hs : IsGŒ¥ s) (hd : Dense s)
    (ht : t.Countable) {f : Œπ ‚Üí Set Œ±} (hc : ‚àÄ i ‚àà t, IsClosed (f i)) (hU : s ‚äÜ ‚ãÉ i ‚àà t, f i) :
    Dense (‚ãÉ i ‚àà t, interior (f i)) := by
  haveI := ht.toEncodable
  simp only [bunion·µ¢_eq_union·µ¢, SetCoe.forall'] at *
  exact hs.dense_union·µ¢_interior_of_closed hd hc hU
set_option linter.uppercaseLean3 false in
#align is_GŒ¥.dense_bUnion_interior_of_closed IsGŒ¥.dense_bunion·µ¢_interior_of_closed

/-- If a countable family of closed sets cover a dense `GŒ¥` set, then the union of their interiors
is dense. Formulated here with `‚ãÉ‚ÇÄ`. -/
theorem IsGŒ¥.dense_union‚Çõ_interior_of_closed {T : Set (Set Œ±)} {s : Set Œ±} (hs : IsGŒ¥ s)
    (hd : Dense s) (hc : T.Countable) (hc' : ‚àÄ t ‚àà T, IsClosed t) (hU : s ‚äÜ ‚ãÉ‚ÇÄ T) :
    Dense (‚ãÉ t ‚àà T, interior t) :=
  hs.dense_bunion·µ¢_interior_of_closed hd hc hc' <| by rwa [‚Üê union‚Çõ_eq_bunion·µ¢]
set_option linter.uppercaseLean3 false in
#align is_GŒ¥.dense_sUnion_interior_of_closed IsGŒ¥.dense_union‚Çõ_interior_of_closed

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with an index set which is a countable set in any type. -/
theorem dense_bunion·µ¢_interior_of_closed {S : Set Œ≤} {f : Œ≤ ‚Üí Set Œ±} (hc : ‚àÄ s ‚àà S, IsClosed (f s))
    (hS : S.Countable) (hU : (‚ãÉ s ‚àà S, f s) = univ) : Dense (‚ãÉ s ‚àà S, interior (f s)) :=
  isGŒ¥_univ.dense_bunion·µ¢_interior_of_closed dense_univ hS hc hU.ge
#align dense_bUnion_interior_of_closed dense_bunion·µ¢_interior_of_closed

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with `‚ãÉ‚ÇÄ`. -/
theorem dense_union‚Çõ_interior_of_closed {S : Set (Set Œ±)} (hc : ‚àÄ s ‚àà S, IsClosed s)
    (hS : S.Countable) (hU : ‚ãÉ‚ÇÄ S = univ) : Dense (‚ãÉ s ‚àà S, interior s) :=
  isGŒ¥_univ.dense_union‚Çõ_interior_of_closed dense_univ hS hc hU.ge
#align dense_sUnion_interior_of_closed dense_union‚Çõ_interior_of_closed

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with an index set which is an encodable type. -/
theorem dense_union·µ¢_interior_of_closed [Encodable Œ≤] {f : Œ≤ ‚Üí Set Œ±} (hc : ‚àÄ s, IsClosed (f s))
    (hU : (‚ãÉ s, f s) = univ) : Dense (‚ãÉ s, interior (f s)) :=
  isGŒ¥_univ.dense_union·µ¢_interior_of_closed dense_univ hc hU.ge
#align dense_Union_interior_of_closed dense_union·µ¢_interior_of_closed

/-- One of the most useful consequences of Baire theorem: if a countable union of closed sets
covers the space, then one of the sets has nonempty interior. -/
theorem nonempty_interior_of_union·µ¢_of_closed [Nonempty Œ±] [Encodable Œ≤] {f : Œ≤ ‚Üí Set Œ±}
    (hc : ‚àÄ s, IsClosed (f s)) (hU : (‚ãÉ s, f s) = univ) : ‚àÉ s, (interior <| f s).Nonempty := by
  simpa using (dense_union·µ¢_interior_of_closed hc hU).nonempty
#align nonempty_interior_of_Union_of_closed nonempty_interior_of_union·µ¢_of_closed

end BaireTheorem
