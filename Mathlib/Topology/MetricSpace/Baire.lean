/-
Copyright (c) 2019 SÃ©bastien GouÃ«zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: SÃ©bastien GouÃ«zel

! This file was ported from Lean 3 source module topology.metric_space.baire
! leanprover-community/mathlib commit f2ce6086713c78a7f880485f7917ea547a215982
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.SpecificLimits.Basic
import Mathbin.Order.Filter.CountableInter
import Mathbin.Topology.GDelta
import Mathbin.Topology.Sets.Compacts

/-!
# Baire theorem

In a complete metric space, a countable intersection of dense open subsets is dense.

The good concept underlying the theorem is that of a GÎ´ set, i.e., a countable intersection
of open sets. Then Baire theorem can also be formulated as the fact that a countable
intersection of dense GÎ´ sets is a dense GÎ´ set. We prove Baire theorem, giving several different
formulations that can be handy. We also prove the important consequence that, if the space is
covered by a countable union of closed sets, then the union of their interiors is dense.

We also define the filter `residual Î±` generated by dense `GÎ´` sets and prove that this filter
has the countable intersection property.
-/


noncomputable section

open Classical Topology Filter ENNReal

open Filter Encodable Set TopologicalSpace

variable {Î± : Type _} {Î² : Type _} {Î³ : Type _} {Î¹ : Type _}

section BaireTheorem

open Emetric ENNReal

/-- The property `baire_space Î±` means that the topological space `Î±` has the Baire property:
any countable intersection of open dense subsets is dense.
Formulated here when the source space is â„• (and subsumed below by `dense_Inter_of_open` working
with any encodable source space).-/
class BaireSpace (Î± : Type _) [TopologicalSpace Î±] : Prop where
  baire_property : âˆ€ f : â„• â†’ Set Î±, (âˆ€ n, IsOpen (f n)) â†’ (âˆ€ n, Dense (f n)) â†’ Dense (â‹‚ n, f n)
#align baire_space BaireSpace

/-- Baire theorems asserts that various topological spaces have the Baire property.
Two versions of these theorems are given.
The first states that complete pseudo_emetric spaces are Baire. -/
instance (priority := 100) baire_category_theorem_emetric_complete [PseudoEMetricSpace Î±]
    [CompleteSpace Î±] : BaireSpace Î± :=
  by
  refine' âŸ¨fun f ho hd => _âŸ©
  let B : â„• â†’ â„â‰¥0âˆ := fun n => 1 / 2 ^ n
  have Bpos : âˆ€ n, 0 < B n := by
    intro n
    simp only [B, one_div, one_mul, ENNReal.inv_pos]
    exact pow_ne_top two_ne_top
  /- Translate the density assumption into two functions `center` and `radius` associating
    to any n, x, Î´, Î´pos a center and a positive radius such that
    `closed_ball center radius` is included both in `f n` and in `closed_ball x Î´`.
    We can also require `radius â‰¤ (1/2)^(n+1)`, to ensure we get a Cauchy sequence later. -/
  have : âˆ€ n x Î´, Î´ â‰  0 â†’ âˆƒ y r, 0 < r âˆ§ r â‰¤ B (n + 1) âˆ§ closed_ball y r âŠ† closed_ball x Î´ âˆ© f n :=
    by
    intro n x Î´ Î´pos
    have : x âˆˆ closure (f n) := hd n x
    rcases EMetric.mem_closure_iff.1 this (Î´ / 2) (ENNReal.half_pos Î´pos) with âŸ¨y, ys, xyâŸ©
    rw [edist_comm] at xy
    obtain âŸ¨r, rpos, hrâŸ© : âˆƒ r > 0, closed_ball y r âŠ† f n :=
      nhds_basis_closed_eball.mem_iff.1 (isOpen_iff_mem_nhds.1 (ho n) y ys)
    refine' âŸ¨y, min (min (Î´ / 2) r) (B (n + 1)), _, _, fun z hz => âŸ¨_, _âŸ©âŸ©
    show 0 < min (min (Î´ / 2) r) (B (n + 1))
    exact lt_min (lt_min (ENNReal.half_pos Î´pos) rpos) (Bpos (n + 1))
    show min (min (Î´ / 2) r) (B (n + 1)) â‰¤ B (n + 1)
    exact min_le_right _ _
    show z âˆˆ closed_ball x Î´
    exact
      calc
        edist z x â‰¤ edist z y + edist y x := edist_triangle _ _ _
        _ â‰¤ min (min (Î´ / 2) r) (B (n + 1)) + Î´ / 2 := (add_le_add hz (le_of_lt xy))
        _ â‰¤ Î´ / 2 + Î´ / 2 := (add_le_add (le_trans (min_le_left _ _) (min_le_left _ _)) le_rfl)
        _ = Î´ := ENNReal.add_halves Î´
        
    show z âˆˆ f n
    exact
      hr
        (calc
          edist z y â‰¤ min (min (Î´ / 2) r) (B (n + 1)) := hz
          _ â‰¤ r := le_trans (min_le_left _ _) (min_le_right _ _)
          )
  choose! center radius Hpos HB Hball using this
  refine' fun x => (mem_closure_iff_nhds_basis nhds_basis_closed_eball).2 fun Îµ Îµpos => _
  /- `Îµ` is positive. We have to find a point in the ball of radius `Îµ` around `x` belonging to all
    `f n`. For this, we construct inductively a sequence `F n = (c n, r n)` such that the closed ball
    `closed_ball (c n) (r n)` is included in the previous ball and in `f n`, and such that
    `r n` is small enough to ensure that `c n` is a Cauchy sequence. Then `c n` converges to a
    limit which belongs to all the `f n`. -/
  let F : â„• â†’ Î± Ã— â„â‰¥0âˆ := fun n =>
    Nat.recOn n (Prod.mk x (min Îµ (B 0))) fun n p => Prod.mk (center n p.1 p.2) (radius n p.1 p.2)
  let c : â„• â†’ Î± := fun n => (F n).1
  let r : â„• â†’ â„â‰¥0âˆ := fun n => (F n).2
  have rpos : âˆ€ n, 0 < r n := by
    intro n
    induction' n with n hn
    exact lt_min Îµpos (Bpos 0)
    exact Hpos n (c n) (r n) hn.ne'
  have r0 : âˆ€ n, r n â‰  0 := fun n => (rpos n).ne'
  have rB : âˆ€ n, r n â‰¤ B n := by
    intro n
    induction' n with n hn
    exact min_le_right _ _
    exact HB n (c n) (r n) (r0 n)
  have incl : âˆ€ n, closed_ball (c (n + 1)) (r (n + 1)) âŠ† closed_ball (c n) (r n) âˆ© f n := fun n =>
    Hball n (c n) (r n) (r0 n)
  have cdist : âˆ€ n, edist (c n) (c (n + 1)) â‰¤ B n :=
    by
    intro n
    rw [edist_comm]
    have A : c (n + 1) âˆˆ closed_ball (c (n + 1)) (r (n + 1)) := mem_closed_ball_self
    have I :=
      calc
        closed_ball (c (n + 1)) (r (n + 1)) âŠ† closed_ball (c n) (r n) :=
          subset.trans (incl n) (inter_subset_left _ _)
        _ âŠ† closed_ball (c n) (B n) := closed_ball_subset_closed_ball (rB n)
        
    exact I A
  have : CauchySeq c := cauchySeq_of_edist_le_geometric_two _ one_ne_top cdist
  -- as the sequence `c n` is Cauchy in a complete space, it converges to a limit `y`.
  rcases cauchySeq_tendsto_of_complete this with âŸ¨y, ylimâŸ©
  -- this point `y` will be the desired point. We will check that it belongs to all
  -- `f n` and to `ball x Îµ`.
  use y
  simp only [exists_prop, Set.mem_interáµ¢]
  have I : âˆ€ n, âˆ€ m â‰¥ n, closed_ball (c m) (r m) âŠ† closed_ball (c n) (r n) :=
    by
    intro n
    refine' Nat.le_induction _ fun m hnm h => _
    Â· exact subset.refl _
    Â· exact subset.trans (incl m) (subset.trans (inter_subset_left _ _) h)
  have yball : âˆ€ n, y âˆˆ closed_ball (c n) (r n) :=
    by
    intro n
    refine' is_closed_ball.mem_of_tendsto ylim _
    refine' (Filter.eventually_ge_atTop n).mono fun m hm => _
    exact I n m hm mem_closed_ball_self
  constructor
  show âˆ€ n, y âˆˆ f n
  Â· intro n
    have : closed_ball (c (n + 1)) (r (n + 1)) âŠ† f n :=
      subset.trans (incl n) (inter_subset_right _ _)
    exact this (yball (n + 1))
  show edist y x â‰¤ Îµ
  exact le_trans (yball 0) (min_le_left _ _)
#align baire_category_theorem_emetric_complete baire_category_theorem_emetric_complete

/-- The second theorem states that locally compact spaces are Baire. -/
instance (priority := 100) baire_category_theorem_locally_compact [TopologicalSpace Î±] [T2Space Î±]
    [LocallyCompactSpace Î±] : BaireSpace Î± :=
  by
  constructor
  intro f ho hd
  /- To prove that an intersection of open dense subsets is dense, prove that its intersection
    with any open neighbourhood `U` is dense. Define recursively a decreasing sequence `K` of
    compact neighbourhoods: start with some compact neighbourhood inside `U`, then at each step,
    take its interior, intersect with `f n`, then choose a compact neighbourhood inside the
    intersection.-/
  apply dense_iff_inter_open.2
  intro U U_open U_nonempty
  rcases exists_positiveCompacts_subset U_open U_nonempty with âŸ¨Kâ‚€, hKâ‚€âŸ©
  have : âˆ€ (n) (K : positive_compacts Î±), âˆƒ K' : positive_compacts Î±, â†‘K' âŠ† f n âˆ© interior K :=
    by
    refine' fun n K => exists_positiveCompacts_subset ((ho n).inter isOpen_interior) _
    rw [inter_comm]
    exact (hd n).inter_open_nonempty _ isOpen_interior K.interior_nonempty
  choose K_next hK_next
  let K : â„• â†’ positive_compacts Î± := fun n => Nat.recOn n Kâ‚€ K_next
  -- This is a decreasing sequence of positive compacts contained in suitable open sets `f n`.
  have hK_decreasing : âˆ€ n : â„•, â†‘(K (n + 1)) âŠ† f n âˆ© K n := fun n =>
    (hK_next n (K n)).trans <| inter_subset_inter_right _ interior_subset
  -- Prove that Ì€`â‹‚ n : â„•, K n` is inside `U âˆ© â‹‚ n : â„•, (f n)`.
  have hK_subset : (â‹‚ n, K n : Set Î±) âŠ† U âˆ© â‹‚ n, f n :=
    by
    intro x hx
    simp only [mem_inter_iff, mem_Inter] at hxâŠ¢
    exact âŸ¨hKâ‚€ <| hx 0, fun n => (hK_decreasing n (hx (n + 1))).1âŸ©
  /- Prove that `â‹‚ n : â„•, K n` is not empty, as an intersection of a decreasing sequence
    of nonempty compact subsets.-/
  have hK_nonempty : (â‹‚ n, K n : Set Î±).Nonempty :=
    IsCompact.nonempty_interáµ¢_of_sequence_nonempty_compact_closed _
      (fun n => (hK_decreasing n).trans (inter_subset_right _ _)) (fun n => (K n).Nonempty)
      (K 0).IsCompact fun n => (K n).IsCompact.IsClosed
  exact hK_nonempty.mono hK_subset
#align baire_category_theorem_locally_compact baire_category_theorem_locally_compact

variable [TopologicalSpace Î±] [BaireSpace Î±]

/-- Definition of a Baire space. -/
theorem dense_interáµ¢_of_open_nat {f : â„• â†’ Set Î±} (ho : âˆ€ n, IsOpen (f n)) (hd : âˆ€ n, Dense (f n)) :
    Dense (â‹‚ n, f n) :=
  BaireSpace.baire_property f ho hd
#align dense_Inter_of_open_nat dense_interáµ¢_of_open_nat

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. -/
theorem dense_interâ‚›_of_open {S : Set (Set Î±)} (ho : âˆ€ s âˆˆ S, IsOpen s) (hS : S.Countable)
    (hd : âˆ€ s âˆˆ S, Dense s) : Dense (â‹‚â‚€ S) :=
  by
  cases' S.eq_empty_or_nonempty with h h
  Â· simp [h]
  Â· rcases hS.exists_eq_range h with âŸ¨f, hfâŸ©
    have F : âˆ€ n, f n âˆˆ S := fun n => by rw [hf] <;> exact mem_range_self _
    rw [hf, sInter_range]
    exact dense_interáµ¢_of_open_nat (fun n => ho _ (F n)) fun n => hd _ (F n)
#align dense_sInter_of_open dense_interâ‚›_of_open

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with
an index set which is a countable set in any type. -/
theorem dense_bInter_of_open {S : Set Î²} {f : Î² â†’ Set Î±} (ho : âˆ€ s âˆˆ S, IsOpen (f s))
    (hS : S.Countable) (hd : âˆ€ s âˆˆ S, Dense (f s)) : Dense (â‹‚ s âˆˆ S, f s) :=
  by
  rw [â† sInter_image]
  apply dense_interâ‚›_of_open
  Â· rwa [ball_image_iff]
  Â· exact hS.image _
  Â· rwa [ball_image_iff]
#align dense_bInter_of_open dense_bInter_of_open

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with
an index set which is an encodable type. -/
theorem dense_interáµ¢_of_open [Encodable Î²] {f : Î² â†’ Set Î±} (ho : âˆ€ s, IsOpen (f s))
    (hd : âˆ€ s, Dense (f s)) : Dense (â‹‚ s, f s) :=
  by
  rw [â† sInter_range]
  apply dense_interâ‚›_of_open
  Â· rwa [forall_range_iff]
  Â· exact countable_range _
  Â· rwa [forall_range_iff]
#align dense_Inter_of_open dense_interáµ¢_of_open

/-- Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with â‹‚â‚€. -/
theorem dense_interâ‚›_of_GÎ´ {S : Set (Set Î±)} (ho : âˆ€ s âˆˆ S, IsGÎ´ s) (hS : S.Countable)
    (hd : âˆ€ s âˆˆ S, Dense s) : Dense (â‹‚â‚€ S) :=
  by
  -- the result follows from the result for a countable intersection of dense open sets,
  -- by rewriting each set as a countable intersection of open sets, which are of course dense.
  choose T hTo hTc hsT using ho
  have : â‹‚â‚€ S = â‹‚â‚€ â‹ƒ s âˆˆ S, T s â€¹_â€º :=
    by-- := (sInter_bUnion (Î»s hs, (hT s hs).2.2)).symm,
    simp only [sInter_Union, (hsT _ _).symm, â† sInter_eq_bInter]
  rw [this]
  refine' dense_interâ‚›_of_open _ (hS.bUnion hTc) _ <;> simp only [mem_Union] <;>
    rintro t âŸ¨s, hs, tTsâŸ©
  show IsOpen t
  exact hTo s hs t tTs
  show Dense t
  Â· intro x
    have := hd s hs x
    rw [hsT s hs] at this
    exact closure_mono (sInter_subset_of_mem tTs) this
#align dense_sInter_of_GÎ´ dense_interâ‚›_of_GÎ´

/-- Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with
an index set which is an encodable type. -/
theorem dense_interáµ¢_of_GÎ´ [Encodable Î²] {f : Î² â†’ Set Î±} (ho : âˆ€ s, IsGÎ´ (f s))
    (hd : âˆ€ s, Dense (f s)) : Dense (â‹‚ s, f s) :=
  by
  rw [â† sInter_range]
  exact dense_interâ‚›_of_GÎ´ (forall_range_iff.2 â€¹_â€º) (countable_range _) (forall_range_iff.2 â€¹_â€º)
#align dense_Inter_of_GÎ´ dense_interáµ¢_of_GÎ´

/-- Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with
an index set which is a countable set in any type. -/
theorem dense_bInter_of_GÎ´ {S : Set Î²} {f : âˆ€ x âˆˆ S, Set Î±} (ho : âˆ€ s âˆˆ S, IsGÎ´ (f s â€¹_â€º))
    (hS : S.Countable) (hd : âˆ€ s âˆˆ S, Dense (f s â€¹_â€º)) : Dense (â‹‚ s âˆˆ S, f s â€¹_â€º) :=
  by
  rw [bInter_eq_Inter]
  haveI := hS.to_encodable
  exact dense_interáµ¢_of_GÎ´ (fun s => ho s s.2) fun s => hd s s.2
#align dense_bInter_of_GÎ´ dense_bInter_of_GÎ´

/-- Baire theorem: the intersection of two dense GÎ´ sets is dense. -/
theorem Dense.inter_of_GÎ´ {s t : Set Î±} (hs : IsGÎ´ s) (ht : IsGÎ´ t) (hsc : Dense s)
    (htc : Dense t) : Dense (s âˆ© t) := by
  rw [inter_eq_Inter]
  apply dense_interáµ¢_of_GÎ´ <;> simp [Bool.forall_bool, *]
#align dense.inter_of_GÎ´ Dense.inter_of_GÎ´

/-- A property holds on a residual (comeagre) set if and only if it holds on some dense `GÎ´` set. -/
theorem eventually_residual {p : Î± â†’ Prop} :
    (âˆ€á¶  x in residual Î±, p x) â†” âˆƒ t : Set Î±, IsGÎ´ t âˆ§ Dense t âˆ§ âˆ€ x âˆˆ t, p x :=
  calc
    (âˆ€á¶  x in residual Î±, p x) â†” âˆ€á¶  x in â¨… (t : Set Î±) (ht : IsGÎ´ t âˆ§ Dense t), ğ“Ÿ t, p x := by
      simp only [residual, infáµ¢_and]
    _ â†” âˆƒ (t : Set Î±)(ht : IsGÎ´ t âˆ§ Dense t), âˆ€á¶  x in ğ“Ÿ t, p x :=
      (mem_binfáµ¢_of_directed
        (fun tâ‚ hâ‚ tâ‚‚ hâ‚‚ =>
          âŸ¨tâ‚ âˆ© tâ‚‚, âŸ¨hâ‚.1.inter hâ‚‚.1, Dense.inter_of_GÎ´ hâ‚.1 hâ‚‚.1 hâ‚.2 hâ‚‚.2âŸ©, by simpâŸ©)
        âŸ¨univ, isGÎ´_univ, dense_univâŸ©)
    _ â†” _ := by simp [and_assoc']
    
#align eventually_residual eventually_residual

/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t Â«expr âŠ† Â» s) -/
/-- A set is residual (comeagre) if and only if it includes a dense `GÎ´` set. -/
theorem mem_residual {s : Set Î±} : s âˆˆ residual Î± â†” âˆƒ (t : _)(_ : t âŠ† s), IsGÎ´ t âˆ§ Dense t :=
  (@eventually_residual Î± _ _ fun x => x âˆˆ s).trans <|
    exists_congr fun t => by rw [exists_prop, and_comm' (t âŠ† s), subset_def, and_assoc']
#align mem_residual mem_residual

theorem dense_of_mem_residual {s : Set Î±} (hs : s âˆˆ residual Î±) : Dense s :=
  let âŸ¨t, hts, _, hdâŸ© := mem_residual.1 hs
  hd.mono hts
#align dense_of_mem_residual dense_of_mem_residual

instance : CountableInterFilter (residual Î±) :=
  âŸ¨by
    intro S hSc hS
    simp only [mem_residual] at *
    choose T hTs hT using hS
    refine' âŸ¨â‹‚ s âˆˆ S, T s â€¹_â€º, _, _, _âŸ©
    Â· rw [sInter_eq_bInter]
      exact Interâ‚‚_mono hTs
    Â· exact isGÎ´_binteráµ¢ hSc fun s hs => (hT s hs).1
    Â· exact dense_bInter_of_GÎ´ (fun s hs => (hT s hs).1) hSc fun s hs => (hT s hs).2âŸ©

/-- If a countable family of closed sets cover a dense `GÎ´` set, then the union of their interiors
is dense. Formulated here with `â‹ƒ`. -/
theorem IsGÎ´.dense_unionáµ¢_interior_of_closed [Encodable Î¹] {s : Set Î±} (hs : IsGÎ´ s) (hd : Dense s)
    {f : Î¹ â†’ Set Î±} (hc : âˆ€ i, IsClosed (f i)) (hU : s âŠ† â‹ƒ i, f i) : Dense (â‹ƒ i, interior (f i)) :=
  by
  let g i := frontier (f i)á¶œ
  have hgo : âˆ€ i, IsOpen (g i) := fun i => is_closed_frontier.is_open_compl
  have hgd : Dense (â‹‚ i, g i) :=
    by
    refine' dense_interáµ¢_of_open hgo fun i x => _
    rw [closure_compl, interior_frontier (hc _)]
    exact id
  refine' (hd.inter_of_GÎ´ hs (isGÎ´_interáµ¢ fun i => (hgo i).IsGÎ´) hgd).mono _
  rintro x âŸ¨hxs, hxgâŸ©
  rw [mem_Inter] at hxg
  rcases mem_Union.1 (hU hxs) with âŸ¨i, hiâŸ©
  exact mem_Union.2 âŸ¨i, self_diff_frontier (f i) â–¸ âŸ¨hi, hxg _âŸ©âŸ©
#align is_GÎ´.dense_Union_interior_of_closed IsGÎ´.dense_unionáµ¢_interior_of_closed

/-- If a countable family of closed sets cover a dense `GÎ´` set, then the union of their interiors
is dense. Formulated here with a union over a countable set in any type. -/
theorem IsGÎ´.dense_bUnion_interior_of_closed {t : Set Î¹} {s : Set Î±} (hs : IsGÎ´ s) (hd : Dense s)
    (ht : t.Countable) {f : Î¹ â†’ Set Î±} (hc : âˆ€ i âˆˆ t, IsClosed (f i)) (hU : s âŠ† â‹ƒ i âˆˆ t, f i) :
    Dense (â‹ƒ i âˆˆ t, interior (f i)) :=
  by
  haveI := ht.to_encodable
  simp only [bUnion_eq_Union, SetCoe.forall'] at *
  exact hs.dense_Union_interior_of_closed hd hc hU
#align is_GÎ´.dense_bUnion_interior_of_closed IsGÎ´.dense_bUnion_interior_of_closed

/-- If a countable family of closed sets cover a dense `GÎ´` set, then the union of their interiors
is dense. Formulated here with `â‹ƒâ‚€`. -/
theorem IsGÎ´.dense_unionâ‚›_interior_of_closed {T : Set (Set Î±)} {s : Set Î±} (hs : IsGÎ´ s)
    (hd : Dense s) (hc : T.Countable) (hc' : âˆ€ t âˆˆ T, IsClosed t) (hU : s âŠ† â‹ƒâ‚€ T) :
    Dense (â‹ƒ t âˆˆ T, interior t) :=
  hs.dense_bUnion_interior_of_closed hd hc hc' <| by rwa [â† sUnion_eq_bUnion]
#align is_GÎ´.dense_sUnion_interior_of_closed IsGÎ´.dense_unionâ‚›_interior_of_closed

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with an index set which is a countable set in any type. -/
theorem dense_bUnion_interior_of_closed {S : Set Î²} {f : Î² â†’ Set Î±} (hc : âˆ€ s âˆˆ S, IsClosed (f s))
    (hS : S.Countable) (hU : (â‹ƒ s âˆˆ S, f s) = univ) : Dense (â‹ƒ s âˆˆ S, interior (f s)) :=
  isGÎ´_univ.dense_bUnion_interior_of_closed dense_univ hS hc hU.ge
#align dense_bUnion_interior_of_closed dense_bUnion_interior_of_closed

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with `â‹ƒâ‚€`. -/
theorem dense_unionâ‚›_interior_of_closed {S : Set (Set Î±)} (hc : âˆ€ s âˆˆ S, IsClosed s)
    (hS : S.Countable) (hU : â‹ƒâ‚€ S = univ) : Dense (â‹ƒ s âˆˆ S, interior s) :=
  isGÎ´_univ.dense_unionâ‚›_interior_of_closed dense_univ hS hc hU.ge
#align dense_sUnion_interior_of_closed dense_unionâ‚›_interior_of_closed

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with an index set which is an encodable type. -/
theorem dense_unionáµ¢_interior_of_closed [Encodable Î²] {f : Î² â†’ Set Î±} (hc : âˆ€ s, IsClosed (f s))
    (hU : (â‹ƒ s, f s) = univ) : Dense (â‹ƒ s, interior (f s)) :=
  isGÎ´_univ.dense_unionáµ¢_interior_of_closed dense_univ hc hU.ge
#align dense_Union_interior_of_closed dense_unionáµ¢_interior_of_closed

/-- One of the most useful consequences of Baire theorem: if a countable union of closed sets
covers the space, then one of the sets has nonempty interior. -/
theorem nonempty_interior_of_unionáµ¢_of_closed [Nonempty Î±] [Encodable Î²] {f : Î² â†’ Set Î±}
    (hc : âˆ€ s, IsClosed (f s)) (hU : (â‹ƒ s, f s) = univ) : âˆƒ s, (interior <| f s).Nonempty := by
  simpa using (dense_unionáµ¢_interior_of_closed hc hU).Nonempty
#align nonempty_interior_of_Union_of_closed nonempty_interior_of_unionáµ¢_of_closed

end BaireTheorem

