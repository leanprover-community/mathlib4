/-
Copyright (c) 2023 Felix Weilacher. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Felix Weilacher
-/
import Mathlib.Topology.MetricSpace.PiNat

#align_import topology.metric_space.cantor_scheme from "leanprover-community/mathlib"@"49b7f94aab3a3bdca1f9f34c5d818afb253b3993"

/-!
# (Topological) Schemes and their induced maps

In topology, and especially descriptive set theory, one often constructs functions `(‚Ñï ‚Üí Œ≤) ‚Üí Œ±`,
where Œ± is some topological space and Œ≤ is a discrete space, as an appropriate limit of some map
`List Œ≤ ‚Üí Set Œ±`. We call the latter type of map a "`Œ≤`-scheme on `Œ±`".

This file develops the basic, abstract theory of these schemes and the functions they induce.

## Main Definitions

* `CantorScheme.inducedMap A` : The aforementioned "limit" of a scheme `A : List Œ≤ ‚Üí Set Œ±`.
  This is a partial function from `‚Ñï ‚Üí Œ≤` to `a`,
  implemented here as an object of type `Œ£ s : Set (‚Ñï ‚Üí Œ≤), s ‚Üí Œ±`.
  That is, `(inducedMap A).1` is the domain and `(inducedMap A).2` is the function.

## Implementation Notes

We consider end-appending to be the fundamental way to build lists (say on `Œ≤`) inductively,
as this interacts better with the topology on `‚Ñï ‚Üí Œ≤`.
As a result, functions like `List.get?` or `Stream'.take` do not have their intended meaning
in this file. See instead `PiNat.res`.

## References

* [kechris1995] (Chapters 6-7)

## Tags

scheme, cantor scheme, lusin scheme, approximation.

-/


namespace CantorScheme

open List Function Filter Set PiNat

open scoped Classical
open Topology

variable {Œ≤ Œ± : Type*} (A : List Œ≤ ‚Üí Set Œ±)

/-- From a `Œ≤`-scheme on `Œ±` `A`, we define a partial function from `(‚Ñï ‚Üí Œ≤)` to `Œ±`
which sends each infinite sequence `x` to an element of the intersection along the
branch corresponding to `x`, if it exists.
We call this the map induced by the scheme. -/
noncomputable def inducedMap : Œ£s : Set (‚Ñï ‚Üí Œ≤), s ‚Üí Œ± :=
  ‚ü®fun x => Set.Nonempty (‚ãÇ n : ‚Ñï, A (res x n)), fun x => x.property.some‚ü©
#align cantor_scheme.induced_map CantorScheme.inducedMap

section Topology

/-- A scheme is antitone if each set contains its children. -/
protected def Antitone : Prop :=
  ‚àÄ l : List Œ≤, ‚àÄ a : Œ≤, A (a :: l) ‚äÜ A l
#align cantor_scheme.antitone CantorScheme.Antitone

/-- A useful strengthening of being antitone is to require that each set contains
the closure of each of its children. -/
def ClosureAntitone [TopologicalSpace Œ±] : Prop :=
  ‚àÄ l : List Œ≤, ‚àÄ a : Œ≤, closure (A (a :: l)) ‚äÜ A l
#align cantor_scheme.closure_antitone CantorScheme.ClosureAntitone

/-- A scheme is disjoint if the children of each set of pairwise disjoint. -/
protected def Disjoint : Prop :=
  ‚àÄ l : List Œ≤, Pairwise fun a b => Disjoint (A (a :: l)) (A (b :: l))
#align cantor_scheme.disjoint CantorScheme.Disjoint

variable {A}

/-- If `x` is in the domain of the induced map of a scheme `A`,
its image under this map is in each set along the corresponding branch. -/
theorem map_mem (x : (inducedMap A).1) (n : ‚Ñï) : (inducedMap A).2 x ‚àà A (res x n) := by
  have := x.property.some_mem
  rw [mem_iInter] at this
  exact this n
#align cantor_scheme.map_mem CantorScheme.map_mem

protected theorem ClosureAntitone.antitone [TopologicalSpace Œ±] (hA : ClosureAntitone A) :
    CantorScheme.Antitone A := fun l a => subset_closure.trans (hA l a)
#align cantor_scheme.closure_antitone.antitone CantorScheme.ClosureAntitone.antitone

protected theorem Antitone.closureAntitone [TopologicalSpace Œ±] (hanti : CantorScheme.Antitone A)
    (hclosed : ‚àÄ l, IsClosed (A l)) : ClosureAntitone A := fun _ _ =>
  (hclosed _).closure_eq.subset.trans (hanti _ _)
#align cantor_scheme.antitone.closure_antitone CantorScheme.Antitone.closureAntitone

/-- A scheme where the children of each set are pairwise disjoint induces an injective map. -/
theorem Disjoint.map_injective (hA : CantorScheme.Disjoint A) : Injective (inducedMap A).2 := by
  rintro ‚ü®x, hx‚ü© ‚ü®y, hy‚ü© hxy
  refine' Subtype.coe_injective (res_injective _)
  dsimp
  ext n : 1
  induction' n with n ih; ¬∑ simp
  simp only [res_succ, cons.injEq]
  refine' ‚ü®_, ih‚ü©
  contrapose hA
  simp only [CantorScheme.Disjoint, _root_.Pairwise, Ne.def, not_forall, exists_prop]
  refine' ‚ü®res x n, _, _, hA, _‚ü©
  rw [not_disjoint_iff]
  refine' ‚ü®(inducedMap A).2 ‚ü®x, hx‚ü©, _, _‚ü©
  ¬∑ rw [‚Üê res_succ]
    apply map_mem
  rw [hxy, ih, ‚Üê res_succ]
  apply map_mem
#align cantor_scheme.disjoint.map_injective CantorScheme.Disjoint.map_injective

end Topology

section Metric

variable [PseudoMetricSpace Œ±]

/-- A scheme on a metric space has vanishing diameter if diameter approaches 0 along each branch. -/
def VanishingDiam : Prop :=
  ‚àÄ x : ‚Ñï ‚Üí Œ≤, Tendsto (fun n : ‚Ñï => EMetric.diam (A (res x n))) atTop (ùìù 0)
#align cantor_scheme.vanishing_diam CantorScheme.VanishingDiam

variable {A}

theorem VanishingDiam.dist_lt (hA : VanishingDiam A) (Œµ : ‚Ñù) (Œµ_pos : 0 < Œµ) (x : ‚Ñï ‚Üí Œ≤) :
    ‚àÉ n : ‚Ñï, ‚àÄ (y) (_ : y ‚àà A (res x n)) (z) (_ : z ‚àà A (res x n)), dist y z < Œµ := by
  specialize hA x
  rw [ENNReal.tendsto_atTop_zero] at hA
  cases' hA (ENNReal.ofReal (Œµ / 2)) (by
    simp only [gt_iff_lt, ENNReal.ofReal_pos]
    linarith) with n hn
  use n
  intro y hy z hz
  rw [‚Üê ENNReal.ofReal_lt_ofReal_iff Œµ_pos, ‚Üê edist_dist]
  apply lt_of_le_of_lt (EMetric.edist_le_diam_of_mem hy hz)
  apply lt_of_le_of_lt (hn _ (le_refl _))
  rw [ENNReal.ofReal_lt_ofReal_iff Œµ_pos]
  linarith
#align cantor_scheme.vanishing_diam.dist_lt CantorScheme.VanishingDiam.dist_lt

/-- A scheme with vanishing diameter along each branch induces a continuous map. -/
theorem VanishingDiam.map_continuous [TopologicalSpace Œ≤] [DiscreteTopology Œ≤]
    (hA : VanishingDiam A) : Continuous (inducedMap A).2 := by
  rw [Metric.continuous_iff']
  rintro ‚ü®x, hx‚ü© Œµ Œµ_pos
  cases' hA.dist_lt _ Œµ_pos x with n hn
  rw [_root_.eventually_nhds_iff]
  refine' ‚ü®(‚Üë)‚Åª¬π' cylinder x n, _, _, by simp‚ü©
  ¬∑ rintro ‚ü®y, hy‚ü© hyx
    rw [mem_preimage, Subtype.coe_mk, cylinder_eq_res, mem_setOf] at hyx
    apply hn
    ¬∑ rw [‚Üê hyx]
      apply map_mem
    apply map_mem
  apply continuous_subtype_val.isOpen_preimage
  apply isOpen_cylinder
#align cantor_scheme.vanishing_diam.map_continuous CantorScheme.VanishingDiam.map_continuous

/-- A scheme on a complete space with vanishing diameter
such that each set contains the closure of its children
induces a total map. -/
theorem ClosureAntitone.map_of_vanishingDiam [CompleteSpace Œ±] (hdiam : VanishingDiam A)
    (hanti : ClosureAntitone A) (hnonempty : ‚àÄ l, (A l).Nonempty) : (inducedMap A).1 = univ := by
  rw [eq_univ_iff_forall]
  intro x
  choose u hu using fun n => hnonempty (res x n)
  have umem : ‚àÄ n m : ‚Ñï, n ‚â§ m ‚Üí u m ‚àà A (res x n) := by
    have : Antitone fun n : ‚Ñï => A (res x n) := by
      refine' antitone_nat_of_succ_le _
      intro n
      apply hanti.antitone
    intro n m hnm
    exact this hnm (hu _)
  have : CauchySeq u := by
    rw [Metric.cauchySeq_iff]
    intro Œµ Œµ_pos
    cases' hdiam.dist_lt _ Œµ_pos x with n hn
    use n
    intro m‚ÇÄ hm‚ÇÄ m‚ÇÅ hm‚ÇÅ
    apply hn <;> apply umem <;> assumption
  cases' cauchySeq_tendsto_of_complete this with y hy
  use y
  rw [mem_iInter]
  intro n
  apply hanti _ (x n)
  apply mem_closure_of_tendsto hy
  rw [eventually_atTop]
  exact ‚ü®n.succ, umem _‚ü©
#align cantor_scheme.closure_antitone.map_of_vanishing_diam CantorScheme.ClosureAntitone.map_of_vanishingDiam

end Metric

end CantorScheme
