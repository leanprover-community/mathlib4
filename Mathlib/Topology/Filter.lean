/-
Copyright (c) 2022 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov
-/
import Mathlib.Order.Filter.Lift
import Mathlib.Order.Interval.Set.Monotone
import Mathlib.Topology.Separation.Basic

/-!
# Topology on the set of filters on a type

This file introduces a topology on `Filter Î±`. It is generated by the sets
`Set.Iic (ğ“Ÿ s) = {l : Filter Î± | s âˆˆ l}`, `s : Set Î±`. A set `s : Set (Filter Î±)` is open if and
only if it is a union of a family of these basic open sets, see `Filter.isOpen_iff`.

This topology has the following important properties.

* If `X` is a topological space, then the map `ğ“ : X â†’ Filter X` is a topology inducing map.

* In particular, it is a continuous map, so `ğ“ âˆ˜ f` tends to `ğ“ (ğ“ a)` whenever `f` tends to `ğ“ a`.

* If `X` is an ordered topological space with order topology and no max element, then `ğ“ âˆ˜ f` tends
  to `ğ“ Filter.atTop` whenever `f` tends to `Filter.atTop`.

* It turns `Filter X` into a Tâ‚€ space and the order on `Filter X` is the dual of the
  `specializationOrder (Filter X)`.

## Tags

filter, topological space
-/


open Set Filter TopologicalSpace

open Filter Topology

variable {Î¹ : Sort*} {Î± Î² X Y : Type*}

namespace Filter

/-- The topology on `Filter Î±` is generated by the sets `Set.Iic (ğ“Ÿ s) = {l : Filter Î± | s âˆˆ l}`,
`s : Set Î±`. A set `s : Set (Filter Î±)` is open if and only if it is a union of a family of these
basic open sets, see `Filter.isOpen_iff`. -/
instance : TopologicalSpace (Filter Î±) :=
  generateFrom <| range <| Iic âˆ˜ ğ“Ÿ

theorem isOpen_Iic_principal {s : Set Î±} : IsOpen (Iic (ğ“Ÿ s)) :=
  GenerateOpen.basic _ (mem_range_self _)

theorem isOpen_setOf_mem {s : Set Î±} : IsOpen { l : Filter Î± | s âˆˆ l } := by
  simpa only [Iic_principal] using isOpen_Iic_principal

theorem isTopologicalBasis_Iic_principal :
    IsTopologicalBasis (range (Iic âˆ˜ ğ“Ÿ : Set Î± â†’ Set (Filter Î±))) :=
  { exists_subset_inter := by
      rintro _ âŸ¨s, rflâŸ© _ âŸ¨t, rflâŸ© l hl
      exact âŸ¨Iic (ğ“Ÿ s) âˆ© Iic (ğ“Ÿ t), âŸ¨s âˆ© t, by simpâŸ©, hl, Subset.rflâŸ©
    sUnion_eq := sUnion_eq_univ_iff.2 fun _ => âŸ¨Iic âŠ¤, âŸ¨univ, congr_arg Iic principal_univâŸ©,
      mem_Iic.2 le_topâŸ©
    eq_generateFrom := rfl }

theorem isOpen_iff {s : Set (Filter Î±)} : IsOpen s â†” âˆƒ T : Set (Set Î±), s = â‹ƒ t âˆˆ T, Iic (ğ“Ÿ t) :=
  isTopologicalBasis_Iic_principal.open_iff_eq_sUnion.trans <| by
    simp only [exists_subset_range_and_iff, sUnion_image, (Â· âˆ˜ Â·)]

theorem nhds_eq (l : Filter Î±) : ğ“ l = l.lift' (Iic âˆ˜ ğ“Ÿ) :=
  nhds_generateFrom.trans <| by
    simp only [mem_setOf_eq, @and_comm (l âˆˆ _), iInf_and, iInf_range, Filter.lift', Filter.lift,
      (Â· âˆ˜ Â·), mem_Iic, le_principal_iff]

theorem nhds_eq' (l : Filter Î±) : ğ“ l = l.lift' fun s => { l' | s âˆˆ l' } := by
  simpa only [Function.comp_def, Iic_principal] using nhds_eq l

protected theorem tendsto_nhds {la : Filter Î±} {lb : Filter Î²} {f : Î± â†’ Filter Î²} :
    Tendsto f la (ğ“ lb) â†” âˆ€ s âˆˆ lb, âˆ€á¶  a in la, s âˆˆ f a := by
  simp only [nhds_eq', tendsto_lift', mem_setOf_eq]

protected theorem HasBasis.nhds {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} (h : HasBasis l p s) :
    HasBasis (ğ“ l) p fun i => Iic (ğ“Ÿ (s i)) := by
  rw [nhds_eq]
  exact h.lift' monotone_principal.Iic

protected theorem tendsto_pure_self (l : Filter X) :
    Tendsto (pure : X â†’ Filter X) l (ğ“ l) := by
  rw [Filter.tendsto_nhds]
  exact fun s hs â†¦ Eventually.mono hs fun x â†¦ id

/-- Neighborhoods of a countably generated filter is a countably generated filter. -/
instance {l : Filter Î±} [IsCountablyGenerated l] : IsCountablyGenerated (ğ“ l) :=
  let âŸ¨_b, hbâŸ© := l.exists_antitone_basis
  HasCountableBasis.isCountablyGenerated <| âŸ¨hb.nhds, Set.to_countable _âŸ©

theorem HasBasis.nhds' {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} (h : HasBasis l p s) :
    HasBasis (ğ“ l) p fun i => { l' | s i âˆˆ l' } := by simpa only [Iic_principal] using h.nhds

protected theorem mem_nhds_iff {l : Filter Î±} {S : Set (Filter Î±)} :
    S âˆˆ ğ“ l â†” âˆƒ t âˆˆ l, Iic (ğ“Ÿ t) âŠ† S :=
  l.basis_sets.nhds.mem_iff

theorem mem_nhds_iff' {l : Filter Î±} {S : Set (Filter Î±)} :
    S âˆˆ ğ“ l â†” âˆƒ t âˆˆ l, âˆ€ â¦ƒl' : Filter Î±â¦„, t âˆˆ l' â†’ l' âˆˆ S :=
  l.basis_sets.nhds'.mem_iff

@[simp]
theorem nhds_bot : ğ“ (âŠ¥ : Filter Î±) = pure âŠ¥ := by
  simp [nhds_eq, Function.comp_def, lift'_bot monotone_principal.Iic]

@[simp]
theorem nhds_top : ğ“ (âŠ¤ : Filter Î±) = âŠ¤ := by simp [nhds_eq]

@[simp]
theorem nhds_principal (s : Set Î±) : ğ“ (ğ“Ÿ s) = ğ“Ÿ (Iic (ğ“Ÿ s)) :=
  (hasBasis_principal s).nhds.eq_of_same_basis (hasBasis_principal _)

@[simp]
theorem nhds_pure (x : Î±) : ğ“ (pure x : Filter Î±) = ğ“Ÿ {âŠ¥, pure x} := by
  rw [â† principal_singleton, nhds_principal, principal_singleton, Iic_pure]

@[simp]
protected theorem nhds_iInf (f : Î¹ â†’ Filter Î±) : ğ“ (â¨… i, f i) = â¨… i, ğ“ (f i) := by
  simp only [nhds_eq]
  apply lift'_iInf_of_map_univ <;> simp

@[simp]
protected theorem nhds_inf (lâ‚ lâ‚‚ : Filter Î±) : ğ“ (lâ‚ âŠ“ lâ‚‚) = ğ“ lâ‚ âŠ“ ğ“ lâ‚‚ := by
  simpa only [iInf_bool_eq] using Filter.nhds_iInf fun b => cond b lâ‚ lâ‚‚

theorem monotone_nhds : Monotone (ğ“ : Filter Î± â†’ Filter (Filter Î±)) :=
  Monotone.of_map_inf Filter.nhds_inf

theorem sInter_nhds (l : Filter Î±) : â‹‚â‚€ { s | s âˆˆ ğ“ l } = Iic l := by
  simp_rw [nhds_eq, Function.comp_def, sInter_lift'_sets monotone_principal.Iic, Iic,
    le_principal_iff, â† setOf_forall, â† Filter.le_def]

@[simp]
theorem nhds_mono {lâ‚ lâ‚‚ : Filter Î±} : ğ“ lâ‚ â‰¤ ğ“ lâ‚‚ â†” lâ‚ â‰¤ lâ‚‚ := by
  refine âŸ¨fun h => ?_, fun h => monotone_nhds hâŸ©
  rw [â† Iic_subset_Iic, â† sInter_nhds, â† sInter_nhds]
  exact sInter_subset_sInter h

protected theorem mem_interior {s : Set (Filter Î±)} {l : Filter Î±} :
    l âˆˆ interior s â†” âˆƒ t âˆˆ l, Iic (ğ“Ÿ t) âŠ† s := by
  rw [mem_interior_iff_mem_nhds, Filter.mem_nhds_iff]

protected theorem mem_closure {s : Set (Filter Î±)} {l : Filter Î±} :
    l âˆˆ closure s â†” âˆ€ t âˆˆ l, âˆƒ l' âˆˆ s, t âˆˆ l' := by
  simp only [closure_eq_compl_interior_compl, Filter.mem_interior, mem_compl_iff, not_exists,
    not_forall, Classical.not_not, exists_prop, not_and, and_comm, subset_def, mem_Iic,
    le_principal_iff]

@[simp]
protected theorem closure_singleton (l : Filter Î±) : closure {l} = Ici l := by
  ext l'
  simp [Filter.mem_closure, Filter.le_def]

@[simp]
theorem specializes_iff_le {lâ‚ lâ‚‚ : Filter Î±} : lâ‚ â¤³ lâ‚‚ â†” lâ‚ â‰¤ lâ‚‚ := by
  simp only [specializes_iff_closure_subset, Filter.closure_singleton, Ici_subset_Ici]

instance : T0Space (Filter Î±) :=
  âŸ¨fun _ _ h => (specializes_iff_le.1 h.specializes).antisymm
    (specializes_iff_le.1 h.symm.specializes)âŸ©

theorem nhds_atTop [Preorder Î±] : ğ“ atTop = â¨… x : Î±, ğ“Ÿ (Iic (ğ“Ÿ (Ici x))) := by
  simp only [atTop, Filter.nhds_iInf, nhds_principal]

protected theorem tendsto_nhds_atTop_iff [Preorder Î²] {l : Filter Î±} {f : Î± â†’ Filter Î²} :
    Tendsto f l (ğ“ atTop) â†” âˆ€ y, âˆ€á¶  a in l, Ici y âˆˆ f a := by
  simp only [nhds_atTop, tendsto_iInf, tendsto_principal, mem_Iic, le_principal_iff]

theorem nhds_atBot [Preorder Î±] : ğ“ atBot = â¨… x : Î±, ğ“Ÿ (Iic (ğ“Ÿ (Iic x))) :=
  @nhds_atTop Î±áµ’áµˆ _

protected theorem tendsto_nhds_atBot_iff [Preorder Î²] {l : Filter Î±} {f : Î± â†’ Filter Î²} :
    Tendsto f l (ğ“ atBot) â†” âˆ€ y, âˆ€á¶  a in l, Iic y âˆˆ f a :=
  @Filter.tendsto_nhds_atTop_iff Î± Î²áµ’áµˆ _ _ _

variable [TopologicalSpace X]

theorem nhds_nhds (x : X) :
    ğ“ (ğ“ x) = â¨… (s : Set X) (_ : IsOpen s) (_ : x âˆˆ s), ğ“Ÿ (Iic (ğ“Ÿ s)) := by
  simp only [(nhds_basis_opens x).nhds.eq_biInf, iInf_and, @iInf_comm _ (_ âˆˆ _)]

theorem isInducing_nhds : IsInducing (ğ“ : X â†’ Filter X) :=
  isInducing_iff_nhds.2 fun x =>
    (nhds_def' _).trans <| by
      simp +contextual only [nhds_nhds, comap_iInf, comap_principal,
        Iic_principal, preimage_setOf_eq, â† mem_interior_iff_mem_nhds, setOf_mem_eq,
        IsOpen.interior_eq]

@[deprecated (since := "2024-10-28")] alias inducing_nhds := isInducing_nhds

@[continuity]
theorem continuous_nhds : Continuous (ğ“ : X â†’ Filter X) :=
  isInducing_nhds.continuous

protected theorem Tendsto.nhds {f : Î± â†’ X} {l : Filter Î±} {x : X} (h : Tendsto f l (ğ“ x)) :
    Tendsto (ğ“ âˆ˜ f) l (ğ“ (ğ“ x)) :=
  (continuous_nhds.tendsto _).comp h

end Filter

variable [TopologicalSpace X] [TopologicalSpace Y] {f : X â†’ Y} {x : X} {s : Set X}

protected nonrec theorem ContinuousWithinAt.nhds (h : ContinuousWithinAt f s x) :
    ContinuousWithinAt (ğ“ âˆ˜ f) s x :=
  h.nhds

protected nonrec theorem ContinuousAt.nhds (h : ContinuousAt f x) : ContinuousAt (ğ“ âˆ˜ f) x :=
  h.nhds

protected nonrec theorem ContinuousOn.nhds (h : ContinuousOn f s) : ContinuousOn (ğ“ âˆ˜ f) s :=
  fun x hx => (h x hx).nhds

protected nonrec theorem Continuous.nhds (h : Continuous f) : Continuous (ğ“ âˆ˜ f) :=
  Filter.continuous_nhds.comp h
