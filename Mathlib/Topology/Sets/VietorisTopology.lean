/-
Copyright (c) 2025 Attila Gáspár. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Attila Gáspár
-/
module

public import Mathlib.Topology.Sets.Compacts

/-!
# Vietoris topology

This file defines the Vietoris topology on the types of compact subsets and nonempty compact subsets
of a topological space. The Vietoris topology is generated by sets of the form
$\{K \mid K \subseteq U\}$ and $\{K \mid K \cap U \ne \emptyset\}$, where $U$ is an open subset of
the underlying space.

## Implementation notes

Rather than defining the topology directly on `TopologicalSpace.Compacts α`, we first define
`TopologicalSpace.vietoris α` on `Set α`, then we take the subspace topology on
`TopologicalSpace.Compacts α` and `TopologicalSpace.NonemptyCompacts α`. This approach will
let us reuse several results if a type of closed sets equipped with the Vietoris topology is
defined in the future.

Note that we do not equip `TopologicalSpace.Closeds α` with the Vietoris topology. When `α` is a
metric space, `TopologicalSpace.Closeds α` is equipped with the Hausdorff metric, which is generally
incompatible with the Vietoris topology.

## References

* [Ernest Michael, *Topologies on spaces of subsets*][michael1951]
-/

@[expose] public section

open Set Topology

variable (α : Type*) [TopologicalSpace α]

namespace TopologicalSpace

/-- The Vietoris topology on the powerset of a topological space, generated by sets of the form
`{A | A ⊆ U}` and `{A | A ∩ U ≠ ∅}`, where `U` is an open subset of the underlying space. Used for
defining the topologies on `Compacts` and `NonemptyCompacts`. -/
protected def vietoris : TopologicalSpace (Set α) :=
  .generateFrom <| powerset '' {U | IsOpen U} ∪ (fun V => {s | (s ∩ V).Nonempty}) '' {V | IsOpen V}

attribute [local instance] TopologicalSpace.vietoris

variable {α}

namespace vietoris

/-- When `Set` is equipped with the Vietoris topology, the powerset of an open set is open. -/
theorem _root_.IsOpen.powerset_vietoris {U : Set α} (h : IsOpen U) :
    IsOpen U.powerset :=
  isOpen_generateFrom_of_mem <| .inl ⟨U, h, rfl⟩

theorem isOpen_inter_nonempty_of_isOpen {U : Set α} (h : IsOpen U) :
    IsOpen {s | (s ∩ U).Nonempty} :=
  isOpen_generateFrom_of_mem <| .inr ⟨U, h, rfl⟩

/-- When `Set` is equipped with the Vietoris topology, the powerset of a closed set is closed. -/
theorem _root_.IsClosed.powerset_vietoris {F : Set α} (h : IsClosed F) :
    IsClosed F.powerset := by
  simp_rw [powerset, ← isOpen_compl_iff, compl_setOf, ← inter_compl_nonempty_iff]
  exact isOpen_inter_nonempty_of_isOpen h.isOpen_compl

theorem isClosed_inter_nonempty_of_isClosed {F : Set α} (h : IsClosed F) :
    IsClosed {s | (s ∩ F).Nonempty} := by
  simp_rw +singlePass [← compl_compl F, inter_compl_nonempty_iff, ← compl_setOf]
  exact h.isOpen_compl.powerset_vietoris.isClosed_compl

theorem isClopen_singleton_empty : IsClopen {(∅ : Set α)} := by
  rw [← powerset_empty]
  exact ⟨isClosed_empty.powerset_vietoris, isOpen_empty.powerset_vietoris⟩

private theorem isCompact_aux {K : Set α} (hK : IsCompact K)
    {s : Set (Set α)} (hsK : s ⊆ K.powerset) (hs : ∀ L ∈ s, IsCompact L) :
    IsCompact {t ⊆ K | ∀ L ∈ s, (t ∩ L).Nonempty} := by
  refine isCompact_generateFrom rfl fun S hS hKS => ?_
  let u := {U | IsOpen U ∧ {s | (s ∩ U).Nonempty} ∈ S}
  by_cases! hsu : ∃ L ∈ s, L ⊆ ⋃₀ u
  · obtain ⟨L, hL, hLu⟩ := hsu
    rw [sUnion_eq_biUnion] at hLu
    obtain ⟨T, hTS, hT, hLT⟩ := (hs L hL).elim_finite_subcover_image (fun _ h => h.1) hLu
    refine ⟨(fun U => {s | (s ∩ U).Nonempty}) '' T, by grind [image_subset_iff], hT.image _, ?_⟩
    simp_rw [sUnion_image, ← setOf_exists, ← nonempty_iUnion, ← inter_iUnion]
    grw [← hLT]
    grind
  · simp_rw [← diff_nonempty] at hsu
    replace hsu L (h : L ∈ s) : (K \ ⋃₀ u ∩ L).Nonempty := (hsu L h).mono <| by grind
    obtain ⟨_, hUS, hUu⟩ := mem_sUnion.mp <| hKS ⟨diff_subset, hsu⟩
    rcases hS hUS with ⟨U, hU, rfl⟩ | ⟨U, hU, rfl⟩
    · rw [mem_powerset_iff, diff_subset_comm, sUnion_eq_biUnion] at hUu
      obtain ⟨T, hTS, hT, hKT⟩ := (hK.diff hU).elim_finite_subcover_image (fun _ h => h.1) hUu
      refine ⟨insert U.powerset ((fun V => {s | (s ∩ V).Nonempty}) '' T),
        insert_subset hUS <| Set.image_subset_iff.mpr <| hTS.trans fun _ h => h.2,
        (hT.image _).insert _, ?_⟩
      rw [sUnion_insert, ← diff_subset_iff, sUnion_image]
      rintro t ⟨⟨htK, -⟩, htU⟩
      rw [mem_powerset_iff, not_subset] at htU
      obtain ⟨x, hxt, hxU⟩ := htU
      obtain ⟨V, hVT, hxV⟩ := mem_iUnion₂.mp <| hKT ⟨htK hxt, hxU⟩
      exact mem_biUnion hVT ⟨x, hxt, hxV⟩
    · obtain ⟨x, hxu, hxU⟩ := hUu
      cases hxu.2 <| mem_sUnion_of_mem hxU ⟨hU, hUS⟩

theorem _root_.IsCompact.powerset_vietoris {K : Set α} (hK : IsCompact K) :
    IsCompact K.powerset := by
  simpa using isCompact_aux hK (s := ∅)

instance [CompactSpace α] : CompactSpace (Set α) :=
  ⟨powerset_univ ▸ isCompact_univ.powerset_vietoris⟩

theorem specializes_of_subset_closure {s t : Set α} (hst : s ⊆ t) (hts : t ⊆ closure s) :
    s ⤳ t := by
  simp_rw [Specializes, nhds_generateFrom, le_iInf₂_iff]
  rintro _ ⟨hs, ⟨U, hU, rfl⟩ | ⟨U, hU, rfl⟩⟩
  · exact iInf₂_le U.powerset ⟨hst.trans hs, .inl <| mem_image_of_mem _ hU⟩
  · obtain ⟨x, hxt, hxU⟩ := hs
    obtain ⟨y, hyU, hys⟩ := mem_closure_iff.mp (hts hxt) U hU hxU
    exact iInf₂_le {t | (t ∩ U).Nonempty} ⟨⟨y, hys, hyU⟩, .inr <| mem_image_of_mem _ hU⟩

theorem specializes_closure {s : Set α} : s ⤳ closure s :=
  specializes_of_subset_closure subset_closure .rfl

end vietoris

namespace Compacts

/-- The Vietoris topology on the compact subsets of a topological space. -/
instance topology : TopologicalSpace (Compacts α) :=
  .induced (↑) (.vietoris α)

@[fun_prop]
theorem isEmbedding_coe : IsEmbedding ((↑) : Compacts α → Set α) where
  injective := SetLike.coe_injective
  eq_induced := rfl

@[fun_prop]
theorem continuous_coe : Continuous ((↑) : Compacts α → Set α) :=
  isEmbedding_coe.continuous

theorem isOpen_subsets_of_isOpen {U : Set α} (h : IsOpen U) :
    IsOpen {K : Compacts α | ↑K ⊆ U} :=
  continuous_coe.isOpen_preimage _ h.powerset_vietoris

theorem isOpen_inter_nonempty_of_isOpen {U : Set α} (h : IsOpen U) :
    IsOpen {K : Compacts α | (↑K ∩ U).Nonempty} :=
  continuous_coe.isOpen_preimage _ <| vietoris.isOpen_inter_nonempty_of_isOpen h

theorem isClosed_subsets_of_isClosed {F : Set α} (h : IsClosed F) :
    IsClosed {K : Compacts α | ↑K ⊆ F} := by
  simp_rw [← isOpen_compl_iff, Set.compl_setOf, ← Set.inter_compl_nonempty_iff]
  exact isOpen_inter_nonempty_of_isOpen h.isOpen_compl

theorem isClosed_inter_nonempty_of_isClosed {F : Set α} (h : IsClosed F) :
    IsClosed {K : Compacts α | (↑K ∩ F).Nonempty} := by
  simp_rw +singlePass [← compl_compl F, Set.inter_compl_nonempty_iff, ← Set.compl_setOf]
  exact (isOpen_subsets_of_isOpen h.isOpen_compl).isClosed_compl

theorem isClopen_singleton_bot : IsClopen {(⊥ : Compacts α)} := by
  convert vietoris.isClopen_singleton_empty.preimage continuous_coe
  rw [← coe_bot, ← image_singleton (f := SetLike.coe), SetLike.coe_injective.preimage_image]

theorem isCompact_subsets_of_isCompact {K : Set α} (hK : IsCompact K) :
    IsCompact {L : Compacts α | ↑L ⊆ K} := by
  rw [isEmbedding_coe.isCompact_iff]
  refine .of_subset_of_specializes hK.powerset_vietoris (by grind) (fun s hs => ?_)
  let L : Compacts α := ⟨K ∩ closure s, hK.inter_right isClosed_closure⟩
  exact ⟨L, mem_image_of_mem _ inter_subset_left,
    vietoris.specializes_of_subset_closure (subset_inter hs subset_closure) inter_subset_right⟩

instance [CompactSpace α] : CompactSpace (Compacts α) :=
  ⟨by simpa using isCompact_subsets_of_isCompact isCompact_univ⟩

theorem isCompact_biUnion_coe_of_isCompact {S : Set (Compacts α)} (hS : IsCompact S) :
    IsCompact (⋃ K ∈ S, (K : Set α)) := by
  rw [isCompact_iff_finite_subcover]
  intro ι U hU h
  rw [iUnion₂_subset_iff] at h
  obtain ⟨s, hs⟩ := hS.elim_finite_subcover
    (fun s : Finset ι => {K | (K : Set α) ⊆ ⋃ i ∈ s, U i})
    (fun s => isOpen_subsets_of_isOpen <| isOpen_biUnion fun _ _ => hU _)
    (fun K hK => mem_iUnion.mpr <| K.isCompact.elim_finite_subcover U hU <| h K hK)
  classical
  refine ⟨s.biUnion id, (biUnion_subset_biUnion_left hs).trans ?_⟩
  simp_rw [biUnion_iUnion, iUnion_subset_iff, Finset.set_biUnion_biUnion]
  exact fun t ht K hK => subset_iUnion₂_of_subset t ht hK

@[simp]
theorem compactSpace_iff : CompactSpace (Compacts α) ↔ CompactSpace α := by
  refine ⟨fun h => ⟨?_⟩, fun _ => inferInstance⟩
  convert isCompact_biUnion_coe_of_isCompact (α := α) isCompact_univ
  symm
  simp_rw [biUnion_univ, eq_univ_iff_forall, mem_iUnion]
  exact fun x => ⟨{x}, Set.mem_singleton x⟩

@[simp]
theorem noncompactSpace_iff : NoncompactSpace (Compacts α) ↔ NoncompactSpace α := by
  simp_rw [← not_compactSpace_iff, compactSpace_iff]

instance [NoncompactSpace α] : NoncompactSpace (Compacts α) :=
  noncompactSpace_iff.mpr ‹_›

end Compacts

namespace NonemptyCompacts

/-- The Vietoris topology on the nonempty compact subsets of a topological space. -/
instance topology : TopologicalSpace (NonemptyCompacts α) :=
  .induced (↑) (.vietoris α)

@[fun_prop]
theorem isEmbedding_coe : IsEmbedding ((↑) : NonemptyCompacts α → Set α) where
  injective := SetLike.coe_injective
  eq_induced := rfl

@[fun_prop]
theorem continuous_coe : Continuous ((↑) : NonemptyCompacts α → Set α) :=
  isEmbedding_coe.continuous

@[fun_prop]
theorem isEmbedding_toCompacts : IsEmbedding (toCompacts (α := α)) where
  injective := toCompacts_injective
  eq_induced := .symm <| induced_compose (f := toCompacts) (g := SetLike.coe)

@[fun_prop]
theorem continuous_toCompacts : Continuous (toCompacts (α := α)) :=
  isEmbedding_toCompacts.continuous

@[fun_prop]
theorem isClosedEmbedding_toCompacts : IsClosedEmbedding (toCompacts (α := α)) where
  __ := isEmbedding_toCompacts
  isClosed_range := by
    rw [range_toCompacts]
    exact Compacts.isClopen_singleton_bot.compl.isClosed

@[fun_prop]
theorem isOpenEmbedding_toCompacts : IsOpenEmbedding (toCompacts (α := α)) where
  __ := isEmbedding_toCompacts
  isOpen_range := by
    rw [range_toCompacts]
    exact Compacts.isClopen_singleton_bot.compl.isOpen

theorem isOpen_subsets_of_isOpen {U : Set α} (h : IsOpen U) :
    IsOpen {K : NonemptyCompacts α | ↑K ⊆ U} :=
  h.powerset_vietoris.preimage continuous_coe

theorem isOpen_inter_nonempty_of_isOpen {U : Set α} (h : IsOpen U) :
    IsOpen {K : NonemptyCompacts α | (↑K ∩ U).Nonempty} :=
  (vietoris.isOpen_inter_nonempty_of_isOpen h).preimage continuous_coe

theorem isClosed_subsets_of_isClosed {F : Set α} (h : IsClosed F) :
    IsClosed {K : NonemptyCompacts α | ↑K ⊆ F} :=
  h.powerset_vietoris.preimage continuous_coe

theorem isClosed_inter_nonempty_of_isClosed {F : Set α} (h : IsClosed F) :
    IsClosed {K : NonemptyCompacts α | (↑K ∩ F).Nonempty} :=
  (vietoris.isClosed_inter_nonempty_of_isClosed h).preimage continuous_coe

instance [CompactSpace α] : CompactSpace (NonemptyCompacts α) :=
  isClosedEmbedding_toCompacts.compactSpace

theorem isCompact_subsets_of_isCompact {K : Set α} (hK : IsCompact K) :
    IsCompact {L : NonemptyCompacts α | ↑L ⊆ K} :=
  isClosedEmbedding_toCompacts.isCompact_preimage (Compacts.isCompact_subsets_of_isCompact hK)

theorem isCompact_biUnion_coe_of_isCompact {S : Set (NonemptyCompacts α)} (hs : IsCompact S) :
    IsCompact (⋃ K ∈ S, (K : Set α)) := by
  convert Compacts.isCompact_biUnion_coe_of_isCompact (hs.image continuous_toCompacts)
  simp_rw [biUnion_image, coe_toCompacts]

@[simp]
theorem compactSpace_iff : CompactSpace (NonemptyCompacts α) ↔ CompactSpace α := by
  refine ⟨fun h => ⟨?_⟩, fun _ => inferInstance⟩
  convert isCompact_biUnion_coe_of_isCompact (α := α) isCompact_univ
  symm
  simp_rw [biUnion_univ, eq_univ_iff_forall, mem_iUnion]
  exact fun x => ⟨{x}, Set.mem_singleton x⟩

@[simp]
theorem noncompactSpace_iff : NoncompactSpace (NonemptyCompacts α) ↔ NoncompactSpace α := by
  simp_rw [← not_compactSpace_iff, compactSpace_iff]

instance [NoncompactSpace α] : NoncompactSpace (NonemptyCompacts α) :=
  noncompactSpace_iff.mpr ‹_›

end NonemptyCompacts

end TopologicalSpace
