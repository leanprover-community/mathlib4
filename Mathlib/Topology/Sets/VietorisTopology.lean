/-
Copyright (c) 2025 Attila Gáspár. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Attila Gáspár
-/
module

public import Mathlib.Topology.Order.Lattice
public import Mathlib.Topology.Sets.Compacts

/-!
# Vietoris topology

This file defines the Vietoris topology on the types of compact subsets and nonempty compact subsets
of a topological space. The Vietoris topology is generated by sets of the form
$\{K \mid K \subseteq U\}$ and $\{K \mid K \cap U \ne \emptyset\}$, where $U$ is an open subset of
the underlying space.

## Implementation notes

Rather than defining the topology directly on `TopologicalSpace.Compacts α`, we first define
`TopologicalSpace.vietoris α` on `Set α`, then we take the subspace topology on
`TopologicalSpace.Compacts α` and `TopologicalSpace.NonemptyCompacts α`. This approach will
let us reuse several results if a type of closed sets equipped with the Vietoris topology is
defined in the future.

Note that we do not equip `TopologicalSpace.Closeds α` with the Vietoris topology. When `α` is a
metric space, `TopologicalSpace.Closeds α` is equipped with the Hausdorff metric, which is generally
incompatible with the Vietoris topology.

## References

* [Ernest Michael, *Topologies on spaces of subsets*][michael1951]
-/

@[expose] public section

open Set Topology

variable {α β : Type*} [TopologicalSpace α] [TopologicalSpace β]

namespace TopologicalSpace

variable (α) in
/-- The Vietoris topology on the powerset of a topological space, generated by sets of the form
`{A | A ⊆ U}` and `{A | A ∩ U ≠ ∅}`, where `U` is an open subset of the underlying space. Used for
defining the topologies on `Compacts` and `NonemptyCompacts`. -/
protected def vietoris : TopologicalSpace (Set α) :=
  .generateFrom <| powerset '' {U | IsOpen U} ∪ (fun V => {s | (s ∩ V).Nonempty}) '' {V | IsOpen V}

attribute [local instance] TopologicalSpace.vietoris

namespace vietoris

/-- When `Set` is equipped with the Vietoris topology, the powerset of an open set is open. -/
theorem _root_.IsOpen.powerset_vietoris {U : Set α} (h : IsOpen U) :
    IsOpen U.powerset :=
  isOpen_generateFrom_of_mem <| .inl ⟨U, h, rfl⟩

theorem isOpen_inter_nonempty_of_isOpen {U : Set α} (h : IsOpen U) :
    IsOpen {s | (s ∩ U).Nonempty} :=
  isOpen_generateFrom_of_mem <| .inr ⟨U, h, rfl⟩

/-- When `Set` is equipped with the Vietoris topology, the powerset of a closed set is closed. -/
theorem _root_.IsClosed.powerset_vietoris {F : Set α} (h : IsClosed F) :
    IsClosed F.powerset := by
  simp_rw [powerset, ← isOpen_compl_iff, compl_setOf, ← inter_compl_nonempty_iff]
  exact isOpen_inter_nonempty_of_isOpen h.isOpen_compl

theorem isClosed_inter_nonempty_of_isClosed {F : Set α} (h : IsClosed F) :
    IsClosed {s | (s ∩ F).Nonempty} := by
  simp_rw +singlePass [← compl_compl F, inter_compl_nonempty_iff, ← compl_setOf]
  exact h.isOpen_compl.powerset_vietoris.isClosed_compl

theorem isClopen_singleton_empty : IsClopen {(∅ : Set α)} := by
  rw [← powerset_empty]
  exact ⟨isClosed_empty.powerset_vietoris, isOpen_empty.powerset_vietoris⟩

theorem continuous_iff {f : α → Set β} :
    Continuous f ↔ (∀ U, IsOpen U → IsOpen (f ⁻¹' U.powerset)) ∧
      (∀ F, IsClosed F → IsClosed (f ⁻¹' F.powerset)) := by
  refine ⟨fun hf =>
      ⟨fun U hU => hU.powerset_vietoris.preimage hf, fun F hF => hF.powerset_vietoris.preimage hf⟩,
    fun ⟨h₁, h₂⟩ => ?_⟩
  rw [continuous_generateFrom_iff]
  rintro _ (⟨U, hU, rfl⟩ | ⟨U, hU, rfl⟩)
  · exact h₁ U hU
  · simp_rw [preimage_setOf_eq, ← not_disjoint_iff_nonempty_inter, ← compl_setOf, isOpen_compl_iff,
      ← subset_compl_iff_disjoint_right]
    exact h₂ Uᶜ hU.isClosed_compl

@[fun_prop]
theorem isEmbedding_singleton : IsEmbedding ({·} : α → Set α) where
  injective := Set.singleton_injective
  eq_induced := by
    simp_rw [TopologicalSpace.vietoris, induced_generateFrom_eq, image_union, image_image,
      powerset, preimage_setOf_eq, singleton_subset_iff, singleton_inter_nonempty, union_self,
      setOf_mem_eq, image_id', generateFrom_setOf_isOpen]

@[fun_prop]
theorem continuous_singleton : Continuous ({·} : α → Set α) :=
  isEmbedding_singleton.continuous

/-- Auxiliary lemma showing that singleton sets form a closed set. It takes the required topological
properties as arguments, so that it applies to both the Vietoris topology and the Hausdorff
uniformity. -/
theorem _root_.isClosed_range_singleton_aux [T2Space α] {t : TopologicalSpace (Set α)}
    (h₁ : IsOpen {(∅ : Set α)}) (h₂ : ∀ {U : Set α}, IsOpen U → IsOpen {s | (s ∩ U).Nonempty}) :
    IsClosed (Set.range ({·} : α → Set α)) := by
  rw [← isOpen_compl_iff, isOpen_iff_mem_nhds]
  intro s hs
  rcases Set.eq_empty_or_nonempty s with rfl | h
  · rwa [(isOpen_singleton_iff_nhds_eq_pure _).mp h₁, Filter.mem_pure]
  rcases h.exists_eq_singleton_or_nontrivial with ⟨x, rfl⟩ | ⟨x, hx, y, hy, hxy⟩
  · cases hs <| Set.mem_range_self x
  obtain ⟨U, V, hU, hV, hxU, hyV, hUV⟩ := t2_separation hxy
  filter_upwards [(h₂ hU).inter (h₂ hV) |>.mem_nhds ⟨⟨x, hx, hxU⟩, ⟨y, hy, hyV⟩⟩]
  rintro _ ⟨hzU, hzV⟩ ⟨z, rfl⟩
  rw [Set.mem_setOf, Set.singleton_inter_nonempty] at hzU hzV
  exact hUV.notMem_of_mem_left hzU hzV

@[fun_prop]
theorem isClosedEmbedding_singleton [T2Space α] :
    Topology.IsClosedEmbedding ({·} : α → Set α) where
  __ := isEmbedding_singleton
  isClosed_range :=
    isClosed_range_singleton_aux isClopen_singleton_empty.isOpen isOpen_inter_nonempty_of_isOpen

@[fun_prop]
theorem continuous_union : Continuous (fun x : Set α × Set α => x.1 ∪ x.2) := by
  simp_rw [continuous_iff, powerset, preimage_setOf_eq, union_subset_iff, setOf_and]
  exact ⟨
    fun U hU => .inter
      (hU.powerset_vietoris.preimage continuous_fst)
      (hU.powerset_vietoris.preimage continuous_snd),
    fun F hF => .inter
      (hF.powerset_vietoris.preimage continuous_fst)
      (hF.powerset_vietoris.preimage continuous_snd)⟩

@[fun_prop]
theorem continuous_range_of_finite {ι : Type*} [Finite ι] :
    Continuous (range : (ι → α) → Set α) := by
  simp_rw [continuous_iff, powerset, preimage_setOf_eq, range_subset_iff, setOf_forall]
  exact ⟨
    fun U hU => isOpen_iInter_of_finite fun i => hU.preimage <| continuous_apply i,
    fun F hF => isClosed_iInter fun i => hF.preimage <| continuous_apply i⟩

private theorem isCompact_aux {K : Set α} (hK : IsCompact K)
    {s : Set (Set α)} (hsK : s ⊆ K.powerset) (hs : ∀ L ∈ s, IsCompact L) :
    IsCompact {t ⊆ K | ∀ L ∈ s, (t ∩ L).Nonempty} := by
  refine isCompact_generateFrom rfl fun S hS hKS => ?_
  let u := {U | IsOpen U ∧ {s | (s ∩ U).Nonempty} ∈ S}
  by_cases! hsu : ∃ L ∈ s, L ⊆ ⋃₀ u
  · obtain ⟨L, hL, hLu⟩ := hsu
    rw [sUnion_eq_biUnion] at hLu
    obtain ⟨T, hTS, hT, hLT⟩ := (hs L hL).elim_finite_subcover_image (fun _ h => h.1) hLu
    refine ⟨(fun U => {s | (s ∩ U).Nonempty}) '' T, by grind [image_subset_iff], hT.image _, ?_⟩
    simp_rw [sUnion_image, ← setOf_exists, ← nonempty_iUnion, ← inter_iUnion]
    grw [← hLT]
    grind
  · simp_rw [← diff_nonempty] at hsu
    replace hsu L (h : L ∈ s) : (K \ ⋃₀ u ∩ L).Nonempty := (hsu L h).mono <| by grind
    obtain ⟨_, hUS, hUu⟩ := mem_sUnion.mp <| hKS ⟨diff_subset, hsu⟩
    rcases hS hUS with ⟨U, hU, rfl⟩ | ⟨U, hU, rfl⟩
    · rw [mem_powerset_iff, diff_subset_comm, sUnion_eq_biUnion] at hUu
      obtain ⟨T, hTS, hT, hKT⟩ := (hK.diff hU).elim_finite_subcover_image (fun _ h => h.1) hUu
      refine ⟨insert U.powerset ((fun V => {s | (s ∩ V).Nonempty}) '' T),
        insert_subset hUS <| Set.image_subset_iff.mpr <| hTS.trans fun _ h => h.2,
        (hT.image _).insert _, ?_⟩
      rw [sUnion_insert, ← diff_subset_iff, sUnion_image]
      rintro t ⟨⟨htK, -⟩, htU⟩
      rw [mem_powerset_iff, not_subset] at htU
      obtain ⟨x, hxt, hxU⟩ := htU
      obtain ⟨V, hVT, hxV⟩ := mem_iUnion₂.mp <| hKT ⟨htK hxt, hxU⟩
      exact mem_biUnion hVT ⟨x, hxt, hxV⟩
    · obtain ⟨x, hxu, hxU⟩ := hUu
      cases hxu.2 <| mem_sUnion_of_mem hxU ⟨hU, hUS⟩

theorem _root_.IsCompact.powerset_vietoris {K : Set α} (hK : IsCompact K) :
    IsCompact K.powerset := by
  simpa using isCompact_aux hK (s := ∅)

instance [CompactSpace α] : CompactSpace (Set α) :=
  ⟨powerset_univ ▸ isCompact_univ.powerset_vietoris⟩

theorem specializes_of_subset_closure {s t : Set α} (hst : s ⊆ t) (hts : t ⊆ closure s) :
    s ⤳ t := by
  simp_rw [Specializes, nhds_generateFrom, le_iInf₂_iff]
  rintro _ ⟨hs, ⟨U, hU, rfl⟩ | ⟨U, hU, rfl⟩⟩
  · exact iInf₂_le U.powerset ⟨hst.trans hs, .inl <| mem_image_of_mem _ hU⟩
  · obtain ⟨x, hxt, hxU⟩ := hs
    obtain ⟨y, hyU, hys⟩ := mem_closure_iff.mp (hts hxt) U hU hxU
    exact iInf₂_le {t | (t ∩ U).Nonempty} ⟨⟨y, hys, hyU⟩, .inr <| mem_image_of_mem _ hU⟩

theorem specializes_closure {s : Set α} : s ⤳ closure s :=
  specializes_of_subset_closure subset_closure .rfl

end vietoris

namespace Compacts

/-- The Vietoris topology on the compact subsets of a topological space. -/
instance topology : TopologicalSpace (Compacts α) :=
  .induced (↑) (.vietoris α)

@[fun_prop]
theorem isEmbedding_coe : IsEmbedding ((↑) : Compacts α → Set α) where
  injective := SetLike.coe_injective
  eq_induced := rfl

@[fun_prop]
theorem continuous_coe : Continuous ((↑) : Compacts α → Set α) :=
  isEmbedding_coe.continuous

theorem isOpen_subsets_of_isOpen {U : Set α} (h : IsOpen U) :
    IsOpen {K : Compacts α | ↑K ⊆ U} :=
  continuous_coe.isOpen_preimage _ h.powerset_vietoris

theorem isOpen_inter_nonempty_of_isOpen {U : Set α} (h : IsOpen U) :
    IsOpen {K : Compacts α | (↑K ∩ U).Nonempty} :=
  continuous_coe.isOpen_preimage _ <| vietoris.isOpen_inter_nonempty_of_isOpen h

theorem isClosed_subsets_of_isClosed {F : Set α} (h : IsClosed F) :
    IsClosed {K : Compacts α | ↑K ⊆ F} := by
  simp_rw [← isOpen_compl_iff, Set.compl_setOf, ← Set.inter_compl_nonempty_iff]
  exact isOpen_inter_nonempty_of_isOpen h.isOpen_compl

theorem isClosed_inter_nonempty_of_isClosed {F : Set α} (h : IsClosed F) :
    IsClosed {K : Compacts α | (↑K ∩ F).Nonempty} := by
  simp_rw +singlePass [← compl_compl F, Set.inter_compl_nonempty_iff, ← Set.compl_setOf]
  exact (isOpen_subsets_of_isOpen h.isOpen_compl).isClosed_compl

theorem isClopen_singleton_bot : IsClopen {(⊥ : Compacts α)} := by
  convert vietoris.isClopen_singleton_empty.preimage continuous_coe
  rw [← coe_bot, ← image_singleton (f := SetLike.coe), SetLike.coe_injective.preimage_image]

@[fun_prop]
theorem isEmbedding_singleton : IsEmbedding ({·} : α → Compacts α) :=
  isEmbedding_coe.of_comp_iff.mp vietoris.isEmbedding_singleton

@[fun_prop]
theorem continuous_singleton : Continuous ({·} : α → Compacts α) :=
  isEmbedding_singleton.continuous

@[fun_prop]
theorem isClosedEmbedding_singleton [T2Space α] :
    Topology.IsClosedEmbedding ({·} : α → Compacts α) :=
  .of_comp isEmbedding_coe vietoris.isClosedEmbedding_singleton

instance : ContinuousSup (Compacts α) := by
  constructor
  simp_rw [isEmbedding_coe.continuous_iff, Function.comp_def, coe_sup]
  fun_prop

@[fun_prop]
theorem continuous_prod : Continuous fun p : Compacts α × Compacts β => p.1 ×ˢ p.2 := by
  rw [continuous_induced_rng, continuous_generateFrom_iff]
  rintro _ (⟨U, hU, rfl⟩ | ⟨U, hU, rfl⟩)
  · rw [isOpen_iff_forall_mem_open]
    intro ⟨K, L⟩ (hKL : (K : Set α) ×ˢ (L : Set β) ⊆ U)
    obtain ⟨V, W, hV, hW, hK, hL, hVW⟩ := generalized_tube_lemma K.isCompact L.isCompact hU hKL
    exact ⟨_, fun ⟨K', L'⟩ ⟨hK', hL'⟩ => (Set.prod_mono hK' hL').trans hVW,
      (isOpen_subsets_of_isOpen hV).prod (isOpen_subsets_of_isOpen hW), hK, hL⟩
  · rw [isOpen_iff_forall_mem_open]
    intro ⟨K, L⟩ ⟨⟨x, y⟩, ⟨(hx : x ∈ K), (hy : y ∈ L)⟩, hxy⟩
    obtain ⟨V, W, hV, hW, hxV, hyW, hVW⟩ := isOpen_prod_iff.mp hU x y hxy
    grw [preimage_setOf_eq, ← hVW]
    simp_rw [Function.comp_apply, coe_prod, prod_inter_prod, prod_nonempty_iff]
    exact ⟨_, .rfl,
      (isOpen_inter_nonempty_of_isOpen hV).prod (isOpen_inter_nonempty_of_isOpen hW),
      ⟨x, hx, hxV⟩, ⟨y, hy, hyW⟩⟩

theorem isCompact_subsets_of_isCompact {K : Set α} (hK : IsCompact K) :
    IsCompact {L : Compacts α | ↑L ⊆ K} := by
  rw [isEmbedding_coe.isCompact_iff]
  refine .of_subset_of_specializes hK.powerset_vietoris (by grind) (fun s hs => ?_)
  let L : Compacts α := ⟨K ∩ closure s, hK.inter_right isClosed_closure⟩
  exact ⟨L, mem_image_of_mem _ inter_subset_left,
    vietoris.specializes_of_subset_closure (subset_inter hs subset_closure) inter_subset_right⟩

instance [CompactSpace α] : CompactSpace (Compacts α) :=
  ⟨by simpa using isCompact_subsets_of_isCompact isCompact_univ⟩

theorem isCompact_biUnion_coe_of_isCompact {S : Set (Compacts α)} (hS : IsCompact S) :
    IsCompact (⋃ K ∈ S, (K : Set α)) := by
  rw [isCompact_iff_finite_subcover]
  intro ι U hU h
  rw [iUnion₂_subset_iff] at h
  obtain ⟨s, hs⟩ := hS.elim_finite_subcover
    (fun s : Finset ι => {K | (K : Set α) ⊆ ⋃ i ∈ s, U i})
    (fun s => isOpen_subsets_of_isOpen <| isOpen_biUnion fun _ _ => hU _)
    (fun K hK => mem_iUnion.mpr <| K.isCompact.elim_finite_subcover U hU <| h K hK)
  classical
  refine ⟨s.biUnion id, (biUnion_subset_biUnion_left hs).trans ?_⟩
  simp_rw [biUnion_iUnion, iUnion_subset_iff, Finset.set_biUnion_biUnion]
  exact fun t ht K hK => subset_iUnion₂_of_subset t ht hK

@[simp]
theorem compactSpace_iff : CompactSpace (Compacts α) ↔ CompactSpace α := by
  refine ⟨fun h => ⟨?_⟩, fun _ => inferInstance⟩
  convert isCompact_biUnion_coe_of_isCompact (α := α) isCompact_univ
  symm
  simp_rw [biUnion_univ, eq_univ_iff_forall, mem_iUnion]
  exact fun x => ⟨{x}, Set.mem_singleton x⟩

@[simp]
theorem noncompactSpace_iff : NoncompactSpace (Compacts α) ↔ NoncompactSpace α := by
  simp_rw [← not_compactSpace_iff, compactSpace_iff]

instance [NoncompactSpace α] : NoncompactSpace (Compacts α) :=
  noncompactSpace_iff.mpr ‹_›

end Compacts

namespace NonemptyCompacts

/-- The Vietoris topology on the nonempty compact subsets of a topological space. -/
instance topology : TopologicalSpace (NonemptyCompacts α) :=
  .induced (↑) (.vietoris α)

@[fun_prop]
theorem isEmbedding_coe : IsEmbedding ((↑) : NonemptyCompacts α → Set α) where
  injective := SetLike.coe_injective
  eq_induced := rfl

@[fun_prop]
theorem continuous_coe : Continuous ((↑) : NonemptyCompacts α → Set α) :=
  isEmbedding_coe.continuous

@[fun_prop]
theorem isEmbedding_toCompacts : IsEmbedding (toCompacts (α := α)) where
  injective := toCompacts_injective
  eq_induced := .symm <| induced_compose (f := toCompacts) (g := SetLike.coe)

@[fun_prop]
theorem continuous_toCompacts : Continuous (toCompacts (α := α)) :=
  isEmbedding_toCompacts.continuous

@[fun_prop]
theorem isClosedEmbedding_toCompacts : IsClosedEmbedding (toCompacts (α := α)) where
  __ := isEmbedding_toCompacts
  isClosed_range := by
    rw [range_toCompacts]
    exact Compacts.isClopen_singleton_bot.compl.isClosed

@[fun_prop]
theorem isOpenEmbedding_toCompacts : IsOpenEmbedding (toCompacts (α := α)) where
  __ := isEmbedding_toCompacts
  isOpen_range := by
    rw [range_toCompacts]
    exact Compacts.isClopen_singleton_bot.compl.isOpen

theorem isOpen_subsets_of_isOpen {U : Set α} (h : IsOpen U) :
    IsOpen {K : NonemptyCompacts α | ↑K ⊆ U} :=
  h.powerset_vietoris.preimage continuous_coe

theorem isOpen_inter_nonempty_of_isOpen {U : Set α} (h : IsOpen U) :
    IsOpen {K : NonemptyCompacts α | (↑K ∩ U).Nonempty} :=
  (vietoris.isOpen_inter_nonempty_of_isOpen h).preimage continuous_coe

theorem isClosed_subsets_of_isClosed {F : Set α} (h : IsClosed F) :
    IsClosed {K : NonemptyCompacts α | ↑K ⊆ F} :=
  h.powerset_vietoris.preimage continuous_coe

theorem isClosed_inter_nonempty_of_isClosed {F : Set α} (h : IsClosed F) :
    IsClosed {K : NonemptyCompacts α | (↑K ∩ F).Nonempty} :=
  (vietoris.isClosed_inter_nonempty_of_isClosed h).preimage continuous_coe

@[fun_prop]
theorem isEmbedding_singleton : IsEmbedding ({·} : α → NonemptyCompacts α) :=
  isEmbedding_coe.of_comp_iff.mp vietoris.isEmbedding_singleton

@[fun_prop]
theorem continuous_singleton : Continuous ({·} : α → NonemptyCompacts α) :=
  isEmbedding_singleton.continuous

@[fun_prop]
theorem isClosedEmbedding_singleton [T2Space α] :
    Topology.IsClosedEmbedding ({·} : α → NonemptyCompacts α) :=
  isClosedEmbedding_toCompacts.of_comp_iff.mp Compacts.isClosedEmbedding_singleton

instance : ContinuousSup (NonemptyCompacts α) := by
  constructor
  simp_rw [isEmbedding_toCompacts.continuous_iff, Function.comp_def, toCompacts_sup]
  fun_prop

@[fun_prop]
theorem continuous_prod :
    Continuous fun p : NonemptyCompacts α × NonemptyCompacts β => p.1 ×ˢ p.2 := by
  simp_rw [isEmbedding_toCompacts.continuous_iff, Function.comp_def, toCompacts_prod]
  fun_prop

instance [CompactSpace α] : CompactSpace (NonemptyCompacts α) :=
  isClosedEmbedding_toCompacts.compactSpace

theorem isCompact_subsets_of_isCompact {K : Set α} (hK : IsCompact K) :
    IsCompact {L : NonemptyCompacts α | ↑L ⊆ K} :=
  isClosedEmbedding_toCompacts.isCompact_preimage (Compacts.isCompact_subsets_of_isCompact hK)

theorem isCompact_biUnion_coe_of_isCompact {S : Set (NonemptyCompacts α)} (hs : IsCompact S) :
    IsCompact (⋃ K ∈ S, (K : Set α)) := by
  convert Compacts.isCompact_biUnion_coe_of_isCompact (hs.image continuous_toCompacts)
  simp_rw [biUnion_image, coe_toCompacts]

@[simp]
theorem compactSpace_iff : CompactSpace (NonemptyCompacts α) ↔ CompactSpace α := by
  refine ⟨fun h => ⟨?_⟩, fun _ => inferInstance⟩
  convert isCompact_biUnion_coe_of_isCompact (α := α) isCompact_univ
  symm
  simp_rw [biUnion_univ, eq_univ_iff_forall, mem_iUnion]
  exact fun x => ⟨{x}, Set.mem_singleton x⟩

@[simp]
theorem noncompactSpace_iff : NoncompactSpace (NonemptyCompacts α) ↔ NoncompactSpace α := by
  simp_rw [← not_compactSpace_iff, compactSpace_iff]

instance [NoncompactSpace α] : NoncompactSpace (NonemptyCompacts α) :=
  noncompactSpace_iff.mpr ‹_›

end NonemptyCompacts

end TopologicalSpace
