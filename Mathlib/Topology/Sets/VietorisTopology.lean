/-
Copyright (c) 2025 Attila Gáspár. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Attila Gáspár
-/
module

public import Mathlib.Topology.Sets.Compacts

/-!
# Vietoris topology

This file defines the Vietoris topology on the types of compact subsets and nonempty compact subsets
of a topological space. The Vietoris topology is generated by sets of the form
$\{K \mid K \subseteq U\}$ and $\{K \mid K \cap U \ne \emptyset\}$, where $U$ is an open subset of
the underlying space.

## Implementation notes

Rather than defining the topology directly on `TopologicalSpace.Compacts α`, we first define
`TopologicalSpace.vietoris α` on `Set α`, then we take the subspace topology on
`TopologicalSpace.Compacts α` and `TopologicalSpace.NonemptyCompacts α`. This approach will
let us reuse several results if a type of closed sets equipped with the Vietoris topology is
defined in the future.

Note that we do not equip `TopologicalSpace.Closeds α` with the Vietoris topology. When `α` is a
metric space, `TopologicalSpace.Closeds α` is equipped with the Hausdorff metric, which is generally
incompatible with the Vietoris topology.

## References

* [Ernest Michael, *Topologies on spaces of subsets*][michael1951]
-/

@[expose] public section

open Set Topology

variable (α : Type*) [TopologicalSpace α]

namespace TopologicalSpace

/-- The Vietoris topology on the powerset of a topological space, generated by sets of the form
`{A | A ⊆ U}` and `{A | A ∩ U ≠ ∅}`, where `U` is an open subset of the underlying space. Used for
defining the topologies on `Compacts` and `NonemptyCompacts`. -/
protected def vietoris : TopologicalSpace (Set α) :=
  .generateFrom <| powerset '' {U | IsOpen U} ∪ (fun V => {s | (s ∩ V).Nonempty}) '' {V | IsOpen V}

attribute [local instance] TopologicalSpace.vietoris

variable {α}

namespace vietoris

/-- When `Set` is equipped with the Vietoris topology, the powerset of an open set is open. -/
theorem _root_.IsOpen.powerset_vietoris {U : Set α} (h : IsOpen U) :
    IsOpen U.powerset :=
  isOpen_generateFrom_of_mem <| .inl ⟨U, h, rfl⟩

theorem isOpen_inter_nonempty_of_isOpen {U : Set α} (h : IsOpen U) :
    IsOpen {s | (s ∩ U).Nonempty} :=
  isOpen_generateFrom_of_mem <| .inr ⟨U, h, rfl⟩

/-- When `Set` is equipped with the Vietoris topology, the powerset of a closed set is closed. -/
theorem _root_.IsClosed.powerset_vietoris {F : Set α} (h : IsClosed F) :
    IsClosed F.powerset := by
  simp_rw [powerset, ← isOpen_compl_iff, compl_setOf, ← inter_compl_nonempty_iff]
  exact isOpen_inter_nonempty_of_isOpen h.isOpen_compl

theorem isClosed_inter_nonempty_of_isClosed {F : Set α} (h : IsClosed F) :
    IsClosed {s | (s ∩ F).Nonempty} := by
  simp_rw +singlePass [← compl_compl F, inter_compl_nonempty_iff, ← compl_setOf]
  exact h.isOpen_compl.powerset_vietoris.isClosed_compl

theorem isClopen_singleton_empty : IsClopen {(∅ : Set α)} := by
  rw [← powerset_empty]
  exact ⟨isClosed_empty.powerset_vietoris, isOpen_empty.powerset_vietoris⟩

/-- The Vietoris topology has a basis consisting of sets of the form
`{s | s ⊆ U₁ ∪ … ∪ Uₙ, s ∩ U₁ ≠ ∅, …, s ∩ Uₙ ≠ ∅}`, where `U₁, …, Uₙ` are open sets. -/
theorem isTopologicalBasis :
    IsTopologicalBasis <|
      (fun u => {s ⊆ ⋃₀ u | ∀ U ∈ u, (s ∩ U).Nonempty}) ''
      {u : Set (Set α) | u.Finite ∧ (∀ U ∈ u, IsOpen U)} := by
  refine isTopologicalBasis_of_subbasis rfl |>.isTopologicalBasis_of_exists_subset ?_ ?_ <;>
    rw [forall_mem_image]
  · intro u ⟨hu₁, hu₂⟩
    simp_rw [setOf_and, setOf_forall]
    exact (isOpen_sUnion hu₂).powerset_vietoris.inter <|
      hu₁.isOpen_biInter fun U hU => isOpen_inter_nonempty_of_isOpen (hu₂ U hU)
  · intro t ⟨ht₁, ht₂⟩ s hs
    rw [exists_mem_image]
    rcases eq_empty_or_nonempty s with rfl | _
    · exists ∅; simpa
    obtain ⟨u, v, hu, hv, rfl⟩ : ∃ u v, u ⊆ powerset '' {U | IsOpen U} ∧
        v ⊆ (fun V => {s | (s ∩ V).Nonempty}) '' {U | IsOpen U} ∧ u ∪ v = t := by
      rw [← inter_eq_left, inter_union_distrib_left] at ht₂
      exact ⟨_, _, inter_subset_right, inter_subset_right, ht₂⟩
    rw [finite_union] at ht₁
    obtain ⟨u, hu₁, hu₂, rfl⟩ := exists_subset_image_finite_and.mp ⟨u, hu, ht₁.1, rfl⟩
    obtain ⟨v, hv₁, hv₂, rfl⟩ := exists_subset_image_finite_and.mp ⟨v, hv, ht₁.2, rfl⟩
    let U := ⋂₀ u
    have hU : IsOpen U := hu₂.isOpen_sInter hu₁
    simp_rw [sInter_union, show ⋂₀ (powerset '' u) = U.powerset by ext; simp [U], sInter_image]
      at hs ⊢
    rw [mem_inter_iff, mem_powerset_iff, mem_iInter₂] at hs
    exists insert U ((U ∩ ·) '' v)
    simp_rw [show ⋃₀ (insert U ((U ∩ ·) '' v)) = U by simp, mem_setOf, finite_insert,
      forall_mem_insert, forall_mem_image, ← inter_assoc, inter_eq_left.mpr hs.1]
    refine ⟨⟨hv₂.image _, hU, fun V hV => hU.inter (hv₁ hV)⟩, by grind,
      fun t ⟨htU, _, ht⟩ => ⟨htU, mem_iInter₂_of_mem ?_⟩⟩
    simpa only [inter_eq_left.mpr htU] using ht

/-- Given a basis `B` on the underlying topological space, the Vietoris topology has a basis
consisting of sets of the form `{s | s ⊆ V, s ∩ U₁ ≠ ∅, …, s ∩ Uₙ ≠ ∅}`, where `U₁, …, Uₙ ∈ B` are
subsets of some open set `V`. -/
theorem _root_.TopologicalSpace.IsTopologicalBasis.vietoris
    {B : Set (Set α)} (hB : IsTopologicalBasis B) :
    IsTopologicalBasis <|
      (fun p => {s ⊆ p.1 | ∀ U ∈ p.2, (s ∩ U).Nonempty}) ''
      {p : Set α × Set (Set α) | IsOpen p.1 ∧ p.2.Finite ∧ p.2 ⊆ B ∧ (∀ U ∈ p.2, U ⊆ p.1)} := by
  refine isTopologicalBasis.isTopologicalBasis_of_exists_subset ?_ ?_ <;>
    rw [forall_mem_image]
  · intro ⟨V, u⟩ ⟨hV, hu, huB, _⟩
    simp_rw [setOf_and, setOf_forall]
    exact hV.powerset_vietoris.inter <|
      hu.isOpen_biInter fun V hV => isOpen_inter_nonempty_of_isOpen <| hB.isOpen <| huB hV
  · intro u ⟨hu₁, hu₂⟩ s ⟨hs₁, hs₂⟩
    choose! f hfB hfU hfs using show ∀ U ∈ u, ∃ W ∈ B, W ⊆ U ∧ (s ∩ W).Nonempty by
      intro U hU
      obtain ⟨x, hxs, hxU⟩ := hs₂ U hU
      obtain ⟨W, hWB, hxW, hW⟩ := hB.exists_subset_of_mem_open hxU <| hu₂ U hU
      exact ⟨W, hWB, hW, x, hxs, hxW⟩
    rw [exists_mem_image]
    refine ⟨⟨⋃₀ u, f '' u⟩, ⟨isOpen_sUnion hu₂, hu₁.image _, by grind⟩, by grind,
      fun t ⟨ht₁, ht₂⟩ => ⟨ht₁, fun U hU => ?_⟩⟩
    rw [forall_mem_image] at ht₂
    grw [← hfU U hU]
    exact ht₂ hU

private theorem isCompact_aux {K : Set α} (hK : IsCompact K)
    {s : Set (Set α)} (hsK : s ⊆ K.powerset) (hs : ∀ L ∈ s, IsCompact L) :
    IsCompact {t ⊆ K | ∀ L ∈ s, (t ∩ L).Nonempty} := by
  refine isCompact_generateFrom rfl fun S hS hKS => ?_
  let u := {U | IsOpen U ∧ {s | (s ∩ U).Nonempty} ∈ S}
  by_cases! hsu : ∃ L ∈ s, L ⊆ ⋃₀ u
  · obtain ⟨L, hL, hLu⟩ := hsu
    rw [sUnion_eq_biUnion] at hLu
    obtain ⟨T, hTS, hT, hLT⟩ := (hs L hL).elim_finite_subcover_image (fun _ h => h.1) hLu
    refine ⟨(fun U => {s | (s ∩ U).Nonempty}) '' T, by grind [image_subset_iff], hT.image _, ?_⟩
    simp_rw [sUnion_image, ← setOf_exists, ← nonempty_iUnion, ← inter_iUnion]
    grw [← hLT]
    grind
  · simp_rw [← diff_nonempty] at hsu
    replace hsu L (h : L ∈ s) : (K \ ⋃₀ u ∩ L).Nonempty := (hsu L h).mono <| by grind
    obtain ⟨_, hUS, hUu⟩ := mem_sUnion.mp <| hKS ⟨diff_subset, hsu⟩
    rcases hS hUS with ⟨U, hU, rfl⟩ | ⟨U, hU, rfl⟩
    · rw [mem_powerset_iff, diff_subset_comm, sUnion_eq_biUnion] at hUu
      obtain ⟨T, hTS, hT, hKT⟩ := (hK.diff hU).elim_finite_subcover_image (fun _ h => h.1) hUu
      refine ⟨insert U.powerset ((fun V => {s | (s ∩ V).Nonempty}) '' T),
        insert_subset hUS <| Set.image_subset_iff.mpr <| hTS.trans fun _ h => h.2,
        (hT.image _).insert _, ?_⟩
      rw [sUnion_insert, ← diff_subset_iff, sUnion_image]
      rintro t ⟨⟨htK, -⟩, htU⟩
      rw [mem_powerset_iff, not_subset] at htU
      obtain ⟨x, hxt, hxU⟩ := htU
      obtain ⟨V, hVT, hxV⟩ := mem_iUnion₂.mp <| hKT ⟨htK hxt, hxU⟩
      exact mem_biUnion hVT ⟨x, hxt, hxV⟩
    · obtain ⟨x, hxu, hxU⟩ := hUu
      cases hxu.2 <| mem_sUnion_of_mem hxU ⟨hU, hUS⟩

theorem _root_.IsCompact.powerset_vietoris {K : Set α} (hK : IsCompact K) :
    IsCompact K.powerset := by
  simpa using isCompact_aux hK (s := ∅)

instance [CompactSpace α] : CompactSpace (Set α) :=
  ⟨powerset_univ ▸ isCompact_univ.powerset_vietoris⟩

theorem specializes_of_subset_closure {s t : Set α} (hst : s ⊆ t) (hts : t ⊆ closure s) :
    s ⤳ t := by
  simp_rw [Specializes, nhds_generateFrom, le_iInf₂_iff]
  rintro _ ⟨hs, ⟨U, hU, rfl⟩ | ⟨U, hU, rfl⟩⟩
  · exact iInf₂_le U.powerset ⟨hst.trans hs, .inl <| mem_image_of_mem _ hU⟩
  · obtain ⟨x, hxt, hxU⟩ := hs
    obtain ⟨y, hyU, hys⟩ := mem_closure_iff.mp (hts hxt) U hU hxU
    exact iInf₂_le {t | (t ∩ U).Nonempty} ⟨⟨y, hys, hyU⟩, .inr <| mem_image_of_mem _ hU⟩

theorem specializes_closure {s : Set α} : s ⤳ closure s :=
  specializes_of_subset_closure subset_closure .rfl

end vietoris

namespace Compacts

/-- The Vietoris topology on the compact subsets of a topological space. -/
instance topology : TopologicalSpace (Compacts α) :=
  .induced (↑) (.vietoris α)

@[fun_prop]
theorem isEmbedding_coe : IsEmbedding ((↑) : Compacts α → Set α) where
  injective := SetLike.coe_injective
  eq_induced := rfl

@[fun_prop]
theorem continuous_coe : Continuous ((↑) : Compacts α → Set α) :=
  isEmbedding_coe.continuous

theorem isOpen_subsets_of_isOpen {U : Set α} (h : IsOpen U) :
    IsOpen {K : Compacts α | ↑K ⊆ U} :=
  continuous_coe.isOpen_preimage _ h.powerset_vietoris

theorem isOpen_inter_nonempty_of_isOpen {U : Set α} (h : IsOpen U) :
    IsOpen {K : Compacts α | (↑K ∩ U).Nonempty} :=
  continuous_coe.isOpen_preimage _ <| vietoris.isOpen_inter_nonempty_of_isOpen h

theorem isClosed_subsets_of_isClosed {F : Set α} (h : IsClosed F) :
    IsClosed {K : Compacts α | ↑K ⊆ F} := by
  simp_rw [← isOpen_compl_iff, Set.compl_setOf, ← Set.inter_compl_nonempty_iff]
  exact isOpen_inter_nonempty_of_isOpen h.isOpen_compl

theorem isClosed_inter_nonempty_of_isClosed {F : Set α} (h : IsClosed F) :
    IsClosed {K : Compacts α | (↑K ∩ F).Nonempty} := by
  simp_rw +singlePass [← compl_compl F, Set.inter_compl_nonempty_iff, ← Set.compl_setOf]
  exact (isOpen_subsets_of_isOpen h.isOpen_compl).isClosed_compl

theorem isClopen_singleton_bot : IsClopen {(⊥ : Compacts α)} := by
  convert vietoris.isClopen_singleton_empty.preimage continuous_coe
  rw [← coe_bot, ← image_singleton (f := SetLike.coe), SetLike.coe_injective.preimage_image]

/-- Given a basis `B` on a topological space `α`, the topology of `Compacts α` has a basis
consisting of sets of the form `{K | K ⊆ U₁ ∪ … ∪ Uₙ, K ∩ U₁ ≠ ∅, …, K ∩ Uₙ ≠ ∅}`, where
`U₁, …, Uₙ ∈ B`. -/
theorem _root_.TopologicalSpace.IsTopologicalBasis.compacts
    {B : Set (Set α)} (hB : IsTopologicalBasis B) :
    IsTopologicalBasis <|
      (fun u => {K : Compacts α | ↑K ⊆ ⋃₀ u ∧ ∀ U ∈ u, (↑K ∩ U).Nonempty}) ''
      {u | u.Finite ∧ u ⊆ B} := by
  refine hB.vietoris.isInducing isEmbedding_coe.isInducing
    |>.isTopologicalBasis_of_exists_subset ?_ ?_ <;> simp_rw [forall_mem_image]
  · intro u ⟨hu, huB⟩
    simp_rw [setOf_and, setOf_forall]
    exact .inter
      (isOpen_subsets_of_isOpen <| isOpen_sUnion fun U hU => hB.isOpen <| huB hU)
      (hu.isOpen_biInter fun U hU => isOpen_inter_nonempty_of_isOpen <| hB.isOpen <| huB hU)
  · intro ⟨V, u⟩ ⟨hV, hu, huB, huV⟩ K ⟨hKV, hKu⟩
    dsimp only at *
    obtain ⟨w, hwB, hwV⟩ := hB.open_eq_sUnion hV
    rw [hwV] at hKV
    replace hwV := hwV.symm.subset
    wlog hwK : ∀ W ∈ w, ((K : Set α) ∩ W).Nonempty generalizing w
    · refine this {W ∈ w | (↑K ∩ W).Nonempty} (fun x hx => ?_) (by grind) (by grind) (by grind)
      obtain ⟨W, hWw, hxW⟩ := mem_sUnion.mp (hKV hx)
      exact mem_sUnion_of_mem hxW ⟨hWw, x, hx, hxW⟩
    wlog hw : w.Finite generalizing w
    · rw [sUnion_eq_biUnion] at hKV
      obtain ⟨w', _⟩ := K.isCompact.elim_finite_subcover_image (fun W hW => hB.isOpen (hwB hW)) hKV
      apply this w' <;> grind [sUnion_eq_biUnion]
    wlog huw : u ⊆ w generalizing w
    · apply this (u ∪ w) <;> grind [sUnion_union, Finite.union]
    rw [exists_mem_image]
    exists w
    grind

/-- The topology of `Compacts α` has a basis consisting of sets of the form
`{K | K ⊆ U₁ ∪ … ∪ Uₙ, K ∩ U₁ ≠ ∅, …, K ∩ Uₙ ≠ ∅}`, where `U₁, …, Uₙ` are open sets.

See also `TopologicalSpace.IsTopologicalBasis.compacts` for a variant where the sets `Uᵢ`
are chosen from some basis. -/
theorem isTopologicalBasis :
    IsTopologicalBasis <|
      (fun u => {K : Compacts α | ↑K ⊆ ⋃₀ u ∧ ∀ U ∈ u, (↑K ∩ U).Nonempty}) ''
      {u : Set (Set α) | u.Finite ∧ ∀ U ∈ u, IsOpen U} :=
  isTopologicalBasis_opens.compacts

theorem isCompact_subsets_of_isCompact {K : Set α} (hK : IsCompact K) :
    IsCompact {L : Compacts α | ↑L ⊆ K} := by
  rw [isEmbedding_coe.isCompact_iff]
  refine .of_subset_of_specializes hK.powerset_vietoris (by grind) (fun s hs => ?_)
  let L : Compacts α := ⟨K ∩ closure s, hK.inter_right isClosed_closure⟩
  exact ⟨L, mem_image_of_mem _ inter_subset_left,
    vietoris.specializes_of_subset_closure (subset_inter hs subset_closure) inter_subset_right⟩

instance [CompactSpace α] : CompactSpace (Compacts α) :=
  ⟨by simpa using isCompact_subsets_of_isCompact isCompact_univ⟩

theorem isCompact_biUnion_coe_of_isCompact {S : Set (Compacts α)} (hS : IsCompact S) :
    IsCompact (⋃ K ∈ S, (K : Set α)) := by
  rw [isCompact_iff_finite_subcover]
  intro ι U hU h
  rw [iUnion₂_subset_iff] at h
  obtain ⟨s, hs⟩ := hS.elim_finite_subcover
    (fun s : Finset ι => {K | (K : Set α) ⊆ ⋃ i ∈ s, U i})
    (fun s => isOpen_subsets_of_isOpen <| isOpen_biUnion fun _ _ => hU _)
    (fun K hK => mem_iUnion.mpr <| K.isCompact.elim_finite_subcover U hU <| h K hK)
  classical
  refine ⟨s.biUnion id, (biUnion_subset_biUnion_left hs).trans ?_⟩
  simp_rw [biUnion_iUnion, iUnion_subset_iff, Finset.set_biUnion_biUnion]
  exact fun t ht K hK => subset_iUnion₂_of_subset t ht hK

@[simp]
theorem compactSpace_iff : CompactSpace (Compacts α) ↔ CompactSpace α := by
  refine ⟨fun h => ⟨?_⟩, fun _ => inferInstance⟩
  convert isCompact_biUnion_coe_of_isCompact (α := α) isCompact_univ
  symm
  simp_rw [biUnion_univ, eq_univ_iff_forall, mem_iUnion]
  exact fun x => ⟨{x}, Set.mem_singleton x⟩

@[simp]
theorem noncompactSpace_iff : NoncompactSpace (Compacts α) ↔ NoncompactSpace α := by
  simp_rw [← not_compactSpace_iff, compactSpace_iff]

instance [NoncompactSpace α] : NoncompactSpace (Compacts α) :=
  noncompactSpace_iff.mpr ‹_›

end Compacts

namespace NonemptyCompacts

/-- The Vietoris topology on the nonempty compact subsets of a topological space. -/
instance topology : TopologicalSpace (NonemptyCompacts α) :=
  .induced (↑) (.vietoris α)

@[fun_prop]
theorem isEmbedding_coe : IsEmbedding ((↑) : NonemptyCompacts α → Set α) where
  injective := SetLike.coe_injective
  eq_induced := rfl

@[fun_prop]
theorem continuous_coe : Continuous ((↑) : NonemptyCompacts α → Set α) :=
  isEmbedding_coe.continuous

@[fun_prop]
theorem isEmbedding_toCompacts : IsEmbedding (toCompacts (α := α)) where
  injective := toCompacts_injective
  eq_induced := .symm <| induced_compose (f := toCompacts) (g := SetLike.coe)

@[fun_prop]
theorem continuous_toCompacts : Continuous (toCompacts (α := α)) :=
  isEmbedding_toCompacts.continuous

@[fun_prop]
theorem isClosedEmbedding_toCompacts : IsClosedEmbedding (toCompacts (α := α)) where
  __ := isEmbedding_toCompacts
  isClosed_range := by
    rw [range_toCompacts]
    exact Compacts.isClopen_singleton_bot.compl.isClosed

@[fun_prop]
theorem isOpenEmbedding_toCompacts : IsOpenEmbedding (toCompacts (α := α)) where
  __ := isEmbedding_toCompacts
  isOpen_range := by
    rw [range_toCompacts]
    exact Compacts.isClopen_singleton_bot.compl.isOpen

theorem isOpen_subsets_of_isOpen {U : Set α} (h : IsOpen U) :
    IsOpen {K : NonemptyCompacts α | ↑K ⊆ U} :=
  h.powerset_vietoris.preimage continuous_coe

theorem isOpen_inter_nonempty_of_isOpen {U : Set α} (h : IsOpen U) :
    IsOpen {K : NonemptyCompacts α | (↑K ∩ U).Nonempty} :=
  (vietoris.isOpen_inter_nonempty_of_isOpen h).preimage continuous_coe

theorem isClosed_subsets_of_isClosed {F : Set α} (h : IsClosed F) :
    IsClosed {K : NonemptyCompacts α | ↑K ⊆ F} :=
  h.powerset_vietoris.preimage continuous_coe

theorem isClosed_inter_nonempty_of_isClosed {F : Set α} (h : IsClosed F) :
    IsClosed {K : NonemptyCompacts α | (↑K ∩ F).Nonempty} :=
  (vietoris.isClosed_inter_nonempty_of_isClosed h).preimage continuous_coe

/-- Given a basis `B` on a topological space `α`, the topology of `NonemptyCompacts α` has a basis
consisting of sets of the form `{K | K ⊆ U₁ ∪ … ∪ Uₙ, K ∩ U₁ ≠ ∅, …, K ∩ Uₙ ≠ ∅}`, where
`U₁, …, Uₙ ∈ B` and `n > 0`. -/
theorem _root_.TopologicalSpace.IsTopologicalBasis.nonemptyCompacts
    {B : Set (Set α)} (hB : IsTopologicalBasis B) :
    IsTopologicalBasis <|
      (fun u => {K : NonemptyCompacts α | ↑K ⊆ ⋃₀ u ∧ ∀ U ∈ u, (↑K ∩ U).Nonempty}) ''
      {u | u.Finite ∧ u.Nonempty ∧ u ⊆ B} := by
  refine hB.compacts.isInducing isEmbedding_toCompacts.isInducing
    |>.isTopologicalBasis_of_exists_subset ?_ ?_ <;> simp_rw [forall_mem_image]
  · rintro u ⟨hu, -, huB⟩
    simp_rw [setOf_and, setOf_forall]
    exact .inter
      (isOpen_subsets_of_isOpen <| isOpen_sUnion fun U hU => hB.isOpen <| huB hU)
      (hu.isOpen_biInter fun U hU => isOpen_inter_nonempty_of_isOpen <| hB.isOpen <| huB hU)
  · intro u ⟨hu, huB⟩ K ⟨hK₁, hK₂⟩
    rcases eq_empty_or_nonempty u with rfl | hu'
    · absurd K.nonempty.mono hK₁; simp
    rw [exists_mem_image]
    exists u

/-- The topology of `NonemptyCompacts α` has a basis consisting of sets of the form
`{s | s ⊆ U₁ ∪ … ∪ Uₙ, s ∩ U₁ ≠ ∅, …, s ∩ Uₙ ≠ ∅}`, where `U₁, …, Uₙ` are open sets and `n > 0`.

See also `TopologicalSpace.IsTopologicalBasis.nonemptyCompacts` for a variant where the sets `Uᵢ`
are chosen from some basis. -/
theorem isTopologicalBasis :
    IsTopologicalBasis <|
      (fun u => {K : NonemptyCompacts α | ↑K ⊆ ⋃₀ u ∧ ∀ U ∈ u, (↑K ∩ U).Nonempty}) ''
      {u : Set (Set α) | u.Finite ∧ u.Nonempty ∧ ∀ U ∈ u, IsOpen U} :=
  isTopologicalBasis_opens.nonemptyCompacts

instance [CompactSpace α] : CompactSpace (NonemptyCompacts α) :=
  isClosedEmbedding_toCompacts.compactSpace

theorem isCompact_subsets_of_isCompact {K : Set α} (hK : IsCompact K) :
    IsCompact {L : NonemptyCompacts α | ↑L ⊆ K} :=
  isClosedEmbedding_toCompacts.isCompact_preimage (Compacts.isCompact_subsets_of_isCompact hK)

theorem isCompact_biUnion_coe_of_isCompact {S : Set (NonemptyCompacts α)} (hs : IsCompact S) :
    IsCompact (⋃ K ∈ S, (K : Set α)) := by
  convert Compacts.isCompact_biUnion_coe_of_isCompact (hs.image continuous_toCompacts)
  simp_rw [biUnion_image, coe_toCompacts]

@[simp]
theorem compactSpace_iff : CompactSpace (NonemptyCompacts α) ↔ CompactSpace α := by
  refine ⟨fun h => ⟨?_⟩, fun _ => inferInstance⟩
  convert isCompact_biUnion_coe_of_isCompact (α := α) isCompact_univ
  symm
  simp_rw [biUnion_univ, eq_univ_iff_forall, mem_iUnion]
  exact fun x => ⟨{x}, Set.mem_singleton x⟩

@[simp]
theorem noncompactSpace_iff : NoncompactSpace (NonemptyCompacts α) ↔ NoncompactSpace α := by
  simp_rw [← not_compactSpace_iff, compactSpace_iff]

instance [NoncompactSpace α] : NoncompactSpace (NonemptyCompacts α) :=
  noncompactSpace_iff.mpr ‹_›

end NonemptyCompacts

end TopologicalSpace
