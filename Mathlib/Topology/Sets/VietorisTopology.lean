/-
Copyright (c) 2025 Attila Gáspár. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Attila Gáspár
-/
module

public import Mathlib.Topology.Order.Lattice
public import Mathlib.Topology.Sets.Compacts

/-!
# Vietoris topology

This file defines the Vietoris topology on the types of compact subsets and nonempty compact subsets
of a topological space. The Vietoris topology is generated by sets of the form
$\{K \mid K \subseteq U\}$ and $\{K \mid K \cap U \ne \emptyset\}$, where $U$ is an open subset of
the underlying space.

## Implementation notes

Rather than defining the topology directly on `TopologicalSpace.Compacts α`, we first define
`TopologicalSpace.vietoris α` on `Set α`, then we take the subspace topology on
`TopologicalSpace.Compacts α` and `TopologicalSpace.NonemptyCompacts α`. This approach will
let us reuse several results if a type of closed sets equipped with the Vietoris topology is
defined in the future.

Note that we do not equip `TopologicalSpace.Closeds α` with the Vietoris topology. When `α` is a
metric space, `TopologicalSpace.Closeds α` is equipped with the Hausdorff metric, which is generally
incompatible with the Vietoris topology.

## References

* [Ernest Michael, *Topologies on spaces of subsets*][michael1951]
-/

@[expose] public section

open Set Topology

variable {α β : Type*} [TopologicalSpace α] [TopologicalSpace β]

namespace TopologicalSpace

variable (α) in
/-- The Vietoris topology on the powerset of a topological space, generated by sets of the form
`{A | A ⊆ U}` and `{A | A ∩ U ≠ ∅}`, where `U` is an open subset of the underlying space. Used for
defining the topologies on `Compacts` and `NonemptyCompacts`. -/
protected def vietoris : TopologicalSpace (Set α) :=
  .generateFrom <| powerset '' {U | IsOpen U} ∪ (fun V => {s | (s ∩ V).Nonempty}) '' {V | IsOpen V}

attribute [local instance] TopologicalSpace.vietoris

namespace vietoris

/-- When `Set` is equipped with the Vietoris topology, the powerset of an open set is open. -/
theorem _root_.IsOpen.powerset_vietoris {U : Set α} (h : IsOpen U) :
    IsOpen U.powerset :=
  isOpen_generateFrom_of_mem <| .inl ⟨U, h, rfl⟩

theorem isOpen_inter_nonempty_of_isOpen {U : Set α} (h : IsOpen U) :
    IsOpen {s | (s ∩ U).Nonempty} :=
  isOpen_generateFrom_of_mem <| .inr ⟨U, h, rfl⟩

/-- When `Set` is equipped with the Vietoris topology, the powerset of a closed set is closed. -/
theorem _root_.IsClosed.powerset_vietoris {F : Set α} (h : IsClosed F) :
    IsClosed F.powerset := by
  simp_rw [powerset, ← isOpen_compl_iff, compl_setOf, ← inter_compl_nonempty_iff]
  exact isOpen_inter_nonempty_of_isOpen h.isOpen_compl

theorem isClosed_inter_nonempty_of_isClosed {F : Set α} (h : IsClosed F) :
    IsClosed {s | (s ∩ F).Nonempty} := by
  simp_rw +singlePass [← compl_compl F, inter_compl_nonempty_iff, ← compl_setOf]
  exact h.isOpen_compl.powerset_vietoris.isClosed_compl

theorem isClopen_singleton_empty : IsClopen {(∅ : Set α)} := by
  rw [← powerset_empty]
  exact ⟨isClosed_empty.powerset_vietoris, isOpen_empty.powerset_vietoris⟩

/-- The Vietoris topology has a basis consisting of sets of the form
`{s | s ⊆ U₁ ∪ … ∪ Uₙ, s ∩ U₁ ≠ ∅, …, s ∩ Uₙ ≠ ∅}`, where `U₁, …, Uₙ` are open sets. -/
theorem isTopologicalBasis :
    IsTopologicalBasis <|
      (fun u => {s ⊆ ⋃₀ u | ∀ U ∈ u, (s ∩ U).Nonempty}) ''
      {u : Set (Set α) | u.Finite ∧ (∀ U ∈ u, IsOpen U)} := by
  refine isTopologicalBasis_of_subbasis rfl |>.isTopologicalBasis_of_exists_subset ?_ ?_ <;>
    rw [forall_mem_image]
  · intro u ⟨hu₁, hu₂⟩
    simp_rw [setOf_and, setOf_forall]
    exact (isOpen_sUnion hu₂).powerset_vietoris.inter <|
      hu₁.isOpen_biInter fun U hU => isOpen_inter_nonempty_of_isOpen (hu₂ U hU)
  · intro t ⟨ht₁, ht₂⟩ s hs
    rw [exists_mem_image]
    rcases eq_empty_or_nonempty s with rfl | _
    · exists ∅; simpa
    obtain ⟨u, v, hu, hv, rfl⟩ : ∃ u v, u ⊆ powerset '' {U | IsOpen U} ∧
        v ⊆ (fun V => {s | (s ∩ V).Nonempty}) '' {U | IsOpen U} ∧ u ∪ v = t := by
      rw [← inter_eq_left, inter_union_distrib_left] at ht₂
      exact ⟨_, _, inter_subset_right, inter_subset_right, ht₂⟩
    rw [finite_union] at ht₁
    obtain ⟨u, hu₁, hu₂, rfl⟩ := exists_subset_image_finite_and.mp ⟨u, hu, ht₁.1, rfl⟩
    obtain ⟨v, hv₁, hv₂, rfl⟩ := exists_subset_image_finite_and.mp ⟨v, hv, ht₁.2, rfl⟩
    let U := ⋂₀ u
    have hU : IsOpen U := hu₂.isOpen_sInter hu₁
    simp_rw [sInter_union, show ⋂₀ (powerset '' u) = U.powerset by ext; simp [U], sInter_image]
      at hs ⊢
    rw [mem_inter_iff, mem_powerset_iff, mem_iInter₂] at hs
    exists insert U ((U ∩ ·) '' v)
    simp_rw [show ⋃₀ (insert U ((U ∩ ·) '' v)) = U by simp, mem_setOf, finite_insert,
      forall_mem_insert, forall_mem_image, ← inter_assoc, inter_eq_left.mpr hs.1]
    refine ⟨⟨hv₂.image _, hU, fun V hV => hU.inter (hv₁ hV)⟩, by grind,
      fun t ⟨htU, _, ht⟩ => ⟨htU, mem_iInter₂_of_mem ?_⟩⟩
    simpa only [inter_eq_left.mpr htU] using ht

/-- Given a basis `B` on the underlying topological space, the Vietoris topology has a basis
consisting of sets of the form `{s | s ⊆ V, s ∩ U₁ ≠ ∅, …, s ∩ Uₙ ≠ ∅}`, where `U₁, …, Uₙ ∈ B` are
subsets of some open set `V`. -/
theorem _root_.TopologicalSpace.IsTopologicalBasis.vietoris
    {B : Set (Set α)} (hB : IsTopologicalBasis B) :
    IsTopologicalBasis <|
      (fun p => {s ⊆ p.1 | ∀ U ∈ p.2, (s ∩ U).Nonempty}) ''
      {p : Set α × Set (Set α) | IsOpen p.1 ∧ p.2.Finite ∧ p.2 ⊆ B ∧ (∀ U ∈ p.2, U ⊆ p.1)} := by
  refine isTopologicalBasis.isTopologicalBasis_of_exists_subset ?_ ?_ <;>
    rw [forall_mem_image]
  · intro ⟨V, u⟩ ⟨hV, hu, huB, _⟩
    simp_rw [setOf_and, setOf_forall]
    exact hV.powerset_vietoris.inter <|
      hu.isOpen_biInter fun V hV => isOpen_inter_nonempty_of_isOpen <| hB.isOpen <| huB hV
  · intro u ⟨hu₁, hu₂⟩ s ⟨hs₁, hs₂⟩
    choose! f hfB hfU hfs using show ∀ U ∈ u, ∃ W ∈ B, W ⊆ U ∧ (s ∩ W).Nonempty by
      intro U hU
      obtain ⟨x, hxs, hxU⟩ := hs₂ U hU
      obtain ⟨W, hWB, hxW, hW⟩ := hB.exists_subset_of_mem_open hxU <| hu₂ U hU
      exact ⟨W, hWB, hW, x, hxs, hxW⟩
    rw [exists_mem_image]
    refine ⟨⟨⋃₀ u, f '' u⟩, ⟨isOpen_sUnion hu₂, hu₁.image _, by grind⟩, by grind,
      fun t ⟨ht₁, ht₂⟩ => ⟨ht₁, fun U hU => ?_⟩⟩
    rw [forall_mem_image] at ht₂
    grw [← hfU U hU]
    exact ht₂ hU

theorem closure_finite_subsets (s : Set α) :
    closure {t | t.Finite ∧ t ⊆ s} = (closure s).powerset := by
  refine subset_antisymm ?_ (fun K hKs => ?_)
  · rw [isClosed_closure.powerset_vietoris.closure_subset_iff]
    exact fun K ⟨_, h⟩ => h.trans subset_closure
  · rw [isTopologicalBasis.mem_closure_iff, forall_mem_image]
    rintro u ⟨hu₁, hu₂⟩ ⟨ht₁, ht₂⟩
    choose x hxU hxs using fun U : u => show (↑U ∩ s).Nonempty by
      obtain ⟨x, hxK, hxV⟩ := ht₂ U U.prop
      exact mem_closure_iff.mp (hKs hxK) _ (hu₂ _ U.prop) hxV
    have := hu₁.to_subtype
    exact ⟨range x, ⟨range_subset_iff.mpr fun V => mem_sUnion_of_mem (hxU V) V.prop,
      fun U hU => ⟨x ⟨U, hU⟩, mem_range_self _, hxU ⟨U, hU⟩⟩⟩,
      finite_range _, range_subset_iff.mpr hxs⟩

theorem continuous_iff {f : α → Set β} :
    Continuous f ↔ (∀ U, IsOpen U → IsOpen (f ⁻¹' U.powerset)) ∧
      (∀ F, IsClosed F → IsClosed (f ⁻¹' F.powerset)) := by
  refine ⟨fun hf =>
      ⟨fun U hU => hU.powerset_vietoris.preimage hf, fun F hF => hF.powerset_vietoris.preimage hf⟩,
    fun ⟨h₁, h₂⟩ => ?_⟩
  rw [continuous_generateFrom_iff]
  rintro _ (⟨U, hU, rfl⟩ | ⟨U, hU, rfl⟩)
  · exact h₁ U hU
  · simp_rw [preimage_setOf_eq, ← not_disjoint_iff_nonempty_inter, ← compl_setOf, isOpen_compl_iff,
      ← subset_compl_iff_disjoint_right]
    exact h₂ Uᶜ hU.isClosed_compl

@[fun_prop]
theorem isEmbedding_singleton : IsEmbedding ({·} : α → Set α) where
  injective := Set.singleton_injective
  eq_induced := by
    simp_rw [TopologicalSpace.vietoris, induced_generateFrom_eq, image_union, image_image,
      powerset, preimage_setOf_eq, singleton_subset_iff, singleton_inter_nonempty, union_self,
      setOf_mem_eq, image_id', generateFrom_setOf_isOpen]

@[fun_prop]
theorem continuous_singleton : Continuous ({·} : α → Set α) :=
  isEmbedding_singleton.continuous

/-- Auxiliary lemma showing that singleton sets form a closed set. It takes the required topological
properties as arguments, so that it applies to both the Vietoris topology and the Hausdorff
uniformity. -/
theorem _root_.isClosed_range_singleton_aux [T2Space α] {t : TopologicalSpace (Set α)}
    (h₁ : IsOpen {(∅ : Set α)}) (h₂ : ∀ {U : Set α}, IsOpen U → IsOpen {s | (s ∩ U).Nonempty}) :
    IsClosed (Set.range ({·} : α → Set α)) := by
  rw [← isOpen_compl_iff, isOpen_iff_mem_nhds]
  intro s hs
  rcases Set.eq_empty_or_nonempty s with rfl | h
  · rwa [(isOpen_singleton_iff_nhds_eq_pure _).mp h₁, Filter.mem_pure]
  rcases h.exists_eq_singleton_or_nontrivial with ⟨x, rfl⟩ | ⟨x, hx, y, hy, hxy⟩
  · cases hs <| Set.mem_range_self x
  obtain ⟨U, V, hU, hV, hxU, hyV, hUV⟩ := t2_separation hxy
  filter_upwards [(h₂ hU).inter (h₂ hV) |>.mem_nhds ⟨⟨x, hx, hxU⟩, ⟨y, hy, hyV⟩⟩]
  rintro _ ⟨hzU, hzV⟩ ⟨z, rfl⟩
  rw [Set.mem_setOf, Set.singleton_inter_nonempty] at hzU hzV
  exact hUV.notMem_of_mem_left hzU hzV

@[fun_prop]
theorem isClosedEmbedding_singleton [T2Space α] :
    Topology.IsClosedEmbedding ({·} : α → Set α) where
  __ := isEmbedding_singleton
  isClosed_range :=
    isClosed_range_singleton_aux isClopen_singleton_empty.isOpen isOpen_inter_nonempty_of_isOpen

@[fun_prop]
theorem continuous_union : Continuous (fun x : Set α × Set α => x.1 ∪ x.2) := by
  simp_rw [continuous_iff, powerset, preimage_setOf_eq, union_subset_iff, setOf_and]
  exact ⟨
    fun U hU => .inter
      (hU.powerset_vietoris.preimage continuous_fst)
      (hU.powerset_vietoris.preimage continuous_snd),
    fun F hF => .inter
      (hF.powerset_vietoris.preimage continuous_fst)
      (hF.powerset_vietoris.preimage continuous_snd)⟩

@[fun_prop]
theorem continuous_range_of_finite {ι : Type*} [Finite ι] :
    Continuous (range : (ι → α) → Set α) := by
  simp_rw [continuous_iff, powerset, preimage_setOf_eq, range_subset_iff, setOf_forall]
  exact ⟨
    fun U hU => isOpen_iInter_of_finite fun i => hU.preimage <| continuous_apply i,
    fun F hF => isClosed_iInter fun i => hF.preimage <| continuous_apply i⟩

private theorem isCompact_aux {K : Set α} (hK : IsCompact K)
    {s : Set (Set α)} (hsK : s ⊆ K.powerset) (hs : ∀ L ∈ s, IsCompact L) :
    IsCompact {t ⊆ K | ∀ L ∈ s, (t ∩ L).Nonempty} := by
  refine isCompact_generateFrom rfl fun S hS hKS => ?_
  let u := {U | IsOpen U ∧ {s | (s ∩ U).Nonempty} ∈ S}
  by_cases! hsu : ∃ L ∈ s, L ⊆ ⋃₀ u
  · obtain ⟨L, hL, hLu⟩ := hsu
    rw [sUnion_eq_biUnion] at hLu
    obtain ⟨T, hTS, hT, hLT⟩ := (hs L hL).elim_finite_subcover_image (fun _ h => h.1) hLu
    refine ⟨(fun U => {s | (s ∩ U).Nonempty}) '' T, by grind [image_subset_iff], hT.image _, ?_⟩
    simp_rw [sUnion_image, ← setOf_exists, ← nonempty_iUnion, ← inter_iUnion]
    grw [← hLT]
    grind
  · simp_rw [← diff_nonempty] at hsu
    replace hsu L (h : L ∈ s) : (K \ ⋃₀ u ∩ L).Nonempty := (hsu L h).mono <| by grind
    obtain ⟨_, hUS, hUu⟩ := mem_sUnion.mp <| hKS ⟨diff_subset, hsu⟩
    rcases hS hUS with ⟨U, hU, rfl⟩ | ⟨U, hU, rfl⟩
    · rw [mem_powerset_iff, diff_subset_comm, sUnion_eq_biUnion] at hUu
      obtain ⟨T, hTS, hT, hKT⟩ := (hK.diff hU).elim_finite_subcover_image (fun _ h => h.1) hUu
      refine ⟨insert U.powerset ((fun V => {s | (s ∩ V).Nonempty}) '' T),
        insert_subset hUS <| Set.image_subset_iff.mpr <| hTS.trans fun _ h => h.2,
        (hT.image _).insert _, ?_⟩
      rw [sUnion_insert, ← diff_subset_iff, sUnion_image]
      rintro t ⟨⟨htK, -⟩, htU⟩
      rw [mem_powerset_iff, not_subset] at htU
      obtain ⟨x, hxt, hxU⟩ := htU
      obtain ⟨V, hVT, hxV⟩ := mem_iUnion₂.mp <| hKT ⟨htK hxt, hxU⟩
      exact mem_biUnion hVT ⟨x, hxt, hxV⟩
    · obtain ⟨x, hxu, hxU⟩ := hUu
      cases hxu.2 <| mem_sUnion_of_mem hxU ⟨hU, hUS⟩

theorem _root_.IsCompact.powerset_vietoris {K : Set α} (hK : IsCompact K) :
    IsCompact K.powerset := by
  simpa using isCompact_aux hK (s := ∅)

instance [CompactSpace α] : CompactSpace (Set α) :=
  ⟨powerset_univ ▸ isCompact_univ.powerset_vietoris⟩

theorem specializes_of_subset_closure {s t : Set α} (hst : s ⊆ t) (hts : t ⊆ closure s) :
    s ⤳ t := by
  simp_rw [Specializes, nhds_generateFrom, le_iInf₂_iff]
  rintro _ ⟨hs, ⟨U, hU, rfl⟩ | ⟨U, hU, rfl⟩⟩
  · exact iInf₂_le U.powerset ⟨hst.trans hs, .inl <| mem_image_of_mem _ hU⟩
  · obtain ⟨x, hxt, hxU⟩ := hs
    obtain ⟨y, hyU, hys⟩ := mem_closure_iff.mp (hts hxt) U hU hxU
    exact iInf₂_le {t | (t ∩ U).Nonempty} ⟨⟨y, hys, hyU⟩, .inr <| mem_image_of_mem _ hU⟩

theorem specializes_closure {s : Set α} : s ⤳ closure s :=
  specializes_of_subset_closure subset_closure .rfl

theorem isPreconnected_nonempty_finite_subsets {s : Set α} (hs : IsPreconnected s) :
    IsPreconnected {t | t.Nonempty ∧ t.Finite ∧ t ⊆ s} := by
  rcases eq_empty_or_nonempty s with rfl | ⟨x, hx⟩
  · convert isPreconnected_empty
    grind [Set.not_nonempty_empty]
  conv => arg 1; equals ⋃ n : ℕ+, range (ι := Fin n) '' Set.pi univ fun _ => s =>
    refine subset_antisymm (fun t ht => ?_)
      (iUnion_subset fun _ => image_subset_iff.mpr fun f hf =>
        ⟨range_nonempty _, finite_range _, by grind⟩)
    obtain ⟨ht₁, ht₂, hts⟩ := ht
    obtain ⟨n, f, -, rfl⟩ := ht₂.fin_param
    rw [range_subset_iff] at hts
    rw [range_nonempty_iff_nonempty] at ht₁
    lift n to ℕ+ using Fin.pos'
    exact mem_iUnion_of_mem n <| mem_image_of_mem _ <| mem_univ_pi.mpr hts
  exact isPreconnected_iUnion
    ⟨{x}, mem_iInter_of_mem fun n => ⟨fun _ => x, by grind⟩⟩
    (fun n => .image (isPreconnected_univ_pi fun _ => hs) _ (by fun_prop))

theorem isPreconnected_sUnion {s : Set (Set α)} (hs : IsPreconnected s)
    (h : ∃ t ∈ s, IsPreconnected t) : IsPreconnected (⋃₀ s) := by
  obtain ⟨t, hts, ht⟩ := h
  have hts' := subset_sUnion_of_mem hts
  intro U V hU hV hUV
  by_cases! ht' : t ⊆ U ∨ t ⊆ V
  · wlog htU : t ⊆ U generalizing U V
    · grind
    rintro - ⟨y, hys, hyV⟩
    obtain ⟨u, hus, hyu⟩ := mem_sUnion.mpr hys
    have : s ⊆ {v | (v ∩ V).Nonempty} ∪ U.powerset := by
      simp_rw [← diff_subset_iff, ← not_disjoint_iff_nonempty_inter]
      grind
    obtain ⟨v, hvs, hvU, hvV⟩ :=
      hs _ _ (isOpen_inter_nonempty_of_isOpen hV) hU.powerset_vietoris this
        ⟨u, hus, y, hyu, hyV⟩ ⟨t, by grind⟩
    apply hvU.mono
    grind
  · rintro - -
    grw [← hts'] at hUV ⊢
    have htU : ¬ Disjoint t U := by grind
    have htV : ¬ Disjoint t V := by grind
    rw [not_disjoint_iff_nonempty_inter] at htU htV
    exact ht U V hU hV hUV htU htV

end vietoris

namespace Compacts

/-- The Vietoris topology on the compact subsets of a topological space. -/
instance topology : TopologicalSpace (Compacts α) :=
  .induced (↑) (.vietoris α)

@[fun_prop]
theorem isEmbedding_coe : IsEmbedding ((↑) : Compacts α → Set α) where
  injective := SetLike.coe_injective
  eq_induced := rfl

@[fun_prop]
theorem continuous_coe : Continuous ((↑) : Compacts α → Set α) :=
  isEmbedding_coe.continuous

theorem isOpen_subsets_of_isOpen {U : Set α} (h : IsOpen U) :
    IsOpen {K : Compacts α | ↑K ⊆ U} :=
  continuous_coe.isOpen_preimage _ h.powerset_vietoris

theorem isOpen_inter_nonempty_of_isOpen {U : Set α} (h : IsOpen U) :
    IsOpen {K : Compacts α | (↑K ∩ U).Nonempty} :=
  continuous_coe.isOpen_preimage _ <| vietoris.isOpen_inter_nonempty_of_isOpen h

theorem isClosed_subsets_of_isClosed {F : Set α} (h : IsClosed F) :
    IsClosed {K : Compacts α | ↑K ⊆ F} := by
  simp_rw [← isOpen_compl_iff, Set.compl_setOf, ← Set.inter_compl_nonempty_iff]
  exact isOpen_inter_nonempty_of_isOpen h.isOpen_compl

theorem isClosed_inter_nonempty_of_isClosed {F : Set α} (h : IsClosed F) :
    IsClosed {K : Compacts α | (↑K ∩ F).Nonempty} := by
  simp_rw +singlePass [← compl_compl F, Set.inter_compl_nonempty_iff, ← Set.compl_setOf]
  exact (isOpen_subsets_of_isOpen h.isOpen_compl).isClosed_compl

theorem isClopen_singleton_bot : IsClopen {(⊥ : Compacts α)} := by
  convert vietoris.isClopen_singleton_empty.preimage continuous_coe
  rw [← coe_bot, ← image_singleton (f := SetLike.coe), SetLike.coe_injective.preimage_image]

theorem closure_finite_subsets (s : Set α) :
    closure {K : Compacts α | (K : Set α).Finite ∧ ↑K ⊆ s} = {K : Compacts α | ↑K ⊆ closure s} := by
  change closure (SetLike.coe ⁻¹' {K : Set α | K.Finite ∧ K ⊆ s}) =
    SetLike.coe ⁻¹' (closure s).powerset
  rw [isEmbedding_coe.closure_eq_preimage_closure_image, image_preimage_eq_of_subset ?_,
    vietoris.closure_finite_subsets]
  exact fun K ⟨hK, _⟩ => ⟨⟨K, hK.isCompact⟩, rfl⟩

theorem dense_setOf_finite : Dense {K : Compacts α | (K : Set α).Finite} := by
  simpa [dense_iff_closure_eq] using closure_finite_subsets (α := α) Set.univ

/-- Given a basis `B` on a topological space `α`, the topology of `Compacts α` has a basis
consisting of sets of the form `{K | K ⊆ U₁ ∪ … ∪ Uₙ, K ∩ U₁ ≠ ∅, …, K ∩ Uₙ ≠ ∅}`, where
`U₁, …, Uₙ ∈ B`. -/
theorem _root_.TopologicalSpace.IsTopologicalBasis.compacts
    {B : Set (Set α)} (hB : IsTopologicalBasis B) :
    IsTopologicalBasis <|
      (fun u => {K : Compacts α | ↑K ⊆ ⋃₀ u ∧ ∀ U ∈ u, (↑K ∩ U).Nonempty}) ''
      {u | u.Finite ∧ u ⊆ B} := by
  refine hB.vietoris.isInducing isEmbedding_coe.isInducing
    |>.isTopologicalBasis_of_exists_subset ?_ ?_ <;> simp_rw [forall_mem_image]
  · intro u ⟨hu, huB⟩
    simp_rw [setOf_and, setOf_forall]
    exact .inter
      (isOpen_subsets_of_isOpen <| isOpen_sUnion fun U hU => hB.isOpen <| huB hU)
      (hu.isOpen_biInter fun U hU => isOpen_inter_nonempty_of_isOpen <| hB.isOpen <| huB hU)
  · intro ⟨V, u⟩ ⟨hV, hu, huB, huV⟩ K ⟨hKV, hKu⟩
    dsimp only at *
    obtain ⟨w, hwB, hwV⟩ := hB.open_eq_sUnion hV
    rw [hwV] at hKV
    replace hwV := hwV.symm.subset
    wlog hwK : ∀ W ∈ w, ((K : Set α) ∩ W).Nonempty generalizing w
    · refine this {W ∈ w | (↑K ∩ W).Nonempty} (fun x hx => ?_) (by grind) (by grind) (by grind)
      obtain ⟨W, hWw, hxW⟩ := mem_sUnion.mp (hKV hx)
      exact mem_sUnion_of_mem hxW ⟨hWw, x, hx, hxW⟩
    wlog hw : w.Finite generalizing w
    · rw [sUnion_eq_biUnion] at hKV
      obtain ⟨w', _⟩ := K.isCompact.elim_finite_subcover_image (fun W hW => hB.isOpen (hwB hW)) hKV
      apply this w' <;> grind [sUnion_eq_biUnion]
    wlog huw : u ⊆ w generalizing w
    · apply this (u ∪ w) <;> grind [sUnion_union, Finite.union]
    rw [exists_mem_image]
    exists w
    grind

/-- The topology of `Compacts α` has a basis consisting of sets of the form
`{K | K ⊆ U₁ ∪ … ∪ Uₙ, K ∩ U₁ ≠ ∅, …, K ∩ Uₙ ≠ ∅}`, where `U₁, …, Uₙ` are open sets.

See also `TopologicalSpace.IsTopologicalBasis.compacts` for a variant where the sets `Uᵢ`
are chosen from some basis. -/
theorem isTopologicalBasis :
    IsTopologicalBasis <|
      (fun u => {K : Compacts α | ↑K ⊆ ⋃₀ u ∧ ∀ U ∈ u, (↑K ∩ U).Nonempty}) ''
      {u : Set (Set α) | u.Finite ∧ ∀ U ∈ u, IsOpen U} :=
  isTopologicalBasis_opens.compacts

@[fun_prop]
theorem isEmbedding_singleton : IsEmbedding ({·} : α → Compacts α) :=
  isEmbedding_coe.of_comp_iff.mp vietoris.isEmbedding_singleton

@[fun_prop]
theorem continuous_singleton : Continuous ({·} : α → Compacts α) :=
  isEmbedding_singleton.continuous

@[fun_prop]
theorem isClosedEmbedding_singleton [T2Space α] :
    Topology.IsClosedEmbedding ({·} : α → Compacts α) :=
  .of_comp isEmbedding_coe vietoris.isClosedEmbedding_singleton

instance : ContinuousSup (Compacts α) := by
  constructor
  simp_rw [isEmbedding_coe.continuous_iff, Function.comp_def, coe_sup]
  fun_prop

@[fun_prop]
theorem continuous_prod : Continuous fun p : Compacts α × Compacts β => p.1 ×ˢ p.2 := by
  rw [continuous_induced_rng, continuous_generateFrom_iff]
  rintro _ (⟨U, hU, rfl⟩ | ⟨U, hU, rfl⟩)
  · rw [isOpen_iff_forall_mem_open]
    intro ⟨K, L⟩ (hKL : (K : Set α) ×ˢ (L : Set β) ⊆ U)
    obtain ⟨V, W, hV, hW, hK, hL, hVW⟩ := generalized_tube_lemma K.isCompact L.isCompact hU hKL
    exact ⟨_, fun ⟨K', L'⟩ ⟨hK', hL'⟩ => (Set.prod_mono hK' hL').trans hVW,
      (isOpen_subsets_of_isOpen hV).prod (isOpen_subsets_of_isOpen hW), hK, hL⟩
  · rw [isOpen_iff_forall_mem_open]
    intro ⟨K, L⟩ ⟨⟨x, y⟩, ⟨(hx : x ∈ K), (hy : y ∈ L)⟩, hxy⟩
    obtain ⟨V, W, hV, hW, hxV, hyW, hVW⟩ := isOpen_prod_iff.mp hU x y hxy
    grw [preimage_setOf_eq, ← hVW]
    simp_rw [Function.comp_apply, coe_prod, prod_inter_prod, prod_nonempty_iff]
    exact ⟨_, .rfl,
      (isOpen_inter_nonempty_of_isOpen hV).prod (isOpen_inter_nonempty_of_isOpen hW),
      ⟨x, hx, hxV⟩, ⟨y, hy, hyW⟩⟩

theorem isCompact_subsets_of_isCompact {K : Set α} (hK : IsCompact K) :
    IsCompact {L : Compacts α | ↑L ⊆ K} := by
  rw [isEmbedding_coe.isCompact_iff]
  refine .of_subset_of_specializes hK.powerset_vietoris (by grind) (fun s hs => ?_)
  let L : Compacts α := ⟨K ∩ closure s, hK.inter_right isClosed_closure⟩
  exact ⟨L, mem_image_of_mem _ inter_subset_left,
    vietoris.specializes_of_subset_closure (subset_inter hs subset_closure) inter_subset_right⟩

instance [CompactSpace α] : CompactSpace (Compacts α) :=
  ⟨by simpa using isCompact_subsets_of_isCompact isCompact_univ⟩

theorem isCompact_biUnion_coe_of_isCompact {S : Set (Compacts α)} (hS : IsCompact S) :
    IsCompact (⋃ K ∈ S, (K : Set α)) := by
  rw [isCompact_iff_finite_subcover]
  intro ι U hU h
  rw [iUnion₂_subset_iff] at h
  obtain ⟨s, hs⟩ := hS.elim_finite_subcover
    (fun s : Finset ι => {K | (K : Set α) ⊆ ⋃ i ∈ s, U i})
    (fun s => isOpen_subsets_of_isOpen <| isOpen_biUnion fun _ _ => hU _)
    (fun K hK => mem_iUnion.mpr <| K.isCompact.elim_finite_subcover U hU <| h K hK)
  classical
  refine ⟨s.biUnion id, (biUnion_subset_biUnion_left hs).trans ?_⟩
  simp_rw [biUnion_iUnion, iUnion_subset_iff, Finset.set_biUnion_biUnion]
  exact fun t ht K hK => subset_iUnion₂_of_subset t ht hK

@[simp]
theorem compactSpace_iff : CompactSpace (Compacts α) ↔ CompactSpace α := by
  refine ⟨fun h => ⟨?_⟩, fun _ => inferInstance⟩
  convert isCompact_biUnion_coe_of_isCompact (α := α) isCompact_univ
  symm
  simp_rw [biUnion_univ, eq_univ_iff_forall, mem_iUnion]
  exact fun x => ⟨{x}, Set.mem_singleton x⟩

@[simp]
theorem noncompactSpace_iff : NoncompactSpace (Compacts α) ↔ NoncompactSpace α := by
  simp_rw [← not_compactSpace_iff, compactSpace_iff]

instance [NoncompactSpace α] : NoncompactSpace (Compacts α) :=
  noncompactSpace_iff.mpr ‹_›

theorem isPreconnected_nonempty_finite_subsets {s : Set α} (hs : IsPreconnected s) :
    IsPreconnected {K : Compacts α | (K : Set α).Nonempty ∧ (K : Set α).Finite ∧ ↑K ⊆ s} := by
  rw [← isEmbedding_coe.isPreconnected_image]
  convert vietoris.isPreconnected_nonempty_finite_subsets hs
  exact subset_antisymm (image_subset_iff.mpr .rfl) (fun t ht => ⟨⟨t, ht.2.1.isCompact⟩, ht, rfl⟩)

theorem isPreconnected_nonempty_subsets {s : Set α} (hs : IsPreconnected s) :
    IsPreconnected {K : Compacts α | (K : Set α).Nonempty ∧ ↑K ⊆ s} := by
  refine (isPreconnected_nonempty_finite_subsets hs).subset_closure (by grind) ?_
  conv_lhs => rw [setOf_and]
  conv_rhs => rw [setOf_and]
  simp_rw [nonempty_iff_ne_empty, ← coe_bot, SetLike.coe_ne_coe, Ne, ← compl_singleton_eq]
  grw [← isClopen_singleton_bot.compl.isOpen.inter_closure, closure_finite_subsets,
    ← subset_closure]

end Compacts

namespace NonemptyCompacts

/-- The Vietoris topology on the nonempty compact subsets of a topological space. -/
instance topology : TopologicalSpace (NonemptyCompacts α) :=
  .induced (↑) (.vietoris α)

@[fun_prop]
theorem isEmbedding_coe : IsEmbedding ((↑) : NonemptyCompacts α → Set α) where
  injective := SetLike.coe_injective
  eq_induced := rfl

@[fun_prop]
theorem continuous_coe : Continuous ((↑) : NonemptyCompacts α → Set α) :=
  isEmbedding_coe.continuous

@[fun_prop]
theorem isEmbedding_toCompacts : IsEmbedding (toCompacts (α := α)) where
  injective := toCompacts_injective
  eq_induced := .symm <| induced_compose (f := toCompacts) (g := SetLike.coe)

@[fun_prop]
theorem continuous_toCompacts : Continuous (toCompacts (α := α)) :=
  isEmbedding_toCompacts.continuous

@[fun_prop]
theorem isClosedEmbedding_toCompacts : IsClosedEmbedding (toCompacts (α := α)) where
  __ := isEmbedding_toCompacts
  isClosed_range := by
    rw [range_toCompacts]
    exact Compacts.isClopen_singleton_bot.compl.isClosed

@[fun_prop]
theorem isOpenEmbedding_toCompacts : IsOpenEmbedding (toCompacts (α := α)) where
  __ := isEmbedding_toCompacts
  isOpen_range := by
    rw [range_toCompacts]
    exact Compacts.isClopen_singleton_bot.compl.isOpen

theorem isOpen_subsets_of_isOpen {U : Set α} (h : IsOpen U) :
    IsOpen {K : NonemptyCompacts α | ↑K ⊆ U} :=
  h.powerset_vietoris.preimage continuous_coe

theorem isOpen_inter_nonempty_of_isOpen {U : Set α} (h : IsOpen U) :
    IsOpen {K : NonemptyCompacts α | (↑K ∩ U).Nonempty} :=
  (vietoris.isOpen_inter_nonempty_of_isOpen h).preimage continuous_coe

theorem isClosed_subsets_of_isClosed {F : Set α} (h : IsClosed F) :
    IsClosed {K : NonemptyCompacts α | ↑K ⊆ F} :=
  h.powerset_vietoris.preimage continuous_coe

theorem isClosed_inter_nonempty_of_isClosed {F : Set α} (h : IsClosed F) :
    IsClosed {K : NonemptyCompacts α | (↑K ∩ F).Nonempty} :=
  (vietoris.isClosed_inter_nonempty_of_isClosed h).preimage continuous_coe

theorem closure_finite_subsets (s : Set α) :
    closure {K : NonemptyCompacts α | (K : Set α).Finite ∧ ↑K ⊆ s} =
      {K : NonemptyCompacts α | ↑K ⊆ closure s} := by
  simpa only [isOpenEmbedding_toCompacts.isOpenMap.preimage_closure_eq_closure_preimage
    continuous_toCompacts] using congr(toCompacts ⁻¹' $(Compacts.closure_finite_subsets s))

theorem dense_setOf_finite : Dense {K : NonemptyCompacts α | (K : Set α).Finite} :=
  Compacts.dense_setOf_finite.preimage isOpenEmbedding_toCompacts.isOpenMap

/-- Given a basis `B` on a topological space `α`, the topology of `NonemptyCompacts α` has a basis
consisting of sets of the form `{K | K ⊆ U₁ ∪ … ∪ Uₙ, K ∩ U₁ ≠ ∅, …, K ∩ Uₙ ≠ ∅}`, where
`U₁, …, Uₙ ∈ B` and `n > 0`. -/
theorem _root_.TopologicalSpace.IsTopologicalBasis.nonemptyCompacts
    {B : Set (Set α)} (hB : IsTopologicalBasis B) :
    IsTopologicalBasis <|
      (fun u => {K : NonemptyCompacts α | ↑K ⊆ ⋃₀ u ∧ ∀ U ∈ u, (↑K ∩ U).Nonempty}) ''
      {u | u.Finite ∧ u.Nonempty ∧ u ⊆ B} := by
  refine hB.compacts.isInducing isEmbedding_toCompacts.isInducing
    |>.isTopologicalBasis_of_exists_subset ?_ ?_ <;> simp_rw [forall_mem_image]
  · rintro u ⟨hu, -, huB⟩
    simp_rw [setOf_and, setOf_forall]
    exact .inter
      (isOpen_subsets_of_isOpen <| isOpen_sUnion fun U hU => hB.isOpen <| huB hU)
      (hu.isOpen_biInter fun U hU => isOpen_inter_nonempty_of_isOpen <| hB.isOpen <| huB hU)
  · intro u ⟨hu, huB⟩ K ⟨hK₁, hK₂⟩
    rcases eq_empty_or_nonempty u with rfl | hu'
    · absurd K.nonempty.mono hK₁; simp
    rw [exists_mem_image]
    exists u

/-- The topology of `NonemptyCompacts α` has a basis consisting of sets of the form
`{s | s ⊆ U₁ ∪ … ∪ Uₙ, s ∩ U₁ ≠ ∅, …, s ∩ Uₙ ≠ ∅}`, where `U₁, …, Uₙ` are open sets and `n > 0`.

See also `TopologicalSpace.IsTopologicalBasis.nonemptyCompacts` for a variant where the sets `Uᵢ`
are chosen from some basis. -/
theorem isTopologicalBasis :
    IsTopologicalBasis <|
      (fun u => {K : NonemptyCompacts α | ↑K ⊆ ⋃₀ u ∧ ∀ U ∈ u, (↑K ∩ U).Nonempty}) ''
      {u : Set (Set α) | u.Finite ∧ u.Nonempty ∧ ∀ U ∈ u, IsOpen U} :=
  isTopologicalBasis_opens.nonemptyCompacts

@[fun_prop]
theorem isEmbedding_singleton : IsEmbedding ({·} : α → NonemptyCompacts α) :=
  isEmbedding_coe.of_comp_iff.mp vietoris.isEmbedding_singleton

@[fun_prop]
theorem continuous_singleton : Continuous ({·} : α → NonemptyCompacts α) :=
  isEmbedding_singleton.continuous

@[fun_prop]
theorem isClosedEmbedding_singleton [T2Space α] :
    Topology.IsClosedEmbedding ({·} : α → NonemptyCompacts α) :=
  isClosedEmbedding_toCompacts.of_comp_iff.mp Compacts.isClosedEmbedding_singleton

instance : ContinuousSup (NonemptyCompacts α) := by
  constructor
  simp_rw [isEmbedding_toCompacts.continuous_iff, Function.comp_def, toCompacts_sup]
  fun_prop

@[fun_prop]
theorem continuous_prod :
    Continuous fun p : NonemptyCompacts α × NonemptyCompacts β => p.1 ×ˢ p.2 := by
  simp_rw [isEmbedding_toCompacts.continuous_iff, Function.comp_def, toCompacts_prod]
  fun_prop

instance [CompactSpace α] : CompactSpace (NonemptyCompacts α) :=
  isClosedEmbedding_toCompacts.compactSpace

theorem isCompact_subsets_of_isCompact {K : Set α} (hK : IsCompact K) :
    IsCompact {L : NonemptyCompacts α | ↑L ⊆ K} :=
  isClosedEmbedding_toCompacts.isCompact_preimage (Compacts.isCompact_subsets_of_isCompact hK)

theorem isCompact_biUnion_coe_of_isCompact {S : Set (NonemptyCompacts α)} (hs : IsCompact S) :
    IsCompact (⋃ K ∈ S, (K : Set α)) := by
  convert Compacts.isCompact_biUnion_coe_of_isCompact (hs.image continuous_toCompacts)
  simp_rw [biUnion_image, coe_toCompacts]

@[simp]
theorem compactSpace_iff : CompactSpace (NonemptyCompacts α) ↔ CompactSpace α := by
  refine ⟨fun h => ⟨?_⟩, fun _ => inferInstance⟩
  convert isCompact_biUnion_coe_of_isCompact (α := α) isCompact_univ
  symm
  simp_rw [biUnion_univ, eq_univ_iff_forall, mem_iUnion]
  exact fun x => ⟨{x}, Set.mem_singleton x⟩

@[simp]
theorem noncompactSpace_iff : NoncompactSpace (NonemptyCompacts α) ↔ NoncompactSpace α := by
  simp_rw [← not_compactSpace_iff, compactSpace_iff]

instance [NoncompactSpace α] : NoncompactSpace (NonemptyCompacts α) :=
  noncompactSpace_iff.mpr ‹_›

theorem isPreconnected_finite_subsets {s : Set α} (hs : IsPreconnected s) :
    IsPreconnected {K : NonemptyCompacts α | (K : Set α).Finite ∧ ↑K ⊆ s} := by
  rw [← isEmbedding_toCompacts.isPreconnected_image]
  convert Compacts.isPreconnected_nonempty_finite_subsets hs
  exact subset_antisymm
    (image_subset_iff.mpr fun K hK => ⟨K.nonempty, hK⟩)
    (fun K hK => ⟨⟨K, hK.1⟩, hK.2, rfl⟩)

theorem isPreconnected_subsets {s : Set α} (hs : IsPreconnected s) :
    IsPreconnected {K : NonemptyCompacts α | ↑K ⊆ s} := by
  rw [← isEmbedding_toCompacts.isPreconnected_image]
  convert Compacts.isPreconnected_nonempty_subsets hs
  exact subset_antisymm
    (image_subset_iff.mpr fun K hK => ⟨K.nonempty, hK⟩)
    (fun K hK => ⟨⟨K, hK.1⟩, hK.2, rfl⟩)

instance [PreconnectedSpace α] : PreconnectedSpace (NonemptyCompacts α) where
  isPreconnected_univ := by
    convert isPreconnected_subsets (α := α) isPreconnected_univ
    simp

@[simp]
theorem preconnectedSpace_iff : PreconnectedSpace (NonemptyCompacts α) ↔ PreconnectedSpace α := by
  refine ⟨fun h => ?_, fun h => inferInstance⟩
  rw [preconnectedSpace_iff_clopen] at h ⊢
  intro s hs
  rcases (h {K | ↑K ⊆ s}
    ⟨isClosed_subsets_of_isClosed hs.isClosed, isOpen_subsets_of_isOpen hs.isOpen⟩) with h | h
  · left
    rw [Set.eq_empty_iff_forall_notMem] at h ⊢
    exact fun x hx => h {x} (Set.singleton_subset_iff.mpr hx)
  · right
    rw [Set.eq_univ_iff_forall] at h ⊢
    exact fun x => Set.singleton_subset_iff.mp (h {x})

instance [ConnectedSpace α] : ConnectedSpace (NonemptyCompacts α) where
  toNonempty := inferInstance

@[simp]
theorem connectedSpace_iff : ConnectedSpace (NonemptyCompacts α) ↔ ConnectedSpace α := by
  refine ⟨fun h => ?_, fun _ => inferInstance⟩
  have := preconnectedSpace_iff.mp h.toPreconnectedSpace;
  constructor
  rw [← not_isEmpty_iff]
  intro
  absurd h.toNonempty
  rw [not_nonempty_iff]
  infer_instance

end NonemptyCompacts

end TopologicalSpace
