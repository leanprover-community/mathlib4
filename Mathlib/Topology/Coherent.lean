/-
Copyright (c) 2024 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov
-/
import Mathlib.Topology.Defs.Sequences
import Mathlib.Topology.ContinuousOn

/-!
# Topology generated by its restrictions to subsets

We say that restrictions of the topology on `X` to sets from a family `S`
generates the original topology,
if either of the following equivalent conditions hold:

- a set which is relatively open in each `s ‚àà S` is open;
- a set which is relatively closed in each `s ‚àà S` is closed;
- for any topological space `Y`, a function `f : X ‚Üí Y` is continuous
  provided that it is continuous on each `s ‚àà S`.

We use the first condition as the definition
(see `IsCoherentWith` in `Mathlib/Topology/Defs/Induced.lean`),
and provide the others as corollaries.

## Main results

- `IsCoherentWith.of_seq`: if `X` is a sequential space
  and `S` contains all sets of the form `insert x (Set.range u)`,
  where `u : ‚Ñï ‚Üí X` is a sequence that converges to `x`,
  then we have `IsCoherentWith S`;
-/

open Filter Set

variable {X : Type*} [TopologicalSpace X] {S : Set (Set X)} {t : Set X} {x : X}

namespace Topology.IsCoherentWith

protected theorem isOpen_iff (hS : IsCoherentWith S) :
    IsOpen t ‚Üî ‚àÄ s ‚àà S, IsOpen ((‚Üë) ‚Åª¬π' t : Set s) :=
  ‚ü®fun ht _ _ ‚Ü¶ ht.preimage continuous_subtype_val, hS.1 t‚ü©

protected theorem isClosed_iff (hS : IsCoherentWith S) :
    IsClosed t ‚Üî ‚àÄ s ‚àà S, IsClosed ((‚Üë) ‚Åª¬π' t : Set s) := by
  simp only [‚Üê isOpen_compl_iff, hS.isOpen_iff, preimage_compl]

protected theorem continuous_iff {Y : Type*} [TopologicalSpace Y] {f : X ‚Üí Y}
    (hS : IsCoherentWith S) :
    Continuous f ‚Üî ‚àÄ s ‚àà S, ContinuousOn f s :=
  ‚ü®fun h _ _ ‚Ü¶ h.continuousOn, fun h ‚Ü¶ continuous_def.2 fun _u hu ‚Ü¶ hS.isOpen_iff.2 fun s hs ‚Ü¶
    hu.preimage <| (h s hs).restrict‚ü©

theorem of_continuous_prop (h : ‚àÄ f : X ‚Üí Prop, (‚àÄ s ‚àà S, ContinuousOn f s) ‚Üí Continuous f) :
    IsCoherentWith S where
  isOpen_of_forall_induced u hu := by
    simp only [continuousOn_iff_continuous_restrict, continuous_Prop] at *
    exact h _ hu

theorem of_isClosed (h : ‚àÄ t : Set X, (‚àÄ s ‚àà S, IsClosed ((‚Üë) ‚Åª¬π' t : Set s)) ‚Üí IsClosed t) :
    IsCoherentWith S :=
  ‚ü®fun _t ht ‚Ü¶ isClosed_compl_iff.1 <| h _ fun s hs ‚Ü¶ (ht s hs).isClosed_compl‚ü©

protected theorem enlarge {T} (hS : IsCoherentWith S) (hT : ‚àÄ s ‚àà S, ‚àÉ t ‚àà T, s ‚äÜ t) :
    IsCoherentWith T :=
  of_continuous_prop fun _f hf ‚Ü¶ hS.continuous_iff.2 fun s hs ‚Ü¶
    let ‚ü®t, htT, hst‚ü© := hT s hs; (hf t htT).mono hst

protected theorem mono {T} (hS : IsCoherentWith S) (hT : S ‚äÜ T) : IsCoherentWith T :=
  hS.enlarge fun s hs ‚Ü¶ ‚ü®s, hT hs, Subset.rfl‚ü©

/-- If `X` is a sequential space
and `S` contains each set of the form `insert x (Set.range u)`
where `u : ‚Ñï ‚Üí X` is a sequence and `x` is its limit,
then topology on `X` is generated by its restrictions to the sets of `S`. -/
lemma of_seq [SequentialSpace X]
    (h : ‚àÄ ‚¶Éu : ‚Ñï ‚Üí X‚¶Ñ ‚¶Éx : X‚¶Ñ, Tendsto u atTop (ùìù x) ‚Üí insert x (range u) ‚àà S) :
    IsCoherentWith S := by
  refine of_isClosed fun t ht ‚Ü¶ IsSeqClosed.isClosed fun u x hut hux ‚Ü¶ ?_
  rcases isClosed_induced_iff.1 (ht _ (h hux)) with ‚ü®s, hsc, hst‚ü©
  rw [Subtype.preimage_val_eq_preimage_val_iff, Set.ext_iff] at hst
  suffices x ‚àà s by specialize hst x; simp_all
  refine hsc.mem_of_tendsto hux <| Eventually.of_forall fun k ‚Ü¶ ?_
  specialize hst (u k)
  simp_all

/-- If each point of the space has a neighborhood from the family `S`,
then the topology is generated by its restrictions to the sets of `S`. -/
lemma of_nhds (h : ‚àÄ x, ‚àÉ s ‚àà S, s ‚àà ùìù x) : IsCoherentWith S :=
  of_continuous_prop fun _f hf ‚Ü¶ continuous_iff_continuousAt.2 fun x ‚Ü¶
    let ‚ü®s, hsS, hsx‚ü© := h x
    (hf s hsS).continuousAt hsx

end Topology.IsCoherentWith
