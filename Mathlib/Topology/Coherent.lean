/-
Copyright (c) 2024 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov
-/
import Mathlib.Topology.Defs.Sequences
import Mathlib.Topology.ContinuousOn
import Mathlib.Topology.ContinuousMap.Basic

/-!
# Topology generated by its restrictions to subsets

We say that restrictions of the topology on `X` to sets from a family `S`
generates the original topology,
if either of the following equivalent conditions hold:

- a set which is relatively open in each `s ‚àà S` is open;
- a set which is relatively closed in each `s ‚àà S` is closed;
- for any topological space `Y`, a function `f : X ‚Üí Y` is continuous
  provided that it is continuous on each `s ‚àà S`.

We use the first condition as the definition
(see `IsCoherentWith` in `Mathlib/Topology/Defs/Induced.lean`),
and provide the others as corollaries.

## Main results

- `IsCoherentWith.of_seq`: if `X` is a sequential space
  and `S` contains all sets of the form `insert x (Set.range u)`,
  where `u : ‚Ñï ‚Üí X` is a sequence that converges to `x`,
  then we have `IsCoherentWith S`;
-/

open Filter Set Set.Notation

variable {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]
  {S : Set (Set X)} {t : Set X} {x : X}

namespace Topology.IsCoherentWith

protected theorem isOpen_iff (hS : IsCoherentWith S) :
    IsOpen t ‚Üî ‚àÄ s ‚àà S, IsOpen ((‚Üë) ‚Åª¬π' t : Set s) :=
  ‚ü®fun ht _ _ ‚Ü¶ ht.preimage continuous_subtype_val, hS.1 t‚ü©

protected theorem isClosed_iff (hS : IsCoherentWith S) :
    IsClosed t ‚Üî ‚àÄ s ‚àà S, IsClosed ((‚Üë) ‚Åª¬π' t : Set s) := by
  simp only [‚Üê isOpen_compl_iff, hS.isOpen_iff, preimage_compl]

protected theorem continuous_iff {Y : Type*} [TopologicalSpace Y] {f : X ‚Üí Y}
    (hS : IsCoherentWith S) :
    Continuous f ‚Üî ‚àÄ s ‚àà S, ContinuousOn f s :=
  ‚ü®fun h _ _ ‚Ü¶ h.continuousOn, fun h ‚Ü¶ continuous_def.2 fun _u hu ‚Ü¶ hS.isOpen_iff.2 fun s hs ‚Ü¶
    hu.preimage <| (h s hs).restrict‚ü©

theorem of_continuous_prop (h : ‚àÄ f : X ‚Üí Prop, (‚àÄ s ‚àà S, ContinuousOn f s) ‚Üí Continuous f) :
    IsCoherentWith S where
  isOpen_of_forall_induced u hu := by
    simp only [continuousOn_iff_continuous_restrict, continuous_Prop] at *
    exact h _ hu

theorem of_isClosed (h : ‚àÄ t : Set X, (‚àÄ s ‚àà S, IsClosed ((‚Üë) ‚Åª¬π' t : Set s)) ‚Üí IsClosed t) :
    IsCoherentWith S :=
  ‚ü®fun _t ht ‚Ü¶ isClosed_compl_iff.1 <| h _ fun s hs ‚Ü¶ (ht s hs).isClosed_compl‚ü©

protected theorem enlarge {T} (hS : IsCoherentWith S) (hT : ‚àÄ s ‚àà S, ‚àÉ t ‚àà T, s ‚äÜ t) :
    IsCoherentWith T :=
  of_continuous_prop fun _f hf ‚Ü¶ hS.continuous_iff.2 fun s hs ‚Ü¶
    let ‚ü®t, htT, hst‚ü© := hT s hs; (hf t htT).mono hst

protected theorem mono {T} (hS : IsCoherentWith S) (hT : S ‚äÜ T) : IsCoherentWith T :=
  hS.enlarge fun s hs ‚Ü¶ ‚ü®s, hT hs, Subset.rfl‚ü©

/-- If `X` is a sequential space
and `S` contains each set of the form `insert x (Set.range u)`
where `u : ‚Ñï ‚Üí X` is a sequence and `x` is its limit,
then topology on `X` is generated by its restrictions to the sets of `S`. -/
lemma of_seq [SequentialSpace X]
    (h : ‚àÄ ‚¶Éu : ‚Ñï ‚Üí X‚¶Ñ ‚¶Éx : X‚¶Ñ, Tendsto u atTop (ùìù x) ‚Üí insert x (range u) ‚àà S) :
    IsCoherentWith S := by
  refine of_isClosed fun t ht ‚Ü¶ IsSeqClosed.isClosed fun u x hut hux ‚Ü¶ ?_
  rcases isClosed_induced_iff.1 (ht _ (h hux)) with ‚ü®s, hsc, hst‚ü©
  rw [Subtype.preimage_val_eq_preimage_val_iff, Set.ext_iff] at hst
  suffices x ‚àà s by specialize hst x; simp_all
  refine hsc.mem_of_tendsto hux <| Eventually.of_forall fun k ‚Ü¶ ?_
  specialize hst (u k)
  simp_all

/-- If each point of the space has a neighborhood from the family `S`,
then the topology is generated by its restrictions to the sets of `S`. -/
lemma of_nhds (h : ‚àÄ x, ‚àÉ s ‚àà S, s ‚àà ùìù x) : IsCoherentWith S :=
  of_continuous_prop fun _f hf ‚Ü¶ continuous_iff_continuousAt.2 fun x ‚Ü¶
    let ‚ü®s, hsS, hsx‚ü© := h x
    (hf s hsS).continuousAt hsx

/-- If a space `X` is coherent with an indexed family of subspaces `S` whose union is `X`, then the
 canonical inclusion from `Œ£ i, S i` to `X` is a quotient map. -/
lemma isQuotientMap_sigma_desc'
    {Œπ : Type*} {S : Œπ ‚Üí Set X} (hX : IsCoherentWith (range S)) (hS : ‚ãÉ i, S i = univ) :
    IsQuotientMap (ContinuousMap.sigma (fun _ ‚Ü¶ ContinuousMap.subtypeVal) : C(Œ£ i, S i, X)) where
  surjective y := by
    rw [iUnion_eq_univ_iff] at hS
    obtain ‚ü®i, hx‚ü© := hS y
    use Sigma.mk i ‚ü®y, hx‚ü©
    simp
  eq_coinduced := by
    ext t
    unfold instTopologicalSpaceSigma
    simp [hX.isOpen_iff (t := t), isOpen_coinduced, isOpen_iSup_iff, preimage_preimage]

/-- If a space `X` is coherent with a set of subspaces `S` whose union is `X`, then the
 canonical inclusion from `Œ£ i, S i` to `X` is a quotient map. -/
lemma isQuotientMap_sigma_desc (hX : IsCoherentWith S) (hS : ‚ãÉ‚ÇÄ S = univ) :
    IsQuotientMap (ContinuousMap.sigma (fun _ ‚Ü¶ ContinuousMap.subtypeVal) : C(Œ£ (s : S), s, X)) :=
  have h : S = range Subtype.val := by simp
  IsCoherentWith.isQuotientMap_sigma_desc' (S := ((‚Üë) : S ‚Üí Set X))
    (h ‚ñ∏ hX) (sUnion_eq_iUnion ‚ñ∏ hS)

variable {S : Set (Set X)} (hS : IsCoherentWith S) (surj : ‚ãÉ‚ÇÄ S = Set.univ) (F : ‚àÄ s ‚àà S, C(s, Y))
  (hF : ‚àÄ (s) (hs : s ‚àà S) (t) (ht : t ‚àà S) (x : X) (hxs : x ‚àà s) (hxt : x ‚àà t),
    F s hs ‚ü®x, hxs‚ü© = F t ht ‚ü®x, hxt‚ü©)

/-- A family `F s` of continuous maps `C(s, Y)`, where (1) the domains `s` are taken from a set `S`
of sets in `X` which are jointly surjective and coherent with `X` and (2) the functions `F s` agree
pairwise on intersections, can be glued to construct a continuous map `C(X, Y)`. -/
noncomputable def liftCover : C(X, Y) where
  toFun := Set.liftCover ((‚Üë) : S ‚Üí Set X) (fun s ‚Ü¶ F s s.2) (fun s t ‚Ü¶ hF s s.2 t t.2)
    (by simp [sUnion_eq_iUnion, ‚Üê surj])
  continuous_toFun := by
    rw [hS.continuous_iff, Subtype.forall']
    intro s
    rw [continuousOn_iff_continuous_restrict, Set.liftCover_restrict]
    exact (F s s.2).continuous

variable {hS surj F hF}

@[simp]
theorem liftCover_coe {s : S} (x : (s : Set X)) : hS.liftCover surj F hF x = F s s.2 x := by
  simp [IsCoherentWith.liftCover]

@[simp]
theorem liftCover_of_mem_coe {s : Set X} (hs : s ‚àà S) (x : s) :
    hS.liftCover surj F hF x = F s hs x :=
  hS.liftCover_coe (s := ‚ü®s, hs‚ü©) x

theorem liftCover_of_mem {s : Set X} (hs : s ‚àà S) {x : X} (hx : x ‚àà s) :
    hS.liftCover surj F hF x = F s hs ‚ü®x, hx‚ü© :=
  hS.liftCover_of_mem_coe hs ‚ü®x, hx‚ü©

theorem preimage_liftCover (t : Set Y) :
    hS.liftCover surj F hF ‚Åª¬π' t = ‚ãÉ s : S, (‚Üë) '' (F s s.2 ‚Åª¬π' t) := by
  simp only [IsCoherentWith.liftCover, ContinuousMap.coe_mk]
  rw [Set.preimage_liftCover]

@[simp]
theorem liftCover_restrict (s : Set X) (hs : s ‚àà S) :
    s.restrict (hS.liftCover surj F hF) = F s hs := by
  ext x; simp [hs]

variable (hS surj) in
/-- When `X` is coherent with a set of subspaces `S`, every continuous map out of `X` can be
written as a `liftCover`. -/
@[simps]
noncomputable def liftEquiv :
    { F : ‚àÄ s ‚àà S, C(s, Y) // ‚àÄ s (hs : s ‚àà S) t (ht : t ‚àà S) x (hxs : x ‚àà s) (hxt : x ‚àà t),
       F s hs ‚ü®x, hxs‚ü© = F t ht ‚ü®x, hxt‚ü© } ‚âÉ C(X, Y) where
  toFun F := hS.liftCover surj F F.2
  invFun f := ‚ü®fun s hs ‚Ü¶ f.restrict s, fun s hs t ht x hxs hxt ‚Ü¶ by simp‚ü©
  left_inv := by rintro ‚ü®F, hF‚ü©; ext s hs x; simp [hs]
  right_inv f := by
    ext x
    rw [sUnion_eq_univ_iff] at surj
    obtain ‚ü®s, hs, hxs‚ü© := surj x
    simp [liftCover_of_mem hs hxs]

/-- A version of `liftEquiv_apply` that is more convenient when rewriting. -/
lemma liftEquiv_apply' : hS.liftCover surj F hF = hS.liftEquiv surj ‚ü®F, hF‚ü© := by rfl

variable {Œπ} {S : Œπ ‚Üí Set X} (hS : IsCoherentWith (range S)) (surj : ‚ãÉ i, S i = Set.univ)
  (œÜ : (i : Œπ) ‚Üí C(S i, Y))
  (hœÜ : ‚àÄ i j x (hxi : x ‚àà S i) (hxj : x ‚àà S j), œÜ i ‚ü®x, hxi‚ü© = œÜ j ‚ü®x, hxj‚ü©)

/-- A family `œÜ i` of continuous maps `(i : Œπ) ‚Üí C(S i, Y)`, where (1) the domains `S i` are taken
from a family `S` of sets in `X` which are jointly surjective and coherent with `X` and (2) the
functions `œÜ` agree pairwise on intersections, can be glued to construct a continuous map
`C(X, Y)`. -/
noncomputable def liftCover' : C(X, Y) where
  toFun := Set.liftCover S (œÜ ¬∑) hœÜ surj
  continuous_toFun := by
    rw [hS.continuous_iff, forall_mem_range]
    intro i
    rw [continuousOn_iff_continuous_restrict, Set.liftCover_restrict]
    exact (œÜ i).continuous

variable {hS surj œÜ hœÜ}
variable {i : Œπ}

@[simp]
theorem liftCover'_coe (x : S i) : hS.liftCover' surj œÜ hœÜ x = œÜ i x := by
  simp [IsCoherentWith.liftCover']

@[simp]
theorem liftCover'_of_mem {x : X} (hx : x ‚àà S i) : hS.liftCover' surj œÜ hœÜ x = œÜ i ‚ü®x, hx‚ü© :=
  hS.liftCover'_coe ‚ü®x, hx‚ü©

theorem preimage_liftCover' (t : Set Y) :
    hS.liftCover' surj œÜ hœÜ ‚Åª¬π' t = ‚ãÉ i, (‚Üë) '' (œÜ i ‚Åª¬π' t) := by
  simp only [IsCoherentWith.liftCover', ContinuousMap.coe_mk]
  rw [Set.preimage_liftCover]

@[simp]
theorem liftCover'_restrict : (S i).restrict (hS.liftCover' surj œÜ hœÜ) = œÜ i := by ext x; simp

variable (hS surj) in
/-- When `X` is coherent with a family of subspaces `S i`, every continuous map out of `X` can be
written as a `liftCover'`. -/
@[simps]
noncomputable def liftEquiv' :
    { œÜ : (i : Œπ) ‚Üí C(S i, Y) // ‚àÄ i j x (hxi : x ‚àà S i) (hxj : x ‚àà S j),
       œÜ i ‚ü®x, hxi‚ü© = œÜ j ‚ü®x, hxj‚ü© } ‚âÉ C(X, Y) where
  toFun œÜ := hS.liftCover' surj œÜ œÜ.2
  invFun f := ‚ü®fun i ‚Ü¶ f.restrict (S i), fun i j x hxi hxj ‚Ü¶ by simp‚ü©
  left_inv := by rintro ‚ü®œÜ, hœÜ‚ü©; ext i x; simp
  right_inv f := by
    ext x
    rw [iUnion_eq_univ_iff] at surj
    obtain ‚ü®i, hxi‚ü© := surj x
    simp [liftCover'_of_mem hxi]

/-- A version of `liftEquiv'_apply` that is more convenient when rewriting. -/
lemma liftEquiv'_apply' : hS.liftCover' surj œÜ hœÜ = hS.liftEquiv' surj ‚ü®œÜ, hœÜ‚ü© := by rfl

end Topology.IsCoherentWith
