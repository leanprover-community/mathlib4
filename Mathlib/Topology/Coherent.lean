/-
Copyright (c) 2024 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov
-/
import Mathlib.Topology.Defs.Sequences
import Mathlib.Topology.ContinuousOn
import Mathlib.Topology.ContinuousMap.Basic

/-!
# Topology generated by its restrictions to subsets

We say that restrictions of the topology on `X` to sets from a family `S`
generates the original topology,
if either of the following equivalent conditions hold:

- a set which is relatively open in each `s âˆˆ S` is open;
- a set which is relatively closed in each `s âˆˆ S` is closed;
- for any topological space `Y`, a function `f : X â†’ Y` is continuous
  provided that it is continuous on each `s âˆˆ S`.

We use the first condition as the definition
(see `IsCoherentWith` in `Mathlib/Topology/Defs/Induced.lean`),
and provide the others as corollaries.

## Main results

- `IsCoherentWith.of_seq`: if `X` is a sequential space
  and `S` contains all sets of the form `insert x (Set.range u)`,
  where `u : â„• â†’ X` is a sequence that converges to `x`,
  then we have `IsCoherentWith S`;
-/

open Filter Set Set.Notation

variable {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]
  {S : Set (Set X)} {t : Set X} {x : X}

namespace Topology.IsCoherentWith

protected theorem isOpen_iff (hS : IsCoherentWith S) :
    IsOpen t â†” âˆ€ s âˆˆ S, IsOpen ((â†‘) â»Â¹' t : Set s) :=
  âŸ¨fun ht _ _ â†¦ ht.preimage continuous_subtype_val, hS.1 tâŸ©

protected theorem isClosed_iff (hS : IsCoherentWith S) :
    IsClosed t â†” âˆ€ s âˆˆ S, IsClosed ((â†‘) â»Â¹' t : Set s) := by
  simp only [â† isOpen_compl_iff, hS.isOpen_iff, preimage_compl]

protected theorem continuous_iff {Y : Type*} [TopologicalSpace Y] {f : X â†’ Y}
    (hS : IsCoherentWith S) :
    Continuous f â†” âˆ€ s âˆˆ S, ContinuousOn f s :=
  âŸ¨fun h _ _ â†¦ h.continuousOn, fun h â†¦ continuous_def.2 fun _u hu â†¦ hS.isOpen_iff.2 fun s hs â†¦
    hu.preimage <| (h s hs).restrictâŸ©

theorem of_continuous_prop (h : âˆ€ f : X â†’ Prop, (âˆ€ s âˆˆ S, ContinuousOn f s) â†’ Continuous f) :
    IsCoherentWith S where
  isOpen_of_forall_induced u hu := by
    simp only [continuousOn_iff_continuous_restrict, continuous_Prop] at *
    exact h _ hu

theorem of_isClosed (h : âˆ€ t : Set X, (âˆ€ s âˆˆ S, IsClosed ((â†‘) â»Â¹' t : Set s)) â†’ IsClosed t) :
    IsCoherentWith S :=
  âŸ¨fun _t ht â†¦ isClosed_compl_iff.1 <| h _ fun s hs â†¦ (ht s hs).isClosed_complâŸ©

protected theorem enlarge {T} (hS : IsCoherentWith S) (hT : âˆ€ s âˆˆ S, âˆƒ t âˆˆ T, s âŠ† t) :
    IsCoherentWith T :=
  of_continuous_prop fun _f hf â†¦ hS.continuous_iff.2 fun s hs â†¦
    let âŸ¨t, htT, hstâŸ© := hT s hs; (hf t htT).mono hst

protected theorem mono {T} (hS : IsCoherentWith S) (hT : S âŠ† T) : IsCoherentWith T :=
  hS.enlarge fun s hs â†¦ âŸ¨s, hT hs, Subset.rflâŸ©

/-- If `X` is a sequential space
and `S` contains each set of the form `insert x (Set.range u)`
where `u : â„• â†’ X` is a sequence and `x` is its limit,
then topology on `X` is generated by its restrictions to the sets of `S`. -/
lemma of_seq [SequentialSpace X]
    (h : âˆ€ â¦ƒu : â„• â†’ Xâ¦„ â¦ƒx : Xâ¦„, Tendsto u atTop (ğ“ x) â†’ insert x (range u) âˆˆ S) :
    IsCoherentWith S := by
  refine of_isClosed fun t ht â†¦ IsSeqClosed.isClosed fun u x hut hux â†¦ ?_
  rcases isClosed_induced_iff.1 (ht _ (h hux)) with âŸ¨s, hsc, hstâŸ©
  rw [Subtype.preimage_val_eq_preimage_val_iff, Set.ext_iff] at hst
  suffices x âˆˆ s by specialize hst x; simp_all
  refine hsc.mem_of_tendsto hux <| Eventually.of_forall fun k â†¦ ?_
  specialize hst (u k)
  simp_all

/-- If each point of the space has a neighborhood from the family `S`,
then the topology is generated by its restrictions to the sets of `S`. -/
lemma of_nhds (h : âˆ€ x, âˆƒ s âˆˆ S, s âˆˆ ğ“ x) : IsCoherentWith S :=
  of_continuous_prop fun _f hf â†¦ continuous_iff_continuousAt.2 fun x â†¦
    let âŸ¨s, hsS, hsxâŸ© := h x
    (hf s hsS).continuousAt hsx

lemma of_open_cover (hSO : âˆ€ s âˆˆ S, IsOpen s) (hSU : â‹ƒâ‚€ S = univ) : IsCoherentWith S :=
  of_nhds (S := S) fun x â†¦
    let âŸ¨s, hsS, hsxâŸ© := sUnion_eq_univ_iff.mp hSU x
    âŸ¨s, hsS, hSO _ hsS |>.mem_nhds hsxâŸ©

-- lemma of_closed_cover (hSC : âˆ€ s âˆˆ S, IsClosed s) (hSU : â‹ƒ s âˆˆ S, sá¶œ = univ) :
--     IsCoherentWith S := by
--   have hSc : IsCoherentWith { sá¶œ | s âˆˆ S } := by
--     apply of_open_cover <;> simpa [sUnion_eq_iUnion, iUnion_subtype]
--   apply of_isClosed
--   intro t ht
--   simp_rw +contextual [(hSC _ _).inter_preimage_val_iff] at ht
--   rw [hSc.isClosed_iff]
--   simp
--   intro s hs
--   rw [â† isOpen_compl_iff, â† preimage_compl, (hSC s hs).isOpen_compl.inter_preimage_val_iff,
--   â† compl_union, isOpen_compl_iff]

/-- If a space `X` is coherent with an indexed family of subspaces `S` whose union is `X`, then the
 canonical inclusion from `Î£ i, S i` to `X` is a quotient map. -/
lemma isQuotientMap_sigma_desc'
    {Î¹ : Type*} {S : Î¹ â†’ Set X} (hX : IsCoherentWith (range S)) (hS : â‹ƒ i, S i = univ) :
    IsQuotientMap (ContinuousMap.sigma (fun _ â†¦ ContinuousMap.subtypeVal) : C(Î£ i, S i, X)) where
  surjective y := by
    rw [iUnion_eq_univ_iff] at hS
    obtain âŸ¨i, hxâŸ© := hS y
    use Sigma.mk i âŸ¨y, hxâŸ©
    simp
  eq_coinduced := by
    ext t
    unfold instTopologicalSpaceSigma
    simp [hX.isOpen_iff (t := t), isOpen_coinduced, isOpen_iSup_iff, preimage_preimage]

/-- If a space `X` is coherent with a set of subspaces `S` whose union is `X`, then the
 canonical inclusion from `Î£ i, S i` to `X` is a quotient map. -/
lemma isQuotientMap_sigma_desc (hX : IsCoherentWith S) (hS : â‹ƒâ‚€ S = univ) :
    IsQuotientMap (ContinuousMap.sigma (fun _ â†¦ ContinuousMap.subtypeVal) : C(Î£ (s : S), s, X)) :=
  have h : S = range Subtype.val := by simp
  IsCoherentWith.isQuotientMap_sigma_desc' (S := ((â†‘) : S â†’ Set X))
    (h â–¸ hX) (sUnion_eq_iUnion â–¸ hS)

variable {S : Set (Set X)} (hS : IsCoherentWith S) (surj : â‹ƒâ‚€ S = Set.univ) (F : âˆ€ s âˆˆ S, C(s, Y))
  (hF : âˆ€ (s) (hs : s âˆˆ S) (t) (ht : t âˆˆ S) (x : X) (hxs : x âˆˆ s) (hxt : x âˆˆ t),
    F s hs âŸ¨x, hxsâŸ© = F t ht âŸ¨x, hxtâŸ©)

/-- A family `F s` of continuous maps `C(s, Y)`, where (1) the domains `s` are taken from a set `S`
of sets in `X` which are jointly surjective and coherent with `X` and (2) the functions `F s` agree
pairwise on intersections, can be glued to construct a continuous map `C(X, Y)`. -/
noncomputable def liftCover : C(X, Y) where
  toFun := Set.liftCover ((â†‘) : S â†’ Set X) (fun s â†¦ F s s.2) (fun s t â†¦ hF s s.2 t t.2)
    (by simp [sUnion_eq_iUnion, â† surj])
  continuous_toFun := by
    rw [hS.continuous_iff, Subtype.forall']
    intro s
    rw [continuousOn_iff_continuous_restrict, Set.liftCover_restrict]
    exact (F s s.2).continuous

variable {hS surj F hF}

@[simp]
theorem liftCover_coe {s : S} (x : (s : Set X)) : hS.liftCover surj F hF x = F s s.2 x := by
  simp [IsCoherentWith.liftCover]

@[simp]
theorem liftCover_of_mem_coe {s : Set X} (hs : s âˆˆ S) (x : s) :
    hS.liftCover surj F hF x = F s hs x :=
  hS.liftCover_coe (s := âŸ¨s, hsâŸ©) x

theorem liftCover_of_mem {s : Set X} (hs : s âˆˆ S) {x : X} (hx : x âˆˆ s) :
    hS.liftCover surj F hF x = F s hs âŸ¨x, hxâŸ© :=
  hS.liftCover_of_mem_coe hs âŸ¨x, hxâŸ©

theorem preimage_liftCover (t : Set Y) :
    hS.liftCover surj F hF â»Â¹' t = â‹ƒ s : S, (â†‘) '' (F s s.2 â»Â¹' t) := by
  simp only [IsCoherentWith.liftCover, ContinuousMap.coe_mk]
  rw [Set.preimage_liftCover]

@[simp]
theorem liftCover_restrict (s : Set X) (hs : s âˆˆ S) :
    s.restrict (hS.liftCover surj F hF) = F s hs := by
  ext x; simp [hs]

variable (hS surj) in
/-- When `X` is coherent with a set of subspaces `S`, every continuous map out of `X` can be
written as a `liftCover`. -/
@[simps]
noncomputable def liftEquiv :
    { F : âˆ€ s âˆˆ S, C(s, Y) // âˆ€ s (hs : s âˆˆ S) t (ht : t âˆˆ S) x (hxs : x âˆˆ s) (hxt : x âˆˆ t),
       F s hs âŸ¨x, hxsâŸ© = F t ht âŸ¨x, hxtâŸ© } â‰ƒ C(X, Y) where
  toFun F := hS.liftCover surj F F.2
  invFun f := âŸ¨fun s hs â†¦ f.restrict s, fun s hs t ht x hxs hxt â†¦ by simpâŸ©
  left_inv := by rintro âŸ¨F, hFâŸ©; ext s hs x; simp [hs]
  right_inv f := by
    ext x
    rw [sUnion_eq_univ_iff] at surj
    obtain âŸ¨s, hs, hxsâŸ© := surj x
    simp [liftCover_of_mem hs hxs]

/-- A version of `liftEquiv_apply` that is more convenient when rewriting. -/
lemma liftEquiv_apply' : hS.liftCover surj F hF = hS.liftEquiv surj âŸ¨F, hFâŸ© := by rfl

variable {Î¹} {S : Î¹ â†’ Set X} (hS : IsCoherentWith (range S)) (surj : â‹ƒ i, S i = Set.univ)
  (Ï† : (i : Î¹) â†’ C(S i, Y))
  (hÏ† : âˆ€ i j x (hxi : x âˆˆ S i) (hxj : x âˆˆ S j), Ï† i âŸ¨x, hxiâŸ© = Ï† j âŸ¨x, hxjâŸ©)

/-- A family `Ï† i` of continuous maps `(i : Î¹) â†’ C(S i, Y)`, where (1) the domains `S i` are taken
from a family `S` of sets in `X` which are jointly surjective and coherent with `X` and (2) the
functions `Ï†` agree pairwise on intersections, can be glued to construct a continuous map
`C(X, Y)`. -/
noncomputable def liftCover' : C(X, Y) where
  toFun := Set.liftCover S (Ï† Â·) hÏ† surj
  continuous_toFun := by
    rw [hS.continuous_iff, forall_mem_range]
    intro i
    rw [continuousOn_iff_continuous_restrict, Set.liftCover_restrict]
    exact (Ï† i).continuous

variable {hS surj Ï† hÏ†}
variable {i : Î¹}

@[simp]
theorem liftCover'_coe (x : S i) : hS.liftCover' surj Ï† hÏ† x = Ï† i x := by
  simp [IsCoherentWith.liftCover']

@[simp]
theorem liftCover'_of_mem {x : X} (hx : x âˆˆ S i) : hS.liftCover' surj Ï† hÏ† x = Ï† i âŸ¨x, hxâŸ© :=
  hS.liftCover'_coe âŸ¨x, hxâŸ©

theorem preimage_liftCover' (t : Set Y) :
    hS.liftCover' surj Ï† hÏ† â»Â¹' t = â‹ƒ i, (â†‘) '' (Ï† i â»Â¹' t) := by
  simp only [IsCoherentWith.liftCover', ContinuousMap.coe_mk]
  rw [Set.preimage_liftCover]

@[simp]
theorem liftCover'_restrict : (S i).restrict (hS.liftCover' surj Ï† hÏ†) = Ï† i := by ext x; simp

variable (hS surj) in
/-- When `X` is coherent with a family of subspaces `S i`, every continuous map out of `X` can be
written as a `liftCover'`. -/
@[simps]
noncomputable def liftEquiv' :
    { Ï† : (i : Î¹) â†’ C(S i, Y) // âˆ€ i j x (hxi : x âˆˆ S i) (hxj : x âˆˆ S j),
       Ï† i âŸ¨x, hxiâŸ© = Ï† j âŸ¨x, hxjâŸ© } â‰ƒ C(X, Y) where
  toFun Ï† := hS.liftCover' surj Ï† Ï†.2
  invFun f := âŸ¨fun i â†¦ f.restrict (S i), fun i j x hxi hxj â†¦ by simpâŸ©
  left_inv := by rintro âŸ¨Ï†, hÏ†âŸ©; ext i x; simp
  right_inv f := by
    ext x
    rw [iUnion_eq_univ_iff] at surj
    obtain âŸ¨i, hxiâŸ© := surj x
    simp [liftCover'_of_mem hxi]

/-- A version of `liftEquiv'_apply` that is more convenient when rewriting. -/
lemma liftEquiv'_apply' : hS.liftCover' surj Ï† hÏ† = hS.liftEquiv' surj âŸ¨Ï†, hÏ†âŸ© := by rfl

end Topology.IsCoherentWith
