/-
Copyright (c) 2024 Ya√´l Dillies. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Ya√´l Dillies
-/
import Mathlib.Order.BooleanSubalgebra
import Mathlib.Topology.Compactness.Bases
import Mathlib.Topology.LocalAtTarget
import Mathlib.Topology.QuasiSeparated
import Mathlib.Topology.Spectral.Hom
import Mathlib.Topology.Spectral.Prespectral

/-!
# Constructible sets

This file defines constructible sets, which are morally sets in a topological space which we can
make out of finite unions and intersections of open and closed sets.

Precisely, constructible sets are the Boolean subalgebra generated by open retrocompact sets,
where a set is retrocompact if its intersection with every compact open set is compact.
In a locally Noetherian space, all sets are retrocompact, in which case this Boolean subalgebra is
simply the one generated by the open sets.

Constructible sets are useful because the image of a constructible set under a finitely presented
morphism of schemes is a constructible set (and this is *not* true at the level of varieties).

## Main declarations

* `IsRetrocompact`: Predicate for a set to be retrocompact, namely to have its intersection with
  every compact open be compact.
* `IsConstructible`: Predicate for a set to be constructible, namely to belong to the Boolean
  subalgebra generated by open retrocompact sets.
* `IsLocallyConstructible`: Predicate for a set to be locally constructible, namely to be
  partitionable along an open cover such that each of its parts is constructible in the
  respective open subspace.
-/

open Set TopologicalSpace Topology
open scoped Set.Notation

variable {Œπ : Sort*} {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : X ‚Üí Y}
  {s t U : Set X} {a : X}

/-! ### retrocompact sets -/

/-- A retrocompact set is a set whose intersection with every compact open is compact. -/
@[stacks 005A]
def IsRetrocompact (s : Set X) : Prop := ‚àÄ ‚¶ÉU‚¶Ñ, IsCompact U ‚Üí IsOpen U ‚Üí IsCompact (s ‚à© U)

@[simp] lemma IsRetrocompact.empty : IsRetrocompact (‚àÖ : Set X) := by simp [IsRetrocompact]
@[simp] lemma IsRetrocompact.univ : IsRetrocompact (univ : Set X) := by
  simp +contextual [IsRetrocompact]

@[simp] lemma IsRetrocompact.singleton : IsRetrocompact {a} :=
  fun _ _ _ ‚Ü¶ Subsingleton.singleton_inter.isCompact

lemma IsRetrocompact.union (hs : IsRetrocompact s) (ht : IsRetrocompact t) :
    IsRetrocompact (s ‚à™ t : Set X) :=
  fun _U hUcomp hUopen ‚Ü¶ union_inter_distrib_right .. ‚ñ∏ (hs hUcomp hUopen).union (ht hUcomp hUopen)

private lemma supClosed_isRetrocompact : SupClosed {s : Set X | IsRetrocompact s} :=
  fun _s hs _t ht ‚Ü¶ hs.union ht

lemma IsRetrocompact.finsetSup {Œπ : Type*} {s : Finset Œπ} {t : Œπ ‚Üí Set X}
    (ht : ‚àÄ i ‚àà s, IsRetrocompact (t i)) : IsRetrocompact (s.sup t) := by
  induction s using Finset.cons_induction with
  | empty => simp
  | cons i s ih hi =>
    rw [Finset.sup_cons]
    exact (ht _ <| by simp).union <| hi <| Finset.forall_of_forall_cons ht

set_option linter.docPrime false in
lemma IsRetrocompact.finsetSup' {Œπ : Type*} {s : Finset Œπ} {hs} {t : Œπ ‚Üí Set X}
    (ht : ‚àÄ i ‚àà s, IsRetrocompact (t i)) : IsRetrocompact (s.sup' hs t) := by
  rw [Finset.sup'_eq_sup]; exact .finsetSup ht

lemma IsRetrocompact.iUnion [Finite Œπ] {f : Œπ ‚Üí Set X} (hf : ‚àÄ i, IsRetrocompact (f i)) :
    IsRetrocompact (‚ãÉ i, f i) := supClosed_isRetrocompact.iSup_mem .empty hf

lemma IsRetrocompact.sUnion {S : Set (Set X)} (hS : S.Finite) (hS' : ‚àÄ s ‚àà S, IsRetrocompact s) :
    IsRetrocompact (‚ãÉ‚ÇÄ S) := supClosed_isRetrocompact.sSup_mem hS .empty hS'

lemma IsRetrocompact.biUnion {Œπ : Type*} {f : Œπ ‚Üí Set X} {t : Set Œπ} (ht : t.Finite)
    (hf : ‚àÄ i ‚àà t, IsRetrocompact (f i)) : IsRetrocompact (‚ãÉ i ‚àà t, f i) :=
  supClosed_isRetrocompact.biSup_mem ht .empty hf

section T2Space
variable [T2Space X]

lemma IsRetrocompact.inter (hs : IsRetrocompact s) (ht : IsRetrocompact t) :
    IsRetrocompact (s ‚à© t : Set X) :=
  fun _U hUcomp hUopen ‚Ü¶ inter_inter_distrib_right .. ‚ñ∏ (hs hUcomp hUopen).inter (ht hUcomp hUopen)

private lemma infClosed_isRetrocompact : InfClosed {s : Set X | IsRetrocompact s} :=
  fun _s hs _t ht ‚Ü¶ hs.inter ht

lemma IsRetrocompact.finsetInf {Œπ : Type*} {s : Finset Œπ} {t : Œπ ‚Üí Set X}
    (ht : ‚àÄ i ‚àà s, IsRetrocompact (t i)) : IsRetrocompact (s.inf t) := by
  induction s using Finset.cons_induction with
  | empty => simp
  | cons i s ih hi =>
    rw [Finset.inf_cons]
    exact (ht _ <| by simp).inter <| hi <| Finset.forall_of_forall_cons ht

set_option linter.docPrime false in
lemma IsRetrocompact.finsetInf' {Œπ : Type*} {s : Finset Œπ} {hs} {t : Œπ ‚Üí Set X}
    (ht : ‚àÄ i ‚àà s, IsRetrocompact (t i)) : IsRetrocompact (s.inf' hs t) := by
  rw [Finset.inf'_eq_inf]; exact .finsetInf ht

lemma IsRetrocompact.iInter [Finite Œπ] {f : Œπ ‚Üí Set X} (hf : ‚àÄ i, IsRetrocompact (f i)) :
    IsRetrocompact (‚ãÇ i, f i) := infClosed_isRetrocompact.iInf_mem .univ hf

lemma IsRetrocompact.sInter {S : Set (Set X)} (hS : S.Finite) (hS' : ‚àÄ s ‚àà S, IsRetrocompact s) :
    IsRetrocompact (‚ãÇ‚ÇÄ S) := infClosed_isRetrocompact.sInf_mem hS .univ hS'

lemma IsRetrocompact.biInter {Œπ : Type*} {f : Œπ ‚Üí Set X} {t : Set Œπ} (ht : t.Finite)
    (hf : ‚àÄ i ‚àà t, IsRetrocompact (f i)) : IsRetrocompact (‚ãÇ i ‚àà t, f i) :=
  infClosed_isRetrocompact.biInf_mem ht .univ hf

end T2Space

lemma IsRetrocompact.inter_isOpen (hs : IsRetrocompact s) (ht : IsRetrocompact t)
    (htopen : IsOpen t) : IsRetrocompact (s ‚à© t : Set X) :=
  fun _U hUcomp hUopen ‚Ü¶ inter_assoc .. ‚ñ∏ hs (ht hUcomp hUopen) (htopen.inter hUopen)

lemma IsRetrocompact.isOpen_inter (hs : IsRetrocompact s) (ht : IsRetrocompact t)
    (hsopen : IsOpen s) : IsRetrocompact (s ‚à© t : Set X) :=
  inter_comm .. ‚ñ∏ ht.inter_isOpen hs hsopen

lemma IsRetrocompact_iff_isSpectralMap_subtypeVal :
    IsRetrocompact s ‚Üî IsSpectralMap (Subtype.val : s ‚Üí X) := by
  refine ‚ü®fun hs ‚Ü¶ ‚ü®continuous_subtype_val, fun t htopen htcomp ‚Ü¶ ?_‚ü©, fun hs t htcomp htopen ‚Ü¶ ?_‚ü©
  ¬∑ rw [IsEmbedding.subtypeVal.isCompact_iff, image_preimage_eq_inter_range,
      Subtype.range_coe_subtype, setOf_mem_eq, inter_comm]
    exact hs htcomp htopen
  ¬∑ simpa using (hs.isCompact_preimage_of_isOpen htopen htcomp).image continuous_subtype_val

@[stacks 005B]
lemma IsRetrocompact.image_of_isEmbedding (hs : IsRetrocompact s) (hfemb : IsEmbedding f)
    (hfcomp : IsRetrocompact (range f)) : IsRetrocompact (f '' s) := by
  rintro U hUcomp hUopen
  rw [‚Üê image_inter_preimage, ‚Üê hfemb.isCompact_iff]
  refine hs ?_ <| hUopen.preimage hfemb.continuous
  rw [hfemb.isCompact_iff, image_preimage_eq_inter_range, inter_comm]
  exact hfcomp hUcomp hUopen

@[stacks 005J "Extracted from the proof"]
lemma IsRetrocompact.preimage_of_isOpenEmbedding {s : Set Y} (hf : IsOpenEmbedding f)
    (hs : IsRetrocompact s) : IsRetrocompact (f ‚Åª¬π' s) := by
  rintro U hUcomp hUopen
  rw [hf.isCompact_iff, image_preimage_inter]
  exact hs (hUcomp.image hf.continuous) <| hf.isOpenMap _ hUopen

@[stacks 09YE "Extracted from the proof"]
lemma IsRetrocompact.preimage_of_isClosedEmbedding {s : Set Y} (hf : IsClosedEmbedding f)
    (hf' : IsCompact (range f)·∂ú) (hs : IsRetrocompact s) : IsRetrocompact (f ‚Åª¬π' s) := by
  rintro U hUcomp hUopen
  have hfUopen : IsOpen (f '' U ‚à™ (range f)·∂ú) := by
    simpa [‚Üê range_diff_image hf.injective, sdiff_eq, compl_inter, union_comm]
      using (hf.isClosedMap _ hUopen.isClosed_compl).isOpen_compl
  have hfUcomp : IsCompact (f '' U ‚à™ (range f)·∂ú) := (hUcomp.image hf.continuous).union hf'
  simpa [inter_union_distrib_left, inter_left_comm, inter_eq_right.2 (image_subset_range ..),
    hf.isCompact_iff, image_preimage_inter] using (hs hfUcomp hfUopen).inter_left hf.isClosed_range

/-! ### Constructible sets -/

namespace Topology

/-- A constructible set is a set that can be written as the
finite union/finite intersection/complement of open retrocompact sets.

In other words, constructible sets form the Boolean subalgebra generated by open retrocompact sets.
-/
def IsConstructible (s : Set X) : Prop :=
  s ‚àà BooleanSubalgebra.closure {U | IsOpen U ‚àß IsRetrocompact U}

@[simp]
protected lemma IsConstructible.empty : IsConstructible (‚àÖ : Set X) := BooleanSubalgebra.bot_mem

@[simp]
protected lemma IsConstructible.univ : IsConstructible (univ : Set X) := BooleanSubalgebra.top_mem

lemma IsConstructible.union : IsConstructible s ‚Üí IsConstructible t ‚Üí IsConstructible (s ‚à™ t) :=
  BooleanSubalgebra.sup_mem

lemma IsConstructible.inter : IsConstructible s ‚Üí IsConstructible t ‚Üí IsConstructible (s ‚à© t) :=
  BooleanSubalgebra.inf_mem

lemma IsConstructible.sdiff : IsConstructible s ‚Üí IsConstructible t ‚Üí IsConstructible (s \ t) :=
  BooleanSubalgebra.sdiff_mem

lemma IsConstructible.himp : IsConstructible s ‚Üí IsConstructible t ‚Üí IsConstructible (s ‚á® t) :=
  BooleanSubalgebra.himp_mem

@[simp] lemma isConstructible_compl : IsConstructible s·∂ú ‚Üî IsConstructible s :=
  BooleanSubalgebra.compl_mem_iff

alias ‚ü®IsConstructible.of_compl, IsConstructible.compl‚ü© := isConstructible_compl

lemma IsConstructible.iUnion [Finite Œπ] {f : Œπ ‚Üí Set X} (hf : ‚àÄ i, IsConstructible (f i)) :
    IsConstructible (‚ãÉ i, f i) := BooleanSubalgebra.iSup_mem hf

lemma IsConstructible.iInter [Finite Œπ] {f : Œπ ‚Üí Set X} (hf : ‚àÄ i, IsConstructible (f i)) :
    IsConstructible (‚ãÇ i, f i) := BooleanSubalgebra.iInf_mem hf

lemma IsConstructible.sUnion {S : Set (Set X)} (hS : S.Finite) (hS' : ‚àÄ s ‚àà S, IsConstructible s) :
    IsConstructible (‚ãÉ‚ÇÄ S) := BooleanSubalgebra.sSup_mem hS hS'

lemma IsConstructible.sInter {S : Set (Set X)} (hS : S.Finite) (hS' : ‚àÄ s ‚àà S, IsConstructible s) :
    IsConstructible (‚ãÇ‚ÇÄ S) := BooleanSubalgebra.sInf_mem hS hS'

lemma IsConstructible.biUnion {Œπ : Type*} {f : Œπ ‚Üí Set X} {t : Set Œπ} (ht : t.Finite)
    (hf : ‚àÄ i ‚àà t, IsConstructible (f i)) : IsConstructible (‚ãÉ i ‚àà t, f i) :=
  BooleanSubalgebra.biSup_mem ht hf

lemma IsConstructible.biInter {Œπ : Type*} {f : Œπ ‚Üí Set X} {t : Set Œπ} (ht : t.Finite)
    (hf : ‚àÄ i ‚àà t, IsConstructible (f i)) : IsConstructible (‚ãÇ i ‚àà t, f i) :=
  BooleanSubalgebra.biInf_mem ht hf

lemma _root_.IsRetrocompact.isConstructible (hUopen : IsOpen U) (hUcomp : IsRetrocompact U) :
    IsConstructible U := BooleanSubalgebra.subset_closure ‚ü®hUopen, hUcomp‚ü©

/-- An induction principle for constructible sets. If `p` holds for all open retrocompact
sets, and is preserved under union and complement, then `p` holds for all constructible sets. -/
@[elab_as_elim]
lemma IsConstructible.empty_union_induction {p : ‚àÄ s : Set X, IsConstructible s ‚Üí Prop}
    (open_retrocompact : ‚àÄ U (hUopen : IsOpen U) (hUcomp : IsRetrocompact U),
      p U (BooleanSubalgebra.subset_closure ‚ü®hUopen, hUcomp‚ü©))
    (union : ‚àÄ s hs t ht, p s hs ‚Üí p t ht ‚Üí p (s ‚à™ t) (hs.union ht))
    (compl : ‚àÄ s hs, p s hs ‚Üí p s·∂ú hs.compl) {s} (hs : IsConstructible s) : p s hs := by
  induction hs using BooleanSubalgebra.closure_bot_sup_induction with
  | mem U hU => exact open_retrocompact _ hU.1 hU.2
  | bot => exact open_retrocompact _ isOpen_empty .empty
  | sup s hs t ht hs' ht' => exact union _ _ _ _ hs' ht'
  | compl s hs hs' => exact compl _ _ hs'

/-- If `f` is continuous and is such that preimages of open retrocompact sets are retrocompact,
then preimages of constructible sets are constructible. -/
@[stacks 005I]
lemma IsConstructible.preimage {s : Set Y} (hfcont : Continuous f)
    (hf : ‚àÄ s, IsOpen s ‚Üí IsRetrocompact s ‚Üí IsRetrocompact (f ‚Åª¬π' s)) (hs : IsConstructible s) :
    IsConstructible (f ‚Åª¬π' s) := by
  induction hs using IsConstructible.empty_union_induction with
  | open_retrocompact U hUopen hUcomp =>
    exact (hf _ hUopen hUcomp).isConstructible <| hUopen.preimage hfcont
  | union s hs t ht hs' ht' => rw [preimage_union]; exact hs'.union ht'
  | compl s hs hs' => rw [preimage_compl]; exact hs'.compl

@[stacks 005J]
lemma IsConstructible.preimage_of_isOpenEmbedding {s : Set Y} (hf : IsOpenEmbedding f)
    (hs : IsConstructible s) : IsConstructible (f ‚Åª¬π' s) :=
  hs.preimage hf.continuous fun _t _ ht ‚Ü¶ ht.preimage_of_isOpenEmbedding hf

@[stacks 09YE]
lemma IsConstructible.preimage_of_isClosedEmbedding {s : Set Y} (hf : IsClosedEmbedding f)
    (hf' : IsCompact (range f)·∂ú) (hs : IsConstructible s) : IsConstructible (f ‚Åª¬π' s) :=
  hs.preimage hf.continuous fun _t _ ht ‚Ü¶ ht.preimage_of_isClosedEmbedding hf hf'

@[stacks 09YD]
lemma IsConstructible.image_of_isOpenEmbedding (hfopen : IsOpenEmbedding f)
    (hfcomp : IsRetrocompact (range f)) (hs : IsConstructible s) : IsConstructible (f '' s) := by
  induction hs using IsConstructible.empty_union_induction with
  | open_retrocompact U hUopen hUcomp =>
    exact (hUcomp.image_of_isEmbedding hfopen.isEmbedding hfcomp).isConstructible <|
      hfopen.isOpenMap _ hUopen
  | union s hs t ht hs' ht' => rw [image_union]; exact hs'.union ht'
  | compl s hs hs' =>
    rw [‚Üê range_diff_image hfopen.injective]
    exact (hfcomp.isConstructible hfopen.isOpen_range).sdiff hs'

@[stacks 09YG]
lemma IsConstructible.image_of_isClosedEmbedding (hf : IsClosedEmbedding f)
    (hfcomp : IsRetrocompact (range f)·∂ú) (hs : IsConstructible s) : IsConstructible (f '' s) := by
  induction hs using IsConstructible.empty_union_induction with
  | open_retrocompact U hUopen hUcomp =>
    have hfU : IsOpen (f '' U ‚à™ (range f)·∂ú) := by
      simpa [‚Üê range_diff_image hf.injective, sdiff_eq, compl_inter, union_comm]
        using (hf.isClosedMap _ hUopen.isClosed_compl).isOpen_compl
    suffices h : IsRetrocompact (f '' U ‚à™ (range f)·∂ú) by
      simpa [union_inter_distrib_right, inter_eq_left.2 (image_subset_range ..)]
        using (h.isConstructible hfU).sdiff (hfcomp.isConstructible hf.isClosed_range.isOpen_compl)
    rintro V hVcomp hVopen
    rw [union_inter_distrib_right, ‚Üê image_inter_preimage]
    exact ((hUcomp (hf.isCompact_preimage hVcomp) (hVopen.preimage hf.continuous)).image
      hf.continuous).union <| hfcomp hVcomp hVopen
  | union s hs t ht hs' ht' => rw [image_union]; exact hs'.union ht'
  | compl s hs hs' =>
    rw [‚Üê range_diff_image hf.injective]
    exact (hfcomp.isConstructible hf.isClosed_range.isOpen_compl).of_compl.sdiff hs'

lemma isConstructible_preimage_iff_of_isOpenEmbedding {s : Set Y} (hf : IsOpenEmbedding f)
    (hfcomp : IsRetrocompact (range f)) (hsf : s ‚äÜ range f) :
    IsConstructible (f ‚Åª¬π' s) ‚Üî IsConstructible s where
  mp hs := by simpa [image_preimage_eq_range_inter, inter_eq_right.2 hsf]
    using hs.image_of_isOpenEmbedding hf hfcomp
  mpr := .preimage_of_isOpenEmbedding hf

section CompactSpace
variable [CompactSpace X] {P : ‚àÄ s : Set X, IsConstructible s ‚Üí Prop} {B : Set (Set X)}
  {b : Œπ ‚Üí Set X}

lemma _root_.IsRetrocompact.isCompact (hs : IsRetrocompact s) : IsCompact s := by
  simpa using hs CompactSpace.isCompact_univ

variable [QuasiSeparatedSpace X]

omit [CompactSpace X] in
lemma _root_.IsCompact.isRetrocompact (hU' : IsCompact U) (hU : IsOpen U) : IsRetrocompact U :=
  fun _ hV' hV ‚Ü¶ hU'.inter_of_isOpen hV' hU hV

omit [CompactSpace X] in
lemma _root_.IsCompact.isConstructible (hU' : IsCompact U) (hU : IsOpen U) : IsConstructible U :=
  (hU'.isRetrocompact hU).isConstructible hU

@[stacks 0069 "Iff form of (2). Note that Stacks doesn't define quasi-separated spaces."]
lemma _root_.QuasiSeparatedSpace.isRetrocompact_iff_isCompact
    (hU : IsOpen U) : IsRetrocompact U ‚Üî IsCompact U :=
  ‚ü®IsRetrocompact.isCompact, (IsCompact.isRetrocompact ¬∑ hU)‚ü©

@[elab_as_elim]
lemma IsConstructible.induction_of_isTopologicalBasis {Œπ : Type*} [Nonempty Œπ] (b : Œπ ‚Üí Set X)
    (basis : IsTopologicalBasis (range b)) (isCompact_basis : ‚àÄ i, IsCompact (b i))
    (sdiff : ‚àÄ i s (hs : Set.Finite s), P (b i \ ‚ãÉ j ‚àà s, b j)
      (((isCompact_basis _).isConstructible (basis.isOpen ‚ü®i, rfl‚ü©)).sdiff <| .biUnion hs fun _ _ ‚Ü¶
        ((isCompact_basis _).isConstructible (basis.isOpen ‚ü®_, rfl‚ü©))))
    (union : ‚àÄ s hs t ht, P s hs ‚Üí P t ht ‚Üí P (s ‚à™ t) (hs.union ht))
    (s : Set X) (hs : IsConstructible s) : P s hs := by
  induction s, hs using BooleanSubalgebra.closure_sdiff_sup_induction with
  | isSublattice =>
    exact ‚ü®fun s hs t ht ‚Ü¶ ‚ü®hs.1.union ht.1, hs.2.union ht.2‚ü©,
      fun s hs t ht ‚Ü¶ ‚ü®hs.1.inter ht.1, hs.2.inter_isOpen ht.2 ht.1‚ü©‚ü©
  | bot_mem => exact ‚ü®isOpen_empty, .empty‚ü©
  | top_mem => exact ‚ü®isOpen_univ, .univ‚ü©
  | sdiff U hU V hV =>
    have := isCompact_open_iff_eq_finite_iUnion_of_isTopologicalBasis _ basis isCompact_basis
    obtain ‚ü®s, hs, rfl‚ü© := (this _).1 ‚ü®hU.2.isCompact, hU.1‚ü©
    obtain ‚ü®t, ht, rfl‚ü© := (this _).1 ‚ü®hV.2.isCompact, hV.1‚ü©
    simp_rw [iUnion_diff]
    induction s, hs using Set.Finite.induction_on with
    | empty => simpa using sdiff (Classical.arbitrary _) {Classical.arbitrary _}
    | @insert i s hi hs ih =>
      simp_rw [biUnion_insert]
      exact union _ _ _
        (.biUnion hs fun i _ ‚Ü¶ ((isCompact_basis _).isConstructible (basis.isOpen ‚ü®i, rfl‚ü©)).sdiff
          <| .biUnion ht fun j _ ‚Ü¶ (isCompact_basis _).isConstructible (basis.isOpen ‚ü®_, rfl‚ü©))
        (sdiff _ _ ht)
        (ih ‚ü®isOpen_biUnion fun  _ _ ‚Ü¶ basis.isOpen ‚ü®_, rfl‚ü©, .biUnion hs
          fun i _ ‚Ü¶ (isCompact_basis _).isRetrocompact (basis.isOpen ‚ü®i, rfl‚ü©)‚ü©)
  | sup s _ t _ hs' ht' => exact union _ _ _ _ hs' ht'

end CompactSpace

/-! ### Locally constructible sets -/

/-- A set in a topological space is locally constructible, if every point has a neighborhood on
which the set is constructible. -/
@[stacks 005G]
def IsLocallyConstructible (s : Set X) : Prop := ‚àÄ x, ‚àÉ U ‚àà ùìù x, IsOpen U ‚àß IsConstructible (U ‚Üì‚à© s)

lemma IsConstructible.isLocallyConstructible (hs : IsConstructible s) : IsLocallyConstructible s :=
  fun _ ‚Ü¶ ‚ü®univ, by simp, by simp,
    (isConstructible_preimage_iff_of_isOpenEmbedding isOpen_univ.isOpenEmbedding_subtypeVal
      (by simp) (by simp)).2 hs‚ü©

lemma _root_.IsRetrocompact.isLocallyConstructible (hUopen : IsOpen U) (hUcomp : IsRetrocompact U) :
    IsLocallyConstructible U := (hUcomp.isConstructible hUopen).isLocallyConstructible

@[simp] protected lemma IsLocallyConstructible.empty : IsLocallyConstructible (‚àÖ : Set X) :=
  IsConstructible.empty.isLocallyConstructible

@[simp] protected lemma IsLocallyConstructible.univ : IsLocallyConstructible (univ : Set X) :=
  IsConstructible.univ.isLocallyConstructible

lemma IsLocallyConstructible.inter (hs : IsLocallyConstructible s) (ht : IsLocallyConstructible t) :
    IsLocallyConstructible (s ‚à© t) := by
  rintro x
  obtain ‚ü®U, hxU, hU, hsU‚ü© := hs x
  obtain ‚ü®V, hxV, hV, htV‚ü© := ht x
  refine ‚ü®U ‚à© V, Filter.inter_mem hxU hxV, hU.inter hV, ?_‚ü©
  change IsConstructible
    (inclusion inter_subset_left ‚Åª¬π' (U ‚Üì‚à© s) ‚à© inclusion inter_subset_right ‚Åª¬π' (V ‚Üì‚à© t))
  exact .inter (hsU.preimage_of_isOpenEmbedding <| .inclusion _ <|
      .preimage continuous_subtype_val <| hU.inter hV)
    (htV.preimage_of_isOpenEmbedding <| .inclusion _ <|
      .preimage continuous_subtype_val <| hU.inter hV )

lemma IsLocallyConstructible.finsetInf {Œπ : Type*} {s : Finset Œπ} {t : Œπ ‚Üí Set X}
    (ht : ‚àÄ i ‚àà s, IsLocallyConstructible (t i)) : IsLocallyConstructible (s.inf t) := by
  induction s using Finset.cons_induction with
  | empty => simp
  | cons i s ih hi =>
    rw [Finset.inf_cons]
    exact (ht _ <| by simp).inter <| hi <| Finset.forall_of_forall_cons ht

set_option linter.docPrime false in
lemma IsLocallyConstructible.finsetInf' {Œπ : Type*} {s : Finset Œπ} {hs} {t : Œπ ‚Üí Set X}
    (ht : ‚àÄ i ‚àà s, IsLocallyConstructible (t i)) : IsLocallyConstructible (s.inf' hs t) := by
  rw [Finset.inf'_eq_inf]; exact .finsetInf ht

private lemma infClosed_isLocallyConstructible : InfClosed {s : Set X | IsLocallyConstructible s} :=
  fun _s hs _t ht ‚Ü¶ hs.inter ht

lemma IsLocallyConstructible.iInter [Finite Œπ] {f : Œπ ‚Üí Set X}
    (hf : ‚àÄ i, IsLocallyConstructible (f i)) : IsLocallyConstructible (‚ãÇ i, f i) :=
  infClosed_isLocallyConstructible.iInf_mem .univ hf

lemma IsLocallyConstructible.sInter {S : Set (Set X)} (hS : S.Finite)
    (hS' : ‚àÄ s ‚àà S, IsLocallyConstructible s) : IsLocallyConstructible (‚ãÇ‚ÇÄ S) :=
  infClosed_isLocallyConstructible.sInf_mem hS .univ hS'

lemma IsLocallyConstructible.union (hs : IsLocallyConstructible s) (ht : IsLocallyConstructible t) :
    IsLocallyConstructible (s ‚à™ t) := by
  rintro x
  obtain ‚ü®U, hxU, hU, hsU‚ü© := hs x
  obtain ‚ü®V, hxV, hV, htV‚ü© := ht x
  refine ‚ü®U ‚à© V, Filter.inter_mem hxU hxV, hU.inter hV, ?_‚ü©
  have : (U ‚à© V) ‚Üì‚à© (s ‚à™ t) =
      inclusion inter_subset_left ‚Åª¬π' (U ‚Üì‚à© s) ‚à™ inclusion inter_subset_right ‚Åª¬π' (V ‚Üì‚à© t) := by
    ext; simp
  rw [this]
  exact .union (hsU.preimage_of_isOpenEmbedding <| .inclusion _ <|
      .preimage continuous_subtype_val <| hU.inter hV)
    (htV.preimage_of_isOpenEmbedding <| .inclusion _ <|
      .preimage continuous_subtype_val <| hU.inter hV )

lemma IsLocallyConstructible.iUnion [Finite Œπ] {f : Œπ ‚Üí Set X}
    (hf : ‚àÄ i, IsLocallyConstructible (f i)) : IsLocallyConstructible (‚ãÉ i, f i) :=
  SupClosed.iSup_mem (s := {s | IsLocallyConstructible s}) (fun _ h‚ÇÅ _ ‚Ü¶ h‚ÇÅ.union) .empty hf

lemma IsLocallyConstructible.biUnion {Œπ : Type*} {f : Œπ ‚Üí Set X} {s : Set Œπ} (hs : s.Finite)
    (hf : ‚àÄ i ‚àà s, IsLocallyConstructible (f i)) : IsLocallyConstructible (‚ãÉ i ‚àà s, f i) :=
  SupClosed.biSup_mem (s := {s | IsLocallyConstructible s}) (fun _ h‚ÇÅ _ ‚Ü¶ h‚ÇÅ.union) hs .empty hf

lemma IsLocallyConstructible.sUnion {S : Set (Set X)} (hS : S.Finite)
    (hS' : ‚àÄ s ‚àà S, IsLocallyConstructible s) : IsLocallyConstructible (‚ãÉ‚ÇÄ S) :=
  SupClosed.sSup_mem (s := {s | IsLocallyConstructible s}) (fun _ h‚ÇÅ _ ‚Ü¶ h‚ÇÅ.union) hS .empty hS'

lemma IsLocallyConstructible.preimage_of_isOpenEmbedding {s : Set Y}
    (hs : IsLocallyConstructible s) (hf : IsOpenEmbedding f) :
    IsLocallyConstructible (f ‚Åª¬π' s) := by
  intro x
  obtain ‚ü®U, hxU, hU, H‚ü© := hs (f x)
  exact ‚ü®f ‚Åª¬π' U, hf.continuous.continuousAt.preimage_mem_nhds hxU, hU.preimage hf.continuous,
    (H.preimage_of_isOpenEmbedding (hf.restrictPreimage _) :)‚ü©

lemma IsLocallyConstructible.isConstructible_of_subset_of_isCompact
    [PrespectralSpace X] [QuasiSeparatedSpace X]
    (hs : IsLocallyConstructible s) (hst : s ‚äÜ t) (ht : IsCompact t) :
    IsConstructible s := by
  have (x : _) : ‚àÉ U, IsOpen U ‚àß IsCompact U ‚àß x ‚àà U ‚àß IsConstructible (U ‚à© s) :=
    have ‚ü®U, hxU, hU, hUs‚ü© := hs x
    have ‚ü®V, ‚ü®hV‚ÇÅ, hV‚ÇÇ‚ü©, hxV, hVU‚ü© := PrespectralSpace.isTopologicalBasis.mem_nhds_iff.mp hxU
    have : IsConstructible (V ‚Üì‚à© s) :=
      (hUs.preimage_of_isOpenEmbedding (IsOpenEmbedding.id.restrict hVU hV‚ÇÅ):)
    have : IsConstructible (V ‚à© s) := by
      have := this.image_of_isOpenEmbedding hV‚ÇÅ.isOpenEmbedding_subtypeVal
        (by simpa using hV‚ÇÇ.isRetrocompact hV‚ÇÅ)
      rwa [Subtype.image_preimage_coe] at this
    ‚ü®V, hV‚ÇÅ, hV‚ÇÇ, hxV, this‚ü©
  choose U hU hU' hxU hUs using this
  obtain ‚ü®œÉ, hœÉ, htœÉ‚ü© := ht.elim_nhds_subcover U (fun x _ ‚Ü¶ (hU x).mem_nhds (hxU x))
  convert IsConstructible.biUnion œÉ.finite_toSet (fun x _ ‚Ü¶ hUs x)
  apply subset_antisymm
  ¬∑ rw [‚Üê Set.iUnion‚ÇÇ_inter, Set.subset_inter_iff]
    exact ‚ü®hst.trans htœÉ, subset_rfl‚ü©
  ¬∑ exact Set.iUnion‚ÇÇ_subset fun _ _ ‚Ü¶ Set.inter_subset_right

lemma IsLocallyConstructible.isConstructible
    [PrespectralSpace X] [QuasiSeparatedSpace X] [CompactSpace X]
    (hs : IsLocallyConstructible s) :
    IsConstructible s :=
  hs.isConstructible_of_subset_of_isCompact s.subset_univ isCompact_univ

lemma IsLocallyConstructible.inter_of_isOpen_isCompact
    [PrespectralSpace X] [QuasiSeparatedSpace X]
    (hs : IsLocallyConstructible s) (ht : IsOpen t) (ht' : IsCompact t) :
    IsConstructible (s ‚à© t) :=
  (hs.inter (ht'.isConstructible ht).isLocallyConstructible).isConstructible_of_subset_of_isCompact
    Set.inter_subset_right ht'

variable {Œπ : Type*} {U : Œπ ‚Üí Opens X}

lemma IsLocallyConstructible.of_isOpenCover
    (hU : IsOpenCover U) (H : ‚àÄ i, IsLocallyConstructible ((U i : Set X) ‚Üì‚à© s)) :
    IsLocallyConstructible s := by
  intro x
  have ‚ü®i, hi‚ü© := hU.exists_mem x
  have ‚ü®V, hVx, hV, hV'‚ü© := H i ‚ü®x, hi‚ü©
  refine ‚ü®_, (U i).2.isOpenEmbedding_subtypeVal.image_mem_nhds.mpr hVx,
      (U i).2.isOpenMap_subtype_val _ hV, ?_‚ü©
  let e : V ‚âÉ‚Çú Subtype.val '' V :=
    (Equiv.Set.image _ V Subtype.val_injective).toHomeomorphOfIsInducing
      ((U i).2.isOpenEmbedding_subtypeVal.restrict (by simp [MapsTo]) hV).isInducing
  convert hV'.preimage_of_isOpenEmbedding e.symm.isOpenEmbedding
  ext ‚ü®_, x, hx, rfl‚ü©
  simp [e, Equiv.toHomeomorphOfIsInducing]

/-- A variant that requires constructible in the ambient space.
This is as strong as the unprimed version only when the open cover consists of retrocompact sets. -/
lemma IsLocallyConstructible.of_isOpenCover'
    (hU : IsOpenCover U) (H : ‚àÄ i, IsLocallyConstructible (s ‚à© U i)) :
    IsLocallyConstructible s :=
  .of_isOpenCover hU fun i ‚Ü¶ by
    rw [‚Üê Subtype.preimage_coe_inter_self]
    exact (H i).preimage_of_isOpenEmbedding (U i).2.isOpenEmbedding_subtypeVal

lemma IsLocallyConstructible.iff_of_isOpenCover
    (hU : IsOpenCover U) :
    IsLocallyConstructible s ‚Üî ‚àÄ i, IsLocallyConstructible ((U i : Set X) ‚Üì‚à© s) :=
  ‚ü®fun H i ‚Ü¶ H.preimage_of_isOpenEmbedding (U i).2.isOpenEmbedding_subtypeVal,
    fun H ‚Ü¶ .of_isOpenCover hU H‚ü©

lemma IsLocallyConstructible.iff_isConstructible_of_isOpenCover
    [PrespectralSpace X] [QuasiSeparatedSpace X]
    (hU : IsOpenCover U) (hU' : ‚àÄ i, IsCompact (U i : Set X)) :
    IsLocallyConstructible s ‚Üî ‚àÄ i, IsConstructible (s ‚à© U i) :=
  ‚ü®fun H i ‚Ü¶ H.inter_of_isOpen_isCompact (U i).2 (hU' i),
    fun H ‚Ü¶ .of_isOpenCover' hU fun i ‚Ü¶ (H i).isLocallyConstructible‚ü©

end Topology
