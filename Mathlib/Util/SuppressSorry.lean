/-
Copyright (c) 2025 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Lean.Elab.Command
import Mathlib.Util.CommandElabHook
open Lean Elab Command

/-!
# The `suppressSorry` option

The `suppressSorry` option will cause the `warning: declaration uses 'sorry'` message
to be suppressed on any declaration. It is useful for projects which are incomplete and have
dozens or hundreds of sorries and would like to not see this noise in the build log.

The option can be set anywhere a regular option can: as `set_option` in the file (including
locally in a section, up to declaration granularity), or using the `[leanOptions]` table
in `lakefile.toml`.

To suppress sorries only in `lake build` and not interactively, add
```
weakLeanArgs = ["-Dweak.suppressSorry=true"]
```
to the `lakefile.toml` file.

If you want `lake build` to not suppress sorries in CI, you need to use the `lakefile.lean`
syntax like so:
```
package myPackage where
  weakLeanArgs := if (get_config? CI).isSome then #[] else #["-Dweak.suppressSorry=true"]
```
and then call `lake build` locally and `lake build -KCI` in your CI script.

## Implementation Notes

Lean's commands do not come with a way to do this out of the box. To accomplish it without
adding any additional text to downstream files, we hook each command elaborator. For declaration
kinds which are built in, like `theorem` (or things that macro expand to them, like `lemma`),
this is done by changing the global state for the parser to apply our sorry filter after the
command has done its thing.

Unfortunately this is not good enough because it interacts badly with the `suppress_compilation`
command, which declares a local (non-builtin) command elaborator in the middle of the file.
We can't modify the environment at import time because it is read only, so we also hook the
`attribute` command to perform a one-time environment modification to change the `command_elab`
attribute itself to hook any new command elaborators it declares.

-/

namespace Mathlib.Util.SuppressSorry

/-- Suppresses the warning `declaration uses 'sorry'` that normally appears when using `sorry`. -/
register_option suppressSorry : Bool := {
  defValue := false
  descr := "suppress sorry warnings"
}

/--
This is a list of whitelisted declarations which will be wrapped to suppress sorries.
(We could wrap all elabs but it seems prudent to just wrap the ones that actually get used.)
-/
def wrappedDeclarations := [``Parser.Command.declaration]

/--
A wrapper for a `CommandElab` which suppresses any sorries generated by it. (It assumes the initial
message log is empty, which is the case for command elaborators called from `elabCommand`.)
-/
def wrapElab (m : CommandElab) : CommandElab := fun stx => do
  m stx
  if suppressSorry.get (← getOptions) then
    -- We have to resolve asynchronous messages or we might miss some.
    -- This might be a linearization point but `#guard_msgs` does the same thing.
    -- TODO: investigate if this can be done without waiting.
    let msgs := (← get).messages ++
      (← get).snapshotTasks.foldl (· ++ ·.get.getAll.foldl (· ++ ·.diagnostics.msgLog) .empty) {}
    modify ({ · with messages := msgs, snapshotTasks := #[] })
    if msgs.hasUnreported then
      modify fun s => { s with
        messages.unreported := s.messages.unreported.filter fun m =>
          !(m.severity matches .warning && m.data.hasTag (· == `hasSorry)) }

/--
Apply the `wrapElab` function to every command (including ones to be added later using
`future := true`). This will take effect as soon as you import this file.
-/
initialize CommandElabHook.wrapEveryCommandElab wrapElab wrappedDeclarations (future := true)

end Mathlib.Util.SuppressSorry
