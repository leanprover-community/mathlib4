/-
Copyright (c) 2025 Jonas van der Schaaf. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jonas van der Schaaf, Anish Rajeev
-/

module

public import Mathlib.ModelTheory.Types
public import Mathlib.Topology.Bases
public import Mathlib.Topology.Connected.TotallyDisconnected
public import Mathlib.Topology.Compactness.Compact
public import Mathlib.Topology.Connected.Separation
public import Mathlib.Topology.Baire.LocallyCompactRegular

/-!
# Topology on the space of complete types

This file defines a topological structure on the type `CompleteType T α` (note that
these are types from model theory and not types from type theory). The topology
is generated by sets of the form `{p : CompleteType T α | ∃ φ, φ ∈ p}`.

Note that the contents of this file are separate from ModelTheory/Types.lean to avoid
importing files from the Topology folder there.
-/

open Set FirstOrder Language Theory CompleteType TopologicalSpace

namespace CompleteType

universe u

variable {L : Language} {T : L.Theory} {α : Type _}

instance : TopologicalSpace (CompleteType T α) := generateFrom (range typesWith)

public lemma typesWith_basis : IsTopologicalBasis (range (typesWith (α := α) (T := T))) where
  exists_subset_inter := by
    intro t₁ ⟨φ, ht₁⟩ t₂ ⟨ψ, ht₂⟩ x hx
    refine ⟨typesWith (φ ⊓ ψ), ⟨φ ⊓ ψ, rfl⟩, ?_⟩
    rw [typesWith_inf, ht₁, ht₂]
    exact ⟨hx, fun _ ↦ id⟩
  sUnion_eq := by
    rw [←Set.univ_subset_iff]
    exact Set.subset_sUnion_of_mem ⟨_, typesWith_top⟩
  eq_generateFrom := rfl

lemma typesWith_open (φ : (L[[α]]).Sentence) : IsOpen (typesWith (T := T) φ) :=
  isOpen_generateFrom_of_mem ⟨φ, rfl⟩

lemma typesWith_closed (φ : (L[[α]]).Sentence) : IsClosed (typesWith (T := T) φ) where
  isOpen_compl := by rw [←typesWith_compl]; exact typesWith_open _

lemma typesWith_clopen (φ : (L[[α]]).Sentence) : IsClopen (typesWith (T := T) φ) where
  left := typesWith_closed _
  right := typesWith_open _

instance : TotallySeparatedSpace (CompleteType T α) := by
  rw [totallySeparatedSpace_iff_exists_isClopen]
  intro p q hpq
  simp only [ne_eq, SetLike.ext_iff, not_forall, not_iff] at hpq
  obtain ⟨φ, hφ⟩ := hpq
  exact (mem_or_not_mem p φ).elim
    (fun h ↦ ⟨typesWith φ, typesWith_clopen _, h, by change ¬φ ∈ q; rwa [←hφ, not_not]⟩)
    (fun h ↦ ⟨
        typesWith ∼φ,
        typesWith_clopen _, h,
        by change ¬∼φ∈q; rwa [not_mem_iff,←hφ, not_not, ←not_mem_iff]
      ⟩)

instance : CompactSpace (T.CompleteType α) := by
  constructor
  rw[isCompact_iff_ultrafilter_le_nhds]
  intros F _
  refine ⟨⟨{φ | typesWith φ ∈ F}, ?_, ?_⟩, ?_⟩
  · intro φ x
    exact F.mem_of_superset Filter.univ_mem (fun p _ ↦ p.subset x)
  · rw [Theory.IsMaximal, Theory.isSatisfiable_iff_isFinitelySatisfiable]
    refine ⟨?_, ?_⟩
    · rw[Theory.IsFinitelySatisfiable]
      intro x hx
      have : ∀ φ ∈ x, typesWith φ ∈ F.toFilter := by intro φ hφ; exact hx hφ
      rw[←Filter.biInter_finset_mem x] at this
      obtain ⟨T, T_inter⟩ := F.neBot.nonempty_of_mem this
      have subset : SetLike.coe x ⊆ T.toTheory := by rwa[Set.mem_iInter₂] at T_inter
      exact Theory.IsSatisfiable.mono T.isMaximal'.1 subset
    · intro φ
      simp only [mem_setOf_eq, typesWith_compl]
      exact Ultrafilter.mem_or_compl_mem F (typesWith φ)
  · refine ⟨trivial, ?_⟩
    · rw [nhds_generateFrom]
      apply le_iInf₂
      intro _ h
      rw [Filter.le_principal_iff]
      obtain ⟨_, rfl⟩ := h.2
      exact h.1

instance : BaireSpace (T.CompleteType α) := BaireSpace.of_t2Space_locallyCompactSpace

end CompleteType

namespace OmittingTypes

variable {L : Language} {T : L.Theory} {n : ℕ}

/-- A language with ω extra constants is abbreviated as ExpandedLanguage -/
abbrev ExpandedLanguage := L[[ℕ]]
local notation "L'" => @ExpandedLanguage L
def toL' : L →ᴸ L' := L.lhomWithConstants ℕ
local notation "T'" => toL'.onTheory T

/-- Existentially quantifies over the variables in formulas from a complete type in
    the expanded language -/
noncomputable def existentialOfFormula (φ : L'[[Fin n]].Sentence) : L'[[Fin n]].Sentence := by
  replace φ := ((L').lhomWithConstantsMap (fun i ↦ Sum.inr i) (β := Empty ⊕ (Fin n))).onSentence φ
  replace φ := Formula.equivSentence.2 φ
  replace φ := Formula.iExs (α := Empty) (β := Fin n) (L := L') φ
  exact ((L').lhomWithConstants (Fin n)).onSentence φ

/-- Replaces variables in a formula from a complete type in the expanded language with constants
    from the expanded language. Fin n → ℕ represents a tuple of constants -/
def replaceWithConstant (φ : L'[[Fin n]].Sentence) (c : Fin n → ℕ) : (L').Sentence :=
  (Formula.equivSentence.2 φ).subst (β := Empty) (fun i ↦ Constants.term (Sum.inr (c i)))

/-- The set of complete types in the expanded language such that it contains all witnesses -/
def henkinWitnessSet (φ : L[[Fin n]].Sentence) : Set ((T').CompleteType (Fin n)) := by
  replace φ : L'[[Fin n]].Sentence := (toL'.addConstants (L := L) (Fin n)).onSentence φ
  have φe : L'[[Fin n]].Sentence := existentialOfFormula φ
  have φc (c : Fin n → ℕ) : L'[[Fin n]].Sentence :=
    ((L').lhomWithConstants (Fin n)).onSentence (replaceWithConstant φ c)
  exact { p : (T').CompleteType (Fin n) | φe ∈ p → ∃ c : (Fin n → ℕ),  (φc c) ∈ p }

end OmittingTypes
