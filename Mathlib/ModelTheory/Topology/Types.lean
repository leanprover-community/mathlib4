/-
Copyright (c) 2025 Jonas van der Schaaf. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jonas van der Schaaf
-/

module

public import Mathlib.ModelTheory.Types
public import Mathlib.Topology.Bases
public import Mathlib.Topology.Connected.TotallyDisconnected
public import Mathlib.Topology.Compactness.Compact

/-!
# Topology on the space of complete types

This file defines a topological structure on the type `CompleteType T α` (note that
these are types from model theory and not types from type theory). The topology
is generated by sets of the form `{p : CompleteType T α | ∃ φ, φ ∈ p}`.

Note that the contents of this file are separate from `Mathlib/ModelTheory/Types.lean`
to avoid importing files from the Topology folder there.
-/

open Set FirstOrder Language Theory CompleteType TopologicalSpace

namespace CompleteType

universe u

variable {L : Language} {T : L.Theory} {α : Type*}

public instance : TopologicalSpace (CompleteType T α) := generateFrom (range typesWith)

public lemma isTopologicalBasis_range_typesWith :
    IsTopologicalBasis (range (typesWith (α := α) (T := T))) where
  exists_subset_inter := by
    intro t₁ ⟨φ, ht₁⟩ t₂ ⟨ψ, ht₂⟩ x hx
    refine ⟨typesWith (φ ⊓ ψ), ⟨φ ⊓ ψ, rfl⟩, ?_⟩
    rw [typesWith_inf, ht₁, ht₂]
    exact ⟨hx, fun _ ↦ id⟩
  sUnion_eq := by
    rw [←Set.univ_subset_iff]
    exact Set.subset_sUnion_of_mem ⟨_, typesWith_top⟩
  eq_generateFrom := rfl

public lemma isOpen_typesWith (φ : (L[[α]]).Sentence) : IsOpen (typesWith (T := T) φ) :=
  isOpen_generateFrom_of_mem ⟨φ, rfl⟩

public lemma isClosed_typesWith (φ : (L[[α]]).Sentence) : IsClosed (typesWith (T := T) φ) where
  isOpen_compl := by rw [←typesWith_not]; exact isOpen_typesWith _

public lemma isClopen_typesWith (φ : (L[[α]]).Sentence) : IsClopen (typesWith (T := T) φ) where
  left := isClosed_typesWith _
  right := isOpen_typesWith _

public instance : TotallySeparatedSpace (CompleteType T α) := by
  rw [totallySeparatedSpace_iff_exists_isClopen]
  intro p q hpq
  simp only [ne_eq, SetLike.ext_iff, not_forall, not_iff] at hpq
  obtain ⟨φ, hφ⟩ := hpq
  exact (mem_or_not_mem p φ).elim
    (fun h ↦ ⟨
      typesWith φ, isClopen_typesWith _, h,
      by rwa [mem_compl_iff, mem_typesWith_iff, ← hφ, not_not]⟩)
    (fun h ↦ ⟨
        typesWith ∼φ,
        isClopen_typesWith _, h,
        by rwa [mem_compl_iff, mem_typesWith_iff, not_mem_iff, ← hφ, not_not, ←not_mem_iff]⟩)


end CompleteType
