/-
Copyright (c) 2024 Dagur Asgeirsson. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Dagur Asgeirsson
-/
import Mathlib.Condensed.Light.TopComparison
import Mathlib.Topology.Category.Sequential
import Mathlib.Topology.Category.LightProfinite.Sequence
/-!

# The adjunction between light condensed sets and topological spaces

This file defines the functor `lightCondSetToTopCat : LightCondSet.{u} ‚•§ TopCat.{u}` which is
left adjoint to `topCatToLightCondSet : TopCat.{u} ‚•§ LightCondSet.{u}`. We prove that the counit
is bijective (but not in general an isomorphism) and conclude that the right adjoint is faithful.

The counit is an isomorphism for sequential spaces, and we conclude that the functor
`topCatToLightCondSet` is fully faithful when restricted to sequential spaces.
-/

universe u

open LightCondensed LightCondSet CategoryTheory LightProfinite

attribute [local instance] ConcreteCategory.instFunLike

namespace LightCondSet

variable (X : LightCondSet.{u})

/-- Auxiliary definition to define the topology on `X(*)` for a light condensed set `X`. -/
private def _root_.LightProfinite.const (S : LightProfinite.{u}) (s : S) :
    LightProfinite.of PUnit.{u+1} ‚ü∂ S :=
  ContinuousMap.const _ s

/-- Auxiliary definition to define the topology on `X(*)` for a light condensed set `X`. -/
private def coinducingCoprod :
    (Œ£ (i : (S : LightProfinite.{u}) √ó X.val.obj ‚ü®S‚ü©), i.fst) ‚Üí
      X.val.obj ‚ü®LightProfinite.of PUnit‚ü© :=
  fun ‚ü®‚ü®S, i‚ü©, s‚ü© ‚Ü¶ X.val.map (S.const s).op i

/-- Let `X` be a light condensed set. We define a topology on `X(*)` as the quotient topology of
all the maps from light profinite sets `S` to `X(*)`, corresponding to elements of `X(S)`.
In other words, the topology coinduced by the map `LightCondSet.coinducingCoprod` above. -/
local instance underlyingTopologicalSpace :
    TopologicalSpace (X.val.obj ‚ü®LightProfinite.of PUnit‚ü©) :=
  TopologicalSpace.coinduced (coinducingCoprod X) inferInstance

/-- The object part of the functor `LightCondSet ‚•§ TopCat` -/
def toTopCat : TopCat.{u} := TopCat.of (X.val.obj ‚ü®LightProfinite.of PUnit‚ü©)

lemma continuous_coinducingCoprod {S : LightProfinite.{u}} (x : X.val.obj ‚ü®S‚ü©) :
    Continuous fun a ‚Ü¶ (X.coinducingCoprod ‚ü®‚ü®S, x‚ü©, a‚ü©) := by
  suffices ‚àÄ (i : (T : LightProfinite.{u}) √ó X.val.obj ‚ü®T‚ü©),
      Continuous (fun (a : i.fst) ‚Ü¶ X.coinducingCoprod ‚ü®i, a‚ü©) from this ‚ü®_, _‚ü©
  rw [‚Üê continuous_sigma_iff]
  apply continuous_coinduced_rng

variable {X} {Y : LightCondSet} (f : X ‚ü∂ Y)

/-- The map part of the functor `LightCondSet ‚•§ TopCat` -/
@[simps]
def toTopCatMap : X.toTopCat ‚ü∂ Y.toTopCat where
  toFun := f.val.app ‚ü®LightProfinite.of PUnit‚ü©
  continuous_toFun := by
    rw [continuous_coinduced_dom]
    apply continuous_sigma
    intro ‚ü®S, x‚ü©
    simp only [Function.comp_apply, coinducingCoprod]
    have : (fun (a : S) ‚Ü¶ f.val.app ‚ü®LightProfinite.of PUnit‚ü© (X.val.map (S.const a).op x)) =
        (fun (a : S) ‚Ü¶ Y.val.map (S.const a).op (f.val.app ‚ü®S‚ü© x)) :=
      funext fun a ‚Ü¶ NatTrans.naturality_apply f.val (S.const a).op x
    rw [this]
    exact continuous_coinducingCoprod _ _

/-- The functor `LightCondSet ‚•§ TopCat` -/
@[simps]
def _root_.lightCondSetToTopCat : LightCondSet.{u} ‚•§ TopCat.{u} where
  obj X := X.toTopCat
  map f := toTopCatMap f

/-- The counit of the adjunction `lightCondSetToTopCat ‚ä£ topCatToLightCondSet` -/
def topCatAdjunctionCounit (X : TopCat.{u}) : X.toLightCondSet.toTopCat ‚ü∂ X where
  toFun x := x.1 PUnit.unit
  continuous_toFun := by
    rw [continuous_coinduced_dom]
    continuity

/-- The counit of the adjunction `lightCondSetToTopCat ‚ä£ topCatToLightCondSet` is always bijective,
but not an isomorphism in general (the inverse isn't continuous unless `X` is sequential).
-/
def topCatAdjunctionCounitEquiv (X : TopCat.{u}) : X.toLightCondSet.toTopCat ‚âÉ X where
  toFun := topCatAdjunctionCounit X
  invFun x := ContinuousMap.const _ x
  left_inv _ := rfl
  right_inv _ := rfl

lemma topCatAdjunctionCounit_bijective (X : TopCat.{u}) :
    Function.Bijective (topCatAdjunctionCounit X) :=
  (topCatAdjunctionCounitEquiv X).bijective

/-- The unit of the adjunction `lightCondSetToTopCat ‚ä£ topCatToLightCondSet` -/
@[simps val_app val_app_apply]
def topCatAdjunctionUnit (X : LightCondSet.{u}) : X ‚ü∂ X.toTopCat.toLightCondSet where
  val := {
    app := fun S x ‚Ü¶ {
      toFun := fun s ‚Ü¶ X.val.map (S.unop.const s).op x
      continuous_toFun := by
        suffices ‚àÄ (i : (T : LightProfinite.{u}) √ó X.val.obj ‚ü®T‚ü©),
          Continuous (fun (a : i.fst) ‚Ü¶ X.coinducingCoprod ‚ü®i, a‚ü©) from this ‚ü®_, _‚ü©
        rw [‚Üê continuous_sigma_iff]
        apply continuous_coinduced_rng }
    naturality := fun _ _ _ ‚Ü¶ by
      ext
      simp only [TopCat.toSheafCompHausLike_val_obj, CompHausLike.compHausLikeToTop_obj,
        Opposite.op_unop, types_comp_apply, TopCat.toSheafCompHausLike_val_map,
        ‚Üê FunctorToTypes.map_comp_apply]
      rfl }

/-- The adjunction `lightCondSetToTopCat ‚ä£ topCatToLightCondSet` -/
noncomputable def topCatAdjunction : lightCondSetToTopCat.{u} ‚ä£ topCatToLightCondSet :=
  Adjunction.mkOfUnitCounit {
    unit := { app := topCatAdjunctionUnit }
    counit := { app := topCatAdjunctionCounit }
    left_triangle := by
      ext Y
      change Y.val.map (ùüô _) _ = _
      simp }

instance (X : TopCat) : Epi (topCatAdjunction.counit.app X) := by
  rw [TopCat.epi_iff_surjective]
  exact (topCatAdjunctionCounit_bijective _).2

instance : topCatToLightCondSet.Faithful := topCatAdjunction.faithful_R_of_epi_counit_app

open Sequential

instance (X : LightCondSet.{u}) : SequentialSpace X.toTopCat := by
  apply SequentialSpace.coinduced

instance (X : LightCondSet.{u}) : SequentialSpace (lightCondSetToTopCat.obj X) :=
  inferInstanceAs (SequentialSpace X.toTopCat)

/-- The functor from light condensed sets to topological spaces lands in sequential spaces. -/
def lightCondSetToSequential : LightCondSet.{u} ‚•§ Sequential.{u} where
  obj X := Sequential.of (lightCondSetToTopCat.obj X)
  map f := toTopCatMap f

/--
The functor from topological spaces to light condensed sets restricted to sequential spaces.
-/
noncomputable def sequentialToLightCondSet :
    Sequential.{u} ‚•§ LightCondSet.{u} :=
  sequentialToTop ‚ãô topCatToLightCondSet

/--
The adjunction `lightCondSetToTopCat ‚ä£ topCatToLightCondSet` restricted to sequential
spaces.
-/
noncomputable def sequentialAdjunction :
    lightCondSetToSequential ‚ä£ sequentialToLightCondSet :=
  topCatAdjunction.restrictFullyFaithful (iC := ùü≠ _) (iD := sequentialToTop)
    (Functor.FullyFaithful.id _) fullyFaithfulSequentialToTop
    (Iso.refl _) (Iso.refl _)

/--
The counit of the adjunction `lightCondSetToSequential ‚ä£ sequentialToLightCondSet`
is a homeomorphism.

Note: for now, we only have `‚Ñï‚à™{‚àû}` as a light profinite set at universe level 0, which is why we
can only prove this for `X : TopCat.{0}`.
-/
def sequentialAdjunctionHomeo (X : TopCat.{0}) [SequentialSpace X] :
    X.toLightCondSet.toTopCat ‚âÉ‚Çú X where
  toEquiv := topCatAdjunctionCounitEquiv X
  continuous_toFun := (topCatAdjunctionCounit X).continuous
  continuous_invFun := by
    apply SeqContinuous.continuous
    unfold SeqContinuous
    intro f p h
    let g := (topCatAdjunctionCounitEquiv X).invFun ‚àò (OnePoint.continuousMapMkNat f p h)
    change Filter.Tendsto (fun n : ‚Ñï ‚Ü¶ g n) _ _
    erw [‚Üê OnePoint.continuous_iff_from_nat]
    let x : X.toLightCondSet.val.obj ‚ü®(‚Ñï‚à™{‚àû})‚ü© := OnePoint.continuousMapMkNat f p h
    exact continuous_coinducingCoprod X.toLightCondSet x

/--
The counit of the adjunction `lightCondSetToSequential ‚ä£ sequentialToLightCondSet`
is an isomorphism.

Note: for now, we only have `‚Ñï‚à™{‚àû}` as a light profinite set at universe level 0, which is why we
can only prove this for `X : Sequential.{0}`.
-/
noncomputable def sequentialAdjunctionCounitIso (X : Sequential.{0}) :
    lightCondSetToSequential.obj (sequentialToLightCondSet.obj X) ‚âÖ X :=
  isoOfHomeo (sequentialAdjunctionHomeo X.toTop)

instance : IsIso sequentialAdjunction.{0}.counit := by
  rw [NatTrans.isIso_iff_isIso_app]
  intro X
  exact inferInstanceAs (IsIso (sequentialAdjunctionCounitIso X).hom)

/--
The functor from topological spaces to light condensed sets restricted to sequential spaces
is fully faithful.

Note: for now, we only have `‚Ñï‚à™{‚àû}` as a light profinite set at universe level 0, which is why we
can only prove this for the functor `Sequential.{0} ‚•§ LightCondSet.{0}`.
-/
noncomputable def fullyFaithfulSequentialToLightCondSet :
    sequentialToLightCondSet.{0}.FullyFaithful :=
  sequentialAdjunction.fullyFaithfulROfIsIsoCounit

end LightCondSet
