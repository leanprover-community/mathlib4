/-
Copyright (c) 2024 R√©my Degenne. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: R√©my Degenne
-/
import Mathlib.Probability.Kernel.Composition
import Mathlib.Probability.Martingale.Convergence
import Mathlib.Analysis.SpecialFunctions.Log.Base
import Mathlib.Probability.Kernel.Disintegration.AuxLemmas

/-!
# Kernel density

Let `Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)` and `ŒΩ : kernel Œ± ‚Ñù` be two finite kernels with `kernel.fst Œ∫ ‚â§ ŒΩ`.
We build a function `f : Œ± ‚Üí ‚Ñù ‚Üí Set Œ≤ ‚Üí ‚Ñù` jointly measurable in the first two arguments such that
for all `a : Œ±` and all measurable sets `s : Set Œ≤` and `A : Set ‚Ñù`,
`‚à´ t in A, f a t s ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ s)).toReal`.

If we were interested only in a fixed `a : Œ±`, then we could use the Radon-Nikodym derivative to
build the function `f`, as follows
```
def f_a (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) (ŒΩ : kernel a ‚Ñù) (a : Œ±) (t : ‚Ñù) (s : Set Œ≤) : ‚Ñù :=
  (((Œ∫ a).restrict (univ √óÀ¢ s)).fst.rnDeriv (ŒΩ a) t).toReal
```
However, we can't turn those functions for each `a` into a measurable function of the pair `(a, t)`.

In order to obtain measurability through countability, we discretize the real line.
For each `n : ‚Ñï`, we define the intervals `I n k = [k * 2^-n, (k + 1) * 2^-n)` for `k : ‚Ñ§`.
For `t : ‚Ñù`, let `indexI n t = ‚åät * 2^n‚åã` be the integer such that `t ‚àà I n (indexI n t)`.

For a given `n`, the function `densityProcess Œ∫ ŒΩ n : Œ± ‚Üí ‚Ñù ‚Üí Set Œ≤ ‚Üí ‚Ñù` defined by
`fun a t s ‚Ü¶ (Œ∫ a (I n (indexI n t) √óÀ¢ s) / ŒΩ a (I n (indexI n t))).toReal` has the desired
property that `‚à´ t in A, densityProcess Œ∫ ŒΩ n a t s ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ s)).toReal` for all `A`
in the œÉ-algebra generated by the intervals `I n k` for `k : ‚Ñ§` and is measurable in `(a, t)`.

Let `‚Ñ±` be the filtration of those œÉ-algebras for all `n : ‚Ñï`. The functions `densityProcess Œ∫ ŒΩ n`
described here are a bounded `ŒΩ`-martingale for the filtration `‚Ñ±`. By Doob's L1 martingale
convergence theorem, that martingale converges to a limit, which has a product-measurable version
and satisfies the integral equality for all `A` in `‚®Ü n, ‚Ñ± n = borel ‚Ñù`. We have obtained the
desired density function.

## Main definitions

* `FooBar`

## Main statements

* `fooBar_unique`

## Implementation details


## References

The construction of the density process in this file follows the proof of Theorem 9.27 in
[O. Kallenberg, Foundations of modern probability][kallenberg2021].

TODO: adapted to use countably generated sigma-algebras.
-/

variable {Œ± Œ≤ : Type*} {mŒ± : MeasurableSpace Œ±}

open MeasureTheory Set Filter

open scoped NNReal ENNReal MeasureTheory Topology ProbabilityTheory

namespace ProbabilityTheory

lemma Measure.iInf_Iic_gt_prod {œÅ : Measure (Œ± √ó ‚Ñù)} [IsFiniteMeasure œÅ]
    {s : Set Œ±} (hs : MeasurableSet s) (t : ‚Ñö) :
    ‚®Ö r : { r' : ‚Ñö // t < r' }, œÅ (s √óÀ¢ Iic (r : ‚Ñù)) = œÅ (s √óÀ¢ Iic (t : ‚Ñù)) := by
  rw [‚Üê measure_iInter_eq_iInf]
  ¬∑ rw [‚Üê prod_iInter]
    congr with x : 1
    simp only [mem_iInter, mem_Iic, Subtype.forall, Subtype.coe_mk]
    refine' ‚ü®fun h => _, fun h a hta => h.trans _‚ü©
    ¬∑ refine' le_of_forall_lt_rat_imp_le fun q htq => h q _
      exact mod_cast htq
    ¬∑ exact mod_cast hta.le
  ¬∑ exact fun _ => hs.prod measurableSet_Iic
  ¬∑ refine' Monotone.directed_ge fun r r' hrr' => prod_subset_prod_iff.mpr (Or.inl ‚ü®subset_rfl, _‚ü©)
    refine' Iic_subset_Iic.mpr _
    exact mod_cast hrr'
  ¬∑ exact ‚ü®‚ü®t + 1, lt_add_one _‚ü©, measure_ne_top œÅ _‚ü©

variable {Œ± Œ≤ Œ≥ : Type*} {mŒ± : MeasurableSpace Œ±} {mŒ≥ : MeasurableSpace Œ≥}
  [MeasurableSpace.CountablyGenerated Œ≥]

-- todo : `Filtration` should be renamed to `filtration`
def ‚Ñ± (Œ≥ : Type*) [m : MeasurableSpace Œ≥] [MeasurableSpace.CountablyGenerated Œ≥] :
    Filtration ‚Ñï m where
  seq := fun n ‚Ü¶ MeasurableSpace.generateFrom <| MeasurableSpace.countablePartition Œ≥ n
  mono' := monotone_nat_of_le_succ (MeasurableSpace.generateFrom_countablePartition_le_succ _)
  le' := MeasurableSpace.generateFrom_countablePartition_le Œ≥

lemma measurableSet_‚Ñ±_countablePartition (n : ‚Ñï) {s : Set Œ≥}
    (hs : s ‚àà MeasurableSpace.countablePartition Œ≥ n) :
    MeasurableSet[‚Ñ± Œ≥ n] s :=
  MeasurableSpace.measurableSet_generateFrom hs

lemma existsPartitionSet_mem (n : ‚Ñï) (t : Œ≥) :
    ‚àÉ s, s ‚àà MeasurableSpace.countablePartition Œ≥ n ‚àß t ‚àà s := by
  have h_univ := MeasurableSpace.sUnion_countablePartition Œ≥ n
  have h_mem_univ := mem_univ t
  rw [‚Üê h_univ] at h_mem_univ
  simpa only [mem_sUnion] using h_mem_univ

def partitionSet (n : ‚Ñï) (t : Œ≥) : Set Œ≥ :=
  (existsPartitionSet_mem n t).choose

lemma partitionSet_mem (n : ‚Ñï) (t : Œ≥) :
    partitionSet n t ‚àà MeasurableSpace.countablePartition Œ≥ n :=
  (existsPartitionSet_mem n t).choose_spec.1

lemma mem_partitionSet (n : ‚Ñï) (t : Œ≥) : t ‚àà partitionSet n t :=
  (existsPartitionSet_mem n t).choose_spec.2

lemma mem_countablePartition_iff (n : ‚Ñï) (t : Œ≥) {s : Set Œ≥}
    (hs : s ‚àà MeasurableSpace.countablePartition Œ≥ n) :
    t ‚àà s ‚Üî partitionSet n t = s := by
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ by_contra h_ne
    have h_disj : Disjoint s (partitionSet n t) :=
      MeasurableSpace.disjoint_countablePartition n hs (partitionSet_mem n t) (Ne.symm h_ne)
    refine absurd h_disj ?_
    rw [not_disjoint_iff_nonempty_inter]
    exact ‚ü®t, h, mem_partitionSet n t‚ü©
  ¬∑ rw [‚Üê h]
    exact mem_partitionSet n t

lemma partitionSet_of_mem {n : ‚Ñï} {t : Œ≥} {s : Set Œ≥}
    (hs : s ‚àà MeasurableSpace.countablePartition Œ≥ n) (ht : t ‚àà s) :
    partitionSet n t = s := by
  rwa [‚Üê mem_countablePartition_iff n t hs]

lemma measurableSet_‚Ñ±_partitionSet (n : ‚Ñï) (t : Œ≥) :
    MeasurableSet[‚Ñ± Œ≥ n] (partitionSet n t) :=
  measurableSet_‚Ñ±_countablePartition n (partitionSet_mem n t)

lemma measurableSet_partitionSet (n : ‚Ñï) (t : Œ≥) :
    MeasurableSet (partitionSet n t) :=
  (‚Ñ± Œ≥).le n _ (measurableSet_‚Ñ±_partitionSet n t)

instance todo_move (n : ‚Ñï) : Countable (MeasurableSpace.countablePartition Œ≥ n) :=
  Set.Finite.countable (MeasurableSpace.finite_countablePartition _ _)

lemma measurable_aux (n : ‚Ñï) (m : MeasurableSpace (MeasurableSpace.countablePartition Œ≥ n)) :
    @Measurable Œ≥ (MeasurableSpace.countablePartition Œ≥ n) (‚Ñ± Œ≥ n) m
      (fun c : Œ≥ ‚Ü¶ ‚ü®partitionSet n c, partitionSet_mem n c‚ü©) := by
  refine @measurable_to_countable' (MeasurableSpace.countablePartition Œ≥ n) Œ≥ m _
    (‚Ñ± Œ≥ n) _ (fun t ‚Ü¶ ?_)
  rcases t with ‚ü®t, ht‚ü©
  suffices MeasurableSet[‚Ñ± Œ≥ n] {x | partitionSet n x = t} by
    convert this
    ext x
    simp
  have : {x | partitionSet n x = t} = t := by
    ext x
    rw [mem_setOf_eq, mem_countablePartition_iff n x ht]
  rw [this]
  exact measurableSet_‚Ñ±_countablePartition _ ht

lemma measurable_partitionSet (n : ‚Ñï) : Measurable[‚Ñ± Œ≥ n] (partitionSet n) := by
  have : partitionSet n = (fun s : MeasurableSpace.countablePartition Œ≥ n ‚Ü¶ (s : Set Œ≥))
      ‚àò (fun t ‚Ü¶ ‚ü®partitionSet n t, partitionSet_mem n t‚ü©) := rfl
  rw [this]
  refine Measurable.comp
    (?_ : Measurable (fun s : MeasurableSpace.countablePartition Œ≥ n ‚Ü¶ (s : Set Œ≥))) ?_
  ¬∑ measurability
  exact measurable_aux _ _

lemma MeasurableSpace.generateFrom_iSup {Œπ : Type*} (s : Œπ ‚Üí Set (Set Œ±)) :
    MeasurableSpace.generateFrom (‚ãÉ i, s i) = ‚®Ü i, MeasurableSpace.generateFrom (s i) :=
  (@MeasurableSpace.giGenerateFrom Œ±).gc.l_iSup

lemma iSup_‚Ñ± (Œ≤ : Type*) [m : MeasurableSpace Œ≤] [MeasurableSpace.CountablyGenerated Œ≤] :
    ‚®Ü n, ‚Ñ± Œ≤ n = m := by
  conv_rhs => rw [‚Üê MeasurableSpace.generateFrom_iUnion_countablePartition Œ≤]
  rw [MeasurableSpace.generateFrom_iSup]
  rfl

variable [MeasurableSpace Œ≤]

section DensityProcess

variable {Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)} {ŒΩ : kernel Œ± Œ≥}

noncomputable
def densityProcess (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (n : ‚Ñï) (a : Œ±) (t : Œ≥) (s : Set Œ≤) :
    ‚Ñù :=
  (Œ∫ a (partitionSet n t √óÀ¢ s) / ŒΩ a (partitionSet n t)).toReal

lemma densityProcess_def (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (n : ‚Ñï) (a : Œ±) (s : Set Œ≤) :
    (fun t ‚Ü¶ densityProcess Œ∫ ŒΩ n a t s)
      = fun t ‚Ü¶ (Œ∫ a (partitionSet n t √óÀ¢ s) / ŒΩ a (partitionSet n t)).toReal :=
  rfl

lemma measurable_densityProcess_‚Ñ±_aux (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (n : ‚Ñï)
    {s : Set Œ≤} (hs : MeasurableSet s) :
    Measurable[MeasurableSpace.prod mŒ± (‚Ñ± Œ≥ n)] (fun (p : Œ± √ó Œ≥) ‚Ü¶
      Œ∫ p.1 (partitionSet n p.2 √óÀ¢ s) / ŒΩ p.1 (partitionSet n p.2)) := by
  change Measurable[MeasurableSpace.prod mŒ± (‚Ñ± Œ≥ n)]
      ((fun (p : Œ± √ó MeasurableSpace.countablePartition Œ≥ n) ‚Ü¶ Œ∫ p.1 (‚Üëp.2 √óÀ¢ s) / ŒΩ p.1 p.2)
        ‚àò (fun (p : Œ± √ó Œ≥) ‚Ü¶ (p.1, ‚ü®partitionSet n p.2, partitionSet_mem n p.2‚ü©)))
  have h1 : @Measurable _ _ (MeasurableSpace.prod mŒ± ‚ä§) _
      (fun (p : Œ± √ó MeasurableSpace.countablePartition Œ≥ n) ‚Ü¶ Œ∫ p.1 (‚Üëp.2 √óÀ¢ s) / ŒΩ p.1 p.2) := by
    refine Measurable.div ?_ ?_
    ¬∑ refine measurable_from_prod_countable ?_
      rintro ‚ü®t, ht‚ü©
      simp only
      refine kernel.measurable_coe _ (MeasurableSet.prod ?_ hs)
      exact MeasurableSpace.measurableSet_countablePartition _ ht
    ¬∑ refine measurable_from_prod_countable ?_
      rintro ‚ü®t, ht‚ü©
      simp only
      exact kernel.measurable_coe _ (MeasurableSpace.measurableSet_countablePartition _ ht)
  refine h1.comp ?_
  refine measurable_fst.prod_mk ?_
  change @Measurable (Œ± √ó Œ≥) (MeasurableSpace.countablePartition Œ≥ n)
    (MeasurableSpace.prod mŒ± (‚Ñ± Œ≥ n)) ‚ä§
    ((fun c : Œ≥ ‚Ü¶ ‚ü®partitionSet n c, partitionSet_mem n c‚ü©) ‚àò (fun p : Œ± √ó Œ≥ ‚Ü¶ p.2))
  refine Measurable.comp ?_ measurable_snd
  exact measurable_aux n ‚ä§

lemma measurable_densityProcess_aux (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (n : ‚Ñï)
    {s : Set Œ≤} (hs : MeasurableSet s) :
    Measurable (fun (p : Œ± √ó Œ≥) ‚Ü¶
      Œ∫ p.1 (partitionSet n p.2 √óÀ¢ s) / ŒΩ p.1 (partitionSet n p.2)) := by
  refine Measurable.mono (measurable_densityProcess_‚Ñ±_aux Œ∫ ŒΩ n hs) ?_ le_rfl
  exact sup_le_sup le_rfl (MeasurableSpace.comap_mono ((‚Ñ± Œ≥).le _))

lemma measurable_densityProcess (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (n : ‚Ñï)
    {s : Set Œ≤} (hs : MeasurableSet s) :
    Measurable (fun (p : Œ± √ó Œ≥) ‚Ü¶ densityProcess Œ∫ ŒΩ n p.1 p.2 s) :=
  (measurable_densityProcess_aux Œ∫ ŒΩ n hs).ennreal_toReal

lemma measurable_densityProcess_left (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (n : ‚Ñï)
    (t : Œ≥) {s : Set Œ≤} (hs : MeasurableSet s) :
    Measurable (fun a ‚Ü¶ densityProcess Œ∫ ŒΩ n a t s) :=
  (measurable_densityProcess Œ∫ ŒΩ n hs).comp (measurable_id.prod_mk measurable_const)

lemma measurable_densityProcess_right (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (n : ‚Ñï)
    {s : Set Œ≤} (a : Œ±) (hs : MeasurableSet s) :
    Measurable (fun t ‚Ü¶ densityProcess Œ∫ ŒΩ n a t s) :=
  (measurable_densityProcess Œ∫ ŒΩ n hs).comp (measurable_const.prod_mk measurable_id)

lemma measurable_‚Ñ±_densityProcess (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (n : ‚Ñï)
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    Measurable[‚Ñ± Œ≥ n] (fun t ‚Ü¶ densityProcess Œ∫ ŒΩ n a t s) := by
  refine @Measurable.ennreal_toReal _ (‚Ñ± Œ≥ n) _ ?_
  exact (measurable_densityProcess_‚Ñ±_aux Œ∫ ŒΩ n hs).comp measurable_prod_mk_left

lemma stronglyMeasurable_‚Ñ±_densityProcess (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (n : ‚Ñï)
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    StronglyMeasurable[‚Ñ± Œ≥ n] (fun t ‚Ü¶ densityProcess Œ∫ ŒΩ n a t s) :=
  (measurable_‚Ñ±_densityProcess Œ∫ ŒΩ n a hs).stronglyMeasurable

lemma adapted_densityProcess (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (a : Œ±)
  {s : Set Œ≤} (hs : MeasurableSet s) :
    Adapted (‚Ñ± Œ≥) (fun n t ‚Ü¶ densityProcess Œ∫ ŒΩ n a t s) :=
  fun n ‚Ü¶ stronglyMeasurable_‚Ñ±_densityProcess Œ∫ ŒΩ n a hs

lemma densityProcess_nonneg (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (n : ‚Ñï)
    (a : Œ±) (t : Œ≥) (s : Set Œ≤) :
    0 ‚â§ densityProcess Œ∫ ŒΩ n a t s :=
  ENNReal.toReal_nonneg

lemma apply_partitionSet_le_of_fst_le (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) (n : ‚Ñï) (a : Œ±) (t : Œ≥) (s : Set Œ≤) :
    Œ∫ a (partitionSet n t √óÀ¢ s) ‚â§ ŒΩ a (partitionSet n t) := by
  calc Œ∫ a (partitionSet n t √óÀ¢ s)
    ‚â§ kernel.fst Œ∫ a (partitionSet n t) := by
        rw [kernel.fst_apply' _ _ (measurableSet_partitionSet _ _)]
        refine measure_mono (fun x ‚Ü¶ ?_)
        simp only [mem_prod, mem_setOf_eq, and_imp]
        exact fun h _ ‚Ü¶ h
  _ ‚â§ ŒΩ a (partitionSet n t) := hŒ∫ŒΩ a _ (measurableSet_partitionSet _ _)

lemma densityProcess_le_one (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) (n : ‚Ñï) (a : Œ±) (t : Œ≥) (s : Set Œ≤) :
    densityProcess Œ∫ ŒΩ n a t s ‚â§ 1 := by
  refine ENNReal.toReal_le_of_le_ofReal zero_le_one (ENNReal.div_le_of_le_mul ?_)
  rw [ENNReal.ofReal_one, one_mul]
  exact apply_partitionSet_le_of_fst_le hŒ∫ŒΩ n a t s

lemma snorm_densityProcess_le (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) (n : ‚Ñï) (a : Œ±) (s : Set Œ≤) :
    snorm (fun t ‚Ü¶ densityProcess Œ∫ ŒΩ n a t s) 1 (ŒΩ a) ‚â§ ŒΩ a univ := by
  refine (snorm_le_of_ae_bound (C := 1) (ae_of_all _ (fun x ‚Ü¶ ?_))).trans ?_
  ¬∑ simp only [Real.norm_eq_abs, abs_of_nonneg (densityProcess_nonneg Œ∫ ŒΩ n a x s),
      densityProcess_le_one hŒ∫ŒΩ n a x s]
  ¬∑ simp

lemma integrable_densityProcess (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel ŒΩ] (n : ‚Ñï)
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    Integrable (fun t ‚Ü¶ densityProcess Œ∫ ŒΩ n a t s) (ŒΩ a) := by
  rw [‚Üê mem‚Ñíp_one_iff_integrable]
  refine ‚ü®Measurable.aestronglyMeasurable ?_, ?_‚ü©
  ¬∑ exact measurable_densityProcess_right Œ∫ ŒΩ n a hs
  ¬∑ exact (snorm_densityProcess_le hŒ∫ŒΩ n a s).trans_lt (measure_lt_top _ _)

lemma set_integral_densityProcess_I (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel Œ∫] [IsFiniteKernel ŒΩ]
    (n : ‚Ñï) (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) {u : Set Œ≥}
    (hu : u ‚àà MeasurableSpace.countablePartition Œ≥ n) :
    ‚à´ t in u, densityProcess Œ∫ ŒΩ n a t s ‚àÇ(ŒΩ a) = (Œ∫ a (u √óÀ¢ s)).toReal := by
  have hu_meas : MeasurableSet u := MeasurableSpace.measurableSet_countablePartition n hu
  simp_rw [densityProcess]
  rw [integral_toReal]
  rotate_left
  ¬∑ refine Measurable.aemeasurable ?_
    have h := measurable_densityProcess_aux Œ∫ ŒΩ n hs
    change Measurable ((fun (p : Œ± √ó _) ‚Ü¶ Œ∫ p.1 (partitionSet n p.2 √óÀ¢ s)
      / ŒΩ p.1 (partitionSet n p.2)) ‚àò (fun t ‚Ü¶ (a, t)))
    exact h.comp measurable_prod_mk_left
  ¬∑ refine ae_of_all _ (fun t ‚Ü¶ ?_)
    by_cases h0 : ŒΩ a (partitionSet n t) = 0
    ¬∑ suffices Œ∫ a (partitionSet n t √óÀ¢ s) = 0 by simp [h0, this]
      have h0' : kernel.fst Œ∫ a (partitionSet n t) = 0 :=
        le_antisymm ((hŒ∫ŒΩ a _ (measurableSet_partitionSet _ _)).trans h0.le) zero_le'
      rw [kernel.fst_apply' _ _ (measurableSet_partitionSet _ _)] at h0'
      refine measure_mono_null (fun x ‚Ü¶ ?_) h0'
      simp only [mem_prod, mem_setOf_eq, and_imp]
      exact fun h _ ‚Ü¶ h
    ¬∑ refine ENNReal.div_lt_top ?_ h0
      exact measure_ne_top _ _
  congr
  have : ‚à´‚Åª t in u, Œ∫ a (partitionSet n t √óÀ¢ s) / ŒΩ a (partitionSet n t) ‚àÇ(ŒΩ a)
      = ‚à´‚Åª _ in u, Œ∫ a (u √óÀ¢ s) / ŒΩ a u ‚àÇ(ŒΩ a) := by
    refine set_lintegral_congr_fun hu_meas (ae_of_all _ (fun t ht ‚Ü¶ ?_))
    rw [partitionSet_of_mem hu ht]
  rw [this]
  simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
  by_cases h0 : ŒΩ a u = 0
  ¬∑ simp only [h0, mul_zero]
    have h0' : kernel.fst Œ∫ a u = 0 :=
      le_antisymm ((hŒ∫ŒΩ a _ hu_meas).trans h0.le) zero_le'
    rw [kernel.fst_apply' _ _ hu_meas] at h0'
    refine (measure_mono_null ?_ h0').symm
    intro p
    simp only [mem_prod, mem_setOf_eq, and_imp]
    exact fun h _ ‚Ü¶ h
  rw [div_eq_mul_inv, mul_assoc, ENNReal.inv_mul_cancel h0, mul_one]
  exact measure_ne_top _ _

lemma integral_densityProcess (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel Œ∫] [IsFiniteKernel ŒΩ]
    (n : ‚Ñï) (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    ‚à´ t, densityProcess Œ∫ ŒΩ n a t s ‚àÇ(ŒΩ a) = (Œ∫ a (univ √óÀ¢ s)).toReal := by
  rw [‚Üê integral_univ, ‚Üê MeasurableSpace.sUnion_countablePartition Œ≥ n, sUnion_eq_iUnion,
    iUnion_prod_const, measure_iUnion]
  rotate_left
  ¬∑ intro i j hij
    simp only [Set.disjoint_prod, disjoint_self, bot_eq_empty]
    refine Or.inl (MeasurableSpace.disjoint_countablePartition n i.prop j.prop ?_)
    rw [ne_eq, Subtype.coe_inj]
    exact hij
  ¬∑ exact fun k ‚Ü¶ (MeasurableSpace.measurableSet_countablePartition n k.prop).prod hs
  rw [integral_iUnion]
  rotate_left
  ¬∑ exact fun k ‚Ü¶ MeasurableSpace.measurableSet_countablePartition n k.prop
  ¬∑ intro i j hij
    refine MeasurableSpace.disjoint_countablePartition n i.prop j.prop ?_
    rw [ne_eq, Subtype.coe_inj]
    exact hij
  ¬∑ exact (integrable_densityProcess hŒ∫ŒΩ n a hs).integrableOn
  rw [ENNReal.tsum_toReal_eq (fun _ ‚Ü¶ measure_ne_top _ _)]
  congr with k
  rw [set_integral_densityProcess_I hŒ∫ŒΩ _ _ hs k.prop]

lemma set_integral_densityProcess (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel Œ∫] [IsFiniteKernel ŒΩ]
    (n : ‚Ñï) (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) {A : Set Œ≥} (hA : MeasurableSet[‚Ñ± Œ≥ n] A) :
    ‚à´ t in A, densityProcess Œ∫ ŒΩ n a t s ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ s)).toReal := by
  refine MeasurableSpace.induction_on_inter (m := ‚Ñ± Œ≥ n)
    (s := MeasurableSpace.countablePartition Œ≥ n)
    (C := fun A ‚Ü¶ ‚à´ t in A, densityProcess Œ∫ ŒΩ n a t s ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ s)).toReal) rfl
    ?_ ?_ ?_ ?_ ?_ hA
  ¬∑ rintro s hs t ht hst
    suffices s = t by rwa [this, inter_self]
    by_contra h_ne
    rw [‚Üê not_disjoint_iff_nonempty_inter] at hst
    exact hst <| MeasurableSpace.disjoint_countablePartition n hs ht h_ne
  ¬∑ simp
  ¬∑ rintro u hu
    rw [set_integral_densityProcess_I hŒ∫ŒΩ _ _ hs hu]
  ¬∑ intro A hA hA_eq
    have hA' : MeasurableSet A := (‚Ñ± Œ≥).le _ _ hA
    have h := integral_add_compl hA' (integrable_densityProcess hŒ∫ŒΩ n a hs)
    rw [hA_eq, integral_densityProcess hŒ∫ŒΩ n a hs] at h
    have : A·∂ú √óÀ¢ s = univ √óÀ¢ s \ A √óÀ¢ s := by
      rw [prod_diff_prod, compl_eq_univ_diff]
      simp
    rw [this, measure_diff (by intro x; simp) (hA'.prod hs) (measure_ne_top (Œ∫ a) _),
      ENNReal.toReal_sub_of_le (measure_mono (by intro x; simp)) (measure_ne_top _ _)]
    rw [eq_tsub_iff_add_eq_of_le, add_comm]
    ¬∑ exact h
    ¬∑ rw [ENNReal.toReal_le_toReal (measure_ne_top _ _) (measure_ne_top _ _)]
      exact measure_mono (by intro x; simp)
  ¬∑ intro f hf_disj hf h_eq
    rw [integral_iUnion (fun i ‚Ü¶ (‚Ñ± Œ≥).le n _ (hf i)) hf_disj
      (integrable_densityProcess hŒ∫ŒΩ _ _ hs).integrableOn]
    simp_rw [h_eq]
    rw [iUnion_prod_const, measure_iUnion _ (fun i ‚Ü¶ ((‚Ñ± Œ≥).le n _ (hf i)).prod hs)]
    ¬∑ rw [ENNReal.tsum_toReal_eq]
      exact fun _ ‚Ü¶ measure_ne_top _ _
    ¬∑ intro i j hij
      rw [Function.onFun, Set.disjoint_prod]
      exact Or.inl (hf_disj hij)

lemma set_integral_densityProcess_of_le (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel Œ∫]
    [IsFiniteKernel ŒΩ] {n m : ‚Ñï} (hnm : n ‚â§ m) (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s)
    {A : Set Œ≥} (hA : MeasurableSet[‚Ñ± Œ≥ n] A) :
    ‚à´ t in A, densityProcess Œ∫ ŒΩ m a t s ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ s)).toReal :=
  set_integral_densityProcess hŒ∫ŒΩ m a hs ((‚Ñ± Œ≥).mono hnm A hA)

lemma condexp_densityProcess (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel Œ∫] [IsFiniteKernel ŒΩ]
    {i j : ‚Ñï} (hij : i ‚â§ j) (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    (ŒΩ a)[fun t ‚Ü¶ densityProcess Œ∫ ŒΩ j a t s | ‚Ñ± Œ≥ i]
      =·µê[ŒΩ a] fun t ‚Ü¶ densityProcess Œ∫ ŒΩ i a t s := by
  symm
  refine ae_eq_condexp_of_forall_set_integral_eq ?_ ?_ ?_ ?_ ?_
  ¬∑ exact integrable_densityProcess hŒ∫ŒΩ j a hs
  ¬∑ refine fun t _ _ ‚Ü¶ Integrable.integrableOn ?_
    exact integrable_densityProcess hŒ∫ŒΩ _ _ hs
  ¬∑ intro t ht _
    rw [set_integral_densityProcess hŒ∫ŒΩ i a hs ht,
      set_integral_densityProcess_of_le hŒ∫ŒΩ hij a hs ht]
  ¬∑ exact StronglyMeasurable.aeStronglyMeasurable' (stronglyMeasurable_‚Ñ±_densityProcess Œ∫ ŒΩ i a hs)

lemma martingale_densityProcess (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel Œ∫] [IsFiniteKernel ŒΩ]
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    Martingale (fun n t ‚Ü¶ densityProcess Œ∫ ŒΩ n a t s) (‚Ñ± Œ≥) (ŒΩ a) :=
  ‚ü®adapted_densityProcess Œ∫ ŒΩ a hs, fun _ _ h ‚Ü¶ condexp_densityProcess hŒ∫ŒΩ h a hs‚ü©

lemma densityProcess_mono_set (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) (n : ‚Ñï) (a : Œ±) (t : Œ≥)
    {s s' : Set Œ≤} (h : s ‚äÜ s') :
    densityProcess Œ∫ ŒΩ n a t s ‚â§ densityProcess Œ∫ ŒΩ n a t s' := by
  unfold densityProcess
  by_cases h0 : ŒΩ a (partitionSet n t) = 0
  ¬∑ rw [h0, ENNReal.toReal_div, ENNReal.toReal_div]
    simp
  have h_ne_top : ‚àÄ s, Œ∫ a (partitionSet n t √óÀ¢ s) / ŒΩ a (partitionSet n t) ‚â† ‚ä§ := by
    intro s
    rw [ne_eq, ENNReal.div_eq_top]
    simp only [ne_eq, h0, and_false, false_or, not_and, not_not]
    refine fun h_top ‚Ü¶ eq_top_mono ?_ h_top
    exact apply_partitionSet_le_of_fst_le hŒ∫ŒΩ n a t s
  rw [ENNReal.toReal_le_toReal]
  ¬∑ gcongr
    rw [prod_subset_prod_iff]
    simp [subset_rfl, h]
  ¬∑ exact h_ne_top s
  ¬∑ exact h_ne_top s'

lemma densityProcess_mono_kernel_left {Œ∫' : kernel Œ± (Œ≥ √ó Œ≤)} (hŒ∫Œ∫' : Œ∫ ‚â§ Œ∫')
    (hŒ∫'ŒΩ : kernel.fst Œ∫' ‚â§ ŒΩ) (n : ‚Ñï) (a : Œ±) (t : Œ≥) {s : Set Œ≤} (hs : MeasurableSet s) :
    densityProcess Œ∫ ŒΩ n a t s ‚â§ densityProcess Œ∫' ŒΩ n a t s := by
  unfold densityProcess
  by_cases h0 : ŒΩ a (partitionSet n t) = 0
  ¬∑ rw [h0, ENNReal.toReal_div, ENNReal.toReal_div]
    simp
  have h_le : Œ∫' a (partitionSet n t √óÀ¢ s)
      ‚â§ ŒΩ a (partitionSet n t) := apply_partitionSet_le_of_fst_le hŒ∫'ŒΩ n a t s
  rw [ENNReal.toReal_le_toReal]
  ¬∑ gcongr
    exact hŒ∫Œ∫' _ _ ((measurableSet_partitionSet _ _).prod hs)
  ¬∑ rw [ne_eq, ENNReal.div_eq_top]
    simp only [ne_eq, h0, and_false, false_or, not_and, not_not]
    refine fun h_top ‚Ü¶ eq_top_mono ?_ h_top
    exact (hŒ∫Œ∫' _ _ ((measurableSet_partitionSet _ _).prod hs)).trans h_le
  ¬∑ rw [ne_eq, ENNReal.div_eq_top]
    simp only [ne_eq, h0, and_false, false_or, not_and, not_not]
    exact fun h_top ‚Ü¶ eq_top_mono h_le h_top

lemma densityProcess_antitone_kernel_right {ŒΩ' : kernel Œ± Œ≥}
    (hŒΩŒΩ' : ŒΩ ‚â§ ŒΩ') (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) (n : ‚Ñï) (a : Œ±) (t : Œ≥) (s : Set Œ≤) :
    densityProcess Œ∫ ŒΩ' n a t s ‚â§ densityProcess Œ∫ ŒΩ n a t s := by
  unfold densityProcess
  have h_le : Œ∫ a (partitionSet n t √óÀ¢ s)
      ‚â§ ŒΩ a (partitionSet n t) := apply_partitionSet_le_of_fst_le hŒ∫ŒΩ n a t s
  by_cases h0 : ŒΩ a (partitionSet n t) = 0
  ¬∑ suffices Œ∫ a (partitionSet n t √óÀ¢ s) = 0 by
      simp only [this, ENNReal.zero_div, ENNReal.zero_toReal, h0, le_refl]
    exact le_antisymm (h_le.trans h0.le) zero_le'
  have h0' : ŒΩ' a (partitionSet n t) ‚â† 0 := by
    refine fun h ‚Ü¶ h0 (le_antisymm (le_trans ?_ h.le) zero_le')
    exact hŒΩŒΩ' _ _ (measurableSet_partitionSet _ _)
  rw [ENNReal.toReal_le_toReal]
  ¬∑ gcongr
    exact hŒΩŒΩ' _ _ (measurableSet_partitionSet _ _)
  ¬∑ simp only [ne_eq, ENNReal.div_eq_top, h0', and_false, false_or, not_and, not_not]
    refine fun h_top ‚Ü¶ eq_top_mono ?_ h_top
    exact h_le.trans (hŒΩŒΩ' _ _ (measurableSet_partitionSet _ _))
  ¬∑ simp only [ne_eq, ENNReal.div_eq_top, h0, and_false, false_or, not_and, not_not]
    exact fun h_top ‚Ü¶ eq_top_mono h_le h_top

lemma densityProcess_empty (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (n : ‚Ñï) (a : Œ±) (t : Œ≥) :
    densityProcess Œ∫ ŒΩ n a t ‚àÖ = 0 := by
  simp [densityProcess]

lemma tendsto_densityProcess_atTop_empty_of_antitone (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥)
    [IsFiniteKernel Œ∫] (n : ‚Ñï) (a : Œ±) (t : Œ≥)
    (s : ‚Ñï ‚Üí Set Œ≤) (hs : Antitone s) (hs_iInter : ‚ãÇ i, s i = ‚àÖ)
    (hs_meas : ‚àÄ n, MeasurableSet (s n)) :
    Tendsto (fun m ‚Ü¶ densityProcess Œ∫ ŒΩ n a t (s m)) atTop (ùìù (densityProcess Œ∫ ŒΩ n a t ‚àÖ)) := by
  simp_rw [densityProcess]
  by_cases h0 : ŒΩ a (partitionSet n t) = 0
  ¬∑ simp_rw [h0, ENNReal.toReal_div]
    simp
  refine (ENNReal.tendsto_toReal ?_).comp ?_
  ¬∑ rw [ne_eq, ENNReal.div_eq_top]
    push_neg
    simp
  refine ENNReal.Tendsto.div_const ?_ ?_
  ¬∑ have h := tendsto_measure_iInter (Œº := Œ∫ a)
      (s := fun m ‚Ü¶ partitionSet n t √óÀ¢ s m) ?_ ?_ ?_
    ¬∑ convert h
      rw [‚Üê prod_iInter, hs_iInter]
    ¬∑ exact fun n ‚Ü¶ MeasurableSet.prod (measurableSet_partitionSet _ _) (hs_meas n)
    ¬∑ intro m m' hmm'
      simp only [le_eq_subset, prod_subset_prod_iff, subset_rfl, true_and]
      exact Or.inl <| hs hmm'
    ¬∑ exact ‚ü®0, measure_ne_top _ _‚ü©
  ¬∑ simp only [prod_empty, OuterMeasure.empty', ne_eq, not_true_eq_false, false_or, h0,
      not_false_iff]

lemma tendsto_densityProcess_atTop_of_antitone (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥)
    [IsFiniteKernel Œ∫] (n : ‚Ñï) (a : Œ±) (t : Œ≥)
    (s : ‚Ñï ‚Üí Set Œ≤) (hs : Antitone s) (hs_iInter : ‚ãÇ i, s i = ‚àÖ)
    (hs_meas : ‚àÄ n, MeasurableSet (s n)) :
    Tendsto (fun m ‚Ü¶ densityProcess Œ∫ ŒΩ n a t (s m)) atTop (ùìù 0) := by
  rw [‚Üê densityProcess_empty Œ∫ ŒΩ n a t]
  exact tendsto_densityProcess_atTop_empty_of_antitone Œ∫ ŒΩ n a t s hs hs_iInter hs_meas

lemma tendsto_densityProcess_limitProcess (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel Œ∫]
    [IsFiniteKernel ŒΩ] (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    ‚àÄ·µê t ‚àÇ(ŒΩ a), Tendsto (fun n ‚Ü¶ densityProcess Œ∫ ŒΩ n a t s) atTop
      (ùìù ((‚Ñ± Œ≥).limitProcess (fun n t ‚Ü¶ densityProcess Œ∫ ŒΩ n a t s) (ŒΩ a) t)) := by
  refine Submartingale.ae_tendsto_limitProcess (martingale_densityProcess hŒ∫ŒΩ a hs).submartingale
    (R := (ŒΩ a univ).toNNReal) (fun n ‚Ü¶ ?_)
  refine (snorm_densityProcess_le hŒ∫ŒΩ n a s).trans_eq ?_
  rw [ENNReal.coe_toNNReal]
  exact measure_ne_top _ _

lemma limitProcess_mem_L1 (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel Œ∫] [IsFiniteKernel ŒΩ]
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    Mem‚Ñíp ((‚Ñ± Œ≥).limitProcess (fun n t ‚Ü¶ densityProcess Œ∫ ŒΩ n a t s) (ŒΩ a)) 1 (ŒΩ a) := by
  refine Submartingale.mem‚Ñíp_limitProcess (martingale_densityProcess hŒ∫ŒΩ a hs).submartingale
    (R := (ŒΩ a univ).toNNReal) (fun n ‚Ü¶ ?_)
  refine (snorm_densityProcess_le hŒ∫ŒΩ n a s).trans_eq ?_
  rw [ENNReal.coe_toNNReal]
  exact measure_ne_top _ _

lemma tendsto_snorm_one_densityProcess_limitProcess (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel Œ∫]
    [IsFiniteKernel ŒΩ] (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    Tendsto (fun n ‚Ü¶ snorm ((fun t ‚Ü¶ densityProcess Œ∫ ŒΩ n a t s)
        - (‚Ñ± Œ≥).limitProcess (fun n t ‚Ü¶ densityProcess Œ∫ ŒΩ n a t s) (ŒΩ a)) 1 (ŒΩ a))
      atTop (ùìù 0) := by
  refine Submartingale.tendsto_snorm_one_limitProcess ?_ ?_
  ¬∑ exact (martingale_densityProcess hŒ∫ŒΩ a hs).submartingale
  ¬∑ refine uniformIntegrable_of le_rfl ENNReal.one_ne_top ?_ ?_
    ¬∑ exact fun n ‚Ü¶ (measurable_densityProcess_right Œ∫ ŒΩ n a hs).aestronglyMeasurable
    ¬∑ intro Œµ _
      refine ‚ü®2, fun n ‚Ü¶ ?_‚ü©
      refine le_of_eq_of_le ?_ (?_ : 0 ‚â§ ENNReal.ofReal Œµ)
      ¬∑ have : {x | 2 ‚â§ ‚ÄñdensityProcess Œ∫ ŒΩ n a x s‚Äñ‚Çä} = ‚àÖ := by
          ext x
          simp only [mem_setOf_eq, mem_empty_iff_false, iff_false, not_le]
          refine (?_ : _ ‚â§ (1 : ‚Ñù‚â•0)).trans_lt one_lt_two
          rw [Real.nnnorm_of_nonneg (densityProcess_nonneg _ _ _ _ _ _)]
          exact mod_cast (densityProcess_le_one hŒ∫ŒΩ _ _ _ _)
        rw [this]
        simp
      ¬∑ simp

lemma tendsto_snorm_one_restrict_densityProcess_limitProcess [IsFiniteKernel Œ∫] [IsFiniteKernel ŒΩ]
    (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) (A : Set Œ≥) :
    Tendsto (fun n ‚Ü¶ snorm ((fun t ‚Ü¶ densityProcess Œ∫ ŒΩ n a t s)
        - (‚Ñ± Œ≥).limitProcess (fun n t ‚Ü¶ densityProcess Œ∫ ŒΩ n a t s) (ŒΩ a)) 1 ((ŒΩ a).restrict A))
      atTop (ùìù 0) :=
  tendsto_snorm_restrict_zero (tendsto_snorm_one_densityProcess_limitProcess hŒ∫ŒΩ a hs) A

noncomputable
def MLimsup (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (a : Œ±) (t : Œ≥) (s : Set Œ≤) : ‚Ñù :=
  limsup (fun n ‚Ü¶ densityProcess Œ∫ ŒΩ n a t s) atTop

lemma mLimsup_ae_eq_limitProcess (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel Œ∫] [IsFiniteKernel ŒΩ]
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    (fun t ‚Ü¶ MLimsup Œ∫ ŒΩ a t s)
      =·µê[ŒΩ a] (‚Ñ± Œ≥).limitProcess (fun n t ‚Ü¶ densityProcess Œ∫ ŒΩ n a t s) (ŒΩ a) := by
  filter_upwards [tendsto_densityProcess_limitProcess hŒ∫ŒΩ a hs] with t ht using ht.limsup_eq

lemma tendsto_m_mLimsup (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) (a : Œ±) [IsFiniteKernel Œ∫] [IsFiniteKernel ŒΩ]
    {s : Set Œ≤} (hs : MeasurableSet s) :
    ‚àÄ·µê t ‚àÇ(ŒΩ a),
      Tendsto (fun n ‚Ü¶ densityProcess Œ∫ ŒΩ n a t s) atTop (ùìù (MLimsup Œ∫ ŒΩ a t s)) := by
  filter_upwards [tendsto_densityProcess_limitProcess hŒ∫ŒΩ a hs, mLimsup_ae_eq_limitProcess hŒ∫ŒΩ a hs]
    with t h1 h2 using h2 ‚ñ∏ h1

lemma measurable_mLimsup (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥)
    {s : Set Œ≤} (hs : MeasurableSet s) :
    Measurable (fun (p : Œ± √ó Œ≥) ‚Ü¶ MLimsup Œ∫ ŒΩ p.1 p.2 s) :=
  measurable_limsup (fun n ‚Ü¶ measurable_densityProcess Œ∫ ŒΩ n hs)

lemma measurable_mLimsup_left (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (t : Œ≥)
    {s : Set Œ≤} (hs : MeasurableSet s) :
    Measurable (fun a ‚Ü¶ MLimsup Œ∫ ŒΩ a t s) := by
  change Measurable ((fun (p : Œ± √ó Œ≥) ‚Ü¶ MLimsup Œ∫ ŒΩ p.1 p.2 s) ‚àò (fun a ‚Ü¶ (a, t)))
  exact (measurable_mLimsup Œ∫ ŒΩ hs).comp measurable_prod_mk_right

lemma measurable_mLimsup_right (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥)
    {s : Set Œ≤} (hs : MeasurableSet s) (a : Œ±) :
    Measurable (fun t ‚Ü¶ MLimsup Œ∫ ŒΩ a t s) := by
  change Measurable ((fun (p : Œ± √ó Œ≥) ‚Ü¶ MLimsup Œ∫ ŒΩ p.1 p.2 s) ‚àò (fun t ‚Ü¶ (a, t)))
  exact (measurable_mLimsup Œ∫ ŒΩ hs).comp measurable_prod_mk_left

lemma mLimsup_mono_set (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) (a : Œ±) (t : Œ≥) {s s' : Set Œ≤} (h : s ‚äÜ s') :
    MLimsup Œ∫ ŒΩ a t s ‚â§ MLimsup Œ∫ ŒΩ a t s' := by
  refine limsup_le_limsup ?_ ?_ ?_
  ¬∑ exact eventually_of_forall (fun n ‚Ü¶ densityProcess_mono_set hŒ∫ŒΩ n a t h)
  ¬∑ exact isCoboundedUnder_le_of_le atTop (fun i ‚Ü¶ densityProcess_nonneg _ _ _ _ _ _)
  ¬∑ exact isBoundedUnder_of ‚ü®1, fun n ‚Ü¶ densityProcess_le_one hŒ∫ŒΩ _ _ _ _‚ü©

lemma mLimsup_nonneg (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) (a : Œ±) (t : Œ≥) (s : Set Œ≤) :
    0 ‚â§ MLimsup Œ∫ ŒΩ a t s := by
  refine le_limsup_of_frequently_le ?_ ?_
  ¬∑ exact frequently_of_forall (fun n ‚Ü¶ densityProcess_nonneg _ _ _ _ _ _)
  ¬∑ exact isBoundedUnder_of ‚ü®1, fun n ‚Ü¶ densityProcess_le_one hŒ∫ŒΩ _ _ _ _‚ü©

lemma mLimsup_le_one (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) (a : Œ±) (t : Œ≥) (s : Set Œ≤) :
    MLimsup Œ∫ ŒΩ a t s ‚â§ 1 := by
  refine limsup_le_of_le ?_ ?_
  ¬∑ exact isCoboundedUnder_le_of_le atTop (fun i ‚Ü¶ densityProcess_nonneg _ _ _ _ _ _)
  ¬∑ exact eventually_of_forall (fun n ‚Ü¶ densityProcess_le_one hŒ∫ŒΩ _ _ _ _)

lemma snorm_mLimsup_le (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) (a : Œ±) (s : Set Œ≤) :
    snorm (fun t ‚Ü¶ MLimsup Œ∫ ŒΩ a t s) 1 (ŒΩ a) ‚â§ ŒΩ a univ := by
  refine (snorm_le_of_ae_bound (C := 1) (ae_of_all _ (fun t ‚Ü¶ ?_))).trans ?_
  ¬∑ simp only [Real.norm_eq_abs, abs_of_nonneg (mLimsup_nonneg hŒ∫ŒΩ a t s),
      mLimsup_le_one hŒ∫ŒΩ a t s]
  ¬∑ simp

lemma integrable_mLimsup (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel ŒΩ]
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    Integrable (fun t ‚Ü¶ MLimsup Œ∫ ŒΩ a t s) (ŒΩ a) := by
  rw [‚Üê mem‚Ñíp_one_iff_integrable]
  refine ‚ü®Measurable.aestronglyMeasurable ?_, ?_‚ü©
  ¬∑ exact measurable_mLimsup_right Œ∫ ŒΩ hs a
  ¬∑ exact (snorm_mLimsup_le hŒ∫ŒΩ a s).trans_lt (measure_lt_top _ _)

lemma tendsto_set_integral_m (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel Œ∫] [IsFiniteKernel ŒΩ]
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) (A : Set Œ≥) :
    Tendsto (fun i ‚Ü¶ ‚à´ x in A, densityProcess Œ∫ ŒΩ i a x s ‚àÇ(ŒΩ a)) atTop
      (ùìù (‚à´ x in A, MLimsup Œ∫ ŒΩ a x s ‚àÇ(ŒΩ a))) := by
  refine tendsto_set_integral_of_L1' (Œº := ŒΩ a) (fun t ‚Ü¶ MLimsup Œ∫ ŒΩ a t s)
    (integrable_mLimsup hŒ∫ŒΩ a hs) (F := fun i t ‚Ü¶ densityProcess Œ∫ ŒΩ i a t s) (l := atTop)
    (eventually_of_forall (fun n ‚Ü¶ integrable_densityProcess hŒ∫ŒΩ _ _ hs)) ?_ A
  refine (tendsto_congr fun n ‚Ü¶ ?_).mp (tendsto_snorm_one_densityProcess_limitProcess hŒ∫ŒΩ a hs)
  refine snorm_congr_ae ?_
  exact EventuallyEq.rfl.sub (mLimsup_ae_eq_limitProcess hŒ∫ŒΩ a hs).symm

/-- Auxiliary lemma for `set_integral_mLimsup`. -/
lemma set_integral_mLimsup_of_measurableSet (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel Œ∫]
    [IsFiniteKernel ŒΩ]
    (n : ‚Ñï) (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) {A : Set Œ≥} (hA : MeasurableSet[‚Ñ± Œ≥ n] A) :
    ‚à´ t in A, MLimsup Œ∫ ŒΩ a t s ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ s)).toReal := by
  suffices ‚à´ t in A, MLimsup Œ∫ ŒΩ a t s ‚àÇ(ŒΩ a) = ‚à´ t in A, densityProcess Œ∫ ŒΩ n a t s ‚àÇ(ŒΩ a) by
    rw [this]
    exact set_integral_densityProcess hŒ∫ŒΩ _ _ hs hA
  suffices ‚à´ t in A, MLimsup Œ∫ ŒΩ a t s ‚àÇ(ŒΩ a)
      = limsup (fun i ‚Ü¶ ‚à´ t in A, densityProcess Œ∫ ŒΩ i a t s ‚àÇ(ŒΩ a)) atTop by
    rw [this, ‚Üê limsup_const (Œ± := ‚Ñï) (f := atTop) (‚à´ t in A, densityProcess Œ∫ ŒΩ n a t s ‚àÇ(ŒΩ a)),
      limsup_congr]
    simp only [eventually_atTop, ge_iff_le]
    refine ‚ü®n, fun m hnm ‚Ü¶ ?_‚ü©
    rw [set_integral_densityProcess_of_le hŒ∫ŒΩ hnm _ hs hA,
      set_integral_densityProcess hŒ∫ŒΩ _ _ hs hA]
  -- use L1 convergence
  have h := tendsto_set_integral_m hŒ∫ŒΩ a hs A
  rw [h.limsup_eq]

lemma integral_mLimsup (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel Œ∫] [IsFiniteKernel ŒΩ]
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    ‚à´ t, MLimsup Œ∫ ŒΩ a t s ‚àÇ(ŒΩ a) = (Œ∫ a (univ √óÀ¢ s)).toReal := by
  rw [‚Üê integral_univ, set_integral_mLimsup_of_measurableSet hŒ∫ŒΩ 0 a hs MeasurableSet.univ]

lemma set_integral_mLimsup (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel Œ∫] [IsFiniteKernel ŒΩ]
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) {A : Set Œ≥} (hA : MeasurableSet A) :
    ‚à´ t in A, MLimsup Œ∫ ŒΩ a t s ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ s)).toReal := by
  have hA' : MeasurableSet[‚®Ü n, ‚Ñ± Œ≥ n] A := by rwa [iSup_‚Ñ±]
  refine MeasurableSpace.induction_on_inter (m := ‚®Ü n, ‚Ñ± Œ≥ n)
    (C := fun A ‚Ü¶ ‚à´ t in A, MLimsup Œ∫ ŒΩ a t s ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ s)).toReal)
    (MeasurableSpace.measurableSpace_iSup_eq (‚Ñ± Œ≥)) ?_ ?_ ?_ ?_ ?_ hA'
  ¬∑ rintro s ‚ü®n, hs‚ü© t ‚ü®m, ht‚ü© _
    exact ‚ü®max n m, ((‚Ñ± Œ≥).mono (le_max_left n m) _ hs).inter ((‚Ñ± Œ≥).mono (le_max_right n m) _ ht)‚ü©
  ¬∑ simp
  ¬∑ intro A ‚ü®n, hA‚ü©
    exact set_integral_mLimsup_of_measurableSet hŒ∫ŒΩ n a hs hA
  ¬∑ intro A hA hA_eq
    rw [iSup_‚Ñ±] at hA
    have h := integral_add_compl hA (integrable_mLimsup hŒ∫ŒΩ a hs)
    rw [hA_eq, integral_mLimsup hŒ∫ŒΩ a hs] at h
    have : A·∂ú √óÀ¢ s = univ √óÀ¢ s \ A √óÀ¢ s := by
      rw [prod_diff_prod, compl_eq_univ_diff]
      simp
    rw [this, measure_diff (by intro x; simp) (hA.prod hs) (measure_ne_top (Œ∫ a) _),
      ENNReal.toReal_sub_of_le (measure_mono (by intro x; simp)) (measure_ne_top _ _)]
    rw [eq_tsub_iff_add_eq_of_le, add_comm]
    ¬∑ exact h
    ¬∑ rw [ENNReal.toReal_le_toReal (measure_ne_top _ _) (measure_ne_top _ _)]
      exact measure_mono (by intro x; simp)
  ¬∑ intro f hf_disj hf h_eq
    rw [integral_iUnion _ hf_disj (integrable_mLimsup hŒ∫ŒΩ _ hs).integrableOn]
    ¬∑ simp_rw [h_eq]
      rw [‚Üê ENNReal.tsum_toReal_eq (fun _ ‚Ü¶ measure_ne_top _ _)]
      congr
      rw [iUnion_prod_const, measure_iUnion]
      ¬∑ intro i j hij
        rw [Function.onFun, Set.disjoint_prod]
        exact Or.inl (hf_disj hij)
      ¬∑ rw [iSup_‚Ñ±] at hf
        exact fun i ‚Ü¶ (hf i).prod hs
    ¬∑ rwa [iSup_‚Ñ±] at hf

lemma tendsto_integral_mLimsup_of_monotone (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel Œ∫]
    [IsFiniteKernel ŒΩ]
    (a : Œ±) (s : ‚Ñï ‚Üí Set Œ≤) (hs : Monotone s) (hs_iUnion : ‚ãÉ i, s i = univ)
    (hs_meas : ‚àÄ n, MeasurableSet (s n)) :
    Tendsto (fun m ‚Ü¶ ‚à´ t, MLimsup Œ∫ ŒΩ a t (s m) ‚àÇ(ŒΩ a)) atTop (ùìù (Œ∫ a univ).toReal) := by
  simp_rw [integral_mLimsup hŒ∫ŒΩ a (hs_meas _)]
  have h_cont := ENNReal.continuousOn_toReal.continuousAt (x := Œ∫ a univ) ?_
  swap
  ¬∑ rw [mem_nhds_iff]
    refine ‚ü®Iio (Œ∫ a univ + 1), fun x hx ‚Ü¶ ne_top_of_lt (?_ : x < Œ∫ a univ + 1), isOpen_Iio, ?_‚ü©
    ¬∑ simpa using hx
    ¬∑ simp only [mem_Iio]
      exact ENNReal.lt_add_right (measure_ne_top _ _) one_ne_zero
  refine h_cont.tendsto.comp ?_
  have h := tendsto_measure_iUnion (s := fun n ‚Ü¶ univ √óÀ¢ s n) (Œº := Œ∫ a) ?_
  swap; ¬∑ intro n m hnm x; simp only [mem_prod, mem_univ, true_and]; exact fun h ‚Ü¶ hs hnm h
  convert h
  rw [‚Üê prod_iUnion, hs_iUnion]
  simp only [univ_prod_univ, measure_univ]

lemma tendsto_integral_mLimsup_of_antitone (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel Œ∫]
    [IsFiniteKernel ŒΩ]
    (a : Œ±) (s : ‚Ñï ‚Üí Set Œ≤) (hs : Antitone s) (hs_iInter : ‚ãÇ i, s i = ‚àÖ)
    (hs_meas : ‚àÄ n, MeasurableSet (s n)) :
    Tendsto (fun m ‚Ü¶ ‚à´ t, MLimsup Œ∫ ŒΩ a t (s m) ‚àÇ(ŒΩ a)) atTop (ùìù 0) := by
  simp_rw [integral_mLimsup hŒ∫ŒΩ a (hs_meas _)]
  rw [‚Üê ENNReal.zero_toReal]
  have h_cont := ENNReal.continuousOn_toReal.continuousAt (x := 0) ?_
  swap
  ¬∑ rw [mem_nhds_iff]
    refine ‚ü®Iio 1, fun x hx ‚Ü¶ ne_top_of_lt (?_ : x < 1), isOpen_Iio, ?_‚ü©
    ¬∑ simpa using hx
    ¬∑ simp
  refine h_cont.tendsto.comp ?_
  have h := tendsto_measure_iInter (s := fun n ‚Ü¶ univ √óÀ¢ s n) (Œº := Œ∫ a)
    (fun n ‚Ü¶ MeasurableSet.univ.prod (hs_meas n)) ?_ ?_
  rotate_left
  ¬∑ intro n m hnm x; simp only [mem_prod, mem_univ, true_and]; exact fun h ‚Ü¶ hs hnm h
  ¬∑ refine ‚ü®0, measure_ne_top _ _‚ü©
  convert h
  rw [‚Üê prod_iInter, hs_iInter]
  simp only [ne_eq, prod_empty, OuterMeasure.empty', forall_exists_index]

lemma tendsto_mLimsup_atTop_ae_of_antitone (hŒ∫ŒΩ : kernel.fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel Œ∫]
    [IsFiniteKernel ŒΩ] (a : Œ±) (s : ‚Ñï ‚Üí Set Œ≤) (hs : Antitone s) (hs_iInter : ‚ãÇ i, s i = ‚àÖ)
    (hs_meas : ‚àÄ n, MeasurableSet (s n)) :
    ‚àÄ·µê t ‚àÇ(ŒΩ a), Tendsto (fun m ‚Ü¶ MLimsup Œ∫ ŒΩ a t (s m)) atTop (ùìù 0) := by
  have h_anti : ‚àÄ t, Antitone (fun m ‚Ü¶ MLimsup Œ∫ ŒΩ a t (s m)) :=
    fun t n m hnm ‚Ü¶ mLimsup_mono_set hŒ∫ŒΩ a t (hs hnm)
  have h_le_one : ‚àÄ m t, MLimsup Œ∫ ŒΩ a t (s m) ‚â§ 1 := fun m t ‚Ü¶ mLimsup_le_one hŒ∫ŒΩ a t (s m)
  -- for all `t`, `fun m ‚Ü¶ MLimsup Œ∫ a (s m) t` has a limit
  have h_exists : ‚àÄ t, ‚àÉ l, Tendsto (fun m ‚Ü¶ MLimsup Œ∫ ŒΩ a t (s m)) atTop (ùìù l) := by
    intro t
    have h_tendsto : Tendsto (fun m ‚Ü¶ MLimsup Œ∫ ŒΩ a t (s m)) atTop atBot ‚à®
        ‚àÉ l, Tendsto (fun m ‚Ü¶ MLimsup Œ∫ ŒΩ a t (s m)) atTop (ùìù l) :=
      tendsto_of_antitone (h_anti t)
    cases' h_tendsto with h_absurd h_tendsto
    ¬∑ rw [tendsto_atTop_atBot_iff_of_antitone (h_anti t)] at h_absurd
      obtain ‚ü®r, hr‚ü© := h_absurd (-1)
      have h_nonneg := mLimsup_nonneg hŒ∫ŒΩ a t (s r)
      linarith
    ¬∑ exact h_tendsto
  -- let `F` be the pointwise limit of `fun m ‚Ü¶ MLimsup Œ∫ a (s m) t` for all `t`
  let F : Œ≥ ‚Üí ‚Ñù := fun t ‚Ü¶ (h_exists t).choose
  have hF_tendsto : ‚àÄ t, Tendsto (fun m ‚Ü¶ MLimsup Œ∫ ŒΩ a t (s m)) atTop (ùìù (F t)) :=
    fun t ‚Ü¶ (h_exists t).choose_spec
  have hF_nonneg : ‚àÄ t, 0 ‚â§ F t :=
    fun t ‚Ü¶ ge_of_tendsto' (hF_tendsto t) (fun m ‚Ü¶ mLimsup_nonneg hŒ∫ŒΩ a t (s m))
  have hF_le_one : ‚àÄ t, F t ‚â§ 1 := fun t ‚Ü¶ le_of_tendsto' (hF_tendsto t) (fun m ‚Ü¶ h_le_one m t)
  have hF_int : Integrable F (ŒΩ a) := by
    rw [‚Üê mem‚Ñíp_one_iff_integrable]
    refine ‚ü®?_, ?_‚ü©
    ¬∑ refine aestronglyMeasurable_of_tendsto_ae atTop (fun n ‚Ü¶ ?_) (ae_of_all _ hF_tendsto)
      exact (measurable_mLimsup_right Œ∫ ŒΩ (hs_meas _) a).aestronglyMeasurable
    ¬∑ rw [snorm_one_eq_lintegral_nnnorm]
      calc ‚à´‚Åª x, ‚ÄñF x‚Äñ‚Çä ‚àÇ(ŒΩ a) ‚â§ ‚à´‚Åª _, 1 ‚àÇ(ŒΩ a) := by
            refine lintegral_mono (fun x ‚Ü¶ ?_)
            rw [‚Üê ofReal_norm_eq_coe_nnnorm, Real.norm_eq_abs, ENNReal.ofReal_le_one,
              abs_of_nonneg (hF_nonneg _)]
            exact hF_le_one _
      _ < ‚ä§ := by
            simp only [lintegral_const, one_mul]
            exact measure_lt_top _ _
   -- it suffices to show that the limit `F` is 0 a.e.
  suffices ‚àÄ·µê t ‚àÇ(ŒΩ a), F t = 0 by
    filter_upwards [this] with t ht_eq
    rw [‚Üê ht_eq]
    exact hF_tendsto t
  -- since `F` is nonnegative, proving that its integral is 0 is sufficient to get that
  -- `F` is 0 a.e.
  suffices ‚àÄ·µê (t : Œ≥) ‚àÇ(ŒΩ a), 0 = F t by filter_upwards [this] with a ha; simp [ha]
  refine ae_eq_of_integral_eq_of_ae_le (integrable_const _) hF_int  (ae_of_all _ hF_nonneg) ?_
  have h_integral :
      Tendsto (fun m : ‚Ñï ‚Ü¶ ‚à´ t, MLimsup Œ∫ ŒΩ a t (s m) ‚àÇ(ŒΩ a)) atTop (ùìù (‚à´ t, F t ‚àÇ(ŒΩ a))) := by
    refine integral_tendsto_of_tendsto_of_antitone ?_ hF_int ?_ ?_
    ¬∑ exact fun n ‚Ü¶ integrable_mLimsup hŒ∫ŒΩ _ (hs_meas n)
    ¬∑ exact ae_of_all _ h_anti
    ¬∑ exact ae_of_all _ hF_tendsto
  have h_integral' :
      Tendsto (fun m : ‚Ñï ‚Ü¶ ‚à´ t, MLimsup Œ∫ ŒΩ a t (s m) ‚àÇ(ŒΩ a)) atTop (ùìù (‚à´ _, 0 ‚àÇ(ŒΩ a))) := by
    simp only [integral_zero]
    exact tendsto_integral_mLimsup_of_antitone hŒ∫ŒΩ a s hs hs_iInter hs_meas
  exact (tendsto_nhds_unique h_integral h_integral').symm

section UnivFst

lemma densityProcess_univ [IsFiniteKernel Œ∫] (n : ‚Ñï) (a : Œ±) (t : Œ≥) :
    densityProcess Œ∫ (kernel.fst Œ∫) n a t univ
      = if kernel.fst Œ∫ a (partitionSet n t) = 0 then 0 else 1 := by
  rw [densityProcess]
  by_cases h : kernel.fst Œ∫ a (partitionSet n t) = 0
  ¬∑ simp [h]
    by_cases h' : Œ∫ a (partitionSet n t √óÀ¢ univ) = 0
    ¬∑ simp [h']
    ¬∑ rw [ENNReal.div_zero h']
      simp
  ¬∑ simp only [h, ite_false]
    rw [kernel.fst_apply' _ _ (measurableSet_partitionSet _ _)]
    have : partitionSet n t √óÀ¢ univ = {p : Œ≥ √ó Œ≤ | p.1 ‚àà partitionSet n t} := by
      ext x
      simp
    rw [this, ENNReal.div_self]
    ¬∑ simp
    ¬∑ rwa [kernel.fst_apply' _ _ (measurableSet_partitionSet _ _)] at h
    ¬∑ exact measure_ne_top _ _

lemma densityProcess_univ_ae (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) [IsFiniteKernel Œ∫] (n : ‚Ñï) (a : Œ±) :
    ‚àÄ·µê t ‚àÇ(kernel.fst Œ∫ a), densityProcess Œ∫ (kernel.fst Œ∫) n a t univ = 1 := by
  rw [ae_iff]
  have : {t | ¬¨ densityProcess Œ∫ (kernel.fst Œ∫) n a t univ = 1}
      ‚äÜ {t | kernel.fst Œ∫ a (partitionSet n t) = 0} := by
    intro t ht
    simp only [mem_setOf_eq] at ht ‚ä¢
    rw [densityProcess_univ] at ht
    simpa using ht
  refine measure_mono_null this ?_
  have : {t | kernel.fst Œ∫ a (partitionSet n t) = 0}
      ‚äÜ ‚ãÉ (u) (_ : u ‚àà MeasurableSpace.countablePartition Œ≥ n) (_ : kernel.fst Œ∫ a u = 0), u := by
    intro t ht
    simp only [mem_setOf_eq, mem_iUnion, exists_prop] at ht ‚ä¢
    exact ‚ü®partitionSet n t, partitionSet_mem _ _, ht, mem_partitionSet _ _‚ü©
  refine measure_mono_null this ?_
  rw [measure_biUnion]
  ¬∑ simp
  ¬∑ exact (MeasurableSpace.finite_countablePartition _ _).countable
  ¬∑ intro s hs t ht hst
    simp only [disjoint_iUnion_right, disjoint_iUnion_left]
    exact fun _ _ ‚Ü¶ MeasurableSpace.disjoint_countablePartition n hs ht hst
  ¬∑ intro s hs
    by_cases h : kernel.fst Œ∫ a s = 0
    ¬∑ simp [h, MeasurableSpace.measurableSet_countablePartition n hs]
    ¬∑ simp [h]

lemma tendsto_densityProcess_atTop_univ_of_monotone (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤))
    (n : ‚Ñï) (a : Œ±) (t : Œ≥) (s : ‚Ñï ‚Üí Set Œ≤) (hs : Monotone s) (hs_iUnion : ‚ãÉ i, s i = univ) :
    Tendsto (fun m ‚Ü¶ densityProcess Œ∫ (kernel.fst Œ∫) n a t (s m)) atTop
      (ùìù (densityProcess Œ∫ (kernel.fst Œ∫) n a t univ)) := by
  simp_rw [densityProcess]
  refine (ENNReal.tendsto_toReal ?_).comp ?_
  ¬∑ rw [ne_eq, ENNReal.div_eq_top]
    push_neg
    simp_rw [kernel.fst_apply' _ _ (measurableSet_partitionSet _ _)]
    constructor
    ¬∑ refine fun h h0 ‚Ü¶ h (measure_mono_null (fun x ‚Ü¶ ?_) h0)
      simp only [mem_prod, mem_setOf_eq, and_imp]
      exact fun h _ ‚Ü¶ h
    ¬∑ refine fun h_top ‚Ü¶ eq_top_mono (measure_mono (fun x ‚Ü¶ ?_)) h_top
      simp only [mem_prod, mem_setOf_eq, and_imp]
      exact fun h _ ‚Ü¶ h
  by_cases h0 : kernel.fst Œ∫ a (partitionSet n t) = 0
  ¬∑ rw [kernel.fst_apply' _ _ (measurableSet_partitionSet _ _)] at h0 ‚ä¢
    suffices ‚àÄ m, Œ∫ a (partitionSet n t √óÀ¢ s m) = 0 by
      simp only [this, h0, ENNReal.zero_div, tendsto_const_nhds_iff]
      suffices Œ∫ a (partitionSet n t √óÀ¢ univ) = 0 by
        simp only [this, ENNReal.zero_div]
      convert h0
      ext x
      simp only [mem_prod, mem_univ, and_true, mem_setOf_eq]
    refine fun m ‚Ü¶ measure_mono_null (fun x ‚Ü¶ ?_) h0
    simp only [mem_prod, mem_setOf_eq, and_imp]
    exact fun h _ ‚Ü¶ h
  refine ENNReal.Tendsto.div_const ?_ ?_
  ¬∑ have h := tendsto_measure_iUnion (Œº := Œ∫ a)
      (s := fun m ‚Ü¶ partitionSet n t √óÀ¢ s m) ?_
    swap
    ¬∑ intro m m' hmm'
      simp only [le_eq_subset, prod_subset_prod_iff, subset_rfl, true_and]
      exact Or.inl <| hs hmm'
    convert h
    rw [‚Üê prod_iUnion, hs_iUnion]
  ¬∑ exact Or.inr h0

lemma tendsto_densityProcess_atTop_ae_of_monotone (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) [IsFiniteKernel Œ∫]
    (n : ‚Ñï) (a : Œ±) (s : ‚Ñï ‚Üí Set Œ≤) (hs : Monotone s) (hs_iUnion : ‚ãÉ i, s i = univ) :
    ‚àÄ·µê t ‚àÇ(kernel.fst Œ∫ a),
      Tendsto (fun m ‚Ü¶ densityProcess Œ∫ (kernel.fst Œ∫) n a t (s m)) atTop (ùìù 1) := by
  filter_upwards [densityProcess_univ_ae Œ∫ n a] with t ht
  rw [‚Üê ht]
  exact tendsto_densityProcess_atTop_univ_of_monotone Œ∫ n a t s hs hs_iUnion

lemma mLimsup_univ (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) [IsFiniteKernel Œ∫] (a : Œ±) :
    ‚àÄ·µê t ‚àÇ(kernel.fst Œ∫ a), MLimsup Œ∫ (kernel.fst Œ∫) a t univ = 1 := by
  have h := fun n ‚Ü¶ densityProcess_univ_ae Œ∫ n a
  rw [‚Üê ae_all_iff] at h
  filter_upwards [h] with t ht
  rw [MLimsup]
  simp [ht]

lemma tendsto_mLimsup_atTop_ae_of_monotone [IsFiniteKernel Œ∫]
    (a : Œ±) (s : ‚Ñï ‚Üí Set Œ≤) (hs : Monotone s) (hs_iUnion : ‚ãÉ i, s i = univ)
    (hs_meas : ‚àÄ n, MeasurableSet (s n)) :
    ‚àÄ·µê t ‚àÇ(kernel.fst Œ∫ a), Tendsto (fun m ‚Ü¶ MLimsup Œ∫ (kernel.fst Œ∫) a t (s m)) atTop (ùìù 1) := by
  let ŒΩ := kernel.fst Œ∫
  have h_mono : ‚àÄ t, Monotone (fun m ‚Ü¶ MLimsup Œ∫ (kernel.fst Œ∫) a t (s m)) :=
    fun t n m hnm ‚Ü¶ mLimsup_mono_set le_rfl a t (hs hnm)
  have h_le_one : ‚àÄ m t, MLimsup Œ∫ ŒΩ a t (s m) ‚â§ 1 := fun m t ‚Ü¶ mLimsup_le_one le_rfl a t (s m)
  -- for all `t`, `fun m ‚Ü¶ MLimsup Œ∫ a (s m) t` has a limit
  have h_exists : ‚àÄ t, ‚àÉ l, Tendsto (fun m ‚Ü¶ MLimsup Œ∫ ŒΩ a t (s m)) atTop (ùìù l) := by
    intro t
    have h_tendsto : Tendsto (fun m ‚Ü¶ MLimsup Œ∫ ŒΩ a t (s m)) atTop atTop ‚à®
        ‚àÉ l, Tendsto (fun m ‚Ü¶ MLimsup Œ∫ ŒΩ a t (s m)) atTop (ùìù l) :=
      tendsto_of_monotone (h_mono t)
    cases' h_tendsto with h_absurd h_tendsto
    ¬∑ rw [tendsto_atTop_atTop_iff_of_monotone (h_mono t)] at h_absurd
      obtain ‚ü®r, hr‚ü© := h_absurd 2
      exact absurd (hr.trans (h_le_one r t)) one_lt_two.not_le
    ¬∑ exact h_tendsto
  -- let `F` be the pointwise limit of `fun m ‚Ü¶ MLimsup Œ∫ a (s m) t` for all `t`
  let F : Œ≥ ‚Üí ‚Ñù := fun t ‚Ü¶ (h_exists t).choose
  have hF_tendsto : ‚àÄ t, Tendsto (fun m ‚Ü¶ MLimsup Œ∫ ŒΩ a t (s m)) atTop (ùìù (F t)) :=
    fun t ‚Ü¶ (h_exists t).choose_spec
  have hF_nonneg : ‚àÄ t, 0 ‚â§ F t :=
    fun t ‚Ü¶ ge_of_tendsto' (hF_tendsto t) (fun m ‚Ü¶ mLimsup_nonneg le_rfl a t (s m))
  have hF_le_one : ‚àÄ t, F t ‚â§ 1 := fun t ‚Ü¶ le_of_tendsto' (hF_tendsto t) (fun m ‚Ü¶ h_le_one m t)
  have hF_int : Integrable F (ŒΩ a) := by
    rw [‚Üê mem‚Ñíp_one_iff_integrable]
    constructor
    ¬∑ refine aestronglyMeasurable_of_tendsto_ae atTop (fun n ‚Ü¶ ?_) (ae_of_all _ hF_tendsto)
      exact (measurable_mLimsup_right Œ∫ ŒΩ (hs_meas _) a).aestronglyMeasurable
    ¬∑ rw [snorm_one_eq_lintegral_nnnorm]
      calc ‚à´‚Åª x, ‚ÄñF x‚Äñ‚Çä ‚àÇ(ŒΩ a) ‚â§ ‚à´‚Åª _, 1 ‚àÇ(ŒΩ a) := by
            refine lintegral_mono (fun x ‚Ü¶ ?_)
            rw [‚Üê ofReal_norm_eq_coe_nnnorm, Real.norm_eq_abs, ENNReal.ofReal_le_one,
              abs_of_nonneg (hF_nonneg _)]
            exact hF_le_one _
      _ < ‚ä§ := by simp only [lintegral_const, measure_univ, one_mul, measure_lt_top]
   -- it suffices to show that the limit `F` is 1 a.e.
  suffices ‚àÄ·µê t ‚àÇ(ŒΩ a), F t = 1 by
    filter_upwards [this] with t ht_eq
    rw [‚Üê ht_eq]
    exact hF_tendsto t
  -- since `F` is at most 1, proving that its integral is the same as the integral of 1 will tell
  -- us that `F` is 1 a.e.
  refine ae_eq_of_integral_eq_of_ae_le hF_int (integrable_const _) (ae_of_all _ hF_le_one) ?_
  have h_integral :
      Tendsto (fun m : ‚Ñï ‚Ü¶ ‚à´ t, MLimsup Œ∫ ŒΩ a t (s m) ‚àÇ(ŒΩ a)) atTop (ùìù (‚à´ t, F t ‚àÇ(ŒΩ a))) := by
    refine integral_tendsto_of_tendsto_of_monotone ?_ hF_int ?_ ?_
    ¬∑ exact fun n ‚Ü¶ integrable_mLimsup le_rfl _ (hs_meas n)
    ¬∑ exact ae_of_all _ h_mono
    ¬∑ exact ae_of_all _ hF_tendsto
  have h_integral' :
      Tendsto (fun m : ‚Ñï ‚Ü¶ ‚à´ t, MLimsup Œ∫ ŒΩ a t (s m) ‚àÇ(ŒΩ a)) atTop (ùìù (‚à´ _, 1 ‚àÇ(ŒΩ a))) := by
    rw [integral_const]
    simp only [smul_eq_mul, mul_one]
    rw [kernel.fst_apply' _ _ MeasurableSet.univ]
    exact tendsto_integral_mLimsup_of_monotone le_rfl a s hs hs_iUnion hs_meas
  exact tendsto_nhds_unique h_integral h_integral'

end UnivFst

end DensityProcess

end ProbabilityTheory
