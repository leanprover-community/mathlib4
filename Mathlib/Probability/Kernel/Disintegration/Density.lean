/-
Copyright (c) 2024 R√©my Degenne. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: R√©my Degenne
-/
import Mathlib.Probability.Kernel.Composition
import Mathlib.Probability.Martingale.Convergence
import Mathlib.Probability.Process.PartitionFiltration

/-!
# Kernel density

Let `Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)` and `ŒΩ : kernel Œ± Œ≥` be two finite kernels with `kernel.fst Œ∫ ‚â§ ŒΩ`,
where `Œ≥` has a countably generated œÉ-algebra (true in particular for standard Borel spaces).
We build a function `density Œ∫ ŒΩ : Œ± ‚Üí Œ≥ ‚Üí Set Œ≤ ‚Üí ‚Ñù` jointly measurable in the first two arguments
such that for all `a : Œ±` and all measurable sets `s : Set Œ≤` and `A : Set Œ≥`,
`‚à´ x in A, density Œ∫ ŒΩ a x s ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ s)).toReal`.

There are two main applications of this construction (still TODO, in other files).
* Disintegration of kernels: for `Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)`, we want to build a kernel
  `Œ∑ : kernel (Œ± √ó Œ≥) Œ≤` such that `Œ∫ = fst Œ∫ ‚äó‚Çñ Œ∑`. For `Œ≤ = ‚Ñù`, we can use the density of `Œ∫`
  with respect to `fst Œ∫` for intervals to build a kernel cumulative distribution function for `Œ∑`.
  The construction can then be extended to `Œ≤` standard Borel.
* Radon-Nikodym theorem for kernels: for `Œ∫ ŒΩ : kernel Œ± Œ≥`, we can use the density to build a
  Radon-Nikodym derivative of `Œ∫` with respect to `ŒΩ`. We don't need `Œ≤` here but we can apply the
  density construction to `Œ≤ = Unit`. The derivative construction will use `density` but will not
  be exactly equal to it because we will want to remove the `fst Œ∫ ‚â§ ŒΩ` assumption.

## Main definitions

* `ProbabilityTheory.kernel.density`: for `Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)` and `ŒΩ : kernel Œ± Œ≥` two finite
  kernels, `kernel.density Œ∫ ŒΩ` is a function `Œ± ‚Üí Œ≥ ‚Üí Set Œ≤ ‚Üí ‚Ñù`.

## Main statements

* `ProbabilityTheory.kernel.setIntegral_density`: for all measurable sets `A : Set Œ≥` and
  `s : Set Œ≤`, `‚à´ x in A, kernel.density Œ∫ ŒΩ a x s ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ s)).toReal`.
* `ProbabilityTheory.kernel.measurable_density`: the function
  `p : Œ± √ó Œ≥ ‚Ü¶ kernel.density Œ∫ ŒΩ p.1 p.2 s` is measurable.

## Construction of the density

If we were interested only in a fixed `a : Œ±`, then we could use the Radon-Nikodym derivative to
build the density function `density Œ∫ ŒΩ`, as follows.
```
def density' (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel a Œ≥) (a : Œ±) (x : Œ≥) (s : Set Œ≤) : ‚Ñù :=
  (((Œ∫ a).restrict (univ √óÀ¢ s)).fst.rnDeriv (ŒΩ a) x).toReal
```
However, we can't turn those functions for each `a` into a measurable function of the pair `(a, x)`.

In order to obtain measurability through countability, we use the fact that the measurable space `Œ≥`
is countably generated. For each `n : ‚Ñï`, we define (in the file
`Mathlib.Probability.Process.PartitionFiltration`) a finite partition of `Œ≥`, such that those
partitions are finer as `n` grows, and the œÉ-algebra generated by the union of all partitions is the
œÉ-algebra of `Œ≥`. For `x : Œ≥`, `countablePartitionSet n x` denotes the set in the partition such
that `x ‚àà countablePartitionSet n x`.

For a given `n`, the function `densityProcess Œ∫ ŒΩ n : Œ± ‚Üí Œ≥ ‚Üí Set Œ≤ ‚Üí ‚Ñù` defined by
`fun a x s ‚Ü¶ (Œ∫ a (countablePartitionSet n x √óÀ¢ s) / ŒΩ a (countablePartitionSet n x)).toReal` has
the desired property that `‚à´ x in A, densityProcess Œ∫ ŒΩ n a x s ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ s)).toReal` for
all `A` in the œÉ-algebra generated by the partition at scale `n` and is measurable in `(a, x)`.

`countableFiltration Œ≥` is the filtration of those œÉ-algebras for all `n : ‚Ñï`.
The functions `densityProcess Œ∫ ŒΩ n` described here are a bounded `ŒΩ`-martingale for the filtration
`countableFiltration Œ≥`. By Doob's martingale L1 convergence theorem, that martingale converges to
a limit, which has a product-measurable version and satisfies the integral equality for all `A` in
`‚®Ü n, countableFiltration Œ≥ n`. Finally, the partitions were chosen such that that supremum is equal
to the œÉ-algebra on `Œ≥`, hence the equality holds for all measurable sets.
We have obtained the desired density function.

## References

The construction of the density process in this file follows the proof of Theorem 9.27 in
[O. Kallenberg, Foundations of modern probability][kallenberg2021], adapted to use a countably
generated hypothesis instead of specializing to `‚Ñù`.
-/

open MeasureTheory Set Filter MeasurableSpace

open scoped NNReal ENNReal MeasureTheory Topology ProbabilityTheory

namespace ProbabilityTheory.kernel

variable {Œ± Œ≤ Œ≥ : Type*} {mŒ± : MeasurableSpace Œ±} {mŒ≤ : MeasurableSpace Œ≤} {mŒ≥ : MeasurableSpace Œ≥}
    [CountablyGenerated Œ≥] {Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)} {ŒΩ : kernel Œ± Œ≥}

section DensityProcess

/-- An `‚Ñï`-indexed martingale that is a density for `Œ∫` with respect to `ŒΩ` on the sets in
`countablePartition Œ≥ n`. Used to define its limit `ProbabilityTheory.kernel.density`, which is
a density for those kernels for all measurable sets. -/
noncomputable
def densityProcess (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (n : ‚Ñï) (a : Œ±) (x : Œ≥) (s : Set Œ≤) :
    ‚Ñù :=
  (Œ∫ a (countablePartitionSet n x √óÀ¢ s) / ŒΩ a (countablePartitionSet n x)).toReal

lemma densityProcess_def (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (n : ‚Ñï) (a : Œ±) (s : Set Œ≤) :
    (fun t ‚Ü¶ densityProcess Œ∫ ŒΩ n a t s)
      = fun t ‚Ü¶ (Œ∫ a (countablePartitionSet n t √óÀ¢ s) / ŒΩ a (countablePartitionSet n t)).toReal :=
  rfl

lemma measurable_densityProcess_countableFiltration_aux (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥)
    (n : ‚Ñï) {s : Set Œ≤} (hs : MeasurableSet s) :
    Measurable[mŒ±.prod (countableFiltration Œ≥ n)] (fun (p : Œ± √ó Œ≥) ‚Ü¶
      Œ∫ p.1 (countablePartitionSet n p.2 √óÀ¢ s) / ŒΩ p.1 (countablePartitionSet n p.2)) := by
  change Measurable[mŒ±.prod (countableFiltration Œ≥ n)]
      ((fun (p : Œ± √ó countablePartition Œ≥ n) ‚Ü¶ Œ∫ p.1 (‚Üëp.2 √óÀ¢ s) / ŒΩ p.1 p.2)
        ‚àò (fun (p : Œ± √ó Œ≥) ‚Ü¶ (p.1, ‚ü®countablePartitionSet n p.2, countablePartitionSet_mem n p.2‚ü©)))
  have h1 : @Measurable _ _ (mŒ±.prod ‚ä§) _
      (fun p : Œ± √ó countablePartition Œ≥ n ‚Ü¶ Œ∫ p.1 (‚Üëp.2 √óÀ¢ s) / ŒΩ p.1 p.2) := by
    refine Measurable.div ?_ ?_
    ¬∑ refine measurable_from_prod_countable (fun t ‚Ü¶ ?_)
      exact kernel.measurable_coe _ ((measurableSet_countablePartition _ t.prop).prod hs)
    ¬∑ refine measurable_from_prod_countable ?_
      rintro ‚ü®t, ht‚ü©
      exact kernel.measurable_coe _ (measurableSet_countablePartition _ ht)
  refine h1.comp (measurable_fst.prod_mk ?_)
  change @Measurable (Œ± √ó Œ≥) (countablePartition Œ≥ n) (mŒ±.prod (countableFiltration Œ≥ n)) ‚ä§
    ((fun c ‚Ü¶ ‚ü®countablePartitionSet n c, countablePartitionSet_mem n c‚ü©) ‚àò (fun p : Œ± √ó Œ≥ ‚Ü¶ p.2))
  exact (measurable_countablePartitionSet_subtype n ‚ä§).comp measurable_snd

lemma measurable_densityProcess_aux (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (n : ‚Ñï)
    {s : Set Œ≤} (hs : MeasurableSet s) :
    Measurable (fun (p : Œ± √ó Œ≥) ‚Ü¶
      Œ∫ p.1 (countablePartitionSet n p.2 √óÀ¢ s) / ŒΩ p.1 (countablePartitionSet n p.2)) := by
  refine Measurable.mono (measurable_densityProcess_countableFiltration_aux Œ∫ ŒΩ n hs) ?_ le_rfl
  exact sup_le_sup le_rfl (comap_mono ((countableFiltration Œ≥).le _))

lemma measurable_densityProcess (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (n : ‚Ñï)
    {s : Set Œ≤} (hs : MeasurableSet s) :
    Measurable (fun (p : Œ± √ó Œ≥) ‚Ü¶ densityProcess Œ∫ ŒΩ n p.1 p.2 s) :=
  (measurable_densityProcess_aux Œ∫ ŒΩ n hs).ennreal_toReal

lemma measurable_densityProcess_left (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (n : ‚Ñï)
    (x : Œ≥) {s : Set Œ≤} (hs : MeasurableSet s) :
    Measurable (fun a ‚Ü¶ densityProcess Œ∫ ŒΩ n a x s) :=
  (measurable_densityProcess Œ∫ ŒΩ n hs).comp (measurable_id.prod_mk measurable_const)

lemma measurable_densityProcess_right (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (n : ‚Ñï)
    {s : Set Œ≤} (a : Œ±) (hs : MeasurableSet s) :
    Measurable (fun x ‚Ü¶ densityProcess Œ∫ ŒΩ n a x s) :=
  (measurable_densityProcess Œ∫ ŒΩ n hs).comp (measurable_const.prod_mk measurable_id)

lemma measurable_countableFiltration_densityProcess (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (n : ‚Ñï)
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    Measurable[countableFiltration Œ≥ n] (fun x ‚Ü¶ densityProcess Œ∫ ŒΩ n a x s) := by
  refine @Measurable.ennreal_toReal _ (countableFiltration Œ≥ n) _ ?_
  exact (measurable_densityProcess_countableFiltration_aux Œ∫ ŒΩ n hs).comp measurable_prod_mk_left

lemma stronglyMeasurable_countableFiltration_densityProcess (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥)
    (n : ‚Ñï) (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    StronglyMeasurable[countableFiltration Œ≥ n] (fun x ‚Ü¶ densityProcess Œ∫ ŒΩ n a x s) :=
  (measurable_countableFiltration_densityProcess Œ∫ ŒΩ n a hs).stronglyMeasurable

lemma adapted_densityProcess (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (a : Œ±)
    {s : Set Œ≤} (hs : MeasurableSet s) :
    Adapted (countableFiltration Œ≥) (fun n x ‚Ü¶ densityProcess Œ∫ ŒΩ n a x s) :=
  fun n ‚Ü¶ stronglyMeasurable_countableFiltration_densityProcess Œ∫ ŒΩ n a hs

lemma densityProcess_nonneg (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (n : ‚Ñï)
    (a : Œ±) (x : Œ≥) (s : Set Œ≤) :
    0 ‚â§ densityProcess Œ∫ ŒΩ n a x s :=
  ENNReal.toReal_nonneg

lemma meas_countablePartitionSet_le_of_fst_le (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) (n : ‚Ñï) (a : Œ±) (x : Œ≥)
    (s : Set Œ≤) :
    Œ∫ a (countablePartitionSet n x √óÀ¢ s) ‚â§ ŒΩ a (countablePartitionSet n x) := by
  calc Œ∫ a (countablePartitionSet n x √óÀ¢ s)
    ‚â§ fst Œ∫ a (countablePartitionSet n x) := by
        rw [fst_apply' _ _ (measurableSet_countablePartitionSet _ _)]
        refine measure_mono (fun x ‚Ü¶ ?_)
        simp only [mem_prod, mem_setOf_eq, and_imp]
        exact fun h _ ‚Ü¶ h
  _ ‚â§ ŒΩ a (countablePartitionSet n x) := hŒ∫ŒΩ a _

lemma densityProcess_le_one (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) (n : ‚Ñï) (a : Œ±) (x : Œ≥) (s : Set Œ≤) :
    densityProcess Œ∫ ŒΩ n a x s ‚â§ 1 := by
  refine ENNReal.toReal_le_of_le_ofReal zero_le_one (ENNReal.div_le_of_le_mul ?_)
  rw [ENNReal.ofReal_one, one_mul]
  exact meas_countablePartitionSet_le_of_fst_le hŒ∫ŒΩ n a x s

lemma snorm_densityProcess_le (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) (n : ‚Ñï) (a : Œ±) (s : Set Œ≤) :
    snorm (fun x ‚Ü¶ densityProcess Œ∫ ŒΩ n a x s) 1 (ŒΩ a) ‚â§ ŒΩ a univ := by
  refine (snorm_le_of_ae_bound (C := 1) (ae_of_all _ (fun x ‚Ü¶ ?_))).trans ?_
  ¬∑ simp only [Real.norm_eq_abs, abs_of_nonneg (densityProcess_nonneg Œ∫ ŒΩ n a x s),
      densityProcess_le_one hŒ∫ŒΩ n a x s]
  ¬∑ simp

lemma integrable_densityProcess (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel ŒΩ] (n : ‚Ñï)
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    Integrable (fun x ‚Ü¶ densityProcess Œ∫ ŒΩ n a x s) (ŒΩ a) := by
  rw [‚Üê mem‚Ñíp_one_iff_integrable]
  refine ‚ü®Measurable.aestronglyMeasurable ?_, ?_‚ü©
  ¬∑ exact measurable_densityProcess_right Œ∫ ŒΩ n a hs
  ¬∑ exact (snorm_densityProcess_le hŒ∫ŒΩ n a s).trans_lt (measure_lt_top _ _)

lemma setIntegral_densityProcess_of_mem (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) [hŒΩ : IsFiniteKernel ŒΩ]
    (n : ‚Ñï) (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) {u : Set Œ≥}
    (hu : u ‚àà countablePartition Œ≥ n) :
    ‚à´ x in u, densityProcess Œ∫ ŒΩ n a x s ‚àÇ(ŒΩ a) = (Œ∫ a (u √óÀ¢ s)).toReal := by
  have : IsFiniteKernel Œ∫ := isFiniteKernel_of_isFiniteKernel_fst (h := isFiniteKernel_of_le hŒ∫ŒΩ)
  have hu_meas : MeasurableSet u := measurableSet_countablePartition n hu
  simp_rw [densityProcess]
  rw [integral_toReal]
  rotate_left
  ¬∑ refine Measurable.aemeasurable ?_
    change Measurable ((fun (p : Œ± √ó _) ‚Ü¶ Œ∫ p.1 (countablePartitionSet n p.2 √óÀ¢ s)
      / ŒΩ p.1 (countablePartitionSet n p.2)) ‚àò (fun x ‚Ü¶ (a, x)))
    exact (measurable_densityProcess_aux Œ∫ ŒΩ n hs).comp measurable_prod_mk_left
  ¬∑ refine ae_of_all _ (fun x ‚Ü¶ ?_)
    by_cases h0 : ŒΩ a (countablePartitionSet n x) = 0
    ¬∑ suffices Œ∫ a (countablePartitionSet n x √óÀ¢ s) = 0 by simp [h0, this]
      have h0' : fst Œ∫ a (countablePartitionSet n x) = 0 :=
        le_antisymm ((hŒ∫ŒΩ a _).trans h0.le) zero_le'
      rw [fst_apply' _ _ (measurableSet_countablePartitionSet _ _)] at h0'
      refine measure_mono_null (fun x ‚Ü¶ ?_) h0'
      simp only [mem_prod, mem_setOf_eq, and_imp]
      exact fun h _ ‚Ü¶ h
    ¬∑ exact ENNReal.div_lt_top (measure_ne_top _ _) h0
  congr
  have : ‚à´‚Åª x in u, Œ∫ a (countablePartitionSet n x √óÀ¢ s) / ŒΩ a (countablePartitionSet n x) ‚àÇ(ŒΩ a)
      = ‚à´‚Åª _ in u, Œ∫ a (u √óÀ¢ s) / ŒΩ a u ‚àÇ(ŒΩ a) := by
    refine set_lintegral_congr_fun hu_meas (ae_of_all _ (fun t ht ‚Ü¶ ?_))
    rw [countablePartitionSet_of_mem hu ht]
  rw [this]
  simp only [MeasureTheory.lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
  by_cases h0 : ŒΩ a u = 0
  ¬∑ simp only [h0, mul_zero]
    have h0' : fst Œ∫ a u = 0 := le_antisymm ((hŒ∫ŒΩ a _).trans h0.le) zero_le'
    rw [fst_apply' _ _ hu_meas] at h0'
    refine (measure_mono_null ?_ h0').symm
    intro p
    simp only [mem_prod, mem_setOf_eq, and_imp]
    exact fun h _ ‚Ü¶ h
  rw [div_eq_mul_inv, mul_assoc, ENNReal.inv_mul_cancel h0, mul_one]
  exact measure_ne_top _ _

@[deprecated (since := "2024-04-17")]
alias set_integral_densityProcess_of_mem := setIntegral_densityProcess_of_mem

lemma setIntegral_densityProcess (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel ŒΩ]
    (n : ‚Ñï) (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) {A : Set Œ≥}
    (hA : MeasurableSet[countableFiltration Œ≥ n] A) :
    ‚à´ x in A, densityProcess Œ∫ ŒΩ n a x s ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ s)).toReal := by
  have : IsFiniteKernel Œ∫ := isFiniteKernel_of_isFiniteKernel_fst (h := isFiniteKernel_of_le hŒ∫ŒΩ)
  obtain ‚ü®S, hS_subset, rfl‚ü© := (measurableSet_generateFrom_countablePartition_iff _ _).mp hA
  simp_rw [sUnion_eq_iUnion]
  have h_disj : Pairwise (Disjoint on fun i : S ‚Ü¶ (i : Set Œ≥)) := by
    intro u v huv
    #adaptation_note /-- nightly-2024-03-16
    Previously `Function.onFun` unfolded in the following `simp only`,
    but now needs a `rw`.
    This may be a bug: a no import minimization may be required.
    simp only [Finset.coe_sort_coe, Function.onFun] -/
    rw [Function.onFun]
    refine disjoint_countablePartition (hS_subset (by simp)) (hS_subset (by simp)) ?_
    rwa [ne_eq, ‚Üê Subtype.ext_iff]
  rw [integral_iUnion, iUnion_prod_const, measure_iUnion,
      ENNReal.tsum_toReal_eq (fun _ ‚Ü¶ measure_ne_top _ _)]
  ¬∑ congr with u
    rw [setIntegral_densityProcess_of_mem hŒ∫ŒΩ _ _ hs (hS_subset (by simp))]
  ¬∑ intro u v huv
    simp only [Finset.coe_sort_coe, Set.disjoint_prod, disjoint_self, bot_eq_empty]
    exact Or.inl (h_disj huv)
  ¬∑ exact fun _ ‚Ü¶ (measurableSet_countablePartition n (hS_subset (by simp))).prod hs
  ¬∑ exact fun _ ‚Ü¶ measurableSet_countablePartition n (hS_subset (by simp))
  ¬∑ exact h_disj
  ¬∑ exact (integrable_densityProcess hŒ∫ŒΩ _ _ hs).integrableOn

@[deprecated (since := "2024-04-17")]
alias set_integral_densityProcess := setIntegral_densityProcess

lemma integral_densityProcess (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel ŒΩ]
    (n : ‚Ñï) (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    ‚à´ x, densityProcess Œ∫ ŒΩ n a x s ‚àÇ(ŒΩ a) = (Œ∫ a (univ √óÀ¢ s)).toReal := by
  rw [‚Üê integral_univ, setIntegral_densityProcess hŒ∫ŒΩ _ _ hs MeasurableSet.univ]

lemma setIntegral_densityProcess_of_le (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ)
    [IsFiniteKernel ŒΩ] {n m : ‚Ñï} (hnm : n ‚â§ m) (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s)
    {A : Set Œ≥} (hA : MeasurableSet[countableFiltration Œ≥ n] A) :
    ‚à´ x in A, densityProcess Œ∫ ŒΩ m a x s ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ s)).toReal :=
  setIntegral_densityProcess hŒ∫ŒΩ m a hs ((countableFiltration Œ≥).mono hnm A hA)

@[deprecated (since := "2024-04-17")]
alias set_integral_densityProcess_of_le := setIntegral_densityProcess_of_le

lemma condexp_densityProcess (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel ŒΩ]
    {i j : ‚Ñï} (hij : i ‚â§ j) (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    (ŒΩ a)[fun x ‚Ü¶ densityProcess Œ∫ ŒΩ j a x s | countableFiltration Œ≥ i]
      =·µê[ŒΩ a] fun x ‚Ü¶ densityProcess Œ∫ ŒΩ i a x s := by
  refine (ae_eq_condexp_of_forall_setIntegral_eq ?_ ?_ ?_ ?_ ?_).symm
  ¬∑ exact integrable_densityProcess hŒ∫ŒΩ j a hs
  ¬∑ exact fun _ _ _ ‚Ü¶ (integrable_densityProcess hŒ∫ŒΩ _ _ hs).integrableOn
  ¬∑ intro x hx _
    rw [setIntegral_densityProcess hŒ∫ŒΩ i a hs hx,
      setIntegral_densityProcess_of_le hŒ∫ŒΩ hij a hs hx]
  ¬∑ exact StronglyMeasurable.aeStronglyMeasurable'
      (stronglyMeasurable_countableFiltration_densityProcess Œ∫ ŒΩ i a hs)

lemma martingale_densityProcess (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel ŒΩ]
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    Martingale (fun n x ‚Ü¶ densityProcess Œ∫ ŒΩ n a x s) (countableFiltration Œ≥) (ŒΩ a) :=
  ‚ü®adapted_densityProcess Œ∫ ŒΩ a hs, fun _ _ h ‚Ü¶ condexp_densityProcess hŒ∫ŒΩ h a hs‚ü©

lemma densityProcess_mono_set (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) (n : ‚Ñï) (a : Œ±) (x : Œ≥)
    {s s' : Set Œ≤} (h : s ‚äÜ s') :
    densityProcess Œ∫ ŒΩ n a x s ‚â§ densityProcess Œ∫ ŒΩ n a x s' := by
  unfold densityProcess
  by_cases h0 : ŒΩ a (countablePartitionSet n x) = 0
  ¬∑ rw [h0, ENNReal.toReal_div, ENNReal.toReal_div]
    simp
  have h_ne_top : ‚àÄ s,
      Œ∫ a (countablePartitionSet n x √óÀ¢ s) / ŒΩ a (countablePartitionSet n x) ‚â† ‚ä§ := by
    intro s
    rw [ne_eq, ENNReal.div_eq_top]
    simp only [ne_eq, h0, and_false, false_or, not_and, not_not]
    refine fun h_top ‚Ü¶ eq_top_mono ?_ h_top
    exact meas_countablePartitionSet_le_of_fst_le hŒ∫ŒΩ n a x s
  rw [ENNReal.toReal_le_toReal (h_ne_top s) (h_ne_top s')]
  gcongr

lemma densityProcess_mono_kernel_left {Œ∫' : kernel Œ± (Œ≥ √ó Œ≤)} (hŒ∫Œ∫' : Œ∫ ‚â§ Œ∫')
    (hŒ∫'ŒΩ : fst Œ∫' ‚â§ ŒΩ) (n : ‚Ñï) (a : Œ±) (x : Œ≥) (s : Set Œ≤) :
    densityProcess Œ∫ ŒΩ n a x s ‚â§ densityProcess Œ∫' ŒΩ n a x s := by
  unfold densityProcess
  by_cases h0 : ŒΩ a (countablePartitionSet n x) = 0
  ¬∑ rw [h0, ENNReal.toReal_div, ENNReal.toReal_div]
    simp
  have h_le : Œ∫' a (countablePartitionSet n x √óÀ¢ s) ‚â§ ŒΩ a (countablePartitionSet n x) :=
    meas_countablePartitionSet_le_of_fst_le hŒ∫'ŒΩ n a x s
  rw [ENNReal.toReal_le_toReal]
  ¬∑ gcongr
    exact hŒ∫Œ∫' _ _
  ¬∑ rw [ne_eq, ENNReal.div_eq_top]
    simp only [ne_eq, h0, and_false, false_or, not_and, not_not]
    refine fun h_top ‚Ü¶ eq_top_mono ?_ h_top
    exact (hŒ∫Œ∫' _ _).trans h_le
  ¬∑ rw [ne_eq, ENNReal.div_eq_top]
    simp only [ne_eq, h0, and_false, false_or, not_and, not_not]
    exact fun h_top ‚Ü¶ eq_top_mono h_le h_top

lemma densityProcess_antitone_kernel_right {ŒΩ' : kernel Œ± Œ≥}
    (hŒΩŒΩ' : ŒΩ ‚â§ ŒΩ') (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) (n : ‚Ñï) (a : Œ±) (x : Œ≥) (s : Set Œ≤) :
    densityProcess Œ∫ ŒΩ' n a x s ‚â§ densityProcess Œ∫ ŒΩ n a x s := by
  unfold densityProcess
  have h_le : Œ∫ a (countablePartitionSet n x √óÀ¢ s) ‚â§ ŒΩ a (countablePartitionSet n x) :=
    meas_countablePartitionSet_le_of_fst_le hŒ∫ŒΩ n a x s
  by_cases h0 : ŒΩ a (countablePartitionSet n x) = 0
  ¬∑ simp [le_antisymm (h_le.trans h0.le) zero_le', h0]
  have h0' : ŒΩ' a (countablePartitionSet n x) ‚â† 0 :=
    fun h ‚Ü¶ h0 (le_antisymm ((hŒΩŒΩ' _ _).trans h.le) zero_le')
  rw [ENNReal.toReal_le_toReal]
  ¬∑ gcongr
    exact hŒΩŒΩ' _ _
  ¬∑ simp only [ne_eq, ENNReal.div_eq_top, h0', and_false, false_or, not_and, not_not]
    refine fun h_top ‚Ü¶ eq_top_mono ?_ h_top
    exact h_le.trans (hŒΩŒΩ' _ _)
  ¬∑ simp only [ne_eq, ENNReal.div_eq_top, h0, and_false, false_or, not_and, not_not]
    exact fun h_top ‚Ü¶ eq_top_mono h_le h_top

@[simp]
lemma densityProcess_empty (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (n : ‚Ñï) (a : Œ±) (x : Œ≥) :
    densityProcess Œ∫ ŒΩ n a x ‚àÖ = 0 := by
  simp [densityProcess]

lemma tendsto_densityProcess_atTop_empty_of_antitone (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥)
    [IsFiniteKernel Œ∫] (n : ‚Ñï) (a : Œ±) (x : Œ≥)
    (seq : ‚Ñï ‚Üí Set Œ≤) (hseq : Antitone seq) (hseq_iInter : ‚ãÇ i, seq i = ‚àÖ)
    (hseq_meas : ‚àÄ m, MeasurableSet (seq m)) :
    Tendsto (fun m ‚Ü¶ densityProcess Œ∫ ŒΩ n a x (seq m)) atTop
      (ùìù (densityProcess Œ∫ ŒΩ n a x ‚àÖ)) := by
  simp_rw [densityProcess]
  by_cases h0 : ŒΩ a (countablePartitionSet n x) = 0
  ¬∑ simp_rw [h0, ENNReal.toReal_div]
    simp
  refine (ENNReal.tendsto_toReal ?_).comp ?_
  ¬∑ rw [ne_eq, ENNReal.div_eq_top]
    push_neg
    simp
  refine ENNReal.Tendsto.div_const ?_ ?_
  ¬∑ have h := tendsto_measure_iInter (Œº := Œ∫ a) (s := fun m ‚Ü¶ countablePartitionSet n x √óÀ¢ seq m)
      ?_ ?_ ?_
    ¬∑ convert h
      rw [‚Üê prod_iInter, hseq_iInter]
    ¬∑ exact fun m ‚Ü¶ MeasurableSet.prod (measurableSet_countablePartitionSet _ _) (hseq_meas m)
    ¬∑ intro m m' hmm'
      simp only [le_eq_subset, prod_subset_prod_iff, subset_rfl, true_and]
      exact Or.inl <| hseq hmm'
    ¬∑ exact ‚ü®0, measure_ne_top _ _‚ü©
  ¬∑ exact .inr h0

lemma tendsto_densityProcess_atTop_of_antitone (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥)
    [IsFiniteKernel Œ∫] (n : ‚Ñï) (a : Œ±) (x : Œ≥)
    (seq : ‚Ñï ‚Üí Set Œ≤) (hseq : Antitone seq) (hseq_iInter : ‚ãÇ i, seq i = ‚àÖ)
    (hseq_meas : ‚àÄ m, MeasurableSet (seq m)) :
    Tendsto (fun m ‚Ü¶ densityProcess Œ∫ ŒΩ n a x (seq m)) atTop (ùìù 0) := by
  rw [‚Üê densityProcess_empty Œ∫ ŒΩ n a x]
  exact tendsto_densityProcess_atTop_empty_of_antitone Œ∫ ŒΩ n a x seq hseq hseq_iInter hseq_meas

lemma tendsto_densityProcess_limitProcess (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ)
    [IsFiniteKernel ŒΩ] (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    ‚àÄ·µê x ‚àÇ(ŒΩ a), Tendsto (fun n ‚Ü¶ densityProcess Œ∫ ŒΩ n a x s) atTop
      (ùìù ((countableFiltration Œ≥).limitProcess
      (fun n x ‚Ü¶ densityProcess Œ∫ ŒΩ n a x s) (ŒΩ a) x)) := by
  refine Submartingale.ae_tendsto_limitProcess (martingale_densityProcess hŒ∫ŒΩ a hs).submartingale
    (R := (ŒΩ a univ).toNNReal) (fun n ‚Ü¶ ?_)
  refine (snorm_densityProcess_le hŒ∫ŒΩ n a s).trans_eq ?_
  rw [ENNReal.coe_toNNReal]
  exact measure_ne_top _ _

lemma memL1_limitProcess_densityProcess (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel ŒΩ]
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    Mem‚Ñíp ((countableFiltration Œ≥).limitProcess
      (fun n x ‚Ü¶ densityProcess Œ∫ ŒΩ n a x s) (ŒΩ a)) 1 (ŒΩ a) := by
  refine Submartingale.mem‚Ñíp_limitProcess (martingale_densityProcess hŒ∫ŒΩ a hs).submartingale
    (R := (ŒΩ a univ).toNNReal) (fun n ‚Ü¶ ?_)
  refine (snorm_densityProcess_le hŒ∫ŒΩ n a s).trans_eq ?_
  rw [ENNReal.coe_toNNReal]
  exact measure_ne_top _ _

lemma tendsto_snorm_one_densityProcess_limitProcess (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel ŒΩ]
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    Tendsto (fun n ‚Ü¶ snorm ((fun x ‚Ü¶ densityProcess Œ∫ ŒΩ n a x s)
      - (countableFiltration Œ≥).limitProcess (fun n x ‚Ü¶ densityProcess Œ∫ ŒΩ n a x s) (ŒΩ a))
      1 (ŒΩ a)) atTop (ùìù 0) := by
  refine Submartingale.tendsto_snorm_one_limitProcess ?_ ?_
  ¬∑ exact (martingale_densityProcess hŒ∫ŒΩ a hs).submartingale
  ¬∑ refine uniformIntegrable_of le_rfl ENNReal.one_ne_top ?_ ?_
    ¬∑ exact fun n ‚Ü¶ (measurable_densityProcess_right Œ∫ ŒΩ n a hs).aestronglyMeasurable
    ¬∑ refine fun Œµ _ ‚Ü¶ ‚ü®2, fun n ‚Ü¶ le_of_eq_of_le ?_ (?_ : 0 ‚â§ ENNReal.ofReal Œµ)‚ü©
      ¬∑ suffices {x | 2 ‚â§ ‚ÄñdensityProcess Œ∫ ŒΩ n a x s‚Äñ‚Çä} = ‚àÖ by simp [this]
        ext x
        simp only [mem_setOf_eq, mem_empty_iff_false, iff_false, not_le]
        refine (?_ : _ ‚â§ (1 : ‚Ñù‚â•0)).trans_lt one_lt_two
        rw [Real.nnnorm_of_nonneg (densityProcess_nonneg _ _ _ _ _ _)]
        exact mod_cast (densityProcess_le_one hŒ∫ŒΩ _ _ _ _)
      ¬∑ simp

lemma tendsto_snorm_one_restrict_densityProcess_limitProcess [IsFiniteKernel ŒΩ]
    (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) (A : Set Œ≥) :
    Tendsto (fun n ‚Ü¶ snorm ((fun x ‚Ü¶ densityProcess Œ∫ ŒΩ n a x s)
      - (countableFiltration Œ≥).limitProcess (fun n x ‚Ü¶ densityProcess Œ∫ ŒΩ n a x s) (ŒΩ a))
      1 ((ŒΩ a).restrict A)) atTop (ùìù 0) :=
  tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds
    (tendsto_snorm_one_densityProcess_limitProcess hŒ∫ŒΩ a hs) (fun _ ‚Ü¶ zero_le')
    (fun _ ‚Ü¶ snorm_restrict_le _ _ _ _)

end DensityProcess

section Density

/-- Density of the kernel `Œ∫` with respect to `ŒΩ`. This is a function `Œ± ‚Üí Œ≥ ‚Üí Set Œ≤ ‚Üí ‚Ñù` which
is measurable on `Œ± √ó Œ≥` for all measurable sets `s : Set Œ≤` and satisfies that
`‚à´ x in A, density Œ∫ ŒΩ a x s ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ s)).toReal` for all measurable `A : Set Œ≥`. -/
noncomputable
def density (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (a : Œ±) (x : Œ≥) (s : Set Œ≤) : ‚Ñù :=
  limsup (fun n ‚Ü¶ densityProcess Œ∫ ŒΩ n a x s) atTop

lemma density_ae_eq_limitProcess (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel ŒΩ]
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    (fun x ‚Ü¶ density Œ∫ ŒΩ a x s)
      =·µê[ŒΩ a] (countableFiltration Œ≥).limitProcess
        (fun n x ‚Ü¶ densityProcess Œ∫ ŒΩ n a x s) (ŒΩ a) := by
  filter_upwards [tendsto_densityProcess_limitProcess hŒ∫ŒΩ a hs] with t ht using ht.limsup_eq

lemma tendsto_m_density (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) (a : Œ±) [IsFiniteKernel ŒΩ]
    {s : Set Œ≤} (hs : MeasurableSet s) :
    ‚àÄ·µê x ‚àÇ(ŒΩ a),
      Tendsto (fun n ‚Ü¶ densityProcess Œ∫ ŒΩ n a x s) atTop (ùìù (density Œ∫ ŒΩ a x s)) := by
  filter_upwards [tendsto_densityProcess_limitProcess hŒ∫ŒΩ a hs, density_ae_eq_limitProcess hŒ∫ŒΩ a hs]
    with t h1 h2 using h2 ‚ñ∏ h1

lemma measurable_density (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥)
    {s : Set Œ≤} (hs : MeasurableSet s) :
    Measurable (fun (p : Œ± √ó Œ≥) ‚Ü¶ density Œ∫ ŒΩ p.1 p.2 s) :=
  measurable_limsup (fun n ‚Ü¶ measurable_densityProcess Œ∫ ŒΩ n hs)

lemma measurable_density_left (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥) (x : Œ≥)
    {s : Set Œ≤} (hs : MeasurableSet s) :
    Measurable (fun a ‚Ü¶ density Œ∫ ŒΩ a x s) := by
  change Measurable ((fun (p : Œ± √ó Œ≥) ‚Ü¶ density Œ∫ ŒΩ p.1 p.2 s) ‚àò (fun a ‚Ü¶ (a, x)))
  exact (measurable_density Œ∫ ŒΩ hs).comp measurable_prod_mk_right

lemma measurable_density_right (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (ŒΩ : kernel Œ± Œ≥)
    {s : Set Œ≤} (hs : MeasurableSet s) (a : Œ±) :
    Measurable (fun x ‚Ü¶ density Œ∫ ŒΩ a x s) := by
  change Measurable ((fun (p : Œ± √ó Œ≥) ‚Ü¶ density Œ∫ ŒΩ p.1 p.2 s) ‚àò (fun x ‚Ü¶ (a, x)))
  exact (measurable_density Œ∫ ŒΩ hs).comp measurable_prod_mk_left

lemma density_mono_set (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) (a : Œ±) (x : Œ≥) {s s' : Set Œ≤} (h : s ‚äÜ s') :
    density Œ∫ ŒΩ a x s ‚â§ density Œ∫ ŒΩ a x s' := by
  refine limsup_le_limsup ?_ ?_ ?_
  ¬∑ exact eventually_of_forall (fun n ‚Ü¶ densityProcess_mono_set hŒ∫ŒΩ n a x h)
  ¬∑ exact isCoboundedUnder_le_of_le atTop (fun i ‚Ü¶ densityProcess_nonneg _ _ _ _ _ _)
  ¬∑ exact isBoundedUnder_of ‚ü®1, fun n ‚Ü¶ densityProcess_le_one hŒ∫ŒΩ _ _ _ _‚ü©

lemma density_nonneg (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) (a : Œ±) (x : Œ≥) (s : Set Œ≤) :
    0 ‚â§ density Œ∫ ŒΩ a x s := by
  refine le_limsup_of_frequently_le ?_ ?_
  ¬∑ exact frequently_of_forall (fun n ‚Ü¶ densityProcess_nonneg _ _ _ _ _ _)
  ¬∑ exact isBoundedUnder_of ‚ü®1, fun n ‚Ü¶ densityProcess_le_one hŒ∫ŒΩ _ _ _ _‚ü©

lemma density_le_one (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) (a : Œ±) (x : Œ≥) (s : Set Œ≤) :
    density Œ∫ ŒΩ a x s ‚â§ 1 := by
  refine limsup_le_of_le ?_ ?_
  ¬∑ exact isCoboundedUnder_le_of_le atTop (fun i ‚Ü¶ densityProcess_nonneg _ _ _ _ _ _)
  ¬∑ exact eventually_of_forall (fun n ‚Ü¶ densityProcess_le_one hŒ∫ŒΩ _ _ _ _)

section Integral

lemma snorm_density_le (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) (a : Œ±) (s : Set Œ≤) :
    snorm (fun x ‚Ü¶ density Œ∫ ŒΩ a x s) 1 (ŒΩ a) ‚â§ ŒΩ a univ := by
  refine (snorm_le_of_ae_bound (C := 1) (ae_of_all _ (fun t ‚Ü¶ ?_))).trans ?_
  ¬∑ simp only [Real.norm_eq_abs, abs_of_nonneg (density_nonneg hŒ∫ŒΩ a t s),
      density_le_one hŒ∫ŒΩ a t s]
  ¬∑ simp

lemma integrable_density (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel ŒΩ]
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    Integrable (fun x ‚Ü¶ density Œ∫ ŒΩ a x s) (ŒΩ a) := by
  rw [‚Üê mem‚Ñíp_one_iff_integrable]
  refine ‚ü®Measurable.aestronglyMeasurable ?_, ?_‚ü©
  ¬∑ exact measurable_density_right Œ∫ ŒΩ hs a
  ¬∑ exact (snorm_density_le hŒ∫ŒΩ a s).trans_lt (measure_lt_top _ _)

lemma tendsto_setIntegral_densityProcess (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ)
    [IsFiniteKernel ŒΩ] (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) (A : Set Œ≥) :
    Tendsto (fun i ‚Ü¶ ‚à´ x in A, densityProcess Œ∫ ŒΩ i a x s ‚àÇ(ŒΩ a)) atTop
      (ùìù (‚à´ x in A, density Œ∫ ŒΩ a x s ‚àÇ(ŒΩ a))) := by
  refine tendsto_setIntegral_of_L1' (Œº := ŒΩ a) (fun x ‚Ü¶ density Œ∫ ŒΩ a x s)
    (integrable_density hŒ∫ŒΩ a hs) (F := fun i x ‚Ü¶ densityProcess Œ∫ ŒΩ i a x s) (l := atTop)
    (eventually_of_forall (fun n ‚Ü¶ integrable_densityProcess hŒ∫ŒΩ _ _ hs)) ?_ A
  refine (tendsto_congr fun n ‚Ü¶ ?_).mp (tendsto_snorm_one_densityProcess_limitProcess hŒ∫ŒΩ a hs)
  refine snorm_congr_ae ?_
  exact EventuallyEq.rfl.sub (density_ae_eq_limitProcess hŒ∫ŒΩ a hs).symm

@[deprecated (since := "2024-04-17")]
alias tendsto_set_integral_densityProcess := tendsto_setIntegral_densityProcess

/-- Auxiliary lemma for `setIntegral_density`. -/
lemma setIntegral_density_of_measurableSet (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ)
    [IsFiniteKernel ŒΩ] (n : ‚Ñï) (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) {A : Set Œ≥}
    (hA : MeasurableSet[countableFiltration Œ≥ n] A) :
    ‚à´ x in A, density Œ∫ ŒΩ a x s ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ s)).toReal := by
  suffices ‚à´ x in A, density Œ∫ ŒΩ a x s ‚àÇ(ŒΩ a) = ‚à´ x in A, densityProcess Œ∫ ŒΩ n a x s ‚àÇ(ŒΩ a) by
    exact this ‚ñ∏ setIntegral_densityProcess hŒ∫ŒΩ _ _ hs hA
  suffices ‚à´ x in A, density Œ∫ ŒΩ a x s ‚àÇ(ŒΩ a)
      = limsup (fun i ‚Ü¶ ‚à´ x in A, densityProcess Œ∫ ŒΩ i a x s ‚àÇ(ŒΩ a)) atTop by
    rw [this, ‚Üê limsup_const (Œ± := ‚Ñï) (f := atTop) (‚à´ x in A, densityProcess Œ∫ ŒΩ n a x s ‚àÇ(ŒΩ a)),
      limsup_congr]
    simp only [eventually_atTop]
    refine ‚ü®n, fun m hnm ‚Ü¶ ?_‚ü©
    rw [setIntegral_densityProcess_of_le hŒ∫ŒΩ hnm _ hs hA,
      setIntegral_densityProcess hŒ∫ŒΩ _ _ hs hA]
  -- use L1 convergence
  have h := tendsto_setIntegral_densityProcess hŒ∫ŒΩ a hs A
  rw [h.limsup_eq]

@[deprecated (since := "2024-04-17")]
alias set_integral_density_of_measurableSet := setIntegral_density_of_measurableSet

lemma integral_density (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel ŒΩ]
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    ‚à´ x, density Œ∫ ŒΩ a x s ‚àÇ(ŒΩ a) = (Œ∫ a (univ √óÀ¢ s)).toReal := by
  rw [‚Üê integral_univ, setIntegral_density_of_measurableSet hŒ∫ŒΩ 0 a hs MeasurableSet.univ]

lemma setIntegral_density (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel ŒΩ]
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) {A : Set Œ≥} (hA : MeasurableSet A) :
    ‚à´ x in A, density Œ∫ ŒΩ a x s ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ s)).toReal := by
  have : IsFiniteKernel Œ∫ := isFiniteKernel_of_isFiniteKernel_fst (h := isFiniteKernel_of_le hŒ∫ŒΩ)
  have hA' : MeasurableSet[‚®Ü n, countableFiltration Œ≥ n] A := by rwa [iSup_countableFiltration]
  refine induction_on_inter (m := ‚®Ü n, countableFiltration Œ≥ n)
    (C := fun A ‚Ü¶ ‚à´ x in A, density Œ∫ ŒΩ a x s ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ s)).toReal)
    (measurableSpace_iSup_eq (countableFiltration Œ≥)) ?_ ?_ ?_ ?_ ?_ hA'
  ¬∑ rintro s ‚ü®n, hs‚ü© t ‚ü®m, ht‚ü© _
    exact ‚ü®max n m, ((countableFiltration Œ≥).mono (le_max_left n m) _ hs).inter
      ((countableFiltration Œ≥).mono (le_max_right n m) _ ht)‚ü©
  ¬∑ simp
  ¬∑ intro A ‚ü®n, hA‚ü©
    exact setIntegral_density_of_measurableSet hŒ∫ŒΩ n a hs hA
  ¬∑ intro A hA hA_eq
    rw [iSup_countableFiltration] at hA
    have h := integral_add_compl hA (integrable_density hŒ∫ŒΩ a hs)
    rw [hA_eq, integral_density hŒ∫ŒΩ a hs] at h
    have : A·∂ú √óÀ¢ s = univ √óÀ¢ s \ A √óÀ¢ s := by
      rw [prod_diff_prod, compl_eq_univ_diff]
      simp
    rw [this, measure_diff (by intro x; simp) (hA.prod hs) (measure_ne_top (Œ∫ a) _),
      ENNReal.toReal_sub_of_le (measure_mono (by intro x; simp)) (measure_ne_top _ _)]
    rw [eq_tsub_iff_add_eq_of_le, add_comm]
    ¬∑ exact h
    ¬∑ rw [ENNReal.toReal_le_toReal (measure_ne_top _ _) (measure_ne_top _ _)]
      exact measure_mono (by intro x; simp)
  ¬∑ intro f hf_disj hf h_eq
    rw [integral_iUnion _ hf_disj (integrable_density hŒ∫ŒΩ _ hs).integrableOn]
    ¬∑ simp_rw [h_eq]
      rw [‚Üê ENNReal.tsum_toReal_eq (fun _ ‚Ü¶ measure_ne_top _ _)]
      congr
      rw [iUnion_prod_const, measure_iUnion]
      ¬∑ intro i j hij
        rw [Function.onFun, Set.disjoint_prod]
        exact Or.inl (hf_disj hij)
      ¬∑ rw [iSup_countableFiltration] at hf
        exact fun i ‚Ü¶ (hf i).prod hs
    ¬∑ rwa [iSup_countableFiltration] at hf

@[deprecated (since := "2024-04-17")]
alias set_integral_density := setIntegral_density

lemma set_lintegral_density (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel ŒΩ]
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) {A : Set Œ≥} (hA : MeasurableSet A) :
    ‚à´‚Åª x in A, ENNReal.ofReal (density Œ∫ ŒΩ a x s) ‚àÇ(ŒΩ a) = Œ∫ a (A √óÀ¢ s) := by
  have : IsFiniteKernel Œ∫ := isFiniteKernel_of_isFiniteKernel_fst (h := isFiniteKernel_of_le hŒ∫ŒΩ)
  rw [‚Üê ofReal_integral_eq_lintegral_ofReal]
  ¬∑ rw [setIntegral_density hŒ∫ŒΩ a hs hA,
      ENNReal.ofReal_toReal (measure_ne_top _ _)]
  ¬∑ exact (integrable_density hŒ∫ŒΩ a hs).restrict
  ¬∑ exact ae_of_all _ (fun _ ‚Ü¶ density_nonneg hŒ∫ŒΩ _ _ _)

lemma lintegral_density (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel ŒΩ]
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :
    ‚à´‚Åª x, ENNReal.ofReal (density Œ∫ ŒΩ a x s) ‚àÇ(ŒΩ a) = Œ∫ a (univ √óÀ¢ s) := by
  rw [‚Üê set_lintegral_univ]
  exact set_lintegral_density hŒ∫ŒΩ a hs MeasurableSet.univ

end Integral

lemma tendsto_integral_density_of_monotone (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel ŒΩ]
    (a : Œ±) (seq : ‚Ñï ‚Üí Set Œ≤) (hseq : Monotone seq) (hseq_iUnion : ‚ãÉ i, seq i = univ)
    (hseq_meas : ‚àÄ m, MeasurableSet (seq m)) :
    Tendsto (fun m ‚Ü¶ ‚à´ x, density Œ∫ ŒΩ a x (seq m) ‚àÇ(ŒΩ a)) atTop (ùìù (Œ∫ a univ).toReal) := by
  have : IsFiniteKernel Œ∫ := isFiniteKernel_of_isFiniteKernel_fst (h := isFiniteKernel_of_le hŒ∫ŒΩ)
  simp_rw [integral_density hŒ∫ŒΩ a (hseq_meas _)]
  have h_cont := ENNReal.continuousOn_toReal.continuousAt (x := Œ∫ a univ) ?_
  swap
  ¬∑ rw [mem_nhds_iff]
    refine ‚ü®Iio (Œ∫ a univ + 1), fun x hx ‚Ü¶ ne_top_of_lt (?_ : x < Œ∫ a univ + 1), isOpen_Iio, ?_‚ü©
    ¬∑ simpa using hx
    ¬∑ simp only [mem_Iio]
      exact ENNReal.lt_add_right (measure_ne_top _ _) one_ne_zero
  refine h_cont.tendsto.comp ?_
  have h := tendsto_measure_iUnion (s := fun m ‚Ü¶ univ √óÀ¢ seq m) (Œº := Œ∫ a) ?_
  swap; ¬∑ intro n m hnm x; simp only [mem_prod, mem_univ, true_and]; exact fun h ‚Ü¶ hseq hnm h
  convert h
  rw [‚Üê prod_iUnion, hseq_iUnion]
  simp only [univ_prod_univ, measure_univ]

lemma tendsto_integral_density_of_antitone (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel ŒΩ] (a : Œ±)
    (seq : ‚Ñï ‚Üí Set Œ≤) (hseq : Antitone seq) (hseq_iInter : ‚ãÇ i, seq i = ‚àÖ)
    (hseq_meas : ‚àÄ m, MeasurableSet (seq m)) :
    Tendsto (fun m ‚Ü¶ ‚à´ x, density Œ∫ ŒΩ a x (seq m) ‚àÇ(ŒΩ a)) atTop (ùìù 0) := by
  have : IsFiniteKernel Œ∫ := isFiniteKernel_of_isFiniteKernel_fst (h := isFiniteKernel_of_le hŒ∫ŒΩ)
  simp_rw [integral_density hŒ∫ŒΩ a (hseq_meas _)]
  rw [‚Üê ENNReal.zero_toReal]
  have h_cont := ENNReal.continuousOn_toReal.continuousAt (x := 0) ?_
  swap
  ¬∑ rw [mem_nhds_iff]
    refine ‚ü®Iio 1, fun x hx ‚Ü¶ ne_top_of_lt (?_ : x < 1), isOpen_Iio, ?_‚ü©
    ¬∑ simpa using hx
    ¬∑ simp
  refine h_cont.tendsto.comp ?_
  have h := tendsto_measure_iInter (s := fun m ‚Ü¶ univ √óÀ¢ seq m) (Œº := Œ∫ a)
    (fun m ‚Ü¶ MeasurableSet.univ.prod (hseq_meas m)) ?_ ?_
  rotate_left
  ¬∑ intro n m hnm x; simp only [mem_prod, mem_univ, true_and]; exact fun h ‚Ü¶ hseq hnm h
  ¬∑ refine ‚ü®0, measure_ne_top _ _‚ü©
  convert h
  rw [‚Üê prod_iInter, hseq_iInter]
  simp

lemma tendsto_density_atTop_ae_of_antitone (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) [IsFiniteKernel ŒΩ] (a : Œ±)
    (seq : ‚Ñï ‚Üí Set Œ≤) (hseq : Antitone seq) (hseq_iInter : ‚ãÇ i, seq i = ‚àÖ)
    (hseq_meas : ‚àÄ m, MeasurableSet (seq m)) :
    ‚àÄ·µê x ‚àÇ(ŒΩ a), Tendsto (fun m ‚Ü¶ density Œ∫ ŒΩ a x (seq m)) atTop (ùìù 0) := by
  refine tendsto_of_integral_tendsto_of_antitone ?_ (integrable_const _) ?_ ?_ ?_
  ¬∑ exact fun m ‚Ü¶ integrable_density hŒ∫ŒΩ _ (hseq_meas m)
  ¬∑ rw [integral_zero]
    exact tendsto_integral_density_of_antitone hŒ∫ŒΩ a seq hseq hseq_iInter hseq_meas
  ¬∑ exact ae_of_all _ (fun c n m hnm ‚Ü¶ density_mono_set hŒ∫ŒΩ a c (hseq hnm))
  ¬∑ exact ae_of_all _ (fun x m ‚Ü¶ density_nonneg hŒ∫ŒΩ a x (seq m))

section UnivFst

/-! We specialize to `ŒΩ = fst Œ∫`, for which `density Œ∫ (fst Œ∫) a t univ = 1` almost everywhere. -/

lemma densityProcess_fst_univ [IsFiniteKernel Œ∫] (n : ‚Ñï) (a : Œ±) (x : Œ≥) :
    densityProcess Œ∫ (fst Œ∫) n a x univ
      = if fst Œ∫ a (countablePartitionSet n x) = 0 then 0 else 1 := by
  rw [densityProcess]
  by_cases h : fst Œ∫ a (countablePartitionSet n x) = 0
  ¬∑ simp [h]
    by_cases h' : Œ∫ a (countablePartitionSet n x √óÀ¢ univ) = 0
    ¬∑ simp [h']
    ¬∑ rw [ENNReal.div_zero h']
      simp
  ¬∑ simp only [h, ite_false]
    rw [fst_apply' _ _ (measurableSet_countablePartitionSet _ _)]
    have : countablePartitionSet n x √óÀ¢ univ = {p : Œ≥ √ó Œ≤ | p.1 ‚àà countablePartitionSet n x} := by
      ext x
      simp
    rw [this, ENNReal.div_self]
    ¬∑ simp
    ¬∑ rwa [fst_apply' _ _ (measurableSet_countablePartitionSet _ _)] at h
    ¬∑ exact measure_ne_top _ _

lemma densityProcess_fst_univ_ae (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) [IsFiniteKernel Œ∫] (n : ‚Ñï) (a : Œ±) :
    ‚àÄ·µê x ‚àÇ(fst Œ∫ a), densityProcess Œ∫ (fst Œ∫) n a x univ = 1 := by
  rw [ae_iff]
  have : {x | ¬¨ densityProcess Œ∫ (fst Œ∫) n a x univ = 1}
      ‚äÜ {x | fst Œ∫ a (countablePartitionSet n x) = 0} := by
    intro x hx
    simp only [mem_setOf_eq] at hx ‚ä¢
    rw [densityProcess_fst_univ] at hx
    simpa using hx
  refine measure_mono_null this ?_
  have : {x | fst Œ∫ a (countablePartitionSet n x) = 0}
      ‚äÜ ‚ãÉ (u) (_ : u ‚àà countablePartition Œ≥ n) (_ : fst Œ∫ a u = 0), u := by
    intro t ht
    simp only [mem_setOf_eq, mem_iUnion, exists_prop] at ht ‚ä¢
    exact ‚ü®countablePartitionSet n t, countablePartitionSet_mem _ _, ht,
      mem_countablePartitionSet _ _‚ü©
  refine measure_mono_null this ?_
  rw [measure_biUnion]
  ¬∑ simp
  ¬∑ exact (finite_countablePartition _ _).countable
  ¬∑ intro s hs t ht hst
    simp only [disjoint_iUnion_right, disjoint_iUnion_left]
    exact fun _ _ ‚Ü¶ disjoint_countablePartition hs ht hst
  ¬∑ intro s hs
    by_cases h : fst Œ∫ a s = 0
    ¬∑ simp [h, measurableSet_countablePartition n hs]
    ¬∑ simp [h]

lemma tendsto_densityProcess_fst_atTop_univ_of_monotone (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) (n : ‚Ñï) (a : Œ±)
    (x : Œ≥) (seq : ‚Ñï ‚Üí Set Œ≤) (hseq : Monotone seq) (hseq_iUnion : ‚ãÉ i, seq i = univ) :
    Tendsto (fun m ‚Ü¶ densityProcess Œ∫ (fst Œ∫) n a x (seq m)) atTop
      (ùìù (densityProcess Œ∫ (fst Œ∫) n a x univ)) := by
  simp_rw [densityProcess]
  refine (ENNReal.tendsto_toReal ?_).comp ?_
  ¬∑ rw [ne_eq, ENNReal.div_eq_top]
    push_neg
    simp_rw [fst_apply' _ _ (measurableSet_countablePartitionSet _ _)]
    constructor
    ¬∑ refine fun h h0 ‚Ü¶ h (measure_mono_null (fun x ‚Ü¶ ?_) h0)
      simp only [mem_prod, mem_setOf_eq, and_imp]
      exact fun h _ ‚Ü¶ h
    ¬∑ refine fun h_top ‚Ü¶ eq_top_mono (measure_mono (fun x ‚Ü¶ ?_)) h_top
      simp only [mem_prod, mem_setOf_eq, and_imp]
      exact fun h _ ‚Ü¶ h
  by_cases h0 : fst Œ∫ a (countablePartitionSet n x) = 0
  ¬∑ rw [fst_apply' _ _ (measurableSet_countablePartitionSet _ _)] at h0 ‚ä¢
    suffices ‚àÄ m, Œ∫ a (countablePartitionSet n x √óÀ¢ seq m) = 0 by
      simp only [this, h0, ENNReal.zero_div, tendsto_const_nhds_iff]
      suffices Œ∫ a (countablePartitionSet n x √óÀ¢ univ) = 0 by
        simp only [this, ENNReal.zero_div]
      convert h0
      ext x
      simp only [mem_prod, mem_univ, and_true, mem_setOf_eq]
    refine fun m ‚Ü¶ measure_mono_null (fun x ‚Ü¶ ?_) h0
    simp only [mem_prod, mem_setOf_eq, and_imp]
    exact fun h _ ‚Ü¶ h
  refine ENNReal.Tendsto.div_const ?_ ?_
  ¬∑ have h := tendsto_measure_iUnion (Œº := Œ∫ a)
      (s := fun m ‚Ü¶ countablePartitionSet n x √óÀ¢ seq m) ?_
    swap
    ¬∑ intro m m' hmm'
      simp only [le_eq_subset, prod_subset_prod_iff, subset_rfl, true_and]
      exact Or.inl <| hseq hmm'
    convert h
    rw [‚Üê prod_iUnion, hseq_iUnion]
  ¬∑ exact Or.inr h0

lemma tendsto_densityProcess_fst_atTop_ae_of_monotone (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) [IsFiniteKernel Œ∫]
    (n : ‚Ñï) (a : Œ±) (seq : ‚Ñï ‚Üí Set Œ≤) (hseq : Monotone seq) (hseq_iUnion : ‚ãÉ i, seq i = univ) :
    ‚àÄ·µê x ‚àÇ(fst Œ∫ a), Tendsto (fun m ‚Ü¶ densityProcess Œ∫ (fst Œ∫) n a x (seq m)) atTop (ùìù 1) := by
  filter_upwards [densityProcess_fst_univ_ae Œ∫ n a] with x hx
  rw [‚Üê hx]
  exact tendsto_densityProcess_fst_atTop_univ_of_monotone Œ∫ n a x seq hseq hseq_iUnion

lemma density_fst_univ (Œ∫ : kernel Œ± (Œ≥ √ó Œ≤)) [IsFiniteKernel Œ∫] (a : Œ±) :
    ‚àÄ·µê x ‚àÇ(fst Œ∫ a), density Œ∫ (fst Œ∫) a x univ = 1 := by
  have h := fun n ‚Ü¶ densityProcess_fst_univ_ae Œ∫ n a
  rw [‚Üê ae_all_iff] at h
  filter_upwards [h] with x hx
  simp [density, hx]

lemma tendsto_density_fst_atTop_ae_of_monotone [IsFiniteKernel Œ∫]
    (a : Œ±) (seq : ‚Ñï ‚Üí Set Œ≤) (hseq : Monotone seq) (hseq_iUnion : ‚ãÉ i, seq i = univ)
    (hseq_meas : ‚àÄ m, MeasurableSet (seq m)) :
    ‚àÄ·µê x ‚àÇ(fst Œ∫ a), Tendsto (fun m ‚Ü¶ density Œ∫ (fst Œ∫) a x (seq m)) atTop (ùìù 1) := by
  refine tendsto_of_integral_tendsto_of_monotone ?_ (integrable_const _) ?_ ?_ ?_
  ¬∑ exact fun m ‚Ü¶ integrable_density le_rfl _ (hseq_meas m)
  ¬∑ rw [MeasureTheory.integral_const, smul_eq_mul, mul_one]
    convert tendsto_integral_density_of_monotone (Œ∫ := Œ∫) le_rfl a seq hseq hseq_iUnion hseq_meas
    rw [fst_apply' _ _ MeasurableSet.univ]
    simp only [mem_univ, setOf_true]
  ¬∑ exact ae_of_all _ (fun c n m hnm ‚Ü¶ density_mono_set le_rfl a c (hseq hnm))
  ¬∑ exact ae_of_all _ (fun x m ‚Ü¶ density_le_one le_rfl a x (seq m))

end UnivFst

end Density

end kernel

end ProbabilityTheory
