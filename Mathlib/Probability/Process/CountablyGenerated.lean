/-
Copyright (c) 2024 Rémy Degenne. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Rémy Degenne
-/
import Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated
import Mathlib.Probability.Process.Filtration

/-!
# Filtration built from the finite partitions of a countably generated measurable space

In a countably generated measurable space `α`, we can build a sequence of finer and finer finite
measurable partitions of the space such that the measurable space is generated by the union of all
partitions.
This sequence of partitions is defined in `MeasureTheory.MeasurableSpace.CountablyGenerated`.

Here, we build the filtration of the measurable spaces generated by `countablePartition α n` for all
`n : ℕ`, which we call `partitionFiltration α`.
Since each measurable space in the filtration is finite, we can easily build measurable functions on
those spaces. By building a martingale with respect to `partitionFiltration α` and using the
martingale convergence theorems, we can define a measurable function on `α`.

## Main definitions

* `ProbabilityTheory.partitionFiltration`: A filtration built from the measurable spaces generated
  by `countablePartition α n` for all `n : ℕ`.

## Main statements

* `ProbabilityTheory.iSup_partitionFiltration`: `⨆ n, partitionFiltration α n` is the measurable
  space on `α`.

-/

open MeasureTheory MeasurableSpace

namespace ProbabilityTheory

variable {α : Type*} [MeasurableSpace α] [CountablyGenerated α]

/-- A filtration built from the measurable spaces generated by `countablePartition α n` for
all `n : ℕ`. -/
def partitionFiltration (α : Type*) [m : MeasurableSpace α] [CountablyGenerated α] :
    Filtration ℕ m where
  seq n := generateFrom (countablePartition α n)
  mono' := monotone_nat_of_le_succ (generateFrom_countablePartition_le_succ _)
  le' := generateFrom_countablePartition_le α

lemma measurableSet_partitionFiltration_of_mem (n : ℕ) {s : Set α}
    (hs : s ∈ countablePartition α n) :
    MeasurableSet[partitionFiltration α n] s :=
  measurableSet_generateFrom hs

lemma measurableSet_partitionFiltration_countablePartitionSet (n : ℕ) (t : α) :
    MeasurableSet[partitionFiltration α n] (countablePartitionSet n t) :=
  measurableSet_partitionFiltration_of_mem n (countablePartitionSet_mem n t)

lemma measurable_countablePartitionSet_subtype (n : ℕ)
    (m : MeasurableSpace (countablePartition α n)) :
    @Measurable α (countablePartition α n) (partitionFiltration α n) m
      (fun a ↦ ⟨countablePartitionSet n a, countablePartitionSet_mem n a⟩) := by
  refine @measurable_to_countable' (countablePartition α n) α m _
    (partitionFiltration α n) _ (fun t ↦ ?_)
  rcases t with ⟨t, ht⟩
  suffices MeasurableSet[partitionFiltration α n] {x | countablePartitionSet n x = t} by
    convert this
    ext x
    simp
  simp_rw [countablePartitionSet_eq_iff _ ht]
  exact measurableSet_partitionFiltration_of_mem _ ht

lemma measurable_partitionFiltration_countablePartitionSet (α : Type*)
    [MeasurableSpace α] [CountablyGenerated α] (n : ℕ) :
    Measurable[partitionFiltration α n] (countablePartitionSet n) :=
  measurable_subtype_coe.comp (measurable_countablePartitionSet_subtype _ _)

lemma measurable_countablePartitionSet (α : Type*) [MeasurableSpace α] [CountablyGenerated α]
    (n : ℕ) :
    Measurable (countablePartitionSet (α := α) n) :=
  (measurable_partitionFiltration_countablePartitionSet α n).mono ((partitionFiltration α).le n)
    le_rfl

lemma iSup_partitionFiltration (α : Type*) [m : MeasurableSpace α] [CountablyGenerated α] :
    ⨆ n, partitionFiltration α n = m := by
  conv_rhs => rw [← generateFrom_iUnion_countablePartition α, ← iSup_generateFrom]

end ProbabilityTheory
