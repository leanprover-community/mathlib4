/-
Copyright (c) 2025 Kexing Ying. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kexing Ying
-/
import Mathlib.Probability.Process.Adapted

/-!
# Progressively Measurable Ïƒ-algebra

This file defines the progressively measurable Ïƒ-algebra associated to a filtration, as well as the
notion of predictable processes. We prove that predictable processes are progressively measurable
and adapted. We also give an equivalent characterization of predictability for discrete processes.

## Main definitions

* `Filtration.predictable` : The predictable Ïƒ-algebra associated to a filtration.
* `Filtration.IsPredictable` : A process is predictable if it is measurable with respect to the
  predictable Ïƒ-algebra.

## Main results

* `Filtration.IsPredictable.progMeasurable` : A predictable process is progressively measurable.
* `Filtration.IsPredictable.measurable_succ` : `u` is a discrete predictable process iff
  `u (n + 1)` is `ğ“• n`-measurable and `u 0` is `ğ“• 0`-measurable.

## Tags

predictable, previsible

-/

open Filter Order TopologicalSpace

open scoped MeasureTheory NNReal ENNReal Topology

namespace MeasureTheory

variable {Î© Î¹ : Type*} {m : MeasurableSpace Î©} {E : Type*} [TopologicalSpace E]

section

variable [Preorder Î¹] [OrderBot Î¹]

namespace Filtration

/-- Given a filtration `ğ“•`, the predictable Ïƒ-algebra is the Ïƒ-algebra on `Î¹ Ã— Î©` generated by
sets of the form `(t, âˆ) Ã— A` for `t âˆˆ Î¹` and `A âˆˆ ğ“• t` and `{âŠ¥} Ã— A` for `A âˆˆ ğ“• âŠ¥`. -/
def predictable (ğ“• : Filtration Î¹ m) : MeasurableSpace (Î¹ Ã— Î©) :=
    MeasurableSpace.generateFrom <|
      {s | âˆƒ A, MeasurableSet[ğ“• âŠ¥] A âˆ§ s = {âŠ¥} Ã—Ë¢ A} âˆª
      {s | âˆƒ i A, MeasurableSet[ğ“• i] A âˆ§ s = Set.Ioi i Ã—Ë¢ A}

end Filtration

/-- A process is said to be predictable if it is measurable with respect to the predictable
Ïƒ-algebra. -/
def IsPredictable (ğ“• : Filtration Î¹ m) (u : Î¹ â†’ Î© â†’ E) :=
    StronglyMeasurable[ğ“•.predictable] <| Function.uncurry u

end

lemma measurableSet_predictable_Ioi_prod [LinearOrder Î¹] [OrderBot Î¹]
    {ğ“• : Filtration Î¹ m} {i : Î¹} {s : Set Î©} (hs : MeasurableSet[ğ“• i] s) :
    MeasurableSet[ğ“•.predictable] <| Set.Ioi i Ã—Ë¢ s :=
  MeasurableSpace.measurableSet_generateFrom <| Or.inr âŸ¨i, s, hs, rflâŸ©

/-- Sets of the form `(i, j] Ã— A` for any `A âˆˆ ğ“• i` are measurable with respect to the predictable
Ïƒ-algebra. -/
lemma measurableSet_predictable_Ioc_prod [LinearOrder Î¹] [OrderBot Î¹]
    {ğ“• : Filtration Î¹ m} (i j : Î¹) {s : Set Î©} (hs : MeasurableSet[ğ“• i] s) :
    MeasurableSet[ğ“•.predictable] <| Set.Ioc i j Ã—Ë¢ s := by
  obtain hij | hij := le_or_gt j i
  Â· simp [hij]
  Â· rw [â† Set.Ioi_diff_Ioi, (by simp : (Set.Ioi i \ Set.Ioi j) Ã—Ë¢ s
      = Set.Ioi i Ã—Ë¢ (s \ s) âˆª (Set.Ioi i \ Set.Ioi j) Ã—Ë¢ s), â† Set.prod_diff_prod]
    refine MeasurableSet.diff (measurableSet_predictable_Ioi_prod hs)
      (measurableSet_predictable_Ioi_prod <| ğ“•.mono hij.le _ hs)

namespace IsPredictable

open Filtration

variable [LinearOrder Î¹] [OrderBot Î¹] [MeasurableSpace Î¹] [TopologicalSpace Î¹]
    [OpensMeasurableSpace Î¹] [OrderClosedTopology Î¹]
    [MetrizableSpace E] [MeasurableSpace E] [BorelSpace E] [SecondCountableTopology E]

/-- A predictable process is progressively measurable. -/
lemma progMeasurable {ğ“• : Filtration Î¹ m} {u : Î¹ â†’ Î© â†’ E} (hğ“• : IsPredictable ğ“• u) :
    ProgMeasurable ğ“• u := by
  refine fun i â†¦ Measurable.stronglyMeasurable ?_
  rw [IsPredictable, stronglyMeasurable_iff_measurable, measurable_iff_comap_le] at hğ“•
  rw [measurable_iff_comap_le, (by aesop : (fun (p : Set.Iic i Ã— Î©) â†¦ u (p.1) p.2)
      = Function.uncurry u âˆ˜ (fun p â†¦ (p.1, p.2))), â† MeasurableSpace.comap_comp]
  refine (MeasurableSpace.comap_mono hğ“•).trans ?_
  rw [predictable, MeasurableSpace.comap_generateFrom]
  refine MeasurableSpace.generateFrom_le ?_
  rintro - âŸ¨-, (âŸ¨s, hs, rflâŸ© | âŸ¨j, A, hA, rflâŸ©), rflâŸ©
  Â· rw [(by aesop : (fun (p : Set.Iic i Ã— Î©) â†¦ ((p.1 : Î¹), p.2)) â»Â¹' ({âŠ¥} Ã—Ë¢ s) = {âŠ¥} Ã—Ë¢ s)]
    exact (measurableSet_singleton _).prod <| ğ“•.mono bot_le _ hs
  Â· obtain hji | hij := lt_or_ge j i
    Â· rw [(by grind : (fun (p : Set.Iic i Ã— Î©) â†¦ ((p.1 : Î¹), p.2)) â»Â¹' Set.Ioi j Ã—Ë¢ A
        = (Subtype.val â»Â¹' (Set.Ioc j i)) Ã—Ë¢ A)]
      exact (measurable_subtype_coe measurableSet_Ioc).prod (ğ“•.mono hji.le _ hA)
    Â· rw [(by grind : (fun (p : Set.Iic i Ã— Î©) â†¦ ((p.1 : Î¹), p.2)) â»Â¹' Set.Ioi j Ã—Ë¢ A = âˆ…)]
      Â· simp

/-- A predictable process is adapted. -/
lemma adapted {ğ“• : Filtration Î¹ m} {u : Î¹ â†’ Î© â†’ E} (hğ“• : IsPredictable ğ“• u) :
    Adapted ğ“• u :=
  hğ“•.progMeasurable.adapted

omit [SecondCountableTopology E] in
lemma measurableSet_prodMk_add_one_of_predictable {ğ“• : Filtration â„• m} {s : Set (â„• Ã— Î©)}
    (hs : MeasurableSet[ğ“•.predictable] s) (n : â„•) :
    MeasurableSet[ğ“• n] {Ï‰ | (n + 1, Ï‰) âˆˆ s} := by
  rw [(by aesop : {Ï‰ | (n + 1, Ï‰) âˆˆ s} = (Prod.mk (Î± := Set.singleton (n + 1)) (Î² := Î©)
      âŸ¨n + 1, rflâŸ©) â»Â¹' ((fun (p : Set.singleton (n + 1) Ã— Î©) â†¦ ((p.1 : â„•), p.2)) â»Â¹' s))]
  refine measurableSet_preimage (mÎ² := Subtype.instMeasurableSpace.prod (ğ“• n))
    measurable_prodMk_left <| measurableSet_preimage ?_ hs
  rw [measurable_iff_comap_le, MeasurableSpace.comap_le_iff_le_map]
  refine MeasurableSpace.generateFrom_le ?_
  rintro - (âŸ¨A, hA, rflâŸ© | âŸ¨i, A, hA, rflâŸ©)
  Â· rw [MeasurableSpace.map_def,
      (_ : (fun (p : Set.singleton (n + 1) Ã— Î©) â†¦ ((p.1 : â„•), p.2)) â»Â¹' ({âŠ¥} Ã—Ë¢ A) = âˆ…)]
    Â· simp
    Â· ext p
      simp only [Nat.bot_eq_zero, Set.mem_preimage, Set.mem_prod, Set.mem_singleton_iff,
        Set.mem_empty_iff_false, iff_false, not_and]
      exact fun hp1 â†¦ False.elim <| Nat.succ_ne_zero n (hp1 â–¸ p.1.2.symm)
  Â· rw [MeasurableSpace.map_def]
    obtain hni | hin := lt_or_ge n i
    Â· rw [(_ : (fun (p : Set.singleton (n + 1) Ã— Î©) â†¦ ((p.1 : â„•), p.2)) â»Â¹' (Set.Ioi i Ã—Ë¢ A) = âˆ…)]
      Â· simp only [MeasurableSet.empty]
      Â· ext p
        simp only [Set.mem_preimage, Set.mem_prod, Set.mem_Ioi, Set.mem_empty_iff_false,
          iff_false, not_and]
        rw [p.1.2]
        grind
    Â· rw [(_ : (fun (p : Set.singleton (n + 1) Ã— Î©) â†¦ ((p.1 : â„•), p.2)) â»Â¹' (Set.Ioi i Ã—Ë¢ A)
          = {âŸ¨n + 1, rflâŸ©} Ã—Ë¢ A)]
      Â· exact MeasurableSet.prod (MeasurableSet.of_subtype_image trivial) (ğ“•.mono hin _ hA)
      Â· ext p
        simp only [Set.mem_preimage, Set.mem_prod, Set.mem_Ioi, Set.mem_singleton_iff,
          and_congr_left_iff]
        intro hp2
        rw [p.1.2]
        exact âŸ¨fun _ â†¦ by aesop, fun _ â†¦ lt_add_one_iff.2 hinâŸ©

omit [SecondCountableTopology E] in
/-- If `u` is a discrete predictable process, then `u (n + 1)` is `ğ“• n`-measurable. -/
lemma measurable_add_one {ğ“• : Filtration â„• m} {u : â„• â†’ Î© â†’ E} (hğ“• : IsPredictable ğ“• u) (n : â„•) :
    Measurable[ğ“• n] (u (n + 1)) := by
  intro s hs
  rw [(by aesop : u (n + 1) â»Â¹' s = {Ï‰ | (n + 1, Ï‰) âˆˆ (Function.uncurry u) â»Â¹' s})]
  exact measurableSet_prodMk_add_one_of_predictable (hğ“•.measurable hs) n

end IsPredictable

section

variable [MetrizableSpace E] [MeasurableSpace E] [BorelSpace E]

lemma measurableSet_predictable_singleton_prod
    {ğ“• : Filtration â„• m} {n : â„•} {s : Set Î©} (hs : MeasurableSet[ğ“• n] s) :
    MeasurableSet[ğ“•.predictable] <| {n + 1} Ã—Ë¢ s := by
  rw [(_ : {n + 1} = Set.Ioc n (n + 1))]
  Â· exact measurableSet_predictable_Ioc_prod _ _ hs
  Â· ext m
    simp only [Set.mem_singleton_iff, Set.mem_Ioc]
    refine âŸ¨fun hm â†¦ âŸ¨hm â–¸ lt_add_one n, hm â–¸ le_rflâŸ©, ?_âŸ©
    rintro âŸ¨hmâ‚, hmâ‚‚âŸ©
    linarith

lemma isPredictable_of_measurable_add_one [SecondCountableTopology E]
    {ğ“• : Filtration â„• m} {u : â„• â†’ Î© â†’ E}
    (hâ‚€ : Measurable[ğ“• 0] (u 0)) (h : âˆ€ n, Measurable[ğ“• n] (u (n + 1))) :
    IsPredictable ğ“• u := by
  refine Measurable.stronglyMeasurable ?_
  intro s hs
  rw [(by aesop : Function.uncurry u â»Â¹' s = â‹ƒ n : â„•, {n} Ã—Ë¢ (u n â»Â¹' s))]
  refine MeasurableSet.iUnion <| fun n â†¦ ?_
  obtain (rfl | hn) := n.eq_zero_or_eq_succ_pred
  Â· exact MeasurableSpace.measurableSet_generateFrom <| Or.inl âŸ¨u 0 â»Â¹' s, hâ‚€ hs, rflâŸ©
  Â· rw [hn]
    exact measurableSet_predictable_singleton_prod (h (n - 1) hs)

/-- A discrete process `u` is predictable iff `u (n + 1)` is `ğ“• n`-measurable for all `n` and
`u 0` is `ğ“• 0`-measurable. -/
lemma isPredictable_iff_measurable_add_one [SecondCountableTopology E]
    {ğ“• : Filtration â„• m} {u : â„• â†’ Î© â†’ E} :
    IsPredictable ğ“• u â†” Measurable[ğ“• 0] (u 0) âˆ§ âˆ€ n, Measurable[ğ“• n] (u (n + 1)) :=
  âŸ¨fun hğ“• â†¦ âŸ¨(hğ“•.adapted 0).measurable, fun n â†¦ hğ“•.measurable_add_one (n)âŸ©,
   fun h â†¦ isPredictable_of_measurable_add_one h.1 h.2âŸ©

end

end MeasureTheory
