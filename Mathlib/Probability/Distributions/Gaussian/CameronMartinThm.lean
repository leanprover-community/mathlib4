/-
Copyright (c) 2025 R√©my Degenne. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: R√©my Degenne
-/
import Mathlib.MeasureTheory.Measure.ProbabilityMeasure
import Mathlib.Probability.Distributions.Gaussian.CameronMartin
import Mathlib.Probability.HasLaw

/-!
# Cameron-Martin Theorem

## Main definitions

* `FooBar`

## Main statements

* `fooBar_unique`

## Notation



## Implementation details



## References

* [F. Bar, *Quuxes*][bibkey]

## Tags

Foobars, barfoos
-/

open MeasureTheory Filter
open scoped ENNReal Topology InnerProductSpace

namespace ProbabilityTheory

variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [MeasurableSpace E] [BorelSpace E]
  [CompleteSpace E] [SecondCountableTopology E]
  {Œº : Measure E} [IsGaussian Œº]

-- todo: use the CM ‚Üî RKHS isometry to add a coe to fun for CameronMartin, and write this lemma
-- for CameronMartin?
lemma hasLaw_cameronMartinRKHS (x : cameronMartinRKHS Œº) :
    HasLaw x (gaussianReal 0 (‚Äñx‚Äñ‚Çä ^ 2)) Œº where
  map_eq := by
    by_cases hx0 : x = 0
    ¬∑ simp only [hx0, ZeroMemClass.coe_zero, nnnorm_zero, ne_eq, OfNat.ofNat_ne_zero,
        not_false_eq_true, zero_pow, gaussianReal_zero_var]
      suffices Œº.map (fun _ ‚Ü¶ (0 : ‚Ñù)) = Measure.dirac 0 by convert this; simp
      simp
    have hx_norm_pos : 0 < ‚Äñx‚Äñ := by simp [norm_pos_iff, hx0]
    unfold cameronMartinRKHS at x
    have h := x.2
    rw [Submodule.mem_topologicalClosure_iff, mem_closure_iff_seq_limit] at h
    obtain ‚ü®L, hL_mem, hL_tendsto‚ü© := h
    simp only [Submodule.map_top, SetLike.mem_coe, LinearMap.mem_range] at hL_mem
    let L' := fun n ‚Ü¶ (‚Äñx‚Äñ / ‚ÄñL n‚Äñ) ‚Ä¢ L n
    have hL'_mem n : ‚àÉ y, StrongDual.centeredToLp Œº 2 y = L' n := by
      choose y' hy' using hL_mem
      refine ‚ü®(‚Äñx‚Äñ / ‚ÄñL n‚Äñ) ‚Ä¢ y' n, ?_‚ü©
      simp [hy' n, L']
    have hL'_tendsto : Tendsto L' atTop (ùìù x) := by
      unfold L'
      have h_norm : Tendsto (fun n ‚Ü¶ ‚ÄñL n‚Äñ) atTop (ùìù ‚Äñx‚Äñ) := hL_tendsto.norm
      suffices Tendsto (fun n ‚Ü¶ (‚Äñx‚Äñ / ‚ÄñL n‚Äñ) ‚Ä¢ L n) atTop (ùìù ((‚Äñx‚Äñ / ‚Äñx‚Äñ) ‚Ä¢ x)) by
        rwa [div_self hx_norm_pos.ne', one_smul] at this
      refine Tendsto.smul ?_ hL_tendsto
      exact Tendsto.div tendsto_const_nhds h_norm hx_norm_pos.ne'
    choose y hy using hL'_mem
    have hy_map' (n : ‚Ñï) : Œº.map (y n) = gaussianReal (Œº[y n]) (‚Äñx‚Äñ‚Çä ^ 2) := by
      rw [IsGaussian.map_eq_gaussianReal]
      congr
      sorry
    have hL'_map n : Œº.map (L' n) = gaussianReal 0 (‚Äñx‚Äñ‚Çä ^ 2) := by
      have h_eq : L' n =·µê[Œº] fun x ‚Ü¶ y n x - Œº[y n] := by
        rw [‚Üê hy]
        filter_upwards [centeredToLp_apply (Œº := Œº) memLp_two_id (y n)] with z hz
        simp only [hz, map_sub, sub_right_inj]
        rw [IsGaussian.integral_dual]
      rw [Measure.map_congr h_eq]
      sorry
    have hL'_prob n : IsProbabilityMeasure (Œº.map (L' n)) := by
      rw [hL'_map n]
      infer_instance
    let ŒΩ n : ProbabilityMeasure ‚Ñù := ‚ü®Œº.map (L' n), hL'_prob n‚ü©
    have hŒΩ_tendsto_1 : Tendsto ŒΩ atTop (ùìù ‚ü®gaussianReal 0 (‚Äñx‚Äñ‚Çä ^ 2), inferInstance‚ü©) := by
      unfold ŒΩ
      simp_rw [hL'_map]
      exact tendsto_const_nhds
    have hx_prob : IsProbabilityMeasure (Œº.map (x : E ‚Üí ‚Ñù)) :=
      isProbabilityMeasure_map (by fun_prop)
    have hŒΩ_tendsto_2 : Tendsto ŒΩ atTop (ùìù ‚ü®Œº.map x, hx_prob‚ü©) := by
      sorry -- implied by convergence in L2
    have h_eq := tendsto_nhds_unique hŒΩ_tendsto_2 hŒΩ_tendsto_1
    rw [Subtype.ext_iff] at h_eq
    exact h_eq

lemma variance_cameronMartinRKHS (x : cameronMartinRKHS Œº) :
    Var[x; Œº] = ‚Äñx‚Äñ‚Çä ^ 2 := by
  have : Var[fun y ‚Ü¶ y; Œº.map x] = ‚Äñx‚Äñ‚Çä ^ 2 := by simp [(hasLaw_cameronMartinRKHS x).map_eq]
  rwa [variance_map aemeasurable_id' (by fun_prop)] at this

lemma covariance_cameronMartinRKHS (x y : cameronMartinRKHS Œº) :
    cov[x, y; Œº] = ‚ü™x, y‚ü´_‚Ñù := by
  rw [covariance_eq_variance_add_sub_div_two (Lp.memLp x.1) (Lp.memLp y.1)]
  have : (x : E ‚Üí ‚Ñù) + (y : E ‚Üí ‚Ñù) =·µê[Œº] (x + y : cameronMartinRKHS Œº) := by
    simp only [Submodule.coe_add, AddSubgroup.coe_add]
    exact (AEEqFun.coeFn_add _ _).symm
  rw [variance_congr this]
  simp_rw [variance_cameronMartinRKHS]
  rw [real_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two]
  simp [pow_two]

lemma isProbabilityMeasure_withDensity_cameronMartin (x : CameronMartin Œº) :
    IsProbabilityMeasure (Œº.withDensity fun y ‚Ü¶
      .ofReal (.exp ((cmIsometryEquiv Œº x : E ‚Üí ‚Ñù) y - ‚Äñx‚Äñ ^ 2 / 2))) where
  measure_univ := by
    rw [withDensity_apply _ .univ, setLIntegral_univ]
    calc ‚à´‚Åª a, .ofReal (.exp ((cmIsometryEquiv Œº x : E ‚Üí ‚Ñù) a - ‚Äñx‚Äñ ^ 2 / 2)) ‚àÇŒº
    _ = .ofReal (.exp (- ‚Äñx‚Äñ ^ 2 / 2))
        * ‚à´‚Åª a, .ofReal (.exp ((cmIsometryEquiv Œº x : E ‚Üí ‚Ñù) a)) ‚àÇŒº := by
      simp_rw [sub_eq_add_neg, Real.exp_add, ENNReal.ofReal_mul (Real.exp_nonneg _)]
      rw [lintegral_mul_const _ (by fun_prop), mul_comm, neg_div]
    _ = .ofReal (.exp (- ‚Äñx‚Äñ ^ 2 / 2))
        * ‚à´‚Åª a, .ofReal (.exp a) ‚àÇ(Œº.map (cmIsometryEquiv Œº x)) := by
      rw [lintegral_map (by fun_prop) (by fun_prop)]
    _ = .ofReal (.exp (- ‚Äñx‚Äñ ^ 2 / 2)) * ‚à´‚Åª a, .ofReal (.exp a) ‚àÇ(gaussianReal 0 (‚Äñx‚Äñ‚Çä ^ 2)) := by
      rw [(hasLaw_cameronMartinRKHS (cmIsometryEquiv Œº x)).map_eq, (cmIsometryEquiv Œº).nnnorm_map]
    _ = .ofReal (.exp (- ‚Äñx‚Äñ ^ 2 / 2)) * .ofReal (.exp (‚Äñx‚Äñ ^ 2 / 2)) := by
      congr
      have h := mgf_id_gaussianReal (Œº := (0 : ‚Ñù)) (v := ‚Äñx‚Äñ‚Çä ^ 2)
      rw [funext_iff] at h
      specialize h 1
      simp only [mgf, id_eq, one_mul, mul_one, NNReal.coe_pow, coe_nnnorm, one_pow, zero_add] at h
      rw [‚Üê h, ofReal_integral_eq_lintegral_ofReal]
      ¬∑ simpa using (integrable_exp_mul_gaussianReal (Œº := (0 : ‚Ñù)) (v := ‚Äñx‚Äñ‚Çä ^ 2) 1)
      ¬∑ exact ae_of_all _ fun _ ‚Ü¶ Real.exp_nonneg _
    _ = 1 := by
      rw [‚Üê ENNReal.ofReal_mul (Real.exp_nonneg _), ‚Üê Real.exp_add]
      ring_nf
      simp

lemma todo_ae_eq (x : CameronMartin Œº) (L : StrongDual ‚Ñù E) (t : ‚Ñù) :
    (cmIsometryEquiv Œº (L - t ‚Ä¢ x) : E ‚Üí ‚Ñù)
      =·µê[Œº] fun u ‚Ü¶ L u - Œº[L] - t * (cmIsometryEquiv Œº x : E ‚Üí ‚Ñù) u := by
  simp only [map_sub, map_smul, AddSubgroupClass.coe_sub, SetLike.val_smul]
  sorry

lemma some_equality_in_Real'' (x : CameronMartin Œº) (L : StrongDual ‚Ñù E) (t : ‚Ñù) :
    ‚à´ u, Complex.exp ((L u - t * (cmIsometryEquiv Œº x : E ‚Üí ‚Ñù) u) * Complex.I
        - ‚Äñx‚Äñ ^ 2 / 2) ‚àÇŒº
      = .exp (- ‚Äñx‚Äñ ^ 2 / 2)
        * ‚à´ u, .exp ((cmIsometryEquiv Œº (L - t ‚Ä¢ x) : E ‚Üí ‚Ñù) u * Complex.I
          + Œº[L] * Complex.I) ‚àÇŒº := by
  calc ‚à´ u, Complex.exp ((L u - t * (cmIsometryEquiv Œº x : E ‚Üí ‚Ñù) u) * Complex.I
        - ‚Äñx‚Äñ ^ 2 / 2) ‚àÇŒº
  _ = .exp (- ‚Äñx‚Äñ ^ 2 / 2)
      * ‚à´ u, .exp ((L u - t * (cmIsometryEquiv Œº x : E ‚Üí ‚Ñù) u) * Complex.I) ‚àÇŒº := by
    simp_rw [sub_eq_add_neg, Complex.exp_add]
    rw [integral_mul_const, mul_comm (Complex.exp _), neg_div]
  _ = .exp (- ‚Äñx‚Äñ ^ 2 / 2)
      * ‚à´ u, .exp ((L u - Œº[L] - t * (cmIsometryEquiv Œº x : E ‚Üí ‚Ñù) u)
        * Complex.I + Œº[L] * Complex.I) ‚àÇŒº := by
    congr with u
    congr
    ring
  _ = .exp (- ‚Äñx‚Äñ ^ 2 / 2)
      * ‚à´ u, .exp ((cmIsometryEquiv Œº (L - t ‚Ä¢ x) : E ‚Üí ‚Ñù) u * Complex.I
        + Œº[L] * Complex.I) ‚àÇŒº := by
    congr 1
    refine integral_congr_ae ?_
    filter_upwards [todo_ae_eq x L t] with u hu
    rw [hu, integral_complex_ofReal]
    simp

lemma some_equality_in_Real' (x : CameronMartin Œº) (L : StrongDual ‚Ñù E) (t : ‚Ñù) :
    ‚à´ u, Complex.exp ((L u - t * (cmIsometryEquiv Œº x : E ‚Üí ‚Ñù) u) * Complex.I
        - ‚Äñx‚Äñ ^ 2 / 2) ‚àÇŒº
      = .exp (- ‚Äñx‚Äñ ^ 2 / 2 + Œº[L] * Complex.I)
        * ‚à´ u : ‚Ñù, .exp (u * Complex.I) ‚àÇ(gaussianReal 0 (‚ÄñL - t ‚Ä¢ x‚Äñ‚Çä ^ 2)) := by
  calc ‚à´ u, Complex.exp ((L u - t * (cmIsometryEquiv Œº x : E ‚Üí ‚Ñù) u) * Complex.I
        - ‚Äñx‚Äñ ^ 2 / 2) ‚àÇŒº
  _ = .exp (- ‚Äñx‚Äñ ^ 2 / 2)
      * ‚à´ u, .exp ((cmIsometryEquiv Œº (L - t ‚Ä¢ x) : E ‚Üí ‚Ñù) u * Complex.I
        + Œº[L] * Complex.I) ‚àÇŒº := by
    exact some_equality_in_Real'' x L t
  _ = .exp (- ‚Äñx‚Äñ ^ 2 / 2)
      * ‚à´ u : ‚Ñù, .exp (u * Complex.I + Œº[L] * Complex.I)
        ‚àÇ(Œº.map (cmIsometryEquiv Œº (L - t ‚Ä¢ x))) := by
    rw [integral_map (by fun_prop) (by fun_prop)]
  _ = .exp (- ‚Äñx‚Äñ ^ 2 / 2)
      * ‚à´ u : ‚Ñù, .exp (u * Complex.I + Œº[L] * Complex.I)
        ‚àÇ(gaussianReal 0 (‚ÄñL - t ‚Ä¢ x‚Äñ‚Çä ^ 2)) := by
    rw [(hasLaw_cameronMartinRKHS (cmIsometryEquiv Œº (L - t ‚Ä¢ x))).map_eq,
      (cmIsometryEquiv Œº).nnnorm_map]
  _ = .exp (- ‚Äñx‚Äñ ^ 2 / 2 + Œº[L] * Complex.I)
      * ‚à´ u : ‚Ñù, .exp (u * Complex.I) ‚àÇ(gaussianReal 0 (‚ÄñL - t ‚Ä¢ x‚Äñ‚Çä ^ 2)) := by
    rw [Complex.exp_add, mul_assoc]
    congr 1
    simp_rw [Complex.exp_add]
    rw [integral_mul_const, mul_comm _ (Complex.exp _)]

lemma some_equality_in_Real (x : CameronMartin Œº) (L : StrongDual ‚Ñù E) (t : ‚Ñù) :
    ‚à´ u, Complex.exp ((L u - t * (cmIsometryEquiv Œº x : E ‚Üí ‚Ñù) u) * Complex.I
        - ‚Äñx‚Äñ ^ 2 / 2) ‚àÇŒº
      = .exp (t * L x.toInitialSpace - (1 + t ^ 2) / 2 * ‚Äñx‚Äñ ^ 2
        + Œº[L] * Complex.I - Var[L; Œº] / 2) := by
  calc ‚à´ u, Complex.exp ((L u - t * (cmIsometryEquiv Œº x : E ‚Üí ‚Ñù) u) * Complex.I
        - ‚Äñx‚Äñ ^ 2 / 2) ‚àÇŒº
  _ = .exp (- ‚Äñx‚Äñ ^ 2 / 2 + Œº[L] * Complex.I)
      * ‚à´ u : ‚Ñù, .exp (u * Complex.I) ‚àÇ(gaussianReal 0 (‚ÄñL - t ‚Ä¢ x‚Äñ‚Çä ^ 2)) := by
    exact some_equality_in_Real' x L t
  _ = .exp (- ‚Äñx‚Äñ ^ 2 / 2 + Œº[L] * Complex.I - ‚ÄñL - t ‚Ä¢ x‚Äñ ^ 2 / 2) := by
    conv_lhs => rw [Complex.exp_add]
    conv_rhs => rw [add_sub_assoc, Complex.exp_add, sub_eq_add_neg, Complex.exp_add, ‚Üê mul_assoc]
    have h := charFun_gaussianReal (Œº := 0) (v := ‚ÄñL - t ‚Ä¢ x‚Äñ‚Çä ^ 2) 1
    simp only [charFun, RCLike.inner_apply, conj_trivial, one_mul, Complex.ofReal_one,
      Complex.ofReal_zero, mul_zero, zero_mul, NNReal.coe_pow, coe_nnnorm, Complex.ofReal_pow,
      one_pow, mul_one, zero_sub] at h
    rw [h]
  _ = .exp (t * L x.toInitialSpace - (1 + t ^ 2) / 2 * ‚Äñx‚Äñ ^ 2
        + Œº[L] * Complex.I - Var[L; Œº] / 2) := by
    have h_inner : (t : ‚ÑÇ) * L x.toInitialSpace = ‚ü™.ofDual Œº L, t ‚Ä¢ x‚ü´_‚Ñù := by
      simp [‚Üê CameronMartin.apply_toInitialSpace_eq_inner]
    rw [h_inner, real_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two]
    simp_rw [‚Üê pow_two]
    rw [CameronMartin.sq_norm_ofDual (Œº := Œº) L]
    simp only [norm_smul, Real.norm_eq_abs, mul_pow, sq_abs, Complex.ofReal_div, Complex.ofReal_sub,
      Complex.ofReal_add, Complex.ofReal_mul, Complex.ofReal_pow, Complex.ofReal_ofNat]
    ring_nf

lemma some_equality_in_Complex (x : CameronMartin Œº) (L : StrongDual ‚Ñù E) (z : ‚ÑÇ) :
    ‚à´ u, Complex.exp ((L u - z * (cmIsometryEquiv Œº x : E ‚Üí ‚Ñù) u) * Complex.I
        - ‚Äñx‚Äñ ^ 2 / 2) ‚àÇŒº
      = .exp (z * L x.toInitialSpace - (1 + z ^ 2) / 2 * ‚Äñx‚Äñ ^ 2
        + Œº[L] * Complex.I - Var[L; Œº] / 2) := by
  revert z
  refine funext_iff.mp ?_
  rw [‚Üê Set.eqOn_univ]
  refine AnalyticOnNhd.eqOn_of_preconnected_of_frequently_eq (ùïú := ‚ÑÇ) (E := ‚ÑÇ) (z‚ÇÄ := 0) ?_ ?_
    isPreconnected_univ (Set.mem_univ 0) ?_
  ¬∑ simp_rw [sub_eq_add_neg, Complex.exp_add, integral_mul_const]
    refine AnalyticOnNhd.mul ?_ analyticOnNhd_const
    simp_rw [‚Üê sub_eq_add_neg]
    sorry
  ¬∑ simp_rw [sub_eq_add_neg, Complex.exp_add]
    refine AnalyticOnNhd.mul ?_ analyticOnNhd_const
    refine AnalyticOnNhd.mul ?_ analyticOnNhd_const
    refine AnalyticOnNhd.mul ?_ ?_
    ¬∑ exact (analyticOnNhd_id.mul analyticOnNhd_const).cexp
    ¬∑ refine (AnalyticOnNhd.mul ?_ analyticOnNhd_const).neg.cexp
      exact (analyticOnNhd_const.add (analyticOnNhd_id.pow 2)).mul analyticOnNhd_const
  -- todo: extract lemma: frequently around a point in ‚Ñù implies frequently around the point in ‚ÑÇ.
  -- This is also used in ComplexMGF
  have h_real : ‚àÉ·∂† (t : ‚Ñù) in ùìù[‚â†] 0,
      ‚à´ u, Complex.exp ((L u - t * (cmIsometryEquiv Œº x : E ‚Üí ‚Ñù) u) * Complex.I
          - ‚Äñx‚Äñ ^ 2 / 2) ‚àÇŒº
        = .exp (t * L x.toInitialSpace - (1 + t ^ 2) / 2 * ‚Äñx‚Äñ ^ 2
          + Œº[L] * Complex.I - Var[L; Œº] / 2) :=
    .of_forall fun y ‚Ü¶ some_equality_in_Real x L y
  rw [frequently_iff_seq_forall] at h_real ‚ä¢
  obtain ‚ü®xs, hx_tendsto, hx_eq‚ü© := h_real
  refine ‚ü®fun n ‚Ü¶ xs n, ?_, fun n ‚Ü¶ ?_‚ü©
  ¬∑ rw [tendsto_nhdsWithin_iff] at hx_tendsto ‚ä¢
    constructor
    ¬∑ rw [‚Üê Complex.ofReal_zero, tendsto_ofReal_iff]
      exact hx_tendsto.1
    ¬∑ simpa using hx_tendsto.2
  ¬∑ simp [hx_eq]

lemma cor_for_z_eq_I (x : CameronMartin Œº) (L : StrongDual ‚Ñù E) :
    ‚à´ u, Complex.exp (L u * Complex.I + (cmIsometryEquiv Œº x : E ‚Üí ‚Ñù) u
        - ‚Äñx‚Äñ ^ 2 / 2) ‚àÇŒº
      = .exp ((Œº[L] + L x.toInitialSpace) * Complex.I - Var[L; Œº] / 2) := by
  have h := some_equality_in_Complex x L Complex.I
  simp only [Complex.I_sq, add_neg_cancel, zero_div, zero_mul, sub_zero] at h
  convert h using 3
  ¬∑ congr
    rw [mul_comm Complex.I, sub_mul, mul_assoc]
    simp
  ¬∑ ring

lemma charFunDual_withDensity_cameronMartin (x : CameronMartin Œº) (L : StrongDual ‚Ñù E) :
    charFunDual
        (Œº.withDensity fun y ‚Ü¶ .ofReal (.exp ((cmIsometryEquiv Œº x : E ‚Üí ‚Ñù) y - ‚Äñx‚Äñ ^ 2 / 2))) L
      = .exp ((Œº[L] + L x.toInitialSpace) * Complex.I - Var[L; Œº] / 2) := by
  calc charFunDual
        (Œº.withDensity fun y ‚Ü¶ .ofReal (.exp ((cmIsometryEquiv Œº x : E ‚Üí ‚Ñù) y - ‚Äñx‚Äñ ^ 2 / 2))) L
  _ = ‚à´ u, Complex.exp (L u * Complex.I + (cmIsometryEquiv Œº x : E ‚Üí ‚Ñù) u
        - ‚Äñx‚Äñ ^ 2 / 2) ‚àÇŒº := by
    rw [charFunDual_apply, integral_withDensity_eq_integral_toReal_smul (by fun_prop)]
    swap; ¬∑ exact ae_of_all _ (by finiteness)
    congr with u
    rw [ENNReal.toReal_ofReal (Real.exp_nonneg _), add_sub_assoc, Complex.exp_add,
      mul_comm (Complex.exp _)]
    simp
  _ = .exp ((Œº[L] + L x.toInitialSpace) * Complex.I - Var[L; Œº] / 2) := cor_for_z_eq_I x L

theorem map_add_cameronMartin_eq_withDensity (x : CameronMartin Œº) :
    Œº.map (fun y ‚Ü¶ y + x.toInitialSpace)
      = Œº.withDensity (fun y ‚Ü¶ .ofReal (.exp ((cmIsometryEquiv Œº x : E ‚Üí ‚Ñù) y - ‚Äñx‚Äñ ^ 2 / 2))) := by
  have := isProbabilityMeasure_withDensity_cameronMartin x
  refine Measure.ext_of_charFunDual ?_
  ext L
  rw [charFunDual_map_add_const, IsGaussian.charFunDual_eq, ‚Üê Complex.exp_add,
    charFunDual_withDensity_cameronMartin x L]
  congr
  ring

theorem absolutelyContinuous_map_add_cameronMartin (x : CameronMartin Œº) :
    Œº.map (fun y ‚Ü¶ y + x.toInitialSpace) ‚â™ Œº := by
  rw [map_add_cameronMartin_eq_withDensity x]
  exact withDensity_absolutelyContinuous _ _

end ProbabilityTheory
