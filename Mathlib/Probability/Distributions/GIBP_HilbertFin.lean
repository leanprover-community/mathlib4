
import Probability.Distributions.GaussianIntegrationByParts
import Mathlib
import Mathlib.Analysis.MeanInequalitiesPow


/-!
# Gaussian Integration by Parts on a real Hilbert space (finite-dimensional, covariant form)

This file lifts the one-dimensional Gaussian integration by parts (Stein's lemma) to a
finite-dimensional real Hilbert space `H` by decomposing along an
orthonormal basis and applying the 1D result on each coordinate, with a
conditioning argument.

Compared with a "standard" (identity covariance) statement, we work directly at
covariant generality: the coordinates may have arbitrary (nonnegative)
variances `œÑ i`. The covariance operator is then

```
Œ£ h = ‚àë i, (œÑ i : ‚Ñù) * ‚ü™h, w i‚ü´ ‚Ä¢ w i,
```

and the IBP identity reads

```
E[‚ü™g, h‚ü´ F(g)] = E[(fderiv ‚Ñù F (g)) (Œ£ h)].
```

The proof strategy:
* Fix an orthonormal basis `w : OrthonormalBasis Œπ ‚Ñù H` with `[Fintype Œπ]`.
* Model a centered Gaussian `g : Œ© ‚Üí H` via independent centered normal
  coordinates `c i : Œ© ‚Üí ‚Ñù` of variances `œÑ i` so that `g = ‚àë i, (c i) ‚Ä¢ w i`.
* Expand `‚ü™g, h‚ü´ = ‚àë i (c i) * ‚ü™h, w i‚ü´` and reduce to a 1D conditional step
  along each coordinate, which contributes a factor `œÑ i`.

We package the modeling assumptions into a predicate `IsGaussianHilbert`.

NOTE: We restrict to a *finite* orthonormal basis index `Œπ`
with `[Fintype Œπ]`. TODO: Extending to separable infinite-dimensional spaces.
-/

open scoped Filter BigOperators Topology ProbabilityTheory ENNReal InnerProductSpace NNReal
open MeasureTheory Filter Set

noncomputable section

namespace PhysLean.Probability.GaussianIBP

variable {Œ© : Type*} [MeasureSpace Œ©] [IsProbabilityMeasure (‚Ñô : Measure Œ©)]
variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ‚Ñù H] [CompleteSpace H]
variable [MeasurableSpace H] [BorelSpace H]

-- Expectation notation (local; avoids referring to section variables in the expansion)
local notation3 (prettyPrint := false) "ùîº[" e "]" => ‚à´ œâ, e ‚àÇ‚Ñô

/-- A centered Gaussian `H`-valued random variable modeled by coordinates -/
structure IsGaussianHilbert (g : Œ© ‚Üí H) where
  /-- Finite index type for the orthonormal basis. -/
  Œπ : Type*
  /-- Finite type structure on the index `Œπ`. -/
  fintype_Œπ : Fintype Œπ
  /-- An orthonormal basis of `H` indexed by `Œπ`. -/
  w : OrthonormalBasis Œπ ‚Ñù H
  /-- Coordinate variances `œÑ i ‚â• 0` (as `NNReal`). -/
  œÑ : Œπ ‚Üí NNReal
  /-- Coordinate random variables `c i : Œ© ‚Üí ‚Ñù`. -/
  c : Œπ ‚Üí Œ© ‚Üí ‚Ñù
  /-- Measurability of each coordinate process `c i`. -/
  c_meas : ‚àÄ i, Measurable (c i)
  /-- Each coordinate `c i` is centered Gaussian with variance `œÑ i`. -/
  c_gauss : ‚àÄ i, ProbabilityTheory.IsCenteredGaussianRV (c i) (œÑ i)
  /-- Independence of the family of coordinates `(c i)_i`. -/
  c_indep : ProbabilityTheory.iIndepFun c ‚Ñô
  /-- Representation of `g` as the finite ONB sum `‚àë i, (c i) ‚Ä¢ w i`. -/
  repr : g = fun œâ => ‚àë i, (c i œâ) ‚Ä¢ w i

attribute [instance] IsGaussianHilbert.fintype_Œπ

/-- Moderate growth on `H ‚Üí ‚Ñù` -/
structure HasModerateGrowth {H : Type*} [NormedAddCommGroup H] [NormedSpace ‚Ñù H]
    (F : H ‚Üí ‚Ñù) where
  /-- A positive constant controlling the growth bound. -/
  C : ‚Ñù
  /-- A natural exponent controlling the polynomial growth. -/
  m : ‚Ñï
  /-- Positivity of the growth constant. -/
  Cpos : 0 < C
  /-- Pointwise bound on `F`: `|F z| ‚â§ C * (1 + ‚Äñz‚Äñ) ^ m`. -/
  F_bound : ‚àÄ z, |F z| ‚â§ C * (1 + ‚Äñz‚Äñ) ^ m
  /-- Operator-norm bound on the Fr√©chet derivative:
      `‚Äñfderiv ‚Ñù F z‚Äñ ‚â§ C * (1 + ‚Äñz‚Äñ) ^ m`. -/
  dF_bound : ‚àÄ z, ‚Äñfderiv ‚Ñù F z‚Äñ ‚â§ C * (1 + ‚Äñz‚Äñ) ^ m

namespace HasModerateGrowth

variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ‚Ñù H]

lemma bound_dF_apply {F : H ‚Üí ‚Ñù} (hMG : HasModerateGrowth F) (z h : H) :
    ‚Äñ(fderiv ‚Ñù F z) h‚Äñ ‚â§ hMG.C * (1 + ‚Äñz‚Äñ) ^ hMG.m * ‚Äñh‚Äñ := by
  have h‚ÇÅ : ‚Äñ(fderiv ‚Ñù F z) h‚Äñ ‚â§ ‚Äñfderiv ‚Ñù F z‚Äñ * ‚Äñh‚Äñ :=
    ContinuousLinearMap.le_opNorm _ _
  have h‚ÇÇ : ‚Äñfderiv ‚Ñù F z‚Äñ * ‚Äñh‚Äñ ‚â§ (hMG.C * (1 + ‚Äñz‚Äñ) ^ hMG.m) * ‚Äñh‚Äñ :=
    mul_le_mul_of_nonneg_right (hMG.dF_bound z) (norm_nonneg _)
  exact h‚ÇÅ.trans h‚ÇÇ

end HasModerateGrowth

namespace Aux

variable {Œπ : Type*} [Fintype Œπ]
variable (w : OrthonormalBasis Œπ ‚Ñù H)

omit [CompleteSpace H] [MeasurableSpace H] [BorelSpace H] in
@[simp] lemma inner_decomp (x y : H) :
    ‚ü™x, y‚ü´_‚Ñù = ‚àë i, (‚ü™x, w i‚ü´_‚Ñù) * (‚ü™y, w i‚ü´_‚Ñù) := by
  simpa [real_inner_comm] using (w.sum_inner_mul_inner x y).symm

end Aux

/-- Coordinates of `g` in the basis `w`. -/
@[simp] def coord {Œπ : Type*} [Fintype Œπ]
    (w : OrthonormalBasis Œπ ‚Ñù H) (g : Œ© ‚Üí H) (i : Œπ) : Œ© ‚Üí ‚Ñù :=
  fun œâ => ‚ü™g œâ, w i‚ü´_‚Ñù

omit [IsProbabilityMeasure (‚Ñô : Measure Œ©)] [CompleteSpace H] [MeasurableSpace H] [BorelSpace H] in
/-- Explicit formula for the coordinates of `g` in the basis `w`. -/
lemma coord_repr_eq
    {g : Œ© ‚Üí H} (hg : IsGaussianHilbert g) (i : hg.Œπ) :
    coord hg.w g i = fun œâ => ‚ü™g œâ, hg.w i‚ü´_‚Ñù := rfl

omit [IsProbabilityMeasure (‚Ñô : Measure Œ©)] [CompleteSpace H] [MeasurableSpace H] [BorelSpace H] in
/-- On a Gaussian Hilbert model, the abstract coordinate map coincides with the
explicit coefficient process supplied by the model. -/
lemma coord_eq_c {g : Œ© ‚Üí H} (hg : IsGaussianHilbert g) :
    coord hg.w g = hg.c := by
  classical
  funext i œâ
  -- Expand g œâ and move inner through the finite sum.
  have hrepr : g œâ = ‚àë j : hg.Œπ, (hg.c j œâ) ‚Ä¢ hg.w j := by
    simpa using congrArg (fun f => f œâ) hg.repr
  simp only [coord, hrepr, sum_inner, inner_smul_left]
  -- The sum collapses to the i-th term by orthonormality.
  convert Finset.sum_eq_single i (fun j _ hij => ?_) (fun hi => ?_)
  ¬∑ -- The i-th term is `c i œâ * ‚ü™w i, w i‚ü´ = c i œâ * 1`.
    simp [OrthonormalBasis.inner_eq_ite]
  ¬∑ -- Off-diagonal terms `j ‚â† i` are zero.
    simp [OrthonormalBasis.inner_eq_ite, hij]
  ¬∑ -- The index `i` is always in the universe.
    exact (hi (Finset.mem_univ i)).elim

omit [IsProbabilityMeasure (‚Ñô : Measure Œ©)] [CompleteSpace H] [MeasurableSpace H] [BorelSpace H] in
/-- For a Gaussian Hilbert model, each coordinate is centered normal with the
specified variance, and the coordinates are independent. -/
lemma coord_isGaussian_and_indep {g : Œ© ‚Üí H}
    (hg : IsGaussianHilbert g) :
    (‚àÄ i, ProbabilityTheory.IsCenteredGaussianRV (coord hg.w g i) (hg.œÑ i)) ‚àß
    ProbabilityTheory.iIndepFun (coord hg.w g) ‚Ñô := by
  classical
  have hcoord : coord hg.w g = hg.c := coord_eq_c (g := g) hg
  refine ‚ü®?std, ?indep‚ü©
  ¬∑ intro i; simpa [hcoord] using hg.c_gauss i
  ¬∑ simpa [hcoord] using hg.c_indep

omit [IsProbabilityMeasure (‚Ñô : Measure Œ©)] [CompleteSpace H] [MeasurableSpace H] [BorelSpace H] in
/-- Coordinates are measurable functions (inherited from the model `c`). -/
lemma coord_measurable {g : Œ© ‚Üí H} (hg : IsGaussianHilbert g) :
    ‚àÄ i, Measurable (coord hg.w g i) := by
  intro i
  simpa [coord_eq_c (g := g) hg] using hg.c_meas i

/-! ## Integrability lemmas and linearity under sums
The following lemmas gather the integrability facts needed to justify using
`integral_finset_sum`, pulling constants outside expectations, and swapping a
finite sum with an expectation.

We also provide a *weighted* linearity lemma for `fderiv` inside a finite sum.
section Integrability-/

section AuxMeasAndMoments

open scoped BigOperators
open MeasureTheory ProbabilityTheory

variable {Œ© : Type*} [MeasureSpace Œ©] [IsProbabilityMeasure (‚Ñô : Measure Œ©)]
variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ‚Ñù H] [CompleteSpace H]
variable [MeasurableSpace H] [BorelSpace H]
variable {g : Œ© ‚Üí H} {F : H ‚Üí ‚Ñù}
variable {g : Œ© ‚Üí H} {F : H ‚Üí ‚Ñù}


omit [IsProbabilityMeasure (‚Ñô : Measure Œ©)] [CompleteSpace H] in
/-- `g` is measurable from the coordinate representation in the Gaussian model. -/
lemma IsGaussianHilbert.repr_measurable (hg : IsGaussianHilbert (Œ© := Œ©) (H := H) g) :
    Measurable g := by
  classical
  let Œ¶ : (hg.Œπ ‚Üí ‚Ñù) ‚Üí H := fun y => ‚àë i, (y i) ‚Ä¢ hg.w i
  have hŒ¶_cont : Continuous Œ¶ := by
    have h_i : ‚àÄ i : hg.Œπ, Continuous fun y : (hg.Œπ ‚Üí ‚Ñù) => (y i) ‚Ä¢ hg.w i := by
      intro i
      exact (continuous_apply i).smul continuous_const
    simpa [Œ¶] using
      (continuous_finset_sum (s := (Finset.univ : Finset hg.Œπ)) (fun i _ => h_i i))
  let cvec : Œ© ‚Üí (hg.Œπ ‚Üí ‚Ñù) := fun œâ i => hg.c i œâ
  have hcvec_meas : Measurable cvec := by
    refine measurable_pi_iff.mpr ?_
    intro i
    simpa [cvec] using hg.c_meas i
  have : Measurable (fun œâ => Œ¶ (cvec œâ)) := hŒ¶_cont.measurable.comp hcvec_meas
  simpa [hg.repr, Œ¶, cvec] using this

omit [IsProbabilityMeasure (‚Ñô : Measure Œ©)] in
/-- For a centered real Gaussian random variable, the square is integrable. -/
lemma ProbabilityTheory.IsCenteredGaussianRV.integrable_sq
    {X : Œ© ‚Üí ‚Ñù} {v : ‚Ñù‚â•0}
    (hX : ProbabilityTheory.IsCenteredGaussianRV X v)
    (hX_meas : Measurable X) :
    Integrable (fun œâ => (X œâ)^2) := by
  have h_int_gauss : Integrable (fun x : ‚Ñù => x^2) (gaussianReal 0 v) := by
    simpa using ProbabilityTheory.integrable_sq_gaussianReal_centered (v := v)
  have hmap : Measure.map X (‚Ñô : Measure Œ©) = gaussianReal 0 v := hX
  have h_int_map : Integrable (fun x : ‚Ñù => x^2) (Measure.map X (‚Ñô : Measure Œ©)) := by
    simpa [hmap] using h_int_gauss
  exact h_int_map.comp_measurable (Œº := (‚Ñô : Measure Œ©)) hX_meas

end AuxMeasAndMoments

section Integrability

open MeasureTheory ProbabilityTheory

variable {Œ© : Type*} [MeasureSpace Œ©] [IsProbabilityMeasure (‚Ñô : Measure Œ©)]
variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ‚Ñù H] [CompleteSpace H]
variable [MeasurableSpace H] [BorelSpace H]
variable {g : Œ© ‚Üí H} {F : H ‚Üí ‚Ñù}

omit [CompleteSpace H][MeasurableSpace H] [BorelSpace H] in
/-- The finite sum of absolute Gaussian coordinates is integrable. -/
lemma integrable_sum_abs_coords (hg : IsGaussianHilbert g) :
    Integrable (fun œâ => ‚àë i, |coord hg.w g i œâ|) := by
  classical
  have hL1_each : ‚àÄ i : hg.Œπ, Integrable (fun œâ => |coord hg.w g i œâ|) := by
    intro i
    have hL2 : Integrable (fun œâ => (coord hg.w g i œâ) ^ 2) := by
      have hGauss := (coord_isGaussian_and_indep (g := g) hg).1 i
      have hMeas := coord_measurable (g := g) hg i
      exact ProbabilityTheory.IsCenteredGaussianRV.integrable_sq (X := coord hg.w g i)
        (v := hg.œÑ i) hGauss hMeas
    have h_major_int : Integrable (fun œâ => 1 + (coord hg.w g i œâ) ^ 2) := by
      simpa using (integrable_const (Œº := (‚Ñô : Measure Œ©)) (c := (1 : ‚Ñù))).add hL2
    have h_meas : AEStronglyMeasurable (fun œâ => |coord hg.w g i œâ|) ‚Ñô :=
      (coord_measurable (g := g) hg i).abs.aestronglyMeasurable
    have h_dom : ‚àÄ·µê œâ ‚àÇ‚Ñô, ‚Äñ|coord hg.w g i œâ|‚Äñ ‚â§ 1 + (coord hg.w g i œâ) ^ 2 := by
      refine Eventually.of_forall (fun œâ => ?_)

      set x := coord hg.w g i œâ
      have h0 : 0 ‚â§ x ^ 2 := sq_nonneg x
      have h1 : (1 : ‚Ñù) ‚â§ 1 + x ^ 2 := by exact le_add_of_nonneg_right h0
      by_cases hx : |x| ‚â§ 1
      ¬∑ exact (le_trans (by simpa [Real.norm_eq_abs, abs_abs] using hx)
          (by simpa [Real.norm_eq_abs, abs_abs, add_comm] using h1))
      ¬∑ have hgt : 1 < |x| := not_le.mp hx
        have habs_nonneg : 0 ‚â§ |x| := abs_nonneg x
        have h_le_sq : |x| ‚â§ |x| * |x| := by
          have := mul_le_mul_of_nonneg_left (le_of_lt hgt) habs_nonneg
          simpa [one_mul] using this
        have h_le_sq' : |x| ‚â§ x^2 := by simpa [pow_two, sq_abs] using h_le_sq
        have hx2_le : x^2 ‚â§ 1 + x^2 := by
          have : 0 ‚â§ (1 : ‚Ñù) := by exact zero_le_one
          simp [add_comm]
        have : |x| ‚â§ 1 + x^2 := le_trans h_le_sq' hx2_le
        simpa [Real.norm_eq_abs, abs_abs] using this
    exact h_major_int.mono' h_meas h_dom
  simpa using
    (integrable_finset_sum
      (s := (Finset.univ : Finset hg.Œπ))
      (f := fun i œâ => |coord hg.w g i œâ|)
      (by intro i _; simpa using hL1_each i))

omit [CompleteSpace H] in
/-- A finite-dimensional Gaussian has integrable norm. -/
lemma integrable_norm_of_gaussian (hg : IsGaussianHilbert g) :
    Integrable (fun œâ => ‚Äñg œâ‚Äñ) := by
  classical
  have hcoord : coord hg.w g = hg.c := coord_eq_c (g := g) hg
  have hsum : ‚àÄ œâ, g œâ = ‚àë i, (hg.c i œâ) ‚Ä¢ hg.w i := by
    intro œâ
    simpa using congrArg (fun f => f œâ) hg.repr
  have hnorm_w_one : ‚àÄ i : hg.Œπ, ‚Äñhg.w i‚Äñ = (1 : ‚Ñù) := by
    intro i; simp
  have h_norm_le : ‚àÄ œâ, ‚Äñg œâ‚Äñ ‚â§ ‚àë i, |coord hg.w g i œâ| := by
    intro œâ
    have h_step :
        ‚Äñg œâ‚Äñ ‚â§ ‚àë i, ‚Äñ(hg.c i œâ) ‚Ä¢ hg.w i‚Äñ := by
      calc
        ‚Äñg œâ‚Äñ = ‚Äñ‚àë i, (hg.c i œâ) ‚Ä¢ hg.w i‚Äñ := by simp [hsum œâ]
        _ ‚â§ ‚àë i, ‚Äñ(hg.c i œâ) ‚Ä¢ hg.w i‚Äñ := by
          simpa using
            (norm_sum_le (s := (Finset.univ : Finset hg.Œπ))
              (f := fun i => (hg.c i œâ) ‚Ä¢ hg.w i))
    have h_to_abs :
        ‚àë i, ‚Äñ(hg.c i œâ) ‚Ä¢ hg.w i‚Äñ = ‚àë i, |hg.c i œâ| := by
      refine Finset.sum_congr rfl (by
        intro i _
        simp [norm_smul, hnorm_w_one i] )
    have h_to_coord :
        ‚àë i, |hg.c i œâ| = ‚àë i, |coord hg.w g i œâ| := by
      refine Finset.sum_congr rfl (by
        intro i _; simp [hcoord]; rw [‚Üê hcoord]; rfl )
    exact h_step.trans (by simp [h_to_abs, h_to_coord])
  have h_sum_int := integrable_sum_abs_coords (hg := hg)
  refine h_sum_int.mono' (hg.repr_measurable.norm.aestronglyMeasurable) ?_
  exact Filter.Eventually.of_forall (fun œâ => by
    have : ‚Äñ‚Äñg œâ‚Äñ‚Äñ = ‚Äñg œâ‚Äñ := by
      simp [Real.norm_eq_abs, abs_of_nonneg (norm_nonneg _)]
    simpa [this] using (h_norm_le œâ))

omit [CompleteSpace H] in
/-- Backwards-compatible wrapper: the only cases used below are `p = 1` and
polynomial profiles, both covered by the previous lemmas. For `p = 1`
we provide this alias. -/
lemma integrable_norm_pow_one_of_gaussian (hg : IsGaussianHilbert g) :
    Integrable (fun œâ => ‚Äñg œâ‚Äñ ^ (1 : ‚Ñù)) := by
  simpa using (integrable_norm_of_gaussian (hg := hg))

/-! ### A clean domination by polynomial moments

For p ‚â• 0 and any natural m with p ‚â§ m, we have the pointwise bound
  x^p ‚â§ (1 + x)^m  for all x ‚â• 0.
This yields integrability of ‚Äñg‚Äñ^p from the polynomial moment
integrability already proved in `integrable_one_add_norm_pow`.
-/


/-- Scalar inequality: for `p ‚â• 0`, `p ‚â§ m : ‚Ñï`, and `x ‚â• 0`,
we have `x^p ‚â§ (1 + x)^m`. -/
lemma rpow_le_one_add_pow_nat_of_le (p : ‚Ñù) (m : ‚Ñï)
    (hp : 0 ‚â§ p) (hp_le : p ‚â§ m) :
    ‚àÄ x : ‚Ñù, 0 ‚â§ x ‚Üí x ^ p ‚â§ (1 + x) ^ m := by
  intro x hx
  by_cases hxle1 : x ‚â§ 1
  ¬∑ have hxp_le_one : x ^ p ‚â§ (1 : ‚Ñù) ^ p :=
      Real.rpow_le_rpow hx hxle1 hp
    have hone : (1 : ‚Ñù) ^ p = (1 : ‚Ñù) := by simp
    have h1le : (1 : ‚Ñù) ‚â§ (1 + x) ^ m := by
      have h01x : 1 ‚â§ 1 + x := by linarith
      have h0 : 0 ‚â§ 1 + x := by linarith
      simp [one_pow]
      exact one_le_pow‚ÇÄ h01x
    exact (by
      have : x ^ p ‚â§ (1 : ‚Ñù) := by simpa [hone] using hxp_le_one
      exact this.trans h1le)
  ¬∑ have hx1 : 1 ‚â§ x := le_of_lt (lt_of_not_ge hxle1)
    have hxp_le_xm : x ^ p ‚â§ x ^ (m : ‚Ñù) := Real.rpow_le_rpow_of_exponent_le hx1 hp_le
    have hx_nonneg : 0 ‚â§ x := hx
    have hx_le_1x : x ‚â§ 1 + x := by linarith
    have xpow_nat :
        (x : ‚Ñù) ^ (m : ‚Ñù) = (x ^ m : ‚Ñù) := by
      simp
    have x_pow_le_one_add :
        (x ^ m : ‚Ñù) ‚â§ (1 + x) ^ m :=
          ProbabilityTheory.Real.pow_le_pow_of_le_left hx hx_le_1x
    calc
      x ^ p ‚â§ x ^ (m : ‚Ñù) := hxp_le_xm
      _ = (x ^ m : ‚Ñù) := by simp [xpow_nat]
      _ ‚â§ (1 + x) ^ m := x_pow_le_one_add

section MeanIneqHelpers

open scoped BigOperators
open Finset

variable {Œπ : Type*}

/-- For `p ‚â• 1` and nonnegative weights `z i ‚â• 0`, the generalized mean inequality
(unnormalized) on a finite set `s`:

  (‚àë i‚ààs, z i)^p ‚â§ (s.card : ‚Ñù)^(p - 1) * ‚àë i‚ààs, (z i)^p.

This is the equal-weights case of `Real.rpow_arith_mean_le_arith_mean_rpow`. -/
lemma sum_rpow_le_card_pow_sub_one_sum_rpow
    (s : Finset Œπ) (z : Œπ ‚Üí ‚Ñù) {p : ‚Ñù}
    (hp : 1 ‚â§ p) (hz : ‚àÄ i ‚àà s, 0 ‚â§ z i) :
    (‚àë i ‚àà s, z i) ^ p ‚â§ (s.card : ‚Ñù) ^ (p - 1) * ‚àë i ‚àà s, (z i) ^ p := by
  classical
  by_cases h0 : s.card = 0
  ¬∑ have hs : s = ‚àÖ := Finset.card_eq_zero.mp h0
    have hp0 : 0 < p := by linarith
    simp [hs, hp0.ne']
  ¬∑ have hcard_pos_nat : 0 < s.card := Nat.pos_of_ne_zero (by simpa using h0)
    have hcard_pos : 0 < (s.card : ‚Ñù) := by exact_mod_cast hcard_pos_nat
    let c : ‚Ñù := s.card
    have hc_pos : 0 < c := by simpa [c] using hcard_pos
    have hc_nonneg : 0 ‚â§ c := le_of_lt hc_pos
    have hw_nonneg : ‚àÄ i ‚àà s, 0 ‚â§ c‚Åª¬π := fun _ _ => inv_nonneg.mpr hc_nonneg
    have hw_sum : ‚àë i ‚àà s, c‚Åª¬π = 1 := by
      simp [Finset.sum_const, nsmul_eq_mul, c, mul_comm, inv_mul_cancel, ne_of_gt hc_pos]
    have hmean :
        (‚àë i ‚àà s, c‚Åª¬π * z i) ^ p ‚â§ ‚àë i ‚àà s, c‚Åª¬π * (z i) ^ p :=
      Real.rpow_arith_mean_le_arith_mean_rpow
        (s := s) (w := fun _ => c‚Åª¬π) (z := z) hw_nonneg hw_sum hz hp
    have hR : (‚àë i ‚àà s, c‚Åª¬π * (z i) ^ p) = c‚Åª¬π * ‚àë i ‚àà s, (z i) ^ p := by
      simp [mul_sum]
    have ha_nonneg : 0 ‚â§ ‚àë i ‚àà s, c‚Åª¬π * z i :=
      Finset.sum_nonneg (by
        intro i hi; exact mul_nonneg (inv_nonneg.mpr hc_nonneg) (hz i hi))
    have hmul :
        (c : ‚Ñù) ^ p * (‚àë i ‚àà s, c‚Åª¬π * z i) ^ p
          ‚â§ (c : ‚Ñù) ^ p * (c‚Åª¬π * ‚àë i ‚àà s, (z i) ^ p) := by
      exact mul_le_mul_of_nonneg_left (by simpa [hR] using hmean)
        (Real.rpow_nonneg hc_nonneg _)
    have c_mul_avg :
        c * (‚àë i ‚àà s, c‚Åª¬π * z i) = ‚àë i ‚àà s, z i := by
      calc
        c * (‚àë i ‚àà s, c‚Åª¬π * z i)
            = ‚àë i ‚àà s, c * (c‚Åª¬π * z i) := by simp [mul_sum]
        _ = ‚àë i ‚àà s, (c * c‚Åª¬π) * z i := by
          refine Finset.sum_congr rfl (by intro i hi; simp [mul_assoc])
        _ = ‚àë i ‚àà s, z i := by
          simp [inv_mul_cancel, ne_of_gt hc_pos, mul_comm, mul_left_comm, mul_assoc]
    have hL :
        (c : ‚Ñù) ^ p * (‚àë i ‚àà s, c‚Åª¬π * z i) ^ p = (‚àë i ‚àà s, z i) ^ p := by
      have : (c * (‚àë i ‚àà s, c‚Åª¬π * z i)) ^ p
              = (c : ‚Ñù) ^ p * (‚àë i ‚àà s, c‚Åª¬π * z i) ^ p :=
        Real.mul_rpow hc_nonneg ha_nonneg
      aesop
    have hpow_mul_right :
        (c : ‚Ñù) ^ p * (c‚Åª¬π * ‚àë i ‚àà s, (z i) ^ p)
          = (c : ‚Ñù) ^ (p - 1) * ‚àë i ‚àà s, (z i) ^ p := by
      have hpdecomp : (c : ‚Ñù) ^ p = (c : ‚Ñù) ^ (p - 1) * (c : ‚Ñù) ^ 1 := by
        simpa [sub_eq_add_neg, Real.rpow_one, add_comm, add_left_comm, add_assoc] using
          (Real.rpow_add hc_pos (p - 1) (1 : ‚Ñù))
      calc
        (c : ‚Ñù) ^ p * (c‚Åª¬π * ‚àë i ‚àà s, (z i) ^ p)
            = ((c : ‚Ñù) ^ (p - 1) * (c : ‚Ñù) ^ 1) * (c‚Åª¬π * ‚àë i ‚àà s, (z i) ^ p) := by
              simp [hpdecomp]
        _ = (c : ‚Ñù) ^ (p - 1) * ((c : ‚Ñù) ^ 1 * (c‚Åª¬π * ‚àë i ‚àà s, (z i) ^ p)) := by
              simp [mul_comm, mul_left_comm, mul_assoc]
        _ = (c : ‚Ñù) ^ (p - 1) * (‚àë i ‚àà s, (z i) ^ p) := by
          have : (c : ‚Ñù) ^ 1 = c := by simp [Real.rpow_one]
          simp [this, mul_comm, mul_left_comm, mul_assoc, inv_mul_cancel, ne_of_gt hc_pos]
    simpa [hL, hpow_mul_right] using hmul

end MeanIneqHelpers

section PolynomialMoments

open scoped BigOperators
open MeasureTheory ProbabilityTheory
open Finset

variable {g : Œ© ‚Üí H}


/-! 1D Gaussian moment helpers (all nat moments are finite). -/
namespace ProbabilityTheory

/-- All absolute moments `|x|^k` are integrable under any centered real Gaussian. -/
lemma integrable_abs_pow_gaussianReal_centered_nat
    (v : ‚Ñù‚â•0) (k : ‚Ñï) :
    Integrable (fun x : ‚Ñù => |x| ^ k) (ProbabilityTheory.gaussianReal 0 v) := by
  have h_poly : Integrable (fun x : ‚Ñù => (1 + |x|) ^ k)
      (ProbabilityTheory.gaussianReal 0 v) := by
    simpa using
      ProbabilityTheory.gaussianReal_integrable_one_add_abs_pow_centered (v := v) (k := k)
  have h_meas :
      AEStronglyMeasurable (fun x : ‚Ñù => |x| ^ k) (ProbabilityTheory.gaussianReal 0 v) := by
    exact ((measurable_id'.abs.pow_const k)).aestronglyMeasurable
  have h_dom :
      ‚àÄ·µê x ‚àÇ(ProbabilityTheory.gaussianReal 0 v),
        ‚Äñ|x| ^ k‚Äñ ‚â§ (1 + |x|) ^ k := by
    refine ae_of_all _ (fun x => ?_)
    have hx : 0 ‚â§ |x| := abs_nonneg x
    have hle : |x| ‚â§ 1 + |x| := by linarith
    have : |x| ^ k ‚â§ (1 + |x|) ^ k := ProbabilityTheory.Real.pow_le_pow_of_le_left hx hle
    simpa [Real.norm_eq_abs, abs_of_nonneg (pow_nonneg hx _)] using this
  exact h_poly.mono' h_meas h_dom

omit [IsProbabilityMeasure (‚Ñô : Measure Œ©)] in
/-- Lift to an RV: a centered Gaussian RV has all finite absolute moments. -/
lemma IsCenteredGaussianRV.integrable_abs_pow_nat
    {X : Œ© ‚Üí ‚Ñù} {v : ‚Ñù‚â•0}
    (hX : ProbabilityTheory.IsCenteredGaussianRV X v)
    (hX_meas : Measurable X) (k : ‚Ñï) :
    Integrable (fun œâ => |X œâ| ^ k) := by
  have hmap : Measure.map X (‚Ñô : Measure Œ©) = ProbabilityTheory.gaussianReal 0 v := hX
  have h_int_map :
      Integrable (fun x : ‚Ñù => |x| ^ k) (Measure.map X (‚Ñô : Measure Œ©)) := by
    simpa [hmap] using
      integrable_abs_pow_gaussianReal_centered_nat (v := v) (k := k)
  exact h_int_map.comp_measurable (Œº := (‚Ñô : Measure Œ©)) hX_meas

end ProbabilityTheory

-- Monotonicity of natural powers on ‚Ñù for nonnegative bases.
namespace Real

lemma pow_le_pow_of_le_left {a b : ‚Ñù} (ha : 0 ‚â§ a) (hab : a ‚â§ b) (n : ‚Ñï) :
    a ^ n ‚â§ b ^ n := by
  induction' n with k hk
  ¬∑ simp
  ¬∑ have hb : 0 ‚â§ b := ha.trans hab
    have h1 : a ^ k * a ‚â§ a ^ k * b :=
      mul_le_mul_of_nonneg_left hab (pow_nonneg ha k)
    have h2 : a ^ k * b ‚â§ b ^ k * b :=
      mul_le_mul_of_nonneg_right hk hb
    simpa [pow_succ] using h1.trans h2

end Real

section FiniteOnbPowerDomination

open scoped BigOperators
open Finset MeasureTheory ProbabilityTheory

variable {Œπ Œ© H : Type*}
variable [Fintype Œπ]
variable [NormedAddCommGroup H] [InnerProductSpace ‚Ñù H]
variable [MeasurableSpace Œ©] {Œº : Measure Œ©}

/-- For a finite orthonormal basis `w` and coefficients `c : Œπ ‚Üí ‚Ñù`, raise the
norm of the finite sum to a natural power and dominate it by the sum of powers
of the coefficients (generalized mean inequality, equal-weights case). -/
lemma norm_pow_nat_le_card_pow_pred_sum_abs_pow
  (w : OrthonormalBasis Œπ ‚Ñù H) (c : Œπ ‚Üí ‚Ñù) (m : ‚Ñï) (hm : 1 ‚â§ m) :
  ‚Äñ‚àë i, c i ‚Ä¢ w i‚Äñ ^ m ‚â§ (Fintype.card Œπ : ‚Ñù) ^ (m - 1) * ‚àë i, |c i| ^ m := by
  classical
  cases m with
  | zero => cases hm
  | succ k =>
    have h‚ÇÅ : ‚Äñ‚àë i, c i ‚Ä¢ w i‚Äñ ‚â§ ‚àë i, ‚Äñc i ‚Ä¢ w i‚Äñ := by
      simpa using norm_sum_le (s := (Finset.univ : Finset Œπ)) (f := fun i => c i ‚Ä¢ w i)
    have h‚ÇÇ : ‚àÄ i, ‚Äñc i ‚Ä¢ w i‚Äñ = |c i| := fun i => by
      -- `‚Äñw i‚Äñ = 1`
      have hw : ‚Äñw i‚Äñ = (1 : ‚Ñù) := by simp
      simp [norm_smul, hw]
    have hsum_univ :
        ‚àë i ‚àà (Finset.univ : Finset Œπ), ‚Äñc i ‚Ä¢ w i‚Äñ
          = ‚àë i ‚àà (Finset.univ : Finset Œπ), |c i| := by
      refine Finset.sum_congr rfl ?_
      intro i hi; simp [h‚ÇÇ i]
    have hsum : ‚àë i, ‚Äñc i ‚Ä¢ w i‚Äñ = ‚àë i, |c i| := by
      simpa using hsum_univ
    let n := Nat.succ k
    have hnn : 0 ‚â§ ‚Äñ‚àë i, c i ‚Ä¢ w i‚Äñ := norm_nonneg _
    have h‚ÇÅm : ‚Äñ‚àë i, c i ‚Ä¢ w i‚Äñ ^ n ‚â§ (‚àë i, |c i|) ^ n := by
      exact Real.pow_le_pow_of_le_left hnn (by simpa [hsum] using h‚ÇÅ) n
    have hmean_main :
        (‚àë i, |c i|) ^ n
          ‚â§ (Fintype.card Œπ : ‚Ñù) ^ (n - 1) * ‚àë i, |c i| ^ n := by
      by_cases h0 : Fintype.card Œπ = 0
      ¬∑ have : (Finset.univ : Finset Œπ) = ‚àÖ := by
          simpa using Finset.card_eq_zero.mp h0
        simp [this, h0]
      ¬∑ set s : Finset Œπ := Finset.univ
        set cR : ‚Ñù := (Fintype.card Œπ : ‚Ñù)
        have hc_pos_nat : 0 < Fintype.card Œπ := Nat.pos_of_ne_zero h0
        have hc_pos : 0 < cR := by
          have : 0 < (Fintype.card Œπ : ‚Ñù) := Nat.cast_pos.mpr hc_pos_nat
          simpa [cR] using this
        have hw_nonneg : ‚àÄ i ‚àà s, 0 ‚â§ cR‚Åª¬π := fun _ _ => inv_nonneg.mpr (le_of_lt hc_pos)
        have hw_sum : ‚àë i ‚àà s, cR‚Åª¬π = 1 := by
          simp [s, cR, Finset.sum_const, nsmul_eq_mul, inv_mul_cancel, ne_of_gt hc_pos]
        have hz_nonneg : ‚àÄ i ‚àà s, 0 ‚â§ |c i| := by
          intro i _; exact abs_nonneg _
        have hmean :=
          Real.pow_arith_mean_le_arith_mean_pow (s := s)
            (w := fun _ => cR‚Åª¬π) (z := fun i => |c i|)
            (hw := fun i hi => by exact hw_nonneg i hi)
            (hw' := by simpa [s] using hw_sum)
            (hz := fun i hi => hz_nonneg i hi)
            (n := n)
        have hL :
            (‚àë i ‚àà s, cR‚Åª¬π * |c i|) ^ n
              = (cR ^ n)‚Åª¬π * (‚àë i, |c i|) ^ n := by
          have : (‚àë i ‚àà s, cR‚Åª¬π * |c i|) = cR‚Åª¬π * (‚àë i, |c i|) := by
            simp [s, mul_sum]
          calc
            (‚àë i ‚àà s, cR‚Åª¬π * |c i|) ^ n
                = (cR‚Åª¬π * (‚àë i, |c i|)) ^ n := by simp [this]
            _ = (cR‚Åª¬π) ^ n * (‚àë i, |c i|) ^ n := by
                  simpa using (mul_pow (cR‚Åª¬π) (‚àë i, |c i|) n)
            _ = (cR ^ n)‚Åª¬π * (‚àë i, |c i|) ^ n := by
                  simp [inv_pow]
        have hR :
            (‚àë i ‚àà s, cR‚Åª¬π * (|c i|) ^ n)
              = cR‚Åª¬π * ‚àë i, (|c i|) ^ n := by
          simp [s, mul_sum]
        have hrew : (cR ^ n)‚Åª¬π * (‚àë i, |c i|) ^ n
                      ‚â§ cR‚Åª¬π * ‚àë i, (|c i|) ^ n := by
          simpa [hL, hR, s] using hmean
        have hc_pow_pos : 0 < (cR : ‚Ñù) ^ n := pow_pos hc_pos _
        have hmul := mul_le_mul_of_nonneg_left hrew (le_of_lt hc_pow_pos)
        have hc_ne : (cR : ‚Ñù) ‚â† 0 := ne_of_gt hc_pos
        have hc_pow_ne : (cR : ‚Ñù) ^ n ‚â† 0 := by exact pow_ne_zero _ hc_ne
        have hLcancel :
            cR ^ n * ((cR ^ n)‚Åª¬π * (‚àë i, |c i|) ^ n) = (‚àë i, |c i|) ^ n := by
          simp_all only [le_add_iff_nonneg_left, zero_le, norm_nonneg, Nat.succ_eq_add_one,
            Nat.cast_pos, Finset.mem_univ, inv_nonneg, Nat.cast_nonneg, imp_self, implies_true,
            sum_const, card_univ, nsmul_eq_mul, ne_eq, Nat.cast_eq_zero, not_false_eq_true,
            mul_inv_cancel‚ÇÄ, abs_nonneg, pow_pos, Nat.add_eq_zero,
            one_ne_zero, and_false, pow_eq_zero_iff, mul_inv_cancel_left‚ÇÄ, cR, s, n]
        have hRcancel :
            cR ^ n * (cR‚Åª¬π * ‚àë i, |c i| ^ n) = cR ^ k * ‚àë i, |c i| ^ n := by
          have : cR * (cR ^ k * (cR‚Åª¬π * ‚àë i, |c i| ^ n))
                  = cR ^ k * ‚àë i, |c i| ^ n := by
            have hc_ne' : cR ‚â† 0 := hc_ne
            calc
              cR * (cR ^ k * (cR‚Åª¬π * ‚àë i, |c i| ^ n))
                  = cR ^ k * (cR * (cR‚Åª¬π * ‚àë i, |c i| ^ n)) := by
                      simp [mul_comm, mul_left_comm, mul_assoc]
              _ = cR ^ k * ((cR * cR‚Åª¬π) * ‚àë i, |c i| ^ n) := by
                      simp [mul_left_comm, mul_assoc]
              _ = cR ^ k * (1 * ‚àë i, |c i| ^ n) := by
                      simp [hc_ne']
              _ = cR ^ k * ‚àë i, |c i| ^ n := by simp
          simpa [n, pow_succ, mul_comm, mul_left_comm, mul_assoc] using this
        have hmul' :
            (‚àë i, |c i|) ^ n ‚â§ cR ^ k * ‚àë i, |c i| ^ n := by
          simpa [hLcancel, hRcancel] using hmul
        simpa [n, Nat.succ_sub_one, mul_comm, mul_left_comm, mul_assoc] using hmul'
    simpa [n] using (h‚ÇÅm.trans hmean_main)

variable [MeasurableSpace H] [BorelSpace H]


/-- Integrability lift: if each `|c i|^m` is integrable (under `‚Ñô`) and `m ‚â• 1`,
then `‚Äñ‚àë i, c i ‚Ä¢ w i‚Äñ^m` is integrable (under `‚Ñô`). For `m = 0` it is the constant `1`. -/
lemma integrable_norm_pow_nat_of_onb_sum
  {Œ© Œπ H : Type*} [MeasureSpace Œ©] [IsProbabilityMeasure (‚Ñô : Measure Œ©)]
  [Fintype Œπ] [NormedAddCommGroup H] [InnerProductSpace ‚Ñù H]
  [MeasurableSpace H] [BorelSpace H]
  (w : OrthonormalBasis Œπ ‚Ñù H) (c : Œπ ‚Üí Œ© ‚Üí ‚Ñù) (m : ‚Ñï)
  (hc_meas : ‚àÄ i, Measurable (c i))
  (hc_int : ‚àÄ i, Integrable (fun œâ => |c i œâ| ^ m)) :
  Integrable (fun œâ => ‚Äñ‚àë i, c i œâ ‚Ä¢ w i‚Äñ ^ m) := by
  classical
  cases m with
  | zero =>
      simp
  | succ k =>
      let n := Nat.succ k
      have h_pt :
          ‚àÄ œâ, ‚Äñ‚àë i, c i œâ ‚Ä¢ w i‚Äñ ^ n
                ‚â§ (Fintype.card Œπ : ‚Ñù) ^ (n - 1) * ‚àë i, |c i œâ| ^ n := by
        intro œâ
        have := norm_pow_nat_le_card_pow_pred_sum_abs_pow (w := w) (c := fun i => c i œâ) (m := n) (by aesop)
        simpa using this
      have h_sum_int : Integrable (fun œâ => ‚àë i, |c i œâ| ^ n) := by
        have h_each : ‚àÄ i, Integrable (fun œâ => |c i œâ| ^ n) := by
          intro i
          simpa [n] using hc_int i
        simpa using (integrable_finset_sum (s := (Finset.univ : Finset Œπ))
                    (f := fun i œâ => |c i œâ| ^ n) (fun i _ => h_each i))
      have h_rhs_int :
          Integrable (fun œâ => (Fintype.card Œπ : ‚Ñù) ^ (n - 1) * ‚àë i, |c i œâ| ^ n) :=
        h_sum_int.const_mul _
      have h_meas_sum : Measurable (fun œâ => ‚àë i, c i œâ ‚Ä¢ w i) := by
        classical
        let Œ¶ : (Œπ ‚Üí ‚Ñù) ‚Üí H := fun y => ‚àë i, (y i) ‚Ä¢ w i
        have hŒ¶_cont : Continuous Œ¶ := by
          have h_i : ‚àÄ i : Œπ, Continuous fun y : (Œπ ‚Üí ‚Ñù) => (y i) ‚Ä¢ w i := by
            intro i
            exact (continuous_apply i).smul continuous_const
          simpa [Œ¶] using
            (continuous_finset_sum (s := (Finset.univ : Finset Œπ)) (fun i _ => h_i i))
        let cvec : Œ© ‚Üí (Œπ ‚Üí ‚Ñù) := fun œâ i => c i œâ
        have hcvec_meas : Measurable cvec := by
          refine measurable_pi_iff.mpr ?_
          intro i
          simpa [cvec] using hc_meas i
        simpa [Œ¶, cvec] using hŒ¶_cont.measurable.comp hcvec_meas
      have h_measL : AEStronglyMeasurable (fun œâ => ‚Äñ‚àë i, c i œâ ‚Ä¢ w i‚Äñ ^ n) (‚Ñô : Measure Œ©) := by
        have : Measurable (fun œâ => ‚Äñ‚àë i, c i œâ ‚Ä¢ w i‚Äñ) := h_meas_sum.norm
        exact (this.pow_const n).aestronglyMeasurable
      refine h_rhs_int.mono' h_measL (Filter.Eventually.of_forall ?_)
      intro œâ
      have hR : 0 ‚â§ (Fintype.card Œπ : ‚Ñù) ^ (n - 1) * ‚àë i, |c i œâ| ^ n := by
        have : 0 ‚â§ ‚àë i, |c i œâ| ^ n := by
          exact Finset.sum_nonneg (by intro i _; exact pow_nonneg (abs_nonneg _) _)
        have hc : 0 ‚â§ (Fintype.card Œπ : ‚Ñù) ^ (n - 1) := by
          exact pow_nonneg (by exact_mod_cast (Nat.cast_nonneg (Fintype.card Œπ))) _
        exact mul_nonneg hc this
      have hL : 0 ‚â§ ‚Äñ‚àë i, c i œâ ‚Ä¢ w i‚Äñ ^ n := by exact pow_nonneg (norm_nonneg _) _
      have := h_pt œâ
      simpa [Real.norm_eq_abs, abs_of_nonneg hL, abs_of_nonneg hR] using this

end FiniteOnbPowerDomination

section GaussianONB_Moments

open MeasureTheory ProbabilityTheory Finset PhysLean.Probability.GaussianIBP

variable {Œ© Œπ H : Type*}
variable [MeasureSpace Œ©] {Œº : Measure Œ©}
variable [IsProbabilityMeasure (‚Ñô : Measure Œ©)]
variable [Fintype Œπ]
variable [NormedAddCommGroup H] [InnerProductSpace ‚Ñù H]
variable [MeasurableSpace H] [BorelSpace H]

/-- If `g = ‚àë i, c i ‚Ä¢ w i` with ONB `w` and each `c i` integrable in `|¬∑|^m`,
then `‚Äñg‚Äñ^m` is integrable (under `‚Ñô`). -/
lemma integrable_norm_pow_nat_of_onb_sum_of_gaussian_coords
  (w : OrthonormalBasis Œπ ‚Ñù H) (c : Œπ ‚Üí Œ© ‚Üí ‚Ñù) (m : ‚Ñï)
  (hc_meas : ‚àÄ i, Measurable (c i))
  (hc_gauss : ‚àÄ i, ProbabilityTheory.IsCenteredGaussianRV (c i) (0 : ‚Ñù‚â•0)) :
  Integrable (fun œâ => ‚Äñ‚àë i, c i œâ ‚Ä¢ w i‚Äñ ^ m) := by
  classical
  have hc_int : ‚àÄ i, Integrable (fun œâ => |c i œâ| ^ m) := by
    intro i
    exact ProbabilityTheory.IsCenteredGaussianRV.integrable_abs_pow_nat
      (hX := hc_gauss i) (hX_meas := hc_meas i) (k := m)
  exact integrable_norm_pow_nat_of_onb_sum
    (w := w) (c := c) (m := m) (hc_meas := hc_meas) (hc_int := hc_int)

/-- For the `IsGaussianHilbert` model, all natural moments of `‚Äñg‚Äñ` are integrable (under `‚Ñô`). -/
lemma integrable_norm_pow_nat_of_gaussian
  {g : Œ© ‚Üí H} (hg : IsGaussianHilbert g) (m : ‚Ñï) :
  Integrable (fun œâ => ‚Äñg œâ‚Äñ ^ m) := by
  classical
  cases m with
  | zero =>
      simp
  | succ k =>
      have h_repr : ‚àÄ œâ, g œâ = ‚àë i, (hg.c i œâ) ‚Ä¢ hg.w i := fun œâ =>
        by simpa using congrArg (fun f => f œâ) hg.repr
      have h_meas : ‚àÄ i, Measurable (hg.c i) := hg.c_meas
      have h_gauss : ‚àÄ i, ProbabilityTheory.IsCenteredGaussianRV (hg.c i) (hg.œÑ i) := hg.c_gauss
      let mNat := Nat.succ k
      have h_int_sum :
          Integrable (fun œâ => ‚Äñ‚àë i, hg.c i œâ ‚Ä¢ hg.w i‚Äñ ^ mNat) := by
        have hc_int : ‚àÄ i, Integrable (fun œâ => |hg.c i œâ| ^ mNat) := by
          intro i
          exact ProbabilityTheory.IsCenteredGaussianRV.integrable_abs_pow_nat
            (hX := h_gauss i) (hX_meas := h_meas i) (k := mNat)
        exact integrable_norm_pow_nat_of_onb_sum
          (w := hg.w) (c := hg.c) (m := mNat) (hc_meas := h_meas) (hc_int := hc_int)
      simpa [h_repr] using h_int_sum


end GaussianONB_Moments

end PolynomialMoments
open MeasureTheory ProbabilityTheory Finset PhysLean.Probability.GaussianIBP

namespace Real

/-- For `a, b ‚â• 0` and `p ‚â• 1`, `(a + b)^p ‚â§ 2^(p - 1) * (a^p + b^p)` (real-exponent version). -/
lemma add_rpow_le_mul_rpow_add_rpow {a b p : ‚Ñù}
    (ha : 0 ‚â§ a) (hb : 0 ‚â§ b) (hp1 : 1 ‚â§ p) :
    (a + b) ^ p ‚â§ (2 : ‚Ñù) ^ (p - 1) * (a ^ p + b ^ p) := by
  lift a to NNReal using ha
  lift b to NNReal using hb
  simpa using NNReal.rpow_add_le_mul_rpow_add_rpow a b hp1

/-- Nat-exponent version: for `a, b ‚â• 0` and `n ‚â• 1`,
    `(a + b)^n ‚â§ 2^(n - 1) * (a^n + b^n)`. -/
lemma add_pow_le_two_pow_mul_add_pow {a b : ‚Ñù} {n : ‚Ñï}
    (ha : 0 ‚â§ a) (hb : 0 ‚â§ b) (hn : 1 ‚â§ n) :
    (a + b) ^ n ‚â§ (2 : ‚Ñù) ^ (n - 1) * (a ^ n + b ^ n) := by
  classical
  have hmean :
      ((1 / 2 : ‚Ñù) * a + (1 / 2 : ‚Ñù) * b) ^ n
        ‚â§ (1 / 2 : ‚Ñù) * a ^ n + (1 / 2 : ‚Ñù) * b ^ n := by
    let s := (Finset.univ : Finset (Fin 2))
    have hw_nonneg : ‚àÄ i ‚àà s, 0 ‚â§ (1 / 2 : ‚Ñù) := by
      intro _ _; norm_num
    have hw_sum : ‚àë i ‚àà s, (1 / 2 : ‚Ñù) = 1 := by
      simpa using by
        simp [s, Fin.sum_univ_succ, one_div, two_mul, add_comm, add_left_comm, add_assoc]
    have hz_nonneg : ‚àÄ i ‚àà s, 0 ‚â§ (if (i = 0) then a else b) := by
      intro i _; fin_cases i <;> simp [ha, hb]
    have h :=
      Real.pow_arith_mean_le_arith_mean_pow (s := s)
        (w := fun _ => (1 / 2 : ‚Ñù))
        (z := fun i => if (i = 0) then a else b)
        (hw := hw_nonneg) (hw' := hw_sum) (hz := hz_nonneg) (n := n)
    have hL :
        (‚àë i ‚àà s, (1 / 2 : ‚Ñù) * (if i = 0 then a else b)) =
          (1 / 2 : ‚Ñù) * a + (1 / 2 : ‚Ñù) * b := by
      simp; exact Fin.sum_univ_two fun i => if i = 0 then 2‚Åª¬π * a else 2‚Åª¬π * b
    clear hL
    simpa [s, Fin.sum_univ_succ, one_div] using h
  have h2pos : 0 ‚â§ (2 : ‚Ñù) := by norm_num
  have hmul := mul_le_mul_of_nonneg_left hmean (pow_nonneg h2pos n)
  have hL :
      (2 : ‚Ñù) ^ n * (((1 / 2 : ‚Ñù) * a + (1 / 2 : ‚Ñù) * b) ^ n)
        = (a + b) ^ n := by
    have := by
      simpa [mul_add, mul_comm, mul_left_comm, mul_assoc] using
        congrArg (fun x => x ^ n) (by ring_nf : (1 / 2 : ‚Ñù) * (a + b) = (1 / 2) * a + (1 / 2) * b)
    calc
      (2 : ‚Ñù) ^ n * (((1 / 2 : ‚Ñù) * a + (1 / 2 : ‚Ñù) * b) ^ n)
          = (2 : ‚Ñù) ^ n * (((1 / 2 : ‚Ñù) * (a + b)) ^ n) := by
              simp [mul_add, mul_comm, mul_left_comm, mul_assoc]
              exact id (Eq.symm this)
      _ = ((2 : ‚Ñù) * (1 / 2 : ‚Ñù)) ^ n * (a + b) ^ n := by simp [mul_pow, this]
      _ = (1 : ‚Ñù) ^ n * (a + b) ^ n := by simp
      _ = (a + b) ^ n := by simp
  have hn_pos : 0 < n := Nat.succ_le.mp hn
  have hR :
      (2 : ‚Ñù) ^ n * ((1 / 2 : ‚Ñù) * a ^ n + (1 / 2 : ‚Ñù) * b ^ n)
        = (2 : ‚Ñù) ^ (n - 1) * (a ^ n + b ^ n) := by
    have hn_eq : n = (n - 1) + 1 := by
      exact (Nat.succ_pred_eq_of_pos hn_pos).symm
    calc
      (2 : ‚Ñù) ^ n * ((1 / 2 : ‚Ñù) * a ^ n + (1 / 2 : ‚Ñù) * b ^ n)
          = (2 : ‚Ñù) ^ n * (1 / 2 : ‚Ñù) * (a ^ n + b ^ n) := by ring
      _ = ((2 : ‚Ñù) ^ ((n - 1) + 1) * (1 / 2 : ‚Ñù)) * (a ^ n + b ^ n) := by
            rw [hn_eq]; rw [Nat.add_succ_sub_one]
      _ = ((2 : ‚Ñù) ^ (n - 1) * 2 * (1 / 2 : ‚Ñù)) * (a ^ n + b ^ n) := by
            simp [pow_succ, mul_comm, mul_left_comm, mul_assoc]
      _ = ((2 : ‚Ñù) ^ (n - 1) * 1) * (a ^ n + b ^ n) := by
            simp
      _ = (2 : ‚Ñù) ^ (n - 1) * (a ^ n + b ^ n) := by
            simp [mul_comm, mul_left_comm, mul_assoc]
  exact add_pow_le ha hb n

end Real


open MeasureTheory ProbabilityTheory

omit [CompleteSpace H] in
/-- All polynomial profiles `(1 + ‚Äñg‚Äñ)^m` are integrable. -/
lemma integrable_one_add_norm_pow
    (hg : IsGaussianHilbert g) (m : ‚Ñï) :
    Integrable (fun œâ => (1 + ‚Äñg œâ‚Äñ) ^ m) := by
  classical
  cases m with
  | zero => simp
  | succ m' =>
      let n := Nat.succ m'
      have h_dom : ‚àÄ œâ,
          (1 + ‚Äñg œâ‚Äñ) ^ n ‚â§
            (2 : ‚Ñù) ^ (n - 1) * (1 + (‚Äñg œâ‚Äñ) ^ n) := by
        intro œâ
        have hn : 1 ‚â§ n := Nat.succ_le_succ (Nat.zero_le m')
        have h := Real.add_pow_le_two_pow_mul_add_pow
                    (a := (1 : ‚Ñù)) (b := ‚Äñg œâ‚Äñ) (n := n)
                    (ha := by norm_num) (hb := norm_nonneg _) (hn := hn)
        simpa [one_pow, add_comm, add_left_comm, add_assoc] using h
      have h_int_right :
          Integrable (fun œâ => 1 + (‚Äñg œâ‚Äñ) ^ n) := by
        have h1 : Integrable (fun _ : Œ© => (1 : ‚Ñù)) := by simp
        have h2 : Integrable (fun œâ => (‚Äñg œâ‚Äñ) ^ n) :=
          integrable_norm_pow_nat_of_gaussian (hg := hg) (m := n)
        simpa using h1.add h2
      have h_int_dom :
          Integrable (fun œâ => (2 : ‚Ñù) ^ (n - 1) * (1 + (‚Äñg œâ‚Äñ) ^ n)) :=
        h_int_right.const_mul _
      have h_meas : AEStronglyMeasurable (fun œâ => (1 + ‚Äñg œâ‚Äñ) ^ n) ‚Ñô := by
        have : Measurable (fun œâ => 1 + ‚Äñg œâ‚Äñ) :=
          (measurable_const).add (hg.repr_measurable.norm)
        exact (this.pow_const n).aestronglyMeasurable
      refine h_int_dom.mono' h_meas (Filter.Eventually.of_forall (fun œâ => ?_))
      have hR : 0 ‚â§ (2 : ‚Ñù) ^ (n - 1) * (1 + (‚Äñg œâ‚Äñ) ^ n) := by
        have h1 : 0 ‚â§ (2 : ‚Ñù) ^ (n - 1) := pow_nonneg (by norm_num) _
        have h2 : 0 ‚â§ (1 + (‚Äñg œâ‚Äñ) ^ n) := add_nonneg (by norm_num) (pow_nonneg (norm_nonneg _) _)
        exact mul_nonneg h1 h2
      have hbase : 0 ‚â§ 1 + ‚Äñg œâ‚Äñ := by nlinarith [norm_nonneg (g œâ)]
      have hL : 0 ‚â§ (1 + ‚Äñg œâ‚Äñ) ^ n := pow_nonneg hbase _
      have := h_dom œâ
      simpa [Real.norm_eq_abs, abs_pow, abs_of_nonneg hbase, abs_of_nonneg hR] using this

omit [CompleteSpace H] in
/-- Parameterized integrability: if `p ‚â• 0` and `p ‚â§ m` for some natural `m`,
then `‚Äñg‚Äñ^p` is integrable. -/
lemma integrable_norm_rpow_of_gaussian_of_nat_ub
    (hg : IsGaussianHilbert g) (p : ‚Ñù) (hp : 0 ‚â§ p)
    (m : ‚Ñï) (hp_le : p ‚â§ m) :
    Integrable (fun œâ => ‚Äñg œâ‚Äñ ^ p) := by
  classical
  have h_dom :
      ‚àÄ œâ, ‚Äñg œâ‚Äñ ^ p ‚â§ (1 + ‚Äñg œâ‚Äñ) ^ m :=
    fun œâ => rpow_le_one_add_pow_nat_of_le (p := p) (m := m) hp hp_le (‚Äñg œâ‚Äñ) (norm_nonneg _)
  have h_int_poly : Integrable (fun œâ => (1 + ‚Äñg œâ‚Äñ) ^ m) :=
    integrable_one_add_norm_pow (hg := hg) (m := m)
  have h_meas : AEStronglyMeasurable (fun œâ => ‚Äñg œâ‚Äñ ^ p) ‚Ñô := by
    have h1 : Measurable (fun œâ => ‚Äñg œâ‚Äñ) := hg.repr_measurable.norm
    have h2 : Measurable (fun t : ‚Ñù => t ^ p) := by
      measurability
    exact (h2.comp h1).aestronglyMeasurable
  refine h_int_poly.mono' h_meas (Filter.Eventually.of_forall ?_)
  intro œâ
  have hR : 0 ‚â§ (1 + ‚Äñg œâ‚Äñ) ^ m := by
    have : 0 ‚â§ 1 + ‚Äñg œâ‚Äñ := by nlinarith [norm_nonneg (g œâ)]
    exact pow_nonneg this _
  have hL : 0 ‚â§ ‚Äñg œâ‚Äñ ^ p := Real.rpow_nonneg (norm_nonneg _) _
  simpa [Real.norm_eq_abs, abs_of_nonneg hL, abs_of_nonneg hR] using h_dom œâ

omit [CompleteSpace H] in
/-- All moments of the norm of a finite-dimensional Gaussian are finite (for `p ‚â• 0`).
This wrapper chooses a natural upper bound `m ‚â• p` by existence. -/
lemma integrable_norm_pow_of_gaussian
    (hg : IsGaussianHilbert g) (p : ‚Ñù) (hp : 0 ‚â§ p) :
    Integrable (fun œâ => ‚Äñg œâ‚Äñ ^ p) := by
  classical
  obtain ‚ü®m, hm‚ü© := exists_nat_ge p
  exact integrable_norm_rpow_of_gaussian_of_nat_ub (hg := hg) (p := p) hp (m := m) (hp_le := by exact_mod_cast hm)

omit [CompleteSpace H] in
/-- Natural moments are integrable. -/
lemma integrable_norm_pow_nat_of_gaussian'
    (hg : IsGaussianHilbert g) (k : ‚Ñï) :
    Integrable (fun œâ => (‚Äñg œâ‚Äñ) ^ k) := by
  have h := integrable_norm_rpow_of_gaussian_of_nat_ub (hg := hg)
              (p := (k : ‚Ñù)) (hp := by exact_mod_cast (Nat.cast_nonneg k))
              (m := k) (hp_le := by exact_mod_cast (le_of_eq rfl))
  exact integrable_norm_pow_nat_of_gaussian hg k

omit [CompleteSpace H] in
/-- All polynomial profiles in the norm are integrable. -/
lemma integrable_one_add_norm_pow' (hg : IsGaussianHilbert g) (m : ‚Ñï) :
    Integrable (fun œâ => (1 + ‚Äñg œâ‚Äñ) ^ m) := by
  classical
  have h_term :
      ‚àÄ k ‚àà Finset.range (m + 1),
        Integrable (fun œâ => (Nat.choose m k : ‚Ñù) * (‚Äñg œâ‚Äñ) ^ k) := by
    intro k hk
    have hk_int : Integrable (fun œâ => (‚Äñg œâ‚Äñ) ^ k) := by
      cases k with
      | zero => simp
      | succ k' =>
          have h := integrable_norm_pow_of_gaussian (g := g) (hg := hg) (p := (Nat.succ k' : ‚Ñù))
            (hp := by exact Nat.cast_nonneg' k'.succ)
          exact integrable_norm_pow_nat_of_gaussian hg (k' + 1)
    simpa using hk_int.const_mul (Nat.choose m k : ‚Ñù)
  have h_sum :
      Integrable (fun œâ =>
        ‚àë k ‚àà Finset.range (m + 1), (Nat.choose m k : ‚Ñù) * (‚Äñg œâ‚Äñ) ^ k) := by
    simpa using
      (integrable_finset_sum
        (s := Finset.range (m + 1))
        (f := fun k œâ => (Nat.choose m k : ‚Ñù) * (‚Äñg œâ‚Äñ) ^ k)
        (by intro k hk; exact h_term k hk))
  have : (fun œâ => (1 + ‚Äñg œâ‚Äñ) ^ m)
      = (fun œâ =>
          ‚àë k ‚àà Finset.range (m + 1), (Nat.choose m k : ‚Ñù) * (‚Äñg œâ‚Äñ) ^ k) := by
    funext œâ
    simp [add_comm, add_left_comm, add_assoc, add_pow, one_pow, mul_comm, mul_left_comm, mul_assoc]
  simpa [this]

omit [CompleteSpace H] in
/-- Under polynomial growth of `F` and Gaussian tails of `g`, `F ‚àò g` is integrable. -/
lemma integrable_F_of_growth
    (hg : IsGaussianHilbert g) (hF_diff : ContDiff ‚Ñù 1 F) (hF_growth : HasModerateGrowth F) :
    Integrable (fun œâ => F (g œâ)) := by
  have h_bound : ‚àÄ œâ, |F (g œâ)| ‚â§ hF_growth.C * (1 + ‚Äñg œâ‚Äñ) ^ hF_growth.m :=
    fun œâ => hF_growth.F_bound (g œâ)
  have h_int_poly : Integrable (fun œâ => (1 + ‚Äñg œâ‚Äñ) ^ hF_growth.m) := by
    simpa using integrable_one_add_norm_pow (hg := hg) (m := hF_growth.m)
  have h_int_bound : Integrable (fun œâ => hF_growth.C * (1 + ‚Äñg œâ‚Äñ) ^ hF_growth.m) :=
    h_int_poly.const_mul hF_growth.C
  have hg_meas : Measurable g := hg.repr_measurable
  have hF_meas : Measurable F := hF_diff.continuous.measurable
  apply Integrable.mono h_int_bound (hF_meas.comp hg_meas).aestronglyMeasurable
  refine Filter.Eventually.of_forall (fun œâ => ?_)
  have hbase : 0 ‚â§ 1 + ‚Äñg œâ‚Äñ := by nlinarith [norm_nonneg (g œâ)]
  have hCabs : |hF_growth.C| = hF_growth.C := abs_of_nonneg (le_of_lt hF_growth.Cpos)
  have h1abs : |1 + ‚Äñg œâ‚Äñ| = 1 + ‚Äñg œâ‚Äñ := abs_of_nonneg hbase
  simpa [Function.comp, Real.norm_eq_abs, hCabs, h1abs] using h_bound œâ

omit [CompleteSpace H] in
/-- Each coordinate has finite moments; multiplying by `F(g)` preserves integrability. -/
lemma integrable_coord_mul_F
    (hg : IsGaussianHilbert g) (hF_diff : ContDiff ‚Ñù 1 F) (hF_growth : HasModerateGrowth F) (i : hg.Œπ) :
    Integrable (fun œâ => (coord hg.w g i œâ) * F (g œâ)) := by
  classical
  let c_i := coord hg.w g i
  have hc_i_L2 : Integrable (fun œâ => c_i œâ ^ 2) :=
    ProbabilityTheory.IsCenteredGaussianRV.integrable_sq
      (hX := (coord_isGaussian_and_indep hg).1 i)
      (hX_meas := (coord_measurable (g := g) hg i))
  have hF_L2 : Integrable (fun œâ => F (g œâ) ^ 2) := by
    have h_bound_sq :
        ‚àÄ œâ, |F (g œâ) ^ 2| ‚â§ hF_growth.C ^ 2 * (1 + ‚Äñg œâ‚Äñ) ^ (2 * hF_growth.m) := by
      intro œâ
      have hb : |F (g œâ)| ‚â§ hF_growth.C * (1 + ‚Äñg œâ‚Äñ) ^ hF_growth.m :=
        hF_growth.F_bound (g œâ)
      have hb2 : |F (g œâ)| ^ 2
                    ‚â§ (hF_growth.C * (1 + ‚Äñg œâ‚Äñ) ^ hF_growth.m) ^ 2 :=
        Real.pow_le_pow_of_le_left (abs_nonneg _) hb 2
      have hR :
          (hF_growth.C * (1 + ‚Äñg œâ‚Äñ) ^ hF_growth.m) ^ 2
            = hF_growth.C ^ 2 * (1 + ‚Äñg œâ‚Äñ) ^ (2 * hF_growth.m) := by
        simp [pow_two, mul_pow, pow_mul, two_mul, mul_comm, mul_left_comm, mul_assoc]
      simpa [abs_pow, hR] using hb2
    have h_int_poly :
        Integrable (fun œâ => (1 + ‚Äñg œâ‚Äñ) ^ (2 * hF_growth.m)) := by
      simpa using integrable_one_add_norm_pow (hg := hg) (m := 2 * hF_growth.m)
    have h_int_bound := h_int_poly.const_mul (hF_growth.C ^ 2)
    have hg_meas : Measurable g := hg.repr_measurable
    have hF_meas : Measurable F := hF_diff.continuous.measurable
    refine h_int_bound.mono' ((hF_meas.comp hg_meas).pow_const 2).aestronglyMeasurable ?_
    refine Filter.Eventually.of_forall (fun œâ => ?_)
    have hpow_nonneg : 0 ‚â§ (1 + ‚Äñg œâ‚Äñ) ^ (2 * hF_growth.m) := by
      have : 0 ‚â§ 1 + ‚Äñg œâ‚Äñ := by nlinarith [norm_nonneg (g œâ)]
      exact pow_nonneg this _
    have hrhs_nonneg : 0 ‚â§ hF_growth.C ^ 2 * (1 + ‚Äñg œâ‚Äñ) ^ (2 * hF_growth.m) :=
      mul_nonneg (by exact sq_nonneg _) hpow_nonneg
    simpa [Real.norm_eq_abs, abs_of_nonneg hrhs_nonneg] using h_bound_sq œâ
  have h_int_rhs :
      Integrable (fun œâ => (1 / 2 : ‚Ñù) * ((c_i œâ) ^ 2 + (F (g œâ)) ^ 2)) :=
    (hc_i_L2.add hF_L2).const_mul (1 / 2 : ‚Ñù)
  have hc_meas : Measurable c_i := (coord_measurable (g := g) hg i)
  have hFcomp_meas : Measurable (fun œâ => F (g œâ)) :=
    (hF_diff.continuous.measurable).comp hg.repr_measurable
  have h_meas_prod :
      AEStronglyMeasurable (fun œâ => c_i œâ * F (g œâ)) ‚Ñô :=
    (hc_meas.mul hFcomp_meas).aestronglyMeasurable
  have h_dom :
      ‚àÄ œâ, |c_i œâ * F (g œâ)| ‚â§ (1 / 2 : ‚Ñù) * ((c_i œâ) ^ 2 + (F (g œâ)) ^ 2) := by
    intro œâ
    have hsq : 0 ‚â§ (|c_i œâ| - |F (g œâ)|) ^ 2 := sq_nonneg _
    have hcs' :
        2 * (|c_i œâ| * |F (g œâ)|) ‚â§ |c_i œâ| ^ 2 + |F (g œâ)| ^ 2 := by
      have := hsq
      nlinarith [pow_two (|c_i œâ|), pow_two (|F (g œâ)|)]
    have hcs :
        2 * |c_i œâ * F (g œâ)| ‚â§ |c_i œâ| ^ 2 + |F (g œâ)| ^ 2 := by
      simpa [abs_mul, mul_comm, mul_left_comm, mul_assoc] using hcs'
    have : |c_i œâ * F (g œâ)| ‚â§ (|c_i œâ| ^ 2 + |F (g œâ)| ^ 2) / 2 := by
      have hpos : (0 : ‚Ñù) < 2 := by norm_num
      exact (le_div_iff‚ÇÄ' hpos).mpr hcs
    simpa [div_eq_mul_inv, one_div, pow_two, abs_pow, mul_add, mul_comm, mul_left_comm, mul_assoc]
      using this
  refine h_int_rhs.mono' h_meas_prod (Filter.Eventually.of_forall (fun œâ => ?_))
  have hR : 0 ‚â§ (1 / 2 : ‚Ñù) * ((c_i œâ) ^ 2 + (F (g œâ)) ^ 2) := by
    have : 0 ‚â§ (c_i œâ) ^ 2 + (F (g œâ)) ^ 2 := by exact add_nonneg (sq_nonneg _) (sq_nonneg _)
    have : 0 ‚â§ (1 / 2 : ‚Ñù) * ((c_i œâ) ^ 2 + (F (g œâ)) ^ 2) :=
      mul_nonneg (by norm_num) this
    simpa using this
  exact h_dom œâ

omit [CompleteSpace H] in
/-- The Fr√©chet derivative applied to a fixed direction is integrable under the growth bound. -/
lemma integrable_fderiv_apply
    (hg : IsGaussianHilbert g) (hF_diff : ContDiff ‚Ñù 1 F)
    (hF_growth : HasModerateGrowth F) (h : H) :
    Integrable (fun œâ => (fderiv ‚Ñù F (g œâ)) h) := by
  have h_bound : ‚àÄ œâ, ‚Äñ(fderiv ‚Ñù F (g œâ)) h‚Äñ
      ‚â§ hF_growth.C * (1 + ‚Äñg œâ‚Äñ) ^ hF_growth.m * ‚Äñh‚Äñ :=
    fun œâ => HasModerateGrowth.bound_dF_apply hF_growth (g œâ) h
  have h_int_poly : Integrable (fun œâ => (1 + ‚Äñg œâ‚Äñ) ^ hF_growth.m) := by
    simpa using integrable_one_add_norm_pow (hg := hg) (m := hF_growth.m)
  have h_int_bound : Integrable (fun œâ => (hF_growth.C * ‚Äñh‚Äñ) * ((1 + ‚Äñg œâ‚Äñ) ^ hF_growth.m)) :=
    h_int_poly.const_mul (hF_growth.C * ‚Äñh‚Äñ)
  have hg_meas : Measurable g := hg.repr_measurable
  have hF_deriv_cont : Continuous (fderiv ‚Ñù F) :=
    hF_diff.continuous_fderiv (le_rfl : (1 : WithTop ‚Ñï‚àû) ‚â§ 1)
  have h_comp_meas : Measurable (fun œâ => fderiv ‚Ñù F (g œâ)) :=
    hF_deriv_cont.measurable.comp hg_meas
  have h_apply_meas : Measurable (fun œâ => (fderiv ‚Ñù F (g œâ)) h) :=
    (ContinuousLinearMap.apply ‚Ñù ‚Ñù h).measurable.comp h_comp_meas
  refine h_int_bound.mono' h_apply_meas.aestronglyMeasurable (Filter.Eventually.of_forall ?_)
  intro œâ
  simpa [mul_comm, mul_left_comm, mul_assoc] using h_bound œâ

omit [IsProbabilityMeasure (‚Ñô : Measure Œ©)] [CompleteSpace H] [MeasurableSpace H] [BorelSpace H] in
/-- Interchange expectation with a finite sum. -/
lemma expectation_finset_sum
    (hg : IsGaussianHilbert g) --(hF_diff : ContDiff ‚Ñù 1 F) (hF_growth : HasModerateGrowth F)
    (f : hg.Œπ ‚Üí Œ© ‚Üí ‚Ñù)
    (hint : ‚àÄ i, Integrable (f i)) :
    ùîº[(fun œâ => ‚àë i, f i œâ)] = ‚àë i, ùîº[(f i ¬∑)] := by
  classical
  have hint' : ‚àÄ i ‚àà (Finset.univ : Finset hg.Œπ), Integrable (f i) := by
    intro i _; simpa using hint i
  change (‚à´ œâ, (‚àë i : hg.Œπ, f i œâ) ‚àÇ‚Ñô) = ‚àë i : hg.Œπ, (‚à´ œâ, f i œâ ‚àÇ‚Ñô)
  simpa using
    (integral_finset_sum (s := (Finset.univ : Finset hg.Œπ)) (f := fun i œâ => f i œâ) hint')

omit [IsProbabilityMeasure (‚Ñô : Measure Œ©)] in
/-- Pull out a *constant* scalar factor from expectation. -/
lemma expectation_const_mul
    (c : ‚Ñù) {f : Œ© ‚Üí ‚Ñù} (_ : Integrable f) :
    ùîº[(fun œâ => c * f œâ)] = c * ùîº[f] := by
  classical
  change (‚à´ œâ, c * f œâ ‚àÇ‚Ñô) = c * (‚à´ œâ, f œâ ‚àÇ‚Ñô)
  exact MeasureTheory.integral_const_mul c f

omit [CompleteSpace H] in
/-- Weighted version: pull a finite *weighted* sum inside a continuous linear
map applied pointwise, then exchange the finite sum with expectation. -/
lemma fderiv_expectation_weighted_sum
    (hg : IsGaussianHilbert g) (hF_diff : ContDiff ‚Ñù 1 F) (hF_growth : HasModerateGrowth F)
    (a : hg.Œπ ‚Üí ‚Ñù) :
    ùîº[(fun œâ => (fderiv ‚Ñù F (g œâ)) (‚àë i : hg.Œπ, (a i) ‚Ä¢ hg.w i))]
      = ‚àë i : hg.Œπ, (a i) * ùîº[(fun œâ => (fderiv ‚Ñù F (g œâ)) (hg.w i))] := by
  classical
  have hint : ‚àÄ i : hg.Œπ, Integrable (fun œâ => (fderiv ‚Ñù F (g œâ)) (hg.w i)) :=
    fun i => integrable_fderiv_apply (hg := hg) (hF_diff := hF_diff)
      (hF_growth := hF_growth) (h := hg.w i)
  have pointwise :
    (fun œâ => (fderiv ‚Ñù F (g œâ)) (‚àë i : hg.Œπ, (a i) ‚Ä¢ hg.w i))
      = (fun œâ => ‚àë i : hg.Œπ, (a i) * ((fderiv ‚Ñù F (g œâ)) (hg.w i))) := by
    funext œâ
    have L : H ‚ÜíL[‚Ñù] ‚Ñù := fderiv ‚Ñù F (g œâ)
    simp [map_sum, map_smul‚Çõ‚Çó, smul_eq_mul]
  calc
    ùîº[(fun œâ => (fderiv ‚Ñù F (g œâ)) (‚àë i : hg.Œπ, (a i) ‚Ä¢ hg.w i))]
        = ùîº[(fun œâ => ‚àë i : hg.Œπ, (a i) * ((fderiv ‚Ñù F (g œâ)) (hg.w i)))] := by
          simp [pointwise]
    _ = ‚àë i : hg.Œπ, ùîº[(fun œâ => (a i) * ((fderiv ‚Ñù F (g œâ)) (hg.w i)))] := by
          simpa using
            expectation_finset_sum (hg := hg)
              (f := fun i œâ => (a i) * ((fderiv ‚Ñù F (g œâ)) (hg.w i)))
              (hint := fun i => (hint i).const_mul (a i))
    _ = ‚àë i : hg.Œπ, (a i) * ùîº[(fun œâ => (fderiv ‚Ñù F (g œâ)) (hg.w i))] := by
          refine Finset.sum_congr rfl ?_
          intro i _
          simpa [mul_comm, mul_left_comm, mul_assoc]
            using expectation_const_mul (c := (a i))
              (f := fun œâ => (fderiv ‚Ñù F (g œâ)) (hg.w i))
              ((hint i))

end Integrability

/-! ## Covariance operator as a continuous linear map (rank‚Äëone sum)
We package the covariance weights `(œÑ i)` and basis vectors `(w i)` into a
bounded operator `Œ£ : H ‚ÜíL[‚Ñù] H`. This lets us present the IBP identity in a
clean, coordinate‚Äëfree form.
-/
section CovarianceOperator

variable {g : Œ© ‚Üí H}
section InnerProductSpace
open scoped InnerProductSpace

/-- The continuous linear map `x ‚Ü¶ ‚ü™v, x‚ü´` for a fixed `v`.
Note: this is linear in `x` for general `RCLike ùïú`. -/
def ContinuousLinearMap.innerSL (ùïú : Type*) [RCLike ùïú] {E : Type*}
    [NormedAddCommGroup E] [InnerProductSpace ùïú E] (v : E) : E ‚ÜíL[ùïú] ùïú :=
  LinearMap.mkContinuous
    { toFun := fun x => ‚ü™v, x‚ü´_ùïú
      map_add' := by
        intro x y
        -- ‚ü™v, x + y‚ü´ = ‚ü™v, x‚ü´ + ‚ü™v, y‚ü´
        simpa using (inner_add_right v x y)
      map_smul' := by
        intro c x
        -- ‚ü™v, c ‚Ä¢ x‚ü´ = c * ‚ü™v, x‚ü´
        simpa using (inner_smul_right v x c) }
    ‚Äñv‚Äñ
    (fun x => by
      simpa using (norm_inner_le_norm v x))

@[simp] lemma ContinuousLinearMap.innerSL_apply
    (ùïú : Type*) [RCLike ùïú] {E : Type*} [NormedAddCommGroup E] [InnerProductSpace ùïú E]
    (v x : E) :
    (ContinuousLinearMap.innerSL ùïú (E := E) v) x = ‚ü™v, x‚ü´_ùïú := rfl

end InnerProductSpace

/-- Covariance operator `Œ£` built from the finite spectral data `(w, œÑ)`.
It is the finite sum of rank‚Äëone projections `h ‚Ü¶ ‚ü™h, w i‚ü´ ‚Ä¢ w i`, scaled by `œÑ i`. -/
noncomputable def covOp (hg : IsGaussianHilbert g) : H ‚ÜíL[‚Ñù] H :=
  (Finset.univ : Finset hg.Œπ).sum fun i =>
    (hg.œÑ i : ‚Ñù) ‚Ä¢
      ContinuousLinearMap.smulRight (ContinuousLinearMap.innerSL ‚Ñù (hg.w i)) (hg.w i)

omit [IsProbabilityMeasure (‚Ñô : Measure Œ©)] [CompleteSpace H] [MeasurableSpace H] [BorelSpace H] in
@[simp] lemma covOp_apply
    {g : Œ© ‚Üí H} (hg : IsGaussianHilbert g) (h : H) :
    (covOp (g := g) hg) h
      = ‚àë i : hg.Œπ, ((hg.œÑ i : ‚Ñù) * ‚ü™h, hg.w i‚ü´_‚Ñù) ‚Ä¢ hg.w i := by
  classical
  rw [covOp, ContinuousLinearMap.sum_apply]
  refine Finset.sum_congr rfl (fun i _ => ?_)
  simp [smul_smul, real_inner_comm]

/-- We write `Œ£_hg` for the covariance operator associated
with a Gaussian Hilbert model `hg`. -/
notation3 "Œ£_" hg => covOp (g := _ ) hg

omit [IsProbabilityMeasure (‚Ñô : Measure Œ©)] [CompleteSpace H] [MeasurableSpace H] [BorelSpace H] in
lemma covOp_symmetric
    {g : Œ© ‚Üí H} (hg : IsGaussianHilbert g) (x y : H) :
    ‚ü™(covOp (g := g) hg) x, y‚ü´_‚Ñù = ‚ü™x, (covOp (g := g) hg) y‚ü´_‚Ñù := by
  classical
  have L : ‚ü™(covOp (g := g) hg) x, y‚ü´_‚Ñù
      = ‚àë i : hg.Œπ, (hg.œÑ i : ‚Ñù) * ‚ü™x, hg.w i‚ü´_‚Ñù * ‚ü™hg.w i, y‚ü´_‚Ñù := by
    have hsum :=
      (sum_inner (ùïú := ‚Ñù) (E := H)
        (s := (Finset.univ : Finset hg.Œπ))
        (f := fun i => ((hg.œÑ i : ‚Ñù) * ‚ü™x, hg.w i‚ü´_‚Ñù) ‚Ä¢ hg.w i)
        (x := y))
    simpa [covOp_apply (g := g) (hg := hg) x,
           real_inner_smul_left, mul_comm, mul_left_comm, mul_assoc]
      using hsum
  have R : ‚ü™x, (covOp (g := g) hg) y‚ü´_‚Ñù
      = ‚àë i : hg.Œπ, (hg.œÑ i : ‚Ñù) * ‚ü™x, hg.w i‚ü´_‚Ñù * ‚ü™hg.w i, y‚ü´_‚Ñù := by
    have hsum :=
      (inner_sum (ùïú := ‚Ñù) (E := H)
        (s := (Finset.univ : Finset hg.Œπ))
        (f := fun i => ((hg.œÑ i : ‚Ñù) * ‚ü™y, hg.w i‚ü´_‚Ñù) ‚Ä¢ hg.w i)
        (x := x))
    simpa [covOp_apply (g := g) (hg := hg) y,
           real_inner_smul_right, real_inner_comm,
           mul_comm, mul_left_comm, mul_assoc]
      using hsum
  aesop

omit [IsProbabilityMeasure (‚Ñô : Measure Œ©)] [CompleteSpace H] [MeasurableSpace H] [BorelSpace H] in
lemma covOp_pos
    {g : Œ© ‚Üí H} (hg : IsGaussianHilbert g) (x : H) :
    0 ‚â§ ‚ü™(covOp (g := g) hg) x, x‚ü´_‚Ñù := by
  classical
  have hx :
      ‚ü™(covOp (g := g) hg) x, x‚ü´_‚Ñù
        = ‚àë i : hg.Œπ, (hg.œÑ i : ‚Ñù) * (‚ü™x, hg.w i‚ü´_‚Ñù)^2 := by
    have hsum :
        ‚ü™‚àë i : hg.Œπ, ((hg.œÑ i : ‚Ñù) * ‚ü™x, hg.w i‚ü´_‚Ñù) ‚Ä¢ hg.w i, x‚ü´_‚Ñù
          = ‚àë i : hg.Œπ, ‚ü™((hg.œÑ i : ‚Ñù) * ‚ü™x, hg.w i‚ü´_‚Ñù) ‚Ä¢ hg.w i, x‚ü´_‚Ñù := by
      simpa using
        (sum_inner (ùïú := ‚Ñù) (E := H)
          (s := (Finset.univ : Finset hg.Œπ))
          (f := fun i => ((hg.œÑ i : ‚Ñù) * ‚ü™x, hg.w i‚ü´_‚Ñù) ‚Ä¢ hg.w i)
          (x := x))
    have : ‚àë i : hg.Œπ, ‚ü™((hg.œÑ i : ‚Ñù) * ‚ü™x, hg.w i‚ü´_‚Ñù) ‚Ä¢ hg.w i, x‚ü´_‚Ñù
            = ‚àë i : hg.Œπ, (hg.œÑ i : ‚Ñù) * (‚ü™x, hg.w i‚ü´_‚Ñù)^2 := by
      refine Finset.sum_congr rfl (fun i _ => ?_)
      calc
        ‚ü™((hg.œÑ i : ‚Ñù) * ‚ü™x, hg.w i‚ü´_‚Ñù) ‚Ä¢ hg.w i, x‚ü´_‚Ñù
            = ((hg.œÑ i : ‚Ñù) * ‚ü™x, hg.w i‚ü´_‚Ñù) * ‚ü™hg.w i, x‚ü´_‚Ñù := by
              rw [inner_smul_left]; simp
        _ = (hg.œÑ i : ‚Ñù) * (‚ü™x, hg.w i‚ü´_‚Ñù * ‚ü™hg.w i, x‚ü´_‚Ñù) := by
              simp [mul_assoc]
        _ = (hg.œÑ i : ‚Ñù) * (‚ü™x, hg.w i‚ü´_‚Ñù * ‚ü™x, hg.w i‚ü´_‚Ñù) := by
              simp [real_inner_comm]
        _ = (hg.œÑ i : ‚Ñù) * (‚ü™x, hg.w i‚ü´_‚Ñù)^2 := by
              simp [pow_two, mul_comm, mul_left_comm, mul_assoc]
    simpa [covOp_apply (g := g) (hg := hg) x] using hsum.trans this
  have hterm : ‚àÄ i : hg.Œπ, 0 ‚â§ (hg.œÑ i : ‚Ñù) * (‚ü™x, hg.w i‚ü´_‚Ñù)^2 := by
    intro i
    exact mul_nonneg (by exact (hg.œÑ i).coe_nonneg) (sq_nonneg _)
  have hsum : 0 ‚â§ ‚àë i : hg.Œπ, (hg.œÑ i : ‚Ñù) * (‚ü™x, hg.w i‚ü´_‚Ñù)^2 :=
    Finset.sum_nonneg (by intro i _; exact hterm i)
  aesop

end CovarianceOperator

/-! ## Linear test functions and covariance corollaries -/
section LinearTestFunctions

variable {g : Œ© ‚Üí H}

/-- Constant functions have moderate growth. -/
def hasModerateGrowth_const (c : ‚Ñù) :
    HasModerateGrowth (fun _ : H => c) := by
  classical
  refine ‚ü®|c| + 1, 0, by exact add_pos_of_nonneg_of_pos (abs_nonneg c) zero_lt_one, ?F, ?dF‚ü©
  ¬∑ intro z
    have : |c| ‚â§ |c| + 1 := by nlinarith [abs_nonneg c]
    simp [pow_zero, one_mul]
  ¬∑ intro z
    have : (0 : ‚Ñù) ‚â§ |c| + 1 := by nlinarith [abs_nonneg c]
    simpa [fderiv_const, pow_zero, one_mul] using this

/-- Continuous linear maps have moderate growth with linear exponent. -/
def hasModerateGrowth_of_clm (L : H ‚ÜíL[‚Ñù] ‚Ñù) :
    HasModerateGrowth (fun z : H => L z) := by
  classical
  refine ‚ü®‚ÄñL‚Äñ + 1, 1, by exact add_pos_of_nonneg_of_pos (norm_nonneg (L : H ‚ÜíL[‚Ñù] ‚Ñù)) zero_lt_one, ?F, ?dF‚ü©
  ¬∑ intro z
    have h‚ÇÅ : |L z| ‚â§ ‚ÄñL‚Äñ * ‚Äñz‚Äñ := by simpa using L.le_opNorm z
    have h‚ÇÇ : ‚ÄñL‚Äñ * ‚Äñz‚Äñ ‚â§ (‚ÄñL‚Äñ + 1) * (1 + ‚Äñz‚Äñ) := by
      have hL : ‚ÄñL‚Äñ ‚â§ ‚ÄñL‚Äñ + 1 := by nlinarith [norm_nonneg (L : H ‚ÜíL[‚Ñù] ‚Ñù)]
      have hz : ‚Äñz‚Äñ ‚â§ 1 + ‚Äñz‚Äñ := by nlinarith [norm_nonneg z]
      exact (mul_le_mul_of_nonneg_left hz (by nlinarith [norm_nonneg (L : H ‚ÜíL[‚Ñù] ‚Ñù)])).trans
        (by nlinarith [norm_nonneg (L : H ‚ÜíL[‚Ñù] ‚Ñù), norm_nonneg z])
    have : |L z| ‚â§ (‚ÄñL‚Äñ + 1) * (1 + ‚Äñz‚Äñ) := h‚ÇÅ.trans h‚ÇÇ
    simpa [pow_one] using this
  ¬∑ intro z
    have hderiv : fderiv ‚Ñù (fun x : H => L x) z = L := by
      simp
    have hL' : ‚ÄñL‚Äñ ‚â§ (‚ÄñL‚Äñ + 1) * (1 + ‚Äñz‚Äñ) := by
      have h1 : ‚ÄñL‚Äñ ‚â§ ‚ÄñL‚Äñ + 1 := by nlinarith [norm_nonneg (L : H ‚ÜíL[‚Ñù] ‚Ñù)]
      have h2 : (1 : ‚Ñù) ‚â§ 1 + ‚Äñz‚Äñ := by nlinarith [norm_nonneg z]
      have h3 : ‚ÄñL‚Äñ * 1 ‚â§ (‚ÄñL‚Äñ + 1) * (1 + ‚Äñz‚Äñ) := by
        exact mul_le_mul h1 h2 (by norm_num) (by nlinarith [norm_nonneg (L : H ‚ÜíL[‚Ñù] ‚Ñù)])
      simpa using h3
    simpa [hderiv, pow_one] using hL'

end LinearTestFunctions

/-! ## Parameterized 1D Stein step along a coordinate
Fix a basis index `i`. Write the coordinate vector as `x := coord w g i` and
collect the remaining coordinates as a parameter `y`. For

```
œÜ (x : ‚Ñù) (y : (hg.Œπ \ {i}) ‚Üí ‚Ñù) := F ( ‚àë j ‚â† i, (y j) ‚Ä¢ w j + x ‚Ä¢ w i ),
```

the 1D Stein identity applied to `x` (with `y` fixed) yields

```
E[ x * œÜ(x,y) ] = (œÑ i) * E[ ‚àÇ_x œÜ(x,y) ].
```

Integrating both sides with respect to `y` gives the desired coordinate step. -/
section CoordLineAndDecomposition

open scoped BigOperators
open MeasureTheory ProbabilityTheory

variable {Œ© : Type*} [MeasureSpace Œ©] [IsProbabilityMeasure (‚Ñô : Measure Œ©)]
variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ‚Ñù H]
variable [CompleteSpace H] [MeasurableSpace H] [BorelSpace H]

namespace CoordLine
section
/-- Index of the ‚Äúcomplement‚Äù coordinates when singling out `i`. -/
@[simp] def Comp (Œπ : Type*) (i : Œπ) := { j : Œπ // j ‚â† i }

variable {Œπ : Type*} [Fintype Œπ]
variable (w : OrthonormalBasis Œπ ‚Ñù H)


/-- Finite instance for the complement subtype `{j // j ‚â† i}`. -/
noncomputable instance instFintypeComp (i : Œπ) [DecidableEq Œπ] : Fintype (Comp Œπ i) :=
  Subtype.fintype (fun j : Œπ => j ‚â† i)

/-- Build back a vector in `H` from a complement family and a coordinate along `w i`. -/
@[simp] def buildAlong [DecidableEq Œπ] (i : Œπ) (y : Comp Œπ i ‚Üí ‚Ñù) (x : ‚Ñù) : H :=
  (‚àë j : Comp Œπ i, (y j) ‚Ä¢ w j.1) + x ‚Ä¢ w i

omit [CompleteSpace H] [MeasurableSpace H] [BorelSpace H] in
/-- Finite-sum splitting identity along a fixed coordinate `i`. -/
lemma sum_split_along [DecidableEq Œπ] (i : Œπ) (a : Œπ ‚Üí ‚Ñù) :
  (‚àë j, (a j) ‚Ä¢ w j) = (‚àë j : Comp Œπ i, (a j.1) ‚Ä¢ w j.1) + (a i) ‚Ä¢ w i := by
  classical
  have hi : i ‚àà (Finset.univ : Finset Œπ) := by simp
  have hsplit :
      (‚àë j ‚àà (Finset.univ.erase i), (a j) ‚Ä¢ w j) + (a i) ‚Ä¢ w i
        = ‚àë j, (a j) ‚Ä¢ w j := by
    simp
  have hattach :
      (‚àë j : {j // j ‚àà (Finset.univ.erase i)}, (a j.1) ‚Ä¢ w j.1)
        = (‚àë j ‚àà (Finset.univ.erase i), (a j) ‚Ä¢ w j) := by
    simpa using
      (Finset.sum_attach (s := (Finset.univ.erase i))
        (f := fun j => (a j) ‚Ä¢ w j))
  let e : Comp Œπ i ‚âÉ {j // j ‚àà (Finset.univ.erase i)} :=
  { toFun := fun j =>
      ‚ü®j.1, by
        exact Finset.mem_erase.mpr ‚ü®j.2, by simp‚ü©‚ü©
    , invFun := fun j => ‚ü®j.1, (Finset.mem_erase.mp j.2).1‚ü©
    , left_inv := by
        intro j; cases j with
        | mk x hx => simp [hx]
    , right_inv := by
        intro j; cases j with
        | mk x hx =>
            rcases Finset.mem_erase.mp hx with ‚ü®hxi, hxU‚ü©
            simp [hxi] }
  have htransport :
      (‚àë j : {j // j ‚àà (Finset.univ.erase i)}, (a j.1) ‚Ä¢ w j.1)
        = ‚àë j : Comp Œπ i, (a j.1) ‚Ä¢ w j.1 := by
    simpa [e] using
      (e.symm.sum_comp (fun j => (a j.1) ‚Ä¢ w j.1))
  have hsub :
      (‚àë j ‚àà (Finset.univ.erase i), (a j) ‚Ä¢ w j)
        = ‚àë j : Comp Œπ i, (a j.1) ‚Ä¢ w j.1 := by
    calc
      (‚àë j ‚àà (Finset.univ.erase i), (a j) ‚Ä¢ w j)
          = (‚àë j : {j // j ‚àà (Finset.univ.erase i)}, (a j.1) ‚Ä¢ w j.1) := by
            simpa using hattach.symm
      _ = (‚àë j : Comp Œπ i, (a j.1) ‚Ä¢ w j.1) := htransport
  simpa [hsub] using hsplit.symm

/-- With coefficients `c : Œπ ‚Üí Œ© ‚Üí ‚Ñù`, the random vector `g` splits into complement + i-th. -/
lemma repr_split_along
  {Œ© : Type*} [MeasureSpace Œ©] {Œπ : Type*} [Fintype Œπ] [DecidableEq Œπ]
  {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ‚Ñù H]
  [CompleteSpace H] [MeasurableSpace H] [BorelSpace H]
  (w : OrthonormalBasis Œπ ‚Ñù H) (i : Œπ) (c : Œπ ‚Üí Œ© ‚Üí ‚Ñù) :
  ‚àÄ œâ, (‚àë j, (c j œâ) ‚Ä¢ w j) = buildAlong (w := w) i (fun j => c j.1 œâ) (c i œâ) := by
  intro œâ
  classical
  simpa [buildAlong] using
    sum_split_along (w := w) (i := i) (a := fun j => c j œâ)

/-- Decomposition of `g` along `w i`: complement + `i`-th coordinate. -/
lemma g_decomp_along
  {Œ© : Type*} [MeasureSpace Œ©] {Œπ : Type*} [Fintype Œπ] [DecidableEq Œπ]
  {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ‚Ñù H]
  [CompleteSpace H] [MeasurableSpace H] [BorelSpace H]
  {g : Œ© ‚Üí H}
  (hg : PhysLean.Probability.GaussianIBP.IsGaussianHilbert (Œ© := Œ©) (H := H) g)
  [DecidableEq hg.Œπ]
  (i : hg.Œπ) :
  ‚àÄ œâ, g œâ = buildAlong (w := hg.w) i (fun j => hg.c j.1 œâ) (hg.c i œâ) := by
  intro œâ
  classical
  simpa [hg.repr] using
    repr_split_along (w := hg.w) (i := i) (c := hg.c) œâ
end
end CoordLine
end CoordLineAndDecomposition

section JointLawFubini

open MeasureTheory ProbabilityTheory

variable {Œ© : Type*} [MeasureSpace Œ©] [IsProbabilityMeasure (‚Ñô : Measure Œ©)]

/-- If `Y` and `X` are independent measurable maps, the law of `(Y,X)` is the product of laws. -/
lemma map_pair_eq_prod_of_indep
  {Œ± Œ≤ : Type*} [MeasurableSpace Œ±] [MeasurableSpace Œ≤]
  (Y : Œ© ‚Üí Œ±) (X : Œ© ‚Üí Œ≤)
  (hY : Measurable Y) (hX : Measurable X)
  (hIndep : ProbabilityTheory.IndepFun Y X (‚Ñô : Measure Œ©)) :
  Measure.map (fun œâ => (Y œâ, X œâ)) (‚Ñô : Measure Œ©)
    = (Measure.map Y (‚Ñô : Measure Œ©)).prod (Measure.map X (‚Ñô : Measure Œ©)) := by
  classical
  exact
    (ProbabilityTheory.indepFun_iff_map_prod_eq_prod_map_map
      (Œº := (‚Ñô : Measure Œ©)) (hf := hY.aemeasurable) (hg := hX.aemeasurable)).1 hIndep

omit [IsProbabilityMeasure (‚Ñô : Measure Œ©)] in
/-- Change of variables for the pair map `(Y, X)`: no independence needed. -/
lemma integral_pair_change_of_variables
  {Œ± Œ≤ : Type*} [MeasurableSpace Œ±] [MeasurableSpace Œ≤]
  (Y : Œ© ‚Üí Œ±) (X : Œ© ‚Üí Œ≤)
  (hY : Measurable Y) (hX : Measurable X)
  {œÜ : Œ± √ó Œ≤ ‚Üí ‚Ñù} (hœÜ_meas : Measurable œÜ) :
  ‚à´ œâ, œÜ (Y œâ, X œâ) ‚àÇ‚Ñô = ‚à´ p, œÜ p ‚àÇ(Measure.map (fun œâ => (Y œâ, X œâ)) ‚Ñô) := by
  have hYX : AEMeasurable (fun œâ => (Y œâ, X œâ)) ‚Ñô := (hY.prodMk hX).aemeasurable
  have hœÜ : AEStronglyMeasurable œÜ (Measure.map (fun œâ => (Y œâ, X œâ)) ‚Ñô) :=
    hœÜ_meas.aestronglyMeasurable
  have h := MeasureTheory.integral_map hYX hœÜ
  simpa [Function.comp_def] using h.symm

/-- Same as `map_pair_eq_prod_of_indep` but only assuming a.e.-measurability of `Y` and `X`. -/
lemma map_pair_eq_prod_of_indep‚ÇÄ
  {Œ± Œ≤ : Type*} [MeasurableSpace Œ±] [MeasurableSpace Œ≤]
  (Y : Œ© ‚Üí Œ±) (X : Œ© ‚Üí Œ≤)
  (hY : AEMeasurable Y ‚Ñô) (hX : AEMeasurable X ‚Ñô)
  (hIndep : ProbabilityTheory.IndepFun Y X ‚Ñô) :
  Measure.map (fun œâ => (Y œâ, X œâ)) ‚Ñô
    = (Measure.map Y ‚Ñô).prod (Measure.map X ‚Ñô) := by
  classical
  exact
    (ProbabilityTheory.indepFun_iff_map_prod_eq_prod_map_map
      (Œº := (‚Ñô : Measure Œ©)) (hf := hY) (hg := hX)).1 hIndep

/-- Integration against the joint distribution of independent random variables
can be rewritten against the product of marginals (no integrability assumption needed). -/
lemma integral_joint_eq_integral_prod_of_indep_min
  {Œ± Œ≤ : Type*} [MeasurableSpace Œ±] [MeasurableSpace Œ≤]
  (Y : Œ© ‚Üí Œ±) (X : Œ© ‚Üí Œ≤)
  (hY : Measurable Y) (hX : Measurable X)
  (hIndep : ProbabilityTheory.IndepFun Y X ‚Ñô)
  {œÜ : Œ± √ó Œ≤ ‚Üí ‚Ñù} (hœÜ_meas : Measurable œÜ) :
  ‚à´ œâ, œÜ (Y œâ, X œâ) ‚àÇ‚Ñô = ‚à´ p, œÜ p ‚àÇ((Measure.map Y ‚Ñô).prod (Measure.map X ‚Ñô)) := by
  have hchg := integral_pair_change_of_variables Y X hY hX hœÜ_meas
  have hmap := map_pair_eq_prod_of_indep Y X hY hX hIndep
  simp [hchg, hmap]

omit [IsProbabilityMeasure (‚Ñô : Measure Œ©)] in
/- Transfer L¬π-finiteness from composition to pushforward measure via change of variables. -/
/-- Change of variables for the pair map `(Y, X)` (no independence needed). -/
lemma lintegral_map_pair_eq_lintegral_comp
    {Œ± Œ≤ : Type*} [MeasurableSpace Œ±] [MeasurableSpace Œ≤]
    (Y : Œ© ‚Üí Œ±) (X : Œ© ‚Üí Œ≤)
    (hY : Measurable Y) (hX : Measurable X)
    {œÜ : Œ± √ó Œ≤ ‚Üí ‚Ñù} (hœÜ_meas : Measurable œÜ) :
    ‚à´‚Åª p, (‚ÄñœÜ p‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ‚àÇ(Measure.map (fun œâ => (Y œâ, X œâ)) ‚Ñô)
      = ‚à´‚Åª œâ, (‚ÄñœÜ (Y œâ, X œâ)‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ‚àÇ‚Ñô := by
  have h_meas_norm : Measurable (fun p : Œ± √ó Œ≤ => (‚ÄñœÜ p‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) := by
    have h_norm_phi_meas : Measurable fun p => ‚ÄñœÜ p‚Äñ := hœÜ_meas.norm
    have h_ofReal_meas : Measurable ENNReal.ofReal := ENNReal.measurable_ofReal
    simp only [measurable_coe_nnreal_ennreal_iff]
    exact Measurable.nnnorm hœÜ_meas
  refine lintegral_map h_meas_norm ?_
  exact Measurable.prodMk hY hX

omit [IsProbabilityMeasure (‚Ñô : Measure Œ©)] in
/-- Transfer integrability from the composition `œÜ ‚àò (Y,X)` to `œÜ` under the push-forward law. -/
lemma integrable_map_pair_of_integrable_comp
    {Œ± Œ≤ : Type*} [MeasurableSpace Œ±] [MeasurableSpace Œ≤]
    (Y : Œ© ‚Üí Œ±) (X : Œ© ‚Üí Œ≤)
    (hY : Measurable Y) (hX : Measurable X)
    {œÜ : Œ± √ó Œ≤ ‚Üí ‚Ñù} (hœÜ_meas : Measurable œÜ)
    (hInt : Integrable (fun œâ => œÜ (Y œâ, X œâ)) ‚Ñô) :
    Integrable œÜ (Measure.map (fun œâ => (Y œâ, X œâ)) ‚Ñô) := by
  classical
  have hœÜ_aes : AEStronglyMeasurable œÜ (Measure.map (fun œâ => (Y œâ, X œâ)) ‚Ñô) :=
    hœÜ_meas.aestronglyMeasurable
  have h_norm_id :=
    lintegral_map_pair_eq_lintegral_comp Y X hY hX hœÜ_meas
  have hFin_comp : HasFiniteIntegral (fun œâ => œÜ (Y œâ, X œâ)) ‚Ñô := hInt.hasFiniteIntegral
  have hFin_push :
      HasFiniteIntegral œÜ (Measure.map (fun œâ => (Y œâ, X œâ)) ‚Ñô) := by
    refine (hasFiniteIntegral_def œÜ (Measure.map (fun œâ => (Y œâ, X œâ)) ‚Ñô)).mpr ?_
    exact lt_of_eq_of_lt h_norm_id hFin_comp
  exact ‚ü®hœÜ_aes, hFin_push‚ü©

/-- Transfer integrability from the push-forward law to the product law, using independence. -/
lemma integrable_prod_of_integrable_map_pair_of_indep
    {Œ± Œ≤ : Type*} [MeasurableSpace Œ±] [MeasurableSpace Œ≤]
    (Y : Œ© ‚Üí Œ±) (X : Œ© ‚Üí Œ≤)
    (hY : Measurable Y) (hX : Measurable X)
    (hIndep : ProbabilityTheory.IndepFun Y X ‚Ñô)
    {œÜ : Œ± √ó Œ≤ ‚Üí ‚Ñù} --(hœÜ_meas : Measurable œÜ)
    (hInt_map : Integrable œÜ (Measure.map (fun œâ => (Y œâ, X œâ)) ‚Ñô)) :
    Integrable œÜ ((Measure.map Y ‚Ñô).prod (Measure.map X ‚Ñô)) := by
  have hmap :
      Measure.map (fun œâ => (Y œâ, X œâ)) ‚Ñô
        = (Measure.map Y ‚Ñô).prod (Measure.map X ‚Ñô) :=
    map_pair_eq_prod_of_indep Y X hY hX hIndep
  simpa [hmap] using hInt_map

/-- Transfer integrability from the composition to the product law (needed for Fubini). -/
lemma integrable_on_prod_of_indep_of_integrable_comp
    {Œ± Œ≤ : Type*} [MeasurableSpace Œ±] [MeasurableSpace Œ≤]
    (Y : Œ© ‚Üí Œ±) (X : Œ© ‚Üí Œ≤)
    (hY : Measurable Y) (hX : Measurable X)
    (hIndep : ProbabilityTheory.IndepFun Y X ‚Ñô)
    {œÜ : Œ± √ó Œ≤ ‚Üí ‚Ñù} (hœÜ_meas : Measurable œÜ)
    (hInt : Integrable (fun œâ => œÜ (Y œâ, X œâ)) ‚Ñô) :
    Integrable œÜ ((Measure.map Y ‚Ñô).prod (Measure.map X ‚Ñô)) := by
  have hInt_map :=
    integrable_map_pair_of_integrable_comp Y X hY hX hœÜ_meas hInt
  exact
    integrable_prod_of_integrable_map_pair_of_indep
      Y X hY hX hIndep hInt_map

/-- Wrapper with the original name/signature kept for compatibility:
the integrability assumption is not needed for the equality, so it is ignored. -/
lemma integral_joint_eq_integral_prod_of_indep
  {Œ± Œ≤ : Type*} [MeasurableSpace Œ±] [MeasurableSpace Œ≤]
  (Y : Œ© ‚Üí Œ±) (X : Œ© ‚Üí Œ≤)
  (hY : Measurable Y) (hX : Measurable X)
  (hIndep : ProbabilityTheory.IndepFun Y X ‚Ñô)
  {œÜ : Œ± √ó Œ≤ ‚Üí ‚Ñù}
  (hœÜ_meas : Measurable œÜ)
  (_hInt : Integrable (fun œâ => œÜ (Y œâ, X œâ)) ‚Ñô) :
  ‚à´ œâ, œÜ (Y œâ, X œâ) ‚àÇ‚Ñô = ‚à´ p, œÜ p ‚àÇ((Measure.map Y ‚Ñô).prod (Measure.map X ‚Ñô)) :=
  integral_joint_eq_integral_prod_of_indep_min Y X hY hX hIndep hœÜ_meas

/-- Fubini factorisation when `Y` and `X` are independent. -/
lemma integral_pair_via_prod
    {Œ± Œ≤ : Type*}
    [TopologicalSpace Œ±] [MeasurableSpace Œ±] [BorelSpace Œ±]
    [TopologicalSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    (Y : Œ© ‚Üí Œ±) (X : Œ© ‚Üí Œ≤)
    (hY : Measurable Y) (hX : Measurable X)
    (hIndep : ProbabilityTheory.IndepFun Y X ‚Ñô)
    {Œ® : Œ± ‚Üí Œ≤ ‚Üí ‚Ñù}
    (hŒ®_meas : Measurable (fun p : Œ± √ó Œ≤ => Œ® p.1 p.2))
    (hInt : Integrable (fun œâ => Œ® (Y œâ) (X œâ)) ‚Ñô) :
    ‚à´ œâ, Œ® (Y œâ) (X œâ) ‚àÇ‚Ñô
      = ‚à´ y, ‚à´ x, Œ® y x ‚àÇ(Measure.map X ‚Ñô) ‚àÇ(Measure.map Y ‚Ñô) := by
  classical
  set œÜ : Œ± √ó Œ≤ ‚Üí ‚Ñù := fun p => Œ® p.1 p.2
  have h1 :=
    integral_joint_eq_integral_prod_of_indep_min Y X hY hX hIndep (hœÜ_meas := hŒ®_meas)
  have hInt_prod :
      Integrable œÜ ((Measure.map Y ‚Ñô).prod (Measure.map X ‚Ñô)) :=
    integrable_on_prod_of_indep_of_integrable_comp
      Y X hY hX hIndep (hœÜ_meas := hŒ®_meas) (hInt := by simpa [œÜ] using hInt)
  have h2 :
      ‚à´ p, œÜ p ‚àÇ((Measure.map Y ‚Ñô).prod (Measure.map X ‚Ñô))
        = ‚à´ y, ‚à´ x, Œ® y x ‚àÇ(Measure.map X ‚Ñô) ‚àÇ(Measure.map Y ‚Ñô) := by
    simpa [œÜ] using
      MeasureTheory.integral_prod
        (Œº := Measure.map Y ‚Ñô) (ŒΩ := Measure.map X ‚Ñô) œÜ hInt_prod
  simpa [œÜ] using (h1.trans h2)

/-- If `X` is a real-valued random variable with Gaussian law `gaussianReal 0 v`,
independent of `Y`, and if `œâ ‚Ü¶ œÜ (Y œâ, X œâ)` is integrable, then `œÜ` is integrable
with respect to the product measure `(map Y ‚Ñô) √ó (gaussianReal 0 v)`.

This is a Gaussian specialization of `integrable_on_prod_of_indep_of_integrable_comp`. -/
lemma integrable_phi_on_mapY_prod_gauss
  {Œ± : Type*} [MeasurableSpace Œ±]
  (Y : Œ© ‚Üí Œ±) (X : Œ© ‚Üí ‚Ñù)
  (hY : Measurable Y) (hX : Measurable X)
  (hIndep : ProbabilityTheory.IndepFun Y X ‚Ñô)
  (v : ‚Ñù‚â•0) (hXlaw : Measure.map X ‚Ñô = ProbabilityTheory.gaussianReal 0 v)
  {œÜ : Œ± √ó ‚Ñù ‚Üí ‚Ñù} (hœÜ_meas : Measurable œÜ)
  (hInt : Integrable (fun œâ => œÜ (Y œâ, X œâ)) ‚Ñô) :
  Integrable œÜ ((Measure.map Y ‚Ñô).prod (ProbabilityTheory.gaussianReal 0 v)) := by
  have hInt_prod :
      Integrable œÜ ((Measure.map Y ‚Ñô).prod (Measure.map X ‚Ñô)) :=
    integrable_on_prod_of_indep_of_integrable_comp
      Y X hY hX hIndep hœÜ_meas hInt
  simpa [hXlaw] using hInt_prod

lemma integrable_psi_on_mapY_prod_gauss
  {Œ± : Type*} [MeasurableSpace Œ±]
  (Y : Œ© ‚Üí Œ±) (X : Œ© ‚Üí ‚Ñù)
  (hY : Measurable Y) (hX : Measurable X)
  (hIndep : ProbabilityTheory.IndepFun Y X ‚Ñô)
  (v : ‚Ñù‚â•0) (hXlaw : Measure.map X ‚Ñô = ProbabilityTheory.gaussianReal 0 v)
  {œà : Œ± √ó ‚Ñù ‚Üí ‚Ñù} (hœà_meas : Measurable œà)
  (hInt : Integrable (fun œâ => œà (Y œâ, X œâ)) ‚Ñô) :
  Integrable œà ((Measure.map Y ‚Ñô).prod (ProbabilityTheory.gaussianReal 0 v)) := by
  have hInt_prod :
      Integrable œà ((Measure.map Y ‚Ñô).prod (Measure.map X ‚Ñô)) :=
    integrable_on_prod_of_indep_of_integrable_comp
      Y X hY hX hIndep hœà_meas hInt
  simpa [hXlaw] using hInt_prod

end JointLawFubini

section SliceCalculus

open scoped BigOperators
open MeasureTheory ProbabilityTheory

variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ‚Ñù H]
variable [CompleteSpace H] [MeasurableSpace H] [BorelSpace H]

namespace CoordLine

variable {Œπ : Type*} [Fintype Œπ]
variable (w : OrthonormalBasis Œπ ‚Ñù H) (i : Œπ)

/-- The linear map `‚Ñù ‚ÜíL[‚Ñù] H`, `x ‚Ü¶ x ‚Ä¢ w i`. -/
@[simp] def lineCLM : ‚Ñù ‚ÜíL[‚Ñù] H := (1 : ‚Ñù ‚ÜíL[‚Ñù] ‚Ñù).smulRight (w i)

/-- Affine line map `x ‚Ü¶ z + x ‚Ä¢ w i`. -/
@[simp] def line (z : H) : ‚Ñù ‚Üí H := fun x => z + (lineCLM (w := w) (i := i)) x

omit [CompleteSpace H] [MeasurableSpace H] [BorelSpace H] in
lemma line_def (z : H) (x : ‚Ñù) : line (w := w) (i := i) z x = z + x ‚Ä¢ w i := rfl

omit [CompleteSpace H] [MeasurableSpace H] [BorelSpace H] in
/-- Chain rule for the 1D slice of a `C¬π` test `F : H ‚Üí ‚Ñù`. -/
lemma deriv_F_along (F : H ‚Üí ‚Ñù) (hF : ContDiff ‚Ñù 1 F) (z : H) :
  ‚àÄ x, deriv (fun t => F (line (w := w) (i := i) z t)) x
        = (fderiv ‚Ñù F (line (w := w) (i := i) z x)) (w i) := by
  intro x
  have hline : HasFDerivAt (line (w := w) (i := i) z)
      (lineCLM (w := w) (i := i)) x :=
    (lineCLM (w := w) (i := i)).hasFDerivAt.const_add z
  have hF' : HasFDerivAt F (fderiv ‚Ñù F (line (w := w) (i := i) z x))
      (line (w := w) (i := i) z x) :=
    (hF.differentiable le_rfl _).hasFDerivAt
  have hcomp := hF'.comp x hline
  have hderiv :
      HasDerivAt (fun t => F (line (w := w) (i := i) z t))
        (((fderiv ‚Ñù F (line (w := w) (i := i) z x)).comp
            (lineCLM (w := w) (i := i))) 1) x := by
    simpa using hcomp.hasDerivAt
  have hCLM1 : (lineCLM (w := w) (i := i)) 1 = w i := by
    simp [lineCLM, one_mul]
  simpa [ContinuousLinearMap.comp_apply, hCLM1] using hderiv.deriv

/-!
Split moderateGrowth_along into general affine lemmas and a thin ONB wrapper.
-/
namespace AffineModerateGrowth

open Real

variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]

/-- Basic affine bound along a line:
`1 + ‚Äñz + L x‚Äñ ‚â§ (1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ) * (1 + |x|)`. -/
lemma one_add_norm_comp_affine_le
    (z : E) (L : ‚Ñù ‚ÜíL[‚Ñù] E) (x : ‚Ñù) :
  1 + ‚Äñz + L x‚Äñ ‚â§ (1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ) * (1 + |x|) := by
  have h_tri : ‚Äñz + L x‚Äñ ‚â§ ‚Äñz‚Äñ + ‚ÄñL x‚Äñ := norm_add_le _ _
  have h_op : ‚ÄñL x‚Äñ ‚â§ ‚ÄñL‚Äñ * ‚Äñx‚Äñ := L.le_opNorm x
  have hx : ‚Äñx‚Äñ = |x| := by simp [Real.norm_eq_abs]
  have h1 : 1 + ‚Äñz + L x‚Äñ ‚â§ 1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ * |x| := by
    calc
      1 + ‚Äñz + L x‚Äñ ‚â§ 1 + (‚Äñz‚Äñ + ‚ÄñL x‚Äñ) := by simpa only [add_assoc] using add_le_add_left h_tri 1
      _ = 1 + ‚Äñz‚Äñ + ‚ÄñL x‚Äñ := by simp [add_assoc]
      _ ‚â§ 1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ * |x| := by simpa [hx] using add_le_add_left h_op (1 + ‚Äñz‚Äñ)
  have h_nonneg_z : 0 ‚â§ 1 + ‚Äñz‚Äñ := by nlinarith [norm_nonneg z]
  have h_one_le : 1 ‚â§ 1 + |x| := by linarith [abs_nonneg x]
  have h_left_mul : 1 + ‚Äñz‚Äñ ‚â§ (1 + ‚Äñz‚Äñ) * (1 + |x|) :=
    le_mul_of_one_le_right h_nonneg_z h_one_le
  have h_x_le : |x| ‚â§ 1 + |x| := by linarith [abs_nonneg x]
  have h_right_mul : ‚ÄñL‚Äñ * |x| ‚â§ ‚ÄñL‚Äñ * (1 + |x|) :=
    mul_le_mul_of_nonneg_left h_x_le (norm_nonneg (L : ‚Ñù ‚ÜíL[‚Ñù] E))
  have h_sum : 1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ * |x| ‚â§ (1 + ‚Äñz‚Äñ) * (1 + |x|) + ‚ÄñL‚Äñ * (1 + |x|) :=
    add_le_add h_left_mul h_right_mul
  have : (1 + ‚Äñz‚Äñ) * (1 + |x|) + ‚ÄñL‚Äñ * (1 + |x|) = (1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ) * (1 + |x|) := by
    simp [mul_add, add_comm, add_left_comm, add_assoc, mul_comm]
  calc
    1 + ‚Äñz + L x‚Äñ ‚â§ 1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ * |x| := h1
    _ ‚â§ (1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ) * (1 + |x|) := by simpa using (le_trans h_sum (le_of_eq this))

/-- Power version of the previous bound. -/
lemma pow_le_pow_one_add_norm_comp_affine
    (z : E) (L : ‚Ñù ‚ÜíL[‚Ñù] E) (x : ‚Ñù) (m : ‚Ñï) :
  (1 + ‚Äñz + L x‚Äñ) ^ m ‚â§ ((1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ) * (1 + |x|)) ^ m := by
  have hbase : 0 ‚â§ 1 + ‚Äñz + L x‚Äñ := by nlinarith [norm_nonneg (z + L x)]
  exact Real.pow_le_pow_of_le_left hbase (one_add_norm_comp_affine_le z L x) m

/-- Chain rule for slicing `F : E ‚Üí ‚Ñù` along an affine line `x ‚Ü¶ z + L x`. -/
lemma deriv_comp_affine
    {F : E ‚Üí ‚Ñù} (hF : ContDiff ‚Ñù 1 F) (z : E) (L : ‚Ñù ‚ÜíL[‚Ñù] E) (x : ‚Ñù) :
  deriv (fun t => F (z + L t)) x = (fderiv ‚Ñù F (z + L x)) (L 1) := by
  have hline : HasFDerivAt (fun t : ‚Ñù => z + L t) L x := L.hasFDerivAt.const_add z
  have hF' : HasFDerivAt F (fderiv ‚Ñù F (z + L x)) (z + L x) :=
    (hF.differentiable le_rfl _).hasFDerivAt
  have hcomp := hF'.comp x hline
  have : HasDerivAt (fun t => F (z + L t))
          (((fderiv ‚Ñù F (z + L x)).comp L) 1) x := hcomp.hasDerivAt
  simpa [ContinuousLinearMap.comp_apply] using this.deriv

variable {H : Type*} [NormedAddCommGroup H] [NormedSpace ‚Ñù H]

lemma bound_dF_apply {F : H ‚Üí ‚Ñù} (hMG : HasModerateGrowth F) (z h : H) :
    ‚Äñ(fderiv ‚Ñù F z) h‚Äñ ‚â§ hMG.C * (1 + ‚Äñz‚Äñ) ^ hMG.m * ‚Äñh‚Äñ := by
  have h_op : ‚Äñ(fderiv ‚Ñù F z) h‚Äñ ‚â§ ‚Äñfderiv ‚Ñù F z‚Äñ * ‚Äñh‚Äñ := ContinuousLinearMap.le_opNorm _ _
  have h_coeff_nonneg : 0 ‚â§ ‚Äñh‚Äñ := norm_nonneg _
  have h_body_le : ‚Äñfderiv ‚Ñù F z‚Äñ * ‚Äñh‚Äñ ‚â§ (hMG.C * (1 + ‚Äñz‚Äñ) ^ hMG.m) * ‚Äñh‚Äñ :=
    mul_le_mul_of_nonneg_right (hMG.dF_bound z) h_coeff_nonneg
  exact h_op.trans h_body_le

/-- General affine bound: `1 + ‚Äñz + L x‚Äñ ‚â§ (1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ) * (1 + ‚Äñx‚Äñ)` for L : E' ‚ÜíL[‚Ñù] E. -/
lemma one_add_norm_comp_affine_le'
    {E' E : Type*} [NormedAddCommGroup E'] [NormedSpace ‚Ñù E']
    [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
    (z : E) (L : E' ‚ÜíL[‚Ñù] E) (x : E') :
  1 + ‚Äñz + L x‚Äñ ‚â§ (1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ) * (1 + ‚Äñx‚Äñ) := by
  have h_tri : ‚Äñz + L x‚Äñ ‚â§ ‚Äñz‚Äñ + ‚ÄñL x‚Äñ := norm_add_le _ _
  have h_op : ‚ÄñL x‚Äñ ‚â§ ‚ÄñL‚Äñ * ‚Äñx‚Äñ := L.le_opNorm x
  have h1 : 1 + ‚Äñz + L x‚Äñ ‚â§ 1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ * ‚Äñx‚Äñ := by
    calc
      1 + ‚Äñz + L x‚Äñ ‚â§ 1 + (‚Äñz‚Äñ + ‚ÄñL x‚Äñ) := by simpa [add_assoc] using add_le_add_left h_tri 1
      _ = 1 + ‚Äñz‚Äñ + ‚ÄñL x‚Äñ := by simp [add_assoc]
      _ ‚â§ 1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ * ‚Äñx‚Äñ := by simpa using add_le_add_left h_op (1 + ‚Äñz‚Äñ)
  have hx : ‚Äñx‚Äñ ‚â§ 1 + ‚Äñx‚Äñ := by nlinarith [norm_nonneg (x : E')]
  have hz : 0 ‚â§ 1 + ‚Äñz‚Äñ := by nlinarith [norm_nonneg (z : E)]
  have h_left : 1 + ‚Äñz‚Äñ ‚â§ (1 + ‚Äñz‚Äñ) * (1 + ‚Äñx‚Äñ) := le_mul_of_one_le_right hz (by nlinarith [norm_nonneg (x : E')])
  have h_right : ‚ÄñL‚Äñ * ‚Äñx‚Äñ ‚â§ ‚ÄñL‚Äñ * (1 + ‚Äñx‚Äñ) := mul_le_mul_of_nonneg_left hx (norm_nonneg (L : E' ‚ÜíL[‚Ñù] E))
  have h_sum := add_le_add h_left h_right
  have : (1 + ‚Äñz‚Äñ) * (1 + ‚Äñx‚Äñ) + ‚ÄñL‚Äñ * (1 + ‚Äñx‚Äñ) = (1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ) * (1 + ‚Äñx‚Äñ) := by ring
  exact (le_trans h1 (le_trans (le_of_eq (by simp [this])) h_sum)).trans (le_of_eq (by simp [this]))

/-- Power version. -/
lemma pow_le_pow_one_add_norm_comp_affine'
    {E' E : Type*} [NormedAddCommGroup E'] [NormedSpace ‚Ñù E']
    [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
    (z : E) (L : E' ‚ÜíL[‚Ñù] E) (x : E') (m : ‚Ñï) :
  (1 + ‚Äñz + L x‚Äñ) ^ m ‚â§ ((1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ) * (1 + ‚Äñx‚Äñ)) ^ m := by
  have hbase : 0 ‚â§ 1 + ‚Äñz + L x‚Äñ := by nlinarith [norm_nonneg (z + L x)]
  exact Real.pow_le_pow_of_le_left hbase (one_add_norm_comp_affine_le' z L x) m

/-- Value bound after composing F : E ‚Üí ‚Ñù with affine line x ‚Ü¶ z + L x (real parameter). -/
lemma growth_bound_comp_affine_real_value
    {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
    {F : E ‚Üí ‚Ñù}
    (hMG : PhysLean.Probability.GaussianIBP.HasModerateGrowth F)
    (z : E) (L : ‚Ñù ‚ÜíL[‚Ñù] E) :
  ‚àÄ x : ‚Ñù,
    |F (z + L x)|
      ‚â§ (hMG.C * (1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ) ^ hMG.m) * (1 + |x|) ^ hMG.m := by
  intro x
  have hF := hMG.F_bound (z + L x)
  have hpow := pow_le_pow_one_add_norm_comp_affine' (z := z) (L := L) (x := x) (m := hMG.m)
  have hx : ‚Äñx‚Äñ = |x| := by simp
  calc
    |F (z + L x)| ‚â§ hMG.C * (1 + ‚Äñz + L x‚Äñ) ^ hMG.m := hF
    _ ‚â§ hMG.C * (((1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ) * (1 + ‚Äñx‚Äñ)) ^ hMG.m) := by exact mul_le_mul_of_nonneg_left hpow (le_of_lt hMG.Cpos)
    _ = (hMG.C * (1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ) ^ hMG.m) * (1 + |x|) ^ hMG.m := by simp [mul_pow, hx, mul_comm, mul_left_comm, mul_assoc]

/-- Derivative bound after composing F : E ‚Üí ‚Ñù with affine line x ‚Ü¶ z + L x (real parameter). -/
lemma growth_bound_comp_affine_real_deriv
    {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
    {F : E ‚Üí ‚Ñù}
    (hF_diff : ContDiff ‚Ñù 1 F)
    (hMG : PhysLean.Probability.GaussianIBP.HasModerateGrowth F)
    (z : E) (L : ‚Ñù ‚ÜíL[‚Ñù] E) :
  ‚àÄ x : ‚Ñù,
    |deriv (fun t => F (z + L t)) x|
      ‚â§ (hMG.C * (1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ) ^ hMG.m * (1 + ‚ÄñL‚Äñ)) * (1 + |x|) ^ hMG.m := by
  intro x
  have hderiv := deriv_comp_affine (hF := hF_diff) (z := z) (L := L) (x := x)
  have hL1 : ‚ÄñL 1‚Äñ ‚â§ ‚ÄñL‚Äñ := by
    simpa [Real.norm_eq_abs, abs_one, mul_one] using (L.le_opNorm (1 : ‚Ñù))
  have h_df : ‚Äñfderiv ‚Ñù F (z + L x)‚Äñ ‚â§ hMG.C * (1 + ‚Äñz + L x‚Äñ) ^ hMG.m := hMG.dF_bound _
  have hval :
      |(fderiv ‚Ñù F (z + L x)) (L 1)| ‚â§ ‚Äñfderiv ‚Ñù F (z + L x)‚Äñ * ‚ÄñL 1‚Äñ := by
    simpa [Real.norm_eq_abs] using
      (ContinuousLinearMap.le_opNorm (fderiv ‚Ñù F (z + L x)) (L 1))
  have h1 :
      |deriv (fun t => F (z + L t)) x|
        ‚â§ hMG.C * (1 + ‚Äñz + L x‚Äñ) ^ hMG.m * ‚ÄñL‚Äñ := by
    have := calc
      |(fderiv ‚Ñù F (z + L x)) (L 1)|
            ‚â§ ‚Äñfderiv ‚Ñù F (z + L x)‚Äñ * ‚ÄñL 1‚Äñ := hval
      _ ‚â§ ‚Äñfderiv ‚Ñù F (z + L x)‚Äñ * ‚ÄñL‚Äñ := mul_le_mul_of_nonneg_left hL1 (norm_nonneg _)
      _ ‚â§ hMG.C * (1 + ‚Äñz + L x‚Äñ) ^ hMG.m * ‚ÄñL‚Äñ :=
            mul_le_mul_of_nonneg_right h_df (norm_nonneg _)
    simpa [hderiv, mul_comm, mul_left_comm, mul_assoc] using this
  have hL_le : ‚ÄñL‚Äñ ‚â§ 1 + ‚ÄñL‚Äñ := by nlinarith [norm_nonneg (L : ‚Ñù ‚ÜíL[‚Ñù] E)]
  have coeff_nonneg :
      0 ‚â§ hMG.C * (1 + ‚Äñz + L x‚Äñ) ^ hMG.m :=
    mul_nonneg (le_of_lt hMG.Cpos) (pow_nonneg (by nlinarith [norm_nonneg (z + L x)]) _)
  have h2 :
      hMG.C * (1 + ‚Äñz + L x‚Äñ) ^ hMG.m * ‚ÄñL‚Äñ
        ‚â§ hMG.C * (1 + ‚Äñz + L x‚Äñ) ^ hMG.m * (1 + ‚ÄñL‚Äñ) :=
    mul_le_mul_of_nonneg_left hL_le coeff_nonneg
  have hx : ‚Äñx‚Äñ = |x| := by simp
  have hpow‚ÇÄ :=
    pow_le_pow_one_add_norm_comp_affine' (z := z) (L := L) (x := x) (m := hMG.m)
  have hpow' :
      (1 + ‚Äñz + L x‚Äñ) ^ hMG.m
        ‚â§ (1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ) ^ hMG.m * (1 + |x|) ^ hMG.m := by
    simpa [mul_pow, hx] using hpow‚ÇÄ
  have h3 :
      hMG.C * (1 + ‚Äñz + L x‚Äñ) ^ hMG.m * (1 + ‚ÄñL‚Äñ)
        ‚â§ (hMG.C * (1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ) ^ hMG.m * (1 + ‚ÄñL‚Äñ)) * (1 + |x|) ^ hMG.m := by
    have t1 := mul_le_mul_of_nonneg_left hpow' (le_of_lt hMG.Cpos)
    have h1L : 0 ‚â§ 1 + ‚ÄñL‚Äñ := by nlinarith [norm_nonneg (L : ‚Ñù ‚ÜíL[‚Ñù] E)]
    have t2 := mul_le_mul_of_nonneg_right t1 h1L
    simpa [mul_comm, mul_left_comm, mul_assoc, mul_pow] using t2
  exact (h1.trans (h2.trans h3))

/-- Thin wrapper: moderate growth for x ‚Ü¶ F (z + L x). -/
lemma moderateGrowth_comp_affine_real
    {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
    {F : E ‚Üí ‚Ñù} (hF_diff : ContDiff ‚Ñù 1 F)
    (hMG : PhysLean.Probability.GaussianIBP.HasModerateGrowth F)
    (z : E) (L : ‚Ñù ‚ÜíL[‚Ñù] E) :
  ProbabilityTheory.HasModerateGrowth (fun x : ‚Ñù => F (z + L x)) := by
  set A : ‚Ñù := 1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ
  set C' : ‚Ñù := hMG.C * A ^ hMG.m * (1 + ‚ÄñL‚Äñ)
  have hApos : 0 < A := by nlinarith [norm_nonneg z, norm_nonneg (L : ‚Ñù ‚ÜíL[‚Ñù] E)]
  have hAmpos : 0 < A ^ hMG.m := pow_pos hApos _
  have hLpos : 0 < (1 + ‚ÄñL‚Äñ) := by nlinarith [norm_nonneg (L : ‚Ñù ‚ÜíL[‚Ñù] E)]
  have hC'pos : 0 < C' := mul_pos (mul_pos hMG.Cpos hAmpos) hLpos
  refine ‚ü®C', hMG.m, hC'pos, ?_, ?_‚ü©
  ¬∑ intro x
    exact (growth_bound_comp_affine_real_value (hMG := hMG) (z := z) (L := L) x).trans (by
      have hfac : (hMG.C * A ^ hMG.m) ‚â§ C' := by
        have hL1 : 1 ‚â§ 1 + ‚ÄñL‚Äñ := by nlinarith [norm_nonneg (L : ‚Ñù ‚ÜíL[‚Ñù] E)]
        have hnonneg : 0 ‚â§ hMG.C * A ^ hMG.m :=
          mul_nonneg (le_of_lt hMG.Cpos) (pow_nonneg (le_of_lt hApos) _)
        calc
          hMG.C * A ^ hMG.m = (hMG.C * A ^ hMG.m) * 1 := by ring
          _ ‚â§ (hMG.C * A ^ hMG.m) * (1 + ‚ÄñL‚Äñ) := mul_le_mul_of_nonneg_left hL1 hnonneg
          _ = C' := by simp [C']
      have hx_nonneg : 0 ‚â§ (1 + |x|) ^ hMG.m := pow_nonneg (by linarith [abs_nonneg x]) _
      exact mul_le_mul_of_nonneg_right hfac hx_nonneg)
  ¬∑ intro x
    exact (growth_bound_comp_affine_real_deriv (hF_diff := hF_diff) (hMG := hMG) (z := z) (L := L) x).trans (by
      have hcoeff :
          hMG.C * (1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ) ^ hMG.m * (1 + ‚ÄñL‚Äñ) = C' := by aesop
      have : (hMG.C * (1 + ‚Äñz‚Äñ + ‚ÄñL‚Äñ) ^ hMG.m * (1 + ‚ÄñL‚Äñ)) * (1 + |x|) ^ hMG.m
            = C' * (1 + |x|) ^ hMG.m := by simp [hcoeff]
      exact le_of_eq this)

end AffineModerateGrowth

open AffineModerateGrowth

variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ‚Ñù H]
variable [CompleteSpace H] [MeasurableSpace H] [BorelSpace H]
variable {Œπ : Type*} [Fintype Œπ]

variable (w : OrthonormalBasis Œπ ‚Ñù H) (i : Œπ)

omit [CompleteSpace H] [MeasurableSpace H] [BorelSpace H] in
/-- Wrapper: moderate growth along the ONB coordinate line. -/
lemma moderateGrowth_along
  (F : H ‚Üí ‚Ñù)
  (hF_diff : ContDiff ‚Ñù 1 F)
  (hMG : PhysLean.Probability.GaussianIBP.HasModerateGrowth F)
  (z : H) :
  ProbabilityTheory.HasModerateGrowth (fun x : ‚Ñù => F (z + x ‚Ä¢ w i)) := by
  have h := AffineModerateGrowth.moderateGrowth_comp_affine_real
            (hF_diff := hF_diff) (hMG := hMG) (z := z) (L := lineCLM (w := w) (i := i))
  simpa [lineCLM] using h

end CoordLine
end SliceCalculus

section OneDStepWithParameter

open MeasureTheory ProbabilityTheory
open CoordLine

variable {vœÑ : ‚Ñù‚â•0}

/-- 1D Gaussian IBP along a coordinate line, with an external parameter `y`. -/
lemma gaussian_IBP_along_line
  {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ‚Ñù H]
  [CompleteSpace H] [MeasurableSpace H] [BorelSpace H]
  {Œπ : Type*} [Fintype Œπ] [DecidableEq Œπ]
  (w : OrthonormalBasis Œπ ‚Ñù H) (i : Œπ)
  (F : H ‚Üí ‚Ñù) (hF_diff : ContDiff ‚Ñù 1 F)
  (hF_growth : PhysLean.Probability.GaussianIBP.HasModerateGrowth F)
  (y : CoordLine.Comp Œπ i ‚Üí ‚Ñù) :
  ‚à´ (x : ‚Ñù), x * (F (buildAlong (w := w) (i := i) y x)) ‚àÇ(ProbabilityTheory.gaussianReal 0 vœÑ)
    = (vœÑ : ‚Ñù) * ‚à´ (x : ‚Ñù), (deriv (fun t => F (buildAlong (w := w) (i := i) y t)) x)
        ‚àÇ(ProbabilityTheory.gaussianReal 0 vœÑ) := by
  classical
  let z : H := ‚àë j : CoordLine.Comp Œπ i, (y j) ‚Ä¢ w j.1
  have hMG1D : ProbabilityTheory.HasModerateGrowth (fun x : ‚Ñù => F (z + x ‚Ä¢ w i)) :=
    CoordLine.moderateGrowth_along (w := w) (i := i) F hF_diff hF_growth z
  have hF1D : ContDiff ‚Ñù 1 (fun x : ‚Ñù => F (z + x ‚Ä¢ w i)) := by
    exact hF_diff.comp ((contDiff_const.add (contDiff_id.smul contDiff_const)) : ContDiff ‚Ñù 1 (fun x : ‚Ñù => z + x ‚Ä¢ w i))
  by_cases hv : vœÑ = 0
  ¬∑ subst hv
    simp [z, CoordLine.buildAlong, add_comm, add_left_comm, add_assoc]
  ¬∑ have hIBP :=
      ProbabilityTheory.gaussianReal_integration_by_parts
        (v := vœÑ) (hv := hv)
        (F := fun x : ‚Ñù => F (z + x ‚Ä¢ w i))
        (hF := hF1D)
        (hMod := hMG1D)
    simpa [z, CoordLine.buildAlong, add_comm, add_left_comm, add_assoc] using hIBP

end OneDStepWithParameter

section SteinAlongOneCoordinate

open scoped BigOperators
open MeasureTheory ProbabilityTheory
open CoordLine

variable {Œ© : Type*} [MeasureSpace Œ©] [IsProbabilityMeasure (‚Ñô : Measure Œ©)]
variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ‚Ñù H] [CompleteSpace H]
variable [MeasurableSpace H] [BorelSpace H]

variable {Œπ : Type*} [Fintype Œπ] [DecidableEq Œπ]

namespace ProductIBP

open MeasureTheory

variable {Œ± Œ≤ : Type*}
variable [MeasurableSpace Œ±] [MeasurableSpace Œ≤]

/-- Fubini transport of a section-wise identity to the product. -/
lemma integral_prod_of_section_eq
  (ŒºŒ± : Measure Œ±) (ŒºŒ≤ : Measure Œ≤) (hŒ± : SFinite ŒºŒ±) (hŒ≤ : SFinite ŒºŒ≤)
  {œÜ œà : Œ± √ó Œ≤ ‚Üí ‚Ñù}
  (hœÜ_int : Integrable œÜ (ŒºŒ±.prod ŒºŒ≤))
  (hœà_int : Integrable œà (ŒºŒ±.prod ŒºŒ≤))
  (hSec : ‚àÄ a, ‚à´ b, œÜ (a, b) ‚àÇŒºŒ≤ = ‚à´ b, œà (a, b) ‚àÇŒºŒ≤) :
  ‚à´ p, œÜ p ‚àÇ(ŒºŒ±.prod ŒºŒ≤) = ‚à´ p, œà p ‚àÇ(ŒºŒ±.prod ŒºŒ≤) := by
  classical
  haveI : SFinite ŒºŒ± := hŒ±
  have hœÜ_prod :
      (‚à´ p, œÜ p ‚àÇ(ŒºŒ±.prod ŒºŒ≤))
        = (‚à´ a, ‚à´ b, œÜ (a, b) ‚àÇŒºŒ≤ ‚àÇŒºŒ±) :=
    MeasureTheory.integral_prod (Œº := ŒºŒ±) (ŒΩ := ŒºŒ≤) (f := œÜ) hœÜ_int
  have hœà_prod :
      (‚à´ p, œà p ‚àÇ(ŒºŒ±.prod ŒºŒ≤))
        = (‚à´ a, ‚à´ b, œà (a, b) ‚àÇŒºŒ≤ ‚àÇŒºŒ±) :=
    MeasureTheory.integral_prod (Œº := ŒºŒ±) (ŒΩ := ŒºŒ≤) (f := œà) hœà_int
  have h_congr :
      (‚à´ a, ‚à´ b, œÜ (a, b) ‚àÇŒºŒ≤ ‚àÇŒºŒ±)
        = (‚à´ a, ‚à´ b, œà (a, b) ‚àÇŒºŒ≤ ‚àÇŒºŒ±) :=
    MeasureTheory.integral_congr_ae (Œº := ŒºŒ±)
      (Filter.Eventually.of_forall (fun a => by simpa using hSec a))
  simpa [hœÜ_prod, hœà_prod] using h_congr

end ProductIBP

namespace CoordLine

open Topology

variable {Œπ : Type*} [Fintype Œπ] [DecidableEq Œπ]
variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ‚Ñù H]

/-- Continuity of the affine ONB coordinate-line map (y,x) ‚Ü¶ buildAlong w i y x. -/
lemma buildAlong_continuous
  (w : OrthonormalBasis Œπ ‚Ñù H) (i : Œπ) :
  Continuous (fun p : (Comp Œπ i ‚Üí ‚Ñù) √ó ‚Ñù => buildAlong (w := w) (i := i) p.1 p.2) := by
  classical
  have h_eval_sum :
      Continuous (fun y : Comp Œπ i ‚Üí ‚Ñù =>
        (‚àë j : Comp Œπ i, (y j) ‚Ä¢ w j.1 : H)) := by
    refine
      continuous_finset_sum
        (s := (Finset.univ : Finset (Comp Œπ i)))
        (f := fun (j : Comp Œπ i) (y : Comp Œπ i ‚Üí ‚Ñù) => (y j) ‚Ä¢ w j.1)
        ?_
    intro j hj
    simpa using (continuous_apply j).smul continuous_const
  have h1 : Continuous (fun p : (Comp Œπ i ‚Üí ‚Ñù) √ó ‚Ñù =>
      ‚àë j : Comp Œπ i, (p.1 j) ‚Ä¢ w j.1) :=
    h_eval_sum.comp continuous_fst
  have h2 : Continuous (fun p : (Comp Œπ i ‚Üí ‚Ñù) √ó ‚Ñù => p.2 ‚Ä¢ w i) :=
    continuous_snd.smul continuous_const
  simpa [buildAlong, add_comm, add_left_comm, add_assoc] using h1.add h2

section meas
variable [MeasurableSpace H] [BorelSpace H]

/-- Measurability of the affine ONB coordinate-line map. -/
lemma buildAlong_measurable
  (w : OrthonormalBasis Œπ ‚Ñù H) (i : Œπ) :
  Measurable (fun p : (Comp Œπ i ‚Üí ‚Ñù) √ó ‚Ñù => buildAlong (w := w) (i := i) p.1 p.2) :=
  (buildAlong_continuous (w := w) (i := i)).measurable

end meas

end CoordLine

/-- Pointwise-in-parameter 1D Stein identity along ONB coordinate `i`. -/
lemma stein_section_along_coord
  {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ‚Ñù H]
  [CompleteSpace H] [MeasurableSpace H] [BorelSpace H]
  {Œπ : Type*} [Fintype Œπ] [DecidableEq Œπ]
  (w : OrthonormalBasis Œπ ‚Ñù H) (i : Œπ)
  (F : H ‚Üí ‚Ñù) (hF_diff : ContDiff ‚Ñù 1 F)
  (hF_growth : PhysLean.Probability.GaussianIBP.HasModerateGrowth F)
  (vœÑ : ‚Ñù‚â•0)
  (y : CoordLine.Comp Œπ i ‚Üí ‚Ñù) :
  ‚à´ x, x * F (CoordLine.buildAlong (w := w) (i := i) y x) ‚àÇ(ProbabilityTheory.gaussianReal 0 vœÑ)
    = (vœÑ : ‚Ñù) * ‚à´ x, deriv (fun t => F (CoordLine.buildAlong (w := w) (i := i) y t)) x
        ‚àÇ(ProbabilityTheory.gaussianReal 0 vœÑ) :=
  gaussian_IBP_along_line (w := w) (i := i) (F := F) (hF_diff := hF_diff) (hF_growth := hF_growth) (y := y)

open ProductIBP CoordLine

/-- Core product-level Stein step (pulls the scalar `(vœÑ : ‚Ñù)` inside the integrand). -/
lemma stein_coord_on_product_core
  (w : OrthonormalBasis Œπ ‚Ñù H) (i : Œπ)
  (F : H ‚Üí ‚Ñù) (hF_diff : ContDiff ‚Ñù 1 F)
  (hF_growth : PhysLean.Probability.GaussianIBP.HasModerateGrowth F)
  (ŒºY : Measure (CoordLine.Comp Œπ i ‚Üí ‚Ñù))
  (vœÑ : ‚Ñù‚â•0)
  (hŒºY_sfinite : SFinite ŒºY)
  (hInt_left :
     Integrable (fun p : (CoordLine.Comp Œπ i ‚Üí ‚Ñù) √ó ‚Ñù =>
       p.2 * F (CoordLine.buildAlong (w := w) (i := i) p.1 p.2)) (ŒºY.prod (ProbabilityTheory.gaussianReal 0 vœÑ)))
  (hInt_right :
     Integrable (fun p : (CoordLine.Comp Œπ i ‚Üí ‚Ñù) √ó ‚Ñù =>
       (vœÑ : ‚Ñù) * deriv (fun t => F (CoordLine.buildAlong (w := w) (i := i) p.1 t)) p.2)
     (ŒºY.prod (ProbabilityTheory.gaussianReal 0 vœÑ))) :
  ‚à´ p, p.2 * F (CoordLine.buildAlong (w := w) (i := i) p.1 p.2) ‚àÇ(ŒºY.prod (ProbabilityTheory.gaussianReal 0 vœÑ))
    =
  ‚à´ p, (vœÑ : ‚Ñù) * deriv (fun t => F (CoordLine.buildAlong (w := w) (i := i) p.1 t)) p.2
    ‚àÇ(ŒºY.prod (ProbabilityTheory.gaussianReal 0 vœÑ)) := by
  let Œ≥ : Measure ‚Ñù := ProbabilityTheory.gaussianReal 0 vœÑ
  let œÜ : ((CoordLine.Comp Œπ i ‚Üí ‚Ñù) √ó ‚Ñù) ‚Üí ‚Ñù :=
    fun p => p.2 * F (CoordLine.buildAlong (w := w) (i := i) p.1 p.2)
  let œà : ((CoordLine.Comp Œπ i ‚Üí ‚Ñù) √ó ‚Ñù) ‚Üí ‚Ñù :=
    fun p => (vœÑ : ‚Ñù) * deriv (fun t => F (CoordLine.buildAlong (w := w) (i := i) p.1 t)) p.2
  have hSec : ‚àÄ y, ‚à´ x, œÜ (y, x) ‚àÇŒ≥ = ‚à´ x, œà (y, x) ‚àÇŒ≥ := by
    intro y
    simp [œÜ, œà]; erw [stein_section_along_coord (w := w) (i := i) (F := F) (hF_diff := hF_diff)
      (hF_growth := hF_growth) (vœÑ := vœÑ) (y := y)]
    rw [‚Üê stein_section_along_coord w i F hF_diff hF_growth vœÑ y]; rw [stein_section_along_coord
        w i F hF_diff hF_growth vœÑ y]; simp; rw [integral_const_mul]
  exact ProductIBP.integral_prod_of_section_eq (ŒºŒ± := ŒºY) (ŒºŒ≤ := Œ≥) (hŒ± := hŒºY_sfinite)
    (hŒ≤ := (instSFiniteOfSigmaFinite)) (hœÜ_int := hInt_left) (hœà_int := hInt_right) (hSec := hSec)

/-- Backwards-compatible wrapper: original signature (keeps `(vœÑ : ‚Ñù)` outside). -/
lemma stein_coord_on_product
  (w : OrthonormalBasis Œπ ‚Ñù H) (i : Œπ)
  (F : H ‚Üí ‚Ñù) (hF_diff : ContDiff ‚Ñù 1 F)
  (hF_growth : PhysLean.Probability.GaussianIBP.HasModerateGrowth F)
  (ŒºY : Measure (CoordLine.Comp Œπ i ‚Üí ‚Ñù))
  (vœÑ : ‚Ñù‚â•0)
  (hŒºY_sfinite : SFinite ŒºY)
  (hInt_left :
     Integrable
       (fun p : (CoordLine.Comp Œπ i ‚Üí ‚Ñù) √ó ‚Ñù =>
          p.2 * F (CoordLine.buildAlong (w := w) (i := i) p.1 p.2))
       (ŒºY.prod (ProbabilityTheory.gaussianReal 0 vœÑ)))
  (hInt_right‚ÇÄ :
     Integrable
       (fun p : (CoordLine.Comp Œπ i ‚Üí ‚Ñù) √ó ‚Ñù =>
          deriv (fun t => F (CoordLine.buildAlong (w := w) (i := i) p.1 t)) p.2)
       (ŒºY.prod (ProbabilityTheory.gaussianReal 0 vœÑ))) :
  ‚à´ p, p.2 * F (CoordLine.buildAlong (w := w) (i := i) p.1 p.2) ‚àÇ(ŒºY.prod (ProbabilityTheory.gaussianReal 0 vœÑ))
    =
  (vœÑ : ‚Ñù) * ‚à´ p, deriv (fun t => F (CoordLine.buildAlong (w := w) (i := i) p.1 t)) p.2
      ‚àÇ(ŒºY.prod (ProbabilityTheory.gaussianReal 0 vœÑ)) := by
  have hInt_right := hInt_right‚ÇÄ.const_mul (vœÑ : ‚Ñù)
  have hcore := stein_coord_on_product_core (w := w) (i := i) (F := F) (hF_diff := hF_diff)
    (hF_growth := hF_growth) (ŒºY := ŒºY) (vœÑ := vœÑ) (hŒºY_sfinite := hŒºY_sfinite)
    (hInt_left := hInt_left) (hInt_right := hInt_right)
  calc
      ‚à´ p, p.2 * F (CoordLine.buildAlong (w := w) (i := i) p.1 p.2)
        ‚àÇ(ŒºY.prod (ProbabilityTheory.gaussianReal 0 vœÑ))
        =
      ‚à´ p, (vœÑ : ‚Ñù) * deriv
          (fun t => F (CoordLine.buildAlong (w := w) (i := i) p.1 t)) p.2
        ‚àÇ(ŒºY.prod (ProbabilityTheory.gaussianReal 0 vœÑ)) := hcore
    _ =
      (vœÑ : ‚Ñù) *
      ‚à´ p, deriv (fun t => F (CoordLine.buildAlong (w := w) (i := i) p.1 t)) p.2
        ‚àÇ(ŒºY.prod (ProbabilityTheory.gaussianReal 0 vœÑ)) := by
      simp [integral_const_mul]

namespace ProbabilityTheory

open MeasureTheory Set

variable {Œ© Œπ : Type*} [MeasurableSpace Œ©] {Œº : Measure Œ©}
variable {Œ± : Œπ ‚Üí Type*} [‚àÄ i, MeasurableSpace (Œ± i)]

/-- If, for a measurable map `f : Œ© ‚Üí Œ† i, Œ± i`, each coordinate has Dirac law at `c i`,
then the law of `f` is the Dirac mass at the whole point `c`.

Hypotheses:
- `Œº` is a probability measure;
- the index type `Œπ` is countable (in particular, this includes finite index sets);
- each `Œ± i` has measurable singletons;
- `f` is (globally) measurable;
- for each `i`, the pushforward of the coordinate `œâ ‚Ü¶ f œâ i` is `dirac (c i)`.

Conclusion:
`map f Œº = dirac c`. -/
lemma map_fun_dirac_of_coord_dirac
    [IsProbabilityMeasure Œº] [Countable Œπ]
    [‚àÄ i, MeasurableSingletonClass (Œ± i)]
    {f : Œ© ‚Üí (‚àÄ i, Œ± i)} {c : ‚àÄ i, Œ± i}
    (hf : Measurable f)
    (hcoord : ‚àÄ i, Measure.map (fun œâ => f œâ i) Œº = Measure.dirac (c i)) :
    Measure.map f Œº = Measure.dirac c := by
  classical
  have hAE_coord : ‚àÄ i, ‚àÄ·µê œâ ‚àÇ Œº, f œâ i = c i := by
    intro i
    have hfi : Measurable (fun œâ => f œâ i) := (measurable_pi_apply i).comp hf
    have h1 : (Measure.map (fun œâ => f œâ i) Œº) {c i} = 1 := by
      simpa using (by
        have := hcoord i
        simpa using congrArg (fun (m : Measure (Œ± i)) => m {c i}) this)
    have : Œº ((fun œâ => f œâ i) ‚Åª¬π' {c i}) = 1 := by
      have hmap :
          (Measure.map (fun œâ => f œâ i) Œº) {c i}
            = Œº ((fun œâ => f œâ i) ‚Åª¬π' {c i}) :=
        Measure.map_apply (Œº := Œº) (f := fun œâ => f œâ i) (s := {c i})
          hfi (measurableSet_singleton (c i))
      simpa [hmap] using h1
    have hcompl0 : Œº (((fun œâ => f œâ i) ‚Åª¬π' {c i})·∂ú) = 0 := by
      have : MeasurableSet ((fun œâ => f œâ i) ‚Åª¬π' {c i}) :=
        hfi (measurableSet_singleton _)
      aesop
    exact (ae_iff.mpr hcompl0).mono (by intro œâ hœâ; simpa using hœâ)
  have hAE_all : ‚àÄ·µê œâ ‚àÇ Œº, ‚àÄ i, f œâ i = c i := by
    simpa using (ae_all_iff.mpr hAE_coord)
  have hAE_funext : f =·µê[Œº] fun _ => c := by
    refine hAE_all.mono ?_
    intro œâ hœâ; funext i; exact hœâ i
  ext s hs
  have hconst : Measurable fun (_ : Œ©) => c := by
    simp
  have hf_map : (Measure.map f Œº) s = Œº (f ‚Åª¬π' s) := Measure.map_apply hf hs
  have hconst_map : (Measure.map (fun (_ : Œ©) => c) Œº) s
      = Œº ((fun _ => c) ‚Åª¬π' s) := Measure.map_apply hconst hs
  have h_sets_ae :
      {œâ | f œâ ‚àà s} =·µê[Œº] {œâ | (fun _ => c) œâ ‚àà s} :=
    hAE_funext.mono (by
      intro œâ hœâ; aesop)
  have h_eq_measure : Œº (f ‚Åª¬π' s) = Œº ((fun _ => c) ‚Åª¬π' s) := by
    exact measure_congr h_sets_ae
  simpa [hf_map, hconst_map] using
    show (Measure.map f Œº) s = (Measure.map (fun _ => c) Œº) s from by
      aesop
  --done

end ProbabilityTheory

section Gauss1D_helpers

namespace ProbabilityTheory

/-- Under a centered real Gaussian law, `(1 + |x|)^n` is integrable for all `n`. -/
lemma integrable_one_add_abs_pow_nat_gaussian
    (v : ‚Ñù‚â•0) (n : ‚Ñï) :
    Integrable (fun x : ‚Ñù => (1 + |x|) ^ n) (ProbabilityTheory.gaussianReal 0 v) := by
  classical
  cases n with
  | zero =>
      simp
  | succ k =>
    have hdom :
        ‚àÄ x : ‚Ñù, (1 + |x|) ^ (Nat.succ k)
          ‚â§ (2 : ‚Ñù) ^ (Nat.succ k - 1) * (1 + |x| ^ (Nat.succ k)) := by
      intro x
      have := Real.add_pow_le_two_pow_mul_add_pow
        (a := 1) (b := |x|) (n := Nat.succ k)
        (ha := by norm_num) (hb := by exact abs_nonneg x)
        (hn := Nat.succ_le_succ (Nat.zero_le k))
      simpa [one_pow] using this
    have h_meas : AEStronglyMeasurable
        (fun x : ‚Ñù => (1 + |x|) ^ (Nat.succ k)) (ProbabilityTheory.gaussianReal 0 v) := by
      have hcont : Continuous (fun x : ‚Ñù => (1 + |x|) ^ (Nat.succ k)) :=
        (continuous_const.add continuous_abs).pow _
      simpa using hcont.measurable.aestronglyMeasurable
    have h_rhs_int :
        Integrable (fun x : ‚Ñù => (2 : ‚Ñù) ^ (Nat.succ k - 1) * (1 + |x| ^ (Nat.succ k)))
          (ProbabilityTheory.gaussianReal 0 v) := by
      have h1 : Integrable (fun _ : ‚Ñù => (2 : ‚Ñù) ^ (Nat.succ k - 1))
            (ProbabilityTheory.gaussianReal 0 v) := by
        simp
      have h2 : Integrable (fun x : ‚Ñù => |x| ^ (Nat.succ k))
            (ProbabilityTheory.gaussianReal 0 v) :=
        integrable_abs_pow_gaussianReal_centered_nat (v := v) (k := Nat.succ k)
      have : Integrable
          (fun x : ‚Ñù =>
            (2 : ‚Ñù) ^ (Nat.succ k - 1) + (2 : ‚Ñù) ^ (Nat.succ k - 1) * |x| ^ (Nat.succ k))
          (ProbabilityTheory.gaussianReal 0 v) :=
        h1.add (h2.const_mul _)
      simpa [mul_add, mul_one] using this
    refine h_rhs_int.mono' h_meas (ae_of_all _ (fun x => ?_))
    have hL : 0 ‚â§ (1 + |x|) ^ (Nat.succ k) :=
      pow_nonneg (by linarith [abs_nonneg x]) _
    calc
      ‚Äñ(1 + |x|) ^ (Nat.succ k)‚Äñ
          = (1 + |x|) ^ (Nat.succ k) := by rw [Real.norm_of_nonneg hL]
      _ ‚â§ (2 : ‚Ñù) ^ (Nat.succ k - 1) * (1 + |x| ^ (Nat.succ k)) := hdom x

end ProbabilityTheory
end Gauss1D_helpers

section AlongLine_integrability

open ProbabilityTheory

variable {Œπ : Type*} [Fintype Œπ] [DecidableEq Œπ]
variable (w : OrthonormalBasis Œπ ‚Ñù H) (i : Œπ)

omit [CompleteSpace H] [MeasurableSpace H] [BorelSpace H] [DecidableEq Œπ] in
/-- 1D along-line integrability (value): `x ‚Ü¶ x ¬∑ F(z + x ‚Ä¢ w i)` is `L¬π(gauss)`. -/
lemma integrable_along_line_mul_gauss
    (F : H ‚Üí ‚Ñù) (hF_diff : ContDiff ‚Ñù 1 F)
    (hF_growth : HasModerateGrowth F)
    (z : H) (v : ‚Ñù‚â•0) :
    Integrable (fun x : ‚Ñù => x * F (z + x ‚Ä¢ w i)) (ProbabilityTheory.gaussianReal 0 v) := by
  classical
  have hMG1D : ProbabilityTheory.HasModerateGrowth (fun x : ‚Ñù => F (z + x ‚Ä¢ w i)) :=
    CoordLine.moderateGrowth_along (w := w) (i := i)
      (F := F) (hF_diff := hF_diff) (hMG := hF_growth) z
  have h_meas : AEStronglyMeasurable
      (fun x : ‚Ñù => x * F (z + x ‚Ä¢ w i)) (ProbabilityTheory.gaussianReal 0 v) := by
    have hArg : Continuous (fun x : ‚Ñù => z + (CoordLine.lineCLM (w := w) (i := i)) x) :=
      continuous_const.add (CoordLine.lineCLM (w := w) (i := i)).continuous
    have hcont : Continuous (fun x : ‚Ñù => F (z + x ‚Ä¢ w i)) :=
      hF_diff.continuous.comp hArg
    exact (measurable_id.aestronglyMeasurable.mul hcont.measurable.aestronglyMeasurable)
  have h_dom :
      ‚àÄ x, |x * F (z + x ‚Ä¢ w i)| ‚â§
        (hF_growth.C * (1 + ‚Äñz‚Äñ + ‚ÄñCoordLine.lineCLM (w := w) (i := i)‚Äñ) ^ hF_growth.m)
        * (|x| * (1 + |x|) ^ hF_growth.m) := by
    intro x
    have hv :=
      CoordLine.AffineModerateGrowth.growth_bound_comp_affine_real_value
        (hMG := hF_growth) (z := z) (L := CoordLine.lineCLM (w := w) (i := i)) x
    have hLnorm : ‚ÄñCoordLine.lineCLM (w := w) (i := i)‚Äñ = ‚Äñw i‚Äñ := by
      simp [CoordLine.lineCLM]
    have hRew : 1 + ‚Äñz‚Äñ + ‚ÄñCoordLine.lineCLM (w := w) (i := i)‚Äñ
              = 1 + ‚Äñz‚Äñ + ‚Äñw i‚Äñ := by simp [hLnorm]
    have hv' := hv.trans (by
      have hC : hF_growth.C * (1 + ‚Äñz‚Äñ + ‚ÄñCoordLine.lineCLM (w := w) (i := i)‚Äñ) ^ hF_growth.m
                ‚â§ hF_growth.C * (1 + ‚Äñz‚Äñ + ‚Äñw i‚Äñ) ^ hF_growth.m := by
        simp [hRew]
      have hx : 0 ‚â§ (1 + |x|) ^ hF_growth.m := by
        exact pow_nonneg (by linarith [abs_nonneg x]) _
      exact mul_le_mul_of_nonneg_right hC hx)
    have hv'' :
        |x * F (z + x ‚Ä¢ w i)|
          ‚â§ |x| * (hF_growth.C * (1 + ‚Äñz‚Äñ + ‚Äñw i‚Äñ) ^ hF_growth.m) * (1 + |x|) ^ hF_growth.m := by
      have := mul_le_mul_of_nonneg_left hv' (by exact abs_nonneg x)
      simpa [mul_comm, mul_left_comm, mul_assoc, abs_mul] using this
    have hnormwi : ‚Äñw i‚Äñ = (1 : ‚Ñù) := by simp
    have hConstRew :
        |x| * (hF_growth.C * (1 + ‚Äñz‚Äñ + ‚Äñw i‚Äñ) ^ hF_growth.m)
              * (1 + |x|) ^ hF_growth.m
          = (hF_growth.C * (1 + ‚Äñz‚Äñ + 1) ^ hF_growth.m) * (|x| * (1 + |x|) ^ hF_growth.m) := by
      have hstep :
          hF_growth.C * (1 + ‚Äñz‚Äñ + ‚Äñw i‚Äñ) ^ hF_growth.m
            = hF_growth.C * (1 + ‚Äñz‚Äñ + 1) ^ hF_growth.m := by
        simp [hnormwi]
      simp [hstep, mul_comm, mul_left_comm, mul_assoc]
    have hv''' :
        |x * F (z + x ‚Ä¢ w i)|
          ‚â§ (hF_growth.C * (1 + ‚Äñz‚Äñ + 1) ^ hF_growth.m) * (|x| * (1 + |x|) ^ hF_growth.m) := by
      aesop
    aesop
  have h_int_mplus1 :
      Integrable (fun x : ‚Ñù => (1 + |x|) ^ (hF_growth.m + 1))
        (ProbabilityTheory.gaussianReal 0 v) :=
    (ProbabilityTheory.integrable_one_add_abs_pow_nat_gaussian (v := v) (n := hF_growth.m + 1))
  have h_meas_rhs :
      AEStronglyMeasurable (fun x : ‚Ñù => |x| * (1 + |x|) ^ hF_growth.m)
        (ProbabilityTheory.gaussianReal 0 v) := by
    have hcont : Continuous (fun x : ‚Ñù => |x| * (1 + |x|) ^ hF_growth.m) :=
      continuous_abs.mul ((continuous_const.add continuous_abs).pow _)
    simpa using hcont.measurable.aestronglyMeasurable
  have h_base_int :
      Integrable (fun x : ‚Ñù => |x| * (1 + |x|) ^ hF_growth.m)
        (ProbabilityTheory.gaussianReal 0 v) := by
    refine h_int_mplus1.mono' h_meas_rhs (ae_of_all _ (fun x => ?_))
    have hx_pow_nonneg : 0 ‚â§ (1 + |x|) ^ hF_growth.m :=
      pow_nonneg (by linarith [abs_nonneg x]) _
    have hnonneg : 0 ‚â§ |x| * (1 + |x|) ^ hF_growth.m :=
      mul_nonneg (abs_nonneg _) hx_pow_nonneg
    have hx_le : |x| ‚â§ 1 + |x| := by linarith [abs_nonneg x]
    have hstep :
        |x| * (1 + |x|) ^ hF_growth.m
          ‚â§ (1 + |x|) * (1 + |x|) ^ hF_growth.m :=
      mul_le_mul_of_nonneg_right hx_le hx_pow_nonneg
    have habs : |(1 + |x|)| = 1 + |x| := by
      have : 0 ‚â§ 1 + |x| := by linarith [abs_nonneg x]
      simp [abs_of_nonneg this]
    have hx_pow_nonneg' : 0 ‚â§ |(1 + |x|)| ^ hF_growth.m :=
      pow_nonneg (abs_nonneg (1 + |x|)) _
    have hstep' :
        |x| * |(1 + |x|)| ^ hF_growth.m
          ‚â§ |(1 + |x|)| ^ (hF_growth.m + 1) := by
      have hx_le' : |x| ‚â§ |(1 + |x|)| := by simp [habs]
      have := mul_le_mul_of_nonneg_right hx_le' hx_pow_nonneg'
      simpa [pow_succ, mul_comm, mul_left_comm, mul_assoc] using this
    have : ‚Äñ|x| * (1 + |x|) ^ hF_growth.m‚Äñ
            ‚â§ (1 + |x|) ^ (hF_growth.m + 1) := by
      have hnonneg' : 0 ‚â§ |x| * |(1 + |x|)| ^ hF_growth.m :=
        mul_nonneg (abs_nonneg _) hx_pow_nonneg'
      simpa [Real.norm_eq_abs, abs_of_nonneg hnonneg', habs] using hstep'
    exact this
  have h_rhs_int :
      Integrable
        (fun x : ‚Ñù =>
          (hF_growth.C * (1 + ‚Äñz‚Äñ + 1) ^ hF_growth.m) * (|x| * (1 + |x|) ^ hF_growth.m))
        (ProbabilityTheory.gaussianReal 0 v) :=
    h_base_int.const_mul _
  exact h_rhs_int.mono' h_meas (ae_of_all _ (fun x => by
    have hR : 0 ‚â§
        (hF_growth.C * (1 + ‚Äñz‚Äñ + 1) ^ hF_growth.m) * (|x| * (1 + |x|) ^ hF_growth.m) := by
      have hx : 0 ‚â§ (|x| * (1 + |x|) ^ hF_growth.m) :=
        mul_nonneg (abs_nonneg _) (pow_nonneg (by linarith [abs_nonneg x]) _)
      have hK : 0 ‚â§ (hF_growth.C * (1 + ‚Äñz‚Äñ + 1) ^ hF_growth.m) :=
        mul_nonneg (le_of_lt hF_growth.Cpos)
          (pow_nonneg (by nlinarith [norm_nonneg z]) _)
      exact mul_nonneg hK hx
    simpa [Real.norm_eq_abs, abs_mul] using h_dom x))

omit [CompleteSpace H] [MeasurableSpace H] [BorelSpace H] [DecidableEq Œπ] in
/-- 1D along-line integrability (derivative). -/
lemma integrable_along_line_deriv_gauss
    (F : H ‚Üí ‚Ñù) (hF_diff : ContDiff ‚Ñù 1 F)
    (hF_growth : HasModerateGrowth F)
    (z : H) (v : ‚Ñù‚â•0) :
    Integrable (fun x : ‚Ñù =>
      deriv (fun t => F (z + t ‚Ä¢ w i)) x) (ProbabilityTheory.gaussianReal 0 v) := by
  classical
  have hF1D : ContDiff ‚Ñù 1 (fun x : ‚Ñù => F (z + (CoordLine.lineCLM (w := w) (i := i)) x)) :=
    hF_diff.comp (contDiff_const.add (CoordLine.lineCLM (w := w) (i := i)).contDiff)
  have h_meas :
      AEStronglyMeasurable
        (fun x : ‚Ñù => deriv (fun t => F (z + t ‚Ä¢ w i)) x)
        (ProbabilityTheory.gaussianReal 0 v) := by
    measurability
  have h_dom :
      ‚àÄ x, |deriv (fun t => F (z + t ‚Ä¢ w i)) x|
        ‚â§ (hF_growth.C * (1 + ‚Äñz‚Äñ + ‚ÄñCoordLine.lineCLM (w := w) (i := i)‚Äñ) ^ hF_growth.m
              * (1 + ‚ÄñCoordLine.lineCLM (w := w) (i := i)‚Äñ))
          * ((1 + |x|) ^ hF_growth.m) := by
    intro x
    have hbound :=
      CoordLine.AffineModerateGrowth.growth_bound_comp_affine_real_deriv
        (hF_diff := hF_diff) (hMG := hF_growth) (z := z) (L := CoordLine.lineCLM (w := w) (i := i)) x
    have hLnorm : ‚ÄñCoordLine.lineCLM (w := w) (i := i)‚Äñ = ‚Äñw i‚Äñ := by
      simp [CoordLine.lineCLM]
    have hw1 : ‚Äñw i‚Äñ = (1 : ‚Ñù) := by simp
    simpa [hLnorm, hw1, mul_comm, mul_left_comm, mul_assoc] using hbound
  have h_base : Integrable (fun x : ‚Ñù => (1 + |x|) ^ hF_growth.m)
        (ProbabilityTheory.gaussianReal 0 v) :=
    ProbabilityTheory.integrable_one_add_abs_pow_nat_gaussian (v := v) (n := hF_growth.m)
  have h_rhs_int :
      Integrable
        (fun x : ‚Ñù =>
          (hF_growth.C * (1 + ‚Äñz‚Äñ + ‚ÄñCoordLine.lineCLM (w := w) (i := i)‚Äñ) ^ hF_growth.m
              * (1 + ‚ÄñCoordLine.lineCLM (w := w) (i := i)‚Äñ))
            * ((1 + |x|) ^ hF_growth.m))
        (ProbabilityTheory.gaussianReal 0 v) :=
    h_base.const_mul _
  exact h_rhs_int.mono' h_meas (ae_of_all _ (fun x => by
    simpa [Real.norm_eq_abs] using h_dom x))

end AlongLine_integrability

namespace MeasureTheory

variable {Œ± : Type*} [MeasurableSpace Œ±]
variable {E : Type*} [NormedAddCommGroup E]
variable {Œº : Measure Œ±}

/-- If `f =·µê[Œº] g`, then `Integrable f Œº ‚Üî Integrable g Œº`. -/
lemma integrable_congr_ae {f g : Œ± ‚Üí E} (hfg : f =·µê[Œº] g) :
    Integrable f Œº ‚Üî Integrable g Œº := by
  classical
  constructor
  ¬∑ intro hf
    refine ‚ü®hf.aestronglyMeasurable.congr hfg, ?_‚ü©
    have hnn : (fun x => (‚Äñg x‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) =·µê[Œº]
                (fun x => (‚Äñf x‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) := by
      refine hfg.mono ?_
      intro x hx; simp [hx]
    have hlin : ‚à´‚Åª x, ‚Äñg x‚Äñ‚Çä ‚àÇŒº = ‚à´‚Åª x, ‚Äñf x‚Äñ‚Çä ‚àÇŒº := by
      simpa using lintegral_congr_ae hnn
    rw [propext (hasFiniteIntegral_congr (id (EventuallyEq.symm hfg)))]
    exact hf.hasFiniteIntegral
  ¬∑ intro hg
    refine ‚ü®hg.aestronglyMeasurable.congr hfg.symm, ?_‚ü©
    have hnn : (fun x => (‚Äñf x‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) =·µê[Œº]
                (fun x => (‚Äñg x‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) := by
      refine hfg.mono ?_
      intro x hx; simp [hx]
    have hlin : ‚à´‚Åª x, ‚Äñf x‚Äñ‚Çä ‚àÇŒº = ‚à´‚Åª x, ‚Äñg x‚Äñ‚Çä ‚àÇŒº := by
      simpa using lintegral_congr_ae hnn
    rw [propext (hasFiniteIntegral_congr hfg)]
    simpa [hlin] using hg.hasFiniteIntegral

end MeasureTheory

section Pullback_to_Omega

open ProbabilityTheory MeasureTheory

variable {Œπ : Type*} [Fintype Œπ] [DecidableEq Œπ]
variable (w : OrthonormalBasis Œπ ‚Ñù H) (i : Œπ)

omit [CompleteSpace H] [MeasurableSpace H] [BorelSpace H] in
/-- If `X` has centered Gaussian law and `Y =·µê const y‚ÇÄ`, then
`œâ ‚Ü¶ X œâ ¬∑ F(buildAlong w i (Y œâ) (X œâ))` is integrable. -/
lemma integrable_coord_mul_F_of_gauss_and_aeConstY
    {Œ© : Type*} [MeasureSpace Œ©] (Œº : Measure Œ©)
    (F : H ‚Üí ‚Ñù) (hF_diff : ContDiff ‚Ñù 1 F)
    (hF_growth : HasModerateGrowth F)
    (vœÑ : ‚Ñù‚â•0)
    (X : Œ© ‚Üí ‚Ñù) (hX_meas : Measurable X)
    (hX_gauss : Measure.map X Œº = ProbabilityTheory.gaussianReal 0 vœÑ)
    (Y : Œ© ‚Üí (CoordLine.Comp Œπ i ‚Üí ‚Ñù)) {y0 : (CoordLine.Comp Œπ i ‚Üí ‚Ñù)}
    (hY_ae : Y =·µê[Œº] fun _ => y0) :
    Integrable (fun œâ => X œâ * F ( CoordLine.buildAlong (w := w) (i := i) (Y œâ) (X œâ) )) Œº := by
  classical
  have hae :
      (fun œâ => X œâ * F (CoordLine.buildAlong (w := w) (i := i) (Y œâ) (X œâ)))
        =·µê[Œº]
      (fun œâ => X œâ * F (CoordLine.buildAlong (w := w) (i := i) y0 (X œâ))) := by
    refine hY_ae.mono ?_
    intro œâ hœâ
    simp [hœâ]
  let z0 : H := ‚àë j : CoordLine.Comp Œπ i, (y0 j) ‚Ä¢ w j.1
  have hint_gauss :
      Integrable (fun x : ‚Ñù => x * F (z0 + x ‚Ä¢ w i))
        (ProbabilityTheory.gaussianReal 0 vœÑ) :=
    integrable_along_line_mul_gauss (w := w) (i := i) (F := F)
      (hF_diff := hF_diff) (hF_growth := hF_growth) (z := z0) (v := vœÑ)
  have : Integrable
      (fun œâ => X œâ * F (CoordLine.buildAlong (w := w) (i := i) y0 (X œâ))) Œº := by
    have hmap_int :
        Integrable (fun x : ‚Ñù => x * F (z0 + x ‚Ä¢ w i)) (Measure.map X Œº) := by
      simpa [hX_gauss] using hint_gauss
    simpa [CoordLine.buildAlong, z0, add_comm, add_left_comm, add_assoc] using
      hmap_int.comp_measurable hX_meas
  exact (integrable_congr_ae hae).2 this

omit [CompleteSpace H] [MeasurableSpace H] [BorelSpace H] in
/-- If `X` has centered Gaussian law and `Y =·µê const y‚ÇÄ`, then
`œâ ‚Ü¶ deriv (t ‚Ü¶ F(buildAlong w i (Y œâ) t)) (X œâ)` is integrable. -/
lemma integrable_deriv_F_along_coord_of_gauss_and_aeConstY
    {Œ© : Type*} [MeasureSpace Œ©] (Œº : Measure Œ©)
    (F : H ‚Üí ‚Ñù) (hF_diff : ContDiff ‚Ñù 1 F)
    (hF_growth : HasModerateGrowth F)
    (vœÑ : ‚Ñù‚â•0)
    (X : Œ© ‚Üí ‚Ñù) (hX_meas : Measurable X)
    (hX_gauss : Measure.map X Œº = ProbabilityTheory.gaussianReal 0 vœÑ)
    (Y : Œ© ‚Üí (CoordLine.Comp Œπ i ‚Üí ‚Ñù)) {y0 : (CoordLine.Comp Œπ i ‚Üí ‚Ñù)}
    (hY_ae : Y =·µê[Œº] fun _ => y0) :
    Integrable (fun œâ =>
      deriv (fun t => F (CoordLine.buildAlong (w := w) (i := i) (Y œâ) t)) (X œâ)) Œº := by
  classical
  have hae : (fun œâ =>
      deriv (fun t => F (CoordLine.buildAlong (w := w) (i := i) (Y œâ) t)) (X œâ))
      =·µê[Œº]
      (fun œâ =>
      deriv (fun t => F (CoordLine.buildAlong (w := w) (i := i) y0 t)) (X œâ)) := by
    refine hY_ae.mono ?_
    intro œâ hœâ
    simp [hœâ]
  let z0 : H := ‚àë j : CoordLine.Comp Œπ i, (y0 j) ‚Ä¢ w j.1
  have hint_gauss :
      Integrable (fun x : ‚Ñù =>
        deriv (fun t => F (z0 + t ‚Ä¢ w i)) x) (ProbabilityTheory.gaussianReal 0 vœÑ) :=
    integrable_along_line_deriv_gauss (w := w) (i := i) (F := F)
      (hF_diff := hF_diff) (hF_growth := hF_growth) (z := z0) (v := vœÑ)
  have : Integrable (fun œâ =>
      deriv (fun t => F (CoordLine.buildAlong (w := w) (i := i) y0 t)) (X œâ)) Œº := by
    have hmap_int :
        Integrable (fun x : ‚Ñù =>
          deriv (fun t => F (z0 + t ‚Ä¢ w i)) x) (Measure.map X Œº) := by
      simpa [hX_gauss] using hint_gauss
    simpa [CoordLine.buildAlong, z0, add_comm, add_left_comm, add_assoc] using
      hmap_int.comp_measurable hX_meas
  exact (integrable_congr_ae hae).2 this

end Pullback_to_Omega

section AEconst_helper

open ProbabilityTheory

/-- If each coordinate of `Y` (to `Comp Œπ i ‚Üí ‚Ñù`) has pushforward law `gaussianReal 0 0`
with respect to `Œº` (i.e. Dirac at `0`), then `Y =·µê[Œº] const 0`. -/
lemma ae_const_zero_of_coord_gauss0
    {Œ© : Type*} [MeasureSpace Œ©] (Œº : Measure Œ©)
    {Œπ : Type*} [Fintype Œπ] [DecidableEq Œπ] (i : Œπ)
    (Y : Œ© ‚Üí (CoordLine.Comp Œπ i ‚Üí ‚Ñù)) (hY_meas : Measurable Y)
    (hY_gauss0 : ‚àÄ j, Measure.map (fun œâ => Y œâ j) Œº = ProbabilityTheory.gaussianReal 0 0) :
    Y =·µê[Œº] (fun _ => (fun _ => (0 : ‚Ñù))) := by
  classical
  have hAEcoord : ‚àÄ j, ‚àÄ·µê œâ ‚àÇ Œº, Y œâ j = 0 := by
    intro j
    have hmap : Measure.map (fun œâ => Y œâ j) Œº
                = ProbabilityTheory.gaussianReal 0 0 := hY_gauss0 j
    have hmeasj : Measurable (fun œâ => Y œâ j) :=
      (measurable_pi_apply j).comp hY_meas
    have hdirac : ProbabilityTheory.gaussianReal 0 0 = Measure.dirac (0 : ‚Ñù) := by
      simp
    have hcompl0 :
        Œº (((fun œâ => Y œâ j) ‚Åª¬π' {0})·∂ú) = 0 := by
      have hs : MeasurableSet (({0} : Set ‚Ñù)·∂ú) :=
        (measurableSet_singleton (0 : ‚Ñù)).compl
      have hmap_apply :
          (Measure.map (fun œâ => Y œâ j) Œº) (({0} : Set ‚Ñù)·∂ú)
            = Œº (((fun œâ => Y œâ j) ‚Åª¬π' (({0} : Set ‚Ñù)·∂ú))) := by
        simpa using
          (Measure.map_apply (Œº := Œº) (f := fun œâ => Y œâ j) (s := (({0} : Set ‚Ñù)·∂ú))
            hmeasj hs)
      have hpush0 :
          (Measure.map (fun œâ => Y œâ j) Œº) (({0} : Set ‚Ñù)·∂ú) = 0 := by
        classical
        simp [hmap, hdirac]
      have : Œº (((fun œâ => Y œâ j) ‚Åª¬π' (({0} : Set ‚Ñù)·∂ú))) = 0 := by
        simpa [hmap_apply] using hpush0
      simpa using this
    exact (ae_iff.mpr hcompl0).mono (by intro œâ hœâ; simpa using hœâ)
  have : ‚àÄ·µê œâ ‚àÇ Œº, ‚àÄ j, Y œâ j = 0 := by
    refine ae_all_iff.2 (by intro j; exact hAEcoord j)
  exact this.mono (by intro œâ hœâ; funext j; exact hœâ j)

end AEconst_helper

section Wrappers_old_names

open ProbabilityTheory

variable {Œ© : Type*} [MeasureSpace Œ©] [IsProbabilityMeasure (‚Ñô : Measure Œ©)]
variable {Œπ : Type*} [Fintype Œπ] [DecidableEq Œπ]

omit [CompleteSpace H] [MeasurableSpace H] [BorelSpace H] [IsProbabilityMeasure (‚Ñô : Measure Œ©)] in
/-- Wrapper (old name): integrability of `X ¬∑ F(buildAlong (Y,X))` under independence,
using the a.e.-const helper for zero-variance coordinates. -/
lemma integrable_coord_mul_F_of_indep
    (w : OrthonormalBasis Œπ ‚Ñù H) (i : Œπ)
    (F : H ‚Üí ‚Ñù) (hF_diff : ContDiff ‚Ñù 1 F)
    (hF_growth : HasModerateGrowth F)
    (vœÑ : ‚Ñù‚â•0)
    (X : Œ© ‚Üí ‚Ñù) (Y : Œ© ‚Üí (CoordLine.Comp Œπ i ‚Üí ‚Ñù))
    (hX_meas : Measurable X) (hY_meas : Measurable Y)
    (_hIndep : ProbabilityTheory.IndepFun Y X ‚Ñô)
    (hX_gauss : ProbabilityTheory.IsCenteredGaussianRV X vœÑ)
    (hY_gauss0 : ‚àÄ j, ProbabilityTheory.IsCenteredGaussianRV (fun œâ => Y œâ j) 0) :
    Integrable (fun œâ => X œâ * F (CoordLine.buildAlong (w := w) (i := i) (Y œâ) (X œâ))) ‚Ñô := by
  classical
  have hYpush :
      ‚àÄ j, Measure.map (fun œâ => Y œâ j) (‚Ñô : Measure Œ©)
            = ProbabilityTheory.gaussianReal 0 0 := by
    intro j
    simpa [ProbabilityTheory.IsCenteredGaussianRV, ProbabilityTheory.IsGaussianRV] using hY_gauss0 j
  have hYae : Y =·µê[‚Ñô] fun _ => (fun _ => (0 : ‚Ñù)) :=
    ae_const_zero_of_coord_gauss0 (Œº := (‚Ñô : Measure Œ©))
      (i := i) (Y := Y) (hY_meas := hY_meas) (hY_gauss0 := hYpush)
  have hXlaw : Measure.map X ‚Ñô = ProbabilityTheory.gaussianReal 0 vœÑ := by
    simpa [ProbabilityTheory.IsCenteredGaussianRV, ProbabilityTheory.IsGaussianRV] using hX_gauss
  simpa using
    integrable_coord_mul_F_of_gauss_and_aeConstY
      (w := w) (i := i) (Œº := (‚Ñô : Measure Œ©))
      (F := F) (hF_diff := hF_diff) (hF_growth := hF_growth)
      (vœÑ := vœÑ) (X := X) (hX_meas := hX_meas) (hX_gauss := hXlaw)
      (Y := Y) (y0 := fun _ => 0) (hY_ae := hYae)

omit [CompleteSpace H] [MeasurableSpace H] [BorelSpace H] [IsProbabilityMeasure (‚Ñô : Measure Œ©)] in
/-- Wrapper (old name): integrability of the derivative along the coordinate line under independence. -/
lemma integrable_deriv_F_along_coord_of_indep
    (w : OrthonormalBasis Œπ ‚Ñù H) (i : Œπ)
    (F : H ‚Üí ‚Ñù) (hF_diff : ContDiff ‚Ñù 1 F)
    (hF_growth : HasModerateGrowth F)
    (vœÑ : ‚Ñù‚â•0)
    (X : Œ© ‚Üí ‚Ñù) (Y : Œ© ‚Üí (CoordLine.Comp Œπ i ‚Üí ‚Ñù))
    (hX_meas : Measurable X) (hY_meas : Measurable Y)
    (_hIndep : ProbabilityTheory.IndepFun Y X ‚Ñô)
    (hX_gauss : ProbabilityTheory.IsCenteredGaussianRV X vœÑ)
    (hY_gauss0 : ‚àÄ j, ProbabilityTheory.IsCenteredGaussianRV (fun œâ => Y œâ j) 0) :
    Integrable (fun œâ =>
      deriv (fun t => F (CoordLine.buildAlong (w := w) (i := i) (Y œâ) t)) (X œâ)) ‚Ñô := by
  classical
  -- Y is a.e. zero
  have hYpush :
      ‚àÄ j, Measure.map (fun œâ => Y œâ j) (‚Ñô : Measure Œ©)
            = ProbabilityTheory.gaussianReal 0 0 := by
    intro j
    simpa [ProbabilityTheory.IsCenteredGaussianRV, ProbabilityTheory.IsGaussianRV] using hY_gauss0 j
  have hYae : Y =·µê[‚Ñô] fun _ => (fun _ => (0 : ‚Ñù)) :=
    ae_const_zero_of_coord_gauss0 (Œº := (‚Ñô : Measure Œ©))
      (i := i) (Y := Y) (hY_meas := hY_meas) (hY_gauss0 := hYpush)
  have hXlaw : Measure.map X ‚Ñô = ProbabilityTheory.gaussianReal 0 vœÑ := by
    simpa [ProbabilityTheory.IsCenteredGaussianRV, ProbabilityTheory.IsGaussianRV] using hX_gauss
  simpa using
    integrable_deriv_F_along_coord_of_gauss_and_aeConstY
      (w := w) (i := i) (Œº := (‚Ñô : Measure Œ©))
      (F := F) (hF_diff := hF_diff) (hF_growth := hF_growth)
      (vœÑ := vœÑ) (X := X) (hX_meas := hX_meas) (hX_gauss := hXlaw)
      (Y := Y) (y0 := fun _ => 0) (hY_ae := hYae)

end Wrappers_old_names
open ProbabilityTheory MeasureTheory

/-- If a real-valued map `X` is a.e. equal to the constant `0` under a probability measure `Œº`,
then its pushforward law is the Dirac mass at `0`. Requires measurability of `X`. -/
lemma map_eq_dirac_of_ae_eq_const_zero
    {Œ© : Type*} [MeasureSpace Œ©] {Œº : Measure Œ©} [IsProbabilityMeasure Œº]
    {X : Œ© ‚Üí ‚Ñù} (hX_meas : Measurable X)
    (hConst : X =·µê[Œº] fun _ => (0 : ‚Ñù)) :
    Measure.map X Œº = Measure.dirac (0 : ‚Ñù) := by
  classical
  ext s hs
  have hmapX : (Measure.map X Œº) s = Œº (X ‚Åª¬π' s) :=
    Measure.map_apply hX_meas hs
  have hmap0 : (Measure.map (fun (_ : Œ©) => (0 : ‚Ñù)) Œº) s
      = Œº ((fun _ => (0 : ‚Ñù)) ‚Åª¬π' s) :=
    Measure.map_apply (measurable_const : Measurable fun (_ : Œ©) => (0 : ‚Ñù)) hs
  have hpreimage_ae :
      (X ‚Åª¬π' s) =·µê[Œº] ((fun _ : Œ© => (0 : ‚Ñù)) ‚Åª¬π' s) := by
    refine hConst.mono ?_
    intro œâ hœâ
    have hiff : (œâ ‚àà X ‚Åª¬π' s) ‚Üî (œâ ‚àà ((fun _ : Œ© => (0 : ‚Ñù)) ‚Åª¬π' s)) := by
      simp [Set.mem_preimage, hœâ]
    simpa using (propext hiff)
  have hEq : Œº (X ‚Åª¬π' s) = Œº ((fun _ : Œ© => (0 : ‚Ñù)) ‚Åª¬π' s) :=
    measure_congr hpreimage_ae
  have hEq : Œº (X ‚Åª¬π' s) = Œº ((fun _ : Œ© => (0 : ‚Ñù)) ‚Åª¬π' s) :=
    measure_congr hpreimage_ae
  have hConstPush :
      (Measure.map (fun _ : Œ© => (0 : ‚Ñù)) Œº) s = (Measure.dirac (0 : ‚Ñù)) s := by
    by_cases h0 : (0 : ‚Ñù) ‚àà s
    ¬∑ have : ((fun _ : Œ© => (0 : ‚Ñù)) ‚Åª¬π' s) = Set.univ := by
        ext œâ; simp [h0]
      simp [hmap0, this, h0]
    ¬∑ have : ((fun _ : Œ© => (0 : ‚Ñù)) ‚Åª¬π' s) = (‚àÖ : Set Œ©) := by
        ext œâ; simp [h0]
      simp [hmap0, this, h0]
  have hChain : Œº (X ‚Åª¬π' s) = (Measure.dirac (0 : ‚Ñù)) s :=
    (hEq.trans hmap0.symm).trans hConstPush
  simpa [hmapX] using hChain

/-- If a real-valued map `X` is a.e. equal to the constant `0` under a probability measure `Œº`,
then its pushforward law is the centered degenerate Gaussian `gaussianReal 0 0`. -/
lemma map_eq_gaussianReal0_of_ae_eq_const_zero
    {Œ© : Type*} [MeasureSpace Œ©] {Œº : Measure Œ©} [IsProbabilityMeasure Œº]
    {X : Œ© ‚Üí ‚Ñù} (hX_meas : Measurable X)
    (hConst : X =·µê[Œº] fun _ => (0 : ‚Ñù)) :
    Measure.map X Œº = ProbabilityTheory.gaussianReal 0 0 := by
  classical
  simpa [ProbabilityTheory.gaussianReal_dirac] using
    map_eq_dirac_of_ae_eq_const_zero (Œº := Œº) (hX_meas := hX_meas) (hConst := hConst)

namespace ProbabilityTheory

/-- Wrapper with the ambient probability measure `‚Ñô`:
if `X =·µê[‚Ñô] 0` and `X` is measurable, then `X` is a centered Gaussian with
variance `0`. -/
lemma IsCenteredGaussianRV.of_ae_eq_const
    {Œ© : Type*} [MeasureSpace Œ©] [IsProbabilityMeasure (‚Ñô : Measure Œ©)]
    {X : Œ© ‚Üí ‚Ñù} (hX_meas : Measurable X)
    (hConst : X =·µê[‚Ñô] fun _ => (0 : ‚Ñù)) :
    ProbabilityTheory.IsCenteredGaussianRV X 0 := by
  classical
  have hmap : Measure.map X (‚Ñô : Measure Œ©) =
      ProbabilityTheory.gaussianReal 0 0 := by
    simpa [ProbabilityTheory.gaussianReal_dirac] using
      map_eq_dirac_of_ae_eq_const_zero (Œº := (‚Ñô : Measure Œ©))
        (hX_meas := hX_meas) (hConst := hConst)
  dsimp [ProbabilityTheory.IsCenteredGaussianRV,
         ProbabilityTheory.IsGaussianRV] at *
  exact hmap

/-- If a family `f` is mutually independent, then the tuple on the complement
of `i` is independent from the coordinate `i` itself. -/
lemma iIndepFun.indepFun_subtype_prod_singleton
  {Œ© Œπ : Type*} {Œ≤ : Œπ ‚Üí Type*}
  [MeasurableSpace Œ©] {Œº : Measure Œ©}
  [Fintype Œπ] [DecidableEq Œπ]
  [‚àÄ i, MeasurableSpace (Œ≤ i)]
  {f : ‚àÄ i, Œ© ‚Üí Œ≤ i}
  (hind : ProbabilityTheory.iIndepFun f Œº)
  (hf : ‚àÄ i, Measurable (f i))
  (i : Œπ) :
  ProbabilityTheory.IndepFun
    (fun œâ => fun j : {j // j ‚â† i} => f j.1 œâ)
    (fun œâ => f i œâ) Œº := by
  classical
  let S : Finset Œπ := Finset.univ.erase i
  let T : Finset Œπ := {i}
  have hST : Disjoint S T := by
    refine Finset.disjoint_left.2 ?_
    intro x hxS hxT
    exact (Finset.mem_erase.mp hxS).1 (Finset.mem_singleton.mp hxT)
  have h0 :
      ProbabilityTheory.IndepFun
        (fun œâ (j : {x // x ‚àà S}) => f j.1 œâ)
        (fun œâ (k : {x // x ‚àà T}) => f k.1 œâ) Œº :=
    (ProbabilityTheory.iIndepFun.indepFun_finset
      (f := f) (Œº := Œº) (S := S) (T := T) hST hind hf)
  let e : {j // j ‚â† i} ‚âÉ {j // j ‚àà S} :=
  { toFun := fun j =>
      ‚ü®j.1, by
        have : j.1 ‚â† i ‚àß j.1 ‚àà Finset.univ := ‚ü®j.2, by simp‚ü©
        simpa [S, Finset.mem_erase] using this‚ü©
    , invFun := fun j => ‚ü®j.1, (Finset.mem_erase.mp j.2).1‚ü©
    , left_inv := by intro j; rfl
    , right_inv := by intro j; rfl }
  let œÜ :
      (‚àÄ j : {j // j ‚àà S}, Œ≤ j.1) ‚Üí (‚àÄ j : {j // j ‚â† i}, Œ≤ j.1) :=
    fun v j => v (e j)
  have hœÜ_meas : Measurable œÜ := by
    refine measurable_pi_iff.mpr (fun j => ?_)
    simpa using (measurable_pi_apply (e j))
  let œà : (‚àÄ _k : {x // x ‚àà T}, Œ≤ _k.1) ‚Üí Œ≤ i :=
    fun v => v ‚ü®i, by simp [T]‚ü©
  have hœà_meas : Measurable œà := by measurability
  have h' := (ProbabilityTheory.IndepFun.comp h0 hœÜ_meas hœà_meas)
  have h_left :
      (œÜ ‚àò fun œâ (j : {j // j ‚àà S}) => f j.1 œâ)
        =
      (fun œâ (j : {j // j ‚â† i}) => f j.1 œâ) := by
    funext œâ j; rfl
  have h_right :
      (œà ‚àò fun œâ (k : {x // x ‚àà T}) => f k.1 œâ)
        = (fun œâ => f i œâ) := by
    funext œâ; rfl
  simpa [h_left, h_right] using h'

omit [IsProbabilityMeasure (‚Ñô : Measure Œ©)] [CompleteSpace H] [MeasurableSpace H] [BorelSpace H] in
/-- Independence of i-th coordinate and complement under the Gaussian model. -/
lemma indep_coord_complement
  {g : Œ© ‚Üí H} (hg : PhysLean.Probability.GaussianIBP.IsGaussianHilbert g)
  (i : hg.Œπ) :
  ProbabilityTheory.IndepFun
    (fun œâ => fun j : CoordLine.Comp hg.Œπ i => coord hg.w g j.1 œâ)
    (coord hg.w g i) ‚Ñô := by
  classical
  have hind :
      ProbabilityTheory.iIndepFun (coord hg.w g) ‚Ñô :=
    (PhysLean.Probability.GaussianIBP.coord_isGaussian_and_indep (g := g) hg).2
  have hf : ‚àÄ j, Measurable (coord hg.w g j) :=
    PhysLean.Probability.GaussianIBP.coord_measurable (g := g) hg
  simpa [CoordLine.Comp] using
    (ProbabilityTheory.iIndepFun.indepFun_subtype_prod_singleton
      (Œº := ‚Ñô) (f := coord hg.w g) hind hf i)

lemma stein_coord_with_param_of_indep
  (w : OrthonormalBasis Œπ ‚Ñù H) (i : Œπ)
  (F : H ‚Üí ‚Ñù) (hF_diff : ContDiff ‚Ñù 1 F)
  (hF_growth : PhysLean.Probability.GaussianIBP.HasModerateGrowth F)
  (X : Œ© ‚Üí ‚Ñù) (Y : Œ© ‚Üí (CoordLine.Comp Œπ i ‚Üí ‚Ñù))
  (hX_meas : Measurable X) (hY_meas : Measurable Y)
  (hIndep : ProbabilityTheory.IndepFun Y X ‚Ñô)
  (hX_gauss : ProbabilityTheory.IsCenteredGaussianRV X vœÑ)
  (hY_gauss0 : ‚àÄ j, ProbabilityTheory.IsCenteredGaussianRV (fun œâ => Y œâ j) 0) :
  ‚à´ œâ, X œâ * F (CoordLine.buildAlong (w := w) (i := i) (Y œâ) (X œâ)) ‚àÇ‚Ñô
    =
  (vœÑ : ‚Ñù) *
  ‚à´ œâ, deriv (fun t => F (CoordLine.buildAlong (w := w) (i := i) (Y œâ) t)) (X œâ) ‚àÇ‚Ñô := by
  classical
  set P := (CoordLine.Comp Œπ i ‚Üí ‚Ñù) √ó ‚Ñù
  set œÜ : P ‚Üí ‚Ñù :=
    fun p => p.2 * F (CoordLine.buildAlong (w := w) (i := i) p.1 p.2)
  set œà : P ‚Üí ‚Ñù :=
    fun p => deriv (fun t => F (CoordLine.buildAlong (w := w) (i := i) p.1 t)) p.2
  have hœÜ_meas : Measurable œÜ := by
    have h_eval_sum :
        Continuous (fun y : CoordLine.Comp Œπ i ‚Üí ‚Ñù =>
          ‚àë j : CoordLine.Comp Œπ i, (y j) ‚Ä¢ w j.1) := by
      refine
        continuous_finset_sum
          (s := (Finset.univ : Finset (CoordLine.Comp Œπ i)))
          (f := fun (j : CoordLine.Comp Œπ i) (y : CoordLine.Comp Œπ i ‚Üí ‚Ñù) => (y j) ‚Ä¢ w j.1)
          ?_
      intro j _
      simpa using (continuous_apply j).smul continuous_const
    have h1 : Continuous (fun p : P => ‚àë j : CoordLine.Comp Œπ i, (p.1 j) ‚Ä¢ w j.1) :=
      h_eval_sum.comp continuous_fst
    have h2 : Continuous (fun p : P => p.2 ‚Ä¢ w i) := continuous_snd.smul continuous_const
    have h_build_cont : Continuous (fun p : P =>
        CoordLine.buildAlong (w := w) (i := i) p.1 p.2) := by
      simpa [CoordLine.buildAlong, add_comm, add_left_comm, add_assoc] using h1.add h2
    have hFcont : Continuous (fun p : P =>
        F (CoordLine.buildAlong (w := w) (i := i) p.1 p.2)) :=
      hF_diff.continuous.comp h_build_cont
    have hSnd : Continuous (fun p : P => p.2) := continuous_snd
    exact (hSnd.measurable.mul hFcont.measurable)
  have hœà_meas : Measurable œà := by
    have h_eval_sum :
        Continuous (fun y : CoordLine.Comp Œπ i ‚Üí ‚Ñù =>
          ‚àë j : CoordLine.Comp Œπ i, (y j) ‚Ä¢ w j.1) := by
      refine
        continuous_finset_sum
          (s := (Finset.univ : Finset (CoordLine.Comp Œπ i)))
          (f := fun (j : CoordLine.Comp Œπ i) (y : CoordLine.Comp Œπ i ‚Üí ‚Ñù) => (y j) ‚Ä¢ w j.1)
          ?_
      intro j _
      simpa using (continuous_apply j).smul continuous_const
    have h1 : Continuous (fun p : P => ‚àë j : CoordLine.Comp Œπ i, (p.1 j) ‚Ä¢ w j.1) :=
      h_eval_sum.comp continuous_fst
    have h2 : Continuous (fun p : P => p.2 ‚Ä¢ w i) := continuous_snd.smul continuous_const
    have h_build_meas : Measurable (fun p : P =>
        CoordLine.buildAlong (w := w) (i := i) p.1 p.2) := by
      have h_build_cont : Continuous (fun p : P =>
          CoordLine.buildAlong (w := w) (i := i) p.1 p.2) := by
        simpa [CoordLine.buildAlong, add_comm, add_left_comm, add_assoc] using h1.add h2
      exact h_build_cont.measurable
    have hFderiv_meas :
        Measurable (fun p : P =>
          fderiv ‚Ñù F (CoordLine.buildAlong (w := w) (i := i) p.1 p.2)) :=
      (hF_diff.continuous_fderiv le_rfl).measurable.comp h_build_meas
    have hEval : Measurable (fun L : H ‚ÜíL[‚Ñù] ‚Ñù => L (w i)) :=
      ContinuousLinearMap.measurable_apply (w i)
    have h_rhs :
        Measurable (fun p : P =>
          (fderiv ‚Ñù F (CoordLine.buildAlong (w := w) (i := i) p.1 p.2)) (w i)) :=
      hEval.comp hFderiv_meas
    have h_eq :
        (fun p : P =>
          deriv (fun t => F (CoordLine.buildAlong (w := w) (i := i) p.1 t)) p.2)
        =
        (fun p : P =>
          (fderiv ‚Ñù F (CoordLine.buildAlong (w := w) (i := i) p.1 p.2)) (w i)) := by
      funext p
      have : ‚àÄ t : ‚Ñù,
          CoordLine.buildAlong (w := w) (i := i) p.1 t
            = (‚àë j, (p.1 j) ‚Ä¢ w j.1) + t ‚Ä¢ w i := by
        intro t; simp [CoordLine.buildAlong, add_comm, add_left_comm, add_assoc]
      simpa [this, CoordLine.line_def] using
        (CoordLine.deriv_F_along (w := w) (i := i) (F := F)
          (hF := hF_diff) (z := ‚àë j, (p.1 j) ‚Ä¢ w j.1) (x := p.2))
    simpa [œà, h_eq] using h_rhs
  have hmap_pair := map_pair_eq_prod_of_indep Y X hY_meas hX_meas hIndep
  have hchg_pair_œÜ :
      ‚à´ œâ, œÜ (Y œâ, X œâ) ‚àÇ‚Ñô
        = ‚à´ p, œÜ p ‚àÇMeasure.map (fun œâ => (Y œâ, X œâ)) ‚Ñô := by
    simpa using
      integral_pair_change_of_variables Y X hY_meas hX_meas hœÜ_meas
  have hchg_pair_œà :
      ‚à´ œâ, œà (Y œâ, X œâ) ‚àÇ‚Ñô
        = ‚à´ p, œà p ‚àÇMeasure.map (fun œâ => (Y œâ, X œâ)) ‚Ñô := by
    simpa using
      integral_pair_change_of_variables Y X hY_meas hX_meas hœà_meas
  have hchg_œÜ :
      ‚à´ œâ, œÜ (Y œâ, X œâ) ‚àÇ‚Ñô
        = ‚à´ p, œÜ p ‚àÇ((Measure.map Y ‚Ñô).prod (Measure.map X ‚Ñô)) := by
    simpa [hmap_pair] using hchg_pair_œÜ
  have hchg_œà :
      ‚à´ œâ, œà (Y œâ, X œâ) ‚àÇ‚Ñô
        = ‚à´ p, œà p ‚àÇ((Measure.map Y ‚Ñô).prod (Measure.map X ‚Ñô)) := by
    simpa [hmap_pair] using hchg_pair_œà
  have hX_law : Measure.map X ‚Ñô = ProbabilityTheory.gaussianReal 0 vœÑ := hX_gauss
  have hInt_œÜŒ© :
      Integrable (fun œâ =>
        œÜ (Y œâ, X œâ)) ‚Ñô := by
    simpa [œÜ] using
      (integrable_coord_mul_F_of_indep (w := w) (i := i)
        (F := F) (hF_diff := hF_diff) (hF_growth := hF_growth)
        (vœÑ := vœÑ) (X := X) (Y := Y)
        (hX_meas := hX_meas) (hY_meas := hY_meas)
        (_hIndep := hIndep) (hX_gauss := hX_gauss)
        (hY_gauss0 := hY_gauss0))
  have hInt_œàŒ© :
      Integrable (fun œâ =>
        œà (Y œâ, X œâ)) ‚Ñô := by
    simpa [œà] using
      (integrable_deriv_F_along_coord_of_indep (w := w) (i := i)
        (F := F) (hF_diff := hF_diff) (hF_growth := hF_growth)
        (vœÑ := vœÑ) (X := X) (Y := Y)
        (hX_meas := hX_meas) (hY_meas := hY_meas)
        (_hIndep := hIndep) (hX_gauss := hX_gauss)
        (hY_gauss0 := hY_gauss0))

  have hprod' :
      ‚à´ p, œÜ p ‚àÇ((Measure.map Y ‚Ñô).prod (Measure.map X ‚Ñô))
        =
      (vœÑ : ‚Ñù) *
      ‚à´ p, œà p ‚àÇ((Measure.map Y ‚Ñô).prod (Measure.map X ‚Ñô)) := by
    haveI : SFinite (Measure.map Y ‚Ñô) := Measure.instSFiniteMap ‚Ñô Y
    have h :=
      stein_coord_on_product (w := w) (i := i) (F := F)
        (hF_diff := hF_diff) (hF_growth := hF_growth)
        (ŒºY := Measure.map Y ‚Ñô) (vœÑ := vœÑ)
        (hŒºY_sfinite := inferInstance)
        (hInt_left := by
          simpa [hX_law, œÜ] using
            (integrable_phi_on_mapY_prod_gauss (Y := Y) (X := X)
              (hY := hY_meas) (hX := hX_meas) (hIndep := hIndep)
              (v := vœÑ) (hXlaw := hX_law) (hœÜ_meas := hœÜ_meas)
              (hInt := hInt_œÜŒ©)))
        (hInt_right‚ÇÄ := by
          simpa [hX_law, œà] using
            (integrable_psi_on_mapY_prod_gauss (Y := Y) (X := X)
              (hY := hY_meas) (hX := hX_meas) (hIndep := hIndep)
              (v := vœÑ) (hXlaw := hX_law) (hœà_meas := hœà_meas)
              (hInt := hInt_œàŒ©)))
    simpa [œÜ, œà, hX_law] using h
  calc
    ‚à´ œâ, X œâ * F (CoordLine.buildAlong (w := w) (i := i) (Y œâ) (X œâ)) ‚àÇ‚Ñô
        = ‚à´ œâ, œÜ (Y œâ, X œâ) ‚àÇ‚Ñô := by
          simp [œÜ]
    _ = ‚à´ p, œÜ p ‚àÇ((Measure.map Y ‚Ñô).prod (Measure.map X ‚Ñô)) := hchg_œÜ
    _ = (vœÑ : ‚Ñù) * ‚à´ p, œà p ‚àÇ((Measure.map Y ‚Ñô).prod (Measure.map X ‚Ñô)) := hprod'
    _ = (vœÑ : ‚Ñù) * ‚à´ œâ, œà (Y œâ, X œâ) ‚àÇ‚Ñô := by
          have := congrArg (fun z => (vœÑ : ‚Ñù) * z) (hchg_œà.symm)
          simpa using this
    _ = (vœÑ : ‚Ñù) * ‚à´ œâ, deriv (fun t => F (CoordLine.buildAlong (w := w) (i := i) (Y œâ) t)) (X œâ) ‚àÇ‚Ñô := by
          simp [œà]

/-- Final split that replaces the old `stein_coord_with_param_split`. -/
lemma stein_coord_with_param'
  {g : Œ© ‚Üí H} (hg : PhysLean.Probability.GaussianIBP.IsGaussianHilbert g)
  {F : H ‚Üí ‚Ñù} (hF_diff : ContDiff ‚Ñù 1 F)
  (hF_growth : PhysLean.Probability.GaussianIBP.HasModerateGrowth F)
  (i : hg.Œπ) :
  ‚à´ œâ, (PhysLean.Probability.GaussianIBP.coord hg.w g i œâ) * F (g œâ) ‚àÇ‚Ñô
    = (hg.œÑ i : ‚Ñù) * ‚à´ œâ, (fderiv ‚Ñù F (g œâ)) (hg.w i) ‚àÇ‚Ñô := by
  classical
  let X := PhysLean.Probability.GaussianIBP.coord hg.w g i
  let Y := fun œâ => fun j : PhysLean.Probability.GaussianIBP.CoordLine.Comp hg.Œπ i =>
    PhysLean.Probability.GaussianIBP.coord hg.w g j.1 œâ
  have hX_meas : Measurable X :=
    (PhysLean.Probability.GaussianIBP.coord_measurable (g := g) hg) i
  have hY_meas : Measurable Y :=
    measurable_pi_iff.mpr (fun j =>
      (PhysLean.Probability.GaussianIBP.coord_measurable (g := g) hg) j.1)
  have hIndep := ProbabilityTheory.indep_coord_complement (hg := hg) (i := i)
  have hX_gauss := (PhysLean.Probability.GaussianIBP.coord_isGaussian_and_indep (g := g) hg).1 i
  have hcoord_eq_c :
      PhysLean.Probability.GaussianIBP.coord hg.w g = hg.c :=
    PhysLean.Probability.GaussianIBP.coord_eq_c (g := g) hg
  have h_decomp : ‚àÄ œâ, g œâ =
      PhysLean.Probability.GaussianIBP.CoordLine.buildAlong (w := hg.w) (i := i) (Y œâ) (X œâ) := by
    intro œâ
    have hrepr : g œâ = ‚àë j : hg.Œπ, (hg.c j œâ) ‚Ä¢ hg.w j := by
      simpa using congrArg (fun f => f œâ) hg.repr
    have hsplit :
        ‚àë j : hg.Œπ, (hg.c j œâ) ‚Ä¢ hg.w j
          =
        (‚àë j : PhysLean.Probability.GaussianIBP.CoordLine.Comp hg.Œπ i,
           (hg.c j.1 œâ) ‚Ä¢ hg.w j.1) + (hg.c i œâ) ‚Ä¢ hg.w i := by
      simpa using
        PhysLean.Probability.GaussianIBP.CoordLine.repr_split_along
          (w := hg.w) (i := i) (c := hg.c) œâ
    have hY' : (fun j : PhysLean.Probability.GaussianIBP.CoordLine.Comp hg.Œπ i => Y œâ j)
                = (fun j => hg.c j.1 œâ) := by
      funext j
      simp [Y, hcoord_eq_c]; rw [‚Üê hcoord_eq_c]; aesop
    have hX' : X œâ = hg.c i œâ := by
      simp [X, hcoord_eq_c]
    calc
      g œâ = ‚àë j, (hg.c j œâ) ‚Ä¢ hg.w j := hrepr
      _ = (‚àë j : PhysLean.Probability.GaussianIBP.CoordLine.Comp hg.Œπ i,
              (hg.c j.1 œâ) ‚Ä¢ hg.w j.1) + (hg.c i œâ) ‚Ä¢ hg.w i := hsplit
      _ = (‚àë j : PhysLean.Probability.GaussianIBP.CoordLine.Comp hg.Œπ i,
              (Y œâ j) ‚Ä¢ hg.w j.1) + (X œâ) ‚Ä¢ hg.w i := by
            simp [hY', hX']
      _ = PhysLean.Probability.GaussianIBP.CoordLine.buildAlong
              (w := hg.w) (i := i) (Y œâ) (X œâ) := by
            simp [PhysLean.Probability.GaussianIBP.CoordLine.buildAlong,
                  add_comm, add_left_comm, add_assoc]
  set P := (PhysLean.Probability.GaussianIBP.CoordLine.Comp hg.Œπ i ‚Üí ‚Ñù) √ó ‚Ñù
  set œÜ : P ‚Üí ‚Ñù :=
    fun p => p.2 * F (PhysLean.Probability.GaussianIBP.CoordLine.buildAlong
                        (w := hg.w) (i := i) p.1 p.2)
  set œà : P ‚Üí ‚Ñù :=
    fun p => deriv (fun t =>
      F (PhysLean.Probability.GaussianIBP.CoordLine.buildAlong
            (w := hg.w) (i := i) p.1 t)) p.2
  have hœÜ_meas : Measurable œÜ := by
    have h_eval_sum :
        Continuous (fun y : PhysLean.Probability.GaussianIBP.CoordLine.Comp hg.Œπ i ‚Üí ‚Ñù =>
          ‚àë j, (y j) ‚Ä¢ hg.w j.1) := by
      refine
        continuous_finset_sum
          (s := (Finset.univ : Finset (PhysLean.Probability.GaussianIBP.CoordLine.Comp hg.Œπ i)))
          (f := fun (j : PhysLean.Probability.GaussianIBP.CoordLine.Comp hg.Œπ i)
                       (y : PhysLean.Probability.GaussianIBP.CoordLine.Comp hg.Œπ i ‚Üí ‚Ñù) =>
                       (y j) ‚Ä¢ hg.w j.1)
          ?_
      intro j _
      simpa using (continuous_apply j).smul continuous_const
    have h1 : Continuous (fun p : P =>
        ‚àë j : PhysLean.Probability.GaussianIBP.CoordLine.Comp hg.Œπ i, (p.1 j) ‚Ä¢ hg.w j.1) :=
      h_eval_sum.comp continuous_fst
    have h2 : Continuous (fun p : P => p.2 ‚Ä¢ hg.w i) :=
      continuous_snd.smul continuous_const
    have h_build_cont : Continuous (fun p : P =>
        PhysLean.Probability.GaussianIBP.CoordLine.buildAlong (w := hg.w) (i := i) p.1 p.2) := by
      simpa [PhysLean.Probability.GaussianIBP.CoordLine.buildAlong,
             add_comm, add_left_comm, add_assoc] using h1.add h2
    have hFcont : Continuous (fun p : P =>
        F (PhysLean.Probability.GaussianIBP.CoordLine.buildAlong (w := hg.w) (i := i) p.1 p.2)) :=
      hF_diff.continuous.comp h_build_cont
    have hSnd : Continuous (fun p : P => p.2) := continuous_snd
    exact (hSnd.measurable.mul hFcont.measurable)
  have hœà_meas : Measurable œà := by
    have h_eval_sum :
        Continuous (fun y : PhysLean.Probability.GaussianIBP.CoordLine.Comp hg.Œπ i ‚Üí ‚Ñù =>
          ‚àë j, (y j) ‚Ä¢ hg.w j.1) := by
      refine
        continuous_finset_sum
          (s := (Finset.univ : Finset (PhysLean.Probability.GaussianIBP.CoordLine.Comp hg.Œπ i)))
          (f := fun (j : PhysLean.Probability.GaussianIBP.CoordLine.Comp hg.Œπ i)
                       (y : PhysLean.Probability.GaussianIBP.CoordLine.Comp hg.Œπ i ‚Üí ‚Ñù) =>
                       (y j) ‚Ä¢ hg.w j.1)
          ?_
      intro j _
      simpa using (continuous_apply j).smul continuous_const
    have h1 : Continuous (fun p : P =>
        ‚àë j : PhysLean.Probability.GaussianIBP.CoordLine.Comp hg.Œπ i, (p.1 j) ‚Ä¢ hg.w j.1) :=
      h_eval_sum.comp continuous_fst
    have h2 : Continuous (fun p : P => p.2 ‚Ä¢ hg.w i) :=
      continuous_snd.smul continuous_const
    have h_build_meas : Measurable (fun p : P =>
        PhysLean.Probability.GaussianIBP.CoordLine.buildAlong (w := hg.w) (i := i) p.1 p.2) := by
      have h_build_cont : Continuous (fun p : P =>
          PhysLean.Probability.GaussianIBP.CoordLine.buildAlong (w := hg.w) (i := i) p.1 p.2) := by
        simpa [PhysLean.Probability.GaussianIBP.CoordLine.buildAlong,
               add_comm, add_left_comm, add_assoc] using h1.add h2
      exact h_build_cont.measurable
    have hFderiv_meas :
        Measurable (fun p : P =>
          fderiv ‚Ñù F (PhysLean.Probability.GaussianIBP.CoordLine.buildAlong
                        (w := hg.w) (i := i) p.1 p.2)) :=
      (hF_diff.continuous_fderiv le_rfl).measurable.comp h_build_meas
    have hEval : Measurable (fun L : H ‚ÜíL[‚Ñù] ‚Ñù => L (hg.w i)) :=
      ContinuousLinearMap.measurable_apply (hg.w i)
    have h_rhs :
        Measurable (fun p : P =>
          (fderiv ‚Ñù F (PhysLean.Probability.GaussianIBP.CoordLine.buildAlong
                        (w := hg.w) (i := i) p.1 p.2)) (hg.w i)) :=
      hEval.comp hFderiv_meas
    have h_eq :
        (fun p : P =>
          deriv (fun t =>
            F (PhysLean.Probability.GaussianIBP.CoordLine.buildAlong
                  (w := hg.w) (i := i) p.1 t)) p.2)
        =
        (fun p : P =>
          (fderiv ‚Ñù F (PhysLean.Probability.GaussianIBP.CoordLine.buildAlong
                        (w := hg.w) (i := i) p.1 p.2)) (hg.w i)) := by
      funext p
      have : ‚àÄ t : ‚Ñù,
          PhysLean.Probability.GaussianIBP.CoordLine.buildAlong (w := hg.w) (i := i) p.1 t
            = (‚àë j, (p.1 j) ‚Ä¢ hg.w j.1) + t ‚Ä¢ hg.w i := by
        intro t; simp [PhysLean.Probability.GaussianIBP.CoordLine.buildAlong,
                       add_comm, add_left_comm, add_assoc]
      simpa [this, PhysLean.Probability.GaussianIBP.CoordLine.line_def] using
        (PhysLean.Probability.GaussianIBP.CoordLine.deriv_F_along
          (w := hg.w) (i := i) (F := F)
          (hF := hF_diff)
          (z := ‚àë j, (p.1 j) ‚Ä¢ hg.w j.1) (x := p.2))
    simpa [œà, h_eq] using h_rhs
  have hmap_pair := map_pair_eq_prod_of_indep Y X hY_meas hX_meas hIndep
  have hchg_pair_œÜ :
      ‚à´ œâ, œÜ (Y œâ, X œâ) ‚àÇ‚Ñô
        = ‚à´ p, œÜ p ‚àÇMeasure.map (fun œâ => (Y œâ, X œâ)) ‚Ñô := by
    simpa using
      integral_pair_change_of_variables Y X hY_meas hX_meas hœÜ_meas
  have hchg_pair_œà :
      ‚à´ œâ, œà (Y œâ, X œâ) ‚àÇ‚Ñô
        = ‚à´ p, œà p ‚àÇMeasure.map (fun œâ => (Y œâ, X œâ)) ‚Ñô := by
    simpa using
      integral_pair_change_of_variables Y X hY_meas hX_meas hœà_meas
  have hchg_œÜ :
      ‚à´ œâ, œÜ (Y œâ, X œâ) ‚àÇ‚Ñô
        = ‚à´ p, œÜ p ‚àÇ((Measure.map Y ‚Ñô).prod (Measure.map X ‚Ñô)) := by
    simpa [hmap_pair] using hchg_pair_œÜ
  have hchg_œà :
      ‚à´ œâ, œà (Y œâ, X œâ) ‚àÇ‚Ñô
        = ‚à´ p, œà p ‚àÇ((Measure.map Y ‚Ñô).prod (Measure.map X ‚Ñô)) := by
    simpa [hmap_pair] using hchg_pair_œà
  have hInt_œÜŒ© :
      Integrable (fun œâ =>
        œÜ (Y œâ, X œâ)) ‚Ñô := by
    have : Integrable (fun œâ => X œâ * F (g œâ)) ‚Ñô :=
      integrable_coord_mul_F hg hF_diff hF_growth i
    simpa [œÜ, h_decomp] using this
  have hInt_œàŒ© :
      Integrable (fun œâ =>
        œà (Y œâ, X œâ)) ‚Ñô := by
    have h_deriv_pointwise : ‚àÄ œâ,
        deriv (fun t =>
          F (PhysLean.Probability.GaussianIBP.CoordLine.buildAlong
                (w := hg.w) (i := i) (Y œâ) t)) (X œâ)
          = (fderiv ‚Ñù F (g œâ)) (hg.w i) := by
      intro œâ
      have := PhysLean.Probability.GaussianIBP.CoordLine.deriv_F_along
        (w := hg.w) (i := i) (F := F) (hF := hF_diff)
        (z := ‚àë j : PhysLean.Probability.GaussianIBP.CoordLine.Comp hg.Œπ i,
                  (Y œâ j) ‚Ä¢ hg.w j.1)
        (x := X œâ)
      simpa [PhysLean.Probability.GaussianIBP.CoordLine.line_def,
             PhysLean.Probability.GaussianIBP.CoordLine.buildAlong,
             h_decomp œâ, add_comm, add_left_comm, add_assoc] using this
    have hInt_fderiv :
        Integrable (fun œâ => (fderiv ‚Ñù F (g œâ)) (hg.w i)) ‚Ñô :=
      integrable_fderiv_apply hg hF_diff hF_growth (hg.w i)
    have h_eq_fun :
        (fun œâ => œà (Y œâ, X œâ))
          = (fun œâ => (fderiv ‚Ñù F (g œâ)) (hg.w i)) := by
      funext œâ
      simp [œà, h_deriv_pointwise œâ]
      exact h_deriv_pointwise œâ
    simpa [h_eq_fun] using hInt_fderiv
  have hX_law : Measure.map X ‚Ñô = ProbabilityTheory.gaussianReal 0 (hg.œÑ i) := hX_gauss
  have hprod' :
      ‚à´ p, œÜ p ‚àÇ((Measure.map Y ‚Ñô).prod (Measure.map X ‚Ñô))
        =
      (hg.œÑ i : ‚Ñù) *
      ‚à´ p, œà p ‚àÇ((Measure.map Y ‚Ñô).prod (Measure.map X ‚Ñô)) := by
    haveI : SFinite (Measure.map Y ‚Ñô) := Measure.instSFiniteMap ‚Ñô Y
    have h :=
      stein_coord_on_product (w := hg.w) (i := i) (F := F)
        (hF_diff := hF_diff) (hF_growth := hF_growth)
        (ŒºY := Measure.map Y ‚Ñô) (vœÑ := hg.œÑ i)
        (hŒºY_sfinite := inferInstance)
        (hInt_left := by
          simpa [hX_law, œÜ] using
            (integrable_phi_on_mapY_prod_gauss (Y := Y) (X := X)
              (hY := hY_meas) (hX := hX_meas) (hIndep := hIndep)
              (v := hg.œÑ i) (hXlaw := hX_law) (hœÜ_meas := hœÜ_meas)
              (hInt := hInt_œÜŒ©)))
        (hInt_right‚ÇÄ := by
          simpa [hX_law, œà] using
            (integrable_psi_on_mapY_prod_gauss (Y := Y) (X := X)
              (hY := hY_meas) (hX := hX_meas) (hIndep := hIndep)
              (v := hg.œÑ i) (hXlaw := hX_law) (hœà_meas := hœà_meas)
              (hInt := hInt_œàŒ©)))
    simpa [œÜ, œà, hX_law] using h
  calc
    ‚à´ œâ, X œâ * F (g œâ) ‚àÇ‚Ñô
        = ‚à´ œâ, œÜ (Y œâ, X œâ) ‚àÇ‚Ñô := by
          simp [œÜ, h_decomp]
    _ = ‚à´ p, œÜ p ‚àÇ((Measure.map Y ‚Ñô).prod (Measure.map X ‚Ñô)) := hchg_œÜ
    _ = (hg.œÑ i : ‚Ñù) * ‚à´ p, œà p ‚àÇ((Measure.map Y ‚Ñô).prod (Measure.map X ‚Ñô)) := hprod'
    _ = (hg.œÑ i : ‚Ñù) * ‚à´ œâ, œà (Y œâ, X œâ) ‚àÇ‚Ñô := by
          have := congrArg (fun z => (hg.œÑ i : ‚Ñù) * z) (hchg_œà.symm)
          simpa using this
    _ = (hg.œÑ i : ‚Ñù) * ‚à´ œâ, (fderiv ‚Ñù F (g œâ)) (hg.w i) ‚àÇ‚Ñô := by
          have h_deriv_pointwise : ‚àÄ œâ,
              deriv (fun t =>
                F (PhysLean.Probability.GaussianIBP.CoordLine.buildAlong
                      (w := hg.w) (i := i) (Y œâ) t)) (X œâ)
              = (fderiv ‚Ñù F (g œâ)) (hg.w i) := by
            intro œâ
            have := PhysLean.Probability.GaussianIBP.CoordLine.deriv_F_along
              (w := hg.w) (i := i) (F := F) (hF := hF_diff)
              (z := ‚àë j : PhysLean.Probability.GaussianIBP.CoordLine.Comp hg.Œπ i,
                        (Y œâ j) ‚Ä¢ hg.w j.1)
              (x := X œâ)
            simpa [PhysLean.Probability.GaussianIBP.CoordLine.line_def,
                   PhysLean.Probability.GaussianIBP.CoordLine.buildAlong,
                   h_decomp œâ, add_comm, add_left_comm, add_assoc] using this
          refine congrArg (fun r => (hg.œÑ i : ‚Ñù) * r) ?_
          refine integral_congr_ae (ae_of_all _ (fun œâ => ?_))
          exact h_deriv_pointwise œâ

/-- Wrapper that reuses the split proof. -/
lemma stein_coord_with_param
  {Œ© : Type*} [MeasureSpace Œ©] [IsProbabilityMeasure (‚Ñô : Measure Œ©)]
  {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ‚Ñù H] [CompleteSpace H]
  [MeasurableSpace H] [BorelSpace H]
  {g : Œ© ‚Üí H} (hg : PhysLean.Probability.GaussianIBP.IsGaussianHilbert g)
  {F : H ‚Üí ‚Ñù} (hF_diff : ContDiff ‚Ñù 1 F)
  (hF_growth : PhysLean.Probability.GaussianIBP.HasModerateGrowth F)
  (i : hg.Œπ) :
  ùîº[(fun œâ => (coord hg.w g i œâ) * F (g œâ))]
    = (hg.œÑ i : ‚Ñù) * ùîº[(fun œâ => (fderiv ‚Ñù F (g œâ)) (hg.w i))] :=
  stein_coord_with_param' (g := g) hg hF_diff hF_growth i

/-- The key 1D conditional IBP step for a fixed basis direction `w i`.
This is an immediate wrapper around `stein_coord_with_param`. -/
lemma coord_IBP
    {g : Œ© ‚Üí H} (hg : IsGaussianHilbert g)
    {F : H ‚Üí ‚Ñù} (hF_diff : ContDiff ‚Ñù 1 F)
    (hF_growth : HasModerateGrowth F)
    (i : hg.Œπ) :
  ùîº[(fun œâ => (coord hg.w g i œâ) * F (g œâ))]
    = (hg.œÑ i : ‚Ñù) * ùîº[(fun œâ => (fderiv ‚Ñù F (g œâ)) (hg.w i))] := by
  classical
  simpa using
    stein_coord_with_param (g := g) (hg := hg) (F := F)
      (hF_diff := hF_diff) (hF_growth := hF_growth) (i := i)

/-- **Gaussian IBP on a finite-dimensional Hilbert space (covariant form).**
If `g` is a centered Gaussian on `H` modeled by independent coordinates along an
orthonormal basis with variances `œÑ i`, then for every `h ‚àà H` and every `C¬π`
 test function `F : H ‚Üí ‚Ñù` of moderate growth,

```
  E[‚ü™g, h‚ü´ F(g)] = E[(fderiv ‚Ñù F (g)) (Œ£ h)],
  where  Œ£ h = ‚àë i, (œÑ i : ‚Ñù) * ‚ü™h, w i‚ü´ ‚Ä¢ w i.
```
-/
@[simp]
theorem gaussian_integration_by_parts_hilbert_cov
    {g : Œ© ‚Üí H} (hg : IsGaussianHilbert g)
    (h : H)
    {F : H ‚Üí ‚Ñù} (hF_diff : ContDiff ‚Ñù 1 F) (hF_growth : HasModerateGrowth F) :
    ùîº[(fun œâ => ‚ü™g œâ, h‚ü´_‚Ñù * F (g œâ))]
      = ùîº[(fun œâ => (fderiv ‚Ñù F (g œâ))
          (‚àë i : hg.Œπ, ((hg.œÑ i : ‚Ñù) * ‚ü™h, hg.w i‚ü´_‚Ñù) ‚Ä¢ hg.w i))] := by
  classical
  let Œπ := hg.Œπ
  let w := hg.w
  have inner_expansion :
      (fun œâ => ‚ü™g œâ, h‚ü´_‚Ñù)
        = (fun œâ => ‚àë i : Œπ, (‚ü™g œâ, w i‚ü´_‚Ñù) * (‚ü™h, w i‚ü´_‚Ñù)) := by
    funext œâ; simpa using Aux.inner_decomp (w := w) (x := g œâ) (y := h)
  have step1 :
      ùîº[(fun œâ => ‚ü™g œâ, h‚ü´_‚Ñù * F (g œâ))]
        = ‚àë i : Œπ, (‚ü™h, w i‚ü´_‚Ñù) * ùîº[(fun œâ => (‚ü™g œâ, w i‚ü´_‚Ñù) * F (g œâ))] := by
    classical
    have h_int : ‚àÄ i : Œπ, Integrable (fun œâ => (‚ü™g œâ, w i‚ü´_‚Ñù) * F (g œâ)) :=
      fun i => integrable_coord_mul_F hg hF_diff hF_growth i
    have distr :
        (fun œâ =>
          (‚àë i : Œπ, (‚ü™g œâ, w i‚ü´_‚Ñù) * (‚ü™h, w i‚ü´_‚Ñù)) * F (g œâ))
      = (fun œâ =>
          ‚àë i : Œπ, (‚ü™h, w i‚ü´_‚Ñù) * ((‚ü™g œâ, w i‚ü´_‚Ñù) * F (g œâ))) := by
      funext œâ
      simp [Finset.sum_mul, mul_comm, mul_left_comm, mul_assoc]
      exact Finset.mul_sum Finset.univ (fun i => ‚ü™h, w i‚ü´_‚Ñù * ‚ü™g œâ, w i‚ü´_‚Ñù) (F (g œâ))
    calc
      ùîº[(fun œâ => ‚ü™g œâ, h‚ü´_‚Ñù * F (g œâ))]
          = ùîº[(fun œâ =>
                (‚àë i : Œπ, (‚ü™g œâ, w i‚ü´_‚Ñù) * (‚ü™h, w i‚ü´_‚Ñù)) * F (g œâ))] := by
              refine integral_congr_ae (ae_of_all _ (fun œâ => ?_))
              have hpt :
                  ‚ü™g œâ, h‚ü´_‚Ñù
                    = ‚àë i : Œπ, (‚ü™g œâ, w i‚ü´_‚Ñù) * (‚ü™h, w i‚ü´_‚Ñù) := by
                have := congrArg (fun f : Œ© ‚Üí ‚Ñù => f œâ) inner_expansion
                simpa using this
              simpa using congrArg (fun t => t * F (g œâ)) hpt
      _ = ùîº[(fun œâ =>
                ‚àë i : Œπ, (‚ü™h, w i‚ü´_‚Ñù) * ((‚ü™g œâ, w i‚ü´_‚Ñù) * F (g œâ)))] := by
              simp [distr]
      _ = ‚àë i : Œπ, ùîº[(fun œâ =>
                (‚ü™h, w i‚ü´_‚Ñù) * ((‚ü™g œâ, w i‚ü´_‚Ñù) * F (g œâ)))] := by
              simpa using
                expectation_finset_sum
                  (hg := hg)
                  (f := fun i œâ => (‚ü™h, w i‚ü´_‚Ñù) * ((‚ü™g œâ, w i‚ü´_‚Ñù) * F (g œâ)))
                  (hint := fun i => (h_int i).const_mul (‚ü™h, w i‚ü´_‚Ñù))
      _ = ‚àë i : Œπ, (‚ü™h, w i‚ü´_‚Ñù) * ùîº[(fun œâ => (‚ü™g œâ, w i‚ü´_‚Ñù) * F (g œâ))] := by
              refine Finset.sum_congr rfl ?_
              intro i _
              simpa [mul_comm, mul_left_comm, mul_assoc]
                using expectation_const_mul
                  (c := (‚ü™h, w i‚ü´_‚Ñù))
                  (f := fun œâ => (‚ü™g œâ, w i‚ü´_‚Ñù) * F (g œâ))
                  ((h_int i))
  have step2 :
      ‚àÄ i : Œπ,
        ùîº[(fun œâ => (‚ü™g œâ, w i‚ü´_‚Ñù) * F (g œâ))]
          = (hg.œÑ i : ‚Ñù) * ùîº[(fun œâ => (fderiv ‚Ñù F (g œâ)) (w i))] := by
    intro i
    simpa [coord] using
      coord_IBP (g := g) (hg := hg) (F := F)
        (hF_diff := hF_diff) (hF_growth := hF_growth) (i := i)
  have step3 :
      ‚àë i : Œπ, (‚ü™h, w i‚ü´_‚Ñù) * ùîº[(fun œâ => (‚ü™g œâ, w i‚ü´_‚Ñù) * F (g œâ))]
        = ‚àë i : Œπ, ((hg.œÑ i : ‚Ñù) * ‚ü™h, w i‚ü´_‚Ñù)
            * ùîº[(fun œâ => (fderiv ‚Ñù F (g œâ)) (w i))] := by
    classical
    refine Finset.sum_congr rfl ?_
    intro i _
    have h_comm :
        ùîº[(fun œâ => F (g œâ) * ‚ü™g œâ, w i‚ü´_‚Ñù)]
          = ùîº[(fun œâ => ‚ü™g œâ, w i‚ü´_‚Ñù * F (g œâ))] := by
      change ‚à´ œâ, F (g œâ) * ‚ü™g œâ, w i‚ü´_‚Ñù ‚àÇ‚Ñô
          = ‚à´ œâ, ‚ü™g œâ, w i‚ü´_‚Ñù * F (g œâ) ‚àÇ‚Ñô
      refine integral_congr_ae (ae_of_all _ (fun œâ => ?_))
      simp [mul_comm]
    calc
      (‚ü™h, w i‚ü´_‚Ñù) * ùîº[(fun œâ => (‚ü™g œâ, w i‚ü´_‚Ñù) * F (g œâ))]
          = (‚ü™h, w i‚ü´_‚Ñù) * ((hg.œÑ i : ‚Ñù) * ùîº[(fun œâ =>
                (fderiv ‚Ñù F (g œâ)) (w i))]) := by
                simp [step2 i]
      _ = ((hg.œÑ i : ‚Ñù) * ‚ü™h, w i‚ü´_‚Ñù) * ùîº[(fun œâ =>
                (fderiv ‚Ñù F (g œâ)) (w i))] := by
                simp [mul_comm, mul_left_comm, mul_assoc]
  have step4 :
      (‚àë i : Œπ, ((hg.œÑ i : ‚Ñù) * ‚ü™h, w i‚ü´_‚Ñù)
            * ùîº[(fun œâ => (fderiv ‚Ñù F (g œâ)) (w i))])
        = ùîº[(fun œâ => (fderiv ‚Ñù F (g œâ))
              (‚àë i : Œπ, ((hg.œÑ i : ‚Ñù) * ‚ü™h, w i‚ü´_‚Ñù) ‚Ä¢ w i))] := by
    classical
    simpa using
      (fderiv_expectation_weighted_sum
        (hg := hg) (hF_diff := hF_diff) (hF_growth := hF_growth)
        (a := fun i : Œπ => (hg.œÑ i : ‚Ñù) * ‚ü™h, w i‚ü´_‚Ñù)).symm
  calc
    ùîº[(fun œâ => ‚ü™g œâ, h‚ü´_‚Ñù * F (g œâ))]
        = ‚àë i : Œπ, (‚ü™h, w i‚ü´_‚Ñù) * ùîº[(fun œâ => (‚ü™g œâ, w i‚ü´_‚Ñù) * F (g œâ))] := step1
    _ = ‚àë i : Œπ, ((hg.œÑ i : ‚Ñù) * ‚ü™h, w i‚ü´_‚Ñù)
            * ùîº[(fun œâ => (fderiv ‚Ñù F (g œâ)) (w i))] := step3
    _ = ùîº[(fun œâ => (fderiv ‚Ñù F (g œâ))
              (‚àë i : Œπ, ((hg.œÑ i : ‚Ñù) * ‚ü™h, w i‚ü´_‚Ñù) ‚Ä¢ w i))] := step4

/-- **Operator form (coordinate‚Äëfree).** Using the covariance operator `Œ£`,
the covariant IBP reads

```
  ùîº[‚ü™g, h‚ü´ F(g)] = ùîº[(fderiv ‚Ñù F (g)) (Œ£ h)].
```
-/
@[simp]
 theorem gaussian_integration_by_parts_hilbert_cov_op
    {g : Œ© ‚Üí H} (hg : IsGaussianHilbert g)
    (h : H)
    {F : H ‚Üí ‚Ñù} (hF_diff : ContDiff ‚Ñù 1 F) (hF_growth : HasModerateGrowth F) :
    ùîº[(fun œâ => ‚ü™g œâ, h‚ü´_‚Ñù * F (g œâ))]
      = ùîº[(fun œâ => (fderiv ‚Ñù F (g œâ)) ((covOp (g := g) hg) h))] := by
  classical
  simpa [covOp_apply (g := g) (hg := hg) h]
    using gaussian_integration_by_parts_hilbert_cov
      (g := g) (hg := hg) (h := h) (F := F)
      (hF_diff := hF_diff) (hF_growth := hF_growth)

section LinearTestFunctions

/-- Zero mean of Gaussian inner coordinates (take `F ‚â° 1`). -/
@[simp]
lemma gaussian_zero_mean_inner
    {g : Œ© ‚Üí H} (hg : IsGaussianHilbert g) (h : H) :
    ùîº[(fun œâ => ‚ü™g œâ, h‚ü´_‚Ñù)] = 0 := by
  classical
  have hMG : HasModerateGrowth (fun _ : H => (1 : ‚Ñù)) :=
    hasModerateGrowth_const (H := H) (c := (1 : ‚Ñù))
  have hDiff : ContDiff ‚Ñù 1 (fun _ : H => (1 : ‚Ñù)) := by
    simpa using (contDiff_const : ContDiff ‚Ñù 1 (fun _ : H => (1 : ‚Ñù)))
  simpa using
    (gaussian_integration_by_parts_hilbert_cov_op (g := g) (hg := hg) (h := h)
      (F := fun _ : H => (1 : ‚Ñù)) (hF_diff := hDiff) (hF_growth := hMG))

/-- Covariance identity: `E[‚ü™g,h‚ü´ ‚ü™g,u‚ü´] = ‚ü™(Œ£ h), u‚ü´`. -/
@[simp]
lemma gaussian_covariance_pairing
    {g : Œ© ‚Üí H} (hg : IsGaussianHilbert g) (h u : H) :
    ùîº[(fun œâ => ‚ü™g œâ, h‚ü´_‚Ñù * ‚ü™g œâ, u‚ü´_‚Ñù)]
      = ‚ü™(covOp (g := g) hg) h, u‚ü´_‚Ñù := by
  classical
  let L : H ‚ÜíL[‚Ñù] ‚Ñù := ContinuousLinearMap.innerSL ‚Ñù u
  have hDiff : ContDiff ‚Ñù 1 (fun z : H => L z) := L.contDiff
  have hMG : HasModerateGrowth (fun z : H => L z) := hasModerateGrowth_of_clm (L := L)
  have hIBP :=
    gaussian_integration_by_parts_hilbert_cov_op (g := g) (hg := hg) (h := h)
      (F := fun z : H => L z) (hF_diff := hDiff) (hF_growth := hMG)
  have hderiv : ‚àÄ z, fderiv ‚Ñù (fun x : H => L x) z = L := by
    intro z
    exact ContinuousLinearMap.fderiv L
  have hR :
      ùîº[(fun œâ : Œ© =>
        (fderiv ‚Ñù (fun z : H => L z) (g œâ)) ((covOp (g := g) hg) h))]
      =
      ùîº[(fun _œâ : Œ© => L ((covOp (g := g) hg) h))] := by
    simp [hderiv]
  have hExpConst :
      ùîº[(fun _œâ : Œ© => L ((covOp (g := g) hg) h))] = L ((covOp (g := g) hg) h) := by
    simp
  have hMain :
      ùîº[(fun œâ : Œ© => ‚ü™g œâ, h‚ü´_‚Ñù * L (g œâ))]
        = L ((covOp (g := g) hg) h) := by
    have h' :
        ùîº[(fun œâ : Œ© => ‚ü™g œâ, h‚ü´_‚Ñù * L (g œâ))]
          = ùîº[(fun _œâ : Œ© => L ((covOp (g := g) hg) h))] := by
      simpa [hR] using hIBP
    simpa [hExpConst] using h'
  have hRhs :
      ùîº[(fun œâ : Œ© => ‚ü™g œâ, h‚ü´_‚Ñù * ‚ü™u, g œâ‚ü´_‚Ñù)]
        = ‚ü™u, (covOp (g := g) hg) h‚ü´_‚Ñù := by
    simpa only [L, ContinuousLinearMap.innerSL_apply] using hMain
  simpa [real_inner_comm] using hRhs


end LinearTestFunctions

/-- **Standard-covariance corollary.** If all coordinate variances are `1`, the
covariant formula reduces to the usual identity with `h` on the RHS. -/
@[simp]
 theorem gaussian_integration_by_parts_hilbert_std
    {g : Œ© ‚Üí H} (hg : IsGaussianHilbert g)
    (hœÑ : ‚àÄ i : hg.Œπ, hg.œÑ i = 1)
    (h : H)
    {F : H ‚Üí ‚Ñù} (hF_diff : ContDiff ‚Ñù 1 F) (hF_growth : HasModerateGrowth F) :
    ùîº[(fun œâ => ‚ü™g œâ, h‚ü´_‚Ñù * F (g œâ))]
      = ùîº[(fun œâ => (fderiv ‚Ñù F (g œâ)) h)] := by
  classical
  have := gaussian_integration_by_parts_hilbert_cov
    (g := g) (hg := hg) (h := h) (F := F)
    (hF_diff := hF_diff) (hF_growth := hF_growth)
  have h_as_sum :
      (‚àë i : hg.Œπ, ((hg.œÑ i : ‚Ñù) * ‚ü™h, hg.w i‚ü´_‚Ñù) ‚Ä¢ hg.w i) = h := by
    classical
    have : (‚àë i : hg.Œπ, (‚ü™h, hg.w i‚ü´_‚Ñù) ‚Ä¢ hg.w i) = h := by
      simpa [hg.w.repr_apply_apply, real_inner_comm] using (hg.w.sum_repr h)
    simpa [hœÑ, mul_one] using this
  simpa [h_as_sum] using this

/-! ## Further corollaries  -/
section MoreCorollaries

variable {g : Œ© ‚Üí H}

/-- **CLM test functions.** A clean operator‚Äëform covariance identity for any
continuous linear functional `L : H ‚ÜíL[‚Ñù] ‚Ñù`.

This is just `gaussian_integration_by_parts_hilbert_cov_op` with `F = L`, whose
Fr√©chet derivative is constantly `L`. -/
@[simp]
lemma gaussian_covariance_clm
    (hg : IsGaussianHilbert (Œ© := Œ©) (H := H) g)
    (L : H ‚ÜíL[‚Ñù] ‚Ñù) (h : H) :
    ùîº[(fun œâ => ‚ü™g œâ, h‚ü´_‚Ñù * L (g œâ))]
      = L ((covOp (g := g) hg) h) := by
  classical
  have hDiff : ContDiff ‚Ñù 1 (fun z : H => L z) := L.contDiff
  have hMG   : HasModerateGrowth (fun z : H => L z) :=
    hasModerateGrowth_of_clm (L := L)
  simpa using
    (gaussian_integration_by_parts_hilbert_cov_op (g := g) (hg := hg)
      (h := h) (F := fun z : H => L z) (hF_diff := hDiff) (hF_growth := hMG))

/-- **Quadratic moment along a direction.** Specializing the covariance pairing
with `u = h` gives the second moment of the scalar coordinate. -/
@[simp]
lemma gaussian_quadratic_moment
    (hg : IsGaussianHilbert (Œ© := Œ©) (H := H) g) (h : H) :
    ùîº[(fun œâ => (‚ü™g œâ, h‚ü´_‚Ñù)^2)]
      = ‚ü™(covOp (g := g) hg) h, h‚ü´_‚Ñù := by
  classical
  simpa [pow_two] using
    (gaussian_covariance_pairing (g := g) (hg := hg) (h := h) (u := h))

lemma gaussian_second_moment
    (hg : IsGaussianHilbert (Œ© := Œ©) (H := H) g) :
    ùîº[(fun œâ => ‚Äñg œâ‚Äñ^2)] = ‚àë i : hg.Œπ, (hg.œÑ i : ‚Ñù) := by
  classical
  have h_decomp :
      (fun œâ => ‚Äñg œâ‚Äñ^2) = (fun œâ => ‚àë i : hg.Œπ, (‚ü™g œâ, hg.w i‚ü´_‚Ñù)^2) := by
    funext œâ
    simpa [real_inner_self_eq_norm_sq, pow_two] using
      (Aux.inner_decomp (w := hg.w) (x := g œâ) (y := g œâ))
  have h_each : ‚àÄ i : hg.Œπ,
      ùîº[(fun œâ => (‚ü™g œâ, hg.w i‚ü´_‚Ñù)^2)] = (hg.œÑ i : ‚Ñù) := by
    intro i
    simpa [pow_two,
           covOp_apply (g := g) (hg := hg),
           OrthonormalBasis.inner_eq_ite,
           inner_smul_left] using
      (gaussian_quadratic_moment (g := g) (hg := hg) (h := hg.w i))
  have h_int : ‚àÄ i : hg.Œπ, Integrable (fun œâ => (‚ü™g œâ, hg.w i‚ü´_‚Ñù)^2) := by
    intro i
    have hX_gauss :
        ProbabilityTheory.IsCenteredGaussianRV (coord hg.w g i) (hg.œÑ i) :=
      (coord_isGaussian_and_indep (g := g) hg).1 i
    have hX_meas : Measurable (coord hg.w g i) :=
      (coord_measurable (g := g) hg) i
    simpa [coord, pow_two] using
      (ProbabilityTheory.IsCenteredGaussianRV.integrable_sq
        (Œ© := Œ©) (X := coord hg.w g i) (v := hg.œÑ i) hX_gauss hX_meas)
  calc
    ùîº[(fun œâ => ‚Äñg œâ‚Äñ^2)]
        = ùîº[(fun œâ => ‚àë i : hg.Œπ, (‚ü™g œâ, hg.w i‚ü´_‚Ñù)^2)] := by
            simp [h_decomp]
    _ = ‚àë i : hg.Œπ, ùîº[(fun œâ => (‚ü™g œâ, hg.w i‚ü´_‚Ñù)^2)] := by
            simpa using
              expectation_finset_sum (g := g) (hg := hg)
                (f := fun i œâ => (‚ü™g œâ, hg.w i‚ü´_‚Ñù)^2) (hint := h_int)
    _ = ‚àë i : hg.Œπ, (hg.œÑ i : ‚Ñù) := by
            simp [h_each]

end MoreCorollaries
end ProbabilityTheory
end SteinAlongOneCoordinate
end GaussianIBP
end Probability

