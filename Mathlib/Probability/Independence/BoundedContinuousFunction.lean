/-
Copyright (c) 2025 Etienne Marion. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Etienne Marion
-/
module

public import Mathlib.MeasureTheory.Measure.HasOuterApproxClosedProd
public import Mathlib.Probability.Independence.Process
public import Mathlib.Probability.Notation

/-!
# Characterizing independence via bounded continuous functions

Given two random variables `X : Î© â†’ E` and `Y : Î© â†’ F` such that `E` and `F` are Borel spaces
satisfying `HasOuterApproxClosed`, `X` and `Y` are independent if for any real bounded continuous
functions `f` and `g`, `âˆ« Ï‰, f (X Ï‰) * g (Y Ï‰) âˆ‚P = (âˆ« Ï‰, f (X Ï‰) âˆ‚P) * (âˆ« Ï‰, g (Y Ï‰) âˆ‚P)`.

Consider now `X : (s : S) â†’ Î© â†’ E s`, with `Fintype S` and each `E s` being a Borel space satisfying
`HasOuterApproxClosed`. Then to apply the above result we need that `Î  s, E s` is a Borel space,
and therefore that each `E s` is second countable. We can circumvent this restriction by proving
that `fun Ï‰ s â†¦ X s Ï‰` and `Y` are independent if for any family of bounded continuous functions
`f : (s : S) â†’ E s â†’ â„` and any bounded continuous function `g : F â†’ â„` we have
`âˆ« Ï‰, âˆ s, f s (X s Ï‰) * g (Y Ï‰) âˆ‚P = âˆ« Ï‰, âˆ s, f s (X s Ï‰) âˆ‚P * âˆ« Ï‰, g (Y Ï‰) âˆ‚P`.
We can use this result in the case where `S := Unit` to deduce the first statement we mentioned.

We take this approach in this file. We first prove `pi_indepFun_pi_of_prod_bcf`, which allows to
prove the result when `E` and `F` are product spaces without assuming second countability, and
then we deduce the other cases from there.

Building on this, we also prove `process_indepFun_process_of_prod_bcf`. This time we do not require
`Fintype S` and require the hypothesis to be satisfied for each `I : Finset S`. Then we similarly
deduce other versions where one of the variables is not necessarily a process.

We then turn to independence between an event and a random variable. We prove
`indicator_indepFun_pi_of_prod_bcf`: the indicator of an event `A` is independent
of a finite family of random variables `X : (s : S) â†’ Î© â†’ E s` if for any family of bounded
continuous functions `f : (s : S) â†’ E s â†’ â„` we have
`âˆ« Ï‰ in A, âˆ s, f s (X s Ï‰) âˆ‚P = P.real A * âˆ« Ï‰, âˆ s, f s (X s Ï‰) âˆ‚P`. Once again we deduce
other versions from this, and also write versions where `X` is a stochastic process.

Then we build on that to show that a `Ïƒ`-algebra `m` is independent from a stochastic process `X`
if for any `A` such that `MeasurableSet[m] A`, any `I : Finset S` and any bounded continuous
function `f : (Î  s : I, E s) â†’ â„`, we have `âˆ« Ï‰ in A, f (X Â· Ï‰) âˆ‚P = P.real A * âˆ« Ï‰, f (X Â· Ï‰) âˆ‚P`.
This again is formulated with different versions. We also provide versions in terms of
`IndepSets` instead of `Indep`.

## Main statement

* `indep_comap_process_of_bcf`: A `Ïƒ`-algebra `m` is independent from a stochastic process `X`
  if for any `A` such that `MeasurableSet[m] A`, any `I : Finset S`, and any bounded continuous
  function `f : (Î  s : I, E s) â†’ â„`, we have
  `âˆ« Ï‰ in A, f (X Â· Ï‰) âˆ‚P = P.real A * âˆ« Ï‰, f (X Â· Ï‰) âˆ‚P`.

## Notations

to avoid writing `boundedContinuousFunction` in the names, which is quite lengthy, we abbreviate it
to `bcf`.

## Tags

independence, bounded continuous functions
-/

@[expose] public section

open MeasureTheory Measure ProbabilityTheory ENNReal
open scoped BoundedContinuousFunction

variable {Î© S T : Type*} {m mÎ© : MeasurableSpace Î©} {P : Measure Î©}

/-- If the indicator of a set `A` is indepent from a variable `X`, then set `A` is independent
from the sigma algebra generated by `X`. -/
lemma IndepFun.singleton_indepSets_of_indicator {ğ“§ : Type*} [mX : MeasurableSpace ğ“§] {A : Set Î©}
    {X : Î© â†’ ğ“§} (h : (A.indicator (1 : Î© â†’ â„)) âŸ‚áµ¢[P] X) :
    IndepSets {A} {s | MeasurableSet[mX.comap X] s} P := by
  rw [IndepSets_iff]
  rintro s - hs âŸ¨t, ht, rflâŸ©
  rw [Set.mem_singleton_iff.1 hs]
  have hA' : A = A.indicator (1 : Î© â†’ â„) â»Â¹' {1} := by ext; simp [Set.indicator]
  rw [hA']
  exact h.measure_inter_preimage_eq_mul _ _ (by simp) ht

variable {E : S â†’ Type*} {F : T â†’ Type*} {G H : Type*}
  [âˆ€ s, TopologicalSpace (E s)] [âˆ€ s, MeasurableSpace (E s)] [âˆ€ s, BorelSpace (E s)]
  [âˆ€ s, HasOuterApproxClosed (E s)]
  [âˆ€ t, TopologicalSpace (F t)] [âˆ€ t, MeasurableSpace (F t)] [âˆ€ t, BorelSpace (F t)]
  [âˆ€ t, HasOuterApproxClosed (F t)]
  [TopologicalSpace G] [MeasurableSpace G] [BorelSpace G] [HasOuterApproxClosed G]
  [TopologicalSpace H] [MeasurableSpace H] [BorelSpace H] [HasOuterApproxClosed H]
  {X : (s : S) â†’ Î© â†’ E s} {Y : (t : T) â†’ Î© â†’ F t} {Z : Î© â†’ G} {U : Î© â†’ H}

section Fintype

variable [Fintype S] [Fintype T]

section IndepFun

variable [IsFiniteMeasure P]

lemma pi_indepFun_pi_of_prod_bcf (mX : âˆ€ s, AEMeasurable (X s) P)
    (mY : âˆ€ t, AEMeasurable (Y t) P)
    (h : âˆ€ (f : (s : S) â†’ E s â†’áµ‡ â„) (g : (t : T) â†’ F t â†’áµ‡ â„),
      P[(âˆ s, f s âˆ˜ (X s)) * (âˆ t, g t âˆ˜ (Y t))] = P[âˆ s, f s âˆ˜ (X s)] * P[âˆ t, g t âˆ˜ (Y t)]) :
    IndepFun (fun Ï‰ s â†¦ X s Ï‰) (fun Ï‰ t â†¦ Y t Ï‰) P := by
  rw [indepFun_iff_map_prod_eq_prod_map_map (aemeasurable_pi_lambda _ mX)
    (aemeasurable_pi_lambda _ mY)]
  refine eq_prod_of_integral_prod_mul_prod_boundedContinuousFunction fun f g â†¦ ?_
  rw [integral_map, integral_map, integral_map]
  Â· convert h f g <;> simp
  any_goals fun_prop
  all_goals exact Measurable.aestronglyMeasurable (by fun_prop)

/-- Two families of random variables $(X_1, ..., X_p)$ and $(Y_1, ..., Y_q)$ are independent if
for all real bounded continuous functions $f$ and $g$,
$$P[f(X_1, ..., X_p) g(Y_1, ..., Y_q)] = P[f(X_1, ..., X_p)] * P[g(Y_1, ..., Y_q)].$$ -/
lemma pi_indepFun_pi_of_bcf (mX : âˆ€ s, AEMeasurable (X s) P)
    (mY : âˆ€ t, AEMeasurable (Y t) P)
    (h : âˆ€ (f : (Î  s, E s) â†’áµ‡ â„) (g : (Î  t, F t) â†’áµ‡ â„),
      P[fun Ï‰ â†¦ f (X Â· Ï‰) * g (Y Â· Ï‰)] = P[fun Ï‰ â†¦ f (X Â· Ï‰)] * P[fun Ï‰ â†¦ g (Y Â· Ï‰)]) :
    IndepFun (fun Ï‰ s â†¦ X s Ï‰) (fun Ï‰ t â†¦ Y t Ï‰) P := by
  refine pi_indepFun_pi_of_prod_bcf mX mY fun f g â†¦ ?_
  convert h (âˆ s, (f s).compContinuous âŸ¨Function.eval s, by fun_propâŸ©)
    (âˆ t, (g t).compContinuous âŸ¨Function.eval t, by fun_propâŸ©) <;> simp

lemma indepFun_pi_of_prod_bcf (mZ : AEMeasurable Z P)
    (mY : âˆ€ t, AEMeasurable (Y t) P)
    (h : âˆ€ (f : G â†’áµ‡ â„) (g : (t : T) â†’ F t â†’áµ‡ â„),
      P[f âˆ˜ Z * (âˆ t, g t âˆ˜ (Y t))] = P[f âˆ˜ Z] * P[âˆ t, g t âˆ˜ (Y t)]) :
    IndepFun Z (fun Ï‰ t â†¦ Y t Ï‰) P := by
  rw [indepFun_iff_map_prod_eq_prod_map_map mZ (aemeasurable_pi_lambda _ mY)]
  refine eq_prod_of_integral_mul_prod_boundedContinuousFunction fun f g â†¦ ?_
  rw [integral_map, integral_map, integral_map]
  Â· convert h f g <;> simp
  any_goals fun_prop
  all_goals exact Measurable.aestronglyMeasurable (by fun_prop)

lemma indepFun_pi_of_bcf (mZ : AEMeasurable Z P)
    (mY : âˆ€ t, AEMeasurable (Y t) P)
    (h : âˆ€ (f : G â†’áµ‡ â„) (g : (Î  t, F t) â†’áµ‡ â„),
      P[fun Ï‰ â†¦ f (Z Ï‰) * g (Y Â· Ï‰)] = P[f âˆ˜ Z] * P[fun Ï‰ â†¦ g (Y Â· Ï‰)]) :
    IndepFun Z (fun Ï‰ t â†¦ Y t Ï‰) P := by
  refine indepFun_pi_of_prod_bcf mZ mY fun f g â†¦ ?_
  convert h f (âˆ t, (g t).compContinuous âŸ¨Function.eval t, by fun_propâŸ©) <;> simp

lemma pi_indepFun_of_prod_bcf (mX : âˆ€ s, AEMeasurable (X s) P)
    (mU : AEMeasurable U P)
    (h : âˆ€ (f : (s : S) â†’ E s â†’áµ‡ â„) (g : H â†’áµ‡ â„),
      P[(âˆ s, f s âˆ˜ (X s)) * g âˆ˜ U] = P[âˆ s, f s âˆ˜ (X s)] * P[g âˆ˜ U]) :
    IndepFun (fun Ï‰ s â†¦ X s Ï‰) U P := by
  rw [indepFun_iff_map_prod_eq_prod_map_map (aemeasurable_pi_lambda _ mX) mU]
  refine eq_prod_of_integral_prod_mul_boundedContinuousFunction fun f g â†¦ ?_
  rw [integral_map, integral_map, integral_map]
  Â· convert h f g <;> simp
  any_goals fun_prop
  all_goals exact Measurable.aestronglyMeasurable (by fun_prop)

lemma pi_indepFun_of_bcf (mX : âˆ€ s, AEMeasurable (X s) P)
    (mU : AEMeasurable U P)
    (h : âˆ€ (f : (Î  s, E s) â†’áµ‡ â„) (g : H â†’áµ‡ â„),
      P[fun Ï‰ â†¦ f (X Â· Ï‰) * g (U Ï‰)] = P[fun Ï‰ â†¦ f (X Â· Ï‰)] * P[g âˆ˜ U]) :
    IndepFun (fun Ï‰ s â†¦ X s Ï‰) U P := by
  refine pi_indepFun_of_prod_bcf mX mU fun f g â†¦ ?_
  convert h (âˆ s, (f s).compContinuous âŸ¨Function.eval s, by fun_propâŸ©) g <;> simp

/-- Two random variables $X$ and $Y$ are independent if
for all real bounded continuous functions $f$ and $g$,
$$P[f(X) g(Y)] = P[f(X)] * P[g(Y)].$$ -/
lemma indepFun_of_bcf (mZ : AEMeasurable Z P) (mU : AEMeasurable U P)
    (h : âˆ€ (f : G â†’áµ‡ â„) (g : H â†’áµ‡ â„), P[f âˆ˜ Z * g âˆ˜ U] = P[f âˆ˜ Z] * P[g âˆ˜ U]) :
    IndepFun Z U P := by
  rw [indepFun_iff_map_prod_eq_prod_map_map mZ mU]
  refine eq_prod_of_integral_mul_boundedContinuousFunction fun f g â†¦ ?_
  rw [integral_map, integral_map, integral_map]
  Â· exact h f g
  any_goals fun_prop
  exact Measurable.aestronglyMeasurable (by fun_prop)

end IndepFun

variable [IsProbabilityMeasure P]

section Indicator

lemma indicator_indepFun_pi_of_prod_bcf
    {A : Set Î©} (mA : NullMeasurableSet A P) (mX : âˆ€ s, AEMeasurable (X s) P)
    (h : âˆ€ f : (s : S) â†’ E s â†’áµ‡ â„, âˆ« Ï‰ in A, âˆ s, f s (X s Ï‰) âˆ‚P =
      P.real A * âˆ« Ï‰, âˆ s, f s (X s Ï‰) âˆ‚P) :
    (A.indicator (1 : Î© â†’ â„)) âŸ‚áµ¢[P] (fun Ï‰ s â†¦ X s Ï‰) := by
  refine indepFun_pi_of_prod_bcf
    ((aemeasurable_indicator_const_iff 1).2 mA) mX fun f g â†¦ ?_
  have h1 Ï‰ : f (A.indicator 1 Ï‰) * âˆ s, g s (X s Ï‰) =
      A.indicator (fun Ï‰ â†¦ f 1 * âˆ s, g s (X s Ï‰)) Ï‰ +
      f 0 * âˆ s, g s (X s Ï‰) - A.indicator (fun Ï‰ â†¦ f 0 * âˆ s, g s (X s Ï‰)) Ï‰ := by
    classical
    rw [Set.indicator_apply]
    split_ifs <;> simp_all
  have h2 Ï‰ : f (A.indicator 1 Ï‰) =
      A.indicator (fun _ â†¦ f 1) Ï‰ + Aá¶œ.indicator (fun _ â†¦ f 0) Ï‰ := by
    classical
    rw [Set.indicator_apply]
    split_ifs <;> simp_all
  have hg {c : â„} : Integrable (fun Ï‰ â†¦ c * âˆ s, g s (X s Ï‰)) P := by
    refine Integrable.of_bound ?_ (â€–câ€– * âˆ s, â€–g sâ€–) (ae_of_all _ fun Ï‰ â†¦ ?_)
    Â· exact (Finset.aestronglyMeasurable_fun_prod _ fun s _ â†¦
        (g s).continuous.aestronglyMeasurable.comp_aemeasurable (mX s)).const_mul _
    Â· rw [norm_mul, norm_prod]
      gcongr with s
      exact (g s).norm_coe_le_norm _
  simp_rw [Pi.mul_apply, Finset.prod_apply, Function.comp_apply, h1, h2]
  rw [integral_sub, integral_add, integral_indicatorâ‚€ mA, integral_indicatorâ‚€ mA,
    integral_const_mul, integral_const_mul, integral_const_mul, integral_add,
    integral_indicatorâ‚€ mA, integral_indicatorâ‚€ mA.compl, integral_const, integral_const, h]
  Â· simp [measureReal_complâ‚€ mA]
    ring
  Â· exact (integrable_const _).indicatorâ‚€ mA
  Â· exact (integrable_const _).indicatorâ‚€ mA.compl
  Â· exact hg.indicatorâ‚€ mA
  Â· exact hg
  Â· exact (hg.indicatorâ‚€ mA).add hg
  Â· exact hg.indicatorâ‚€ mA

/-- The indicator of a set $A$ and a family of random variables $(X_1, ..., X_p)$ are independent
if for all real bounded continuous function $f$,
$$P[\mathbb{I}_A f(X_1, ..., X_p)] = P(A) P[f(X_1, ..., X_p)].$$ -/
lemma indicator_indepFun_pi_of_bcf
    {A : Set Î©} (mA : NullMeasurableSet A P) (mX : âˆ€ s, AEMeasurable (X s) P)
    (h : âˆ€ f : (Î  s, E s) â†’áµ‡ â„, âˆ« Ï‰ in A, f (X Â· Ï‰) âˆ‚P = P.real A * âˆ« Ï‰, f (X Â· Ï‰) âˆ‚P) :
    (A.indicator (1 : Î© â†’ â„)) âŸ‚áµ¢[P] (fun Ï‰ s â†¦ X s Ï‰) := by
  refine indicator_indepFun_pi_of_prod_bcf mA mX fun f â†¦ ?_
  convert h (âˆ s, (f s).compContinuous âŸ¨Function.eval s, by fun_propâŸ©) <;> simp

/-- The indicator of a set $A$ and a random variable $X$ are independent
if for all real bounded continuous function $f$,
$$P[\mathbb{I}_A f(X)] = P(A) P[f(X)].$$ -/
lemma indicator_indepFun_of_bcf
    {A : Set Î©} (mA : NullMeasurableSet A P) (mZ : AEMeasurable Z P)
    (h : âˆ€ f : G â†’áµ‡ â„, âˆ« Ï‰ in A, f (Z Ï‰) âˆ‚P = P.real A * âˆ« Ï‰, f (Z Ï‰) âˆ‚P) :
    (A.indicator (1 : Î© â†’ â„)) âŸ‚áµ¢[P] Z := by
  suffices (A.indicator (1 : Î© â†’ â„)) âŸ‚áµ¢[P] (fun Ï‰ (_ : Unit) â†¦ Z Ï‰) from
    this.comp (measurable_id) (measurable_pi_apply ())
  refine indicator_indepFun_pi_of_prod_bcf mA (fun _ â†¦ mZ) fun f â†¦ ?_
  convert h (f ()) <;> simp

end Indicator

section IndepSets

lemma indepSets_comap_pi_of_prod_bcf
    {ğ’œ : Set (Set Î©)} (mğ’œ : âˆ€ A âˆˆ ğ’œ, NullMeasurableSet A P) (mX : âˆ€ s, AEMeasurable (X s) P)
    (h : âˆ€ A âˆˆ ğ’œ, âˆ€ f : (s : S) â†’ E s â†’áµ‡ â„, âˆ« Ï‰ in A, âˆ s, f s (X s Ï‰) âˆ‚P =
      P.real A * âˆ« Ï‰, âˆ s, f s (X s Ï‰) âˆ‚P) :
    IndepSets ğ’œ {A | MeasurableSet[MeasurableSpace.pi.comap (fun Ï‰ s â†¦ X s Ï‰)] A} P :=
  indepSets_iff_singleton_indepSets.2 fun A hA â†¦ IndepFun.singleton_indepSets_of_indicator
    (indicator_indepFun_pi_of_prod_bcf (mğ’œ A hA) mX (h A hA))

lemma indepSets_comap_pi_of_bcf
    {ğ’œ : Set (Set Î©)} (mğ’œ : âˆ€ A âˆˆ ğ’œ, NullMeasurableSet A P) (mX : âˆ€ s, AEMeasurable (X s) P)
    (h : âˆ€ A âˆˆ ğ’œ, âˆ€ f : (Î  s, E s) â†’áµ‡ â„, âˆ« Ï‰ in A, f (X Â· Ï‰) âˆ‚P = P.real A * âˆ« Ï‰, f (X Â· Ï‰) âˆ‚P) :
    IndepSets ğ’œ {A | MeasurableSet[MeasurableSpace.pi.comap (fun Ï‰ s â†¦ X s Ï‰)] A} P :=
  indepSets_iff_singleton_indepSets.2 fun A hA â†¦ IndepFun.singleton_indepSets_of_indicator
    (indicator_indepFun_pi_of_bcf (mğ’œ A hA) mX (h A hA))

lemma indepSets_comap_of_bcf
    {ğ’œ : Set (Set Î©)} (mğ’œ : âˆ€ A âˆˆ ğ’œ, NullMeasurableSet A P) (mZ : AEMeasurable Z P)
    (h : âˆ€ A âˆˆ ğ’œ, âˆ€ f : G â†’áµ‡ â„, âˆ« Ï‰ in A, f (Z Ï‰) âˆ‚P = P.real A * âˆ« Ï‰, f (Z Ï‰) âˆ‚P) :
    IndepSets ğ’œ {A | MeasurableSet[MeasurableSpace.comap Z inferInstance] A} P :=
  indepSets_iff_singleton_indepSets.2 fun A hA â†¦ IndepFun.singleton_indepSets_of_indicator
    (indicator_indepFun_of_bcf (mğ’œ A hA) mZ (h A hA))

end IndepSets

section Indep

lemma indep_comap_pi_of_prod_bcf (hm : m â‰¤ mÎ©) (mX : âˆ€ s, AEMeasurable (X s) P)
    (h : âˆ€ A, MeasurableSet[m] A â†’ âˆ€ f : (s : S) â†’ E s â†’áµ‡ â„,
      âˆ« Ï‰ in A, âˆ s, f s (X s Ï‰) âˆ‚P = P.real A * âˆ« Ï‰, âˆ s, f s (X s Ï‰) âˆ‚P) :
    Indep m (MeasurableSpace.pi.comap (fun Ï‰ s â†¦ X s Ï‰)) P :=
  (Indep_iff_IndepSets _ _ P).2
    (indepSets_comap_pi_of_prod_bcf (fun A hA â†¦ (hm A hA).nullMeasurableSet) mX h)

/-- A sigma-algebra $\mathcal{A}$ and a family of random variables $(X_1, ..., X_p)$ are independent
if for all set $A \in \mathcal{A}$ and for all real bounded continuous function $f$,
$$P[\mathbb{I}_A f(X_1, ..., X_p)] = P(A) P[f(X_1, ..., X_p)].$$ -/
lemma indep_comap_pi_of_bcf (hm : m â‰¤ mÎ©) (mX : âˆ€ s, AEMeasurable (X s) P)
    (h : âˆ€ A, MeasurableSet[m] A â†’ âˆ€ f : (Î  s, E s) â†’áµ‡ â„,
      âˆ« Ï‰ in A, f (X Â· Ï‰) âˆ‚P = P.real A * âˆ« Ï‰, f (X Â· Ï‰) âˆ‚P) :
    Indep m (MeasurableSpace.pi.comap (fun Ï‰ s â†¦ X s Ï‰)) P :=
  (Indep_iff_IndepSets _ _ P).2
    (indepSets_comap_pi_of_bcf (fun A hA â†¦ (hm A hA).nullMeasurableSet) mX h)

/-- A sigma-algebra $\mathcal{A}$ and a random variable $X$ are independent
if for all set $A \in \mathcal{A}$ and for all real bounded continuous function $f$,
$$P[\mathbb{I}_A f(X)] = P(A) P[f(X)].$$ -/
lemma indep_comap_of_bcf (hm : m â‰¤ mÎ©) (mZ : AEMeasurable Z P)
    (h : âˆ€ A, MeasurableSet[m] A â†’ âˆ€ f : G â†’áµ‡ â„,
      âˆ« Ï‰ in A, f (Z Ï‰) âˆ‚P = P.real A * âˆ« Ï‰, f (Z Ï‰) âˆ‚P) :
    Indep m (MeasurableSpace.comap Z inferInstance) P :=
  (Indep_iff_IndepSets _ _ P).2
    (indepSets_comap_of_bcf (fun A hA â†¦ (hm A hA).nullMeasurableSet) mZ h)

end Indep

end Fintype

section Process

section IndepFun

variable [IsZeroOrProbabilityMeasure P]

lemma process_indepFun_process_of_prod_bcf
    (mX : âˆ€ s, Measurable (X s)) (mY : âˆ€ t, Measurable (Y t))
    (h : âˆ€ (I : Finset S) (J : Finset T) (f : (s : I) â†’ E s â†’áµ‡ â„) (g : (t : J) â†’ F t â†’áµ‡ â„),
      P[(âˆ s, f s âˆ˜ (X s)) * (âˆ t, g t âˆ˜ (Y t))] = P[âˆ s, f s âˆ˜ (X s)] * P[âˆ t, g t âˆ˜ (Y t)]) :
    IndepFun (fun Ï‰ s â†¦ X s Ï‰) (fun Ï‰ t â†¦ Y t Ï‰) P :=
  IndepFun.process_indepFun_process mX mY
    fun I J â†¦ pi_indepFun_pi_of_prod_bcf (by fun_prop) (by fun_prop) (h I J)

/-- Two stochastic processes $(X_s)_{s \in S}$ and $(Y_t)_{t \in T}$ are independent if
for all $s_1, ..., s_p \in S, t_1, ..., t_q \in T$ and
for all real bounded continuous functions $f$ and $g$,
$$P[f(X_{s_1}, ..., X_{s_p}) g(Y_{t_1}, ..., Y_{t_q})] =
P[f(X_{s_1}, ..., X_{s_p})] * P[g(Y_{t_1}, ..., Y_{t_q})].$$ -/
lemma process_indepFun_process_of_bcf
    (mX : âˆ€ s, Measurable (X s)) (mY : âˆ€ t, Measurable (Y t))
    (h : âˆ€ (I : Finset S) (J : Finset T) (f : (Î  s : I, E s) â†’áµ‡ â„) (g : (Î  t : J, F t) â†’áµ‡ â„),
      P[fun Ï‰ â†¦ f (X Â· Ï‰) * g (Y Â· Ï‰)] = P[fun Ï‰ â†¦ f (X Â· Ï‰)] * P[fun Ï‰ â†¦ g (Y Â· Ï‰)]) :
    IndepFun (fun Ï‰ s â†¦ X s Ï‰) (fun Ï‰ t â†¦ Y t Ï‰) P :=
  IndepFun.process_indepFun_process mX mY
    fun I J â†¦ pi_indepFun_pi_of_bcf (by fun_prop) (by fun_prop) (h I J)

lemma indepFun_process_of_prod_bcf
    (mZ : AEMeasurable Z P) (mY : âˆ€ t, Measurable (Y t))
    (h : âˆ€ (f : G â†’áµ‡ â„) (J : Finset T) (g : (t : J) â†’ F t â†’áµ‡ â„),
      P[f âˆ˜ Z * (âˆ t, g t âˆ˜ (Y t))] = P[f âˆ˜ Z] * P[âˆ t, g t âˆ˜ (Y t)]) :
    IndepFun Z (fun Ï‰ t â†¦ Y t Ï‰) P :=
  IndepFun.indepFun_process mZ mY fun J â†¦
    indepFun_pi_of_prod_bcf (by fun_prop) (by fun_prop) (h Â· J)

lemma indepFun_process_of_bcf
    (mZ : AEMeasurable Z P) (mY : âˆ€ t, Measurable (Y t))
    (h : âˆ€ (f : G â†’áµ‡ â„) (J : Finset T) (g : (Î  t : J, F t) â†’áµ‡ â„),
      P[fun Ï‰ â†¦ f (Z Ï‰) * g (Y Â· Ï‰)] = P[f âˆ˜ Z] * P[fun Ï‰ â†¦ g (Y Â· Ï‰)]) :
    IndepFun Z (fun Ï‰ t â†¦ Y t Ï‰) P :=
  IndepFun.indepFun_process mZ mY fun J â†¦ indepFun_pi_of_bcf (by fun_prop) (by fun_prop) (h Â· J)

lemma process_indepFun_of_prod_bcf
    (mX : âˆ€ s, Measurable (X s)) (mU : AEMeasurable U P)
    (h : âˆ€ (I : Finset S) (f : (s : I) â†’ E s â†’áµ‡ â„) (g : H â†’áµ‡ â„),
      P[(âˆ s, f s âˆ˜ (X s)) * g âˆ˜ U] = P[âˆ s, f s âˆ˜ (X s)] * P[g âˆ˜ U]) :
    IndepFun (fun Ï‰ s â†¦ X s Ï‰) U P :=
  IndepFun.process_indepFun mX mU fun I â†¦ pi_indepFun_of_prod_bcf (by fun_prop) (by fun_prop) (h I)

lemma process_indepFun_of_bcf
    (mX : âˆ€ s, Measurable (X s)) (mU : AEMeasurable U P)
    (h : âˆ€ (I : Finset S) (f : (Î  s : I, E s) â†’áµ‡ â„) (g : H â†’áµ‡ â„),
      P[fun Ï‰ â†¦ f (X Â· Ï‰) * g (U Ï‰)] = P[fun Ï‰ â†¦ f (X Â· Ï‰)] * P[g âˆ˜ U]) :
    IndepFun (fun Ï‰ s â†¦ X s Ï‰) U P :=
  IndepFun.process_indepFun mX mU fun I â†¦ pi_indepFun_of_bcf (by fun_prop) (by fun_prop) (h I)

end IndepFun

variable [IsProbabilityMeasure P]

section Indicator

lemma indicator_indepFun_process_of_prod_bcf
    {A : Set Î©} (mA : NullMeasurableSet A P) (mX : âˆ€ s, Measurable (X s))
    (h : âˆ€ (I : Finset S) (f : (s : I) â†’ E s â†’áµ‡ â„),
      âˆ« Ï‰ in A, âˆ s, f s (X s Ï‰) âˆ‚P = P.real A * âˆ« Ï‰, âˆ s, f s (X s Ï‰) âˆ‚P) :
    IndepFun (A.indicator (1 : Î© â†’ â„)) (fun Ï‰ s â†¦ X s Ï‰) P :=
  IndepFun.indepFun_process ((aemeasurable_indicator_const_iff 1).2 mA) mX
    fun I â†¦ indicator_indepFun_pi_of_prod_bcf mA (by fun_prop) (h I)

/-- The indicator of a set $A$ and a stochastic process $(X_s)_{s \in S}$ are independent if
for all $s_1, ..., s_p \in S$ and for all real bounded continuous function $f$,
$$P[\mathbb{I}_A f(X_{s_1}, ..., X_{s_p})] =
P(A) P[f(X_{s_1}, ..., X_{s_p})].$$ -/
lemma indicator_indepFun_process_of_bcf
    {A : Set Î©} (mA : NullMeasurableSet A P) (mX : âˆ€ s, Measurable (X s))
    (h : âˆ€ (I : Finset S) (f : (Î  s : I, E s) â†’áµ‡ â„),
      âˆ« Ï‰ in A, f (X Â· Ï‰) âˆ‚P = P.real A * âˆ« Ï‰, f (X Â· Ï‰) âˆ‚P) :
    IndepFun (A.indicator (1 : Î© â†’ â„)) (fun Ï‰ s â†¦ X s Ï‰) P :=
  IndepFun.indepFun_process ((aemeasurable_indicator_const_iff 1).2 mA) mX
    fun I â†¦ indicator_indepFun_pi_of_bcf mA (by fun_prop) (h I)

end Indicator

section IndepSets

lemma indepSets_comap_process_of_prod_bcf
    {ğ’œ : Set (Set Î©)} (mğ’œ : âˆ€ A âˆˆ ğ’œ, NullMeasurableSet A P) (mX : âˆ€ s, Measurable (X s))
    (h : âˆ€ A âˆˆ ğ’œ, âˆ€ (I : Finset S) (f : (s : I) â†’ E s â†’áµ‡ â„),
      âˆ« Ï‰ in A, âˆ s, f s (X s Ï‰) âˆ‚P = P.real A * âˆ« Ï‰, âˆ s, f s (X s Ï‰) âˆ‚P) :
    IndepSets ğ’œ {A | MeasurableSet[MeasurableSpace.pi.comap (fun Ï‰ s â†¦ X s Ï‰)] A} P :=
  indepSets_iff_singleton_indepSets.2 fun A hA â†¦ IndepFun.singleton_indepSets_of_indicator
    (indicator_indepFun_process_of_prod_bcf (mğ’œ A hA) mX (h A hA))

lemma indepSets_comap_process_of_bcf
    {ğ’œ : Set (Set Î©)} (mğ’œ : âˆ€ A âˆˆ ğ’œ, NullMeasurableSet A P) (mX : âˆ€ s, Measurable (X s))
    (h : âˆ€ A âˆˆ ğ’œ, âˆ€ (I : Finset S) (f : (Î  s : I, E s) â†’áµ‡ â„),
      âˆ« Ï‰ in A, f (X Â· Ï‰) âˆ‚P = P.real A * âˆ« Ï‰, f (X Â· Ï‰) âˆ‚P) :
    IndepSets ğ’œ {A | MeasurableSet[MeasurableSpace.pi.comap (fun Ï‰ s â†¦ X s Ï‰)] A} P :=
  indepSets_iff_singleton_indepSets.2 fun A hA â†¦ IndepFun.singleton_indepSets_of_indicator
    (indicator_indepFun_process_of_bcf (mğ’œ A hA) mX (h A hA))

end IndepSets

section Indep

lemma indep_comap_process_of_prod_bcf
    (hm : m â‰¤ mÎ©) (mX : âˆ€ s, Measurable (X s))
    (h : âˆ€ A, MeasurableSet[m] A â†’ âˆ€ (I : Finset S) (f : (s : I) â†’ E s â†’áµ‡ â„),
      âˆ« Ï‰ in A, âˆ s, f s (X s Ï‰) âˆ‚P = P.real A * âˆ« Ï‰, âˆ s, f s (X s Ï‰) âˆ‚P) :
    Indep m (MeasurableSpace.pi.comap (fun Ï‰ s â†¦ X s Ï‰)) P :=
  (Indep_iff_IndepSets _ _ P).2
    (indepSets_comap_process_of_prod_bcf (fun A hA â†¦ (hm A hA).nullMeasurableSet) mX h)

/-- A sigma-algebra $\mathcal{A}$ and a stochastic process $(X_s)_{s \in S}$ are independent if
for all $A \in \mathcal{A}$, for all $s_1, ..., s_p \in S$ and
for all real bounded continuous function $f$,
$$P[\mathbb{I}_A f(X_{s_1}, ..., X_{s_p})] =
P(A) P[f(X_{s_1}, ..., X_{s_p})].$$ -/
lemma indep_comap_process_of_bcf
    (hm : m â‰¤ mÎ©) (mX : âˆ€ s, Measurable (X s))
    (h : âˆ€ A, MeasurableSet[m] A â†’ âˆ€ (I : Finset S) (f : (Î  s : I, E s) â†’áµ‡ â„),
      âˆ« Ï‰ in A, f (X Â· Ï‰) âˆ‚P = P.real A * âˆ« Ï‰, f (X Â· Ï‰) âˆ‚P) :
    Indep m (MeasurableSpace.pi.comap (fun Ï‰ s â†¦ X s Ï‰)) P :=
  (Indep_iff_IndepSets _ _ P).2
    (indepSets_comap_process_of_bcf (fun A hA â†¦ (hm A hA).nullMeasurableSet) mX h)

end Indep

end Process
