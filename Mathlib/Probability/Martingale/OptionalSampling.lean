/-
Copyright (c) 2023 RÃ©my Degenne. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: RÃ©my Degenne
-/
import Mathlib.Order.SuccPred.LinearLocallyFinite
import Mathlib.Probability.Martingale.Basic

#align_import probability.martingale.optional_sampling from "leanprover-community/mathlib"@"ba074af83b6cf54c3104e59402b39410ddbd6dca"

/-!
# Optional sampling theorem

If `Ï„` is a bounded stopping time and `Ïƒ` is another stopping time, then the value of a martingale
`f` at the stopping time `min Ï„ Ïƒ` is almost everywhere equal to
`Î¼[stoppedValue f Ï„ | hÏƒ.measurableSpace]`.

## Main results

* `stoppedValue_ae_eq_condexp_of_le_const`: the value of a martingale `f` at a stopping time `Ï„`
  bounded by `n` is the conditional expectation of `f n` with respect to the Ïƒ-algebra generated by
  `Ï„`.
* `stoppedValue_ae_eq_condexp_of_le`: if `Ï„` and `Ïƒ` are two stopping times with `Ïƒ â‰¤ Ï„` and `Ï„` is
  bounded, then the value of a martingale `f` at `Ïƒ` is the conditional expectation of its value at
  `Ï„` with respect to the Ïƒ-algebra generated by `Ïƒ`.
* `stoppedValue_min_ae_eq_condexp`: the optional sampling theorem. If `Ï„` is a bounded stopping
  time and `Ïƒ` is another stopping time, then the value of a martingale `f` at the stopping time
  `min Ï„ Ïƒ` is almost everywhere equal to the conditional expectation of `f` stopped at `Ï„`
  with respect to the Ïƒ-algebra generated by `Ïƒ`.

-/


open scoped MeasureTheory BigOperators ENNReal

open TopologicalSpace

-- Porting note: move to `Topology/Instances/Discrete`
instance (priority := 100) DiscreteTopology.secondCountableTopology_of_countable {Î± : Type*}
    [TopologicalSpace Î±] [DiscreteTopology Î±] [Countable Î±] : SecondCountableTopology Î± :=
  @DiscreteTopology.secondCountableTopology_of_encodable _ _ _ (Encodable.ofCountable _)
#align discrete_topology.second_countable_topology_of_countable DiscreteTopology.secondCountableTopology_of_countable

namespace MeasureTheory

namespace Martingale

variable {Î© E : Type*} {m : MeasurableSpace Î©} {Î¼ : Measure Î©} [NormedAddCommGroup E]
  [NormedSpace â„ E] [CompleteSpace E]

section FirstCountableTopology

variable {Î¹ : Type*} [LinearOrder Î¹] [TopologicalSpace Î¹] [OrderTopology Î¹]
  [FirstCountableTopology Î¹] {â„± : Filtration Î¹ m} [SigmaFiniteFiltration Î¼ â„±] {Ï„ Ïƒ : Î© â†’ Î¹}
  {f : Î¹ â†’ Î© â†’ E} {i n : Î¹}

theorem condexp_stopping_time_ae_eq_restrict_eq_const
    [(Filter.atTop : Filter Î¹).IsCountablyGenerated] (h : Martingale f â„± Î¼)
    (hÏ„ : IsStoppingTime â„± Ï„) [SigmaFinite (Î¼.trim hÏ„.measurableSpace_le)] (hin : i â‰¤ n) :
    Î¼[f n|hÏ„.measurableSpace] =áµ[Î¼.restrict {x | Ï„ x = i}] f i := by
  refine' Filter.EventuallyEq.trans _ (ae_restrict_of_ae (h.condexp_ae_eq hin))
  -- âŠ¢ Î¼[f n|IsStoppingTime.measurableSpace hÏ„] =áµ[Measure.restrict Î¼ {x | Ï„ x = i} â€¦
  refine' condexp_ae_eq_restrict_of_measurableSpace_eq_on hÏ„.measurableSpace_le (â„±.le i)
    (hÏ„.measurableSet_eq' i) fun t => _
  rw [Set.inter_comm _ t, IsStoppingTime.measurableSet_inter_eq_iff]
  -- ğŸ‰ no goals
#align measure_theory.martingale.condexp_stopping_time_ae_eq_restrict_eq_const MeasureTheory.Martingale.condexp_stopping_time_ae_eq_restrict_eq_const

theorem condexp_stopping_time_ae_eq_restrict_eq_const_of_le_const (h : Martingale f â„± Î¼)
    (hÏ„ : IsStoppingTime â„± Ï„) (hÏ„_le : âˆ€ x, Ï„ x â‰¤ n)
    [SigmaFinite (Î¼.trim (hÏ„.measurableSpace_le_of_le hÏ„_le))] (i : Î¹) :
    Î¼[f n|hÏ„.measurableSpace] =áµ[Î¼.restrict {x | Ï„ x = i}] f i := by
  by_cases hin : i â‰¤ n
  -- âŠ¢ Î¼[f n|IsStoppingTime.measurableSpace hÏ„] =áµ[Measure.restrict Î¼ {x | Ï„ x = i} â€¦
  Â· refine' Filter.EventuallyEq.trans _ (ae_restrict_of_ae (h.condexp_ae_eq hin))
    -- âŠ¢ Î¼[f n|IsStoppingTime.measurableSpace hÏ„] =áµ[Measure.restrict Î¼ {x | Ï„ x = i} â€¦
    refine' condexp_ae_eq_restrict_of_measurableSpace_eq_on (hÏ„.measurableSpace_le_of_le hÏ„_le)
      (â„±.le i) (hÏ„.measurableSet_eq' i) fun t => _
    rw [Set.inter_comm _ t, IsStoppingTime.measurableSet_inter_eq_iff]
    -- ğŸ‰ no goals
  Â· suffices {x : Î© | Ï„ x = i} = âˆ… by simp [this]; norm_cast
    -- âŠ¢ {x | Ï„ x = i} = âˆ…
    ext1 x
    -- âŠ¢ x âˆˆ {x | Ï„ x = i} â†” x âˆˆ âˆ…
    simp only [Set.mem_setOf_eq, Set.mem_empty_iff_false, iff_false_iff]
    -- âŠ¢ Â¬Ï„ x = i
    rintro rfl
    -- âŠ¢ False
    exact hin (hÏ„_le x)
    -- ğŸ‰ no goals
#align measure_theory.martingale.condexp_stopping_time_ae_eq_restrict_eq_const_of_le_const MeasureTheory.Martingale.condexp_stopping_time_ae_eq_restrict_eq_const_of_le_const

theorem stoppedValue_ae_eq_restrict_eq (h : Martingale f â„± Î¼) (hÏ„ : IsStoppingTime â„± Ï„)
    (hÏ„_le : âˆ€ x, Ï„ x â‰¤ n) [SigmaFinite (Î¼.trim (hÏ„.measurableSpace_le_of_le hÏ„_le))] (i : Î¹) :
    stoppedValue f Ï„ =áµ[Î¼.restrict {x | Ï„ x = i}] Î¼[f n|hÏ„.measurableSpace] := by
  refine' Filter.EventuallyEq.trans _
    (condexp_stopping_time_ae_eq_restrict_eq_const_of_le_const h hÏ„ hÏ„_le i).symm
  rw [Filter.EventuallyEq, ae_restrict_iff' (â„±.le _ _ (hÏ„.measurableSet_eq i))]
  -- âŠ¢ âˆ€áµ (x : Î©) âˆ‚Î¼, x âˆˆ {Ï‰ | Ï„ Ï‰ = i} â†’ stoppedValue f Ï„ x = f i x
  refine' Filter.eventually_of_forall fun x hx => _
  -- âŠ¢ stoppedValue f Ï„ x = f i x
  rw [Set.mem_setOf_eq] at hx
  -- âŠ¢ stoppedValue f Ï„ x = f i x
  simp_rw [stoppedValue, hx]
  -- ğŸ‰ no goals
#align measure_theory.martingale.stopped_value_ae_eq_restrict_eq MeasureTheory.Martingale.stoppedValue_ae_eq_restrict_eq

/-- The value of a martingale `f` at a stopping time `Ï„` bounded by `n` is the conditional
expectation of `f n` with respect to the Ïƒ-algebra generated by `Ï„`. -/
theorem stoppedValue_ae_eq_condexp_of_le_const_of_countable_range (h : Martingale f â„± Î¼)
    (hÏ„ : IsStoppingTime â„± Ï„) (hÏ„_le : âˆ€ x, Ï„ x â‰¤ n) (h_countable_range : (Set.range Ï„).Countable)
    [SigmaFinite (Î¼.trim (hÏ„.measurableSpace_le_of_le hÏ„_le))] :
    stoppedValue f Ï„ =áµ[Î¼] Î¼[f n|hÏ„.measurableSpace] := by
  have : Set.univ = â‹ƒ i âˆˆ Set.range Ï„, {x | Ï„ x = i} := by
    ext1 x
    simp only [Set.mem_univ, Set.mem_range, true_and_iff, Set.iUnion_exists, Set.iUnion_iUnion_eq',
      Set.mem_iUnion, Set.mem_setOf_eq, exists_apply_eq_apply']
  nth_rw 1 [â† @Measure.restrict_univ Î© _ Î¼]
  -- âŠ¢ stoppedValue f Ï„ =áµ[Measure.restrict Î¼ Set.univ] Î¼[f n|IsStoppingTime.measur â€¦
  rw [this, ae_eq_restrict_biUnion_iff _ h_countable_range]
  -- âŠ¢ âˆ€ (i : Î¹), i âˆˆ Set.range Ï„ â†’ stoppedValue f Ï„ =áµ[Measure.restrict Î¼ {x | Ï„ x â€¦
  exact fun i _ => stoppedValue_ae_eq_restrict_eq h _ hÏ„_le i
  -- ğŸ‰ no goals
#align measure_theory.martingale.stopped_value_ae_eq_condexp_of_le_const_of_countable_range MeasureTheory.Martingale.stoppedValue_ae_eq_condexp_of_le_const_of_countable_range

/-- The value of a martingale `f` at a stopping time `Ï„` bounded by `n` is the conditional
expectation of `f n` with respect to the Ïƒ-algebra generated by `Ï„`. -/
theorem stoppedValue_ae_eq_condexp_of_le_const [Countable Î¹] (h : Martingale f â„± Î¼)
    (hÏ„ : IsStoppingTime â„± Ï„) (hÏ„_le : âˆ€ x, Ï„ x â‰¤ n)
    [SigmaFinite (Î¼.trim (hÏ„.measurableSpace_le_of_le hÏ„_le))] :
    stoppedValue f Ï„ =áµ[Î¼] Î¼[f n|hÏ„.measurableSpace] :=
  h.stoppedValue_ae_eq_condexp_of_le_const_of_countable_range hÏ„ hÏ„_le (Set.to_countable _)
#align measure_theory.martingale.stopped_value_ae_eq_condexp_of_le_const MeasureTheory.Martingale.stoppedValue_ae_eq_condexp_of_le_const

/-- If `Ï„` and `Ïƒ` are two stopping times with `Ïƒ â‰¤ Ï„` and `Ï„` is bounded, then the value of a
martingale `f` at `Ïƒ` is the conditional expectation of its value at `Ï„` with respect to the
Ïƒ-algebra generated by `Ïƒ`. -/
theorem stoppedValue_ae_eq_condexp_of_le_of_countable_range (h : Martingale f â„± Î¼)
    (hÏ„ : IsStoppingTime â„± Ï„) (hÏƒ : IsStoppingTime â„± Ïƒ) (hÏƒ_le_Ï„ : Ïƒ â‰¤ Ï„) (hÏ„_le : âˆ€ x, Ï„ x â‰¤ n)
    (hÏ„_countable_range : (Set.range Ï„).Countable) (hÏƒ_countable_range : (Set.range Ïƒ).Countable)
    [SigmaFinite (Î¼.trim (hÏƒ.measurableSpace_le_of_le fun x => (hÏƒ_le_Ï„ x).trans (hÏ„_le x)))] :
    stoppedValue f Ïƒ =áµ[Î¼] Î¼[stoppedValue f Ï„|hÏƒ.measurableSpace] := by
  have : SigmaFinite (Î¼.trim (hÏ„.measurableSpace_le_of_le hÏ„_le)) :=
    sigmaFiniteTrim_mono _ (IsStoppingTime.measurableSpace_mono hÏƒ hÏ„ hÏƒ_le_Ï„)
  have : Î¼[stoppedValue f Ï„|hÏƒ.measurableSpace] =áµ[Î¼]
      Î¼[Î¼[f n|hÏ„.measurableSpace]|hÏƒ.measurableSpace] := condexp_congr_ae
    (h.stoppedValue_ae_eq_condexp_of_le_const_of_countable_range hÏ„ hÏ„_le hÏ„_countable_range)
  refine' (Filter.EventuallyEq.trans _
    (condexp_condexp_of_le _ (hÏ„.measurableSpace_le_of_le hÏ„_le)).symm).trans this.symm
  Â· exact h.stoppedValue_ae_eq_condexp_of_le_const_of_countable_range hÏƒ
      (fun x => (hÏƒ_le_Ï„ x).trans (hÏ„_le x)) hÏƒ_countable_range
  Â· exact hÏƒ.measurableSpace_mono hÏ„ hÏƒ_le_Ï„
    -- ğŸ‰ no goals
#align measure_theory.martingale.stopped_value_ae_eq_condexp_of_le_of_countable_range MeasureTheory.Martingale.stoppedValue_ae_eq_condexp_of_le_of_countable_range

/-- If `Ï„` and `Ïƒ` are two stopping times with `Ïƒ â‰¤ Ï„` and `Ï„` is bounded, then the value of a
martingale `f` at `Ïƒ` is the conditional expectation of its value at `Ï„` with respect to the
Ïƒ-algebra generated by `Ïƒ`. -/
theorem stoppedValue_ae_eq_condexp_of_le [Countable Î¹] (h : Martingale f â„± Î¼)
    (hÏ„ : IsStoppingTime â„± Ï„) (hÏƒ : IsStoppingTime â„± Ïƒ) (hÏƒ_le_Ï„ : Ïƒ â‰¤ Ï„) (hÏ„_le : âˆ€ x, Ï„ x â‰¤ n)
    [SigmaFinite (Î¼.trim hÏƒ.measurableSpace_le)] :
    stoppedValue f Ïƒ =áµ[Î¼] Î¼[stoppedValue f Ï„|hÏƒ.measurableSpace] :=
  h.stoppedValue_ae_eq_condexp_of_le_of_countable_range hÏ„ hÏƒ hÏƒ_le_Ï„ hÏ„_le (Set.to_countable _)
    (Set.to_countable _)
#align measure_theory.martingale.stopped_value_ae_eq_condexp_of_le MeasureTheory.Martingale.stoppedValue_ae_eq_condexp_of_le

end FirstCountableTopology

section SubsetOfNat

/-! In the following results the index set verifies
`[LinearOrder Î¹] [LocallyFiniteOrder Î¹] [OrderBot Î¹]`, which means that it is order-isomorphic to
a subset of `â„•`. `Î¹` is equipped with the discrete topology, which is also the order topology,
and is a measurable space with the Borel Ïƒ-algebra. -/


variable {Î¹ : Type*} [LinearOrder Î¹] [LocallyFiniteOrder Î¹] [OrderBot Î¹] [TopologicalSpace Î¹]
  [DiscreteTopology Î¹] [MeasurableSpace Î¹] [BorelSpace Î¹] [MeasurableSpace E] [BorelSpace E]
  [SecondCountableTopology E] {â„± : Filtration Î¹ m} {Ï„ Ïƒ : Î© â†’ Î¹} {f : Î¹ â†’ Î© â†’ E} {i n : Î¹}

theorem condexp_stoppedValue_stopping_time_ae_eq_restrict_le (h : Martingale f â„± Î¼)
    (hÏ„ : IsStoppingTime â„± Ï„) (hÏƒ : IsStoppingTime â„± Ïƒ) [SigmaFinite (Î¼.trim hÏƒ.measurableSpace_le)]
    (hÏ„_le : âˆ€ x, Ï„ x â‰¤ n) :
    Î¼[stoppedValue f Ï„|hÏƒ.measurableSpace] =áµ[Î¼.restrict {x : Î© | Ï„ x â‰¤ Ïƒ x}] stoppedValue f Ï„ := by
  rw [ae_eq_restrict_iff_indicator_ae_eq
    (hÏ„.measurableSpace_le _ (hÏ„.measurableSet_le_stopping_time hÏƒ))]
  refine' (condexp_indicator (integrable_stoppedValue Î¹ hÏ„ h.integrable hÏ„_le)
    (hÏ„.measurableSet_stopping_time_le hÏƒ)).symm.trans _
  have h_int :
      Integrable ({Ï‰ : Î© | Ï„ Ï‰ â‰¤ Ïƒ Ï‰}.indicator (stoppedValue (fun n : Î¹ => f n) Ï„)) Î¼ := by
    refine' (integrable_stoppedValue Î¹ hÏ„ h.integrable hÏ„_le).indicator _
    exact hÏ„.measurableSpace_le _ (hÏ„.measurableSet_le_stopping_time hÏƒ)
  have h_meas : AEStronglyMeasurable' hÏƒ.measurableSpace
      ({Ï‰ : Î© | Ï„ Ï‰ â‰¤ Ïƒ Ï‰}.indicator (stoppedValue (fun n : Î¹ => f n) Ï„)) Î¼ := by
    refine' StronglyMeasurable.aeStronglyMeasurable' _
    refine' StronglyMeasurable.stronglyMeasurable_of_measurableSpace_le_on
      (hÏ„.measurableSet_le_stopping_time hÏƒ) _ _ _
    Â· intro t ht
      rw [Set.inter_comm _ t] at ht âŠ¢
      rw [hÏ„.measurableSet_inter_le_iff hÏƒ, IsStoppingTime.measurableSet_min_iff hÏ„ hÏƒ] at ht
      exact ht.2
    Â· refine' StronglyMeasurable.indicator _ (hÏ„.measurableSet_le_stopping_time hÏƒ)
      refine' Measurable.stronglyMeasurable _
      exact measurable_stoppedValue h.adapted.progMeasurable_of_discrete hÏ„
    Â· intro x hx
      simp only [hx, Set.indicator_of_not_mem, not_false_iff]
  exact condexp_of_aestronglyMeasurable' hÏƒ.measurableSpace_le h_meas h_int
  -- ğŸ‰ no goals
#align measure_theory.martingale.condexp_stopped_value_stopping_time_ae_eq_restrict_le MeasureTheory.Martingale.condexp_stoppedValue_stopping_time_ae_eq_restrict_le

/-- **Optional Sampling theorem**. If `Ï„` is a bounded stopping time and `Ïƒ` is another stopping
time, then the value of a martingale `f` at the stopping time `min Ï„ Ïƒ` is almost everywhere equal
to the conditional expectation of `f` stopped at `Ï„` with respect to the Ïƒ-algebra generated
by `Ïƒ`. -/
theorem stoppedValue_min_ae_eq_condexp [SigmaFiniteFiltration Î¼ â„±] (h : Martingale f â„± Î¼)
    (hÏ„ : IsStoppingTime â„± Ï„) (hÏƒ : IsStoppingTime â„± Ïƒ) {n : Î¹} (hÏ„_le : âˆ€ x, Ï„ x â‰¤ n)
    [h_sf_min : SigmaFinite (Î¼.trim (hÏ„.min hÏƒ).measurableSpace_le)] :
    (stoppedValue f fun x => min (Ïƒ x) (Ï„ x)) =áµ[Î¼] Î¼[stoppedValue f Ï„|hÏƒ.measurableSpace] := by
  refine'
    (h.stoppedValue_ae_eq_condexp_of_le hÏ„ (hÏƒ.min hÏ„) (fun x => min_le_right _ _) hÏ„_le).trans _
  refine' ae_of_ae_restrict_of_ae_restrict_compl {x | Ïƒ x â‰¤ Ï„ x} _ _
  -- âŠ¢ âˆ€áµ (x : Î©) âˆ‚Measure.restrict Î¼ {x | Ïƒ x â‰¤ Ï„ x}, (Î¼[stoppedValue f Ï„|IsStoppi â€¦
  Â· exact condexp_min_stopping_time_ae_eq_restrict_le hÏƒ hÏ„
    -- ğŸ‰ no goals
  Â· suffices Î¼[stoppedValue f Ï„|(hÏƒ.min hÏ„).measurableSpace] =áµ[Î¼.restrict {x | Ï„ x â‰¤ Ïƒ x}]
        Î¼[stoppedValue f Ï„|hÏƒ.measurableSpace] by
      rw [ae_restrict_iff' (hÏƒ.measurableSpace_le _ (hÏƒ.measurableSet_le_stopping_time hÏ„).compl)]
      rw [Filter.EventuallyEq, ae_restrict_iff'] at this
      swap; Â· exact hÏ„.measurableSpace_le _ (hÏ„.measurableSet_le_stopping_time hÏƒ)
      filter_upwards [this] with x hx hx_mem
      simp only [Set.mem_compl_iff, Set.mem_setOf_eq, not_le] at hx_mem
      exact hx hx_mem.le
    apply Filter.EventuallyEq.trans _ ((condexp_min_stopping_time_ae_eq_restrict_le hÏ„ hÏƒ).trans _)
    Â· exact stoppedValue f Ï„
      -- ğŸ‰ no goals
    Â· rw [IsStoppingTime.measurableSpace_min hÏƒ, IsStoppingTime.measurableSpace_min hÏ„, inf_comm]
      -- ğŸ‰ no goals
    Â· have h1 : Î¼[stoppedValue f Ï„|hÏ„.measurableSpace] = stoppedValue f Ï„ := by
        refine' condexp_of_stronglyMeasurable hÏ„.measurableSpace_le _ _
        Â· refine' Measurable.stronglyMeasurable _
          exact measurable_stoppedValue h.adapted.progMeasurable_of_discrete hÏ„
        Â· exact integrable_stoppedValue Î¹ hÏ„ h.integrable hÏ„_le
      rw [h1]
      -- âŠ¢ stoppedValue f Ï„ =áµ[Measure.restrict Î¼ {x | Ï„ x â‰¤ Ïƒ x}] Î¼[stoppedValue f Ï„|I â€¦
      exact (condexp_stoppedValue_stopping_time_ae_eq_restrict_le h hÏ„ hÏƒ hÏ„_le).symm
      -- ğŸ‰ no goals
#align measure_theory.martingale.stopped_value_min_ae_eq_condexp MeasureTheory.Martingale.stoppedValue_min_ae_eq_condexp

end SubsetOfNat

end Martingale

end MeasureTheory
