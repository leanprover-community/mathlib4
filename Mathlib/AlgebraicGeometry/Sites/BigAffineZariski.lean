/-
Copyright (c) 2025 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau
-/

import Mathlib.AlgebraicGeometry.Cover.Open
import Mathlib.AlgebraicGeometry.GammaSpecAdjunction
import Mathlib.AlgebraicGeometry.Sites.BigZariski
import Mathlib.CategoryTheory.Sites.DenseSubsite.InducedTopology
import Mathlib.RingTheory.Ideal.Pointwise

/-!
# The Big Zariski Site on the Opposite Category of Commutative Rings

In this file we define the Zariski topology on `CommRingCat·µí·µñ`, noting that this category is
equivalent to the category of affine schemes.

## Main Definitions

- `CommRingCat.zariskiTopology`: The Zariski topology on `CommRingCat·µí·µñ`, constructed using the
  induced topology from the Zariski topology on the category of schemes via the functor
  `AlgebraicGeometry.Scheme.Spec` : `CommRingCat·µí·µñ ‚•§ Scheme`.
- `CommRingCat.standardPretopology`: A pretopology on `CommRingCat·µí·µñ` formed by considering
  standard covers of `Spec R[1/f‚±º] ‚ü∂ Spec R` where the `(f‚ÇÅ, ‚ãØ, f‚Çô) = R`.

## Main Results

- `zariski_eq_toGrothendieck_standard`: The Zariski topology on `CommRingCat·µí·µñ` is equal to the
  Grothendieck topology generated by the standard pretopology.
- `sheafEquiv`: An equivalence between the category of sheaves on the Zariski site of
  `CommRingCat·µí·µñ` and on the Zariski site of `Scheme`. In other words, a sheaf on `CommRingCat·µí·µñ`
  can be extended uniquely to `Scheme`.
- `isSheaf_zariski_iff_isSheaf_standard`: A presheaf on `CommRingCat·µí·µñ` is a sheaf for the Zariski
  topology if and only if it satisfies the sheaf condition for any standard cover of `Spec R`.
  Recall that a standard cover of `Spec R` is a cover by `Spec R[1/f‚±º]` where `(f‚ÇÅ, ‚ãØ, f‚Çô) = R`.

-/

universe u v

open CategoryTheory Functor Opposite Category Limits

set_option linter.unusedVariables false in
/-- A type synonym to make a canonical `Algebra` structure where `r ‚Ä¢ s` is defeq to
`algebraMap R S r * s`. -/
def Canon (_R : Type u) (S : Type v) : Type v := S

namespace Canon

variable (R : Type u) (S : Type v)

/-- A "constructor" to not abuse defeq. -/
def of (x : S) : Canon R S := x

/-- A "projection" to not abuse defeq. -/
def down (x : Canon R S) : S := x

instance [Semiring S] : Semiring (Canon R S) :=
  inferInstanceAs (Semiring S)

/-- The ring structure is still the same, it is not affected by how the scalar multiplication is
defined. -/
@[simps] def ringEquiv [Semiring S] : Canon R S ‚âÉ+* S where
  toFun := down R S
  invFun := of R S
  map_add' _ _ := rfl
  map_mul' _ _ := rfl
  left_inv _ := rfl
  right_inv _ := rfl

instance [CommSemiring S] : CommSemiring (Canon R S) :=
  inferInstanceAs (CommSemiring S)

instance [Ring S] : Ring (Canon R S) :=
  inferInstanceAs (Ring S)

instance [CommRing S] : CommRing (Canon R S) :=
  inferInstanceAs (CommRing S)

instance [Field S] : Field (Canon R S) :=
  inferInstanceAs (Field S)

/-- The `algebraMap` from `R` to the new `S`. -/
def toCanon [CommSemiring R] [Semiring S] [Algebra R S] : R ‚Üí+* Canon R S :=
  _root_.algebraMap R S

instance [CommSemiring R] [Semiring S] [Algebra R S] :
    Algebra R (Canon R S) where
  algebraMap := toCanon R S
  smul r x := toCanon R S r * x
  commutes' r x := Algebra.commutes r (show S from x)
  smul_def' _ _ := rfl

example [CommSemiring R] [CommSemiring S] [Algebra R S] :
    (algebraMap R (Canon R S)).toAlgebra = inferInstanceAs (Algebra R (Canon R S)) :=
  rfl

/-- Even though the scalar multiplications are not defeq, they are still isomorphic as algebras. -/
def algEquiv [CommSemiring R] [CommSemiring S] [Algebra R S] :
    Canon R S ‚âÉ‚Çê[R] S :=
  AlgEquiv.ofRingEquiv (f := ringEquiv R S) fun _ ‚Ü¶ rfl

instance [CommSemiring R] [CommSemiring S] [Algebra R S] (M : Submonoid R) [IsLocalization M S] :
    IsLocalization M (Canon R S) :=
  IsLocalization.isLocalization_of_algEquiv M (algEquiv R S).symm

end Canon


open AlgebraicGeometry AffineScheme Scheme TensorProduct

namespace CommRingCat

/-- A scheme is covered by affines. -/
instance : IsCoverDense Scheme.Spec Scheme.zariskiTopology.{u} where
  is_cover X := ‚ü®.ofArrows (Spec ‚àò X.affineOpenCover.obj) X.affineOpenCover.map,
    ‚ü®X.affineOpenCover.openCover, rfl‚ü©,
    fun _ u ‚ü®j‚ü© ‚Ü¶ ‚ü®‚ü®op (X.affineOpenCover.obj j), ùüô _, X.affineOpenCover.map j, by rw [id_comp]‚ü©‚ü©‚ü©

/-- The Zariski topology on the opposite category of commutative rings, constructed using the
induced topology from the Zariski topology on the category of schemes. -/
def zariskiTopology : GrothendieckTopology CommRingCat.{u}·µí·µñ :=
  inducedTopology Scheme.Spec Scheme.zariskiTopology

/-- A standard system of covering `Spec R` by localizations `Spec R[1/f‚±º]` where `(f‚ÇÅ, ‚ãØ, f‚Çô) = R`.
The indexing type is required to be in `Type 0` and a `Fintype`. -/
structure StandardSystem (R : Type u) [CommRing R] : Type (u+1) where
  /-- The indexing type. -/
  J : Type
  /-- The indexing type is required to be finite. -/
  fintype : Fintype J := by infer_instance
  /-- The elements `f‚±º` whose localisations `Spec R[1/f‚±º]` will cover `Spec R`. -/
  elem : J ‚Üí R
  /-- The elements span the unit ideal. -/
  span_eq_top : Ideal.span (Set.range elem) = ‚ä§
  /-- The localizations. They do not have to be the canonical one, they can be any localization
  satisfying the `IsLocalization` predicate. -/
  loc : J ‚Üí Type u := fun j ‚Ü¶ Localization.Away (elem j)
  /-- The localizations are commutative rings. -/
  commRing : ‚àÄ j, CommRing (loc j) := by infer_instance
  /-- The localizations are algebras over the base ring. -/
  algebra : ‚àÄ j, Algebra R (loc j) := by infer_instance
  /-- The localizations are localizations. -/
  away : ‚àÄ j, IsLocalization.Away (elem j) (loc j) := by infer_instance

namespace StandardSystem

attribute [simp] fintype span_eq_top
attribute [instance] fintype commRing algebra away

/-- The object `Spec R[1/f‚±º]` for the given index `j`. -/
@[simp] abbrev obj {R : Type u} [CommRing R] (s : StandardSystem R) (j : s.J) : CommRingCat·µí·µñ :=
  op (of (s.loc j))

/-- The morphism from `Spec R[1/f‚±º]` to `Spec R` that will form a part of the cover. -/
@[simp]
abbrev hom {R : Type u} [CommRing R] (s : StandardSystem R) (j : s.J) : s.obj j ‚ü∂ op (of R) :=
  op (ofHom (algebraMap R (s.loc j)))

/-- A standard cover of `Spec R` by `Spec R[1/f‚±º]` where `{f‚±º}‚±º` is a finite set that generates the
unit ideal of R. -/
inductive cover {R : Type u} [CommRing R] (s : StandardSystem R) : Presieve (op (of R)) where
  | mk (j : s.J) : cover s (s.hom j)

/-- The standard system obtained from an isomorphism. Any isomorphism is a localization away from
`1`. -/
abbrev ofIsIso {R S : CommRingCat.{u}·µí·µñ} (f : S ‚ü∂ R) [IsIso f] : StandardSystem ‚Üë(unop R) where
  J := Unit
  elem j := 1
  span_eq_top := by rw [Set.range_const, Ideal.span_singleton_one]
  loc j := ‚Üë(unop S)
  algebra j := f.unop.hom.toAlgebra
  away j := letI := f.unop.hom.toAlgebra; haveI := isIso_unop f;
    IsLocalization.away_of_isUnit_of_bijective _ isUnit_one
      (by convert (CategoryTheory.isIso_iff_bijective ((forget CommRingCat).map f.unop)).1 <|
        inferInstance)

-- MOVE
@[ext] lemma _root_.Presieve.ext {C : Type u} [Category C] {X : C} {p q : Presieve X}
    (h : ‚àÄ (Y : C) (u : Y ‚ü∂ X), p u ‚Üî q u) : p = q :=
  funext fun Y ‚Ü¶ funext fun f ‚Ü¶ propext <| h Y f

@[simp] lemma ofIsIso_cover {R S : CommRingCat.{u}·µí·µñ} (f : S ‚ü∂ R) [IsIso f] :
    (ofIsIso f).cover = Presieve.singleton f := by
  ext Y u; constructor
  ¬∑ rintro ‚ü®j‚ü©; exact ‚ü®‚ü©
  ¬∑ rintro ‚ü®‚ü©; exact ‚ü®()‚ü©

/-- If `œÜ : R ‚Üí+* S` is a ring homomorphism and we have `(f‚±º)‚±º` that generate the unit ideal of R,
then `(œÜ f‚±º)‚±º` generate the unit ideal of `S`. -/
noncomputable abbrev baseChange {R S : Type u} [CommRing R] [CommRing S] (f : R ‚Üí+* S)
    (s : StandardSystem R)
    (loc' : s.J ‚Üí Type u) [‚àÄ j, CommRing (loc' j)] [‚àÄ j, Algebra S (loc' j)]
    [‚àÄ j : s.J, IsLocalization.Away (f (s.elem j)) (loc' j)] :
    StandardSystem S where
  J := s.J
  elem j := f (s.elem j)
  span_eq_top := by rw [Set.range_comp', ‚Üê Ideal.map_span, s.span_eq_top, Ideal.map_top]
  loc := loc'

/-- A canoncial pullback cone in `CommRingCat·µí·µñ`. -/
noncomputable def _root_.CommRingCat.pullbackConeOp {X Y Z : CommRingCat.{u}·µí·µñ}
    (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : PullbackCone f g :=
  letI := f.unop.hom.toAlgebra
  letI := g.unop.hom.toAlgebra
  PullbackCone.mk (W := op (of (Canon X.unop (X.unop ‚äó[Z.unop] Y.unop))))
    (op (ofHom (algebraMap _ _)))
    (op (ofHom Algebra.TensorProduct.includeRight.toRingHom))
    congr(op (ofHom $Algebra.TensorProduct.includeLeftRingHom_comp_algebraMap))

instance (C : Type u) [Category.{v} C] : Trans (Iso (C := C)) Iso Iso where
  trans := Iso.trans

/-- The `pullbackConeOp` is canonically isomorphic to the opposite of the `pushoutCocone` defined
in `CommRingCat`. (Note that the tensor products have "different" algebra structures in the sense
that they are equal but not defeq.) -/
noncomputable def _root_.CommRingCat.pullbackConeOpIsoPullback {X Y Z : CommRingCat.{u}·µí·µñ}
    (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :
    letI := f.unop.hom.toAlgebra
    letI := g.unop.hom.toAlgebra
    pullbackConeOp f g ‚âÖ (pushoutCocone Z.unop X.unop Y.unop).op :=
  PullbackCone.ext (Iso.op (RingEquiv.toCommRingCatIso (Canon.ringEquiv _ _).symm))

/-- The `pullbackConeOp` is a pullback. -/
noncomputable def _root_.CommRingCat.pullbackConeOpIsLimit {X Y Z : CommRingCat.{u}·µí·µñ}
    (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : IsLimit (pullbackConeOp f g) :=
  letI := f.unop.hom.toAlgebra
  letI := g.unop.hom.toAlgebra
  have := IsColimit.coconePointUniqueUpToIso (pushout.isColimit _ _)
      (pushoutCoconeIsColimit Z.unop X.unop Y.unop)
  .ofIsoLimit (PushoutCocone.isColimitEquivIsLimitOp _ <| pushoutCoconeIsColimit _ _ _)
    (pullbackConeOpIsoPullback f g).symm

/-- The `pullbackConeOp` is isomorphic to the pullback. -/
noncomputable def _root_.CommRingCat.pullbackConeOpIso {X Y Z : CommRingCat.{u}·µí·µñ}
    (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : (pullbackConeOp f g).pt ‚âÖ pullback f g :=
  (pullbackConeOpIsLimit f g).conePointUniqueUpToIso (limit.isLimit _)


section Bind

variable {R : Type u} [CommRing R] (s : StandardSystem R)
  (t : (j : s.J) ‚Üí StandardSystem (s.loc j))
  (j : s.J) (tj : StandardSystem (s.loc j)) (k : tj.J)

/-- An auxiliary definition for `bind`ing standard systems. Given `(f‚ÇÅ, ‚ãØ, f‚Çô) = R`, and then
for a given `f‚±º` given a similar covering of `R[1/f‚±º]`, i.e. `(f‚±º‚ÇÅ, ‚ãØ, f‚±º‚Çò) = R[1/f‚±º]`, we
first choose a representative of `f‚±º·µ¢` inside `R`. -/
noncomputable def bindElem : R :=
  (IsLocalization.Away.sec (s.elem j) (tj.elem k)).1

lemma associated_bindElem :
    Associated (algebraMap R (s.loc j) (bindElem s j tj k)) (tj.elem k) := by
  unfold bindElem
  rw [‚Üê IsLocalization.Away.sec_spec, map_pow]
  exact associated_mul_unit_left _ _ (.pow _ <| IsLocalization.Away.algebraMap_isUnit _)

instance : IsLocalization.Away (algebraMap R (s.loc j) (bindElem s j tj k)) (tj.loc k) :=
  IsLocalization.Away.of_associated (associated_bindElem s j tj k).symm

theorem span_map_bindElem_eq_top :
    Ideal.span (Set.range (algebraMap R (s.loc j) ‚àò bindElem s j tj)) = ‚ä§ := by
  rw [eq_top_iff, ‚Üê tj.span_eq_top, Ideal.span_le, Set.range_subset_iff]
  exact fun k ‚Ü¶ let ‚ü®u, hu‚ü© := associated_bindElem s j tj k
    hu ‚ñ∏ Ideal.mul_mem_right _ _ (Ideal.subset_span <| Set.mem_range_self _)

theorem exists_pow_mem_span_bindElem :
    ‚àÉ n : ‚Ñï, s.elem j ^ n ‚àà Ideal.span (Set.range (bindElem s j tj)) := by
  have := span_map_bindElem_eq_top s j tj
  rw [Ideal.eq_top_iff_one, Set.range_comp, ‚Üê Ideal.map_span, ‚Üê map_one (algebraMap R (s.loc j)),
    IsLocalization.algebraMap_mem_map_algebraMap_iff (Submonoid.powers (s.elem j))] at this
  obtain ‚ü®_, ‚ü®n, rfl‚ü©, hn‚ü© := this
  exact ‚ü®n, by simpa using hn‚ü©

theorem exists_pow_mem_span_mul_bindElem :
    ‚àÉ n : ‚Ñï, s.elem j ^ n ‚àà Ideal.span (Set.range fun k : tj.J ‚Ü¶ s.elem j * bindElem s j tj k) := by
  obtain ‚ü®n, hn‚ü© := exists_pow_mem_span_bindElem s j tj
  refine ‚ü®n + 1, ?_‚ü©
  rw [pow_succ']
  convert Ideal.mul_mem_mul (Ideal.mem_span_singleton_self _) hn
  rw [Ideal.span_mul_span', Set.singleton_mul, ‚Üê Set.range_comp]
  rfl

theorem span_bindElem_eq_top :
    Ideal.span (Set.range fun jk : (j : s.J) √ó (t j).J ‚Ü¶
      s.elem jk.fst * s.bindElem jk.fst (t jk.fst) jk.snd) = ‚ä§ := by
  have (j : s.J) := exists_pow_mem_span_mul_bindElem s j (t j)
  choose n hn using this
  rw [eq_top_iff, ‚Üê Ideal.span_pow_eq_top _ s.span_eq_top (‚àë j : s.J, n j), Ideal.span_le,
    ‚Üê Set.range_comp, Set.range_subset_iff]
  refine fun j ‚Ü¶ Ideal.mem_of_dvd _ ?_ (Ideal.span_mono ?_ (hn j))
  ¬∑ exact pow_dvd_pow _ (Finset.single_le_sum (fun _ _ ‚Ü¶ Nat.zero_le _) (Finset.mem_univ _))
  ¬∑ exact Set.range_subset_iff.2 fun k ‚Ü¶ ‚ü®‚ü®j, k‚ü©, rfl‚ü©

/-- The `bind`ing of covers. If `(f‚ÇÅ, ‚ãØ, f‚Çô) = R`, and for each `j` we are also given cover
`(f‚±º‚ÇÅ, ‚ãØ, f‚±º‚Çò) = R[1/f‚±º]` (`m` depends on `j`), then we can combine them to form a larger cover of
`R`. More specifically, we choose representatives `r‚±º·µ¢ : R` for `f‚±º‚ÇÅ : R[1/f‚±º]`, then the element
is `f‚±º * r‚±º·µ¢`. This has the property that `R[1/f‚±º][1/f‚±º·µ¢] = R[1/(f‚±º * r‚±º·µ¢)]`, in the sense that
the former is a localization away from the chosen `f‚±º * r‚±º·µ¢` over `R`. -/
noncomputable def bind [‚àÄ j k, Algebra R ((t j).loc k)]
    [‚àÄ j k, IsScalarTower R (s.loc j) ((t j).loc k)] :
    StandardSystem R where
  J := (j : s.J) √ó (t j).J
  elem j := s.elem j.fst * s.bindElem j.fst (t j.fst) j.snd
  span_eq_top := span_bindElem_eq_top s t
  loc j := ((t j.fst).loc j.snd)
  away j := IsLocalization.Away.mul' (s.loc j.fst) _ _ _

theorem bind_cover (t'' : ‚àÄ (Y : CommRingCat·µí·µñ) (u : Y ‚ü∂ op (of R)), s.cover u ‚Üí
      StandardSystem (Y.unop))
    (ht : ‚àÄ j, t'' (s.obj j) (s.hom j) (cover.mk j) = t j)
    [‚àÄ j k, Algebra R ((t j).loc k)]
    [‚àÄ j k, IsScalarTower R (s.loc j) ((t j).loc k)] :
    (s.bind t).cover = s.cover.bind fun Y u hu ‚Ü¶ (t'' Y u hu).cover := by
  ext Y u; constructor
  ¬∑ rintro ‚ü®‚ü®j, k‚ü©‚ü©
    refine ‚ü®_, (t j).hom k, s.hom j, cover.mk j, ?_, ?_‚ü©
    ¬∑ simp only [ht]; exact ‚ü®k‚ü©
    ¬∑ have := IsScalarTower.algebraMap_eq R (s.loc j) ((t j).loc k)
      exact congr(op (ofHom $this.symm))
  ¬∑ rintro ‚ü®Z, v, _, ‚ü®j‚ü©, ‚ü®k‚ü©, rfl‚ü©
    revert k
    rw [ht]
    intro k
    convert cover.mk (s := s.bind t) ‚ü®j, k‚ü©
    have := IsScalarTower.algebraMap_eq R (s.loc j) ((t j).loc k)
    exact congr(op (ofHom $this.symm))

end Bind

end StandardSystem

open StandardSystem

/-- A pretopology on `CommRingCat·µí·µñ` formed by considering standard covers of
`Spec R[1/f‚±º] ‚ü∂ Spec R` where the `(f‚ÇÅ, ‚ãØ, f‚Çô) = R`. -/
def standardPretopology : Pretopology CommRingCat.{u}·µí·µñ where
  coverings R := { u : Presieve R | ‚àÉ (s : StandardSystem ‚Üë(unop R)), s.cover = u }
  has_isos R S f _ := ‚ü®ofIsIso f, ofIsIso_cover f‚ü©
  pullbacks R S u := by
    rintro _ ‚ü®s, rfl‚ü©
    letI := u.unop.hom.toAlgebra
    let e (j : s.J) : pullback (s.hom j) u ‚âÖ
        op (of (Canon S.unop (S.unop ‚äó[R.unop] Canon R.unop (s.loc j)))) :=
      (pullbackSymmetry _ _).trans (pullbackConeOpIso u (s.hom j)).symm
    letI (j : s.J) := (pullback.snd (s.hom j) u).unop.hom.toAlgebra
    letI (j : s.J) := (e j).hom.unop.hom.toAlgebra
    have h (j : s.J) : (e j).hom ‚â´ (pullbackConeOp u (s.hom j)).fst = pullback.snd (s.hom j) u := by
      unfold e pullbackConeOpIso
      rw [Iso.trans_hom, assoc, Iso.symm_hom, IsLimit.conePointUniqueUpToIso_inv_comp,
        pullbackSymmetry, IsLimit.conePointUniqueUpToIso_hom_comp]
      rfl
    haveI (j : s.J) : IsScalarTower (S.unop)
        (Canon S.unop (S.unop ‚äó[R.unop] Canon R.unop (s.loc j)))
        (pullback (s.hom j) u).unop :=
      .of_algebraMap_eq' congr((unop $((h j).symm)).hom)
    let t := (s.baseChange (algebraMap R.unop S.unop) fun j : s.J ‚Ü¶
      Canon S.unop (S.unop ‚äó[R.unop] Canon R.unop (s.loc j))).bind fun j : s.J ‚Ü¶
        ofIsIso (e j).hom
    use t; ext Y v; constructor
    ¬∑ rintro ‚ü®j, ‚ü®‚ü©‚ü©
      exact ‚ü®s.obj j, s.hom j, ‚ü®_‚ü©‚ü©
    ¬∑ rintro ‚ü®_, _, ‚ü®j‚ü©‚ü©
      exact cover.mk (s := t) ‚ü®j, Unit.unit‚ü©
  transitive := by
    rintro R _ t'' ‚ü®s, rfl‚ü© ht'
    choose t' ht using ht'
    let t (j : s.J) : StandardSystem (s.loc j) := t' (s.hom j) (cover.mk j)
    letI (j : s.J) (k : (t j).J) : Algebra (unop R).1 ((t j).loc k) :=
      Algebra.compHom _ (algebraMap (unop R).1 (s.loc j))
    have (j : s.J) (k : (t j).J) : IsScalarTower (‚Üë(unop R)) (s.loc j) ((t j).loc k) :=
      .of_algebraMap_eq fun r ‚Ü¶ rfl
    use s.bind t
    convert s.bind_cover t t' (fun j ‚Ü¶ rfl); exact (ht _ _).symm

open PrimeSpectrum

/-- An open immersion `u : U ‚ü∂ Spec R` is covered by `Spec R[1/f]`. In other words, for every
`p : U`, there is `f : R` such that `p ‚àà D(f) ‚äÜ U`, i.e. such that `Spec R[1/f] ‚ü∂ Spec R`
factors through `u`. -/
lemma _root_.AlgebraicGeometry.Scheme.Hom.exists_factor
    {R : Type u} [CommRing R] {U : Scheme.{u}} (u : U ‚ü∂ Spec (of R)) [IsOpenImmersion u] (p : U) :
    ‚àÉ f : R, ‚àÉ g : Spec (of (Localization.Away f)) ‚ü∂ U,
      basicOpen f ‚â§ u.opensRange ‚àß
      IsOpenImmersion g ‚àß
      g ‚â´ u = Spec.map (ofHom (algebraMap R (Localization.Away f))) ‚àß
      p ‚àà Set.range g.base := by
  obtain ‚ü®_, ‚ü®(f : R), rfl‚ü©, hpf, hfu‚ü© :=
    isTopologicalBasis_basic_opens.exists_subset_of_mem_open
      (u := u.opensRange.1) ‚ü®p, rfl‚ü© u.opensRange.2
  let g := AlgebraicGeometry.IsOpenImmersion.lift u
    (Spec.map (ofHom (algebraMap R (Localization.Away f))))
    ((localization_away_comap_range (Localization.Away f) f).trans_subset hfu)
  have hgu : g ‚â´ u = _ := IsOpenImmersion.lift_fac _ _ _
  refine ‚ü®f, g, hfu, inferInstance, hgu, u.isOpenEmbedding.injective.mem_set_image.mp ?_‚ü©
  rw [‚Üê Set.range_comp, ‚Üê ContinuousMap.coe_comp, ‚Üê TopCat.hom_comp, ‚Üê comp_coeBase, hgu,
    Spec.map_base, hom_ofHom, TopCat.hom_ofHom]
  convert hpf using 1; exact localization_away_comap_range _ _

-- NOFIX
/-- Given a family of schemes with morphisms to `X` satisfying `P` that jointly cover `X`,
`AffineCover.mkOfCovers` is an associated `P`-cover of `X`.

See `Cover.mkOfCovers`. -/
@[simps] noncomputable def _root_.AlgebraicGeometry.Scheme.AffineCover.mkOfCovers
    {P : MorphismProperty Scheme.{u}} {X : Scheme.{u}}
    (J : Type v) (obj : J ‚Üí CommRingCat.{u}) (map : ‚àÄ j, Spec (obj j) ‚ü∂ X)
    (covers : ‚àÄ x : X, ‚àÉ (j : J) (y : Spec (obj j)), (map j).base y = x)
    (map_prop : ‚àÄ (j : J), P (map j) := by infer_instance) :
    AffineCover P X where
  J := J
  obj := obj
  map := map
  f x := (covers x).choose
  covers x := (covers x).choose_spec
  map_prop := map_prop

/-- Given an open cover of `Spec R`, refine it to a cover by `Spec R[1/f]`. -/
@[simps! (isSimp := False)] noncomputable
def _root_.AlgebraicGeometry.Scheme.Cover.refinementSpec {R : CommRingCat.{u}}
    (U : Cover IsOpenImmersion (Spec R)) : AffineOpenCover (Spec R) :=
  .mkOfCovers
    (J := { f : R // ‚àÉ j : U.J, basicOpen f ‚â§ (U.map j).opensRange })
    (obj := fun f ‚Ü¶ of (Localization.Away f.val))
    (map := fun f ‚Ü¶ Spec.map (ofHom (algebraMap R (Localization.Away f.val))))
    (covers := fun x ‚Ü¶
      let ‚ü®j, y, hjyx‚ü© := U.exists_eq x
      let ‚ü®f, g, hfj, hg, hgj, p, hypg‚ü© := (U.map j).exists_factor y
      ‚ü®‚ü®f, j, hfj‚ü©, p, hjyx ‚ñ∏ hypg ‚ñ∏ congr(($hgj.symm).base p)‚ü©)

/-- Given an open cover indexed by a `Fintype`, shrink the fintype into `Type 0`. -/
@[simps!] noncomputable def _root_.AlgebraicGeometry.Scheme.OpenCover.shrink {X : Scheme.{u}}
    (U : OpenCover.{v} X) [Fintype U.J] : OpenCover.{0} X :=
  U.reindex (equivShrink.{0} U.J).symm

/-- Actually a subcover (the indexing type is a subtype of `U.J`). -/
@[simps!] noncomputable def _root_.AlgebraicGeometry.Scheme.OpenCover.finiteSubcover'
    {X : Scheme.{u}} [CompactSpace X] (U : OpenCover.{v} X) :
    OpenCover.{v} X where
  J := { j : U.J // ‚àÉ x : U.finiteSubcover.J, U.f x.val = j }
  obj j := U.obj j.val
  map j := U.map j.val
  f x := ‚ü®U.f (U.finiteSubcover.f x).val, _, rfl‚ü©
  covers := U.finiteSubcover.covers

noncomputable instance {X : Scheme.{u}} [CompactSpace X] (U : OpenCover.{v} X) :
    Fintype U.finiteSubcover'.J :=
  open Classical in Fintype.ofSurjective (fun x ‚Ü¶ ‚ü®U.f x.val, x, rfl‚ü©) fun j ‚Ü¶ by
    obtain ‚ü®_, _, rfl‚ü© := j; exact ‚ü®_, rfl‚ü©

open TopologicalSpace

/-- An open cover of `Spec R` can be refined to a standard cover in terms of `StandardSystem`. -/
noncomputable def StandardSystem.ofOpenCover {R : CommRingCat.{u}} (U : OpenCover.{v} (Spec R)) :
    StandardSystem R where
  J := U.refinementSpec.openCover.finiteSubcover'.shrink.J
  fintype := .ofEquiv _ (equivShrink _)
  elem j := ((equivShrink _).symm j).val.val
  span_eq_top := by
    set U' := U.refinementSpec.openCover.finiteSubcover'.shrink
    rw [‚Üê iSup_basicOpen_eq_top_iff, Opens.ext_iff, Opens.coe_iSup,
      Opens.coe_top, Set.eq_univ_iff_forall]
    refine fun x ‚Ü¶ Set.mem_iUnion_of_mem (U'.f x) ?_
    convert U'.covers x; exact (localization_away_comap_range _ _).symm

/-- The refinement produced is actually a refinement. -/
lemma StandardSystem.ofOpenCover_exists_factor {R : CommRingCat.{u}}
    (U : OpenCover.{v} (Spec R)) (j : (ofOpenCover U).J) :
    ‚àÉ j' : U.J, ‚àÉ g : Spec (of ((ofOpenCover U).loc j)) ‚ü∂ U.obj j',
      g ‚â´ U.map j' = Scheme.Spec.map ((ofOpenCover U).hom j) := by
  obtain ‚ü®j', hj‚ü© := ((equivShrink _).symm j).val.property
  let g := IsOpenImmersion.lift (U.map j') (Scheme.Spec.map ((ofOpenCover U).hom j))
    ((localization_away_comap_range (Localization.Away _) _).trans_subset hj)
  exact ‚ü®j', g, IsOpenImmersion.lift_fac _ _ _‚ü©

/-- A standard system on `R` produces an affine open cover of `Spec R`.

Note that this differs from `AlgebraicGeometry.Scheme.affineOpenCoverOfSpanRangeEqTop` by not
requiring the localizations to be the canonical `Localization.Away f`. -/
@[simps! (isSimp := False)] noncomputable
def StandardSystem.toAffineOpenCover {R : Type u} [CommRing R]
    (s : StandardSystem R) : AffineOpenCover.{u} (Spec (of R)) :=
  .mkOfCovers
    (J := ULift.{u} s.J)
    (obj := fun j ‚Ü¶ of (s.loc j.down))
    (map := fun j ‚Ü¶ Spec.map (ofHom (algebraMap R (s.loc j.down))))
    (covers := fun x ‚Ü¶ by
      have := iSup_basicOpen_eq_top_iff.mpr s.span_eq_top
      rw [Opens.ext_iff, Opens.coe_iSup, Opens.coe_top, Set.eq_univ_iff_forall] at this
      obtain ‚ü®j, hxj‚ü© := Set.mem_iUnion.mp (this x)
      refine ‚ü®ULift.up j, ?_‚ü©
      rw [‚Üê Set.mem_range]
      convert hxj using 1
      exact localization_away_comap_range _ _)
    (map_prop := fun j ‚Ü¶ AlgebraicGeometry.IsOpenImmersion.of_isLocalization (s.elem j.down))

/-- The Zariski topology on `CommRingCat·µí·µñ` (formed by the induced topology on `Scheme` via
the functor `Scheme.Spec : CommRingCat·µí·µñ ‚•§ Scheme`) is equal to the Grothendieck topology
generated by the standard covers using `Spec R[1/f·µ¢] ‚ü∂ Spec R`.

In other words, an open immersion locally looks like `Spec R[1/f·µ¢] ‚ü∂ Spec R`. -/
lemma zariski_eq_toGrothendieck_standard :
    zariskiTopology.{u} = standardPretopology.toGrothendieck _ := by
  refine le_antisymm ?_ ?_
  ¬∑ rintro X s ‚ü®R, ‚ü®U, rfl‚ü©, hrs‚ü©
    refine ‚ü®_, ‚ü®.ofOpenCover U, rfl‚ü©, ?_‚ü©
    rintro _ _ ‚ü®j‚ü©
    obtain ‚ü®j', f, hf‚ü© := ofOpenCover_exists_factor U j
    obtain ‚ü®Z, g, h, hsg, hjhg‚ü© := @hrs _ _ ‚ü®j'‚ü©
    rw [hjhg, ‚Üê assoc, ‚Üê Spec.map_preimage (f ‚â´ h), Scheme.Spec_map, Scheme.Spec_map,
      ‚Üê Spec.map_comp, Spec.map_inj, ‚Üê op_inj_iff] at hf
    change (Spec.preimage (f ‚â´ h)).op ‚â´ g = (ofOpenCover U).hom j at hf
    exact hf ‚ñ∏ s.downward_closed hsg _
  ¬∑ rintro X u ‚ü®p, ‚ü®s, rfl‚ü©, hsu‚ü©
    refine ‚ü®_, ‚ü®s.toAffineOpenCover.openCover, rfl‚ü©, ?_‚ü©
    rintro _ _ ‚ü®j‚ü©
    exact ‚ü®_, _, ùüô _, hsu _ ‚ü®j.down‚ü©, rfl‚ü©

/-- The category of sheaves on `CommRingCat·µí·µñ` (using the pullback of the Zariski topology via
`Spec`) is equivalent to the category of sheaves on `Scheme` under the Zariski topology.

In other words, any sheaf on `CommRingCat·µí·µñ` can be extended uniquely to a sheaf on `Scheme`. -/
noncomputable def sheafEquiv (A : Type*) [Category.{v} A]
    [‚àÄ X : Scheme·µí·µñ, HasLimitsOfShape (StructuredArrow X Scheme.Spec.op) A] :
    Sheaf zariskiTopology.{u} A ‚âå Sheaf Scheme.zariskiTopology.{u} A :=
  CategoryTheory.Functor.sheafInducedTopologyEquivOfIsCoverDense _ _ _

/-- A lemma to help check the sheaf condition: it suffices to check for the standard cover of
`Spec R[1/f‚±º] ‚ü∂ Spec R` where `(f‚ÇÅ, ‚ãØ, f‚Çô) = R`. -/
@[simp] lemma isSheaf_zariski_iff_isSheaf_standard (p : CommRingCat.{u}·µí·µñ·µí·µñ ‚•§ Type v) :
    Presheaf.IsSheaf zariskiTopology.{u} p ‚Üî
      ‚àÄ (R : CommRingCat.{u}) (s : StandardSystem R), Presieve.IsSheafFor p s.cover := by
  rw [zariski_eq_toGrothendieck_standard, isSheaf_iff_isSheaf_of_type, Presieve.isSheaf_pretopology]
  constructor
  ¬∑ intro h R S; exact h _ ‚ü®S, rfl‚ü©
  ¬∑ rintro h X _ ‚ü®S, rfl‚ü©; exact h X.unop S

end CommRingCat

