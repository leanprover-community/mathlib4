/-
Copyright (c) 2025 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau
-/
import Mathlib.AlgebraicGeometry.PullbackCarrier
import Mathlib.AlgebraicGeometry.Sites.BigZariski
import Mathlib.CategoryTheory.Sites.DenseSubsite.InducedTopology
import Mathlib.CategoryTheory.Sites.Finite
import Mathlib.RingTheory.RingHom.OpenImmersion

/-!
# The Big Zariski Site on the Opposite Category of Commutative Rings

In this file we define the Zariski topology on `CommRingCat·µí·µñ`, noting that this category is
equivalent to the category of affine schemes.

## Main Definitions

- `CommRingCat.zariskiTopology`: The Zariski topology on `CommRingCat·µí·µñ`, constructed using the
  induced topology from the Zariski topology on the category of schemes via the functor
  `AlgebraicGeometry.Scheme.Spec` : `CommRingCat·µí·µñ ‚•§ Scheme`.
- `CommRingCat.zariskiPretopology`: The Zariski pretopology on `CommRingCat·µí·µñ`, consisting of
  presieves that are finite, jointly surjective, and standard open immersions.

## Main Results

- `zariskiTopology_eq_toGrothendieck_zariskiPretopology`: The Zariski topology on `CommRingCat·µí·µñ` is
  equal to the Grothendieck topology generated by the standard pretopology.
- `sheafEquiv`: An equivalence between the category of sheaves on the Zariski site of
  `CommRingCat·µí·µñ` and on the Zariski site of `Scheme`. In other words, a sheaf on `CommRingCat·µí·µñ`
  can be extended uniquely to `Scheme`.

-/

universe u‚ÇÄ v v‚ÇÅ v‚ÇÇ v‚ÇÉ u u‚ÇÅ u‚ÇÇ

open CategoryTheory Functor Opposite Category Limits CommRingCat
open AlgebraicGeometry AffineScheme Scheme TensorProduct PrimeSpectrum

namespace AlgebraicGeometry

namespace Scheme

variable {X : Scheme.{u}} {P : MorphismProperty Scheme.{u}}

/-- Given a family of schemes with morphisms to `X` satisfying `P` that jointly cover `X`,
`AffineCover.mkOfCovers` is an associated `P`-cover of `X`.

See `Cover.mkOfCovers`. -/
@[simps] noncomputable def AffineCover.mkOfCovers
    {P : MorphismProperty Scheme.{u}} {S : Scheme.{u}}
    {I‚ÇÄ : Type v} (X : I‚ÇÄ ‚Üí CommRingCat.{u}) (f : ‚àÄ j, Spec (X j) ‚ü∂ S)
    (covers : ‚àÄ x : S, ‚àÉ (j : I‚ÇÄ) (y : Spec (X j)), (f j).base y = x)
    (map_prop : ‚àÄ (j : I‚ÇÄ), P (f j) := by infer_instance) :
    AffineCover P S where
  I‚ÇÄ := I‚ÇÄ
  X := X
  f := f
  idx x := (covers x).choose
  covers x := (covers x).choose_spec
  map_prop := map_prop

namespace Cover

/-- Package the data of `U‚ÇÅ ‚ü∂ U‚ÇÇ` into a theorem. -/
theorem Hom.exists {U‚ÇÅ U‚ÇÇ : Cover.{v} P X} (h : U‚ÇÅ.Hom U‚ÇÇ) (i‚ÇÅ : U‚ÇÅ.I‚ÇÄ) :
    ‚àÉ (i‚ÇÇ : U‚ÇÇ.I‚ÇÄ) (f : U‚ÇÅ.X i‚ÇÅ ‚ü∂ U‚ÇÇ.X i‚ÇÇ), P f ‚àß f ‚â´ U‚ÇÇ.f i‚ÇÇ = U‚ÇÅ.f i‚ÇÅ :=
  ‚ü®h.idx i‚ÇÅ, h.app i‚ÇÅ, h.app_prop i‚ÇÅ, h.w i‚ÇÅ‚ü©

/-- Given an open cover of `Spec R`, refine it to a cover by `Spec R[1/f]`. -/
@[simps! (isSimp := False) f] noncomputable
def refinementSpec {R : CommRingCat.{u}}
    (U : Cover IsOpenImmersion (Spec R)) : AffineOpenCover (Spec R) :=
  AffineCover.mkOfCovers
    (I‚ÇÄ := { f : R // ‚àÉ j : U.I‚ÇÄ, PrimeSpectrum.basicOpen f ‚â§ (U.f j).opensRange })
    (X := fun f ‚Ü¶ .of (Localization.Away f.val))
    (f := fun f ‚Ü¶ Spec.map (CommRingCat.ofHom (algebraMap R (Localization.Away f.val))))
    (covers := fun x ‚Ü¶
      let ‚ü®j, y, hjyx‚ü© := U.exists_eq x
      let ‚ü®f, g, hfj, hg, hgj, p, hypg‚ü© := (U.f j).exists_factor y
      ‚ü®‚ü®f, j, hfj‚ü©, p, hjyx ‚ñ∏ hypg ‚ñ∏ congr(($hgj.symm).base p)‚ü©)

/-- The `refinementSpec` cover is a refinement of the original cover. -/
noncomputable def refinementSpecHom {R : CommRingCat.{u}} (U : Cover IsOpenImmersion (Spec R)) :
    (refinementSpec U).openCover ‚ü∂ U where
  idx j := j.2.choose
  app j := (U.map_prop j.2.choose).lift _ (Spec.map <| ofHom <| algebraMap _ _) <|
    (localization_away_comap_range (Localization.Away j.1) j.1).trans_subset j.2.choose_spec

end Cover

namespace AffineOpenCover

/-- An arbitrarily chosen finite affine open subcover of an affine open cover of a compact space. -/
@[simps (isSimp := false)] noncomputable
def finiteSubcover {X : Scheme.{u}} [CompactSpace X] (U : AffineOpenCover.{v} X) :
    AffineOpenCover.{u} X where
  I‚ÇÄ := U.openCover.finiteSubcover.I‚ÇÄ
  X i := U.X (U.idx i.val)
  f j := U.f (U.idx j.val)
  idx := U.openCover.finiteSubcover.idx
  covers := U.openCover.finiteSubcover.covers

noncomputable instance {X : Scheme.{u}} [CompactSpace X] (U : AffineOpenCover.{v} X) :
    Fintype U.finiteSubcover.I‚ÇÄ :=
  inferInstanceAs (Fintype (U.openCover.finiteSubcover.I‚ÇÄ))

/-- The finite subcover is a refinement of the original cover. -/
noncomputable def finiteSubcoverHom {X : Scheme.{u}} [CompactSpace X] (U : AffineOpenCover.{u} X) :
    U.finiteSubcover.openCover ‚ü∂ U.openCover where
  idx i := U.idx i.val
  app i := ùüô _

end AffineOpenCover

end Scheme

end AlgebraicGeometry

namespace CommRingCat

/-- A scheme is covered by affines. -/
instance isCoverDense_zariski : IsCoverDense Scheme.Spec Scheme.zariskiTopology.{u} where
  is_cover X := ‚ü®.ofArrows (Spec ‚àò X.affineOpenCover.X) X.affineOpenCover.f,
    ‚ü®X.affineOpenCover.openCover, rfl‚ü©,
    fun _ u ‚ü®j‚ü© ‚Ü¶ ‚ü®‚ü®op (X.affineOpenCover.X j), ùüô _, X.affineOpenCover.f j, by rw [id_comp]‚ü©‚ü©‚ü©

instance : IsCoverDense Scheme.Spec (grothendieckTopology IsOpenImmersion.{u}) :=
  isCoverDense_zariski

/-- The Zariski topology on the opposite category of commutative rings, constructed using the
induced topology from the Zariski topology on the category of schemes. -/
def zariskiTopology : GrothendieckTopology CommRingCat.{u}·µí·µñ :=
  inducedTopology Scheme.Spec Scheme.zariskiTopology

/-- The category of sheaves on `CommRingCat·µí·µñ` (using the pullback of the Zariski topology via
`Spec`) is equivalent to the category of sheaves on `Scheme` under the Zariski topology.

In other words, any sheaf on `CommRingCat·µí·µñ` can be extended uniquely to a sheaf on `Scheme`. -/
noncomputable def sheafEquiv (A : Type*) [Category.{v} A]
    [‚àÄ X : Scheme·µí·µñ, HasLimitsOfShape (StructuredArrow X Scheme.Spec.op) A] :
    Sheaf zariskiTopology.{u} A ‚âå Sheaf Scheme.zariskiTopology.{u} A :=
  CategoryTheory.Functor.sheafInducedTopologyEquivOfIsCoverDense _ _ _

/-- A standard open immersion is one that is a localization map away from some element. -/
def standardOpenImmersion : MorphismProperty CommRingCat.{u} :=
  RingHom.toMorphismProperty RingHom.IsStandardOpenImmersion

@[simp]
lemma standardOpenImmersion_ofHom_eq {R S : Type u} [CommRing R] [CommRing S] (f : R ‚Üí+* S) :
    standardOpenImmersion (ofHom f) = f.IsStandardOpenImmersion := rfl

lemma standardOpenImmersion_ofHom {R S : Type u} [CommRing R] [CommRing S] (f : R ‚Üí+* S) :
    standardOpenImmersion (ofHom f) ‚Üî f.IsStandardOpenImmersion := Iff.rfl

instance : standardOpenImmersion.ContainsIdentities where
  id_mem R := RingHom.IsStandardOpenImmersion.id R

instance : standardOpenImmersion.IsMultiplicative where
  comp_mem _ _ := RingHom.IsStandardOpenImmersion.comp

instance : standardOpenImmersion.op.IsStableUnderBaseChange :=
  @MorphismProperty.IsStableUnderCobaseChange.op _ _ _ <|
    RingHom.isStableUnderCobaseChange_toMorphismProperty_iff.mpr
      RingHom.IsStandardOpenImmersion.isStableUnderBaseChange

/-- The standard pretopology on `CommRingCat·µí·µñ` consists standard open immersions, i.e. those
that are localization maps away from some element. -/
def standardPretopology : Pretopology CommRingCat.{u}·µí·µñ :=
  standardOpenImmersion.op.pretopology

theorem isOpenImmersion_of_mem_standard {X Y : CommRingCat.{u}·µí·µñ} {p : Presieve X}
    (hp : p ‚àà standardPretopology.coverings X) {u : Y ‚ü∂ X} (hu : p u) :
    IsOpenImmersion (Scheme.Spec.map u) := by
  algebraize [u.unop.hom]
  obtain ‚ü®r, hr‚ü© := hp hu
  exact AlgebraicGeometry.IsOpenImmersion.of_isLocalization r

/-- A presieve is jointly surjective if it covers every point in the spectrum. -/
def JointlySurjective (X : CommRingCat.{u}·µí·µñ) (s : Presieve X) : Prop :=
  ‚àÄ p : Spec X.unop, ‚àÉ (Y : CommRingCat·µí·µñ) (u : Y ‚ü∂ X) (_ : s u)
    (q : Spec Y.unop), (Spec.map u.unop).base q = p

/-- The jointly surjective pretopology on `CommRingCat·µí·µñ` consists of jointly surjective presieves.
-/
def jointlySurjective : Pretopology CommRingCat.{u}·µí·µñ where
  coverings X := { s : Presieve X | JointlySurjective X s }
  has_isos X Y f _ y :=
    ‚ü®Y, f, ‚ü®‚ü©, y.comap (inv f.unop).hom, by
      rw [Spec.map_base_apply, ‚Üê comap_comp_apply, ‚Üê hom_comp, IsIso.hom_inv_id]; simp‚ü©
  pullbacks X Y u s hs y :=
    let ‚ü®Z, v, hv, x, hx‚ü© := hs (y.comap u.unop.hom)
    let ‚ü®q, hq‚ü© := Scheme.IsJointlySurjectivePreserving.exists_preimage_snd_triplet_of_prop
      (f := Scheme.Spec.map v) (g := Scheme.Spec.map u) (P := ‚ä§) trivial x y hx
    let e : Scheme.Spec.obj (pullback v u) ‚âÖ pullback (Scheme.Spec.map v) (Scheme.Spec.map u) :=
      PreservesPullback.iso _ _ _
    ‚ü®_, _, ‚ü®_, _, hv‚ü©, e.inv.base q, by
      rw [‚Üê hq, ‚Üê PreservesPullback.iso_inv_snd, comp_base_apply]; rfl‚ü©
  transitive X s t hs ht z :=
    let ‚ü®Y, v, hv, y, hy‚ü© := hs z
    let ‚ü®Z, u, hu, x, hx‚ü© := ht v hv y
    ‚ü®Z, u ‚â´ v, ‚ü®_, _, _, hv, hu, rfl‚ü©, x, by simp [hx, hy]‚ü©

open PrimeSpectrum

/-- Shrink a given open cover. -/
@[simps!] noncomputable def _root_.AlgebraicGeometry.Scheme.OpenCover.shrink {X : Scheme.{u}}
    (U : OpenCover.{v} X) [Small.{u‚ÇÄ} U.I‚ÇÄ] : OpenCover.{u‚ÇÄ} X :=
  U.reindex (equivShrink.{u‚ÇÄ} U.I‚ÇÄ).symm

/-- Actually a subcover (the indexing type is a subtype of `U.J`). -/
@[simps!] noncomputable def _root_.AlgebraicGeometry.Scheme.OpenCover.finiteSubcover'
    {X : Scheme.{u}} [CompactSpace X] (U : OpenCover.{v} X) :
    OpenCover.{v} X where
  I‚ÇÄ := { i : U.I‚ÇÄ // ‚àÉ x : U.finiteSubcover.I‚ÇÄ, U.idx x.val = i }
  X i := U.X i.val
  f i := U.f i.val
  idx x := ‚ü®U.idx (U.finiteSubcover.idx x).val, _, rfl‚ü©
  covers := U.finiteSubcover.covers

noncomputable instance {X : Scheme.{u}} [CompactSpace X] (U : OpenCover.{v} X) :
    Fintype U.finiteSubcover'.I‚ÇÄ :=
  open Classical in Fintype.ofSurjective (fun x ‚Ü¶ ‚ü®U.idx x.val, x, rfl‚ü©) fun j ‚Ü¶ by
    obtain ‚ü®_, _, rfl‚ü© := j; exact ‚ü®_, rfl‚ü©

open TopologicalSpace

/-- Intersection of standard, jointly surjective, and finite. -/
def zariskiPretopology : Pretopology CommRingCat.{u}·µí·µñ :=
  standardPretopology ‚äì (jointlySurjective ‚äì .finite _)

/-- The presieve that corresponds to an affine cover. -/
def _root_.CategoryTheory.Presieve.ofAffineCover {X : CommRingCat.{u}·µí·µñ}
    {P : MorphismProperty Scheme.{u}} (U : AffineCover.{v} P (Spec X.unop)) :
    Presieve X :=
  fun Y u ‚Ü¶ ‚àÉ (j : U.I‚ÇÄ) (h : Y = op (U.X j)), u = eqToHom h ‚â´ (Spec.preimage (U.f j)).op

open Presieve

theorem jointlySurjective_ofCover {X : CommRingCat.{u}·µí·µñ}
    {P : MorphismProperty Scheme.{u}} (U : AffineCover.{v} P (Spec X.unop)) :
    JointlySurjective X (.ofAffineCover U) :=
  fun p ‚Ü¶ let ‚ü®y, hy‚ü© := U.covers p
  ‚ü®op <| U.X (U.idx p), (Spec.preimage <| U.f (U.idx p)).op, ‚ü®_, rfl, rfl‚ü©, y, by
    rwa [Quiver.Hom.unop_op, Spec.map_preimage]‚ü©

theorem finite_ofCover {X : CommRingCat.{u}·µí·µñ}
    {P : MorphismProperty Scheme.{u}} (U : AffineCover.{v} P (Spec X.unop)) [Finite U.I‚ÇÄ] :
    Pretopology.finite _ X (.ofAffineCover U) := by
  refine Set.finite_coe_iff.2 <| Finite.of_surjective
    (fun i : U.I‚ÇÄ ‚Ü¶ ‚ü®‚ü®_, _‚ü©, i, rfl, by rw [eqToHom_refl, id_comp]‚ü©)
    fun ‚ü®‚ü®fst, snd‚ü©, j, h‚ÇÅ, h‚ÇÇ‚ü© ‚Ü¶ ‚ü®j, ?_‚ü©
  dsimp only at h‚ÇÅ h‚ÇÇ; subst h‚ÇÅ
  rw [eqToHom_refl, id_comp] at h‚ÇÇ; subst h‚ÇÇ; rfl

lemma zariskiTopology_eq_toGrothendieck_zariskiPretopology :
    zariskiTopology.{u} = zariskiPretopology.toGrothendieck := by
  unfold zariskiTopology Scheme.zariskiTopology
  ext X s
  constructor
  ¬∑ rintro ‚ü®-, ‚ü®U, rfl‚ü©, hus‚ü©
    set U' := U.refinementSpec.finiteSubcover
    refine ‚ü®.ofAffineCover U', ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ rintro _ _ ‚ü®j, rfl, rfl‚ü©
      rw [AffineOpenCover.finiteSubcover_f, Cover.refinementSpec_f,
        Spec.preimage_map, eqToHom_refl, id_comp, MorphismProperty.op, Quiver.Hom.unop_op,
        standardOpenImmersion_ofHom, RingHom.isStandardOpenImmersion_algebraMap]
      infer_instance
    ¬∑ exact jointlySurjective_ofCover U'
    ¬∑ exact finite_ofCover U'
    ¬∑ rintro _ _ ‚ü®j', rfl, h‚ü©
      rw [eqToHom_refl, id_comp] at h; subst h
      obtain ‚ü®j, f, hf, hfj‚ü© := (U.refinementSpec.finiteSubcoverHom ‚â´ U.refinementSpecHom).exists j'
      obtain ‚ü®Z, g, h, hsg, hjhg‚ü© := hus _ ‚ü®j‚ü©
      rw [‚Üê AffineOpenCover.openCover_f, ‚Üê hfj, hjhg, ‚Üê assoc, Spec.preimage_comp,
        Scheme.Spec_map, Spec.preimage_map, op_comp, Quiver.Hom.op_unop]
      exact s.downward_closed hsg _
  ¬∑ rintro ‚ü®p, ‚ü®std, surj, fin‚ü©, hsu‚ü©
    rw [mem_inducedTopology_sieves_iff, grothendieckTopology_eq_inf]
    refine ‚ü®p.map Scheme.Spec, ‚ü®fun x ‚Ü¶ ?_, ?_‚ü©, ?_‚ü©
    ¬∑ obtain ‚ü®Y, u, hu, y, rfl‚ü© := surj x
      exact ‚ü®Scheme.Spec.obj Y, y, Scheme.Spec.map u, ‚ü®hu‚ü©, rfl‚ü©
    ¬∑ exact fun _ _ ‚ü®hu‚ü© ‚Ü¶ isOpenImmersion_of_mem_standard std hu
    ¬∑ rw [‚Üê Sieve.generate_le_iff, Sieve.generate_map_eq_functorPushforward]
      exact Sieve.functorPushforward_monotone _ _ ((Sieve.generate_le_iff _ _).mpr hsu)

end CommRingCat
