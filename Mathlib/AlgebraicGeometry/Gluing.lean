/-
Copyright (c) 2022 Andrew Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Andrew Yang

! This file was ported from Lean 3 source module algebraic_geometry.gluing
! leanprover-community/mathlib commit 533f62f4dd62a5aad24a04326e6e787c8f7e98b1
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.AlgebraicGeometry.PresheafedSpace.Gluing
import Mathbin.AlgebraicGeometry.OpenImmersion.Scheme

/-!
# Gluing Schemes

Given a family of gluing data of schemes, we may glue them together.

## Main definitions

* `algebraic_geometry.Scheme.glue_data`: A structure containing the family of gluing data.
* `algebraic_geometry.Scheme.glue_data.glued`: The glued scheme.
    This is defined as the multicoequalizer of `‚àê V i j ‚áâ ‚àê U i`, so that the general colimit API
    can be used.
* `algebraic_geometry.Scheme.glue_data.Œπ`: The immersion `Œπ i : U i ‚ü∂ glued` for each `i : J`.
* `algebraic_geometry.Scheme.glue_data.iso_carrier`: The isomorphism between the underlying space
  of the glued scheme and the gluing of the underlying topological spaces.
* `algebraic_geometry.Scheme.open_cover.glue_data`: The glue data associated with an open cover.
* `algebraic_geometry.Scheme.open_cover.from_glue_data`: The canonical morphism
  `ùí∞.glue_data.glued ‚ü∂ X`. This has an `is_iso` instance.
* `algebraic_geometry.Scheme.open_cover.glue_morphisms`: We may glue a family of compatible
  morphisms defined on an open cover of a scheme.

## Main results

* `algebraic_geometry.Scheme.glue_data.Œπ_is_open_immersion`: The map `Œπ i : U i ‚ü∂ glued`
  is an open immersion for each `i : J`.
* `algebraic_geometry.Scheme.glue_data.Œπ_jointly_surjective` : The underlying maps of
  `Œπ i : U i ‚ü∂ glued` are jointly surjective.
* `algebraic_geometry.Scheme.glue_data.V_pullback_cone_is_limit` : `V i j` is the pullback
  (intersection) of `U i` and `U j` over the glued space.
* `algebraic_geometry.Scheme.glue_data.Œπ_eq_iff_rel` : `Œπ i x = Œπ j y` if and only if they coincide
  when restricted to `V i i`.
* `algebraic_geometry.Scheme.glue_data.is_open_iff` : An subset of the glued scheme is open iff
  all its preimages in `U i` are open.

## Implementation details

All the hard work is done in `algebraic_geometry/presheafed_space/gluing.lean` where we glue
presheafed spaces, sheafed spaces, and locally ringed spaces.

-/


noncomputable section

universe u

open TopologicalSpace CategoryTheory Opposite

open CategoryTheory.Limits AlgebraicGeometry.PresheafedSpace

open CategoryTheory.GlueData

namespace AlgebraicGeometry

namespace Scheme

/-- A family of gluing data consists of
1. An index type `J`
2. An scheme `U i` for each `i : J`.
3. An scheme `V i j` for each `i j : J`.
  (Note that this is `J √ó J ‚Üí Scheme` rather than `J ‚Üí J ‚Üí Scheme` to connect to the
  limits library easier.)
4. An open immersion `f i j : V i j ‚ü∂ U i` for each `i j : Œπ`.
5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.
such that
6. `f i i` is an isomorphism.
7. `t i i` is the identity.
8. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some
    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.
9. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.

We can then glue the schemes `U i` together by identifying `V i j` with `V j i`, such
that the `U i`'s are open subschemes of the glued space.
-/
@[nolint has_nonempty_instance]
structure GlueData extends CategoryTheory.GlueData Scheme where
  f_open : ‚àÄ i j, IsOpenImmersionCat (f i j)
#align algebraic_geometry.Scheme.glue_data AlgebraicGeometry.Scheme.GlueData

attribute [instance] glue_data.f_open

namespace GlueData

variable (D : GlueData)

local notation "ùñ£" => D.toGlueData

/-- The glue data of locally ringed spaces spaces associated to a family of glue data of schemes. -/
abbrev toLocallyRingedSpaceGlueData : LocallyRingedSpace.GlueData :=
  { f_open := D.f_open
    toGlueData := ùñ£.mapGlueData forgetToLocallyRingedSpace }
#align algebraic_geometry.Scheme.glue_data.to_LocallyRingedSpace_glue_data AlgebraicGeometry.Scheme.GlueData.toLocallyRingedSpaceGlueData

/-- (Implementation). The glued scheme of a glue data.
This should not be used outside this file. Use `Scheme.glue_data.glued` instead. -/
def gluedScheme : Scheme :=
  by
  apply
    LocallyRingedSpace.is_open_immersion.Scheme D.to_LocallyRingedSpace_glue_data.to_glue_data.glued
  intro x
  obtain ‚ü®i, y, rfl‚ü© := D.to_LocallyRingedSpace_glue_data.Œπ_jointly_surjective x
  refine' ‚ü®_, _ ‚â´ D.to_LocallyRingedSpace_glue_data.to_glue_data.Œπ i, _‚ü©
  swap; exact (D.U i).affineCover.map y
  constructor
  ¬∑ dsimp [-Set.mem_range]
    rw [coe_comp, Set.range_comp]
    refine' Set.mem_image_of_mem _ _
    exact (D.U i).affineCover.Covers y
  ¬∑ infer_instance
#align algebraic_geometry.Scheme.glue_data.glued_Scheme AlgebraicGeometry.Scheme.GlueData.gluedScheme

instance : CreatesColimit ùñ£.diagram.multispan forgetToLocallyRingedSpace :=
  createsColimitOfFullyFaithfulOfIso D.gluedScheme
    (HasColimit.isoOfNatIso (ùñ£.diagramIso forgetToLocallyRingedSpace).symm)

instance : PreservesColimit ùñ£.diagram.multispan forgetToTop :=
  by
  delta forget_to_Top LocallyRingedSpace.forget_to_Top
  infer_instance

instance : HasMulticoequalizer ùñ£.diagram :=
  hasColimit_of_created _ forgetToLocallyRingedSpace

/-- The glued scheme of a glued space. -/
abbrev glued : Scheme :=
  ùñ£.glued
#align algebraic_geometry.Scheme.glue_data.glued AlgebraicGeometry.Scheme.GlueData.glued

/-- The immersion from `D.U i` into the glued space. -/
abbrev Œπ (i : D.J) : D.U i ‚ü∂ D.glued :=
  ùñ£.Œπ i
#align algebraic_geometry.Scheme.glue_data.Œπ AlgebraicGeometry.Scheme.GlueData.Œπ

/-- The gluing as sheafed spaces is isomorphic to the gluing as presheafed spaces. -/
abbrev isoLocallyRingedSpace :
    D.glued.toLocallyRingedSpace ‚âÖ D.toLocallyRingedSpaceGlueData.toGlueData.glued :=
  ùñ£.gluedIso forgetToLocallyRingedSpace
#align algebraic_geometry.Scheme.glue_data.iso_LocallyRingedSpace AlgebraicGeometry.Scheme.GlueData.isoLocallyRingedSpace

theorem Œπ_isoLocallyRingedSpace_inv (i : D.J) :
    D.toLocallyRingedSpaceGlueData.toGlueData.Œπ i ‚â´ D.isoLocallyRingedSpace.inv = ùñ£.Œπ i :=
  ùñ£.Œπ_gluedIso_inv forgetToLocallyRingedSpace i
#align algebraic_geometry.Scheme.glue_data.Œπ_iso_LocallyRingedSpace_inv AlgebraicGeometry.Scheme.GlueData.Œπ_isoLocallyRingedSpace_inv

instance Œπ_isOpenImmersionCat (i : D.J) : IsOpenImmersionCat (ùñ£.Œπ i) := by
  rw [‚Üê D.Œπ_iso_LocallyRingedSpace_inv]; infer_instance
#align algebraic_geometry.Scheme.glue_data.Œπ_is_open_immersion AlgebraicGeometry.Scheme.GlueData.Œπ_isOpenImmersionCat

theorem Œπ_jointly_surjective (x : ùñ£.glued.carrier) :
    ‚àÉ (i : D.J) (y : (D.U i).carrier), (D.Œπ i).1.base y = x :=
  ùñ£.Œπ_jointly_surjective (forgetToTop ‚ãô forget TopCat) x
#align algebraic_geometry.Scheme.glue_data.Œπ_jointly_surjective AlgebraicGeometry.Scheme.GlueData.Œπ_jointly_surjective

@[simp, reassoc]
theorem glue_condition (i j : D.J) : D.t i j ‚â´ D.f j i ‚â´ D.Œπ j = D.f i j ‚â´ D.Œπ i :=
  ùñ£.glue_condition i j
#align algebraic_geometry.Scheme.glue_data.glue_condition AlgebraicGeometry.Scheme.GlueData.glue_condition

/-- The pullback cone spanned by `V i j ‚ü∂ U i` and `V i j ‚ü∂ U j`.
This is a pullback diagram (`V_pullback_cone_is_limit`). -/
def vPullbackCone (i j : D.J) : PullbackCone (D.Œπ i) (D.Œπ j) :=
  PullbackCone.mk (D.f i j) (D.t i j ‚â´ D.f j i) (by simp)
#align algebraic_geometry.Scheme.glue_data.V_pullback_cone AlgebraicGeometry.Scheme.GlueData.vPullbackCone

/-- The following diagram is a pullback, i.e. `V·µ¢‚±º` is the intersection of `U·µ¢` and `U‚±º` in `X`.

V·µ¢‚±º ‚ü∂ U·µ¢
 |      |
 ‚Üì      ‚Üì
 U‚±º ‚ü∂ X
-/
def vPullbackConeIsLimit (i j : D.J) : IsLimit (D.vPullbackCone i j) :=
  ùñ£.vPullbackConeIsLimitOfMap forgetToLocallyRingedSpace i j
    (D.toLocallyRingedSpaceGlueData.vPullbackConeIsLimit _ _)
#align algebraic_geometry.Scheme.glue_data.V_pullback_cone_is_limit AlgebraicGeometry.Scheme.GlueData.vPullbackConeIsLimit

/-- The underlying topological space of the glued scheme is isomorphic to the gluing of the
underlying spacess -/
def isoCarrier :
    D.glued.carrier ‚âÖ
      D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.toPresheafedSpaceGlueData.toTopGlueData.toGlueData.glued :=
  by
  refine' (PresheafedSpace.forget _).mapIso _ ‚â™‚â´ glue_data.glued_iso _ (PresheafedSpace.forget _)
  refine'
    SheafedSpace.forget_to_PresheafedSpace.map_iso _ ‚â™‚â´ SheafedSpace.glue_data.iso_PresheafedSpace _
  refine'
    LocallyRingedSpace.forget_to_SheafedSpace.map_iso _ ‚â™‚â´
      LocallyRingedSpace.glue_data.iso_SheafedSpace _
  exact Scheme.glue_data.iso_LocallyRingedSpace _
#align algebraic_geometry.Scheme.glue_data.iso_carrier AlgebraicGeometry.Scheme.GlueData.isoCarrier

@[simp]
theorem Œπ_isoCarrier_inv (i : D.J) :
    D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.toPresheafedSpaceGlueData.toTopGlueData.toGlueData.Œπ
          i ‚â´
        D.isoCarrier.inv =
      (D.Œπ i).1.base :=
  by
  delta iso_carrier
  simp only [functor.map_iso_inv, iso.trans_inv, iso.trans_assoc, glue_data.Œπ_glued_iso_inv_assoc,
    functor.map_iso_trans, category.assoc]
  iterate 3 erw [‚Üê comp_base]
  simp_rw [‚Üê category.assoc]
  rw [D.to_LocallyRingedSpace_glue_data.to_SheafedSpace_glue_data.Œπ_iso_PresheafedSpace_inv i]
  erw [D.to_LocallyRingedSpace_glue_data.Œπ_iso_SheafedSpace_inv i]
  change (_ ‚â´ D.iso_LocallyRingedSpace.inv).1.base = _
  rw [D.Œπ_iso_LocallyRingedSpace_inv i]
#align algebraic_geometry.Scheme.glue_data.Œπ_iso_carrier_inv AlgebraicGeometry.Scheme.GlueData.Œπ_isoCarrier_inv

/-- An equivalence relation on `Œ£ i, D.U i` that holds iff `ùñ£ .Œπ i x = ùñ£ .Œπ j y`.
See `Scheme.gluing_data.Œπ_eq_iff`. -/
def Rel (a b : Œ£ i, ((D.U i).carrier : Type _)) : Prop :=
  a = b ‚à®
    ‚àÉ x : (D.V (a.1, b.1)).carrier, (D.f _ _).1.base x = a.2 ‚àß (D.t _ _ ‚â´ D.f _ _).1.base x = b.2
#align algebraic_geometry.Scheme.glue_data.rel AlgebraicGeometry.Scheme.GlueData.Rel

theorem Œπ_eq_iff (i j : D.J) (x : (D.U i).carrier) (y : (D.U j).carrier) :
    (ùñ£.Œπ i).1.base x = (ùñ£.Œπ j).1.base y ‚Üî D.Rel ‚ü®i, x‚ü© ‚ü®j, y‚ü© :=
  by
  refine'
    Iff.trans _
      (D.to_LocallyRingedSpace_glue_data.to_SheafedSpace_glue_data.toPresheafedSpaceGlueData.toTopGlueData.Œπ_eq_iff_rel
        i j x y)
  rw [‚Üê ((TopCat.mono_iff_injective D.iso_carrier.inv).mp inferInstance).eq_iff]
  simp_rw [‚Üê comp_apply, D.Œπ_iso_carrier_inv]
#align algebraic_geometry.Scheme.glue_data.Œπ_eq_iff AlgebraicGeometry.Scheme.GlueData.Œπ_eq_iff

theorem isOpen_iff (U : Set D.glued.carrier) : IsOpen U ‚Üî ‚àÄ i, IsOpen ((D.Œπ i).1.base ‚Åª¬π' U) :=
  by
  rw [‚Üê (TopCat.homeoOfIso D.iso_carrier.symm).isOpen_preimage]
  rw [TopCat.GlueData.isOpen_iff]
  apply forall_congr'
  intro i
  erw [‚Üê Set.preimage_comp, ‚Üê coe_comp, Œπ_iso_carrier_inv]
#align algebraic_geometry.Scheme.glue_data.is_open_iff AlgebraicGeometry.Scheme.GlueData.isOpen_iff

/-- The open cover of the glued space given by the glue data. -/
def openCover (D : Scheme.GlueData) : OpenCover D.glued
    where
  J := D.J
  obj := D.U
  map := D.Œπ
  f x := (D.Œπ_jointly_surjective x).some
  Covers x := ‚ü®_, (D.Œπ_jointly_surjective x).choose_spec.choose_spec‚ü©
#align algebraic_geometry.Scheme.glue_data.open_cover AlgebraicGeometry.Scheme.GlueData.openCover

end GlueData

namespace OpenCover

variable {X : Scheme.{u}} (ùí∞ : OpenCover.{u} X)

/-- (Implementation) the transition maps in the glue data associated with an open cover. -/
def gluedCoverT' (x y z : ùí∞.J) :
    pullback (pullback.fst : pullback (ùí∞.map x) (ùí∞.map y) ‚ü∂ _)
        (pullback.fst : pullback (ùí∞.map x) (ùí∞.map z) ‚ü∂ _) ‚ü∂
      pullback (pullback.fst : pullback (ùí∞.map y) (ùí∞.map z) ‚ü∂ _)
        (pullback.fst : pullback (ùí∞.map y) (ùí∞.map x) ‚ü∂ _) :=
  by
  refine' (pullback_right_pullback_fst_iso _ _ _).Hom ‚â´ _
  refine' _ ‚â´ (pullback_symmetry _ _).Hom
  refine' _ ‚â´ (pullback_right_pullback_fst_iso _ _ _).inv
  refine' pullback.map _ _ _ _ (pullback_symmetry _ _).Hom (ùüô _) (ùüô _) _ _
  ¬∑ simp [pullback.condition]
  ¬∑ simp
#align algebraic_geometry.Scheme.open_cover.glued_cover_t' AlgebraicGeometry.Scheme.OpenCover.gluedCoverT'

@[simp, reassoc]
theorem gluedCoverT'_fst_fst (x y z : ùí∞.J) :
    ùí∞.gluedCoverT' x y z ‚â´ pullback.fst ‚â´ pullback.fst = pullback.fst ‚â´ pullback.snd := by
  delta glued_cover_t'; simp
#align algebraic_geometry.Scheme.open_cover.glued_cover_t'_fst_fst AlgebraicGeometry.Scheme.OpenCover.gluedCoverT'_fst_fst

@[simp, reassoc]
theorem gluedCoverT'_fst_snd (x y z : ùí∞.J) :
    gluedCoverT' ùí∞ x y z ‚â´ pullback.fst ‚â´ pullback.snd = pullback.snd ‚â´ pullback.snd := by
  delta glued_cover_t'; simp
#align algebraic_geometry.Scheme.open_cover.glued_cover_t'_fst_snd AlgebraicGeometry.Scheme.OpenCover.gluedCoverT'_fst_snd

@[simp, reassoc]
theorem gluedCoverT'_snd_fst (x y z : ùí∞.J) :
    gluedCoverT' ùí∞ x y z ‚â´ pullback.snd ‚â´ pullback.fst = pullback.fst ‚â´ pullback.snd := by
  delta glued_cover_t'; simp
#align algebraic_geometry.Scheme.open_cover.glued_cover_t'_snd_fst AlgebraicGeometry.Scheme.OpenCover.gluedCoverT'_snd_fst

@[simp, reassoc]
theorem gluedCoverT'_snd_snd (x y z : ùí∞.J) :
    gluedCoverT' ùí∞ x y z ‚â´ pullback.snd ‚â´ pullback.snd = pullback.fst ‚â´ pullback.fst := by
  delta glued_cover_t'; simp
#align algebraic_geometry.Scheme.open_cover.glued_cover_t'_snd_snd AlgebraicGeometry.Scheme.OpenCover.gluedCoverT'_snd_snd

theorem glued_cover_cocycle_fst (x y z : ùí∞.J) :
    gluedCoverT' ùí∞ x y z ‚â´ gluedCoverT' ùí∞ y z x ‚â´ gluedCoverT' ùí∞ z x y ‚â´ pullback.fst =
      pullback.fst :=
  by apply pullback.hom_ext <;> simp
#align algebraic_geometry.Scheme.open_cover.glued_cover_cocycle_fst AlgebraicGeometry.Scheme.OpenCover.glued_cover_cocycle_fst

theorem glued_cover_cocycle_snd (x y z : ùí∞.J) :
    gluedCoverT' ùí∞ x y z ‚â´ gluedCoverT' ùí∞ y z x ‚â´ gluedCoverT' ùí∞ z x y ‚â´ pullback.snd =
      pullback.snd :=
  by apply pullback.hom_ext <;> simp [pullback.condition]
#align algebraic_geometry.Scheme.open_cover.glued_cover_cocycle_snd AlgebraicGeometry.Scheme.OpenCover.glued_cover_cocycle_snd

theorem glued_cover_cocycle (x y z : ùí∞.J) :
    gluedCoverT' ùí∞ x y z ‚â´ gluedCoverT' ùí∞ y z x ‚â´ gluedCoverT' ùí∞ z x y = ùüô _ :=
  by
  apply pullback.hom_ext <;> simp_rw [category.id_comp, category.assoc]
  apply glued_cover_cocycle_fst
  apply glued_cover_cocycle_snd
#align algebraic_geometry.Scheme.open_cover.glued_cover_cocycle AlgebraicGeometry.Scheme.OpenCover.glued_cover_cocycle

/-- The glue data associated with an open cover.
The canonical isomorphism `ùí∞.glued_cover.glued ‚ü∂ X` is provided by `ùí∞.from_glued`. -/
@[simps]
def gluedCover : Scheme.GlueData.{u} where
  J := ùí∞.J
  U := ùí∞.obj
  V := fun ‚ü®x, y‚ü© => pullback (ùí∞.map x) (ùí∞.map y)
  f x y := pullback.fst
  f_id x := inferInstance
  t x y := (pullbackSymmetry _ _).Hom
  t_id x := by simpa
  t' x y z := gluedCoverT' ùí∞ x y z
  t_fac x y z := by apply pullback.hom_ext <;> simp
  -- The `cocycle` field could have been `by tidy` but lean timeouts.
  cocycle x y z := glued_cover_cocycle ùí∞ x y z
  f_open x := inferInstance
#align algebraic_geometry.Scheme.open_cover.glued_cover AlgebraicGeometry.Scheme.OpenCover.gluedCover

/-- The canonical morphism from the gluing of an open cover of `X` into `X`.
This is an isomorphism, as witnessed by an `is_iso` instance. -/
def fromGlued : ùí∞.gluedCover.glued ‚ü∂ X :=
  by
  fapply multicoequalizer.desc
  exact fun x => ùí∞.map x
  rintro ‚ü®x, y‚ü©
  change pullback.fst ‚â´ _ = ((pullback_symmetry _ _).Hom ‚â´ pullback.fst) ‚â´ _
  simpa using pullback.condition
#align algebraic_geometry.Scheme.open_cover.from_glued AlgebraicGeometry.Scheme.OpenCover.fromGlued

@[simp, reassoc]
theorem Œπ_fromGlued (x : ùí∞.J) : ùí∞.gluedCover.Œπ x ‚â´ ùí∞.fromGlued = ùí∞.map x :=
  Multicoequalizer.œÄ_desc _ _ _ _ _
#align algebraic_geometry.Scheme.open_cover.Œπ_from_glued AlgebraicGeometry.Scheme.OpenCover.Œπ_fromGlued

theorem fromGlued_injective : Function.Injective ùí∞.fromGlued.1.base :=
  by
  intro x y h
  obtain ‚ü®i, x, rfl‚ü© := ùí∞.glued_cover.Œπ_jointly_surjective x
  obtain ‚ü®j, y, rfl‚ü© := ùí∞.glued_cover.Œπ_jointly_surjective y
  simp_rw [‚Üê comp_apply, ‚Üê SheafedSpace.comp_base, ‚Üê LocallyRingedSpace.comp_val] at h 
  erw [Œπ_from_glued, Œπ_from_glued] at h 
  let e :=
    (TopCat.pullbackConeIsLimit _ _).conePointUniqueUpToIso
      (is_limit_of_has_pullback_of_preserves_limit Scheme.forget_to_Top (ùí∞.map i) (ùí∞.map j))
  rw [ùí∞.glued_cover.Œπ_eq_iff]
  right
  use e.hom ‚ü®‚ü®x, y‚ü©, h‚ü©
  simp_rw [‚Üê comp_apply]
  constructor
  ¬∑ erw [is_limit.cone_point_unique_up_to_iso_hom_comp _ _ walking_cospan.left]; rfl
  ¬∑ erw [pullback_symmetry_hom_comp_fst,
      is_limit.cone_point_unique_up_to_iso_hom_comp _ _ walking_cospan.right]
    rfl
#align algebraic_geometry.Scheme.open_cover.from_glued_injective AlgebraicGeometry.Scheme.OpenCover.fromGlued_injective

instance fromGlued_stalk_iso (x : ùí∞.gluedCover.glued.carrier) :
    IsIso (PresheafedSpace.stalkMap ùí∞.fromGlued.val x) :=
  by
  obtain ‚ü®i, x, rfl‚ü© := ùí∞.glued_cover.Œπ_jointly_surjective x
  have :=
    PresheafedSpace.stalk_map.congr_hom _ _
      (congr_arg LocallyRingedSpace.hom.val <| ùí∞.Œπ_from_glued i) x
  erw [PresheafedSpace.stalk_map.comp] at this 
  rw [‚Üê is_iso.eq_comp_inv] at this 
  rw [this]
  infer_instance
#align algebraic_geometry.Scheme.open_cover.from_glued_stalk_iso AlgebraicGeometry.Scheme.OpenCover.fromGlued_stalk_iso

theorem fromGlued_open_map : IsOpenMap ùí∞.fromGlued.1.base :=
  by
  intro U hU
  rw [isOpen_iff_forall_mem_open]
  intro x hx
  rw [ùí∞.glued_cover.is_open_iff] at hU 
  use ùí∞.from_glued.val.base '' U ‚à© Set.range (ùí∞.map (ùí∞.f x)).1.base
  use Set.inter_subset_left _ _
  constructor
  ¬∑ rw [‚Üê Set.image_preimage_eq_inter_range]
    apply show is_open_immersion (ùí∞.map (ùí∞.f x)) by infer_instance.base_open.IsOpenMap
    convert hU (ùí∞.f x) using 1
    rw [‚Üê Œπ_from_glued]; erw [coe_comp]; rw [Set.preimage_comp]
    congr 1
    refine' Set.preimage_image_eq _ ùí∞.from_glued_injective
  ¬∑ exact ‚ü®hx, ùí∞.covers x‚ü©
#align algebraic_geometry.Scheme.open_cover.from_glued_open_map AlgebraicGeometry.Scheme.OpenCover.fromGlued_open_map

theorem fromGlued_openEmbedding : OpenEmbedding ùí∞.fromGlued.1.base :=
  openEmbedding_of_continuous_injective_open (by continuity) ùí∞.fromGlued_injective
    ùí∞.fromGlued_open_map
#align algebraic_geometry.Scheme.open_cover.from_glued_open_embedding AlgebraicGeometry.Scheme.OpenCover.fromGlued_openEmbedding

instance : Epi ùí∞.fromGlued.val.base :=
  by
  rw [TopCat.epi_iff_surjective]
  intro x
  obtain ‚ü®y, h‚ü© := ùí∞.covers x
  use (ùí∞.glued_cover.Œπ (ùí∞.f x)).1.base y
  rw [‚Üê comp_apply]
  rw [‚Üê ùí∞.Œπ_from_glued (ùí∞.f x)] at h 
  exact h

instance fromGlued_open_immersion : IsOpenImmersionCat ùí∞.fromGlued :=
  SheafedSpace.IsOpenImmersion.of_stalk_iso _ ùí∞.fromGlued_openEmbedding
#align algebraic_geometry.Scheme.open_cover.from_glued_open_immersion AlgebraicGeometry.Scheme.OpenCover.fromGlued_open_immersion

instance : IsIso ùí∞.fromGlued :=
  by
  apply
    is_iso_of_reflects_iso _
      (Scheme.forget_to_LocallyRingedSpace ‚ãô
        LocallyRingedSpace.forget_to_SheafedSpace ‚ãô SheafedSpace.forget_to_PresheafedSpace)
  change @is_iso (PresheafedSpace _) _ _ _ ùí∞.from_glued.val
  apply PresheafedSpace.is_open_immersion.to_iso

/-- Given an open cover of `X`, and a morphism `ùí∞.obj x ‚ü∂ Y` for each open subscheme in the cover,
such that these morphisms are compatible in the intersection (pullback), we may glue the morphisms
together into a morphism `X ‚ü∂ Y`.

Note:
If `X` is exactly (defeq to) the gluing of `U i`, then using `multicoequalizer.desc` suffices.
-/
def glueMorphisms {Y : Scheme} (f : ‚àÄ x, ùí∞.obj x ‚ü∂ Y)
    (hf : ‚àÄ x y, (pullback.fst : pullback (ùí∞.map x) (ùí∞.map y) ‚ü∂ _) ‚â´ f x = pullback.snd ‚â´ f y) :
    X ‚ü∂ Y := by
  refine' inv ùí∞.from_glued ‚â´ _
  fapply multicoequalizer.desc
  exact f
  rintro ‚ü®i, j‚ü©
  change pullback.fst ‚â´ f i = (_ ‚â´ _) ‚â´ f j
  erw [pullback_symmetry_hom_comp_fst]
  exact hf i j
#align algebraic_geometry.Scheme.open_cover.glue_morphisms AlgebraicGeometry.Scheme.OpenCover.glueMorphisms

@[simp, reassoc]
theorem Œπ_glueMorphisms {Y : Scheme} (f : ‚àÄ x, ùí∞.obj x ‚ü∂ Y)
    (hf : ‚àÄ x y, (pullback.fst : pullback (ùí∞.map x) (ùí∞.map y) ‚ü∂ _) ‚â´ f x = pullback.snd ‚â´ f y)
    (x : ùí∞.J) : ùí∞.map x ‚â´ ùí∞.glueMorphisms f hf = f x :=
  by
  rw [‚Üê Œπ_from_glued, category.assoc]
  erw [is_iso.hom_inv_id_assoc, multicoequalizer.œÄ_desc]
#align algebraic_geometry.Scheme.open_cover.Œπ_glue_morphisms AlgebraicGeometry.Scheme.OpenCover.Œπ_glueMorphisms

theorem hom_ext {Y : Scheme} (f‚ÇÅ f‚ÇÇ : X ‚ü∂ Y) (h : ‚àÄ x, ùí∞.map x ‚â´ f‚ÇÅ = ùí∞.map x ‚â´ f‚ÇÇ) : f‚ÇÅ = f‚ÇÇ :=
  by
  rw [‚Üê cancel_epi ùí∞.from_glued]
  apply multicoequalizer.hom_ext
  intro x
  erw [multicoequalizer.œÄ_desc_assoc]
  erw [multicoequalizer.œÄ_desc_assoc]
  exact h x
#align algebraic_geometry.Scheme.open_cover.hom_ext AlgebraicGeometry.Scheme.OpenCover.hom_ext

end OpenCover

end Scheme

end AlgebraicGeometry

