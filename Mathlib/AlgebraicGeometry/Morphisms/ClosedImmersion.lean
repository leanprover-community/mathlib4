/-
Copyright (c) 2023 Jonas van der Schaaf. All rights
reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jonas van der Schaaf, Amelia Livingston
-/
import Mathlib.AlgebraicGeometry.AffineScheme
import Mathlib.AlgebraicGeometry.Stalks
import Mathlib.CategoryTheory.MorphismProperty
import Mathlib.RingTheory.LocalProperties

/-!
# Closed immersions of schemes

A morphism of schemes `f : X ‚ü∂ Y` is a closed immersion if the underlying map of topological spaces
is a closed immersion and the induced morphisms of stalks are all surjective.

## Main definitions

* `Scheme.IsClosedImmersion` : The property of scheme morphisms stating `f : X ‚ü∂ Y` is a closed
  immersion.

## TODO

* Show closed immersions of affines are induced by surjective ring maps
* Show closed immersions are stable under pullback
* Define closed immersions of locally ringed spaces, where we also assume that the kernel of `O_X ‚Üí
  f_*O_Y` is locally generated by sections as an `O_X`-module, and relate it to this file. See
  https://stacks.math.columbia.edu/tag/01HJ.

-/
universe v u

open CategoryTheory

namespace AlgebraicGeometry

/-- A morphism of schemes `X ‚ü∂ Y` is a closed immersion if the underlying
topological map is a closed embedding and the induced stalk maps are surjective. -/
class Scheme.IsClosedImmersion {X Y : Scheme} (f : X ‚ü∂ Y) : Prop where
  base_closed : ClosedEmbedding f.1.base
  surj_on_stalks : ‚àÄ x : X, Function.Surjective (PresheafedSpace.stalkMap f.1 x)

namespace Scheme.IsClosedImmersion

open Scheme

local notation "IsClosedImmersion" => Scheme.IsClosedImmersion

instance id {X : Scheme} : IsClosedImmersion (ùüô X) := by
  constructor
  . apply closedEmbedding_id
  . intro x r
    use r
    erw [PresheafedSpace.stalkMap.id]
    rfl

/- The file `OpenImmersion.Basic` doesn't use this `MorphismProperty` stuff,
but `Morphisms.FiniteType` does. I've emulated the latter for now.
Also at the moment the naming/namespacing is a mix of those two files... - Amelia -/

/-- Suppose we have maps of schemes `f : X ‚ü∂ Y` and `g : Y ‚ü∂ Z` which are both closed immersions.
  Then their composition `f ‚â´ g : X ‚ü∂ Z` is also a closed immersion. -/
theorem stableUnderComposition :
    MorphismProperty.StableUnderComposition (@Scheme.IsClosedImmersion) := by
  rintro X Y Z f g ‚ü®hf_closed, hf_surj‚ü© ‚ü®hg_closed, hg_surj‚ü©
  constructor
  . exact hg_closed.comp hf_closed
  . intro x
    erw [PresheafedSpace.stalkMap.comp]
    exact (hf_surj x).comp (hg_surj (f.1.1 x))

instance comp {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z)
  [hf : IsClosedImmersion f] [hg : IsClosedImmersion g] :
    IsClosedImmersion (f ‚â´ g) :=
  stableUnderComposition f g hf hg

/-- Isomorphisms are closed immersions. -/
instance ofIsIso {X Y : Scheme} (f : X ‚ü∂ Y) [hf : IsIso f] :
    IsClosedImmersion f := by
  constructor
  . let f_top_iso := TopCat.homeoOfIso (asIso f.1.base)
    exact Homeomorph.closedEmbedding f_top_iso
  . intro x
    exact (ConcreteCategory.bijective_of_isIso _).2

/-- Composition with an iso preserves closed embeddings. This is a direct
corollary from `ofIsIso` and `stableUnderComposition`. -/
theorem respectsIso :
    MorphismProperty.RespectsIso @Scheme.IsClosedImmersion := by
  constructor <;> intro X Y Z e f hf <;> apply stableUnderComposition
  <;> infer_instance -- not sure of formatting convention here

-- This needs moving to different file
/- A surjective hom `R ‚Üí+* S` induces a surjective hom `R_{f‚Åª¬π(P)} ‚Üí+* S_P`.
This is just an application of `localizationPreserves_surjective`, modulo the fact that
`IsLocalization f((f‚Åª¬π(P))·∂ú) R_P`, since `f((f‚Åª¬π(P))·∂ú)` is just `P·∂ú`... -/
theorem surjective_localRingHom_of_surjective {R S : Type u}
    [CommRing R] [CommRing S] (f : R ‚Üí+* S)
    (h : Function.Surjective f) (P : Ideal S) [P.IsPrime] :
    Function.Surjective (Localization.localRingHom (P.comap f) P f rfl) :=
  @localizationPreserves_surjective R S _ _ f ((P.comap f).primeCompl)
    (Localization.AtPrime (P.comap f)) (Localization.AtPrime P) _ _ _ _ _
    ((Submonoid.map_comap_eq_of_surjective h P.primeCompl).symm ‚ñ∏ Localization.isLocalization) h

/-- Given two commutative rings `R S : CommRingCat` and a surjective morphism
`f : R ‚ü∂ S`, the induced scheme morphism `specObj S ‚ü∂ specObj R` is a
closed immersion. -/
theorem spec_of_surjective {R S : CommRingCat} (f : R ‚ü∂ S)
    (h : Function.Surjective f) :
    IsClosedImmersion (Scheme.specMap (CommRingCat.ofHom f)) := by
  constructor
  . apply PrimeSpectrum.closedEmbedding_comap_of_surjective _ _ h
  . intro x
    erw [‚ÜêlocalRingHom_comp_stalkIso, CommRingCat.coe_comp, CommRingCat.coe_comp]
    show Function.Surjective (_ ‚àò _)
    apply Function.Surjective.comp (Function.Surjective.comp _ _) _
    . let stalk_iso := (StructureSheaf.stalkIso S x).inv
      exact (ConcreteCategory.bijective_of_isIso stalk_iso).2
    . exact surjective_localRingHom_of_surjective f h x.asIdeal
    . let stalk_iso := (StructureSheaf.stalkIso ((CommRingCat.of R))
        ((PrimeSpectrum.comap (CommRingCat.ofHom f)) x)).hom
      exact (ConcreteCategory.bijective_of_isIso stalk_iso).2

instance spec_of_quotient_mk {R : CommRingCat.{u}} (I : Ideal R) :
  IsClosedImmersion (Scheme.specMap (CommRingCat.ofHom (Ideal.Quotient.mk I))) :=
spec_of_surjective (CommRingCat.ofHom (Ideal.Quotient.mk I))
  Ideal.Quotient.mk_surjective

-- Is this a MorphismProperty somewhere?
theorem ofComp {X Y Z: Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z)[hg : IsClosedImmersion g]
  [hcomp : IsClosedImmersion (f ‚â´ g)] : IsClosedImmersion f := by
    rcases hcomp with ‚ü®comp_closed, comp_stalk_surj‚ü©
    rcases hg with ‚ü®g_closed, -‚ü©
    constructor
    . rw [Scheme.comp_val_base] at comp_closed
      apply closedEmbedding_of_continuous_injective_closed
      . apply Scheme.Hom.continuous
      . exact Function.Injective.of_comp comp_closed.inj
      . intro Z hZ
        rw [ClosedEmbedding.closed_iff_image_closed g_closed, ‚ÜêSet.image_comp]
        exact ClosedEmbedding.isClosedMap comp_closed _ hZ
    . intro x
      specialize comp_stalk_surj x
      erw [Scheme.comp_val, PresheafedSpace.stalkMap.comp] at comp_stalk_surj
      exact Function.Surjective.of_comp comp_stalk_surj

end Scheme.IsClosedImmersion
end AlgebraicGeometry
