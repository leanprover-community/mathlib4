/-
Copyright (c) 2023 Jonas van der Schaaf. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Amelia Livingston, Christian Merten, Jonas van der Schaaf
-/
import Mathlib.AlgebraicGeometry.OpenImmersion
import Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact
import Mathlib.CategoryTheory.MorphismProperty.Composition
import Mathlib.RingTheory.LocalProperties
import Mathlib.AlgebraicGeometry.Morphisms.Basic
import Mathlib.Topology.LocalAtTarget
import Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated
import Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties
import Mathlib.RingTheory.RingHom.Surjective

/-!

# Closed immersions of schemes

A morphism of schemes `f : X âŸ¶ Y` is a closed immersion if the underlying map of topological spaces
is a closed immersion and the induced morphisms of stalks are all surjective.

## Main definitions

* `IsClosedImmersion` : The property of scheme morphisms stating `f : X âŸ¶ Y` is a closed immersion.

## TODO

* Show closed immersions of affines are induced by surjective ring maps
* Show closed immersions are stable under pullback
* Show closed immersions are precisely the proper monomorphisms
* Define closed immersions of locally ringed spaces, where we also assume that the kernel of `O_X â†’
  f_*O_Y` is locally generated by sections as an `O_X`-module, and relate it to this file. See
  https://stacks.math.columbia.edu/tag/01HJ.

-/

universe v u

open CategoryTheory

namespace AlgebraicGeometry

/-
@[mk_iff]
class IsSurjectiveOnStalks {X Y : Scheme} (f : X âŸ¶ Y) : Prop where
  out : MorphismProperty.stalkwise (fun f â†¦ Function.Surjective f) f

lemma isSurjectiveOnStalks_eq_stalkwise_surjective :
    @IsSurjectiveOnStalks = MorphismProperty.stalkwise (fun f â†¦ Function.Surjective f) := by
  ext 
  exact isSurjectiveOnStalks_iff _
-/

/-- A morphism of schemes `X âŸ¶ Y` is a closed immersion if the underlying
topological map is a closed embedding and the induced stalk maps are surjective. -/
@[mk_iff]
class IsClosedImmersion {X Y : Scheme} (f : X âŸ¶ Y) : Prop where
  base_closed : MorphismProperty.topologically ClosedEmbedding f
  surj_on_stalks : MorphismProperty.stalkwise (fun f â†¦ Function.Surjective f) f

namespace IsClosedImmersion

lemma closedEmbedding {X Y : Scheme} (f : X âŸ¶ Y)
    [IsClosedImmersion f] : ClosedEmbedding f.1.base :=
  IsClosedImmersion.base_closed

lemma surjective_stalkMap {X Y : Scheme} (f : X âŸ¶ Y)
    [IsClosedImmersion f] (x : X) : Function.Surjective (PresheafedSpace.stalkMap f.1 x) :=
  IsClosedImmersion.surj_on_stalks x

/-- Isomorphisms are closed immersions. -/
instance {X Y : Scheme} (f : X âŸ¶ Y) [IsIso f] : IsClosedImmersion f where
  base_closed := Homeomorph.closedEmbedding <| TopCat.homeoOfIso (asIso f.1.base)
  surj_on_stalks := fun _ â†¦ (ConcreteCategory.bijective_of_isIso _).2

instance : MorphismProperty.IsMultiplicative @IsClosedImmersion where
  id_mem _ := inferInstance
  comp_mem {X Y Z} f g hf hg := by
    refine âŸ¨hg.base_closed.comp hf.base_closed, fun x â†¦ ?_âŸ©
    erw [PresheafedSpace.stalkMap.comp]
    exact (hf.surj_on_stalks x).comp (hg.surj_on_stalks (f.1.1 x))

/-
instance {X Y : Scheme} (f : X âŸ¶ Y) [IsIso f] : IsSurjectiveOnStalks f where
  out := fun _ â†¦ (ConcreteCategory.bijective_of_isIso _).2
-/

/-
instance : MorphismProperty.IsMultiplicative @IsSurjectiveOnStalks where
  id_mem _ := inferInstance
  comp_mem {X Y Z} f g hf hg := by
    constructor
    intro x
    erw [PresheafedSpace.stalkMap.comp]
    exact (hf.out x).comp (hg.out (f.1.1 x))
-/

/-- Composition of closed immersions is a closed immersion. -/
instance comp {X Y Z : Scheme} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [IsClosedImmersion f]
    [IsClosedImmersion g] : IsClosedImmersion (f â‰« g) :=
  MorphismProperty.IsStableUnderComposition.comp_mem f g inferInstance inferInstance

/-
/-- Composition of closed immersions is a closed immersion. -/
instance comp' {X Y Z : Scheme} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [IsSurjectiveOnStalks f]
    [IsSurjectiveOnStalks g] : IsSurjectiveOnStalks (f â‰« g) :=
  MorphismProperty.IsStableUnderComposition.comp_mem f g inferInstance inferInstance
-/

/-- Composition with an isomorphism preserves closed immersions. -/
lemma respectsIso : MorphismProperty.RespectsIso @IsClosedImmersion := by
  constructor <;> intro X Y Z e f hf <;> infer_instance

/-- Given two commutative rings `R S : CommRingCat` and a surjective morphism
`f : R âŸ¶ S`, the induced scheme morphism `specObj S âŸ¶ specObj R` is a
closed immersion. -/
theorem spec_of_surjective {R S : CommRingCat} (f : R âŸ¶ S) (h : Function.Surjective f) :
    IsClosedImmersion (Spec.map f) where
  base_closed := PrimeSpectrum.closedEmbedding_comap_of_surjective _ _ h
  surj_on_stalks x := by
    dsimp
    erw [â† localRingHom_comp_stalkIso, CommRingCat.coe_comp, CommRingCat.coe_comp]
    apply Function.Surjective.comp (Function.Surjective.comp _ _) _
    Â· exact (ConcreteCategory.bijective_of_isIso (StructureSheaf.stalkIso S x).inv).2
    Â· exact surjective_localRingHom_of_surjective f h x.asIdeal
    Â· let g := (StructureSheaf.stalkIso ((CommRingCat.of R))
        ((PrimeSpectrum.comap (CommRingCat.ofHom f)) x)).hom
      exact (ConcreteCategory.bijective_of_isIso g).2

open Opposite

lemma specMap_Î“_map {X Y : Scheme} [IsAffine X] [IsAffine Y] (f : X âŸ¶ Y) :
    Spec.map (Scheme.Î“.map f.op) = X.isoSpec.inv â‰« f â‰« Y.isoSpec.hom := by
  erw [IsIso.eq_inv_comp]
  apply Adjunction.unit_naturality

theorem of_surjective_of_affine {X Y : Scheme} [IsAffine X] [IsAffine Y] (f : X âŸ¶ Y)
    (h : Function.Surjective (Scheme.Î“.map f.op)) : IsClosedImmersion f := by
  have he : IsClosedImmersion (X.isoSpec.inv â‰« f â‰« Y.isoSpec.hom) := by
    rw [â† specMap_Î“_map f]
    apply spec_of_surjective
    exact h
  rw [respectsIso.cancel_left_isIso] at he
  rw [respectsIso.cancel_right_isIso] at he
  exact he

/-- For any ideal `I` in a commutative ring `R`, the quotient map `specObj R âŸ¶ specObj (R â§¸ I)`
is a closed immersion. -/
instance spec_of_quotient_mk {R : CommRingCat.{u}} (I : Ideal R) :
    IsClosedImmersion (Spec.map (CommRingCat.ofHom (Ideal.Quotient.mk I))) :=
  spec_of_surjective _ Ideal.Quotient.mk_surjective

/-- If `f â‰« g` is a closed immersion, then `f` is a closed immersion. -/
theorem of_comp {X Y Z : Scheme} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [IsClosedImmersion g]
    [IsClosedImmersion (f â‰« g)] : IsClosedImmersion f where
  base_closed := by
    have h := closedEmbedding (f â‰« g)
    rw [Scheme.comp_val_base] at h
    apply closedEmbedding_of_continuous_injective_closed (Scheme.Hom.continuous f)
    Â· exact Function.Injective.of_comp h.inj
    Â· intro Z hZ
      rw [ClosedEmbedding.closed_iff_image_closed (closedEmbedding g),
        â† Set.image_comp]
      exact ClosedEmbedding.isClosedMap h _ hZ
  surj_on_stalks x := by
    have h := surjective_stalkMap (f â‰« g) x
    erw [Scheme.comp_val, PresheafedSpace.stalkMap.comp] at h
    exact Function.Surjective.of_comp h

theorem closedEmbedding_localAtTarget : PropertyIsLocalAtTarget
    (MorphismProperty.topologically ClosedEmbedding) := by
  apply MorphismProperty.topologically_propertyIsLocalAtTarget
  Â· apply MorphismProperty.topologically_respectsIso
    Â· intro X Y _ _ e
      exact Homeomorph.closedEmbedding e
    Â· intro X Y Z _ _ _ f g hf hg
      exact ClosedEmbedding.comp hg hf
  Â· intro X Y _ _ f s hf
    exact ClosedEmbedding.restrictPreimage s hf
  Â· intro X Y _ _ f Î¹ U hU hfcont hf
    apply (closedEmbedding_iff_closedEmbedding_of_iSup_eq_top hU hfcont).mpr hf

theorem surjective_respectsIso :
    RingHom.RespectsIso (fun f â†¦ Function.Surjective f) := by
  apply RingHom.StableUnderComposition.respectsIso
  Â· intro R S T _ _ _ f g hf hg
    simp only [RingHom.coe_comp]
    exact Function.Surjective.comp hg hf
  Â· intro R S _ _ e
    exact EquivLike.surjective e

theorem isSurjectiveOnStalks_localAtTarget : PropertyIsLocalAtTarget
      (MorphismProperty.stalkwise (fun f â†¦ Function.Surjective f)) := by
  apply stalkwiseIsLocalAtTarget_of_respectsIso
  exact surjective_respectsIso

/-
TODO: can we write a general helper (ideally n-ary) to obtain this?
-> write MorphismProperty.and
-/
/-- Closed immersions are local at the target. -/
theorem closedImmersion_localAtTarget :
    PropertyIsLocalAtTarget @IsClosedImmersion where
  RespectsIso := respectsIso
  restrict f U hf := by
    constructor
    Â· exact closedEmbedding_localAtTarget.restrict f U hf.base_closed
    . exact isSurjectiveOnStalks_localAtTarget.restrict f U hf.surj_on_stalks
  of_openCover f ğ’° hf := by
    constructor
    Â· exact closedEmbedding_localAtTarget.of_openCover f ğ’° (fun i â†¦ (hf i).base_closed)
    Â· exact isSurjectiveOnStalks_localAtTarget.of_openCover f ğ’° (fun i â†¦ (hf i).surj_on_stalks)

section Affine

section

variable {X Y : Scheme} (f : X âŸ¶ Y) (x : X) (s : Scheme.Î“.obj <| op X)

example : X.presheaf.obj (op âŠ¤) := s

variable (t : Scheme.Î“.obj <| op Y)

end

variable (A : Type u) [CommRing A]
variable {X : Scheme.{u}}

open TopologicalSpace

noncomputable
def IsOpenImmersion.Î“Iso {X Y : Scheme.{u}} (f : X âŸ¶ Y) [IsOpenImmersion f] :
    Scheme.Î“.obj (op X) â‰… Y.presheaf.obj (op (Scheme.Hom.opensRange f)) :=
  Scheme.Î“.mapIso (IsOpenImmersion.isoOfRangeEq
      (Scheme.Î¹Opens (Scheme.Hom.opensRange f)) _ Subtype.range_val).op â‰ªâ‰«
    Y.presheaf.mapIso (eqToIso (TopologicalSpace.Opens.openEmbedding_obj_top _).symm).op

lemma IsOpenImmersion.map_Î“Iso_inv
    {X Y : Scheme.{u}} (f : X âŸ¶ Y) [IsOpenImmersion f] :
  Y.presheaf.map (homOfLE le_top).op â‰« (IsOpenImmersion.Î“Iso f).inv = Scheme.Î“.map f.op := by
  conv_rhs => rw [â† IsOpenImmersion.isoOfRangeEq_inv_fac
      (Scheme.Î¹Opens (Scheme.Hom.opensRange f)) _ Subtype.range_val]
  rw [IsOpenImmersion.Î“Iso]
  dsimp
  rw [â† Functor.map_comp_assoc]
  rfl

lemma eq_of_eq_cover {X : Scheme.{u}} (f g : Scheme.Î“.obj (op X)) (ğ’° : X.OpenCover)
    (h : âˆ€ i : ğ’°.J, Scheme.Î“.map (ğ’°.map i).op f = Scheme.Î“.map (ğ’°.map i).op g) : f = g := by
  fapply TopCat.Sheaf.eq_of_locally_eq' X.sheaf
    (fun i â†¦ Scheme.Hom.opensRange (ğ’°.map (ğ’°.f i))) _ (fun _ â†¦ homOfLE le_top)
  Â· rintro x -; simpa using âŸ¨_, ğ’°.covers xâŸ©
  Â· intro x;
    replace h := h (ğ’°.f x)
    rw [â† IsOpenImmersion.map_Î“Iso_inv] at h
    exact (IsOpenImmersion.Î“Iso (ğ’°.map (ğ’°.f x))).commRingCatIsoToRingEquiv.symm.injective h

lemma zero_of_zero_cover (s : Scheme.Î“.obj (op X)) (ğ’° : X.OpenCover)
    (h : âˆ€ i : ğ’°.J, Scheme.Î“.map (ğ’°.map i).op s = 0) : s = 0 := by
  apply eq_of_eq_cover s 0 _
  intro i
  rw [map_zero]
  exact h i

lemma isNilpotent_of_isNilpotent_cover (s : Scheme.Î“.obj (op X)) (ğ’° : X.OpenCover)
    [Finite ğ’°.J] (h : âˆ€ i : ğ’°.J, IsNilpotent (Scheme.Î“.map (ğ’°.map i).op s)) : IsNilpotent s := by
  choose fn hfn using h
  have : Fintype ğ’°.J := Fintype.ofFinite ğ’°.J
  /- the maximum of all `fn i` (exists, because `ğ’°.J` is finite) -/
  let N : â„• := Finset.sup Finset.univ fn
  have hfnleN (i : ğ’°.J) : fn i â‰¤ N := Finset.le_sup (Finset.mem_univ i)
  use N
  apply zero_of_zero_cover
  intro i
  simp only [map_pow]
  exact pow_eq_zero_of_le (hfnleN i) (hfn i)

lemma Î“ToStalk_stalkMap {X Y : Scheme} (f : X âŸ¶ Y) (x : X) :
    Y.Î“ToStalk (f.val.base x) â‰« PresheafedSpace.stalkMap f.val x =
      Scheme.Î“.map f.op â‰« X.Î“ToStalk x := by
  dsimp only [LocallyRingedSpace.Î“ToStalk]
  rw [PresheafedSpace.stalkMap_germ']
  simp

noncomputable def _root_.AlgebraicGeometry.LocallyRingedSpace.ResidueField
    (X : LocallyRingedSpace) (x : X) : CommRingCat :=
  CommRingCat.of <| LocalRing.ResidueField (X.stalk x)

noncomputable def _root_.AlgebraicGeometry.LocallyRingedSpace.evaluation (X : LocallyRingedSpace)
    {U : TopologicalSpace.Opens X} (x : U) :
    X.presheaf.obj (op U) âŸ¶ X.ResidueField x :=
  X.presheaf.germ x â‰« LocalRing.residue _

lemma _root_.AlgebraicGeometry.LocallyRingedSpace.evaluation_eq_zero_iff_mem_maximalIdeal
    (X : LocallyRingedSpace) {U : TopologicalSpace.Opens X} (x : U) (f : X.presheaf.obj (op U)) :
    X.evaluation x f = 0 â†” (X.presheaf.germ x) f âˆˆ LocalRing.maximalIdeal (X.stalk x) :=
  LocalRing.residue_eq_zero_iff _

lemma _root_.AlgebraicGeometry.LocallyRingedSpace.evaluation_ne_zero_iff_isUnit
    (X : LocallyRingedSpace) {U : TopologicalSpace.Opens X} (x : U) (f : X.presheaf.obj (op U)) :
    X.evaluation x f â‰  0 â†” IsUnit ((X.presheaf.germ x) f) :=
  LocalRing.residue_ne_zero_iff_isUnit _

noncomputable def _root_.AlgebraicGeometry.LocallyRingedSpace.Î“evaluation (X : LocallyRingedSpace)
    (x : X) :
    LocallyRingedSpace.Î“.obj (op X) âŸ¶ X.ResidueField x :=
  X.evaluation âŸ¨x, show x âˆˆ âŠ¤ from trivialâŸ©

--lemma _root_.AlgebraicGeometry.LocallyRingedSpace.Î“evaluation_eq_zero_iff_mem_maximalIdeal
--    (X : LocallyRingedSpace) (x : X) (f : LocallyRingedSpace.Î“.obj (op X)) :
--    X.Î“evaluation x f = 0 â†” (X.presheaf.germ x) f âˆˆ LocalRing.maximalIdeal (X.stalk x) :=
--  LocalRing.residue_eq_zero_iff _

lemma _root_.AlgebraicGeometry.LocallyRingedSpace.Î“evaluation_ne_zero_iff_isUnit
    (X : LocallyRingedSpace) {U : TopologicalSpace.Opens X} (x : U) (f : X.presheaf.obj (op U)) :
    X.evaluation x f â‰  0 â†” IsUnit ((X.presheaf.germ x) f) :=
  LocalRing.residue_ne_zero_iff_isUnit _

noncomputable def _root_.AlgebraicGeometry.LocallyRingedSpace.evaluationMap
    {X Y : LocallyRingedSpace} (f : X âŸ¶ Y) (x : X) :
    Y.ResidueField (f.val.base x) âŸ¶ X.ResidueField x :=
  LocalRing.ResidueField.map (LocallyRingedSpace.stalkMap f x)

lemma _root_.AlgebraicGeometry.LocallyRingedSpace.mem_basicOpen (X : LocallyRingedSpace)
    {U : TopologicalSpace.Opens X}
    (f : X.presheaf.obj (op U)) (x : U) :
    x.val âˆˆ X.toRingedSpace.basicOpen f â†” X.evaluation x f â‰  0 := by
  rw [X.toRingedSpace.mem_basicOpen f x]
  exact (X.evaluation_ne_zero_iff_isUnit x f).symm

lemma _root_.AlgebraicGeometry.LocallyRingedSpace.mem_basicOpenÎ“ (X : LocallyRingedSpace)
    (f : X.presheaf.obj (op âŠ¤)) (x : X) :
    x âˆˆ X.toRingedSpace.basicOpen f â†” X.Î“evaluation x f â‰  0 :=
  LocallyRingedSpace.mem_basicOpen X f âŸ¨x, trivialâŸ©

lemma evaluation_evaluationMap {X Y : Scheme} (f : X âŸ¶ Y) (x : X) :
    Y.Î“evaluation (f.val.base x) â‰« LocallyRingedSpace.evaluationMap f x =
      Scheme.Î“.map f.op â‰« X.Î“evaluation x := by
  dsimp [LocallyRingedSpace.Î“evaluation, LocallyRingedSpace.evaluation,
    LocallyRingedSpace.evaluationMap]
  rw [Category.assoc]
  ext a
  simp only [comp_apply]
  erw [LocalRing.ResidueField.map_residue, PresheafedSpace.stalkMap_germ'_apply]
  rfl

lemma evaluation_evaluationMap_apply {X Y : Scheme} (f : X âŸ¶ Y) (x : X) (a : Scheme.Î“.obj (op Y)) :
    LocallyRingedSpace.evaluationMap f x (Y.Î“evaluation (f.val.base x) a) =
      X.Î“evaluation x (Scheme.Î“.map f.op a) := by
  simpa using congrFun (congrArg DFunLike.coe <| evaluation_evaluationMap f x) a

lemma Î“ToStalk_stalkMap_apply {X Y : Scheme} (f : X âŸ¶ Y) (x : X) (a : Scheme.Î“.obj (op Y)) :
    PresheafedSpace.stalkMap f.val x (Y.Î“ToStalk (f.val.base x) a) =
      X.Î“ToStalk x (Scheme.Î“.map f.op a) := by
  simpa using congrFun (congrArg DFunLike.coe <| Î“ToStalk_stalkMap f x) a

def _root_.AlgebraicGeometry.RingedSpace.zeroLocus {X : RingedSpace}
    (s : Set (X.presheaf.obj (op âŠ¤))) : Set X :=
  â‹‚ f âˆˆ s, (X.basicOpen f)á¶œ

lemma _root_.AlgebraicGeometry.RingedSpace.zeroLocus_singleton {X : RingedSpace}
    (f : X.presheaf.obj (op âŠ¤)) : X.zeroLocus {f} = (X.basicOpen f).carrierá¶œ := by
  simp [RingedSpace.zeroLocus]

lemma _root_.AlgebraicGeometry.LocallyRingedSpace.mem_zeroLocus_iff' {X : LocallyRingedSpace}
    (s : Set (X.presheaf.obj (op âŠ¤))) (x : X) :
      x âˆˆ X.toRingedSpace.zeroLocus s â†” âˆ€ f âˆˆ s, x âˆ‰ X.toRingedSpace.basicOpen f := by
  simp [RingedSpace.zeroLocus]
  rfl

lemma _root_.AlgebraicGeometry.LocallyRingedSpace.mem_zeroLocus_iff {X : LocallyRingedSpace}
    (s : Set (X.presheaf.obj (op âŠ¤))) (x : X) :
      x âˆˆ X.toRingedSpace.zeroLocus s â†” âˆ€ f âˆˆ s, X.Î“evaluation x f = 0 := by
  simp only [RingedSpace.zeroLocus, Set.mem_iInter, Set.mem_compl_iff, SetLike.mem_coe,
    LocallyRingedSpace.Î“_obj]
  simp only [LocallyRingedSpace.mem_basicOpenÎ“, ne_eq, not_not]
  rfl

lemma Scheme.zeroLocus_primeSpectrum_zeroLocus' {X : Scheme} (s : Set (Scheme.Î“.obj (op X))) :
    X.toÎ“SpecFun â»Â¹' PrimeSpectrum.zeroLocus s = RingedSpace.zeroLocus s := by
  simp only [RingedSpace.zeroLocus]
  have (i : Scheme.Î“.obj (op X)) (_ : i âˆˆ s) : (X.basicOpen i).carrierá¶œ =
        X.toÎ“SpecFun â»Â¹' (PrimeSpectrum.basicOpen i).carrierá¶œ := by
    symm
    rw [Set.preimage_compl, X.toÎ“Spec_preim_basicOpen_eq i]
    simp
    rfl
  erw [Set.iInterâ‚‚_congr this]
  rw [â† Set.preimage_iInterâ‚‚]
  simp only [Scheme.Î“_obj, Opens.carrier_eq_coe, PrimeSpectrum.basicOpen_eq_zeroLocus_compl, compl_compl]
  rw [â† PrimeSpectrum.zeroLocus_iUnionâ‚‚]
  simp

example [IsAffine X] : X.toÎ“SpecFun = X.isoSpec.hom.val.base := rfl

lemma Scheme.zeroLocus_primeSpectrum_zeroLocus {X : Scheme} [IsAffine X] (s : Set (Scheme.Î“.obj (op X))) :
    X.isoSpec.hom.val.base '' RingedSpace.zeroLocus s = PrimeSpectrum.zeroLocus s := by
  rw [â† Scheme.zeroLocus_primeSpectrum_zeroLocus']
  show X.isoSpec.hom.val.base '' (X.isoSpec.hom.val.base â»Â¹' PrimeSpectrum.zeroLocus s) =
    PrimeSpectrum.zeroLocus s
  rw [Set.image_preimage_eq]
  apply Function.Bijective.surjective
  have : IsIso (X.isoSpec.hom.val.base) := inferInstance
  exact ConcreteCategory.bijective_of_isIso (X.isoSpec.hom.val.base)

lemma Scheme.zeroLocus_eq_top_iff {X : Scheme} [IsAffine X] (s : Set (Scheme.Î“.obj (op X))) :
    RingedSpace.zeroLocus s = âŠ¤ â†” s âŠ† nilradical (Scheme.Î“.obj (op X)) := by
  rw [â† Scheme.zeroLocus_primeSpectrum_zeroLocus']
  simp only [Functor.op_obj, inducedFunctor_obj, LocallyRingedSpace.forgetToSheafedSpace_obj,
    LocallyRingedSpace.Î“_obj, Set.top_eq_univ, Set.preimage_eq_univ_iff, Scheme.Î“_obj]
  erw [â† PrimeSpectrum.zeroLocus_eq_top_iff]
  have hfsurj : Function.Surjective (X.toÎ“SpecFun) := by
    apply Function.Bijective.surjective
    apply ConcreteCategory.bijective_of_isIso X.isoSpec.hom.val.base
  rw [hfsurj.range_eq]
  simp

lemma Scheme.zeroLocus_mem {X : Scheme} (s : Set (Scheme.Î“.obj (op X)))
    (x : X) : x âˆˆ RingedSpace.zeroLocus s â†” âˆ€ f âˆˆ s, X.Î“evaluation x f = 0 :=
  LocallyRingedSpace.mem_zeroLocus_iff s x

lemma Scheme.basicOpen_eq_bot_iff {X : Scheme} [IsAffine X] (f : Scheme.Î“.obj (op X)) :
    X.basicOpen f = âŠ¥ â†” IsNilpotent f := by
  rw [â† mem_nilradical, â† Opens.coe_eq_empty, â† Set.compl_univ_iff]
  erw [â† RingedSpace.zeroLocus_singleton]
  rw [â† Set.top_eq_univ, Scheme.zeroLocus_eq_top_iff]
  simp

lemma Scheme.isNilpotent_iff {X : Scheme} [IsAffine X] (f : Scheme.Î“.obj (op X)) :
    IsNilpotent f â†” âˆ€ x, X.Î“evaluation x f = 0 := by
  rw [â† Scheme.basicOpen_eq_bot_iff]
  rw [â† Opens.coe_eq_empty]
  rw [Set.eq_empty_iff_forall_not_mem]
  rw [â† not_iff_not]
  simp only [Functor.op_obj, inducedFunctor_obj, LocallyRingedSpace.forgetToSheafedSpace_obj,
    SheafedSpace.forgetToPresheafedSpace_obj, SetLike.mem_coe, not_forall, not_not, LocallyRingedSpace.Î“_obj]
  simp_rw [â† ne_eq]
  constructor
  Â· intro âŸ¨x, hxâŸ©
    use x
    apply (X.mem_basicOpenÎ“ f x).mp hx
  Â· intro âŸ¨x, hxâŸ©
    use x
    apply (X.mem_basicOpenÎ“ f x).mpr hx

theorem eq_zeroLocus_of_isClosed (X : Scheme) [IsAffine X] (s : Set X.carrier) (hs : IsClosed s) :
    âˆƒ I : Ideal (Scheme.Î“.obj (op X)), s = RingedSpace.zeroLocus (I : Set (Scheme.Î“.obj (op X))) := by
  let A : CommRingCat := Scheme.Î“.obj (op X)
  let iso : X â‰… Spec A := Scheme.isoSpec X
  let Z : Set (Spec A) := iso.hom.val.base '' s
  have hZ : IsClosed Z :=
    (TopCat.homeoOfIso (asIso <| iso.hom.val.base)).isClosedMap _ hs
  obtain âŸ¨I, (hI : Z = _)âŸ© := (PrimeSpectrum.isClosed_iff_zeroLocus_ideal _).mp hZ
  use I
  have : Function.Injective (Set.image iso.hom.val.base) := by
    simp only [Set.image_injective]
    exact (ConcreteCategory.bijective_of_isIso iso.hom.val.base).injective
  apply this
  show Z = _
  rw [hI]
  erw [Scheme.zeroLocus_primeSpectrum_zeroLocus]

theorem surjective_of_closedInAffine_of_injective {X Y : Scheme} [IsAffine Y] [CompactSpace X]
    (f : X âŸ¶ Y) (hfcl : IsClosed (Set.range f.val.base))
    (hfinj : Function.Injective (Scheme.Î“.map f.op)) :
    Function.Surjective f.val.base := by
  let A : CommRingCat := Scheme.Î“.obj (op Y)
  obtain âŸ¨I, hIâŸ© := eq_zeroLocus_of_isClosed Y (Set.range f.val.base) hfcl
  let Ï† : A âŸ¶ Scheme.Î“.obj (op X) := Scheme.Î“.map f.op
  let ğ’° : X.OpenCover := X.affineCover.finiteSubcover
  have (i : ğ’°.J) : IsAffine (ğ’°.obj i) :=
    Scheme.isAffine_affineCover X _
  let B (i : ğ’°.J) : CommRingCat := Scheme.Î“.obj (op <| ğ’°.obj i)
  let res (i : ğ’°.J) : Scheme.Î“.obj (op X) âŸ¶ B i := Scheme.Î“.map (ğ’°.map i).op
  apply Set.range_iff_surjective.mp
  rw [hI]
  apply (Scheme.zeroLocus_eq_top_iff _).mpr
  have h1 (s : A) (hs : s âˆˆ I) (i : ğ’°.J) (x : ğ’°.obj i) :
      (ğ’°.obj i).Î“evaluation x ((res i) (Ï† s)) = 0 := by
    let y : Y := f.val.base <| (ğ’°.map i).val.base x
    have hyinrange : y âˆˆ Set.range f.val.base :=
      Set.mem_range_self ((ğ’°.map i).val.base x)
    have hys : Y.Î“evaluation y s = 0 := by
      rw [hI, Scheme.zeroLocus_mem] at hyinrange
      exact hyinrange s hs
    let fâ‚“ := LocallyRingedSpace.evaluationMap (ğ’°.map i â‰« f) x
    have hdiag2 :
        (ğ’°.obj i).Î“evaluation x ((res i) (Ï† s)) = fâ‚“ (Y.Î“evaluation y s) := by
      erw [evaluation_evaluationMap_apply]
      rfl
    rw [hdiag2, hys]
    simp
  have h3 (s : A) (hs : s âˆˆ I) (i : ğ’°.J) : IsNilpotent ((res i) (Ï† s)) := by
    rw [Scheme.isNilpotent_iff]
    intro x
    apply h1 s hs i x
  intro s hs
  simp only [SetLike.mem_coe, mem_nilradical, â† IsNilpotent.map_iff hfinj]
  apply isNilpotent_of_isNilpotent_cover _ ğ’°
  exact h3 s hs

noncomputable instance {X : Scheme} (x : X) : Algebra (X.presheaf.obj { unop := âŠ¤ }) (X.presheaf.stalk x) :=
  TopCat.Presheaf.algebra_section_stalk X.presheaf (U := âŠ¤) âŸ¨x, trivialâŸ©

noncomputable instance {X : Scheme} (x : X) : Algebra (X.presheaf.obj { unop := âŠ¤ }) (X.stalk x) :=
  TopCat.Presheaf.algebra_section_stalk X.presheaf (U := âŠ¤) âŸ¨x, trivialâŸ©


noncomputable
def stalkIsoOfIso {X Y : Scheme} (e : X â‰… Y) (x : X) : Y.stalk (e.hom.val.base x) â‰… X.stalk x :=
  letI F := Scheme.forgetToLocallyRingedSpace â‹™
      LocallyRingedSpace.forgetToSheafedSpace â‹™ SheafedSpace.forgetToPresheafedSpace
  PresheafedSpace.stalkMap.stalkIso (F.mapIso e) x

@[simp]
lemma stalkIsoOfIso_hom {X Y : Scheme} (e : X â‰… Y) (x : X) :
    (stalkIsoOfIso e x).hom = X.stalkMap e.hom x :=
  rfl

set_option maxHeartbeats 1000000

lemma fooz {X : Scheme.{u}} [IsAffine X] (a : X.presheaf.obj (op âŠ¤)) :
    (StructureSheaf.toOpen (X.presheaf.obj (op âŠ¤)) âŠ¤
      â‰« X.isoSpec.hom.val.c.app { unop := âŠ¤ }) a = a := by
  simp only [Scheme.isoSpec]
  simp only [asIso_hom, TopCat.Presheaf.pushforwardObj_obj, Functor.op_obj, Opens.map_top]
  erw [Î“Spec.toOpen_unit_app_val_c_app]
  simp
  rfl

lemma barz {X : Scheme.{u}} [IsAffine X] (x : X) (a : X.presheaf.obj (op âŠ¤)) :
    (X.presheaf.germ âŸ¨x, show x âˆˆ âŠ¤ from trivialâŸ©) a = (stalkIsoOfIso X.isoSpec x).hom
      ((StructureSheaf.toStalk (X.presheaf.obj (op âŠ¤)) (X.isoSpec.hom.val.base x)) a) := by
  let R := X.presheaf.obj (op âŠ¤)
  rw [stalkIsoOfIso_hom]
  simp [LocallyRingedSpace.stalkMap]
  simp only [StructureSheaf.toStalk]
  show (X.presheaf.germ âŸ¨x, show x âˆˆ âŠ¤ from trivialâŸ©) a =
      ((StructureSheaf.toOpen â†‘R âŠ¤ â‰« (Spec.structureSheaf â†‘R).presheaf.germ
        âŸ¨X.isoSpec.hom.val.base x, show X.isoSpec.hom.val.base x âˆˆ âŠ¤ from trivialâŸ© â‰«
          PresheafedSpace.stalkMap X.isoSpec.hom.val x)) a
  erw [PresheafedSpace.stalkMap_germ' X.isoSpec.hom.val âŠ¤]
  show (X.presheaf.germ âŸ¨x, show x âˆˆ âŠ¤ from trivialâŸ©) a =
    X.presheaf.germ âŸ¨x, show x âˆˆ âŠ¤ from trivialâŸ©
      ((StructureSheaf.toOpen â†‘R âŠ¤ â‰« X.isoSpec.hom.val.c.app (op âŠ¤)) a)
  rw [fooz]

lemma isLocalizationAtPrime [IsAffine X] (x : X) :
    IsLocalization.AtPrime (R := X.presheaf.obj (op âŠ¤))
      (X.stalk x) (X.isoSpec.hom.val.base x).asIdeal := by
  let R := X.presheaf.obj (op âŠ¤)
  let p : PrimeSpectrum R := X.isoSpec.hom.val.base x
  have islocal := StructureSheaf.IsLocalization.to_stalk R p
  let i := X.isoSpec
  have : (Scheme.Spec.obj (op <| R)).presheaf = (Spec.structureSheaf R).presheaf := rfl
  let is : (Spec.structureSheaf R).presheaf.stalk p â‰… X.stalk x :=
    stalkIsoOfIso i x
  have iff := IsLocalization.isLocalization_iff_of_ringEquiv p.asIdeal.primeCompl
    is.commRingCatIsoToRingEquiv
  have := iff.mp islocal
  show IsLocalization p.asIdeal.primeCompl â†‘(X.stalk x)
  convert this
  ext a b
  simp
  let inst1 := (is.commRingCatIsoToRingEquiv.toRingHom.comp
    (algebraMap R ((Spec.structureSheaf â†‘R).presheaf.stalk p))).toAlgebra
  let inst2 := (instAlgebraÎ±CommRingObjOppositeOpensTopologicalSpaceCarrierCommRingCatPresheafOpTopStalk_1 x)
  rw [@Algebra.smul_def _ _ _ _ inst1]
  rw [@Algebra.smul_def (X.presheaf.obj { unop := âŠ¤ }) (X.stalk x) _ _ inst2 a b]
  have : (algebraMap (X.presheaf.obj { unop := âŠ¤ }) (X.stalk x)) a =
      (@algebraMap R (X.stalk x) _ _ (inst1) a) := by
    show (algebraMap â†‘(X.presheaf.obj { unop := âŠ¤ }) â†‘(X.stalk x)) a =
      (is.commRingCatIsoToRingEquiv.toRingHom.comp (algebraMap â†‘R â†‘((Spec.structureSheaf â†‘R).presheaf.stalk p))) a
    simp [is, i]
    erw [TopCat.Presheaf.stalk_open_algebraMap]
    apply barz
  rw [this]

lemma isLocalization [IsAffine X] (x : X) : âˆƒ (M : Submonoid (X.presheaf.obj (op âŠ¤))),
    IsLocalization M (X.stalk x) := by
  use (X.isoSpec.hom.val.base x).asIdeal.primeCompl
  apply isLocalizationAtPrime

lemma injective_of_isLocalization {R S T} [CommRing R] (M : Submonoid R) [CommRing S] [Algebra R S]
    [IsLocalization M S] [CommRing T] (f : S â†’+* T) :
    Function.Injective f â†” âˆ€ (x y : R),
      algebraMap R S x = algebraMap R S y â†” f (algebraMap R S x) = f (algebraMap R S y) := by
  rw [â† IsLocalization.lift_of_comp (M := M) f, IsLocalization.lift_injective_iff]
  simp

lemma injective_iff_of_isLocalization' {R S T} [CommRing R] (M : Submonoid R) [CommRing S] [Algebra R S]
    [IsLocalization M S] [CommRing T] (f : S â†’+* T) :
    Function.Injective f â†” âˆ€ (x : R), algebraMap R S x = 0 â†” f (algebraMap R S x) = 0 := by
  rw [injective_of_isLocalization M]
  constructor
  Â· intro h x
    rw [â† map_zero (algebraMap R S), â† map_zero f, â† map_zero (algebraMap R S)]
    exact h x 0
  Â· intro h x y
    rw [â† sub_eq_zero]
    nth_rw 2 [â† sub_eq_zero]
    repeat rw [â† map_sub]
    exact h (x - y)

lemma injective_of_isLocalization' {R S T} [CommRing R] (M : Submonoid R) [CommRing S] [Algebra R S]
    [IsLocalization M S] [CommRing T] (f : S â†’+* T)
    (h : âˆ€ (x : R), f (algebraMap R S x) = 0 â†’ algebraMap R S x = 0) :
    Function.Injective f := by
  rw [injective_iff_of_isLocalization' M]
  exact fun x â†¦ âŸ¨fun h â†¦ by rw [h]; simp, h xâŸ©

theorem stalkMap_injective_of {X Y : Scheme} (f : X âŸ¶ Y) [IsAffine Y] (x : X)
    (h : âˆ€ g,
      LocallyRingedSpace.stalkMap f x (Y.Î“ToStalk (f.val.base x) g) = 0 â†’ Y.Î“ToStalk (f.val.base x) g = 0) :
    Function.Injective (LocallyRingedSpace.stalkMap f x) := by
  obtain âŸ¨M, hMâŸ© := isLocalization (f.val.base x)
  apply injective_of_isLocalization' M
  exact h

lemma Î“ToStalk_eq_zero_of {X : Scheme} (x : X) (f s : Scheme.Î“.obj (op X)) (hx : x âˆˆ X.basicOpen s)
    {n : â„•} (hf : s ^ n * f = 0) : X.Î“ToStalk x f = 0 := by
  rw [Scheme.mem_basicOpen_top] at hx
  replace hx : IsUnit (X.Î“ToStalk x s) := hx
  have hu : IsUnit (X.Î“ToStalk x (s ^ n)) := by
    rw [map_pow]
    exact IsUnit.pow n hx
  rw [â† hu.mul_right_eq_zero, â† map_mul, hf, map_zero]

lemma pow_mul_eq_zero_of_le {R : Type*} [CommRing R] {a b : R} {m n : â„•} (hmn : m â‰¤ n)
    (h : a ^ m * b = 0) : a ^ n * b = 0 := by
  have : n = n - m + m := by
    omega
  rw [show n = n - m + m by omega, pow_add, mul_assoc, h]
  simp

lemma res_basicOpen_eq_iff_of_qcqs {X : Scheme} {U : TopologicalSpace.Opens X}
    (hU : IsCompact U.carrier) (hU' : IsQuasiSeparated U.carrier)
    (f g s : X.presheaf.obj (op U))
    (hf : (f |_ X.basicOpen s : (forget CommRingCat).obj _) = (g |_ X.basicOpen s)) :
    âˆƒ n, s ^ n * f = s ^ n * g := by
  have hloc := is_localization_basicOpen_of_qcqs hU hU' s
  obtain âŸ¨âŸ¨_, n, rflâŸ©, hcâŸ© := hloc.exists_of_eq hf
  use n

lemma Î“res_basicOpen_eq_iff_of_qcqs {X : Scheme} [CompactSpace X] [QuasiSeparatedSpace X]
    (f g s : Scheme.Î“.obj (op X))
    (hf : (f |_ X.basicOpen s : (forget CommRingCat).obj _) = (g |_ X.basicOpen s)) :
    âˆƒ n, s ^ n * f = s ^ n * g := by
  apply res_basicOpen_eq_iff_of_qcqs
  Â· exact CompactSpace.isCompact_univ
  Â· exact isQuasiSeparated_univ
  Â· exact hf

@[simp]
lemma RingedSpace.res_zero {X : RingedSpace} {U V : TopologicalSpace.Opens X}
    (hUV : U â‰¤ V) : ((0 : X.presheaf.obj (op V)) |_ U : (forget CommRingCat).obj _) = 0 :=
  map_zero _

lemma res_basicOpen_zero_iff_of_qcqs {X : Scheme} {U : TopologicalSpace.Opens X}
    (hU : IsCompact U.carrier) (hU' : IsQuasiSeparated U.carrier)
    (f s : X.presheaf.obj (op U)) (hf : (f |_ X.basicOpen s : (forget CommRingCat).obj _) = 0) :
    âˆƒ n, s ^ n * f = 0 := by
  have := by
    apply res_basicOpen_eq_iff_of_qcqs hU hU' f 0 s
    simp only [RingedSpace.res_zero]
    exact hf
  simp at this
  assumption

lemma Î“res_basicOpen_zero_iff_of_qcqs {X : Scheme} [CompactSpace X] [QuasiSeparatedSpace X]
    (f s : Scheme.Î“.obj (op X)) (hf : (f |_ X.basicOpen s : (forget CommRingCat).obj _) = 0) :
    âˆƒ n, s ^ n * f = 0 := by
  apply res_basicOpen_zero_iff_of_qcqs
  Â· exact CompactSpace.isCompact_univ
  Â· exact isQuasiSeparated_univ
  Â· exact hf

section

variable {X Y : Scheme} (f : X âŸ¶ Y) (U : Opens Y) (s : Scheme.Î“.obj (op Y))

end

lemma pullback_zero_of_zero {X Y : Scheme} (f : X âŸ¶ Y) (U : Opens Y) (s : Scheme.Î“.obj (op Y))
    (h : (s |_ U : (forget CommRingCat).obj _) = 0) :
    ((Scheme.Î“.map f.op s) |_ fâ»Â¹áµ U : (forget CommRingCat).obj _) = 0 := by
  simp only [Functor.op_obj, inducedFunctor_obj, LocallyRingedSpace.forgetToSheafedSpace_obj,
    SheafedSpace.forgetToPresheafedSpace_obj, Scheme.Î“_obj, Scheme.Î“_map, Quiver.Hom.unop_op]
  let e : U â‰¤ âŠ¤ := le_top
  let i : op âŠ¤ âŸ¶ op U := (homOfLE e).op
  show (f.app âŠ¤ â‰« X.presheaf.map ((Opens.map f.1.base).map i.unop).op) s = 0
  rw [â† Scheme.Hom.naturality, comp_apply]
  show (Scheme.Hom.app f U) (s |_ U) = 0
  rw [h]
  simp

lemma map_le {X Y : Scheme} (f : X âŸ¶ Y) {U V : Opens Y} (hUV : U â‰¤ V) :
    fâ»Â¹áµ U â‰¤ fâ»Â¹áµ V :=
  leOfHom <| (Opens.map f.val.base).map (homOfLE hUV)

theorem injective_on_stalks {X Y : Scheme} (f : X âŸ¶ Y) [CompactSpace X] [IsAffine Y]
    (hfopen : IsOpenMap f.val.base)
    (hfinjâ‚ : Function.Injective f.val.base)
    (hfinjâ‚‚ : Function.Injective (Scheme.Î“.map f.op)) (x : X) :
    Function.Injective (LocallyRingedSpace.stalkMap f x) := by
  let A : CommRingCat := Scheme.Î“.obj (op Y)
  let Ï† : A âŸ¶ Scheme.Î“.obj (op X) := Scheme.Î“.map f.op
  let ğ’° : X.OpenCover := X.affineCover.finiteSubcover
  have (i : ğ’°.J) : IsAffine (ğ’°.obj i) := Scheme.isAffine_affineCover X _
  let res (i : ğ’°.J) : Scheme.Î“.obj (op X) âŸ¶ Scheme.Î“.obj (op <| ğ’°.obj i) :=
    Scheme.Î“.map (ğ’°.map i).op
  apply stalkMap_injective_of
  intro (g : A) h
  erw [Î“ToStalk_stalkMap_apply] at h
  obtain âŸ¨U, _, (hx : x âˆˆ U), hgâŸ© :=
    X.toRingedSpace.eq_zero_res_of_eq_zero_germ âŠ¤ (Ï† g) âŸ¨x, trivialâŸ© h
  let y : Y := f.val.base x
  let V : TopologicalSpace.Opens Y := âŸ¨f.val.base '' U.carrier, hfopen U.carrier U.is_open'âŸ©
  have hyv : y âˆˆ V := by
    simp only [TopologicalSpace.Opens.carrier_eq_coe, TopologicalSpace.Opens.mem_mk, Set.mem_image,
      SetLike.mem_coe, V]
    use x
  have : TopologicalSpace.Opens.IsBasis (Set.range Y.basicOpen) := isBasis_basicOpen Y
  rw [Opens.isBasis_iff_nbhd] at this
  obtain âŸ¨V', âŸ¨(s : A), rflâŸ©, hyv', yv'leâŸ© := this hyv
  let W (i : ğ’°.J) : TopologicalSpace.Opens (ğ’°.obj i) := ((ğ’°.obj i).basicOpen ((res i) (Ï† s)))
  let r (i : ğ’°.J) : (forget CommRingCat).obj ((ğ’°.obj i).presheaf.obj (op <| W i)) :=
    (res i) (Ï† g) |_ (W i)
  let r0 (i : ğ’°.J) : (forget CommRingCat).obj ((ğ’°.obj i).presheaf.obj (op <| (ğ’°.map i)â»Â¹áµ U)) :=
    ((res i) (Ï† g) |_ (ğ’°.map i)â»Â¹áµ U)
  have h00 (i : ğ’°.J) : r0 i = 0 := by
    dsimp only [r0, res]
    apply pullback_zero_of_zero
    exact hg
  have hwle (i : ğ’°.J) : W i â‰¤ (ğ’°.map i)â»Â¹áµ U := by
    show ((ğ’°.obj i).toRingedSpace.basicOpen ((ğ’°.map i â‰« f).val.c.app (op âŠ¤) s)) â‰¤ _
    erw [â† LocallyRingedSpace.preimage_basicOpen (ğ’°.map i â‰« f) s]
    dsimp
    apply map_le
    apply map_le f at yv'le
    dsimp only [V] at yv'le
    trans
    exact yv'le
    apply le_of_eq
    apply Opens.ext
    apply Set.preimage_image_eq
    exact hfinjâ‚
  have h0 (i : ğ’°.J) : r i = 0 := by
    dsimp [r]
    rw [â† TopCat.Presheaf.restrict_restrict (hwle i)]
    dsimp [r0] at h00
    rw [h00 i]
    rfl
  have h1 (i : ğ’°.J) : âˆƒ n, (res i) (Ï† (s ^ n * g)) = 0 := by
    obtain âŸ¨n, hnâŸ© := Î“res_basicOpen_zero_iff_of_qcqs ((res i) (Ï† g)) ((res i) (Ï† s)) (h0 i)
    use n
    rwa [map_mul, map_mul, map_pow, map_pow]
  have h2 : âˆƒ n, âˆ€ i, (res i) (Ï† (s ^ n * g)) = 0 := by
    choose fn hfn using h1
    have : Fintype ğ’°.J := Fintype.ofFinite ğ’°.J
    /- the maximum of all `fn i` (exists, because `ğ’°.J` is finite) -/
    let N : â„• := Finset.sup Finset.univ fn
    have hfnleN (i : ğ’°.J) : fn i â‰¤ N := Finset.le_sup (Finset.mem_univ i)
    use N
    intro i
    rw [map_mul, map_pow, map_mul, map_pow]
    simp only [map_mul, map_pow, map_mul, map_pow] at hfn
    apply pow_mul_eq_zero_of_le (hfnleN i) (hfn i)
  obtain âŸ¨n, hnâŸ© := h2
  have h3 : Ï† (s ^ n * g) = 0 :=
    zero_of_zero_cover _ _ hn
  have h4 : s ^ n * g = 0 := by
    rw [RingHom.injective_iff_ker_eq_bot, RingHom.ker_eq_bot_iff_eq_zero] at hfinjâ‚‚
    exact hfinjâ‚‚ _ h3
  exact Î“ToStalk_eq_zero_of y g s hyv' h4

theorem TopCat.isIso_of_bijective_of_isClosedMap {X Y : TopCat} (f : X âŸ¶ Y)
    (hfbij : Function.Bijective f) (hfcl : IsClosedMap f) : IsIso f := by
  let e : X â‰ƒâ‚œ Y := Homeomorph.homeomorphOfContinuousClosed
    (Equiv.ofBijective f hfbij) f.continuous hfcl
  let i : X â‰… Y := TopCat.isoOfHomeo e
  show IsIso i.hom
  infer_instance

theorem closedImmersion_affine_target_iso {X Y : Scheme} [IsAffine Y]
    (f : X âŸ¶ Y) [IsClosedImmersion f] (hf : Function.Injective (Scheme.Î“.map f.op)) :
    IsIso f := by
  have : CompactSpace X := (closedEmbedding f).compactSpace
  have : IsIso f.val.base := by
    refine TopCat.isIso_of_bijective_of_isClosedMap _ âŸ¨?_, ?_âŸ© ?_
    Â· exact (closedEmbedding f).inj
    Â· apply surjective_of_closedInAffine_of_injective
      Â· exact (closedEmbedding f).isClosed_range
      Â· exact hf
    Â· exact (closedEmbedding f).isClosedMap
  rw [isIso_iff_stalk_iso]
  constructor
  Â· assumption
  Â· intro x
    apply (ConcreteCategory.isIso_iff_bijective _).mpr
    constructor
    Â· apply injective_on_stalks
      Â· exact (TopCat.homeoOfIso (asIso f.val.base)).isOpenMap
      Â· exact (closedEmbedding f).inj
      Â· exact hf
    Â· exact surjective_stalkMap f x

noncomputable example (A : CommRingCat) : Scheme.Î“.obj (op <| Spec A) âŸ¶ A :=
  Scheme.SpecÎ“Identity.hom.app A

lemma toSpecÎ“_Î“Spec_adjunction_homEquiv {X : Scheme} {B : CommRingCat} (Ï† : B âŸ¶ Scheme.Î“.obj (op X)) :
    toSpecÎ“ B â‰« ((Î“Spec.adjunction.homEquiv X (op B)) Ï†.op).val.c.app (op âŠ¤) = Ï† := by
  rw [AlgebraicGeometry.Î“Spec.adjunction_homEquiv]
  erw [AlgebraicGeometry.Î“Spec.locallyRingedSpaceAdjunction_homEquiv_apply']
  show toSpecÎ“ B â‰« (Spec.locallyRingedSpaceMap Ï†).val.c.app (op âŠ¤) â‰«
    (identityToÎ“Spec.app X.toLocallyRingedSpace).val.c.app (op âŠ¤) = Ï†
  rw [â† LocallyRingedSpace.SpecÎ“Identity_inv_app]
  convert_to Ï† â‰«
    LocallyRingedSpace.SpecÎ“Identity.inv.app (LocallyRingedSpace.Î“.obj { unop := X.toLocallyRingedSpace }) â‰«
     (identityToÎ“Spec.app X.toLocallyRingedSpace).val.c.app (op âŠ¤) = Ï†
  have hfoo : toSpecÎ“ B â‰« StructureSheaf.comap Ï† âŠ¤ âŠ¤ (by trivial) = Ï† â‰« toSpecÎ“ Î“(X, âŠ¤) := by
    erw [Spec_Î“_naturality]
    simp
  Â· simp only [Functor.comp_obj, Functor.rightOp_obj, LocallyRingedSpace.Î“_obj, Spec.toLocallyRingedSpace_obj,
      Spec.locallyRingedSpaceObj_toSheafedSpace, Spec.sheafedSpaceObj_carrier, Functor.id_obj,
      TopCat.Presheaf.pushforwardObj_obj, Functor.op_obj, Opens.map_top, Spec.sheafedSpaceObj_presheaf,
      LocallyRingedSpace.SpecÎ“Identity_inv_app, Scheme.Î“_obj, Spec.locallyRingedSpaceMap_val,
      Spec.sheafedSpaceMap_base, Spec.sheafedSpaceMap_c_app]
    rw [â† Category.assoc]
    rw [â† Category.assoc]
    rw [hfoo]
  Â· rw [Î“Spec.left_triangle X.toLocallyRingedSpace]
    simp

lemma Î“Spec_adjunction_homEquiv_app_top {X : Scheme} {B : CommRingCat} (Ï† : B âŸ¶ Scheme.Î“.obj (op X)) :
    (((Î“Spec.adjunction.homEquiv X (op B)) Ï†.op).val.c.app (op âŠ¤)) = inv (toSpecÎ“ B) â‰« Ï† := by
  simp_rw [â† toSpecÎ“_Î“Spec_adjunction_homEquiv Ï†]
  simp

set_option maxHeartbeats 500000

lemma specMap_app_top {A B : CommRingCat} (Ï† : A âŸ¶ B) :
    (Spec.map Ï†).val.c.app (op âŠ¤) = inv (toSpecÎ“ A) â‰« Ï† â‰« toSpecÎ“ B := by
  rw [Spec_Î“_naturality]
  simp
  rfl

lemma specMap_app_top_surjective {A B : CommRingCat} (Ï† : A âŸ¶ B) (hÏ† : Function.Surjective Ï†) :
    Function.Surjective ((Spec.map Ï†).val.c.app (op âŠ¤)) := by
  rw [specMap_app_top]
  erw [CommRingCat.coe_comp]
  erw [CommRingCat.coe_comp]
  apply Function.Surjective.comp
  Â· apply Function.Surjective.comp
    Â· apply Function.Bijective.surjective
      apply (ConcreteCategory.isIso_iff_bijective _).mp
      infer_instance
    Â· exact hÏ†
  Â· apply Function.Bijective.surjective
    apply (ConcreteCategory.isIso_iff_bijective _).mp
    infer_instance

theorem spec_target_factorization {X : Scheme} {A : CommRingCat} (f : X âŸ¶ Spec A) :
    âˆƒ (B : CommRingCat) (g : X âŸ¶ Spec B) (h : A âŸ¶ B),
      f = g â‰« Spec.map h âˆ§ Function.Surjective h âˆ§
        Function.Injective (Scheme.Î“.map g.op) := by
  let Ï† : A âŸ¶ Scheme.Î“.obj (op X) :=
    (((Î“Spec.adjunction).homEquiv X (op A)).symm f).unop
  let I : Ideal A := RingHom.ker Ï†
  let B : CommRingCat := CommRingCat.of <| A â§¸ I
  let Ï†' : B âŸ¶ Scheme.Î“.obj (op X) := RingHom.kerLift Ï†
  have hinj : Function.Injective Ï†' := RingHom.kerLift_injective Ï†
  use B
  let g : X âŸ¶ Spec B :=
    (Î“Spec.adjunction).homEquiv X (op B) Ï†'.op
  use g
  let h : A âŸ¶ B := Ideal.Quotient.mk I
  use h
  have hd : Ï† = h â‰« Ï†' := by
    ext a
    simp only [Scheme.Î“_obj, comp_apply]
    symm
    apply RingHom.kerLift_mk
  refine âŸ¨?_, ?_, ?_âŸ©
  Â· apply ((Î“Spec.adjunction).homEquiv X (op A)).symm.injective
    apply Opposite.unop_injective
    show Ï† = _
    rw [Adjunction.homEquiv_naturality_left_symm]
    rw [Adjunction.homEquiv_counit]
    show Ï† = _ â‰« _
    show Ï† = (_ â‰« _) â‰« _
    dsimp only [g]
    simp only [Scheme.Î“_obj, Functor.rightOp_obj, Scheme.Spec_obj, Functor.id_obj, Î“Spec.adjunction_counit_app,
      Quiver.Hom.unop_op, Functor.rightOp_map, Scheme.Î“_map, Category.assoc]
    rw [â† Category.assoc]
    erw [â† Spec_Î“_naturality]
    simp
    show Ï† = h â‰« toSpecÎ“ B â‰« _
    erw [toSpecÎ“_Î“Spec_adjunction_homEquiv Ï†']
    exact hd
  Â· exact Ideal.Quotient.mk_surjective
  Â· simp only [g]
    simp only [Scheme.Î“_obj, Functor.rightOp_obj, Scheme.Spec_obj, Scheme.Î“_map, Scheme.Hom.app,
      Quiver.Hom.unop_op]
    erw [Î“Spec_adjunction_homEquiv_app_top]
    erw [CommRingCat.coe_comp]
    apply Function.Injective.comp
    Â· exact hinj
    Â· apply Function.Bijective.injective
      apply (ConcreteCategory.isIso_iff_bijective _).mp
      infer_instance

instance (B : CommRingCat) : IsAffine (Spec B) := isAffine_Spec B

theorem affine_target_factorization {X Y : Scheme} [IsAffine Y] (f : X âŸ¶ Y) :
    âˆƒ (Z : Scheme) (g : X âŸ¶ Z) (h : Z âŸ¶ Y),
      f = g â‰« h âˆ§ IsAffine Z âˆ§ Function.Surjective (Scheme.Î“.map h.op) âˆ§
        Function.Injective (Scheme.Î“.map g.op) := by
  let isoY := Y.isoSpec
  obtain âŸ¨B, g, h, hcomp, hsurj, hinjâŸ© := spec_target_factorization (f â‰« isoY.hom)
  refine âŸ¨Spec B, g, Spec.map h â‰« isoY.inv, ?_, ?_, ?_, ?_âŸ©
  Â· rw [â† Category.assoc]
    rw [â† hcomp]
    simp
  Â· infer_instance
  Â· simp
    rw [CommRingCat.coe_comp]
    apply (specMap_app_top_surjective h hsurj).comp
    Â· apply Function.Bijective.surjective
      apply ConcreteCategory.bijective_of_isIso
  Â· exact hinj

theorem closedImmersion_affine_target {X Y : Scheme} [IsAffine Y] (f : X âŸ¶ Y)
    [IsClosedImmersion f] : IsAffine X âˆ§ Function.Surjective (Scheme.Î“.map f.op) := by
  obtain âŸ¨Z, g, h, rfl, hZA, hh, hgâŸ© := affine_target_factorization f
  have : IsClosedImmersion h := of_surjective_of_affine h hh
  have : IsClosedImmersion g := IsClosedImmersion.of_comp g h
  have : IsIso g := closedImmersion_affine_target_iso g hg
  constructor
  Â· apply isAffine_of_isIso g
  Â· simp
    show Function.Surjective (_ âˆ˜ Scheme.Î“.map h.op)
    apply Function.Surjective.comp
    Â· apply Function.Bijective.surjective
      apply ConcreteCategory.bijective_of_isIso
    Â· exact hh

end Affine

section

end

open Limits

theorem closedImmersion_pullback_fst_of_isAffine {X Y Z : Scheme} [IsAffine X] [IsAffine Y] [IsAffine Z]
    (f : X âŸ¶ Y) (g : Z âŸ¶ Y) [IsClosedImmersion g]  :
    IsClosedImmersion (pullback.fst : pullback f g âŸ¶ X) := by
  have : Function.Surjective (Scheme.Î“.map g.op) :=
    (closedImmersion_affine_target g).right
  apply of_surjective_of_affine
  apply (RingHom.surjective_stableUnderBaseChange).Î“_pullback_fst
  Â· exact RingHom.surjective_respectsIso
  Â· exact (closedImmersion_affine_target g).right

theorem closedImmersion_stableUnderBaseChange :
    MorphismProperty.StableUnderBaseChange @IsClosedImmersion := by
  apply MorphismProperty.stableUnderBaseChange_of_isLocalAtTarget_of_affine
  Â· exact closedImmersion_localAtTarget
  Â· apply MorphismProperty.StableUnderAffineBaseChange.mk
    Â· exact respectsIso
    Â· intro X Y S _ _ f g hg
      have : IsAffine Y := (closedImmersion_affine_target g).left
      exact closedImmersion_pullback_fst_of_isAffine f g

instance {X Y : Scheme} (f : X âŸ¶ Y) [IsClosedImmersion f] : QuasiCompact f where
  isCompact_preimage _ _ hU' := base_closed.isCompact_preimage hU'

end IsClosedImmersion

end AlgebraicGeometry
