/-
Copyright (c) 2023 Jonas van der Schaaf. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Amelia Livingston, Christian Merten, Jonas van der Schaaf
-/
import Mathlib.AlgebraicGeometry.Morphisms.Affine
import Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties
import Mathlib.AlgebraicGeometry.Morphisms.FiniteType
import Mathlib.AlgebraicGeometry.Morphisms.IsIso
import Mathlib.AlgebraicGeometry.ResidueField
import Mathlib.AlgebraicGeometry.Properties

/-!

# Closed immersions of schemes

A morphism of schemes `f : X ‚ü∂ Y` is a closed immersion if the underlying map of topological spaces
is a closed immersion and the induced morphisms of stalks are all surjective.

## Main definitions

* `IsClosedImmersion` : The property of scheme morphisms stating `f : X ‚ü∂ Y` is a closed immersion.

## TODO

* Show closed immersions are precisely the proper monomorphisms
* Define closed immersions of locally ringed spaces, where we also assume that the kernel of `O_X ‚Üí
  f_*O_Y` is locally generated by sections as an `O_X`-module, and relate it to this file. See
  https://stacks.math.columbia.edu/tag/01HJ.

-/

universe v u

open CategoryTheory Opposite TopologicalSpace Topology

namespace AlgebraicGeometry

/-- A morphism of schemes `X ‚ü∂ Y` is a closed immersion if the underlying
topological map is a closed embedding and the induced stalk maps are surjective. -/
@[mk_iff]
class IsClosedImmersion {X Y : Scheme} (f : X ‚ü∂ Y) : Prop extends SurjectiveOnStalks f where
  base_closed : IsClosedEmbedding f.base

lemma Scheme.Hom.isClosedEmbedding {X Y : Scheme} (f : X.Hom Y)
    [IsClosedImmersion f] : IsClosedEmbedding f.base :=
  IsClosedImmersion.base_closed

namespace IsClosedImmersion

@[deprecated (since := "2024-10-24")]
alias isClosedEmbedding := Scheme.Hom.isClosedEmbedding
@[deprecated (since := "2024-10-20")]
alias closedEmbedding := isClosedEmbedding

lemma eq_inf : @IsClosedImmersion = (topologically IsClosedEmbedding) ‚äì
    @SurjectiveOnStalks := by
  ext X Y f
  rw [isClosedImmersion_iff, and_comm]
  rfl

lemma iff_isPreimmersion {X Y : Scheme} {f : X ‚ü∂ Y} :
    IsClosedImmersion f ‚Üî IsPreimmersion f ‚àß IsClosed (Set.range f.base) := by
  rw [isClosedImmersion_iff, isPreimmersion_iff, and_assoc, isClosedEmbedding_iff]

lemma of_isPreimmersion {X Y : Scheme} (f : X ‚ü∂ Y) [IsPreimmersion f]
    (hf : IsClosed (Set.range f.base)) : IsClosedImmersion f :=
  iff_isPreimmersion.mpr ‚ü®‚Äπ_‚Ä∫, hf‚ü©

instance (priority := 900) {X Y : Scheme} (f : X ‚ü∂ Y) [IsClosedImmersion f] : IsPreimmersion f :=
  (iff_isPreimmersion.mp ‚Äπ_‚Ä∫).1

/-- Isomorphisms are closed immersions. -/
instance {X Y : Scheme} (f : X ‚ü∂ Y) [IsIso f] : IsClosedImmersion f where
  base_closed := Homeomorph.isClosedEmbedding <| TopCat.homeoOfIso (asIso f.base)
  surj_on_stalks := fun _ ‚Ü¶ (ConcreteCategory.bijective_of_isIso _).2

instance (priority := low) {X Y : Scheme} [IsEmpty X] (f : X ‚ü∂ Y) : IsClosedImmersion f :=
  .of_isPreimmersion _ (by rw [Set.range_eq_empty]; exact isClosed_empty)

instance : MorphismProperty.IsMultiplicative @IsClosedImmersion where
  id_mem _ := inferInstance
  comp_mem _ _ hf hg := ‚ü®hg.base_closed.comp hf.base_closed‚ü©

/-- Composition of closed immersions is a closed immersion. -/
instance comp {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsClosedImmersion f]
    [IsClosedImmersion g] : IsClosedImmersion (f ‚â´ g) :=
  MorphismProperty.IsStableUnderComposition.comp_mem f g inferInstance inferInstance

/-- Composition with an isomorphism preserves closed immersions. -/
instance respectsIso : MorphismProperty.RespectsIso @IsClosedImmersion := by
  apply MorphismProperty.RespectsIso.mk <;> intro X Y Z e f hf <;> infer_instance

/-- Given two commutative rings `R S : CommRingCat` and a surjective morphism
`f : R ‚ü∂ S`, the induced scheme morphism `specObj S ‚ü∂ specObj R` is a
closed immersion. -/
theorem spec_of_surjective {R S : CommRingCat} (f : R ‚ü∂ S) (h : Function.Surjective f) :
    IsClosedImmersion (Spec.map f) where
  base_closed := PrimeSpectrum.isClosedEmbedding_comap_of_surjective _ _ h
  surj_on_stalks x := by
    haveI : (RingHom.toMorphismProperty (fun f ‚Ü¶ Function.Surjective f)).RespectsIso := by
      rw [‚Üê RingHom.toMorphismProperty_respectsIso_iff]
      exact RingHom.surjective_respectsIso
    apply (MorphismProperty.arrow_mk_iso_iff
      (RingHom.toMorphismProperty (fun f ‚Ü¶ Function.Surjective f))
      (Scheme.arrowStalkMapSpecIso f x)).mpr
    exact RingHom.surjective_localRingHom_of_surjective f.hom h x.asIdeal

/-- For any ideal `I` in a commutative ring `R`, the quotient map `specObj R ‚ü∂ specObj (R ‚ß∏ I)`
is a closed immersion. -/
instance spec_of_quotient_mk {R : CommRingCat.{u}} (I : Ideal R) :
    IsClosedImmersion (Spec.map (CommRingCat.ofHom (Ideal.Quotient.mk I))) :=
  spec_of_surjective _ Ideal.Quotient.mk_surjective

/-- Any morphism between affine schemes that is surjective on global sections is a
closed immersion. -/
lemma of_surjective_of_isAffine {X Y : Scheme} [IsAffine X] [IsAffine Y] (f : X ‚ü∂ Y)
    (h : Function.Surjective (f.appTop)) : IsClosedImmersion f := by
  rw [MorphismProperty.arrow_mk_iso_iff @IsClosedImmersion (arrowIsoSpecŒìOfIsAffine f)]
  apply spec_of_surjective
  exact h

/--
If `f ‚â´ g` and `g` are closed immersions, then `f` is a closed immersion.
Also see `IsClosedImmersion.of_comp` for the general version
where `g` is only required to be separated.
-/
theorem of_comp_isClosedImmersion {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsClosedImmersion g]
    [IsClosedImmersion (f ‚â´ g)] : IsClosedImmersion f where
  base_closed := by
    have h := (f ‚â´ g).isClosedEmbedding
    simp only [Scheme.comp_coeBase, TopCat.coe_comp] at h
    refine .of_continuous_injective_isClosedMap (Scheme.Hom.continuous f) h.injective.of_comp ?_
    intro Z hZ
    rw [IsClosedEmbedding.isClosed_iff_image_isClosed g.isClosedEmbedding,
      ‚Üê Set.image_comp]
    exact h.isClosedMap _ hZ
  surj_on_stalks x := by
    have h := (f ‚â´ g).stalkMap_surjective x
    simp_rw [Scheme.stalkMap_comp] at h
    exact Function.Surjective.of_comp h

instance Spec_map_residue {X : Scheme.{u}} (x) : IsClosedImmersion (Spec.map (X.residue x)) :=
  IsClosedImmersion.spec_of_surjective (X.residue x)
    Ideal.Quotient.mk_surjective

instance {X Y : Scheme} (f : X ‚ü∂ Y) [IsClosedImmersion f] : QuasiCompact f where
  isCompact_preimage _ _ hU' := base_closed.isCompact_preimage hU'

end IsClosedImmersion

section Affine

variable {X Y : Scheme.{u}} [IsAffine Y] {f : X ‚ü∂ Y}

open IsClosedImmersion LocallyRingedSpace

/-- If `f : X ‚ü∂ Y` is a morphism of schemes with quasi-compact source and affine target, `f`
has a closed image and `f` induces an injection on global sections, then
`f` is surjective. -/
lemma surjective_of_isClosed_range_of_injective [CompactSpace X]
    (hfcl : IsClosed (Set.range f.base)) (hfinj : Function.Injective (f.appTop)) :
    Function.Surjective f.base := by
  obtain ‚ü®I, hI‚ü© := (Scheme.eq_zeroLocus_of_isClosed_of_isAffine Y (Set.range f.base)).mp hfcl
  let ùí∞ : X.OpenCover := X.affineCover.finiteSubcover
  haveI (i : ùí∞.J) : IsAffine (ùí∞.obj i) := Scheme.isAffine_affineCover X _
  apply Set.range_eq_univ.mp
  apply hI ‚ñ∏ (Scheme.zeroLocus_eq_top_iff_subset_nilradical _).mpr
  intro s hs
  simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,
    Submodule.mem_toAddSubmonoid, SetLike.mem_coe, mem_nilradical, ‚Üê IsNilpotent.map_iff hfinj]
  refine Scheme.isNilpotent_of_isNilpotent_cover _ ùí∞ (fun i ‚Ü¶ ?_)
  rw [Scheme.isNilpotent_iff_basicOpen_eq_bot]
  rw [Scheme.basicOpen_eq_bot_iff_forall_evaluation_eq_zero]
  intro x
  suffices h : f.base ((ùí∞.map i).base x.val) ‚àâ Y.basicOpen s by
    erw [‚Üê Scheme.Œìevaluation_naturality_apply (ùí∞.map i ‚â´ f)]
    simpa only [Scheme.comp_base, TopCat.coe_comp, Function.comp_apply,
      Scheme.residueFieldMap_comp, CommRingCat.comp_apply, map_eq_zero,
      Scheme.evaluation_eq_zero_iff_not_mem_basicOpen]
  exact (Y.mem_zeroLocus_iff I _).mp (hI ‚ñ∏ Set.mem_range_self ((ùí∞.map i).base x.val)) s hs

/-- If `f : X ‚ü∂ Y` is open, injective, `X` is quasi-compact and `Y` is affine, then `f` is stalkwise
injective if it is injective on global sections. -/
lemma stalkMap_injective_of_isOpenMap_of_injective [CompactSpace X]
    (hfopen : IsOpenMap f.base) (hfinj‚ÇÅ : Function.Injective f.base)
    (hfinj‚ÇÇ : Function.Injective (f.appTop)) (x : X) :
    Function.Injective (f.stalkMap x) := by
  let œÜ : Œì(Y, ‚ä§) ‚ü∂ Œì(X, ‚ä§) := f.appTop
  let ùí∞ : X.OpenCover := X.affineCover.finiteSubcover
  have (i : ùí∞.J) : IsAffine (ùí∞.obj i) := Scheme.isAffine_affineCover X _
  let res (i : ùí∞.J) : Œì(X, ‚ä§) ‚ü∂ Œì(ùí∞.obj i, ‚ä§) := (ùí∞.map i).appTop
  refine stalkMap_injective_of_isAffine _ _ (fun (g : Œì(Y, ‚ä§)) h ‚Ü¶ ?_)
  rw [TopCat.Presheaf.Œìgerm, Scheme.stalkMap_germ_apply] at h
  obtain ‚ü®U, w, (hx : x ‚àà U), hg‚ü© :=
    X.toRingedSpace.exists_res_eq_zero_of_germ_eq_zero ‚ä§ (œÜ g) ‚ü®x, trivial‚ü© h
  obtain ‚ü®_, ‚ü®s, rfl‚ü©, hyv, bsle‚ü© := Opens.isBasis_iff_nbhd.mp (isBasis_basicOpen Y)
    (show f.base x ‚àà ‚ü®f.base '' U.carrier, hfopen U.carrier U.is_open'‚ü© from ‚ü®x, by simpa‚ü©)
  let W (i : ùí∞.J) : TopologicalSpace.Opens (ùí∞.obj i) := (ùí∞.obj i).basicOpen ((res i) (œÜ s))
  have hwle (i : ùí∞.J) : W i ‚â§ (ùí∞.map i)‚Åª¬π·µÅ U := by
    show (ùí∞.obj i).basicOpen ((ùí∞.map i ‚â´ f).appTop s) ‚â§ _
    rw [‚Üê Scheme.preimage_basicOpen_top, Scheme.comp_coeBase, Opens.map_comp_obj]
    refine Scheme.Hom.preimage_le_preimage_of_le _
      (le_trans (f.preimage_le_preimage_of_le bsle) (le_of_eq ?_))
    simp [Set.preimage_image_eq _ hfinj‚ÇÅ]
  have h0 (i : ùí∞.J) : (ùí∞.map i).appLE _ (W i) (by simp) (œÜ g) = 0 := by
    rw [‚Üê Scheme.Hom.appLE_map _ _ (homOfLE <| hwle i).op, ‚Üê Scheme.Hom.map_appLE _ le_rfl w.op]
    simp only [CommRingCat.comp_apply]
    rw [hg]
    simp only [map_zero]
  have h1 (i : ùí∞.J) : ‚àÉ n, (res i) (œÜ (s ^ n * g)) = 0 := by
    obtain ‚ü®n, hn‚ü© := exists_of_res_zero_of_qcqs_of_top (s := ((res i) (œÜ s))) (h0 i)
    exact ‚ü®n, by rwa [map_mul, map_mul, map_pow, map_pow]‚ü©
  have h2 : ‚àÉ n, ‚àÄ i, (res i) (œÜ (s ^ n * g)) = 0 := by
    choose fn hfn using h1
    refine ‚ü®Finset.sup Finset.univ fn, fun i ‚Ü¶ ?_‚ü©
    rw [map_mul, map_pow, map_mul, map_pow]
    simp only [map_mul, map_pow, map_mul, map_pow] at hfn
    apply pow_mul_eq_zero_of_le (Finset.le_sup (Finset.mem_univ i)) (hfn i)
  obtain ‚ü®n, hn‚ü© := h2
  apply germ_eq_zero_of_pow_mul_eq_zero (U := ‚ä§) ‚ü®f.base x, trivial‚ü© hyv
  rw [RingHom.injective_iff_ker_eq_bot, RingHom.ker_eq_bot_iff_eq_zero] at hfinj‚ÇÇ
  exact hfinj‚ÇÇ _ (Scheme.zero_of_zero_cover _ _ hn)

namespace IsClosedImmersion

/-- If `f` is a closed immersion with affine target such that the induced map on global
sections is injective, `f` is an isomorphism. -/
theorem isIso_of_injective_of_isAffine [IsClosedImmersion f]
    (hf : Function.Injective (f.appTop)) : IsIso f := (isIso_iff_stalk_iso f).mpr <|
  have : CompactSpace X := f.isClosedEmbedding.compactSpace
  have hiso : IsIso f.base := TopCat.isIso_of_bijective_of_isClosedMap _
    ‚ü®f.isClosedEmbedding.injective,
     surjective_of_isClosed_range_of_injective f.isClosedEmbedding.isClosed_range hf‚ü©
    (f.isClosedEmbedding.isClosedMap)
  ‚ü®hiso, fun x ‚Ü¶ (ConcreteCategory.isIso_iff_bijective _).mpr
    ‚ü®stalkMap_injective_of_isOpenMap_of_injective ((TopCat.homeoOfIso (asIso f.base)).isOpenMap)
    f.isClosedEmbedding.injective hf _, f.stalkMap_surjective x‚ü©‚ü©

variable (f)

/-- If `f` is a closed immersion with affine target, the source is affine and
the induced map on global sections is surjective. -/
theorem isAffine_surjective_of_isAffine [IsClosedImmersion f] :
    IsAffine X ‚àß Function.Surjective (f.appTop) := by
  haveI i : IsClosedImmersion f := inferInstance
  rw [‚Üê affineTargetImageFactorization_comp f] at i ‚ä¢
  haveI := of_surjective_of_isAffine (affineTargetImageInclusion f)
    (affineTargetImageInclusion_app_surjective f)
  haveI := IsClosedImmersion.of_comp_isClosedImmersion (affineTargetImageFactorization f)
    (affineTargetImageInclusion f)
  haveI := isIso_of_injective_of_isAffine (affineTargetImageFactorization_app_injective f)
  exact ‚ü®isAffine_of_isIso (affineTargetImageFactorization f),
    (ConcreteCategory.bijective_of_isIso
      ((affineTargetImageFactorization f).appTop)).surjective.comp <|
      affineTargetImageInclusion_app_surjective f‚ü©

lemma Spec_iff {R : CommRingCat} {f : X ‚ü∂ Spec R} :
    IsClosedImmersion f ‚Üî ‚àÉ I : Ideal R, ‚àÉ e : X ‚âÖ Spec (.of <| R ‚ß∏ I),
      f = e.hom ‚â´ Spec.map (CommRingCat.ofHom (Ideal.Quotient.mk I)) := by
  constructor
  ¬∑ intro H
    obtain ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := IsClosedImmersion.isAffine_surjective_of_isAffine f
    let œÜ := (Scheme.ŒìSpecIso R).inv ‚â´ f.appTop
    refine ‚ü®RingHom.ker œÜ.1, Scheme.isoSpec _ ‚â™‚â´ Scheme.Spec.mapIso
        (.op (RingEquiv.ofBijective œÜ.1.kerLift ?_).toCommRingCatIso), ?_‚ü©
    ¬∑ exact ‚ü®œÜ.1.kerLift_injective, Ideal.Quotient.lift_surjective_of_surjective _ _
        (h‚ÇÇ.comp (Scheme.ŒìSpecIso R).commRingCatIsoToRingEquiv.symm.surjective)‚ü©
    ¬∑ simp only [Iso.trans_hom, Functor.mapIso_hom, Iso.op_hom, Scheme.Spec_map,
        Quiver.Hom.unop_op, Category.assoc, ‚Üê Spec.map_comp]
      show f = X.isoSpec.hom ‚â´ Spec.map œÜ
      simp only [Scheme.isoSpec, asIso_hom, Spec.map_comp, ‚Üê Scheme.toSpecŒì_naturality_assoc,
        ‚Üê SpecMap_ŒìSpecIso_hom, œÜ]
      simp only [‚Üê Spec.map_comp, Iso.inv_hom_id, Spec.map_id, Category.comp_id]
  ¬∑ rintro ‚ü®I, e, rfl‚ü©
    infer_instance

end IsClosedImmersion

end Affine

/-- Being a closed immersion is local at the target. -/
instance IsClosedImmersion.isLocalAtTarget : IsLocalAtTarget @IsClosedImmersion :=
  eq_inf ‚ñ∏ inferInstance

/-- On morphisms with affine target, being a closed immersion is precisely having affine source
and being surjective on global sections. -/
instance IsClosedImmersion.hasAffineProperty : HasAffineProperty @IsClosedImmersion
    (fun X _ f ‚Ü¶ IsAffine X ‚àß Function.Surjective (f.appTop)) := by
  convert HasAffineProperty.of_isLocalAtTarget @IsClosedImmersion
  refine ‚ü®fun ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© ‚Ü¶ of_surjective_of_isAffine _ h‚ÇÇ, by apply isAffine_surjective_of_isAffine‚ü©

instance (priority := 900) {X Y : Scheme.{u}} (f : X ‚ü∂ Y) [h : IsClosedImmersion f] :
    IsAffineHom f := by
  wlog hY : IsAffine Y
  ¬∑ rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := @IsAffineHom) _
      (iSup_affineOpens_eq_top Y)]
    intro U
    have H : IsClosedImmersion (f ‚à£_ U) := IsLocalAtTarget.restrict h U
    exact this _ U.2
  rw [HasAffineProperty.iff_of_isAffine (P := @IsAffineHom)]
  exact (IsClosedImmersion.isAffine_surjective_of_isAffine f).1

/-- Being a closed immersion is stable under base change. -/
instance IsClosedImmersion.isStableUnderBaseChange :
    MorphismProperty.IsStableUnderBaseChange @IsClosedImmersion := by
  apply HasAffineProperty.isStableUnderBaseChange
  haveI := HasAffineProperty.isLocal_affineProperty @IsClosedImmersion
  apply AffineTargetMorphismProperty.IsStableUnderBaseChange.mk
  intro X Y S _ _ f g ‚ü®ha, hsurj‚ü©
  exact ‚ü®inferInstance, RingHom.surjective_isStableUnderBaseChange.pullback_fst_appTop _
    RingHom.surjective_respectsIso f _ hsurj‚ü©

/-- Closed immersions are locally of finite type. -/
instance (priority := 900) {X Y : Scheme.{u}} (f : X ‚ü∂ Y) [h : IsClosedImmersion f] :
    LocallyOfFiniteType f := by
  wlog hY : IsAffine Y
  ¬∑ rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := @LocallyOfFiniteType) _
      (iSup_affineOpens_eq_top Y)]
    intro U
    have H : IsClosedImmersion (f ‚à£_ U) := IsLocalAtTarget.restrict h U
    exact this _ U.2
  obtain ‚ü®_, hf‚ü© := h.isAffine_surjective_of_isAffine
  rw [HasRingHomProperty.iff_of_isAffine (P := @LocallyOfFiniteType)]
  exact RingHom.FiniteType.of_surjective (Scheme.Hom.app f ‚ä§).hom hf

/-- A surjective closed immersion is an isomorphism when the target is reduced. -/
lemma isIso_of_isClosedImmersion_of_surjective {X Y : Scheme.{u}} (f : X ‚ü∂ Y)
    [IsClosedImmersion f] [Surjective f] [IsReduced Y] :
    IsIso f := by
  wlog hY : IsAffine Y
  ¬∑ refine (IsLocalAtTarget.iff_of_openCover (P := .isomorphisms Scheme) Y.affineCover).mpr ?_
    intro i
    apply (config := { allowSynthFailures := true }) this
    ¬∑ exact MorphismProperty.pullback_snd _ _ inferInstance
    ¬∑ exact IsLocalAtTarget.of_isPullback (.of_hasPullback f (Y.affineCover.map i)) ‚Äπ_‚Ä∫
    ¬∑ exact isReduced_of_isOpenImmersion (Y.affineCover.map i)
    ¬∑ infer_instance
  apply IsClosedImmersion.isIso_of_injective_of_isAffine
  obtain ‚ü®hX, hf‚ü© := HasAffineProperty.iff_of_isAffine.mp ‚ÄπIsClosedImmersion f‚Ä∫
  let œÜ := f.appTop
  suffices RingHom.ker œÜ.hom ‚â§ nilradical _ by
    rwa [nilradical_eq_zero, Submodule.zero_eq_bot, le_bot_iff,
      ‚Üê RingHom.injective_iff_ker_eq_bot] at this
  refine (PrimeSpectrum.zeroLocus_eq_top_iff _).mp ?_
  rw [‚Üê range_specComap_of_surjective _ _ hf, Set.top_eq_univ, Set.range_eq_univ]
  have : Surjective (Spec.map (f.appTop)) :=
    (MorphismProperty.arrow_mk_iso_iff @Surjective (arrowIsoSpecŒìOfIsAffine f)).mp
    (inferInstanceAs (Surjective f))
  exact this.1

section Section

nonrec theorem isClosedImmersion_of_comp_eq_id {X Y : Scheme} [Subsingleton Y]
    (f : X ‚ü∂ Y) (g : Y ‚ü∂ X) (hg : g ‚â´ f = ùüô Y) :
    IsClosedImmersion g := by
  wlog hX : ‚àÉ R, X = Spec R
  ¬∑ rw [IsLocalAtTarget.iff_of_openCover (P := @IsClosedImmersion) X.affineCover]
    intro i
    by_cases hxU : Set.range g.base ‚äÜ (X.affineCover.map i).opensRange
    ¬∑ rw [Scheme.Cover.pullbackHom,
        ‚Üê (IsOpenImmersion.isPullback_lift_id _ _ hxU).flip.isoPullback_inv_snd,
        MorphismProperty.cancel_left_of_respectsIso @IsClosedImmersion]
      have inst : Subsingleton ((X.affineCover.pullbackCover g).obj i) :=
        ((X.affineCover.pullbackCover g).map i).isOpenEmbedding.injective.subsingleton
      refine this (X.affineCover.map i ‚â´ f) _ ?_ ‚ü®_, rfl‚ü©
      rw [IsOpenImmersion.lift_fac_assoc, hg]
    ¬∑ have : IsEmpty ((X.affineCover.pullbackCover g).obj i) := by
        apply Scheme.isEmpty_pullback
        rw [‚Üê Set.subset_compl_iff_disjoint_left]
        rintro _ hx ‚ü®x, rfl‚ü©
        apply hxU
        rintro _ ‚ü®y, rfl‚ü©
        exact Subsingleton.elim x y ‚ñ∏ hx
      infer_instance
  obtain ‚ü®R, rfl‚ü© := hX
  wlog hY : ‚àÉ S, Y = Spec S
  ¬∑ have inst := (Scheme.isoSpec Y).inv.homeomorph.injective.subsingleton
    rw [‚Üê MorphismProperty.cancel_left_of_respectsIso @IsClosedImmersion (Scheme.isoSpec Y).inv]
    exact this R (f ‚â´ (Scheme.isoSpec Y).hom) ((Scheme.isoSpec Y).inv ‚â´ g)
      (by simp [reassoc_of% hg]) ‚ü®_, rfl‚ü©
  obtain ‚ü®S, rfl‚ü© := hY
  obtain ‚ü®œÜ, rfl‚ü© := Spec.map_surjective f
  obtain ‚ü®œà, rfl‚ü© := Spec.map_surjective g
  rw [‚Üê Spec.map_comp, ‚Üê Spec.map_id, Spec.map_injective.eq_iff] at hg
  apply IsClosedImmersion.spec_of_surjective
  apply Function.LeftInverse.surjective (g := œÜ)
  have := congr($hg ‚â´ $hg)
  exact fun x ‚Ü¶ congr($hg.1 x)

instance (priority := low) {X Y : Scheme} [Subsingleton Y] [X.Over Y] (f : Y ‚ü∂ X) [f.IsOver Y] :
    IsClosedImmersion f :=
  isClosedImmersion_of_comp_eq_id (X ‚Üò Y) f (by simp)

end Section


end AlgebraicGeometry
