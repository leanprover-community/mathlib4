/-
Copyright (c) 2022 Andrew Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Andrew Yang
-/
import Mathlib.AlgebraicGeometry.Morphisms.Constructors
import Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact
import Mathlib.Topology.QuasiSeparated
import Mathlib.Topology.Sheaves.CommRingCat

/-!
# Quasi-separated morphisms

A morphism of schemes `f : X ‚ü∂ Y` is quasi-separated if the diagonal morphism `X ‚ü∂ X √ó[Y] X` is
quasi-compact.

A scheme is quasi-separated if the intersections of any two affine open sets is quasi-compact.
(`AlgebraicGeometry.quasiSeparatedSpace_iff_affine`)

We show that a morphism is quasi-separated if the preimage of every affine open is quasi-separated.

We also show that this property is local at the target,
and is stable under compositions and base-changes.

## Main result
- `AlgebraicGeometry.is_localization_basicOpen_of_qcqs` (**Qcqs lemma**):
  If `U` is qcqs, then `Œì(X, D(f)) ‚âÉ Œì(X, U)_f` for every `f : Œì(X, U)`.

-/


noncomputable section

open CategoryTheory CategoryTheory.Limits Opposite TopologicalSpace

universe u

open scoped AlgebraicGeometry

namespace AlgebraicGeometry

variable {X Y : Scheme.{u}} (f : X ‚ü∂ Y)

/-- A morphism is `QuasiSeparated` if diagonal map is quasi-compact. -/
@[mk_iff]
class QuasiSeparated (f : X ‚ü∂ Y) : Prop where
  /-- A morphism is `QuasiSeparated` if diagonal map is quasi-compact. -/
  diagonalQuasiCompact : QuasiCompact (pullback.diagonal f) := by infer_instance

theorem quasiSeparatedSpace_iff_affine (X : Scheme) :
    QuasiSeparatedSpace X ‚Üî ‚àÄ U V : X.affineOpens, IsCompact (U ‚à© V : Set X) := by
  rw [quasiSeparatedSpace_iff]
  constructor
  ¬∑ intro H U V; exact H U V U.1.2 U.2.isCompact V.1.2 V.2.isCompact
  ¬∑ intro H
    suffices
      ‚àÄ (U : X.Opens) (_ : IsCompact U.1) (V : X.Opens) (_ : IsCompact V.1),
        IsCompact (U ‚äì V).1
      by intro U V hU hU' hV hV'; exact this ‚ü®U, hU‚ü© hU' ‚ü®V, hV‚ü© hV'
    intro U hU V hV
    refine compact_open_induction_on V hV ?_ ?_
    ¬∑ simp
    ¬∑ intro S _ V hV
      change IsCompact (U.1 ‚à© (S.1 ‚à™ V.1))
      rw [Set.inter_union_distrib_left]
      apply hV.union
      clear hV
      refine compact_open_induction_on U hU ?_ ?_
      ¬∑ simp
      ¬∑ intro S _ W hW
        change IsCompact ((S.1 ‚à™ W.1) ‚à© V.1)
        rw [Set.union_inter_distrib_right]
        apply hW.union
        apply H

theorem quasiCompact_affineProperty_iff_quasiSeparatedSpace {X Y : Scheme} [IsAffine Y]
    (f : X ‚ü∂ Y) :
    AffineTargetMorphismProperty.diagonal (fun X _ _ _ ‚Ü¶ CompactSpace X) f ‚Üî
      QuasiSeparatedSpace X := by
  delta AffineTargetMorphismProperty.diagonal
  rw [quasiSeparatedSpace_iff_affine]
  constructor
  ¬∑ intro H U V
    haveI : IsAffine _ := U.2
    haveI : IsAffine _ := V.2
    let g : pullback U.1.Œπ V.1.Œπ ‚ü∂ X := pullback.fst _ _ ‚â´ U.1.Œπ
    -- Porting note: `inferInstance` does not work here
    have : IsOpenImmersion g := PresheafedSpace.IsOpenImmersion.comp _ _
    have e := Homeomorph.ofIsEmbedding _ this.base_open.isEmbedding
    rw [IsOpenImmersion.range_pullback_to_base_of_left] at e
    erw [Subtype.range_coe, Subtype.range_coe] at e
    rw [isCompact_iff_compactSpace]
    exact @Homeomorph.compactSpace _ _ _ _ (H _ _) e
  ¬∑ introv H h‚ÇÅ h‚ÇÇ
    let g : pullback f‚ÇÅ f‚ÇÇ ‚ü∂ X := pullback.fst _ _ ‚â´ f‚ÇÅ
    -- Porting note: `inferInstance` does not work here
    have : IsOpenImmersion g := PresheafedSpace.IsOpenImmersion.comp _ _
    have e := Homeomorph.ofIsEmbedding _ this.base_open.isEmbedding
    rw [IsOpenImmersion.range_pullback_to_base_of_left] at e
    simp_rw [isCompact_iff_compactSpace] at H
    exact
      @Homeomorph.compactSpace _ _ _ _
        (H ‚ü®‚ü®_, h‚ÇÅ.base_open.isOpen_range‚ü©, isAffineOpen_opensRange _‚ü©
          ‚ü®‚ü®_, h‚ÇÇ.base_open.isOpen_range‚ü©, isAffineOpen_opensRange _‚ü©)
        e.symm

theorem quasiSeparated_eq_diagonal_is_quasiCompact :
    @QuasiSeparated = MorphismProperty.diagonal @QuasiCompact := by ext; exact quasiSeparated_iff _

instance : HasAffineProperty @QuasiSeparated (fun X _ _ _ ‚Ü¶ QuasiSeparatedSpace X) where
  __ := HasAffineProperty.copy
    quasiSeparated_eq_diagonal_is_quasiCompact.symm
    (by ext; exact quasiCompact_affineProperty_iff_quasiSeparatedSpace _)

instance (priority := 900) quasiSeparatedOfMono {X Y : Scheme} (f : X ‚ü∂ Y) [Mono f] :
    QuasiSeparated f where

instance quasiSeparated_isStableUnderComposition :
    MorphismProperty.IsStableUnderComposition @QuasiSeparated :=
  quasiSeparated_eq_diagonal_is_quasiCompact.symm ‚ñ∏ inferInstance

instance quasiSeparated_isStableUnderBaseChange :
    MorphismProperty.IsStableUnderBaseChange @QuasiSeparated :=
  quasiSeparated_eq_diagonal_is_quasiCompact.symm ‚ñ∏ inferInstance

instance quasiSeparatedComp {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [QuasiSeparated f]
    [QuasiSeparated g] : QuasiSeparated (f ‚â´ g) :=
  MorphismProperty.comp_mem _ f g inferInstance inferInstance

theorem quasiSeparated_over_affine_iff {X Y : Scheme} (f : X ‚ü∂ Y) [IsAffine Y] :
    QuasiSeparated f ‚Üî QuasiSeparatedSpace X := by
  rw [HasAffineProperty.iff_of_isAffine (P := @QuasiSeparated)]

theorem quasiSeparatedSpace_iff_quasiSeparated (X : Scheme) :
    QuasiSeparatedSpace X ‚Üî QuasiSeparated (terminal.from X) :=
  (quasiSeparated_over_affine_iff _).symm

instance {X Y S : Scheme} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) [QuasiSeparated g] :
    QuasiSeparated (pullback.fst f g) :=
  MorphismProperty.pullback_fst f g inferInstance

instance {X Y S : Scheme} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) [QuasiSeparated f] :
    QuasiSeparated (pullback.snd f g) :=
  MorphismProperty.pullback_snd f g inferInstance

theorem quasiSeparatedSpace_of_quasiSeparated {X Y : Scheme} (f : X ‚ü∂ Y)
    [hY : QuasiSeparatedSpace Y] [QuasiSeparated f] : QuasiSeparatedSpace X := by
  rw [quasiSeparatedSpace_iff_quasiSeparated] at hY ‚ä¢
  rw [‚Üê terminalIsTerminal.hom_ext (f ‚â´ terminal.from Y) (terminal.from X)]
  infer_instance

instance quasiSeparatedSpace_of_isAffine (X : Scheme) [IsAffine X] :
    QuasiSeparatedSpace X := by
  constructor
  intro U V hU hU' hV hV'
  obtain ‚ü®s, hs, e‚ü© := (isCompactOpen_iff_eq_basicOpen_union _).mp ‚ü®hU', hU‚ü©
  obtain ‚ü®s', hs', e'‚ü© := (isCompactOpen_iff_eq_basicOpen_union _).mp ‚ü®hV', hV‚ü©
  rw [e, e', Set.iUnion‚ÇÇ_inter]
  simp_rw [Set.inter_iUnion‚ÇÇ]
  apply hs.isCompact_biUnion
  intro i _
  apply hs'.isCompact_biUnion
  intro i' _
  change IsCompact (X.basicOpen i ‚äì X.basicOpen i').1
  rw [‚Üê Scheme.basicOpen_mul]
  exact ((isAffineOpen_top _).basicOpen _).isCompact

theorem IsAffineOpen.isQuasiSeparated {X : Scheme} {U : X.Opens} (hU : IsAffineOpen U) :
    IsQuasiSeparated (U : Set X) := by
  rw [isQuasiSeparated_iff_quasiSeparatedSpace]
  exacts [@AlgebraicGeometry.quasiSeparatedSpace_of_isAffine _ hU, U.isOpen]

theorem QuasiSeparated.of_comp {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [QuasiSeparated (f ‚â´ g)] :
    QuasiSeparated f := by
  let ùí∞ := (Z.affineCover.pullbackCover g).bind fun x => Scheme.affineCover _
  have (i) : IsAffine (ùí∞.obj i) := by dsimp [ùí∞]; infer_instance
  apply HasAffineProperty.of_openCover
    ((Z.affineCover.pullbackCover g).bind fun x => Scheme.affineCover _)
  rintro ‚ü®i, j‚ü©; dsimp at i j
  refine @quasiSeparatedSpace_of_quasiSeparated _ _ ?_
    (HasAffineProperty.of_isPullback (.of_hasPullback _ (Z.affineCover.map i)) ‚Äπ_‚Ä∫) ?_
  ¬∑ exact pullback.map _ _ _ _ (ùüô _) _ _ (by simp) (Category.comp_id _) ‚â´
      (pullbackRightPullbackFstIso g (Z.affineCover.map i) f).hom
  ¬∑ exact inferInstance

theorem exists_eq_pow_mul_of_isAffineOpen (X : Scheme) (U : X.Opens) (hU : IsAffineOpen U)
    (f : Œì(X, U)) (x : Œì(X, X.basicOpen f)) :
    ‚àÉ (n : ‚Ñï) (y : Œì(X, U)), y |_·µ£ X.basicOpen f = (f |_·µ£ X.basicOpen f) ^ n * x := by
  have := (hU.isLocalization_basicOpen f).2
  obtain ‚ü®‚ü®y, _, n, rfl‚ü©, d‚ü© := this x
  use n, y
  dsimp only [TopCat.Presheaf.restrictOpenCommRingCat_apply]
  simpa [mul_comm x] using d.symm

theorem exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux_aux {X : TopCat}
    (F : X.Presheaf CommRingCat) {U‚ÇÅ U‚ÇÇ U‚ÇÉ U‚ÇÑ U‚ÇÖ U‚ÇÜ U‚Çá : Opens X} {n‚ÇÅ n‚ÇÇ : ‚Ñï}
    {y‚ÇÅ : F.obj (op U‚ÇÅ)} {y‚ÇÇ : F.obj (op U‚ÇÇ)} {f : F.obj (op <| U‚ÇÅ ‚äî U‚ÇÇ)}
    {x : F.obj (op U‚ÇÉ)} (h‚ÇÑ‚ÇÅ : U‚ÇÑ ‚â§ U‚ÇÅ) (h‚ÇÑ‚ÇÇ : U‚ÇÑ ‚â§ U‚ÇÇ) (h‚ÇÖ‚ÇÅ : U‚ÇÖ ‚â§ U‚ÇÅ) (h‚ÇÖ‚ÇÉ : U‚ÇÖ ‚â§ U‚ÇÉ)
    (h‚ÇÜ‚ÇÇ : U‚ÇÜ ‚â§ U‚ÇÇ) (h‚ÇÜ‚ÇÉ : U‚ÇÜ ‚â§ U‚ÇÉ) (h‚Çá‚ÇÑ : U‚Çá ‚â§ U‚ÇÑ) (h‚Çá‚ÇÖ : U‚Çá ‚â§ U‚ÇÖ) (h‚Çá‚ÇÜ : U‚Çá ‚â§ U‚ÇÜ)
    (e‚ÇÅ : y‚ÇÅ |_·µ£ U‚ÇÖ = (f |_·µ£ U‚ÇÅ |_·µ£ U‚ÇÖ) ^ n‚ÇÅ * x |_·µ£ U‚ÇÖ)
    (e‚ÇÇ : y‚ÇÇ |_·µ£ U‚ÇÜ = (f |_·µ£ U‚ÇÇ |_·µ£ U‚ÇÜ) ^ n‚ÇÇ * x |_·µ£ U‚ÇÜ) :
    (((f |_·µ£ U‚ÇÅ) ^ n‚ÇÇ * y‚ÇÅ) |_·µ£ U‚ÇÑ) |_·µ£ U‚Çá = (((f |_·µ£ U‚ÇÇ) ^ n‚ÇÅ * y‚ÇÇ) |_·µ£ U‚ÇÑ) |_·µ£ U‚Çá := by
  apply_fun (fun x : F.obj (op U‚ÇÖ) ‚Ü¶ x |_·µ£ U‚Çá) at e‚ÇÅ
  apply_fun (fun x : F.obj (op U‚ÇÜ) ‚Ü¶ x |_·µ£ U‚Çá) at e‚ÇÇ
  dsimp only [TopCat.Presheaf.restrictOpenCommRingCat_apply] at e‚ÇÅ e‚ÇÇ ‚ä¢
  simp only [map_mul, map_pow, ‚Üê op_comp, ‚Üê F.map_comp, homOfLE_comp, ‚Üê CommRingCat.comp_apply]
    at e‚ÇÅ e‚ÇÇ ‚ä¢
  rw [e‚ÇÅ, e‚ÇÇ, mul_left_comm]

theorem exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux (X : Scheme)
    (S : X.affineOpens) (U‚ÇÅ U‚ÇÇ : X.Opens) {n‚ÇÅ n‚ÇÇ : ‚Ñï} {y‚ÇÅ : Œì(X, U‚ÇÅ)}
    {y‚ÇÇ : Œì(X, U‚ÇÇ)} {f : Œì(X, U‚ÇÅ ‚äî U‚ÇÇ)}
    {x : Œì(X, X.basicOpen f)} (h‚ÇÅ : S.1 ‚â§ U‚ÇÅ) (h‚ÇÇ : S.1 ‚â§ U‚ÇÇ)
    (e‚ÇÅ : y‚ÇÅ |_·µ£ X.basicOpen (f |_·µ£ U‚ÇÅ) =
      ((f |_·µ£ U‚ÇÅ |_·µ£ X.basicOpen _) ^ n‚ÇÅ) * x |_·µ£ X.basicOpen _)
    (e‚ÇÇ : y‚ÇÇ |_·µ£ X.basicOpen (f |_·µ£ U‚ÇÇ) =
      ((f |_·µ£ U‚ÇÇ |_·µ£ X.basicOpen _) ^ n‚ÇÇ) * x |_·µ£ X.basicOpen _) :
    ‚àÉ n : ‚Ñï, ‚àÄ m, n ‚â§ m ‚Üí
      ((f |_·µ£ U‚ÇÅ) ^ (m + n‚ÇÇ) * y‚ÇÅ) |_·µ£ S.1 = ((f |_·µ£ U‚ÇÇ) ^ (m + n‚ÇÅ) * y‚ÇÇ) |_·µ£ S.1 := by
  obtain ‚ü®‚ü®_, n, rfl‚ü©, e‚ü© :=
    (@IsLocalization.eq_iff_exists _ _ _ _ _ _
      (S.2.isLocalization_basicOpen (f |_·µ£ S.1))
        (((f |_·µ£ U‚ÇÅ) ^ n‚ÇÇ * y‚ÇÅ) |_·µ£ S.1)
        (((f |_·µ£ U‚ÇÇ) ^ n‚ÇÅ * y‚ÇÇ) |_·µ£ S.1)).mp <| by
    apply exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux_aux (e‚ÇÅ := e‚ÇÅ) (e‚ÇÇ := e‚ÇÇ)
    ¬∑ show X.basicOpen _ ‚â§ _
      simp only [TopCat.Presheaf.restrictOpenCommRingCat_apply, Scheme.basicOpen_res]
      exact inf_le_inf h‚ÇÅ le_rfl
    ¬∑ show X.basicOpen _ ‚â§ _
      simp only [TopCat.Presheaf.restrictOpenCommRingCat_apply, Scheme.basicOpen_res]
      exact inf_le_inf h‚ÇÇ le_rfl
  use n
  intros m hm
  rw [‚Üê tsub_add_cancel_of_le hm]
  simp only [TopCat.Presheaf.restrictOpenCommRingCat_apply,
    pow_add, map_pow, map_mul, mul_assoc, ‚Üê Functor.map_comp, ‚Üê op_comp, homOfLE_comp,
    Subtype.coe_mk, ‚Üê CommRingCat.comp_apply] at e ‚ä¢
  rw [e]

theorem exists_eq_pow_mul_of_isCompact_of_isQuasiSeparated (X : Scheme.{u}) (U : X.Opens)
    (hU : IsCompact U.1) (hU' : IsQuasiSeparated U.1) (f : Œì(X, U)) (x : Œì(X, X.basicOpen f)) :
    ‚àÉ (n : ‚Ñï) (y : Œì(X, U)), y |_·µ£ X.basicOpen f = (f |_·µ£ X.basicOpen f) ^ n * x := by
  dsimp only [TopCat.Presheaf.restrictOpenCommRingCat_apply]
  revert hU' f x
  refine compact_open_induction_on U hU ?_ ?_
  ¬∑ intro _ f x
    use 0, f
    refine @Subsingleton.elim _
      (CommRingCat.subsingleton_of_isTerminal (X.sheaf.isTerminalOfEqEmpty ?_)) _ _
    rw [eq_bot_iff]
    exact X.basicOpen_le f
  ¬∑ -- Given `f : ùí™(S ‚à™ U), x : ùí™(X_f)`, we need to show that `f ^ n * x` is the restriction of
    -- some `y : ùí™(S ‚à™ U)` for some `n : ‚Ñï`.
    intro S hS U hU hSU f x
    -- We know that such `y‚ÇÅ, n‚ÇÅ` exists on `S` by the induction hypothesis.
    obtain ‚ü®n‚ÇÅ, y‚ÇÅ, hy‚ÇÅ‚ü© :=
      hU (hSU.of_subset Set.subset_union_left) (X.presheaf.map (homOfLE le_sup_left).op f)
        (X.presheaf.map (homOfLE _).op x)
    -- ¬∑ rw [X.basicOpen_res]; exact inf_le_right
    -- We know that such `y‚ÇÇ, n‚ÇÇ` exists on `U` since `U` is affine.
    obtain ‚ü®n‚ÇÇ, y‚ÇÇ, hy‚ÇÇ‚ü© :=
      exists_eq_pow_mul_of_isAffineOpen X _ U.2 (X.presheaf.map (homOfLE le_sup_right).op f)
        (X.presheaf.map (homOfLE _).op x)
    dsimp only [TopCat.Presheaf.restrictOpenCommRingCat_apply] at hy‚ÇÇ
    -- swap; ¬∑ rw [X.basicOpen_res]; exact inf_le_right
    -- Since `S ‚à™ U` is quasi-separated, `S ‚à© U` can be covered by finite affine opens.
    obtain ‚ü®s, hs', hs‚ü© :=
      (isCompactOpen_iff_eq_finset_affine_union _).mp
        ‚ü®hSU _ _ Set.subset_union_left S.2 hS Set.subset_union_right U.1.2
            U.2.isCompact,
          (S ‚äì U.1).2‚ü©
    haveI := hs'.to_subtype
    cases nonempty_fintype s
    replace hs : S ‚äì U.1 = iSup fun i : s => (i : X.Opens) := by ext1; simpa using hs
    have hs‚ÇÅ : ‚àÄ i : s, i.1.1 ‚â§ S := by
      intro i; change (i : X.Opens) ‚â§ S
      refine le_trans ?_ (inf_le_left (b := U.1))
      rw [hs]
      -- Porting note: have to add argument explicitly
      exact @le_iSup X.Opens s _ (fun (i : s) => (i : X.Opens)) i
    have hs‚ÇÇ : ‚àÄ i : s, i.1.1 ‚â§ U.1 := by
      intro i; change (i : X.Opens) ‚â§ U
      refine le_trans ?_ (inf_le_right (a := S))
      rw [hs]
      -- Porting note: have to add argument explicitly
      exact @le_iSup X.Opens s _ (fun (i : s) => (i : X.Opens)) i
    -- On each affine open in the intersection, we have `f ^ (n + n‚ÇÇ) * y‚ÇÅ = f ^ (n + n‚ÇÅ) * y‚ÇÇ`
    -- for some `n` since `f ^ n‚ÇÇ * y‚ÇÅ = f ^ (n‚ÇÅ + n‚ÇÇ) * x = f ^ n‚ÇÅ * y‚ÇÇ` on `X_f`.
    have := fun i ‚Ü¶ exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux
      X i.1 S U (hs‚ÇÅ i) (hs‚ÇÇ i) hy‚ÇÅ hy‚ÇÇ
    choose n hn using this
    -- We can thus choose a big enough `n` such that `f ^ (n + n‚ÇÇ) * y‚ÇÅ = f ^ (n + n‚ÇÅ) * y‚ÇÇ`
    -- on `S ‚à© U`.
    have :
      X.presheaf.map (homOfLE <| inf_le_left).op
          (X.presheaf.map (homOfLE le_sup_left).op f ^ (Finset.univ.sup n + n‚ÇÇ) * y‚ÇÅ) =
        X.presheaf.map (homOfLE <| inf_le_right).op
          (X.presheaf.map (homOfLE le_sup_right).op f ^ (Finset.univ.sup n + n‚ÇÅ) * y‚ÇÇ) := by
      fapply X.sheaf.eq_of_locally_eq' fun i : s => i.1.1
      ¬∑ refine fun i => homOfLE ?_; rw [hs]
        -- Porting note: have to add argument explicitly
        exact @le_iSup X.Opens s _ (fun (i : s) => (i : X.Opens)) i
      ¬∑ exact le_of_eq hs
      ¬∑ intro i
        -- This unfolds `X.sheaf` and ensures we use `CommRingCat.hom` to apply the morphism
        show (X.presheaf.map _) _ = (X.presheaf.map _) _
        simp only [‚Üê CommRingCat.comp_apply, ‚Üê Functor.map_comp, ‚Üê op_comp]
        apply hn
        exact Finset.le_sup (Finset.mem_univ _)
    use Finset.univ.sup n + n‚ÇÅ + n‚ÇÇ
    -- By the sheaf condition, since `f ^ (n + n‚ÇÇ) * y‚ÇÅ = f ^ (n + n‚ÇÅ) * y‚ÇÇ`, it can be glued into
    -- the desired section on `S ‚à™ U`.
    use (X.sheaf.objSupIsoProdEqLocus S U.1).inv ‚ü®‚ü®_ * _, _ * _‚ü©, this‚ü©
    refine (X.sheaf.objSupIsoProdEqLocus_inv_eq_iff _ _ _ (X.basicOpen_res _
      (homOfLE le_sup_left).op) (X.basicOpen_res _ (homOfLE le_sup_right).op)).mpr ‚ü®?_, ?_‚ü©
    ¬∑ -- This unfolds `X.sheaf` and ensures we use `CommRingCat.hom` to apply the morphism
      show (X.presheaf.map _) _ = (X.presheaf.map _) _
      rw [add_assoc, add_comm n‚ÇÅ]
      simp only [pow_add, map_pow, map_mul, hy‚ÇÅ, ‚Üê CommRingCat.comp_apply, ‚Üê mul_assoc,
        ‚Üê Functor.map_comp, ‚Üê op_comp, homOfLE_comp]
    ¬∑ -- This unfolds `X.sheaf` and ensures we use `CommRingCat.hom` to apply the morphism
      show (X.presheaf.map _) _ = (X.presheaf.map _) _
      simp only [pow_add, map_pow, map_mul, hy‚ÇÇ, ‚Üê CommRingCat.comp_apply, ‚Üê mul_assoc,
        ‚Üê Functor.map_comp, ‚Üê op_comp, homOfLE_comp]

/-- If `U` is qcqs, then `Œì(X, D(f)) ‚âÉ Œì(X, U)_f` for every `f : Œì(X, U)`.
This is known as the **Qcqs lemma** in [R. Vakil, *The rising sea*][RisingSea]. -/
theorem is_localization_basicOpen_of_qcqs {X : Scheme} {U : X.Opens} (hU : IsCompact U.1)
    (hU' : IsQuasiSeparated U.1) (f : Œì(X, U)) :
    IsLocalization.Away f (Œì(X, X.basicOpen f)) := by
  constructor
  ¬∑ rintro ‚ü®_, n, rfl‚ü©
    simp only [map_pow, Subtype.coe_mk, RingHom.algebraMap_toAlgebra]
    exact IsUnit.pow _ (RingedSpace.isUnit_res_basicOpen _ f)
  ¬∑ intro z
    obtain ‚ü®n, y, e‚ü© := exists_eq_pow_mul_of_isCompact_of_isQuasiSeparated X U hU hU' f z
    refine ‚ü®‚ü®y, _, n, rfl‚ü©, ?_‚ü©
    simpa only [map_pow, Subtype.coe_mk, RingHom.algebraMap_toAlgebra, mul_comm z] using e.symm
  ¬∑ intro x y
    rw [‚Üê sub_eq_zero, ‚Üê map_sub, RingHom.algebraMap_toAlgebra]
    simp_rw [‚Üê @sub_eq_zero _ _ (_ * x) (_ * y), ‚Üê mul_sub]
    generalize x - y = z
    intro H
    obtain ‚ü®n, e‚ü© := exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isCompact X hU _ _ H
    refine ‚ü®‚ü®_, n, rfl‚ü©, ?_‚ü©
    simpa [mul_comm z] using e

lemma exists_of_res_eq_of_qcqs {X : Scheme.{u}} {U : TopologicalSpace.Opens X}
    (hU : IsCompact U.carrier) (hU' : IsQuasiSeparated U.carrier)
    {f g s : Œì(X, U)} (hfg : f |_·µ£ X.basicOpen s = g |_·µ£ X.basicOpen s) :
    ‚àÉ n, s ^ n * f = s ^ n * g := by
  obtain ‚ü®n, hc‚ü© := (is_localization_basicOpen_of_qcqs hU hU' s).exists_of_eq s hfg
  use n

lemma exists_of_res_eq_of_qcqs_of_top {X : Scheme.{u}} [CompactSpace X] [QuasiSeparatedSpace X]
    {f g s : Œì(X, ‚ä§)} (hfg : f |_·µ£ X.basicOpen s = g |_·µ£ X.basicOpen s) :
    ‚àÉ n, s ^ n * f = s ^ n * g :=
  exists_of_res_eq_of_qcqs (U := ‚ä§) CompactSpace.isCompact_univ isQuasiSeparated_univ hfg

lemma exists_of_res_zero_of_qcqs {X : Scheme.{u}} {U : TopologicalSpace.Opens X}
    (hU : IsCompact U.carrier) (hU' : IsQuasiSeparated U.carrier)
    {f s : Œì(X, U)} (hf : f |_·µ£ X.basicOpen s = 0) :
    ‚àÉ n, s ^ n * f = 0 := by
  suffices h : ‚àÉ n, s ^ n * f = s ^ n * 0 by
    simpa using h
  apply exists_of_res_eq_of_qcqs hU hU'
  simpa

lemma exists_of_res_zero_of_qcqs_of_top {X : Scheme} [CompactSpace X] [QuasiSeparatedSpace X]
    {f s : Œì(X, ‚ä§)} (hf : f |_·µ£ X.basicOpen s = 0) :
    ‚àÉ n, s ^ n * f = 0 :=
  exists_of_res_zero_of_qcqs (U := ‚ä§) CompactSpace.isCompact_univ isQuasiSeparated_univ hf

/-- If `U` is qcqs, then `Œì(X, D(f)) ‚âÉ Œì(X, U)_f` for every `f : Œì(X, U)`.
This is known as the **Qcqs lemma** in [R. Vakil, *The rising sea*][RisingSea]. -/
theorem isIso_ŒìSpec_adjunction_unit_app_basicOpen {X : Scheme} [CompactSpace X]
    [QuasiSeparatedSpace X] (f : X.presheaf.obj (op ‚ä§)) :
    IsIso ((ŒìSpec.adjunction.unit.app X).c.app (op (PrimeSpectrum.basicOpen f))) := by
  refine @IsIso.of_isIso_comp_right _ _ _ _ _ _ (X.presheaf.map
    (eqToHom (Scheme.toSpecŒì_preimage_basicOpen _ _).symm).op) _ ?_
  rw [ConcreteCategory.isIso_iff_bijective, CommRingCat.forget_map]
  apply (config := { allowSynthFailures := true }) IsLocalization.bijective
  ¬∑ exact StructureSheaf.IsLocalization.to_basicOpen _ _
  ¬∑ refine is_localization_basicOpen_of_qcqs ?_ ?_ _
    ¬∑ exact isCompact_univ
    ¬∑ exact isQuasiSeparated_univ
  ¬∑ simp only [RingHom.algebraMap_toAlgebra]
    -- This `rw` doesn't fire as a `simp` (`only`).
    rw [‚Üê CommRingCat.hom_comp]
    simp [RingHom.algebraMap_toAlgebra, ‚Üê Functor.map_comp]

end AlgebraicGeometry
