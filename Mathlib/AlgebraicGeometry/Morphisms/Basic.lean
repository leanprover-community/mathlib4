/-
Copyright (c) 2022 Andrew Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Andrew Yang

! This file was ported from Lean 3 source module algebraic_geometry.morphisms.basic
! leanprover-community/mathlib commit 434e2fd21c1900747afc6d13d8be7f4eedba7218
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.AlgebraicGeometry.AffineScheme
import Mathbin.AlgebraicGeometry.Pullbacks
import Mathbin.CategoryTheory.MorphismProperty

/-!
# Properties of morphisms between Schemes

We provide the basic framework for talking about properties of morphisms between Schemes.

A `morphism_property Scheme` is a predicate on morphisms between schemes, and an
`affine_target_morphism_property` is a predicate on morphisms into affine schemes. Given a
`P : affine_target_morphism_property`, we may construct a `morphism_property` called
`target_affine_locally P` that holds for `f : X ‚ü∂ Y` whenever `P` holds for the
restriction of `f` on every affine open subset of `Y`.

## Main definitions

- `algebraic_geometry.affine_target_morphism_property.is_local`: We say that `P.is_local` if `P`
satisfies the assumptions of the affine communication lemma
(`algebraic_geometry.of_affine_open_cover`). That is,
1. `P` respects isomorphisms.
2. If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ Y.basic_open r` for any
  global section `r`.
3. If `P` holds for `f ‚à£_ Y.basic_open r` for all `r` in a spanning set of the global sections,
  then `P` holds for `f`.

- `algebraic_geometry.property_is_local_at_target`: We say that `property_is_local_at_target P` for
`P : morphism_property Scheme` if
1. `P` respects isomorphisms.
2. If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ U` for any `U`.
3. If `P` holds for `f ‚à£_ U` for an open cover `U` of `Y`, then `P` holds for `f`.

## Main results

- `algebraic_geometry.affine_target_morphism_property.is_local.affine_open_cover_tfae`:
  If `P.is_local`, then `target_affine_locally P f` iff there exists an affine cover `{ U·µ¢ }` of `Y`
  such that `P` holds for `f ‚à£_ U·µ¢`.
- `algebraic_geometry.affine_target_morphism_property.is_local_of_open_cover_imply`:
  If the existance of an affine cover `{ U·µ¢ }` of `Y` such that `P` holds for `f ‚à£_ U·µ¢` implies
  `target_affine_locally P f`, then `P.is_local`.
- `algebraic_geometry.affine_target_morphism_property.is_local.affine_target_iff`:
  If `Y` is affine and `f : X ‚ü∂ Y`, then `target_affine_locally P f ‚Üî P f` provided `P.is_local`.
- `algebraic_geometry.affine_target_morphism_property.is_local.target_affine_locally_is_local` :
  If `P.is_local`, then `property_is_local_at_target (target_affine_locally P)`.
- `algebraic_geometry.property_is_local_at_target.open_cover_tfae`:
  If `property_is_local_at_target P`, then `P f` iff there exists an open cover `{ U·µ¢ }` of `Y`
  such that `P` holds for `f ‚à£_ U·µ¢`.

These results should not be used directly, and should be ported to each property that is local.

-/


universe u

open TopologicalSpace CategoryTheory CategoryTheory.Limits Opposite

noncomputable section

namespace AlgebraicGeometry

/-- An `affine_target_morphism_property` is a class of morphisms from an arbitrary scheme into an
affine scheme. -/
def AffineTargetMorphismProperty :=
  ‚àÄ ‚¶ÉX Y : Scheme‚¶Ñ (f : X ‚ü∂ Y) [IsAffine Y], Prop
#align algebraic_geometry.affine_target_morphism_property AlgebraicGeometry.AffineTargetMorphismProperty

/-- `is_iso` as a `morphism_property`. -/
protected def Scheme.isIso : MorphismProperty Scheme :=
  @IsIso Scheme _
#align algebraic_geometry.Scheme.is_iso AlgebraicGeometry.Scheme.isIso

/-- `is_iso` as an `affine_morphism_property`. -/
protected def Scheme.affineTargetIsIso : AffineTargetMorphismProperty := fun X Y f H => IsIso f
#align algebraic_geometry.Scheme.affine_target_is_iso AlgebraicGeometry.Scheme.affineTargetIsIso

instance : Inhabited AffineTargetMorphismProperty :=
  ‚ü®Scheme.affineTargetIsIso‚ü©

/-- A `affine_target_morphism_property` can be extended to a `morphism_property` such that it
*never* holds when the target is not affine -/
def AffineTargetMorphismProperty.toProperty (P : AffineTargetMorphismProperty) :
    MorphismProperty Scheme := fun X Y f => ‚àÉ h, @P f h
#align algebraic_geometry.affine_target_morphism_property.to_property AlgebraicGeometry.AffineTargetMorphismProperty.toProperty

theorem AffineTargetMorphismProperty.toProperty_apply (P : AffineTargetMorphismProperty)
    {X Y : Scheme} (f : X ‚ü∂ Y) [IsAffine Y] : P.toProperty f ‚Üî P f := by
  delta affine_target_morphism_property.to_property; simp [*]
#align algebraic_geometry.affine_target_morphism_property.to_property_apply AlgebraicGeometry.AffineTargetMorphismProperty.toProperty_apply

theorem affine_cancel_left_isIso {P : AffineTargetMorphismProperty} (hP : P.toProperty.RespectsIso)
    {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsIso f] [IsAffine Z] : P (f ‚â´ g) ‚Üî P g := by
  rw [‚Üê P.to_property_apply, ‚Üê P.to_property_apply, hP.cancel_left_is_iso]
#align algebraic_geometry.affine_cancel_left_is_iso AlgebraicGeometry.affine_cancel_left_isIso

theorem affine_cancel_right_isIso {P : AffineTargetMorphismProperty} (hP : P.toProperty.RespectsIso)
    {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsIso g] [IsAffine Z] [IsAffine Y] :
    P (f ‚â´ g) ‚Üî P f := by rw [‚Üê P.to_property_apply, ‚Üê P.to_property_apply, hP.cancel_right_is_iso]
#align algebraic_geometry.affine_cancel_right_is_iso AlgebraicGeometry.affine_cancel_right_isIso

theorem AffineTargetMorphismProperty.respectsIso_mk {P : AffineTargetMorphismProperty}
    (h‚ÇÅ : ‚àÄ {X Y Z} (e : X ‚âÖ Y) (f : Y ‚ü∂ Z) [IsAffine Z], P f ‚Üí P (e.hom ‚â´ f))
    (h‚ÇÇ :
      ‚àÄ {X Y Z} (e : Y ‚âÖ Z) (f : X ‚ü∂ Y) [h : IsAffine Y],
        P f ‚Üí @P (f ‚â´ e.hom) (is_affine_of_iso e.inv)) :
    P.toProperty.RespectsIso := by
  constructor
  ¬∑ rintro X Y Z e f ‚ü®a, h‚ü©; exact ‚ü®a, h‚ÇÅ e f h‚ü©
  ¬∑ rintro X Y Z e f ‚ü®a, h‚ü©; exact ‚ü®is_affine_of_iso e.inv, h‚ÇÇ e f h‚ü©
#align algebraic_geometry.affine_target_morphism_property.respects_iso_mk AlgebraicGeometry.AffineTargetMorphismProperty.respectsIso_mk

/-- For a `P : affine_target_morphism_property`, `target_affine_locally P` holds for
`f : X ‚ü∂ Y` whenever `P` holds for the restriction of `f` on every affine open subset of `Y`. -/
def targetAffineLocally (P : AffineTargetMorphismProperty) : MorphismProperty Scheme :=
  fun {X Y : Scheme} (f : X ‚ü∂ Y) => ‚àÄ U : Y.affineOpens, @P (f ‚à£_ U) U.Prop
#align algebraic_geometry.target_affine_locally AlgebraicGeometry.targetAffineLocally

theorem IsAffineOpen.map_isIso {X Y : Scheme} {U : Opens Y.carrier} (hU : IsAffineOpen U)
    (f : X ‚ü∂ Y) [IsIso f] : IsAffineOpen ((Opens.map f.1.base).obj U) :=
  haveI : is_affine _ := hU
  is_affine_of_iso (f ‚à£_ U)
#align algebraic_geometry.is_affine_open.map_is_iso AlgebraicGeometry.IsAffineOpen.map_isIso

theorem targetAffineLocally_respectsIso {P : AffineTargetMorphismProperty}
    (hP : P.toProperty.RespectsIso) : (targetAffineLocally P).RespectsIso :=
  by
  constructor
  ¬∑ introv H U
    rw [morphism_restrict_comp, affine_cancel_left_is_iso hP]
    exact H U
  ¬∑ introv H
    rintro ‚ü®U, hU : is_affine_open U‚ü©; dsimp
    haveI : is_affine _ := hU
    haveI : is_affine _ := hU.map_is_iso e.hom
    rw [morphism_restrict_comp, affine_cancel_right_is_iso hP]
    exact H ‚ü®(opens.map e.hom.val.base).obj U, hU.map_is_iso e.hom‚ü©
#align algebraic_geometry.target_affine_locally_respects_iso AlgebraicGeometry.targetAffineLocally_respectsIso

/-- We say that `P : affine_target_morphism_property` is a local property if
1. `P` respects isomorphisms.
2. If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ Y.basic_open r` for any
  global section `r`.
3. If `P` holds for `f ‚à£_ Y.basic_open r` for all `r` in a spanning set of the global sections,
  then `P` holds for `f`.
-/
structure AffineTargetMorphismProperty.IsLocal (P : AffineTargetMorphismProperty) : Prop where
  RespectsIso : P.toProperty.RespectsIso
  toBasicOpen :
    ‚àÄ {X Y : Scheme} [IsAffine Y] (f : X ‚ü∂ Y) (r : Y.Presheaf.obj <| op ‚ä§),
      P f ‚Üí @P (f ‚à£_ Y.basic_open r) ((top_is_affine_open Y).basicOpenIsAffine _)
  ofBasicOpenCover :
    ‚àÄ {X Y : Scheme} [IsAffine Y] (f : X ‚ü∂ Y) (s : Finset (Y.Presheaf.obj <| op ‚ä§))
      (hs : Ideal.span (s : Set (Y.Presheaf.obj <| op ‚ä§)) = ‚ä§),
      (‚àÄ r : s, @P (f ‚à£_ Y.basic_open r.1) ((top_is_affine_open Y).basicOpenIsAffine _)) ‚Üí P f
#align algebraic_geometry.affine_target_morphism_property.is_local AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal

theorem targetAffineLocallyOfOpenCover {P : AffineTargetMorphismProperty} (hP : P.IsLocal)
    {X Y : Scheme} (f : X ‚ü∂ Y) (ùí∞ : Y.OpenCover) [‚àÄ i, IsAffine (ùí∞.obj i)]
    (hùí∞ : ‚àÄ i, P (pullback.snd : (ùí∞.pullbackCover f).obj i ‚ü∂ ùí∞.obj i)) : targetAffineLocally P f :=
  by
  classical
  let S i :=
    (‚ü®‚ü®Set.range (ùí∞.map i).1.base, (ùí∞.is_open i).base_open.open_range‚ü©,
        range_is_affine_open_of_open_immersion (ùí∞.map i)‚ü© :
      Y.affine_opens)
  intro U
  apply of_affine_open_cover U (Set.range S)
  ¬∑ intro U r h
    haveI : is_affine _ := U.2
    have := hP.2 (f ‚à£_ U.1)
    replace this := this (Y.presheaf.map (eq_to_hom U.1.openEmbedding_obj_top).op r) h
    rw [‚Üê P.to_property_apply] at this ‚ä¢
    exact (hP.1.arrow_mk_iso_iff (morphism_restrict_restrict_basic_open f _ r)).mp this
  ¬∑ intro U s hs H
    haveI : is_affine _ := U.2
    apply hP.3 (f ‚à£_ U.1) (s.image (Y.presheaf.map (eq_to_hom U.1.openEmbedding_obj_top).op))
    ¬∑ apply_fun Ideal.comap (Y.presheaf.map (eq_to_hom U.1.openEmbedding_obj_top.symm).op) at hs 
      rw [Ideal.comap_top] at hs 
      rw [‚Üê hs]
      simp only [eq_to_hom_op, eq_to_hom_map, Finset.coe_image]
      have :
        ‚àÄ {R S : CommRingCat} (e : S = R) (s : Set S),
          Ideal.span (eq_to_hom e '' s) = Ideal.comap (eq_to_hom e.symm) (Ideal.span s) :=
        by intros; subst e; simpa
      apply this
    ¬∑ rintro ‚ü®r, hr‚ü©
      obtain ‚ü®r, hr', rfl‚ü© := finset.mem_image.mp hr
      simp_rw [‚Üê P.to_property_apply] at H ‚ä¢
      exact (hP.1.arrow_mk_iso_iff (morphism_restrict_restrict_basic_open f _ r)).mpr (H ‚ü®r, hr'‚ü©)
  ¬∑ rw [Set.eq_univ_iff_forall]
    simp only [Set.mem_iUnion]
    intro x
    exact ‚ü®‚ü®_, ‚ü®ùí∞.f x, rfl‚ü©‚ü©, ùí∞.covers x‚ü©
  ¬∑ rintro ‚ü®_, i, rfl‚ü©
    simp_rw [‚Üê P.to_property_apply] at hùí∞ ‚ä¢
    exact (hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _)).mpr (hùí∞ i)
#align algebraic_geometry.target_affine_locally_of_open_cover AlgebraicGeometry.targetAffineLocallyOfOpenCover

theorem AffineTargetMorphismProperty.IsLocal.affine_openCover_tFAE
    {P : AffineTargetMorphismProperty} (hP : P.IsLocal) {X Y : Scheme.{u}} (f : X ‚ü∂ Y) :
    TFAE
      [targetAffineLocally P f,
        ‚àÉ (ùí∞ : Scheme.OpenCover.{u} Y) (_ : ‚àÄ i, IsAffine (ùí∞.obj i)),
          ‚àÄ i : ùí∞.J, P (pullback.snd : (ùí∞.pullback_cover f).obj i ‚ü∂ ùí∞.obj i),
        ‚àÄ (ùí∞ : Scheme.OpenCover.{u} Y) [‚àÄ i, IsAffine (ùí∞.obj i)] (i : ùí∞.J),
          P (pullback.snd : (ùí∞.pullback_cover f).obj i ‚ü∂ ùí∞.obj i),
        ‚àÄ {U : Scheme} (g : U ‚ü∂ Y) [IsAffine U] [IsOpenImmersionCat g],
          P (pullback.snd : pullback f g ‚ü∂ U),
        ‚àÉ (Œπ : Type u) (U : Œπ ‚Üí Opens Y.carrier) (hU : iSup U = ‚ä§) (hU' : ‚àÄ i, IsAffineOpen (U i)),
          ‚àÄ i, @P (f ‚à£_ U i) (hU' i)] :=
  by
  tfae_have 1 ‚Üí 4
  ¬∑ intro H U g h‚ÇÅ h‚ÇÇ
    skip
    replace H := H ‚ü®‚ü®_, h‚ÇÇ.base_open.open_range‚ü©, range_is_affine_open_of_open_immersion g‚ü©
    rw [‚Üê P.to_property_apply] at H ‚ä¢
    rwa [‚Üê hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _)]
  tfae_have 4 ‚Üí 3
  ¬∑ intro H ùí∞ hùí∞ i
    skip
    apply H
  tfae_have 3 ‚Üí 2
  ¬∑ exact fun H => ‚ü®Y.affine_cover, inferInstance, H Y.affine_cover‚ü©
  tfae_have 2 ‚Üí 1
  ¬∑ rintro ‚ü®ùí∞, hùí∞, H‚ü©; exact target_affine_locally_of_open_cover hP f ùí∞ H
  tfae_have 5 ‚Üí 2
  ¬∑ rintro ‚ü®Œπ, U, hU, hU', H‚ü©
    refine' ‚ü®Y.open_cover_of_supr_eq_top U hU, hU', _‚ü©
    intro i
    specialize H i
    rw [‚Üê P.to_property_apply, ‚Üê hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _)]
    rw [‚Üê P.to_property_apply] at H 
    convert H
    all_goals ext1; exact Subtype.range_coe
  tfae_have 1 ‚Üí 5
  ¬∑ intro H
    refine'
      ‚ü®Y.carrier, fun x => (Y.affine_cover.map x).opensRange, _, fun i =>
        range_is_affine_open_of_open_immersion _, _‚ü©
    ¬∑ rw [eq_top_iff]; intro x _; erw [opens.mem_supr]; exact ‚ü®x, Y.affine_cover.covers x‚ü©
    ¬∑ intro i; exact H ‚ü®_, range_is_affine_open_of_open_immersion _‚ü©
  tfae_finish
#align algebraic_geometry.affine_target_morphism_property.is_local.affine_open_cover_tfae AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.affine_openCover_tFAE

theorem AffineTargetMorphismProperty.isLocalOfOpenCoverImply (P : AffineTargetMorphismProperty)
    (hP : P.toProperty.RespectsIso)
    (H :
      ‚àÄ {X Y : Scheme.{u}} (f : X ‚ü∂ Y),
        (‚àÉ (ùí∞ : Scheme.OpenCover.{u} Y) (_ : ‚àÄ i, IsAffine (ùí∞.obj i)),
            ‚àÄ i : ùí∞.J, P (pullback.snd : (ùí∞.pullback_cover f).obj i ‚ü∂ ùí∞.obj i)) ‚Üí
          ‚àÄ {U : Scheme} (g : U ‚ü∂ Y) [IsAffine U] [IsOpenImmersionCat g],
            P (pullback.snd : pullback f g ‚ü∂ U)) :
    P.IsLocal := by
  refine' ‚ü®hP, _, _‚ü©
  ¬∑ introv h
    skip
    haveI : is_affine _ := (top_is_affine_open Y).basicOpenIsAffine r
    delta morphism_restrict
    rw [affine_cancel_left_is_iso hP]
    refine' @H f ‚ü®Scheme.open_cover_of_is_iso (ùüô Y), _, _‚ü© (Y.of_restrict _) _inst _
    ¬∑ intro i; dsimp; infer_instance
    ¬∑ intro i; dsimp
      rwa [‚Üê category.comp_id pullback.snd, ‚Üê pullback.condition, affine_cancel_left_is_iso hP]
  ¬∑ introv hs hs'
    skip
    replace hs := ((top_is_affine_open Y).basicOpen_union_eq_self_iff _).mpr hs
    have := H f ‚ü®Y.open_cover_of_supr_eq_top _ hs, _, _‚ü© (ùüô _)
    rwa [‚Üê category.comp_id pullback.snd, ‚Üê pullback.condition, affine_cancel_left_is_iso hP] at
      this 
    ¬∑ intro i; exact (top_is_affine_open Y).basicOpenIsAffine _
    ¬∑ rintro (i : s)
      specialize hs' i
      haveI : is_affine _ := (top_is_affine_open Y).basicOpenIsAffine i.1
      delta morphism_restrict at hs' 
      rwa [affine_cancel_left_is_iso hP] at hs' 
#align algebraic_geometry.affine_target_morphism_property.is_local_of_open_cover_imply AlgebraicGeometry.AffineTargetMorphismProperty.isLocalOfOpenCoverImply

theorem AffineTargetMorphismProperty.IsLocal.affine_openCover_iff {P : AffineTargetMorphismProperty}
    (hP : P.IsLocal) {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (ùí∞ : Scheme.OpenCover.{u} Y)
    [hùí∞ : ‚àÄ i, IsAffine (ùí∞.obj i)] :
    targetAffineLocally P f ‚Üî ‚àÄ i, @P (pullback.snd : pullback f (ùí∞.map i) ‚ü∂ _) (hùí∞ i) :=
  ‚ü®fun H =>
    let h := ((hP.affine_openCover_tFAE f).out 0 2).mp H
    h ùí∞,
    fun H =>
    let h := ((hP.affine_openCover_tFAE f).out 1 0).mp
    h ‚ü®ùí∞, inferInstance, H‚ü©‚ü©
#align algebraic_geometry.affine_target_morphism_property.is_local.affine_open_cover_iff AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.affine_openCover_iff

theorem AffineTargetMorphismProperty.IsLocal.affine_target_iff {P : AffineTargetMorphismProperty}
    (hP : P.IsLocal) {X Y : Scheme.{u}} (f : X ‚ü∂ Y) [IsAffine Y] : targetAffineLocally P f ‚Üî P f :=
  by
  rw [hP.affine_open_cover_iff f _]
  swap; ¬∑ exact Scheme.open_cover_of_is_iso (ùüô Y)
  swap; ¬∑ intro; dsimp; infer_instance
  trans P (pullback.snd : pullback f (ùüô _) ‚ü∂ _)
  ¬∑ exact ‚ü®fun H => H PUnit.unit, fun H _ => H‚ü©
  rw [‚Üê category.comp_id pullback.snd, ‚Üê pullback.condition, affine_cancel_left_is_iso hP.1]
#align algebraic_geometry.affine_target_morphism_property.is_local.affine_target_iff AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.affine_target_iff

/-- We say that `P : morphism_property Scheme` is local at the target if
1. `P` respects isomorphisms.
2. If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ U` for any `U`.
3. If `P` holds for `f ‚à£_ U` for an open cover `U` of `Y`, then `P` holds for `f`.
-/
structure PropertyIsLocalAtTarget (P : MorphismProperty Scheme) : Prop where
  RespectsIso : P.RespectsIso
  restrict : ‚àÄ {X Y : Scheme} (f : X ‚ü∂ Y) (U : Opens Y.carrier), P f ‚Üí P (f ‚à£_ U)
  of_open_cover :
    ‚àÄ {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (ùí∞ : Scheme.OpenCover.{u} Y),
      (‚àÄ i : ùí∞.J, P (pullback.snd : (ùí∞.pullbackCover f).obj i ‚ü∂ ùí∞.obj i)) ‚Üí P f
#align algebraic_geometry.property_is_local_at_target AlgebraicGeometry.PropertyIsLocalAtTarget

theorem AffineTargetMorphismProperty.IsLocal.targetAffineLocallyIsLocal
    {P : AffineTargetMorphismProperty} (hP : P.IsLocal) :
    PropertyIsLocalAtTarget (targetAffineLocally P) :=
  by
  constructor
  ¬∑ exact target_affine_locally_respects_iso hP.1
  ¬∑ intro X Y f U H V
    rw [‚Üê P.to_property_apply, hP.1.arrow_mk_iso_iff (morphism_restrict_restrict f _ _)]
    convert H ‚ü®_, is_affine_open.image_is_open_immersion V.2 (Y.of_restrict _)‚ü©
    rw [‚Üê P.to_property_apply]
    rfl
  ¬∑ rintro X Y f ùí∞ hùí∞
    rw [(hP.affine_open_cover_tfae f).out 0 1]
    refine' ‚ü®ùí∞.bind fun _ => Scheme.affine_cover _, _, _‚ü©
    ¬∑ intro i; dsimp [Scheme.open_cover.bind]; infer_instance
    ¬∑ intro i
      specialize hùí∞ i.1
      rw [(hP.affine_open_cover_tfae (pullback.snd : pullback f (ùí∞.map i.fst) ‚ü∂ _)).out 0 2] at hùí∞ 
      specialize hùí∞ (Scheme.affine_cover _) i.2
      let e :
        pullback f ((ùí∞.obj i.fst).affineCover.map i.snd ‚â´ ùí∞.map i.fst) ‚ü∂
          pullback (pullback.snd : pullback f (ùí∞.map i.fst) ‚ü∂ _)
            ((ùí∞.obj i.fst).affineCover.map i.snd) :=
        by
        refine' (pullback_symmetry _ _).Hom ‚â´ _
        refine' (pullback_right_pullback_fst_iso _ _ _).inv ‚â´ _
        refine' (pullback_symmetry _ _).Hom ‚â´ _
        refine' pullback.map _ _ _ _ (pullback_symmetry _ _).Hom (ùüô _) (ùüô _) _ _ <;>
          simp only [category.comp_id, category.id_comp, pullback_symmetry_hom_comp_snd]
      rw [‚Üê affine_cancel_left_is_iso hP.1 e] at hùí∞ 
      convert hùí∞
      simp
#align algebraic_geometry.affine_target_morphism_property.is_local.target_affine_locally_is_local AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.targetAffineLocallyIsLocal

theorem PropertyIsLocalAtTarget.openCover_tFAE {P : MorphismProperty Scheme}
    (hP : PropertyIsLocalAtTarget P) {X Y : Scheme.{u}} (f : X ‚ü∂ Y) :
    TFAE
      [P f,
        ‚àÉ ùí∞ : Scheme.OpenCover.{u} Y,
          ‚àÄ i : ùí∞.J, P (pullback.snd : (ùí∞.pullbackCover f).obj i ‚ü∂ ùí∞.obj i),
        ‚àÄ (ùí∞ : Scheme.OpenCover.{u} Y) (i : ùí∞.J),
          P (pullback.snd : (ùí∞.pullbackCover f).obj i ‚ü∂ ùí∞.obj i),
        ‚àÄ U : Opens Y.carrier, P (f ‚à£_ U),
        ‚àÄ {U : Scheme} (g : U ‚ü∂ Y) [IsOpenImmersionCat g], P (pullback.snd : pullback f g ‚ü∂ U),
        ‚àÉ (Œπ : Type u) (U : Œπ ‚Üí Opens Y.carrier) (hU : iSup U = ‚ä§), ‚àÄ i, P (f ‚à£_ U i)] :=
  by
  tfae_have 2 ‚Üí 1
  ¬∑ rintro ‚ü®ùí∞, H‚ü©; exact hP.3 f ùí∞ H
  tfae_have 1 ‚Üí 4
  ¬∑ intro H U; exact hP.2 f U H
  tfae_have 4 ‚Üí 3
  ¬∑ intro H ùí∞ i
    rw [‚Üê hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _)]
    exact H (ùí∞.map i).opensRange
  tfae_have 3 ‚Üí 2
  ¬∑ exact fun H => ‚ü®Y.affine_cover, H Y.affine_cover‚ü©
  tfae_have 4 ‚Üí 5
  ¬∑ intro H U g hg
    skip
    rw [‚Üê hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _)]
    apply H
  tfae_have 5 ‚Üí 4
  ¬∑ intro H U
    erw [hP.1.cancel_left_isIso]
    apply H
  tfae_have 4 ‚Üí 6
  ¬∑ intro H; exact ‚ü®PUnit, fun _ => ‚ä§, ciSup_const, fun _ => H _‚ü©
  tfae_have 6 ‚Üí 2
  ¬∑ rintro ‚ü®Œπ, U, hU, H‚ü©
    refine' ‚ü®Y.open_cover_of_supr_eq_top U hU, _‚ü©
    intro i
    rw [‚Üê hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _)]
    convert H i
    all_goals ext1; exact Subtype.range_coe
  tfae_finish
#align algebraic_geometry.property_is_local_at_target.open_cover_tfae AlgebraicGeometry.PropertyIsLocalAtTarget.openCover_tFAE

theorem PropertyIsLocalAtTarget.openCover_iff {P : MorphismProperty Scheme}
    (hP : PropertyIsLocalAtTarget P) {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (ùí∞ : Scheme.OpenCover.{u} Y) :
    P f ‚Üî ‚àÄ i, P (pullback.snd : pullback f (ùí∞.map i) ‚ü∂ _) :=
  ‚ü®fun H =>
    let h := ((hP.openCover_tFAE f).out 0 2).mp H
    h ùí∞,
    fun H =>
    let h := ((hP.openCover_tFAE f).out 1 0).mp
    h ‚ü®ùí∞, H‚ü©‚ü©
#align algebraic_geometry.property_is_local_at_target.open_cover_iff AlgebraicGeometry.PropertyIsLocalAtTarget.openCover_iff

namespace AffineTargetMorphismProperty

/-- A `P : affine_target_morphism_property` is stable under base change if `P` holds for `Y ‚ü∂ S`
implies that `P` holds for `X √ó‚Çõ Y ‚ü∂ X` with `X` and `S` affine schemes. -/
def StableUnderBaseChange (P : AffineTargetMorphismProperty) : Prop :=
  ‚àÄ ‚¶ÉX Y S : Scheme‚¶Ñ [IsAffine S] [IsAffine X] (f : X ‚ü∂ S) (g : Y ‚ü∂ S),
    P g ‚Üí P (pullback.fst : pullback f g ‚ü∂ X)
#align algebraic_geometry.affine_target_morphism_property.stable_under_base_change AlgebraicGeometry.AffineTargetMorphismProperty.StableUnderBaseChange

theorem IsLocal.targetAffineLocallyPullbackFstOfRightOfStableUnderBaseChange
    {P : AffineTargetMorphismProperty} (hP : P.IsLocal) (hP' : P.StableUnderBaseChange)
    {X Y S : Scheme} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) [IsAffine S] (H : P g) :
    targetAffineLocally P (pullback.fst : pullback f g ‚ü∂ X) :=
  by
  rw [(hP.affine_open_cover_tfae (pullback.fst : pullback f g ‚ü∂ X)).out 0 1]
  use X.affine_cover, inferInstance
  intro i
  let e := pullback_symmetry _ _ ‚â™‚â´ pullback_right_pullback_fst_iso f g (X.affine_cover.map i)
  have : e.hom ‚â´ pullback.fst = pullback.snd := by simp
  rw [‚Üê this, affine_cancel_left_is_iso hP.1]
  apply hP' <;> assumption
#align algebraic_geometry.affine_target_morphism_property.is_local.target_affine_locally_pullback_fst_of_right_of_stable_under_base_change AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.targetAffineLocallyPullbackFstOfRightOfStableUnderBaseChange

theorem IsLocal.stableUnderBaseChange {P : AffineTargetMorphismProperty} (hP : P.IsLocal)
    (hP' : P.StableUnderBaseChange) : (targetAffineLocally P).StableUnderBaseChange :=
  MorphismProperty.StableUnderBaseChange.mk (targetAffineLocally_respectsIso hP.RespectsIso)
    (by
      intro X Y S f g H
      rw [(hP.target_affine_locally_is_local.open_cover_tfae (pullback.fst : pullback f g ‚ü∂ X)).out
          0 1]
      use S.affine_cover.pullback_cover f
      intro i
      rw [(hP.affine_open_cover_tfae g).out 0 3] at H 
      let e :
        pullback (pullback.fst : pullback f g ‚ü∂ _) ((S.affine_cover.pullback_cover f).map i) ‚âÖ _ :=
        by
        refine'
          pullback_symmetry _ _ ‚â™‚â´
            pullback_right_pullback_fst_iso f g _ ‚â™‚â´
              _ ‚â™‚â´
                (pullback_right_pullback_fst_iso (S.affine_cover.map i) g
                    (pullback.snd : pullback f (S.affine_cover.map i) ‚ü∂ _)).symm
        exact
          as_iso
            (pullback.map _ _ _ _ (ùüô _) (ùüô _) (ùüô _) (by simpa using pullback.condition) (by simp))
      have : e.hom ‚â´ pullback.fst = pullback.snd := by simp
      rw [‚Üê this, (target_affine_locally_respects_iso hP.1).cancel_left_isIso]
      apply hP.target_affine_locally_pullback_fst_of_right_of_stable_under_base_change hP'
      rw [‚Üê pullback_symmetry_hom_comp_snd, affine_cancel_left_is_iso hP.1]
      apply H)
#align algebraic_geometry.affine_target_morphism_property.is_local.stable_under_base_change AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.stableUnderBaseChange

end AffineTargetMorphismProperty

/-- The `affine_target_morphism_property` associated to `(target_affine_locally P).diagonal`.
See `diagonal_target_affine_locally_eq_target_affine_locally`.
-/
def AffineTargetMorphismProperty.diagonal (P : AffineTargetMorphismProperty) :
    AffineTargetMorphismProperty := fun X Y f hf =>
  ‚àÄ {U‚ÇÅ U‚ÇÇ : Scheme} (f‚ÇÅ : U‚ÇÅ ‚ü∂ X) (f‚ÇÇ : U‚ÇÇ ‚ü∂ X) [IsAffine U‚ÇÅ] [IsAffine U‚ÇÇ] [IsOpenImmersionCat f‚ÇÅ]
    [IsOpenImmersionCat f‚ÇÇ], P (pullback.map_desc f‚ÇÅ f‚ÇÇ f)
#align algebraic_geometry.affine_target_morphism_property.diagonal AlgebraicGeometry.AffineTargetMorphismProperty.diagonal

theorem AffineTargetMorphismProperty.diagonal_respectsIso (P : AffineTargetMorphismProperty)
    (hP : P.toProperty.RespectsIso) : P.diagonal.toProperty.RespectsIso :=
  by
  delta affine_target_morphism_property.diagonal
  apply affine_target_morphism_property.respects_iso_mk
  ¬∑ introv H _ _
    skip
    rw [pullback.map_desc_comp, affine_cancel_left_is_iso hP, affine_cancel_right_is_iso hP]
    apply H
  ¬∑ introv H _ _
    skip
    rw [pullback.map_desc_comp, affine_cancel_right_is_iso hP]
    apply H
#align algebraic_geometry.affine_target_morphism_property.diagonal_respects_iso AlgebraicGeometry.AffineTargetMorphismProperty.diagonal_respectsIso

theorem diagonalTargetAffineLocallyOfOpenCover (P : AffineTargetMorphismProperty) (hP : P.IsLocal)
    {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (ùí∞ : Scheme.OpenCover.{u} Y) [‚àÄ i, IsAffine (ùí∞.obj i)]
    (ùí∞' : ‚àÄ i, Scheme.OpenCover.{u} (pullback f (ùí∞.map i))) [‚àÄ i j, IsAffine ((ùí∞' i).obj j)]
    (hùí∞' : ‚àÄ i j k, P (pullback.mapDesc ((ùí∞' i).map j) ((ùí∞' i).map k) pullback.snd)) :
    (targetAffineLocally P).diagonal f :=
  by
  refine' (hP.affine_open_cover_iff _ _).mpr _
  ¬∑
    exact
      (Scheme.pullback.open_cover_of_base ùí∞ f f).bind fun i =>
        Scheme.Pullback.openCoverOfLeftRight.{u, u} (ùí∞' i) (ùí∞' i) pullback.snd pullback.snd
  ¬∑ intro i
    dsimp at *
    infer_instance
  ¬∑ rintro ‚ü®i, j, k‚ü©
    dsimp
    convert
      (affine_cancel_left_is_iso hP.1
            (pullback_diagonal_map_iso _ _ ((ùí∞' i).map j) ((ùí∞' i).map k)).inv pullback.snd).mp
        _
    pick_goal 3
    ¬∑ convert hùí∞' i j k; apply pullback.hom_ext <;> simp
    all_goals
      apply pullback.hom_ext <;>
        simp only [category.assoc, pullback.lift_fst, pullback.lift_snd, pullback.lift_fst_assoc,
          pullback.lift_snd_assoc]
#align algebraic_geometry.diagonal_target_affine_locally_of_open_cover AlgebraicGeometry.diagonalTargetAffineLocallyOfOpenCover

theorem AffineTargetMorphismProperty.diagonalOfTargetAffineLocally
    (P : AffineTargetMorphismProperty) (hP : P.IsLocal) {X Y U : Scheme.{u}} (f : X ‚ü∂ Y) (g : U ‚ü∂ Y)
    [IsAffine U] [IsOpenImmersionCat g] (H : (targetAffineLocally P).diagonal f) :
    P.diagonal (pullback.snd : pullback f g ‚ü∂ _) :=
  by
  rintro U V f‚ÇÅ f‚ÇÇ _ _ _ _
  skip
  replace H := ((hP.affine_open_cover_tfae (pullback.diagonal f)).out 0 3).mp H
  let g‚ÇÅ :=
    pullback.map (f‚ÇÅ ‚â´ pullback.snd) (f‚ÇÇ ‚â´ pullback.snd) f f (f‚ÇÅ ‚â´ pullback.fst) (f‚ÇÇ ‚â´ pullback.fst)
      g (by rw [category.assoc, category.assoc, pullback.condition])
      (by rw [category.assoc, category.assoc, pullback.condition])
  let g‚ÇÇ : pullback f‚ÇÅ f‚ÇÇ ‚ü∂ pullback f g := pullback.fst ‚â´ f‚ÇÅ
  specialize H g‚ÇÅ
  rw [‚Üê affine_cancel_left_is_iso hP.1 (pullback_diagonal_map_iso f _ f‚ÇÅ f‚ÇÇ).Hom]
  convert H
  ¬∑
    apply pullback.hom_ext <;>
      simp only [category.assoc, pullback.lift_fst, pullback.lift_snd, pullback.lift_fst_assoc,
        pullback.lift_snd_assoc, category.comp_id, pullback_diagonal_map_iso_hom_fst,
        pullback_diagonal_map_iso_hom_snd]
#align algebraic_geometry.affine_target_morphism_property.diagonal_of_target_affine_locally AlgebraicGeometry.AffineTargetMorphismProperty.diagonalOfTargetAffineLocally

theorem AffineTargetMorphismProperty.IsLocal.diagonal_affine_openCover_tFAE
    {P : AffineTargetMorphismProperty} (hP : P.IsLocal) {X Y : Scheme.{u}} (f : X ‚ü∂ Y) :
    TFAE
      [(targetAffineLocally P).diagonal f,
        ‚àÉ (ùí∞ : Scheme.OpenCover.{u} Y) (_ : ‚àÄ i, IsAffine (ùí∞.obj i)),
          ‚àÄ i : ùí∞.J, P.diagonal (pullback.snd : pullback f (ùí∞.map i) ‚ü∂ _),
        ‚àÄ (ùí∞ : Scheme.OpenCover.{u} Y) [‚àÄ i, IsAffine (ùí∞.obj i)] (i : ùí∞.J),
          P.diagonal (pullback.snd : pullback f (ùí∞.map i) ‚ü∂ _),
        ‚àÄ {U : Scheme} (g : U ‚ü∂ Y) [IsAffine U] [IsOpenImmersionCat g],
          P.diagonal (pullback.snd : pullback f g ‚ü∂ _),
        ‚àÉ (ùí∞ : Scheme.OpenCover.{u} Y) (_ : ‚àÄ i, IsAffine (ùí∞.obj i)) (ùí∞' :
          ‚àÄ i, Scheme.OpenCover.{u} (pullback f (ùí∞.map i))) (_ : ‚àÄ i j, IsAffine ((ùí∞' i).obj j)),
          ‚àÄ i j k, P (pullback.map_desc ((ùí∞' i).map j) ((ùí∞' i).map k) pullback.snd)] :=
  by
  tfae_have 1 ‚Üí 4
  ¬∑ introv H hU hg _ _; skip; apply P.diagonal_of_target_affine_locally <;> assumption
  tfae_have 4 ‚Üí 3
  ¬∑ introv H hùí∞; skip; apply H
  tfae_have 3 ‚Üí 2
  ¬∑ exact fun H => ‚ü®Y.affine_cover, inferInstance, H Y.affine_cover‚ü©
  tfae_have 2 ‚Üí 5
  ¬∑ rintro ‚ü®ùí∞, hùí∞, H‚ü©
    skip
    refine' ‚ü®ùí∞, inferInstance, fun _ => Scheme.affine_cover _, inferInstance, _‚ü©
    intro i j k
    apply H
  tfae_have 5 ‚Üí 1
  ¬∑ rintro ‚ü®ùí∞, _, ùí∞', _, H‚ü©
    exact diagonal_target_affine_locally_of_open_cover P hP f ùí∞ ùí∞' H
  tfae_finish
#align algebraic_geometry.affine_target_morphism_property.is_local.diagonal_affine_open_cover_tfae AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.diagonal_affine_openCover_tFAE

theorem AffineTargetMorphismProperty.IsLocal.diagonal {P : AffineTargetMorphismProperty}
    (hP : P.IsLocal) : P.diagonal.IsLocal :=
  AffineTargetMorphismProperty.isLocalOfOpenCoverImply P.diagonal (P.diagonal_respectsIso hP.1)
    fun _ _ f => ((hP.diagonal_affine_openCover_tFAE f).out 1 3).mp
#align algebraic_geometry.affine_target_morphism_property.is_local.diagonal AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.diagonal

theorem diagonal_targetAffineLocally_eq_targetAffineLocally (P : AffineTargetMorphismProperty)
    (hP : P.IsLocal) : (targetAffineLocally P).diagonal = targetAffineLocally P.diagonal :=
  by
  ext _ _ f
  exact
    ((hP.diagonal_affine_open_cover_tfae f).out 0 1).trans
      ((hP.diagonal.affine_open_cover_tfae f).out 1 0)
#align algebraic_geometry.diagonal_target_affine_locally_eq_target_affine_locally AlgebraicGeometry.diagonal_targetAffineLocally_eq_targetAffineLocally

theorem universallyIsLocalAtTarget (P : MorphismProperty Scheme)
    (hP :
      ‚àÄ {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (ùí∞ : Scheme.OpenCover.{u} Y),
        (‚àÄ i : ùí∞.J, P (pullback.snd : (ùí∞.pullbackCover f).obj i ‚ü∂ ùí∞.obj i)) ‚Üí P f) :
    PropertyIsLocalAtTarget P.universally :=
  by
  refine'
    ‚ü®P.universally_respects_iso, fun X Y f U =>
      P.universally_stable_under_base_change (is_pullback_morphism_restrict f U).flip, _‚ü©
  intro X Y f ùí∞ h X' Y' i‚ÇÅ i‚ÇÇ f' H
  apply hP _ (ùí∞.pullback_cover i‚ÇÇ)
  intro i
  dsimp
  apply h i (pullback.lift (pullback.fst ‚â´ i‚ÇÅ) (pullback.snd ‚â´ pullback.snd) _) pullback.snd
  swap
  ¬∑ rw [category.assoc, category.assoc, ‚Üê pullback.condition, ‚Üê pullback.condition_assoc, H.w]
  refine' (is_pullback.of_right _ (pullback.lift_snd _ _ _) (is_pullback.of_has_pullback _ _)).flip
  rw [pullback.lift_fst, ‚Üê pullback.condition]
  exact (is_pullback.of_has_pullback _ _).paste_horiz H.flip
#align algebraic_geometry.universally_is_local_at_target AlgebraicGeometry.universallyIsLocalAtTarget

theorem universallyIsLocalAtTargetOfMorphismRestrict (P : MorphismProperty Scheme)
    (hP‚ÇÅ : P.RespectsIso)
    (hP‚ÇÇ :
      ‚àÄ {X Y : Scheme.{u}} (f : X ‚ü∂ Y) {Œπ : Type u} (U : Œπ ‚Üí Opens Y.carrier) (hU : iSup U = ‚ä§),
        (‚àÄ i, P (f ‚à£_ U i)) ‚Üí P f) :
    PropertyIsLocalAtTarget P.universally :=
  universallyIsLocalAtTarget P
    (by
      intro X Y f ùí∞ hùí∞
      apply hP‚ÇÇ f (fun i : ùí∞.J => (ùí∞.map i).opensRange) ùí∞.supr_opens_range
      simp_rw [hP‚ÇÅ.arrow_mk_iso_iff (morphism_restrict_opens_range f _)]
      exact hùí∞)
#align algebraic_geometry.universally_is_local_at_target_of_morphism_restrict AlgebraicGeometry.universallyIsLocalAtTargetOfMorphismRestrict

/-- `topologically P` holds for a morphism if the underlying topological map satisfies `P`. -/
def MorphismProperty.topologically
    (P : ‚àÄ {Œ± Œ≤ : Type u} [TopologicalSpace Œ±] [TopologicalSpace Œ≤] (f : Œ± ‚Üí Œ≤), Prop) :
    MorphismProperty Scheme.{u} := fun X Y f => P f.1.base
#align algebraic_geometry.morphism_property.topologically AlgebraicGeometry.MorphismProperty.topologically

end AlgebraicGeometry

