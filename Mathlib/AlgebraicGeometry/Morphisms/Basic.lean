/-
Copyright (c) 2022 Andrew Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Andrew Yang
-/
import Mathlib.AlgebraicGeometry.AffineScheme
import Mathlib.AlgebraicGeometry.Pullbacks
import Mathlib.CategoryTheory.MorphismProperty.Limits
import Mathlib.Data.List.TFAE

#align_import algebraic_geometry.morphisms.basic from "leanprover-community/mathlib"@"434e2fd21c1900747afc6d13d8be7f4eedba7218"

/-!
# Properties of morphisms between Schemes

We provide the basic framework for talking about properties of morphisms between Schemes.

A `MorphismProperty Scheme` is a predicate on morphisms between schemes, and an
`AffineTargetMorphismProperty` is a predicate on morphisms into affine schemes. Given a
`P : AffineTargetMorphismProperty`, we may construct a `MorphismProperty` called
`targetAffineLocally P` that holds for `f : X ‚ü∂ Y` whenever `P` holds for the
restriction of `f` on every affine open subset of `Y`.

## Main definitions

- `AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal`: We say that `P.IsLocal` if `P`
satisfies the assumptions of the affine communication lemma
(`AlgebraicGeometry.of_affine_open_cover`). That is,
1. `P` respects isomorphisms.
2. If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ Y.basicOpen r` for any
  global section `r`.
3. If `P` holds for `f ‚à£_ Y.basicOpen r` for all `r` in a spanning set of the global sections,
  then `P` holds for `f`.

- `AlgebraicGeometry.PropertyIsLocalAtTarget`: We say that `PropertyIsLocalAtTarget P` for
`P : MorphismProperty Scheme` if
1. `P` respects isomorphisms.
2. If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ U` for any `U`.
3. If `P` holds for `f ‚à£_ U` for an open cover `U` of `Y`, then `P` holds for `f`.

## Main results

- `AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.affine_openCover_TFAE`:
  If `P.IsLocal`, then `targetAffineLocally P f` iff there exists an affine cover `{ U·µ¢ }` of `Y`
  such that `P` holds for `f ‚à£_ U·µ¢`.
- `AlgebraicGeometry.AffineTargetMorphismProperty.isLocalOfOpenCoverImply`:
  If the existence of an affine cover `{ U·µ¢ }` of `Y` such that `P` holds for `f ‚à£_ U·µ¢` implies
  `targetAffineLocally P f`, then `P.IsLocal`.
- `AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.affine_target_iff`:
  If `Y` is affine and `f : X ‚ü∂ Y`, then `targetAffineLocally P f ‚Üî P f` provided `P.IsLocal`.
- `AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.targetAffineLocally_isLocal` :
  If `P.IsLocal`, then `PropertyIsLocalAtTarget (targetAffineLocally P)`.
- `AlgebraicGeometry.PropertyIsLocalAtTarget.openCover_TFAE`:
  If `PropertyIsLocalAtTarget P`, then `P f` iff there exists an open cover `{ U·µ¢ }` of `Y`
  such that `P` holds for `f ‚à£_ U·µ¢`.

These results should not be used directly, and should be ported to each property that is local.

-/

set_option linter.uppercaseLean3 false

universe u

open TopologicalSpace CategoryTheory CategoryTheory.Limits Opposite

noncomputable section

namespace AlgebraicGeometry

/-- An `AffineTargetMorphismProperty` is a class of morphisms from an arbitrary scheme into an
affine scheme. -/
def AffineTargetMorphismProperty :=
  ‚àÄ ‚¶ÉX Y : Scheme‚¶Ñ (_ : X ‚ü∂ Y) [IsAffine Y], Prop
#align algebraic_geometry.affine_target_morphism_property AlgebraicGeometry.AffineTargetMorphismProperty

/-- `IsIso` as a `MorphismProperty`. -/
protected def Scheme.isIso : MorphismProperty Scheme :=
  @IsIso Scheme _
#align algebraic_geometry.Scheme.is_iso AlgebraicGeometry.Scheme.isIso

/-- `IsIso` as an `AffineTargetMorphismProperty`. -/
protected def Scheme.affineTargetIsIso : AffineTargetMorphismProperty := fun _ _ f _ => IsIso f
#align algebraic_geometry.Scheme.affine_target_is_iso AlgebraicGeometry.Scheme.affineTargetIsIso

instance : Inhabited AffineTargetMorphismProperty := ‚ü®Scheme.affineTargetIsIso‚ü©

/-- An `AffineTargetMorphismProperty` can be extended to a `MorphismProperty` such that it
*never* holds when the target is not affine -/
def AffineTargetMorphismProperty.toProperty (P : AffineTargetMorphismProperty) :
    MorphismProperty Scheme := fun _ _ f => ‚àÉ h, @P _ _ f h
#align algebraic_geometry.affine_target_morphism_property.to_property AlgebraicGeometry.AffineTargetMorphismProperty.toProperty

theorem AffineTargetMorphismProperty.toProperty_apply (P : AffineTargetMorphismProperty)
    {X Y : Scheme} (f : X ‚ü∂ Y) [i : IsAffine Y] : P.toProperty f ‚Üî P f := by
  delta AffineTargetMorphismProperty.toProperty; simp [*]
#align algebraic_geometry.affine_target_morphism_property.to_property_apply AlgebraicGeometry.AffineTargetMorphismProperty.toProperty_apply

theorem AffineTargetMorphismProperty.cancel_left_of_respectsIso
    (P : AffineTargetMorphismProperty) [P.toProperty.RespectsIso]
    {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsIso f] [IsAffine Z] : P (f ‚â´ g) ‚Üî P g := by
  rw [‚Üê P.toProperty_apply, ‚Üê P.toProperty_apply, P.toProperty.cancel_left_of_respectsIso]
#align algebraic_geometry.affine_cancel_left_is_iso AlgebraicGeometry.AffineTargetMorphismProperty.cancel_left_of_respectsIso

theorem AffineTargetMorphismProperty.cancel_right_of_respectsIso
    (P : AffineTargetMorphismProperty) [P.toProperty.RespectsIso]
    {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsIso g] [IsAffine Z] [IsAffine Y] :
    P (f ‚â´ g) ‚Üî P f := by rw [‚Üê P.toProperty_apply, ‚Üê P.toProperty_apply,
      P.toProperty.cancel_right_of_respectsIso]
#align algebraic_geometry.affine_cancel_right_is_iso AlgebraicGeometry.AffineTargetMorphismProperty.cancel_right_of_respectsIso

@[deprecated (since := "2024-07-02")] alias affine_cancel_left_isIso :=
  AffineTargetMorphismProperty.cancel_left_of_respectsIso
@[deprecated (since := "2024-07-02")] alias affine_cancel_right_isIso :=
  AffineTargetMorphismProperty.cancel_right_of_respectsIso

theorem AffineTargetMorphismProperty.respectsIso_mk {P : AffineTargetMorphismProperty}
    (h‚ÇÅ : ‚àÄ {X Y Z} (e : X ‚âÖ Y) (f : Y ‚ü∂ Z) [IsAffine Z], P f ‚Üí P (e.hom ‚â´ f))
    (h‚ÇÇ : ‚àÄ {X Y Z} (e : Y ‚âÖ Z) (f : X ‚ü∂ Y) [h : IsAffine Y],
      P f ‚Üí @P _ _ (f ‚â´ e.hom) (isAffine_of_isIso e.inv)) :
    P.toProperty.RespectsIso := by
  constructor
  ¬∑ rintro X Y Z e f ‚ü®a, h‚ü©; exact ‚ü®a, h‚ÇÅ e f h‚ü©
  ¬∑ rintro X Y Z e f ‚ü®a, h‚ü©; exact ‚ü®isAffine_of_isIso e.inv, h‚ÇÇ e f h‚ü©
#align algebraic_geometry.affine_target_morphism_property.respects_iso_mk AlgebraicGeometry.AffineTargetMorphismProperty.respectsIso_mk

/-- For a `P : AffineTargetMorphismProperty`, `targetAffineLocally P` holds for
`f : X ‚ü∂ Y` whenever `P` holds for the restriction of `f` on every affine open subset of `Y`. -/
def targetAffineLocally (P : AffineTargetMorphismProperty) : MorphismProperty Scheme :=
  fun {X Y : Scheme} (f : X ‚ü∂ Y) => ‚àÄ U : Y.affineOpens, P (f ‚à£_ U)
#align algebraic_geometry.target_affine_locally AlgebraicGeometry.targetAffineLocally

theorem IsAffineOpen.preimage_of_isIso {X Y : Scheme} {U : Opens Y.carrier} (hU : IsAffineOpen U)
    (f : X ‚ü∂ Y) [IsIso f] : IsAffineOpen (f ‚Åª¬π·µÅ U) :=
  haveI : IsAffine _ := hU
  isAffine_of_isIso (f ‚à£_ U)
#align algebraic_geometry.is_affine_open.map_is_iso AlgebraicGeometry.IsAffineOpen.preimage_of_isIso

instance targetAffineLocally_respectsIso (P : AffineTargetMorphismProperty)
    [P.toProperty.RespectsIso] : (targetAffineLocally P).RespectsIso := by
  constructor
  ¬∑ introv H U
    rw [morphismRestrict_comp, P.cancel_left_of_respectsIso]
    exact H U
  ¬∑ introv H
    rintro ‚ü®U, hU : IsAffineOpen U‚ü©; dsimp
    haveI : IsAffine _ := hU.preimage_of_isIso e.hom
    rw [morphismRestrict_comp, P.cancel_right_of_respectsIso]
    exact H ‚ü®(Opens.map e.hom.val.base).obj U, hU.preimage_of_isIso e.hom‚ü©
#align algebraic_geometry.target_affine_locally_respects_iso AlgebraicGeometry.targetAffineLocally_respectsIso

/-- We say that `P : AffineTargetMorphismProperty` is a local property if
1. `P` respects isomorphisms.
2. If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ Y.basicOpen r` for any
  global section `r`.
3. If `P` holds for `f ‚à£_ Y.basicOpen r` for all `r` in a spanning set of the global sections,
  then `P` holds for `f`.
-/
structure AffineTargetMorphismProperty.IsLocal (P : AffineTargetMorphismProperty) : Prop where
  /-- `P` as a morphism property respects isomorphisms -/
  RespectsIso : P.toProperty.RespectsIso
  /-- `P` is stable under restriction to basic open set of global sections. -/
  toBasicOpen :
    ‚àÄ {X Y : Scheme} [IsAffine Y] (f : X ‚ü∂ Y) (r : Œì(Y, ‚ä§)),
      P f ‚Üí @P _ _ (f ‚à£_ Y.basicOpen r) ((isAffineOpen_top Y).basicOpen _)
  /-- `P` for `f` if `P` holds for `f` restricted to basic sets of a spanning set of the global
    sections -/
  ofBasicOpenCover :
    ‚àÄ {X Y : Scheme} [IsAffine Y] (f : X ‚ü∂ Y) (s : Finset Œì(Y, ‚ä§))
      (_ : Ideal.span (s : Set Œì(Y, ‚ä§)) = ‚ä§),
      (‚àÄ r : s, @P _ _ (f ‚à£_ Y.basicOpen r.1) ((isAffineOpen_top Y).basicOpen _)) ‚Üí P f
#align algebraic_geometry.affine_target_morphism_property.is_local AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal

/-- Specialization of `ConcreteCategory.id_apply` because `simp` can't see through the defeq. -/
@[local simp] lemma CommRingCat.id_apply (R : CommRingCat) (x : R) : ùüô R x = x := rfl

theorem targetAffineLocally_of_openCover {P : AffineTargetMorphismProperty} (hP : P.IsLocal)
    {X Y : Scheme} (f : X ‚ü∂ Y) (ùí∞ : Y.OpenCover) [‚àÄ i, IsAffine (ùí∞.obj i)]
    (hùí∞ : ‚àÄ i, P (pullback.snd : (ùí∞.pullbackCover f).obj i ‚ü∂ ùí∞.obj i)) :
    targetAffineLocally P f := by
  have := hP.1
  classical
  let S i : Y.affineOpens := ‚ü®_, isAffineOpen_opensRange (ùí∞.map i)‚ü©
  intro U
  induction U using of_affine_open_cover S ùí∞.iSup_opensRange with
  | basicOpen U r h =>
    haveI : IsAffine _ := U.2
    have := hP.2 (f ‚à£_ U.1)
    replace this := this (Y.presheaf.map (eqToHom U.1.openEmbedding_obj_top).op r) h
    rw [‚Üê P.toProperty_apply] at this ‚ä¢
    exact (P.toProperty.arrow_mk_iso_iff (morphismRestrictRestrictBasicOpen f _ r)).mp this
  | openCover U s hs H =>
    haveI : IsAffine _ := U.2
    apply hP.3 (f ‚à£_ U.1) (s.image (Y.presheaf.map (eqToHom U.1.openEmbedding_obj_top).op))
    ¬∑ apply_fun Ideal.comap (Y.presheaf.map (eqToHom U.1.openEmbedding_obj_top.symm).op) at hs
      rw [Ideal.comap_top] at hs
      rw [‚Üê hs]
      simp only [eqToHom_op, eqToHom_map, Finset.coe_image]
      have : ‚àÄ {R S : CommRingCat} (e : S = R) (s : Set S),
          Ideal.span (eqToHom e '' s) = Ideal.comap (eqToHom e.symm) (Ideal.span s) := by
        intro _ S e _
        subst e
        simp only [eqToHom_refl, CommRingCat.id_apply, Set.image_id']
        -- Porting note: Lean didn't see `ùüô _` is just ring hom id
        exact (Ideal.comap_id _).symm
      apply this
    ¬∑ rintro ‚ü®r, hr‚ü©
      obtain ‚ü®r, hr', rfl‚ü© := Finset.mem_image.mp hr
      specialize H ‚ü®r, hr'‚ü©
      rw [‚Üê P.toProperty_apply] at H ‚ä¢
      exact (P.toProperty.arrow_mk_iso_iff (morphismRestrictRestrictBasicOpen f _ r)).mpr H
  | hU i =>
    specialize hùí∞ i
    rw [‚Üê P.toProperty_apply] at hùí∞ ‚ä¢
    exact (P.toProperty.arrow_mk_iso_iff (morphismRestrictOpensRange f _)).mpr hùí∞
#align algebraic_geometry.target_affine_locally_of_open_cover AlgebraicGeometry.targetAffineLocally_of_openCover

open List in
theorem AffineTargetMorphismProperty.IsLocal.affine_openCover_TFAE
    {P : AffineTargetMorphismProperty} (hP : P.IsLocal) {X Y : Scheme.{u}} (f : X ‚ü∂ Y) :
    TFAE
      [targetAffineLocally P f,
        ‚àÉ (ùí∞ : Scheme.OpenCover.{u} Y) (_ : ‚àÄ i, IsAffine (ùí∞.obj i)),
          ‚àÄ i : ùí∞.J, P (pullback.snd : (ùí∞.pullbackCover f).obj i ‚ü∂ ùí∞.obj i),
        ‚àÄ (ùí∞ : Scheme.OpenCover.{u} Y) [‚àÄ i, IsAffine (ùí∞.obj i)] (i : ùí∞.J),
          P (pullback.snd : (ùí∞.pullbackCover f).obj i ‚ü∂ ùí∞.obj i),
        ‚àÄ {U : Scheme} (g : U ‚ü∂ Y) [IsAffine U] [IsOpenImmersion g],
          P (pullback.snd : pullback f g ‚ü∂ U),
        ‚àÉ (Œπ : Type u) (U : Œπ ‚Üí Opens Y.carrier) (_ : iSup U = ‚ä§) (hU' : ‚àÄ i, IsAffineOpen (U i)),
          ‚àÄ i, @P _ _ (f ‚à£_ U i) (hU' i)] := by
  have := hP.1
  tfae_have 1 ‚Üí 4
  ¬∑ intro H U g h‚ÇÅ h‚ÇÇ
    replace H := H ‚ü®_, isAffineOpen_opensRange g‚ü©
    rw [‚Üê P.toProperty_apply] at H ‚ä¢
    rwa [‚Üê P.toProperty.arrow_mk_iso_iff (morphismRestrictOpensRange f _)]
  tfae_have 4 ‚Üí 3
  ¬∑ intro H ùí∞ hùí∞ i
    apply H
  tfae_have 3 ‚Üí 2
  ¬∑ exact fun H => ‚ü®Y.affineCover, inferInstance, H Y.affineCover‚ü©
  tfae_have 2 ‚Üí 1
  ¬∑ rintro ‚ü®ùí∞, hùí∞, H‚ü©; exact targetAffineLocally_of_openCover hP f ùí∞ H
  tfae_have 5 ‚Üí 2
  ¬∑ rintro ‚ü®Œπ, U, hU, hU', H‚ü©
    refine ‚ü®Y.openCoverOfSuprEqTop U hU, hU', ?_‚ü©
    intro i
    specialize H i
    rw [‚Üê P.toProperty_apply, ‚Üê P.toProperty.arrow_mk_iso_iff (morphismRestrictOpensRange f _)]
    rw [‚Üê P.toProperty_apply] at H
    convert H
    all_goals ext1; exact Subtype.range_coe
  tfae_have 1 ‚Üí 5
  ¬∑ intro H
    refine ‚ü®Y.carrier, fun x => (Scheme.Hom.opensRange <| Y.affineCover.map x),
      ?_, fun i => isAffineOpen_opensRange _, ?_‚ü©
    ¬∑ rw [eq_top_iff]; intro x _; erw [Opens.mem_iSup]; exact ‚ü®x, Y.affineCover.covers x‚ü©
    ¬∑ intro i; exact H ‚ü®_, isAffineOpen_opensRange _‚ü©
  tfae_finish
#align algebraic_geometry.affine_target_morphism_property.is_local.affine_open_cover_tfae AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.affine_openCover_TFAE

theorem AffineTargetMorphismProperty.isLocalOfOpenCoverImply (P : AffineTargetMorphismProperty)
    [P.toProperty.RespectsIso]
    (H : ‚àÄ {X Y : Scheme.{u}} (f : X ‚ü∂ Y),
      (‚àÉ (ùí∞ : Scheme.OpenCover.{u} Y) (_ : ‚àÄ i, IsAffine (ùí∞.obj i)),
        ‚àÄ i : ùí∞.J, P (pullback.snd : (ùí∞.pullbackCover f).obj i ‚ü∂ ùí∞.obj i)) ‚Üí
        ‚àÄ {U : Scheme} (g : U ‚ü∂ Y) [IsAffine U] [IsOpenImmersion g],
          P (pullback.snd : pullback f g ‚ü∂ U)) :
    P.IsLocal := by
  refine ‚ü®by assumption, ?_, ?_‚ü©
  ¬∑ introv h
    haveI : IsAffine _ := (isAffineOpen_top Y).basicOpen r
    delta morphismRestrict
    rw [P.cancel_left_of_respectsIso]
    refine @H _ _ f ‚ü®Scheme.openCoverOfIsIso (ùüô Y), ?_, ?_‚ü© _ (Y.ofRestrict _) _ _
    ¬∑ intro i; dsimp; infer_instance
    ¬∑ intro i; dsimp
      rwa [‚Üê Category.comp_id pullback.snd, ‚Üê pullback.condition, P.cancel_left_of_respectsIso]
  ¬∑ introv hs hs'
    replace hs := ((isAffineOpen_top Y).basicOpen_union_eq_self_iff _).mpr hs
    have := H f ‚ü®Y.openCoverOfSuprEqTop _ hs, ?_, ?_‚ü© (ùüô _)
    ¬∑ rwa [‚Üê Category.comp_id pullback.snd, ‚Üê pullback.condition, P.cancel_left_of_respectsIso]
        at this
    ¬∑ intro i; exact (isAffineOpen_top Y).basicOpen _
    ¬∑ rintro (i : s)
      specialize hs' i
      haveI : IsAffine _ := (isAffineOpen_top Y).basicOpen i.1
      delta morphismRestrict at hs'
      rwa [P.cancel_left_of_respectsIso] at hs'
#align algebraic_geometry.affine_target_morphism_property.is_local_of_open_cover_imply AlgebraicGeometry.AffineTargetMorphismProperty.isLocalOfOpenCoverImply

theorem AffineTargetMorphismProperty.IsLocal.affine_openCover_iff {P : AffineTargetMorphismProperty}
    (hP : P.IsLocal) {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (ùí∞ : Scheme.OpenCover.{u} Y)
    [hùí∞ : ‚àÄ i, IsAffine (ùí∞.obj i)] :
    targetAffineLocally P f ‚Üî ‚àÄ i, @P _ _ (pullback.snd : pullback f (ùí∞.map i) ‚ü∂ _) (hùí∞ i) := by
  refine ‚ü®fun H => let h := ((hP.affine_openCover_TFAE f).out 0 2).mp H; ?_,
    fun H => let h := ((hP.affine_openCover_TFAE f).out 1 0).mp; ?_‚ü©
  ¬∑ exact fun i => h ùí∞ i
  ¬∑ exact h ‚ü®ùí∞, inferInstance, H‚ü©
#align algebraic_geometry.affine_target_morphism_property.is_local.affine_open_cover_iff AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.affine_openCover_iff

theorem AffineTargetMorphismProperty.IsLocal.affine_target_iff {P : AffineTargetMorphismProperty}
    (hP : P.IsLocal) {X Y : Scheme.{u}} (f : X ‚ü∂ Y) [IsAffine Y] :
    targetAffineLocally P f ‚Üî P f := by
  have := hP.1
  haveI : ‚àÄ i, IsAffine (Scheme.OpenCover.obj (Scheme.openCoverOfIsIso (ùüô Y)) i) := fun i => by
    dsimp; infer_instance
  rw [hP.affine_openCover_iff f (Scheme.openCoverOfIsIso (ùüô Y))]
  trans P (pullback.snd : pullback f (ùüô _) ‚ü∂ _)
  ¬∑ exact ‚ü®fun H => H PUnit.unit, fun H _ => H‚ü©
  rw [‚Üê Category.comp_id pullback.snd, ‚Üê pullback.condition, P.cancel_left_of_respectsIso]
#align algebraic_geometry.affine_target_morphism_property.is_local.affine_target_iff AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.affine_target_iff

/-- We say that `P : MorphismProperty Scheme` is local at the target if
1. `P` respects isomorphisms.
2. If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ U` for any `U`.
3. If `P` holds for `f ‚à£_ U` for an open cover `U` of `Y`, then `P` holds for `f`.
-/
structure PropertyIsLocalAtTarget (P : MorphismProperty Scheme) : Prop where
  /-- `P` respects isomorphisms. -/
  RespectsIso : P.RespectsIso
  /-- If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ U` for any `U`. -/
  restrict : ‚àÄ {X Y : Scheme} (f : X ‚ü∂ Y) (U : Opens Y), P f ‚Üí P (f ‚à£_ U)
  /-- If `P` holds for `f ‚à£_ U` for an open cover `U` of `Y`, then `P` holds for `f`.  -/
  of_openCover :
    ‚àÄ {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (ùí∞ : Scheme.OpenCover.{u} Y),
      (‚àÄ i : ùí∞.J, P (pullback.snd : (ùí∞.pullbackCover f).obj i ‚ü∂ ùí∞.obj i)) ‚Üí P f
#align algebraic_geometry.property_is_local_at_target AlgebraicGeometry.PropertyIsLocalAtTarget

lemma propertyIsLocalAtTarget_of_morphismRestrict (P : MorphismProperty Scheme)
    [P.RespectsIso]
    (hP‚ÇÇ : ‚àÄ {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (U : Opens Y), P f ‚Üí P (f ‚à£_ U))
    (hP‚ÇÉ : ‚àÄ {X Y : Scheme.{u}} (f : X ‚ü∂ Y) {Œπ : Type u} (U : Œπ ‚Üí Opens Y)
      (_ : iSup U = ‚ä§), (‚àÄ i, P (f ‚à£_ U i)) ‚Üí P f) :
    PropertyIsLocalAtTarget P where
  RespectsIso := by assumption
  restrict := hP‚ÇÇ
  of_openCover {X Y} f ùí∞ hùí∞ := by
    apply hP‚ÇÉ f (fun i : ùí∞.J => Scheme.Hom.opensRange (ùí∞.map i)) ùí∞.iSup_opensRange
    simp_rw [P.arrow_mk_iso_iff (morphismRestrictOpensRange f _)]
    exact hùí∞

theorem AffineTargetMorphismProperty.IsLocal.targetAffineLocally_isLocal
    {P : AffineTargetMorphismProperty} (hP : P.IsLocal) :
    PropertyIsLocalAtTarget (targetAffineLocally P) := by
  have := hP.1
  constructor
  ¬∑ infer_instance
  ¬∑ intro X Y f U H V
    rw [‚Üê P.toProperty_apply (i := V.2),
      P.toProperty.arrow_mk_iso_iff (morphismRestrictRestrict f _ _)]
    convert H ‚ü®_, V.2.image_of_isOpenImmersion (Y.ofRestrict _)‚ü©
    rw [‚Üê P.toProperty_apply]
  ¬∑ rintro X Y f ùí∞ hùí∞
    -- Porting note: rewrite `[(hP.affine_openCover_TFAE f).out 0 1` directly complains about
    -- metavariables
    have h01 := (hP.affine_openCover_TFAE f).out 0 1
    rw [h01]
    refine ‚ü®ùí∞.bind fun _ => Scheme.affineCover _, ?_, ?_‚ü©
    ¬∑ intro i; dsimp [Scheme.OpenCover.bind]; infer_instance
    ¬∑ intro i
      specialize hùí∞ i.1
      -- Porting note: rewrite `[(hP.affine_openCover_TFAE pullback.snd).out 0 1` directly
      -- complains about metavariables
      have h02 := (hP.affine_openCover_TFAE (pullback.snd : pullback f (ùí∞.map i.fst) ‚ü∂ _)).out 0 2
      rw [h02] at hùí∞
      specialize hùí∞ (Scheme.affineCover _) i.2
      let e : pullback f ((ùí∞.obj i.fst).affineCover.map i.snd ‚â´ ùí∞.map i.fst) ‚ü∂
          pullback (pullback.snd : pullback f (ùí∞.map i.fst) ‚ü∂ _)
            ((ùí∞.obj i.fst).affineCover.map i.snd) := by
        refine (pullbackSymmetry _ _).hom ‚â´ ?_
        refine (pullbackRightPullbackFstIso _ _ _).inv ‚â´ ?_
        refine (pullbackSymmetry _ _).hom ‚â´ ?_
        refine pullback.map _ _ _ _ (pullbackSymmetry _ _).hom (ùüô _) (ùüô _) ?_ ?_ <;>
        simp only [Category.comp_id, Category.id_comp, pullbackSymmetry_hom_comp_snd]
      rw [‚Üê P.cancel_left_of_respectsIso e] at hùí∞
      convert hùí∞ using 1
      simp [e]
#align algebraic_geometry.affine_target_morphism_property.is_local.target_affine_locally_is_local AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.targetAffineLocally_isLocal

open List in
theorem PropertyIsLocalAtTarget.openCover_TFAE {P : MorphismProperty Scheme}
    (hP : PropertyIsLocalAtTarget P) {X Y : Scheme.{u}} (f : X ‚ü∂ Y) :
    TFAE
      [P f,
        ‚àÉ ùí∞ : Scheme.OpenCover.{u} Y,
          ‚àÄ i : ùí∞.J, P (pullback.snd : (ùí∞.pullbackCover f).obj i ‚ü∂ ùí∞.obj i),
        ‚àÄ (ùí∞ : Scheme.OpenCover.{u} Y) (i : ùí∞.J),
          P (pullback.snd : (ùí∞.pullbackCover f).obj i ‚ü∂ ùí∞.obj i),
        ‚àÄ U : Opens Y.carrier, P (f ‚à£_ U),
        ‚àÄ {U : Scheme} (g : U ‚ü∂ Y) [IsOpenImmersion g], P (pullback.snd : pullback f g ‚ü∂ U),
        ‚àÉ (Œπ : Type u) (U : Œπ ‚Üí Opens Y.carrier) (_ : iSup U = ‚ä§), ‚àÄ i, P (f ‚à£_ U i)] := by
  have := hP.1
  tfae_have 2 ‚Üí 1
  ¬∑ rintro ‚ü®ùí∞, H‚ü©; exact hP.3 f ùí∞ H
  tfae_have 1 ‚Üí 4
  ¬∑ intro H U; exact hP.2 f U H
  tfae_have 4 ‚Üí 3
  ¬∑ intro H ùí∞ i
    rw [‚Üê P.arrow_mk_iso_iff (morphismRestrictOpensRange f _)]
    exact H <| Scheme.Hom.opensRange (ùí∞.map i)
  tfae_have 3 ‚Üí 2
  ¬∑ exact fun H => ‚ü®Y.affineCover, H Y.affineCover‚ü©
  tfae_have 4 ‚Üí 5
  ¬∑ intro H U g hg
    rw [‚Üê P.arrow_mk_iso_iff (morphismRestrictOpensRange f _)]
    apply H
  tfae_have 5 ‚Üí 4
  ¬∑ intro H U
    erw [P.cancel_left_of_respectsIso]
    apply H
  tfae_have 4 ‚Üí 6
  ¬∑ intro H; exact ‚ü®PUnit, fun _ => ‚ä§, ciSup_const, fun _ => H _‚ü©
  tfae_have 6 ‚Üí 2
  ¬∑ rintro ‚ü®Œπ, U, hU, H‚ü©
    refine ‚ü®Y.openCoverOfSuprEqTop U hU, ?_‚ü©
    intro i
    rw [‚Üê P.arrow_mk_iso_iff (morphismRestrictOpensRange f _)]
    convert H i
    all_goals ext1; exact Subtype.range_coe
  tfae_finish
#align algebraic_geometry.property_is_local_at_target.open_cover_tfae AlgebraicGeometry.PropertyIsLocalAtTarget.openCover_TFAE

theorem PropertyIsLocalAtTarget.openCover_iff {P : MorphismProperty Scheme}
    (hP : PropertyIsLocalAtTarget P) {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (ùí∞ : Scheme.OpenCover.{u} Y) :
    P f ‚Üî ‚àÄ i, P (pullback.snd : pullback f (ùí∞.map i) ‚ü∂ _) := by
  -- Porting note: couldn't get the term mode proof work
  refine ‚ü®fun H => let h := ((hP.openCover_TFAE f).out 0 2).mp H; fun i => ?_,
    fun H => let h := ((hP.openCover_TFAE f).out 1 0).mp; ?_‚ü©
  ¬∑ exact h ùí∞ i
  ¬∑ exact h ‚ü®ùí∞, H‚ü©
#align algebraic_geometry.property_is_local_at_target.open_cover_iff AlgebraicGeometry.PropertyIsLocalAtTarget.openCover_iff

namespace AffineTargetMorphismProperty

/-- A `P : AffineTargetMorphismProperty` is stable under base change if `P` holds for `Y ‚ü∂ S`
implies that `P` holds for `X √ó‚Çõ Y ‚ü∂ X` with `X` and `S` affine schemes. -/
def StableUnderBaseChange (P : AffineTargetMorphismProperty) : Prop :=
  ‚àÄ ‚¶ÉX Y S : Scheme‚¶Ñ [IsAffine S] [IsAffine X] (f : X ‚ü∂ S) (g : Y ‚ü∂ S),
    P g ‚Üí P (pullback.fst : pullback f g ‚ü∂ X)
#align algebraic_geometry.affine_target_morphism_property.stable_under_base_change AlgebraicGeometry.AffineTargetMorphismProperty.StableUnderBaseChange

theorem IsLocal.targetAffineLocally_pullback_fst_of_right_of_stableUnderBaseChange
    {P : AffineTargetMorphismProperty} (hP : P.IsLocal) (hP' : P.StableUnderBaseChange)
    {X Y S : Scheme} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) [IsAffine S] (H : P g) :
    targetAffineLocally P (pullback.fst : pullback f g ‚ü∂ X) := by
  have := hP.1
  -- Porting note: rewrite `(hP.affine_openCover_TFAE ...).out 0 1` doesn't work
  have h01 := (hP.affine_openCover_TFAE (pullback.fst : pullback f g ‚ü∂ X)).out 0 1
  rw [h01]
  use X.affineCover, inferInstance
  intro i
  let e := pullbackSymmetry _ _ ‚â™‚â´ pullbackRightPullbackFstIso f g (X.affineCover.map i)
  have : e.hom ‚â´ pullback.fst = pullback.snd := by simp [e]
  rw [‚Üê this, P.cancel_left_of_respectsIso]
  apply hP'; assumption
#align algebraic_geometry.affine_target_morphism_property.is_local.target_affine_locally_pullback_fst_of_right_of_stable_under_base_change AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.targetAffineLocally_pullback_fst_of_right_of_stableUnderBaseChange

theorem IsLocal.stableUnderBaseChange {P : AffineTargetMorphismProperty} (hP : P.IsLocal)
    (hP' : P.StableUnderBaseChange) : (targetAffineLocally P).StableUnderBaseChange :=
  have := hP.1
  MorphismProperty.StableUnderBaseChange.mk
    (fun X Y S f g H => by
      -- Porting note: rewrite `(...openCover_TFAE).out 0 1` directly doesn't work, complains about
      -- metavariable
      have h01 := (hP.targetAffineLocally_isLocal.openCover_TFAE
        (pullback.fst : pullback f g ‚ü∂ X)).out 0 1
      rw [h01]
      use S.affineCover.pullbackCover f
      intro i
      -- Porting note: rewrite `(hP.affine_openCover_TFAE g).out 0 3` directly doesn't work
      -- complains about metavariable
      have h03 := (hP.affine_openCover_TFAE g).out 0 3
      rw [h03] at H
      let e : pullback (pullback.fst : pullback f g ‚ü∂ _) ((S.affineCover.pullbackCover f).map i) ‚âÖ
          _ := by
        refine pullbackSymmetry _ _ ‚â™‚â´ pullbackRightPullbackFstIso f g _ ‚â™‚â´ ?_ ‚â™‚â´
          (pullbackRightPullbackFstIso (S.affineCover.map i) g
            (pullback.snd : pullback f (S.affineCover.map i) ‚ü∂ _)).symm
        exact asIso
          (pullback.map _ _ _ _ (ùüô _) (ùüô _) (ùüô _) (by simpa using pullback.condition) (by simp))
      have : e.hom ‚â´ pullback.fst = pullback.snd := by simp [e]
      rw [‚Üê this, (targetAffineLocally P).cancel_left_of_respectsIso]
      apply hP.targetAffineLocally_pullback_fst_of_right_of_stableUnderBaseChange hP'
      rw [‚Üê pullbackSymmetry_hom_comp_snd, P.cancel_left_of_respectsIso]
      apply H)
#align algebraic_geometry.affine_target_morphism_property.is_local.stable_under_base_change AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.stableUnderBaseChange

end AffineTargetMorphismProperty

namespace AffineTargetMorphismProperty.IsLocal

@[deprecated (since := "2024-06-22")]
alias targetAffineLocallyIsLocal := targetAffineLocally_isLocal

@[deprecated (since := "2024-06-22")]
alias targetAffineLocallyPullbackFstOfRightOfStableUnderBaseChange :=
  targetAffineLocally_pullback_fst_of_right_of_stableUnderBaseChange

end AffineTargetMorphismProperty.IsLocal

end AlgebraicGeometry
