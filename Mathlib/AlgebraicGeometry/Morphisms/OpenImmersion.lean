/-
Copyright (c) 2022 Andrew Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Andrew Yang
-/
module

public import Mathlib.AlgebraicGeometry.Morphisms.UnderlyingMap

/-!

# Open immersions

A morphism is an open immersion if the underlying map of spaces is an open embedding
`f : X ‚ü∂ U ‚äÜ Y`, and the sheaf map `Y(V) ‚ü∂ f _* X(V)` is an iso for each `V ‚äÜ U`.

Most of the theories are developed in `AlgebraicGeometry/OpenImmersion`, and we provide the
remaining theorems analogous to other lemmas in `AlgebraicGeometry/Morphisms/*`.

-/

@[expose] public section


noncomputable section

open CategoryTheory CategoryTheory.Limits Opposite TopologicalSpace Topology

universe u

namespace AlgebraicGeometry

/-- `Spec (R ‚ß∏ I) ‚ü∂ Spec R` is an open immersion iff `I` is generated by an idempotent. -/
lemma isOpenImmersion_SpecMap_iff_of_surjective {R S : CommRingCat}
    (f : R ‚ü∂ S) (hf : Function.Surjective f.hom) :
    IsOpenImmersion (Spec.map f) ‚Üî
    ‚àÉ e, IsIdempotentElem e ‚àß RingHom.ker f.hom = Ideal.span {e} := by
  constructor
  ¬∑ intro H
    obtain ‚ü®e, he, he'‚ü© := PrimeSpectrum.isClopen_iff_zeroLocus.mp
      ‚ü®PrimeSpectrum.isClosed_range_comap_of_surjective _ _ hf,
        (Spec.map f).isOpenEmbedding.isOpen_range‚ü©
    refine ‚ü®e, he, ?_‚ü©
    let œÜ : R ‚ü∂ _ := (CommRingCat.ofHom (Ideal.Quotient.mk (.span {e})))
    have : IsOpenImmersion (Spec.map œÜ) :=
      have : IsLocalization.Away (1 - e) (‚ÜëR ‚ß∏ Ideal.span {e}) :=
        IsLocalization.away_of_isIdempotentElem he.one_sub (by simp) Ideal.Quotient.mk_surjective
      IsOpenImmersion.of_isLocalization (1 - e)
    have H : Set.range (Spec.map œÜ) = Set.range (Spec.map f) :=
      ((range_comap_of_surjective _ _
        Ideal.Quotient.mk_surjective).trans (by simp)).trans he'.symm
    let i : S ‚âÖ .of _ := (Scheme.Spec.preimageIso
      (IsOpenImmersion.isoOfRangeEq (Spec.map œÜ) (Spec.map f) H)).unop
    have hi : Function.Injective i.inv.hom := (ConcreteCategory.bijective_of_isIso i.inv).1
    have : f = œÜ ‚â´ i.inv := by apply Spec.map_injective; simp [i, ‚Üê Scheme.Spec_map]
    rw [this, CommRingCat.hom_comp, RingHom.ker_eq_comap_bot, ‚Üê Ideal.comap_comap,
      ‚Üê RingHom.ker_eq_comap_bot, (RingHom.injective_iff_ker_eq_bot i.inv.hom).mp hi,
      ‚Üê RingHom.ker_eq_comap_bot]
    simp [œÜ]
  ¬∑ rintro ‚ü®e, he, he'‚ü©
    letI := f.hom.toAlgebra
    have : IsLocalization.Away (1 - e) S :=
      IsLocalization.away_of_isIdempotentElem he.one_sub (by simpa using he') hf
    exact IsOpenImmersion.of_isLocalization (1 - e)

variable {X Y : Scheme.{u}}

@[deprecated (since := "2026-01-20")]
alias isOpenImmersion_iff_stalk := IsOpenImmersion.iff_isIso_stalkMap

theorem IsOpenImmersion.of_openCover_source (f : X ‚ü∂ Y)
    (ùí∞ : X.OpenCover) (hf : Function.Injective f) (hùí∞ : ‚àÄ i, IsOpenImmersion (ùí∞.f i ‚â´ f)) :
    IsOpenImmersion f := by
  refine IsOpenImmersion.iff_isIso_stalkMap.mpr
    ‚ü®.of_continuous_injective_isOpenMap f.continuous hf ?_, ?_‚ü©
  ¬∑ intro U hU
    convert (‚®Ü i, ((ùí∞.f i ‚â´ f) ''·µÅ (ùí∞.f i ‚Åª¬π·µÅ ‚ü®U, hU‚ü©))).2
    ext x
    exact ‚ü®fun ‚ü®x, _, _‚ü© ‚Ü¶ by have := ùí∞.exists_eq x; simp; grind, by simp; grind‚ü©
  ¬∑ intro x
    obtain ‚ü®i, x, rfl‚ü© := ùí∞.exists_eq x
    rw [‚Üê (IsIso.comp_inv_eq _).mpr (Scheme.Hom.stalkMap_comp (ùí∞.f i) f x)]
    infer_instance

lemma IsOpenImmersion.of_forall_source_exists (f : X ‚ü∂ Y)
    (hf : Function.Injective f)
    (hX : ‚àÄ x, ‚àÉ (U : Scheme) (i : U ‚ü∂ X) (_ : IsOpenImmersion i),
      x ‚àà i.opensRange ‚àß IsOpenImmersion (i ‚â´ f)) :
    IsOpenImmersion f := by
  choose U i _ hxi hi using hX
  let ùí∞ : X.OpenCover := ‚ü®‚ü®X, U, i‚ü©,
    ‚ü®by simpa using show ‚àÄ x, ‚àÉ j y, i j y = x from (‚ü®_, hxi ¬∑‚ü©), by simpa‚ü©‚ü©
  exact IsOpenImmersion.of_openCover_source f ùí∞ hf hi

theorem isOpenImmersion_eq_inf :
    @IsOpenImmersion = (topologically IsOpenEmbedding) ‚äì stalkwise (Function.Bijective ¬∑) := by
  ext
  exact IsOpenImmersion.iff_isIso_stalkMap.trans
    (and_congr Iff.rfl (forall_congr' fun x ‚Ü¶ ConcreteCategory.isIso_iff_bijective _))

instance : IsZariskiLocalAtTarget (stalkwise (Function.Bijective ¬∑)) := by
  apply stalkwiseIsZariskiLocalAtTarget_of_respectsIso
  rw [RingHom.toMorphismProperty_respectsIso_iff]
  convert (inferInstanceAs (MorphismProperty.isomorphisms CommRingCat).RespectsIso)
  ext
  exact (ConcreteCategory.isIso_iff_bijective _).symm

instance isOpenImmersion_isZariskiLocalAtTarget : IsZariskiLocalAtTarget @IsOpenImmersion :=
  isOpenImmersion_eq_inf ‚ñ∏ inferInstance

instance {X Y X' Y' : Scheme.{u}}
    (f : X ‚ü∂ X') (g : Y ‚ü∂ Y') [IsOpenImmersion f] [IsOpenImmersion g] :
    IsOpenImmersion (coprod.map f g) :=
  IsZariskiLocalAtTarget.coprodMap f g ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫

end AlgebraicGeometry
