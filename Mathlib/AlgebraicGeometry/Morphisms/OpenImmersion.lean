/-
Copyright (c) 2022 Andrew Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Andrew Yang
-/
import Mathlib.AlgebraicGeometry.Morphisms.UnderlyingMap

/-!

# Open immersions

A morphism is an open immersion if the underlying map of spaces is an open embedding
`f : X âŸ¶ U âŠ† Y`, and the sheaf map `Y(V) âŸ¶ f _* X(V)` is an iso for each `V âŠ† U`.

Most of the theories are developed in `AlgebraicGeometry/OpenImmersion`, and we provide the
remaining theorems analogous to other lemmas in `AlgebraicGeometry/Morphisms/*`.

-/


noncomputable section

open CategoryTheory CategoryTheory.Limits Opposite TopologicalSpace Topology

universe u

namespace AlgebraicGeometry

/-- `Spec (R â§¸ I) âŸ¶ Spec R` is an open immersion iff `I` is generated by an idempotent. -/
lemma isOpenImmersion_SpecMap_iff_of_surjective {R S : CommRingCat}
    (f : R âŸ¶ S) (hf : Function.Surjective f.hom) :
    IsOpenImmersion (Spec.map f) â†”
    âˆƒ e, IsIdempotentElem e âˆ§ RingHom.ker f.hom = Ideal.span {e} := by
  constructor
  Â· intro H
    obtain âŸ¨e, he, he'âŸ© := PrimeSpectrum.isClopen_iff_zeroLocus.mp
      âŸ¨PrimeSpectrum.isClosed_range_comap_of_surjective _ _ hf,
        (Spec.map f).isOpenEmbedding.isOpen_rangeâŸ©
    refine âŸ¨e, he, ?_âŸ©
    let Ï† : R âŸ¶ _ := (CommRingCat.ofHom (Ideal.Quotient.mk (.span {e})))
    have : IsOpenImmersion (Spec.map Ï†) :=
      have : IsLocalization.Away (1 - e) (â†‘R â§¸ Ideal.span {e}) :=
        IsLocalization.away_of_isIdempotentElem he.one_sub (by simp) Ideal.Quotient.mk_surjective
      IsOpenImmersion.of_isLocalization (1 - e)
    have H : Set.range (Spec.map Ï†) = Set.range (Spec.map f) :=
      ((PrimeSpectrum.range_comap_of_surjective _ _
        Ideal.Quotient.mk_surjective).trans (by simp)).trans he'.symm
    let i : S â‰… .of _ := (Scheme.Spec.preimageIso
      (IsOpenImmersion.isoOfRangeEq (Spec.map Ï†) (Spec.map f) H)).unop
    have hi : Function.Injective i.inv.hom := (ConcreteCategory.bijective_of_isIso i.inv).1
    have : f = Ï† â‰« i.inv := by apply Spec.map_injective; simp [i, â† Scheme.Spec_map]
    rw [this, CommRingCat.hom_comp, RingHom.ker_eq_comap_bot, â† Ideal.comap_comap,
      â† RingHom.ker_eq_comap_bot, (RingHom.injective_iff_ker_eq_bot i.inv.hom).mp hi,
      â† RingHom.ker_eq_comap_bot]
    simp [Ï†]
  Â· rintro âŸ¨e, he, he'âŸ©
    letI := f.hom.toAlgebra
    have : IsLocalization.Away (1 - e) S :=
      IsLocalization.away_of_isIdempotentElem he.one_sub (by simpa using he') hf
    exact IsOpenImmersion.of_isLocalization (1 - e)

variable {X Y : Scheme.{u}}

theorem isOpenImmersion_iff_stalk {f : X âŸ¶ Y} : IsOpenImmersion f â†”
    IsOpenEmbedding f âˆ§ âˆ€ x, IsIso (f.stalkMap x) := IsOpenImmersion.iff_isIso_stalkMap f

theorem IsOpenImmersion.of_openCover_source (f : X âŸ¶ Y)
    (ğ’° : X.OpenCover) (hf : Function.Injective f) (hğ’° : âˆ€ i, IsOpenImmersion (ğ’°.f i â‰« f)) :
    IsOpenImmersion f := by
  refine isOpenImmersion_iff_stalk.mpr âŸ¨.of_continuous_injective_isOpenMap f.continuous hf ?_, ?_âŸ©
  Â· intro U hU
    convert (â¨† i, ((ğ’°.f i â‰« f) ''áµ (ğ’°.f i â»Â¹áµ âŸ¨U, hUâŸ©))).2
    ext x
    exact âŸ¨fun âŸ¨x, _, _âŸ© â†¦ by have := ğ’°.exists_eq x; simp; grind, by simp; grindâŸ©
  Â· intro x
    obtain âŸ¨i, x, rflâŸ© := ğ’°.exists_eq x
    rw [â† (IsIso.comp_inv_eq _).mpr (Scheme.Hom.stalkMap_comp (ğ’°.f i) f x)]
    infer_instance

lemma IsOpenImmersion.of_forall_source_exists (f : X âŸ¶ Y)
    (hf : Function.Injective f)
    (hX : âˆ€ x, âˆƒ (U : Scheme) (i : U âŸ¶ X) (_ : IsOpenImmersion i),
      x âˆˆ i.opensRange âˆ§ IsOpenImmersion (i â‰« f)) :
    IsOpenImmersion f := by
  choose U i _ hxi hi using hX
  let ğ’° : X.OpenCover := âŸ¨âŸ¨X, U, iâŸ©,
    âŸ¨by simpa using show âˆ€ x, âˆƒ j y, i j y = x from (âŸ¨_, hxi Â·âŸ©), by simpaâŸ©âŸ©
  exact IsOpenImmersion.of_openCover_source f ğ’° hf hi

theorem isOpenImmersion_eq_inf :
    @IsOpenImmersion = (topologically IsOpenEmbedding) âŠ“
      stalkwise (fun f â†¦ Function.Bijective f) := by
  ext
  exact isOpenImmersion_iff_stalk.trans
    (and_congr Iff.rfl (forall_congr' fun x â†¦ ConcreteCategory.isIso_iff_bijective _))

instance : IsZariskiLocalAtTarget (stalkwise (fun f â†¦ Function.Bijective f)) := by
  apply stalkwiseIsZariskiLocalAtTarget_of_respectsIso
  rw [RingHom.toMorphismProperty_respectsIso_iff]
  convert (inferInstanceAs (MorphismProperty.isomorphisms CommRingCat).RespectsIso)
  ext
  exact (ConcreteCategory.isIso_iff_bijective _).symm

instance isOpenImmersion_isZariskiLocalAtTarget : IsZariskiLocalAtTarget @IsOpenImmersion :=
  isOpenImmersion_eq_inf â–¸ inferInstance

end AlgebraicGeometry
