/-
Copyright (c) 2022 Andrew Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Andrew Yang
-/
import Mathlib.AlgebraicGeometry.Morphisms.UnderlyingMap

/-!

# Open immersions

A morphism is an open immersion if the underlying map of spaces is an open embedding
`f : X ‚ü∂ U ‚äÜ Y`, and the sheaf map `Y(V) ‚ü∂ f _* X(V)` is an iso for each `V ‚äÜ U`.

Most of the theories are developed in `AlgebraicGeometry/OpenImmersion`, and we provide the
remaining theorems analogous to other lemmas in `AlgebraicGeometry/Morphisms/*`.

-/


noncomputable section

open CategoryTheory CategoryTheory.Limits Opposite TopologicalSpace Topology

universe u

namespace AlgebraicGeometry

/-- `Spec (R ‚ß∏ I) ‚ü∂ Spec R` is an open immersion iff `I` is generated by an idempotent. -/
lemma isOpenImmersion_SpecMap_iff_of_surjective {R S : CommRingCat}
    (f : R ‚ü∂ S) (hf : Function.Surjective f.hom) :
    IsOpenImmersion (Spec.map f) ‚Üî
    ‚àÉ e, IsIdempotentElem e ‚àß RingHom.ker f.hom = Ideal.span {e} := by
  constructor
  ¬∑ intro H
    obtain ‚ü®e, he, he'‚ü© := PrimeSpectrum.isClopen_iff_zeroLocus.mp
      ‚ü®PrimeSpectrum.isClosed_range_comap_of_surjective _ _ hf,
        (Spec.map f).isOpenEmbedding.isOpen_range‚ü©
    refine ‚ü®e, he, ?_‚ü©
    let œÜ : R ‚ü∂ _ := (CommRingCat.ofHom (Ideal.Quotient.mk (.span {e})))
    have : IsOpenImmersion (Spec.map œÜ) :=
      have : IsLocalization.Away (1 - e) (‚ÜëR ‚ß∏ Ideal.span {e}) :=
        IsLocalization.away_of_isIdempotentElem he.one_sub (by simp) Ideal.Quotient.mk_surjective
      IsOpenImmersion.of_isLocalization (1 - e)
    have H : Set.range (Spec.map œÜ).base = Set.range (Spec.map f).base :=
      ((PrimeSpectrum.range_comap_of_surjective _ _
        Ideal.Quotient.mk_surjective).trans (by simp)).trans he'.symm
    let i : S ‚âÖ .of _ := (Scheme.Spec.preimageIso
      (IsOpenImmersion.isoOfRangeEq (Spec.map œÜ) (Spec.map f) H)).unop
    have hi : Function.Injective i.inv.hom := (ConcreteCategory.bijective_of_isIso i.inv).1
    have : f = œÜ ‚â´ i.inv := by apply Spec.map_injective; simp [i, ‚Üê Scheme.Spec_map]
    rw [this, CommRingCat.hom_comp, RingHom.ker_eq_comap_bot, ‚Üê Ideal.comap_comap,
      ‚Üê RingHom.ker_eq_comap_bot, (RingHom.injective_iff_ker_eq_bot i.inv.hom).mp hi,
      ‚Üê RingHom.ker_eq_comap_bot]
    simp [œÜ]
  ¬∑ rintro ‚ü®e, he, he'‚ü©
    letI := f.hom.toAlgebra
    have : IsLocalization.Away (1 - e) S :=
      IsLocalization.away_of_isIdempotentElem he.one_sub (by simpa using he') hf
    exact IsOpenImmersion.of_isLocalization (1 - e)

variable {X Y : Scheme.{u}}

theorem isOpenImmersion_iff_stalk {f : X ‚ü∂ Y} : IsOpenImmersion f ‚Üî
    IsOpenEmbedding f.base ‚àß ‚àÄ x, IsIso (f.stalkMap x) := IsOpenImmersion.iff_stalk_iso f

theorem IsOpenImmersion.of_openCover_source (f : X ‚ü∂ Y)
    (ùí∞ : X.OpenCover) (hf : Function.Injective f.base) (hùí∞ : ‚àÄ i, IsOpenImmersion (ùí∞.f i ‚â´ f)) :
    IsOpenImmersion f := by
  refine isOpenImmersion_iff_stalk.mpr ‚ü®.of_continuous_injective_isOpenMap f.continuous hf ?_, ?_‚ü©
  ¬∑ intro U hU
    convert (‚®Ü i, ((ùí∞.f i ‚â´ f) ''·µÅ (ùí∞.f i ‚Åª¬π·µÅ ‚ü®U, hU‚ü©))).2
    ext x
    simp only [Set.mem_image, TopologicalSpace.Opens.map_obj, TopologicalSpace.Opens.iSup_mk,
      TopologicalSpace.Opens.carrier_eq_coe, IsOpenMap.coe_functor_obj, Scheme.comp_coeBase,
      TopCat.hom_comp, ContinuousMap.comp_apply, TopologicalSpace.Opens.coe_mk, Set.mem_iUnion,
      Set.mem_preimage]
    constructor
    ¬∑ rintro ‚ü®x, hx, rfl‚ü©
      obtain ‚ü®i, x, rfl‚ü© := ùí∞.exists_eq x
      exact ‚ü®i, x, hx, rfl‚ü©
    ¬∑ rintro ‚ü®i, x, hx, rfl‚ü©
      exact ‚ü®_, hx, rfl‚ü©
  ¬∑ intro x
    obtain ‚ü®i, x, rfl‚ü© := ùí∞.exists_eq x
    rw [‚Üê (IsIso.comp_inv_eq _).mpr (Scheme.stalkMap_comp (ùí∞.f i) f x)]
    infer_instance

lemma IsOpenImmersion.of_forall_source_exists (f : X ‚ü∂ Y)
    (hf : Function.Injective f.base)
    (hX : ‚àÄ x, ‚àÉ (U : Scheme) (i : U ‚ü∂ X) (_ : IsOpenImmersion i),
      x ‚àà i.opensRange ‚àß IsOpenImmersion (i ‚â´ f)) :
    IsOpenImmersion f := by
  choose U i _ hxi hi using hX
  let ùí∞ : X.OpenCover := ‚ü®‚ü®X, U, i‚ü©,
    ‚ü®by simpa using show ‚àÄ x, ‚àÉ j y, (i j).base y = x from (‚ü®_, hxi ¬∑‚ü©), by simpa‚ü©‚ü©
  exact IsOpenImmersion.of_openCover_source f ùí∞ hf hi

theorem isOpenImmersion_eq_inf :
    @IsOpenImmersion = (topologically IsOpenEmbedding) ‚äì
      stalkwise (fun f ‚Ü¶ Function.Bijective f) := by
  ext
  exact isOpenImmersion_iff_stalk.trans
    (and_congr Iff.rfl (forall_congr' fun x ‚Ü¶ ConcreteCategory.isIso_iff_bijective _))

instance : IsLocalAtTarget (stalkwise (fun f ‚Ü¶ Function.Bijective f)) := by
  apply stalkwiseIsLocalAtTarget_of_respectsIso
  rw [RingHom.toMorphismProperty_respectsIso_iff]
  convert (inferInstanceAs (MorphismProperty.isomorphisms CommRingCat).RespectsIso)
  ext
  exact (ConcreteCategory.isIso_iff_bijective _).symm

instance isOpenImmersion_isLocalAtTarget : IsLocalAtTarget @IsOpenImmersion :=
  isOpenImmersion_eq_inf ‚ñ∏ inferInstance

end AlgebraicGeometry
