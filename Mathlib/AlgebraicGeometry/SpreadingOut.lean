/-
Copyright (c) 2024 Andrew Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Andrew Yang
-/
import Mathlib.AlgebraicGeometry.Morphisms.FiniteType
import Mathlib.AlgebraicGeometry.Noetherian
import Mathlib.AlgebraicGeometry.Stalk
import Mathlib.AlgebraicGeometry.Properties

/-!
# Spreading out morphisms

Under certain conditions, a morphism on stalks `Spec ùí™_{X, x} ‚ü∂ Spec ùí™_{Y, y}` can be spread
out into a neighborhood of `x`.

## Main result
Given `S`-schemes `X Y` and points `x : X` `y : Y` over `s : S`.
Suppose we have the following diagram of `S`-schemes
```
Spec ùí™_{X, x} ‚ü∂ X
    |
  Spec(œÜ)
    ‚Üì
Spec ùí™_{Y, y} ‚ü∂ Y
```
We would like to spread `Spec(œÜ)` out to an `S`-morphism on an open subscheme `U ‚äÜ X`
```
Spec ùí™_{X, x} ‚ü∂ U ‚äÜ X
    |             |
  Spec(œÜ)         |
    ‚Üì             ‚Üì
Spec ùí™_{Y, y} ‚ü∂ Y
```
- `AlgebraicGeometry.spread_out_unique_of_isGermInjective`:
  The lift is "unique" if the germ map is injective at `x`.
- `AlgebraicGeometry.spread_out_of_isGermInjective`:
  The lift exists if `Y` is locally of finite type and the germ map is injective at `x`.

## TODO

Show that certain morphism properties can also be spread out.

-/

universe u

open CategoryTheory

namespace AlgebraicGeometry

variable {X Y S : Scheme.{u}} (f : X ‚ü∂ Y) (sX : X ‚ü∂ S) (sY : Y ‚ü∂ S) {R A : CommRingCat.{u}}

/-- The germ map at `x` is injective if there exists some affine `U ‚àã x`
  such that the map `Œì(X, U) ‚ü∂ X_x` is injective -/
class Scheme.IsGermInjectiveAt (X : Scheme.{u}) (x : X) : Prop where
  cond : ‚àÉ (U : X.Opens) (hx : x ‚àà U), IsAffineOpen U ‚àß Function.Injective (X.presheaf.germ U x hx)

lemma injective_germ_basicOpen (U : X.Opens) (hU : IsAffineOpen U)
    (x : X) (hx : x ‚àà U) (f : Œì(X, U))
    (hf : x ‚àà X.basicOpen f)
    (H : Function.Injective (X.presheaf.germ U x hx)) :
      Function.Injective (X.presheaf.germ (X.basicOpen f) x hf) := by
  rw [RingHom.injective_iff_ker_eq_bot, RingHom.ker_eq_bot_iff_eq_zero] at H ‚ä¢
  intros t ht
  have := hU.isLocalization_basicOpen f
  obtain ‚ü®t, s, rfl‚ü© := IsLocalization.mk'_surjective (.powers f) t
  rw [‚Üê RingHom.mem_ker, IsLocalization.mk'_eq_mul_mk'_one, Ideal.mul_unit_mem_iff_mem,
    RingHom.mem_ker, RingHom.algebraMap_toAlgebra, CommRingCat.germ_res_apply] at ht
  swap; ¬∑ exact @isUnit_of_invertible _ _ _ (@IsLocalization.invertible_mk'_one ..)
  rw [H _ ht, IsLocalization.mk'_zero]

lemma Scheme.exists_germ_injective (X : Scheme.{u}) (x : X) [X.IsGermInjectiveAt x] :
    ‚àÉ (U : X.Opens) (hx : x ‚àà U),
        IsAffineOpen U ‚àß Function.Injective (X.presheaf.germ U x hx) :=
  Scheme.IsGermInjectiveAt.cond

lemma Scheme.exists_le_and_germ_injective (X : Scheme.{u}) (x : X) [X.IsGermInjectiveAt x]
    (V : X.Opens) (hxV : x ‚àà V) :
    ‚àÉ (U : X.Opens) (hx : x ‚àà U),
        IsAffineOpen U ‚àß U ‚â§ V ‚àß Function.Injective (X.presheaf.germ U x hx) := by
  obtain ‚ü®U, hx, hU, H‚ü© := Scheme.IsGermInjectiveAt.cond (x := x)
  obtain ‚ü®f, hf, hxf‚ü© := hU.exists_basicOpen_le ‚ü®x, hxV‚ü© hx
  exact ‚ü®X.basicOpen f, hxf, hU.basicOpen f, hf, injective_germ_basicOpen U hU x hx f hxf H‚ü©

instance (x : X) [X.IsGermInjectiveAt x] [IsOpenImmersion f] :
    Y.IsGermInjectiveAt (f.base x) := by
  obtain ‚ü®U, hxU, hU, H‚ü© := X.exists_germ_injective x
  refine ‚ü®‚ü®f ''·µÅ U, ‚ü®x, hxU, rfl‚ü©, hU.image_of_isOpenImmersion f, ?_‚ü©‚ü©
  refine ((MorphismProperty.injective CommRingCat).cancel_right_of_respectsIso _
    (f.stalkMap x)).mp ?_
  refine ((MorphismProperty.injective CommRingCat).cancel_left_of_respectsIso
    (f.appIso U).inv _).mp ?_
  simpa

variable {f} in
lemma isGermInjectiveAt_iff_of_isOpenImmersion {x : X} [IsOpenImmersion f]:
    Y.IsGermInjectiveAt (f.base x) ‚Üî X.IsGermInjectiveAt x := by
  refine ‚ü®fun H ‚Ü¶ ?_, fun _ ‚Ü¶ inferInstance‚ü©
  obtain ‚ü®U, hxU, hU, hU', H‚ü© :=
    Y.exists_le_and_germ_injective (f.base x) (V := f.opensRange) ‚ü®x, rfl‚ü©
  obtain ‚ü®V, hV‚ü© := (IsOpenImmersion.affineOpensEquiv f).surjective ‚ü®‚ü®U, hU‚ü©, hU'‚ü©
  obtain rfl : f ''·µÅ V = U := Subtype.eq_iff.mp (Subtype.eq_iff.mp hV)
  obtain ‚ü®y, hy, e : f.base y = f.base x‚ü© := hxU
  obtain rfl := f.isOpenEmbedding.injective e
  refine ‚ü®V, hy, V.2, ?_‚ü©
  replace H := ((MorphismProperty.injective CommRingCat).cancel_right_of_respectsIso _
    (f.stalkMap y)).mpr H
  replace H := ((MorphismProperty.injective CommRingCat).cancel_left_of_respectsIso
    (f.appIso V).inv _).mpr H
  simpa using H

/--
The class of schemes such that for each `x : X`,
`Œì(X, U) ‚ü∂ X_x` is injective for some affine `U` containing `x`.

This is typically satisfied when `X` is integral or locally noetherian.
-/
abbrev Scheme.IsGermInjective (X : Scheme.{u}) := ‚àÄ x : X, X.IsGermInjectiveAt x

lemma Scheme.IsGermInjective.of_openCover
    {X : Scheme.{u}} (ùí∞ : X.OpenCover) [‚àÄ i, (ùí∞.obj i).IsGermInjective] : X.IsGermInjective := by
  intro x
  rw [‚Üê (ùí∞.covers x).choose_spec]
  infer_instance

protected
lemma Scheme.IsGermInjective.Spec
    (H : ‚àÄ I : Ideal R, I.IsPrime ‚Üí ‚àÉ f : R, f ‚àâ I ‚àß ‚àÄ (x y : R)
        (_ : y * x = 0) (_ : y ‚àâ I), ‚àÉ n, f ^ n * x = 0) : (Spec R).IsGermInjective := by
  refine fun p ‚Ü¶ ‚ü®?_‚ü©
  obtain ‚ü®f, hf, H‚ü© := H p.asIdeal p.2
  refine ‚ü®PrimeSpectrum.basicOpen f, hf, ?_, ?_‚ü©
  ¬∑ rw [‚Üê basicOpen_eq_of_affine]
    exact (isAffineOpen_top (Spec R)).basicOpen _
  rw [RingHom.injective_iff_ker_eq_bot, RingHom.ker_eq_bot_iff_eq_zero]
  intro x hx
  obtain ‚ü®x, s, rfl‚ü© := IsLocalization.mk'_surjective
    (S := ((Spec.structureSheaf R).val.obj (.op <| PrimeSpectrum.basicOpen f))) (.powers f) x
  rw [‚Üê RingHom.mem_ker, IsLocalization.mk'_eq_mul_mk'_one, Ideal.mul_unit_mem_iff_mem,
    RingHom.mem_ker, RingHom.algebraMap_toAlgebra] at hx
  swap; ¬∑ exact @isUnit_of_invertible _ _ _ (@IsLocalization.invertible_mk'_one ..)
  erw [StructureSheaf.germ_toOpen] at hx
  obtain ‚ü®‚ü®y, hy‚ü©, hy'‚ü© := (IsLocalization.map_eq_zero_iff p.asIdeal.primeCompl
    ((Spec.structureSheaf R).presheaf.stalk p) _).mp hx
  obtain ‚ü®n, hn‚ü© := H x y hy' hy
  refine (@IsLocalization.mk'_eq_zero_iff ..).mpr ?_
  exact ‚ü®‚ü®_, n, rfl‚ü©, hn‚ü©

instance (priority := 100) [IsIntegral X] : X.IsGermInjective := by
  refine fun x ‚Ü¶ ‚ü®‚ü®(X.affineCover.map x).opensRange, X.affineCover.covers x,
    (isAffineOpen_opensRange (X.affineCover.map x)), ?_‚ü©‚ü©
  have : Nonempty (X.affineCover.map x).opensRange := ‚ü®‚ü®_, X.affineCover.covers x‚ü©‚ü©
  have := (isAffineOpen_opensRange (X.affineCover.map x)).isLocalization_stalk
    ‚ü®_, X.affineCover.covers x‚ü©
  exact @IsLocalization.injective _ _ _ _ _ (show _ from _) this
    (Ideal.primeCompl_le_nonZeroDivisors _)

instance (priority := 100) [IsLocallyNoetherian X] : X.IsGermInjective := by
  suffices ‚àÄ (R : CommRingCat.{u}) (_ : IsNoetherianRing R), (Spec R).IsGermInjective by
    refine @Scheme.IsGermInjective.of_openCover _ (X.affineOpenCover.openCover) (fun i ‚Ü¶ this _ ?_)
    have := isLocallyNoetherian_of_isOpenImmersion (X.affineOpenCover.map i)
    infer_instance
  refine fun R hR ‚Ü¶ Scheme.IsGermInjective.Spec fun I hI ‚Ü¶ ?_
  let J := RingHom.ker <| algebraMap R (Localization.AtPrime I)
  have hJ (x) : x ‚àà J ‚Üî ‚àÉ y : I.primeCompl, y * x = 0 :=
    IsLocalization.map_eq_zero_iff I.primeCompl _ x
  choose f hf using fun x ‚Ü¶ (hJ x).mp
  obtain ‚ü®s, hs‚ü© := (isNoetherianRing_iff_ideal_fg R).mp ‚Äπ_‚Ä∫ J
  have hs' : (s : Set R) ‚äÜ J := hs ‚ñ∏ Ideal.subset_span
  refine ‚ü®_, (s.attach.prod fun x ‚Ü¶ f x (hs' x.2)).2, fun x y e hy ‚Ü¶ ‚ü®1, ?_‚ü©‚ü©
  rw [pow_one, mul_comm, ‚Üê smul_eq_mul, ‚Üê Submodule.mem_annihilator_span_singleton]
  refine SetLike.le_def.mp ?_ ((hJ x).mpr ‚ü®‚ü®y, hy‚ü©, e‚ü©)
  rw [‚Üê hs, Ideal.span_le]
  intro i hi
  rw [SetLike.mem_coe, Submodule.mem_annihilator_span_singleton, smul_eq_mul,
    mul_comm, ‚Üê smul_eq_mul, ‚Üê Submodule.mem_annihilator_span_singleton, Submonoid.coe_finset_prod]
  refine Ideal.mem_of_dvd _ (Finset.dvd_prod_of_mem _ (s.mem_attach ‚ü®i, hi‚ü©)) ?_
  rw [Submodule.mem_annihilator_span_singleton, smul_eq_mul]
  exact hf i _

/--
Let `x : X` and `f g : X ‚ü∂ Y` be two morphisms such that `f x = g x`.
If `f` and `g` agree on the stalk of `x`, then they agree on an open neighborhood of `x`,
provided `X` is "germ-injective" at `x` (e.g. when it's integral or locally noetherian).

TODO: The condition on `X` is unnecessary when `Y` is locally of finite type.
-/
@[stacks 0BX6]
lemma spread_out_unique_of_isGermInjective {x : X} [X.IsGermInjectiveAt x]
    (f g : X ‚ü∂ Y) (e : f.base x = g.base x)
    (H : f.stalkMap x =
      Y.presheaf.stalkSpecializes (Inseparable.of_eq e.symm).specializes ‚â´ g.stalkMap x) :
    ‚àÉ (U : X.Opens), x ‚àà U ‚àß U.Œπ ‚â´ f = U.Œπ ‚â´ g := by
  obtain ‚ü®_, ‚ü®V : Y.Opens, hV, rfl‚ü©, hxV, -‚ü© :=
    (isBasis_affine_open Y).exists_subset_of_mem_open (Set.mem_univ (f.base x)) isOpen_univ
  have hxV' : g.base x ‚àà V := e ‚ñ∏ hxV
  obtain ‚ü®U, hxU, _, hUV, HU‚ü© := X.exists_le_and_germ_injective x (f ‚Åª¬π·µÅ V ‚äì g ‚Åª¬π·µÅ V) ‚ü®hxV, hxV'‚ü©
  refine ‚ü®U, hxU, ?_‚ü©
  rw [‚Üê Scheme.Hom.resLE_comp_Œπ _ (hUV.trans inf_le_left),
    ‚Üê Scheme.Hom.resLE_comp_Œπ _ (hUV.trans inf_le_right)]
  congr 1
  have : IsAffine V := hV
  suffices ‚àÄ (U‚ÇÄ V‚ÇÄ) (eU : U = U‚ÇÄ) (eV : V = V‚ÇÄ),
      f.appLE V‚ÇÄ U‚ÇÄ (eU ‚ñ∏ eV ‚ñ∏ hUV.trans inf_le_left) =
        g.appLE V‚ÇÄ U‚ÇÄ (eU ‚ñ∏ eV ‚ñ∏ hUV.trans inf_le_right) by
    rw [‚Üê cancel_mono V.toScheme.isoSpec.hom]
    simp only [Scheme.isoSpec, asIso_hom, Scheme.toSpecŒì_naturality,
      Scheme.Hom.app_eq_appLE, Scheme.Hom.resLE_appLE]
    congr 2
    apply this <;> simp
  rintro U V rfl rfl
  have := ConcreteCategory.mono_of_injective (C := CommRingCat) _ HU
  rw [‚Üê cancel_mono (X.presheaf.germ U x hxU)]
  simp only [Scheme.Hom.appLE, Category.assoc, X.presheaf.germ_res', ‚Üê Scheme.stalkMap_germ, H]
  simp only [TopCat.Presheaf.germ_stalkSpecializes_assoc, Scheme.stalkMap_germ]

/--
A variant of `spread_out_unique_of_isGermInjective`
whose condition is an equality of scheme morphisms instead of ring homomorphisms.
-/
lemma spread_out_unique_of_isGermInjective' {x : X} [X.IsGermInjectiveAt x]
    (f g : X ‚ü∂ Y)
    (e : X.fromSpecStalk x ‚â´ f = X.fromSpecStalk x ‚â´ g) :
    ‚àÉ (U : X.Opens), x ‚àà U ‚àß U.Œπ ‚â´ f = U.Œπ ‚â´ g := by
  fapply spread_out_unique_of_isGermInjective
  ¬∑ simpa using congr(($e).base (IsLocalRing.closedPoint _))
  ¬∑ apply Spec.map_injective
    rw [‚Üê cancel_mono (Y.fromSpecStalk _)]
    simpa [Scheme.Spec_map_stalkSpecializes_fromSpecStalk]

lemma exists_lift_of_germInjective_aux {U : X.Opens} {x : X} (hxU)
    (œÜ : A ‚ü∂ X.presheaf.stalk x) (œÜRA : R ‚ü∂ A) (œÜRX : R ‚ü∂ Œì(X, U))
    (hœÜRA : RingHom.FiniteType œÜRA.hom)
    (e : œÜRA ‚â´ œÜ = œÜRX ‚â´ X.presheaf.germ U x hxU) :
    ‚àÉ (V : X.Opens) (hxV : x ‚àà V),
      V ‚â§ U ‚àß RingHom.range œÜ.hom ‚â§ RingHom.range (X.presheaf.germ V x hxV).hom := by
  letI := œÜRA.hom.toAlgebra
  obtain ‚ü®s, hs‚ü© := hœÜRA
  choose W hxW f hf using fun t ‚Ü¶ X.presheaf.germ_exist x (œÜ t)
  have H : x ‚àà s.inf W ‚äì U := by
    rw [‚Üê SetLike.mem_coe, TopologicalSpace.Opens.coe_inf, TopologicalSpace.Opens.coe_finset_inf]
    exact ‚ü®by simpa using fun x _ ‚Ü¶ hxW x, hxU‚ü©
  refine ‚ü®s.inf W ‚äì U, H, inf_le_right, ?_‚ü©
  letI := œÜRX.hom.toAlgebra
  letI := (œÜRX ‚â´ X.presheaf.germ U x hxU).hom.toAlgebra
  letI := (œÜRX ‚â´ X.presheaf.map (homOfLE (inf_le_right (a := s.inf W))).op).hom.toAlgebra
  let œÜ' : A ‚Üí‚Çê[R] X.presheaf.stalk x :=
    { œÜ.hom with commutes' := DFunLike.congr_fun (congr_arg CommRingCat.Hom.hom e) }
  let œà : Œì(X, s.inf W ‚äì U) ‚Üí‚Çê[R] X.presheaf.stalk x :=
    { (X.presheaf.germ _ x H).hom with commutes' := fun x ‚Ü¶ X.presheaf.germ_res_apply _ _ _ _ }
  show AlgHom.range œÜ' ‚â§ AlgHom.range œà
  rw [‚Üê Algebra.map_top, ‚Üê hs, AlgHom.map_adjoin, Algebra.adjoin_le_iff]
  rintro _ ‚ü®i, hi, rfl : œÜ i = _‚ü©
  refine ‚ü®X.presheaf.map (homOfLE (inf_le_left.trans (Finset.inf_le hi))).op (f i), ?_‚ü©
  exact (X.presheaf.germ_res_apply _ _ _ _).trans (hf _)

/--
Suppose `X` is a scheme, `x : X` such that the germ map at `x` is (locally) injective,
and `U` is a neighborhood of `x`.
Given a commutative diagram of `CommRingCat`
```
R ‚ü∂ Œì(X, U)
‚Üì    ‚Üì
A ‚ü∂ ùí™_{X, x}
```
such that `R` is of finite type over `A`, we may lift `A ‚ü∂ ùí™_{X, x}` to some `A ‚ü∂ Œì(X, V)`.
-/
lemma exists_lift_of_germInjective {x : X} [X.IsGermInjectiveAt x] {U : X.Opens} (hxU : x ‚àà U)
    (œÜ : A ‚ü∂ X.presheaf.stalk x) (œÜRA : R ‚ü∂ A) (œÜRX : R ‚ü∂ Œì(X, U))
    (hœÜRA : RingHom.FiniteType œÜRA.hom)
    (e : œÜRA ‚â´ œÜ = œÜRX ‚â´ X.presheaf.germ U x hxU) :
    ‚àÉ (V : X.Opens) (hxV : x ‚àà V) (œÜ' : A ‚ü∂ Œì(X, V)) (i : V ‚â§ U), IsAffineOpen V ‚àß
      œÜ = œÜ' ‚â´ X.presheaf.germ V x hxV ‚àß œÜRX ‚â´ X.presheaf.map i.hom.op = œÜRA ‚â´ œÜ' := by
  obtain ‚ü®V, hxV, iVU, hV‚ü© := exists_lift_of_germInjective_aux hxU œÜ œÜRA œÜRX hœÜRA e
  obtain ‚ü®V', hxV', hV', iV'V, H‚ü© := X.exists_le_and_germ_injective x V hxV
  let f := X.presheaf.germ V' x hxV'
  have hf' : RingHom.range (X.presheaf.germ V x hxV).hom ‚â§ RingHom.range f.hom := by
    rw [‚Üê X.presheaf.germ_res iV'V.hom _ hxV']
    exact Set.range_comp_subset_range (X.presheaf.map iV'V.hom.op) f
  let e := RingEquiv.ofLeftInverse H.hasLeftInverse.choose_spec
  refine ‚ü®V', hxV', CommRingCat.ofHom (e.symm.toRingHom.comp
    (œÜ.hom.codRestrict _ (fun x ‚Ü¶ hf' (hV ‚ü®x, rfl‚ü©)))), iV'V.trans iVU, hV', ?_, ?_‚ü©
  ¬∑ ext a
    show œÜ a = (e (e.symm _)).1
    simp only [RingEquiv.apply_symm_apply]
    rfl
  ¬∑ ext a
    apply e.injective
    show e _ = e (e.symm _)
    rw [RingEquiv.apply_symm_apply]
    ext
    show X.presheaf.germ _ _ _ (X.presheaf.map _ _) = (œÜRA ‚â´ œÜ) a
    rw [CommRingCat.germ_res_apply, ‚ÄπœÜRA ‚â´ œÜ = _‚Ä∫]
    rfl

/--
Given `S`-schemes `X Y` and points `x : X` `y : Y` over `s : S`.
Suppose we have the following diagram of `S`-schemes
```
Spec ùí™_{X, x} ‚ü∂ X
    |
  Spec(œÜ)
    ‚Üì
Spec ùí™_{Y, y} ‚ü∂ Y
```
Then the map `Spec(œÜ)` spreads out to an `S`-morphism on an open subscheme `U ‚äÜ X`,
```
Spec ùí™_{X, x} ‚ü∂ U ‚äÜ X
    |             |
  Spec(œÜ)         |
    ‚Üì             ‚Üì
Spec ùí™_{Y, y} ‚ü∂ Y
```
provided that `Y` is locally of finite type over `S` and
`X` is "germ-injective" at `x` (e.g. when it's integral or locally noetherian).

TODO: The condition on `X` is unnecessary when `Y` is locally of finite presentation.
-/
@[stacks 0BX6]
lemma spread_out_of_isGermInjective [LocallyOfFiniteType sY] {x : X} [X.IsGermInjectiveAt x] {y : Y}
    (e : sX.base x = sY.base y) (œÜ : Y.presheaf.stalk y ‚ü∂ X.presheaf.stalk x)
    (h : sY.stalkMap y ‚â´ œÜ =
      S.presheaf.stalkSpecializes (Inseparable.of_eq e).specializes ‚â´ sX.stalkMap x) :
    ‚àÉ (U : X.Opens) (hxU : x ‚àà U) (f : U.toScheme ‚ü∂ Y),
      Spec.map œÜ ‚â´ Y.fromSpecStalk y = U.fromSpecStalkOfMem x hxU ‚â´ f ‚àß
      f ‚â´ sY = U.Œπ ‚â´ sX := by
  obtain ‚ü®_, ‚ü®U, hU, rfl‚ü©, hxU, -‚ü© :=
    (isBasis_affine_open S).exists_subset_of_mem_open (Set.mem_univ (sX.base x)) isOpen_univ
  have hyU : sY.base y ‚àà U := e ‚ñ∏ hxU
  obtain ‚ü®_, ‚ü®V : Y.Opens, hV, rfl‚ü©, hyV, iVU‚ü© :=
    (isBasis_affine_open Y).exists_subset_of_mem_open hyU (sY ‚Åª¬π·µÅ U).2
  have : sY.appLE U V iVU ‚â´ Y.presheaf.germ V y hyV ‚â´ œÜ =
      sX.app U ‚â´ X.presheaf.germ (sX ‚Åª¬π·µÅ U) x hxU := by
    rw [Scheme.Hom.appLE, Category.assoc, Y.presheaf.germ_res_assoc,
      ‚Üê Scheme.stalkMap_germ_assoc, h]
    simp
  obtain ‚ü®W, hxW, œÜ', i, hW, h‚ÇÅ, h‚ÇÇ‚ü© :=
    exists_lift_of_germInjective (R := Œì(S, U)) (A := Œì(Y, V)) (U := sX ‚Åª¬π·µÅ U) (x := x) hxU
    (Y.presheaf.germ _ y hyV ‚â´ œÜ) (sY.appLE U V iVU) (sX.app U)
    (LocallyOfFiniteType.finiteType_of_affine_subset ‚ü®_, hU‚ü© ‚ü®_, hV‚ü© _) this
  refine ‚ü®W, hxW, W.toSpecŒì ‚â´ Spec.map œÜ' ‚â´ hV.fromSpec, ?_, ?_‚ü©
  ¬∑ rw [W.fromSpecStalkOfMem_toSpecŒì_assoc x hxW, ‚Üê Spec.map_comp_assoc, ‚Üê h‚ÇÅ,
      Spec.map_comp, Category.assoc, ‚Üê IsAffineOpen.fromSpecStalk,
      IsAffineOpen.fromSpecStalk_eq_fromSpecStalk]
  ¬∑ simp only [Category.assoc, IsAffineOpen.isoSpec_inv_Œπ_assoc]
    rw [‚Üê IsAffineOpen.Spec_map_appLE_fromSpec sY hU hV iVU, ‚Üê Spec.map_comp_assoc, ‚Üê h‚ÇÇ,
      ‚Üê Scheme.Hom.appLE, ‚Üê hW.isoSpec_hom, IsAffineOpen.Spec_map_appLE_fromSpec sX hU hW i,
      ‚Üê Iso.eq_inv_comp, IsAffineOpen.isoSpec_inv_Œπ_assoc]

/--
Given `S`-schemes `X Y`, a point `x : X`, and a `S`-morphism `œÜ : Spec ùí™_{X, x} ‚ü∂ Y`,
we may spread it out to an `S`-morphism `f : U ‚ü∂ Y`
provided that `Y` is locally of finite type over `S` and
`X` is "germ-injective" at `x` (e.g. when it's integral or locally noetherian).

TODO: The condition on `X` is unnecessary when `Y` is locally of finite presentation.
-/
lemma spread_out_of_isGermInjective' [LocallyOfFiniteType sY] {x : X} [X.IsGermInjectiveAt x]
    (œÜ : Spec (X.presheaf.stalk x) ‚ü∂ Y)
    (h : œÜ ‚â´ sY = X.fromSpecStalk x ‚â´ sX) :
    ‚àÉ (U : X.Opens) (hxU : x ‚àà U) (f : U.toScheme ‚ü∂ Y),
      œÜ = U.fromSpecStalkOfMem x hxU ‚â´ f ‚àß f ‚â´ sY = U.Œπ ‚â´ sX := by
  have := spread_out_of_isGermInjective sX sY ?_ (Scheme.stalkClosedPointTo œÜ) ?_
  ¬∑ simpa only [Scheme.Spec_stalkClosedPointTo_fromSpecStalk] using this
  ¬∑ rw [‚Üê Scheme.comp_base_apply, h, Scheme.comp_base_apply, Scheme.fromSpecStalk_closedPoint]
  ¬∑ apply Spec.map_injective
    rw [‚Üê cancel_mono (S.fromSpecStalk _)]
    simpa only [Spec.map_comp, Category.assoc, Scheme.Spec_map_stalkMap_fromSpecStalk,
      Scheme.Spec_stalkClosedPointTo_fromSpecStalk_assoc,
      Scheme.Spec_map_stalkSpecializes_fromSpecStalk]

end AlgebraicGeometry
