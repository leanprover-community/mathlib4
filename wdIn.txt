Content-Length: 5893

{"jsonrpc":"2.0","id":0,"method":"initialize","params":{"processId":9416,"clientInfo":{"name":"Visual Studio Code","version":"1.84.2"},"locale":"en-us","rootPath":"c:\\Users\\Xavier Xarles\\mathlib4\\mathlib4","rootUri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4","capabilities":{"workspace":{"applyEdit":true,"workspaceEdit":{"documentChanges":true,"resourceOperations":["create","rename","delete"],"failureHandling":"textOnlyTransactional","normalizesLineEndings":true,"changeAnnotationSupport":{"groupsOnLabel":true}},"configuration":true,"didChangeWatchedFiles":{"dynamicRegistration":true,"relativePatternSupport":true},"symbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"tagSupport":{"valueSet":[1]},"resolveSupport":{"properties":["location.range"]}},"codeLens":{"refreshSupport":true},"executeCommand":{"dynamicRegistration":true},"didChangeConfiguration":{"dynamicRegistration":true},"semanticTokens":{"refreshSupport":true},"fileOperations":{"dynamicRegistration":true,"didCreate":true,"didRename":true,"didDelete":true,"willCreate":true,"willRename":true,"willDelete":true},"inlineValue":{"refreshSupport":true},"inlayHint":{"refreshSupport":true},"diagnostics":{"refreshSupport":true}},"textDocument":{"publishDiagnostics":{"relatedInformation":true,"versionSupport":false,"tagSupport":{"valueSet":[1,2]},"codeDescriptionSupport":true,"dataSupport":true},"synchronization":{"dynamicRegistration":true,"willSave":true,"willSaveWaitUntil":true,"didSave":true},"completion":{"dynamicRegistration":true,"contextSupport":true,"completionItem":{"snippetSupport":true,"commitCharactersSupport":true,"documentationFormat":["markdown","plaintext"],"deprecatedSupport":true,"preselectSupport":true,"tagSupport":{"valueSet":[1]},"insertReplaceSupport":true,"resolveSupport":{"properties":["documentation","detail","additionalTextEdits"]},"insertTextModeSupport":{"valueSet":[1,2]},"labelDetailsSupport":true},"insertTextMode":2,"completionItemKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]},"completionList":{"itemDefaults":["commitCharacters","editRange","insertTextFormat","insertTextMode"]}},"hover":{"dynamicRegistration":true,"contentFormat":["markdown","plaintext"]},"signatureHelp":{"dynamicRegistration":true,"signatureInformation":{"documentationFormat":["markdown","plaintext"],"parameterInformation":{"labelOffsetSupport":true},"activeParameterSupport":true},"contextSupport":true},"definition":{"dynamicRegistration":true,"linkSupport":true},"references":{"dynamicRegistration":true},"documentHighlight":{"dynamicRegistration":true},"documentSymbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"hierarchicalDocumentSymbolSupport":true,"tagSupport":{"valueSet":[1]},"labelSupport":true},"codeAction":{"dynamicRegistration":true,"isPreferredSupport":true,"disabledSupport":true,"dataSupport":true,"resolveSupport":{"properties":["edit"]},"codeActionLiteralSupport":{"codeActionKind":{"valueSet":["","quickfix","refactor","refactor.extract","refactor.inline","refactor.rewrite","source","source.organizeImports"]}},"honorsChangeAnnotations":false},"codeLens":{"dynamicRegistration":true},"formatting":{"dynamicRegistration":true},"rangeFormatting":{"dynamicRegistration":true},"onTypeFormatting":{"dynamicRegistration":true},"rename":{"dynamicRegistration":true,"prepareSupport":true,"prepareSupportDefaultBehavior":1,"honorsChangeAnnotations":true},"documentLink":{"dynamicRegistration":true,"tooltipSupport":true},"typeDefinition":{"dynamicRegistration":true,"linkSupport":true},"implementation":{"dynamicRegistration":true,"linkSupport":true},"colorProvider":{"dynamicRegistration":true},"foldingRange":{"dynamicRegistration":true,"rangeLimit":5000,"lineFoldingOnly":true,"foldingRangeKind":{"valueSet":["comment","imports","region"]},"foldingRange":{"collapsedText":false}},"declaration":{"dynamicRegistration":true,"linkSupport":true},"selectionRange":{"dynamicRegistration":true},"callHierarchy":{"dynamicRegistration":true},"semanticTokens":{"dynamicRegistration":true,"tokenTypes":["namespace","type","class","enum","interface","struct","typeParameter","parameter","variable","property","enumMember","event","function","method","macro","keyword","modifier","comment","string","number","regexp","operator","decorator"],"tokenModifiers":["declaration","definition","readonly","static","deprecated","abstract","async","modification","documentation","defaultLibrary"],"formats":["relative"],"requests":{"range":true,"full":{"delta":true}},"multilineTokenSupport":false,"overlappingTokenSupport":false,"serverCancelSupport":true,"augmentsSyntaxTokens":true},"linkedEditingRange":{"dynamicRegistration":true},"typeHierarchy":{"dynamicRegistration":true},"inlineValue":{"dynamicRegistration":true},"inlayHint":{"dynamicRegistration":true,"resolveSupport":{"properties":["tooltip","textEdits","label.tooltip","label.location","label.command"]}},"diagnostic":{"dynamicRegistration":true,"relatedDocumentSupport":false}},"window":{"showMessage":{"messageActionItem":{"additionalPropertiesSupport":true}},"showDocument":{"support":true},"workDoneProgress":true},"general":{"staleRequestSupport":{"cancel":true,"retryOnContentModified":["textDocument/semanticTokens/full","textDocument/semanticTokens/range","textDocument/semanticTokens/full/delta"]},"regularExpressions":{"engine":"ECMAScript","version":"ES2020"},"markdown":{"parser":"marked","version":"1.1.0"},"positionEncodings":["utf-16"]},"notebookDocument":{"synchronization":{"dynamicRegistration":true,"executionSummarySupport":true}}},"initializationOptions":{"editDelay":200,"hasWidgets":true},"trace":"off","workspaceFolders":[{"uri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4","name":"mathlib4"}]}}Content-Length: 52

{"jsonrpc":"2.0","method":"initialized","params":{}}Content-Length: 61

{"jsonrpc":"2.0","id":"register_ilean_watcher","result":null}Content-Length: 188

{"jsonrpc":"2.0","id":1,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4/Mathlib/RingTheory/Ideal/Basic.lean"}}}Content-Length: 307

{"jsonrpc":"2.0","id":2,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4/Mathlib/RingTheory/Ideal/Basic.lean"},"range":{"start":{"line":836,"character":0},"end":{"line":836,"character":0}},"context":{"diagnostics":[],"triggerKind":2}}}Content-Length: 36754

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4/Mathlib/RingTheory/Ideal/Basic.lean","languageId":"lean4","version":1,"text":"/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Chris Hughes, Mario Carneiro\n-/\nimport Mathlib.Tactic.FinCases\nimport Mathlib.Data.Nat.Choose.Sum\nimport Mathlib.LinearAlgebra.Finsupp\n\n#align_import ring_theory.ideal.basic from \"leanprover-community/mathlib\"@\"dc6c365e751e34d100e80fe6e314c3c3e0fd2988\"\n\n/-!\n\n# Ideals over a ring\n\nThis file defines `Ideal R`, the type of (left) ideals over a ring `R`.\nNote that over commutative rings, left ideals and two-sided ideals are equivalent.\n\n## Implementation notes\n\n`Ideal R` is implemented using `Submodule R R`, where `•` is interpreted as `*`.\n\n## TODO\n\nSupport right ideals, and two-sided ideals over non-commutative rings.\n-/\n\n\nuniverse u v w\n\nvariable {α : Type u} {β : Type v}\n\nopen Set Function\n\nopen BigOperators Pointwise\n\n/-- A (left) ideal in a semiring `R` is an additive submonoid `s` such that\n`a * b ∈ s` whenever `b ∈ s`. If `R` is a ring, then `s` is an additive subgroup.  -/\n@[reducible]\ndef Ideal (R : Type u) [Semiring R] :=\n  Submodule R R\n#align ideal Ideal\n\nsection Semiring\n\nnamespace Ideal\n\nvariable [Semiring α] (I : Ideal α) {a b : α}\n\nprotected theorem zero_mem : (0 : α) ∈ I :=\n  Submodule.zero_mem I\n#align ideal.zero_mem Ideal.zero_mem\n\nprotected theorem add_mem : a ∈ I → b ∈ I → a + b ∈ I :=\n  Submodule.add_mem I\n#align ideal.add_mem Ideal.add_mem\n\nvariable (a)\n\ntheorem mul_mem_left : b ∈ I → a * b ∈ I :=\n  Submodule.smul_mem I a\n#align ideal.mul_mem_left Ideal.mul_mem_left\n\nvariable {a}\n\n@[ext]\ntheorem ext {I J : Ideal α} (h : ∀ x, x ∈ I ↔ x ∈ J) : I = J :=\n  Submodule.ext h\n#align ideal.ext Ideal.ext\n\ntheorem sum_mem (I : Ideal α) {ι : Type*} {t : Finset ι} {f : ι → α} :\n    (∀ c ∈ t, f c ∈ I) → (∑ i in t, f i) ∈ I :=\n  Submodule.sum_mem I\n#align ideal.sum_mem Ideal.sum_mem\n\ntheorem eq_top_of_unit_mem (x y : α) (hx : x ∈ I) (h : y * x = 1) : I = ⊤ :=\n  eq_top_iff.2 fun z _ =>\n    calc\n      z = z * (y * x) := by simp [h]\n      _ = z * y * x := Eq.symm <| mul_assoc z y x\n      _ ∈ I := I.mul_mem_left _ hx\n#align ideal.eq_top_of_unit_mem Ideal.eq_top_of_unit_mem\n\ntheorem eq_top_of_isUnit_mem {x} (hx : x ∈ I) (h : IsUnit x) : I = ⊤ :=\n  let ⟨y, hy⟩ := h.exists_left_inv\n  eq_top_of_unit_mem I x y hx hy\n#align ideal.eq_top_of_is_unit_mem Ideal.eq_top_of_isUnit_mem\n\ntheorem eq_top_iff_one : I = ⊤ ↔ (1 : α) ∈ I :=\n  ⟨by rintro rfl; trivial, fun h => eq_top_of_unit_mem _ _ 1 h (by simp)⟩\n#align ideal.eq_top_iff_one Ideal.eq_top_iff_one\n\ntheorem ne_top_iff_one : I ≠ ⊤ ↔ (1 : α) ∉ I :=\n  not_congr I.eq_top_iff_one\n#align ideal.ne_top_iff_one Ideal.ne_top_iff_one\n\n@[simp]\ntheorem unit_mul_mem_iff_mem {x y : α} (hy : IsUnit y) : y * x ∈ I ↔ x ∈ I := by\n  refine' ⟨fun h => _, fun h => I.mul_mem_left y h⟩\n  obtain ⟨y', hy'⟩ := hy.exists_left_inv\n  have := I.mul_mem_left y' h\n  rwa [← mul_assoc, hy', one_mul] at this\n#align ideal.unit_mul_mem_iff_mem Ideal.unit_mul_mem_iff_mem\n\n/-- The ideal generated by a subset of a ring -/\ndef span (s : Set α) : Ideal α :=\n  Submodule.span α s\n#align ideal.span Ideal.span\n\n@[simp]\ntheorem submodule_span_eq {s : Set α} : Submodule.span α s = Ideal.span s :=\n  rfl\n#align ideal.submodule_span_eq Ideal.submodule_span_eq\n\n@[simp]\ntheorem span_empty : span (∅ : Set α) = ⊥ :=\n  Submodule.span_empty\n#align ideal.span_empty Ideal.span_empty\n\n@[simp]\ntheorem span_univ : span (Set.univ : Set α) = ⊤ :=\n  Submodule.span_univ\n#align ideal.span_univ Ideal.span_univ\n\ntheorem span_union (s t : Set α) : span (s ∪ t) = span s ⊔ span t :=\n  Submodule.span_union _ _\n#align ideal.span_union Ideal.span_union\n\ntheorem span_iUnion {ι} (s : ι → Set α) : span (⋃ i, s i) = ⨆ i, span (s i) :=\n  Submodule.span_iUnion _\n#align ideal.span_Union Ideal.span_iUnion\n\ntheorem mem_span {s : Set α} (x) : x ∈ span s ↔ ∀ p : Ideal α, s ⊆ p → x ∈ p :=\n  mem_iInter₂\n#align ideal.mem_span Ideal.mem_span\n\ntheorem subset_span {s : Set α} : s ⊆ span s :=\n  Submodule.subset_span\n#align ideal.subset_span Ideal.subset_span\n\ntheorem span_le {s : Set α} {I} : span s ≤ I ↔ s ⊆ I :=\n  Submodule.span_le\n#align ideal.span_le Ideal.span_le\n\ntheorem span_mono {s t : Set α} : s ⊆ t → span s ≤ span t :=\n  Submodule.span_mono\n#align ideal.span_mono Ideal.span_mono\n\n@[simp]\ntheorem span_eq : span (I : Set α) = I :=\n  Submodule.span_eq _\n#align ideal.span_eq Ideal.span_eq\n\n@[simp]\ntheorem span_singleton_one : span ({1} : Set α) = ⊤ :=\n  (eq_top_iff_one _).2 <| subset_span <| mem_singleton _\n#align ideal.span_singleton_one Ideal.span_singleton_one\n\ntheorem isCompactElement_top : CompleteLattice.IsCompactElement (⊤ : Ideal α) := by\n  simpa only [← span_singleton_one] using Submodule.singleton_span_isCompactElement 1\n\ntheorem mem_span_insert {s : Set α} {x y} :\n    x ∈ span (insert y s) ↔ ∃ a, ∃ z ∈ span s, x = a * y + z :=\n  Submodule.mem_span_insert\n#align ideal.mem_span_insert Ideal.mem_span_insert\n\ntheorem mem_span_singleton' {x y : α} : x ∈ span ({y} : Set α) ↔ ∃ a, a * y = x :=\n  Submodule.mem_span_singleton\n#align ideal.mem_span_singleton' Ideal.mem_span_singleton'\n\ntheorem span_singleton_le_iff_mem {x : α} : span {x} ≤ I ↔ x ∈ I :=\n  Submodule.span_singleton_le_iff_mem _ _\n#align ideal.span_singleton_le_iff_mem Ideal.span_singleton_le_iff_mem\n\ntheorem span_singleton_mul_left_unit {a : α} (h2 : IsUnit a) (x : α) :\n    span ({a * x} : Set α) = span {x} := by\n  apply le_antisymm <;> rw [span_singleton_le_iff_mem, mem_span_singleton']\n  exacts [⟨a, rfl⟩, ⟨_, h2.unit.inv_mul_cancel_left x⟩]\n#align ideal.span_singleton_mul_left_unit Ideal.span_singleton_mul_left_unit\n\ntheorem span_insert (x) (s : Set α) : span (insert x s) = span ({x} : Set α) ⊔ span s :=\n  Submodule.span_insert x s\n#align ideal.span_insert Ideal.span_insert\n\ntheorem span_eq_bot {s : Set α} : span s = ⊥ ↔ ∀ x ∈ s, (x : α) = 0 :=\n  Submodule.span_eq_bot\n#align ideal.span_eq_bot Ideal.span_eq_bot\n\n@[simp]\ntheorem span_singleton_eq_bot {x} : span ({x} : Set α) = ⊥ ↔ x = 0 :=\n  Submodule.span_singleton_eq_bot\n#align ideal.span_singleton_eq_bot Ideal.span_singleton_eq_bot\n\ntheorem span_singleton_ne_top {α : Type*} [CommSemiring α] {x : α} (hx : ¬IsUnit x) :\n    Ideal.span ({x} : Set α) ≠ ⊤ :=\n  (Ideal.ne_top_iff_one _).mpr fun h1 =>\n    let ⟨y, hy⟩ := Ideal.mem_span_singleton'.mp h1\n    hx ⟨⟨x, y, mul_comm y x ▸ hy, hy⟩, rfl⟩\n#align ideal.span_singleton_ne_top Ideal.span_singleton_ne_top\n\n@[simp]\ntheorem span_zero : span (0 : Set α) = ⊥ := by rw [← Set.singleton_zero, span_singleton_eq_bot]\n#align ideal.span_zero Ideal.span_zero\n\n@[simp]\ntheorem span_one : span (1 : Set α) = ⊤ := by rw [← Set.singleton_one, span_singleton_one]\n#align ideal.span_one Ideal.span_one\n\ntheorem span_eq_top_iff_finite (s : Set α) :\n    span s = ⊤ ↔ ∃ s' : Finset α, ↑s' ⊆ s ∧ span (s' : Set α) = ⊤ := by\n  simp_rw [eq_top_iff_one]\n  exact ⟨Submodule.mem_span_finite_of_mem_span, fun ⟨s', h₁, h₂⟩ => span_mono h₁ h₂⟩\n#align ideal.span_eq_top_iff_finite Ideal.span_eq_top_iff_finite\n\ntheorem mem_span_singleton_sup {S : Type*} [CommSemiring S] {x y : S} {I : Ideal S} :\n    x ∈ Ideal.span {y} ⊔ I ↔ ∃ a : S, ∃ b ∈ I, a * y + b = x := by\n  rw [Submodule.mem_sup]\n  constructor\n  · rintro ⟨ya, hya, b, hb, rfl⟩\n    obtain ⟨a, rfl⟩ := mem_span_singleton'.mp hya\n    exact ⟨a, b, hb, rfl⟩\n  · rintro ⟨a, b, hb, rfl⟩\n    exact ⟨a * y, Ideal.mem_span_singleton'.mpr ⟨a, rfl⟩, b, hb, rfl⟩\n#align ideal.mem_span_singleton_sup Ideal.mem_span_singleton_sup\n\n/-- The ideal generated by an arbitrary binary relation.\n-/\ndef ofRel (r : α → α → Prop) : Ideal α :=\n  Submodule.span α { x | ∃ (a b : _) (_h : r a b), x + b = a }\n#align ideal.of_rel Ideal.ofRel\n\n/-- An ideal `P` of a ring `R` is prime if `P ≠ R` and `xy ∈ P → x ∈ P ∨ y ∈ P` -/\nclass IsPrime (I : Ideal α) : Prop where\n  /-- The prime ideal is not the entire ring. -/\n  ne_top' : I ≠ ⊤\n  /-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/\n  mem_or_mem' : ∀ {x y : α}, x * y ∈ I → x ∈ I ∨ y ∈ I\n#align ideal.is_prime Ideal.IsPrime\n\ntheorem isPrime_iff {I : Ideal α} : IsPrime I ↔ I ≠ ⊤ ∧ ∀ {x y : α}, x * y ∈ I → x ∈ I ∨ y ∈ I :=\n  ⟨fun h => ⟨h.1, h.2⟩, fun h => ⟨h.1, h.2⟩⟩\n#align ideal.is_prime_iff Ideal.isPrime_iff\n\ntheorem IsPrime.ne_top {I : Ideal α} (hI : I.IsPrime) : I ≠ ⊤ :=\n  hI.1\n#align ideal.is_prime.ne_top Ideal.IsPrime.ne_top\n\ntheorem IsPrime.mem_or_mem {I : Ideal α} (hI : I.IsPrime) {x y : α} : x * y ∈ I → x ∈ I ∨ y ∈ I :=\n  hI.2\n#align ideal.is_prime.mem_or_mem Ideal.IsPrime.mem_or_mem\n\ntheorem IsPrime.mem_or_mem_of_mul_eq_zero {I : Ideal α} (hI : I.IsPrime) {x y : α} (h : x * y = 0) :\n    x ∈ I ∨ y ∈ I :=\n  hI.mem_or_mem (h.symm ▸ I.zero_mem)\n#align ideal.is_prime.mem_or_mem_of_mul_eq_zero Ideal.IsPrime.mem_or_mem_of_mul_eq_zero\n\ntheorem IsPrime.mem_of_pow_mem {I : Ideal α} (hI : I.IsPrime) {r : α} (n : ℕ) (H : r ^ n ∈ I) :\n    r ∈ I := by\n  induction' n with n ih\n  · rw [pow_zero] at H\n    exact (mt (eq_top_iff_one _).2 hI.1).elim H\n  · rw [pow_succ] at H\n    exact Or.casesOn (hI.mem_or_mem H) id ih\n#align ideal.is_prime.mem_of_pow_mem Ideal.IsPrime.mem_of_pow_mem\n\ntheorem not_isPrime_iff {I : Ideal α} :\n    ¬I.IsPrime ↔ I = ⊤ ∨ ∃ (x : α) (_hx : x ∉ I) (y : α) (_hy : y ∉ I), x * y ∈ I := by\n  simp_rw [Ideal.isPrime_iff, not_and_or, Ne.def, Classical.not_not, not_forall, not_or]\n  exact\n    or_congr Iff.rfl\n      ⟨fun ⟨x, y, hxy, hx, hy⟩ => ⟨x, hx, y, hy, hxy⟩, fun ⟨x, hx, y, hy, hxy⟩ =>\n        ⟨x, y, hxy, hx, hy⟩⟩\n#align ideal.not_is_prime_iff Ideal.not_isPrime_iff\n\ntheorem zero_ne_one_of_proper {I : Ideal α} (h : I ≠ ⊤) : (0 : α) ≠ 1 := fun hz =>\n  I.ne_top_iff_one.1 h <| hz ▸ I.zero_mem\n#align ideal.zero_ne_one_of_proper Ideal.zero_ne_one_of_proper\n\ntheorem bot_prime [IsDomain α] : (⊥ : Ideal α).IsPrime :=\n  ⟨fun h => one_ne_zero (by rwa [Ideal.eq_top_iff_one, Submodule.mem_bot] at h), fun h =>\n    mul_eq_zero.mp (by simpa only [Submodule.mem_bot] using h)⟩\n#align ideal.bot_prime Ideal.bot_prime\n\n/-- An ideal is maximal if it is maximal in the collection of proper ideals. -/\nclass IsMaximal (I : Ideal α) : Prop where\n  /-- The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\n  and there are no other proper ideals strictly containing it. -/\n  out : IsCoatom I\n#align ideal.is_maximal Ideal.IsMaximal\n\ntheorem isMaximal_def {I : Ideal α} : I.IsMaximal ↔ IsCoatom I :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n#align ideal.is_maximal_def Ideal.isMaximal_def\n\ntheorem IsMaximal.ne_top {I : Ideal α} (h : I.IsMaximal) : I ≠ ⊤ :=\n  (isMaximal_def.1 h).1\n#align ideal.is_maximal.ne_top Ideal.IsMaximal.ne_top\n\ntheorem isMaximal_iff {I : Ideal α} :\n    I.IsMaximal ↔ (1 : α) ∉ I ∧ ∀ (J : Ideal α) (x), I ≤ J → x ∉ I → x ∈ J → (1 : α) ∈ J :=\n  isMaximal_def.trans <|\n    and_congr I.ne_top_iff_one <|\n      forall_congr' fun J => by\n        rw [lt_iff_le_not_le];\n          exact\n            ⟨fun H x h hx₁ hx₂ => J.eq_top_iff_one.1 <| H ⟨h, not_subset.2 ⟨_, hx₂, hx₁⟩⟩,\n              fun H ⟨h₁, h₂⟩ =>\n              let ⟨x, xJ, xI⟩ := not_subset.1 h₂\n              J.eq_top_iff_one.2 <| H x h₁ xI xJ⟩\n#align ideal.is_maximal_iff Ideal.isMaximal_iff\n\ntheorem IsMaximal.eq_of_le {I J : Ideal α} (hI : I.IsMaximal) (hJ : J ≠ ⊤) (IJ : I ≤ J) : I = J :=\n  eq_iff_le_not_lt.2 ⟨IJ, fun h => hJ (hI.1.2 _ h)⟩\n#align ideal.is_maximal.eq_of_le Ideal.IsMaximal.eq_of_le\n\ninstance : IsCoatomic (Ideal α) := by\n  apply CompleteLattice.coatomic_of_top_compact\n  rw [← span_singleton_one]\n  exact Submodule.singleton_span_isCompactElement 1\n\ntheorem IsMaximal.coprime_of_ne {M M' : Ideal α} (hM : M.IsMaximal) (hM' : M'.IsMaximal)\n    (hne : M ≠ M') : M ⊔ M' = ⊤ := by\n  contrapose! hne with h\n  exact hM.eq_of_le hM'.ne_top (le_sup_left.trans_eq (hM'.eq_of_le h le_sup_right).symm)\n#align ideal.is_maximal.coprime_of_ne Ideal.IsMaximal.coprime_of_ne\n\n/-- **Krull's theorem**: if `I` is an ideal that is not the whole ring, then it is included in some\n    maximal ideal. -/\ntheorem exists_le_maximal (I : Ideal α) (hI : I ≠ ⊤) : ∃ M : Ideal α, M.IsMaximal ∧ I ≤ M :=\n  let ⟨m, hm⟩ := (eq_top_or_exists_le_coatom I).resolve_left hI\n  ⟨m, ⟨⟨hm.1⟩, hm.2⟩⟩\n#align ideal.exists_le_maximal Ideal.exists_le_maximal\n\nvariable (α)\n\n/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/\ntheorem exists_maximal [Nontrivial α] : ∃ M : Ideal α, M.IsMaximal :=\n  let ⟨I, ⟨hI, _⟩⟩ := exists_le_maximal (⊥ : Ideal α) bot_ne_top\n  ⟨I, hI⟩\n#align ideal.exists_maximal Ideal.exists_maximal\n\nvariable {α}\n\ninstance [Nontrivial α] : Nontrivial (Ideal α) := by\n  rcases@exists_maximal α _ _ with ⟨M, hM, _⟩\n  exact nontrivial_of_ne M ⊤ hM\n\n/-- If P is not properly contained in any maximal ideal then it is not properly contained\n  in any proper ideal -/\ntheorem maximal_of_no_maximal {P : Ideal α}\n    (hmax : ∀ m : Ideal α, P < m → ¬IsMaximal m) (J : Ideal α) (hPJ : P < J) : J = ⊤ := by\n  by_contra hnonmax\n  rcases exists_le_maximal J hnonmax with ⟨M, hM1, hM2⟩\n  exact hmax M (lt_of_lt_of_le hPJ hM2) hM1\n#align ideal.maximal_of_no_maximal Ideal.maximal_of_no_maximal\n\ntheorem span_pair_comm {x y : α} : (span {x, y} : Ideal α) = span {y, x} := by\n  simp only [span_insert, sup_comm]\n#align ideal.span_pair_comm Ideal.span_pair_comm\n\ntheorem mem_span_pair {x y z : α} : z ∈ span ({x, y} : Set α) ↔ ∃ a b, a * x + b * y = z :=\n  Submodule.mem_span_pair\n#align ideal.mem_span_pair Ideal.mem_span_pair\n\n@[simp]\ntheorem span_pair_add_mul_left {R : Type u} [CommRing R] {x y : R} (z : R) :\n    (span {x + y * z, y} : Ideal R) = span {x, y} := by\n  ext\n  rw [mem_span_pair, mem_span_pair]\n  exact\n    ⟨fun ⟨a, b, h⟩ =>\n      ⟨a, b + a * z, by\n        rw [← h]\n        ring1⟩,\n      fun ⟨a, b, h⟩ =>\n      ⟨a, b - a * z, by\n        rw [← h]\n        ring1⟩⟩\n#align ideal.span_pair_add_mul_left Ideal.span_pair_add_mul_left\n\n@[simp]\ntheorem span_pair_add_mul_right {R : Type u} [CommRing R] {x y : R} (z : R) :\n    (span {x, y + x * z} : Ideal R) = span {x, y} := by\n  rw [span_pair_comm, span_pair_add_mul_left, span_pair_comm]\n#align ideal.span_pair_add_mul_right Ideal.span_pair_add_mul_right\n\ntheorem IsMaximal.exists_inv {I : Ideal α} (hI : I.IsMaximal) {x} (hx : x ∉ I) :\n    ∃ y, ∃ i ∈ I, y * x + i = 1 := by\n  cases' isMaximal_iff.1 hI with H₁ H₂\n  rcases mem_span_insert.1\n      (H₂ (span (insert x I)) x (Set.Subset.trans (subset_insert _ _) subset_span) hx\n        (subset_span (mem_insert _ _))) with\n    ⟨y, z, hz, hy⟩\n  refine' ⟨y, z, _, hy.symm⟩\n  rwa [← span_eq I]\n#align ideal.is_maximal.exists_inv Ideal.IsMaximal.exists_inv\n\nsection Lattice\n\nvariable {R : Type u} [Semiring R]\n\n-- porting note: is this the right approach? or is there a better way to prove? (next 4 decls)\ntheorem mem_sup_left {S T : Ideal R} : ∀ {x : R}, x ∈ S → x ∈ S ⊔ T :=\n  @le_sup_left _ _ S T\n#align ideal.mem_sup_left Ideal.mem_sup_left\n\ntheorem mem_sup_right {S T : Ideal R} : ∀ {x : R}, x ∈ T → x ∈ S ⊔ T :=\n  @le_sup_right _ _ S T\n#align ideal.mem_sup_right Ideal.mem_sup_right\n\ntheorem mem_iSup_of_mem {ι : Sort*} {S : ι → Ideal R} (i : ι) : ∀ {x : R}, x ∈ S i → x ∈ iSup S :=\n  @le_iSup _ _ _ S _\n#align ideal.mem_supr_of_mem Ideal.mem_iSup_of_mem\n\ntheorem mem_sSup_of_mem {S : Set (Ideal R)} {s : Ideal R} (hs : s ∈ S) :\n    ∀ {x : R}, x ∈ s → x ∈ sSup S :=\n  @le_sSup _ _ _ _ hs\n#align ideal.mem_Sup_of_mem Ideal.mem_sSup_of_mem\n\ntheorem mem_sInf {s : Set (Ideal R)} {x : R} : x ∈ sInf s ↔ ∀ ⦃I⦄, I ∈ s → x ∈ I :=\n  ⟨fun hx I his => hx I ⟨I, iInf_pos his⟩, fun H _I ⟨_J, hij⟩ => hij ▸ fun _S ⟨hj, hS⟩ => hS ▸ H hj⟩\n#align ideal.mem_Inf Ideal.mem_sInf\n\n@[simp 1001] -- porting note: increased priority to appease `simpNF`\ntheorem mem_inf {I J : Ideal R} {x : R} : x ∈ I ⊓ J ↔ x ∈ I ∧ x ∈ J :=\n  Iff.rfl\n#align ideal.mem_inf Ideal.mem_inf\n\n@[simp 1001] -- porting note: increased priority to appease `simpNF`\ntheorem mem_iInf {ι : Sort*} {I : ι → Ideal R} {x : R} : x ∈ iInf I ↔ ∀ i, x ∈ I i :=\n  Submodule.mem_iInf _\n#align ideal.mem_infi Ideal.mem_iInf\n\n@[simp 1001] -- porting note: increased priority to appease `simpNF`\ntheorem mem_bot {x : R} : x ∈ (⊥ : Ideal R) ↔ x = 0 :=\n  Submodule.mem_bot _\n#align ideal.mem_bot Ideal.mem_bot\n\nend Lattice\n\nsection Pi\n\nvariable (ι : Type v)\n\n/-- `I^n` as an ideal of `R^n`. -/\ndef pi : Ideal (ι → α) where\n  carrier := { x | ∀ i, x i ∈ I }\n  zero_mem' _i := I.zero_mem\n  add_mem' ha hb i := I.add_mem (ha i) (hb i)\n  smul_mem' a _b hb i := I.mul_mem_left (a i) (hb i)\n#align ideal.pi Ideal.pi\n\ntheorem mem_pi (x : ι → α) : x ∈ I.pi ι ↔ ∀ i, x i ∈ I :=\n  Iff.rfl\n#align ideal.mem_pi Ideal.mem_pi\n\nend Pi\n\ntheorem sInf_isPrime_of_isChain {s : Set (Ideal α)} (hs : s.Nonempty) (hs' : IsChain (· ≤ ·) s)\n    (H : ∀ p ∈ s, Ideal.IsPrime p) : (sInf s).IsPrime :=\n  ⟨fun e =>\n    let ⟨x, hx⟩ := hs\n    (H x hx).ne_top (eq_top_iff.mpr (e.symm.trans_le (sInf_le hx))),\n    fun e =>\n    or_iff_not_imp_left.mpr fun hx => by\n      rw [Ideal.mem_sInf] at hx e ⊢\n      push_neg at hx\n      obtain ⟨I, hI, hI'⟩ := hx\n      intro J hJ\n      cases' hs'.total hI hJ with h h\n      · exact h (((H I hI).mem_or_mem (e hI)).resolve_left hI')\n      · exact ((H J hJ).mem_or_mem (e hJ)).resolve_left fun x => hI' <| h x⟩\n#align ideal.Inf_is_prime_of_is_chain Ideal.sInf_isPrime_of_isChain\n\nend Ideal\n\nend Semiring\n\nsection CommSemiring\n\nvariable {a b : α}\n\n-- A separate namespace definition is needed because the variables were historically in a different\n-- order.\nnamespace Ideal\n\nvariable [CommSemiring α] (I : Ideal α)\n\n@[simp]\ntheorem mul_unit_mem_iff_mem {x y : α} (hy : IsUnit y) : x * y ∈ I ↔ x ∈ I :=\n  mul_comm y x ▸ unit_mul_mem_iff_mem I hy\n#align ideal.mul_unit_mem_iff_mem Ideal.mul_unit_mem_iff_mem\n\ntheorem mem_span_singleton {x y : α} : x ∈ span ({y} : Set α) ↔ y ∣ x :=\n  mem_span_singleton'.trans <| exists_congr fun _ => by rw [eq_comm, mul_comm]\n#align ideal.mem_span_singleton Ideal.mem_span_singleton\n\ntheorem mem_span_singleton_self (x : α) : x ∈ span ({x} : Set α) :=\n  mem_span_singleton.mpr dvd_rfl\n#align ideal.mem_span_singleton_self Ideal.mem_span_singleton_self\n\ntheorem span_singleton_le_span_singleton {x y : α} :\n    span ({x} : Set α) ≤ span ({y} : Set α) ↔ y ∣ x :=\n  span_le.trans <| singleton_subset_iff.trans mem_span_singleton\n#align ideal.span_singleton_le_span_singleton Ideal.span_singleton_le_span_singleton\n\ntheorem span_singleton_eq_span_singleton {α : Type u} [CommRing α] [IsDomain α] {x y : α} :\n    span ({x} : Set α) = span ({y} : Set α) ↔ Associated x y := by\n  rw [← dvd_dvd_iff_associated, le_antisymm_iff, and_comm]\n  apply and_congr <;> rw [span_singleton_le_span_singleton]\n#align ideal.span_singleton_eq_span_singleton Ideal.span_singleton_eq_span_singleton\n\ntheorem span_singleton_mul_right_unit {a : α} (h2 : IsUnit a) (x : α) :\n    span ({x * a} : Set α) = span {x} := by rw [mul_comm, span_singleton_mul_left_unit h2]\n#align ideal.span_singleton_mul_right_unit Ideal.span_singleton_mul_right_unit\n\ntheorem span_singleton_eq_top {x} : span ({x} : Set α) = ⊤ ↔ IsUnit x := by\n  rw [isUnit_iff_dvd_one, ← span_singleton_le_span_singleton, span_singleton_one, eq_top_iff]\n#align ideal.span_singleton_eq_top Ideal.span_singleton_eq_top\n\ntheorem span_singleton_prime {p : α} (hp : p ≠ 0) : IsPrime (span ({p} : Set α)) ↔ Prime p := by\n  simp [isPrime_iff, Prime, span_singleton_eq_top, hp, mem_span_singleton]\n#align ideal.span_singleton_prime Ideal.span_singleton_prime\n\ntheorem IsMaximal.isPrime {I : Ideal α} (H : I.IsMaximal) : I.IsPrime :=\n  ⟨H.1.1, @fun x y hxy =>\n    or_iff_not_imp_left.2 fun hx => by\n      let J : Ideal α := Submodule.span α (insert x ↑I)\n      have IJ : I ≤ J := Set.Subset.trans (subset_insert _ _) subset_span\n      have xJ : x ∈ J := Ideal.subset_span (Set.mem_insert x I)\n      cases' isMaximal_iff.1 H with _ oJ\n      specialize oJ J x IJ hx xJ\n      rcases Submodule.mem_span_insert.mp oJ with ⟨a, b, h, oe⟩\n      obtain F : y * 1 = y * (a • x + b) := congr_arg (fun g : α => y * g) oe\n      rw [← mul_one y, F, mul_add, mul_comm, smul_eq_mul, mul_assoc]\n      refine' Submodule.add_mem I (I.mul_mem_left a hxy) (Submodule.smul_mem I y _)\n      rwa [Submodule.span_eq] at h⟩\n#align ideal.is_maximal.is_prime Ideal.IsMaximal.isPrime\n\n-- see Note [lower instance priority]\ninstance (priority := 100) IsMaximal.isPrime' (I : Ideal α) : ∀ [_H : I.IsMaximal], I.IsPrime :=\n  @IsMaximal.isPrime _ _ _\n#align ideal.is_maximal.is_prime' Ideal.IsMaximal.isPrime'\n\ntheorem span_singleton_lt_span_singleton  [IsDomain α] {x y : α} :\n    span ({x} : Set α) < span ({y} : Set α) ↔ DvdNotUnit y x := by\n  rw [lt_iff_le_not_le, span_singleton_le_span_singleton, span_singleton_le_span_singleton,\n    dvd_and_not_dvd_iff]\n#align ideal.span_singleton_lt_span_singleton Ideal.span_singleton_lt_span_singleton\n\ntheorem factors_decreasing [IsDomain α] (b₁ b₂ : α) (h₁ : b₁ ≠ 0) (h₂ : ¬IsUnit b₂) :\n    span ({b₁ * b₂} : Set α) < span {b₁} :=\n  lt_of_le_not_le\n    (Ideal.span_le.2 <| singleton_subset_iff.2 <| Ideal.mem_span_singleton.2 ⟨b₂, rfl⟩) fun h =>\n    h₂ <| isUnit_of_dvd_one <|\n        (mul_dvd_mul_iff_left h₁).1 <| by rwa [mul_one, ← Ideal.span_singleton_le_span_singleton]\n#align ideal.factors_decreasing Ideal.factors_decreasing\n\nvariable (b)\n\ntheorem mul_mem_right (h : a ∈ I) : a * b ∈ I :=\n  mul_comm b a ▸ I.mul_mem_left b h\n#align ideal.mul_mem_right Ideal.mul_mem_right\n\nvariable {b}\n\ntheorem pow_mem_of_mem (ha : a ∈ I) (n : ℕ) (hn : 0 < n) : a ^ n ∈ I :=\n  Nat.casesOn n (Not.elim (by decide))\n    (fun m _hm => (pow_succ a m).symm ▸ I.mul_mem_right (a ^ m) ha) hn\n#align ideal.pow_mem_of_mem Ideal.pow_mem_of_mem\n\ntheorem IsPrime.mul_mem_iff_mem_or_mem {I : Ideal α} (hI : I.IsPrime) :\n    ∀ {x y : α}, x * y ∈ I ↔ x ∈ I ∨ y ∈ I := @fun x y =>\n  ⟨hI.mem_or_mem, by\n    rintro (h | h)\n    exacts [I.mul_mem_right y h, I.mul_mem_left x h]⟩\n#align ideal.is_prime.mul_mem_iff_mem_or_mem Ideal.IsPrime.mul_mem_iff_mem_or_mem\n\ntheorem IsPrime.pow_mem_iff_mem {I : Ideal α} (hI : I.IsPrime) {r : α} (n : ℕ) (hn : 0 < n) :\n    r ^ n ∈ I ↔ r ∈ I :=\n  ⟨hI.mem_of_pow_mem n, fun hr => I.pow_mem_of_mem hr n hn⟩\n#align ideal.is_prime.pow_mem_iff_mem Ideal.IsPrime.pow_mem_iff_mem\n\ntheorem pow_multiset_sum_mem_span_pow [DecidableEq α] (s : Multiset α) (n : ℕ) :\n    s.sum ^ (Multiset.card s * n + 1) ∈\n    span ((s.map fun (x:α) ↦ x ^ (n + 1)).toFinset : Set α) := by\n  induction' s using Multiset.induction_on with a s hs\n  · simp\n  simp only [Finset.coe_insert, Multiset.map_cons, Multiset.toFinset_cons, Multiset.sum_cons,\n    Multiset.card_cons, add_pow]\n  refine' Submodule.sum_mem _ _\n  intro c _hc\n  rw [mem_span_insert]\n  by_cases h : n + 1 ≤ c\n  · refine' ⟨a ^ (c - (n + 1)) * s.sum ^ ((Multiset.card s + 1) * n + 1 - c) *\n      ((Multiset.card s + 1) * n + 1).choose c, 0, Submodule.zero_mem _, _⟩\n    rw [mul_comm _ (a ^ (n + 1))]\n    simp_rw [← mul_assoc]\n    rw [← pow_add, add_zero, add_tsub_cancel_of_le h]\n  · use 0\n    simp_rw [zero_mul, zero_add]\n    refine' ⟨_, _, rfl⟩\n    replace h : c ≤ n := Nat.lt_succ_iff.mp (not_le.mp h)\n    have : (Multiset.card s + 1) * n + 1 - c = Multiset.card s * n + 1 + (n - c) := by\n      rw [add_mul, one_mul, add_assoc, add_comm n 1, ← add_assoc, add_tsub_assoc_of_le h]\n    rw [this, pow_add]\n    simp_rw [mul_assoc, mul_comm (s.sum ^ (Multiset.card s * n + 1)), ← mul_assoc]\n    exact mul_mem_left _ _ hs\n#align ideal.pow_multiset_sum_mem_span_pow Ideal.pow_multiset_sum_mem_span_pow\n\ntheorem sum_pow_mem_span_pow {ι} (s : Finset ι) (f : ι → α) (n : ℕ) :\n    (∑ i in s, f i) ^ (s.card * n + 1) ∈ span ((fun i => f i ^ (n + 1)) '' s) := by\n  classical\n  simpa only [Multiset.card_map, Multiset.map_map, comp_apply, Multiset.toFinset_map,\n    Finset.coe_image, Finset.val_toFinset] using pow_multiset_sum_mem_span_pow (s.1.map f) n\n#align ideal.sum_pow_mem_span_pow Ideal.sum_pow_mem_span_pow\n\ntheorem span_pow_eq_top (s : Set α) (hs : span s = ⊤) (n : ℕ) :\n    span ((fun (x : α) => x ^ n) '' s) = ⊤ := by\n  rw [eq_top_iff_one]\n  cases' n with n\n  · obtain rfl | ⟨x, hx⟩ := eq_empty_or_nonempty s\n    · rw [Set.image_empty, hs]\n      trivial\n    · exact subset_span ⟨_, hx, pow_zero _⟩\n  rw [eq_top_iff_one, span, Finsupp.mem_span_iff_total] at hs\n  rcases hs with ⟨f, hf⟩\n  have hf : (f.support.sum fun a => f a * a) = 1 := hf -- Porting note: was `change ... at hf`\n  have := sum_pow_mem_span_pow f.support (fun a => f a * a) n\n  rw [hf, one_pow] at this\n  refine' span_le.mpr _ this\n  rintro _ hx\n  simp_rw [Set.mem_image] at hx\n  rcases hx with ⟨x, _, rfl⟩\n  have : span ({(x:α) ^ (n + 1)} : Set α) ≤ span ((fun x : α => x ^ (n + 1)) '' s) := by\n    rw [span_le, Set.singleton_subset_iff]\n    exact subset_span ⟨x, x.prop, rfl⟩\n  refine' this _\n  rw [mul_pow, mem_span_singleton]\n  exact ⟨f x ^ (n + 1), mul_comm _ _⟩\n#align ideal.span_pow_eq_top Ideal.span_pow_eq_top\n\nlemma isPrime_of_maximally_disjoint (I : Ideal α)\n    (S : Submonoid α)\n    (disjoint : Disjoint (I : Set α) S)\n    (maximally_disjoint : ∀ (J : Ideal α), I < J → ¬ Disjoint (J : Set α) S) :\n    I.IsPrime where\n  ne_top' := by\n    rintro rfl\n    have : 1 ∈ (S : Set α) := S.one_mem\n    aesop\n  mem_or_mem' {x y} hxy := by\n    by_contra' rid\n    have hx := maximally_disjoint (I ⊔ span {x}) (Submodule.lt_sup_iff_not_mem.mpr rid.1)\n    have hy := maximally_disjoint (I ⊔ span {y}) (Submodule.lt_sup_iff_not_mem.mpr rid.2)\n    simp only [Set.not_disjoint_iff, mem_inter_iff, SetLike.mem_coe, Submodule.mem_sup,\n      mem_span_singleton] at hx hy\n    obtain ⟨s₁, ⟨i₁, hi₁, ⟨_, ⟨r₁, rfl⟩, hr₁⟩⟩, hs₁⟩ := hx\n    obtain ⟨s₂, ⟨i₂, hi₂, ⟨_, ⟨r₂, rfl⟩, hr₂⟩⟩, hs₂⟩ := hy\n    refine disjoint.ne_of_mem\n      (I.add_mem (I.mul_mem_left (i₁ + x * r₁) hi₂) <| I.add_mem (I.mul_mem_right (y * r₂) hi₁) <|\n        I.mul_mem_right (r₁ * r₂) hxy)\n      (S.mul_mem hs₁ hs₂) ?_\n    rw [← hr₁, ← hr₂]\n    ring\n\nend Ideal\n\nend CommSemiring\n\nsection Ring\n\nnamespace Ideal\n\nvariable [Ring α] (I : Ideal α) {a b : α}\n\nprotected theorem neg_mem_iff : -a ∈ I ↔ a ∈ I :=\n  Submodule.neg_mem_iff I\n#align ideal.neg_mem_iff Ideal.neg_mem_iff\n\nprotected theorem add_mem_iff_left : b ∈ I → (a + b ∈ I ↔ a ∈ I) :=\n  Submodule.add_mem_iff_left I\n#align ideal.add_mem_iff_left Ideal.add_mem_iff_left\n\nprotected theorem add_mem_iff_right : a ∈ I → (a + b ∈ I ↔ b ∈ I) :=\n  Submodule.add_mem_iff_right I\n#align ideal.add_mem_iff_right Ideal.add_mem_iff_right\n\nprotected theorem sub_mem : a ∈ I → b ∈ I → a - b ∈ I :=\n  Submodule.sub_mem I\n#align ideal.sub_mem Ideal.sub_mem\n\ntheorem mem_span_insert' {s : Set α} {x y} : x ∈ span (insert y s) ↔ ∃ a, x + a * y ∈ span s :=\n  Submodule.mem_span_insert'\n#align ideal.mem_span_insert' Ideal.mem_span_insert'\n\n@[simp]\ntheorem span_singleton_neg (x : α) : (span {-x} : Ideal α) = span {x} := by\n  ext\n  simp only [mem_span_singleton']\n  exact ⟨fun ⟨y, h⟩ => ⟨-y, h ▸ neg_mul_comm y x⟩, fun ⟨y, h⟩ => ⟨-y, h ▸ neg_mul_neg y x⟩⟩\n#align ideal.span_singleton_neg Ideal.span_singleton_neg\n\nend Ideal\n\nend Ring\n\nsection DivisionSemiring\n\nvariable {K : Type u} [DivisionSemiring K] (I : Ideal K)\n\nnamespace Ideal\n\n/-- All ideals in a division (semi)ring are trivial. -/\ntheorem eq_bot_or_top : I = ⊥ ∨ I = ⊤ := by\n  rw [or_iff_not_imp_right]\n  change _ ≠ _ → _\n  rw [Ideal.ne_top_iff_one]\n  intro h1\n  rw [eq_bot_iff]\n  intro r hr\n  by_cases H : r = 0; · simpa\n  simpa [H, h1] using I.mul_mem_left r⁻¹ hr\n#align ideal.eq_bot_or_top Ideal.eq_bot_or_top\n\nvariable (K) in\n/-- A bijection between between (left) ideals of a division ring and `{0, 1}`, sending `⊥` to `0`\nand `⊤` to `1`. -/\ndef equivFinTwo [DecidableEq (Ideal K)] : Ideal K ≃ Fin 2 where\n  toFun := fun I ↦ if I = ⊥ then 0 else 1\n  invFun := ![⊥, ⊤]\n  left_inv := fun I ↦ by rcases eq_bot_or_top I with rfl | rfl <;> simp\n  right_inv := fun i ↦ by fin_cases i <;> simp\n\ninstance : Finite (Ideal K) := let _i := Classical.decEq (Ideal K); ⟨equivFinTwo K⟩\n\n/-- Ideals of a `DivisionSemiring` are a simple order. Thanks to the way abbreviations work,\nthis automatically gives an `IsSimpleModule K` instance. -/\ninstance isSimpleOrder : IsSimpleOrder (Ideal K) :=\n  ⟨eq_bot_or_top⟩\n#align ideal.is_simple_order Ideal.isSimpleOrder\n\ntheorem eq_bot_of_prime [h : I.IsPrime] : I = ⊥ :=\n  or_iff_not_imp_right.mp I.eq_bot_or_top h.1\n#align ideal.eq_bot_of_prime Ideal.eq_bot_of_prime\n\ntheorem bot_isMaximal : IsMaximal (⊥ : Ideal K) :=\n  ⟨⟨fun h => absurd ((eq_top_iff_one (⊤ : Ideal K)).mp rfl) (by rw [← h]; simp), fun I hI =>\n      or_iff_not_imp_left.mp (eq_bot_or_top I) (ne_of_gt hI)⟩⟩\n#align ideal.bot_is_maximal Ideal.bot_isMaximal\n\nend Ideal\n\nend DivisionSemiring\n\nsection CommRing\n\nnamespace Ideal\n\ntheorem mul_sub_mul_mem {R : Type*} [CommRing R] (I : Ideal R) {a b c d : R} (h1 : a - b ∈ I)\n    (h2 : c - d ∈ I) : a * c - b * d ∈ I := by\n  rw [show a * c - b * d = (a - b) * c + b * (c - d) by rw [sub_mul, mul_sub]; abel]\n  exact I.add_mem (I.mul_mem_right _ h1) (I.mul_mem_left _ h2)\n#align ideal.mul_sub_mul_mem Ideal.mul_sub_mul_mem\n\nend Ideal\n\nend CommRing\n\n-- TODO: consider moving the lemmas below out of the `Ring` namespace since they are\n-- about `CommSemiring`s.\nnamespace Ring\n\nvariable {R : Type*} [CommSemiring R]\n\ntheorem exists_not_isUnit_of_not_isField [Nontrivial R] (hf : ¬IsField R) :\n    ∃ (x : R) (_hx : x ≠ (0 : R)), ¬IsUnit x := by\n  have : ¬_ := fun h => hf ⟨exists_pair_ne R, mul_comm, h⟩\n  simp_rw [isUnit_iff_exists_inv]\n  push_neg at this ⊢\n  obtain ⟨x, hx, not_unit⟩ := this\n  exact ⟨x, hx, not_unit⟩\n#align ring.exists_not_is_unit_of_not_is_field Ring.exists_not_isUnit_of_not_isField\n\ntheorem not_isField_iff_exists_ideal_bot_lt_and_lt_top [Nontrivial R] :\n    ¬IsField R ↔ ∃ I : Ideal R, ⊥ < I ∧ I < ⊤ := by\n  constructor\n  · intro h\n    obtain ⟨x, nz, nu⟩ := exists_not_isUnit_of_not_isField h\n    use Ideal.span {x}\n    rw [bot_lt_iff_ne_bot, lt_top_iff_ne_top]\n    exact ⟨mt Ideal.span_singleton_eq_bot.mp nz, mt Ideal.span_singleton_eq_top.mp nu⟩\n  · rintro ⟨I, bot_lt, lt_top⟩ hf\n    obtain ⟨x, mem, ne_zero⟩ := SetLike.exists_of_lt bot_lt\n    rw [Submodule.mem_bot] at ne_zero\n    obtain ⟨y, hy⟩ := hf.mul_inv_cancel ne_zero\n    rw [lt_top_iff_ne_top, Ne.def, Ideal.eq_top_iff_one, ← hy] at lt_top\n    exact lt_top (I.mul_mem_right _ mem)\n#align ring.not_is_field_iff_exists_ideal_bot_lt_and_lt_top Ring.not_isField_iff_exists_ideal_bot_lt_and_lt_top\n\ntheorem not_isField_iff_exists_prime [Nontrivial R] :\n    ¬IsField R ↔ ∃ p : Ideal R, p ≠ ⊥ ∧ p.IsPrime :=\n  not_isField_iff_exists_ideal_bot_lt_and_lt_top.trans\n    ⟨fun ⟨I, bot_lt, lt_top⟩ =>\n      let ⟨p, hp, le_p⟩ := I.exists_le_maximal (lt_top_iff_ne_top.mp lt_top)\n      ⟨p, bot_lt_iff_ne_bot.mp (lt_of_lt_of_le bot_lt le_p), hp.isPrime⟩,\n      fun ⟨p, ne_bot, Prime⟩ => ⟨p, bot_lt_iff_ne_bot.mpr ne_bot, lt_top_iff_ne_top.mpr Prime.1⟩⟩\n#align ring.not_is_field_iff_exists_prime Ring.not_isField_iff_exists_prime\n\n/-- Also see `Ideal.isSimpleOrder` for the forward direction as an instance when `R` is a\ndivision (semi)ring.\n\nThis result actually holds for all division semirings, but we lack the predicate to state it. -/\ntheorem isField_iff_isSimpleOrder_ideal : IsField R ↔ IsSimpleOrder (Ideal R) := by\n  cases subsingleton_or_nontrivial R\n  · exact\n      ⟨fun h => (not_isField_of_subsingleton _ h).elim, fun h =>\n        (false_of_nontrivial_of_subsingleton <| Ideal R).elim⟩\n  rw [← not_iff_not, Ring.not_isField_iff_exists_ideal_bot_lt_and_lt_top, ← not_iff_not]\n  push_neg\n  simp_rw [lt_top_iff_ne_top, bot_lt_iff_ne_bot, ← or_iff_not_imp_left, not_ne_iff]\n  exact ⟨fun h => ⟨h⟩, fun h => h.2⟩\n#align ring.is_field_iff_is_simple_order_ideal Ring.isField_iff_isSimpleOrder_ideal\n\n/-- When a ring is not a field, the maximal ideals are nontrivial. -/\ntheorem ne_bot_of_isMaximal_of_not_isField [Nontrivial R] {M : Ideal R} (max : M.IsMaximal)\n    (not_field : ¬IsField R) : M ≠ ⊥ := by\n  rintro h\n  rw [h] at max\n  rcases max with ⟨⟨_h1, h2⟩⟩\n  obtain ⟨I, hIbot, hItop⟩ := not_isField_iff_exists_ideal_bot_lt_and_lt_top.mp not_field\n  exact ne_of_lt hItop (h2 I hIbot)\n#align ring.ne_bot_of_is_maximal_of_not_is_field Ring.ne_bot_of_isMaximal_of_not_isField\n\nend Ring\n\nnamespace Ideal\n\nvariable {R : Type u} [CommSemiring R] [Nontrivial R]\n\ntheorem bot_lt_of_maximal (M : Ideal R) [hm : M.IsMaximal] (non_field : ¬IsField R) : ⊥ < M := by\n  rcases Ring.not_isField_iff_exists_ideal_bot_lt_and_lt_top.1 non_field with ⟨I, Ibot, Itop⟩\n  constructor; · simp\n  intro mle\n  apply lt_irrefl (⊤ : Ideal R)\n  have : M = ⊥ := eq_bot_iff.mpr mle\n  rw [←this] at Ibot\n  rwa [hm.1.2 I Ibot] at Itop\n#align ideal.bot_lt_of_maximal Ideal.bot_lt_of_maximal\n\nend Ideal\n\nvariable {a b : α}\n\n/-- The set of non-invertible elements of a monoid. -/\ndef nonunits (α : Type u) [Monoid α] : Set α :=\n  { a | ¬IsUnit a }\n#align nonunits nonunits\n\n@[simp]\ntheorem mem_nonunits_iff [Monoid α] : a ∈ nonunits α ↔ ¬IsUnit a :=\n  Iff.rfl\n#align mem_nonunits_iff mem_nonunits_iff\n\ntheorem mul_mem_nonunits_right [CommMonoid α] : b ∈ nonunits α → a * b ∈ nonunits α :=\n  mt isUnit_of_mul_isUnit_right\n#align mul_mem_nonunits_right mul_mem_nonunits_right\n\ntheorem mul_mem_nonunits_left [CommMonoid α] : a ∈ nonunits α → a * b ∈ nonunits α :=\n  mt isUnit_of_mul_isUnit_left\n#align mul_mem_nonunits_left mul_mem_nonunits_left\n\ntheorem zero_mem_nonunits [Semiring α] : 0 ∈ nonunits α ↔ (0 : α) ≠ 1 :=\n  not_congr isUnit_zero_iff\n#align zero_mem_nonunits zero_mem_nonunits\n\n@[simp 1001] -- increased priority to appease `simpNF`\ntheorem one_not_mem_nonunits [Monoid α] : (1 : α) ∉ nonunits α :=\n  not_not_intro isUnit_one\n#align one_not_mem_nonunits one_not_mem_nonunits\n\ntheorem coe_subset_nonunits [Semiring α] {I : Ideal α} (h : I ≠ ⊤) : (I : Set α) ⊆ nonunits α :=\n  fun _x hx hu => h <| I.eq_top_of_isUnit_mem hx hu\n#align coe_subset_nonunits coe_subset_nonunits\n\ntheorem exists_max_ideal_of_mem_nonunits [CommSemiring α] (h : a ∈ nonunits α) :\n    ∃ I : Ideal α, I.IsMaximal ∧ a ∈ I := by\n  have : Ideal.span ({a} : Set α) ≠ ⊤ := by\n    intro H\n    rw [Ideal.span_singleton_eq_top] at H\n    contradiction\n  rcases Ideal.exists_le_maximal _ this with ⟨I, Imax, H⟩\n  use I, Imax\n  apply H\n  apply Ideal.subset_span\n  exact Set.mem_singleton a\n#align exists_max_ideal_of_mem_nonunits exists_max_ideal_of_mem_nonunits\n"},"dependencyBuildMode":"never"}}Content-Length: 272

{"jsonrpc":"2.0","id":3,"method":"textDocument/semanticTokens/range","params":{"textDocument":{"uri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4/Mathlib/RingTheory/Ideal/Basic.lean"},"range":{"start":{"line":807,"character":0},"end":{"line":893,"character":9}}}}Content-Length: 186

{"jsonrpc":"2.0","id":4,"method":"textDocument/foldingRange","params":{"textDocument":{"uri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4/Mathlib/RingTheory/Ideal/Basic.lean"}}}Content-Length: 162

{"jsonrpc":"2.0","id":5,"method":"$/lean/rpc/connect","params":{"uri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4/Mathlib/RingTheory/Ideal/Basic.lean"}}Content-Length: 452

{"jsonrpc":"2.0","id":6,"method":"$/lean/rpc/call","params":{"method":"Lean.Widget.getInteractiveGoals","params":{"textDocument":{"uri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4/Mathlib/RingTheory/Ideal/Basic.lean"},"position":{"line":836,"character":0}},"sessionId":"37787850261972398","textDocument":{"uri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4/Mathlib/RingTheory/Ideal/Basic.lean"},"position":{"line":836,"character":0}}}Content-Length: 455

{"jsonrpc":"2.0","id":7,"method":"$/lean/rpc/call","params":{"method":"Lean.Widget.getInteractiveTermGoal","params":{"textDocument":{"uri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4/Mathlib/RingTheory/Ideal/Basic.lean"},"position":{"line":836,"character":0}},"sessionId":"37787850261972398","textDocument":{"uri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4/Mathlib/RingTheory/Ideal/Basic.lean"},"position":{"line":836,"character":0}}}Content-Length: 413

{"jsonrpc":"2.0","id":8,"method":"$/lean/rpc/call","params":{"method":"Lean.Widget.getWidgets","params":{"uri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4/Mathlib/RingTheory/Ideal/Basic.lean","line":836,"character":0},"sessionId":"37787850261972398","textDocument":{"uri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4/Mathlib/RingTheory/Ideal/Basic.lean"},"position":{"line":836,"character":0}}}Content-Length: 342

{"jsonrpc":"2.0","id":9,"method":"$/lean/rpc/call","params":{"method":"Lean.Widget.getInteractiveDiagnostics","params":{"lineRange":{"start":836,"end":837}},"sessionId":"37787850261972398","textDocument":{"uri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4/Mathlib/RingTheory/Ideal/Basic.lean"},"position":{"line":836,"character":0}}}Content-Length: 194

{"jsonrpc":"2.0","id":10,"method":"textDocument/semanticTokens/full","params":{"textDocument":{"uri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4/Mathlib/RingTheory/Ideal/Basic.lean"}}}Content-Length: 453

{"jsonrpc":"2.0","id":11,"method":"$/lean/rpc/call","params":{"method":"Lean.Widget.getInteractiveGoals","params":{"textDocument":{"uri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4/Mathlib/RingTheory/Ideal/Basic.lean"},"position":{"line":836,"character":0}},"sessionId":"37787850261972398","textDocument":{"uri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4/Mathlib/RingTheory/Ideal/Basic.lean"},"position":{"line":836,"character":0}}}Content-Length: 456

{"jsonrpc":"2.0","id":12,"method":"$/lean/rpc/call","params":{"method":"Lean.Widget.getInteractiveTermGoal","params":{"textDocument":{"uri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4/Mathlib/RingTheory/Ideal/Basic.lean"},"position":{"line":836,"character":0}},"sessionId":"37787850261972398","textDocument":{"uri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4/Mathlib/RingTheory/Ideal/Basic.lean"},"position":{"line":836,"character":0}}}Content-Length: 414

{"jsonrpc":"2.0","id":13,"method":"$/lean/rpc/call","params":{"method":"Lean.Widget.getWidgets","params":{"uri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4/Mathlib/RingTheory/Ideal/Basic.lean","line":836,"character":0},"sessionId":"37787850261972398","textDocument":{"uri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4/Mathlib/RingTheory/Ideal/Basic.lean"},"position":{"line":836,"character":0}}}Content-Length: 343

{"jsonrpc":"2.0","id":14,"method":"$/lean/rpc/call","params":{"method":"Lean.Widget.getInteractiveDiagnostics","params":{"lineRange":{"start":836,"end":837}},"sessionId":"37787850261972398","textDocument":{"uri":"file:///c%3A/Users/Xavier%20Xarles/mathlib4/mathlib4/Mathlib/RingTheory/Ideal/Basic.lean"},"position":{"line":836,"character":0}}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/setTrace","params":{"value":"off"}}