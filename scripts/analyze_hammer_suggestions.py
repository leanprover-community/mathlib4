#!/usr/bin/env python3
"""
Analyze hammer suggestions from Lean build output.

This script processes the output of `lake build --no-build` to extract and analyze
tactic replacement suggestions generated by Lean's hammer tactics.

Usage:
    # Analyze all of Mathlib with default tactics (simp_all and grind)
    ./scripts/analyze_hammer_suggestions.py

    # Analyze a specific module
    ./scripts/analyze_hammer_suggestions.py Mathlib.Data.List.Basic

    # Enable specific tactics (use --no-<tactic> to disable)
    ./scripts/analyze_hammer_suggestions.py --aesop --canonical

    # Disable default tactics
    ./scripts/analyze_hammer_suggestions.py --no-simp-all --no-grind

    # Output raw location:tactic pairs for further processing
    ./scripts/analyze_hammer_suggestions.py --raw

By default, only simp_all and grind are enabled. Use --aesop and --canonical to
enable additional tactics. The script analyzes which tactics can replace existing
tactics at each location, both with and without the +suggestions flag.

Output includes:
  - Count of locations solvable by each subset of enabled tactics
  - Grid format showing binary patterns (1=tactic works, 0=doesn't)
  - Separate tables for base tactics and +suggestions variants

Normalization:
  - Removes 'try ' prefix from tactics
  - Removes '?' modifier (e.g., 'simp_all?' -> 'simp_all')
  - Removes dagger symbol '✝' from tactic names
"""

import argparse
import re
import subprocess
from collections import defaultdict
from itertools import product


def normalize_tactic(tactic):
    """Normalize tactic name, handling +suggestions variants and try prefix."""
    # Remove dagger symbol
    tactic = tactic.replace('✝', '')
    tactic = tactic.strip()

    # Remove 'try ' prefix if present
    if tactic.startswith('try '):
        tactic = tactic[4:].strip()

    # Remove '?' modifier (but keep it before +suggestions)
    # e.g., "simp_all? +suggestions" -> "simp_all +suggestions"
    tactic = tactic.replace('? +', ' +')
    # Remove trailing '?' if present
    if tactic.endswith('?'):
        tactic = tactic[:-1].strip()

    return tactic


def extract_suggestions(target):
    """Run lake build and extract hammer suggestions."""
    result = subprocess.run(
        ['lake', 'build', '--no-build', target],
        capture_output=True,
        text=True
    )

    output = result.stdout + result.stderr

    # Pattern to match info messages with "can be replaced with"
    pattern = r'info: ([^:]+):(\d+):(\d+):.*? can be replaced with `([^`]+)`'
    matches = re.findall(pattern, output, re.DOTALL)

    # Group suggestions by location
    locations = defaultdict(set)
    for filepath, row, col, replacement in matches:
        location = f"{filepath}:{row}:{col}"
        normalized = normalize_tactic(replacement)
        locations[location].add(normalized)

    return locations


def output_raw(locations):
    """Output raw location:tactic pairs."""
    for location, tactics in sorted(locations.items()):
        for tactic in sorted(tactics):
            print(f"{location}:{tactic}")


def check_tactic_support(locations, tactics):
    """
    For each location, determine which tactics from the given set are suggested.
    Returns a dict mapping location -> set of supported tactics.
    """
    result = {}
    for location, suggestions in locations.items():
        supported = set()
        for tactic in tactics:
            if tactic in suggestions:
                supported.add(tactic)
        result[location] = frozenset(supported)

    return result


def count_subsets(tactic_support):
    """
    Count how many locations support each subset of tactics.
    Returns a dict mapping frozenset -> count.
    """
    counts = defaultdict(int)
    for supported in tactic_support.values():
        counts[supported] += 1

    return counts


def format_subset(subset, tactics):
    """Format a subset as a binary string for display."""
    return ''.join('1' if t in subset else '0' for t in tactics)


def print_table(counts, tactics, title):
    """Print a formatted table of counts."""
    print(f"\n{title}")
    print("=" * len(title))

    # Generate all possible subsets
    all_subsets = []
    for bits in product([0, 1], repeat=len(tactics)):
        subset = frozenset(t for t, b in zip(tactics, bits) if b)
        all_subsets.append(subset)

    # Sort subsets by binary representation for consistent display
    all_subsets.sort(key=lambda s: format_subset(s, tactics), reverse=True)

    # Print header
    print(f"\n{'Subset':<40} {'Count':>8}")
    print("-" * 50)

    total = 0
    for subset in all_subsets:
        count = counts.get(subset, 0)
        total += count
        if count > 0 or subset == frozenset():  # Show zero count for empty set
            subset_str = '{' + ', '.join(sorted(subset)) + '}' if subset else '{}'
            print(f"{subset_str:<40} {count:>8}")

    print("-" * 50)
    print(f"{'Total locations':<40} {total:>8}")

    # Print grid format
    print(f"\n{title} - Grid Format")
    print("=" * len(title))

    # Create a mapping from binary pattern to count
    pattern_counts = {}
    for subset in all_subsets:
        pattern = format_subset(subset, tactics)
        pattern_counts[pattern] = counts.get(subset, 0)

    # Print all combinations
    num_tactics = len(tactics)
    num_combinations = 2 ** num_tactics
    print(f"\nTactics: {', '.join(tactics)}")
    print("Binary pattern: " + "".join(f"{t[0]}" for t in tactics))
    print()

    # Group into rows of 4 for readability
    for i in range(0, num_combinations, 4):
        for j in range(min(4, num_combinations - i)):
            combo_idx = num_combinations - 1 - (i + j)  # Count down from all 1s
            bits = format(combo_idx, f'0{num_tactics}b')
            count = pattern_counts.get(bits, 0)
            subset_names = [tactics[k] for k in range(num_tactics) if bits[k] == '1']
            subset_str = '{' + ','.join(subset_names) + '}' if subset_names else '{}'
            print(f"{bits} {count:>6}  {subset_str}")
        if i + 4 < num_combinations:
            print()


def output_analysis(locations, enabled_tactics):
    """Output analysis tables."""
    print(f"Found {len(locations)} unique locations with suggestions")

    # Filter to only enabled tactics
    base_tactics = [t for t in ['simp_all', 'aesop', 'canonical', 'grind'] if enabled_tactics[t]]

    if not base_tactics:
        print("\nNo tactics enabled. Use --simp-all, --aesop, --canonical, or --grind to enable tactics.")
        return

    print(f"\nAnalyzing tactics: {', '.join(base_tactics)}")

    # Tactics with +suggestions
    suggestions_tactics = [f'{t} +suggestions' for t in base_tactics]

    # Analyze base tactics
    base_support = check_tactic_support(locations, base_tactics)
    base_counts = count_subsets(base_support)
    print_table(base_counts, base_tactics, "Counts without +suggestions")

    # Analyze +suggestions tactics
    sugg_support = check_tactic_support(locations, suggestions_tactics)
    sugg_counts = count_subsets(sugg_support)
    print_table(sugg_counts, suggestions_tactics, "Counts with +suggestions")


def main():
    parser = argparse.ArgumentParser(
        description='Analyze hammer suggestions from Lean build output'
    )
    parser.add_argument(
        'target',
        nargs='?',
        default='Mathlib',
        help='Build target to analyze (default: Mathlib)'
    )
    parser.add_argument(
        '--raw',
        action='store_true',
        help='Output raw location:tactic pairs instead of analysis tables'
    )

    # Tactic enable/disable flags (simp_all and grind enabled by default)
    parser.add_argument(
        '--simp-all',
        action=argparse.BooleanOptionalAction,
        default=True,
        help='Include simp_all in analysis (default: enabled)'
    )
    parser.add_argument(
        '--aesop',
        action=argparse.BooleanOptionalAction,
        default=False,
        help='Include aesop in analysis (default: disabled)'
    )
    parser.add_argument(
        '--canonical',
        action=argparse.BooleanOptionalAction,
        default=False,
        help='Include canonical in analysis (default: disabled)'
    )
    parser.add_argument(
        '--grind',
        action=argparse.BooleanOptionalAction,
        default=True,
        help='Include grind in analysis (default: enabled)'
    )

    args = parser.parse_args()

    # Build enabled tactics dict (normalize argument names to tactic names)
    enabled_tactics = {
        'simp_all': args.simp_all,
        'aesop': args.aesop,
        'canonical': args.canonical,
        'grind': args.grind
    }

    # Extract all suggestions
    locations = extract_suggestions(args.target)

    if args.raw:
        output_raw(locations)
    else:
        print(f"Analyzing hammer suggestions for {args.target}...")
        print("=" * 70)
        print()
        output_analysis(locations, enabled_tactics)


if __name__ == '__main__':
    main()
