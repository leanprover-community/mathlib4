import Mathlib.Util.Frontend
import Mathlib.Control.Basic
import Mathlib.Lean.Expr.Basic
import Mathlib.Tactic.Common
import Mathlib.Tactic.ToExpr
import Mathlib.Util.Cli
import Aesop
import Lean.Util.Trace

open Lean Core Elab IO Meta Term Tactic -- All the monads!

set_option autoImplicit true

/--
Compile the designated module, and run a monadic function with each new `ConstantInfo`,
with the `Environment` as it was before the command which created that declaration.

(Internal declarations according to `Name.isBlackListed` are skipped.)
-/
def runAtDecls (mod : Name) (tac : ConstantInfo → MetaM (Option α)) :
    IO (List (ConstantInfo × α)) := do
  let fileName := (← findLean mod).toString
  let steps ← compileModule mod
  let targets := steps.bind fun c => c.diff.map fun i => (c, i)

  targets.filterMapM fun (cmd, ci) => do
    for m in cmd.msgs do IO.eprintln (bombEmoji ++ (← m.data.toString))
    unless cmd.msgs.isEmpty do
      throw <| IO.userError s!"Unexpected messages in: {mod} during elaboration of {cmd.stx}"

    let ctx := { fileName := fileName, options := {}, fileMap := default }
    let state := { env := cmd.before }
    -- From `IO` to `CoreM`:
    Prod.fst <$> (CoreM.toIO · ctx state) do
      if ← ci.name.isBlackListed then
        pure none
      else
        -- From `CoreM` to `MetaM`:
        MetaM.run' (ctx := {}) (s := {}) do
          match ← tac ci with
          | some r => pure (ci, r)
          | none => pure none

inductive ResultType
| failure
| subgoals
| notDefEq
| success
deriving Repr, BEq

instance : ToString ResultType where
  toString := fun
  | .failure => "failure"
  | .subgoals => "subgoals"
  | .notDefEq => "notDefEq"
  | .success => "success"

structure Result where
  type : ResultType
  seconds : Float
  heartbeats : Nat

/--
Compile the designated module, select declarations satisfying a predicate,
and run a tactic on the type of each declaration.
-/
def runTacticAtDecls (mod : Name) (decls : ConstantInfo → CoreM Bool) (tac : TacticM Unit) :
    IO (List (ConstantInfo × Result)) := do
  runAtDecls mod fun ci => do
    if ! (← decls ci) then return none
    let g ← mkFreshExprMVar ci.type
    -- From `MetaM` to `TermElabM`
    let ((gs, seconds), heartbeats) ← withHeartbeats <| withSeconds <|
      try? <| TermElabM.run' do
        -- From `TermElabM` to `TacticM`!
        Tactic.run g.mvarId! tac
    let type : ResultType ← match gs with
    | none => pure .failure
    | some (_ :: _) => pure .subgoals
    | some [] =>
      match ci.value? with
      | none => pure .success
      | some v =>
        if ← isProp ci.type then
          pure .success
        else
        match ← try? (isDefEq g v) with
        | none
          -- In this case we should perhaps return an "uncertain" value.
          -- The problem is that `v` may contain constants generated by the simplifier
          -- during elaboration of the original proof,
          -- and which aren't in the current environment, so we can't really compare `g` and `v`
        | some false => pure .notDefEq
        | some true => pure .success
    return some ⟨type, seconds, heartbeats⟩


def useAesop : TacticM Unit := do evalTactic (← `(tactic| aesop))
def useExact? : TacticM Unit := do evalTactic (← `(tactic| exact?))
def useRfl : TacticM Unit := do evalTactic (← `(tactic| intros; rfl))
def useSimpAll : TacticM Unit := do evalTactic (← `(tactic| intros; simp_all))

open Cli System

def tacticBenchmarkMain (args : Cli.Parsed) : IO UInt32 := do
  let module := args.positionalArg! "module" |>.as! Name
  searchPathRef.set compileTimeSearchPath%
  let tac ←
    if args.hasFlag "aesop" then pure useAesop else
    if args.hasFlag "exact" then pure useExact? else
    if args.hasFlag "rfl" then pure useRfl else
    if args.hasFlag "simp_all" then pure useSimpAll else
    throw <| IO.userError "Specify a tactic, e.g. `--aesop`"
  let result ← runTacticAtDecls module (fun _ => pure true) tac
  IO.println s!"{module} {result.map (·.2.type) |>.count .success} {result.length}"
  for (ci, ⟨type, seconds, heartbeats⟩) in result do
    IO.println <| (if type == .success then checkEmoji else crossEmoji) ++ " " ++ ci.name.toString ++
      s!" ({seconds}s) ({heartbeats} heartbeats)"
  return 0

/-- Setting up command line options and help text for `lake exe tactic_benchmark`. -/
def tactic_benchmark : Cmd := `[Cli|
  tactic_benchmark VIA tacticBenchmarkMain; ["0.0.1"]
  "Run a customisable tactic at all declarations in a file."

  FLAGS:
    "aesop";       "Use `aesop`."
    "exact";       "Use `exact?`."
    "rfl";         "Use `intros; rfl`."
    "simp_all";    "Use `intros; simp_all`."

  ARGS:
    module : Name; "Lean module to compile and export InfoTrees."
]

/-- `lake exe tactic_benchmark` -/
def main (args : List String) : IO UInt32 :=
  tactic_benchmark.validate args
