import Mathlib.Order.Defs.PartialOrder
import Mathlib.Order.Notation
import Mathlib.Tactic.ToAdditive

variable {α : Type} [PartialOrder α] (a b c : α)

-- test that we can translate between structures, reordering the arguments of the fields
class SemilatticeInf (α : Type) extends PartialOrder α, Min α where
  le_inf : ∀ a b c : α, a ≤ b → a ≤ c → a ≤ b ⊓ c

class SemilatticeSup (α : Type) extends PartialOrder α, Max α where
  protected sup_le : ∀ a b c : α, a ≤ c → b ≤ c → a ⊔ b ≤ c

attribute [to_dual] SemilatticeInf
attribute [to_dual existing] SemilatticeSup.sup_le

@[to_dual]
lemma SemilatticeInf.le_inf' {α : Type} [SemilatticeInf α] (a b c : α) : a ≤ b → a ≤ c → a ≤ b ⊓ c :=
  SemilatticeInf.le_inf a b c

@[to_dual]
lemma SemilatticeSup.sup_le' {α : Type} [SemilatticeSup α] (a b c : α) : a ≤ c → b ≤ c → a ⊔ b ≤ c :=
  SemilatticeSup.sup_le a b c

structure Lattice (α : Type) extends SemilatticeInf α, SemilatticeSup α

attribute [to_dual existing] Lattice.toSemilatticeInf

-- we still cannot reorder arguments of arguments, so `SemilatticeInf.mk` is not translatable
/--
error: @[to_dual] failed. The translated value is not type correct. For help, see the docstring of `to_additive`, section `Troubleshooting`. Failed to add declaration
instSemilatticeSupOfForallLeForallMax:
Application type mismatch: The argument
  le_inf
has type
  ∀ (a b c : α), b ≤ a → c ≤ a → b ⊔ c ≤ a
but is expected to have type
  ∀ (a b c : α), a ≤ c → b ≤ c → a ⊔ b ≤ c
in the application
  { toPartialOrder := inst✝¹, toMax := inst✝, sup_le := le_inf }
-/
#guard_msgs in
@[to_dual]
instance [Min α] (le_inf : ∀ a b c : α, a ≤ b → a ≤ c → a ≤ b ⊓ c) : SemilatticeInf α where
  le_inf


-- If the given `reorder` is the same as the autogenerated one, we get a linter warning:
/--
warning: `to_dual` correctly autogenerated the `(reorder := ...)` argument for le_imp_le.
You may remove the `(reorder := ...)` argument.

Note: This linter can be disabled with `set_option linter.translateReorder false`
-/
#guard_msgs in
@[to_dual self (reorder := a b)]
theorem le_imp_le : a ≤ b → a ≤ b := id

-- The comparison on `reorder`s can see that `a b` is the same as `b a`:
/--
warning: `to_dual` correctly autogenerated the `(reorder := ...)` argument for le_imp_le'.
You may remove the `(reorder := ...)` argument.

Note: This linter can be disabled with `set_option linter.translateReorder false`
-/
#guard_msgs in
@[to_dual self (reorder := b a)]
theorem le_imp_le' : a ≤ b → a ≤ b := id

-- It is possible to overwrite the autogenerated `reorder`:
/--
error: `to_dual` validation failed: expected
  ∀ {α : Type} (a : α) [inst : PartialOrder α] (b : α), b ≤ a → b ≤ a
but 'le_imp_le''' has type
  ∀ {α : Type} [inst : PartialOrder α] (a b : α), a ≤ b → a ≤ b
-/
#guard_msgs in
@[to_dual self (reorder := 2 3)]
theorem le_imp_le'' : a ≤ b → a ≤ b := id

-- We can even overwrite it with the empty `reorder`:
/--
warning: `to_dual self` is redundant when none of the arguments are reordered.
Please remove the attribute, or provide an explicit `(reorder := ...)` argument.
If you need to give a hint to `to_dual` to translate expressions involving `le_imp_le'''`,
use `to_dual_do_translate` instead

Note: This linter can be disabled with `set_option linter.translateRedundant false`
---
error: `to_dual` validation failed: expected
  ∀ {α : Type} [inst : PartialOrder α] (a b : α), b ≤ a → b ≤ a
but 'le_imp_le'''' has type
  ∀ {α : Type} [inst : PartialOrder α] (a b : α), a ≤ b → a ≤ b
-/
#guard_msgs in
@[to_dual self (reorder := )]
theorem le_imp_le''' : a ≤ b → a ≤ b := id

-- Test a larger permutation:

theorem refl₁ (a b c d e : Nat) : a + b + c + d + e = a + b + c + d + e := rfl

@[to_dual existing refl₁]
theorem refl₂ (b c a e d : Nat) : a + b + c + d + e = a + b + c + d + e := rfl

-- Test that we do not translate numerals like we do in `@[to_additive]`
/--
warning: `to_dual self` is redundant when none of the arguments are reordered.
Please remove the attribute, or provide an explicit `(reorder := ...)` argument.
If you need to give a hint to `to_dual` to translate expressions involving `one_le_one`,
use `to_dual_do_translate` instead

Note: This linter can be disabled with `set_option linter.translateRedundant false`
-/
#guard_msgs in
@[to_dual self]
theorem one_le_one [One α] : (1 : α) ≤ 1 := le_rfl

-- Test the name generated by `to_dual none`
@[to_dual none]
theorem bot_eq_top {α : Type} [Bot α] [Top α] : (⊤ : α) = ⊥ → (⊤ : α) = ⊥ := id

/-- info: bot_eq_top._to_dual_1 {α : Type} [Top α] [Bot α] : ⊥ = ⊤ → ⊥ = ⊤ -/
#guard_msgs in
#check bot_eq_top._to_dual_1

/- Test the translation of auxLemmas.
`_proof_i` lemmas are translated, but `_simp_i` lemmas are unfolded. -/
@[to_dual lt_le_trans]
theorem le_lt_trans (h₁ : a ≤ b) (h₂ : b < c) : a < c := by
  grind

theorem le_refl': ∀ a : α, a ≤ a := by
  simp

/--
info: fun {α} [PartialOrder α] a b c h₁ h₂ => lt_le_trans._proof_1_1 a b c h₁ h₂
---
info: fun {α} [PartialOrder α] => of_eq_true (Eq.trans (forall_congr fun a => le_refl._simp_1 a) (implies_true α))
-/
#guard_msgs in
run_meta
  Lean.logInfo (← Lean.getConstInfo ``lt_le_trans).value!
  Lean.logInfo (← Lean.getConstInfo ``le_refl').value!

/-! Test the `to_dual_insert_cast` framework. -/

@[to_dual lt_sum_eq_of_le']
def lt_sum_eq_of_le [DecidableLE α] {a b : α} (hab : a ≤ b) :
    a < b ⊕' a = b :=
  if hba : b ≤ a then PSum.inr (le_antisymm hab hba) else PSum.inl (lt_of_le_not_ge hab hba)

@[to_dual DecidableLE1_dual]
def DecidableLE1 (h : ∀ a b : α, Decidable (a ≤ b)) : DecidableLE α := fun a b ↦ h a b

@[to_dual DecidableLE2_dual]
def DecidableLE2 (h : ∀ a b : α, Decidable (a ≤ b)) : DecidableLE α := id h

-- Not yet supported because it probably won't show up in practice
-- (though it wouldn't be too hard to fix `unfoldConsts` to support this)
/--
error: @[to_dual] failed to insert a cast to make `fun {α} [PartialOrder α] h =>
  h` have type `{α : Type} → [inst : PartialOrder α] → DecidableLE α → (a b : α) → Decidable (a ≤ b)`

fun {α} [PartialOrder α] h =>
  h : {α : Type} →
  [inst : PartialOrder α] →
    DecidableLE α →
      DecidableLE
        α does not have type {α : Type} → [inst : PartialOrder α] → DecidableLE α → (a b : α) → Decidable (a ≤ b).
-/
#guard_msgs in
@[to_dual DecidableLE3_dual]
def DecidableLE3 (h : DecidableLE α) : ∀ a b : α, Decidable (a ≤ b) := h

@[to_dual DecidableLE4_dual]
def DecidableLE4 (h : DecidableLE α) (a b : α) : Decidable (a ≤ b) := h a b

-- The arguments to `h` have been introduced, and swapped:
/--
info: fun {α} [PartialOrder α] h a b => h b a
---
info: fun {α} [PartialOrder α] h => id fun a b => h b a
---
info: fun {α} [PartialOrder α] h a b => h b a
-/
#guard_msgs in
open Lean in
run_meta
  logInfo m!"{(← getConstInfo ``DecidableLE1_dual).value!}"
  logInfo m!"{(← getConstInfo ``DecidableLE2_dual).value!}"
  logInfo m!"{(← getConstInfo ``DecidableLE4_dual).value!}"

-- The arguments to `inst✝` have been swapped:
/--
info: @dite (a < b ⊕' a = b) (b ≤ a) (inst✝ b a) (fun hba => PSum.inr ⋯) fun hba => PSum.inl ⋯
---
info: @dite (b < a ⊕' a = b) (a ≤ b) (inst✝ a b) (fun hba => PSum.inr ⋯) fun hba => PSum.inl ⋯
-/
#guard_msgs in
open Lean Meta in
run_meta
  lambdaTelescope (← getConstInfo ``lt_sum_eq_of_le).value! fun _ => (logInfo m!"{·.setPPExplicit true}")
  lambdaTelescope (← getConstInfo ``lt_sum_eq_of_le').value! fun _ => (logInfo m!"{·.setPPExplicit true}")

/-- `Ico a b` is the left-closed right-open interval $[a, b)$. -/
def Cov.Ico (a b : α) := fun x ↦ a ⩿ x ∧ x ⋖ b

/-- `Ioc a b` is the left-open right-closed interval $(a, b]$. -/
@[to_dual existing (reorder := a b)]
def Cov.Ioc (a b : α) := fun x ↦ a ⋖ x ∧ x ⩿ b

to_dual_insert_cast Cov.Ico := by grind

-- The dual theorems `mem_Ioc'` does not hold by reflexivity.
-- To prove it, some rewrites have been added to the proof of `mem_Ico`.
@[to_dual mem_Ioc']
theorem mem_Ico {a b x : α} : Cov.Ico a b x ↔ (a ≤ x ∧ ∀ ⦃c⦄, a < c → ¬c < x) ∧ x ⋖ b := Iff.rfl
