import Mathlib.Order.Defs.PartialOrder
import Mathlib.Order.Notation
import Mathlib.Tactic.ToAdditive

variable {α : Type} [PartialOrder α] (a b c : α)

-- test that we can translate between structures, reordering the arguments of the fields
class SemilatticeInf (α : Type) extends PartialOrder α, Min α where
  le_inf : ∀ a b c : α, a ≤ b → a ≤ c → a ≤ b ⊓ c

class SemilatticeSup (α : Type) extends PartialOrder α, Max α where
  protected sup_le : ∀ a b c : α, a ≤ c → b ≤ c → a ⊔ b ≤ c

attribute [to_dual] SemilatticeInf
attribute [to_dual existing] SemilatticeSup.sup_le

@[to_dual]
lemma SemilatticeInf.le_inf' {α : Type} [SemilatticeInf α] (a b c : α) : a ≤ b → a ≤ c → a ≤ b ⊓ c :=
  SemilatticeInf.le_inf a b c

@[to_dual]
lemma SemilatticeSup.sup_le' {α : Type} [SemilatticeSup α] (a b c : α) : a ≤ c → b ≤ c → a ⊔ b ≤ c :=
  SemilatticeSup.sup_le a b c

structure Lattice (α : Type) extends SemilatticeInf α, SemilatticeSup α

attribute [to_dual existing] Lattice.toSemilatticeInf

-- we still cannot reorder arguments of arguments, so `SemilatticeInf.mk` is not translatable
/--
error: @[to_dual] failed. The translated value is not type correct. For help, see the docstring of `to_additive`, section `Troubleshooting`. Failed to add declaration
instSemilatticeSupOfForallLeForallMax:
Application type mismatch: The argument
  le_inf
has type
  ∀ (a b c : α), b ≤ a → c ≤ a → b ⊔ c ≤ a
but is expected to have type
  ∀ (a b c : α), a ≤ c → b ≤ c → a ⊔ b ≤ c
in the application
  { toPartialOrder := inst✝¹, toMax := inst✝, sup_le := le_inf }
-/
#guard_msgs in
@[to_dual]
instance [Min α] (le_inf : ∀ a b c : α, a ≤ b → a ≤ c → a ≤ b ⊓ c) : SemilatticeInf α where
  le_inf


-- If the given `reorder` is the same as the autogenerated one, we get a linter warning:
/--
warning: `to_dual` correctly autogenerated the `(reorder := ...)` argument for le_imp_le.
You may remove the `(reorder := ...)` argument.

Note: This linter can be disabled with `set_option linter.translateReorder false`
-/
#guard_msgs in
@[to_dual self (reorder := a b)]
theorem le_imp_le : a ≤ b → a ≤ b := id

-- The comparison on `reorder`s can see that `a b` is the same as `b a`:
/--
warning: `to_dual` correctly autogenerated the `(reorder := ...)` argument for le_imp_le'.
You may remove the `(reorder := ...)` argument.

Note: This linter can be disabled with `set_option linter.translateReorder false`
-/
#guard_msgs in
@[to_dual self (reorder := b a)]
theorem le_imp_le' : a ≤ b → a ≤ b := id

-- It is possible to overwrite the autogenerated `reorder`:
/--
error: `to_dual` validation failed: expected
  ∀ {α : Type} (a : α) [inst : PartialOrder α] (b : α), b ≤ a → b ≤ a
but 'le_imp_le''' has type
  ∀ {α : Type} [inst : PartialOrder α] (a b : α), a ≤ b → a ≤ b
-/
#guard_msgs in
@[to_dual self (reorder := 2 3)]
theorem le_imp_le'' : a ≤ b → a ≤ b := id

-- We can even overwrite it with the empty `reorder`:
/--
warning: `to_dual self` is redundant when none of the arguments are reordered.
Please remove the attribute, or provide an explicit `(reorder := ...)` argument.
If you need to give a hint to `to_dual` to translate expressions involving `le_imp_le'''`,
use `to_dual_do_translate` instead

Note: This linter can be disabled with `set_option linter.translateRedundant false`
---
error: `to_dual` validation failed: expected
  ∀ {α : Type} [inst : PartialOrder α] (a b : α), b ≤ a → b ≤ a
but 'le_imp_le'''' has type
  ∀ {α : Type} [inst : PartialOrder α] (a b : α), a ≤ b → a ≤ b
-/
#guard_msgs in
@[to_dual self (reorder := )]
theorem le_imp_le''' : a ≤ b → a ≤ b := id

-- Test a larger permutation:

theorem refl₁ (a b c d e : Nat) : a + b + c + d + e = a + b + c + d + e := rfl

@[to_dual existing refl₁]
theorem refl₂ (b c a e d : Nat) : a + b + c + d + e = a + b + c + d + e := rfl

-- Test that we do not translate numerals like we do in `@[to_additive]`
/--
warning: `to_dual self` is redundant when none of the arguments are reordered.
Please remove the attribute, or provide an explicit `(reorder := ...)` argument.
If you need to give a hint to `to_dual` to translate expressions involving `one_le_one`,
use `to_dual_do_translate` instead

Note: This linter can be disabled with `set_option linter.translateRedundant false`
-/
#guard_msgs in
@[to_dual self]
theorem one_le_one [One α] : (1 : α) ≤ 1 := le_rfl

-- Test the name generated by `to_dual none`
@[to_dual none]
theorem bot_eq_top {α : Type} [Bot α] [Top α] : (⊤ : α) = ⊥ → (⊤ : α) = ⊥ := id

/-- info: bot_eq_top._to_dual_1 {α : Type} [Top α] [Bot α] : ⊥ = ⊤ → ⊥ = ⊤ -/
#guard_msgs in
#check bot_eq_top._to_dual_1

/- Test the translation of auxLemmas.
`_proof_i` lemmas are translated, but `_simp_i` lemmas are unfolded. -/
@[to_dual lt_le_trans]
theorem le_lt_trans (h₁ : a ≤ b) (h₂ : b < c) : a < c := by
  grind

theorem le_refl': ∀ a : α, a ≤ a := by
  simp

/--
info: fun {α} [PartialOrder α] a b c h₁ h₂ => lt_le_trans._proof_1_1 a b c h₁ h₂
---
info: fun {α} [PartialOrder α] => of_eq_true (Eq.trans (forall_congr fun a => le_refl._simp_1 a) (implies_true α))
-/
#guard_msgs in
run_meta
  Lean.logInfo (← Lean.getConstInfo ``lt_le_trans).value!
  Lean.logInfo (← Lean.getConstInfo ``le_refl').value!

-- Test that we do not translate the order on `Prop`
instance Prop.le : LE Prop :=
  ⟨(· → ·)⟩

@[to_dual le_of_imp']
theorem Prop.le_of_imp (_h : a ≤ b) {p q : Prop} : (p → q) → p ≤ q := id

-- Dualize `a ≤ b` but not `p ≤ q`
/--
info: «Prop».le_of_imp' {α : Type} [PartialOrder α] (a b : α) (_h : b ≤ a) {p q : Prop} : (p → q) → p ≤ q
-/
#guard_msgs in
#check Prop.le_of_imp'
