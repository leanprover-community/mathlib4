import Mathlib.Tactic.Basic
import Mathlib.Tactic.Conv
import Mathlib.Tactic.Linter.Multigoal
import Mathlib.Util.SleepHeartbeats
import Mathlib.Tactic.SuccessIfFailWithMsg

-- The warning generated by `linter.style.multiGoal` is not suppressed by `#guard_msgs`,
-- because the linter is run on `#guard_msgs` itself. This is a known issue, see e.g.
-- https://leanprover.zulipchat.com/#narrow/stream/348111-batteries/topic/unreachableTactic.20linter.20not.20suppressed.20by.20.60.23guard_msgs.60
-- We jump through an extra hoop here to silence the warning.
set_option linter.style.multiGoal false

-- A deactivated linter does nothing.
example : True := by
  by_cases 0 = 0
  exact .intro
  exact .intro

#guard_msgs(drop warning) in
set_option linter.style.multiGoal true in
/--
warning: There are 2 unclosed goals before 'exact .intro' and at least one remaining goal afterwards.
Please focus on the current goal, for instance using `·` (typed as "\.").
note: this linter can be disabled with `set_option linter.style.multiGoal false`
-/
#guard_msgs in
example : True := by
  by_cases 0 = 0
  exact .intro
  exact .intro

#guard_msgs(drop warning) in
set_option linter.style.multiGoal true in
/--
warning: There are 2 unclosed goals before 'assumption' and at least one remaining goal afterwards.
Please focus on the current goal, for instance using `·` (typed as "\.").
note: this linter can be disabled with `set_option linter.style.multiGoal false`
-/
#guard_msgs in
example {n : Nat} (hn : n = 0) : n + 0 = 0 := by
  conv =>
    congr
    rw [← Nat.add_zero 0]
  conv_lhs =>
    congr
    rw [← Nat.add_zero n]
    rfl
  conv_rhs =>
    rw [← Nat.add_zero 0]
    congr
    rfl
    rfl
  by_cases 0 = 0
  assumption
  assumption

set_option linter.unusedTactic false in
#guard_msgs(drop warning) in
set_option linter.style.multiGoal true in
/--
warning: There are 2 unclosed goals before 'rfl' and at least one remaining goal afterwards.
Please focus on the current goal, for instance using `·` (typed as "\.").
note: this linter can be disabled with `set_option linter.style.multiGoal false`
-/
#guard_msgs in
example (p : Prop) (hp : p) : (0 = 0 ∧ p) ∨ 0 = 0 := by
  iterate left; decide
  repeat' left; decide
  refine Or.inl ⟨?_, ?_⟩
  rfl
  assumption

#guard_msgs(drop warning) in
set_option linter.style.multiGoal true in
/--
warning: There are 3 unclosed goals before 'rfl' and at least one remaining goal afterwards.
Please focus on the current goal, for instance using `·` (typed as "\.").
note: this linter can be disabled with `set_option linter.style.multiGoal false`
---
warning: There are 2 unclosed goals before 'trivial' and at least one remaining goal afterwards.
Please focus on the current goal, for instance using `·` (typed as "\.").
note: this linter can be disabled with `set_option linter.style.multiGoal false`
-/
#guard_msgs in
example : 0 = 0 ∧ 0 = 0 ∧ 0 = 0 := by
  refine ⟨?_, ?_, ?_⟩
  rfl
  trivial
  rfl

example (p : Bool) : 0 = 0 := by
  cases p
  case' false => rfl
  case' true => rfl

#guard_msgs in
-- `assumption'` is allowed, as it is useful precisely when there are multiple active goals.
example (p : Bool) (f : False) {h : 0 = 0} : 0 = 0 ∧ 0 = 1 := by
  cases p <;>
  constructor
  assumption'
  any_goals cases f

#guard_msgs in
-- `focus` is ignored.
example : True ∧ True := by
  constructor
  focus
    exact .intro
  focus
    exact .intro

set_option linter.unusedTactic false in
example : 1 = 1 := by
  sleep_heartbeats 1000
  rfl

-- We test that a tactic closing all remaining goals does not trigger the linter.
macro "bi_trivial" : tactic => `(tactic| (trivial; trivial))

set_option linter.style.multiGoal true in
example : True ∧ True := by
  constructor
  bi_trivial

-- Exclude `fail_if_success` and `success_if_fail_with_msg` from linting.
set_option linter.style.multiGoal true in
example : True := by
  fail_if_success done
  success_if_fail_with_msg "internal exception #4" done
  exact .intro
